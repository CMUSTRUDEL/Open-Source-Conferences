Title: MountainWest RubyConf 2013 Code Smells: Your Refactoring Cheat Codes by John Pignata
Publication date: 2020-01-28
Playlist: MWRC 2013
Description: 
	Sure, the TDD cycle is red-green-refactor but what exactly are we refactoring? We just wrote the code, it's green, and it seems reasonable to us. Let's move onto the next test. We're have a deadline, remember?
Whether we're working with code we just wrote or opening up a project for the first time, being able to listen to the hints the code is trying to give you about how it wants to be constructed is the most direct path toward successful refactoring. What the code is telling you nuanced however: no code smell is absolute and none in itself is an indication of a problem. How do we know we need to refactor? What are the code smells telling us to do? How do we balance our short terms needs of shipping our software with the long term maintainability of the code base? In this talk we'll talk through some of the classical code smells and dive into examples of how to put these smells to work for you.

Help us caption & translate this video!

http://amara.org/v/FGbr/
Captions: 
	00:00:19,850 --> 00:00:23,789
everyone good morning can y'all can you

00:00:22,050 --> 00:00:25,439
hear me yeah cool

00:00:23,789 --> 00:00:26,759
so they lured you here the Matt's

00:00:25,439 --> 00:00:29,189
keynote and now you're stuck in a

00:00:26,759 --> 00:00:31,800
refactoring talk which is pretty devious

00:00:29,189 --> 00:00:33,930
I'm sorry about that my name is John

00:00:31,800 --> 00:00:35,010
pinata I'm an engineer in New York at a

00:00:33,930 --> 00:00:38,100
company called group mate

00:00:35,010 --> 00:00:39,930
and I want to start I want to start with

00:00:38,100 --> 00:00:42,420
a quick definition coat smells are

00:00:39,930 --> 00:00:43,890
heuristics for refactoring and the

00:00:42,420 --> 00:00:46,079
concept of code smells were first

00:00:43,890 --> 00:00:47,760
introduced by Kent back on Ward

00:00:46,079 --> 00:00:49,800
Cunningham's wiki in the late 90s and

00:00:47,760 --> 00:00:52,559
then later more formally published in

00:00:49,800 --> 00:00:55,230
the factoring book in a chapter Kent

00:00:52,559 --> 00:00:57,149
Beck co-authored when we're building

00:00:55,230 --> 00:00:59,100
software our design communicates to us

00:00:57,149 --> 00:01:00,930
through resistance we may say things

00:00:59,100 --> 00:01:04,739
like our code is difficult to understand

00:01:00,930 --> 00:01:06,750
or to test or to change or to reuse and

00:01:04,739 --> 00:01:09,420
this is the this is the expression of

00:01:06,750 --> 00:01:11,310
that resistance this this resistance is

00:01:09,420 --> 00:01:14,429
really valuable it's nudging us along to

00:01:11,310 --> 00:01:16,530
refactor code smells are hints from our

00:01:14,429 --> 00:01:19,440
software about how it wants us to reduce

00:01:16,530 --> 00:01:21,090
this resistance and in this way when we

00:01:19,440 --> 00:01:22,500
listen and respond to the hints that our

00:01:21,090 --> 00:01:23,910
software is giving us about how we want

00:01:22,500 --> 00:01:27,929
it how it wants to be structured our

00:01:23,910 --> 00:01:29,220
design emerges from our systems parts so

00:01:27,929 --> 00:01:31,410
the rest of this talk is going to be a

00:01:29,220 --> 00:01:33,420
lot of code this is the system that

00:01:31,410 --> 00:01:35,369
we're going to be refactoring it is a

00:01:33,420 --> 00:01:38,750
back-end API for a mobile application

00:01:35,369 --> 00:01:41,190
that's used by Google Android devices

00:01:38,750 --> 00:01:42,869
the push daemon is the thing we're going

00:01:41,190 --> 00:01:45,259
to refactor so the feature we're looking

00:01:42,869 --> 00:01:48,090
at is we deliver push notifications to

00:01:45,259 --> 00:01:49,440
users phones so like when someone

00:01:48,090 --> 00:01:51,030
favorites your message on Twitter you

00:01:49,440 --> 00:01:53,310
get a push notification that's what

00:01:51,030 --> 00:01:54,959
we're doing here the component that

00:01:53,310 --> 00:01:56,940
actually delivers the push notifications

00:01:54,959 --> 00:01:58,590
to Android phones is this set this

00:01:56,940 --> 00:02:00,630
middle bit the push daemon which we've

00:01:58,590 --> 00:02:02,789
extracted from our application and the

00:02:00,630 --> 00:02:05,250
push daemons a little unorthodox it

00:02:02,789 --> 00:02:07,259
listens on a UDP port so it's listening

00:02:05,250 --> 00:02:09,509
for UDP datagrams it takes those

00:02:07,259 --> 00:02:11,520
datagrams extracts a message and then

00:02:09,509 --> 00:02:13,830
delivers that message through HTTP to

00:02:11,520 --> 00:02:15,390
the Google API Google then handles

00:02:13,830 --> 00:02:18,599
delivery of the message to the user's

00:02:15,390 --> 00:02:20,760
device and just to give you an idea of

00:02:18,599 --> 00:02:22,530
this code as it was discovered here it

00:02:20,760 --> 00:02:23,700
is there's a lot of it and we're gonna

00:02:22,530 --> 00:02:25,050
go through it line by line so don't

00:02:23,700 --> 00:02:27,719
worry about reading it hopefully it's

00:02:25,050 --> 00:02:29,489
somewhat legible let's just talk about

00:02:27,719 --> 00:02:32,200
what this thing does so there's two

00:02:29,489 --> 00:02:34,269
externally visible behaviors in our push

00:02:32,200 --> 00:02:36,340
there's one command called ping which is

00:02:34,269 --> 00:02:37,959
a simple health jack if we was asked the

00:02:36,340 --> 00:02:40,120
the push team in the ping it responds

00:02:37,959 --> 00:02:41,769
back with pong and then there's a

00:02:40,120 --> 00:02:42,970
command send send is the central command

00:02:41,769 --> 00:02:47,200
of our system it's the thing that

00:02:42,970 --> 00:02:49,390
delivers messages to Google's API let's

00:02:47,200 --> 00:02:50,829
test this thing so in order to see how

00:02:49,390 --> 00:02:52,359
this thing works we're actually going to

00:02:50,829 --> 00:02:54,760
run the script and we're going to use

00:02:52,359 --> 00:02:57,159
we're gonna send it UDP messages and

00:02:54,760 --> 00:02:59,049
observe its behavior externally so if we

00:02:57,159 --> 00:03:00,939
run the script reading through the

00:02:59,049 --> 00:03:02,439
script we see that it binds on a UDP

00:03:00,939 --> 00:03:04,450
port in this case it's six eight eight

00:03:02,439 --> 00:03:05,950
nine we're gonna run the script it's

00:03:04,450 --> 00:03:09,250
gonna block and wait for incoming data

00:03:05,950 --> 00:03:12,190
grams we could use netcat now netcat is

00:03:09,250 --> 00:03:13,720
a small UNIX utility for sending

00:03:12,190 --> 00:03:15,940
messages across the network and it has a

00:03:13,720 --> 00:03:17,470
dash u flag which means UDP so we're

00:03:15,940 --> 00:03:19,209
gonna send messages to our local host

00:03:17,470 --> 00:03:21,189
port six eight eight nine we're gonna

00:03:19,209 --> 00:03:22,930
just type in ping and hit enter it's

00:03:21,189 --> 00:03:25,030
supposed to respond back with pong which

00:03:22,930 --> 00:03:27,370
it does so our first test is passing our

00:03:25,030 --> 00:03:29,470
first manual test next we're going to

00:03:27,370 --> 00:03:31,180
synthesize a send command send is a

00:03:29,470 --> 00:03:33,700
little more complicated so send takes

00:03:31,180 --> 00:03:36,549
parameters so instead of just a command

00:03:33,700 --> 00:03:38,620
send we also include two parameters the

00:03:36,549 --> 00:03:40,989
first is a registration ID this

00:03:38,620 --> 00:03:43,449
registration ID represents a physical

00:03:40,989 --> 00:03:45,430
Android phone in the field like so an

00:03:43,449 --> 00:03:47,290
Android device registers with Google's

00:03:45,430 --> 00:03:49,180
API and Google says okay here's your

00:03:47,290 --> 00:03:51,190
token here's how an application can

00:03:49,180 --> 00:03:52,720
address you the phone then passes that

00:03:51,190 --> 00:03:55,329
token to us and we use it to send it

00:03:52,720 --> 00:03:56,889
notifications the second parameter is

00:03:55,329 --> 00:04:00,609
just some text it's just some text we

00:03:56,889 --> 00:04:01,959
want to deliver into the phone since

00:04:00,609 --> 00:04:03,639
we're testing this as a black box

00:04:01,959 --> 00:04:05,199
they're really the only way we could be

00:04:03,639 --> 00:04:07,269
sure that this thing works is to send

00:04:05,199 --> 00:04:08,859
this message and use an actual

00:04:07,269 --> 00:04:12,129
registration ID of an actual Google

00:04:08,859 --> 00:04:14,440
Google phone if we do that and hit enter

00:04:12,129 --> 00:04:16,389
we then check our physical phone and we

00:04:14,440 --> 00:04:19,870
get the message so our system works as

00:04:16,389 --> 00:04:21,010
it is and our second test passes so

00:04:19,870 --> 00:04:22,479
we're going to be running this test a

00:04:21,010 --> 00:04:24,729
lot we're gonna be refactoring in many

00:04:22,479 --> 00:04:26,229
small steps and we want instant feedback

00:04:24,729 --> 00:04:27,520
we want to be able to run this thing in

00:04:26,229 --> 00:04:29,889
the background and for it to throw an

00:04:27,520 --> 00:04:31,539
alert at us if we if we break it so

00:04:29,889 --> 00:04:33,099
we're gonna write the outer most

00:04:31,539 --> 00:04:34,510
possible coverage we're gonna do the

00:04:33,099 --> 00:04:36,120
same thing we did with netcat and our

00:04:34,510 --> 00:04:39,039
eyes but we're gonna do it using r-spec

00:04:36,120 --> 00:04:41,080
so in this test we're cheating a little

00:04:39,039 --> 00:04:42,729
bit because our script body

00:04:41,080 --> 00:04:43,930
we don't have an object definition we

00:04:42,729 --> 00:04:45,200
don't even have any methods we just have

00:04:43,930 --> 00:04:47,450
a raw script that run

00:04:45,200 --> 00:04:50,150
it's because of that we're gonna use the

00:04:47,450 --> 00:04:52,550
Ruby load method to load the thing in a

00:04:50,150 --> 00:04:55,220
background thread and we're going to

00:04:52,550 --> 00:04:57,170
then send it messages with r-spec and

00:04:55,220 --> 00:04:59,360
assert on the behavior

00:04:57,170 --> 00:05:00,410
now we could fork a process instead of

00:04:59,360 --> 00:05:02,090
using a thread but we're going to use a

00:05:00,410 --> 00:05:03,800
thread here because we're in the same

00:05:02,090 --> 00:05:06,710
process as the thing that we're testing

00:05:03,800 --> 00:05:09,650
now which means we can mock and like

00:05:06,710 --> 00:05:11,300
mock the Google API for instance so

00:05:09,650 --> 00:05:12,890
here's the first test this is the same

00:05:11,300 --> 00:05:14,270
thing we did with netcat instead of

00:05:12,890 --> 00:05:16,100
using netcat we're going to use Ruby so

00:05:14,270 --> 00:05:17,300
we're gonna say socket send ping and

00:05:16,100 --> 00:05:18,980
then we're gonna assert that the

00:05:17,300 --> 00:05:20,120
response should be pong same thing we

00:05:18,980 --> 00:05:23,390
did with our eyes but now we're

00:05:20,120 --> 00:05:24,350
automating it here's the send test same

00:05:23,390 --> 00:05:27,920
thing we did with net cat we're gonna

00:05:24,350 --> 00:05:30,920
send in a prefab message so send token

00:05:27,920 --> 00:05:33,110
with some text but we can't automate

00:05:30,920 --> 00:05:34,730
physically checking a phone right and we

00:05:33,110 --> 00:05:36,110
don't really want to have to we want to

00:05:34,730 --> 00:05:38,120
be able to test this as a self-contained

00:05:36,110 --> 00:05:39,800
unit so what we're going to do is we're

00:05:38,120 --> 00:05:42,800
going to use web mock to mock the Google

00:05:39,800 --> 00:05:43,970
API and our responsibility is just hit

00:05:42,800 --> 00:05:46,520
the service boundary with the right

00:05:43,970 --> 00:05:48,080
parameters so we're gonna send in this

00:05:46,520 --> 00:05:50,990
command and then we're going to assert

00:05:48,080 --> 00:05:52,310
that the right parameters come out and

00:05:50,990 --> 00:05:54,380
now we could run the test and the test

00:05:52,310 --> 00:05:56,630
passes and now we could use auto test or

00:05:54,380 --> 00:05:57,800
something in the background to continue

00:05:56,630 --> 00:05:59,810
running this in the background as we

00:05:57,800 --> 00:06:01,160
refactor so now we can actually start

00:05:59,810 --> 00:06:04,430
refactoring we can go back to the

00:06:01,160 --> 00:06:06,170
original patient like I said there's no

00:06:04,430 --> 00:06:07,640
class definition here there's no method

00:06:06,170 --> 00:06:09,500
definition here but we see our first

00:06:07,640 --> 00:06:12,740
code smell has to do with the fact that

00:06:09,500 --> 00:06:14,090
we have one long method so it's long

00:06:12,740 --> 00:06:15,530
that it's not actually a method but our

00:06:14,090 --> 00:06:17,600
script body is sort of that the main

00:06:15,530 --> 00:06:19,460
method of our program and this method is

00:06:17,600 --> 00:06:21,500
really really long it's 30 lines of code

00:06:19,460 --> 00:06:23,240
that's doing all signs kinds of sort of

00:06:21,500 --> 00:06:25,640
things so let's go through it line by

00:06:23,240 --> 00:06:27,320
line at the top we're instantiating some

00:06:25,640 --> 00:06:29,960
collaborators so we're instantiating a

00:06:27,320 --> 00:06:31,550
queue in HTTP client and a UDP socket

00:06:29,960 --> 00:06:33,650
three things that seem to have nothing

00:06:31,550 --> 00:06:35,210
to do with each other next we're

00:06:33,650 --> 00:06:37,760
actually creating a worker thread pool

00:06:35,210 --> 00:06:40,160
so I assume we're using JRuby or

00:06:37,760 --> 00:06:42,080
Rubinius like moths just recommended and

00:06:40,160 --> 00:06:44,480
we are doing this because we want to do

00:06:42,080 --> 00:06:46,520
some work in the background so here

00:06:44,480 --> 00:06:50,390
we're using the queue to coordinate our

00:06:46,520 --> 00:06:52,100
work with the worker threads next in the

00:06:50,390 --> 00:06:53,960
threads we're actually creating a

00:06:52,100 --> 00:06:56,180
service request to the Google API and

00:06:53,960 --> 00:06:57,120
we're sending we're sending them the

00:06:56,180 --> 00:07:00,270
data that comes down to

00:06:57,120 --> 00:07:01,650
you finally in the middle of script

00:07:00,270 --> 00:07:03,120
we're finally getting to binding to our

00:07:01,650 --> 00:07:04,650
socket so here's our socket and there's

00:07:03,120 --> 00:07:08,850
a port six eight eight nine again just

00:07:04,650 --> 00:07:11,220
hard-coded in there in but beneath that

00:07:08,850 --> 00:07:12,600
we are pulling the socket for Datagram

00:07:11,220 --> 00:07:15,330
so we're seeing if we have incoming data

00:07:12,600 --> 00:07:16,740
grams if we do we're then dispatching a

00:07:15,330 --> 00:07:18,030
command based upon what's in there if

00:07:16,740 --> 00:07:19,139
it's ping we're gonna go one way if it's

00:07:18,030 --> 00:07:22,080
send we're gonna go the other way and

00:07:19,139 --> 00:07:24,330
then finally in send we're doing all

00:07:22,080 --> 00:07:25,919
kinds of gross string gymnastics to

00:07:24,330 --> 00:07:27,690
extract parameters so that we could

00:07:25,919 --> 00:07:30,150
create this JSON body that Google

00:07:27,690 --> 00:07:31,440
expects from us on the other side so to

00:07:30,150 --> 00:07:32,729
begin organizing this we're going to

00:07:31,440 --> 00:07:34,919
need to break it down into smaller

00:07:32,729 --> 00:07:36,810
pieces and our first move is going to be

00:07:34,919 --> 00:07:38,550
to replace this method with a method

00:07:36,810 --> 00:07:40,620
object we're just going to wrap this

00:07:38,550 --> 00:07:42,449
amorphous script body in a method so we

00:07:40,620 --> 00:07:44,400
can give it some shape so because we

00:07:42,449 --> 00:07:46,380
only have one method we're gonna create

00:07:44,400 --> 00:07:48,060
a method called push demon we have one

00:07:46,380 --> 00:07:49,979
object sorry that object we've one

00:07:48,060 --> 00:07:52,169
object in our system so we'll just use

00:07:49,979 --> 00:07:55,740
the same name as we saw on our diagram

00:07:52,169 --> 00:07:57,330
and the first the mechanics of replaced

00:07:55,740 --> 00:07:58,590
method with method object dictate that

00:07:57,330 --> 00:08:00,120
the first move is that we take the

00:07:58,590 --> 00:08:01,770
locals that are used in the method and

00:08:00,120 --> 00:08:04,500
we promote them the instance variables

00:08:01,770 --> 00:08:06,180
within the object we're creating next

00:08:04,500 --> 00:08:07,740
we're just going to take the remainder

00:08:06,180 --> 00:08:09,479
of the script body and we're going to

00:08:07,740 --> 00:08:11,220
wrap it in a method called start and

00:08:09,479 --> 00:08:12,330
we're gonna take the references we had

00:08:11,220 --> 00:08:14,520
to the locals and we're going to update

00:08:12,330 --> 00:08:15,630
it to instance variables so that we can

00:08:14,520 --> 00:08:18,479
use the instance variables we just

00:08:15,630 --> 00:08:19,650
created so we still have our long method

00:08:18,479 --> 00:08:21,690
at least now it has a name it's called

00:08:19,650 --> 00:08:24,050
start and now we could begin breaking

00:08:21,690 --> 00:08:26,280
that thing down at the smaller chunks so

00:08:24,050 --> 00:08:28,289
start is doing a lot there's three

00:08:26,280 --> 00:08:29,639
statement bodies in start we're spawning

00:08:28,289 --> 00:08:31,440
our workers and that will first one

00:08:29,639 --> 00:08:32,940
we're binding in the middle one and then

00:08:31,440 --> 00:08:35,789
below we're looping and processing

00:08:32,940 --> 00:08:37,169
incoming requests so let's extract these

00:08:35,789 --> 00:08:39,209
through statement bodies into private

00:08:37,169 --> 00:08:40,620
methods and let's leave references to

00:08:39,209 --> 00:08:42,450
these project methods in start so it's

00:08:40,620 --> 00:08:44,730
somewhat coherent so we're spawning

00:08:42,450 --> 00:08:47,279
workers which is just that same

00:08:44,730 --> 00:08:51,360
statement of body we're binding the

00:08:47,279 --> 00:08:53,310
socket and we're processing requests so

00:08:51,360 --> 00:08:56,520
here is push demon with the private API

00:08:53,310 --> 00:08:58,350
collapsed post extraction and we still

00:08:56,520 --> 00:09:00,180
have a lot more extraction to do but we

00:08:58,350 --> 00:09:01,709
have a choice we can continue extracting

00:09:00,180 --> 00:09:03,720
into smaller and smaller methods or we

00:09:01,709 --> 00:09:05,430
can look at push demon as an object and

00:09:03,720 --> 00:09:08,940
see if its responsibilities make sense I

00:09:05,430 --> 00:09:10,620
would assert that in this case push

00:09:08,940 --> 00:09:12,270
demon has a lot of reasons to change

00:09:10,620 --> 00:09:13,650
so here's a list of just random things

00:09:12,270 --> 00:09:15,540
that could possibly change about push

00:09:13,650 --> 00:09:16,920
teaming the items in this list have only

00:09:15,540 --> 00:09:19,470
a tangential relationship with each

00:09:16,920 --> 00:09:21,510
other and that's a code smell called

00:09:19,470 --> 00:09:24,060
divergent change it tells us that if we

00:09:21,510 --> 00:09:25,440
have an object and the object has many

00:09:24,060 --> 00:09:27,510
reasons to change that seem unrelated

00:09:25,440 --> 00:09:29,130
it's likely that the object has too many

00:09:27,510 --> 00:09:31,380
responsibilities so we're going to

00:09:29,130 --> 00:09:33,360
extract objects from our push team an

00:09:31,380 --> 00:09:34,800
object will start with the worker

00:09:33,360 --> 00:09:36,060
because the worker is pretty stuff

00:09:34,800 --> 00:09:39,360
contained and it seems like its own

00:09:36,060 --> 00:09:41,400
concept so our worker here is using the

00:09:39,360 --> 00:09:43,680
cue and using the client uses the cue to

00:09:41,400 --> 00:09:45,750
get coordinate work amongst its worker

00:09:43,680 --> 00:09:46,560
threads and it uses the client to post

00:09:45,750 --> 00:09:48,720
to the Google API

00:09:46,560 --> 00:09:50,190
so we need these two collaborators in

00:09:48,720 --> 00:09:51,990
our new object so we're gonna extract an

00:09:50,190 --> 00:09:54,390
object called worker workers going to

00:09:51,990 --> 00:09:55,770
have a cue and a client we then go back

00:09:54,390 --> 00:09:57,180
to the push daemon and now we can

00:09:55,770 --> 00:09:58,530
replace our cue in the client with a

00:09:57,180 --> 00:10:00,060
call to worker so now we're

00:09:58,530 --> 00:10:01,320
instantiating a new worker and that's

00:10:00,060 --> 00:10:03,720
going to encapsulate those two other

00:10:01,320 --> 00:10:04,830
collaborators next we have to look

00:10:03,720 --> 00:10:06,600
through our code to make sure we're not

00:10:04,830 --> 00:10:08,640
using those instance variables we just

00:10:06,600 --> 00:10:10,410
nuked and process requests were

00:10:08,640 --> 00:10:12,540
shoveling stuff directly into the queue

00:10:10,410 --> 00:10:14,760
here which we can't do anymore because

00:10:12,540 --> 00:10:16,560
we don't have access to the queue but we

00:10:14,760 --> 00:10:18,120
do need some way to submit work into the

00:10:16,560 --> 00:10:20,670
worker so what we're gonna do is we're

00:10:18,120 --> 00:10:23,940
gonna add a method to worker the shovel

00:10:20,670 --> 00:10:25,920
method to submit work into it and this

00:10:23,940 --> 00:10:28,190
will just allow us to give the worker a

00:10:25,920 --> 00:10:30,480
piece of work to do it in the background

00:10:28,190 --> 00:10:32,430
we go back in the process request and we

00:10:30,480 --> 00:10:34,260
flipped queue to worker okay so now

00:10:32,430 --> 00:10:36,000
queue is gone now we can actually

00:10:34,260 --> 00:10:38,460
extract the method we want to extract so

00:10:36,000 --> 00:10:39,780
spawn workers is still in push daemon we

00:10:38,460 --> 00:10:41,610
could move that method into worker now

00:10:39,780 --> 00:10:43,170
so we're gonna move it into worker we're

00:10:41,610 --> 00:10:44,460
gonna call it spawn because spawn worker

00:10:43,170 --> 00:10:46,230
would be redundant and we're gonna

00:10:44,460 --> 00:10:47,870
parameterize count but other than that

00:10:46,230 --> 00:10:50,430
we're gonna leave it unchanged tray now

00:10:47,870 --> 00:10:52,620
in push daemon we no longer call this

00:10:50,430 --> 00:10:53,910
local it goes away and instead we tell

00:10:52,620 --> 00:10:56,460
our worker to spawn and we give it some

00:10:53,910 --> 00:11:00,420
unit of work unit of concurrency in this

00:10:56,460 --> 00:11:03,060
case 10 next step is this UDP demon that

00:11:00,420 --> 00:11:04,320
UDP sockets scuse me so UDP socket and

00:11:03,060 --> 00:11:09,330
we're using it a lot in this in this

00:11:04,320 --> 00:11:10,680
program we're binding it to a port we're

00:11:09,330 --> 00:11:11,970
receiving data through it and we're

00:11:10,680 --> 00:11:13,290
sending data through it so we're pretty

00:11:11,970 --> 00:11:16,800
concerned with the internals of this

00:11:13,290 --> 00:11:18,300
socket and our object should be talking

00:11:16,800 --> 00:11:19,770
at a higher level of abstraction we want

00:11:18,300 --> 00:11:21,000
to raise a level of conversation between

00:11:19,770 --> 00:11:22,410
these two objects we'd want to be

00:11:21,000 --> 00:11:23,770
dealing with a low-level socket we want

00:11:22,410 --> 00:11:26,380
to be dealing with something higher

00:11:23,770 --> 00:11:29,200
so let's create a UDP server UDP server

00:11:26,380 --> 00:11:30,460
will expose a socket that it'll hide the

00:11:29,200 --> 00:11:32,260
socket rather the opposite

00:11:30,460 --> 00:11:34,870
sockets an implementation detail of the

00:11:32,260 --> 00:11:37,060
UDP server next we're going to look at

00:11:34,870 --> 00:11:38,890
these three verbs bind receive send and

00:11:37,060 --> 00:11:40,720
we'll just give UDP server those

00:11:38,890 --> 00:11:42,820
capabilities so we'll add three methods

00:11:40,720 --> 00:11:45,940
bind receive and send and it'll pretty

00:11:42,820 --> 00:11:47,980
much just wrap a socket for now so we

00:11:45,940 --> 00:11:50,650
can go back into push daemon and we can

00:11:47,980 --> 00:11:52,210
flip our socket to a server and now bind

00:11:50,650 --> 00:11:55,120
goes away we don't need this anymore we

00:11:52,210 --> 00:11:56,110
just tell the server to bind and process

00:11:55,120 --> 00:11:59,860
request we have a couple of references

00:11:56,110 --> 00:12:01,600
to socket those get updated to server so

00:11:59,860 --> 00:12:03,100
we have another object now but I would

00:12:01,600 --> 00:12:04,630
assert that we didn't achieve our goal

00:12:03,100 --> 00:12:06,340
our goal was to raise the level of

00:12:04,630 --> 00:12:08,050
discourse between these two objects we

00:12:06,340 --> 00:12:10,210
wanted to hide the fact that we were

00:12:08,050 --> 00:12:12,760
dealing with a socket and all we did was

00:12:10,210 --> 00:12:15,100
introduce another step in the chain we

00:12:12,760 --> 00:12:17,170
introduced a middleman essentially we

00:12:15,100 --> 00:12:19,330
know a lot about how UDP server does its

00:12:17,170 --> 00:12:21,280
job we know it uses a socket we could

00:12:19,330 --> 00:12:23,650
guess that but these details are leaking

00:12:21,280 --> 00:12:25,540
out of the UDP server this is an example

00:12:23,650 --> 00:12:26,680
of inappropriate intimacy we are

00:12:25,540 --> 00:12:29,230
inappropriately intimate with the

00:12:26,680 --> 00:12:30,670
internals of UDP server and part of the

00:12:29,230 --> 00:12:32,560
reason is in this sequence diagram what

00:12:30,670 --> 00:12:34,510
we're doing is we're telling it to bind

00:12:32,560 --> 00:12:36,790
to a port and then we're pulling it to

00:12:34,510 --> 00:12:38,050
receive data so we're constantly asking

00:12:36,790 --> 00:12:41,230
me TP server do you have new data yet

00:12:38,050 --> 00:12:42,580
blocking it comes back it has data UDP

00:12:41,230 --> 00:12:44,320
server can't really do much on its own

00:12:42,580 --> 00:12:47,290
without the push daemon kind of being

00:12:44,320 --> 00:12:49,390
its puppeteer so we could rearrange

00:12:47,290 --> 00:12:51,460
these objects though in such a way where

00:12:49,390 --> 00:12:53,380
they sort of tell each other to do

00:12:51,460 --> 00:12:56,320
things rather than us asking it and like

00:12:53,380 --> 00:12:58,840
forcing it to do things we can create an

00:12:56,320 --> 00:13:01,330
interface where push daemon subscribes

00:12:58,840 --> 00:13:04,120
its intent that it wants to be alerted

00:13:01,330 --> 00:13:06,040
when new requests come in so we're going

00:13:04,120 --> 00:13:07,420
to have a listen we're still going to

00:13:06,040 --> 00:13:08,890
have to tell it what port it's going to

00:13:07,420 --> 00:13:11,440
use and then we're going to tell UDP

00:13:08,890 --> 00:13:14,230
server tell us when new information is

00:13:11,440 --> 00:13:16,060
available and call a method on us so

00:13:14,230 --> 00:13:17,530
let's let's go through that so we have

00:13:16,060 --> 00:13:20,290
to update push daemon for our new

00:13:17,530 --> 00:13:22,150
arrangement the first thing we have to

00:13:20,290 --> 00:13:24,760
do is I mentioned we wanted to indicate

00:13:22,150 --> 00:13:26,860
our interest in UDP server to let it

00:13:24,760 --> 00:13:29,110
know that we want new requests so to do

00:13:26,860 --> 00:13:30,460
that we're going to pass in ourselves in

00:13:29,110 --> 00:13:32,650
the constructor and the convention here

00:13:30,460 --> 00:13:34,240
is going to be when you create a new UDP

00:13:32,650 --> 00:13:35,860
server you pass in the application

00:13:34,240 --> 00:13:37,940
that's interested in

00:13:35,860 --> 00:13:39,200
next we don't know exactly where this is

00:13:37,940 --> 00:13:40,640
gonna go but we know we don't want to do

00:13:39,200 --> 00:13:43,250
this anymore we don't want to pull the

00:13:40,640 --> 00:13:44,060
socket and get data from the socket so

00:13:43,250 --> 00:13:45,500
we're gonna replace that we're gonna

00:13:44,060 --> 00:13:46,430
just have a method called listen and

00:13:45,500 --> 00:13:49,550
we'll figure out what that does in a

00:13:46,430 --> 00:13:51,800
moment next these two things look the

00:13:49,550 --> 00:13:53,120
same now we're telling the server to

00:13:51,800 --> 00:13:54,980
bind and then we're telling it to listen

00:13:53,120 --> 00:13:56,870
bind is kind of its own problem we don't

00:13:54,980 --> 00:13:57,980
care what it has to do to listen we just

00:13:56,870 --> 00:13:59,209
want to provide it a port number so

00:13:57,980 --> 00:14:03,050
we're gonna collapse those into one

00:13:59,209 --> 00:14:04,250
method call next process requests the

00:14:03,050 --> 00:14:06,290
first thing it does is it asks the

00:14:04,250 --> 00:14:07,370
server do you have any data we wanted to

00:14:06,290 --> 00:14:08,570
couple it from that we don't want

00:14:07,370 --> 00:14:10,220
process requests to have to worry about

00:14:08,570 --> 00:14:12,110
that so we're gonna add a parameter of

00:14:10,220 --> 00:14:13,310
data and process request is going to

00:14:12,110 --> 00:14:15,200
assume that if someone calls it you're

00:14:13,310 --> 00:14:16,279
gonna have data for it to process and

00:14:15,200 --> 00:14:18,260
we're going to promote it into our

00:14:16,279 --> 00:14:20,420
public API so this will be the method

00:14:18,260 --> 00:14:23,050
that gets called by UDP server when

00:14:20,420 --> 00:14:25,160
there's a new request to process and

00:14:23,050 --> 00:14:26,750
process request is a really bulky name

00:14:25,160 --> 00:14:28,490
that I don't really like so I'm gonna

00:14:26,750 --> 00:14:31,250
change it I'm gonna steal a convention

00:14:28,490 --> 00:14:32,570
from Rack and call it call at first

00:14:31,250 --> 00:14:33,829
glance it seems like process requests

00:14:32,570 --> 00:14:35,930
the money is a better name it's a longer

00:14:33,829 --> 00:14:37,459
name maybe more descriptive but I expect

00:14:35,930 --> 00:14:40,790
future developers who read this code

00:14:37,459 --> 00:14:42,350
will be familiar with racks API so if

00:14:40,790 --> 00:14:44,029
they see call they're gonna instantly

00:14:42,350 --> 00:14:46,149
sort of intuitively understand the

00:14:44,029 --> 00:14:48,620
arrangement between these two objects

00:14:46,149 --> 00:14:50,329
okay next we're going to update UDP

00:14:48,620 --> 00:14:52,399
server for this new arrangement so we

00:14:50,329 --> 00:14:54,170
before we passed ourselves into the

00:14:52,399 --> 00:14:55,640
initializer of UDP server so we have to

00:14:54,170 --> 00:14:57,740
change the method signature of our

00:14:55,640 --> 00:15:00,410
constructor we'll do that we'll add the

00:14:57,740 --> 00:15:03,230
app next we have to update bind so we

00:15:00,410 --> 00:15:05,660
changed its name to listen and we added

00:15:03,230 --> 00:15:07,040
some behavior so it still binds the

00:15:05,660 --> 00:15:09,050
socket that's the detail of what it has

00:15:07,040 --> 00:15:11,029
to do to begin listening but we also

00:15:09,050 --> 00:15:13,190
added this loop so that loop that was in

00:15:11,029 --> 00:15:15,079
push daemon is now here and it's

00:15:13,190 --> 00:15:16,910
responsible for polling its socket

00:15:15,079 --> 00:15:23,120
itself and when it gets new data it'll

00:15:16,910 --> 00:15:25,160
call our app with that data so finally

00:15:23,120 --> 00:15:26,480
back to push daemon most of our dirty

00:15:25,160 --> 00:15:28,730
laundry in terms of our public our

00:15:26,480 --> 00:15:30,050
private API is gone but now we have this

00:15:28,730 --> 00:15:32,420
call method which is a little bit of a

00:15:30,050 --> 00:15:34,100
disaster the first thing that draws the

00:15:32,420 --> 00:15:36,769
eye is the fact that call is essentially

00:15:34,100 --> 00:15:38,089
a large case statement and case

00:15:36,769 --> 00:15:39,320
statement was one of the canonical code

00:15:38,089 --> 00:15:40,100
smells from a factory it was the switch

00:15:39,320 --> 00:15:42,350
statement in Java

00:15:40,100 --> 00:15:44,260
the thing that Beck and Fowler were

00:15:42,350 --> 00:15:46,370
concerned with was when you have a

00:15:44,260 --> 00:15:48,110
conditional like this it has a tendency

00:15:46,370 --> 00:15:49,100
to chlorate itself in your codebase if

00:15:48,110 --> 00:15:50,690
you have occasion to check

00:15:49,100 --> 00:15:52,460
for a type or a type code or something

00:15:50,690 --> 00:15:53,990
like that it's likely that you're going

00:15:52,460 --> 00:15:56,360
to do that in multiple places

00:15:53,990 --> 00:15:57,740
I think our use of case is a little

00:15:56,360 --> 00:15:59,870
different it's almost defensible like

00:15:57,740 --> 00:16:01,730
we're not weird we're testing we're

00:15:59,870 --> 00:16:03,230
looking at data coming in from over a

00:16:01,730 --> 00:16:05,300
network and we're making a determination

00:16:03,230 --> 00:16:06,230
based upon that data something's gonna

00:16:05,300 --> 00:16:08,090
have to make this determination

00:16:06,230 --> 00:16:10,550
something's gonna have to say is the

00:16:08,090 --> 00:16:12,290
command pingers the command send whether

00:16:10,550 --> 00:16:14,330
it's a case or another structure it

00:16:12,290 --> 00:16:16,280
seems a little immaterial but our bigger

00:16:14,330 --> 00:16:18,230
problem is in the branches of this case

00:16:16,280 --> 00:16:20,240
statement is a lot of behavior and a lot

00:16:18,230 --> 00:16:22,340
of like really nitty-gritty like string

00:16:20,240 --> 00:16:23,840
manipulation behavior and we can't unit

00:16:22,340 --> 00:16:25,700
test this stuff outside of the context

00:16:23,840 --> 00:16:28,010
of a push demon which feels completely

00:16:25,700 --> 00:16:29,510
wrong so let's try to shake that

00:16:28,010 --> 00:16:32,030
behavior loose we're gonna want to

00:16:29,510 --> 00:16:34,700
collapse this case statement by making

00:16:32,030 --> 00:16:36,770
its branches identical and replacing the

00:16:34,700 --> 00:16:38,810
behavior in these branches with objects

00:16:36,770 --> 00:16:39,770
that quack to the same interface so

00:16:38,810 --> 00:16:41,450
we're essentially going to replace this

00:16:39,770 --> 00:16:44,390
conditional with polymorphism it's gonna

00:16:41,450 --> 00:16:45,800
take a few moves to get there the first

00:16:44,390 --> 00:16:47,330
thing we need to do is here's the here's

00:16:45,800 --> 00:16:49,640
what the server service does when it

00:16:47,330 --> 00:16:53,330
gets a ping it sends back pong across

00:16:49,640 --> 00:16:54,610
the network using this data stuff we're

00:16:53,330 --> 00:16:56,900
going to extract that into an object

00:16:54,610 --> 00:16:58,640
because we have a worker concept in our

00:16:56,900 --> 00:17:01,610
system let's create a job concept let's

00:16:58,640 --> 00:17:03,230
extend the metaphor so we will create a

00:17:01,610 --> 00:17:05,780
jobs namespace and we'll add a class

00:17:03,230 --> 00:17:07,760
ping ping what needs as data and server

00:17:05,780 --> 00:17:09,470
to do its job so we'll just add those to

00:17:07,760 --> 00:17:11,750
the initializer and then when we call

00:17:09,470 --> 00:17:14,090
run it will send it'll still send data

00:17:11,750 --> 00:17:17,090
across the network and we go back to

00:17:14,090 --> 00:17:18,740
call we take this statement and we just

00:17:17,090 --> 00:17:21,200
get rid of it and replace it with our

00:17:18,740 --> 00:17:23,630
jobs class and call run so not a win at

00:17:21,200 --> 00:17:26,060
all now we have more code but hopefully

00:17:23,630 --> 00:17:27,110
this shrink soon let's look at send now

00:17:26,060 --> 00:17:28,700
so we're going to do the same thing with

00:17:27,110 --> 00:17:30,560
send we're gonna forklift this out of

00:17:28,700 --> 00:17:34,220
push daemon and into its own job class

00:17:30,560 --> 00:17:37,070
so send now the semantics of send are

00:17:34,220 --> 00:17:39,920
such that the return value of run is a

00:17:37,070 --> 00:17:41,960
JSON string so the semantics of send and

00:17:39,920 --> 00:17:43,610
ping are completely different in ping we

00:17:41,960 --> 00:17:45,140
rely on the side effect rely on the fact

00:17:43,610 --> 00:17:47,840
that when we call run it's going to make

00:17:45,140 --> 00:17:50,030
that system call and send data across

00:17:47,840 --> 00:17:50,990
the network to the client run is

00:17:50,030 --> 00:17:53,180
actually just doing some string

00:17:50,990 --> 00:17:55,760
manipulation and returning some JSON so

00:17:53,180 --> 00:17:57,260
we're kind of stuck now all right we

00:17:55,760 --> 00:17:59,690
have these two branches that are

00:17:57,260 --> 00:18:01,010
different and we can't eliminate this

00:17:59,690 --> 00:18:01,740
conditional unless these branches are

00:18:01,010 --> 00:18:04,320
the same

00:18:01,740 --> 00:18:05,490
to make these branches identical we have

00:18:04,320 --> 00:18:07,590
to zoom out and look at the larger

00:18:05,490 --> 00:18:09,450
system we made this extraction before

00:18:07,590 --> 00:18:11,220
this worker and we just sort of like

00:18:09,450 --> 00:18:13,920
happily plunked all these Google API

00:18:11,220 --> 00:18:16,320
details in there and that seems really

00:18:13,920 --> 00:18:18,750
limiting now in retrospect we have a

00:18:16,320 --> 00:18:20,220
concept of jobs and we have a worker it

00:18:18,750 --> 00:18:22,080
would be much more natural if the worker

00:18:20,220 --> 00:18:24,320
could just work arbitrary jobs rather

00:18:22,080 --> 00:18:28,860
than being tied to the context of use of

00:18:24,320 --> 00:18:30,720
posting JSON to Google so let's extract

00:18:28,860 --> 00:18:32,700
some of that dirty laundry I'm going to

00:18:30,720 --> 00:18:34,290
take these details these Google details

00:18:32,700 --> 00:18:37,350
and we're just going to move them into

00:18:34,290 --> 00:18:39,179
send for now so send is going to change

00:18:37,350 --> 00:18:41,700
a bit instead of returning JSON it's

00:18:39,179 --> 00:18:43,860
going to do the post across the network

00:18:41,700 --> 00:18:46,620
we're gonna memorize an HTTP client

00:18:43,860 --> 00:18:48,510
instance and send and ping now have the

00:18:46,620 --> 00:18:50,910
same semantics when you call run it

00:18:48,510 --> 00:18:52,440
makes an operate takes an operation that

00:18:50,910 --> 00:18:54,840
does some unit of work and we don't have

00:18:52,440 --> 00:18:57,720
to worry about the return value worker

00:18:54,840 --> 00:18:59,880
now is much much slimmer instead of

00:18:57,720 --> 00:19:02,820
being tied to Google this is now just a

00:18:59,880 --> 00:19:04,679
jobs runner so it runs in it's it

00:19:02,820 --> 00:19:06,450
monitors this queue and in each

00:19:04,679 --> 00:19:08,429
background thread it pops off the queue

00:19:06,450 --> 00:19:10,350
it expects jobs to come down that queue

00:19:08,429 --> 00:19:12,750
when a job comes down it just calls run

00:19:10,350 --> 00:19:15,510
on it so that's the interface this any

00:19:12,750 --> 00:19:16,740
job that speaks to this interface we

00:19:15,510 --> 00:19:20,970
could use the worker to execute in the

00:19:16,740 --> 00:19:22,200
background so now in push daemon we no

00:19:20,970 --> 00:19:24,450
longer have to worry about calling run

00:19:22,200 --> 00:19:25,470
that's workers responsibility and we no

00:19:24,450 --> 00:19:28,350
longer have to worry about the return

00:19:25,470 --> 00:19:30,179
value of send so that all disappears so

00:19:28,350 --> 00:19:32,070
now we have a case statement with pretty

00:19:30,179 --> 00:19:33,450
identical branches the same you know we

00:19:32,070 --> 00:19:35,550
have a different class we different

00:19:33,450 --> 00:19:38,130
object there but it's the same method

00:19:35,550 --> 00:19:40,980
being called with the same signature and

00:19:38,130 --> 00:19:42,150
we essentially have a factory so the

00:19:40,980 --> 00:19:43,860
case statement is just returning an

00:19:42,150 --> 00:19:47,250
instance depending on what command is

00:19:43,860 --> 00:19:49,320
paste pea sent to it and then once we

00:19:47,250 --> 00:19:50,640
get a job instance we just shovel that

00:19:49,320 --> 00:19:53,160
into the worker and the worker runs the

00:19:50,640 --> 00:19:54,750
job in the background so now that we

00:19:53,160 --> 00:19:56,400
have this factory and it's clear that

00:19:54,750 --> 00:19:59,040
that's what it is we've we've had all

00:19:56,400 --> 00:20:01,290
along we can move this into an explicit

00:19:59,040 --> 00:20:03,870
factory so we're just going to copy it

00:20:01,290 --> 00:20:06,030
into a method we'll add a method to the

00:20:03,870 --> 00:20:08,250
jobs met a class called factory and it's

00:20:06,030 --> 00:20:09,990
just going to do the same work so now we

00:20:08,250 --> 00:20:11,250
could finally think about do we want to

00:20:09,990 --> 00:20:13,080
just get rid of this case statement

00:20:11,250 --> 00:20:15,160
there's a compelling argument to get rid

00:20:13,080 --> 00:20:17,470
of it if we keep it around in future

00:20:15,160 --> 00:20:19,060
factorings it's possible that behavior

00:20:17,470 --> 00:20:20,980
is gonna slip into these branches and we

00:20:19,060 --> 00:20:22,480
don't want that we want the interface to

00:20:20,980 --> 00:20:26,020
be standard and we want all jobs to

00:20:22,480 --> 00:20:27,010
quack the same way so let's make a move

00:20:26,020 --> 00:20:28,810
and get rid of it we're gonna go

00:20:27,010 --> 00:20:30,400
backwards a little bit to go forwards so

00:20:28,810 --> 00:20:33,850
we're gonna replace our case with with a

00:20:30,400 --> 00:20:37,420
hash the hash is a map from a command to

00:20:33,850 --> 00:20:39,310
a job class in our factory we get the

00:20:37,420 --> 00:20:41,280
incoming data from this from the client

00:20:39,310 --> 00:20:43,600
we do some string manipulation for now

00:20:41,280 --> 00:20:45,370
we then ask the class do you have a

00:20:43,600 --> 00:20:47,320
class we ask for their jobs hash do you

00:20:45,370 --> 00:20:48,610
have a class for this command if you do

00:20:47,320 --> 00:20:51,160
we instantiate it and return it to the

00:20:48,610 --> 00:20:53,200
caller now in our push daemon instead of

00:20:51,160 --> 00:20:54,340
having this case that Slim's down and we

00:20:53,200 --> 00:20:56,350
just call our factory and the factory

00:20:54,340 --> 00:20:59,110
returns us a job we shovel it into the

00:20:56,350 --> 00:21:00,760
worker so push demon is slimmed down

00:20:59,110 --> 00:21:02,590
quite a bit but we've made a mess in

00:21:00,760 --> 00:21:06,760
these other extractions so let's go and

00:21:02,590 --> 00:21:08,170
try to clean them up jobs ping there's

00:21:06,760 --> 00:21:10,120
not much code here but the code that is

00:21:08,170 --> 00:21:11,560
here is a little suspect the first thing

00:21:10,120 --> 00:21:13,390
that we noticed is we have these weird

00:21:11,560 --> 00:21:15,490
references to data this associative

00:21:13,390 --> 00:21:17,290
array type structure and we don't know

00:21:15,490 --> 00:21:19,240
what it is but we assume it's data that

00:21:17,290 --> 00:21:21,070
you'd say that we're only passing

00:21:19,240 --> 00:21:23,350
together and this is a code smell called

00:21:21,070 --> 00:21:24,550
the data clump so a data clump are you

00:21:23,350 --> 00:21:25,930
know two or more attributes that are

00:21:24,550 --> 00:21:29,230
passed around together to do some

00:21:25,930 --> 00:21:30,790
represent some larger value that our pet

00:21:29,230 --> 00:21:32,560
that can't be passed around individually

00:21:30,790 --> 00:21:35,560
but do not exist in a higher level of

00:21:32,560 --> 00:21:37,030
abstraction so in this case we have to

00:21:35,560 --> 00:21:38,860
look a little closer at what data is

00:21:37,030 --> 00:21:40,810
because it's kind of confusing so this

00:21:38,860 --> 00:21:42,850
is what socket returns back to us it's

00:21:40,810 --> 00:21:44,080
returning us two things the first member

00:21:42,850 --> 00:21:45,790
is just the data that came through from

00:21:44,080 --> 00:21:47,890
the client but the second is of the

00:21:45,790 --> 00:21:49,570
structure called the sock adder and the

00:21:47,890 --> 00:21:51,730
sock adder includes information about

00:21:49,570 --> 00:21:54,310
the client and some information about

00:21:51,730 --> 00:21:56,470
the network and so a protocol family

00:21:54,310 --> 00:21:58,720
port and IP address of what we're

00:21:56,470 --> 00:22:00,160
interested in this is a pretty important

00:21:58,720 --> 00:22:02,110
concept in our system we're a service

00:22:00,160 --> 00:22:04,990
that deals with remote clients we should

00:22:02,110 --> 00:22:06,910
have a concept in our system home for

00:22:04,990 --> 00:22:09,010
this knowledge so let's create that

00:22:06,910 --> 00:22:11,410
we're gonna create a client a client

00:22:09,010 --> 00:22:13,600
this is going to be a very kind of class

00:22:11,410 --> 00:22:15,460
isn't going to do much yet it's going to

00:22:13,600 --> 00:22:17,380
take in the sock outer structure it's

00:22:15,460 --> 00:22:18,970
going to use adder info adder info is a

00:22:17,380 --> 00:22:21,250
class in the Ruby standard library that

00:22:18,970 --> 00:22:22,180
knows how to parse sock adders it's

00:22:21,250 --> 00:22:23,710
gonna take that and decorate it with

00:22:22,180 --> 00:22:26,650
some methods so we can access address

00:22:23,710 --> 00:22:28,909
import pretty easy so now we get to

00:22:26,650 --> 00:22:30,109
clean up a little bit and UDP server

00:22:28,909 --> 00:22:31,879
we're just taking the data from the

00:22:30,109 --> 00:22:34,369
socket and throwing it to the app like

00:22:31,879 --> 00:22:35,869
just saying here good luck we're gonna

00:22:34,369 --> 00:22:38,239
do something better now we're gonna

00:22:35,869 --> 00:22:39,950
deconstruct what comes out of the socket

00:22:38,239 --> 00:22:41,509
into its constituent parts the message

00:22:39,950 --> 00:22:43,070
in the sock adder we're gonna create a

00:22:41,509 --> 00:22:44,629
new client out of the sock adder and

00:22:43,070 --> 00:22:46,970
then we're gonna call the app with

00:22:44,629 --> 00:22:48,470
client and message this is a really good

00:22:46,970 --> 00:22:50,359
thing we had a really terrible name hang

00:22:48,470 --> 00:22:51,499
around for a long time data which is

00:22:50,359 --> 00:22:53,590
probably the worst name you could have

00:22:51,499 --> 00:22:55,759
in the system right what does data mean

00:22:53,590 --> 00:22:57,499
let's replace it so now we can finally

00:22:55,759 --> 00:23:00,229
get rid of it data becomes its parts

00:22:57,499 --> 00:23:02,179
client and message much more explicit so

00:23:00,229 --> 00:23:04,249
now we can go back to jobs ping we still

00:23:02,179 --> 00:23:06,590
have our data clump but at least now our

00:23:04,249 --> 00:23:08,509
data clump is coherent and looking at it

00:23:06,590 --> 00:23:10,789
it becomes pretty obvious that we can do

00:23:08,509 --> 00:23:13,429
this work without clients data client is

00:23:10,789 --> 00:23:15,470
the key actor in this line of code but

00:23:13,429 --> 00:23:17,479
we're asking a questions rather than

00:23:15,470 --> 00:23:18,919
letting it do its job this is an example

00:23:17,479 --> 00:23:20,659
of feature Envy we're trying to do

00:23:18,919 --> 00:23:22,669
someone else's job with someone else's

00:23:20,659 --> 00:23:25,159
data it's obvious that client should be

00:23:22,669 --> 00:23:27,080
the one doing the work extracted objects

00:23:25,159 --> 00:23:28,669
tend to attract behavior so now that we

00:23:27,080 --> 00:23:31,340
have something called client or system

00:23:28,669 --> 00:23:33,590
we want to give it behaviors so let's do

00:23:31,340 --> 00:23:35,539
that let's let client handle sending the

00:23:33,590 --> 00:23:36,409
message so to send the message it's

00:23:35,539 --> 00:23:37,940
going to have to collaborate with a

00:23:36,409 --> 00:23:39,379
server server is the only thing that

00:23:37,940 --> 00:23:41,059
knows how to deal with the network so

00:23:39,379 --> 00:23:42,950
we're gonna enter a add a server

00:23:41,059 --> 00:23:44,599
parameter here to the to the initializer

00:23:42,950 --> 00:23:46,009
and then we're gonna add a send method

00:23:44,599 --> 00:23:48,739
so the send method is going to take in a

00:23:46,009 --> 00:23:50,659
message pong or whatever it is and it's

00:23:48,739 --> 00:23:52,460
going to collaborate with server to send

00:23:50,659 --> 00:23:56,739
the message using the the data it knows

00:23:52,460 --> 00:23:58,789
address in port finally in UDP server

00:23:56,739 --> 00:24:00,019
because we're instantiating the client

00:23:58,789 --> 00:24:02,659
now we have to pass in the server which

00:24:00,019 --> 00:24:05,599
is ourself and in jobs now this

00:24:02,659 --> 00:24:07,940
collapses down to clients and pong which

00:24:05,599 --> 00:24:10,369
is much better now we can get we deal

00:24:07,940 --> 00:24:11,450
with this met this signature here we

00:24:10,369 --> 00:24:13,220
don't need a server anymore because

00:24:11,450 --> 00:24:16,580
client encapsulates the idea of a server

00:24:13,220 --> 00:24:19,309
so we could stop passing that down get

00:24:16,580 --> 00:24:20,749
rid of that okay so let's turn our

00:24:19,309 --> 00:24:23,299
attention to send so there's a lot of

00:24:20,749 --> 00:24:25,460
code smells in here if we start at the

00:24:23,299 --> 00:24:27,559
top we can kind of work our way down

00:24:25,460 --> 00:24:29,989
so same name different meaning we have

00:24:27,559 --> 00:24:32,359
two concepts here with the same name at

00:24:29,989 --> 00:24:34,099
the top we have an HTTP client memorized

00:24:32,359 --> 00:24:35,960
that we're using to talk to Google and

00:24:34,099 --> 00:24:37,669
then right below it in our initializer

00:24:35,960 --> 00:24:39,049
we're passing in the client that we just

00:24:37,669 --> 00:24:41,730
created the service client that

00:24:39,049 --> 00:24:43,900
represents a requester

00:24:41,730 --> 00:24:45,400
this could mean one of two things it

00:24:43,900 --> 00:24:48,940
could mean that we've imprecisely named

00:24:45,400 --> 00:24:51,310
the actors in the system or it could

00:24:48,940 --> 00:24:52,840
mean that this object knows too much I

00:24:51,310 --> 00:24:54,340
think in this case since we've moved

00:24:52,840 --> 00:24:55,570
around these details quite a bit you

00:24:54,340 --> 00:24:57,910
know we start out and push team and then

00:24:55,570 --> 00:25:00,220
we move to worker it seems like these

00:24:57,910 --> 00:25:02,170
need a permanent home so let's create a

00:25:00,220 --> 00:25:03,850
concrete object in our system that

00:25:02,170 --> 00:25:05,830
represents a push notification it's

00:25:03,850 --> 00:25:07,540
pretty important concept push

00:25:05,830 --> 00:25:09,340
notification has a registration ID and

00:25:07,540 --> 00:25:10,750
then it alert and this object's behavior

00:25:09,340 --> 00:25:12,490
is it knows how to deliver itself to the

00:25:10,750 --> 00:25:15,100
google api and that's it that's all it

00:25:12,490 --> 00:25:18,370
does so now jobs send collapses and

00:25:15,100 --> 00:25:20,440
instead of having to deal with the

00:25:18,370 --> 00:25:23,680
google api directly it uses push

00:25:20,440 --> 00:25:25,360
notification to do that so we're left

00:25:23,680 --> 00:25:27,310
with two fairly stinky lines of code

00:25:25,360 --> 00:25:28,990
here the first line of code is doing a

00:25:27,310 --> 00:25:30,730
regular expression match using capture

00:25:28,990 --> 00:25:33,040
groups and the second line of code is

00:25:30,730 --> 00:25:35,490
using the pseudo global polish like

00:25:33,040 --> 00:25:38,380
regular expression side effect variables

00:25:35,490 --> 00:25:39,790
we want to get rid of that the first

00:25:38,380 --> 00:25:41,650
line of code is an interesting one it's

00:25:39,790 --> 00:25:43,420
it's a night it's representative of

00:25:41,650 --> 00:25:44,950
primitive obsession this isn't to say

00:25:43,420 --> 00:25:46,180
that primitives are bad right primitives

00:25:44,950 --> 00:25:48,820
are most of what we're passing around

00:25:46,180 --> 00:25:51,100
but it's because we're using a simple

00:25:48,820 --> 00:25:54,150
type to represent a complex idea what's

00:25:51,100 --> 00:25:56,800
happening in here is a complex idea

00:25:54,150 --> 00:25:58,840
we're tokenizing the incoming message

00:25:56,800 --> 00:26:00,460
and trying to extract meaning from it

00:25:58,840 --> 00:26:02,680
and we're doing it at a lower depth in

00:26:00,460 --> 00:26:05,050
our system than we'd like if we zoom out

00:26:02,680 --> 00:26:07,480
what we have between a client and the

00:26:05,050 --> 00:26:09,970
server is a line protocol our line

00:26:07,480 --> 00:26:12,250
protocol looks like this we expect a

00:26:09,970 --> 00:26:15,310
command ping or send and then optionally

00:26:12,250 --> 00:26:16,660
we expect some parameters these

00:26:15,310 --> 00:26:19,840
parameters have their own tokenization

00:26:16,660 --> 00:26:21,850
rules so a parameter string is split on

00:26:19,840 --> 00:26:23,890
spaces unless a double quote is

00:26:21,850 --> 00:26:25,720
encountered in which case all characters

00:26:23,890 --> 00:26:28,780
enclosed in those double quotes becomes

00:26:25,720 --> 00:26:30,040
a token this should sound familiar this

00:26:28,780 --> 00:26:32,020
is exactly how the UNIX Bourne shell

00:26:30,040 --> 00:26:33,460
process parses parameters right when

00:26:32,020 --> 00:26:35,470
you've have in the command line if you

00:26:33,460 --> 00:26:37,120
put something in quotes that becomes an

00:26:35,470 --> 00:26:39,490
argument and that's what we've

00:26:37,120 --> 00:26:42,040
unwittingly built here and the Ruby

00:26:39,490 --> 00:26:44,050
standard library actually has an object

00:26:42,040 --> 00:26:45,900
that knows how to tokenize strings based

00:26:44,050 --> 00:26:48,700
upon those rules it's called shell words

00:26:45,900 --> 00:26:50,590
shell words is something we can use to

00:26:48,700 --> 00:26:52,210
split up the incoming message into

00:26:50,590 --> 00:26:55,090
tokens and then use those tokens more

00:26:52,210 --> 00:26:56,230
intelligently so what we're going to

00:26:55,090 --> 00:26:57,810
create a new object we're gonna extract

00:26:56,230 --> 00:26:59,980
yet another object called request

00:26:57,810 --> 00:27:01,120
request it's gonna take in a message and

00:26:59,980 --> 00:27:03,280
it's going to tokenize that message

00:27:01,120 --> 00:27:05,890
using shell words split it's then gonna

00:27:03,280 --> 00:27:07,150
decorate it with two men two methods

00:27:05,890 --> 00:27:08,890
we're gonna have a method called command

00:27:07,150 --> 00:27:10,300
which takes the first token and

00:27:08,890 --> 00:27:12,400
normalizes it into an upper case

00:27:10,300 --> 00:27:13,660
strength and then we're gonna take the

00:27:12,400 --> 00:27:15,760
remainder of the tokens and we're gonna

00:27:13,660 --> 00:27:18,160
return them as an array and if we don't

00:27:15,760 --> 00:27:20,470
have any tokens which can return an

00:27:18,160 --> 00:27:22,420
empty array so now things clean up quite

00:27:20,470 --> 00:27:24,010
a bit instead of passing down this raw

00:27:22,420 --> 00:27:25,120
message and relying on the rest of the

00:27:24,010 --> 00:27:26,800
system to kind of figure out what that

00:27:25,120 --> 00:27:33,490
message means we're gonna pass down a

00:27:26,800 --> 00:27:34,900
request so here in our factory instead

00:27:33,490 --> 00:27:36,100
of having to deal with a raw message and

00:27:34,900 --> 00:27:38,170
splitting it and figuring out what the

00:27:36,100 --> 00:27:41,230
command is well instead just gonna use

00:27:38,170 --> 00:27:43,240
the request object to figure out what

00:27:41,230 --> 00:27:45,750
the command is and ask the hash to

00:27:43,240 --> 00:27:48,430
return us a corresponding job class

00:27:45,750 --> 00:27:50,050
finally in send we no longer have the

00:27:48,430 --> 00:27:52,450
regular expression and we no longer have

00:27:50,050 --> 00:27:55,450
the weird pseudo global variables we

00:27:52,450 --> 00:27:57,610
just have parameters which is an array

00:27:55,450 --> 00:27:58,840
and we you know we're sort of binding

00:27:57,610 --> 00:28:01,810
ourselves to the position of those

00:27:58,840 --> 00:28:03,130
elements okay we have one more piece of

00:28:01,810 --> 00:28:05,440
unfinished business before we're out of

00:28:03,130 --> 00:28:07,090
time we've left mill checks scattered

00:28:05,440 --> 00:28:08,800
throughout the code in a couple of

00:28:07,090 --> 00:28:11,860
places so the first place is in this

00:28:08,800 --> 00:28:13,930
Factory so we're saying hash give me a

00:28:11,860 --> 00:28:15,700
job at correspond to this command but if

00:28:13,930 --> 00:28:18,460
we pass in a command like info or

00:28:15,700 --> 00:28:20,350
shutdown or something like that the hash

00:28:18,460 --> 00:28:22,900
is gonna return nil to us so we don't

00:28:20,350 --> 00:28:25,480
want to call new on nil because it will

00:28:22,900 --> 00:28:27,280
blow out so we check to see if classes

00:28:25,480 --> 00:28:28,840
truthy if class is truthy then we

00:28:27,280 --> 00:28:29,350
instantiate the class and we return it

00:28:28,840 --> 00:28:31,660
to the caller

00:28:29,350 --> 00:28:34,390
so our factory could return nil

00:28:31,660 --> 00:28:36,340
depending on user input consequently the

00:28:34,390 --> 00:28:38,080
push demon has to guard here so it has

00:28:36,340 --> 00:28:39,670
to check did I get a job back from the

00:28:38,080 --> 00:28:40,810
factory if I did I'm gonna shovel it

00:28:39,670 --> 00:28:42,580
into the worker if I didn't I'm not

00:28:40,810 --> 00:28:43,690
going to do anything nil is

00:28:42,580 --> 00:28:44,950
communicating an idea here it's

00:28:43,690 --> 00:28:47,260
communicating the idea that an unknown

00:28:44,950 --> 00:28:49,330
command has been requested and we can

00:28:47,260 --> 00:28:50,620
make this a concept in our system we're

00:28:49,330 --> 00:28:51,880
gonna use the null object pattern we're

00:28:50,620 --> 00:28:55,300
gonna introduce a null object to

00:28:51,880 --> 00:28:56,590
represent an unknown command so it's

00:28:55,300 --> 00:28:58,840
gonna look like this it's gonna clack

00:28:56,590 --> 00:29:00,370
exactly like a job but it's a no op it's

00:28:58,840 --> 00:29:01,930
not going to do anything you can call

00:29:00,370 --> 00:29:03,760
run on it it's just not gonna do

00:29:01,930 --> 00:29:06,340
anything but it speaks the same

00:29:03,760 --> 00:29:09,010
interface which means in our jobs class

00:29:06,340 --> 00:29:11,080
now instead of guarding here

00:29:09,010 --> 00:29:12,549
we could use a cool feature of hash so

00:29:11,080 --> 00:29:14,140
hash doesn't have to return nil as the

00:29:12,549 --> 00:29:16,750
default it just does that's its default

00:29:14,140 --> 00:29:17,710
behavior we could tell the hash when you

00:29:16,750 --> 00:29:20,230
get a key that you don't recognize

00:29:17,710 --> 00:29:21,490
return null job so now this hash is

00:29:20,230 --> 00:29:23,320
guaranteed to return something that

00:29:21,490 --> 00:29:25,210
clocks like a job so instead of checking

00:29:23,320 --> 00:29:27,610
if we got a class back we can just

00:29:25,210 --> 00:29:29,980
blindly instantiate it and return the

00:29:27,610 --> 00:29:32,200
instance so in the case of ping and send

00:29:29,980 --> 00:29:33,940
this method will return opinio instance

00:29:32,200 --> 00:29:35,169
or a send instance in the case of

00:29:33,940 --> 00:29:38,740
anything else it's going to return a

00:29:35,169 --> 00:29:40,450
null job instance now in push daemon we

00:29:38,740 --> 00:29:42,429
no longer have to check for nil here

00:29:40,450 --> 00:29:45,429
that can just go away and this is better

00:29:42,429 --> 00:29:47,980
but we've introduced a problem now we're

00:29:45,429 --> 00:29:49,960
in queueing null job here so no jobs are

00:29:47,980 --> 00:29:52,660
no op but we're stuffing it into memory

00:29:49,960 --> 00:29:54,580
and making a thread grab it and call run

00:29:52,660 --> 00:29:55,750
on it which is essentially no op it

00:29:54,580 --> 00:29:57,570
would be better if we didn't in queue it

00:29:55,750 --> 00:29:59,650
at all if we short-circuited it here and

00:29:57,570 --> 00:30:02,290
for us to do that we have a few options

00:29:59,650 --> 00:30:04,240
right we could check the type of the job

00:30:02,290 --> 00:30:06,700
that comes back we could say if you are

00:30:04,240 --> 00:30:10,090
a no job don't you don't submit yourself

00:30:06,700 --> 00:30:11,230
to the worker and this is just as bad as

00:30:10,090 --> 00:30:12,970
the nil check I mean it's pretty much

00:30:11,230 --> 00:30:15,460
the same thing it's a little more

00:30:12,970 --> 00:30:18,610
explicit I guess it would be better if

00:30:15,460 --> 00:30:20,770
we inverted the dispatch here so instead

00:30:18,610 --> 00:30:22,120
of the worker that invoking the

00:30:20,770 --> 00:30:24,850
operation of the shovel on the worker

00:30:22,120 --> 00:30:26,470
let's invoke the shovel on the job

00:30:24,850 --> 00:30:28,330
because the job knows if it's a valid

00:30:26,470 --> 00:30:31,690
job that needs to be in queued in the

00:30:28,330 --> 00:30:34,090
worker so let's add the opposite shovel

00:30:31,690 --> 00:30:35,679
to our job so we're gonna add the right

00:30:34,090 --> 00:30:38,500
shovel here right shovel will expect to

00:30:35,679 --> 00:30:40,660
pass a worker in in the ping job if we

00:30:38,500 --> 00:30:42,130
get this method call we're gonna just

00:30:40,660 --> 00:30:44,650
submit ourselves to the worker for later

00:30:42,130 --> 00:30:46,120
execution but in null job we're gonna

00:30:44,650 --> 00:30:47,830
respond to the same method but we're not

00:30:46,120 --> 00:30:50,559
gonna submit ourselves we're just going

00:30:47,830 --> 00:30:53,830
to no op and that means the push daemon

00:30:50,559 --> 00:30:55,750
in this case we can just flip this so

00:30:53,830 --> 00:30:56,980
job now goes into worker and job can

00:30:55,750 --> 00:31:00,730
make the determination if I want to

00:30:56,980 --> 00:31:02,650
include of time we're gonna stop our

00:31:00,730 --> 00:31:04,929
refactoring here I've put the code up on

00:31:02,650 --> 00:31:06,970
github for anyone interested for

00:31:04,929 --> 00:31:08,559
whatever reason there's plenty left to

00:31:06,970 --> 00:31:10,090
do in the code like there's there's tons

00:31:08,559 --> 00:31:11,380
of smells still left like for example we

00:31:10,090 --> 00:31:13,990
have hard-coded configuration details

00:31:11,380 --> 00:31:15,429
everywhere and that's gonna that's like

00:31:13,990 --> 00:31:16,929
the opposite of divergent change that's

00:31:15,429 --> 00:31:18,700
shotgun surgery that's possible that

00:31:16,929 --> 00:31:20,380
we're gonna have to update those details

00:31:18,700 --> 00:31:21,600
in many different places when we deploy

00:31:20,380 --> 00:31:24,030
to a new environment let's

00:31:21,600 --> 00:31:25,770
we also have weird boilerplate now like

00:31:24,030 --> 00:31:28,170
the job to create the job interface we

00:31:25,770 --> 00:31:29,370
have to add these methods and it would

00:31:28,170 --> 00:31:32,580
be nicer if we like extracted a

00:31:29,370 --> 00:31:35,700
superclass but we don't have time to do

00:31:32,580 --> 00:31:37,890
that and that said even though we have

00:31:35,700 --> 00:31:39,120
some more work left to do our push

00:31:37,890 --> 00:31:41,550
daemon is a much better shape than when

00:31:39,120 --> 00:31:42,690
we started we listened and responded to

00:31:41,550 --> 00:31:44,580
the code smells in the original script

00:31:42,690 --> 00:31:46,200
and we've made huge strides toward a

00:31:44,580 --> 00:31:49,080
more coherent design that will be easier

00:31:46,200 --> 00:31:51,800
to grow and maintain that's all I have

00:31:49,080 --> 00:31:51,800

YouTube URL: https://www.youtube.com/watch?v=q_qdWuCAkd8


