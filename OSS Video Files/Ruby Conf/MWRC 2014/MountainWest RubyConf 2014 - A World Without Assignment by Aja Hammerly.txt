Title: MountainWest RubyConf 2014 - A World Without Assignment by Aja Hammerly
Publication date: 2020-01-24
Playlist: MWRC 2014
Description: 
	In OO, assignment is one of our main tools. Most developers learn how to store values in variables shortly after learning "Hello World". By contrast, functional programming makes much less use of assignment and mutation. Instead techniques like function composition, recursion, and anonymous functions are used to produce the same results that OO programmers produce with side effects.
Despite being object oriented, Ruby easily accommodates pure functional approaches. This talk will demonstrate how common programming tasks can be accomplished without assignment or mutation. Ruby and Scheme (a Lisp dialect) will be used for examples. I'll also discuss some of the great resources available for those interested in digging deeper into functional programming.

Help us caption & translate this video!

http://amara.org/v/FG2H/
Captions: 
	00:00:24,500 --> 00:00:30,660
good morning everyone people are

00:00:29,070 --> 00:00:33,989
actually awake at this conference in the

00:00:30,660 --> 00:00:36,239
morning it's weird so my first tech

00:00:33,989 --> 00:00:39,239
conference was Golden Gate rubyconf 2010

00:00:36,239 --> 00:00:41,340
and Jim wyrick gave the keynote at that

00:00:39,239 --> 00:00:43,680
conference and he covered a wide variety

00:00:41,340 --> 00:00:46,470
of topics including physical chemistry

00:00:43,680 --> 00:00:48,480
which really is one of my favoritest

00:00:46,470 --> 00:00:50,820
things in the world emission spectra and

00:00:48,480 --> 00:00:53,550
this book the structure and

00:00:50,820 --> 00:00:55,410
interpretation of computer programs he

00:00:53,550 --> 00:00:57,930
said that this book had been recommended

00:00:55,410 --> 00:01:00,180
more than any other book to him as

00:00:57,930 --> 00:01:01,739
something that would help act current

00:01:00,180 --> 00:01:03,750
programmers professional programmers

00:01:01,739 --> 00:01:05,250
improve their craft and so he had

00:01:03,750 --> 00:01:06,660
started a study group and his keynote

00:01:05,250 --> 00:01:08,190
was about what his study group had

00:01:06,660 --> 00:01:10,710
learned thus far in the first two

00:01:08,190 --> 00:01:13,590
chapters of this book so this book has

00:01:10,710 --> 00:01:14,970
five chapters it's about this thick so

00:01:13,590 --> 00:01:18,330
you can imagine what those two chapters

00:01:14,970 --> 00:01:21,440
actually cover and about 50 60 minutes

00:01:18,330 --> 00:01:23,820
into a 90-minute keynote he said and

00:01:21,440 --> 00:01:25,500
everything I've covered this far doesn't

00:01:23,820 --> 00:01:27,960
use assignment in fact this book doesn't

00:01:25,500 --> 00:01:30,479
even introduce assignment until chapter

00:01:27,960 --> 00:01:33,030
3 more than forty percent of the way

00:01:30,479 --> 00:01:34,500
through the book and that little nugget

00:01:33,030 --> 00:01:37,080
stuck with me and that's kind of where

00:01:34,500 --> 00:01:39,869
this talk started so a little bit about

00:01:37,080 --> 00:01:41,430
me I majha hammerle I tweet a bag of

00:01:39,869 --> 00:01:43,049
mizar be and I like it when people tweet

00:01:41,430 --> 00:01:44,280
at me during my talk because my phone's

00:01:43,049 --> 00:01:45,810
over there and i will read all your

00:01:44,280 --> 00:01:49,409
comments later and I will be very happy

00:01:45,810 --> 00:01:51,810
as long as they're nice uh I'm on github

00:01:49,409 --> 00:01:54,090
as bagga miser I blog very occasionally

00:01:51,810 --> 00:01:56,549
at Amazo com primarily it's my talk

00:01:54,090 --> 00:01:58,049
slides and these slides would be up

00:01:56,549 --> 00:02:00,990
there except for me an rsync had an

00:01:58,049 --> 00:02:02,400
argument about an hour ago and I work at

00:02:00,990 --> 00:02:04,439
a company called substantial we are in

00:02:02,400 --> 00:02:06,150
digital products to do in seattle

00:02:04,439 --> 00:02:07,680
washington if you're ever in seattle you

00:02:06,150 --> 00:02:09,420
should check out our website substantial

00:02:07,680 --> 00:02:11,910
calm because we host far too many events

00:02:09,420 --> 00:02:15,810
in our office space for nerds of varying

00:02:11,910 --> 00:02:18,840
kinds um what qualifies me to give this

00:02:15,810 --> 00:02:21,269
talk quite frankly not much but based on

00:02:18,840 --> 00:02:24,150
Jim's keynote a couple of us in Seattle

00:02:21,269 --> 00:02:26,220
RB did a study group through sicp to

00:02:24,150 --> 00:02:27,690
IKOS about nine months rienzi and talk

00:02:26,220 --> 00:02:29,730
to you a little bit about that later and

00:02:27,690 --> 00:02:32,160
I also did a study group on functional

00:02:29,730 --> 00:02:33,060
programming last fall in a different

00:02:32,160 --> 00:02:34,620
book

00:02:33,060 --> 00:02:37,200
and if you've ever seen me speak before

00:02:34,620 --> 00:02:39,209
I have a deep fascination with esoteric

00:02:37,200 --> 00:02:41,970
and not very useful programming

00:02:39,209 --> 00:02:43,980
languages like prologue and other such

00:02:41,970 --> 00:02:45,209
things so once I've started doing that

00:02:43,980 --> 00:02:47,790
I'm starting to see some functional

00:02:45,209 --> 00:02:51,060
programming all over the place now so

00:02:47,790 --> 00:02:52,290
functional programming what's that this

00:02:51,060 --> 00:02:54,060
is what wikipedia has to say about

00:02:52,290 --> 00:02:55,680
functional programming and computer

00:02:54,060 --> 00:02:58,080
science functional programming is a

00:02:55,680 --> 00:02:59,640
programming paradigm a style of building

00:02:58,080 --> 00:03:02,160
the structure and elements of computer

00:02:59,640 --> 00:03:04,290
programs that treats computation as the

00:03:02,160 --> 00:03:06,750
evaluation of mathematical functions and

00:03:04,290 --> 00:03:09,030
avoid state and mutable data so that is

00:03:06,750 --> 00:03:11,610
not particularly useful this is what one

00:03:09,030 --> 00:03:13,380
of my co-workers said the entire idea of

00:03:11,610 --> 00:03:16,380
mutable state is suspicious and easy to

00:03:13,380 --> 00:03:18,450
mess up and this was Jim's definition

00:03:16,380 --> 00:03:19,950
from his talk the functional Ling a

00:03:18,450 --> 00:03:22,319
functional language is about calling

00:03:19,950 --> 00:03:23,790
functions no it's not about calling

00:03:22,319 --> 00:03:26,190
functions about crates it's about

00:03:23,790 --> 00:03:27,870
creating functions that do things so I

00:03:26,190 --> 00:03:30,120
don't actually think I could build a

00:03:27,870 --> 00:03:32,459
talker on any of those definitions so in

00:03:30,120 --> 00:03:33,989
this talk I'm going to focus on one core

00:03:32,459 --> 00:03:36,870
aspect of functional programming and

00:03:33,989 --> 00:03:38,310
that is not using assignment no

00:03:36,870 --> 00:03:40,260
assignment at all in this talk there's

00:03:38,310 --> 00:03:43,200
not a single equals in Ruby anywhere in

00:03:40,260 --> 00:03:44,850
this talk in scheme you do assignment

00:03:43,200 --> 00:03:47,579
with set bang and there are no set bangs

00:03:44,850 --> 00:03:49,980
in this talk and I'm going to avoid

00:03:47,579 --> 00:03:53,640
modifying objects anywhere so setting

00:03:49,980 --> 00:03:56,190
expectations 114 slides lots of code I

00:03:53,640 --> 00:04:00,889
don't give Luffy talks lots of

00:03:56,190 --> 00:04:05,209
parentheses yeah lots of parentheses and

00:04:00,889 --> 00:04:05,209
no ponies sorry Mike

00:04:06,040 --> 00:04:13,670
yes but it's a very sad pony so why

00:04:12,290 --> 00:04:15,020
should you care not why should you care

00:04:13,670 --> 00:04:18,080
about no ponies but why should you care

00:04:15,020 --> 00:04:20,150
about functional programming so first of

00:04:18,080 --> 00:04:22,610
all it's easier to test there's a lot

00:04:20,150 --> 00:04:24,140
less setup there's a lot less stubbing

00:04:22,610 --> 00:04:25,700
and mocking in fact most of the times

00:04:24,140 --> 00:04:27,050
and the projects I'm working on that

00:04:25,700 --> 00:04:29,390
have functional aspects do very little

00:04:27,050 --> 00:04:30,920
stubbing and mocking and you always

00:04:29,390 --> 00:04:33,050
start from a known state which means

00:04:30,920 --> 00:04:35,420
it's impossible for your tests in your

00:04:33,050 --> 00:04:36,680
first run to pollute the data for your

00:04:35,420 --> 00:04:38,150
second runner your third run you don't

00:04:36,680 --> 00:04:41,150
end up with those dependencies that can

00:04:38,150 --> 00:04:42,830
trip you up pretty easily concurrency is

00:04:41,150 --> 00:04:44,330
a lot more a lot easier and functional

00:04:42,830 --> 00:04:46,460
parent with functional paradigms because

00:04:44,330 --> 00:04:47,930
again no state nothing for two threads

00:04:46,460 --> 00:04:52,310
to stomp all over each other on it's

00:04:47,930 --> 00:04:53,600
fantastic safe reuse this is something

00:04:52,310 --> 00:04:55,160
that a lot of functional programming

00:04:53,600 --> 00:04:57,290
advocates talk about you can take a

00:04:55,160 --> 00:04:59,390
function from one project pick it up

00:04:57,290 --> 00:05:01,010
move at wholesale into another because

00:04:59,390 --> 00:05:02,180
again you don't have state you don't

00:05:01,010 --> 00:05:03,650
have to make sure you have class bar is

00:05:02,180 --> 00:05:08,540
an instance of our setup correctly for

00:05:03,650 --> 00:05:10,220
your function to work brevity this is a

00:05:08,540 --> 00:05:12,740
plus or minus depending on your opinion

00:05:10,220 --> 00:05:16,850
a lot of functional languages list

00:05:12,740 --> 00:05:19,580
languages scheme Haskell are concise

00:05:16,850 --> 00:05:21,170
they're very short and very concise and

00:05:19,580 --> 00:05:23,330
not a lot of text goes into making

00:05:21,170 --> 00:05:26,150
something happen that makes some people

00:05:23,330 --> 00:05:29,180
very happy it makes others frustrated

00:05:26,150 --> 00:05:30,590
your mileage may vary but I think two of

00:05:29,180 --> 00:05:31,880
the biggest reasons that you should care

00:05:30,590 --> 00:05:33,710
about functional programming is that a

00:05:31,880 --> 00:05:35,750
lot of you already use it who here has

00:05:33,710 --> 00:05:38,390
passed a block to some method from

00:05:35,750 --> 00:05:41,300
innumerable raise your hands that's what

00:05:38,390 --> 00:05:42,740
I expected that whole idea functional

00:05:41,300 --> 00:05:44,630
programming or at least strongly

00:05:42,740 --> 00:05:46,850
influenced by functional programming and

00:05:44,630 --> 00:05:48,230
since most of you are already doing it

00:05:46,850 --> 00:05:49,520
you might as well learn the basics of it

00:05:48,230 --> 00:05:52,250
and start doing it right and really

00:05:49,520 --> 00:05:54,800
using all the strength it has also Ruby

00:05:52,250 --> 00:05:56,270
makes it easy a lot of the basic

00:05:54,800 --> 00:05:57,680
functional concepts are available to us

00:05:56,270 --> 00:06:00,530
natively in Ruby don't have to go

00:05:57,680 --> 00:06:02,180
through any crazy like contortions to

00:06:00,530 --> 00:06:04,100
make them work and so it makes it easy

00:06:02,180 --> 00:06:05,720
to integrate a little bit of functional

00:06:04,100 --> 00:06:07,070
stuff over here maybe you've got some

00:06:05,720 --> 00:06:09,230
service in your rails app that can

00:06:07,070 --> 00:06:10,580
benefit from some functional ideas you

00:06:09,230 --> 00:06:12,350
can build that up throw it and lib and

00:06:10,580 --> 00:06:16,310
you can leave the rest of your rails app

00:06:12,350 --> 00:06:18,420
and object-oriented land so it's

00:06:16,310 --> 00:06:20,640
functional language I know best

00:06:18,420 --> 00:06:23,280
actually has use in the real world is

00:06:20,640 --> 00:06:25,740
scheme so here are some scheme basics

00:06:23,280 --> 00:06:28,770
this is going to be a very fast trip

00:06:25,740 --> 00:06:31,260
through scheme 101 most important thing

00:06:28,770 --> 00:06:34,980
scheme uses prefix notation which means

00:06:31,260 --> 00:06:36,810
that the method goes first so throughout

00:06:34,980 --> 00:06:38,970
all of my slides where I have scheme and

00:06:36,810 --> 00:06:41,730
Ruby on the same slide ruby is in red

00:06:38,970 --> 00:06:44,070
and on the right ours alliteration

00:06:41,730 --> 00:06:47,430
they're awesome scheme is going to be in

00:06:44,070 --> 00:06:49,560
blue and on the left so you can see that

00:06:47,430 --> 00:06:51,570
five plus three in Ruby is the same as +

00:06:49,560 --> 00:06:53,310
53 and scheme and the cool thing about

00:06:51,570 --> 00:06:55,710
prefix notation is that you can have

00:06:53,310 --> 00:06:57,240
many arguments as you want so you can

00:06:55,710 --> 00:06:59,070
add two things or in the second line you

00:06:57,240 --> 00:07:02,310
were multiplying three things it's the

00:06:59,070 --> 00:07:03,510
same method you can do your parenthesis

00:07:02,310 --> 00:07:05,880
for grouping of various mathematical

00:07:03,510 --> 00:07:08,190
functions you can see that in the third

00:07:05,880 --> 00:07:10,110
line and then there's the add one

00:07:08,190 --> 00:07:11,850
function which I think well I think

00:07:10,110 --> 00:07:14,220
actually is in racket core a simple

00:07:11,850 --> 00:07:15,240
incrementer and you put the function

00:07:14,220 --> 00:07:16,680
name first and then you put the

00:07:15,240 --> 00:07:20,450
arguments afterwards around everything

00:07:16,680 --> 00:07:20,450
with parentheses lots of parentheses

00:07:20,990 --> 00:07:25,020
here's how you define functions in

00:07:23,100 --> 00:07:26,520
scheme one of the things I really like

00:07:25,020 --> 00:07:28,860
is that it looks a lot like Ruby we've

00:07:26,520 --> 00:07:31,320
got define a function named some

00:07:28,860 --> 00:07:34,200
arguments a method body and then a close

00:07:31,320 --> 00:07:35,580
parenthesis instead of an end and then

00:07:34,200 --> 00:07:37,170
you call the method just by having the

00:07:35,580 --> 00:07:39,840
method name and then the argument inside

00:07:37,170 --> 00:07:42,860
parentheses it goes really nicely

00:07:39,840 --> 00:07:45,420
one-to-one with Ruby and then

00:07:42,860 --> 00:07:47,370
conditionals one thing that I see that

00:07:45,420 --> 00:07:50,550
functional programmers especially

00:07:47,370 --> 00:07:54,000
schemers and racketeers use a lot is the

00:07:50,550 --> 00:07:56,010
cond the Khanda skanda is can short for

00:07:54,000 --> 00:07:57,930
condition and it maps one-to-one with

00:07:56,010 --> 00:08:01,020
Ruby's case statement which I see people

00:07:57,930 --> 00:08:03,510
almost never using so here's how it

00:08:01,020 --> 00:08:05,820
looks and this function is absolute

00:08:03,510 --> 00:08:08,190
value so first case if our number is

00:08:05,820 --> 00:08:09,690
greater than zero we're going to say our

00:08:08,190 --> 00:08:12,090
number is X if it's greater than zero we

00:08:09,690 --> 00:08:14,100
just return the number itself second

00:08:12,090 --> 00:08:15,930
case if the number is equal to zero and

00:08:14,100 --> 00:08:17,610
that's single equals and scheme is a

00:08:15,930 --> 00:08:19,350
comparison it's like the double equals

00:08:17,610 --> 00:08:22,650
in Ruby it is not assignment I'm not

00:08:19,350 --> 00:08:24,540
breaking my rule I we return 0 so if our

00:08:22,650 --> 00:08:26,990
number is equal to zero and in the other

00:08:24,540 --> 00:08:29,340
case we turn the OP we return the

00:08:26,990 --> 00:08:31,920
mathematical opposite so negative 1

00:08:29,340 --> 00:08:32,390
times the number in Ruby or scheme has a

00:08:31,920 --> 00:08:34,560
unit

00:08:32,390 --> 00:08:36,479
a- that works as the mathematical

00:08:34,560 --> 00:08:38,669
opposite and it's awesome we return the

00:08:36,479 --> 00:08:40,110
net mathematical opposite and just like

00:08:38,669 --> 00:08:41,789
a ruby it has that implicit return

00:08:40,110 --> 00:08:43,919
whatever the last statement you

00:08:41,789 --> 00:08:46,110
evaluated will be returned so you can

00:08:43,919 --> 00:08:47,430
see how that maps one to one but this is

00:08:46,110 --> 00:08:48,839
not actually how schemer would write it

00:08:47,430 --> 00:08:50,310
that's how a real schemer would write it

00:08:48,839 --> 00:08:52,410
and this is where that brevity point

00:08:50,310 --> 00:08:53,640
comes in shrunk a lot vertically I've

00:08:52,410 --> 00:08:55,410
been trying to lay stuff out in the last

00:08:53,640 --> 00:08:57,960
slide so that you can see side-to-side

00:08:55,410 --> 00:09:01,650
how it maps with the Ruby but schemers

00:08:57,960 --> 00:09:02,670
like their code short so the other kind

00:09:01,650 --> 00:09:04,020
of conditional that I'm going to use in

00:09:02,670 --> 00:09:05,520
this talk although it's used a lot less

00:09:04,020 --> 00:09:08,460
often in a lot of the scheme code that

00:09:05,520 --> 00:09:10,950
I've read is if so here's a predicate

00:09:08,460 --> 00:09:13,430
function who here does not know what the

00:09:10,950 --> 00:09:16,710
word predicate means raise your hand

00:09:13,430 --> 00:09:18,150
awesome thank you predicate functions

00:09:16,710 --> 00:09:19,500
are functions that return a boolean so

00:09:18,150 --> 00:09:21,480
they have the return true or false and

00:09:19,500 --> 00:09:23,279
that concepts really important and I'm

00:09:21,480 --> 00:09:25,920
going to use it all over the place so

00:09:23,279 --> 00:09:28,020
this function returns balmy based on the

00:09:25,920 --> 00:09:29,820
temperature is it Bo me outside today so

00:09:28,020 --> 00:09:32,580
if the temperature is above 65 degrees

00:09:29,820 --> 00:09:38,460
it's bo me the temperature is not above

00:09:32,580 --> 00:09:45,780
65 degrees it's not balmy some of us are

00:09:38,460 --> 00:09:47,370
not you so temperature so you can see in

00:09:45,780 --> 00:09:48,900
scheme we have an if we have a

00:09:47,370 --> 00:09:52,500
conditional statement and then we have

00:09:48,900 --> 00:09:54,210
two branches one that gets run when the

00:09:52,500 --> 00:09:55,530
khodet when our condition is true and

00:09:54,210 --> 00:09:58,740
one that gets run when our condition is

00:09:55,530 --> 00:10:00,900
false the else is implicit unlike Ruby

00:09:58,740 --> 00:10:04,589
you just have two branches so that's how

00:10:00,900 --> 00:10:06,540
an if works in scheme and find little

00:10:04,589 --> 00:10:09,120
lists all the functional languages I've

00:10:06,540 --> 00:10:11,760
ever used love lists they use them all

00:10:09,120 --> 00:10:13,470
over the place we don't really have a

00:10:11,760 --> 00:10:15,180
concept in Ruby that maps one to one

00:10:13,470 --> 00:10:17,490
with the concept of a list and scheme so

00:10:15,180 --> 00:10:20,070
i'm going to use arrays and just kind of

00:10:17,490 --> 00:10:21,990
hand wave over the differences so in ski

00:10:20,070 --> 00:10:24,000
me to find a list with a single quote a

00:10:21,990 --> 00:10:28,080
set of friends and some elements inside

00:10:24,000 --> 00:10:31,250
separated by spaces and Ruby there's an

00:10:28,080 --> 00:10:33,209
array one two three that's a list I

00:10:31,250 --> 00:10:35,970
don't know the meaning behind the word

00:10:33,209 --> 00:10:38,160
car I don't know the orange-red origins

00:10:35,970 --> 00:10:41,670
of the word car but in scheme and Lisp

00:10:38,160 --> 00:10:44,160
car is the first element of a list it's

00:10:41,670 --> 00:10:46,420
the head so

00:10:44,160 --> 00:10:49,660
thank you see I learn things when I give

00:10:46,420 --> 00:10:52,690
talks it's awesome so the car of the

00:10:49,660 --> 00:10:57,750
list 1 2 3 is 1 and in Ruby are

00:10:52,690 --> 00:10:59,650
equivalent is first also one all

00:10:57,750 --> 00:11:03,220
functional languages I've used have a

00:10:59,650 --> 00:11:06,730
concept of rest in scheme that's cutter

00:11:03,220 --> 00:11:09,370
and in Ruby we define it with this crazy

00:11:06,730 --> 00:11:12,660
crazy array index range syntax of 1

00:11:09,370 --> 00:11:15,790
negative 1 that's ugly and hard to write

00:11:12,660 --> 00:11:18,339
so I'm going to open up the array class

00:11:15,790 --> 00:11:20,950
and add dot rest on to the end and that

00:11:18,339 --> 00:11:22,960
returns the exact same thing so rest in

00:11:20,950 --> 00:11:24,760
this case is a list that is the rest of

00:11:22,960 --> 00:11:27,100
the elements not including the head in

00:11:24,760 --> 00:11:28,570
this case that's two and three so the

00:11:27,100 --> 00:11:31,000
list containing the elements to three

00:11:28,570 --> 00:11:36,480
and finally you need to know if lists

00:11:31,000 --> 00:11:39,250
rmp empty in scheme that's null ? and in

00:11:36,480 --> 00:11:41,290
Ruby that's MDA and one thing I did not

00:11:39,250 --> 00:11:44,560
point out on the conditional slide is

00:11:41,290 --> 00:11:47,770
that scheme uses pound t4 true and pound

00:11:44,560 --> 00:11:48,880
f4 false if that really bugs you and you

00:11:47,770 --> 00:11:50,440
want to learn you want to learn a

00:11:48,880 --> 00:11:54,880
functional language you can go to racket

00:11:50,440 --> 00:11:56,320
it has true and false built-in so now we

00:11:54,880 --> 00:12:03,040
have all that now for my favorite thing

00:11:56,320 --> 00:12:05,140
recursion awesome factorial this is the

00:12:03,040 --> 00:12:06,910
definition of factorial in scheme and

00:12:05,140 --> 00:12:09,270
Ruby if our number we're trying to find

00:12:06,910 --> 00:12:12,040
the factorial of is one we return one

00:12:09,270 --> 00:12:15,970
otherwise we take n times the factorial

00:12:12,040 --> 00:12:17,650
of our number minus one so we're trying

00:12:15,970 --> 00:12:20,020
to find the factorial of 5 will take

00:12:17,650 --> 00:12:22,150
five times the factorial of 4 times the

00:12:20,020 --> 00:12:23,380
factorial of 3 times the factorial to

00:12:22,150 --> 00:12:25,959
you then you get down there because

00:12:23,380 --> 00:12:27,310
recursion is awesome there's a great

00:12:25,959 --> 00:12:30,160
lightning talk last night about

00:12:27,310 --> 00:12:32,560
Fibonacci and elegance and how Ruby is

00:12:30,160 --> 00:12:34,360
awesome I promise to show a scheme

00:12:32,560 --> 00:12:37,690
implementation of Fibonacci here it is

00:12:34,360 --> 00:12:40,630
if n so this gives you the nth Fibonacci

00:12:37,690 --> 00:12:43,930
number if n is zero we're going to say

00:12:40,630 --> 00:12:45,550
that that Fibonacci number is 0 if n is

00:12:43,930 --> 00:12:46,930
1 we're going to say one yes I know that

00:12:45,550 --> 00:12:48,550
there are differing definitions of the

00:12:46,930 --> 00:12:51,640
first to Fibonacci numbers this is the

00:12:48,550 --> 00:12:54,040
one I like otherwise we're going to take

00:12:51,640 --> 00:12:55,810
the Fibonacci of n minus 1 and the

00:12:54,040 --> 00:12:57,089
Fibonacci number for n minus 2 and add

00:12:55,810 --> 00:12:59,160
them together

00:12:57,089 --> 00:13:01,170
nishan of Fibonacci and you can see

00:12:59,160 --> 00:13:03,769
again side by side with Ruby how that

00:13:01,170 --> 00:13:05,970
works out and these are all fantastic

00:13:03,769 --> 00:13:08,129
but there's this thing called tail call

00:13:05,970 --> 00:13:10,410
optimization that makes these things

00:13:08,129 --> 00:13:13,680
even more awesome so another recursive

00:13:10,410 --> 00:13:17,610
example exponentiation this is a

00:13:13,680 --> 00:13:20,040
function that computes B to the N and if

00:13:17,610 --> 00:13:22,410
n is 10 any number raised to the 0 power

00:13:20,040 --> 00:13:25,920
is one we return one otherwise we

00:13:22,410 --> 00:13:28,680
multiply B times B to the N minus 1 yeah

00:13:25,920 --> 00:13:32,009
recursion is awesome except there's a

00:13:28,680 --> 00:13:33,509
small problem with this stack gets stack

00:13:32,009 --> 00:13:37,199
depth gets pretty high with this version

00:13:33,509 --> 00:13:39,720
so walking through if we start with X of

00:13:37,199 --> 00:13:43,199
2 to the fourth well we're going to go 2

00:13:39,720 --> 00:13:45,689
times X of 2 to the 3 all the way down

00:13:43,199 --> 00:13:47,850
to 2 times 2 times 2 times X to the two

00:13:45,689 --> 00:13:49,559
to the zero and then we're going to

00:13:47,850 --> 00:13:51,480
unwind the stack and I've color coded

00:13:49,559 --> 00:13:53,069
each level the stack is it unwinds and

00:13:51,480 --> 00:13:55,949
we end up with a stack depth of 5 and

00:13:53,069 --> 00:13:57,749
five is not that big a deal but if you

00:13:55,949 --> 00:14:00,600
start computing really big powers you

00:13:57,749 --> 00:14:02,730
might run into some problems so the way

00:14:00,600 --> 00:14:04,649
you can fix that is by using tail call

00:14:02,730 --> 00:14:06,839
optimization a title and the slightest

00:14:04,649 --> 00:14:07,769
wrong I apologize and so what we're

00:14:06,839 --> 00:14:09,389
going to do instead is we're going to

00:14:07,769 --> 00:14:11,279
use an accumulator and we're going to

00:14:09,389 --> 00:14:14,279
write a helper function so we still have

00:14:11,279 --> 00:14:17,100
our X of B to the N but now we have XT

00:14:14,279 --> 00:14:18,839
with B to the N and a third argument and

00:14:17,100 --> 00:14:21,480
that third argument is our product so

00:14:18,839 --> 00:14:24,480
far a partial product which is why it's

00:14:21,480 --> 00:14:25,949
pee in our helper function and what

00:14:24,480 --> 00:14:27,899
we're going to say is that our n is now

00:14:25,949 --> 00:14:29,730
a counter and we're just going to take

00:14:27,899 --> 00:14:32,429
it down by one and we're going to

00:14:29,730 --> 00:14:35,370
increase our product by one it by one

00:14:32,429 --> 00:14:36,779
factor of B and that means that we're

00:14:35,370 --> 00:14:39,329
going to have less work to do when we do

00:14:36,779 --> 00:14:40,860
when we unwind our recursive stack so if

00:14:39,329 --> 00:14:42,209
our counter is zero we're just going to

00:14:40,860 --> 00:14:45,089
return our product whose of our counter

00:14:42,209 --> 00:14:47,220
gets down to zero we're done otherwise

00:14:45,089 --> 00:14:49,170
we're going to call our helper function

00:14:47,220 --> 00:14:51,120
with be we're going to reduce our

00:14:49,170 --> 00:14:52,350
counter by one let's c minus one line

00:14:51,120 --> 00:14:54,720
and we're going to go b times our

00:14:52,350 --> 00:14:56,220
partial product thus far it's a little

00:14:54,720 --> 00:14:58,170
hard to follow so here's what it looks

00:14:56,220 --> 00:15:01,110
like is you actually move through it we

00:14:58,170 --> 00:15:04,350
start with X of 2 to the 4 and then we

00:15:01,110 --> 00:15:06,139
do our helper function with 24 and a

00:15:04,350 --> 00:15:09,629
partial product of one because one's the

00:15:06,139 --> 00:15:10,920
multiplicative identity and then we call

00:15:09,629 --> 00:15:12,600
ourselves again with two

00:15:10,920 --> 00:15:14,519
three and now we've multiplied our base

00:15:12,600 --> 00:15:16,050
times our identity so that's two is our

00:15:14,519 --> 00:15:19,290
partial product is that last argument

00:15:16,050 --> 00:15:20,910
there we go we reduce our counter and

00:15:19,290 --> 00:15:24,899
increase our partial product again so we

00:15:20,910 --> 00:15:27,690
have 2 2 and 4 to 1 and 8 20 and 16 and

00:15:24,899 --> 00:15:29,610
there's our answer our counter is now 0

00:15:27,690 --> 00:15:32,399
so we can return that partial product as

00:15:29,610 --> 00:15:34,350
our final answer so we still end up

00:15:32,399 --> 00:15:36,060
making 5 recursive calls but since at

00:15:34,350 --> 00:15:39,000
every point in the process we've done

00:15:36,060 --> 00:15:40,949
all of our math we don't have nearly as

00:15:39,000 --> 00:15:42,029
much work to do when we unwind the stack

00:15:40,949 --> 00:15:45,240
and it ends up being a lot more

00:15:42,029 --> 00:15:47,220
efficient so the meat of the talk as

00:15:45,240 --> 00:15:49,470
always when I gave a talk on a crazy

00:15:47,220 --> 00:15:52,260
crazy programming paradigm is a semi

00:15:49,470 --> 00:15:54,149
contrived example this case is the

00:15:52,260 --> 00:15:56,370
making change example which i have found

00:15:54,149 --> 00:15:59,040
in every functional programming book i

00:15:56,370 --> 00:16:00,660
have worked on except one and i've

00:15:59,040 --> 00:16:02,970
probably implemented it in four

00:16:00,660 --> 00:16:05,130
languages at this point so the problem

00:16:02,970 --> 00:16:06,449
as stated in sicp is how many different

00:16:05,130 --> 00:16:09,570
ways can you make change of a dollar

00:16:06,449 --> 00:16:11,670
given half dollars quarters dimes and

00:16:09,570 --> 00:16:14,010
nickels so I'm going to walk you through

00:16:11,670 --> 00:16:15,779
my thought process as i sat at home one

00:16:14,010 --> 00:16:18,029
afternoon writing this writing this

00:16:15,779 --> 00:16:20,399
example up for this talk and my first

00:16:18,029 --> 00:16:23,010
response was that's too hard so we're

00:16:20,399 --> 00:16:25,130
going to simplify it how many ways can

00:16:23,010 --> 00:16:27,390
you make some amount with some coins

00:16:25,130 --> 00:16:28,620
well that point I know kind of what my

00:16:27,390 --> 00:16:30,029
function signature is going to look like

00:16:28,620 --> 00:16:32,010
I'm going to define a method count

00:16:30,029 --> 00:16:33,870
change and I'm going to give it an

00:16:32,010 --> 00:16:35,610
amount and I'm going to give it some

00:16:33,870 --> 00:16:38,820
coins you know that's kind of where I

00:16:35,610 --> 00:16:40,800
ended up so let's say an amount is an

00:16:38,820 --> 00:16:42,899
integer number of sense if you've ever

00:16:40,800 --> 00:16:44,339
worked in billing systems this idea of

00:16:42,899 --> 00:16:47,160
an integer number of sense is probably

00:16:44,339 --> 00:16:48,870
familiar to you and I'm going to assume

00:16:47,160 --> 00:16:51,029
I have infinite coins which would be

00:16:48,870 --> 00:16:53,519
awesome so I'm going to make my coins

00:16:51,029 --> 00:16:55,380
collection an array of denominations so

00:16:53,519 --> 00:16:56,550
a penny will be represented by own one

00:16:55,380 --> 00:17:00,149
in this array and Nicko will be

00:16:56,550 --> 00:17:02,699
represented by a 5 and so on so back to

00:17:00,149 --> 00:17:04,230
our simplified original question how

00:17:02,699 --> 00:17:07,290
many ways can you make some amount with

00:17:04,230 --> 00:17:10,290
some coins still too hard we're going to

00:17:07,290 --> 00:17:12,480
simplify again how many ways can you

00:17:10,290 --> 00:17:17,400
make one cent with no coins anybody got

00:17:12,480 --> 00:17:20,100
the answer yep easy answer see I like

00:17:17,400 --> 00:17:21,510
making things simpler it's also sir

00:17:20,100 --> 00:17:23,819
let's write some coin for that let's

00:17:21,510 --> 00:17:24,839
write some code for that case so it's

00:17:23,819 --> 00:17:25,829
not a case statement can

00:17:24,839 --> 00:17:27,959
is functional programming case

00:17:25,829 --> 00:17:29,789
statements are awesome so when our coins

00:17:27,959 --> 00:17:32,279
where ray is empty we have no

00:17:29,789 --> 00:17:33,690
denominations we have no coins we can't

00:17:32,279 --> 00:17:36,299
make change so the answer is always

00:17:33,690 --> 00:17:39,779
going to be zero a for a base case for

00:17:36,299 --> 00:17:41,549
our recursion we test it out we say how

00:17:39,779 --> 00:17:43,440
many ways can we make one cent with no

00:17:41,549 --> 00:17:46,980
coins empty arrayed and represent not

00:17:43,440 --> 00:17:48,360
having coins 0 so it works and because i

00:17:46,980 --> 00:17:49,860
know i'm going to be doing recursion and

00:17:48,360 --> 00:17:51,809
they know i have very limited side to

00:17:49,860 --> 00:17:55,289
side room on my slides I'm gonna alias

00:17:51,809 --> 00:17:58,649
count join count change to CC run it

00:17:55,289 --> 00:18:05,210
again still works so how many ways can

00:17:58,649 --> 00:18:08,640
you make one cent with pennies yep penny

00:18:05,210 --> 00:18:10,080
so um I'm going to fade out the code

00:18:08,640 --> 00:18:11,399
we've already talked about just so you

00:18:10,080 --> 00:18:14,700
can focus on the part that's important

00:18:11,399 --> 00:18:17,340
so we had another case if our mount is

00:18:14,700 --> 00:18:19,350
equal to our first a denomination we

00:18:17,340 --> 00:18:20,610
have one way to make that amount right

00:18:19,350 --> 00:18:24,230
we just use one of those first two

00:18:20,610 --> 00:18:27,000
nominations so run it totally works

00:18:24,230 --> 00:18:32,490
awesome how many ways can you make five

00:18:27,000 --> 00:18:35,190
cents using pennies one that many

00:18:32,490 --> 00:18:36,330
pennies right there this reminding

00:18:35,190 --> 00:18:42,210
anyone else of their like third grade

00:18:36,330 --> 00:18:44,640
homework so another case this is going

00:18:42,210 --> 00:18:47,460
to be our else and we're going to have

00:18:44,640 --> 00:18:48,750
to start using recursion now so if we

00:18:47,460 --> 00:18:50,159
don't know what else to do let's grab

00:18:48,750 --> 00:18:52,380
one of those first coins and our

00:18:50,159 --> 00:18:55,049
denominations array let's say okay I'll

00:18:52,380 --> 00:18:57,059
use one penny now code go figure out how

00:18:55,049 --> 00:18:59,039
to make four cents using whatever coins

00:18:57,059 --> 00:19:01,320
I have left and it's going to go okay

00:18:59,039 --> 00:19:02,850
well I'll use one penny and now Karen go

00:19:01,320 --> 00:19:04,320
figure out how to make three coins three

00:19:02,850 --> 00:19:05,399
cents using the coins I have left and

00:19:04,320 --> 00:19:07,230
eventually we're going to get down to

00:19:05,399 --> 00:19:10,860
one of our base cases and we're going to

00:19:07,230 --> 00:19:15,330
be done so simple recursion test it out

00:19:10,860 --> 00:19:17,010
five cents pennies totally works make it

00:19:15,330 --> 00:19:18,720
even more complicated how many ways can

00:19:17,010 --> 00:19:22,640
you make five cents using nickels and

00:19:18,720 --> 00:19:22,640
pennies yep

00:19:24,410 --> 00:19:29,600
so let's try it see if we got it this'll

00:19:27,680 --> 00:19:33,080
look great that doesn't look like it

00:19:29,600 --> 00:19:34,790
doesn't look right at all so at least

00:19:33,080 --> 00:19:36,530
for me it wasn't obvious what was going

00:19:34,790 --> 00:19:37,760
on when I was coding through this so i

00:19:36,530 --> 00:19:38,960
looked at my code and I'm like you know

00:19:37,760 --> 00:19:40,250
this doesn't make sense so one of the

00:19:38,960 --> 00:19:42,440
things I like to do is I like to

00:19:40,250 --> 00:19:44,630
substitute in my arguments so I've

00:19:42,440 --> 00:19:46,100
bolded the args and now I'm going to

00:19:44,630 --> 00:19:48,200
step through each case and figure out

00:19:46,100 --> 00:19:49,550
where I'm going wrong so the first case

00:19:48,200 --> 00:19:52,940
doesn't match so that can't be the

00:19:49,550 --> 00:19:54,650
problem second case matches though and

00:19:52,940 --> 00:19:56,390
what's happening here is we're saying

00:19:54,650 --> 00:19:58,880
well I'm making five cents I have

00:19:56,390 --> 00:20:02,270
nickels clearly i can make 57 swith a

00:19:58,880 --> 00:20:03,560
nickel and so i'm done except we know

00:20:02,270 --> 00:20:06,380
that you can make five cents using

00:20:03,560 --> 00:20:10,820
nickels or pennies so I think we're

00:20:06,380 --> 00:20:12,170
missing a recursive step here and what

00:20:10,820 --> 00:20:13,970
we need to do is we need to say okay

00:20:12,170 --> 00:20:15,830
it's fantastic code that you can make

00:20:13,970 --> 00:20:17,810
five cents using Nichols now can you use

00:20:15,830 --> 00:20:19,910
the rest of the rest of the coins that

00:20:17,810 --> 00:20:22,160
you have and see if you can make five

00:20:19,910 --> 00:20:23,900
cents using those so here's where that

00:20:22,160 --> 00:20:26,450
dot rest we talked about earlier comes

00:20:23,900 --> 00:20:29,570
in we're going to say it's one so we can

00:20:26,450 --> 00:20:31,580
use that nickel plus however we can

00:20:29,570 --> 00:20:34,820
however many ways we can make five cents

00:20:31,580 --> 00:20:39,620
using the rest of the coins recursion

00:20:34,820 --> 00:20:42,260
it's awesome so let's test it out count

00:20:39,620 --> 00:20:45,620
change of five cents with nickels and

00:20:42,260 --> 00:20:47,120
pennies we get to so that's right let's

00:20:45,620 --> 00:20:49,100
make it even harder how many ways can

00:20:47,120 --> 00:20:54,110
you make ten cents using nickels and

00:20:49,100 --> 00:20:56,960
pennies I look about right to everyone

00:20:54,110 --> 00:20:58,910
three different groupings there two

00:20:56,960 --> 00:21:01,880
nickels nickel and five pennies and ten

00:20:58,910 --> 00:21:03,560
pennies so let's see if we got see if we

00:21:01,880 --> 00:21:09,730
have all the cases we need run the code

00:21:03,560 --> 00:21:12,110
gives us two still not quite right so

00:21:09,730 --> 00:21:14,630
again we substitute in the arguments

00:21:12,110 --> 00:21:16,850
again we don't use the first array first

00:21:14,630 --> 00:21:18,380
case second case doesn't match so I

00:21:16,850 --> 00:21:20,600
think we're missing a recursion on our

00:21:18,380 --> 00:21:22,850
third step now and it's exactly the same

00:21:20,600 --> 00:21:24,740
one we were missing before is our

00:21:22,850 --> 00:21:27,320
existing one is like okay well that's

00:21:24,740 --> 00:21:29,660
that 10-5 is saying we are going to use

00:21:27,320 --> 00:21:32,420
a nickel but we know that we don't have

00:21:29,660 --> 00:21:33,800
to use that nickel so we need to do is

00:21:32,420 --> 00:21:36,260
we need to add a second case where we're

00:21:33,800 --> 00:21:37,789
going to be like okay well how many ways

00:21:36,260 --> 00:21:39,289
can you make it without nickels

00:21:37,789 --> 00:21:41,269
and how many ways can you make it with

00:21:39,289 --> 00:21:43,609
nickels and this is an idea that I

00:21:41,269 --> 00:21:46,100
learned is learned in school called

00:21:43,609 --> 00:21:47,359
weirdo analysis where you say that one

00:21:46,100 --> 00:21:48,710
thing that you're trying to count is the

00:21:47,359 --> 00:21:50,029
weirdo and you count all the ways you

00:21:48,710 --> 00:21:51,019
can do it with the weirdo and all the

00:21:50,029 --> 00:21:52,970
ways that you can do it without the

00:21:51,019 --> 00:21:55,100
weirdo and you add them together so in

00:21:52,970 --> 00:21:56,239
this case our nickel is the weirdo so

00:21:55,100 --> 00:21:57,950
we're going to count all the ways we can

00:21:56,239 --> 00:21:59,419
make ten cents without a nickel and all

00:21:57,950 --> 00:22:00,470
the ways that we can make ten cents with

00:21:59,419 --> 00:22:03,200
a nickel and we're going to add them

00:22:00,470 --> 00:22:05,149
together and I googled it and other

00:22:03,200 --> 00:22:06,619
people call it weirdo analysis too so

00:22:05,149 --> 00:22:10,070
while I may be a weirdo I'm not a weirdo

00:22:06,619 --> 00:22:11,809
because of this so we're gonna count

00:22:10,070 --> 00:22:14,779
change ten cents with nickels and

00:22:11,809 --> 00:22:16,399
pennies we get three so this is where my

00:22:14,779 --> 00:22:17,929
tester brain kicks in because I used to

00:22:16,399 --> 00:22:20,029
be a software tester and I'm like how

00:22:17,929 --> 00:22:21,499
many ways can I break this how many ways

00:22:20,029 --> 00:22:25,580
can you make seven cents using only

00:22:21,499 --> 00:22:29,210
nickels yep there are anyways so I run

00:22:25,580 --> 00:22:31,460
my code stacked up too deep so I think

00:22:29,210 --> 00:22:35,179
we're missing one last case this is just

00:22:31,460 --> 00:22:37,249
not good so substitute the arguments in

00:22:35,179 --> 00:22:38,989
and at this case this point here's the

00:22:37,249 --> 00:22:40,369
place where it's going wrong all the

00:22:38,989 --> 00:22:42,919
other stuffs fine we get to this case

00:22:40,369 --> 00:22:44,899
we're like okay well we'll use a nickel

00:22:42,919 --> 00:22:47,989
and we'll go seven cents minus five

00:22:44,899 --> 00:22:49,970
senses two cents will say hey code can

00:22:47,989 --> 00:22:52,429
you make two cents using nickels and the

00:22:49,970 --> 00:22:53,330
code will just keep going nope nope so

00:22:52,429 --> 00:22:55,099
how many ways going to make negative

00:22:53,330 --> 00:22:57,529
three cents using Nichols how many ways

00:22:55,099 --> 00:22:58,639
can I make negative eight cents using

00:22:57,529 --> 00:23:01,190
Nichols so we're missing and we're

00:22:58,639 --> 00:23:03,919
missing one last case and it's this case

00:23:01,190 --> 00:23:08,330
if our amount is less than our biggest

00:23:03,919 --> 00:23:09,889
denomination we need to try to make our

00:23:08,330 --> 00:23:11,450
amount using the rest of our coins and

00:23:09,889 --> 00:23:12,919
at this point I've introduced very

00:23:11,450 --> 00:23:15,379
subtly a requirement and that

00:23:12,919 --> 00:23:17,359
requirement is that the coins array is

00:23:15,379 --> 00:23:20,960
in descending order by denomination

00:23:17,359 --> 00:23:22,879
otherwise this won't work so just a I

00:23:20,960 --> 00:23:24,470
don't think that's a bad assumption to

00:23:22,879 --> 00:23:26,539
make but I did make that assumption I

00:23:24,470 --> 00:23:28,940
wanted to make that clear so we run it

00:23:26,539 --> 00:23:30,169
we get zero that's correct and at this

00:23:28,940 --> 00:23:32,779
point we're able to go back to our

00:23:30,169 --> 00:23:34,789
original problem which is how many ways

00:23:32,779 --> 00:23:36,649
can you make change of one dollar given

00:23:34,789 --> 00:23:41,330
half dollars quarters dimes nickels and

00:23:36,649 --> 00:23:44,119
pennies there's the code answers 29 292

00:23:41,330 --> 00:23:45,739
and here's the implementation and scheme

00:23:44,119 --> 00:23:47,359
which I still think is much prettier

00:23:45,739 --> 00:23:50,539
than the ruby implementation but it's a

00:23:47,359 --> 00:23:50,919
ruby comp cited in a ruby so it's

00:23:50,539 --> 00:23:52,570
because

00:23:50,919 --> 00:23:54,580
the same as the Rubik version we still

00:23:52,570 --> 00:23:56,879
have the same for case statements are

00:23:54,580 --> 00:23:59,470
for wenn's on our case statement so

00:23:56,879 --> 00:24:01,299
brief side we're gonna do some more

00:23:59,470 --> 00:24:05,649
functions who here knows how to use

00:24:01,299 --> 00:24:07,539
include in Ruby hands good okay it fit

00:24:05,649 --> 00:24:09,279
it's called member in every other

00:24:07,539 --> 00:24:13,149
language known under the Sun pretty much

00:24:09,279 --> 00:24:16,210
so it is this thing part of this list

00:24:13,149 --> 00:24:19,330
that's all it does here's a recursive

00:24:16,210 --> 00:24:22,450
definition if the list is empty clearly

00:24:19,330 --> 00:24:24,190
our thing can't be in it if are the lift

00:24:22,450 --> 00:24:25,690
the first elf thing of our list is the

00:24:24,190 --> 00:24:28,720
thing we're looking for well clearly our

00:24:25,690 --> 00:24:30,389
thing is in the list otherwise go see if

00:24:28,720 --> 00:24:32,470
our thing is in the rest of the list

00:24:30,389 --> 00:24:35,769
basically the exact same logic we were

00:24:32,470 --> 00:24:37,149
just using for counting change here's

00:24:35,769 --> 00:24:40,720
the same function and a slightly smaller

00:24:37,149 --> 00:24:42,429
font because here's the same here's

00:24:40,720 --> 00:24:46,200
exactly the same logic used to implement

00:24:42,429 --> 00:24:48,489
any a the any predicate on innumerable

00:24:46,200 --> 00:24:50,230
the only changes I've made in this case

00:24:48,489 --> 00:24:52,450
is instead of passing in an element that

00:24:50,230 --> 00:24:55,210
i'm looking for an N and passing in a

00:24:52,450 --> 00:24:57,009
predicate function and we're going to

00:24:55,210 --> 00:24:58,539
call that predicate function on the

00:24:57,009 --> 00:25:00,249
first element of the list and if that

00:24:58,539 --> 00:25:02,619
returns true we're going to return true

00:25:00,249 --> 00:25:04,450
otherwise we're going to recursively

00:25:02,619 --> 00:25:06,940
call exactly the same way we did with

00:25:04,450 --> 00:25:09,220
member and pass the predicate in instead

00:25:06,940 --> 00:25:11,460
of the element and this is what I say

00:25:09,220 --> 00:25:14,019
that this this idea is built into Ruby

00:25:11,460 --> 00:25:15,940
fundamentally these concepts the fact

00:25:14,019 --> 00:25:18,609
that you can pass a function as data in

00:25:15,940 --> 00:25:21,879
Ruby really makes it powerful for doing

00:25:18,609 --> 00:25:24,909
functional ideas and you can look at how

00:25:21,879 --> 00:25:26,769
simple that transformation was so here's

00:25:24,909 --> 00:25:29,529
the actual implementation and to use

00:25:26,769 --> 00:25:30,970
this I like to use anonymous functions

00:25:29,529 --> 00:25:32,379
if you're a JavaScript or coffee

00:25:30,970 --> 00:25:33,940
scriptor you probably use these all the

00:25:32,379 --> 00:25:36,249
time if you're rubios you probably use

00:25:33,940 --> 00:25:38,200
them less often but you can see

00:25:36,249 --> 00:25:40,029
side-by-side the lambda implementation

00:25:38,200 --> 00:25:41,559
of an anonymous function and scheme and

00:25:40,029 --> 00:25:45,090
the land implementation of anonymous

00:25:41,559 --> 00:25:47,470
function and Ruby they're really similar

00:25:45,090 --> 00:25:50,739
Ruby really was influenced by Lisp

00:25:47,470 --> 00:25:52,809
really was and you can see that in the

00:25:50,739 --> 00:25:54,850
case of Ruby you do call on the end call

00:25:52,809 --> 00:25:56,049
it in the case of scheme called the same

00:25:54,850 --> 00:25:57,639
way we call any other function outer

00:25:56,049 --> 00:26:00,639
parentheses put the arguments on the end

00:25:57,639 --> 00:26:02,139
close parentheses so we can use those

00:26:00,639 --> 00:26:04,690
anonymous functions with our any

00:26:02,139 --> 00:26:07,090
predicate that we just built up

00:26:04,690 --> 00:26:08,710
and we're going to say any for the list

00:26:07,090 --> 00:26:10,630
of 12 and we have an anonymous function

00:26:08,710 --> 00:26:14,140
that checks to see if anything in that

00:26:10,630 --> 00:26:15,970
list is less than five and the answer is

00:26:14,140 --> 00:26:17,470
true and then we run it again with an

00:26:15,970 --> 00:26:19,180
anonymous functions to see if anything

00:26:17,470 --> 00:26:21,880
in that list is equal to five and the

00:26:19,180 --> 00:26:24,040
answer is false but this idea of passing

00:26:21,880 --> 00:26:26,650
functions as data is built into Ruby and

00:26:24,040 --> 00:26:29,320
is really powerful so I have very little

00:26:26,650 --> 00:26:31,030
time left I highly recommend that you

00:26:29,320 --> 00:26:33,010
learn more I've been talking about this

00:26:31,030 --> 00:26:34,570
talk as a functional programming

00:26:33,010 --> 00:26:35,860
one-on-one this is really the first half

00:26:34,570 --> 00:26:38,080
an hour of functional programming

00:26:35,860 --> 00:26:39,940
one-on-one and there's a lot more that

00:26:38,080 --> 00:26:41,500
you can learn and I think that rubios

00:26:39,940 --> 00:26:43,870
especially can benefit from learning

00:26:41,500 --> 00:26:45,430
these concepts and using them within our

00:26:43,870 --> 00:26:47,410
language and if you do javascript you

00:26:45,430 --> 00:26:49,840
really should learn this because

00:26:47,410 --> 00:26:51,100
javascript especially a lot of well

00:26:49,840 --> 00:26:54,160
written javascript has a lot of these

00:26:51,100 --> 00:26:55,510
ideas in it to my favorite functional

00:26:54,160 --> 00:26:57,610
programming book is the little schemer

00:26:55,510 --> 00:27:00,160
it's really thin I didn't bring it

00:26:57,610 --> 00:27:02,020
because I didn't have room in my bag you

00:27:00,160 --> 00:27:06,130
could finish it in a weekend I don't

00:27:02,020 --> 00:27:08,650
recommend you do because it's dense and

00:27:06,130 --> 00:27:12,460
it's written in Socratic dialogue it's

00:27:08,650 --> 00:27:14,470
so awesome it's two columns questions on

00:27:12,460 --> 00:27:17,470
the Left answers on the right all the

00:27:14,470 --> 00:27:19,120
way through it's weird on there are two

00:27:17,470 --> 00:27:21,700
other books in the series the season

00:27:19,120 --> 00:27:23,080
schemer and the reason schemer once you

00:27:21,700 --> 00:27:24,250
could pass a little schemer I recommend

00:27:23,080 --> 00:27:26,320
those two as well and have them all

00:27:24,250 --> 00:27:27,820
lined up on my shelf at home the reason

00:27:26,320 --> 00:27:31,120
schemer builds a constraint solving

00:27:27,820 --> 00:27:33,310
system I love prologue by the end so you

00:27:31,120 --> 00:27:35,590
can go from nothing to the reason

00:27:33,310 --> 00:27:37,870
schemer and probably less than 150 pages

00:27:35,590 --> 00:27:42,340
and that shows you have dense these

00:27:37,870 --> 00:27:44,260
books are and then structure an

00:27:42,340 --> 00:27:46,030
interpretation of computer programs this

00:27:44,260 --> 00:27:48,070
was an introductory text on functional

00:27:46,030 --> 00:27:50,320
programming or programming completely at

00:27:48,070 --> 00:27:52,930
MIT for a number of years it's also

00:27:50,320 --> 00:27:54,610
known as the wizard book if you do it i

00:27:52,930 --> 00:27:56,410
recommend a study group and if you do a

00:27:54,610 --> 00:27:59,320
study group i recommend not doing what

00:27:56,410 --> 00:28:02,890
Aaron Ryan and I did you don't have to

00:27:59,320 --> 00:28:04,330
do all the problems we did them all it

00:28:02,890 --> 00:28:06,940
took us nine months I don't recommend

00:28:04,330 --> 00:28:09,760
that but this goes from reverse a list

00:28:06,940 --> 00:28:11,920
to implement a scheme interpreter annual

00:28:09,760 --> 00:28:14,800
and language of your choice like that is

00:28:11,920 --> 00:28:16,720
the last problem in the book so it it

00:28:14,800 --> 00:28:18,400
also builds a constraint solving system

00:28:16,720 --> 00:28:20,380
and deals with environments and

00:28:18,400 --> 00:28:23,440
all sorts of other awesome things um I

00:28:20,380 --> 00:28:25,390
did build to construe a scheme

00:28:23,440 --> 00:28:26,800
interpreter and Ruby if you want to see

00:28:25,390 --> 00:28:29,050
it come find me later as I said last

00:28:26,800 --> 00:28:32,620
night I wear pink at conferences so I'm

00:28:29,050 --> 00:28:34,270
easy to find and if you're like me and

00:28:32,620 --> 00:28:35,650
you're more of an auditory learner there

00:28:34,270 --> 00:28:37,060
are a lot of great talks on functional

00:28:35,650 --> 00:28:39,400
programming on con freaks here are four

00:28:37,060 --> 00:28:41,520
of my favorites functional programming

00:28:39,400 --> 00:28:45,580
in Ruby by Pat Shaughnessy from go ruko

00:28:41,520 --> 00:28:47,350
2013 parenthetically speaking by Jim

00:28:45,580 --> 00:28:49,900
wyrick that's the Golden Gate Ruby comp

00:28:47,350 --> 00:28:51,610
2010 keynote that I watched and kind of

00:28:49,900 --> 00:28:54,250
got me down this path and was the

00:28:51,610 --> 00:28:56,350
inspiration for this talk sadly the con

00:28:54,250 --> 00:28:58,720
freaks video cuts out 45 minutes into a

00:28:56,350 --> 00:29:00,100
90-minute talk so most of what you get

00:28:58,720 --> 00:29:01,600
is physical chemistry and emission

00:29:00,100 --> 00:29:05,140
spectra which I still think is awesome

00:29:01,600 --> 00:29:06,520
but it's not quite as awesome also

00:29:05,140 --> 00:29:08,500
there's functional principles 400

00:29:06,520 --> 00:29:10,690
development by jessica care from rubia

00:29:08,500 --> 00:29:12,100
Midwest 2013 this is an awesome talk

00:29:10,690 --> 00:29:13,510
because Jessica's a great speaker but

00:29:12,100 --> 00:29:16,060
also because she does functional

00:29:13,510 --> 00:29:17,260
programming every day unlike me and

00:29:16,060 --> 00:29:18,700
unlike a lot of people who give these

00:29:17,260 --> 00:29:20,380
talks and so she has a very different

00:29:18,700 --> 00:29:21,460
interpretation of it she's coming at it

00:29:20,380 --> 00:29:23,530
from a functional person who's

00:29:21,460 --> 00:29:25,090
interested in Ruby and she's a very

00:29:23,530 --> 00:29:27,490
animated speaker so you cannot fall

00:29:25,090 --> 00:29:29,080
asleep during her talks and why not

00:29:27,490 --> 00:29:30,370
adventures in functional programming by

00:29:29,080 --> 00:29:31,900
Jim weihrauch this is the talk that was

00:29:30,370 --> 00:29:33,460
making the rounds of Twitter right after

00:29:31,900 --> 00:29:35,530
gym time the earlier this year and it's

00:29:33,460 --> 00:29:37,180
a fantastic talk I highly recommend

00:29:35,530 --> 00:29:39,370
watching the video I was in the audience

00:29:37,180 --> 00:29:41,230
for this talk and I understood the Y

00:29:39,370 --> 00:29:43,480
Combinator when I walked in and I could

00:29:41,230 --> 00:29:46,510
barely keep up because it is information

00:29:43,480 --> 00:29:48,190
dense but Jim is a fantastic speaker was

00:29:46,510 --> 00:29:50,380
a fantastic speaker and so you should

00:29:48,190 --> 00:29:51,970
really sit down and watch this with your

00:29:50,380 --> 00:29:54,640
finger on the pause button to figure out

00:29:51,970 --> 00:29:56,170
what the heck he just did um photo

00:29:54,640 --> 00:29:57,640
credits if you're going to use photos

00:29:56,170 --> 00:29:59,530
and talks i highly recommend you credit

00:29:57,640 --> 00:30:02,500
them i only had one this time which was

00:29:59,530 --> 00:30:04,330
the boring born pony thank you very much

00:30:02,500 --> 00:30:12,370
i 30 seconds so i have time for one

00:30:04,330 --> 00:30:14,410
question yes of course the question was

00:30:12,370 --> 00:30:16,480
what's my opinion on closure uh I

00:30:14,410 --> 00:30:18,130
haven't used it but everyone I know who

00:30:16,480 --> 00:30:21,000
used it whose is it is smart so it's

00:30:18,130 --> 00:30:21,000
probably pretty awesome

00:30:22,179 --> 00:30:25,630
okay thank you guys

00:30:45,549 --> 00:30:47,610

YouTube URL: https://www.youtube.com/watch?v=Qyn4NyeftUE


