Title: MountainWest RubyConf 2014 - New Ruby 2.1 Awesomeness: Pro Object Allocation Tracing
Publication date: 2020-01-24
Playlist: MWRC 2014
Description: 
	By Sam Rawlins

Ruby 2.1 is coming out soon with an amazing new feature under ObjectSpace: #trace_object_allocations. We are now able to trace the file and line number (as well as method) where any Ruby object is allocated from. This is a very welcome feature, as object-level tracing has been very difficult in Ruby, especially since the memprof gem could not support Ruby past 1.8.x.
This new Ruby 2.1 feature is really just exposing some raw (and vast) data, so it can be difficult to tease out meaningful information. Two gems are introduced in this talk to solve just that problem. The objspace-stats gem allows us to view and summarize new object allocations in meaningful ways. We'll look at how to filter, group, and sort new object allocations. The second gem is rack-objspace-stats. We'll see how this tool can intercept requests to a Rack stack, and measure new object allocations taking place during the request. (For those familiar, this works very similar to the rack-perftools_profiler gem.)
We'll look at various examples of how this new Ruby 2.1 feature, and these tools can help an organization reduce unnecessary memory allocations, and speed up their code, especially mature Rack applications.

Help us caption & translate this video!

http://amara.org/v/FG2j/
Captions: 
	00:00:24,680 --> 00:00:29,730
hey guys I'm Sam Rollins on the last

00:00:28,410 --> 00:00:34,080
talked before lunch so I'm going to make

00:00:29,730 --> 00:00:35,520
this as fast as I can and I'm not sure

00:00:34,080 --> 00:00:38,489
I'm going to take questions because I

00:00:35,520 --> 00:00:40,170
really am eager to get to lunch and that

00:00:38,489 --> 00:00:42,330
this I may have packed more than I

00:00:40,170 --> 00:00:44,760
should have been to this so my talk is

00:00:42,330 --> 00:00:47,520
going to be on a new feature in Ruby 2.1

00:00:44,760 --> 00:00:51,690
called tracing object allocations it's

00:00:47,520 --> 00:00:53,399
super exciting so Ruby 2.1 is out raise

00:00:51,690 --> 00:00:55,470
your hand if you've installed it or used

00:00:53,399 --> 00:00:57,180
any new features in Ruby 21 awesome this

00:00:55,470 --> 00:01:00,690
is like that's a better adoption the

00:00:57,180 --> 00:01:02,700
Ruby 19 when it came out so you can grab

00:01:00,690 --> 00:01:05,220
it with our bien rvm of course they both

00:01:02,700 --> 00:01:07,770
allow you to grab it here's the news

00:01:05,220 --> 00:01:09,450
file of all the features and what I'm

00:01:07,770 --> 00:01:12,149
going to talk about is this little guy

00:01:09,450 --> 00:01:15,750
in the corner object space trace object

00:01:12,149 --> 00:01:17,369
allocations so object space is not new

00:01:15,750 --> 00:01:19,050
you may have used like count objects

00:01:17,369 --> 00:01:21,390
each object it's where the garbage

00:01:19,050 --> 00:01:24,479
collect method is but they've added a

00:01:21,390 --> 00:01:26,190
couple new methods into one trace object

00:01:24,479 --> 00:01:30,600
allocations and then a couple sibling

00:01:26,190 --> 00:01:31,920
functions start-stop clear so let's

00:01:30,600 --> 00:01:33,330
start off with an anecdote from github

00:01:31,920 --> 00:01:35,580
that's kind of where this story begins

00:01:33,330 --> 00:01:38,310
they have a blog post called Hey Judy

00:01:35,580 --> 00:01:40,020
don't make it bad and they kind of tell

00:01:38,310 --> 00:01:41,909
the story of when they fire up the

00:01:40,020 --> 00:01:43,799
github app and immediately count how

00:01:41,909 --> 00:01:46,320
many objects are memory and

00:01:43,799 --> 00:01:48,780
referenceable there's more than 600,000

00:01:46,320 --> 00:01:50,340
Ruby objects hanging out this way more

00:01:48,780 --> 00:01:52,619
than they they thought should be the

00:01:50,340 --> 00:01:55,110
case so this was a mystery and at the

00:01:52,619 --> 00:01:57,570
time there aren't any there weren't any

00:01:55,110 --> 00:01:59,640
great ways to profile memory and they're

00:01:57,570 --> 00:02:01,890
kind of up until Ruby 21 there there

00:01:59,640 --> 00:02:04,259
weren't any good ones I think mem prof

00:02:01,890 --> 00:02:07,259
was a good one for Ruby 18 which didn't

00:02:04,259 --> 00:02:09,110
work in Ruby 19 and this is kind of

00:02:07,259 --> 00:02:11,820
there's been a void here there's great

00:02:09,110 --> 00:02:13,560
sequel profiling tools CPU profiling

00:02:11,820 --> 00:02:15,870
tools but this is there's been a gap

00:02:13,560 --> 00:02:17,700
here the so this is kind of what we're

00:02:15,870 --> 00:02:20,190
trying to solve is where am I supposedly

00:02:17,700 --> 00:02:22,079
hogging all this memory so enter trace

00:02:20,190 --> 00:02:24,870
object allocations let's look at an

00:02:22,079 --> 00:02:27,329
example we have a simple class here with

00:02:24,870 --> 00:02:29,549
a method that returns an array so it

00:02:27,329 --> 00:02:31,200
allocates and returns an array and then

00:02:29,549 --> 00:02:34,230
another method that allocates and

00:02:31,200 --> 00:02:36,239
returns a string and I want to trace

00:02:34,230 --> 00:02:40,560
my object allocations so what we can do

00:02:36,239 --> 00:02:43,680
is sorry is we can call some code here

00:02:40,560 --> 00:02:44,849
we're gonna we're gonna the two lines in

00:02:43,680 --> 00:02:47,280
the middle of there are the important

00:02:44,849 --> 00:02:50,790
ones where we say I'm going to save this

00:02:47,280 --> 00:02:53,010
this return value from an array and the

00:02:50,790 --> 00:02:55,470
variable a and then I'm going to save my

00:02:53,010 --> 00:02:57,390
class new string into it the S variable

00:02:55,470 --> 00:02:59,610
and I want to trace this code so you

00:02:57,390 --> 00:03:02,640
wrap that code in a block and pass it to

00:02:59,610 --> 00:03:04,440
trace object allocations and then what

00:03:02,640 --> 00:03:06,060
you're provided is a couple other helper

00:03:04,440 --> 00:03:10,890
methods in object space that can tell

00:03:06,060 --> 00:03:13,410
you what file allocated this object my a

00:03:10,890 --> 00:03:15,930
object and what line was it allocated on

00:03:13,410 --> 00:03:18,090
and what class and what method are the

00:03:15,930 --> 00:03:20,849
kind of allocation sites for this little

00:03:18,090 --> 00:03:22,170
object my little a variable here so

00:03:20,849 --> 00:03:25,230
that's pretty cool it tells you example

00:03:22,170 --> 00:03:28,019
3 r-b tells you my closet tells you line

00:03:25,230 --> 00:03:29,879
3 there's also an alternate method so if

00:03:28,019 --> 00:03:31,769
if it's a little kludgy to wrap your

00:03:29,879 --> 00:03:33,959
code in a block that you wanted to trace

00:03:31,769 --> 00:03:36,299
you can also just call trace out object

00:03:33,959 --> 00:03:38,959
allocations start run your code and then

00:03:36,299 --> 00:03:41,489
call stop you get the same functionality

00:03:38,959 --> 00:03:44,220
so why why are we doing this why is this

00:03:41,489 --> 00:03:45,510
interesting in general we want to do two

00:03:44,220 --> 00:03:47,459
things we can reduce the memory

00:03:45,510 --> 00:03:49,380
footprint here that was github big thing

00:03:47,459 --> 00:03:50,910
there they write when they start up they

00:03:49,380 --> 00:03:53,639
have all these objects and they do not

00:03:50,910 --> 00:03:55,680
want all those objects so this can help

00:03:53,639 --> 00:03:57,419
performance in your applications and

00:03:55,680 --> 00:03:58,650
then it can also help reduce garbage

00:03:57,419 --> 00:04:01,319
collection times so if you have fewer

00:03:58,650 --> 00:04:04,709
objects garbage collection will just run

00:04:01,319 --> 00:04:06,180
faster specifically marking and sweeping

00:04:04,709 --> 00:04:08,069
so even if these are tiny objects even

00:04:06,180 --> 00:04:10,829
if it's a bunch of empty arrays or small

00:04:08,069 --> 00:04:13,980
strings one character strings this will

00:04:10,829 --> 00:04:16,019
reduce marking and sweeping in garbage

00:04:13,980 --> 00:04:17,789
collection so you say but my application

00:04:16,019 --> 00:04:19,590
is an on Ruby 2 point 1 this is no no

00:04:17,789 --> 00:04:21,419
use of to me that's okay it's a

00:04:19,590 --> 00:04:23,820
diagnostic tool if you can get your app

00:04:21,419 --> 00:04:25,080
to run locally in Ruby 21 then you can

00:04:23,820 --> 00:04:26,580
play around with this stuff and get some

00:04:25,080 --> 00:04:28,440
information out you don't need to bump

00:04:26,580 --> 00:04:31,860
your production application to Ruby 21

00:04:28,440 --> 00:04:34,590
to use this um so what we just saw there

00:04:31,860 --> 00:04:35,970
that example trace object allocations is

00:04:34,590 --> 00:04:38,039
pretty limited I have to have a handle

00:04:35,970 --> 00:04:39,810
on an object and say this this variable

00:04:38,039 --> 00:04:42,570
Ruby tell me where it came from and it

00:04:39,810 --> 00:04:44,640
can tell you and that's super limited

00:04:42,570 --> 00:04:46,020
you don't have little handles on all

00:04:44,640 --> 00:04:48,030
your on all your objects at any one

00:04:46,020 --> 00:04:49,200
place it's also very fine

00:04:48,030 --> 00:04:51,810
grain so it's only going to tell you

00:04:49,200 --> 00:04:53,220
information about each object but it's

00:04:51,810 --> 00:04:54,810
just the start I think this is super

00:04:53,220 --> 00:04:57,090
exciting so we can start to write tools

00:04:54,810 --> 00:04:59,610
around this to get better information

00:04:57,090 --> 00:05:02,310
about our apps as a whole so the next

00:04:59,610 --> 00:05:04,380
step is aggregation I've got a gem

00:05:02,310 --> 00:05:06,240
called allocation stats it of course

00:05:04,380 --> 00:05:09,210
requires Ruby 2.1 it requires that new

00:05:06,240 --> 00:05:12,090
feature to get going let's look at an

00:05:09,210 --> 00:05:15,090
example of how this works so we have a

00:05:12,090 --> 00:05:17,040
class that has method on line three it's

00:05:15,090 --> 00:05:19,350
going to allocate a hash and we have

00:05:17,040 --> 00:05:21,600
three string keys or three string values

00:05:19,350 --> 00:05:24,030
their online three online for we

00:05:21,600 --> 00:05:25,500
allocate another string so what we're

00:05:24,030 --> 00:05:28,470
going to do is require allocation stats

00:05:25,500 --> 00:05:31,200
and then line ten has my class new my

00:05:28,470 --> 00:05:33,420
method and we're going to wrap that in a

00:05:31,200 --> 00:05:36,150
block and pass it to allocation stats

00:05:33,420 --> 00:05:38,820
trace so very similar API to the the

00:05:36,150 --> 00:05:41,460
basic Ruby the basic library API and

00:05:38,820 --> 00:05:43,680
then we're going to call the allocations

00:05:41,460 --> 00:05:46,080
in that stats object and to text gives

00:05:43,680 --> 00:05:48,830
us this nice tabular output so here we

00:05:46,080 --> 00:05:51,870
can see online for we allocated a string

00:05:48,830 --> 00:05:54,210
in and the the classpath and method

00:05:51,870 --> 00:05:56,250
where my class and my method on line

00:05:54,210 --> 00:05:59,040
three we allocated that hash and the

00:05:56,250 --> 00:06:00,900
three string values in line ten you can

00:05:59,040 --> 00:06:03,240
see we allocated a new instance of my

00:06:00,900 --> 00:06:05,160
class so remember from the previous talk

00:06:03,240 --> 00:06:06,780
each time you called out new first it

00:06:05,160 --> 00:06:08,820
allocates memory and then it calls the

00:06:06,780 --> 00:06:10,770
initialized method so we're allocating

00:06:08,820 --> 00:06:14,550
my class objects as well when we when we

00:06:10,770 --> 00:06:16,770
run this code so again we have not

00:06:14,550 --> 00:06:18,450
aggregated results yet so let's group by

00:06:16,770 --> 00:06:20,940
we have the same code here same code

00:06:18,450 --> 00:06:24,210
here this time we're going to group by

00:06:20,940 --> 00:06:26,340
source file source line and class so now

00:06:24,210 --> 00:06:27,480
this tabular output is going to have

00:06:26,340 --> 00:06:29,130
allocations but they're going to be

00:06:27,480 --> 00:06:31,860
grouped by those three those three

00:06:29,130 --> 00:06:33,420
fields so we can see here we've now

00:06:31,860 --> 00:06:35,730
grouped those three strings that we

00:06:33,420 --> 00:06:38,280
allocated on line three it's showing

00:06:35,730 --> 00:06:39,570
that three strings were allocated and so

00:06:38,280 --> 00:06:41,190
that's kind of there in that table much

00:06:39,570 --> 00:06:43,800
more useful than seeing each individual

00:06:41,190 --> 00:06:45,330
allocation let's look at a more

00:06:43,800 --> 00:06:48,030
complicated example psyche is a really

00:06:45,330 --> 00:06:51,060
fun one so this is again the the llamo

00:06:48,030 --> 00:06:53,340
parsing library in the standard Ruby

00:06:51,060 --> 00:06:54,930
library here's like almost the most

00:06:53,340 --> 00:06:56,700
basic example I could think of we're

00:06:54,930 --> 00:06:58,330
going to take an array of two strings

00:06:56,700 --> 00:07:00,370
dump it to yamo

00:06:58,330 --> 00:07:02,110
and see what happens when when we run

00:07:00,370 --> 00:07:04,479
that code so we're going to wrap that in

00:07:02,110 --> 00:07:05,620
a call to trace the the allocations

00:07:04,479 --> 00:07:07,539
we're going to this time I'm going to

00:07:05,620 --> 00:07:10,120
group by source file and then the class

00:07:07,539 --> 00:07:12,969
of the objects being allocated and this

00:07:10,120 --> 00:07:14,439
is what we get so first we see at the

00:07:12,969 --> 00:07:17,259
top there there were 38 strings

00:07:14,439 --> 00:07:20,139
allocated in visitor there were five

00:07:17,259 --> 00:07:22,900
match data's that's the result of a JAX

00:07:20,139 --> 00:07:24,879
match in visitor Darby and we see more

00:07:22,900 --> 00:07:27,099
you see down further below there's 12

00:07:24,879 --> 00:07:29,979
arrays being allocated in yeah moultrie

00:07:27,099 --> 00:07:31,870
so these aren't sorted yet let's make it

00:07:29,979 --> 00:07:33,550
a little more useful we loop by will

00:07:31,870 --> 00:07:35,800
call the same code will group by source

00:07:33,550 --> 00:07:38,889
file in class again this time let's sort

00:07:35,800 --> 00:07:41,469
it and now we can see our top allocation

00:07:38,889 --> 00:07:44,259
sites there are 38 strings from visitor

00:07:41,469 --> 00:07:45,940
and 21 strings and 12 arrays from yamel

00:07:44,259 --> 00:07:47,979
tree and if you want you can group those

00:07:45,940 --> 00:07:50,349
by line and see where the lines are and

00:07:47,979 --> 00:07:53,110
I I see this and I'm just like super

00:07:50,349 --> 00:07:56,139
interested like I want to dump an array

00:07:53,110 --> 00:07:57,580
of two little strings to yamo and you

00:07:56,139 --> 00:07:59,020
get all these allocations and visitor

00:07:57,580 --> 00:08:00,699
like that's just super interesting to

00:07:59,020 --> 00:08:02,020
see like what is going on in that

00:08:00,699 --> 00:08:04,419
visitor file and it could be all

00:08:02,020 --> 00:08:06,430
necessary I found that a lot that a lot

00:08:04,419 --> 00:08:11,440
of this is like accidental necessary

00:08:06,430 --> 00:08:13,449
code but it's interesting class plus is

00:08:11,440 --> 00:08:16,419
a cool little feature where we can dive

00:08:13,449 --> 00:08:18,339
in and group by group by something

00:08:16,419 --> 00:08:20,589
something more special so here we're

00:08:18,339 --> 00:08:22,930
using the hike library and the hike gem

00:08:20,589 --> 00:08:25,270
is um kind of the core of sprockets

00:08:22,930 --> 00:08:27,430
where it's you can tell the hike library

00:08:25,270 --> 00:08:29,409
here's a subdirectory give me all the

00:08:27,430 --> 00:08:31,509
files that match this pattern so here

00:08:29,409 --> 00:08:34,719
we're actually looking at hikes own

00:08:31,509 --> 00:08:38,349
directory and we're going to search for

00:08:34,719 --> 00:08:40,899
all the RB files and again group by

00:08:38,349 --> 00:08:43,390
source file and class plus this time and

00:08:40,899 --> 00:08:45,339
now you can see we have a couple more

00:08:43,390 --> 00:08:48,519
interesting results it'll it'll so class

00:08:45,339 --> 00:08:51,070
plus we'll show you that online or in

00:08:48,519 --> 00:08:54,100
kernel require their 134 allocations of

00:08:51,070 --> 00:08:56,649
arrays and all of those arrays were just

00:08:54,100 --> 00:08:58,600
a raise of fixed numbs and falses so if

00:08:56,649 --> 00:09:00,940
if there if the members are limited to a

00:08:58,600 --> 00:09:04,269
couple classes it'll it'll give you that

00:09:00,940 --> 00:09:07,029
information so maybe that's not terribly

00:09:04,269 --> 00:09:08,800
interesting but the second one you see

00:09:07,029 --> 00:09:10,990
these are arrays of strings so strings

00:09:08,800 --> 00:09:12,279
themselves are also allocations and the

00:09:10,990 --> 00:09:15,249
third one is a raise of array

00:09:12,279 --> 00:09:16,470
so this this is kind of interesting what

00:09:15,249 --> 00:09:18,639
looks a little weird here though is that

00:09:16,470 --> 00:09:20,589
I'm in the hike gem I was kind of

00:09:18,639 --> 00:09:23,860
curious about what the hike gem does and

00:09:20,589 --> 00:09:26,139
all my top allocation sites here are in

00:09:23,860 --> 00:09:28,569
Ruby gems Colonel require that's super

00:09:26,139 --> 00:09:30,040
surprising and I don't want to look in

00:09:28,569 --> 00:09:32,649
Colonel require I'm not interested in

00:09:30,040 --> 00:09:34,149
that so what's actually happening here

00:09:32,649 --> 00:09:36,879
is and then we also have some Ruby VM

00:09:34,149 --> 00:09:38,439
instruction sequences in the top sites

00:09:36,879 --> 00:09:42,040
there so what's happening here is I

00:09:38,439 --> 00:09:44,410
think the hike gem uses auto load and so

00:09:42,040 --> 00:09:46,870
it is even though I require hike before

00:09:44,410 --> 00:09:48,399
tracing the hike gem itself is using

00:09:46,870 --> 00:09:50,860
auto load and whatever libraries it's

00:09:48,399 --> 00:09:52,660
it's loading are loaded after I've begun

00:09:50,860 --> 00:09:55,029
tracing and so we get all these ugly

00:09:52,660 --> 00:09:57,399
stats here so to solve that we can burn

00:09:55,029 --> 00:10:00,069
one this is like in poker burning a card

00:09:57,399 --> 00:10:02,709
so if we call burn one and then give it

00:10:00,069 --> 00:10:04,779
this same block then it's going to run

00:10:02,709 --> 00:10:06,519
the block once without tracing it

00:10:04,779 --> 00:10:07,749
doesn't care about what happened then

00:10:06,519 --> 00:10:09,339
it's going to run the block a second

00:10:07,749 --> 00:10:11,110
time tracing and then we get much

00:10:09,339 --> 00:10:13,269
cleaner output we see the the top

00:10:11,110 --> 00:10:15,639
allocation site is in path name which

00:10:13,269 --> 00:10:20,199
makes sense for this this library that

00:10:15,639 --> 00:10:22,839
looks around pads a running inside your

00:10:20,199 --> 00:10:24,790
specs is a cool feature so if you're

00:10:22,839 --> 00:10:26,559
kind of thinking like I'd like my you

00:10:24,790 --> 00:10:28,569
know is my gem or asthma is a library

00:10:26,559 --> 00:10:31,149
that I use like using a lot of objects

00:10:28,569 --> 00:10:33,910
that it doesn't need to allocate so and

00:10:31,149 --> 00:10:36,850
then where do I start that investigation

00:10:33,910 --> 00:10:38,170
so in at the top of your spec help or if

00:10:36,850 --> 00:10:41,079
you're using our spec and I'd love to

00:10:38,170 --> 00:10:43,059
put this into other spec tools you can

00:10:41,079 --> 00:10:45,850
require allocation stats until it to

00:10:43,059 --> 00:10:48,610
trace our spec and you'll get this

00:10:45,850 --> 00:10:50,740
result so here I'm tracing the mail gem

00:10:48,610 --> 00:10:53,319
the mail gem has incredible test

00:10:50,740 --> 00:10:55,480
coverage they have a lot of tests so I

00:10:53,319 --> 00:10:57,579
just included that at the top and I ran

00:10:55,480 --> 00:11:00,429
the specs there were a ton of specs and

00:10:57,579 --> 00:11:02,139
you get the top ten allocation sites so

00:11:00,429 --> 00:11:05,110
the first one there is string

00:11:02,139 --> 00:11:09,009
allocations in utilities wine 180 and

00:11:05,110 --> 00:11:12,040
you can see which spec feature the most

00:11:09,009 --> 00:11:13,839
allocations for that line so attachments

00:11:12,040 --> 00:11:17,439
list spec and then you get a line that's

00:11:13,839 --> 00:11:19,720
that's cut off that had 4639 allocations

00:11:17,439 --> 00:11:21,459
of strings it may be a little weird like

00:11:19,720 --> 00:11:23,170
is this a huge spec it kind of seems

00:11:21,459 --> 00:11:24,910
like it doesn't maybe doesn't need to be

00:11:23,170 --> 00:11:25,870
like message spec you seem like they

00:11:24,910 --> 00:11:28,120
should be unit tests

00:11:25,870 --> 00:11:31,000
and then you see so you get the top

00:11:28,120 --> 00:11:33,310
examples and then the next allocation

00:11:31,000 --> 00:11:35,170
site is arrays being allocated and

00:11:33,310 --> 00:11:37,570
received parser and you get some more

00:11:35,170 --> 00:11:39,490
that you get this long list and then

00:11:37,570 --> 00:11:42,040
from there you can like go crazy and try

00:11:39,490 --> 00:11:43,839
and reduce reduce allocations and we'll

00:11:42,040 --> 00:11:46,660
see some ways to reduce allocations in a

00:11:43,839 --> 00:11:48,610
bit so this was super interesting i sent

00:11:46,660 --> 00:11:51,580
them a pull request reducing allocations

00:11:48,610 --> 00:11:53,560
by a significant amount it was it's

00:11:51,580 --> 00:11:56,290
super fun to go through a library and do

00:11:53,560 --> 00:11:58,750
this so this helps reduce object turn

00:11:56,290 --> 00:12:00,450
this is kind of the biggest cost of

00:11:58,750 --> 00:12:02,680
garbage collection this is a known

00:12:00,450 --> 00:12:04,720
computer science ii thing is that in

00:12:02,680 --> 00:12:06,970
java and ruby in these languages with

00:12:04,720 --> 00:12:08,830
garbage collectors most objects are

00:12:06,970 --> 00:12:10,390
young objects they die as young objects

00:12:08,830 --> 00:12:12,910
and so you get a lot of object churn and

00:12:10,390 --> 00:12:16,360
this is the difficulty in garbage

00:12:12,910 --> 00:12:19,720
collection is is quickly collecting

00:12:16,360 --> 00:12:23,260
young objects especially in if you have

00:12:19,720 --> 00:12:24,940
a rack app those those per request

00:12:23,260 --> 00:12:26,980
allocations right so you have a request

00:12:24,940 --> 00:12:28,720
coming in it goes through your entire

00:12:26,980 --> 00:12:30,070
rack pipeline into your rails pipeline

00:12:28,720 --> 00:12:31,570
you're generating response coming out

00:12:30,070 --> 00:12:32,860
it's generating all these strings and

00:12:31,570 --> 00:12:35,020
objects and grading the database

00:12:32,860 --> 00:12:36,520
generating thousands of allocations and

00:12:35,020 --> 00:12:38,740
then as soon as your response goes out

00:12:36,520 --> 00:12:40,029
there all garbage they're all they're

00:12:38,740 --> 00:12:43,080
all worthless unless you're kind of like

00:12:40,029 --> 00:12:46,300
unless these are like memorized objects

00:12:43,080 --> 00:12:48,760
so we also have rack allocation stats is

00:12:46,300 --> 00:12:50,680
another excellent tool so it's a rack

00:12:48,760 --> 00:12:54,250
middleware if you have a rack app that

00:12:50,680 --> 00:12:57,010
maybe sits here it responds to to this

00:12:54,250 --> 00:13:00,160
request maybe my rack app port 9292 at a

00:12:57,010 --> 00:13:02,950
path with some parameters you can add

00:13:00,160 --> 00:13:06,390
raz trace equals true r as for rack

00:13:02,950 --> 00:13:08,740
allocation stats and then instead of

00:13:06,390 --> 00:13:11,790
sending you back the response that you

00:13:08,740 --> 00:13:13,720
were expecting it's going to give you

00:13:11,790 --> 00:13:16,450
yes let's look at this it's going to

00:13:13,720 --> 00:13:18,070
give you those sites it's going to give

00:13:16,450 --> 00:13:21,190
you the top sites so let's look at an

00:13:18,070 --> 00:13:24,040
example this is a super simple Sinatra

00:13:21,190 --> 00:13:26,440
app it responds to one path at ER be

00:13:24,040 --> 00:13:28,839
it's going to parse this er be down here

00:13:26,440 --> 00:13:31,779
and it's going to say hello world in six

00:13:28,839 --> 00:13:36,040
languages very simple app and let's

00:13:31,779 --> 00:13:38,050
let's see what happens so here it's

00:13:36,040 --> 00:13:39,570
super washed out at the top but this is

00:13:38,050 --> 00:13:41,400
like the normal app just the slash

00:13:39,570 --> 00:13:44,640
BRB path you see hello world in six

00:13:41,400 --> 00:13:48,000
languages if i add razz trace equals

00:13:44,640 --> 00:13:50,550
true this is the response i get so we

00:13:48,000 --> 00:13:53,370
see the top allocation sites by default

00:13:50,550 --> 00:13:55,800
it's by file it gruesome by file line in

00:13:53,370 --> 00:13:57,990
class plus so you see like the seventh

00:13:55,800 --> 00:14:01,110
one down that it's allocating 15 a raise

00:13:57,990 --> 00:14:03,300
of strings so this is a way to like

00:14:01,110 --> 00:14:05,670
trace your rack apps there's a couple

00:14:03,300 --> 00:14:08,040
features if you pass in razz help it'll

00:14:05,670 --> 00:14:10,710
give you it'll respond with help text in

00:14:08,040 --> 00:14:13,740
the browser alias paths equals true

00:14:10,710 --> 00:14:16,470
helps with super long absolute file

00:14:13,740 --> 00:14:18,030
paths so you see the top ones there er

00:14:16,470 --> 00:14:20,460
be is in the Ruby live der so it's just

00:14:18,030 --> 00:14:23,550
kind of alias that for you like the six

00:14:20,460 --> 00:14:24,750
line down is the sinatra 133 gem further

00:14:23,550 --> 00:14:27,180
down there's present working directory

00:14:24,750 --> 00:14:31,530
so that kind of helps i can squish it

00:14:27,180 --> 00:14:33,240
onto this tiny slide r as x equals 10

00:14:31,530 --> 00:14:35,520
helps you kind of with it's similar to

00:14:33,240 --> 00:14:36,710
burning you can also do burning but if

00:14:35,520 --> 00:14:39,740
you have like non-deterministic

00:14:36,710 --> 00:14:42,530
allocations if there's any random ality

00:14:39,740 --> 00:14:45,330
then you can or caching then you can

00:14:42,530 --> 00:14:47,370
pass in x equals 10 and the middle of

00:14:45,330 --> 00:14:49,500
where will fire off your request into

00:14:47,370 --> 00:14:51,330
the end of your app 10 times tracing the

00:14:49,500 --> 00:14:54,260
entire time so you get the summary

00:14:51,330 --> 00:14:57,600
output you can also have put to json r

00:14:54,260 --> 00:14:59,850
as output equals interactive is a super

00:14:57,600 --> 00:15:06,240
fun thing let's look at an example of

00:14:59,850 --> 00:15:10,320
that okay so here's my app again so if i

00:15:06,240 --> 00:15:11,850
pass a res strace equals true and raz

00:15:10,320 --> 00:15:14,370
output equals interactive we get this

00:15:11,850 --> 00:15:16,320
JavaScript app so this is super nice

00:15:14,370 --> 00:15:18,170
instead of like playing with the with

00:15:16,320 --> 00:15:20,460
the request headers there we can just

00:15:18,170 --> 00:15:21,780
it'll we can get all our requests back

00:15:20,460 --> 00:15:23,550
and group them as we wish so right now

00:15:21,780 --> 00:15:25,710
they're grouped by file line and class

00:15:23,550 --> 00:15:27,840
plus you can see the top offender there

00:15:25,710 --> 00:15:30,330
I can instead group by file and class

00:15:27,840 --> 00:15:32,190
plus you can filter out things like oh

00:15:30,330 --> 00:15:33,990
I'm only curious about the gems i'm

00:15:32,190 --> 00:15:36,930
using so don't you know filter out the

00:15:33,990 --> 00:15:39,720
project you can also see that there's a

00:15:36,930 --> 00:15:41,910
long tail here of allocations i do not

00:15:39,720 --> 00:15:47,430
care about these individual allocation

00:15:41,910 --> 00:15:49,320
sites so you can say only am only show

00:15:47,430 --> 00:15:51,090
me groups with at least this many

00:15:49,320 --> 00:15:53,550
allocations so if we pump this up to

00:15:51,090 --> 00:15:55,560
like 10 now here's a nice super short

00:15:53,550 --> 00:15:57,510
list I I think that I have a simple

00:15:55,560 --> 00:15:59,160
Sinatra app and yet here's a bunch of

00:15:57,510 --> 00:16:01,890
allocation sites that are allocating

00:15:59,160 --> 00:16:03,600
more than 10 objects per line number

00:16:01,890 --> 00:16:04,980
like Phi landline number combination and

00:16:03,600 --> 00:16:06,120
that's super interesting and now maybe

00:16:04,980 --> 00:16:08,399
you have a short list of things to

00:16:06,120 --> 00:16:14,160
investigate so this is really fun a

00:16:08,399 --> 00:16:15,510
piece of RAC allocation stats so what do

00:16:14,160 --> 00:16:19,680
I do with all this I've showed you like

00:16:15,510 --> 00:16:21,450
how to trace your allocations but what's

00:16:19,680 --> 00:16:23,640
what's useful about this okay the goal

00:16:21,450 --> 00:16:26,160
is to allocate less right so you see how

00:16:23,640 --> 00:16:27,779
do i allocate less well that depends

00:16:26,160 --> 00:16:29,760
there's a bunch of different ways it's

00:16:27,779 --> 00:16:32,040
not always simple we can go through some

00:16:29,760 --> 00:16:35,959
some examples so here is an example from

00:16:32,040 --> 00:16:38,970
the temple gem they are they used to be

00:16:35,959 --> 00:16:41,850
adding one or a two another with plus

00:16:38,970 --> 00:16:43,019
equals soaky's plus equals H keys and

00:16:41,850 --> 00:16:45,089
you can see that this is a short-lived

00:16:43,019 --> 00:16:47,070
array so keys is an array that's

00:16:45,089 --> 00:16:49,490
generated by the inject method and

00:16:47,070 --> 00:16:52,290
you're not going to damage anything by

00:16:49,490 --> 00:16:54,269
destructing the by using a destructive

00:16:52,290 --> 00:16:56,430
method and concatenate incorrectly to

00:16:54,269 --> 00:16:59,940
that array so I replace that code with

00:16:56,430 --> 00:17:01,860
keys concat H keys and it's allocating

00:16:59,940 --> 00:17:04,410
one less array every loop through inject

00:17:01,860 --> 00:17:05,459
there and the Ruby documentation is

00:17:04,410 --> 00:17:07,890
super good about this actually

00:17:05,459 --> 00:17:09,689
especially in string and array and some

00:17:07,890 --> 00:17:12,510
of those base classes they will tell you

00:17:09,689 --> 00:17:15,540
that plus allocates a new array and then

00:17:12,510 --> 00:17:18,959
a pens and can cat appends the second

00:17:15,540 --> 00:17:21,809
array to this array memoization is

00:17:18,959 --> 00:17:24,240
another great way you kind of have to

00:17:21,809 --> 00:17:25,470
you know use this sparingly don't don't

00:17:24,240 --> 00:17:26,880
memorize too much because you get some

00:17:25,470 --> 00:17:28,500
memory bloke but especially in string

00:17:26,880 --> 00:17:30,240
building we'll see some examples of

00:17:28,500 --> 00:17:33,870
where memorizing can help reduce

00:17:30,240 --> 00:17:36,000
allocations string freeze got a super

00:17:33,870 --> 00:17:37,530
exciting feature in Ruby 2 point 1 so

00:17:36,000 --> 00:17:38,790
this you would need to take advantage of

00:17:37,530 --> 00:17:42,600
this you would need to actually bump to

00:17:38,790 --> 00:17:45,000
Ruby 2 point 1 string literals when

00:17:42,600 --> 00:17:46,980
Freese is called on them will always

00:17:45,000 --> 00:17:48,570
refer to the same object so this this

00:17:46,980 --> 00:17:52,140
modification is actually to the Ruby

00:17:48,570 --> 00:17:54,300
parser where if it parses out you know

00:17:52,140 --> 00:17:57,780
quotes and text and no interpolation and

00:17:54,300 --> 00:18:00,720
and quotes dot freeze it's going to save

00:17:57,780 --> 00:18:02,309
that as one object so this is this is

00:18:00,720 --> 00:18:04,919
very different an old Ruby so let's look

00:18:02,309 --> 00:18:07,320
at an example this top method here no

00:18:04,919 --> 00:18:09,720
freeze where I'm trimming

00:18:07,320 --> 00:18:12,030
or translating sorry translating spaces

00:18:09,720 --> 00:18:14,430
into quotes every time you enter this

00:18:12,030 --> 00:18:16,230
method Ruby looks and says oh oh I have

00:18:14,430 --> 00:18:17,400
a space string so let me let me allocate

00:18:16,230 --> 00:18:19,170
that and I have an underscore string and

00:18:17,400 --> 00:18:20,910
I'll allocate that and not frozen let me

00:18:19,170 --> 00:18:22,200
allocate that and then it kind of lets

00:18:20,910 --> 00:18:24,270
us with your string and returns a value

00:18:22,200 --> 00:18:26,250
and those all die and then the next time

00:18:24,270 --> 00:18:28,500
you call no freeze all those objects are

00:18:26,250 --> 00:18:32,550
allocated again and they die cuz they're

00:18:28,500 --> 00:18:34,530
super young if we freeze in Ruby 2.1

00:18:32,550 --> 00:18:36,390
it's going to that that that's going to

00:18:34,530 --> 00:18:37,890
reference the same object every run

00:18:36,390 --> 00:18:40,230
through so it creates the object at

00:18:37,890 --> 00:18:41,490
parse time I think or maybe maybe it's

00:18:40,230 --> 00:18:42,750
the first time the method is called then

00:18:41,490 --> 00:18:44,430
it will refer the same object it will

00:18:42,750 --> 00:18:46,140
not allocate that object every run

00:18:44,430 --> 00:18:49,200
through so we here we have some

00:18:46,140 --> 00:18:52,080
benchmarks using the no freeze method

00:18:49,200 --> 00:18:54,960
this I think I did aight i called this

00:18:52,080 --> 00:18:57,300
eight million times took nine seconds

00:18:54,960 --> 00:18:59,790
using you know without freezing those

00:18:57,300 --> 00:19:02,370
strings and it took seven seven seconds

00:18:59,790 --> 00:19:03,780
freezing those strings and you can see

00:19:02,370 --> 00:19:05,700
there were far fewer allocations and

00:19:03,780 --> 00:19:08,850
then that second last column is the time

00:19:05,700 --> 00:19:11,790
spent in GC was almost cut in half when

00:19:08,850 --> 00:19:13,710
when I I don't throw all these horrible

00:19:11,790 --> 00:19:16,050
short-lived tiny one character strings

00:19:13,710 --> 00:19:17,790
of the garbage collector if you're

00:19:16,050 --> 00:19:20,040
curious like will this slowed down

00:19:17,790 --> 00:19:24,200
calling the freeze method on a 20 app or

00:19:20,040 --> 00:19:26,580
a 19 app it slows it down slightly so

00:19:24,200 --> 00:19:28,380
but but not dramatically and actually

00:19:26,580 --> 00:19:29,910
garbage collection stays the same so an

00:19:28,380 --> 00:19:31,710
even better method than this and an even

00:19:29,910 --> 00:19:33,720
prettier method because it's hideous

00:19:31,710 --> 00:19:37,050
putting that freeze everywhere is save

00:19:33,720 --> 00:19:39,900
your you know quotes space quotes as a

00:19:37,050 --> 00:19:42,030
constant outside the method so you have

00:19:39,900 --> 00:19:43,260
your space constant your underscore

00:19:42,030 --> 00:19:45,480
constant which actually is probably

00:19:43,260 --> 00:19:46,860
better syntactically anyways to have

00:19:45,480 --> 00:19:48,660
these visas objects if you're

00:19:46,860 --> 00:19:50,010
translating the mail jam constantly

00:19:48,660 --> 00:19:54,390
translates new lines in two different

00:19:50,010 --> 00:19:58,340
things so that's a way to reduce

00:19:54,390 --> 00:20:01,590
allocations rails 3 2 has some horrific

00:19:58,340 --> 00:20:05,070
allocation sites so here's a super tiny

00:20:01,590 --> 00:20:06,480
rails 32 app I literally created I said

00:20:05,070 --> 00:20:09,420
rails new and then I generated two

00:20:06,480 --> 00:20:11,760
models a project has many tasks a

00:20:09,420 --> 00:20:13,140
project has a name and a description and

00:20:11,760 --> 00:20:15,720
the task has a name in the description

00:20:13,140 --> 00:20:18,630
and then this page loads a total it

00:20:15,720 --> 00:20:21,300
should load a total of 100 stringy or

00:20:18,630 --> 00:20:23,280
texty like stringing fields so that's

00:20:21,300 --> 00:20:24,450
how many how many fields I feel like

00:20:23,280 --> 00:20:26,400
should be retrieved from the database

00:20:24,450 --> 00:20:29,190
and we may be allocated in order to

00:20:26,400 --> 00:20:30,870
generate this so what do we actually get

00:20:29,190 --> 00:20:33,810
we get seven hundred and fifty six

00:20:30,870 --> 00:20:35,340
strings from active record relation 707

00:20:33,810 --> 00:20:38,310
strings from active support callbacks

00:20:35,340 --> 00:20:40,560
300 strings from sequel 83 statement and

00:20:38,310 --> 00:20:42,420
that one that one doesn't seem so bad I

00:20:40,560 --> 00:20:44,370
was expecting a hundred stringy fields

00:20:42,420 --> 00:20:47,400
to be retrieved from the database and it

00:20:44,370 --> 00:20:48,960
generated 332 strings maybe there's some

00:20:47,400 --> 00:20:50,760
factor of three that it kind of needs to

00:20:48,960 --> 00:20:52,410
it needs to generate these strings for

00:20:50,760 --> 00:20:53,430
well you'd have to look to kind of find

00:20:52,410 --> 00:20:55,830
out if there's something horribly

00:20:53,430 --> 00:20:59,160
offensive in there so let's look at

00:20:55,830 --> 00:21:03,120
these these various sites active support

00:20:59,160 --> 00:21:05,280
callbacks this is where you're creating

00:21:03,120 --> 00:21:07,560
callbacks in them like helping methods

00:21:05,280 --> 00:21:09,150
in so active support callbacks is used

00:21:07,560 --> 00:21:11,420
in an active model and the controller

00:21:09,150 --> 00:21:14,700
for for various callbacks filters

00:21:11,420 --> 00:21:18,330
validators and so every time you call a

00:21:14,700 --> 00:21:21,000
callback it jet it builds the callbacks

00:21:18,330 --> 00:21:22,890
name that it needs to run and it's doing

00:21:21,000 --> 00:21:25,830
all this interpolation in line for 14

00:21:22,890 --> 00:21:27,900
generates a method and line 81 there

00:21:25,830 --> 00:21:31,920
generates a method that it's sending to

00:21:27,900 --> 00:21:33,660
so this is your once your rails app if

00:21:31,920 --> 00:21:35,910
if you're using active support and rails

00:21:33,660 --> 00:21:37,050
app is launched there's a static number

00:21:35,910 --> 00:21:39,870
of callbacks that you're going to use

00:21:37,050 --> 00:21:41,520
right so this is kind of terrifying that

00:21:39,870 --> 00:21:46,110
this is generating these strings every

00:21:41,520 --> 00:21:48,720
time and the fix is of course to cash

00:21:46,110 --> 00:21:50,760
them or memorize them so in rails for

00:21:48,720 --> 00:21:52,890
they turn this into a thread-safe cash

00:21:50,760 --> 00:21:55,320
and you don't generate callback names

00:21:52,890 --> 00:21:56,730
every single time a request comes in and

00:21:55,320 --> 00:22:01,140
needs to needs to call any kind of

00:21:56,730 --> 00:22:04,160
callbacks very good okay active record

00:22:01,140 --> 00:22:07,650
relation this one's pretty awful as well

00:22:04,160 --> 00:22:09,270
we see in initialize so every single

00:22:07,650 --> 00:22:12,030
time you call a relation you called out

00:22:09,270 --> 00:22:14,220
where you call dot not you call any of

00:22:12,030 --> 00:22:16,500
these active record relation generating

00:22:14,220 --> 00:22:19,260
methods it's calling initialize which is

00:22:16,500 --> 00:22:20,970
running through these arrays and the

00:22:19,260 --> 00:22:22,920
instance variable set is not the

00:22:20,970 --> 00:22:25,050
offensive part it's the it's string

00:22:22,920 --> 00:22:26,580
interpolation there right so we have V

00:22:25,050 --> 00:22:28,950
is a string and then it needs to build a

00:22:26,580 --> 00:22:31,860
new string turning it into an instance

00:22:28,950 --> 00:22:32,519
variable every single time you create a

00:22:31,860 --> 00:22:34,409
new relation

00:22:32,519 --> 00:22:36,239
it's going through those 20 items in

00:22:34,409 --> 00:22:37,619
those arrays and it's instantiating

00:22:36,239 --> 00:22:39,509
little tiny strings that are immediately

00:22:37,619 --> 00:22:41,940
thrown away as soon as instance variable

00:22:39,509 --> 00:22:45,419
set is called and causing a lot of

00:22:41,940 --> 00:22:47,429
garbage collection so the result here in

00:22:45,419 --> 00:22:49,559
rails for this file has just kind of

00:22:47,429 --> 00:22:51,809
entirely refactored and this problem

00:22:49,559 --> 00:22:55,440
goes away they do nothing like this in

00:22:51,809 --> 00:22:58,889
rails 4 it's not always easy to fix

00:22:55,440 --> 00:23:01,379
these here's a tag from active act from

00:22:58,889 --> 00:23:03,359
action views tag helper so anytime you

00:23:01,379 --> 00:23:06,869
call like form tag input tag button tag

00:23:03,359 --> 00:23:10,049
image tag link to they all kind of boil

00:23:06,869 --> 00:23:11,729
down to calling tag and tag is just all

00:23:10,049 --> 00:23:13,529
it's going to do is he's trying to build

00:23:11,729 --> 00:23:15,119
an HTML tag so he starts with a left

00:23:13,529 --> 00:23:16,649
bracket and then the name of the tag and

00:23:15,119 --> 00:23:18,179
then some other things and then maybe a

00:23:16,649 --> 00:23:20,519
closing bracket but maybe a slash

00:23:18,179 --> 00:23:21,899
closing bracket so every single time

00:23:20,519 --> 00:23:23,669
you're generating your massively

00:23:21,899 --> 00:23:26,039
complicated view in an app and it needs

00:23:23,669 --> 00:23:28,649
to build every single HTML tag in that

00:23:26,039 --> 00:23:30,479
page it's creating a string for the Open

00:23:28,649 --> 00:23:32,009
bracket and all of that jazz and then

00:23:30,479 --> 00:23:34,499
the close bracket it's also generating

00:23:32,009 --> 00:23:35,759
the slash close bracket at every single

00:23:34,499 --> 00:23:38,669
time and then those needs get thrown

00:23:35,759 --> 00:23:39,869
away this could be fixed with fries I

00:23:38,669 --> 00:23:42,269
have not been schmaert that but I

00:23:39,869 --> 00:23:44,519
imagine these should be constant eyes

00:23:42,269 --> 00:23:45,839
the the end close bracket in the wac end

00:23:44,519 --> 00:23:47,369
close bracket there should be constant

00:23:45,839 --> 00:23:52,469
eyes and that'll reduce allocations by a

00:23:47,369 --> 00:23:54,450
lot let's see so this is sequel lights

00:23:52,469 --> 00:23:56,190
statement this is where there were 300

00:23:54,450 --> 00:23:58,200
objects being allocated and we're kind

00:23:56,190 --> 00:24:01,379
of wanted just 100 so if we look through

00:23:58,200 --> 00:24:03,659
this what do we have here we have the

00:24:01,379 --> 00:24:06,089
the offensive line was line 108 Val

00:24:03,659 --> 00:24:08,489
equals step step is not a local variable

00:24:06,089 --> 00:24:10,440
in this method so it must be a method

00:24:08,489 --> 00:24:11,909
but when you look for it you can't find

00:24:10,440 --> 00:24:14,700
the method in this file where is step

00:24:11,909 --> 00:24:17,579
turns out it's in the sea extension and

00:24:14,700 --> 00:24:19,169
sequel light so there it is you know

00:24:17,579 --> 00:24:20,309
entirely possible to find where the

00:24:19,169 --> 00:24:22,109
strings are being allocated in that

00:24:20,309 --> 00:24:24,479
function but they might be calling you

00:24:22,109 --> 00:24:25,859
no further see functions and that was a

00:24:24,479 --> 00:24:27,719
rabbit hole that I decided not to go

00:24:25,859 --> 00:24:29,849
down I thought 300 isn't terribly

00:24:27,719 --> 00:24:31,709
offensive over 100 but that would be

00:24:29,849 --> 00:24:33,769
probably super exciting maybe maybe it

00:24:31,709 --> 00:24:37,679
doesn't need to allocate so many strings

00:24:33,769 --> 00:24:39,599
so be excited these gems are changing I

00:24:37,679 --> 00:24:43,619
think the the more tools should come out

00:24:39,599 --> 00:24:44,820
for this new feature and this is this

00:24:43,619 --> 00:24:46,410
kind of just the beginning because this

00:24:44,820 --> 00:24:49,610
is you know the first time we've had

00:24:46,410 --> 00:24:52,590
great memory profiling tool like this

00:24:49,610 --> 00:24:54,090
beware of your object allocations beware

00:24:52,590 --> 00:24:55,530
of how much garbage collection costs you

00:24:54,090 --> 00:24:57,990
I think an easy one is like when you're

00:24:55,530 --> 00:25:00,480
chaining innumerable methods like dot

00:24:57,990 --> 00:25:01,950
select select select use some bang

00:25:00,480 --> 00:25:07,020
methods in there so you're not creating

00:25:01,950 --> 00:25:09,600
new innumerable Z time add trace object

00:25:07,020 --> 00:25:11,640
allocations to your toolbox and watch

00:25:09,600 --> 00:25:12,720
this space for more exciting things if

00:25:11,640 --> 00:25:13,890
you're interested in this stuff there

00:25:12,720 --> 00:25:15,690
are some great things to google the

00:25:13,890 --> 00:25:17,220
github blog post is super interesting

00:25:15,690 --> 00:25:18,990
you can read the end of that story how

00:25:17,220 --> 00:25:20,940
they fix that problem and what they kind

00:25:18,990 --> 00:25:23,070
of found was the problem it's called Hey

00:25:20,940 --> 00:25:26,580
Judy don't make it bad these are my two

00:25:23,070 --> 00:25:28,170
gems Cochise Asada's efficient 2.1 is a

00:25:26,580 --> 00:25:29,850
talk he's given a few times so you can

00:25:28,170 --> 00:25:32,760
find a video of it when he gave it at

00:25:29,850 --> 00:25:34,590
euro coo and Ruby ke ghee he gave kind

00:25:32,760 --> 00:25:36,900
of a version of it a true become this

00:25:34,590 --> 00:25:39,090
year it's super interesting it's more

00:25:36,900 --> 00:25:42,110
focused on the new garbage collector in

00:25:39,090 --> 00:25:45,300
2.1 but he does touch on on this feature

00:25:42,110 --> 00:25:46,590
I want to say thanks to amman gupta he

00:25:45,300 --> 00:25:48,930
actually originally wrote the feature

00:25:46,590 --> 00:25:51,390
because that blog posts they're kind of

00:25:48,930 --> 00:25:53,640
kind of shows how he wrote this he did

00:25:51,390 --> 00:25:54,930
the thing we you fork ruby and you add

00:25:53,640 --> 00:25:56,670
your own patch to try and find where

00:25:54,930 --> 00:25:58,320
you're doing your allocations and then

00:25:56,670 --> 00:26:00,570
he got it merged in with co ichi into

00:25:58,320 --> 00:26:03,150
the ruby core get up for everything they

00:26:00,570 --> 00:26:05,520
do my coworker matt brooks mountain west

00:26:03,150 --> 00:26:08,220
really calm thanks Mike and Hakeem this

00:26:05,520 --> 00:26:10,830
presentation is made with reveal that's

00:26:08,220 --> 00:26:12,450
everything um if you do want to talk

00:26:10,830 --> 00:26:13,890
about this later because you all want to

00:26:12,450 --> 00:26:18,290
get to lunch I think I'm gonna be eating

00:26:13,890 --> 00:26:18,290

YouTube URL: https://www.youtube.com/watch?v=ViUvz4FCDxg


