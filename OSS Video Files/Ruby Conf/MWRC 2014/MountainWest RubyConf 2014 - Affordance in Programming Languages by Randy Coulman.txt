Title: MountainWest RubyConf 2014 - Affordance in Programming Languages by Randy Coulman
Publication date: 2020-01-24
Playlist: MWRC 2014
Description: 
	A good design communicates the intended use of an object. In the physical world, this communication is accomplished by "affordances", as discussed by Donald Norman in "The Psychology of Everyday Things".
Programming languages also have affordances, and they influence the kinds of solutions we develop. The more languages we know, the more we "expand our design space" so that we can come up with better solutions to the problems we face every day.

Help us caption & translate this video!

http://amara.org/v/FG2F/
Captions: 
	00:00:25,010 --> 00:00:32,250
morning welcome to Mountain West small

00:00:29,970 --> 00:00:35,160
talk I mean read the conference there

00:00:32,250 --> 00:00:36,540
will be small talk my name is Randy

00:00:35,160 --> 00:00:37,650
Coleman my life says it's pronounced

00:00:36,540 --> 00:00:39,840
like soul man if you ever have trouble

00:00:37,650 --> 00:00:41,070
remembering I get it all kinds of

00:00:39,840 --> 00:00:42,720
different ways and apparently this is my

00:00:41,070 --> 00:00:44,460
way of getting my name on one slide as

00:00:42,720 --> 00:00:46,230
many times as I possibly can because I'm

00:00:44,460 --> 00:00:47,910
really creative with picking my my user

00:00:46,230 --> 00:00:49,559
names so today I want to talk about

00:00:47,910 --> 00:00:53,579
affordances and how they relate to

00:00:49,559 --> 00:00:54,840
programming languages this is faucet

00:00:53,579 --> 00:00:56,760
that you might see in like a hotel sink

00:00:54,840 --> 00:00:58,739
or bathtub can anybody actually figure

00:00:56,760 --> 00:01:00,000
out how it would work I mean it's a

00:00:58,739 --> 00:01:01,260
faucet right you should be able to turn

00:01:00,000 --> 00:01:04,500
it on you should be able to get hot and

00:01:01,260 --> 00:01:06,180
cold water out of it doesn't really kind

00:01:04,500 --> 00:01:07,410
of kind of hard to figure out

00:01:06,180 --> 00:01:12,390
fortunately this one comes with

00:01:07,410 --> 00:01:13,710
instructions sorta China maybe not so in

00:01:12,390 --> 00:01:15,600
the physical design world there's this

00:01:13,710 --> 00:01:17,070
concept of affordances I first heard

00:01:15,600 --> 00:01:18,750
about it in a book by novel Norman

00:01:17,070 --> 00:01:20,490
called the psychology of everyday things

00:01:18,750 --> 00:01:22,770
he's rereleased it is the design of

00:01:20,490 --> 00:01:24,240
everyday things if you do any if you

00:01:22,770 --> 00:01:25,770
build anything that people are going to

00:01:24,240 --> 00:01:27,390
use I recommend the book it's got a lot

00:01:25,770 --> 00:01:29,549
of really good advice in it but an

00:01:27,390 --> 00:01:30,990
affordance is a quality of an object or

00:01:29,549 --> 00:01:33,299
environment that allows someone to

00:01:30,990 --> 00:01:35,040
perform an action it affords that action

00:01:33,299 --> 00:01:36,930
and that's also come to me in a little

00:01:35,040 --> 00:01:38,909
bit whether that object actually

00:01:36,930 --> 00:01:40,979
communicates the action you can perform

00:01:38,909 --> 00:01:42,570
with it so you see a button and you know

00:01:40,979 --> 00:01:44,909
you can push it you see a you know a

00:01:42,570 --> 00:01:46,200
knob and you know you can turn it switch

00:01:44,909 --> 00:01:49,710
you can flip it those kinds of things

00:01:46,200 --> 00:01:51,630
those are affordances affordances also

00:01:49,710 --> 00:01:53,490
apply or actually sir I want to look at

00:01:51,630 --> 00:01:55,500
a couple more examples first so this is

00:01:53,490 --> 00:01:57,480
like a walk white and you see this these

00:01:55,500 --> 00:01:59,550
bright red lights

00:01:57,480 --> 00:02:01,110
push but really you have to push that

00:01:59,550 --> 00:02:02,610
button down below and they had to put

00:02:01,110 --> 00:02:04,680
arrows on the thing to point out where

00:02:02,610 --> 00:02:05,910
you actually need to push I'm guessing a

00:02:04,680 --> 00:02:08,190
lot of people get confused by that

00:02:05,910 --> 00:02:10,020
here's another example it's back door of

00:02:08,190 --> 00:02:11,430
a bus now there's these bars on the

00:02:10,020 --> 00:02:13,800
right and the left that you may think

00:02:11,430 --> 00:02:15,480
maybe you can push on those bars but no

00:02:13,800 --> 00:02:17,100
you have to touch the yellow strip and

00:02:15,480 --> 00:02:18,450
because that wasn't clear enough they

00:02:17,100 --> 00:02:20,010
had to actually add the white arrows as

00:02:18,450 --> 00:02:22,710
well to communicate how do you operate

00:02:20,010 --> 00:02:24,600
this door how do I get off the bus so

00:02:22,710 --> 00:02:26,010
these are not very good affordances but

00:02:24,600 --> 00:02:27,600
you can also have really really good

00:02:26,010 --> 00:02:29,880
affordances for example if you walked up

00:02:27,600 --> 00:02:31,530
to an escalator that looked like that it

00:02:29,880 --> 00:02:33,180
immediately communicates what you should

00:02:31,530 --> 00:02:34,830
do you want to stand just you go on the

00:02:33,180 --> 00:02:36,740
right if you want to walk down you go on

00:02:34,830 --> 00:02:39,780
the left so there's good and bad

00:02:36,740 --> 00:02:41,550
affordances and affordances you can also

00:02:39,780 --> 00:02:45,960
apply to software I mean the obvious

00:02:41,550 --> 00:02:47,760
place is UI design you want your us to

00:02:45,960 --> 00:02:49,980
communicate how they're supposed to be

00:02:47,760 --> 00:02:52,410
used and and what you're supposed to do

00:02:49,980 --> 00:02:54,300
with them but even API design can have

00:02:52,410 --> 00:02:55,950
affordances there's a guy by the name of

00:02:54,300 --> 00:02:58,290
a mirror Jean who's been doing a series

00:02:55,950 --> 00:03:00,090
of javascript screencasts called coding

00:02:58,290 --> 00:03:02,300
out loud and he's been doing a series on

00:03:00,090 --> 00:03:07,110
rest api's he's building a little

00:03:02,300 --> 00:03:08,490
tic-tac-toe game API and in his adjacent

00:03:07,110 --> 00:03:10,290
packets to come back there's actually

00:03:08,490 --> 00:03:12,330
documentation about how to use the API

00:03:10,290 --> 00:03:15,060
and it also gives you a list of here's

00:03:12,330 --> 00:03:16,950
all the URLs you can hit that are legal

00:03:15,060 --> 00:03:20,910
given the current state of the game and

00:03:16,950 --> 00:03:22,320
so that affords you know you as the

00:03:20,910 --> 00:03:24,450
program reason that API it's an

00:03:22,320 --> 00:03:27,480
affordance that you can use to operate

00:03:24,450 --> 00:03:29,310
the game and in this talk I'd like to

00:03:27,480 --> 00:03:31,170
suggest that affordances also apply to

00:03:29,310 --> 00:03:32,850
programming languages different

00:03:31,170 --> 00:03:34,890
languages of four different kinds of

00:03:32,850 --> 00:03:37,230
design and they influence different

00:03:34,890 --> 00:03:39,090
kinds of solutions to problems so let's

00:03:37,230 --> 00:03:41,100
look at a simple example the humble

00:03:39,090 --> 00:03:42,720
point class this example I'm going to

00:03:41,100 --> 00:03:44,250
I'm going to use some ideas from small

00:03:42,720 --> 00:03:45,930
talk to try to come up with a better

00:03:44,250 --> 00:03:47,370
Ruby solution to a problem all my

00:03:45,930 --> 00:03:49,260
examples are going to apply to Ruby

00:03:47,370 --> 00:03:50,670
since this is a ruby conference and I'll

00:03:49,260 --> 00:03:52,050
be drawing from the languages i'm most

00:03:50,670 --> 00:03:54,720
familiar with i program and small talk

00:03:52,050 --> 00:03:57,420
and c++ everyday and more and more ruby

00:03:54,720 --> 00:04:00,540
as i go as well so you're going to see a

00:03:57,420 --> 00:04:02,040
fair bit of small talk and some c++ as

00:04:00,540 --> 00:04:04,590
well and hopefully that won't scar you

00:04:02,040 --> 00:04:06,739
too badly so here's a simple point class

00:04:04,590 --> 00:04:08,640
in Ruby you can use a struct for this

00:04:06,739 --> 00:04:10,440
many people have probably written

00:04:08,640 --> 00:04:11,300
something like this just very simply

00:04:10,440 --> 00:04:13,340
create an

00:04:11,300 --> 00:04:14,360
point with an x and y coordinate but

00:04:13,340 --> 00:04:20,360
what happens if you want to support

00:04:14,360 --> 00:04:22,670
polar coordinates now if you don't know

00:04:20,360 --> 00:04:24,410
what polar coordinates are we're used to

00:04:22,670 --> 00:04:26,960
specifying points in a Cartesian plane

00:04:24,410 --> 00:04:28,640
with an x and y coordinate but polar

00:04:26,960 --> 00:04:30,560
coordinates you can specify the exact

00:04:28,640 --> 00:04:32,540
same point with the radius or a distance

00:04:30,560 --> 00:04:34,700
from the origin and an angle from the

00:04:32,540 --> 00:04:37,190
positive x-axis and it turns out that

00:04:34,700 --> 00:04:39,440
like in orbital mechanics and radial

00:04:37,190 --> 00:04:42,470
motion equations the equations are a lot

00:04:39,440 --> 00:04:44,720
simpler if you use polar coordinates you

00:04:42,470 --> 00:04:46,550
know that the radius and angle basically

00:04:44,720 --> 00:04:47,930
describe a vector if you're from without

00:04:46,550 --> 00:04:50,390
from physics and if you watch despicable

00:04:47,930 --> 00:04:55,340
me nor that a vector has both direction

00:04:50,390 --> 00:04:57,590
and magnitude so you can you can specify

00:04:55,340 --> 00:04:59,690
points in two ways now we look at our

00:04:57,590 --> 00:05:01,460
simple point class we're looking at we

00:04:59,690 --> 00:05:04,400
only have one constructor and it already

00:05:01,460 --> 00:05:06,140
takes two numbers so how would we say no

00:05:04,400 --> 00:05:08,510
this point needs the radius and an angle

00:05:06,140 --> 00:05:10,580
instead of an X and a why I suppose we

00:05:08,510 --> 00:05:12,800
could add like a little tag parameter

00:05:10,580 --> 00:05:14,450
something that specifies that I used to

00:05:12,800 --> 00:05:16,490
work with the lady named Anna and every

00:05:14,450 --> 00:05:17,780
time I'd see code like that my nose have

00:05:16,490 --> 00:05:19,940
crinkle up and she go you're making the

00:05:17,780 --> 00:05:23,240
poo face again so I think of solutions

00:05:19,940 --> 00:05:25,610
like that I make the poo face so let's

00:05:23,240 --> 00:05:27,680
look at small talk so this is the exact

00:05:25,610 --> 00:05:29,900
same code in small talk looks a little

00:05:27,680 --> 00:05:31,010
were do I mean small talk you work in a

00:05:29,900 --> 00:05:32,510
coding environment you don't actually

00:05:31,010 --> 00:05:33,740
have all this text on the screen when

00:05:32,510 --> 00:05:35,150
you're looking at it but this is kind of

00:05:33,740 --> 00:05:39,169
how you communicate your code and a flat

00:05:35,150 --> 00:05:40,940
medium like this in small talk every

00:05:39,169 --> 00:05:44,330
method it uses keyword arguments so

00:05:40,940 --> 00:05:47,180
those colin's are the keywords and every

00:05:44,330 --> 00:05:49,280
method has a unique name some sort and

00:05:47,180 --> 00:05:51,650
so we define a class method on point

00:05:49,280 --> 00:05:53,450
called X Cole and why Cola it takes to

00:05:51,650 --> 00:05:54,800
two parameters and it delegates to an

00:05:53,450 --> 00:05:56,690
instant side method to initialize the

00:05:54,800 --> 00:05:58,070
instance variables Ruby's doing that for

00:05:56,690 --> 00:06:00,110
that for you under the hood by the way

00:05:58,070 --> 00:06:01,910
it's the same thing and you construct it

00:06:00,110 --> 00:06:03,770
by sending the X colon y colon message

00:06:01,910 --> 00:06:06,020
to point and that's how we construct a

00:06:03,770 --> 00:06:07,669
point so to support polar coordinates

00:06:06,020 --> 00:06:09,969
and small talk the solution is obvious

00:06:07,669 --> 00:06:12,399
just add another name

00:06:09,969 --> 00:06:14,949
it's called our colon theta colon it

00:06:12,399 --> 00:06:16,749
takes a radius and angle and this one

00:06:14,949 --> 00:06:19,029
just delegates to the XY constructor

00:06:16,749 --> 00:06:20,199
using the trigonometry form you you

00:06:19,029 --> 00:06:21,879
learned in high school and then had to

00:06:20,199 --> 00:06:23,829
go look look up on google because you

00:06:21,879 --> 00:06:25,539
forgot your high school trigonometry but

00:06:23,829 --> 00:06:28,179
you just send the article and theta Cola

00:06:25,539 --> 00:06:32,169
message to point and you get a point in

00:06:28,179 --> 00:06:34,809
polar coordinates so small talk has this

00:06:32,169 --> 00:06:38,110
affordance of names constructors can we

00:06:34,809 --> 00:06:39,969
apply that to Ruby yes we can we can

00:06:38,110 --> 00:06:41,589
make class methods in Ruby so in this

00:06:39,969 --> 00:06:43,509
case I've made an XY method that takes

00:06:41,589 --> 00:06:45,639
an x and y and it just delegates to the

00:06:43,509 --> 00:06:48,069
normal constructor the new new method

00:06:45,639 --> 00:06:49,539
and then i can make another constructor

00:06:48,069 --> 00:06:50,860
called self that polar that takes the

00:06:49,539 --> 00:06:53,110
radius in theta use the same

00:06:50,860 --> 00:06:54,459
trigonometry formulas bonus points for

00:06:53,110 --> 00:06:55,929
pretending to make the new method

00:06:54,459 --> 00:06:57,219
private and nothing's ever really

00:06:55,929 --> 00:06:58,419
private movie I know that but at least

00:06:57,219 --> 00:07:00,789
it communicates something about my

00:06:58,419 --> 00:07:02,409
intended use of the class and you can

00:07:00,789 --> 00:07:04,029
construct both kinds of points like at

00:07:02,409 --> 00:07:06,579
the bottom there point XY our point

00:07:04,029 --> 00:07:08,919
polar and so we've been able to take an

00:07:06,579 --> 00:07:10,389
idea from small talk couple named

00:07:08,919 --> 00:07:12,729
constructors or an affordance from small

00:07:10,389 --> 00:07:14,379
talk and apply that to Ruby to come up

00:07:12,729 --> 00:07:16,749
with a solution to the problem of how

00:07:14,379 --> 00:07:18,339
can we make points both ways let's look

00:07:16,749 --> 00:07:20,559
at another really simple example the

00:07:18,339 --> 00:07:23,529
find method in Ruby or detect it's also

00:07:20,559 --> 00:07:24,999
known small file calls that detect if I

00:07:23,529 --> 00:07:28,089
wanted to look through an array of

00:07:24,999 --> 00:07:29,829
numbers for an odd number I could write

00:07:28,089 --> 00:07:30,729
something like this in small talk no I'm

00:07:29,829 --> 00:07:32,979
not going to give you a whole lot of

00:07:30,729 --> 00:07:34,449
small talk syntax training here Noel's

00:07:32,979 --> 00:07:36,759
going to do that this afternoon so

00:07:34,449 --> 00:07:38,829
coming come and watch an old stock but

00:07:36,759 --> 00:07:40,329
the hash with the friends that's a

00:07:38,829 --> 00:07:43,089
literal array in small talk and the

00:07:40,329 --> 00:07:44,379
square braces are a block I know using

00:07:43,089 --> 00:07:45,699
each as a variable name is a little bit

00:07:44,379 --> 00:07:47,619
confusing to Ruby programmers because

00:07:45,699 --> 00:07:49,779
there's method in Ruby but small talk to

00:07:47,619 --> 00:07:53,139
EDM is that your your loop variable or

00:07:49,779 --> 00:07:55,389
your variable in a in a block is called

00:07:53,139 --> 00:07:57,419
each often and so this is looking

00:07:55,389 --> 00:07:59,679
through that array for an odd number

00:07:57,419 --> 00:08:02,019
anything that responds true to the odd

00:07:59,679 --> 00:08:03,610
message and in Smalltalk it doesn't

00:08:02,019 --> 00:08:04,989
return nil if you can't find one that

00:08:03,610 --> 00:08:07,239
actually raises an exception so that's

00:08:04,989 --> 00:08:09,159
what happens in this case exact same

00:08:07,239 --> 00:08:10,839
code and Ruby i'm using find instead of

00:08:09,159 --> 00:08:12,489
detect because it seems like most people

00:08:10,839 --> 00:08:14,769
prefer fine so trying to be a little bit

00:08:12,489 --> 00:08:16,360
idiomatic here Andrew Bertrand Dolph is

00:08:14,769 --> 00:08:18,309
not found what if you wanted to return

00:08:16,360 --> 00:08:20,439
something else you didn't want an

00:08:18,309 --> 00:08:22,599
exception you didn't want to know well

00:08:20,439 --> 00:08:23,680
in small talk you can pass multiple

00:08:22,599 --> 00:08:26,169
blocks to a method

00:08:23,680 --> 00:08:28,090
so i can use detective none instead a

00:08:26,169 --> 00:08:29,740
small talk has keyword arguments again

00:08:28,090 --> 00:08:32,320
so if i want to add a parameter i have

00:08:29,740 --> 00:08:34,210
to add another keyword and so i can pass

00:08:32,320 --> 00:08:35,890
two blocks the first block is looking

00:08:34,210 --> 00:08:38,260
the criteria that I'm looking for and

00:08:35,890 --> 00:08:41,950
the second block is what what should I

00:08:38,260 --> 00:08:43,690
return if I can't find one and hash none

00:08:41,950 --> 00:08:46,000
is a symbol and small just like

00:08:43,690 --> 00:08:47,589
colon none would be in Ruby so small

00:08:46,000 --> 00:08:50,770
talk has this affordance of passing

00:08:47,589 --> 00:08:51,970
multiple blocks to methods and actually

00:08:50,770 --> 00:08:52,899
that's how conditionals are going to

00:08:51,970 --> 00:08:55,240
small talk but that's a whole other

00:08:52,899 --> 00:08:57,130
topic so we have this affordance of

00:08:55,240 --> 00:08:58,930
multiple blocks can we do this in Ruby

00:08:57,130 --> 00:09:00,580
well it turns out this is built into

00:08:58,930 --> 00:09:02,370
Ruby how many of you knew that Ruby

00:09:00,580 --> 00:09:09,370
could take a poor and if none parameter

00:09:02,370 --> 00:09:11,410
anybody Aaron knows awesome nobody knows

00:09:09,370 --> 00:09:13,209
this so I'm using a stab you lambda

00:09:11,410 --> 00:09:15,700
there but you pass in anything callable

00:09:13,209 --> 00:09:18,580
in as a parameter to find and that

00:09:15,700 --> 00:09:20,350
callable will get called if it can't if

00:09:18,580 --> 00:09:22,660
the if the condition can't be satisfied

00:09:20,350 --> 00:09:26,410
and so I can run this and it'll return

00:09:22,660 --> 00:09:29,250
the nun symbol so in Ruby you can do

00:09:26,410 --> 00:09:31,600
multiple blocks like in small talk it

00:09:29,250 --> 00:09:33,100
doesn't read as well I kind of like

00:09:31,600 --> 00:09:36,010
having the condition i'm looking for

00:09:33,100 --> 00:09:38,560
come first and then the bad case come

00:09:36,010 --> 00:09:40,060
last nobody nobody knows about this and

00:09:38,560 --> 00:09:41,770
nobody uses it because it really doesn't

00:09:40,060 --> 00:09:43,180
read quite as well but you can do it you

00:09:41,770 --> 00:09:45,010
can actually pass multiple blocks

00:09:43,180 --> 00:09:46,600
through methods I think Augie Grimm's

00:09:45,010 --> 00:09:48,040
done that a couple times on this Ruby

00:09:46,600 --> 00:09:51,279
top of screencasts which are awesome by

00:09:48,040 --> 00:09:53,890
the way so this brings me to an idea

00:09:51,279 --> 00:09:55,270
called linguistic relativity you might

00:09:53,890 --> 00:09:56,890
also have heard of it as the sapir-whorf

00:09:55,270 --> 00:09:58,900
hypothesis and I have no idea if I

00:09:56,890 --> 00:10:02,170
pronounced that correctly but the idea

00:09:58,900 --> 00:10:04,209
is that languages influence thought and

00:10:02,170 --> 00:10:06,640
the language you think naturally and

00:10:04,209 --> 00:10:08,170
will influence the kinds of thoughts you

00:10:06,640 --> 00:10:10,270
think and the kinds of ideas you have

00:10:08,170 --> 00:10:11,800
now there's people that disagree that

00:10:10,270 --> 00:10:13,089
this is actual real theory there's been

00:10:11,800 --> 00:10:14,860
some experiments to try to prove or

00:10:13,089 --> 00:10:16,720
disprove it there's a strong form in a

00:10:14,860 --> 00:10:19,630
weak form you can go read the article

00:10:16,720 --> 00:10:21,520
like I did if you want to but this idea

00:10:19,630 --> 00:10:23,890
that languages influence thought is kind

00:10:21,520 --> 00:10:25,690
of intriguing to me Cory Phyllida to

00:10:23,890 --> 00:10:27,790
talk about a year and a half ago at

00:10:25,690 --> 00:10:30,610
suffer craftsmanship North America great

00:10:27,790 --> 00:10:32,020
talk by the way but in his talk part of

00:10:30,610 --> 00:10:34,480
his talk was he talked about what does

00:10:32,020 --> 00:10:35,980
the language allow you to say and what

00:10:34,480 --> 00:10:37,500
does the language force you to say and

00:10:35,980 --> 00:10:39,390
he gave a great example

00:10:37,500 --> 00:10:41,610
if I was to come to you and say I went

00:10:39,390 --> 00:10:42,900
to a movie with my neighbor you might

00:10:41,610 --> 00:10:44,070
count you might ask me especially if

00:10:42,900 --> 00:10:45,330
you're my wife you might ask me while

00:10:44,070 --> 00:10:46,890
it's your neighbor male or female and

00:10:45,330 --> 00:10:49,080
unless you're my wife I might answer

00:10:46,890 --> 00:10:50,640
well that's none of your business but if

00:10:49,080 --> 00:10:52,290
I was speaking in a language like French

00:10:50,640 --> 00:10:54,120
where that where the nouns are gendered

00:10:52,290 --> 00:10:56,640
there's masculine and feminine forms of

00:10:54,120 --> 00:10:59,310
nouns when I told you I went to a movie

00:10:56,640 --> 00:11:00,570
with my neighbor I would be forced to

00:10:59,310 --> 00:11:02,310
tell you whether my neighbor was male or

00:11:00,570 --> 00:11:03,750
female because of that language that

00:11:02,310 --> 00:11:05,790
language is forcing me to say something

00:11:03,750 --> 00:11:07,980
that English doesn't force me to say and

00:11:05,790 --> 00:11:09,750
the same thing is true of programming

00:11:07,980 --> 00:11:12,150
languages our languages influence the

00:11:09,750 --> 00:11:13,590
kind of thoughts we have and maths

00:11:12,150 --> 00:11:15,870
actually use this as one of his

00:11:13,590 --> 00:11:17,700
principles when he invented Ruby he

00:11:15,870 --> 00:11:19,740
actually gave a talk in 2003 at OSCON

00:11:17,700 --> 00:11:21,600
about about the design of Ruby and he

00:11:19,740 --> 00:11:23,220
talked about this a lot and one of the

00:11:21,600 --> 00:11:24,690
points he made is that languages are not

00:11:23,220 --> 00:11:27,480
only tools for communication but also

00:11:24,690 --> 00:11:29,550
tools for thinking and he invented Ruby

00:11:27,480 --> 00:11:31,860
to be a good thinking tool that's one of

00:11:29,550 --> 00:11:33,540
his goals of a ruby was to make it a

00:11:31,860 --> 00:11:37,020
good thinking tool and I think it's

00:11:33,540 --> 00:11:38,340
great actually it's pretty good so let's

00:11:37,020 --> 00:11:40,650
look at a couple more examples these

00:11:38,340 --> 00:11:42,150
ones are slightly more involved now I'm

00:11:40,650 --> 00:11:43,290
going to get some C++ on you and I

00:11:42,150 --> 00:11:46,589
apologize but I'm going to do it anyway

00:11:43,290 --> 00:11:47,670
a lot of times when we're when we're

00:11:46,589 --> 00:11:49,320
programming we have to clean up after

00:11:47,670 --> 00:11:54,480
ourselves we work with finite resources

00:11:49,320 --> 00:11:58,710
all the time memory threads files file

00:11:54,480 --> 00:12:01,080
handles database connections locks

00:11:58,710 --> 00:12:02,490
things where you have to do something to

00:12:01,080 --> 00:12:03,540
acquire something and then release it

00:12:02,490 --> 00:12:05,220
when you're done you have to clean up

00:12:03,540 --> 00:12:06,910
after yourself now when we work in

00:12:05,220 --> 00:12:07,960
garbage club

00:12:06,910 --> 00:12:09,400
we don't have to worry about this

00:12:07,960 --> 00:12:11,440
anymore that was see we don't have to do

00:12:09,400 --> 00:12:12,610
that well memories only one kind of

00:12:11,440 --> 00:12:15,130
resource and there's lots of different

00:12:12,610 --> 00:12:16,420
kinds of resources so we have to we have

00:12:15,130 --> 00:12:18,850
to pay attention to cleaning up after

00:12:16,420 --> 00:12:21,900
ourselves so how many of you seen see

00:12:18,850 --> 00:12:21,900
code that looks something like this

00:12:22,050 --> 00:12:31,360
anybody recognize that there's to go to

00:12:29,380 --> 00:12:33,590
fails right in the middle this is

00:12:31,360 --> 00:12:34,940
actually apples SS

00:12:33,590 --> 00:12:38,030
there for weeks ago if you don't

00:12:34,940 --> 00:12:39,530
recognize it I'm not going to try to fix

00:12:38,030 --> 00:12:40,790
apples problem but the whole idea of

00:12:39,530 --> 00:12:42,470
this code is that you have to make sure

00:12:40,790 --> 00:12:44,840
that you free these buffers down at the

00:12:42,470 --> 00:12:46,100
bottom no matter how you finish the

00:12:44,840 --> 00:12:47,960
function so I'm going to look at a

00:12:46,100 --> 00:12:50,590
simpler example I've written a very

00:12:47,960 --> 00:12:53,570
expressively name function called foo

00:12:50,590 --> 00:12:54,830
and it has to acquire our resource and

00:12:53,570 --> 00:12:58,070
make sure it releases it when it's done

00:12:54,830 --> 00:13:00,460
and in the in between there it does some

00:12:58,070 --> 00:13:03,430
work with it now this code is buggy and

00:13:00,460 --> 00:13:04,710
you shouldn't write code

00:13:03,430 --> 00:13:08,200
and if you do you should feel bad

00:13:04,710 --> 00:13:10,240
because I did when I wrote it the

00:13:08,200 --> 00:13:11,470
obvious problem is that if faz doesn't

00:13:10,240 --> 00:13:13,600
give us the answer to life the universe

00:13:11,470 --> 00:13:15,010
and everything it's going to early

00:13:13,600 --> 00:13:17,589
return and we're not going to free our

00:13:15,010 --> 00:13:18,940
resource that's a pretty obvious problem

00:13:17,589 --> 00:13:21,010
when you look at this code but the less

00:13:18,940 --> 00:13:24,670
obvious problem is what if bar or baths

00:13:21,010 --> 00:13:27,250
raises an exception same problem we're

00:13:24,670 --> 00:13:28,810
dead we acquire the resource we catch

00:13:27,250 --> 00:13:31,660
the exception go on about our business

00:13:28,810 --> 00:13:33,580
leak to resource you do that too many

00:13:31,660 --> 00:13:36,459
times and your program crashes after a

00:13:33,580 --> 00:13:38,680
while maybe sooner maybe later but it

00:13:36,459 --> 00:13:39,910
crashes so we have to do something about

00:13:38,680 --> 00:13:44,470
that and we have to write our code

00:13:39,910 --> 00:13:46,540
differently because of that this solves

00:13:44,470 --> 00:13:50,170
the problem we actually release the

00:13:46,540 --> 00:13:51,640
resource but I start making the poo face

00:13:50,170 --> 00:13:54,130
again when I look at code like that it's

00:13:51,640 --> 00:13:55,420
ugly I have to duplicate the release of

00:13:54,130 --> 00:13:57,190
the resource I have to catch an

00:13:55,420 --> 00:13:59,620
exception I don't care about at all I

00:13:57,190 --> 00:14:02,560
have to rewrite the early return and end

00:13:59,620 --> 00:14:04,959
up with wedgie code and lots of nesting

00:14:02,560 --> 00:14:07,360
I don't like it so is there a better way

00:14:04,959 --> 00:14:11,110
well it turns out in C++ there is a

00:14:07,360 --> 00:14:13,330
better way c++ has an affordance called

00:14:11,110 --> 00:14:15,190
deterministic destruction semantics and

00:14:13,330 --> 00:14:16,750
the idea is when you allocate an object

00:14:15,190 --> 00:14:20,200
on the stack like a local variable and a

00:14:16,750 --> 00:14:22,120
function or a method when that scope

00:14:20,200 --> 00:14:23,920
exits no matter how it exits that

00:14:22,120 --> 00:14:26,140
destructive that object will get called

00:14:23,920 --> 00:14:28,779
all the time right then

00:14:26,140 --> 00:14:32,080
deterministically and so you can use

00:14:28,779 --> 00:14:35,980
that property of C++ to make a little

00:14:32,080 --> 00:14:37,690
rap of sorry I'm proud of joke using

00:14:35,980 --> 00:14:39,790
looking at code like that makes me think

00:14:37,690 --> 00:14:40,810
of using a stove like this if you want

00:14:39,790 --> 00:14:43,089
to set medium heat you have to press

00:14:40,810 --> 00:14:46,959
this button like six times that's a bad

00:14:43,089 --> 00:14:48,820
affordance bad design okay so using

00:14:46,959 --> 00:14:50,500
deterministic structures you can use

00:14:48,820 --> 00:14:53,110
this pattern and C++ called resource

00:14:50,500 --> 00:14:54,490
acquisition is initialization now

00:14:53,110 --> 00:14:56,470
speaking of affordances that pattern

00:14:54,490 --> 00:14:58,180
name is horrible it doesn't communicate

00:14:56,470 --> 00:14:59,770
at all but the basic idea is you can

00:14:58,180 --> 00:15:01,810
acquire a resource and a constructor

00:14:59,770 --> 00:15:02,950
release the resource into destructor and

00:15:01,810 --> 00:15:06,880
you know when the destructors going to

00:15:02,950 --> 00:15:09,130
get called so you know what's going to

00:15:06,880 --> 00:15:10,480
happen and so we can wrap a resource in

00:15:09,130 --> 00:15:12,400
a little wrapper class called safe

00:15:10,480 --> 00:15:14,410
resource it acquires the resource in the

00:15:12,400 --> 00:15:16,810
constructor releases the resource and

00:15:14,410 --> 00:15:17,059
destructor and I've got a little get

00:15:16,810 --> 00:15:18,349
mess

00:15:17,059 --> 00:15:21,079
they're just so we can get out the raw

00:15:18,349 --> 00:15:23,059
resource and I can rewrite foo using

00:15:21,079 --> 00:15:24,619
safe resource

00:15:23,059 --> 00:15:25,999
klee the same as the first example

00:15:24,619 --> 00:15:27,259
except that I don't need the explicit

00:15:25,999 --> 00:15:30,559
release at the bottom that's taken care

00:15:27,259 --> 00:15:33,199
of but the point is no matter how I exit

00:15:30,559 --> 00:15:34,519
this function whether I early return

00:15:33,199 --> 00:15:37,279
whether I get an exception or whether

00:15:34,519 --> 00:15:38,689
exit normally that resource will get

00:15:37,279 --> 00:15:40,189
released automatically and I don't have

00:15:38,689 --> 00:15:42,109
to do anything as a programmer I don't

00:15:40,189 --> 00:15:43,579
have to do anything special i can use

00:15:42,109 --> 00:15:45,319
safe resource anywhere in my program I

00:15:43,579 --> 00:15:47,299
want and I've got to do nothing extra

00:15:45,319 --> 00:15:52,369
special to handle that resource getting

00:15:47,299 --> 00:15:55,009
released properly welcome to Mountain

00:15:52,369 --> 00:15:56,779
West small talk so we have this

00:15:55,009 --> 00:15:59,509
affordance of deterministic destructors

00:15:56,779 --> 00:16:01,249
can we apply this to Ruby well Ruby

00:15:59,509 --> 00:16:04,009
doesn't have deterministic destructors

00:16:01,249 --> 00:16:05,899
so what can we do instead we can use

00:16:04,009 --> 00:16:07,369
begin ensure blocks everywhere where we

00:16:05,899 --> 00:16:09,889
use the resource so in the insurer block

00:16:07,369 --> 00:16:12,319
we actually release the resource okay

00:16:09,889 --> 00:16:13,639
you can actually define a finalizar on

00:16:12,319 --> 00:16:15,259
an object that will get called when the

00:16:13,639 --> 00:16:20,299
garbage collector collects the object

00:16:15,259 --> 00:16:21,409
ooh but and also we don't actually know

00:16:20,299 --> 00:16:23,539
when the garbage collector is going to

00:16:21,409 --> 00:16:26,389
run if you're in a tight loop acquiring

00:16:23,539 --> 00:16:27,769
a resource a lot you need that resource

00:16:26,389 --> 00:16:28,969
to get released really fast because

00:16:27,769 --> 00:16:30,319
otherwise you could run out of it before

00:16:28,969 --> 00:16:32,929
the garbage collector gets the chance to

00:16:30,319 --> 00:16:36,079
run and run the final answer but ruby

00:16:32,929 --> 00:16:38,209
has blocks and blocks help us here quite

00:16:36,079 --> 00:16:40,399
a bit so let's look at a ruby example of

00:16:38,209 --> 00:16:42,469
the safe resource class you know

00:16:40,399 --> 00:16:44,269
initialize acquires a resource release

00:16:42,469 --> 00:16:46,339
releases it but we then we have a class

00:16:44,269 --> 00:16:48,559
method called a player that wraps the

00:16:46,339 --> 00:16:51,679
interaction with this object so we

00:16:48,559 --> 00:16:53,599
reallocate the object also come to me in

00:16:51,679 --> 00:16:55,909
a little bit and then we have an ensure

00:16:53,599 --> 00:16:57,769
that releases the resource so whenever

00:16:55,909 --> 00:16:59,659
we exit that block the resource will get

00:16:57,769 --> 00:17:01,609
released immediately and we clean up

00:16:59,659 --> 00:17:03,649
after ourselves so then we can look at

00:17:01,609 --> 00:17:06,619
our food method where we do safer zorks

00:17:03,649 --> 00:17:09,649
taquoia pass in a block that takes the

00:17:06,619 --> 00:17:11,899
resource and no matter how we leave this

00:17:09,649 --> 00:17:13,909
block that resource will get cleaned up

00:17:11,899 --> 00:17:16,519
now you've seen this pattern if you use

00:17:13,909 --> 00:17:17,990
file dot open it takes a block it opens

00:17:16,519 --> 00:17:19,850
the file for you closes it when you're

00:17:17,990 --> 00:17:21,679
done there's this pattern is all over in

00:17:19,850 --> 00:17:24,559
Ruby and it's a great pattern and that

00:17:21,679 --> 00:17:26,319
is the option we have in languages with

00:17:24,559 --> 00:17:28,399
blocks when we have to deal with

00:17:26,319 --> 00:17:31,039
resources we don't have deterministic

00:17:28,399 --> 00:17:33,799
instructors so use this pattern with

00:17:31,039 --> 00:17:35,539
blocks and java at least earlier

00:17:33,799 --> 00:17:36,630
versions of Java you have to use a

00:17:35,539 --> 00:17:39,420
finally ever

00:17:36,630 --> 00:17:41,580
we're so Ruby's blocks actually make

00:17:39,420 --> 00:17:46,200
this not too bad it's it's pretty nice

00:17:41,580 --> 00:17:47,460
syntax it's not too noisy but everywhere

00:17:46,200 --> 00:17:48,930
where you use this resource you can't

00:17:47,460 --> 00:17:50,280
just use it the way you normally would

00:17:48,930 --> 00:17:51,870
like say freeze or start new and then

00:17:50,280 --> 00:17:54,480
let it go away when you're done so you

00:17:51,870 --> 00:17:56,340
have to change as a client of this of

00:17:54,480 --> 00:17:58,740
the resource you have to change your

00:17:56,340 --> 00:17:59,940
programming pattern and he's been doing

00:17:58,740 --> 00:18:01,950
a series on with it you handle the

00:17:59,940 --> 00:18:03,510
resource safely and you can't really get

00:18:01,950 --> 00:18:04,920
rid of that duplication now Ruby it's

00:18:03,510 --> 00:18:08,640
not that much duplication it's not too

00:18:04,920 --> 00:18:10,230
bad other languages it's worse Lisp

00:18:08,640 --> 00:18:12,210
actually uses macros for this they have

00:18:10,230 --> 00:18:13,710
like a macro called with open file that

00:18:12,210 --> 00:18:15,270
you know it opens the file and then when

00:18:13,710 --> 00:18:19,200
the when you're done the code inside the

00:18:15,270 --> 00:18:21,570
block it cleans it up so we can do

00:18:19,200 --> 00:18:23,010
something like deterministic destructors

00:18:21,570 --> 00:18:24,960
in Ruby it's not quite the same but it's

00:18:23,010 --> 00:18:28,140
pretty good and I highly recommend this

00:18:24,960 --> 00:18:29,460
pattern if you use this pattern the C++

00:18:28,140 --> 00:18:31,380
all the time I mean there's smart

00:18:29,460 --> 00:18:34,650
pointer classes that do this for you the

00:18:31,380 --> 00:18:36,570
the C++ filestream classes do this for

00:18:34,650 --> 00:18:38,430
you use this pattern everywhere you

00:18:36,570 --> 00:18:40,860
completely eliminate a whole class of

00:18:38,430 --> 00:18:42,690
bugs anything to do with with leaking

00:18:40,860 --> 00:18:44,910
resources pretty much goes away with

00:18:42,690 --> 00:18:47,720
this pattern so I highly recommend it so

00:18:44,910 --> 00:18:50,970
we're gonna look at one last example

00:18:47,720 --> 00:18:53,010
it's a very long time oh so this one

00:18:50,970 --> 00:18:54,540
works too by the way one last example

00:18:53,010 --> 00:18:57,300
let's say we want to be able to read

00:18:54,540 --> 00:18:59,640
images of different types so we have

00:18:57,300 --> 00:19:01,320
this image reader and we want this to be

00:18:59,640 --> 00:19:02,820
extendable so that if you're using my

00:19:01,320 --> 00:19:05,430
imagery go library and you have your own

00:19:02,820 --> 00:19:07,020
image format you want to handle you can

00:19:05,430 --> 00:19:08,940
just add an image reader class and it

00:19:07,020 --> 00:19:10,860
will just hook into the framework so how

00:19:08,940 --> 00:19:12,540
might we do this I suppose you know that

00:19:10,860 --> 00:19:13,650
case statement is pretty much out if we

00:19:12,540 --> 00:19:15,000
wanted to be extendable because you

00:19:13,650 --> 00:19:16,380
don't want to have to go edit my case

00:19:15,000 --> 00:19:18,240
statement just to add your image reader

00:19:16,380 --> 00:19:19,830
in there we can have some kind of

00:19:18,240 --> 00:19:21,360
registry so you define your image reader

00:19:19,830 --> 00:19:24,330
class and then you have to register that

00:19:21,360 --> 00:19:25,980
class with some kind of registry let's

00:19:24,330 --> 00:19:27,540
again look at small talk and this is

00:19:25,980 --> 00:19:29,160
actually in the visual XML talk based

00:19:27,540 --> 00:19:32,250
image I've changed the code a little bit

00:19:29,160 --> 00:19:33,390
but so there's a lot of code there but

00:19:32,250 --> 00:19:34,920
basically what's going on here is

00:19:33,390 --> 00:19:38,490
there's a class method called from file

00:19:34,920 --> 00:19:40,200
it takes a file name opens a binary so

00:19:38,490 --> 00:19:43,980
these are and then calls this reader

00:19:40,200 --> 00:19:46,860
class for method on the stream and if

00:19:43,980 --> 00:19:48,900
that returns a class then we instantiate

00:19:46,860 --> 00:19:50,070
the class on the stream down at the

00:19:48,900 --> 00:19:54,690
bottom there if

00:19:50,070 --> 00:19:57,750
returns nil then we raise an error so

00:19:54,690 --> 00:20:00,690
how does this reader class for method

00:19:57,750 --> 00:20:02,820
work what's that all about well turns

00:20:00,690 --> 00:20:05,070
out small talk every class knows all of

00:20:02,820 --> 00:20:07,350
its subclasses and so we can iterate

00:20:05,070 --> 00:20:08,970
those subclasses you can either you

00:20:07,350 --> 00:20:10,890
subclasses to get the director sentence

00:20:08,970 --> 00:20:13,350
or all subclasses to get recursively all

00:20:10,890 --> 00:20:15,000
the subclasses but here we just iterate

00:20:13,350 --> 00:20:18,030
the subclasses with a detective none

00:20:15,000 --> 00:20:19,170
which we saw earlier and it resets the

00:20:18,030 --> 00:20:20,160
image stream back to the beginning so

00:20:19,170 --> 00:20:21,870
they're always looking at the beginning

00:20:20,160 --> 00:20:23,550
of the file and then just sends each

00:20:21,870 --> 00:20:25,650
class that can read message with the

00:20:23,550 --> 00:20:27,180
stream and the class will say yes I can

00:20:25,650 --> 00:20:29,130
read this stream or no I can't read this

00:20:27,180 --> 00:20:31,140
stream and if we find one that returns

00:20:29,130 --> 00:20:33,120
true two can read will return that as

00:20:31,140 --> 00:20:35,490
our imagery your class so just by virtue

00:20:33,120 --> 00:20:36,870
of there being a subclass of image

00:20:35,490 --> 00:20:40,560
reader that can read a certain image

00:20:36,870 --> 00:20:41,760
format this code will automatically find

00:20:40,560 --> 00:20:43,650
that I don't have to do anything special

00:20:41,760 --> 00:20:45,660
I don't need a registry I don't need a

00:20:43,650 --> 00:20:47,670
case statement I don't need anything I

00:20:45,660 --> 00:20:49,020
just polymorphic we asked the class hey

00:20:47,670 --> 00:20:50,850
can you read this file can you read this

00:20:49,020 --> 00:20:52,140
file can read this file and the one that

00:20:50,850 --> 00:20:54,510
answers true we'll get to handle the

00:20:52,140 --> 00:20:55,860
file this pattern works great it's used

00:20:54,510 --> 00:20:57,570
quite a bit in small talking you don't

00:20:55,860 --> 00:20:59,460
write it every day but it's really handy

00:20:57,570 --> 00:21:01,200
20 theme if you have any kind of dynamic

00:20:59,460 --> 00:21:05,430
response you can use it with like uri

00:21:01,200 --> 00:21:07,260
schemes all kinds of things so we have

00:21:05,430 --> 00:21:10,590
thus affordance of subclass iteration

00:21:07,260 --> 00:21:12,030
well what can we do in Ruby here's our

00:21:10,590 --> 00:21:13,860
image reader class I've changed the

00:21:12,030 --> 00:21:15,960
names to be a little bit I don't see

00:21:13,860 --> 00:21:18,450
more Ruby like so we have imagery to

00:21:15,960 --> 00:21:21,210
read opens a binary stream on the file

00:21:18,450 --> 00:21:22,440
calls find reader class on it raises an

00:21:21,210 --> 00:21:24,150
error if you can't find a reader class

00:21:22,440 --> 00:21:27,240
otherwise instantiates the reader they

00:21:24,150 --> 00:21:29,820
return reader class on the stream well

00:21:27,240 --> 00:21:33,360
how to find reader class work pretty

00:21:29,820 --> 00:21:35,340
much like small talk so classes find and

00:21:33,360 --> 00:21:36,840
realign the stream every time ask the

00:21:35,340 --> 00:21:42,300
leader class can you read this stream

00:21:36,840 --> 00:21:44,610
yes or no subclasses we don't have that

00:21:42,300 --> 00:21:45,990
what's that about well it turns out

00:21:44,610 --> 00:21:47,280
actually if you're using active support

00:21:45,990 --> 00:21:49,020
you do have that at least in the latest

00:21:47,280 --> 00:21:51,150
versions that's actually been built into

00:21:49,020 --> 00:21:54,180
rails now there's a sub classes for

00:21:51,150 --> 00:21:57,210
direct descendants and descendants for

00:21:54,180 --> 00:21:58,530
recursive but if you're not using active

00:21:57,210 --> 00:22:00,360
support and you don't want to pull it in

00:21:58,530 --> 00:22:01,980
for this one thing you can do this

00:22:00,360 --> 00:22:03,420
yourself we have a little taste the

00:22:01,980 --> 00:22:06,150
radius in theta use the class

00:22:03,420 --> 00:22:07,800
and then we use the inherited hook that

00:22:06,150 --> 00:22:11,430
gets called every time a subclass of the

00:22:07,800 --> 00:22:12,960
classes is is loaded or created that

00:22:11,430 --> 00:22:14,520
inherited hook gets called and we can

00:22:12,960 --> 00:22:16,110
just shovel that subclass into the array

00:22:14,520 --> 00:22:18,270
so we can do with small talk is doing

00:22:16,110 --> 00:22:20,220
for us with you know a couple lines of

00:22:18,270 --> 00:22:22,230
Ruby you can actually keep track of all

00:22:20,220 --> 00:22:23,550
the subclasses there's also extended for

00:22:22,230 --> 00:22:26,970
modules if you need to do it there you

00:22:23,550 --> 00:22:28,470
can hook into module extension so using

00:22:26,970 --> 00:22:30,270
this code if i want to write in an

00:22:28,470 --> 00:22:32,820
imagery or class let's say for bitmaps i

00:22:30,270 --> 00:22:36,330
just subclass image reader i implement

00:22:32,820 --> 00:22:38,700
can read and i return true if the first

00:22:36,330 --> 00:22:40,500
two bites of the stream r BM because

00:22:38,700 --> 00:22:41,760
that's how bitmaps are identified notice

00:22:40,500 --> 00:22:43,260
I'm not using file extensions here i'm

00:22:41,760 --> 00:22:44,970
actually using the content of the stream

00:22:43,260 --> 00:22:45,900
so this would work like if you're on a

00:22:44,970 --> 00:22:47,310
web server we're not even getting

00:22:45,900 --> 00:22:49,710
filename sure just getting images back

00:22:47,310 --> 00:22:50,940
from the server you can you can just use

00:22:49,710 --> 00:22:54,000
the data stream to tell what kind of

00:22:50,940 --> 00:22:55,260
file it is and read images where your

00:22:54,000 --> 00:22:56,760
actual reading code would go here I'm

00:22:55,260 --> 00:22:57,960
just spitting out a string because I

00:22:56,760 --> 00:23:01,770
didn't want to implement a whole bit map

00:22:57,960 --> 00:23:03,450
reader jpg image reader same idea look

00:23:01,770 --> 00:23:05,910
for the FFD eight that's the signature

00:23:03,450 --> 00:23:07,230
that dot be there is it Ruby 20 thing

00:23:05,910 --> 00:23:10,620
and it's because in coatings and that's

00:23:07,230 --> 00:23:13,440
all I'm going to say about that and then

00:23:10,620 --> 00:23:14,910
a ping image reader well pings actually

00:23:13,440 --> 00:23:16,290
have an 8-byte signature and it's

00:23:14,910 --> 00:23:17,730
actually kind of fascinating what all

00:23:16,290 --> 00:23:19,080
those bites are for it's pretty kind of

00:23:17,730 --> 00:23:20,250
it's kind of cool you can look that up I

00:23:19,080 --> 00:23:23,040
don't have time to go into it today

00:23:20,250 --> 00:23:24,570
again the encoding thing on the end so

00:23:23,040 --> 00:23:28,260
if I've got a directory full of images

00:23:24,570 --> 00:23:31,470
and I loop through them and ask the

00:23:28,260 --> 00:23:34,260
image reader to read them it reads them

00:23:31,470 --> 00:23:36,030
just fine and so when I when I if I

00:23:34,260 --> 00:23:38,190
wanted to write you know something for

00:23:36,030 --> 00:23:39,870
for gifts I could write a gif image

00:23:38,190 --> 00:23:43,110
reader subclass immense reader implement

00:23:39,870 --> 00:23:44,280
can read and read and that's all I have

00:23:43,110 --> 00:23:46,500
to do I don't have to do anything with

00:23:44,280 --> 00:23:48,450
the registry I don't have to add to a

00:23:46,500 --> 00:23:50,370
case statement I all I got to do is make

00:23:48,450 --> 00:23:53,100
sure that that imagery to class gets

00:23:50,370 --> 00:23:54,960
required in and loaded as soon as it's

00:23:53,100 --> 00:23:56,910
loaded the subclass the inherited hook

00:23:54,960 --> 00:24:00,360
will fire subclass will get registered

00:23:56,910 --> 00:24:04,610
and it'll find my image reader alright

00:24:00,360 --> 00:24:04,610
so let's wrap up here what do we learn

00:24:05,000 --> 00:24:09,090
hopefully I've taught you a couple Ruby

00:24:07,290 --> 00:24:11,010
tricks that you didn't know before maybe

00:24:09,090 --> 00:24:13,410
maybe those will help you maybe I didn't

00:24:11,010 --> 00:24:15,720
teach you anything that's fine but

00:24:13,410 --> 00:24:16,890
languages afford certain designs and

00:24:15,720 --> 00:24:18,420
inhibit other ones

00:24:16,890 --> 00:24:20,190
and when you're thinking in a particular

00:24:18,420 --> 00:24:22,470
language you tend to solve problems a

00:24:20,190 --> 00:24:25,200
certain way and so you can take those

00:24:22,470 --> 00:24:27,060
ideas those influences that that

00:24:25,200 --> 00:24:28,770
language have on your thought and you

00:24:27,060 --> 00:24:31,230
can apply them to other languages and

00:24:28,770 --> 00:24:33,420
those will increase your solution space

00:24:31,230 --> 00:24:34,980
you have more ideas about how to solve

00:24:33,420 --> 00:24:37,830
problems you'll be more creative and

00:24:34,980 --> 00:24:39,810
it'll make you a better programmer so I

00:24:37,830 --> 00:24:41,610
really recommend learning more languages

00:24:39,810 --> 00:24:43,980
and you don't have to like write massive

00:24:41,610 --> 00:24:45,480
you know production software in them but

00:24:43,980 --> 00:24:47,070
learn done enough that you can start

00:24:45,480 --> 00:24:48,900
thinking a little bit fluently in that

00:24:47,070 --> 00:24:52,640
language learned idioms and the patterns

00:24:48,900 --> 00:24:55,140
of that language but don't go too far

00:24:52,640 --> 00:24:57,360
years ago is kind of forced to work in

00:24:55,140 --> 00:24:59,340
visual basic 6 and you know 13 years of

00:24:57,360 --> 00:25:02,190
small talk of almost finished my therapy

00:24:59,340 --> 00:25:03,870
but not quite and visual basic 6 does

00:25:02,190 --> 00:25:05,730
not have implementation inheritance now

00:25:03,870 --> 00:25:08,160
implementation inheritance is overrated

00:25:05,730 --> 00:25:09,720
but when you need it you need it and I

00:25:08,160 --> 00:25:11,640
didn't have it there and so I actually

00:25:09,720 --> 00:25:14,010
came up with a pattern to fake it with

00:25:11,640 --> 00:25:15,060
composition and delegation and i'm

00:25:14,010 --> 00:25:16,710
pretty sure that none of my coworkers

00:25:15,060 --> 00:25:18,750
really understood what that code was

00:25:16,710 --> 00:25:20,250
doing I took it too far you need to

00:25:18,750 --> 00:25:21,660
write code that you're the people are

00:25:20,250 --> 00:25:23,820
coming after you and that you work with

00:25:21,660 --> 00:25:25,230
they're going to understand but that

00:25:23,820 --> 00:25:26,850
doesn't mean you shouldn't use any ideas

00:25:25,230 --> 00:25:28,410
from other languages I'm actually

00:25:26,850 --> 00:25:29,820
working on a little ruby gem right now

00:25:28,410 --> 00:25:31,290
and I've been learning JavaScript and

00:25:29,820 --> 00:25:34,110
Java Script student influencing the way

00:25:31,290 --> 00:25:35,670
I write the code in that gem the more

00:25:34,110 --> 00:25:36,900
languages you know the better designs

00:25:35,670 --> 00:25:39,450
you can come up with a better solutions

00:25:36,900 --> 00:25:40,830
can come up with another example of not

00:25:39,450 --> 00:25:42,330
going too far there's a lot of people

00:25:40,830 --> 00:25:44,310
talking about well how can we apply

00:25:42,330 --> 00:25:45,510
functional ideas to Ruby and actually I

00:25:44,310 --> 00:25:48,690
was going to be talking about that right

00:25:45,510 --> 00:25:50,670
after me and there's a lot of good ideas

00:25:48,690 --> 00:25:52,440
there but if you try to go like full-on

00:25:50,670 --> 00:25:54,180
immutable data structures where you

00:25:52,440 --> 00:25:55,950
never modify a structure you always

00:25:54,180 --> 00:25:57,900
return a copy with the modification in

00:25:55,950 --> 00:25:59,130
it you're going to cause problems Ruby's

00:25:57,900 --> 00:26:01,530
garbage collector it's just not

00:25:59,130 --> 00:26:02,670
optimized for that pattern so you need

00:26:01,530 --> 00:26:04,650
to be careful using stuff like that

00:26:02,670 --> 00:26:07,050
there's good ideas from functional and

00:26:04,650 --> 00:26:10,050
and they're worth learning but like I

00:26:07,050 --> 00:26:11,250
said don't go too far with it so if you

00:26:10,050 --> 00:26:13,140
want more on this topic I've actually

00:26:11,250 --> 00:26:14,670
wrote like a 10 or 12 part blog post

00:26:13,140 --> 00:26:17,850
series on my blog there's the link to

00:26:14,670 --> 00:26:19,860
the to the category tag and you can see

00:26:17,850 --> 00:26:21,570
that there's I tried to pick examples

00:26:19,860 --> 00:26:23,090
from there that apply to Ruby but I've

00:26:21,570 --> 00:26:25,950
got some other examples in there as well

00:26:23,090 --> 00:26:27,750
I want to thank my company key

00:26:25,950 --> 00:26:28,950
technology for actually sending me to

00:26:27,750 --> 00:26:30,730
the conference and let me come for the

00:26:28,950 --> 00:26:32,710
whole week I really appreciate that

00:26:30,730 --> 00:26:34,840
of throwing the obligatory we're hiring

00:26:32,710 --> 00:26:36,130
so if you're tired of doing web stuff

00:26:34,840 --> 00:26:37,960
and you want to come and use small talk

00:26:36,130 --> 00:26:40,390
and C++ and a small but growing amount

00:26:37,960 --> 00:26:44,049
of Ruby to to shoot at food with with

00:26:40,390 --> 00:26:45,730
supersonic air Jets talk to me Thank

00:26:44,049 --> 00:26:47,710
rogar be my local Ruby users group

00:26:45,730 --> 00:26:49,210
because that league they were guinea

00:26:47,710 --> 00:26:50,620
pigs for me for this talk they let me do

00:26:49,210 --> 00:26:51,730
a dry run a couple weeks ago and I got a

00:26:50,620 --> 00:26:53,980
lot of great feedback from them so

00:26:51,730 --> 00:26:55,360
they're awesome and Jen Myers is also

00:26:53,980 --> 00:26:57,340
awesome she does some like the inner

00:26:55,360 --> 00:26:58,480
speaker mentoring and I got to spend a

00:26:57,340 --> 00:27:00,460
half an hour on skype with her one day

00:26:58,480 --> 00:27:02,290
and she is really really awesome she's

00:27:00,460 --> 00:27:04,419
really really passionate about helping

00:27:02,290 --> 00:27:06,610
women who wanted to learn how to speak

00:27:04,419 --> 00:27:07,809
so check her out if you're in that

00:27:06,610 --> 00:27:10,179
category and you want to get some

00:27:07,809 --> 00:27:11,500
entering from her there are some

00:27:10,179 --> 00:27:14,110
references to the things I talked about

00:27:11,500 --> 00:27:15,130
yeah i'll post my slides up to okay but

00:27:14,110 --> 00:27:17,230
yeah go ahead take a picture if you want

00:27:15,130 --> 00:27:19,710
all right I'm way out of time so thank

00:27:17,230 --> 00:27:19,710
you very much

00:27:27,950 --> 00:27:30,010

YouTube URL: https://www.youtube.com/watch?v=aQu18GXl74Q


