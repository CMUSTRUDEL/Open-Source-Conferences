Title: LA Ruby Conf 2014 - SOLID principles through tests by Sebastian Sogamoso
Publication date: 2020-01-24
Playlist: LA RubyConf 2014
Description: 
	We care about writing quality code, we have read the definition of SOLID principles several times and we know how important they are for writing good OO code, but are we really following those principles? Is there a pragmatic way of following them in our day to day jobs or are they just some principles a few computer scientists wrote? Fortunately there is, SOLID principles are not just good ideas , they are intended to help us write better code, enjoy our jobs more and be happy programmers. But, where should we start? We should start where we always do. By writing tests, yes, for real. As Kent Beck says "TDD doesn't drive good design. TDD gives you immediate feedback about what is likely to be bad design", so we need to go a step further. In this talk we will see how writing tests is not just *doing TDD* is about having good test coverage, it's also about driving our code towards good design, one that follows SOLID principles.

Help us caption & translate this video!

http://amara.org/v/FG3a/
Captions: 
	00:00:25,030 --> 00:00:32,930
good morning everyone my name is

00:00:27,910 --> 00:00:35,810
Sebastian sigamos oh I'm so guy in

00:00:32,930 --> 00:00:39,370
tutoring github I come from Medellin

00:00:35,810 --> 00:00:42,650
Colombia and South America I work for a

00:00:39,370 --> 00:00:46,790
software development company I called

00:00:42,650 --> 00:00:50,480
Volvo Inc we do we build a custom

00:00:46,790 --> 00:00:54,200
solutions for institutions that are in

00:00:50,480 --> 00:00:56,960
the higher education business and today

00:00:54,200 --> 00:01:01,760
we're going to talk about solid

00:00:56,960 --> 00:01:06,320
principles two tests so this doesn't

00:01:01,760 --> 00:01:09,530
seem to be working I'll have to email

00:01:06,320 --> 00:01:14,000
okay so I want to start with a question

00:01:09,530 --> 00:01:19,580
a cane you guys rest your hand if you

00:01:14,000 --> 00:01:25,180
are doing TDD as as like as a habit and

00:01:19,580 --> 00:01:29,000
on your daily work okay okay that's good

00:01:25,180 --> 00:01:32,290
it's more than half of you guys so so

00:01:29,000 --> 00:01:35,030
that's great and I've seen that like as

00:01:32,290 --> 00:01:38,200
more and more people adopt EDD as you

00:01:35,030 --> 00:01:41,030
have it on their day-to-day jobs people

00:01:38,200 --> 00:01:43,600
have gone to a point where they're

00:01:41,030 --> 00:01:46,820
thinking that like if they're doing TDD

00:01:43,600 --> 00:01:48,439
they they are you doing it right i mean

00:01:46,820 --> 00:01:51,009
and then that's right but at they're

00:01:48,439 --> 00:01:54,220
doing it right and the in the sense that

00:01:51,009 --> 00:01:56,659
their design is good and diet their

00:01:54,220 --> 00:01:58,400
applications to their system are well

00:01:56,659 --> 00:02:00,530
designed just because of the fact

00:01:58,400 --> 00:02:03,320
they're doing treaty they're doing TDD

00:02:00,530 --> 00:02:05,509
and tdd guarantees that for them but

00:02:03,320 --> 00:02:08,590
that's not like that's not actually true

00:02:05,509 --> 00:02:13,130
that not not necessarily true because a

00:02:08,590 --> 00:02:13,760
scan back said TDD doesn't drive good

00:02:13,130 --> 00:02:16,040
design

00:02:13,760 --> 00:02:19,819
just gives you like immediate feedback

00:02:16,040 --> 00:02:22,400
of what slightly to be back design so

00:02:19,819 --> 00:02:24,500
that's not in other words mean that you

00:02:22,400 --> 00:02:25,579
should listen to your tests and you

00:02:24,500 --> 00:02:28,459
should listen to your test because

00:02:25,579 --> 00:02:31,250
they're the first client of your system

00:02:28,459 --> 00:02:34,790
and if testing is painful it's because

00:02:31,250 --> 00:02:37,340
there's a the same problem and like

00:02:34,790 --> 00:02:41,060
there's a bunch of ways to make code

00:02:37,340 --> 00:02:43,549
more testable and making call more

00:02:41,060 --> 00:02:45,140
Testament necessarily mean that the code

00:02:43,549 --> 00:02:47,840
is better so for example you could just

00:02:45,140 --> 00:02:51,700
something like making a private method

00:02:47,840 --> 00:02:55,549
public just to be able to test the class

00:02:51,700 --> 00:02:57,170
here like yeah if your way but that

00:02:55,549 --> 00:03:01,340
doesn't necessarily necessarily means

00:02:57,170 --> 00:03:03,290
that your code is actually better so in

00:03:01,340 --> 00:03:06,950
a presentation Michael feather escaped

00:03:03,290 --> 00:03:08,870
about like the deep synergy between

00:03:06,950 --> 00:03:11,239
tests and good design he said that a

00:03:08,870 --> 00:03:14,690
good design makes a class more testable

00:03:11,239 --> 00:03:17,629
and that means that solving your design

00:03:14,690 --> 00:03:20,629
problems will also solve affects your

00:03:17,629 --> 00:03:24,079
testing problems and that's what solid

00:03:20,629 --> 00:03:28,599
principles are good for they are good

00:03:24,079 --> 00:03:33,169
for helping us right object-oriented

00:03:28,599 --> 00:03:35,299
software that's well designed so for the

00:03:33,169 --> 00:03:37,579
other ones of you that don't know a

00:03:35,299 --> 00:03:40,040
solid principles is just a set of five

00:03:37,579 --> 00:03:42,410
principles there at the sign level

00:03:40,040 --> 00:03:47,660
principles and they were put together by

00:03:42,410 --> 00:03:49,160
Uncle Bob Martin and the five principles

00:03:47,660 --> 00:03:50,750
are the same responsibility the

00:03:49,160 --> 00:03:53,239
open/close principle the list scripps

00:03:50,750 --> 00:03:54,799
institution the interface aggregation

00:03:53,239 --> 00:03:58,549
and dependency inversion principle we're

00:03:54,799 --> 00:04:00,680
all getting to the damn layer so the

00:03:58,549 --> 00:04:02,750
whole idea about about following sold

00:04:00,680 --> 00:04:05,599
principles is to avoid having code

00:04:02,750 --> 00:04:08,480
that's a rigid fragile in the oil and

00:04:05,599 --> 00:04:13,180
viscous and this award words mean that

00:04:08,480 --> 00:04:16,940
it helps us avoid code having codes yeah

00:04:13,180 --> 00:04:23,419
really coupled that's hard to change and

00:04:16,940 --> 00:04:26,389
that's not reducible so if we if we look

00:04:23,419 --> 00:04:27,170
at that in a context of the the business

00:04:26,389 --> 00:04:30,110
of

00:04:27,170 --> 00:04:32,720
for development basically the intention

00:04:30,110 --> 00:04:35,090
of solid principles is to help us write

00:04:32,720 --> 00:04:39,620
code that will help you save time and

00:04:35,090 --> 00:04:42,890
money so to start looking at looking at

00:04:39,620 --> 00:04:46,520
this principles in action let's start by

00:04:42,890 --> 00:04:48,620
looking at an example and let's say we

00:04:46,520 --> 00:04:51,860
have a requirement right and the

00:04:48,620 --> 00:04:54,950
requirement tells us to model shipping

00:04:51,860 --> 00:04:57,320
method for an e-commerce system and that

00:04:54,950 --> 00:04:59,600
shipping method to calculate the cost of

00:04:57,320 --> 00:05:03,110
shipping a giving order and if you

00:04:59,600 --> 00:05:05,510
calculated giving on like three things

00:05:03,110 --> 00:05:07,820
the first one is the amount of items in

00:05:05,510 --> 00:05:11,030
the order to ship and that's excluding

00:05:07,820 --> 00:05:12,560
the items that are not like sorry that

00:05:11,030 --> 00:05:14,300
our digital so for example if we're

00:05:12,560 --> 00:05:16,430
talking about books it should exclude

00:05:14,300 --> 00:05:20,240
ebooks because we don't ship them at

00:05:16,430 --> 00:05:22,940
least not physically right so the second

00:05:20,240 --> 00:05:25,540
thing that should be based on is a fixed

00:05:22,940 --> 00:05:27,590
rate that depends on the amount of items

00:05:25,540 --> 00:05:30,440
and the third one is the distance

00:05:27,590 --> 00:05:33,320
between the origin and destination so

00:05:30,440 --> 00:05:38,480
we're going to use our spec to see these

00:05:33,320 --> 00:05:41,120
examples so let's start by like bubbling

00:05:38,480 --> 00:05:43,580
a test that helps us implement the

00:05:41,120 --> 00:05:45,320
requirements we got so we we should

00:05:43,580 --> 00:05:48,050
consider a case when all items are

00:05:45,320 --> 00:05:49,790
digital name when only one item is

00:05:48,050 --> 00:05:52,250
digital and then when more than one item

00:05:49,790 --> 00:05:54,320
is digital and then we should probably

00:05:52,250 --> 00:05:57,020
add some sub cases considering the

00:05:54,320 --> 00:05:59,150
distance so we should consider the case

00:05:57,020 --> 00:06:01,280
when the origin and destination are in

00:05:59,150 --> 00:06:03,380
the same state or the same country order

00:06:01,280 --> 00:06:04,970
in different countries then if we roll

00:06:03,380 --> 00:06:06,470
the whole test it will look something

00:06:04,970 --> 00:06:08,240
like this I didn't expect you to catch

00:06:06,470 --> 00:06:10,190
you guys to read that I just want to

00:06:08,240 --> 00:06:14,990
show that it's really big just like for

00:06:10,190 --> 00:06:17,450
a really simple method so it's it's that

00:06:14,990 --> 00:06:19,130
normally it's not a really good symptom

00:06:17,450 --> 00:06:23,000
but doesn't mean that there's problem

00:06:19,130 --> 00:06:27,260
yet so if if we have this test and then

00:06:23,000 --> 00:06:29,030
let's let this test drive us to write

00:06:27,260 --> 00:06:32,470
some code the code would probably look

00:06:29,030 --> 00:06:34,910
like this and let's look into into it so

00:06:32,470 --> 00:06:37,550
the way we calculate the car suggests

00:06:34,910 --> 00:06:40,520
like a really simple formula its items

00:06:37,550 --> 00:06:43,879
times rate times distance and let's

00:06:40,520 --> 00:06:48,080
we were like what's each one of these

00:06:43,879 --> 00:06:50,810
three things so items items are coming

00:06:48,080 --> 00:06:52,280
from from the order and we are getting

00:06:50,810 --> 00:06:54,409
the island for the order and then just

00:06:52,280 --> 00:06:58,550
like rejecting the word the ones that

00:06:54,409 --> 00:07:01,250
are digital and just counting them so if

00:06:58,550 --> 00:07:03,680
we look at this it seems like the

00:07:01,250 --> 00:07:06,110
shipping middle-class actually needs to

00:07:03,680 --> 00:07:08,900
know a lot about order and how to get

00:07:06,110 --> 00:07:11,629
the items that there are going to ship

00:07:08,900 --> 00:07:13,940
from the order and this is normally not

00:07:11,629 --> 00:07:16,880
a good symptom but let's keep on looking

00:07:13,940 --> 00:07:18,979
at this code and then the way we

00:07:16,880 --> 00:07:23,300
calculate the rate as a really simple

00:07:18,979 --> 00:07:26,330
simple method just checks f we have more

00:07:23,300 --> 00:07:29,120
than one item and it plies rate f we

00:07:26,330 --> 00:07:31,460
have a less than one item we're going to

00:07:29,120 --> 00:07:35,380
apply another one and although this is

00:07:31,460 --> 00:07:38,419
quite simple it seems like this is

00:07:35,380 --> 00:07:41,690
something that the shipping method class

00:07:38,419 --> 00:07:45,319
shouldn't probably know the bell because

00:07:41,690 --> 00:07:48,259
if this changes the shipping metal class

00:07:45,319 --> 00:07:50,090
will probably interchange seams with

00:07:48,259 --> 00:07:51,680
same thing with the distance so we're

00:07:50,090 --> 00:07:54,110
just returning Andy and it occur based

00:07:51,680 --> 00:07:56,389
on if the sea is the original

00:07:54,110 --> 00:07:58,400
destination are in the same state or in

00:07:56,389 --> 00:08:05,330
some country or they're just in

00:07:58,400 --> 00:08:09,440
different countries so looking at a

00:08:05,330 --> 00:08:11,659
class like this which has like a bunch

00:08:09,440 --> 00:08:13,250
of private methods which actually have

00:08:11,659 --> 00:08:17,539
the information or the business logic

00:08:13,250 --> 00:08:19,819
we're trying to model normally a summary

00:08:17,539 --> 00:08:21,919
class called I mean this type of class

00:08:19,819 --> 00:08:25,849
sorry s number Darren America clap

00:08:21,919 --> 00:08:28,729
called either classes and what that

00:08:25,849 --> 00:08:31,069
means is that the class has a although

00:08:28,729 --> 00:08:33,529
on the surface it looks like it has a

00:08:31,069 --> 00:08:36,529
small public API which is simple and

00:08:33,529 --> 00:08:38,149
narrow if you if you open it you'll

00:08:36,529 --> 00:08:41,539
notice that it has a lot of private

00:08:38,149 --> 00:08:43,550
methods and the logic that's relevant to

00:08:41,539 --> 00:08:45,740
the class or over to the business or to

00:08:43,550 --> 00:08:51,170
the system where will we are building

00:08:45,740 --> 00:08:54,050
it's all on those private methods you

00:08:51,170 --> 00:08:56,540
should actually try to avoid this

00:08:54,050 --> 00:09:08,390
it's not something you want to have in

00:08:56,540 --> 00:09:09,890
your system okay so let's look at the

00:09:08,390 --> 00:09:14,000
single responsibility principle which

00:09:09,890 --> 00:09:17,570
will probably help us design this code

00:09:14,000 --> 00:09:20,390
better and the single possibility

00:09:17,570 --> 00:09:24,339
principle basically says that class to

00:09:20,390 --> 00:09:27,500
have one another one reason to change so

00:09:24,339 --> 00:09:28,940
looking at at what the class we just

00:09:27,500 --> 00:09:30,800
have which has a bunch of private

00:09:28,940 --> 00:09:32,930
methods and looking at this principle

00:09:30,800 --> 00:09:36,170
which says it has a class you all we

00:09:32,930 --> 00:09:38,269
have 11 in only one reason to change we

00:09:36,170 --> 00:09:40,190
could easily think about extracting a

00:09:38,269 --> 00:09:42,860
class from the class we have and that's

00:09:40,190 --> 00:09:45,230
probably a good idea but instead of

00:09:42,860 --> 00:09:47,839
jumping to salute to conclusions into

00:09:45,230 --> 00:09:51,170
solutions let's let the test tell us

00:09:47,839 --> 00:09:53,950
what to do so let's do something I like

00:09:51,170 --> 00:09:56,930
to call wishful testing which means that

00:09:53,950 --> 00:09:59,750
we are we're going we're going to write

00:09:56,930 --> 00:10:03,589
tests that assume that code that's not

00:09:59,750 --> 00:10:05,140
already part of our system exists we're

00:10:03,589 --> 00:10:08,000
going to we're going to write code that

00:10:05,140 --> 00:10:11,420
assumes that the code we will like to

00:10:08,000 --> 00:10:13,850
exist is a right there okay so test will

00:10:11,420 --> 00:10:16,670
probably look like this a lot shorter

00:10:13,850 --> 00:10:19,339
than the one we originally had and let's

00:10:16,670 --> 00:10:21,649
look at in the into more detail so this

00:10:19,339 --> 00:10:23,899
is the first part of the test or the

00:10:21,649 --> 00:10:26,779
first test which basically at considers

00:10:23,899 --> 00:10:29,950
the case when we have all items digital

00:10:26,779 --> 00:10:32,750
on the order and issue return 0 and

00:10:29,950 --> 00:10:35,360
let's look at specific line here and

00:10:32,750 --> 00:10:37,010
which is this one so we're getting in

00:10:35,360 --> 00:10:38,600
order and we're stuffing a method call

00:10:37,010 --> 00:10:41,870
known these are items and telling it to

00:10:38,600 --> 00:10:44,270
return 0 so this this method doesn't

00:10:41,870 --> 00:10:47,390
exist or doesn't probably exist yet but

00:10:44,270 --> 00:10:49,660
it makes more sense for us to to expect

00:10:47,390 --> 00:10:52,459
the method to exist because we shouldn't

00:10:49,660 --> 00:10:55,490
like we shouldn't let the shipping

00:10:52,459 --> 00:10:58,070
method class know too much about how

00:10:55,490 --> 00:11:01,070
about the order how to get the items

00:10:58,070 --> 00:11:02,990
from it so this makes more sense we're

00:11:01,070 --> 00:11:06,800
delegating the responsibility to the

00:11:02,990 --> 00:11:07,220
order order object or objects re-order

00:11:06,800 --> 00:11:09,800
class

00:11:07,220 --> 00:11:12,110
so now let's look at the second part of

00:11:09,800 --> 00:11:15,709
this test the second example and let's

00:11:12,110 --> 00:11:18,019
look at some specific lines of that the

00:11:15,709 --> 00:11:20,689
first line I I would like us to look at

00:11:18,019 --> 00:11:22,279
is this one so we're assuming that

00:11:20,689 --> 00:11:24,920
there's a class called shipping rate

00:11:22,279 --> 00:11:26,899
which is going to be in charge of

00:11:24,920 --> 00:11:29,720
calculating the rate we're going to use

00:11:26,899 --> 00:11:33,350
to calculate the cost of the shipping of

00:11:29,720 --> 00:11:36,709
shipping an order and this is also the

00:11:33,350 --> 00:11:38,990
same thing we also like doing visual

00:11:36,709 --> 00:11:41,959
programming wishing that this class

00:11:38,990 --> 00:11:44,089
existed and that this class contain all

00:11:41,959 --> 00:11:48,110
the logic to calculate the rate we will

00:11:44,089 --> 00:11:49,759
use same for distance and we're again

00:11:48,110 --> 00:11:53,360
we're expecting the order to have this

00:11:49,759 --> 00:11:55,850
non digital items rattle so after

00:11:53,360 --> 00:11:59,930
reading this test this will probably

00:11:55,850 --> 00:12:02,779
lead us or drivers to writing creating a

00:11:59,930 --> 00:12:05,389
class of looks like this so let's look

00:12:02,779 --> 00:12:06,829
at it with more detail so the way we

00:12:05,389 --> 00:12:10,579
calculate the cost is basically the same

00:12:06,829 --> 00:12:13,670
same formula and then the way we get the

00:12:10,579 --> 00:12:15,050
items changes a lot we don't have to

00:12:13,670 --> 00:12:18,410
know a lot about the order we're just

00:12:15,050 --> 00:12:20,089
calling a method on a same thing with

00:12:18,410 --> 00:12:21,439
the rate we're just depending on the

00:12:20,089 --> 00:12:23,509
rate on the shipping weight class and

00:12:21,439 --> 00:12:25,399
this sense we're doing the same thing so

00:12:23,509 --> 00:12:28,490
what we basically did here is we

00:12:25,399 --> 00:12:31,490
extracted some responsibilities that the

00:12:28,490 --> 00:12:34,120
shipping method class had and and we

00:12:31,490 --> 00:12:36,829
delegated them to other classes which

00:12:34,120 --> 00:12:40,610
makes more sense and which leaves our

00:12:36,829 --> 00:12:41,930
flat our shipping method class makes it

00:12:40,610 --> 00:12:44,809
more simple and the good thing about

00:12:41,930 --> 00:12:47,149
this is that if the way we calculate the

00:12:44,809 --> 00:12:49,160
shipping distance sorry the distance

00:12:47,149 --> 00:12:50,870
from one city to you from the region to

00:12:49,160 --> 00:12:53,600
the destination we should only change

00:12:50,870 --> 00:12:55,519
the shipping distance class and we don't

00:12:53,600 --> 00:12:58,819
have to change the shipping method class

00:12:55,519 --> 00:13:01,399
and what's also great about this is that

00:12:58,819 --> 00:13:05,050
we can probably use this shipping

00:13:01,399 --> 00:13:09,050
distance and shipping rate classes so

00:13:05,050 --> 00:13:11,689
that's how a writing test a bit

00:13:09,050 --> 00:13:14,990
differently will help us follow this

00:13:11,689 --> 00:13:16,699
link responsibility principle now let's

00:13:14,990 --> 00:13:19,309
look at a different principle one it's

00:13:16,699 --> 00:13:21,020
called the liskov substitution and this

00:13:19,309 --> 00:13:25,520
principle basically says that the

00:13:21,020 --> 00:13:28,010
FS must be substitutable for at the base

00:13:25,520 --> 00:13:31,220
class so in other word this means that

00:13:28,010 --> 00:13:34,880
if we have a Class A Class B and we have

00:13:31,220 --> 00:13:37,370
a nice and Class B sub type of class a

00:13:34,880 --> 00:13:39,800
we should be able to replace an instance

00:13:37,370 --> 00:13:43,280
of class A with class b and the system

00:13:39,800 --> 00:13:45,940
shouldn't break and and and like this

00:13:43,280 --> 00:13:50,720
principle it's that's really based on on

00:13:45,940 --> 00:13:53,120
on how we should be like take care of

00:13:50,720 --> 00:13:55,790
this when we're using heritance but this

00:13:53,120 --> 00:13:58,640
actually can be used like in a more

00:13:55,790 --> 00:14:01,580
general context and I'll talk I'll make

00:13:58,640 --> 00:14:06,490
sure what that is so it Ruby that means

00:14:01,580 --> 00:14:09,920
that if it looks like a doc and if it

00:14:06,490 --> 00:14:13,070
walks like a duck oh sorry simple dreams

00:14:09,920 --> 00:14:15,290
like a duck then it's probably a doc and

00:14:13,070 --> 00:14:18,920
we call deck it's sorry and we call it

00:14:15,290 --> 00:14:21,140
that duck typing so let's look at an

00:14:18,920 --> 00:14:23,360
example with some tests so we already

00:14:21,140 --> 00:14:25,730
know the shipping the like a shipping

00:14:23,360 --> 00:14:27,740
method that's called standard method the

00:14:25,730 --> 00:14:30,590
one we just saw in the best example and

00:14:27,740 --> 00:14:31,910
now on the right we have a new method

00:14:30,590 --> 00:14:34,850
that we want to introduce your system

00:14:31,910 --> 00:14:36,950
called express my shipping method so if

00:14:34,850 --> 00:14:39,020
just for looking at the name of them of

00:14:36,950 --> 00:14:41,030
the methods were testing on those

00:14:39,020 --> 00:14:43,970
classes they looked pretty similar

00:14:41,030 --> 00:14:47,800
although it's easy to see that the

00:14:43,970 --> 00:14:51,800
Express method it's me is missing a

00:14:47,800 --> 00:14:56,510
method that the standard shipping method

00:14:51,800 --> 00:14:59,090
has and that means that we couldn't come

00:14:56,510 --> 00:15:00,500
like replace confidently one class with

00:14:59,090 --> 00:15:02,240
the other which we couldn't replace like

00:15:00,500 --> 00:15:04,670
the standard metal we express method

00:15:02,240 --> 00:15:08,510
because it doesn't respond to the

00:15:04,670 --> 00:15:10,370
packing days message so the system could

00:15:08,510 --> 00:15:14,990
break it would be like doing something

00:15:10,370 --> 00:15:17,240
like this so if we since we're talking

00:15:14,990 --> 00:15:21,470
about tests there's type of tests that

00:15:17,240 --> 00:15:23,720
can help us like do this confidently and

00:15:21,470 --> 00:15:27,440
prevent us from having this type of

00:15:23,720 --> 00:15:29,690
phone and called contract tests and

00:15:27,440 --> 00:15:32,540
basically what a contract test is as a

00:15:29,690 --> 00:15:34,579
test now allow us that allows us to

00:15:32,540 --> 00:15:38,239
verify that a given class

00:15:34,579 --> 00:15:41,829
follows a given contract and since we're

00:15:38,239 --> 00:15:46,389
using our spec artifact has like this

00:15:41,829 --> 00:15:49,610
really nice method called show examples

00:15:46,389 --> 00:15:52,779
which allows us to the final set of

00:15:49,610 --> 00:15:55,759
tests in the block and then we use it so

00:15:52,779 --> 00:15:57,920
now I like on this and in this

00:15:55,759 --> 00:15:59,869
particular case we're just checking that

00:15:57,920 --> 00:16:02,720
like the class giving class response to

00:15:59,869 --> 00:16:06,259
some methods we can even specify which

00:16:02,720 --> 00:16:09,429
parameters to receive and then if we go

00:16:06,259 --> 00:16:12,889
back to the test we're just add them to

00:16:09,429 --> 00:16:15,470
the test of the son of shipping method

00:16:12,889 --> 00:16:17,089
and express shipping method and we will

00:16:15,470 --> 00:16:20,720
just do it by using it should behave

00:16:17,089 --> 00:16:24,110
like an accountant name of the block so

00:16:20,720 --> 00:16:26,749
this will allow us to notice that when

00:16:24,110 --> 00:16:28,549
we run the tests that the Express method

00:16:26,749 --> 00:16:31,040
doesn't follow the contract and then we

00:16:28,549 --> 00:16:34,279
could easily add that method to the to

00:16:31,040 --> 00:16:37,519
the class and now we can be sure that we

00:16:34,279 --> 00:16:39,529
are like we can do duck typing safety

00:16:37,519 --> 00:16:44,509
with confidence and the system won't

00:16:39,529 --> 00:16:46,970
break till now let's say we got a new

00:16:44,509 --> 00:16:49,809
requirement and the requirement says

00:16:46,970 --> 00:16:52,579
that we're to be able to ship an order

00:16:49,809 --> 00:16:55,220
using any of the existing shipping

00:16:52,579 --> 00:16:56,929
methods so we have let's say we have

00:16:55,220 --> 00:16:58,549
system has growing we have three

00:16:56,929 --> 00:17:01,369
shipping methods now we have a standard

00:16:58,549 --> 00:17:04,939
express with which we just saw and one

00:17:01,369 --> 00:17:08,179
new one called simulation shipping at so

00:17:04,939 --> 00:17:10,010
if we start by writing test this will

00:17:08,179 --> 00:17:11,510
probably the cases we will need to

00:17:10,010 --> 00:17:13,699
consider we will need to consider

00:17:11,510 --> 00:17:15,919
whether when shipping method is the

00:17:13,699 --> 00:17:22,100
standard wall which express one or the

00:17:15,919 --> 00:17:25,370
same thing method 1 so if we let this

00:17:22,100 --> 00:17:28,220
test drive the design of our classes or

00:17:25,370 --> 00:17:29,860
just the cold we should write it could

00:17:28,220 --> 00:17:33,769
end up looking like something like this

00:17:29,860 --> 00:17:35,539
let's look into more detail so it seems

00:17:33,769 --> 00:17:38,360
like what we're doing is we're just

00:17:35,539 --> 00:17:40,970
checking which is the class or the type

00:17:38,360 --> 00:17:44,049
of the method and this normally is now

00:17:40,970 --> 00:17:47,779
good ideas you most of you probably now

00:17:44,049 --> 00:17:49,880
so we're just checking if it's a regular

00:17:47,779 --> 00:17:52,639
shipping method and acting accordingly

00:17:49,880 --> 00:17:56,990
same thing with Express metal and same

00:17:52,639 --> 00:17:59,770
thing with same-day method so what if a

00:17:56,990 --> 00:18:02,270
new shipping method was introduced and

00:17:59,770 --> 00:18:05,240
would that mean that the order class

00:18:02,270 --> 00:18:07,760
which should change well if we look at

00:18:05,240 --> 00:18:09,830
the current implementation that means

00:18:07,760 --> 00:18:12,409
yes we'll probably need to add a piece

00:18:09,830 --> 00:18:13,940
of code when we checked out the where we

00:18:12,409 --> 00:18:15,919
check if the of the shipping method is

00:18:13,940 --> 00:18:19,820
next a shipping method and act

00:18:15,919 --> 00:18:21,740
accordingly too so now let's see you

00:18:19,820 --> 00:18:24,139
some of the solid principles to make

00:18:21,740 --> 00:18:27,529
that better than to allow us to write

00:18:24,139 --> 00:18:30,860
tests that will allow us that will guide

00:18:27,529 --> 00:18:35,750
us to drive better code so let's talk

00:18:30,860 --> 00:18:37,520
about two more principles once called it

00:18:35,750 --> 00:18:39,409
dependency inversion principle which

00:18:37,520 --> 00:18:41,200
says that you should depend on

00:18:39,409 --> 00:18:43,940
abstraction starting concretions and

00:18:41,200 --> 00:18:47,270
another one's called the open/close

00:18:43,940 --> 00:18:50,899
principle which says that you should be

00:18:47,270 --> 00:18:53,960
able to extend the class without opening

00:18:50,899 --> 00:18:58,429
it or without modifying it so if we look

00:18:53,960 --> 00:18:59,870
at this code we we just saw that too to

00:18:58,429 --> 00:19:01,639
add a new shipping method we had to

00:18:59,870 --> 00:19:04,760
change the class basically that means

00:19:01,639 --> 00:19:07,850
opening it so alcohol will probably tell

00:19:04,760 --> 00:19:10,460
us told tell us to close it class and I

00:19:07,850 --> 00:19:14,299
see how we can do that let's start by by

00:19:10,460 --> 00:19:16,879
the test this is how the test will

00:19:14,299 --> 00:19:18,679
probably look like we're just creating

00:19:16,879 --> 00:19:21,110
instance of the order and then calling

00:19:18,679 --> 00:19:23,419
ship method on it passing the method to

00:19:21,110 --> 00:19:26,899
it and then we're what we're going to

00:19:23,419 --> 00:19:29,299
check is that the ship method or ship

00:19:26,899 --> 00:19:34,309
message is actually sent to that to that

00:19:29,299 --> 00:19:37,309
object with with some arguments so that

00:19:34,309 --> 00:19:39,649
will probably lead us to write code that

00:19:37,309 --> 00:19:42,110
looks like this looks much more simple

00:19:39,649 --> 00:19:44,840
right the ship metal just received some

00:19:42,110 --> 00:19:46,789
method and caused the ship and send the

00:19:44,840 --> 00:19:51,139
ship message to it with some arguments

00:19:46,789 --> 00:19:54,289
and that means that now we achieved here

00:19:51,139 --> 00:19:56,899
is that we are now depending on

00:19:54,289 --> 00:19:58,669
concretions which in other words for

00:19:56,899 --> 00:20:00,960
this example that means we don't depend

00:19:58,669 --> 00:20:03,960
on concrete shipping methods and there

00:20:00,960 --> 00:20:06,390
entation we can just pass and shipping

00:20:03,960 --> 00:20:08,309
method to it and then and the or your

00:20:06,390 --> 00:20:11,309
class should know what to do with and

00:20:08,309 --> 00:20:14,279
also we don't need to open this class

00:20:11,309 --> 00:20:17,549
any time a new shipping method exists we

00:20:14,279 --> 00:20:19,500
can just send it to it and we can and

00:20:17,549 --> 00:20:22,500
that's what we call extending a class

00:20:19,500 --> 00:20:27,020
with we're hoping it so the we could say

00:20:22,500 --> 00:20:27,020
that the class is closed but so awesome

00:20:32,510 --> 00:20:40,169
okay now let's talk about next solid

00:20:37,590 --> 00:20:43,260
principal just called interface

00:20:40,169 --> 00:20:45,539
segregation so this principle was

00:20:43,260 --> 00:20:50,100
actually interesting because it was

00:20:45,539 --> 00:20:55,049
written with languages such as Java and

00:20:50,100 --> 00:21:00,690
C++ problem and it doesn't really apply

00:20:55,049 --> 00:21:02,789
to be as step its definition because it

00:21:00,690 --> 00:21:04,860
says that we should make fine grade

00:21:02,789 --> 00:21:07,649
interfaces for client or that are

00:21:04,860 --> 00:21:10,279
specific for each client and as you know

00:21:07,649 --> 00:21:13,799
we really we don't have interfaces but

00:21:10,279 --> 00:21:15,870
there's there's like implicit message in

00:21:13,799 --> 00:21:17,820
this principle that we can actually

00:21:15,870 --> 00:21:20,309
apply a movie and the wish you care

00:21:17,820 --> 00:21:22,169
about and this about the public

00:21:20,309 --> 00:21:25,620
interface of the classes we write and

00:21:22,169 --> 00:21:28,409
how they should be small so let's say we

00:21:25,620 --> 00:21:30,840
want to see which are the instance

00:21:28,409 --> 00:21:33,029
method Republican semantics of a factory

00:21:30,840 --> 00:21:39,419
record base for example and after worker

00:21:33,029 --> 00:21:41,130
base has actually a lot has 123 public

00:21:39,419 --> 00:21:44,760
instance methods which means it has a

00:21:41,130 --> 00:21:46,980
huge interface so if we wanted to build

00:21:44,760 --> 00:21:49,760
an object that acts as a as an active

00:21:46,980 --> 00:21:55,169
record bass instance to say we could

00:21:49,760 --> 00:21:57,419
create a contract test as we just saw

00:21:55,169 --> 00:22:00,330
before and this will mean we have to

00:21:57,419 --> 00:22:02,630
write a big contract tests and that's

00:22:00,330 --> 00:22:07,100
not something we would want to do right

00:22:02,630 --> 00:22:11,690
that's probably paint to maintain so

00:22:07,100 --> 00:22:14,550
that's why we should aim to build

00:22:11,690 --> 00:22:16,650
classes to have small public into

00:22:14,550 --> 00:22:20,160
such as a salad shipping method which

00:22:16,650 --> 00:22:22,620
basically just have for private sorry

00:22:20,160 --> 00:22:25,050
for public method instance methods which

00:22:22,620 --> 00:22:28,230
means that has a narrow narrow interface

00:22:25,050 --> 00:22:32,130
which means that if we want to build the

00:22:28,230 --> 00:22:34,650
class that acts as a shipping method we

00:22:32,130 --> 00:22:37,470
will just need to write small contract

00:22:34,650 --> 00:22:39,810
test which is easier to maintain and the

00:22:37,470 --> 00:22:42,600
end the end and like the result in class

00:22:39,810 --> 00:22:44,910
we build resulting shipping method we

00:22:42,600 --> 00:22:49,590
will probably be a simple kind of class

00:22:44,910 --> 00:22:51,810
too so why is all of this important like

00:22:49,590 --> 00:22:54,090
why should we care about solid

00:22:51,810 --> 00:22:56,550
principles and why should we consider

00:22:54,090 --> 00:22:58,710
solid principles were when writing test

00:22:56,550 --> 00:23:02,550
well this is because solid principles

00:22:58,710 --> 00:23:04,920
allows us to manage our dependencies so

00:23:02,550 --> 00:23:07,380
that we have called that's less couple

00:23:04,920 --> 00:23:11,070
and more cohesive and that means that

00:23:07,380 --> 00:23:13,080
our code will be easier to maintain and

00:23:11,070 --> 00:23:17,430
if we have code it's easier to maintain

00:23:13,080 --> 00:23:20,670
will probably be happier developers so

00:23:17,430 --> 00:23:22,920
one thing that's important to know is

00:23:20,670 --> 00:23:24,900
that solid principles are not the Holy

00:23:22,920 --> 00:23:27,210
Grail doesn't mean that you should like

00:23:24,900 --> 00:23:29,460
apply them blindly and you should always

00:23:27,210 --> 00:23:31,250
apply them and this is stunt like a

00:23:29,460 --> 00:23:34,590
golden rule you should always follow

00:23:31,250 --> 00:23:37,400
I've seen cases where people take this

00:23:34,590 --> 00:23:40,140
leg to an extreme when where they

00:23:37,400 --> 00:23:43,530
actually end up writing code that's

00:23:40,140 --> 00:23:46,770
worse than what they had before just to

00:23:43,530 --> 00:23:52,110
follow these principles blindly so apply

00:23:46,770 --> 00:23:53,940
them where it makes sense to you and the

00:23:52,110 --> 00:23:57,420
last thing I would like to say to you

00:23:53,940 --> 00:24:00,270
guys is throwing up this quote by came

00:23:57,420 --> 00:24:02,220
back yeah I like quotes by came back it

00:24:00,270 --> 00:24:05,970
has some great coat and this one says

00:24:02,220 --> 00:24:07,590
that he's not he's not like a great

00:24:05,970 --> 00:24:10,170
programmer he's just a good programmer

00:24:07,590 --> 00:24:13,140
with great habits and I think it's

00:24:10,170 --> 00:24:16,770
really important and that's something

00:24:13,140 --> 00:24:19,050
that we should all consider like having

00:24:16,770 --> 00:24:22,140
great Abbott's or acquiring great habit

00:24:19,050 --> 00:24:24,090
will actually help us like constantly

00:24:22,140 --> 00:24:28,290
the loop to constantly deliver great

00:24:24,090 --> 00:24:30,270
code and personally I think that

00:24:28,290 --> 00:24:33,210
to what solid principles are good for

00:24:30,270 --> 00:24:35,040
and some principles like following solid

00:24:33,210 --> 00:24:36,660
principles and no insult principles in

00:24:35,040 --> 00:24:39,780
keeping that in mind we're writing tests

00:24:36,660 --> 00:24:44,280
and when writing code will help us

00:24:39,780 --> 00:24:54,900
acquire good object shank habits so

00:24:44,280 --> 00:24:59,130
thank you that's all I have okay I think

00:24:54,900 --> 00:25:01,410
we have some time for questions I'm just

00:24:59,130 --> 00:25:04,560
curious if you've seen any great

00:25:01,410 --> 00:25:08,370
examples of kind of wrapping active

00:25:04,560 --> 00:25:09,630
record so that like apps can kind of you

00:25:08,370 --> 00:25:11,100
know maybe rails apps for other kind of

00:25:09,630 --> 00:25:12,630
apps can access the database through a

00:25:11,100 --> 00:25:14,250
layer that has a smaller number of

00:25:12,630 --> 00:25:16,710
methods and if that's something that

00:25:14,250 --> 00:25:20,040
like people have started doing just

00:25:16,710 --> 00:25:23,040
because it's hard to write clean like

00:25:20,040 --> 00:25:24,540
good tests with just like active record

00:25:23,040 --> 00:25:26,310
is like all our active record stuff is

00:25:24,540 --> 00:25:28,620
basically integration integrated against

00:25:26,310 --> 00:25:30,780
the database and that makes our tests

00:25:28,620 --> 00:25:32,670
slow and clunky and weirdly coupled and

00:25:30,780 --> 00:25:34,140
all that kind of stuff after a while so

00:25:32,670 --> 00:25:36,600
just curious if you've seen any really

00:25:34,140 --> 00:25:39,990
good patterns there yeah that's that's

00:25:36,600 --> 00:25:41,880
actually a very good question so what

00:25:39,990 --> 00:25:46,530
I've been doing and I've seen a lot of

00:25:41,880 --> 00:25:48,870
people doing is like maintaining your

00:25:46,530 --> 00:25:49,890
active record classes or like your

00:25:48,870 --> 00:25:52,560
models basically on the rails

00:25:49,890 --> 00:25:54,750
application as as as much as you can and

00:25:52,560 --> 00:25:58,020
that means like only using active record

00:25:54,750 --> 00:25:59,880
to to do stuff related to the database

00:25:58,020 --> 00:26:03,660
like you can you can just have the

00:25:59,880 --> 00:26:05,820
Scopes there validations and like maybe

00:26:03,660 --> 00:26:08,850
callbacks if you want to use those and

00:26:05,820 --> 00:26:12,480
and and that's it like if you like if

00:26:08,850 --> 00:26:15,780
you have to write some business logic

00:26:12,480 --> 00:26:18,330
that it relies on on that data being

00:26:15,780 --> 00:26:22,860
saved to the database you should do that

00:26:18,330 --> 00:26:24,840
on on different objects and that that

00:26:22,860 --> 00:26:28,740
makes your code way easier to maintain

00:26:24,840 --> 00:26:31,350
your active record classes a small and

00:26:28,740 --> 00:26:33,690
easy to use too and also will help you

00:26:31,350 --> 00:26:35,900
like have a test suite that runs faster

00:26:33,690 --> 00:26:35,900
probe

00:27:24,460 --> 00:27:27,460

YouTube URL: https://www.youtube.com/watch?v=_4j0Bh-Qtrc


