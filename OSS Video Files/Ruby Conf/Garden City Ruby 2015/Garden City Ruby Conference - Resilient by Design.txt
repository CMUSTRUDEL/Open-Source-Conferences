Title: Garden City Ruby Conference - Resilient by Design
Publication date: 2020-01-23
Playlist: Garden City Ruby 2015
Description: 
	By, Smit Shah

Modern distributed systems have aggressive requirements around uptime and performance, they need to face harsh realities such as sudden rush of visitors, network issues, tangled databases and other unforeseen bugs. With so many moving parts involved even in the simplest of services, it becomes mandatory to adopt defensive patterns which would guard against some of these problems and identify anti-patterns before they trigger cascading failures across systems. This talk is for all those developers who hate getting a oncall at 4 AM in the morning

Help us caption & translate this video!

http://amara.org/v/GF2o/
Captions: 
	00:00:14,860 --> 00:00:21,529
first of all like pages mansion I i work

00:00:19,580 --> 00:00:25,810
at Lorenzo I am also part of the bundler

00:00:21,529 --> 00:00:31,060
code team and today I want to talk about

00:00:25,810 --> 00:00:31,060
how to build resilient systems it is

00:00:32,620 --> 00:00:43,850
useless on them so yeah yes it cut tango

00:00:39,430 --> 00:00:48,500
so today I am going to talk about how to

00:00:43,850 --> 00:00:50,360
build resident systems so why why do we

00:00:48,500 --> 00:00:57,680
care about resident systems in the first

00:00:50,360 --> 00:01:00,830
place so if anyone who loses sleep over

00:00:57,680 --> 00:01:03,110
their systems down time or any customers

00:01:00,830 --> 00:01:05,320
or business they would care about

00:01:03,110 --> 00:01:10,040
resiliency of their system because

00:01:05,320 --> 00:01:11,960
downtime would probably mean would be

00:01:10,040 --> 00:01:13,640
disastrous for them and probably some

00:01:11,960 --> 00:01:17,469
developers would have to wake up at

00:01:13,640 --> 00:01:20,869
night to answer that on call that is one

00:01:17,469 --> 00:01:23,119
so you would want to build systems that

00:01:20,869 --> 00:01:25,520
in case of failures are a very high

00:01:23,119 --> 00:01:30,710
traffic it would still work it would

00:01:25,520 --> 00:01:33,289
still perform and hence a we do care

00:01:30,710 --> 00:01:36,679
about resonant system so how do we go

00:01:33,289 --> 00:01:39,109
about building one so let's move away

00:01:36,679 --> 00:01:44,359
from software for a bit now let's say

00:01:39,109 --> 00:01:47,450
about cars you have a car those are very

00:01:44,359 --> 00:01:50,810
resilient in tow when an accident occurs

00:01:47,450 --> 00:01:52,880
like it would have a airbag system every

00:01:50,810 --> 00:01:56,359
when it will kick in and you know save

00:01:52,880 --> 00:01:58,609
your life nuclear power reactors if the

00:01:56,359 --> 00:02:01,039
power goes out it doesn't just you know

00:01:58,609 --> 00:02:03,409
start leaking radiation all over there

00:02:01,039 --> 00:02:05,990
would be mechanisms to build it do you

00:02:03,409 --> 00:02:07,759
think those guys built-in mechanism you

00:02:05,990 --> 00:02:11,270
know once the nuclear power plant was

00:02:07,759 --> 00:02:13,430
entirely built it started it was working

00:02:11,270 --> 00:02:14,870
and then somebody says who if what if

00:02:13,430 --> 00:02:17,360
there is a power outage do we have

00:02:14,870 --> 00:02:20,290
handled that case no they would have

00:02:17,360 --> 00:02:23,270
thought about it from the start but

00:02:20,290 --> 00:02:26,540
unfortunately in software residents the

00:02:23,270 --> 00:02:27,620
way the things it works is folks do the

00:02:26,540 --> 00:02:30,769
entire feature

00:02:27,620 --> 00:02:32,480
everything is done luckily if it's in

00:02:30,769 --> 00:02:35,150
the queue estate someone would get the

00:02:32,480 --> 00:02:39,010
idea Oh what if that cache server that

00:02:35,150 --> 00:02:43,190
we are highly relying upon to beat our

00:02:39,010 --> 00:02:45,590
SLA service level agreement well what if

00:02:43,190 --> 00:02:46,879
it goes down yeah then you if you

00:02:45,590 --> 00:02:49,730
realize you didn't handle that then

00:02:46,879 --> 00:02:52,040
that's too late most of the time you

00:02:49,730 --> 00:02:55,370
realize all of this while it's on

00:02:52,040 --> 00:02:57,379
production urea once fine day when you

00:02:55,370 --> 00:02:59,450
actually need your cash is to be working

00:02:57,379 --> 00:03:01,910
when your load on your server is

00:02:59,450 --> 00:03:04,849
extremely high that's when you I would

00:03:01,910 --> 00:03:06,470
want it to perform its best that's when

00:03:04,849 --> 00:03:10,069
the cache server would actually go down

00:03:06,470 --> 00:03:12,739
and when it goes down some devs would

00:03:10,069 --> 00:03:17,659
get fired but the rest of who remains

00:03:12,739 --> 00:03:20,930
would have to handle all that carnage so

00:03:17,659 --> 00:03:23,420
the only way to design a resilient

00:03:20,930 --> 00:03:26,959
system is from the start you have to

00:03:23,420 --> 00:03:28,879
begin with resonance in mind while

00:03:26,959 --> 00:03:30,920
designing you have to think about ok

00:03:28,879 --> 00:03:36,169
what if why the service I am talking to

00:03:30,920 --> 00:03:37,940
goes down what if my what if my database

00:03:36,169 --> 00:03:39,950
does not respond or what if there is a

00:03:37,940 --> 00:03:43,099
bed query running on my database all

00:03:39,950 --> 00:03:46,370
those things you have to think and and

00:03:43,099 --> 00:03:48,230
lot of things like while I'm going to

00:03:46,370 --> 00:03:49,639
talk about patterns that can help you

00:03:48,230 --> 00:03:51,919
with a lot of things are very

00:03:49,639 --> 00:03:54,109
domain-specific those are things that

00:03:51,919 --> 00:03:59,150
you have to learn out in advance that

00:03:54,109 --> 00:04:01,040
you can handle in code so yes so coming

00:03:59,150 --> 00:04:04,959
to it this is going to be the main crux

00:04:01,040 --> 00:04:07,760
of the talk resilient design patterns so

00:04:04,959 --> 00:04:10,069
while I don't say the guarantee that you

00:04:07,760 --> 00:04:11,900
using this design patterns would

00:04:10,069 --> 00:04:15,500
guarantee that you know your tour

00:04:11,900 --> 00:04:17,979
machine will not go down every time but

00:04:15,500 --> 00:04:23,180
it will reduce it will improve your

00:04:17,979 --> 00:04:25,039
systems up time considerably so let me

00:04:23,180 --> 00:04:27,590
give an example why you would want

00:04:25,039 --> 00:04:32,990
design patterns over a one-time solution

00:04:27,590 --> 00:04:35,270
so we we had a system in production over

00:04:32,990 --> 00:04:38,060
a period of time the memory usage of

00:04:35,270 --> 00:04:41,000
that Europe we had unicorn as our bet

00:04:38,060 --> 00:04:41,630
server over a period of time the unicorn

00:04:41,000 --> 00:04:46,010
web server

00:04:41,630 --> 00:04:50,120
a memory usage would increase like day

00:04:46,010 --> 00:04:53,780
by day and by a vehicle to the memory

00:04:50,120 --> 00:04:56,660
usage would be with me so high that it

00:04:53,780 --> 00:05:00,820
would start swapping and at that point

00:04:56,660 --> 00:05:06,020
the only option you would have is to

00:05:00,820 --> 00:05:10,880
restart the e web server and so that was

00:05:06,020 --> 00:05:14,570
very painful so while looking at why

00:05:10,880 --> 00:05:16,790
this was happening we had lot of things

00:05:14,570 --> 00:05:19,280
like okay maybe it's one of the native

00:05:16,790 --> 00:05:23,120
extensions in Ruby which is leaking to

00:05:19,280 --> 00:05:26,120
memory we didn't find anything we

00:05:23,120 --> 00:05:31,660
thought okay are we creating symbols

00:05:26,120 --> 00:05:35,540
anywhere we checked we were only doing

00:05:31,660 --> 00:05:37,070
JSON parsing and that's that was the

00:05:35,540 --> 00:05:39,650
only time while we were creating symbols

00:05:37,070 --> 00:05:42,290
and generally yeah you would know that

00:05:39,650 --> 00:05:46,010
most of the times when you parts a Jason

00:05:42,290 --> 00:05:49,580
the keys would be non unique so that's a

00:05:46,010 --> 00:05:52,100
better option so let me just add that

00:05:49,580 --> 00:05:55,520
those who aren't you to do be in Ruby

00:05:52,100 --> 00:05:59,120
till Ruby 2.2 we just came out on this

00:05:55,520 --> 00:06:01,070
25th December it would never garbage

00:05:59,120 --> 00:06:04,130
collected symbols so if you create a

00:06:01,070 --> 00:06:08,480
symbol in Ruby it would remain till you

00:06:04,130 --> 00:06:10,430
kill the process so it's a like you have

00:06:08,480 --> 00:06:12,860
to talk you can't just keep creating

00:06:10,430 --> 00:06:15,740
symbols and expect things to work fine

00:06:12,860 --> 00:06:18,310
so what we found out eventually was that

00:06:15,740 --> 00:06:21,500
at one place where we were parsing JSON

00:06:18,310 --> 00:06:23,660
there were non-unique keys which were

00:06:21,500 --> 00:06:25,760
timestamps and every time we were

00:06:23,660 --> 00:06:27,800
parsing this chaser we were converting

00:06:25,760 --> 00:06:30,860
it to symbol and that was increasing

00:06:27,800 --> 00:06:33,770
from memory usage and it was not

00:06:30,860 --> 00:06:36,590
happening em very frequently but when

00:06:33,770 --> 00:06:38,690
you add one or two weeks time period the

00:06:36,590 --> 00:06:42,620
memory usage would start this one but

00:06:38,690 --> 00:06:44,360
till then so to actually solve this

00:06:42,620 --> 00:06:48,650
problem you would need knowledge of

00:06:44,360 --> 00:06:50,419
Ruby's symbol you need to familiar with

00:06:48,650 --> 00:06:53,450
your cold waste you need to know that

00:06:50,419 --> 00:06:55,230
okay I'm parsing JSON here and there are

00:06:53,450 --> 00:06:58,500
there is a unique

00:06:55,230 --> 00:07:00,210
non-unique Jason key there is a unique J

00:06:58,500 --> 00:07:02,190
Selke coming every single time when I

00:07:00,210 --> 00:07:05,640
get the response from this server all

00:07:02,190 --> 00:07:07,200
that knowledge might not be possible if

00:07:05,640 --> 00:07:09,480
the project is very large you might

00:07:07,200 --> 00:07:12,060
never know that part of the code base so

00:07:09,480 --> 00:07:15,720
till then to make sure that no customer

00:07:12,060 --> 00:07:18,180
actually got impacted we had a member we

00:07:15,720 --> 00:07:20,340
had bounded the memory of each worker we

00:07:18,180 --> 00:07:23,250
had something like monett which would

00:07:20,340 --> 00:07:25,890
monitor each worker and if its memory

00:07:23,250 --> 00:07:27,930
usage increase a certain threshold we

00:07:25,890 --> 00:07:30,480
would kill that worker and restart it

00:07:27,930 --> 00:07:32,610
that way even though we had plenty of

00:07:30,480 --> 00:07:34,890
time to look for the error to find the

00:07:32,610 --> 00:07:37,500
root cause the business was not impacted

00:07:34,890 --> 00:07:40,920
and I think this is what design patterns

00:07:37,500 --> 00:07:44,010
are all about it's like till you exactly

00:07:40,920 --> 00:07:45,570
know what the problem is it your you

00:07:44,010 --> 00:07:47,370
won't lose sleep over it and you would

00:07:45,570 --> 00:07:49,530
have sufficient time to do it if we

00:07:47,370 --> 00:07:53,910
didn't do that somebody would have had

00:07:49,530 --> 00:07:55,620
to be online every time the memory it

00:07:53,910 --> 00:07:58,560
would start because ur hitting this web

00:07:55,620 --> 00:08:01,260
so these are the patterns I would be

00:07:58,560 --> 00:08:05,670
covering today lets us begin with a very

00:08:01,260 --> 00:08:08,720
first one bounding so inbounding let's

00:08:05,670 --> 00:08:11,400
start with timeouts how many of you know

00:08:08,720 --> 00:08:14,310
that like just raise your hands how many

00:08:11,400 --> 00:08:19,380
of you know the natural ETP default

00:08:14,310 --> 00:08:22,820
timeout in Ruby like no one okay like

00:08:19,380 --> 00:08:27,210
whether your keynote speaker yeah so

00:08:22,820 --> 00:08:30,000
it's 60 seconds like it's 60 seconds by

00:08:27,210 --> 00:08:32,940
default a lot of Ruby HTTP clients are

00:08:30,000 --> 00:08:35,790
built over this natch SVP library which

00:08:32,940 --> 00:08:39,270
comes with the MRI by default so they're

00:08:35,790 --> 00:08:41,610
also 60 seconds okay what about active

00:08:39,270 --> 00:08:43,890
your record connection pool say how my

00:08:41,610 --> 00:08:46,560
what is the time out to get a connection

00:08:43,890 --> 00:08:50,460
from a connection pool like does anyone

00:08:46,560 --> 00:08:54,030
know that number like no one this time

00:08:50,460 --> 00:08:57,300
at five seconds so what do you realize

00:08:54,030 --> 00:08:59,370
is this time outs are very high the this

00:08:57,300 --> 00:09:03,480
having this time outs on a production

00:08:59,370 --> 00:09:05,670
system 100 load would be very bad I

00:09:03,480 --> 00:09:07,690
think in the fail fast pattern I'll

00:09:05,670 --> 00:09:11,470
explain why this is a very bad

00:09:07,690 --> 00:09:13,690
we're to have but generally lot of

00:09:11,470 --> 00:09:17,110
systems default timeouts are very high

00:09:13,690 --> 00:09:20,170
but the sad part is there are lot of

00:09:17,110 --> 00:09:23,160
things in your operating systems that

00:09:20,170 --> 00:09:27,780
does not have timeouts by default like

00:09:23,160 --> 00:09:30,160
we again the there was one software way

00:09:27,780 --> 00:09:32,680
with straw was to pick up all the

00:09:30,160 --> 00:09:36,640
messages from the services and push it

00:09:32,680 --> 00:09:38,860
to our main queue now the this this

00:09:36,640 --> 00:09:42,100
service was very strange because it

00:09:38,860 --> 00:09:45,490
would after 2-3 weeks it would actually

00:09:42,100 --> 00:09:47,950
get hung it would just stop working and

00:09:45,490 --> 00:09:49,390
there would be critical impact because

00:09:47,950 --> 00:09:52,750
of it because message was not getting

00:09:49,390 --> 00:09:57,370
delivered to the other service when we

00:09:52,750 --> 00:10:00,910
went down like we using GDP and printing

00:09:57,370 --> 00:10:04,660
out stack trails by trapping a signal we

00:10:00,910 --> 00:10:09,100
found out that it happened that it was

00:10:04,660 --> 00:10:11,470
getting block on socket datsun so in

00:10:09,100 --> 00:10:15,910
Ruby socket dots and is a blocking call

00:10:11,470 --> 00:10:18,790
the we were using a UDP socket which is

00:10:15,910 --> 00:10:21,340
fire-and-forget if if you still remember

00:10:18,790 --> 00:10:23,830
so generally when you send anything on

00:10:21,340 --> 00:10:27,100
UDP it's in it doesn't wait for a

00:10:23,830 --> 00:10:30,670
response it's instantaneous but UDP has

00:10:27,100 --> 00:10:33,370
a buffer and when that buffer is full if

00:10:30,670 --> 00:10:35,320
you don't have any timeouts or if you're

00:10:33,370 --> 00:10:37,930
not sending a non-blocking way the

00:10:35,320 --> 00:10:41,830
Datsun would block permanently till

00:10:37,930 --> 00:10:43,810
someone actually goes down and I mean

00:10:41,830 --> 00:10:49,570
restarts it or something like that and

00:10:43,810 --> 00:10:52,150
because we so to this one bug and this

00:10:49,570 --> 00:10:54,820
was something we used to collect

00:10:52,150 --> 00:10:56,950
matrices and analyze them later so

00:10:54,820 --> 00:10:59,589
something that would actually just read

00:10:56,950 --> 00:11:03,220
for reporting or something was blocking

00:10:59,589 --> 00:11:05,860
the main feature of the software which

00:11:03,220 --> 00:11:08,620
was sending messages so use timeouts

00:11:05,860 --> 00:11:12,600
evaluate each and every time out in your

00:11:08,620 --> 00:11:15,550
system and depending on your service

00:11:12,600 --> 00:11:18,790
maybe the acceptable timeout is only 10

00:11:15,550 --> 00:11:21,459
seconds but it wouldn't never be 60

00:11:18,790 --> 00:11:24,069
seconds second point is

00:11:21,459 --> 00:11:26,709
bounding like one I already talked about

00:11:24,069 --> 00:11:29,470
its memory bounding like check your

00:11:26,709 --> 00:11:31,660
birth process check your that that if

00:11:29,470 --> 00:11:33,579
after certain threshold you probably

00:11:31,660 --> 00:11:37,329
want some kind of behavior may be

00:11:33,579 --> 00:11:39,759
restarted or maybe clear the memory so

00:11:37,329 --> 00:11:41,980
that is one and finally i would say

00:11:39,759 --> 00:11:44,910
about inbounding i would say about this

00:11:41,980 --> 00:11:48,040
bounding your buffers and your cues so

00:11:44,910 --> 00:11:50,860
every are if your load on your system is

00:11:48,040 --> 00:11:53,920
very high all your UDP buffers tcp

00:11:50,860 --> 00:11:59,050
buffers and say you also have you text

00:11:53,920 --> 00:12:02,050
lock in your code base all of this would

00:11:59,050 --> 00:12:03,670
actually form queues and the sad part of

00:12:02,050 --> 00:12:07,449
this queues are you have zero control

00:12:03,670 --> 00:12:10,569
over those cues so you can't do anything

00:12:07,449 --> 00:12:12,100
if this queue for a form instead the

00:12:10,569 --> 00:12:16,660
better approach would be to have very

00:12:12,100 --> 00:12:21,009
restrictive buffer buffer sizes for this

00:12:16,660 --> 00:12:22,959
and then have your own cue your own

00:12:21,009 --> 00:12:24,939
bounded queue for that once you have

00:12:22,959 --> 00:12:28,029
your own bounded queue you are in

00:12:24,939 --> 00:12:29,679
control of it you can easily say apply

00:12:28,029 --> 00:12:31,240
back pressure basically tell the other

00:12:29,679 --> 00:12:34,779
service which is sending all the message

00:12:31,240 --> 00:12:36,699
that a I am completely overloaded please

00:12:34,779 --> 00:12:41,980
don't send me more messages or send them

00:12:36,699 --> 00:12:44,410
it does a slower pace or you can or you

00:12:41,980 --> 00:12:46,749
can process those messages or

00:12:44,410 --> 00:12:48,730
differently but that is something you

00:12:46,749 --> 00:12:52,420
would only know if you know how many

00:12:48,730 --> 00:12:55,929
messages are there in your queue and and

00:12:52,420 --> 00:12:58,600
if it's somewhere in your UDP buffer or

00:12:55,929 --> 00:13:00,459
it's somewhere there in your mutex Q you

00:12:58,600 --> 00:13:04,179
would never figure out that how many

00:13:00,459 --> 00:13:08,679
messages are dead to process second

00:13:04,179 --> 00:13:11,259
pattern is circuit breakers so circuit

00:13:08,679 --> 00:13:13,660
breakers are one of the patterns

00:13:11,259 --> 00:13:16,769
popularized by Michael Nygaard in this

00:13:13,660 --> 00:13:19,749
book release it they had amazing parents

00:13:16,769 --> 00:13:22,420
it's like it's really sad that lot of

00:13:19,749 --> 00:13:25,389
folks do not know anything about it so

00:13:22,420 --> 00:13:28,019
let me explain this base of the diagram

00:13:25,389 --> 00:13:31,149
so here you are talking to your client

00:13:28,019 --> 00:13:33,519
your their circuit breaker is this an

00:13:31,149 --> 00:13:34,780
intermediate thing that sends to the

00:13:33,519 --> 00:13:37,510
supplier

00:13:34,780 --> 00:13:39,250
and you get a response and you again

00:13:37,510 --> 00:13:40,870
send it back to the client everything

00:13:39,250 --> 00:13:42,970
but but now let's say there is some

00:13:40,870 --> 00:13:45,520
connection problem with other suppliers

00:13:42,970 --> 00:13:47,890
over well so what's happening is while

00:13:45,520 --> 00:13:49,510
sending the request its timing out you

00:13:47,890 --> 00:13:51,610
have set your timer because now you're

00:13:49,510 --> 00:13:54,310
following use timeout so you have time

00:13:51,610 --> 00:13:55,780
out of say two seconds it's not giving

00:13:54,310 --> 00:13:59,230
you a response in two seconds so your

00:13:55,780 --> 00:14:01,840
timing out and and then you're sending

00:13:59,230 --> 00:14:05,830
that error back to client in this case

00:14:01,840 --> 00:14:07,300
service any decent circuit breaker or

00:14:05,830 --> 00:14:09,670
implementation would have a fallback

00:14:07,300 --> 00:14:11,680
mechanism in case you would call that

00:14:09,670 --> 00:14:14,230
fall back the fall there could be a

00:14:11,680 --> 00:14:18,340
static content your cash or anything

00:14:14,230 --> 00:14:20,800
like that or it could be not be

00:14:18,340 --> 00:14:23,920
implemented whatever it is it would time

00:14:20,800 --> 00:14:27,730
on after certain time it would realize

00:14:23,920 --> 00:14:30,070
that you would have SAT a certain

00:14:27,730 --> 00:14:32,050
threshold of failure for that epi now

00:14:30,070 --> 00:14:34,450
you would say okay in last 10 minutes it

00:14:32,050 --> 00:14:39,390
should fail for thirty percent of the

00:14:34,450 --> 00:14:41,890
time if you breach that limit it would

00:14:39,390 --> 00:14:44,380
not even know the circuit would draw

00:14:41,890 --> 00:14:46,960
trip and it would go into the open state

00:14:44,380 --> 00:14:50,470
in this case you would not even bothered

00:14:46,960 --> 00:14:52,870
calling the other server this has two

00:14:50,470 --> 00:14:55,630
advantages one is you're not wasting

00:14:52,870 --> 00:14:59,110
timing out to a service which is failing

00:14:55,630 --> 00:15:01,810
more time than you desire second that

00:14:59,110 --> 00:15:03,730
other service might be over well and by

00:15:01,810 --> 00:15:07,210
sending your request there you are

00:15:03,730 --> 00:15:08,650
essentially DDoSing that service which

00:15:07,210 --> 00:15:12,190
is both the things that you wouldn't

00:15:08,650 --> 00:15:14,820
want and this is like the very bare

00:15:12,190 --> 00:15:17,440
minimum of service circuit breakers

00:15:14,820 --> 00:15:19,060
after certain time what you can do with

00:15:17,440 --> 00:15:21,100
your circuit breaker is you can move

00:15:19,060 --> 00:15:23,170
them to a half-open state where you

00:15:21,100 --> 00:15:25,270
would try making calls to the service if

00:15:23,170 --> 00:15:27,430
those calls succeed you can again go

00:15:25,270 --> 00:15:30,010
back to the initial closed state where

00:15:27,430 --> 00:15:32,860
everything is fine or if things are

00:15:30,010 --> 00:15:36,690
still not okay you can remain open and

00:15:32,860 --> 00:15:39,880
not make the call to that services

00:15:36,690 --> 00:15:42,030
actually circuit breakers are not just

00:15:39,880 --> 00:15:44,830
used to talk with other services

00:15:42,030 --> 00:15:46,510
elasticsearch makes uses of circuit

00:15:44,830 --> 00:15:48,370
breakers basically if you are executing

00:15:46,510 --> 00:15:50,800
really bad where is in

00:15:48,370 --> 00:15:52,480
elasticsearch and those queries are

00:15:50,800 --> 00:15:57,760
reaching the time limit that you have

00:15:52,480 --> 00:15:59,890
set by a certain threshold it will open

00:15:57,760 --> 00:16:02,740
the circuit for that query and it won't

00:15:59,890 --> 00:16:05,470
even execute that query every time you

00:16:02,740 --> 00:16:07,300
in a cold that tries to execute that

00:16:05,470 --> 00:16:10,089
query it will raise an exception saying

00:16:07,300 --> 00:16:12,550
that look this query is taking lot of

00:16:10,089 --> 00:16:17,200
time and we are not even going to

00:16:12,550 --> 00:16:19,000
execute it but this you save the so the

00:16:17,200 --> 00:16:21,820
other queries in your system can still

00:16:19,000 --> 00:16:24,250
go ahead in my sequel there is nothing

00:16:21,820 --> 00:16:26,620
like that so in my sequel if you have

00:16:24,250 --> 00:16:29,440
lot of queries running which are taking

00:16:26,620 --> 00:16:32,380
time it will steal all the resources

00:16:29,440 --> 00:16:36,279
from the queries the other queries that

00:16:32,380 --> 00:16:38,890
should be executing and generally if you

00:16:36,279 --> 00:16:40,900
can ask any DevOps or linux admin in

00:16:38,890 --> 00:16:43,750
this case probably he would have to go

00:16:40,900 --> 00:16:45,790
to my sequel look at my sickle process

00:16:43,750 --> 00:16:48,730
list and kill those queries one by one

00:16:45,790 --> 00:16:51,460
so the other queries can start executing

00:16:48,730 --> 00:16:56,589
so circuit breakers are even used in

00:16:51,460 --> 00:16:58,959
databases and yeah for implementation of

00:16:56,589 --> 00:17:00,940
circuit breakers or what I really

00:16:58,959 --> 00:17:03,220
recommend if any one of you is using

00:17:00,940 --> 00:17:05,980
JRuby I highly recommend you use hystrix

00:17:03,220 --> 00:17:08,589
by Netflix it's a Java library with

00:17:05,980 --> 00:17:11,920
JRuby you can easily use it inside your

00:17:08,589 --> 00:17:14,050
Ruby code but if you are on MRI there is

00:17:11,920 --> 00:17:16,449
a circuit breaker gem but frankly it's

00:17:14,050 --> 00:17:22,300
not as battle-tested as the netflix

00:17:16,449 --> 00:17:24,870
hystrix library so yeah fail fast so now

00:17:22,300 --> 00:17:26,890
in both the previous points I've been

00:17:24,870 --> 00:17:29,620
mentioning that you should be failing

00:17:26,890 --> 00:17:32,950
fast that failing fast is much better

00:17:29,620 --> 00:17:36,520
than you know taking time to do it why

00:17:32,950 --> 00:17:39,580
is that so I'm just going to need some

00:17:36,520 --> 00:17:42,130
math for this so this is littles law

00:17:39,580 --> 00:17:45,040
which is it all comes in under queueing

00:17:42,130 --> 00:17:46,840
theory so yep length of a queue depends

00:17:45,040 --> 00:17:49,270
on your how many messages are arriving

00:17:46,840 --> 00:17:51,820
and how much time you're Gotham is

00:17:49,270 --> 00:17:53,290
taking to process them so now think

00:17:51,820 --> 00:17:55,690
about it like if you are not failing

00:17:53,290 --> 00:17:57,310
fast you're just and there is something

00:17:55,690 --> 00:17:59,710
wrong with your server or the service

00:17:57,310 --> 00:18:01,900
you are talking to your mean time in the

00:17:59,710 --> 00:18:02,360
system is going to shut up it's going to

00:18:01,900 --> 00:18:07,580
be bad

00:18:02,360 --> 00:18:11,300
hi which means you're the length of the

00:18:07,580 --> 00:18:14,840
queue is going to increase over time so

00:18:11,300 --> 00:18:17,570
I have a perfect example for this saying

00:18:14,840 --> 00:18:20,930
you you are running a business of you

00:18:17,570 --> 00:18:24,980
know you offer ebooks for download so

00:18:20,930 --> 00:18:27,170
you buy the e-book you pay them through

00:18:24,980 --> 00:18:31,130
your credit card once the payment has

00:18:27,170 --> 00:18:33,170
been accepted it will prevent service

00:18:31,130 --> 00:18:35,690
actually tries to approve the pavement

00:18:33,170 --> 00:18:39,770
and then you get the downloading so by

00:18:35,690 --> 00:18:41,990
the book Excel pay payment gets approved

00:18:39,770 --> 00:18:44,000
and you get the download link now let's

00:18:41,990 --> 00:18:46,820
say the pavement up rule is talking to

00:18:44,000 --> 00:18:49,820
some credit card company servers and

00:18:46,820 --> 00:18:51,470
that is done so by the time it's down

00:18:49,820 --> 00:18:52,490
and you're not failing fast what's going

00:18:51,470 --> 00:18:57,800
to happen is there it's going to be a

00:18:52,490 --> 00:19:00,620
queue build up till that point and and

00:18:57,800 --> 00:19:02,600
let's see it took one hour to for them

00:19:00,620 --> 00:19:05,570
to get the service up now once the

00:19:02,600 --> 00:19:07,880
services up unless the response times

00:19:05,570 --> 00:19:11,210
were really really fast what's going to

00:19:07,880 --> 00:19:13,070
happen is I mean if the response times

00:19:11,210 --> 00:19:15,080
are really really fast compared to the

00:19:13,070 --> 00:19:19,040
arrival rate what's going to happen is

00:19:15,080 --> 00:19:22,160
the folks who are ordering anything now

00:19:19,040 --> 00:19:24,920
will actually get the order after one

00:19:22,160 --> 00:19:31,190
hour or whatever the delay is in that

00:19:24,920 --> 00:19:33,410
system so say so that's a very bad

00:19:31,190 --> 00:19:35,330
experience because on any books I'd what

00:19:33,410 --> 00:19:36,890
you see is like once you purchase the

00:19:35,330 --> 00:19:38,810
book it would take one minute for the

00:19:36,890 --> 00:19:40,940
download link to appear and your

00:19:38,810 --> 00:19:42,770
breeching those promises every single

00:19:40,940 --> 00:19:44,720
time the customer might never even come

00:19:42,770 --> 00:19:47,390
back and buy things from your side but

00:19:44,720 --> 00:19:50,360
let's say you believe in failing fast

00:19:47,390 --> 00:19:53,480
you say that ok I will fail fast so

00:19:50,360 --> 00:19:55,040
every time we you try call contacting

00:19:53,480 --> 00:19:57,470
that other credit card service it feel

00:19:55,040 --> 00:20:00,350
you and you have a circuit breaker

00:19:57,470 --> 00:20:02,380
implemented you go to false i can in

00:20:00,350 --> 00:20:05,300
fall that the only thing you do is you

00:20:02,380 --> 00:20:07,790
push that message to a different retry

00:20:05,300 --> 00:20:10,610
queue or something and say okay i'll

00:20:07,790 --> 00:20:13,010
retry this message later and you clear

00:20:10,610 --> 00:20:15,050
it from the main message what does this

00:20:13,010 --> 00:20:16,160
do is when the service gets out the

00:20:15,050 --> 00:20:18,800
people who are

00:20:16,160 --> 00:20:21,380
placing orders at that moment will

00:20:18,800 --> 00:20:23,450
actually get it right then in there like

00:20:21,380 --> 00:20:27,500
the one minute time that you have

00:20:23,450 --> 00:20:29,450
promised and those folks who did not did

00:20:27,500 --> 00:20:32,060
not get it in one minute you can send

00:20:29,450 --> 00:20:34,970
them a hill because you can say okay all

00:20:32,060 --> 00:20:37,610
the messages we try Q are the ones where

00:20:34,970 --> 00:20:39,830
I actually preach my promise that I

00:20:37,610 --> 00:20:41,240
promise in one minute and you can send

00:20:39,830 --> 00:20:42,710
them a mail saying okay because of

00:20:41,240 --> 00:20:45,590
technical difficulties it's going to

00:20:42,710 --> 00:20:50,180
take some time and you can also process

00:20:45,590 --> 00:20:51,920
those messages so what again if you have

00:20:50,180 --> 00:20:54,890
noticed in three patterns what I am

00:20:51,920 --> 00:20:56,510
trying to convey is control what you get

00:20:54,890 --> 00:20:58,460
here is control instead of you know

00:20:56,510 --> 00:21:00,890
allowing your operating system or

00:20:58,460 --> 00:21:02,960
someone else to have the control is

00:21:00,890 --> 00:21:04,750
better that you have the control because

00:21:02,960 --> 00:21:08,210
you understand your domain knowledge

00:21:04,750 --> 00:21:10,370
domain logic you know you know if we

00:21:08,210 --> 00:21:13,010
give our ebook buying website you would

00:21:10,370 --> 00:21:17,120
want to have the control to send apology

00:21:13,010 --> 00:21:20,890
meals or not having said that there is

00:21:17,120 --> 00:21:30,830
one thing that I really want to show you

00:21:20,890 --> 00:21:33,790
is this one second so this is a this is

00:21:30,830 --> 00:21:37,520
queuing theory and because there is a

00:21:33,790 --> 00:21:39,650
capacity talked just before this I just

00:21:37,520 --> 00:21:41,840
want to quickly show you that how you

00:21:39,650 --> 00:21:44,060
can actually use queuing theory to do

00:21:41,840 --> 00:21:45,320
amazing things so say let's say you have

00:21:44,060 --> 00:21:46,850
a single cube basically you have a

00:21:45,320 --> 00:21:50,000
website where you're getting all your

00:21:46,850 --> 00:21:57,440
messages from you have C servers so

00:21:50,000 --> 00:22:01,880
let's say C servers would be 2015 20

00:21:57,440 --> 00:22:03,560
servers you would want your getting

00:22:01,880 --> 00:22:07,280
hundred customers per minute 100

00:22:03,560 --> 00:22:10,250
requests per minute and your rate is

00:22:07,280 --> 00:22:12,740
around 15 you can process 15 requests

00:22:10,250 --> 00:22:17,180
per minute per server and you have 20

00:22:12,740 --> 00:22:20,300
service like this this tells you what is

00:22:17,180 --> 00:22:23,330
your average good time well customer how

00:22:20,300 --> 00:22:25,430
many customers you serve in a minute it

00:22:23,330 --> 00:22:28,010
tells you your load average which is

00:22:25,430 --> 00:22:29,560
zero because this number is really high

00:22:28,010 --> 00:22:35,150
because there are a number of

00:22:29,560 --> 00:22:38,300
let me reduce it so yeah so average

00:22:35,150 --> 00:22:43,790
waiting for each customer to actually

00:22:38,300 --> 00:22:47,060
get your product is 37.00 37 minute it

00:22:43,790 --> 00:22:50,720
also gives you entire graph about how

00:22:47,060 --> 00:22:53,120
much time it has to wait it can really

00:22:50,720 --> 00:23:00,800
help you with a capacity planning so

00:22:53,120 --> 00:23:03,470
yeah so going back there is a something

00:23:00,800 --> 00:23:08,270
called the bulkhead the bulkhead design

00:23:03,470 --> 00:23:11,870
pattern is actually comes from ships so

00:23:08,270 --> 00:23:14,180
if you look at any modern ship below

00:23:11,870 --> 00:23:16,910
deck there would be they would be

00:23:14,180 --> 00:23:19,490
compartmentalized completely the reason

00:23:16,910 --> 00:23:21,590
why they do this is say your shipmates

00:23:19,490 --> 00:23:23,980
with an accident and water flows through

00:23:21,590 --> 00:23:26,750
it because it's completely

00:23:23,980 --> 00:23:28,280
compartmentalize the waters won't water

00:23:26,750 --> 00:23:30,350
won't invade the other parts of the

00:23:28,280 --> 00:23:33,350
system so even if this one part of the

00:23:30,350 --> 00:23:36,410
system is down it does not take out the

00:23:33,350 --> 00:23:39,440
entire boat with it and this is the same

00:23:36,410 --> 00:23:41,900
in services saying n you have two

00:23:39,440 --> 00:23:45,500
services a and B and they talk to sorry

00:23:41,900 --> 00:23:48,950
we see now unfortunately the service see

00:23:45,500 --> 00:23:52,910
goes down a both a and B making requests

00:23:48,950 --> 00:23:54,890
to see are also down and because now a

00:23:52,910 --> 00:23:57,830
and we are down service depending on

00:23:54,890 --> 00:24:00,020
them or would also go down so you can

00:23:57,830 --> 00:24:01,850
see this is a cascading failure scenario

00:24:00,020 --> 00:24:07,550
like many a multiple microservice

00:24:01,850 --> 00:24:09,740
running in your system in your all in

00:24:07,550 --> 00:24:12,620
your sauce service-oriented are today so

00:24:09,740 --> 00:24:15,080
in this case this is something do you

00:24:12,620 --> 00:24:18,320
clearly do not desire but let's say you

00:24:15,080 --> 00:24:21,250
use the bulkhead pattern you have server

00:24:18,320 --> 00:24:23,930
see some of the dedicated servers

00:24:21,250 --> 00:24:26,390
dedicated first service a and some are

00:24:23,930 --> 00:24:30,410
dedicated to service be for good

00:24:26,390 --> 00:24:32,390
measures see their physical most don't

00:24:30,410 --> 00:24:36,290
also go down so you have put them on

00:24:32,390 --> 00:24:40,100
different regions of AWS so but this

00:24:36,290 --> 00:24:43,070
even if service a can a portion of

00:24:40,100 --> 00:24:45,200
service see goes down other services

00:24:43,070 --> 00:24:47,269
we still be up because of redundancy

00:24:45,200 --> 00:24:49,610
that you have introduced however

00:24:47,269 --> 00:24:52,159
bulkheads are not just for services it

00:24:49,610 --> 00:24:54,470
could be applied to your single machine

00:24:52,159 --> 00:24:56,840
as well so say you have a machine and

00:24:54,470 --> 00:25:00,500
you have multiple threads running you

00:24:56,840 --> 00:25:02,960
can a pin a certain thread group to a

00:25:00,500 --> 00:25:05,870
core and other threads to other core so

00:25:02,960 --> 00:25:08,210
even if those threads that part of the

00:25:05,870 --> 00:25:12,950
service that thought which is using

00:25:08,210 --> 00:25:15,049
those threads start to start to get

00:25:12,950 --> 00:25:17,240
overloaded it won't at least make use of

00:25:15,049 --> 00:25:20,029
other polls it will only use the course

00:25:17,240 --> 00:25:22,360
that it spin too and that way even

00:25:20,029 --> 00:25:25,220
though some part of your machine is

00:25:22,360 --> 00:25:28,059
constantly busy the other my parts are

00:25:25,220 --> 00:25:32,360
still able to serve requests and that is

00:25:28,059 --> 00:25:34,009
what the bulkhead pattern is and finally

00:25:32,360 --> 00:25:36,620
the last pattern that I want to talk

00:25:34,009 --> 00:25:41,120
about is specifications specifications

00:25:36,620 --> 00:25:44,059
are something that I feel feel a lot of

00:25:41,120 --> 00:25:47,870
folks have realized that they are not

00:25:44,059 --> 00:25:49,700
important but I think Leslie Lampard

00:25:47,870 --> 00:25:51,799
gave up amazing talk last year called

00:25:49,700 --> 00:25:54,259
thinking for programmers you should

00:25:51,799 --> 00:25:57,320
definitely watch it if you haven't in

00:25:54,259 --> 00:25:59,929
specifications what he says before you

00:25:57,320 --> 00:26:02,149
write any code you write the

00:25:59,929 --> 00:26:04,730
specification in a stateful manner so

00:26:02,149 --> 00:26:07,669
you have a function that takes an

00:26:04,730 --> 00:26:11,990
argument a and it changes that are a to

00:26:07,669 --> 00:26:15,950
some state B and if you document that

00:26:11,990 --> 00:26:18,110
you write this before you do it you

00:26:15,950 --> 00:26:21,169
would realize that how sloppy your

00:26:18,110 --> 00:26:23,149
thinking is because what happens is that

00:26:21,169 --> 00:26:26,750
whenever a person thinks about a case

00:26:23,149 --> 00:26:28,639
before when he starts coding he he only

00:26:26,750 --> 00:26:30,350
at most he is only going to think about

00:26:28,639 --> 00:26:33,470
the happy casement everything is working

00:26:30,350 --> 00:26:35,629
fine you would never consider the cases

00:26:33,470 --> 00:26:39,320
when you know something might be wrong

00:26:35,629 --> 00:26:42,049
with the system so but the specification

00:26:39,320 --> 00:26:44,240
once you write this down that this is

00:26:42,049 --> 00:26:46,940
what I want you realize that you haven't

00:26:44,240 --> 00:26:49,340
thought about lot of cases inside your

00:26:46,940 --> 00:26:53,200
system and then that's when you realize

00:26:49,340 --> 00:26:56,290
that you need to think about the non

00:26:53,200 --> 00:26:58,420
not-so-happy case so one of the four

00:26:56,290 --> 00:27:00,730
that I have to say he said by Michael

00:26:58,420 --> 00:27:03,220
Naga the software design only talks

00:27:00,730 --> 00:27:08,410
about what system should do not what

00:27:03,220 --> 00:27:11,320
system should not do and because because

00:27:08,410 --> 00:27:13,540
we only address we if we only think

00:27:11,320 --> 00:27:16,480
about that okay the happy path case I

00:27:13,540 --> 00:27:20,080
can assure you when on production when

00:27:16,480 --> 00:27:21,880
you actually encounters in order that

00:27:20,080 --> 00:27:24,940
you didn't think about things won't go

00:27:21,880 --> 00:27:27,790
well you have you need to think about it

00:27:24,940 --> 00:27:30,850
this is before you write any sort of

00:27:27,790 --> 00:27:32,980
good because even if you do TDD the

00:27:30,850 --> 00:27:35,860
amount of test coverage that you would

00:27:32,980 --> 00:27:36,940
actually do is based on scenarios that

00:27:35,860 --> 00:27:39,010
you have thought of if you haven't

00:27:36,940 --> 00:27:40,830
thought about a problem well if you

00:27:39,010 --> 00:27:42,640
don't really understand any cold

00:27:40,830 --> 00:27:45,430
understand the problem that you are

00:27:42,640 --> 00:27:48,400
trying to solve completely no matter

00:27:45,430 --> 00:27:51,310
what Oh patterns or whatever you lose

00:27:48,400 --> 00:27:54,300
you will never be able to write good

00:27:51,310 --> 00:27:57,090
code that would actually solve it and

00:27:54,300 --> 00:28:01,570
finally just putting all together all

00:27:57,090 --> 00:28:03,580
this patterns that I would highly

00:28:01,570 --> 00:28:07,150
recommend that if there is one pattern

00:28:03,580 --> 00:28:08,200
that you can start with you were i would

00:28:07,150 --> 00:28:10,720
recommend that you start with

00:28:08,200 --> 00:28:12,670
specification and some of you might

00:28:10,720 --> 00:28:14,860
think that you know maybe my services

00:28:12,670 --> 00:28:18,310
aren't large enough for big enough to

00:28:14,860 --> 00:28:21,130
make use of any patterns but i digress

00:28:18,310 --> 00:28:24,370
that even the smallest service today is

00:28:21,130 --> 00:28:26,050
a distributed system you at least in

00:28:24,370 --> 00:28:28,420
worst case have would have a database

00:28:26,050 --> 00:28:30,040
running on a different server and you

00:28:28,420 --> 00:28:32,890
would be communicating through network

00:28:30,040 --> 00:28:36,670
and as we all know that network is not

00:28:32,890 --> 00:28:38,680
as reliable as we want so I would say

00:28:36,670 --> 00:28:42,760
that at least put some of those patterns

00:28:38,680 --> 00:28:44,830
in practice I I think you can ask any

00:28:42,760 --> 00:28:47,740
developer who has been on call for a

00:28:44,830 --> 00:28:51,160
long time it's not a really amazing

00:28:47,740 --> 00:28:53,370
thing to be on so yeah that's it that's

00:28:51,160 --> 00:28:53,370
mine

00:28:55,279 --> 00:29:03,289
and here the references i'll upload with

00:28:59,489 --> 00:29:03,289
slight so if you want to know more

00:29:16,310 --> 00:29:18,370

YouTube URL: https://www.youtube.com/watch?v=yTkaq26YgDU


