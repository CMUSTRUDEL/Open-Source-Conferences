Title: Rocky Mountain Ruby 2013 SOLID and TDD, Sitting in a  by Mike Nicholaides
Publication date: 2020-01-27
Playlist: Rocky Mountain Ruby 2013
Description: 
	You've heard the claims or know from experience that test-driven development (TDD) produces better code. Perhaps you've also heard that to write better code you should be following the SOLID principles. Is there a connection between practicing TDD and writing SOLID code?

In this talk, I'll use examples gleaned from real life to demonstrate how TDD prompts us to produce code that conforms to the SOLID principles, and how the SOLID principles are where we should turn when our tests are causing us pain. In doing so, we'll learn what each principle really means and why it's valuable.

Mike Nicholaides has been a Rails consultant since 2006 and has always obsessed about writing clean, clear, and concise code. He organizes the Code Retreat in Philadelphia where the focus is on learning TDD, communicating with code, and of course, having fun.

Help us caption & translate this video!

http://amara.org/v/FG6D/
Captions: 
	00:00:29,699 --> 00:00:37,120
hello everybody um hi my name is mike

00:00:34,899 --> 00:00:41,050
nicoletis i'm gonna be talking about

00:00:37,120 --> 00:00:44,710
testing today a little bit about myself

00:00:41,050 --> 00:00:47,739
first i'm a partner at prompt works were

00:00:44,710 --> 00:00:49,980
small consultancy in philadelphia we do

00:00:47,739 --> 00:00:52,239
a lot of work in ruby rails javascript

00:00:49,980 --> 00:00:55,800
infrastructure automation like chef that

00:00:52,239 --> 00:00:58,210
kind of thing besides just developing

00:00:55,800 --> 00:01:00,969
products for our clients we do a lot of

00:00:58,210 --> 00:01:02,920
pair programming with them that's

00:01:00,969 --> 00:01:05,379
because when we leave you know when the

00:01:02,920 --> 00:01:07,260
project is over we want to continue them

00:01:05,379 --> 00:01:09,909
on the path of test-driven development

00:01:07,260 --> 00:01:12,340
good object-oriented design and good

00:01:09,909 --> 00:01:17,020
process um that's somewhat of an

00:01:12,340 --> 00:01:18,460
inspiration for this talk and testing is

00:01:17,020 --> 00:01:23,259
something that's important to the way

00:01:18,460 --> 00:01:24,909
that we work excuse me so I work with a

00:01:23,259 --> 00:01:26,740
bunch of super talented folks here and

00:01:24,909 --> 00:01:29,890
we have some really great clients and

00:01:26,740 --> 00:01:32,170
I'm honored to be a part of that alright

00:01:29,890 --> 00:01:33,610
let's get started you've probably heard

00:01:32,170 --> 00:01:36,070
you've probably heard have said that if

00:01:33,610 --> 00:01:38,530
you do TDD and that is if you write your

00:01:36,070 --> 00:01:39,270
tests first before you write a code that

00:01:38,530 --> 00:01:41,710
you're going to end up with

00:01:39,270 --> 00:01:44,470
well-designed code your code will be

00:01:41,710 --> 00:01:47,560
easy to understand easy to change easy

00:01:44,470 --> 00:01:49,240
to reuse and of course correct but I'm

00:01:47,560 --> 00:01:54,390
here to tell you that that's just not

00:01:49,240 --> 00:01:56,560
true I can show you many examples of

00:01:54,390 --> 00:01:59,469
tests that were that were written first

00:01:56,560 --> 00:02:03,280
some of them look like this can you guys

00:01:59,469 --> 00:02:04,540
in the back read that yeah well it

00:02:03,280 --> 00:02:05,619
doesn't matter cuz if it was in front of

00:02:04,540 --> 00:02:09,489
you you probably still wouldn't be able

00:02:05,619 --> 00:02:11,110
to you know and then you know if you

00:02:09,489 --> 00:02:11,980
berate tests like that your code that

00:02:11,110 --> 00:02:14,400
makes it past is going to look something

00:02:11,980 --> 00:02:14,400
like this

00:02:14,939 --> 00:02:19,870
so if you if you buy into that idea that

00:02:17,939 --> 00:02:22,180
writing your test first is going to give

00:02:19,870 --> 00:02:24,069
you a good code don't be surprised when

00:02:22,180 --> 00:02:27,310
you find yourself in snared and thorny

00:02:24,069 --> 00:02:33,189
about brittle code and tests that are

00:02:27,310 --> 00:02:35,739
even worse you see well tested code or

00:02:33,189 --> 00:02:38,709
I'm sorry well designed code is easy to

00:02:35,739 --> 00:02:41,409
test inherently testing is hard when

00:02:38,709 --> 00:02:44,560
codes not well designed if we write our

00:02:41,409 --> 00:02:46,810
test first the design of our our code is

00:02:44,560 --> 00:02:49,510
going to match the design that our tests

00:02:46,810 --> 00:02:51,519
expect so you need to know how to listen

00:02:49,510 --> 00:02:54,190
to your tests and how to use your test

00:02:51,519 --> 00:02:56,290
to describe good design so I'm going to

00:02:54,190 --> 00:02:58,090
show you what I mean but first let's

00:02:56,290 --> 00:03:03,159
let's talk about what I mean when I say

00:02:58,090 --> 00:03:06,250
good code if you're unfamiliar with

00:03:03,159 --> 00:03:08,439
solid it's an acronym for five design

00:03:06,250 --> 00:03:10,060
principles these are principles that

00:03:08,439 --> 00:03:14,379
uncle bob martin identified and

00:03:10,060 --> 00:03:16,090
collected in the early 2000s he noticed

00:03:14,379 --> 00:03:19,030
that the good software that he saw that

00:03:16,090 --> 00:03:21,250
is good software is easy to maintain

00:03:19,030 --> 00:03:23,440
easy to extend it all seem to follow

00:03:21,250 --> 00:03:25,840
these five principles so I'm going to go

00:03:23,440 --> 00:03:27,190
over them briefly and kind of put some

00:03:25,840 --> 00:03:30,849
emphasis and what I think this means for

00:03:27,190 --> 00:03:32,470
Ruby development and then we're going to

00:03:30,849 --> 00:03:33,730
do some other stuff get into some tests

00:03:32,470 --> 00:03:35,319
so I'm going to take them in different

00:03:33,730 --> 00:03:39,069
order than the acronym because I think

00:03:35,319 --> 00:03:40,959
it's easier to explain that way so first

00:03:39,069 --> 00:03:43,440
let's get this one out of the way the I

00:03:40,959 --> 00:03:46,120
install it is interface segregation I

00:03:43,440 --> 00:03:48,040
don't think it belongs with these four

00:03:46,120 --> 00:03:50,620
fundamental principles but for other

00:03:48,040 --> 00:03:53,349
ones the only benefit that it gives us

00:03:50,620 --> 00:03:56,409
is it that it makes compiling statically

00:03:53,349 --> 00:04:01,709
typed code bases faster so C++ and Java

00:03:56,409 --> 00:04:04,389
we don't have that problem good for us

00:04:01,709 --> 00:04:06,790
the D in solid is stands for a

00:04:04,389 --> 00:04:07,979
dependency inversion don't worry about

00:04:06,790 --> 00:04:10,120
the name is sort of a throwback to

00:04:07,979 --> 00:04:13,019
implementation details and statically

00:04:10,120 --> 00:04:16,359
typed in the statically type of world

00:04:13,019 --> 00:04:18,820
but the thing to remember is this depend

00:04:16,359 --> 00:04:22,479
on us depend upon abstractions not

00:04:18,820 --> 00:04:24,190
concretions so like what are concretion

00:04:22,479 --> 00:04:25,900
is what are abstractions let's let's

00:04:24,190 --> 00:04:29,979
look some code that I think can help

00:04:25,900 --> 00:04:32,440
fine a little bit better this method

00:04:29,979 --> 00:04:36,970
depends upon a concretion it's calling

00:04:32,440 --> 00:04:38,470
file dot open directly ok well let's

00:04:36,970 --> 00:04:41,979
compare that to depending on an

00:04:38,470 --> 00:04:43,419
abstraction in this version the save my

00:04:41,979 --> 00:04:45,820
game method it depends on the

00:04:43,419 --> 00:04:47,560
abstraction of a what we called a

00:04:45,820 --> 00:04:50,169
persistent store so instead of using

00:04:47,560 --> 00:04:52,360
file out open directly all has to know

00:04:50,169 --> 00:04:57,100
is how to call a save method and pass it

00:04:52,360 --> 00:05:00,460
its game data and so this this file

00:04:57,100 --> 00:05:04,270
store this is a an abstraction and the

00:05:00,460 --> 00:05:06,190
file that open part is the concretion so

00:05:04,270 --> 00:05:07,330
for every day Ruby development i think

00:05:06,190 --> 00:05:09,370
that the dependency inversion principle

00:05:07,330 --> 00:05:16,300
is telling us we should hide concretions

00:05:09,370 --> 00:05:19,630
behind abstractions next up is the open

00:05:16,300 --> 00:05:21,310
closed principle this one says that

00:05:19,630 --> 00:05:24,509
software entities should be open for

00:05:21,310 --> 00:05:27,729
extension but closed for modification

00:05:24,509 --> 00:05:30,400
entities being like methods classes

00:05:27,729 --> 00:05:33,490
modules that sort of thing in more

00:05:30,400 --> 00:05:36,510
concrete terms this means that we should

00:05:33,490 --> 00:05:39,510
have swappable pieces for dependencies

00:05:36,510 --> 00:05:41,680
collaborators and complicated logic

00:05:39,510 --> 00:05:44,289
you're actually already familiar with

00:05:41,680 --> 00:05:47,740
techniques that let us abide by this

00:05:44,289 --> 00:05:52,300
principle blocks for instance so think

00:05:47,740 --> 00:05:53,710
of array map we pass it we passed that

00:05:52,300 --> 00:05:55,840
method a block to change the way it

00:05:53,710 --> 00:05:58,210
works so the method is open for

00:05:55,840 --> 00:05:59,979
extension but and the clothes for

00:05:58,210 --> 00:06:02,020
modification part means that we're not

00:05:59,979 --> 00:06:03,340
changing the way the map method works

00:06:02,020 --> 00:06:08,860
for everybody else just in this

00:06:03,340 --> 00:06:10,960
particular case inheritance so you know

00:06:08,860 --> 00:06:12,639
we can extend any class by soup by sub

00:06:10,960 --> 00:06:17,699
classing it and this doesn't change the

00:06:12,639 --> 00:06:21,550
original class and dependency injection

00:06:17,699 --> 00:06:24,370
being able to swap out dependencies and

00:06:21,550 --> 00:06:26,470
collaborate collaborators collaborators

00:06:24,370 --> 00:06:28,780
lets us change the way that a object

00:06:26,470 --> 00:06:30,860
works without modifying the class or the

00:06:28,780 --> 00:06:33,080
source code

00:06:30,860 --> 00:06:36,469
so let's look at our example this is an

00:06:33,080 --> 00:06:38,569
example of dependency injection in this

00:06:36,469 --> 00:06:39,939
version the save my game method it takes

00:06:38,569 --> 00:06:43,849
a persistent store as a parameter

00:06:39,939 --> 00:06:45,349
instead of hard-coding it to use this

00:06:43,849 --> 00:06:47,240
method we can pass in any kind of

00:06:45,349 --> 00:06:49,150
persistence store and that's what

00:06:47,240 --> 00:06:51,409
dependency injection is we're passing in

00:06:49,150 --> 00:06:54,530
something we're passing the dependency

00:06:51,409 --> 00:06:56,360
instead of hard-coding it so if you're

00:06:54,530 --> 00:06:58,759
confused about what that meant it's just

00:06:56,360 --> 00:07:01,969
that don't get that be scared by the

00:06:58,759 --> 00:07:06,409
weird name and the reputation that other

00:07:01,969 --> 00:07:08,210
communities have given it so this method

00:07:06,409 --> 00:07:09,650
is now open for extension you can change

00:07:08,210 --> 00:07:13,400
the way behaves by passing an object's

00:07:09,650 --> 00:07:14,990
that behave differently for everyday

00:07:13,400 --> 00:07:16,129
development is I think this principle

00:07:14,990 --> 00:07:18,050
just means we should be making our

00:07:16,129 --> 00:07:21,080
entities extendable make your methods

00:07:18,050 --> 00:07:23,990
make your classes extendable and end

00:07:21,080 --> 00:07:26,750
your objects next we have the list cough

00:07:23,990 --> 00:07:28,159
substitution principle you've probably

00:07:26,750 --> 00:07:31,810
heard this principle described in terms

00:07:28,159 --> 00:07:33,830
of classes and subclasses but in Ruby

00:07:31,810 --> 00:07:36,620
classes actually have nothing to do with

00:07:33,830 --> 00:07:38,000
it in Ruby we use duck typing even if

00:07:36,620 --> 00:07:42,560
you're using sub classes and stuff

00:07:38,000 --> 00:07:45,409
everything is duck typed so um like

00:07:42,560 --> 00:07:47,960
Lionel said earlier about duck typing if

00:07:45,409 --> 00:07:51,800
it quacks like a duck it's a duck that's

00:07:47,960 --> 00:07:54,080
what duck typing is if the this

00:07:51,800 --> 00:07:55,370
principle tells us sort of a sort of a

00:07:54,080 --> 00:07:57,289
kind of different way of saying it if

00:07:55,370 --> 00:07:59,930
you want it to be a duck you have to

00:07:57,289 --> 00:08:02,839
make it quack like a duck it's also

00:07:59,930 --> 00:08:05,569
going to look at this example whatever

00:08:02,839 --> 00:08:07,370
object we pass into this method as long

00:08:05,569 --> 00:08:09,250
as it quacks like a duck it's a duck so

00:08:07,370 --> 00:08:11,449
as long as it responds to save and

00:08:09,250 --> 00:08:14,930
accepts the game data as an argument

00:08:11,449 --> 00:08:16,939
then we can use it and will know that

00:08:14,930 --> 00:08:19,250
we're following the this principle if

00:08:16,939 --> 00:08:21,379
we're not using is ax or kind of or

00:08:19,250 --> 00:08:24,400
respond to to check the type we're just

00:08:21,379 --> 00:08:29,569
we're trusting the type that we're given

00:08:24,400 --> 00:08:31,159
and then the last the last principle we

00:08:29,569 --> 00:08:34,310
have is the single responsibility

00:08:31,159 --> 00:08:35,750
principle this is the one that says that

00:08:34,310 --> 00:08:39,020
a class should have one and only one

00:08:35,750 --> 00:08:40,669
reason to change in terms of every day

00:08:39,020 --> 00:08:43,159
Ruby development it means that our

00:08:40,669 --> 00:08:46,370
classes should be small our classes

00:08:43,159 --> 00:08:48,589
should do one thing and instead of

00:08:46,370 --> 00:08:55,610
having a few big classes we should have

00:08:48,589 --> 00:08:59,390
lots of small classes so solid for every

00:08:55,610 --> 00:09:00,529
day Ruby development just means this we

00:08:59,390 --> 00:09:02,930
should be hiding concretions behind

00:09:00,529 --> 00:09:06,199
abstractions which make entities

00:09:02,930 --> 00:09:08,660
extendable use duck typing this is Ruby

00:09:06,199 --> 00:09:11,240
after all and classes should do one

00:09:08,660 --> 00:09:13,490
thing okay so now that we have some

00:09:11,240 --> 00:09:16,190
guidelines let's look at some code that

00:09:13,490 --> 00:09:17,930
does not follow them we're gonna listen

00:09:16,190 --> 00:09:22,520
to the tests and see what they are

00:09:17,930 --> 00:09:24,490
telling us about the design okay so a

00:09:22,520 --> 00:09:26,839
little context we've been given this app

00:09:24,490 --> 00:09:29,029
it's a Twitter clone but don't tell that

00:09:26,839 --> 00:09:30,410
to the owner because it's better than

00:09:29,029 --> 00:09:34,399
Twitter because you're not limited to

00:09:30,410 --> 00:09:36,620
140 characters in this app users can

00:09:34,399 --> 00:09:39,529
send each other messages don't call them

00:09:36,620 --> 00:09:41,480
tweets our lawyers get very upset their

00:09:39,529 --> 00:09:44,959
messages so here's an example of the

00:09:41,480 --> 00:09:46,310
message model just like with Twitter we

00:09:44,959 --> 00:09:49,670
can use the @ sign in front of a

00:09:46,310 --> 00:09:51,800
username to mention somebody and then we

00:09:49,670 --> 00:09:54,170
can call mentioned users on a message

00:09:51,800 --> 00:09:57,199
that gives us an array of the users that

00:09:54,170 --> 00:10:00,370
we mentioned so let's look at some code

00:09:57,199 --> 00:10:02,120
that I found in one of the controllers I

00:10:00,370 --> 00:10:03,680
thought was I just wanted to give you

00:10:02,120 --> 00:10:06,470
loaded with context and so here's some

00:10:03,680 --> 00:10:09,949
code and we have this class this

00:10:06,470 --> 00:10:12,740
notifier class it looks like maybe it's

00:10:09,949 --> 00:10:15,920
about notifying people who are mentioned

00:10:12,740 --> 00:10:18,199
in a message so i know that this app was

00:10:15,920 --> 00:10:19,519
written test first so let's go look at

00:10:18,199 --> 00:10:24,050
the test and we'll find out what it does

00:10:19,519 --> 00:10:27,260
and see how it's designed so here are

00:10:24,050 --> 00:10:30,589
the tests I removed the test codes just

00:10:27,260 --> 00:10:33,769
the descriptions i will read abri them

00:10:30,589 --> 00:10:37,910
for you if if it's too hard to read back

00:10:33,769 --> 00:10:40,430
there it emails okay so the the notifier

00:10:37,910 --> 00:10:43,279
class one we call dot notify on it it

00:10:40,430 --> 00:10:45,709
emails the messages mentioned users who

00:10:43,279 --> 00:10:48,110
prefer to be emailed it essa messes

00:10:45,709 --> 00:10:49,819
those who prefer to be SMS and a

00:10:48,110 --> 00:10:52,010
facebook so I guess that's what the FB

00:10:49,819 --> 00:10:53,930
is Facebook's the messages messages

00:10:52,010 --> 00:10:58,339
mentioned users who prefer to be

00:10:53,930 --> 00:11:00,980
facebooked so it looks like this thing

00:10:58,339 --> 00:11:02,240
sends out emails SMS is something on

00:11:00,980 --> 00:11:06,740
facebook maybe that's a facebook wall

00:11:02,240 --> 00:11:09,110
post also it looks like this business

00:11:06,740 --> 00:11:11,209
about who prefer to be emailed who

00:11:09,110 --> 00:11:12,980
prefer to be SMS it looks like that

00:11:11,209 --> 00:11:15,500
users can opt out of getting emails or

00:11:12,980 --> 00:11:20,689
SMS is in this class will honor those

00:11:15,500 --> 00:11:22,670
preferences so before we start examining

00:11:20,689 --> 00:11:26,510
what's wrong with this let's talk about

00:11:22,670 --> 00:11:31,339
what's good here first this class is

00:11:26,510 --> 00:11:32,870
tested that is wonderful secondly the

00:11:31,339 --> 00:11:35,390
test descriptions are accurate and

00:11:32,870 --> 00:11:36,589
complete as far as we know that we can

00:11:35,390 --> 00:11:38,209
tell that they're there have been some

00:11:36,589 --> 00:11:41,510
details that have been embedded in the

00:11:38,209 --> 00:11:43,100
test descriptions and that's a good

00:11:41,510 --> 00:11:44,630
thing I think that all tests should have

00:11:43,100 --> 00:11:48,260
that property that all the details are

00:11:44,630 --> 00:11:50,689
embedded in the descriptions third we

00:11:48,260 --> 00:11:52,579
have all the logic is hidden behind this

00:11:50,689 --> 00:11:53,899
abstraction this notifier class so the

00:11:52,579 --> 00:11:56,209
controller doesn't have to know anything

00:11:53,899 --> 00:12:00,079
about emailing or smsing it just says

00:11:56,209 --> 00:12:06,140
notified to notify and that's a nice

00:12:00,079 --> 00:12:07,850
abstraction for us good so let's let's

00:12:06,140 --> 00:12:09,740
start listening now to what the test is

00:12:07,850 --> 00:12:11,720
the tests are telling us about the

00:12:09,740 --> 00:12:13,670
design and we're going to take two

00:12:11,720 --> 00:12:15,230
approaches the first approach is going

00:12:13,670 --> 00:12:19,250
to be a little more methodical or

00:12:15,230 --> 00:12:20,540
effortful as Brian would say and then

00:12:19,250 --> 00:12:22,670
we're going to try to build a little bit

00:12:20,540 --> 00:12:24,260
of intuition and see what our intuition

00:12:22,670 --> 00:12:31,429
should be telling us about these this

00:12:24,260 --> 00:12:33,050
tests so that this is the well I want to

00:12:31,429 --> 00:12:36,260
talk about I'm going to use the word

00:12:33,050 --> 00:12:38,120
details a lot and when I say details in

00:12:36,260 --> 00:12:40,790
reference to the tests and to the care

00:12:38,120 --> 00:12:43,040
this is what I mean what it does there's

00:12:40,790 --> 00:12:44,630
two things what it does that's things

00:12:43,040 --> 00:12:46,880
that this class is expected to do so

00:12:44,630 --> 00:12:48,589
that's responsibilities and remember our

00:12:46,880 --> 00:12:51,679
class our classes are supposed to have

00:12:48,589 --> 00:12:53,959
one responsibility and then what it

00:12:51,679 --> 00:12:57,770
knows so that's things that this class

00:12:53,959 --> 00:12:59,899
has to know in order to do its job these

00:12:57,770 --> 00:13:01,069
are concretions so remember we're

00:12:59,899 --> 00:13:05,510
supposed to be hiding country shins

00:13:01,069 --> 00:13:07,100
behind abstractions okay so let's start

00:13:05,510 --> 00:13:08,420
with what this class has to do we're

00:13:07,100 --> 00:13:08,910
kind of be methodical about it just

00:13:08,420 --> 00:13:09,750
lists

00:13:08,910 --> 00:13:12,630
we're going to list out everything so

00:13:09,750 --> 00:13:16,920
what are its responsibilities it has to

00:13:12,630 --> 00:13:20,100
email users SMS users and Facebook users

00:13:16,920 --> 00:13:24,510
and now what does it have to know what

00:13:20,100 --> 00:13:26,010
are the concretions the message so it

00:13:24,510 --> 00:13:29,540
has to know which messages has its

00:13:26,010 --> 00:13:33,270
notifying about it has to know how to

00:13:29,540 --> 00:13:35,130
has to know who to notify and it has to

00:13:33,270 --> 00:13:37,920
know who did who to determine these to

00:13:35,130 --> 00:13:40,170
be notified by each each method so who

00:13:37,920 --> 00:13:45,750
wants to be emailed it must be SMS who

00:13:40,170 --> 00:13:48,060
wants to be facebook okay so if we do

00:13:45,750 --> 00:13:50,070
that with our you know we can't we don't

00:13:48,060 --> 00:13:51,300
always have the time in the you know if

00:13:50,070 --> 00:13:53,790
we practiced Edd and we're going through

00:13:51,300 --> 00:13:56,340
this cycle we don't always have the time

00:13:53,790 --> 00:13:57,930
or the energy or remember to you know

00:13:56,340 --> 00:14:00,420
let's list out everything that's going

00:13:57,930 --> 00:14:03,360
on here so let's talk about some more

00:14:00,420 --> 00:14:09,600
intuitive sense that we should we can

00:14:03,360 --> 00:14:12,140
build to listen to our tests so first

00:14:09,600 --> 00:14:15,320
let's look at I mean just what the tests

00:14:12,140 --> 00:14:18,150
let's listen to what they just say and

00:14:15,320 --> 00:14:20,160
you know on the surface level in this

00:14:18,150 --> 00:14:21,990
case it's a dead giveaway that it's

00:14:20,160 --> 00:14:26,270
describing more than one responsibility

00:14:21,990 --> 00:14:28,410
right it emails it SMS is at Facebook's

00:14:26,270 --> 00:14:31,680
and then another thing that we can

00:14:28,410 --> 00:14:34,800
notice is that each described

00:14:31,680 --> 00:14:37,550
responsibility has the same structure so

00:14:34,800 --> 00:14:39,600
and when you have multiple response

00:14:37,550 --> 00:14:41,280
responsibilities that have the same

00:14:39,600 --> 00:14:43,290
structure it's usually a sign that

00:14:41,280 --> 00:14:48,950
there's an abstraction that we've failed

00:14:43,290 --> 00:14:52,770
to identify okay so there's that next

00:14:48,950 --> 00:14:54,630
let's look at the language so look

00:14:52,770 --> 00:14:56,910
especially at this phrase who prefer to

00:14:54,630 --> 00:14:59,760
be emailed um it's sort of awkward

00:14:56,910 --> 00:15:02,870
phrasing and it comes from the need but

00:14:59,760 --> 00:15:05,730
I think the correct desire to encode

00:15:02,870 --> 00:15:08,010
this detail in the description so as

00:15:05,730 --> 00:15:10,460
this detail was not encoded in here it

00:15:08,010 --> 00:15:13,410
would seem to indicate that every every

00:15:10,460 --> 00:15:14,430
mentioned user should be emailed when

00:15:13,410 --> 00:15:17,040
that's not the case only the ones who

00:15:14,430 --> 00:15:19,410
have opted in so like I said before

00:15:17,040 --> 00:15:22,499
that's good that the details are encoded

00:15:19,410 --> 00:15:25,859
here and that is accurate and complete

00:15:22,499 --> 00:15:28,229
that's good and one of the reasons it's

00:15:25,859 --> 00:15:31,769
good is because it makes it it makes it

00:15:28,229 --> 00:15:34,949
clear when our phrasing starts to get

00:15:31,769 --> 00:15:37,399
harder and harder to to get it right

00:15:34,949 --> 00:15:40,079
when we have to agonize over the words

00:15:37,399 --> 00:15:42,089
it's it might be telling us that we're

00:15:40,079 --> 00:15:44,399
embedding we have too many details here

00:15:42,089 --> 00:15:47,069
and that's why it's hard to embed them

00:15:44,399 --> 00:15:48,959
in the test description so when we have

00:15:47,069 --> 00:15:51,089
strained long test descriptions to sign

00:15:48,959 --> 00:15:55,879
there are too many details not enough

00:15:51,089 --> 00:15:58,049
abstractions so where are we at so far

00:15:55,879 --> 00:16:00,299
we've looked at the test descriptions

00:15:58,049 --> 00:16:01,949
and we hear them telling us that this

00:16:00,299 --> 00:16:04,619
notifier class probably has too many

00:16:01,949 --> 00:16:07,709
responsibilities and it's not hiding its

00:16:04,619 --> 00:16:08,929
concretions behind abstractions we

00:16:07,709 --> 00:16:11,369
haven't even looked at the test code yet

00:16:08,929 --> 00:16:14,249
so that's us already we have pretty good

00:16:11,369 --> 00:16:16,949
indicators of what's going on next let's

00:16:14,249 --> 00:16:19,769
look at some of the test code and listen

00:16:16,949 --> 00:16:21,719
to what that might be telling us when I

00:16:19,769 --> 00:16:24,749
say look I mean look what I don't even

00:16:21,719 --> 00:16:26,279
read this don't bother so this is the

00:16:24,749 --> 00:16:30,720
third test case this is the one about

00:16:26,279 --> 00:16:33,419
Facebook and what is what's the first

00:16:30,720 --> 00:16:38,069
feeling that you notice when you look at

00:16:33,419 --> 00:16:41,069
this yeah I season yes big it's long the

00:16:38,069 --> 00:16:43,949
first yes the first feeling that I

00:16:41,069 --> 00:16:45,179
get is that it's scary so if if my boss

00:16:43,949 --> 00:16:47,549
says I need to change something about

00:16:45,179 --> 00:16:49,979
how Facebook messaging works where

00:16:47,549 --> 00:16:52,139
there's coding or there's a a bug in

00:16:49,979 --> 00:16:55,289
this code somewhere I'm not excited to

00:16:52,139 --> 00:16:56,549
fix it and I'm not excited so like if we

00:16:55,289 --> 00:17:01,349
have another case left it's like copy

00:16:56,549 --> 00:17:02,249
this test and change it so I can you can

00:17:01,349 --> 00:17:03,869
already tell just by looking at it

00:17:02,249 --> 00:17:06,839
that's going to be difficult to follow

00:17:03,869 --> 00:17:08,699
and it's not because it's like spaghetti

00:17:06,839 --> 00:17:11,879
it's actually linear there's three

00:17:08,699 --> 00:17:14,220
sections it's like a given when then

00:17:11,879 --> 00:17:15,419
takes that format but it'd be hard to

00:17:14,220 --> 00:17:17,579
get your head around because there are

00:17:15,419 --> 00:17:19,319
so many details here and we can tell

00:17:17,579 --> 00:17:24,949
that just by looking at just by looking

00:17:19,319 --> 00:17:27,720
at it and that's part of the reason why

00:17:24,949 --> 00:17:29,750
you know your tests and my tests are

00:17:27,720 --> 00:17:29,750
hard

00:17:29,900 --> 00:17:34,190
so this is what all the tests look like

00:17:32,330 --> 00:17:37,220
for this class that this is the three

00:17:34,190 --> 00:17:39,770
different test cases and this is the

00:17:37,220 --> 00:17:42,200
actual code that makes the test pass so

00:17:39,770 --> 00:17:44,840
we could maybe clean this up we break

00:17:42,200 --> 00:17:46,250
things into smaller methods but that

00:17:44,840 --> 00:17:48,410
would really just be putting lipstick on

00:17:46,250 --> 00:17:49,880
a pig because we'd be hiding the fact

00:17:48,410 --> 00:17:52,100
that there are still three

00:17:49,880 --> 00:17:53,600
responsibilities at least in this class

00:17:52,100 --> 00:17:57,290
and there are too many concretions in

00:17:53,600 --> 00:18:00,500
this class not enough abstraction so

00:17:57,290 --> 00:18:02,540
your boss your client calls you 3 a.m.

00:18:00,500 --> 00:18:05,450
and says that there's a bug in how we're

00:18:02,540 --> 00:18:06,860
smsing people and you know people are

00:18:05,450 --> 00:18:09,950
complaining because they have the 25

00:18:06,860 --> 00:18:14,210
cents per text message plan so that's

00:18:09,950 --> 00:18:16,310
really expensive for them so we have to

00:18:14,210 --> 00:18:24,940
fix it now so what's your reaction going

00:18:16,310 --> 00:18:28,400
to be yeah so I've definitely felt this

00:18:24,940 --> 00:18:30,920
so we can do better we now that we know

00:18:28,400 --> 00:18:32,720
the properties of good object-oriented

00:18:30,920 --> 00:18:36,650
design or have some sense of them at

00:18:32,720 --> 00:18:38,600
least let's fix this first I think that

00:18:36,650 --> 00:18:40,790
we need some guidelines for how to write

00:18:38,600 --> 00:18:44,960
our tests how to do TDD in a way that

00:18:40,790 --> 00:18:48,440
that gives us that gives us pain-free

00:18:44,960 --> 00:18:51,290
tests so these are the guidelines that I

00:18:48,440 --> 00:18:53,750
think we should follow we should defer

00:18:51,290 --> 00:18:56,240
our responsibilities to other classes so

00:18:53,750 --> 00:18:58,250
when we're when we're encountering that

00:18:56,240 --> 00:18:59,600
we have multiple responsibilities we

00:18:58,250 --> 00:19:02,920
should be pushing them off into

00:18:59,600 --> 00:19:06,440
dependencies or into collaborators or

00:19:02,920 --> 00:19:08,150
pushing them somewhere else I mean

00:19:06,440 --> 00:19:08,990
pushing off the ones that are more than

00:19:08,150 --> 00:19:11,600
one we should only take one

00:19:08,990 --> 00:19:13,760
responsibility per class and secondly we

00:19:11,600 --> 00:19:15,500
need to assume good abstractions so

00:19:13,760 --> 00:19:18,830
remember when we're writing our test

00:19:15,500 --> 00:19:21,740
first we're defining the API of our of

00:19:18,830 --> 00:19:23,540
the class that we're going to write so

00:19:21,740 --> 00:19:24,440
we have to assume that we have that our

00:19:23,540 --> 00:19:26,780
class is going to give us a good

00:19:24,440 --> 00:19:27,950
abstraction and if we do we'll have to

00:19:26,780 --> 00:19:29,420
write it in a way that makes the test

00:19:27,950 --> 00:19:32,420
pass and we'll be left with a good

00:19:29,420 --> 00:19:37,070
abstraction so with these guidelines we

00:19:32,420 --> 00:19:38,090
can make testing easy on ourselves okay

00:19:37,070 --> 00:19:40,730
so let's kind of go through this a

00:19:38,090 --> 00:19:42,920
little bit first let's deal with this

00:19:40,730 --> 00:19:43,370
the fact we have so many details in here

00:19:42,920 --> 00:19:45,380
and

00:19:43,370 --> 00:19:46,870
or more so the fact that we have this

00:19:45,380 --> 00:19:50,059
repeated structure and there's an

00:19:46,870 --> 00:19:51,890
abstraction that that's in there that we

00:19:50,059 --> 00:19:54,800
need to get out so let's remove the

00:19:51,890 --> 00:19:56,960
details okay so now since all three of

00:19:54,800 --> 00:19:59,240
these are the same let's combine them

00:19:56,960 --> 00:20:01,430
into one and now we're going to put the

00:19:59,240 --> 00:20:03,530
details back in and this is going to

00:20:01,430 --> 00:20:07,850
force us to use an abstraction so I just

00:20:03,530 --> 00:20:10,640
put all the details back in and it reads

00:20:07,850 --> 00:20:14,570
horribly it notified via SMS / facebook

00:20:10,640 --> 00:20:17,330
/ email right it reads horribly but

00:20:14,570 --> 00:20:19,490
we've identified which places are where

00:20:17,330 --> 00:20:22,179
our abstraction is we had we need some

00:20:19,490 --> 00:20:24,710
abstraction to handle SMS Facebook email

00:20:22,179 --> 00:20:27,740
and combine them into a single

00:20:24,710 --> 00:20:31,309
abstraction so what sort of thing like

00:20:27,740 --> 00:20:32,330
would would cover that I'm thinking

00:20:31,309 --> 00:20:35,000
maybe like a we'll call it a

00:20:32,330 --> 00:20:37,670
notification channel like SMS Facebook

00:20:35,000 --> 00:20:39,559
and email they're all channels for us so

00:20:37,670 --> 00:20:45,470
let's put that abstraction into our test

00:20:39,559 --> 00:20:46,970
case okay so that's that's good we still

00:20:45,470 --> 00:20:51,590
have this via their preferred

00:20:46,970 --> 00:20:56,150
notification channels language so if if

00:20:51,590 --> 00:20:57,679
we leave this as is this test is telling

00:20:56,150 --> 00:21:02,420
us that our class is responsible for

00:20:57,679 --> 00:21:04,040
determining which channels which users

00:21:02,420 --> 00:21:07,160
should be notified on which channels

00:21:04,040 --> 00:21:08,570
right so that's that's another

00:21:07,160 --> 00:21:10,929
responsibility or maybe to concretion

00:21:08,570 --> 00:21:15,110
it's kind of fuzzy but let's defer that

00:21:10,929 --> 00:21:17,480
it force another class to pick it up so

00:21:15,110 --> 00:21:19,760
we'll defer it by just saying it meant

00:21:17,480 --> 00:21:22,340
it messages messages then via

00:21:19,760 --> 00:21:25,220
notification channels so where is that

00:21:22,340 --> 00:21:27,910
like you know we can't just tell our

00:21:25,220 --> 00:21:32,540
clients to stop giving us requirements I

00:21:27,910 --> 00:21:33,890
mean sometimes we do but really the

00:21:32,540 --> 00:21:36,290
problem is that we have an abstracted

00:21:33,890 --> 00:21:38,690
thing as well so where is this this

00:21:36,290 --> 00:21:41,809
responsibility of knowing who to who to

00:21:38,690 --> 00:21:44,420
notify via which channel going to live

00:21:41,809 --> 00:21:47,870
so we have a notifier class and we have

00:21:44,420 --> 00:21:49,460
this notification channel abstraction so

00:21:47,870 --> 00:21:50,630
we're testing the notifier class so it's

00:21:49,460 --> 00:21:53,150
not there so it's going to have to be in

00:21:50,630 --> 00:21:56,090
the notification channel and that sounds

00:21:53,150 --> 00:21:58,169
fine I guess we'll see if that works

00:21:56,090 --> 00:22:01,679
so let's clean up the language a little

00:21:58,169 --> 00:22:03,539
bit and that's a lot better it notifies

00:22:01,679 --> 00:22:06,059
mentioned users via notification

00:22:03,539 --> 00:22:13,470
channels okay we can all take a deep

00:22:06,059 --> 00:22:14,730
breath I'm deep breath yeah so we're

00:22:13,470 --> 00:22:16,350
taking a deep breath a sigh of relief

00:22:14,730 --> 00:22:18,960
because we shrunk our test description

00:22:16,350 --> 00:22:21,360
considerably and this is going to be

00:22:18,960 --> 00:22:24,210
much easier to test we have a good

00:22:21,360 --> 00:22:28,049
abstraction we think far fewer details

00:22:24,210 --> 00:22:33,299
and one responsibility so let's write

00:22:28,049 --> 00:22:36,840
this test ah okay isn't that better it's

00:22:33,299 --> 00:22:38,250
short you don't necessarily have to read

00:22:36,840 --> 00:22:41,370
it I'll just kind of explain really

00:22:38,250 --> 00:22:43,169
quickly what's going on here given we're

00:22:41,370 --> 00:22:46,289
going to do a given when done given a

00:22:43,169 --> 00:22:47,970
mock message and to mock channels and a

00:22:46,289 --> 00:22:51,840
notifier that's initialized with those

00:22:47,970 --> 00:22:57,269
channels when we tell the notifier to

00:22:51,840 --> 00:22:58,710
notify about a message then we assert

00:22:57,269 --> 00:23:03,870
that each channel was given a message

00:22:58,710 --> 00:23:07,950
and told to notify about it and this is

00:23:03,870 --> 00:23:09,840
the code that makes this test pass so

00:23:07,950 --> 00:23:11,970
what's going on here this notifier class

00:23:09,840 --> 00:23:13,830
can be initialized with a list of

00:23:11,970 --> 00:23:16,230
notification channels right so that's

00:23:13,830 --> 00:23:19,710
dependency injection when we call dot

00:23:16,230 --> 00:23:20,940
notify on a notifier instance it's going

00:23:19,710 --> 00:23:23,730
to go through the list of channels until

00:23:20,940 --> 00:23:27,870
each one of those to notify and give it

00:23:23,730 --> 00:23:30,179
the message so this time the test was

00:23:27,870 --> 00:23:33,779
waste this class was way easier to test

00:23:30,179 --> 00:23:35,580
and to implement so maybe you're

00:23:33,779 --> 00:23:38,700
thinking and I sort of hope you are that

00:23:35,580 --> 00:23:40,139
I'm kind of cheating right so of course

00:23:38,700 --> 00:23:42,840
this was easier to test it hardly does

00:23:40,139 --> 00:23:45,929
anything you know the other tests were

00:23:42,840 --> 00:23:49,649
sitting we're testing a lot of stuff and

00:23:45,929 --> 00:23:51,059
I say in response to that that you're

00:23:49,649 --> 00:23:54,840
actually right and that's exactly the

00:23:51,059 --> 00:23:57,029
point it doesn't when we have small

00:23:54,840 --> 00:23:59,250
classes that depend on abstractions

00:23:57,029 --> 00:24:02,039
they're super easy to test and we want

00:23:59,250 --> 00:24:06,570
to have our all our classes be small and

00:24:02,039 --> 00:24:09,090
easy to test um it's interestingly

00:24:06,570 --> 00:24:10,620
enough this kind of

00:24:09,090 --> 00:24:12,930
came out of it when I was putting this

00:24:10,620 --> 00:24:14,820
together the details about which

00:24:12,930 --> 00:24:17,670
notification channels to use becomes a

00:24:14,820 --> 00:24:19,380
configuration option and so right here

00:24:17,670 --> 00:24:21,150
we have in production we have some

00:24:19,380 --> 00:24:22,830
channels that were using in staging we

00:24:21,150 --> 00:24:25,320
use different ones that's it's now

00:24:22,830 --> 00:24:27,480
become configuration and we got that for

00:24:25,320 --> 00:24:29,820
free because we were depending upon

00:24:27,480 --> 00:24:31,500
abstractions so we're depending upon the

00:24:29,820 --> 00:24:34,470
idea of a notification channel rather

00:24:31,500 --> 00:24:36,300
than particular ones and we're injecting

00:24:34,470 --> 00:24:40,850
the dependencies not hard coating them

00:24:36,300 --> 00:24:40,850
so we made the class open to extension

00:24:41,390 --> 00:24:46,590
so now this is what the test for the

00:24:43,890 --> 00:24:48,120
email channel looks like let's go

00:24:46,590 --> 00:24:49,590
through really quickly given that we

00:24:48,120 --> 00:24:52,190
have a message with three mentioned

00:24:49,590 --> 00:24:56,760
users two of which want to be emailed

00:24:52,190 --> 00:25:02,190
and I'm sorry I think I skipped piece

00:24:56,760 --> 00:25:04,740
here there we go yes we have a message

00:25:02,190 --> 00:25:06,210
with users and then we stub out our

00:25:04,740 --> 00:25:08,790
message mailer that's like our action

00:25:06,210 --> 00:25:09,930
mailer thing in rails we're going to

00:25:08,790 --> 00:25:13,050
stub that out so we can laid our test

00:25:09,930 --> 00:25:15,060
that it was called correctly when we

00:25:13,050 --> 00:25:19,050
make a new email channel and tell it to

00:25:15,060 --> 00:25:20,730
notify then then we will assert that the

00:25:19,050 --> 00:25:24,870
message mailer did in fact get called

00:25:20,730 --> 00:25:27,090
with the message and only the users that

00:25:24,870 --> 00:25:30,410
it's supposed to that they that the

00:25:27,090 --> 00:25:32,820
email channel is supposed to notify so

00:25:30,410 --> 00:25:34,560
yeah that's a lot cleaner than the first

00:25:32,820 --> 00:25:36,440
example you'll notice something that

00:25:34,560 --> 00:25:39,510
we're depending upon warps more

00:25:36,440 --> 00:25:41,070
concretion here there's more details so

00:25:39,510 --> 00:25:42,840
we're building real in this case I

00:25:41,070 --> 00:25:45,000
decided to build real user objects with

00:25:42,840 --> 00:25:46,830
factory girl instead of using mocks and

00:25:45,000 --> 00:25:48,750
we stubbed out the message mailer

00:25:46,830 --> 00:25:51,410
instead of injecting a mailer like a

00:25:48,750 --> 00:25:54,120
generic mailer into our email channel

00:25:51,410 --> 00:25:56,730
which we could have done but why are we

00:25:54,120 --> 00:25:59,250
using concretions here well it's because

00:25:56,730 --> 00:26:00,630
we're listening to our tests it's this

00:25:59,250 --> 00:26:02,610
was easy to test there wasn't a lot of

00:26:00,630 --> 00:26:04,650
pain and putting the stuff together it

00:26:02,610 --> 00:26:07,740
was easy to use real objects it's not

00:26:04,650 --> 00:26:10,230
hitting the database so it's fast using

00:26:07,740 --> 00:26:11,640
mocks would not simplify this test and

00:26:10,230 --> 00:26:13,890
another layer of abstraction wouldn't

00:26:11,640 --> 00:26:16,560
help anything so that's the signal that

00:26:13,890 --> 00:26:19,250
we use to determine when we can lay down

00:26:16,560 --> 00:26:21,440
our concretions

00:26:19,250 --> 00:26:23,240
these details is concretion they have to

00:26:21,440 --> 00:26:25,310
end up somewhere right i mean we can't

00:26:23,240 --> 00:26:28,370
always be something has to talk to the

00:26:25,310 --> 00:26:30,260
file system of the network somewhere and

00:26:28,370 --> 00:26:32,120
so if we take this approach of differing

00:26:30,260 --> 00:26:34,880
responsibilities and assuming good

00:26:32,120 --> 00:26:37,060
abstractions we end up with small

00:26:34,880 --> 00:26:39,410
classes that contain some concretions

00:26:37,060 --> 00:26:40,970
but only ones that are relevant to the

00:26:39,410 --> 00:26:46,310
class and that's another word for that

00:26:40,970 --> 00:26:47,360
is cohesion right okay so let's in that

00:26:46,310 --> 00:26:50,300
vein let's take a look at where the

00:26:47,360 --> 00:26:53,120
details are in both of these cases in

00:26:50,300 --> 00:26:54,770
our first attempt or the first version

00:26:53,120 --> 00:26:57,080
of the code that we got most of the

00:26:54,770 --> 00:26:59,360
details were in the notifier class I

00:26:57,080 --> 00:27:01,010
just listed them out here really only

00:26:59,360 --> 00:27:03,830
thing to see is the number of them in

00:27:01,010 --> 00:27:06,290
our second attempt like once we went and

00:27:03,830 --> 00:27:10,210
redid it the details get spread out

00:27:06,290 --> 00:27:12,860
among a bunch of small classes they have

00:27:10,210 --> 00:27:15,620
one responsibility and very few details

00:27:12,860 --> 00:27:21,530
and each of these small classes is

00:27:15,620 --> 00:27:24,410
really easy to test so before I finish

00:27:21,530 --> 00:27:26,990
up I just want to say a few things the

00:27:24,410 --> 00:27:29,750
code that I'm criticizing here is code

00:27:26,990 --> 00:27:31,250
that I wrote and it's in a style that

00:27:29,750 --> 00:27:33,950
I've written test for a long time and

00:27:31,250 --> 00:27:35,810
sometimes still do if your tests look

00:27:33,950 --> 00:27:37,850
like those the ones of those criticizing

00:27:35,810 --> 00:27:43,910
that's awesome because you have tests

00:27:37,850 --> 00:27:45,080
and you're way ahead if you don't have

00:27:43,910 --> 00:27:47,030
tests and you start writing them and

00:27:45,080 --> 00:27:49,750
they look like that that's awesome

00:27:47,030 --> 00:27:54,980
because now you have tests right and

00:27:49,750 --> 00:27:58,480
testing is testing is hard so I think

00:27:54,980 --> 00:28:02,960
that any amount of testing is laudable

00:27:58,480 --> 00:28:05,960
so to close use TDD write your tests

00:28:02,960 --> 00:28:09,230
first but that's not enough and your

00:28:05,960 --> 00:28:10,910
tests assume good abstractions defer

00:28:09,230 --> 00:28:13,340
responsibilities into other classes if

00:28:10,910 --> 00:28:15,010
you do that you'll end up with small

00:28:13,340 --> 00:28:17,180
classes that are easy to test

00:28:15,010 --> 00:28:19,850
abstractions that are easy to understand

00:28:17,180 --> 00:28:24,520
and manage and an application that's

00:28:19,850 --> 00:28:27,520
easy to change and that is solid code

00:28:24,520 --> 00:28:27,520

YouTube URL: https://www.youtube.com/watch?v=FidRcixHQos


