Title: Rocky Mountain Ruby 2013 Ruby Systems Programming by Andy Delcambre
Publication date: 2020-01-27
Playlist: Rocky Mountain Ruby 2013
Description: 
	We as rubyists tend to write software that runs on the web, without a deep understanding of what it would take to write the plumbing for that same software. I think it's useful to have a basic understanding of how some of the lower level components of a system work.

I'll discuss the basics of systems programming, using Ruby. I'll talk about syscalls and kernel space vs user space. I'll cover a bit about file descriptors and what they're for. And hopefully I'll walk through a small example of a working webserver using those primitive syscalls.

Help us caption & translate this video!

http://amara.org/v/FG7N/
Captions: 
	00:00:29,420 --> 00:00:35,579
cool so like I said I'm talking about

00:00:33,780 --> 00:00:38,370
systems programming in Ruby my name is

00:00:35,579 --> 00:00:40,320
Andy telkom I go buy a dell com on the

00:00:38,370 --> 00:00:45,030
internet my last name is not phonetic at

00:00:40,320 --> 00:00:48,360
all no one ever gets it right I work at

00:00:45,030 --> 00:00:50,489
github and I work mostly on some more

00:00:48,360 --> 00:00:51,600
back end things so things dealing with

00:00:50,489 --> 00:00:53,610
the system stuff I kind of work from

00:00:51,600 --> 00:00:56,280
basically the bottom of the rails app to

00:00:53,610 --> 00:00:57,750
the top of the gate layer we have an RPC

00:00:56,280 --> 00:00:59,100
system that gets the data from the file

00:00:57,750 --> 00:01:00,030
servers to the front ends if you want to

00:00:59,100 --> 00:01:01,079
talk about any of that stuff I would

00:01:00,030 --> 00:01:08,159
love to talk about it it's fascinating

00:01:01,079 --> 00:01:10,799
to me so the title this talk is a ruby

00:01:08,159 --> 00:01:11,909
systems programming and that sort of

00:01:10,799 --> 00:01:14,369
implies that what I'm going to try and

00:01:11,909 --> 00:01:16,109
teach you is like how to write systems

00:01:14,369 --> 00:01:17,429
code and like write these sort of little

00:01:16,109 --> 00:01:19,409
things and that's not really the point

00:01:17,429 --> 00:01:22,950
at all the point is much more about

00:01:19,409 --> 00:01:25,229
learning how these lower level building

00:01:22,950 --> 00:01:27,359
blocks work in the apps that we write

00:01:25,229 --> 00:01:29,189
every day but the things that we don't

00:01:27,359 --> 00:01:30,179
actually do like the things that we

00:01:29,189 --> 00:01:31,560
don't actually write the things that are

00:01:30,179 --> 00:01:35,609
kind of underneath the layer that we

00:01:31,560 --> 00:01:37,289
work at so that said kind of like to

00:01:35,609 --> 00:01:39,630
define what systems programming is and

00:01:37,289 --> 00:01:42,689
what system software is this is a quote

00:01:39,630 --> 00:01:45,179
from Wikipedia it says operating control

00:01:42,689 --> 00:01:46,799
the computer hardware and to provide a

00:01:45,179 --> 00:01:48,509
platform for running application

00:01:46,799 --> 00:01:49,979
software and I really like this quote is

00:01:48,509 --> 00:01:50,549
it kind of breaks it into two pieces so

00:01:49,979 --> 00:01:52,529
we're too when we're talking about

00:01:50,549 --> 00:01:53,909
system software first we're interacting

00:01:52,529 --> 00:01:55,319
with the hardware directly so we're

00:01:53,909 --> 00:01:56,340
writing very low level code we're

00:01:55,319 --> 00:01:57,989
probably interacting with the colonel

00:01:56,340 --> 00:01:59,939
and on the other hand we're petting a

00:01:57,989 --> 00:02:02,009
platform for any other software other

00:01:59,939 --> 00:02:03,450
applications software so this means is

00:02:02,009 --> 00:02:05,539
that this none of the code that we write

00:02:03,450 --> 00:02:08,340
if we're writing system software is

00:02:05,539 --> 00:02:10,649
probably going to be user-facing it's

00:02:08,340 --> 00:02:12,640
mostly going to be software that other

00:02:10,649 --> 00:02:15,440
software is gonna be running on top of

00:02:12,640 --> 00:02:16,700
so the other piece here is that we're

00:02:15,440 --> 00:02:17,720
running application software on top of

00:02:16,700 --> 00:02:21,170
this which is sort of the everything

00:02:17,720 --> 00:02:24,380
else category and there's a lot here so

00:02:21,170 --> 00:02:26,150
this could be video games iphone apps

00:02:24,380 --> 00:02:28,790
something that runs on your set-top box

00:02:26,150 --> 00:02:30,620
but for this crowd and for me because

00:02:28,790 --> 00:02:33,940
this is what I know I'm gonna start sort

00:02:30,620 --> 00:02:37,340
of narrow the scope down to web software

00:02:33,940 --> 00:02:39,320
so we have this large set of building

00:02:37,340 --> 00:02:41,210
blocks that runs underneath the rails

00:02:39,320 --> 00:02:44,510
apps that we write the Ruby apps that we

00:02:41,210 --> 00:02:45,740
rain and these are kind of pieces that

00:02:44,510 --> 00:02:47,510
we don't think about a lot when writing

00:02:45,740 --> 00:02:49,190
just in rails and writing actions and

00:02:47,510 --> 00:02:50,030
controllers and things like that we're

00:02:49,190 --> 00:02:52,760
going to start all the way at the bottom

00:02:50,030 --> 00:02:54,110
and work our way up the stack we're

00:02:52,760 --> 00:02:56,030
gonna start all with the colonel so just

00:02:54,110 --> 00:02:58,100
above the hardware talk a little bit

00:02:56,030 --> 00:03:00,350
about system calls and how we interact

00:02:58,100 --> 00:03:01,490
with Colonel how we just deal with

00:03:00,350 --> 00:03:03,650
anything that looks like a file which is

00:03:01,490 --> 00:03:05,570
most things in UNIX file descriptors

00:03:03,650 --> 00:03:07,520
talk a little bit about sockets how we

00:03:05,570 --> 00:03:10,970
do network programming the protocol we

00:03:07,520 --> 00:03:12,080
can write for web software hdb and I'll

00:03:10,970 --> 00:03:16,460
show you a little demo at the end

00:03:12,080 --> 00:03:17,510
hopefully this code should are there

00:03:16,460 --> 00:03:19,400
anything that I talked about here should

00:03:17,510 --> 00:03:22,190
apply generally to any unix system

00:03:19,400 --> 00:03:24,290
there's pretty much not a lot of overlap

00:03:22,190 --> 00:03:26,330
with Windows here or other non UNIX

00:03:24,290 --> 00:03:28,490
systems but anything specific that I

00:03:26,330 --> 00:03:31,460
talked about is specifically linux and

00:03:28,490 --> 00:03:32,990
linux x86 this code is generally low

00:03:31,460 --> 00:03:34,100
enough level that the platform you're

00:03:32,990 --> 00:03:37,100
running on and even the hardware you're

00:03:34,100 --> 00:03:38,510
running on actually matters a lot that

00:03:37,100 --> 00:03:40,550
said my the demo on the show actually

00:03:38,510 --> 00:03:45,770
runs on my Mac too so it's not not

00:03:40,550 --> 00:03:48,470
solely Linux so at the beginning we have

00:03:45,770 --> 00:03:50,330
the colonel and the colonel basically is

00:03:48,470 --> 00:03:51,710
the thing that runs directly above the

00:03:50,330 --> 00:03:54,710
hardware this is the piece that controls

00:03:51,710 --> 00:03:56,930
all the stuff on your system so

00:03:54,710 --> 00:03:59,540
generally this is what a computer looks

00:03:56,930 --> 00:04:02,420
like if the hardware down here this is

00:03:59,540 --> 00:04:05,450
like you know memory and and maybe hard

00:04:02,420 --> 00:04:07,160
disks and graphics drivers sound card

00:04:05,450 --> 00:04:09,560
things like that that'll lives down here

00:04:07,160 --> 00:04:11,840
but doesn't do anything and above that

00:04:09,560 --> 00:04:13,220
you have your code which runs which is

00:04:11,840 --> 00:04:15,290
sort of like everything you think of as

00:04:13,220 --> 00:04:16,790
software so any application you write

00:04:15,290 --> 00:04:19,250
anything that you run anything you see

00:04:16,790 --> 00:04:20,660
all runs sort of up in that green box

00:04:19,250 --> 00:04:22,700
and in the middle here you have the

00:04:20,660 --> 00:04:23,530
kernel which is the mediator between the

00:04:22,700 --> 00:04:25,480
code

00:04:23,530 --> 00:04:27,520
that we think of as software and the

00:04:25,480 --> 00:04:32,139
hardware and it handles sort of

00:04:27,520 --> 00:04:34,150
everything right so I don't know okay it

00:04:32,139 --> 00:04:35,860
handles all of the interactions with the

00:04:34,150 --> 00:04:39,970
hardware but it also manages all of

00:04:35,860 --> 00:04:42,010
those processes that run up there so in

00:04:39,970 --> 00:04:44,230
that green box at the top where your

00:04:42,010 --> 00:04:46,600
code runs we call this user mode and

00:04:44,230 --> 00:04:48,250
this is actually implemented in the CPU

00:04:46,600 --> 00:04:49,480
like the difference between what runs in

00:04:48,250 --> 00:04:52,270
kernel mode and what runs in user mode

00:04:49,480 --> 00:04:53,710
and if you're just sticking in user mode

00:04:52,270 --> 00:04:55,930
if you're just running the coding user

00:04:53,710 --> 00:04:57,669
mode there's very little you can do I

00:04:55,930 --> 00:05:00,040
kind of break it down into two things

00:04:57,669 --> 00:05:01,630
first like what I call math which is

00:05:00,040 --> 00:05:03,820
basically any like thing you're just

00:05:01,630 --> 00:05:06,610
modifying locally you have a couple of

00:05:03,820 --> 00:05:07,419
things maybe pieces of data maybe their

00:05:06,610 --> 00:05:10,660
numbers maybe you're doing arithmetic

00:05:07,419 --> 00:05:13,000
but maybe it's also like two strings and

00:05:10,660 --> 00:05:14,979
you're joining strings together or maybe

00:05:13,000 --> 00:05:17,080
something lower level like crypto or I

00:05:14,979 --> 00:05:19,720
don't know any any number of things like

00:05:17,080 --> 00:05:21,490
that but it's all with data that you

00:05:19,720 --> 00:05:23,139
already have and you're basically

00:05:21,490 --> 00:05:25,690
performing operations on it so you can't

00:05:23,139 --> 00:05:27,970
get any new data in and the second thing

00:05:25,690 --> 00:05:29,140
you can do is you can access memory but

00:05:27,970 --> 00:05:32,050
this is only memory that you've already

00:05:29,140 --> 00:05:33,940
been given by the colonel so with that

00:05:32,050 --> 00:05:35,110
sort of first category when you're doing

00:05:33,940 --> 00:05:36,610
arithmetic and things like that so you

00:05:35,110 --> 00:05:38,169
can store the results and you can move

00:05:36,610 --> 00:05:40,330
stuff around you still aren't getting

00:05:38,169 --> 00:05:43,300
anything new in your not puttin anything

00:05:40,330 --> 00:05:47,020
out from this system you're very stuck

00:05:43,300 --> 00:05:50,050
in this box so what's not here it's like

00:05:47,020 --> 00:05:52,510
anything I oh like I just said any file

00:05:50,050 --> 00:05:55,690
access or anything to the screen Network

00:05:52,510 --> 00:05:58,720
anything like that at all so on the

00:05:55,690 --> 00:06:01,930
other hand things on the colonel this is

00:05:58,720 --> 00:06:03,789
running a kernel mode and the colonel on

00:06:01,930 --> 00:06:08,229
a computer can literally do anything and

00:06:03,789 --> 00:06:09,580
everything there's nothing it can't do

00:06:08,229 --> 00:06:10,720
it can access any memory on the system

00:06:09,580 --> 00:06:13,180
it can write read & write to any

00:06:10,720 --> 00:06:14,830
hardware in the system it can modify any

00:06:13,180 --> 00:06:18,220
program it can control what programs

00:06:14,830 --> 00:06:20,590
were unwin but you don't get to run code

00:06:18,220 --> 00:06:23,350
here right this is not your land you're

00:06:20,590 --> 00:06:26,710
running still back in user mode so how

00:06:23,350 --> 00:06:29,010
do we do all of these things that kernel

00:06:26,710 --> 00:06:32,950
mode can do but we can't do in user mode

00:06:29,010 --> 00:06:34,479
so we use the system call API system

00:06:32,950 --> 00:06:36,880
calls are how we basically make those

00:06:34,479 --> 00:06:38,470
calls and make modifications

00:06:36,880 --> 00:06:41,430
to the system that can only happen in

00:06:38,470 --> 00:06:43,480
kernel mode so we have a computer again

00:06:41,430 --> 00:06:45,610
we're running up in user mode there

00:06:43,480 --> 00:06:46,840
you're down in kernel mode here and you

00:06:45,610 --> 00:06:49,120
might sort of think that the way this

00:06:46,840 --> 00:06:50,680
works is because we know now that in

00:06:49,120 --> 00:06:52,930
user mode you can't do very much and in

00:06:50,680 --> 00:06:54,550
kernel mode you can do things like right

00:06:52,930 --> 00:06:55,990
to files so you might imagine that what

00:06:54,550 --> 00:06:57,550
you do is you like chug along and user

00:06:55,990 --> 00:06:59,050
mode and you and you get to a spot where

00:06:57,550 --> 00:07:00,190
you want to like write to a log file and

00:06:59,050 --> 00:07:02,020
so you switch over to kernel mode and

00:07:00,190 --> 00:07:03,250
write a couple of lines of code to write

00:07:02,020 --> 00:07:04,480
out to a file and you switch back in

00:07:03,250 --> 00:07:07,870
user mode and that's not how this works

00:07:04,480 --> 00:07:10,270
at all so we use system calls and we

00:07:07,870 --> 00:07:11,830
actually basically stop execution of our

00:07:10,270 --> 00:07:14,380
program and we ask the colonel to do

00:07:11,830 --> 00:07:15,700
something on our behalf and it does

00:07:14,380 --> 00:07:19,720
something like write a file or open a

00:07:15,700 --> 00:07:21,850
file it returns back to us and we kind

00:07:19,720 --> 00:07:23,170
of keep going on our merry way but we

00:07:21,850 --> 00:07:28,650
don't ever actually get to run code in

00:07:23,170 --> 00:07:30,820
kernel mode so you can see all of the

00:07:28,650 --> 00:07:32,830
system calls that your program is

00:07:30,820 --> 00:07:34,390
executing with an s trace command this

00:07:32,830 --> 00:07:36,730
is the unix version there's also d trust

00:07:34,390 --> 00:07:38,860
on mac if you're a linux like this is

00:07:36,730 --> 00:07:40,930
linux d truss on mac which uses a DTrace

00:07:38,860 --> 00:07:42,460
api I think there's probably similar

00:07:40,930 --> 00:07:43,840
ones for other UNIX to be operating

00:07:42,460 --> 00:07:46,780
systems I have no idea how to do this in

00:07:43,840 --> 00:07:48,760
Windows but you can basically take any

00:07:46,780 --> 00:07:50,500
process on your computer and see what

00:07:48,760 --> 00:07:52,720
system calls its making and there's

00:07:50,500 --> 00:07:54,700
probably going to be a lot of them so I

00:07:52,720 --> 00:07:58,450
did this just with one request locally

00:07:54,700 --> 00:08:00,880
with one of the apps at github you can

00:07:58,450 --> 00:08:01,930
see it go by these are all system calls

00:08:00,880 --> 00:08:03,430
see these are all the system calls it

00:08:01,930 --> 00:08:04,540
happens for one request locally this is

00:08:03,430 --> 00:08:07,420
until 11 mode so it would be a little

00:08:04,540 --> 00:08:08,890
bit less in production but there's a lot

00:08:07,420 --> 00:08:13,300
of stuff here and some of its really

00:08:08,890 --> 00:08:14,440
esoteric like get sig proc mask and sig

00:08:13,300 --> 00:08:15,700
halt stack and things like that these

00:08:14,440 --> 00:08:18,130
are I don't really know what they do

00:08:15,700 --> 00:08:19,540
there there's some esoterica in system

00:08:18,130 --> 00:08:20,590
calls but there's someone's here that

00:08:19,540 --> 00:08:23,440
sort of makes sense right so we have

00:08:20,590 --> 00:08:28,750
clothes there's an except we have a send

00:08:23,440 --> 00:08:30,190
to a few other things there so this is

00:08:28,750 --> 00:08:32,500
basically how everything gets done in

00:08:30,190 --> 00:08:34,960
your web request this updates much

00:08:32,500 --> 00:08:36,820
faster that we get many more calls than

00:08:34,960 --> 00:08:38,620
the frame rate of this video so in that

00:08:36,820 --> 00:08:43,000
request there was actually 120,000

00:08:38,620 --> 00:08:45,850
syscalls for one request so you might

00:08:43,000 --> 00:08:47,410
imagine that because we can't do

00:08:45,850 --> 00:08:50,230
anything without using this calls and

00:08:47,410 --> 00:08:51,490
because we do 120,000

00:08:50,230 --> 00:08:53,380
as calls in one request just to do

00:08:51,490 --> 00:08:55,060
anything at all that this API would be

00:08:53,380 --> 00:08:57,250
very large there would be lots and lots

00:08:55,060 --> 00:09:00,550
of things you have to do there no to be

00:08:57,250 --> 00:09:03,580
able to to do this and it's really

00:09:00,550 --> 00:09:05,830
actually small this is the entirety of

00:09:03,580 --> 00:09:08,050
this fiscal table in Linux there's 326

00:09:05,830 --> 00:09:09,340
possible things you can call this is in

00:09:08,050 --> 00:09:10,750
the kernel if it is not in this table

00:09:09,340 --> 00:09:13,870
you cannot call it it won't know to do

00:09:10,750 --> 00:09:18,490
with it so the API boundary is really

00:09:13,870 --> 00:09:20,410
small to make an actual assist call this

00:09:18,490 --> 00:09:22,510
is how we do this this is actually the

00:09:20,410 --> 00:09:24,160
assembly for this this is the open sis

00:09:22,510 --> 00:09:26,860
call every sis column that says call

00:09:24,160 --> 00:09:28,510
table is has a number associated with it

00:09:26,860 --> 00:09:30,400
which is why that that's the skull table

00:09:28,510 --> 00:09:35,560
exists so open happens to be cisco

00:09:30,400 --> 00:09:37,930
number 5 so we move 5 in TX the args to

00:09:35,560 --> 00:09:40,000
this is called going to the additional

00:09:37,930 --> 00:09:42,040
registers exe bx + e CX of registers

00:09:40,000 --> 00:09:43,870
here if you have more than like five or

00:09:42,040 --> 00:09:45,910
so arguments the method is different but

00:09:43,870 --> 00:09:47,010
that almost never happens mostest calls

00:09:45,910 --> 00:09:49,480
take a very small number of organized

00:09:47,010 --> 00:09:52,390
down here we trigger this interrupt so

00:09:49,480 --> 00:09:54,490
this is the interrupt assembly call and

00:09:52,390 --> 00:09:57,700
we're triggering the ad and hex assist

00:09:54,490 --> 00:10:00,640
call this is the i386 software interrupt

00:09:57,700 --> 00:10:03,580
this transfers execution to the colonel

00:10:00,640 --> 00:10:05,170
the interrupt handler fires it looks up

00:10:03,580 --> 00:10:09,220
which interrupt handler or which handler

00:10:05,170 --> 00:10:10,690
should handle the ATX interrupt which is

00:10:09,220 --> 00:10:12,400
happens to be the cisco handler and this

00:10:10,690 --> 00:10:13,840
is call handler then looks up the eax

00:10:12,400 --> 00:10:15,940
register finds out we're doing open

00:10:13,840 --> 00:10:17,710
execute the open code and returns code

00:10:15,940 --> 00:10:19,570
back to you but this actually stops

00:10:17,710 --> 00:10:21,430
execution of your program and starts

00:10:19,570 --> 00:10:23,200
execution in the kernel you you were no

00:10:21,430 --> 00:10:25,210
longer executing your code after that

00:10:23,200 --> 00:10:27,190
interrupt happens so you can see there's

00:10:25,210 --> 00:10:28,900
you're not there's no code that you're

00:10:27,190 --> 00:10:29,890
running no even assembly code that

00:10:28,900 --> 00:10:33,750
you're running that actually happens in

00:10:29,890 --> 00:10:35,740
kernel mode think that's kind of cool so

00:10:33,750 --> 00:10:38,500
this is kind of also another just fun

00:10:35,740 --> 00:10:40,510
fact but of that syscall table um there

00:10:38,500 --> 00:10:42,220
it's one basically big array and that

00:10:40,510 --> 00:10:44,560
it's like a look up into it those

00:10:42,220 --> 00:10:48,670
numbers so there can't be blank spots in

00:10:44,560 --> 00:10:50,910
that table so if there's like a sis call

00:10:48,670 --> 00:10:53,140
that only happens on one architecture or

00:10:50,910 --> 00:10:54,550
there's one that has been deprecated and

00:10:53,140 --> 00:10:56,890
isn't used anymore or there's one

00:10:54,550 --> 00:11:01,330
reserved for future use they can't they

00:10:56,890 --> 00:11:02,860
still have to be there so of those 396

00:11:01,330 --> 00:11:03,680
in the fiscal table 65 of them are

00:11:02,860 --> 00:11:05,690
defined as the sis

00:11:03,680 --> 00:11:08,089
in Isis call and that in my stance were

00:11:05,690 --> 00:11:09,470
not implemented so 65 of the SIS calls

00:11:08,089 --> 00:11:10,850
the I was talking about earlier don't

00:11:09,470 --> 00:11:12,440
even do anything you don't even use them

00:11:10,850 --> 00:11:14,899
so we're down to like two hundred and 60

00:11:12,440 --> 00:11:17,860
some-odd total syscalls that you can

00:11:14,899 --> 00:11:21,020
call and linux windows on the other hand

00:11:17,860 --> 00:11:22,580
there's some say thousands we don't have

00:11:21,020 --> 00:11:24,950
the codes we can't look and count them

00:11:22,580 --> 00:11:26,839
but nobody really knows exactly how many

00:11:24,950 --> 00:11:28,040
there are but there's many many more

00:11:26,839 --> 00:11:30,230
than Linux and I think it's kind of cool

00:11:28,040 --> 00:11:32,420
that in UNIX land in the linux land we

00:11:30,230 --> 00:11:34,430
we have such a small API boundary that

00:11:32,420 --> 00:11:36,200
we have to understand and windows it's

00:11:34,430 --> 00:11:42,130
much larger even though we have the same

00:11:36,200 --> 00:11:45,290
total power so with these discs calls

00:11:42,130 --> 00:11:46,640
there's a ways like we need to be able

00:11:45,290 --> 00:11:49,940
to talk about the things that happen in

00:11:46,640 --> 00:11:51,410
the kernel and in many cases what we're

00:11:49,940 --> 00:11:54,230
talking about actually looks like a file

00:11:51,410 --> 00:11:56,959
to the to the colonel linux describes

00:11:54,230 --> 00:12:00,410
sort of everything as a file we have

00:11:56,959 --> 00:12:02,540
this isn't sort of fact i guess that

00:12:00,410 --> 00:12:04,940
people say truism everything is file

00:12:02,540 --> 00:12:05,930
which is not quite literally true there

00:12:04,940 --> 00:12:07,820
are other operating systems that take

00:12:05,930 --> 00:12:09,650
this much farther than linux does but in

00:12:07,820 --> 00:12:13,339
general for most cases that we talk

00:12:09,650 --> 00:12:14,209
about everything is a file so we have a

00:12:13,339 --> 00:12:17,890
list of things that are files

00:12:14,209 --> 00:12:20,120
non-exhaustive cludes files but also a

00:12:17,890 --> 00:12:22,070
bunch of other stuff that don't really

00:12:20,120 --> 00:12:24,709
seem like files like printers and hard

00:12:22,070 --> 00:12:26,630
drives and maybe pipes for doing that

00:12:24,709 --> 00:12:30,230
interprocess communication shared memory

00:12:26,630 --> 00:12:33,050
graphics cards the terminal that you

00:12:30,230 --> 00:12:35,300
type into and also sockets which is how

00:12:33,050 --> 00:12:36,800
we do network programming tried a little

00:12:35,300 --> 00:12:40,250
bit more about that in a couple of

00:12:36,800 --> 00:12:42,440
minutes so with this file API are with

00:12:40,250 --> 00:12:44,930
with these file descriptors when you

00:12:42,440 --> 00:12:47,000
have any of these things once you've got

00:12:44,930 --> 00:12:48,950
them and you're talking about them with

00:12:47,000 --> 00:12:51,079
sis calls you use these file descriptors

00:12:48,950 --> 00:12:53,480
and the api that you can use to just to

00:12:51,079 --> 00:12:55,610
talk to them is really really small so

00:12:53,480 --> 00:12:58,610
all four of these assists calls or how

00:12:55,610 --> 00:12:59,750
you basically write and read from file

00:12:58,610 --> 00:13:01,790
descriptors or anything that looks like

00:12:59,750 --> 00:13:03,350
a file all of these take the file

00:13:01,790 --> 00:13:05,110
descriptor numbers that you get handed

00:13:03,350 --> 00:13:07,459
when you open any of those things and

00:13:05,110 --> 00:13:10,040
this is pretty much it there's there's

00:13:07,459 --> 00:13:12,860
probably more that take file descriptors

00:13:10,040 --> 00:13:14,630
but this is most of the the api so you

00:13:12,860 --> 00:13:16,459
can read from the files you can write to

00:13:14,630 --> 00:13:16,700
the files and you can close them so you

00:13:16,459 --> 00:13:18,500
know how

00:13:16,700 --> 00:13:21,080
access to them anymore and the L sequin

00:13:18,500 --> 00:13:22,400
is a little bit special so file

00:13:21,080 --> 00:13:24,380
descriptors are kind of defined to have

00:13:22,400 --> 00:13:26,240
a type so some are like block types like

00:13:24,380 --> 00:13:27,860
files like you have a list of blocks

00:13:26,240 --> 00:13:28,940
that you can read from so you can seek

00:13:27,860 --> 00:13:29,930
around in it so you can say like I want

00:13:28,940 --> 00:13:31,340
to go back to the beginning or go to the

00:13:29,930 --> 00:13:32,630
end but if you're reading a stream of

00:13:31,340 --> 00:13:35,810
bytes off the network you obviously

00:13:32,630 --> 00:13:37,100
can't rewind that stream so that also is

00:13:35,810 --> 00:13:43,840
part of the file API but it doesn't work

00:13:37,100 --> 00:13:45,830
in stream tile type files so this is a

00:13:43,840 --> 00:13:48,080
so there's a couple of initiative mix

00:13:45,830 --> 00:13:51,070
here actually so this is all the file

00:13:48,080 --> 00:13:55,160
descriptors that are open for one

00:13:51,070 --> 00:13:57,860
unicorn on production at github there's

00:13:55,160 --> 00:13:59,510
one thing here so this is the you notice

00:13:57,860 --> 00:14:02,480
but I'm getting this is I melu Singh

00:13:59,510 --> 00:14:05,540
this proc file system does / proc / PID

00:14:02,480 --> 00:14:06,530
/f D this is just the directory with all

00:14:05,540 --> 00:14:09,230
of the file descriptors that this

00:14:06,530 --> 00:14:10,550
process has open so this is kind of is

00:14:09,230 --> 00:14:12,440
also part of that everything as a file

00:14:10,550 --> 00:14:14,210
thing this is how you get information

00:14:12,440 --> 00:14:15,860
from the colonel about processes that

00:14:14,210 --> 00:14:17,270
are running if you are ever on a Linux

00:14:15,860 --> 00:14:18,500
system go explore the proc file system

00:14:17,270 --> 00:14:23,720
is really cold at all kinds of stuff in

00:14:18,500 --> 00:14:25,250
there so second we have three file

00:14:23,720 --> 00:14:27,500
descriptors that are pretty much on

00:14:25,250 --> 00:14:28,940
every single process that you ever have

00:14:27,500 --> 00:14:31,190
and let's they've been closed and that's

00:14:28,940 --> 00:14:33,440
zero one and two the first three over

00:14:31,190 --> 00:14:35,330
there so 0 is standard in one is

00:14:33,440 --> 00:14:37,220
standard out into a standard error every

00:14:35,330 --> 00:14:38,630
process by default when you start it has

00:14:37,220 --> 00:14:41,210
these three file descriptors open and

00:14:38,630 --> 00:14:43,310
they're pointed to those things this is

00:14:41,210 --> 00:14:45,260
a unicorn so we have redirected those to

00:14:43,310 --> 00:14:46,580
certain things standard in comes from

00:14:45,260 --> 00:14:48,410
Deb null because this is a server

00:14:46,580 --> 00:14:49,850
there's no standard end that's happening

00:14:48,410 --> 00:14:51,730
and then standard out and standard error

00:14:49,850 --> 00:14:53,870
are going to this unicorn log file

00:14:51,730 --> 00:14:55,580
there's a couple of other log files here

00:14:53,870 --> 00:14:56,990
number 35 is the pigments log for when

00:14:55,580 --> 00:14:58,460
we do syntax highlighting we have the

00:14:56,990 --> 00:15:00,920
production log for rails over narrow

00:14:58,460 --> 00:15:04,880
number 10 somewhere else there's another

00:15:00,920 --> 00:15:06,170
one anyway but there's a couple of like

00:15:04,880 --> 00:15:08,180
pipes here for doing some probably I'm

00:15:06,170 --> 00:15:10,400
process communication but we have a lot

00:15:08,180 --> 00:15:11,660
of here is these sockets and these

00:15:10,400 --> 00:15:13,520
sockets are for pretty much anything

00:15:11,660 --> 00:15:16,730
that's communicating over the network so

00:15:13,520 --> 00:15:18,680
this could be the socket that we're

00:15:16,730 --> 00:15:21,320
listening on to do the web traffic from

00:15:18,680 --> 00:15:25,160
this unicorn it could be a connection to

00:15:21,320 --> 00:15:27,410
my sequel or Redis or memcached it could

00:15:25,160 --> 00:15:28,430
be a established connection to a client

00:15:27,410 --> 00:15:29,720
that we're actually currently handling

00:15:28,430 --> 00:15:31,939
or crossed for

00:15:29,720 --> 00:15:33,740
and many other things it's probably a

00:15:31,939 --> 00:15:36,170
lot of client connections and then like

00:15:33,740 --> 00:15:38,209
a couple of server-side connections but

00:15:36,170 --> 00:15:40,250
this is everything that's happening and

00:15:38,209 --> 00:15:45,860
these are all basically abide by that

00:15:40,250 --> 00:15:47,329
file API so with that file API I talked

00:15:45,860 --> 00:15:50,720
only about how we read to and write from

00:15:47,329 --> 00:15:52,759
them but there's no we don't there's no

00:15:50,720 --> 00:15:54,709
API as part of the file API for creating

00:15:52,759 --> 00:15:57,079
new file descriptors and that's because

00:15:54,709 --> 00:15:58,189
depending on what type of the file what

00:15:57,079 --> 00:15:59,990
type of file descriptor you're getting

00:15:58,189 --> 00:16:02,449
at there's actually different api's for

00:15:59,990 --> 00:16:04,459
all of them so for doing network

00:16:02,449 --> 00:16:06,920
communication the API is called the BSD

00:16:04,459 --> 00:16:09,410
sockets API first a little bit of

00:16:06,920 --> 00:16:12,410
history here this is a very brief

00:16:09,410 --> 00:16:14,300
history of UNIX back in like nineteen

00:16:12,410 --> 00:16:15,529
sixty three or so well in the early

00:16:14,300 --> 00:16:17,060
1960s it lasts of a couple of years

00:16:15,529 --> 00:16:19,339
there was this research operating system

00:16:17,060 --> 00:16:20,480
called multics that was developed at a

00:16:19,339 --> 00:16:23,089
consortium of a bunch of different

00:16:20,480 --> 00:16:25,790
companies including MIT and 18c the labs

00:16:23,089 --> 00:16:28,490
and a few other places and it was trying

00:16:25,790 --> 00:16:31,069
to be it basically was too adventurous

00:16:28,490 --> 00:16:32,720
it did not work it was never used it for

00:16:31,069 --> 00:16:37,069
anything real it only was sort of

00:16:32,720 --> 00:16:38,750
exploring some concepts but it it

00:16:37,069 --> 00:16:40,550
basically failed like it stopped

00:16:38,750 --> 00:16:42,230
happening at some point but a couple of

00:16:40,550 --> 00:16:45,050
the guys ken thompson and dennis ritchie

00:16:42,230 --> 00:16:47,509
that had worked on that went to AT&T

00:16:45,050 --> 00:16:49,189
Bell Labs and started this much smaller

00:16:47,509 --> 00:16:50,779
scoped operating system that they called

00:16:49,189 --> 00:16:53,120
eunuchs which was a play on the multics

00:16:50,779 --> 00:16:55,430
thing so multics was multi-user UNIX was

00:16:53,120 --> 00:17:00,379
originally single user so what the name

00:16:55,430 --> 00:17:02,480
came about and that was about 1970 and I

00:17:00,379 --> 00:17:05,720
find this really interesting but there's

00:17:02,480 --> 00:17:08,780
the history of why unix was available to

00:17:05,720 --> 00:17:10,669
be licensed the source code was due to a

00:17:08,780 --> 00:17:12,140
teensy Bell Labs going through the

00:17:10,669 --> 00:17:14,419
antitrust settlement at that time so

00:17:12,140 --> 00:17:16,159
they were prohibited from selling and

00:17:14,419 --> 00:17:17,980
having the operating system be

00:17:16,159 --> 00:17:20,209
proprietary so they had to give away

00:17:17,980 --> 00:17:22,730
source code licenses to it to us

00:17:20,209 --> 00:17:25,579
specifically universities not entirely

00:17:22,730 --> 00:17:27,439
confident on all the vagaries of why or

00:17:25,579 --> 00:17:29,270
like what would it took to get a license

00:17:27,439 --> 00:17:30,500
back then but definitely universities

00:17:29,270 --> 00:17:36,470
could get licenses to the source code

00:17:30,500 --> 00:17:38,780
for unix which is cool so in 1978 there

00:17:36,470 --> 00:17:41,870
was one there was a guy at UC Berkeley

00:17:38,780 --> 00:17:43,400
in California that took the original

00:17:41,870 --> 00:17:45,170
system five UNIX from

00:17:43,400 --> 00:17:48,230
18c the labs and wanted to port it to

00:17:45,170 --> 00:17:49,850
backs and so he ported the software /

00:17:48,230 --> 00:17:52,070
added a bunch of utilities around it and

00:17:49,850 --> 00:17:54,230
release to this bsd the guy that did

00:17:52,070 --> 00:17:55,760
that his name is bill joy one of the

00:17:54,230 --> 00:17:57,440
things that he added to bsd at that time

00:17:55,760 --> 00:17:59,210
was a little program called VI which you

00:17:57,440 --> 00:18:00,740
might have heard of he's probably more

00:17:59,210 --> 00:18:03,710
famous for but he was also one of the

00:18:00,740 --> 00:18:07,580
guys that originally did bsd five years

00:18:03,710 --> 00:18:08,720
later 1983 bsd 4.2 came out and this was

00:18:07,580 --> 00:18:11,300
right around the time that the original

00:18:08,720 --> 00:18:14,690
standardization for the tcp/ip Stan

00:18:11,300 --> 00:18:16,700
standard was coming out and this was

00:18:14,690 --> 00:18:21,290
basically the first real tcp/ip stack

00:18:16,700 --> 00:18:25,550
that you could use and so in 1983 to

00:18:21,290 --> 00:18:27,830
today about 30 years and the API has

00:18:25,550 --> 00:18:29,420
effectively not changed and this is one

00:18:27,830 --> 00:18:31,340
of the few pieces of like sort of API

00:18:29,420 --> 00:18:33,860
and code that actually got ported to

00:18:31,340 --> 00:18:36,590
windows as well so on windows they also

00:18:33,860 --> 00:18:37,850
have the same bsd sockets API I just

00:18:36,590 --> 00:18:40,160
think it's really cool their work today

00:18:37,850 --> 00:18:42,290
writing code that is using a 30 year old

00:18:40,160 --> 00:18:47,600
API on 40 year old software that was

00:18:42,290 --> 00:18:49,340
started almost 50 years ago this is

00:18:47,600 --> 00:18:51,470
pretty much the entirety of the bsd

00:18:49,340 --> 00:18:53,030
sockets api this is the server side

00:18:51,470 --> 00:18:54,770
portion so if you're connecting from a

00:18:53,030 --> 00:18:56,690
client side you're probably not going to

00:18:54,770 --> 00:18:59,240
use well there's another couple that you

00:18:56,690 --> 00:19:00,500
use but the api is really small and this

00:18:59,240 --> 00:19:02,870
handles pretty much everything that we

00:19:00,500 --> 00:19:04,460
can do i'll go through the Meech in turn

00:19:02,870 --> 00:19:07,370
the first one is suck it this is how you

00:19:04,460 --> 00:19:08,750
create a new bsd socket this is how you

00:19:07,370 --> 00:19:10,910
tell what type of socket you're going to

00:19:08,750 --> 00:19:12,290
have so if we're doing tcpip before that

00:19:10,910 --> 00:19:13,580
would be where you tell it that you

00:19:12,290 --> 00:19:18,290
could also do like unix domain select

00:19:13,580 --> 00:19:20,540
its ipv6 you do UDP or than the tcp bind

00:19:18,290 --> 00:19:22,400
tells the kernel that we want or like

00:19:20,540 --> 00:19:24,410
what address we want to listen on so

00:19:22,400 --> 00:19:25,580
this is where you can tell it what port

00:19:24,410 --> 00:19:28,850
we're coming in on what address were

00:19:25,580 --> 00:19:30,200
listening on on but the socket is still

00:19:28,850 --> 00:19:32,690
not in listening mode it's not ready to

00:19:30,200 --> 00:19:34,130
accept incoming connections listen tells

00:19:32,690 --> 00:19:35,330
the colonel to turn that socket into a

00:19:34,130 --> 00:19:36,410
listening socket so it's actually

00:19:35,330 --> 00:19:39,560
passively waiting for incoming

00:19:36,410 --> 00:19:41,210
connections except we'll take a new

00:19:39,560 --> 00:19:42,200
connection off that socket it'll

00:19:41,210 --> 00:19:43,250
actually block and wait for a new

00:19:42,200 --> 00:19:44,960
connection to come in once a new

00:19:43,250 --> 00:19:47,030
connection comes in it returns that

00:19:44,960 --> 00:19:49,220
another new socket which is also a file

00:19:47,030 --> 00:19:54,269
descriptor that references that one

00:19:49,220 --> 00:19:56,940
client directly then once we have that

00:19:54,269 --> 00:19:58,830
clients Luckett from the from the except

00:19:56,940 --> 00:20:00,389
call then all we have is a file

00:19:58,830 --> 00:20:02,099
descriptor and we can use the exact same

00:20:00,389 --> 00:20:04,799
thing we were talking about earlier with

00:20:02,099 --> 00:20:07,979
the file API to read read from it right

00:20:04,799 --> 00:20:10,499
to it and close it when we're done so

00:20:07,979 --> 00:20:12,119
this API is about how we basically

00:20:10,499 --> 00:20:13,169
establish connections but it doesn't

00:20:12,119 --> 00:20:14,249
care what data we're talking about on

00:20:13,169 --> 00:20:17,279
top of it that's sort of the next level

00:20:14,249 --> 00:20:18,959
up so just a little brief overview of

00:20:17,279 --> 00:20:22,859
HTTP most of you have probably seen this

00:20:18,959 --> 00:20:25,049
before try and go pretty fast but htp is

00:20:22,859 --> 00:20:27,509
basically a request response so in that

00:20:25,049 --> 00:20:29,639
sort of session we're going to accept a

00:20:27,509 --> 00:20:31,649
connection read the request from it

00:20:29,639 --> 00:20:33,299
generate a response like process

00:20:31,649 --> 00:20:35,159
something send a response back over the

00:20:33,299 --> 00:20:36,450
wire and close the connection you can

00:20:35,159 --> 00:20:40,429
keep connections open but it's that's

00:20:36,450 --> 00:20:44,849
kind of like a specific version of HTTP

00:20:40,429 --> 00:20:46,919
so this is a generic HTTP request the

00:20:44,849 --> 00:20:49,139
first line is important there that's

00:20:46,919 --> 00:20:50,459
always the same always starts with the

00:20:49,139 --> 00:20:51,659
HTTP verb that we're talking about so in

00:20:50,459 --> 00:20:53,669
this case it's a get request but it

00:20:51,659 --> 00:20:56,940
could be a post up put a delete head

00:20:53,669 --> 00:21:00,119
options and on down the second parameter

00:20:56,940 --> 00:21:02,009
there is the path which is basically

00:21:00,119 --> 00:21:03,989
everything after the domain name in the

00:21:02,009 --> 00:21:06,479
URL when you look at it if there was

00:21:03,989 --> 00:21:07,919
params that would be here as well all in

00:21:06,479 --> 00:21:09,479
that same thing and then we have the

00:21:07,919 --> 00:21:12,269
HTTP version we're using this is HTTP

00:21:09,479 --> 00:21:14,759
1.1 the next three there are headers

00:21:12,269 --> 00:21:16,049
that we're sending so we can send any

00:21:14,759 --> 00:21:17,759
number of headers these are relatively

00:21:16,049 --> 00:21:20,429
arbitrary you can send more headers than

00:21:17,759 --> 00:21:22,019
this if you want this was a curled I did

00:21:20,429 --> 00:21:24,629
against Google and we're accepting any

00:21:22,019 --> 00:21:26,789
content type back if this was a post and

00:21:24,629 --> 00:21:28,349
we wanted to send a request body as well

00:21:26,789 --> 00:21:29,579
there would be one blank new wine and

00:21:28,349 --> 00:21:31,019
then the whole rip was funny that would

00:21:29,579 --> 00:21:32,309
you like foreign parameters ocean JSON

00:21:31,019 --> 00:21:35,639
or something like that for doing an API

00:21:32,309 --> 00:21:38,339
request so the server then processes

00:21:35,639 --> 00:21:40,889
this request it returns a response the

00:21:38,339 --> 00:21:42,749
response looks something like this again

00:21:40,889 --> 00:21:44,129
we have this first line which declares

00:21:42,749 --> 00:21:46,109
what version of HTTP we're using and

00:21:44,129 --> 00:21:49,379
then it returns the status code that we

00:21:46,109 --> 00:21:50,999
return so it's always both in numeric

00:21:49,379 --> 00:21:53,369
and the text version of the status code

00:21:50,999 --> 00:21:56,159
this is 200 ok could also be like 404

00:21:53,369 --> 00:21:59,549
not found 500 internal server error or

00:21:56,159 --> 00:22:01,169
any of the other ones then we also have

00:21:59,549 --> 00:22:02,879
the same set of things we have the

00:22:01,169 --> 00:22:05,190
headers that are coming back the

00:22:02,879 --> 00:22:07,539
format's the same key value with the

00:22:05,190 --> 00:22:09,879
colon in between the date some cash

00:22:07,539 --> 00:22:11,109
gene content the content type that we're

00:22:09,879 --> 00:22:13,090
getting back what kind of server served

00:22:11,109 --> 00:22:15,609
it and this can go on and on as you

00:22:13,090 --> 00:22:17,259
probably know one blank new line and

00:22:15,609 --> 00:22:18,970
then the response data so in this case

00:22:17,259 --> 00:22:22,019
this would probably be HTML for google

00:22:18,970 --> 00:22:24,580
com that's what I did the curl against

00:22:22,019 --> 00:22:27,779
so let's look at some code finally

00:22:24,580 --> 00:22:30,399
gotten to that point some caveats here

00:22:27,779 --> 00:22:32,320
this is not production code there are

00:22:30,399 --> 00:22:33,460
huge security vulnerabilities here you

00:22:32,320 --> 00:22:34,989
should never write code that looks like

00:22:33,460 --> 00:22:38,169
this if you're going to write like low

00:22:34,989 --> 00:22:40,029
level code there there's more that you

00:22:38,169 --> 00:22:41,529
need to do but this actually does work i

00:22:40,029 --> 00:22:45,639
will show you that it works momentarily

00:22:41,529 --> 00:22:48,399
but so this is a 23 line HTV server it

00:22:45,639 --> 00:22:49,899
does work i'll go through it again line

00:22:48,399 --> 00:22:52,090
by line to talk about each one in turn

00:22:49,899 --> 00:22:54,669
first you require the socket library to

00:22:52,090 --> 00:22:56,200
get all the good bits in reveal and we

00:22:54,669 --> 00:22:58,690
set up some constants just to kind of

00:22:56,200 --> 00:23:00,879
make the code a little more concise let

00:22:58,690 --> 00:23:02,590
me get into the meat of it so this is

00:23:00,879 --> 00:23:05,769
the Ruby call that ends up calling the

00:23:02,590 --> 00:23:08,259
socket a BSc suck a call or your API

00:23:05,769 --> 00:23:09,609
call we're creating anyone and we're

00:23:08,259 --> 00:23:12,220
saying it we're going to have an inet

00:23:09,609 --> 00:23:16,389
socket with a stream type so this is

00:23:12,220 --> 00:23:19,029
ipv4 and tcp if we were doing ipv6 that

00:23:16,389 --> 00:23:20,700
would say inet6 if we were doing UDP

00:23:19,029 --> 00:23:23,019
rather than TCP that could say Datagram

00:23:20,700 --> 00:23:24,369
you could keep going there's many many

00:23:23,019 --> 00:23:25,869
more taco types but they get really

00:23:24,369 --> 00:23:27,970
esoteric really fast you can also do

00:23:25,869 --> 00:23:29,529
eunuchs domain sockets just somewhat

00:23:27,970 --> 00:23:34,299
common but kind of everything beyond

00:23:29,529 --> 00:23:38,710
that less so then we're going to do the

00:23:34,299 --> 00:23:39,789
bind call this is the thing that tells

00:23:38,710 --> 00:23:43,320
it what with a kernel where we're

00:23:39,789 --> 00:23:45,879
listening to first we create this

00:23:43,320 --> 00:23:47,019
structure basically for what kind of

00:23:45,879 --> 00:23:48,970
sake we're gonna listen on so this is

00:23:47,019 --> 00:23:51,729
listening on port 1108 o on localhost

00:23:48,970 --> 00:23:56,649
and we're going to call the blind api

00:23:51,729 --> 00:23:58,330
call there so this the this socket is

00:23:56,649 --> 00:24:00,659
now listening well it's not listening

00:23:58,330 --> 00:24:03,519
yet but it's attached to port 1108 oh

00:24:00,659 --> 00:24:05,590
the reticle listen the parameter to

00:24:03,519 --> 00:24:07,779
listen is how deep the key ways so like

00:24:05,590 --> 00:24:09,759
i said before we accept connections off

00:24:07,779 --> 00:24:11,349
of this listen socket but if we're not

00:24:09,759 --> 00:24:14,019
currently accepting a connection then

00:24:11,349 --> 00:24:15,309
and someone comes in then it use it up

00:24:14,019 --> 00:24:17,049
and this says that we can have five

00:24:15,309 --> 00:24:18,630
people waiting to queue while we're

00:24:17,049 --> 00:24:21,480
waiting to accept the next one

00:24:18,630 --> 00:24:23,610
five connections we need to queue so

00:24:21,480 --> 00:24:27,870
then in a while loop we're going to call

00:24:23,610 --> 00:24:29,790
accept the accept API returns to poll

00:24:27,870 --> 00:24:31,080
basically and the first one is the

00:24:29,790 --> 00:24:33,120
actual file descriptor we're talking

00:24:31,080 --> 00:24:34,620
about so now we have a client socket and

00:24:33,120 --> 00:24:35,970
once this returns we actually have an

00:24:34,620 --> 00:24:39,110
established connection coming in from

00:24:35,970 --> 00:24:42,870
the from the server or from the client

00:24:39,110 --> 00:24:44,520
this is my very high performance hundred

00:24:42,870 --> 00:24:48,660
percent standards-compliant HTTP request

00:24:44,520 --> 00:24:52,800
parser if you remember the first line of

00:24:48,660 --> 00:24:53,970
an HTTP call is this get path version so

00:24:52,800 --> 00:24:58,170
I just split on spaces and take the

00:24:53,970 --> 00:24:59,940
second one what's the path we're going

00:24:58,170 --> 00:25:01,380
to expand the file name or expand the

00:24:59,940 --> 00:25:02,610
path using that path from the current

00:25:01,380 --> 00:25:07,440
file so like anything in the current

00:25:02,610 --> 00:25:11,820
directory so if the file exists and it's

00:25:07,440 --> 00:25:13,890
a file we read the contents left disk we

00:25:11,820 --> 00:25:15,750
write out there doing a 200 ok we send

00:25:13,890 --> 00:25:19,710
the content length of the file length

00:25:15,750 --> 00:25:21,180
and the contents of the file if that

00:25:19,710 --> 00:25:24,420
that's the 200 ok so we have the

00:25:21,180 --> 00:25:25,650
constant up there defined if on the

00:25:24,420 --> 00:25:27,150
other hand that file didn't exist we

00:25:25,650 --> 00:25:29,630
just end up not found which was to find

00:25:27,150 --> 00:25:34,500
up there so that's that HTTP 404

00:25:29,630 --> 00:25:35,880
response code finally after we're done

00:25:34,500 --> 00:25:37,860
when we close the sockets that way that

00:25:35,880 --> 00:25:39,810
this terminates the TCP connection so it

00:25:37,860 --> 00:25:42,810
doesn't stay open now that's it it's a

00:25:39,810 --> 00:25:45,500
23 line HTTP server in Ruby I will make

00:25:42,810 --> 00:25:45,500
sure that it works

00:25:55,320 --> 00:26:05,310
so here I have just a directory it's got

00:26:01,740 --> 00:26:06,510
two files in it that server file which

00:26:05,310 --> 00:26:09,600
looks basically the same as the other

00:26:06,510 --> 00:26:13,110
one and there's just a file called fuga

00:26:09,600 --> 00:26:20,430
text here which I will serve we're gonna

00:26:13,110 --> 00:26:21,720
run the file with Ruby go to so we

00:26:20,430 --> 00:26:27,300
didn't pass a file right so we get it

00:26:21,720 --> 00:26:29,310
not found if we give it a file that

00:26:27,300 --> 00:26:33,630
actually does exist we get the contents

00:26:29,310 --> 00:26:35,880
back and of course because there's not a

00:26:33,630 --> 00:26:41,070
lot here we can also just get the server

00:26:35,880 --> 00:26:47,730
file itself so it works like we have 23

00:26:41,070 --> 00:26:53,760
line HTTP server that's pretty cool we

00:26:47,730 --> 00:26:57,000
go so that is a 23 line HP server that

00:26:53,760 --> 00:26:58,800
actually does work successfully so just

00:26:57,000 --> 00:27:01,020
to prove that I'm not making this all up

00:26:58,800 --> 00:27:03,210
and that this actually does get used I

00:27:01,020 --> 00:27:04,710
went and found the places where this

00:27:03,210 --> 00:27:06,350
actually gets used inside of unicorn so

00:27:04,710 --> 00:27:09,870
we actually make the same API calls here

00:27:06,350 --> 00:27:11,340
the this is an example for the ipv6 way

00:27:09,870 --> 00:27:12,480
that it listens because the ipv4 one is

00:27:11,340 --> 00:27:14,460
a little bit different it doesn't see

00:27:12,480 --> 00:27:17,520
rather than in Ruby so that API calls

00:27:14,460 --> 00:27:20,280
are hidden but you can see here we call

00:27:17,520 --> 00:27:23,310
so new we pass inet6 to it and so

00:27:20,280 --> 00:27:28,080
extreme so we're creating a TCP ipv6

00:27:23,310 --> 00:27:29,790
socket we do the same exact line call

00:27:28,080 --> 00:27:32,340
with the creating the same structure so

00:27:29,790 --> 00:27:34,380
with the port in the address and then

00:27:32,340 --> 00:27:36,420
rather than accept we call it when you

00:27:34,380 --> 00:27:38,160
select here because accept only listens

00:27:36,420 --> 00:27:40,380
on one file descriptor and so if you

00:27:38,160 --> 00:27:41,730
want to listen on like multiple sockets

00:27:40,380 --> 00:27:42,840
at the same time you can if you're

00:27:41,730 --> 00:27:44,070
accepting on one you're obviously not

00:27:42,840 --> 00:27:45,720
listening on the other so select is

00:27:44,070 --> 00:27:46,860
basically the same thing you can listen

00:27:45,720 --> 00:27:49,140
on multiple the same time it was

00:27:46,860 --> 00:27:51,060
returned whichever one comes first but

00:27:49,140 --> 00:27:55,340
we actually do the same the same exact

00:27:51,060 --> 00:27:57,690
API calls downside of unicorn so again

00:27:55,340 --> 00:28:01,500
starting from the bottom we have the

00:27:57,690 --> 00:28:03,420
colonel runs on top of hardware to talk

00:28:01,500 --> 00:28:04,770
to the colonel which is how we get to

00:28:03,420 --> 00:28:07,320
basically anything that the hardware is

00:28:04,770 --> 00:28:08,880
related to we use these system calls for

00:28:07,320 --> 00:28:10,410
talking about anything that uses a

00:28:08,880 --> 00:28:12,420
I'll or looks like a file basically

00:28:10,410 --> 00:28:14,790
including sockets we're can use the file

00:28:12,420 --> 00:28:16,410
descriptor API we use sockets to write

00:28:14,790 --> 00:28:17,790
with networking servers and we use HTTP

00:28:16,410 --> 00:28:19,920
on top of sockets to do the web

00:28:17,790 --> 00:28:21,750
basically so this is everything from

00:28:19,920 --> 00:28:25,260
basically directly above the hardware to

00:28:21,750 --> 00:28:26,340
directly below your rails app if you're

00:28:25,260 --> 00:28:27,600
interested in more reading about this

00:28:26,340 --> 00:28:28,710
there's a couple of books here that I

00:28:27,600 --> 00:28:31,020
think are really good this one's Linux

00:28:28,710 --> 00:28:32,940
system programming by Robert love who is

00:28:31,020 --> 00:28:35,130
a kernel developer from novell he's

00:28:32,940 --> 00:28:36,270
awesome this is just came out second

00:28:35,130 --> 00:28:39,540
edition a couple of months ago so it's

00:28:36,270 --> 00:28:41,010
really up to date covers all about linux

00:28:39,540 --> 00:28:43,350
system calls it's really actually fun to

00:28:41,010 --> 00:28:44,670
read it's pretty cool it doesn't really

00:28:43,350 --> 00:28:46,490
cover the networking side of things it's

00:28:44,670 --> 00:28:48,600
more about the system calls and all the

00:28:46,490 --> 00:28:51,630
all the system calls it you can do in

00:28:48,600 --> 00:28:54,180
Linux basically for network programming

00:28:51,630 --> 00:28:55,800
there's a usually referred to as unp

00:28:54,180 --> 00:28:59,220
unix network program by richard stevens

00:28:55,800 --> 00:29:00,780
this is much much older and it's a beast

00:28:59,220 --> 00:29:02,340
it's really thick but it covers

00:29:00,780 --> 00:29:04,020
everything you could ever want to know

00:29:02,340 --> 00:29:05,040
about network programming it's better as

00:29:04,020 --> 00:29:07,380
a reference then like something you'd

00:29:05,040 --> 00:29:09,000
read into and also by richard stevens is

00:29:07,380 --> 00:29:11,250
unix program advances in the unix

00:29:09,000 --> 00:29:12,750
environment a pua which is basically

00:29:11,250 --> 00:29:16,410
similar to linux system programming but

00:29:12,750 --> 00:29:17,610
for everything unix it's huge but it's a

00:29:16,410 --> 00:29:21,360
beast and it's it's a good reference

00:29:17,610 --> 00:29:23,070
again good books so that's it thanks a

00:29:21,360 --> 00:29:25,310
lot I got on mate Andy on the internet

00:29:23,070 --> 00:29:25,310
eight

00:30:04,690 --> 00:30:06,750

YouTube URL: https://www.youtube.com/watch?v=XNP0b6ykfFw


