Title: Rocky Mountain Ruby 2013 Minecart - A story of Ruby at a growing company by Matt Wilson
Publication date: 2020-01-27
Playlist: Rocky Mountain Ruby 2013
Description: 
	This is the story of Ruby at Square. As Square grew, we invested heavily in a service oriented architecture (SOA) and mainly used Java as our language of choice for new service development. Recently we finished a project, named Minecart, to deeply tie Ruby applications into our Java service infrastructure. To accomplish this we had to dive into the bowels of JRuby. To date, Square is roughly around 50/50 Java services vs Ruby services and everyone enjoys the benefits of a standard ecosystem. I will share many of our learnings along with a couple of practical examples and pitfalls for integrating Ruby into a custom Java framework.

Help us caption & translate this video!

http://amara.org/v/FG7J/
Captions: 
	00:00:29,789 --> 00:00:36,340
hello everyone I'm Matt Wilson and I'm

00:00:32,680 --> 00:00:38,200
an engineer at square so real quick how

00:00:36,340 --> 00:00:41,980
many people have heard of someone

00:00:38,200 --> 00:00:43,809
deploying to JRuby in production all

00:00:41,980 --> 00:00:45,430
right that's that's smaller than I

00:00:43,809 --> 00:00:47,230
thought it's like forty-five percent of

00:00:45,430 --> 00:00:51,190
the audience how many people actually

00:00:47,230 --> 00:00:53,289
deploy to JRuby in production all right

00:00:51,190 --> 00:00:56,829
all right that's like that's like three

00:00:53,289 --> 00:01:02,590
three percent of the audience so I love

00:00:56,829 --> 00:01:04,930
JRuby what JRuby has mature garbage

00:01:02,590 --> 00:01:06,670
collection native threading it has a

00:01:04,930 --> 00:01:08,740
promise of being able to fine-tune slow

00:01:06,670 --> 00:01:11,350
parts of your application and you get to

00:01:08,740 --> 00:01:13,090
use well-known crypto libraries like

00:01:11,350 --> 00:01:17,049
bouncy castle without shelling out to

00:01:13,090 --> 00:01:20,080
the command line now jruby is not a ploy

00:01:17,049 --> 00:01:21,430
to get java into your stack i think

00:01:20,080 --> 00:01:23,680
they've done a little bit of a bad job

00:01:21,430 --> 00:01:25,570
of branding that JRuby is just a

00:01:23,680 --> 00:01:28,210
platform that can interpret Ruby and

00:01:25,570 --> 00:01:31,060
does it well there are a couple problems

00:01:28,210 --> 00:01:33,070
with JRuby one is startup time second

00:01:31,060 --> 00:01:35,079
one is sometimes they'll get java stack

00:01:33,070 --> 00:01:38,560
traces but I believe Charles can fix

00:01:35,079 --> 00:01:41,140
this and I believe in Charles so let's

00:01:38,560 --> 00:01:43,720
look at we're going to talk about i said

00:01:41,140 --> 00:01:45,460
i will share many of our learnings along

00:01:43,720 --> 00:01:48,100
with a couple of practical examples and

00:01:45,460 --> 00:01:52,950
pitfalls for any great routing into our

00:01:48,100 --> 00:01:55,509
custom Java framework so let's begin

00:01:52,950 --> 00:01:57,670
there's a lot you have to do to convert

00:01:55,509 --> 00:02:02,290
from a type language to not can everyone

00:01:57,670 --> 00:02:05,560
see my pointer I'm just kidding I wrote

00:02:02,290 --> 00:02:07,930
that presentation is really boring we

00:02:05,560 --> 00:02:09,640
have a lot of technical details on our

00:02:07,930 --> 00:02:12,580
blog at corner squareup com if you're

00:02:09,640 --> 00:02:13,950
interested in how this was done but

00:02:12,580 --> 00:02:16,110
what's really interesting about

00:02:13,950 --> 00:02:18,030
the talk as I was developing it is that

00:02:16,110 --> 00:02:21,120
squares Ruby's stack leverages our

00:02:18,030 --> 00:02:22,920
production environment completely so

00:02:21,120 --> 00:02:25,500
what is a production environment and why

00:02:22,920 --> 00:02:26,670
couldn't Ruby leverage it before so I'm

00:02:25,500 --> 00:02:30,209
going to talk a little bit about that

00:02:26,670 --> 00:02:33,390
today um what I'd like you to take out

00:02:30,209 --> 00:02:35,610
of this talk is first of all the jruby

00:02:33,390 --> 00:02:37,110
is awesome and the JVM is something that

00:02:35,610 --> 00:02:40,290
you should consider deploying to or

00:02:37,110 --> 00:02:42,900
using even if you never intend to drop

00:02:40,290 --> 00:02:47,459
down and write Java or closure or other

00:02:42,900 --> 00:02:49,799
JVM languages as you've split out into a

00:02:47,459 --> 00:02:51,900
service-oriented architecture it's

00:02:49,799 --> 00:02:53,910
critical that you think about building a

00:02:51,900 --> 00:02:55,920
common framework that all your apps are

00:02:53,910 --> 00:02:57,540
deployed on top of which gives you the

00:02:55,920 --> 00:03:00,120
ability to design an engineer the

00:02:57,540 --> 00:03:01,230
production environment and then for

00:03:00,120 --> 00:03:02,940
those of you who are a little bit more

00:03:01,230 --> 00:03:06,209
poly linguist I'm going to show an

00:03:02,940 --> 00:03:08,910
example of a very big Java framework

00:03:06,209 --> 00:03:11,400
that a lot of our Java engineers worked

00:03:08,910 --> 00:03:13,110
on a very good framework and how we were

00:03:11,400 --> 00:03:15,090
able to put Ruby on top of it in a

00:03:13,110 --> 00:03:16,739
seamless way that allows any Ruby

00:03:15,090 --> 00:03:18,840
engineer off the street to come in and

00:03:16,739 --> 00:03:20,549
develop Ruby with all the toolkits that

00:03:18,840 --> 00:03:21,840
they are familiar with in a way that

00:03:20,549 --> 00:03:23,880
they don't have to understand what's

00:03:21,840 --> 00:03:24,900
happening underneath but then they can

00:03:23,880 --> 00:03:28,049
participate in this production

00:03:24,900 --> 00:03:30,870
environment so let's give a little bit

00:03:28,049 --> 00:03:33,900
of history about how square developed I

00:03:30,870 --> 00:03:35,489
got very lucky i joined square early and

00:03:33,900 --> 00:03:37,889
i got to work on a project called wallet

00:03:35,489 --> 00:03:40,680
which is a second application from

00:03:37,889 --> 00:03:43,769
square and the idea is you can walk into

00:03:40,680 --> 00:03:45,930
a store and buy proximity we can detect

00:03:43,769 --> 00:03:47,310
when you are close to a merchant and if

00:03:45,930 --> 00:03:49,470
you have given authorization for that

00:03:47,310 --> 00:03:50,819
merchant to charge you you will your

00:03:49,470 --> 00:03:53,220
name and picture will show up on the

00:03:50,819 --> 00:03:56,040
register and they can you can walk up an

00:03:53,220 --> 00:03:57,389
order coffee and say charge matt you

00:03:56,040 --> 00:03:59,730
take your coffee and you leave and you

00:03:57,389 --> 00:04:01,109
didn't touch any technology it changed

00:03:59,730 --> 00:04:03,329
how people interacted and it was a

00:04:01,109 --> 00:04:06,120
really cool project to work on and how

00:04:03,329 --> 00:04:07,799
it was done is we took four people I was

00:04:06,120 --> 00:04:10,919
one of the four and we put him in a room

00:04:07,799 --> 00:04:13,680
and we began developing and it was a

00:04:10,919 --> 00:04:15,209
three month sprint to basically add the

00:04:13,680 --> 00:04:17,220
ability to store credit cards at square

00:04:15,209 --> 00:04:19,470
add the ability for merchants to publish

00:04:17,220 --> 00:04:21,539
their ad vitur locations for customers

00:04:19,470 --> 00:04:23,909
is fine add the ability for customers to

00:04:21,539 --> 00:04:25,169
search for these merchants so it was a

00:04:23,909 --> 00:04:27,510
bunch of infrastructure that we didn't

00:04:25,169 --> 00:04:27,840
have but the reason we were able to do

00:04:27,510 --> 00:04:29,880
it

00:04:27,840 --> 00:04:31,980
was because in that team of four the

00:04:29,880 --> 00:04:33,419
communication was highly optimized we

00:04:31,980 --> 00:04:35,460
all were able to come up with this

00:04:33,419 --> 00:04:39,630
custom vision of where we wanted to go

00:04:35,460 --> 00:04:41,639
and make decisions autonomously so we

00:04:39,630 --> 00:04:44,760
came out of that room after three months

00:04:41,639 --> 00:04:47,990
and the rest of the company helped us

00:04:44,760 --> 00:04:51,660
for another month to push it out and

00:04:47,990 --> 00:04:53,699
they launched successfully so a couple

00:04:51,660 --> 00:04:55,919
months later we sort of faced the

00:04:53,699 --> 00:04:58,169
problem that many growing companies have

00:04:55,919 --> 00:05:00,800
which is how do we depart from our

00:04:58,169 --> 00:05:03,810
monolith and I just want to say

00:05:00,800 --> 00:05:05,430
monolithic apps are great service

00:05:03,810 --> 00:05:08,100
oriented architecture is a people

00:05:05,430 --> 00:05:10,590
solution it is not a code solution is

00:05:08,100 --> 00:05:12,600
not an availability solution it's a way

00:05:10,590 --> 00:05:14,400
for a lot of engineers to work to eat

00:05:12,600 --> 00:05:18,450
with each other without affecting each

00:05:14,400 --> 00:05:19,919
other so put this off I am a big fan of

00:05:18,450 --> 00:05:21,810
rails engines I think there's a lot of

00:05:19,919 --> 00:05:24,450
architecture things we can do to make it

00:05:21,810 --> 00:05:26,729
easier to split up when it's time but

00:05:24,450 --> 00:05:28,500
once it's time the biggest thing that

00:05:26,729 --> 00:05:31,889
you're going to have to solve is your

00:05:28,500 --> 00:05:35,130
message bus now what a message bus is is

00:05:31,889 --> 00:05:37,289
this is defining how data transitions or

00:05:35,130 --> 00:05:40,139
how data moves in your system so one

00:05:37,289 --> 00:05:42,750
implementation has feeds and all feeds

00:05:40,139 --> 00:05:44,490
are are basically a pagination API where

00:05:42,750 --> 00:05:47,780
you page through data through an append

00:05:44,490 --> 00:05:50,490
only list so we wrote it in Java first

00:05:47,780 --> 00:05:52,470
it turns out there's some details around

00:05:50,490 --> 00:05:54,720
sharding because you want to be able to

00:05:52,470 --> 00:05:56,820
scale out your consumers horizontally

00:05:54,720 --> 00:05:58,830
then it turns out there's some details

00:05:56,820 --> 00:06:00,479
around publishing and using auto

00:05:58,830 --> 00:06:02,039
increment and there's some race

00:06:00,479 --> 00:06:04,680
conditions in the database so there's

00:06:02,039 --> 00:06:07,560
some more code it turns out it's there's

00:06:04,680 --> 00:06:09,780
a lot of code but we got it working it

00:06:07,560 --> 00:06:12,690
worked in Java and Java can consume from

00:06:09,780 --> 00:06:17,010
our Ruby services now we had to get it

00:06:12,690 --> 00:06:20,010
working in ruby ruby is terse so we

00:06:17,010 --> 00:06:26,580
began and we had our short at active

00:06:20,010 --> 00:06:31,500
record bass consume oh no oh no oh what

00:06:26,580 --> 00:06:34,590
are these things oh my god it's terrible

00:06:31,500 --> 00:06:37,370
right it's lots of code we have now to

00:06:34,590 --> 00:06:41,340
crap tons of code we have to maintain

00:06:37,370 --> 00:06:41,700
now some of you may say well that's not

00:06:41,340 --> 00:06:45,090
eating

00:06:41,700 --> 00:06:46,740
matic Ruby and and but but the truth is

00:06:45,090 --> 00:06:49,020
it's hard to maintain feature parity

00:06:46,740 --> 00:06:50,730
across languages if you have language

00:06:49,020 --> 00:06:52,290
one and language too regardless of what

00:06:50,730 --> 00:06:54,120
they are you have to pick your primary

00:06:52,290 --> 00:06:56,550
you have to implement it in language one

00:06:54,120 --> 00:06:58,500
and then basically copy over the class

00:06:56,550 --> 00:07:00,240
structure into language too because if

00:06:58,500 --> 00:07:01,890
there's ever a security vulnerability or

00:07:00,240 --> 00:07:03,450
there's even just a new feature that you

00:07:01,890 --> 00:07:05,190
want to add you need to be able to go to

00:07:03,450 --> 00:07:07,230
language one make the change and

00:07:05,190 --> 00:07:08,730
immediately go to language to find the

00:07:07,230 --> 00:07:12,300
place to make that similar change and

00:07:08,730 --> 00:07:14,070
make the change um and I don't believe

00:07:12,300 --> 00:07:16,680
that there's a mythical team that can

00:07:14,070 --> 00:07:19,440
leverage two stacks or build two stacks

00:07:16,680 --> 00:07:21,420
that have feature equivalents as time

00:07:19,440 --> 00:07:24,000
goes on so this is probably the best way

00:07:21,420 --> 00:07:26,850
to do that in this mode but it worked

00:07:24,000 --> 00:07:28,860
ruby was now able to talk to Java and I

00:07:26,850 --> 00:07:30,420
was pretty much the only infrastructure

00:07:28,860 --> 00:07:32,190
that was in our Java stack so we

00:07:30,420 --> 00:07:35,700
continued building new Ruby services

00:07:32,190 --> 00:07:39,690
building new Java services but then this

00:07:35,700 --> 00:07:42,600
guy came along starbucks and starbucks

00:07:39,690 --> 00:07:46,080
was a totally different animal um

00:07:42,600 --> 00:07:47,910
basically from day 4 we had 50 engineers

00:07:46,080 --> 00:07:49,860
working on this i don't know if you know

00:07:47,910 --> 00:07:52,140
this but every time you swipe a card at

00:07:49,860 --> 00:07:55,170
a starbucks location it goes through

00:07:52,140 --> 00:07:56,700
squares network and and because of the

00:07:55,170 --> 00:07:58,290
work i don't on wallet i got to

00:07:56,700 --> 00:07:59,460
architect the wallet integration with

00:07:58,290 --> 00:08:01,650
starbucks so you can actually take

00:07:59,460 --> 00:08:04,200
square wallet and scan your QR code at

00:08:01,650 --> 00:08:06,030
starbucks um and this was really a

00:08:04,200 --> 00:08:07,860
lesson for me in decision sequencing

00:08:06,030 --> 00:08:09,810
what decisions that you have to make

00:08:07,860 --> 00:08:11,490
today what decisions could you try to

00:08:09,810 --> 00:08:13,200
find a little wiggle room to experiment

00:08:11,490 --> 00:08:15,450
with and and what decisions could you

00:08:13,200 --> 00:08:18,150
put off till the end and we had a couple

00:08:15,450 --> 00:08:20,730
of engineers who got together and and

00:08:18,150 --> 00:08:22,620
how they made this project work as they

00:08:20,730 --> 00:08:24,330
defined how services we're going to talk

00:08:22,620 --> 00:08:27,360
in the production environment they

00:08:24,330 --> 00:08:28,740
design the they decided here is how we

00:08:27,360 --> 00:08:30,930
are going to maintain these services

00:08:28,740 --> 00:08:33,000
here is how we're going to provide the

00:08:30,930 --> 00:08:34,500
SLA that we need to provide and here's

00:08:33,000 --> 00:08:36,660
how we're going to work together and

00:08:34,500 --> 00:08:39,300
expose our API is both internally and

00:08:36,660 --> 00:08:41,130
externally and at the time of starbucks

00:08:39,300 --> 00:08:44,670
we're a single data center we had about

00:08:41,130 --> 00:08:46,410
six apps in production after the three

00:08:44,670 --> 00:08:50,550
months we had three months to accomplish

00:08:46,410 --> 00:08:52,230
this we had like 15 services in

00:08:50,550 --> 00:08:54,120
production across two data centers and

00:08:52,230 --> 00:08:56,010
we were active active for taking card

00:08:54,120 --> 00:08:57,810
processing so really pushed

00:08:56,010 --> 00:08:59,790
infrastructure forward but there was a

00:08:57,810 --> 00:09:02,130
ton of infrastructure that was built to

00:08:59,790 --> 00:09:04,470
do this and the biggest thing that made

00:09:02,130 --> 00:09:06,630
the starbucks project succeed was the

00:09:04,470 --> 00:09:08,340
optimization for communication by saying

00:09:06,630 --> 00:09:10,410
here is how the systems are going to

00:09:08,340 --> 00:09:12,930
work in production we were able to build

00:09:10,410 --> 00:09:14,610
a skeleton that later we were the all

00:09:12,930 --> 00:09:17,280
the teams were able to work it er ative

00:09:14,610 --> 00:09:20,040
Lee and fill out the details with but we

00:09:17,280 --> 00:09:22,410
had a goal that we were we were driving

00:09:20,040 --> 00:09:24,270
towards so very different animal from

00:09:22,410 --> 00:09:25,800
what wall was like and it's pretty

00:09:24,270 --> 00:09:27,990
amazing that both of these developments

00:09:25,800 --> 00:09:29,910
tiles were able to work but there and

00:09:27,990 --> 00:09:33,020
some people may think they conflict what

00:09:29,910 --> 00:09:37,410
they really don't the because day to day

00:09:33,020 --> 00:09:42,180
agile is how we develop at square so

00:09:37,410 --> 00:09:44,790
then the question was how do we leverage

00:09:42,180 --> 00:09:46,740
this production stack so we have built

00:09:44,790 --> 00:09:48,990
out a bunch of technology to make square

00:09:46,740 --> 00:09:51,180
robust we're working in an area where

00:09:48,990 --> 00:09:54,210
we're other companies are pushing three

00:09:51,180 --> 00:09:56,430
four five six nines that's like eight

00:09:54,210 --> 00:09:59,070
hours of downtime 50 minutes of downtime

00:09:56,430 --> 00:10:01,680
five minutes of downtime and four

00:09:59,070 --> 00:10:07,500
seconds sorry 30 seconds of downtime a

00:10:01,680 --> 00:10:10,560
year so one option was that we could

00:10:07,500 --> 00:10:12,030
build a ruby service container and keep

00:10:10,560 --> 00:10:13,620
it in feature parity with the Java

00:10:12,030 --> 00:10:18,150
service container like I showed you with

00:10:13,620 --> 00:10:20,550
the feeds but another option was we

00:10:18,150 --> 00:10:21,900
could allow Ruby to get access to the

00:10:20,550 --> 00:10:23,850
sum of the resources in service

00:10:21,900 --> 00:10:26,670
container so sort of piecemeal say i

00:10:23,850 --> 00:10:28,320
want the feed and i want the cross data

00:10:26,670 --> 00:10:32,760
center and then talk to it through a

00:10:28,320 --> 00:10:34,320
java api another idea was you could put

00:10:32,760 --> 00:10:35,970
rails on top of the service container

00:10:34,320 --> 00:10:39,870
and talk to all of your resources

00:10:35,970 --> 00:10:41,910
through a java api but the one that i

00:10:39,870 --> 00:10:43,860
thought was the most appealing was to

00:10:41,910 --> 00:10:46,410
spend a little bit of time writing some

00:10:43,860 --> 00:10:49,290
duplicate code but just a very thin API

00:10:46,410 --> 00:10:51,570
layer that adapted the concepts in the

00:10:49,290 --> 00:10:53,670
service container to those in that were

00:10:51,570 --> 00:10:54,930
more idiomatic Ruby and the reason i

00:10:53,670 --> 00:10:56,490
thought this could succeed and be

00:10:54,930 --> 00:10:58,440
maintainable is because the service

00:10:56,490 --> 00:11:00,660
container was already designed to be

00:10:58,440 --> 00:11:02,070
optimized for application developers is

00:11:00,660 --> 00:11:03,750
already designed to try to allow

00:11:02,070 --> 00:11:05,820
application developers to develop as

00:11:03,750 --> 00:11:07,860
quickly as possible so they only had

00:11:05,820 --> 00:11:10,050
about four or five concepts that if we

00:11:07,860 --> 00:11:11,670
could represent equally in

00:11:10,050 --> 00:11:14,070
in this project that we call mine cart

00:11:11,670 --> 00:11:15,839
then both sides would be able to develop

00:11:14,070 --> 00:11:20,610
independently of each other but we would

00:11:15,839 --> 00:11:23,279
have a stable API so what's when I when

00:11:20,610 --> 00:11:24,750
I say service container and and

00:11:23,279 --> 00:11:28,050
stability what does this actually mean

00:11:24,750 --> 00:11:29,910
what is the production environment so I

00:11:28,050 --> 00:11:31,440
like I like this picture a lot because

00:11:29,910 --> 00:11:34,410
it reminded me of something that Steve

00:11:31,440 --> 00:11:38,490
Jobs said which is software is like

00:11:34,410 --> 00:11:41,190
scaffolding and and by using objective-c

00:11:38,490 --> 00:11:43,200
and all their native api's you are able

00:11:41,190 --> 00:11:44,790
to start at a higher level and build a

00:11:43,200 --> 00:11:46,470
taller building so if you start without

00:11:44,790 --> 00:11:48,170
any scaffolding you can only build the

00:11:46,470 --> 00:11:51,240
building so high before it falls over

00:11:48,170 --> 00:11:52,980
and if and the exciting thing is the

00:11:51,240 --> 00:11:55,079
production environment is a new

00:11:52,980 --> 00:11:59,850
dimension that you can optimize for new

00:11:55,079 --> 00:12:02,040
scaffolding so in development what often

00:11:59,850 --> 00:12:04,800
happens is you'll have a project you'll

00:12:02,040 --> 00:12:07,649
build it and it'll work you'll ship it

00:12:04,800 --> 00:12:09,829
it flies but a couple months will go by

00:12:07,649 --> 00:12:12,570
maybe the team changes a little and

00:12:09,829 --> 00:12:14,310
you'll say let's build something new and

00:12:12,570 --> 00:12:15,420
you'll get excited and you'll take all

00:12:14,310 --> 00:12:18,510
the things that you liked about the

00:12:15,420 --> 00:12:19,560
first one you'll try to actively fix

00:12:18,510 --> 00:12:21,420
some things that you didn't like about

00:12:19,560 --> 00:12:23,190
the first project but then you also lose

00:12:21,420 --> 00:12:24,570
out on some of the know how that

00:12:23,190 --> 00:12:26,579
happened during the first development

00:12:24,570 --> 00:12:28,260
that wasn't immediately apparent and

00:12:26,579 --> 00:12:30,959
you'll build something and it'll still

00:12:28,260 --> 00:12:32,880
fly it'll work great but then nine

00:12:30,959 --> 00:12:35,610
months later we'll go by and you'll have

00:12:32,880 --> 00:12:38,100
two more projects now it is very hard

00:12:35,610 --> 00:12:39,839
for a single engineer to look at each

00:12:38,100 --> 00:12:42,120
one of these projects and tell how they

00:12:39,839 --> 00:12:44,310
integrate together like does each each

00:12:42,120 --> 00:12:45,959
project handle and evidence the same you

00:12:44,310 --> 00:12:47,520
might even be deploying on different

00:12:45,959 --> 00:12:49,140
utilities they're like different apps

00:12:47,520 --> 00:12:51,930
may have different rolling deploy

00:12:49,140 --> 00:12:56,510
stories and so it keeps going and keeps

00:12:51,930 --> 00:12:58,649
going and you end up on flying turtles

00:12:56,510 --> 00:13:00,270
but what you want in your production

00:12:58,649 --> 00:13:03,690
environment is you want it to be like a

00:13:00,270 --> 00:13:05,760
city a city is immensely complex system

00:13:03,690 --> 00:13:07,740
you want all your Road sizes to be the

00:13:05,760 --> 00:13:09,660
same you want your power grid to power

00:13:07,740 --> 00:13:11,820
all of the buildings the same you want

00:13:09,660 --> 00:13:14,220
every single light bulb fixture to be

00:13:11,820 --> 00:13:16,170
the same fixture you want an engineer to

00:13:14,220 --> 00:13:17,790
be able to practice replacing an

00:13:16,170 --> 00:13:19,860
elevator in one building and then

00:13:17,790 --> 00:13:21,720
accurately reproduce this across all the

00:13:19,860 --> 00:13:23,610
other buildings and what this really

00:13:21,720 --> 00:13:25,589
does for the infrastructure engineers

00:13:23,610 --> 00:13:28,050
is it allows them to balance trade-offs

00:13:25,589 --> 00:13:30,180
between short-term and long-term gains

00:13:28,050 --> 00:13:32,190
so they can say we're going to work on a

00:13:30,180 --> 00:13:34,380
year-and-a-half project that saves us

00:13:32,190 --> 00:13:36,360
forty percent in resources instead of a

00:13:34,380 --> 00:13:38,370
six-month project that saves us ten

00:13:36,360 --> 00:13:40,019
percent resources and they can predict

00:13:38,370 --> 00:13:41,190
accurately the success of this project

00:13:40,019 --> 00:13:43,610
because they don't run into

00:13:41,190 --> 00:13:45,779
idiosyncrasies that really jeopardize

00:13:43,610 --> 00:13:49,350
being able to roll this out to across

00:13:45,779 --> 00:13:51,149
all the apps so if we look at the types

00:13:49,350 --> 00:13:53,760
of scaffolding we have production

00:13:51,149 --> 00:13:55,829
scaffolding like Heroku and App Engine

00:13:53,760 --> 00:13:57,480
are a little bit more particular and

00:13:55,829 --> 00:13:59,880
give you some api's where if you feed

00:13:57,480 --> 00:14:01,350
them data you can then go and see how

00:13:59,880 --> 00:14:02,820
your service is doing see how many

00:14:01,350 --> 00:14:05,730
requests you're getting well then you

00:14:02,820 --> 00:14:06,870
can have something like ec2 or Rackspace

00:14:05,730 --> 00:14:09,029
where you're in control of your

00:14:06,870 --> 00:14:10,709
environment and the point is they don't

00:14:09,029 --> 00:14:13,380
care what the code that you deploy to

00:14:10,709 --> 00:14:17,130
looks like you can deploy anything that

00:14:13,380 --> 00:14:18,360
responds to http then there are things

00:14:17,130 --> 00:14:21,050
are optimized for the development

00:14:18,360 --> 00:14:23,910
environment and there's like rails or

00:14:21,050 --> 00:14:26,339
java play which is an immediate feedback

00:14:23,910 --> 00:14:27,839
java library these don't mean that they

00:14:26,339 --> 00:14:29,910
don't work in production they were great

00:14:27,839 --> 00:14:31,350
in production it's just they don't care

00:14:29,910 --> 00:14:33,329
how they work in production they don't

00:14:31,350 --> 00:14:36,300
care how they talk to other systems that

00:14:33,329 --> 00:14:38,100
are of the same type like rails is not

00:14:36,300 --> 00:14:39,839
opinionated except for maybe active

00:14:38,100 --> 00:14:42,779
resource about how you do service to

00:14:39,839 --> 00:14:44,640
serve as communication and then you have

00:14:42,779 --> 00:14:47,160
sort of a combination where there's

00:14:44,640 --> 00:14:48,899
application framework you built into but

00:14:47,160 --> 00:14:50,730
and by using the application framework

00:14:48,899 --> 00:14:52,380
it can install logging and common

00:14:50,730 --> 00:14:56,420
instrumentation for you to be able to

00:14:52,380 --> 00:14:58,560
monitor and maintain your applications

00:14:56,420 --> 00:15:02,279
so we go through a couple common

00:14:58,560 --> 00:15:03,839
features in this framework it packages

00:15:02,279 --> 00:15:05,160
dependencies so you have a consistent

00:15:03,839 --> 00:15:08,040
deploy story and you always have your

00:15:05,160 --> 00:15:10,320
resources there's some sort of

00:15:08,040 --> 00:15:12,360
application lifecycle so when it spins

00:15:10,320 --> 00:15:14,310
up and receives traffic versus when it

00:15:12,360 --> 00:15:17,399
spins down with some sort of rolling

00:15:14,310 --> 00:15:19,829
deploys and not losing requests trust

00:15:17,399 --> 00:15:22,320
and security this is huge to square we

00:15:19,829 --> 00:15:23,940
have bank accounts we have social

00:15:22,320 --> 00:15:26,040
security numbers and we have credit

00:15:23,940 --> 00:15:28,529
cards so how do we build a distributed

00:15:26,040 --> 00:15:30,120
system that our customer and that lives

00:15:28,529 --> 00:15:33,420
up to the trust that our customers put

00:15:30,120 --> 00:15:35,310
into us um monitoring and

00:15:33,420 --> 00:15:37,570
instrumentation how is an individual

00:15:35,310 --> 00:15:40,780
know doing versus how is the whole

00:15:37,570 --> 00:15:43,510
environment behaving some sort of job

00:15:40,780 --> 00:15:45,070
system some sort of message bus and you

00:15:43,510 --> 00:15:46,660
can have multiple implementations but

00:15:45,070 --> 00:15:49,240
how do you get data around your system

00:15:46,660 --> 00:15:51,640
and then some sort of form of health

00:15:49,240 --> 00:15:54,660
checks is when I'm alive how do I know

00:15:51,640 --> 00:15:56,770
that all my downstream dependencies

00:15:54,660 --> 00:15:59,950
enable me to make the request that I

00:15:56,770 --> 00:16:02,560
need to make and then lastly some sort

00:15:59,950 --> 00:16:04,930
of distributed tracing and common

00:16:02,560 --> 00:16:07,030
logging so that you can actually when an

00:16:04,930 --> 00:16:11,170
error happens go and find and pinpoint

00:16:07,030 --> 00:16:13,390
the exception all right the goal of all

00:16:11,170 --> 00:16:14,950
this is so that application engineers

00:16:13,390 --> 00:16:17,050
spend time creating value for the

00:16:14,950 --> 00:16:18,820
customers you know from from my point of

00:16:17,050 --> 00:16:20,800
view all that matters is I have an idea

00:16:18,820 --> 00:16:22,660
I want to be able to build it I want to

00:16:20,800 --> 00:16:23,680
be able to ship it and in the by

00:16:22,660 --> 00:16:26,340
optimizing for the production

00:16:23,680 --> 00:16:28,540
environment I don't have to maintain it

00:16:26,340 --> 00:16:30,820
but the more important thing that a

00:16:28,540 --> 00:16:33,430
common system does is it elevates the

00:16:30,820 --> 00:16:34,930
conversation about bring and brings it

00:16:33,430 --> 00:16:38,440
back to what the application or that

00:16:34,930 --> 00:16:40,330
features and and it's very subtle but

00:16:38,440 --> 00:16:43,210
it's very important if I had a feature

00:16:40,330 --> 00:16:45,130
that I wanted to charge a wallet credit

00:16:43,210 --> 00:16:47,230
card I could go into a meeting with a

00:16:45,130 --> 00:16:49,150
security engineer and a couple of

00:16:47,230 --> 00:16:50,740
application engineers and we could start

00:16:49,150 --> 00:16:52,840
of and say okay we want to charge wallet

00:16:50,740 --> 00:16:54,310
credit cards and then the security guys

00:16:52,840 --> 00:16:56,500
would say okay well we need to figure

00:16:54,310 --> 00:16:57,790
out how to make this secure because you

00:16:56,500 --> 00:16:59,650
know this is the first system that we're

00:16:57,790 --> 00:17:01,420
using to charge credit cards and we

00:16:59,650 --> 00:17:03,610
don't want a compromise in this system

00:17:01,420 --> 00:17:06,250
to accidentally credit cards and the

00:17:03,610 --> 00:17:09,280
details just sort of delve down into

00:17:06,250 --> 00:17:12,040
sort of things that don't matter for the

00:17:09,280 --> 00:17:13,810
success of the feature but with a common

00:17:12,040 --> 00:17:15,760
system without saying a word the

00:17:13,810 --> 00:17:17,350
security engineers can automatically and

00:17:15,760 --> 00:17:19,839
their heads go okay needs to be in this

00:17:17,350 --> 00:17:21,850
firewall zone is going to have these

00:17:19,839 --> 00:17:23,860
properties and these people are going to

00:17:21,850 --> 00:17:26,220
be the ones maintaining it so this

00:17:23,860 --> 00:17:28,390
dramatically increases the success of

00:17:26,220 --> 00:17:32,200
complex products as you get bigger and

00:17:28,390 --> 00:17:33,970
bigger unfortunately optimizing for the

00:17:32,200 --> 00:17:36,280
production environment can conflict with

00:17:33,970 --> 00:17:38,410
the development environment so that was

00:17:36,280 --> 00:17:40,840
the goal of mine cart can we make a

00:17:38,410 --> 00:17:44,370
system that puts both of these and

00:17:40,840 --> 00:17:47,350
advantages both of these to the maximum

00:17:44,370 --> 00:17:51,220
so let's look at what Ruby code at

00:17:47,350 --> 00:17:53,289
square looks like so this is a

00:17:51,220 --> 00:17:56,590
and rails controller it's going to drop

00:17:53,289 --> 00:17:59,289
down here in a second and it has a

00:17:56,590 --> 00:18:02,260
standard view there's two special

00:17:59,289 --> 00:18:04,690
methods in here the kitchen and employee

00:18:02,260 --> 00:18:06,820
methods and there there an API to be

00:18:04,690 --> 00:18:08,620
able to talk out to other services so we

00:18:06,820 --> 00:18:12,580
have a remote kitchen service and we

00:18:08,620 --> 00:18:15,700
have a remote employee service so if we

00:18:12,580 --> 00:18:18,130
will go through the code it looks like

00:18:15,700 --> 00:18:20,530
standard rails we require login but then

00:18:18,130 --> 00:18:21,970
the this magic current user token and in

00:18:20,530 --> 00:18:23,559
our distributed network how we talk

00:18:21,970 --> 00:18:25,419
about users is just through their user

00:18:23,559 --> 00:18:27,370
token there an identifier that we can

00:18:25,419 --> 00:18:29,830
use to track the user so we're not

00:18:27,370 --> 00:18:32,350
passing around like actual user objects

00:18:29,830 --> 00:18:34,780
with behavior we have this system called

00:18:32,350 --> 00:18:38,110
multi pass which is user authentication

00:18:34,780 --> 00:18:42,760
and all it does is exchanged a session

00:18:38,110 --> 00:18:45,640
for a user so coming back current user

00:18:42,760 --> 00:18:47,620
dot present in our environment in our

00:18:45,640 --> 00:18:50,049
with our systems it's going to talk out

00:18:47,620 --> 00:18:55,179
to multi pass with the session token and

00:18:50,049 --> 00:18:58,000
get back the user token alright so we

00:18:55,179 --> 00:19:00,640
move on to the next part kitchen

00:18:58,000 --> 00:19:03,070
delivery orders and get the order list

00:19:00,640 --> 00:19:06,250
from that response alright so to

00:19:03,070 --> 00:19:08,200
understand what's happening well sorry

00:19:06,250 --> 00:19:09,730
there is a mysterious bang here which

00:19:08,200 --> 00:19:10,570
all that means in our syntax is that

00:19:09,730 --> 00:19:14,530
we're going to do this request

00:19:10,570 --> 00:19:16,120
synchronously so to understand what is

00:19:14,530 --> 00:19:17,919
actually happening in this request we're

00:19:16,120 --> 00:19:20,590
going to quickly delve into our service

00:19:17,919 --> 00:19:23,799
to service story and then come back up

00:19:20,590 --> 00:19:25,270
and look at how the code operates so

00:19:23,799 --> 00:19:27,309
there there are sort of three parts to

00:19:25,270 --> 00:19:29,679
the connection the first one is our

00:19:27,309 --> 00:19:32,320
mutual ssl which is our trusting

00:19:29,679 --> 00:19:33,700
security story and then i'm going to

00:19:32,320 --> 00:19:35,950
talk a little bit about protocol buffers

00:19:33,700 --> 00:19:37,480
and how they define the api and then

00:19:35,950 --> 00:19:38,980
lastly I'm going to we have a custom

00:19:37,480 --> 00:19:41,169
protocol for a service to service

00:19:38,980 --> 00:19:43,990
communication called sake which has some

00:19:41,169 --> 00:19:47,309
cool properties so taking a look at

00:19:43,990 --> 00:19:49,960
mutual ssl very simply all it does is

00:19:47,309 --> 00:19:52,870
service a will talk to service be and

00:19:49,960 --> 00:19:55,390
service be looks at its access control

00:19:52,870 --> 00:19:56,770
lists or akal and says yep you're

00:19:55,390 --> 00:19:59,289
allowed to talk to me unless the

00:19:56,770 --> 00:20:02,230
connection go through likewise service a

00:19:59,289 --> 00:20:04,600
can talk to service see what a service

00:20:02,230 --> 00:20:06,700
be tries to talk to service see

00:20:04,600 --> 00:20:08,590
service see looks at its akal see is 0

00:20:06,700 --> 00:20:11,260
service b is not allowed to talk to me

00:20:08,590 --> 00:20:13,900
and closes the connection likewise the

00:20:11,260 --> 00:20:15,640
service be talks to service see but it's

00:20:13,900 --> 00:20:18,280
a copycat and doesn't have the same key

00:20:15,640 --> 00:20:20,080
service be will close the connection and

00:20:18,280 --> 00:20:22,450
this can be as fine grand as you want it

00:20:20,080 --> 00:20:24,760
to be so you can do it on a per endpoint

00:20:22,450 --> 00:20:28,510
basis on a per service basis whatever

00:20:24,760 --> 00:20:31,210
needs you have for your security alright

00:20:28,510 --> 00:20:32,920
so after the connection is made we go up

00:20:31,210 --> 00:20:36,370
a level and we look at what our API is

00:20:32,920 --> 00:20:38,410
actually doing now all this all protocol

00:20:36,370 --> 00:20:41,200
buffer is is as a value object it's a

00:20:38,410 --> 00:20:43,390
snapshot of an object at a period of

00:20:41,200 --> 00:20:47,020
time that it makes it easy to transmit

00:20:43,390 --> 00:20:48,820
data between systems so every time you

00:20:47,020 --> 00:20:51,700
see delivery person is going to have a

00:20:48,820 --> 00:20:53,530
name and employee ID and this does not

00:20:51,700 --> 00:20:56,680
mean you have to use the protocol buffer

00:20:53,530 --> 00:20:59,290
wire format you can use JSON over or use

00:20:56,680 --> 00:21:01,750
this to define a JSON schema as well we

00:20:59,290 --> 00:21:04,060
also define our services so here we say

00:21:01,750 --> 00:21:07,090
when we call show with a driver ID then

00:21:04,060 --> 00:21:08,770
giving me back that driver response but

00:21:07,090 --> 00:21:11,080
we can also specify some properties

00:21:08,770 --> 00:21:16,030
about this API in the API definition

00:21:11,080 --> 00:21:18,700
like we can say it's indep it in so once

00:21:16,030 --> 00:21:20,290
we know the API that we're talking the

00:21:18,700 --> 00:21:22,840
thing that actually moves the data is

00:21:20,290 --> 00:21:25,270
this protocol called sake it's just a

00:21:22,840 --> 00:21:28,240
standard socket that has a request in a

00:21:25,270 --> 00:21:29,650
response it has a message ID Sokka is

00:21:28,240 --> 00:21:31,480
responsible for making sure the

00:21:29,650 --> 00:21:33,790
requester receives the response they

00:21:31,480 --> 00:21:36,010
asked for but there's this cool thing

00:21:33,790 --> 00:21:39,490
called the side channel and the side

00:21:36,010 --> 00:21:41,080
channel persists across requests so when

00:21:39,490 --> 00:21:43,180
service a makes across the service be

00:21:41,080 --> 00:21:44,980
and then serve as b goes to service see

00:21:43,180 --> 00:21:46,780
that side channel is consistent and

00:21:44,980 --> 00:21:48,910
something that you can immediately do

00:21:46,780 --> 00:21:52,060
with this is exception chaining so the

00:21:48,910 --> 00:21:53,860
service see blows up service be will

00:21:52,060 --> 00:21:55,750
throw the exact same error and that will

00:21:53,860 --> 00:21:57,640
propagate to service a service a will

00:21:55,750 --> 00:21:59,290
throw the exact same error so if you're

00:21:57,640 --> 00:22:01,330
on call for a service and you get paged

00:21:59,290 --> 00:22:03,010
immediately you can pinpoint that

00:22:01,330 --> 00:22:05,230
service see is the cause of your problem

00:22:03,010 --> 00:22:08,910
this this really speaks to our ability

00:22:05,230 --> 00:22:12,330
to respond to emergency situations

00:22:08,910 --> 00:22:14,620
alright I think we're ready to do this

00:22:12,330 --> 00:22:18,130
let's lose real quick look at the API

00:22:14,620 --> 00:22:19,660
that we're calling so we had

00:22:18,130 --> 00:22:21,160
have delivery orders which takes an

00:22:19,660 --> 00:22:23,770
empty request which is why there's no

00:22:21,160 --> 00:22:25,930
parameters on that turns an order

00:22:23,770 --> 00:22:28,060
response which just has a repeated list

00:22:25,930 --> 00:22:30,640
of orders and in protocol buffers a

00:22:28,060 --> 00:22:34,450
repeated field gets translated to order

00:22:30,640 --> 00:22:36,550
underscore list but it's got this thing

00:22:34,450 --> 00:22:39,610
here that says the multi pass user is

00:22:36,550 --> 00:22:42,190
required and we go back here no where am

00:22:39,610 --> 00:22:47,770
I saying that that I'm passing the user

00:22:42,190 --> 00:22:49,600
to this API but on top of our production

00:22:47,770 --> 00:22:51,490
stack we've been able to build some cool

00:22:49,600 --> 00:22:54,490
infrastructure for even components like

00:22:51,490 --> 00:22:57,580
multi pass so how multipass works is

00:22:54,490 --> 00:23:00,010
each client is the same and once it gets

00:22:57,580 --> 00:23:02,380
the credential back from the server the

00:23:00,010 --> 00:23:04,930
multi pass client will insert into the

00:23:02,380 --> 00:23:06,850
side channel the multi pass user so then

00:23:04,930 --> 00:23:09,190
service B is able to get access to that

00:23:06,850 --> 00:23:11,320
multipass user and service c is able to

00:23:09,190 --> 00:23:12,820
get access to that same user and the

00:23:11,320 --> 00:23:15,340
reason this is interesting is because if

00:23:12,820 --> 00:23:17,710
you have an action as recruits cope 228

00:23:15,340 --> 00:23:20,320
a specific user all downstream requests

00:23:17,710 --> 00:23:23,260
will also be scoped to that same user if

00:23:20,320 --> 00:23:24,700
you add on top of that mutual SSL you

00:23:23,260 --> 00:23:26,680
can see that this environment can get

00:23:24,700 --> 00:23:28,030
very complex and we have tools for

00:23:26,680 --> 00:23:29,860
visualizing this and this is actually

00:23:28,030 --> 00:23:32,230
something that someone can design an

00:23:29,860 --> 00:23:33,580
engineer and go look for where do we

00:23:32,230 --> 00:23:36,460
need new services where are we

00:23:33,580 --> 00:23:39,130
vulnerable how can we improve speed so

00:23:36,460 --> 00:23:41,770
so it's a very very different world that

00:23:39,130 --> 00:23:44,500
we've come to from where we started as a

00:23:41,770 --> 00:23:46,000
single rails app all right now we're

00:23:44,500 --> 00:23:48,280
really ready so we're going to make that

00:23:46,000 --> 00:23:50,170
request we're going to talk out to the

00:23:48,280 --> 00:23:51,910
peach to the kitchen service but if the

00:23:50,170 --> 00:23:53,860
pizza kitchen service is down it

00:23:51,910 --> 00:23:58,120
automatically fails over to the next one

00:23:53,860 --> 00:23:59,980
and we get our orders back then we're

00:23:58,120 --> 00:24:02,860
just going to do a simple loop over all

00:23:59,980 --> 00:24:04,810
of the orders and merge in our driver

00:24:02,860 --> 00:24:07,030
names because we stored our data in

00:24:04,810 --> 00:24:09,340
separate services but you'll notice

00:24:07,030 --> 00:24:11,320
there's no bang at the end of this show

00:24:09,340 --> 00:24:14,440
so we're actually going to go and do fan

00:24:11,320 --> 00:24:16,300
out and collect all of the all of the

00:24:14,440 --> 00:24:19,110
orders so that we're not waiting on

00:24:16,300 --> 00:24:21,490
requests and this returns a magic

00:24:19,110 --> 00:24:23,890
basically promise that you can then

00:24:21,490 --> 00:24:26,590
access future variables on our future

00:24:23,890 --> 00:24:29,140
data on and at the time when you need to

00:24:26,590 --> 00:24:30,730
instantiate it it'll actually wait for

00:24:29,140 --> 00:24:33,150
the requests to finish and return

00:24:30,730 --> 00:24:38,919
you the proper value that you asked for

00:24:33,150 --> 00:24:40,270
and that's it we just simply don't know

00:24:38,919 --> 00:24:44,679
if you can see that but this is just a

00:24:40,270 --> 00:24:46,630
simple HTML template that just renders

00:24:44,679 --> 00:24:48,730
our orders list and it all works

00:24:46,630 --> 00:24:51,400
together and it's something that someone

00:24:48,730 --> 00:24:54,460
who is just used to standard Ruby can

00:24:51,400 --> 00:24:56,620
come in and learn our RPC API and then

00:24:54,460 --> 00:24:59,890
develop big big products on top of it

00:24:56,620 --> 00:25:02,530
and this system gets very complex but

00:24:59,890 --> 00:25:05,710
it's not bleeding bleeding into the

00:25:02,530 --> 00:25:08,679
development story and the rest is sort

00:25:05,710 --> 00:25:10,510
of turtles all the way down the database

00:25:08,679 --> 00:25:12,640
we're actually using a connection pool

00:25:10,510 --> 00:25:14,740
from our service container but you get

00:25:12,640 --> 00:25:17,860
to use the sequel ORM exactly as you

00:25:14,740 --> 00:25:19,870
would expect jobs are very simple as

00:25:17,860 --> 00:25:22,299
does pretty much exactly as you would

00:25:19,870 --> 00:25:26,080
read it and its load balanced across the

00:25:22,299 --> 00:25:29,200
cluster for our PC out you can do

00:25:26,080 --> 00:25:31,960
synchronous asynchronous or asynchronous

00:25:29,200 --> 00:25:35,260
callback style and you can also specify

00:25:31,960 --> 00:25:37,150
properties about that connection and

00:25:35,260 --> 00:25:39,220
then we're also able to handle our PCN

00:25:37,150 --> 00:25:40,929
so on a rails controller that's from a

00:25:39,220 --> 00:25:42,790
web request but another service is

00:25:40,929 --> 00:25:44,679
making a request to you we give you a

00:25:42,790 --> 00:25:48,429
rails like controller that maps a

00:25:44,679 --> 00:25:50,770
protobuf into your rails api or sorry

00:25:48,429 --> 00:25:53,230
into your your Ruby API that looks like

00:25:50,770 --> 00:25:55,660
rails and the cool thing is no one

00:25:53,230 --> 00:25:58,660
externally knows whether you're a ruby

00:25:55,660 --> 00:26:03,210
app or a Java app so they are completely

00:25:58,660 --> 00:26:05,980
replaceable and lastly this message bus

00:26:03,210 --> 00:26:08,290
there's still a crap ton of code under

00:26:05,980 --> 00:26:10,630
here but there's not there's not a ruby

00:26:08,290 --> 00:26:12,790
crap ton of code is one implementation

00:26:10,630 --> 00:26:15,850
and the coolest thing is the people who

00:26:12,790 --> 00:26:18,040
develop our infrastructure for feats are

00:26:15,850 --> 00:26:20,770
able to rely on the service container

00:26:18,040 --> 00:26:23,410
job system but as a ruby developer as an

00:26:20,770 --> 00:26:25,540
application developer and and sorry just

00:26:23,410 --> 00:26:27,640
to be clear we have Java people who do

00:26:25,540 --> 00:26:29,919
application development as well but as

00:26:27,640 --> 00:26:32,559
an application developer i can pick to

00:26:29,919 --> 00:26:34,720
use sidekick or rescue in addition to my

00:26:32,559 --> 00:26:36,580
job system because it might fit the

00:26:34,720 --> 00:26:38,500
requirements better but the people

00:26:36,580 --> 00:26:40,390
developing infrastructure can rely on

00:26:38,500 --> 00:26:43,330
this this consistent behavior of the job

00:26:40,390 --> 00:26:45,190
system that has been built

00:26:43,330 --> 00:26:49,570
so it's a little anti-climactic right

00:26:45,190 --> 00:26:51,430
but the thing that makes it worse all of

00:26:49,570 --> 00:26:53,740
this time is we've got this new service

00:26:51,430 --> 00:26:57,340
call coming online called global name

00:26:53,740 --> 00:26:59,650
service which is a service discovery so

00:26:57,340 --> 00:27:01,270
typically in a in a environment where

00:26:59,650 --> 00:27:03,730
you have redundancy you have service

00:27:01,270 --> 00:27:05,350
that talks to resources and it goes

00:27:03,730 --> 00:27:07,150
through some sort of load balancer and

00:27:05,350 --> 00:27:09,820
the load balancer knows which nodes are

00:27:07,150 --> 00:27:12,430
out but as soon as you go multi data

00:27:09,820 --> 00:27:14,980
center the sort of standard operation is

00:27:12,430 --> 00:27:16,990
to pull the routing back into the

00:27:14,980 --> 00:27:22,510
application and say try my local data

00:27:16,990 --> 00:27:23,650
center then go remotely but G&S solves

00:27:22,510 --> 00:27:25,720
this problem by tying into the

00:27:23,650 --> 00:27:28,660
application lifecycle and as your app

00:27:25,720 --> 00:27:30,910
starts up it's going to say hi I would

00:27:28,660 --> 00:27:33,850
like to talk to service b and g NS says

00:27:30,910 --> 00:27:36,280
ok and it starts giving connections to

00:27:33,850 --> 00:27:39,340
your required services and we actually

00:27:36,280 --> 00:27:40,840
have a cluster of clients that have all

00:27:39,340 --> 00:27:43,060
the logic for load balancing and

00:27:40,840 --> 00:27:45,340
software so it will prefer the local

00:27:43,060 --> 00:27:47,140
data center I have thirty percent of

00:27:45,340 --> 00:27:49,180
requests are failing it'll try the next

00:27:47,140 --> 00:27:51,520
data center in this order and all that

00:27:49,180 --> 00:27:54,430
is handled by java client software

00:27:51,520 --> 00:27:58,450
inside of your Ruby application then you

00:27:54,430 --> 00:28:00,040
say I'm ready and gns comes online and

00:27:58,450 --> 00:28:02,050
starts riding in traffic and the

00:28:00,040 --> 00:28:04,600
question is you know what what does an

00:28:02,050 --> 00:28:06,640
application engineer have to do to get

00:28:04,600 --> 00:28:08,500
access to this functionality and the

00:28:06,640 --> 00:28:10,960
only thing is they just have to bundle

00:28:08,500 --> 00:28:17,410
up day mine cart and this is really the

00:28:10,960 --> 00:28:19,510
promise of this integrated world so the

00:28:17,410 --> 00:28:22,090
goal of mine cart is to allow us to have

00:28:19,510 --> 00:28:23,260
a consistent production story so that we

00:28:22,090 --> 00:28:26,710
can communicate with each other

00:28:23,260 --> 00:28:28,900
seamlessly and the same we have I

00:28:26,710 --> 00:28:32,500
believe 150 services that are registered

00:28:28,900 --> 00:28:34,150
I think 110 of them are deployed so

00:28:32,500 --> 00:28:36,460
that's an amount of services that we

00:28:34,150 --> 00:28:39,760
have but the idea is that anyone can

00:28:36,460 --> 00:28:41,260
come in have an idea build it see it in

00:28:39,760 --> 00:28:43,120
development working deploy to production

00:28:41,260 --> 00:28:45,100
and have confidence that is actually

00:28:43,120 --> 00:28:47,380
going to work and reduce that time so

00:28:45,100 --> 00:28:49,120
that as application engineers we're just

00:28:47,380 --> 00:28:51,850
getting back to shipping awesome and

00:28:49,120 --> 00:28:53,620
awesome product during during the last

00:28:51,850 --> 00:28:56,290
hack week we have a hack week every

00:28:53,620 --> 00:28:56,690
every quarter during a week through a

00:28:56,290 --> 00:28:58,870
team

00:28:56,690 --> 00:29:02,150
three was able to spin up a new service

00:28:58,870 --> 00:29:03,530
to new services in both production and

00:29:02,150 --> 00:29:05,540
they integrated with seven existing

00:29:03,530 --> 00:29:06,890
services in our production environment

00:29:05,540 --> 00:29:09,230
and they were able to do this without

00:29:06,890 --> 00:29:10,640
talking or without even talking to the

00:29:09,230 --> 00:29:12,440
teams without interfering with the other

00:29:10,640 --> 00:29:17,330
teams code just by being able to read

00:29:12,440 --> 00:29:18,800
those api's so I brought Daniel nyman

00:29:17,330 --> 00:29:20,300
and Matthew Todd with me and they're the

00:29:18,800 --> 00:29:22,100
ones who really made this dream come

00:29:20,300 --> 00:29:23,630
true and they would love to talk to you

00:29:22,100 --> 00:29:26,000
about it if you're interested I would

00:29:23,630 --> 00:29:31,010
also love to talk to you about it and

00:29:26,000 --> 00:29:33,190
with that are there any questions that's

00:29:31,010 --> 00:29:33,190
it

00:29:41,630 --> 00:29:49,040
all right I'm sorry thank you

00:30:27,910 --> 00:30:29,970

YouTube URL: https://www.youtube.com/watch?v=wk7uq4K7dzI


