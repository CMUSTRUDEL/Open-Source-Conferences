Title: LA RubyConf 2010 - Alternative Data Structures in Ruby
Publication date: 2020-01-29
Playlist: LA RubyConf 2010
Description: 
	Alternative Data Structures in Ruby by: Tyler McMullen
Captions: 
	00:00:14,190 --> 00:00:20,200
hi my name is Sylar I also work at

00:00:18,490 --> 00:00:22,300
script I'm going to be talking a little

00:00:20,200 --> 00:00:24,970
bit about alternative data structures in

00:00:22,300 --> 00:00:27,670
Ruby supply within said I don't actually

00:00:24,970 --> 00:00:31,650
know anything about no sequel so not

00:00:27,670 --> 00:00:31,650
going to talk about that so instead i'm

00:00:43,590 --> 00:00:50,399
alright guys again

00:00:46,100 --> 00:00:52,500
so now you might be asking yourself you

00:00:50,399 --> 00:00:53,670
know why should we talk about different

00:00:52,500 --> 00:00:55,109
data structures like you have your

00:00:53,670 --> 00:00:56,969
arrays you have your sets you have your

00:00:55,109 --> 00:01:00,649
hash is great that's enough for anybody

00:00:56,969 --> 00:01:02,909
right well sometimes that's enough but

00:01:00,649 --> 00:01:04,439
sometimes you need to do something a

00:01:02,909 --> 00:01:05,729
little bit different so again it's

00:01:04,439 --> 00:01:08,340
script like we deal with a huge amount

00:01:05,729 --> 00:01:11,520
of data and so on lots of occurrences

00:01:08,340 --> 00:01:12,960
I've found that like the normal data

00:01:11,520 --> 00:01:14,700
structures that use on a daily basis

00:01:12,960 --> 00:01:18,390
just don't always quite work they don't

00:01:14,700 --> 00:01:20,190
do they don't do exactly what I want all

00:01:18,390 --> 00:01:21,659
the time so you know why would I use a

00:01:20,190 --> 00:01:22,830
different data structure well there's

00:01:21,659 --> 00:01:24,869
basically three different reasons

00:01:22,830 --> 00:01:29,369
there's speed there's memory and there's

00:01:24,869 --> 00:01:32,390
clarity so get into that a little bit

00:01:29,369 --> 00:01:34,979
more so you know you know what you made

00:01:32,390 --> 00:01:37,440
excuse me so what's wrong with my

00:01:34,979 --> 00:01:41,580
favorite data structure X whatever X is

00:01:37,440 --> 00:01:42,990
probably nothing that the things I'm

00:01:41,580 --> 00:01:44,130
going to be talking about are just data

00:01:42,990 --> 00:01:47,880
structures that I've used in the past

00:01:44,130 --> 00:01:49,080
and you know also currently and it's

00:01:47,880 --> 00:01:50,610
just data structures that I find

00:01:49,080 --> 00:01:52,140
interesting the thought the point of

00:01:50,610 --> 00:01:53,700
this talk isn't really to like say you

00:01:52,140 --> 00:01:56,220
should use these data structures it's

00:01:53,700 --> 00:01:58,500
more like you should use data structures

00:01:56,220 --> 00:02:00,869
in general and to get you more

00:01:58,500 --> 00:02:02,580
interested in them so all right let's

00:02:00,869 --> 00:02:04,920
get right into it let's talk about blue

00:02:02,580 --> 00:02:07,410
filters so the point of a bloom filter

00:02:04,920 --> 00:02:09,660
is to test for existence in the set it's

00:02:07,410 --> 00:02:12,510
basically to say have I seen this item

00:02:09,660 --> 00:02:14,580
before it's a probabilistic data

00:02:12,510 --> 00:02:16,920
structure which means it can fail

00:02:14,580 --> 00:02:19,590
sometimes and you know how much it fails

00:02:16,920 --> 00:02:20,819
and how often it fails that's a tunable

00:02:19,590 --> 00:02:22,920
thing and we'll talk about that a little

00:02:20,819 --> 00:02:25,620
bit but really the point of a bloom

00:02:22,920 --> 00:02:28,080
filter is its memory usage it's pretty

00:02:25,620 --> 00:02:29,790
awesome so let's say that we have a

00:02:28,080 --> 00:02:31,650
hundred million strings let's say if

00:02:29,790 --> 00:02:33,330
they're about 100 characters long due to

00:02:31,650 --> 00:02:35,430
put these in a traditional set you'd be

00:02:33,330 --> 00:02:37,650
talking something like 10 gigabytes of

00:02:35,430 --> 00:02:38,940
memory so not really feasible more

00:02:37,650 --> 00:02:42,629
memory than most computers have right

00:02:38,940 --> 00:02:45,930
now in a bloom filter if you thought

00:02:42,629 --> 00:02:47,670
that like a 0 point 0 0 0 0 1 percent

00:02:45,930 --> 00:02:50,459
chance of failure is ok you can do the

00:02:47,670 --> 00:02:52,260
same thing in about 280 mex if a higher

00:02:50,459 --> 00:02:53,950
failure chances okay you can do the same

00:02:52,260 --> 00:02:56,110
thing 170 max

00:02:53,950 --> 00:03:00,340
these are much more reasonable numbers

00:02:56,110 --> 00:03:02,110
so how's the bloom filter work well a

00:03:00,340 --> 00:03:04,180
bloom filter is basically just a series

00:03:02,110 --> 00:03:06,370
of bits a series of check boxes which

00:03:04,180 --> 00:03:09,040
can be on or off you know they're

00:03:06,370 --> 00:03:11,650
indexed of course and so if we want to

00:03:09,040 --> 00:03:14,170
say here's my string here is my object

00:03:11,650 --> 00:03:17,110
that I'm adding to my set maybe it's the

00:03:14,170 --> 00:03:18,180
string to be or not to be first we run

00:03:17,110 --> 00:03:20,830
that through a series of hash functions

00:03:18,180 --> 00:03:22,690
now exactly how many hash functions use

00:03:20,830 --> 00:03:23,920
is a function of how many things are

00:03:22,690 --> 00:03:26,110
going to be adding in the size of the

00:03:23,920 --> 00:03:27,910
bloom filter but for now let's just say

00:03:26,110 --> 00:03:29,590
we're going to use two and so we run it

00:03:27,910 --> 00:03:31,780
through two hash functions and what pops

00:03:29,590 --> 00:03:34,329
out are two numbers one and five let's

00:03:31,780 --> 00:03:36,400
say so we set number so one and five

00:03:34,329 --> 00:03:37,540
great now we're going to add another one

00:03:36,400 --> 00:03:41,500
we're going to add that is the question

00:03:37,540 --> 00:03:42,760
and mind you like an 8-bit bloom filters

00:03:41,500 --> 00:03:47,230
not actually something you would want to

00:03:42,760 --> 00:03:49,000
use so so there is that but so we're

00:03:47,230 --> 00:03:50,980
going to add that as well and then we're

00:03:49,000 --> 00:03:53,260
going to start query whether tis nobler

00:03:50,980 --> 00:03:55,090
well so then we run that through the

00:03:53,260 --> 00:03:57,430
same two hash functions and out pops you

00:03:55,090 --> 00:03:59,709
numbers two and five and one of those is

00:03:57,430 --> 00:04:03,040
not set so we definitely have never seen

00:03:59,709 --> 00:04:04,959
the string before likewise we go back to

00:04:03,040 --> 00:04:06,609
the to be or not to be running through

00:04:04,959 --> 00:04:10,590
to you hash functions one and five and

00:04:06,609 --> 00:04:12,750
it's a match great well

00:04:10,590 --> 00:04:14,790
we can also get one that will give a

00:04:12,750 --> 00:04:16,620
false match we didn't actually see this

00:04:14,790 --> 00:04:20,400
one but the two things that it happen to

00:04:16,620 --> 00:04:22,139
get just happen to be set so it's a

00:04:20,400 --> 00:04:23,850
false match and like I said this this

00:04:22,139 --> 00:04:26,940
can be tuned just based on the size of

00:04:23,850 --> 00:04:28,889
the bloom filter so that is what makes

00:04:26,940 --> 00:04:31,110
it probabilistic so what is the point of

00:04:28,889 --> 00:04:32,699
a bloom filter then well let's say we're

00:04:31,110 --> 00:04:34,410
running something like a file server

00:04:32,699 --> 00:04:36,300
some file server that's it lives

00:04:34,410 --> 00:04:38,520
remotely has lots of files on it kind of

00:04:36,300 --> 00:04:39,780
expensive for us to query it let's say

00:04:38,520 --> 00:04:42,300
our tech chure looks something like that

00:04:39,780 --> 00:04:44,340
that we have a request that comes in

00:04:42,300 --> 00:04:46,680
goes directly to the file server if it

00:04:44,340 --> 00:04:51,330
exists 10 200 back if it doesn't exist

00:04:46,680 --> 00:04:52,950
in 404 great so maybe we find that we're

00:04:51,330 --> 00:04:54,750
getting a lot of 404 people are querying

00:04:52,950 --> 00:04:56,700
this like a lot and you know our file

00:04:54,750 --> 00:04:58,410
server is becoming overloaded great we

00:04:56,700 --> 00:05:00,419
need to find something to do instead of

00:04:58,410 --> 00:05:02,580
this well one thing we could do is add a

00:05:00,419 --> 00:05:05,520
bloom filter in between the request and

00:05:02,580 --> 00:05:08,250
the file server itself and the point of

00:05:05,520 --> 00:05:10,229
this would be to just say what is not in

00:05:08,250 --> 00:05:11,940
the file server we can't actually say

00:05:10,229 --> 00:05:14,190
what is in the file server we can say if

00:05:11,940 --> 00:05:16,530
something definitely is not and so in

00:05:14,190 --> 00:05:18,479
this case even if the loom filter gives

00:05:16,530 --> 00:05:19,950
us a false match great so we let that

00:05:18,479 --> 00:05:22,710
request through and the file server is

00:05:19,950 --> 00:05:24,720
just going to return a 404 anyway and so

00:05:22,710 --> 00:05:26,250
that's fine but we still get rid of like

00:05:24,720 --> 00:05:29,630
ninety-nine percent of their of the

00:05:26,250 --> 00:05:32,360
false request the file server just great

00:05:29,630 --> 00:05:34,640
so summing up bloom filters point is

00:05:32,360 --> 00:05:36,530
testing for existence in a set really

00:05:34,640 --> 00:05:38,120
the the reason you would use this is for

00:05:36,530 --> 00:05:41,360
its memory footprint and you know it

00:05:38,120 --> 00:05:44,660
also has a great speed so that's one

00:05:41,360 --> 00:05:47,330
colors okay so let's move on to a DK

00:05:44,660 --> 00:05:49,220
trees all right PK trees thins for a

00:05:47,330 --> 00:05:51,380
burkhard keller trees which is just the

00:05:49,220 --> 00:05:53,150
guys who invented it what it actually

00:05:51,380 --> 00:05:57,050
does though is somewhat more interesting

00:05:53,150 --> 00:06:00,050
it finds the best match even when a evil

00:05:57,050 --> 00:06:02,930
in an exact match does not exist in a

00:06:00,050 --> 00:06:04,970
set and the point of this is to reduce

00:06:02,930 --> 00:06:06,920
search based traditionally if you wanted

00:06:04,970 --> 00:06:08,570
to find the best match in a particular

00:06:06,920 --> 00:06:09,830
set of strings would say you would have

00:06:08,570 --> 00:06:11,720
to scan through the entire length of

00:06:09,830 --> 00:06:13,160
strings you know maybe use a priority

00:06:11,720 --> 00:06:14,810
queue to like keep the ones that are

00:06:13,160 --> 00:06:16,640
closest to what you're looking for but

00:06:14,810 --> 00:06:17,780
the point of a PK tree is to me get to

00:06:16,640 --> 00:06:20,630
make it so that you don't have to

00:06:17,780 --> 00:06:22,220
actually scan through the entire list so

00:06:20,630 --> 00:06:23,780
really the point the point is that it

00:06:22,220 --> 00:06:25,400
reduces the search space and it only

00:06:23,780 --> 00:06:28,190
works inside something called a metric

00:06:25,400 --> 00:06:30,110
space so what is a metric space well the

00:06:28,190 --> 00:06:31,520
term metric space comes from well

00:06:30,110 --> 00:06:33,050
traditionally comes from like Euclidean

00:06:31,520 --> 00:06:35,170
distance like actual distance between

00:06:33,050 --> 00:06:37,400
two points but it turns out that

00:06:35,170 --> 00:06:39,980
levenshtein distance also count to the

00:06:37,400 --> 00:06:41,680
metric space and so traditionally BK

00:06:39,980 --> 00:06:44,600
trees are used for spelling correctors

00:06:41,680 --> 00:06:48,050
in order to find the best matches for a

00:06:44,600 --> 00:06:50,210
particular word in a large dictionary so

00:06:48,050 --> 00:06:52,340
what this works off of is something

00:06:50,210 --> 00:06:54,290
called the triangle inequality which I

00:06:52,340 --> 00:06:55,670
added this slide to my talking like wow

00:06:54,290 --> 00:06:57,530
this is going to be good and he talked

00:06:55,670 --> 00:06:59,080
with triangle inequality it it's gonna

00:06:57,530 --> 00:07:02,949
be awesome

00:06:59,080 --> 00:07:04,780
so let's say we have these three nodes x

00:07:02,949 --> 00:07:08,020
y&z we know the distance between two of

00:07:04,780 --> 00:07:10,389
the nodes 1 and 4 technically this is

00:07:08,020 --> 00:07:12,520
the reverse triangle inequality but the

00:07:10,389 --> 00:07:16,379
point really is that using that we can

00:07:12,520 --> 00:07:19,960
determine we can determine a lower bound

00:07:16,379 --> 00:07:21,219
for the distance between Z and Y so we

00:07:19,960 --> 00:07:24,639
just plug in the numbers into our

00:07:21,219 --> 00:07:26,469
formula 4-1 and so we can say that the

00:07:24,639 --> 00:07:30,400
distance between Z and Y is greater than

00:07:26,469 --> 00:07:32,830
or equal to 3 and so if we if all we

00:07:30,400 --> 00:07:35,110
cared about was the distance if all we

00:07:32,830 --> 00:07:36,909
cared about was if the distance between

00:07:35,110 --> 00:07:38,530
them was less than 2 now we don't even

00:07:36,909 --> 00:07:41,650
need to run that distance function now

00:07:38,530 --> 00:07:44,259
we can just skip it so let's take a look

00:07:41,650 --> 00:07:45,969
in the actual example of this so let's

00:07:44,259 --> 00:07:47,740
say this is our dictionary we have six

00:07:45,969 --> 00:07:51,490
words there taser paste shave light

00:07:47,740 --> 00:07:52,930
pastor and pasta and so to start

00:07:51,490 --> 00:07:54,639
building our BK tree we're going to pick

00:07:52,930 --> 00:07:56,620
one of the words on there totally a

00:07:54,639 --> 00:07:59,139
random completely a random let's say

00:07:56,620 --> 00:08:00,400
it's paste hum so we're going to build a

00:07:59,139 --> 00:08:02,680
tree

00:08:00,400 --> 00:08:05,490
and it just so happens of course that

00:08:02,680 --> 00:08:08,710
our our tree works out perfectly and

00:08:05,490 --> 00:08:10,270
paces the root and pasta is one distance

00:08:08,710 --> 00:08:12,610
that's one edit distance away from paste

00:08:10,270 --> 00:08:15,070
pastors to edit distance tasers three

00:08:12,610 --> 00:08:18,490
edit distance etc going down the line

00:08:15,070 --> 00:08:20,440
there so now we want to query it we're

00:08:18,490 --> 00:08:21,910
going to say you know our user has typed

00:08:20,440 --> 00:08:23,740
in a particular word let's say it's

00:08:21,910 --> 00:08:25,990
pasta but they spelled it wrong to the

00:08:23,740 --> 00:08:27,960
pasta so now we want to find the words

00:08:25,990 --> 00:08:30,190
that are closest to this in our tree so

00:08:27,960 --> 00:08:32,650
we compare it to the roof we run our

00:08:30,190 --> 00:08:34,029
distance function and great it's one but

00:08:32,650 --> 00:08:35,740
you know so what do we do to get the

00:08:34,029 --> 00:08:39,459
rest of them well using that triangle

00:08:35,740 --> 00:08:41,890
inequality we can determine that only

00:08:39,459 --> 00:08:43,599
two of the words on there are only two

00:08:41,890 --> 00:08:46,300
of the branches off of the root are

00:08:43,599 --> 00:08:48,520
actually even feasible given the

00:08:46,300 --> 00:08:50,620
triangle inequality given that we know

00:08:48,520 --> 00:08:51,880
the distance between pasta and pasta and

00:08:50,620 --> 00:08:54,279
paste and we know the distance between

00:08:51,880 --> 00:08:56,860
paste in pasta and paste and pastor we

00:08:54,279 --> 00:08:58,750
can say that only those two are actually

00:08:56,860 --> 00:09:01,360
interesting so we can just get rid of

00:08:58,750 --> 00:09:04,270
all the other ones so now it turns out

00:09:01,360 --> 00:09:06,670
that pasta and paste are the only ones

00:09:04,270 --> 00:09:07,990
that actually match you know if they're

00:09:06,670 --> 00:09:11,140
the only ones that are interesting to us

00:09:07,990 --> 00:09:13,600
but really the point of this is that we

00:09:11,140 --> 00:09:16,930
got to not do our comparison across

00:09:13,600 --> 00:09:18,190
everything else you know pazar shave and

00:09:16,930 --> 00:09:19,600
light did not even have to run this

00:09:18,190 --> 00:09:20,830
distance function so here we got rid of

00:09:19,600 --> 00:09:23,830
fifty percent of the queries that we

00:09:20,830 --> 00:09:25,420
would have had to do previously and so

00:09:23,830 --> 00:09:28,330
extending the BK true you know maybe we

00:09:25,420 --> 00:09:30,010
have lots of words here and you can kind

00:09:28,330 --> 00:09:33,130
of see you know maybe we take that pasta

00:09:30,010 --> 00:09:35,020
compared to paste and it turns out pasta

00:09:33,130 --> 00:09:36,910
and Pastner in each of those like

00:09:35,020 --> 00:09:38,560
continuing down the line we only end up

00:09:36,910 --> 00:09:42,480
having to query a very small percentage

00:09:38,560 --> 00:09:45,190
of the tree which is fantastic so

00:09:42,480 --> 00:09:46,810
summing up BK trees

00:09:45,190 --> 00:09:47,890
now most often these are used for

00:09:46,810 --> 00:09:50,290
spelling characters but you could also

00:09:47,890 --> 00:09:52,060
use a BK tree for something like finding

00:09:50,290 --> 00:09:53,770
everything that's particularly close to

00:09:52,060 --> 00:09:56,170
something on a map for instance you

00:09:53,770 --> 00:09:57,580
could use it for that as well you know

00:09:56,170 --> 00:09:59,860
it works in any metric space but it only

00:09:57,580 --> 00:10:01,330
works in metric spaces and the point is

00:09:59,860 --> 00:10:04,410
to reduce the search base to reduce the

00:10:01,330 --> 00:10:06,820
number of functions that you have to run

00:10:04,410 --> 00:10:08,740
all right that about covers it for BK

00:10:06,820 --> 00:10:11,290
trees so let's move on to another one go

00:10:08,740 --> 00:10:12,850
to splay tree so before I give them

00:10:11,290 --> 00:10:14,230
display trees I'm going to go off on a

00:10:12,850 --> 00:10:16,390
little tangent here about access

00:10:14,230 --> 00:10:18,100
patterns so normally when people think

00:10:16,390 --> 00:10:19,420
about data structures they're like well

00:10:18,100 --> 00:10:21,580
you know i'm going to query these

00:10:19,420 --> 00:10:22,720
different keys and you know they kind of

00:10:21,580 --> 00:10:24,970
assume that it's going to be an even

00:10:22,720 --> 00:10:26,470
distribution between the different keys

00:10:24,970 --> 00:10:28,750
that you're going to be querying i do

00:10:26,470 --> 00:10:30,550
this myself a lot but it turns out that

00:10:28,750 --> 00:10:34,000
you know that's actually very rarely the

00:10:30,550 --> 00:10:35,350
case normally the actual like worrying

00:10:34,000 --> 00:10:36,460
that you do against that data structure

00:10:35,350 --> 00:10:38,770
is going to look a lot more like a power

00:10:36,460 --> 00:10:40,600
law for instance like a lot of the work

00:10:38,770 --> 00:10:42,490
i end up doing is in text analysis and

00:10:40,600 --> 00:10:44,470
an X analysis there's something known as

00:10:42,490 --> 00:10:46,390
zips law which states that you know

00:10:44,470 --> 00:10:48,730
basically in any human natural language

00:10:46,390 --> 00:10:52,270
you're going to have a power law of

00:10:48,730 --> 00:10:57,720
words so that kind of applies especially

00:10:52,270 --> 00:11:00,490
display trees because splay cherries are

00:10:57,720 --> 00:11:03,220
such that like The even the access

00:11:00,490 --> 00:11:04,810
pattern the better so like you I'm sure

00:11:03,220 --> 00:11:06,690
you can find some like immediate uses

00:11:04,810 --> 00:11:08,920
for this how about lake web caches

00:11:06,690 --> 00:11:11,710
especially web caches for something like

00:11:08,920 --> 00:11:14,200
involving a time data so for instance

00:11:11,710 --> 00:11:16,270
you have a blog a very popular blog and

00:11:14,200 --> 00:11:17,920
let's say you know most of the traffic

00:11:16,270 --> 00:11:19,720
that you currently get are going to your

00:11:17,920 --> 00:11:21,670
latest blog post

00:11:19,720 --> 00:11:23,470
so a splay tree would be perfect you

00:11:21,670 --> 00:11:27,100
know if memcache wasn't good enough or

00:11:23,470 --> 00:11:28,839
something like that but anyway so split

00:11:27,100 --> 00:11:30,100
tree is a self-balancing binary tree and

00:11:28,839 --> 00:11:32,220
the point of it is that it brings the

00:11:30,100 --> 00:11:35,230
most accessed items closer to the root

00:11:32,220 --> 00:11:36,670
so now maybe you have your binary tree

00:11:35,230 --> 00:11:39,970
look something like this perfect little

00:11:36,670 --> 00:11:43,029
binary tree great so now we're going to

00:11:39,970 --> 00:11:45,069
query for number nine so what happens

00:11:43,029 --> 00:11:46,540
while we walk down our tree there to

00:11:45,069 --> 00:11:49,660
number nine and then we do what's called

00:11:46,540 --> 00:11:52,089
a splay operation we start doing tree

00:11:49,660 --> 00:11:54,939
rotations until nine gets back to the

00:11:52,089 --> 00:11:56,290
root now you have you saying yourself

00:11:54,939 --> 00:11:58,089
well we had this perfect binary tree

00:11:56,290 --> 00:11:59,709
before why would you want to do that you

00:11:58,089 --> 00:12:01,990
know why why would I want this now like

00:11:59,709 --> 00:12:04,180
extremely unbalanced binary tree well

00:12:01,990 --> 00:12:06,339
the point of this is to get the most

00:12:04,180 --> 00:12:09,490
accessed items toward the root of the

00:12:06,339 --> 00:12:11,350
tree and so you know maybe you know so

00:12:09,490 --> 00:12:13,120
the next time that nine is queried it's

00:12:11,350 --> 00:12:16,629
going to come up immediately no delay at

00:12:13,120 --> 00:12:18,040
all great now of course you know if five

00:12:16,629 --> 00:12:19,410
is queried it's going to have to walk

00:12:18,040 --> 00:12:21,970
all the way down there and then like

00:12:19,410 --> 00:12:23,519
rotate it back up to the top but the

00:12:21,970 --> 00:12:26,199
idea is that this is especially good for

00:12:23,519 --> 00:12:30,819
for queries that I have extremely uneven

00:12:26,199 --> 00:12:32,230
access patterns so splay trees a for

00:12:30,819 --> 00:12:36,339
very uneven access patterns great for

00:12:32,230 --> 00:12:37,389
caches garbage collectors etc again like

00:12:36,339 --> 00:12:39,220
this isn't actually something that

00:12:37,389 --> 00:12:40,870
you're probably going to use on a daily

00:12:39,220 --> 00:12:41,980
basis but it's kind of cool to know

00:12:40,870 --> 00:12:43,120
about these kinds of things and get you

00:12:41,980 --> 00:12:44,079
interested in like different data

00:12:43,120 --> 00:12:46,980
structures so you can find something

00:12:44,079 --> 00:12:51,959
that does work for your situation

00:12:46,980 --> 00:12:51,959
now we're gonna move on to tries yeah

00:12:57,940 --> 00:13:01,880
well in this lake in a traditional splay

00:13:00,500 --> 00:13:03,260
tree you would do it on every access

00:13:01,880 --> 00:13:05,480
like I said this is for like extremely

00:13:03,260 --> 00:13:07,970
uneven access patterns and I have some

00:13:05,480 --> 00:13:10,070
benchmarks that actually work out to the

00:13:07,970 --> 00:13:11,240
show that you know in very uneven access

00:13:10,070 --> 00:13:14,950
time that works out to be quite a bit

00:13:11,240 --> 00:13:14,950
faster than a hash table turns out

00:13:18,360 --> 00:13:23,370
you move it all the way to the root each

00:13:20,160 --> 00:13:27,269
time seems kind of weird it turns out

00:13:23,370 --> 00:13:28,560
that it works sometimes so last year the

00:13:27,269 --> 00:13:30,329
structure we're going to look at it as a

00:13:28,560 --> 00:13:34,320
try this is actually my favorite data

00:13:30,329 --> 00:13:36,630
structure so it's pretty cool so why is

00:13:34,320 --> 00:13:39,060
it try cool well turns out that it has

00:13:36,630 --> 00:13:41,160
order one look up has order one ad has

00:13:39,060 --> 00:13:42,839
order one removal you do order traversal

00:13:41,160 --> 00:13:44,220
you can do prefix matching basically

00:13:42,839 --> 00:13:47,760
it's like a hash table except better in

00:13:44,220 --> 00:13:51,329
every way oh that's not actually true

00:13:47,760 --> 00:13:52,589
but you know anyway and then depending

00:13:51,329 --> 00:13:54,750
on the implementation of it you can have

00:13:52,589 --> 00:13:57,420
really good memory usage so that's also

00:13:54,750 --> 00:14:00,300
awesome so how's the try work and what

00:13:57,420 --> 00:14:03,680
is it try do so this is what an empty

00:14:00,300 --> 00:14:05,579
tray looks like just have the root note

00:14:03,680 --> 00:14:06,480
now we're going to add a trick we're

00:14:05,579 --> 00:14:08,910
going to add a string to it we're going

00:14:06,480 --> 00:14:10,470
to add the string thin and so we just

00:14:08,910 --> 00:14:12,899
add four little notes there one

00:14:10,470 --> 00:14:15,329
following the other thin we're going to

00:14:12,899 --> 00:14:16,890
another one trap and so you can start to

00:14:15,329 --> 00:14:19,350
see they're like we're starting to share

00:14:16,890 --> 00:14:21,240
like the the upper node so trap and thin

00:14:19,350 --> 00:14:23,310
both share the tea and we had another

00:14:21,240 --> 00:14:24,720
one we're going to add bar and we get

00:14:23,310 --> 00:14:27,269
burp

00:14:24,720 --> 00:14:29,399
and so you can see that like the point

00:14:27,269 --> 00:14:30,959
is that it starts like a thumb as you

00:14:29,399 --> 00:14:33,930
build a tree they start to share more

00:14:30,959 --> 00:14:35,639
and more of the individual tree of the

00:14:33,930 --> 00:14:37,290
individual notes rather so how's the

00:14:35,639 --> 00:14:40,079
query work now let's say we're going to

00:14:37,290 --> 00:14:42,860
query for trap start the root node we

00:14:40,079 --> 00:14:47,509
walk down each letter at a time p are a

00:14:42,860 --> 00:14:49,649
B and success you know we found trap and

00:14:47,509 --> 00:14:51,089
let's say we're going to do a false

00:14:49,649 --> 00:14:52,649
query something that's not in there it's

00:14:51,089 --> 00:14:57,629
going to look like this I start at the

00:14:52,649 --> 00:15:01,470
root node be you and fail so it stops

00:14:57,629 --> 00:15:04,800
there you know it's basically like the

00:15:01,470 --> 00:15:06,209
pee in buckets isn't there so that's as

00:15:04,800 --> 00:15:08,649
far as we go and we know that it's not

00:15:06,209 --> 00:15:11,499
in the try at all

00:15:08,649 --> 00:15:14,199
so here's an example of where a tri is

00:15:11,499 --> 00:15:15,939
pretty cool as an autocomplete let say

00:15:14,199 --> 00:15:18,910
you're going to make a wrecked a rack

00:15:15,939 --> 00:15:20,860
based autocomplete er well it turns out

00:15:18,910 --> 00:15:24,009
that you can do that with most tries in

00:15:20,860 --> 00:15:25,420
just like that so you can see there we

00:15:24,009 --> 00:15:26,920
have our initialized method which loads

00:15:25,420 --> 00:15:29,259
a whole bunch of words into the try and

00:15:26,920 --> 00:15:32,230
an hour call method to match the rack

00:15:29,259 --> 00:15:35,470
API we do a rack request new on the

00:15:32,230 --> 00:15:37,749
environment we get our word which I

00:15:35,470 --> 00:15:41,529
apparently forgot to put into a variable

00:15:37,749 --> 00:15:42,550
that's cool and then we return it you

00:15:41,529 --> 00:15:44,889
know so we're just going to return the

00:15:42,550 --> 00:15:48,939
list of children of a particular prefix

00:15:44,889 --> 00:15:53,529
to JSON and that's really it like tries

00:15:48,939 --> 00:15:55,199
are pretty cool for that so it looks

00:15:53,529 --> 00:15:57,100
like I'm ending incredibly early

00:15:55,199 --> 00:15:59,920
apparently I've been talking really fast

00:15:57,100 --> 00:16:01,899
sorry about that but really my

00:15:59,920 --> 00:16:03,610
conclusion is pretty simple like data

00:16:01,899 --> 00:16:05,170
structures are cool you know maybe you

00:16:03,610 --> 00:16:07,420
won't find any particular use in these

00:16:05,170 --> 00:16:08,800
data structures but hopefully the

00:16:07,420 --> 00:16:09,939
hopefully this will kind of get you

00:16:08,800 --> 00:16:11,199
interested to look at other data

00:16:09,939 --> 00:16:13,300
structures and find something that is

00:16:11,199 --> 00:16:14,920
interesting it does work for you so uh

00:16:13,300 --> 00:16:16,120
hopefully you guys have lots of

00:16:14,920 --> 00:16:18,120
questions

00:16:16,120 --> 00:16:18,120
ah

00:16:25,750 --> 00:16:30,610
so the idea with the bloom filter is to

00:16:28,270 --> 00:16:32,200
not rely on it being correct a hundred

00:16:30,610 --> 00:16:33,430
percent of the time which is kind of

00:16:32,200 --> 00:16:36,190
which is why i like the file server

00:16:33,430 --> 00:16:37,750
example there because even if it is

00:16:36,190 --> 00:16:39,190
wrong like it's just going to pass

00:16:37,750 --> 00:16:40,660
through and still get the correct answer

00:16:39,190 --> 00:16:44,970
so really the point is to just use it as

00:16:40,660 --> 00:16:46,600
a filter I like expect false positives

00:16:44,970 --> 00:16:48,960
exactly you will never get false

00:16:46,600 --> 00:16:48,960
negatives

00:16:53,230 --> 00:16:59,330
yeah exactly

00:16:57,270 --> 00:16:59,330
you

00:17:00,430 --> 00:17:03,660
yeah yeah exactly

00:17:15,390 --> 00:17:19,420
how do I do it I work with a bunch of

00:17:17,980 --> 00:17:24,430
really smart people and I asked them

00:17:19,420 --> 00:17:25,600
generally oh uh huh another way to do it

00:17:24,430 --> 00:17:27,520
I don't know I spend a lot of time on

00:17:25,600 --> 00:17:28,630
Wikipedia is well just like reading

00:17:27,520 --> 00:17:32,320
about different data structures and

00:17:28,630 --> 00:17:36,700
reading books and Mark is holding up

00:17:32,320 --> 00:17:39,120
something that I cannot read oh yes

00:17:36,700 --> 00:17:40,690
exactly

00:17:39,120 --> 00:17:43,500
I

00:17:40,690 --> 00:17:43,500
anything else

00:17:45,430 --> 00:17:51,160
I'm sorry can you say it again

00:17:48,520 --> 00:17:53,110
Oh burkhard Keller is a the paper

00:17:51,160 --> 00:17:56,070
written in 1972 by a guy named Burke

00:17:53,110 --> 00:17:56,070
Garden of guy named killer

00:18:01,610 --> 00:18:06,230
sure well I mean that that auto complete

00:18:04,220 --> 00:18:07,520
our example like that's actually what

00:18:06,230 --> 00:18:10,330
our auto complete ER looks like four

00:18:07,520 --> 00:18:12,950
tags and scram it's really very simple

00:18:10,330 --> 00:18:14,870
additionally like i have i've been

00:18:12,950 --> 00:18:17,270
working on a spelling corrector for the

00:18:14,870 --> 00:18:19,970
search engine that we use its grift so

00:18:17,270 --> 00:18:21,620
i'm using a BK tree for that i haven't

00:18:19,970 --> 00:18:23,480
actually used splay trees but i know

00:18:21,620 --> 00:18:25,100
several other people who work on some

00:18:23,480 --> 00:18:27,640
graphics related stuff that script have

00:18:25,100 --> 00:18:27,640
so

00:18:33,389 --> 00:18:38,369
I should have added a slide for that for

00:18:35,789 --> 00:18:41,369
different links so I have a couple

00:18:38,369 --> 00:18:44,129
implementations NC with riri bindings on

00:18:41,369 --> 00:18:45,989
my github github.com / Tyler but then

00:18:44,129 --> 00:18:47,579
there's also a few other ones if you

00:18:45,989 --> 00:18:50,429
just search really if you just search

00:18:47,579 --> 00:18:52,289
like github or Google for like Ruby

00:18:50,429 --> 00:18:55,969
splay tree or Ruby be a tree you'll

00:18:52,289 --> 00:18:55,969
you'll find quite a few good hits there

00:19:00,630 --> 00:19:05,370
um three is it for a couple different

00:19:02,730 --> 00:19:07,470
things but the main thing is that tags

00:19:05,370 --> 00:19:08,820
so we have a tag autocomplete ER as you

00:19:07,470 --> 00:19:13,310
start typing a tag it'll figure out

00:19:08,820 --> 00:19:13,310
which one you actually want very simple

00:19:13,630 --> 00:19:18,160
yes exactly keeps it out of the rails

00:19:16,330 --> 00:19:21,450
app so the you know really quite what

00:19:18,160 --> 00:19:21,450
was really quick response times

00:19:21,470 --> 00:19:24,559
anything up

00:19:24,659 --> 00:19:29,059

YouTube URL: https://www.youtube.com/watch?v=Mti-bblDAek


