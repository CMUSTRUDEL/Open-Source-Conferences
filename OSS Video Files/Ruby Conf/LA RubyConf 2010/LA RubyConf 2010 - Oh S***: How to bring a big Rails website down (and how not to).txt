Title: LA RubyConf 2010 - Oh S***: How to bring a big Rails website down (and how not to)
Publication date: 2020-01-29
Playlist: LA RubyConf 2010
Description: 
	Oh S***: How to bring a big Rails website down (and how not to) by: Tim Morgan
Captions: 
	00:00:13,740 --> 00:00:20,260
hi okay

00:00:17,650 --> 00:00:21,939
my talk is called ohshit lessons and

00:00:20,260 --> 00:00:27,130
continually baking a huge website

00:00:21,939 --> 00:00:29,410
everyone hear me okay okay look good my

00:00:27,130 --> 00:00:31,810
name is Tim Morgan I'm a senior rails

00:00:29,410 --> 00:00:33,430
developer at script I was hired at

00:00:31,810 --> 00:00:35,350
script as kind of like a rails guru

00:00:33,430 --> 00:00:36,760
because I knew the API really well but I

00:00:35,350 --> 00:00:39,640
didn't really have a lot of experience

00:00:36,760 --> 00:00:43,210
in scaling that was kind of a trap trial

00:00:39,640 --> 00:00:47,110
by fire for me at script I learned a lot

00:00:43,210 --> 00:00:48,489
of things the hard way and so this talk

00:00:47,110 --> 00:00:50,309
isn't gonna be about like security

00:00:48,489 --> 00:00:52,210
vulnerabilities or anything like that

00:00:50,309 --> 00:00:54,549
instead I'm going to talk about what

00:00:52,210 --> 00:00:57,549
I've learned as RLS developer for script

00:00:54,549 --> 00:00:59,979
I like doing it this way like how I

00:00:57,549 --> 00:01:01,839
break it because I think engineers sort

00:00:59,979 --> 00:01:03,519
of we we learn the most when we break

00:01:01,839 --> 00:01:05,740
things you know when we're knee-deep in

00:01:03,519 --> 00:01:07,150
the debugger and stuff like that that's

00:01:05,740 --> 00:01:08,380
when we when we really start to

00:01:07,150 --> 00:01:11,740
understand rails and the stuff that

00:01:08,380 --> 00:01:13,990
we're working with so a bit about scribd

00:01:11,740 --> 00:01:16,630
scribd is a really really large Ruby on

00:01:13,990 --> 00:01:19,689
Rails website here's our quantcast page

00:01:16,630 --> 00:01:22,780
we do about 40 million users per month

00:01:19,689 --> 00:01:25,720
in traffic we serve 36 megabytes of

00:01:22,780 --> 00:01:28,360
traffic per second and every day 50,000

00:01:25,720 --> 00:01:31,570
new documents are uploaded into amazon

00:01:28,360 --> 00:01:33,670
s3 my point isn't really to dazzle you

00:01:31,570 --> 00:01:34,990
with statistics is to you know let you

00:01:33,670 --> 00:01:37,090
know that when you have a website this

00:01:34,990 --> 00:01:38,980
big it becomes really really really easy

00:01:37,090 --> 00:01:40,870
to break it if you don't understand

00:01:38,980 --> 00:01:43,930
exactly what you're doing and exactly

00:01:40,870 --> 00:01:45,610
what rails is doing so i'll be taking

00:01:43,930 --> 00:01:48,790
you through some of the more infamous

00:01:45,610 --> 00:01:52,810
mistakes that I've made these mistakes

00:01:48,790 --> 00:01:57,340
are almost always problems of scale this

00:01:52,810 --> 00:01:59,050
is stolen it's almost always problems of

00:01:57,340 --> 00:02:00,940
scale and stuff that you you wouldn't

00:01:59,050 --> 00:02:03,100
even think twice about writing if you

00:02:00,940 --> 00:02:05,190
had you know three thousand users per

00:02:03,100 --> 00:02:07,930
day on a website or like a hobby site

00:02:05,190 --> 00:02:10,420
but you know once once your traffic

00:02:07,930 --> 00:02:11,270
explodes it can really come back to bite

00:02:10,420 --> 00:02:13,970
you

00:02:11,270 --> 00:02:16,250
and almost all of them center around how

00:02:13,970 --> 00:02:17,690
rails uses the database and script we is

00:02:16,250 --> 00:02:19,580
my sequel so there's going to be some my

00:02:17,690 --> 00:02:22,700
sequel specific stuff in here but I also

00:02:19,580 --> 00:02:24,560
try to generalize it a bit and I try to

00:02:22,700 --> 00:02:26,870
talk about post grads and Oracle if

00:02:24,560 --> 00:02:28,640
anybody's using that too but it is going

00:02:26,870 --> 00:02:31,600
to be a little my sequel specific so

00:02:28,640 --> 00:02:34,910
bear with me if you don't use my sequel

00:02:31,600 --> 00:02:36,740
ok so my most devastating mistake

00:02:34,910 --> 00:02:41,210
Everett script which I will talk about

00:02:36,740 --> 00:02:44,060
in a bit resulted in our DBA giving me a

00:02:41,210 --> 00:02:47,330
few good pointers it actually resulted

00:02:44,060 --> 00:02:52,340
in yelling a few good pointers here's

00:02:47,330 --> 00:02:54,470
his log from campfire basically in short

00:02:52,340 --> 00:02:56,780
what he was telling me to do is to

00:02:54,470 --> 00:02:59,450
understand what the code is doing and

00:02:56,780 --> 00:03:01,520
it's crucially important because rails

00:02:59,450 --> 00:03:03,800
cannot be relied upon to generate the

00:03:01,520 --> 00:03:05,570
best query for every situation and in

00:03:03,800 --> 00:03:07,970
fact sometimes they can't even be relied

00:03:05,570 --> 00:03:11,000
upon to generate a good query for the

00:03:07,970 --> 00:03:12,980
situation and also i hope i hope

00:03:11,000 --> 00:03:15,920
everyone is familiar with the sequel

00:03:12,980 --> 00:03:18,140
explained and explained analyze tools it

00:03:15,920 --> 00:03:19,850
not you just explain in front of a query

00:03:18,140 --> 00:03:20,990
it doesn't run the query so if the query

00:03:19,850 --> 00:03:22,520
slow you don't have to worry about that

00:03:20,990 --> 00:03:24,320
it just gives you some information on

00:03:22,520 --> 00:03:27,020
how it would run the query and that's

00:03:24,320 --> 00:03:30,580
very very useful and you'll see some

00:03:27,020 --> 00:03:34,130
examples of that in the upcoming slides

00:03:30,580 --> 00:03:36,230
so basically i'll oil it down to you for

00:03:34,130 --> 00:03:39,140
a few points every time you add a

00:03:36,230 --> 00:03:40,610
feature you should you know run you

00:03:39,140 --> 00:03:42,530
should run your feature on your site and

00:03:40,610 --> 00:03:45,050
look at your query log unless it's

00:03:42,530 --> 00:03:46,700
absolutely most trivial of features and

00:03:45,050 --> 00:03:48,760
you know it doesn't touch the database

00:03:46,700 --> 00:03:51,230
you should be looking at your query log

00:03:48,760 --> 00:03:53,630
you should understand what each query

00:03:51,230 --> 00:03:55,190
does and no it's not a problem or if you

00:03:53,630 --> 00:03:57,320
suspect it might be a problem you should

00:03:55,190 --> 00:04:01,940
be explaining that query you should have

00:03:57,320 --> 00:04:03,590
my sigil explain that query if you test

00:04:01,940 --> 00:04:05,720
with a large database you'll get

00:04:03,590 --> 00:04:08,180
frustrated at how slow some parts of

00:04:05,720 --> 00:04:10,820
your code are and well guess what your

00:04:08,180 --> 00:04:12,440
users are frustrated too I'm actually I

00:04:10,820 --> 00:04:14,450
this is actually a little hypocritical

00:04:12,440 --> 00:04:16,220
of me because I don't always do this but

00:04:14,450 --> 00:04:19,790
I what I have that I found it really

00:04:16,220 --> 00:04:21,980
useful I know that with rails three

00:04:19,790 --> 00:04:25,250
point oh we're going to be a little more

00:04:21,980 --> 00:04:27,320
agnostic with our 00 RM and maybe some

00:04:25,250 --> 00:04:29,270
of you have used data mapper data mapper

00:04:27,320 --> 00:04:31,490
has a really cool tool called DM

00:04:29,270 --> 00:04:34,340
sweatshop which gives factories double

00:04:31,490 --> 00:04:36,650
duty it lets you erect a fully populated

00:04:34,340 --> 00:04:38,330
production database using your factories

00:04:36,650 --> 00:04:41,360
and you can you know with arbitrary

00:04:38,330 --> 00:04:44,240
numbers of rows so you can in a small

00:04:41,360 --> 00:04:45,680
amount of time have a database bigger

00:04:44,240 --> 00:04:47,480
than you would expect to have in

00:04:45,680 --> 00:04:48,740
production and then when you play with

00:04:47,480 --> 00:04:51,680
your site you might notice some things

00:04:48,740 --> 00:04:53,570
are crucially slow and you know you'll

00:04:51,680 --> 00:04:55,630
be just as frustrated as your users

00:04:53,570 --> 00:04:58,450
would be

00:04:55,630 --> 00:05:01,090
and lastly you should pay close

00:04:58,450 --> 00:05:02,650
attention to your indexes hopefully

00:05:01,090 --> 00:05:05,110
everyone here understands the basics of

00:05:02,650 --> 00:05:06,910
indexes if you have a user's table with

00:05:05,110 --> 00:05:08,740
a login column and you need to look up

00:05:06,910 --> 00:05:11,620
users by login you need an index on the

00:05:08,740 --> 00:05:14,620
login column things get more complicated

00:05:11,620 --> 00:05:17,110
with more complicated queries indexes

00:05:14,620 --> 00:05:18,850
are very database specific my sequel and

00:05:17,110 --> 00:05:22,060
postgres use very different strategies

00:05:18,850 --> 00:05:23,350
for for using indexes inquiries so it's

00:05:22,060 --> 00:05:25,570
important to understand how your

00:05:23,350 --> 00:05:29,350
database uses indexes and what indexes

00:05:25,570 --> 00:05:31,570
you'll need for different queries so

00:05:29,350 --> 00:05:33,070
we'll start with the anecdotes the first

00:05:31,570 --> 00:05:35,110
ones a subject that's been a little

00:05:33,070 --> 00:05:38,650
beaten to death already but I've added

00:05:35,110 --> 00:05:40,920
what's hopefully a novel twist to it and

00:05:38,650 --> 00:05:43,450
it's the problem with finding batches

00:05:40,920 --> 00:05:46,540
and what we're talking about here is

00:05:43,450 --> 00:05:48,430
when you need to update every row or a

00:05:46,540 --> 00:05:49,600
lot of rows in your table but it's not

00:05:48,430 --> 00:05:52,270
the kind of thing you can do with a

00:05:49,600 --> 00:05:54,490
sequel update statement you need to

00:05:52,270 --> 00:05:56,710
instantiate every row as an active

00:05:54,490 --> 00:05:58,630
record object and you need to you know

00:05:56,710 --> 00:06:00,490
perform some kind of operation like you

00:05:58,630 --> 00:06:01,930
know downloading from s3 and uploading

00:06:00,490 --> 00:06:04,240
to a different bucket or something like

00:06:01,930 --> 00:06:06,160
that where you can't just do it in

00:06:04,240 --> 00:06:08,650
sequel obviously

00:06:06,160 --> 00:06:11,710
so I mean hopefully everyone sees the

00:06:08,650 --> 00:06:13,510
problem with this if you do user dot all

00:06:11,710 --> 00:06:15,610
you're going to instantiate every single

00:06:13,510 --> 00:06:17,290
record in your database all at once if

00:06:15,610 --> 00:06:19,480
you can even fit it in memory if you

00:06:17,290 --> 00:06:22,960
have a lot of users it's still going to

00:06:19,480 --> 00:06:24,580
be very slow and of course it executes a

00:06:22,960 --> 00:06:28,810
very slow query and select star from

00:06:24,580 --> 00:06:30,850
users so that in rails 23 we get the

00:06:28,810 --> 00:06:33,580
find each method which calls find in

00:06:30,850 --> 00:06:36,130
batches it solves this problem hopefully

00:06:33,580 --> 00:06:38,490
most of you know how this works it grabs

00:06:36,130 --> 00:06:41,230
the first n rose from the table and

00:06:38,490 --> 00:06:43,120
looks at the ID of the last item in the

00:06:41,230 --> 00:06:46,120
batch that it grabs and it uses that to

00:06:43,120 --> 00:06:49,150
get the start of the next ten rows we

00:06:46,120 --> 00:06:51,280
don't use offset particularly in my

00:06:49,150 --> 00:06:53,800
sequel because offset is slow it does a

00:06:51,280 --> 00:06:56,770
linear iteration over the table to find

00:06:53,800 --> 00:06:59,350
the an offset item that's all of n

00:06:56,770 --> 00:07:01,810
whereas if you use the primary key which

00:06:59,350 --> 00:07:04,060
you assumedly have an index on it does

00:07:01,810 --> 00:07:08,650
it does a b-tree look up which is own

00:07:04,060 --> 00:07:11,500
log n so the problem is with composite

00:07:08,650 --> 00:07:13,630
primary keys if you have a table like

00:07:11,500 --> 00:07:16,060
this a group memberships table that

00:07:13,630 --> 00:07:17,770
joins a group and a membership stable it

00:07:16,060 --> 00:07:20,590
doesn't need a surrogate key from the

00:07:17,770 --> 00:07:22,870
database the user I need a group ID are

00:07:20,590 --> 00:07:24,940
enough to uniquely identify a row so you

00:07:22,870 --> 00:07:26,860
use a composite primary key rails

00:07:24,940 --> 00:07:29,380
doesn't handle this very well on its own

00:07:26,860 --> 00:07:31,810
but you have the composite primary keys

00:07:29,380 --> 00:07:34,240
plugin so the find in batches method

00:07:31,810 --> 00:07:37,060
which I've copied and pasted here will

00:07:34,240 --> 00:07:41,140
break if you use composite primary keys

00:07:37,060 --> 00:07:43,150
not realizing this I foolishly just did

00:07:41,140 --> 00:07:46,890
a lot of finding batches push to

00:07:43,150 --> 00:07:49,000
production and script goes down so

00:07:46,890 --> 00:07:50,530
there's a couple of bugs in there that I

00:07:49,000 --> 00:07:52,270
discovered while I was fixing it you can

00:07:50,530 --> 00:07:54,370
see right here that the table names are

00:07:52,270 --> 00:07:55,960
not escaped so if you have a table name

00:07:54,370 --> 00:07:58,300
that's also a reserved keyword it's

00:07:55,960 --> 00:08:00,610
going to break and lastly these records

00:07:58,300 --> 00:08:02,440
are yield within the scope up there so

00:08:00,610 --> 00:08:03,730
that with scope and then you yield the

00:08:02,440 --> 00:08:06,849
record so if you if you have your own

00:08:03,730 --> 00:08:09,560
scope it just going to be overwritten

00:08:06,849 --> 00:08:11,180
so anyway the composite primary Keys

00:08:09,560 --> 00:08:13,190
method a lot of you are probably

00:08:11,180 --> 00:08:15,020
familiar with it you can do something

00:08:13,190 --> 00:08:17,840
like this where you pass a list of

00:08:15,020 --> 00:08:19,940
primary keys and then when you call your

00:08:17,840 --> 00:08:23,389
model primary key you get an array back

00:08:19,940 --> 00:08:26,319
instead of a string so the solution in

00:08:23,389 --> 00:08:28,849
this case is to build a query generator

00:08:26,319 --> 00:08:30,050
that loads batches of objects in the

00:08:28,849 --> 00:08:32,149
same way you count multi-digit numbers

00:08:30,050 --> 00:08:33,950
so if you have three primary keys it'd

00:08:32,149 --> 00:08:36,349
be just like how you count three digit

00:08:33,950 --> 00:08:38,659
numbers I'm just going to go through it

00:08:36,349 --> 00:08:40,339
briefly because it's not worth it to get

00:08:38,659 --> 00:08:43,339
into the details so you've grabbed the

00:08:40,339 --> 00:08:45,860
first five rows from the table you note

00:08:43,339 --> 00:08:49,399
the primary key combination of the last

00:08:45,860 --> 00:08:51,380
row and then you grabbed all rows you

00:08:49,399 --> 00:08:53,510
grab the next five rows where the user

00:08:51,380 --> 00:08:55,370
ID is greater than five and the group ID

00:08:53,510 --> 00:08:59,720
is greater than one or with a group ID

00:08:55,370 --> 00:09:01,730
greater than one and limit 5 and so then

00:08:59,720 --> 00:09:04,790
you get the idea you get the primary key

00:09:01,730 --> 00:09:07,310
ID of that last item and so on and so

00:09:04,790 --> 00:09:09,440
forth hopefully get the idea the full

00:09:07,310 --> 00:09:11,570
solutions available at this URL if you

00:09:09,440 --> 00:09:13,190
use composite primary peas and you need

00:09:11,570 --> 00:09:16,520
to use find the batches you can use this

00:09:13,190 --> 00:09:18,440
to it's just a dis URL it's a monkey

00:09:16,520 --> 00:09:20,300
patch so monkey patches the default find

00:09:18,440 --> 00:09:21,860
it matches implementation obviously

00:09:20,300 --> 00:09:23,390
there's some contention about monkey

00:09:21,860 --> 00:09:25,130
patching so if you don't like it you can

00:09:23,390 --> 00:09:28,610
just rename the method or something that

00:09:25,130 --> 00:09:30,740
it will overwrite an existing method it

00:09:28,610 --> 00:09:33,200
also fixes that you because I mentioned

00:09:30,740 --> 00:09:35,149
earlier if you have your own scope your

00:09:33,200 --> 00:09:36,560
records that the records learned that

00:09:35,149 --> 00:09:38,420
this method will not overwrite that

00:09:36,560 --> 00:09:41,029
scope and you know you can use tables

00:09:38,420 --> 00:09:43,279
with reserve sequel keywords at standard

00:09:41,029 --> 00:09:44,810
disclaimer there might be bugs visited

00:09:43,279 --> 00:09:46,640
scripts but you know when be the last

00:09:44,810 --> 00:09:47,110
time I pushed huggy code the script so

00:09:46,640 --> 00:09:50,040
you should

00:09:47,110 --> 00:09:50,040
before you push it

00:09:50,540 --> 00:09:55,400
the next one is my most infamous moment

00:09:53,510 --> 00:09:57,470
it's the problem with validates

00:09:55,400 --> 00:09:59,470
uniqueness out some of you guys are

00:09:57,470 --> 00:10:04,070
laughing so you guys seen this before

00:09:59,470 --> 00:10:06,650
yeah it's really bad it's really bad so

00:10:04,070 --> 00:10:08,180
it stands as an absolutely shining

00:10:06,650 --> 00:10:10,340
example of why you should watch your

00:10:08,180 --> 00:10:12,680
query log and you should explain queries

00:10:10,340 --> 00:10:15,640
and how even the simplest of changes

00:10:12,680 --> 00:10:19,970
need to be investigated in the database

00:10:15,640 --> 00:10:23,030
so here's an abbreviated example of

00:10:19,970 --> 00:10:25,610
script user model this is pretty

00:10:23,030 --> 00:10:27,190
standard stuff then the requirement

00:10:25,610 --> 00:10:29,870
comes down the pipeline we need cake

00:10:27,190 --> 00:10:32,390
insensitivity and logins we need it so

00:10:29,870 --> 00:10:33,710
that if I sign up with one login and you

00:10:32,390 --> 00:10:35,090
signed up with the same login but a

00:10:33,710 --> 00:10:38,690
different case combination your

00:10:35,090 --> 00:10:40,280
prevented from signing up so we all know

00:10:38,690 --> 00:10:42,710
how to fix this problem right it's

00:10:40,280 --> 00:10:44,180
pretty easy okay sensitive is false so

00:10:42,710 --> 00:10:48,290
you know I get this yeah that's like

00:10:44,180 --> 00:10:49,730
it's 10pm and I get this down the on

00:10:48,290 --> 00:10:51,290
fogbugz and I'm like okay I'll just

00:10:49,730 --> 00:10:56,290
quickly do this before I go to bed so i

00:10:51,290 --> 00:11:00,950
added you know push it out go home yeah

00:10:56,290 --> 00:11:02,660
exactly I agree with him and I come to

00:11:00,950 --> 00:11:04,790
work next morning and I discover script

00:11:02,660 --> 00:11:06,740
is down everyone on care fires mad at me

00:11:04,790 --> 00:11:12,020
because they they get bisected it down

00:11:06,740 --> 00:11:14,570
to my commit so if I sec it it does not

00:11:12,020 --> 00:11:16,520
take favors so how could this have

00:11:14,570 --> 00:11:18,110
happened let's take a look at the sequel

00:11:16,520 --> 00:11:21,560
that rails runs when a user model is

00:11:18,110 --> 00:11:24,320
validated so it does this the offending

00:11:21,560 --> 00:11:26,510
clause here is the lower login portion

00:11:24,320 --> 00:11:29,780
my signal has to calculate the lowercase

00:11:26,510 --> 00:11:32,330
version of every single users login one

00:11:29,780 --> 00:11:34,010
by one and with more than 10 million

00:11:32,330 --> 00:11:36,320
users that we had at the time it was

00:11:34,010 --> 00:11:38,300
taking two minutes to run that query on

00:11:36,320 --> 00:11:39,920
our database and this was being run

00:11:38,300 --> 00:11:42,260
every time anybody tried to sign up for

00:11:39,920 --> 00:11:43,150
script which is you know multiple times

00:11:42,260 --> 00:11:47,620
per minute

00:11:43,150 --> 00:11:51,100
so soon enough script goes down and I

00:11:47,620 --> 00:11:58,240
also managed to seriously anger my DBA

00:11:51,100 --> 00:12:01,140
this guy know there was one he doesn't

00:11:58,240 --> 00:12:03,730
he works remotely so I'm safe for now

00:12:01,140 --> 00:12:05,410
there was one positive bonus from this

00:12:03,730 --> 00:12:12,730
whole thing however i learned what my

00:12:05,410 --> 00:12:15,310
name is in sterling so what's the

00:12:12,730 --> 00:12:18,070
solution well if you're fortunate enough

00:12:15,310 --> 00:12:19,600
to use postgres or oracle well you can

00:12:18,070 --> 00:12:22,990
just use a functional index you can

00:12:19,600 --> 00:12:24,640
create an index on lower login it'll

00:12:22,990 --> 00:12:26,410
take some time to create the index but

00:12:24,640 --> 00:12:29,170
then your problems are essentially

00:12:26,410 --> 00:12:31,660
solved however my sequel doesn't support

00:12:29,170 --> 00:12:33,400
functional indexes the solution of my

00:12:31,660 --> 00:12:35,140
sequels a little bit trickier it's

00:12:33,400 --> 00:12:36,370
something that maybe you would not maybe

00:12:35,140 --> 00:12:38,770
you don't expect if you're not that

00:12:36,370 --> 00:12:41,170
familiar with my sequel if you see here

00:12:38,770 --> 00:12:45,040
my sequel is cake insensitive for string

00:12:41,170 --> 00:12:46,900
comparisons by default this is actually

00:12:45,040 --> 00:12:48,880
an even bigger problem because now

00:12:46,900 --> 00:12:51,610
validates uniqueness of and my sequel

00:12:48,880 --> 00:12:53,020
are kind of diametrically opposed my

00:12:51,610 --> 00:12:54,910
sequel will make a case insensitive

00:12:53,020 --> 00:12:58,000
regardless of what you said validates

00:12:54,910 --> 00:12:59,620
uniqueness of two so basically wherever

00:12:58,000 --> 00:13:01,900
there's a validates uniqueness up its

00:12:59,620 --> 00:13:04,090
implicitly case insensitive

00:13:01,900 --> 00:13:08,890
so the solution here is the use of the

00:13:04,090 --> 00:13:10,750
binary keyword in my sequel this this

00:13:08,890 --> 00:13:12,280
keyword one place before a string tells

00:13:10,750 --> 00:13:15,010
my sequel to treat the comparison is

00:13:12,280 --> 00:13:17,860
binary data instead of as a string and

00:13:15,010 --> 00:13:21,220
it incurs no speed hit is at least as

00:13:17,860 --> 00:13:23,320
far as I know and so basically you need

00:13:21,220 --> 00:13:25,060
to modify validates uniqueness of to

00:13:23,320 --> 00:13:28,000
include this binary keyword when

00:13:25,060 --> 00:13:31,210
case-sensitive is true and leave it out

00:13:28,000 --> 00:13:33,280
when case-sensitive is false it's also

00:13:31,210 --> 00:13:34,930
very important this is actually only one

00:13:33,280 --> 00:13:37,600
of two times I broke script that day

00:13:34,930 --> 00:13:39,460
because I actually committed this and

00:13:37,600 --> 00:13:41,740
that's also order and for whatever

00:13:39,460 --> 00:13:44,440
reason despite the fact that it doesn't

00:13:41,740 --> 00:13:46,270
actually modify any data when you stick

00:13:44,440 --> 00:13:48,850
it next to log in its order in because

00:13:46,270 --> 00:13:50,380
it does it runs that binary keyword on

00:13:48,850 --> 00:13:54,520
every users login which is essentially

00:13:50,380 --> 00:13:56,680
the same problem that we have before so

00:13:54,520 --> 00:13:58,840
it's important to put it on the right

00:13:56,680 --> 00:14:00,130
side of the equal sign there at least on

00:13:58,840 --> 00:14:04,030
the side of the constant string

00:14:00,130 --> 00:14:06,580
whichever side that thought again we've

00:14:04,030 --> 00:14:08,410
got the solution online it's another

00:14:06,580 --> 00:14:10,480
monkey patch to validates uniqueness of

00:14:08,410 --> 00:14:11,890
it's really just there to kind of get

00:14:10,480 --> 00:14:14,830
the code out so people can see it and

00:14:11,890 --> 00:14:16,960
this monkey patch also doesn't check if

00:14:14,830 --> 00:14:19,240
you're using my sequel and it on binary

00:14:16,960 --> 00:14:22,000
is not a keyword in other database

00:14:19,240 --> 00:14:23,320
languages so you should probably only

00:14:22,000 --> 00:14:25,090
include it if you have a my sequel

00:14:23,320 --> 00:14:26,860
project or if anybody wants to make a

00:14:25,090 --> 00:14:28,450
plug-in out of it that's smart and

00:14:26,860 --> 00:14:29,980
checks if you have my sequel and loads

00:14:28,450 --> 00:14:32,140
itself and otherwise not I mean that's

00:14:29,980 --> 00:14:34,750
fine too

00:14:32,140 --> 00:14:38,500
and also standard this Glaber may

00:14:34,750 --> 00:14:40,900
contain bugs so the problem with delete

00:14:38,500 --> 00:14:43,210
and destroy is really more of a problem

00:14:40,900 --> 00:14:46,840
with rails documentation than anything

00:14:43,210 --> 00:14:49,210
else in general rails documentation is

00:14:46,840 --> 00:14:52,840
pretty explicit about how different

00:14:49,210 --> 00:14:55,060
methods work one area this fall short is

00:14:52,840 --> 00:14:58,240
the use of delete and destroy when you

00:14:55,060 --> 00:15:00,100
use it with the longer has to sorry as

00:14:58,240 --> 00:15:02,740
many and hasn't belongs to many

00:15:00,100 --> 00:15:04,270
associations their operation changes

00:15:02,740 --> 00:15:06,070
depending on how you configure your

00:15:04,270 --> 00:15:08,500
association which can seem like

00:15:06,070 --> 00:15:11,710
unrelated code and it's really an issue

00:15:08,500 --> 00:15:13,720
with how the documentation is set up or

00:15:11,710 --> 00:15:16,570
just the architecture decisions that

00:15:13,720 --> 00:15:18,280
were made I'll take you through a real

00:15:16,570 --> 00:15:21,640
world example that of course happened

00:15:18,280 --> 00:15:25,180
its script so here we have a category

00:15:21,640 --> 00:15:27,400
much categories group together documents

00:15:25,180 --> 00:15:29,500
with similar subjects they are joined

00:15:27,400 --> 00:15:31,360
through a category membership join model

00:15:29,500 --> 00:15:33,010
so category has many category

00:15:31,360 --> 00:15:35,790
memberships and has many documents

00:15:33,010 --> 00:15:37,770
through category memberships

00:15:35,790 --> 00:15:39,630
now we have a dependent delete all

00:15:37,770 --> 00:15:41,790
setting as some of you guys probably

00:15:39,630 --> 00:15:43,560
know dependent delete all is faster than

00:15:41,790 --> 00:15:45,420
the pendant destroyed because dependent

00:15:43,560 --> 00:15:47,220
destroy runs the before destroy the

00:15:45,420 --> 00:15:49,470
after destroyed hugs so it has to

00:15:47,220 --> 00:15:51,090
instantiate each row as an active record

00:15:49,470 --> 00:15:53,130
object to run the hooks whereas if you

00:15:51,090 --> 00:15:55,170
don't have any hugs you just use delete

00:15:53,130 --> 00:15:59,850
all and it just you know does a sequel

00:15:55,170 --> 00:16:02,970
delete any way down the pipeline comes a

00:15:59,850 --> 00:16:05,640
requirement when we delete documents or

00:16:02,970 --> 00:16:07,410
when we remove a category we want to tag

00:16:05,640 --> 00:16:10,770
documents with the name of that category

00:16:07,410 --> 00:16:12,840
so if we have five documents in the

00:16:10,770 --> 00:16:15,360
aviation category then we want to tag

00:16:12,840 --> 00:16:16,890
them with aviation before we delete that

00:16:15,360 --> 00:16:18,180
category so that we can keep track of

00:16:16,890 --> 00:16:21,540
where they were or at least have a

00:16:18,180 --> 00:16:24,570
relevant pack so everyone knows how to

00:16:21,540 --> 00:16:27,450
fix this you just add a before destroy

00:16:24,570 --> 00:16:28,740
that tax those documents and you could

00:16:27,450 --> 00:16:30,360
all imagine what these the

00:16:28,740 --> 00:16:33,480
implementation that method might look

00:16:30,360 --> 00:16:35,280
like well it didn't work here was my

00:16:33,480 --> 00:16:37,530
implementation of the method we're using

00:16:35,280 --> 00:16:39,510
somewhat fancy sequel syntax so that we

00:16:37,530 --> 00:16:41,760
don't have to iterate and instantiate

00:16:39,510 --> 00:16:43,440
each rose an active record object but

00:16:41,760 --> 00:16:46,020
what's important here is the sub query

00:16:43,440 --> 00:16:49,170
that I've highlighted in red which just

00:16:46,020 --> 00:16:52,350
selects all the all the IDS of all the

00:16:49,170 --> 00:16:54,330
documents in the category when this

00:16:52,350 --> 00:16:56,700
query is executed you might be surprised

00:16:54,330 --> 00:16:58,920
to discover that it returns no rose in

00:16:56,700 --> 00:17:01,770
other words by the time we get to that

00:16:58,920 --> 00:17:03,420
before destroy all the documents have

00:17:01,770 --> 00:17:06,860
author all the all the category

00:17:03,420 --> 00:17:10,140
memberships have already been deleted so

00:17:06,860 --> 00:17:13,470
this does not make sense right like why

00:17:10,140 --> 00:17:16,290
would rails be removing why would rails

00:17:13,470 --> 00:17:18,330
be removing associated objects before

00:17:16,290 --> 00:17:19,740
calling the destroy method like why is

00:17:18,330 --> 00:17:21,840
it running that dependent delete all

00:17:19,740 --> 00:17:24,000
before doing the before destroyed huh

00:17:21,840 --> 00:17:25,890
like that doesn't make sense the fix is

00:17:24,000 --> 00:17:28,030
not obvious and is probably really

00:17:25,890 --> 00:17:32,950
frustrating to a lot of people

00:17:28,030 --> 00:17:36,580
just have to move it to the top that's

00:17:32,950 --> 00:17:39,450
some rails magic let's explain why what

00:17:36,580 --> 00:17:41,740
the rails magic is pat's mini is

00:17:39,450 --> 00:17:44,580
actually doing a little bit of meta

00:17:41,740 --> 00:17:48,250
programming when you call has midi it

00:17:44,580 --> 00:17:51,670
calls a you know on the on the receiver

00:17:48,250 --> 00:17:53,410
it calls instance or class eval before

00:17:51,670 --> 00:17:55,750
destroyed it essentially instantiated

00:17:53,410 --> 00:17:57,610
essentially invokes before destroy and

00:17:55,750 --> 00:18:00,700
creates its own hook that does the

00:17:57,610 --> 00:18:02,500
deleting and so before destroyed hooks

00:18:00,700 --> 00:18:04,990
are run in the order that they are

00:18:02,500 --> 00:18:07,180
defined so if you put that has many

00:18:04,990 --> 00:18:08,560
before your before destroy hug it's

00:18:07,180 --> 00:18:11,680
before destroy puck is going to be

00:18:08,560 --> 00:18:16,000
running first which is infuriating but

00:18:11,680 --> 00:18:20,110
it's the way it is let's say you like me

00:18:16,000 --> 00:18:22,090
had no conceptual idea about this did

00:18:20,110 --> 00:18:23,740
not in your wildest dreams believe that

00:18:22,090 --> 00:18:25,600
moving this to the top would actually

00:18:23,740 --> 00:18:27,640
fix the problem so you made sort of a

00:18:25,600 --> 00:18:29,500
different different things you just

00:18:27,640 --> 00:18:31,510
remove that dependent delete all you

00:18:29,500 --> 00:18:33,910
said okay I'll delete the damn things

00:18:31,510 --> 00:18:36,280
myself you remove that dependent delete

00:18:33,910 --> 00:18:39,400
all and instead you add this at the very

00:18:36,280 --> 00:18:41,410
bottom of your method thing sing I'm

00:18:39,400 --> 00:18:43,650
going to run this first and then I will

00:18:41,410 --> 00:18:47,010
delete these myself thank you very much

00:18:43,650 --> 00:18:49,180
well now you may be surprised to learn

00:18:47,010 --> 00:18:51,280
hopefully before you push it to

00:18:49,180 --> 00:18:53,350
production you may be surprised to learn

00:18:51,280 --> 00:18:55,870
that your delete all method does not

00:18:53,350 --> 00:18:59,140
delete the category memberships anymore

00:18:55,870 --> 00:19:01,470
now it nearly set their category IDs to

00:18:59,140 --> 00:19:03,150
null why

00:19:01,470 --> 00:19:05,490
it's tricky verbiage in the

00:19:03,150 --> 00:19:08,370
documentation the delete all method

00:19:05,490 --> 00:19:11,070
removes all methods from or removes all

00:19:08,370 --> 00:19:12,419
records from the Association it doesn't

00:19:11,070 --> 00:19:14,159
say anything about the leading the

00:19:12,419 --> 00:19:16,169
records it nearly says they're removed

00:19:14,159 --> 00:19:21,570
from the Association and so rails and

00:19:16,169 --> 00:19:23,640
it's a computer mind believes that by

00:19:21,570 --> 00:19:25,650
removing them or by setting the category

00:19:23,640 --> 00:19:27,809
IDs to null it has effectively removed

00:19:25,650 --> 00:19:30,299
them from the Association rails has no

00:19:27,809 --> 00:19:38,309
idea that a category membership with

00:19:30,299 --> 00:19:41,370
anal category ID screw you Rios has no

00:19:38,309 --> 00:19:43,830
ID idea that setting the category or

00:19:41,370 --> 00:19:46,559
that a any category membership with anal

00:19:43,830 --> 00:19:50,570
category ID is essentially dead weight

00:19:46,559 --> 00:19:52,610
in your database so

00:19:50,570 --> 00:19:55,250
you are probably looking for something

00:19:52,610 --> 00:19:57,620
like this the active record based Alito

00:19:55,250 --> 00:20:00,159
method which will actually do the sequel

00:19:57,620 --> 00:20:03,350
delete and do what you wanted it to do

00:20:00,159 --> 00:20:05,600
so this is simple right Association

00:20:03,350 --> 00:20:07,700
delete all doesn't delete the records it

00:20:05,600 --> 00:20:10,039
merely sets their foreign key to null

00:20:07,700 --> 00:20:12,799
you just have to remember that well not

00:20:10,039 --> 00:20:14,360
quite apparently you actually need it

00:20:12,799 --> 00:20:17,179
able to figure out what the lead all

00:20:14,360 --> 00:20:18,740
does so it depends on what your

00:20:17,179 --> 00:20:21,799
dependent option is and it makes a

00:20:18,740 --> 00:20:23,629
little sense if you read through it if

00:20:21,799 --> 00:20:25,490
you're dependent option is nullify which

00:20:23,629 --> 00:20:28,639
is the default but it sets the records

00:20:25,490 --> 00:20:32,000
foreign keys to know if you're dependent

00:20:28,639 --> 00:20:34,129
option is destroyed then it loads each

00:20:32,000 --> 00:20:35,899
record runs the before destroyed hugs it

00:20:34,129 --> 00:20:39,590
deletes a record runs after destroy hugs

00:20:35,899 --> 00:20:41,269
if you're dependent option is that to

00:20:39,590 --> 00:20:44,029
delete all then it deletes the records

00:20:41,269 --> 00:20:46,690
from the database it makes some sense in

00:20:44,029 --> 00:20:48,740
some way it's just a little quirky but

00:20:46,690 --> 00:20:53,120
there is something here that should

00:20:48,740 --> 00:20:55,190
catch your eye a caught my eye it's

00:20:53,120 --> 00:20:58,279
actually two things what's up with the

00:20:55,190 --> 00:21:00,139
Select why why do we need to do is

00:20:58,279 --> 00:21:01,789
select before we do an update you know

00:21:00,139 --> 00:21:05,360
why do we need to do is select before we

00:21:01,789 --> 00:21:06,980
do it delete well let's be smart let's

00:21:05,360 --> 00:21:09,070
investigate the query log and let's see

00:21:06,980 --> 00:21:13,000
what's going on

00:21:09,070 --> 00:21:15,490
it looks like what's going on is that it

00:21:13,000 --> 00:21:17,769
is first selecting it is doing the

00:21:15,490 --> 00:21:19,480
select that we expect with or doing this

00:21:17,769 --> 00:21:21,220
electricity where cause that we expect

00:21:19,480 --> 00:21:23,080
to get a list of ID's and then it's

00:21:21,220 --> 00:21:25,360
doing an update and passing in a list of

00:21:23,080 --> 00:21:27,070
ID's well that's fine for the nine

00:21:25,360 --> 00:21:29,409
category memberships that I have in this

00:21:27,070 --> 00:21:32,049
example but for my sequel in particular

00:21:29,409 --> 00:21:34,809
it doesn't do very well with lists of

00:21:32,049 --> 00:21:36,669
ID's even though even if you have an

00:21:34,809 --> 00:21:38,200
even if you have an index on ID this is

00:21:36,669 --> 00:21:40,000
still going to break if you have you

00:21:38,200 --> 00:21:43,179
know a particularly large category that

00:21:40,000 --> 00:21:45,759
you're deleting there's an even bigger

00:21:43,179 --> 00:21:48,759
problem though and the observant among

00:21:45,759 --> 00:21:51,159
you may notice that we're using ID and

00:21:48,759 --> 00:21:53,799
catagory memberships is a joint table it

00:21:51,159 --> 00:21:55,809
shouldn't have an ID column oftentimes

00:21:53,799 --> 00:21:57,039
our older joint tables in scrip do just

00:21:55,809 --> 00:21:59,559
because at the time we didn't really

00:21:57,039 --> 00:22:03,190
know about the ID is false option but

00:21:59,559 --> 00:22:06,549
now we do and so we don't have IDs and

00:22:03,190 --> 00:22:13,379
the truth is if you don't have an ID you

00:22:06,549 --> 00:22:13,379
actually get this which is useless so

00:22:14,340 --> 00:22:20,230
composite primary keys a recent version

00:22:17,049 --> 00:22:22,269
has fixed this which is good but it

00:22:20,230 --> 00:22:26,259
doesn't fix the larger problem which is

00:22:22,269 --> 00:22:28,779
that you know we're still using a large

00:22:26,259 --> 00:22:30,429
list of in the case of composite primary

00:22:28,779 --> 00:22:32,289
keys were using just a bunch of hands

00:22:30,429 --> 00:22:34,450
and hands and at the ends or we're just

00:22:32,289 --> 00:22:37,149
using an end and a bunch of lists or a

00:22:34,450 --> 00:22:40,570
bunch of items in a list so we're back

00:22:37,149 --> 00:22:43,330
to our refrain what's the solution

00:22:40,570 --> 00:22:45,100
when in doubt fall back on methods that

00:22:43,330 --> 00:22:47,440
are well defined and no matter what

00:22:45,100 --> 00:22:49,840
parameters you give this method the

00:22:47,440 --> 00:22:52,120
active record bass the leap all method

00:22:49,840 --> 00:22:55,690
will perform one and exactly one delete

00:22:52,120 --> 00:22:57,880
and nothing else and so don't be afraid

00:22:55,690 --> 00:22:59,470
to give up some of that rails magic in

00:22:57,880 --> 00:23:02,200
exchange for knowing what's going on

00:22:59,470 --> 00:23:05,169
with your database by the way a little

00:23:02,200 --> 00:23:07,210
aside um note that there's no conditions

00:23:05,169 --> 00:23:09,429
hash there if you put a conditions hash

00:23:07,210 --> 00:23:11,139
in there rails will say conditions well

00:23:09,429 --> 00:23:12,909
that's not a column in the database so

00:23:11,139 --> 00:23:14,679
I'll just delete everything that's how

00:23:12,909 --> 00:23:22,600
we lost our credit cards table this is a

00:23:14,679 --> 00:23:24,220
true story so yeah find becca okay well

00:23:22,600 --> 00:23:27,070
actually at the time there were only

00:23:24,220 --> 00:23:28,629
like we had just launched our store so

00:23:27,070 --> 00:23:40,029
they're only a few credit card so we

00:23:28,629 --> 00:23:41,440
were just like and the same thing is the

00:23:40,029 --> 00:23:42,970
setting is because you know i don't know

00:23:41,440 --> 00:23:44,649
if any of you work with payment systems

00:23:42,970 --> 00:23:46,360
but you can't store your own credit

00:23:44,649 --> 00:23:48,309
cards in the database you after storm

00:23:46,360 --> 00:23:50,320
into vault so really they were just you

00:23:48,309 --> 00:23:51,940
know the IDS of credit card that were

00:23:50,320 --> 00:23:56,080
stored by some big enterprise vault

00:23:51,940 --> 00:23:57,669
company and so and that so basically

00:23:56,080 --> 00:23:59,200
when these users they go when they're

00:23:57,669 --> 00:24:00,789
like wait no I did type in my credit

00:23:59,200 --> 00:24:02,919
card so they'll type in their credit

00:24:00,789 --> 00:24:04,029
card and we'll send it off to the vault

00:24:02,919 --> 00:24:05,080
in the vault and say we already have

00:24:04,029 --> 00:24:06,279
this credit card so we'll get it back

00:24:05,080 --> 00:24:07,809
saying they already have it but they

00:24:06,279 --> 00:24:09,580
don't have it's actually pretty bad but

00:24:07,809 --> 00:24:11,409
fortunately just only a few of them that

00:24:09,580 --> 00:24:14,279
will have that you know never be able to

00:24:11,409 --> 00:24:14,279
use their credit card again

00:24:15,659 --> 00:24:22,809
anyway fine conditions delete all no

00:24:20,470 --> 00:24:25,659
conditions this all of course be fixed

00:24:22,809 --> 00:24:28,240
in rails 3 with the new abstract query

00:24:25,659 --> 00:24:30,820
logic thing whose name I forget your

00:24:28,240 --> 00:24:36,010
Errol yes thank you Errol's wonderful

00:24:30,820 --> 00:24:37,809
remove this problem entirely lastly

00:24:36,010 --> 00:24:39,970
we're going to talk about a very my

00:24:37,809 --> 00:24:42,370
sequel specific thing again sorry for

00:24:39,970 --> 00:24:43,929
anybody doesn't use my sequel but you

00:24:42,370 --> 00:24:47,470
know so where most of our problems come

00:24:43,929 --> 00:24:49,510
from really so the problem indexes and

00:24:47,470 --> 00:24:50,679
really indexes are a wonderful thing I

00:24:49,510 --> 00:24:51,820
shouldn't say there's a problem with

00:24:50,679 --> 00:24:53,020
them because they're not because if we

00:24:51,820 --> 00:24:56,830
didn't happen we'd have a lot more

00:24:53,020 --> 00:24:58,840
problerms indexes though are the source

00:24:56,830 --> 00:25:01,450
of many or the lack thereof are the

00:24:58,840 --> 00:25:04,270
source of many big problems in large

00:25:01,450 --> 00:25:05,860
websites the problem is that your

00:25:04,270 --> 00:25:09,340
database performance depends critically

00:25:05,860 --> 00:25:11,230
on having the correct indexes but a lots

00:25:09,340 --> 00:25:12,850
of times especially people who are just

00:25:11,230 --> 00:25:14,950
getting started in rails they don't

00:25:12,850 --> 00:25:17,740
understand what to index and when and

00:25:14,950 --> 00:25:19,330
the other problem is as your database

00:25:17,740 --> 00:25:22,929
grows it gets harder and harder to add

00:25:19,330 --> 00:25:24,730
new indexes so it's important to think

00:25:22,929 --> 00:25:26,350
about wedding exes you might need early

00:25:24,730 --> 00:25:28,419
on when you've only got a few thousand

00:25:26,350 --> 00:25:31,059
rows in your table and before it gets

00:25:28,419 --> 00:25:34,270
slashdot and dug in hacker news and the

00:25:31,059 --> 00:25:36,789
only other problem you know now it's

00:25:34,270 --> 00:25:38,950
scribd we just we simply can't add

00:25:36,789 --> 00:25:41,320
indexes to certain tables anymore we

00:25:38,950 --> 00:25:43,270
either add them to slaves or we find

00:25:41,320 --> 00:25:46,450
creative ways to use existing indexes

00:25:43,270 --> 00:25:47,830
it's you know we all sorts of things

00:25:46,450 --> 00:25:50,039
that maybe I shouldn't even be telling

00:25:47,830 --> 00:25:50,039
you about

00:25:50,170 --> 00:25:55,280
so here's some pretty straightforward

00:25:53,270 --> 00:25:57,470
code to load a user's documents for

00:25:55,280 --> 00:26:00,470
their profile page if only it actually

00:25:57,470 --> 00:26:02,120
looked like this at script we'd just

00:26:00,470 --> 00:26:04,550
have a bunch of name scopes document

00:26:02,120 --> 00:26:07,340
thought of user we could also do user

00:26:04,550 --> 00:26:10,370
documents but whatever not paginate it

00:26:07,340 --> 00:26:12,950
and we have params page and order them

00:26:10,370 --> 00:26:15,530
by it uploaded and all so yeah that's

00:26:12,950 --> 00:26:17,180
fine and of course since we're smart or

00:26:15,530 --> 00:26:18,770
well we take a look at the query and

00:26:17,180 --> 00:26:20,330
there's nothing wrong with the query it

00:26:18,770 --> 00:26:25,010
does exactly what we thought strings

00:26:20,330 --> 00:26:27,230
together all those things anyway so down

00:26:25,010 --> 00:26:30,350
the pipeline comes the order that the

00:26:27,230 --> 00:26:31,610
documents should be paranoid delete for

00:26:30,350 --> 00:26:33,110
those of you that don't know paranoid

00:26:31,610 --> 00:26:34,640
delete means you don't actually remove

00:26:33,110 --> 00:26:37,100
anything from the database you just set

00:26:34,640 --> 00:26:38,780
a deleted boolean to true in that way

00:26:37,100 --> 00:26:40,550
you still have the data in case they

00:26:38,780 --> 00:26:41,900
want to undelete it or something because

00:26:40,550 --> 00:26:45,800
people are predict you us or for

00:26:41,900 --> 00:26:47,210
whatever reason or in the case of the

00:26:45,800 --> 00:26:49,250
way we do it it's scribd and the way the

00:26:47,210 --> 00:26:51,920
ex is paranoid plugin does it it's a

00:26:49,250 --> 00:26:53,750
deleted act timestamp and if it's null

00:26:51,920 --> 00:26:56,980
then the object is not deleted otherwise

00:26:53,750 --> 00:26:59,890
at the time it was deleted at

00:26:56,980 --> 00:27:02,919
so we all know how to fix this we just

00:26:59,890 --> 00:27:04,960
na not deleted name scope right so

00:27:02,919 --> 00:27:09,460
that's easy well if you push it to

00:27:04,960 --> 00:27:11,730
production script goes down so what went

00:27:09,460 --> 00:27:14,440
wrong let's take a look at the query

00:27:11,730 --> 00:27:16,299
nothing wrong here that's exactly what

00:27:14,440 --> 00:27:18,700
it should be you just add and deleted at

00:27:16,299 --> 00:27:21,040
is not null that's fine so we're going

00:27:18,700 --> 00:27:23,080
to delve deeper into the indexes if we

00:27:21,040 --> 00:27:25,510
show create a table here you can see the

00:27:23,080 --> 00:27:27,370
problem we have an index on user ID and

00:27:25,510 --> 00:27:29,770
we have an index on deleted at but we

00:27:27,370 --> 00:27:33,460
don't have an index on user ID and on

00:27:29,770 --> 00:27:35,200
the way to that and my sequel is not

00:27:33,460 --> 00:27:37,510
smart enough to somehow combine those

00:27:35,200 --> 00:27:40,960
into an index on user ID and undelete it

00:27:37,510 --> 00:27:43,600
up so it also my sequel important though

00:27:40,960 --> 00:27:45,429
only ever uses exactly one index for

00:27:43,600 --> 00:27:49,410
each query portion of your account

00:27:45,429 --> 00:27:52,660
statement so you know it's going to pick

00:27:49,410 --> 00:27:54,100
if we explain my sequin confirms it we

00:27:52,660 --> 00:27:57,000
got some scary-looking stuff and the

00:27:54,100 --> 00:27:59,679
extra using filesort should scare people

00:27:57,000 --> 00:28:02,530
and the fact that we're you know using

00:27:59,679 --> 00:28:04,570
index document on user or index document

00:28:02,530 --> 00:28:08,260
on user ID is also pretty scary it's a

00:28:04,570 --> 00:28:09,970
full table scale so the solution of

00:28:08,260 --> 00:28:12,070
course is to add an index you know you

00:28:09,970 --> 00:28:14,440
got an index on user ID and deleted at

00:28:12,070 --> 00:28:15,520
you run the migration your problem is

00:28:14,440 --> 00:28:17,330
solved you don't need enough to change

00:28:15,520 --> 00:28:20,429
your code

00:28:17,330 --> 00:28:22,080
if you are smart and you run the explain

00:28:20,429 --> 00:28:23,940
before you push the production you'll

00:28:22,080 --> 00:28:25,889
see that is in fact using the correct

00:28:23,940 --> 00:28:28,139
index now I actually forgot to change

00:28:25,889 --> 00:28:29,519
its as still not all that scary stuff at

00:28:28,139 --> 00:28:33,629
the bottom of whatever this is just a

00:28:29,519 --> 00:28:35,609
fake explain so so it says index

00:28:33,629 --> 00:28:37,289
documents on user ID and deleted out

00:28:35,609 --> 00:28:39,929
which is good that's what we want we're

00:28:37,289 --> 00:28:42,389
done what about the just-in-time

00:28:39,929 --> 00:28:45,239
solution that index is probably not

00:28:42,389 --> 00:28:47,249
tenable for large companies if you're

00:28:45,239 --> 00:28:49,200
our documents table right now as

00:28:47,249 --> 00:28:50,609
millions and millions of rows and if we

00:28:49,200 --> 00:28:53,070
were to add an index it would lock that

00:28:50,609 --> 00:28:54,779
table for a very long time and not to

00:28:53,070 --> 00:28:56,549
mention that table or that index has to

00:28:54,779 --> 00:28:59,279
propagate to all its life so it's a big

00:28:56,549 --> 00:29:00,749
mess you can at least force my sequel to

00:28:59,279 --> 00:29:03,029
use the more restrictive of the two

00:29:00,749 --> 00:29:05,009
indexes which should hopefully pick some

00:29:03,029 --> 00:29:06,419
of your problems for some time until you

00:29:05,009 --> 00:29:09,779
can find a better way to deal with this

00:29:06,419 --> 00:29:12,059
problem here we're using the use index

00:29:09,779 --> 00:29:15,149
feature of my sequel which forces it to

00:29:12,059 --> 00:29:18,299
use a particular index in general my

00:29:15,149 --> 00:29:20,580
sequel is reasonably intelligent i would

00:29:18,299 --> 00:29:23,460
say about picking the correct index but

00:29:20,580 --> 00:29:26,009
yeah there's some shaking heads it can

00:29:23,460 --> 00:29:28,559
go really really wrong at times and you

00:29:26,009 --> 00:29:31,470
know if you as an intelligent programmer

00:29:28,559 --> 00:29:33,749
don't want to you know leave it to

00:29:31,470 --> 00:29:38,070
chance you can just use the use index or

00:29:33,749 --> 00:29:39,869
the force index statements in order to

00:29:38,070 --> 00:29:41,849
ensure that you're using the best index

00:29:39,869 --> 00:29:44,609
available in this particular instance

00:29:41,849 --> 00:29:47,279
we're assuming that each individual user

00:29:44,609 --> 00:29:49,710
has fewer documents than the set of all

00:29:47,279 --> 00:29:51,899
not deleted documents which is a

00:29:49,710 --> 00:29:53,970
reasonable bet to make that way we'll

00:29:51,899 --> 00:29:55,649
narrow it down quickly by user ID and

00:29:53,970 --> 00:29:58,169
then all we have to do is iterate over

00:29:55,649 --> 00:30:01,169
the documents you know in an order n

00:29:58,169 --> 00:30:03,299
time in order at time just to filter out

00:30:01,169 --> 00:30:07,409
those that are deleted

00:30:03,299 --> 00:30:10,710
um yeah and so as long as you're not

00:30:07,409 --> 00:30:12,690
loading some giant monster users page it

00:30:10,710 --> 00:30:15,899
should be at least reasonably fast for

00:30:12,690 --> 00:30:18,509
the time being so normally my sequel

00:30:15,899 --> 00:30:20,340
will pick normally my sequel will pick

00:30:18,509 --> 00:30:21,869
decent indexes if you have only a few

00:30:20,340 --> 00:30:23,519
indexes in your table and it's pretty

00:30:21,869 --> 00:30:25,259
obvious which one they use for a given

00:30:23,519 --> 00:30:27,509
situation but as you start adding more

00:30:25,259 --> 00:30:29,210
indexes you need to explain your queries

00:30:27,509 --> 00:30:31,980
and make sure it's using the right index

00:30:29,210 --> 00:30:33,809
and you need to provide index hints like

00:30:31,980 --> 00:30:35,909
this when necessary there's

00:30:33,809 --> 00:30:39,179
unfortunately no easy way to do this in

00:30:35,909 --> 00:30:40,799
active record prettiness right now but

00:30:39,179 --> 00:30:45,210
sometimes you have to say goodbye to

00:30:40,799 --> 00:30:47,070
active record prettiness so in

00:30:45,210 --> 00:30:48,600
conclusion i'm going to reiterate my

00:30:47,070 --> 00:30:50,730
original points you need to always

00:30:48,600 --> 00:30:54,359
understand the queries that your code is

00:30:50,730 --> 00:30:56,820
generating unless the query is trivially

00:30:54,359 --> 00:30:58,739
trivially obvious you should be thinking

00:30:56,820 --> 00:31:00,450
about what the implications it's going

00:30:58,739 --> 00:31:03,899
to happen under scale and you'd be

00:31:00,450 --> 00:31:06,119
explaining it if necessary test with a

00:31:03,899 --> 00:31:07,830
heavily populated database again I don't

00:31:06,119 --> 00:31:10,139
always do this but I really should and

00:31:07,830 --> 00:31:13,440
so should you at least at least a couple

00:31:10,139 --> 00:31:14,909
of times again DM sweatshop is nice

00:31:13,440 --> 00:31:17,100
hopefully there's something like that

00:31:14,909 --> 00:31:20,100
for rails that I just haven't discovered

00:31:17,100 --> 00:31:21,899
yet and just prop up giant databases

00:31:20,100 --> 00:31:24,480
with random data and test with them and

00:31:21,899 --> 00:31:26,190
look for frustrating slowness and lastly

00:31:24,480 --> 00:31:28,590
pay close attention to your indexes

00:31:26,190 --> 00:31:30,480
because indexes are very important and

00:31:28,590 --> 00:31:33,070
often times new programmers just don't

00:31:30,480 --> 00:31:35,529
understand them

00:31:33,070 --> 00:31:39,970
so that's the conclusion of my top are

00:31:35,529 --> 00:31:42,429
there any questions have you done any

00:31:39,970 --> 00:31:44,380
experimenting we had post gross with

00:31:42,429 --> 00:31:46,630
some of the same techniques yeah

00:31:44,380 --> 00:31:48,490
actually so script runs on my sequel but

00:31:46,630 --> 00:31:51,639
I use post credits for all my little

00:31:48,490 --> 00:31:54,669
website and I run into some problems

00:31:51,639 --> 00:31:57,399
with postgres the functional indexes is

00:31:54,669 --> 00:31:59,679
nicer as for some of the meteor and

00:31:57,399 --> 00:32:00,970
grittier stuff I only under really

00:31:59,679 --> 00:32:02,440
understand that in my sequel just

00:32:00,970 --> 00:32:04,330
because I don't run a website like

00:32:02,440 --> 00:32:06,309
script in Postgres and that's just the

00:32:04,330 --> 00:32:08,769
way it is but there there are lots of

00:32:06,309 --> 00:32:15,669
experts I'm sure that besides me I'm

00:32:08,769 --> 00:32:18,370
very helpful have you looked at trying

00:32:15,669 --> 00:32:20,889
to I think there's a lot of what they

00:32:18,370 --> 00:32:24,429
call no sequel database technologies

00:32:20,889 --> 00:32:26,860
around now and a lot of the stuff that

00:32:24,429 --> 00:32:28,970
we're doing in rails is using the

00:32:26,860 --> 00:32:32,600
database to

00:32:28,970 --> 00:32:34,760
to model the references and when you

00:32:32,600 --> 00:32:36,500
have a million Road table in a million

00:32:34,760 --> 00:32:38,600
row table and you need a bunch of

00:32:36,500 --> 00:32:40,250
references that that's really huge and

00:32:38,600 --> 00:32:44,059
it's hard to do in a relational

00:32:40,250 --> 00:32:46,190
technology so have you looked at trying

00:32:44,059 --> 00:32:48,830
to you know model some of this stuff in

00:32:46,190 --> 00:32:51,070
a non-relational technology whether that

00:32:48,830 --> 00:32:53,870
would be an advantage or just a lot of

00:32:51,070 --> 00:32:55,929
passholders life so no sequel is getting

00:32:53,870 --> 00:32:58,130
pretty big lately especially with

00:32:55,929 --> 00:33:00,289
technologies like from facebook and

00:32:58,130 --> 00:33:02,840
twitter who have been kind of paving the

00:33:00,289 --> 00:33:04,309
way there and that's good I agree with

00:33:02,840 --> 00:33:06,590
you and probably a lot of people here

00:33:04,309 --> 00:33:08,179
that relational databases have sort of a

00:33:06,590 --> 00:33:09,590
specific use case that they're really

00:33:08,179 --> 00:33:11,390
good at and they've just going to been

00:33:09,590 --> 00:33:14,350
blown out to other things just to model

00:33:11,390 --> 00:33:16,309
an entire websites data structure

00:33:14,350 --> 00:33:18,380
unfortunately at scribd we haven't

00:33:16,309 --> 00:33:19,640
delved into that a lot Tyler is going to

00:33:18,380 --> 00:33:22,130
be speaking next knows more about this

00:33:19,640 --> 00:33:25,580
than I do he's more on the cutting edge

00:33:22,130 --> 00:33:28,100
of this stuff than i am but we we still

00:33:25,580 --> 00:33:30,559
use my sequel for almost all of our core

00:33:28,100 --> 00:33:32,659
data this is a change that may come in

00:33:30,559 --> 00:33:35,080
the future hopefully but not yet

00:33:32,659 --> 00:33:35,080
unfortunately

00:33:36,380 --> 00:33:40,360

YouTube URL: https://www.youtube.com/watch?v=hqK4o7OIA54


