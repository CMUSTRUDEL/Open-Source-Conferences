Title: Madison Ruby 2013 - Rapid Game Prototyping with Ruby
Publication date: 2020-01-28
Playlist: Madison Ruby 2013
Description: 
	By Michael Fairley

Just as Ruby is great for getting a new web project off the ground and into production, Ruby is equally awesome for quickly building games up from scratch and continuing to iterate on them. This talk explores the basics of how computer games work, shows the tools available for building games in Ruby, and has a live demonstration of creating a simple game.

Help us caption & translate this video!

http://amara.org/v/FG7Y/
Captions: 
	00:00:11,720 --> 00:00:21,260
I love you dad I love you too mom if you

00:00:15,980 --> 00:00:22,880
ever watch the video so like Jim said my

00:00:21,260 --> 00:00:24,500
name is Michael Farrelly and I'm gonna

00:00:22,880 --> 00:00:27,439
be talking a little bit about making

00:00:24,500 --> 00:00:29,540
computer games with Ruby Erica at a

00:00:27,439 --> 00:00:32,060
company called Braintree and we make it

00:00:29,540 --> 00:00:35,120
easy for companies of any size to take

00:00:32,060 --> 00:00:36,860
payments online we work with thousands

00:00:35,120 --> 00:00:37,820
of really awesome merchants including a

00:00:36,860 --> 00:00:39,829
bunch of these that you probably

00:00:37,820 --> 00:00:42,489
recognize so if you want to chat about

00:00:39,829 --> 00:00:45,320
payments come find me later

00:00:42,489 --> 00:00:46,940
we're also always hiring talented

00:00:45,320 --> 00:00:49,340
developers and we do a lot of Ruby and

00:00:46,940 --> 00:00:52,480
we're based out of Chicago so come find

00:00:49,340 --> 00:00:55,220
me if you want to chat about that too so

00:00:52,480 --> 00:00:57,530
I'm assuming that most people in here

00:00:55,220 --> 00:00:59,810
are web developers that the Ruby you get

00:00:57,530 --> 00:01:01,490
paid to write is part of a rails app or

00:00:59,810 --> 00:01:03,560
a Sinatra app or you're writing

00:01:01,490 --> 00:01:06,350
libraries that you intend to end up in a

00:01:03,560 --> 00:01:07,880
rails app or Sinatra app I fall into

00:01:06,350 --> 00:01:08,720
that boat to the past three years that

00:01:07,880 --> 00:01:10,579
I've been doing

00:01:08,720 --> 00:01:13,490
Ruby professionally I've mostly been

00:01:10,579 --> 00:01:14,900
working on Rails apps but games are what

00:01:13,490 --> 00:01:16,880
got me into programming in the first

00:01:14,900 --> 00:01:18,650
place and even though I don't really

00:01:16,880 --> 00:01:20,450
aspire to do that professionally anymore

00:01:18,650 --> 00:01:22,100
I've picked it up as a hobby that

00:01:20,450 --> 00:01:24,050
something I do on the weekends when I

00:01:22,100 --> 00:01:25,250
want to just cowboy some code out and

00:01:24,050 --> 00:01:29,030
not have to worry if it's gonna send

00:01:25,250 --> 00:01:30,530
money to the wrong place so I'm gonna

00:01:29,030 --> 00:01:32,180
share a little bit a little bit about

00:01:30,530 --> 00:01:34,490
this passion with you and hope you guys

00:01:32,180 --> 00:01:38,659
will go home and try it out and find as

00:01:34,490 --> 00:01:40,760
much fun is it fun in it as I do so I'm

00:01:38,659 --> 00:01:42,560
gonna briefly go over some of the like

00:01:40,760 --> 00:01:44,720
abstract stuff behind what game

00:01:42,560 --> 00:01:46,760
programming is talk about a few of the

00:01:44,720 --> 00:01:48,920
really cool Ruby libraries we have for

00:01:46,760 --> 00:01:50,810
doing game programming and then give you

00:01:48,920 --> 00:01:53,630
a quick demo of making pong from scratch

00:01:50,810 --> 00:01:55,340
using these tools but before that I need

00:01:53,630 --> 00:01:56,930
to address some doubt in the room which

00:01:55,340 --> 00:02:00,409
is is Ruby the right tool for making

00:01:56,930 --> 00:02:02,990
games isn't Ruby slow don't games need

00:02:00,409 --> 00:02:06,710
to be fast an answer is yes to all of

00:02:02,990 --> 00:02:08,629
those we luckily have most of these Ruby

00:02:06,710 --> 00:02:10,429
libraries are actually Ruby bindings on

00:02:08,629 --> 00:02:13,189
top of C libraries that are quite fast

00:02:10,429 --> 00:02:16,310
so we get a lot of the speed of C with

00:02:13,189 --> 00:02:18,739
the experts expressivity of Ruby and it

00:02:16,310 --> 00:02:20,209
works out really well I'm gonna give you

00:02:18,739 --> 00:02:24,200
a quick demo of something I've been

00:02:20,209 --> 00:02:25,550
working on that should also cancel out

00:02:24,200 --> 00:02:28,420
some of your doubt

00:02:25,550 --> 00:02:31,910
I've been building a minecraft clone

00:02:28,420 --> 00:02:33,950
using Ruby this is about 800 lines of

00:02:31,910 --> 00:02:36,290
Ruby for what you're seeing and it's

00:02:33,950 --> 00:02:40,820
it's pretty dang fast for being a 3d

00:02:36,290 --> 00:02:47,240
game written in Ruby so if that's

00:02:40,820 --> 00:02:49,400
possible a lot of things are this slide

00:02:47,240 --> 00:02:51,410
has just about everything you need to

00:02:49,400 --> 00:02:56,030
know about game programming as a general

00:02:51,410 --> 00:02:58,040
concept on it at the core of every game

00:02:56,030 --> 00:03:00,320
via the the pong demo that I'm going to

00:02:58,040 --> 00:03:03,200
show you later to Skyrim or Call of Duty

00:03:00,320 --> 00:03:05,000
has a game loop at it and the game loop

00:03:03,200 --> 00:03:06,950
is pretty simple you do a little bit of

00:03:05,000 --> 00:03:08,210
setup before you enter the loop put your

00:03:06,950 --> 00:03:10,220
game and whatever starting state you

00:03:08,210 --> 00:03:12,620
want it to be and inside the loop you

00:03:10,220 --> 00:03:15,050
continually update your game world based

00:03:12,620 --> 00:03:17,570
on player input or time or randomness

00:03:15,050 --> 00:03:19,550
and then draw the state of the world out

00:03:17,570 --> 00:03:21,470
onto the screen you do all of the

00:03:19,550 --> 00:03:25,340
mutation during the update and all of

00:03:21,470 --> 00:03:29,120
your output during draw and that that's

00:03:25,340 --> 00:03:32,510
basically game programming in five lines

00:03:29,120 --> 00:03:34,190
of code so there's an awesome library

00:03:32,510 --> 00:03:37,070
for doing game programming in Ruby and

00:03:34,190 --> 00:03:40,730
it's called gosu the entirety of gosu is

00:03:37,070 --> 00:03:43,070
about five 105 methods and active record

00:03:40,730 --> 00:03:44,840
base has 500 class class methods on it

00:03:43,070 --> 00:03:46,160
so if you've gotten to know active

00:03:44,840 --> 00:03:50,090
record pretty well you can pick up all

00:03:46,160 --> 00:03:52,970
of gosu in a weekend at the core of gosu

00:03:50,090 --> 00:03:55,010
is the window class and this is what you

00:03:52,970 --> 00:03:56,390
subclass to make your game and once you

00:03:55,010 --> 00:03:57,590
do that you're responsible for

00:03:56,390 --> 00:04:00,560
implementing three methods on it

00:03:57,590 --> 00:04:01,820
initialize update and draw and you'll

00:04:00,560 --> 00:04:04,970
notice that these are the three methods

00:04:01,820 --> 00:04:06,620
from the game loop your setup the thing

00:04:04,970 --> 00:04:09,260
that effects your game and then drawing

00:04:06,620 --> 00:04:11,270
the state out onto the world and gosu

00:04:09,260 --> 00:04:14,090
makes all of these like pretty easy to

00:04:11,270 --> 00:04:15,950
do so gosu has some tools for helping

00:04:14,090 --> 00:04:17,660
you draw on the screen one of the

00:04:15,950 --> 00:04:20,120
methods that you'll use a lot is draw

00:04:17,660 --> 00:04:22,700
quad you give it an x coordinate a y

00:04:20,120 --> 00:04:24,590
coordinate and a color for four points

00:04:22,700 --> 00:04:26,000
on a quadrilateral and it'll draw them

00:04:24,590 --> 00:04:28,460
together and fill in what's in between

00:04:26,000 --> 00:04:30,800
them there's also things like draw a

00:04:28,460 --> 00:04:32,240
triangle and draw a line and then goes

00:04:30,800 --> 00:04:34,160
who also has tools for helping you put

00:04:32,240 --> 00:04:37,610
text and images on the screen with about

00:04:34,160 --> 00:04:39,350
as much code goes who also helps you

00:04:37,610 --> 00:04:41,540
handle input from your players

00:04:39,350 --> 00:04:44,720
so you can ask if a button is down be it

00:04:41,540 --> 00:04:47,150
a button on the keyboard or the mouse or

00:04:44,720 --> 00:04:48,560
a joystick or gamepad and then you can

00:04:47,150 --> 00:04:53,720
also get the coordinates of the mouse

00:04:48,560 --> 00:04:55,340
pretty easily it's also pretty simple to

00:04:53,720 --> 00:04:57,230
play sounds and go sooo you construct a

00:04:55,340 --> 00:04:59,060
sample class with a file name pointing

00:04:57,230 --> 00:05:01,070
at a sound file and then whenever you

00:04:59,060 --> 00:05:04,310
call play on that sample the sound will

00:05:01,070 --> 00:05:06,710
come out of your speakers and go see

00:05:04,310 --> 00:05:08,600
also includes a bunch of helpers to help

00:05:06,710 --> 00:05:10,010
you do your math there's a bunch of

00:05:08,600 --> 00:05:13,160
common math that you'll find yourself

00:05:10,010 --> 00:05:15,190
doing in 2d game programming and a lot

00:05:13,160 --> 00:05:17,510
of its high school level math but as a

00:05:15,190 --> 00:05:19,070
Bryan Liles demonstrated yesterday

00:05:17,510 --> 00:05:23,960
morning we don't all remember our high

00:05:19,070 --> 00:05:25,850
school math so gosu just gives you some

00:05:23,960 --> 00:05:28,520
nice correct semantic methods to help

00:05:25,850 --> 00:05:30,350
you out with this so offset X and offset

00:05:28,520 --> 00:05:32,960
white here you pass them an angle in a

00:05:30,350 --> 00:05:34,400
distance and it tells you what component

00:05:32,960 --> 00:05:37,130
of traveling that distance on that angle

00:05:34,400 --> 00:05:39,590
has actually change on the x axis or the

00:05:37,130 --> 00:05:41,570
y axis and similarly you can pass this

00:05:39,590 --> 00:05:44,840
distance method to points and it'll tell

00:05:41,570 --> 00:05:47,000
you how far apart they are I've written

00:05:44,840 --> 00:05:49,460
a very small library that sits on top of

00:05:47,000 --> 00:05:51,950
gosu and it's where the rapid and the

00:05:49,460 --> 00:05:53,630
title of this talk comes from hasu helps

00:05:51,950 --> 00:05:55,430
you build gosu games as quickly as

00:05:53,630 --> 00:05:58,790
possible and it does this in a couple of

00:05:55,430 --> 00:06:00,710
ways the main thing is hot code loading

00:05:58,790 --> 00:06:02,570
so normally when you're building a GoSee

00:06:00,710 --> 00:06:04,280
game if your game is running and you

00:06:02,570 --> 00:06:05,540
want to change something about it you

00:06:04,280 --> 00:06:08,270
changed your code but then you have to

00:06:05,540 --> 00:06:09,680
quit the game start it back up and go

00:06:08,270 --> 00:06:12,860
back to wherever you were in the game to

00:06:09,680 --> 00:06:14,660
see how it's affected you uh-huh sue

00:06:12,860 --> 00:06:16,070
whenever you save your files it

00:06:14,660 --> 00:06:17,750
immediately loads them and the next

00:06:16,070 --> 00:06:19,540
cycle through the game loop that code is

00:06:17,750 --> 00:06:22,490
in place taking effects

00:06:19,540 --> 00:06:24,290
similarly with gosu when you have an

00:06:22,490 --> 00:06:25,700
exception it crashes out the game and

00:06:24,290 --> 00:06:27,740
you have to start it back up and find

00:06:25,700 --> 00:06:29,930
your way back to where you were

00:06:27,740 --> 00:06:32,510
hasu will catch your exceptions pause

00:06:29,930 --> 00:06:35,710
your game and after you fixed it resume

00:06:32,510 --> 00:06:37,850
your game from where you left off and

00:06:35,710 --> 00:06:39,650
since you're doing your game set up in

00:06:37,850 --> 00:06:41,330
the initialized method of your window

00:06:39,650 --> 00:06:42,730
you only get one shot to do that because

00:06:41,330 --> 00:06:45,260
you only construct your window once

00:06:42,730 --> 00:06:47,090
so in hasu you put your setup code in

00:06:45,260 --> 00:06:50,720
reset and you can just hit the are key

00:06:47,090 --> 00:06:52,580
to reset your game and with that I think

00:06:50,720 --> 00:06:53,249
we know enough to do a pseudo live

00:06:52,580 --> 00:06:55,469
coding demo

00:06:53,249 --> 00:06:56,999
of pong and I say pseudo because I've

00:06:55,469 --> 00:07:00,889
pre-recorded most of it so you don't

00:06:56,999 --> 00:07:03,569
have to watch me fumble through typos or

00:07:00,889 --> 00:07:07,469
or get stuck in a Emacs mode that I

00:07:03,569 --> 00:07:10,619
don't know how to get out of so so we'll

00:07:07,469 --> 00:07:14,549
start out by installing kazoo which will

00:07:10,619 --> 00:07:21,239
also install gosu and pong got RB will

00:07:14,549 --> 00:07:22,979
be the main file for this game will

00:07:21,239 --> 00:07:24,539
subclass ha state window and this is

00:07:22,979 --> 00:07:27,089
going to be our main window class we'll

00:07:24,539 --> 00:07:30,959
give it a width and a height that are

00:07:27,089 --> 00:07:32,339
about 75% of this screen and in our

00:07:30,959 --> 00:07:34,139
initialize method we are gonna have to

00:07:32,339 --> 00:07:35,489
call super up to the gosu window giving

00:07:34,139 --> 00:07:37,819
it the width the height and the fact

00:07:35,489 --> 00:07:41,369
that we don't want it to be full screen

00:07:37,819 --> 00:07:44,519
and we call run on this class and in a

00:07:41,369 --> 00:07:49,159
new tab I'll run this and we have a

00:07:44,519 --> 00:07:49,159
blank window so let's put a ball on this

00:07:49,429 --> 00:07:52,979
for hustle ooh hot code bleeding you

00:07:51,359 --> 00:07:56,699
have to use hostile ode instead of

00:07:52,979 --> 00:07:58,949
require so we'll load up the the file

00:07:56,699 --> 00:08:03,360
with the ball in it during our game

00:07:58,949 --> 00:08:05,849
setup we'll make a new ball and in the

00:08:03,360 --> 00:08:09,589
draw method I'm going to ask the ball to

00:08:05,849 --> 00:08:09,589
draw itself onto the window

00:08:14,020 --> 00:08:18,250
for now the ball is going to consist of

00:08:15,580 --> 00:08:19,810
an exposition and a white position

00:08:18,250 --> 00:08:23,950
representing the center of the ball on

00:08:19,810 --> 00:08:33,160
the screen and I'll start this out in

00:08:23,950 --> 00:08:34,840
the exact middle of the window and for

00:08:33,160 --> 00:08:36,250
drawing I'm going to use the draw quad

00:08:34,840 --> 00:08:45,580
method that I showed you back on the

00:08:36,250 --> 00:08:47,740
slides and here x1 is going to be the

00:08:45,580 --> 00:08:49,450
left edge of the ball x2 will be the

00:08:47,740 --> 00:08:52,030
right edge white one will be the top and

00:08:49,450 --> 00:08:54,150
YC will be the bottom and I'll define

00:08:52,030 --> 00:08:57,400
exactly what those are in just a minute

00:08:54,150 --> 00:08:59,520
and I'm gonna make the ball B red for

00:08:57,400 --> 00:08:59,520
now

00:09:04,820 --> 00:09:10,790
so x1 is going to be the center of the

00:09:06,920 --> 00:09:17,360
ball - half the size of the ball and we

00:09:10,790 --> 00:09:20,150
need to define size real quick and then

00:09:17,360 --> 00:09:23,710
x2 y1 and y2 are all going to be pretty

00:09:20,150 --> 00:09:23,710
similar to what x1 is

00:09:30,680 --> 00:09:35,209
and after we reset we have a bowl on the

00:09:33,619 --> 00:09:38,269
screen and it's a little too small so

00:09:35,209 --> 00:09:39,800
I'm gonna bump it up and you saw that as

00:09:38,269 --> 00:09:41,420
soon as I saved the file and switch back

00:09:39,800 --> 00:09:43,939
to the window the the new code had taken

00:09:41,420 --> 00:09:50,990
effect and don't have to close or reopen

00:09:43,939 --> 00:09:52,639
the game so let's make the ball move we

00:09:50,990 --> 00:09:54,379
now need to add the update method that

00:09:52,639 --> 00:09:59,089
goes who will call as part of the game

00:09:54,379 --> 00:10:02,540
loop and I'll just ask the ball to move

00:09:59,089 --> 00:10:05,269
itself doing that and the ball needs a

00:10:02,540 --> 00:10:07,249
in and a speed to move so I'll go ahead

00:10:05,269 --> 00:10:08,809
and add those to the bowl and I'll have

00:10:07,249 --> 00:10:15,199
it start out always headed to the top

00:10:08,809 --> 00:10:17,509
right with the speed of four and an move

00:10:15,199 --> 00:10:19,309
I'm gonna use offset X and offset Y that

00:10:17,509 --> 00:10:21,470
I showed you back doing the slides to

00:10:19,309 --> 00:10:22,999
figure out how many pixels in the x

00:10:21,470 --> 00:10:25,639
direction and y direction we should move

00:10:22,999 --> 00:10:31,579
to end up moving speed pixels along the

00:10:25,639 --> 00:10:39,439
angle and then I can add those to the X

00:10:31,579 --> 00:10:42,290
in the Y position and we have a moving

00:10:39,439 --> 00:10:44,629
ball and it's a little a little slow so

00:10:42,290 --> 00:10:50,600
I'm gonna bump up the speed just a

00:10:44,629 --> 00:10:52,339
little bit okay so the ball is moving

00:10:50,600 --> 00:10:53,990
off the top edge of the window but we

00:10:52,339 --> 00:10:59,120
really want it to be bouncing so let's

00:10:53,990 --> 00:10:59,809
solve that this is pretty

00:10:59,120 --> 00:11:02,120
straightforward

00:10:59,809 --> 00:11:03,499
so Deering our move method if we detect

00:11:02,120 --> 00:11:05,179
that the ball has gone off the top of

00:11:03,499 --> 00:11:07,790
the screen we'll bump it back down onto

00:11:05,179 --> 00:11:11,559
the screen and then flip the y component

00:11:07,790 --> 00:11:11,559
of the direction that the ball is moving

00:11:14,589 --> 00:11:21,139
and we get a pretty simple bounce there

00:11:16,929 --> 00:11:24,889
and set up the ball to go down into the

00:11:21,139 --> 00:11:26,209
right and we'll do the same thing for

00:11:24,889 --> 00:11:28,490
when the ball moves off the bottom of

00:11:26,209 --> 00:11:31,129
the screen we'll move it back up and

00:11:28,490 --> 00:11:39,019
flip it's the white component of its

00:11:31,129 --> 00:11:40,879
angle and we get some bouncing there I'm

00:11:39,019 --> 00:11:42,709
gonna go ahead and extract out this

00:11:40,879 --> 00:11:43,520
flipping the Y component of the angle

00:11:42,709 --> 00:11:46,040
into a

00:11:43,520 --> 00:11:47,450
method called bounce off edge and if we

00:11:46,040 --> 00:11:48,800
were to have sound effects this would be

00:11:47,450 --> 00:11:53,080
a great place to put a little bleep

00:11:48,800 --> 00:11:53,080
bleep bleep sound while you're playing

00:11:58,930 --> 00:12:03,430
and we don't actually have access to DX

00:12:01,540 --> 00:12:06,129
in bounce off edge because we're

00:12:03,430 --> 00:12:08,670
computing it and move so we can pull the

00:12:06,129 --> 00:12:13,079
ex and ey out into their own methods and

00:12:08,670 --> 00:12:13,079
this will prove useful a couple times

00:12:21,590 --> 00:12:24,680
okay so it's a little boring that the

00:12:23,240 --> 00:12:27,080
ball starts off heading the same

00:12:24,680 --> 00:12:29,600
direction each time so let's randomize

00:12:27,080 --> 00:12:32,560
it just a little bit we don't want it to

00:12:29,600 --> 00:12:34,910
ever go perfectly vertical or perfectly

00:12:32,560 --> 00:12:36,950
horribly vertical so I'll randomize it

00:12:34,910 --> 00:12:39,560
so it has a cone and which it'll move

00:12:36,950 --> 00:12:45,260
and then half the time we'll also want

00:12:39,560 --> 00:12:49,300
it to go to the left as well so we have

00:12:45,260 --> 00:12:51,650
some some random starting state here and

00:12:49,300 --> 00:12:52,730
now we need to handle what what happens

00:12:51,650 --> 00:12:58,670
when the ball moves off the right edge

00:12:52,730 --> 00:13:00,890
or the left edge of the screen so we'll

00:12:58,670 --> 00:13:04,220
give the two players scores which will

00:13:00,890 --> 00:13:08,029
start out at zero and then we'll use the

00:13:04,220 --> 00:13:13,160
gosu font class which takes a name of a

00:13:08,029 --> 00:13:15,290
font and a size and we can use that to

00:13:13,160 --> 00:13:17,510
draw the scores out of the screen so

00:13:15,290 --> 00:13:20,690
I'll draw the left score in the top left

00:13:17,510 --> 00:13:28,010
and the right players score in the top

00:13:20,690 --> 00:13:29,690
right okay so now we need to actually

00:13:28,010 --> 00:13:34,700
change the scores when the ball goes off

00:13:29,690 --> 00:13:36,500
the screen so Deering update we can ask

00:13:34,700 --> 00:13:38,089
the ball if it's moved off the left side

00:13:36,500 --> 00:13:40,900
of the screen and if it has will

00:13:38,089 --> 00:13:44,240
increase the right players score and

00:13:40,900 --> 00:13:47,750
reset where the ball is by constructing

00:13:44,240 --> 00:13:49,010
a new one and we'll do the same thing

00:13:47,750 --> 00:13:51,440
for when the ball moves off the right

00:13:49,010 --> 00:13:56,210
side well increase the left player score

00:13:51,440 --> 00:14:00,920
and make a new ball so we need to add

00:13:56,210 --> 00:14:03,320
off left and off right to ball they are

00:14:00,920 --> 00:14:04,640
pretty strict simple if the left edge of

00:14:03,320 --> 00:14:06,290
the ball has gone off the left edge of

00:14:04,640 --> 00:14:08,900
the screen then we should think of it as

00:14:06,290 --> 00:14:14,990
being off left and if the right side is

00:14:08,900 --> 00:14:16,010
off the right and the same thing on so

00:14:14,990 --> 00:14:18,470
now when the ball goes off the screen

00:14:16,010 --> 00:14:21,050
the the score on the opposite side will

00:14:18,470 --> 00:14:22,279
get incremented but this isn't really

00:14:21,050 --> 00:14:23,710
much of a game yet because there's no

00:14:22,279 --> 00:14:29,420
way to play it

00:14:23,710 --> 00:14:34,250
so we need some paddles so our paddle

00:14:29,420 --> 00:14:35,900
code will go in paddle dot RB and we'll

00:14:34,250 --> 00:14:38,560
have a left paddle and a right paddle

00:14:35,900 --> 00:14:42,430
which will use the same class with a

00:14:38,560 --> 00:14:42,430
different side passed to it

00:14:47,500 --> 00:14:51,160
and like I did with the ball I'm gonna

00:14:49,150 --> 00:14:53,520
ask the paddles to draw themselves on to

00:14:51,160 --> 00:14:53,520
the window

00:15:03,970 --> 00:15:08,769
so we'll make our paddle file with our

00:15:05,919 --> 00:15:11,799
class in it paddles are going to have a

00:15:08,769 --> 00:15:15,269
side and a y position representing the

00:15:11,799 --> 00:15:17,289
vertical center of where the paddle is

00:15:15,269 --> 00:15:19,720
we'll use the side that was passed in

00:15:17,289 --> 00:15:23,339
and we'll always have the paddle start

00:15:19,720 --> 00:15:23,339
out vertically centered in the screen

00:15:25,049 --> 00:15:29,109
and I'm going to cheat a little bit and

00:15:27,069 --> 00:15:31,029
copy and paste the draw method from ball

00:15:29,109 --> 00:15:34,089
because it's actually sort of a general

00:15:31,029 --> 00:15:35,619
rectangle drawing method if we had more

00:15:34,089 --> 00:15:38,199
time we could extract this out into a

00:15:35,619 --> 00:15:42,759
superclass that both ball and paddle

00:15:38,199 --> 00:15:44,079
share so the left edge of the paddle is

00:15:42,759 --> 00:15:46,629
actually going to depend on whether it's

00:15:44,079 --> 00:15:48,069
the left side or the right side so the

00:15:46,629 --> 00:15:53,439
left paddles left edge is going to be

00:15:48,069 --> 00:15:55,239
the left edge of this the window and the

00:15:53,439 --> 00:15:57,579
right paddles left edge is going to be

00:15:55,239 --> 00:15:59,709
the right edge of the window - the width

00:15:57,579 --> 00:16:01,839
of the paddle so I'm gonna go ahead and

00:15:59,709 --> 00:16:09,789
give paddles a width and a height that I

00:16:01,839 --> 00:16:11,169
think looks pretty good and so the right

00:16:09,789 --> 00:16:15,519
side of the paddle is just going to be

00:16:11,169 --> 00:16:18,669
the left side plus its width the top

00:16:15,519 --> 00:16:25,499
edge the center of the paddle - half its

00:16:18,669 --> 00:16:28,509
height and similarly for the bottom edge

00:16:25,499 --> 00:16:31,959
and with that we should have some

00:16:28,509 --> 00:16:36,429
paddles showing up but they still can't

00:16:31,959 --> 00:16:38,829
move so let's make the paddles move so

00:16:36,429 --> 00:16:41,049
for the left paddle I'm gonna use W for

00:16:38,829 --> 00:16:44,289
up and s for down and we'll start with

00:16:41,049 --> 00:16:46,539
having W move the left paddle up so when

00:16:44,289 --> 00:16:48,869
W is pressed we'll call up on the left

00:16:46,539 --> 00:16:48,869
paddle

00:16:52,490 --> 00:16:57,810
and the definition of up is pretty

00:16:55,079 --> 00:17:00,589
simple basically just take a little bit

00:16:57,810 --> 00:17:00,589
off the y-value

00:17:05,670 --> 00:17:09,589
and then down will be the opposite

00:17:12,880 --> 00:17:18,150
and we'll use s to have the left paddle

00:17:15,670 --> 00:17:18,150
moved am

00:17:23,230 --> 00:17:30,220
and it's moving a little slowly well

00:17:26,919 --> 00:17:31,659
first I'm going to have the the up arrow

00:17:30,220 --> 00:17:39,759
and the down arrow control the right

00:17:31,659 --> 00:17:41,230
paddle so the pedals are moving a little

00:17:39,759 --> 00:17:43,989
slowly so I'm going to extract out this

00:17:41,230 --> 00:17:51,580
magic number and bump it up just a

00:17:43,989 --> 00:17:53,049
little bit so there's a little bit of a

00:17:51,580 --> 00:17:55,210
problem with the way our paddles move

00:17:53,049 --> 00:18:00,269
and that's that they can move off the

00:17:55,210 --> 00:18:06,129
edges of the screen just fixing this is

00:18:00,269 --> 00:18:09,249
easy enough if while the paddle is

00:18:06,129 --> 00:18:11,049
moving up its top edge goes off the top

00:18:09,249 --> 00:18:17,109
of the screen we'll just nudge it back

00:18:11,049 --> 00:18:18,759
down a little bit and same thing for

00:18:17,109 --> 00:18:20,710
when it's moving down if the bottom edge

00:18:18,759 --> 00:18:23,999
goes off the bottom of the window

00:18:20,710 --> 00:18:23,999
we'll just nudge it back up

00:18:32,210 --> 00:18:35,570
and so our petals are still kind of

00:18:33,830 --> 00:18:38,210
worthless because they can't block the

00:18:35,570 --> 00:18:42,830
ball so I think it's time to handle that

00:18:38,210 --> 00:18:45,100
problem so back in our update method

00:18:42,830 --> 00:18:48,470
will ask the ball if it's currently

00:18:45,100 --> 00:18:53,149
intersecting with the left paddle and if

00:18:48,470 --> 00:18:58,159
it is we'll ask it to bounce itself off

00:18:53,149 --> 00:19:00,669
of the left paddle and same thing for

00:18:58,159 --> 00:19:00,669
the right paddle

00:19:06,040 --> 00:19:09,550
and it's not super important that you

00:19:07,930 --> 00:19:12,280
understand what this intersect method is

00:19:09,550 --> 00:19:14,260
doing right now it's the sort of general

00:19:12,280 --> 00:19:17,590
are two rectangles overlapping each

00:19:14,260 --> 00:19:19,960
other in two dimensions the math is

00:19:17,590 --> 00:19:22,740
interesting but a little too subtle to

00:19:19,960 --> 00:19:22,740
get into right now

00:19:30,690 --> 00:19:34,679
so when the ball hits our paddle the

00:19:32,909 --> 00:19:38,009
intersect method works but we don't have

00:19:34,679 --> 00:19:45,779
bounced off paddle yet so time to add

00:19:38,009 --> 00:19:49,109
that and when the ball hits the the

00:19:45,779 --> 00:19:50,309
paddle on the Left we need to nudge the

00:19:49,109 --> 00:19:52,470
ball back off the right side of the

00:19:50,309 --> 00:19:55,049
paddle so that it's no longer on top of

00:19:52,470 --> 00:19:57,809
it and the right paddle will need to

00:19:55,049 --> 00:20:02,279
nudge the ball just to the left to make

00:19:57,809 --> 00:20:04,109
sure they are no longer touching and we

00:20:02,279 --> 00:20:05,729
can flip the the x-component of the

00:20:04,109 --> 00:20:13,649
balls angle sort of like we did when it

00:20:05,729 --> 00:20:16,470
hit the top and bottom edge and this

00:20:13,649 --> 00:20:20,309
works but it leads to a slightly boring

00:20:16,470 --> 00:20:23,789
game so we need to do something more

00:20:20,309 --> 00:20:25,470
interesting with the bounce so what I'm

00:20:23,789 --> 00:20:27,269
gonna do is when the ball hits near the

00:20:25,470 --> 00:20:29,999
center of the paddle have it come off at

00:20:27,269 --> 00:20:31,379
a pretty steep angle but when it's hits

00:20:29,999 --> 00:20:35,879
towards the edge of the paddle have it

00:20:31,379 --> 00:20:37,769
come off a little more shallow so I'll

00:20:35,879 --> 00:20:39,119
take the difference between the the

00:20:37,769 --> 00:20:41,220
center of the ball and the center of the

00:20:39,119 --> 00:20:42,299
paddle and divide it by the paddles

00:20:41,220 --> 00:20:45,299
height and this will give us a number

00:20:42,299 --> 00:20:47,609
between negative 0.5 and 0.5 with sort

00:20:45,299 --> 00:20:50,489
of the extremes being near the edges we

00:20:47,609 --> 00:20:52,799
can multiply that by an angle and turn

00:20:50,489 --> 00:21:01,109
the angle a little bit and we'll need to

00:20:52,799 --> 00:21:02,970
flip it for the paddle on the right and

00:21:01,109 --> 00:21:06,749
now we should have a much more

00:21:02,970 --> 00:21:07,799
interesting bounce so when it hits near

00:21:06,749 --> 00:21:10,169
the center it comes off pretty

00:21:07,799 --> 00:21:14,989
horizontal and hits near the edge of the

00:21:10,169 --> 00:21:14,989
paddle we get much more vertical motion

00:21:18,910 --> 00:21:22,870
and as one extra twist whenever we the

00:21:21,610 --> 00:21:24,670
ball hits the paddle we should speed it

00:21:22,870 --> 00:21:27,870
up just a little bit so the game gets

00:21:24,670 --> 00:21:27,870
more challenging as it goes on

00:21:40,280 --> 00:21:44,960
and so I'm a little bored of playing

00:21:42,950 --> 00:21:48,010
pong by myself so let's add a simple AI

00:21:44,960 --> 00:21:48,010
for me to play against

00:21:59,440 --> 00:22:04,300
so during our update method if the left

00:22:01,810 --> 00:22:08,410
paddle is an AI let's get to move itself

00:22:04,300 --> 00:22:11,040
and prevent the human from controlling

00:22:08,410 --> 00:22:11,040
what's going on

00:22:16,850 --> 00:22:20,419
and a lot of a second argument to the

00:22:18,649 --> 00:22:22,480
paddle constructor to show whether it's

00:22:20,419 --> 00:22:29,179
AI or not

00:22:22,480 --> 00:22:36,740
so if Dad gay attribute and take it in

00:22:29,179 --> 00:22:42,649
our constructor and then the AIS

00:22:36,740 --> 00:22:48,470
movement is pretty simple if the ball is

00:22:42,649 --> 00:22:50,919
above it it should move up otherwise it

00:22:48,470 --> 00:22:50,919
should move down

00:22:55,370 --> 00:23:09,990
and so this works but we get this weird

00:22:57,900 --> 00:23:14,070
jittering effect oh dang it I screwed

00:23:09,990 --> 00:23:17,400
that up also of the the jittering effect

00:23:14,070 --> 00:23:18,810
happens later in that one so I'm done

00:23:17,400 --> 00:23:20,400
playing pong now but we still don't have

00:23:18,810 --> 00:23:22,230
a way to close our window so we'll add

00:23:20,400 --> 00:23:24,480
the button down method to our pong

00:23:22,230 --> 00:23:27,210
window which will get called whenever a

00:23:24,480 --> 00:23:30,240
button gets pressed and if the button

00:23:27,210 --> 00:23:31,890
that gets pressed is escape well lost

00:23:30,240 --> 00:23:37,530
the window to close itself ending the

00:23:31,890 --> 00:23:39,800
game loop and that was pong in 15

00:23:37,530 --> 00:23:39,800
minutes

00:23:46,770 --> 00:23:50,320
so I have the source code for all of

00:23:48,880 --> 00:23:52,810
this up on my github if you're

00:23:50,320 --> 00:23:55,270
interested in going back through it the

00:23:52,810 --> 00:23:56,740
commits are put in the order that I

00:23:55,270 --> 00:23:58,330
showed in the video if you're definitely

00:23:56,740 --> 00:24:03,970
interested in following back along the

00:23:58,330 --> 00:24:06,010
same path so this link in the bottom

00:24:03,970 --> 00:24:07,420
right will take you to a gist with links

00:24:06,010 --> 00:24:10,210
to everything else I mentioned during

00:24:07,420 --> 00:24:12,010
this presentation so there's a bunch of

00:24:10,210 --> 00:24:14,980
other gems that work well with gosu

00:24:12,010 --> 00:24:18,900
either built on top of it or just happen

00:24:14,980 --> 00:24:21,280
to work well alongside of it chingu is

00:24:18,900 --> 00:24:22,420
sort of an abstraction on top of gosu

00:24:21,280 --> 00:24:24,100
that gives you a bunch of common

00:24:22,420 --> 00:24:26,470
behavior you probably want in most of

00:24:24,100 --> 00:24:30,070
your games like mapping player input to

00:24:26,470 --> 00:24:33,130
method calls or having menus or drawing

00:24:30,070 --> 00:24:35,410
rectangles things like that chipmunk is

00:24:33,130 --> 00:24:37,870
a 2d physics library so the physics in

00:24:35,410 --> 00:24:39,310
pong is pretty simple but if you want to

00:24:37,870 --> 00:24:41,140
build something like Angry Birds or

00:24:39,310 --> 00:24:42,550
scorched earth you'd be pulling your

00:24:41,140 --> 00:24:44,650
hair out trying to get all that math

00:24:42,550 --> 00:24:47,230
right so each of those would be just a

00:24:44,650 --> 00:24:49,510
couple lines of chipmunk code release C

00:24:47,230 --> 00:24:52,090
is a gem that helps you package Ruby

00:24:49,510 --> 00:24:54,040
applications up into Windows executables

00:24:52,090 --> 00:24:55,960
or Mac apps if you want to distribute

00:24:54,040 --> 00:24:59,110
your games to people who aren't Ruby

00:24:55,960 --> 00:25:01,330
programmers and Ruby the ghost who also

00:24:59,110 --> 00:25:02,830
plays well with the Ruby OpenGL gem

00:25:01,330 --> 00:25:06,070
which is what I did for that minecraft

00:25:02,830 --> 00:25:07,960
clone I showed you earlier and there are

00:25:06,070 --> 00:25:10,720
some somewhat active forums for gosu

00:25:07,960 --> 00:25:12,310
both people showing off their games that

00:25:10,720 --> 00:25:16,050
they've made in gosu and other tools

00:25:12,310 --> 00:25:16,050
they've made to work alongside of it

00:25:16,080 --> 00:25:20,440
there's also a really great freely

00:25:18,670 --> 00:25:22,570
available online book called game

00:25:20,440 --> 00:25:24,520
programming patterns when I first

00:25:22,570 --> 00:25:26,080
started doing game development my web

00:25:24,520 --> 00:25:27,820
development mindset and all the patterns

00:25:26,080 --> 00:25:30,940
I knew didn't really help me structure

00:25:27,820 --> 00:25:32,380
programs in any meaningful way so this

00:25:30,940 --> 00:25:35,290
book is written by a game industry

00:25:32,380 --> 00:25:36,910
veteran who talks about a lot of the

00:25:35,290 --> 00:25:39,550
problems the games have as they start to

00:25:36,910 --> 00:25:41,050
grow and the the patterns that have

00:25:39,550 --> 00:25:44,440
emerged over the decades for solving

00:25:41,050 --> 00:25:46,560
them and that's all I have for you thank

00:25:44,440 --> 00:25:46,560
you

00:25:47,149 --> 00:25:49,210
you

00:25:59,549 --> 00:26:01,610

YouTube URL: https://www.youtube.com/watch?v=Vo5OVEmSDtY


