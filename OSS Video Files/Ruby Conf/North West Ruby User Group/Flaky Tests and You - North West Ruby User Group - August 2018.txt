Title: Flaky Tests and You - North West Ruby User Group - August 2018
Publication date: 2018-08-20
Playlist: North West Ruby User Group
Description: 
	Flaky tests are the bane of every developer. They kill your velocity and sow distrust in your test suite. In this talk we'll look at common causes of flaky tests, how to fix them, and how to avoid writing them in the future.


Rob Paskin is a developer at Createk, where he has been on a crusade to rid (very) large and (very) legacy apps of their flaky tests, as well as trying (very) hard to not put new ones in.

_

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:00,000 --> 00:00:05,250
all right so I'm gonna be here today and

00:00:02,340 --> 00:00:08,189
talking to you about fleet and what you

00:00:05,250 --> 00:00:10,080
can do about someone else robbed my Jeep

00:00:08,189 --> 00:00:12,900
asking on the internet on Twitter and

00:00:10,080 --> 00:00:15,690
get up and all those things and I am a

00:00:12,900 --> 00:00:25,230
developer at critic we're an agency

00:00:15,690 --> 00:00:27,599
based in and copes I will so let's start

00:00:25,230 --> 00:00:32,070
off like with all good talks we're the

00:00:27,599 --> 00:00:33,390
definition what is a flaky test it's

00:00:32,070 --> 00:00:35,210
kind of one of those things it's bit

00:00:33,390 --> 00:00:39,210
like obscenity you know when you see it

00:00:35,210 --> 00:00:41,399
but generally you think of a flaky test

00:00:39,210 --> 00:00:44,280
being some test that fails

00:00:41,399 --> 00:00:46,260
intermittently over it fails on certain

00:00:44,280 --> 00:00:49,230
days of the month or certain times of

00:00:46,260 --> 00:00:51,030
the day there's tests that fail

00:00:49,230 --> 00:00:58,109
sometimes when the run in a certain

00:00:51,030 --> 00:01:00,870
order so I'm like to step back for a bit

00:00:58,109 --> 00:01:02,280
and ask the question why do we have

00:01:00,870 --> 00:01:03,930
tests in the first place

00:01:02,280 --> 00:01:06,150
stiffly why do we have an automated test

00:01:03,930 --> 00:01:09,450
week hopefully if you're all Reavers

00:01:06,150 --> 00:01:12,180
you'll have all work on apps that have

00:01:09,450 --> 00:01:14,430
was made test weeks that are run on some

00:01:12,180 --> 00:01:19,560
CI server somewhere or at least or your

00:01:14,430 --> 00:01:21,299
own machine and it's probably several

00:01:19,560 --> 00:01:23,460
reasons why however I think the main one

00:01:21,299 --> 00:01:24,810
is that it gives you confidence when

00:01:23,460 --> 00:01:28,650
you're making changes to your code

00:01:24,810 --> 00:01:31,049
whether or not that's having new

00:01:28,650 --> 00:01:33,000
features making a factorings or even

00:01:31,049 --> 00:01:33,920
taking out dead code that you think

00:01:33,000 --> 00:01:36,390
isn't used anymore

00:01:33,920 --> 00:01:40,110
it's nice to note that you've got a good

00:01:36,390 --> 00:01:41,549
strong stable test suite that it's got

00:01:40,110 --> 00:01:46,500
your back and will flag up if you have

00:01:41,549 --> 00:01:48,750
any problems now the problem with flaky

00:01:46,500 --> 00:01:51,000
tests is they destroy that confidence

00:01:48,750 --> 00:01:52,770
because if you can no longer say that

00:01:51,000 --> 00:01:55,979
your test suite is stable and

00:01:52,770 --> 00:01:57,600
consistently gives you good results you

00:01:55,979 --> 00:02:00,030
don't know whether you have a flaky test

00:01:57,600 --> 00:02:03,390
that flakes on the side of passing well

00:02:00,030 --> 00:02:07,250
it's actually broken or is broken and

00:02:03,390 --> 00:02:07,250
flakes on the side of passing

00:02:08,300 --> 00:02:12,740
so um I guess probably what you all want

00:02:10,790 --> 00:02:16,970
to know is how do we deal with flaky

00:02:12,740 --> 00:02:18,950
tests so I step 0 after you've

00:02:16,970 --> 00:02:20,830
identified your flaky tests maybe you've

00:02:18,950 --> 00:02:23,960
been through just from word of mouth

00:02:20,830 --> 00:02:27,050
Fallot developers you can do sort of

00:02:23,960 --> 00:02:29,390
Morpher analysis what I've done is

00:02:27,050 --> 00:02:31,040
looked at builds that failed and there

00:02:29,390 --> 00:02:32,150
then succeeded when they retry it and

00:02:31,040 --> 00:02:37,520
looked at those tests that actually

00:02:32,150 --> 00:02:40,700
failed but after that step 0 skip that

00:02:37,520 --> 00:02:45,860
test pretty very cool

00:02:40,700 --> 00:02:48,590
I know but skip it because it's a boss

00:02:45,860 --> 00:02:51,800
dice to phrase it is worse to have a

00:02:48,590 --> 00:02:55,190
flaky test the no test at all because as

00:02:51,800 --> 00:02:57,200
I mentioned the flaky tests can give you

00:02:55,190 --> 00:02:59,870
false negatives or even false positives

00:02:57,200 --> 00:03:05,210
they create false hope and you noticed I

00:02:59,870 --> 00:03:09,140
hope that kills you so skip it but

00:03:05,210 --> 00:03:10,610
equally as important as skipping it so

00:03:09,140 --> 00:03:12,440
this is how you skip it in r-spec you

00:03:10,610 --> 00:03:15,320
could just have a skip come on let's

00:03:12,440 --> 00:03:16,970
skip metadata as well but you can do

00:03:15,320 --> 00:03:21,410
this as many tests or Jasmin already

00:03:16,970 --> 00:03:22,910
tests week really but step two is to

00:03:21,410 --> 00:03:24,950
make a note somewhere over in your

00:03:22,910 --> 00:03:27,110
history tracker your bug tracker and

00:03:24,950 --> 00:03:29,390
your Kanban board or whatever to go back

00:03:27,110 --> 00:03:31,360
and fix those flaky tests because

00:03:29,390 --> 00:03:34,820
otherwise the danger is that they state

00:03:31,360 --> 00:03:37,520
skipped forever and there's a good

00:03:34,820 --> 00:03:39,080
chance that you'll come in and break

00:03:37,520 --> 00:03:40,310
something and then you've code to feet

00:03:39,080 --> 00:03:42,640
the whole point of having an automated

00:03:40,310 --> 00:03:45,530
test suite which is to catch regressions

00:03:42,640 --> 00:03:47,300
so you can either sort of tag them with

00:03:45,530 --> 00:03:50,780
something that's easy grab the ball or

00:03:47,300 --> 00:03:51,890
make a note of all the file paths Jim

00:03:50,780 --> 00:03:57,170
you probably want some impiously grab

00:03:51,890 --> 00:04:00,980
focus file cross can change so onto

00:03:57,170 --> 00:04:02,660
causes a flaky tests so create we work

00:04:00,980 --> 00:04:04,489
on a very large and very legacy

00:04:02,660 --> 00:04:07,520
application that I've been on a bit of a

00:04:04,489 --> 00:04:11,050
crusade recently to get rid of some

00:04:07,520 --> 00:04:13,520
particularly persistent flaky tests and

00:04:11,050 --> 00:04:16,520
so I feel like I probably should address

00:04:13,520 --> 00:04:19,150
the elephant in the room first which is

00:04:16,520 --> 00:04:21,220
capybara and

00:04:19,150 --> 00:04:24,729
I did find that quite a lot of tests

00:04:21,220 --> 00:04:27,010
were due to capybara or in spite of

00:04:24,729 --> 00:04:30,220
capybara or occurred in category tests

00:04:27,010 --> 00:04:34,449
in charitable but actually I found that

00:04:30,220 --> 00:04:38,080
a lot more of the tests failed due to

00:04:34,449 --> 00:04:41,040
randomness so that can I would be

00:04:38,080 --> 00:04:43,389
roundness in values that are going in or

00:04:41,040 --> 00:04:49,150
randomness in the order in which we run

00:04:43,389 --> 00:04:52,660
tests so one particular source of

00:04:49,150 --> 00:04:54,789
randomness which is kind of by design by

00:04:52,660 --> 00:04:57,490
farm was the fakir gem there are other

00:04:54,789 --> 00:05:00,330
gems available but I found that the fake

00:04:57,490 --> 00:05:04,960
Agenor is generally the most popular and

00:05:00,330 --> 00:05:06,400
so the fake gem if not used it before it

00:05:04,960 --> 00:05:10,479
gives you a bunch of methods to create

00:05:06,400 --> 00:05:13,479
realistic looking test data so here's a

00:05:10,479 --> 00:05:16,750
factory or maybe in a fixture that

00:05:13,479 --> 00:05:19,419
you've probably seen or thought of many

00:05:16,750 --> 00:05:22,479
times in your working life if you're a

00:05:19,419 --> 00:05:24,820
developer so we've got user factory that

00:05:22,479 --> 00:05:27,760
defines a name and we just pluck out a

00:05:24,820 --> 00:05:29,470
first name from a faker we take that

00:05:27,760 --> 00:05:31,560
value run with it we don't really care

00:05:29,470 --> 00:05:37,229
what it is

00:05:31,560 --> 00:05:39,880
so here we've got a reasonably standard

00:05:37,229 --> 00:05:42,820
capybara feature spec so creating two

00:05:39,880 --> 00:05:47,039
users this is using the capybara syntax

00:05:42,820 --> 00:05:49,090
sorry the factory other syntax but again

00:05:47,039 --> 00:05:51,669
that's his axe here is not important so

00:05:49,090 --> 00:05:54,010
create two users go into the users path

00:05:51,669 --> 00:05:56,110
making sure that both those users show

00:05:54,010 --> 00:05:58,030
up on the path within filling in some

00:05:56,110 --> 00:06:01,210
preferred search field with the first

00:05:58,030 --> 00:06:03,310
users name or performing that search and

00:06:01,210 --> 00:06:04,690
then we're making assertion that the

00:06:03,310 --> 00:06:08,789
first user thought that we search for

00:06:04,690 --> 00:06:12,580
has turned up but the second user hasn't

00:06:08,789 --> 00:06:14,710
so we commit this one rather test

00:06:12,580 --> 00:06:18,400
locally yeah that's good that's good

00:06:14,710 --> 00:06:19,990
so with an often it's very way and you

00:06:18,400 --> 00:06:21,510
know a time passed it's it's fine it's

00:06:19,990 --> 00:06:26,490
fine it's fine it's fine

00:06:21,510 --> 00:06:26,490
nothing to see here until one day

00:06:26,889 --> 00:06:32,120
yes haha it's the worst letter in the

00:06:31,580 --> 00:06:36,379
alphabet

00:06:32,120 --> 00:06:38,120
especially in red so we see here that

00:06:36,379 --> 00:06:40,249
we've got an arrow on the last

00:06:38,120 --> 00:06:42,800
expectation which is that we're

00:06:40,249 --> 00:06:46,039
expecting user to not to appear and this

00:06:42,800 --> 00:06:48,589
is failing and so you can see here this

00:06:46,039 --> 00:06:52,099
is a capybara saying that we use

00:06:48,589 --> 00:06:55,069
expecting some text to be not there but

00:06:52,099 --> 00:06:57,919
it is there so the more Eagle mode

00:06:55,069 --> 00:07:04,909
amongst you might notice that I've got a

00:06:57,919 --> 00:07:06,979
bit of repetition here and - do you

00:07:04,909 --> 00:07:11,990
understand why that is need to talk

00:07:06,979 --> 00:07:13,999
about pods okay so I had a look at the

00:07:11,990 --> 00:07:16,639
fake gem I wanted to see exactly where

00:07:13,999 --> 00:07:19,520
does these first names come from and it

00:07:16,639 --> 00:07:22,339
turns out that it's just a big yellow

00:07:19,520 --> 00:07:26,960
file it's just a list of names that

00:07:22,339 --> 00:07:27,889
they've deemed that they wanted and in

00:07:26,960 --> 00:07:31,129
the particular version of the

00:07:27,889 --> 00:07:33,589
Generalitat it's just over 3000 so that

00:07:31,129 --> 00:07:36,409
means to my naive my bike and white that

00:07:33,589 --> 00:07:38,389
there's probably about a one in 3,000

00:07:36,409 --> 00:07:39,560
chance that's you're gonna get a

00:07:38,389 --> 00:07:40,550
mismatch probably slightly higher

00:07:39,560 --> 00:07:41,089
because of things like the birthday

00:07:40,550 --> 00:07:45,800
paradox

00:07:41,089 --> 00:07:47,089
I don't know not my petition but yeah

00:07:45,800 --> 00:07:52,689
there's a small chance that Scot flake

00:07:47,089 --> 00:07:56,779
out however there are other factories or

00:07:52,689 --> 00:07:57,770
fakey randomness generators in faker one

00:07:56,779 --> 00:08:00,379
of those quite probably ones its

00:07:57,770 --> 00:08:02,539
countries and countries they don't

00:08:00,379 --> 00:08:05,870
change that often at the moment there's

00:08:02,539 --> 00:08:08,839
245 and so if you're generating around

00:08:05,870 --> 00:08:10,819
the country and one Tesla it fixed

00:08:08,839 --> 00:08:12,770
recently was creating a country

00:08:10,819 --> 00:08:14,810
assigning that country to something and

00:08:12,770 --> 00:08:16,699
then checking the country changed and so

00:08:14,810 --> 00:08:18,860
there's one in 245 chances of actually

00:08:16,699 --> 00:08:20,870
you assign power going you get power go

00:08:18,860 --> 00:08:23,289
back you've got no way of knowing

00:08:20,870 --> 00:08:26,620
whether or not this has she changed and

00:08:23,289 --> 00:08:29,839
a last one subtly favorite from a

00:08:26,620 --> 00:08:34,069
developer where whose project mean

00:08:29,839 --> 00:08:37,640
heritage like the more esoteric factory

00:08:34,069 --> 00:08:39,589
faker ones and there's one that gives

00:08:37,640 --> 00:08:42,199
you laurel rinse characters now

00:08:39,589 --> 00:08:44,180
unfortunately there's fireface little

00:08:42,199 --> 00:08:47,540
rings as well it only gives you 30

00:08:44,180 --> 00:08:50,449
characters i mean obviously they didn't

00:08:47,540 --> 00:08:54,740
read this Silmarillion where i think but

00:08:50,449 --> 00:09:00,140
yeah so this one flakes out majorly so

00:08:54,740 --> 00:09:02,300
what's the fix well in this case we can

00:09:00,140 --> 00:09:05,029
consider this test to be an instance of

00:09:02,300 --> 00:09:07,459
a mystery guest so a mystery guest is

00:09:05,029 --> 00:09:09,680
some piece of information that is

00:09:07,459 --> 00:09:11,930
critical for how the test functions that

00:09:09,680 --> 00:09:13,519
comes from somewhere else in your test

00:09:11,930 --> 00:09:16,760
suite you don't really know where it

00:09:13,519 --> 00:09:18,589
just comes from somewhere and so what we

00:09:16,760 --> 00:09:20,800
do here is dead as we put it front and

00:09:18,589 --> 00:09:25,970
center in the test and we hard code it

00:09:20,800 --> 00:09:27,439
so we can now be sure that these names

00:09:25,970 --> 00:09:28,670
will never at lap notes they don't have

00:09:27,439 --> 00:09:30,620
any overlapping characters as well

00:09:28,670 --> 00:09:35,000
because that's not we could find

00:09:30,620 --> 00:09:36,079
and so we've maybe lost things that we

00:09:35,000 --> 00:09:38,209
might have had sort of surprise

00:09:36,079 --> 00:09:39,620
discoveries where you know if somebody

00:09:38,209 --> 00:09:41,689
had a really long name and i broke my

00:09:39,620 --> 00:09:43,329
test but the flip side is we now have

00:09:41,689 --> 00:09:48,529
hopefully rock-solid

00:09:43,329 --> 00:09:51,890
state will test okay

00:09:48,529 --> 00:09:54,560
the second source were not really source

00:09:51,890 --> 00:09:56,870
of randomness but something that is very

00:09:54,560 --> 00:10:00,890
much prone to breakage with randomness

00:09:56,870 --> 00:10:03,290
is changing local state now hopefully

00:10:00,890 --> 00:10:06,319
most of your tests are self-contained

00:10:03,290 --> 00:10:08,000
they set up and they tear down and they

00:10:06,319 --> 00:10:11,149
don't leave any sort of rubbish or

00:10:08,000 --> 00:10:13,370
change things in their wake but you know

00:10:11,149 --> 00:10:16,790
that was that's the ideal world doesn't

00:10:13,370 --> 00:10:19,600
always happen that way so here we've got

00:10:16,790 --> 00:10:23,360
a user class it's a natural record and

00:10:19,600 --> 00:10:25,819
it's got before safe hook that creates a

00:10:23,360 --> 00:10:29,439
bunch of records for that user like a

00:10:25,819 --> 00:10:31,670
photo and some likes or any up something

00:10:29,439 --> 00:10:33,230
the important thing is it it creates a

00:10:31,670 --> 00:10:34,819
load of stuff that we we don't want

00:10:33,230 --> 00:10:37,279
because we've done some analysis and we

00:10:34,819 --> 00:10:43,850
found that this class majorly slows down

00:10:37,279 --> 00:10:46,189
our test week so we hit the googles and

00:10:43,850 --> 00:10:48,860
we have a look at see okay how do I ask

00:10:46,189 --> 00:10:51,009
you a call back to natural record way

00:10:48,860 --> 00:10:53,509
the real stocks came up

00:10:51,009 --> 00:10:54,829
it's unrealistic of course stackoverflow

00:10:53,509 --> 00:10:56,199
will come up but it probably would lead

00:10:54,829 --> 00:10:59,300
you here

00:10:56,199 --> 00:11:01,550
so how look and says skip a previously

00:10:59,300 --> 00:11:03,709
set callback sounds like what we want

00:11:01,550 --> 00:11:04,670
and then if I'm there's blah blah blah

00:11:03,709 --> 00:11:09,949
who cares for me

00:11:04,670 --> 00:11:13,779
Ella's good so sticking the test and

00:11:09,949 --> 00:11:20,149
yeah now I test wheat runs a lot quicker

00:11:13,779 --> 00:11:24,319
so it's great road tests yeah that's all

00:11:20,149 --> 00:11:24,889
good push up the CI off it goes building

00:11:24,319 --> 00:11:29,809
it's fine

00:11:24,889 --> 00:11:33,399
obviously it nobody fine until of course

00:11:29,809 --> 00:11:39,920
one day in the not-too-distant future

00:11:33,399 --> 00:11:42,319
so now a failure so in this time we have

00:11:39,920 --> 00:11:44,779
a look at the line number because we're

00:11:42,319 --> 00:11:47,569
like well I think I made my change alike

00:11:44,779 --> 00:11:50,980
I'm 130 and this is like nine ten and

00:11:47,569 --> 00:11:58,189
it's like user does this thing and I

00:11:50,980 --> 00:12:00,769
hadn't a but just to be sure we pick up

00:11:58,189 --> 00:12:04,339
the seed that it used and we run the

00:12:00,769 --> 00:12:08,449
tests again and we can see these ones

00:12:04,339 --> 00:12:11,019
fine ones that we added or sped up I

00:12:08,449 --> 00:12:15,679
should say but this one is failing

00:12:11,019 --> 00:12:19,459
so again just make sure change the seed

00:12:15,679 --> 00:12:21,139
around runs fine but you'll notice that

00:12:19,459 --> 00:12:23,059
the seeds which dictates the order in

00:12:21,139 --> 00:12:28,009
which these things run has put this one

00:12:23,059 --> 00:12:29,029
up here and this one down here so I

00:12:28,009 --> 00:12:34,519
think we've probably got some water

00:12:29,029 --> 00:12:36,110
dependence in here so we have a look at

00:12:34,519 --> 00:12:38,629
our file and we can see right down the

00:12:36,110 --> 00:12:43,279
bottom here's what we added a skip

00:12:38,629 --> 00:12:45,290
callback so we scroll up control and so

00:12:43,279 --> 00:12:47,119
we get to nine ten we can see here we've

00:12:45,290 --> 00:12:49,699
got some tests there's actually testing

00:12:47,119 --> 00:12:51,619
but before say a callback so when you

00:12:49,699 --> 00:12:54,980
use a saving that user and expecting

00:12:51,619 --> 00:12:57,829
that user to have done the thing so it

00:12:54,980 --> 00:12:59,600
turns out that skip callback is is a

00:12:57,829 --> 00:13:01,249
badly named effort it should actually be

00:12:59,600 --> 00:13:02,800
called delete callback because that's

00:13:01,249 --> 00:13:05,750
what it does

00:13:02,800 --> 00:13:08,000
the big cool clue

00:13:05,750 --> 00:13:10,459
in retrospect is the fact that you're

00:13:08,000 --> 00:13:13,810
calling on a class and generally class

00:13:10,459 --> 00:13:17,060
methods that are doing something that

00:13:13,810 --> 00:13:21,320
change your state are normally a bad

00:13:17,060 --> 00:13:24,050
idea and so it happens that if this

00:13:21,320 --> 00:13:26,480
thing runs before this thing the

00:13:24,050 --> 00:13:31,370
callback is wiped and so this assertion

00:13:26,480 --> 00:13:35,240
is always going to fail so how do we

00:13:31,370 --> 00:13:38,480
skip it well how'd it fix it so in the

00:13:35,240 --> 00:13:41,260
short-term I'd probably say stop it so

00:13:38,480 --> 00:13:44,269
this is the aspect mock's

00:13:41,260 --> 00:13:45,709
syntax so we we take the user we allow

00:13:44,269 --> 00:13:47,930
them to receive do the thing we just

00:13:45,709 --> 00:13:50,089
returned true so we don't know do all

00:13:47,930 --> 00:13:52,490
that heavy lifting probably longer term

00:13:50,089 --> 00:13:54,529
you may want to look at separating out

00:13:52,490 --> 00:13:56,690
the sort of the creation of stuff from

00:13:54,529 --> 00:13:58,339
the user user model so the user model

00:13:56,690 --> 00:14:01,430
stays light and you've maybe got some

00:13:58,339 --> 00:14:03,079
service or some axillary object that

00:14:01,430 --> 00:14:08,779
creates all the stuff for you in only

00:14:03,079 --> 00:14:10,339
the cases where you want it to okay as

00:14:08,779 --> 00:14:13,399
as on the size something that I

00:14:10,339 --> 00:14:16,699
discovered that is life-changing in

00:14:13,399 --> 00:14:19,699
their small way is aspect by sect so if

00:14:16,699 --> 00:14:21,440
you do find that you have a failing test

00:14:19,699 --> 00:14:24,290
run and you suspected to be all just

00:14:21,440 --> 00:14:26,779
dependent what you can do is cool I

00:14:24,290 --> 00:14:29,720
spoke with the why succeed by sec flag

00:14:26,779 --> 00:14:31,100
give it the seed or it failed and the

00:14:29,720 --> 00:14:33,769
list of file that files all the

00:14:31,100 --> 00:14:36,320
directory like you do aspect will then

00:14:33,769 --> 00:14:39,350
run your tests find out if it is indeed

00:14:36,320 --> 00:14:41,899
order dependent it will then take the

00:14:39,350 --> 00:14:43,220
failing test or failing tests and run

00:14:41,899 --> 00:14:45,920
them repeatedly with a set of

00:14:43,220 --> 00:14:47,329
increasingly smaller number of tests

00:14:45,920 --> 00:14:51,140
until it can find the minimum

00:14:47,329 --> 00:14:54,649
reproducible test test run that fails so

00:14:51,140 --> 00:14:56,180
generally you can find normally quite

00:14:54,649 --> 00:14:58,790
quickly depending on how many files you

00:14:56,180 --> 00:15:01,610
run exactly which file is causing the

00:14:58,790 --> 00:15:04,610
problem and which course it's the other

00:15:01,610 --> 00:15:05,959
file to break so it's amazing you just

00:15:04,610 --> 00:15:08,300
said it running go for lunch come back

00:15:05,959 --> 00:15:11,380
stand your job for you so this is this

00:15:08,300 --> 00:15:11,380
is the future right here

00:15:11,900 --> 00:15:17,370
okay third subject I want to talk about

00:15:14,730 --> 00:15:21,000
is something that I think it's dear in

00:15:17,370 --> 00:15:24,060
all of our hearts date times and time

00:15:21,000 --> 00:15:28,050
zones could probably fill a whole talk

00:15:24,060 --> 00:15:29,580
maybe several talks about the the

00:15:28,050 --> 00:15:32,370
interesting specifics about dates and

00:15:29,580 --> 00:15:36,300
times and time zones I want to focus on

00:15:32,370 --> 00:15:40,710
one which is sort of real specific but I

00:15:36,300 --> 00:15:42,930
found it was quite interesting so we've

00:15:40,710 --> 00:15:45,450
got an app here where you can make

00:15:42,930 --> 00:15:48,300
appointments for some date in the future

00:15:45,450 --> 00:15:50,480
and we have the requirement that a month

00:15:48,300 --> 00:15:52,470
before your appointment you get emailed

00:15:50,480 --> 00:15:55,040
about that appointment just to remind

00:15:52,470 --> 00:15:57,660
you that hey you know still going on

00:15:55,040 --> 00:16:00,270
okay so we can batch out at an

00:15:57,660 --> 00:16:02,730
implementation quite quickly we just say

00:16:00,270 --> 00:16:05,270
you know I'm up from now live over there

00:16:02,730 --> 00:16:08,160
all the appointments then a reminder and

00:16:05,270 --> 00:16:09,750
the test is hopefully reasonably

00:16:08,160 --> 00:16:11,550
straightforward as well the create an

00:16:09,750 --> 00:16:14,850
appointment with the date a month ago

00:16:11,550 --> 00:16:16,260
and then we run it for today and we

00:16:14,850 --> 00:16:24,930
expect that reminder counter to change

00:16:16,260 --> 00:16:27,210
by one yeah it's mine however a few

00:16:24,930 --> 00:16:29,360
months later depending when you're right

00:16:27,210 --> 00:16:29,360
on

00:16:32,540 --> 00:16:40,320
another failure so again we're expecting

00:16:37,980 --> 00:16:42,120
the the count to go up by one but it

00:16:40,320 --> 00:16:46,670
hasn't changed at all so it just hasn't

00:16:42,120 --> 00:16:51,360
sinned them okay so this can happen on

00:16:46,670 --> 00:16:52,860
certain dates and so I think it's worth

00:16:51,360 --> 00:16:55,980
stepping back for a moment and

00:16:52,860 --> 00:16:58,650
considering how rail starts day

00:16:55,980 --> 00:17:00,150
arithmetic because it's really great or

00:16:58,650 --> 00:17:03,060
or if ik depending on the state of view

00:17:00,150 --> 00:17:06,089
that rails monkey patches the integer

00:17:03,060 --> 00:17:11,339
class so we can say one month or three

00:17:06,089 --> 00:17:13,140
days and this returns something called

00:17:11,339 --> 00:17:14,699
an active support duration which kind of

00:17:13,140 --> 00:17:16,650
acts like an integer number of seconds

00:17:14,699 --> 00:17:21,600
but it kind of knows some special things

00:17:16,650 --> 00:17:23,069
about itself and so mumps as hopefully

00:17:21,600 --> 00:17:25,770
we'll learn at prime school don't always

00:17:23,069 --> 00:17:28,740
have 30 days but for the purposes of

00:17:25,770 --> 00:17:30,120
duration a month does because you know

00:17:28,740 --> 00:17:34,800
if you've got pick one that's what big

00:17:30,120 --> 00:17:37,890
30 however if we then say a month from

00:17:34,800 --> 00:17:40,500
now this is not always the same as 30

00:17:37,890 --> 00:17:43,410
days from now yes so these things aren't

00:17:40,500 --> 00:17:47,490
actually synonyms they do know that they

00:17:43,410 --> 00:17:49,700
are represent a month or days and so

00:17:47,490 --> 00:17:53,760
this is the case work we're tripping up

00:17:49,700 --> 00:17:57,179
so if imagine we run this on New Year's

00:17:53,760 --> 00:18:01,590
Eve great time for CRT fails well and we

00:17:57,179 --> 00:18:03,840
say a month ago you'll see that we get

00:18:01,590 --> 00:18:06,390
back the 30th November and this is

00:18:03,840 --> 00:18:07,950
because the way that rails works is it

00:18:06,390 --> 00:18:10,290
will try and find the next matching date

00:18:07,950 --> 00:18:12,690
which in this case will be the 31st and

00:18:10,290 --> 00:18:16,679
November but that doesn't exist still

00:18:12,690 --> 00:18:18,420
then ramp down so then problem then

00:18:16,679 --> 00:18:21,090
arises if we then try and go forward

00:18:18,420 --> 00:18:23,480
from that date because if we go a month

00:18:21,090 --> 00:18:26,990
forward from the first of November

00:18:23,480 --> 00:18:28,980
first time summer does exist so

00:18:26,990 --> 00:18:33,420
unfortunately we can't round-trip these

00:18:28,980 --> 00:18:36,679
values like the ease and simplicity of

00:18:33,420 --> 00:18:36,679
the suppressant ice would suggest

00:18:38,360 --> 00:18:42,710
so in fact you can find all of these

00:18:40,220 --> 00:18:44,870
states you can use the Nattie all year

00:18:42,710 --> 00:18:46,970
method that gives you a range that goes

00:18:44,870 --> 00:18:49,400
from first to generate to say first

00:18:46,970 --> 00:18:51,290
December we can loop over all those

00:18:49,400 --> 00:18:54,320
those states and choose the ones where

00:18:51,290 --> 00:18:56,150
if we go back a month and go to 14

00:18:54,320 --> 00:19:00,140
months we don't get the same date as

00:18:56,150 --> 00:19:03,080
going forward a month and outfalls

00:19:00,140 --> 00:19:06,140
probably the usual suspects a lot of

00:19:03,080 --> 00:19:11,480
dates in March primary because they

00:19:06,140 --> 00:19:14,570
follow February July and December and it

00:19:11,480 --> 00:19:17,720
turns out these are all mumps star

00:19:14,570 --> 00:19:19,970
followed by the months that have 30 days

00:19:17,720 --> 00:19:22,790
and then once that certain one in this

00:19:19,970 --> 00:19:25,940
particular case I find out once

00:19:22,790 --> 00:19:32,570
generally these was about seven dates

00:19:25,940 --> 00:19:35,510
ten tax or crop up time and again so the

00:19:32,570 --> 00:19:36,830
fix in this case and the strategy we

00:19:35,510 --> 00:19:40,580
went for was actually maybe slightly

00:19:36,830 --> 00:19:43,760
oblique because this representative

00:19:40,580 --> 00:19:45,380
ticket that might even be working on on

00:19:43,760 --> 00:19:48,140
and off it come back to us three times

00:19:45,380 --> 00:19:50,360
the various iterations various bugs and

00:19:48,140 --> 00:19:52,700
so we decided in the end actually doing

00:19:50,360 --> 00:19:54,770
all this day arithmetic was kind of

00:19:52,700 --> 00:19:57,680
quite complicated there was no real

00:19:54,770 --> 00:19:59,810
insight for the end user as to when

00:19:57,680 --> 00:20:02,720
actually things get done and so we

00:19:59,810 --> 00:20:05,090
actually kind of come up to the easy way

00:20:02,720 --> 00:20:06,730
out a little bit and scrap the tests and

00:20:05,090 --> 00:20:10,070
decided to change the implementation

00:20:06,730 --> 00:20:12,830
which is always great with do things and

00:20:10,070 --> 00:20:14,840
so we decided to set a static reminder

00:20:12,830 --> 00:20:17,660
date so we calculated this once before

00:20:14,840 --> 00:20:20,960
you create the appointment we now have a

00:20:17,660 --> 00:20:25,310
column that we could now look at we can

00:20:20,960 --> 00:20:27,260
query you can show the users and so we

00:20:25,310 --> 00:20:34,610
can even dependency inject in here so we

00:20:27,260 --> 00:20:36,620
can run it this window methods for today

00:20:34,610 --> 00:20:39,830
or we can pass in other dates if say for

00:20:36,620 --> 00:20:41,590
example the psychic job never that runs

00:20:39,830 --> 00:20:46,450
this falls over

00:20:41,590 --> 00:20:50,680
I would say like you know I'm sure there

00:20:46,450 --> 00:20:51,970
is a way to to fix this I did it's been

00:20:50,680 --> 00:20:54,490
some try and trying to work out like

00:20:51,970 --> 00:20:58,150
okay so away in case it works in all

00:20:54,490 --> 00:21:00,010
cases fortunate don't think there is in

00:20:58,150 --> 00:21:02,590
our case we ended up just writing some

00:21:00,010 --> 00:21:03,910
special cases for these dates and just

00:21:02,590 --> 00:21:05,920
made a note that when the test suite

00:21:03,910 --> 00:21:07,720
runs on those days butts up big yellow

00:21:05,920 --> 00:21:10,870
warning and says yeah it's not going to

00:21:07,720 --> 00:21:14,050
work and shift so date the will work and

00:21:10,870 --> 00:21:16,870
then we test those seven cases sorry the

00:21:14,050 --> 00:21:19,960
five cases separately what we know that

00:21:16,870 --> 00:21:22,090
the dates are going to be a wonky so

00:21:19,960 --> 00:21:26,200
lastly back to the elephant or the

00:21:22,090 --> 00:21:29,440
capybara in the room and I think

00:21:26,200 --> 00:21:32,380
probably the main cause of capibara

00:21:29,440 --> 00:21:37,600
flakiness it's waiting specifically

00:21:32,380 --> 00:21:43,660
capibara not waiting long enough and so

00:21:37,600 --> 00:21:48,160
a fair amount of capybara failures can

00:21:43,660 --> 00:21:51,250
be fixed by rearranging your syntax a

00:21:48,160 --> 00:21:55,630
little bit so for example here we've got

00:21:51,250 --> 00:21:59,640
we using the fine method with an ID now

00:21:55,630 --> 00:22:01,570
this method won't wait but in this case

00:21:59,640 --> 00:22:04,090
we're actually making kind of two

00:22:01,570 --> 00:22:05,650
assertions here which is that there is

00:22:04,090 --> 00:22:09,820
an idea of user somewhere in the page

00:22:05,650 --> 00:22:12,790
and that has the text flaky so the way

00:22:09,820 --> 00:22:14,020
this is written this could succeed but

00:22:12,790 --> 00:22:17,950
it might not have the tête that the

00:22:14,020 --> 00:22:19,900
actual text that we want but every bar

00:22:17,950 --> 00:22:21,550
doesn't care it's found why you want it

00:22:19,900 --> 00:22:25,480
so if we're gonna return something and

00:22:21,550 --> 00:22:27,400
this could be not the text you want so

00:22:25,480 --> 00:22:30,540
generally the rule of thumb is to move

00:22:27,400 --> 00:22:33,430
everything into the assertion if you can

00:22:30,540 --> 00:22:36,150
so most of your code for our session has

00:22:33,430 --> 00:22:38,350
become assertions on page or some

00:22:36,150 --> 00:22:40,960
selector so in this case we use the

00:22:38,350 --> 00:22:43,690
house here that CSS selector and we can

00:22:40,960 --> 00:22:47,220
pass in text and this will do a partial

00:22:43,690 --> 00:22:47,220
max by default

00:22:47,550 --> 00:22:59,320
another one that seems quite innocent in

00:22:52,840 --> 00:23:01,840
a way is doing assertions against the

00:22:59,320 --> 00:23:03,880
current path and this again is something

00:23:01,840 --> 00:23:06,010
that probably works most of the time but

00:23:03,880 --> 00:23:07,630
occasionally Pacific your CI server is

00:23:06,010 --> 00:23:11,250
on the heavy load and that's really

00:23:07,630 --> 00:23:13,390
really slowly and can break and so again

00:23:11,250 --> 00:23:15,730
the solution here is to move everything

00:23:13,390 --> 00:23:20,260
into the assertion and it so happens

00:23:15,730 --> 00:23:24,580
that SEO a special match adjust for the

00:23:20,260 --> 00:23:26,410
current path and this will wait within

00:23:24,580 --> 00:23:30,400
the allotted time to make sure they're

00:23:26,410 --> 00:23:33,910
actually passes so in thinking about

00:23:30,400 --> 00:23:35,470
this I I was actually intrigued one day

00:23:33,910 --> 00:23:36,520
to find out how does Carrie all right

00:23:35,470 --> 00:23:38,320
she does it because you kind of think

00:23:36,520 --> 00:23:42,010
like well just waits it's kind of all a

00:23:38,320 --> 00:23:46,210
bit magical but no turns out it's just a

00:23:42,010 --> 00:23:48,550
big big loop basically for the sleep so

00:23:46,210 --> 00:23:51,040
this is the simplified version of the

00:23:48,550 --> 00:23:55,630
the method gets it gets hit so basically

00:23:51,040 --> 00:23:58,060
record the now time is our start time we

00:23:55,630 --> 00:24:00,400
go through all of these sessions raise

00:23:58,060 --> 00:24:04,420
an error so then we have a look and see

00:24:00,400 --> 00:24:06,670
basically has the has the difference

00:24:04,420 --> 00:24:08,650
between what is now on the start time

00:24:06,670 --> 00:24:09,910
exceeded our wait time which is

00:24:08,650 --> 00:24:12,130
generally I think it's default two

00:24:09,910 --> 00:24:15,970
seconds always we sleep a bit and then

00:24:12,130 --> 00:24:16,900
we retry so cab Bora is basically

00:24:15,970 --> 00:24:25,540
sitting there doing loads of these

00:24:16,900 --> 00:24:29,470
little loops for every assertion okay no

00:24:25,540 --> 00:24:33,340
one a problem that I found is that

00:24:29,470 --> 00:24:36,670
sometimes although you've got things

00:24:33,340 --> 00:24:39,130
that all weight properly often you're

00:24:36,670 --> 00:24:42,100
making assertions against some state in

00:24:39,130 --> 00:24:44,110
the database and again this test will

00:24:42,100 --> 00:24:45,430
probably work most of the time but

00:24:44,110 --> 00:24:48,280
sometimes because we're not actually

00:24:45,430 --> 00:24:50,980
waiting for the form to submit this

00:24:48,280 --> 00:24:52,960
could possibly fail so again the

00:24:50,980 --> 00:24:55,630
solution here is to add an extra

00:24:52,960 --> 00:24:59,580
assertion that something has changed on

00:24:55,630 --> 00:25:04,020
the tech on the page that represents the

00:24:59,580 --> 00:25:05,900
something completely so in this case

00:25:04,020 --> 00:25:10,920
we're just saying like just have a

00:25:05,900 --> 00:25:12,330
welcome message and so again the boss

00:25:10,920 --> 00:25:13,650
that's a phrase if the user action

00:25:12,330 --> 00:25:16,290
doesn't change it's got page column head

00:25:13,650 --> 00:25:18,900
did actually happen you know is this

00:25:16,290 --> 00:25:20,520
test failure or it has flakiness

00:25:18,900 --> 00:25:21,570
actually masking the fact that you know

00:25:20,520 --> 00:25:23,670
we're doing something but we're not

00:25:21,570 --> 00:25:25,260
actually reflecting it to the user and

00:25:23,670 --> 00:25:26,790
so this flaky test has kind of revealed

00:25:25,260 --> 00:25:28,950
a problem in our implementation where

00:25:26,790 --> 00:25:31,740
maybe actually we shouldn't be making

00:25:28,950 --> 00:25:33,930
assertions against the database but

00:25:31,740 --> 00:25:35,430
instead asserting that things are being

00:25:33,930 --> 00:25:38,100
shown to the user that could have only

00:25:35,430 --> 00:25:42,120
happened in this case because they got

00:25:38,100 --> 00:25:44,880
signed up okay so in summary but work

00:25:42,120 --> 00:25:48,830
mystery guests try and bring state that

00:25:44,880 --> 00:25:51,720
your test depend on into the test itself

00:25:48,830 --> 00:25:54,330
be very careful about mutating global

00:25:51,720 --> 00:25:57,110
state and if you do have to because

00:25:54,330 --> 00:25:59,760
sometimes you do try and reset it

00:25:57,110 --> 00:26:00,870
specifically I mean that's where a spec

00:25:59,760 --> 00:26:02,670
mocks is quite good because it

00:26:00,870 --> 00:26:05,730
automatically all do a teardown

00:26:02,670 --> 00:26:07,490
and most important libraries do this for

00:26:05,730 --> 00:26:11,640
you so you know think about it

00:26:07,490 --> 00:26:14,490
use a spit bisect to find what has been

00:26:11,640 --> 00:26:18,260
test it's amazing it's that sort of

00:26:14,490 --> 00:26:21,360
bright shiny AI future we will promised

00:26:18,260 --> 00:26:24,210
remember that not all months days time

00:26:21,360 --> 00:26:26,520
zones are the same unfortunately British

00:26:24,210 --> 00:26:30,180
a look that's British summer time is a

00:26:26,520 --> 00:26:33,950
thing unfortunately that's do fail very

00:26:30,180 --> 00:26:36,960
sometime and it's always good to know

00:26:33,950 --> 00:26:39,420
when capibara will wait what it doesn't

00:26:36,960 --> 00:26:42,620
what methods do and sometimes you might

00:26:39,420 --> 00:26:45,690
need to add in some extra waiting so

00:26:42,620 --> 00:26:47,490
here's my running car Goforth deflate

00:26:45,690 --> 00:26:52,180
your tests thank you

00:26:47,490 --> 00:26:52,180

YouTube URL: https://www.youtube.com/watch?v=Gz9ijgiTjss


