Title: Amsterdam.rb meetup - 18th of May 2021
Publication date: 2021-05-18
Playlist: Amsterdam.rb meetups
Description: 
	Live stream of the Amsterdam.rb meetup of the 18th of May 2021.

All attendees can talk and ask questions with the community and speakers on the Ruby Netherlands Slack. Join our Slack today by following this link: https://amsrbslack.herokuapp.com and navigate to the #amsterdam channel.

With this being a virtual meetup, food and beverages will be of the "bring your own" kind. Grab your most comfy chair and your favorite snacks and join us online!

Program of the event:
00:00 - Welcome and program
06:18 - Wander Hillen on "Fibers from the inside"*
34:54 - Q&A with Wander Hillen
45:10 - Call for speakers
46:01 - Sophia Castellarin on "Building Vagrant (with Vagrant)"
57:33 - Q&A with Sophia Castellarin
1:00:52 - Next meetup announcement

See you on the interwebs!

Arno, Floor, Tom & Rayta

*A continuation of Julik's talk at the last meetup (https://www.youtube.com/watch?v=nk24WMICx4k), and the talk-version of his blog on the subject: https://wjwh.eu/posts/2021-02-07-ruby-preemptive-fiber.html

PS. Are you interested in giving a talk at a future meetup? Contact us on Twitter (https://twitter.com/amsrb), Email (amsrborgs@rubynl.org), or on Slack (@Arno - he/him, @FloorD, @tombruijn or @rayta).

---

Event page: https://www.meetup.com/Amsterdam-rb/events/278021912/

Website: https://amsrb.org/

Twitter: https://twitter.com/amsrb

#Amsterdamrb #Ruby #Meetup #Amsterdam
Captions: 
	00:00:10,719 --> 00:00:15,280
hello

00:00:12,400 --> 00:00:17,119
hello and welcome to our monthly

00:00:15,280 --> 00:00:19,119
amsterdam ruby meetup

00:00:17,119 --> 00:00:22,080
i hope everyone is settled in with some

00:00:19,119 --> 00:00:22,080
snacks and drinks

00:00:23,359 --> 00:00:32,320
i hear myself in an echo

00:00:30,160 --> 00:00:34,000
uh all right i'm going to see you my

00:00:32,320 --> 00:00:35,600
name is uh tonduben

00:00:34,000 --> 00:00:39,120
and i'm one of the amazon ruby

00:00:35,600 --> 00:00:39,120
organizers with me is

00:00:39,280 --> 00:00:46,640
hi i'm raita also one of the organizers

00:00:42,719 --> 00:00:48,960
uh welcome and we're not the only one

00:00:46,640 --> 00:00:51,200
organizing the monthly ruby meetup

00:00:48,960 --> 00:00:51,200
though

00:00:53,280 --> 00:00:56,000
we have a team

00:00:56,840 --> 00:00:59,840
arnold

00:01:00,719 --> 00:01:07,199
i don't think so our team of organizers

00:01:10,880 --> 00:01:14,880
i think our slide deck is stuck

00:01:20,159 --> 00:01:23,439
so well anyway we have a nice ruby team

00:01:22,880 --> 00:01:27,040
so

00:01:23,439 --> 00:01:30,079
the the rest are team uh uh consists of

00:01:27,040 --> 00:01:34,159
um floor and

00:01:30,079 --> 00:01:36,880
uh arno arno is our uh uh

00:01:34,159 --> 00:01:38,240
is our tech lead and audiovisual expert

00:01:36,880 --> 00:01:39,200
he will be doing the technical part of

00:01:38,240 --> 00:01:41,840
the meetup tonight

00:01:39,200 --> 00:01:42,640
and so you can expect some music in the

00:01:41,840 --> 00:01:45,200
the break

00:01:42,640 --> 00:01:46,720
and we have floor dress a senior program

00:01:45,200 --> 00:01:48,479
manager at microsoft

00:01:46,720 --> 00:01:50,240
and organizer of a gazillion other

00:01:48,479 --> 00:01:52,159
meetups and conferences

00:01:50,240 --> 00:01:55,840
so you may have seen her at other

00:01:52,159 --> 00:01:55,840
meetups as well

00:01:56,880 --> 00:02:02,479
um so join the chat uh

00:02:00,399 --> 00:02:04,000
tom you wanna tell the audience

00:02:02,479 --> 00:02:06,079
something about how they can join the

00:02:04,000 --> 00:02:08,399
conversation

00:02:06,079 --> 00:02:10,479
yes i'm gonna talk through this echo for

00:02:08,399 --> 00:02:10,479
me

00:02:10,959 --> 00:02:16,080
um yeah so uh

00:02:14,160 --> 00:02:17,200
let everyone know that you're uh

00:02:16,080 --> 00:02:20,800
watching today

00:02:17,200 --> 00:02:25,920
we're using the uh ams rb hashtag

00:02:20,800 --> 00:02:27,840
on twitter um yes i see the nice banner

00:02:25,920 --> 00:02:29,599
uh please get involved in the chat in

00:02:27,840 --> 00:02:31,760
our slack uh you can

00:02:29,599 --> 00:02:32,959
join by the link that is on screen right

00:02:31,760 --> 00:02:36,239
now

00:02:32,959 --> 00:02:39,280
um please join the amsterdam channel

00:02:36,239 --> 00:02:41,440
to chat about this meetup

00:02:39,280 --> 00:02:43,280
ask your questions and all that later

00:02:41,440 --> 00:02:45,280
and we'll we will

00:02:43,280 --> 00:02:46,879
sorry we will relay the questions to the

00:02:45,280 --> 00:02:51,360
speakers

00:02:46,879 --> 00:02:54,480
when we are in the q a

00:02:51,360 --> 00:02:55,519
yep and so we also have a code of

00:02:54,480 --> 00:02:59,519
conduct

00:02:55,519 --> 00:03:02,640
and please be aware of that and read it

00:02:59,519 --> 00:03:04,800
if you haven't already it's down here

00:03:02,640 --> 00:03:06,640
the the the link to the code of contact

00:03:04,800 --> 00:03:09,040
basically it boils down to

00:03:06,640 --> 00:03:11,440
be kind to each other and respect that

00:03:09,040 --> 00:03:13,760
everybody's here to learn and to share

00:03:11,440 --> 00:03:15,680
and if you do notice something or

00:03:13,760 --> 00:03:18,000
anything unsavory please contact

00:03:15,680 --> 00:03:19,519
any of the organizers through slack dm

00:03:18,000 --> 00:03:21,760
or 230m

00:03:19,519 --> 00:03:22,560
are vietnamese stated in the code of

00:03:21,760 --> 00:03:25,840
conduct

00:03:22,560 --> 00:03:28,879
yay slides

00:03:25,840 --> 00:03:30,879
okay okay so now we have this cool thing

00:03:28,879 --> 00:03:32,319
right

00:03:30,879 --> 00:03:33,760
we need the next slide because we're

00:03:32,319 --> 00:03:34,080
going to show the cool thing the cool

00:03:33,760 --> 00:03:36,959
thing

00:03:34,080 --> 00:03:37,440
yes yes yes coming up in partnership

00:03:36,959 --> 00:03:41,280
with

00:03:37,440 --> 00:03:43,120
other zen look do you like plants

00:03:41,280 --> 00:03:45,200
but i'm gonna do this commercial thingy

00:03:43,120 --> 00:03:48,720
right now right do you like plants

00:03:45,200 --> 00:03:52,000
but do you forget watering them like

00:03:48,720 --> 00:03:52,000
uh tom

00:03:53,439 --> 00:04:01,840
yeah well then you should come and build

00:03:55,680 --> 00:04:01,840
ours a self-watering plant

00:04:05,280 --> 00:04:10,720
so that's the third of june at uh at six

00:04:08,239 --> 00:04:13,360
o'clock with a maximum of 20 people

00:04:10,720 --> 00:04:15,040
we're gonna build a self-watering plant

00:04:13,360 --> 00:04:17,199
system

00:04:15,040 --> 00:04:18,639
yes you will need some development

00:04:17,199 --> 00:04:21,359
experience in this

00:04:18,639 --> 00:04:22,160
uh to get to get to participate in this

00:04:21,359 --> 00:04:24,639
session

00:04:22,160 --> 00:04:26,080
so you make sure you have a macro pc

00:04:24,639 --> 00:04:28,960
with a freebie

00:04:26,080 --> 00:04:29,759
free usb port to hook up an arduino

00:04:28,960 --> 00:04:32,960
board

00:04:29,759 --> 00:04:36,400
and have the arduino ide installed

00:04:32,960 --> 00:04:38,240
ahead of time um to get all set up for

00:04:36,400 --> 00:04:40,240
this event we will send you a package

00:04:38,240 --> 00:04:40,960
with a bunch of stuff like an arduino

00:04:40,240 --> 00:04:42,800
board

00:04:40,960 --> 00:04:44,479
a plant seed so you don't even need to

00:04:42,800 --> 00:04:47,280
choose which center your

00:04:44,479 --> 00:04:49,040
plant you're gonna plant and then

00:04:47,280 --> 00:04:51,440
everything else will also be there like

00:04:49,040 --> 00:04:53,680
a t-shirt some fun swag and even a snack

00:04:51,440 --> 00:04:57,759
and a drink so you don't have to

00:04:53,680 --> 00:05:01,039
you can all set up in one box

00:04:57,759 --> 00:05:03,680
yeah and then the third of june

00:05:01,039 --> 00:05:05,520
will all jump onto a zoom call and in

00:05:03,680 --> 00:05:06,400
two hours you'll build your own watering

00:05:05,520 --> 00:05:08,160
system

00:05:06,400 --> 00:05:10,160
so this event is a great place to

00:05:08,160 --> 00:05:13,600
connect with fellow developers and

00:05:10,160 --> 00:05:13,600
like-minded tech fans

00:05:14,240 --> 00:05:18,240
so let's sign up quickly because again

00:05:16,880 --> 00:05:21,120
we only have

00:05:18,240 --> 00:05:22,000
20 spots check the meetup page for more

00:05:21,120 --> 00:05:24,400
details

00:05:22,000 --> 00:05:25,840
and remember that people signing up have

00:05:24,400 --> 00:05:28,080
to reside in the netherlands

00:05:25,840 --> 00:05:29,680
because we are shipping these things to

00:05:28,080 --> 00:05:31,280
you

00:05:29,680 --> 00:05:34,880
yes and shipping costs out of the

00:05:31,280 --> 00:05:34,880
netherlands are a lot

00:05:35,440 --> 00:05:41,440
so for the program tonight we have two

00:05:39,440 --> 00:05:42,880
we've invited two inspiring speakers we

00:05:41,440 --> 00:05:45,039
will kick off

00:05:42,880 --> 00:05:46,560
uh first we'll talk about firebase

00:05:45,039 --> 00:05:52,000
currency in mri

00:05:46,560 --> 00:05:54,639
from wonder hillen

00:05:52,000 --> 00:05:55,120
the second talk will be about virtual

00:05:54,639 --> 00:05:58,720
machines

00:05:55,120 --> 00:05:59,039
specifically vagrant by sophia and after

00:05:58,720 --> 00:06:01,120
f

00:05:59,039 --> 00:06:02,479
after every talk we will have about 10

00:06:01,120 --> 00:06:06,160
minutes q a

00:06:02,479 --> 00:06:07,680
session and event and we will also have

00:06:06,160 --> 00:06:12,720
a short break about

00:06:07,680 --> 00:06:12,720
say 15 minutes uh between the talks

00:06:13,680 --> 00:06:18,240
yep so um let's get ready for our first

00:06:17,520 --> 00:06:20,720
talk

00:06:18,240 --> 00:06:21,759
uh vanderhillen he's a freelance

00:06:20,720 --> 00:06:24,319
software developer

00:06:21,759 --> 00:06:25,039
he's a runner and a former and military

00:06:24,319 --> 00:06:27,520
officer

00:06:25,039 --> 00:06:29,039
and in this talk wonder will cover a few

00:06:27,520 --> 00:06:29,759
methods to allow for preemptive

00:06:29,039 --> 00:06:33,120
scheduling

00:06:29,759 --> 00:06:33,919
of fibers in mri ruby his talk fibers

00:06:33,120 --> 00:06:36,960
from the emsa

00:06:33,919 --> 00:06:38,800
inside is a continuation of last

00:06:36,960 --> 00:06:40,800
meetup's talk by eulek

00:06:38,800 --> 00:06:42,479
about ruby's new fiber scheduler

00:06:40,800 --> 00:06:48,319
concurrency fibers

00:06:42,479 --> 00:06:51,039
and you so wonder over to you

00:06:48,319 --> 00:06:51,039
yeah yeah

00:06:51,360 --> 00:06:56,560
hello everyone my name is vonna hiller

00:06:54,800 --> 00:07:00,560
and i'm here to talk to you

00:06:56,560 --> 00:07:00,560
about fibers in ruby

00:07:00,639 --> 00:07:07,840
so what i'm gonna talk about uh today

00:07:04,000 --> 00:07:10,479
is uh actually like three things

00:07:07,840 --> 00:07:11,680
uh first i'm gonna go over like what

00:07:10,479 --> 00:07:15,360
unique talk

00:07:11,680 --> 00:07:17,199
talked about last month uh

00:07:15,360 --> 00:07:19,680
just for the people that couldn't attend

00:07:17,199 --> 00:07:22,479
or didn't find the time to watch the

00:07:19,680 --> 00:07:23,120
restroom uh next we'll talk a little bit

00:07:22,479 --> 00:07:24,960
about

00:07:23,120 --> 00:07:27,199
the fiber scheduler interface that is

00:07:24,960 --> 00:07:29,599
new in ruby 3.0

00:07:27,199 --> 00:07:30,479
and finally i will talk a little bit

00:07:29,599 --> 00:07:33,680
about

00:07:30,479 --> 00:07:34,560
auto yielding fibers which is something

00:07:33,680 --> 00:07:38,319
that

00:07:34,560 --> 00:07:40,880
kind of fills up the final bit

00:07:38,319 --> 00:07:40,880
of the

00:07:41,360 --> 00:07:45,360
of the fiber concurrency story and ruby

00:07:44,000 --> 00:07:49,360
as i see

00:07:45,360 --> 00:07:50,319
and finally we'll go a little bit into

00:07:49,360 --> 00:07:53,360
the future

00:07:50,319 --> 00:07:55,599
and we'll see what is actually in store

00:07:53,360 --> 00:08:00,560
for like future reviews

00:07:55,599 --> 00:08:00,560
like us so a little bit

00:08:01,120 --> 00:08:04,879
never mind i thought there wasn't about

00:08:03,120 --> 00:08:07,840
these live tickets now

00:08:04,879 --> 00:08:09,840
uh that's fine my name is vanda i've

00:08:07,840 --> 00:08:10,879
done a lot of talks on the rubio method

00:08:09,840 --> 00:08:14,400
already

00:08:10,879 --> 00:08:15,199
um i used to work for the military as

00:08:14,400 --> 00:08:17,520
well as i said

00:08:15,199 --> 00:08:19,199
but i have found a new calling in

00:08:17,520 --> 00:08:21,759
writing beautiful software

00:08:19,199 --> 00:08:23,280
and ruby is very nice for that i used to

00:08:21,759 --> 00:08:26,639
work for

00:08:23,280 --> 00:08:27,360
with transfer and amsterdam for a long

00:08:26,639 --> 00:08:30,400
while

00:08:27,360 --> 00:08:32,399
uh at the moment i'm a freelancer and

00:08:30,400 --> 00:08:34,479
currently i'm working for a lender and a

00:08:32,399 --> 00:08:37,360
crowdfund funding platform for

00:08:34,479 --> 00:08:38,719
social impact um it's a fun place to

00:08:37,360 --> 00:08:40,000
work and we're always looking for more

00:08:38,719 --> 00:08:43,039
people so check them out

00:08:40,000 --> 00:08:43,760
if you are looking for any words and

00:08:43,039 --> 00:08:47,600
with that

00:08:43,760 --> 00:08:49,760
let's go for the actual contents of the

00:08:47,600 --> 00:08:55,839
talk so what you like talked about

00:08:49,760 --> 00:08:55,839
the last month

00:08:55,920 --> 00:09:00,240
so uh this this is a little bit of a

00:08:58,800 --> 00:09:02,240
quick introduction if you

00:09:00,240 --> 00:09:04,080
are completely out of your debts here

00:09:02,240 --> 00:09:06,480
then i would advise you to

00:09:04,080 --> 00:09:07,200
after this talk go back to the previous

00:09:06,480 --> 00:09:10,240
one

00:09:07,200 --> 00:09:10,880
that in ruby there are basically three

00:09:10,240 --> 00:09:14,000
ways

00:09:10,880 --> 00:09:16,399
of uh doing comprehensive

00:09:14,000 --> 00:09:18,399
uh for doing more than one thing at a

00:09:16,399 --> 00:09:20,399
time because these things

00:09:18,399 --> 00:09:21,760
mix concurrency and parallelism at the

00:09:20,399 --> 00:09:25,040
same time and we have

00:09:21,760 --> 00:09:27,360
processes threads and fibers

00:09:25,040 --> 00:09:29,120
processes share nothing they are

00:09:27,360 --> 00:09:32,320
completely scheduled by the

00:09:29,120 --> 00:09:36,240
operating system and as such they

00:09:32,320 --> 00:09:39,519
can be very parallel but because they

00:09:36,240 --> 00:09:42,160
don't share anything any

00:09:39,519 --> 00:09:43,839
uh object in memory that you could maybe

00:09:42,160 --> 00:09:46,880
share

00:09:43,839 --> 00:09:49,120
um will be invisible to it so each

00:09:46,880 --> 00:09:51,440
process has to keep its own copy

00:09:49,120 --> 00:09:53,040
and that results in a lot of memory

00:09:51,440 --> 00:09:57,200
space being used up

00:09:53,040 --> 00:10:00,720
so the next level down

00:09:57,200 --> 00:10:02,560
is doing threads and you get into

00:10:00,720 --> 00:10:04,079
multicellular program where multiple

00:10:02,560 --> 00:10:06,160
threads can share

00:10:04,079 --> 00:10:07,519
the same error space so for example if

00:10:06,160 --> 00:10:10,640
you are running

00:10:07,519 --> 00:10:13,600
a rails application then you can you

00:10:10,640 --> 00:10:17,200
only have to load all your classes once

00:10:13,600 --> 00:10:20,959
all your threads can share those

00:10:17,200 --> 00:10:22,800
and you don't have to sort of duplicate

00:10:20,959 --> 00:10:24,240
all those objects in memory so that says

00:10:22,800 --> 00:10:27,440
quite a lot of memory

00:10:24,240 --> 00:10:30,800
uh though not as much as you could

00:10:27,440 --> 00:10:33,600
uh save by using pipe because a threat

00:10:30,800 --> 00:10:34,880
still has a its own space in the

00:10:33,600 --> 00:10:38,160
operating system it's

00:10:34,880 --> 00:10:42,000
still scheduled by the operating system

00:10:38,160 --> 00:10:44,160
and in ruby you give up a little bit of

00:10:42,000 --> 00:10:46,399
parallelism by going to sets instead of

00:10:44,160 --> 00:10:48,800
processes

00:10:46,399 --> 00:10:50,880
although as you let talk about last

00:10:48,800 --> 00:10:54,000
month

00:10:50,880 --> 00:10:57,200
there are certain things like ielts

00:10:54,000 --> 00:11:00,800
that can be done and finally

00:10:57,200 --> 00:11:03,680
we come to fibers

00:11:00,800 --> 00:11:05,440
fibers are what's known as co-routines

00:11:03,680 --> 00:11:06,640
and they live on the same operating

00:11:05,440 --> 00:11:08,320
system thread

00:11:06,640 --> 00:11:12,720
so that's also where the name comes from

00:11:08,320 --> 00:11:16,720
because many fibers make up one thread

00:11:12,720 --> 00:11:20,320
they are not parallel at all uh and they

00:11:16,720 --> 00:11:22,800
have to uh share their time on that

00:11:20,320 --> 00:11:24,560
operating system threat manually that

00:11:22,800 --> 00:11:27,360
has to be done by program

00:11:24,560 --> 00:11:28,480
um but what they do gain is because it's

00:11:27,360 --> 00:11:31,600
not a fed they can

00:11:28,480 --> 00:11:32,560
all share that same operating system

00:11:31,600 --> 00:11:35,600
thread

00:11:32,560 --> 00:11:37,839
and by that they can also share for

00:11:35,600 --> 00:11:41,200
example the stack space used by that

00:11:37,839 --> 00:11:44,560
this makes them very very efficient

00:11:41,200 --> 00:11:47,360
that is nice because you can fit

00:11:44,560 --> 00:11:49,760
way more concurrent connections for

00:11:47,360 --> 00:11:52,160
example if you have a way

00:11:49,760 --> 00:11:53,920
something like a website get your

00:11:52,160 --> 00:11:56,880
hosting

00:11:53,920 --> 00:11:59,279
if you use threads or processes you will

00:11:56,880 --> 00:12:01,040
very quickly run into the limits of how

00:11:59,279 --> 00:12:04,560
much one server can

00:12:01,040 --> 00:12:08,320
uh can supply but maybe it

00:12:04,560 --> 00:12:11,360
it runs out of memory way sooner

00:12:08,320 --> 00:12:15,760
than it will run out of processing

00:12:11,360 --> 00:12:15,760
for example um

00:12:17,839 --> 00:12:22,959
fibers are kind of a way around it

00:12:20,800 --> 00:12:26,000
because they are so memory efficient but

00:12:22,959 --> 00:12:28,000
you can fit way more connections

00:12:26,000 --> 00:12:30,399
but of course because they are not

00:12:28,000 --> 00:12:32,160
parallel we come to the like what i call

00:12:30,399 --> 00:12:33,920
the fiber sweet spot which is doing

00:12:32,160 --> 00:12:34,160
nothing and this is amazing computers

00:12:33,920 --> 00:12:36,639
are

00:12:34,160 --> 00:12:38,160
super good they're nothing like people

00:12:36,639 --> 00:12:40,000
by the way um

00:12:38,160 --> 00:12:42,399
and this is because like waiting for

00:12:40,000 --> 00:12:43,519
things is really time efficient like you

00:12:42,399 --> 00:12:45,440
can wait for

00:12:43,519 --> 00:12:47,760
an infinite amount of things at the same

00:12:45,440 --> 00:12:50,000
time like i can

00:12:47,760 --> 00:12:51,519
you know bake a cake and wait for the

00:12:50,000 --> 00:12:52,399
dishwasher and wait for the for the

00:12:51,519 --> 00:12:56,000
learning machine

00:12:52,399 --> 00:12:57,760
i can do all the things at the same time

00:12:56,000 --> 00:12:59,200
and you know if i have more machines i

00:12:57,760 --> 00:13:02,160
could wait for even more

00:12:59,200 --> 00:13:02,160
at the same time right

00:13:02,320 --> 00:13:05,920
of course when they're all done at the

00:13:03,680 --> 00:13:07,839
same time that's a problem

00:13:05,920 --> 00:13:10,480
but if you're a little bit careful about

00:13:07,839 --> 00:13:14,000
it you can wait for like a lot of things

00:13:10,480 --> 00:13:16,720
and most web apps are actually super

00:13:14,000 --> 00:13:16,720
full upgraded

00:13:17,279 --> 00:13:24,079
so uh you wait for a request to come in

00:13:22,000 --> 00:13:25,519
they don't all come at the same time and

00:13:24,079 --> 00:13:27,600
come just once in a while

00:13:25,519 --> 00:13:28,560
hopefully after their busy website and

00:13:27,600 --> 00:13:30,480
have a lot

00:13:28,560 --> 00:13:32,000
but still they won't come in one big

00:13:30,480 --> 00:13:36,240
batch

00:13:32,000 --> 00:13:38,160
them one at a time and

00:13:36,240 --> 00:13:39,760
maybe you have a very simple website

00:13:38,160 --> 00:13:41,519
that just returns files

00:13:39,760 --> 00:13:43,120
but often you will have to do some

00:13:41,519 --> 00:13:46,399
database calls or

00:13:43,120 --> 00:13:48,000
caching calls and you have to wait for

00:13:46,399 --> 00:13:50,800
the database to compute

00:13:48,000 --> 00:13:50,800
your return

00:13:51,040 --> 00:13:56,079
when you finally have your response then

00:13:53,920 --> 00:13:58,079
of course you need to send it to the

00:13:56,079 --> 00:14:00,000
to the user and maybe this is a user

00:13:58,079 --> 00:14:01,600
with a very slow internet connection so

00:14:00,000 --> 00:14:03,920
even you're like

00:14:01,600 --> 00:14:05,360
very lightweight react app that's only

00:14:03,920 --> 00:14:09,680
five megabytes

00:14:05,360 --> 00:14:12,800
uh will take a long time to be sent um

00:14:09,680 --> 00:14:15,279
and you know that's more waiting and in

00:14:12,800 --> 00:14:17,680
all that time that it's waiting

00:14:15,279 --> 00:14:19,279
your computer can do a lot because

00:14:17,680 --> 00:14:21,120
waiting for database caller

00:14:19,279 --> 00:14:23,120
might only take 10 milliseconds or

00:14:21,120 --> 00:14:24,560
something which you might think is not a

00:14:23,120 --> 00:14:26,399
lot of time but for computers

00:14:24,560 --> 00:14:27,760
you can do so much in 10 milliseconds

00:14:26,399 --> 00:14:30,560
you could

00:14:27,760 --> 00:14:32,240
accept a whole bunch of new requests or

00:14:30,560 --> 00:14:36,320
handle other stuff

00:14:32,240 --> 00:14:36,320
and this is really what fires excel

00:14:38,000 --> 00:14:43,680
now they do have big downsides

00:14:41,199 --> 00:14:44,480
and basically the biggest downside is

00:14:43,680 --> 00:14:48,240
that the

00:14:44,480 --> 00:14:51,839
programmer has to manage when they

00:14:48,240 --> 00:14:51,839
when they switch between five

00:14:54,959 --> 00:14:58,320
and this is pretty tricky as we'll see

00:14:56,560 --> 00:14:59,199
that we'll come to that later in the

00:14:58,320 --> 00:15:00,639
talk because

00:14:59,199 --> 00:15:03,360
this downside is basically what the

00:15:00,639 --> 00:15:05,279
topic is about now fighters also cannot

00:15:03,360 --> 00:15:07,120
migrate between threads they're really

00:15:05,279 --> 00:15:09,040
pinned to that one set so

00:15:07,120 --> 00:15:11,199
and that leads us to the third downside

00:15:09,040 --> 00:15:11,839
like if you block a single fiber on the

00:15:11,199 --> 00:15:14,399
thread

00:15:11,839 --> 00:15:15,440
then none of the other fibers can run

00:15:14,399 --> 00:15:17,839
because

00:15:15,440 --> 00:15:18,800
as we talked about they are not very

00:15:17,839 --> 00:15:21,920
parallel

00:15:18,800 --> 00:15:25,040
they are not vertical at all in fact so

00:15:21,920 --> 00:15:26,720
if you have one fiber that that is just

00:15:25,040 --> 00:15:28,160
sitting there doing nothing or maybe

00:15:26,720 --> 00:15:30,880
it's doing a lot of things but

00:15:28,160 --> 00:15:33,120
it's not giving away it's it's time to

00:15:30,880 --> 00:15:34,959
other fibers

00:15:33,120 --> 00:15:37,759
then none of the other fibers on the

00:15:34,959 --> 00:15:40,160
thread go on so you might have

00:15:37,759 --> 00:15:42,639
potentially thousands of fibers waiting

00:15:40,160 --> 00:15:47,440
on this single fiber that's just not

00:15:42,639 --> 00:15:47,440
given back its its allocation

00:15:47,519 --> 00:15:51,199
and this is a this is kind of a big deal

00:15:49,839 --> 00:15:53,519
and all the

00:15:51,199 --> 00:15:56,000
problems with fibers come from this

00:15:53,519 --> 00:15:58,720
third problem

00:15:56,000 --> 00:15:59,519
and it's also like fibers i've been in

00:15:58,720 --> 00:16:03,279
ruby

00:15:59,519 --> 00:16:03,279
for a very long time almost 10 years

00:16:03,360 --> 00:16:11,040
and around them have been

00:16:08,720 --> 00:16:12,320
a couple of very nice frameworks so you

00:16:11,040 --> 00:16:13,600
have event machine

00:16:12,320 --> 00:16:15,680
they don't seem to have a lot of you

00:16:13,600 --> 00:16:16,160
also have cellulite a little bit more

00:16:15,680 --> 00:16:18,079
modern

00:16:16,160 --> 00:16:19,920
it's basic which has the best level it's

00:16:18,079 --> 00:16:23,199
literally a sync

00:16:19,920 --> 00:16:27,360
with a ruby in it anyway

00:16:23,199 --> 00:16:28,800
um but the problem is that you

00:16:27,360 --> 00:16:30,639
need to structure your entire

00:16:28,800 --> 00:16:32,560
application around this framework

00:16:30,639 --> 00:16:34,160
instead of

00:16:32,560 --> 00:16:36,880
structuring it around something else

00:16:34,160 --> 00:16:40,480
that wants to be structured certain

00:16:36,880 --> 00:16:42,959
and usually when um

00:16:40,480 --> 00:16:45,279
when you have that kind of conflict

00:16:42,959 --> 00:16:47,600
rails tends to win

00:16:45,279 --> 00:16:49,120
and then you have a problem because you

00:16:47,600 --> 00:16:51,920
you need to

00:16:49,120 --> 00:16:52,720
to really write your program around the

00:16:51,920 --> 00:16:56,800
use of

00:16:52,720 --> 00:16:56,800
fibers to get the biggest benefits

00:16:57,279 --> 00:17:00,800
the biggest problems is the normal code

00:16:59,600 --> 00:17:04,480
like it will not

00:17:00,800 --> 00:17:06,799
call 500 yield

00:17:04,480 --> 00:17:09,039
input output as we discussed will very

00:17:06,799 --> 00:17:10,400
often block to databases to upstream

00:17:09,039 --> 00:17:14,160
apis

00:17:10,400 --> 00:17:14,160
even sending responses to users

00:17:14,480 --> 00:17:20,640
and even when you

00:17:17,600 --> 00:17:20,959
move around that then big computations

00:17:20,640 --> 00:17:23,120
can

00:17:20,959 --> 00:17:24,559
also block because if you have just have

00:17:23,120 --> 00:17:27,280
a very busy

00:17:24,559 --> 00:17:28,480
wireless computing something um and it

00:17:27,280 --> 00:17:30,400
takes 10 seconds

00:17:28,480 --> 00:17:32,080
then in those 10 seconds it will

00:17:30,400 --> 00:17:35,039
typically and not go

00:17:32,080 --> 00:17:36,880
yield and so any other fighters that

00:17:35,039 --> 00:17:39,760
could run will not run because

00:17:36,880 --> 00:17:40,960
already this big competition is running

00:17:39,760 --> 00:17:42,720
um

00:17:40,960 --> 00:17:45,120
yeah and that's that's kind of tricky

00:17:42,720 --> 00:17:47,360
and because

00:17:45,120 --> 00:17:49,919
in any genuine point there might be such

00:17:47,360 --> 00:17:52,240
a big computation

00:17:49,919 --> 00:17:54,080
you're pretty much housed because you

00:17:52,240 --> 00:17:57,039
either need to use all the

00:17:54,080 --> 00:17:58,000
async or fiber specific gems and if

00:17:57,039 --> 00:17:59,679
there's

00:17:58,000 --> 00:18:01,440
if there's not any of those but they're

00:17:59,679 --> 00:18:04,240
really good non-asynch gen

00:18:01,440 --> 00:18:05,600
you still can't use it um because it

00:18:04,240 --> 00:18:09,120
will probably do stuff that's not

00:18:05,600 --> 00:18:13,039
compatible with your fibers

00:18:09,120 --> 00:18:17,840
so um yeah this this makes filers pretty

00:18:13,039 --> 00:18:17,840
unwieldy to use in production

00:18:19,600 --> 00:18:23,840
in ruby 3.0 it was released last

00:18:21,840 --> 00:18:27,120
christmas

00:18:23,840 --> 00:18:30,000
there was a super cool new development

00:18:27,120 --> 00:18:32,160
which is the fiber scheduler and it

00:18:30,000 --> 00:18:34,160
basically does exactly what you

00:18:32,160 --> 00:18:35,200
uh what what it means it schedules

00:18:34,160 --> 00:18:38,000
fibers

00:18:35,200 --> 00:18:38,960
and now what does this mean it means

00:18:38,000 --> 00:18:41,760
that

00:18:38,960 --> 00:18:44,000
if you have one defined for your current

00:18:41,760 --> 00:18:47,440
thread there's a

00:18:44,000 --> 00:18:50,400
method like uh fiber.scapular

00:18:47,440 --> 00:18:51,039
um then every standard library method

00:18:50,400 --> 00:18:53,600
will call

00:18:51,039 --> 00:18:55,360
yields instead of block and this is

00:18:53,600 --> 00:18:58,720
actually

00:18:55,360 --> 00:19:01,679
an insanely good deal for fibers

00:18:58,720 --> 00:19:02,320
um because let's see how this is

00:19:01,679 --> 00:19:05,520
implemented

00:19:02,320 --> 00:19:06,640
in in all the right and all the read

00:19:05,520 --> 00:19:09,280
methods

00:19:06,640 --> 00:19:11,039
like wherever they are like even if

00:19:09,280 --> 00:19:13,200
they're often some gem

00:19:11,039 --> 00:19:14,559
uh they will be monkey pets because

00:19:13,200 --> 00:19:17,200
everything everywhere

00:19:14,559 --> 00:19:19,440
always comes down to these few things

00:19:17,200 --> 00:19:22,240
that are just implemented by the

00:19:19,440 --> 00:19:22,720
ruby virtual machine so what we're

00:19:22,240 --> 00:19:26,720
looking

00:19:22,720 --> 00:19:30,960
here is a piece of code from from mri

00:19:26,720 --> 00:19:34,000
for that ruby will call if it's

00:19:30,960 --> 00:19:36,720
wants to read from a connection from

00:19:34,000 --> 00:19:38,720
network connection typically

00:19:36,720 --> 00:19:40,000
but there are no glides available then

00:19:38,720 --> 00:19:44,799
it will

00:19:40,000 --> 00:19:48,880
return you know i have no data for you

00:19:44,799 --> 00:19:52,320
and uh ruby will then call

00:19:48,880 --> 00:19:55,600
rb iowa readable

00:19:52,320 --> 00:19:58,559
to uh to not basically

00:19:55,600 --> 00:20:00,799
wait until it's readable it's it's

00:19:58,559 --> 00:20:04,720
pretty straightforward in this naming

00:20:00,799 --> 00:20:08,799
um and the change in ruby 3.0

00:20:04,720 --> 00:20:11,520
is these first five lines um

00:20:08,799 --> 00:20:11,840
let's start with failure scheduler uh

00:20:11,520 --> 00:20:14,080
and

00:20:11,840 --> 00:20:16,159
including the if block and what you see

00:20:14,080 --> 00:20:19,600
there like it says

00:20:16,159 --> 00:20:20,080
if the scheduler is not qml qml is to

00:20:19,600 --> 00:20:22,799
see

00:20:20,080 --> 00:20:23,760
equivalent of what we call just nil and

00:20:22,799 --> 00:20:26,799
ruby

00:20:23,760 --> 00:20:30,640
code then it will do

00:20:26,799 --> 00:20:34,080
our b scheduler iot readable

00:20:30,640 --> 00:20:38,159
and return and

00:20:34,080 --> 00:20:40,559
of course if the scheduler was was qmil

00:20:38,159 --> 00:20:42,080
then this if will not be executed and

00:20:40,559 --> 00:20:43,280
the rest of the function will go as

00:20:42,080 --> 00:20:47,039
normal

00:20:43,280 --> 00:20:50,159
but this rb scheduler ios readable

00:20:47,039 --> 00:20:51,039
is where all the magic heights um so

00:20:50,159 --> 00:20:54,000
what is

00:20:51,039 --> 00:20:54,000
that all about then

00:20:56,400 --> 00:21:02,799
yeah so the

00:20:59,600 --> 00:21:05,840
scheduler um

00:21:02,799 --> 00:21:10,000
receives the fiber and it

00:21:05,840 --> 00:21:10,000
stores it somewhere inside itself

00:21:10,640 --> 00:21:13,919
and then it may use any number of ways

00:21:13,039 --> 00:21:17,280
to determine

00:21:13,919 --> 00:21:20,880
when to resume this fiber again so

00:21:17,280 --> 00:21:23,520
uh and this is deliberately super vague

00:21:20,880 --> 00:21:24,480
like any number of ways or somewhere

00:21:23,520 --> 00:21:27,679
inside itself

00:21:24,480 --> 00:21:30,080
what does this mean well the ruby team

00:21:27,679 --> 00:21:31,200
didn't really have a clear idea of how

00:21:30,080 --> 00:21:34,720
this should look

00:21:31,200 --> 00:21:38,080
so they were like well let's have all

00:21:34,720 --> 00:21:40,159
our generators come up with clever ideas

00:21:38,080 --> 00:21:42,480
and for ruby 3.1 we'll choose one of

00:21:40,159 --> 00:21:44,720
them to be the default but right now

00:21:42,480 --> 00:21:46,880
there is not the default but anyone can

00:21:44,720 --> 00:21:51,679
write their own scheduler

00:21:46,880 --> 00:21:55,679
and use that or use any other scheduler

00:21:51,679 --> 00:21:59,679
in the the scheduler only

00:21:55,679 --> 00:22:03,200
of the standard library will only

00:21:59,679 --> 00:22:06,559
declare how it should behave or

00:22:03,200 --> 00:22:08,960
what methods it should provide

00:22:06,559 --> 00:22:10,400
so for example if you want to be waiting

00:22:08,960 --> 00:22:13,919
for input output

00:22:10,400 --> 00:22:17,520
it could use people on on linux or kq

00:22:13,919 --> 00:22:20,400
if you're on some bsd variant or

00:22:17,520 --> 00:22:23,200
mac os if you could use the i o control

00:22:20,400 --> 00:22:26,640
ports on windows

00:22:23,200 --> 00:22:29,919
if you're trying to block on a timeout

00:22:26,640 --> 00:22:33,120
basically you you do sleep flat

00:22:29,919 --> 00:22:36,159
1000 for example to wait a second

00:22:33,120 --> 00:22:38,159
um that is also a blogging operation

00:22:36,159 --> 00:22:39,520
and so it goes to the schedule it says i

00:22:38,159 --> 00:22:42,240
want to skip for a second

00:22:39,520 --> 00:22:43,360
and schedule school and why don't you go

00:22:42,240 --> 00:22:47,360
sit over there

00:22:43,360 --> 00:22:49,440
mr fiber and in about a second

00:22:47,360 --> 00:22:50,880
i will call resume on you so that you

00:22:49,440 --> 00:22:53,520
can resume

00:22:50,880 --> 00:22:54,799
after that second as if nothing happened

00:22:53,520 --> 00:22:56,960
and in that second

00:22:54,799 --> 00:22:59,120
all the other fighters that have taught

00:22:56,960 --> 00:23:03,120
the schedule that they want to be run

00:22:59,120 --> 00:23:06,840
uh can have their time in the sun um

00:23:03,120 --> 00:23:09,919
this is by the way an incredible

00:23:06,840 --> 00:23:11,600
incredible uh area of uh

00:23:09,919 --> 00:23:13,120
data structures if you like greater

00:23:11,600 --> 00:23:14,720
structures from this this timeline

00:23:13,120 --> 00:23:17,679
section is where you want to be there

00:23:14,720 --> 00:23:20,840
heaps that diamond wheels that all sorts

00:23:17,679 --> 00:23:24,159
of fancy big orientation under the sun

00:23:20,840 --> 00:23:26,960
um just fyi if you're interested

00:23:24,159 --> 00:23:28,080
i am very interested uh then that is the

00:23:26,960 --> 00:23:32,960
place where you want to look

00:23:28,080 --> 00:23:37,120
and there's a lot of good watching um

00:23:32,960 --> 00:23:39,120
but as we mentioned there are actually

00:23:37,120 --> 00:23:40,159
more ways than just sleeping and input

00:23:39,120 --> 00:23:43,760
output for

00:23:40,159 --> 00:23:45,279
a fiber to walk um if you have a big

00:23:43,760 --> 00:23:49,360
computation

00:23:45,279 --> 00:23:51,360
then um it's not necessarily blocking

00:23:49,360 --> 00:23:53,279
but it's certainly not yielding to other

00:23:51,360 --> 00:23:56,480
fibers

00:23:53,279 --> 00:23:59,919
and i was looking at just this

00:23:56,480 --> 00:23:59,919
ruby 3.0 release

00:24:00,640 --> 00:24:04,159
release announcement and i saw this

00:24:02,240 --> 00:24:05,840
fiber scheduler and so this is

00:24:04,159 --> 00:24:08,880
insanely cool but you know there's still

00:24:05,840 --> 00:24:11,360
the big computation button so i was like

00:24:08,880 --> 00:24:13,520
there has to be a good way right so and

00:24:11,360 --> 00:24:16,400
then i thought like this is real

00:24:13,520 --> 00:24:17,600
can i just modify the if statement and

00:24:16,400 --> 00:24:21,520
or the wow

00:24:17,600 --> 00:24:24,799
statement and or maybe even just

00:24:21,520 --> 00:24:29,039
send like can i uh monkey patch

00:24:24,799 --> 00:24:33,120
function goals and you know make my own

00:24:29,039 --> 00:24:35,840
uh so i went off and i looked at

00:24:33,120 --> 00:24:36,880
at the code and it turns out that yeah

00:24:35,840 --> 00:24:39,840
you can

00:24:36,880 --> 00:24:40,720
or well not not really the if statement

00:24:39,840 --> 00:24:42,880
um

00:24:40,720 --> 00:24:45,120
but you can definitely uh override

00:24:42,880 --> 00:24:47,440
function calls

00:24:45,120 --> 00:24:49,760
so my first idea was to do something

00:24:47,440 --> 00:24:52,400
that's erlang popularized

00:24:49,760 --> 00:24:53,679
um because basically you keep a counter

00:24:52,400 --> 00:24:57,120
of how many methods

00:24:53,679 --> 00:24:59,760
have control and

00:24:57,120 --> 00:25:00,960
like every fiber gets let's say a

00:24:59,760 --> 00:25:05,120
thousand method calls

00:25:00,960 --> 00:25:09,840
and once once it's out of method calls

00:25:05,120 --> 00:25:13,440
then then it will always call you

00:25:09,840 --> 00:25:15,279
to give other fighters sometime

00:25:13,440 --> 00:25:16,559
uh in ruby there is something called the

00:25:15,279 --> 00:25:19,279
trace point api

00:25:16,559 --> 00:25:20,400
has been available since like will be

00:25:19,279 --> 00:25:23,279
one point something

00:25:20,400 --> 00:25:24,400
it's been there forever and there's a

00:25:23,279 --> 00:25:28,159
ton of

00:25:24,400 --> 00:25:31,360
events that you can hook into

00:25:28,159 --> 00:25:34,240
it was originally meant for writing

00:25:31,360 --> 00:25:34,799
profiling tools but you can also use it

00:25:34,240 --> 00:25:37,760
for this

00:25:34,799 --> 00:25:40,799
so my first experiment took like three

00:25:37,760 --> 00:25:44,000
minutes to write it was really quick

00:25:40,799 --> 00:25:44,960
and it used this api um but that wasn't

00:25:44,000 --> 00:25:47,440
really

00:25:44,960 --> 00:25:48,320
what it said uh if it did work it did

00:25:47,440 --> 00:25:52,640
work

00:25:48,320 --> 00:25:53,600
um but the code slowed down by five

00:25:52,640 --> 00:25:57,039
times

00:25:53,600 --> 00:25:58,000
so it was not really worth it and i was

00:25:57,039 --> 00:26:00,960
looking at

00:25:58,000 --> 00:26:00,960
why does this happen

00:26:03,520 --> 00:26:10,400
and the problem there was that

00:26:07,600 --> 00:26:12,240
this trade point api itself was mostly

00:26:10,400 --> 00:26:15,120
made in ruby

00:26:12,240 --> 00:26:16,240
so for every ruby method call you did

00:26:15,120 --> 00:26:20,480
you would add

00:26:16,240 --> 00:26:22,240
two or three other method calls

00:26:20,480 --> 00:26:23,919
and that guy the overhead was just

00:26:22,240 --> 00:26:27,360
insane

00:26:23,919 --> 00:26:31,840
luckily there's also

00:26:27,360 --> 00:26:31,840
a c equivalent in the mri exist

00:26:31,919 --> 00:26:35,120
and that's called rv event hook that

00:26:34,320 --> 00:26:38,400
basically

00:26:35,120 --> 00:26:41,200
does what it says it adds event hooks

00:26:38,400 --> 00:26:41,520
and you can use that in much the same

00:26:41,200 --> 00:26:44,559
way

00:26:41,520 --> 00:26:46,960
and that was also pretty nice but

00:26:44,559 --> 00:26:48,960
you know even i i really really tried

00:26:46,960 --> 00:26:50,559
optimizing this

00:26:48,960 --> 00:26:52,400
but i couldn't get it to be more

00:26:50,559 --> 00:26:56,080
efficient than like

00:26:52,400 --> 00:27:00,480
two times slowed down so yeah

00:26:56,080 --> 00:27:01,840
two times slow down is a lot of uh

00:27:00,480 --> 00:27:03,600
you know performance to give up

00:27:01,840 --> 00:27:05,440
especially with ruby being all by the

00:27:03,600 --> 00:27:07,200
hour gonna be three times faster than i

00:27:05,440 --> 00:27:08,799
would do

00:27:07,200 --> 00:27:10,960
so i was like it's probably not a good

00:27:08,799 --> 00:27:10,960
thing

00:27:11,120 --> 00:27:15,679
now of course uh this tracement api as i

00:27:15,120 --> 00:27:17,279
mentioned

00:27:15,679 --> 00:27:18,720
was originally meant for writing

00:27:17,279 --> 00:27:23,120
profiling tools

00:27:18,720 --> 00:27:25,039
and are basically two ways of profiling

00:27:23,120 --> 00:27:26,880
the first one is the trace point way is

00:27:25,039 --> 00:27:28,799
that you hook into everything

00:27:26,880 --> 00:27:32,159
but you can also do sampling profiling

00:27:28,799 --> 00:27:33,919
where you ask the operating system to

00:27:32,159 --> 00:27:35,440
to interrupt your program every once in

00:27:33,919 --> 00:27:37,279
a while and

00:27:35,440 --> 00:27:39,120
when it does that you quickly look what

00:27:37,279 --> 00:27:42,240
hey what was i doing

00:27:39,120 --> 00:27:43,679
and the idea is that over longer periods

00:27:42,240 --> 00:27:45,919
of time you will get on

00:27:43,679 --> 00:27:47,200
average a representative example of your

00:27:45,919 --> 00:27:50,480
product

00:27:47,200 --> 00:27:53,840
so at the time i was working on

00:27:50,480 --> 00:27:57,279
the haskell compiler and

00:27:53,840 --> 00:28:00,320
there i learned about how they do it is

00:27:57,279 --> 00:28:00,880
you can ask the operating system to send

00:28:00,320 --> 00:28:04,799
you

00:28:00,880 --> 00:28:08,080
a signal in linux relief

00:28:04,799 --> 00:28:10,960
to send you a signal um in a certain

00:28:08,080 --> 00:28:12,399
number of milliseconds

00:28:10,960 --> 00:28:15,679
and then you just install a signal

00:28:12,399 --> 00:28:18,960
handler that will call with a

00:28:15,679 --> 00:28:19,440
for us so for example if you say like

00:28:18,960 --> 00:28:22,720
well

00:28:19,440 --> 00:28:23,520
i want any fiber that runs for longer

00:28:22,720 --> 00:28:27,039
than

00:28:23,520 --> 00:28:30,240
50 milliseconds to

00:28:27,039 --> 00:28:34,000
automatically yield you need to say i

00:28:30,240 --> 00:28:37,440
in a um

00:28:34,000 --> 00:28:39,760
in 50 milliseconds please send me

00:28:37,440 --> 00:28:41,679
a signal and you install a signal

00:28:39,760 --> 00:28:45,840
handler that will

00:28:41,679 --> 00:28:45,840
forcibly yield this fiber

00:28:48,640 --> 00:28:55,120
and this is actually

00:28:52,559 --> 00:28:56,960
it sounds very dangerous but it's safe

00:28:55,120 --> 00:29:00,159
because the ruby

00:28:56,960 --> 00:29:02,720
virtual machine will only handle signals

00:29:00,159 --> 00:29:04,640
when it comes to a point where it's safe

00:29:02,720 --> 00:29:06,080
to do so for the ruby internal so it

00:29:04,640 --> 00:29:09,279
will never disrupt your

00:29:06,080 --> 00:29:12,320
ruby code and as

00:29:09,279 --> 00:29:16,080
a as an extra bonus you can have

00:29:12,320 --> 00:29:19,279
a separate subclass of fiber that

00:29:16,080 --> 00:29:22,159
that implements this behavior

00:29:19,279 --> 00:29:23,840
when calling resume and when calling a

00:29:22,159 --> 00:29:25,520
yield

00:29:23,840 --> 00:29:27,120
and you can leave your normal fibers

00:29:25,520 --> 00:29:30,720
alone so if you

00:29:27,120 --> 00:29:34,000
know which of your computers might

00:29:30,720 --> 00:29:36,080
uh might block on big

00:29:34,000 --> 00:29:37,679
the computations then you can have

00:29:36,080 --> 00:29:40,240
ghostbear the yielding

00:29:37,679 --> 00:29:42,880
and you can leave all the other ones on

00:29:40,240 --> 00:29:42,880
the normal day

00:29:43,279 --> 00:29:48,640
and this this was actually pretty nice

00:29:44,960 --> 00:29:48,640
the overhead was only four percent

00:29:49,120 --> 00:29:55,120
and i think it has a lot of benefits

00:29:53,120 --> 00:29:56,559
although there are still a lot of

00:29:55,120 --> 00:29:59,600
downsides as well right

00:29:56,559 --> 00:30:03,840
so um the signal

00:29:59,600 --> 00:30:07,039
uh method is a little bit shaky

00:30:03,840 --> 00:30:11,120
um it is yeah

00:30:07,039 --> 00:30:14,320
it's only i've only made it for linux

00:30:11,120 --> 00:30:16,799
uh it might work on other platforms as

00:30:14,320 --> 00:30:23,840
well but i'm not sure if it will ever be

00:30:16,799 --> 00:30:23,840
like a general solution um

00:30:24,000 --> 00:30:30,399
of course since it relies on

00:30:27,120 --> 00:30:31,679
mri behavior it's probably also an mri

00:30:30,399 --> 00:30:34,840
on the solution

00:30:31,679 --> 00:30:37,520
although if that is a big problem in

00:30:34,840 --> 00:30:42,080
practice

00:30:37,520 --> 00:30:45,760
the c extensions are not

00:30:42,080 --> 00:30:48,720
guaranteed to handle signals in a

00:30:45,760 --> 00:30:50,640
sensible way and they can do an

00:30:48,720 --> 00:30:53,039
arbitrary amount of work

00:30:50,640 --> 00:30:56,399
before they return to the point where

00:30:53,039 --> 00:31:00,640
the ruby vm can handle the signal so

00:30:56,399 --> 00:31:00,640
if you have a lot of big computations in

00:31:00,799 --> 00:31:05,360
eoc extensions then this this might not

00:31:04,240 --> 00:31:08,480
work

00:31:05,360 --> 00:31:10,559
and finally is the

00:31:08,480 --> 00:31:12,640
problem that if you just have too much

00:31:10,559 --> 00:31:15,840
work for one thread

00:31:12,640 --> 00:31:17,120
then since fibers cannot migrate between

00:31:15,840 --> 00:31:19,600
threads

00:31:17,120 --> 00:31:20,880
but what you would want to do is called

00:31:19,600 --> 00:31:24,320
work stealing

00:31:20,880 --> 00:31:27,519
is where a threat that this idol

00:31:24,320 --> 00:31:30,840
can actually take fibers from a thread

00:31:27,519 --> 00:31:33,360
that is really busy

00:31:30,840 --> 00:31:37,279
but yeah that's that's not

00:31:33,360 --> 00:31:40,080
uh currently uh implemented although

00:31:37,279 --> 00:31:41,679
uh i was talking to sarah williams the

00:31:40,080 --> 00:31:44,720
author of the async

00:31:41,679 --> 00:31:46,320
framework and he mentions that oh this

00:31:44,720 --> 00:31:47,919
should be doable in like a week and i

00:31:46,320 --> 00:31:48,960
was like oh my god i thought this would

00:31:47,919 --> 00:31:51,039
be like

00:31:48,960 --> 00:31:52,159
a year of work but he was quite

00:31:51,039 --> 00:31:54,640
optimistic so

00:31:52,159 --> 00:31:54,640
who knows

00:31:55,279 --> 00:32:01,200
um yeah so the fiber future is pretty

00:31:58,720 --> 00:32:03,360
bright i think

00:32:01,200 --> 00:32:05,519
especially with the new fiber scheduling

00:32:03,360 --> 00:32:08,399
interface

00:32:05,519 --> 00:32:09,440
and i think that is because so much of

00:32:08,399 --> 00:32:13,440
ruby workloads

00:32:09,440 --> 00:32:16,480
are in the area of web apps

00:32:13,440 --> 00:32:19,600
and web apps do a lot of io

00:32:16,480 --> 00:32:21,360
and usually not that much actual

00:32:19,600 --> 00:32:25,279
computations

00:32:21,360 --> 00:32:26,480
you can already see this in 6.1 or 6.2

00:32:25,279 --> 00:32:29,360
there will be

00:32:26,480 --> 00:32:30,960
something called load async for active

00:32:29,360 --> 00:32:32,640
record models

00:32:30,960 --> 00:32:35,600
where if you want to do multiple

00:32:32,640 --> 00:32:37,799
database queries you can

00:32:35,600 --> 00:32:40,320
tell them to do like you know

00:32:37,799 --> 00:32:44,159
user.old.loadasync

00:32:40,320 --> 00:32:45,200
and rails will farm that query off to a

00:32:44,159 --> 00:32:48,880
separate

00:32:45,200 --> 00:32:51,600
threadball but why a threadball

00:32:48,880 --> 00:32:52,960
this is actually basically the dream

00:32:51,600 --> 00:32:55,840
case for

00:32:52,960 --> 00:32:56,480
fibers is you want to do a little bit of

00:32:55,840 --> 00:32:59,440
work

00:32:56,480 --> 00:33:00,399
uh some process somewhere else in this

00:32:59,440 --> 00:33:02,480
case the database

00:33:00,399 --> 00:33:03,840
is doing all the actual computations all

00:33:02,480 --> 00:33:05,760
you have to do is wait

00:33:03,840 --> 00:33:07,600
this is exactly why i want fibers

00:33:05,760 --> 00:33:11,519
instead of threads

00:33:07,600 --> 00:33:13,919
so i expect future versions of rails to

00:33:11,519 --> 00:33:15,679
to at least make five of these solutions

00:33:13,919 --> 00:33:19,600
possible for them

00:33:15,679 --> 00:33:21,840
background workers is another case like

00:33:19,600 --> 00:33:23,440
even though they're called workers a lot

00:33:21,840 --> 00:33:25,039
of background workers that i've seen

00:33:23,440 --> 00:33:26,799
don't actually work all that much

00:33:25,039 --> 00:33:29,919
they're mostly background waitress

00:33:26,799 --> 00:33:32,880
right so uh

00:33:29,919 --> 00:33:34,159
at my print job we have several sidekick

00:33:32,880 --> 00:33:37,279
clusters

00:33:34,159 --> 00:33:37,679
uh just for mailers and that's that's

00:33:37,279 --> 00:33:40,880
fine

00:33:37,679 --> 00:33:44,000
i mean mill is an important workload but

00:33:40,880 --> 00:33:45,120
most of what they do is waiting for the

00:33:44,000 --> 00:33:48,480
mail provider

00:33:45,120 --> 00:33:50,480
to say it's okay we sent your mail um

00:33:48,480 --> 00:33:53,440
and this is also like you could get way

00:33:50,480 --> 00:33:56,399
more concurrency with the fiber-based

00:33:53,440 --> 00:33:57,279
background work there aren't any good

00:33:56,399 --> 00:33:59,760
ones yet

00:33:57,279 --> 00:34:00,880
but i think with the fibroscapular

00:33:59,760 --> 00:34:04,320
improvements we'll

00:34:00,880 --> 00:34:07,279
see a few in the interview and finally

00:34:04,320 --> 00:34:08,000
what i think will push buyers further in

00:34:07,279 --> 00:34:10,800
the future

00:34:08,000 --> 00:34:11,919
is just further improvements to the ruby

00:34:10,800 --> 00:34:15,300
itself

00:34:11,919 --> 00:34:16,800
like i mentioned workspeed work stealing

00:34:15,300 --> 00:34:19,119
[Music]

00:34:16,800 --> 00:34:21,040
should be possible there's no technical

00:34:19,119 --> 00:34:22,879
reason that it can't be done

00:34:21,040 --> 00:34:24,800
except that it needs more work in the

00:34:22,879 --> 00:34:28,960
pmi

00:34:24,800 --> 00:34:32,159
and uh in future rubric versions

00:34:28,960 --> 00:34:32,639
there will be a default schedule so all

00:34:32,159 --> 00:34:34,399
this

00:34:32,639 --> 00:34:35,839
magic behavior that i've been talking

00:34:34,399 --> 00:34:38,960
about for the

00:34:35,839 --> 00:34:41,919
um for the last visit

00:34:38,960 --> 00:34:41,919
26 minutes

00:34:42,159 --> 00:34:45,839
will be available but you don't even

00:34:44,879 --> 00:34:47,760
have to

00:34:45,839 --> 00:34:50,320
define your scheduler anymore because it

00:34:47,760 --> 00:34:50,320
will be there

00:34:50,399 --> 00:34:57,520
um well i hope i haven't left you like

00:34:54,240 --> 00:35:00,960
this for childhood or maybe i have

00:34:57,520 --> 00:35:00,960
in which case you might have questions

00:35:01,280 --> 00:35:04,320
so i'm i'm here and if you have

00:35:03,440 --> 00:35:07,599
questions now

00:35:04,320 --> 00:35:09,359
then um or ask them uh

00:35:07,599 --> 00:35:11,119
to the organizing team in any other way

00:35:09,359 --> 00:35:14,320
you know um

00:35:11,119 --> 00:35:16,000
and if you don't uh have any questions

00:35:14,320 --> 00:35:17,760
now without any questions later

00:35:16,000 --> 00:35:21,760
still put them in the slide because i'm

00:35:17,760 --> 00:35:21,760
there pretty often you can answer them

00:35:23,839 --> 00:35:26,240
yes

00:35:26,960 --> 00:35:31,839
thank you wonder

00:35:32,160 --> 00:35:38,560
so we have a couple of questions here um

00:35:36,320 --> 00:35:40,160
let's start uh tom you want to kick off

00:35:38,560 --> 00:35:43,520
with the first question

00:35:40,160 --> 00:35:44,000
yeah we were wondering um having

00:35:43,520 --> 00:35:46,720
researched

00:35:44,000 --> 00:35:48,640
fibers in this way have you been able to

00:35:46,720 --> 00:35:52,079
use fibers in your own app so far

00:35:48,640 --> 00:35:54,720
how did uh how did this help with the um

00:35:52,079 --> 00:35:55,680
i'm i'm currently a freelancer for

00:35:54,720 --> 00:35:58,800
another company so

00:35:55,680 --> 00:36:00,720
my own app is a little bit shaky and i

00:35:58,800 --> 00:36:01,920
i really don't want to be the guy that

00:36:00,720 --> 00:36:04,640
comes somewhere like

00:36:01,920 --> 00:36:05,680
what you should do uh you should rewrite

00:36:04,640 --> 00:36:08,000
everything in the

00:36:05,680 --> 00:36:09,839
inside of this life because those people

00:36:08,000 --> 00:36:13,920
are worse than the knowledge

00:36:09,839 --> 00:36:13,920
it's um

00:36:14,720 --> 00:36:18,640
okay so what did you prompted you to do

00:36:17,599 --> 00:36:21,839
the quick answer

00:36:18,640 --> 00:36:24,880
is um i've definitely played a lot

00:36:21,839 --> 00:36:27,040
with different title liners

00:36:24,880 --> 00:36:27,040
back

00:36:28,800 --> 00:36:31,280
streaming

00:36:32,160 --> 00:36:36,079
servers we did a lot of experiments into

00:36:34,880 --> 00:36:39,359
rewriting those

00:36:36,079 --> 00:36:43,920
into like either

00:36:39,359 --> 00:36:45,520
crystal or fiber-based uh approaches

00:36:43,920 --> 00:36:47,280
but i haven't worked there for one and a

00:36:45,520 --> 00:36:49,760
half years now so i don't know how

00:36:47,280 --> 00:36:52,880
that's projected

00:36:49,760 --> 00:36:52,880
at my current company

00:36:52,960 --> 00:36:57,040
no i i haven't done anything with

00:36:55,119 --> 00:36:59,440
fighters but like i said

00:36:57,040 --> 00:37:00,960
we do have a lot of workloads uh that

00:36:59,440 --> 00:37:03,440
would really benefit

00:37:00,960 --> 00:37:04,640
from the you know fighters like like the

00:37:03,440 --> 00:37:09,839
mailers

00:37:04,640 --> 00:37:09,839
um so timon if you're listening

00:37:12,560 --> 00:37:18,400
yeah so uh we have another question from

00:37:15,599 --> 00:37:19,839
uh david how would you decide when a

00:37:18,400 --> 00:37:23,599
fiber should yield

00:37:19,839 --> 00:37:27,280
is it only on blocking operations

00:37:23,599 --> 00:37:29,280
yeah this is a very good question

00:37:27,280 --> 00:37:31,119
it really depends on the weapon and i

00:37:29,280 --> 00:37:34,400
know this is the worst answer

00:37:31,119 --> 00:37:38,000
ever because it's always true but

00:37:34,400 --> 00:37:38,480
um like certainly on blocking operations

00:37:38,000 --> 00:37:41,680
but

00:37:38,480 --> 00:37:43,200
not only um

00:37:41,680 --> 00:37:45,119
like if you know that your fiber is

00:37:43,200 --> 00:37:48,720
gonna block because it goes to sleep

00:37:45,119 --> 00:37:50,400
or uh i always readable or with writable

00:37:48,720 --> 00:37:52,300
or something like that yeah then you

00:37:50,400 --> 00:37:53,599
should always heal

00:37:52,300 --> 00:37:55,839
[Music]

00:37:53,599 --> 00:37:57,440
and just let the scheduler say like if

00:37:55,839 --> 00:38:00,079
the schedule has nothing better to do

00:37:57,440 --> 00:38:04,560
then it will just return to your pyramid

00:38:00,079 --> 00:38:08,240
um if you um

00:38:04,560 --> 00:38:10,320
have for example a big confess like i

00:38:08,240 --> 00:38:12,960
wrote a blog post as well

00:38:10,320 --> 00:38:14,640
um and there i used a big fibonacci

00:38:12,960 --> 00:38:15,119
computation but you can imagine that you

00:38:14,640 --> 00:38:17,040
have

00:38:15,119 --> 00:38:19,280
just some computation that's really

00:38:17,040 --> 00:38:22,480
intense

00:38:19,280 --> 00:38:26,000
that that would take some time

00:38:22,480 --> 00:38:29,280
and let's say it takes 10 seconds

00:38:26,000 --> 00:38:32,320
right and in this case

00:38:29,280 --> 00:38:34,560
like maybe you think 10 seconds is

00:38:32,320 --> 00:38:36,000
too long because i want to at least

00:38:34,560 --> 00:38:39,839
handle incoming

00:38:36,000 --> 00:38:43,520
connections within half a second

00:38:39,839 --> 00:38:45,839
then you can either in the

00:38:43,520 --> 00:38:46,560
in the loop itself you can say like you

00:38:45,839 --> 00:38:48,800
know if i

00:38:46,560 --> 00:38:50,640
this many spin through the through a

00:38:48,800 --> 00:38:54,240
while loop

00:38:50,640 --> 00:38:58,240
yield and let the fiber come back

00:38:54,240 --> 00:39:01,520
from scheduler when it's time again

00:38:58,240 --> 00:39:04,240
or you can use something like the

00:39:01,520 --> 00:39:06,079
the interrupt-based method that i talked

00:39:04,240 --> 00:39:09,119
about in the talk

00:39:06,079 --> 00:39:12,160
uh if if you have uh if it's some method

00:39:09,119 --> 00:39:14,320
in a gem that you can't really control

00:39:12,160 --> 00:39:15,440
but it's definitely not only on blocking

00:39:14,320 --> 00:39:17,200
operations

00:39:15,440 --> 00:39:18,800
in a traditional sense it can also be

00:39:17,200 --> 00:39:21,760
blocking because it's just

00:39:18,800 --> 00:39:24,480
working for a long time and being a

00:39:21,760 --> 00:39:24,480
responsibility

00:39:24,800 --> 00:39:29,760
yep thank you uh tom you have another

00:39:28,640 --> 00:39:32,240
question

00:39:29,760 --> 00:39:32,880
yes uh so we're talking about fibers and

00:39:32,240 --> 00:39:36,079
it's uh

00:39:32,880 --> 00:39:39,359
all new things in ruby free as well

00:39:36,079 --> 00:39:41,359
um so in your opinion do you think this

00:39:39,359 --> 00:39:43,119
that's this is what ruby is moving

00:39:41,359 --> 00:39:45,760
towards using more fibers also

00:39:43,119 --> 00:39:47,359
internally and things or

00:39:45,760 --> 00:39:49,200
what do you think the future for fiber

00:39:47,359 --> 00:39:52,240
holds fibers

00:39:49,200 --> 00:39:54,839
well actually i think programming in

00:39:52,240 --> 00:39:57,760
general is going to move

00:39:54,839 --> 00:40:01,359
towards like if

00:39:57,760 --> 00:40:04,319
evented loops with

00:40:01,359 --> 00:40:05,440
basically fibers and work stealing to

00:40:04,319 --> 00:40:08,640
handle

00:40:05,440 --> 00:40:11,040
large concurrent operations so you can

00:40:08,640 --> 00:40:14,240
see that in a lot of other languages

00:40:11,040 --> 00:40:14,960
as well and i think this is a really

00:40:14,240 --> 00:40:18,160
good

00:40:14,960 --> 00:40:20,560
way um for uh for

00:40:18,160 --> 00:40:21,839
modern applications with mostly network

00:40:20,560 --> 00:40:25,119
applications

00:40:21,839 --> 00:40:28,160
um to uh to work

00:40:25,119 --> 00:40:31,040
in a um

00:40:28,160 --> 00:40:31,599
yeah on on modern machines like back in

00:40:31,040 --> 00:40:35,040
the day

00:40:31,599 --> 00:40:40,000
that's when we were in uh

00:40:35,040 --> 00:40:41,920
the the cpus weren't quite as fast

00:40:40,000 --> 00:40:43,200
and the networks weren't quite as

00:40:41,920 --> 00:40:46,319
omnipresent as

00:40:43,200 --> 00:40:50,000
as they are now but basically

00:40:46,319 --> 00:40:54,400
all the um like the

00:40:50,000 --> 00:40:58,319
the big say language frameworks that

00:40:54,400 --> 00:41:00,560
that you see in you know

00:40:58,319 --> 00:41:01,760
these series that are up and down like

00:41:00,560 --> 00:41:05,760
you have goals

00:41:01,760 --> 00:41:08,880
invented loops and with work sticking

00:41:05,760 --> 00:41:11,680
you see crystal is moving that that way

00:41:08,880 --> 00:41:13,200
you see that uh in the beam in the in

00:41:11,680 --> 00:41:16,000
electron airline

00:41:13,200 --> 00:41:17,040
uh even engine x is going that way and

00:41:16,000 --> 00:41:19,200
that's like

00:41:17,040 --> 00:41:20,319
c code so i think it's it's really a

00:41:19,200 --> 00:41:23,760
good way like

00:41:20,319 --> 00:41:28,000
if ruby is gonna sort of evolve

00:41:23,760 --> 00:41:31,599
and and many elephants are like the the

00:41:28,000 --> 00:41:33,960
big web uh language or at least

00:41:31,599 --> 00:41:35,280
the biggest dynamic language in

00:41:33,960 --> 00:41:37,839
[Music]

00:41:35,280 --> 00:41:39,119
back-end then i think this is a really

00:41:37,839 --> 00:41:42,400
good way to sort of

00:41:39,119 --> 00:41:45,520
keep up and improve the possibilities of

00:41:42,400 --> 00:41:45,520
the language itself

00:41:47,119 --> 00:41:50,640
cool thank you well it sounds like

00:41:49,920 --> 00:41:53,520
you're uh

00:41:50,640 --> 00:41:54,240
uh you're a pretty great fan of uh

00:41:53,520 --> 00:41:57,440
fibers

00:41:54,240 --> 00:42:00,319
so uh so

00:41:57,440 --> 00:42:01,119
basically so once we can go to dinner

00:42:00,319 --> 00:42:04,000
parties again

00:42:01,119 --> 00:42:04,880
and birthday parties and uh once you're

00:42:04,000 --> 00:42:07,520
allowed to

00:42:04,880 --> 00:42:09,280
what what's what's the what's the other

00:42:07,520 --> 00:42:11,680
elevator pitch for four fibers

00:42:09,280 --> 00:42:12,720
like what do i tell them like why should

00:42:11,680 --> 00:42:14,960
they uh

00:42:12,720 --> 00:42:16,319
uh like my mom for instance now i'm

00:42:14,960 --> 00:42:20,480
joking like what's the other

00:42:16,319 --> 00:42:20,480
elevator quick for for using fibers

00:42:22,800 --> 00:42:26,880
or like basically um what what prompted

00:42:26,560 --> 00:42:28,480
you

00:42:26,880 --> 00:42:30,240
to look into fibers did you have like a

00:42:28,480 --> 00:42:32,319
specific use case like okay

00:42:30,240 --> 00:42:34,000
like this thing is killing me i need

00:42:32,319 --> 00:42:36,800
fibers for this so i'll dive in

00:42:34,000 --> 00:42:37,280
uh i i just thought it was it was very

00:42:36,800 --> 00:42:40,720
good

00:42:37,280 --> 00:42:43,920
but if i had to sell it to someone um

00:42:40,720 --> 00:42:44,960
i i would go for like the oldest and i

00:42:43,920 --> 00:42:47,680
think best

00:42:44,960 --> 00:42:49,359
selling proposition there there there

00:42:47,680 --> 00:42:54,240
was and always will be

00:42:49,359 --> 00:42:55,839
is you you get more for less right

00:42:54,240 --> 00:42:59,680
you get more throughput for the same

00:42:55,839 --> 00:43:01,520
amount of cpus and the same amount of

00:42:59,680 --> 00:43:02,800
server space that you have to buy so in

00:43:01,520 --> 00:43:05,520
a business context

00:43:02,800 --> 00:43:07,680
i think unless you're really doing cpu

00:43:05,520 --> 00:43:10,880
heavy stuff

00:43:07,680 --> 00:43:11,760
then they're not a good fit within a

00:43:10,880 --> 00:43:14,880
place where they

00:43:11,760 --> 00:43:16,640
do fit and as i mentioned i think a lot

00:43:14,880 --> 00:43:19,760
of for example rails apps are an

00:43:16,640 --> 00:43:21,200
extremely good fit then they can really

00:43:19,760 --> 00:43:23,680
shine and they're much better than what

00:43:21,200 --> 00:43:23,680
we have now

00:43:25,040 --> 00:43:32,480
thank you and i think we have time for

00:43:29,040 --> 00:43:32,480
one last question

00:43:32,800 --> 00:43:39,520
uh you have another question tom

00:43:35,839 --> 00:43:42,640
um maybe

00:43:39,520 --> 00:43:43,760
i do see someone more uh do you would

00:43:42,640 --> 00:43:47,280
you have any other

00:43:43,760 --> 00:43:48,640
code examples that you want to share

00:43:47,280 --> 00:43:53,119
from your

00:43:48,640 --> 00:43:56,240
explorations into fiberland um

00:43:53,119 --> 00:43:58,400
yes i do but i will post a link to my

00:43:56,240 --> 00:44:01,599
blog in the swept

00:43:58,400 --> 00:44:02,720
if that's okay because i don't you know

00:44:01,599 --> 00:44:04,880
it's difficult to

00:44:02,720 --> 00:44:07,040
present the code in there you know just

00:44:04,880 --> 00:44:09,359
by speaking about it

00:44:07,040 --> 00:44:11,040
all right then we'll wait for it in

00:44:09,359 --> 00:44:14,160
slack

00:44:11,040 --> 00:44:16,720
okay okay

00:44:14,160 --> 00:44:19,200
uh well thank you very much for your uh

00:44:16,720 --> 00:44:22,480
for your time and your amazing talk uh

00:44:19,200 --> 00:44:25,440
wonder i definitely catch up in our

00:44:22,480 --> 00:44:27,040
uh in our slack um i think the community

00:44:25,440 --> 00:44:28,640
is loving your talk

00:44:27,040 --> 00:44:30,880
and uh maybe there are a couple of

00:44:28,640 --> 00:44:35,440
questions there that that we missed so

00:44:30,880 --> 00:44:37,839
feel free to to look them up um

00:44:35,440 --> 00:44:38,720
i think we're uh we're ready for a break

00:44:37,839 --> 00:44:42,400
right home

00:44:38,720 --> 00:44:45,520
yes we are and this time

00:44:42,400 --> 00:44:48,400
there's music so yeah we're going

00:44:45,520 --> 00:44:48,800
live and when we are yeah i hope it's

00:44:48,400 --> 00:44:52,480
not

00:44:48,800 --> 00:45:04,800
too loud we'll be back in 15 minutes

00:44:52,480 --> 00:45:06,960
or so around 8 ish see you then

00:45:04,800 --> 00:45:07,920
hello everyone welcome back from our

00:45:06,960 --> 00:45:11,359
little break

00:45:07,920 --> 00:45:14,800
hope everyone got a new glass of drink

00:45:11,359 --> 00:45:20,160
of choice uh before we get started

00:45:14,800 --> 00:45:20,160
uh let's talk about speakers

00:45:20,960 --> 00:45:23,920
or no slides

00:45:24,720 --> 00:45:28,319
myself yes hello so before we get

00:45:27,760 --> 00:45:29,520
started

00:45:28,319 --> 00:45:31,359
we're planning the next couple of

00:45:29,520 --> 00:45:32,720
meetups ahead

00:45:31,359 --> 00:45:35,839
so for the next couple of months and

00:45:32,720 --> 00:45:39,760
we're looking for speakers

00:45:35,839 --> 00:45:42,240
so let us know if you're up for that and

00:45:39,760 --> 00:45:44,319
send us a twitter dm or send us an email

00:45:42,240 --> 00:45:44,720
or find us on slack if you know who we

00:45:44,319 --> 00:45:47,440
are

00:45:44,720 --> 00:45:48,560
find our faces in the member list and

00:45:47,440 --> 00:45:51,440
send us a little

00:45:48,560 --> 00:45:51,760
description of your talk a title like a

00:45:51,440 --> 00:45:55,200
two

00:45:51,760 --> 00:45:58,560
free sentence summary and then we can

00:45:55,200 --> 00:45:58,560
plan you in for the next couple of

00:45:58,839 --> 00:46:03,839
events

00:46:00,079 --> 00:46:04,960
yes um thank you tom so let's get ready

00:46:03,839 --> 00:46:08,000
for our second

00:46:04,960 --> 00:46:11,440
talk um big welcome to

00:46:08,000 --> 00:46:14,400
sofia sofia is a software engineer at

00:46:11,440 --> 00:46:14,720
hashicorp by sophia and she's working on

00:46:14,400 --> 00:46:16,960
the

00:46:14,720 --> 00:46:18,160
fragrant project she previously worked

00:46:16,960 --> 00:46:21,359
for anaconda inc

00:46:18,160 --> 00:46:23,839
mo and utsuit and today she will

00:46:21,359 --> 00:46:24,880
talk about building fragrant with

00:46:23,839 --> 00:46:29,839
fragrant

00:46:24,880 --> 00:46:29,839
sophia take it away

00:46:39,280 --> 00:46:45,760
i'm muted turns out um okay i can start

00:46:42,720 --> 00:46:48,000
from the beginning can you hear me now

00:46:45,760 --> 00:46:50,319
uh okay so uh thanks again for the

00:46:48,000 --> 00:46:51,200
introduction um sophia uh today i have a

00:46:50,319 --> 00:46:53,119
little talk

00:46:51,200 --> 00:46:55,920
uh prepared about building vagrant with

00:46:53,119 --> 00:46:56,319
vagrant and the challenges that go along

00:46:55,920 --> 00:46:59,359
with

00:46:56,319 --> 00:47:01,280
um with building ruby applications and

00:46:59,359 --> 00:47:02,640
distributing them to to users on the

00:47:01,280 --> 00:47:05,280
desktop

00:47:02,640 --> 00:47:06,000
uh so a little bit a little bit about me

00:47:05,280 --> 00:47:07,599
i'm sophia

00:47:06,000 --> 00:47:09,599
i'm a software engineer on the vagrant

00:47:07,599 --> 00:47:10,079
team i've been open source for a few

00:47:09,599 --> 00:47:13,440
years

00:47:10,079 --> 00:47:15,599
in ruby and and in python

00:47:13,440 --> 00:47:17,280
um so a little bit about figuring before

00:47:15,599 --> 00:47:19,040
we get started for for people who aren't

00:47:17,280 --> 00:47:22,079
familiar vagrant is a

00:47:19,040 --> 00:47:26,240
ruby desktop application that is used to

00:47:22,079 --> 00:47:26,240
manage virtual machines in the cli

00:47:27,200 --> 00:47:30,559
so we're going to talk a little bit

00:47:29,760 --> 00:47:33,280
about

00:47:30,559 --> 00:47:33,839
how we go ahead and package vagrant and

00:47:33,280 --> 00:47:36,960
our

00:47:33,839 --> 00:47:39,440
challenges there if you're interested in

00:47:36,960 --> 00:47:40,000
checking out our github about like how

00:47:39,440 --> 00:47:42,240
we do

00:47:40,000 --> 00:47:43,200
like this process uh you can find it at

00:47:42,240 --> 00:47:46,800
hashicorp

00:47:43,200 --> 00:47:50,079
vagrant dash installers

00:47:46,800 --> 00:47:50,800
so um ruby is pretty awesome with like

00:47:50,079 --> 00:47:52,480
their gem

00:47:50,800 --> 00:47:54,160
thing they have going on you just like

00:47:52,480 --> 00:47:55,119
gem build and you have this artifact

00:47:54,160 --> 00:47:57,119
that it's just like

00:47:55,119 --> 00:47:58,559
installable or runnable anywhere you

00:47:57,119 --> 00:48:01,680
have a ruby interpreter

00:47:58,559 --> 00:48:03,599
so this is like super awesome uh if you

00:48:01,680 --> 00:48:06,480
have like

00:48:03,599 --> 00:48:07,680
control over where this application is

00:48:06,480 --> 00:48:11,280
running

00:48:07,680 --> 00:48:14,240
but say you are going to give this

00:48:11,280 --> 00:48:15,119
a gem to someone to run on their desktop

00:48:14,240 --> 00:48:17,440
then

00:48:15,119 --> 00:48:19,359
maybe you might run into a bit of

00:48:17,440 --> 00:48:21,920
troubles like

00:48:19,359 --> 00:48:22,880
the user has to then know uh which ruby

00:48:21,920 --> 00:48:25,280
to run against

00:48:22,880 --> 00:48:26,720
um maybe they their dependencies in your

00:48:25,280 --> 00:48:29,280
application like there are

00:48:26,720 --> 00:48:31,119
with vagrant and you need to like have

00:48:29,280 --> 00:48:32,720
different versions of some softwares

00:48:31,119 --> 00:48:35,839
available

00:48:32,720 --> 00:48:37,839
and this becomes like a a big process

00:48:35,839 --> 00:48:39,920
uh for for users to be running the

00:48:37,839 --> 00:48:41,520
project but also for developers to like

00:48:39,920 --> 00:48:44,480
do stuff like recreate

00:48:41,520 --> 00:48:46,400
uh issues so the question is how do i

00:48:44,480 --> 00:48:48,319
get a ruby application to be

00:48:46,400 --> 00:48:50,079
easy installable and running

00:48:48,319 --> 00:48:50,720
consistently across many different

00:48:50,079 --> 00:48:53,680
machines

00:48:50,720 --> 00:48:54,960
so answering this question really

00:48:53,680 --> 00:48:56,640
provides

00:48:54,960 --> 00:48:59,200
value to to the end user so they don't

00:48:56,640 --> 00:49:01,200
need to know a lot about how to run

00:48:59,200 --> 00:49:02,480
the project that they're trying to run

00:49:01,200 --> 00:49:05,520
um and it also helps

00:49:02,480 --> 00:49:06,240
us developers so that we can recreate

00:49:05,520 --> 00:49:08,160
issues

00:49:06,240 --> 00:49:10,160
and actually solve bugs instead of just

00:49:08,160 --> 00:49:13,040
trying to to track down

00:49:10,160 --> 00:49:14,800
uh if there is some like incompatibility

00:49:13,040 --> 00:49:17,119
between different versions of rubies in

00:49:14,800 --> 00:49:20,160
our application

00:49:17,119 --> 00:49:20,720
so the answer that we have is to package

00:49:20,160 --> 00:49:24,000
up

00:49:20,720 --> 00:49:25,760
um favorite um so ship it with with ruby

00:49:24,000 --> 00:49:26,319
and all of its dependencies and that way

00:49:25,760 --> 00:49:28,800
we can

00:49:26,319 --> 00:49:29,440
control the environment that ruby

00:49:28,800 --> 00:49:32,800
actually

00:49:29,440 --> 00:49:35,839
or vagrant actually runs in

00:49:32,800 --> 00:49:38,800
uh so we do this um

00:49:35,839 --> 00:49:39,680
this process using vagrant so before we

00:49:38,800 --> 00:49:42,319
get into that

00:49:39,680 --> 00:49:46,559
um for the uninitiated let's talk a

00:49:42,319 --> 00:49:48,400
little bit about how vagrant works

00:49:46,559 --> 00:49:49,760
so the vagrant file is like the

00:49:48,400 --> 00:49:52,800
configuration unit

00:49:49,760 --> 00:49:54,480
for like running any vagrant project so

00:49:52,800 --> 00:49:57,119
this tells you like what your project

00:49:54,480 --> 00:49:59,760
should actually looks like

00:49:57,119 --> 00:50:01,920
um we have a vagrant box and this is

00:49:59,760 --> 00:50:04,640
basically like the machine image

00:50:01,920 --> 00:50:06,800
that um like gets brought up when you

00:50:04,640 --> 00:50:09,839
run like a vagrant up

00:50:06,800 --> 00:50:10,800
and then we also allow you to have

00:50:09,839 --> 00:50:14,240
provisioners

00:50:10,800 --> 00:50:16,319
so here you can define things to run

00:50:14,240 --> 00:50:19,280
against your target machine

00:50:16,319 --> 00:50:19,280
once it's brought up

00:50:20,400 --> 00:50:24,240
so now that we're all experts in

00:50:23,040 --> 00:50:25,839
fragrant

00:50:24,240 --> 00:50:29,280
we can go ahead and build some

00:50:25,839 --> 00:50:31,520
installers using vagrant

00:50:29,280 --> 00:50:33,040
so the first step in this process is to

00:50:31,520 --> 00:50:33,599
make sure we have like reproducible

00:50:33,040 --> 00:50:36,480
builds

00:50:33,599 --> 00:50:37,359
um so we use packer to do this um we

00:50:36,480 --> 00:50:39,440
create some

00:50:37,359 --> 00:50:41,200
vmware machines with it we install all

00:50:39,440 --> 00:50:41,839
of the build tools we need and then we

00:50:41,200 --> 00:50:44,160
use the

00:50:41,839 --> 00:50:45,119
vagrant post processor to spit out our

00:50:44,160 --> 00:50:48,240
vagrant boxes

00:50:45,119 --> 00:50:50,160
so in our vagrant file we can say

00:50:48,240 --> 00:50:51,680
that the box we want to use is the one

00:50:50,160 --> 00:50:55,839
we generated

00:50:51,680 --> 00:50:55,839
using our packer process

00:50:56,400 --> 00:51:02,319
and then the next thing to do is to

00:51:00,319 --> 00:51:04,000
write a script that actually goes ahead

00:51:02,319 --> 00:51:07,440
and builds our installers

00:51:04,000 --> 00:51:08,240
and we can ask vagrant to be able to run

00:51:07,440 --> 00:51:11,119
this script

00:51:08,240 --> 00:51:12,079
against our target machine whenever we

00:51:11,119 --> 00:51:15,359
bring it up

00:51:12,079 --> 00:51:15,359
using a provisioner

00:51:17,280 --> 00:51:21,440
okay so now that we have our vagrant

00:51:19,520 --> 00:51:22,800
file kind of set up so that the process

00:51:21,440 --> 00:51:24,480
of building our installers should be

00:51:22,800 --> 00:51:25,839
pretty streamlined we need to actually

00:51:24,480 --> 00:51:28,240
do the thing where we

00:51:25,839 --> 00:51:29,200
like figure out how to build the package

00:51:28,240 --> 00:51:32,319
um so

00:51:29,200 --> 00:51:33,440
in vagrant we have three steps that we

00:51:32,319 --> 00:51:35,680
follow

00:51:33,440 --> 00:51:36,480
the first is building the substrate and

00:51:35,680 --> 00:51:38,079
then

00:51:36,480 --> 00:51:39,599
that's like all of the packages that

00:51:38,079 --> 00:51:41,760
vagrant relies on

00:51:39,599 --> 00:51:42,640
then we build actual vagrant so that's

00:51:41,760 --> 00:51:45,200
doing like

00:51:42,640 --> 00:51:45,920
the gem build step and then we need to

00:51:45,200 --> 00:51:48,160
generate an

00:51:45,920 --> 00:51:50,160
installable package so that's like the

00:51:48,160 --> 00:51:53,440
the step where we have a

00:51:50,160 --> 00:51:56,640
thing that a user can install

00:51:53,440 --> 00:51:58,079
so the substrate layer as i mentioned is

00:51:56,640 --> 00:51:58,640
all of the dependencies that vagrant

00:51:58,079 --> 00:52:01,200
needs

00:51:58,640 --> 00:52:02,480
so that's like building out ruby and its

00:52:01,200 --> 00:52:04,640
dependencies

00:52:02,480 --> 00:52:05,520
and curl and some of the other uh stuff

00:52:04,640 --> 00:52:08,720
that favorite

00:52:05,520 --> 00:52:11,119
relies on um we're

00:52:08,720 --> 00:52:14,319
like a little bit cautious about when we

00:52:11,119 --> 00:52:16,079
um change this layer of of our package

00:52:14,319 --> 00:52:17,359
um we're like looking out for stuff like

00:52:16,079 --> 00:52:20,559
if any of the

00:52:17,359 --> 00:52:23,920
dependencies have cves or something or

00:52:20,559 --> 00:52:25,680
um if between versions uh behavior

00:52:23,920 --> 00:52:27,200
changes then we need to be like really

00:52:25,680 --> 00:52:30,720
cognizant of those things

00:52:27,200 --> 00:52:30,720
whenever we're changing the substrate

00:52:30,839 --> 00:52:34,480
layer

00:52:32,079 --> 00:52:36,559
the package layer um is where we do this

00:52:34,480 --> 00:52:39,040
step where we build our gem and then

00:52:36,559 --> 00:52:39,839
install it into our substrate and then

00:52:39,040 --> 00:52:41,200
this is also

00:52:39,839 --> 00:52:43,520
where we do that last step where we

00:52:41,200 --> 00:52:47,040
generate a generate of the package

00:52:43,520 --> 00:52:50,160
so this generating of the package

00:52:47,040 --> 00:52:53,119
uh is different per each uh

00:52:50,160 --> 00:52:54,079
system that we're running on so on mac

00:52:53,119 --> 00:52:57,520
we'll use like

00:52:54,079 --> 00:53:00,880
package build and dmg build uh or such

00:52:57,520 --> 00:53:02,640
um in order to like get out like a dmg

00:53:00,880 --> 00:53:03,040
and then do the whole like notarizing

00:53:02,640 --> 00:53:06,000
bit

00:53:03,040 --> 00:53:06,000
um after that

00:53:07,119 --> 00:53:10,240
so uh once we have our vagrant file

00:53:09,599 --> 00:53:13,200
ready that

00:53:10,240 --> 00:53:14,319
will drive our process um we have our

00:53:13,200 --> 00:53:17,200
script

00:53:14,319 --> 00:53:18,000
that actually goes and creates uh our

00:53:17,200 --> 00:53:20,800
installers

00:53:18,000 --> 00:53:22,800
and broken up into those steps um then

00:53:20,800 --> 00:53:25,680
all we need to do is be able to

00:53:22,800 --> 00:53:26,400
run uh the script using vagrant uh so we

00:53:25,680 --> 00:53:30,240
do this

00:53:26,400 --> 00:53:30,240
using a provision

00:53:30,480 --> 00:53:38,000
so if we have a matrix of

00:53:34,079 --> 00:53:40,000
boxes which represents the targets of

00:53:38,000 --> 00:53:41,040
installers that we want to build against

00:53:40,000 --> 00:53:44,079
plus we have

00:53:41,040 --> 00:53:46,559
some place to run this in ci plus a

00:53:44,079 --> 00:53:49,040
little bit of magic

00:53:46,559 --> 00:53:51,119
uh then we end up with uh all of the

00:53:49,040 --> 00:53:54,000
installers we need for all of the

00:53:51,119 --> 00:53:56,720
uh applications or all of the uh the

00:53:54,000 --> 00:53:59,520
targets we run on

00:53:56,720 --> 00:54:00,559
and then if we peek inside this package

00:53:59,520 --> 00:54:04,000
a little bit

00:54:00,559 --> 00:54:07,359
um we can see we have like the binary uh

00:54:04,000 --> 00:54:08,880
vagrant so that's where the user uses or

00:54:07,359 --> 00:54:10,480
sees

00:54:08,880 --> 00:54:11,920
and then we have this embedded directory

00:54:10,480 --> 00:54:14,160
that has all of the

00:54:11,920 --> 00:54:16,079
uh required like dependencies so that

00:54:14,160 --> 00:54:18,720
has like ruby and curl

00:54:16,079 --> 00:54:20,400
uh and then we also have this gems uh

00:54:18,720 --> 00:54:21,599
directory and that's where like the

00:54:20,400 --> 00:54:25,359
vagrant gem lives and

00:54:21,599 --> 00:54:27,200
all of its dependencies

00:54:25,359 --> 00:54:28,400
so i have a little bit of a demo where

00:54:27,200 --> 00:54:32,960
we can go

00:54:28,400 --> 00:54:39,839
and build a vagrant package

00:54:32,960 --> 00:54:39,839
if i can share my screen

00:54:49,200 --> 00:54:53,839
cool so

00:54:54,079 --> 00:55:00,880
here we have uh our matrix of boxes

00:54:58,559 --> 00:55:02,240
um if they're all commented out because

00:55:00,880 --> 00:55:04,319
we don't want to sit here all day

00:55:02,240 --> 00:55:05,520
um building a bunch of installers

00:55:04,319 --> 00:55:08,640
instead we're just going to build this

00:55:05,520 --> 00:55:08,640
one up onto installer

00:55:09,119 --> 00:55:11,280
so

00:55:12,799 --> 00:55:16,480
my vagrant machine is already up

00:55:18,160 --> 00:55:21,520
and i actually already have the

00:55:19,599 --> 00:55:22,880
substrate built um

00:55:21,520 --> 00:55:25,280
and i did that just because it takes a

00:55:22,880 --> 00:55:28,559
long time to do that uh so

00:55:25,280 --> 00:55:32,799
all we need to do then uh is go ahead

00:55:28,559 --> 00:55:36,000
and provision this vagrant machine um

00:55:32,799 --> 00:55:39,839
to do the the packaging step

00:55:36,000 --> 00:55:43,760
um so

00:55:39,839 --> 00:55:46,880
here it goes off um

00:55:43,760 --> 00:55:49,359
it's just updating and if we give it a

00:55:46,880 --> 00:55:52,240
little bit of a second

00:55:49,359 --> 00:55:53,200
it's going to find the substrate that

00:55:52,240 --> 00:55:56,319
exists

00:55:53,200 --> 00:55:58,640
locally that i already built before this

00:55:56,319 --> 00:55:59,839
and then it's going to go ahead and

00:55:58,640 --> 00:56:02,880
build that ruby gem

00:55:59,839 --> 00:56:05,599
and install it and then build a

00:56:02,880 --> 00:56:05,599
dab package

00:56:10,880 --> 00:56:15,359
so if we look up here we see that this

00:56:13,760 --> 00:56:18,480
vagrant gem

00:56:15,359 --> 00:56:20,720
has been created we see

00:56:18,480 --> 00:56:23,040
that it's getting installed into the

00:56:20,720 --> 00:56:26,799
substrate

00:56:23,040 --> 00:56:30,640
and then we see

00:56:26,799 --> 00:56:34,240
that it's actually created this dev

00:56:30,640 --> 00:56:37,760
so we can go into

00:56:34,240 --> 00:56:37,760
this vm

00:56:38,160 --> 00:56:45,839
and we see that the dev exists right

00:56:39,839 --> 00:56:45,839
here and we can install it

00:56:50,799 --> 00:56:59,599
and there we have it cool

00:56:54,079 --> 00:57:12,720
that was uh was it

00:56:59,599 --> 00:57:16,000
and share my screen back again

00:57:12,720 --> 00:57:19,200
cool so uh that was it

00:57:16,000 --> 00:57:20,799
um if you are interested in figuring

00:57:19,200 --> 00:57:22,160
you can check us out at hashicorps

00:57:20,799 --> 00:57:23,760
vagrant and if you're interested to

00:57:22,160 --> 00:57:25,520
learn more about the installers

00:57:23,760 --> 00:57:28,480
um we're also on github there at

00:57:25,520 --> 00:57:31,680
hashicorp slash vagrant installers

00:57:28,480 --> 00:57:31,920
um thanks for uh hanging out and i hope

00:57:31,680 --> 00:57:34,559
you

00:57:31,920 --> 00:57:34,559
enjoyed the talk

00:57:39,119 --> 00:57:44,720
hello thank you for the talk

00:57:45,359 --> 00:57:49,680
awesome um so we have uh a couple of

00:57:48,799 --> 00:57:53,280
questions

00:57:49,680 --> 00:57:55,359
uh for you um we just start would you

00:57:53,280 --> 00:57:57,760
like to start with the first one tom

00:57:55,359 --> 00:57:58,799
yes just so that i understand correctly

00:57:57,760 --> 00:58:01,040
you're using

00:57:58,799 --> 00:58:02,240
vagrant to build a lot of to set up a

00:58:01,040 --> 00:58:03,280
lot of different virtual machines

00:58:02,240 --> 00:58:04,720
different addresses

00:58:03,280 --> 00:58:07,760
and then creating gems for every

00:58:04,720 --> 00:58:10,559
different os available

00:58:07,760 --> 00:58:12,240
yeah so we're building uh like whole

00:58:10,559 --> 00:58:16,240
installers so

00:58:12,240 --> 00:58:16,240
for each different os we have to like

00:58:18,240 --> 00:58:21,520
you drop those for a second all right no

00:58:21,040 --> 00:58:25,119
but that's

00:58:21,520 --> 00:58:26,799
that's cool i uh um we do a similar

00:58:25,119 --> 00:58:28,400
thing at where i work and that works

00:58:26,799 --> 00:58:30,799
very well we're also using vegan for

00:58:28,400 --> 00:58:30,799
that so

00:58:33,040 --> 00:58:38,559
um so we have another question uh we

00:58:36,559 --> 00:58:39,520
package almost everything for debian

00:58:38,559 --> 00:58:42,480
because it gives

00:58:39,520 --> 00:58:44,720
us unattended upgrades and that solves

00:58:42,480 --> 00:58:47,280
the majorities of cvs

00:58:44,720 --> 00:58:48,079
so does vagrant allow for unattended

00:58:47,280 --> 00:58:50,480
upgrades

00:58:48,079 --> 00:58:52,240
or which steps needs to be taken with

00:58:50,480 --> 00:58:54,240
our vulnerabilities reported to any of

00:58:52,240 --> 00:58:57,440
the dependencies

00:58:54,240 --> 00:58:58,960
uh so when we go ahead and build like

00:58:57,440 --> 00:59:02,400
out vagrant installers

00:58:58,960 --> 00:59:04,640
um we go in and like manually like uh

00:59:02,400 --> 00:59:06,319
update the cvs so that's like whenever

00:59:04,640 --> 00:59:06,880
we have a release which is like every

00:59:06,319 --> 00:59:08,319
like

00:59:06,880 --> 00:59:10,000
couple months maybe we just make sure

00:59:08,319 --> 00:59:11,839
everything is up to date there are no

00:59:10,000 --> 00:59:15,040
cbus logged against anything

00:59:11,839 --> 00:59:15,040
like in that subsequent layer

00:59:16,480 --> 00:59:22,960
thank you um

00:59:20,400 --> 00:59:24,319
so i don't see any other questions in

00:59:22,960 --> 00:59:25,359
it's like do you have any other

00:59:24,319 --> 00:59:29,520
questions uh

00:59:25,359 --> 00:59:32,559
tom maybe some i missed yeah no i i

00:59:29,520 --> 00:59:34,400
i wonder like what do you have any other

00:59:32,559 --> 00:59:36,000
tools similar to vagrant or tools you

00:59:34,400 --> 00:59:36,640
work on that you're like these are cool

00:59:36,000 --> 00:59:39,599
tools

00:59:36,640 --> 00:59:40,480
i want other people to know about them

00:59:39,599 --> 00:59:44,319
uh

00:59:40,480 --> 00:59:46,160
at the moment no but

00:59:44,319 --> 00:59:47,520
i saw i saw visual studio code are you

00:59:46,160 --> 00:59:49,920
happy with that

00:59:47,520 --> 00:59:51,440
yeah i mean it does the things that i

00:59:49,920 --> 00:59:53,200
like i like that it has the terminal

00:59:51,440 --> 00:59:53,920
integrated honestly that's the only

00:59:53,200 --> 00:59:56,240
thing

00:59:53,920 --> 01:00:00,319
that i really like it's amazing yeah

00:59:56,240 --> 01:00:03,599
it's cool

01:00:00,319 --> 01:00:04,160
cool well uh thank you thank you very

01:00:03,599 --> 01:00:07,920
much

01:00:04,160 --> 01:00:10,400
for your talk uh sophia uh well actually

01:00:07,920 --> 01:00:12,400
i have a lot of generic questions but

01:00:10,400 --> 01:00:13,359
just just like uh questions i'm very

01:00:12,400 --> 01:00:16,079
curious

01:00:13,359 --> 01:00:16,799
about and i'd like to know so for in the

01:00:16,079 --> 01:00:20,000
the ruby

01:00:16,799 --> 01:00:22,160
community um is there uh

01:00:20,000 --> 01:00:23,359
anyone in the ruby community that

01:00:22,160 --> 01:00:27,119
inspires you like

01:00:23,359 --> 01:00:30,240
who is your role model oh

01:00:27,119 --> 01:00:34,079
i don't know this is a hard one

01:00:30,240 --> 01:00:35,200
um all of them yeah all of them like

01:00:34,079 --> 01:00:37,599
everyone who's ever

01:00:35,200 --> 01:00:38,400
answered any of my questions on github

01:00:37,599 --> 01:00:42,079
how

01:00:38,400 --> 01:00:44,319
i love them

01:00:42,079 --> 01:00:45,200
thank you very much for your time uh

01:00:44,319 --> 01:00:48,160
sophia

01:00:45,200 --> 01:00:49,920
and uh and your talk yeah thanks for

01:00:48,160 --> 01:00:53,440
having me

01:00:49,920 --> 01:00:57,280
i think uh we are the end of our uh uh

01:00:53,440 --> 01:01:00,240
amsterdam ruby meetup yes

01:00:57,280 --> 01:01:01,040
yeah so our next meetup will be on the

01:01:00,240 --> 01:01:04,640
15th

01:01:01,040 --> 01:01:07,839
of june and we hope to see you there

01:01:04,640 --> 01:01:10,480
so there's a big question mark there so

01:01:07,839 --> 01:01:12,079
because we're still also looking for for

01:01:10,480 --> 01:01:14,480
speakers

01:01:12,079 --> 01:01:16,240
and i want to give a really big shout

01:01:14,480 --> 01:01:20,480
out to our tech person

01:01:16,240 --> 01:01:24,000
and dj arno and our moderators slash

01:01:20,480 --> 01:01:28,079
social media expert slash mom of

01:01:24,000 --> 01:01:28,079
chickens and fin floor

01:01:28,880 --> 01:01:33,200
yes uh and i guess we've reached the end

01:01:32,160 --> 01:01:36,799
of the meet up then

01:01:33,200 --> 01:01:38,000
um from the entire mcmrb uh team we hope

01:01:36,799 --> 01:01:40,720
you enjoyed it

01:01:38,000 --> 01:01:41,520
um if you have any other questions for

01:01:40,720 --> 01:01:44,720
our speakers

01:01:41,520 --> 01:01:46,000
uh they are still on slack uh please

01:01:44,720 --> 01:01:47,920
answer questions there and then we'll

01:01:46,000 --> 01:01:52,799
answer them

01:01:47,920 --> 01:01:55,280
we hope to see you next time

01:01:52,799 --> 01:01:56,400
you we have to wait for awkwardly until

01:01:55,280 --> 01:02:01,039
i know

01:01:56,400 --> 01:02:01,039
till he decides to switch us off or no

01:02:01,119 --> 01:02:06,079

YouTube URL: https://www.youtube.com/watch?v=F2mp3DOHwq8


