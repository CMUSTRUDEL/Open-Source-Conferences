Title: Keynote: Simple goal. Hard to accomplish - RedDotRubyConf 2017
Publication date: 2020-01-22
Playlist: RedDotRuby 2017
Description: 
	Speaker: Yukihiro (Matz) Matsumoto

Event Page: http://www.reddotrubyconf.com/

Produced by Engineers.SG

Help us caption & translate this video!

http://amara.org/v/8HYW/
Captions: 
	00:00:04,890 --> 00:00:16,180
good morning morning yeah welcome to

00:00:10,540 --> 00:00:20,289
Singapore and and welcome to the res our

00:00:16,180 --> 00:00:21,010
will become 2017 and then this is my I

00:00:20,289 --> 00:00:24,340
don't know

00:00:21,010 --> 00:00:26,310
both conference here I don't know both

00:00:24,340 --> 00:00:28,390
of it

00:00:26,310 --> 00:00:33,640
may I ask you a question

00:00:28,390 --> 00:00:38,460
few questions ah how many of you are

00:00:33,640 --> 00:00:42,899
capable ah almost open thank you

00:00:38,460 --> 00:00:45,550
how many programmers a little bit less

00:00:42,899 --> 00:00:49,320
thank you

00:00:45,550 --> 00:00:52,930
how many of you perceive yourself as

00:00:49,320 --> 00:00:56,590
creators okay fine

00:00:52,930 --> 00:01:00,160
okay we fellow creators I'm going to

00:00:56,590 --> 00:01:03,430
talk about our creating software under

00:01:00,160 --> 00:01:07,720
setting goals and the result of which

00:01:03,430 --> 00:01:10,860
will accomplish those goals okay we

00:01:07,720 --> 00:01:14,250
create software in creating software

00:01:10,860 --> 00:01:14,250
while the goal

00:01:14,979 --> 00:01:19,890
my personal goal is now related to

00:01:17,409 --> 00:01:25,180
software be a good father

00:01:19,890 --> 00:01:30,070
as a father for children so being a good

00:01:25,180 --> 00:01:33,189
father is quite simple goal right

00:01:30,070 --> 00:01:35,170
quite simple goal but as how that is how

00:01:33,189 --> 00:01:39,159
to accomplish the simple goal I guess

00:01:35,170 --> 00:01:45,070
being a good father but there are so

00:01:39,159 --> 00:01:50,500
many reasons to fail like a wrong

00:01:45,070 --> 00:01:52,750
priority or maybe you know so temper or

00:01:50,500 --> 00:01:56,860
something like that so there are a me no

00:01:52,750 --> 00:02:01,990
reason to fail and our software goal is

00:01:56,860 --> 00:02:05,950
to create great software and that simple

00:02:01,990 --> 00:02:09,250
but it's kind of hard to create great

00:02:05,950 --> 00:02:13,989
software we have to define great we have

00:02:09,250 --> 00:02:17,200
to try very hard to create a great

00:02:13,989 --> 00:02:20,560
software especially when

00:02:17,200 --> 00:02:23,580
we have become popular so we have so

00:02:20,560 --> 00:02:26,470
many burden in the history of the

00:02:23,580 --> 00:02:29,890
development of software for example we

00:02:26,470 --> 00:02:31,660
would be our simple goal is make the

00:02:29,890 --> 00:02:35,290
language better right

00:02:31,660 --> 00:02:39,640
so our week working there will be core

00:02:35,290 --> 00:02:43,660
team working very very very very hard to

00:02:39,640 --> 00:02:46,180
make Ruby language better but sometimes

00:02:43,660 --> 00:02:51,610
that kind of simple goal is pretty

00:02:46,180 --> 00:02:54,819
pretty difficult to accomplish because

00:02:51,610 --> 00:02:57,579
Ruby so cutter so that that's the reason

00:02:54,819 --> 00:03:02,769
we have so many people here in in the

00:02:57,579 --> 00:03:04,630
audience and it has Ruby has helped so

00:03:02,769 --> 00:03:06,849
many developers all over the world in

00:03:04,630 --> 00:03:11,260
Singapore in United States in Japan of

00:03:06,849 --> 00:03:15,630
course India or Malaysia or Europe or so

00:03:11,260 --> 00:03:18,970
many countries so it has has many

00:03:15,630 --> 00:03:23,400
compatibles probably more than million

00:03:18,970 --> 00:03:28,750
developers all over the world and in it

00:03:23,400 --> 00:03:33,970
besides that Ruby had survived for 25

00:03:28,750 --> 00:03:36,819
years like you know it's quite rare for

00:03:33,970 --> 00:03:41,139
software project to survive more than 20

00:03:36,819 --> 00:03:44,650
years but the internal Ruby is about 25

00:03:41,139 --> 00:03:47,560
years so there's so many software were

00:03:44,650 --> 00:03:50,470
written in Ruby so you write something

00:03:47,560 --> 00:03:54,519
really you rise of many there are tons

00:03:50,470 --> 00:03:57,220
of software within really so in that

00:03:54,519 --> 00:04:00,519
sense so compatibility models were

00:03:57,220 --> 00:04:03,310
worthy because even the slightest

00:04:00,519 --> 00:04:07,769
slightest change even the teeny bit of

00:04:03,310 --> 00:04:11,680
the compatibility breakage would break

00:04:07,769 --> 00:04:15,340
thousands of software so we need

00:04:11,680 --> 00:04:19,030
compatibility in fact really has a lot

00:04:15,340 --> 00:04:23,080
of technical gaps example so I am a mere

00:04:19,030 --> 00:04:28,810
human so in design Ruby I made some

00:04:23,080 --> 00:04:35,900
mistakes or got a source of them so I

00:04:28,810 --> 00:04:39,310
sometimes I regret them so that I feel

00:04:35,900 --> 00:04:42,910
some kind of trouble so that I want to

00:04:39,310 --> 00:04:48,169
resolve those kind of troubles by

00:04:42,910 --> 00:04:50,720
breaking compatibility so the you know

00:04:48,169 --> 00:04:53,800
in a sauce design of software or it

00:04:50,720 --> 00:04:59,510
designed the languages so the designers

00:04:53,800 --> 00:05:03,140
sometimes want to change the language or

00:04:59,510 --> 00:05:06,260
software in better way by breaking a

00:05:03,140 --> 00:05:09,230
compatibility for example we had some

00:05:06,260 --> 00:05:14,030
kind of huge breakage in between the

00:05:09,230 --> 00:05:19,340
will be 1/8 and will be 1/9 it was more

00:05:14,030 --> 00:05:22,850
than 10 years ago but it is a good thing

00:05:19,340 --> 00:05:25,790
so we replaced up we replaced a virtual

00:05:22,850 --> 00:05:30,260
machine that makes really a few times

00:05:25,790 --> 00:05:33,800
faster and then we introduced some kinda

00:05:30,260 --> 00:05:38,600
are the multi language things so that we

00:05:33,800 --> 00:05:40,820
can safely use the so many encoding

00:05:38,600 --> 00:05:44,360
without strings encodings like a unique

00:05:40,820 --> 00:05:46,340
code 50s in Japan or maybe and a big

00:05:44,360 --> 00:05:49,039
five in Taiwan or some some other

00:05:46,340 --> 00:05:52,280
encodings so that current

00:05:49,039 --> 00:05:55,039
Ruby 1:9 and Ruby 2 supposed to more

00:05:52,280 --> 00:05:59,060
than 80 encodings all over the world so

00:05:55,039 --> 00:06:04,210
that kind of change was needed but at

00:05:59,060 --> 00:06:04,210
the same time the breakage we brought

00:06:04,450 --> 00:06:12,140
stopped evolution got so many people

00:06:07,850 --> 00:06:18,860
stay using the old one eight for a long

00:06:12,140 --> 00:06:23,240
long time so we need we needed more than

00:06:18,860 --> 00:06:26,090
five years to as a community to migrate

00:06:23,240 --> 00:06:30,890
what one nine after we release the one

00:06:26,090 --> 00:06:34,840
nine so the goals five years the commute

00:06:30,890 --> 00:06:39,590
done at least half of the community was

00:06:34,840 --> 00:06:41,360
slows down in the improvement from the

00:06:39,590 --> 00:06:44,240
improvement of the language

00:06:41,360 --> 00:06:47,930
and the implementation implementation of

00:06:44,240 --> 00:06:52,250
the runtime so that God five-year is

00:06:47,930 --> 00:06:57,620
kind of waste of time for us the Python

00:06:52,250 --> 00:07:05,210
was even worse they took more than ten

00:06:57,620 --> 00:07:08,960
years or PHP they even canceled piece

00:07:05,210 --> 00:07:13,189
pieces so the people who is working on

00:07:08,960 --> 00:07:16,370
the PHP so created the new whole new

00:07:13,189 --> 00:07:21,349
language without compatibility name the

00:07:16,370 --> 00:07:24,229
piece b6 but it was the gap was so huge

00:07:21,349 --> 00:07:26,810
and then knowing the community virtually

00:07:24,229 --> 00:07:31,099
nowhere in the community shows the piece

00:07:26,810 --> 00:07:34,430
b6 so they just gave up the similar

00:07:31,099 --> 00:07:37,969
things happened in atmospheric fall so

00:07:34,430 --> 00:07:41,319
they gave up atmospheric fall so it's

00:07:37,969 --> 00:07:44,689
it's called second system syndrome so

00:07:41,319 --> 00:07:49,370
when we have trouble with the current

00:07:44,689 --> 00:07:52,159
system we just get mad and yet throw

00:07:49,370 --> 00:07:53,960
away the first version then we recreate

00:07:52,159 --> 00:08:00,770
the second version which is whole new

00:07:53,960 --> 00:08:04,789
and far better and no one use them so

00:08:00,770 --> 00:08:09,919
that we have learned we have to move on

00:08:04,789 --> 00:08:16,129
step by step gradual change is the way

00:08:09,919 --> 00:08:22,430
to go so that we have to buy a compass

00:08:16,129 --> 00:08:25,180
to accomplish the goals we student threw

00:08:22,430 --> 00:08:30,289
away our current system current software

00:08:25,180 --> 00:08:34,130
then we have to gradually improve our

00:08:30,289 --> 00:08:37,370
systems and then we have to set up the

00:08:34,130 --> 00:08:38,560
simple goals and then we accomplish them

00:08:37,370 --> 00:08:42,260
one by one

00:08:38,560 --> 00:08:47,019
okay let me show you a case study of

00:08:42,260 --> 00:08:47,019
accomplishing a simple goal for Ruby

00:08:47,740 --> 00:08:54,310
lastly two years ago actually two almost

00:08:50,839 --> 00:08:58,509
three years ago so I

00:08:54,310 --> 00:09:03,100
give give up this kind of slogan model

00:08:58,509 --> 00:09:06,519
or keyphrase to name the ruby 3x3 that

00:09:03,100 --> 00:09:11,680
means that how we want to make Ruby

00:09:06,519 --> 00:09:14,860
three three times faster no you know

00:09:11,680 --> 00:09:18,550
that made so many people inside of

00:09:14,860 --> 00:09:23,559
outside of the Kaduri community complain

00:09:18,550 --> 00:09:28,509
about the slow slowness of the Ruby

00:09:23,559 --> 00:09:31,569
language look in most of the case so

00:09:28,509 --> 00:09:35,499
ruby is fast enough the reason you use

00:09:31,569 --> 00:09:41,050
Ruby right but you know the comparing

00:09:35,499 --> 00:09:46,839
Ruby to say C++ or maybe Java or I don't

00:09:41,050 --> 00:09:51,279
knows so and under the very simple micro

00:09:46,839 --> 00:09:56,410
benchmarks Ruby slow yeah the grouping

00:09:51,279 --> 00:09:59,980
million times the empty will million

00:09:56,410 --> 00:10:04,600
times in P loops you know few hundred

00:09:59,980 --> 00:10:07,629
times lower than C++ of course but in

00:10:04,600 --> 00:10:12,910
real world application which is not that

00:10:07,629 --> 00:10:18,100
slow but you know at the same time no

00:10:12,910 --> 00:10:21,730
one complains about the faster Ruby you

00:10:18,100 --> 00:10:27,240
know if you we got past so everyone's

00:10:21,730 --> 00:10:27,240
going to be happy except for exit path

00:10:27,270 --> 00:10:34,350
so the faster will be the make will be

00:10:31,290 --> 00:10:36,870
passive that is the simple goal

00:10:34,350 --> 00:10:43,350
it seems straight forth and pretty

00:10:36,870 --> 00:10:47,339
simple okay making movie fast but

00:10:43,350 --> 00:10:50,100
technically it is difficult and all the

00:10:47,339 --> 00:10:50,760
we have been we have been working on

00:10:50,100 --> 00:10:53,550
Ruby

00:10:50,760 --> 00:10:56,220
virtual machine for us to more than

00:10:53,550 --> 00:10:59,550
twenty years so that we all will have

00:10:56,220 --> 00:11:03,720
already picked the low-hanging fruit so

00:10:59,550 --> 00:11:09,660
we have to do something very drastic to

00:11:03,720 --> 00:11:13,860
make it make really fast fast for three

00:11:09,660 --> 00:11:18,420
times so actually for more difficult and

00:11:13,860 --> 00:11:22,560
limiting because we have some kind of a

00:11:18,420 --> 00:11:26,550
human rules or maybe regulations the

00:11:22,560 --> 00:11:28,589
hard part is of course about the

00:11:26,550 --> 00:11:30,810
compatibility we have to keep

00:11:28,589 --> 00:11:35,510
compatibility even though the released

00:11:30,810 --> 00:11:38,910
after the second one is the memory usage

00:11:35,510 --> 00:11:41,610
in general the software performance is

00:11:38,910 --> 00:11:48,720
that it's kind of that time space

00:11:41,610 --> 00:11:51,990
trailer so you usually when you make

00:11:48,720 --> 00:11:56,660
your software faster your software will

00:11:51,990 --> 00:12:00,899
consume the more memory for example

00:11:56,660 --> 00:12:03,149
there would be sense to the JVM there

00:12:00,899 --> 00:12:06,149
will be is faster than purity in most of

00:12:03,149 --> 00:12:08,279
the cases acceptable startup times and

00:12:06,149 --> 00:12:14,399
that's just great great things vector

00:12:08,279 --> 00:12:20,329
JVM but at the same time JRuby concerns

00:12:14,399 --> 00:12:24,690
more memory in micro benchmarks it

00:12:20,329 --> 00:12:26,320
consumes a hundred hundred times more

00:12:24,690 --> 00:12:30,830
memory

00:12:26,320 --> 00:12:33,170
or it it consumes the same thing more

00:12:30,830 --> 00:12:35,920
time more memory on the articles

00:12:33,170 --> 00:12:38,990
benchmark which is relatively big

00:12:35,920 --> 00:12:42,050
benchmark and somewhat realistic

00:12:38,990 --> 00:12:42,740
benchmark we will talk about obstacles

00:12:42,050 --> 00:12:46,790
later

00:12:42,740 --> 00:12:49,570
so the better the Ruby language may run

00:12:46,790 --> 00:12:53,780
on memory tight involvement like a

00:12:49,570 --> 00:12:58,100
karateka smallest Dino I happen to work

00:12:53,780 --> 00:13:02,150
for a broker so that the it is very

00:12:58,100 --> 00:13:07,580
important for me to ensure the Ruby

00:13:02,150 --> 00:13:11,990
would work work we will run safely on

00:13:07,580 --> 00:13:17,870
the smallest I know without 520 Meg or

00:13:11,990 --> 00:13:20,780
memory or a decent TC has only to have

00:13:17,870 --> 00:13:24,440
the two gigabyte memory ok your

00:13:20,780 --> 00:13:27,080
developers your kisi may have a 16 gig

00:13:24,440 --> 00:13:35,360
or maybe 20 24 gigs of memory

00:13:27,080 --> 00:13:38,320
oh but the for the more mere PC uses the

00:13:35,360 --> 00:13:43,010
decent TT only has a 2 gig gig of memory

00:13:38,320 --> 00:13:45,920
for a few years back the 2 gig is big

00:13:43,010 --> 00:13:50,210
memory or even on an embedded system

00:13:45,920 --> 00:13:52,610
some people try to run really software

00:13:50,210 --> 00:13:56,839
on top of the smaller computers like a

00:13:52,610 --> 00:13:57,890
Raspberry Pi or maybe does Lego

00:13:56,839 --> 00:14:01,040
Mindstorm

00:13:57,890 --> 00:14:04,160
or maybe the big teeny embedded a

00:14:01,040 --> 00:14:08,330
building bold like out with a warm egg

00:14:04,160 --> 00:14:10,760
or memory so at least it should be

00:14:08,330 --> 00:14:13,250
configurable to use less memory that's

00:14:10,760 --> 00:14:17,480
the first rule also I'm just I'm the

00:14:13,250 --> 00:14:21,800
second group memory uses so that we want

00:14:17,480 --> 00:14:26,769
to make we faster but at least the the

00:14:21,800 --> 00:14:30,699
faster Ruby can be configured the

00:14:26,769 --> 00:14:33,879
to use less memory like us the current

00:14:30,699 --> 00:14:37,540
will be implementation the third one

00:14:33,879 --> 00:14:41,110
third kidding rules is dependency so

00:14:37,540 --> 00:14:45,279
really is long live project it's it's 24

00:14:41,110 --> 00:14:53,290
years of old so I started the the

00:14:45,279 --> 00:14:57,249
proofing Rudy on February 24 1993 so

00:14:53,290 --> 00:15:00,029
that in on next February will be will

00:14:57,249 --> 00:15:05,139
turn to 25 whoa

00:15:00,029 --> 00:15:10,929
so that depends for Ruby depending on

00:15:05,139 --> 00:15:15,009
the outside project is dangerous the for

00:15:10,929 --> 00:15:18,329
example so to make really faster so we

00:15:15,009 --> 00:15:23,559
can't rely on the DS project like LLVM

00:15:18,329 --> 00:15:26,230
lifted new lightning better we don't

00:15:23,559 --> 00:15:29,439
have control over those software so that

00:15:26,230 --> 00:15:33,549
these are the third-party software and

00:15:29,439 --> 00:15:38,529
then it's you know we can we cannot

00:15:33,549 --> 00:15:42,899
control them unless you an apple if you

00:15:38,529 --> 00:15:46,689
are poor you can buy them the software

00:15:42,899 --> 00:15:48,970
so that those of you may have bugs so

00:15:46,689 --> 00:15:53,490
that they may not you know it's on

00:15:48,970 --> 00:16:00,160
priority the product may be abundant so

00:15:53,490 --> 00:16:02,679
so that we may need to focus or we have

00:16:00,160 --> 00:16:05,470
to maintain those kinds of huge turtle

00:16:02,679 --> 00:16:09,429
software by ourselves which is nearly

00:16:05,470 --> 00:16:12,669
impossible so that is kind of silly

00:16:09,429 --> 00:16:14,439
things but there's very few projects of

00:16:12,669 --> 00:16:20,079
web between more than twenty years ago

00:16:14,439 --> 00:16:24,429
so that if we want we rely on the third

00:16:20,079 --> 00:16:27,189
party a huge project we have to take

00:16:24,429 --> 00:16:30,279
care we might have to take care of them

00:16:27,189 --> 00:16:33,459
in the future so the programming

00:16:30,279 --> 00:16:37,929
language live far longer than other

00:16:33,459 --> 00:16:40,130
software like a you know the Fortran was

00:16:37,929 --> 00:16:46,920
born in 54

00:16:40,130 --> 00:16:50,490
1954 the the list was born in 58 so but

00:16:46,920 --> 00:16:55,620
those languages still survived the Ruby

00:16:50,490 --> 00:17:01,070
is 24 years old 24 year old and then but

00:16:55,620 --> 00:17:05,490
I assume Ruby we will survive for coming

00:17:01,070 --> 00:17:05,930
20 years next 20 years or maybe next 50

00:17:05,490 --> 00:17:12,000
years

00:17:05,930 --> 00:17:17,570
so so we just don't want to rely on the

00:17:12,000 --> 00:17:22,250
third party project which live you know

00:17:17,570 --> 00:17:26,070
along far shorter than the verb itself

00:17:22,250 --> 00:17:27,300
the also we need to have the

00:17:26,070 --> 00:17:30,180
maintainability

00:17:27,300 --> 00:17:35,760
so overall meant ability matters

00:17:30,180 --> 00:17:36,800
so because our main table code stops the

00:17:35,760 --> 00:17:41,610
pollution

00:17:36,800 --> 00:17:49,200
so the F we start liberal evolution so

00:17:41,610 --> 00:17:53,010
that we as a community the grocery type

00:17:49,200 --> 00:17:57,230
so we have to keep on moving so that the

00:17:53,010 --> 00:18:00,600
maintainability not us so these are our

00:17:57,230 --> 00:18:04,350
no restrictions regulations and hidden

00:18:00,600 --> 00:18:08,090
rules and we map I must add some kind of

00:18:04,350 --> 00:18:12,000
the easy part to make our goals easy

00:18:08,090 --> 00:18:15,720
which is one of them is a baseline so

00:18:12,000 --> 00:18:21,170
the our baseline of three times faster

00:18:15,720 --> 00:18:27,060
is compared to Rudy 2.0 which is AA

00:18:21,170 --> 00:18:30,840
which was reducing our 2013 which is

00:18:27,060 --> 00:18:34,350
four years ago not that 2/4 which really

00:18:30,840 --> 00:18:36,480
is in last year so we have done a lot of

00:18:34,350 --> 00:18:39,930
improvement during the are since the

00:18:36,480 --> 00:18:42,300
will be too old so we implemented the

00:18:39,930 --> 00:18:44,760
generational garbage collectors we added

00:18:42,300 --> 00:18:47,820
in we have added incremental garbage

00:18:44,760 --> 00:18:50,100
collectors and then last year we have

00:18:47,820 --> 00:18:53,490
added the open address hash table which

00:18:50,100 --> 00:18:55,770
is which runs faster for the hash table

00:18:53,490 --> 00:19:02,040
and the metal cup and a lot of other

00:18:55,770 --> 00:19:06,540
improvements and we have the last last

00:19:02,040 --> 00:19:08,550
four years we have five to ten percent

00:19:06,540 --> 00:19:11,700
improvement in performance and memory

00:19:08,550 --> 00:19:15,420
usage each year we have done a good job

00:19:11,700 --> 00:19:18,470
for us last few years so they're really

00:19:15,420 --> 00:19:23,210
two for is faster than really too old

00:19:18,470 --> 00:19:25,860
then good b-24 consumes less memory

00:19:23,210 --> 00:19:28,440
slightly less memory than would be too

00:19:25,860 --> 00:19:32,460
old so we want to include these

00:19:28,440 --> 00:19:36,540
improvements in the you know the three

00:19:32,460 --> 00:19:41,700
by three measurement so this is this is

00:19:36,540 --> 00:19:45,300
one hidden regulation which makes algal

00:19:41,700 --> 00:19:49,590
little bit easier okay second rule a

00:19:45,300 --> 00:19:52,050
second regulation is no micro benchmarks

00:19:49,590 --> 00:19:54,330
micro benchmarks is pretty interesting

00:19:52,050 --> 00:19:57,210
like we have the Sun going to shoot out

00:19:54,330 --> 00:20:01,860
games the comparing compare the the

00:19:57,210 --> 00:20:05,820
performance of the languages but the

00:20:01,860 --> 00:20:10,160
only games you know the measuring the

00:20:05,820 --> 00:20:12,750
teeny loops or you know the finding

00:20:10,160 --> 00:20:16,500
suppose the searching through the binary

00:20:12,750 --> 00:20:20,610
tree is quite interesting games but you

00:20:16,500 --> 00:20:23,520
know that not usually reflect the real

00:20:20,610 --> 00:20:26,840
world behavior so real world application

00:20:23,520 --> 00:20:32,880
behave differently from micro benchmarks

00:20:26,840 --> 00:20:34,980
so the in the measurement of Ruby 3x3 so

00:20:32,880 --> 00:20:39,110
we have to build some kind of standard

00:20:34,980 --> 00:20:44,730
benchmarks so the standard benchmark

00:20:39,110 --> 00:20:47,970
need to be very real wall with that we

00:20:44,730 --> 00:20:50,850
fetch real world it they are out show

00:20:47,970 --> 00:20:54,780
but they have to affect real world

00:20:50,850 --> 00:20:58,200
behavior so that we are introduced a to

00:20:54,780 --> 00:21:00,150
kind of new benchmarks one is the web

00:20:58,200 --> 00:21:03,210
application benchmark which on top of

00:21:00,150 --> 00:21:06,100
rails because most people use Ruby

00:21:03,210 --> 00:21:15,050
through on top of Rails

00:21:06,100 --> 00:21:18,500
unfortunately yeah rails programmers

00:21:15,050 --> 00:21:23,630
raise your hand okay

00:21:18,500 --> 00:21:25,430
that's the reason so that this kind of

00:21:23,630 --> 00:21:28,570
benchmark is based with this cause and

00:21:25,430 --> 00:21:33,020
then you can find your benchmark here

00:21:28,570 --> 00:21:37,820
github.com Noah gives whales with Ruby

00:21:33,020 --> 00:21:39,560
bends so we are having we had we under

00:21:37,820 --> 00:21:44,060
the process of improving this funding

00:21:39,560 --> 00:21:46,580
the benchmark that could be it that can

00:21:44,060 --> 00:21:49,460
be installed very easily and you can

00:21:46,580 --> 00:21:52,250
measure the performance very easily so

00:21:49,460 --> 00:21:55,580
this kind of benchmark is done by no

00:21:52,250 --> 00:22:01,790
gift which is hired by dog appFolio

00:21:55,580 --> 00:22:06,920
company which hires him as a working for

00:22:01,790 --> 00:22:10,280
the improving Ruby four times the

00:22:06,920 --> 00:22:13,430
another another benchmark is the optic

00:22:10,280 --> 00:22:18,760
care of our benchmark opt carrots stand

00:22:13,430 --> 00:22:18,760
stands for the carrot for optimization I

00:22:19,090 --> 00:22:25,000
don't know about the other culture but

00:22:21,320 --> 00:22:30,410
it's at least in Japan carrot stand for

00:22:25,000 --> 00:22:33,950
you know tempting bite for horses you

00:22:30,410 --> 00:22:37,640
know you put the carrot on on in front

00:22:33,950 --> 00:22:42,740
of the holes the hook like I like this

00:22:37,640 --> 00:22:44,870
that host runs the chasing carrot so

00:22:42,740 --> 00:22:50,090
that can the host can run their very

00:22:44,870 --> 00:22:57,550
past so that optic care of try to be a

00:22:50,090 --> 00:23:01,220
carrot for Ruby 3x3 so it's like we

00:22:57,550 --> 00:23:04,010
pursue to improve the performance of the

00:23:01,220 --> 00:23:06,890
optic care of benchmark so the Ruby we

00:23:04,010 --> 00:23:12,080
are going to be faster the other carrot

00:23:06,890 --> 00:23:14,960
is the nanometers Nintendo internet

00:23:12,080 --> 00:23:16,460
system emulator so you can play say

00:23:14,960 --> 00:23:20,440
Mario

00:23:16,460 --> 00:23:24,769
using the other carrot they try to

00:23:20,440 --> 00:23:28,269
implement a a compressor six frames per

00:23:24,769 --> 00:23:32,240
second by you know the dynamic

00:23:28,269 --> 00:23:35,289
interpreted conversion machine so you

00:23:32,240 --> 00:23:41,149
can find out the carrot here github.com

00:23:35,289 --> 00:23:44,029
mummy at the carrot the topic a lot is

00:23:41,149 --> 00:23:50,960
written by the this guy you scandal

00:23:44,029 --> 00:23:53,059
which is insanely genius guy so the we

00:23:50,960 --> 00:23:56,419
have the his immigration we have the

00:23:53,059 --> 00:23:59,240
baseline of the Ruby tool and we don't

00:23:56,419 --> 00:24:02,899
use the micro benchmarks to measure will

00:23:59,240 --> 00:24:05,230
be three by three okay that there are

00:24:02,899 --> 00:24:08,179
all the regressions memory usage

00:24:05,230 --> 00:24:12,850
dependency the maintainability the

00:24:08,179 --> 00:24:18,080
baseline the no micro benchmarks so the

00:24:12,850 --> 00:24:19,009
Ruby 3x3 under these regulations how

00:24:18,080 --> 00:24:29,590
hard they are

00:24:19,009 --> 00:24:29,590
I consider Ruby 3x3 is nearly impossible

00:24:31,629 --> 00:24:42,100
yeah we need some kinda fresh technology

00:24:37,059 --> 00:24:47,139
named it here we have the tons of other

00:24:42,100 --> 00:24:51,919
optimization to the virtual machine but

00:24:47,139 --> 00:24:58,210
the I'm expecting dead can be a very

00:24:51,919 --> 00:25:00,740
very useful in improving the performance

00:24:58,210 --> 00:25:04,039
the gist stands for the just-in-time

00:25:00,740 --> 00:25:07,460
compilation so the some language used

00:25:04,039 --> 00:25:12,860
LLVM to implement it like a ruby Gnaeus

00:25:07,460 --> 00:25:16,100
crystal julia these languages LLVM to to

00:25:12,860 --> 00:25:20,269
make this language faster so it is

00:25:16,100 --> 00:25:23,929
portable so it runs on any OS and see

00:25:20,269 --> 00:25:27,169
many ways and many CPUs and as the LLVM

00:25:23,929 --> 00:25:30,930
is highly optimized the code generated

00:25:27,169 --> 00:25:36,780
by LLVM is quite quality

00:25:30,930 --> 00:25:40,800
in a highly optimized and but uh the dip

00:25:36,780 --> 00:25:45,540
API sometimes changes so we have to

00:25:40,800 --> 00:25:49,020
follow these change and then the LLVM is

00:25:45,540 --> 00:25:54,540
a huge hate party software so we had a

00:25:49,020 --> 00:25:59,220
problem for anxiety of dependency we

00:25:54,540 --> 00:26:02,630
have other jet libraries like a Lib that

00:25:59,220 --> 00:26:07,290
lived it or the new lightning so that

00:26:02,630 --> 00:26:12,320
these libraries are less widely used and

00:26:07,290 --> 00:26:16,770
it comes with the lesser GPL which is

00:26:12,320 --> 00:26:21,990
now fully compatible with the owl our

00:26:16,770 --> 00:26:26,970
license which is BSD and we have we also

00:26:21,990 --> 00:26:31,320
have that anxiety of dependency so we

00:26:26,970 --> 00:26:33,450
have been are considering adding G to

00:26:31,320 --> 00:26:38,760
the language for a long long time and

00:26:33,450 --> 00:26:42,120
then the only option we could think of

00:26:38,760 --> 00:26:46,700
without these kind of our problems is

00:26:42,120 --> 00:26:53,550
the writing our own jet which is very

00:26:46,700 --> 00:26:57,500
very difficult so that we were having

00:26:53,550 --> 00:26:59,250
trouble for a long long time but uh

00:26:57,500 --> 00:27:04,530
early this year

00:26:59,250 --> 00:27:09,090
the other option came in and it emptied

00:27:04,530 --> 00:27:13,380
stands for emoji keyboard you can find

00:27:09,090 --> 00:27:17,910
the blonde with emptied here github VN

00:27:13,380 --> 00:27:22,110
mock love will be 3 LP LMZ branch it's

00:27:17,910 --> 00:27:25,710
done by dove vladimir and Makarov

00:27:22,110 --> 00:27:29,910
delight pronounced like who's working

00:27:25,710 --> 00:27:34,110
for Red Hat and then the rod email is

00:27:29,910 --> 00:27:38,700
also the opera just hash table we have

00:27:34,110 --> 00:27:44,610
introduced last year so the engine is a

00:27:38,700 --> 00:27:48,320
little bit different approach MJ is a

00:27:44,610 --> 00:27:52,080
LTL and just uses the does

00:27:48,320 --> 00:27:55,380
straightforward DCC fourth clan and then

00:27:52,080 --> 00:27:58,049
just our M line uses messages let me

00:27:55,380 --> 00:28:02,870
explain a little bit more about that so

00:27:58,049 --> 00:28:09,269
LTL stands for the register transfer

00:28:02,870 --> 00:28:12,840
language so that it is kind of the byte

00:28:09,269 --> 00:28:16,620
code or the abstract instructions for

00:28:12,840 --> 00:28:19,350
abstract machine and it's based on the

00:28:16,620 --> 00:28:23,429
registers in the in the world of the

00:28:19,350 --> 00:28:28,110
virtual machine in our implementation so

00:28:23,429 --> 00:28:32,419
there are long history of arguments

00:28:28,110 --> 00:28:35,100
between the stock-based internal

00:28:32,419 --> 00:28:38,130
representation and the register based

00:28:35,100 --> 00:28:42,630
internet position so the stock-based

00:28:38,130 --> 00:28:47,429
aisle means the distancing so that get

00:28:42,630 --> 00:28:50,639
local up the get local variable which is

00:28:47,429 --> 00:28:57,240
the part of the young instructions so

00:28:50,639 --> 00:29:01,380
that you can take the look value of the

00:28:57,240 --> 00:29:06,860
local valuable of be index into the

00:29:01,380 --> 00:29:11,269
stack then the another local variable

00:29:06,860 --> 00:29:15,200
into the stack then at the plus

00:29:11,269 --> 00:29:23,429
operation consuming to stock entries

00:29:15,200 --> 00:29:28,169
then push the result in the in on top of

00:29:23,429 --> 00:29:31,740
the stack then you put the value the

00:29:28,169 --> 00:29:35,130
stack top value to the local variable in

00:29:31,740 --> 00:29:36,210
a index that kind of thing like it's

00:29:35,130 --> 00:29:39,480
kind of like a fault

00:29:36,210 --> 00:29:43,019
you know stock based language in a

00:29:39,480 --> 00:29:46,769
register this IR which is the okay the

00:29:43,019 --> 00:29:50,730
value of a youth class volley way and

00:29:46,769 --> 00:29:54,149
valuable P into the value of C so much

00:29:50,730 --> 00:29:57,480
simpler but imprinted implementation

00:29:54,149 --> 00:29:57,750
wise so that the risk of SiO is much

00:29:57,480 --> 00:30:01,710
much

00:29:57,750 --> 00:30:04,650
more are complicated so that you know

00:30:01,710 --> 00:30:09,410
both sides of the pros and cons so

00:30:04,650 --> 00:30:14,400
there's no clear winner in this argument

00:30:09,410 --> 00:30:18,030
and y'all's the current VM years done

00:30:14,400 --> 00:30:22,190
folder yet another Ruby VM the real

00:30:18,030 --> 00:30:28,920
stands would love uses stack beta are

00:30:22,190 --> 00:30:30,540
like JDM you stack this i/o okay for

00:30:28,920 --> 00:30:33,000
your information the M Ruby the

00:30:30,540 --> 00:30:37,440
alternative implementation will be also

00:30:33,000 --> 00:30:40,740
use the register by all anyway the stack

00:30:37,440 --> 00:30:43,950
based AI R is simpler and stock based

00:30:40,740 --> 00:30:49,320
IRS shoulder-in in term of the the size

00:30:43,950 --> 00:30:51,570
of the the compiled by code the the

00:30:49,320 --> 00:30:53,310
register based il creates less

00:30:51,570 --> 00:30:57,540
instructions okay

00:30:53,310 --> 00:31:01,170
the size of the code is smaller in stock

00:30:57,540 --> 00:31:05,550
based the number of the instructions of

00:31:01,170 --> 00:31:09,330
the smaller in stock register based i/o

00:31:05,550 --> 00:31:11,850
and in addition the register based io

00:31:09,330 --> 00:31:15,750
creates less memory traffic so you can

00:31:11,850 --> 00:31:22,500
access less memory and register desire

00:31:15,750 --> 00:31:26,160
of claim to run faster so that enough

00:31:22,500 --> 00:31:29,640
this as I said before that there's no

00:31:26,160 --> 00:31:33,300
clear winner in the stock based il and

00:31:29,640 --> 00:31:36,360
the resistor base I all but at least for

00:31:33,300 --> 00:31:40,410
this purpose so that the register this

00:31:36,360 --> 00:31:43,710
il is easier to implement it on top it

00:31:40,410 --> 00:31:46,880
and that which is the best IO is less a

00:31:43,710 --> 00:31:52,740
little bit easier to implement the the

00:31:46,880 --> 00:31:56,100
optimization so he chose the new the

00:31:52,740 --> 00:32:00,890
virtual machine instructions on which is

00:31:56,100 --> 00:32:04,830
register based so the the vladimir

00:32:00,890 --> 00:32:08,850
replace the job by his LTL voter machine

00:32:04,830 --> 00:32:10,090
which is not perfect yet but it's

00:32:08,850 --> 00:32:14,960
working

00:32:10,090 --> 00:32:17,480
and it as fast under the current

00:32:14,960 --> 00:32:20,890
implementation so his LTL virtual

00:32:17,480 --> 00:32:27,050
machine is run as fast as two fold

00:32:20,890 --> 00:32:30,800
it's not slow and it consumes almost

00:32:27,050 --> 00:32:35,600
same memory amount as the recommended

00:32:30,800 --> 00:32:39,230
virtual machine so that you know the

00:32:35,600 --> 00:32:44,480
step of the Ruby makes three times

00:32:39,230 --> 00:32:49,100
faster so that you know the same

00:32:44,480 --> 00:32:52,460
performance is not satisfied so you

00:32:49,100 --> 00:32:55,700
might feel unsatisfied by the same

00:32:52,460 --> 00:32:58,880
performance same memo footprint but the

00:32:55,700 --> 00:33:01,670
important things is that you know you

00:32:58,880 --> 00:33:05,210
don't have the performance decoration

00:33:01,670 --> 00:33:09,530
and then you them come concerns the

00:33:05,210 --> 00:33:12,500
baseline of the memory footprint so the

00:33:09,530 --> 00:33:17,360
we have the new virtual machine with

00:33:12,500 --> 00:33:22,340
register based then he implemented

00:33:17,360 --> 00:33:28,300
on top of the RPL the the activities

00:33:22,340 --> 00:33:35,470
like this the figure is really small but

00:33:28,300 --> 00:33:41,440
fundamentally the empted images here

00:33:35,470 --> 00:33:47,860
generate cheat code into files then

00:33:41,440 --> 00:33:53,090
compile C code by GCC or climb as a

00:33:47,860 --> 00:33:55,760
normal a compilation step then generate

00:33:53,090 --> 00:34:00,080
the dot as the dot a so file shared

00:33:55,760 --> 00:34:05,230
object file then load dynamically those

00:34:00,080 --> 00:34:08,410
iso files into Ruby to implement this

00:34:05,230 --> 00:34:08,410
which is

00:34:08,920 --> 00:34:17,330
which is nice idea it is not

00:34:13,520 --> 00:34:20,930
straightforward you jury did creates the

00:34:17,330 --> 00:34:23,830
the interruption in memory then called

00:34:20,930 --> 00:34:26,330
the function we generate in the memory

00:34:23,830 --> 00:34:30,040
but a he cush

00:34:26,330 --> 00:34:35,990
he used the Biosystems and that the user

00:34:30,040 --> 00:34:38,570
compiles to compile jet files so that we

00:34:35,990 --> 00:34:41,900
in under the current implementation we

00:34:38,570 --> 00:34:46,040
generated the Java code which is in

00:34:41,900 --> 00:34:48,920
memory then we execute that those in

00:34:46,040 --> 00:34:50,420
memory your code write those we eat

00:34:48,920 --> 00:34:53,690
compiled will be cold

00:34:50,420 --> 00:34:55,820
into the yard cold gang excuse ah you

00:34:53,690 --> 00:35:05,030
are called by the virtual reality

00:34:55,820 --> 00:35:08,150
machine so by MGM jet the baseline is

00:35:05,030 --> 00:35:10,700
you can read the Ruby code then compile

00:35:08,150 --> 00:35:13,490
will be called into the LTL which is the

00:35:10,700 --> 00:35:17,600
register based virtual machine code then

00:35:13,490 --> 00:35:19,640
execute the the LTL by the Aldea virtual

00:35:17,600 --> 00:35:24,410
machine which is threefold

00:35:19,640 --> 00:35:30,490
and then quotes a similar to yours but

00:35:24,410 --> 00:35:36,650
once you turn off the jet option so MZ

00:35:30,490 --> 00:35:41,480
creates the LTL then general C code into

00:35:36,650 --> 00:35:47,690
file from LPL then compiled all seek

00:35:41,480 --> 00:35:52,220
ship code by GCC then load compile iso

00:35:47,690 --> 00:35:58,370
file then execute the function so

00:35:52,220 --> 00:36:02,150
benefit so we have no tricky

00:35:58,370 --> 00:36:05,030
dependencies so this ec is independent

00:36:02,150 --> 00:36:08,420
of course GCC is other third-party

00:36:05,030 --> 00:36:12,130
software but which is live far longer

00:36:08,420 --> 00:36:15,920
than Ruby the first version of Ruby in

00:36:12,130 --> 00:36:18,020
93 or compiled by this machine so DCC is

00:36:15,920 --> 00:36:21,020
all enough

00:36:18,020 --> 00:36:24,170
besides that so that you know the

00:36:21,020 --> 00:36:28,869
compilation step is well-defined so it

00:36:24,170 --> 00:36:33,200
is it's so stable so it hasn't changed

00:36:28,869 --> 00:36:36,619
for us I don't know 30 40 years so we

00:36:33,200 --> 00:36:39,530
can rely on them to the next 20 years

00:36:36,619 --> 00:36:42,859
and then those compiled is a very stable

00:36:39,530 --> 00:36:47,349
and a GCC's ubiquitous you can you can

00:36:42,859 --> 00:36:50,150
have the DCT on Linux Mac Windows or

00:36:47,349 --> 00:36:54,980
maybe in the owner and abetted devices

00:36:50,150 --> 00:37:01,520
so at least you can have a complete

00:36:54,980 --> 00:37:05,619
compiler on so many systems the by the

00:37:01,520 --> 00:37:10,849
reason so that ends it is pretty much

00:37:05,619 --> 00:37:23,839
portable and highly optimized but we

00:37:10,849 --> 00:37:27,680
also have tricks so the point is it is

00:37:23,839 --> 00:37:33,349
so many unnecessary steps compared to

00:37:27,680 --> 00:37:37,690
the attitude so that you have to

00:37:33,349 --> 00:37:41,170
minimize headers so in the build process

00:37:37,690 --> 00:37:45,440
we create the minimized header

00:37:41,170 --> 00:37:54,109
he claims that we can cut the 90% of the

00:37:45,440 --> 00:37:58,640
Ruby headers then Oh and that he used

00:37:54,109 --> 00:38:01,880
the worker threads to create the the jet

00:37:58,640 --> 00:38:05,300
code so the good compilation process is

00:38:01,880 --> 00:38:10,609
the is done by the separate thread from

00:38:05,300 --> 00:38:14,089
the P the main line friends so that you

00:38:10,609 --> 00:38:20,630
can use the the multi-core to to get

00:38:14,089 --> 00:38:23,300
compiled so as a result default l GL is

00:38:20,630 --> 00:38:26,060
of such as Ruby and a default of the L

00:38:23,300 --> 00:38:28,910
constant up less memory as we Alex the

00:38:26,060 --> 00:38:30,980
current implementation and and it runs

00:38:28,910 --> 00:38:33,410
far faster than yours

00:38:30,980 --> 00:38:38,089
and it concerns more memory than job of

00:38:33,410 --> 00:38:41,059
course and then you can do that ahead of

00:38:38,089 --> 00:38:44,299
time compile a hydrant on completion so

00:38:41,059 --> 00:38:47,780
you can compile all the review files

00:38:44,299 --> 00:38:51,260
into the machine code you can roll them

00:38:47,780 --> 00:38:52,160
into the virtual machine to run you will

00:38:51,260 --> 00:38:55,880
will be called

00:38:52,160 --> 00:39:01,400
in see it's not comparable to plan C

00:38:55,880 --> 00:39:05,240
code written by a human but it's faster

00:39:01,400 --> 00:39:07,970
than the group does the plain Ruby and

00:39:05,240 --> 00:39:11,420
then we can have the future of such

00:39:07,970 --> 00:39:15,530
drastic inlining which makes the

00:39:11,420 --> 00:39:16,569
compiled code even faster or maybe the

00:39:15,530 --> 00:39:20,119
weird

00:39:16,569 --> 00:39:24,140
planning about the speculative jet which

00:39:20,119 --> 00:39:26,900
in assuming the okay this argument must

00:39:24,140 --> 00:39:31,450
be integers so you can compile these

00:39:26,900 --> 00:39:33,740
numbers as integers without any the

00:39:31,450 --> 00:39:37,130
converting back and forth with the Ruby

00:39:33,740 --> 00:39:40,730
world and C world so by using these

00:39:37,130 --> 00:39:44,000
kinds that technique and ideas range it

00:39:40,730 --> 00:39:50,390
can be even faster of course and it has

00:39:44,000 --> 00:39:53,660
drawbacks which is the higher compiler

00:39:50,390 --> 00:39:55,640
cost you know the process is a

00:39:53,660 --> 00:39:57,559
generation she called excusing C

00:39:55,640 --> 00:40:00,680
compiler the passing C code the

00:39:57,559 --> 00:40:02,900
cogeneration code generate from generate

00:40:00,680 --> 00:40:06,049
code from C code than the dynamic

00:40:02,900 --> 00:40:10,760
loading dot ISO file which is all of

00:40:06,049 --> 00:40:13,460
them unnecessary for the usual tips like

00:40:10,760 --> 00:40:18,559
a live using lidget or other jet

00:40:13,460 --> 00:40:21,640
technologies so these kind of things the

00:40:18,559 --> 00:40:26,720
you know the burden to the performance

00:40:21,640 --> 00:40:29,210
but we they attract a he is trying to

00:40:26,720 --> 00:40:34,520
the minimal is kind of a burden

00:40:29,210 --> 00:40:36,650
so although result mgs1 far faster than

00:40:34,520 --> 00:40:41,150
y'alls and it consumed more memory than

00:40:36,650 --> 00:40:43,260
job as i told you okay and that runs

00:40:41,150 --> 00:40:45,720
faster than JRuby

00:40:43,260 --> 00:40:48,720
and indeed consume far less memory than

00:40:45,720 --> 00:40:52,260
geography okay under the micro

00:40:48,720 --> 00:40:55,800
benchmarks which are a lot of the words

00:40:52,260 --> 00:40:59,130
kmidgette runs six times faster than we

00:40:55,800 --> 00:41:02,280
do all in average then just consume four

00:40:59,130 --> 00:41:05,640
times more memory as a reference JRuby

00:41:02,280 --> 00:41:07,400
12.5 faster than will be too old and the

00:41:05,640 --> 00:41:12,570
dairy comes with 200 times more memory

00:41:07,400 --> 00:41:16,650
in micro benchmarks in optical out

00:41:12,570 --> 00:41:21,180
benchmark and it runs 2.8 times faster

00:41:16,650 --> 00:41:25,200
and then consumed 1.16 16 times more

00:41:21,180 --> 00:41:27,570
memory as a reference generally runs 2.4

00:41:25,200 --> 00:41:28,440
times faster than will be too old and

00:41:27,570 --> 00:41:32,099
there it comes

00:41:28,440 --> 00:41:35,820
18 times memory ok another the real

00:41:32,099 --> 00:41:38,670
world example the difference is not that

00:41:35,820 --> 00:41:44,670
big you know that's not sixth time not

00:41:38,670 --> 00:41:47,819
200 times so the evolution is an empty

00:41:44,670 --> 00:41:52,220
is very promising but as it still have

00:41:47,819 --> 00:41:57,300
some issues we cannot replace the M jet

00:41:52,220 --> 00:42:02,339
our virtual machine by NZ yet but it's

00:41:57,300 --> 00:42:05,310
promising we need more so we don't make

00:42:02,339 --> 00:42:10,130
any promise we don't make any promise

00:42:05,310 --> 00:42:13,859
that we might not have the Ruby MJ as a

00:42:10,130 --> 00:42:18,750
jet engine for will be three but at

00:42:13,859 --> 00:42:22,050
least we already have the implemented

00:42:18,750 --> 00:42:26,339
technology to make Ruby three times

00:42:22,050 --> 00:42:29,880
faster and then the engine achieves the

00:42:26,339 --> 00:42:31,890
highest in out criteria okay we are

00:42:29,880 --> 00:42:34,650
trying to make the other with rheumatics

00:42:31,890 --> 00:42:37,380
it's like a multi-core concurrency or

00:42:34,650 --> 00:42:41,760
type inferences okay I'm not going to

00:42:37,380 --> 00:42:45,290
talk about them today but as those

00:42:41,760 --> 00:42:49,470
simple goals have hidden rules and

00:42:45,290 --> 00:42:53,460
regulations and limitations and they are

00:42:49,470 --> 00:42:56,490
so difficult internet so I can now I

00:42:53,460 --> 00:42:59,070
only say that today but we

00:42:56,490 --> 00:43:03,570
have tons of work to do that to make

00:42:59,070 --> 00:43:06,560
Ruby better conclusion a completion

00:43:03,570 --> 00:43:09,950
simple goal can be extremely difficult a

00:43:06,560 --> 00:43:14,940
lot of hidden trade-offs and migrations

00:43:09,950 --> 00:43:18,840
but it's all a way of creation we are

00:43:14,940 --> 00:43:22,860
created right so we are trying to create

00:43:18,840 --> 00:43:26,280
something we haven't seen just so it's

00:43:22,860 --> 00:43:28,820
kind of magic - subdiver first source of

00:43:26,280 --> 00:43:33,619
development is the process of making

00:43:28,820 --> 00:43:38,670
impossible possible so at the first

00:43:33,619 --> 00:43:48,740
grant-making Ruby 310 past is impossible

00:43:38,670 --> 00:43:53,310
but somehow we can do not nasty things

00:43:48,740 --> 00:43:57,210
but you can technologies ideas with help

00:43:53,310 --> 00:43:59,690
form genius and community so that the

00:43:57,210 --> 00:44:03,770
difficulty and pain a cause of the

00:43:59,690 --> 00:44:08,790
creation we know is how every single

00:44:03,770 --> 00:44:11,760
simple goal is hard but we have to keep

00:44:08,790 --> 00:44:18,510
trying we have to keep moving forward

00:44:11,760 --> 00:44:23,570
and in do until we can accomplish we

00:44:18,510 --> 00:44:27,300
will help you the Ruby is the way that I

00:44:23,570 --> 00:44:31,290
try to help you guys to implement great

00:44:27,300 --> 00:44:33,090
software so we can help each other so I

00:44:31,290 --> 00:44:41,240
help you you help me

00:44:33,090 --> 00:44:44,670
we ask so together we can make it and in

00:44:41,240 --> 00:44:49,410
this talk is special appreciation to

00:44:44,670 --> 00:44:53,000
brother Mycroft happy hacking and make

00:44:49,410 --> 00:44:53,000
impossible possible thank you

00:44:59,120 --> 00:45:04,500
so you mentioned that mg might be slower

00:45:01,860 --> 00:45:07,350
in some cases I wondering if you're

00:45:04,500 --> 00:45:10,410
planning to give some API to disable it

00:45:07,350 --> 00:45:12,180
explicitly if I know that my program may

00:45:10,410 --> 00:45:14,700
not benefit from it that it might be

00:45:12,180 --> 00:45:17,760
slower with mg done than without it yeah

00:45:14,700 --> 00:45:21,960
you have to turn on ng by explicitly so

00:45:17,760 --> 00:45:23,850
by default ah da you can run Dirk by

00:45:21,960 --> 00:45:26,010
default it will be off and I need to

00:45:23,850 --> 00:45:29,040
turn it on explicitly or by D chosen to

00:45:26,010 --> 00:45:32,310
do an on explicitly okay okay for it

00:45:29,040 --> 00:45:38,250
it's the performance is to say the same

00:45:32,310 --> 00:45:42,000
okay Callie thank you hi

00:45:38,250 --> 00:45:45,450
so I'm pardon my ignorance but so the

00:45:42,000 --> 00:45:48,810
point of JIT is that you instead of

00:45:45,450 --> 00:45:52,230
interpreting the program when you run it

00:45:48,810 --> 00:45:54,990
you compile it into C into like a shared

00:45:52,230 --> 00:45:57,690
object and then you kind of execute that

00:45:54,990 --> 00:46:00,060
object on the target platform great okay

00:45:57,690 --> 00:46:03,930
and interpret so the way it is done now

00:46:00,060 --> 00:46:05,670
works how so how do you how do you

00:46:03,930 --> 00:46:07,440
interrupt how do you run them I mean I'm

00:46:05,670 --> 00:46:09,090
sorry to ask that but how do you

00:46:07,440 --> 00:46:11,820
actually run Ruby at the moment like how

00:46:09,090 --> 00:46:15,270
does the interpreted way work yeah yeah

00:46:11,820 --> 00:46:22,830
there you compile the you're really cold

00:46:15,270 --> 00:46:25,230
in in see if I are converting out LTL to

00:46:22,830 --> 00:46:29,180
the C code okay corresponding C code

00:46:25,230 --> 00:46:33,270
then compile them by the C compiler then

00:46:29,180 --> 00:46:36,530
called the load and dynamically then

00:46:33,270 --> 00:46:38,910
link into that you know it plays up the

00:46:36,530 --> 00:46:41,100
implementation with the Sheep ring ah

00:46:38,910 --> 00:46:44,000
that will be implemented the root method

00:46:41,100 --> 00:46:48,300
by the dog guides below that C function

00:46:44,000 --> 00:46:52,380
so that that must just run the method

00:46:48,300 --> 00:46:54,930
implemented in c so but that's the

00:46:52,380 --> 00:46:57,300
that's the JIT right data yet okay and

00:46:54,930 --> 00:46:58,770
how does it work like at the moment we

00:46:57,300 --> 00:47:01,560
don't have get right at the moment we

00:46:58,770 --> 00:47:04,700
have interpreted the interpret I never

00:47:01,560 --> 00:47:08,970
understood how the actual interpretation

00:47:04,700 --> 00:47:11,470
process works like so there's Ruby code

00:47:08,970 --> 00:47:14,859
and then we have the Ruby VM

00:47:11,470 --> 00:47:17,380
and you basically compiled the Ruby code

00:47:14,859 --> 00:47:21,160
into instructions for the Ruby VM yes

00:47:17,380 --> 00:47:23,230
and then the VM The Onion's doesn't fit

00:47:21,160 --> 00:47:25,270
the one instruction book okay okay okay

00:47:23,230 --> 00:47:27,339
and that's obviously slower because you

00:47:25,270 --> 00:47:29,079
have to interpret the move okay

00:47:27,339 --> 00:47:34,530
okay well no if I finally understand

00:47:29,079 --> 00:47:34,530
what JIT is thank you you're welcome

00:47:40,030 --> 00:48:02,180
in education okay it's fundamentally

00:47:58,940 --> 00:48:04,160
saying so that under the virtual machine

00:48:02,180 --> 00:48:07,760
you have to convert back and forth in

00:48:04,160 --> 00:48:11,120
the C structured and the Ruby data types

00:48:07,760 --> 00:48:14,060
and in the converted C code you have to

00:48:11,120 --> 00:48:17,170
do the same so that the cost you can

00:48:14,060 --> 00:48:20,690
remove from the virtual machine is the

00:48:17,170 --> 00:48:22,820
doctoring the cold and the the

00:48:20,690 --> 00:48:27,260
conditioning or something like that so

00:48:22,820 --> 00:48:29,780
that make the control faster not the top

00:48:27,260 --> 00:48:32,600
the data process itself so you have to

00:48:29,780 --> 00:48:35,690
send a method in in a dynamic way so you

00:48:32,600 --> 00:48:37,070
have to teach them the value in dynamic

00:48:35,690 --> 00:48:42,710
way or something like that that won't

00:48:37,070 --> 00:48:45,590
change so that that is the reason so the

00:48:42,710 --> 00:48:48,520
engine runs three times faster not a

00:48:45,590 --> 00:48:48,520
hundred times faster

00:49:03,530 --> 00:49:08,770
what time okay thank you

00:49:08,850 --> 00:49:13,190

YouTube URL: https://www.youtube.com/watch?v=3NRTzTccoI0


