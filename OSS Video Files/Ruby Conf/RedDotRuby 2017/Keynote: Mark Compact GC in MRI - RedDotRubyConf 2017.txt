Title: Keynote: Mark Compact GC in MRI - RedDotRubyConf 2017
Publication date: 2020-01-22
Playlist: RedDotRuby 2017
Description: 
	Speaker: Aaron Patterson, GitHub

Event Page: http://www.reddotrubyconf.com/

Produced by Engineers.SG

Help us caption & translate this video!

http://amara.org/v/8HYE/
Captions: 
	00:00:04,800 --> 00:00:08,939
hold on I got to get a couple photos

00:00:10,469 --> 00:00:14,170
this isn't part of my this isn't part of

00:00:12,760 --> 00:00:15,780
my presentation time I just need some

00:00:14,170 --> 00:00:18,879
photos everybody

00:00:15,780 --> 00:00:18,879
[Music]

00:00:23,160 --> 00:00:29,200
not yet no Friday home right now this is

00:00:26,050 --> 00:00:31,450
just this is Aaron time right now this

00:00:29,200 --> 00:00:35,949
is Aaron time you're gonna have to wait

00:00:31,450 --> 00:00:37,690
for Friday hug though there's a special

00:00:35,949 --> 00:00:41,410
portion in my presentation for Friday

00:00:37,690 --> 00:00:43,839
hug so let's wait a second

00:00:41,410 --> 00:00:47,519
I mean I'm choosing to stay behind the

00:00:43,839 --> 00:00:51,430
podium because I'm not wearing any pants

00:00:47,519 --> 00:00:53,980
just I am wearing pants and sturdy you

00:00:51,430 --> 00:00:55,780
can see okay so the title of my talk

00:00:53,980 --> 00:01:00,420
more compact to you CNM all right

00:00:55,780 --> 00:01:05,229
my name is Aaron hello um I am a

00:01:00,420 --> 00:01:08,789
twenty-something hipster nerd now a

00:01:05,229 --> 00:01:08,789
30-something hits you nervous

00:01:08,830 --> 00:01:12,280
my name is tender love if you don't

00:01:10,810 --> 00:01:14,220
recognize me in person this is what I

00:01:12,280 --> 00:01:16,869
look like on the Internet

00:01:14,220 --> 00:01:18,399
yesterday I was I was very jet-lagged

00:01:16,869 --> 00:01:20,289
I'm still a little bit jet-lagged but

00:01:18,399 --> 00:01:22,179
yesterday just this is how I felt

00:01:20,289 --> 00:01:27,100
yesterday was it's Friday toon year yay

00:01:22,179 --> 00:01:30,240
Thursday um but today today today today

00:01:27,100 --> 00:01:33,670
is Friday so let's weekend

00:01:30,240 --> 00:01:35,560
now now is the time for Friday hugs I

00:01:33,670 --> 00:01:39,000
want everybody to stand up and I want

00:01:35,560 --> 00:01:39,000
you to give the Internet a hug with me

00:01:39,570 --> 00:01:48,210
this is a tradition that I do and I will

00:01:44,350 --> 00:01:48,210
explain why in a minute okay

00:01:48,240 --> 00:01:59,250
all right everybody one two three happy

00:01:52,750 --> 00:02:02,409
bride okay thank you

00:01:59,250 --> 00:02:04,090
so I do this I do this every Friday a

00:02:02,409 --> 00:02:05,800
hug the internet the reason I do it is

00:02:04,090 --> 00:02:08,050
because I work from home and I get kind

00:02:05,800 --> 00:02:10,539
of lonely so the internet the internet

00:02:08,050 --> 00:02:13,420
is my water cooler so that's how I say

00:02:10,539 --> 00:02:17,459
hello everyone I was actually in I was

00:02:13,420 --> 00:02:21,160
in Japan a couple weeks ago and I

00:02:17,459 --> 00:02:23,620
decided to go to some retirement homes

00:02:21,160 --> 00:02:28,989
and do Friday hug there and this is a

00:02:23,620 --> 00:02:33,850
photo of one of them who hear you're

00:02:28,989 --> 00:02:35,290
doing Friday hugs there oh I'm just

00:02:33,850 --> 00:02:38,019
kidding that's not true there's a real

00:02:35,290 --> 00:02:39,489
photo but I was out there I'm on the

00:02:38,019 --> 00:02:44,530
Ruby core team in the rails core team

00:02:39,489 --> 00:02:55,290
and I have a quiz for you today is this

00:02:44,530 --> 00:02:57,970
Ruby or rail I work for a company called

00:02:55,290 --> 00:03:02,170
github I don't know if you've heard of

00:02:57,970 --> 00:03:05,380
it this is a small company I work for it

00:03:02,170 --> 00:03:07,900
is I have to I have to make this a joke

00:03:05,380 --> 00:03:10,980
at every conference it is the only legit

00:03:07,900 --> 00:03:10,980
company I've ever worked for

00:03:11,100 --> 00:03:15,519
so this is this is not if you thank you

00:03:14,110 --> 00:03:17,560
thank you this is not to be confused

00:03:15,519 --> 00:03:23,110
with NASA's presentation where he was

00:03:17,560 --> 00:03:25,090
showing off widget but I thought it was

00:03:23,110 --> 00:03:27,040
kind of cool because he posted the link

00:03:25,090 --> 00:03:29,549
to and it was on github so it was legit

00:03:27,040 --> 00:03:29,549
on git

00:03:29,769 --> 00:03:35,920
but I actually was going around and I

00:03:31,840 --> 00:03:38,110
well I forked to the project so there is

00:03:35,920 --> 00:03:41,410
actually two of them so now it's it's

00:03:38,110 --> 00:03:43,890
two legit and those are two legit on on

00:03:41,410 --> 00:03:43,890
git

00:03:46,270 --> 00:03:53,060
yes those of you grew up in the 80s know

00:03:51,920 --> 00:03:55,490
what I'm talking about

00:03:53,060 --> 00:04:00,350
all right so anyway I love you can get

00:03:55,490 --> 00:04:04,310
but I will not force push it on you so I

00:04:00,350 --> 00:04:06,710
work for I work for github as a Ruby and

00:04:04,310 --> 00:04:09,050
rails developer and what I mean by that

00:04:06,710 --> 00:04:11,960
is I actually work on Ruby and rails for

00:04:09,050 --> 00:04:14,480
github so fortunately github allows me

00:04:11,960 --> 00:04:16,670
to do open source development as my as

00:04:14,480 --> 00:04:19,760
my full-time job though I have recently

00:04:16,670 --> 00:04:21,799
become mister manager but I still do

00:04:19,760 --> 00:04:25,550
open source development and mr. managing

00:04:21,799 --> 00:04:27,920
as well so anyway I get to work on open

00:04:25,550 --> 00:04:30,050
source code all day and I just want to

00:04:27,920 --> 00:04:31,850
say like you know github loves open

00:04:30,050 --> 00:04:33,920
source and I am extremely grateful that

00:04:31,850 --> 00:04:37,460
they let me do this

00:04:33,920 --> 00:04:41,390
I have two cats this one is the attacker

00:04:37,460 --> 00:04:43,490
for Facebook YouTube Instagram I didn't

00:04:41,390 --> 00:04:45,470
include the Instagram part and chooses

00:04:43,490 --> 00:04:47,900
to - for short this is the more famous

00:04:45,470 --> 00:04:51,830
one his name is Gorbachev puff-puff

00:04:47,900 --> 00:04:53,740
thunderhorse and they or Gorby puffs for

00:04:51,830 --> 00:04:56,810
short they love each other very much

00:04:53,740 --> 00:04:59,450
actually that's not true he he hates her

00:04:56,810 --> 00:05:00,920
and she loves him and they just hate so

00:04:59,450 --> 00:05:04,570
she always snuggle with him and he gets

00:05:00,920 --> 00:05:07,120
annoyed and leave but they they're

00:05:04,570 --> 00:05:09,380
totally experts in getting in my way

00:05:07,120 --> 00:05:11,180
for example they like to sleep on my

00:05:09,380 --> 00:05:13,730
keyboard like this and this is like this

00:05:11,180 --> 00:05:16,780
is a I'm constantly cleaning hair out of

00:05:13,730 --> 00:05:19,850
my keyboard because of these these cats

00:05:16,780 --> 00:05:21,800
I'm a mechanical keyboard enthusiast

00:05:19,850 --> 00:05:23,090
I love mechanical keyboards and I'm

00:05:21,800 --> 00:05:25,700
going to show you this is my this is my

00:05:23,090 --> 00:05:28,970
list of my mechanical keyboards I own

00:05:25,700 --> 00:05:31,070
five or godox keyboards three of them

00:05:28,970 --> 00:05:32,690
are infinity ergo docks is one of them's

00:05:31,070 --> 00:05:35,030
in Irbid ah cz and the other ones the

00:05:32,690 --> 00:05:40,630
original I own two planks and one a tray

00:05:35,030 --> 00:05:45,010
us and this is very sad this is

00:05:40,630 --> 00:05:45,010
thousands of dollars of keyboards I

00:05:45,730 --> 00:05:50,300
shouldn't spend so much money on these

00:05:47,960 --> 00:05:51,470
things what I do this is my this is my

00:05:50,300 --> 00:05:53,480
daily driver one this

00:05:51,470 --> 00:05:56,570
the infinity or godox pencil when I use

00:05:53,480 --> 00:05:58,880
daily all the other ago does look very

00:05:56,570 --> 00:06:02,420
similar to this one but this is my daily

00:05:58,880 --> 00:06:03,980
use one this is my travel keyboard whose

00:06:02,420 --> 00:06:05,360
what a point cooks like I have this one

00:06:03,980 --> 00:06:07,220
here with me today so if you want to

00:06:05,360 --> 00:06:08,750
take a look at that afterwards please

00:06:07,220 --> 00:06:10,460
come say hello to me and I will show it

00:06:08,750 --> 00:06:13,880
to you and you can type on it and it's

00:06:10,460 --> 00:06:17,360
very loud and I want you to enjoy how

00:06:13,880 --> 00:06:18,530
loud it is ok this is this is the atreya

00:06:17,360 --> 00:06:20,960
keyboard this is an interesting

00:06:18,530 --> 00:06:23,660
interesting keyboard as well I like this

00:06:20,960 --> 00:06:26,690
keyboard a lot but I don't travel with

00:06:23,660 --> 00:06:28,340
it because this one fits more keys into

00:06:26,690 --> 00:06:30,590
a smaller space and it's easier to pack

00:06:28,340 --> 00:06:33,170
although I do love this keyboard I also

00:06:30,590 --> 00:06:34,910
have a I figured you know I was putting

00:06:33,170 --> 00:06:36,620
in these slides about my keyboards I

00:06:34,910 --> 00:06:40,250
figured I may as well show off all the

00:06:36,620 --> 00:06:44,120
other crap that's on my desk so I also

00:06:40,250 --> 00:06:46,970
use an L track Mouse as a roller Mouse

00:06:44,120 --> 00:06:49,850
and that is my cat lying there in the

00:06:46,970 --> 00:06:52,669
background and the reason I got those

00:06:49,850 --> 00:06:55,460
Mouse is because well I was having RFI

00:06:52,669 --> 00:06:57,650
problems but also the cat kept sweeping

00:06:55,460 --> 00:07:00,200
on my mouse pad so this is the this is a

00:06:57,650 --> 00:07:02,480
situation I was living with like I could

00:07:00,200 --> 00:07:06,800
barely use the mouse pad and it would

00:07:02,480 --> 00:07:08,090
get really bad like this like that and I

00:07:06,800 --> 00:07:11,570
don't want to move them out of the way

00:07:08,090 --> 00:07:13,610
because I feel bad but actually reviewed

00:07:11,570 --> 00:07:16,400
this mouse pad if you go on Amazon I

00:07:13,610 --> 00:07:18,710
review this Mac and there's like

00:07:16,400 --> 00:07:21,320
thousands and thousands of comments on

00:07:18,710 --> 00:07:23,810
my review for this mouse pad because I

00:07:21,320 --> 00:07:28,940
think the title the mousepad was like it

00:07:23,810 --> 00:07:33,200
was I really enjoy the 50 25 to 50% of

00:07:28,940 --> 00:07:35,390
this mouse pad I can use it any time so

00:07:33,200 --> 00:07:37,760
it is it is a popular popular review on

00:07:35,390 --> 00:07:41,600
Amazon so that's actually how people

00:07:37,760 --> 00:07:44,810
know me is this review i use a norman

00:07:41,600 --> 00:07:46,460
layout this is different than Dvorak

00:07:44,810 --> 00:07:50,120
Ricordi it's actually based off of

00:07:46,460 --> 00:07:52,610
qwerty where they moved as few keys as

00:07:50,120 --> 00:07:55,820
possible but to improve your like

00:07:52,610 --> 00:07:57,590
improve typing it took me about three

00:07:55,820 --> 00:07:59,419
weeks to learn that so I I have a

00:07:57,590 --> 00:08:00,800
completely custom setup and what that

00:07:59,419 --> 00:08:03,949
means is that I'm totally used

00:08:00,800 --> 00:08:05,840
on a laptop basically now the reason I

00:08:03,949 --> 00:08:08,539
did all the stuff is because at one

00:08:05,840 --> 00:08:10,580
point I had really bad RSI issues like I

00:08:08,539 --> 00:08:11,870
couldn't type at all I my hands are just

00:08:10,580 --> 00:08:15,139
hurting all the time

00:08:11,870 --> 00:08:17,150
and I realized the reason the reason I

00:08:15,139 --> 00:08:18,979
was getting these pains in my hand is

00:08:17,150 --> 00:08:21,229
because I wasn't thinking about my work

00:08:18,979 --> 00:08:23,840
environmental at all like I just would

00:08:21,229 --> 00:08:26,030
type on whatever and I don't care how I

00:08:23,840 --> 00:08:28,430
sat or it didn't matter even though I

00:08:26,030 --> 00:08:31,069
was spending you know however many hours

00:08:28,430 --> 00:08:33,789
a day at a desk so I never really

00:08:31,069 --> 00:08:36,050
thought about that much at all and I

00:08:33,789 --> 00:08:37,820
once I started thinking about it and

00:08:36,050 --> 00:08:39,289
actually getting into the stuff that's

00:08:37,820 --> 00:08:41,300
the reason I spent so much money on

00:08:39,289 --> 00:08:43,190
these keyboards and things was to make

00:08:41,300 --> 00:08:45,380
sure I didn't get that pain again so

00:08:43,190 --> 00:08:47,149
what I want to pass on to you today is

00:08:45,380 --> 00:08:49,760
to think about your work environment and

00:08:47,149 --> 00:08:53,810
to invest in yourself Don said this

00:08:49,760 --> 00:08:55,250
earlier yes call back to you so make

00:08:53,810 --> 00:08:56,510
sure we thinking about your work

00:08:55,250 --> 00:08:59,990
environment so you don't get injured

00:08:56,510 --> 00:09:01,760
like I did I you don't want to get

00:08:59,990 --> 00:09:04,610
injured and then do the stuff you should

00:09:01,760 --> 00:09:06,740
do it in advance please or so please

00:09:04,610 --> 00:09:14,089
invest in yourself or treat yourself as

00:09:06,740 --> 00:09:20,750
I like to say I also love puns but

00:09:14,089 --> 00:09:27,380
sequel puns make me very upset no sequel

00:09:20,750 --> 00:09:28,760
puns please take a photo so I want to

00:09:27,380 --> 00:09:30,620
talk a little bit a little bit about

00:09:28,760 --> 00:09:33,230
error messages there was an awesome talk

00:09:30,620 --> 00:09:36,079
yesterday about error messages and I

00:09:33,230 --> 00:09:38,480
enjoyed I enjoyed that presentation and

00:09:36,079 --> 00:09:39,770
I want to tell you about my relationship

00:09:38,480 --> 00:09:41,720
with error messages and that's that I

00:09:39,770 --> 00:09:47,449
have an incredibly short attention span

00:09:41,720 --> 00:09:49,070
I like to cure meat and this is this is

00:09:47,449 --> 00:09:52,010
some of the sausage that I make like I

00:09:49,070 --> 00:09:54,740
made some sausage at home and I promise

00:09:52,010 --> 00:09:57,350
it relates to error messages uh so I

00:09:54,740 --> 00:10:00,230
like to make sausages this is this is a

00:09:57,350 --> 00:10:01,760
some pancetta that I made I made this I

00:10:00,230 --> 00:10:03,470
also enjoy making bacon though I

00:10:01,760 --> 00:10:08,140
couldn't find any photos of it for some

00:10:03,470 --> 00:10:08,140
reason and I love to make

00:10:11,990 --> 00:10:18,660
so I love I love to cure meats and stuff

00:10:15,150 --> 00:10:21,240
and I want to make bacon and when you go

00:10:18,660 --> 00:10:24,810
buy it at the store it was about $4.99 a

00:10:21,240 --> 00:10:26,790
pound and okay that's for expensive they

00:10:24,810 --> 00:10:28,110
can I apologize for the imperial units

00:10:26,790 --> 00:10:29,970
but it doesn't really matter because

00:10:28,110 --> 00:10:32,220
I've used the same units throughout so

00:10:29,970 --> 00:10:36,690
you can figure out the price it's $4.99

00:10:32,220 --> 00:10:39,270
per some unit now when I went to make my

00:10:36,690 --> 00:10:41,490
own bacon I would I had to buy raw pork

00:10:39,270 --> 00:10:43,500
belly could cure it myself and

00:10:41,490 --> 00:10:47,190
unfortunately when I went to buy that

00:10:43,500 --> 00:10:50,610
that ended up being $5.25 per pound and

00:10:47,190 --> 00:10:52,620
that really bothered me because the raw

00:10:50,610 --> 00:10:54,390
pork belly was more expensive than the

00:10:52,620 --> 00:10:57,270
cured pork belly and presumably they had

00:10:54,390 --> 00:10:59,400
done more more processing on that so it

00:10:57,270 --> 00:11:01,260
bugs me that I wanted to make my own at

00:10:59,400 --> 00:11:02,550
home and I wasn't saving any money doing

00:11:01,260 --> 00:11:05,460
it

00:11:02,550 --> 00:11:07,800
so I went around to several stores and

00:11:05,460 --> 00:11:10,470
kept buying these raw pork bellies and

00:11:07,800 --> 00:11:13,680
they I noticed that they kept coming in

00:11:10,470 --> 00:11:15,120
the same box and no matter what butcher

00:11:13,680 --> 00:11:17,010
I went to they would they would put it

00:11:15,120 --> 00:11:19,170
in the same box and I'm like hmm the

00:11:17,010 --> 00:11:21,209
interesting so I figured out where the

00:11:19,170 --> 00:11:23,730
box came from and I found out that it

00:11:21,209 --> 00:11:25,290
was actually a wholesaler and I found

00:11:23,730 --> 00:11:26,670
out if I went and bought these pork

00:11:25,290 --> 00:11:28,500
bellies from the wholesaler they were

00:11:26,670 --> 00:11:31,220
about two dollars and 25 cents a pound

00:11:28,500 --> 00:11:34,140
so that was a great discount

00:11:31,220 --> 00:11:35,880
unfortunately if you want to buy pork

00:11:34,140 --> 00:11:37,410
bellies from a wholesaler you actually

00:11:35,880 --> 00:11:39,089
had to have a business license so I

00:11:37,410 --> 00:11:40,980
needed to incorporate a business and

00:11:39,089 --> 00:11:45,860
that's where I that's why I started my

00:11:40,980 --> 00:11:45,860
consulting company adequate industries

00:11:46,990 --> 00:11:54,560
everything adequately so I started this

00:11:52,940 --> 00:11:58,579
consulting business so that I could go

00:11:54,560 --> 00:12:00,800
buy go buy these pork bellies now when I

00:11:58,579 --> 00:12:02,720
filled out the online forms a cost about

00:12:00,800 --> 00:12:04,370
I don't know forty dollars to start a

00:12:02,720 --> 00:12:07,459
business and I was filling out the

00:12:04,370 --> 00:12:08,990
online forms and like they kept asking

00:12:07,459 --> 00:12:10,519
you youth questions this is where the

00:12:08,990 --> 00:12:12,649
short attention span comes in they kept

00:12:10,519 --> 00:12:14,630
asking me these questions and I didn't

00:12:12,649 --> 00:12:17,300
know how to answer them so I was just

00:12:14,630 --> 00:12:19,550
like like I'd saw the forum and give me

00:12:17,300 --> 00:12:21,079
some errors and my eyes would glaze over

00:12:19,550 --> 00:12:23,300
because I didn't understand the errors

00:12:21,079 --> 00:12:25,670
so I'd just fill out keep filling out

00:12:23,300 --> 00:12:28,220
stuff like putting in stuff and checking

00:12:25,670 --> 00:12:31,610
stuff until it finally let me through

00:12:28,220 --> 00:12:34,610
and I'm not quite sure what I put into

00:12:31,610 --> 00:12:36,410
the form but it let me through and they

00:12:34,610 --> 00:12:38,000
took the government took my money so I

00:12:36,410 --> 00:12:40,970
figured I must have done everything

00:12:38,000 --> 00:12:45,910
right right they they wouldn't take my

00:12:40,970 --> 00:12:49,130
money unless I did it right right

00:12:45,910 --> 00:12:52,130
so anyways fast forward like I had the

00:12:49,130 --> 00:12:56,029
business for maybe three years or so and

00:12:52,130 --> 00:12:59,149
I get a I get a call one day from from

00:12:56,029 --> 00:13:01,010
an auditor from the cities and she says

00:12:59,149 --> 00:13:05,500
to me your business isn't set up

00:13:01,010 --> 00:13:05,500
correctly and I said oh really

00:13:06,100 --> 00:13:10,610
and so she explains to me she explained

00:13:09,290 --> 00:13:12,199
to me what was wrong with the business

00:13:10,610 --> 00:13:13,820
and I had no idea what she was talking

00:13:12,199 --> 00:13:15,320
about and I'm like I don't know what I

00:13:13,820 --> 00:13:18,320
have no idea what you're talking about

00:13:15,320 --> 00:13:19,880
and she said well yes your business is

00:13:18,320 --> 00:13:22,519
set up completely wrong and I said well

00:13:19,880 --> 00:13:24,230
yes but you took my money so why did you

00:13:22,519 --> 00:13:26,199
take my money if it's all set up wrong

00:13:24,230 --> 00:13:28,220
and she's like well I don't know but

00:13:26,199 --> 00:13:32,870
you're going to have to pay some fines

00:13:28,220 --> 00:13:34,370
and I'm like oh gee and so she says well

00:13:32,870 --> 00:13:35,660
how much you know how much money have

00:13:34,370 --> 00:13:37,459
you made with the business and I'm like

00:13:35,660 --> 00:13:41,540
I don't make any money with the business

00:13:37,459 --> 00:13:44,120
I omitted the part about pork bellies uh

00:13:41,540 --> 00:13:49,100
I don't make any money with the business

00:13:44,120 --> 00:13:50,149
so uh she said okay well I you don't

00:13:49,100 --> 00:13:52,250
have then you don't have to pay any

00:13:50,149 --> 00:13:54,920
fines but we we want to close down your

00:13:52,250 --> 00:13:56,540
business want to close it and I said

00:13:54,920 --> 00:13:57,980
okay that's fine I don't want to pay any

00:13:56,540 --> 00:13:58,819
I don't pay anything you can go ahead

00:13:57,980 --> 00:14:00,529
and close it down

00:13:58,819 --> 00:14:03,110
so she says okay Gregg closes it down

00:14:00,529 --> 00:14:05,089
and then about two weeks later I get a

00:14:03,110 --> 00:14:09,410
letter from the city asking me whether

00:14:05,089 --> 00:14:15,199
or not I wanted to renew my business so

00:14:09,410 --> 00:14:19,550
I replied yes in second segment and so I

00:14:15,199 --> 00:14:23,389
may or may not still have a business not

00:14:19,550 --> 00:14:28,009
totally sure anyway so that is my my fog

00:14:23,389 --> 00:14:29,389
of error messages so anyway let's move

00:14:28,009 --> 00:14:31,250
on a bit I want to say I want to say

00:14:29,389 --> 00:14:33,860
thank you thank you to the organizers

00:14:31,250 --> 00:14:35,990
for having me thank you all of you for

00:14:33,860 --> 00:14:38,269
coming here today I love coming to

00:14:35,990 --> 00:14:40,100
Singapore was my fourth or fifth time I

00:14:38,269 --> 00:14:42,500
think it's at this conference I love

00:14:40,100 --> 00:14:44,630
being here the talks are always amazing

00:14:42,500 --> 00:14:47,209
I saw some of the best talks this year

00:14:44,630 --> 00:14:49,399
I've seen so far I learned so much when

00:14:47,209 --> 00:14:51,380
I'm here and I enjoy talking to the

00:14:49,399 --> 00:14:53,720
people because there's so many talented

00:14:51,380 --> 00:14:57,459
engineers here I always leave feeling

00:14:53,720 --> 00:14:57,459
inspired so thank you all very much

00:15:01,030 --> 00:15:10,210
oh oh oh are we okay

00:15:08,470 --> 00:15:14,510
I'm just kidding I'm kidding knows me

00:15:10,210 --> 00:15:14,510
[Laughter]

00:15:16,020 --> 00:15:20,080
alright so we're going to talk about

00:15:17,710 --> 00:15:21,430
mark compact GP for MRI this is this is

00:15:20,080 --> 00:15:25,510
the ongoing development that we're doing

00:15:21,430 --> 00:15:28,150
it gets github last year I spoke about

00:15:25,510 --> 00:15:31,420
garbage collection as well and at the

00:15:28,150 --> 00:15:34,450
end of my talk I proposed a propose a

00:15:31,420 --> 00:15:36,940
thing called an idea called heat

00:15:34,450 --> 00:15:39,010
splitting and we were working on that at

00:15:36,940 --> 00:15:42,610
github and we ended up abandoning the

00:15:39,010 --> 00:15:45,490
project so this is a unfortunately I am

00:15:42,610 --> 00:15:47,800
a failure of a software engineer so I'm

00:15:45,490 --> 00:15:49,960
now a senior software engineer telling

00:15:47,800 --> 00:15:52,390
you that I am NOT great at programming

00:15:49,960 --> 00:15:54,580
but anyway we abandon that project for a

00:15:52,390 --> 00:15:56,020
different project called compaction and

00:15:54,580 --> 00:15:58,540
that's what I want to talk to you about

00:15:56,020 --> 00:16:00,340
today I actually introduced compaction a

00:15:58,540 --> 00:16:05,620
tiny bit last year and said that it was

00:16:00,340 --> 00:16:09,910
something that was impossible to do with

00:16:05,620 --> 00:16:14,200
MRI but it turns out I was wrong so I am

00:16:09,910 --> 00:16:16,090
frequently wrong apparently I as I was

00:16:14,200 --> 00:16:19,110
about heat splitting so we're going to

00:16:16,090 --> 00:16:23,170
talk about a compaction this this year

00:16:19,110 --> 00:16:25,630
now Ruby already has a marking

00:16:23,170 --> 00:16:27,640
compacting GC and so we're not really

00:16:25,630 --> 00:16:28,780
going to focus too much on the mark side

00:16:27,640 --> 00:16:31,420
of this we're going to talk about the

00:16:28,780 --> 00:16:33,310
compaction side but in order to talk

00:16:31,420 --> 00:16:35,080
about a compacting garbage collector we

00:16:33,310 --> 00:16:37,600
actually have to have two things already

00:16:35,080 --> 00:16:39,010
we need to have objects and we need to

00:16:37,600 --> 00:16:41,230
have free space we have to have

00:16:39,010 --> 00:16:44,830
something to compact and we have have to

00:16:41,230 --> 00:16:46,060
have some place to contact them into so

00:16:44,830 --> 00:16:48,490
the roadmap is going to be we're going

00:16:46,060 --> 00:16:49,960
to look at how allocations work then

00:16:48,490 --> 00:16:51,580
collections and we'll focus on

00:16:49,960 --> 00:16:55,120
compaction and move into the actual

00:16:51,580 --> 00:16:58,000
implementation details of compaction and

00:16:55,120 --> 00:17:00,130
I took a page from Lonnie two o'clock

00:16:58,000 --> 00:17:02,620
yesterday and reserved the slide for

00:17:00,130 --> 00:17:07,320
local jokes so if you have any local

00:17:02,620 --> 00:17:09,880
jokes please tell them to me later so

00:17:07,320 --> 00:17:11,620
first let's talk about allocation now

00:17:09,880 --> 00:17:13,690
this is an example of some code that

00:17:11,620 --> 00:17:14,689
allocates a whole bunch of objects of

00:17:13,690 --> 00:17:17,449
you

00:17:14,689 --> 00:17:19,459
but when we execute this code where do

00:17:17,449 --> 00:17:20,959
those objects go like where do they

00:17:19,459 --> 00:17:22,669
actually get put and what actually

00:17:20,959 --> 00:17:25,039
allocates them what I think is

00:17:22,669 --> 00:17:26,360
interesting is that allocation is

00:17:25,039 --> 00:17:28,429
actually the garbage collectors

00:17:26,360 --> 00:17:29,840
responsibility and when you I thought

00:17:28,429 --> 00:17:31,490
that was always weird when you hear the

00:17:29,840 --> 00:17:33,679
name garbage collector you think oh it's

00:17:31,490 --> 00:17:36,019
actually getting rid of any garbage but

00:17:33,679 --> 00:17:38,059
actually creating garbage is also the

00:17:36,019 --> 00:17:39,590
garbage collectors job as well so it's

00:17:38,059 --> 00:17:42,500
not just the garbage collector it is

00:17:39,590 --> 00:17:45,049
also a garbage producer which is

00:17:42,500 --> 00:17:47,659
interesting to me and if you look

00:17:45,049 --> 00:17:49,970
through Ruby's code the source code the

00:17:47,659 --> 00:17:52,399
the source of all objects comes from a

00:17:49,970 --> 00:17:53,960
function called RB new obso if you want

00:17:52,399 --> 00:17:55,700
to dive into the code go look for this

00:17:53,960 --> 00:17:57,889
go look for this function you can read

00:17:55,700 --> 00:18:00,169
through it and learn how objects are

00:17:57,889 --> 00:18:01,940
allocated this function actually

00:18:00,169 --> 00:18:03,830
searches the memory stays for a new

00:18:01,940 --> 00:18:06,889
place that put the object and returns

00:18:03,830 --> 00:18:09,019
that object back to you so the way that

00:18:06,889 --> 00:18:11,419
Ruby actually divides the computer's

00:18:09,019 --> 00:18:14,000
memory is we have a heap which is some

00:18:11,419 --> 00:18:15,980
amount of memory Ruby actually divides

00:18:14,000 --> 00:18:18,139
that heap into pages so we have many

00:18:15,980 --> 00:18:19,940
pages then it divides those pages

00:18:18,139 --> 00:18:21,980
further into objects so each of the

00:18:19,940 --> 00:18:23,870
pages have objects and whenever we

00:18:21,980 --> 00:18:26,149
allocate an object we look for a space

00:18:23,870 --> 00:18:28,370
in one of those pages and if there is

00:18:26,149 --> 00:18:30,139
space and we put an object there and if

00:18:28,370 --> 00:18:32,269
there is no space and we'll allocate a

00:18:30,139 --> 00:18:34,549
new page and then we'll put objects in

00:18:32,269 --> 00:18:36,559
that in that new page when we have to

00:18:34,549 --> 00:18:38,929
allocate a new page that's called a slow

00:18:36,559 --> 00:18:41,360
path allocation so we say give me an

00:18:38,929 --> 00:18:42,740
object I'm going to if there's no room

00:18:41,360 --> 00:18:44,570
then the process will actions will

00:18:42,740 --> 00:18:46,460
allocate a page and then put that object

00:18:44,570 --> 00:18:48,230
go so it's called a slow path allocation

00:18:46,460 --> 00:18:50,870
because we have to go through all the

00:18:48,230 --> 00:18:52,429
work of creating a new page if there is

00:18:50,870 --> 00:18:54,620
free space that's called a Fastpass

00:18:52,429 --> 00:18:56,240
allocation it's it's because all we have

00:18:54,620 --> 00:18:58,159
to do is just return that object back we

00:18:56,240 --> 00:18:59,750
have we have space for it so when you're

00:18:58,159 --> 00:19:01,549
running your application in production

00:18:59,750 --> 00:19:03,230
you want to reduce the number of slow

00:19:01,549 --> 00:19:05,179
path allocations that you're doing in

00:19:03,230 --> 00:19:07,549
production and increase the number of

00:19:05,179 --> 00:19:08,929
fast path allocations so in order to do

00:19:07,549 --> 00:19:13,279
that you can tweak some of the garbage

00:19:08,929 --> 00:19:15,559
collector garbage collection knobs and

00:19:13,279 --> 00:19:17,539
one to tweak is this one called RV GC

00:19:15,559 --> 00:19:19,159
heap free sloths and this basically says

00:19:17,539 --> 00:19:22,639
the number of clots that we're going to

00:19:19,159 --> 00:19:25,369
have available so we tune ours up fairly

00:19:22,639 --> 00:19:26,380
high at github such that when a request

00:19:25,369 --> 00:19:27,910
comes through

00:19:26,380 --> 00:19:29,830
we don't have to do any slow path

00:19:27,910 --> 00:19:32,860
allocations all of them are fast paths

00:19:29,830 --> 00:19:35,530
so we keep a large heap these pages are

00:19:32,860 --> 00:19:37,179
also called arenas if you hear that term

00:19:35,530 --> 00:19:39,580
it's essentially the same thing just an

00:19:37,179 --> 00:19:42,100
amount of memory that we reallocate in

00:19:39,580 --> 00:19:42,910
some place so if we look further into a

00:19:42,100 --> 00:19:44,919
page layout

00:19:42,910 --> 00:19:46,690
I said pages are where we store new

00:19:44,919 --> 00:19:48,580
objects but what actually happens is

00:19:46,690 --> 00:19:51,669
when we allocate a page that page gets

00:19:48,580 --> 00:19:54,520
prefilled with a bunch of free slots so

00:19:51,669 --> 00:19:56,620
we have a bunch of these free free areas

00:19:54,520 --> 00:19:59,289
in a page and when you allocate objects

00:19:56,620 --> 00:20:01,750
out the objects get put into those free

00:19:59,289 --> 00:20:03,940
slots as we're running our program so

00:20:01,750 --> 00:20:08,230
it'll go through there and allocate put

00:20:03,940 --> 00:20:10,750
them into those free slots now when it

00:20:08,230 --> 00:20:12,820
when objects get freed they actually go

00:20:10,750 --> 00:20:14,140
away from those freeze those slots and

00:20:12,820 --> 00:20:15,429
they just get turned into free slots

00:20:14,140 --> 00:20:17,409
again I'll just go away

00:20:15,429 --> 00:20:19,960
when they're GC they get turned into

00:20:17,409 --> 00:20:20,710
free slot and then we can reuse those

00:20:19,960 --> 00:20:24,130
slots later

00:20:20,710 --> 00:20:27,940
now slots are fixed with which so each

00:20:24,130 --> 00:20:29,590
object is only 40 bytes wide but that's

00:20:27,940 --> 00:20:32,200
kind of interesting when you think about

00:20:29,590 --> 00:20:34,179
it like if a ruby object is only 40

00:20:32,200 --> 00:20:36,789
bytes how do we store things like hashes

00:20:34,179 --> 00:20:38,500
or arrays we know how she's grow larger

00:20:36,789 --> 00:20:40,960
than 40 bytes though so how does that

00:20:38,500 --> 00:20:43,390
actually work the way this works is if

00:20:40,960 --> 00:20:44,980
we have memory like this our computer's

00:20:43,390 --> 00:20:47,710
memory and we have some page in the

00:20:44,980 --> 00:20:49,150
memory when we allocate objects in there

00:20:47,710 --> 00:20:51,700
let's say we have some kind of hash

00:20:49,150 --> 00:20:53,530
object in there what will do is will

00:20:51,700 --> 00:20:56,049
allocate what's called an SD hash

00:20:53,530 --> 00:20:57,880
structure out on on the heap it's not

00:20:56,049 --> 00:21:00,280
actually allocated inside of that page

00:20:57,880 --> 00:21:02,049
it's allocated somewhere else in the

00:21:00,280 --> 00:21:04,210
computer's memory and the way that we

00:21:02,049 --> 00:21:09,400
actually allocate those SD hashes is

00:21:04,210 --> 00:21:11,230
with the mallet call now when a GC

00:21:09,400 --> 00:21:13,659
occurs and you want to free that hash

00:21:11,230 --> 00:21:16,360
it's the hashes responsibility to say

00:21:13,659 --> 00:21:18,159
okay before I get freed I'm going to

00:21:16,360 --> 00:21:20,740
call the free function on the SD hash

00:21:18,159 --> 00:21:23,320
now that SD hash will get freed up and

00:21:20,740 --> 00:21:26,049
then the garbage collector will free the

00:21:23,320 --> 00:21:28,210
Ruby hash object itself so that's how

00:21:26,049 --> 00:21:31,000
we're able to store objects larger than

00:21:28,210 --> 00:21:32,049
40 bytes in the computer's memory and

00:21:31,000 --> 00:21:35,230
this will be important a little bit

00:21:32,049 --> 00:21:36,820
later so this memory up at the top here

00:21:35,230 --> 00:21:38,860
that's managed by the system allocator

00:21:36,820 --> 00:21:39,450
where that slice at the bottom is

00:21:38,860 --> 00:21:42,360
managed by

00:21:39,450 --> 00:21:44,250
garbage collector now interesting facts

00:21:42,360 --> 00:21:46,799
about these two areas are that we can

00:21:44,250 --> 00:21:48,659
control the layout and the format of

00:21:46,799 --> 00:21:50,370
objects that are allocated inside of the

00:21:48,659 --> 00:21:52,230
GC so we can move those things around

00:21:50,370 --> 00:21:54,419
and manipulate them but the ones that

00:21:52,230 --> 00:21:56,639
are outside those system allocations we

00:21:54,419 --> 00:21:59,130
can't necessarily control where those

00:21:56,639 --> 00:22:01,409
are with the system allocator we can do

00:21:59,130 --> 00:22:03,600
some little tricks but we don't have

00:22:01,409 --> 00:22:06,240
nearly as much control over them as we

00:22:03,600 --> 00:22:08,720
do with the objects allocated in the GC

00:22:06,240 --> 00:22:11,519
so anything allocating the GC is much

00:22:08,720 --> 00:22:14,220
much better for us than if it's a system

00:22:11,519 --> 00:22:16,169
allocated so in summary we're going to

00:22:14,220 --> 00:22:19,049
summarize with some Ruby code a heap has

00:22:16,169 --> 00:22:21,470
many pages a page has many slots a slot

00:22:19,049 --> 00:22:24,059
can either be empty or have an object

00:22:21,470 --> 00:22:26,730
those are the conditions of our of our

00:22:24,059 --> 00:22:28,409
memory so when we look at collection

00:22:26,730 --> 00:22:30,799
we're going to talk about collection oh

00:22:28,409 --> 00:22:33,299
we talked about this a little bit in the

00:22:30,799 --> 00:22:35,460
last year but we're going to do a little

00:22:33,299 --> 00:22:37,440
refresher because it's important to

00:22:35,460 --> 00:22:39,120
understand how collection works in order

00:22:37,440 --> 00:22:42,210
to see the tricks we can do with

00:22:39,120 --> 00:22:44,250
compaction so Ruby uses a mark and sweep

00:22:42,210 --> 00:22:46,139
garbage collector and the algorithm

00:22:44,250 --> 00:22:49,590
roughly goes something like this if we

00:22:46,139 --> 00:22:52,260
have Ruby objects those Ruby objects

00:22:49,590 --> 00:22:54,450
form a tree in memory this is kind of

00:22:52,260 --> 00:22:56,639
what the tree looks like now if we cut

00:22:54,450 --> 00:22:59,340
one of those cut one of those slice

00:22:56,639 --> 00:23:01,049
those arrows from the tree we actually

00:22:59,340 --> 00:23:02,429
have to free up all those things and

00:23:01,049 --> 00:23:04,860
that's where the garbage collector comes

00:23:02,429 --> 00:23:07,710
in we cut that relationship it fries

00:23:04,860 --> 00:23:10,110
those fries those objects so the actual

00:23:07,710 --> 00:23:14,159
the actual algorithm has two different

00:23:10,110 --> 00:23:16,409
parts the mark mark part and the sweet

00:23:14,159 --> 00:23:19,919
part which is why it's called a

00:23:16,409 --> 00:23:21,779
mark-and-sweep garbage collector so the

00:23:19,919 --> 00:23:24,510
way this works is if we have some sort

00:23:21,779 --> 00:23:26,070
of have some sort of tree we go through

00:23:24,510 --> 00:23:28,049
what is called a mark phase and we walk

00:23:26,070 --> 00:23:30,720
through the tree we're starting from the

00:23:28,049 --> 00:23:33,120
root so in this particular example we'll

00:23:30,720 --> 00:23:37,320
go from the root to eight F and then

00:23:33,120 --> 00:23:39,899
from s to D B and C and then from the D

00:23:37,320 --> 00:23:41,370
we go back to a and anything at the end

00:23:39,899 --> 00:23:43,860
of this mark phase that hasn't been

00:23:41,370 --> 00:23:45,720
marked we free it so that's what happens

00:23:43,860 --> 00:23:48,179
those all get those all get freed and

00:23:45,720 --> 00:23:51,659
that's the overview of a mark and sweep

00:23:48,179 --> 00:23:52,770
mark and sweep implementation now the

00:23:51,659 --> 00:23:56,370
thing that actually

00:23:52,770 --> 00:23:58,230
those edges is a function called GC mark

00:23:56,370 --> 00:24:00,300
and that's going to be important later

00:23:58,230 --> 00:24:03,510
where is that GC mark right there so

00:24:00,300 --> 00:24:06,420
that that function is what marks those

00:24:03,510 --> 00:24:07,620
arrows so it's important this function

00:24:06,420 --> 00:24:09,360
name is important and we'll look at it

00:24:07,620 --> 00:24:11,820
later so if we're to look at this in

00:24:09,360 --> 00:24:13,050
Ruby code we would say like hey object

00:24:11,820 --> 00:24:14,280
give me references I'm going to walk

00:24:13,050 --> 00:24:16,860
through each of the references and call

00:24:14,280 --> 00:24:18,450
GC more from this now the downside of

00:24:16,860 --> 00:24:20,970
mark-and-sweep is that it's kind of a

00:24:18,450 --> 00:24:22,380
slow swell algorithm but there are

00:24:20,970 --> 00:24:24,240
different tricks that we can do to

00:24:22,380 --> 00:24:27,000
increase the speed of the algorithm such

00:24:24,240 --> 00:24:28,920
as incremental incremental marking and

00:24:27,000 --> 00:24:31,620
lazy sweeping and we actually discussed

00:24:28,920 --> 00:24:34,020
those in depth last year so if you want

00:24:31,620 --> 00:24:35,820
to know more about that watch the watch

00:24:34,020 --> 00:24:39,180
the top

00:24:35,820 --> 00:24:41,550
now onto compacting we've looked at how

00:24:39,180 --> 00:24:42,870
objects are created and destroyed but

00:24:41,550 --> 00:24:45,780
how does this actually relate to

00:24:42,870 --> 00:24:49,110
compacting now let's say we have a bunch

00:24:45,780 --> 00:24:52,980
of objects like this and we free up some

00:24:49,110 --> 00:24:54,750
of those objects like that the amount of

00:24:52,980 --> 00:24:56,490
memory that's actually consumed is still

00:24:54,750 --> 00:24:58,230
the size of all of those pages even

00:24:56,490 --> 00:24:59,880
though we freed up all those objects we

00:24:58,230 --> 00:25:03,090
didn't actually decrease the size of the

00:24:59,880 --> 00:25:05,310
memory right now let's say we're freeing

00:25:03,090 --> 00:25:07,350
more objects and all of a sudden that

00:25:05,310 --> 00:25:09,810
top page becomes free in this particular

00:25:07,350 --> 00:25:11,880
case what will happen is when the page

00:25:09,810 --> 00:25:13,740
becomes completely free Ruby will

00:25:11,880 --> 00:25:15,990
actually free that page up so it goes

00:25:13,740 --> 00:25:18,360
away and now we're able to reduce the

00:25:15,990 --> 00:25:20,910
amount of memory that the process uses

00:25:18,360 --> 00:25:23,100
so now what if we have a situation like

00:25:20,910 --> 00:25:25,860
this where we freed up many objects and

00:25:23,100 --> 00:25:29,010
the sum of those objects equals the size

00:25:25,860 --> 00:25:32,220
of one page now if we could move those

00:25:29,010 --> 00:25:33,750
objects around it would be nice to move

00:25:32,220 --> 00:25:37,410
them around like this and then we could

00:25:33,750 --> 00:25:41,040
actually free up that page like that so

00:25:37,410 --> 00:25:43,470
unfortunately today object can't move so

00:25:41,040 --> 00:25:45,000
if we can't do this in rubies that you

00:25:43,470 --> 00:25:47,280
have installed on your production

00:25:45,000 --> 00:25:49,410
machines today and this is where

00:25:47,280 --> 00:25:50,850
compaction comes in and this is the work

00:25:49,410 --> 00:25:52,380
that we've been doing at github is

00:25:50,850 --> 00:25:54,780
working on a compacting garbage

00:25:52,380 --> 00:25:56,700
collector and you can actually find all

00:25:54,780 --> 00:26:01,340
of these all these changes here so this

00:25:56,700 --> 00:26:01,340
is this is the Ligeti

00:26:01,370 --> 00:26:10,410
let G C on legit so if you want to find

00:26:08,160 --> 00:26:12,060
all that work is up here on github so

00:26:10,410 --> 00:26:15,360
I'm going to talk about the actual

00:26:12,060 --> 00:26:17,130
contacting side of this now the

00:26:15,360 --> 00:26:18,390
compaction algorithm algorithm that

00:26:17,130 --> 00:26:20,250
we're going to we're going to talk about

00:26:18,390 --> 00:26:22,410
is called two-finger compaction there's

00:26:20,250 --> 00:26:24,060
actually many many different compaction

00:26:22,410 --> 00:26:26,250
algorithms but this is the one that we

00:26:24,060 --> 00:26:28,920
implemented it's called two-finger

00:26:26,250 --> 00:26:36,840
compaction yes I was playing with

00:26:28,920 --> 00:26:39,080
keynote and it was fun so the downsides

00:26:36,840 --> 00:26:41,400
of this particular this particular

00:26:39,080 --> 00:26:42,900
algorithm the first disadvantage this

00:26:41,400 --> 00:26:44,610
algorithm has is that it's not very

00:26:42,900 --> 00:26:46,020
efficient and you'll see you'll see the

00:26:44,610 --> 00:26:47,670
algorithm in action a little bit later

00:26:46,020 --> 00:26:49,650
and the second problem with this

00:26:47,670 --> 00:26:52,230
algorithm is that it actually places

00:26:49,650 --> 00:26:54,660
objects in a random random locations in

00:26:52,230 --> 00:26:57,420
memory you'll see why in a minute here

00:26:54,660 --> 00:26:58,950
but the the major advantage behind this

00:26:57,420 --> 00:27:00,870
algorithm is that it's actually very

00:26:58,950 --> 00:27:04,380
simple to understand and simple to

00:27:00,870 --> 00:27:08,220
implement with and I am very lazy so

00:27:04,380 --> 00:27:10,830
those things appeal to me greatly so the

00:27:08,220 --> 00:27:13,140
the algorithm has two steps which is

00:27:10,830 --> 00:27:15,360
moving objects and updating references

00:27:13,140 --> 00:27:16,500
so it first it moves the objects I'm

00:27:15,360 --> 00:27:18,360
going to actually update all the

00:27:16,500 --> 00:27:20,160
references for the objects we're going

00:27:18,360 --> 00:27:22,320
to look at the algorithm here so the

00:27:20,160 --> 00:27:24,270
algorithm starts with this is a page

00:27:22,320 --> 00:27:26,670
that we have with some free slots in it

00:27:24,270 --> 00:27:28,020
and some objects on the slots and up at

00:27:26,670 --> 00:27:30,810
the top there those are the actual

00:27:28,020 --> 00:27:33,060
addresses of the objects so it starts

00:27:30,810 --> 00:27:37,650
out by putting two pointers on either

00:27:33,060 --> 00:27:39,930
end of either end of the page and the

00:27:37,650 --> 00:27:41,430
less pointer is called the free point or

00:27:39,930 --> 00:27:43,410
the right pointer is called the scan

00:27:41,430 --> 00:27:45,270
pointer and what happens is the left

00:27:43,410 --> 00:27:47,520
pointer moves to the right until it

00:27:45,270 --> 00:27:49,770
finds a free slot and the right pointer

00:27:47,520 --> 00:27:51,990
moves to the left until finds an object

00:27:49,770 --> 00:27:54,960
and when those two things happen it

00:27:51,990 --> 00:27:56,460
swaps those two so in this case we stop

00:27:54,960 --> 00:27:58,770
right here and we just swap those two

00:27:56,460 --> 00:28:01,380
and then it actually writes out a

00:27:58,770 --> 00:28:04,560
forwarding address so the object that

00:28:01,380 --> 00:28:07,350
used to be in B now is in one so it

00:28:04,560 --> 00:28:10,440
leaves the one address there and we

00:28:07,350 --> 00:28:12,390
repeat this so this the left scans until

00:28:10,440 --> 00:28:14,540
it finds free the right scans until it

00:28:12,390 --> 00:28:16,820
finds an object it swaps and

00:28:14,540 --> 00:28:19,220
leave the forwarding address so it keeps

00:28:16,820 --> 00:28:21,890
repeating this process until those two

00:28:19,220 --> 00:28:24,170
pointers meet so it will repeat and then

00:28:21,890 --> 00:28:26,600
finally when they meet we've moved all

00:28:24,170 --> 00:28:28,610
the objects next to each other so the

00:28:26,600 --> 00:28:30,920
actual the actual code for implementing

00:28:28,610 --> 00:28:32,660
this is it looks like this and it's

00:28:30,920 --> 00:28:34,640
really it's really very simple you can

00:28:32,660 --> 00:28:36,080
see up there we take a scan pointer and

00:28:34,640 --> 00:28:38,210
a free pointer those are the things that

00:28:36,080 --> 00:28:40,490
are moving through through the heap and

00:28:38,210 --> 00:28:42,290
then we basically just swap the two we

00:28:40,490 --> 00:28:46,550
do a mend copy of one to the other and

00:28:42,290 --> 00:28:48,350
then we're done so unfortunately if we

00:28:46,550 --> 00:28:51,890
have let's say some Ruby code that looks

00:28:48,350 --> 00:28:53,450
like this the the objects are related to

00:28:51,890 --> 00:28:55,580
each other they have a relationship with

00:28:53,450 --> 00:28:57,470
each other so indicated by those arrows

00:28:55,580 --> 00:28:59,330
there we have maybe some hash at points

00:28:57,470 --> 00:29:02,180
that a points at a symbol in a string

00:28:59,330 --> 00:29:04,130
now unfortunately after we compact the

00:29:02,180 --> 00:29:06,500
heap it'll end up looking like this and

00:29:04,130 --> 00:29:08,750
now that hash points at two locations

00:29:06,500 --> 00:29:11,540
that no longer contain the objects that

00:29:08,750 --> 00:29:13,130
we're looking for so because of that we

00:29:11,540 --> 00:29:14,450
have to make another pass through the

00:29:13,130 --> 00:29:16,130
heap and actually update those

00:29:14,450 --> 00:29:18,860
references so it points with the right

00:29:16,130 --> 00:29:21,200
thing and this is a very easy algorithm

00:29:18,860 --> 00:29:23,150
all we do is start at one end and we

00:29:21,200 --> 00:29:25,520
just move along looking at each object

00:29:23,150 --> 00:29:28,130
to see that see what references that

00:29:25,520 --> 00:29:30,260
object has if it has references we look

00:29:28,130 --> 00:29:32,420
at the follow those references look for

00:29:30,260 --> 00:29:33,890
the forwarding addresses then we simply

00:29:32,420 --> 00:29:35,630
change the references to point at the

00:29:33,890 --> 00:29:38,270
forwarding addresses so in this

00:29:35,630 --> 00:29:40,280
particular case object number four used

00:29:38,270 --> 00:29:42,380
to point at six and seven now it needs

00:29:40,280 --> 00:29:44,150
to point at five and three so all we do

00:29:42,380 --> 00:29:46,490
is update those arrows the point at five

00:29:44,150 --> 00:29:48,650
and three and then continue on through

00:29:46,490 --> 00:29:51,710
the through the keep updating references

00:29:48,650 --> 00:29:53,420
like that so once we reach the end of

00:29:51,710 --> 00:29:55,280
the end of the heap we're done and we've

00:29:53,420 --> 00:29:58,520
updated all the references everything is

00:29:55,280 --> 00:30:00,290
working yay then the final step is to go

00:29:58,520 --> 00:30:02,690
through and change all these forwarding

00:30:00,290 --> 00:30:05,870
addresses back to free free slots and

00:30:02,690 --> 00:30:07,880
now our heap is back to a normal Ruby

00:30:05,870 --> 00:30:10,430
heap and all the objects are moved next

00:30:07,880 --> 00:30:12,290
to each other so I want to show a little

00:30:10,430 --> 00:30:15,070
bit of the updating update reference

00:30:12,290 --> 00:30:17,900
code and I'm just going to show it for

00:30:15,070 --> 00:30:20,210
just four arrays but basically all we do

00:30:17,900 --> 00:30:21,920
is we have this C code that basically

00:30:20,210 --> 00:30:23,309
iterates through every single one of

00:30:21,920 --> 00:30:25,529
these slots in the

00:30:23,309 --> 00:30:27,330
slots in your heap and then calls an

00:30:25,529 --> 00:30:28,950
update references function down there at

00:30:27,330 --> 00:30:31,019
the bottom and updates the references

00:30:28,950 --> 00:30:33,269
for those objects now if we go look at

00:30:31,019 --> 00:30:35,429
that that update object references was

00:30:33,269 --> 00:30:37,289
actually in a very large function and

00:30:35,429 --> 00:30:39,330
what it is it's looking at the type of

00:30:37,289 --> 00:30:41,249
the object and depending on the type it

00:30:39,330 --> 00:30:43,379
updates the references so for example

00:30:41,249 --> 00:30:45,419
one of the one of the things is an array

00:30:43,379 --> 00:30:47,399
is the case statement inside of that

00:30:45,419 --> 00:30:49,320
function where we handle arrays and we

00:30:47,399 --> 00:30:50,999
say okay well this is a shared array we

00:30:49,320 --> 00:30:52,950
update that pointer if it's not a shared

00:30:50,999 --> 00:30:55,080
array then we go through and update all

00:30:52,950 --> 00:30:57,059
the references inside of the array so

00:30:55,080 --> 00:31:00,690
that's all we have to do we're done it

00:30:57,059 --> 00:31:03,389
is that easy a so there's there's

00:31:00,690 --> 00:31:05,490
actually a the the cost of this

00:31:03,389 --> 00:31:08,220
algorithm is that we have to visit each

00:31:05,490 --> 00:31:10,559
slot three times we have to visit every

00:31:08,220 --> 00:31:12,659
object once in order to move all the

00:31:10,559 --> 00:31:15,600
objects we have to visit every object

00:31:12,659 --> 00:31:18,299
again in order to update the references

00:31:15,600 --> 00:31:20,070
and we have to visit every object again

00:31:18,299 --> 00:31:22,769
in order to remove those free free slots

00:31:20,070 --> 00:31:25,320
in the future we can probably remove

00:31:22,769 --> 00:31:27,600
that last step and just treat these

00:31:25,320 --> 00:31:29,039
forwarding pointers as free slots but

00:31:27,600 --> 00:31:32,539
you can see we have to walk through

00:31:29,039 --> 00:31:34,440
every single object twice at least so

00:31:32,539 --> 00:31:35,730
compaction challenges I want to talk

00:31:34,440 --> 00:31:37,679
about some of the challenges we've had

00:31:35,730 --> 00:31:41,279
implementing this implementing this

00:31:37,679 --> 00:31:42,840
compactor at work one all these all

00:31:41,279 --> 00:31:45,659
these problems boiled down to

00:31:42,840 --> 00:31:48,269
essentially object addresses so every

00:31:45,659 --> 00:31:50,940
object in your system every Ruby object

00:31:48,269 --> 00:31:52,769
has an address an address and memory now

00:31:50,940 --> 00:31:55,169
unfortunately a lot of the code out

00:31:52,769 --> 00:31:57,960
there specifically the C code out there

00:31:55,169 --> 00:32:00,149
today believes that these addresses are

00:31:57,960 --> 00:32:03,240
constant that the the address for that

00:32:00,149 --> 00:32:07,259
particular object will never change now

00:32:03,240 --> 00:32:09,090
unfortunately if we will have some C

00:32:07,259 --> 00:32:10,980
code that says points that this object

00:32:09,090 --> 00:32:13,700
and it says oh this address number four

00:32:10,980 --> 00:32:17,820
that'll never change right fine

00:32:13,700 --> 00:32:21,990
now unfortunately with a compactor that

00:32:17,820 --> 00:32:25,259
is no longer true so uh the primary

00:32:21,990 --> 00:32:27,149
offender of this this rule is

00:32:25,259 --> 00:32:28,919
specifically C code and we're going to

00:32:27,149 --> 00:32:31,019
look at those look at how to address

00:32:28,919 --> 00:32:32,490
these C code issues because we have to

00:32:31,019 --> 00:32:34,470
address this in order for it to actually

00:32:32,490 --> 00:32:36,090
be a production-ready thing

00:32:34,470 --> 00:32:37,769
the three problem cases we'll look at

00:32:36,090 --> 00:32:40,230
our C extensions and how we dealt with

00:32:37,769 --> 00:32:43,710
that hash tables and also global

00:32:40,230 --> 00:32:47,309
variables in C so for C extensions the

00:32:43,710 --> 00:32:50,490
way we dealt with that is a little trick

00:32:47,309 --> 00:32:52,230
I use now so far the object

00:32:50,490 --> 00:32:54,480
relationships we've looked at have been

00:32:52,230 --> 00:32:55,919
hashes that point at strings and symbols

00:32:54,480 --> 00:32:58,950
and these are just normal

00:32:55,919 --> 00:33:00,539
normal Ruby objects right now these are

00:32:58,950 --> 00:33:02,279
regular references and we can handle

00:33:00,539 --> 00:33:04,620
these regular references pretty easily

00:33:02,279 --> 00:33:06,269
because they're implemented inside of

00:33:04,620 --> 00:33:08,490
MRI we know how to update those

00:33:06,269 --> 00:33:11,309
references we can fix them but what if

00:33:08,490 --> 00:33:13,350
we have some C code over here some C

00:33:11,309 --> 00:33:15,269
data structure the points that our a

00:33:13,350 --> 00:33:20,009
Ruby object how do we how do we actually

00:33:15,269 --> 00:33:22,200
handle that so if we don't if we don't

00:33:20,009 --> 00:33:24,720
handle that then the garbage collector

00:33:22,200 --> 00:33:27,990
could actually free the hash and then

00:33:24,720 --> 00:33:31,440
our our our C code would explode right

00:33:27,990 --> 00:33:33,600
if you have if you have C code it has to

00:33:31,440 --> 00:33:35,610
do something to make sure that that Ruby

00:33:33,600 --> 00:33:37,529
hash stays around and if that Ruby hash

00:33:35,610 --> 00:33:40,830
doesn't stay around then that C code

00:33:37,529 --> 00:33:44,279
must explode so how do we how does the C

00:33:40,830 --> 00:33:46,529
code actually handle this so the C code

00:33:44,279 --> 00:33:48,330
has to say well I want that hash to stay

00:33:46,529 --> 00:33:50,669
around because I'm referencing it and in

00:33:48,330 --> 00:33:52,710
order to do that in order to do that the

00:33:50,669 --> 00:33:55,500
C extension author actually has to call

00:33:52,710 --> 00:33:57,809
a function called RB GC mark so they

00:33:55,500 --> 00:34:00,029
call our b GC mark on that ruby object

00:33:57,809 --> 00:34:03,120
in order to say hey i'm still holding a

00:34:00,029 --> 00:34:05,700
reference to this don't free this don't

00:34:03,120 --> 00:34:07,980
free this object now what's interesting

00:34:05,700 --> 00:34:11,069
is if you remember back to our market

00:34:07,980 --> 00:34:12,690
our mark sweet algorithm you'll note

00:34:11,069 --> 00:34:14,849
that the way we actually mark references

00:34:12,690 --> 00:34:18,510
was we have a function called GC mark

00:34:14,849 --> 00:34:20,490
not our v GC mom so actually internal

00:34:18,510 --> 00:34:22,500
data structure is normal regular Ruby

00:34:20,490 --> 00:34:25,349
objects use this function called RB GC

00:34:22,500 --> 00:34:27,960
mark so our called GC mark so in this

00:34:25,349 --> 00:34:30,300
way we can differentiate between objects

00:34:27,960 --> 00:34:32,550
that are held by C extensions versus

00:34:30,300 --> 00:34:35,369
objects that are held by just normal

00:34:32,550 --> 00:34:37,589
regular Ruby objects so in this

00:34:35,369 --> 00:34:40,169
particular case we can say okay well you

00:34:37,589 --> 00:34:43,500
know don't move that hash it's being

00:34:40,169 --> 00:34:45,869
held on to by a C extension but the

00:34:43,500 --> 00:34:47,850
string and the symbol those are okay to

00:34:45,869 --> 00:34:50,070
move okay we can move both

00:34:47,850 --> 00:34:51,810
because they're just being held by Ruby

00:34:50,070 --> 00:34:55,710
a ruby object and we know how to fix

00:34:51,810 --> 00:34:57,450
those now I want to prime you for

00:34:55,710 --> 00:34:58,710
questions to ask me later what happens

00:34:57,450 --> 00:35:00,210
if you have a C extension that

00:34:58,710 --> 00:35:02,100
references a symbol like this that

00:35:00,210 --> 00:35:05,780
doesn't market what is that case what do

00:35:02,100 --> 00:35:08,760
we do then so please ask me that later

00:35:05,780 --> 00:35:11,100
so let's look at hash tables this is

00:35:08,760 --> 00:35:13,950
probably the least interesting problem

00:35:11,100 --> 00:35:16,020
but also most frustrating or maybe both

00:35:13,950 --> 00:35:19,140
of those I'm not sure it's it's an

00:35:16,020 --> 00:35:21,390
interesting / fun and not fun problem

00:35:19,140 --> 00:35:23,490
and you'll see why here so a normal hash

00:35:21,390 --> 00:35:26,070
table a hash table all it does is that

00:35:23,490 --> 00:35:29,130
have some sort of a bucketing system

00:35:26,070 --> 00:35:31,560
where we take some we take some value

00:35:29,130 --> 00:35:33,810
and we compute a hash code for that

00:35:31,560 --> 00:35:35,580
value and based on that hash code we

00:35:33,810 --> 00:35:38,460
stick to the stick that data structure

00:35:35,580 --> 00:35:42,270
into some bucket right so we have some

00:35:38,460 --> 00:35:44,310
key value pair for example we have some

00:35:42,270 --> 00:35:46,590
hashing function that computes the hash

00:35:44,310 --> 00:35:48,480
for the key and say in this case it

00:35:46,590 --> 00:35:50,490
computed 6 and it stores the key in

00:35:48,480 --> 00:35:53,700
value there that way later on what we

00:35:50,490 --> 00:35:56,490
can do is take that same key compute the

00:35:53,700 --> 00:35:58,260
hash key for it again and get access to

00:35:56,490 --> 00:36:01,290
that value we're all we're all familiar

00:35:58,260 --> 00:36:03,390
with this we know roughly how hashes

00:36:01,290 --> 00:36:07,740
work we use these day-to-day I think

00:36:03,390 --> 00:36:09,900
especially if you're a rack user so the

00:36:07,740 --> 00:36:12,180
default hashing function unfortunately

00:36:09,900 --> 00:36:13,380
is this and you don't need to understand

00:36:12,180 --> 00:36:15,930
the sneak code I'm going to point out

00:36:13,380 --> 00:36:18,570
exactly to you what the problem is the

00:36:15,930 --> 00:36:21,390
default hashing function actually uses

00:36:18,570 --> 00:36:24,240
the memory address that uses the object

00:36:21,390 --> 00:36:26,580
address so if you take the hash value of

00:36:24,240 --> 00:36:28,830
some Ruby object it's going to be the

00:36:26,580 --> 00:36:31,650
object address now the problem is that

00:36:28,830 --> 00:36:34,680
if that object moves well that address

00:36:31,650 --> 00:36:36,090
changes and if that address changes well

00:36:34,680 --> 00:36:39,480
then the hash code changes for that

00:36:36,090 --> 00:36:41,190
object and if that hash code changes

00:36:39,480 --> 00:36:43,740
then we can no longer look up the object

00:36:41,190 --> 00:36:47,190
in the hash right so this is an issue

00:36:43,740 --> 00:36:50,070
for hashes I yes I said this if the

00:36:47,190 --> 00:36:52,920
address changes then so does the hash so

00:36:50,070 --> 00:36:54,780
how do we how do we fix this clearly if

00:36:52,920 --> 00:36:56,580
you use some key in the hash we want to

00:36:54,780 --> 00:36:59,490
be able to look up that value again so

00:36:56,580 --> 00:37:00,430
what do we do well the solution that we

00:36:59,490 --> 00:37:03,430
have taken on for

00:37:00,430 --> 00:37:05,950
who don't allow house keys to move so

00:37:03,430 --> 00:37:09,910
it's just these these certain groups of

00:37:05,950 --> 00:37:11,680
objects they cannot move okay now I put

00:37:09,910 --> 00:37:13,420
a little star by that because I want to

00:37:11,680 --> 00:37:16,150
give you feed you another question which

00:37:13,420 --> 00:37:18,520
is what about strings so ask me this

00:37:16,150 --> 00:37:21,060
later in the Q&A section or if we have

00:37:18,520 --> 00:37:23,320
if we don't have time ask me over a beer

00:37:21,060 --> 00:37:26,290
so the final thing I want to talk about

00:37:23,320 --> 00:37:27,820
is a global variable and I'm going to

00:37:26,290 --> 00:37:30,400
show you an example of global variables

00:37:27,820 --> 00:37:34,150
that we had to deal with in MRI and I

00:37:30,400 --> 00:37:35,410
sent a patch to fix this so in this case

00:37:34,150 --> 00:37:37,450
we have a global variable here called

00:37:35,410 --> 00:37:39,280
separator and this separator actually

00:37:37,450 --> 00:37:41,620
points in a string called slash it's

00:37:39,280 --> 00:37:43,240
just slash you'll note you'll know the

00:37:41,620 --> 00:37:44,140
slash from when you do file dot joint

00:37:43,240 --> 00:37:46,690
okay

00:37:44,140 --> 00:37:48,520
now that that global variable is used

00:37:46,690 --> 00:37:50,350
again down here when you say file dot

00:37:48,520 --> 00:37:52,210
doing so it's okay take those two things

00:37:50,350 --> 00:37:56,020
join them together with that string and

00:37:52,210 --> 00:38:00,030
we're great now what happens if we

00:37:56,020 --> 00:38:02,800
assign the separator to nil and then GC

00:38:00,030 --> 00:38:05,260
so let's take a look at this code we say

00:38:02,800 --> 00:38:07,270
assign file call and separator to nil

00:38:05,260 --> 00:38:08,620
and the other one to nil then we do a GC

00:38:07,270 --> 00:38:11,290
and then we start you'll actually get a

00:38:08,620 --> 00:38:13,600
seg date and that is because I'll show

00:38:11,290 --> 00:38:17,320
you in a minute it this segment is not

00:38:13,600 --> 00:38:20,490
occur with JRuby so I shouldn't plug

00:38:17,320 --> 00:38:24,580
JRuby some time on me MRI scene bud

00:38:20,490 --> 00:38:26,680
there you go so the reason this sexy

00:38:24,580 --> 00:38:28,210
happens is because we have the string in

00:38:26,680 --> 00:38:30,580
memory we actually have three references

00:38:28,210 --> 00:38:32,800
to it we have the global variable in C

00:38:30,580 --> 00:38:34,810
pointing at that object and then we have

00:38:32,800 --> 00:38:36,970
these two Ruby constants pointing at the

00:38:34,810 --> 00:38:38,890
object now this code here that our

00:38:36,970 --> 00:38:41,950
that's in the lower right I'm assigning

00:38:38,890 --> 00:38:47,350
those global objects to those constants

00:38:41,950 --> 00:38:51,520
to nil and then we do a GC start so we

00:38:47,350 --> 00:38:53,830
assign those to nil we do a GC start the

00:38:51,520 --> 00:38:56,290
GC says well there is no references to

00:38:53,830 --> 00:38:58,810
that flash object anymore so I'm going

00:38:56,290 --> 00:39:00,220
to free it so it frees it because the

00:38:58,810 --> 00:39:04,270
global variable does not know how to

00:39:00,220 --> 00:39:06,160
market so it frees it and then when the

00:39:04,270 --> 00:39:08,860
final file dot join runs everything

00:39:06,160 --> 00:39:10,840
blows up because we have no reference to

00:39:08,860 --> 00:39:13,240
that object anymore so in this

00:39:10,840 --> 00:39:15,040
particular case uh

00:39:13,240 --> 00:39:16,930
what we did or what I did was submit a

00:39:15,040 --> 00:39:19,990
patch to stop using this global variable

00:39:16,930 --> 00:39:22,740
so look up the value rather than rather

00:39:19,990 --> 00:39:26,440
than use some global variable as a cache

00:39:22,740 --> 00:39:29,140
so this issue is similar to compaction

00:39:26,440 --> 00:39:31,300
because we're not able to update update

00:39:29,140 --> 00:39:33,670
the references of those global variables

00:39:31,300 --> 00:39:36,010
which is what that what's that what the

00:39:33,670 --> 00:39:38,260
compactor needs to do so global

00:39:36,010 --> 00:39:40,000
variables the the hash issue and the

00:39:38,260 --> 00:39:42,160
global variable issue are very similar

00:39:40,000 --> 00:39:44,110
because when those objects move we can't

00:39:42,160 --> 00:39:46,570
update we can't update those references

00:39:44,110 --> 00:39:50,590
so the general problem is essentially

00:39:46,570 --> 00:39:53,740
that we can only update Ruby objects

00:39:50,590 --> 00:39:57,520
appointed other Ruby objects and we can

00:39:53,740 --> 00:40:00,910
update those we can only update core

00:39:57,520 --> 00:40:03,010
classes to MRI so I want to I showed a

00:40:00,910 --> 00:40:05,140
few examples of the issues there are

00:40:03,010 --> 00:40:05,740
many issues but we've fixed them one by

00:40:05,140 --> 00:40:08,440
one

00:40:05,740 --> 00:40:10,869
piecemeal and it seems to be working

00:40:08,440 --> 00:40:12,250
most of the time so I want to show you a

00:40:10,869 --> 00:40:15,010
result of the compaction we're actually

00:40:12,250 --> 00:40:16,210
using we use the compactor in production

00:40:15,010 --> 00:40:18,580
and I want to share some of the results

00:40:16,210 --> 00:40:20,500
with you that we found this is an

00:40:18,580 --> 00:40:26,109
example of a rails heap I'm just going

00:40:20,500 --> 00:40:27,460
to show a bare bare rails project so the

00:40:26,109 --> 00:40:30,490
compaction code looks like this

00:40:27,460 --> 00:40:32,050
essentially we open an open a file we

00:40:30,490 --> 00:40:33,970
write out the heap to the file we have

00:40:32,050 --> 00:40:36,250
to specifically compact the heap by

00:40:33,970 --> 00:40:38,380
calling GC compact then we write it out

00:40:36,250 --> 00:40:41,440
again so to run this with the rails

00:40:38,380 --> 00:40:43,450
script Runner now if we graph all the

00:40:41,440 --> 00:40:46,300
graph with the slots look like if we

00:40:43,450 --> 00:40:47,890
graph the heap before the before we were

00:40:46,300 --> 00:40:51,820
on compaction the heap looks like this

00:40:47,890 --> 00:40:54,760
now each of these columns are a page and

00:40:51,820 --> 00:40:57,700
we talked about pages earlier each of

00:40:54,760 --> 00:41:01,210
the red dots are objects that we cannot

00:40:57,700 --> 00:41:03,520
move each of the green dots are objects

00:41:01,210 --> 00:41:05,710
that we can move in each of the white

00:41:03,520 --> 00:41:08,440
the white location that is free space

00:41:05,710 --> 00:41:11,440
and these pages are sorted by the number

00:41:08,440 --> 00:41:14,590
of objects that cannot be moved now

00:41:11,440 --> 00:41:16,060
after we compact it for you if we look

00:41:14,590 --> 00:41:18,490
at this graph again it looks something

00:41:16,060 --> 00:41:20,350
like this or you can see now we've got

00:41:18,490 --> 00:41:22,390
all the green objects move to one side

00:41:20,350 --> 00:41:24,640
of the heap and we have all the white

00:41:22,390 --> 00:41:26,150
space on the other side of the heap and

00:41:24,640 --> 00:41:32,029
we can allocate into there

00:41:26,150 --> 00:41:35,180
so before compaction we had 552 pages

00:41:32,029 --> 00:41:37,789
and of those pages 528 of those pages

00:41:35,180 --> 00:41:40,130
have space on them for allocation now

00:41:37,789 --> 00:41:42,259
the problem with this is is that every

00:41:40,130 --> 00:41:44,720
time we write to a page that page may be

00:41:42,259 --> 00:41:46,430
copied to a child process where we're

00:41:44,720 --> 00:41:48,589
using unicorn in production which is a

00:41:46,430 --> 00:41:50,690
forking web server so copy-on-write

00:41:48,589 --> 00:41:54,349
optimizations are important to us now

00:41:50,690 --> 00:41:58,039
after compaction we are only 160

00:41:54,349 --> 00:42:00,980
thousand of our 552 pages have space for

00:41:58,039 --> 00:42:03,019
allocation so maybe only 167 of those

00:42:00,980 --> 00:42:06,829
pages can possibly be copied where

00:42:03,019 --> 00:42:08,990
previously 528 could now this lower

00:42:06,829 --> 00:42:11,299
number is better for copy-on-write

00:42:08,990 --> 00:42:13,309
optimizations because we would like to

00:42:11,299 --> 00:42:15,589
have fewer pages we copy to child

00:42:13,309 --> 00:42:19,249
processes now we can actually improve

00:42:15,589 --> 00:42:20,869
this we you saw all those red dots at

00:42:19,249 --> 00:42:22,519
the bottom if we can fix those red

00:42:20,869 --> 00:42:25,309
objects such that there are fewer of

00:42:22,519 --> 00:42:27,589
them we can improve this number ideally

00:42:25,309 --> 00:42:29,359
we would have no red objects but you saw

00:42:27,589 --> 00:42:31,940
earlier we have those issues where there

00:42:29,359 --> 00:42:34,519
are some that we cannot move there are

00:42:31,940 --> 00:42:36,559
some that we found that I didn't show in

00:42:34,519 --> 00:42:38,299
this presentation that we fail we can't

00:42:36,559 --> 00:42:40,789
move them but with a bit of development

00:42:38,299 --> 00:42:41,630
work we can so I want to show you some

00:42:40,789 --> 00:42:43,910
of the heap graphs

00:42:41,630 --> 00:42:47,299
well a heap graph from our production

00:42:43,910 --> 00:42:49,220
application and the reason I didn't

00:42:47,299 --> 00:42:51,230
include many of these graphs is because

00:42:49,220 --> 00:42:53,089
they're very big we have a very large

00:42:51,230 --> 00:42:55,489
heap and production this is what it

00:42:53,089 --> 00:42:59,359
looks like after compaction you can see

00:42:55,489 --> 00:43:01,400
it is quite wide now the good news is I

00:42:59,359 --> 00:43:03,440
mean the bad news is if there's a lot of

00:43:01,400 --> 00:43:05,119
red objects on here the good news is is

00:43:03,440 --> 00:43:07,099
that it follows the trend of a basic

00:43:05,119 --> 00:43:10,640
rails application so we can say basic

00:43:07,099 --> 00:43:14,599
rails app is generally representative of

00:43:10,640 --> 00:43:16,369
the heap so why compact I've talked

00:43:14,599 --> 00:43:18,799
about how to build compactor and I gave

00:43:16,369 --> 00:43:21,079
one reason the one reason is to free up

00:43:18,799 --> 00:43:23,509
space like this we want to free up if we

00:43:21,079 --> 00:43:24,739
can we want to free up those pages the

00:43:23,509 --> 00:43:26,450
other is for coffee on write

00:43:24,739 --> 00:43:28,430
optimizations which I mentioned a little

00:43:26,450 --> 00:43:31,130
bit earlier we use a forking web server

00:43:28,430 --> 00:43:33,289
unicorn in a forking setup all the child

00:43:31,130 --> 00:43:35,210
processes share a memory with the parent

00:43:33,289 --> 00:43:37,069
process but as soon as either of them

00:43:35,210 --> 00:43:38,730
write to those processes we get that

00:43:37,069 --> 00:43:40,650
memory copied and that inquiry

00:43:38,730 --> 00:43:43,920
the overall memory used on the servers

00:43:40,650 --> 00:43:46,589
so we want to reduce that so for example

00:43:43,920 --> 00:43:48,329
in this case before compaction basically

00:43:46,589 --> 00:43:50,160
all of these pages could be written -

00:43:48,329 --> 00:43:51,839
all of them have free space on it so

00:43:50,160 --> 00:43:53,790
potentially all of them could be copied

00:43:51,839 --> 00:43:56,070
to a child process whereas after

00:43:53,790 --> 00:43:58,020
compaction you can see here only those

00:43:56,070 --> 00:44:01,349
pages can be copied to the child process

00:43:58,020 --> 00:44:05,369
and these pages remain shared among the

00:44:01,349 --> 00:44:07,109
among the parent and child processes now

00:44:05,369 --> 00:44:07,849
I want to talk about reality here for a

00:44:07,109 --> 00:44:11,660
minute

00:44:07,849 --> 00:44:15,960
unfortunately let's get back to reality

00:44:11,660 --> 00:44:17,280
sorry uh we're going to talk a little

00:44:15,960 --> 00:44:19,890
bit about I want to talk a little bit

00:44:17,280 --> 00:44:22,220
about agile agile development so agile

00:44:19,890 --> 00:44:25,980
agile development tells us the fail fad

00:44:22,220 --> 00:44:28,619
now I've created a new development style

00:44:25,980 --> 00:44:29,310
a new better development style that I

00:44:28,619 --> 00:44:36,599
call

00:44:29,310 --> 00:44:38,820
fail continuously so I've actually

00:44:36,599 --> 00:44:41,690
created a new continuous integration

00:44:38,820 --> 00:44:45,839
server where where we actually

00:44:41,690 --> 00:44:48,810
continuously fail and today I'm really

00:44:45,839 --> 00:44:51,450
proud to present a new product from

00:44:48,810 --> 00:44:56,250
adequate industries it's called Aaron CI

00:44:51,450 --> 00:44:58,800
where your test will fail constantly so

00:44:56,250 --> 00:45:00,000
I guess I'm coming around here making a

00:44:58,800 --> 00:45:03,000
tongue-in-cheek a tongue-in-cheek

00:45:00,000 --> 00:45:04,980
assertion that I I am somewhat of a

00:45:03,000 --> 00:45:06,900
failure and it is true because if we

00:45:04,980 --> 00:45:09,359
look at the real-world results of this

00:45:06,900 --> 00:45:13,740
compactor we saw in production maybe

00:45:09,359 --> 00:45:16,800
only a 2% improvement or a 2% for dust2

00:45:13,740 --> 00:45:20,250
percent reduction in memory usage on our

00:45:16,800 --> 00:45:22,440
production machines this is nowhere near

00:45:20,250 --> 00:45:23,910
the amount that we expected because if

00:45:22,440 --> 00:45:25,859
you look at these if you look at these

00:45:23,910 --> 00:45:28,770
graphs here we would expect ok well you

00:45:25,859 --> 00:45:32,250
know maybe in this case we have most of

00:45:28,770 --> 00:45:34,530
the shared and presumably only 30% of it

00:45:32,250 --> 00:45:37,109
can be copied so you'd expect us to have

00:45:34,530 --> 00:45:41,369
maybe I don't know 60% reduction in

00:45:37,109 --> 00:45:44,460
memory but that's not true or a 30%

00:45:41,369 --> 00:45:46,200
improvement it's not true and and we're

00:45:44,460 --> 00:45:47,790
trying to figure out why like I said

00:45:46,200 --> 00:45:49,380
this is ongoing development and I want

00:45:47,790 --> 00:45:50,630
to share with you two possibilities or

00:45:49,380 --> 00:45:53,180
two reasons why we're not

00:45:50,630 --> 00:45:56,029
the improvements that we expected there

00:45:53,180 --> 00:45:58,250
are two possibilities one is essentially

00:45:56,029 --> 00:46:00,349
poor compaction and the other one is

00:45:58,250 --> 00:46:01,940
maybe a small percentage of the heap is

00:46:00,349 --> 00:46:05,509
actually compact and I'll explain that

00:46:01,940 --> 00:46:07,789
in a second I glossed over some stuff in

00:46:05,509 --> 00:46:10,339
this presentation some stuff lots of

00:46:07,789 --> 00:46:12,859
stuff now if we look at this boom for

00:46:10,339 --> 00:46:15,680
compaction graph I've divided up these

00:46:12,859 --> 00:46:17,420
pages into four four parts and the

00:46:15,680 --> 00:46:19,369
reason I've divided these pages into

00:46:17,420 --> 00:46:22,099
four parts is because if you write to

00:46:19,369 --> 00:46:25,190
one page the entire page does not get

00:46:22,099 --> 00:46:28,849
copied only 25% of the page gets copied

00:46:25,190 --> 00:46:31,910
okay so the problem is that this free

00:46:28,849 --> 00:46:33,950
space there 25% of every single page

00:46:31,910 --> 00:46:36,680
that's open that particular free space

00:46:33,950 --> 00:46:39,440
that can possibly be copied may be equal

00:46:36,680 --> 00:46:41,710
to this free space here so if that's the

00:46:39,440 --> 00:46:44,779
case and we'll see no improvements in in

00:46:41,710 --> 00:46:46,940
copy-on-write so if the number of

00:46:44,779 --> 00:46:49,130
quarter pages is equal to the number of

00:46:46,940 --> 00:46:51,950
full pages after compaction then we

00:46:49,130 --> 00:46:54,650
won't see any improvements now the other

00:46:51,950 --> 00:46:56,630
possibility is that maybe the Ruby heap

00:46:54,650 --> 00:46:58,819
is actually much smaller than the amount

00:46:56,630 --> 00:47:00,769
of memory that we've allocated we talked

00:46:58,819 --> 00:47:03,140
a little bit earlier about hashes being

00:47:00,769 --> 00:47:04,549
allocated in one area and Ruby's GC

00:47:03,140 --> 00:47:06,740
allocated in a different area

00:47:04,549 --> 00:47:08,299
maybe Ruby's GC is it's just a small

00:47:06,740 --> 00:47:10,400
percentage of the memory that's being

00:47:08,299 --> 00:47:12,799
used so a compaction will have very

00:47:10,400 --> 00:47:15,259
little effect on it maybe it's large

00:47:12,799 --> 00:47:16,609
maybe it's small so we have to measure

00:47:15,259 --> 00:47:18,559
that and I want to talk a little bit

00:47:16,609 --> 00:47:19,819
about measuring and then I'm going to

00:47:18,559 --> 00:47:22,640
hurry because I'm totally over time

00:47:19,819 --> 00:47:25,880
we're measuring this now with a thing

00:47:22,640 --> 00:47:28,099
called malloc stop logging and what this

00:47:25,880 --> 00:47:30,829
is is we say every time you make a call

00:47:28,099 --> 00:47:32,750
to malloc we log the stack so we see who

00:47:30,829 --> 00:47:34,130
made that call and figure out what the

00:47:32,750 --> 00:47:35,990
problem is I'm going to show you how to

00:47:34,130 --> 00:47:37,670
do this on OS 10 but you can also do

00:47:35,990 --> 00:47:41,509
this with Val grind and the what's

00:47:37,670 --> 00:47:43,579
called the massive allocator so lookup

00:47:41,509 --> 00:47:46,640
that later the way to do this with OS 10

00:47:43,579 --> 00:47:49,220
is you simply set a variable called now

00:47:46,640 --> 00:47:51,140
it's back logging no compact and what

00:47:49,220 --> 00:47:53,809
this does that logs every single mouth

00:47:51,140 --> 00:47:56,000
call and now you put the process to

00:47:53,809 --> 00:47:58,640
sleep because you can only analyze live

00:47:56,000 --> 00:48:03,040
processes because of a thing called

00:47:58,640 --> 00:48:06,340
address randomization which don't just

00:48:03,040 --> 00:48:08,560
don't worry about it so you put the

00:48:06,340 --> 00:48:11,110
process to sleep and say okay in another

00:48:08,560 --> 00:48:13,120
terminal ask for the mouse history give

00:48:11,110 --> 00:48:15,600
me all all by size for that particular

00:48:13,120 --> 00:48:17,440
pit I just put in some kid that's

00:48:15,600 --> 00:48:19,960
obviously not the paid you're going to

00:48:17,440 --> 00:48:22,480
have so what that does is it actually

00:48:19,960 --> 00:48:24,700
prints out all of the live allocated

00:48:22,480 --> 00:48:27,490
things so this mallet stack logging logs

00:48:24,700 --> 00:48:29,230
of reallocation logs every three and the

00:48:27,490 --> 00:48:31,840
mallet history actually takes that

00:48:29,230 --> 00:48:33,400
history and calculate what is allocated

00:48:31,840 --> 00:48:35,410
now and what are the stats for those

00:48:33,400 --> 00:48:37,150
particular things so a sample of the

00:48:35,410 --> 00:48:39,040
stock log is like this I know you can't

00:48:37,150 --> 00:48:41,320
read it one record looks something like

00:48:39,040 --> 00:48:43,720
this where we say okay we had one call

00:48:41,320 --> 00:48:45,280
for some amount of bytes and that's what

00:48:43,720 --> 00:48:47,410
the stack looks like so you can see who

00:48:45,280 --> 00:48:50,590
made that call now I wrote some code to

00:48:47,410 --> 00:48:52,240
process it and it's kind of small but I

00:48:50,590 --> 00:48:53,890
want to point out I want to point out a

00:48:52,240 --> 00:48:57,370
few things about this processing code

00:48:53,890 --> 00:48:59,800
one is I use the flip flop operator the

00:48:57,370 --> 00:49:01,990
other is I use a protected method and

00:48:59,800 --> 00:49:06,880
the other is I have a method here with

00:49:01,990 --> 00:49:09,400
no parentheses are so I'm using all the

00:49:06,880 --> 00:49:12,730
worst practices from from this

00:49:09,400 --> 00:49:15,100
conference so if we use it if we use

00:49:12,730 --> 00:49:16,750
this code the process process the output

00:49:15,100 --> 00:49:18,790
of this malice stack logging we can see

00:49:16,750 --> 00:49:22,750
an empty program will have something

00:49:18,790 --> 00:49:24,100
like this where 17% only 17% of the heap

00:49:22,750 --> 00:49:27,340
is managed by the garbage collector

00:49:24,100 --> 00:49:28,960
where 83% of it is managed by the system

00:49:27,340 --> 00:49:33,460
and that's for an empty program this

00:49:28,960 --> 00:49:35,170
very basic empty program here now we can

00:49:33,460 --> 00:49:38,800
actually we can actually adjust with

00:49:35,170 --> 00:49:42,070
okay yes thank you earned good job we

00:49:38,800 --> 00:49:44,110
can we can adjust this let's say we

00:49:42,070 --> 00:49:45,760
change the number of slots that we

00:49:44,110 --> 00:49:47,740
initialize with let's say we start out

00:49:45,760 --> 00:49:50,920
with a hundred thousand Ruby objects and

00:49:47,740 --> 00:49:52,750
get the stack for that this is what it

00:49:50,920 --> 00:49:54,340
will look like so we started with 17

00:49:52,750 --> 00:49:56,080
with an empty program and we can

00:49:54,340 --> 00:49:57,940
actually increase the amount that's used

00:49:56,080 --> 00:49:59,680
by the garbage collector so we're

00:49:57,940 --> 00:50:02,620
testing in this in production right now

00:49:59,680 --> 00:50:04,900
unfortunately logging this data is slow

00:50:02,620 --> 00:50:06,940
so we're trying to come up with a better

00:50:04,900 --> 00:50:08,980
way to do it the test results will guide

00:50:06,940 --> 00:50:10,450
us how to actually fix this and improve

00:50:08,980 --> 00:50:13,420
the performance of the compare

00:50:10,450 --> 00:50:15,940
so depending on what the test results

00:50:13,420 --> 00:50:18,450
are it will tell us where we need to

00:50:15,940 --> 00:50:20,799
focus so if the test results show that

00:50:18,450 --> 00:50:22,450
most of the heat is taken up by the

00:50:20,799 --> 00:50:24,819
garbage collector then we need to fix

00:50:22,450 --> 00:50:28,299
all those red dots and allow those to

00:50:24,819 --> 00:50:30,039
move if it turns out that the Ruby GC is

00:50:28,299 --> 00:50:31,930
a small percentage of the heap then we

00:50:30,039 --> 00:50:33,880
need to allow variable with objects and

00:50:31,930 --> 00:50:36,339
start allocating hashes into rubies

00:50:33,880 --> 00:50:37,930
rubies garbage collector now the truth

00:50:36,339 --> 00:50:40,359
is that both of these things need to

00:50:37,930 --> 00:50:42,069
happen but the test results will tell us

00:50:40,359 --> 00:50:45,190
which one to focus on so that we can get

00:50:42,069 --> 00:50:46,510
the best best results for this so I'm

00:50:45,190 --> 00:50:48,430
going to finish up here because I am way

00:50:46,510 --> 00:50:51,039
over time I will summarize why should we

00:50:48,430 --> 00:50:54,880
compact compaction allows us to save us

00:50:51,039 --> 00:50:57,039
save memory in two ways which is freeing

00:50:54,880 --> 00:50:59,769
up freeing up pages and also improving

00:50:57,039 --> 00:51:02,559
copy-on-write performance we've

00:50:59,769 --> 00:51:04,799
developed this this patch is open source

00:51:02,559 --> 00:51:08,500
software which you can go check out here

00:51:04,799 --> 00:51:10,269
the plan is to upstream this sometime

00:51:08,500 --> 00:51:16,329
this year I'm hoping to get it done by

00:51:10,269 --> 00:51:18,160
September for Ruby kaikki and that is

00:51:16,329 --> 00:51:20,730
all thank you very much I'm so happy I

00:51:18,160 --> 00:51:20,730
could be here

00:51:24,550 --> 00:51:34,460
all right questions there you go

00:51:29,540 --> 00:51:36,050
yeah you can go to the mic hi I'm going

00:51:34,460 --> 00:51:37,610
to get a new laptop so I was wondering

00:51:36,050 --> 00:51:42,110
when will we get a new edition of

00:51:37,610 --> 00:51:44,240
stickers with Gorbachev in future well

00:51:42,110 --> 00:51:45,530
there's no there's no new edition no new

00:51:44,240 --> 00:51:49,160
edition right now I brought stickers

00:51:45,530 --> 00:51:51,790
with me I if I am invited back next year

00:51:49,160 --> 00:51:55,040
I will definitely bring new stickers we

00:51:51,790 --> 00:51:57,410
I brought I brought stickers there

00:51:55,040 --> 00:52:00,740
justly we've had the same stickers for a

00:51:57,410 --> 00:52:05,270
year we recently moved so my my brand

00:52:00,740 --> 00:52:08,030
manager my wife hasn't had time to

00:52:05,270 --> 00:52:10,490
design new ones so will I'll have some

00:52:08,030 --> 00:52:12,380
next year awesome and now for a more

00:52:10,490 --> 00:52:14,180
serious one yeah what will happen with

00:52:12,380 --> 00:52:15,980
object IDs since they depend on the

00:52:14,180 --> 00:52:17,630
memory where objects was allocated I'm

00:52:15,980 --> 00:52:19,160
sure that's that's a great question so

00:52:17,630 --> 00:52:21,080
the question is well what will happen

00:52:19,160 --> 00:52:25,220
with object ID the object IDs are based

00:52:21,080 --> 00:52:27,560
on based on the location of the object

00:52:25,220 --> 00:52:29,480
in memory so when you call object ID

00:52:27,560 --> 00:52:31,280
that number is directly related to where

00:52:29,480 --> 00:52:33,190
that object is in memory and the way

00:52:31,280 --> 00:52:35,870
that we're handling that is we actually

00:52:33,190 --> 00:52:38,000
lazily figure out what the object ID is

00:52:35,870 --> 00:52:40,040
and cash it on the object and then we

00:52:38,000 --> 00:52:42,590
have another a separate lookup table for

00:52:40,040 --> 00:52:44,990
collisions so basically what will happen

00:52:42,590 --> 00:52:47,210
is your object has no object ID until

00:52:44,990 --> 00:52:49,250
you call object ID then it will

00:52:47,210 --> 00:52:52,370
calculate the object ID based on you the

00:52:49,250 --> 00:52:56,030
address or if that value has already

00:52:52,370 --> 00:52:57,800
been taken from some other value so the

00:52:56,030 --> 00:53:02,000
moral of the story is please do not call

00:52:57,800 --> 00:53:07,870
object ID you can do it but it could be

00:53:02,000 --> 00:53:07,870
slow in the future yes

00:53:10,100 --> 00:53:15,360
like

00:53:12,330 --> 00:53:20,070
oh the excitation will be here what

00:53:15,360 --> 00:53:21,690
would be what welcome to be coffee there

00:53:20,070 --> 00:53:24,090
is this expectation that the stuff in

00:53:21,690 --> 00:53:26,340
the the green the red and green that

00:53:24,090 --> 00:53:29,670
that that would just be shared but can't

00:53:26,340 --> 00:53:31,560
those same cans of things in those pages

00:53:29,670 --> 00:53:32,970
also change over time and the

00:53:31,560 --> 00:53:33,570
copy-on-write could kick in for those

00:53:32,970 --> 00:53:35,190
pages

00:53:33,570 --> 00:53:38,820
sure sure yes that's a great question so

00:53:35,190 --> 00:53:40,080
the question is I can't move the the red

00:53:38,820 --> 00:53:43,320
and the green objects that I showed

00:53:40,080 --> 00:53:45,300
earlier move around and or or get freed

00:53:43,320 --> 00:53:47,850
or have something new be written there

00:53:45,300 --> 00:53:50,130
over time and then have that ruin the

00:53:47,850 --> 00:53:53,310
copy-on-write optimization and the

00:53:50,130 --> 00:53:57,060
answer is yes it's possible but what we

00:53:53,310 --> 00:53:59,460
did is all that all those objects that I

00:53:57,060 --> 00:54:01,530
showed you are immediately after rails

00:53:59,460 --> 00:54:05,160
boot so it's all just code that we've

00:54:01,530 --> 00:54:07,410
loaded in and initialization objects so

00:54:05,160 --> 00:54:09,480
those will likely not change so it

00:54:07,410 --> 00:54:11,570
should be long-lived long-lived objects

00:54:09,480 --> 00:54:13,620
but yes it's possible

00:54:11,570 --> 00:54:15,660
okay yeah I guess I just don't

00:54:13,620 --> 00:54:18,060
intuitively know like active record is

00:54:15,660 --> 00:54:19,980
in there just like messing everything up

00:54:18,060 --> 00:54:22,080
after you've loaded it and like you know

00:54:19,980 --> 00:54:23,580
messing around with with Singleton's and

00:54:22,080 --> 00:54:26,610
whatnot I didn't know how much it causes

00:54:23,580 --> 00:54:28,170
that something sure I know the code most

00:54:26,610 --> 00:54:31,350
we got most of the stuff that I showed

00:54:28,170 --> 00:54:35,880
there is just compiled Ruby code it'll

00:54:31,350 --> 00:54:37,620
never that stuff will never change if we

00:54:35,880 --> 00:54:39,240
were doing compaction later on like

00:54:37,620 --> 00:54:42,120
after each request or something like

00:54:39,240 --> 00:54:42,780
that yeah it would it would completely

00:54:42,120 --> 00:54:44,490
ruin it

00:54:42,780 --> 00:54:48,870
yeah okay I figured the answer was

00:54:44,490 --> 00:54:56,700
something like that thank you yeah all

00:54:48,870 --> 00:54:58,950
right okay hello hi thanks for that it

00:54:56,700 --> 00:55:01,740
was really good to see the internals of

00:54:58,950 --> 00:55:05,160
Ruby oh thank you a two-part question

00:55:01,740 --> 00:55:08,760
actually in the loop does it go through

00:55:05,160 --> 00:55:11,580
the entire or just a page so can you say

00:55:08,760 --> 00:55:14,460
that again you mentioned about the loop

00:55:11,580 --> 00:55:16,920
for compaction I go through the whole

00:55:14,460 --> 00:55:19,650
page or the whole heap it goes through

00:55:16,920 --> 00:55:23,730
the entire heap okay so is it possible

00:55:19,650 --> 00:55:25,070
that a pointer are moving the object you

00:55:23,730 --> 00:55:27,170
leave a pointer there

00:55:25,070 --> 00:55:28,850
that pointer itself could move later

00:55:27,170 --> 00:55:31,820
does that happen

00:55:28,850 --> 00:55:34,070
a pointer what do you mean so the way

00:55:31,820 --> 00:55:38,770
you are moving the object yeah can a

00:55:34,070 --> 00:55:38,770
pointer also move I is it even possible

00:55:38,800 --> 00:55:45,080
no I mean you can move so the object the

00:55:43,400 --> 00:55:48,530
object will get moved but after we've

00:55:45,080 --> 00:55:50,120
updated all the references then none of

00:55:48,530 --> 00:55:51,790
the none of the Ruby objects should

00:55:50,120 --> 00:55:57,020
reference pointers that aren't actual

00:55:51,790 --> 00:56:01,850
Ruby objects okay thanks mm-hmm yeah

00:55:57,020 --> 00:56:06,460
okay hello Aaron hello and how does an

00:56:01,850 --> 00:56:08,630
anomaly anonymous class act in this

00:56:06,460 --> 00:56:11,750
compacting is it going to stick around

00:56:08,630 --> 00:56:15,350
forever or is it going to be moved like

00:56:11,750 --> 00:56:17,660
a normal object all objects remove

00:56:15,350 --> 00:56:20,060
equally it doesn't delete I assign it to

00:56:17,660 --> 00:56:23,450
a glow to a constant like you can say I

00:56:20,060 --> 00:56:26,950
don't know a equals yep and it doesn't

00:56:23,450 --> 00:56:26,950
care okay great

00:56:29,400 --> 00:56:33,480
people hi Aaron you have thanks for

00:56:32,880 --> 00:56:36,240
sharing

00:56:33,480 --> 00:56:39,960
I just know you mentioned you go about

00:56:36,240 --> 00:56:43,020
2% for Team ideation right about the

00:56:39,960 --> 00:56:46,920
memory location Yeah right

00:56:43,020 --> 00:56:51,210
I have no idea how the computers are

00:56:46,920 --> 00:56:55,410
squeezed written but one thing that I am

00:56:51,210 --> 00:56:59,520
quite confused is a but you are trying

00:56:55,410 --> 00:57:04,860
to read the whole page right if there is

00:56:59,520 --> 00:57:11,280
no it you got the one I'm quite curious

00:57:04,860 --> 00:57:14,550
up the cosa allocation of the new object

00:57:11,280 --> 00:57:20,250
I might be faster than your composition

00:57:14,550 --> 00:57:24,510
script so I miss the John unable to free

00:57:20,250 --> 00:57:28,200
the whole pitch sure yeah yeah okay so

00:57:24,510 --> 00:57:29,880
the question is uh how does the how can

00:57:28,200 --> 00:57:33,900
the compactor keep up with allocation

00:57:29,880 --> 00:57:34,530
yes yes both new object yeah yeah that's

00:57:33,900 --> 00:57:37,590
a good question

00:57:34,530 --> 00:57:39,780
this right now it's it basically stops

00:57:37,590 --> 00:57:42,240
the world stop the world compactor and

00:57:39,780 --> 00:57:43,830
you have to actually call an object or

00:57:42,240 --> 00:57:46,410
you have to call a method called GT

00:57:43,830 --> 00:57:49,670
compact so we had to we modified our

00:57:46,410 --> 00:57:53,730
modified our boot process to say okay

00:57:49,670 --> 00:57:56,310
before before we actually listen for

00:57:53,730 --> 00:57:58,800
requests we compact everything and that

00:57:56,310 --> 00:58:01,980
pauses the process for maybe our

00:57:58,800 --> 00:58:03,840
particular heat it would pause the

00:58:01,980 --> 00:58:06,360
process for about 100 milliseconds and

00:58:03,840 --> 00:58:08,250
then continue on so it doesn't actually

00:58:06,360 --> 00:58:13,800
allow any allocations during the

00:58:08,250 --> 00:58:18,450
compaction favor all right cool okay

00:58:13,800 --> 00:58:25,380
there's one in the back isn't there's a

00:58:18,450 --> 00:58:25,890
mic there you can go to the mic yeah

00:58:25,380 --> 00:58:30,090
sorry

00:58:25,890 --> 00:58:32,190
well you may have a ye I will be managed

00:58:30,090 --> 00:58:34,920
memory as well system managed memory or

00:58:32,190 --> 00:58:37,380
me no I think so vehicle chamber why do

00:58:34,920 --> 00:58:39,330
we need to separate these two type of

00:58:37,380 --> 00:58:40,920
memory management White House will be

00:58:39,330 --> 00:58:44,220
managed to all memory in

00:58:40,920 --> 00:58:46,500
and also mention about the 40 kV sighs

00:58:44,220 --> 00:58:48,480
sure what can it be dynamic sure that's

00:58:46,500 --> 00:58:50,580
a good question so the question is why

00:58:48,480 --> 00:58:52,650
can't why can't Ruby manage all of the

00:58:50,580 --> 00:59:03,420
all the memory why do we have this 40

00:58:52,650 --> 00:59:07,230
byte 40 byte limit right so well the

00:59:03,420 --> 00:59:08,880
answer is that garbage GC alga GC

00:59:07,230 --> 00:59:12,510
algorithms are a lot easier when you

00:59:08,880 --> 00:59:14,940
have a fixed width fixed width slot so

00:59:12,510 --> 00:59:18,090
with a fixed width six with slot it's

00:59:14,940 --> 00:59:21,140
much easier to write a GC I think that's

00:59:18,090 --> 00:59:25,190
basically the origin of it we can have I

00:59:21,140 --> 00:59:25,190
don't think there's any particular

00:59:25,670 --> 00:59:30,300
limitation or reason why we couldn't

00:59:28,230 --> 00:59:32,280
store everything in Ruby's garbage

00:59:30,300 --> 00:59:34,260
collector essentially it's just that

00:59:32,280 --> 00:59:38,070
someone needs to do the work to

00:59:34,260 --> 00:59:40,110
implement that so if I had to guess the

00:59:38,070 --> 00:59:45,900
reason we have fixed with slots as

00:59:40,110 --> 00:59:49,440
historic reasons max maybe I yes he's

00:59:45,900 --> 00:59:57,780
not paying attention to places they go I

00:59:49,440 --> 00:59:58,440
will make that be the the answer thank

00:59:57,780 --> 01:00:02,730
you for the talk

00:59:58,440 --> 01:00:06,630
umm you say something about the red

01:00:02,730 --> 01:00:10,290
positive say the hash you can remove the

01:00:06,630 --> 01:00:13,860
location because the treat I see using

01:00:10,290 --> 01:00:18,200
such vectors we affect the way we write

01:00:13,860 --> 01:00:21,810
Cole let's say like having a lot of the

01:00:18,200 --> 01:00:25,320
object at hands and there's unmovable

01:00:21,810 --> 01:00:28,530
with actually affect the performance and

01:00:25,320 --> 01:00:31,800
therefore we may end the writing few has

01:00:28,530 --> 01:00:34,320
or the kind of stuff like you think we

01:00:31,800 --> 01:00:36,840
affect our way of writing code right

01:00:34,320 --> 01:00:39,360
right so the question is will the TV I

01:00:36,840 --> 01:00:40,830
guess is the behavior of the garbage

01:00:39,360 --> 01:00:42,300
collector or the implementation details

01:00:40,830 --> 01:00:45,230
of the garbage collector will that

01:00:42,300 --> 01:00:50,310
impact the way that we write code

01:00:45,230 --> 01:00:52,860
it shouldn't I don't think that it

01:00:50,310 --> 01:00:54,299
should impact it I think I think most of

01:00:52,860 --> 01:00:57,209
those red objects we can actually

01:00:54,299 --> 01:01:00,059
eliminate so I think that with a bit

01:00:57,209 --> 01:01:02,160
more development work we can reduce it

01:01:00,059 --> 01:01:06,029
such that the percentage of objects that

01:01:02,160 --> 01:01:09,989
can't be moved is very low and you would

01:01:06,029 --> 01:01:11,609
I mean it would be so low that there is

01:01:09,989 --> 01:01:14,910
no reason for you to know that it is

01:01:11,609 --> 01:01:19,079
even a thing so no I don't think it

01:01:14,910 --> 01:01:21,299
would have impact it okay thank you very

01:01:19,079 --> 01:01:21,770
much Evan thank you thank you for having

01:01:21,299 --> 01:01:26,550
me

01:01:21,770 --> 01:01:26,550

YouTube URL: https://www.youtube.com/watch?v=EPpWMoA6_Pc


