Title: Shitlist-driven development and other tricks for working on large codebases - RedDotRubyConf 2017
Publication date: 2020-01-22
Playlist: RedDotRuby 2017
Description: 
	Speaker: Florian Weingarten, Production Engineering Lead, Shopify

Working on large codebases is hard. Doing so with 700 people is even harder. Deploying it 50 times a day is almost impossible. We will look at productivity tricks and automations that we use at Shopify to get stuff done. We will learn how we fix the engine while the plane is running, how to quickly change code that lots of people depend on, how to automatically track down productivity killers like unreliable tests, how to maintain a level of agility that keeps developers happy and allows them to ship fast, and most importantly what the heck a "shitlist" is.

Speaker's Bio

Florian is originally from Germany, where he studied mathematics and computer science. Since moving to Canada, he is now working as Production Engineer at Shopify in Ottawa, spending most of his time on refactoring large Ruby on Rails codebases and thinking about scalability and performance problems.

Event Page: http://www.reddotrubyconf.com/

Produced by Engineers.SG

Help us caption & translate this video!

http://amara.org/v/8HYM/
Captions: 
	00:00:03,940 --> 00:00:10,219
yeah so first of all I want to apologize

00:00:08,210 --> 00:00:12,320
for the other swearing in the title um

00:00:10,219 --> 00:00:13,880
it was kind of like an internal name

00:00:12,320 --> 00:00:15,530
that we used and someone on my team said

00:00:13,880 --> 00:00:18,040
wouldn't be funny if you get the tour

00:00:15,530 --> 00:00:21,080
accepted through this in the title so I

00:00:18,040 --> 00:00:23,150
listened but so I'm going to talk about

00:00:21,080 --> 00:00:25,130
something that we call shitless driven

00:00:23,150 --> 00:00:28,430
development and I'm going to share some

00:00:25,130 --> 00:00:31,000
tricks about about how to work with

00:00:28,430 --> 00:00:33,350
which we really large code bases and

00:00:31,000 --> 00:00:36,050
it's not going to be too really specific

00:00:33,350 --> 00:00:38,660
but I think no matter which language you

00:00:36,050 --> 00:00:42,170
you work with hopefully you can find

00:00:38,660 --> 00:00:44,120
something useful he has the foreword for

00:00:42,170 --> 00:00:47,059
a load of context my work for Shopify

00:00:44,120 --> 00:00:50,000
which is a ecommerce software as a

00:00:47,059 --> 00:00:53,180
service platform headquartered in Canada

00:00:50,000 --> 00:00:54,770
and we are as far as I know one of the

00:00:53,180 --> 00:00:56,899
oldest and I think the largest ruby on

00:00:54,770 --> 00:00:59,539
rails core business in the world we've

00:00:56,899 --> 00:01:01,840
been using rails since version zero

00:00:59,539 --> 00:01:04,070
point something like over ten years ago

00:01:01,840 --> 00:01:08,240
and I think it's probably the biggest

00:01:04,070 --> 00:01:10,400
ruby company in Canada this is a Ottawa

00:01:08,240 --> 00:01:12,530
the capital of Canada and it's one of

00:01:10,400 --> 00:01:17,900
the buildings on the on the right is the

00:01:12,530 --> 00:01:20,750
Shopify headquarter and my job at

00:01:17,900 --> 00:01:22,729
Shopify is I basically work on one of

00:01:20,750 --> 00:01:24,920
the core architecture teams and a lot of

00:01:22,729 --> 00:01:27,619
my job looks like this so I I do a lot

00:01:24,920 --> 00:01:29,229
of very broad work very low level

00:01:27,619 --> 00:01:31,220
changes lots of maintenance work and

00:01:29,229 --> 00:01:34,159
lots of work that effects the entire

00:01:31,220 --> 00:01:39,229
application the entire platform and most

00:01:34,159 --> 00:01:41,869
of the most of the take tips and stuff

00:01:39,229 --> 00:01:46,340
that in this in this talk is coming from

00:01:41,869 --> 00:01:49,790
the contacts a little bit so Shopify is

00:01:46,340 --> 00:01:51,290
a is a monolithic rails application that

00:01:49,790 --> 00:01:53,149
doesn't mean that the the tip that I'm

00:01:51,290 --> 00:01:54,680
giving here can't be applied to like

00:01:53,149 --> 00:01:56,990
other code bases but just so you know

00:01:54,680 --> 00:02:01,130
this is where where this comes from but

00:01:56,990 --> 00:02:03,110
um so we we run a much tenant

00:02:01,130 --> 00:02:06,140
architecture which means that we we host

00:02:03,110 --> 00:02:08,299
people online stores and we have about

00:02:06,140 --> 00:02:09,380
more than 400,000 of those online stores

00:02:08,299 --> 00:02:11,420
and they're all running in the same

00:02:09,380 --> 00:02:13,340
education the same database the same

00:02:11,420 --> 00:02:15,500
the same deployment so it's not like

00:02:13,340 --> 00:02:16,640
multiple it's not like each shop has its

00:02:15,500 --> 00:02:20,870
own deployment but it's obviously an

00:02:16,640 --> 00:02:22,760
application and we do we do about twenty

00:02:20,870 --> 00:02:26,090
to forty thousand requests per second

00:02:22,760 --> 00:02:28,700
and our main github repository has about

00:02:26,090 --> 00:02:31,300
eight hundred contributors which

00:02:28,700 --> 00:02:33,800
includes developers designers and

00:02:31,300 --> 00:02:37,160
content strategists and documentation

00:02:33,800 --> 00:02:38,540
writers all that kind stuff and there's

00:02:37,160 --> 00:02:40,610
a whole bunch of problems that comes

00:02:38,540 --> 00:02:44,180
with you have so many people trying to

00:02:40,610 --> 00:02:47,030
change the same thing at at the same

00:02:44,180 --> 00:02:48,880
time and so quickly and so for all of

00:02:47,030 --> 00:02:51,769
those eight hundred contributors have

00:02:48,880 --> 00:02:53,930
information to merge changes to master

00:02:51,769 --> 00:02:57,530
they all have committed to deploy to

00:02:53,930 --> 00:02:59,180
production and we with the rate of

00:02:57,530 --> 00:03:01,459
change that we have right now we deploy

00:02:59,180 --> 00:03:03,320
about fifty times today and those fifty

00:03:01,459 --> 00:03:08,750
deploys are about 100 PR and fifty to a

00:03:03,320 --> 00:03:12,950
hundred peers a day and together that

00:03:08,750 --> 00:03:15,200
kind of amount of change every day gives

00:03:12,950 --> 00:03:17,390
you a bunch of interesting problems that

00:03:15,200 --> 00:03:21,739
you don't really run into with small

00:03:17,390 --> 00:03:27,860
applications but yeah it's a it's a

00:03:21,739 --> 00:03:30,410
challenge so I want to phrase this talk

00:03:27,860 --> 00:03:32,420
is from the perspective of productivity

00:03:30,410 --> 00:03:35,989
problems so I'm going to talk about

00:03:32,420 --> 00:03:38,989
three three important productivity

00:03:35,989 --> 00:03:41,530
problems that were that we were faced

00:03:38,989 --> 00:03:45,140
with and share some tips about how we

00:03:41,530 --> 00:03:48,230
how you work on them so the first one is

00:03:45,140 --> 00:03:49,790
deploy so if you have this many people

00:03:48,230 --> 00:03:51,500
working on the same code in the same

00:03:49,790 --> 00:03:52,880
application and they all want to deploy

00:03:51,500 --> 00:03:57,440
the deploys actually become a bottleneck

00:03:52,880 --> 00:03:59,690
and what I mean by that is first of all

00:03:57,440 --> 00:04:01,280
if you hire more people they want to

00:03:59,690 --> 00:04:02,750
ship more code and shipping more code

00:04:01,280 --> 00:04:04,820
means that you either need to deploy

00:04:02,750 --> 00:04:09,500
more often or you need to have bigger

00:04:04,820 --> 00:04:11,359
deploys so one of the two and four for

00:04:09,500 --> 00:04:14,239
several reasons smaller deploys are

00:04:11,359 --> 00:04:15,920
often better so a few obvious ones is

00:04:14,239 --> 00:04:18,109
that that fewer changes are often easier

00:04:15,920 --> 00:04:20,209
to to debuggers save how you're changing

00:04:18,109 --> 00:04:21,209
less code at the same time it's easier

00:04:20,209 --> 00:04:24,539
to roll

00:04:21,209 --> 00:04:26,220
I guess easier to to revert and easier

00:04:24,539 --> 00:04:29,100
to keep an overview of what's happening

00:04:26,220 --> 00:04:30,720
so from from that perspective we we

00:04:29,100 --> 00:04:35,819
wanted multipliers and not bigger ones

00:04:30,720 --> 00:04:37,710
so now the important observation is that

00:04:35,819 --> 00:04:39,569
if you want small deployer and we want

00:04:37,710 --> 00:04:43,620
to declare often you need to you need to

00:04:39,569 --> 00:04:46,160
deploy to be fast so as an example I

00:04:43,620 --> 00:04:48,419
said we deploy about fifty times to be

00:04:46,160 --> 00:04:50,250
most of our developers on the same time

00:04:48,419 --> 00:04:52,650
zone so that means about six deploys per

00:04:50,250 --> 00:04:53,970
business hour and if those deploys take

00:04:52,650 --> 00:04:55,560
longer than ten minutes then they become

00:04:53,970 --> 00:04:57,690
a serious productivity problem for us

00:04:55,560 --> 00:05:00,500
because we can't ship the code as fast

00:04:57,690 --> 00:05:02,820
as we want to and that means we can't

00:05:00,500 --> 00:05:05,570
you know can't develop features as

00:05:02,820 --> 00:05:05,570
likely as we want to

00:05:09,669 --> 00:05:16,820
so what do we what do we do about it so

00:05:15,200 --> 00:05:18,530
first of all when I say when I said

00:05:16,820 --> 00:05:20,630
employee I don't I don't only mean

00:05:18,530 --> 00:05:23,540
getting the code into production but I

00:05:20,630 --> 00:05:27,350
mean the entire pipeline that comes with

00:05:23,540 --> 00:05:29,030
that so building if you use docker for

00:05:27,350 --> 00:05:31,760
example building a CI container running

00:05:29,030 --> 00:05:33,110
running your tests on CI building the

00:05:31,760 --> 00:05:35,419
production container uploading the

00:05:33,110 --> 00:05:37,250
production container to wherever you

00:05:35,419 --> 00:05:38,750
have to upload it to like get it on the

00:05:37,250 --> 00:05:40,760
server restart all of those containers

00:05:38,750 --> 00:05:42,530
to make sure everything is successful so

00:05:40,760 --> 00:05:48,229
when I say deploy I really mean this

00:05:42,530 --> 00:05:51,440
entire sequence of steps so an obvious

00:05:48,229 --> 00:05:53,090
one is if you have Seattle's you should

00:05:51,440 --> 00:05:54,320
paralyze them so if you have two people

00:05:53,090 --> 00:05:55,940
who want to ship something at the same

00:05:54,320 --> 00:05:58,190
time you shouldn't run this the average

00:05:55,940 --> 00:06:00,110
one after another but also it's the same

00:05:58,190 --> 00:06:03,169
person has multiple tests you can easily

00:06:00,110 --> 00:06:05,990
run the tests in parallel so that one is

00:06:03,169 --> 00:06:07,280
pretty obvious another one that is that

00:06:05,990 --> 00:06:09,320
was super helpful for as I said you

00:06:07,280 --> 00:06:14,450
should build those containers in advance

00:06:09,320 --> 00:06:16,580
so before I said we have about 50

00:06:14,450 --> 00:06:19,430
deploys but about 100 PRS that means

00:06:16,580 --> 00:06:23,210
some deploys contain more than one PR so

00:06:19,430 --> 00:06:24,919
if we build those production containers

00:06:23,210 --> 00:06:26,660
for every merge to master that means we

00:06:24,919 --> 00:06:29,090
build a lot of containers that actually

00:06:26,660 --> 00:06:32,539
never get deployed but the advantage of

00:06:29,090 --> 00:06:33,800
that is that if that container wants to

00:06:32,539 --> 00:06:36,320
if someone wants to deploy that

00:06:33,800 --> 00:06:39,639
container then it is already ready and

00:06:36,320 --> 00:06:39,639
we don't have to build it in that moment

00:06:40,090 --> 00:06:46,850
another really big improvement that we

00:06:42,260 --> 00:06:48,860
had is during the container build we

00:06:46,850 --> 00:06:50,660
would have often involve different rake

00:06:48,860 --> 00:06:52,100
tasks and so on and each of those rake

00:06:50,660 --> 00:06:54,860
tasks would often put the rails

00:06:52,100 --> 00:06:57,229
application and if your rate application

00:06:54,860 --> 00:06:59,600
is this big booting just just running a

00:06:57,229 --> 00:07:01,190
rake task just booting loading the rails

00:06:59,600 --> 00:07:02,479
environment before you can even start

00:07:01,190 --> 00:07:05,120
doing or start running your real-time

00:07:02,479 --> 00:07:07,789
rake tasks often takes up to 10 seconds

00:07:05,120 --> 00:07:09,470
or so so finding a way to combine all of

00:07:07,789 --> 00:07:13,970
those and so you only have to put it

00:07:09,470 --> 00:07:15,260
once was a huge speed up for us deploy

00:07:13,970 --> 00:07:17,090
297 parallel it

00:07:15,260 --> 00:07:18,800
you don't want to do one server at a

00:07:17,090 --> 00:07:24,710
time if you have an application of this

00:07:18,800 --> 00:07:26,540
side and now if you if you look at all

00:07:24,710 --> 00:07:28,220
those different steps or building

00:07:26,540 --> 00:07:30,740
containers running tests building the

00:07:28,220 --> 00:07:32,060
production container restarting the

00:07:30,740 --> 00:07:34,670
applications all of those require

00:07:32,060 --> 00:07:36,830
booting the application so if you find a

00:07:34,670 --> 00:07:38,660
way to reduce the time it takes to boot

00:07:36,830 --> 00:07:41,240
your application that has a huge impact

00:07:38,660 --> 00:07:44,240
and different in many different areas so

00:07:41,240 --> 00:07:46,490
there was a really big improvement and

00:07:44,240 --> 00:07:48,470
then the last one that is a little bit

00:07:46,490 --> 00:07:50,570
overlooked is how long does it take to

00:07:48,470 --> 00:07:53,630
shut down your application so especially

00:07:50,570 --> 00:07:55,730
if you're running a web application and

00:07:53,630 --> 00:07:58,370
you using jewnicorn there's a standard

00:07:55,730 --> 00:08:00,230
timeout value that says how long is a

00:07:58,370 --> 00:08:02,780
request allowed to run and if you want

00:08:00,230 --> 00:08:04,490
to deploy you have to you either have to

00:08:02,780 --> 00:08:05,690
terminate those requests which gonna

00:08:04,490 --> 00:08:07,580
lead to errors or you have to wait for

00:08:05,690 --> 00:08:09,170
them to finish and if you wait for them

00:08:07,580 --> 00:08:10,910
to finish that means you deploy is going

00:08:09,170 --> 00:08:15,470
to take at least as long as it takes for

00:08:10,910 --> 00:08:18,110
that to happen so doing whatever you can

00:08:15,470 --> 00:08:19,820
to make sure you have as little long

00:08:18,110 --> 00:08:22,220
running requests as possible and I have

00:08:19,820 --> 00:08:26,270
a huge impact on the speed at which you

00:08:22,220 --> 00:08:28,400
can deploy the other bottleneck related

00:08:26,270 --> 00:08:31,160
to deploy as a human so there's a couple

00:08:28,400 --> 00:08:32,690
of steps that you can totally get away

00:08:31,160 --> 00:08:35,030
with at a smaller company or a smaller

00:08:32,690 --> 00:08:36,580
codebase smaller project but if you want

00:08:35,030 --> 00:08:40,550
to deploy a hundred times a day then

00:08:36,580 --> 00:08:42,530
that's not going to work anymore so one

00:08:40,550 --> 00:08:44,330
example is smaller companies often have

00:08:42,530 --> 00:08:47,360
an ops team and the ops team is allowed

00:08:44,330 --> 00:08:49,670
to deploy but Italy has 800 people and

00:08:47,360 --> 00:08:51,230
they all want to deploy if all of them

00:08:49,670 --> 00:08:55,370
have to ask the ops team to deploy that

00:08:51,230 --> 00:08:58,340
doesn't work so you need to allow people

00:08:55,370 --> 00:09:01,070
to deploy on their own so another thing

00:08:58,340 --> 00:09:02,380
asking having someone that decides now's

00:09:01,070 --> 00:09:05,600
a good time to deploy doesn't they're

00:09:02,380 --> 00:09:08,750
asking everyone to pay attention to the

00:09:05,600 --> 00:09:09,950
status of mass sei doesn't care asking

00:09:08,750 --> 00:09:12,440
everyone to pay attention to errors

00:09:09,950 --> 00:09:14,750
doing a deploy so having everyone watch

00:09:12,440 --> 00:09:17,930
the deploy to see whether they pay that

00:09:14,750 --> 00:09:20,390
doesn't scare as many people and at the

00:09:17,930 --> 00:09:21,890
end even even ask them even even saying

00:09:20,390 --> 00:09:23,480
hey every developer can deploy

00:09:21,890 --> 00:09:26,540
themselves even that doesn't scale at

00:09:23,480 --> 00:09:27,140
the point so in summary humans don't

00:09:26,540 --> 00:09:28,910
care

00:09:27,140 --> 00:09:33,350
and you should automate this process as

00:09:28,910 --> 00:09:36,230
much as you can so to illustrate i want

00:09:33,350 --> 00:09:37,399
to show you the tool that we use but

00:09:36,230 --> 00:09:38,779
there's nothing really special about

00:09:37,399 --> 00:09:40,610
this tool you can easily write your own

00:09:38,779 --> 00:09:42,260
at the point that I'm trying to make is

00:09:40,610 --> 00:09:44,240
that you should have some kind of tool

00:09:42,260 --> 00:09:48,740
and that tool should not be human trivia

00:09:44,240 --> 00:09:50,209
and software so this is our deploy

00:09:48,740 --> 00:09:52,190
software called Shiva that open source

00:09:50,209 --> 00:09:54,230
if you want you you can use it or you

00:09:52,190 --> 00:09:57,200
can give some ideas and write your own

00:09:54,230 --> 00:09:59,750
but a few important parts here is that

00:09:57,200 --> 00:10:02,360
here for example you can see it's

00:09:59,750 --> 00:10:05,720
waiting for CI and as soon as those

00:10:02,360 --> 00:10:08,300
tests are passing we automatically

00:10:05,720 --> 00:10:10,240
deploy this and there's no human that

00:10:08,300 --> 00:10:13,850
has to press a button or nobody has to

00:10:10,240 --> 00:10:17,000
say it's okay to deploy now so basically

00:10:13,850 --> 00:10:18,980
we expect people if they emerge to

00:10:17,000 --> 00:10:23,060
master that basically means this is good

00:10:18,980 --> 00:10:25,550
to get employed another big one that we

00:10:23,060 --> 00:10:29,390
often have is that people make mistakes

00:10:25,550 --> 00:10:30,680
so you merge something and then you you

00:10:29,390 --> 00:10:32,779
you figure out or something was wrong I

00:10:30,680 --> 00:10:35,779
need to revert it and then we often had

00:10:32,779 --> 00:10:38,240
problems where people had to manually

00:10:35,779 --> 00:10:40,459
keep an eye on oh this can't get

00:10:38,240 --> 00:10:41,930
deployed so reverted then lock the

00:10:40,459 --> 00:10:43,220
deployers make sure the first one

00:10:41,930 --> 00:10:43,640
doesn't go out without the second one

00:10:43,220 --> 00:10:46,370
and so on

00:10:43,640 --> 00:10:49,820
so automating this in software is really

00:10:46,370 --> 00:10:51,500
was really on taking away some of the

00:10:49,820 --> 00:10:53,959
human interaction from this process

00:10:51,500 --> 00:10:57,380
right so this feature for example here

00:10:53,959 --> 00:10:58,820
says if there is a revert for the commit

00:10:57,380 --> 00:11:00,459
that hasn't been deployed that in then

00:10:58,820 --> 00:11:03,260
nothing in that range can get deployed

00:11:00,459 --> 00:11:04,610
and then if something passes the eye

00:11:03,260 --> 00:11:10,640
after that it's going to get deployed

00:11:04,610 --> 00:11:12,949
automatically another thing that you can

00:11:10,640 --> 00:11:16,850
automate is telling people that their

00:11:12,949 --> 00:11:19,490
code is not being deployed so if you if

00:11:16,850 --> 00:11:20,540
you deploy stuff automatically it's

00:11:19,490 --> 00:11:22,790
still important that people know that

00:11:20,540 --> 00:11:26,269
their changes are going out so we have a

00:11:22,790 --> 00:11:29,209
wave attack channel with waking where

00:11:26,269 --> 00:11:32,779
people get notifications to see that the

00:11:29,209 --> 00:11:34,970
code is going out and another another

00:11:32,779 --> 00:11:36,500
important thing is that we don't we

00:11:34,970 --> 00:11:38,990
don't want people to merge too many

00:11:36,500 --> 00:11:40,910
commits into master so we don't we don't

00:11:38,990 --> 00:11:43,250
want the commits to pile up so if

00:11:40,910 --> 00:11:45,020
there's a large backlog of stuff that

00:11:43,250 --> 00:11:49,459
hasn't been deployed yet we want people

00:11:45,020 --> 00:11:50,870
to wait and so on a smaller application

00:11:49,459 --> 00:11:52,190
it's okay if someone keeps an eye on

00:11:50,870 --> 00:11:54,199
that and then pokes the people and say

00:11:52,190 --> 00:11:55,220
hey don't do this but if you have if you

00:11:54,199 --> 00:11:57,980
have a lot of people and if the

00:11:55,220 --> 00:12:01,040
application gets really big then this

00:11:57,980 --> 00:12:03,140
kind of like educating people is also

00:12:01,040 --> 00:12:05,180
something that you can automate so in

00:12:03,140 --> 00:12:08,000
our case if someone does is if someone

00:12:05,180 --> 00:12:09,860
merges to Mars a while

00:12:08,000 --> 00:12:11,180
sea ice failing or wires a lot of

00:12:09,860 --> 00:12:12,860
commits that haven't been deployed yet

00:12:11,180 --> 00:12:15,230
those people also couldn't get in the

00:12:12,860 --> 00:12:20,420
notification saying on you shouldn't do

00:12:15,230 --> 00:12:22,459
that this one is really interesting I

00:12:20,420 --> 00:12:25,790
thought because it's a little water

00:12:22,459 --> 00:12:27,800
roundabout or like yeah is it I would

00:12:25,790 --> 00:12:31,279
say it's a workaround for a missing

00:12:27,800 --> 00:12:33,140
feature and github I think where if you

00:12:31,279 --> 00:12:36,380
if merging two master basically means

00:12:33,140 --> 00:12:38,120
it's going to get deployed then that

00:12:36,380 --> 00:12:40,339
also becomes a bit of a bottleneck so

00:12:38,120 --> 00:12:43,490
well the workflow that we actually use

00:12:40,339 --> 00:12:46,519
is we have a browser extension that at

00:12:43,490 --> 00:12:49,279
inject this button here into the gate of

00:12:46,519 --> 00:12:51,050
UI and people don't actually merge their

00:12:49,279 --> 00:12:53,329
peers they just say this is ready to be

00:12:51,050 --> 00:12:56,000
merged and then later a boss comes on

00:12:53,329 --> 00:12:57,260
merged for you when some heuristic

00:12:56,000 --> 00:13:01,160
decides that now is a good time to

00:12:57,260 --> 00:13:02,810
deploy this so this means people can say

00:13:01,160 --> 00:13:04,279
ok this is ready and then they can move

00:13:02,810 --> 00:13:07,010
on and work on the next peer I don't

00:13:04,279 --> 00:13:08,560
have to basically the developers the

00:13:07,010 --> 00:13:12,319
humans themselves I don't have to

00:13:08,560 --> 00:13:15,220
orchestrate this whole deploy process

00:13:12,319 --> 00:13:18,220
but it's another step that that we

00:13:15,220 --> 00:13:18,220
automated

00:13:22,899 --> 00:13:29,180
okay so the the next problem I want to

00:13:26,149 --> 00:13:31,490
talk about is we have the name of my

00:13:29,180 --> 00:13:34,009
Tyler comes upon for the the

00:13:31,490 --> 00:13:36,949
presentation title and that the problem

00:13:34,009 --> 00:13:40,399
is basically that how do you deal with

00:13:36,949 --> 00:13:43,129
deprecations so especially if you work

00:13:40,399 --> 00:13:45,019
on a very low level like a team like the

00:13:43,129 --> 00:13:45,769
one I'm working on where you do a lot of

00:13:45,019 --> 00:13:48,230
framework

00:13:45,769 --> 00:13:50,269
changes a lot of stuff that effect not

00:13:48,230 --> 00:13:52,879
only a certain feature but the entire

00:13:50,269 --> 00:13:54,259
application then you often or for

00:13:52,879 --> 00:13:55,759
example the team that it's responsible

00:13:54,259 --> 00:13:58,309
for upgrading to a new rails version and

00:13:55,759 --> 00:14:00,649
that kind of stuff so basically if you

00:13:58,309 --> 00:14:03,920
if you have an API an internal API that

00:14:00,649 --> 00:14:07,790
is being used by a lot of code and your

00:14:03,920 --> 00:14:09,920
job is to migrate from the from the old

00:14:07,790 --> 00:14:12,499
way to do it to the new one so the way

00:14:09,920 --> 00:14:15,439
that rails solves this internally is

00:14:12,499 --> 00:14:17,990
with active support deprecation notices

00:14:15,439 --> 00:14:19,819
and that's basically logging and

00:14:17,990 --> 00:14:22,670
everybody be expand with those log

00:14:19,819 --> 00:14:25,160
output and you just have to hope that

00:14:22,670 --> 00:14:26,600
people will fix it but the reality is

00:14:25,160 --> 00:14:28,519
people will not fix it because nobody

00:14:26,600 --> 00:14:29,569
feels responsible for those errors if

00:14:28,519 --> 00:14:33,319
you have eight hundred eight hundred

00:14:29,569 --> 00:14:36,290
people working on the application so

00:14:33,319 --> 00:14:38,089
basically the idea is you go and fix all

00:14:36,290 --> 00:14:40,699
of those methods to use a new one and

00:14:38,089 --> 00:14:42,110
now everything is fixed but the problem

00:14:40,699 --> 00:14:44,059
is that in the meantime while you get

00:14:42,110 --> 00:14:48,019
that someone else might have added a new

00:14:44,059 --> 00:14:50,629
um a new class that also does it wrong

00:14:48,019 --> 00:14:53,059
or someone if you do B first and then

00:14:50,629 --> 00:14:55,069
you do see after you finish see someone

00:14:53,059 --> 00:14:57,620
might have unfixed B and the wrong again

00:14:55,069 --> 00:14:58,819
and it's really it gets really annoying

00:14:57,620 --> 00:15:01,220
if you have a lot of people and you try

00:14:58,819 --> 00:15:05,480
to make very low-level changes you would

00:15:01,220 --> 00:15:06,829
step on your toes all the time so what

00:15:05,480 --> 00:15:12,529
else can you do after that is better

00:15:06,829 --> 00:15:14,389
than log on so you can try to send an

00:15:12,529 --> 00:15:16,610
email and say hey don't do this or you

00:15:14,389 --> 00:15:18,949
can send a slack announcement basically

00:15:16,610 --> 00:15:20,990
tell everyone use the new method not the

00:15:18,949 --> 00:15:22,370
old one and that might work if they have

00:15:20,990 --> 00:15:25,220
five people in people in your team but

00:15:22,370 --> 00:15:26,600
if you have 800 and new people get

00:15:25,220 --> 00:15:28,819
higher all the time and the oak people

00:15:26,600 --> 00:15:30,949
forget it or maybe they don't care or

00:15:28,819 --> 00:15:32,870
for all kinds of reasons this doesn't

00:15:30,949 --> 00:15:36,600
really work so

00:15:32,870 --> 00:15:38,370
the idea is that the idea that we had is

00:15:36,600 --> 00:15:40,050
we we need to find a way to automate

00:15:38,370 --> 00:15:43,740
this we need to find a way to educate

00:15:40,050 --> 00:15:46,830
people what is the right behavior and do

00:15:43,740 --> 00:15:48,720
this education by by code by enforcing

00:15:46,830 --> 00:15:51,000
certain rules but without pissing

00:15:48,720 --> 00:15:56,420
everyone off and without everyone having

00:15:51,000 --> 00:15:59,580
to come to us and ask for help so the

00:15:56,420 --> 00:16:01,110
the the other extreme that you can do is

00:15:59,580 --> 00:16:03,150
you can you can basically raised in the

00:16:01,110 --> 00:16:05,730
old method and say this you can't use it

00:16:03,150 --> 00:16:07,560
anymore then you run your tests fix all

00:16:05,730 --> 00:16:10,200
the tests and then you know everything's

00:16:07,560 --> 00:16:11,700
good but if you run hundreds of

00:16:10,200 --> 00:16:15,330
thousands of tests and you have a lot of

00:16:11,700 --> 00:16:16,590
code then you can't really um you're

00:16:15,330 --> 00:16:22,170
basically forced to make all those

00:16:16,590 --> 00:16:23,940
changes in one PR and if you ship 100 PS

00:16:22,170 --> 00:16:25,740
every day then this is definitely going

00:16:23,940 --> 00:16:27,980
to cause much conflict and all that kind

00:16:25,740 --> 00:16:30,480
of stuff so you want to find a way to

00:16:27,980 --> 00:16:34,140
fix those things one after the other

00:16:30,480 --> 00:16:36,900
ideally like tiny slices 1 PR per change

00:16:34,140 --> 00:16:41,730
or something like that but without

00:16:36,900 --> 00:16:43,320
people being able to undo your work so

00:16:41,730 --> 00:16:45,840
the idea is basically if we have two

00:16:43,320 --> 00:16:50,120
classes that both do it wrong VNC can we

00:16:45,840 --> 00:16:53,340
say can we fix B so that if someone

00:16:50,120 --> 00:16:55,920
basically are basically can we whitelist

00:16:53,340 --> 00:16:58,050
some of those users without allowing

00:16:55,920 --> 00:17:00,540
people to add new ones and that that is

00:16:58,050 --> 00:17:01,350
an idea that we jokingly internally

00:17:00,540 --> 00:17:04,170
called the list

00:17:01,350 --> 00:17:07,200
so a shitless is basically a list of

00:17:04,170 --> 00:17:10,020
things that is already shitty so stuff

00:17:07,200 --> 00:17:11,250
that is doing it wrong and that's

00:17:10,020 --> 00:17:12,690
basically a whitelist all of those

00:17:11,250 --> 00:17:15,660
people are allowed to do it wrong but

00:17:12,690 --> 00:17:18,440
you can't add new stuff to it so for a

00:17:15,660 --> 00:17:20,610
second just assume here that the

00:17:18,440 --> 00:17:22,920
deprecated method knows who called it

00:17:20,610 --> 00:17:26,010
that that's one of the important ideas

00:17:22,920 --> 00:17:27,180
and if if that method knows who called

00:17:26,010 --> 00:17:30,690
it you can do something like this way

00:17:27,180 --> 00:17:33,090
you say it's the college either B or C

00:17:30,690 --> 00:17:34,620
then those who are ok because they been

00:17:33,090 --> 00:17:38,130
around forever and we are working on

00:17:34,620 --> 00:17:39,690
those but nobody can add new ones and

00:17:38,130 --> 00:17:42,510
now you can go and you can fix the

00:17:39,690 --> 00:17:45,539
removed from the list and now this

00:17:42,510 --> 00:17:47,190
one is still allowed this one is 6

00:17:45,539 --> 00:17:53,940
nobody can accidentally unfix it and

00:17:47,190 --> 00:17:55,049
also nobody can add new staff so the

00:17:53,940 --> 00:17:58,590
problem with this approach is a little

00:17:55,049 --> 00:18:00,720
bit that I kind of assumed that I was

00:17:58,590 --> 00:18:02,879
able to change the method that I want to

00:18:00,720 --> 00:18:04,799
defecate but that method might be in a

00:18:02,879 --> 00:18:07,049
gem or it might be in rails or it might

00:18:04,799 --> 00:18:09,210
be you know somewhere that outside of

00:18:07,049 --> 00:18:10,710
your control or maybe you don't want to

00:18:09,210 --> 00:18:14,629
go through all of those classes and

00:18:10,710 --> 00:18:16,679
change the parameters everywhere so

00:18:14,629 --> 00:18:19,940
maybe maybe the level of granularity

00:18:16,679 --> 00:18:22,320
that you want to maybe instead of saying

00:18:19,940 --> 00:18:24,479
B and C are allowed to call this maybe

00:18:22,320 --> 00:18:26,190
you want to say the shop model and the

00:18:24,479 --> 00:18:28,019
customer model are illogical is but not

00:18:26,190 --> 00:18:31,259
check out models or you want to say

00:18:28,019 --> 00:18:32,729
maybe the internal web requests are

00:18:31,259 --> 00:18:35,700
allowed but not the external ones or

00:18:32,729 --> 00:18:37,399
maybe the background jobs are allowed to

00:18:35,700 --> 00:18:39,989
do it and not the web requests so

00:18:37,399 --> 00:18:43,349
there's different granularities that you

00:18:39,989 --> 00:18:44,940
might want and basically the key to how

00:18:43,349 --> 00:18:49,259
do you implement this granularity is how

00:18:44,940 --> 00:18:52,979
do you how do you figure out who called

00:18:49,259 --> 00:18:56,099
it so and something simple that you can

00:18:52,979 --> 00:18:58,409
do is you can you can come up with with

00:18:56,099 --> 00:19:01,019
an annotation basically if you locate at

00:18:58,409 --> 00:19:03,989
the bottom we have a controller or a job

00:19:01,019 --> 00:19:06,539
and those jobs basically register

00:19:03,989 --> 00:19:09,570
themselves to the list basically

00:19:06,539 --> 00:19:12,299
with a what I call context here so it

00:19:09,570 --> 00:19:14,820
says the context that the code is now

00:19:12,299 --> 00:19:18,210
running in is the shitty controller foo

00:19:14,820 --> 00:19:21,559
method or the shitty job and then the

00:19:18,210 --> 00:19:23,399
 list itself can say this is allow

00:19:21,559 --> 00:19:25,859
this dish should raise an exception

00:19:23,399 --> 00:19:29,359
unless it's coming from the shitty job

00:19:25,859 --> 00:19:32,129
and then basically the workflow is

00:19:29,359 --> 00:19:34,200
first-year what your whitelist you're

00:19:32,129 --> 00:19:35,669
allowed constant here is empty you run

00:19:34,200 --> 00:19:37,919
your test you put everything in there

00:19:35,669 --> 00:19:39,210
that fails the test that one P added you

00:19:37,919 --> 00:19:41,070
can ship and now you're confident that

00:19:39,210 --> 00:19:45,080
nobody can add any X identity add any

00:19:41,070 --> 00:19:47,669
new and then your task is now

00:19:45,080 --> 00:19:49,409
basically remove one item from this list

00:19:47,669 --> 00:19:51,599
see which tests fail fix all of them

00:19:49,409 --> 00:19:55,130
move on to the next one and this is

00:19:51,599 --> 00:19:57,950
really great for for

00:19:55,130 --> 00:20:01,310
are generating to-do lists or basically

00:19:57,950 --> 00:20:03,320
giving your team approach that progress

00:20:01,310 --> 00:20:04,550
indicator because you can you can see

00:20:03,320 --> 00:20:06,620
how this list is getting smaller and

00:20:04,550 --> 00:20:08,210
smaller every day it's super awesome for

00:20:06,620 --> 00:20:08,930
motivation because people feel like

00:20:08,210 --> 00:20:11,150
they're making progress

00:20:08,930 --> 00:20:15,070
eggless is getting smaller and it's much

00:20:11,150 --> 00:20:17,150
more measurable than a lot full of

00:20:15,070 --> 00:20:26,750
deprecation spam that nobody is going to

00:20:17,150 --> 00:20:30,020
look at yeah so ya miss it so to

00:20:26,750 --> 00:20:31,940
summaries the to summarize this is in

00:20:30,020 --> 00:20:33,470
our experience very valuable if your

00:20:31,940 --> 00:20:35,390
nicotine is very broad behavior if

00:20:33,470 --> 00:20:37,520
you're maintaining some kind of internal

00:20:35,390 --> 00:20:40,850
API if you need to break down a huge

00:20:37,520 --> 00:20:42,970
task into small chunks this is help for

00:20:40,850 --> 00:20:45,230
my team has always become the go-to tool

00:20:42,970 --> 00:20:48,710
it's awesome for generating to-do lists

00:20:45,230 --> 00:20:51,620
for having a something to just work

00:20:48,710 --> 00:20:54,320
through and it's also often to educate

00:20:51,620 --> 00:20:56,750
your team about how you want them to

00:20:54,320 --> 00:20:58,010
write code and how you want them to what

00:20:56,750 --> 00:20:59,660
kind of methods you want them to use in

00:20:58,010 --> 00:21:03,020
which kinds of methods you want them to

00:20:59,660 --> 00:21:05,960
stay away from and this education

00:21:03,020 --> 00:21:07,580
happens at a medic code level so you

00:21:05,960 --> 00:21:09,860
don't have to talk to all those humans

00:21:07,580 --> 00:21:12,230
but you just make good error messages

00:21:09,860 --> 00:21:14,570
and the error message should then

00:21:12,230 --> 00:21:19,340
explain what is what are you what you

00:21:14,570 --> 00:21:21,140
want from people so as an example if you

00:21:19,340 --> 00:21:24,080
have certain certain behavior that you

00:21:21,140 --> 00:21:26,390
want to deprecate the error message

00:21:24,080 --> 00:21:29,000
should explain what are you doing wrong

00:21:26,390 --> 00:21:31,310
why is it wrong it was working yesterday

00:21:29,000 --> 00:21:33,080
ago eisenhower on how can I fix it who

00:21:31,310 --> 00:21:36,620
can I talk to if I if I don't know how

00:21:33,080 --> 00:21:40,640
to fix it and basically the an error

00:21:36,620 --> 00:21:43,370
message like this via code is enforces

00:21:40,640 --> 00:21:46,910
good best practices for whatever it is

00:21:43,370 --> 00:21:49,090
that you want to does you want people to

00:21:46,910 --> 00:21:49,090
do

00:21:53,400 --> 00:21:57,850
okay so the the third problem that I

00:21:56,740 --> 00:22:01,960
want to talk about is the problem

00:21:57,850 --> 00:22:04,000
unreliability head so this one might not

00:22:01,960 --> 00:22:06,250
be such a big deal if you are working

00:22:04,000 --> 00:22:07,630
more like a service-oriented

00:22:06,250 --> 00:22:09,070
architecture but if you aren't working

00:22:07,630 --> 00:22:11,140
on the monolithic grades education then

00:22:09,070 --> 00:22:16,060
this can get really really annoying

00:22:11,140 --> 00:22:18,850
really quickly so the interesting thing

00:22:16,060 --> 00:22:20,230
is that there is a there's a I mean most

00:22:18,850 --> 00:22:22,320
people probably know what the what the

00:22:20,230 --> 00:22:25,150
problem is with us when I say unreliable

00:22:22,320 --> 00:22:27,010
unreliable tests but they're not

00:22:25,150 --> 00:22:29,290
annoying enough to really force you to

00:22:27,010 --> 00:22:30,460
do something about it but if the more

00:22:29,290 --> 00:22:32,820
tests you have the more people you have

00:22:30,460 --> 00:22:35,290
and so on those problems become really

00:22:32,820 --> 00:22:37,930
not just likely but actually common so

00:22:35,290 --> 00:22:40,210
if I say when I say unreliable test I

00:22:37,930 --> 00:22:41,920
mean I mean a test that sometimes passes

00:22:40,210 --> 00:22:45,160
sometimes fails without you making any

00:22:41,920 --> 00:22:49,840
changes to the code and for some context

00:22:45,160 --> 00:22:51,640
we run about 750ti bills per day that's

00:22:49,840 --> 00:22:54,070
ten minutes each and about 70,000 tests

00:22:51,640 --> 00:22:56,980
and it's only a single one of those

00:22:54,070 --> 00:22:59,380
70,000 tests is unreliable and fails 1%

00:22:56,980 --> 00:23:00,820
of the time randomly then we lose over

00:22:59,380 --> 00:23:03,100
one hour of productivity per day and

00:23:00,820 --> 00:23:05,800
this is the those numbers are based on

00:23:03,100 --> 00:23:07,780
the assumption that those tests are

00:23:05,800 --> 00:23:09,730
running on your branch so that one hour

00:23:07,780 --> 00:23:11,560
of productivity for one person if you

00:23:09,730 --> 00:23:13,360
apply this to master where the failing

00:23:11,560 --> 00:23:19,900
test effects way more people then this

00:23:13,360 --> 00:23:21,880
is even worse so there's two common

00:23:19,900 --> 00:23:24,640
types of unreliable tests that I want to

00:23:21,880 --> 00:23:27,700
talk about one is the flaky test so

00:23:24,640 --> 00:23:29,320
that's the the one that is easy to spot

00:23:27,700 --> 00:23:31,330
easy to debug it's just a test that you

00:23:29,320 --> 00:23:34,480
you see all the time sometimes it fails

00:23:31,330 --> 00:23:38,200
sometimes it doesn't often that is time

00:23:34,480 --> 00:23:39,550
dependent so maybe you have like a

00:23:38,200 --> 00:23:41,470
couple lines in your code and if there's

00:23:39,550 --> 00:23:43,150
more than a second in between sometimes

00:23:41,470 --> 00:23:45,880
then calculation doesn't match anymore

00:23:43,150 --> 00:23:47,620
or maybe the test only fails if your STI

00:23:45,880 --> 00:23:48,850
systems under load because something is

00:23:47,620 --> 00:23:51,550
out of memory or

00:23:48,850 --> 00:23:55,180
that kind of stuff and the second

00:23:51,550 --> 00:23:57,700
category is way more sneaky because the

00:23:55,180 --> 00:23:58,540
test that is the problem is actually not

00:23:57,700 --> 00:24:01,180
the one that is failing

00:23:58,540 --> 00:24:03,610
so those tests are Auto dependent so you

00:24:01,180 --> 00:24:05,720
might have a test a that fails only if a

00:24:03,610 --> 00:24:10,880
source has B that fails only

00:24:05,720 --> 00:24:12,770
a ring before and yeah tracking down

00:24:10,880 --> 00:24:15,890
those tests and fixing them is going to

00:24:12,770 --> 00:24:18,590
be super important because yeah they can

00:24:15,890 --> 00:24:21,610
be a huge productivity tailor for for

00:24:18,590 --> 00:24:24,910
your team so how do you check them back

00:24:21,610 --> 00:24:27,500
so a lot of people probably know about

00:24:24,910 --> 00:24:29,630
software like box neck which is an

00:24:27,500 --> 00:24:31,520
exception tracking software that allows

00:24:29,630 --> 00:24:32,630
you to use in production so every time

00:24:31,520 --> 00:24:34,280
that happens an exception in your

00:24:32,630 --> 00:24:35,900
production system you lock that

00:24:34,280 --> 00:24:38,030
exception somewhere and you get like

00:24:35,900 --> 00:24:40,850
data and all those features and all kind

00:24:38,030 --> 00:24:46,280
of stuff I thought this was really cool

00:24:40,850 --> 00:24:47,480
an interesting idea to not only use this

00:24:46,280 --> 00:24:47,810
in production but only use it for your

00:24:47,480 --> 00:24:49,820
test

00:24:47,810 --> 00:24:51,440
so every time a test fails and how is

00:24:49,820 --> 00:24:53,840
the AI system we actually report it as

00:24:51,440 --> 00:24:55,340
an exception and then we can we can use

00:24:53,840 --> 00:24:57,680
all of those data and all of the

00:24:55,340 --> 00:24:59,000
features on those test failures and you

00:24:57,680 --> 00:25:01,070
get all kinds of cool stuff where you

00:24:59,000 --> 00:25:04,300
can see when did the state test start

00:25:01,070 --> 00:25:07,370
failing which PR might have caused it or

00:25:04,300 --> 00:25:09,890
you even get like alerting you can say

00:25:07,370 --> 00:25:11,300
if a certain test fails more than five

00:25:09,890 --> 00:25:13,610
days in a row or something like that you

00:25:11,300 --> 00:25:16,120
can notify someone or pindy also

00:25:13,610 --> 00:25:20,450
automatically and that kind of stuff so

00:25:16,120 --> 00:25:22,010
as for most problems the very first step

00:25:20,450 --> 00:25:23,360
here to fixing the problems that you

00:25:22,010 --> 00:25:25,790
need the visibility first so you need

00:25:23,360 --> 00:25:27,650
you need to figure out what is actually

00:25:25,790 --> 00:25:29,270
wrong how bad is it how often does it

00:25:27,650 --> 00:25:31,570
happen how many people are affected and

00:25:29,270 --> 00:25:31,570
so on

00:25:31,940 --> 00:25:39,380
yeah so after you've identified which

00:25:34,670 --> 00:25:43,750
tests are problematic how do we fix them

00:25:39,380 --> 00:25:46,130
so with the the first kind of flaky test

00:25:43,750 --> 00:25:48,260
that's the test that sometimes fails and

00:25:46,130 --> 00:25:51,980
sometimes passes if you have a suspicion

00:25:48,260 --> 00:25:53,120
that this test might be flaky obviously

00:25:51,980 --> 00:25:55,460
you want to you want to confirm if

00:25:53,120 --> 00:25:56,780
that's actually the case for you what we

00:25:55,460 --> 00:25:59,360
do is we have a little script on them

00:25:56,780 --> 00:26:01,490
that runs on our TI system and those

00:25:59,360 --> 00:26:03,140
little green and red boxes here each box

00:26:01,490 --> 00:26:05,600
is one container that we run in parallel

00:26:03,140 --> 00:26:07,640
each container runs that's one single

00:26:05,600 --> 00:26:10,600
test in isolation a thousand times so

00:26:07,640 --> 00:26:13,670
here we basically run the same test

00:26:10,600 --> 00:26:15,560
64,000 times and if it looks like this

00:26:13,670 --> 00:26:16,740
it is giving sometimes it's a it's

00:26:15,560 --> 00:26:18,780
undergoing passes

00:26:16,740 --> 00:26:23,520
you have confirmation that our this test

00:26:18,780 --> 00:26:25,350
is actually a problem the other one that

00:26:23,520 --> 00:26:29,730
it's a little bit Nakia a little bit

00:26:25,350 --> 00:26:33,450
harder to debug is the leaky test so if

00:26:29,730 --> 00:26:36,300
you if you're not super familiar with

00:26:33,450 --> 00:26:39,270
how testing frameworks like mini unit s

00:26:36,300 --> 00:26:41,700
or r-spec work I found it to be

00:26:39,270 --> 00:26:43,200
confusing at first when I was first

00:26:41,700 --> 00:26:46,530
learning about test-driven development

00:26:43,200 --> 00:26:47,880
is that it doesn't actually create a new

00:26:46,530 --> 00:26:49,470
process for each test but it runs

00:26:47,880 --> 00:26:53,190
multiple tests in the same process and

00:26:49,470 --> 00:26:56,250
that means if those tests by mistake

00:26:53,190 --> 00:26:57,870
somehow mutate local state those that

00:26:56,250 --> 00:26:59,490
that mutation is still visible in the

00:26:57,870 --> 00:27:01,830
next test so it's possible that those

00:26:59,490 --> 00:27:04,410
tests affect each other and a leaky test

00:27:01,830 --> 00:27:08,309
is a test that makes another test fail

00:27:04,410 --> 00:27:11,370
by modifying global State and a really

00:27:08,309 --> 00:27:13,260
great way to find those tests is using

00:27:11,370 --> 00:27:15,720
binary search so what you do is

00:27:13,260 --> 00:27:17,700
basically you you look into your

00:27:15,720 --> 00:27:19,260
monitoring that I had before and you

00:27:17,700 --> 00:27:20,700
look at the list of tests that ran and

00:27:19,260 --> 00:27:23,760
the last one is going to be the one that

00:27:20,700 --> 00:27:25,050
failed but as I said that the one that

00:27:23,760 --> 00:27:26,550
fail is not actually the problem the

00:27:25,050 --> 00:27:28,410
problem is one of the tests that ran

00:27:26,550 --> 00:27:30,240
before it because one of those costs the

00:27:28,410 --> 00:27:32,820
last time to fail so you take that list

00:27:30,240 --> 00:27:35,900
and you divide it by half you run the

00:27:32,820 --> 00:27:38,970
first half and then the failing test and

00:27:35,900 --> 00:27:40,410
if it fails again you know the

00:27:38,970 --> 00:27:42,960
problematic test needs to be in that

00:27:40,410 --> 00:27:45,710
half if it doesn't fail it into the

00:27:42,960 --> 00:27:47,580
second half and then you repeat this and

00:27:45,710 --> 00:27:50,040
repeatedly cut through the list and

00:27:47,580 --> 00:27:51,809
basically perform a binary search

00:27:50,040 --> 00:27:53,040
through the list of candidates and then

00:27:51,809 --> 00:27:56,520
the tool that we have at the very end

00:27:53,040 --> 00:27:58,290
says if it does identify a leaking test

00:27:56,520 --> 00:28:01,020
then it says this how you can reproduce

00:27:58,290 --> 00:28:02,700
it locally here's your leaky test and

00:28:01,020 --> 00:28:05,760
the test that fails because of a leaky

00:28:02,700 --> 00:28:09,720
test and then on yeah you can basically

00:28:05,760 --> 00:28:12,210
track it down this way so putting all

00:28:09,720 --> 00:28:14,010
those pieces together what we do is we

00:28:12,210 --> 00:28:15,600
have this automatic monitoring it's a

00:28:14,010 --> 00:28:18,410
test fails too often or for too many

00:28:15,600 --> 00:28:22,620
days in a row you can automatically

00:28:18,410 --> 00:28:24,090
confirm is it leaky is it flaky ping the

00:28:22,620 --> 00:28:27,210
author of the test say hey this is a

00:28:24,090 --> 00:28:30,179
problem just fix it

00:28:27,210 --> 00:28:36,179
when this is super valuable for for

00:28:30,179 --> 00:28:38,639
productivity okay so quick summary at

00:28:36,179 --> 00:28:41,489
the end um I talked about three problems

00:28:38,639 --> 00:28:42,690
the first one is deploys so if your

00:28:41,489 --> 00:28:43,739
application gets really big and if you

00:28:42,690 --> 00:28:46,649
have a lot of people and you want to

00:28:43,739 --> 00:28:49,349
ship a lot of code the one of the really

00:28:46,649 --> 00:28:51,629
important things you can do is make sure

00:28:49,349 --> 00:28:53,039
you deploy a really fast because if they

00:28:51,629 --> 00:28:54,960
are fast you can deploy more often and

00:28:53,039 --> 00:29:00,779
you can deploy smaller which is safer

00:28:54,960 --> 00:29:02,369
and yeah so besides making the path also

00:29:00,779 --> 00:29:06,109
automate them make sure there's a little

00:29:02,369 --> 00:29:06,109
human involvement as possible

00:29:06,229 --> 00:29:10,589
problem two that I talked about was what

00:29:09,239 --> 00:29:11,700
I call too many cooks in the kitchen so

00:29:10,589 --> 00:29:14,460
you have too many people trying to

00:29:11,700 --> 00:29:16,139
change the same thing or stepping on

00:29:14,460 --> 00:29:19,249
each other's toes or accidentally I'm

00:29:16,139 --> 00:29:21,809
doing each other's work and so on and

00:29:19,249 --> 00:29:23,460
what I would like you to encourage us

00:29:21,809 --> 00:29:26,489
try this approach of shiftless driven

00:29:23,460 --> 00:29:29,249
development which is basically a fancier

00:29:26,489 --> 00:29:31,559
version of deprecation warrant where you

00:29:29,249 --> 00:29:34,229
know once you fix one one in it's

00:29:31,559 --> 00:29:36,179
impossible to add new ones or am-6 that

00:29:34,229 --> 00:29:38,460
one and the last one that I talked about

00:29:36,179 --> 00:29:39,599
unreliable and reliable test the

00:29:38,460 --> 00:29:41,909
important thing that I want you to take

00:29:39,599 --> 00:29:43,469
away from this is that you can actually

00:29:41,909 --> 00:29:45,239
use a lot of your production monitoring

00:29:43,469 --> 00:29:50,489
tools for your tests and you can get a

00:29:45,239 --> 00:29:54,599
lot of insight out of that and using the

00:29:50,489 --> 00:29:58,820
binary search approach to a plank leaky

00:29:54,599 --> 00:29:58,820
test is really um really powerful

00:30:05,109 --> 00:30:10,700
okay so we show on times with the state

00:30:08,179 --> 00:30:14,299
exactly two questions okay so yeah he

00:30:10,700 --> 00:30:21,590
was good I'm really glad I was sitting

00:30:14,299 --> 00:30:23,509
close to you so my question is I've seen

00:30:21,590 --> 00:30:25,789
a lot of really powerful internal tools

00:30:23,509 --> 00:30:27,710
here and some of them I think the

00:30:25,789 --> 00:30:29,509
underlying philosophies are applicable

00:30:27,710 --> 00:30:31,970
about across code bases that the

00:30:29,509 --> 00:30:34,389
specific tools might not be so I'd love

00:30:31,970 --> 00:30:36,859
to talk you to talk about Shopify's

00:30:34,389 --> 00:30:40,730
decision-making process for what is

00:30:36,859 --> 00:30:42,109
important to build here you know you

00:30:40,730 --> 00:30:45,470
mean which important to a certain point

00:30:42,109 --> 00:30:47,779
I like yeah which which internal tools

00:30:45,470 --> 00:30:50,149
are important to build how that how you

00:30:47,779 --> 00:30:54,039
can make internal tools that fit with

00:30:50,149 --> 00:30:54,039
the grain of your process effectively

00:30:54,249 --> 00:31:00,139
description I would say the ones that

00:30:58,039 --> 00:31:01,519
affect the most people the ones that

00:31:00,139 --> 00:31:03,519
have the most impact across the company

00:31:01,519 --> 00:31:06,259
are probably the most important one so

00:31:03,519 --> 00:31:11,929
for us the test stuff that I talked

00:31:06,259 --> 00:31:13,340
about was um SS more often as it more

00:31:11,929 --> 00:31:16,159
often you want to deploy the more

00:31:13,340 --> 00:31:17,899
annoying it gets if there's unreliable

00:31:16,159 --> 00:31:20,059
tests so that was one where we thought

00:31:17,899 --> 00:31:22,190
well is affecting 500 people and if

00:31:20,059 --> 00:31:24,350
this is if it has too many safety tests

00:31:22,190 --> 00:31:26,090
then there's 500 people who can't get

00:31:24,350 --> 00:31:28,129
any work done so that was a good

00:31:26,090 --> 00:31:31,850
candidate for something that we need to

00:31:28,129 --> 00:31:34,659
work on I don't know that that onto the

00:31:31,850 --> 00:31:37,009
person yeah thank you

00:31:34,659 --> 00:31:42,830
okay great let's try and get someone

00:31:37,009 --> 00:31:46,039
from the other side of the audience okay

00:31:42,830 --> 00:31:49,279
um hi so first of all it's a very

00:31:46,039 --> 00:31:53,029
interesting stop and I have a question

00:31:49,279 --> 00:31:56,080
and the subject of unstable test because

00:31:53,029 --> 00:31:59,840
I've also had my share of you know

00:31:56,080 --> 00:32:02,869
that's it suddenly break one day so can

00:31:59,840 --> 00:32:07,399
you share your experience on you know

00:32:02,869 --> 00:32:12,009
the most annoying and difficult unstable

00:32:07,399 --> 00:32:12,009
test statistics and how did you fix the

00:32:12,270 --> 00:32:19,470
in my experience the safety tests are

00:32:15,600 --> 00:32:21,750
usually pretty easy to to identify and

00:32:19,470 --> 00:32:23,220
usually pretty easy to fix as well the

00:32:21,750 --> 00:32:25,290
the really annoying ones other geeky

00:32:23,220 --> 00:32:26,430
ones where the test that is failing is

00:32:25,290 --> 00:32:30,000
actually not the test that is the

00:32:26,430 --> 00:32:34,290
problem and stuff that I've seen a lot

00:32:30,000 --> 00:32:37,380
is so so often the problem is cause I

00:32:34,290 --> 00:32:39,510
state that it's being modified in one

00:32:37,380 --> 00:32:42,450
test and then some other test somehow is

00:32:39,510 --> 00:32:45,750
affected by that and something that I

00:32:42,450 --> 00:32:48,090
see a lot of stuff related to caching so

00:32:45,750 --> 00:32:49,860
someone was trying to be smart and catch

00:32:48,090 --> 00:32:53,280
something like a global variable or

00:32:49,860 --> 00:32:57,870
often like related to Rails autoloading

00:32:53,280 --> 00:33:00,060
where the first test costs a certain

00:32:57,870 --> 00:33:02,130
class or a certain constant to be auto

00:33:00,060 --> 00:33:03,660
loaded and then the second test behaves

00:33:02,130 --> 00:33:07,110
differently because of that that is

00:33:03,660 --> 00:33:13,910
often really annoying there's a lot of

00:33:07,110 --> 00:33:15,900
very annoying details about how

00:33:13,910 --> 00:33:18,690
transactional fixtures for example work

00:33:15,900 --> 00:33:20,370
in rails like the one thing that a lot

00:33:18,690 --> 00:33:24,360
of people seem to run into a chopper is

00:33:20,370 --> 00:33:25,740
that if if your test makes a table

00:33:24,360 --> 00:33:29,360
modification like an alter table

00:33:25,740 --> 00:33:31,500
statement to add a column for example

00:33:29,360 --> 00:33:33,750
those statements for example actually

00:33:31,500 --> 00:33:36,300
cause the database commit which means

00:33:33,750 --> 00:33:39,260
the test does not correctly rollback the

00:33:36,300 --> 00:33:41,940
changes and all those kind of really

00:33:39,260 --> 00:33:43,020
intricate details that most people don't

00:33:41,940 --> 00:33:44,520
know about and they shouldn't need to

00:33:43,020 --> 00:33:46,140
know about it but they affect your test

00:33:44,520 --> 00:33:51,210
like those are in my experience really

00:33:46,140 --> 00:33:52,840
annoying thank you all right cool thank

00:33:51,210 --> 00:33:56,780
you very much Florian

00:33:52,840 --> 00:33:56,780

YouTube URL: https://www.youtube.com/watch?v=20pj_ajDBOg


