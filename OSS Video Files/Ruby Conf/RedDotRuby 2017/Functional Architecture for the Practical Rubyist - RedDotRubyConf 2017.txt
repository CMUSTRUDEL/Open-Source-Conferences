Title: Functional Architecture for the Practical Rubyist - RedDotRubyConf 2017
Publication date: 2020-01-22
Playlist: RedDotRuby 2017
Description: 
	Speaker: Tim Riley, Partner and Developer, Icelab

We build our Ruby apps with the best of intentions, but it's all too easy for them to become tangled and hard to maintain. If you've reached for object-oriented design principles as your path forward, and found them elusive or hard to apply, there is still hope! It turns out that some of our best OO code may live behind an FP curtain. Come along and discover how a functional architecture can make your Ruby apps not only SOLID, but a real joy to build, test, and extend.

Speaker's Bio

Tim Riley is a partner at Australian design agency Icelab, and a core developer of dry-rb. He's excited by small libraries, first-class functions, and pushing forward web app development with Ruby.

Event Page: http://www.reddotrubyconf.com/

Produced by Engineers.SG

Help us caption & translate this video!

http://amara.org/v/8HYV/
Captions: 
	00:00:04,620 --> 00:00:11,620
all right hello everyone

00:00:07,960 --> 00:00:14,139
I'm Tim commuter sweet from Australia or

00:00:11,620 --> 00:00:16,840
I work for a company called ice lab and

00:00:14,139 --> 00:00:20,650
I'm also a core developer in the dry

00:00:16,840 --> 00:00:23,140
bein Rama B Ruby projects and it's

00:00:20,650 --> 00:00:24,910
really great to be back in Singapore we

00:00:23,140 --> 00:00:27,699
love this city it's a great weather

00:00:24,910 --> 00:00:29,769
great food and thanks it is my whole

00:00:27,699 --> 00:00:30,970
family this is us here we're here for

00:00:29,769 --> 00:00:34,090
last year's conference we had a great

00:00:30,970 --> 00:00:36,719
time our daughter was 1 and my wife was

00:00:34,090 --> 00:00:38,739
pregnant and here we are now back again

00:00:36,719 --> 00:00:41,829
my daughter first daughter is 2 years

00:00:38,739 --> 00:00:43,329
old second one seven months and I was

00:00:41,829 --> 00:00:44,920
thinking about this and I'm actually

00:00:43,329 --> 00:00:46,540
scared about what might happen if I come

00:00:44,920 --> 00:00:48,370
back next year

00:00:46,540 --> 00:00:52,840
we have space right angle keeps in the

00:00:48,370 --> 00:00:53,980
family and onto the technical things I'm

00:00:52,840 --> 00:00:56,590
sorry to say I've got nothing to add to

00:00:53,980 --> 00:00:58,870
matters comments about every end or JIT

00:00:56,590 --> 00:01:01,660
compilers except to say that I'm glad he

00:00:58,870 --> 00:01:03,210
is taking care of it I'm here today to

00:01:01,660 --> 00:01:05,710
talk about something a bit different

00:01:03,210 --> 00:01:07,479
building applications with review and I

00:01:05,710 --> 00:01:10,270
want to talk about a big shift in the

00:01:07,479 --> 00:01:13,869
way I've been writing rubia I want to

00:01:10,270 --> 00:01:14,920
talk about functional architecture and I

00:01:13,869 --> 00:01:16,840
wouldn't start our journey into

00:01:14,920 --> 00:01:20,530
functional architecture strangely enough

00:01:16,840 --> 00:01:22,119
with object-oriented design that's that

00:01:20,530 --> 00:01:23,140
thing we should all aspire to as

00:01:22,119 --> 00:01:25,659
rubyists right

00:01:23,140 --> 00:01:28,210
we had these object-oriented design

00:01:25,659 --> 00:01:29,950
principles like solid to guide us and we

00:01:28,210 --> 00:01:31,330
know these things are important and that

00:01:29,950 --> 00:01:33,009
they should influence the way we write

00:01:31,330 --> 00:01:35,950
our code we've been hearing this for

00:01:33,009 --> 00:01:37,150
years and myself I'd watch talks about

00:01:35,950 --> 00:01:39,520
these things too and I say to myself

00:01:37,150 --> 00:01:43,000
yeah this is how I should write my code

00:01:39,520 --> 00:01:44,740
and then I'd go back to whatever I was

00:01:43,000 --> 00:01:48,310
working on and quite frankly it was a

00:01:44,740 --> 00:01:50,320
mess by comparison and I think my

00:01:48,310 --> 00:01:53,710
problem was that in my mind I tend to

00:01:50,320 --> 00:01:55,479
opt for pragmatism over design and I'd

00:01:53,710 --> 00:01:57,640
reassure myself and I'd say this

00:01:55,479 --> 00:01:59,950
situation is ok I'm a practical

00:01:57,640 --> 00:02:03,670
developer I've got work to do what

00:01:59,950 --> 00:02:05,170
architecture but not surprisingly the

00:02:03,670 --> 00:02:07,180
longer I worked in these apps the harder

00:02:05,170 --> 00:02:09,369
and harder they became to change and

00:02:07,180 --> 00:02:11,980
that's really the point of architecture

00:02:09,369 --> 00:02:14,020
and design that applied to code these

00:02:11,980 --> 00:02:16,600
things aim to make change easy

00:02:14,020 --> 00:02:19,720
and a well-designed codebase it should

00:02:16,600 --> 00:02:21,250
stand the test of time and we can see

00:02:19,720 --> 00:02:24,220
these things illustrated through martin

00:02:21,250 --> 00:02:26,170
fowler's design stamina hypothesis we

00:02:24,220 --> 00:02:29,170
can lay it out on a chart on the bottom

00:02:26,170 --> 00:02:31,960
axis we have time on the Left we have

00:02:29,170 --> 00:02:33,160
features built and then if we start an

00:02:31,960 --> 00:02:35,260
app without paying much attention to

00:02:33,160 --> 00:02:37,750
design we may get a really nice initial

00:02:35,260 --> 00:02:39,730
spike in features but over time that

00:02:37,750 --> 00:02:42,060
curve kind of leveled off as it becomes

00:02:39,730 --> 00:02:44,290
harder and harder to build new things

00:02:42,060 --> 00:02:45,490
but on the other hand if we pay a bit

00:02:44,290 --> 00:02:47,230
more attention upfront to some good

00:02:45,490 --> 00:02:49,090
design approaches well there might be a

00:02:47,230 --> 00:02:50,650
bit of a slower ramp up but over time we

00:02:49,090 --> 00:02:53,380
get this really steady ability to add

00:02:50,650 --> 00:02:55,150
new features so we see here we have this

00:02:53,380 --> 00:02:57,550
line between them this design payoff

00:02:55,150 --> 00:02:59,080
line and I think my problem was I spend

00:02:57,550 --> 00:03:00,850
too much time thinking about the bottom

00:02:59,080 --> 00:03:02,050
left of that chart when really I should

00:03:00,850 --> 00:03:04,750
have been thinking about all the space

00:03:02,050 --> 00:03:06,820
above that line there and I think this

00:03:04,750 --> 00:03:08,980
is a mindset that's perhaps endemic in

00:03:06,820 --> 00:03:11,440
our community in general because we

00:03:08,980 --> 00:03:16,330
found our fame in enabling those

00:03:11,440 --> 00:03:18,610
early-stage productivity wins my problem

00:03:16,330 --> 00:03:20,530
was also that I wasn't comprehensively

00:03:18,610 --> 00:03:23,050
applying better designs of my

00:03:20,530 --> 00:03:25,030
applications some band-aid approaches

00:03:23,050 --> 00:03:27,760
here and there they might help but

00:03:25,030 --> 00:03:29,950
they're really not just enough and since

00:03:27,760 --> 00:03:33,070
our job as developers is to deal with

00:03:29,950 --> 00:03:35,020
change and given the truth that we can't

00:03:33,070 --> 00:03:38,110
always predict where change will come

00:03:35,020 --> 00:03:40,560
from what we want ideally is a good

00:03:38,110 --> 00:03:44,440
design that covers our in their entirety

00:03:40,560 --> 00:03:48,000
so that's why I'm here today so everyone

00:03:44,440 --> 00:03:51,600
stand back about something to say

00:03:48,000 --> 00:03:54,490
functional programming will save us well

00:03:51,600 --> 00:03:56,680
maybe not quite like that this is the

00:03:54,490 --> 00:03:58,060
Ruby conference after all and I know

00:03:56,680 --> 00:04:00,430
many of us 20 were different languages

00:03:58,060 --> 00:04:02,260
but I can still consider myself happy

00:04:00,430 --> 00:04:04,600
with Ruby and a practical rubyist and

00:04:02,260 --> 00:04:06,730
likely Ruby itself is a practical

00:04:04,600 --> 00:04:08,740
malleable language and it's going to

00:04:06,730 --> 00:04:11,620
allow us to model things nicely along

00:04:08,740 --> 00:04:13,780
functional lines - the first step

00:04:11,620 --> 00:04:16,120
towards a functional architecture is a

00:04:13,780 --> 00:04:18,299
change in mindset it's about viewing

00:04:16,120 --> 00:04:21,790
your app as a series of transformations

00:04:18,299 --> 00:04:23,410
we did our initial data HTTP request for

00:04:21,790 --> 00:04:25,000
example and then we can run that through

00:04:23,410 --> 00:04:27,400
a number of transformative steps with

00:04:25,000 --> 00:04:30,509
each one passing some data to the next

00:04:27,400 --> 00:04:33,729
until at the other end we get some HTML

00:04:30,509 --> 00:04:36,430
so in another light an app model is a

00:04:33,729 --> 00:04:38,880
series of transformations is really an

00:04:36,430 --> 00:04:41,169
app model is a series of functions and

00:04:38,880 --> 00:04:43,990
this is where we get to the functional

00:04:41,169 --> 00:04:45,940
part of functional architecture we can

00:04:43,990 --> 00:04:48,039
model these functions nicely in Ruby as

00:04:45,940 --> 00:04:50,889
functional objects let's take a look at

00:04:48,039 --> 00:04:52,690
one now so for exit our example today

00:04:50,889 --> 00:04:55,060
we're going to be making an import

00:04:52,690 --> 00:04:57,370
products class say we're building some

00:04:55,060 --> 00:04:59,199
kind of online store we use something

00:04:57,370 --> 00:05:01,630
like this to populate our M product

00:04:59,199 --> 00:05:04,120
database from some third party feed of

00:05:01,630 --> 00:05:05,979
products and even in this clewd right

00:05:04,120 --> 00:05:08,500
here we see the first quality of a

00:05:05,979 --> 00:05:11,979
functional object usually we can name

00:05:08,500 --> 00:05:13,840
them by word and then it has a call

00:05:11,979 --> 00:05:16,630
method just like Ruby's own language

00:05:13,840 --> 00:05:17,949
level procs occasionally we might want a

00:05:16,630 --> 00:05:22,240
few more methods at most of the time

00:05:17,949 --> 00:05:25,539
call it enough that call method accepts

00:05:22,240 --> 00:05:28,000
an input goes to work on it and return

00:05:25,539 --> 00:05:29,800
some output now during the lifetime of

00:05:28,000 --> 00:05:31,360
that method it shouldn't mutate the

00:05:29,800 --> 00:05:34,300
state of the object and it shouldn't

00:05:31,360 --> 00:05:36,280
mutate the input data so this is one of

00:05:34,300 --> 00:05:38,289
our big departures from a classical

00:05:36,280 --> 00:05:40,990
object-oriented design approach our

00:05:38,289 --> 00:05:44,320
functional objects separate data from

00:05:40,990 --> 00:05:47,710
behavior let me keep that data anywhere

00:05:44,320 --> 00:05:49,539
in their own state before we go any

00:05:47,710 --> 00:05:51,400
further let's actually take a quick look

00:05:49,539 --> 00:05:54,669
at what this method will actually need

00:05:51,400 --> 00:05:56,380
to do the first thing it will do is get

00:05:54,669 --> 00:05:59,650
a list of product records by downloading

00:05:56,380 --> 00:06:01,449
that feed and then it will work with a

00:05:59,650 --> 00:06:02,680
products repository and we'll loop

00:06:01,449 --> 00:06:04,630
through to the products and create a

00:06:02,680 --> 00:06:07,210
record for each one in our own database

00:06:04,630 --> 00:06:09,370
now is it pretty clear and simple method

00:06:07,210 --> 00:06:11,340
to read and that's because it delegates

00:06:09,370 --> 00:06:13,720
a lot of its work to some dependencies

00:06:11,340 --> 00:06:15,669
these are what allow us to break down

00:06:13,720 --> 00:06:18,849
our application into smaller more

00:06:15,669 --> 00:06:21,669
useable objects here those dependencies

00:06:18,849 --> 00:06:25,360
again we have download feed and we have

00:06:21,669 --> 00:06:27,280
a products repository and from here we

00:06:25,360 --> 00:06:29,440
can see the next trait of a functional

00:06:27,280 --> 00:06:31,840
object those dependencies are passed in

00:06:29,440 --> 00:06:34,120
by the initialized method and then we

00:06:31,840 --> 00:06:35,770
capture them in the object state and

00:06:34,120 --> 00:06:37,360
once these are set they never need to

00:06:35,770 --> 00:06:38,990
change and what you're seeing here

00:06:37,360 --> 00:06:40,460
really is constructed appendixes

00:06:38,990 --> 00:06:42,110
it's one of those classical

00:06:40,460 --> 00:06:43,310
object-oriented design techniques and it

00:06:42,110 --> 00:06:46,100
works great with these functional

00:06:43,310 --> 00:06:47,620
objects so the end result is that we can

00:06:46,100 --> 00:06:50,960
initialize this object just once and

00:06:47,620 --> 00:06:52,460
call it many times over and once it's

00:06:50,960 --> 00:06:54,500
constructed if you then go on any passed

00:06:52,460 --> 00:06:57,860
around to become the dependency of other

00:06:54,500 --> 00:06:59,990
objects too now you might be thinking

00:06:57,860 --> 00:07:01,880
what we've seen so far is really just

00:06:59,990 --> 00:07:03,740
one of those service objects that we

00:07:01,880 --> 00:07:05,840
occasionally sprinkle around our apps

00:07:03,740 --> 00:07:08,150
where we see hotspots of complexity it

00:07:05,840 --> 00:07:10,730
and you'd be right this is one of those

00:07:08,150 --> 00:07:13,130
things but what I'm proposing is that we

00:07:10,730 --> 00:07:14,900
use this approach to build out the

00:07:13,130 --> 00:07:17,120
entirety of our applications

00:07:14,900 --> 00:07:20,240
functionality because we want that

00:07:17,120 --> 00:07:21,980
comprehensive design approach so all of

00:07:20,240 --> 00:07:26,360
that crud that we used to building well

00:07:21,980 --> 00:07:27,680
they can be functional objects too so

00:07:26,360 --> 00:07:31,430
that's how we take care of the behavior

00:07:27,680 --> 00:07:33,830
side of things what about data how do we

00:07:31,430 --> 00:07:36,380
handle that we can do that courtesy of

00:07:33,830 --> 00:07:37,910
types and this is ruby of course so

00:07:36,380 --> 00:07:39,770
they're not going to be the capital T

00:07:37,910 --> 00:07:41,930
types that we might expect another

00:07:39,770 --> 00:07:42,980
functional programming languages instead

00:07:41,930 --> 00:07:46,940
what I'm really talking about is

00:07:42,980 --> 00:07:48,200
modeling these as value objects what is

00:07:46,940 --> 00:07:50,180
the value object it's just something

00:07:48,200 --> 00:07:51,830
that holds a particular structure of

00:07:50,180 --> 00:07:53,690
data that's unique to our business

00:07:51,830 --> 00:07:55,370
domain and then once we have these

00:07:53,690 --> 00:07:57,260
objects created we should treat them as

00:07:55,370 --> 00:08:00,260
immutable once they're initialized their

00:07:57,260 --> 00:08:01,760
state should never changed to and of

00:08:00,260 --> 00:08:04,100
course we can add behavior to these

00:08:01,760 --> 00:08:06,140
objects in classical object owners style

00:08:04,100 --> 00:08:08,480
with extra methods working with the

00:08:06,140 --> 00:08:10,340
values we already have and the nice

00:08:08,480 --> 00:08:12,560
thing about these being simple value

00:08:10,340 --> 00:08:14,600
objects is that we can then easily pass

00:08:12,560 --> 00:08:16,820
them around all of our system and not

00:08:14,600 --> 00:08:18,440
have to worry about unexpected mutations

00:08:16,820 --> 00:08:21,800
or any sort of behavioral side effects

00:08:18,440 --> 00:08:24,020
along the way and in this way the value

00:08:21,800 --> 00:08:26,060
objects become first-class objects

00:08:24,020 --> 00:08:28,430
within our system all about functional

00:08:26,060 --> 00:08:32,840
objects can depend upon and work with

00:08:28,430 --> 00:08:35,330
these structures so in a ruby app built

00:08:32,840 --> 00:08:36,440
with this style objects tend to break

00:08:35,330 --> 00:08:40,730
down into these two different things

00:08:36,440 --> 00:08:43,670
values and functions our values hold

00:08:40,730 --> 00:08:47,300
data and those functions operate on the

00:08:43,670 --> 00:08:48,380
data our values are inert they're

00:08:47,300 --> 00:08:50,510
passive

00:08:48,380 --> 00:08:53,720
but the functions they're active they go

00:08:50,510 --> 00:08:56,660
to work on those values and if the

00:08:53,720 --> 00:08:58,370
values are the content in our system the

00:08:56,660 --> 00:09:00,860
functions form the pipeline through

00:08:58,370 --> 00:09:04,280
which the content flows in order for us

00:09:00,860 --> 00:09:09,470
to achieve some kind of outcome so

00:09:04,280 --> 00:09:12,560
that's the breakdown values work out to

00:09:09,470 --> 00:09:13,640
be pretty typical of the dieted code but

00:09:12,560 --> 00:09:15,530
let's take a closer look at those

00:09:13,640 --> 00:09:18,700
functions if we built an app around them

00:09:15,530 --> 00:09:20,420
how does that design approach measure up

00:09:18,700 --> 00:09:21,920
well I think first thing we should

00:09:20,420 --> 00:09:23,390
acknowledge that with Ruby being

00:09:21,920 --> 00:09:26,210
grounded in the object-oriented world

00:09:23,390 --> 00:09:27,800
and with just using objects to model our

00:09:26,210 --> 00:09:29,210
functions we should acknowledge that

00:09:27,800 --> 00:09:30,680
what we're doing here is really more a

00:09:29,210 --> 00:09:32,720
blend of functional programming and

00:09:30,680 --> 00:09:34,490
object-oriented programming so with this

00:09:32,720 --> 00:09:35,710
in mind let's see how we measure up to

00:09:34,490 --> 00:09:38,720
some of those long-standing

00:09:35,710 --> 00:09:41,210
object-oriented design principles and I

00:09:38,720 --> 00:09:44,510
did mention solid before so let's see

00:09:41,210 --> 00:09:46,730
how that plays out here here we have

00:09:44,510 --> 00:09:49,130
those five familiar kind of dense little

00:09:46,730 --> 00:09:50,600
principles there coined there from

00:09:49,130 --> 00:09:53,300
Robert Martin and they're all concerning

00:09:50,600 --> 00:09:55,310
class design and together they can

00:09:53,300 --> 00:09:57,260
actually work as a decent indicator of

00:09:55,310 --> 00:10:00,320
what is well-designed object-oriented

00:09:57,260 --> 00:10:01,400
code so we'll step through them now we

00:10:00,320 --> 00:10:02,720
start with a single responsibility

00:10:01,400 --> 00:10:04,370
principle and this one I'm sure we're

00:10:02,720 --> 00:10:06,500
all familiar with it says that a class

00:10:04,370 --> 00:10:09,410
should only have one reason to change

00:10:06,500 --> 00:10:10,880
well how that our example here it's

00:10:09,410 --> 00:10:12,560
functional so it's named after a single

00:10:10,880 --> 00:10:14,800
verb it's got a single responsibility

00:10:12,560 --> 00:10:17,330
running the import for our products so

00:10:14,800 --> 00:10:19,190
there's no room really for anything else

00:10:17,330 --> 00:10:20,930
there if you want to add other behavior

00:10:19,190 --> 00:10:23,090
that goes somewhere else so I think

00:10:20,930 --> 00:10:26,420
we're off to a good start we'll give us

00:10:23,090 --> 00:10:29,720
all the tea the next one the open closed

00:10:26,420 --> 00:10:32,630
principle says that incidence should be

00:10:29,720 --> 00:10:35,960
open for extension closed for

00:10:32,630 --> 00:10:37,430
modification or in other words when

00:10:35,960 --> 00:10:40,220
we're building a system and you want to

00:10:37,430 --> 00:10:42,920
introduce new behavior what we should do

00:10:40,220 --> 00:10:45,200
is rather than modifying the old objects

00:10:42,920 --> 00:10:47,990
we should create a new objects that work

00:10:45,200 --> 00:10:49,310
with the ones we already have so this

00:10:47,990 --> 00:10:51,620
plays nicely with our single purpose

00:10:49,310 --> 00:10:53,300
functions let's say for example that we

00:10:51,620 --> 00:10:56,090
want to send an email notification at

00:10:53,300 --> 00:10:57,920
the end of our import well given that

00:10:56,090 --> 00:10:59,450
our existing import products function is

00:10:57,920 --> 00:11:02,210
closed for modification

00:10:59,450 --> 00:11:03,920
we can extend its behavior by writing a

00:11:02,210 --> 00:11:06,410
new standard import notification object

00:11:03,920 --> 00:11:08,180
and then wrapping them both in a

00:11:06,410 --> 00:11:10,190
higher-level coordinating object that

00:11:08,180 --> 00:11:12,530
runs the input first and then sends a

00:11:10,190 --> 00:11:14,210
notification and the beautiful thing

00:11:12,530 --> 00:11:16,910
about this approach is that the more of

00:11:14,210 --> 00:11:18,680
our code we leave untouched the more

00:11:16,910 --> 00:11:21,020
confident we can be that our system will

00:11:18,680 --> 00:11:24,500
continue to run bug free even as we go

00:11:21,020 --> 00:11:26,720
and introduce new changes so that's

00:11:24,500 --> 00:11:30,260
another tick and now we come to the list

00:11:26,720 --> 00:11:31,820
of substitution principle and this one

00:11:30,260 --> 00:11:34,220
is really specifically about sub

00:11:31,820 --> 00:11:35,900
plotting and ensuring that a subclasses

00:11:34,220 --> 00:11:37,670
interface doesn't break the

00:11:35,900 --> 00:11:40,490
compatibility with its parent interface

00:11:37,670 --> 00:11:42,890
and since we mostly rely on competition

00:11:40,490 --> 00:11:44,720
we don't subclass much at all I'm just

00:11:42,890 --> 00:11:48,380
going to chalk this one up as an easy

00:11:44,720 --> 00:11:52,100
win I'll set those those base lines for

00:11:48,380 --> 00:11:55,310
myself here so from now to the interface

00:11:52,100 --> 00:11:57,830
segregation principle and this one says

00:11:55,310 --> 00:11:59,690
that many client specific interfaces are

00:11:57,830 --> 00:12:02,510
better than one general purpose

00:11:59,690 --> 00:12:04,580
interface or in other words when you

00:12:02,510 --> 00:12:07,310
depend on an object and it has

00:12:04,580 --> 00:12:09,470
interfaces for many different users you

00:12:07,310 --> 00:12:11,810
wind up being affected by changes to

00:12:09,470 --> 00:12:14,900
that object forced upon it by those

00:12:11,810 --> 00:12:16,760
other users well in practice let's see

00:12:14,900 --> 00:12:18,020
how this plays out we have our import

00:12:16,760 --> 00:12:20,090
products function we've been working

00:12:18,020 --> 00:12:21,920
with and it has that download feed

00:12:20,090 --> 00:12:24,820
dependency where it gets the product

00:12:21,920 --> 00:12:28,160
information from a remote feed source

00:12:24,820 --> 00:12:30,140
and this object at the bottom here has

00:12:28,160 --> 00:12:32,870
effectively been working as an incoming

00:12:30,140 --> 00:12:34,580
product source but what if we wanted to

00:12:32,870 --> 00:12:36,260
go and add a different way of getting

00:12:34,580 --> 00:12:38,710
product information say by allowing

00:12:36,260 --> 00:12:41,780
users to upload a feed file directly

00:12:38,710 --> 00:12:43,850
well since that is also about incoming

00:12:41,780 --> 00:12:45,530
products should we go on add that extra

00:12:43,850 --> 00:12:47,990
behavior right down to our existing

00:12:45,530 --> 00:12:49,220
objects or we could but that would

00:12:47,990 --> 00:12:51,350
violate this principle because it

00:12:49,220 --> 00:12:54,020
returning the object into a bigger

00:12:51,350 --> 00:12:55,370
general-purpose interface and that means

00:12:54,020 --> 00:12:56,930
it's likely going to change for

00:12:55,370 --> 00:12:59,990
different reasons over time and upset

00:12:56,930 --> 00:13:01,940
the stability of our app so instead

00:12:59,990 --> 00:13:03,380
because you've designed our objects to

00:13:01,940 --> 00:13:05,180
work really easily with different

00:13:03,380 --> 00:13:07,250
dependencies is much easier and much

00:13:05,180 --> 00:13:09,560
more natural to model this as a separate

00:13:07,250 --> 00:13:11,300
object with a new client specific

00:13:09,560 --> 00:13:11,970
interface purely for the purpose of

00:13:11,300 --> 00:13:14,399
handling

00:13:11,970 --> 00:13:16,399
dublin's and this means that other

00:13:14,399 --> 00:13:19,230
objects can work with it as required so

00:13:16,399 --> 00:13:21,449
nothing should become unexpectedly

00:13:19,230 --> 00:13:25,800
unsettled by changes to either of these

00:13:21,449 --> 00:13:27,089
dependencies so for ticks down one to go

00:13:25,800 --> 00:13:29,910
we've got the dependency inversion

00:13:27,089 --> 00:13:32,160
principle and in some states that one

00:13:29,910 --> 00:13:35,490
should depend upon abstractions and not

00:13:32,160 --> 00:13:37,680
concretion or in other words we should

00:13:35,490 --> 00:13:40,769
care more about interface rather than

00:13:37,680 --> 00:13:42,180
implementation and this is another place

00:13:40,769 --> 00:13:44,250
where our functional objects really

00:13:42,180 --> 00:13:46,889
shine because they're re-entered around

00:13:44,250 --> 00:13:50,040
dependency injection all those things do

00:13:46,889 --> 00:13:52,439
come in as abstract objects just like

00:13:50,040 --> 00:13:54,269
this our import products function

00:13:52,439 --> 00:13:56,550
doesn't know the concrete implementation

00:13:54,269 --> 00:13:58,829
details of that downloader just its

00:13:56,550 --> 00:14:01,079
interface just that it responds to call

00:13:58,829 --> 00:14:02,910
and that is except the feed object this

00:14:01,079 --> 00:14:05,310
is really Ruby's duck typing in a

00:14:02,910 --> 00:14:07,829
nutshell because it gives us the

00:14:05,310 --> 00:14:09,600
flexibility to adjust the implementation

00:14:07,829 --> 00:14:11,939
details of this object whenever we need

00:14:09,600 --> 00:14:14,670
or even replace it entirely and as long

00:14:11,939 --> 00:14:19,350
as we retain that interface everything

00:14:14,670 --> 00:14:23,309
stays good so how did we do well it's

00:14:19,350 --> 00:14:26,220
looking like we're solid and what this

00:14:23,309 --> 00:14:28,759
shows is that by following a functional

00:14:26,220 --> 00:14:31,189
approach we've actually created better

00:14:28,759 --> 00:14:33,930
object-oriented code for ourselves and

00:14:31,189 --> 00:14:36,329
we've done this with a blindingly simple

00:14:33,930 --> 00:14:40,259
approach really to our design model our

00:14:36,329 --> 00:14:43,110
behavior this functions I mean we

00:14:40,259 --> 00:14:44,370
satisfy those principles so easily you

00:14:43,110 --> 00:14:46,740
just have to think about why they were

00:14:44,370 --> 00:14:48,990
there in the first place and I think

00:14:46,740 --> 00:14:51,600
it's because it's so easy in classic

00:14:48,990 --> 00:14:53,759
object-oriented design to get off to

00:14:51,600 --> 00:14:54,750
what few like a good start and then go

00:14:53,759 --> 00:14:56,519
down the wrong path

00:14:54,750 --> 00:14:59,370
and wound up with something this Vaid

00:14:56,519 --> 00:15:02,519
I'm specified hard to reason about or

00:14:59,370 --> 00:15:04,490
just really complicated so we need these

00:15:02,519 --> 00:15:07,050
principles to try and keep us on track

00:15:04,490 --> 00:15:09,000
whereas with our functions they're dead

00:15:07,050 --> 00:15:13,470
simple and they take care of so many of

00:15:09,000 --> 00:15:15,600
those design considerations for us and I

00:15:13,470 --> 00:15:17,550
think this approach is confirmed by how

00:15:15,600 --> 00:15:21,000
we would test these as well let's take a

00:15:17,550 --> 00:15:22,319
quick look at that we start by recalling

00:15:21,000 --> 00:15:23,990
those two dependencies who are using

00:15:22,319 --> 00:15:27,110
download feed and

00:15:23,990 --> 00:15:31,010
products repository and then we set them

00:15:27,110 --> 00:15:33,380
up as mocks or test doubles then we can

00:15:31,010 --> 00:15:35,029
create our object under test the import

00:15:33,380 --> 00:15:38,029
products object by passing those doubles

00:15:35,029 --> 00:15:42,230
to the constructor then create a real

00:15:38,029 --> 00:15:44,390
feed value for our input and then return

00:15:42,230 --> 00:15:46,550
fixture data from a local file whenever

00:15:44,390 --> 00:15:48,740
our fake download object is called with

00:15:46,550 --> 00:15:50,839
the feed and then finally we get to our

00:15:48,740 --> 00:15:52,580
test so we can call our importer and

00:15:50,839 --> 00:15:54,200
assert that our repository has been

00:15:52,580 --> 00:15:56,330
asked to create a record for each of the

00:15:54,200 --> 00:15:58,209
products in that fixture file and that's

00:15:56,330 --> 00:16:00,500
it

00:15:58,209 --> 00:16:03,620
we could use these mocks so easily

00:16:00,500 --> 00:16:05,540
because our class was designed around

00:16:03,620 --> 00:16:07,700
working with injected dependencies so

00:16:05,540 --> 00:16:09,709
instead of having to interact with these

00:16:07,700 --> 00:16:12,649
two different external systems this

00:16:09,709 --> 00:16:14,750
remote HTTP datasource and local

00:16:12,649 --> 00:16:17,330
database instead we could simulate their

00:16:14,750 --> 00:16:19,490
behavior focus on our one function under

00:16:17,330 --> 00:16:21,440
test and get the test done quickly in

00:16:19,490 --> 00:16:26,450
real isolation and with a minimum of

00:16:21,440 --> 00:16:29,120
fuss I think there's been a strong theme

00:16:26,450 --> 00:16:33,620
so far it's been about making our

00:16:29,120 --> 00:16:35,630
dependencies clear and I think this is

00:16:33,620 --> 00:16:39,339
because it's one of the best things that

00:16:35,630 --> 00:16:42,020
we can do to enable well-designed code

00:16:39,339 --> 00:16:44,029
making our defensive dependencies clear

00:16:42,020 --> 00:16:46,190
means that we can consider the stable

00:16:44,029 --> 00:16:48,890
dependencies principle as we go about

00:16:46,190 --> 00:16:51,529
and build our apps and this one says

00:16:48,890 --> 00:16:53,420
that a stable object an object's

00:16:51,529 --> 00:16:55,640
dependencies should be more stable than

00:16:53,420 --> 00:16:57,649
it is what does this actually mean what

00:16:55,640 --> 00:16:59,480
the state will mean here or a stable

00:16:57,649 --> 00:17:01,880
object roughly means hard to change and

00:16:59,480 --> 00:17:04,459
an unstable one is one that's easier to

00:17:01,880 --> 00:17:06,260
change and every application will need

00:17:04,459 --> 00:17:08,600
its share of unstable objects because

00:17:06,260 --> 00:17:11,059
applications do need to change but we

00:17:08,600 --> 00:17:12,770
want to avoid the situation where the

00:17:11,059 --> 00:17:14,720
objects that we need to change often are

00:17:12,770 --> 00:17:17,839
the ones that have many users within our

00:17:14,720 --> 00:17:19,640
system so what we can do then is take

00:17:17,839 --> 00:17:21,650
our dependencies and arrange them

00:17:19,640 --> 00:17:22,819
according to this principle and make

00:17:21,650 --> 00:17:27,490
sure the lines flow in the right

00:17:22,819 --> 00:17:27,490
direction from unstable to stable

00:17:27,530 --> 00:17:32,060
and we can take this a step further once

00:17:30,710 --> 00:17:34,550
we start thinking out about our

00:17:32,060 --> 00:17:36,380
dependencies in this way we can extend

00:17:34,550 --> 00:17:39,080
this thinking to our app as a whole and

00:17:36,380 --> 00:17:40,880
consider it as a graph of objects with

00:17:39,080 --> 00:17:43,250
the classes or objects as the nodes and

00:17:40,880 --> 00:17:46,790
the dependency relationships at the

00:17:43,250 --> 00:17:48,590
edges and historically the way we built

00:17:46,790 --> 00:17:50,390
our ruby apps has been really class

00:17:48,590 --> 00:17:52,430
focused that we consider those classes

00:17:50,390 --> 00:17:56,270
the nodes to be the primary determinants

00:17:52,430 --> 00:17:58,520
of what is a well-designed app but I

00:17:56,270 --> 00:18:00,050
suggest we open things up a bit and take

00:17:58,520 --> 00:18:02,930
a hard look at the edges in our graph

00:18:00,050 --> 00:18:04,190
those dependency relationships if we

00:18:02,930 --> 00:18:06,320
find the edges being arranged like this

00:18:04,190 --> 00:18:09,410
so our application looks like a big

00:18:06,320 --> 00:18:11,180
directed acyclic graph this is a good

00:18:09,410 --> 00:18:14,180
sign that this app is going to be easier

00:18:11,180 --> 00:18:16,400
to change whereas on the other hand if

00:18:14,180 --> 00:18:18,380
our graphs had edges flowing in the

00:18:16,400 --> 00:18:20,930
wrong direction or becoming tangled or

00:18:18,380 --> 00:18:22,700
even becoming cyclic then it's a sign we

00:18:20,930 --> 00:18:25,270
could be in trouble that's an app that's

00:18:22,700 --> 00:18:27,350
going to be more resistant to change and

00:18:25,270 --> 00:18:28,670
that's really why we have all these

00:18:27,350 --> 00:18:30,620
printables in the first place they're

00:18:28,670 --> 00:18:35,090
there to help us achieve apps that are

00:18:30,620 --> 00:18:37,940
easier to change and well it seems like

00:18:35,090 --> 00:18:40,430
a functional approach to design gives us

00:18:37,940 --> 00:18:42,560
this and it does so in a way that's easy

00:18:40,430 --> 00:18:44,420
to follow based on that widespread use

00:18:42,560 --> 00:18:47,480
of functional objects and clear

00:18:44,420 --> 00:18:48,290
composition of dependencies and it's a

00:18:47,480 --> 00:18:51,890
pretty neat trick

00:18:48,290 --> 00:18:53,330
I'd say but I don't think it's a tree

00:18:51,890 --> 00:18:55,460
not a party tree because it doesn't fall

00:18:53,330 --> 00:18:57,320
down under pressure this is an approach

00:18:55,460 --> 00:18:59,240
we like so much at ice lab where our

00:18:57,320 --> 00:19:02,480
work that is now our preferred way to

00:18:59,240 --> 00:19:04,640
build ruby apps and over the last two

00:19:02,480 --> 00:19:06,620
years we've built more than 10 apps like

00:19:04,640 --> 00:19:08,060
this across different domains and with

00:19:06,620 --> 00:19:11,230
different levels of complexity and I can

00:19:08,060 --> 00:19:13,850
tell you this it works really well and

00:19:11,230 --> 00:19:16,250
from this simple reorientation around

00:19:13,850 --> 00:19:19,210
functions we've started to see a new

00:19:16,250 --> 00:19:22,970
high level architecture start to emerge

00:19:19,210 --> 00:19:25,160
because when we have many small single

00:19:22,970 --> 00:19:27,290
responsibility objects well at that

00:19:25,160 --> 00:19:29,240
point we need to take time to devise a

00:19:27,290 --> 00:19:32,930
sensible and consistent approach to

00:19:29,240 --> 00:19:35,420
naming them and organizing them and that

00:19:32,930 --> 00:19:39,020
leads to an emergent modularization of

00:19:35,420 --> 00:19:41,210
code within our system as we see those

00:19:39,020 --> 00:19:45,320
modules emerge we can start to take note

00:19:41,210 --> 00:19:47,690
of their boundaries and from this we can

00:19:45,320 --> 00:19:51,649
start to see you distinct subsystems

00:19:47,690 --> 00:19:54,200
become more visible in our apps how did

00:19:51,649 --> 00:19:55,760
this actually play out well we start

00:19:54,200 --> 00:19:57,470
with that graph of individual objects

00:19:55,760 --> 00:19:59,120
like we've been looking at and after a

00:19:57,470 --> 00:20:01,190
while we note some of them are clustered

00:19:59,120 --> 00:20:04,760
together because they all work towards a

00:20:01,190 --> 00:20:06,230
shared high level goal so we can

00:20:04,760 --> 00:20:09,500
formalize that and turn it into a

00:20:06,230 --> 00:20:11,539
distinct subsystem and as we go

00:20:09,500 --> 00:20:13,399
other subsystems start to emerge as we

00:20:11,539 --> 00:20:14,510
develop the features of our app these

00:20:13,399 --> 00:20:18,289
are the things that make up our

00:20:14,510 --> 00:20:19,640
applications core behaviors and because

00:20:18,289 --> 00:20:22,490
we've started paying attention to

00:20:19,640 --> 00:20:24,320
boundaries we can also take note of the

00:20:22,490 --> 00:20:27,740
applications own outer boundaries as

00:20:24,320 --> 00:20:30,559
well so rather than being deeply tired

00:20:27,740 --> 00:20:34,299
into the app as a whole systems like the

00:20:30,559 --> 00:20:37,039
HTTP interface the persistence layer and

00:20:34,299 --> 00:20:39,350
integrations with external services well

00:20:37,039 --> 00:20:41,539
they can be all carved off and placed at

00:20:39,350 --> 00:20:44,360
the outer edges of our app and formalize

00:20:41,539 --> 00:20:47,659
with a clear public API and clear and

00:20:44,360 --> 00:20:49,640
obvious points of integration and this

00:20:47,659 --> 00:20:52,010
arrangement this is what makes changes

00:20:49,640 --> 00:20:53,779
to our app just as easy at the very high

00:20:52,010 --> 00:20:58,909
level as they should be down at the

00:20:53,779 --> 00:21:00,620
individual object by object level if all

00:20:58,909 --> 00:21:01,960
of this sounds attractive to you and

00:21:00,620 --> 00:21:05,210
it's something you want to give a try

00:21:01,960 --> 00:21:07,250
well you don't have to worry about going

00:21:05,210 --> 00:21:09,529
out on your own and forging your own

00:21:07,250 --> 00:21:11,840
path to this because we've seen a whole

00:21:09,529 --> 00:21:15,440
Ruby ecosystem that's grown up around

00:21:11,840 --> 00:21:17,419
this approach we have Ramar be a

00:21:15,440 --> 00:21:19,460
persistence toolkit designed from the

00:21:17,419 --> 00:21:23,419
ground up to work with a separate layer

00:21:19,460 --> 00:21:25,279
from your business logic and then we

00:21:23,419 --> 00:21:27,289
have the drive-e project which is the

00:21:25,279 --> 00:21:29,179
collection of gems built to enable

00:21:27,289 --> 00:21:32,960
specifically this design I've been

00:21:29,179 --> 00:21:35,270
looking at today driver gives us things

00:21:32,960 --> 00:21:37,549
like type definitions data validation

00:21:35,270 --> 00:21:41,330
view rendering all models of functional

00:21:37,549 --> 00:21:43,370
objects it gives us the ability to

00:21:41,330 --> 00:21:46,159
consistently model both in success and

00:21:43,370 --> 00:21:47,980
failure results of our functions which

00:21:46,159 --> 00:21:50,179
lets us compose them in interesting ways

00:21:47,980 --> 00:21:51,529
and on top of all of this we get nice

00:21:50,179 --> 00:21:53,450
pattern matching support so we can

00:21:51,529 --> 00:21:54,750
elevate failure handling through their

00:21:53,450 --> 00:21:57,900
first class concept

00:21:54,750 --> 00:21:59,190
within our system and we also get

00:21:57,900 --> 00:22:01,740
support for building our own value

00:21:59,190 --> 00:22:03,450
objects with strict data attribute types

00:22:01,740 --> 00:22:06,570
so it can be confident about what

00:22:03,450 --> 00:22:08,220
they'll hold now all of those things are

00:22:06,570 --> 00:22:10,080
worthy of their own talks but I just

00:22:08,220 --> 00:22:12,510
want to draw attention to one gem here

00:22:10,080 --> 00:22:15,000
drive system this is built specifically

00:22:12,510 --> 00:22:17,880
to help us create acts centered around

00:22:15,000 --> 00:22:20,220
functional objects and what it does is

00:22:17,880 --> 00:22:22,380
offer us a central container through

00:22:20,220 --> 00:22:26,010
which we can access all of those objects

00:22:22,380 --> 00:22:27,960
in our system that container populate

00:22:26,010 --> 00:22:29,850
itself based on some simple convention

00:22:27,960 --> 00:22:33,480
that starts by scanning our source files

00:22:29,850 --> 00:22:36,150
an n for each file registers a matching

00:22:33,480 --> 00:22:39,060
container identifier and then when we

00:22:36,150 --> 00:22:40,560
resolve that identifier we get a pre

00:22:39,060 --> 00:22:43,200
initialized instance of that object

00:22:40,560 --> 00:22:46,050
ready for us to use with all of those

00:22:43,200 --> 00:22:47,310
dependencies automatically provided so

00:22:46,050 --> 00:22:48,720
if you're looking at our examples before

00:22:47,310 --> 00:22:50,730
and wondering well how do I get

00:22:48,720 --> 00:22:52,410
everything into the objects this is

00:22:50,730 --> 00:22:56,610
something that will let you do it easily

00:22:52,410 --> 00:22:58,080
and it let us do this by giving us this

00:22:56,610 --> 00:22:59,940
simple mixing that we can use in our

00:22:58,080 --> 00:23:01,920
class files where we specify our

00:22:59,940 --> 00:23:04,260
dependencies by their container

00:23:01,920 --> 00:23:06,270
identifier so instead of having to

00:23:04,260 --> 00:23:07,530
manually build that constructor and set

00:23:06,270 --> 00:23:09,390
the instance variables like we just did

00:23:07,530 --> 00:23:11,340
before we can now just declare our

00:23:09,390 --> 00:23:14,510
dependencies upfront and the rest is

00:23:11,340 --> 00:23:17,190
done for us and with all that in place

00:23:14,510 --> 00:23:19,440
we can now make an instance of our

00:23:17,190 --> 00:23:22,010
object directly without supplying any

00:23:19,440 --> 00:23:24,840
arguments at all that initializer and

00:23:22,010 --> 00:23:26,670
again when we do this all those default

00:23:24,840 --> 00:23:30,720
dependencies get provided from the

00:23:26,670 --> 00:23:32,190
container now if you think about testing

00:23:30,720 --> 00:23:34,860
this opens up to new possibilities for

00:23:32,190 --> 00:23:36,270
us because we can now choose which of

00:23:34,860 --> 00:23:38,280
the dependencies we want to leave as the

00:23:36,270 --> 00:23:40,560
default and which we want to replace

00:23:38,280 --> 00:23:42,420
with something like a test double so

00:23:40,560 --> 00:23:44,400
instead of that arrangement like we've

00:23:42,420 --> 00:23:45,600
had before where we had to provide a

00:23:44,400 --> 00:23:48,690
double for every single one of the

00:23:45,600 --> 00:23:50,100
dependencies what we can do now is we

00:23:48,690 --> 00:23:52,290
could choose not to provide one of them

00:23:50,100 --> 00:23:53,790
just like here we can choose to skip

00:23:52,290 --> 00:23:56,760
passing our products repository as a

00:23:53,790 --> 00:23:59,010
test double so the resulting object here

00:23:56,760 --> 00:24:00,810
will use just one double and then it

00:23:59,010 --> 00:24:03,150
will use the real system object for the

00:24:00,810 --> 00:24:05,280
repository so if we went to test this

00:24:03,150 --> 00:24:06,659
object it would actually write all the

00:24:05,280 --> 00:24:08,129
records to our test database

00:24:06,659 --> 00:24:11,039
and then we could go in a search for

00:24:08,129 --> 00:24:14,009
their presence afterwards now this is a

00:24:11,039 --> 00:24:16,169
much less pure approach to testing but

00:24:14,009 --> 00:24:18,210
in certain situations it may be much

00:24:16,169 --> 00:24:20,330
more practical and it's great that we

00:24:18,210 --> 00:24:24,059
have the choice to do one or the other

00:24:20,330 --> 00:24:28,049
so that was it pretty much a functional

00:24:24,059 --> 00:24:30,690
architecture for Ruby apps how did we do

00:24:28,049 --> 00:24:32,129
it well we really created a hybrid of

00:24:30,690 --> 00:24:34,259
functional and object-oriented

00:24:32,129 --> 00:24:37,200
programming based on some really simple

00:24:34,259 --> 00:24:38,940
rules we separate data and behavior and

00:24:37,200 --> 00:24:42,029
then we provide that behavior as

00:24:38,940 --> 00:24:43,679
functional objects but we also drawn the

00:24:42,029 --> 00:24:45,629
best bits of object-oriented programming

00:24:43,679 --> 00:24:48,869
like dependency injection and object

00:24:45,629 --> 00:24:50,729
composition and by doing this we found

00:24:48,869 --> 00:24:54,409
an approach that's easy to follow and

00:24:50,729 --> 00:24:56,700
makes for apps that are easy to change

00:24:54,409 --> 00:24:59,279
and I think this makes a functional

00:24:56,700 --> 00:25:02,279
architecture a real practical choice for

00:24:59,279 --> 00:25:04,080
any rubyist out there and thanks to

00:25:02,279 --> 00:25:05,849
organizations like ROM are being drive

00:25:04,080 --> 00:25:08,549
ADA's already support in our community

00:25:05,849 --> 00:25:10,139
for following this approach and also by

00:25:08,549 --> 00:25:12,059
choosing to stay with Ruby and take an

00:25:10,139 --> 00:25:13,799
approach like this rather than trying to

00:25:12,059 --> 00:25:15,749
follow it with some other programming

00:25:13,799 --> 00:25:17,669
languages you get to continue to

00:25:15,749 --> 00:25:20,159
leverage all of your existing knowledge

00:25:17,669 --> 00:25:24,269
of our community our ecosystem and our

00:25:20,159 --> 00:25:25,769
tools so given all that I think

00:25:24,269 --> 00:25:27,509
functional architecture is really worth

00:25:25,769 --> 00:25:31,440
the try I think you can help you build

00:25:27,509 --> 00:25:34,320
better things because while solid might

00:25:31,440 --> 00:25:36,690
be asking him for a collection of design

00:25:34,320 --> 00:25:38,849
principles I think it's a feeling too

00:25:36,690 --> 00:25:40,679
and I know that since I've been working

00:25:38,849 --> 00:25:43,049
in this way I've been shipping apps that

00:25:40,679 --> 00:25:44,970
feel 100 percent solid absolute I'm

00:25:43,049 --> 00:25:47,070
confident will work the way they shed an

00:25:44,970 --> 00:25:49,649
absolute I know I can go back and easily

00:25:47,070 --> 00:25:51,419
change later now I feel that taking this

00:25:49,649 --> 00:25:53,669
journey has made me a better developer

00:25:51,419 --> 00:25:55,769
but most importantly it made me a

00:25:53,669 --> 00:25:59,389
happier developer I'd love for you to

00:25:55,769 --> 00:26:01,679
join me and if you would like to join me

00:25:59,389 --> 00:26:02,909
now's a good time to check out this

00:26:01,679 --> 00:26:05,009
repository because we're just getting

00:26:02,909 --> 00:26:06,869
started in building a best practice

00:26:05,009 --> 00:26:09,899
example app that follows all these

00:26:06,869 --> 00:26:11,489
principles so it's fresh as of this week

00:26:09,899 --> 00:26:13,460
if you follow along you get to see all

00:26:11,489 --> 00:26:15,809
the work that we do to make it happen

00:26:13,460 --> 00:26:17,580
and with that thanks very much for

00:26:15,809 --> 00:26:21,169
listening and I hope you give this a

00:26:17,580 --> 00:26:21,169
pitcher chance thank you very much

00:26:28,660 --> 00:26:38,800
all right so do we have any questions

00:26:31,190 --> 00:26:38,800
for mr. timidly anyone yeah

00:26:46,510 --> 00:26:56,130
hello first thank you for the talk it is

00:26:49,060 --> 00:26:59,410
really good so my question is how about

00:26:56,130 --> 00:27:03,130
how do you develop this kind of

00:26:59,410 --> 00:27:06,160
component I mean for example did you

00:27:03,130 --> 00:27:09,370
first draw some kind of diagrams before

00:27:06,160 --> 00:27:12,240
starting to create the objects like

00:27:09,370 --> 00:27:15,460
import products download speeds and the

00:27:12,240 --> 00:27:17,380
repositories and you know in which order

00:27:15,460 --> 00:27:19,780
do you go from bottom up like the

00:27:17,380 --> 00:27:21,640
protector ease first or you start

00:27:19,780 --> 00:27:24,010
top-down and putting in tests suppose

00:27:21,640 --> 00:27:26,860
first things things like that I would

00:27:24,010 --> 00:27:30,900
like to know about the process which you

00:27:26,860 --> 00:27:33,040
used to design and develop thank you

00:27:30,900 --> 00:27:35,200
thanks for the question I guess a top

00:27:33,040 --> 00:27:36,940
down or bottom approach bottom-up

00:27:35,200 --> 00:27:39,160
approach is there for you to take

00:27:36,940 --> 00:27:40,540
depending I guess on your personal style

00:27:39,160 --> 00:27:43,000
and how much you know about the

00:27:40,540 --> 00:27:45,340
requirements up front so if you were

00:27:43,000 --> 00:27:47,950
sort of doing exploratory development or

00:27:45,340 --> 00:27:49,450
your requirements for fuzzy definitely

00:27:47,950 --> 00:27:51,610
you'd start with a top-down approach

00:27:49,450 --> 00:27:53,980
you'd make your highest level thing and

00:27:51,610 --> 00:27:55,930
then you start to explore what it has to

00:27:53,980 --> 00:27:57,910
do and as you notice studying that

00:27:55,930 --> 00:28:00,130
objects starting to do too much that's

00:27:57,910 --> 00:28:03,010
when you break it apart and build extra

00:28:00,130 --> 00:28:05,680
objects as dependencies and because we

00:28:03,010 --> 00:28:08,140
we work with that auto-injector mix in

00:28:05,680 --> 00:28:10,060
is the way we work that's a really low

00:28:08,140 --> 00:28:11,920
friction thing to do there's not much

00:28:10,060 --> 00:28:13,330
effort to make a new file and then check

00:28:11,920 --> 00:28:16,180
and identify for that file in there's a

00:28:13,330 --> 00:28:17,590
dependency so that's some that's one way

00:28:16,180 --> 00:28:19,030
to take it or on the other hand if you

00:28:17,590 --> 00:28:21,460
really knew exactly what you wanted to

00:28:19,030 --> 00:28:23,770
build you could start with yeah the

00:28:21,460 --> 00:28:26,320
solid underpinnings and then go upwards

00:28:23,770 --> 00:28:28,570
so either options there it just depends

00:28:26,320 --> 00:28:33,070
on the situation of the app that you're

00:28:28,570 --> 00:28:39,400
developing I think can I have one more

00:28:33,070 --> 00:28:42,310
question okay thank you so sometimes

00:28:39,400 --> 00:28:44,170
when when going this way do you have the

00:28:42,310 --> 00:28:46,030
feeling that when you want to implement

00:28:44,170 --> 00:28:48,040
some features you have to change you

00:28:46,030 --> 00:28:50,950
have to make change to the several files

00:28:48,040 --> 00:28:54,700
instead of one file for for example if I

00:28:50,950 --> 00:28:57,400
want to like add something to import

00:28:54,700 --> 00:28:59,420
products like it needs a new behavior

00:28:57,400 --> 00:29:01,670
like aggregating data from

00:28:59,420 --> 00:29:04,310
repository but the repository doesn't

00:29:01,670 --> 00:29:07,820
have that functionality yet and in the

00:29:04,310 --> 00:29:11,120
end adding one thing requires changing

00:29:07,820 --> 00:29:13,160
in multiple files yeah do you have that

00:29:11,120 --> 00:29:14,750
clearly yeah this is something that

00:29:13,160 --> 00:29:17,990
definitely happens but I think it's an

00:29:14,750 --> 00:29:20,030
advantage because think about the

00:29:17,990 --> 00:29:24,050
opposite if you had all of your behavior

00:29:20,030 --> 00:29:26,030
clustered into one class and that means

00:29:24,050 --> 00:29:28,250
that much more of your system is all

00:29:26,030 --> 00:29:30,980
using that one class and then it means

00:29:28,250 --> 00:29:33,080
that any change you make there is going

00:29:30,980 --> 00:29:34,010
to have ripple effects ones that you may

00:29:33,080 --> 00:29:36,970
not even expect

00:29:34,010 --> 00:29:40,490
whereas with smaller responsibilities

00:29:36,970 --> 00:29:43,310
broken apart into a larger number of

00:29:40,490 --> 00:29:44,450
individual files you can see much more

00:29:43,310 --> 00:29:47,060
clearly because of the dependency

00:29:44,450 --> 00:29:48,590
relationships what is using what and you

00:29:47,060 --> 00:29:50,120
know what each one should be doing

00:29:48,590 --> 00:29:54,290
specifically because it has that single

00:29:50,120 --> 00:29:56,300
responsibility and in some some objects

00:29:54,290 --> 00:29:57,800
that do have sort of wider api's like

00:29:56,300 --> 00:29:59,840
repositories where you might want to add

00:29:57,800 --> 00:30:02,150
lots of methods for different ways to

00:29:59,840 --> 00:30:03,620
access your data because those methods

00:30:02,150 --> 00:30:06,350
are clearly named by you the developer

00:30:03,620 --> 00:30:07,460
you've explicitly made an API you should

00:30:06,350 --> 00:30:09,230
be much more confident about where

00:30:07,460 --> 00:30:11,150
that's being used and you can make that

00:30:09,230 --> 00:30:13,070
change it is just a change in mindset

00:30:11,150 --> 00:30:14,690
that whenever you work on things you

00:30:13,070 --> 00:30:16,340
jump across a few different files rather

00:30:14,690 --> 00:30:19,660
than the smaller number of larger

00:30:16,340 --> 00:30:19,660
bulkier files

00:30:21,730 --> 00:30:25,360
there anyone else

00:30:27,870 --> 00:30:36,559
no I'll write up there oh yes oh okay

00:30:32,190 --> 00:30:36,559
could you approach hold microphone

00:30:44,710 --> 00:30:52,190
okay hello so my question is if I want

00:30:50,060 --> 00:30:55,250
to migrate an existing application

00:30:52,190 --> 00:30:58,280
happen running production application so

00:30:55,250 --> 00:31:03,040
what would put a complicity to move it

00:30:58,280 --> 00:31:05,690
from Opie to functional programming APIs

00:31:03,040 --> 00:31:07,910
that is a tricky question I guess

00:31:05,690 --> 00:31:10,730
dealing with any legacy application

00:31:07,910 --> 00:31:12,350
comes with a whole bunch of nuance but I

00:31:10,730 --> 00:31:13,880
think this is something you can do as

00:31:12,350 --> 00:31:15,410
long as you're willing to accept that

00:31:13,880 --> 00:31:16,790
you're going to live in this world where

00:31:15,410 --> 00:31:18,950
there are sort of two different

00:31:16,790 --> 00:31:22,820
approaches to the design and I guess

00:31:18,950 --> 00:31:26,300
commit to the new approach whenever you

00:31:22,820 --> 00:31:27,740
add new functionality I mean you can

00:31:26,300 --> 00:31:30,530
certainly use drive system within rails

00:31:27,740 --> 00:31:31,970
for instance as a rail pipe forward what

00:31:30,530 --> 00:31:33,350
it would mean though within a rails app

00:31:31,970 --> 00:31:35,090
for example is that you're just going

00:31:33,350 --> 00:31:38,690
against the grain a bit so that may

00:31:35,090 --> 00:31:41,330
cause you a bit of friction but on the

00:31:38,690 --> 00:31:43,520
other hand these are all making a web

00:31:41,330 --> 00:31:44,810
app with with dry web and any other web

00:31:43,520 --> 00:31:46,550
front-end these things are alright

00:31:44,810 --> 00:31:49,030
compatible so you can put them together

00:31:46,550 --> 00:31:51,650
in various ways you could even choose to

00:31:49,030 --> 00:31:53,240
carve out the new stuff and have it in a

00:31:51,650 --> 00:31:56,780
sort of separate recommendable app

00:31:53,240 --> 00:32:00,710
alongside but that's quite an extreme

00:31:56,780 --> 00:32:02,930
approach so I think a more sensitive

00:32:00,710 --> 00:32:04,670
approach would probably be just to start

00:32:02,930 --> 00:32:06,470
thinking about as you build new

00:32:04,670 --> 00:32:09,440
functionality think about how it can be

00:32:06,470 --> 00:32:11,180
modeled as verbs and put them put those

00:32:09,440 --> 00:32:13,610
things those classes in your rails

00:32:11,180 --> 00:32:15,620
application wherever it fits and start

00:32:13,610 --> 00:32:17,780
working with those and you can hired for

00:32:15,620 --> 00:32:21,070
instance active record queries behind

00:32:17,780 --> 00:32:22,670
query objects you could also hired

00:32:21,070 --> 00:32:24,620
operations that write to the database

00:32:22,670 --> 00:32:26,300
behind their own objects and then your

00:32:24,620 --> 00:32:28,670
active record models for instance then

00:32:26,300 --> 00:32:30,620
become a much lower level persistence

00:32:28,670 --> 00:32:32,330
related detail rather than something

00:32:30,620 --> 00:32:34,340
that you use as the primary API of your

00:32:32,330 --> 00:32:35,690
app so that kind of mindset you can

00:32:34,340 --> 00:32:37,700
apply to any tools that you're using

00:32:35,690 --> 00:32:39,110
whether or not you use these gems or

00:32:37,700 --> 00:32:39,710
something else so that's how I think

00:32:39,110 --> 00:32:48,520
you'd do it

00:32:39,710 --> 00:32:51,200
ok cool do we have more questions yeah

00:32:48,520 --> 00:32:54,430
thanks for the talk to him and do you

00:32:51,200 --> 00:32:56,780
think that ruby would benefit from

00:32:54,430 --> 00:32:59,480
adopting some of the patterns you were

00:32:56,780 --> 00:33:02,660
showing for example value objects could

00:32:59,480 --> 00:33:04,640
be part of the Ruby core basically and

00:33:02,660 --> 00:33:06,530
people would probably pick pick up this

00:33:04,640 --> 00:33:08,450
pattern way easier you know this

00:33:06,530 --> 00:33:12,170
thinking of like okay I have an

00:33:08,450 --> 00:33:13,790
immutable read-only value object if it

00:33:12,170 --> 00:33:15,440
was in Ruby core directly what do you

00:33:13,790 --> 00:33:16,820
think should that kind of stuff be in

00:33:15,440 --> 00:33:21,500
Ruby or not because that's what my talk

00:33:16,820 --> 00:33:25,610
is about I'm happy to wait and find out

00:33:21,500 --> 00:33:27,020
this afternoon no I think masters point

00:33:25,610 --> 00:33:29,390
about compatibility is a really good one

00:33:27,020 --> 00:33:32,480
there um we can do these things in Ruby

00:33:29,390 --> 00:33:34,610
by convention an object can be immutable

00:33:32,480 --> 00:33:37,070
within our system if we choose not to

00:33:34,610 --> 00:33:41,320
mutate it and if we choose not to create

00:33:37,070 --> 00:33:43,400
writers sure I think some some

00:33:41,320 --> 00:33:46,490
facilities around first-class functions

00:33:43,400 --> 00:33:48,320
would help so that some of those

00:33:46,490 --> 00:33:50,620
functional objects can feel a little bit

00:33:48,320 --> 00:33:53,330
more better situated within the language

00:33:50,620 --> 00:33:57,020
but you know we work with the tools we

00:33:53,330 --> 00:33:58,730
have and you know we've probably all

00:33:57,020 --> 00:34:00,530
been writing with Ruby for a long time

00:33:58,730 --> 00:34:03,110
and we're here because we still enjoy it

00:34:00,530 --> 00:34:04,880
as a language for all of its good

00:34:03,110 --> 00:34:07,750
features and all of its kind of quirks

00:34:04,880 --> 00:34:10,690
and I think the fact that lets us model

00:34:07,750 --> 00:34:13,070
systems along these lines is great and

00:34:10,690 --> 00:34:14,270
we can start to develop the same

00:34:13,070 --> 00:34:15,919
instincts for how to break things down

00:34:14,270 --> 00:34:17,899
that that other function languages give

00:34:15,919 --> 00:34:21,909
us and I think the biggest thing that

00:34:17,899 --> 00:34:24,980
helped me in doing this was really

00:34:21,909 --> 00:34:26,360
approaching this completely apart from

00:34:24,980 --> 00:34:28,580
the tools I was used to using and

00:34:26,360 --> 00:34:30,470
starting fresh on some new project so I

00:34:28,580 --> 00:34:33,560
couldn't fall back to my old habits or

00:34:30,470 --> 00:34:35,450
those old shortcuts and that was what

00:34:33,560 --> 00:34:39,280
helps submit the change in mindset and

00:34:35,450 --> 00:34:39,280
that can still all be done within Ruby

00:34:42,560 --> 00:34:48,899
so the dry stack compact consists of a

00:34:46,050 --> 00:34:51,750
lot of different small libraries would

00:34:48,899 --> 00:34:53,909
you agree that it is designed and it is

00:34:51,750 --> 00:34:56,610
meant for more advanced programmers I

00:34:53,909 --> 00:34:58,770
feel that when beginners come and try to

00:34:56,610 --> 00:35:00,840
learn something the in difficult for

00:34:58,770 --> 00:35:03,810
them to decide what they actually want

00:35:00,840 --> 00:35:06,270
they usually want to have a set of tools

00:35:03,810 --> 00:35:08,700
that that that is like you know like

00:35:06,270 --> 00:35:10,050
pack together for them so I'm wondering

00:35:08,700 --> 00:35:11,550
if you think that this is meant for

00:35:10,050 --> 00:35:12,930
advanced programmers or do you think

00:35:11,550 --> 00:35:15,030
that maybe the community will come up

00:35:12,930 --> 00:35:17,220
with some like no just the default stack

00:35:15,030 --> 00:35:19,470
that you only modified if you know what

00:35:17,220 --> 00:35:21,810
you're doing yeah you're right in at the

00:35:19,470 --> 00:35:23,010
gems are fairly low on opinion they're

00:35:21,810 --> 00:35:24,350
meant to be flexible and they're meant

00:35:23,010 --> 00:35:26,520
to integrate into many different

00:35:24,350 --> 00:35:28,580
situations which is why perhaps they

00:35:26,520 --> 00:35:31,860
don't guide you as much as other tools

00:35:28,580 --> 00:35:33,420
but I would say that new developers can

00:35:31,860 --> 00:35:36,930
become productive with this we saw that

00:35:33,420 --> 00:35:38,460
at Ice lab we had someone who came on

00:35:36,930 --> 00:35:40,530
board as a junior developer he done some

00:35:38,460 --> 00:35:42,570
online Rails courses and he was pretty

00:35:40,530 --> 00:35:44,670
productively working with this because

00:35:42,570 --> 00:35:47,580
it really is a much simpler concept that

00:35:44,670 --> 00:35:49,890
is core you create objects you compose

00:35:47,580 --> 00:35:51,360
them and that's how you get larger

00:35:49,890 --> 00:35:54,360
pieces of functionality it's actually a

00:35:51,360 --> 00:35:56,220
smaller number of things to learn and as

00:35:54,360 --> 00:35:59,100
long as they're guided by some

00:35:56,220 --> 00:36:00,180
higher-level organizing structure with

00:35:59,100 --> 00:36:01,920
an app so if they're working with

00:36:00,180 --> 00:36:03,750
someone else you can take care of that

00:36:01,920 --> 00:36:05,730
by having conventions within your app

00:36:03,750 --> 00:36:07,200
that you've established and I think as

00:36:05,730 --> 00:36:09,300
part of doing all of this you get better

00:36:07,200 --> 00:36:10,770
at actually becoming a programmer so

00:36:09,300 --> 00:36:12,540
instead of being a programmer for one

00:36:10,770 --> 00:36:13,980
framework for instance you just get

00:36:12,540 --> 00:36:15,990
better at modeling and solving problems

00:36:13,980 --> 00:36:17,820
in general and I think that's a great

00:36:15,990 --> 00:36:19,260
thing for a junior developer or a less

00:36:17,820 --> 00:36:21,330
experienced developer to learn because

00:36:19,260 --> 00:36:22,800
they're going to be things that will

00:36:21,330 --> 00:36:24,570
help them for the rest of their

00:36:22,800 --> 00:36:26,490
programming career even if these tools

00:36:24,570 --> 00:36:28,760
they'd away the ideas behind them are

00:36:26,490 --> 00:36:28,760
enduring

00:36:33,140 --> 00:36:44,610
anyone else oh sorry I'm interested by

00:36:41,700 --> 00:36:48,330
your statement that the various dry dot

00:36:44,610 --> 00:36:50,850
RB gems are intended as atomic because

00:36:48,330 --> 00:36:53,310
when I've looked at it before I feel

00:36:50,850 --> 00:36:55,440
almost like you're trying to build a

00:36:53,310 --> 00:36:57,630
functional DSL using Ruby as an

00:36:55,440 --> 00:37:00,050
interpreter and while that isn't to my

00:36:57,630 --> 00:37:05,070
taste I think it's a reasonable project

00:37:00,050 --> 00:37:07,470
and so I guess how do you visualize

00:37:05,070 --> 00:37:09,060
people just using individual piece bits

00:37:07,470 --> 00:37:10,830
and pieces of the drop in because it

00:37:09,060 --> 00:37:13,230
seems like a kind of coherent system

00:37:10,830 --> 00:37:16,110
that you either buy into or don't buy

00:37:13,230 --> 00:37:18,000
into to me it's true that way you sort

00:37:16,110 --> 00:37:19,890
of have built these to work in harmony

00:37:18,000 --> 00:37:21,840
magic collection because they share

00:37:19,890 --> 00:37:25,050
similar philosophy across all the gems

00:37:21,840 --> 00:37:26,220
but a lot of them are intended your

00:37:25,050 --> 00:37:27,720
entire idea is to make one each

00:37:26,220 --> 00:37:30,690
something that solves an individual

00:37:27,720 --> 00:37:32,400
problem so I didn't mention it here but

00:37:30,690 --> 00:37:33,990
a one of the ones I've seen the biggest

00:37:32,400 --> 00:37:37,440
uptake is dry validation which is a

00:37:33,990 --> 00:37:39,150
standalone validation library and strict

00:37:37,440 --> 00:37:40,710
rigorous data validation is something

00:37:39,150 --> 00:37:43,200
that everyone needs in their projects

00:37:40,710 --> 00:37:44,730
and dry validation is really just about

00:37:43,200 --> 00:37:47,340
creating schema objects that you can

00:37:44,730 --> 00:37:48,869
call anywhere in your application so it

00:37:47,340 --> 00:37:50,580
doesn't really have any requirements

00:37:48,869 --> 00:37:52,650
beyond that your application can take

00:37:50,580 --> 00:37:54,930
any shape people are using it in rails

00:37:52,650 --> 00:37:57,119
apps people using it in apps that are

00:37:54,930 --> 00:37:59,940
the full collection of drive idioms and

00:37:57,119 --> 00:38:02,640
because it was done as a standalone

00:37:59,940 --> 00:38:05,040
thing it can find usefulness in a

00:38:02,640 --> 00:38:07,190
broader context now some of the dryer B

00:38:05,040 --> 00:38:10,590
gems are a little bit more specific for

00:38:07,190 --> 00:38:12,330
following an architecture like drive

00:38:10,590 --> 00:38:14,640
system if you're not going to want to

00:38:12,330 --> 00:38:15,690
build an app with a container to vend

00:38:14,640 --> 00:38:18,240
your object there's not really much

00:38:15,690 --> 00:38:19,890
point in using drive system but that's

00:38:18,240 --> 00:38:21,420
the whole idea because we didn't bundle

00:38:19,890 --> 00:38:23,100
that into everything and make them tied

00:38:21,420 --> 00:38:25,710
together you can just pick and choose

00:38:23,100 --> 00:38:27,240
what you'd like to use so the best ones

00:38:25,710 --> 00:38:29,609
that are that we've seen with standalone

00:38:27,240 --> 00:38:31,980
usage dry validation and dry types and

00:38:29,609 --> 00:38:36,600
dry struct because everyone has a need

00:38:31,980 --> 00:38:37,950
to validate data and model data and and

00:38:36,600 --> 00:38:39,900
treat data with rigor and that's

00:38:37,950 --> 00:38:42,440
something that can fit with any

00:38:39,900 --> 00:38:42,440
application

00:38:44,790 --> 00:38:48,850
okay I think that's all the time we have

00:38:47,380 --> 00:38:52,830
for questions let's give him another

00:38:48,850 --> 00:38:52,830

YouTube URL: https://www.youtube.com/watch?v=7qnsRejCyEQ


