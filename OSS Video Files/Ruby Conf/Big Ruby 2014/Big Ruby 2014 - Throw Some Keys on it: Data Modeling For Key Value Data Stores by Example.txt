Title: Big Ruby 2014 - Throw Some Keys on it: Data Modeling For Key Value Data Stores by Example
Publication date: 2020-01-24
Playlist: Big Ruby 2014
Description: 
	By Hector Castro

Most Computer Science curriculums offer at least one course that focuses on databases. Most of the time, these courses promote relational database management systems (RDBMS) by emphasizing the relational model, relational algebra, data normalization, and Structured Query Language (SQL). 

Key/value data stores are increasing in popularity but our mental model for storing data is still primarily relational. 

In this talk, we'll explore data modeling for key/value stores using the Uber mobile application as an example.

Help us caption & translate this video!

http://amara.org/v/FG3z/
Captions: 
	00:00:19,930 --> 00:00:25,130
alright so the talk is throw some keys

00:00:22,580 --> 00:00:28,369
on it data modeling for key value data

00:00:25,130 --> 00:00:31,070
stores by example my name is Hector

00:00:28,369 --> 00:00:33,590
Castro that's my handle pretty much

00:00:31,070 --> 00:00:36,380
everywhere disclaimer up front I work

00:00:33,590 --> 00:00:39,710
for bass show we make a distributed key

00:00:36,380 --> 00:00:44,480
valley database a quick story about a

00:00:39,710 --> 00:00:47,090
quick back story here i was in mexico in

00:00:44,480 --> 00:00:48,710
mexico you'll run in scenarios where if

00:00:47,090 --> 00:00:51,079
you're sitting down in like an open cafe

00:00:48,710 --> 00:00:53,960
area a guy like this will approach you

00:00:51,079 --> 00:00:55,430
and he will put his hand on you and he

00:00:53,960 --> 00:00:59,269
won't make a sound and he'll stay there

00:00:55,430 --> 00:01:01,100
until you pay him money if you're with

00:00:59,269 --> 00:01:02,960
someone else he will then do the same

00:01:01,100 --> 00:01:06,350
thing to them and stand there until you

00:01:02,960 --> 00:01:08,060
give them money so if software doesn't

00:01:06,350 --> 00:01:12,440
work out for any of us this is a nice

00:01:08,060 --> 00:01:14,150
professional to look forward to so how

00:01:12,440 --> 00:01:16,040
many people have seen something like

00:01:14,150 --> 00:01:19,220
this like hanging on somebody's cube

00:01:16,040 --> 00:01:21,710
wall or somebody printing it out to try

00:01:19,220 --> 00:01:23,210
to explain what the database what

00:01:21,710 --> 00:01:26,170
relationships are between a bunch of

00:01:23,210 --> 00:01:28,790
different entities in a database so

00:01:26,170 --> 00:01:31,369
relational databases aren't all bad

00:01:28,790 --> 00:01:32,810
right they give us things that are very

00:01:31,369 --> 00:01:35,990
attractive from a developer's

00:01:32,810 --> 00:01:38,540
perspective they give us they give us

00:01:35,990 --> 00:01:39,799
relationships you know establishing

00:01:38,540 --> 00:01:41,689
relationships between multiple entities

00:01:39,799 --> 00:01:42,979
when you're de normalizing give you

00:01:41,689 --> 00:01:45,409
transactions you're trying to make

00:01:42,979 --> 00:01:46,880
modifications to multiple rows multiple

00:01:45,409 --> 00:01:49,280
objects the same time you want them to

00:01:46,880 --> 00:01:51,590
happen in an atomic way they give you

00:01:49,280 --> 00:01:53,119
schemas so you can define types against

00:01:51,590 --> 00:01:55,189
particular object so you can optimize

00:01:53,119 --> 00:01:56,719
you can say this is going to be a date

00:01:55,189 --> 00:02:00,380
for my range query so he can make your

00:01:56,719 --> 00:02:03,439
range queries fastest as an integer the

00:02:00,380 --> 00:02:05,299
ability to extend existing schemas so if

00:02:03,439 --> 00:02:06,530
you want to alter a table you can do all

00:02:05,299 --> 00:02:08,000
these things in a relational database

00:02:06,530 --> 00:02:09,259
and the last thing probably one of the

00:02:08,000 --> 00:02:12,200
most important things is that you can

00:02:09,259 --> 00:02:14,600
use ad hoc queries you can use sequel to

00:02:12,200 --> 00:02:18,200
access all the data inside of your

00:02:14,600 --> 00:02:20,990
database so then the question is you

00:02:18,200 --> 00:02:23,000
know what if your application doesn't

00:02:20,990 --> 00:02:26,300
need most of that for more importantly

00:02:23,000 --> 00:02:28,690
what if things like latency things like

00:02:26,300 --> 00:02:30,400
scale or high availability Trump

00:02:28,690 --> 00:02:31,570
a lot of the features that you're

00:02:30,400 --> 00:02:33,250
getting out of relational database

00:02:31,570 --> 00:02:35,230
basically your application requires

00:02:33,250 --> 00:02:37,900
these more than it require some of those

00:02:35,230 --> 00:02:40,270
other features we want went through so

00:02:37,900 --> 00:02:42,430
this is where key value stores come into

00:02:40,270 --> 00:02:44,890
play more specifically distributed key

00:02:42,430 --> 00:02:46,300
value stores so a couple of reasons why

00:02:44,890 --> 00:02:47,830
they're attractive so there's schema

00:02:46,300 --> 00:02:50,620
lists and we saw this in a couple of

00:02:47,830 --> 00:02:53,020
talks yesterday single access reads

00:02:50,620 --> 00:02:54,250
you're doing primary key reads so

00:02:53,020 --> 00:02:56,200
generally things are going to be very

00:02:54,250 --> 00:02:58,810
fast if you're trying to do hi right

00:02:56,200 --> 00:03:00,340
workloads they're also pretty good for

00:02:58,810 --> 00:03:03,100
right heavy workloads a lot of times key

00:03:00,340 --> 00:03:06,610
value stores are append only so these

00:03:03,100 --> 00:03:08,440
rights can be very fast in general

00:03:06,610 --> 00:03:10,300
they're easier to scale if not simply

00:03:08,440 --> 00:03:12,100
because you know you have a much more

00:03:10,300 --> 00:03:13,420
restricted API so there's a lot of

00:03:12,100 --> 00:03:14,680
things that you don't have to worry

00:03:13,420 --> 00:03:16,330
about if you're trying to scale key

00:03:14,680 --> 00:03:17,740
value data store not to worry about

00:03:16,330 --> 00:03:20,610
joins you don't have to worry about

00:03:17,740 --> 00:03:23,350
grouping data across multiple shards and

00:03:20,610 --> 00:03:25,600
it's a familiar interface so it's just

00:03:23,350 --> 00:03:28,810
just a hash so a couple of examples here

00:03:25,600 --> 00:03:30,700
and Ruby if you have a hash or map you

00:03:28,810 --> 00:03:33,250
can assign a value to it and print it

00:03:30,700 --> 00:03:35,410
out you can assign a more complicated

00:03:33,250 --> 00:03:37,720
structure you can serialize that you can

00:03:35,410 --> 00:03:39,670
store it there you can even just take

00:03:37,720 --> 00:03:40,840
image files and put them inside right so

00:03:39,670 --> 00:03:42,190
you can do a lot of these same things

00:03:40,840 --> 00:03:45,580
with key value stores because they're

00:03:42,190 --> 00:03:48,820
just storing binary data so a lot of

00:03:45,580 --> 00:03:50,050
times even even I did this is when you

00:03:48,820 --> 00:03:51,870
know you're presented with this very

00:03:50,050 --> 00:03:54,250
primitive way of interacting with data

00:03:51,870 --> 00:03:57,280
the immediate the immediate thing is

00:03:54,250 --> 00:03:59,680
okay that's cool but my application is

00:03:57,280 --> 00:04:00,880
too complicated so I can't use this data

00:03:59,680 --> 00:04:05,290
store I need something more complicated

00:04:00,880 --> 00:04:07,620
i need rose any tables any columns so

00:04:05,290 --> 00:04:10,480
the example I'm going to walk through is

00:04:07,620 --> 00:04:13,630
relatively simple but it's something

00:04:10,480 --> 00:04:15,280
that it gave me an aha moment when I was

00:04:13,630 --> 00:04:16,840
you know figuring out how to model

00:04:15,280 --> 00:04:18,370
applications for key value data stores

00:04:16,840 --> 00:04:20,019
and I think it's produced a lot of other

00:04:18,370 --> 00:04:22,870
aha moments with other people that I've

00:04:20,019 --> 00:04:24,160
interacted with so I felt compelled to

00:04:22,870 --> 00:04:26,490
put it together in a presentation to

00:04:24,160 --> 00:04:28,900
hopefully give you the same aha moment

00:04:26,490 --> 00:04:32,200
so are people familiar with this

00:04:28,900 --> 00:04:34,060
application for anybody who's not uber

00:04:32,200 --> 00:04:36,490
is just like a mobile application for

00:04:34,060 --> 00:04:38,650
you to request drivers like basically

00:04:36,490 --> 00:04:40,690
black our limousines also now they're

00:04:38,650 --> 00:04:42,240
expanding a regular cars to come to

00:04:40,690 --> 00:04:43,849
location that you're at pick

00:04:42,240 --> 00:04:45,479
you up take you wherever you need to go

00:04:43,849 --> 00:04:48,630
transactions happen through credit cards

00:04:45,479 --> 00:04:52,620
no real interaction with the driver it's

00:04:48,630 --> 00:04:54,690
basically like optimized cab service so

00:04:52,620 --> 00:04:56,250
you think about this you start thinking

00:04:54,690 --> 00:04:58,310
about like geolocation you start

00:04:56,250 --> 00:05:00,720
thinking about making geospatial queries

00:04:58,310 --> 00:05:01,740
you know the engineer and a lot of us

00:05:00,720 --> 00:05:03,870
Walter maniacally start thinking like

00:05:01,740 --> 00:05:05,849
well I know postgres has geospatial

00:05:03,870 --> 00:05:06,900
queries I know that Solar has geospatial

00:05:05,849 --> 00:05:08,280
queries that's the first thing I'm going

00:05:06,900 --> 00:05:10,110
to reach you try to solve this problem

00:05:08,280 --> 00:05:11,759
so I'm going to try to walk through an

00:05:10,110 --> 00:05:15,990
example of how you solve this with a key

00:05:11,759 --> 00:05:19,169
value data store so uber has a couple of

00:05:15,990 --> 00:05:22,289
components the first one is the driver

00:05:19,169 --> 00:05:24,389
itself right the black car then there's

00:05:22,289 --> 00:05:25,800
you wherever you are wherever you're

00:05:24,389 --> 00:05:29,039
located wherever you're requesting this

00:05:25,800 --> 00:05:31,130
car from and then there's the entire map

00:05:29,039 --> 00:05:36,780
right where you are where you're located

00:05:31,130 --> 00:05:42,210
the area around you so let's start with

00:05:36,780 --> 00:05:43,740
the driver so the driver is in this

00:05:42,210 --> 00:05:45,569
particular quadrant so we're taking the

00:05:43,740 --> 00:05:47,849
map and we're kind of slicing it up now

00:05:45,569 --> 00:05:50,159
if we assume that that you know the pin

00:05:47,849 --> 00:05:52,919
here is at zero zero then if we go over

00:05:50,159 --> 00:05:55,080
one and go down to we can assume that

00:05:52,919 --> 00:05:57,719
this driver is at the coordinate 1

00:05:55,080 --> 00:05:59,430
negative 2 so we're not using we're not

00:05:57,719 --> 00:06:00,810
using latitude longitude precisely here

00:05:59,430 --> 00:06:06,080
because we're just trying to generalize

00:06:00,810 --> 00:06:11,099
into these larger blocks so to propose a

00:06:06,080 --> 00:06:15,530
way to describe this particular if I was

00:06:11,099 --> 00:06:21,479
trying to request this car you have a

00:06:15,530 --> 00:06:22,889
date a time and the coordinates so now

00:06:21,479 --> 00:06:24,389
this is an example of what it would look

00:06:22,889 --> 00:06:26,219
like in react because react has a notion

00:06:24,389 --> 00:06:28,319
of something called buckets but

00:06:26,219 --> 00:06:30,479
generally we're just using the date here

00:06:28,319 --> 00:06:31,830
and the time as a namespace we're just

00:06:30,479 --> 00:06:34,979
saying we want to namespace it by this

00:06:31,830 --> 00:06:36,419
particular date and time so if the key

00:06:34,979 --> 00:06:38,099
idea you're trying to use doesn't have a

00:06:36,419 --> 00:06:39,690
notion of buckets you just prepend

00:06:38,099 --> 00:06:42,080
something before the key and then you

00:06:39,690 --> 00:06:45,030
add a slash or a dash or whatever and

00:06:42,080 --> 00:06:47,400
then the payload would be an array or a

00:06:45,030 --> 00:06:50,580
list of the cars inside that particular

00:06:47,400 --> 00:06:53,520
quadrant right so now we're going to try

00:06:50,580 --> 00:06:55,540
to walk through some Ruby code so we

00:06:53,520 --> 00:06:57,370
have a function called emit car

00:06:55,540 --> 00:06:59,590
location and it has a couple of

00:06:57,370 --> 00:07:00,520
arguments we have a car ID we have a

00:06:59,590 --> 00:07:03,040
color which is not necessarily

00:07:00,520 --> 00:07:04,450
meaningful here just for logging output

00:07:03,040 --> 00:07:08,200
and then we have a lot of to longitude

00:07:04,450 --> 00:07:10,540
we were faking that we're creating the

00:07:08,200 --> 00:07:13,090
bucket or in another example might just

00:07:10,540 --> 00:07:16,690
be the namespace so basically we're just

00:07:13,090 --> 00:07:17,770
creating that that black portion then

00:07:16,690 --> 00:07:19,180
we're just printing out some logging

00:07:17,770 --> 00:07:22,840
information so we can get an idea of

00:07:19,180 --> 00:07:24,880
what's going on then we're creating a

00:07:22,840 --> 00:07:27,940
data structure and we're adding the car

00:07:24,880 --> 00:07:30,940
ID to it right so this data structure is

00:07:27,940 --> 00:07:32,740
called G set so first question it

00:07:30,940 --> 00:07:34,810
probably pops up is what's a G set right

00:07:32,740 --> 00:07:39,520
I'm familiar with a set but what is this

00:07:34,810 --> 00:07:40,960
G set so a G set is is is a data

00:07:39,520 --> 00:07:44,190
structure that's categorized as a

00:07:40,960 --> 00:07:46,390
conflict-free replicated data type right

00:07:44,190 --> 00:07:48,970
most commonly these things are known as

00:07:46,390 --> 00:07:50,200
CR dt's rights just abbreviate taking

00:07:48,970 --> 00:07:53,140
the the first letter of each of those

00:07:50,200 --> 00:07:55,930
words crdt czar data data types that

00:07:53,140 --> 00:07:57,970
were designed for eventually consistent

00:07:55,930 --> 00:07:59,890
data stores right they were designed for

00:07:57,970 --> 00:08:01,180
systems that are based around eventual

00:07:59,890 --> 00:08:03,430
consistency they're not strongly

00:08:01,180 --> 00:08:04,900
consistent and all they do is they

00:08:03,430 --> 00:08:07,750
preserve the properties that you would

00:08:04,900 --> 00:08:10,540
expect out of the data structure but

00:08:07,750 --> 00:08:12,100
they don't walk they remain highly

00:08:10,540 --> 00:08:16,510
available and they have self healing

00:08:12,100 --> 00:08:23,020
properties so the G stands for grow only

00:08:16,510 --> 00:08:24,970
so it's a grow only set so set Union

00:08:23,020 --> 00:08:27,910
itself so if you have just the regular

00:08:24,970 --> 00:08:29,770
set and ruby the act of merging multiple

00:08:27,910 --> 00:08:33,090
sets together is commutative and

00:08:29,770 --> 00:08:36,849
convergent therefore it's always safe to

00:08:33,090 --> 00:08:38,919
have simultaneous rights which only

00:08:36,849 --> 00:08:40,570
allow addition so you're only allowed to

00:08:38,919 --> 00:08:43,720
add items to the site you're not allowed

00:08:40,570 --> 00:08:47,650
to remove them from the set so why might

00:08:43,720 --> 00:08:49,060
removing items from a set be bad it's

00:08:47,650 --> 00:08:50,770
bad because you don't want to have a

00:08:49,060 --> 00:08:52,240
scenario where you're removing cars from

00:08:50,770 --> 00:08:55,090
a particular quadrant or from a

00:08:52,240 --> 00:08:56,620
particular cell and they belong there so

00:08:55,090 --> 00:08:58,120
for example if you're requesting a car

00:08:56,620 --> 00:08:59,530
and there's one right outside you don't

00:08:58,120 --> 00:09:01,240
want a scenario to occur where that car

00:08:59,530 --> 00:09:02,980
gets removed from the list and you're

00:09:01,240 --> 00:09:05,110
getting a car dispatched from like down

00:09:02,980 --> 00:09:08,230
you know five blocks away when you have

00:09:05,110 --> 00:09:09,310
one sitting right outside so if we keep

00:09:08,230 --> 00:09:12,220
walking through the code

00:09:09,310 --> 00:09:14,260
here we're just creating a key we're

00:09:12,220 --> 00:09:15,820
passing a content type because we're

00:09:14,260 --> 00:09:17,860
communicating with with the back-end

00:09:15,820 --> 00:09:20,290
data store through HTTP and we're

00:09:17,860 --> 00:09:22,690
serializing that data structure to JSON

00:09:20,290 --> 00:09:24,580
so for this particular datatype this is

00:09:22,690 --> 00:09:26,890
what it might look like right so we have

00:09:24,580 --> 00:09:28,270
some information about what the type is

00:09:26,890 --> 00:09:30,160
because we need to know how to

00:09:28,270 --> 00:09:32,140
deserialize and serialize it and then we

00:09:30,160 --> 00:09:36,580
just have a list of items that are in

00:09:32,140 --> 00:09:39,370
this particular G set so now we move to

00:09:36,580 --> 00:09:42,520
the next phase here we have the set up

00:09:39,370 --> 00:09:44,110
location or where you're getting picked

00:09:42,520 --> 00:09:47,710
up from or where your request in the car

00:09:44,110 --> 00:09:50,440
from so again if we're assuming that you

00:09:47,710 --> 00:09:57,070
know you're in 00 this is where you're

00:09:50,440 --> 00:09:58,660
at so now the function or what it might

00:09:57,070 --> 00:10:00,130
look like to try to request the car

00:09:58,660 --> 00:10:01,330
right so you've already have the cars

00:10:00,130 --> 00:10:02,650
that are using the previous function

00:10:01,330 --> 00:10:04,930
adjust the omit the location

00:10:02,650 --> 00:10:06,100
periodically as they drive around but

00:10:04,930 --> 00:10:07,510
now you're trying to request the car

00:10:06,100 --> 00:10:12,610
from all the cars that are existing in

00:10:07,510 --> 00:10:14,710
the system so the request car function

00:10:12,610 --> 00:10:19,000
takes two arguments a latitude longitude

00:10:14,710 --> 00:10:20,890
your latitude longitude so we have a

00:10:19,000 --> 00:10:22,170
function here called closest blocks and

00:10:20,890 --> 00:10:24,850
we're passing it to latitude longitude

00:10:22,170 --> 00:10:27,940
all this function is basically doing is

00:10:24,850 --> 00:10:29,260
you're right here but most likely

00:10:27,940 --> 00:10:31,000
there's not going to be a car here so

00:10:29,260 --> 00:10:33,490
it's also getting the blocks that are

00:10:31,000 --> 00:10:35,110
immediately around you so that that way

00:10:33,490 --> 00:10:36,910
we can try to go through all of them to

00:10:35,110 --> 00:10:40,630
see we can keep doing that until we find

00:10:36,910 --> 00:10:41,650
a car that's in your area then we're

00:10:40,630 --> 00:10:44,530
just printing out some logging

00:10:41,650 --> 00:10:46,600
information that we're taking the output

00:10:44,530 --> 00:10:48,310
of the previous function we're just

00:10:46,600 --> 00:10:50,200
taking the keys out of it we're sorting

00:10:48,310 --> 00:10:53,680
them and then we're trying to iterate

00:10:50,200 --> 00:10:58,180
through them so what what does that look

00:10:53,680 --> 00:10:59,740
like so the output of the local grid

00:10:58,180 --> 00:11:02,620
this is what it might look like so the

00:10:59,740 --> 00:11:04,120
keys are the computed distance so we're

00:11:02,620 --> 00:11:05,320
assuming that the coordinates are

00:11:04,120 --> 00:11:07,690
latitude longitude but they're not

00:11:05,320 --> 00:11:09,010
really if we apply a function we can try

00:11:07,690 --> 00:11:11,410
to get an idea of how far they are from

00:11:09,010 --> 00:11:14,200
my location so I'm going through and I'm

00:11:11,410 --> 00:11:16,180
tabulating that math and then the value

00:11:14,200 --> 00:11:19,120
of this particular key is the latitude

00:11:16,180 --> 00:11:20,620
longitude coordinates so I'm sorting

00:11:19,120 --> 00:11:22,760
them by distance so that i can make sure

00:11:20,620 --> 00:11:24,890
that the first one i try to in

00:11:22,760 --> 00:11:26,270
act with is the closest one to me so

00:11:24,890 --> 00:11:31,640
that I don't start getting cars that are

00:11:26,270 --> 00:11:35,630
far away from me so now we want to try

00:11:31,640 --> 00:11:39,470
to get the closest car to my location so

00:11:35,630 --> 00:11:41,000
now if we go into this function get cars

00:11:39,470 --> 00:11:42,560
that location again we're passing a

00:11:41,000 --> 00:11:44,060
latitude longitude we're doing the same

00:11:42,560 --> 00:11:46,990
thing as before we're defining this

00:11:44,060 --> 00:11:49,340
particular bucket with the time stamp

00:11:46,990 --> 00:11:51,280
we're creating a new G set because we

00:11:49,340 --> 00:11:54,020
want to be populating things in it and

00:11:51,280 --> 00:11:57,950
then the next thing here is so up here

00:11:54,020 --> 00:12:00,970
we got an object from the data store for

00:11:57,950 --> 00:12:04,790
that particular latitude longitude pair

00:12:00,970 --> 00:12:06,260
we're checking its siblings so what are

00:12:04,790 --> 00:12:08,330
siblings so this is something that's a

00:12:06,260 --> 00:12:11,090
little bit more specific to react so in

00:12:08,330 --> 00:12:13,400
this case right here you would probably

00:12:11,090 --> 00:12:15,170
do this somewhat some differently in

00:12:13,400 --> 00:12:17,150
another key value store but this is how

00:12:15,170 --> 00:12:19,610
you would approach it in react so

00:12:17,150 --> 00:12:21,380
siblings in react are a mechanism to

00:12:19,610 --> 00:12:23,120
present prevent data loss when you have

00:12:21,380 --> 00:12:25,460
scenarios like concurrent rights or

00:12:23,120 --> 00:12:26,720
network partitions so I'm going to try

00:12:25,460 --> 00:12:29,000
to walk through an example of the last

00:12:26,720 --> 00:12:31,100
one and just explain like what might

00:12:29,000 --> 00:12:34,910
cause this particular scenario what what

00:12:31,100 --> 00:12:36,500
why these siblings are important so in a

00:12:34,910 --> 00:12:38,300
lot of distributed data stores you're

00:12:36,500 --> 00:12:40,490
writing data multiple times so you have

00:12:38,300 --> 00:12:42,530
multiple replicas of a particular piece

00:12:40,490 --> 00:12:44,540
of data throughout multiple machines in

00:12:42,530 --> 00:12:46,550
a cluster so we have a piece of data a

00:12:44,540 --> 00:12:47,960
we have three replicas we're going to

00:12:46,550 --> 00:12:50,420
assume that each of these replicas are

00:12:47,960 --> 00:12:52,430
on a different machine in the cluster so

00:12:50,420 --> 00:12:53,930
this line down the middle here is meant

00:12:52,430 --> 00:12:55,910
to illustrate a network partition so

00:12:53,930 --> 00:12:57,410
this is a scenario where nodes in your

00:12:55,910 --> 00:12:59,060
cluster can't talk to each other because

00:12:57,410 --> 00:13:00,680
something happened inside your data

00:12:59,060 --> 00:13:03,860
center or something happened in Amazon

00:13:00,680 --> 00:13:05,180
or whatever now we have application

00:13:03,860 --> 00:13:06,650
servers that might be talking to this

00:13:05,180 --> 00:13:08,060
data store we might have some on this

00:13:06,650 --> 00:13:10,880
side of the partition we might have some

00:13:08,060 --> 00:13:14,990
on this side right say one on this side

00:13:10,880 --> 00:13:16,280
rights be one on this side right see so

00:13:14,990 --> 00:13:18,110
now when the network partition goes away

00:13:16,280 --> 00:13:20,480
how do we know which one of these is

00:13:18,110 --> 00:13:22,730
supposed to win right a lot of times

00:13:20,480 --> 00:13:24,170
data stores will just pick the last one

00:13:22,730 --> 00:13:26,240
or whichever one is perceived to be the

00:13:24,170 --> 00:13:27,770
last one meaning you may lose beer you

00:13:26,240 --> 00:13:29,090
may lose see you don't necessarily know

00:13:27,770 --> 00:13:32,420
datastore doesn't know which one is

00:13:29,090 --> 00:13:35,600
actually right so what react does is

00:13:32,420 --> 00:13:36,620
it'll keep both you'll have B and you'll

00:13:35,600 --> 00:13:37,880
have seed because it

00:13:36,620 --> 00:13:41,390
can't figure out which one he needs to

00:13:37,880 --> 00:13:44,030
win and so in this scenario so going

00:13:41,390 --> 00:13:46,010
back to the uber example every time that

00:13:44,030 --> 00:13:48,170
we're adding cars to this G set we're

00:13:46,010 --> 00:13:52,340
effectively creating another one of

00:13:48,170 --> 00:13:54,500
these siblings so that there's a you

00:13:52,340 --> 00:13:55,880
know a set of siblings inside the data

00:13:54,500 --> 00:13:57,470
store and then this line right here

00:13:55,880 --> 00:13:58,850
you're basically going through all the

00:13:57,470 --> 00:14:01,340
siblings and you're applying that set

00:13:58,850 --> 00:14:03,380
Union so since it's only allowing

00:14:01,340 --> 00:14:04,880
addition you're never losing cars from

00:14:03,380 --> 00:14:06,800
that particular object you're just

00:14:04,880 --> 00:14:08,960
continually appending them which is

00:14:06,800 --> 00:14:10,700
producing the output which is the list

00:14:08,960 --> 00:14:14,360
of cars that are in you know the area

00:14:10,700 --> 00:14:15,950
that's closest to you and then here

00:14:14,360 --> 00:14:18,770
we're just taking that same thing and

00:14:15,950 --> 00:14:20,660
we're we're know that output of that set

00:14:18,770 --> 00:14:22,430
Union and we're sending it back to the

00:14:20,660 --> 00:14:24,830
data source saying look this is what I

00:14:22,430 --> 00:14:27,440
want you to persist so going back to the

00:14:24,830 --> 00:14:29,780
other example so you have this this list

00:14:27,440 --> 00:14:31,910
of siblings what we're doing is we're

00:14:29,780 --> 00:14:34,070
merging that together and we're sending

00:14:31,910 --> 00:14:36,170
it back as a new value so we're grabbing

00:14:34,070 --> 00:14:38,000
all the cars in that particular quadrant

00:14:36,170 --> 00:14:39,560
that particular location and we're

00:14:38,000 --> 00:14:41,090
sending that back we're saying persist

00:14:39,560 --> 00:14:42,620
this that the next person who tries to

00:14:41,090 --> 00:14:45,080
retrieve it gets this list it doesn't

00:14:42,620 --> 00:14:46,640
have to go through this process so

00:14:45,080 --> 00:14:48,580
you're paying the cost that read time as

00:14:46,640 --> 00:14:51,520
opposed to paying the cost at right time

00:14:48,580 --> 00:14:55,070
so once that whole process is done

00:14:51,520 --> 00:14:57,740
you're calling dot members which is just

00:14:55,070 --> 00:14:58,970
the API for the particular G set so it's

00:14:57,740 --> 00:15:01,360
how you're getting the elements out of

00:14:58,970 --> 00:15:03,920
it and if that's greater than zero then

00:15:01,360 --> 00:15:05,300
you have a car if not then you're going

00:15:03,920 --> 00:15:07,580
back to the top of the loop and you're

00:15:05,300 --> 00:15:08,960
going to the next block to identify

00:15:07,580 --> 00:15:11,060
whether there's a car in that area and

00:15:08,960 --> 00:15:12,530
you keep going until you know either you

00:15:11,060 --> 00:15:15,050
run out you go through too many and

00:15:12,530 --> 00:15:21,710
there's just nobody around you or you

00:15:15,050 --> 00:15:24,830
actually get a hit so the next thing

00:15:21,710 --> 00:15:27,410
here is just emphasized that what we

00:15:24,830 --> 00:15:30,410
went through was basically creating this

00:15:27,410 --> 00:15:31,820
G set on the client side right so we

00:15:30,410 --> 00:15:33,470
were we were creating this data

00:15:31,820 --> 00:15:35,090
structure we're defining it on the

00:15:33,470 --> 00:15:36,800
client side and we're used we're

00:15:35,090 --> 00:15:38,990
basically abusing the data store a

00:15:36,800 --> 00:15:42,440
little bit to give us the properties

00:15:38,990 --> 00:15:44,150
that we want around this G set in the

00:15:42,440 --> 00:15:46,100
next version of react we're including

00:15:44,150 --> 00:15:48,650
these data structures on the server side

00:15:46,100 --> 00:15:50,420
so what that means is that the API

00:15:48,650 --> 00:15:52,029
instead of a lot of that boilerplate

00:15:50,420 --> 00:15:55,100
a lot of that code that i showed before

00:15:52,029 --> 00:15:58,190
this is what it would look like you know

00:15:55,100 --> 00:16:00,320
you would just add cars to them add cars

00:15:58,190 --> 00:16:02,720
to this particular key and the datastore

00:16:00,320 --> 00:16:04,940
would merge siblings together would

00:16:02,720 --> 00:16:06,560
resolve these conflicts the same time

00:16:04,940 --> 00:16:07,880
you would just use that same pointer to

00:16:06,560 --> 00:16:10,820
that key and then you would get the

00:16:07,880 --> 00:16:14,600
members and you would have a list the

00:16:10,820 --> 00:16:16,970
the Ruby api for react specifically was

00:16:14,600 --> 00:16:19,100
actually developed by a guy that's

00:16:16,970 --> 00:16:21,230
sitting right here Bryce who gave a talk

00:16:19,100 --> 00:16:23,870
yesterday so if you have questions

00:16:21,230 --> 00:16:28,610
specifically about the Ruby client he's

00:16:23,870 --> 00:16:32,540
the person to ask so to try to you know

00:16:28,610 --> 00:16:34,399
wrap up the talk when when would doing

00:16:32,540 --> 00:16:37,579
all this stuff be attractive right so we

00:16:34,399 --> 00:16:39,709
walk through some note conceptually is

00:16:37,579 --> 00:16:40,910
not too difficult to understand how over

00:16:39,709 --> 00:16:43,579
might work but then there's some tricky

00:16:40,910 --> 00:16:46,190
parts there about modeling 2 G set about

00:16:43,579 --> 00:16:47,870
creating something that can work in an

00:16:46,190 --> 00:16:49,670
eventually consistent environment right

00:16:47,870 --> 00:16:52,660
and so that's a lot more complicated

00:16:49,670 --> 00:16:55,310
than just adding rows to a database and

00:16:52,660 --> 00:16:59,750
using whatever functionality it has to

00:16:55,310 --> 00:17:01,070
do geospatial queries right and so the

00:16:59,750 --> 00:17:03,620
answer to that is basically what I

00:17:01,070 --> 00:17:06,169
mentioned before is when these three

00:17:03,620 --> 00:17:08,360
things start impacting so it's not when

00:17:06,169 --> 00:17:10,010
you're trying to create an uber service

00:17:08,360 --> 00:17:11,390
for your local neighborhood it's when

00:17:10,010 --> 00:17:12,890
you're trying to create uber service for

00:17:11,390 --> 00:17:14,419
like the entire United States and you're

00:17:12,890 --> 00:17:17,240
trying to serve it out of the same you

00:17:14,419 --> 00:17:19,669
know data center or its if you're trying

00:17:17,240 --> 00:17:21,860
to ingest metrics out of a lot of

00:17:19,669 --> 00:17:24,140
consumer devices that are all across the

00:17:21,860 --> 00:17:26,360
world like if somebody has you know one

00:17:24,140 --> 00:17:27,620
of those activity monitors and you're

00:17:26,360 --> 00:17:28,790
trying to ingest the metrics that are

00:17:27,620 --> 00:17:31,780
getting admitted by those things you

00:17:28,790 --> 00:17:35,450
need a system that is highly available

00:17:31,780 --> 00:17:39,860
produces low latency or operates at low

00:17:35,450 --> 00:17:43,240
latency and can handle scale and with

00:17:39,860 --> 00:17:43,240

YouTube URL: https://www.youtube.com/watch?v=-_3Us7Ystyg


