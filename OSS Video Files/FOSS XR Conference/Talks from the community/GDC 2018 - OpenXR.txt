Title: GDC 2018 - OpenXR
Publication date: 2019-10-25
Playlist: Talks from the community
Description: 
	Slides: https://www.khronos.org/developers/library/2018-gdc

For the first time, we’ll give an update on the technical details of the of the OpenXR standard for virtual and augmented reality - created by the Khronos OpenXR working group. This includes the interfaces that applications will use to communicate with runtimes, as well as how new devices and interoperability are handled. Specifics of the technical challenges of developing the specification will be covered, as well as insights to the reasoning behind some of the decisions made by the working group on the architecture of the standard.
Captions: 
	00:00:00,000 --> 00:00:08,130
[Music]

00:00:05,420 --> 00:00:10,650
thanks everybody for coming my name is

00:00:08,130 --> 00:00:13,559
Nick whiting by day I'm a tech director

00:00:10,650 --> 00:00:15,480
at Epic Games and by night I work on

00:00:13,559 --> 00:00:18,090
standards like open XR I'm actually the

00:00:15,480 --> 00:00:19,980
the working group chair and today I have

00:00:18,090 --> 00:00:21,900
the privilege of presenting the work of

00:00:19,980 --> 00:00:24,269
a really talented group of folks and

00:00:21,900 --> 00:00:26,250
give you guys a first look at open XR

00:00:24,269 --> 00:00:30,060
which is what we jokingly referred to as

00:00:26,250 --> 00:00:32,189
standardizing all of the realities so

00:00:30,060 --> 00:00:33,540
the agenda for today will give you a

00:00:32,189 --> 00:00:35,790
quick note on what we'll cover and a

00:00:33,540 --> 00:00:38,190
little few proviso since this is a kind

00:00:35,790 --> 00:00:40,469
of pre-release preview of a spec that is

00:00:38,190 --> 00:00:42,390
still very much a work in progress by a

00:00:40,469 --> 00:00:44,329
lot of very talented folks in companies

00:00:42,390 --> 00:00:46,590
a few of which are in the room today

00:00:44,329 --> 00:00:50,100
I'll give you a kind of a brief history

00:00:46,590 --> 00:00:52,050
of this standard we kind of announced it

00:00:50,100 --> 00:00:53,280
beginning of last year so I figured I'd

00:00:52,050 --> 00:00:55,620
let you guys know what we've been up to

00:00:53,280 --> 00:00:58,260
hard at work I'm trying to converge on

00:00:55,620 --> 00:01:00,030
getting something out there then kind of

00:00:58,260 --> 00:01:02,129
an outline of the the problem that we're

00:01:00,030 --> 00:01:03,449
trying to solve with open XR and the

00:01:02,129 --> 00:01:06,060
things that we're trying to address and

00:01:03,449 --> 00:01:08,220
we kind of made a few philosophies as a

00:01:06,060 --> 00:01:09,299
working group that helped inform what we

00:01:08,220 --> 00:01:11,310
should concentrate on what we should

00:01:09,299 --> 00:01:13,260
move on from what we should just not

00:01:11,310 --> 00:01:15,270
even touch it all because it's too early

00:01:13,260 --> 00:01:17,040
and then the part that everybody's

00:01:15,270 --> 00:01:18,630
probably actually waiting for I'm gonna

00:01:17,040 --> 00:01:20,670
give a kind of high-level overview of a

00:01:18,630 --> 00:01:23,250
good bit of the standard we're not going

00:01:20,670 --> 00:01:24,600
to present any specification specific

00:01:23,250 --> 00:01:26,759
language here but we should give you a

00:01:24,600 --> 00:01:28,680
kind of good overview of how the system

00:01:26,759 --> 00:01:30,659
works what we cover how its extensible

00:01:28,680 --> 00:01:32,700
and then I'll kind of address where we

00:01:30,659 --> 00:01:33,900
go from here and at the very end I

00:01:32,700 --> 00:01:36,090
figured there's probably gonna be a lot

00:01:33,900 --> 00:01:37,590
of questions because this is the first

00:01:36,090 --> 00:01:40,110
kind of you know coming-out party for

00:01:37,590 --> 00:01:41,490
open XR so there should be ample time

00:01:40,110 --> 00:01:43,490
and at the end of the presentation for

00:01:41,490 --> 00:01:46,530
you guys to ask any questions you want

00:01:43,490 --> 00:01:49,020
so with that a few notes on what we'll

00:01:46,530 --> 00:01:50,790
cover so the the first proviso is

00:01:49,020 --> 00:01:52,680
actually the most important and this

00:01:50,790 --> 00:01:54,570
spec is still very much a work in

00:01:52,680 --> 00:01:57,469
progress it's it's pretty lengthy

00:01:54,570 --> 00:02:00,149
already I think 268 pages at last count

00:01:57,469 --> 00:02:02,189
and there's bits and pieces that are

00:02:00,149 --> 00:02:03,600
kind of in flux right now but overall

00:02:02,189 --> 00:02:04,950
the body of it has kind of taken shape

00:02:03,600 --> 00:02:07,049
and that's why the working group felt

00:02:04,950 --> 00:02:09,780
comfortable talking to you but that

00:02:07,049 --> 00:02:11,250
being said all this stuff is still

00:02:09,780 --> 00:02:12,650
subject to change right now we're going

00:02:11,250 --> 00:02:14,150
through a period

00:02:12,650 --> 00:02:15,680
starting to actually implement the spec

00:02:14,150 --> 00:02:19,040
ourselves a few people in the group are

00:02:15,680 --> 00:02:21,560
and like with any piece of software you

00:02:19,040 --> 00:02:23,810
know there's bugs in it so everything up

00:02:21,560 --> 00:02:25,099
here is not yet canonized this gospel

00:02:23,810 --> 00:02:28,489
truth but we're hoping to get there

00:02:25,099 --> 00:02:31,189
before too long so for this talk in

00:02:28,489 --> 00:02:32,959
general we assume that you guys know a

00:02:31,189 --> 00:02:34,939
little bit about VR and AR and how it

00:02:32,959 --> 00:02:37,099
works it kind of a general level a

00:02:34,939 --> 00:02:38,569
little bit about programming and you

00:02:37,099 --> 00:02:41,750
know you can get your way around a

00:02:38,569 --> 00:02:42,950
render loop decently but two things that

00:02:41,750 --> 00:02:44,329
we don't want to assume is that you know

00:02:42,950 --> 00:02:46,489
anything about the specification process

00:02:44,329 --> 00:02:48,680
because I know I sure did before a year

00:02:46,489 --> 00:02:50,450
ago and that you don't necessarily have

00:02:48,680 --> 00:02:52,579
any knowledge of other Curnow

00:02:50,450 --> 00:02:55,579
specifications so what will cover

00:02:52,579 --> 00:02:57,530
anything that should be new there and as

00:02:55,579 --> 00:02:58,459
I mentioned the spec is pretty lengthy

00:02:57,530 --> 00:03:00,290
and we're not going to cover the whole

00:02:58,459 --> 00:03:02,299
thing what we really wanted to focus on

00:03:00,290 --> 00:03:03,530
with this was just give you guys an

00:03:02,299 --> 00:03:05,359
initial preview of parts of the

00:03:03,530 --> 00:03:06,620
specification that are mostly well

00:03:05,359 --> 00:03:08,030
defined at this point and we felt

00:03:06,620 --> 00:03:10,010
comfortable kind of talking about it a

00:03:08,030 --> 00:03:11,780
higher level but there are entire

00:03:10,010 --> 00:03:12,950
systems that we aren't going to cover in

00:03:11,780 --> 00:03:14,510
this talk and we'll have to wait till

00:03:12,950 --> 00:03:17,109
the the release of the spec in a little

00:03:14,510 --> 00:03:19,129
bit and as I said there should be

00:03:17,109 --> 00:03:21,650
playing time for questions in the end

00:03:19,129 --> 00:03:23,150
the that kind of provides us with that

00:03:21,650 --> 00:03:25,370
or I can't answer any questions about

00:03:23,150 --> 00:03:26,900
systems that aren't stabilized and no

00:03:25,370 --> 00:03:29,690
you can't ask when it'll be released but

00:03:26,900 --> 00:03:32,720
I'm sure one of you will that's how it

00:03:29,690 --> 00:03:34,669
always goes all right so a brief history

00:03:32,720 --> 00:03:37,190
of the standard so it started about a

00:03:34,669 --> 00:03:39,139
year ago but the standard is really

00:03:37,190 --> 00:03:41,359
comprised of a whole bunch of companies

00:03:39,139 --> 00:03:42,620
that you know when we first announced

00:03:41,359 --> 00:03:44,120
the standard people like how are you

00:03:42,620 --> 00:03:45,739
going to get these people to work

00:03:44,120 --> 00:03:48,109
together there's no way that company X

00:03:45,739 --> 00:03:50,989
will join in a standard with company Y

00:03:48,109 --> 00:03:52,609
and as you can see from the the images

00:03:50,989 --> 00:03:53,870
up there that's not even all the people

00:03:52,609 --> 00:03:55,129
that are involved in the spec these are

00:03:53,870 --> 00:03:57,169
the people that were willing to put

00:03:55,129 --> 00:03:59,479
their logos up at this early stage but

00:03:57,169 --> 00:04:01,849
you can see then open XR is kind of

00:03:59,479 --> 00:04:04,669
successfully got dogs and cats to live

00:04:01,849 --> 00:04:07,099
together in harmony a little bit epic is

00:04:04,669 --> 00:04:09,709
up there with unity and oculus with

00:04:07,099 --> 00:04:11,120
valve and it's actually been really

00:04:09,709 --> 00:04:11,900
great and very collaborative I think

00:04:11,120 --> 00:04:13,430
that's one of the things that's

00:04:11,900 --> 00:04:15,709
impressed me most about the entire

00:04:13,430 --> 00:04:17,209
effort is that everybody wants this

00:04:15,709 --> 00:04:18,470
thing to succeed and so everybody's

00:04:17,209 --> 00:04:21,200
willing to work very hard and very

00:04:18,470 --> 00:04:24,380
cooperatively on some thorny engineering

00:04:21,200 --> 00:04:25,740
issues so it's been very refreshing and

00:04:24,380 --> 00:04:26,940
I think if

00:04:25,740 --> 00:04:29,069
thing else to take away from this talk

00:04:26,940 --> 00:04:30,750
is that open XR has legs because of the

00:04:29,069 --> 00:04:32,910
participation of all these companies in

00:04:30,750 --> 00:04:34,860
here and a lot of them have publicly

00:04:32,910 --> 00:04:37,889
committed to adopting the standards in

00:04:34,860 --> 00:04:40,440
the very near term so keep that in mind

00:04:37,889 --> 00:04:42,090
as we go through the rest is as for a

00:04:40,440 --> 00:04:44,669
brief history as I mentioned last year

00:04:42,090 --> 00:04:47,460
was kind of our coming-out our initial

00:04:44,669 --> 00:04:49,560
announcement of the exploratory group we

00:04:47,460 --> 00:04:51,870
sent one of our members Joe Ludwig from

00:04:49,560 --> 00:04:53,880
valve on a lightning-quick day trip from

00:04:51,870 --> 00:04:55,560
Seattle to Korea to propose it to the

00:04:53,880 --> 00:04:56,520
technical advisory panel and see if

00:04:55,560 --> 00:04:58,199
there was an interest in it

00:04:56,520 --> 00:05:00,690
unfortunately there was quite a big

00:04:58,199 --> 00:05:02,460
interest so the group started generating

00:05:00,690 --> 00:05:04,080
a statement of work basically deciding

00:05:02,460 --> 00:05:05,819
what should we put in the spec what

00:05:04,080 --> 00:05:07,949
should we try to put in the spec kind of

00:05:05,819 --> 00:05:09,840
thorny issues like should it be a VR and

00:05:07,949 --> 00:05:12,810
AR spec should we do one or the other

00:05:09,840 --> 00:05:14,880
and then save one for a later version we

00:05:12,810 --> 00:05:16,650
kind of got that all sussed out and then

00:05:14,880 --> 00:05:19,889
we put out a call for participation and

00:05:16,650 --> 00:05:21,539
actually right over there last year we

00:05:19,889 --> 00:05:23,130
had a panel that kind of announced us as

00:05:21,539 --> 00:05:26,130
an official working group and we kind of

00:05:23,130 --> 00:05:27,720
began work there we we started kicking

00:05:26,130 --> 00:05:31,830
it off at the winter face to face

00:05:27,720 --> 00:05:33,150
January year ago in Vancouver and it was

00:05:31,830 --> 00:05:34,440
nice because we had three or four

00:05:33,150 --> 00:05:36,210
different companies that came up and

00:05:34,440 --> 00:05:37,919
actually proposed specifications as a

00:05:36,210 --> 00:05:39,120
starting point from it because that was

00:05:37,919 --> 00:05:40,919
one of the things we wanted to have kind

00:05:39,120 --> 00:05:42,060
of a strongman proposal in order to kind

00:05:40,919 --> 00:05:44,880
of suss out some of the technical issues

00:05:42,060 --> 00:05:46,669
and that multiple members of the working

00:05:44,880 --> 00:05:48,810
group actually put up fully fleshed out

00:05:46,669 --> 00:05:50,099
specifications for it so we had a good

00:05:48,810 --> 00:05:52,949
starting point and we kind of

00:05:50,099 --> 00:05:54,479
unanimously approved picking

00:05:52,949 --> 00:05:57,210
oculus contribution which was at the

00:05:54,479 --> 00:05:58,770
time called Aetna to be our kind of

00:05:57,210 --> 00:06:01,889
starting point and that was based on

00:05:58,770 --> 00:06:06,030
their work on merging their desktop rift

00:06:01,889 --> 00:06:09,030
API and the gear VR API over the next

00:06:06,030 --> 00:06:11,250
two face two phases we started actually

00:06:09,030 --> 00:06:12,419
working on chopping up the spec and just

00:06:11,250 --> 00:06:13,860
kind of doing the heavy lifting you know

00:06:12,419 --> 00:06:15,830
take the car apart and get ready to put

00:06:13,860 --> 00:06:19,080
it back together on the garage floor

00:06:15,830 --> 00:06:21,060
there's a face-to-face in Amsterdam we

00:06:19,080 --> 00:06:22,169
do them quarterly with Chronos but there

00:06:21,060 --> 00:06:23,849
was so much work to be done that we

00:06:22,169 --> 00:06:25,440
actually decided we needed an interim

00:06:23,849 --> 00:06:27,810
face-to-face to get together and kind of

00:06:25,440 --> 00:06:30,479
suss out some of the language so we did

00:06:27,810 --> 00:06:33,210
that in July last year at valves offices

00:06:30,479 --> 00:06:34,800
in Washington before our big kind of

00:06:33,210 --> 00:06:36,750
next milestone which was last fall's

00:06:34,800 --> 00:06:38,729
face to face in September in Chicago

00:06:36,750 --> 00:06:39,569
where the working group is like okay

00:06:38,729 --> 00:06:40,649
we've kind of talked

00:06:39,569 --> 00:06:42,300
about this enough we really need to

00:06:40,649 --> 00:06:45,240
start chopping things down and deciding

00:06:42,300 --> 00:06:47,610
where we're going to plant our line in

00:06:45,240 --> 00:06:50,279
the sand in order to define an MVP

00:06:47,610 --> 00:06:52,319
product so at Chicago we had a lot of

00:06:50,279 --> 00:06:53,759
fun deliberation over a long list of

00:06:52,319 --> 00:06:55,709
bulleted points on what would be MVP

00:06:53,759 --> 00:06:58,589
what would not be MVP who cared about

00:06:55,709 --> 00:07:00,659
what was anybody willing to stand up and

00:06:58,589 --> 00:07:03,179
propose feature so we had a pretty good

00:07:00,659 --> 00:07:05,119
idea as of last fall what was going to

00:07:03,179 --> 00:07:07,770
be in the final version of the spec and

00:07:05,119 --> 00:07:09,629
again we had more face-to-face as

00:07:07,770 --> 00:07:11,490
quarterly but we had so much work to do

00:07:09,629 --> 00:07:13,830
especially after defining what it wasn't

00:07:11,490 --> 00:07:15,539
in the first version of the spec that we

00:07:13,830 --> 00:07:19,559
ended up having another interim

00:07:15,539 --> 00:07:21,930
face-to-face at valve and basically at

00:07:19,559 --> 00:07:24,300
Taipei in January of this year we said

00:07:21,930 --> 00:07:25,169
okay now that we would find this MVP we

00:07:24,300 --> 00:07:27,089
want people to start actually

00:07:25,169 --> 00:07:28,830
implementing the runtimes that it can

00:07:27,089 --> 00:07:30,599
adhere to the spec and make applications

00:07:28,830 --> 00:07:31,709
that adhere to the spec so that we can

00:07:30,599 --> 00:07:33,839
start sussing out all kind of

00:07:31,709 --> 00:07:35,789
last-minute bugs with it and so at

00:07:33,839 --> 00:07:36,990
Taipei we kind of suss out the last

00:07:35,789 --> 00:07:38,899
issues for that and now people are

00:07:36,990 --> 00:07:41,669
actually starting to implement and run

00:07:38,899 --> 00:07:44,159
open XR compliant runtimes and

00:07:41,669 --> 00:07:45,930
applications and here we are at GDC

00:07:44,159 --> 00:07:47,009
right now right here and you guys are

00:07:45,930 --> 00:07:49,469
getting the first look at the

00:07:47,009 --> 00:07:50,819
specification there's some stuff that's

00:07:49,469 --> 00:07:53,249
coming in the future which I'll cover at

00:07:50,819 --> 00:07:56,490
the end of the slide but that's kind of

00:07:53,249 --> 00:07:58,169
our history up into this point now under

00:07:56,490 --> 00:08:03,180
kind of goals and philosophies of the

00:07:58,169 --> 00:08:05,189
specification so the problem space as we

00:08:03,180 --> 00:08:07,199
see it with open XR is that the

00:08:05,189 --> 00:08:09,300
ecosystem right now for V RNA our apps

00:08:07,199 --> 00:08:10,729
kind of looks like this you have a whole

00:08:09,300 --> 00:08:12,719
bunch of applications they either

00:08:10,729 --> 00:08:14,509
integrate directly with a bunch of

00:08:12,719 --> 00:08:16,919
runtimes that are proprietary per

00:08:14,509 --> 00:08:19,589
company or they go through an engine

00:08:16,919 --> 00:08:20,930
which then has a bunch of plugins or

00:08:19,589 --> 00:08:24,779
some other systems to connect to those

00:08:20,930 --> 00:08:27,089
api's and then all those API is kind of

00:08:24,779 --> 00:08:28,860
connect to their own devices and what

00:08:27,089 --> 00:08:31,259
that leads to is a lot of kind of market

00:08:28,860 --> 00:08:33,719
fragmentation the the V RNA our market

00:08:31,259 --> 00:08:35,219
right now is pretty small and if you're

00:08:33,719 --> 00:08:37,050
an application developer you need to hit

00:08:35,219 --> 00:08:39,000
as large of that addressable market as

00:08:37,050 --> 00:08:40,229
possible so that implies that you've got

00:08:39,000 --> 00:08:44,009
to either integrate with all these

00:08:40,229 --> 00:08:46,709
different kind of runtime targets or you

00:08:44,009 --> 00:08:48,959
have to use an engine that does that for

00:08:46,709 --> 00:08:51,360
you so part of the motivation for open

00:08:48,959 --> 00:08:52,920
XR was very selfish in that I run the

00:08:51,360 --> 00:08:54,389
Unreal Engine X R Department and I want

00:08:52,920 --> 00:08:55,860
to save myself work so I tried to get

00:08:54,389 --> 00:08:58,290
everybody together to make one single

00:08:55,860 --> 00:09:00,000
specification but it's also kind of

00:08:58,290 --> 00:09:01,200
presents a problem from the other end of

00:09:00,000 --> 00:09:02,850
the the slides and that if you're a

00:09:01,200 --> 00:09:04,350
hardware manufacturer or you have uh

00:09:02,850 --> 00:09:06,630
some sort of specialty peripheral it's

00:09:04,350 --> 00:09:08,370
very hard for you to convince

00:09:06,630 --> 00:09:09,779
application developers to support your

00:09:08,370 --> 00:09:11,160
peripheral because that implies more

00:09:09,779 --> 00:09:13,410
work and more engineering effort and

00:09:11,160 --> 00:09:14,850
more cost for them so people that make

00:09:13,410 --> 00:09:15,990
new peripherals and will not end up kind

00:09:14,850 --> 00:09:18,089
of getting lost in the noise a little

00:09:15,990 --> 00:09:19,260
bit because it's very hard for them

00:09:18,089 --> 00:09:20,699
without just throwing money at

00:09:19,260 --> 00:09:25,199
application developers to get them to

00:09:20,699 --> 00:09:27,389
integrate into their ecosystem so the

00:09:25,199 --> 00:09:30,029
solution as the open XR group sees it is

00:09:27,389 --> 00:09:32,220
to create a open XR standard that has

00:09:30,029 --> 00:09:36,000
kind of two phases one is a application

00:09:32,220 --> 00:09:38,579
facing specification and one is the what

00:09:36,000 --> 00:09:41,730
we call the device plug-in extension on

00:09:38,579 --> 00:09:44,100
there so the application facing API is a

00:09:41,730 --> 00:09:45,570
netbook is a API that all runtimes have

00:09:44,100 --> 00:09:48,000
to implement and that's what allows the

00:09:45,570 --> 00:09:50,850
applications to talk to the open XR

00:09:48,000 --> 00:09:53,339
runtimes on the other side of that coin

00:09:50,850 --> 00:09:55,680
is the plug-in extension which basically

00:09:53,339 --> 00:09:57,720
lets arbitrary devices kind of talk to

00:09:55,680 --> 00:09:59,459
open XR runtimes and that's really the

00:09:57,720 --> 00:10:01,740
magic that lets one runtime talk to a

00:09:59,459 --> 00:10:04,440
bunch of different devices and really

00:10:01,740 --> 00:10:05,550
opens up the ecosystem so we we think

00:10:04,440 --> 00:10:07,740
that a lot of people will end up at

00:10:05,550 --> 00:10:09,269
implementing runtimes and we hope that a

00:10:07,740 --> 00:10:10,740
lot of them will actually implement the

00:10:09,269 --> 00:10:13,860
device plug-in extension to make their

00:10:10,740 --> 00:10:17,279
devices cross compatible with all the

00:10:13,860 --> 00:10:20,370
other runtimes so the kind of flow is

00:10:17,279 --> 00:10:22,740
that the application does its rendering

00:10:20,370 --> 00:10:24,870
sends its imagery down to the open XR

00:10:22,740 --> 00:10:26,910
runtime and the open XR runtime

00:10:24,870 --> 00:10:28,560
processes that it handles composition

00:10:26,910 --> 00:10:30,390
handles distortion handles sending out

00:10:28,560 --> 00:10:31,980
haptic events and then presents that to

00:10:30,390 --> 00:10:34,380
the device and at the same time it sends

00:10:31,980 --> 00:10:36,149
tracking information up from the runtime

00:10:34,380 --> 00:10:38,069
for the devices and input information up

00:10:36,149 --> 00:10:39,480
to the application so as far as the

00:10:38,069 --> 00:10:44,459
application is concerned it's kind of a

00:10:39,480 --> 00:10:46,079
single target that it has to aim for and

00:10:44,459 --> 00:10:48,660
to help us with these goals we kind of

00:10:46,079 --> 00:10:50,760
done decided on four philosophies as a

00:10:48,660 --> 00:10:52,560
working group that helped kind of guide

00:10:50,760 --> 00:10:55,110
what we decided to work on how we frame

00:10:52,560 --> 00:10:56,550
those api's when we work on them the

00:10:55,110 --> 00:10:59,720
first one is that we really wanted to

00:10:56,550 --> 00:11:02,459
enable both VR and AR applications

00:10:59,720 --> 00:11:04,230
basically the the X and open XR started

00:11:02,459 --> 00:11:06,130
as joke on a PowerPoint when we said if

00:11:04,230 --> 00:11:09,070
we put a V on top of an A

00:11:06,130 --> 00:11:10,540
it makes an X and that was really is

00:11:09,070 --> 00:11:11,980
about as much thought as was put into it

00:11:10,540 --> 00:11:13,390
everybody just kind of liked the idea

00:11:11,980 --> 00:11:16,510
and it was one of those things that was

00:11:13,390 --> 00:11:18,150
kind of so stupid it worked but if

00:11:16,510 --> 00:11:22,510
nothing else we wanted to really kind of

00:11:18,150 --> 00:11:24,760
clean up the ecosystem of you know MRX

00:11:22,510 --> 00:11:27,160
are a are there's there's some other ARS

00:11:24,760 --> 00:11:28,330
that are coming out now we said XR is a

00:11:27,160 --> 00:11:30,580
good kind of catch-all term for that

00:11:28,330 --> 00:11:32,590
what we define XR is something that has

00:11:30,580 --> 00:11:34,390
real-world sensor data that's being fed

00:11:32,590 --> 00:11:37,210
into a device whether or not that device

00:11:34,390 --> 00:11:39,610
displays or anything is kind of up to up

00:11:37,210 --> 00:11:41,890
to the runtime but we really wanted to

00:11:39,610 --> 00:11:43,690
make a common API that unified a lot of

00:11:41,890 --> 00:11:47,440
those concepts that are common to all XR

00:11:43,690 --> 00:11:50,470
devices the second is that we really

00:11:47,440 --> 00:11:52,570
wanted to be future-proof so the first

00:11:50,470 --> 00:11:54,700
version of the spec open XR 1.0 was kind

00:11:52,570 --> 00:11:57,580
of focused on current devices and

00:11:54,700 --> 00:11:59,050
near-term devices but the standard is

00:11:57,580 --> 00:12:01,750
really built around being extremely

00:11:59,050 --> 00:12:03,220
flexible so that you can not only target

00:12:01,750 --> 00:12:05,560
those kind of current devices but allow

00:12:03,220 --> 00:12:07,480
future innovations and developments to

00:12:05,560 --> 00:12:10,390
kind of be gracefully folded into the

00:12:07,480 --> 00:12:12,760
ecosystem so when I talk about a lot of

00:12:10,390 --> 00:12:14,920
these things they have expansions where

00:12:12,760 --> 00:12:16,570
if you pass in a struct there's ability

00:12:14,920 --> 00:12:18,220
to pass in more data as kind of payloads

00:12:16,570 --> 00:12:20,520
very similar to how volcán works you can

00:12:18,220 --> 00:12:22,720
have extensions to the API just like

00:12:20,520 --> 00:12:24,070
Vulcan and what we really wanted to do

00:12:22,720 --> 00:12:25,900
was make sure we don't paint ourselves

00:12:24,070 --> 00:12:30,430
out of any corners of precluding any

00:12:25,900 --> 00:12:31,690
type of device coming in kind of along

00:12:30,430 --> 00:12:33,310
those lines we thought it would be

00:12:31,690 --> 00:12:35,200
pretty foolish of us to kind of try to

00:12:33,310 --> 00:12:37,480
predict the future of X our technology I

00:12:35,200 --> 00:12:38,590
mean if you've been following AR and VR

00:12:37,480 --> 00:12:40,540
developments in the past few years

00:12:38,590 --> 00:12:42,520
you've noticed that there's nothing if

00:12:40,540 --> 00:12:44,590
not a lot of crazy wacky ideas that want

00:12:42,520 --> 00:12:45,850
to kind of find their feet you know

00:12:44,590 --> 00:12:47,980
there's kind of the standard devices

00:12:45,850 --> 00:12:49,510
that are in there that carry the 3.46

00:12:47,980 --> 00:12:52,540
off now we start to have inside out

00:12:49,510 --> 00:12:54,160
tracking versus outside in tracking but

00:12:52,540 --> 00:12:55,240
what we really wanted to decide was you

00:12:54,160 --> 00:12:56,980
know we don't know if somebody's going

00:12:55,240 --> 00:12:58,240
to make a crazy shoe based controller

00:12:56,980 --> 00:12:59,800
that's going to be something that you

00:12:58,240 --> 00:13:00,160
know catches on and it's actually super

00:12:59,800 --> 00:13:02,560
cool

00:13:00,160 --> 00:13:04,510
so what we wanted to do is make the API

00:13:02,560 --> 00:13:06,910
as flexible as possible kind of codify

00:13:04,510 --> 00:13:08,740
the concepts that are unique to

00:13:06,910 --> 00:13:10,060
everything but for things like input and

00:13:08,740 --> 00:13:12,130
display timing and whatnot make those

00:13:10,060 --> 00:13:16,330
very extensible so it's easy for people

00:13:12,130 --> 00:13:17,980
to kind of drop in and number four which

00:13:16,330 --> 00:13:19,900
is one of my personal favorites again as

00:13:17,980 --> 00:13:22,540
an engine developer is unified

00:13:19,900 --> 00:13:25,900
the performance critical concepts in XR

00:13:22,540 --> 00:13:28,600
application development so if you target

00:13:25,900 --> 00:13:32,890
even two similar devices like an oculus

00:13:28,600 --> 00:13:35,560
rift versus a HTC vive with steamvr

00:13:32,890 --> 00:13:36,910
things like frame timing are done subtly

00:13:35,560 --> 00:13:39,160
differently but in a way that really

00:13:36,910 --> 00:13:40,810
makes it hard for our engines render

00:13:39,160 --> 00:13:42,010
pipe to kind of adapt to it so one of

00:13:40,810 --> 00:13:44,980
the things that we really wanted to

00:13:42,010 --> 00:13:46,990
settle on as part of open XR was how do

00:13:44,980 --> 00:13:48,640
we take these things that affect device

00:13:46,990 --> 00:13:50,110
performance and make them codified so

00:13:48,640 --> 00:13:52,510
you can at least build to one kind of

00:13:50,110 --> 00:13:54,760
pattern of target even though it's

00:13:52,510 --> 00:13:55,990
there's no promises that without content

00:13:54,760 --> 00:13:58,690
modification you can make something that

00:13:55,990 --> 00:14:00,460
runs on a you know really badass gaming

00:13:58,690 --> 00:14:02,500
rank run on a mobile phone that we don't

00:14:00,460 --> 00:14:03,820
try to do that but what we want to do is

00:14:02,500 --> 00:14:05,200
make sure that the performance and the

00:14:03,820 --> 00:14:06,820
timing of your render pipe is similar

00:14:05,200 --> 00:14:08,290
across both platforms so that you can

00:14:06,820 --> 00:14:09,370
kind of target and optimize your content

00:14:08,290 --> 00:14:12,480
to one and know that it's going to be a

00:14:09,370 --> 00:14:15,490
reasonably good approximation on another

00:14:12,480 --> 00:14:18,220
now in order to do that there's kind of

00:14:15,490 --> 00:14:19,990
two approaches to runtimes that we think

00:14:18,220 --> 00:14:22,630
people will take as I said if you're an

00:14:19,990 --> 00:14:24,310
open X are compatible runtime you have

00:14:22,630 --> 00:14:25,710
the open XR application layer so that

00:14:24,310 --> 00:14:28,420
applications can talk to your runtime

00:14:25,710 --> 00:14:29,560
but one of the things that was important

00:14:28,420 --> 00:14:31,120
to a lot of the members of the group was

00:14:29,560 --> 00:14:33,220
that they didn't necessarily have to

00:14:31,120 --> 00:14:34,600
support multiple plug-in device

00:14:33,220 --> 00:14:35,670
extensions and there's kind of two

00:14:34,600 --> 00:14:38,590
reasons for that

00:14:35,670 --> 00:14:40,750
one is that some platforms some mobile

00:14:38,590 --> 00:14:42,100
platforms especially have very strict

00:14:40,750 --> 00:14:44,350
security requirements and it's not

00:14:42,100 --> 00:14:45,640
always possible to load in drivers that

00:14:44,350 --> 00:14:48,280
are required for them to kind of

00:14:45,640 --> 00:14:49,600
abstractly support a device plugin the

00:14:48,280 --> 00:14:52,180
other one is there are some you know

00:14:49,600 --> 00:14:53,920
economic considerations here where you

00:14:52,180 --> 00:14:55,960
know exclusive content may not want to

00:14:53,920 --> 00:14:58,180
work on all devices but we still think

00:14:55,960 --> 00:15:00,130
that it's important for the application

00:14:58,180 --> 00:15:02,740
developers to be able to target an open

00:15:00,130 --> 00:15:04,570
XR runtime even if they have to have

00:15:02,740 --> 00:15:05,950
multiple runtimes on the machine it

00:15:04,570 --> 00:15:07,740
still means that the application

00:15:05,950 --> 00:15:11,320
developers can target kind of a single

00:15:07,740 --> 00:15:14,200
specification the other side of this is

00:15:11,320 --> 00:15:15,970
runtime B which actually implements the

00:15:14,200 --> 00:15:18,490
device plug-in extension layer and what

00:15:15,970 --> 00:15:21,430
that means is that that runtime handles

00:15:18,490 --> 00:15:23,920
composition but what it passes off on to

00:15:21,430 --> 00:15:25,810
devices it can take arbitrary devices in

00:15:23,920 --> 00:15:28,440
so maybe it works with an oculus and a

00:15:25,810 --> 00:15:30,640
rift and a Google device or some other

00:15:28,440 --> 00:15:32,770
kind of more specialized or bespoke

00:15:30,640 --> 00:15:33,430
hardware we hope that a lot of people

00:15:32,770 --> 00:15:34,870
kind of into

00:15:33,430 --> 00:15:36,040
great the the device plug-in extension

00:15:34,870 --> 00:15:37,149
because we hopefully have made it

00:15:36,040 --> 00:15:38,950
flexible enough that it shouldn't

00:15:37,149 --> 00:15:43,240
preclude any sort of device from being

00:15:38,950 --> 00:15:45,040
integrated into the ecosystem one of the

00:15:43,240 --> 00:15:47,200
other big things if you're familiar with

00:15:45,040 --> 00:15:49,839
Vulcan you know that Vulcan is a layered

00:15:47,200 --> 00:15:52,000
API we wanted to make sure that open XR

00:15:49,839 --> 00:15:53,560
took the best parts of Vulcan you know

00:15:52,000 --> 00:15:57,459
cribbed off of their their cheat sheet a

00:15:53,560 --> 00:15:59,830
little bit but it's a layered API so if

00:15:57,459 --> 00:16:01,630
you look at the application looking at

00:15:59,830 --> 00:16:03,160
talking to the applicator the

00:16:01,630 --> 00:16:05,200
application talking to the application

00:16:03,160 --> 00:16:06,730
layer talking to the runtime where you

00:16:05,200 --> 00:16:08,500
see those red lines or where you can

00:16:06,730 --> 00:16:10,330
actually insert layers into there and

00:16:08,500 --> 00:16:11,830
what layers do is instead of the

00:16:10,330 --> 00:16:13,990
application calling directly into the

00:16:11,830 --> 00:16:16,600
runtime you can kind of shim function

00:16:13,990 --> 00:16:18,190
calls into the middle so it's useful for

00:16:16,600 --> 00:16:19,390
things like debugging information that

00:16:18,190 --> 00:16:20,649
you don't want to necessarily have at

00:16:19,390 --> 00:16:22,510
runtime but it's useful as you're

00:16:20,649 --> 00:16:24,940
developing an app the nice thing about

00:16:22,510 --> 00:16:26,380
it using that as a layer is that you can

00:16:24,940 --> 00:16:28,330
easily just turn that off and not run

00:16:26,380 --> 00:16:29,680
with the penalties that you would have

00:16:28,330 --> 00:16:30,820
to pay for it to record extra

00:16:29,680 --> 00:16:31,839
information about the state of the

00:16:30,820 --> 00:16:33,520
system

00:16:31,839 --> 00:16:35,830
there's also verification layers that

00:16:33,520 --> 00:16:37,510
you can insert to basically for an

00:16:35,830 --> 00:16:39,010
application to check am I using the API

00:16:37,510 --> 00:16:40,300
right am i calling these functions in

00:16:39,010 --> 00:16:42,760
the right order did I do something

00:16:40,300 --> 00:16:44,230
incredibly stupid you can help catch

00:16:42,760 --> 00:16:46,630
those without paying that runtime

00:16:44,230 --> 00:16:47,890
performance penalty another interesting

00:16:46,630 --> 00:16:50,350
one that we think that will come up is

00:16:47,890 --> 00:16:53,350
performance and profiling layers there's

00:16:50,350 --> 00:16:55,330
a lot of interesting challenges with air

00:16:53,350 --> 00:16:58,300
and V are apps revolving around timing

00:16:55,330 --> 00:16:59,320
and being able to insert a layer into

00:16:58,300 --> 00:17:00,940
there then get that timing information

00:16:59,320 --> 00:17:03,070
and kind of visualize what's happening

00:17:00,940 --> 00:17:04,390
when you miss a frame for instance we

00:17:03,070 --> 00:17:08,230
think will be very useful so this is a

00:17:04,390 --> 00:17:11,220
core part of the API that we enable with

00:17:08,230 --> 00:17:13,929
that we'll get into the standard itself

00:17:11,220 --> 00:17:15,400
so the the first thing I want to go over

00:17:13,929 --> 00:17:19,480
some of the kind of conventions and

00:17:15,400 --> 00:17:22,030
primitives that we use in open XR so for

00:17:19,480 --> 00:17:23,860
objects that are kind of allocated by

00:17:22,030 --> 00:17:26,230
the runtime on behalf of the application

00:17:23,860 --> 00:17:27,579
we represent with handles these aren't

00:17:26,230 --> 00:17:29,500
reference counted handles so you have to

00:17:27,579 --> 00:17:31,960
be careful because the application

00:17:29,500 --> 00:17:33,670
itself manages the scope so they're kind

00:17:31,960 --> 00:17:35,290
of opaque to the underlying object you

00:17:33,670 --> 00:17:36,940
can't you know query a handle about the

00:17:35,290 --> 00:17:38,380
instance and say you know what what's

00:17:36,940 --> 00:17:39,910
your internal state but you have to pass

00:17:38,380 --> 00:17:43,480
these into a lot of the functions

00:17:39,910 --> 00:17:45,040
because we are a C style API generally

00:17:43,480 --> 00:17:46,970
the lifetime is managed with create and

00:17:45,040 --> 00:17:50,150
destroy so as the application

00:17:46,970 --> 00:17:51,650
goes in and out of ER AR mode it can

00:17:50,150 --> 00:17:54,020
create and destroy handles as needed or

00:17:51,650 --> 00:17:56,510
if the instance needs to update under

00:17:54,020 --> 00:17:58,190
the hood you can destroy the handle and

00:17:56,510 --> 00:18:01,010
allocate a new one when you're ready to

00:17:58,190 --> 00:18:02,630
go again one one thing to point out

00:18:01,010 --> 00:18:04,880
about this is that the handles are

00:18:02,630 --> 00:18:06,500
hierarchical in a lot of cases so as

00:18:04,880 --> 00:18:07,490
we'll get to in a few minutes we have an

00:18:06,500 --> 00:18:09,290
instance which is kind of the

00:18:07,490 --> 00:18:10,700
applications view of the runtime and

00:18:09,290 --> 00:18:12,620
within that instance we have a system

00:18:10,700 --> 00:18:15,140
which represents the devices that you're

00:18:12,620 --> 00:18:17,150
actually using in the runtime so

00:18:15,140 --> 00:18:18,380
instances are only valid for their

00:18:17,150 --> 00:18:19,760
parent handles and there's a couple

00:18:18,380 --> 00:18:22,030
other things like input that are only

00:18:19,760 --> 00:18:24,200
valid within the scope of their parent

00:18:22,030 --> 00:18:26,090
we enumerate those again for

00:18:24,200 --> 00:18:28,160
extensibility by using an X our object

00:18:26,090 --> 00:18:30,380
type of numeration so yeah we hope we

00:18:28,160 --> 00:18:32,180
can slot in new ones as extensions need

00:18:30,380 --> 00:18:33,710
to if you need to add a handle type it's

00:18:32,180 --> 00:18:37,310
there for you you just change the object

00:18:33,710 --> 00:18:38,840
type another one of the core concepts of

00:18:37,310 --> 00:18:40,100
the API that's really aimed at helping

00:18:38,840 --> 00:18:42,380
with forward compatibility and

00:18:40,100 --> 00:18:45,080
versatility is what we call semantic

00:18:42,380 --> 00:18:47,690
paths and these are a concept I believe

00:18:45,080 --> 00:18:49,730
that was introduced with VRP and I'm not

00:18:47,690 --> 00:18:51,860
sure but the the folks from Sensex which

00:18:49,730 --> 00:18:53,540
make SVR have used this for a long time

00:18:51,860 --> 00:18:55,730
in OS VR and we thought it was a pretty

00:18:53,540 --> 00:18:57,950
good concept so the the group ended up

00:18:55,730 --> 00:18:59,060
adopting it so a semantic path is

00:18:57,950 --> 00:19:00,860
basically nothing more than just a

00:18:59,060 --> 00:19:03,980
hierarchical string representation of

00:19:00,860 --> 00:19:06,410
something in the XR ecosystem so we'll

00:19:03,980 --> 00:19:07,850
cover exactly what these things are in a

00:19:06,410 --> 00:19:10,340
little more detail later but things like

00:19:07,850 --> 00:19:12,710
spaces which define kind of basis spaces

00:19:10,340 --> 00:19:14,630
for the application there and they're

00:19:12,710 --> 00:19:15,980
different devices if you have a

00:19:14,630 --> 00:19:18,230
controller or any controller has buttons

00:19:15,980 --> 00:19:20,060
those can be addressed by semantic paths

00:19:18,230 --> 00:19:21,740
as well as viewport configurations which

00:19:20,060 --> 00:19:24,830
is how many eyes do I want to render

00:19:21,740 --> 00:19:27,710
basically if you look at them down at

00:19:24,830 --> 00:19:29,060
the bottom they're very much like your

00:19:27,710 --> 00:19:31,490
standard kind of file path handles

00:19:29,060 --> 00:19:33,920
they're hierarchical and lets you kind

00:19:31,490 --> 00:19:36,950
of address arbitrarily long hierarchies

00:19:33,920 --> 00:19:38,870
of objects in there the the properties

00:19:36,950 --> 00:19:40,370
of them as I said they're hierarchical

00:19:38,870 --> 00:19:43,460
but one of the the most useful of them

00:19:40,370 --> 00:19:44,960
is that they can be alias so user

00:19:43,460 --> 00:19:46,370
representation is one of the things that

00:19:44,960 --> 00:19:48,050
we use for semantic paths so you have a

00:19:46,370 --> 00:19:51,260
user and he has a hand and he has a left

00:19:48,050 --> 00:19:54,050
hand but also you can address these with

00:19:51,260 --> 00:19:55,880
alternate semantic paths if you wanted

00:19:54,050 --> 00:19:57,080
to say what's the users primary hand if

00:19:55,880 --> 00:19:58,840
in the runtime they've selected I'm

00:19:57,080 --> 00:20:00,740
left-handed I'm a right-handed

00:19:58,840 --> 00:20:02,750
individual we can alias

00:20:00,740 --> 00:20:03,950
user hand primary and so application

00:20:02,750 --> 00:20:05,659
should say whichever hand that they're

00:20:03,950 --> 00:20:07,399
using as their primary hand is the one I

00:20:05,659 --> 00:20:09,649
want to give them UI hints on or let

00:20:07,399 --> 00:20:11,570
them use the point the gun with or

00:20:09,649 --> 00:20:12,950
something like that they're stored in a

00:20:11,570 --> 00:20:15,770
string table so they're not horrific Li

00:20:12,950 --> 00:20:16,789
slow after you kind of define them human

00:20:15,770 --> 00:20:19,640
readable which is very nice for

00:20:16,789 --> 00:20:21,830
debugging they can be predefined we have

00:20:19,640 --> 00:20:24,140
a number of reserves slots like the user

00:20:21,830 --> 00:20:25,490
hand left and use your hand primary well

00:20:24,140 --> 00:20:26,750
you can also define them at an

00:20:25,490 --> 00:20:28,549
application level if you want to create

00:20:26,750 --> 00:20:30,260
new spaces or something you can define

00:20:28,549 --> 00:20:32,779
meaningful full paths to those kind of

00:20:30,260 --> 00:20:34,429
data types for yourself they're treated

00:20:32,779 --> 00:20:36,919
as handles so you manage the lifetime of

00:20:34,429 --> 00:20:39,200
those case insensitive with kind of your

00:20:36,919 --> 00:20:41,390
standard value characters with a null

00:20:39,200 --> 00:20:42,890
terminated string but the one thing we

00:20:41,390 --> 00:20:44,539
we were always careful to point out is

00:20:42,890 --> 00:20:46,399
that they're actually not file paths so

00:20:44,539 --> 00:20:51,200
you can't use kind of dot and dot dot to

00:20:46,399 --> 00:20:52,970
go up and down the hierarchy for the

00:20:51,200 --> 00:20:54,649
reserved semantic pass here's a couple

00:20:52,970 --> 00:20:56,779
kind of classifications of them the user

00:20:54,649 --> 00:20:58,820
hand and left and user hand right which

00:20:56,779 --> 00:21:00,860
can also be alias with user hand primary

00:20:58,820 --> 00:21:02,840
and user hand secondary based on the the

00:21:00,860 --> 00:21:05,029
run times user profile of that person

00:21:02,840 --> 00:21:07,789
the head is a reserved semantic path but

00:21:05,029 --> 00:21:09,649
also the device layers so devices that

00:21:07,789 --> 00:21:11,390
are providing input or display

00:21:09,649 --> 00:21:13,010
capabilities you can register with your

00:21:11,390 --> 00:21:14,899
vendor name and your device name and

00:21:13,010 --> 00:21:16,730
your identifier and component and then

00:21:14,899 --> 00:21:19,309
build out a tree of kind of an arbitrary

00:21:16,730 --> 00:21:21,529
construction that helps define exactly

00:21:19,309 --> 00:21:25,760
what kind of input your device provides

00:21:21,529 --> 00:21:28,220
and what kind of output it can take the

00:21:25,760 --> 00:21:29,809
next concept is the XR space and this is

00:21:28,220 --> 00:21:31,909
kind of one of the fundamental concepts

00:21:29,809 --> 00:21:34,399
used throughout the API to help make it

00:21:31,909 --> 00:21:36,559
generalized and able to work on AR and

00:21:34,399 --> 00:21:39,230
VR inside out tracking and outside in

00:21:36,559 --> 00:21:40,730
tracking so at kind of a fundamental

00:21:39,230 --> 00:21:42,880
level we have a right-handed coordinate

00:21:40,730 --> 00:21:45,320
system that you can see in the top right

00:21:42,880 --> 00:21:48,020
but within that coordinate system we

00:21:45,320 --> 00:21:49,669
define a lot of spaces which is

00:21:48,020 --> 00:21:51,860
basically just a basis that returns a

00:21:49,669 --> 00:21:54,830
kind of a translational location and a

00:21:51,860 --> 00:21:56,419
scale within that space the runtime

00:21:54,830 --> 00:21:59,000
basically has an internal representation

00:21:56,419 --> 00:22:01,039
that it can store however it wants to so

00:21:59,000 --> 00:22:02,929
it gets tracking data from one source or

00:22:01,039 --> 00:22:05,270
multiple sources how it stores the

00:22:02,929 --> 00:22:08,480
representation internally is up to it in

00:22:05,270 --> 00:22:11,169
cases like an oculus or a vibe that are

00:22:08,480 --> 00:22:15,200
outside in tracked that states that

00:22:11,169 --> 00:22:17,480
world space is probably

00:22:15,200 --> 00:22:20,330
but in the case of ARR inside out

00:22:17,480 --> 00:22:22,880
tracking headsets that state is always

00:22:20,330 --> 00:22:24,679
kind of malleable as the the mapping

00:22:22,880 --> 00:22:27,440
defines more more places that it

00:22:24,679 --> 00:22:29,270
recognizes so the way we kind of get

00:22:27,440 --> 00:22:32,000
around those sticky issues with open XR

00:22:29,270 --> 00:22:34,490
is that we let you define spaces like a

00:22:32,000 --> 00:22:36,320
floor plane or a high level plane but

00:22:34,490 --> 00:22:37,730
then we define a function that lets you

00:22:36,320 --> 00:22:39,860
get the relation between any two of

00:22:37,730 --> 00:22:41,630
those spaces and those spaces can be

00:22:39,860 --> 00:22:44,510
continually updated as I said if the

00:22:41,630 --> 00:22:46,220
room is discovering more about what the

00:22:44,510 --> 00:22:48,350
layout of the actual room is it can

00:22:46,220 --> 00:22:50,059
adjust those as it's needed or if you

00:22:48,350 --> 00:22:51,530
wanted to attach a tracking space to a

00:22:50,059 --> 00:22:53,059
motion controller for instance and have

00:22:51,530 --> 00:22:55,760
that basis function kind of move along

00:22:53,059 --> 00:22:57,140
with the motion controller itself so

00:22:55,760 --> 00:23:01,940
that you can attach things in relative

00:22:57,140 --> 00:23:03,470
space you can do that as well so this is

00:23:01,940 --> 00:23:04,789
kind of the overall structure of the

00:23:03,470 --> 00:23:05,990
instance the system in this session

00:23:04,789 --> 00:23:09,230
these are the kind of the three base

00:23:05,990 --> 00:23:11,690
level concepts of open XR so first of

00:23:09,230 --> 00:23:13,309
all you need a loader in order to get a

00:23:11,690 --> 00:23:15,080
handle to one of the runtimes so an

00:23:13,309 --> 00:23:16,730
application basically says hey I'm an

00:23:15,080 --> 00:23:18,980
open XR application I want to use open

00:23:16,730 --> 00:23:22,159
XR I need to find a runtime that's

00:23:18,980 --> 00:23:23,840
compatible and we're not requiring you

00:23:22,159 --> 00:23:25,070
to use the open XR loader that we ship

00:23:23,840 --> 00:23:26,990
and we imagine that this is one of those

00:23:25,070 --> 00:23:28,580
things that will vary in complexity you

00:23:26,990 --> 00:23:31,250
can either have one runtime and just use

00:23:28,580 --> 00:23:32,809
that all the time or we might have ones

00:23:31,250 --> 00:23:34,220
that let you pick the user pick

00:23:32,809 --> 00:23:35,809
intelligently between them based on what

00:23:34,220 --> 00:23:37,130
hardware's plugged in which apps are

00:23:35,809 --> 00:23:40,309
running if you have a kind of home

00:23:37,130 --> 00:23:43,250
baseline experience all those factors

00:23:40,309 --> 00:23:44,210
can be taken into account the reason

00:23:43,250 --> 00:23:45,679
that this one is a little bit more

00:23:44,210 --> 00:23:47,210
malleable too is that some platforms

00:23:45,679 --> 00:23:48,590
like Android have very very specific

00:23:47,210 --> 00:23:51,530
requirements about what this loader is

00:23:48,590 --> 00:23:52,850
allowed to do and so we try not to put

00:23:51,530 --> 00:23:54,530
too many restrictions on it and leave it

00:23:52,850 --> 00:23:56,299
open-ended basically as long as it can

00:23:54,530 --> 00:23:57,710
pick a runtime for you and return those

00:23:56,299 --> 00:24:01,250
handles to the application that's all it

00:23:57,710 --> 00:24:03,049
needs to do the next thing in the

00:24:01,250 --> 00:24:05,120
hierarchy is the XR instance and this is

00:24:03,049 --> 00:24:06,799
really the application says I'm an open

00:24:05,120 --> 00:24:09,890
XR application I need a handle to a

00:24:06,799 --> 00:24:11,570
runtime and that's the XR instance so we

00:24:09,890 --> 00:24:13,309
use this function XR create instance

00:24:11,570 --> 00:24:15,440
just ask the loader for a hook to a

00:24:13,309 --> 00:24:17,390
runtime and at that same time we can

00:24:15,440 --> 00:24:19,640
also pick if we want to enable any diba

00:24:17,390 --> 00:24:21,520
are any layers or any extensions at that

00:24:19,640 --> 00:24:25,039
same time it's very similar to the

00:24:21,520 --> 00:24:26,510
Vulcan initialization path so the

00:24:25,039 --> 00:24:28,100
application is like hey I'm ready to go

00:24:26,510 --> 00:24:30,289
I need the extensions

00:24:28,100 --> 00:24:31,549
or Vulcan potentially give me a runtime

00:24:30,289 --> 00:24:33,710
that's compatible with that and then it

00:24:31,549 --> 00:24:36,500
returns a handle to that runtime which

00:24:33,710 --> 00:24:39,710
we then used to do the rest of our open

00:24:36,500 --> 00:24:42,350
x earning the the next level in that is

00:24:39,710 --> 00:24:44,210
the XR system so the XR system is

00:24:42,350 --> 00:24:47,210
essentially a group of devices that work

00:24:44,210 --> 00:24:48,919
together within open XR so you can

00:24:47,210 --> 00:24:51,169
imagine an hmd and a set of controllers

00:24:48,919 --> 00:24:52,910
comprised and XR system you can get they

00:24:51,169 --> 00:24:55,580
have different capabilities some of them

00:24:52,910 --> 00:24:57,370
can display some of them can track three

00:24:55,580 --> 00:24:59,630
Dolf some of them can track six stuff

00:24:57,370 --> 00:25:01,010
but all of those are kind of represented

00:24:59,630 --> 00:25:02,809
as a system so the first thing you do

00:25:01,010 --> 00:25:04,490
after you create an instance is you ask

00:25:02,809 --> 00:25:06,380
the instance what hardware do you

00:25:04,490 --> 00:25:07,490
support and then it gives you a list of

00:25:06,380 --> 00:25:13,309
that and you can pick I want to run on

00:25:07,490 --> 00:25:14,929
this system so basically when you

00:25:13,309 --> 00:25:17,510
enumerate the physical devices you get a

00:25:14,929 --> 00:25:18,740
few of the properties about them one of

00:25:17,510 --> 00:25:20,720
them is what kind of tracking they have

00:25:18,740 --> 00:25:22,070
other ones are what resolution are they

00:25:20,720 --> 00:25:24,230
capable of supporting if they can

00:25:22,070 --> 00:25:26,480
support MSAA what their swap chain

00:25:24,230 --> 00:25:28,970
lengths are what kind of input devices

00:25:26,480 --> 00:25:30,559
they support this is also kind of the

00:25:28,970 --> 00:25:32,480
the part where we need to start caring

00:25:30,559 --> 00:25:33,679
about what graphics API is because the

00:25:32,480 --> 00:25:35,840
system is responsible for allocating

00:25:33,679 --> 00:25:38,470
swap chains so we need to know what kind

00:25:35,840 --> 00:25:41,090
of a swap chain textures you need to use

00:25:38,470 --> 00:25:42,919
there's actually some special extensions

00:25:41,090 --> 00:25:44,450
in here for Vulcan because potentially

00:25:42,919 --> 00:25:46,789
you might need some of these runtimes

00:25:44,450 --> 00:25:48,320
might need specific Vulcan extensions

00:25:46,789 --> 00:25:50,809
enabled so you can query that at this

00:25:48,320 --> 00:25:54,559
time and then enable your instance with

00:25:50,809 --> 00:25:56,659
the Vulcan extensions that you need next

00:25:54,559 --> 00:25:58,340
up is a session and until very recently

00:25:56,659 --> 00:25:59,870
actually this was another handle kind of

00:25:58,340 --> 00:26:01,940
lifetime object but it's recently been

00:25:59,870 --> 00:26:04,100
demoted to just a function to begin and

00:26:01,940 --> 00:26:05,690
end a session and basically a session is

00:26:04,100 --> 00:26:07,789
how an application indicates whether or

00:26:05,690 --> 00:26:09,860
not it wants to render VR output at that

00:26:07,789 --> 00:26:12,650
time and get input from a tracking

00:26:09,860 --> 00:26:14,299
system so it's pretty simple once the

00:26:12,650 --> 00:26:16,039
application is ready to start sending

00:26:14,299 --> 00:26:18,500
frame data and allocating a swap chains

00:26:16,039 --> 00:26:20,179
it says begin session and that tells the

00:26:18,500 --> 00:26:21,559
instance that hey this guy wants to

00:26:20,179 --> 00:26:23,990
start rendering frames to the device we

00:26:21,559 --> 00:26:25,760
should give it use of the the runtime

00:26:23,990 --> 00:26:27,220
end display on the device and then when

00:26:25,760 --> 00:26:29,690
it's done it can you call in session

00:26:27,220 --> 00:26:30,919
basically the the rule here is if you

00:26:29,690 --> 00:26:34,220
haven't started the session you can't

00:26:30,919 --> 00:26:35,809
give it frames but this is nice for

00:26:34,220 --> 00:26:37,880
mixed-mode applications - if you have a

00:26:35,809 --> 00:26:39,650
AR application on the phone for instance

00:26:37,880 --> 00:26:41,150
you can start without a session but

00:26:39,650 --> 00:26:41,510
initialize all the open XR stuff and

00:26:41,150 --> 00:26:43,490
when you want

00:26:41,510 --> 00:26:44,780
kick it into AR mode you just begin a

00:26:43,490 --> 00:26:48,560
session and you can start taking the

00:26:44,780 --> 00:26:50,090
input when the runtime wants to

00:26:48,560 --> 00:26:52,580
communicate with the application we do

00:26:50,090 --> 00:26:55,190
through do so through the events queue

00:26:52,580 --> 00:26:56,930
so the events here's a kind of a couple

00:26:55,190 --> 00:26:59,300
of them but they're very basic and

00:26:56,930 --> 00:27:01,240
pretty extensible the the ones that are

00:26:59,300 --> 00:27:03,770
kind of fundamental to the system our

00:27:01,240 --> 00:27:05,450
visibility change focus change which is

00:27:03,770 --> 00:27:07,370
whether or not you are actually

00:27:05,450 --> 00:27:09,380
rendering on the device or getting input

00:27:07,370 --> 00:27:11,090
from the device system but there's also

00:27:09,380 --> 00:27:13,790
a little bit more kind of heavyweight

00:27:11,090 --> 00:27:15,170
ones if the runtime says hey somebody

00:27:13,790 --> 00:27:16,900
else wants to render on me it can send a

00:27:15,170 --> 00:27:19,130
request that you end the session

00:27:16,900 --> 00:27:20,860
immediately so that you stop ending

00:27:19,130 --> 00:27:23,060
frames and yield to another application

00:27:20,860 --> 00:27:25,100
sometimes if the runtime has to update

00:27:23,060 --> 00:27:26,360
it can ask that you end the instance and

00:27:25,100 --> 00:27:28,400
then recreate it later after it's gone

00:27:26,360 --> 00:27:30,020
through an update but it also has some

00:27:28,400 --> 00:27:32,660
of the the more kind of user focused

00:27:30,020 --> 00:27:34,790
events such as if the user puts on the

00:27:32,660 --> 00:27:36,530
headset or takes it off or if the user

00:27:34,790 --> 00:27:37,880
trips over their cable and Yanks it out

00:27:36,530 --> 00:27:39,980
of the computer and you need to handle

00:27:37,880 --> 00:27:41,960
that those are all surfaced through the

00:27:39,980 --> 00:27:44,270
event system it's basically just a

00:27:41,960 --> 00:27:46,520
simple event queue that the game

00:27:44,270 --> 00:27:48,470
application is expected to pull at

00:27:46,520 --> 00:27:50,330
whatever rate did kind of updates its

00:27:48,470 --> 00:27:52,580
simulation net there's no kind of

00:27:50,330 --> 00:27:53,810
restrictions on how fast those cue

00:27:52,580 --> 00:27:54,950
messages have to be handled they just

00:27:53,810 --> 00:27:59,810
kind of build up until the application

00:27:54,950 --> 00:28:03,530
processes them next step is input in

00:27:59,810 --> 00:28:05,330
haptics so the input is one of those

00:28:03,530 --> 00:28:06,860
things that we don't dare as a

00:28:05,330 --> 00:28:08,120
specification to actually predict what

00:28:06,860 --> 00:28:10,250
it's going to look like because we

00:28:08,120 --> 00:28:13,250
expect this to be a pretty crazy area in

00:28:10,250 --> 00:28:15,950
the coming years so we go through an

00:28:13,250 --> 00:28:17,900
abstraction where we try to get the

00:28:15,950 --> 00:28:19,730
applications to define events that they

00:28:17,900 --> 00:28:21,560
care about such as kind of I want to

00:28:19,730 --> 00:28:23,300
move I want to jump I want to teleport I

00:28:21,560 --> 00:28:25,070
want to shoot a gun rather than

00:28:23,300 --> 00:28:26,990
specifically binding directly to the

00:28:25,070 --> 00:28:28,730
controls so a lot of games you know we

00:28:26,990 --> 00:28:31,090
say I want to press a to jump and I want

00:28:28,730 --> 00:28:33,560
to press B to shoot my gun we say

00:28:31,090 --> 00:28:35,590
shooting a gun and jumping or to actions

00:28:33,560 --> 00:28:37,790
and we let the runtime actually bind

00:28:35,590 --> 00:28:40,580
which button on the device actually

00:28:37,790 --> 00:28:42,350
handles those things again this is

00:28:40,580 --> 00:28:43,880
handled IG's completely by the runtime

00:28:42,350 --> 00:28:45,350
so we expect if you you know boot up

00:28:43,880 --> 00:28:47,600
steamvr for instance you'll have a bunch

00:28:45,350 --> 00:28:49,250
of controller bindings and then the user

00:28:47,600 --> 00:28:53,420
will be able to kind of pick which ones

00:28:49,250 --> 00:28:55,550
they want and this has kind of several

00:28:53,420 --> 00:28:57,800
advantages by forcing that abstraction

00:28:55,550 --> 00:28:59,780
one of the things is one of our group

00:28:57,800 --> 00:29:01,520
members Jill Ludwick said that dev teams

00:28:59,780 --> 00:29:03,410
are ephemeral abut platforms are forever

00:29:01,520 --> 00:29:04,730
and that's kind of a jerkish thing to

00:29:03,410 --> 00:29:08,750
say because he's a platform owner I'm a

00:29:04,730 --> 00:29:10,550
dev team but I think the sentiment is is

00:29:08,750 --> 00:29:12,340
correct in that you know especially

00:29:10,550 --> 00:29:14,450
right now people that are making

00:29:12,340 --> 00:29:15,770
applications and whatnot it's it's you

00:29:14,450 --> 00:29:17,720
know one or two years down the road it's

00:29:15,770 --> 00:29:19,190
very hard to go back and actually get a

00:29:17,720 --> 00:29:20,300
system that can compile and find all the

00:29:19,190 --> 00:29:22,460
dev team members that know how it works

00:29:20,300 --> 00:29:24,740
to update those applications but the

00:29:22,460 --> 00:29:27,650
platforms tend to hang around for much

00:29:24,740 --> 00:29:30,320
longer time so by pushing this kind of

00:29:27,650 --> 00:29:32,120
binding to the runtime if somebody comes

00:29:30,320 --> 00:29:33,620
out with a new awesome headset or a new

00:29:32,120 --> 00:29:36,410
awesome controller and the runtime

00:29:33,620 --> 00:29:37,730
supports that it can say hey if you have

00:29:36,410 --> 00:29:39,200
a gun peripheral now you want that

00:29:37,730 --> 00:29:41,240
trigger on the gun to shoot rather than

00:29:39,200 --> 00:29:43,730
the a button that leaves it up to the

00:29:41,240 --> 00:29:45,440
runtime the runtime can update and map

00:29:43,730 --> 00:29:47,170
those new controls so it's really a

00:29:45,440 --> 00:29:51,290
quite powerful tool to future-proof

00:29:47,170 --> 00:29:52,550
things it's also interesting in that it

00:29:51,290 --> 00:29:54,530
kind of allows for mixing and matching

00:29:52,550 --> 00:29:56,960
of multiple input sources so if you had

00:29:54,530 --> 00:29:58,970
a runtime that was combining maybe a

00:29:56,960 --> 00:30:01,340
vikon tracking system with some other

00:29:58,970 --> 00:30:04,630
arbitrary display system you're not

00:30:01,340 --> 00:30:07,130
bound to you know use whatever

00:30:04,630 --> 00:30:09,110
controller was created with the

00:30:07,130 --> 00:30:10,490
application you can map those two

00:30:09,110 --> 00:30:11,690
together just as easily as you could any

00:30:10,490 --> 00:30:13,280
other so it's very seamless to the

00:30:11,690 --> 00:30:14,960
application it just gets the data it

00:30:13,280 --> 00:30:18,350
doesn't care where it can comes from the

00:30:14,960 --> 00:30:19,550
runtime is what's mapping it for it it

00:30:18,350 --> 00:30:22,250
also makes it pretty easy to support

00:30:19,550 --> 00:30:23,960
optional features so if the open XR

00:30:22,250 --> 00:30:26,030
runtime potentially supports body

00:30:23,960 --> 00:30:28,400
tracking through use of trackers we can

00:30:26,030 --> 00:30:29,660
say hey if you feed us data for where

00:30:28,400 --> 00:30:31,430
the left knee position is through

00:30:29,660 --> 00:30:34,160
whatever kind of tracking methodology be

00:30:31,430 --> 00:30:35,750
that a connect or a v tracker we can

00:30:34,160 --> 00:30:37,610
ingest that and then actually put it in

00:30:35,750 --> 00:30:38,990
there and it's the open XR runtime job

00:30:37,610 --> 00:30:41,090
to normalize all those spaces together

00:30:38,990 --> 00:30:43,520
so did the application it's just another

00:30:41,090 --> 00:30:44,930
source of input and that's pretty darn

00:30:43,520 --> 00:30:46,640
cool when you think about all the kind

00:30:44,930 --> 00:30:49,070
of combinations that people are doing

00:30:46,640 --> 00:30:52,880
especially for kind of location-based be

00:30:49,070 --> 00:30:54,860
our experiences and kind of finally it

00:30:52,880 --> 00:30:57,380
kind of solves that the right-hand of

00:30:54,860 --> 00:30:58,850
the original problem statement where if

00:30:57,380 --> 00:31:01,010
I'm a hardware manufacturer I have a

00:30:58,850 --> 00:31:03,140
cool new device that's a little bit you

00:31:01,010 --> 00:31:04,760
know novel how do I fit that into the

00:31:03,140 --> 00:31:06,440
ecosystem and how can I get content

00:31:04,760 --> 00:31:08,540
built upon that with this sort of thing

00:31:06,440 --> 00:31:10,160
if you say my foot controller provides

00:31:08,540 --> 00:31:11,420
you know kind of locomotion input for

00:31:10,160 --> 00:31:13,160
going forward and backwards left and

00:31:11,420 --> 00:31:14,810
right you don't no longer have to have

00:31:13,160 --> 00:31:16,670
the application developer take that into

00:31:14,810 --> 00:31:17,900
consideration they can just bind that in

00:31:16,670 --> 00:31:20,390
the runtime as long as your runtime

00:31:17,900 --> 00:31:23,560
supports the hardware and the

00:31:20,390 --> 00:31:27,650
applications automatically can use that

00:31:23,560 --> 00:31:29,630
so the actions that I mentioned up there

00:31:27,650 --> 00:31:30,740
have a couple properties that I'll go

00:31:29,630 --> 00:31:33,230
over real quick the first one is just

00:31:30,740 --> 00:31:35,600
kind of its identifier name so teleport

00:31:33,230 --> 00:31:37,310
jump nothing terribly interested in

00:31:35,600 --> 00:31:38,660
interesting there but it also has a

00:31:37,310 --> 00:31:40,970
localized name which is kind of the

00:31:38,660 --> 00:31:43,390
human readable description that's

00:31:40,970 --> 00:31:45,920
surfaced in the UI at the runtime so

00:31:43,390 --> 00:31:47,480
this can be the same as the action name

00:31:45,920 --> 00:31:49,340
for simple things but it also might be

00:31:47,480 --> 00:31:51,950
something that is a little more complex

00:31:49,340 --> 00:31:53,390
to describe a more complex action we

00:31:51,950 --> 00:31:54,980
also have action sets which I'll get to

00:31:53,390 --> 00:31:57,500
in a few but it allows kind of groupings

00:31:54,980 --> 00:31:59,870
of actions based on the different states

00:31:57,500 --> 00:32:01,490
that your application might be in and

00:31:59,870 --> 00:32:04,280
finally we have the suggested binding

00:32:01,490 --> 00:32:05,930
which is if the user hasn't bothered to

00:32:04,280 --> 00:32:07,250
go through and actually configure what

00:32:05,930 --> 00:32:09,440
the input settings are for the runtime

00:32:07,250 --> 00:32:11,480
they cannot the application you provide

00:32:09,440 --> 00:32:13,910
a set of suggested bindings so if I was

00:32:11,480 --> 00:32:15,740
making a game I said okay I want this to

00:32:13,910 --> 00:32:17,330
be the default binding for using oculus

00:32:15,740 --> 00:32:18,800
touch controllers and I want this to be

00:32:17,330 --> 00:32:21,200
the default binding when I'm using a

00:32:18,800 --> 00:32:22,460
Google daydream headset and the

00:32:21,200 --> 00:32:24,620
application can kind of provide those

00:32:22,460 --> 00:32:25,910
recommendations but it's ultimately up

00:32:24,620 --> 00:32:28,130
to the user in the runtime whether or

00:32:25,910 --> 00:32:30,290
not they want to use those or not there

00:32:28,130 --> 00:32:31,820
are some limitations on it there's a

00:32:30,290 --> 00:32:34,070
couple different types of actions

00:32:31,820 --> 00:32:36,200
bullying's one dimensional vectors which

00:32:34,070 --> 00:32:37,460
are kind of the scalars two-dimensional

00:32:36,200 --> 00:32:39,740
vectors and three-dimensional vectors

00:32:37,460 --> 00:32:41,210
and through the use of the those

00:32:39,740 --> 00:32:43,040
relative paths you can kind of build

00:32:41,210 --> 00:32:45,020
hierarchies of this so if you had a

00:32:43,040 --> 00:32:46,610
device input that could provide a

00:32:45,020 --> 00:32:48,620
two-dimensional vector kind of like a

00:32:46,610 --> 00:32:52,880
thumb stick you could bind that to a

00:32:48,620 --> 00:32:54,650
type vector to F and you have X&Y input

00:32:52,880 --> 00:32:56,480
into there but you're not kind of

00:32:54,650 --> 00:32:58,520
restricted to that if the the runtime is

00:32:56,480 --> 00:33:00,290
like I want to take together these two

00:32:58,520 --> 00:33:02,300
completely different arbitrary joysticks

00:33:00,290 --> 00:33:04,220
and mash the left and right on this

00:33:02,300 --> 00:33:06,290
stick to the front and back on this

00:33:04,220 --> 00:33:08,000
stick or if I want to remap a thumbstick

00:33:06,290 --> 00:33:10,430
input for a car racing game to a pedal

00:33:08,000 --> 00:33:15,230
you can also do that custom in the

00:33:10,430 --> 00:33:17,210
runtime there's one more kind of very

00:33:15,230 --> 00:33:19,100
special type of input which is actually

00:33:17,210 --> 00:33:21,230
one of the things that's being debated

00:33:19,100 --> 00:33:22,100
as of kind of last weekend this week

00:33:21,230 --> 00:33:23,929
which is

00:33:22,100 --> 00:33:26,630
the extra our action state pose which is

00:33:23,929 --> 00:33:28,669
basically just saying this action input

00:33:26,630 --> 00:33:30,200
is something that has a full pose in

00:33:28,669 --> 00:33:31,640
that it has a position and a rotation

00:33:30,200 --> 00:33:33,710
with it and it can potentially have

00:33:31,640 --> 00:33:35,630
other inputs such as linear velocity

00:33:33,710 --> 00:33:38,330
angular velocity and accelerations into

00:33:35,630 --> 00:33:39,740
there you can pull these in the same

00:33:38,330 --> 00:33:41,840
place you pull all the other input

00:33:39,740 --> 00:33:44,179
actions by calling X our get action

00:33:41,840 --> 00:33:46,789
state pose and then it passes back a

00:33:44,179 --> 00:33:49,160
flag to say hey these are the parameters

00:33:46,789 --> 00:33:51,049
for it but this controller is only $3.00

00:33:49,160 --> 00:33:54,559
so it doesn't really support a position

00:33:51,049 --> 00:33:55,970
bid for instance again this is really

00:33:54,559 --> 00:33:57,710
kind of designed to be generic and

00:33:55,970 --> 00:33:59,450
flexible so that as new devices come on

00:33:57,710 --> 00:34:03,440
you can map them into the runtime pretty

00:33:59,450 --> 00:34:05,150
naturally action sets are kind of what I

00:34:03,440 --> 00:34:06,890
touched upon before but if you have an

00:34:05,150 --> 00:34:08,990
application that has kind of different

00:34:06,890 --> 00:34:10,310
modalities of interaction you can define

00:34:08,990 --> 00:34:12,889
different action sets and swap between

00:34:10,310 --> 00:34:14,359
them so in our hypothetical example of

00:34:12,889 --> 00:34:16,280
Khitan petter VR which is a game I

00:34:14,359 --> 00:34:17,899
really wish somebody would make you

00:34:16,280 --> 00:34:19,490
could be in potentially two modes one is

00:34:17,899 --> 00:34:21,649
petting the kitten mode where you want

00:34:19,490 --> 00:34:23,030
the a button to spawn a yarn ball for

00:34:21,649 --> 00:34:25,669
two delightfully play with and be

00:34:23,030 --> 00:34:27,379
adorable with the click might teleport

00:34:25,669 --> 00:34:28,460
you around the room and then pulling the

00:34:27,379 --> 00:34:30,619
grip button might spawn you more

00:34:28,460 --> 00:34:32,540
delightful kittens to play with but also

00:34:30,619 --> 00:34:34,010
if you're in the UI for that application

00:34:32,540 --> 00:34:35,389
you don't want to be able to spawn

00:34:34,010 --> 00:34:36,409
kittens potentially your spawn yarn

00:34:35,389 --> 00:34:37,909
balls you want to be able to select

00:34:36,409 --> 00:34:39,590
items change the menus and scroll

00:34:37,909 --> 00:34:41,000
through the menus and that's why you can

00:34:39,590 --> 00:34:43,100
have an entirely different action set

00:34:41,000 --> 00:34:44,840
that's devoted to UI mode again these

00:34:43,100 --> 00:34:46,760
are optional things but the more

00:34:44,840 --> 00:34:48,710
robustly that applications can actually

00:34:46,760 --> 00:34:50,750
define their action sets the better that

00:34:48,710 --> 00:34:51,830
people can integrate new types of

00:34:50,750 --> 00:34:54,050
hardware and future-proof their

00:34:51,830 --> 00:34:57,080
applications towards the devices that

00:34:54,050 --> 00:34:58,940
come down the road and if you've ever

00:34:57,080 --> 00:35:00,530
made a VR AR application you know that

00:34:58,940 --> 00:35:02,210
users can sometimes be a little bit

00:35:00,530 --> 00:35:04,490
frustrating and just not getting what

00:35:02,210 --> 00:35:05,930
you had intended them to get so

00:35:04,490 --> 00:35:08,420
sometimes you have to provide UI hands

00:35:05,930 --> 00:35:10,040
to tell them how to perform actions so

00:35:08,420 --> 00:35:12,380
we also have a kind of a reverse lookup

00:35:10,040 --> 00:35:15,170
that you can perform with this where you

00:35:12,380 --> 00:35:16,160
can say hey I want to tell the user that

00:35:15,170 --> 00:35:18,710
they need to pull the trigger to

00:35:16,160 --> 00:35:20,869
teleport how do I do that you can ask

00:35:18,710 --> 00:35:22,520
the open XR runtime hey what button on

00:35:20,869 --> 00:35:24,320
this device is actually bound to the

00:35:22,520 --> 00:35:26,630
teleport command so that you can draw

00:35:24,320 --> 00:35:28,340
the controller in the actual application

00:35:26,630 --> 00:35:30,680
itself or you can put some UI saying hey

00:35:28,340 --> 00:35:34,940
pull the trigger to teleport idiot and

00:35:30,680 --> 00:35:36,030
hopefully they they get the hint haptics

00:35:34,940 --> 00:35:37,740
are something that's all

00:35:36,030 --> 00:35:39,510
so in the specification that goes

00:35:37,740 --> 00:35:41,580
through the same sort of input action

00:35:39,510 --> 00:35:44,130
thing haptic actions can be in action

00:35:41,580 --> 00:35:46,110
sets just like regular input actions are

00:35:44,130 --> 00:35:48,480
but basically this allows you to send

00:35:46,110 --> 00:35:50,370
vibrations out to the controller this is

00:35:48,480 --> 00:35:52,410
one of the things we have one baseline

00:35:50,370 --> 00:35:54,000
type of haptic action which basically

00:35:52,410 --> 00:35:56,340
just has a start time a duration the

00:35:54,000 --> 00:35:58,440
frequency and amplitude kind of based

00:35:56,340 --> 00:36:00,450
around current hardware but this is one

00:35:58,440 --> 00:36:02,820
of the things that we expect as the

00:36:00,450 --> 00:36:05,280
technology improves that you can use

00:36:02,820 --> 00:36:06,720
that people will write extensions and

00:36:05,280 --> 00:36:08,640
vendor specific extensions to be able to

00:36:06,720 --> 00:36:10,290
take advantage of more complex haptics I

00:36:08,640 --> 00:36:11,970
mean then we have haptics now that

00:36:10,290 --> 00:36:13,080
provide shears against the palm to kind

00:36:11,970 --> 00:36:14,220
of make it feel like you have something

00:36:13,080 --> 00:36:16,260
in your hand as opposed to just

00:36:14,220 --> 00:36:19,170
vibration all those can be very easily

00:36:16,260 --> 00:36:20,880
slotted in through extensions just by

00:36:19,170 --> 00:36:23,940
defining new types of XR haptics and if

00:36:20,880 --> 00:36:25,380
you add those to your haptic set then as

00:36:23,940 --> 00:36:26,910
new devices come down the road they

00:36:25,380 --> 00:36:28,700
might be able to make an intelligent

00:36:26,910 --> 00:36:30,510
mapping in the runtime between the

00:36:28,700 --> 00:36:32,160
information that the application is

00:36:30,510 --> 00:36:36,150
providing and the haptic device that

00:36:32,160 --> 00:36:38,250
they actually have all right so that was

00:36:36,150 --> 00:36:40,980
input now let's get onto a little bit of

00:36:38,250 --> 00:36:43,860
the the rendering pipeline up here so at

00:36:40,980 --> 00:36:45,660
a kind of high basic level we have the

00:36:43,860 --> 00:36:47,340
three functions that everybody kind of

00:36:45,660 --> 00:36:49,950
knows and loves from current VR na our

00:36:47,340 --> 00:36:51,210
applications X our begin frame is

00:36:49,950 --> 00:36:53,220
basically what you call when you say hey

00:36:51,210 --> 00:36:55,230
I'm ready to start rendering I need to

00:36:53,220 --> 00:36:57,360
you know get my next item on my swap

00:36:55,230 --> 00:37:00,000
chain and then issue a bunch of draw

00:36:57,360 --> 00:37:01,290
calls so call X our begin frame you make

00:37:00,000 --> 00:37:02,520
a bunch of pretty things to render on

00:37:01,290 --> 00:37:03,840
there and then when you're done

00:37:02,520 --> 00:37:05,850
rendering and you want to tell the

00:37:03,840 --> 00:37:07,260
compositor hey I'm ready to take all

00:37:05,850 --> 00:37:09,690
these layers and then have you display

00:37:07,260 --> 00:37:11,850
them you call X our end frame pretty

00:37:09,690 --> 00:37:13,890
simple it takes a predicted display time

00:37:11,850 --> 00:37:14,850
and how many layers that you want to

00:37:13,890 --> 00:37:17,460
present I'll kind of get into the

00:37:14,850 --> 00:37:18,720
details of that in a little bit but it's

00:37:17,460 --> 00:37:21,450
very similar if you've worked with any

00:37:18,720 --> 00:37:23,760
kind of modern VR API on how that loop

00:37:21,450 --> 00:37:27,120
goes the one that's a little bit special

00:37:23,760 --> 00:37:29,490
is X our wait frame and this is called

00:37:27,120 --> 00:37:31,410
and it when it returns it's a kind of a

00:37:29,490 --> 00:37:32,730
delayed function when it returns is when

00:37:31,410 --> 00:37:35,970
the runtime says you should start

00:37:32,730 --> 00:37:37,200
simulating your next game frame so valve

00:37:35,970 --> 00:37:39,540
calls this running start

00:37:37,200 --> 00:37:40,740
oculus I can't remember what oculus

00:37:39,540 --> 00:37:42,090
calls it but they have a similar sort of

00:37:40,740 --> 00:37:44,130
functionality that's supposed to get you

00:37:42,090 --> 00:37:46,860
on how fast your application can render

00:37:44,130 --> 00:37:48,000
and the idea is really it runtime knows

00:37:46,860 --> 00:37:49,380
best and when to release your

00:37:48,000 --> 00:37:51,030
application to start rendering so that

00:37:49,380 --> 00:37:52,950
they can position you to have your

00:37:51,030 --> 00:37:54,360
rendering work done as close to when the

00:37:52,950 --> 00:37:58,860
compositor is hooking and displaying the

00:37:54,360 --> 00:38:00,090
frames in order to minimize latency XR

00:37:58,860 --> 00:38:02,820
wait framing if you dig into it a little

00:38:00,090 --> 00:38:04,140
bit more takes a swap interval parameter

00:38:02,820 --> 00:38:06,350
and what the swap interval parameter

00:38:04,140 --> 00:38:10,470
does is say how many frames you want to

00:38:06,350 --> 00:38:12,300
wait for so by default swap interval 1

00:38:10,470 --> 00:38:14,490
means every time the native displays

00:38:12,300 --> 00:38:16,860
refreshes I want to render a frame but

00:38:14,490 --> 00:38:20,700
you can also specify more than that so

00:38:16,860 --> 00:38:22,290
if you say specify a swap interval to XR

00:38:20,700 --> 00:38:23,460
wait frame kind of skips a frame so if

00:38:22,290 --> 00:38:25,020
you want to render at half frame rate

00:38:23,460 --> 00:38:26,610
and have it do the reprojection under

00:38:25,020 --> 00:38:28,740
the hood you can specify swap interval

00:38:26,610 --> 00:38:30,930
to and then it will be the runtimes job

00:38:28,740 --> 00:38:32,910
to up sample that to display at the

00:38:30,930 --> 00:38:34,500
devices native frame rate if you try to

00:38:32,910 --> 00:38:35,640
specify a swap interval zero it's

00:38:34,500 --> 00:38:38,280
completely invalid rips a hole in space

00:38:35,640 --> 00:38:40,200
and time don't try to do it but

00:38:38,280 --> 00:38:42,180
basically it all in all that this XR

00:38:40,200 --> 00:38:44,730
wait frame is how the application gets

00:38:42,180 --> 00:38:46,140
throttled by the runtime in order to

00:38:44,730 --> 00:38:50,010
make it a little bit more concrete let's

00:38:46,140 --> 00:38:52,850
look at a frame timing diagram so this

00:38:50,010 --> 00:38:54,990
is a very simple kind of DirectX 11

00:38:52,850 --> 00:38:56,340
OpenGL style simple multi-threaded

00:38:54,990 --> 00:38:58,680
renderer that has a simulation thread

00:38:56,340 --> 00:39:00,060
that's responsible for updating the

00:38:58,680 --> 00:39:01,080
simulation in the game it has a render

00:39:00,060 --> 00:39:03,420
thread which is responsible for

00:39:01,080 --> 00:39:04,650
generating a bunch of draw draw call

00:39:03,420 --> 00:39:07,920
commands and then sending them to the

00:39:04,650 --> 00:39:09,990
GPU so this is actually easier if you

00:39:07,920 --> 00:39:14,330
start with the blue frame or the kind of

00:39:09,990 --> 00:39:17,010
vaguely taupe I guess frame I wanted to

00:39:14,330 --> 00:39:18,750
that frame is one that's kind of well

00:39:17,010 --> 00:39:21,030
scheduled fits within the allotted

00:39:18,750 --> 00:39:23,610
amount of time the simulation thread

00:39:21,030 --> 00:39:26,220
runs and then calls wait frame to wait

00:39:23,610 --> 00:39:27,930
until the next block of time and then it

00:39:26,220 --> 00:39:29,670
kicks those jobs off to the the render

00:39:27,930 --> 00:39:30,560
frame the render thread so the render

00:39:29,670 --> 00:39:32,460
thread does a little bit of

00:39:30,560 --> 00:39:36,390
initialization work and then when it's

00:39:32,460 --> 00:39:38,250
ready to call draw I actually started

00:39:36,390 --> 00:39:40,230
issuing GPU work it calls begin frame

00:39:38,250 --> 00:39:41,220
and then it calls in frame when that's

00:39:40,230 --> 00:39:45,300
done

00:39:41,220 --> 00:39:47,610
if you then back it up to frame 101

00:39:45,300 --> 00:39:48,990
frame 101 the simulation thread you can

00:39:47,610 --> 00:39:52,080
see it's coming very very close to the

00:39:48,990 --> 00:39:54,990
compositors hook between frame 1 at 100

00:39:52,080 --> 00:39:56,760
and 101 because of that it knows that it

00:39:54,990 --> 00:39:58,710
can't actually make the next frame so it

00:39:56,760 --> 00:40:00,540
decides to hold out for another frame

00:39:58,710 --> 00:40:03,030
and the XR wait frame there holds for

00:40:00,540 --> 00:40:03,250
much longer than frame 102 does so this

00:40:03,030 --> 00:40:04,750
one

00:40:03,250 --> 00:40:06,460
this is really doing is the runtime is

00:40:04,750 --> 00:40:08,170
making an effort to get the the

00:40:06,460 --> 00:40:10,000
application back on track and starting

00:40:08,170 --> 00:40:11,500
its work at a time where it thinks that

00:40:10,000 --> 00:40:16,410
the application will be done in time for

00:40:11,500 --> 00:40:18,910
the compositor present now this is a

00:40:16,410 --> 00:40:20,980
more deeply pipeline multi-threaded

00:40:18,910 --> 00:40:23,470
example this is actually kind of how

00:40:20,980 --> 00:40:25,750
Unreal Engine does it it's a little bit

00:40:23,470 --> 00:40:26,710
abstracted so I I know there are certain

00:40:25,750 --> 00:40:29,230
people in the audience that will

00:40:26,710 --> 00:40:31,720
probably disagree with my level of

00:40:29,230 --> 00:40:33,130
abstraction on it but basically unreal

00:40:31,720 --> 00:40:35,290
has a simulation thread which we call

00:40:33,130 --> 00:40:37,480
the game thread which then calls the

00:40:35,290 --> 00:40:38,800
render thread which starts to issue what

00:40:37,480 --> 00:40:41,680
we call RHI commands which is an

00:40:38,800 --> 00:40:44,110
abstraction of the rendering API and

00:40:41,680 --> 00:40:46,090
then the RHI thread starts to translate

00:40:44,110 --> 00:40:48,490
those into actual Vulcan or DirectX

00:40:46,090 --> 00:40:51,190
commands whatever so there's a layer of

00:40:48,490 --> 00:40:53,260
indirection within here that makes it a

00:40:51,190 --> 00:40:54,670
little bit more complicated so this

00:40:53,260 --> 00:40:56,260
application doesn't have any missed

00:40:54,670 --> 00:40:58,360
frames so you can see X our wait frame

00:40:56,260 --> 00:41:00,820
is pretty much firing at the same

00:40:58,360 --> 00:41:02,890
duration each time but you'll see on the

00:41:00,820 --> 00:41:04,180
render thread we the kind of lighter

00:41:02,890 --> 00:41:06,340
versions of the diamond there when we

00:41:04,180 --> 00:41:08,230
and cue the begin render commands and

00:41:06,340 --> 00:41:10,360
then they actually get executed on the

00:41:08,230 --> 00:41:13,180
RHI thread when we actually start

00:41:10,360 --> 00:41:15,700
translating them into draw calls and

00:41:13,180 --> 00:41:18,250
work for the GPU and then we have a

00:41:15,700 --> 00:41:20,380
little bit of a render thread fence over

00:41:18,250 --> 00:41:22,240
there where we say that the RHI thread

00:41:20,380 --> 00:41:25,180
can't get more than one thread ahead of

00:41:22,240 --> 00:41:26,320
the actual render thread so the

00:41:25,180 --> 00:41:28,330
interesting thing though is if you look

00:41:26,320 --> 00:41:29,470
at the the gray air or there we can

00:41:28,330 --> 00:41:31,300
actually have up to three flame

00:41:29,470 --> 00:41:32,680
frames in flight with open XR and we

00:41:31,300 --> 00:41:35,230
just extend our swap chain slightly in

00:41:32,680 --> 00:41:36,700
order to handle that so that was a very

00:41:35,230 --> 00:41:38,380
brief summary of something that took

00:41:36,700 --> 00:41:39,700
about three months of rendering

00:41:38,380 --> 00:41:41,620
programmers fighting in a room over a

00:41:39,700 --> 00:41:43,390
whiteboard to get but we're pretty

00:41:41,620 --> 00:41:45,730
confident now that we've started

00:41:43,390 --> 00:41:47,770
implementing stuff that this solution

00:41:45,730 --> 00:41:48,880
will work for kind of future proofing

00:41:47,770 --> 00:41:51,970
ourselves against you know highly

00:41:48,880 --> 00:41:53,200
parallel api's as well as kind of work

00:41:51,970 --> 00:41:54,460
in the simple case where you just have

00:41:53,200 --> 00:41:58,060
kind of a simple render loop and maybe

00:41:54,460 --> 00:41:59,770
one or two threads working on it in

00:41:58,060 --> 00:42:02,560
terms of actually managing the swap

00:41:59,770 --> 00:42:04,060
chains it's a pretty simple system that

00:42:02,560 --> 00:42:06,010
if you've done any rendering programming

00:42:04,060 --> 00:42:07,990
you should be pretty familiar we create

00:42:06,010 --> 00:42:10,330
the swap chains based on the XR system

00:42:07,990 --> 00:42:12,130
so we say hey device what's your native

00:42:10,330 --> 00:42:13,600
resolution how deep of swap chain can

00:42:12,130 --> 00:42:16,000
you handle what should we do for

00:42:13,600 --> 00:42:17,080
recommended msaa settings you create a

00:42:16,000 --> 00:42:19,000
swap chain and

00:42:17,080 --> 00:42:20,290
then right after that you get a swab

00:42:19,000 --> 00:42:21,970
chain image which is what actually gives

00:42:20,290 --> 00:42:23,920
you back handles to textures that you

00:42:21,970 --> 00:42:26,640
can render to and that's based on which

00:42:23,920 --> 00:42:29,770
graphics API that you initialized in the

00:42:26,640 --> 00:42:31,300
create system and after that you can

00:42:29,770 --> 00:42:33,520
cache those textures for as long as the

00:42:31,300 --> 00:42:35,380
swap chain is alive when you're in your

00:42:33,520 --> 00:42:36,730
actual render loop you acquire a swap

00:42:35,380 --> 00:42:38,590
chain image which gives you an index

00:42:36,730 --> 00:42:40,510
into the array of images that it gave

00:42:38,590 --> 00:42:42,730
you it's important to note they're not

00:42:40,510 --> 00:42:44,110
necessarily in order the specification

00:42:42,730 --> 00:42:45,640
says if they can review returned in any

00:42:44,110 --> 00:42:48,790
order so applications have to handle

00:42:45,640 --> 00:42:50,350
that then weight swap chain image is a

00:42:48,790 --> 00:42:51,970
function that waits until that image is

00:42:50,350 --> 00:42:53,530
actually available for you but if your

00:42:51,970 --> 00:42:55,990
swap chain is long enough hopefully that

00:42:53,530 --> 00:42:57,280
shouldn't be waiting for you you can go

00:42:55,990 --> 00:42:58,840
through your normal render loop and then

00:42:57,280 --> 00:43:01,360
when you write before you're ready to

00:42:58,840 --> 00:43:02,980
call XR n frame you release the swap

00:43:01,360 --> 00:43:05,140
chain image and say hey I'm done with

00:43:02,980 --> 00:43:08,680
that and then it will use that in the

00:43:05,140 --> 00:43:11,140
next XR n frame and then when you're all

00:43:08,680 --> 00:43:14,440
done with that you call XR destroy swap

00:43:11,140 --> 00:43:16,300
chain and the whole thing goes away so

00:43:14,440 --> 00:43:19,030
as kind of a quick reminder we have a

00:43:16,300 --> 00:43:20,650
system that we call layers right now but

00:43:19,030 --> 00:43:23,410
even this name is highly controversial

00:43:20,650 --> 00:43:25,360
we jokingly named them after one of the

00:43:23,410 --> 00:43:26,890
members of the group Casas if you're

00:43:25,360 --> 00:43:29,410
familiar with Cass Everett yeah he has

00:43:26,890 --> 00:43:34,030
the honor I guess of having layers named

00:43:29,410 --> 00:43:36,400
after him in the joking manner but the

00:43:34,030 --> 00:43:38,320
compositor is actually responsible for

00:43:36,400 --> 00:43:40,600
taking all the layers that you define

00:43:38,320 --> 00:43:42,190
so left eye right eye you can have some

00:43:40,600 --> 00:43:44,710
special layers like quad layers with UI

00:43:42,190 --> 00:43:48,790
in the world and then aggregating those

00:43:44,710 --> 00:43:50,230
all together in xrn frame the XR when

00:43:48,790 --> 00:43:52,660
you give them tax tower in frame you

00:43:50,230 --> 00:43:55,570
give them the composite composition data

00:43:52,660 --> 00:43:58,120
which kind of specifies a type a display

00:43:55,570 --> 00:44:00,130
time when the XR runtime expects them to

00:43:58,120 --> 00:44:02,470
actually be presented which I they're

00:44:00,130 --> 00:44:04,840
associated with if any and what space

00:44:02,470 --> 00:44:05,860
they're in so again if you go back to

00:44:04,840 --> 00:44:07,780
the very beginning where you can define

00:44:05,860 --> 00:44:10,240
multiple basis spaces you can do that

00:44:07,780 --> 00:44:12,130
with everything like compositor layers

00:44:10,240 --> 00:44:14,500
so if you wanted to for instance have a

00:44:12,130 --> 00:44:16,390
quad layer that hovers above a track

00:44:14,500 --> 00:44:17,890
device or a motion controller you can

00:44:16,390 --> 00:44:19,570
specify that as the space and just give

00:44:17,890 --> 00:44:20,680
it a static offset and then the runtime

00:44:19,570 --> 00:44:22,360
will do all the math under the hood for

00:44:20,680 --> 00:44:28,390
you so it's it's pretty slick being able

00:44:22,360 --> 00:44:29,590
to define arbitrary basis the two most

00:44:28,390 --> 00:44:31,960
common types

00:44:29,590 --> 00:44:34,090
compositor layers are the XR composite

00:44:31,960 --> 00:44:35,800
layer multi projection which kind of is

00:44:34,090 --> 00:44:37,900
just basically your your basic left eye

00:44:35,800 --> 00:44:40,120
right eye stereoscopic one and then the

00:44:37,900 --> 00:44:42,640
XR layer quad which is the kind of quad

00:44:40,120 --> 00:44:43,930
elements that just live in the world but

00:44:42,640 --> 00:44:46,600
again this is one where there's a lot of

00:44:43,930 --> 00:44:47,830
extensions currently and we expect a lot

00:44:46,600 --> 00:44:50,130
of extensions to come up that allow you

00:44:47,830 --> 00:44:52,210
to do things like cube map layers

00:44:50,130 --> 00:44:54,190
cylindrical layers other types of layers

00:44:52,210 --> 00:44:55,840
that may require more specialized

00:44:54,190 --> 00:44:58,000
processing or only some runtimes may

00:44:55,840 --> 00:45:02,890
choose to support but these two are kind

00:44:58,000 --> 00:45:05,650
of core and fundamental to the spec kind

00:45:02,890 --> 00:45:07,300
of the the last bit of the the rendering

00:45:05,650 --> 00:45:09,220
pipeline is the viewport configurations

00:45:07,300 --> 00:45:10,810
and this is something that we actually

00:45:09,220 --> 00:45:13,600
deliberated on for quite a while but

00:45:10,810 --> 00:45:15,400
this is part of what let's open XR kind

00:45:13,600 --> 00:45:17,380
of target everything from camera

00:45:15,400 --> 00:45:19,180
pass-through AR the stereoscopic VR and

00:45:17,380 --> 00:45:21,640
AR to something like a cave which has a

00:45:19,180 --> 00:45:23,860
lot of projections basically you can

00:45:21,640 --> 00:45:25,540
query an XR system and say hey what kind

00:45:23,860 --> 00:45:28,180
of viewport configurations do you

00:45:25,540 --> 00:45:30,730
support so on if you go left to right a

00:45:28,180 --> 00:45:31,870
simple case might be one viewport and if

00:45:30,730 --> 00:45:34,330
you look at the very bottom these are

00:45:31,870 --> 00:45:36,160
all addressed again through XR paths so

00:45:34,330 --> 00:45:37,840
they're kind of hierarchical you can say

00:45:36,160 --> 00:45:39,610
what part of a R configurations do you

00:45:37,840 --> 00:45:41,260
support what sort of VR configurations

00:45:39,610 --> 00:45:42,820
do you support and under each one of

00:45:41,260 --> 00:45:45,550
those it might have a bunch of different

00:45:42,820 --> 00:45:47,920
options for it so for instance if you

00:45:45,550 --> 00:45:49,990
had a star VR headset which is a super

00:45:47,920 --> 00:45:51,550
wide field-of-view you might have one

00:45:49,990 --> 00:45:53,350
viewport configuration that has two

00:45:51,550 --> 00:45:55,360
viewports per eye to let it kind of

00:45:53,350 --> 00:45:56,560
project around or you might have a very

00:45:55,360 --> 00:45:58,810
simple just kind of stereoscopic

00:45:56,560 --> 00:46:00,940
projection that's less physically

00:45:58,810 --> 00:46:03,010
accurate but lets you kind of cheat if

00:46:00,940 --> 00:46:05,560
you don't actually aren't able to render

00:46:03,010 --> 00:46:07,660
for viewports at a time

00:46:05,560 --> 00:46:10,030
so basically applications can defy

00:46:07,660 --> 00:46:11,590
decide from the XR system which kind of

00:46:10,030 --> 00:46:13,780
a viewport configurations they want to

00:46:11,590 --> 00:46:16,360
support and then they set they say hey I

00:46:13,780 --> 00:46:18,730
want to use the standard stereoscopic vr

00:46:16,360 --> 00:46:21,640
h md viewport configuration or i want to

00:46:18,730 --> 00:46:24,430
use a two planes per eye viewport

00:46:21,640 --> 00:46:25,720
configuration and then it gets to manage

00:46:24,430 --> 00:46:26,980
that over the lifetime of the session

00:46:25,720 --> 00:46:29,080
you can switch back and forth if you

00:46:26,980 --> 00:46:30,520
want to you can drop down if your

00:46:29,080 --> 00:46:31,750
performance isn't able to render as many

00:46:30,520 --> 00:46:34,350
viewports as you want you can drop down

00:46:31,750 --> 00:46:36,760
to more simple viewport configurations

00:46:34,350 --> 00:46:39,100
runtimes don't have as much powers

00:46:36,760 --> 00:46:40,810
applications in this they can request it

00:46:39,100 --> 00:46:42,280
that the application change viewport

00:46:40,810 --> 00:46:42,800
configurations but the application

00:46:42,280 --> 00:46:45,470
doesn't actually

00:46:42,800 --> 00:46:47,540
have to listen to it and that's because

00:46:45,470 --> 00:46:48,830
we don't know for it necessarily that

00:46:47,540 --> 00:46:50,210
the application can actually support

00:46:48,830 --> 00:46:51,860
rendering to particular view port

00:46:50,210 --> 00:46:56,210
configurations so the application always

00:46:51,860 --> 00:46:57,470
has the option to opt out so this is

00:46:56,210 --> 00:46:59,150
what it kind of looks like when you call

00:46:57,470 --> 00:47:00,530
view port configurations you pass it a

00:46:59,150 --> 00:47:02,600
system because we have to know what kind

00:47:00,530 --> 00:47:04,370
of hardware you're rendering to we've

00:47:02,600 --> 00:47:06,620
passed it at a display time which is

00:47:04,370 --> 00:47:08,210
when we think that this frame will be

00:47:06,620 --> 00:47:10,940
rendered usually two or three frames in

00:47:08,210 --> 00:47:11,990
the future we ask the XR system hey what

00:47:10,940 --> 00:47:14,540
time is two or three frames in the

00:47:11,990 --> 00:47:16,100
future and we also pass it a space so

00:47:14,540 --> 00:47:17,720
that if we want to render from the

00:47:16,100 --> 00:47:19,760
center point between the eyes or if we

00:47:17,720 --> 00:47:21,320
have some other arbitrary location that

00:47:19,760 --> 00:47:23,620
we want to get the viewports relative to

00:47:21,320 --> 00:47:26,560
we can just use space to define those

00:47:23,620 --> 00:47:29,810
what that returns is an X our viewport

00:47:26,560 --> 00:47:32,120
projection info which has flags attached

00:47:29,810 --> 00:47:34,250
to it which such as are the eyes tracked

00:47:32,120 --> 00:47:35,210
in this for the gaze direction and

00:47:34,250 --> 00:47:36,440
that's kind of the only one we have

00:47:35,210 --> 00:47:38,570
right now

00:47:36,440 --> 00:47:40,400
the combined f of U of all viewports so

00:47:38,570 --> 00:47:42,320
if you need to do calling an occlusion

00:47:40,400 --> 00:47:44,390
you can have that and then an array of

00:47:42,320 --> 00:47:46,760
these X our viewport projection infos

00:47:44,390 --> 00:47:48,560
which contain a view transform a

00:47:46,760 --> 00:47:51,680
projection specification which is just

00:47:48,560 --> 00:47:53,390
kind of a matrix in the shear a gauge

00:47:51,680 --> 00:47:54,590
direction if that's not necessarily the

00:47:53,390 --> 00:47:56,300
same direction that the eyes pointing

00:47:54,590 --> 00:47:59,870
and then if it's associated with the

00:47:56,300 --> 00:48:01,340
left eye or the right eye so in certain

00:47:59,870 --> 00:48:04,700
cases you don't necessarily have one

00:48:01,340 --> 00:48:06,290
projection per eye in a case like a cave

00:48:04,700 --> 00:48:07,970
system where you have stereoscopic

00:48:06,290 --> 00:48:10,820
planes in front of you on top left right

00:48:07,970 --> 00:48:12,350
top bottom you can have six viewports

00:48:10,820 --> 00:48:13,550
per eye on there and they'd all be

00:48:12,350 --> 00:48:16,340
mapped to the left eye because you want

00:48:13,550 --> 00:48:17,870
that to use these left eyes offset and

00:48:16,340 --> 00:48:19,370
you can return as many of these as the

00:48:17,870 --> 00:48:21,170
viewport configuration has right now the

00:48:19,370 --> 00:48:23,540
only one that we've encountered so far

00:48:21,170 --> 00:48:24,920
is a cave which has 12 but usually you

00:48:23,540 --> 00:48:27,350
use one or two depending on if you're

00:48:24,920 --> 00:48:32,110
doing kind of camera pastor ray R or if

00:48:27,350 --> 00:48:32,110
you're using a stereoscopic V ar-ar-ar

00:48:32,990 --> 00:48:36,290
kind of last up in the core

00:48:34,310 --> 00:48:39,020
specification is how the device plug-in

00:48:36,290 --> 00:48:40,880
itself works it shares a lot of function

00:48:39,020 --> 00:48:43,400
calls with the normal open XR

00:48:40,880 --> 00:48:44,930
application side API you create an

00:48:43,400 --> 00:48:47,330
instance in order to get a hook to a

00:48:44,930 --> 00:48:48,830
runtime but then after that instead of

00:48:47,330 --> 00:48:52,010
actually creating a system you start

00:48:48,830 --> 00:48:54,500
defining systems so the XR device

00:48:52,010 --> 00:48:56,059
plug-in connect khr lets you then start

00:48:54,500 --> 00:48:59,689
registering things with AD

00:48:56,059 --> 00:49:01,489
vice khr and devices are basically

00:48:59,689 --> 00:49:03,229
defining a new system you use a relative

00:49:01,489 --> 00:49:05,959
path usually with my vendor and my

00:49:03,229 --> 00:49:07,759
device name and then you specify what

00:49:05,959 --> 00:49:09,979
kind of functionality that you support

00:49:07,759 --> 00:49:12,650
and functionality can be displayed track

00:49:09,979 --> 00:49:15,499
ability input haptics audio in audio out

00:49:12,650 --> 00:49:18,769
wireless mnestheus kind of leave

00:49:15,499 --> 00:49:20,150
open-ended and then once you kind of

00:49:18,769 --> 00:49:22,160
create that that gets registered as a

00:49:20,150 --> 00:49:23,779
next hour session that then the runtime

00:49:22,160 --> 00:49:25,999
can provide to applications so if you

00:49:23,779 --> 00:49:27,499
had a new headset that you wanted to

00:49:25,999 --> 00:49:28,969
support with the device plug-in you

00:49:27,499 --> 00:49:30,259
would tell it what kind of features you

00:49:28,969 --> 00:49:32,630
support that would register with the

00:49:30,259 --> 00:49:34,609
plug-in that plug them to register with

00:49:32,630 --> 00:49:35,989
the runtime and then any application

00:49:34,609 --> 00:49:37,699
that connects to that runtime can then

00:49:35,989 --> 00:49:40,099
say hey that's one of the supported

00:49:37,699 --> 00:49:43,999
devices and choose to use it it doesn't

00:49:40,099 --> 00:49:45,289
have to be an entire XR system with

00:49:43,999 --> 00:49:46,609
controllers and display you can just

00:49:45,289 --> 00:49:48,319
register if you have a controller it can

00:49:46,609 --> 00:49:49,819
go through the device input if you have

00:49:48,319 --> 00:49:50,949
some other sort of tracking mechanism

00:49:49,819 --> 00:49:53,420
that can also go through the same

00:49:50,949 --> 00:49:56,059
function so once you create and register

00:49:53,420 --> 00:49:57,920
that system you set it enabled as long

00:49:56,059 --> 00:49:59,779
as it's there and that communicates back

00:49:57,920 --> 00:50:01,939
up to the runtime and then through a

00:49:59,779 --> 00:50:04,939
system of synchronous calls like display

00:50:01,939 --> 00:50:06,439
timing info and update poses you send

00:50:04,939 --> 00:50:07,640
the information about the device up to

00:50:06,439 --> 00:50:09,650
the runtime which you can then process

00:50:07,640 --> 00:50:11,989
and then reflect up to the application

00:50:09,650 --> 00:50:13,819
if the runtime wants to communicate with

00:50:11,989 --> 00:50:16,279
the device plug-in itself it does

00:50:13,819 --> 00:50:19,729
through an event queue which is this XR

00:50:16,279 --> 00:50:22,579
plug in pole event KH R and that one

00:50:19,729 --> 00:50:23,929
unlike the application level event queue

00:50:22,579 --> 00:50:25,219
is expected to be handled within a

00:50:23,929 --> 00:50:26,420
certain duration of time because we

00:50:25,219 --> 00:50:29,119
figured that those are performance

00:50:26,420 --> 00:50:31,009
critical messages that need to be

00:50:29,119 --> 00:50:32,359
handled if the runtimes doing something

00:50:31,009 --> 00:50:33,650
like about to shut down the device

00:50:32,359 --> 00:50:36,459
plugins need to know that so they can

00:50:33,650 --> 00:50:36,459
release their resources

00:50:37,369 --> 00:50:42,259
speaking of extensions the if you're not

00:50:40,219 --> 00:50:43,729
familiar with how Chronos generally does

00:50:42,259 --> 00:50:45,469
extensions we crib this heavily from

00:50:43,729 --> 00:50:46,849
Vulcan again because they are much older

00:50:45,469 --> 00:50:49,640
and wiser than we are and we directly

00:50:46,849 --> 00:50:51,859
steal all their good ideas but in the

00:50:49,640 --> 00:50:53,749
core standard are basically our litmus

00:50:51,859 --> 00:50:56,420
test for that is core concepts that are

00:50:53,749 --> 00:50:58,099
fundamental to the specification for all

00:50:56,420 --> 00:50:59,959
use cases so things like managing your

00:50:58,099 --> 00:51:01,819
instance getting tracking information

00:50:59,959 --> 00:51:03,309
and frame timing stuff all go in the

00:51:01,819 --> 00:51:05,299
core standard so that means that every

00:51:03,309 --> 00:51:07,969
runtime that implements it has to

00:51:05,299 --> 00:51:09,000
implement those things the next class

00:51:07,969 --> 00:51:10,680
kind of

00:51:09,000 --> 00:51:12,780
next to that or what we call khr

00:51:10,680 --> 00:51:15,030
extensions which is functionality that a

00:51:12,780 --> 00:51:17,160
large class of runtimes are likely going

00:51:15,030 --> 00:51:18,540
to implement so this is actually

00:51:17,160 --> 00:51:19,920
something where we put different

00:51:18,540 --> 00:51:22,410
platform supports so like Windows and

00:51:19,920 --> 00:51:24,390
Android and Linux and Mac anything

00:51:22,410 --> 00:51:26,250
that's platform specific to that goes in

00:51:24,390 --> 00:51:27,720
a cage our extension because we expect

00:51:26,250 --> 00:51:29,550
not all runtimes are going to work on

00:51:27,720 --> 00:51:30,869
all platforms so that's something we

00:51:29,550 --> 00:51:34,380
can't put as part of the core

00:51:30,869 --> 00:51:36,720
specification it's also where we put

00:51:34,380 --> 00:51:38,040
things like the device plug-in where we

00:51:36,720 --> 00:51:39,630
hope most people will implement it but

00:51:38,040 --> 00:51:41,820
we there are legitimate reasons where

00:51:39,630 --> 00:51:43,790
some people might not be able to that

00:51:41,820 --> 00:51:46,470
sort of stuff goes into khr extensions

00:51:43,790 --> 00:51:48,780
next up our ext extensions which is

00:51:46,470 --> 00:51:50,550
functionality that a few runtimes might

00:51:48,780 --> 00:51:52,400
want to implement but aren't potentially

00:51:50,550 --> 00:51:54,810
applicable to all sorts of runtimes

00:51:52,400 --> 00:51:56,460
one of the examples of this is the

00:51:54,810 --> 00:51:58,380
performance in thermal settings which

00:51:56,460 --> 00:52:00,599
are kind of based around mobile chipsets

00:51:58,380 --> 00:52:02,970
to get thermal warnings and performance

00:52:00,599 --> 00:52:04,500
warnings when you need to throttle up or

00:52:02,970 --> 00:52:06,150
down your application and helping you do

00:52:04,500 --> 00:52:08,130
that that's an example of an ext

00:52:06,150 --> 00:52:09,869
extension or we expect a large group of

00:52:08,130 --> 00:52:12,240
people will be adopting it but not

00:52:09,869 --> 00:52:14,520
necessarily broadly across all sorts of

00:52:12,240 --> 00:52:16,140
platforms and finally we have vendors

00:52:14,520 --> 00:52:18,599
who set extensions so if you want to do

00:52:16,140 --> 00:52:19,380
something kind of experimental or you

00:52:18,599 --> 00:52:20,760
want to do something that's very

00:52:19,380 --> 00:52:22,320
specific to your piece of hardware you

00:52:20,760 --> 00:52:25,230
can write a vendor extension which fits

00:52:22,320 --> 00:52:26,730
into the the ecosystem but isn't

00:52:25,230 --> 00:52:28,550
necessarily supported across all

00:52:26,730 --> 00:52:31,260
runtimes

00:52:28,550 --> 00:52:34,470
so finally just a quick note about where

00:52:31,260 --> 00:52:36,240
we're going from here as I kind of

00:52:34,470 --> 00:52:38,070
mention we covered the grey area up to

00:52:36,240 --> 00:52:39,510
here our next step is a working group is

00:52:38,070 --> 00:52:42,089
to put out a provisional release of the

00:52:39,510 --> 00:52:43,859
spec which is kind of a release of the

00:52:42,089 --> 00:52:46,619
full specification language for people

00:52:43,859 --> 00:52:48,180
to take a look at give us feedback on

00:52:46,619 --> 00:52:50,280
but that won't necessarily have

00:52:48,180 --> 00:52:52,290
conformance testing along with it the

00:52:50,280 --> 00:52:54,780
next step after that is to define what

00:52:52,290 --> 00:52:56,820
we want to specify for conformance

00:52:54,780 --> 00:52:58,550
testing with open XR it's a little

00:52:56,820 --> 00:53:00,839
difficult because you have squishy meat

00:52:58,550 --> 00:53:03,270
beings putting stuff on their bodies and

00:53:00,839 --> 00:53:04,770
using it it's a little hard to uniformly

00:53:03,270 --> 00:53:06,510
test that sort of stuff so that that's

00:53:04,770 --> 00:53:07,980
where a lot of the kind of mental effort

00:53:06,510 --> 00:53:09,690
of the group is going to now figuring

00:53:07,980 --> 00:53:11,070
out exactly what it means to be

00:53:09,690 --> 00:53:13,680
conformant with the device plug-in API

00:53:11,070 --> 00:53:15,000
or the application level API and then

00:53:13,680 --> 00:53:16,830
shortly after that once we have an

00:53:15,000 --> 00:53:18,330
answer to all those tricky questions we

00:53:16,830 --> 00:53:20,660
can go through ratification and release

00:53:18,330 --> 00:53:22,510
the official 1.0 spec and people can

00:53:20,660 --> 00:53:24,550
choose to become

00:53:22,510 --> 00:53:27,250
ders of it and implement conformant

00:53:24,550 --> 00:53:29,710
runtimes and put him out in the wild and

00:53:27,250 --> 00:53:33,330
with that that's it does anybody have

00:53:29,710 --> 00:53:33,330
any questions thank you

00:53:37,120 --> 00:53:42,790
if you have questions please go to the

00:53:39,580 --> 00:53:44,500
mic and speak into the mic hello okay

00:53:42,790 --> 00:53:46,120
you might have actually explained this I

00:53:44,500 --> 00:53:47,800
might have missed it or something but um

00:53:46,120 --> 00:53:50,140
so you mentioned to the cave that you

00:53:47,800 --> 00:53:51,250
map everything to the left eye in order

00:53:50,140 --> 00:53:55,180
to have it all map to the left eye

00:53:51,250 --> 00:53:58,240
offset Y is the offset not just encoded

00:53:55,180 --> 00:53:59,320
as part of the view transform matrix and

00:53:58,240 --> 00:54:01,930
then it's just like the eye doesn't

00:53:59,320 --> 00:54:03,010
really I don't to like a left eye and a

00:54:01,930 --> 00:54:04,810
right eye in some ways I have an eye

00:54:03,010 --> 00:54:06,430
that is here pointed this way and an eye

00:54:04,810 --> 00:54:08,560
that is here pointed this way and like

00:54:06,430 --> 00:54:12,370
in a cave I need cameras in these six

00:54:08,560 --> 00:54:13,900
directions point in those ways yes so it

00:54:12,370 --> 00:54:15,610
is actually encoded in the view

00:54:13,900 --> 00:54:17,520
transform in that view projection info

00:54:15,610 --> 00:54:19,660
that's returned to it the eyes let's the

00:54:17,520 --> 00:54:20,830
application understand what it's

00:54:19,660 --> 00:54:23,080
actually rendering to if it has

00:54:20,830 --> 00:54:24,490
something like fused instant stereo

00:54:23,080 --> 00:54:25,990
rendering or something like that it's

00:54:24,490 --> 00:54:27,160
useful to have pairs of transforms

00:54:25,990 --> 00:54:29,710
that's basically where you use one draw

00:54:27,160 --> 00:54:31,090
call and then use Hardware instancing to

00:54:29,710 --> 00:54:33,850
draw a left eye version and a ride I

00:54:31,090 --> 00:54:37,120
version there's the term you just use

00:54:33,850 --> 00:54:38,830
there was a fused instance to stereo

00:54:37,120 --> 00:54:43,990
render stereo rendering okay look into

00:54:38,830 --> 00:54:47,490
that thank you for desktop apps that

00:54:43,990 --> 00:54:50,160
might want to support both like AVR

00:54:47,490 --> 00:54:52,780
really helpful to be able to you know

00:54:50,160 --> 00:54:55,960
homogenizer our interaction with control

00:54:52,780 --> 00:54:58,510
devices using the the XR API are you

00:54:55,960 --> 00:55:02,710
planning to support a degenerate device

00:54:58,510 --> 00:55:04,660
that is essentially a window yeah

00:55:02,710 --> 00:55:06,970
there's a extension I didn't explicitly

00:55:04,660 --> 00:55:09,190
mention it but there's a I believe we

00:55:06,970 --> 00:55:10,360
call it the headless extension on there

00:55:09,190 --> 00:55:13,180
which implies that you don't have a

00:55:10,360 --> 00:55:15,820
tracked desktop application but you can

00:55:13,180 --> 00:55:17,050
run either tracking or device input

00:55:15,820 --> 00:55:18,700
without having to worry about the render

00:55:17,050 --> 00:55:24,760
frame or loop and you can control that

00:55:18,700 --> 00:55:26,470
as a standard kind of application you

00:55:24,760 --> 00:55:27,520
don't have to know with the headless

00:55:26,470 --> 00:55:29,590
basically you turns off any

00:55:27,520 --> 00:55:31,180
functionalities and makes it so you're

00:55:29,590 --> 00:55:32,620
not required to call and allocate the

00:55:31,180 --> 00:55:39,340
Swap change stuff if you don't want to

00:55:32,620 --> 00:55:40,960
but you can if you do you could yeah you

00:55:39,340 --> 00:55:42,400
still have to have a compositor to that

00:55:40,960 --> 00:55:45,520
one was able to display it but yes you

00:55:42,400 --> 00:55:47,920
could hi a couple questions first what

00:55:45,520 --> 00:55:48,600
are the IP contribution rules in terms

00:55:47,920 --> 00:55:51,480
of propriety

00:55:48,600 --> 00:55:53,370
Terry IP at the various levels core and

00:55:51,480 --> 00:55:56,130
non-core and then do you have a

00:55:53,370 --> 00:55:58,140
provision for an exclusive application

00:55:56,130 --> 00:56:00,480
versus a cooperative or you may have

00:55:58,140 --> 00:56:02,430
multiple in the same space in the how do

00:56:00,480 --> 00:56:04,980
you find out how much time you got out

00:56:02,430 --> 00:56:07,230
of the hardware so for the the first

00:56:04,980 --> 00:56:09,030
part are you interested in the IP

00:56:07,230 --> 00:56:12,720
restrictions for the different levels of

00:56:09,030 --> 00:56:13,860
extension so this is a great question

00:56:12,720 --> 00:56:17,220
for Neel standing in the back of the

00:56:13,860 --> 00:56:18,630
room smirking but the the IP zone

00:56:17,220 --> 00:56:20,160
framework basically any contributions

00:56:18,630 --> 00:56:22,260
you make to the spec you contribute to

00:56:20,160 --> 00:56:24,240
the IP zone of the specification so it

00:56:22,260 --> 00:56:26,130
basically is freely licensed to

00:56:24,240 --> 00:56:27,870
everybody through the open XR standard

00:56:26,130 --> 00:56:30,120
you can start to get more and more

00:56:27,870 --> 00:56:32,300
proprietary and kind of encapsulate your

00:56:30,120 --> 00:56:34,530
stuff as you get to vendor specific

00:56:32,300 --> 00:56:37,700
extensions but Neal is frantically

00:56:34,530 --> 00:56:37,700
running to tell me I'm full of

00:56:37,850 --> 00:56:43,770
you're right so but it's the core and

00:56:41,190 --> 00:56:46,080
the khr extensions are under the IP

00:56:43,770 --> 00:56:47,690
framework which basically in a sense

00:56:46,080 --> 00:56:50,010
this is everyone who implements

00:56:47,690 --> 00:56:52,380
conformant open XR agrees not to sue

00:56:50,010 --> 00:56:54,510
each other but then the vendor

00:56:52,380 --> 00:56:56,220
extensions and ext is they they're

00:56:54,510 --> 00:57:03,660
people doing their own thing so that's

00:56:56,220 --> 00:57:04,890
not under the IP thanks Neal yeah that's

00:57:03,660 --> 00:57:06,390
something that's still a little bit

00:57:04,890 --> 00:57:08,220
under debate the first bit of that I had

00:57:06,390 --> 00:57:10,650
mentioned that XR session went from

00:57:08,220 --> 00:57:12,840
being a handle lifetime object into a

00:57:10,650 --> 00:57:14,070
beginning in session that's part of the

00:57:12,840 --> 00:57:16,080
discussion that we're trying to suss out

00:57:14,070 --> 00:57:16,680
exactly what we're going to do on that

00:57:16,080 --> 00:57:20,820
so

00:57:16,680 --> 00:57:29,970
TBD unfortunately I am curious about the

00:57:20,820 --> 00:57:33,900
action some worries about the

00:57:29,970 --> 00:57:36,300
combinatorial explosion flexible mmhmm

00:57:33,900 --> 00:57:38,190
yes so there's a you don't have to use

00:57:36,300 --> 00:57:39,540
action sets there's a standard global

00:57:38,190 --> 00:57:40,920
action set where if you say this is just

00:57:39,540 --> 00:57:43,650
all the stuff I care about and I want to

00:57:40,920 --> 00:57:46,200
handle that in my application you can do

00:57:43,650 --> 00:57:48,480
that freely but you can use action sets

00:57:46,200 --> 00:57:50,370
and I think the only restriction on them

00:57:48,480 --> 00:57:52,020
is you can't have an action that's in

00:57:50,370 --> 00:57:54,240
more than one set at a time unless you

00:57:52,020 --> 00:57:55,560
put it in that global action set because

00:57:54,240 --> 00:57:57,030
when you destroy an action set it

00:57:55,560 --> 00:58:00,060
destroys all of its children per the

00:57:57,030 --> 00:58:01,260
handle life cycle rules because those X

00:58:00,060 --> 00:58:01,650
are actions become children of their

00:58:01,260 --> 00:58:06,750
actions

00:58:01,650 --> 00:58:09,869
that's thanks yeah in terms of what

00:58:06,750 --> 00:58:11,819
you're cribbing from Vulcan are you also

00:58:09,869 --> 00:58:14,160
target I think it's great

00:58:11,819 --> 00:58:17,250
are you also targeting the machine

00:58:14,160 --> 00:58:19,500
readable XML representation of the API

00:58:17,250 --> 00:58:22,440
to make it easier to create alternate

00:58:19,500 --> 00:58:25,859
language bindings I'm not super familiar

00:58:22,440 --> 00:58:37,140
with that part of the Vulcan it's best

00:58:25,859 --> 00:58:40,049
few yes Carl would know yes device

00:58:37,140 --> 00:58:42,420
plugin one of the things that's been

00:58:40,049 --> 00:58:45,660
that I've seen kind of like as chaotic

00:58:42,420 --> 00:58:48,000
in the VR space is you know what do you

00:58:45,660 --> 00:58:49,829
do when somebody puts on a headset where

00:58:48,000 --> 00:58:52,589
does the audio for the application go

00:58:49,829 --> 00:58:55,230
how do you communicate that to do the

00:58:52,589 --> 00:58:58,680
the system say hey switch to this audio

00:58:55,230 --> 00:59:02,549
device are you are you gonna be focusing

00:58:58,680 --> 00:59:04,079
on that that's still one of the the open

00:59:02,549 --> 00:59:05,970
questions the device plug-in is one of

00:59:04,079 --> 00:59:07,859
the last things that's kind of being

00:59:05,970 --> 00:59:09,720
formed and coming online so we have this

00:59:07,859 --> 00:59:11,849
specification for whether or not it

00:59:09,720 --> 00:59:13,770
supports audio in and out on the plug-in

00:59:11,849 --> 00:59:15,029
device API but the lifetime and whether

00:59:13,770 --> 00:59:17,099
or not it would be routed to the actual

00:59:15,029 --> 00:59:19,559
device itself is probably part of the

00:59:17,099 --> 00:59:21,630
session which is still being debated on

00:59:19,559 --> 00:59:22,500
how specifically that's gonna be handled

00:59:21,630 --> 00:59:24,180
but it is something that we're taking

00:59:22,500 --> 00:59:29,220
into consideration because it is

00:59:24,180 --> 00:59:32,160
something of a mess just a small

00:59:29,220 --> 00:59:35,039
question about the action system and the

00:59:32,160 --> 00:59:38,760
bindings so you said that applications

00:59:35,039 --> 00:59:40,710
can suggest for known devices bindings

00:59:38,760 --> 00:59:44,190
is that a per action thing or can you

00:59:40,710 --> 00:59:46,770
suggest groups of actions incest so you

00:59:44,190 --> 00:59:49,589
could have profiles if hey does X and B

00:59:46,770 --> 00:59:52,109
does y that works but I don't want you I

00:59:49,589 --> 00:59:53,910
want to provide those two together as a

00:59:52,109 --> 00:59:56,010
suggestion as opposed to independently

00:59:53,910 --> 00:59:57,510
right now in in the spec in its current

00:59:56,010 --> 01:00:03,240
form it's by action so it's not per

00:59:57,510 --> 01:00:07,680
action set I have a question about the

01:00:03,240 --> 01:00:09,770
time frame life cycle do you specify in

01:00:07,680 --> 01:00:11,579
any way like the moment in time when

01:00:09,770 --> 01:00:14,500
compositor is working so that

01:00:11,579 --> 01:00:16,359
application is notified that

01:00:14,500 --> 01:00:18,520
in this moment in time you shouldn't do

01:00:16,359 --> 01:00:21,460
any DMA transfers or anything that could

01:00:18,520 --> 01:00:24,460
trip the compositor that that's part

01:00:21,460 --> 01:00:26,740
that's kind of implicit in the end xrn

01:00:24,460 --> 01:00:28,119
frame call we say that we're not going

01:00:26,740 --> 01:00:29,710
to submit any draw commands so it's up

01:00:28,119 --> 01:00:32,020
to the compositor to look at how long

01:00:29,710 --> 01:00:35,200
the thanks to the GPU work will take and

01:00:32,020 --> 01:00:36,940
then slot in by there but they we expect

01:00:35,200 --> 01:00:38,230
that most runtime authors kind of like

01:00:36,940 --> 01:00:40,750
they do now will use some of the

01:00:38,230 --> 01:00:42,520
preemption api's potentially to

01:00:40,750 --> 01:00:43,900
reproject a frame and displayed if the

01:00:42,520 --> 01:00:48,160
application is taking too long on the

01:00:43,900 --> 01:00:50,020
GPU okay but think about like if

01:00:48,160 --> 01:00:53,410
applications pounding in a background

01:00:50,020 --> 01:00:55,450
check transfers of de town pci that

01:00:53,410 --> 01:00:58,090
would trip compositor if compositor

01:00:55,450 --> 01:01:01,119
needs to suck in some data api as well

01:00:58,090 --> 01:01:02,200
and it's now killed behind huge so

01:01:01,119 --> 01:01:04,060
you're talking about external

01:01:02,200 --> 01:01:07,720
applications is having the GPU or

01:01:04,060 --> 01:01:10,270
something yeah at the same time when you

01:01:07,720 --> 01:01:12,490
transfer data rate but like you you

01:01:10,270 --> 01:01:14,290
finished your rendering in time before

01:01:12,490 --> 01:01:16,150
the deadline compositor can pick that up

01:01:14,290 --> 01:01:18,310
but now you trip the compositor because

01:01:16,150 --> 01:01:20,320
you still transfer textures or something

01:01:18,310 --> 01:01:22,660
yeah that's the problem of having

01:01:20,320 --> 01:01:23,830
multiple applications run it's something

01:01:22,660 --> 01:01:26,200
that we we leave largely to the

01:01:23,830 --> 01:01:27,849
compositor in order to set up the timing

01:01:26,200 --> 01:01:30,310
of it we can't force other applications

01:01:27,849 --> 01:01:31,900
not to do something on the GPU but

01:01:30,310 --> 01:01:35,320
different runtimes have different

01:01:31,900 --> 01:01:37,930
methods for mitigating that as much as

01:01:35,320 --> 01:01:39,490
possible so we don't explicitly set

01:01:37,930 --> 01:01:41,349
anything in this specification regarding

01:01:39,490 --> 01:01:42,490
that but we hope that the timing

01:01:41,349 --> 01:01:44,010
information that we do provide their

01:01:42,490 --> 01:01:46,599
runtime from the application with the

01:01:44,010 --> 01:01:48,040
begin frame end frame and wait will let

01:01:46,599 --> 01:01:48,940
the application at least do something

01:01:48,040 --> 01:01:51,010
intelligent if it keeps getting

01:01:48,940 --> 01:01:52,869
preempted on the GPU maybe throttle the

01:01:51,010 --> 01:02:05,530
application down to every other frame so

01:01:52,869 --> 01:02:08,320
that it has a larger window sorry I can

01:02:05,530 --> 01:02:10,720
here with the door by beginning and end

01:02:08,320 --> 01:02:13,150
frame to you gate like only the workload

01:02:10,720 --> 01:02:15,580
that is dependent on the poses or do you

01:02:13,150 --> 01:02:16,750
also take into notice like post

01:02:15,580 --> 01:02:19,540
independent work

01:02:16,750 --> 01:02:20,800
that could happen yet in just the stuff

01:02:19,540 --> 01:02:24,250
right now that's taken from the

01:02:20,800 --> 01:02:28,150
application between the two calls okay

01:02:24,250 --> 01:02:29,980
thanks hi I'm just curious

01:02:28,150 --> 01:02:31,540
so what extent my understanding of world

01:02:29,980 --> 01:02:33,510
geometry become a part of the spec for

01:02:31,540 --> 01:02:36,610
platforms like hololens and magic leap

01:02:33,510 --> 01:02:38,200
well so ingesting like sensor data from

01:02:36,610 --> 01:02:39,940
that yeah like a world master even

01:02:38,200 --> 01:02:42,250
semantic understanding of the world

01:02:39,940 --> 01:02:44,140
mm-hmm right now there's nothing

01:02:42,250 --> 01:02:45,460
specified in the course back but that's

01:02:44,140 --> 01:02:47,020
something that would probably target a

01:02:45,460 --> 01:02:49,660
cage our extension since there's a wide

01:02:47,020 --> 01:02:51,610
class of devices that will support that

01:02:49,660 --> 01:02:52,840
but as of right now we we aren't ready

01:02:51,610 --> 01:02:59,890
to announce anything specifically about

01:02:52,840 --> 01:03:05,800
that all right any other questions out

01:02:59,890 --> 01:03:07,630
Ben hey if you were to have somebody who

01:03:05,800 --> 01:03:08,830
wanted to do gesture input like you know

01:03:07,630 --> 01:03:11,740
circle should be a button press or

01:03:08,830 --> 01:03:13,930
something mmm Zak would you advise that

01:03:11,740 --> 01:03:16,450
being specified by the device the

01:03:13,930 --> 01:03:18,670
application or is there any support even

01:03:16,450 --> 01:03:19,480
in that for an open X R so that would

01:03:18,670 --> 01:03:21,520
probably be something that the

01:03:19,480 --> 01:03:22,840
application would devote an event to for

01:03:21,520 --> 01:03:24,130
whatever was actually listening for that

01:03:22,840 --> 01:03:25,870
and then that would be the suggested

01:03:24,130 --> 01:03:27,550
binding if there was a gesture input API

01:03:25,870 --> 01:03:29,770
that the runtime supported they would

01:03:27,550 --> 01:03:31,060
bind the circle gesture to that which

01:03:29,770 --> 01:03:32,440
would mean that you know if you had

01:03:31,060 --> 01:03:33,550
maybe a you know something that had

01:03:32,440 --> 01:03:35,020
hardware for specifically for

01:03:33,550 --> 01:03:36,430
recognizing that gesture I could send it

01:03:35,020 --> 01:03:37,570
or if you had a motion controller or

01:03:36,430 --> 01:03:39,340
something in the runtime wanted to

01:03:37,570 --> 01:03:41,350
record the position and then fire off

01:03:39,340 --> 01:03:42,640
gestures as part of the input system it

01:03:41,350 --> 01:03:44,110
would then be free to do that that makes

01:03:42,640 --> 01:03:54,790
it a little more future-proofing

01:03:44,110 --> 01:03:56,200
versatile I think you know yeah yeah you

01:03:54,790 --> 01:03:59,080
could just find that is basically one of

01:03:56,200 --> 01:04:00,910
the semantics paths that was my input

01:03:59,080 --> 01:04:02,560
gesture or something which the runtime

01:04:00,910 --> 01:04:04,300
would then present some UI to the user

01:04:02,560 --> 01:04:06,190
that could say bind the circle gesture

01:04:04,300 --> 01:04:08,950
from my magical gesture recognizer

01:04:06,190 --> 01:04:12,520
device to cast a magic whistle or

01:04:08,950 --> 01:04:15,180
something like thanks coop all right

01:04:12,520 --> 01:04:15,180
thanks everybody

01:04:15,800 --> 01:04:24,719
you

01:04:16,980 --> 01:04:24,719

YouTube URL: https://www.youtube.com/watch?v=U-CpA5d9MjI


