Title: Using PHP outside the Web Context - Andrés Correa Casablanca | IPC 2017
Publication date: 2019-01-23
Playlist: International PHP Conference 2017
Description: 
	Andrés Correa Casablanca (Adsmurai) at IPC 2017: In the last few years we’ll observed how PHP has advanced at a very fast pace improving almost all its facets (performance, consistency, security, tooling, community common practices…), but something that we haven’t seen yet is PHP as a serious option to solve problems not related to the web.

The scientific community is still small inside the PHP world, but it’s growing. In this talk we’ll discover where we are and where are we going, which pieces are missing and what we already have.

We’ll do a tour over some recent projects that are leading these efforts: machine learning, time series forecasting and other data science related problems can be solved using PHP without the need of complex technology stacks.
Captions: 
	00:00:02,100 --> 00:00:13,320
[Music]

00:00:06,710 --> 00:00:17,100
okay let's begin today we will talk

00:00:13,320 --> 00:00:21,500
about using PHP to to bring something

00:00:17,100 --> 00:00:26,849
else different not what the Blauman but

00:00:21,500 --> 00:00:30,779
scientific computation we will work with

00:00:26,849 --> 00:00:33,690
two examples because let's be realistic

00:00:30,779 --> 00:00:39,540
PHP it's not like Python but we can do

00:00:33,690 --> 00:00:44,070
some things so I'm Andrew I'm working as

00:00:39,540 --> 00:00:46,200
a developer since 2010 and I'm currently

00:00:44,070 --> 00:00:52,500
working at at Mirai which is an advent

00:00:46,200 --> 00:00:55,710
marketing company this is and what I'm

00:00:52,500 --> 00:01:01,020
doing at my company but I do tea in my

00:00:55,710 --> 00:01:09,030
spare time so I can devote as many time

00:01:01,020 --> 00:01:12,540
as I want so well okay why why we do

00:01:09,030 --> 00:01:16,320
that things because it's fine in first

00:01:12,540 --> 00:01:18,150
time I started that because sometimes we

00:01:16,320 --> 00:01:23,430
want to work on things that that we

00:01:18,150 --> 00:01:25,680
don't touch in our daily day-to-day work

00:01:23,430 --> 00:01:29,040
and because sometimes we want to

00:01:25,680 --> 00:01:31,159
experiment with what we can do with PHP

00:01:29,040 --> 00:01:34,079
or or the technologies that that we use

00:01:31,159 --> 00:01:36,990
we want to try if if something is

00:01:34,079 --> 00:01:45,090
possible because it seems difficult so

00:01:36,990 --> 00:01:47,369
we try it and sometimes we succeed they

00:01:45,090 --> 00:01:50,750
are more recent of course if it were

00:01:47,369 --> 00:01:55,049
impossible I didn't try it to begin with

00:01:50,750 --> 00:01:57,409
so why because we could we can pitch

00:01:55,049 --> 00:02:00,210
Pisa dynamically type at language

00:01:57,409 --> 00:02:03,630
dynamically typed languages I will suite

00:02:00,210 --> 00:02:07,330
that for that type of things

00:02:03,630 --> 00:02:11,200
pitch P performance has been improving

00:02:07,330 --> 00:02:14,080
over time the same is true for to link

00:02:11,200 --> 00:02:17,260
we have composer and another practices

00:02:14,080 --> 00:02:20,710
and we have a solid community behind

00:02:17,260 --> 00:02:24,160
that so I think that we can do

00:02:20,710 --> 00:02:27,100
interesting things there's a lot of

00:02:24,160 --> 00:02:30,190
things to do yet but we have a good

00:02:27,100 --> 00:02:33,670
starting point well there are more

00:02:30,190 --> 00:02:37,210
reasons I'm amused and I have invited

00:02:33,670 --> 00:02:40,380
from from other technology stacks like

00:02:37,210 --> 00:02:43,300
Python Giulia MATLAB or even c-sharp

00:02:40,380 --> 00:02:48,520
they they all have a lot of tools that

00:02:43,300 --> 00:02:51,220
we lack in PHP PHP is far behind from

00:02:48,520 --> 00:02:53,440
those technologies so I think that it's

00:02:51,220 --> 00:02:55,300
interesting to to work on that there are

00:02:53,440 --> 00:02:57,940
more reasons of course I'll continue

00:02:55,300 --> 00:03:02,860
with that but I think it's possible I

00:02:57,940 --> 00:03:04,870
think we should do that why because we

00:03:02,860 --> 00:03:08,650
need it there are lot of things that we

00:03:04,870 --> 00:03:11,620
can do with with many scientific

00:03:08,650 --> 00:03:13,390
competition libraries we can implement

00:03:11,620 --> 00:03:16,110
recommender systems classification

00:03:13,390 --> 00:03:19,180
systems we can do reinforcement learning

00:03:16,110 --> 00:03:20,709
time series forecasting or even natural

00:03:19,180 --> 00:03:25,530
language processing or many other things

00:03:20,709 --> 00:03:27,970
that that have business value

00:03:25,530 --> 00:03:30,630
recommender systems are very valuable

00:03:27,970 --> 00:03:35,260
for e-commerce social social

00:03:30,630 --> 00:03:38,739
applications online Nash's assistance we

00:03:35,260 --> 00:03:41,560
can implement for detection language

00:03:38,739 --> 00:03:47,010
detection sentiment analysis we can

00:03:41,560 --> 00:03:47,010
perform automated AV testing or even

00:03:49,320 --> 00:04:02,110
doing modifications on the code at

00:03:55,000 --> 00:04:05,730
runtime to to optimize our user

00:04:02,110 --> 00:04:08,730
interfaces or even our algorithms using

00:04:05,730 --> 00:04:12,940
machine learning techniques we can

00:04:08,730 --> 00:04:16,270
improve our reports implementing

00:04:12,940 --> 00:04:18,230
forecasting techniques we can improve

00:04:16,270 --> 00:04:21,020
our planning

00:04:18,230 --> 00:04:23,150
or stock management algorithms so we

00:04:21,020 --> 00:04:27,650
have a lot of things that we could do

00:04:23,150 --> 00:04:29,420
but we are doing it or in our case we

00:04:27,650 --> 00:04:31,610
are we are doing it with other

00:04:29,420 --> 00:04:36,590
technologies so we have more complex

00:04:31,610 --> 00:04:40,700
tasks that require the require muscular

00:04:36,590 --> 00:04:47,390
developers or larger teams and that

00:04:40,700 --> 00:04:51,050
requires sometimes a set of micro

00:04:47,390 --> 00:04:55,390
services communicating between them with

00:04:51,050 --> 00:04:59,710
IPC mechanisms or api's over the wire so

00:04:55,390 --> 00:05:03,590
if we are able to implement those things

00:04:59,710 --> 00:05:07,370
with one single language we could keep a

00:05:03,590 --> 00:05:10,160
simple stack that could be maintained by

00:05:07,370 --> 00:05:14,680
by smaller teams with less skilled

00:05:10,160 --> 00:05:16,940
people developers so it will be cheaper

00:05:14,680 --> 00:05:19,550
it's possible that for us

00:05:16,940 --> 00:05:22,000
that's not important but a lot of people

00:05:19,550 --> 00:05:25,220
around the world we are in in

00:05:22,000 --> 00:05:27,200
high-income countries that's not

00:05:25,220 --> 00:05:32,600
important for us but there are a lot of

00:05:27,200 --> 00:05:35,840
a lot of countries where PHP is one of

00:05:32,600 --> 00:05:39,530
the main languages we hear a lot from

00:05:35,840 --> 00:05:42,640
psycho flows block we could see we can

00:05:39,530 --> 00:05:46,760
see that PHP is used mainly by

00:05:42,640 --> 00:05:48,440
low-income countries we can see some

00:05:46,760 --> 00:05:51,770
satellite projects like CodeIgniter

00:05:48,440 --> 00:05:54,110
laravel or MySQL it's not a satellite

00:05:51,770 --> 00:06:00,500
project but it's very correlated with

00:05:54,110 --> 00:06:03,380
PHP as so and we can see if if we look a

00:06:00,500 --> 00:06:08,240
little technology technologies like

00:06:03,380 --> 00:06:12,410
MATLAB numpy pandas Python that are used

00:06:08,240 --> 00:06:16,750
mainly in high-income countries so if we

00:06:12,410 --> 00:06:20,570
are able to implement those algorithms

00:06:16,750 --> 00:06:23,030
those technologies in PHP we will be

00:06:20,570 --> 00:06:26,540
able to help those low-income countries

00:06:23,030 --> 00:06:29,570
to improve rate in dev technology this

00:06:26,540 --> 00:06:30,690
is good by itself this is a this is a

00:06:29,570 --> 00:06:33,270
good goal

00:06:30,690 --> 00:06:38,370
I think it's interesting that's one of

00:06:33,270 --> 00:06:41,100
my main goals so I think that this is

00:06:38,370 --> 00:06:43,710
for me this is the main reason but it's

00:06:41,100 --> 00:06:46,710
possible that for people this is not

00:06:43,710 --> 00:06:52,290
enough important for me that's not the

00:06:46,710 --> 00:06:56,010
case so here we have another plot we can

00:06:52,290 --> 00:06:58,170
see that PHP is more used in low-income

00:06:56,010 --> 00:07:02,040
countries let's use it in high-income

00:06:58,170 --> 00:07:03,840
countries we can see in purple flow data

00:07:02,040 --> 00:07:04,790
engineering related technologies are

00:07:03,840 --> 00:07:07,680
more used at in high-income countries

00:07:04,790 --> 00:07:10,380
than in the rest of the world and we can

00:07:07,680 --> 00:07:12,540
see that low-level technologies or

00:07:10,380 --> 00:07:16,800
systems related technologies like Bosch

00:07:12,540 --> 00:07:18,240
see Linux or C++ are no use it in

00:07:16,800 --> 00:07:22,560
high-income countries and in the rest of

00:07:18,240 --> 00:07:26,270
the world that's because high high

00:07:22,560 --> 00:07:29,670
income countries can can spend much more

00:07:26,270 --> 00:07:33,690
money into building blocks while

00:07:29,670 --> 00:07:36,090
low-income countries have to use those

00:07:33,690 --> 00:07:38,760
building blocks but they can't spend the

00:07:36,090 --> 00:07:44,400
resources constructing or developing

00:07:38,760 --> 00:07:47,940
that sort of things so if we improve

00:07:44,400 --> 00:07:56,840
this part of the PHP echo system we

00:07:47,940 --> 00:07:56,840
could help a lot of people so while we

00:07:57,020 --> 00:08:07,020
in to begin with we should know what do

00:08:01,890 --> 00:08:12,630
we have what we don't have so two years

00:08:07,020 --> 00:08:16,650
ago again a guy wrote an article very

00:08:12,630 --> 00:08:19,080
interesting talking about if a PHP was

00:08:16,650 --> 00:08:25,020
usable to implement machine learning

00:08:19,080 --> 00:08:27,570
techniques in 2015 it wasn't possible or

00:08:25,020 --> 00:08:29,450
at least it wasn't possible in an

00:08:27,570 --> 00:08:35,400
efficient way

00:08:29,450 --> 00:08:38,099
why because there were two kids or at

00:08:35,400 --> 00:08:40,310
least there weren't enough powerful tool

00:08:38,099 --> 00:08:40,310
kids

00:08:41,010 --> 00:08:45,900
about other topics

00:08:43,120 --> 00:08:48,490
it was worse because if we consider

00:08:45,900 --> 00:08:50,760
collaborative filtering time series

00:08:48,490 --> 00:08:54,520
forecasting natural language processing

00:08:50,760 --> 00:09:00,810
I could find some efforts but very

00:08:54,520 --> 00:09:04,540
dispersed people who work it on that

00:09:00,810 --> 00:09:08,410
didn't do a great effort on on the

00:09:04,540 --> 00:09:12,030
software engineering part they did some

00:09:08,410 --> 00:09:18,940
experiments some articles but it was

00:09:12,030 --> 00:09:21,190
pretty it they were very simple

00:09:18,940 --> 00:09:25,530
experiments so nothing that could be

00:09:21,190 --> 00:09:25,530
used in production or in business

00:09:26,160 --> 00:09:34,150
hopefully that's not the case right now

00:09:30,190 --> 00:09:36,220
we have something more here we have a

00:09:34,150 --> 00:09:42,640
very interesting project which is called

00:09:36,220 --> 00:09:45,070
pitch PML I don't remember the name of

00:09:42,640 --> 00:09:48,990
the developer because it is very strange

00:09:45,070 --> 00:09:51,400
it is from Poland or something like that

00:09:48,990 --> 00:09:57,520
it's difficult for me Tom to pronounce

00:09:51,400 --> 00:10:01,780
the so why it's interesting it's one one

00:09:57,520 --> 00:10:05,050
year old that project actually more or

00:10:01,780 --> 00:10:07,540
less it's actively develop it it's well

00:10:05,050 --> 00:10:09,910
documented we have a lot of available

00:10:07,540 --> 00:10:13,470
examples it's pretty complete

00:10:09,910 --> 00:10:15,360
we have many and many many algorithms

00:10:13,470 --> 00:10:21,240
classification algorithms we have

00:10:15,360 --> 00:10:26,410
duration algorithms we have data loading

00:10:21,240 --> 00:10:29,680
components for CSV for XML and another

00:10:26,410 --> 00:10:32,740
type of documents I think that it has

00:10:29,680 --> 00:10:35,980
some drawbacks mainly that it is too

00:10:32,740 --> 00:10:38,080
weak at least for my taste I think that

00:10:35,980 --> 00:10:41,680
it should be decomposed or split into

00:10:38,080 --> 00:10:45,370
smaller libraries in order to to be

00:10:41,680 --> 00:10:47,730
cleaner but also to help other people to

00:10:45,370 --> 00:10:51,630
implement other components

00:10:47,730 --> 00:10:55,850
using that supports that subcomponents

00:10:51,630 --> 00:11:01,650
of of HTML later we'll see some examples

00:10:55,850 --> 00:11:04,320
of PHP ml let's continue with the list

00:11:01,650 --> 00:11:08,550
of things that we have and then we'll

00:11:04,320 --> 00:11:10,740
see what we don't have more things

00:11:08,550 --> 00:11:16,830
that's a project that I even implemented

00:11:10,740 --> 00:11:19,380
it's it it likes a lot of things so I'm

00:11:16,830 --> 00:11:22,320
not very proud of it but I think it's

00:11:19,380 --> 00:11:24,960
it's an important step and there's a lot

00:11:22,320 --> 00:11:27,630
of work to do and I think that it's

00:11:24,960 --> 00:11:30,390
worth it's worth it

00:11:27,630 --> 00:11:33,450
it is it to install it works on Mac on

00:11:30,390 --> 00:11:36,930
Linux and Windows but it lacks on some

00:11:33,450 --> 00:11:43,890
things we can plot we can do plots or

00:11:36,930 --> 00:11:47,460
graphs we can show HTML tables and we

00:11:43,890 --> 00:11:50,520
don't have automatic or at least clean

00:11:47,460 --> 00:11:52,980
interfaces to to handle composite

00:11:50,520 --> 00:11:58,020
dependencies we have to require manually

00:11:52,980 --> 00:12:03,630
the out loads doctor other and and we

00:11:58,020 --> 00:12:06,960
have to know in advance the the the

00:12:03,630 --> 00:12:10,140
absolute path of where we have those

00:12:06,960 --> 00:12:13,890
libraries installed so it's easy to

00:12:10,140 --> 00:12:18,150
implement but no one did it I think I

00:12:13,890 --> 00:12:20,190
should do because it's important but

00:12:18,150 --> 00:12:23,880
well that's a that's a state of things

00:12:20,190 --> 00:12:28,170
so more things than I'll predict that I

00:12:23,880 --> 00:12:30,260
am that I started later I I will talk

00:12:28,170 --> 00:12:35,880
about why is that that I started that

00:12:30,260 --> 00:12:39,500
peach PSD s which is its name comes from

00:12:35,880 --> 00:12:39,500
scientific data structures

00:12:39,780 --> 00:12:45,810
what started as I discovered another

00:12:42,480 --> 00:12:50,640
project which is called PHP IDs which is

00:12:45,810 --> 00:12:52,320
an extension with polyfill that that has

00:12:50,640 --> 00:12:57,870
the same features

00:12:52,320 --> 00:13:00,480
this extension peach PDS is a very it's

00:12:57,870 --> 00:13:00,960
a very performant and it structure and

00:13:00,480 --> 00:13:03,510
the

00:13:00,960 --> 00:13:06,750
structures collection that it's very

00:13:03,510 --> 00:13:10,310
interesting but for our case it wasn't

00:13:06,750 --> 00:13:15,900
enough so I started to implement

00:13:10,310 --> 00:13:18,270
something different the extension part

00:13:15,900 --> 00:13:21,540
isn't finished because I've even

00:13:18,270 --> 00:13:24,540
finished the API I have to experiment a

00:13:21,540 --> 00:13:27,330
little bit more so we have two things

00:13:24,540 --> 00:13:29,880
implemented right now which are tensor

00:13:27,330 --> 00:13:32,630
or in the arrays and matrix data

00:13:29,880 --> 00:13:35,670
structures tensor or in the arrays

00:13:32,630 --> 00:13:41,100
multi-dimensional arrays that that have

00:13:35,670 --> 00:13:45,300
many special features we can reshape

00:13:41,100 --> 00:13:48,840
them we can operate between them we can

00:13:45,300 --> 00:13:51,840
operate on slices of those data

00:13:48,840 --> 00:13:55,560
structures for example we can pass a

00:13:51,840 --> 00:13:58,680
selector that specifies a separation of

00:13:55,560 --> 00:14:04,110
the tensor and apply operations only

00:13:58,680 --> 00:14:08,400
over that separation and when there are

00:14:04,110 --> 00:14:14,580
a lot of things but I didn't acquainted

00:14:08,400 --> 00:14:17,340
so I'm sorry about matrix automatics I

00:14:14,580 --> 00:14:19,440
was reviewing all the matrix

00:14:17,340 --> 00:14:23,970
implementations that are available in

00:14:19,440 --> 00:14:27,780
packages all of them without without

00:14:23,970 --> 00:14:32,270
exception are using knife algorithms

00:14:27,780 --> 00:14:37,350
which are very very slow which are

00:14:32,270 --> 00:14:42,660
pretty bad election my my implementation

00:14:37,350 --> 00:14:46,530
is is far faster than the than the

00:14:42,660 --> 00:14:54,510
matrix implementations and I didn't even

00:14:46,530 --> 00:14:58,980
use it smart algorithms I only choose an

00:14:54,510 --> 00:15:03,330
internal implementation which is using a

00:14:58,980 --> 00:15:05,880
single contiguous array instead of using

00:15:03,330 --> 00:15:08,880
nested arrays like many other libraries

00:15:05,880 --> 00:15:10,710
are doing and using

00:15:08,880 --> 00:15:15,620
a specific terrorist cell order when

00:15:10,710 --> 00:15:18,390
when we do multiplications only that to

00:15:15,620 --> 00:15:21,690
take advantage of space and time

00:15:18,390 --> 00:15:25,500
locality I think that many PHP

00:15:21,690 --> 00:15:27,480
developers don't think done or don't

00:15:25,500 --> 00:15:29,910
usually think about performance but in

00:15:27,480 --> 00:15:34,560
this case that's very important because

00:15:29,910 --> 00:15:37,950
when we do scientific computation we do

00:15:34,560 --> 00:15:42,060
a lot of computations so we need to do

00:15:37,950 --> 00:15:46,260
that in as few times as possible

00:15:42,060 --> 00:15:48,150
so for instance we are in using the

00:15:46,260 --> 00:15:51,300
stressin algorithms nor anything more

00:15:48,150 --> 00:15:55,380
advanced satellite like that and i think

00:15:51,300 --> 00:16:01,590
that it could improve even more what I

00:15:55,380 --> 00:16:04,290
have done here so I can pass this

00:16:01,590 --> 00:16:06,450
example because it's an experiment it's

00:16:04,290 --> 00:16:09,180
my last experiment isn't even finished

00:16:06,450 --> 00:16:14,220
it's it's usable like now we can

00:16:09,180 --> 00:16:17,100
forecast a simple time serious but we

00:16:14,220 --> 00:16:21,030
only have exponential time exponential

00:16:17,100 --> 00:16:24,240
smoothing with lamp damping trends and

00:16:21,030 --> 00:16:29,720
many other interesting goodies but but

00:16:24,240 --> 00:16:32,790
nothing really serious for production so

00:16:29,720 --> 00:16:36,120
this is not a project that at the moment

00:16:32,790 --> 00:16:39,450
seem it interesting for me and that was

00:16:36,120 --> 00:16:44,010
what stupid me to implement the data

00:16:39,450 --> 00:16:46,650
frame structure in the SDS a cron is a

00:16:44,010 --> 00:16:49,820
data frames the data structure which is

00:16:46,650 --> 00:16:55,590
something that we can find in the pandas

00:16:49,820 --> 00:16:58,980
library for Python and it is something

00:16:55,590 --> 00:17:01,320
that it should be it in fact it's very

00:16:58,980 --> 00:17:07,370
useful when when we deal with a lot of

00:17:01,320 --> 00:17:09,900
data or label data with some structure

00:17:07,370 --> 00:17:13,380
the problem with our con is that it's

00:17:09,900 --> 00:17:15,949
discontinued and the election of its

00:17:13,380 --> 00:17:19,199
internal data structures and algorithms

00:17:15,949 --> 00:17:21,720
it was an thought

00:17:19,199 --> 00:17:25,529
in order to be performance so it only

00:17:21,720 --> 00:17:30,179
was thought in order to be easy to use I

00:17:25,529 --> 00:17:36,450
think that's some someday someone should

00:17:30,179 --> 00:17:40,230
implement something better well what we

00:17:36,450 --> 00:17:45,059
have we don't have good data structures

00:17:40,230 --> 00:17:47,009
as I said I started to implement these

00:17:45,059 --> 00:17:54,259
two structures Mattox and

00:17:47,009 --> 00:17:54,259
tensors but it's an ongoing work work

00:17:54,529 --> 00:18:03,090
the main issue is documentation because

00:17:57,239 --> 00:18:05,549
they are usable matrix maybe not so

00:18:03,090 --> 00:18:10,950
because we don't have the embarrass

00:18:05,549 --> 00:18:14,850
operator but it could be used but and

00:18:10,950 --> 00:18:18,830
the arrays are completely usable so

00:18:14,850 --> 00:18:21,210
that's one point I have to state that

00:18:18,830 --> 00:18:24,779
performance is important I'll repeat it

00:18:21,210 --> 00:18:28,230
again and again because well when you

00:18:24,779 --> 00:18:32,100
are working with thousands or tens of

00:18:28,230 --> 00:18:34,350
thousands of data points and and you are

00:18:32,100 --> 00:18:38,159
you have to try many algorithms or many

00:18:34,350 --> 00:18:44,629
combinations of parameters you'll suffer

00:18:38,159 --> 00:18:48,119
from so computations so what's more

00:18:44,629 --> 00:18:50,159
algebra utils we have in PHP lapak

00:18:48,119 --> 00:18:54,869
that's an extension that isn't available

00:18:50,159 --> 00:19:00,090
in most Linux distros that's a problem

00:18:54,869 --> 00:19:02,940
because if you want to use lapak you you

00:19:00,090 --> 00:19:08,159
should compile it and if if you like

00:19:02,940 --> 00:19:10,409
this knowledge or time or or systems

00:19:08,159 --> 00:19:12,809
writes in your server you want to be

00:19:10,409 --> 00:19:17,450
able to use that so I don't think that

00:19:12,809 --> 00:19:23,580
it's a good option inhibition lebackes

00:19:17,450 --> 00:19:29,039
api isn't very good and and it can't

00:19:23,580 --> 00:19:30,190
work with with continues arrays it works

00:19:29,039 --> 00:19:35,080
with the

00:19:30,190 --> 00:19:37,539
colonists erase so I think that we

00:19:35,080 --> 00:19:40,960
should implement those algebra utils in

00:19:37,539 --> 00:19:45,850
in some other extension it's it's out of

00:19:40,960 --> 00:19:49,269
4 - ok that I'll repeat that repeat we

00:19:45,850 --> 00:19:51,879
need performance here we two things that

00:19:49,269 --> 00:19:54,909
we can do if we are in PHP internal

00:19:51,879 --> 00:19:57,519
experts we can choose better algorithms

00:19:54,909 --> 00:20:01,659
and we can maybe work on native

00:19:57,519 --> 00:20:03,519
extensions in the second case we should

00:20:01,659 --> 00:20:07,299
know something more but about PHP

00:20:03,519 --> 00:20:10,929
internals but not not so much as if we

00:20:07,299 --> 00:20:14,529
work with just-in-time compiler or if we

00:20:10,929 --> 00:20:19,750
try to Viki things like a seeing eye or

00:20:14,529 --> 00:20:23,080
AP eyes or things like that so ok that's

00:20:19,750 --> 00:20:28,179
an example that's that graph that I plot

00:20:23,080 --> 00:20:31,210
many moons ago that shows how choosing

00:20:28,179 --> 00:20:34,049
the right algorithm affects matrix

00:20:31,210 --> 00:20:37,720
multiplication performance that's what

00:20:34,049 --> 00:20:48,179
what what I'm using in my current

00:20:37,720 --> 00:20:53,559
implementation and and that that line is

00:20:48,179 --> 00:21:01,570
what what's being used in most PHP

00:20:53,559 --> 00:21:04,840
Mattox libraries so we have very very

00:21:01,570 --> 00:21:07,990
very fast implementation compiled with

00:21:04,840 --> 00:21:10,179
with what we can find in Pakistan pile

00:21:07,990 --> 00:21:14,409
these times with Java implementations

00:21:10,179 --> 00:21:18,039
implementations you'll wanna cry because

00:21:14,409 --> 00:21:22,679
PHP is very slow compared to two other

00:21:18,039 --> 00:21:25,679
languages more things that we all have

00:21:22,679 --> 00:21:28,149
visualization tools okay with we have

00:21:25,679 --> 00:21:30,970
plotting libraries and that sort of

00:21:28,149 --> 00:21:35,200
things but we don't what we didn't

00:21:30,970 --> 00:21:38,380
integrate it with with with day-to-day

00:21:35,200 --> 00:21:44,860
working tools like Jupiter PHP

00:21:38,380 --> 00:21:48,160
we'll see that in a few minutes like we

00:21:44,860 --> 00:21:50,620
can do in in Python if we work in in

00:21:48,160 --> 00:21:54,220
Python we have pipe loads and many other

00:21:50,620 --> 00:21:58,140
libraries and while we are working on

00:21:54,220 --> 00:22:01,320
Jupiter we can see plots or tables

00:21:58,140 --> 00:22:04,210
showing the results of what we are doing

00:22:01,320 --> 00:22:08,890
this is something that we lack right now

00:22:04,210 --> 00:22:11,130
so I think that if someone wants to work

00:22:08,890 --> 00:22:16,059
on that I'll be very grateful

00:22:11,130 --> 00:22:19,240
ok and what's more important for me

00:22:16,059 --> 00:22:22,510
we need a working group because the out

00:22:19,240 --> 00:22:26,799
of of efforts but are very dispersed we

00:22:22,510 --> 00:22:29,710
have the PHP ml I've I've talked with a

00:22:26,799 --> 00:22:35,890
caboose conda's now I remembered his

00:22:29,710 --> 00:22:38,559
name about using PHP SDS in PHP ml but

00:22:35,890 --> 00:22:44,380
there's some quicks that I have to

00:22:38,559 --> 00:22:47,559
polish before using that in PHP ml but

00:22:44,380 --> 00:22:51,340
in facts we are two guys working on that

00:22:47,559 --> 00:22:54,159
but the guy who implemented our con is

00:22:51,340 --> 00:22:57,840
another one that is working alone and

00:22:54,159 --> 00:23:02,289
there are the other guys or people

00:22:57,840 --> 00:23:04,539
working alone it it should be I think it

00:23:02,289 --> 00:23:07,690
would be interesting if people intercept

00:23:04,539 --> 00:23:10,020
on that meet together and talk about

00:23:07,690 --> 00:23:15,000
that and define standards and define

00:23:10,020 --> 00:23:21,760
api's or interfaces because this would

00:23:15,000 --> 00:23:28,980
improve our efforts ok that's not the

00:23:21,760 --> 00:23:28,980
end ok we have here

00:23:30,920 --> 00:23:38,960
I have two examples let's begin with the

00:23:35,530 --> 00:23:40,520
boring one and then we'll we'll continue

00:23:38,960 --> 00:23:45,290
with a more interesting one

00:23:40,520 --> 00:23:49,250
okay that's Jupiter this is commonly

00:23:45,290 --> 00:23:56,000
used in Python development world at

00:23:49,250 --> 00:23:58,700
least in data related tasks this Jupiter

00:23:56,000 --> 00:24:02,380
notebook is used is using pitch Jupiter

00:23:58,700 --> 00:24:05,390
PHP which is a program that connects

00:24:02,380 --> 00:24:11,260
Jupiter with with a pitch with PHP and

00:24:05,390 --> 00:24:17,480
allow us to executive each P here so

00:24:11,260 --> 00:24:18,950
here is where I want to embed plots and

00:24:17,480 --> 00:24:22,610
graphs and other sort of things that

00:24:18,950 --> 00:24:30,760
that currently I'm I'm not able to do

00:24:22,610 --> 00:24:33,169
that so okay I'll show you the s and

00:24:30,760 --> 00:24:37,570
potential implementation how it works

00:24:33,169 --> 00:24:42,640
and the next example will be a HTML

00:24:37,570 --> 00:24:49,240
implementation usage sorry

00:24:42,640 --> 00:24:53,480
okay so I have to include the autoloader

00:24:49,240 --> 00:24:55,610
manually fix specifying its the complete

00:24:53,480 --> 00:24:59,780
path because there are some things that

00:24:55,610 --> 00:25:02,450
are missing I import some libraries i

00:24:59,780 --> 00:25:09,610
some some classes and i start to use it

00:25:02,450 --> 00:25:17,690
to use them okay here I'm creating a

00:25:09,610 --> 00:25:21,799
tensor fill it with zeros which which

00:25:17,690 --> 00:25:24,230
has a shape this tensor will have three

00:25:21,799 --> 00:25:26,780
dimensions every dimension will have a

00:25:24,230 --> 00:25:27,950
size the first dimension will have three

00:25:26,780 --> 00:25:29,809
positions

00:25:27,950 --> 00:25:35,299
the second dimension will have eight

00:25:29,809 --> 00:25:38,000
positions and so on so this is like if

00:25:35,299 --> 00:25:39,559
you can think about that like three

00:25:38,000 --> 00:25:44,320
stuck at eight

00:25:39,559 --> 00:25:44,320
we're eight matrixes so

00:25:45,110 --> 00:25:53,760
for example one one example that could

00:25:48,480 --> 00:25:58,170
match this would be three images great

00:25:53,760 --> 00:26:05,270
images it great images this could match

00:25:58,170 --> 00:26:11,420
this this data structure so we access

00:26:05,270 --> 00:26:15,960
concrete entries passing vector entry

00:26:11,420 --> 00:26:19,590
this syntax is allowed in PHP PHP storm

00:26:15,960 --> 00:26:22,680
will complain about that because it snow

00:26:19,590 --> 00:26:25,470
cone it's it's being uncommon and they

00:26:22,680 --> 00:26:30,090
think that it in court but it works so

00:26:25,470 --> 00:26:36,920
we can pass anything as a as an index to

00:26:30,090 --> 00:26:41,490
to our array like in structure okay

00:26:36,920 --> 00:26:44,700
there are two two examples of access

00:26:41,490 --> 00:26:46,950
here we have we are trying to access a

00:26:44,700 --> 00:26:52,950
position that doesn't exist SDS will

00:26:46,950 --> 00:26:56,220
complain that's what we should expect we

00:26:52,950 --> 00:27:02,580
have many many other static constructors

00:26:56,220 --> 00:27:06,920
zeros ones constants we even can

00:27:02,580 --> 00:27:09,000
construct random tensors following

00:27:06,920 --> 00:27:11,070
uniform distributions or normal

00:27:09,000 --> 00:27:13,410
distributions if we use normal

00:27:11,070 --> 00:27:17,840
distributions we can specify the mean

00:27:13,410 --> 00:27:20,040
and the variance if we if we work with

00:27:17,840 --> 00:27:23,300
uniform distributions we can specify the

00:27:20,040 --> 00:27:27,060
minimum value and the maximum one

00:27:23,300 --> 00:27:31,520
this is nothing very fancy but it's a

00:27:27,060 --> 00:27:36,150
building block that that will meet so we

00:27:31,520 --> 00:27:39,960
have to begin at some points there are

00:27:36,150 --> 00:27:44,580
many things that we could do we can get

00:27:39,960 --> 00:27:48,890
the shape of our tensor we can shape our

00:27:44,580 --> 00:27:48,890
tensors for example

00:27:49,809 --> 00:28:01,879
before we had 3 / 8 / 8 tensor and then

00:27:55,039 --> 00:28:05,179
we can reshape it to 3 / 64 tensor this

00:28:01,879 --> 00:28:09,350
is useful mainly for machine learning

00:28:05,179 --> 00:28:11,149
algorithms where we transform an image

00:28:09,350 --> 00:28:16,039
that has some structure into an

00:28:11,149 --> 00:28:19,669
unstructured vector and the machine

00:28:16,039 --> 00:28:24,259
learning our in already won't know

00:28:19,669 --> 00:28:28,639
anything about the the sample structure

00:28:24,259 --> 00:28:35,929
so we'll pass we'll pass it a simple

00:28:28,639 --> 00:28:39,320
vector so we need to reshape that ok so

00:28:35,929 --> 00:28:41,419
here after reshaping we can see that

00:28:39,320 --> 00:28:47,629
that we can access positions that didn't

00:28:41,419 --> 00:28:51,159
exist before nothing more than that more

00:28:47,629 --> 00:28:55,639
things we can apply many and many

00:28:51,159 --> 00:28:59,840
aggregation functions of our tensors we

00:28:55,639 --> 00:29:06,440
can apply zooms means variance standard

00:28:59,840 --> 00:29:08,210
deviations we can apply to that

00:29:06,440 --> 00:29:12,409
operations to the world data structure

00:29:08,210 --> 00:29:15,919
but we can also choose what dimensions

00:29:12,409 --> 00:29:21,980
we want to collapse so this is important

00:29:15,919 --> 00:29:24,649
because for example if we have we have

00:29:21,980 --> 00:29:27,649
an array of images and we want to

00:29:24,649 --> 00:29:32,570
compute the luminance so we want a

00:29:27,649 --> 00:29:34,279
single number for sample so choosing the

00:29:32,570 --> 00:29:39,950
concrete dimensions we want to collapse

00:29:34,279 --> 00:29:42,950
it's useful for example in that case we

00:29:39,950 --> 00:29:46,490
have some examples of choosing what

00:29:42,950 --> 00:29:48,500
dimensions we collapse here we you are

00:29:46,490 --> 00:29:50,380
collapsing the second and third

00:29:48,500 --> 00:29:56,980
dimensions

00:29:50,380 --> 00:30:02,580
I think I've lost one example I wanted

00:29:56,980 --> 00:30:08,620
to show well that's not very important

00:30:02,580 --> 00:30:11,410
okay that we can we can collapse

00:30:08,620 --> 00:30:14,290
dimensions flow in two ways we can

00:30:11,410 --> 00:30:17,500
specify one one by one if we want to

00:30:14,290 --> 00:30:19,300
collapse it or not or we can specify one

00:30:17,500 --> 00:30:23,050
single collection specifying its

00:30:19,300 --> 00:30:27,040
concrete index that's in that case this

00:30:23,050 --> 00:30:31,030
would result as its result will be the

00:30:27,040 --> 00:30:32,560
same as that because we are only clamped

00:30:31,030 --> 00:30:38,910
to collect collapsing the first

00:30:32,560 --> 00:30:44,140
dimension okay so that's not very fancy

00:30:38,910 --> 00:30:49,090
we can do permutations over our

00:30:44,140 --> 00:30:52,150
dimensions this again can be useful if

00:30:49,090 --> 00:30:58,570
we are manipulating very strange

00:30:52,150 --> 00:31:05,830
datasets and that sort of things we can

00:30:58,570 --> 00:31:18,420
slice our tensors we can pass for

00:31:05,830 --> 00:31:23,440
example here here i passing gonna slice

00:31:18,420 --> 00:31:28,780
slice specification and i I'm assigning

00:31:23,440 --> 00:31:31,420
one tensor with shape to two to this

00:31:28,780 --> 00:31:35,830
part of the of the tensor that I've

00:31:31,420 --> 00:31:39,550
previously created so we'll have in this

00:31:35,830 --> 00:31:46,150
case is a matrix a by 3 / 3 matrix so

00:31:39,550 --> 00:31:49,540
we'll have 0 0 0 0 0 and 42 42 42 42 in

00:31:46,150 --> 00:31:54,430
that case because I only modify it

00:31:49,540 --> 00:31:58,000
one slice one region of the answer I

00:31:54,430 --> 00:32:03,060
used in this case a matrix but we can do

00:31:58,000 --> 00:32:03,060
that with very complex data structures

00:32:03,470 --> 00:32:11,900
that's not okay as you can imagine we

00:32:08,180 --> 00:32:15,830
have been re operators multiplication

00:32:11,900 --> 00:32:20,630
addition subtraction and many other one

00:32:15,830 --> 00:32:23,660
many others we can apply we can map

00:32:20,630 --> 00:32:30,260
functions over our tensors among other

00:32:23,660 --> 00:32:33,710
things so this is what I'm working on in

00:32:30,260 --> 00:32:37,010
order to integrate it with PHP ml will

00:32:33,710 --> 00:32:42,020
jump to PHP ml that's more interesting

00:32:37,010 --> 00:32:44,080
so here we have more more things to talk

00:32:42,020 --> 00:32:44,080
about

00:32:45,050 --> 00:32:54,170
to begin with we'll import the classes

00:32:49,760 --> 00:33:00,410
we will use and as a second step will

00:32:54,170 --> 00:33:03,560
load our data set this dataset we'll see

00:33:00,410 --> 00:33:07,960
it in few seconds but it's a list of

00:33:03,560 --> 00:33:11,720
phrases and English Italian French and

00:33:07,960 --> 00:33:16,790
it's language as a light label after

00:33:11,720 --> 00:33:20,410
that this example comes from the PHP ml

00:33:16,790 --> 00:33:23,800
list of examples but I've ported it to

00:33:20,410 --> 00:33:28,460
Jupiter notebook and I've added comments

00:33:23,800 --> 00:33:34,270
in order to to be able to talk about

00:33:28,460 --> 00:33:37,310
that here so we import the data set and

00:33:34,270 --> 00:33:41,600
after that we'll will start to construct

00:33:37,310 --> 00:33:46,280
some some objects that we'll use to

00:33:41,600 --> 00:33:50,710
classify our phrases and detect their

00:33:46,280 --> 00:33:55,460
languages so to begin with

00:33:50,710 --> 00:33:58,490
will instantiate work tokenizer

00:33:55,460 --> 00:34:02,120
so will transform our phrases into a

00:33:58,490 --> 00:34:04,670
list of words and after that we'll pass

00:34:02,120 --> 00:34:09,340
this word tokenizer to two concurrent

00:34:04,670 --> 00:34:12,799
vectorizer so this will transform our

00:34:09,340 --> 00:34:17,690
arrays of words

00:34:12,799 --> 00:34:21,750
into an array that counts the number of

00:34:17,690 --> 00:34:26,759
appearances of every every word for four

00:34:21,750 --> 00:34:30,980
phrase in order to classify our phrases

00:34:26,759 --> 00:34:36,089
we'll use another piece which is the

00:34:30,980 --> 00:34:39,389
tf-idf transformer this use at tf-idf

00:34:36,089 --> 00:34:44,129
algorithm algorithm which comes from

00:34:39,389 --> 00:34:46,169
term frequency investment frequency as I

00:34:44,129 --> 00:34:49,099
work here at ideas at documents are

00:34:46,169 --> 00:34:53,339
characterized by the most frequent words

00:34:49,099 --> 00:34:57,720
but what's that are very common among

00:34:53,339 --> 00:35:02,490
the world dataset Island as meaningful

00:34:57,720 --> 00:35:09,329
as words that are not so obvious

00:35:02,490 --> 00:35:16,490
so the tftf algorithm which is used is

00:35:09,329 --> 00:35:21,569
commonly used in data retrieval usages

00:35:16,490 --> 00:35:25,500
even if it has been substituted but my

00:35:21,569 --> 00:35:28,769
better algorithms it will be useful in

00:35:25,500 --> 00:35:33,420
in this case too to classify our phrases

00:35:28,769 --> 00:35:39,170
so in order to visualize our samples and

00:35:33,420 --> 00:35:46,079
to apply some transformations we'll

00:35:39,170 --> 00:35:49,440
iterate over our data set we can see

00:35:46,079 --> 00:35:51,990
here our phrases some ones are in

00:35:49,440 --> 00:35:59,110
English there are another ones in French

00:35:51,990 --> 00:36:01,970
or other languages so we apply two steps

00:35:59,110 --> 00:36:09,810
[Music]

00:36:01,970 --> 00:36:17,550
we apply fit-step and a transform step

00:36:09,810 --> 00:36:20,700
distance from step what what it does is

00:36:17,550 --> 00:36:26,010
to transform our previous array of

00:36:20,700 --> 00:36:30,000
strings into an array of vectors in this

00:36:26,010 --> 00:36:32,100
case these are counters this means that

00:36:30,000 --> 00:36:33,570
the first word we don't know which is

00:36:32,100 --> 00:36:35,760
the first word but the first word

00:36:33,570 --> 00:36:41,460
appears one single time in the first

00:36:35,760 --> 00:36:47,370
phrase and so on so here we have very

00:36:41,460 --> 00:36:50,370
large array of arrays after that we

00:36:47,370 --> 00:36:54,180
apply the tftf transformer

00:36:50,370 --> 00:36:56,040
this gives has something more maybe

00:36:54,180 --> 00:37:00,180
strange this is more difficult to

00:36:56,040 --> 00:37:04,680
interpret but it's an it's an index

00:37:00,180 --> 00:37:05,220
computed following that idea that I the

00:37:04,680 --> 00:37:09,330
type

00:37:05,220 --> 00:37:16,050
I've told before so this will be method

00:37:09,330 --> 00:37:20,760
in order to classify our phrases so now

00:37:16,050 --> 00:37:26,550
we have data with we have repeated our

00:37:20,760 --> 00:37:32,130
data so let's let's let's continue we

00:37:26,550 --> 00:37:38,880
started with a data set that came from a

00:37:32,130 --> 00:37:42,300
CSV file but we the composite it we

00:37:38,880 --> 00:37:46,410
extracted that into simple PHP arrays so

00:37:42,300 --> 00:37:52,200
we have to construct again another data

00:37:46,410 --> 00:37:56,160
set so these samples array that we've

00:37:52,200 --> 00:37:59,610
been modifying in the previous steps

00:37:56,160 --> 00:38:02,670
we'll pass that to to that array data

00:37:59,610 --> 00:38:05,460
set constructor and we'll pass again the

00:38:02,670 --> 00:38:08,160
lab the labels that we have in the

00:38:05,460 --> 00:38:13,640
original data set which are English

00:38:08,160 --> 00:38:18,570
French Italian and so on so

00:38:13,640 --> 00:38:23,250
when we have the data set again in order

00:38:18,570 --> 00:38:26,100
to to train our can see fire we'll split

00:38:23,250 --> 00:38:28,740
the data set into two main components

00:38:26,100 --> 00:38:33,090
which are the training data set and a

00:38:28,740 --> 00:38:35,790
test data set we split that because in

00:38:33,090 --> 00:38:38,970
order to to even evaluate the

00:38:35,790 --> 00:38:42,540
performance of our classifier we need an

00:38:38,970 --> 00:38:45,030
independent data set that it is not

00:38:42,540 --> 00:38:49,670
correlated with with the data set used

00:38:45,030 --> 00:38:54,540
for training so we apply a randomized at

00:38:49,670 --> 00:38:58,830
splitting we tell to split algorithm

00:38:54,540 --> 00:39:02,070
that we want 90% to the training data

00:38:58,830 --> 00:39:12,030
set and the remaining part to the

00:39:02,070 --> 00:39:17,160
testing to testing step so well we have

00:39:12,030 --> 00:39:19,710
a splitter data set and now we construct

00:39:17,160 --> 00:39:23,730
a classifier but discussing fire isn't

00:39:19,710 --> 00:39:26,130
training it yet so here the only thing

00:39:23,730 --> 00:39:29,580
that we are doing is choosing the

00:39:26,130 --> 00:39:32,220
algorithm in this case is algorithm

00:39:29,580 --> 00:39:36,810
visit on support vector machines and we

00:39:32,220 --> 00:39:39,890
are passing as a parameter parameter the

00:39:36,810 --> 00:39:45,390
kernel the kernel is a function that

00:39:39,890 --> 00:39:50,100
allows us to transform our vectorial

00:39:45,390 --> 00:39:53,730
space which has some specified number of

00:39:50,100 --> 00:39:57,030
dimensions into a big bacterial space

00:39:53,730 --> 00:40:00,420
where we can find a nipple plane that

00:39:57,030 --> 00:40:03,450
separates the data points that build

00:40:00,420 --> 00:40:07,880
that belongs to one class class or

00:40:03,450 --> 00:40:12,150
another class so we from that separation

00:40:07,880 --> 00:40:16,160
in the bigger bacterial space and we

00:40:12,150 --> 00:40:20,790
returned to the original bacterial space

00:40:16,160 --> 00:40:22,410
where our hyperplane won't be an

00:40:20,790 --> 00:40:28,799
hyperplane but and

00:40:22,410 --> 00:40:30,059
hypersurface very good but okay that's

00:40:28,799 --> 00:40:33,900
that's the general idea

00:40:30,059 --> 00:40:36,450
so the RBF is one way of doing that

00:40:33,900 --> 00:40:40,520
transformations but but there are many

00:40:36,450 --> 00:40:45,720
other ones so this is one possibility

00:40:40,520 --> 00:40:50,400
and for our case it's it's it's not very

00:40:45,720 --> 00:40:53,250
important because today mmm almost every

00:40:50,400 --> 00:40:57,240
algorithm that we can choose will

00:40:53,250 --> 00:41:02,849
perform well for us at least for basic

00:40:57,240 --> 00:41:05,309
cases so we'll train that we pass the

00:41:02,849 --> 00:41:10,589
train the train samples and it's levels

00:41:05,309 --> 00:41:15,980
I don't especially like that API but

00:41:10,589 --> 00:41:23,309
it's what it is so it works that's okay

00:41:15,980 --> 00:41:26,130
and finally we'll pass the test samples

00:41:23,309 --> 00:41:31,529
to the classifier to predict to predict

00:41:26,130 --> 00:41:33,170
its labels here we have the labels maybe

00:41:31,529 --> 00:41:39,410
I should

00:41:33,170 --> 00:41:42,859
show to the the samples but well mmm if

00:41:39,410 --> 00:41:49,599
I finish that and then we can analyze

00:41:42,859 --> 00:41:53,809
the test samples and then we can measure

00:41:49,599 --> 00:41:56,630
the training performance the classifier

00:41:53,809 --> 00:41:59,510
performance in it K and in that case we

00:41:56,630 --> 00:42:02,599
have a perfect accuracy this is entirely

00:41:59,510 --> 00:42:05,769
realistic at all because I mean I'm

00:42:02,599 --> 00:42:11,269
pretty sure that we have over fitted our

00:42:05,769 --> 00:42:14,960
training data set this is an to good

00:42:11,269 --> 00:42:18,010
this is to this is unrealistic even with

00:42:14,960 --> 00:42:24,190
super classifiers developer at Google

00:42:18,010 --> 00:42:24,190
these performances aren't realistic so

00:42:24,760 --> 00:42:36,710
that's all there are much more things

00:42:28,490 --> 00:42:40,819
about that topic but I think that there

00:42:36,710 --> 00:42:44,089
art of things to do yet so if if you

00:42:40,819 --> 00:42:46,599
have questions or something that the

00:42:44,089 --> 00:42:46,599
adapter

00:42:47,070 --> 00:42:50,419
[Music]

00:43:02,180 --> 00:43:05,350
[Music]

00:43:06,540 --> 00:43:12,910
are you are you talking about why am i

00:43:09,730 --> 00:43:48,480
am implementing things that exists in

00:43:12,910 --> 00:43:50,950
other languages and yes yes obviously I

00:43:48,480 --> 00:43:53,680
don't want to force anything but

00:43:50,950 --> 00:43:58,150
learning is an individual process at

00:43:53,680 --> 00:44:01,330
least at least from this viewpoint so

00:43:58,150 --> 00:44:02,800
everyone has to learn by themselves you

00:44:01,330 --> 00:44:05,470
can collaborate you can learn together

00:44:02,800 --> 00:44:09,460
without other people but every people

00:44:05,470 --> 00:44:13,570
has to do that effort while when you

00:44:09,460 --> 00:44:16,990
implement that only a small team of

00:44:13,570 --> 00:44:19,900
people has to do that effort and this

00:44:16,990 --> 00:44:23,380
this effort will be shared with much

00:44:19,900 --> 00:44:26,500
more people so this will never be at the

00:44:23,380 --> 00:44:31,180
level of what we can find at Python or

00:44:26,500 --> 00:44:34,450
Scala or air r or or Julia or that type

00:44:31,180 --> 00:44:36,730
of languages but I think that it could

00:44:34,450 --> 00:44:41,950
be at the level that it would be usable

00:44:36,730 --> 00:44:47,050
for small business small projects that

00:44:41,950 --> 00:44:49,869
that are confirmed by by people not not

00:44:47,050 --> 00:44:53,109
enough skilled or without enough

00:44:49,869 --> 00:44:58,810
knowledge so that's that's the aim of

00:44:53,109 --> 00:45:02,410
that initiative I don't want to keep

00:44:58,810 --> 00:45:04,960
people blocked in one technology stack I

00:45:02,410 --> 00:45:06,880
think that it's it's very

00:45:04,960 --> 00:45:09,300
it's very good to explore another

00:45:06,880 --> 00:45:12,820
technologies it's very good to learn I

00:45:09,300 --> 00:45:16,270
don't think that that people should stop

00:45:12,820 --> 00:45:19,930
doing that but I think that we could

00:45:16,270 --> 00:45:24,520
help some people that maybe doesn't have

00:45:19,930 --> 00:45:27,190
money to pay University maybe it doesn't

00:45:24,520 --> 00:45:29,190
have time to learn things because they

00:45:27,190 --> 00:45:32,920
live in countries where they don't have

00:45:29,190 --> 00:45:35,530
labral rights there are many many

00:45:32,920 --> 00:45:38,170
problems that you can face at your life

00:45:35,530 --> 00:45:43,360
if you don't live in in wealthy

00:45:38,170 --> 00:45:46,840
countries so we are not used to that

00:45:43,360 --> 00:45:49,060
problems but they exist so maybe we

00:45:46,840 --> 00:45:51,460
could help maybe not maybe I'm wrong

00:45:49,060 --> 00:45:55,510
it's possible as I am you're wrong but

00:45:51,460 --> 00:46:17,340
but I have I have some commitment about

00:45:55,510 --> 00:46:17,340
that yes

00:47:07,970 --> 00:47:11,380
[Music]

00:47:18,230 --> 00:47:28,400
yes but but that this what what did what

00:47:24,810 --> 00:47:32,160
you did see here in fact you can do it

00:47:28,400 --> 00:47:35,610
as well with Python and I think that

00:47:32,160 --> 00:47:38,790
Python is I'm defending doing it in PHP

00:47:35,610 --> 00:47:40,950
but but for a very particular reason but

00:47:38,790 --> 00:47:45,300
python is is better suited for that

00:47:40,950 --> 00:47:49,650
proposed so if you live here in germany

00:47:45,300 --> 00:47:52,500
or or in Spain or in France or in UK and

00:47:49,650 --> 00:47:56,040
you want to work on machine learning for

00:47:52,500 --> 00:47:58,710
for instance maybe you should start with

00:47:56,040 --> 00:48:01,290
Python and and you won't have any

00:47:58,710 --> 00:48:06,420
problems because Python it's it's pretty

00:48:01,290 --> 00:48:09,720
easy to to learn to but but the starting

00:48:06,420 --> 00:48:14,580
point it is important because maybe you

00:48:09,720 --> 00:48:16,560
can past ten years working only with PHP

00:48:14,580 --> 00:48:21,090
because you don't have eighteen years

00:48:16,560 --> 00:48:23,340
but maybe you have thirteen I 30 or 40

00:48:21,090 --> 00:48:29,880
and you want to start with peace bison

00:48:23,340 --> 00:48:33,600
and maybe at that points being older it

00:48:29,880 --> 00:48:36,060
will be harder to learn and and it would

00:48:33,600 --> 00:48:40,440
be harder to change the complete

00:48:36,060 --> 00:48:43,020
technology stack so this notebook is

00:48:40,440 --> 00:48:48,420
available for Python and and in fact I

00:48:43,020 --> 00:48:53,820
copied it from the Python world they

00:48:48,420 --> 00:48:57,390
meant it this was and this is this

00:48:53,820 --> 00:49:01,920
didn't start the PHP world we are

00:48:57,390 --> 00:49:05,190
copying and we don't we PHP at least at

00:49:01,920 --> 00:49:10,250
this moment it's not even it's not able

00:49:05,190 --> 00:49:15,870
to compete with with Python at at all

00:49:10,250 --> 00:49:19,080
it's not able it is impossible at least

00:49:15,870 --> 00:49:25,100
right now I don't know what will happen

00:49:19,080 --> 00:49:30,330
in some time many years in advance but

00:49:25,100 --> 00:49:34,230
but right now I only defend this this

00:49:30,330 --> 00:49:38,100
approach because it could help people

00:49:34,230 --> 00:49:41,180
that is already working on web

00:49:38,100 --> 00:49:44,150
development and that sort of things

00:49:41,180 --> 00:49:49,800
because if you want if you are starting

00:49:44,150 --> 00:49:52,190
my advice is a choose Python don't use

00:49:49,800 --> 00:49:52,190
PHP

00:50:08,119 --> 00:50:21,450
no in this case we are using super

00:50:13,710 --> 00:50:24,780
vector classifier yes which is you can

00:50:21,450 --> 00:50:29,780
think about if if you think only in a

00:50:24,780 --> 00:50:29,780
tooth in a two dimensional space and you

00:50:29,990 --> 00:50:37,830
imagine every sample as a point in the

00:50:33,869 --> 00:50:41,720
space what what what this algorithm

00:50:37,830 --> 00:50:45,119
tries to do is to draw a line between

00:50:41,720 --> 00:50:48,390
one one set of samples and the other set

00:50:45,119 --> 00:50:52,680
and that line has one special property

00:50:48,390 --> 00:50:56,340
that it tries to be a key just a key

00:50:52,680 --> 00:51:02,060
distant from them from the more extreme

00:50:56,340 --> 00:51:05,520
cases that are more near ones from what

00:51:02,060 --> 00:51:09,980
excuse me for my pronunciation and my

00:51:05,520 --> 00:51:13,380
lack of vocabulary this line tries to to

00:51:09,980 --> 00:51:15,300
be exactly at the same distance from the

00:51:13,380 --> 00:51:19,020
nearest point from one side and the

00:51:15,300 --> 00:51:23,040
nearest point from the other side so if

00:51:19,020 --> 00:51:26,670
you think about it in three dimensions

00:51:23,040 --> 00:51:29,790
what you have is a plane and if you if

00:51:26,670 --> 00:51:34,530
you think of it in more dimensions you

00:51:29,790 --> 00:51:38,700
have hyper planes but what we commonly

00:51:34,530 --> 00:51:42,089
find is that samples are mixed together

00:51:38,700 --> 00:51:46,920
so we can draw a planes or planes or

00:51:42,089 --> 00:51:49,260
lines that write our samples so there's

00:51:46,920 --> 00:51:55,950
an algebraic trick that transforms that

00:51:49,260 --> 00:51:58,099
space in a high dimensional space that

00:51:55,950 --> 00:52:02,099
in addition sometimes introduces

00:51:58,099 --> 00:52:05,240
introduces some nonlinearities that

00:52:02,099 --> 00:52:07,430
cubed the cube that space so in

00:52:05,240 --> 00:52:10,820
in that high dimensional space you are

00:52:07,430 --> 00:52:13,640
able to to find that hyperplane that

00:52:10,820 --> 00:52:18,050
separates samples from one class and the

00:52:13,640 --> 00:52:20,000
other one and then you return back to

00:52:18,050 --> 00:52:25,760
the previous original space and that

00:52:20,000 --> 00:52:29,690
hyperplane becomes a qubit hyper hyper

00:52:25,760 --> 00:52:32,780
surface so maybe where you had a

00:52:29,690 --> 00:52:36,080
straight line then you do have a cubed

00:52:32,780 --> 00:52:39,160
line but that's cubed line in the

00:52:36,080 --> 00:52:43,730
hyperspace will will be a straight one

00:52:39,160 --> 00:52:47,560
that's this is a neat mathematical trick

00:52:43,730 --> 00:52:53,380
it is very nice it is very beautiful but

00:52:47,560 --> 00:53:09,770
you have to spend some time to to get it

00:52:53,380 --> 00:53:17,420
in deep support vector machines became

00:53:09,770 --> 00:53:22,490
trains before the deep learning advent

00:53:17,420 --> 00:53:26,600
so superfecta machines are very

00:53:22,490 --> 00:53:30,770
performant are very fast and they do

00:53:26,600 --> 00:53:35,600
very well so this wasn't my my choose i

00:53:30,770 --> 00:53:43,250
I measured my example in another one but

00:53:35,600 --> 00:53:47,119
I think that a caboose conda's who

00:53:43,250 --> 00:53:48,830
implemented the first example has more

00:53:47,119 --> 00:53:53,690
experience with with super vector

00:53:48,830 --> 00:53:56,869
machines and it's pretty expectable that

00:53:53,690 --> 00:54:02,060
point because people with experience on

00:53:56,869 --> 00:54:04,760
deep learning done so much and in

00:54:02,060 --> 00:54:07,340
reality it's it's very trendy but in

00:54:04,760 --> 00:54:08,420
fact most people don't know anything

00:54:07,340 --> 00:54:11,270
about that

00:54:08,420 --> 00:54:16,340
they know that neural networks began

00:54:11,270 --> 00:54:18,010
that but they don't know why now we can

00:54:16,340 --> 00:54:20,710
train the

00:54:18,010 --> 00:54:22,840
networks and before we we were enabled

00:54:20,710 --> 00:54:24,460
we have now we have a lot of

00:54:22,840 --> 00:54:27,460
mathematical tricks that that allow us

00:54:24,460 --> 00:54:30,480
to do that but the sticks have been a

00:54:27,460 --> 00:54:35,950
trommel accumulated over years and years

00:54:30,480 --> 00:54:40,720
if you go back to a 90s the state of New

00:54:35,950 --> 00:54:43,630
York Met works was was a disaster

00:54:40,720 --> 00:54:45,430
because maybe you could if you were very

00:54:43,630 --> 00:54:48,520
good training neural network because

00:54:45,430 --> 00:54:52,690
maybe you could stack ten layer thin

00:54:48,520 --> 00:54:55,240
layers or 20 now you can stack thousands

00:54:52,690 --> 00:54:58,950
of layers so there is a very big

00:54:55,240 --> 00:55:02,130
difference and over that time when when

00:54:58,950 --> 00:55:05,770
neural networks had those problems

00:55:02,130 --> 00:55:10,660
support vector machines arise as a very

00:55:05,770 --> 00:55:14,790
promising alternative so I think that

00:55:10,660 --> 00:55:18,390
the future deploy is deep learning but

00:55:14,790 --> 00:55:24,430
deep learning is more hard to to apply

00:55:18,390 --> 00:55:27,940
and it's you need better machines you

00:55:24,430 --> 00:55:30,430
need more node mark knowledge so using

00:55:27,940 --> 00:55:33,030
support vector machines it's a pretty

00:55:30,430 --> 00:55:33,030
good election

00:55:44,590 --> 00:55:55,100
in order to use using GPUs here isn't

00:55:50,960 --> 00:56:01,100
possible because to do that we wouldn't

00:55:55,100 --> 00:56:07,280
we we need low-level buildings to be

00:56:01,100 --> 00:56:10,490
into PHP exactly mats but no one did

00:56:07,280 --> 00:56:13,580
that effort for PHP so we don't have

00:56:10,490 --> 00:56:15,500
this special piece that it would be very

00:56:13,580 --> 00:56:20,660
nice it would be fantastic but we don't

00:56:15,500 --> 00:56:23,060
have that piece and in that case we

00:56:20,660 --> 00:56:26,270
didn't we wouldn't notice the difference

00:56:23,060 --> 00:56:30,110
because we had very little data set if

00:56:26,270 --> 00:56:32,030
we had a very large data set maybe we

00:56:30,110 --> 00:56:35,180
could start noticing the difference

00:56:32,030 --> 00:56:39,620
between GPUs and CPUs but in this

00:56:35,180 --> 00:57:08,120
particular case this it would be more

00:56:39,620 --> 00:57:13,400
complicated without any gains well I'm

00:57:08,120 --> 00:57:17,930
using some components to do Bitcoin

00:57:13,400 --> 00:57:24,650
market positions but but those origins

00:57:17,930 --> 00:57:29,120
are private because one artist and the

00:57:24,650 --> 00:57:32,350
my algorithms are a disaster i if I have

00:57:29,120 --> 00:57:37,300
to to share that I would be ashame it

00:57:32,350 --> 00:57:41,840
and second when at the time when when I

00:57:37,300 --> 00:57:45,830
if someday I obtain results I won't show

00:57:41,840 --> 00:57:47,720
it but because the money not so in any

00:57:45,830 --> 00:57:50,300
case I won't share that

00:57:47,720 --> 00:57:53,359
but yes I'm using I'm using those

00:57:50,300 --> 00:57:56,030
components in order to predict between

00:57:53,359 --> 00:57:58,930
markets but it's for particular uses not

00:57:56,030 --> 00:57:58,930
for business ones

00:58:03,510 --> 00:58:06,819
[Music]

00:58:12,470 --> 00:58:24,150
[Applause]

00:58:13,870 --> 00:58:24,150

YouTube URL: https://www.youtube.com/watch?v=uqZFkvS9JpA


