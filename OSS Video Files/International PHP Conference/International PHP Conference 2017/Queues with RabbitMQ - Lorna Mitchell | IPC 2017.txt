Title: Queues with RabbitMQ - Lorna Mitchell | IPC 2017
Publication date: 2019-01-23
Playlist: International PHP Conference 2017
Description: 
	Lorna Mitchell (IBM) at IPC 2017: Queues are a powerful addition to our applications, enabling looser coupling between our components and reducing the load on key elements of the system such as the database. This session covers how queues in general, and excellent open source tool RabbitMQ in particular, can be used to improve the scalability and robustness of applications. We’ll look at designing queue structures and the options around queues, messages, and durability. Creating reliable worker scripts can be tricky but there will be advice on doing so even in systems which require complex or multi-step processing of tasks. We’ll also talk about data hygiene; when to include data with a message, when a worker should fetch data itself, and how to manage the flow of information back to the component that created the message in the first place. With stories and practical examples, this session is recommended for developers and technical architects everywhere.
Captions: 
	00:00:02,100 --> 00:00:09,630
[Music]

00:00:06,410 --> 00:00:12,840
good morning my name is Lorna I'm a

00:00:09,630 --> 00:00:15,630
developer advocate with IBM I think

00:00:12,840 --> 00:00:17,130
advocacy is a relatively new thing and

00:00:15,630 --> 00:00:19,500
I've had already had lots of questions

00:00:17,130 --> 00:00:22,560
about what that means and really it's

00:00:19,500 --> 00:00:24,810
about two things one thing is telling

00:00:22,560 --> 00:00:26,189
you about cool things IBM does which is

00:00:24,810 --> 00:00:27,269
really easy because it's mostly open

00:00:26,189 --> 00:00:29,519
source so I can just be like hey

00:00:27,269 --> 00:00:33,329
RabbitMQ and there's like a link on the

00:00:29,519 --> 00:00:35,010
last slide to ibm's cloud so if you

00:00:33,329 --> 00:00:37,260
didn't know iBM has a cloud you can run

00:00:35,010 --> 00:00:39,420
your PHP applications there and RabbitMQ

00:00:37,260 --> 00:00:40,920
is available and now you know that I've

00:00:39,420 --> 00:00:43,350
basically done my job we can concentrate

00:00:40,920 --> 00:00:45,450
on the interesting stuff the other thing

00:00:43,350 --> 00:00:47,789
I do is I hear the things that you tell

00:00:45,450 --> 00:00:50,370
me and the questions that you ask and I

00:00:47,789 --> 00:00:52,710
go back to work and I get those things

00:00:50,370 --> 00:00:55,410
changed I fix the documentation I fix

00:00:52,710 --> 00:00:57,570
the libraries I lobby for the product

00:00:55,410 --> 00:00:59,579
changes that you need I explain that the

00:00:57,570 --> 00:01:01,379
parameters are in the wrong format and

00:00:59,579 --> 00:01:03,439
all those kinds of things so it sort of

00:01:01,379 --> 00:01:05,939
works both ways and along the way I

00:01:03,439 --> 00:01:07,799
write a lot of content I also write

00:01:05,939 --> 00:01:09,780
quite a lot of code if you ask Stack

00:01:07,799 --> 00:01:11,880
Overflow questions related to the IBM

00:01:09,780 --> 00:01:13,710
cloud you are likely to get me and

00:01:11,880 --> 00:01:17,400
sometimes I speak at conferences in

00:01:13,710 --> 00:01:20,280
between all that so today I'm going to

00:01:17,400 --> 00:01:23,310
be talking about queues my examples are

00:01:20,280 --> 00:01:25,920
specifically about rabbitmq but I'm

00:01:23,310 --> 00:01:28,110
gonna try and give a nod to the other

00:01:25,920 --> 00:01:31,220
queueing tools that are available I've

00:01:28,110 --> 00:01:34,200
used a bunch of different ones and I

00:01:31,220 --> 00:01:36,420
think there's a lot of transferable

00:01:34,200 --> 00:01:39,540
ideas between the different queue

00:01:36,420 --> 00:01:43,140
offerings so this is not I am a rabbit

00:01:39,540 --> 00:01:45,829
MQ fangirl but really I just love queues

00:01:43,140 --> 00:01:49,560
in general so we'll try and mix that up

00:01:45,829 --> 00:01:52,229
let's start by talking about why I am so

00:01:49,560 --> 00:01:53,729
so excited about queues which are

00:01:52,229 --> 00:01:57,360
basically quite boring and simple idea

00:01:53,729 --> 00:02:01,500
um I really like queues because they

00:01:57,360 --> 00:02:05,070
allow us to give our application super

00:02:01,500 --> 00:02:07,970
powers so we can take quite a dull

00:02:05,070 --> 00:02:12,120
application perhaps quite an old one and

00:02:07,970 --> 00:02:12,780
give it new abilities particularly new

00:02:12,120 --> 00:02:18,240
scale

00:02:12,780 --> 00:02:19,860
abilities by adding a cue and I've put

00:02:18,240 --> 00:02:20,370
here you can a synchronously process

00:02:19,860 --> 00:02:21,780
tasks

00:02:20,370 --> 00:02:23,160
I don't think anyone is sending email in

00:02:21,780 --> 00:02:25,319
the middle of their PHP script if you

00:02:23,160 --> 00:02:26,640
are don't tell me because I'm no longer

00:02:25,319 --> 00:02:29,220
a consultant and I don't have to worry

00:02:26,640 --> 00:02:31,500
about these things but things like

00:02:29,220 --> 00:02:33,959
processing uploads formatting videos

00:02:31,500 --> 00:02:36,180
there's a reason the image thumbnailing

00:02:33,959 --> 00:02:38,640
is always the classic example it's quite

00:02:36,180 --> 00:02:42,480
a good example of something that needs

00:02:38,640 --> 00:02:44,250
doing soonish after we realize it mean

00:02:42,480 --> 00:02:47,760
it's doing but not necessarily in real

00:02:44,250 --> 00:02:53,480
time and certainly not while the user is

00:02:47,760 --> 00:02:55,800
waiting there's a clue here you can add

00:02:53,480 --> 00:02:59,489
asynchronous processing in your existing

00:02:55,800 --> 00:03:03,750
application and this is one of the

00:02:59,489 --> 00:03:07,650
things I like most about queues is you

00:03:03,750 --> 00:03:10,080
can use this technology in an existing

00:03:07,650 --> 00:03:13,230
application in an in a legacy

00:03:10,080 --> 00:03:15,540
application you don't need to wait for a

00:03:13,230 --> 00:03:18,000
new project to try this to take

00:03:15,540 --> 00:03:19,709
advantage of it and you don't need to

00:03:18,000 --> 00:03:21,750
remove something it's not like saying

00:03:19,709 --> 00:03:24,390
Postgres is also by the way Postgres

00:03:21,750 --> 00:03:26,130
really yes it's awesome but to use

00:03:24,390 --> 00:03:28,380
Postgres you need to take out MySQL use

00:03:26,130 --> 00:03:30,060
Postgres instead and that's awkward on

00:03:28,380 --> 00:03:32,579
an existing project so you probably need

00:03:30,060 --> 00:03:36,950
to wait for the next new one queues are

00:03:32,579 --> 00:03:41,459
not like that you can retrofit them so

00:03:36,950 --> 00:03:44,640
queues are particularly as we start to

00:03:41,459 --> 00:03:46,980
build web applications that are more

00:03:44,640 --> 00:03:50,130
than web sites we're doing more than

00:03:46,980 --> 00:03:52,140
that here is a picture of my cat right

00:03:50,130 --> 00:03:55,799
we are building PHP things today that

00:03:52,140 --> 00:03:58,019
are ecommerce complex applications

00:03:55,799 --> 00:04:01,019
sometimes they're entirely back-end

00:03:58,019 --> 00:04:03,750
running whole businesses and when we

00:04:01,019 --> 00:04:05,489
build applications like that we need to

00:04:03,750 --> 00:04:08,100
react to the events in those

00:04:05,489 --> 00:04:12,510
applications and we need to scale up

00:04:08,100 --> 00:04:16,289
more than just rendering webpages the

00:04:12,510 --> 00:04:19,320
queues allow us to do that by allowing

00:04:16,289 --> 00:04:22,229
different components in the system to

00:04:19,320 --> 00:04:25,260
scale up independently and by providing

00:04:22,229 --> 00:04:27,540
a loose coupling point

00:04:25,260 --> 00:04:30,510
a place where two parts of the system or

00:04:27,540 --> 00:04:33,450
your system and a third party API can

00:04:30,510 --> 00:04:36,930
communicate in a way that isn't rigidly

00:04:33,450 --> 00:04:39,120
tied together it can also be useful to

00:04:36,930 --> 00:04:42,060
integrate different parts of the system

00:04:39,120 --> 00:04:45,900
that might be written by different teams

00:04:42,060 --> 00:04:48,120
all you need to do is agree on what the

00:04:45,900 --> 00:04:52,020
data format in the queue message should

00:04:48,120 --> 00:04:54,870
be those things can even be written in

00:04:52,020 --> 00:04:57,660
different technologies because every

00:04:54,870 --> 00:05:00,840
technology is able to write the Q the Q

00:04:57,660 --> 00:05:02,430
is like a database it's it's a it

00:05:00,840 --> 00:05:05,610
doesn't care what language you're using

00:05:02,430 --> 00:05:07,740
there's nothing proprietary and so you

00:05:05,610 --> 00:05:09,210
would be able to talk to those Q's both

00:05:07,740 --> 00:05:11,520
to write them to read messages from

00:05:09,210 --> 00:05:13,890
different text acts so if you need to

00:05:11,520 --> 00:05:15,720
write one thing in a different language

00:05:13,890 --> 00:05:18,210
because there's a great library in that

00:05:15,720 --> 00:05:22,440
language the Q will also help you there

00:05:18,210 --> 00:05:24,210
I mentioned we're going to speak mostly

00:05:22,440 --> 00:05:26,820
about RabbitMQ today so those are

00:05:24,210 --> 00:05:29,640
today's examples RabbitMQ is a

00:05:26,820 --> 00:05:31,350
lightweight open-source project it's

00:05:29,640 --> 00:05:34,800
actually written in Erlang it is as

00:05:31,350 --> 00:05:39,360
solid as a rock which is why I like it

00:05:34,800 --> 00:05:43,080
rabbit MQ is very powerful very flexible

00:05:39,360 --> 00:05:47,100
I would say it is not necessarily the

00:05:43,080 --> 00:05:49,980
easiest of the queue tools to begin with

00:05:47,100 --> 00:05:52,890
so it doesn't have the easiest learning

00:05:49,980 --> 00:05:57,240
curve but it has the most powerful

00:05:52,890 --> 00:06:00,210
features some other tools here that you

00:05:57,240 --> 00:06:01,860
may have heard of and I'm often asked

00:06:00,210 --> 00:06:03,150
about the differences so let's try and

00:06:01,860 --> 00:06:07,650
cover that up front

00:06:03,150 --> 00:06:11,400
I have Gilman which is specifically a

00:06:07,650 --> 00:06:14,670
job queue so RabbitMQ is more like a

00:06:11,400 --> 00:06:16,620
message queue Gilman is more

00:06:14,670 --> 00:06:18,960
specifically a job queue today my

00:06:16,620 --> 00:06:20,730
examples are all about task queues job

00:06:18,960 --> 00:06:23,040
queue so Gilman would work just as well

00:06:20,730 --> 00:06:25,950
in all my examples today and I have used

00:06:23,040 --> 00:06:30,780
that before and I really like being dog

00:06:25,950 --> 00:06:32,400
day it's also open source even I would

00:06:30,780 --> 00:06:37,380
say definitely more lightweight than

00:06:32,400 --> 00:06:38,669
RabbitMQ simpler it'll cover a lot of

00:06:37,380 --> 00:06:41,610
your use cases

00:06:38,669 --> 00:06:44,580
being stalkers yeah saved me on a few

00:06:41,610 --> 00:06:46,949
occasions where the queue protected us

00:06:44,580 --> 00:06:52,560
from a large burst of unexpected traffic

00:06:46,949 --> 00:06:55,919
I used to work on a system which was it

00:06:52,560 --> 00:06:57,629
was to do with smart energy metering so

00:06:55,919 --> 00:07:00,719
lots and lots and lots of sensors and

00:06:57,629 --> 00:07:02,490
they would build a new block of flats a

00:07:00,719 --> 00:07:04,919
whole building full of apartments full

00:07:02,490 --> 00:07:07,919
of sensors and then they would turn it

00:07:04,919 --> 00:07:11,310
on every single one of those sensors

00:07:07,919 --> 00:07:14,460
would instantly phone home all the ones

00:07:11,310 --> 00:07:17,159
and before we had the cue the server

00:07:14,460 --> 00:07:18,419
used to just fall over and once we

00:07:17,159 --> 00:07:19,979
introduced the cube that was okay the

00:07:18,419 --> 00:07:21,509
key would get pretty full would take you

00:07:19,979 --> 00:07:25,680
know half an hour to process when we did

00:07:21,509 --> 00:07:28,110
that big reboot of a whole building but

00:07:25,680 --> 00:07:32,759
the queues give you that ability to

00:07:28,110 --> 00:07:36,150
smooth out the burstiness of the

00:07:32,759 --> 00:07:39,870
internet because when we say oh yeah

00:07:36,150 --> 00:07:42,419
we're doing 100 requests a second they

00:07:39,870 --> 00:07:45,240
don't all come in nicely spaced over

00:07:42,419 --> 00:07:47,759
that second and it's not the same in

00:07:45,240 --> 00:07:52,979
every second we know that it tends to be

00:07:47,759 --> 00:07:58,139
very jaggedy when we're under load Kafka

00:07:52,979 --> 00:07:59,939
I think is an awesome tool but a bit

00:07:58,139 --> 00:08:03,750
different what I'm talking about today

00:07:59,939 --> 00:08:05,729
so Kafka is more of a message queue you

00:08:03,750 --> 00:08:07,879
put messages on the queue you attach a

00:08:05,729 --> 00:08:10,349
consumer it processes the messages later

00:08:07,879 --> 00:08:12,689
you can attach another consumer and

00:08:10,349 --> 00:08:14,159
reprocess those messages for different

00:08:12,689 --> 00:08:16,770
purposes to check that all your

00:08:14,159 --> 00:08:20,610
transactions balance or to analyze a

00:08:16,770 --> 00:08:22,919
different report also the messages will

00:08:20,610 --> 00:08:26,069
usually come through in batches on Kafka

00:08:22,919 --> 00:08:28,409
because it's very a very much aimed at

00:08:26,069 --> 00:08:31,949
sort of data streaming so while I do use

00:08:28,409 --> 00:08:34,529
Kafka as well and I like it it's a

00:08:31,949 --> 00:08:37,589
little bit distinct to the examples that

00:08:34,529 --> 00:08:38,039
I'm giving today I have Redis on this

00:08:37,589 --> 00:08:41,250
list

00:08:38,039 --> 00:08:43,229
okay so Redis has a live Redis but has

00:08:41,250 --> 00:08:45,329
really really basic queuing

00:08:43,229 --> 00:08:48,630
functionality really basic queuing

00:08:45,329 --> 00:08:52,740
functionality but you probably already

00:08:48,630 --> 00:08:56,730
have Redis in your stack so if you need

00:08:52,740 --> 00:08:58,649
to solve a problem like tomorrow without

00:08:56,730 --> 00:09:00,630
introducing new dependencies and needing

00:08:58,649 --> 00:09:03,300
to get all of that agreed and signed off

00:09:00,630 --> 00:09:05,430
and deployed and whatever you can go in

00:09:03,300 --> 00:09:07,500
the very short term you can go to Redis

00:09:05,430 --> 00:09:10,140
to give you a little bit of queuing to

00:09:07,500 --> 00:09:12,690
solve the problem tomorrow maybe ramped

00:09:10,140 --> 00:09:14,370
up to Beanstalk or RabbitMQ next month

00:09:12,690 --> 00:09:17,490
when you've had a bit more chance just

00:09:14,370 --> 00:09:20,339
wrap your queue class really abstractly

00:09:17,490 --> 00:09:22,890
is that a word I'm English so I guess I

00:09:20,339 --> 00:09:25,230
get to make the rules just wrap that

00:09:22,890 --> 00:09:27,990
queue class and switch out the back end

00:09:25,230 --> 00:09:29,180
if you outgrow Redis if you know that

00:09:27,990 --> 00:09:31,589
you just need a small simple queue

00:09:29,180 --> 00:09:34,470
probably live with Redis for quite a

00:09:31,589 --> 00:09:37,470
long time okay

00:09:34,470 --> 00:09:39,630
Lorna concentrate RabbitMQ okay so if

00:09:37,470 --> 00:09:41,610
you are gonna run your own RabbitMQ then

00:09:39,630 --> 00:09:45,300
you need to know that it has an awesome

00:09:41,610 --> 00:09:48,570
RabbitMQ management plugin which gives

00:09:45,300 --> 00:09:50,610
you this nice web front-end so you can

00:09:48,570 --> 00:09:52,980
very easily see the size of the queues

00:09:50,610 --> 00:09:55,620
you can see how quickly messages are

00:09:52,980 --> 00:09:58,050
arriving and being processed you can

00:09:55,620 --> 00:10:00,510
also do some like manual tools here you

00:09:58,050 --> 00:10:03,600
can like add messages to queues and

00:10:00,510 --> 00:10:05,250
inspect what's there so there are some

00:10:03,600 --> 00:10:07,620
nice features and this can be quite

00:10:05,250 --> 00:10:10,260
helpful particularly I use this mostly

00:10:07,620 --> 00:10:11,940
when I'm developing like just working on

00:10:10,260 --> 00:10:16,170
something and checking that things look

00:10:11,940 --> 00:10:19,079
like I expect them to look there's also

00:10:16,170 --> 00:10:23,339
the rabbit MQ CTL tool which I use more

00:10:19,079 --> 00:10:26,010
from the command line so as with all

00:10:23,339 --> 00:10:28,770
shiny technologies there are some big

00:10:26,010 --> 00:10:30,270
words that I'll be using in this talk so

00:10:28,770 --> 00:10:32,880
I thought we would begin by talking

00:10:30,270 --> 00:10:33,990
about some of those words so that you're

00:10:32,880 --> 00:10:39,810
familiar with them and they are no

00:10:33,990 --> 00:10:42,300
longer big or mysterious the broker

00:10:39,810 --> 00:10:46,770
you'll hear message broker that's just

00:10:42,300 --> 00:10:49,529
the rabbit MQ installation within the

00:10:46,770 --> 00:10:52,279
rabbitmq server within the broker we

00:10:49,529 --> 00:10:55,970
have multiple or can have multiple

00:10:52,279 --> 00:10:58,670
exchanges so when we send a message to

00:10:55,970 --> 00:11:01,800
rabbitmq we send it to a specific

00:10:58,670 --> 00:11:04,680
exchange with some information about how

00:11:01,800 --> 00:11:06,510
this message should be routed and the

00:11:04,680 --> 00:11:08,370
queues are attached

00:11:06,510 --> 00:11:11,220
two exchanges so you'll have these

00:11:08,370 --> 00:11:15,990
little nodes exchanges each have some

00:11:11,220 --> 00:11:17,760
cues attached I've got the word queue

00:11:15,990 --> 00:11:20,340
here hopefully you're all familiar with

00:11:17,760 --> 00:11:23,550
that one The Binding key

00:11:20,340 --> 00:11:24,840
so I've binding key and routing key and

00:11:23,550 --> 00:11:26,910
hopefully I won't mix them up but

00:11:24,840 --> 00:11:30,750
sometimes that happens I have the

00:11:26,910 --> 00:11:32,940
binding key these are the rules for hey

00:11:30,750 --> 00:11:35,730
I made this queue it belongs to this

00:11:32,940 --> 00:11:38,610
exchange messages matching this pattern

00:11:35,730 --> 00:11:42,540
should go into this queue and a message

00:11:38,610 --> 00:11:45,450
might go into more than one queue if it

00:11:42,540 --> 00:11:47,880
matches more than one pattern of binding

00:11:45,450 --> 00:11:49,530
key I have an example of that later so

00:11:47,880 --> 00:11:52,950
hopefully this will make more sense with

00:11:49,530 --> 00:11:54,240
the diagram we've got the message the

00:11:52,950 --> 00:11:56,280
message is just the data that we're

00:11:54,240 --> 00:11:59,250
going to process and sometimes some

00:11:56,280 --> 00:12:01,260
metadata alongside that we have the

00:11:59,250 --> 00:12:03,540
routing key this is something that goes

00:12:01,260 --> 00:12:05,340
with the message we send it to the

00:12:03,540 --> 00:12:08,790
exchange and say route it like this and

00:12:05,340 --> 00:12:12,600
supply the message you'll also hear me

00:12:08,790 --> 00:12:15,840
say consumer or worker these are the

00:12:12,600 --> 00:12:18,420
scripts that take the messages off the

00:12:15,840 --> 00:12:21,000
queue and do something useful with them

00:12:18,420 --> 00:12:23,880
the rest is all preamble it's all set up

00:12:21,000 --> 00:12:26,900
now the workers are the clue is in the

00:12:23,880 --> 00:12:29,340
name the things that do the actual work

00:12:26,900 --> 00:12:31,410
so we've got exchanges we've got queues

00:12:29,340 --> 00:12:33,120
we've got messages and there's a few

00:12:31,410 --> 00:12:36,750
different things that you might want to

00:12:33,120 --> 00:12:39,600
know about each of those the exchanges

00:12:36,750 --> 00:12:43,800
are how we sort of separate our

00:12:39,600 --> 00:12:46,500
different areas in RabbitMQ the messages

00:12:43,800 --> 00:12:49,980
when we send a message we send it to an

00:12:46,500 --> 00:12:51,840
exchange and the exchange then takes

00:12:49,980 --> 00:12:53,580
care of taking that message and it's

00:12:51,840 --> 00:12:55,890
routing information and getting it all

00:12:53,580 --> 00:12:58,440
to the correct queues be careful if you

00:12:55,890 --> 00:13:01,290
route to acute if you send a message

00:12:58,440 --> 00:13:03,480
with a routing key which routes it to

00:13:01,290 --> 00:13:05,010
nowhere in particular RabbitMQ will

00:13:03,480 --> 00:13:06,290
indeed route your message to nowhere in

00:13:05,010 --> 00:13:09,000
particular

00:13:06,290 --> 00:13:12,150
so that is worth knowing there's no like

00:13:09,000 --> 00:13:14,550
you can set up some catch places for it

00:13:12,150 --> 00:13:18,540
they're called dead letter exchanges but

00:13:14,550 --> 00:13:20,310
just be careful with different types of

00:13:18,540 --> 00:13:23,100
exchange in RabbitMQ

00:13:20,310 --> 00:13:26,249
the first is the simplest is called the

00:13:23,100 --> 00:13:28,800
direct exchange you create you set up an

00:13:26,249 --> 00:13:32,009
exchange and you create queues with a

00:13:28,800 --> 00:13:34,230
direct exchange the routing key matches

00:13:32,009 --> 00:13:36,269
the queue name so you publish a message

00:13:34,230 --> 00:13:37,920
to an exchange with a routing key and

00:13:36,269 --> 00:13:41,339
that's just specifying which queue it

00:13:37,920 --> 00:13:44,160
goes into so that's a very simple

00:13:41,339 --> 00:13:46,170
starting point I probably recommend this

00:13:44,160 --> 00:13:48,360
when you're using it for the first time

00:13:46,170 --> 00:13:53,059
or if you're very clear about every

00:13:48,360 --> 00:13:55,680
message should go into just one queue

00:13:53,059 --> 00:13:57,600
the second type of exchange is a topic

00:13:55,680 --> 00:14:01,350
exchange now this is something that I

00:13:57,600 --> 00:14:04,889
most commonly work with and it allows us

00:14:01,350 --> 00:14:08,189
to put messages send messages to

00:14:04,889 --> 00:14:10,829
exchanges and route them according to a

00:14:08,189 --> 00:14:13,649
bunch of rules so a message might end up

00:14:10,829 --> 00:14:15,870
in more than one queue so you can have

00:14:13,649 --> 00:14:18,509
all of the messages going to an exchange

00:14:15,870 --> 00:14:20,850
these ones are related to comments these

00:14:18,509 --> 00:14:23,459
ones are related to uploads and these

00:14:20,850 --> 00:14:25,920
ones are related to my profile changes

00:14:23,459 --> 00:14:28,110
and we put all of the comment we copy

00:14:25,920 --> 00:14:31,769
all of the comment ones which might be

00:14:28,110 --> 00:14:34,079
multiple queues into a comment wildcard

00:14:31,769 --> 00:14:38,009
queue so that we can keep all that

00:14:34,079 --> 00:14:40,079
information together it's commonly used

00:14:38,009 --> 00:14:44,279
for particularly sort of auditing

00:14:40,079 --> 00:14:44,930
logging that kind of thing and the

00:14:44,279 --> 00:14:48,569
fan-out

00:14:44,930 --> 00:14:51,329
exchange where all of the cues that you

00:14:48,569 --> 00:14:54,180
bind to this type of exchange will get a

00:14:51,329 --> 00:14:57,750
copy of the message so if you're doing

00:14:54,180 --> 00:15:00,899
pub/sub and you know your subscribers up

00:14:57,750 --> 00:15:02,850
front that can be a really just an easy

00:15:00,899 --> 00:15:04,379
way to set up obviously when you're

00:15:02,850 --> 00:15:06,569
adding and removing a subscribers you

00:15:04,379 --> 00:15:08,879
have to actually add and remove cues on

00:15:06,569 --> 00:15:10,920
RabbitMQ which is a bit of an overhead

00:15:08,879 --> 00:15:16,199
but I have seen use cases where that

00:15:10,920 --> 00:15:18,089
worked pretty well I mentioned first of

00:15:16,199 --> 00:15:21,029
all the direct exchange and on rabbit

00:15:18,089 --> 00:15:23,480
name here we have a default exchange

00:15:21,029 --> 00:15:26,429
which is used in all of the hello world

00:15:23,480 --> 00:15:29,459
examples which is just a special case of

00:15:26,429 --> 00:15:32,879
a direct exchange so the exchange has an

00:15:29,459 --> 00:15:33,720
empty string as its name and whatever we

00:15:32,879 --> 00:15:36,360
specifies

00:15:33,720 --> 00:15:38,189
routing key that will match the queue

00:15:36,360 --> 00:15:41,850
name

00:15:38,189 --> 00:15:43,410
I feel like I undersold the hello world

00:15:41,850 --> 00:15:47,149
tutorials there

00:15:43,410 --> 00:15:51,120
the RabbitMQ project itself has

00:15:47,149 --> 00:15:53,160
absolutely excellent tutorials beginner

00:15:51,120 --> 00:15:55,290
tutorials and then increasingly

00:15:53,160 --> 00:15:57,480
complicated tutorials and they're all

00:15:55,290 --> 00:15:59,970
based around specific use cases and

00:15:57,480 --> 00:16:02,819
they're available in all the different

00:15:59,970 --> 00:16:05,970
languages so you can get a specific this

00:16:02,819 --> 00:16:08,100
is how you do a two-step worker in PHP

00:16:05,970 --> 00:16:10,620
and it'll show you with the most common

00:16:08,100 --> 00:16:14,480
PHP library and all the examples that

00:16:10,620 --> 00:16:17,430
you need to run it so really excellent

00:16:14,480 --> 00:16:18,930
documentation and it's joint it's very

00:16:17,430 --> 00:16:20,459
joined up across all the different

00:16:18,930 --> 00:16:22,620
languages and the different libraries

00:16:20,459 --> 00:16:24,870
for a long time the RabbitMQ project

00:16:22,620 --> 00:16:26,879
kind of provided all of the libraries

00:16:24,870 --> 00:16:29,339
and so they had sort of central control

00:16:26,879 --> 00:16:31,019
and the upshot is great documentation

00:16:29,339 --> 00:16:32,990
but it's all on the RabbitMQ site and

00:16:31,019 --> 00:16:38,430
nothing on the individual libraries

00:16:32,990 --> 00:16:41,519
websites that was exchanges let's talk

00:16:38,430 --> 00:16:43,949
about queues you can bind queues two

00:16:41,519 --> 00:16:47,009
exchanges with binding keys

00:16:43,949 --> 00:16:49,439
these can include wildcards which is how

00:16:47,009 --> 00:16:52,139
you can catch so that allows you to send

00:16:49,439 --> 00:16:54,420
messages with slightly different routing

00:16:52,139 --> 00:16:56,699
keys and either catch them all in one

00:16:54,420 --> 00:16:58,769
queue or change your setup later so they

00:16:56,699 --> 00:17:02,879
end up in different queues you can make

00:16:58,769 --> 00:17:06,959
those decisions queues can also be

00:17:02,879 --> 00:17:08,640
marked as durable so persistent this is

00:17:06,959 --> 00:17:09,780
to do with whether or not you would like

00:17:08,640 --> 00:17:14,100
to lose data

00:17:09,780 --> 00:17:17,159
if the server restarts a lot of the time

00:17:14,100 --> 00:17:20,400
the default options are RabbitMQ similar

00:17:17,159 --> 00:17:25,789
to Redis is another good example where

00:17:20,400 --> 00:17:28,890
it's set for just raw performance not

00:17:25,789 --> 00:17:32,159
necessarily reliability your application

00:17:28,890 --> 00:17:33,690
is like around social media messages and

00:17:32,159 --> 00:17:36,210
whether you're a friend of your sister

00:17:33,690 --> 00:17:38,490
like to your colleagues photo of his cat

00:17:36,210 --> 00:17:40,230
from three weeks ago right then it

00:17:38,490 --> 00:17:43,260
probably doesn't matter if we lose some

00:17:40,230 --> 00:17:45,870
messages on restart like ah and if

00:17:43,260 --> 00:17:47,280
you're using queues in your ordering

00:17:45,870 --> 00:17:49,350
system financial app

00:17:47,280 --> 00:17:51,450
or you know something a bit more

00:17:49,350 --> 00:17:53,850
important then you probably care more

00:17:51,450 --> 00:17:54,500
about the durability and there's a

00:17:53,850 --> 00:17:57,000
gotcha

00:17:54,500 --> 00:17:59,100
the queue has to be marked as durable

00:17:57,000 --> 00:18:01,590
and the message has to be marked as

00:17:59,100 --> 00:18:05,610
durable and then it'll survive the

00:18:01,590 --> 00:18:07,260
restart so just look out for that you

00:18:05,610 --> 00:18:09,300
can set up queues to have a maximum

00:18:07,260 --> 00:18:10,860
length to stop things from growing

00:18:09,300 --> 00:18:12,990
completely out of control

00:18:10,860 --> 00:18:18,450
do keep an eye on the monitoring on the

00:18:12,990 --> 00:18:21,090
queues but also with the maximum length

00:18:18,450 --> 00:18:22,770
it means you can just dictate there's

00:18:21,090 --> 00:18:24,690
just no point having a queue longer than

00:18:22,770 --> 00:18:26,280
this because it takes too long to

00:18:24,690 --> 00:18:29,760
process or we're going to run out of

00:18:26,280 --> 00:18:31,110
memory on this server I consider this to

00:18:29,760 --> 00:18:37,470
be quite good practice set it nice and

00:18:31,110 --> 00:18:40,200
high but it can be really helpful be

00:18:37,470 --> 00:18:43,890
careful with the maximum length setting

00:18:40,200 --> 00:18:47,880
when your queue is full and a new

00:18:43,890 --> 00:18:50,010
message arrives it will be accepted onto

00:18:47,880 --> 00:18:51,300
the queue and the one that's been there

00:18:50,010 --> 00:18:54,270
the longest that was just about to get

00:18:51,300 --> 00:18:57,900
processed will be dropped and that might

00:18:54,270 --> 00:19:00,540
not be what you were expecting so just

00:18:57,900 --> 00:19:02,390
look at you have been warned that is

00:19:00,540 --> 00:19:04,950
definitely burned me more than once

00:19:02,390 --> 00:19:07,530
you can configure a queue with what we

00:19:04,950 --> 00:19:10,620
call a dead letter exchange this is just

00:19:07,530 --> 00:19:13,350
another exchange on the RabbitMQ broker

00:19:10,620 --> 00:19:15,180
and there's nothing special about this

00:19:13,350 --> 00:19:17,730
other exchange is just we put its name

00:19:15,180 --> 00:19:20,340
in a configuration setting on the queue

00:19:17,730 --> 00:19:22,850
so messages that get dropped from the

00:19:20,340 --> 00:19:25,080
queue perhaps because the queue is full

00:19:22,850 --> 00:19:26,880
end up in the dead letter exchange

00:19:25,080 --> 00:19:30,030
rather than just being sent to death

00:19:26,880 --> 00:19:34,320
null that allows us to inspect what was

00:19:30,030 --> 00:19:38,010
there have a look at whether that queue

00:19:34,320 --> 00:19:40,050
is growing very quickly look at which

00:19:38,010 --> 00:19:43,490
messages end up there and perhaps

00:19:40,050 --> 00:19:43,490
process them again later

00:19:45,230 --> 00:19:51,440
messages are essentially a string they

00:19:49,200 --> 00:19:54,390
were they're really not very exciting

00:19:51,440 --> 00:19:58,110
they're essentially a string you will

00:19:54,390 --> 00:20:00,809
commonly see JSON here and but that's

00:19:58,110 --> 00:20:03,510
purely a convention you can use whatever

00:20:00,809 --> 00:20:07,020
string based data format makes sense to

00:20:03,510 --> 00:20:08,490
you now if it's very large then it's

00:20:07,020 --> 00:20:11,280
taking up results on the server and that

00:20:08,490 --> 00:20:12,960
might affect how many messages you can

00:20:11,280 --> 00:20:15,320
easily handle or how quickly you can

00:20:12,960 --> 00:20:20,190
handle those but if you are doing

00:20:15,320 --> 00:20:22,350
slightly more serious data than social

00:20:20,190 --> 00:20:22,980
media then perhaps JSON isn't

00:20:22,350 --> 00:20:27,450
appropriate

00:20:22,980 --> 00:20:30,120
and I've also seen XML if you need the

00:20:27,450 --> 00:20:34,620
data type information but also remember

00:20:30,120 --> 00:20:38,220
with RabbitMQ often this is a link

00:20:34,620 --> 00:20:41,070
between two components that are both

00:20:38,220 --> 00:20:43,860
owned by you or by other people in your

00:20:41,070 --> 00:20:47,910
organization it's rare that you're

00:20:43,860 --> 00:20:50,640
publishing a queue to external consumers

00:20:47,910 --> 00:20:52,380
so you have a bit more control over what

00:20:50,640 --> 00:20:54,179
you can do in terms of data format and I

00:20:52,380 --> 00:20:55,980
do see the binary formats here so

00:20:54,179 --> 00:20:58,440
something like a patchy thrift would be

00:20:55,980 --> 00:21:01,620
a perfectly good fit here it tends to

00:20:58,440 --> 00:21:04,500
confuse third party general public

00:21:01,620 --> 00:21:06,090
consumers but if you are controlling

00:21:04,500 --> 00:21:07,920
both ends there's no reason why you

00:21:06,090 --> 00:21:11,309
shouldn't adopt something like that just

00:21:07,920 --> 00:21:15,750
a bit more compact than XML and a little

00:21:11,309 --> 00:21:18,570
bit more specific than JSON we can

00:21:15,750 --> 00:21:21,300
attach other metadata to our messages so

00:21:18,570 --> 00:21:23,550
for example we can set the time to live

00:21:21,300 --> 00:21:25,080
if you are sending a notification of

00:21:23,550 --> 00:21:27,450
your friend's sister liking your

00:21:25,080 --> 00:21:30,620
colleagues cat and does it make any

00:21:27,450 --> 00:21:32,790
sense to deliver that 10 minutes late

00:21:30,620 --> 00:21:35,910
we've probably moved on it's probably

00:21:32,790 --> 00:21:38,220
not no probably not important so you can

00:21:35,910 --> 00:21:40,230
set the time to live saying this is a

00:21:38,220 --> 00:21:41,190
real-time chat notification it is valid

00:21:40,230 --> 00:21:43,350
for 60 seconds

00:21:41,190 --> 00:21:45,300
if something happens your queue is

00:21:43,350 --> 00:21:47,970
filling up the consumers are not running

00:21:45,300 --> 00:21:50,040
for a few minutes those messages that

00:21:47,970 --> 00:21:53,280
have been in the queue too long well

00:21:50,040 --> 00:21:57,030
tidy themselves up which is brilliant

00:21:53,280 --> 00:21:57,309
so the stuff that is still useful when

00:21:57,030 --> 00:21:59,289
we

00:21:57,309 --> 00:22:01,960
had a problem and we're processing them

00:21:59,289 --> 00:22:03,279
messages 10 minutes late the stuff is

00:22:01,960 --> 00:22:05,100
still useful remains in the queue

00:22:03,279 --> 00:22:08,019
everything else will essentially

00:22:05,100 --> 00:22:11,559
self-destruct it actually ends up on a

00:22:08,019 --> 00:22:14,860
dead letter q you can set the durability

00:22:11,559 --> 00:22:18,220
when you set the message RabbitMQ also

00:22:14,860 --> 00:22:20,529
supports priorities I tend to think that

00:22:18,220 --> 00:22:22,539
if you have different rules about

00:22:20,529 --> 00:22:24,730
processing messages you probably should

00:22:22,539 --> 00:22:27,309
have those in different queues with

00:22:24,730 --> 00:22:29,259
dedicated worker resource but if you

00:22:27,309 --> 00:22:32,820
find yourself in the situation where you

00:22:29,259 --> 00:22:35,289
need priorities then they are available

00:22:32,820 --> 00:22:38,289
all right that's enough talk have some

00:22:35,289 --> 00:22:41,080
code for you I'm gonna show you two

00:22:38,289 --> 00:22:42,909
examples one very simple one and one

00:22:41,080 --> 00:22:44,559
that's a bit more of an echo of a

00:22:42,909 --> 00:22:47,950
real-world problem although I've tried

00:22:44,559 --> 00:22:49,990
to shrink it so it fits in my brain and

00:22:47,950 --> 00:22:53,710
on the slides is about the same sort of

00:22:49,990 --> 00:22:55,419
size so I have published my slide deck

00:22:53,710 --> 00:22:57,220
if you want to have a look at if it's

00:22:55,419 --> 00:22:59,769
easier for you to see the code in front

00:22:57,220 --> 00:23:01,779
of you if I understand technology and

00:22:59,769 --> 00:23:03,249
time zones then I've tweeted it for my

00:23:01,779 --> 00:23:05,499
Twitter account if not I guess I'll

00:23:03,249 --> 00:23:07,779
tweet it later and the code is available

00:23:05,499 --> 00:23:10,570
on github so if you'd rather see it in

00:23:07,779 --> 00:23:12,279
context as opposed to how I chopped it

00:23:10,570 --> 00:23:14,789
to fit on slides without making the

00:23:12,279 --> 00:23:17,619
front tiny then you're very very welcome

00:23:14,789 --> 00:23:22,179
for using rabbit from PHP

00:23:17,619 --> 00:23:24,610
we use this AMQP library so AMQP is a

00:23:22,179 --> 00:23:28,240
queueing standard it's implemented by

00:23:24,610 --> 00:23:33,369
other tools than rabbit and Cuba I think

00:23:28,240 --> 00:23:36,129
rabbits probably the most well known but

00:23:33,369 --> 00:23:38,110
it is standards-compliant plus a little

00:23:36,129 --> 00:23:41,110
bit of extra stuff so you're going to

00:23:38,110 --> 00:23:43,570
compose a require this PHP AMQP lib PHP

00:23:41,110 --> 00:23:45,999
impp lib it does have a couple of

00:23:43,570 --> 00:23:50,769
dependencies so you will need extensions

00:23:45,999 --> 00:23:52,629
b/c math and mb string you probably have

00:23:50,769 --> 00:23:54,999
at least one of these they're not

00:23:52,629 --> 00:23:58,600
particularly exotic extensions but

00:23:54,999 --> 00:23:59,919
that's just something to look out for so

00:23:58,600 --> 00:24:01,690
for our first example we're going to

00:23:59,919 --> 00:24:04,690
write some code that receives a web hook

00:24:01,690 --> 00:24:07,299
and writes the data to a queue to be

00:24:04,690 --> 00:24:09,340
processed later and this is because we

00:24:07,299 --> 00:24:11,920
could be receiving bursts

00:24:09,340 --> 00:24:14,950
webhooks and what we want to do is

00:24:11,920 --> 00:24:16,750
receive the data store it and close the

00:24:14,950 --> 00:24:18,160
connection and that allows the thing

00:24:16,750 --> 00:24:20,080
receiving the webhooks to keep on

00:24:18,160 --> 00:24:23,410
running not get slower and slower and

00:24:20,080 --> 00:24:26,110
slower and eventually just die leaving

00:24:23,410 --> 00:24:28,720
the connections open and then we'll

00:24:26,110 --> 00:24:30,730
process things later from that queue so

00:24:28,720 --> 00:24:32,680
for this I'm going to set up a web hook

00:24:30,730 --> 00:24:35,050
on github so this is just like a general

00:24:32,680 --> 00:24:40,350
click the web hooks button in settings

00:24:35,050 --> 00:24:40,350
on your repo put a URL of choice in here

00:24:40,410 --> 00:24:47,440
specify the content type good hub will

00:24:43,480 --> 00:24:49,420
send you a forum post but I find that a

00:24:47,440 --> 00:24:52,630
bit odd so I'm working with JSON because

00:24:49,420 --> 00:24:54,460
that's how I think web hooks work credit

00:24:52,630 --> 00:24:56,530
to github they also have this secret

00:24:54,460 --> 00:25:00,370
thing which will give you like an H max

00:24:56,530 --> 00:25:03,490
signature most web hooks slash IOT

00:25:00,370 --> 00:25:04,180
things will just happily send HTTP posts

00:25:03,490 --> 00:25:05,920
to your system

00:25:04,180 --> 00:25:08,490
most systems will just happily receive

00:25:05,920 --> 00:25:10,870
them and please be careful out there

00:25:08,490 --> 00:25:12,790
just because it's shiny new Internet of

00:25:10,870 --> 00:25:15,790
Things doesn't mean that we can unlearn

00:25:12,790 --> 00:25:19,840
the lessons of working with HTTP over

00:25:15,790 --> 00:25:21,670
all of the years okay so one more thing

00:25:19,840 --> 00:25:24,970
I want to mention here when I do this

00:25:21,670 --> 00:25:26,650
and I am testing locally I use a tool

00:25:24,970 --> 00:25:27,730
called an grok this is really nothing to

00:25:26,650 --> 00:25:30,040
do with the talk but I just wanted to

00:25:27,730 --> 00:25:33,520
tell you about this cool thing so an

00:25:30,040 --> 00:25:35,200
grok is a tool that you run locally you

00:25:33,520 --> 00:25:38,380
just run the binary I often run it like

00:25:35,200 --> 00:25:41,320
inside my virtual machine where all of

00:25:38,380 --> 00:25:43,630
the my dev platform is run n grok gives

00:25:41,320 --> 00:25:45,940
you a URL and then anyone in the world

00:25:43,630 --> 00:25:48,520
can hit that URL and therefore tunnel

00:25:45,940 --> 00:25:50,890
into hitting your dev platform endpoint

00:25:48,520 --> 00:25:52,750
very useful for testing in humming web

00:25:50,890 --> 00:25:54,550
hooks because you don't need to push

00:25:52,750 --> 00:25:56,710
your code to a public place where a URL

00:25:54,550 --> 00:26:01,150
can reach it allows you to test things

00:25:56,710 --> 00:26:03,400
coming in to your platform mmm cool so

00:26:01,150 --> 00:26:05,920
that was a little shoutout for in rock

00:26:03,400 --> 00:26:07,870
it has an amazing dashboard so you just

00:26:05,920 --> 00:26:10,120
need to generate the correct web hook

00:26:07,870 --> 00:26:11,800
once and then you can press the replay

00:26:10,120 --> 00:26:13,390
button in the dashboard while you figure

00:26:11,800 --> 00:26:17,370
out what your code should have done when

00:26:13,390 --> 00:26:20,350
it received that web hook very useful I

00:26:17,370 --> 00:26:22,060
was a tangent okay so obviously a

00:26:20,350 --> 00:26:25,960
planned tangent I've got a slide about

00:26:22,060 --> 00:26:28,600
it one of my favorite tools all right so

00:26:25,960 --> 00:26:30,550
the PHP producer it's called a producer

00:26:28,600 --> 00:26:34,420
because it's going to put the messages

00:26:30,550 --> 00:26:36,610
onto the queue we're going to receive

00:26:34,420 --> 00:26:40,990
the web hooks from github and write to

00:26:36,610 --> 00:26:43,060
the queue I have the line one vendor

00:26:40,990 --> 00:26:46,750
auto load because I have the AMQP Lib

00:26:43,060 --> 00:26:49,270
included on line two I am reading the

00:26:46,750 --> 00:26:52,420
incoming data it's not a perform post

00:26:49,270 --> 00:26:53,320
it's JSON so you're gonna read this PHP

00:26:52,420 --> 00:26:56,170
colon slash slash

00:26:53,320 --> 00:26:58,690
input string that's the body of the

00:26:56,170 --> 00:26:59,980
request that arrived to PHP you need to

00:26:58,690 --> 00:27:03,280
do the same thing when you're working

00:26:59,980 --> 00:27:05,230
with like put data anything where you

00:27:03,280 --> 00:27:07,870
need to read the body and it's not a

00:27:05,230 --> 00:27:09,160
straightforward post request with form

00:27:07,870 --> 00:27:11,950
formatted data

00:27:09,160 --> 00:27:13,300
I am json decoding it i promise if you

00:27:11,950 --> 00:27:14,920
read the github version there's like

00:27:13,300 --> 00:27:17,050
actual checking that we got some data

00:27:14,920 --> 00:27:20,130
and it decoded correctly but i took it

00:27:17,050 --> 00:27:24,220
out to fit it on the slide and mmm

00:27:20,130 --> 00:27:26,260
connector rabbitmq and this is a pretty

00:27:24,220 --> 00:27:30,160
straightforward AMQP stream connection

00:27:26,260 --> 00:27:32,920
rabbit the library for rabbit has very

00:27:30,160 --> 00:27:34,810
good support so if you need to also use

00:27:32,920 --> 00:27:37,030
ssl and certificates and those kinds of

00:27:34,810 --> 00:27:38,560
things we have support for all that it's

00:27:37,030 --> 00:27:42,550
not brilliantly well documented but it

00:27:38,560 --> 00:27:44,560
is there and this is all running on a vm

00:27:42,550 --> 00:27:46,240
so it's just localhost rabbits default

00:27:44,560 --> 00:27:48,460
port which is five six seven two and

00:27:46,240 --> 00:27:52,750
it's default credentials guests and

00:27:48,460 --> 00:27:55,180
guests I keep all of my demo apps on

00:27:52,750 --> 00:27:56,470
local VMS using default credentials in

00:27:55,180 --> 00:28:01,420
the hope that that will help me to work

00:27:56,470 --> 00:28:03,730
a demo under pressure at some time on

00:28:01,420 --> 00:28:06,760
line seven we're asking the rabbit

00:28:03,730 --> 00:28:09,880
clients have give us a channel this is

00:28:06,760 --> 00:28:14,410
both brilliant and really quite boring

00:28:09,880 --> 00:28:15,250
and so for each machine that connects to

00:28:14,410 --> 00:28:17,650
a rabbit

00:28:15,250 --> 00:28:20,110
server it will make one single

00:28:17,650 --> 00:28:22,810
connection and keep it open each

00:28:20,110 --> 00:28:24,490
individual process that needs to connect

00:28:22,810 --> 00:28:26,440
to that rabbit we'll just use this

00:28:24,490 --> 00:28:28,120
shared connection but we'll we'll use a

00:28:26,440 --> 00:28:30,160
little slice of it so we get this

00:28:28,120 --> 00:28:31,690
channel and that's giving us a little

00:28:30,160 --> 00:28:33,669
bit of the TCP connection

00:28:31,690 --> 00:28:36,129
isolated from the other communication

00:28:33,669 --> 00:28:39,309
going over the same link told you is

00:28:36,129 --> 00:28:41,529
boring okay then we declare the queue

00:28:39,309 --> 00:28:45,429
now this is just in case the queue

00:28:41,529 --> 00:28:49,090
doesn't exist we declare it we declare

00:28:45,429 --> 00:28:51,460
it with a name a bunch of extra

00:28:49,090 --> 00:28:53,379
arguments so the first one is passive

00:28:51,460 --> 00:28:54,940
something you can use to check if the

00:28:53,379 --> 00:28:56,950
queue exists or not which can sometimes

00:28:54,940 --> 00:28:59,970
be useful and the second one is

00:28:56,950 --> 00:29:02,950
durability I think we have some

00:28:59,970 --> 00:29:05,110
exclusivity and some Nowak here mmm

00:29:02,950 --> 00:29:09,250
you would need to look that up so we

00:29:05,110 --> 00:29:11,500
declare our queue and with a name then

00:29:09,250 --> 00:29:13,480
we create the message that I'm literally

00:29:11,500 --> 00:29:16,269
putting the data I received into the

00:29:13,480 --> 00:29:18,789
message so I used dollar input here and

00:29:16,269 --> 00:29:21,940
I set this delivery mode - that's the

00:29:18,789 --> 00:29:23,860
durability switch don't ask me why it's

00:29:21,940 --> 00:29:25,600
called that it just is this is how you

00:29:23,860 --> 00:29:27,220
make your message durable I thought you

00:29:25,600 --> 00:29:29,769
might find it useful so I've included it

00:29:27,220 --> 00:29:31,720
in my example in case you copy it and

00:29:29,769 --> 00:29:34,419
then we publish and we just publish our

00:29:31,720 --> 00:29:36,159
message this is the default exchange

00:29:34,419 --> 00:29:39,940
that I mentioned earlier so it has a

00:29:36,159 --> 00:29:42,129
blank string name and then the this is

00:29:39,940 --> 00:29:44,169
the routing information but for the

00:29:42,129 --> 00:29:45,970
default exchange which is a direct

00:29:44,169 --> 00:29:47,980
exchange this will just be the cue name

00:29:45,970 --> 00:29:51,789
we just declared the cue so we didn't

00:29:47,980 --> 00:29:54,000
need to declare any bindings there all

00:29:51,789 --> 00:29:59,879
right there are messages on the queue

00:29:54,000 --> 00:29:59,879
let's process those yeah

00:30:03,890 --> 00:30:07,830
why do i coat the Jason and then use the

00:30:06,480 --> 00:30:10,530
input in the message my guess is that I

00:30:07,830 --> 00:30:12,240
was debugging this or that if you look

00:30:10,530 --> 00:30:14,070
in the github example it's a little bit

00:30:12,240 --> 00:30:15,570
more advanced than this it's my guess I

00:30:14,070 --> 00:30:17,100
don't know what this is doing here

00:30:15,570 --> 00:30:20,070
you're really wide awake now I'm quite

00:30:17,100 --> 00:30:21,419
scared okay I mean not all this wide

00:30:20,070 --> 00:30:26,190
awake oh I'm going to be like oh yeah

00:30:21,419 --> 00:30:28,530
mmm alright so this example does not fit

00:30:26,190 --> 00:30:29,790
on one slide so I've put the boring

00:30:28,530 --> 00:30:31,710
stuff on this slide on the interesting

00:30:29,790 --> 00:30:33,390
stuff on the next slide we're going to

00:30:31,710 --> 00:30:35,880
connect to rabbitmq get a channel

00:30:33,390 --> 00:30:38,370
declare the cue good now the interesting

00:30:35,880 --> 00:30:41,880
stuff now we're consuming things from

00:30:38,370 --> 00:30:44,309
the cue this time so cuttingly we need

00:30:41,880 --> 00:30:46,590
to start kind of in the middle and we're

00:30:44,309 --> 00:30:48,900
going to do we got the channel we're

00:30:46,590 --> 00:30:52,650
going to do basic consume give the cue

00:30:48,900 --> 00:30:56,460
name give the exchange name and then

00:30:52,650 --> 00:30:58,470
this is the callback so we're doing a

00:30:56,460 --> 00:31:01,140
basic consume and when we consume we do

00:30:58,470 --> 00:31:04,290
this and then this line just gives me a

00:31:01,140 --> 00:31:06,360
bit of blocking code so that will we're

00:31:04,290 --> 00:31:09,890
waiting for messages to arrive where

00:31:06,360 --> 00:31:14,429
messages arrive the callback gets called

00:31:09,890 --> 00:31:18,090
within my callback now we're on line one

00:31:14,429 --> 00:31:20,850
within my callback we pull the data from

00:31:18,090 --> 00:31:23,040
the message do whatever it is we're

00:31:20,850 --> 00:31:25,910
going to do and then we act the message

00:31:23,040 --> 00:31:30,419
we acknowledge the message we say yes I

00:31:25,910 --> 00:31:33,750
successfully processed this message so

00:31:30,419 --> 00:31:35,549
we ask the message for its delivery

00:31:33,750 --> 00:31:39,240
information this is like the message ID

00:31:35,549 --> 00:31:41,970
and then we act that saying I have

00:31:39,240 --> 00:31:44,010
successfully processed this message so

00:31:41,970 --> 00:31:46,110
that's just a really simple example and

00:31:44,010 --> 00:31:48,540
all I'm trying to show you here is it's

00:31:46,110 --> 00:31:50,250
not that hard from PHP you very easily

00:31:48,540 --> 00:31:52,890
would add this into an existing

00:31:50,250 --> 00:31:54,450
application a lot of the frameworks have

00:31:52,890 --> 00:31:58,530
wrapper libraries but you don't really

00:31:54,450 --> 00:32:00,059
need them you the individual library is

00:31:58,530 --> 00:32:02,000
fairly straightforward you're just going

00:32:00,059 --> 00:32:05,429
to put the connection details in your

00:32:02,000 --> 00:32:11,549
wherever you keep your config and then

00:32:05,429 --> 00:32:14,280
access it from your code okay slightly

00:32:11,549 --> 00:32:15,870
more advanced or slightly slightly more

00:32:14,280 --> 00:32:17,280
advanced example

00:32:15,870 --> 00:32:22,080
and this is something where I want to

00:32:17,280 --> 00:32:25,140
just show you around it's a sample

00:32:22,080 --> 00:32:28,620
application built from a real support

00:32:25,140 --> 00:32:30,570
ticket idea kind of thing again the

00:32:28,620 --> 00:32:32,610
codes available on github so please feel

00:32:30,570 --> 00:32:34,200
free to go and dig around don't be too

00:32:32,610 --> 00:32:36,150
amused by the node.js also hanging

00:32:34,200 --> 00:32:39,150
around in this PHP example huh so it

00:32:36,150 --> 00:32:41,250
goes it's a simple guestbook application

00:32:39,150 --> 00:32:41,700
now here's the hard part if you are not

00:32:41,250 --> 00:32:44,100
old enough

00:32:41,700 --> 00:32:46,590
in technical years and then you will

00:32:44,100 --> 00:32:49,980
remember that time when we had guest

00:32:46,590 --> 00:32:53,880
books on our websites so just in case

00:32:49,980 --> 00:32:55,530
this is you there's a couple of horrible

00:32:53,880 --> 00:32:57,900
cultural references that require you to

00:32:55,530 --> 00:33:01,850
be quite old in technical years some of

00:32:57,900 --> 00:33:03,809
you I think qualify just in case a

00:33:01,850 --> 00:33:05,490
simple guestbook application

00:33:03,809 --> 00:33:07,860
it's literally we didn't have

00:33:05,490 --> 00:33:10,350
registration or really dynamic forms at

00:33:07,860 --> 00:33:11,670
all so you go to a nice hotel or holiday

00:33:10,350 --> 00:33:12,929
cottage you will write down your name

00:33:11,670 --> 00:33:15,600
where you're from and what you liked

00:33:12,929 --> 00:33:17,580
about the place we had that on our

00:33:15,600 --> 00:33:20,570
websites with no authentication or

00:33:17,580 --> 00:33:23,040
validation at all so this application is

00:33:20,570 --> 00:33:24,450
literally you write your name and then

00:33:23,040 --> 00:33:29,670
you write a comment and that's it

00:33:24,450 --> 00:33:32,190
right so everybody's with me inside the

00:33:29,670 --> 00:33:35,070
code the process looks something like

00:33:32,190 --> 00:33:37,380
this first of all we validate the post

00:33:35,070 --> 00:33:39,240
requests so somebody filled in the form

00:33:37,380 --> 00:33:40,620
for the guestbook sends as a post

00:33:39,240 --> 00:33:43,770
request we check that it looks vaguely

00:33:40,620 --> 00:33:47,220
sensible and we save the data to the

00:33:43,770 --> 00:33:49,320
database and this old-school guestbook

00:33:47,220 --> 00:33:51,360
application that's all it did and it

00:33:49,320 --> 00:33:54,929
returned information to the user

00:33:51,360 --> 00:33:58,740
I am upgrading my guestbook application

00:33:54,929 --> 00:34:00,300
to offer web hook functionality so I can

00:33:58,740 --> 00:34:01,679
receive real not've real-time

00:34:00,300 --> 00:34:04,860
notifications or nearly real-time

00:34:01,679 --> 00:34:08,760
notifications of new comments on my web

00:34:04,860 --> 00:34:10,620
blog guestbook and and so to do that I

00:34:08,760 --> 00:34:12,990
need to do something after I've saved

00:34:10,620 --> 00:34:16,020
the data to the database I need to do

00:34:12,990 --> 00:34:19,110
something to notify everybody that was

00:34:16,020 --> 00:34:20,970
interested in receiving a web hook so

00:34:19,110 --> 00:34:26,070
one option for this sort of turquoise

00:34:20,970 --> 00:34:29,190
green colored box here is to get a list

00:34:26,070 --> 00:34:29,820
of who needs to be notified and for each

00:34:29,190 --> 00:34:32,640
of the things

00:34:29,820 --> 00:34:34,770
in a list notify and wait for a response

00:34:32,640 --> 00:34:36,770
and notify the next one and wait for a

00:34:34,770 --> 00:34:38,820
response from that one which you know

00:34:36,770 --> 00:34:41,160
probably would work if you only had

00:34:38,820 --> 00:34:44,280
three subscribers probably won't work if

00:34:41,160 --> 00:34:46,710
you have like 10,000 so and the user

00:34:44,280 --> 00:34:48,900
definitely does not want to wait for PHP

00:34:46,710 --> 00:34:51,750
to make 10,000 individual webhook

00:34:48,900 --> 00:34:54,630
requests and wait for the responses in

00:34:51,750 --> 00:34:56,850
real time definitely not so let me

00:34:54,630 --> 00:35:00,510
present an alternative approach which

00:34:56,850 --> 00:35:03,120
uses cues so on the Left we have the

00:35:00,510 --> 00:35:06,270
website that's our existing PHP code and

00:35:03,120 --> 00:35:07,800
all that does is work out is take the

00:35:06,270 --> 00:35:09,810
data of the new comment

00:35:07,800 --> 00:35:11,250
so that's who made the comment what the

00:35:09,810 --> 00:35:14,310
comment says probably some timestamp

00:35:11,250 --> 00:35:17,640
information and a list of who needs to

00:35:14,310 --> 00:35:19,670
be notified get that information throw

00:35:17,640 --> 00:35:23,550
it on the queue in a single message

00:35:19,670 --> 00:35:26,430
returns the user so the website has has

00:35:23,550 --> 00:35:29,040
saved the data to the database ordered

00:35:26,430 --> 00:35:32,390
some web hooks delegated that work and

00:35:29,040 --> 00:35:34,830
then the users experience continues

00:35:32,390 --> 00:35:37,800
meanwhile back at the ranch I mean on

00:35:34,830 --> 00:35:41,610
the queue we can work through processing

00:35:37,800 --> 00:35:45,270
these so I have two queues one is the

00:35:41,610 --> 00:35:47,400
message data so something happened the

00:35:45,270 --> 00:35:49,380
form was filled in we have an event it's

00:35:47,400 --> 00:35:53,460
got some data and we have a worker that

00:35:49,380 --> 00:35:57,410
consumes this and it transforms the list

00:35:53,460 --> 00:36:00,570
of web hooks and the data into one

00:35:57,410 --> 00:36:02,940
message on a different Q so this worker

00:36:00,570 --> 00:36:05,550
is also creating messages one message on

00:36:02,940 --> 00:36:10,170
a different queue for every web hook we

00:36:05,550 --> 00:36:13,110
need to send this makes a series of

00:36:10,170 --> 00:36:15,990
independent units of work this is the

00:36:13,110 --> 00:36:17,550
key to distributed systems you must be

00:36:15,990 --> 00:36:20,700
able to break down the work that needs

00:36:17,550 --> 00:36:22,140
doing into independent units that can be

00:36:20,700 --> 00:36:24,120
scaled up horizontally

00:36:22,140 --> 00:36:25,590
you can't break the work down like this

00:36:24,120 --> 00:36:29,220
you can't build a truly scalable

00:36:25,590 --> 00:36:31,020
distributed system if I need to send ten

00:36:29,220 --> 00:36:32,430
thousand or ten million web hooks what

00:36:31,020 --> 00:36:36,540
why ten million people would be

00:36:32,430 --> 00:36:38,400
interested in my web blog guestbook is

00:36:36,540 --> 00:36:40,710
something we can talk about later but

00:36:38,400 --> 00:36:42,840
imagine that I had to send that many web

00:36:40,710 --> 00:36:43,260
hooks what you don't want to do that a

00:36:42,840 --> 00:36:44,609
loop

00:36:43,260 --> 00:36:46,560
if it goes wrong in the middle we're

00:36:44,609 --> 00:36:49,369
gonna have no idea so we're gonna break

00:36:46,560 --> 00:36:52,140
this down into individual units of work

00:36:49,369 --> 00:36:53,640
so these are on the second queue and

00:36:52,140 --> 00:36:55,440
then you're gonna have another worker

00:36:53,640 --> 00:36:58,160
that's gonna do sending the webhook

00:36:55,440 --> 00:37:00,300
waiting for the response and perhaps

00:36:58,160 --> 00:37:02,430
giving some feedback to the original

00:37:00,300 --> 00:37:08,100
system about the webhooks being sent or

00:37:02,430 --> 00:37:11,430
not so let's try and tie ourselves back

00:37:08,100 --> 00:37:13,859
to RabbitMQ and think about if we were

00:37:11,430 --> 00:37:18,650
trying to achieve this sort of thing how

00:37:13,859 --> 00:37:23,160
we would set up rabbitmq to receive that

00:37:18,650 --> 00:37:27,500
so I have an exchange and I have three

00:37:23,160 --> 00:37:30,690
cues here the first one events v1 is

00:37:27,500 --> 00:37:32,400
where the comment and large list of

00:37:30,690 --> 00:37:34,590
webhooks will arrive in the first case

00:37:32,400 --> 00:37:36,900
or every comment that's filled in on the

00:37:34,590 --> 00:37:39,990
guestbook will get one message on the

00:37:36,900 --> 00:37:41,609
events queue there's a worker on the

00:37:39,990 --> 00:37:44,760
events queue is going to create one

00:37:41,609 --> 00:37:47,910
message for each webhook and put the

00:37:44,760 --> 00:37:50,580
message data in that we need to send so

00:37:47,910 --> 00:37:53,490
all of those many messages assuming that

00:37:50,580 --> 00:37:56,430
I'm have a wildly popular guestbook web

00:37:53,490 --> 00:37:58,380
nevermind and all those messages will

00:37:56,430 --> 00:38:00,540
end up here on the notifications queue

00:37:58,380 --> 00:38:03,060
we'll have a second worker that

00:38:00,540 --> 00:38:03,750
processes that notifications queue sends

00:38:03,060 --> 00:38:07,640
the webhooks

00:38:03,750 --> 00:38:12,390
and waits to see if they work or not

00:38:07,640 --> 00:38:18,750
I've included some version information

00:38:12,390 --> 00:38:20,730
in these you don't need this but I once

00:38:18,750 --> 00:38:24,450
rescued myself from a really large

00:38:20,730 --> 00:38:25,710
problem using an approach like this so I

00:38:24,450 --> 00:38:27,869
just thought I would put it leave it

00:38:25,710 --> 00:38:29,820
like this this is how I normally name my

00:38:27,869 --> 00:38:31,380
cues as a result of having screwed up

00:38:29,820 --> 00:38:33,390
two or three different ways actually in

00:38:31,380 --> 00:38:35,070
the past so this is just a little bit of

00:38:33,390 --> 00:38:36,840
wisdom and what I'm trying to give you

00:38:35,070 --> 00:38:39,330
here is the idea that if you need to

00:38:36,840 --> 00:38:41,160
make a really breaking change to the

00:38:39,330 --> 00:38:44,160
data that's on the queues and write new

00:38:41,160 --> 00:38:46,650
workers you just create a new queue with

00:38:44,160 --> 00:38:48,750
a new version number send a new message

00:38:46,650 --> 00:38:51,090
format with that routing key to get into

00:38:48,750 --> 00:38:54,000
that new queue bright new workers you

00:38:51,090 --> 00:38:56,500
can deploy that immediately meanwhile

00:38:54,000 --> 00:39:00,010
the v1 queues will just work down

00:38:56,500 --> 00:39:04,210
- empty it's very very difficult to step

00:39:00,010 --> 00:39:05,800
change deploy producers and consumers at

00:39:04,210 --> 00:39:07,990
the same time and your cues will

00:39:05,800 --> 00:39:10,110
probably have things in steering systems

00:39:07,990 --> 00:39:12,310
that like turn it off have some downtime

00:39:10,110 --> 00:39:14,320
throw away the data in the queues I

00:39:12,310 --> 00:39:16,600
think we can do better than that

00:39:14,320 --> 00:39:19,840
so this is one one way that you might

00:39:16,600 --> 00:39:24,100
find useful so it's just I didn't take

00:39:19,840 --> 00:39:28,360
it out in case it was useful the dots in

00:39:24,100 --> 00:39:29,740
the routing Keys are just a convention

00:39:28,360 --> 00:39:34,240
but they're a widely recognized

00:39:29,740 --> 00:39:37,680
convention so you'll have kind of major

00:39:34,240 --> 00:39:40,510
topic dot minor topic in the routing

00:39:37,680 --> 00:39:44,260
Keys what I've done here is they're all

00:39:40,510 --> 00:39:48,430
hooks dot something and the third cue is

00:39:44,260 --> 00:39:50,710
the log skew and hooks dot anything that

00:39:48,430 --> 00:39:54,520
hash or I think the Americans would say

00:39:50,710 --> 00:39:58,060
pound symbol is a wild-card that can

00:39:54,520 --> 00:40:00,100
include multiple segments and so

00:39:58,060 --> 00:40:01,900
everything that comes into this exchange

00:40:00,100 --> 00:40:04,000
with the routing key of hooks not

00:40:01,900 --> 00:40:06,250
anything I'm also writing it to my logs

00:40:04,000 --> 00:40:08,770
so I can just log that I did receive it

00:40:06,250 --> 00:40:10,420
so if we have something goes wrong I can

00:40:08,770 --> 00:40:13,720
see did the message not arrive on the

00:40:10,420 --> 00:40:15,940
exchange or did we not process it

00:40:13,720 --> 00:40:18,040
correctly so every message that comes in

00:40:15,940 --> 00:40:20,440
will go to whichever queue it's for and

00:40:18,040 --> 00:40:21,700
the message will be copied also to the

00:40:20,440 --> 00:40:24,790
logs queue and they'll be processed

00:40:21,700 --> 00:40:27,640
independently so this is a topic

00:40:24,790 --> 00:40:29,830
exchange this isn't an unusual set up I

00:40:27,640 --> 00:40:32,320
think it's quite a nice it's the most

00:40:29,830 --> 00:40:38,470
common use case I see of messages going

00:40:32,320 --> 00:40:40,380
to multiple multiple endpoints let's

00:40:38,470 --> 00:40:43,710
talk a little bit about what happens

00:40:40,380 --> 00:40:49,150
after the messages are on the queue

00:40:43,710 --> 00:40:51,250
because rabbitmq is is to talk about it

00:40:49,150 --> 00:40:53,560
is about configuring it writing to it

00:40:51,250 --> 00:40:54,910
setting it up but there's a lot if

00:40:53,560 --> 00:40:56,590
you're going to work with queues in your

00:40:54,910 --> 00:40:59,790
applications there are things that I

00:40:56,590 --> 00:41:03,730
want you to know and workers are

00:40:59,790 --> 00:41:07,660
disposable you can throw them away they

00:41:03,730 --> 00:41:09,930
have to work kind of on their own in the

00:41:07,660 --> 00:41:11,610
dark underground

00:41:09,930 --> 00:41:12,750
they're not very user facing they're

00:41:11,610 --> 00:41:16,590
just a bunch of scripts running

00:41:12,750 --> 00:41:19,440
somewhere so if something goes wrong and

00:41:16,590 --> 00:41:21,390
you can't figure it out you're going to

00:41:19,440 --> 00:41:23,310
just exit ideally you're going to

00:41:21,390 --> 00:41:25,590
actually detect the error and let the

00:41:23,310 --> 00:41:27,090
cue know there's a problem I have a

00:41:25,590 --> 00:41:30,390
slide on retries in a minute

00:41:27,090 --> 00:41:32,970
but try and don't try to limp along you

00:41:30,390 --> 00:41:35,100
need to be really really defensive did I

00:41:32,970 --> 00:41:36,900
receive data did I understand the data

00:41:35,100 --> 00:41:39,930
is the data something I could process is

00:41:36,900 --> 00:41:44,460
this any kind of valid okay I've kind of

00:41:39,930 --> 00:41:46,290
touched on this with the IOT remarks we

00:41:44,460 --> 00:41:48,960
need to be a little bit more paranoid

00:41:46,290 --> 00:41:50,940
than we often are about the data that we

00:41:48,960 --> 00:41:53,460
receive for this this is basically user

00:41:50,940 --> 00:41:55,320
input you don't we comes off a queue you

00:41:53,460 --> 00:41:57,240
don't know where it's been so be

00:41:55,320 --> 00:41:59,760
paranoid when you pull data from a queue

00:41:57,240 --> 00:42:01,560
most of the time it'll just be some sort

00:41:59,760 --> 00:42:04,860
of zombie sensor sending you an empty

00:42:01,560 --> 00:42:08,760
packet right it's not malicious but it

00:42:04,860 --> 00:42:10,650
could be so be careful like I say most

00:42:08,760 --> 00:42:13,920
the time all of the problems are an

00:42:10,650 --> 00:42:15,630
empty packet all of them be careful

00:42:13,920 --> 00:42:18,030
about long-running process hazards

00:42:15,630 --> 00:42:19,830
somebody will tell you that PHP is not

00:42:18,030 --> 00:42:23,820
the right language to write a worker

00:42:19,830 --> 00:42:28,410
script in and I disagree respectfully

00:42:23,820 --> 00:42:30,360
but loudly and there's no reason you

00:42:28,410 --> 00:42:34,830
shouldn't write workers that run for

00:42:30,360 --> 00:42:37,110
days on end in PHP but there are some

00:42:34,830 --> 00:42:39,240
things to look out for because when we

00:42:37,110 --> 00:42:42,780
write PHP for the web we get a fresh

00:42:39,240 --> 00:42:46,440
isolated request when a fresh isolated

00:42:42,780 --> 00:42:47,820
kind of runtime when the request comes

00:42:46,440 --> 00:42:51,620
in and then when it's finished it kind

00:42:47,820 --> 00:42:53,910
of tidies itself up and it'll never and

00:42:51,620 --> 00:42:55,170
contaminates any other requests it's

00:42:53,910 --> 00:42:57,870
just the way they were accustomed to

00:42:55,170 --> 00:43:00,120
work so there are some some practices

00:42:57,870 --> 00:43:02,640
which are completely acceptable in web

00:43:00,120 --> 00:43:04,770
based PHP that you are not going to do

00:43:02,640 --> 00:43:06,810
with a long-running process in

00:43:04,770 --> 00:43:10,610
particular we are guilty of completely

00:43:06,810 --> 00:43:13,320
failing to close resource handles files

00:43:10,610 --> 00:43:17,480
database connections you need to close

00:43:13,320 --> 00:43:21,510
those you also need to properly

00:43:17,480 --> 00:43:22,710
initialize everything because we're

00:43:21,510 --> 00:43:26,880
going to be running in a loops

00:43:22,710 --> 00:43:30,300
you leave a data in a variable it could

00:43:26,880 --> 00:43:31,640
easily sneak into the next loop those

00:43:30,300 --> 00:43:34,470
are things you need to be careful about

00:43:31,640 --> 00:43:36,960
be really careful appending to an array

00:43:34,470 --> 00:43:38,130
or something because that will just grow

00:43:36,960 --> 00:43:41,339
and grow and grow eventually you'll run

00:43:38,130 --> 00:43:43,230
out of memory so there are some things

00:43:41,339 --> 00:43:45,150
that you want to do differently for a

00:43:43,230 --> 00:43:47,250
long-running worker script it's going to

00:43:45,150 --> 00:43:51,150
run in a loop and just keep on getting

00:43:47,250 --> 00:43:53,550
jobs and processing them another thing

00:43:51,150 --> 00:43:55,830
to be careful of is that typically we

00:43:53,550 --> 00:43:58,980
set a rabbit and queue to process to

00:43:55,830 --> 00:44:01,050
have what we call at least once delivery

00:43:58,980 --> 00:44:04,109
the message goes on the queue

00:44:01,050 --> 00:44:06,780
a worker picks it up if that worker

00:44:04,109 --> 00:44:08,190
exits without sending us the ACK without

00:44:06,780 --> 00:44:10,200
acknowledging it was successfully

00:44:08,190 --> 00:44:13,290
processed we give the job to someone

00:44:10,200 --> 00:44:15,420
else if it was successfully processed

00:44:13,290 --> 00:44:17,520
and we just lost AK it's gonna get

00:44:15,420 --> 00:44:21,300
processed twice so your application

00:44:17,520 --> 00:44:24,330
needs to be able to handle duplicates

00:44:21,300 --> 00:44:28,230
because that will happen rarely but it

00:44:24,330 --> 00:44:29,400
will happen so yes things might get

00:44:28,230 --> 00:44:31,290
processed more than once and by

00:44:29,400 --> 00:44:34,320
definition things will get processed out

00:44:31,290 --> 00:44:36,990
of order because we're gonna have nine

00:44:34,320 --> 00:44:39,599
twenty four workers consuming your queue

00:44:36,990 --> 00:44:41,430
so if you put 50 jobs in they're all

00:44:39,599 --> 00:44:42,900
gone the first half are probably going

00:44:41,430 --> 00:44:45,150
to complete before the second half but

00:44:42,900 --> 00:44:47,880
that's all I can tell you if it matters

00:44:45,150 --> 00:44:50,250
what order your messages are processed

00:44:47,880 --> 00:44:52,920
in then they are not independent and you

00:44:50,250 --> 00:44:54,300
have not built a scalable system if you

00:44:52,920 --> 00:44:57,119
need to process things in batches

00:44:54,300 --> 00:44:58,250
together then keep them together process

00:44:57,119 --> 00:45:01,170
them in batches they're not independent

00:44:58,250 --> 00:45:02,550
if it can be independent it doesn't

00:45:01,170 --> 00:45:05,160
matter what order they go in so just

00:45:02,550 --> 00:45:09,630
look out for that so we create workers

00:45:05,160 --> 00:45:11,510
and we need to skill them up send them

00:45:09,630 --> 00:45:14,550
out and they need to know what to do

00:45:11,510 --> 00:45:17,700
independently in the face of any

00:45:14,550 --> 00:45:21,060
adversity you can think of them like

00:45:17,700 --> 00:45:24,359
lemmings here's another one of those

00:45:21,060 --> 00:45:26,130
cultural age specific critter this is a

00:45:24,359 --> 00:45:28,560
computer game if you don't remember

00:45:26,130 --> 00:45:30,390
right these little critters are called

00:45:28,560 --> 00:45:34,140
lemmings and they you just they all

00:45:30,390 --> 00:45:35,730
follow one another and what you do is

00:45:34,140 --> 00:45:36,510
you just let them all out they all

00:45:35,730 --> 00:45:38,010
follow one another

00:45:36,510 --> 00:45:39,240
they come to an edge of a cliff they

00:45:38,010 --> 00:45:40,470
just all follow each other off the edge

00:45:39,240 --> 00:45:43,160
of the cliff which is what real life

00:45:40,470 --> 00:45:46,710
little cuddly lemmings are famous for

00:45:43,160 --> 00:45:48,900
but you can teach them skills you can

00:45:46,710 --> 00:45:52,170
teach them to build sets of steps like

00:45:48,900 --> 00:45:54,690
this or to tunnel through barriers like

00:45:52,170 --> 00:45:57,660
this so you skill up your little guys

00:45:54,690 --> 00:45:59,910
and you send them out into the dark to

00:45:57,660 --> 00:46:02,460
make their own way independently and

00:45:59,910 --> 00:46:05,010
just like writing workers you give them

00:46:02,460 --> 00:46:06,990
some skills teach them what to do in the

00:46:05,010 --> 00:46:09,900
moment of adversity make sure they have

00:46:06,990 --> 00:46:11,940
great logging give it show them what to

00:46:09,900 --> 00:46:13,770
do and then send them out and then they

00:46:11,940 --> 00:46:15,420
find their own way and that's the

00:46:13,770 --> 00:46:19,680
closest parallel I can think of for

00:46:15,420 --> 00:46:21,750
writing really excellent workers awesome

00:46:19,680 --> 00:46:24,060
logging needs to be aggregated you

00:46:21,750 --> 00:46:25,920
should not be logging into servers to

00:46:24,060 --> 00:46:29,250
check logs from multiple different

00:46:25,920 --> 00:46:31,080
workers so write the logs but ship them

00:46:29,250 --> 00:46:33,450
somewhere central where you can very

00:46:31,080 --> 00:46:36,210
easily see oh we got a lot of this error

00:46:33,450 --> 00:46:39,330
message all of a sudden and you can also

00:46:36,210 --> 00:46:42,510
see all of the worker logs in context

00:46:39,330 --> 00:46:45,390
together there are some things I

00:46:42,510 --> 00:46:47,430
particularly like to monitor queue size

00:46:45,390 --> 00:46:49,890
is a good one

00:46:47,430 --> 00:46:51,690
try not to get paged at 4 o'clock in the

00:46:49,890 --> 00:46:54,060
morning there's a million items in the

00:46:51,690 --> 00:46:55,500
queue well maybe that's normal for 4

00:46:54,060 --> 00:46:58,440
o'clock in the morning you need to know

00:46:55,500 --> 00:47:00,630
that so have an idea of how big your

00:46:58,440 --> 00:47:03,300
queue is usually is it growing very

00:47:00,630 --> 00:47:06,150
quickly is it growing a bit a bit a bit

00:47:03,300 --> 00:47:07,530
every day overtime that's a problem it's

00:47:06,150 --> 00:47:09,420
fine for it to get big and then get

00:47:07,530 --> 00:47:12,590
small but it gets big and then gets

00:47:09,420 --> 00:47:16,560
bigger ah you probably have a problem I

00:47:12,590 --> 00:47:22,140
like to have work uptime and the workers

00:47:16,560 --> 00:47:23,490
will be being looked after by up and I'm

00:47:22,140 --> 00:47:24,420
try not to say supervisor process

00:47:23,490 --> 00:47:27,270
because that's the name of the software

00:47:24,420 --> 00:47:29,820
some sort of process that will make sure

00:47:27,270 --> 00:47:33,210
we have the right number of workers

00:47:29,820 --> 00:47:35,280
running all the time supervisor day is a

00:47:33,210 --> 00:47:37,670
good one I see a lot of systemd setups

00:47:35,280 --> 00:47:40,380
now as well so you're going to say right

00:47:37,670 --> 00:47:43,590
run this script I want eight of them and

00:47:40,380 --> 00:47:46,620
if one of them dies it will restart it

00:47:43,590 --> 00:47:48,480
makes it safe to exit it also means you

00:47:46,620 --> 00:47:50,650
should be able to track the uptime of

00:47:48,480 --> 00:47:52,480
your workers

00:47:50,650 --> 00:47:54,700
and I often see workers that

00:47:52,480 --> 00:47:56,590
automatically restart themselves after a

00:47:54,700 --> 00:47:58,750
certain amount of time so maybe they

00:47:56,590 --> 00:48:01,780
process 10,000 jobs and then they

00:47:58,750 --> 00:48:04,150
restart if that restart is usually every

00:48:01,780 --> 00:48:06,550
18 hours and suddenly becomes 18 18

00:48:04,150 --> 00:48:07,150
seconds after I deploy you should worry

00:48:06,550 --> 00:48:09,910
about that

00:48:07,150 --> 00:48:12,130
but crucially you should know that you

00:48:09,910 --> 00:48:16,480
should have the insight for that if you

00:48:12,130 --> 00:48:19,270
just automate if it dies restart you can

00:48:16,480 --> 00:48:20,830
miss the subtleties of what is going on

00:48:19,270 --> 00:48:22,090
because it's so hard to inspect when

00:48:20,830 --> 00:48:27,640
you've just sent this large number of

00:48:22,090 --> 00:48:30,670
small animals out into the dark keep an

00:48:27,640 --> 00:48:33,820
eye on how long each type of message

00:48:30,670 --> 00:48:36,760
takes to be processed there's the

00:48:33,820 --> 00:48:40,600
obvious risks you do a deployment and

00:48:36,760 --> 00:48:41,950
then everything takes a bit longer you

00:48:40,600 --> 00:48:44,170
probably introduced some sort of

00:48:41,950 --> 00:48:45,760
inefficiency keep an eye on that because

00:48:44,170 --> 00:48:49,600
it's hard it's really hard to optimize

00:48:45,760 --> 00:48:51,760
this stuff maybe you didn't do a

00:48:49,600 --> 00:48:52,440
deployment and everything got a lot

00:48:51,760 --> 00:48:57,490
slower

00:48:52,440 --> 00:48:58,630
my money's on DNS timeout but a bunch of

00:48:57,490 --> 00:49:00,130
things would happen it's important that

00:48:58,630 --> 00:49:02,380
you realize because otherwise you're

00:49:00,130 --> 00:49:04,420
you'll find your queue gets bigger you

00:49:02,380 --> 00:49:06,490
need to add some more resource in the

00:49:04,420 --> 00:49:08,619
short term while you figure it out keep

00:49:06,490 --> 00:49:12,280
an eye on those if you're processing

00:49:08,619 --> 00:49:14,800
time gets mysteriously shorter when you

00:49:12,280 --> 00:49:16,930
didn't expect it to then you should

00:49:14,800 --> 00:49:19,540
really really worry that's the worst

00:49:16,930 --> 00:49:21,700
problem I've ever seen is the thing just

00:49:19,540 --> 00:49:24,730
started acting without actually

00:49:21,700 --> 00:49:27,160
processing the work that's why you

00:49:24,730 --> 00:49:29,440
should panic ship with as few

00:49:27,160 --> 00:49:32,109
dependencies as possible minimum viable

00:49:29,440 --> 00:49:34,330
dependencies try not to write a worker

00:49:32,109 --> 00:49:36,070
that uses your whole full stack

00:49:34,330 --> 00:49:39,640
framework

00:49:36,070 --> 00:49:41,470
you don't need most of it just try to be

00:49:39,640 --> 00:49:44,710
really you should be writing small

00:49:41,470 --> 00:49:49,210
focused workers just include what they

00:49:44,710 --> 00:49:51,100
need when we do process a message we can

00:49:49,210 --> 00:49:54,670
send the acknowledgement we can also

00:49:51,100 --> 00:49:57,660
send not acknowledgement we can reject

00:49:54,670 --> 00:50:01,270
instead of ACK and the reject means nope

00:49:57,660 --> 00:50:03,600
did not process this correctly you can

00:50:01,270 --> 00:50:06,010
choose whether you should

00:50:03,600 --> 00:50:07,540
riku that message in which case it goes

00:50:06,010 --> 00:50:10,540
back on the front of the queue gets

00:50:07,540 --> 00:50:14,230
processed again immediately or not be

00:50:10,540 --> 00:50:17,560
really careful Riku ajiz if you couldn't

00:50:14,230 --> 00:50:19,570
process it once maybe it's because of

00:50:17,560 --> 00:50:21,730
third party API failed and a retry will

00:50:19,570 --> 00:50:23,320
do the job maybe something went wrong

00:50:21,730 --> 00:50:26,860
with the worker and a fresh worker will

00:50:23,320 --> 00:50:31,030
help maybe this message can't be

00:50:26,860 --> 00:50:33,730
processed if you keep on Riku it we're

00:50:31,030 --> 00:50:37,540
gonna spend a lot of resource queuing

00:50:33,730 --> 00:50:39,090
and REE queuing this message you get

00:50:37,540 --> 00:50:43,530
poison message we should just try and

00:50:39,090 --> 00:50:43,530
reprocess lots of times yes question

00:50:45,090 --> 00:50:49,570
does the message know that it wasn't

00:50:47,200 --> 00:50:52,750
acknowledgements Ange they're immutable

00:50:49,570 --> 00:50:54,880
so if you want to do something like that

00:50:52,750 --> 00:50:55,750
just bear with never retry slides in

00:50:54,880 --> 00:51:00,640
about two slides

00:50:55,750 --> 00:51:04,090
yes Conan I can see it so you can reject

00:51:00,640 --> 00:51:05,500
it without the Riku if you have the

00:51:04,090 --> 00:51:07,270
dead-letter exchange setup

00:51:05,500 --> 00:51:09,220
your message will go there instead if

00:51:07,270 --> 00:51:12,070
your message is on the queue for too

00:51:09,220 --> 00:51:14,050
long it exceeds it's time to live it

00:51:12,070 --> 00:51:16,240
will go also to the dead-letter exchange

00:51:14,050 --> 00:51:17,890
and if the queue is too long and one of

00:51:16,240 --> 00:51:20,770
the messages got dropped that message

00:51:17,890 --> 00:51:23,140
also goes to the dead-letter exchange so

00:51:20,770 --> 00:51:25,000
once things end up in the queues and our

00:51:23,140 --> 00:51:27,580
dead-letter exchange we have a choice of

00:51:25,000 --> 00:51:32,770
options we can look and see which edge

00:51:27,580 --> 00:51:35,860
cases are not being caught also if the

00:51:32,770 --> 00:51:38,440
problem was third party API went down

00:51:35,860 --> 00:51:39,730
for two hours and everything ended up on

00:51:38,440 --> 00:51:42,400
the dead letter it's dead letter

00:51:39,730 --> 00:51:45,580
exchange once that third party API is

00:51:42,400 --> 00:51:47,790
back up we can write a worker that reads

00:51:45,580 --> 00:51:50,380
the messages and recreates them and

00:51:47,790 --> 00:51:52,390
reprocesses them the data is not lost

00:51:50,380 --> 00:51:55,810
because we've caught it somewhere and

00:51:52,390 --> 00:51:58,630
we're dealing with it what rabbit

00:51:55,810 --> 00:52:00,220
doesn't have is any way of retrying of

00:51:58,630 --> 00:52:01,510
having a concept of this that we've

00:52:00,220 --> 00:52:04,270
already had a problem with this message

00:52:01,510 --> 00:52:06,310
it's not very hard to implement it by

00:52:04,270 --> 00:52:08,230
yourself the most important thing you

00:52:06,310 --> 00:52:11,170
need to know is that the messages cannot

00:52:08,230 --> 00:52:13,270
be changed so we can't add retry

00:52:11,170 --> 00:52:15,360
information to our rabbit mq message

00:52:13,270 --> 00:52:16,830
what we do is the

00:52:15,360 --> 00:52:19,190
messages on the queue the worker tries

00:52:16,830 --> 00:52:22,590
to process it we can't process it okay

00:52:19,190 --> 00:52:24,540
so we make a new message identical to

00:52:22,590 --> 00:52:27,570
the old one because we can't change the

00:52:24,540 --> 00:52:31,080
old one we add this is the we've already

00:52:27,570 --> 00:52:34,590
tried this once data and we put it back

00:52:31,080 --> 00:52:36,330
on the back of the queue and we mark

00:52:34,590 --> 00:52:39,780
that first message is successfully

00:52:36,330 --> 00:52:41,040
processed you might want to write some

00:52:39,780 --> 00:52:43,650
logs somewhere to let you know that you

00:52:41,040 --> 00:52:45,510
were there with some retries a lot of

00:52:43,650 --> 00:52:47,490
the time the difference between this

00:52:45,510 --> 00:52:50,850
manual create a new message put it back

00:52:47,490 --> 00:52:52,530
on the back of the queue and the reject

00:52:50,850 --> 00:52:54,420
with Riku which puts the same message

00:52:52,530 --> 00:52:56,220
back on the front of the queue the big

00:52:54,420 --> 00:52:57,630
difference is maybe it takes half a

00:52:56,220 --> 00:52:59,520
second for all the other messages in the

00:52:57,630 --> 00:53:02,400
queue to get processed whatever that

00:52:59,520 --> 00:53:05,610
glitch was just cause you to fail will

00:53:02,400 --> 00:53:08,250
be gone in half a second so often just

00:53:05,610 --> 00:53:10,440
put it on the back of the queue things

00:53:08,250 --> 00:53:12,630
don't get stuck behind it because the

00:53:10,440 --> 00:53:15,000
rest of the queue drains down then you

00:53:12,630 --> 00:53:18,390
reprocess that's given me a lot of luck

00:53:15,000 --> 00:53:21,720
actually that just just enough back off

00:53:18,390 --> 00:53:24,570
to let things suddenly pull themselves

00:53:21,720 --> 00:53:26,970
together if you get a message which

00:53:24,570 --> 00:53:29,700
already has we re trying this message in

00:53:26,970 --> 00:53:31,560
it again create a new message copy it

00:53:29,700 --> 00:53:33,720
over increment the retry counter and

00:53:31,560 --> 00:53:35,940
don't keep on retrying so if you get to

00:53:33,720 --> 00:53:38,130
three attempts or five attempts whatever

00:53:35,940 --> 00:53:41,640
makes sense in your scenario then stop

00:53:38,130 --> 00:53:44,910
there and otherwise you can get if you

00:53:41,640 --> 00:53:47,880
just blindly Riku all the time you get

00:53:44,910 --> 00:53:50,940
poison messages which will clog up your

00:53:47,880 --> 00:53:55,350
queue you will spend a lot of resource

00:53:50,940 --> 00:53:57,030
on the worker side trying to process

00:53:55,350 --> 00:53:59,610
lots and lots of messages that can never

00:53:57,030 --> 00:54:01,940
be processed and the real work won't get

00:53:59,610 --> 00:54:04,430
done York you usually backs up horribly

00:54:01,940 --> 00:54:06,900
you can also do some back off time

00:54:04,430 --> 00:54:08,490
rabbit doesn't have that built in so

00:54:06,900 --> 00:54:10,380
you're going to build special queues

00:54:08,490 --> 00:54:12,330
that are executed at special times it's

00:54:10,380 --> 00:54:14,320
not very straightforward but you can do

00:54:12,330 --> 00:54:16,960
it

00:54:14,320 --> 00:54:19,720
I also want to mention the feedback

00:54:16,960 --> 00:54:22,990
mechanisms I think this is something

00:54:19,720 --> 00:54:24,390
that we have a lot of anxiety about when

00:54:22,990 --> 00:54:28,540
we're so accustomed to writing

00:54:24,390 --> 00:54:30,250
synchronous code the idea is that you

00:54:28,540 --> 00:54:33,370
put a job on the queue and then we're

00:54:30,250 --> 00:54:36,570
done right the work gets done and the

00:54:33,370 --> 00:54:38,800
original application shouldn't care

00:54:36,570 --> 00:54:39,970
often the original application doesn't

00:54:38,800 --> 00:54:41,800
need to care because this is the real

00:54:39,970 --> 00:54:43,570
world and we don't alright ideal alyttle

00:54:41,800 --> 00:54:46,060
ideal academic distributed systems

00:54:43,570 --> 00:54:47,860
although that would be lovely and often

00:54:46,060 --> 00:54:49,270
the original system does need some sort

00:54:47,860 --> 00:54:51,220
of feedback so like the user upload an

00:54:49,270 --> 00:54:53,380
avatar and we're going to show them cogs

00:54:51,220 --> 00:54:55,090
for a while when we have finished them

00:54:53,380 --> 00:54:57,400
nailing we do want to update what

00:54:55,090 --> 00:54:59,740
they're saying so for that what we

00:54:57,400 --> 00:55:03,790
usually do is we add an additional queue

00:54:59,740 --> 00:55:06,670
to offer some feedback to the to the

00:55:03,790 --> 00:55:09,310
original system so here's the webhooks

00:55:06,670 --> 00:55:11,530
set up again with events and

00:55:09,310 --> 00:55:14,890
notifications and that catch-all logs

00:55:11,530 --> 00:55:17,350
queue when we successfully process a

00:55:14,890 --> 00:55:21,670
webhook we can give that information

00:55:17,350 --> 00:55:23,920
back to the calling application so we

00:55:21,670 --> 00:55:27,370
have an outcomes exchange and this

00:55:23,920 --> 00:55:29,710
additional status queue so that second

00:55:27,370 --> 00:55:31,720
worker is going to write new messages to

00:55:29,710 --> 00:55:33,460
this other queue and the first

00:55:31,720 --> 00:55:36,070
application is going to consume this to

00:55:33,460 --> 00:55:38,260
get the information in so we're using it

00:55:36,070 --> 00:55:41,020
as two-way communication in the queues

00:55:38,260 --> 00:55:43,180
we make another queue that's consumed by

00:55:41,020 --> 00:55:50,650
the original application to get updates

00:55:43,180 --> 00:55:55,120
on what's happening queues in general I

00:55:50,650 --> 00:55:59,050
think are a cornerstone of today's

00:55:55,120 --> 00:56:01,750
applications I think they give us some

00:55:59,050 --> 00:56:04,150
very important tools for modern

00:56:01,750 --> 00:56:06,490
applications for building in an

00:56:04,150 --> 00:56:08,950
increasingly modular manner for

00:56:06,490 --> 00:56:15,070
communicating between multiple

00:56:08,950 --> 00:56:17,530
applications they allow us to scale they

00:56:15,070 --> 00:56:19,240
allow us to be resilient if one system

00:56:17,530 --> 00:56:21,880
is being a little bit flaky the queues

00:56:19,240 --> 00:56:23,740
kind of protect us from the burstiness

00:56:21,880 --> 00:56:26,480
and also from the failure they can

00:56:23,740 --> 00:56:30,110
buffer work that needs doing

00:56:26,480 --> 00:56:32,240
they allow us to scale our systems and

00:56:30,110 --> 00:56:33,890
scale each platform independently I

00:56:32,240 --> 00:56:36,470
you've seen out two or three different

00:56:33,890 --> 00:56:38,150
workers in that set up if one of the

00:56:36,470 --> 00:56:40,190
queues is getting too big I only need

00:56:38,150 --> 00:56:42,830
more of that worker I don't need to

00:56:40,190 --> 00:56:45,080
deploy a whole new webhead every time

00:56:42,830 --> 00:56:46,220
because we're being very targeted about

00:56:45,080 --> 00:56:51,770
the work that we do

00:56:46,220 --> 00:56:53,990
I used RabbitMQ as my example we have it

00:56:51,770 --> 00:56:56,540
on the IBM platform that's not the only

00:56:53,990 --> 00:56:58,100
reason that's not the only reason it's

00:56:56,540 --> 00:57:00,110
not really a hardship it's always been

00:56:58,100 --> 00:57:01,910
one of my favorite tools and now I have

00:57:00,110 --> 00:57:03,560
it available to play with on my cloud

00:57:01,910 --> 00:57:06,560
where someone else pays my hosting bills

00:57:03,560 --> 00:57:08,090
that's quite excellent and I also gave a

00:57:06,560 --> 00:57:10,340
little shout out at the beginning to the

00:57:08,090 --> 00:57:13,100
other cue tools I don't want you to rush

00:57:10,340 --> 00:57:16,160
back to the office tomorrow or next week

00:57:13,100 --> 00:57:18,380
and rip out what you already have if

00:57:16,160 --> 00:57:20,660
it's a different cue system most of us

00:57:18,380 --> 00:57:22,820
showed you here is in some way

00:57:20,660 --> 00:57:27,740
transferable or implementable in other

00:57:22,820 --> 00:57:29,150
systems so I have like one minute for

00:57:27,740 --> 00:57:30,740
questions two minutes for questions and

00:57:29,150 --> 00:57:33,620
I have some resources for you so there's

00:57:30,740 --> 00:57:35,420
the rabbit nq's landing page you can

00:57:33,620 --> 00:57:37,580
also try it on IBM's cloud we have a

00:57:35,420 --> 00:57:39,830
free trial so sign up when you have time

00:57:37,580 --> 00:57:41,680
to make best use of the 30 days and if

00:57:39,830 --> 00:57:44,540
you have questions I can answer those

00:57:41,680 --> 00:57:46,790
I've write quite a lot about this and I

00:57:44,540 --> 00:57:48,740
also collect all of my slide decks and

00:57:46,790 --> 00:57:51,650
articles in other places such as on my

00:57:48,740 --> 00:57:53,750
work blog onto my blog so long Jane net

00:57:51,650 --> 00:57:56,390
is a place to go if you're interested in

00:57:53,750 --> 00:57:59,360
this kind of stuff there's the code link

00:57:56,390 --> 00:58:02,150
to that guestbook web hooks apps I

00:57:59,360 --> 00:58:04,580
showed that's probably got the best of

00:58:02,150 --> 00:58:07,280
the PHP RabbitMQ examples in that you

00:58:04,580 --> 00:58:09,650
might like to look at and finally here

00:58:07,280 --> 00:58:14,260
are my contact details who has a

00:58:09,650 --> 00:58:14,260
question for me yeah

00:58:20,520 --> 00:58:32,170
yes okay this is a really good question

00:58:29,430 --> 00:58:33,970
within a rabbit MQ server you can have

00:58:32,170 --> 00:58:35,799
multiple exchanges each exchange has

00:58:33,970 --> 00:58:39,819
multiple queues what's my advice for

00:58:35,799 --> 00:58:42,880
architecting this try to you give a new

00:58:39,819 --> 00:58:44,319
exchange for each component RabbitMQ

00:58:42,880 --> 00:58:47,500
actually supports something called

00:58:44,319 --> 00:58:49,299
vhosts which I didn't get into today but

00:58:47,500 --> 00:58:51,869
put your exchange on independent vhosts

00:58:49,299 --> 00:58:54,670
if you think that you might possibly

00:58:51,869 --> 00:58:56,470
outgrow or want to move these systems in

00:58:54,670 --> 00:59:00,099
future because very easy to move vhosts

00:58:56,470 --> 00:59:05,380
between hosts so within that an exchange

00:59:00,099 --> 00:59:08,020
per kind of group of things so the

00:59:05,380 --> 00:59:10,839
two-step worker processing the web hooks

00:59:08,020 --> 00:59:12,339
I put that on a single exchange but the

00:59:10,839 --> 00:59:13,450
feedback mechanism which will be

00:59:12,339 --> 00:59:16,240
consumed by something else was on a

00:59:13,450 --> 00:59:19,630
different exchange if you are in doubt

00:59:16,240 --> 00:59:21,819
about whether you need a new cue put it

00:59:19,630 --> 00:59:24,309
in a new queue always put it in a neo

00:59:21,819 --> 00:59:26,410
queue this has saved me so many times I

00:59:24,309 --> 00:59:28,030
had one where I had more or less the

00:59:26,410 --> 00:59:30,220
same data arriving from three different

00:59:28,030 --> 00:59:33,220
suppliers actually all those queues

00:59:30,220 --> 00:59:34,960
processed by the same workers they put

00:59:33,220 --> 00:59:36,309
it in three different queues and the day

00:59:34,960 --> 00:59:37,540
that one of those suppliers sent me

00:59:36,309 --> 00:59:39,849
utter nonsense

00:59:37,540 --> 00:59:42,549
it didn't take out the other two queues

00:59:39,849 --> 00:59:44,260
so there was no real reason for using

00:59:42,549 --> 00:59:46,900
separate queues but now I'm a convert

00:59:44,260 --> 00:59:48,309
always use more queues because if

00:59:46,900 --> 00:59:50,920
there's a problem if there's anything

00:59:48,309 --> 00:59:53,920
different any reason to separate them a

00:59:50,920 --> 00:59:56,170
bug could affect just one and then it's

00:59:53,920 --> 00:59:58,260
isolated and it doesn't take out your

00:59:56,170 --> 01:00:01,359
whole system whereas if you've got

00:59:58,260 --> 01:00:02,980
messages choking the workers and all of

01:00:01,359 --> 01:00:05,980
your good messages are also in the same

01:00:02,980 --> 01:00:09,130
queue you have no choices similarly with

01:00:05,980 --> 01:00:10,720
the routing naming I quite often have a

01:00:09,130 --> 01:00:12,790
queue that catches them all with a bit

01:00:10,720 --> 01:00:15,099
of a wild card and that gives you the

01:00:12,790 --> 01:00:15,869
option to separate out later does that

01:00:15,099 --> 01:00:18,940
answer your question

01:00:15,869 --> 01:00:20,950
fantastic I can take I can't really take

01:00:18,940 --> 01:00:22,839
one more amount of time okay listen I am

01:00:20,950 --> 01:00:24,640
around all day today and tomorrow when

01:00:22,839 --> 01:00:27,010
I'm speaking about service JavaScript I

01:00:24,640 --> 01:00:29,290
hardly know anyone so I am super happy

01:00:27,010 --> 01:00:31,360
to stop and chat about technology thank

01:00:29,290 --> 01:00:36,189
joining me so early in the morning

01:00:31,360 --> 01:00:36,189
[Applause]

01:00:39,170 --> 01:00:41,230

YouTube URL: https://www.youtube.com/watch?v=JnatrDD1E3E


