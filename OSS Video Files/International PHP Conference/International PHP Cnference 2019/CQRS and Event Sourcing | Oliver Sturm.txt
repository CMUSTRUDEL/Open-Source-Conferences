Title: CQRS and Event Sourcing | Oliver Sturm
Publication date: 2020-01-23
Playlist: International PHP Cnference 2019
Description: 
	Data storage and data access are subjects of this talk. CQRS is quite a simple pattern to split responsibilities when working with data, but incredibly complicated papers have been written about it! Event Sourcing can be viewed as a natural extension of CQRS, though in reality a decision for or against it is independent and comes with its own consequences. Oliver uses practical examples in this talk to demonstrate implementation and combination of both patterns.

Speaker: Oliver Sturm (DevExpress) | https://phpconference.com/speaker/oliver-sturm/

🤗 Come, join us at the next International PHP Conference | https://phpconference.com/
👍 Like us on Facebook | https://www.facebook.com/ipc.germany/
👉 Follow us on Twitter | https://twitter.com/phpconference
Captions: 
	00:00:00,000 --> 00:00:06,870
[Music]

00:00:04,490 --> 00:00:10,679
so I'm here to talk about this very

00:00:06,870 --> 00:00:13,380
exciting set of patterns CQRS and event

00:00:10,679 --> 00:00:15,570
sourcing today are there any security

00:00:13,380 --> 00:00:17,880
event sourcing experts in the room will

00:00:15,570 --> 00:00:19,770
already know everything and are gonna

00:00:17,880 --> 00:00:21,869
criticize me every step of the way or

00:00:19,770 --> 00:00:25,199
anything I don't know good good all

00:00:21,869 --> 00:00:26,760
right so my name is Oliver storm my

00:00:25,199 --> 00:00:28,470
email address is on here we're gonna

00:00:26,760 --> 00:00:32,189
skip everything else because we don't

00:00:28,470 --> 00:00:34,050
have time my agenda today is to talk

00:00:32,189 --> 00:00:36,630
about these two patterns as you might

00:00:34,050 --> 00:00:38,730
have guessed and to explain to you why I

00:00:36,630 --> 00:00:41,010
think they're exciting when you might be

00:00:38,730 --> 00:00:45,510
able to use them and how you might

00:00:41,010 --> 00:00:48,120
possibly do this so yeah let's just get

00:00:45,510 --> 00:00:50,370
right into this the consequence of both

00:00:48,120 --> 00:00:52,949
of these patterns is this thing called

00:00:50,370 --> 00:00:54,930
eventual consistency that I also hope to

00:00:52,949 --> 00:00:56,640
be able to talk about for a few minutes

00:00:54,930 --> 00:00:59,370
perhaps since that's a pretty

00:00:56,640 --> 00:01:02,520
interesting aspect of it now

00:00:59,370 --> 00:01:04,860
looking at data access patterns I have

00:01:02,520 --> 00:01:07,430
here a little piece of code which I

00:01:04,860 --> 00:01:09,840
believe is actually from an asp.net

00:01:07,430 --> 00:01:13,350
application not that it really matters

00:01:09,840 --> 00:01:15,840
it is kind of meant to just illustrate

00:01:13,350 --> 00:01:18,299
the kind of process that you went

00:01:15,840 --> 00:01:22,049
through traditionally in a web

00:01:18,299 --> 00:01:24,600
application when you had pages that were

00:01:22,049 --> 00:01:28,560
displaying data and they might also be

00:01:24,600 --> 00:01:31,400
edited right so on page load there is

00:01:28,560 --> 00:01:34,320
this little method of code there on init

00:01:31,400 --> 00:01:36,329
where a data object is basically

00:01:34,320 --> 00:01:38,310
retrieved right so we're talking on the

00:01:36,329 --> 00:01:40,650
server side maybe there are some PHP

00:01:38,310 --> 00:01:42,360
guys in the room server side is

00:01:40,650 --> 00:01:45,509
something you still do quite a bit in

00:01:42,360 --> 00:01:47,670
that area isn't it so so on the server

00:01:45,509 --> 00:01:50,430
side we would retrieve some kind of an

00:01:47,670 --> 00:01:53,670
object I'm calling it the Edit object up

00:01:50,430 --> 00:01:55,950
there and we configure our page to

00:01:53,670 --> 00:01:57,840
display information from this edit

00:01:55,950 --> 00:02:00,479
object right in this case here by

00:01:57,840 --> 00:02:02,009
setting a data source property but it

00:02:00,479 --> 00:02:03,689
doesn't really matter how you do it the

00:02:02,009 --> 00:02:06,479
point is only that the rendered page

00:02:03,689 --> 00:02:09,149
will end up showing information from

00:02:06,479 --> 00:02:10,770
this object now let's say the page comes

00:02:09,149 --> 00:02:13,380
to the browser and the user goes and

00:02:10,770 --> 00:02:15,390
edits something in the page

00:02:13,380 --> 00:02:17,430
some you know text fields or something

00:02:15,390 --> 00:02:21,000
like that they make edits and they

00:02:17,430 --> 00:02:24,120
submit to change data so as a result I

00:02:21,000 --> 00:02:26,670
would then come into the second method

00:02:24,120 --> 00:02:29,310
as well called page load in which I'm

00:02:26,670 --> 00:02:32,820
testing whether the page is currently

00:02:29,310 --> 00:02:34,800
loaded as part of a post call right so

00:02:32,820 --> 00:02:37,620
in this in the situation that data has

00:02:34,800 --> 00:02:40,830
been submitted and if that is the case I

00:02:37,620 --> 00:02:44,220
will then take those changes that I have

00:02:40,830 --> 00:02:47,850
somehow fetched from the post data and

00:02:44,220 --> 00:02:49,860
merged them into my edit object right

00:02:47,850 --> 00:02:51,630
like that and then I save the edit

00:02:49,860 --> 00:02:53,580
object so this is sort of a scenario

00:02:51,630 --> 00:02:56,580
that you would have found in similar

00:02:53,580 --> 00:02:58,650
sequence in very many applications that

00:02:56,580 --> 00:03:01,080
had some kind of server-side

00:02:58,650 --> 00:03:02,250
intelligence right of course things

00:03:01,080 --> 00:03:03,990
might be different today

00:03:02,250 --> 00:03:07,020
perhaps you're talking about a web

00:03:03,990 --> 00:03:08,970
service that actually accepts changes

00:03:07,020 --> 00:03:11,850
from the client in order to persist

00:03:08,970 --> 00:03:15,420
those or whatever but but the mechanism

00:03:11,850 --> 00:03:17,310
in many cases is very similar really in

00:03:15,420 --> 00:03:19,380
many environments people are very keen

00:03:17,310 --> 00:03:23,370
on systems like object relational

00:03:19,380 --> 00:03:25,800
mapping of clever data layers as a more

00:03:23,370 --> 00:03:28,560
general rule perhaps right the data

00:03:25,800 --> 00:03:31,620
layers that allow us as developers to

00:03:28,560 --> 00:03:33,810
work against easy and intuitive api's

00:03:31,620 --> 00:03:36,150
and the data layer does a lot of the

00:03:33,810 --> 00:03:38,820
work that is required to persist our

00:03:36,150 --> 00:03:41,010
data back to the database possibly do

00:03:38,820 --> 00:03:43,320
clever queries and all that kind of

00:03:41,010 --> 00:03:47,040
stuff right so this is the sort of round

00:03:43,320 --> 00:03:48,870
trip now the thing about that is that oh

00:03:47,040 --> 00:03:51,120
well here's a summary fair enough I've

00:03:48,870 --> 00:03:53,670
given you that one the the thing about

00:03:51,120 --> 00:03:57,060
that is that in many cases this approach

00:03:53,670 --> 00:04:00,120
is not entirely optimal really because

00:03:57,060 --> 00:04:03,390
we do some work that isn't actually

00:04:00,120 --> 00:04:05,790
always required for a start when the

00:04:03,390 --> 00:04:08,340
data is loaded in order to display on

00:04:05,790 --> 00:04:10,950
the page in reality you don't always

00:04:08,340 --> 00:04:13,080
actually require the same data when this

00:04:10,950 --> 00:04:15,840
happens right so there might be some

00:04:13,080 --> 00:04:18,690
pages in your application where you know

00:04:15,840 --> 00:04:21,180
your customer or some very obvious

00:04:18,690 --> 00:04:24,030
object like that is actually displayed

00:04:21,180 --> 00:04:26,950
in its entirety but there are probably a

00:04:24,030 --> 00:04:29,860
few of those pages right a cust

00:04:26,950 --> 00:04:32,169
entity in some application can easily

00:04:29,860 --> 00:04:35,680
have you know 50 or 100 fields

00:04:32,169 --> 00:04:38,350
associated other related data probably

00:04:35,680 --> 00:04:40,270
that comes in with it as well and there

00:04:38,350 --> 00:04:42,550
are very few pages anywhere in your

00:04:40,270 --> 00:04:44,620
application I'll bet you that actually

00:04:42,550 --> 00:04:47,320
show all those fields at the same time

00:04:44,620 --> 00:04:49,510
right they really don't at the same time

00:04:47,320 --> 00:04:51,639
of course the other or the other way

00:04:49,510 --> 00:04:54,940
around the same is true if you will

00:04:51,639 --> 00:04:57,700
which means that if you show information

00:04:54,940 --> 00:05:01,780
from a customer object frequently it

00:04:57,700 --> 00:05:05,139
will actually be it will include some

00:05:01,780 --> 00:05:07,720
extra data that is really retrieved from

00:05:05,139 --> 00:05:10,660
some other place right like when your

00:05:07,720 --> 00:05:13,660
data first your persistence back-end

00:05:10,660 --> 00:05:16,330
requires you to join data from various

00:05:13,660 --> 00:05:18,220
tables together as an example right I

00:05:16,330 --> 00:05:21,010
don't know how many of you work with

00:05:18,220 --> 00:05:24,100
relational databases versus no sequel

00:05:21,010 --> 00:05:26,560
databases document databases and so on

00:05:24,100 --> 00:05:29,770
right so your approaches obviously would

00:05:26,560 --> 00:05:32,770
vary depending on those parameters but

00:05:29,770 --> 00:05:36,190
basically the same remains true in many

00:05:32,770 --> 00:05:38,770
applications the data storage in terms

00:05:36,190 --> 00:05:41,320
of the entities that you define the

00:05:38,770 --> 00:05:44,080
tables or collections that you use and

00:05:41,320 --> 00:05:46,630
so on is quite different from what is

00:05:44,080 --> 00:05:49,240
actually used in the application itself

00:05:46,630 --> 00:05:51,130
as far as the user can see write the

00:05:49,240 --> 00:05:53,560
information that the user can't see is

00:05:51,130 --> 00:05:56,590
frequently retrieved from multiple

00:05:53,560 --> 00:05:59,530
locations and at the same time not all

00:05:56,590 --> 00:06:03,130
of it is often displayed at once so from

00:05:59,530 --> 00:06:04,990
this idea cane the concept of CQRS

00:06:03,130 --> 00:06:08,050
that's not a new concept it's been

00:06:04,990 --> 00:06:09,789
around for probably 10 years or so I

00:06:08,050 --> 00:06:12,430
don't know exactly but yeah it's quite

00:06:09,789 --> 00:06:16,810
old really by today's standards the idea

00:06:12,430 --> 00:06:20,470
of it is to define separate execution

00:06:16,810 --> 00:06:22,510
paths for two different aspects of your

00:06:20,470 --> 00:06:26,320
application and these aspects are

00:06:22,510 --> 00:06:27,970
commands and queries the commands are

00:06:26,320 --> 00:06:30,340
the ones that are sent to the system

00:06:27,970 --> 00:06:32,919
when something actually happens like you

00:06:30,340 --> 00:06:35,710
know an edit command or a command to

00:06:32,919 --> 00:06:38,050
create a new instance of something right

00:06:35,710 --> 00:06:39,750
for instance these are commands commands

00:06:38,050 --> 00:06:42,360
could also be

00:06:39,750 --> 00:06:44,760
business processes right you can model

00:06:42,360 --> 00:06:47,610
your system along the lines of business

00:06:44,760 --> 00:06:50,610
processes if your customer says we have

00:06:47,610 --> 00:06:53,010
a process here where somebody places an

00:06:50,610 --> 00:06:55,140
order and they have to initially supply

00:06:53,010 --> 00:06:58,410
this and the other piece of information

00:06:55,140 --> 00:07:00,300
and then after that we do some checking

00:06:58,410 --> 00:07:02,310
and we go back to them and then they

00:07:00,300 --> 00:07:04,440
confirm and they give us some extra

00:07:02,310 --> 00:07:06,480
detail or maybe the payment information

00:07:04,440 --> 00:07:07,830
is processed in a secondary step or

00:07:06,480 --> 00:07:10,740
something like that right so these are

00:07:07,830 --> 00:07:14,340
business processes and frequently the

00:07:10,740 --> 00:07:18,210
commands in your system can if you want

00:07:14,340 --> 00:07:19,770
to adhere to these same lines right so

00:07:18,210 --> 00:07:22,590
that your business processes are

00:07:19,770 --> 00:07:24,600
directly modeled in your system so these

00:07:22,590 --> 00:07:27,030
are commands and the queries quite

00:07:24,600 --> 00:07:30,450
obviously are those processes that

00:07:27,030 --> 00:07:32,490
retrieve information for display or for

00:07:30,450 --> 00:07:34,800
any other purpose where the data is

00:07:32,490 --> 00:07:38,010
required for example data analysis

00:07:34,800 --> 00:07:41,490
processes report generation whatever

00:07:38,010 --> 00:07:43,500
they might be right so we realize based

00:07:41,490 --> 00:07:45,720
on what I showed you initially this kind

00:07:43,500 --> 00:07:49,860
of slightly old-fashioned data access

00:07:45,720 --> 00:07:52,620
sample we realize that the processes of

00:07:49,860 --> 00:07:55,290
clearing data and on of performing

00:07:52,620 --> 00:07:57,840
commands are logically different right

00:07:55,290 --> 00:08:00,510
so it we would benefit from keeping them

00:07:57,840 --> 00:08:02,940
separate on a technical level and also

00:08:00,510 --> 00:08:06,630
we realize that we work with different

00:08:02,940 --> 00:08:09,120
data models for those two scenarios that

00:08:06,630 --> 00:08:12,870
means that the information that is being

00:08:09,120 --> 00:08:14,520
sent or received is not always the same

00:08:12,870 --> 00:08:16,470
right the information we actually

00:08:14,520 --> 00:08:18,919
require is not always the same

00:08:16,470 --> 00:08:22,350
frequently there are actually multiple

00:08:18,919 --> 00:08:25,020
processes involved for sort of the DIF

00:08:22,350 --> 00:08:26,940
the same aspect for instance if you

00:08:25,020 --> 00:08:30,479
imagine you have a system where users

00:08:26,940 --> 00:08:32,849
can log in then you would have a number

00:08:30,479 --> 00:08:35,729
of fields associated with each of these

00:08:32,849 --> 00:08:37,620
user objects in your system and you

00:08:35,729 --> 00:08:39,870
would have processes to edit that

00:08:37,620 --> 00:08:42,180
information but you will probably edit

00:08:39,870 --> 00:08:44,790
that information piece by piece

00:08:42,180 --> 00:08:47,670
right for example maybe a user can

00:08:44,790 --> 00:08:49,680
easily go in and edit their own name if

00:08:47,670 --> 00:08:51,720
they like right okay that's no problem

00:08:49,680 --> 00:08:53,580
but if they want to edit their email

00:08:51,720 --> 00:08:55,830
address that's already a diff

00:08:53,580 --> 00:08:57,990
and process because you may require the

00:08:55,830 --> 00:08:59,760
user to actually confirm their email

00:08:57,990 --> 00:09:02,250
address before the editing can take

00:08:59,760 --> 00:09:04,560
place right if you if you allow the user

00:09:02,250 --> 00:09:06,690
to change their password that's an

00:09:04,560 --> 00:09:08,730
entirely different process again right

00:09:06,690 --> 00:09:11,130
and each of those processes has their

00:09:08,730 --> 00:09:13,410
own data module if you like because

00:09:11,130 --> 00:09:15,300
there are certain sets of information

00:09:13,410 --> 00:09:18,180
that are associated with each of the

00:09:15,300 --> 00:09:21,810
process and and only those will be

00:09:18,180 --> 00:09:24,390
passed instead of the entire user or

00:09:21,810 --> 00:09:28,230
whatever object in your in your system

00:09:24,390 --> 00:09:30,810
right so that's the idea of CQRS one

00:09:28,230 --> 00:09:33,390
process can be different from another we

00:09:30,810 --> 00:09:36,600
can save a lot of time as it says up

00:09:33,390 --> 00:09:40,890
here if we do this quite stringently

00:09:36,600 --> 00:09:43,290
if page cycles are somehow required for

00:09:40,890 --> 00:09:45,000
operations in your system depending on

00:09:43,290 --> 00:09:47,190
whatever technology platform you're

00:09:45,000 --> 00:09:49,560
working on then you will basically be

00:09:47,190 --> 00:09:52,050
saving quite a lot of time by being able

00:09:49,560 --> 00:09:53,930
to keep these page cycles logically

00:09:52,050 --> 00:09:56,550
separate right you don't have to perform

00:09:53,930 --> 00:10:00,450
more work than is absolutely necessary

00:09:56,550 --> 00:10:03,800
in each case it is also possible because

00:10:00,450 --> 00:10:07,200
it allows you to individually scale and

00:10:03,800 --> 00:10:09,870
generally treat your different execution

00:10:07,200 --> 00:10:12,720
paths so the path that allows you to

00:10:09,870 --> 00:10:15,720
query data is different from the one for

00:10:12,720 --> 00:10:18,030
for post-processing of commands and as a

00:10:15,720 --> 00:10:21,120
result you can have individual services

00:10:18,030 --> 00:10:23,880
for it that scale up when query requests

00:10:21,120 --> 00:10:26,280
come in you know lots of them whereas

00:10:23,880 --> 00:10:29,250
the the post commands might be fewer

00:10:26,280 --> 00:10:31,050
right you can do analyses on your system

00:10:29,250 --> 00:10:34,470
to find out what kind of characteristics

00:10:31,050 --> 00:10:38,850
you actually have most typical business

00:10:34,470 --> 00:10:40,950
applications to 90% querying right there

00:10:38,850 --> 00:10:43,260
are probably exceptions up to that rule

00:10:40,950 --> 00:10:46,200
but in general that is true there might

00:10:43,260 --> 00:10:48,990
be applications that have specific bits

00:10:46,200 --> 00:10:50,730
somewhere where they do a lot of command

00:10:48,990 --> 00:10:53,400
processing for example if they do

00:10:50,730 --> 00:10:54,900
something like live data import or that

00:10:53,400 --> 00:10:56,790
kind of thing right in that case they

00:10:54,900 --> 00:10:59,100
would receive a lot of commands but

00:10:56,790 --> 00:11:00,450
these commands are also very specialized

00:10:59,100 --> 00:11:04,340
right they they have a particular

00:11:00,450 --> 00:11:06,780
purpose in the system and in general the

00:11:04,340 --> 00:11:08,790
majority of the

00:11:06,780 --> 00:11:11,340
processes handled by the system would

00:11:08,790 --> 00:11:13,610
probably still be queries right so

00:11:11,340 --> 00:11:17,070
that's the the characteristic and

00:11:13,610 --> 00:11:18,990
viewing these execution paths separately

00:11:17,070 --> 00:11:20,910
as it says in the last bullet there

00:11:18,990 --> 00:11:22,980
means that you will maintain them

00:11:20,910 --> 00:11:25,110
separately you can deploy them

00:11:22,980 --> 00:11:27,990
separately and handle their performance

00:11:25,110 --> 00:11:30,390
characteristics as needed you can test

00:11:27,990 --> 00:11:32,840
them separately as well right your

00:11:30,390 --> 00:11:37,710
overall application logic with the CQRS

00:11:32,840 --> 00:11:40,530
implementation gets easier so here is an

00:11:37,710 --> 00:11:42,870
illustrative diagram to show you you

00:11:40,530 --> 00:11:46,320
know how that might work in case you're

00:11:42,870 --> 00:11:48,360
a visual person we've got the smiling

00:11:46,320 --> 00:11:51,480
client there on the left hand side and

00:11:48,360 --> 00:11:54,210
that client would then perhaps send a

00:11:51,480 --> 00:11:56,250
command to an entity that I'm calling a

00:11:54,210 --> 00:11:58,950
command engine down there at the bottom

00:11:56,250 --> 00:12:02,040
right so that's your command processor

00:11:58,950 --> 00:12:04,560
and I've listed some possible names of

00:12:02,040 --> 00:12:06,990
commands in there create customer update

00:12:04,560 --> 00:12:08,850
customer place order like I said yes

00:12:06,990 --> 00:12:12,360
each one of those would come with a

00:12:08,850 --> 00:12:14,520
certain Associated set of values right

00:12:12,360 --> 00:12:17,130
that that have to be passed along with

00:12:14,520 --> 00:12:20,070
that command now the command engine

00:12:17,130 --> 00:12:22,410
would potentially access a database for

00:12:20,070 --> 00:12:24,450
storage purposes right I'm just giving

00:12:22,410 --> 00:12:26,580
this as an example here of course in

00:12:24,450 --> 00:12:28,620
reality the command could have any sort

00:12:26,580 --> 00:12:31,440
of other consequence inside your system

00:12:28,620 --> 00:12:34,500
and on the other end of that we have the

00:12:31,440 --> 00:12:36,540
query engine so basically the smiling

00:12:34,500 --> 00:12:38,970
client would also be able to submit a

00:12:36,540 --> 00:12:41,910
query to that query engine for example

00:12:38,970 --> 00:12:44,550
the information that is required in

00:12:41,910 --> 00:12:47,880
order to bring up an editing form for

00:12:44,550 --> 00:12:50,460
customer number 23 right and then that

00:12:47,880 --> 00:12:52,500
information would be returned we see up

00:12:50,460 --> 00:12:54,630
there Bob right is returned to the

00:12:52,500 --> 00:12:57,570
client where the information can be

00:12:54,630 --> 00:13:00,720
displayed and if somebody actually goes

00:12:57,570 --> 00:13:02,790
and arranges Bob's details then that

00:13:00,720 --> 00:13:04,530
would lead again to a command update

00:13:02,790 --> 00:13:06,150
customer being sent to the command

00:13:04,530 --> 00:13:08,400
engine all right that's the idea of

00:13:06,150 --> 00:13:10,560
separating those execution paths and

00:13:08,400 --> 00:13:13,620
I've also listed that there might be a

00:13:10,560 --> 00:13:17,160
separate top customers query there and

00:13:13,620 --> 00:13:20,280
I've put some arbitrary values in that

00:13:17,160 --> 00:13:22,470
just to to illustrate that clearly

00:13:20,280 --> 00:13:24,780
the information returned by different

00:13:22,470 --> 00:13:26,550
types of queries could be entirely

00:13:24,780 --> 00:13:30,360
different right that's that's an

00:13:26,550 --> 00:13:32,040
important idea in there and it is like

00:13:30,360 --> 00:13:35,130
that all the way down to the query

00:13:32,040 --> 00:13:38,010
engine right so we don't have any point

00:13:35,130 --> 00:13:40,410
in this application as it is depicted

00:13:38,010 --> 00:13:44,430
here where we are working with any kind

00:13:40,410 --> 00:13:46,980
of a standard structure a standard class

00:13:44,430 --> 00:13:48,780
type perhaps that always has exactly the

00:13:46,980 --> 00:13:51,840
same fields or anything like that right

00:13:48,780 --> 00:13:54,630
the modules the data modules that are

00:13:51,840 --> 00:13:57,540
exchanged by each of the operations in

00:13:54,630 --> 00:14:00,480
here are different from each other and

00:13:57,540 --> 00:14:02,820
they are specifically structured for

00:14:00,480 --> 00:14:05,610
whatever purpose that is that data

00:14:02,820 --> 00:14:09,870
modules purpose right so that's the idea

00:14:05,610 --> 00:14:11,190
of CQRS now I think my next slide goes

00:14:09,870 --> 00:14:13,410
in that direction you shouldn't

00:14:11,190 --> 00:14:15,330
necessarily imagine that the that your

00:14:13,410 --> 00:14:18,600
application structure has to be very

00:14:15,330 --> 00:14:21,270
complex or enormously scaled out or

00:14:18,600 --> 00:14:23,400
anything like that in order to use CQRS

00:14:21,270 --> 00:14:25,740
as a pattern right that's not really the

00:14:23,400 --> 00:14:27,960
intention I was showing in the diagram

00:14:25,740 --> 00:14:31,230
how you know we might have certain

00:14:27,960 --> 00:14:33,960
logical services or something perhaps if

00:14:31,230 --> 00:14:35,850
you will in there for the command engine

00:14:33,960 --> 00:14:38,430
and the query engine right of course you

00:14:35,850 --> 00:14:40,380
can imagine services if you're thinking

00:14:38,430 --> 00:14:43,200
and microservices type of architecture

00:14:40,380 --> 00:14:45,570
then perhaps we have services in there I

00:14:43,200 --> 00:14:47,880
was mentioning individual scaling and

00:14:45,570 --> 00:14:50,520
all that stuff but in reality what the

00:14:47,880 --> 00:14:53,070
pattern is really about is mostly just

00:14:50,520 --> 00:14:56,010
the structural aspect of it right the

00:14:53,070 --> 00:14:58,650
assigning of responsibilities to those

00:14:56,010 --> 00:15:01,140
individual logical modules of your

00:14:58,650 --> 00:15:03,990
application so you could do the same

00:15:01,140 --> 00:15:06,210
thing in a monolithic client application

00:15:03,990 --> 00:15:09,810
if you like yeah there is basically no

00:15:06,210 --> 00:15:13,290
limit to the two where this pattern

00:15:09,810 --> 00:15:15,800
could be applied I personally don't

00:15:13,290 --> 00:15:18,900
think we here you know typical criticism

00:15:15,800 --> 00:15:21,150
is it is it a complex pattern

00:15:18,900 --> 00:15:23,100
I personally totally don't think so

00:15:21,150 --> 00:15:25,650
because it really simplifies each

00:15:23,100 --> 00:15:27,630
individual piece of logic that your

00:15:25,650 --> 00:15:30,900
application implements somewhere it

00:15:27,630 --> 00:15:34,019
simplifies it a lot compared to combined

00:15:30,900 --> 00:15:36,689
execution paths combined execution paths

00:15:34,019 --> 00:15:39,720
are usually more complex to begin with

00:15:36,689 --> 00:15:42,509
you have to write more code to make sure

00:15:39,720 --> 00:15:44,309
that every time maybe a query runs or

00:15:42,509 --> 00:15:46,879
anything like that you actually return

00:15:44,309 --> 00:15:49,800
precisely the right data and you don't

00:15:46,879 --> 00:15:51,809
accidentally include stuff that might

00:15:49,800 --> 00:15:53,939
not really be included with that query

00:15:51,809 --> 00:15:57,269
right you have a difficult time making

00:15:53,939 --> 00:15:59,970
sure that based on user permissions and

00:15:57,269 --> 00:16:02,790
all kinds of other settings perhaps the

00:15:59,970 --> 00:16:05,579
correct data is delivered and there the

00:16:02,790 --> 00:16:07,649
incorrect data is not delivered right so

00:16:05,579 --> 00:16:10,079
that sort of thing is hard with combined

00:16:07,649 --> 00:16:12,839
execution paths easy to get wrong hard

00:16:10,079 --> 00:16:15,600
to test sometimes and with a separate

00:16:12,839 --> 00:16:18,839
execution path this becomes much simpler

00:16:15,600 --> 00:16:21,239
so in my experience a CQRS application

00:16:18,839 --> 00:16:24,540
is actually structurally structurally

00:16:21,239 --> 00:16:27,089
simpler using object relational mapping

00:16:24,540 --> 00:16:28,819
some people are like really attached to

00:16:27,089 --> 00:16:31,679
that which is why I have it in there

00:16:28,819 --> 00:16:34,019
that is an a system that is not really

00:16:31,679 --> 00:16:36,329
entirely compatible from a philosophical

00:16:34,019 --> 00:16:38,189
point of view with the sole separating

00:16:36,329 --> 00:16:40,980
execution paths thing right

00:16:38,189 --> 00:16:43,319
Oh RM was basically originally intended

00:16:40,980 --> 00:16:46,559
for the object oriented program in

00:16:43,319 --> 00:16:50,670
various languages Java among them right

00:16:46,559 --> 00:16:53,730
early on who were trying to persist the

00:16:50,670 --> 00:16:55,860
complex object and class systems that

00:16:53,730 --> 00:16:59,399
they had previously already created

00:16:55,860 --> 00:17:00,839
right so it went from there and today we

00:16:59,399 --> 00:17:02,699
have a lot of object relational mapping

00:17:00,839 --> 00:17:05,549
systems that kind of go the other way

00:17:02,699 --> 00:17:09,149
around where people actually design

00:17:05,549 --> 00:17:11,819
databases in database servers and then

00:17:09,149 --> 00:17:15,020
they have an object-oriented layer on

00:17:11,819 --> 00:17:17,159
top of it using some sort of an ORM tool

00:17:15,020 --> 00:17:20,039
potentially you could use this latter

00:17:17,159 --> 00:17:22,889
approach if you really want to to work

00:17:20,039 --> 00:17:25,350
with your data layer through the ORM

00:17:22,889 --> 00:17:28,020
right but in reality the data

00:17:25,350 --> 00:17:31,080
persistence operations that we actually

00:17:28,020 --> 00:17:32,909
require are very simple it depends on

00:17:31,080 --> 00:17:35,909
the kinds of clients and stuff that you

00:17:32,909 --> 00:17:38,730
use but with most no sequel databases

00:17:35,909 --> 00:17:41,429
for example the process of persisting

00:17:38,730 --> 00:17:44,190
some data in a format that would be

00:17:41,429 --> 00:17:47,340
easily usable here and as we see also in

00:17:44,190 --> 00:17:48,990
event sourcing systems that is usually

00:17:47,340 --> 00:17:51,090
it's simple to do and you may not

00:17:48,990 --> 00:17:53,160
actually require any any additional

00:17:51,090 --> 00:17:56,130
layer in between that of course always

00:17:53,160 --> 00:17:59,400
has a certain degree of overhead all

00:17:56,130 --> 00:18:01,770
right so that's to keep in mind right so

00:17:59,400 --> 00:18:05,730
yep enough said about that I think

00:18:01,770 --> 00:18:08,250
that's the win now how do you do this I

00:18:05,730 --> 00:18:10,080
think we've basically talked about most

00:18:08,250 --> 00:18:12,330
of these points right you module

00:18:10,080 --> 00:18:14,730
everything that happens as changes in

00:18:12,330 --> 00:18:16,500
your system as commands so you have to

00:18:14,730 --> 00:18:19,470
try to gain an understanding of what

00:18:16,500 --> 00:18:21,870
your system actually does what your user

00:18:19,470 --> 00:18:24,510
is do right that's a very good starting

00:18:21,870 --> 00:18:27,120
point anything that your users do can be

00:18:24,510 --> 00:18:29,310
a command basically right and there

00:18:27,120 --> 00:18:31,290
might be a few extra commands at some

00:18:29,310 --> 00:18:33,720
point for example for multi-step

00:18:31,290 --> 00:18:36,660
operations if something has to happen

00:18:33,720 --> 00:18:39,780
later then an extra command might be

00:18:36,660 --> 00:18:42,720
required for the later step and so on

00:18:39,780 --> 00:18:45,090
right and then you can define your data

00:18:42,720 --> 00:18:47,040
models which is usually quite simple

00:18:45,090 --> 00:18:49,440
because you basically just go by what is

00:18:47,040 --> 00:18:51,330
seen in the UI right that's what you

00:18:49,440 --> 00:18:54,120
need basically of course there are

00:18:51,330 --> 00:18:55,470
exceptions like automated processing of

00:18:54,120 --> 00:18:57,660
certain data and so on

00:18:55,470 --> 00:18:59,820
right but as a starting point that's a

00:18:57,660 --> 00:19:02,370
really good idea it's a bit like it is

00:18:59,820 --> 00:19:05,010
defining view models in an MVVM pattern

00:19:02,370 --> 00:19:06,690
right where I mean that's not hard

00:19:05,010 --> 00:19:08,640
because all you need to do is look at

00:19:06,690 --> 00:19:10,680
your screen and find out what the user

00:19:08,640 --> 00:19:12,830
actually needs to see there right that's

00:19:10,680 --> 00:19:15,210
that's your starting point that's your

00:19:12,830 --> 00:19:17,310
85% or something of what you need to do

00:19:15,210 --> 00:19:21,720
and that's kind of similar in this

00:19:17,310 --> 00:19:24,000
scenario here as well okay let me check

00:19:21,720 --> 00:19:25,560
the time since we're running behind and

00:19:24,000 --> 00:19:28,560
everything I think we're meant to finish

00:19:25,560 --> 00:19:30,810
at quarter past eleven right okay that's

00:19:28,560 --> 00:19:33,690
not bad that's not bad so now the

00:19:30,810 --> 00:19:36,360
somewhat more complex topic really is

00:19:33,690 --> 00:19:39,200
the event sourcing topic event sourcing

00:19:36,360 --> 00:19:41,070
in itself is not necessarily directly

00:19:39,200 --> 00:19:43,350
connected to CQRS

00:19:41,070 --> 00:19:46,470
but it does go hand-in-hand with the

00:19:43,350 --> 00:19:49,980
idea very easily and you would basically

00:19:46,470 --> 00:19:52,140
always have separate execution paths in

00:19:49,980 --> 00:19:54,720
an event sourcing system so that is why

00:19:52,140 --> 00:19:58,530
these two patterns are usually mentioned

00:19:54,720 --> 00:20:01,110
hand-in-hand and it makes sense starting

00:19:58,530 --> 00:20:03,990
from the command idea right there yes

00:20:01,110 --> 00:20:06,420
we still send commands to the system in

00:20:03,990 --> 00:20:08,990
an event sourcing system the biggest

00:20:06,420 --> 00:20:11,820
difference of it is really that the only

00:20:08,990 --> 00:20:14,340
persistence we have absolutely

00:20:11,820 --> 00:20:18,000
necessarily in an event sourcing system

00:20:14,340 --> 00:20:19,710
is the event store itself right so

00:20:18,000 --> 00:20:21,450
that's that's the most important thing

00:20:19,710 --> 00:20:23,240
to realize right if you're thinking in

00:20:21,450 --> 00:20:26,580
terms of somebody familiar with

00:20:23,240 --> 00:20:29,670
relational databases probably some no

00:20:26,580 --> 00:20:32,760
secret ones as well where your database

00:20:29,670 --> 00:20:34,559
is basically the snapshot of all the

00:20:32,760 --> 00:20:37,710
information in your system right now we

00:20:34,559 --> 00:20:38,280
are that is the old-fashioned mindset if

00:20:37,710 --> 00:20:41,370
you will

00:20:38,280 --> 00:20:43,169
my apologies in comparison to this here

00:20:41,370 --> 00:20:46,860
right because what we do in event

00:20:43,169 --> 00:20:49,590
sourcing is we don't store a snapshot of

00:20:46,860 --> 00:20:51,870
data well in reality we will in a moment

00:20:49,590 --> 00:20:54,299
but just from the basic mindset yeah the

00:20:51,870 --> 00:20:57,320
basic mindset is that instead of storing

00:20:54,299 --> 00:21:00,299
a snapshot of data as it is right now

00:20:57,320 --> 00:21:04,230
what we do is we simply persist

00:21:00,299 --> 00:21:06,540
everything that happens in the system so

00:21:04,230 --> 00:21:08,700
the commands right the commands are the

00:21:06,540 --> 00:21:11,280
entities that make things happen the

00:21:08,700 --> 00:21:14,460
commands define what happens you could

00:21:11,280 --> 00:21:17,520
begin let's say with an entirely empty

00:21:14,460 --> 00:21:19,590
data store and then a command comes in

00:21:17,520 --> 00:21:22,110
create customer and you go and you

00:21:19,590 --> 00:21:24,720
create a customer object write a command

00:21:22,110 --> 00:21:27,690
comes in update customer you go and you

00:21:24,720 --> 00:21:31,169
changed the object now as long as you

00:21:27,690 --> 00:21:33,780
persist or the commands and we do this

00:21:31,169 --> 00:21:36,360
in what is called an event log I'll say

00:21:33,780 --> 00:21:38,549
more about that in a moment as long as

00:21:36,360 --> 00:21:40,919
you persist all the commands you could

00:21:38,549 --> 00:21:43,799
always begin again from your logical

00:21:40,919 --> 00:21:46,620
state 0 where you don't have any data in

00:21:43,799 --> 00:21:49,590
your application and simply run through

00:21:46,620 --> 00:21:51,540
all the commands again right and you

00:21:49,590 --> 00:21:54,540
would then again arrive at the same

00:21:51,540 --> 00:21:57,900
state of the overall system today right

00:21:54,540 --> 00:22:00,750
so that is the idea the event log is the

00:21:57,900 --> 00:22:03,600
only definitely available kind of

00:22:00,750 --> 00:22:06,299
persistence in a in an event sourcing

00:22:03,600 --> 00:22:07,830
system and it is a pretty simple type of

00:22:06,299 --> 00:22:10,350
persistence because it's append-only

00:22:07,830 --> 00:22:13,110
right so that can be handled very very

00:22:10,350 --> 00:22:14,940
performant ly it's very fast which is

00:22:13,110 --> 00:22:17,820
important theoretically

00:22:14,940 --> 00:22:20,460
could have multiple different processing

00:22:17,820 --> 00:22:23,010
services running in parallel accepting

00:22:20,460 --> 00:22:25,890
commands as quickly as they possibly can

00:22:23,010 --> 00:22:29,430
and converting them into events and

00:22:25,890 --> 00:22:30,960
appending them to the event log right so

00:22:29,430 --> 00:22:33,930
that's kind of the idea with it that is

00:22:30,960 --> 00:22:36,840
a very very quick thing any state of any

00:22:33,930 --> 00:22:42,110
entity can be derived at any point in

00:22:36,840 --> 00:22:45,930
time for from this log of events now

00:22:42,110 --> 00:22:47,760
there is a something happening basically

00:22:45,930 --> 00:22:50,490
in this what I just called a conversion

00:22:47,760 --> 00:22:53,700
from the command to the event right so

00:22:50,490 --> 00:22:55,350
we begin with a command and the there is

00:22:53,700 --> 00:22:58,440
some kind of a service are calling

00:22:55,350 --> 00:23:00,990
command processor that accepts this

00:22:58,440 --> 00:23:03,930
command and then it usually performs

00:23:00,990 --> 00:23:06,000
some basic validation on the command to

00:23:03,930 --> 00:23:08,250
make sure that it's valid from a very

00:23:06,000 --> 00:23:11,040
technical point of view right so the

00:23:08,250 --> 00:23:14,970
command will have to include the command

00:23:11,040 --> 00:23:17,580
name for for start and for organization

00:23:14,970 --> 00:23:20,490
purposes we also associate with each

00:23:17,580 --> 00:23:23,970
command the name of a so called

00:23:20,490 --> 00:23:26,220
aggregate and the ID of such an

00:23:23,970 --> 00:23:29,010
aggregate these are the typical three

00:23:26,220 --> 00:23:32,190
values that you expect a command to

00:23:29,010 --> 00:23:35,520
contain at least right so the aggregate

00:23:32,190 --> 00:23:36,960
is like some sort of logical unit right

00:23:35,520 --> 00:23:40,680
it doesn't necessarily have to

00:23:36,960 --> 00:23:43,350
correspond exactly to some sort of a

00:23:40,680 --> 00:23:46,080
domain entity or anything like that in

00:23:43,350 --> 00:23:48,810
reality some of the time it will yeah so

00:23:46,080 --> 00:23:51,480
for example if you go and create a new

00:23:48,810 --> 00:23:54,560
instance of something then that will

00:23:51,480 --> 00:23:57,270
usually be the aggregate itself right

00:23:54,560 --> 00:23:59,400
and that's that also explains where the

00:23:57,270 --> 00:24:02,610
ID comes from right so you create

00:23:59,400 --> 00:24:04,530
customer and you pass in the name of or

00:24:02,610 --> 00:24:07,560
rather your command would probably just

00:24:04,530 --> 00:24:10,530
be called create and the aggregate name

00:24:07,560 --> 00:24:13,650
might be customer and for the aggregate

00:24:10,530 --> 00:24:16,550
ID the client normally specifies the

00:24:13,650 --> 00:24:20,130
aggregate ID for logical reasons and

00:24:16,550 --> 00:24:22,170
that ID is expected to be unique right

00:24:20,130 --> 00:24:24,270
so the easiest way to do this is to work

00:24:22,170 --> 00:24:26,100
with you you IDs but you can basically

00:24:24,270 --> 00:24:28,780
do that any way you want right so that

00:24:26,100 --> 00:24:30,700
information comes in from the outside

00:24:28,780 --> 00:24:32,430
and on that point the command processor

00:24:30,700 --> 00:24:35,470
is expected to perform some basic

00:24:32,430 --> 00:24:38,920
validation to find out whether it's okay

00:24:35,470 --> 00:24:41,440
to include this command or the event

00:24:38,920 --> 00:24:43,960
related to the command in the system's

00:24:41,440 --> 00:24:45,880
event log or not right if the command

00:24:43,960 --> 00:24:46,840
processor says this is clearly

00:24:45,880 --> 00:24:49,030
incomplete

00:24:46,840 --> 00:24:50,890
we don't have an aggregate name included

00:24:49,030 --> 00:24:52,210
here then of course we never add it to

00:24:50,890 --> 00:24:54,460
the event log right

00:24:52,210 --> 00:24:56,800
the validation can go further than that

00:24:54,460 --> 00:24:58,900
it's a bit up to individual developers

00:24:56,800 --> 00:25:01,030
or teams how far you would like to take

00:24:58,900 --> 00:25:03,760
this the idea is sort of that the

00:25:01,030 --> 00:25:06,850
command processor doesn't entirely care

00:25:03,760 --> 00:25:09,640
what the commands really say right so if

00:25:06,850 --> 00:25:11,470
you if you take validation very very far

00:25:09,640 --> 00:25:13,690
then of course you will have to be

00:25:11,470 --> 00:25:17,320
changing your command processor all the

00:25:13,690 --> 00:25:19,270
time as you add new aggregate commands

00:25:17,320 --> 00:25:21,340
and stuff like that into your system

00:25:19,270 --> 00:25:23,680
right so there is a compromise somewhere

00:25:21,340 --> 00:25:27,100
in between don't validate more than

00:25:23,680 --> 00:25:29,500
necessary basically the aggregates I've

00:25:27,100 --> 00:25:32,290
been talking about our basically little

00:25:29,500 --> 00:25:34,600
objects that are in some implementations

00:25:32,290 --> 00:25:36,550
they're kept in memory the entire time

00:25:34,600 --> 00:25:38,830
in some implementations they might be

00:25:36,550 --> 00:25:40,780
retrieved from a shared cache or

00:25:38,830 --> 00:25:42,940
something along these lines sometimes

00:25:40,780 --> 00:25:46,900
people also for optimization purposes

00:25:42,940 --> 00:25:49,600
use snapshots as I say down there so

00:25:46,900 --> 00:25:52,630
when the event log of course over time

00:25:49,600 --> 00:25:55,900
reaches a pretty large number of rows

00:25:52,630 --> 00:25:58,600
then they basically create a snapshot of

00:25:55,900 --> 00:26:01,330
the aggregate State at various points in

00:25:58,600 --> 00:26:04,390
time perhaps you know every 50,000

00:26:01,330 --> 00:26:06,820
commands or once a day or something like

00:26:04,390 --> 00:26:09,910
that and then of course in a particular

00:26:06,820 --> 00:26:13,360
aggregate state might be loaded from

00:26:09,910 --> 00:26:15,400
that persistent snapshot right so that's

00:26:13,360 --> 00:26:17,530
where your aggregate comes from but the

00:26:15,400 --> 00:26:20,680
aggregate is not an object that

00:26:17,530 --> 00:26:23,110
represents the entire state of some

00:26:20,680 --> 00:26:25,060
entity like for example a customer with

00:26:23,110 --> 00:26:27,040
all those hundred fields I was talking

00:26:25,060 --> 00:26:30,280
about right but the aggregate only

00:26:27,040 --> 00:26:33,610
contains whatever very few fields are

00:26:30,280 --> 00:26:35,920
required for validation purposes so for

00:26:33,610 --> 00:26:37,750
for a start you might want to be able to

00:26:35,920 --> 00:26:39,640
figure out whether an object with a

00:26:37,750 --> 00:26:42,640
certain ID has actually been created

00:26:39,640 --> 00:26:45,280
before right so if somebody does

00:26:42,640 --> 00:26:47,830
create customer number one and then they

00:26:45,280 --> 00:26:49,540
do exactly the same again afterwards it

00:26:47,830 --> 00:26:51,070
would be nice to be able to tell them on

00:26:49,540 --> 00:26:53,920
the second run that that thing already

00:26:51,070 --> 00:26:56,950
exists right so that's one very simple

00:26:53,920 --> 00:27:00,010
flag that is usually included with an

00:26:56,950 --> 00:27:02,680
aggregate do we have this object already

00:27:00,010 --> 00:27:05,140
that kind of thing so this validation

00:27:02,680 --> 00:27:06,790
it's what's meant to be supported by the

00:27:05,140 --> 00:27:08,830
aggregates it doesn't go any further

00:27:06,790 --> 00:27:11,950
than that so aggregates are very small

00:27:08,830 --> 00:27:16,150
they can for for a performance purposes

00:27:11,950 --> 00:27:18,490
be persisted in snapshots and they would

00:27:16,150 --> 00:27:20,790
otherwise be retrieved by running

00:27:18,490 --> 00:27:23,080
through the events in the event log and

00:27:20,790 --> 00:27:25,450
performing certain changes and these

00:27:23,080 --> 00:27:27,190
changes are called projections in case

00:27:25,450 --> 00:27:30,720
you are wondering why that term is on

00:27:27,190 --> 00:27:33,340
there so when an event is basically

00:27:30,720 --> 00:27:35,440
interpreted and certain trainers are

00:27:33,340 --> 00:27:38,170
made to the aggregate and in a moment

00:27:35,440 --> 00:27:40,120
I'll talk about read models as well that

00:27:38,170 --> 00:27:46,210
is called a projection alright so that's

00:27:40,120 --> 00:27:48,940
the idea that okay now this is the basic

00:27:46,210 --> 00:27:52,530
idea of event sourcing I have talked

00:27:48,940 --> 00:27:55,720
about this I think now in in parts here

00:27:52,530 --> 00:27:57,580
we can using the events we can find out

00:27:55,720 --> 00:28:00,280
at any point in time what the system

00:27:57,580 --> 00:28:02,650
actually does right clearly this method

00:28:00,280 --> 00:28:05,170
of data storage is much more powerful in

00:28:02,650 --> 00:28:07,540
a way than the method of storing a

00:28:05,170 --> 00:28:10,120
particular snapshot of data the entire

00:28:07,540 --> 00:28:13,060
time right in an event sourcing system

00:28:10,120 --> 00:28:15,310
we know what what happened in the entire

00:28:13,060 --> 00:28:17,830
system in all time right back to

00:28:15,310 --> 00:28:19,840
whenever it was first installed not just

00:28:17,830 --> 00:28:22,870
what the state of data is today so

00:28:19,840 --> 00:28:27,070
clearly there's much more in that of

00:28:22,870 --> 00:28:29,050
course we also have various pieces of

00:28:27,070 --> 00:28:31,390
tracking functionality in most

00:28:29,050 --> 00:28:33,190
traditional applications right depending

00:28:31,390 --> 00:28:36,100
on the industry you work in you might

00:28:33,190 --> 00:28:38,740
have to have auditing of certain object

00:28:36,100 --> 00:28:41,050
operations or entity operations whatever

00:28:38,740 --> 00:28:43,510
in your application anyway and event

00:28:41,050 --> 00:28:46,840
sourcing covers all these aspects at the

00:28:43,510 --> 00:28:49,870
same time right an important thing is

00:28:46,840 --> 00:28:52,720
that the consequences of an event in

00:28:49,870 --> 00:28:54,880
your overall system are actually not set

00:28:52,720 --> 00:28:56,440
in stone I haven't talked about read

00:28:54,880 --> 00:28:58,660
morals yet I will in

00:28:56,440 --> 00:29:01,210
Almond read morals just in a nutshell

00:28:58,660 --> 00:29:04,180
are basically the query part of your

00:29:01,210 --> 00:29:06,940
application where a client retrieves

00:29:04,180 --> 00:29:09,250
information from right and these read

00:29:06,940 --> 00:29:12,400
morals are basically data storage

00:29:09,250 --> 00:29:14,980
elements that are derived from the event

00:29:12,400 --> 00:29:17,410
stream so whenever events come through

00:29:14,980 --> 00:29:19,810
the system the read model might be

00:29:17,410 --> 00:29:21,490
changed in some way or maybe not right

00:29:19,810 --> 00:29:23,620
depending whether the event has anything

00:29:21,490 --> 00:29:25,270
to do with the data in that particular

00:29:23,620 --> 00:29:27,940
read model right if there is a

00:29:25,270 --> 00:29:29,890
connection a change might be made if not

00:29:27,940 --> 00:29:32,230
there not right so in that's the way it

00:29:29,890 --> 00:29:35,260
works but this isn't something that can

00:29:32,230 --> 00:29:37,960
easily be changed later on if you decide

00:29:35,260 --> 00:29:40,390
that you have a read model that was

00:29:37,960 --> 00:29:43,300
originally created to support you know

00:29:40,390 --> 00:29:45,580
some kind of a report maybe so there are

00:29:43,300 --> 00:29:47,590
like ten fields in the read model at the

00:29:45,580 --> 00:29:49,840
moment and they appear in a report and

00:29:47,590 --> 00:29:51,790
now the customer comes and says oh yeah

00:29:49,840 --> 00:29:54,700
we would actually like to have you know

00:29:51,790 --> 00:29:57,580
another field in there and how about we

00:29:54,700 --> 00:29:59,620
do some clever total calculation or

00:29:57,580 --> 00:30:02,920
something underneath then you basically

00:29:59,620 --> 00:30:05,260
just go and change the projection code

00:30:02,920 --> 00:30:07,990
of your read model the code that

00:30:05,260 --> 00:30:09,970
transfers the event information into

00:30:07,990 --> 00:30:13,150
your read more of storage somehow and

00:30:09,970 --> 00:30:15,190
then you go and kill the existing

00:30:13,150 --> 00:30:17,680
database of the read model you just go

00:30:15,190 --> 00:30:19,990
and drop all the old state and you

00:30:17,680 --> 00:30:23,770
replay and that's an important concept

00:30:19,990 --> 00:30:26,380
you replay the event store for this read

00:30:23,770 --> 00:30:28,720
model which means that the read morally

00:30:26,380 --> 00:30:32,140
goes through the events all the way long

00:30:28,720 --> 00:30:34,210
to its current state and then all of a

00:30:32,140 --> 00:30:36,820
sudden you have a completely changed and

00:30:34,210 --> 00:30:39,040
possibly different structure of data to

00:30:36,820 --> 00:30:41,380
what you had before it's also very

00:30:39,040 --> 00:30:43,200
powerful in development right we've all

00:30:41,380 --> 00:30:46,060
seen that where if you work with

00:30:43,200 --> 00:30:48,520
snapshot databases the traditional way

00:30:46,060 --> 00:30:51,010
sometimes you stumble into issues where

00:30:48,520 --> 00:30:53,440
all of a sudden a particular field in

00:30:51,010 --> 00:30:55,660
your database or maybe the output on

00:30:53,440 --> 00:30:57,820
screen you know that a customer reports

00:30:55,660 --> 00:31:00,670
to you is not what you expect it to be

00:30:57,820 --> 00:31:02,230
right and then you trace it and you find

00:31:00,670 --> 00:31:04,420
oh yeah well there's a value in the

00:31:02,230 --> 00:31:05,920
database that's actually wrong but the

00:31:04,420 --> 00:31:08,320
problem is you have no idea how that got

00:31:05,920 --> 00:31:09,880
there in the first place right you even

00:31:08,320 --> 00:31:11,740
don't know when it got there in

00:31:09,880 --> 00:31:14,260
first place you might be able to look at

00:31:11,740 --> 00:31:16,870
some more backups to find you know when

00:31:14,260 --> 00:31:18,790
did this first creep in or something but

00:31:16,870 --> 00:31:20,950
then that's often the end of the story

00:31:18,790 --> 00:31:23,380
you know because you don't know the

00:31:20,950 --> 00:31:25,840
state of everything else in the system

00:31:23,380 --> 00:31:28,810
at that precise point in time and there

00:31:25,840 --> 00:31:31,480
are frequently some pretty severe limits

00:31:28,810 --> 00:31:34,000
to how much you can debug on that basis

00:31:31,480 --> 00:31:36,790
right well in an event sourcing system

00:31:34,000 --> 00:31:41,470
the data that is in your read models is

00:31:36,790 --> 00:31:43,480
only derived from the event store and as

00:31:41,470 --> 00:31:46,090
a result you can recreate it at any

00:31:43,480 --> 00:31:48,520
point in time you like you can work from

00:31:46,090 --> 00:31:50,830
a backup of course if you like so you

00:31:48,520 --> 00:31:53,170
don't always have to replay the entire

00:31:50,830 --> 00:31:55,510
event store you might be able to work

00:31:53,170 --> 00:31:58,450
from some sort of a persistent state

00:31:55,510 --> 00:32:01,990
where where the reidmar was still intact

00:31:58,450 --> 00:32:04,300
right perhaps and as a result you have a

00:32:01,990 --> 00:32:09,010
much more stable and extensible system

00:32:04,300 --> 00:32:11,230
in that okay now let's see I think I

00:32:09,010 --> 00:32:13,690
have a diagram in year and this kind of

00:32:11,230 --> 00:32:15,730
drives home the whole points about the

00:32:13,690 --> 00:32:18,370
read models that I've only made

00:32:15,730 --> 00:32:20,050
partially so far so those of you in my

00:32:18,370 --> 00:32:22,740
workshop yesterday have already seen

00:32:20,050 --> 00:32:26,530
this fantastic result of my drawing

00:32:22,740 --> 00:32:28,510
skills okay so in this case here we've

00:32:26,530 --> 00:32:30,760
got the smiling client at the top right

00:32:28,510 --> 00:32:33,580
there in actual fact I've also included

00:32:30,760 --> 00:32:36,310
a web server there on the left hand side

00:32:33,580 --> 00:32:38,320
I think the the picture looks sort of a

00:32:36,310 --> 00:32:40,300
bit grainy I must be running a funny

00:32:38,320 --> 00:32:42,670
resolution or something I hope you are

00:32:40,300 --> 00:32:44,950
mostly able to see what I'm trying to

00:32:42,670 --> 00:32:47,170
explain you so the client is in the

00:32:44,950 --> 00:32:49,960
middle at the top it accesses a web

00:32:47,170 --> 00:32:52,570
application perhaps from a web server

00:32:49,960 --> 00:32:54,970
perhaps some other way right they the

00:32:52,570 --> 00:32:57,370
web application might be deployed to the

00:32:54,970 --> 00:32:58,750
client through an app store or something

00:32:57,370 --> 00:33:01,060
like that of course it doesn't really

00:32:58,750 --> 00:33:04,180
matter how the application gets to the

00:33:01,060 --> 00:33:07,120
client and now the client can send

00:33:04,180 --> 00:33:09,040
commands to this cloud thing down here

00:33:07,120 --> 00:33:11,380
in the bottom left corner right that is

00:33:09,040 --> 00:33:13,120
the command processor that's what it

00:33:11,380 --> 00:33:14,920
says in there in case somebody in the

00:33:13,120 --> 00:33:17,440
back can't read it command processor

00:33:14,920 --> 00:33:18,820
cloud in the bottom left ok so that's

00:33:17,440 --> 00:33:21,160
the thing that we've already talked

00:33:18,820 --> 00:33:23,830
about the command processor takes the

00:33:21,160 --> 00:33:26,680
command performs a bit of validation

00:33:23,830 --> 00:33:28,360
puts it in the event store and then and

00:33:26,680 --> 00:33:31,800
this is the part we haven't mentioned so

00:33:28,360 --> 00:33:35,080
far the command processor also goes and

00:33:31,800 --> 00:33:38,140
publishes the event that has been

00:33:35,080 --> 00:33:40,720
created as a result of the command to

00:33:38,140 --> 00:33:43,180
the rest of the system it just kind of

00:33:40,720 --> 00:33:44,860
throws it up in the air yeah mostly it's

00:33:43,180 --> 00:33:47,980
done that way at least so of course you

00:33:44,860 --> 00:33:50,200
could be more dedicated to who you send

00:33:47,980 --> 00:33:52,030
it to or that kind of thing but in

00:33:50,200 --> 00:33:54,730
reality most of the time it's perfectly

00:33:52,030 --> 00:33:56,680
fine to just put it out to everybody and

00:33:54,730 --> 00:33:59,500
in the middle there you see I've put

00:33:56,680 --> 00:34:02,140
this message queue or event bus hub

00:33:59,500 --> 00:34:03,970
thing in there right it totally doesn't

00:34:02,140 --> 00:34:05,830
matter it's a logical thing right it's

00:34:03,970 --> 00:34:08,890
just meant to say we have some kind of a

00:34:05,830 --> 00:34:10,600
communications bus at this point so if

00:34:08,890 --> 00:34:13,360
the event has been published by the

00:34:10,600 --> 00:34:15,610
command processor the idea is that the

00:34:13,360 --> 00:34:17,260
other remaining entities there are three

00:34:15,610 --> 00:34:19,990
of them here as an example the other

00:34:17,260 --> 00:34:23,290
cloudy bits yeah they could if they

00:34:19,990 --> 00:34:25,990
wanted to receive those events and then

00:34:23,290 --> 00:34:28,660
of course react to them in some way and

00:34:25,990 --> 00:34:31,179
this is the role of the read models in

00:34:28,660 --> 00:34:33,730
your system right so the read models are

00:34:31,179 --> 00:34:36,190
basically services in their own right

00:34:33,730 --> 00:34:38,560
sometimes you might combine them so you

00:34:36,190 --> 00:34:41,140
have one service that takes care of

00:34:38,560 --> 00:34:43,270
running several individual read models

00:34:41,140 --> 00:34:45,270
perhaps right so that's again not set in

00:34:43,270 --> 00:34:48,190
stone but you have individual

00:34:45,270 --> 00:34:51,090
responsible entities in there and their

00:34:48,190 --> 00:34:54,370
responsibility is to receive events

00:34:51,090 --> 00:34:56,169
usually do some sort of filtering on the

00:34:54,370 --> 00:34:57,370
events in other words they find out

00:34:56,169 --> 00:34:59,410
which of the events are actually

00:34:57,370 --> 00:35:03,010
relevant you know to the task at hand

00:34:59,410 --> 00:35:05,680
and then the read model performs some

00:35:03,010 --> 00:35:08,200
kind of persistence usually right in

00:35:05,680 --> 00:35:11,050
order to remember some of the

00:35:08,200 --> 00:35:13,990
information just that information which

00:35:11,050 --> 00:35:16,210
is relevant to the job right so if you

00:35:13,990 --> 00:35:19,570
have a read morrow that is you know made

00:35:16,210 --> 00:35:21,280
for the handling of your customer died

00:35:19,570 --> 00:35:23,770
of since we've been talking about these

00:35:21,280 --> 00:35:25,780
examples with customers a lot here then

00:35:23,770 --> 00:35:28,390
you would probably have some kind of

00:35:25,780 --> 00:35:30,640
read model that returns an overview of

00:35:28,390 --> 00:35:33,370
the customers that are already in your

00:35:30,640 --> 00:35:35,770
system such overviews will mostly have a

00:35:33,370 --> 00:35:38,040
limited set of fields right you probably

00:35:35,770 --> 00:35:40,380
don't need or the many that you have

00:35:38,040 --> 00:35:42,210
system in that overview there might be

00:35:40,380 --> 00:35:45,210
some reed models for the purpose of

00:35:42,210 --> 00:35:48,810
editing the customers possibly there are

00:35:45,210 --> 00:35:50,940
there's more than one mode of editing a

00:35:48,810 --> 00:35:54,480
customer might be able to go into the

00:35:50,940 --> 00:35:56,850
system him or herself to edit their own

00:35:54,480 --> 00:35:58,950
data and on the other hand there might

00:35:56,850 --> 00:36:01,320
be back-office employees who can also

00:35:58,950 --> 00:36:03,960
edit the customer but their view is not

00:36:01,320 --> 00:36:06,270
exactly the same as the customers right

00:36:03,960 --> 00:36:08,760
so there might be different ones and

00:36:06,270 --> 00:36:11,130
that's what they combine so that is why

00:36:08,760 --> 00:36:11,610
each of those clouds in the picture

00:36:11,130 --> 00:36:14,430
right there

00:36:11,610 --> 00:36:17,340
have their own debris symbol database

00:36:14,430 --> 00:36:21,660
storage in other words right so each of

00:36:17,340 --> 00:36:24,030
those Services stores its own snapshot

00:36:21,660 --> 00:36:27,870
of whatever current information it has

00:36:24,030 --> 00:36:29,940
for its own purposes finally the client

00:36:27,870 --> 00:36:31,980
I haven't mentioned that so far there

00:36:29,940 --> 00:36:35,010
are several black arrow was saying load

00:36:31,980 --> 00:36:37,440
data the client will be able to load

00:36:35,010 --> 00:36:40,170
information from these different read

00:36:37,440 --> 00:36:41,940
models right of course the client will

00:36:40,170 --> 00:36:44,640
always kind of have to know how to

00:36:41,940 --> 00:36:47,130
contact the read models and so on right

00:36:44,640 --> 00:36:49,170
so this is not a technical diagram you

00:36:47,130 --> 00:36:51,780
might have some extra infrastructure in

00:36:49,170 --> 00:36:54,750
between perhaps some sort of a proxy

00:36:51,780 --> 00:36:58,080
service that allows the client to easily

00:36:54,750 --> 00:37:00,420
contact any one of the read models by

00:36:58,080 --> 00:37:04,410
name or something instead of having to

00:37:00,420 --> 00:37:05,820
to use their IP addresses in some

00:37:04,410 --> 00:37:08,040
systems you might actually have

00:37:05,820 --> 00:37:10,710
different communication channels so it's

00:37:08,040 --> 00:37:13,770
easy enough to imagine the endpoints to

00:37:10,710 --> 00:37:15,960
work through HTTP right but at the same

00:37:13,770 --> 00:37:19,650
time maybe you would also like other

00:37:15,960 --> 00:37:22,350
access points for internal use like the

00:37:19,650 --> 00:37:25,080
ability to contact a read model through

00:37:22,350 --> 00:37:27,240
a through the message queue as an

00:37:25,080 --> 00:37:29,430
example right or whichever way you want

00:37:27,240 --> 00:37:31,590
really so again this is not a technical

00:37:29,430 --> 00:37:34,560
diagram it's more of a logical diagram

00:37:31,590 --> 00:37:37,440
the different communication paths that

00:37:34,560 --> 00:37:39,630
we have so that's the idea we've got the

00:37:37,440 --> 00:37:41,820
command processor for the command part

00:37:39,630 --> 00:37:43,830
we've got the read models for the read

00:37:41,820 --> 00:37:47,750
part and we've got this event

00:37:43,830 --> 00:37:51,890
coordinated system for data pass-through

00:37:47,750 --> 00:37:51,890
in the middle of it

00:37:52,099 --> 00:37:58,320
now using the example from my workshop

00:37:55,770 --> 00:38:01,050
yesterday I'm going to illustrate that

00:37:58,320 --> 00:38:02,849
to you as well let me just see here

00:38:01,050 --> 00:38:06,109
because I'm not sure if we've got a good

00:38:02,849 --> 00:38:10,140
resolution for me to be throwing this

00:38:06,109 --> 00:38:13,890
hang on now this is now not entirely the

00:38:10,140 --> 00:38:15,570
right thing anyway sorry uh that was

00:38:13,890 --> 00:38:23,790
probably because I didn't get round to

00:38:15,570 --> 00:38:28,020
doing it previously due to the oh right

00:38:23,790 --> 00:38:29,300
okay that's fine then let's just use

00:38:28,020 --> 00:38:32,070
this one

00:38:29,300 --> 00:38:36,599
due to the display issues that we had I

00:38:32,070 --> 00:38:39,240
was going to say okay so can you guys

00:38:36,599 --> 00:38:42,420
more or less read the code that is

00:38:39,240 --> 00:38:43,140
coming up here in the back is it too

00:38:42,420 --> 00:38:45,150
small should

00:38:43,140 --> 00:38:49,290
okay I see thumbs up that's excellent

00:38:45,150 --> 00:38:50,550
okay right so well I don't actually know

00:38:49,290 --> 00:38:52,530
if we're gonna have a look at much of

00:38:50,550 --> 00:38:54,750
this code now that I think about it what

00:38:52,530 --> 00:38:56,790
I mainly want to look at really is what

00:38:54,750 --> 00:39:00,839
happens here in the system so let me

00:38:56,790 --> 00:39:03,300
bring up some logs here these are the

00:39:00,839 --> 00:39:05,040
logs of the running system or they

00:39:03,300 --> 00:39:08,849
should be at least nothing's happening

00:39:05,040 --> 00:39:10,650
oh right Oh fair enough that's

00:39:08,849 --> 00:39:13,109
interesting the system isn't actually

00:39:10,650 --> 00:39:16,740
running anyway fantastic there's nothing

00:39:13,109 --> 00:39:24,000
like a few things going wrong so let's

00:39:16,740 --> 00:39:27,780
kill this again I can also while I'm at

00:39:24,000 --> 00:39:32,310
it go to the correct project that I was

00:39:27,780 --> 00:39:37,200
actually going to use now I'm realizing

00:39:32,310 --> 00:39:40,170
that probably I forgot in all the hassle

00:39:37,200 --> 00:39:43,710
that I need to run a MongoDB instance in

00:39:40,170 --> 00:39:45,900
the background here and start the

00:39:43,710 --> 00:39:48,060
project again okay yeah

00:39:45,900 --> 00:39:50,430
now the front-end application is the

00:39:48,060 --> 00:39:54,240
react one it usually takes a little

00:39:50,430 --> 00:39:56,369
while on my on my little Chromebook here

00:39:54,240 --> 00:39:59,250
to actually come up so we'll have to

00:39:56,369 --> 00:40:01,470
wait for that that's why I started it

00:39:59,250 --> 00:40:05,580
before we began here but that didn't

00:40:01,470 --> 00:40:08,550
help clearly so okay let's see here

00:40:05,580 --> 00:40:20,609
we've got the application hopefully oh

00:40:08,550 --> 00:40:23,070
yeah okay presentation um appears to be

00:40:20,609 --> 00:40:25,080
something wrong though but I don't think

00:40:23,070 --> 00:40:28,020
it's actually started even has it

00:40:25,080 --> 00:40:29,849
starting the development so uh no I

00:40:28,020 --> 00:40:31,920
don't think it's really started I think

00:40:29,849 --> 00:40:33,960
this is just the browser having some fun

00:40:31,920 --> 00:40:36,510
there with yesterday's cached version or

00:40:33,960 --> 00:40:38,940
something like that the react

00:40:36,510 --> 00:40:40,980
development server takes quite an

00:40:38,940 --> 00:40:42,900
impressively long time on my little

00:40:40,980 --> 00:40:44,880
Chromebook here to come up I don't know

00:40:42,900 --> 00:40:47,599
why really because it is reasonably fast

00:40:44,880 --> 00:40:51,349
almost all the time otherwise but this

00:40:47,599 --> 00:40:55,670
development server takes a long time

00:40:51,349 --> 00:40:55,670
well it should be there any moment now

00:40:59,630 --> 00:41:10,940
somebody no joke come on no you can't

00:41:08,670 --> 00:41:12,210
make a JavaScript joke if you like yes

00:41:10,940 --> 00:41:15,810
absolutely

00:41:12,210 --> 00:41:16,380
oh yeah we are okay finally right

00:41:15,810 --> 00:41:18,570
excellent

00:41:16,380 --> 00:41:20,339
so this should bring up the actual

00:41:18,570 --> 00:41:21,930
application now there we go there isn't

00:41:20,339 --> 00:41:25,380
any data in it right at the moment

00:41:21,930 --> 00:41:27,180
because I restarted my docker and

00:41:25,380 --> 00:41:30,480
image that I was running locally here

00:41:27,180 --> 00:41:32,460
yesterday now this is a very simple

00:41:30,480 --> 00:41:34,650
thing really there are two views in this

00:41:32,460 --> 00:41:36,420
application here to show me customers

00:41:34,650 --> 00:41:38,400
and their orders right nothing much

00:41:36,420 --> 00:41:40,349
exciting in there and we're not going to

00:41:38,400 --> 00:41:42,330
go into this in great detail I've got a

00:41:40,349 --> 00:41:45,420
link on my slides for you guys to look

00:41:42,330 --> 00:41:48,470
at the demo yourself if you like however

00:41:45,420 --> 00:41:52,200
the point at this stage really is only

00:41:48,470 --> 00:41:54,450
what we see in here now let me try to

00:41:52,200 --> 00:41:55,830
make this a bit bigger here why is it

00:41:54,450 --> 00:42:00,150
not making it bigger what am I doing

00:41:55,830 --> 00:42:03,180
wrong now ah here we go bigger right so

00:42:00,150 --> 00:42:05,670
can you see the the text in the log

00:42:03,180 --> 00:42:08,099
window I suppose yeah okay more thumbs

00:42:05,670 --> 00:42:11,010
up fantastic so the point of the host is

00:42:08,099 --> 00:42:13,440
the whole exercise is I will trigger an

00:42:11,010 --> 00:42:16,410
operation in here through my front-end

00:42:13,440 --> 00:42:17,940
application okay so I call this all EE

00:42:16,410 --> 00:42:20,700
which I always do cuz that's

00:42:17,940 --> 00:42:24,210
me and I live in Scotland so let's enter

00:42:20,700 --> 00:42:27,060
that and now I hit save and then we can

00:42:24,210 --> 00:42:28,589
see what happens in the back end as a

00:42:27,060 --> 00:42:31,050
result yeah here we are

00:42:28,589 --> 00:42:32,819
I'm back in the ListView right now and

00:42:31,050 --> 00:42:35,520
this is just a demo thing so it only

00:42:32,819 --> 00:42:38,400
turtle shows me the newly created ID and

00:42:35,520 --> 00:42:41,010
my own name here and we can now see in

00:42:38,400 --> 00:42:42,569
the log window here what actually

00:42:41,010 --> 00:42:45,240
happened in the background now let me

00:42:42,569 --> 00:42:48,329
see where this begins it begins here

00:42:45,240 --> 00:42:51,990
where it says a service called command

00:42:48,329 --> 00:42:54,359
processor in my system has received a

00:42:51,990 --> 00:42:56,460
command this is the command that came in

00:42:54,359 --> 00:42:58,920
I've described this to you before right

00:42:56,460 --> 00:43:01,260
so here it is now it says we have an

00:42:58,920 --> 00:43:03,450
aggregate named customer we have an

00:43:01,260 --> 00:43:05,880
aggregate ID this is just a newly

00:43:03,450 --> 00:43:08,430
generated UUID value that has been

00:43:05,880 --> 00:43:10,859
associated and we have a command the

00:43:08,430 --> 00:43:13,200
command is called create and then there

00:43:10,859 --> 00:43:15,810
is a payload and the payload basically

00:43:13,200 --> 00:43:18,030
has or the details that I entered so in

00:43:15,810 --> 00:43:21,569
this case you know my location and name

00:43:18,030 --> 00:43:23,880
information now as a result of this the

00:43:21,569 --> 00:43:27,270
command processor generates an event

00:43:23,880 --> 00:43:29,250
here it is and that event is almost the

00:43:27,270 --> 00:43:32,910
same just with a slightly different

00:43:29,250 --> 00:43:35,579
structure really to the as the command

00:43:32,910 --> 00:43:38,760
that is quite common really as long as

00:43:35,579 --> 00:43:40,980
the validation succeeds your events will

00:43:38,760 --> 00:43:45,089
usually be quite similar to the commands

00:43:40,980 --> 00:43:47,760
ok and then what happens is we publish

00:43:45,089 --> 00:43:50,609
the event here which means that it is

00:43:47,760 --> 00:43:53,790
basically sent to the communications bus

00:43:50,609 --> 00:43:56,160
here in my system that is based on 0 mq

00:43:53,790 --> 00:43:59,010
as a message queue but could be anything

00:43:56,160 --> 00:44:00,960
like that and then here we have the read

00:43:59,010 --> 00:44:02,970
model or one of them there are actually

00:44:00,960 --> 00:44:03,660
two read models this one is the first

00:44:02,970 --> 00:44:06,510
one called

00:44:03,660 --> 00:44:09,510
orders that says we have received this

00:44:06,510 --> 00:44:11,040
message with the event and the customers

00:44:09,510 --> 00:44:13,140
read morrow comes along shortly

00:44:11,040 --> 00:44:16,290
afterwards and has also received this

00:44:13,140 --> 00:44:19,500
thing and then we're projecting these

00:44:16,290 --> 00:44:22,800
events to particular read models right

00:44:19,500 --> 00:44:26,130
so the customers read more service here

00:44:22,800 --> 00:44:28,619
actually encapsulated two separate read

00:44:26,130 --> 00:44:30,440
models called overview and editing and

00:44:28,619 --> 00:44:33,190
both of them

00:44:30,440 --> 00:44:35,720
an interest in this particular event

00:44:33,190 --> 00:44:38,300
customer created right

00:44:35,720 --> 00:44:40,430
not every read model in your system of

00:44:38,300 --> 00:44:42,770
course will actually be interested in an

00:44:40,430 --> 00:44:45,109
event about creation of customers right

00:44:42,770 --> 00:44:47,480
so you have to distinguish that and only

00:44:45,109 --> 00:44:50,270
the ones that have handlers for this

00:44:47,480 --> 00:44:52,880
particular event will then be called for

00:44:50,270 --> 00:44:55,069
projection and here it says we're

00:44:52,880 --> 00:44:57,230
projecting those events this is the end

00:44:55,069 --> 00:44:59,210
of the commands yeah there's a bit more

00:44:57,230 --> 00:45:01,550
in here because I've also got automatic

00:44:59,210 --> 00:45:03,380
change notification in the system here

00:45:01,550 --> 00:45:05,540
and that kind of stuff I'm not going to

00:45:03,380 --> 00:45:07,940
go into that but you can feel free to

00:45:05,540 --> 00:45:10,880
check that out if you like right so this

00:45:07,940 --> 00:45:12,980
is the sequence that I was describing I

00:45:10,880 --> 00:45:17,210
could also show you just quickly let's

00:45:12,980 --> 00:45:20,660
do docker PS if I'm doing docker X sick

00:45:17,210 --> 00:45:23,150
and go in there now what's my number

00:45:20,660 --> 00:45:26,500
here that will be 30 I I think here we

00:45:23,150 --> 00:45:29,240
go so now I'm in show databases

00:45:26,500 --> 00:45:31,280
we've got the read model and the event

00:45:29,240 --> 00:45:34,190
databases and everything in there so if

00:45:31,280 --> 00:45:38,210
I do use events and then we do DB events

00:45:34,190 --> 00:45:40,040
find find even I can't type find as it

00:45:38,210 --> 00:45:42,470
turns out there we go so this is the

00:45:40,040 --> 00:45:44,569
event just one of them that has made it

00:45:42,470 --> 00:45:47,000
into my events store and there's a

00:45:44,569 --> 00:45:49,690
separate database I mean but of course

00:45:47,000 --> 00:45:53,900
now I'm doing CD yeah that makes sense

00:45:49,690 --> 00:45:55,670
of course you know since we're on a

00:45:53,900 --> 00:45:57,740
development machine I'm basically

00:45:55,670 --> 00:46:00,020
running all the processes against the

00:45:57,740 --> 00:46:02,540
same database server right in reality

00:46:00,020 --> 00:46:05,030
they might be separate of course but at

00:46:02,540 --> 00:46:07,700
least I'm using separate databases so it

00:46:05,030 --> 00:46:10,040
is as close as it could be really to the

00:46:07,700 --> 00:46:12,530
real thing right there okay so now we

00:46:10,040 --> 00:46:15,650
have the overview read model which is

00:46:12,530 --> 00:46:17,990
the one that we also see in the UI right

00:46:15,650 --> 00:46:20,349
overview and here's that one piece of

00:46:17,990 --> 00:46:23,450
information for Olly you might note that

00:46:20,349 --> 00:46:25,910
the overview read model does not contain

00:46:23,450 --> 00:46:28,280
the location right I decided to leave it

00:46:25,910 --> 00:46:31,609
out just as an example okay so there is

00:46:28,280 --> 00:46:34,609
actually information associated with the

00:46:31,609 --> 00:46:36,920
user that is not part of the overview

00:46:34,609 --> 00:46:40,069
read model but there is a separate read

00:46:36,920 --> 00:46:42,650
model for editing so if I do DB editing

00:46:40,069 --> 00:46:44,269
find you will see that in there that

00:46:42,650 --> 00:46:46,849
location is included

00:46:44,269 --> 00:46:48,589
all right so for editing purposes if I'm

00:46:46,849 --> 00:46:50,989
going to edit this user Ollie

00:46:48,589 --> 00:46:54,049
here's the Scotland that I entered right

00:46:50,989 --> 00:46:56,599
but it is not part of the overview read

00:46:54,049 --> 00:46:58,849
more I mean this is only an example but

00:46:56,599 --> 00:47:00,889
it's a it's a very common scenario that

00:46:58,849 --> 00:47:02,899
you have different read models for these

00:47:00,889 --> 00:47:05,599
different purposes of showing data

00:47:02,899 --> 00:47:09,169
versus editing it possibly showing it in

00:47:05,599 --> 00:47:11,809
different ways and so on okay all right

00:47:09,169 --> 00:47:14,359
where we've got five minutes to go so we

00:47:11,809 --> 00:47:19,339
must continue with a few final words

00:47:14,359 --> 00:47:23,719
here well I have a few words on when to

00:47:19,339 --> 00:47:25,879
use event sourcing I am mentioning in

00:47:23,719 --> 00:47:28,909
that that of course event sourcing does

00:47:25,879 --> 00:47:31,969
have a certain complexity it is actually

00:47:28,909 --> 00:47:35,809
a complexity in my experience that is

00:47:31,969 --> 00:47:38,569
very easy and actually a lot of fun to

00:47:35,809 --> 00:47:40,579
get used to right so I'm not gonna say

00:47:38,569 --> 00:47:43,429
that that the complexity should be a

00:47:40,579 --> 00:47:45,619
reason to not consider event sourcing

00:47:43,429 --> 00:47:48,169
almost anywhere I personally I

00:47:45,619 --> 00:47:51,219
personally think that the upsides of

00:47:48,169 --> 00:47:55,099
this of this model are are great right

00:47:51,219 --> 00:47:57,919
even for for a developer trying to

00:47:55,099 --> 00:48:00,409
analyze your own system while you

00:47:57,919 --> 00:48:03,619
develop it finding issues with it

00:48:00,409 --> 00:48:06,019
tracking down behavioral problems making

00:48:03,619 --> 00:48:08,929
extensions after the fact and all that

00:48:06,019 --> 00:48:11,419
kind of stuff comes very easily in an

00:48:08,929 --> 00:48:13,369
event sourcing system so there is

00:48:11,419 --> 00:48:15,439
complexity with the messages the

00:48:13,369 --> 00:48:17,059
commands you send the events and so on

00:48:15,439 --> 00:48:20,689
that's a bit of an architectural

00:48:17,059 --> 00:48:23,089
complexity perhaps but that's not really

00:48:20,689 --> 00:48:26,139
hard to manage and it is very worthwhile

00:48:23,089 --> 00:48:29,509
so for those reasons I would generally

00:48:26,139 --> 00:48:33,619
suggest checking out event sourcing as a

00:48:29,509 --> 00:48:36,139
pattern I think that that is generally a

00:48:33,619 --> 00:48:38,659
good recommendation of course there are

00:48:36,139 --> 00:48:41,209
perhaps scenarios highly highly

00:48:38,659 --> 00:48:44,139
monolithic applications where you really

00:48:41,209 --> 00:48:47,509
just don't care about the aspects of

00:48:44,139 --> 00:48:49,429
possibly scaling individual bits of your

00:48:47,509 --> 00:48:51,369
application and all that kind of stuff

00:48:49,429 --> 00:48:55,069
but even then you can still benefit from

00:48:51,369 --> 00:48:57,589
the from the developer advantages as

00:48:55,069 --> 00:48:57,890
well and the maintenance advantages that

00:48:57,589 --> 00:49:00,560
you

00:48:57,890 --> 00:49:04,970
in the longer term so that's a good idea

00:49:00,560 --> 00:49:08,360
now um okay I think the how we have

00:49:04,970 --> 00:49:10,280
really seen most of it because of that

00:49:08,360 --> 00:49:12,770
diagram I showed you I don't think there

00:49:10,280 --> 00:49:15,680
is anything much more in there I do

00:49:12,770 --> 00:49:18,200
recommend is using existing libraries of

00:49:15,680 --> 00:49:19,970
course oh I think this was out of place

00:49:18,200 --> 00:49:22,670
in here I'm afraid here we go

00:49:19,970 --> 00:49:24,530
and the one item that I would like to

00:49:22,670 --> 00:49:27,020
talk a bit about in the last few minutes

00:49:24,530 --> 00:49:29,120
we have unfortunately is eventual

00:49:27,020 --> 00:49:30,850
consistency I was meaning to possibly

00:49:29,120 --> 00:49:34,190
have a little more time for that

00:49:30,850 --> 00:49:36,440
basically the eventual consistency is

00:49:34,190 --> 00:49:38,420
what automatically happens in the system

00:49:36,440 --> 00:49:40,190
that I've described here with event

00:49:38,420 --> 00:49:43,550
sourcing for the simple reason that

00:49:40,190 --> 00:49:45,620
there is a split even in CQRS by itself

00:49:43,550 --> 00:49:47,680
not not just with event sourcing even

00:49:45,620 --> 00:49:50,540
there is a split in your timeline

00:49:47,680 --> 00:49:53,570
between the point a command is sent to

00:49:50,540 --> 00:49:55,670
the command processor and the point in

00:49:53,570 --> 00:49:58,850
time where a read model potentially

00:49:55,670 --> 00:50:00,440
reflects the relation updates right that

00:49:58,850 --> 00:50:02,780
is logically the case and this is

00:50:00,440 --> 00:50:04,790
entirely separate and of course it is

00:50:02,780 --> 00:50:07,520
meant to be separate right it is meant

00:50:04,790 --> 00:50:10,270
to be decoupled and everything so you

00:50:07,520 --> 00:50:14,060
couldn't easily drop some kind of

00:50:10,270 --> 00:50:16,790
distributed transaction system on top of

00:50:14,060 --> 00:50:18,800
it in order to gain strong consistency

00:50:16,790 --> 00:50:21,680
then you would also lose all the

00:50:18,800 --> 00:50:24,350
advantages of it right so eventual

00:50:21,680 --> 00:50:26,630
consistency is a logical consequence and

00:50:24,350 --> 00:50:28,580
I always like to stress for the Germans

00:50:26,630 --> 00:50:32,000
of course that eventual does not mean

00:50:28,580 --> 00:50:34,400
event well okay eventual means let's end

00:50:32,000 --> 00:50:36,530
Lee so that doesn't mean maybe it's

00:50:34,400 --> 00:50:39,580
consistent and maybe it isn't right like

00:50:36,530 --> 00:50:42,740
some people like to joke I know that but

00:50:39,580 --> 00:50:44,630
it means in the end it'll be consistent

00:50:42,740 --> 00:50:47,630
and this is actually a system that you

00:50:44,630 --> 00:50:50,120
find in real life quite a lot I

00:50:47,630 --> 00:50:52,700
personally like some examples about it

00:50:50,120 --> 00:50:55,100
for instance the Starbucks analogy right

00:50:52,700 --> 00:50:57,320
where you walk into Starbucks to order a

00:50:55,100 --> 00:50:59,180
coffee and they actually ask you before

00:50:57,320 --> 00:51:00,830
you're even at the counter what your

00:50:59,180 --> 00:51:02,930
coffee you want and they pass it around

00:51:00,830 --> 00:51:05,300
between five different people you know

00:51:02,930 --> 00:51:07,070
those barri star people at the coffee

00:51:05,300 --> 00:51:09,410
machine and all that kind of stuff and

00:51:07,070 --> 00:51:11,450
when you come to the checkout desk you

00:51:09,410 --> 00:51:13,340
pay for a coffee but it's not necessary

00:51:11,450 --> 00:51:15,500
you actually ordered in the first place

00:51:13,340 --> 00:51:17,180
right and then you go to wait for your

00:51:15,500 --> 00:51:18,980
coffee at the end of the line and you

00:51:17,180 --> 00:51:21,020
pick up a coffee and if you don't like

00:51:18,980 --> 00:51:23,090
it you just pour it over the guy's head

00:51:21,020 --> 00:51:25,130
and make him make you new one right and

00:51:23,090 --> 00:51:27,830
that's not exactly the coffee you might

00:51:25,130 --> 00:51:30,080
have ordered or paid for right because

00:51:27,830 --> 00:51:31,790
Starbucks basically guarantees that you

00:51:30,080 --> 00:51:33,500
walk out of the place happy alright

00:51:31,790 --> 00:51:35,870
that's the idea they want you to walk

00:51:33,500 --> 00:51:38,840
away happy with the product you received

00:51:35,870 --> 00:51:40,550
and they want of course to receive some

00:51:38,840 --> 00:51:43,040
money for it but it's clearly not very

00:51:40,550 --> 00:51:45,290
important to them that that is actually

00:51:43,040 --> 00:51:47,450
the money precisely for the product you

00:51:45,290 --> 00:51:50,020
walked out of the shop with right that's

00:51:47,450 --> 00:51:52,520
eventual consistency what they sell is

00:51:50,020 --> 00:51:55,340
customer happiness right basically

00:51:52,520 --> 00:51:58,250
that's it and that is eventual

00:51:55,340 --> 00:52:01,700
consistency it is achieved by means of

00:51:58,250 --> 00:52:03,980
equalizing transactions so if something

00:52:01,700 --> 00:52:06,040
goes wrong in this train let's say you

00:52:03,980 --> 00:52:08,840
know you're not actually trying to

00:52:06,040 --> 00:52:09,920
mistreat the process but you are just

00:52:08,840 --> 00:52:11,810
trying to get your coffee

00:52:09,920 --> 00:52:13,490
in that case things could go wrong

00:52:11,810 --> 00:52:15,710
somebody could pass on the wrong

00:52:13,490 --> 00:52:18,830
information perhaps whatever and they

00:52:15,710 --> 00:52:20,540
make good on that by simply apologizing

00:52:18,830 --> 00:52:22,130
to you and giving you an extra priority

00:52:20,540 --> 00:52:25,190
if you like alright that kind of thing

00:52:22,130 --> 00:52:27,350
so they they equalize and that's exactly

00:52:25,190 --> 00:52:29,990
what happens elsewhere as well if you

00:52:27,350 --> 00:52:31,550
order something at Amazon and it turns

00:52:29,990 --> 00:52:33,320
out they don't happen to have the

00:52:31,550 --> 00:52:35,150
product in the end then they might end

00:52:33,320 --> 00:52:37,130
up apologizing and giving you a voucher

00:52:35,150 --> 00:52:37,580
or something perhaps you know that kind

00:52:37,130 --> 00:52:40,700
of thing

00:52:37,580 --> 00:52:42,380
so these mechanisms are used and

00:52:40,700 --> 00:52:46,550
unfortunately we're running out of time

00:52:42,380 --> 00:52:48,320
I can recommend to you that's not my

00:52:46,550 --> 00:52:50,630
fault today that we're running over the

00:52:48,320 --> 00:52:54,650
snoo I've got this little diagram in

00:52:50,630 --> 00:52:56,990
here for the cap theorem which kind of

00:52:54,650 --> 00:52:59,180
goes hand-in-hand with this idea that

00:52:56,990 --> 00:53:01,310
you can't always achieve or the

00:52:59,180 --> 00:53:04,090
different criteria of persistence

00:53:01,310 --> 00:53:06,320
systems that you would like to see so I

00:53:04,090 --> 00:53:08,120
recommend you check this out in some

00:53:06,320 --> 00:53:09,890
detail and hang on there should be a

00:53:08,120 --> 00:53:13,070
link here somewhere oh yeah the one here

00:53:09,890 --> 00:53:15,380
at the bottom is an interesting study

00:53:13,070 --> 00:53:17,660
but it reads quite fluently it's an

00:53:15,380 --> 00:53:19,820
interesting study on the idea of

00:53:17,660 --> 00:53:22,010
eventual consistency and there are some

00:53:19,820 --> 00:53:24,580
other examples in there for where

00:53:22,010 --> 00:53:27,760
eventual consistency is actually you

00:53:24,580 --> 00:53:29,920
in everyday life and in computer systems

00:53:27,760 --> 00:53:31,840
and even in those computer systems where

00:53:29,920 --> 00:53:33,640
you think we really need strong

00:53:31,840 --> 00:53:35,830
consistency right like whatever in

00:53:33,640 --> 00:53:38,170
banking or whatever as an example they

00:53:35,830 --> 00:53:40,420
they use eventual consistency all the

00:53:38,170 --> 00:53:43,330
time in banking so that's there's a lot

00:53:40,420 --> 00:53:45,340
more information there unfortunately due

00:53:43,330 --> 00:53:47,320
to our technical problems we didn't have

00:53:45,340 --> 00:53:50,740
those extra five or ten minutes so I

00:53:47,320 --> 00:53:53,380
will call it a day at this point this is

00:53:50,740 --> 00:53:55,090
the this is the source of the

00:53:53,380 --> 00:53:57,490
presentation here if you'd like to have

00:53:55,090 --> 00:53:59,650
a look at the slides yourself and the

00:53:57,490 --> 00:54:01,750
complete demo code of the sample I was

00:53:59,650 --> 00:54:06,130
showing you is available as well online

00:54:01,750 --> 00:54:07,720
and that's me done then um oh I'll let

00:54:06,130 --> 00:54:09,940
you take your pictures there fair enough

00:54:07,720 --> 00:54:11,770
thank you very much for being here and I

00:54:09,940 --> 00:54:12,390
hope you have a great conference thank

00:54:11,770 --> 00:54:13,810
you

00:54:12,390 --> 00:54:35,790
[Applause]

00:54:13,810 --> 00:54:35,790

YouTube URL: https://www.youtube.com/watch?v=Cq0Qal_atgY


