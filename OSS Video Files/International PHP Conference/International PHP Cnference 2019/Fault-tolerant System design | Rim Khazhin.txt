Title: Fault-tolerant System design | Rim Khazhin
Publication date: 2020-03-12
Playlist: International PHP Cnference 2019
Description: 
	Operating a high-load mobile application and its backend on a daily basis while continuously adding new features and preventing everything from collapsing is a difficult job. Numerous external services and APIs, continuous refactoring and system optimization makes this process even more error-prone.

We will overview internals of a an app with 13 million users worldwide processing over a million transactions per day. We will cover fault-tolerant system design guidelines with an emphasis on multi-fault tolerant systems. Author will share robust application development best practices and go through common mistakes with detailed explanations.

Speaker: Rim Khazhin (URAL Telekom) | https://phpconference.com/speaker/rim-khazhin/

🤗 Come, join us at the next International PHP Conference | https://phpconference.com/
👍 Like us on Facebook | https://www.facebook.com/ipc.germany/
👉 Follow us on Twitter | https://twitter.com/phpconference
Captions: 
	00:00:00,000 --> 00:00:07,440
[Music]

00:00:04,430 --> 00:00:09,000
so basically where my and why I'm

00:00:07,440 --> 00:00:13,710
talking about this

00:00:09,000 --> 00:00:16,650
my name is rim I'm a CTO at Ural telecom

00:00:13,710 --> 00:00:18,420
company previously I worked for

00:00:16,650 --> 00:00:22,820
fellating application with 14 million

00:00:18,420 --> 00:00:26,180
mobile users previous I also worked

00:00:22,820 --> 00:00:28,949
developing air traffic control systems

00:00:26,180 --> 00:00:31,289
mobile device management system for 15

00:00:28,949 --> 00:00:33,620
million devices and a National Space

00:00:31,289 --> 00:00:36,989
Research Center in Turkey

00:00:33,620 --> 00:00:39,960
I'm also underwater photographer I like

00:00:36,989 --> 00:00:47,280
shooting fish and models under the water

00:00:39,960 --> 00:00:49,320
under the sea so our company you know

00:00:47,280 --> 00:00:53,010
telecom is developing secure

00:00:49,320 --> 00:00:55,800
communication software also software

00:00:53,010 --> 00:00:58,309
refactoring for testability but that's

00:00:55,800 --> 00:01:02,699
about legacy systems also software

00:00:58,309 --> 00:01:05,369
performance optimization objectives of

00:01:02,699 --> 00:01:08,100
our today's talk are briefly

00:01:05,369 --> 00:01:10,500
fault-tolerant system design robust

00:01:08,100 --> 00:01:13,830
software design robust software

00:01:10,500 --> 00:01:16,080
development these are different parts

00:01:13,830 --> 00:01:20,549
because or one is the whole system

00:01:16,080 --> 00:01:22,380
design and the system should work the

00:01:20,549 --> 00:01:25,439
tech default and still work as expected

00:01:22,380 --> 00:01:28,259
and robust coding is more with the code

00:01:25,439 --> 00:01:30,930
itself how the code should be developed

00:01:28,259 --> 00:01:33,299
in order to be robust not to break a

00:01:30,930 --> 00:01:37,409
robust the difference is robust software

00:01:33,299 --> 00:01:39,150
should detect the error and display some

00:01:37,409 --> 00:01:41,159
notification but fault tolerance should

00:01:39,150 --> 00:01:43,860
not only detect but should continue

00:01:41,159 --> 00:01:45,659
working somehow that's the most

00:01:43,860 --> 00:01:47,250
difficult part and I will also present

00:01:45,659 --> 00:01:55,140
some tools and techniques how to achieve

00:01:47,250 --> 00:01:57,390
that 99% reliability so so what are the

00:01:55,140 --> 00:02:01,710
typical problems your application your

00:01:57,390 --> 00:02:04,799
API your web service or web application

00:02:01,710 --> 00:02:11,119
is facing can I see can I hear some

00:02:04,799 --> 00:02:11,119
examples please cool okay what else

00:02:11,550 --> 00:02:19,780
great invaluable is a reason but what's

00:02:16,720 --> 00:02:24,090
how do we how do we see from the user

00:02:19,780 --> 00:02:24,090
perspective how do we experience that

00:02:25,440 --> 00:02:31,180
crashes yeah so basically you're alright

00:02:29,380 --> 00:02:32,770
you do something and it's not doing

00:02:31,180 --> 00:02:36,130
other things as expected

00:02:32,770 --> 00:02:39,100
so basically unresponsive crashing some

00:02:36,130 --> 00:02:42,550
invalid or missing data inconsistent

00:02:39,100 --> 00:02:44,470
data or error messages like examples of

00:02:42,550 --> 00:02:47,050
course you know you click the button and

00:02:44,470 --> 00:02:49,450
it does it nothing happens or the all

00:02:47,050 --> 00:02:51,730
application is unresponsive you can do

00:02:49,450 --> 00:02:56,050
anything just it's waiting for something

00:02:51,730 --> 00:02:57,970
or inconsistent data for example you go

00:02:56,050 --> 00:02:59,950
to one screen edit one screen you see

00:02:57,970 --> 00:03:01,570
you have ten credits you go to a

00:02:59,950 --> 00:03:04,330
different screen and you see you have

00:03:01,570 --> 00:03:07,000
zero credits that's annoying so typical

00:03:04,330 --> 00:03:09,580
options for this is centralized

00:03:07,000 --> 00:03:11,320
management you manage the credits or ask

00:03:09,580 --> 00:03:14,590
for the credits from the single source

00:03:11,320 --> 00:03:17,050
not every page is asking server for my

00:03:14,590 --> 00:03:20,519
credits or any information but using a

00:03:17,050 --> 00:03:23,860
single class for managing that data and

00:03:20,519 --> 00:03:26,830
error messages sometimes you've seen

00:03:23,860 --> 00:03:28,870
that you go to a website and it shows an

00:03:26,830 --> 00:03:30,519
error then again it shows an error and

00:03:28,870 --> 00:03:33,850
you can't do anything just because of

00:03:30,519 --> 00:03:36,280
errors so you need to separate are these

00:03:33,850 --> 00:03:38,260
errors critical or are they just in

00:03:36,280 --> 00:03:41,019
optional informational errors for

00:03:38,260 --> 00:03:42,670
example I couldn't get advertisement

00:03:41,019 --> 00:03:45,970
information is that critical should I

00:03:42,670 --> 00:03:48,070
notify the user no I should just keep it

00:03:45,970 --> 00:03:50,140
silently okay no ads no ads okay no

00:03:48,070 --> 00:03:52,540
problem but what if that's critical

00:03:50,140 --> 00:03:54,250
information like I can't log in or the

00:03:52,540 --> 00:03:56,739
server connection failed okay I

00:03:54,250 --> 00:04:00,310
displayed that once should I show it

00:03:56,739 --> 00:04:02,050
every minute or every second no you can

00:04:00,310 --> 00:04:05,620
be more user friendly for that for

00:04:02,050 --> 00:04:07,810
example notify user and continue working

00:04:05,620 --> 00:04:10,750
at the background the app should still

00:04:07,810 --> 00:04:16,180
be response responsive and try to do its

00:04:10,750 --> 00:04:21,010
work and typical reliability problems

00:04:16,180 --> 00:04:24,530
are for example if the problem is if the

00:04:21,010 --> 00:04:26,780
system is 95 percent error free let's

00:04:24,530 --> 00:04:29,000
it's works but it's not that good

00:04:26,780 --> 00:04:31,970
because it loses you revenue it loses

00:04:29,000 --> 00:04:36,139
you users if you have 1 million users it

00:04:31,970 --> 00:04:38,180
means like 550 thousand users that are

00:04:36,139 --> 00:04:39,889
angry that are unhappy that are not

00:04:38,180 --> 00:04:43,610
using your application so you can show

00:04:39,889 --> 00:04:45,860
less ads less sales less revenue and if

00:04:43,610 --> 00:04:47,780
your application is 99% reliable even

00:04:45,860 --> 00:04:50,870
that is not that good enough if you are

00:04:47,780 --> 00:04:53,120
if you have a lots of users for 1

00:04:50,870 --> 00:04:57,350
million that means 10,000 users and

00:04:53,120 --> 00:04:58,400
10,000 users means 10,000 angry messages

00:04:57,350 --> 00:05:02,870
all over Internet

00:04:58,400 --> 00:05:05,030
so not only ads not not only less sales

00:05:02,870 --> 00:05:07,400
but bad reviews bad reviews means less

00:05:05,030 --> 00:05:10,400
even less users in the future less

00:05:07,400 --> 00:05:16,460
revenue so in total it losses you more

00:05:10,400 --> 00:05:20,600
than 1 percent in revenue so for

00:05:16,460 --> 00:05:23,360
fault-tolerant system design typically

00:05:20,600 --> 00:05:26,450
it's the system that aware of the fault

00:05:23,360 --> 00:05:28,220
it knows I have a fault and it's still

00:05:26,450 --> 00:05:29,960
working after the fault there are

00:05:28,220 --> 00:05:32,780
methods will describe in details later

00:05:29,960 --> 00:05:35,300
and it is waiting for recovery and it is

00:05:32,780 --> 00:05:37,250
able to recover and understand that ok

00:05:35,300 --> 00:05:40,190
it's I'm back I can do everything and

00:05:37,250 --> 00:05:43,580
it's working as expected but it's

00:05:40,190 --> 00:05:45,470
difficult to achieve because software is

00:05:43,580 --> 00:05:47,630
so complex so many different people are

00:05:45,470 --> 00:05:51,440
writing software it changes all the time

00:05:47,630 --> 00:05:54,500
so we are trying to apply formal methods

00:05:51,440 --> 00:05:59,900
used for electronics for hardware to

00:05:54,500 --> 00:06:01,880
software some of them are ok but still

00:05:59,900 --> 00:06:07,400
there are some software principles that

00:06:01,880 --> 00:06:09,200
we need to use so designing first part

00:06:07,400 --> 00:06:11,990
is faults handling understand the fault

00:06:09,200 --> 00:06:14,720
and and know that there is a fault

00:06:11,990 --> 00:06:17,200
response and develop some reliability

00:06:14,720 --> 00:06:21,800
models for example like fault handling

00:06:17,200 --> 00:06:26,410
the first option is avoiding the fault

00:06:21,800 --> 00:06:26,410
how can we avoid the fault for example

00:06:28,390 --> 00:06:34,850
retrying no that's later that's that's

00:06:31,370 --> 00:06:37,100
the it's other parts avoiding it leads

00:06:34,850 --> 00:06:39,890
to the design phase during design we say

00:06:37,100 --> 00:06:42,590
okay for example some developer comes

00:06:39,890 --> 00:06:44,210
and says okay we found some cool stuff

00:06:42,590 --> 00:06:46,810
like elasticsearch let's add

00:06:44,210 --> 00:06:49,610
elasticsearch and it's going to be great

00:06:46,810 --> 00:06:52,400
okay we add elasticsearch but that's

00:06:49,610 --> 00:06:55,670
another node that can fail so what

00:06:52,400 --> 00:06:57,530
happens if that fails besides I'm not

00:06:55,670 --> 00:06:59,480
talking about maintenance setup and

00:06:57,530 --> 00:07:01,550
everything so that it's your decision

00:06:59,480 --> 00:07:05,540
should I use elasticsearch what should I

00:07:01,550 --> 00:07:08,890
add another point that can fail or keep

00:07:05,540 --> 00:07:11,690
keep working without that for example or

00:07:08,890 --> 00:07:14,240
designing system so that the fault can

00:07:11,690 --> 00:07:16,940
be avoided for example making a

00:07:14,240 --> 00:07:19,250
redundant system making a copy of

00:07:16,940 --> 00:07:20,960
database if the database fails what do

00:07:19,250 --> 00:07:23,060
you do you switch the copy database to

00:07:20,960 --> 00:07:24,830
the slave database maybe you don't even

00:07:23,060 --> 00:07:28,100
notice that it switches to a different

00:07:24,830 --> 00:07:30,790
database again techniques for detection

00:07:28,100 --> 00:07:34,310
detecting the fault acting on that fault

00:07:30,790 --> 00:07:36,650
and also techniques for masking

00:07:34,310 --> 00:07:39,440
redundancy what you said we trying was

00:07:36,650 --> 00:07:42,440
was actually dynamic redundancy for

00:07:39,440 --> 00:07:45,500
example our web service failed let's say

00:07:42,440 --> 00:07:48,710
profile service I can't get my user

00:07:45,500 --> 00:07:51,440
profile but I have a previous copy of

00:07:48,710 --> 00:07:53,420
that maybe in local cache or in ready

00:07:51,440 --> 00:07:55,730
sketch on the server side on on my

00:07:53,420 --> 00:07:57,830
application side I have a copy I can

00:07:55,730 --> 00:08:00,320
continue using it because if I don't

00:07:57,830 --> 00:08:03,080
change my profile probably that didn't

00:08:00,320 --> 00:08:05,480
change by itself right so I can keep on

00:08:03,080 --> 00:08:08,000
using that so that's a little bit not

00:08:05,480 --> 00:08:10,850
fresh its stale but at least it's

00:08:08,000 --> 00:08:14,480
reliable it's it's nothing like garbage

00:08:10,850 --> 00:08:17,000
for example and dynamic redundancy is

00:08:14,480 --> 00:08:18,920
retrying at the background we re trying

00:08:17,000 --> 00:08:21,920
we are reconfiguring trying to use

00:08:18,920 --> 00:08:25,240
different sources trying to come up with

00:08:21,920 --> 00:08:28,310
some solution like instead of welcome

00:08:25,240 --> 00:08:30,590
John you can display something your user

00:08:28,310 --> 00:08:33,380
or something that your application knows

00:08:30,590 --> 00:08:37,849
that it's this data is invalid and still

00:08:33,380 --> 00:08:41,210
is showing something to to make sure

00:08:37,849 --> 00:08:41,969
that it's working and so there are also

00:08:41,210 --> 00:08:44,639
other techniques

00:08:41,969 --> 00:08:47,519
like rolling back putting some

00:08:44,639 --> 00:08:53,160
journaling keeping safe last known good

00:08:47,519 --> 00:08:55,850
data so you can revert back to it the

00:08:53,160 --> 00:08:58,819
fault detection mainly consists of

00:08:55,850 --> 00:09:01,560
detecting what what's gone wrong

00:08:58,819 --> 00:09:03,899
for example network problem okay you can

00:09:01,560 --> 00:09:05,759
understand from exception or from some

00:09:03,899 --> 00:09:08,930
status that okay there's Network problem

00:09:05,759 --> 00:09:11,910
okay some with a web service is

00:09:08,930 --> 00:09:15,019
returning some silly output some

00:09:11,910 --> 00:09:17,819
exception code write PHP warning and

00:09:15,019 --> 00:09:19,730
your JSON parser can't parse that so you

00:09:17,819 --> 00:09:24,120
understand okay there is some problem

00:09:19,730 --> 00:09:26,069
you can add some check sums you got the

00:09:24,120 --> 00:09:29,459
information from the server but the

00:09:26,069 --> 00:09:31,920
checksum fails maybe maybe someone is

00:09:29,459 --> 00:09:34,139
doing some nasty things or the service

00:09:31,920 --> 00:09:38,129
is not correct is not working correctly

00:09:34,139 --> 00:09:40,560
so again you detect that for example you

00:09:38,129 --> 00:09:44,149
got the bad user profile information

00:09:40,560 --> 00:09:47,879
that it's not name and surname but now

00:09:44,149 --> 00:09:50,399
so we diagnose that we have a problem

00:09:47,879 --> 00:09:54,360
with this service understood that and

00:09:50,399 --> 00:09:56,730
then we need to isolate that for example

00:09:54,360 --> 00:10:00,269
in each page of your application you are

00:09:56,730 --> 00:10:03,600
displaying welcome dear sir would you

00:10:00,269 --> 00:10:05,939
like to display welcome dear now or you

00:10:03,600 --> 00:10:09,509
have null credits or we have none

00:10:05,939 --> 00:10:13,500
credits yeah so it's not good and it's

00:10:09,509 --> 00:10:16,139
inconsistent so in order to prevent that

00:10:13,500 --> 00:10:17,930
the your system should be able to

00:10:16,139 --> 00:10:21,120
understand that the date is bad and

00:10:17,930 --> 00:10:23,459
prevent it from propagation isolate that

00:10:21,120 --> 00:10:26,160
bad data for example you have a local

00:10:23,459 --> 00:10:29,220
copy and try continue using a local copy

00:10:26,160 --> 00:10:32,129
but notify user ok we are having trouble

00:10:29,220 --> 00:10:34,290
but you can still go working like Gmail

00:10:32,129 --> 00:10:36,660
application if it doesn't connect it

00:10:34,290 --> 00:10:39,389
shows oops we have a problem but you can

00:10:36,660 --> 00:10:41,370
see still open your emails right new

00:10:39,389 --> 00:10:42,899
emails and continue working that's a

00:10:41,370 --> 00:10:48,899
good example of a fault tolerant

00:10:42,899 --> 00:10:50,399
application then reconfiguration part

00:10:48,899 --> 00:10:52,170
for example if you have a problem with

00:10:50,399 --> 00:10:53,970
database then you can continue using

00:10:52,170 --> 00:10:57,000
your cache

00:10:53,970 --> 00:10:59,759
and notify other components that okay my

00:10:57,000 --> 00:11:02,370
SQL database is bad we cannot use it

00:10:59,759 --> 00:11:04,410
don't spend your time trying to connect

00:11:02,370 --> 00:11:05,459
to MySQL for example connection timeout

00:11:04,410 --> 00:11:07,889
is 60 seconds

00:11:05,459 --> 00:11:09,180
okay then on your web application all

00:11:07,889 --> 00:11:12,209
requests will start collecting

00:11:09,180 --> 00:11:13,920
collecting waiting for timeout for 60

00:11:12,209 --> 00:11:16,620
seconds then your web application

00:11:13,920 --> 00:11:18,420
crashes then you need to restart the

00:11:16,620 --> 00:11:20,970
application server you need to restart

00:11:18,420 --> 00:11:22,949
everything so you have to avoid

00:11:20,970 --> 00:11:27,779
cascading failure because one failure

00:11:22,949 --> 00:11:30,829
can end up one single increase in the

00:11:27,779 --> 00:11:33,449
latency can end up crashing everything

00:11:30,829 --> 00:11:35,939
so then if web application is

00:11:33,449 --> 00:11:37,529
unresponsive them sorry if the service

00:11:35,939 --> 00:11:39,870
is unresponsive them the application

00:11:37,529 --> 00:11:44,370
becomes unresponsive and so on and crash

00:11:39,870 --> 00:11:46,589
everything everything else so typical

00:11:44,370 --> 00:11:49,800
solution is restarting restarting the

00:11:46,589 --> 00:11:52,379
server or anything so that three types

00:11:49,800 --> 00:11:54,209
hot we start you start only the faulty

00:11:52,379 --> 00:11:56,879
module for example if you have Micro

00:11:54,209 --> 00:11:58,740
Services or some parts of application or

00:11:56,879 --> 00:12:01,139
some part of your network you just

00:11:58,740 --> 00:12:04,850
restart that and the rest is still

00:12:01,139 --> 00:12:07,920
working the term of warm restart you

00:12:04,850 --> 00:12:10,350
kind of restart the systems but you

00:12:07,920 --> 00:12:13,079
still get the latest the latest data

00:12:10,350 --> 00:12:14,910
part at least part of the data is there

00:12:13,079 --> 00:12:16,949
you only miss part of the data and cold

00:12:14,910 --> 00:12:19,649
restart means restarting the whole

00:12:16,949 --> 00:12:26,250
system and reloading all the data from

00:12:19,649 --> 00:12:28,379
the stack also when you repair the

00:12:26,250 --> 00:12:30,899
system you should understand that okay

00:12:28,379 --> 00:12:34,829
my scale is good we can start using it

00:12:30,899 --> 00:12:43,500
again and for example the service is

00:12:34,829 --> 00:12:46,379
working we can continue getting data in

00:12:43,500 --> 00:12:48,389
real reliability models can be divided

00:12:46,379 --> 00:12:52,620
in serial and parallel serial means

00:12:48,389 --> 00:12:55,199
there is a serial if one node fails then

00:12:52,620 --> 00:12:57,089
all subsequent nodes are unreachable at

00:12:55,199 --> 00:13:00,480
that time but the good thing is all

00:12:57,089 --> 00:13:04,620
nodes before that chain are reachable

00:13:00,480 --> 00:13:07,560
the parallel reliability is you copy you

00:13:04,620 --> 00:13:10,620
put many nodes all critical nodes

00:13:07,560 --> 00:13:12,390
are at least duplicated so if one fails

00:13:10,620 --> 00:13:17,280
then at least there will be a copy

00:13:12,390 --> 00:13:20,700
that's available any question up to now

00:13:17,280 --> 00:13:25,710
is it do you want to go into more

00:13:20,700 --> 00:13:33,870
details or is it good fast slow any

00:13:25,710 --> 00:13:36,540
feedback ok so one important thing is

00:13:33,870 --> 00:13:40,200
all of these are design errors all of

00:13:36,540 --> 00:13:43,740
these can be fixed during the design

00:13:40,200 --> 00:13:46,410
phase or avoided or at least

00:13:43,740 --> 00:13:51,660
yeah let's say avoided a design phase

00:13:46,410 --> 00:13:53,820
for example fault avoidance one

00:13:51,660 --> 00:13:57,630
principle is no single point of failure

00:13:53,820 --> 00:14:02,130
ok the data base is your main point of

00:13:57,630 --> 00:14:03,450
failure so make it make it - okay or add

00:14:02,130 --> 00:14:07,140
some something else

00:14:03,450 --> 00:14:09,540
add cash in front of it at HTTP cache

00:14:07,140 --> 00:14:12,990
add more we will go into detail a little

00:14:09,540 --> 00:14:16,290
bit later then everything should be

00:14:12,990 --> 00:14:19,830
redundant but running the same copy of

00:14:16,290 --> 00:14:22,589
the same software on the same server is

00:14:19,830 --> 00:14:26,220
kind of useless because that software is

00:14:22,589 --> 00:14:28,560
buggy it faced the same problem and it

00:14:26,220 --> 00:14:30,060
crashed so how do you know the other

00:14:28,560 --> 00:14:32,220
copy doesn't crash because the

00:14:30,060 --> 00:14:33,930
conditions are same if it's running on a

00:14:32,220 --> 00:14:37,040
different server than things may be

00:14:33,930 --> 00:14:39,870
different a little bit but basically

00:14:37,040 --> 00:14:42,770
using different designs also help like

00:14:39,870 --> 00:14:46,290
copy of MySQL and copy of ready sketch

00:14:42,770 --> 00:14:48,060
sorry one server is MySQL and Ready's

00:14:46,290 --> 00:14:51,270
cache so at least they're they are

00:14:48,060 --> 00:14:52,740
different and probably they won't fail

00:14:51,270 --> 00:14:56,880
at the same time at least you will be

00:14:52,740 --> 00:14:59,010
able to use some of them so replicating

00:14:56,880 --> 00:15:00,510
the same design is useless if you have

00:14:59,010 --> 00:15:04,100
something for backup

00:15:00,510 --> 00:15:07,110
it should be also a different software

00:15:04,100 --> 00:15:10,589
detection okay you understand that there

00:15:07,110 --> 00:15:14,070
is some Network exception network

00:15:10,589 --> 00:15:16,830
timeout so nowadays waiting for default

00:15:14,070 --> 00:15:19,950
60 seconds timeout is meaningless even

00:15:16,830 --> 00:15:20,970
on websites so you should try to reduce

00:15:19,950 --> 00:15:23,339
that presence

00:15:20,970 --> 00:15:25,110
the web server timeout or iyx request

00:15:23,339 --> 00:15:28,170
time up to five seconds maybe three

00:15:25,110 --> 00:15:29,189
seconds in modern world that's I think

00:15:28,170 --> 00:15:32,279
understandable

00:15:29,189 --> 00:15:35,250
nobody will wait for one minute to

00:15:32,279 --> 00:15:38,269
finalize purchase okay again

00:15:35,250 --> 00:15:44,459
Jason parse errors checks arms and

00:15:38,269 --> 00:15:47,550
isolating the error reconfiguration

00:15:44,459 --> 00:15:49,319
phase is you understand that one part is

00:15:47,550 --> 00:15:52,019
not working for example in your web

00:15:49,319 --> 00:15:55,410
application orders module is not working

00:15:52,019 --> 00:15:57,649
or the video stream is not working but

00:15:55,410 --> 00:16:02,399
other parts should be working right so

00:15:57,649 --> 00:16:05,040
and it would be good if you don't allow

00:16:02,399 --> 00:16:06,959
user to click video stream if you know

00:16:05,040 --> 00:16:09,329
that it's not working so you notify

00:16:06,959 --> 00:16:12,620
whole system say ok video service is

00:16:09,329 --> 00:16:15,060
unavailable temporarily and then user

00:16:12,620 --> 00:16:16,529
when he tries to click tries to watch

00:16:15,060 --> 00:16:19,259
something he will be displayed and

00:16:16,529 --> 00:16:22,230
information we are experiencing problems

00:16:19,259 --> 00:16:24,779
come back in five minutes our we re

00:16:22,230 --> 00:16:31,290
trying maybe give him a retry button for

00:16:24,779 --> 00:16:33,389
himself so graceful degradation is you

00:16:31,290 --> 00:16:35,189
just disabled part of your system so

00:16:33,389 --> 00:16:37,350
that it doesn't work and it doesn't

00:16:35,189 --> 00:16:38,309
annoy user and user knows ok this part

00:16:37,350 --> 00:16:41,129
is not working

00:16:38,309 --> 00:16:43,889
consider elevator if there is a power

00:16:41,129 --> 00:16:45,870
outage you're a later we'll go into into

00:16:43,889 --> 00:16:48,300
a graceful degradation it has a battery

00:16:45,870 --> 00:16:52,470
backup and go down to the closest floor

00:16:48,300 --> 00:16:54,839
and open the doors ok it works you are

00:16:52,470 --> 00:16:58,740
not dying out there you have some light

00:16:54,839 --> 00:17:02,790
so and you are able to exit so that's

00:16:58,740 --> 00:17:05,400
fault tolerant so that's the same is

00:17:02,790 --> 00:17:06,839
relates the same is valid for your

00:17:05,400 --> 00:17:09,360
application your application should also

00:17:06,839 --> 00:17:11,909
be like this ok understand it's not

00:17:09,360 --> 00:17:15,650
working but at least go to some specific

00:17:11,909 --> 00:17:20,490
state and let the user know about this

00:17:15,650 --> 00:17:24,329
and also as I told this if you don't

00:17:20,490 --> 00:17:26,490
prevent this for example if user profile

00:17:24,329 --> 00:17:29,100
service is not working and you don't

00:17:26,490 --> 00:17:30,990
disabled requests to it so then more

00:17:29,100 --> 00:17:32,880
users will be angry they will be

00:17:30,990 --> 00:17:34,590
clicking clicking clicking more requests

00:17:32,880 --> 00:17:34,830
coming to your application server and

00:17:34,590 --> 00:17:36,870
your

00:17:34,830 --> 00:17:39,059
application server will crash that crash

00:17:36,870 --> 00:17:42,230
will trigger another thing then login

00:17:39,059 --> 00:17:45,360
service will crash so all of them will

00:17:42,230 --> 00:17:48,019
cascade will be there will be cascading

00:17:45,360 --> 00:17:51,000
failure all of them will crash at once

00:17:48,019 --> 00:17:53,010
so instead of just simply restarting one

00:17:51,000 --> 00:18:01,080
server you you will have to restart all

00:17:53,010 --> 00:18:04,950
of your servers recovery part is when in

00:18:01,080 --> 00:18:06,899
order to recover you can implement

00:18:04,950 --> 00:18:09,539
transaction safety you can use last

00:18:06,899 --> 00:18:13,289
known good data for example from cache

00:18:09,539 --> 00:18:15,630
from your in from your memory from

00:18:13,289 --> 00:18:18,600
somewhere that you know this was this

00:18:15,630 --> 00:18:20,820
data was good I can use the bad data

00:18:18,600 --> 00:18:23,159
right now but at least I can do this if

00:18:20,820 --> 00:18:25,500
I'm placing order and it failed

00:18:23,159 --> 00:18:28,620
okay I'm saying I can roll back and go

00:18:25,500 --> 00:18:31,620
to payments i payment page again say

00:18:28,620 --> 00:18:35,490
please try again please try again and

00:18:31,620 --> 00:18:42,210
not just show some nasty server error

00:18:35,490 --> 00:18:43,919
page for the same is for payments for

00:18:42,210 --> 00:18:46,799
example the payment button crashes the

00:18:43,919 --> 00:18:49,649
service ok the service crashes you

00:18:46,799 --> 00:18:51,480
understand that but the user wants to

00:18:49,649 --> 00:18:53,870
pay he clicks again and again and again

00:18:51,480 --> 00:18:56,909
maybe something happen in the network so

00:18:53,870 --> 00:18:59,669
the transaction is ok the payment is ok

00:18:56,909 --> 00:19:02,460
but your application doesn't know that

00:18:59,669 --> 00:19:07,769
maybe there is some PHP warning or

00:19:02,460 --> 00:19:09,539
anything or Jason format is bad but user

00:19:07,769 --> 00:19:12,269
wants to pay he clicks again and again

00:19:09,539 --> 00:19:14,100
so in order to prevent duplicate

00:19:12,269 --> 00:19:18,059
payments you can use transaction IDs

00:19:14,100 --> 00:19:20,549
before making a payment you just send

00:19:18,059 --> 00:19:22,049
some transaction ID maybe order ID so is

00:19:20,549 --> 00:19:26,639
this order ID paid or not

00:19:22,049 --> 00:19:29,100
so you prevent duplicate payments for

00:19:26,639 --> 00:19:32,730
transaction safety showing with try

00:19:29,100 --> 00:19:34,409
buttons and then when the network is

00:19:32,730 --> 00:19:36,600
back when the server is back you you

00:19:34,409 --> 00:19:39,120
need to understand that of course there

00:19:36,600 --> 00:19:40,980
is some background service checks become

00:19:39,120 --> 00:19:43,289
maybe network you can listen to network

00:19:40,980 --> 00:19:45,529
changes and understand ok network is but

00:19:43,289 --> 00:19:48,480
it's changed maybe now it's reachable

00:19:45,529 --> 00:19:51,360
maybe now I can retry

00:19:48,480 --> 00:19:53,850
and at the background there should be

00:19:51,360 --> 00:19:56,580
some service retrying and then uh notify

00:19:53,850 --> 00:20:02,309
okay we are done everything is working

00:19:56,580 --> 00:20:05,460
again sorry so the design methodology

00:20:02,309 --> 00:20:08,660
for this is just list all modules in

00:20:05,460 --> 00:20:12,480
your application what are the database

00:20:08,660 --> 00:20:15,320
no media files video files web

00:20:12,480 --> 00:20:19,260
application server streaming server

00:20:15,320 --> 00:20:22,620
cache your web application may be local

00:20:19,260 --> 00:20:25,320
application cache or storage so identify

00:20:22,620 --> 00:20:28,620
all of the modules list points of

00:20:25,320 --> 00:20:31,410
failure what can fail and what will you

00:20:28,620 --> 00:20:34,260
do when it fails what is the backup plan

00:20:31,410 --> 00:20:35,880
so there's you try to design a system

00:20:34,260 --> 00:20:38,220
where there is no single point of

00:20:35,880 --> 00:20:45,020
failure and even if it fails the system

00:20:38,220 --> 00:20:49,049
can continue working one method for

00:20:45,020 --> 00:20:51,990
Responsive application I mean that's

00:20:49,049 --> 00:20:57,179
still responding is separating data from

00:20:51,990 --> 00:20:59,490
control from metadata for example if the

00:20:57,179 --> 00:21:01,140
video is not available okay the

00:20:59,490 --> 00:21:02,880
application should not be freezing

00:21:01,140 --> 00:21:04,950
because of that okay the video is not

00:21:02,880 --> 00:21:07,380
available but I can log in I can log out

00:21:04,950 --> 00:21:12,030
I can see my profile maybe update my

00:21:07,380 --> 00:21:14,820
profile but those simple queries should

00:21:12,030 --> 00:21:17,940
not be working on the same application

00:21:14,820 --> 00:21:20,340
server the big amount of data streaming

00:21:17,940 --> 00:21:21,780
the media the content the products they

00:21:20,340 --> 00:21:23,309
may be running on a different server on

00:21:21,780 --> 00:21:26,010
a different application so if that

00:21:23,309 --> 00:21:32,130
crashes still other operations should be

00:21:26,010 --> 00:21:34,110
working so here the technique is a

00:21:32,130 --> 00:21:38,250
little bit stale well a little bit slow

00:21:34,110 --> 00:21:40,140
so either everything is using

00:21:38,250 --> 00:21:43,440
transaction safety but it's a little bit

00:21:40,140 --> 00:21:45,929
slow but that's real data or it's a

00:21:43,440 --> 00:21:50,250
little bit stale but it's from cache but

00:21:45,929 --> 00:21:53,100
it's very fast so later the eventual

00:21:50,250 --> 00:21:56,570
consistency in a few seconds maybe you

00:21:53,100 --> 00:21:59,730
will see the actual the latest data but

00:21:56,570 --> 00:22:02,659
it's okay for user to see all data for a

00:21:59,730 --> 00:22:02,659
couple of seconds maybe

00:22:04,970 --> 00:22:09,600
so development the application

00:22:08,429 --> 00:22:13,769
development is iterative

00:22:09,600 --> 00:22:17,399
so fault tolerance is also iterative you

00:22:13,769 --> 00:22:18,480
can release an update and this may

00:22:17,399 --> 00:22:20,340
change everything

00:22:18,480 --> 00:22:24,059
this means this may change your fault

00:22:20,340 --> 00:22:25,590
tolerance design so after that change

00:22:24,059 --> 00:22:27,779
you have to also revisit the fault

00:22:25,590 --> 00:22:29,850
tolerance how this affected or what is

00:22:27,779 --> 00:22:35,190
the the latest system status what's

00:22:29,850 --> 00:22:38,850
going on now and reiterate it and make

00:22:35,190 --> 00:22:42,389
sure that still the system is reliable

00:22:38,850 --> 00:22:44,159
now this is a typical scenario first

00:22:42,389 --> 00:22:46,700
while you are developing and testing

00:22:44,159 --> 00:22:50,460
your application has lots of failures

00:22:46,700 --> 00:22:53,250
then after testing is done the

00:22:50,460 --> 00:22:56,100
application is good next release means

00:22:53,250 --> 00:22:57,990
new effects new errors then there gets

00:22:56,100 --> 00:22:59,250
fixed then another update another update

00:22:57,990 --> 00:23:02,909
so this is the basic application

00:22:59,250 --> 00:23:06,720
lifecycle so again why these crashes

00:23:02,909 --> 00:23:10,919
appear because the changes in the

00:23:06,720 --> 00:23:14,970
application resulted in some fault

00:23:10,919 --> 00:23:16,980
tolerance outage or maybe the

00:23:14,970 --> 00:23:24,809
application is not fault tolerance so

00:23:16,980 --> 00:23:26,850
user sees those errors so what are the

00:23:24,809 --> 00:23:31,620
sample application modules for example

00:23:26,850 --> 00:23:35,700
the web service database content UI any

00:23:31,620 --> 00:23:39,659
anything else that you want to add let's

00:23:35,700 --> 00:23:41,940
make a simple a sample design so this is

00:23:39,659 --> 00:23:44,880
the application this is like a mobile

00:23:41,940 --> 00:23:49,260
application or a web application this is

00:23:44,880 --> 00:23:54,120
the web service storage and media files

00:23:49,260 --> 00:23:56,639
located somewhere so what are the points

00:23:54,120 --> 00:23:59,340
of failure the database obviously is

00:23:56,639 --> 00:24:01,380
point of failure web service itself is

00:23:59,340 --> 00:24:04,110
point of failure maybe crashing and

00:24:01,380 --> 00:24:07,559
unresponsive media files may be

00:24:04,110 --> 00:24:11,730
unreachable lost may be the path is

00:24:07,559 --> 00:24:14,519
incorrect then network and of course the

00:24:11,730 --> 00:24:15,220
application itself so what can we do to

00:24:14,519 --> 00:24:19,480
improve this

00:24:15,220 --> 00:24:20,770
we can add local store local cash either

00:24:19,480 --> 00:24:24,250
the web application or mobile

00:24:20,770 --> 00:24:27,340
application it can cache the media files

00:24:24,250 --> 00:24:30,370
the profile information any information

00:24:27,340 --> 00:24:33,100
that they got they can store locally

00:24:30,370 --> 00:24:35,169
just in case just if anything goes wrong

00:24:33,100 --> 00:24:37,419
still the application will continue

00:24:35,169 --> 00:24:42,340
working but at the background tries to

00:24:37,419 --> 00:24:45,460
get that information again if we add

00:24:42,340 --> 00:24:49,179
cash we can cover for this SQL Server

00:24:45,460 --> 00:24:52,450
for example if this connection or if the

00:24:49,179 --> 00:24:58,260
SQL database crashes then you can get

00:24:52,450 --> 00:25:01,929
the information from cash then another

00:24:58,260 --> 00:25:04,390
so this this is a typical situation so

00:25:01,929 --> 00:25:07,000
the media files are not going through

00:25:04,390 --> 00:25:10,380
your web server so you are separating

00:25:07,000 --> 00:25:14,140
that data from commands from the

00:25:10,380 --> 00:25:18,159
metadata again you are using some HTTP

00:25:14,140 --> 00:25:22,210
cache CDN to distribute that data so now

00:25:18,159 --> 00:25:27,240
there are lots of systems lots of parts

00:25:22,210 --> 00:25:27,240
that are redundant that can protect you

00:25:30,380 --> 00:25:37,610
so what could go wrong here let's let's

00:25:34,360 --> 00:25:40,070
again let's speak of scenarios for

00:25:37,610 --> 00:25:42,380
example if there's something wrong with

00:25:40,070 --> 00:25:45,530
the database what can we do what your

00:25:42,380 --> 00:25:48,410
application should do let's say well I'm

00:25:45,530 --> 00:25:54,919
speaking about this web service at this

00:25:48,410 --> 00:25:57,919
time yes right so you get the data from

00:25:54,919 --> 00:26:00,799
cache you can continue using cache but

00:25:57,919 --> 00:26:03,590
you know that this connection is wrong

00:26:00,799 --> 00:26:06,950
is not working you can notify all

00:26:03,590 --> 00:26:11,059
systems here at least in your server you

00:26:06,950 --> 00:26:14,659
can reconfigure you can set as update a

00:26:11,059 --> 00:26:16,460
setting and say MySQL bad maybe you have

00:26:14,659 --> 00:26:18,409
some logging server here cloud watch

00:26:16,460 --> 00:26:21,080
locally or whatever you are using

00:26:18,409 --> 00:26:24,049
maybe that server is bad ok you also

00:26:21,080 --> 00:26:26,059
update this logging service is bad don't

00:26:24,049 --> 00:26:29,179
use just disable it from configuration

00:26:26,059 --> 00:26:33,020
again cache is bad don't use cache ok we

00:26:29,179 --> 00:26:36,650
or everything goes directly to the to

00:26:33,020 --> 00:26:38,929
the database payment API is broken ok

00:26:36,650 --> 00:26:41,630
don't don't use payment we configure

00:26:38,929 --> 00:26:44,440
notify everyone notify even this a web

00:26:41,630 --> 00:26:47,299
application that payment is is bad and

00:26:44,440 --> 00:26:49,580
sorry we cannot accept payments at this

00:26:47,299 --> 00:26:51,500
time or we cannot accept paypal payments

00:26:49,580 --> 00:26:56,179
at this time we cannot use credit card

00:26:51,500 --> 00:26:58,549
but PayPal is ok so again for each of

00:26:56,179 --> 00:27:02,240
these items you can do ok web service is

00:26:58,549 --> 00:27:04,850
not working what else here HTTP cache

00:27:02,240 --> 00:27:06,830
may help for part of your in for part of

00:27:04,850 --> 00:27:10,130
your for the web page still be will be

00:27:06,830 --> 00:27:12,169
loading but you cannot login or if you

00:27:10,130 --> 00:27:14,150
have a separate server for that you can

00:27:12,169 --> 00:27:19,570
continue logging in if you have a

00:27:14,150 --> 00:27:22,460
separate server and if everything is

00:27:19,570 --> 00:27:24,620
down if you are in a subway if you don't

00:27:22,460 --> 00:27:27,470
have an internet still you have lots of

00:27:24,620 --> 00:27:31,940
data on your local application that you

00:27:27,470 --> 00:27:34,730
can be you can continue working so here

00:27:31,940 --> 00:27:38,240
this reconfiguration prevents cascading

00:27:34,730 --> 00:27:40,580
failure if the database is bad ok this

00:27:38,240 --> 00:27:42,799
doesn't have to wait for 60 seconds if

00:27:40,580 --> 00:27:44,120
you have like thousand requests each

00:27:42,799 --> 00:27:47,780
waiting for one minute

00:27:44,120 --> 00:27:54,980
then your web application the crash

00:27:47,780 --> 00:27:56,510
quickly so that part was regulated to

00:27:54,980 --> 00:27:58,910
the system design and formal

00:27:56,510 --> 00:28:03,170
methodologies the rest is more related

00:27:58,910 --> 00:28:12,560
to coding and the more low-level design

00:28:03,170 --> 00:28:15,170
any questions up to now great so robust

00:28:12,560 --> 00:28:18,070
application is the one that can detect

00:28:15,170 --> 00:28:21,110
the errors display and display that

00:28:18,070 --> 00:28:24,290
notify I mean that know that okay I have

00:28:21,110 --> 00:28:27,080
an error so mostly the problem with

00:28:24,290 --> 00:28:30,200
modern applications is they don't detect

00:28:27,080 --> 00:28:32,300
an error for example some invalid user

00:28:30,200 --> 00:28:35,750
input or now input they don't validate

00:28:32,300 --> 00:28:37,970
they just crash and they don't log it so

00:28:35,750 --> 00:28:42,020
no one knows what happened no one knows

00:28:37,970 --> 00:28:44,210
if any error occurred so robust system

00:28:42,020 --> 00:28:50,240
should be able to detect failure and

00:28:44,210 --> 00:28:52,070
indicate it to two things reliability

00:28:50,240 --> 00:28:54,440
for that can be accomplished using rely

00:28:52,070 --> 00:28:57,020
using redundancy yes we can put two

00:28:54,440 --> 00:28:59,900
servers but if that's design fault if

00:28:57,020 --> 00:29:02,570
that's in software you can make as many

00:28:59,900 --> 00:29:06,080
copies as you can but if there's no null

00:29:02,570 --> 00:29:08,600
pointer checking or valid value

00:29:06,080 --> 00:29:12,500
validation then you can you will

00:29:08,600 --> 00:29:14,420
continue getting errors so Neil's new

00:29:12,500 --> 00:29:16,580
story says the software faults are all

00:29:14,420 --> 00:29:18,890
designed faults that could be prevented

00:29:16,580 --> 00:29:24,140
at the beginning before starting to

00:29:18,890 --> 00:29:25,670
coding or during the coding phase so the

00:29:24,140 --> 00:29:27,500
faults are mainly from software

00:29:25,670 --> 00:29:29,390
specification maybe there is some wrong

00:29:27,500 --> 00:29:31,190
understanding in the software

00:29:29,390 --> 00:29:33,170
specification the developers may

00:29:31,190 --> 00:29:35,480
understand it wrong the analysts may

00:29:33,170 --> 00:29:38,330
understand it wrong or maybe different

00:29:35,480 --> 00:29:42,110
departments different modules are don't

00:29:38,330 --> 00:29:45,200
know what the other is doing again

00:29:42,110 --> 00:29:48,590
design error like if every module is

00:29:45,200 --> 00:29:52,010
doing its own work and they are crashing

00:29:48,590 --> 00:29:54,590
keep crashing each other developers of

00:29:52,010 --> 00:29:57,370
course no need to say and unexpected

00:29:54,590 --> 00:29:58,630
conditions in code

00:29:57,370 --> 00:30:00,790
of course what's the what's the

00:29:58,630 --> 00:30:02,440
difference between a profile an

00:30:00,790 --> 00:30:04,840
experienced developer and a young

00:30:02,440 --> 00:30:08,410
developer in experienced developers code

00:30:04,840 --> 00:30:10,870
you can see lots of if-else what if now

00:30:08,410 --> 00:30:13,330
all of all kinds of checks yes the

00:30:10,870 --> 00:30:17,470
program becomes ten times more but it's

00:30:13,330 --> 00:30:19,990
also ten times more reliable so handing

00:30:17,470 --> 00:30:23,440
unexpected conditions is the main idea

00:30:19,990 --> 00:30:26,950
for robust development for example here

00:30:23,440 --> 00:30:32,380
we have a simple code can everyone read

00:30:26,950 --> 00:30:34,750
or those who are interested so so

00:30:32,380 --> 00:30:37,570
basically we say if payment type is

00:30:34,750 --> 00:30:40,240
paypal then go to paypal service make

00:30:37,570 --> 00:30:43,420
payment then update orders table and

00:30:40,240 --> 00:30:47,710
update users update order count so

00:30:43,420 --> 00:30:56,100
what's wrong with this let's give me at

00:30:47,710 --> 00:30:56,100
least five problems okay one

00:30:59,620 --> 00:31:07,980
sorry yes okay

00:31:08,040 --> 00:31:14,580
validation PayPal can fail right free

00:31:15,240 --> 00:31:19,870
yes

00:31:18,120 --> 00:31:21,670
SQL injection

00:31:19,870 --> 00:31:28,960
I let let's say we have handled that

00:31:21,670 --> 00:31:31,870
before this is a function so by the time

00:31:28,960 --> 00:31:34,090
order ID gets here I hope it was handled

00:31:31,870 --> 00:31:39,880
so it's not responsibility of this

00:31:34,090 --> 00:31:46,020
method but okay good yeah my scale Curie

00:31:39,880 --> 00:31:46,020
can fail yeah we got five any ideas more

00:31:51,840 --> 00:31:57,429
yes we will discuss that in the next

00:31:55,000 --> 00:31:59,170
slide but yes good idea you if the

00:31:57,429 --> 00:32:01,420
PayPal fails then you have to do

00:31:59,170 --> 00:32:05,740
something about that right not just say

00:32:01,420 --> 00:32:09,150
okay okay update and I'm fine so also

00:32:05,740 --> 00:32:12,550
let's go let's repeat one by one first

00:32:09,150 --> 00:32:16,620
here's an if and there is no else what

00:32:12,550 --> 00:32:21,070
if I made not SQL injection some URL I

00:32:16,620 --> 00:32:24,190
played with URL and saying payment type

00:32:21,070 --> 00:32:28,210
is rim and it says okay order is shipped

00:32:24,190 --> 00:32:31,179
what if PayPal fails we need to know we

00:32:28,210 --> 00:32:33,190
need to do something about that once if

00:32:31,179 --> 00:32:37,360
your fails we need to do something about

00:32:33,190 --> 00:32:40,270
that and we also update user order count

00:32:37,360 --> 00:32:45,940
that's not that much important but the

00:32:40,270 --> 00:32:48,160
issue here is that design issue so here

00:32:45,940 --> 00:32:50,800
we are updating orders and updating

00:32:48,160 --> 00:32:52,780
users I don't know what is this module

00:32:50,800 --> 00:32:56,080
probably some purchase model or payment

00:32:52,780 --> 00:32:59,050
module but we are directly poking orders

00:32:56,080 --> 00:33:02,590
and who knows who else is poking orders

00:32:59,050 --> 00:33:04,990
table updating maybe for example this

00:33:02,590 --> 00:33:09,480
status I am saying status is paid which

00:33:04,990 --> 00:33:12,860
is string what if tomorrow I just hit

00:33:09,480 --> 00:33:17,300
keyboard by accident and there is a typo

00:33:12,860 --> 00:33:19,190
ends up in pedo and all your pages you

00:33:17,300 --> 00:33:21,860
know in none of your pages you can see

00:33:19,190 --> 00:33:24,860
this order because select where status

00:33:21,860 --> 00:33:27,590
is paid select where status is none or

00:33:24,860 --> 00:33:33,880
new it doesn't select SQL statement

00:33:27,590 --> 00:33:36,260
doesn't find this order this so the

00:33:33,880 --> 00:33:37,270
state machine is broken the order is

00:33:36,260 --> 00:33:40,040
somewhere else

00:33:37,270 --> 00:33:41,870
hopefully you can put some view all

00:33:40,040 --> 00:33:46,930
orders so you can find that order

00:33:41,870 --> 00:33:50,600
otherwise it's it's lost somewhere again

00:33:46,930 --> 00:33:53,120
again if these crashes and I by updating

00:33:50,600 --> 00:33:55,460
the user maybe I don't know what's going

00:33:53,120 --> 00:33:58,970
on maybe a user table is being updated

00:33:55,460 --> 00:34:01,460
the biggest problem is we will go over

00:33:58,970 --> 00:34:06,110
it that everyone is doing its own work

00:34:01,460 --> 00:34:08,300
but on the other modules field this

00:34:06,110 --> 00:34:11,450
module should not be updating orders or

00:34:08,300 --> 00:34:17,000
the users by itself its responsibility

00:34:11,450 --> 00:34:18,980
is just payment okay next this the

00:34:17,000 --> 00:34:21,169
biggest solution is separating of

00:34:18,980 --> 00:34:24,260
concerns we need to split code by the

00:34:21,169 --> 00:34:26,800
modules and the modules should not be

00:34:24,260 --> 00:34:29,300
accessing each other's data directly

00:34:26,800 --> 00:34:31,490
accessing or modifying even modifying

00:34:29,300 --> 00:34:33,830
that's the biggest problem today you

00:34:31,490 --> 00:34:35,990
hired a new developer he came and he is

00:34:33,830 --> 00:34:37,580
updating the orders table by himself

00:34:35,990 --> 00:34:39,679
and you don't know what he's doing and

00:34:37,580 --> 00:34:42,860
you can lose the order as I mentioned

00:34:39,679 --> 00:34:44,929
you don't see customer complaints my

00:34:42,860 --> 00:34:46,790
order is lost where is it or where is my

00:34:44,929 --> 00:34:48,890
shipment I don't see any tracking

00:34:46,790 --> 00:34:50,929
information so just because someone else

00:34:48,890 --> 00:34:54,440
modified it and you don't know which

00:34:50,929 --> 00:34:57,140
kind of status he is using maybe he

00:34:54,440 --> 00:35:00,440
added some new status like checking or

00:34:57,140 --> 00:35:05,030
fraud checking whatever and you don't

00:35:00,440 --> 00:35:06,760
know no direct data modification you

00:35:05,030 --> 00:35:09,920
need to update data through a dedicated

00:35:06,760 --> 00:35:12,440
repository or service update user

00:35:09,920 --> 00:35:15,170
information through user repository user

00:35:12,440 --> 00:35:17,200
service update order through order

00:35:15,170 --> 00:35:20,680
service what's the difference between

00:35:17,200 --> 00:35:20,680
repository and service

00:35:22,280 --> 00:35:29,750
why I mean which one we should use I

00:35:26,840 --> 00:35:32,980
order beer to the one who first answers

00:35:29,750 --> 00:35:32,980
this correctly

00:35:42,610 --> 00:35:50,080
correct so repository is for storage

00:35:46,540 --> 00:35:52,120
only no logic all logic is here

00:35:50,080 --> 00:35:55,300
validation for example I am trying to

00:35:52,120 --> 00:36:00,130
update the order I'm saying ok order

00:35:55,300 --> 00:36:02,500
page ok but the as I told some young

00:36:00,130 --> 00:36:04,120
developer come came and he doesn't know

00:36:02,500 --> 00:36:07,510
the system he is updating the order

00:36:04,120 --> 00:36:09,370
status who is validating it the order

00:36:07,510 --> 00:36:11,920
service the order service should check

00:36:09,370 --> 00:36:14,260
ok is it paid is it ok

00:36:11,920 --> 00:36:16,870
is it not empty what's the status can we

00:36:14,260 --> 00:36:18,780
ship is it in stock all kinds of

00:36:16,870 --> 00:36:24,160
business logic goes into the service

00:36:18,780 --> 00:36:27,700
your beer is on me so and repository

00:36:24,160 --> 00:36:29,950
also should be accessed only through

00:36:27,700 --> 00:36:33,430
service no one no one accesses

00:36:29,950 --> 00:36:35,680
repository directly because it's miss it

00:36:33,430 --> 00:36:37,690
doesn't have a business project so here

00:36:35,680 --> 00:36:41,580
put logic in the service and cover it

00:36:37,690 --> 00:36:45,490
with unit tests all sql's whatever or

00:36:41,580 --> 00:36:47,950
you can write it in plain files it's up

00:36:45,490 --> 00:36:50,530
to you every all that kind of stuff goes

00:36:47,950 --> 00:36:53,080
into repository and you don't need to

00:36:50,530 --> 00:36:55,180
test it because it it's the connection

00:36:53,080 --> 00:36:57,880
with the real world with the real api's

00:36:55,180 --> 00:37:00,190
this can be taught to the mockable you

00:36:57,880 --> 00:37:05,340
Mochrie the repository and test the

00:37:00,190 --> 00:37:05,340
service with unit tests any questions oh

00:37:05,670 --> 00:37:12,940
so a little bit improved example here we

00:37:10,330 --> 00:37:16,150
converted this to switch because there

00:37:12,940 --> 00:37:18,040
may be many payment types and we don't

00:37:16,150 --> 00:37:22,270
want to say if else if else if else

00:37:18,040 --> 00:37:26,080
because that's also sucks and ok we said

00:37:22,270 --> 00:37:29,710
K is constant PayPal payment if payment

00:37:26,080 --> 00:37:32,560
service is ok than return system error

00:37:29,710 --> 00:37:34,600
is not okey return system error here of

00:37:32,560 --> 00:37:37,120
course it's up to you you can return

00:37:34,600 --> 00:37:39,940
system error or throw an exception it's

00:37:37,120 --> 00:37:43,060
up to you but the basic idea is you are

00:37:39,940 --> 00:37:46,810
checking the status then ok order

00:37:43,060 --> 00:37:49,510
service you are paying you marking this

00:37:46,810 --> 00:37:51,370
order estate and it will also do

00:37:49,510 --> 00:37:54,970
something on honest side shipment

00:37:51,370 --> 00:37:55,900
service ship the order ok so what's

00:37:54,970 --> 00:37:56,440
wrong here

00:37:55,900 --> 00:37:59,200
Oh

00:37:56,440 --> 00:38:01,450
cool we will even add a default if if it

00:37:59,200 --> 00:38:02,350
is unknown or unexpected payment type we

00:38:01,450 --> 00:38:11,200
are returning error

00:38:02,350 --> 00:38:13,360
what's wrong will with this yes so next

00:38:11,200 --> 00:38:16,540
step what do we do here

00:38:13,360 --> 00:38:19,450
for example if payment is okay but order

00:38:16,540 --> 00:38:22,060
is not we couldn't update the order what

00:38:19,450 --> 00:38:24,580
do we do here this is exactly what the

00:38:22,060 --> 00:38:28,210
fault-tolerant robust application should

00:38:24,580 --> 00:38:32,010
be thinking of either we can leave it in

00:38:28,210 --> 00:38:34,270
some inconsistent state or make up some

00:38:32,010 --> 00:38:37,990
watchdog software running at the

00:38:34,270 --> 00:38:42,270
background trying to find orphans or

00:38:37,990 --> 00:38:46,210
orders that are paid but not updated

00:38:42,270 --> 00:38:48,790
again for shipment here again we we

00:38:46,210 --> 00:38:51,820
couldn't ship it what happens here we

00:38:48,790 --> 00:38:54,280
need to think okay paid updated but we

00:38:51,820 --> 00:38:57,510
couldn't ship again water is there on

00:38:54,280 --> 00:39:01,120
the warehouse waiting for months and

00:38:57,510 --> 00:39:02,590
it's lost so here again it's up to you

00:39:01,120 --> 00:39:10,780
you need to think what should you do

00:39:02,590 --> 00:39:13,530
here so what can we do here any ideas ok

00:39:10,780 --> 00:39:18,450
so what do we do throw different errors

00:39:13,530 --> 00:39:18,450
what do what do we do with those errors

00:39:20,010 --> 00:39:26,290
ok good we can handle them separately

00:39:23,860 --> 00:39:28,930
we can handle them it's up to you so

00:39:26,290 --> 00:39:31,180
exception handling is is a good topic is

00:39:28,930 --> 00:39:33,700
a very broad topic so here you can

00:39:31,180 --> 00:39:36,010
return or throw exception different type

00:39:33,700 --> 00:39:38,890
of exception and the code calling it

00:39:36,010 --> 00:39:41,290
could think what to do so for example if

00:39:38,890 --> 00:39:44,800
this is simple service simple payment

00:39:41,290 --> 00:39:47,530
service then it's not your concern

00:39:44,800 --> 00:39:50,620
ok I try it ok I give up but you should

00:39:47,530 --> 00:39:53,160
do your the master should be thinking

00:39:50,620 --> 00:39:53,160
what to do next

00:39:56,010 --> 00:40:02,740
so this is soft the invalid inconsistent

00:40:00,340 --> 00:40:04,600
state is solved by state machine state

00:40:02,740 --> 00:40:08,020
machine should be managed by a single

00:40:04,600 --> 00:40:10,510
class for example the order is new order

00:40:08,020 --> 00:40:12,730
service ok new term new order it

00:40:10,510 --> 00:40:14,050
transitions to ready state in

00:40:12,730 --> 00:40:16,570
transitions to shipping state

00:40:14,050 --> 00:40:19,740
transitions to been completed or

00:40:16,570 --> 00:40:25,300
returned from here it can go to refund

00:40:19,740 --> 00:40:29,380
whatever or negotiation so but it should

00:40:25,300 --> 00:40:33,280
be done through a single class through a

00:40:29,380 --> 00:40:36,790
single service and it's easy to cover it

00:40:33,280 --> 00:40:39,940
with unit tests and to make a setup for

00:40:36,790 --> 00:40:43,450
example if you see there are some

00:40:39,940 --> 00:40:46,390
specific case PayPal failed but shipment

00:40:43,450 --> 00:40:48,910
or PayPal okay but shipment fail so what

00:40:46,390 --> 00:40:50,590
do we do that's exactly what you can try

00:40:48,910 --> 00:40:53,020
with the state machine it's easy to

00:40:50,590 --> 00:40:55,990
setup that using unit tests as you say

00:40:53,020 --> 00:40:58,570
just status ok ship not shipping in

00:40:55,990 --> 00:41:01,630
payment is okay bla bla and run the test

00:40:58,570 --> 00:41:04,330
only three lines of code but if you do

00:41:01,630 --> 00:41:06,370
it in real life you have to update the

00:41:04,330 --> 00:41:09,640
database if you have direct database

00:41:06,370 --> 00:41:12,700
access otherwise you have to simulate

00:41:09,640 --> 00:41:18,880
that real life situation simulate that

00:41:12,700 --> 00:41:23,130
error shipment failure etc exception

00:41:18,880 --> 00:41:26,290
handling exception here is more like

00:41:23,130 --> 00:41:28,240
edge case detection not software

00:41:26,290 --> 00:41:30,970
exceptions that we throw around just

00:41:28,240 --> 00:41:34,330
edge cases exception is what we don't

00:41:30,970 --> 00:41:37,770
know and and we didn't predict for

00:41:34,330 --> 00:41:42,490
example unknown invalid input now input

00:41:37,770 --> 00:41:44,830
connection problem anything else so if

00:41:42,490 --> 00:41:47,200
you handle all those unknown unpredicted

00:41:44,830 --> 00:41:49,090
situations this will improve your fault

00:41:47,200 --> 00:41:51,610
tolerance you can understand okay I got

00:41:49,090 --> 00:41:53,980
it here's why I have the problem here

00:41:51,610 --> 00:41:56,080
and I know what to do this I thought

00:41:53,980 --> 00:41:59,590
what should I do with it it's not just

00:41:56,080 --> 00:42:01,600
good a good path a safe path that's okay

00:41:59,590 --> 00:42:04,090
okay but I'm also thinking about the

00:42:01,600 --> 00:42:07,300
exceptions what happens if something

00:42:04,090 --> 00:42:09,310
goes wrong and when you are throwing

00:42:07,300 --> 00:42:11,920
exceptions you decide where to

00:42:09,310 --> 00:42:16,930
eh those exceptions and who should take

00:42:11,920 --> 00:42:21,130
care of them so software fault results

00:42:16,930 --> 00:42:23,110
in some internal state but you should

00:42:21,130 --> 00:42:25,420
understand it you should display it to

00:42:23,110 --> 00:42:28,030
the user and you should notify other

00:42:25,420 --> 00:42:30,760
systems so they should know that there

00:42:28,030 --> 00:42:33,430
is an error detection can be memory

00:42:30,760 --> 00:42:35,140
based for example you received some new

00:42:33,430 --> 00:42:38,920
profile data you compare it with the

00:42:35,140 --> 00:42:42,040
previous and say look in five minutes he

00:42:38,920 --> 00:42:44,290
couldn't grow older or something just an

00:42:42,040 --> 00:42:47,410
example or if you are getting stock

00:42:44,290 --> 00:42:50,740
information you can do some project to

00:42:47,410 --> 00:42:54,040
understand what happened compare it with

00:42:50,740 --> 00:42:56,320
the previous information or memory less

00:42:54,040 --> 00:42:59,680
you receive the data from Jason request

00:42:56,320 --> 00:43:02,290
from sir i axe you a quest we receive

00:42:59,680 --> 00:43:06,460
the JSON data and validated white there

00:43:02,290 --> 00:43:08,350
if the checksum is okay if the data all

00:43:06,460 --> 00:43:11,050
the fields are available and we say no

00:43:08,350 --> 00:43:14,950
it's not invalid and you don't even copy

00:43:11,050 --> 00:43:17,260
to the memory recovery methods are

00:43:14,950 --> 00:43:20,020
backward recovery where you go to last

00:43:17,260 --> 00:43:23,260
known good state you got the data it's

00:43:20,020 --> 00:43:25,120
bad go back you know you say okay this I

00:43:23,260 --> 00:43:26,650
know that this was good I continue

00:43:25,120 --> 00:43:29,980
displaying it for a while and say

00:43:26,650 --> 00:43:33,190
connecting but the data is there and

00:43:29,980 --> 00:43:37,450
forward recovery is for more complex

00:43:33,190 --> 00:43:39,790
systems you can recalculate it or try to

00:43:37,450 --> 00:43:43,780
retry and try to get that information

00:43:39,790 --> 00:43:47,440
back also use some error compensation

00:43:43,780 --> 00:43:51,730
mechanisms to put the data in the

00:43:47,440 --> 00:43:53,800
correct state and use all kinds of fault

00:43:51,730 --> 00:43:56,860
masking so you can go into the graded

00:43:53,800 --> 00:44:01,470
state say okay we have a problem but we

00:43:56,860 --> 00:44:01,470
are trying we are still working on it

00:44:01,950 --> 00:44:08,560
and there are external consistency

00:44:05,140 --> 00:44:11,290
checks if the exact result is difficult

00:44:08,560 --> 00:44:14,020
to come to compute by yourself you can

00:44:11,290 --> 00:44:16,660
add some other external software maybe

00:44:14,020 --> 00:44:17,500
watchdog software that's checking is it

00:44:16,660 --> 00:44:20,650
ok is it ok

00:44:17,500 --> 00:44:23,650
is it responsive is it hanging or as

00:44:20,650 --> 00:44:26,590
some people do probably you

00:44:23,650 --> 00:44:29,020
seeing that for example if application

00:44:26,590 --> 00:44:32,950
is working for one hour than due to

00:44:29,020 --> 00:44:34,870
memory leaks it hangs it crashes so you

00:44:32,950 --> 00:44:37,060
develop a watchdog software that will

00:44:34,870 --> 00:44:39,700
simply restart that or that application

00:44:37,060 --> 00:44:41,410
will restart itself after a while okay

00:44:39,700 --> 00:44:44,260
that's a workaround

00:44:41,410 --> 00:44:48,910
you don't know the solution but that

00:44:44,260 --> 00:44:51,280
works more add some periodic check

00:44:48,910 --> 00:44:53,410
points okay you say five minutes ago I

00:44:51,280 --> 00:44:55,450
was good now I'm good

00:44:53,410 --> 00:44:58,270
good good good and then you can go back

00:44:55,450 --> 00:45:02,500
to the previous state but you can store

00:44:58,270 --> 00:45:04,860
it somewhere in external place internal

00:45:02,500 --> 00:45:07,510
is using checksums

00:45:04,860 --> 00:45:10,330
validating all all kinds of data in the

00:45:07,510 --> 00:45:13,390
memory or receive data and safety net

00:45:10,330 --> 00:45:15,040
for example one I was developing a

00:45:13,390 --> 00:45:16,960
traffic control application we were

00:45:15,040 --> 00:45:18,910
shuffling around the planes on the

00:45:16,960 --> 00:45:22,930
screen ok plane is here plane is there

00:45:18,910 --> 00:45:26,020
starting start engine taxi and what if

00:45:22,930 --> 00:45:29,620
due to some software exception I pull

00:45:26,020 --> 00:45:32,110
the plane and it doesn't end up on the

00:45:29,620 --> 00:45:36,670
screen yeah it's lost its orphan

00:45:32,110 --> 00:45:38,560
somewhere so what what then ok the plane

00:45:36,670 --> 00:45:42,370
is lost and I don't know where to find

00:45:38,560 --> 00:45:45,940
it so here ok you need to unit test that

00:45:42,370 --> 00:45:48,970
part very toughly but still there should

00:45:45,940 --> 00:45:52,390
be a safety net for example I moved it

00:45:48,970 --> 00:45:55,240
here but it's not there after I dropped

00:45:52,390 --> 00:45:57,820
so after you drop check is it there

00:45:55,240 --> 00:46:00,580
actually or maybe it's somewhere orphan

00:45:57,820 --> 00:46:03,280
maybe you can run watchdog software at

00:46:00,580 --> 00:46:06,970
the background to find any orphan planes

00:46:03,280 --> 00:46:13,660
that are not in the UI just as an

00:46:06,970 --> 00:46:17,950
example so internal consistency checking

00:46:13,660 --> 00:46:20,050
is for the software development for

00:46:17,950 --> 00:46:23,680
example you have configuration use this

00:46:20,050 --> 00:46:27,430
a timeout just 15 seconds the minimum

00:46:23,680 --> 00:46:30,760
user age is like 18 and everything else

00:46:27,430 --> 00:46:33,610
but you have different configurations in

00:46:30,760 --> 00:46:36,010
different files or you are making

00:46:33,610 --> 00:46:37,540
configuration for each country or for

00:46:36,010 --> 00:46:39,600
each language you are

00:46:37,540 --> 00:46:43,720
keeping a different configuration right

00:46:39,600 --> 00:46:46,540
so what if you forget to update one

00:46:43,720 --> 00:46:47,740
language you added some field but forgot

00:46:46,540 --> 00:46:50,140
to update it in some different

00:46:47,740 --> 00:46:52,630
configuration file then there will be

00:46:50,140 --> 00:46:54,700
now and the app will crash you did not

00:46:52,630 --> 00:46:57,220
do code that part I'm sure that you

00:46:54,700 --> 00:46:59,830
would handle that and now value you will

00:46:57,220 --> 00:47:03,160
check that but someone else didn't check

00:46:59,830 --> 00:47:04,510
so that will crash because the problem

00:47:03,160 --> 00:47:06,369
with the application is you update

00:47:04,510 --> 00:47:08,290
something and some something else

00:47:06,369 --> 00:47:12,310
crashes that you didn't even think about

00:47:08,290 --> 00:47:16,060
so for consistent configuration you can

00:47:12,310 --> 00:47:18,970
merge them you try to keep them at the

00:47:16,060 --> 00:47:20,500
single structure so that if you update

00:47:18,970 --> 00:47:23,500
something you can you don't have a

00:47:20,500 --> 00:47:27,910
chance to forget you you have to update

00:47:23,500 --> 00:47:30,280
it or add some integrity assertions like

00:47:27,910 --> 00:47:34,000
for each language or for each country

00:47:30,280 --> 00:47:38,590
check if all fields are same for all

00:47:34,000 --> 00:47:41,619
structures and you updated it then run

00:47:38,590 --> 00:47:44,740
the application I hope you can help the

00:47:41,619 --> 00:47:46,540
application just display country for

00:47:44,740 --> 00:47:49,480
country configuration for Norway is

00:47:46,540 --> 00:47:50,470
invalid check the configuration file

00:47:49,480 --> 00:47:54,369
right

00:47:50,470 --> 00:47:56,320
hopefully you test it tester tests it so

00:47:54,369 --> 00:47:59,080
before and before deploying it someone

00:47:56,320 --> 00:48:01,960
should notice it right I hope so or you

00:47:59,080 --> 00:48:03,850
can send a friendly warning like log log

00:48:01,960 --> 00:48:05,740
of warning or display some message that

00:48:03,850 --> 00:48:11,130
there's some configuration problem if

00:48:05,740 --> 00:48:13,690
someone is watching your logs again if

00:48:11,130 --> 00:48:17,680
look-up tables some again some

00:48:13,690 --> 00:48:19,210
configuration for look-up tables for

00:48:17,680 --> 00:48:21,400
mapping I don't know

00:48:19,210 --> 00:48:25,060
for example converting one format to

00:48:21,400 --> 00:48:27,400
another and also you can add some check

00:48:25,060 --> 00:48:30,100
sums to that to that table if I add a

00:48:27,400 --> 00:48:33,190
new row and the check sum should

00:48:30,100 --> 00:48:35,590
validate it somehow either during unit

00:48:33,190 --> 00:48:37,750
testing or during startup of the

00:48:35,590 --> 00:48:40,840
application again you should show the

00:48:37,750 --> 00:48:45,490
warning to the user and some kind of

00:48:40,840 --> 00:48:48,609
reminders these all of these are to

00:48:45,490 --> 00:48:50,830
prevent someone to forget to prevent you

00:48:48,609 --> 00:48:51,340
at the first place to from forgetting

00:48:50,830 --> 00:48:54,850
something

00:48:51,340 --> 00:48:57,670
or tomorrow another another person is

00:48:54,850 --> 00:49:01,270
coming new developer came he knows this

00:48:57,670 --> 00:49:06,430
part but forgot or didn't know something

00:49:01,270 --> 00:49:12,100
from another about the other part and

00:49:06,430 --> 00:49:16,330
domain isolation so basically if you

00:49:12,100 --> 00:49:21,460
have some module the other developers

00:49:16,330 --> 00:49:23,230
shouldn't know much about that module

00:49:21,460 --> 00:49:25,840
just use it with some convenience

00:49:23,230 --> 00:49:28,450
methods simply less simple application

00:49:25,840 --> 00:49:31,480
we have a football game class let's say

00:49:28,450 --> 00:49:35,740
and you have two convenience methods

00:49:31,480 --> 00:49:39,550
pass and shoot you can write a such a

00:49:35,740 --> 00:49:42,360
generic method like action and you get

00:49:39,550 --> 00:49:48,340
type right that would be beautiful and

00:49:42,360 --> 00:49:51,030
less code but why use this and makes

00:49:48,340 --> 00:49:51,030
this private

00:49:56,890 --> 00:50:03,829
exactly you cannot pass invalid value

00:50:00,199 --> 00:50:07,489
since this is PHP you cannot ensure that

00:50:03,829 --> 00:50:10,069
I'm passing this some someone came and

00:50:07,489 --> 00:50:12,680
um maybe you came and passing three

00:50:10,069 --> 00:50:15,079
what's Type three maybe this will crash

00:50:12,680 --> 00:50:17,420
your application end up in inconsistent

00:50:15,079 --> 00:50:21,709
state or lose the ball you are playing

00:50:17,420 --> 00:50:24,739
football and where's the ball so and

00:50:21,709 --> 00:50:27,430
another thing is I don't have to know

00:50:24,739 --> 00:50:30,920
what what are these I don't have to know

00:50:27,430 --> 00:50:32,660
the constants the info the other

00:50:30,920 --> 00:50:36,920
infirmity tail information about this

00:50:32,660 --> 00:50:39,259
just pass okay everything else and yes

00:50:36,920 --> 00:50:41,890
this is using the internal method but

00:50:39,259 --> 00:50:44,979
it's easy to use and I don't need to

00:50:41,890 --> 00:50:48,229
publish that what if I change this later

00:50:44,979 --> 00:50:50,869
what if the logic changes I should keep

00:50:48,229 --> 00:50:54,190
the logic inside my domain inside this

00:50:50,869 --> 00:50:58,430
football game class inside the order

00:50:54,190 --> 00:51:01,519
service class so if for example as I

00:50:58,430 --> 00:51:03,680
told if we add some other status in the

00:51:01,519 --> 00:51:11,809
state machine the order is processed but

00:51:03,680 --> 00:51:15,170
is in this how was it when someone

00:51:11,809 --> 00:51:17,989
complains in the complaining status okay

00:51:15,170 --> 00:51:21,769
so we added a status or added escalated

00:51:17,989 --> 00:51:22,969
to two management's state and everyone

00:51:21,769 --> 00:51:26,619
should know ok

00:51:22,969 --> 00:51:28,940
it is passing from payment status to

00:51:26,619 --> 00:51:30,890
escalation status everyone should be

00:51:28,940 --> 00:51:34,519
notified that there's new status

00:51:30,890 --> 00:51:37,219
escalation no hide that payment ok then

00:51:34,519 --> 00:51:39,170
your applicated your class your service

00:51:37,219 --> 00:51:42,380
should decide what is the next status

00:51:39,170 --> 00:51:44,599
not not half of the not half of the

00:51:42,380 --> 00:51:46,190
class half of other developers from

00:51:44,599 --> 00:51:49,279
other departments they don't have to

00:51:46,190 --> 00:51:54,259
know just make it easy also I was saying

00:51:49,279 --> 00:51:57,769
yesterday the more easier your class is

00:51:54,259 --> 00:52:00,529
your API is the easier it will get

00:51:57,769 --> 00:52:03,410
adopted for example you develop this and

00:52:00,529 --> 00:52:06,739
old API and you develop new one yours is

00:52:03,410 --> 00:52:09,060
great it's beautiful but you don't have

00:52:06,739 --> 00:52:12,630
examples or it's difficult to use

00:52:09,060 --> 00:52:14,820
like you have to read how to use it

00:52:12,630 --> 00:52:17,550
there are no examples that nobody will

00:52:14,820 --> 00:52:20,130
use your API everyone will continue

00:52:17,550 --> 00:52:23,220
using the old API so if you provide some

00:52:20,130 --> 00:52:29,940
examples and make it easy it will get

00:52:23,220 --> 00:52:32,550
used example what's wrong with this I'm

00:52:29,940 --> 00:52:35,820
saying cache invalidate delete this item

00:52:32,550 --> 00:52:38,580
from cache this is my user prefix yes as

00:52:35,820 --> 00:52:41,100
an example and so I'm building my key

00:52:38,580 --> 00:52:45,000
here okay read this cache is very

00:52:41,100 --> 00:52:48,240
generic good good for you but for

00:52:45,000 --> 00:52:50,880
example how maybe tomorrow I will add a

00:52:48,240 --> 00:52:53,880
different prefix here or maybe some

00:52:50,880 --> 00:52:58,220
Department will decide to add a prefix

00:52:53,880 --> 00:53:01,830
for session and creates his own prefix

00:52:58,220 --> 00:53:05,010
which collides with this that's a big

00:53:01,830 --> 00:53:09,390
problem so instead of that which one is

00:53:05,010 --> 00:53:10,260
more easy to use which is more

00:53:09,390 --> 00:53:13,200
management

00:53:10,260 --> 00:53:16,380
this one is more management because this

00:53:13,200 --> 00:53:18,780
is the sorry user cache it should be

00:53:16,380 --> 00:53:21,210
both of them are user cache or maybe no

00:53:18,780 --> 00:53:23,880
this is user cache a specific class

00:53:21,210 --> 00:53:26,640
that's responsible for users or user

00:53:23,880 --> 00:53:29,250
caching this one is real easy to use

00:53:26,640 --> 00:53:33,750
again reading from cache I to read this

00:53:29,250 --> 00:53:36,990
I need to copy this whole code

00:53:33,750 --> 00:53:41,400
everywhere instead why not just get user

00:53:36,990 --> 00:53:43,290
that's much simpler and less errors less

00:53:41,400 --> 00:53:45,980
collision this is just an example you

00:53:43,290 --> 00:53:52,230
can extrapolate it to any other domain

00:53:45,980 --> 00:53:55,770
how about time so we are almost out of

00:53:52,230 --> 00:54:00,120
time so let's I think we are almost over

00:53:55,770 --> 00:54:03,330
so the systems can wear out with time

00:54:00,120 --> 00:54:06,840
due to memory leaks etc and restarting

00:54:03,330 --> 00:54:10,980
usually helps yes so that's one method

00:54:06,840 --> 00:54:14,220
I'm saying the formal methods from from

00:54:10,980 --> 00:54:16,740
electronics design so this is

00:54:14,220 --> 00:54:19,290
interesting exception failures unhandled

00:54:16,740 --> 00:54:21,120
exceptions unhandled edge cases this is

00:54:19,290 --> 00:54:22,870
not on the software exceptions but edge

00:54:21,120 --> 00:54:26,070
cases mainly

00:54:22,870 --> 00:54:28,920
are causing 60% of all system crashes

00:54:26,070 --> 00:54:31,900
listen official number official

00:54:28,920 --> 00:54:34,270
statistic and 50% of security

00:54:31,900 --> 00:54:36,640
vulnerabilities the SQL injection

00:54:34,270 --> 00:54:39,880
yeah SQL injection why because you

00:54:36,640 --> 00:54:45,370
didn't think that someone will add drop

00:54:39,880 --> 00:54:48,850
table there okay so to handle edge cases

00:54:45,370 --> 00:54:51,400
these are the best methods for handling

00:54:48,850 --> 00:54:55,690
the edge cases code review during code

00:54:51,400 --> 00:54:57,970
review you can set up some guidelines to

00:54:55,690 --> 00:55:01,930
check if that code is verifying all the

00:54:57,970 --> 00:55:04,450
edge cases also you can verify that you

00:55:01,930 --> 00:55:06,570
using unit tests trying to input invalid

00:55:04,450 --> 00:55:09,760
data or some corner cases and

00:55:06,570 --> 00:55:12,640
integration tests of course so let's

00:55:09,760 --> 00:55:15,550
make a sample very simple code review

00:55:12,640 --> 00:55:17,230
checklist like all corner cases are

00:55:15,550 --> 00:55:19,840
handled when you are reviewing the code

00:55:17,230 --> 00:55:23,320
you see okay this is no there is no else

00:55:19,840 --> 00:55:27,370
well you say if but what is else or you

00:55:23,320 --> 00:55:29,140
are not validating the input all numbers

00:55:27,370 --> 00:55:32,110
should be constants what if we change it

00:55:29,140 --> 00:55:35,920
or it's not readable no hard coded

00:55:32,110 --> 00:55:39,220
numbers or strings all errors are logged

00:55:35,920 --> 00:55:41,950
and warning displayed to the user or to

00:55:39,220 --> 00:55:43,510
administrator whatever and parameters

00:55:41,950 --> 00:55:46,630
and input is valid data

00:55:43,510 --> 00:55:48,700
so the code review check this should be

00:55:46,630 --> 00:55:51,100
small enough so you remember everything

00:55:48,700 --> 00:55:57,330
and you don't spend too much time on it

00:55:51,100 --> 00:56:02,050
but this will prevent lots of problems

00:55:57,330 --> 00:56:06,220
so so much for the coding any questions

00:56:02,050 --> 00:56:08,710
about that part cool so tools you can

00:56:06,220 --> 00:56:12,550
achieve 99 percent reliability using

00:56:08,710 --> 00:56:16,540
proper tooling for PHP for example if

00:56:12,550 --> 00:56:20,140
you enforce type checking in PHP you can

00:56:16,540 --> 00:56:24,220
actually handle 99% of all errors that

00:56:20,140 --> 00:56:27,880
PHP has right wrap our same for

00:56:24,220 --> 00:56:30,550
JavaScript if you use some tools for

00:56:27,880 --> 00:56:36,130
JavaScript type checking again you are a

00:56:30,550 --> 00:56:36,700
lot a lot safer so you can use a tools

00:56:36,130 --> 00:56:39,400
at that

00:56:36,700 --> 00:56:43,210
tools and techniques like using or using

00:56:39,400 --> 00:56:46,750
proven techniques and components Quality

00:56:43,210 --> 00:56:49,890
Assurance testing making it simple the

00:56:46,750 --> 00:56:52,869
simpler is designed the better the less

00:56:49,890 --> 00:56:55,900
items will fail as I told if you want to

00:56:52,869 --> 00:56:58,480
add a new server you can think oh that's

00:56:55,900 --> 00:57:01,810
a new point of failure why should I do

00:56:58,480 --> 00:57:05,530
this or maybe just make it simpler okay

00:57:01,810 --> 00:57:09,099
not fancy but fault tolerant so you can

00:57:05,530 --> 00:57:13,410
use analysis tools and good development

00:57:09,099 --> 00:57:18,040
environment both for PHP and JavaScript

00:57:13,410 --> 00:57:21,480
this this helps a lot so proven

00:57:18,040 --> 00:57:24,280
techniques proven libraries frameworks

00:57:21,480 --> 00:57:25,150
but use with caution because proven

00:57:24,280 --> 00:57:30,310
means old

00:57:25,150 --> 00:57:32,859
so if typically yes but if five years

00:57:30,310 --> 00:57:35,109
ago it was very robust but what if you

00:57:32,859 --> 00:57:37,180
use it now probably everything has

00:57:35,109 --> 00:57:40,089
changed so maybe you can use it now so

00:57:37,180 --> 00:57:43,960
it's up to you you have to check it or

00:57:40,089 --> 00:57:50,319
find new proven systems or prove you by

00:57:43,960 --> 00:57:54,460
yourself I told this oh sorry sorry

00:57:50,319 --> 00:57:57,400
sorry small question these are the

00:57:54,460 --> 00:58:07,089
techniques and how do you think which

00:57:57,400 --> 00:58:11,349
one is the best for catching errors no

00:58:07,089 --> 00:58:17,970
more beer for you okay well what is the

00:58:11,349 --> 00:58:22,900
best integration test well who else

00:58:17,970 --> 00:58:24,640
what review good who else what else okay

00:58:22,900 --> 00:58:30,450
so this is the answer

00:58:24,640 --> 00:58:35,980
what review actually can prevent 60% of

00:58:30,450 --> 00:58:40,770
errors before testing before QA

00:58:35,980 --> 00:58:45,310
Department starts checking oh sorry I

00:58:40,770 --> 00:58:48,700
will rephrase the code review could fix

00:58:45,310 --> 00:58:49,700
60% of all errors that were caught by

00:58:48,700 --> 00:58:53,059
testers

00:58:49,700 --> 00:58:55,910
this is official study by Dell they

00:58:53,059 --> 00:58:58,730
started code reviewing and they found

00:58:55,910 --> 00:59:01,819
that number of errors that the tester

00:58:58,730 --> 00:59:03,770
started catching reduced dramatically so

00:59:01,819 --> 00:59:08,089
and these are the others integration

00:59:03,770 --> 00:59:10,400
tests are the second best good so there

00:59:08,089 --> 00:59:13,520
are tools for type safety threat safety

00:59:10,400 --> 00:59:16,069
security finding edge cases finding

00:59:13,520 --> 00:59:20,569
memory leaks and code coverage

00:59:16,069 --> 00:59:26,270
these tools are some sonarqube PHP Stan

00:59:20,569 --> 00:59:29,990
Jas hint code linters and development

00:59:26,270 --> 00:59:32,420
environment warnings so no more most of

00:59:29,990 --> 00:59:35,930
us have to deal with legacy code right

00:59:32,420 --> 00:59:38,540
which has lots of warnings but it's

00:59:35,930 --> 00:59:40,430
important to look at them okay there are

00:59:38,540 --> 00:59:41,930
hundreds of warnings collected but if

00:59:40,430 --> 00:59:46,160
you are starting a new class at least

00:59:41,930 --> 00:59:49,730
you should hope you should look at those

00:59:46,160 --> 00:59:54,079
warnings these are actually the is this

00:59:49,730 --> 00:59:56,780
is doing the what that does for but for

00:59:54,079 --> 00:59:58,280
free it says okay look there's no

00:59:56,780 --> 01:00:01,940
default no type checking no

00:59:58,280 --> 01:00:05,960
initialization wrong type expecting int

01:00:01,940 --> 01:00:10,940
but passing string these IDs cell

01:00:05,960 --> 01:00:13,099
telling that you for free okay thank you

01:00:10,940 --> 01:00:15,580
very much thanks for coming and

01:00:13,099 --> 01:00:23,980
participation

01:00:15,580 --> 01:00:25,010
[Music]

01:00:23,980 --> 01:00:34,679
[Applause]

01:00:25,010 --> 01:00:34,679

YouTube URL: https://www.youtube.com/watch?v=9IRKjBJybuo


