Title: "High-Performance PHP with HipHop" - Steve Kamerman | IPC13
Publication date: 2016-06-09
Playlist: International PHP Conference 2013
Description: 
	PHP ist keine High-Performance-Sprache, aber deswegen benutzen wir es auch nicht. Wir nutzen PHP weil es sich großartig für Rapid Application Development eignet und eine massive Community hinter sich stehen hat.

More information: https://phpconference.com/en/
Captions: 
	00:00:05,270 --> 00:00:11,429
good morning my name is when I am a PHP

00:00:09,719 --> 00:00:13,769
developer software architect

00:00:11,429 --> 00:00:15,750
infrastructure guy and the co-founder of

00:00:13,769 --> 00:00:17,760
a company called SI entra mobile where

00:00:15,750 --> 00:00:19,980
the guys that maintain the warfel

00:00:17,760 --> 00:00:21,359
project if you've ever heard of that my

00:00:19,980 --> 00:00:23,910
business partner luca spoke for the

00:00:21,359 --> 00:00:26,849
keynote yesterday so so i'm gonna be

00:00:23,910 --> 00:00:28,439
talking about hip hop for PHP and how to

00:00:26,849 --> 00:00:33,469
get high performance PHP and why you

00:00:28,439 --> 00:00:35,480
might want high performance fee right so

00:00:33,469 --> 00:00:39,480
Facebook is the quintessential

00:00:35,480 --> 00:00:42,660
large-scale PHP site right it's gets

00:00:39,480 --> 00:00:44,489
tons of traffic in 2008 it hit 100

00:00:42,660 --> 00:00:46,309
million active users and Facebook

00:00:44,489 --> 00:00:51,360
realized that they have a big problem

00:00:46,309 --> 00:00:53,129
the the problem is that they had

00:00:51,360 --> 00:00:54,360
explosive growth and they didn't even

00:00:53,129 --> 00:00:56,460
have enough people to put servers in

00:00:54,360 --> 00:00:58,320
their racks fast enough to account for

00:00:56,460 --> 00:00:59,850
their growth rate so they literally

00:00:58,320 --> 00:01:03,629
couldn't react to the amount of growth

00:00:59,850 --> 00:01:04,830
they were getting so in the process they

00:01:03,629 --> 00:01:06,720
profiled their whole site and they

00:01:04,830 --> 00:01:09,479
realized that the problem was page

00:01:06,720 --> 00:01:11,700
generation so some of their stuff was

00:01:09,479 --> 00:01:14,430
written in C++ already they profiled

00:01:11,700 --> 00:01:15,990
MySQL they profiled their load balancers

00:01:14,430 --> 00:01:17,490
and everything else involved and said

00:01:15,990 --> 00:01:19,500
you know what is slowing out our system

00:01:17,490 --> 00:01:22,950
and they found that it was PHP it was

00:01:19,500 --> 00:01:24,450
page generation not that it was PHP it's

00:01:22,950 --> 00:01:26,880
not that it was PHP's fault it's that

00:01:24,450 --> 00:01:29,250
every sight every page view on Facebook

00:01:26,880 --> 00:01:30,450
is dynamic so when you see even a

00:01:29,250 --> 00:01:32,189
fragment of a page you might have your

00:01:30,450 --> 00:01:35,579
friends friends on it or comments from

00:01:32,189 --> 00:01:37,770
from other people and so they profiled

00:01:35,579 --> 00:01:39,689
their PHP and they said what is it in

00:01:37,770 --> 00:01:41,990
PHP that's causing things to go so slow

00:01:39,689 --> 00:01:44,880
and they found that twenty percent of

00:01:41,990 --> 00:01:48,060
the time spent in PHP was spent in

00:01:44,880 --> 00:01:49,649
native code so you know string position

00:01:48,060 --> 00:01:51,210
and these types of things native calls

00:01:49,649 --> 00:01:53,880
that are already in C and C++ and

00:01:51,210 --> 00:01:55,979
they're already optimized and the eighty

00:01:53,880 --> 00:01:57,930
percent that was remaining was all in

00:01:55,979 --> 00:02:00,979
interpreted code so maybe iterating over

00:01:57,930 --> 00:02:03,540
some iterator or something like that and

00:02:00,979 --> 00:02:04,710
so their challenge was how can we how

00:02:03,540 --> 00:02:06,299
can we speed up that eighty percent of

00:02:04,710 --> 00:02:09,030
the time and at the time they realized

00:02:06,299 --> 00:02:11,459
that if they stretch if they they shrink

00:02:09,030 --> 00:02:13,110
that eighty percent down to zero they'll

00:02:11,459 --> 00:02:13,350
only be left with the twenty percent in

00:02:13,110 --> 00:02:14,670
NATO

00:02:13,350 --> 00:02:16,350
code and that would be a five times

00:02:14,670 --> 00:02:21,930
increase in speed if they could pull it

00:02:16,350 --> 00:02:24,360
off so why is PHP so slow well first of

00:02:21,930 --> 00:02:25,920
all well okay first of all it's an

00:02:24,360 --> 00:02:27,360
interpreted language so it's not like

00:02:25,920 --> 00:02:32,820
you're writing this in SI units getting

00:02:27,360 --> 00:02:35,460
compiled down so sim so PHP uses symbol

00:02:32,820 --> 00:02:36,780
table lookups which means that I use a

00:02:35,460 --> 00:02:38,160
lot of symbol table lookups which means

00:02:36,780 --> 00:02:40,170
that every variable you use or every

00:02:38,160 --> 00:02:42,120
function that you call ends up in

00:02:40,170 --> 00:02:44,070
pulling this big hash of all the

00:02:42,120 --> 00:02:45,600
possible variables that might exist in

00:02:44,070 --> 00:02:47,070
that scope and then it goes and finds

00:02:45,600 --> 00:02:48,300
that variable and then it goes and

00:02:47,070 --> 00:02:49,410
figures out where the memory is and then

00:02:48,300 --> 00:02:51,750
it reads that memory and their returns

00:02:49,410 --> 00:02:53,220
the value and that's only for one of the

00:02:51,750 --> 00:02:54,630
variables if you have a let's say you

00:02:53,220 --> 00:02:57,270
call a function that takes four

00:02:54,630 --> 00:02:58,980
arguments a symbol table lookup occurs

00:02:57,270 --> 00:03:00,540
for both the function and each of the

00:02:58,980 --> 00:03:02,640
four arguments and so this is very slow

00:03:00,540 --> 00:03:05,460
PHP doesn't optimize this very much

00:03:02,640 --> 00:03:08,790
other interpreted languages like Python

00:03:05,460 --> 00:03:10,080
are far more efficient at this it also

00:03:08,790 --> 00:03:12,030
doesn't have any static binding

00:03:10,080 --> 00:03:15,000
whatsoever what that means is if you use

00:03:12,030 --> 00:03:17,220
a constant there's no way for PHP to

00:03:15,000 --> 00:03:19,110
guarantee the value of that constant and

00:03:17,220 --> 00:03:21,690
so in a normal language at a normal

00:03:19,110 --> 00:03:23,070
compiled language you would take you

00:03:21,690 --> 00:03:24,420
would replace the variable name at

00:03:23,070 --> 00:03:25,830
compile time with the value of the

00:03:24,420 --> 00:03:27,840
variable since it's constant it can't

00:03:25,830 --> 00:03:30,300
ever change there's no point in going to

00:03:27,840 --> 00:03:32,610
look up its value but PHP is still PHP

00:03:30,300 --> 00:03:37,200
still references the symbol table for

00:03:32,610 --> 00:03:38,370
constants so that's another problem to

00:03:37,200 --> 00:03:42,170
complicate matters we have dynamic

00:03:38,370 --> 00:03:45,390
typing in PHP so even in an opcode cash

00:03:42,170 --> 00:03:47,010
you can't infer the type of a variable

00:03:45,390 --> 00:03:49,260
or guarantee that it will stay the same

00:03:47,010 --> 00:03:51,360
so you might have a variable called foo

00:03:49,260 --> 00:03:53,820
it might be a string at this moment than

00:03:51,360 --> 00:03:55,740
an int in the next and and we'll get

00:03:53,820 --> 00:03:58,760
into a little bit more about why that's

00:03:55,740 --> 00:04:01,770
particularly problem something in PHP

00:03:58,760 --> 00:04:06,090
and lastly is the share nothing

00:04:01,770 --> 00:04:07,560
architecture of PHP some people say this

00:04:06,090 --> 00:04:09,060
is a terrible ideas and people say it's

00:04:07,560 --> 00:04:12,420
a great idea what it means is that

00:04:09,060 --> 00:04:14,250
nothing is shared across requests except

00:04:12,420 --> 00:04:17,910
maybe the session or something you store

00:04:14,250 --> 00:04:19,650
in some other cash and so every time a

00:04:17,910 --> 00:04:21,450
request comes in it needs to completely

00:04:19,650 --> 00:04:22,950
regenerate all the objects everything

00:04:21,450 --> 00:04:24,960
needs to be reinstated right and that's

00:04:22,950 --> 00:04:27,450
expensive the benefit of shared nothing

00:04:24,960 --> 00:04:28,830
architecture is that you can see

00:04:27,450 --> 00:04:30,240
horizontally you can throw a thousand

00:04:28,830 --> 00:04:34,100
more servers in and it will pick up the

00:04:30,240 --> 00:04:36,360
load I'll be a little slow more slowly

00:04:34,100 --> 00:04:37,320
some people continue to argue with me

00:04:36,360 --> 00:04:39,420
about whether shared nothing

00:04:37,320 --> 00:04:40,980
architecture is a good idea but then I

00:04:39,420 --> 00:04:43,290
would point them to the example of

00:04:40,980 --> 00:04:46,260
Python and fights on the most common

00:04:43,290 --> 00:04:49,170
framework as far as i know is Django and

00:04:46,260 --> 00:04:51,330
Django actually re-engineered itself to

00:04:49,170 --> 00:04:53,130
prevent sharing information because

00:04:51,330 --> 00:04:54,330
normally information is persisted across

00:04:53,130 --> 00:04:56,220
requests and they would another way to

00:04:54,330 --> 00:04:57,150
destroy everything every time so they

00:04:56,220 --> 00:04:59,010
could have this shared nothing

00:04:57,150 --> 00:05:00,570
architecture so that's an example of

00:04:59,010 --> 00:05:01,890
someone that came with the shared

00:05:00,570 --> 00:05:08,880
everything and went back to share

00:05:01,890 --> 00:05:09,960
nothing so in 2008 to 2010 Facebook was

00:05:08,880 --> 00:05:11,280
trying to solve this problem of their

00:05:09,960 --> 00:05:13,860
traffic right I said they had a hundred

00:05:11,280 --> 00:05:15,840
million active users and they were

00:05:13,860 --> 00:05:18,030
reaching four hundred billion PHP

00:05:15,840 --> 00:05:20,030
generated pageviews per month that's a

00:05:18,030 --> 00:05:22,620
hell of a lot of page views that's

00:05:20,030 --> 00:05:24,480
154,000 page views per second you've got

00:05:22,620 --> 00:05:26,220
a thousand servers it's 150 for page

00:05:24,480 --> 00:05:28,740
views per second per server across a

00:05:26,220 --> 00:05:31,350
thousand servers so that's an absolutely

00:05:28,740 --> 00:05:33,450
astronomical number and part of the

00:05:31,350 --> 00:05:37,470
reason is that for each visit you might

00:05:33,450 --> 00:05:39,300
you might cause 10 or 20 page views so

00:05:37,470 --> 00:05:42,510
to speak HTTP requests because it's

00:05:39,300 --> 00:05:43,740
lazily loaded with Ajax and things so

00:05:42,510 --> 00:05:46,380
Facebook invented something called hip

00:05:43,740 --> 00:05:50,610
hop for PHP and they deployed it in 2010

00:05:46,380 --> 00:05:54,330
to fix their performance problem so you

00:05:50,610 --> 00:05:56,940
can see the first red line is the

00:05:54,330 --> 00:05:58,980
previous scrap that I had shown there at

00:05:56,940 --> 00:06:02,340
100 million active users and they went

00:05:58,980 --> 00:06:05,070
up in 2010 they had increased their

00:06:02,340 --> 00:06:06,720
traffic by a factor of six these are

00:06:05,070 --> 00:06:08,940
active users to these not just people

00:06:06,720 --> 00:06:10,290
that register and don't use it so my

00:06:08,940 --> 00:06:14,130
grandmother would not fall in this list

00:06:10,290 --> 00:06:15,360
probably but and then I'll get into what

00:06:14,130 --> 00:06:17,280
hip hop did for them but you can see

00:06:15,360 --> 00:06:19,740
their traffic has gone up to the point

00:06:17,280 --> 00:06:23,490
where they're doing you know over a

00:06:19,740 --> 00:06:26,010
billion active users now so what is hip

00:06:23,490 --> 00:06:28,410
hop or PHP hip hop for PHP is a

00:06:26,010 --> 00:06:31,410
multi-threaded embedded web server with

00:06:28,410 --> 00:06:35,040
a built in PHP runtime and so typically

00:06:31,410 --> 00:06:37,050
you have the zend PHP runtime which you

00:06:35,040 --> 00:06:39,270
know you install like anything else but

00:06:37,050 --> 00:06:40,600
hip-hop replaces the PHP is in PHP

00:06:39,270 --> 00:06:44,100
runtime and optimized

00:06:40,600 --> 00:06:46,360
is it there were two different

00:06:44,100 --> 00:06:49,720
generations of hip-hop or PHP there is

00:06:46,360 --> 00:06:52,660
HP HP see which literally translates PHP

00:06:49,720 --> 00:06:54,490
into c++ and I'll get more in detail on

00:06:52,660 --> 00:06:56,200
that and there's HH vm which is the new

00:06:54,490 --> 00:07:00,130
generation that's called the hip-hop

00:06:56,200 --> 00:07:03,760
virtual machine and it runs it i'll talk

00:07:00,130 --> 00:07:05,530
more about it in a bit typically you see

00:07:03,760 --> 00:07:09,460
a two to five times speed increase

00:07:05,530 --> 00:07:12,910
overstock PHP plus a pc now this was a

00:07:09,460 --> 00:07:15,460
stat that came prior to PHP 5.5 with

00:07:12,910 --> 00:07:17,410
appcache it came prior to PHP 5.4 as

00:07:15,460 --> 00:07:21,310
well so there's actually been a

00:07:17,410 --> 00:07:22,620
significant increase in PHP itself to

00:07:21,310 --> 00:07:25,180
give you an idea when they deployed it

00:07:22,620 --> 00:07:27,370
Facebook immediately saw 2x increase in

00:07:25,180 --> 00:07:29,020
speed and now they get a 9x increase in

00:07:27,370 --> 00:07:30,340
speed but they do a couple other things

00:07:29,020 --> 00:07:36,790
to cheat the system to make things

00:07:30,340 --> 00:07:39,310
faster hip hop for PHP compiler this is

00:07:36,790 --> 00:07:40,960
the first generation I started using hip

00:07:39,310 --> 00:07:42,730
hop or by the way I'm not affiliated

00:07:40,960 --> 00:07:43,960
with Facebook I don't develop hip hop I

00:07:42,730 --> 00:07:46,480
have no vested interest in this other

00:07:43,960 --> 00:07:50,040
than it making my services faster so i

00:07:46,480 --> 00:07:53,890
started using hip hop 18 months ago and

00:07:50,040 --> 00:07:56,290
in indy was in this stage of HP HP see

00:07:53,890 --> 00:07:58,600
which means that it translates every

00:07:56,290 --> 00:08:02,020
line line for line from PHP into c++

00:07:58,600 --> 00:08:04,060
human readable c++ and in doing so it

00:08:02,020 --> 00:08:06,430
actually keeps the same class names that

00:08:04,060 --> 00:08:08,080
you had in PHP in the c++ side so in

00:08:06,430 --> 00:08:10,720
facebook this created a very interesting

00:08:08,080 --> 00:08:13,180
opportunity for them they could compile

00:08:10,720 --> 00:08:15,520
their PHP code in the front end and then

00:08:13,180 --> 00:08:19,120
reuse those same classes and c++ in the

00:08:15,520 --> 00:08:23,230
back end with their server guys so

00:08:19,120 --> 00:08:25,390
dynamic typing makes down compiling PHP

00:08:23,230 --> 00:08:29,320
and C++ very difficult so if you imagine

00:08:25,390 --> 00:08:32,050
you had a function called who and it

00:08:29,320 --> 00:08:34,479
takes a variable called bar right this

00:08:32,050 --> 00:08:36,400
function there's no way to guarantee the

00:08:34,479 --> 00:08:39,010
type of the parameter that you pass it

00:08:36,400 --> 00:08:41,469
so if we turn it into C++ what variable

00:08:39,010 --> 00:08:44,350
type do you use for the parameter so ah

00:08:41,469 --> 00:08:46,150
they came up with this actually PHP

00:08:44,350 --> 00:08:48,610
itself has as far as I know has this

00:08:46,150 --> 00:08:50,530
concept of a variant which is a variable

00:08:48,610 --> 00:08:52,420
that can represent any possible variable

00:08:50,530 --> 00:08:53,960
type in PHP but that's not really

00:08:52,420 --> 00:08:56,840
efficient so

00:08:53,960 --> 00:08:58,850
if if there's some way for the code to

00:08:56,840 --> 00:09:01,190
infer let's say the parameter that you

00:08:58,850 --> 00:09:04,010
passed to this function foo you

00:09:01,190 --> 00:09:06,560
initialize as an integer you could be

00:09:04,010 --> 00:09:08,030
reasonably assured that at some point

00:09:06,560 --> 00:09:10,040
that function will get called with this

00:09:08,030 --> 00:09:12,200
integer and so hip-hop would actually

00:09:10,040 --> 00:09:13,490
create two functions okay take one it

00:09:12,200 --> 00:09:15,500
would create one that takes a variant

00:09:13,490 --> 00:09:17,450
and one that takes an integer and

00:09:15,500 --> 00:09:19,160
because of C++ and overloading it

00:09:17,450 --> 00:09:21,320
function that gets called is dependent

00:09:19,160 --> 00:09:23,200
on the variables like a pass to it so it

00:09:21,320 --> 00:09:29,080
can make some big for some very fast

00:09:23,200 --> 00:09:31,670
code function parity is a big problem

00:09:29,080 --> 00:09:33,500
was a big problem with the first

00:09:31,670 --> 00:09:35,180
generation of hip hop because not all

00:09:33,500 --> 00:09:37,370
the functions were implemented things

00:09:35,180 --> 00:09:38,480
like eval and go to didn't make sense in

00:09:37,370 --> 00:09:42,740
the first place and they definitely

00:09:38,480 --> 00:09:44,660
don't make sense in C++ and there were a

00:09:42,740 --> 00:09:48,550
lot of extensions that were not compiled

00:09:44,660 --> 00:09:51,170
so every extension one by one had to be

00:09:48,550 --> 00:09:53,810
transitioned from normal PHP to hip hop

00:09:51,170 --> 00:09:57,140
or PHP and it's a difficult process as

00:09:53,810 --> 00:09:59,570
an example mysqli is not available even

00:09:57,140 --> 00:10:02,750
today I'm hip-hop for PHP the original

00:09:59,570 --> 00:10:04,670
mysql is and PDO is but my but facebook

00:10:02,750 --> 00:10:08,450
had no reason to port my sqli so they

00:10:04,670 --> 00:10:10,850
never did it so the biggest problem that

00:10:08,450 --> 00:10:13,220
I saw with HP HP see is the long

00:10:10,850 --> 00:10:14,660
compilation time my project which was

00:10:13,220 --> 00:10:16,580
fairly small it was a web service that

00:10:14,660 --> 00:10:18,830
I'll talk about in a little bit took

00:10:16,580 --> 00:10:20,750
about 10 minutes to compile literally

00:10:18,830 --> 00:10:22,310
the compile the PHP down to C++ and then

00:10:20,750 --> 00:10:23,900
I need to start the server maybe run

00:10:22,310 --> 00:10:25,760
some phpunit against it to make sure it

00:10:23,900 --> 00:10:30,950
still works and then hope for the best

00:10:25,760 --> 00:10:32,960
but Facebook took 20 minutes to compile

00:10:30,950 --> 00:10:35,390
their code base but it was over 100

00:10:32,960 --> 00:10:37,130
build machines so as you can imagine any

00:10:35,390 --> 00:10:39,950
change they make that has to have pushed

00:10:37,130 --> 00:10:41,510
pushed to production takes hundreds of

00:10:39,950 --> 00:10:46,390
hours or hundreds of minutes of

00:10:41,510 --> 00:10:46,390
compilation across their build cluster

00:10:47,350 --> 00:10:53,210
so what we did was the reason we use

00:10:50,660 --> 00:10:54,650
this is first of all in Facebook is one

00:10:53,210 --> 00:10:57,230
of my customers and so we need to make

00:10:54,650 --> 00:10:59,500
sure that whatever we do is compatible

00:10:57,230 --> 00:11:02,750
with Facebook's infrastructure and

00:10:59,500 --> 00:11:05,030
secondly we created a cloud service

00:11:02,750 --> 00:11:06,790
called warfel cloud which is a mobile

00:11:05,030 --> 00:11:09,010
device detection service so you

00:11:06,790 --> 00:11:11,080
pass us HTTP requests and we pass you

00:11:09,010 --> 00:11:12,400
back a JSON object that contains the

00:11:11,080 --> 00:11:14,290
properties of the device like screen

00:11:12,400 --> 00:11:16,240
resolution in which types of media it

00:11:14,290 --> 00:11:18,280
can play and that sort of thing and so

00:11:16,240 --> 00:11:20,980
this had to be very fast so people would

00:11:18,280 --> 00:11:22,060
use this on their website and it would

00:11:20,980 --> 00:11:24,130
actually have to make a call to our

00:11:22,060 --> 00:11:25,990
cloud and then come back before it can

00:11:24,130 --> 00:11:27,910
even generate the page so that could

00:11:25,990 --> 00:11:29,890
cause a serious bottleneck for our

00:11:27,910 --> 00:11:33,460
customers so we need to be very very low

00:11:29,890 --> 00:11:34,240
latency so we checked out hip hop I

00:11:33,460 --> 00:11:38,740
checked out a couple of other

00:11:34,240 --> 00:11:42,070
technologies and it we decided to use

00:11:38,740 --> 00:11:43,690
hip hop because it Apache the latency

00:11:42,070 --> 00:11:46,060
for a typical request to my service was

00:11:43,690 --> 00:11:49,270
about 20 milliseconds well the entire

00:11:46,060 --> 00:11:51,580
duration of the of the generation page

00:11:49,270 --> 00:11:53,980
generation and with hip hop it was two

00:11:51,580 --> 00:11:55,540
milliseconds so that's a ten times

00:11:53,980 --> 00:11:57,250
improvement in speed for me it's not

00:11:55,540 --> 00:11:59,650
because hip hop was ten times faster at

00:11:57,250 --> 00:12:01,510
processing the PHP necessarily but it

00:11:59,650 --> 00:12:03,100
was a lot less overhead because my PHP

00:12:01,510 --> 00:12:06,370
code base literally was turned into a

00:12:03,100 --> 00:12:08,770
web server so is much more efficient now

00:12:06,370 --> 00:12:10,960
it did have some stability issues and i

00:12:08,770 --> 00:12:16,630
had to craft a creative way to avoid

00:12:10,960 --> 00:12:19,210
them so so what i did was we use h a

00:12:16,630 --> 00:12:21,340
proxy the load balancer in front of our

00:12:19,210 --> 00:12:23,350
servers these were full nodes are

00:12:21,340 --> 00:12:25,300
individual virtual machines that are

00:12:23,350 --> 00:12:28,240
serving traffic for our web service and

00:12:25,300 --> 00:12:30,730
the load balancer is just balancing out

00:12:28,240 --> 00:12:33,130
traffic to each of them but since hip

00:12:30,730 --> 00:12:36,400
hop for PHP was relatively and stable

00:12:33,130 --> 00:12:37,780
when we started I had to run both hip

00:12:36,400 --> 00:12:39,310
hop and apache and I pointed the

00:12:37,780 --> 00:12:40,870
document root for both of those at the

00:12:39,310 --> 00:12:43,150
same code base so they both served the

00:12:40,870 --> 00:12:46,300
same code but of course one is compiled

00:12:43,150 --> 00:12:48,390
and when it's not and so if Apache I've

00:12:46,300 --> 00:12:51,970
hip hop were to fail I would fail over

00:12:48,390 --> 00:12:53,770
to Apache with a load balancer now to

00:12:51,970 --> 00:12:55,240
deal with the long compilation times

00:12:53,770 --> 00:12:57,010
that I talked about it takes about 10

00:12:55,240 --> 00:13:00,700
minutes for us to cop to compile our

00:12:57,010 --> 00:13:02,590
code base I wrote an API called H a

00:13:00,700 --> 00:13:05,290
proxy API which is an open source

00:13:02,590 --> 00:13:07,600
php-based API that you can download if

00:13:05,290 --> 00:13:12,790
you want and it allows me to do things

00:13:07,600 --> 00:13:15,490
like connect to a load balancer disable

00:13:12,790 --> 00:13:17,470
a server under that load balancer get

00:13:15,490 --> 00:13:19,209
some statistics on the load bouncer to

00:13:17,470 --> 00:13:21,069
make sure that

00:13:19,209 --> 00:13:23,619
enough nodes to carry the burden if I

00:13:21,069 --> 00:13:24,970
were to turn one off and then I can

00:13:23,619 --> 00:13:27,040
re-enable servers and this sort of thing

00:13:24,970 --> 00:13:29,290
so we scripted the whole thing it would

00:13:27,040 --> 00:13:30,639
go one server at a time recompiling our

00:13:29,290 --> 00:13:32,769
code base 10 minutes here two minutes

00:13:30,639 --> 00:13:34,899
there and a couple hours later or an

00:13:32,769 --> 00:13:40,899
hour and a half later hopefully always

00:13:34,899 --> 00:13:43,300
well so so the next generation of hip

00:13:40,899 --> 00:13:45,369
hop was called is called HH vm which is

00:13:43,300 --> 00:13:46,600
hip-hop virtual machine so unlike the

00:13:45,369 --> 00:13:49,629
previous version where you had to

00:13:46,600 --> 00:13:52,389
compile everything by hand down to C++

00:13:49,629 --> 00:13:56,379
and then run that hip-hop virtual

00:13:52,389 --> 00:13:58,509
machine has an interpreter built in and

00:13:56,379 --> 00:14:00,850
I come just in time compiler built in

00:13:58,509 --> 00:14:03,639
and so it runs as a service on the

00:14:00,850 --> 00:14:05,889
system and iteratively compiles your

00:14:03,639 --> 00:14:10,149
code while it's running so if you were

00:14:05,889 --> 00:14:11,709
to turn on hip-hop our HH vm it would be

00:14:10,149 --> 00:14:14,410
interpreting the PHP files and serving

00:14:11,709 --> 00:14:17,490
immediately and in the process it would

00:14:14,410 --> 00:14:20,019
nicely I mean nice in terms of CPU time

00:14:17,490 --> 00:14:22,660
it would compile your code down to

00:14:20,019 --> 00:14:25,689
native code without this need for

00:14:22,660 --> 00:14:27,699
separate compilation one interesting

00:14:25,689 --> 00:14:31,329
thing is that the byte code cache

00:14:27,699 --> 00:14:34,569
survives a server restart so unlike with

00:14:31,329 --> 00:14:37,869
PHP I one like with a PC for example or

00:14:34,569 --> 00:14:40,480
up cash for PHP 5.5 if you restart

00:14:37,869 --> 00:14:44,170
apache or engine X then your bytecode

00:14:40,480 --> 00:14:45,759
goes away but with HH vm it survives in

00:14:44,170 --> 00:14:51,279
the form of a sequel light file that

00:14:45,759 --> 00:14:53,889
sits on the file system oh yeah and i'm

00:14:51,279 --> 00:14:54,939
happy to take questions as i go so if

00:14:53,889 --> 00:15:00,749
you have a question raise your hand I'm

00:14:54,939 --> 00:15:03,369
happy to answer it for you so this is

00:15:00,749 --> 00:15:06,339
some sort of an approximation of how HH

00:15:03,369 --> 00:15:08,259
vm works we take a request in its

00:15:06,339 --> 00:15:11,319
received in the embedded web server and

00:15:08,259 --> 00:15:13,240
if there's not already native code

00:15:11,319 --> 00:15:14,829
that's been generated for it it runs it

00:15:13,240 --> 00:15:18,220
through the interpreter which generates

00:15:14,829 --> 00:15:20,799
bytecode and then runs the bytecode and

00:15:18,220 --> 00:15:23,889
in a separate thread down compiles it

00:15:20,799 --> 00:15:25,540
into native code and it can it can

00:15:23,889 --> 00:15:27,790
there's a warm-up phase in which its

00:15:25,540 --> 00:15:29,620
spending some time watching how the PHP

00:15:27,790 --> 00:15:31,569
is actually executing and doing type

00:15:29,620 --> 00:15:32,710
inference to say like what did your

00:15:31,569 --> 00:15:34,270
variable in the per niente

00:15:32,710 --> 00:15:38,520
I expected it to be an int but maybe

00:15:34,270 --> 00:15:38,520
it's a string and it can do that for us

00:15:38,970 --> 00:15:44,080
okay so what kind of performance

00:15:41,580 --> 00:15:47,200
differences do we see between HH vm and

00:15:44,080 --> 00:15:49,810
hip-hop and HP HP C so this is what

00:15:47,200 --> 00:15:51,580
Facebook real found out that the

00:15:49,810 --> 00:15:54,580
baseline here a hundred percent is the

00:15:51,580 --> 00:15:57,280
previous generation HP HP c and the

00:15:54,580 --> 00:15:59,350
yellow line represents HH vm and so

00:15:57,280 --> 00:16:02,290
comparatively they introduced it early

00:15:59,350 --> 00:16:05,080
on but it was slow because of this

00:16:02,290 --> 00:16:07,570
iterative down compiling stuff it took a

00:16:05,080 --> 00:16:11,020
while for them to catch up but in 2012

00:16:07,570 --> 00:16:13,570
they reached the same speed as HH HP HP

00:16:11,020 --> 00:16:15,520
see and they deployed it on their

00:16:13,570 --> 00:16:22,240
servers i believe it was at the

00:16:15,520 --> 00:16:23,740
beginning of the year in 2013 this i R

00:16:22,240 --> 00:16:28,930
stands for intermediate representation

00:16:23,740 --> 00:16:32,830
and it's sort of like a hyper a very

00:16:28,930 --> 00:16:36,510
fast bytecode like Java or.net would

00:16:32,830 --> 00:16:36,510
turn it into so I can be run by the vm

00:16:39,240 --> 00:16:44,580
so optimizing PHP what can you do in

00:16:41,860 --> 00:16:46,360
your PHP code to make hip hop faster

00:16:44,580 --> 00:16:48,010
well first of all you need to think

00:16:46,360 --> 00:16:49,960
about type inference this is what the

00:16:48,010 --> 00:16:52,030
compiler does to try to like we say

00:16:49,960 --> 00:16:54,210
optimize functions specifically for the

00:16:52,030 --> 00:16:56,830
types of variables you're passing in

00:16:54,210 --> 00:16:58,690
what that means is you need to try to

00:16:56,830 --> 00:17:01,390
make an effort to keep your variables

00:16:58,690 --> 00:17:03,910
the same type now that presents a bit of

00:17:01,390 --> 00:17:05,260
a problem with PHP because most of the

00:17:03,910 --> 00:17:07,780
core functions or many of the Court

00:17:05,260 --> 00:17:09,070
functions return bool false on fail on

00:17:07,780 --> 00:17:11,110
failure even though they might otherwise

00:17:09,070 --> 00:17:13,480
return an integer for example string

00:17:11,110 --> 00:17:15,130
position will return an int if it finds

00:17:13,480 --> 00:17:16,990
the string the needle in the haystack

00:17:15,130 --> 00:17:19,510
but if it doesn't it will return bool

00:17:16,990 --> 00:17:20,709
false and that destroys the type

00:17:19,510 --> 00:17:22,540
inference I mean it destroys your

00:17:20,709 --> 00:17:23,980
variable type and now the compiler can't

00:17:22,540 --> 00:17:27,430
assume it's going to stay in into

00:17:23,980 --> 00:17:31,480
anymore so you do the best you can

00:17:27,430 --> 00:17:34,210
basically HH p.m. upgrades primitives

00:17:31,480 --> 00:17:36,430
this means that if your variable star

00:17:34,210 --> 00:17:38,950
doesn't int it may need to get upgraded

00:17:36,430 --> 00:17:40,320
to a variant because it got changed it

00:17:38,950 --> 00:17:42,910
somewhere along the line into a string

00:17:40,320 --> 00:17:46,150
and you strict comparison that that's

00:17:42,910 --> 00:17:48,700
important anyway in fact I'd say use

00:17:46,150 --> 00:17:50,530
when my developers don't use strict

00:17:48,700 --> 00:17:53,620
comparison it drives me nuts and I'll

00:17:50,530 --> 00:17:55,570
show you a couple of reasons why I'll

00:17:53,620 --> 00:17:57,580
take I'll let you take a few minutes to

00:17:55,570 --> 00:18:07,540
read through some of these examples to

00:17:57,580 --> 00:18:11,910
see the craziness of PHP some of my

00:18:07,540 --> 00:18:14,650
favorites are false equals true and this

00:18:11,910 --> 00:18:16,660
using string position as a bool and

00:18:14,650 --> 00:18:20,950
that's a terrible mistake that a lot of

00:18:16,660 --> 00:18:24,670
people make or using a string as an

00:18:20,950 --> 00:18:33,370
integer ironically this is not the same

00:18:24,670 --> 00:18:34,690
even though this is but so okay avoiding

00:18:33,370 --> 00:18:37,300
the global scope this is really

00:18:34,690 --> 00:18:38,590
important because in PHP everyone can

00:18:37,300 --> 00:18:42,400
access the global scope so you can just

00:18:38,590 --> 00:18:44,200
throw some random code in a PHP file and

00:18:42,400 --> 00:18:46,210
run it without side of any function or

00:18:44,200 --> 00:18:46,930
class but there's no guarantee that your

00:18:46,210 --> 00:18:48,550
variables aren't going to get

00:18:46,930 --> 00:18:50,860
overwritten it can get over it and buy

00:18:48,550 --> 00:18:53,560
something out of band too so let's say

00:18:50,860 --> 00:18:56,940
you have an exception handler and you

00:18:53,560 --> 00:18:59,290
initialize a variable as one and then

00:18:56,940 --> 00:19:00,670
somewhere along the line you print out

00:18:59,290 --> 00:19:02,290
that variable and expect it to be one

00:19:00,670 --> 00:19:03,640
well in the process you may have thrown

00:19:02,290 --> 00:19:05,470
an exception and in your exception

00:19:03,640 --> 00:19:06,820
handler you may have modified the global

00:19:05,470 --> 00:19:08,890
scope you could have change that

00:19:06,820 --> 00:19:10,480
variable from one to be and now all of a

00:19:08,890 --> 00:19:12,550
sudden the type has changed and so

00:19:10,480 --> 00:19:15,460
there's no way for the compiler to know

00:19:12,550 --> 00:19:18,580
during static analysis that that your

00:19:15,460 --> 00:19:21,640
variable it has retained its type so you

00:19:18,580 --> 00:19:23,830
can if you have to you can wrap your

00:19:21,640 --> 00:19:26,200
code to get it outside of the global

00:19:23,830 --> 00:19:28,240
scope that way it can't be messed with

00:19:26,200 --> 00:19:29,680
outside of the function but a better

00:19:28,240 --> 00:19:35,350
approach is just not to write crappy

00:19:29,680 --> 00:19:37,650
code so so unique classes functions and

00:19:35,350 --> 00:19:40,210
Constance this is important because

00:19:37,650 --> 00:19:41,920
although in PHP you can't have two

00:19:40,210 --> 00:19:43,840
classes with the same name at the same

00:19:41,920 --> 00:19:46,570
time you can certainly have more than

00:19:43,840 --> 00:19:48,220
one definition for a class for example I

00:19:46,570 --> 00:19:50,980
was working on a website that had a user

00:19:48,220 --> 00:19:53,170
class it was a model that represented

00:19:50,980 --> 00:19:56,050
the user you know table in the database

00:19:53,170 --> 00:19:59,920
and then I had to do some single sign-on

00:19:56,050 --> 00:20:01,930
integration and so with PHP BB

00:19:59,920 --> 00:20:04,300
I loaded up PHP bees library to poke in

00:20:01,930 --> 00:20:06,400
my user and i found out PHP vvd also has

00:20:04,300 --> 00:20:07,780
a user class and that causes a runtime

00:20:06,400 --> 00:20:10,840
error so now I need to make really nasty

00:20:07,780 --> 00:20:14,340
curl calls across localhost to be able

00:20:10,840 --> 00:20:16,780
to interact with another service so I

00:20:14,340 --> 00:20:20,080
don't know why the Facebook team seems

00:20:16,780 --> 00:20:22,630
to be a little bit adverse to namespaces

00:20:20,080 --> 00:20:24,640
but I personally think they're a great

00:20:22,630 --> 00:20:27,850
idea and HH vm supports them so my

00:20:24,640 --> 00:20:29,320
recommendation is use namespaces another

00:20:27,850 --> 00:20:30,640
good side effect is that your code won't

00:20:29,320 --> 00:20:34,320
work with really old versions of PHP

00:20:30,640 --> 00:20:39,490
that might not do what you want anyway

00:20:34,320 --> 00:20:42,490
so the if you have the class bar in two

00:20:39,490 --> 00:20:44,740
different namespaces they're not

00:20:42,490 --> 00:20:48,010
obviously ambiguous there they're unique

00:20:44,740 --> 00:20:51,370
because they have their name space so I

00:20:48,010 --> 00:20:53,620
like to call this concept of in PHP

00:20:51,370 --> 00:20:56,530
there's no real constants and less to

00:20:53,620 --> 00:20:58,510
class constant so I call this dynamic

00:20:56,530 --> 00:21:00,430
constants when you use define because

00:20:58,510 --> 00:21:02,640
you can define something that's supposed

00:21:00,430 --> 00:21:05,260
to be constant based on an expression or

00:21:02,640 --> 00:21:07,810
you could say if this then define as

00:21:05,260 --> 00:21:08,860
that if that then define is this but it

00:21:07,810 --> 00:21:10,600
really defeats the whole purpose of a

00:21:08,860 --> 00:21:13,510
constant because a constant is never

00:21:10,600 --> 00:21:16,420
changing so you've conditionally made a

00:21:13,510 --> 00:21:19,360
read only variable I guess you could say

00:21:16,420 --> 00:21:21,390
but the compiler can't determine what

00:21:19,360 --> 00:21:23,440
that variable type will be odd

00:21:21,390 --> 00:21:24,850
statically so it has to watch your code

00:21:23,440 --> 00:21:26,920
to figure that out and there's no

00:21:24,850 --> 00:21:27,910
guarantee that it's in a state well

00:21:26,920 --> 00:21:29,530
there is a guarantee that it will stay

00:21:27,910 --> 00:21:30,850
the same after it's been defined there's

00:21:29,530 --> 00:21:34,870
no guarantee as to how you're going to

00:21:30,850 --> 00:21:36,850
define it right and I can almost picture

00:21:34,870 --> 00:21:38,320
a request for undefined and redefine and

00:21:36,850 --> 00:21:39,970
in fact I bet you I could find somebody

00:21:38,320 --> 00:21:43,300
on Stack Overflow that's asked how you

00:21:39,970 --> 00:21:46,300
redefine something if they're truly

00:21:43,300 --> 00:21:50,620
constant use a constant and here's an

00:21:46,300 --> 00:21:52,480
example really simply of you know

00:21:50,620 --> 00:21:54,370
usually these types of constants are

00:21:52,480 --> 00:21:58,780
constant forever this will always n ever

00:21:54,370 --> 00:22:01,210
be I'm a real constant on my app config

00:21:58,780 --> 00:22:03,310
and if you really need this sort of like

00:22:01,210 --> 00:22:06,730
conditionally defined constant then

00:22:03,310 --> 00:22:07,960
stick it in some private storage and use

00:22:06,730 --> 00:22:10,990
it as a registry or something like that

00:22:07,960 --> 00:22:12,600
that is assuming you don't want to use

00:22:10,990 --> 00:22:20,190
dependency injection of things

00:22:12,600 --> 00:22:21,930
ah dynamic variables are a travesty has

00:22:20,190 --> 00:22:23,190
anybody actually used dynamic variables

00:22:21,930 --> 00:22:29,910
like this with a double dollar signs

00:22:23,190 --> 00:22:32,960
before for anything what's that okay for

00:22:29,910 --> 00:22:35,550
playing Yeah Yeah right I personally

00:22:32,960 --> 00:22:38,070
never found a use for them I mean I can

00:22:35,550 --> 00:22:39,570
see the use for a dynamic when you're

00:22:38,070 --> 00:22:41,580
accessing a property dynamically so you

00:22:39,570 --> 00:22:43,980
build the property name of a class

00:22:41,580 --> 00:22:46,260
dynamically and then go and fetch it but

00:22:43,980 --> 00:22:49,800
dynamic variables no I don't use them

00:22:46,260 --> 00:22:51,150
that's bad it's bad news so I the

00:22:49,800 --> 00:22:52,890
problem is that the compiler can't

00:22:51,150 --> 00:22:54,270
figure out what variable you're talking

00:22:52,890 --> 00:22:56,150
to you because it depends on a previous

00:22:54,270 --> 00:22:59,160
expression and there's no way to know

00:22:56,150 --> 00:23:00,780
extracting compact are difficult for hip

00:22:59,160 --> 00:23:04,560
hop for PHP as well because they both

00:23:00,780 --> 00:23:05,790
mess with the local scope and so hip hop

00:23:04,560 --> 00:23:08,570
doesn't try to keep track of which

00:23:05,790 --> 00:23:11,370
variables are in the local scope

00:23:08,570 --> 00:23:13,380
explicitly so if you call extract it has

00:23:11,370 --> 00:23:14,580
to unpack this array into the local

00:23:13,380 --> 00:23:15,870
scope and then it has to make sure it's

00:23:14,580 --> 00:23:17,400
not over writing things and that can

00:23:15,870 --> 00:23:20,340
change the variable types of existing

00:23:17,400 --> 00:23:21,690
variables and similarly compact will rip

00:23:20,340 --> 00:23:28,430
things out of the local scope and that's

00:23:21,690 --> 00:23:30,630
expensive to do okay so get defined

00:23:28,430 --> 00:23:33,300
defined VARs has anybody used this

00:23:30,630 --> 00:23:35,940
before outside of testing this is bad

00:23:33,300 --> 00:23:37,680
don't use this I would suggest if you're

00:23:35,940 --> 00:23:39,000
using yet defined of ours for non

00:23:37,680 --> 00:23:41,340
testing code then you should rewrite it

00:23:39,000 --> 00:23:43,590
before somebody sees it you don't know

00:23:41,340 --> 00:23:44,970
what it does it pulls out everything

00:23:43,590 --> 00:23:46,080
from the local scope so you can look at

00:23:44,970 --> 00:23:48,570
all the variables that are currently

00:23:46,080 --> 00:23:53,700
defined but it's extremely expensive to

00:23:48,570 --> 00:23:56,790
do this even for a normal PHP declaring

00:23:53,700 --> 00:23:58,080
class properties I can't think of a

00:23:56,790 --> 00:23:59,580
reason why you wouldn't declare a class

00:23:58,080 --> 00:24:01,500
property unless you have some sort of

00:23:59,580 --> 00:24:05,190
generic object that's there just the

00:24:01,500 --> 00:24:06,300
store data and so if if that's your case

00:24:05,190 --> 00:24:08,370
that you're actually just storing data

00:24:06,300 --> 00:24:10,290
on a generic object that's fine but

00:24:08,370 --> 00:24:13,530
generally speaking you shouldn't use

00:24:10,290 --> 00:24:15,360
undeclared properties and if you're not

00:24:13,530 --> 00:24:17,610
seeing PHP notices then you should be

00:24:15,360 --> 00:24:18,510
turning on PHP notices because these are

00:24:17,610 --> 00:24:21,180
things you shouldn't be doing in the

00:24:18,510 --> 00:24:23,370
first place another neat thing that hip

00:24:21,180 --> 00:24:24,390
hop does is it optimizes getters so if

00:24:23,370 --> 00:24:26,340
you have a function that does nothing

00:24:24,390 --> 00:24:28,970
but goes in

00:24:26,340 --> 00:24:31,730
the value of a property and returns it

00:24:28,970 --> 00:24:34,380
that is called a getter and it's fairly

00:24:31,730 --> 00:24:37,289
inefficient in normal PHP because

00:24:34,380 --> 00:24:38,429
accessing a property directly skips the

00:24:37,289 --> 00:24:40,529
whole round trip through the function

00:24:38,429 --> 00:24:43,679
but there's no way to make our breed

00:24:40,529 --> 00:24:45,840
only variable so to speak in PHP so if

00:24:43,679 --> 00:24:49,110
you make a getter it gets down compiled

00:24:45,840 --> 00:24:51,000
and hip-hop for PHP into a sort of sort

00:24:49,110 --> 00:24:52,980
of read only property and it's the same

00:24:51,000 --> 00:24:54,480
amount of machine instructions to access

00:24:52,980 --> 00:24:58,950
a getter as it is to access a real

00:24:54,480 --> 00:25:00,570
property so what's the performance gain

00:24:58,950 --> 00:25:04,710
the performance gain is less than five

00:25:00,570 --> 00:25:06,990
percent by using the different you know

00:25:04,710 --> 00:25:09,440
maintaining type types and things like

00:25:06,990 --> 00:25:11,820
that but it's still good practice anyway

00:25:09,440 --> 00:25:14,880
some suboptimal functions still work

00:25:11,820 --> 00:25:16,380
even eval and go to in HH p.m. so you

00:25:14,880 --> 00:25:17,880
might think i went hunting for this

00:25:16,380 --> 00:25:19,260
comic on the internet trying to find

00:25:17,880 --> 00:25:21,929
something good for my slide but i did

00:25:19,260 --> 00:25:27,630
not i found this on PHP's manual and the

00:25:21,929 --> 00:25:28,950
go to documentation so it's an example

00:25:27,630 --> 00:25:30,390
of why you don't use go to right here

00:25:28,950 --> 00:25:36,809
because the dinosaur can come and tackle

00:25:30,390 --> 00:25:39,090
your computer so there's another mode

00:25:36,809 --> 00:25:41,789
there's a mode in peach in hip hop for

00:25:39,090 --> 00:25:44,700
PHP that allows you to increase

00:25:41,789 --> 00:25:46,950
performance very easily you turn it on

00:25:44,700 --> 00:25:49,740
it's called repo authoritative mode and

00:25:46,950 --> 00:25:52,919
it means that once the files in your

00:25:49,740 --> 00:25:54,419
document root have been evaluated it

00:25:52,919 --> 00:25:56,399
assumes they've never changed and so

00:25:54,419 --> 00:25:58,289
it's sort of like a PC stat equals zero

00:25:56,399 --> 00:26:00,240
where it doesn't go back to make I oak

00:25:58,289 --> 00:26:02,340
also see if your PHP files have changed

00:26:00,240 --> 00:26:04,830
otherwise it normally behaves just like

00:26:02,340 --> 00:26:07,529
PHP if you change a file that file will

00:26:04,830 --> 00:26:11,760
be immediately processed and used in

00:26:07,529 --> 00:26:13,770
execution um the only thing that I found

00:26:11,760 --> 00:26:15,899
kind of annoying about this is that you

00:26:13,770 --> 00:26:18,450
have to manually delete the cache that

00:26:15,899 --> 00:26:21,179
hip hop creates because I if you recall

00:26:18,450 --> 00:26:23,250
I said that the opcode cash is stored

00:26:21,179 --> 00:26:26,610
between restarts it doesn't this it

00:26:23,250 --> 00:26:29,669
doesn't die with with the server so when

00:26:26,610 --> 00:26:30,840
you restart the service it'll keep using

00:26:29,669 --> 00:26:32,700
the old data so you need to delete the

00:26:30,840 --> 00:26:35,309
old cash and reanalyze it and I'm hoping

00:26:32,700 --> 00:26:36,780
I'm assuming that after Facebook sees me

00:26:35,309 --> 00:26:39,210
presenting this they'll they'll want to

00:26:36,780 --> 00:26:39,929
make a good tutorial on how to do this

00:26:39,210 --> 00:26:41,100
nicely

00:26:39,929 --> 00:26:45,419
is I haven't been able to figure it out

00:26:41,100 --> 00:26:48,929
very easily okay so the current state of

00:26:45,419 --> 00:26:53,279
hip hop hhv em to point to point zero

00:26:48,929 --> 00:26:56,279
was just released on October 17 and it's

00:26:53,279 --> 00:26:59,159
very close in function parity to PHP 5.4

00:26:56,279 --> 00:27:03,749
there were some old functions that they

00:26:59,159 --> 00:27:05,249
never felt like porting like string gets

00:27:03,749 --> 00:27:07,740
CSV or something like that getting a

00:27:05,249 --> 00:27:09,749
seat like parsing a CSV string into an

00:27:07,740 --> 00:27:12,600
array they finally ported this thing

00:27:09,749 --> 00:27:14,340
over they've brought in the

00:27:12,600 --> 00:27:17,159
internationalization extension which

00:27:14,340 --> 00:27:19,499
previously precluded you from using the

00:27:17,159 --> 00:27:21,809
zend framework to on hip hop because it

00:27:19,499 --> 00:27:23,159
required that extension and they've

00:27:21,809 --> 00:27:26,970
brought in a bunch more extensions that

00:27:23,159 --> 00:27:30,779
are fairly obscure now the performance

00:27:26,970 --> 00:27:33,929
of HH vm is nearly 55 times that of

00:27:30,779 --> 00:27:35,789
normal PHP for a typical application now

00:27:33,929 --> 00:27:38,580
i'm quoting facebook so you know take it

00:27:35,789 --> 00:27:40,470
for what it's worth the goal for

00:27:38,580 --> 00:27:43,850
facebook is to support the top 20

00:27:40,470 --> 00:27:49,409
frameworks by the end of 2013 and so

00:27:43,850 --> 00:27:57,529
they've created a chart of the AHA the

00:27:49,409 --> 00:28:00,509
current state of support so this is ah

00:27:57,529 --> 00:28:03,960
the number of unit the percentage of

00:28:00,509 --> 00:28:07,289
unit tests that pass / framework for the

00:28:03,960 --> 00:28:09,149
top you know frameworks that are it's in

00:28:07,289 --> 00:28:12,210
order of most popular or framework on

00:28:09,149 --> 00:28:13,889
github actually I'm sorry I've reordered

00:28:12,210 --> 00:28:17,129
it into the order of its percentage of

00:28:13,889 --> 00:28:19,590
passing but anyway so if you take for

00:28:17,129 --> 00:28:24,210
example drupal passes ninety-eight

00:28:19,590 --> 00:28:25,559
percent of the unit tests now I didn't

00:28:24,210 --> 00:28:27,720
think that was terribly great to be

00:28:25,559 --> 00:28:31,019
honest with you i use ye the e framework

00:28:27,720 --> 00:28:32,249
quite a bit or I did and ninety-two

00:28:31,019 --> 00:28:34,830
percent doesn't really give me a whole

00:28:32,249 --> 00:28:36,749
lot of confidence in the program but

00:28:34,830 --> 00:28:38,610
then if you actually take PHP and run

00:28:36,749 --> 00:28:39,869
the real runtime against it you find

00:28:38,610 --> 00:28:44,669
that it's not much better than that so

00:28:39,869 --> 00:28:47,100
PHP itself from zend only passes 95 plus

00:28:44,669 --> 00:28:50,269
percent of the unit tests for most of

00:28:47,100 --> 00:28:52,529
these frameworks now the ones in red

00:28:50,269 --> 00:28:53,620
couldn't be run at all because there's

00:28:52,529 --> 00:28:58,690
some problem

00:28:53,620 --> 00:29:00,190
for example in uh was it in cakephp I

00:28:58,690 --> 00:29:01,059
don't remember zend framework to they

00:29:00,190 --> 00:29:04,150
didn't have the internationalization

00:29:01,059 --> 00:29:08,530
plugin I mean extension it's since been

00:29:04,150 --> 00:29:11,260
added so it'll work now PHP BB

00:29:08,530 --> 00:29:13,420
throughout the entire unit test they

00:29:11,260 --> 00:29:16,120
call a function missing a parameter and

00:29:13,420 --> 00:29:18,610
that is an error engage in hip hop and

00:29:16,120 --> 00:29:22,330
it can't be done so it simply fails and

00:29:18,610 --> 00:29:25,240
that's similar with the rest of these so

00:29:22,330 --> 00:29:27,130
I believe that PHP hip hop or PHP is

00:29:25,240 --> 00:29:29,530
open source because there's so much PHP

00:29:27,130 --> 00:29:31,240
code that gets merged into it that they

00:29:29,530 --> 00:29:33,610
have this intrinsic connection to the

00:29:31,240 --> 00:29:35,620
PHP license so they licensed itself

00:29:33,610 --> 00:29:38,260
under under the PHP license which is a

00:29:35,620 --> 00:29:42,940
fairly liberal license it's not real

00:29:38,260 --> 00:29:44,230
restrictive I had an issue in 2011 where

00:29:42,940 --> 00:29:46,210
they stopped committing to the

00:29:44,230 --> 00:29:47,559
repository and I was concerned that you

00:29:46,210 --> 00:29:52,059
know maybe they're not going to continue

00:29:47,559 --> 00:29:53,860
giving back to the community and so so

00:29:52,059 --> 00:29:58,059
there was a six month period where i was

00:29:53,860 --> 00:29:59,470
a little bit is a little bit on edge in

00:29:58,059 --> 00:30:01,929
addition there were some problems with

00:29:59,470 --> 00:30:03,910
functions i've submitted I don't know

00:30:01,929 --> 00:30:07,270
four or five bug requests our bug

00:30:03,910 --> 00:30:10,240
reports to the github hip hop or PHP

00:30:07,270 --> 00:30:12,700
repository one just got fixed last week

00:30:10,240 --> 00:30:18,850
for me and I think that speaking about

00:30:12,700 --> 00:30:21,820
it helps so so now it's under active

00:30:18,850 --> 00:30:23,980
development they I see regularly 50 60

00:30:21,820 --> 00:30:25,480
70 commits per day on the public github

00:30:23,980 --> 00:30:27,640
repository they're not like pooling them

00:30:25,480 --> 00:30:30,280
and then pushing them to github they're

00:30:27,640 --> 00:30:32,800
actually doing it in real time and the

00:30:30,280 --> 00:30:34,179
development team themself is active on

00:30:32,800 --> 00:30:35,559
IRC I've jumped on there quite a few

00:30:34,179 --> 00:30:36,640
times and just chatted with these guys

00:30:35,559 --> 00:30:39,309
these guys are the ones that are

00:30:36,640 --> 00:30:40,990
developing the actual hip hop for PHP so

00:30:39,309 --> 00:30:43,990
you can go in there and suggest

00:30:40,990 --> 00:30:48,400
something see what's coming up and that

00:30:43,990 --> 00:30:50,800
sort of thing so like I said I i was a

00:30:48,400 --> 00:30:53,530
little bit distraught in 2011 when when

00:30:50,800 --> 00:30:55,630
this activity slowed down it's so I

00:30:53,530 --> 00:30:57,610
happen to know a few people at Facebook

00:30:55,630 --> 00:30:59,080
and I went and I asked them what the

00:30:57,610 --> 00:31:01,210
heck is going on here you know his

00:30:59,080 --> 00:31:04,480
facebook committed to this thing and I

00:31:01,210 --> 00:31:07,090
so I got a quote from James Pierce which

00:31:04,480 --> 00:31:09,310
was he's ahead of developer advocacy

00:31:07,090 --> 00:31:11,290
get facebook he's a nice guy I mean I

00:31:09,310 --> 00:31:13,600
know I'm outside of Facebook as well and

00:31:11,290 --> 00:31:15,700
he said that in years past we've had a

00:31:13,600 --> 00:31:18,970
few examples of projects which have not

00:31:15,700 --> 00:31:20,260
been well supported but we are now much

00:31:18,970 --> 00:31:21,940
better at growing in sustaining

00:31:20,260 --> 00:31:24,310
community projects including lately in

00:31:21,940 --> 00:31:26,200
mobile hip hop for PHP is absolutely a

00:31:24,310 --> 00:31:28,540
project that we stand strongly behind so

00:31:26,200 --> 00:31:30,970
stay tuned so that makes me feel a

00:31:28,540 --> 00:31:32,410
little better but I still would say that

00:31:30,970 --> 00:31:34,330
its connection to the PHP license would

00:31:32,410 --> 00:31:41,530
be the most compelling reason to trust

00:31:34,330 --> 00:31:42,970
hip hop or PHP so let's see here so I've

00:31:41,530 --> 00:31:44,860
got a list of references that you can

00:31:42,970 --> 00:31:47,320
check out I think the presentation will

00:31:44,860 --> 00:31:51,760
be made available on the website from

00:31:47,320 --> 00:31:52,870
not mistaken I didn't get into actually

00:31:51,760 --> 00:31:55,450
I've got some more time so let me talk

00:31:52,870 --> 00:31:57,880
briefly about the Sebastian Bergman is

00:31:55,450 --> 00:31:59,890
here you may have seen some of his talks

00:31:57,880 --> 00:32:03,190
already at the conference and he wrote

00:31:59,890 --> 00:32:04,990
something called HH vm rapper it's

00:32:03,190 --> 00:32:08,740
available on github and what it does is

00:32:04,990 --> 00:32:10,540
since HH vm has to go into such depth in

00:32:08,740 --> 00:32:12,880
the PHP code to try to figure things out

00:32:10,540 --> 00:32:14,020
like variable types it learns a lot of

00:32:12,880 --> 00:32:15,880
things about the code you write in the

00:32:14,020 --> 00:32:17,800
process they can learn a lot of issues

00:32:15,880 --> 00:32:21,270
that are put to or potential issues that

00:32:17,800 --> 00:32:23,440
you have in your code base and so so

00:32:21,270 --> 00:32:26,260
sebastian has written this HH vm wrapper

00:32:23,440 --> 00:32:27,850
which does static analysis on your PHP

00:32:26,260 --> 00:32:29,560
code base and figures out you know

00:32:27,850 --> 00:32:31,060
what's wrong with your variable types

00:32:29,560 --> 00:32:33,580
and this type of thing and reports them

00:32:31,060 --> 00:32:35,410
back I think I think HH vm makes it

00:32:33,580 --> 00:32:39,310
available in JSON and it gets parsed by

00:32:35,410 --> 00:32:43,510
the HH p.m. rapper so i asked him about

00:32:39,310 --> 00:32:44,920
this in he uh it was very he had

00:32:43,510 --> 00:32:46,450
something he's got something coming up

00:32:44,920 --> 00:32:47,860
that he wasn't telling me about so we'll

00:32:46,450 --> 00:32:52,150
have to see what he's what he's coming

00:32:47,860 --> 00:32:53,710
up with yeah and if you want to see if

00:32:52,150 --> 00:32:57,130
you like if you'd like to know more

00:32:53,710 --> 00:33:00,490
about how the actual transition from PHP

00:32:57,130 --> 00:33:03,190
in the c++ works tapings out the

00:33:00,490 --> 00:33:06,760
original developer of from facebook has

00:33:03,190 --> 00:33:08,320
done a really in-depth look he did a

00:33:06,760 --> 00:33:09,970
lecture at stanford university for an

00:33:08,320 --> 00:33:12,460
hour and a half talking about how you

00:33:09,970 --> 00:33:16,800
turn PHP in the c++ because it's not a

00:33:12,460 --> 00:33:20,320
not an easy task ok Facebook actually

00:33:16,800 --> 00:33:22,360
tests hip hop for PHP against WordPress

00:33:20,320 --> 00:33:26,409
because it has a very body to say a

00:33:22,360 --> 00:33:28,419
diverse set of code behind it actually

00:33:26,409 --> 00:33:31,120
it's really crappy code but anyway yeah

00:33:28,419 --> 00:33:34,090
that's a great test bed for for the code

00:33:31,120 --> 00:33:35,710
base so I think one of the biggest

00:33:34,090 --> 00:33:37,330
problems with perform when you have

00:33:35,710 --> 00:33:38,500
performance problems with PHP it's

00:33:37,330 --> 00:33:40,240
probably because you have a framework

00:33:38,500 --> 00:33:41,830
that's instantiating a thousand objects

00:33:40,240 --> 00:33:44,799
every time you get a request right and

00:33:41,830 --> 00:33:46,779
so if you're not using an opcode cash

00:33:44,799 --> 00:33:49,259
you should be using one now I understand

00:33:46,779 --> 00:33:54,279
a PC has a lot of issues with PHP 5.4

00:33:49,259 --> 00:33:56,799
but I've tested up cash on PHP 5.5 and

00:33:54,279 --> 00:33:58,029
it's extremely fast I mean even without

00:33:56,799 --> 00:34:00,549
using hip hop you should be doing that

00:33:58,029 --> 00:34:06,009
because this 3 instantiation is very

00:34:00,549 --> 00:34:08,730
expensive so how many of you have had

00:34:06,009 --> 00:34:12,240
heard of hip hop prior to this meeting

00:34:08,730 --> 00:34:14,349
everybody almost okay for me it took

00:34:12,240 --> 00:34:15,940
usually about an hour if I had the

00:34:14,349 --> 00:34:18,760
dependencies but the dependencies are so

00:34:15,940 --> 00:34:20,980
specific meant for example you have to

00:34:18,760 --> 00:34:23,490
get this exact version of memcache and

00:34:20,980 --> 00:34:26,379
then on top of that you have to pull

00:34:23,490 --> 00:34:28,000
Facebook's patch file the diff patch

00:34:26,379 --> 00:34:30,280
file and apply it to the memcache

00:34:28,000 --> 00:34:32,889
library and then compile that in and

00:34:30,280 --> 00:34:34,240
it's really nasty it took you know it

00:34:32,889 --> 00:34:36,310
would take hours to get it working right

00:34:34,240 --> 00:34:40,329
if you can get it working right now oh

00:34:36,310 --> 00:34:42,010
HH p.m. I think with the introduction of

00:34:40,329 --> 00:34:44,409
two point two point zero week and a half

00:34:42,010 --> 00:34:46,569
ago they have packages available for all

00:34:44,409 --> 00:34:50,470
the red hat based you know Fedora CentOS

00:34:46,569 --> 00:34:52,899
job and as well as debian and abou two

00:34:50,470 --> 00:34:57,550
and I don't remember what the last one

00:34:52,899 --> 00:35:03,089
was I can check though actually here

00:34:57,550 --> 00:35:03,089
I'll just I was going to bounce again

00:35:04,990 --> 00:35:08,900
well anyway I can check for you

00:35:06,830 --> 00:35:11,990
afterwards well then thank you guys for

00:35:08,900 --> 00:35:14,350
listening to my presentation and I hope

00:35:11,990 --> 00:35:14,350

YouTube URL: https://www.youtube.com/watch?v=zJLwTgRiZro


