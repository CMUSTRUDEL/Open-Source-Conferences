Title: JavaScript -- the structural Problem  - Oliver Sturm | IPC WTC 13
Publication date: 2016-06-09
Playlist: International PHP Conference 2013
Description: 
	In a JavaScript codebase that grows beyond a certain size, code structure is often an issue. There are several solutions that suggest different concepts of modularization, in browser as well as server environments, and numerous other variations. This talk explains and analyzes several approaches and tries to put them in their respective places.

More information: https://phpconference.com/en/
Captions: 
	00:00:06,410 --> 00:00:11,700
welcome my name is Oliver Sturm I work

00:00:09,990 --> 00:00:14,280
with the company called devexpress which

00:00:11,700 --> 00:00:16,470
is otherwise entirely irrelevant to this

00:00:14,280 --> 00:00:19,230
talk but it means that I do some work

00:00:16,470 --> 00:00:21,660
with web technologies because we create

00:00:19,230 --> 00:00:24,779
reusable products for web developers and

00:00:21,660 --> 00:00:26,789
HTML based developers and so on that's

00:00:24,779 --> 00:00:29,119
the background that I have and I'm here

00:00:26,789 --> 00:00:32,340
today to talk to you about JavaScript

00:00:29,119 --> 00:00:34,410
the structural problem is the catchy

00:00:32,340 --> 00:00:37,590
title I came up with that it's basically

00:00:34,410 --> 00:00:40,469
about modularization patterns about

00:00:37,590 --> 00:00:42,420
structuring your code in certain ways

00:00:40,469 --> 00:00:44,700
using particular technical approaches

00:00:42,420 --> 00:00:48,030
and the standard patterns that are out

00:00:44,700 --> 00:00:51,390
there okay so I've got a slide here with

00:00:48,030 --> 00:00:53,610
a bit of an agenda overview the door

00:00:51,390 --> 00:00:55,440
opens fair enough but what I would like

00:00:53,610 --> 00:00:57,600
to talk to you about today is first of

00:00:55,440 --> 00:00:59,430
all where does this idea of structuring

00:00:57,600 --> 00:01:00,899
javascript code come from in the first

00:00:59,430 --> 00:01:04,260
place I mean you may have been

00:01:00,899 --> 00:01:05,880
developing traditional web applications

00:01:04,260 --> 00:01:07,560
for a pretty long time without ever

00:01:05,880 --> 00:01:09,780
having to think very much about

00:01:07,560 --> 00:01:11,310
structuring your JavaScript code right

00:01:09,780 --> 00:01:14,070
potentially you even do that today

00:01:11,310 --> 00:01:15,810
that's fair enough but where does that

00:01:14,070 --> 00:01:17,939
idea come from that will be my first

00:01:15,810 --> 00:01:19,710
point I'd like to talk about some of the

00:01:17,939 --> 00:01:22,619
technical basics in the JavaScript

00:01:19,710 --> 00:01:25,500
language that are used to make

00:01:22,619 --> 00:01:28,049
modularization happen typically if he's

00:01:25,500 --> 00:01:30,840
and the module pattern that is heavily

00:01:28,049 --> 00:01:33,090
based on if he's and then I'd like to

00:01:30,840 --> 00:01:35,340
get into two of the standard patterns

00:01:33,090 --> 00:01:37,650
with common j/s modules and AMD modules

00:01:35,340 --> 00:01:39,780
that are typically used in JavaScript

00:01:37,650 --> 00:01:43,079
based applications both on server and

00:01:39,780 --> 00:01:45,990
client or browser side and say something

00:01:43,079 --> 00:01:48,540
about those as well as about the loaders

00:01:45,990 --> 00:01:51,270
or at least one in particular and

00:01:48,540 --> 00:01:53,100
combining different techniques to get

00:01:51,270 --> 00:01:55,079
those modules loaded into your

00:01:53,100 --> 00:01:58,130
applications that so that's what I have

00:01:55,079 --> 00:02:03,509
in mind for the for the next hour and

00:01:58,130 --> 00:02:05,790
right so who is a JavaScript app

00:02:03,509 --> 00:02:08,550
developer out of all you here can we see

00:02:05,790 --> 00:02:10,830
a show of hands okay that's just a few

00:02:08,550 --> 00:02:12,870
of you fair enough that's good so for

00:02:10,830 --> 00:02:14,730
for at least the others

00:02:12,870 --> 00:02:17,489
some of what I'm going to say is

00:02:14,730 --> 00:02:20,879
probably quite new then although of

00:02:17,489 --> 00:02:22,620
course no website developers may have

00:02:20,879 --> 00:02:24,510
experience with JavaScript of course

00:02:22,620 --> 00:02:26,549
don't get me the wrong way but it's

00:02:24,510 --> 00:02:28,260
usually in a slightly different area is

00:02:26,549 --> 00:02:32,280
my experience than it is for app

00:02:28,260 --> 00:02:34,049
developers so structuring JavaScript

00:02:32,280 --> 00:02:37,079
code the why of it that's my first

00:02:34,049 --> 00:02:38,819
question as I outlined before so the

00:02:37,079 --> 00:02:41,400
idea is that you might have a

00:02:38,819 --> 00:02:43,049
considerable amount of JavaScript quite

00:02:41,400 --> 00:02:45,510
obviously if you're just going to hack

00:02:43,049 --> 00:02:47,640
the odd piece of code into some existing

00:02:45,510 --> 00:02:49,769
framework you know fill in the gaps kind

00:02:47,640 --> 00:02:52,049
of thing pop a little JavaScript code in

00:02:49,769 --> 00:02:53,790
your HTML directly to handle some events

00:02:52,049 --> 00:02:55,799
and that kind of stuff if that's what

00:02:53,790 --> 00:02:57,599
you do you don't normally need to think

00:02:55,799 --> 00:02:59,400
very much about structuring your code

00:02:57,599 --> 00:03:01,859
because it well there's just not enough

00:02:59,400 --> 00:03:04,739
of it to warrant much consideration

00:03:01,859 --> 00:03:07,409
apart from maybe general guidelines like

00:03:04,739 --> 00:03:09,180
pull your code into a separate file if

00:03:07,409 --> 00:03:12,060
you can instead of having a you know

00:03:09,180 --> 00:03:13,799
long-winded script sections in your HTML

00:03:12,060 --> 00:03:16,470
that's that's very enough we know that

00:03:13,799 --> 00:03:18,510
right but otherwise there might not be

00:03:16,470 --> 00:03:21,030
very much else that you need to do to

00:03:18,510 --> 00:03:23,549
structure so the idea of structuring

00:03:21,030 --> 00:03:25,410
your code comes up in those cases that

00:03:23,549 --> 00:03:27,660
I've listed here basically you can read

00:03:25,410 --> 00:03:30,389
so it's about applications that are

00:03:27,660 --> 00:03:32,519
written for use on the server side which

00:03:30,389 --> 00:03:34,620
is usually associated with larger

00:03:32,519 --> 00:03:37,109
amounts of code that implement

00:03:34,620 --> 00:03:39,239
application logic that potentially make

00:03:37,109 --> 00:03:41,040
you know business logic happen on the

00:03:39,239 --> 00:03:43,799
server side and so on this might might

00:03:41,040 --> 00:03:45,900
be node applications for example being

00:03:43,799 --> 00:03:48,410
probably the primary platform for

00:03:45,900 --> 00:03:51,060
server-side JavaScript execution today

00:03:48,410 --> 00:03:53,459
we also have client applications that

00:03:51,060 --> 00:03:55,470
are written purely on an HTML Javascript

00:03:53,459 --> 00:03:58,379
basis of course we see more and more of

00:03:55,470 --> 00:04:00,299
these these days it used to be the the

00:03:58,379 --> 00:04:02,579
prime example was always the Google Docs

00:04:00,299 --> 00:04:05,040
you know stuff like that that are of

00:04:02,579 --> 00:04:07,739
course purely HTML Javascript based

00:04:05,040 --> 00:04:09,510
applications however these days we see

00:04:07,739 --> 00:04:11,579
loads of those everywhere so it doesn't

00:04:09,510 --> 00:04:14,010
really warrant that much that much of an

00:04:11,579 --> 00:04:15,660
explanation the idea with those

00:04:14,010 --> 00:04:17,690
applications is of course if you're

00:04:15,660 --> 00:04:20,430
really new to the topic by any chance

00:04:17,690 --> 00:04:22,740
that you're going to have a client app

00:04:20,430 --> 00:04:24,690
like you might have had at any point in

00:04:22,740 --> 00:04:26,430
time in a native environment like a

00:04:24,690 --> 00:04:29,250
Windows application or maybe in

00:04:26,430 --> 00:04:31,350
mcintosh application whatever else but

00:04:29,250 --> 00:04:33,240
it is going to be implemented in HTML

00:04:31,350 --> 00:04:35,820
and JavaScript and that comes with all

00:04:33,240 --> 00:04:38,100
the same issues and problems and

00:04:35,820 --> 00:04:40,440
challenges that client-side applications

00:04:38,100 --> 00:04:42,240
have always had the architecture there's

00:04:40,440 --> 00:04:45,539
so much different code mixed in there

00:04:42,240 --> 00:04:48,240
for you know data access layers and you

00:04:45,539 --> 00:04:50,190
I layers and business functionality in

00:04:48,240 --> 00:04:52,889
between and so on that obviously the

00:04:50,190 --> 00:04:55,229
idea of structuring that code is is what

00:04:52,889 --> 00:04:57,270
is an easy one to come up with so that's

00:04:55,229 --> 00:04:59,699
that part and the mobile apps that I'm

00:04:57,270 --> 00:05:01,860
listing separately are typically quite

00:04:59,699 --> 00:05:05,130
similar these days because frequently

00:05:01,860 --> 00:05:07,259
people use the same techniques that you

00:05:05,130 --> 00:05:09,990
use to create those client applications

00:05:07,259 --> 00:05:12,570
i was mentioning earlier to make those

00:05:09,990 --> 00:05:15,330
available on mobile devices people now

00:05:12,570 --> 00:05:17,639
use the same technology stacks these

00:05:15,330 --> 00:05:20,190
might be elaborate frameworks perhaps

00:05:17,639 --> 00:05:22,289
you need you use angularjs or ember or

00:05:20,190 --> 00:05:24,210
any of those existing ones you know that

00:05:22,289 --> 00:05:26,460
basically enable single page

00:05:24,210 --> 00:05:28,440
applications that's typically the main

00:05:26,460 --> 00:05:30,210
pattern that is implemented by these

00:05:28,440 --> 00:05:32,760
frameworks and that's the kind of thing

00:05:30,210 --> 00:05:36,180
you might do for mobile applications as

00:05:32,760 --> 00:05:38,550
well today plus probably some kind of a

00:05:36,180 --> 00:05:40,139
transition layer maybe phonegap or

00:05:38,550 --> 00:05:42,690
something like that that actually allows

00:05:40,139 --> 00:05:44,729
you to bring that application onto the

00:05:42,690 --> 00:05:47,159
device and use some of the native

00:05:44,729 --> 00:05:48,840
functionality like built in hardware of

00:05:47,159 --> 00:05:52,380
the device and stuff like that as well

00:05:48,840 --> 00:05:54,630
so that is the other part and the fourth

00:05:52,380 --> 00:05:56,430
item I've listed is reusable modules

00:05:54,630 --> 00:05:58,199
which means of course if you're going to

00:05:56,430 --> 00:06:00,120
create something for other people to

00:05:58,199 --> 00:06:02,550
reuse you need to think about

00:06:00,120 --> 00:06:04,759
modularization right if you're going to

00:06:02,550 --> 00:06:07,259
write the next jQuery that's fair enough

00:06:04,759 --> 00:06:09,870
maybe you're not but maybe you're going

00:06:07,259 --> 00:06:11,729
to create a pretty complex library for

00:06:09,870 --> 00:06:14,909
consumption in your own enterprise

00:06:11,729 --> 00:06:16,770
environment right people do that so you

00:06:14,909 --> 00:06:19,139
know other people with other developers

00:06:16,770 --> 00:06:21,810
from other departments for example might

00:06:19,139 --> 00:06:24,270
have the need to reuse what you have

00:06:21,810 --> 00:06:26,250
created or to actually use it in the

00:06:24,270 --> 00:06:28,740
first place reuse always is always the

00:06:26,250 --> 00:06:32,729
second step isn't it so using what you

00:06:28,740 --> 00:06:34,469
have created in a flexible way can bring

00:06:32,729 --> 00:06:37,560
up the same challenges of modularization

00:06:34,469 --> 00:06:39,479
that you are faced with yourself if you

00:06:37,560 --> 00:06:40,080
use jQuery for example you're familiar

00:06:39,479 --> 00:06:43,710
with the

00:06:40,080 --> 00:06:46,139
way they have a well a structure of sub

00:06:43,710 --> 00:06:48,509
modules if you like that you can pull in

00:06:46,139 --> 00:06:50,310
selectively right it's it's even their

00:06:48,509 --> 00:06:52,830
third party infrastructure there are

00:06:50,310 --> 00:06:55,139
millions of add-ons for jquery that you

00:06:52,830 --> 00:06:57,060
can choose to add into the mix for your

00:06:55,139 --> 00:06:59,069
own application so that's the kind of

00:06:57,060 --> 00:07:01,409
modularization that you may want to use

00:06:59,069 --> 00:07:04,530
yourself like i said even in the

00:07:01,409 --> 00:07:06,810
environment of enterprise level HTML

00:07:04,530 --> 00:07:07,949
Javascript based applications so that's

00:07:06,810 --> 00:07:10,349
the kind of thing we're talking about

00:07:07,949 --> 00:07:14,129
when we come to the idea of structuring

00:07:10,349 --> 00:07:16,110
our JavaScript code and I did want to

00:07:14,129 --> 00:07:18,449
outline that before you walk away

00:07:16,110 --> 00:07:20,280
thinking that's a very odd idea what

00:07:18,449 --> 00:07:24,539
he's been talking about so that's the

00:07:20,280 --> 00:07:26,430
thing right now the fee that's the

00:07:24,539 --> 00:07:30,090
interesting little pronunciation people

00:07:26,430 --> 00:07:32,310
have come up for this acronym here Iife

00:07:30,090 --> 00:07:34,080
right somebody thought that looks almost

00:07:32,310 --> 00:07:36,539
like iffy and if he in English means

00:07:34,080 --> 00:07:39,210
something like a bit weird odd kind of

00:07:36,539 --> 00:07:42,270
thing so they thought that was a funny

00:07:39,210 --> 00:07:44,940
and pronunciation for it are the

00:07:42,270 --> 00:07:46,500
technical basis of what we call the

00:07:44,940 --> 00:07:49,440
module pattern which is usually

00:07:46,500 --> 00:07:51,330
attributed to Douglas Crockford but lots

00:07:49,440 --> 00:07:53,219
of stuff has been written about it so I

00:07:51,330 --> 00:07:55,710
don't think anybody actually claims the

00:07:53,219 --> 00:07:58,949
idea for themselves necessarily but the

00:07:55,710 --> 00:08:02,460
module pattern makes lots of use of the

00:07:58,949 --> 00:08:04,740
iffy as a tank of feature and the iffy

00:08:02,460 --> 00:08:06,750
itself is the immediately invoked

00:08:04,740 --> 00:08:10,050
function expression as it says down

00:08:06,750 --> 00:08:11,460
there which is a JavaScript feature that

00:08:10,050 --> 00:08:13,349
i'm going to show you in a moment i

00:08:11,460 --> 00:08:15,479
guess most of you are familiar with the

00:08:13,349 --> 00:08:17,159
basic way that it works but i find it

00:08:15,479 --> 00:08:19,289
quite interesting to look at some of the

00:08:17,159 --> 00:08:22,440
details of how it is used with the

00:08:19,289 --> 00:08:25,949
module pattern to enable the kind of

00:08:22,440 --> 00:08:27,690
structural module creation and extension

00:08:25,949 --> 00:08:30,509
and so on that is the basis of many

00:08:27,690 --> 00:08:33,899
modularization systems so i'll show you

00:08:30,509 --> 00:08:41,669
some demos for that one in just a second

00:08:33,899 --> 00:08:43,740
actually let's see what we have oh well

00:08:41,669 --> 00:08:46,560
I can see my editor you can't there we

00:08:43,740 --> 00:08:48,300
go and that's probably not large enough

00:08:46,560 --> 00:08:52,290
for everybody is it so let's make that

00:08:48,300 --> 00:08:53,300
larger it's that big enough no so I say

00:08:52,290 --> 00:08:58,310
no that was

00:08:53,300 --> 00:09:00,200
joke right okay maybe i'll go for

00:08:58,310 --> 00:09:01,910
compromise like so it's not okay for

00:09:00,200 --> 00:09:05,630
people in the back there can you read it

00:09:01,910 --> 00:09:08,149
okay brilliant right so I've got this

00:09:05,630 --> 00:09:11,000
very basic piece of code here let me

00:09:08,149 --> 00:09:13,940
just quickly here oh there we go a basic

00:09:11,000 --> 00:09:16,399
piece of code where I'm creating a

00:09:13,940 --> 00:09:19,100
logger only I'm not actually creating a

00:09:16,399 --> 00:09:21,410
logger right now now let's say I would

00:09:19,100 --> 00:09:23,570
like to create a logger with this little

00:09:21,410 --> 00:09:26,269
helper function here and I might do this

00:09:23,570 --> 00:09:28,670
by returning a new function of course

00:09:26,269 --> 00:09:31,459
which will take a piece of text as a

00:09:28,670 --> 00:09:33,230
parameter I can't tell you why it's

00:09:31,459 --> 00:09:35,570
highlighting the X right now oh because

00:09:33,230 --> 00:09:37,760
it says X donia huh that's weird why did

00:09:35,570 --> 00:09:39,680
I search for X I don't remember there

00:09:37,760 --> 00:09:41,690
you go function so this will be the

00:09:39,680 --> 00:09:44,089
function that I will return and this

00:09:41,690 --> 00:09:45,829
function that I'll return we'll just out

00:09:44,089 --> 00:09:47,570
put something on the console for

00:09:45,829 --> 00:09:49,430
simplicity right so we'll just do this

00:09:47,570 --> 00:09:51,170
and then well maybe we're just going to

00:09:49,430 --> 00:09:52,940
do the text for a start I mean this

00:09:51,170 --> 00:09:55,519
little piece of code here would do the

00:09:52,940 --> 00:09:58,360
job just to make that point and conform

00:09:55,519 --> 00:10:03,170
with the little API that I've created

00:09:58,360 --> 00:10:05,779
now for purposes of demonstrating to you

00:10:03,170 --> 00:10:09,020
how this execution works I'm going to

00:10:05,779 --> 00:10:10,670
run this in node I don't know if

00:10:09,020 --> 00:10:12,260
everybody's familiar with that there are

00:10:10,670 --> 00:10:14,570
obviously people with lots of different

00:10:12,260 --> 00:10:17,120
backgrounds here so node is basically a

00:10:14,570 --> 00:10:20,029
server-side JavaScript execution engine

00:10:17,120 --> 00:10:21,649
which allows me to just go ahead and run

00:10:20,029 --> 00:10:23,660
one of these scripts that I'll be

00:10:21,649 --> 00:10:27,380
working with this one is called that I

00:10:23,660 --> 00:10:29,209
think and then obviously it'll just say

00:10:27,380 --> 00:10:31,610
something happened and something else

00:10:29,209 --> 00:10:34,220
happened because that's what i'm using

00:10:31,610 --> 00:10:37,490
my lager here for so that one works just

00:10:34,220 --> 00:10:39,529
fine now something you can do in the

00:10:37,490 --> 00:10:42,610
context of a little function like this

00:10:39,529 --> 00:10:45,320
here is to take advantage of the closure

00:10:42,610 --> 00:10:47,390
functionality of javascript pre basic

00:10:45,320 --> 00:10:49,310
thing really what that means is if I

00:10:47,390 --> 00:10:52,160
have some kind of a variable on this

00:10:49,310 --> 00:10:53,779
level right here I've got some funny

00:10:52,160 --> 00:10:56,120
windows on my other screen here sorry

00:10:53,779 --> 00:10:59,209
well if I've got some variable on here

00:10:56,120 --> 00:11:01,760
let's call this output counter and give

00:10:59,209 --> 00:11:04,970
it an initial value perhaps I can then

00:11:01,760 --> 00:11:06,200
utilize that value inside the function

00:11:04,970 --> 00:11:09,270
that I'm return

00:11:06,200 --> 00:11:10,950
so perhaps i'm going to put in something

00:11:09,270 --> 00:11:13,830
like this you're just put the output

00:11:10,950 --> 00:11:16,500
counter in there and then we're going to

00:11:13,830 --> 00:11:18,090
do closing paren like so something like

00:11:16,500 --> 00:11:21,150
that right so I'm piecing together a

00:11:18,090 --> 00:11:23,550
slightly prettier output for my lager oh

00:11:21,150 --> 00:11:25,830
and I could also go and increment the

00:11:23,550 --> 00:11:29,010
output counter in there like this right

00:11:25,830 --> 00:11:31,710
perhaps and then if I've done that

00:11:29,010 --> 00:11:34,110
roughly the right way I should now see

00:11:31,710 --> 00:11:36,690
that it counts right it says my log

00:11:34,110 --> 00:11:39,420
output has now got numbers in front of

00:11:36,690 --> 00:11:40,860
each of the lines and well I mean if

00:11:39,420 --> 00:11:43,770
you're not familiar with the feature of

00:11:40,860 --> 00:11:46,350
closures you may wonder perhaps why the

00:11:43,770 --> 00:11:48,660
counting thing even happens because

00:11:46,350 --> 00:11:50,790
basically well this function is what's

00:11:48,660 --> 00:11:52,830
being returned to our main scope here

00:11:50,790 --> 00:11:54,990
that's my manual logger in the end and

00:11:52,830 --> 00:11:57,240
the function has a reference to this

00:11:54,990 --> 00:11:59,100
output counter thing that's the not

00:11:57,240 --> 00:12:00,690
quite non-obvious part really if you're

00:11:59,100 --> 00:12:02,280
totally unfamiliar with closures for

00:12:00,690 --> 00:12:04,350
some reason so I'm just explaining it

00:12:02,280 --> 00:12:06,330
shortly that's the way it works

00:12:04,350 --> 00:12:08,670
javascript knows that this funk of this

00:12:06,330 --> 00:12:10,530
this variable here has to stay around

00:12:08,670 --> 00:12:13,530
for use by the other by the other

00:12:10,530 --> 00:12:15,120
function and it makes it available and

00:12:13,530 --> 00:12:17,730
that's it so you can now use that

00:12:15,120 --> 00:12:21,890
variable as a private field if you like

00:12:17,730 --> 00:12:24,870
now in order to make that thing an iffy

00:12:21,890 --> 00:12:26,100
we basically change a little bit of a

00:12:24,870 --> 00:12:28,950
little something about the

00:12:26,100 --> 00:12:31,890
implementation here let me add this to

00:12:28,950 --> 00:12:34,020
the bottom and what we usually do is put

00:12:31,890 --> 00:12:37,940
some additional / ends around this thing

00:12:34,020 --> 00:12:42,690
here and then we add another set of

00:12:37,940 --> 00:12:44,760
parentals inside this pair or behind it

00:12:42,690 --> 00:12:47,910
that's basically roughly the same thing

00:12:44,760 --> 00:12:50,250
what it means is that this function that

00:12:47,910 --> 00:12:52,410
goes from here to there just for clarity

00:12:50,250 --> 00:12:55,680
write this function that I've now

00:12:52,410 --> 00:12:58,290
created is being executed immediately so

00:12:55,680 --> 00:13:00,420
that's the aspect of immediately invoked

00:12:58,290 --> 00:13:02,010
right that's the double I in the

00:13:00,420 --> 00:13:04,440
beginning of the iffy acronym right

00:13:02,010 --> 00:13:05,820
there so instead of just taking the

00:13:04,440 --> 00:13:07,860
function like I do up here I'm just

00:13:05,820 --> 00:13:10,140
declaring it right and now I'm storing

00:13:07,860 --> 00:13:12,240
it away of course the syntax needs to be

00:13:10,140 --> 00:13:14,670
changed a bit still so I wouldn't

00:13:12,240 --> 00:13:17,660
normally have any kind of name on this

00:13:14,670 --> 00:13:20,210
function that's just an anonymous thing

00:13:17,660 --> 00:13:23,260
equally obviously I'm also returning

00:13:20,210 --> 00:13:26,300
something from this function and that's

00:13:23,260 --> 00:13:28,660
so I'm not currently storing this return

00:13:26,300 --> 00:13:33,410
value so I could do something like VAR

00:13:28,660 --> 00:13:35,900
fe lager equals that thing right and as

00:13:33,410 --> 00:13:39,290
a result i have now created this

00:13:35,900 --> 00:13:42,620
anonymous function like so on up to here

00:13:39,290 --> 00:13:46,250
and i've also invoked it right away with

00:13:42,620 --> 00:13:49,520
the pair of parenteral operation is now

00:13:46,250 --> 00:13:51,920
stored inside fe lager again what you

00:13:49,520 --> 00:13:55,370
usually do in addition to this though is

00:13:51,920 --> 00:13:57,920
to extend your return result just a

00:13:55,370 --> 00:14:00,620
little bit so what you normally do is

00:13:57,920 --> 00:14:02,600
return a new object that has perhaps a

00:14:00,620 --> 00:14:04,640
method or function while i'm calling it

00:14:02,600 --> 00:14:07,220
a method because it's vaguely resembles

00:14:04,640 --> 00:14:09,440
the idea of object-oriented structures

00:14:07,220 --> 00:14:11,000
there but I'm getting ahead of myself so

00:14:09,440 --> 00:14:13,070
let's call it a function for now and

00:14:11,000 --> 00:14:15,320
this function i'll call log and that's

00:14:13,070 --> 00:14:17,060
where my existing implementation here

00:14:15,320 --> 00:14:19,790
goes right let me just wrap this round a

00:14:17,060 --> 00:14:23,270
bit so we can see everything and I think

00:14:19,790 --> 00:14:27,080
now I'm missing a another curly right

00:14:23,270 --> 00:14:28,970
there I think like so that's that's the

00:14:27,080 --> 00:14:30,560
one for the new object no that's the one

00:14:28,970 --> 00:14:32,180
for the function now fair enough and

00:14:30,560 --> 00:14:33,980
this is the one for the new object so

00:14:32,180 --> 00:14:35,930
maybe indent that a little so we can see

00:14:33,980 --> 00:14:37,430
what's going on so with this kind of

00:14:35,930 --> 00:14:39,980
syntax this is what you might encounter

00:14:37,430 --> 00:14:42,860
quite frequently when if these are being

00:14:39,980 --> 00:14:44,660
used we have this immediately executed

00:14:42,860 --> 00:14:47,210
function that basically has its own

00:14:44,660 --> 00:14:49,670
internal state that's what we talked

00:14:47,210 --> 00:14:52,460
about in the context and it returns a

00:14:49,670 --> 00:14:54,620
new object that has functionality and

00:14:52,460 --> 00:14:59,000
the functionality of that new object in

00:14:54,620 --> 00:15:03,080
turn utilizes the internal state in some

00:14:59,000 --> 00:15:05,930
way well privately really so let's see

00:15:03,080 --> 00:15:07,370
if the fe lager works if we lager well

00:15:05,930 --> 00:15:10,370
this is an object now which has a

00:15:07,370 --> 00:15:13,100
function call log on it and I can now

00:15:10,370 --> 00:15:15,220
say again you know something else

00:15:13,100 --> 00:15:18,920
happened no we've already got that one

00:15:15,220 --> 00:15:21,950
ok let's test it sorry about that some

00:15:18,920 --> 00:15:23,680
funny keys there a third thing happened

00:15:21,950 --> 00:15:27,740
right that where that would fit better

00:15:23,680 --> 00:15:30,140
and then just save that and see what

00:15:27,740 --> 00:15:31,170
what happens when I run it again and it

00:15:30,140 --> 00:15:33,450
starts count

00:15:31,170 --> 00:15:36,000
from one again says a third thing

00:15:33,450 --> 00:15:38,100
happened and let's duplicate this here

00:15:36,000 --> 00:15:40,709
perhaps and call this a fourth thing

00:15:38,100 --> 00:15:42,990
happened so we can distinguish what's

00:15:40,709 --> 00:15:46,290
happening of course and there we go so

00:15:42,990 --> 00:15:48,180
my new lager implementation is still

00:15:46,290 --> 00:15:50,579
able to log in the same way as the old

00:15:48,180 --> 00:15:53,269
one did utilizing like I said that

00:15:50,579 --> 00:15:55,769
internal state part that I have in there

00:15:53,269 --> 00:15:59,910
but I've now got this implementation

00:15:55,769 --> 00:16:04,350
based on the iffy pattern and JavaScript

00:15:59,910 --> 00:16:09,510
now what's the advantage of having this

00:16:04,350 --> 00:16:12,630
thing right there any ideas anybody in a

00:16:09,510 --> 00:16:14,910
nutshell please I'm not cluttering the

00:16:12,630 --> 00:16:17,130
global scope with variables yes that is

00:16:14,910 --> 00:16:21,240
correct so in comparison to the first

00:16:17,130 --> 00:16:23,040
variation at the top this year I'm not

00:16:21,240 --> 00:16:25,410
declaring this function in the global

00:16:23,040 --> 00:16:27,600
scope basically right so instead of

00:16:25,410 --> 00:16:29,310
doing that I've just got the anonymous

00:16:27,600 --> 00:16:31,920
function and this of course is a scoped

00:16:29,310 --> 00:16:35,250
variable again so whatever scope I would

00:16:31,920 --> 00:16:39,269
be in right now that's where my my newly

00:16:35,250 --> 00:16:40,620
created element let's call it that will

00:16:39,269 --> 00:16:41,970
be stored so I'm not cluttering my

00:16:40,620 --> 00:16:45,510
object space yes that's exactly

00:16:41,970 --> 00:16:48,120
important the other part with if ease is

00:16:45,510 --> 00:16:50,279
basically the same thing as you get with

00:16:48,120 --> 00:16:52,470
the function declaration however which

00:16:50,279 --> 00:16:54,899
is that I'm creating a scope right

00:16:52,470 --> 00:16:58,260
that's the the important basic idea of

00:16:54,899 --> 00:17:01,290
course by using this particular closure

00:16:58,260 --> 00:17:05,189
based syntax I'm creating a scope for

00:17:01,290 --> 00:17:08,189
certain items to live inside without the

00:17:05,189 --> 00:17:10,709
well being able or food allowing anybody

00:17:08,189 --> 00:17:13,319
to access these items from the outside

00:17:10,709 --> 00:17:16,140
unless through some particular public

00:17:13,319 --> 00:17:18,569
API that I'm creating so my public API

00:17:16,140 --> 00:17:20,730
of course is that log function and my

00:17:18,569 --> 00:17:23,130
private information is my output counter

00:17:20,730 --> 00:17:25,230
and that is only accessible to me in a

00:17:23,130 --> 00:17:26,880
particular way that I implement and not

00:17:25,230 --> 00:17:30,990
to anybody else looking at the object

00:17:26,880 --> 00:17:33,860
from the outside right so these are the

00:17:30,990 --> 00:17:36,750
two factors really combined I've got

00:17:33,860 --> 00:17:39,059
just a few more examples for

00:17:36,750 --> 00:17:40,710
completeness sake here I think this code

00:17:39,059 --> 00:17:43,919
should look pretty similar to what we

00:17:40,710 --> 00:17:44,740
just did oh I'm pointing out here that

00:17:43,919 --> 00:17:47,500
you can have

00:17:44,740 --> 00:17:49,480
well that final pair of parentheses in

00:17:47,500 --> 00:17:53,950
different locations right just so you've

00:17:49,480 --> 00:17:56,170
seen that syntax in comparison Oh what's

00:17:53,950 --> 00:18:00,690
not possible by the way is this syntax

00:17:56,170 --> 00:18:00,690
right here where you don't use a pair of

00:18:05,130 --> 00:18:10,570
parentheses I'm highlighting is a

00:18:08,410 --> 00:18:13,360
complete function declaration right

00:18:10,570 --> 00:18:15,940
however in JavaScript that is exactly

00:18:13,360 --> 00:18:17,590
what it is it's a declaration and it is

00:18:15,940 --> 00:18:19,990
not an expression and for that reason

00:18:17,590 --> 00:18:22,210
it's evaluated differently so that's why

00:18:19,990 --> 00:18:23,890
you have to make JavaScript understand

00:18:22,210 --> 00:18:25,929
that you mean for this to be an

00:18:23,890 --> 00:18:28,120
expression and the usual way of doing

00:18:25,929 --> 00:18:30,730
this is using the paren syntax above

00:18:28,120 --> 00:18:32,710
however sometimes you see stuff like

00:18:30,730 --> 00:18:35,440
this year at the bottom these three

00:18:32,710 --> 00:18:37,270
variations all of those work even though

00:18:35,440 --> 00:18:40,030
there's no / ends around the function

00:18:37,270 --> 00:18:42,309
thing because the the well through the

00:18:40,030 --> 00:18:45,460
use of these additional items like the

00:18:42,309 --> 00:18:48,179
the tildes sign here 0 comma or true

00:18:45,460 --> 00:18:50,260
double and you can also make JavaScript

00:18:48,179 --> 00:18:52,480
understand that this is an expression

00:18:50,260 --> 00:18:54,670
that is being evaluated right so that's

00:18:52,480 --> 00:18:56,470
got the same effect and some people use

00:18:54,670 --> 00:18:58,480
it I think it's pretty crazy isn't if

00:18:56,470 --> 00:19:00,790
you've got cold lines starting with zero

00:18:58,480 --> 00:19:02,200
comma for no particular reason I think

00:19:00,790 --> 00:19:04,090
that's pretty weird but I've seen it

00:19:02,200 --> 00:19:06,100
quite a few times so you might encounter

00:19:04,090 --> 00:19:09,429
this somewhere just remember this is

00:19:06,100 --> 00:19:11,920
just a very odd way of using a fees and

00:19:09,429 --> 00:19:14,440
a pretty weird syntax there fair enough

00:19:11,920 --> 00:19:18,640
or maybe you prefer it anybody prefers

00:19:14,440 --> 00:19:22,720
it no okay I see somebody doing this

00:19:18,640 --> 00:19:24,460
right so yeah all right no I don't

00:19:22,720 --> 00:19:26,140
prefer that I do that I've seen it I

00:19:24,460 --> 00:19:27,820
mean especially the Thule thing here I

00:19:26,140 --> 00:19:30,520
think some people really like doing

00:19:27,820 --> 00:19:32,440
that's kind of crazy fair enough ok so I

00:19:30,520 --> 00:19:35,740
just add those in for completeness sake

00:19:32,440 --> 00:19:39,520
now I've also got a little failure with

00:19:35,740 --> 00:19:43,360
some examples of the module pattern bays

00:19:39,520 --> 00:19:45,880
on the fe syntax so for start in my demo

00:19:43,360 --> 00:19:49,059
here I've got this little element called

00:19:45,880 --> 00:19:50,770
an adder defined and it basically works

00:19:49,059 --> 00:19:53,260
exactly like what we've seen a moment

00:19:50,770 --> 00:19:55,540
ago right this adder is a simple if a

00:19:53,260 --> 00:19:57,760
defined object and it doesn't even use

00:19:55,540 --> 00:20:00,250
any internal state so

00:19:57,760 --> 00:20:02,170
you know you don't obviously have to do

00:20:00,250 --> 00:20:04,180
that but it's also an example for a very

00:20:02,170 --> 00:20:06,490
simple item that you might use in

00:20:04,180 --> 00:20:08,770
modularization now this thing should be

00:20:06,490 --> 00:20:10,510
able to add two values together quite

00:20:08,770 --> 00:20:13,390
obviously let me just jump to the

00:20:10,510 --> 00:20:15,520
console one time and enter node module

00:20:13,390 --> 00:20:17,680
patterns and we'll see that the first

00:20:15,520 --> 00:20:20,140
item it output says adding five and

00:20:17,680 --> 00:20:22,030
three gives me eight that sounds vaguely

00:20:20,140 --> 00:20:24,340
correct so we'll just assume for now

00:20:22,030 --> 00:20:27,640
that the adder is doing its job okay

00:20:24,340 --> 00:20:30,040
right so we're using an iffy for that

00:20:27,640 --> 00:20:32,830
one now i'm going to construct a

00:20:30,040 --> 00:20:35,470
calculator here and again I'm using the

00:20:32,830 --> 00:20:38,860
iffy pattern for the calculator but I'm

00:20:35,470 --> 00:20:40,870
making my calculator based on the adder

00:20:38,860 --> 00:20:42,850
which kind of makes sense right if

00:20:40,870 --> 00:20:44,650
you've already got an adder and in

00:20:42,850 --> 00:20:46,870
reality maybe other little building

00:20:44,650 --> 00:20:48,490
blocks as well and you create something

00:20:46,870 --> 00:20:50,590
a little more complicated like the

00:20:48,490 --> 00:20:53,230
calculator you might want to reuse the

00:20:50,590 --> 00:20:55,330
adder functionality that's the idea here

00:20:53,230 --> 00:20:59,860
right so I'm sorry for using simple

00:20:55,330 --> 00:21:01,840
examples or I'm not really but the point

00:20:59,860 --> 00:21:04,600
of course is that this is this shows a

00:21:01,840 --> 00:21:06,340
certain pattern of reuse and using

00:21:04,600 --> 00:21:09,490
building blocks to construct more

00:21:06,340 --> 00:21:13,480
complex things out of them so my adder

00:21:09,490 --> 00:21:15,880
is simply used in here right so that is

00:21:13,480 --> 00:21:18,250
of course the global a drew that has now

00:21:15,880 --> 00:21:19,930
cluttered my name space basically at

00:21:18,250 --> 00:21:21,820
least well actually in this case it

00:21:19,930 --> 00:21:23,770
hasn't not quite so badly at least

00:21:21,820 --> 00:21:26,380
because at least it's of our right so

00:21:23,770 --> 00:21:28,510
it's only microscope whatever that

00:21:26,380 --> 00:21:30,910
really is but still that's where it is

00:21:28,510 --> 00:21:33,100
and one of the things that is actually

00:21:30,910 --> 00:21:35,050
frequently overlooked when people use

00:21:33,100 --> 00:21:36,820
that type of an approach where they just

00:21:35,050 --> 00:21:39,730
assume that they can access anything

00:21:36,820 --> 00:21:42,280
that is in a wider scope than where the

00:21:39,730 --> 00:21:45,040
current piece of code runs in is the

00:21:42,280 --> 00:21:49,450
fact that JavaScript really takes longer

00:21:45,040 --> 00:21:51,730
to resolve these trains of as we say for

00:21:49,450 --> 00:21:55,210
objects that are found higher up in the

00:21:51,730 --> 00:21:57,580
hierarchy right off of scopes basically

00:21:55,210 --> 00:22:00,160
so in reality if you do this all the

00:21:57,580 --> 00:22:02,770
time and you have pretty deeply nested

00:22:00,160 --> 00:22:04,750
hierarchies of scopes because you do use

00:22:02,770 --> 00:22:07,390
if he's quite a bit and maybe you use

00:22:04,750 --> 00:22:10,150
some libraries that also use if is

00:22:07,390 --> 00:22:10,340
internally you may end up having to have

00:22:10,150 --> 00:22:13,760
a

00:22:10,340 --> 00:22:15,650
quite a distance between the the Adler

00:22:13,760 --> 00:22:17,990
object on the global scope more or less

00:22:15,650 --> 00:22:20,240
right and and the current piece of code

00:22:17,990 --> 00:22:22,760
that is being executed and JavaScript

00:22:20,240 --> 00:22:25,580
has to walk up that stack basically to

00:22:22,760 --> 00:22:28,490
find out where the adder object is from

00:22:25,580 --> 00:22:30,860
where does it belong and that takes time

00:22:28,490 --> 00:22:32,360
unfortunately so there have been some

00:22:30,860 --> 00:22:34,460
benchmarks that I've seen where it

00:22:32,360 --> 00:22:37,190
varies somewhat between browsers how

00:22:34,460 --> 00:22:38,840
they handle it and so on however that's

00:22:37,190 --> 00:22:40,940
one reason alone why it's not

00:22:38,840 --> 00:22:43,399
necessarily a good idea to just do this

00:22:40,940 --> 00:22:46,190
everywhere plus of course structurally

00:22:43,399 --> 00:22:47,419
it sucks to go that way right because

00:22:46,190 --> 00:22:50,480
you're going to have a lot of items

00:22:47,419 --> 00:22:53,390
somewhere in a larger namespace scope if

00:22:50,480 --> 00:22:54,919
you like and accessing those globally

00:22:53,390 --> 00:22:57,110
just doesn't make a lot of sense in a

00:22:54,919 --> 00:22:58,490
larger environment so it works

00:22:57,110 --> 00:23:00,260
nevertheless I mean we've seen the

00:22:58,490 --> 00:23:02,299
output already here that's the first one

00:23:00,260 --> 00:23:03,950
adding with the first calculator i think

00:23:02,299 --> 00:23:05,899
is what this one says exactly and of

00:23:03,950 --> 00:23:10,490
course it still works reusing the adder

00:23:05,899 --> 00:23:14,179
in this way now I'm moving along I could

00:23:10,490 --> 00:23:16,340
do this instead of using the adder from

00:23:14,179 --> 00:23:20,450
its global namespace I get the adder

00:23:16,340 --> 00:23:24,140
passed in to my function that is inside

00:23:20,450 --> 00:23:27,620
DFE if you like and of course I have to

00:23:24,140 --> 00:23:29,870
list it down here again as well now I

00:23:27,620 --> 00:23:32,240
mean since this is an example you could

00:23:29,870 --> 00:23:35,480
argue now that in order to create my

00:23:32,240 --> 00:23:37,399
calculator I still need to look up the

00:23:35,480 --> 00:23:39,799
global adder right well that's fair

00:23:37,399 --> 00:23:42,080
enough and I'm only using it in the one

00:23:39,799 --> 00:23:44,059
method in there but consider I might be

00:23:42,080 --> 00:23:46,340
using it thousands of times however I

00:23:44,059 --> 00:23:48,350
could call that particular or saying

00:23:46,340 --> 00:23:50,179
method that particular function on the

00:23:48,350 --> 00:23:52,340
object right there I could call this a

00:23:50,179 --> 00:23:55,070
thousand times if I liked and at least

00:23:52,340 --> 00:23:57,380
now I don't have that long look up train

00:23:55,070 --> 00:24:00,470
for the adder object anymore when it is

00:23:57,380 --> 00:24:02,899
evaluated here okay so it only happens

00:24:00,470 --> 00:24:04,970
once on the construction of my object

00:24:02,899 --> 00:24:07,580
that the arrow is looked up from the

00:24:04,970 --> 00:24:10,870
global namespace it is then passed into

00:24:07,580 --> 00:24:13,640
the function and basically the adder

00:24:10,870 --> 00:24:16,220
variable the the parameter to the

00:24:13,640 --> 00:24:18,470
function is now handled in the same way

00:24:16,220 --> 00:24:20,600
that I was telling you about with the

00:24:18,470 --> 00:24:23,220
when I said we've got private state on

00:24:20,600 --> 00:24:26,190
the inside of that that fe thing right

00:24:23,220 --> 00:24:28,020
closure has that information now so it's

00:24:26,190 --> 00:24:30,630
like a like a variable that has been

00:24:28,020 --> 00:24:33,270
declared in the scope and as a result it

00:24:30,630 --> 00:24:35,130
is kept available again for later use

00:24:33,270 --> 00:24:38,039
and that's what happens when I finally

00:24:35,130 --> 00:24:40,260
end up calling the add function now my a

00:24:38,039 --> 00:24:42,059
direct doesn't have to be looked up in

00:24:40,260 --> 00:24:44,760
any low global scope any more or any

00:24:42,059 --> 00:24:47,250
scope really apart from my own so that's

00:24:44,760 --> 00:24:49,559
where it's found most quickly quite

00:24:47,250 --> 00:24:51,840
obviously and that's the most performant

00:24:49,559 --> 00:24:53,700
way you can go with this the syntax of

00:24:51,840 --> 00:24:55,230
it you would probably already recognize

00:24:53,700 --> 00:24:56,940
if you've been reading around some

00:24:55,230 --> 00:24:59,400
JavaScript libraries occasionally

00:24:56,940 --> 00:25:01,679
because the the way they you have

00:24:59,400 --> 00:25:03,929
certain variables hanging around at the

00:25:01,679 --> 00:25:06,539
end of that particular if evaluation

00:25:03,929 --> 00:25:11,460
expression that's usually it all looks

00:25:06,539 --> 00:25:13,110
the same way typically um oh right i

00:25:11,460 --> 00:25:15,210
have mentioned this here that

00:25:13,110 --> 00:25:16,950
occasionally you see things like this

00:25:15,210 --> 00:25:19,530
year i'm not going to uncomment this

00:25:16,950 --> 00:25:22,200
right so people use the same expression

00:25:19,530 --> 00:25:24,299
or the same kind of pattern to pass in a

00:25:22,200 --> 00:25:26,909
reference to something global like the

00:25:24,299 --> 00:25:29,100
jQuery object for instance right so if

00:25:26,909 --> 00:25:31,260
you create an iffy and you're going to

00:25:29,100 --> 00:25:33,809
be using jQuery inside your

00:25:31,260 --> 00:25:35,520
implementation right there you still

00:25:33,809 --> 00:25:38,100
have the exact same choice you can

00:25:35,520 --> 00:25:40,440
either just access the jQuery object or

00:25:38,100 --> 00:25:42,240
of course it's dollar standard

00:25:40,440 --> 00:25:44,070
representation right there you can

00:25:42,240 --> 00:25:46,140
access that directly from the global

00:25:44,070 --> 00:25:48,530
scope where you might have imported it

00:25:46,140 --> 00:25:51,450
or required it or whatever it is exactly

00:25:48,530 --> 00:25:53,250
and that'll work technically however if

00:25:51,450 --> 00:25:55,200
you make a lot of chords to that object

00:25:53,250 --> 00:25:57,480
it's going to take quite a while to

00:25:55,200 --> 00:25:59,640
evaluate all those and that's the idea

00:25:57,480 --> 00:26:03,090
why somebody might then pass in the

00:25:59,640 --> 00:26:05,789
jQuery object like so and it's received

00:26:03,090 --> 00:26:07,710
up here in a variable that simply has

00:26:05,789 --> 00:26:10,409
the name dollar right so again you're

00:26:07,710 --> 00:26:12,990
back to the usual syntax for most of us

00:26:10,409 --> 00:26:14,880
when using jQuery where you just use the

00:26:12,990 --> 00:26:16,860
dollar as a shortcut to the jQuery

00:26:14,880 --> 00:26:18,630
object in case you're not familiar with

00:26:16,860 --> 00:26:21,330
it this is optional right that's why I'm

00:26:18,630 --> 00:26:22,980
talking about it like that because using

00:26:21,330 --> 00:26:25,260
the dollar is just as a default

00:26:22,980 --> 00:26:27,659
convention when using jQuery on the

00:26:25,260 --> 00:26:29,640
browser side that's how jQuery installs

00:26:27,659 --> 00:26:31,710
itself in there but if you use it on the

00:26:29,640 --> 00:26:34,799
server side for instance it does not

00:26:31,710 --> 00:26:36,840
install its its own variable in the

00:26:34,799 --> 00:26:39,419
global space so you don't have the door

00:26:36,840 --> 00:26:41,419
unless you created yourself instead you

00:26:39,419 --> 00:26:43,950
might have an object called jQuery or

00:26:41,419 --> 00:26:45,900
depending on your module concept which

00:26:43,950 --> 00:26:47,220
I'm going to get to in the end you might

00:26:45,900 --> 00:26:49,529
have some other kind of variable of

00:26:47,220 --> 00:26:52,679
course that that refers to a library

00:26:49,529 --> 00:26:55,350
like jquery so that that pattern can be

00:26:52,679 --> 00:26:57,900
found quite frequently and that's just

00:26:55,350 --> 00:27:00,830
what I wanted to point out here now this

00:26:57,900 --> 00:27:04,320
is where it gets more exciting because

00:27:00,830 --> 00:27:06,779
moving ahead with the module pattern I'm

00:27:04,320 --> 00:27:08,610
now creating my calculator in a slightly

00:27:06,779 --> 00:27:11,610
different way and the idea with this is

00:27:08,610 --> 00:27:14,190
that I'm I'll be able to augment my

00:27:11,610 --> 00:27:16,590
calculator so let's start calling my

00:27:14,190 --> 00:27:18,470
calculator a module shall we because

00:27:16,590 --> 00:27:21,000
that's what I have in mind here really

00:27:18,470 --> 00:27:23,460
of course you know some people prefer a

00:27:21,000 --> 00:27:25,559
particular naming patterns for four

00:27:23,460 --> 00:27:27,600
modules so they might call the

00:27:25,559 --> 00:27:29,640
calculator in all caps or something if

00:27:27,600 --> 00:27:31,289
it's a module well that's up to you

00:27:29,640 --> 00:27:33,480
really you know naming conventions and

00:27:31,289 --> 00:27:35,429
JavaScript are pretty flexible I don't

00:27:33,480 --> 00:27:37,860
normally or if not always tend to do

00:27:35,429 --> 00:27:40,710
that myself to be honest but whatever

00:27:37,860 --> 00:27:42,600
whatever you like so the difference the

00:27:40,710 --> 00:27:44,490
important difference is actually looking

00:27:42,600 --> 00:27:47,370
at the one down here first perhaps is

00:27:44,490 --> 00:27:49,529
that I'm taking a parameter here which

00:27:47,370 --> 00:27:51,110
I'm calling me don't have to do that

00:27:49,529 --> 00:27:54,720
really you can call it anything you like

00:27:51,110 --> 00:27:58,740
and that parameter represents an object

00:27:54,720 --> 00:28:01,409
that is also a calculator already all

00:27:58,740 --> 00:28:03,830
right that's the idea now the parameters

00:28:01,409 --> 00:28:07,529
that I'm passing in here is either an

00:28:03,830 --> 00:28:09,210
existing calculator object or in case we

00:28:07,529 --> 00:28:10,980
don't have a calculator object yet I'm

00:28:09,210 --> 00:28:13,950
just passing in an empty object as an

00:28:10,980 --> 00:28:17,850
initialization really for that newly

00:28:13,950 --> 00:28:20,490
created object now the the line here

00:28:17,850 --> 00:28:21,990
where the where the function is added

00:28:20,490 --> 00:28:24,809
just looks a little different right

00:28:21,990 --> 00:28:27,409
because I'm assigning this new function

00:28:24,809 --> 00:28:31,470
multiplication in this case to a

00:28:27,409 --> 00:28:32,970
variable in that me object so that's I

00:28:31,470 --> 00:28:35,159
did it differently before just for

00:28:32,970 --> 00:28:39,450
comparison let's quickly check back here

00:28:35,159 --> 00:28:41,909
where my ad was just you know a field in

00:28:39,450 --> 00:28:44,940
this newly created object that I set up

00:28:41,909 --> 00:28:47,340
right so instead we're now assuming that

00:28:44,940 --> 00:28:49,210
we already have an object which may of

00:28:47,340 --> 00:28:51,610
course on the first run

00:28:49,210 --> 00:28:53,620
an empty one and then I'm just adding an

00:28:51,610 --> 00:28:55,960
item in this case multiplication to this

00:28:53,620 --> 00:29:00,100
new object and returning that object

00:28:55,960 --> 00:29:02,200
again right so the add up their works

00:29:00,100 --> 00:29:03,760
exactly the same way with the addition

00:29:02,200 --> 00:29:05,289
of the other parameter that we had

00:29:03,760 --> 00:29:07,990
previously right so that's why I'm

00:29:05,289 --> 00:29:10,179
jumping a little but the adder otherwise

00:29:07,990 --> 00:29:11,649
is defined exactly the same way the

00:29:10,179 --> 00:29:15,549
interesting thing with this approach is

00:29:11,649 --> 00:29:17,770
we call it lose augmentation because it

00:29:15,549 --> 00:29:21,070
means that you can now evaluate those

00:29:17,770 --> 00:29:23,620
blocks here in any order you like think

00:29:21,070 --> 00:29:26,049
about it if the ad comes first and it's

00:29:23,620 --> 00:29:28,090
initialized based on an empty object

00:29:26,049 --> 00:29:30,159
here right so in this case because we

00:29:28,090 --> 00:29:32,289
don't have a calculator yet that's the

00:29:30,159 --> 00:29:35,500
assumption at least we're going to use

00:29:32,289 --> 00:29:37,720
an empty one instead and the second one

00:29:35,500 --> 00:29:39,520
here already has a calculator so the one

00:29:37,720 --> 00:29:42,340
that I've created before that already

00:29:39,520 --> 00:29:45,190
has an ADD method or function is passed

00:29:42,340 --> 00:29:47,529
in again and the multi-function is then

00:29:45,190 --> 00:29:49,299
added but it could equally well work the

00:29:47,529 --> 00:29:50,950
other way around right there's no

00:29:49,299 --> 00:29:53,590
difference that's why we call it loose

00:29:50,950 --> 00:29:55,899
augmentation well augmentation first of

00:29:53,590 --> 00:29:58,029
all is the term that you use for the

00:29:55,899 --> 00:30:00,100
idea of adding something into an

00:29:58,029 --> 00:30:02,080
existing item at a later point in time

00:30:00,100 --> 00:30:05,169
right so just to be clear on that one

00:30:02,080 --> 00:30:07,240
and loose is because we don't have a

00:30:05,169 --> 00:30:09,909
particular initialization order in mind

00:30:07,240 --> 00:30:11,980
now if you think modularization that is

00:30:09,909 --> 00:30:14,140
of course a very useful idea isn't it

00:30:11,980 --> 00:30:16,600
because you can now you don't have to

00:30:14,140 --> 00:30:19,659
assume anything about the order that

00:30:16,600 --> 00:30:22,149
your your modules will be loaded in if

00:30:19,659 --> 00:30:24,730
you assume that these items may actually

00:30:22,149 --> 00:30:27,010
live in separate modules in the end in

00:30:24,730 --> 00:30:29,049
separate JavaScript files perhaps right

00:30:27,010 --> 00:30:30,610
for a start you don't have to assume

00:30:29,049 --> 00:30:32,320
anything about the order that those

00:30:30,610 --> 00:30:35,049
files are loaded in that they're

00:30:32,320 --> 00:30:36,730
evaluated for some reason okay so that's

00:30:35,049 --> 00:30:38,740
an important part really loose

00:30:36,730 --> 00:30:41,529
augmentation allows you to create

00:30:38,740 --> 00:30:43,870
modules that are extended after the fact

00:30:41,529 --> 00:30:45,820
and you can of course do the same thing

00:30:43,870 --> 00:30:47,770
with modules that somebody else has

00:30:45,820 --> 00:30:50,500
written for example right to be a bit

00:30:47,770 --> 00:30:52,419
more complex there without making any

00:30:50,500 --> 00:30:54,760
assumptions about the way those modules

00:30:52,419 --> 00:30:56,500
will be used by somebody else later on

00:30:54,760 --> 00:30:58,270
whether they include the one or the

00:30:56,500 --> 00:31:01,000
other block first in that code doesn't

00:30:58,270 --> 00:31:02,830
matter to you at all I think by now

00:31:01,000 --> 00:31:04,690
we're at the multiplying with

00:31:02,830 --> 00:31:07,120
augmented calculator thing down here

00:31:04,690 --> 00:31:08,799
just to jump back and forth a bit so it

00:31:07,120 --> 00:31:11,409
obviously works otherwise I wouldn't be

00:31:08,799 --> 00:31:15,070
showing it to you just so you believe me

00:31:11,409 --> 00:31:18,630
there we go order irrelevant at this

00:31:15,070 --> 00:31:21,610
point I've got another example down here

00:31:18,630 --> 00:31:24,460
where I'm overriding a piece of

00:31:21,610 --> 00:31:27,669
functionality right so in this case I'm

00:31:24,460 --> 00:31:30,309
using an existing calculator object and

00:31:27,669 --> 00:31:32,320
I'm retrieving an item from it in this

00:31:30,309 --> 00:31:34,390
case my multifunction right there and

00:31:32,320 --> 00:31:36,580
I'm just overriding it with some pretty

00:31:34,390 --> 00:31:38,860
crazy thing that multiplies by three for

00:31:36,580 --> 00:31:41,019
no particular reason and I thereby

00:31:38,860 --> 00:31:43,269
override the existing functionality of

00:31:41,019 --> 00:31:46,120
course it would be up to me by the way

00:31:43,269 --> 00:31:48,220
to make the old functionality I mean I

00:31:46,120 --> 00:31:51,250
have it here it stored away in my

00:31:48,220 --> 00:31:53,529
internal state variable if I wanted to I

00:31:51,250 --> 00:31:56,350
could make that old function available

00:31:53,529 --> 00:31:58,690
somehow you know call it old malt or

00:31:56,350 --> 00:32:01,269
mult underscore or something that and

00:31:58,690 --> 00:32:03,340
provide both implementations no reason

00:32:01,269 --> 00:32:05,620
why not right so this is something you

00:32:03,340 --> 00:32:08,289
can do in this case however we talked

00:32:05,620 --> 00:32:09,880
about tight augmentation and the reason

00:32:08,289 --> 00:32:11,799
it's called tight augmentation is

00:32:09,880 --> 00:32:14,289
because now the initialization order

00:32:11,799 --> 00:32:16,750
matters quite obviously I can't really

00:32:14,289 --> 00:32:19,690
go and replace old with you before I

00:32:16,750 --> 00:32:22,179
even have an old item to work with right

00:32:19,690 --> 00:32:24,429
so in this case I'm not using the syntax

00:32:22,179 --> 00:32:26,289
with you or and the empty curlies and

00:32:24,429 --> 00:32:29,139
everything because it doesn't make much

00:32:26,289 --> 00:32:30,940
sense to begin the process of patching

00:32:29,139 --> 00:32:33,519
the existing calculator if you like

00:32:30,940 --> 00:32:35,740
unless I already have a calculator in

00:32:33,519 --> 00:32:38,139
the first place so that's the idea tight

00:32:35,740 --> 00:32:41,409
augmentation as opposed to loose that

00:32:38,139 --> 00:32:43,029
we've seen before now I think there's

00:32:41,409 --> 00:32:46,269
one more example in here unless I'm

00:32:43,029 --> 00:32:48,370
mistaken yes that is it and here that's

00:32:46,269 --> 00:32:50,590
just an example to show you that of

00:32:48,370 --> 00:32:53,110
course while my samples have been pretty

00:32:50,590 --> 00:32:55,510
simple we can still do the same thing

00:32:53,110 --> 00:32:57,399
with any kind of additional internal

00:32:55,510 --> 00:32:59,440
state all right so in this case I'm

00:32:57,399 --> 00:33:02,019
adding some storing functionality to my

00:32:59,440 --> 00:33:04,120
calculator and I've got my own variable

00:33:02,019 --> 00:33:06,039
store up there and I've got a number of

00:33:04,120 --> 00:33:09,159
functions that all work against that

00:33:06,039 --> 00:33:12,399
store and that's of course the idea that

00:33:09,159 --> 00:33:15,070
you're your individual initialization

00:33:12,399 --> 00:33:16,570
blocks don't always have to be quite so

00:33:15,070 --> 00:33:18,730
short as I made them

00:33:16,570 --> 00:33:20,620
there I mean sometimes it makes sense it

00:33:18,730 --> 00:33:22,870
depends on the degree of reusability

00:33:20,620 --> 00:33:25,120
that you would like to achieve because

00:33:22,870 --> 00:33:27,250
every single individual item like for

00:33:25,120 --> 00:33:30,039
instance my adder my adder can't do

00:33:27,250 --> 00:33:32,049
anything but add right so that means

00:33:30,039 --> 00:33:34,269
it's not a very powerful object but it

00:33:32,049 --> 00:33:37,090
also means that I might be able to reuse

00:33:34,269 --> 00:33:39,429
it in a large number of scenarios the

00:33:37,090 --> 00:33:41,950
simpler the objects the better they are

00:33:39,429 --> 00:33:43,120
for building blocks right so that's the

00:33:41,950 --> 00:33:45,429
kind of thing you have to think about

00:33:43,120 --> 00:33:48,100
the granularity when it comes to

00:33:45,429 --> 00:33:50,769
modularization of what you're trying to

00:33:48,100 --> 00:33:52,870
achieve is it are you looking for the

00:33:50,769 --> 00:33:56,019
best possible reuse or are you looking

00:33:52,870 --> 00:33:58,450
for most functionality in one place

00:33:56,019 --> 00:34:00,159
perhaps for some reason right so that's

00:33:58,450 --> 00:34:03,399
the kind of trade-off that you have to

00:34:00,159 --> 00:34:06,279
consider and well obviously this last

00:34:03,399 --> 00:34:08,980
example also works using the store

00:34:06,279 --> 00:34:12,490
private state here to stash away that

00:34:08,980 --> 00:34:15,250
individual value right so that's the

00:34:12,490 --> 00:34:17,109
basics of that if we end module pattern

00:34:15,250 --> 00:34:19,599
thing Oh something I did want to mention

00:34:17,109 --> 00:34:22,589
is that some people criticized this

00:34:19,599 --> 00:34:25,589
module pattern and well really the EFI's

00:34:22,589 --> 00:34:27,490
saying that they are bad to debug

00:34:25,589 --> 00:34:29,560
unfortunately that is not entirely

00:34:27,490 --> 00:34:31,629
untrue it depends a little on the kind

00:34:29,560 --> 00:34:34,359
of debugger that she's use and so on but

00:34:31,629 --> 00:34:36,569
in general it is a little hard to debug

00:34:34,359 --> 00:34:39,520
because the information that is stored

00:34:36,569 --> 00:34:41,859
enclosures is not usually accessible

00:34:39,520 --> 00:34:44,169
easily by a debugger I mean for a start

00:34:41,859 --> 00:34:47,050
of course it's not accessible through

00:34:44,169 --> 00:34:50,440
any public API right so if you have

00:34:47,050 --> 00:34:53,560
fields inside your closures that don't

00:34:50,440 --> 00:34:56,530
correspond to a direct in external API

00:34:53,560 --> 00:34:59,800
for example in my lager example I did

00:34:56,530 --> 00:35:01,930
not have a helper function in there that

00:34:59,800 --> 00:35:04,210
would have allowed me to retrieve the

00:35:01,930 --> 00:35:05,800
output counter right well maybe for some

00:35:04,210 --> 00:35:07,630
reason I would like to do that I would

00:35:05,800 --> 00:35:09,520
like to know what the next output

00:35:07,630 --> 00:35:12,160
counter is going to be but that's not

00:35:09,520 --> 00:35:13,780
part of the public API and as a result I

00:35:12,160 --> 00:35:16,660
don't have access to that information

00:35:13,780 --> 00:35:19,240
and even a debugger typically can't do

00:35:16,660 --> 00:35:22,119
it I can show you just quickly in the

00:35:19,240 --> 00:35:25,030
node debugger um how about what that

00:35:22,119 --> 00:35:28,030
looks like let me just see I've got my

00:35:25,030 --> 00:35:31,450
node inspector running I think

00:35:28,030 --> 00:35:34,750
there we go yeah okay I already had my

00:35:31,450 --> 00:35:40,390
node inspector running so they let's do

00:35:34,750 --> 00:35:42,520
a node debug break module patterns that

00:35:40,390 --> 00:35:44,410
means that the the script is going to

00:35:42,520 --> 00:35:46,240
start running and stop immediately on

00:35:44,410 --> 00:35:49,090
the first line right so now I can go to

00:35:46,240 --> 00:35:52,020
the browser I think I have a browser let

00:35:49,090 --> 00:35:55,630
me get a new window here there we go and

00:35:52,020 --> 00:35:58,570
in here I'll need to go to the URL that

00:35:55,630 --> 00:36:03,940
it shows me oh it doesn't fair enough

00:35:58,570 --> 00:36:07,000
localhost what is it then 58 58 or

00:36:03,940 --> 00:36:10,450
something like that isn't it I thought

00:36:07,000 --> 00:36:11,830
it was 58 or sorry about that it is 58

00:36:10,450 --> 00:36:18,010
isn't it so why is that not in my

00:36:11,830 --> 00:36:20,500
history though whoops um that's not the

00:36:18,010 --> 00:36:22,900
right URL yeah you never use it manually

00:36:20,500 --> 00:36:29,550
do you so let's see I probably have it

00:36:22,900 --> 00:36:35,010
somewhere yeah what the thing uh-huh oh

00:36:29,550 --> 00:36:40,210
right yeah right fair enough oops know

00:36:35,010 --> 00:36:42,670
what on earth am i doing ah there we go

00:36:40,210 --> 00:36:44,350
haha right that's that's the way it

00:36:42,670 --> 00:36:46,750
works you don't actually have to connect

00:36:44,350 --> 00:36:49,330
to 58 58 directly that's a good point

00:36:46,750 --> 00:36:52,840
okay so let's do that again I've got the

00:36:49,330 --> 00:36:55,270
node is inspector running I'll run my my

00:36:52,840 --> 00:36:57,010
module pattern file and now let's reload

00:36:55,270 --> 00:36:59,170
this page and I should be able to see

00:36:57,010 --> 00:37:00,910
the gnu debugger coming up brilliant

00:36:59,170 --> 00:37:02,560
okay so i don't know if you've seen that

00:37:00,910 --> 00:37:04,360
thing before but this is a nice little

00:37:02,560 --> 00:37:05,650
module that allows you to use the node

00:37:04,360 --> 00:37:07,810
debugger with the browser-based

00:37:05,650 --> 00:37:09,220
debugging interface similar to what

00:37:07,810 --> 00:37:12,010
you're familiar with from chrome

00:37:09,220 --> 00:37:13,060
developer tools in my case or firefox of

00:37:12,010 --> 00:37:15,910
course they will look very similar

00:37:13,060 --> 00:37:17,920
anyway these days don't they so I can

00:37:15,910 --> 00:37:19,510
now see my server side code and the

00:37:17,920 --> 00:37:21,820
thing that I was just going to point out

00:37:19,510 --> 00:37:24,340
to you is down at the bottom we've got

00:37:21,820 --> 00:37:28,450
this last example that I had bit larger

00:37:24,340 --> 00:37:31,410
maybe that has the internal state right

00:37:28,450 --> 00:37:35,560
with the store here and now the thing is

00:37:31,410 --> 00:37:38,080
on a line like this here where the store

00:37:35,560 --> 00:37:39,730
is being modified I can't even place a

00:37:38,080 --> 00:37:40,450
break point i'll just show you that

00:37:39,730 --> 00:37:42,520
again i click

00:37:40,450 --> 00:37:44,170
here click and the breakpoint is

00:37:42,520 --> 00:37:46,630
established in the next possible

00:37:44,170 --> 00:37:49,210
location instead of this line 157

00:37:46,630 --> 00:37:51,460
because the node inspector thing doesn't

00:37:49,210 --> 00:37:53,079
even allow me to put that breakpoint in

00:37:51,460 --> 00:37:55,450
the position where I would be able to

00:37:53,079 --> 00:37:58,089
access the store variable and there is

00:37:55,450 --> 00:38:00,579
no way when i get perhaps to this point

00:37:58,089 --> 00:38:04,030
here let's see let's just run through

00:38:00,579 --> 00:38:07,089
here now you might be tempted to think

00:38:04,030 --> 00:38:11,050
that the calculator object should offer

00:38:07,089 --> 00:38:13,180
access somehow to what's inside it right

00:38:11,050 --> 00:38:15,099
so let me just expand this here we go

00:38:13,180 --> 00:38:18,400
but there is nothing in there the

00:38:15,099 --> 00:38:21,339
calculator has add mulch retrieve and so

00:38:18,400 --> 00:38:23,980
on functions and other fields but the

00:38:21,339 --> 00:38:26,140
the store that I can see here is only

00:38:23,980 --> 00:38:28,180
the function called store the other one

00:38:26,140 --> 00:38:30,010
is just not visible at all and that's

00:38:28,180 --> 00:38:31,660
not a problem of the name by the way it

00:38:30,010 --> 00:38:33,250
wouldn't be visible either if it had the

00:38:31,660 --> 00:38:34,750
name it's just a private thing right

00:38:33,250 --> 00:38:37,599
it's in the closure that's the thing

00:38:34,750 --> 00:38:39,880
it's not it's not a field or a property

00:38:37,599 --> 00:38:42,910
or whatever you might imagine it just

00:38:39,880 --> 00:38:45,130
lives inside the closure some of the

00:38:42,910 --> 00:38:48,040
debuggers that I've seen are able to

00:38:45,130 --> 00:38:50,069
place a break point here right oh now it

00:38:48,040 --> 00:38:52,270
claims to be able to us interesting

00:38:50,069 --> 00:38:57,990
let's see if we can actually utilize

00:38:52,270 --> 00:39:02,589
that we can well guys I'm surprised but

00:38:57,990 --> 00:39:04,839
okay that's fair enough interesting I

00:39:02,589 --> 00:39:06,910
was not aware that this debugger is able

00:39:04,839 --> 00:39:09,339
to place the breakpoint there apparently

00:39:06,910 --> 00:39:11,050
at the point when dennis is the

00:39:09,339 --> 00:39:12,910
initialization has already happened

00:39:11,050 --> 00:39:14,319
right that's what it looks like at least

00:39:12,910 --> 00:39:16,599
I'd have to look into this in some

00:39:14,319 --> 00:39:18,400
detail but the the actual point I was

00:39:16,599 --> 00:39:20,290
going to make to you is only that the

00:39:18,400 --> 00:39:22,869
debugging in any event is rather

00:39:20,290 --> 00:39:24,490
complicated because obviously usually

00:39:22,869 --> 00:39:27,130
you will be interested in the state of

00:39:24,490 --> 00:39:28,839
one of those particular fields there at

00:39:27,130 --> 00:39:31,030
a particular point in your application

00:39:28,839 --> 00:39:32,890
when something breaks right and at that

00:39:31,030 --> 00:39:34,270
point of course it doesn't usually help

00:39:32,890 --> 00:39:36,670
you very much if you think to yourself

00:39:34,270 --> 00:39:39,160
hey if only I'd had a breakpoint you

00:39:36,670 --> 00:39:41,020
know at that other point there where

00:39:39,160 --> 00:39:42,400
where the modification happened was

00:39:41,020 --> 00:39:44,410
something like that because it's already

00:39:42,400 --> 00:39:47,380
too late for that so my main point

00:39:44,410 --> 00:39:49,300
really is that you can't look inside the

00:39:47,380 --> 00:39:51,670
object once the value is already in

00:39:49,300 --> 00:39:52,900
there you can't just access it like that

00:39:51,670 --> 00:39:55,360
which is usually what you

00:39:52,900 --> 00:39:57,670
really need to do and even if you if you

00:39:55,360 --> 00:39:59,230
would like to track things down by just

00:39:57,670 --> 00:40:00,820
you know stepping through all the

00:39:59,230 --> 00:40:03,160
various individual points where the

00:40:00,820 --> 00:40:05,110
values being modified or retrieved and

00:40:03,160 --> 00:40:06,220
so on I mean we have certainly

00:40:05,110 --> 00:40:09,520
documented that it's not a

00:40:06,220 --> 00:40:11,470
straightforward process right like I

00:40:09,520 --> 00:40:14,530
said I've seen debuggers that can place

00:40:11,470 --> 00:40:16,330
breakpoints here I was not aware that

00:40:14,530 --> 00:40:17,980
this one can do it under certain pretty

00:40:16,330 --> 00:40:19,390
odd circumstances which is an

00:40:17,980 --> 00:40:21,700
interesting discovery I'll have to look

00:40:19,390 --> 00:40:23,500
into that but the point is just that

00:40:21,700 --> 00:40:25,660
it's complicated and not exactly

00:40:23,500 --> 00:40:27,910
straightforward so that's the criticism

00:40:25,660 --> 00:40:30,460
some people have of the module pattern

00:40:27,910 --> 00:40:32,770
that while having those modules in the

00:40:30,460 --> 00:40:34,870
first place and having the the privacy

00:40:32,770 --> 00:40:37,330
inside those objects of non-accessible

00:40:34,870 --> 00:40:39,010
internal state that is that can be a

00:40:37,330 --> 00:40:41,950
hindrance as well right that's the

00:40:39,010 --> 00:40:45,070
problem now I had a point about this on

00:40:41,950 --> 00:40:47,620
my slide as well where it basically just

00:40:45,070 --> 00:40:50,080
says be disciplined with your public

00:40:47,620 --> 00:40:52,360
api's right because that is my own

00:40:50,080 --> 00:40:53,710
personal point of view for those of you

00:40:52,360 --> 00:40:55,630
who might have done coding with

00:40:53,710 --> 00:40:57,820
object-oriented programming languages

00:40:55,630 --> 00:41:01,450
for example we're kind of used to the

00:40:57,820 --> 00:41:03,610
idea in that space that you know classes

00:41:01,450 --> 00:41:05,320
and objects have got private state that

00:41:03,610 --> 00:41:07,540
is normally inaccessible from the

00:41:05,320 --> 00:41:09,820
outside and if you're also doing a lot

00:41:07,540 --> 00:41:11,560
of automated testing and so on you're

00:41:09,820 --> 00:41:14,830
familiar with the way you have to expose

00:41:11,560 --> 00:41:16,810
whatever you need in a kind of a clean

00:41:14,830 --> 00:41:19,360
way right make it available in the API

00:41:16,810 --> 00:41:22,750
if it has to be accessed from the

00:41:19,360 --> 00:41:25,240
outside so that's the thing in my in my

00:41:22,750 --> 00:41:28,780
eyes you shouldn't probably normally

00:41:25,240 --> 00:41:31,300
have too much internal state in an iffy

00:41:28,780 --> 00:41:33,850
constructed object that doesn't have a

00:41:31,300 --> 00:41:36,370
corresponding external API I mean for

00:41:33,850 --> 00:41:37,840
testing purposes for a start right how

00:41:36,370 --> 00:41:39,970
are you ever going to test that this

00:41:37,840 --> 00:41:42,550
object actually works correctly unless

00:41:39,970 --> 00:41:44,950
you have some kind of technique to

00:41:42,550 --> 00:41:47,920
access them the management information

00:41:44,950 --> 00:41:50,530
that it holds internally to test that

00:41:47,920 --> 00:41:53,110
it's correct right so from that point of

00:41:50,530 --> 00:41:54,940
view I've seen these arguments quite a

00:41:53,110 --> 00:41:57,010
few times and they are technically they

00:41:54,940 --> 00:41:59,200
are valid arguments but my main thought

00:41:57,010 --> 00:42:01,840
at that point is always well why did you

00:41:59,200 --> 00:42:04,270
structure your API in just exactly that

00:42:01,840 --> 00:42:05,740
way in the first place right of course

00:42:04,270 --> 00:42:06,460
fair enough maybe somebody else has

00:42:05,740 --> 00:42:08,050
structured the

00:42:06,460 --> 00:42:09,849
GI and you're just stuck with it and you

00:42:08,050 --> 00:42:11,589
just like to find out you know what's

00:42:09,849 --> 00:42:13,960
going wrong and so on there's enough

00:42:11,589 --> 00:42:16,330
reasons for sure but I don't think that

00:42:13,960 --> 00:42:18,220
there's a good reason not to be using

00:42:16,330 --> 00:42:19,869
the module pattern in that way because

00:42:18,220 --> 00:42:21,790
in the end it's pretty much the early

00:42:19,869 --> 00:42:25,839
way in JavaScript that you can establish

00:42:21,790 --> 00:42:27,670
this kind of secure context prototypes

00:42:25,839 --> 00:42:29,589
for example which is of course one of

00:42:27,670 --> 00:42:34,150
the standard mechanisms in JavaScript

00:42:29,589 --> 00:42:36,339
for reuse in a somewhat similar approach

00:42:34,150 --> 00:42:38,740
to object-oriented techniques or so on

00:42:36,339 --> 00:42:41,560
but it doesn't have the idea of defining

00:42:38,740 --> 00:42:43,420
visibility on particular fields or

00:42:41,560 --> 00:42:45,160
functions or whatever you have right

00:42:43,420 --> 00:42:47,290
that's not part of the prototype system

00:42:45,160 --> 00:42:50,890
in JavaScript so that's what you get

00:42:47,290 --> 00:42:54,339
here all right let me just check the

00:42:50,890 --> 00:42:57,670
time that's good okay so I oh we've seen

00:42:54,339 --> 00:43:00,849
that getting back on this idea of module

00:42:57,670 --> 00:43:03,400
systems we've got these two main

00:43:00,849 --> 00:43:05,349
contenders that I'm looking at here in

00:43:03,400 --> 00:43:07,240
reality there are quite a few other

00:43:05,349 --> 00:43:09,520
module systems out there people have

00:43:07,240 --> 00:43:11,109
created since you know whenever so they

00:43:09,520 --> 00:43:12,550
started using javascript it's been

00:43:11,109 --> 00:43:15,190
around a while now hasn't it I think

00:43:12,550 --> 00:43:19,060
isn't it 18 years or something like can

00:43:15,190 --> 00:43:21,400
you believe it so anyway these are the

00:43:19,060 --> 00:43:24,310
two main really important ones these

00:43:21,400 --> 00:43:26,230
days the commonjs module system which is

00:43:24,310 --> 00:43:28,150
mainly used on the server side it has

00:43:26,230 --> 00:43:31,660
been around longer than the others have

00:43:28,150 --> 00:43:34,030
as well and the AMD the asynchronous

00:43:31,660 --> 00:43:36,040
module definition as it's called which

00:43:34,030 --> 00:43:38,080
has been created as a bit of a spin-off

00:43:36,040 --> 00:43:40,089
almost from the commonjs thing they

00:43:38,080 --> 00:43:43,060
actually both come from the same group

00:43:40,089 --> 00:43:44,830
of standards these days but of course in

00:43:43,060 --> 00:43:48,460
JavaScript nothing is really a standard

00:43:44,830 --> 00:43:50,200
ever right this one is used mainly in

00:43:48,460 --> 00:43:53,589
the browser because it solves the

00:43:50,200 --> 00:43:56,500
problem of loading the modules that you

00:43:53,589 --> 00:43:59,950
have including their dependencies in an

00:43:56,500 --> 00:44:01,660
order that makes sense in the end and it

00:43:59,950 --> 00:44:03,609
also does this in the background

00:44:01,660 --> 00:44:05,530
potentially which is something that the

00:44:03,609 --> 00:44:08,140
commonjs system doesn't really support

00:44:05,530 --> 00:44:11,650
you during there are again plugins and

00:44:08,140 --> 00:44:13,510
add-ons and whatever else elsewhere that

00:44:11,650 --> 00:44:15,880
allow you to use common draya's modules

00:44:13,510 --> 00:44:17,950
in an asynchronous loading pattern right

00:44:15,880 --> 00:44:19,930
so there's a lot of mixed operation kind

00:44:17,950 --> 00:44:21,310
of approaches there as well

00:44:19,930 --> 00:44:23,980
now let's start with command Reyes

00:44:21,310 --> 00:44:27,220
commonjs works by using an exports

00:44:23,980 --> 00:44:29,830
object and that by publishing

00:44:27,220 --> 00:44:32,140
information too well the loader

00:44:29,830 --> 00:44:34,450
basically whatever that means right so

00:44:32,140 --> 00:44:36,700
if you create a module you have your

00:44:34,450 --> 00:44:39,220
functionality in there or perhaps your

00:44:36,700 --> 00:44:41,320
data fields and your functions or your

00:44:39,220 --> 00:44:43,630
objects or whatever you have and you

00:44:41,320 --> 00:44:46,090
just make those available selectively to

00:44:43,630 --> 00:44:48,670
the outer scope by assigning them to

00:44:46,090 --> 00:44:51,340
fields on this exports object

00:44:48,670 --> 00:44:53,830
occasionally you just assign the entire

00:44:51,340 --> 00:44:55,060
exports object in fact Russ not just

00:44:53,830 --> 00:44:57,550
individual fields but the whole thing

00:44:55,060 --> 00:44:59,440
right that's also an option and that's

00:44:57,550 --> 00:45:01,480
the way this works now from the outside

00:44:59,440 --> 00:45:04,780
when your module is loaded there is a

00:45:01,480 --> 00:45:08,170
require function used that will load the

00:45:04,780 --> 00:45:10,360
module and make sure that the object

00:45:08,170 --> 00:45:12,100
that has been passed back by the module

00:45:10,360 --> 00:45:14,950
if you like through this exports thing

00:45:12,100 --> 00:45:16,870
is now made available to you on the

00:45:14,950 --> 00:45:19,690
loading side right that's the way that

00:45:16,870 --> 00:45:21,190
works oh and the final bullet I've got

00:45:19,690 --> 00:45:23,200
in there because I always forget to

00:45:21,190 --> 00:45:26,950
mention this the required that is part

00:45:23,200 --> 00:45:29,020
of this pack here is required in turn to

00:45:26,950 --> 00:45:31,540
return immediately after loading or

00:45:29,020 --> 00:45:33,340
making available that module and it's

00:45:31,540 --> 00:45:36,130
not expected to take any time whatsoever

00:45:33,340 --> 00:45:38,800
really to do this and that's the main

00:45:36,130 --> 00:45:41,350
reason why the common j/s structure was

00:45:38,800 --> 00:45:43,210
not initially usable in a scenario that

00:45:41,350 --> 00:45:44,530
runs in the browser because in the

00:45:43,210 --> 00:45:47,020
browser everything is more complicated

00:45:44,530 --> 00:45:49,930
right first of all everything takes more

00:45:47,020 --> 00:45:51,850
time if a new module javascript file or

00:45:49,930 --> 00:45:53,350
something has to be loaded that doesn't

00:45:51,850 --> 00:45:55,150
happen immediately there might be

00:45:53,350 --> 00:45:56,920
dependencies as well so you've got a

00:45:55,150 --> 00:45:58,720
number of round trips and checks and

00:45:56,920 --> 00:46:00,730
whatever else you may have more than

00:45:58,720 --> 00:46:03,280
just one source that you would like to

00:46:00,730 --> 00:46:05,170
go to to try to load your your modules

00:46:03,280 --> 00:46:07,420
right perhaps you've got a CDN

00:46:05,170 --> 00:46:09,160
deployment for your for your main

00:46:07,420 --> 00:46:10,690
javascript files and that's where you're

00:46:09,160 --> 00:46:12,460
going to go look first and if it can't

00:46:10,690 --> 00:46:14,170
be found you go look somewhere else and

00:46:12,460 --> 00:46:16,600
so on right so the more loading process

00:46:14,170 --> 00:46:20,290
is typically much more complicated in

00:46:16,600 --> 00:46:22,330
the browser and that did not fit in well

00:46:20,290 --> 00:46:24,400
with this particular part of this pack

00:46:22,330 --> 00:46:26,500
that says require should return

00:46:24,400 --> 00:46:29,110
immediately so that's why they started

00:46:26,500 --> 00:46:32,860
doing something else then now let's have

00:46:29,110 --> 00:46:33,110
a look at how that works the the common

00:46:32,860 --> 00:46:39,890
area

00:46:33,110 --> 00:46:41,780
s module system here there we are so

00:46:39,890 --> 00:46:45,710
I've got a file here somewhere which is

00:46:41,780 --> 00:46:48,320
called a test there we are and this

00:46:45,710 --> 00:46:51,620
thing uses the syntax that are just

00:46:48,320 --> 00:46:53,750
outlined with a require core to rolled

00:46:51,620 --> 00:46:56,030
my calculator module from some other

00:46:53,750 --> 00:46:58,640
place right we don't have that thing

00:46:56,030 --> 00:47:01,340
defined yet but this file already exists

00:46:58,640 --> 00:47:03,380
here it is and I can now go in here and

00:47:01,340 --> 00:47:06,290
just do stuff like I just mentioned I

00:47:03,380 --> 00:47:09,440
could just go exports dot add equals

00:47:06,290 --> 00:47:12,470
function if I can type function there we

00:47:09,440 --> 00:47:17,930
go x and y perhaps and then we'll return

00:47:12,470 --> 00:47:20,510
X plus y like so more or less now the

00:47:17,930 --> 00:47:23,990
reason this is is possible immediately

00:47:20,510 --> 00:47:26,600
right here is that node itself uses a

00:47:23,990 --> 00:47:29,120
pattern that is at least very very close

00:47:26,600 --> 00:47:31,190
to the general common jas pattern for

00:47:29,120 --> 00:47:33,170
its module structure so this helper

00:47:31,190 --> 00:47:37,160
function require is actually available

00:47:33,170 --> 00:47:39,410
readily in node and so is the ability to

00:47:37,160 --> 00:47:41,750
use the exports feature for exporting

00:47:39,410 --> 00:47:44,450
the functionality so if I'm going to run

00:47:41,750 --> 00:47:46,580
oh we're still in the debugger here if

00:47:44,450 --> 00:47:51,920
I'm going to run my what's it called

00:47:46,580 --> 00:47:54,470
test calculator oops common jayus there

00:47:51,920 --> 00:47:55,760
we go that's the one I'll get an error

00:47:54,470 --> 00:47:57,500
because we don't support the

00:47:55,760 --> 00:47:59,750
multiplication yet fair enough I'm not

00:47:57,500 --> 00:48:01,730
exporting a multiply function of course

00:47:59,750 --> 00:48:04,490
but we do get the correct result of the

00:48:01,730 --> 00:48:07,340
add operation up there right so my my

00:48:04,490 --> 00:48:09,740
add function has been exported correctly

00:48:07,340 --> 00:48:12,290
from here and I could also add in the

00:48:09,740 --> 00:48:14,300
the functionality of the mult function

00:48:12,290 --> 00:48:16,910
in the same way of course however what

00:48:14,300 --> 00:48:19,040
you typically end up doing is just reuse

00:48:16,910 --> 00:48:21,250
your existing definition of your

00:48:19,040 --> 00:48:24,980
calculator in my case here so I might

00:48:21,250 --> 00:48:26,960
use oops sorry funny keys there we go i

00:48:24,980 --> 00:48:31,100
might use these two blocks here for

00:48:26,960 --> 00:48:33,050
example um like so and create my

00:48:31,100 --> 00:48:35,420
calculator in the usual way oh of course

00:48:33,050 --> 00:48:39,920
I also need my adder let's just copy

00:48:35,420 --> 00:48:42,290
that one in for now there we go and pop

00:48:39,920 --> 00:48:44,180
it at the beginning like so so I've got

00:48:42,290 --> 00:48:46,560
those those elements that I'm just

00:48:44,180 --> 00:48:48,420
copying over to make it obvious that I'm

00:48:46,560 --> 00:48:50,850
how I'm doing this I'm just reusing my

00:48:48,420 --> 00:48:53,430
existing definition code for my for my

00:48:50,850 --> 00:48:55,980
module and then I would just like to

00:48:53,430 --> 00:48:58,860
make this calculator available as my

00:48:55,980 --> 00:49:01,230
export object and in order to do that I

00:48:58,860 --> 00:49:03,650
would now leave this in as a comment

00:49:01,230 --> 00:49:07,500
right here i would do module or exports

00:49:03,650 --> 00:49:10,260
equals calculator right that's it's a

00:49:07,500 --> 00:49:12,210
curiosity of the way node evaluates this

00:49:10,260 --> 00:49:15,030
that you need to prefix exports with

00:49:12,210 --> 00:49:17,370
module in this case if you just do

00:49:15,030 --> 00:49:19,050
exports equals calculator it doesn't

00:49:17,370 --> 00:49:21,150
work because it's not picked up in the

00:49:19,050 --> 00:49:23,430
structure in the right way so by doing

00:49:21,150 --> 00:49:25,560
this here I should now be able to use

00:49:23,430 --> 00:49:28,350
multiplication as well as adding that

00:49:25,560 --> 00:49:31,140
works just fine and I'm now publishing

00:49:28,350 --> 00:49:33,060
my functionality as a node compatible

00:49:31,140 --> 00:49:34,830
module right that's how easy that really

00:49:33,060 --> 00:49:38,040
is nothing else to it this is based on

00:49:34,830 --> 00:49:42,050
the common jas pattern and I check my

00:49:38,040 --> 00:49:45,690
notes see fun missing something ya know

00:49:42,050 --> 00:49:47,880
so that is obviously very simple to do

00:49:45,690 --> 00:49:49,830
really the question of oh there is a

00:49:47,880 --> 00:49:51,720
question actually please go ahead they

00:49:49,830 --> 00:49:55,380
are only available well a node the

00:49:51,720 --> 00:49:57,240
convention is where am I here we go and

00:49:55,380 --> 00:49:59,880
note the convention is that you will

00:49:57,240 --> 00:50:02,640
only have those objects explicitly right

00:49:59,880 --> 00:50:04,710
so no never actually does anything in

00:50:02,640 --> 00:50:05,940
the global namespace or you're not

00:50:04,710 --> 00:50:08,040
supposed to be doing that in your

00:50:05,940 --> 00:50:09,900
applications either I mean you can in

00:50:08,040 --> 00:50:13,350
the end in a node application you might

00:50:09,900 --> 00:50:16,710
have a starting point like your app j/s

00:50:13,350 --> 00:50:18,900
if you do any one of the frameworks or

00:50:16,710 --> 00:50:21,630
stuff like that and in that in that

00:50:18,900 --> 00:50:23,640
startup file you will usually find a

00:50:21,630 --> 00:50:25,500
variety of these require instructions

00:50:23,640 --> 00:50:29,220
there and that's that's the main

00:50:25,500 --> 00:50:32,730
starting point but you can also well you

00:50:29,220 --> 00:50:34,140
can then either pass through in some

00:50:32,730 --> 00:50:36,240
interesting module that you're going to

00:50:34,140 --> 00:50:38,040
reuse somewhere else later you can pass

00:50:36,240 --> 00:50:41,040
that through to some other point in your

00:50:38,040 --> 00:50:42,630
node architecture if you like or on the

00:50:41,040 --> 00:50:45,180
other hand you can just have additional

00:50:42,630 --> 00:50:46,830
require calls later on again that will

00:50:45,180 --> 00:50:48,930
make that module available to you a

00:50:46,830 --> 00:50:50,700
second time right anyway that's how it

00:50:48,930 --> 00:50:52,470
works it's not supposed to live in the

00:50:50,700 --> 00:50:54,240
global namespace at any point that is

00:50:52,470 --> 00:50:56,580
that is their convention really I mean

00:50:54,240 --> 00:50:57,590
if it wasn't of course you would be free

00:50:56,580 --> 00:50:59,660
to

00:50:57,590 --> 00:51:01,130
with the object whatever you like right

00:50:59,660 --> 00:51:02,900
so if you would like to have it in the

00:51:01,130 --> 00:51:05,840
global space and never mind what the

00:51:02,900 --> 00:51:07,400
node guys think fair enough there's

00:51:05,840 --> 00:51:09,890
nothing to keep you from doing that as

00:51:07,400 --> 00:51:11,960
well but that's the way it works here

00:51:09,890 --> 00:51:14,690
and that's the way they prefer to do it

00:51:11,960 --> 00:51:17,690
in node so that's the the simple pattern

00:51:14,690 --> 00:51:21,410
here the other one that I wanted to show

00:51:17,690 --> 00:51:24,440
you is the AMD pattern so let's see I

00:51:21,410 --> 00:51:27,800
think I'll show you this HTML file first

00:51:24,440 --> 00:51:29,120
here now with AMD oh hang on I've

00:51:27,800 --> 00:51:31,100
forgetting something actually I think

00:51:29,120 --> 00:51:35,210
there's a slide on AMD first of all

00:51:31,100 --> 00:51:37,790
exactly right so AMD has the idea of a

00:51:35,210 --> 00:51:40,460
defined function so instead of just

00:51:37,790 --> 00:51:42,350
creating a module as a file like I just

00:51:40,460 --> 00:51:44,900
did right I didn't actually do anything

00:51:42,350 --> 00:51:47,720
to tell the system hey this is my module

00:51:44,900 --> 00:51:50,180
right it's just it just it exists that's

00:51:47,720 --> 00:51:52,520
all there's a file that has a name and

00:51:50,180 --> 00:51:54,260
that's how it's recognized with AMG

00:51:52,520 --> 00:51:57,830
you're supposed to call a define

00:51:54,260 --> 00:52:01,010
function to tell the system the loader

00:51:57,830 --> 00:52:03,140
in the end what your module is and what

00:52:01,010 --> 00:52:05,360
its name is and so on and also by the

00:52:03,140 --> 00:52:07,100
way what its dependencies are because we

00:52:05,360 --> 00:52:09,010
didn't get that with comment reyes right

00:52:07,100 --> 00:52:12,350
there was no dependency thing in there

00:52:09,010 --> 00:52:13,450
with AMD we do have this and the defined

00:52:12,350 --> 00:52:16,340
function allows you to define

00:52:13,450 --> 00:52:19,010
dependencies as well now you also

00:52:16,340 --> 00:52:21,530
require a module loader and in the case

00:52:19,010 --> 00:52:24,140
of node I already had one basically that

00:52:21,530 --> 00:52:26,300
is built into node if you like in the

00:52:24,140 --> 00:52:28,280
case of AMD I'm gonna have to take care

00:52:26,300 --> 00:52:30,230
of myself of making some kind of a

00:52:28,280 --> 00:52:32,540
module loader available and I've

00:52:30,230 --> 00:52:34,880
choosing one that is probably the most

00:52:32,540 --> 00:52:38,750
common of those existing right now which

00:52:34,880 --> 00:52:42,290
is called requirejs so that library

00:52:38,750 --> 00:52:45,440
required ojs is a module loader that is

00:52:42,290 --> 00:52:47,540
compatible with the AMD pattern it also

00:52:45,440 --> 00:52:49,580
supports other patterns but that's the

00:52:47,540 --> 00:52:51,680
main thing that people use today as a

00:52:49,580 --> 00:52:54,320
result I'm just simply referencing that

00:52:51,680 --> 00:52:57,260
script in my little HTML page here and

00:52:54,320 --> 00:52:59,240
I've got this extra tag on here that

00:52:57,260 --> 00:53:02,120
tells it to automatically load a

00:52:59,240 --> 00:53:04,430
javascript file called main j/s right in

00:53:02,120 --> 00:53:07,220
the beginning here and this main joyous

00:53:04,430 --> 00:53:10,100
thing is a piece of code where i'm using

00:53:07,220 --> 00:53:11,310
require again justin is in a different

00:53:10,100 --> 00:53:14,040
syntax to

00:53:11,310 --> 00:53:16,080
what we did before to road to modules

00:53:14,040 --> 00:53:18,870
and the two modules are looking for I

00:53:16,080 --> 00:53:21,270
called jQuery and calculator AMD and

00:53:18,870 --> 00:53:23,700
when those two are loaded they are

00:53:21,270 --> 00:53:26,520
passed into my function that comes here

00:53:23,700 --> 00:53:29,280
as parameters so i'm taking my jquery

00:53:26,520 --> 00:53:32,430
object as the dollar parameter again

00:53:29,280 --> 00:53:35,220
just for you know the the unique effect

00:53:32,430 --> 00:53:37,200
of it and my calculator object as well

00:53:35,220 --> 00:53:38,520
and then i've got a few helpers and this

00:53:37,200 --> 00:53:42,240
basically just implements the

00:53:38,520 --> 00:53:44,220
functionality of very manually hooking

00:53:42,240 --> 00:53:46,230
into various events there so that i can

00:53:44,220 --> 00:53:48,180
quickly test my calculator from the web

00:53:46,230 --> 00:53:50,220
page right so that's all that that thing

00:53:48,180 --> 00:53:52,620
does really nothing surprising in there

00:53:50,220 --> 00:53:55,680
so the thing of course is the module

00:53:52,620 --> 00:53:58,020
loading here and now they're there

00:53:55,680 --> 00:54:01,140
should be as we can guess here a module

00:53:58,020 --> 00:54:03,000
called calculator AMD of course which i

00:54:01,140 --> 00:54:05,040
already have here but it doesn't really

00:54:03,000 --> 00:54:07,470
exist yet so i'm just going to show you

00:54:05,040 --> 00:54:10,080
how we can add this in there and i'll go

00:54:07,470 --> 00:54:12,000
back to my my original code one more

00:54:10,080 --> 00:54:14,340
time and pop in those pieces that we

00:54:12,000 --> 00:54:16,560
need so the other parts were down here i

00:54:14,340 --> 00:54:18,510
think so again you know i'm just doing

00:54:16,560 --> 00:54:20,460
this to point out that you don't have to

00:54:18,510 --> 00:54:22,890
do anything special in order to use

00:54:20,460 --> 00:54:26,190
these features you can just use your

00:54:22,890 --> 00:54:28,260
existing stuff and what what the missus

00:54:26,190 --> 00:54:30,900
here of course is the defined function

00:54:28,260 --> 00:54:33,210
now the defined function takes a

00:54:30,900 --> 00:54:36,270
parameter that specifies the name of the

00:54:33,210 --> 00:54:39,240
module that should be calculator AMD and

00:54:36,270 --> 00:54:41,220
it also takes a list of dependencies

00:54:39,240 --> 00:54:43,890
we're currently i don't have any and

00:54:41,220 --> 00:54:48,090
then it takes a function as a parameter

00:54:43,890 --> 00:54:50,160
and that function gets nothing well

00:54:48,090 --> 00:54:51,570
actually write nothing past in right now

00:54:50,160 --> 00:54:55,080
sorry i was getting ahead of myself

00:54:51,570 --> 00:54:57,080
there for a second and this is supposed

00:54:55,080 --> 00:55:00,300
to return the actual module

00:54:57,080 --> 00:55:02,220
implementation when it is called ok this

00:55:00,300 --> 00:55:04,440
is not call immediately this is called

00:55:02,220 --> 00:55:07,230
by the module loader and it depends upon

00:55:04,440 --> 00:55:09,420
the evaluation of the dependency train

00:55:07,230 --> 00:55:11,970
when it is actually going to be called

00:55:09,420 --> 00:55:14,520
in the end so when this happens i should

00:55:11,970 --> 00:55:16,560
now return an implementation of my

00:55:14,520 --> 00:55:18,810
module which of course in my case is the

00:55:16,560 --> 00:55:22,290
already existing calculator variable

00:55:18,810 --> 00:55:24,960
again right like this so as a result i

00:55:22,290 --> 00:55:28,339
should now be able to open that file

00:55:24,960 --> 00:55:31,320
let me see if that works where are we

00:55:28,339 --> 00:55:33,570
there we are so this is my absolutely

00:55:31,320 --> 00:55:35,880
fantastic web page that I've implemented

00:55:33,570 --> 00:55:39,000
isn't it crazy how chrome doesn't resize

00:55:35,880 --> 00:55:41,250
the buttons to fit the text oh no no no

00:55:39,000 --> 00:55:43,349
styles on this implementation right so

00:55:41,250 --> 00:55:45,450
let's add those and gives me 9 and

00:55:43,349 --> 00:55:47,970
multiply them gives me 20 so that seems

00:55:45,450 --> 00:55:50,460
to work correctly you can see if you

00:55:47,970 --> 00:55:53,580
look at the the network traffic and

00:55:50,460 --> 00:55:55,770
stuff like that here yes the one isn't

00:55:53,580 --> 00:55:57,660
it let's just reload this you can see

00:55:55,770 --> 00:56:01,770
how the individual files are being

00:55:57,660 --> 00:56:06,660
loaded right so let's try to resize this

00:56:01,770 --> 00:56:08,310
a bit oh I'll resize more Oh what am i

00:56:06,660 --> 00:56:09,780
doing I don't have to resize do I

00:56:08,310 --> 00:56:12,000
because the names are right here in the

00:56:09,780 --> 00:56:14,099
beginning so let's see we're loading

00:56:12,000 --> 00:56:15,869
manger yes and then we're loading jquery

00:56:14,099 --> 00:56:18,900
and then we're loading calculator i am

00:56:15,869 --> 00:56:20,460
DJ s right we can basically see exactly

00:56:18,900 --> 00:56:22,740
how this loading mechanism works

00:56:20,460 --> 00:56:25,230
step-by-step and pulls in all the

00:56:22,740 --> 00:56:28,050
various items that i need in order to

00:56:25,230 --> 00:56:31,560
run my functionality in the end so that

00:56:28,050 --> 00:56:33,390
is the basics of how AMD works use a

00:56:31,560 --> 00:56:35,280
loader there are several others out

00:56:33,390 --> 00:56:37,500
there if you don't like require for some

00:56:35,280 --> 00:56:40,440
reason I personally do but there's a

00:56:37,500 --> 00:56:43,290
choice and then create your module by

00:56:40,440 --> 00:56:44,790
using the define instruction something

00:56:43,290 --> 00:56:47,220
interesting about this by the way is

00:56:44,790 --> 00:56:49,200
that the define doesn't have to be the

00:56:47,220 --> 00:56:51,599
only define in one particular file

00:56:49,200 --> 00:56:53,490
necessarily right I mean of course you

00:56:51,599 --> 00:56:56,760
have to make sure somehow that your

00:56:53,490 --> 00:56:59,700
defines all get evaluated so if you use

00:56:56,760 --> 00:57:01,740
require the the main piece of advice

00:56:59,700 --> 00:57:04,230
that they give you really to totally

00:57:01,740 --> 00:57:09,000
make use of the require functionality is

00:57:04,230 --> 00:57:11,310
to only load require itself from your

00:57:09,000 --> 00:57:12,810
main HTML file I mean that's the

00:57:11,310 --> 00:57:15,150
recommendation you don't have to adhere

00:57:12,810 --> 00:57:17,339
to it but I'm mentioning it now because

00:57:15,150 --> 00:57:19,470
if you think about it or you if you

00:57:17,339 --> 00:57:22,109
think about the option of having more

00:57:19,470 --> 00:57:25,109
than one define in the same JavaScript

00:57:22,109 --> 00:57:27,390
file of course the automatic mechanism

00:57:25,109 --> 00:57:29,099
of loading this via the module and file

00:57:27,390 --> 00:57:31,500
name is not going to work anymore

00:57:29,099 --> 00:57:33,390
because there will only be one file name

00:57:31,500 --> 00:57:35,849
but that corresponds more than one

00:57:33,390 --> 00:57:37,460
module in that case right so you would

00:57:35,849 --> 00:57:39,980
then have to load the

00:57:37,460 --> 00:57:42,680
fire with the defines inside yourself

00:57:39,980 --> 00:57:45,890
somehow so that's so that the Lord

00:57:42,680 --> 00:57:47,960
arisia where of where those modules are

00:57:45,890 --> 00:57:50,270
there are also ways of doing advanced

00:57:47,960 --> 00:57:52,670
customer sorry configuration with

00:57:50,270 --> 00:57:54,619
requirejs so i should mention this

00:57:52,670 --> 00:57:57,619
that's an alternative you can basically

00:57:54,619 --> 00:57:59,839
tell require what the exact structure is

00:57:57,619 --> 00:58:01,760
and so on anyway it's something that

00:57:59,839 --> 00:58:03,770
comes to mind once you see the structure

00:58:01,760 --> 00:58:05,869
of this that you may now combine in any

00:58:03,770 --> 00:58:07,730
way you like and that is true you can

00:58:05,869 --> 00:58:10,160
however you still have to do some

00:58:07,730 --> 00:58:12,230
additional work if you move away from

00:58:10,160 --> 00:58:15,530
the basic idea of having a module per

00:58:12,230 --> 00:58:18,170
file kind of thing right so that's how

00:58:15,530 --> 00:58:20,630
that thing works let me just quickly

00:58:18,170 --> 00:58:24,109
check my notes if I've got anything

00:58:20,630 --> 00:58:27,980
important i wanted to mention all right

00:58:24,109 --> 00:58:30,230
oh yeah well actually i did want to do

00:58:27,980 --> 00:58:32,089
one more thing that's true which is i

00:58:30,230 --> 00:58:34,070
wanted to point out the fact that we're

00:58:32,089 --> 00:58:36,710
not really taking advantage of the

00:58:34,070 --> 00:58:39,200
dependency feature yet in here right so

00:58:36,710 --> 00:58:41,150
i could take my adder and pull it out

00:58:39,200 --> 00:58:43,820
into its own module I've got an adder

00:58:41,150 --> 00:58:46,160
ojs here so it's puppet in here and then

00:58:43,820 --> 00:58:50,599
I could also have a defined line down

00:58:46,160 --> 00:58:53,900
there like this and define an adder

00:58:50,599 --> 00:58:55,820
module right so this would be the adder

00:58:53,900 --> 00:58:58,130
object so I've got my adder module

00:58:55,820 --> 00:59:00,890
defined and now I can take advantage of

00:58:58,130 --> 00:59:03,560
the dependency feature so i put my adder

00:59:00,890 --> 00:59:06,020
in here and then i should probably also

00:59:03,560 --> 00:59:08,060
change something about my initialization

00:59:06,020 --> 00:59:10,280
order because it makes more sense now to

00:59:08,060 --> 00:59:11,990
do it like this and i'll show you in a

00:59:10,280 --> 00:59:14,510
second while that is let me just indent

00:59:11,990 --> 00:59:16,700
this a bit because the adder will now be

00:59:14,510 --> 00:59:20,180
passed in as a parameter to this into

00:59:16,700 --> 00:59:21,859
our function here and of course only

00:59:20,180 --> 00:59:23,960
when the adder is available can i

00:59:21,859 --> 00:59:26,570
actually use the augmentation here for

00:59:23,960 --> 00:59:29,300
my calculator now of course in reality

00:59:26,570 --> 00:59:32,720
maybe you would just have your entire

00:59:29,300 --> 00:59:34,190
definition inside the block here right

00:59:32,720 --> 00:59:36,680
so that's fair enough i just wanted to

00:59:34,190 --> 00:59:38,480
make the minimum change that you need in

00:59:36,680 --> 00:59:40,220
order to make this work and that does

00:59:38,480 --> 00:59:42,530
require changing the initialization

00:59:40,220 --> 00:59:44,780
order ever so slightly because otherwise

00:59:42,530 --> 00:59:47,180
it's not going to work anymore so with

00:59:44,780 --> 00:59:48,980
this implementation we have now my code

00:59:47,180 --> 00:59:50,870
should still work in the same way let's

00:59:48,980 --> 00:59:53,090
try to reload this whole thing

00:59:50,870 --> 00:59:55,970
and actually I've seen this before

00:59:53,090 --> 00:59:59,450
sometimes web pages that have used

00:59:55,970 --> 01:00:01,730
required rjs with chrome in order to

00:59:59,450 --> 01:00:03,950
load their stuff don't reload quite

01:00:01,730 --> 01:00:07,520
correctly Oh something's wrong with my

01:00:03,950 --> 01:00:09,530
multiplication what happened there no

01:00:07,520 --> 01:00:11,030
method mulch what am I doing wrong all

01:00:09,530 --> 01:00:12,800
right I'm doing something wrong that I

01:00:11,030 --> 01:00:15,380
frequently do wrong when i do this demo

01:00:12,800 --> 01:00:18,050
right i can't use the second VAR and

01:00:15,380 --> 01:00:20,840
there of course because the the VAR will

01:00:18,050 --> 01:00:24,410
otherwise override the calculator so ok

01:00:20,840 --> 01:00:26,240
let's try this one more time there we go

01:00:24,410 --> 01:00:28,040
reopen the page always a good

01:00:26,240 --> 01:00:30,110
recommendation if you find that chrome

01:00:28,040 --> 01:00:32,360
doesn't appear to be reloading your page

01:00:30,110 --> 01:00:34,280
correctly that happens apparently with

01:00:32,360 --> 01:00:36,260
require occasionally when files have

01:00:34,280 --> 01:00:39,650
been loaded after the fact by the

01:00:36,260 --> 01:00:41,090
require library ok so that's something

01:00:39,650 --> 01:00:42,650
else I wanted to show you with the

01:00:41,090 --> 01:00:44,750
dependencies because that's really the

01:00:42,650 --> 01:00:46,700
idea of course of building those change

01:00:44,750 --> 01:00:49,670
and chains and having those reusable

01:00:46,700 --> 01:00:53,210
blocks and everything in there and I

01:00:49,670 --> 01:00:54,920
think I'm almost done I did well alright

01:00:53,210 --> 01:00:57,110
one final thing to show you I wanted to

01:00:54,920 --> 01:00:59,840
show you how you can use both patterns

01:00:57,110 --> 01:01:02,180
at the same time and I just recommend

01:00:59,840 --> 01:01:03,950
you look at an existing library for that

01:01:02,180 --> 01:01:07,580
purpose for example here's Drake very

01:01:03,950 --> 01:01:11,180
right at the end of it we have a piece

01:01:07,580 --> 01:01:13,880
of code that looks like this here so

01:01:11,180 --> 01:01:15,920
they basically just check if they are in

01:01:13,880 --> 01:01:17,990
a particular environment right here they

01:01:15,920 --> 01:01:20,150
check if there's a module that exports

01:01:17,990 --> 01:01:22,850
for example stuff like that and if that

01:01:20,150 --> 01:01:25,190
is the case they initialize module

01:01:22,850 --> 01:01:26,810
exports to the jQuery object right

01:01:25,190 --> 01:01:29,420
similar to what I was showing you with

01:01:26,810 --> 01:01:31,220
my calculator object otherwise if that

01:01:29,420 --> 01:01:33,560
does not exist they make themselves

01:01:31,220 --> 01:01:35,330
available through the window like so

01:01:33,560 --> 01:01:37,850
that's what you usually end up using in

01:01:35,330 --> 01:01:40,040
a browser and they also check if there

01:01:37,850 --> 01:01:43,100
is a defined function available for the

01:01:40,040 --> 01:01:45,200
AMD pattern and if so they call define

01:01:43,100 --> 01:01:47,720
in order to make jquery available to an

01:01:45,200 --> 01:01:50,060
AMD compatible order right so that's not

01:01:47,720 --> 01:01:52,070
too hard to do you can't create modules

01:01:50,060 --> 01:01:54,200
that adhere to more than one of those

01:01:52,070 --> 01:01:56,480
patterns at the same time which of

01:01:54,200 --> 01:01:59,390
course gives you know your users the

01:01:56,480 --> 01:02:01,520
most flexible approaches to load your

01:01:59,390 --> 01:02:03,290
models whether they use them on the

01:02:01,520 --> 01:02:04,210
server side or the client side or

01:02:03,290 --> 01:02:06,650
whatever

01:02:04,210 --> 01:02:07,700
finally I've got some bullets here that

01:02:06,650 --> 01:02:09,410
you might want to look at because

01:02:07,700 --> 01:02:12,500
there's more to say on the topic of

01:02:09,410 --> 01:02:14,390
course require Jas has quite a lot of

01:02:12,500 --> 01:02:17,960
functionality that I haven't shown you

01:02:14,390 --> 01:02:20,150
now for example it can load jquery and

01:02:17,960 --> 01:02:22,130
its individual sub modules in a

01:02:20,150 --> 01:02:23,990
particular way there's a special support

01:02:22,130 --> 01:02:26,300
for that one they also have this

01:02:23,990 --> 01:02:28,760
optimizer which is a build time tool

01:02:26,300 --> 01:02:30,830
that allows you to minify and combine

01:02:28,760 --> 01:02:33,610
javascript files so you may end up

01:02:30,830 --> 01:02:36,980
having to load just one javascript file

01:02:33,610 --> 01:02:39,020
from the server when a requirement is

01:02:36,980 --> 01:02:40,520
fulfilled through the dependency chain

01:02:39,020 --> 01:02:42,860
right that kind of thing so that's

01:02:40,520 --> 01:02:45,560
pretty cool and it can also be used

01:02:42,860 --> 01:02:47,540
server side so if you think AMD is cool

01:02:45,560 --> 01:02:49,580
and you don't really like the common jas

01:02:47,540 --> 01:02:52,850
based module loading like you do a node

01:02:49,580 --> 01:02:55,490
typically you can use a module in node

01:02:52,850 --> 01:02:58,010
that corresponds to require and then

01:02:55,490 --> 01:03:00,320
load your other modules through the AMD

01:02:58,010 --> 01:03:02,840
pattern even on the server side so

01:03:00,320 --> 01:03:04,580
that's also possible and you can go the

01:03:02,840 --> 01:03:07,310
other way that's my final bullet here

01:03:04,580 --> 01:03:09,440
tools like browserify and a few others

01:03:07,310 --> 01:03:12,170
that have the same kind of purpose allow

01:03:09,440 --> 01:03:14,450
you to use common J's modules on the

01:03:12,170 --> 01:03:18,860
client side they basically have a rapper

01:03:14,450 --> 01:03:21,200
that supplements the the asynchronous

01:03:18,860 --> 01:03:24,140
loading mechanism that we have in the

01:03:21,200 --> 01:03:27,170
AMD pattern and allows you to use the

01:03:24,140 --> 01:03:29,330
common areas pattern type modules in the

01:03:27,170 --> 01:03:31,400
client even though they don't normally

01:03:29,330 --> 01:03:33,860
load asynchronously so that's sort o

01:03:31,400 --> 01:03:36,230
matic in that way right so stuff for you

01:03:33,860 --> 01:03:38,360
to look at otherwise we're out of time I

01:03:36,230 --> 01:03:39,950
think and that's all I had to say so

01:03:38,360 --> 01:03:41,420
I'll just wrap it up right now and say

01:03:39,950 --> 01:03:43,280
thank you very much if you have any

01:03:41,420 --> 01:03:45,110
queries I'll be around till tomorrow

01:03:43,280 --> 01:03:47,060
evening and you can always send me an

01:03:45,110 --> 01:03:49,240
email if you like thanks for being here

01:03:47,060 --> 01:03:49,240

YouTube URL: https://www.youtube.com/watch?v=kU9Wnk85abU


