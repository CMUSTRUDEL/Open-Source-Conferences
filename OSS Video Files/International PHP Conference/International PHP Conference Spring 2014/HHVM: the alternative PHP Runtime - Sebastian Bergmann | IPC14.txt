Title: HHVM: the alternative PHP Runtime - Sebastian Bergmann | IPC14
Publication date: 2016-06-09
Playlist: International PHP Conference Spring 2014
Description: 
	The PHP language is almost 20 years old, as is its reference implementation that can be downloaded from PHP.net. In the last decade, alternative runtimes for PHP came and went. The HipHop VM (HHVM) that is developed – and used in production – by Facebook, however, is probably not only here to stay but very likely going to influence the future of PHP considerably. High time to have an in-depth look at what HHVM is and how it works. (Speaker: Sebastian Bergmann, thePHP.cc)

More information: https://phpconference.com/en/
Captions: 
	00:00:07,639 --> 00:00:20,330
hello good afternoon this is the second

00:00:14,700 --> 00:00:23,100
out of three ATM talks this afternoon I

00:00:20,330 --> 00:00:25,289
hope that it's not too close to what

00:00:23,100 --> 00:00:29,250
Stefan just did just a different

00:00:25,289 --> 00:00:32,099
perspective and if you observe me

00:00:29,250 --> 00:00:34,380
closely at some point at certain points

00:00:32,099 --> 00:00:37,140
during the presentations you will see

00:00:34,380 --> 00:00:41,340
that I am excited about something and

00:00:37,140 --> 00:00:44,930
very enthusiastic but other times I will

00:00:41,340 --> 00:00:50,539
be somewhere between frustrated and

00:00:44,930 --> 00:00:53,969
angry and at the moment really split

00:00:50,539 --> 00:00:57,480
like a split personality of how to think

00:00:53,969 --> 00:01:00,180
about this thing that Adrian is and I'm

00:00:57,480 --> 00:01:02,940
not sure which part of my inner team if

00:01:00,180 --> 00:01:06,659
you will is going to win the battle so

00:01:02,940 --> 00:01:09,860
that's going to be interesting okay

00:01:06,659 --> 00:01:14,430
Atrix p.m. the alternative PHP runtime I

00:01:09,860 --> 00:01:16,680
think this is now I don't know how many

00:01:14,430 --> 00:01:18,420
alternative runtimes we have for PHP

00:01:16,680 --> 00:01:21,720
two years ago I did a presentation at

00:01:18,420 --> 00:01:25,200
Frost Khan at that time I found more

00:01:21,720 --> 00:01:30,689
than 20 alternative implementations of

00:01:25,200 --> 00:01:33,659
the PHP language don't vary the only

00:01:30,689 --> 00:01:38,460
real alternative alternative as in it

00:01:33,659 --> 00:01:39,750
can actually run PHP code it's 83 m so

00:01:38,460 --> 00:01:41,820
you don't have to look at 20 different

00:01:39,750 --> 00:01:44,009
things you just have to look at one so

00:01:41,820 --> 00:01:45,509
high name is Sebastian has been doing

00:01:44,009 --> 00:01:51,299
this thing with PHP for a really long

00:01:45,509 --> 00:01:53,610
time now and I started somebody 98 and I

00:01:51,299 --> 00:01:56,100
really like to help PHP developers build

00:01:53,610 --> 00:01:59,130
better software with the PHP platform

00:01:56,100 --> 00:02:01,170
mr. PHP language and tools around it you

00:01:59,130 --> 00:02:03,180
can call me a pain driven developer if

00:02:01,170 --> 00:02:06,119
you want because a couple of years ago I

00:02:03,180 --> 00:02:08,759
felt the pain of not having tools like

00:02:06,119 --> 00:02:10,440
PHP unit and PHP copy-pasted sector and

00:02:08,759 --> 00:02:12,300
I waited for a bit

00:02:10,440 --> 00:02:13,319
nobody was implementing them so

00:02:12,300 --> 00:02:14,969
eventually

00:02:13,319 --> 00:02:17,099
I built those tools I shared them with

00:02:14,969 --> 00:02:21,359
the world and apparently people started

00:02:17,099 --> 00:02:23,340
using them which is good I have a

00:02:21,359 --> 00:02:25,439
company we do everything it has to do

00:02:23,340 --> 00:02:27,510
with knowledge transfer related to PHP

00:02:25,439 --> 00:02:29,159
and surrounding technologies consulting

00:02:27,510 --> 00:02:33,599
coaching training that's about as much

00:02:29,159 --> 00:02:36,599
marketing as I'm going to do and while

00:02:33,599 --> 00:02:40,079
preparing this presentation I thought

00:02:36,599 --> 00:02:42,209
hey we are in Germany so maybe we should

00:02:40,079 --> 00:02:46,319
do something called radically new and

00:02:42,209 --> 00:02:47,909
start something in Germany you prop even

00:02:46,319 --> 00:02:49,049
if you're not German you may have heard

00:02:47,909 --> 00:02:53,699
of this guy

00:02:49,049 --> 00:02:55,739
good one of our thinkers and poets back

00:02:53,699 --> 00:02:59,849
when Germany actually had good thinkers

00:02:55,739 --> 00:03:02,219
and poets and intelligent people so

00:02:59,849 --> 00:03:04,949
basically in case you don't know German

00:03:02,219 --> 00:03:07,829
what it says there is let him who fails

00:03:04,949 --> 00:03:11,010
to learn and Mark three thousand years

00:03:07,829 --> 00:03:12,719
still stay void of experience in the

00:03:11,010 --> 00:03:15,169
dark and live from day to day

00:03:12,719 --> 00:03:18,379
meaning if you don't know your history

00:03:15,169 --> 00:03:22,189
how can you possibly try to understand

00:03:18,379 --> 00:03:26,069
the past and maybe even the future so

00:03:22,189 --> 00:03:31,259
yes he will talk about hh3m but I think

00:03:26,069 --> 00:03:35,009
it can help to look a bit where we're

00:03:31,259 --> 00:03:38,729
coming from how this thing PHP actually

00:03:35,009 --> 00:03:41,909
works how that led to problems that

00:03:38,729 --> 00:03:47,579
Facebook had and motivated them to find

00:03:41,909 --> 00:03:49,409
a solution I don't know if you know that

00:03:47,579 --> 00:03:53,189
but actually we have a really big

00:03:49,409 --> 00:03:58,109
anniversary for PHP this year PHP will

00:03:53,189 --> 00:04:01,280
turn twenty this year was in 94 that

00:03:58,109 --> 00:04:04,349
Rasmus was working on his website and he

00:04:01,280 --> 00:04:07,680
built the first thing of what eventually

00:04:04,349 --> 00:04:11,729
would become PHP the initial name was

00:04:07,680 --> 00:04:14,549
personal homepage tools that quickly

00:04:11,729 --> 00:04:16,919
changed in 95 to the forms interpreters

00:04:14,549 --> 00:04:21,000
he got rid of personal homepage which

00:04:16,919 --> 00:04:23,580
later was abbreviated to PHP the PHP

00:04:21,000 --> 00:04:25,680
came back a couple of months later like

00:04:23,580 --> 00:04:27,170
three or four months later and he called

00:04:25,680 --> 00:04:31,010
it a personal homepage construction

00:04:27,170 --> 00:04:32,950
it that's not really buzz Verde or short

00:04:31,010 --> 00:04:38,270
or catchy

00:04:32,950 --> 00:04:42,350
so in 96 he shortened it and it became

00:04:38,270 --> 00:04:45,830
PHP fi personal home page tools forms

00:04:42,350 --> 00:04:49,220
interpreter whatever but everyone just

00:04:45,830 --> 00:04:50,990
referred to it as PHP Fi and yes they

00:04:49,220 --> 00:04:56,150
are still website or servers out there

00:04:50,990 --> 00:04:58,910
that deliver websites through PHP fi you

00:04:56,150 --> 00:05:01,970
can refer to this as PHP - it's still

00:04:58,910 --> 00:05:06,440
being used those are some really

00:05:01,970 --> 00:05:13,630
adventurous people no bug fixes in 18 or

00:05:06,440 --> 00:05:13,630
19 years that works so in 98

00:05:13,760 --> 00:05:20,420
- students in Israel who were attending

00:05:16,700 --> 00:05:23,450
a lecture on how to build compilers came

00:05:20,420 --> 00:05:25,190
across PHP if I started using it they

00:05:23,450 --> 00:05:26,060
were starting a little bit of a business

00:05:25,190 --> 00:05:28,400
at a hosting company

00:05:26,060 --> 00:05:29,660
we're interning there for summarize or

00:05:28,400 --> 00:05:32,330
something like that I don't

00:05:29,660 --> 00:05:35,840
I forgot the details but they were using

00:05:32,330 --> 00:05:38,120
PHP Fi and it solved their problem but

00:05:35,840 --> 00:05:43,550
they thought hey it could be implemented

00:05:38,120 --> 00:05:45,800
a lot better so as the way that Rasmus

00:05:43,550 --> 00:05:48,560
explained that he wanted to solve the

00:05:45,800 --> 00:05:51,560
problem he wanted to build websites and

00:05:48,560 --> 00:05:53,240
he built a PHP fi for that but he didn't

00:05:51,560 --> 00:05:55,790
really know and didn't really care about

00:05:53,240 --> 00:05:58,930
how to properly implement the

00:05:55,790 --> 00:06:01,550
programming language so he mailed it in

00:05:58,930 --> 00:06:05,150
a really pragmatic way which meant that

00:06:01,550 --> 00:06:09,410
for instance if you had a for loop you

00:06:05,150 --> 00:06:12,500
would or PHP fi interpreted source calls

00:06:09,410 --> 00:06:14,060
files line by line so it found the line

00:06:12,500 --> 00:06:16,010
that had a for statement okay it

00:06:14,060 --> 00:06:18,020
remembered somewhere here a for loop

00:06:16,010 --> 00:06:20,720
starts and then it executed code it came

00:06:18,020 --> 00:06:22,460
to the end of the for loop it checked

00:06:20,720 --> 00:06:24,950
whether or not the loop has to run again

00:06:22,460 --> 00:06:27,020
and then it backtracked lines back to

00:06:24,950 --> 00:06:28,850
the line with the for loop that's not

00:06:27,020 --> 00:06:30,890
how you build a compiler or an

00:06:28,850 --> 00:06:33,170
interpreter or implement the programming

00:06:30,890 --> 00:06:35,270
language but it worked it's not very

00:06:33,170 --> 00:06:38,260
fast it's not very efficient for the

00:06:35,270 --> 00:06:40,850
first was a good product

00:06:38,260 --> 00:06:43,430
so Andy and Jeff came along and said hey

00:06:40,850 --> 00:06:46,400
the speech we have I think that has

00:06:43,430 --> 00:06:48,260
potential but it's implemented poorly we

00:06:46,400 --> 00:06:50,690
can do better and they were just doing

00:06:48,260 --> 00:06:52,750
this learning all of these things about

00:06:50,690 --> 00:06:58,190
compilers and they build something and

00:06:52,750 --> 00:07:01,630
propose that to Rasmus in 98 and this

00:06:58,190 --> 00:07:05,720
led to PHP 3

00:07:01,630 --> 00:07:09,110
note the - fi the slash of is gone it's

00:07:05,720 --> 00:07:10,720
now three and it was not referred to

00:07:09,110 --> 00:07:14,030
that at that point but the thing that

00:07:10,720 --> 00:07:18,170
Zev and Andy proposed would later be

00:07:14,030 --> 00:07:22,910
known as designed engine you can call

00:07:18,170 --> 00:07:26,000
this an engine 0.5 if you want for a

00:07:22,910 --> 00:07:29,150
while they thought hey 53 is much better

00:07:26,000 --> 00:07:32,960
than PHP fi but they still took a lot of

00:07:29,150 --> 00:07:34,970
shortcuts and wasn't really well it

00:07:32,960 --> 00:07:36,140
still could be implemented better so

00:07:34,970 --> 00:07:38,330
they worked a couple of years on it

00:07:36,140 --> 00:07:41,090
other people contributed and then in

00:07:38,330 --> 00:07:43,070
2000 p34 came out with an engine one and

00:07:41,090 --> 00:07:45,620
for the first time the names and engine

00:07:43,070 --> 00:07:50,530
comes into play as the compiling and

00:07:45,620 --> 00:07:55,340
interpreting kernel of the PHP runtime

00:07:50,530 --> 00:08:00,710
and again it was not really implemented

00:07:55,340 --> 00:08:08,380
well well you learn you learn new things

00:08:00,710 --> 00:08:11,960
and and and so on and in 2005 we got p35

00:08:08,380 --> 00:08:13,880
this is an engine - and it actually was

00:08:11,960 --> 00:08:14,390
a lot better than everything that we had

00:08:13,880 --> 00:08:19,430
before

00:08:14,390 --> 00:08:21,650
yes it's not perfect but over the course

00:08:19,430 --> 00:08:24,680
of the PHP 5 release series from version

00:08:21,650 --> 00:08:26,690
to version PHP has done a really really

00:08:24,680 --> 00:08:31,160
good job of getting better with resorts

00:08:26,690 --> 00:08:34,070
with regards to performance and resource

00:08:31,160 --> 00:08:39,410
consumption but for some people that was

00:08:34,070 --> 00:08:41,150
not enough but so about how does the PHP

00:08:39,410 --> 00:08:43,580
5 runtime actually work it's an

00:08:41,150 --> 00:08:45,320
interpreter which is not really true

00:08:43,580 --> 00:08:47,330
because it's actually an inter Pilar

00:08:45,320 --> 00:08:49,020
which is somewhere between a compiler

00:08:47,330 --> 00:08:50,910
and an interpreter

00:08:49,020 --> 00:08:52,410
a real interpreter would be something

00:08:50,910 --> 00:08:55,740
like Rasmus didn't do in a very

00:08:52,410 --> 00:08:58,650
beginning try to run the code line by

00:08:55,740 --> 00:09:00,870
line whereas inter Pilar has some sort

00:08:58,650 --> 00:09:03,780
of compilation going on taking the

00:09:00,870 --> 00:09:05,340
source code transforming into it into an

00:09:03,780 --> 00:09:07,830
intermediate format that they can then

00:09:05,340 --> 00:09:09,750
be executed but if we look at this

00:09:07,830 --> 00:09:14,220
really really simple piece of code if

00:09:09,750 --> 00:09:17,190
true print star first step that every

00:09:14,220 --> 00:09:22,410
compiler does is try to figure out which

00:09:17,190 --> 00:09:24,300
words which known concepts of the

00:09:22,410 --> 00:09:26,220
programming language are actually in the

00:09:24,300 --> 00:09:31,440
source code file and this is called

00:09:26,220 --> 00:09:33,860
scanning or tokenizing and there are

00:09:31,440 --> 00:09:37,290
tools for instance that you can use to

00:09:33,860 --> 00:09:41,010
visualize the tokens of a PV source code

00:09:37,290 --> 00:09:42,810
file PHP T TV talk it's a tool for that

00:09:41,010 --> 00:09:45,920
for instance that that's the output of

00:09:42,810 --> 00:09:48,210
that and this simple piece of code is

00:09:45,920 --> 00:09:51,810
transformed in this very first step into

00:09:48,210 --> 00:09:53,250
tokens and this happens by reading the

00:09:51,810 --> 00:09:57,750
source code file character by character

00:09:53,250 --> 00:10:00,030
and whenever PHP recognizes something it

00:09:57,750 --> 00:10:01,850
emits the so-called token and starts

00:10:00,030 --> 00:10:07,560
scanning characters for the next token

00:10:01,850 --> 00:10:11,100
so V reads this symbol the question mark

00:10:07,560 --> 00:10:14,490
UPD h2p and Petri says hey I recognize

00:10:11,100 --> 00:10:18,510
that that is a T open tag and then it

00:10:14,490 --> 00:10:20,130
reads an eye and an F hey that's an if

00:10:18,510 --> 00:10:23,550
statement and then some white space and

00:10:20,130 --> 00:10:26,430
so on eventually we have a stream of

00:10:23,550 --> 00:10:28,500
tokens a token string but that token

00:10:26,430 --> 00:10:31,560
stream does not necessarily tell us

00:10:28,500 --> 00:10:33,710
whether or not it's a valid sentence if

00:10:31,560 --> 00:10:36,360
you will of the programming language

00:10:33,710 --> 00:10:40,410
that's where parsing comes into play

00:10:36,360 --> 00:10:42,630
do these parts appear in an order that

00:10:40,410 --> 00:10:45,390
is valid and makes sense

00:10:42,630 --> 00:10:48,690
and for this simple example if through

00:10:45,390 --> 00:10:51,360
print star we have a so-called unchecked

00:10:48,690 --> 00:10:53,340
statement implementation detail you

00:10:51,360 --> 00:10:54,930
don't really want to know about ticked

00:10:53,340 --> 00:10:58,590
and unchecked statements

00:10:54,930 --> 00:11:01,620
trust me I've tried to understand it at

00:10:58,590 --> 00:11:03,690
some point and my head almost exploded

00:11:01,620 --> 00:11:06,360
think of it as a statement we have a

00:11:03,690 --> 00:11:09,540
statement and the statement is comprised

00:11:06,360 --> 00:11:11,690
of an if-then brace an expression a

00:11:09,540 --> 00:11:14,670
closing brace and another statement and

00:11:11,690 --> 00:11:17,310
our expression in fact is an expression

00:11:14,670 --> 00:11:22,730
without a variable in fact it's a scaler

00:11:17,310 --> 00:11:25,170
and that's true so if true braces braces

00:11:22,730 --> 00:11:28,710
that's the first part and then we have a

00:11:25,170 --> 00:11:31,080
statement that's executed or that's

00:11:28,710 --> 00:11:33,150
attached to the if statement again it's

00:11:31,080 --> 00:11:34,560
an unchecked statement if you have the

00:11:33,150 --> 00:11:36,090
opening curly brace the closing curly

00:11:34,560 --> 00:11:38,640
brace an expression an expression

00:11:36,090 --> 00:11:40,050
without a variable and it's a print and

00:11:38,640 --> 00:11:43,380
I'm not showing everything there because

00:11:40,050 --> 00:11:45,720
that would not fit on the slide even for

00:11:43,380 --> 00:11:47,610
such a small piece of code and then the

00:11:45,720 --> 00:11:52,920
next thing that the PHP interpreter does

00:11:47,610 --> 00:11:56,190
is not do what real compilers like Java

00:11:52,920 --> 00:11:59,610
see for the Java Virtual Machine or GCC

00:11:56,190 --> 00:12:06,150
for C and C++ code - they don't go and

00:11:59,610 --> 00:12:07,470
do optimizations on this representation

00:12:06,150 --> 00:12:09,570
of the code they don't even do

00:12:07,470 --> 00:12:11,190
optimization or PHP doesn't even do

00:12:09,570 --> 00:12:13,440
optimizations on that level of code

00:12:11,190 --> 00:12:16,520
which is the final format so after the

00:12:13,440 --> 00:12:19,020
parse tree we go down to byte code if

00:12:16,520 --> 00:12:20,720
you've never seen PHP byte code before

00:12:19,020 --> 00:12:24,510
this is what the PHP interpreter

00:12:20,720 --> 00:12:28,590
internally sees your code like if you've

00:12:24,510 --> 00:12:32,310
ever seen assembly language or Java byte

00:12:28,590 --> 00:12:38,580
code for the JVM looks very similar in

00:12:32,310 --> 00:12:42,830
PHP every function or method including

00:12:38,580 --> 00:12:45,440
the pseudo main function of a PHP script

00:12:42,830 --> 00:12:48,240
which is code in the global scope is

00:12:45,440 --> 00:12:52,740
compiled down into a so called

00:12:48,240 --> 00:12:57,260
OP array each up array contains multiple

00:12:52,740 --> 00:13:00,420
up lines each up line has one opcode

00:12:57,260 --> 00:13:04,170
last time I checked PHP has around 200

00:13:00,420 --> 00:13:06,990
up codes operations like basic

00:13:04,170 --> 00:13:10,020
arithmetic or calling a function calling

00:13:06,990 --> 00:13:12,420
a method creating an object printing

00:13:10,020 --> 00:13:15,520
output stuff like that really low-level

00:13:12,420 --> 00:13:20,440
operations jumping around like

00:13:15,520 --> 00:13:24,040
if statements each of these up lines has

00:13:20,440 --> 00:13:27,220
an opcode and up codes can have operands

00:13:24,040 --> 00:13:31,390
data registers if you want to use the

00:13:27,220 --> 00:13:35,740
CPU terminology to operate on so we have

00:13:31,390 --> 00:13:37,930
a jump at JM PZ statement which which is

00:13:35,740 --> 00:13:41,290
a jump if 0 that's the result of

00:13:37,930 --> 00:13:44,950
compiling if true that's the operand for

00:13:41,290 --> 00:13:47,770
the GMP Z and if that jump is executed

00:13:44,950 --> 00:13:50,260
we jump to up code number six which is

00:13:47,770 --> 00:13:52,750
the end of the file if we don't jump if

00:13:50,260 --> 00:13:54,970
you print the star as we can see here

00:13:52,750 --> 00:13:58,690
the print opcode actually has a return

00:13:54,970 --> 00:14:00,339
value and since we don't do anything

00:13:58,690 --> 00:14:04,420
with that return value it's immediately

00:14:00,339 --> 00:14:06,730
freed and in real compilers you optimize

00:14:04,420 --> 00:14:09,190
I would automatically get rid of this

00:14:06,730 --> 00:14:11,320
opcode it doesn't really hurt us it

00:14:09,190 --> 00:14:14,430
starts to hurt us if you run that piece

00:14:11,320 --> 00:14:19,420
of code billions of times per second

00:14:14,430 --> 00:14:21,100
then you actually feel slowdown but PHP

00:14:19,420 --> 00:14:22,510
is an interpreter or was intended as an

00:14:21,100 --> 00:14:24,370
interpreted language so we never really

00:14:22,510 --> 00:14:26,500
cared about optimizing this

00:14:24,370 --> 00:14:29,050
representation because on the next

00:14:26,500 --> 00:14:31,089
request we throw the code away and need

00:14:29,050 --> 00:14:32,680
to generate it in you we need to scan

00:14:31,089 --> 00:14:34,930
again we need to parse again we need to

00:14:32,680 --> 00:14:40,240
emit bytecode again and then start

00:14:34,930 --> 00:14:42,190
executing the bytecode this changed a

00:14:40,240 --> 00:14:44,290
bit with the release of peach before

00:14:42,190 --> 00:14:48,070
which introduced optional bytecode

00:14:44,290 --> 00:14:50,079
caching it took a while until after PHP

00:14:48,070 --> 00:14:51,310
four came out until bytecode caches

00:14:50,079 --> 00:14:54,130
appeared the first one was the

00:14:51,310 --> 00:14:56,680
commercial offering buys end it took the

00:14:54,130 --> 00:14:59,079
community about one on one to one and a

00:14:56,680 --> 00:15:00,970
half years for the first open source

00:14:59,079 --> 00:15:04,000
might code cache is to come out like

00:15:00,970 --> 00:15:07,540
alternative PHP cache a PC which was the

00:15:04,000 --> 00:15:11,589
most commonly used one until last year

00:15:07,540 --> 00:15:14,380
probably so what happened last year was

00:15:11,589 --> 00:15:17,410
said starting with P 3 5 5 which was

00:15:14,380 --> 00:15:19,180
released in June we now ship by default

00:15:17,410 --> 00:15:22,180
and out-of-the-box bytecode cache which

00:15:19,180 --> 00:15:25,180
is up cache or now on named up cache

00:15:22,180 --> 00:15:27,610
which used to have 10 different names in

00:15:25,180 --> 00:15:28,630
the ten years that it existed what was

00:15:27,610 --> 00:15:31,000
the original

00:15:28,630 --> 00:15:36,010
a product from Zend so then open-source

00:15:31,000 --> 00:15:38,470
thereby code cache and it no ships p35

00:15:36,010 --> 00:15:41,830
it's really easy and if you're not using

00:15:38,470 --> 00:15:43,330
a byte code cache change that using a

00:15:41,830 --> 00:15:47,200
byte code cache can increase your

00:15:43,330 --> 00:15:50,280
performance by up to 70% and you don't

00:15:47,200 --> 00:15:56,830
have to change your code for that ok

00:15:50,280 --> 00:15:58,870
2008 what happened in 2008 well on the

00:15:56,830 --> 00:16:01,900
outside we don't really know what

00:15:58,870 --> 00:16:04,510
happened in 2008 at Facebook until a

00:16:01,900 --> 00:16:07,810
little bit later about one and a half

00:16:04,510 --> 00:16:11,860
years later but Facebook by that time

00:16:07,810 --> 00:16:14,650
had grown to a point where they started

00:16:11,860 --> 00:16:17,020
to see PHP becoming the bottleneck

00:16:14,650 --> 00:16:18,910
they had optimized the databases they

00:16:17,020 --> 00:16:21,580
had optimized the network traffic they

00:16:18,910 --> 00:16:24,280
had optimized the kernel of the

00:16:21,580 --> 00:16:26,040
operating system whatever and at some

00:16:24,280 --> 00:16:28,870
point

00:16:26,040 --> 00:16:32,830
PHP execution performance was their

00:16:28,870 --> 00:16:35,560
bottleneck for a while they remedied

00:16:32,830 --> 00:16:39,010
that by hiring PHP core developers

00:16:35,560 --> 00:16:42,670
working on optimizations for regular PHP

00:16:39,010 --> 00:16:46,180
lots of work on a PC on the alternative

00:16:42,670 --> 00:16:51,910
bytecode cache was done by Facebook

00:16:46,180 --> 00:16:53,590
engineers in 2006 2007 2008 brine Shire

00:16:51,910 --> 00:16:55,240
for instance Lucas Nealon for instance

00:16:53,590 --> 00:16:59,470
they did a lot of really good work on

00:16:55,240 --> 00:17:02,410
the Zend engine and on a PC but then

00:16:59,470 --> 00:17:05,310
that even that was not enough anymore so

00:17:02,410 --> 00:17:07,689
they were looking for alternatives they

00:17:05,310 --> 00:17:09,939
evaluated Quercus for instance which is

00:17:07,689 --> 00:17:14,050
a PHP runtime that sits on top of the

00:17:09,939 --> 00:17:15,939
JVM was actually slower for them than

00:17:14,050 --> 00:17:18,280
the regular PHP runtime so it was not an

00:17:15,939 --> 00:17:21,819
option look at various other things and

00:17:18,280 --> 00:17:25,150
eventually during a so-called hackathon

00:17:21,819 --> 00:17:27,790
which is a regular event at Facebook one

00:17:25,150 --> 00:17:32,560
of the engineers came up with the idea

00:17:27,790 --> 00:17:35,320
hey we also do a lot of C++ development

00:17:32,560 --> 00:17:39,070
at at Facebook for really low level

00:17:35,320 --> 00:17:41,410
stuff and C++ can be really optimized

00:17:39,070 --> 00:17:42,600
well using modern compilers into really

00:17:41,410 --> 00:17:46,090
good binaries

00:17:42,600 --> 00:17:48,970
so wouldn't it be nice if we had some

00:17:46,090 --> 00:17:51,940
sort of tool that would take our PHP

00:17:48,970 --> 00:17:54,910
source code and transform it into C++

00:17:51,940 --> 00:17:58,240
code that we can then compile down into

00:17:54,910 --> 00:18:00,210
native binary and within the 48 hours of

00:17:58,240 --> 00:18:04,030
a hackathon over a weekend

00:18:00,210 --> 00:18:06,550
he built a prototype that was able to

00:18:04,030 --> 00:18:09,030
run a really really simple PHP code PHP

00:18:06,550 --> 00:18:14,170
code without functions without objects

00:18:09,030 --> 00:18:16,900
but the basic stuff worked and then he

00:18:14,170 --> 00:18:18,490
presented the head it was success at the

00:18:16,900 --> 00:18:22,270
hackathon and he got a couple of months

00:18:18,490 --> 00:18:25,210
to work on making it work for real and

00:18:22,270 --> 00:18:28,210
by that by the end of that period it was

00:18:25,210 --> 00:18:31,180
able to run the Facebook codebase it was

00:18:28,210 --> 00:18:33,940
not really fast yet lots of optimization

00:18:31,180 --> 00:18:37,860
still needed to happen but it showed

00:18:33,940 --> 00:18:42,430
that it could eventually work around

00:18:37,860 --> 00:18:47,130
2009 in the PHP community we started to

00:18:42,430 --> 00:18:50,770
hear rumors Facebook had already hired

00:18:47,130 --> 00:18:52,450
some PHP code developers PHP core

00:18:50,770 --> 00:18:54,850
developers meet other PHP core

00:18:52,450 --> 00:18:57,640
developers at conferences or at the bar

00:18:54,850 --> 00:19:00,280
at a conference and they talked so we

00:18:57,640 --> 00:19:03,040
heard rumors that Facebook might be

00:19:00,280 --> 00:19:04,810
working on an alternative 50 runtime

00:19:03,040 --> 00:19:06,280
some people were really scared because

00:19:04,810 --> 00:19:09,040
it's something that happens behind

00:19:06,280 --> 00:19:12,270
closed doors they don't talk about it we

00:19:09,040 --> 00:19:15,070
don't know if what they are doing will

00:19:12,270 --> 00:19:16,990
be good for the PHP project or if it

00:19:15,070 --> 00:19:22,780
will kill the PHP project lots of

00:19:16,990 --> 00:19:24,820
confusion so in 2010 Facebook did a

00:19:22,780 --> 00:19:29,350
really smart thing and a really good

00:19:24,820 --> 00:19:31,360
thing they invited the PHP core

00:19:29,350 --> 00:19:34,780
developer community to the Facebook

00:19:31,360 --> 00:19:40,360
campus to explain them what they were

00:19:34,780 --> 00:19:43,630
working on there was well that was it at

00:19:40,360 --> 00:19:48,610
the end of 2009 and early in 2010 they

00:19:43,630 --> 00:19:52,210
open source HP HPC and HP HP I and this

00:19:48,610 --> 00:19:54,160
is very naming confusion begins so

00:19:52,210 --> 00:19:56,090
initially there was no name for this

00:19:54,160 --> 00:19:58,980
project

00:19:56,090 --> 00:20:01,980
then somebody came up with the name hip

00:19:58,980 --> 00:20:03,990
hop for PHP and I've talked to various

00:20:01,980 --> 00:20:05,820
people at Facebook and nobody could

00:20:03,990 --> 00:20:09,210
really explain to me where hip-hop comes

00:20:05,820 --> 00:20:10,140
from or ask to Facebook developers where

00:20:09,210 --> 00:20:15,360
it comes from when you get three

00:20:10,140 --> 00:20:20,580
different answers it just happened so in

00:20:15,360 --> 00:20:25,500
hindsight now they call their PHP code

00:20:20,580 --> 00:20:29,700
to C++ code transformer HP HPC like the

00:20:25,500 --> 00:20:36,120
first version of hip hop HP HP C for hip

00:20:29,700 --> 00:20:39,240
hop to see somehow whatever HP HP c so

00:20:36,120 --> 00:20:42,300
HP HP C was able to take PHP source

00:20:39,240 --> 00:20:43,890
codes transform that code into C++ and

00:20:42,300 --> 00:20:49,620
then you could use a regular C++

00:20:43,890 --> 00:20:53,010
compiler to get an age of binary just to

00:20:49,620 --> 00:20:57,060
give you an idea it's by that time in

00:20:53,010 --> 00:21:00,810
early 2010 it took less than one second

00:20:57,060 --> 00:21:07,040
to convert the eighty thousand lines of

00:21:00,810 --> 00:21:10,020
PHP unit to C++ code less than a second

00:21:07,040 --> 00:21:12,540
but then it took on my laptop that I had

00:21:10,020 --> 00:21:14,370
back then five hours to compile it from

00:21:12,540 --> 00:21:18,180
C++ to a binary that I could actually

00:21:14,370 --> 00:21:20,370
use and its really frustrating if at the

00:21:18,180 --> 00:21:22,590
very end you get a compile error because

00:21:20,370 --> 00:21:25,320
something is broken in HP HPC well not

00:21:22,590 --> 00:21:26,850
broken by the feature is missing that

00:21:25,320 --> 00:21:29,610
peach for you is required so you had to

00:21:26,850 --> 00:21:31,530
start all over again so I spent a week

00:21:29,610 --> 00:21:34,520
at Facebook around that time to help the

00:21:31,530 --> 00:21:36,720
team get PHP unit to run on hip hop

00:21:34,520 --> 00:21:38,610
because by that time already they had

00:21:36,720 --> 00:21:41,670
almost a hundred thousand unit tests

00:21:38,610 --> 00:21:44,100
with PHP unit and before they rolled out

00:21:41,670 --> 00:21:45,420
hip hop for real in production they

00:21:44,100 --> 00:21:48,990
wants to make sure that their tests

00:21:45,420 --> 00:21:51,900
actually worked on the new stack and for

00:21:48,990 --> 00:21:54,660
that to work the unit testing framework

00:21:51,900 --> 00:22:00,680
has to work on a new stack so that was a

00:21:54,660 --> 00:22:03,240
really interesting time in the everyday

00:22:00,680 --> 00:22:06,210
development work they quickly realized

00:22:03,240 --> 00:22:08,080
that just using HP HPC like you make a

00:22:06,210 --> 00:22:10,900
change for the code

00:22:08,080 --> 00:22:13,630
transformative C++ and compile it even

00:22:10,900 --> 00:22:16,300
if you use a thousand cores on a compile

00:22:13,630 --> 00:22:18,730
farm or even more to speed up the

00:22:16,300 --> 00:22:21,400
compilation process I mean that's the

00:22:18,730 --> 00:22:25,840
great thing about compiling C++ code

00:22:21,400 --> 00:22:27,820
there is a lot of tooling around for

00:22:25,840 --> 00:22:30,490
compiling C++ code in parallel and

00:22:27,820 --> 00:22:34,000
distributed among many cores and many

00:22:30,490 --> 00:22:36,460
machines even if you do that it takes

00:22:34,000 --> 00:22:41,320
longer than changing the code and

00:22:36,460 --> 00:22:44,650
hitting f5 in your browser so they came

00:22:41,320 --> 00:22:47,590
up with a new project in addition to 850

00:22:44,650 --> 00:22:54,130
PC which was HP HP I the hip hop

00:22:47,590 --> 00:23:00,340
interpreter this is HP HP I able to

00:22:54,130 --> 00:23:03,490
press f5 again well oh why couldn't they

00:23:00,340 --> 00:23:05,550
use PHP for that well HP PC only

00:23:03,490 --> 00:23:07,720
supported a subset of the PHP language

00:23:05,550 --> 00:23:09,910
there's a really rigorous coding

00:23:07,720 --> 00:23:11,890
standard of coding constructs in PHP

00:23:09,910 --> 00:23:13,690
that you were not allowed to use because

00:23:11,890 --> 00:23:16,780
they were either really hard to

00:23:13,690 --> 00:23:21,400
implement convert when converting PHP

00:23:16,780 --> 00:23:23,410
code to C++ code or so hard that it was

00:23:21,400 --> 00:23:27,150
not really feasible to implement them

00:23:23,410 --> 00:23:33,010
and one of them was the eval statement

00:23:27,150 --> 00:23:35,380
so they couldn't do or this using PHP

00:23:33,010 --> 00:23:39,070
regular PHP in development time and just

00:23:35,380 --> 00:23:41,050
use HP HPC for deployment why because a

00:23:39,070 --> 00:23:42,670
developer might use constructs in their

00:23:41,050 --> 00:23:44,260
code that are not allowed and then would

00:23:42,670 --> 00:23:47,530
break the compilation yes that would be

00:23:44,260 --> 00:23:50,320
found but not really not really helpful

00:23:47,530 --> 00:23:52,780
not really an efficient way of working

00:23:50,320 --> 00:23:56,200
so they built HP HP I that solve the

00:23:52,780 --> 00:23:58,450
problem but the problem or they got a

00:23:56,200 --> 00:24:01,420
new problem or two new problems problem

00:23:58,450 --> 00:24:04,510
one HP HP I was slower than regular PHP

00:24:01,420 --> 00:24:08,610
and they didn't want to invest the time

00:24:04,510 --> 00:24:10,510
and the effort of optimizing HP HP I

00:24:08,610 --> 00:24:14,410
because they only use it for development

00:24:10,510 --> 00:24:16,660
time problem number two and which is the

00:24:14,410 --> 00:24:20,050
more severe problem they had a really

00:24:16,660 --> 00:24:21,320
hard time keeping HP PC in HP HP I in

00:24:20,050 --> 00:24:23,520
sync

00:24:21,320 --> 00:24:25,560
different teams working on it new

00:24:23,520 --> 00:24:27,570
versions of PHP were coming out new

00:24:25,560 --> 00:24:31,020
features in PHP needed to implement be

00:24:27,570 --> 00:24:34,020
implemented in two places didn't really

00:24:31,020 --> 00:24:37,110
scale hugged up a lot of their

00:24:34,020 --> 00:24:42,060
development resources and they were not

00:24:37,110 --> 00:24:45,620
in a happy place just to give you an

00:24:42,060 --> 00:24:49,620
idea what what this code looked like

00:24:45,620 --> 00:24:53,700
every release of PHP for at least a

00:24:49,620 --> 00:24:58,410
decade ships with a benchtop PHP script

00:24:53,700 --> 00:25:01,200
that is used to benchmark the raw byte

00:24:58,410 --> 00:25:03,210
code execution performance of PHP and

00:25:01,200 --> 00:25:06,210
this is one of the tests that it is that

00:25:03,210 --> 00:25:08,820
is in there which looks really really

00:25:06,210 --> 00:25:14,190
stupid and I hope none of you has code

00:25:08,820 --> 00:25:16,710
that looks like that but this tests for

00:25:14,190 --> 00:25:20,250
instance how fast loops can be executed

00:25:16,710 --> 00:25:22,530
and how fast variables can be looked up

00:25:20,250 --> 00:25:25,440
in Z valves and so on really really

00:25:22,530 --> 00:25:28,830
really low-level stuff convert that to

00:25:25,440 --> 00:25:31,080
C++ and it looks like this and then we

00:25:28,830 --> 00:25:33,600
can compile it to a binary and that's

00:25:31,080 --> 00:25:36,330
also the binary is was also one of the

00:25:33,600 --> 00:25:40,610
problems that prompted a Facebook to do

00:25:36,330 --> 00:25:40,610
something more than just work on HP HPC

00:25:40,760 --> 00:25:46,740
once to all these many cores were done

00:25:43,950 --> 00:25:51,860
compiling Facebook was stuck with a

00:25:46,740 --> 00:25:55,290
binary of several gigabytes in size and

00:25:51,860 --> 00:25:57,300
they had a problem distributing that

00:25:55,290 --> 00:25:59,040
across there are tens of thousands of

00:25:57,300 --> 00:26:02,730
servers they actually use BitTorrent for

00:25:59,040 --> 00:26:05,280
that but it took a while it took a long

00:26:02,730 --> 00:26:07,920
time to build the binary and then it

00:26:05,280 --> 00:26:11,880
took a while to distribute it they

00:26:07,920 --> 00:26:14,250
wanted to do it quicker but to recap

00:26:11,880 --> 00:26:17,610
what happened until this point Facebook

00:26:14,250 --> 00:26:19,830
had a problem we'll see about what that

00:26:17,610 --> 00:26:23,940
problem was in a bit but they wanted a

00:26:19,830 --> 00:26:24,810
faster better runtime for PHP they found

00:26:23,940 --> 00:26:26,730
the solution

00:26:24,810 --> 00:26:30,390
they found the solution of transforming

00:26:26,730 --> 00:26:32,070
PHP code to C++ code and it worked it

00:26:30,390 --> 00:26:34,110
works for them they could have stopped

00:26:32,070 --> 00:26:36,780
at that point they didn't

00:26:34,110 --> 00:26:40,920
which is really great because they open

00:26:36,780 --> 00:26:43,170
sourced their solution now whether or

00:26:40,920 --> 00:26:46,559
not that solution fits a problem that

00:26:43,170 --> 00:26:48,809
somebody else then Facebook has is up

00:26:46,559 --> 00:26:52,110
for everyone that does that development

00:26:48,809 --> 00:26:54,299
or hosting to the site I don't think

00:26:52,110 --> 00:26:57,000
that many people have the problem that

00:26:54,299 --> 00:27:00,179
Facebook ad usually you have to wait for

00:26:57,000 --> 00:27:03,809
external systems like a database and it

00:27:00,179 --> 00:27:07,650
doesn't matter if you wait in PHP or in

00:27:03,809 --> 00:27:10,230
HTM for the database waiting for the

00:27:07,650 --> 00:27:12,660
database is slow in any language or in

00:27:10,230 --> 00:27:15,840
any architecture so that doesn't really

00:27:12,660 --> 00:27:19,890
matter but Facebook's actual problem was

00:27:15,840 --> 00:27:24,929
data center cost and you could really

00:27:19,890 --> 00:27:28,080
see well they are not talking in actual

00:27:24,929 --> 00:27:30,360
numbers in what data center cost and

00:27:28,080 --> 00:27:34,830
energy costs the dealing was in dollar

00:27:30,360 --> 00:27:38,429
values but in their present in the press

00:27:34,830 --> 00:27:42,360
release or in the press presentation in

00:27:38,429 --> 00:27:46,080
February of 2010 they said well we see a

00:27:42,360 --> 00:27:48,510
reduction of 50% in CPUs in CPU usage

00:27:46,080 --> 00:27:51,980
when serving equal amounts of web

00:27:48,510 --> 00:27:55,290
traffic when compared to Apache and PHP

00:27:51,980 --> 00:27:57,510
or ape as they were calling it

00:27:55,290 --> 00:27:59,510
internally their old stack they were not

00:27:57,510 --> 00:28:06,000
running on lamp they were running on ape

00:27:59,510 --> 00:28:09,000
Apache PHP plus extensions or if you ask

00:28:06,000 --> 00:28:12,480
other developers it was a PC plus pH P

00:28:09,000 --> 00:28:15,059
Plus extensions doesn't really matter

00:28:12,480 --> 00:28:17,250
they were using PHP 5-2 and ABC at a

00:28:15,059 --> 00:28:20,669
time and they replace the PHP runtime

00:28:17,250 --> 00:28:24,299
with their own and Facebook's API tier

00:28:20,669 --> 00:28:27,750
was able to serve double the traffic

00:28:24,299 --> 00:28:30,960
with 30% less CPU and that meant that

00:28:27,750 --> 00:28:33,710
they could turn off a lot of servers

00:28:30,960 --> 00:28:38,640
which means a lot of less energy and

00:28:33,710 --> 00:28:41,040
lots of less cooling and that was a

00:28:38,640 --> 00:28:44,450
problem they found a solution they open

00:28:41,040 --> 00:28:47,990
source a solution kudos for that

00:28:44,450 --> 00:28:51,590
and around the same time that they

00:28:47,990 --> 00:28:54,650
rolled actually out HP PC into

00:28:51,590 --> 00:28:56,990
production that it is gradually over a

00:28:54,650 --> 00:29:00,500
longer period of time started with one

00:28:56,990 --> 00:29:03,080
percent of the service running on HP HPC

00:29:00,500 --> 00:29:05,180
and the rest on HP v 2 plus a PC and

00:29:03,080 --> 00:29:10,460
increased the amount of servers that

00:29:05,180 --> 00:29:11,960
were running on HP PC over time but

00:29:10,460 --> 00:29:14,870
around the same time they also ready

00:29:11,960 --> 00:29:19,160
realized that HP HP C will only be a

00:29:14,870 --> 00:29:21,650
short term fix it slowed down the

00:29:19,160 --> 00:29:23,540
development process and they saw that

00:29:21,650 --> 00:29:27,050
there was potential for even more

00:29:23,540 --> 00:29:28,820
resource consumption reduction and for

00:29:27,050 --> 00:29:32,180
even more performance improvements and

00:29:28,820 --> 00:29:34,220
that's why they started already in 2010

00:29:32,180 --> 00:29:41,150
to work on hvm or a hip-hop virtual

00:29:34,220 --> 00:29:44,960
machine from 2010 to 2013 Facebook used

00:29:41,150 --> 00:29:48,080
HP PC in production without any major

00:29:44,960 --> 00:29:50,870
problems that I'm aware of or dead came

00:29:48,080 --> 00:29:53,270
out into the public they were very they

00:29:50,870 --> 00:29:55,640
were happy with the in production but

00:29:53,270 --> 00:29:58,280
once again only after the binary I was

00:29:55,640 --> 00:30:01,430
area was built and put into the

00:29:58,280 --> 00:30:05,020
production they they were happy getting

00:30:01,430 --> 00:30:09,710
their really slow development process

00:30:05,020 --> 00:30:11,660
not happy since 2013

00:30:09,710 --> 00:30:13,910
they are actually using a JVM in

00:30:11,660 --> 00:30:16,220
production they are very happy with that

00:30:13,910 --> 00:30:18,100
and they're continuously improving the

00:30:16,220 --> 00:30:22,030
performance and the resource consumption

00:30:18,100 --> 00:30:26,480
have big plans at the moment to support

00:30:22,030 --> 00:30:32,000
arm 64-bit CPUs which use less power

00:30:26,480 --> 00:30:35,170
than amd64 compatible CPUs that's so

00:30:32,000 --> 00:30:40,310
that's going to be really interesting

00:30:35,170 --> 00:30:44,270
so what's HP m 8r h vm is an open-source

00:30:40,310 --> 00:30:47,810
virtual machine designed for executing

00:30:44,270 --> 00:30:49,310
programs written in hack and PHP open

00:30:47,810 --> 00:30:52,550
source I don't need to explain

00:30:49,310 --> 00:30:54,470
hopefully virtual machine I may need to

00:30:52,550 --> 00:30:57,610
explain virtual machine is a piece of

00:30:54,470 --> 00:31:01,390
software that is able to run a

00:30:57,610 --> 00:31:03,840
of software interpreted in some way the

00:31:01,390 --> 00:31:08,950
PHP interpreter and the lights went out

00:31:03,840 --> 00:31:13,270
set a problem good just don't fall

00:31:08,950 --> 00:31:14,530
asleep the PHP interpreter is a virtual

00:31:13,270 --> 00:31:17,320
machine it's a piece of code that

00:31:14,530 --> 00:31:19,780
executes PHP code and it's a black box

00:31:17,320 --> 00:31:21,760
you don't really care about unless you

00:31:19,780 --> 00:31:24,580
are someone like me who gets excited

00:31:21,760 --> 00:31:27,700
about compiler design language design

00:31:24,580 --> 00:31:30,610
compiler implementation and so on it's a

00:31:27,700 --> 00:31:33,270
black box that executes your code lots

00:31:30,610 --> 00:31:37,420
of interesting technology in there but

00:31:33,270 --> 00:31:39,490
it just works the Java Virtual Machine

00:31:37,420 --> 00:31:43,690
is a virtual machine it execute Java

00:31:39,490 --> 00:31:45,910
code and so on executing programs last

00:31:43,690 --> 00:31:48,550
bits are really interesting with the

00:31:45,910 --> 00:31:53,260
order in which Facebook puts it's

00:31:48,550 --> 00:31:56,530
written in hack and PHP hack we'll get

00:31:53,260 --> 00:32:03,130
to in a bit PHP we all know hopefully so

00:31:56,530 --> 00:32:07,060
how does a JVM work works to some extent

00:32:03,130 --> 00:32:07,990
very similar to what PHP does it starts

00:32:07,060 --> 00:32:09,700
with tokenizing

00:32:07,990 --> 00:32:13,300
because that's what we have to do

00:32:09,700 --> 00:32:15,280
there's no way around that then it

00:32:13,300 --> 00:32:17,140
doesn't build a parse tree like the one

00:32:15,280 --> 00:32:22,090
that PHP use it but it builds a real

00:32:17,140 --> 00:32:23,710
abstract syntax tree and there are

00:32:22,090 --> 00:32:25,450
already on the abstract syntax where you

00:32:23,710 --> 00:32:27,820
can do a lot of static analysis and

00:32:25,450 --> 00:32:29,770
optimization and talking about static

00:32:27,820 --> 00:32:31,480
analysis that is something that I was

00:32:29,770 --> 00:32:34,990
really excited about when I visited

00:32:31,480 --> 00:32:40,540
Facebook last year in fall and saw what

00:32:34,990 --> 00:32:42,670
they were working on back then come to

00:32:40,540 --> 00:32:47,260
that in a bit after the abstract syntax

00:32:42,670 --> 00:32:50,730
tree the source code is transformed into

00:32:47,260 --> 00:32:51,970
and warning this is now really

00:32:50,730 --> 00:32:55,960
technobabble

00:32:51,970 --> 00:32:57,760
buzzword bingo typed static

00:32:55,960 --> 00:33:02,250
single assignment intermediate

00:32:57,760 --> 00:33:05,050
representation so what does it mean an

00:33:02,250 --> 00:33:08,890
SSA or a static single assignment form

00:33:05,050 --> 00:33:11,830
is a highly specialized representation

00:33:08,890 --> 00:33:16,809
for code

00:33:11,830 --> 00:33:18,850
while you are compiling code has some

00:33:16,809 --> 00:33:21,490
really interesting characteristics in

00:33:18,850 --> 00:33:24,909
that every variable that's used when

00:33:21,490 --> 00:33:27,820
it's once it's in this form has to be

00:33:24,909 --> 00:33:31,570
declared and can be defined only once it

00:33:27,820 --> 00:33:34,330
doesn't change it static sounds weird

00:33:31,570 --> 00:33:36,850
but actually makes sense don't want to

00:33:34,330 --> 00:33:39,640
bore you with the details it allows some

00:33:36,850 --> 00:33:44,080
really really nifty optimizations and

00:33:39,640 --> 00:33:46,090
analysis methods it's typed for every

00:33:44,080 --> 00:33:50,529
variable that's in this representation

00:33:46,090 --> 00:33:53,529
we know it's type which again really

00:33:50,529 --> 00:33:57,460
really helpful if we know that the

00:33:53,529 --> 00:33:59,409
variable is always an integer we can in

00:33:57,460 --> 00:34:03,190
our underlying data structures actually

00:33:59,409 --> 00:34:04,659
use a native platform integer much more

00:34:03,190 --> 00:34:06,190
efficient than for instance what we're

00:34:04,659 --> 00:34:09,490
doing in PHP in the PHP interpreter

00:34:06,190 --> 00:34:11,530
using a set well which can be anything

00:34:09,490 --> 00:34:13,980
it can be a string it can be an object

00:34:11,530 --> 00:34:16,359
it can be an array it can be an integer

00:34:13,980 --> 00:34:18,159
really really flexible which is what you

00:34:16,359 --> 00:34:20,139
need in a dynamic language because from

00:34:18,159 --> 00:34:23,830
line to line you can change the type of

00:34:20,139 --> 00:34:26,849
your variable but not really helpful

00:34:23,830 --> 00:34:32,080
when you try to optimize code execution

00:34:26,849 --> 00:34:36,970
and this couldn't really work without

00:34:32,080 --> 00:34:39,609
this type inference using the code

00:34:36,970 --> 00:34:41,649
analysis a th VM can figure out like by

00:34:39,609 --> 00:34:43,869
compiling the code yes this variable

00:34:41,649 --> 00:34:45,970
actually or wherever it's used it's an

00:34:43,869 --> 00:34:49,270
integer so it can use that it didn't

00:34:45,970 --> 00:34:54,089
fears the type in first type really

00:34:49,270 --> 00:34:57,280
useful talking about setting analysis

00:34:54,089 --> 00:35:01,750
violate each VM is compiling the source

00:34:57,280 --> 00:35:03,730
code it generates a JSON file in the

00:35:01,750 --> 00:35:05,800
temp directory that is not really

00:35:03,730 --> 00:35:07,930
documented I hope that this

00:35:05,800 --> 00:35:11,140
functionality is not going away at some

00:35:07,930 --> 00:35:13,589
point because there's so much useful

00:35:11,140 --> 00:35:16,630
information in a JSON file about

00:35:13,589 --> 00:35:18,520
warnings and errors and biggest stuff

00:35:16,630 --> 00:35:21,700
that it finds in your PHP code while

00:35:18,520 --> 00:35:24,470
it's transforming a PHP code and I wrote

00:35:21,700 --> 00:35:26,560
a tool called HTM wrapper that

00:35:24,470 --> 00:35:27,800
wraps around the atrium command line

00:35:26,560 --> 00:35:31,400
thing

00:35:27,800 --> 00:35:35,060
come on an interpreter that generates

00:35:31,400 --> 00:35:37,700
behind the scenes compiler this JSON

00:35:35,060 --> 00:35:40,820
format and gives you access to the

00:35:37,700 --> 00:35:42,260
information in there and I actually have

00:35:40,820 --> 00:35:44,060
some homework to do because this is

00:35:42,260 --> 00:35:45,460
output from roaming running HTTP and

00:35:44,060 --> 00:35:50,630
wrapper on PHP unit there are at least

00:35:45,460 --> 00:35:54,859
three valid potential books that I've

00:35:50,630 --> 00:35:59,240
found so that is it that's a really nice

00:35:54,859 --> 00:36:00,800
side effect of the type as a IR and the

00:35:59,240 --> 00:36:06,800
type inference and the static analysis

00:36:00,800 --> 00:36:08,570
built into the compiler next step after

00:36:06,800 --> 00:36:10,760
the intermediate representation because

00:36:08,570 --> 00:36:12,980
we don't just stop there is we generate

00:36:10,760 --> 00:36:17,470
bytecode and we don't generate PHP

00:36:12,980 --> 00:36:20,030
bytecode pod hiphop bytecode which

00:36:17,470 --> 00:36:22,099
actually has a specification which the

00:36:20,030 --> 00:36:24,380
PHP bytecode does not have which is good

00:36:22,099 --> 00:36:27,500
because you can read it you can write

00:36:24,380 --> 00:36:32,839
your own interpreter for a tip-up

00:36:27,500 --> 00:36:34,880
bytecode for instance if you want also

00:36:32,839 --> 00:36:37,190
have helps with hacking on it because

00:36:34,880 --> 00:36:40,599
you can actually read what's going on

00:36:37,190 --> 00:36:43,070
there's some really interesting

00:36:40,599 --> 00:36:46,250
implementation detail in that that the

00:36:43,070 --> 00:36:48,260
hip-hop bytecode is written to disk if

00:36:46,250 --> 00:36:55,310
you're working in repository mode as a

00:36:48,260 --> 00:36:56,990
SQLite 3 database so you can compile

00:36:55,310 --> 00:36:59,180
your whole application into a single

00:36:56,990 --> 00:37:02,810
file that only contains the bytecode and

00:36:59,180 --> 00:37:07,570
this file is an SQLite 3 database that

00:37:02,810 --> 00:37:10,280
can you can that can even store versions

00:37:07,570 --> 00:37:12,560
snapshots of your application so you

00:37:10,280 --> 00:37:14,330
just have one file but multiple versions

00:37:12,560 --> 00:37:18,920
of the application in it and you can say

00:37:14,330 --> 00:37:21,140
I want to run version X and new requests

00:37:18,920 --> 00:37:23,270
get version Y for instance make some

00:37:21,140 --> 00:37:26,810
really interesting deployment concepts

00:37:23,270 --> 00:37:28,490
possible but it's also really

00:37:26,810 --> 00:37:31,640
interesting because we have a really

00:37:28,490 --> 00:37:33,859
structured format for the binary

00:37:31,640 --> 00:37:37,999
representation of your application

00:37:33,859 --> 00:37:39,949
inside the relational database using SQL

00:37:37,999 --> 00:37:45,279
you can ask questions about your code

00:37:39,949 --> 00:37:52,279
what classes do I have who calls whom

00:37:45,279 --> 00:37:54,189
crazy stuff it's it's a fairyland for

00:37:52,279 --> 00:37:57,759
people that like to do static analysis

00:37:54,189 --> 00:38:00,069
makes it really easy but not easy but

00:37:57,759 --> 00:38:02,779
possible in a different way in new way

00:38:00,069 --> 00:38:05,029
if you get excited about you things that

00:38:02,779 --> 00:38:06,409
then you understand and then what

00:38:05,029 --> 00:38:08,359
happens after that is just in time

00:38:06,409 --> 00:38:14,209
compilation which is why it's getting

00:38:08,359 --> 00:38:18,259
really really fast so while the code is

00:38:14,209 --> 00:38:20,449
being executed it gets translated into

00:38:18,259 --> 00:38:22,629
machine code not everything is con

00:38:20,449 --> 00:38:24,859
translated to machine code at first only

00:38:22,629 --> 00:38:28,219
the sections of the Caleta actually

00:38:24,859 --> 00:38:29,749
executed so you might you start

00:38:28,219 --> 00:38:31,819
obviously with zero percent being

00:38:29,749 --> 00:38:34,969
executed and then you have a request the

00:38:31,819 --> 00:38:37,699
request uses about 10% of your code base

00:38:34,969 --> 00:38:40,869
and those ten percent are on the fly

00:38:37,699 --> 00:38:43,609
transformed into machine code and

00:38:40,869 --> 00:38:46,669
machine code can be executed executed

00:38:43,609 --> 00:38:50,289
really quick and then it's cached you

00:38:46,669 --> 00:38:52,819
don't need to care about that just works

00:38:50,289 --> 00:38:55,639
well you get native machine code in the

00:38:52,819 --> 00:39:00,039
end and that scan is really fast to

00:38:55,639 --> 00:39:00,039
execute and really efficient to execute

00:39:01,299 --> 00:39:10,759
performance it's really hard to talk

00:39:08,029 --> 00:39:15,679
about performance in an objective way

00:39:10,759 --> 00:39:18,979
it's very subjective Google for hh3m and

00:39:15,679 --> 00:39:21,649
benchmark and you find many different

00:39:18,979 --> 00:39:24,709
things some people will say PHP is

00:39:21,649 --> 00:39:26,779
faster from my application in the HTM so

00:39:24,709 --> 00:39:32,479
most people will say ATM is faster than

00:39:26,779 --> 00:39:34,909
PHP this is well the official benchmark

00:39:32,479 --> 00:39:36,889
from Facebook measuring the facebook

00:39:34,909 --> 00:39:39,469
code base and for them

00:39:36,889 --> 00:39:44,989
a judge VM is first and foremost twice

00:39:39,469 --> 00:39:46,909
as fast as HP HPC was and this was with

00:39:44,989 --> 00:39:48,319
the first release and since then they

00:39:46,909 --> 00:39:49,820
have optimized from release to release

00:39:48,319 --> 00:39:52,820
so they're getting better

00:39:49,820 --> 00:39:57,080
it's nine times faster than ape loss for

00:39:52,820 --> 00:40:01,010
them PHP 5 2 plus 8 PC uses up to 80%

00:39:57,080 --> 00:40:04,880
memory less than 55 to and a be seated

00:40:01,010 --> 00:40:07,880
so they are getting what they want out

00:40:04,880 --> 00:40:12,620
of it less resource consumption and

00:40:07,880 --> 00:40:22,360
higher execution speed or CPU F is

00:40:12,620 --> 00:40:22,360
efficiency if you want so in case well I

00:40:23,560 --> 00:40:29,210
have to have a little bit of PHP unit in

00:40:26,660 --> 00:40:36,470
the presentation even if it's just on

00:40:29,210 --> 00:40:39,830
HTM so and since I already got the

00:40:36,470 --> 00:40:43,850
question yesterday in another talk yes

00:40:39,830 --> 00:40:50,840
PHP unit runs on a judge VM so for

00:40:43,850 --> 00:40:53,630
instance this is regular PHP 5 6 running

00:40:50,840 --> 00:40:58,580
a test suite and it looks very similar

00:40:53,630 --> 00:41:02,330
around the test fit this 83m and do you

00:40:58,580 --> 00:41:06,860
spot something if there's something

00:41:02,330 --> 00:41:10,910
curious what's what's curious it's

00:41:06,860 --> 00:41:16,490
slower yes that's because this is not

00:41:10,910 --> 00:41:18,080
fair do it again that would be correct

00:41:16,490 --> 00:41:22,360
if you were actually running in the web

00:41:18,080 --> 00:41:26,870
server this is a command-line tool and

00:41:22,360 --> 00:41:30,230
at the end of the request the memory of

00:41:26,870 --> 00:41:34,700
ATM is gone so we cannot cash the bite

00:41:30,230 --> 00:41:37,880
the native machine code you can get it

00:41:34,700 --> 00:41:40,640
faster by turning off the JIT because

00:41:37,880 --> 00:41:42,950
then you don't get the overhead the ATM

00:41:40,640 --> 00:41:46,160
does not do all the optimizations that

00:41:42,950 --> 00:41:50,210
it can do and then it's faster than

00:41:46,160 --> 00:41:52,430
native PHP which sounds weird because

00:41:50,210 --> 00:41:54,680
when you're not optimizing then it's

00:41:52,430 --> 00:41:55,970
faster but it's not weird at all if

00:41:54,680 --> 00:41:59,390
you're not optimizing you're not wasting

00:41:55,970 --> 00:42:01,700
time and in this case PHP is faster

00:41:59,390 --> 00:42:03,420
because it doesn't optimize it just goes

00:42:01,700 --> 00:42:06,500
straight to executing

00:42:03,420 --> 00:42:07,710
well scanning parsing bytecode emission

00:42:06,500 --> 00:42:10,619
execution

00:42:07,710 --> 00:42:12,809
whereas a th vm has two or three phases

00:42:10,619 --> 00:42:14,760
of optimization in between that we don't

00:42:12,809 --> 00:42:23,460
need and don't get the benefit of on the

00:42:14,760 --> 00:42:26,279
command line okay framework parity is a

00:42:23,460 --> 00:42:27,779
really big topic for Facebook or they

00:42:26,279 --> 00:42:31,349
like to talk about it a lot

00:42:27,779 --> 00:42:34,140
what it means is that they want to be as

00:42:31,349 --> 00:42:36,000
compatible with PHP as possible as much

00:42:34,140 --> 00:42:38,309
as possible at this point in time at

00:42:36,000 --> 00:42:41,960
least and the way that they ensure that

00:42:38,309 --> 00:42:45,720
is that they look at the top 30

00:42:41,960 --> 00:42:49,079
something PHP based applications and

00:42:45,720 --> 00:42:53,250
frameworks on github and for every push

00:42:49,079 --> 00:42:54,660
that they make to HTM they have a Travis

00:42:53,250 --> 00:42:56,730
job somewhere or in continuous

00:42:54,660 --> 00:43:00,000
integration job somewhere that builds

00:42:56,730 --> 00:43:02,819
hh3m and then uses PHP unit to run the

00:43:00,000 --> 00:43:04,559
test suite of this top 30 whatever a

00:43:02,819 --> 00:43:09,500
list of frameworks like symphony tools

00:43:04,559 --> 00:43:13,319
and framework doctrine PHP unit whatever

00:43:09,500 --> 00:43:17,400
run them and make sure that those pieces

00:43:13,319 --> 00:43:22,819
of PHP code work on a VM that's frame of

00:43:17,400 --> 00:43:26,579
parity 2014 Facebook open source is hack

00:43:22,819 --> 00:43:29,369
and hack is a programming language for

00:43:26,579 --> 00:43:32,369
hh3m that interoperates into operate

00:43:29,369 --> 00:43:34,440
seamlessly with PHP it reconciles the

00:43:32,369 --> 00:43:36,390
fast development cycle of PHP was a

00:43:34,440 --> 00:43:38,730
discipline provided by static typing

00:43:36,390 --> 00:43:40,079
while adding many features commonly

00:43:38,730 --> 00:43:43,859
found in other modern programming

00:43:40,079 --> 00:43:48,000
languages so suddenly Facebook had a new

00:43:43,859 --> 00:43:50,009
problem they wanted to have the fast

00:43:48,000 --> 00:43:53,400
development cycle the rapid development

00:43:50,009 --> 00:43:56,519
cycle of a dynamic language PHP without

00:43:53,400 --> 00:44:00,150
the risks attached to a programming

00:43:56,519 --> 00:44:02,009
language that is as dynamic as PHP so

00:44:00,150 --> 00:44:04,650
they introduced things like static

00:44:02,009 --> 00:44:07,859
typing or a concept of called gradual

00:44:04,650 --> 00:44:11,579
typing and for instance you can with

00:44:07,859 --> 00:44:13,200
hack define a return type end and say

00:44:11,579 --> 00:44:15,000
this functional method it returns a

00:44:13,200 --> 00:44:16,770
boolean I get an error message when it's

00:44:15,000 --> 00:44:18,330
return something else

00:44:16,770 --> 00:44:21,210
and the really interesting thing is that

00:44:18,330 --> 00:44:23,310
they have tooling around it that while

00:44:21,210 --> 00:44:25,860
you develop code while you're working on

00:44:23,310 --> 00:44:26,940
the code it can report errors that

00:44:25,860 --> 00:44:29,400
you're making in your code that you're

00:44:26,940 --> 00:44:33,150
violating some of your constraints that

00:44:29,400 --> 00:44:35,280
you have put in place makes developers

00:44:33,150 --> 00:44:39,210
much more productive because they spend

00:44:35,280 --> 00:44:40,980
less time debugging and you don't run

00:44:39,210 --> 00:44:43,290
the risk of getting errors in production

00:44:40,980 --> 00:44:45,780
that you can only get at run time and

00:44:43,290 --> 00:44:50,370
are likely to miss using conventional

00:44:45,780 --> 00:44:55,440
testing techniques collaboration with

00:44:50,370 --> 00:44:57,240
the PHP project in PHP 55

00:44:55,440 --> 00:44:59,910
we got generators generators were

00:44:57,240 --> 00:45:04,650
implemented first in hack before we even

00:44:59,910 --> 00:45:05,790
knew that hack existed was just a syntax

00:45:04,650 --> 00:45:09,810
addition at that point that was

00:45:05,790 --> 00:45:12,420
available for PHP in hh3m and at the

00:45:09,810 --> 00:45:14,400
time when PHP developers started to

00:45:12,420 --> 00:45:15,510
discuss generators Facebook engineers

00:45:14,400 --> 00:45:19,590
came around and said hey we have

00:45:15,510 --> 00:45:21,780
implemented that this is our syntax if

00:45:19,590 --> 00:45:24,660
you want to adopt it that's great if you

00:45:21,780 --> 00:45:26,460
opt for a different syntax that's also

00:45:24,660 --> 00:45:29,100
great then we adopt ours and text to

00:45:26,460 --> 00:45:32,070
yours because we have the tools in place

00:45:29,100 --> 00:45:34,350
to do an automatic refactoring of our

00:45:32,070 --> 00:45:38,370
code base to change the syntax of that

00:45:34,350 --> 00:45:40,860
feature and that works so we they are

00:45:38,370 --> 00:45:43,140
cooperating lots of PHP core developers

00:45:40,860 --> 00:45:46,860
of now work for Facebook they still care

00:45:43,140 --> 00:45:51,270
about the PHP project they communicate

00:45:46,860 --> 00:45:56,280
and that's nice however not everything

00:45:51,270 --> 00:45:58,590
is nice and my presenter thing is

00:45:56,280 --> 00:46:00,510
telling me by vibrating really wild

00:45:58,590 --> 00:46:02,190
things that I'm out of time but please

00:46:00,510 --> 00:46:04,880
allow me one additional minute for a

00:46:02,190 --> 00:46:07,740
little bit of a ranting I managed

00:46:04,880 --> 00:46:11,550
mentioned earlier but I'm really split

00:46:07,740 --> 00:46:16,920
I'm very enthusiastic as programming

00:46:11,550 --> 00:46:18,450
language compiler runtime whatever geek

00:46:16,920 --> 00:46:20,700
if you want to call it but I'm also

00:46:18,450 --> 00:46:26,460
frustrated about a couple of things so

00:46:20,700 --> 00:46:30,000
what am i frustrated about I when when I

00:46:26,460 --> 00:46:30,360
first worked with HTM I was really

00:46:30,000 --> 00:46:32,340
really

00:46:30,360 --> 00:46:35,910
excited that I was able to do something

00:46:32,340 --> 00:46:38,340
like this and last October this actually

00:46:35,910 --> 00:46:42,320
worked what does it do

00:46:38,340 --> 00:46:47,240
it gives me user land access in PHP code

00:46:42,320 --> 00:46:50,340
to abstract syntax trees of PHP programs

00:46:47,240 --> 00:46:53,490
yes I have something similar available

00:46:50,340 --> 00:46:57,120
written in PHP for PHP by with by Nikita

00:46:53,490 --> 00:46:59,700
Popov but the problem with that is that

00:46:57,120 --> 00:47:02,010
it's not automatically in sync with the

00:46:59,700 --> 00:47:05,550
syntax of the language if a new feature

00:47:02,010 --> 00:47:08,130
is added to PHP Nikita has to work on

00:47:05,550 --> 00:47:11,520
PHP parser to extend it to teach it into

00:47:08,130 --> 00:47:13,830
the new syntax and here it's built into

00:47:11,520 --> 00:47:15,860
the runtime when I add a new feature to

00:47:13,830 --> 00:47:19,050
the runtime like a new syntax feature

00:47:15,860 --> 00:47:21,810
it's automatically exposed and

00:47:19,050 --> 00:47:26,280
accessible through what they call the

00:47:21,810 --> 00:47:29,490
code model API so that made me really

00:47:26,280 --> 00:47:31,610
excited and I started to build on work

00:47:29,490 --> 00:47:34,140
on new tools that use that information

00:47:31,610 --> 00:47:36,270
for static code analysis software

00:47:34,140 --> 00:47:38,400
metrics finally automatically finding

00:47:36,270 --> 00:47:40,140
bugs in code and so on automatic

00:47:38,400 --> 00:47:41,790
refactoring tools really really

00:47:40,140 --> 00:47:45,270
interesting stuff that I have wanted to

00:47:41,790 --> 00:47:47,160
work on for a really long time and by

00:47:45,270 --> 00:47:49,320
the way this what it would be like the

00:47:47,160 --> 00:47:51,020
first 20 lines of output for that you

00:47:49,320 --> 00:47:53,430
get an object graph where each object

00:47:51,020 --> 00:47:55,200
represents one node in the Indus in the

00:47:53,430 --> 00:47:57,000
graph you can rearrange it and then

00:47:55,200 --> 00:48:01,430
serialize it back to PHP code if you

00:47:57,000 --> 00:48:11,100
want really cool stuff and then in March

00:48:01,430 --> 00:48:14,090
it was removed and I was really

00:48:11,100 --> 00:48:16,760
surprised by that there was no warning

00:48:14,090 --> 00:48:21,330
from one commit to the next it was gone

00:48:16,760 --> 00:48:24,660
and the explanation was the author of

00:48:21,330 --> 00:48:27,300
code model left the team and nobody else

00:48:24,660 --> 00:48:29,370
understands the code the code led to

00:48:27,300 --> 00:48:32,150
problems we don't need the code we

00:48:29,370 --> 00:48:32,150
deleted the code

00:48:34,020 --> 00:48:39,590
and that really makes me angry you want

00:48:37,680 --> 00:48:43,260
the first problem that you run in to

00:48:39,590 --> 00:48:45,150
give up you don't even ask if somebody

00:48:43,260 --> 00:48:46,740
could help us that they remove yes of

00:48:45,150 --> 00:48:49,800
course it's in the version control

00:48:46,740 --> 00:48:52,290
somebody else can pick it up go back to

00:48:49,800 --> 00:48:54,420
that free version try to fix the bug but

00:48:52,290 --> 00:48:57,450
if it's deleted and nobody talks about

00:48:54,420 --> 00:49:01,550
it nobody will know that this existed at

00:48:57,450 --> 00:49:04,890
some point that's scary

00:49:01,550 --> 00:49:09,060
also at some point code coverage

00:49:04,890 --> 00:49:12,270
functionality was added to to hvm and of

00:49:09,060 --> 00:49:14,550
course I wanted that I asked them to

00:49:12,270 --> 00:49:17,400
implement it and they implemented it and

00:49:14,550 --> 00:49:19,980
I started using it in PHP unit and PHP

00:49:17,400 --> 00:49:21,570
unit if you run it on HTM can give you

00:49:19,980 --> 00:49:26,190
code coverage report for your code that

00:49:21,570 --> 00:49:28,350
you run on 83m but I found bugs which is

00:49:26,190 --> 00:49:32,640
not surprising in a new feature

00:49:28,350 --> 00:49:34,770
I opened the bug response for thanks for

00:49:32,640 --> 00:49:38,430
reporting this nobody has looked at the

00:49:34,770 --> 00:49:40,650
code coverage code in a long time it

00:49:38,430 --> 00:49:46,680
looks like the last non cleanup commit

00:49:40,650 --> 00:49:52,080
in the code was about 22 months ago and

00:49:46,680 --> 00:49:53,700
that really scares me I don't know how

00:49:52,080 --> 00:49:56,000
they get code coverage for their own

00:49:53,700 --> 00:49:56,000
code

00:49:58,660 --> 00:50:03,729
and I can under some degree I can

00:50:01,660 --> 00:50:05,859
understand not that I find it good their

00:50:03,729 --> 00:50:08,200
reasoning that they remove features that

00:50:05,859 --> 00:50:12,239
they don't need I can understand that I

00:50:08,200 --> 00:50:12,239
don't like it but I can understand it

00:50:12,450 --> 00:50:23,200
but I cannot understand why they would

00:50:16,960 --> 00:50:25,450
remove this and I don't know what's

00:50:23,200 --> 00:50:28,089
going to happen in the future they are

00:50:25,450 --> 00:50:32,140
have not fully converted from PHP to

00:50:28,089 --> 00:50:35,410
hack yet but eventually the entire code

00:50:32,140 --> 00:50:37,180
base will be hacked at which point they

00:50:35,410 --> 00:50:41,680
will wonder whether or not they still

00:50:37,180 --> 00:50:45,940
need to support PHP so on the one hand

00:50:41,680 --> 00:50:46,630
I'm really excited about 8hv M on the

00:50:45,940 --> 00:50:51,519
other side

00:50:46,630 --> 00:50:54,249
I don't know how committed they are in

00:50:51,519 --> 00:50:57,460
the long term to support PHP besides

00:50:54,249 --> 00:50:59,619
hack I mean if it's okay for you to

00:50:57,460 --> 00:51:02,170
migrate your codebase completely from

00:50:59,619 --> 00:51:03,640
PHP to hack or to use hack for new

00:51:02,170 --> 00:51:06,910
projects if you want to use the edge of

00:51:03,640 --> 00:51:09,249
VM then you are fine but if you look at

00:51:06,910 --> 00:51:11,589
edges VM today and just want to get the

00:51:09,249 --> 00:51:13,979
performance benefit out of it and your

00:51:11,589 --> 00:51:17,109
current PHP application works on it

00:51:13,979 --> 00:51:20,170
which it probably will and you make a

00:51:17,109 --> 00:51:21,729
decision to switch the runtime then at

00:51:20,170 --> 00:51:23,349
some point in the future you may need to

00:51:21,729 --> 00:51:29,469
switch again because it drop support for

00:51:23,349 --> 00:51:32,999
PHP so that's why I am a little bit

00:51:29,469 --> 00:51:38,019
confused between Varian excitons and

00:51:32,999 --> 00:51:40,150
enthusiastic and frustrated / angry but

00:51:38,019 --> 00:51:43,690
that's probably just my problem I don't

00:51:40,150 --> 00:51:47,680
know so thank you for your interest in

00:51:43,690 --> 00:51:51,579
this I hope it was useful for you next

00:51:47,680 --> 00:51:53,349
talk in this hh3m mini track will be by

00:51:51,579 --> 00:51:57,160
honor and he will show you how to

00:51:53,349 --> 00:51:58,869
install and configure a JVM in your

00:51:57,160 --> 00:52:03,249
system infrastructure integrated with

00:51:58,869 --> 00:52:06,779
nginx most likely and get you started in

00:52:03,249 --> 00:52:06,779

YouTube URL: https://www.youtube.com/watch?v=P9WhAUpMFdg


