Title: HHVM, the new PHP? - Stefan Priebsch | IPC14
Publication date: 2016-06-09
Playlist: International PHP Conference Spring 2014
Description: 
	Facebook has scaled their service to over a billion users, which is very impressive. At some point, however, PHP became their bottleneck. Turns out that rewriting over a million lines of code, even in another language, is not a viable option. So if you cannot change the application, why not change the platform? That is exactly what Facebook did when they created HipHop. HipHop was great, but ultimately failed. Now, the new kid on the block is HHVM, an alternative runtime for PHP. Will HHVM replace PHP? Should you care? Sketching out the history of the project, and its potential future, we will look not only from a technical point of view, but also analyze the business impact.
Captions: 
	00:00:06,470 --> 00:00:13,340
hello everybody

00:00:08,040 --> 00:00:13,340
H hvm the new PHP with a question mark

00:00:13,700 --> 00:00:22,260
basically I'm going to tell you a story

00:00:16,170 --> 00:00:25,170
of hhtv m as I view it and try to get a

00:00:22,260 --> 00:00:28,439
discussion going about how that might

00:00:25,170 --> 00:00:33,540
affect our future or not and what impact

00:00:28,439 --> 00:00:36,570
it might have basically it's purely

00:00:33,540 --> 00:00:40,290
speculation based on some technical

00:00:36,570 --> 00:00:44,070
facts that are already known so you

00:00:40,290 --> 00:00:45,690
can't sue me for anything I say today my

00:00:44,070 --> 00:00:47,940
name is Jeff and rich I'm from Munich

00:00:45,690 --> 00:00:51,930
one of the cofounders of the PHP

00:00:47,940 --> 00:00:54,930
consulting company and we help teams

00:00:51,930 --> 00:00:57,059
develop software successfully the key

00:00:54,930 --> 00:01:01,469
word being successfully in that context

00:00:57,059 --> 00:01:04,580
and now I'm going to talk about Facebook

00:01:01,469 --> 00:01:07,260
everybody knows Facebook obviously

00:01:04,580 --> 00:01:09,150
second largest website in the world with

00:01:07,260 --> 00:01:11,220
regards to traffic I think Google is

00:01:09,150 --> 00:01:14,610
number one at least that's according to

00:01:11,220 --> 00:01:18,000
Alexa and I checked those figures

00:01:14,610 --> 00:01:21,900
yesterday they claim to have 1.2 billion

00:01:18,000 --> 00:01:26,850
active users each month to put that in

00:01:21,900 --> 00:01:30,119
perspective I took those 1.1 one 1.2

00:01:26,850 --> 00:01:34,439
billion evenly distributed them over the

00:01:30,119 --> 00:01:39,180
day and got something like they need to

00:01:34,439 --> 00:01:41,820
deal with 9000 logins per second so

00:01:39,180 --> 00:01:43,680
that's what 1.2 billion users translates

00:01:41,820 --> 00:01:46,619
to roughly I don't have any exact

00:01:43,680 --> 00:01:49,950
numbers but I think it's safe to assume

00:01:46,619 --> 00:01:53,130
that Facebook is big and if you're

00:01:49,950 --> 00:01:57,240
really really big um you certainly have

00:01:53,130 --> 00:02:00,020
a few problems that people less big

00:01:57,240 --> 00:02:03,960
don't have so Facebook claims to have

00:02:00,020 --> 00:02:06,950
108 t petabytes of data per year that

00:02:03,960 --> 00:02:06,950
was in 2012

00:02:07,050 --> 00:02:12,270
honestly anything beyond a terabyte is

00:02:09,990 --> 00:02:13,860
sort of beyond my comprehension so I

00:02:12,270 --> 00:02:16,890
don't even know how many zeroes a

00:02:13,860 --> 00:02:20,190
petabyte has it's a lot and must

00:02:16,890 --> 00:02:22,620
translate to a lot of disks and they

00:02:20,190 --> 00:02:25,620
don't really say how much code they have

00:02:22,620 --> 00:02:28,250
but published numbers that you can find

00:02:25,620 --> 00:02:32,070
on the internet that are unconfirmed are

00:02:28,250 --> 00:02:34,470
ranging somewhere between 10 and 30

00:02:32,070 --> 00:02:36,390
million lines of PHP code they also have

00:02:34,470 --> 00:02:39,030
some code written in other languages but

00:02:36,390 --> 00:02:42,300
obviously this is IPC so we're going to

00:02:39,030 --> 00:02:46,560
focus on the PHP code for today and I

00:02:42,300 --> 00:02:50,450
would say that's a lot now what kind of

00:02:46,560 --> 00:02:54,720
problems would this kind of company have

00:02:50,450 --> 00:02:57,350
probably performance so rumors are that

00:02:54,720 --> 00:03:00,270
Facebook among other things

00:02:57,350 --> 00:03:02,100
re-implemented tcp/ip because they

00:03:00,270 --> 00:03:06,420
figured their internal networks are

00:03:02,100 --> 00:03:08,700
really safe and reliable so we don't

00:03:06,420 --> 00:03:11,190
need all this error handling and check

00:03:08,700 --> 00:03:14,250
some stuff so we have with it so they

00:03:11,190 --> 00:03:17,959
the rumors are that they built a very

00:03:14,250 --> 00:03:22,320
very thin tcp/ip stack on their own

00:03:17,959 --> 00:03:24,959
those are things that average developers

00:03:22,320 --> 00:03:26,400
don't really have to do those are

00:03:24,959 --> 00:03:29,120
problems that you don't really have to

00:03:26,400 --> 00:03:31,830
solve and as a matter of fact

00:03:29,120 --> 00:03:34,500
performance was not even the prime

00:03:31,830 --> 00:03:37,020
motivator for the whole HTM thing that

00:03:34,500 --> 00:03:40,440
we're going to talk about now turns out

00:03:37,020 --> 00:03:43,650
that performance was not really the

00:03:40,440 --> 00:03:46,980
issue the issue was resource usage now

00:03:43,650 --> 00:03:49,830
as Facebook grew they started about 10

00:03:46,980 --> 00:03:52,140
years ago and they have rewritten their

00:03:49,830 --> 00:03:56,670
code base of a couple of times as far as

00:03:52,140 --> 00:03:59,160
we know and they always choose an

00:03:56,670 --> 00:04:00,780
approach that allowed for some growth

00:03:59,160 --> 00:04:03,540
and at some point they realized that

00:04:00,780 --> 00:04:06,360
they had to invent the wheel again and

00:04:03,540 --> 00:04:08,040
start over because they had grown so big

00:04:06,360 --> 00:04:10,890
that they had they're facing new

00:04:08,040 --> 00:04:12,600
challenges and one of the things that

00:04:10,890 --> 00:04:17,549
they realized at some point was if

00:04:12,600 --> 00:04:20,670
you're executing PHP code it's kind of

00:04:17,549 --> 00:04:23,400
slow kind of slow with the quotation

00:04:20,670 --> 00:04:26,910
mark means it's not really slow for the

00:04:23,400 --> 00:04:29,400
average PHP user but if you have

00:04:26,910 --> 00:04:31,560
optimized everything else then at some

00:04:29,400 --> 00:04:34,230
point you realize Oh PHP is an

00:04:31,560 --> 00:04:38,700
interpreted language and interpreted

00:04:34,230 --> 00:04:40,800
languages are slow by design that's a

00:04:38,700 --> 00:04:43,170
trade-off right we're throwing source

00:04:40,800 --> 00:04:46,140
code somewhere it's gets interpreted

00:04:43,170 --> 00:04:49,620
without an explicit compilation step and

00:04:46,140 --> 00:04:53,220
that takes some time if you compile a

00:04:49,620 --> 00:04:54,360
program you have a compilation time and

00:04:53,220 --> 00:04:55,710
you don't really care about how long

00:04:54,360 --> 00:04:59,130
that is because it's separate from

00:04:55,710 --> 00:05:02,430
execution of the code so PHP by design

00:04:59,130 --> 00:05:04,050
is a rather slow language I'm saying

00:05:02,430 --> 00:05:07,920
rather slow because it's not really slow

00:05:04,050 --> 00:05:11,070
its fast enough because most of the time

00:05:07,920 --> 00:05:14,570
let's face it PHP like all other

00:05:11,070 --> 00:05:17,130
programming languages waits for i/o

00:05:14,570 --> 00:05:19,880
waits for the database which for other

00:05:17,130 --> 00:05:23,190
systems to answer to HTTP requests maybe

00:05:19,880 --> 00:05:28,380
somebody aptly said all languages wait

00:05:23,190 --> 00:05:31,850
at the same speed all languages don't

00:05:28,380 --> 00:05:36,570
scale because I always always the issue

00:05:31,850 --> 00:05:40,260
so with Facebook resource usage as they

00:05:36,570 --> 00:05:43,320
executed PHP code was an issue for them

00:05:40,260 --> 00:05:47,760
and they figured if we could execute PHP

00:05:43,320 --> 00:05:50,550
core code using less resources we

00:05:47,760 --> 00:05:54,360
actually might save on a couple of

00:05:50,550 --> 00:05:56,690
servers because Facebook runs well no

00:05:54,360 --> 00:05:59,580
published figures anything between

00:05:56,690 --> 00:06:04,110
50,000 and millions of servers probably

00:05:59,580 --> 00:06:07,050
a solid six digit number if you can say

00:06:04,110 --> 00:06:09,600
like ten percent of resources that

00:06:07,050 --> 00:06:14,130
translates to an outrageously big number

00:06:09,600 --> 00:06:16,590
of servers that you don't need there's

00:06:14,130 --> 00:06:18,630
money there's money you can save

00:06:16,590 --> 00:06:22,230
there is operational cost you can save

00:06:18,630 --> 00:06:24,630
well if you are Facebook if you are a

00:06:22,230 --> 00:06:28,020
bit smaller than Facebook like the

00:06:24,630 --> 00:06:31,350
average company running 20 or 50 servers

00:06:28,020 --> 00:06:34,350
or 500 I don't know there's a lot less

00:06:31,350 --> 00:06:36,270
potential to save well 10 percent

00:06:34,350 --> 00:06:38,910
led to maybe five servers that's some

00:06:36,270 --> 00:06:41,280
money but that's still not justifying

00:06:38,910 --> 00:06:44,910
the investment of having a few people

00:06:41,280 --> 00:06:48,560
reinvent PHP so to say and this in

00:06:44,910 --> 00:06:48,560
essence is exactly what Facebook did

00:06:49,280 --> 00:06:57,180
they could have chosen to rewrite the

00:06:53,310 --> 00:06:59,070
code base in theory in practice well how

00:06:57,180 --> 00:07:01,320
long does it take to rewrite ten million

00:06:59,070 --> 00:07:04,350
lines of code or 30 million lines of

00:07:01,320 --> 00:07:08,160
code takes more than a couple of weeks

00:07:04,350 --> 00:07:09,750
and that's expensive it's risky you

00:07:08,160 --> 00:07:11,670
don't really know what the code

00:07:09,750 --> 00:07:15,920
currently is doing rewriting everything

00:07:11,670 --> 00:07:18,870
is a hard thing and you can't really

00:07:15,920 --> 00:07:20,700
make a soft transition from the existing

00:07:18,870 --> 00:07:24,020
code base to the new one that's probably

00:07:20,700 --> 00:07:26,670
a tough problem to solve so rewriting

00:07:24,020 --> 00:07:28,650
obviously was not an option for Facebook

00:07:26,670 --> 00:07:30,780
from an economic point of view I think

00:07:28,650 --> 00:07:33,300
they are still sort of happy with PHP

00:07:30,780 --> 00:07:36,590
and I've always been but at some point

00:07:33,300 --> 00:07:39,870
they figured well we could choose a

00:07:36,590 --> 00:07:42,150
faster way a way that uses less

00:07:39,870 --> 00:07:47,160
resources primarily to actually run our

00:07:42,150 --> 00:07:49,760
scripts but rewriting them manually in

00:07:47,160 --> 00:07:52,050
another language is not an option

00:07:49,760 --> 00:07:54,960
but why would you need to rewrite code

00:07:52,050 --> 00:07:57,240
manually what do computer scientists do

00:07:54,960 --> 00:08:00,390
I mean they have crazy ideas and say hey

00:07:57,240 --> 00:08:03,000
you know what we could write software

00:08:00,390 --> 00:08:03,740
that rewrites our software in another

00:08:03,000 --> 00:08:11,190
language

00:08:03,740 --> 00:08:14,430
how about converting PHP to C++ and C++

00:08:11,190 --> 00:08:16,680
we can compile then we have all the

00:08:14,430 --> 00:08:18,990
advantages of compiled code which we can

00:08:16,680 --> 00:08:20,700
optimize takes a long time to compile

00:08:18,990 --> 00:08:25,650
and optimize but we don't care we deploy

00:08:20,700 --> 00:08:28,440
it and it's a lot faster and loses less

00:08:25,650 --> 00:08:30,600
resources it's an interesting question

00:08:28,440 --> 00:08:32,760
by the way if it's really a lot faster

00:08:30,600 --> 00:08:35,280
or if it takes quite some effort to make

00:08:32,760 --> 00:08:40,050
it faster in essence this is what what

00:08:35,280 --> 00:08:42,960
what Facebook did I think in 2010 when

00:08:40,050 --> 00:08:45,680
they released hip hop for PHP rumors are

00:08:42,960 --> 00:08:47,390
they had several teams working on

00:08:45,680 --> 00:08:49,010
approaches how to

00:08:47,390 --> 00:08:51,710
make the world better for Facebook

00:08:49,010 --> 00:08:53,030
technical world I mean and one of the

00:08:51,710 --> 00:08:56,500
solutions was hip hop that's a

00:08:53,030 --> 00:09:01,820
cross-compiler transforming PHP to C++

00:08:56,500 --> 00:09:05,600
and that's very interesting because it

00:09:01,820 --> 00:09:09,440
solved quite a few problems you they

00:09:05,600 --> 00:09:12,800
were using a lot fewer resources so they

00:09:09,440 --> 00:09:16,550
could serve they could save on a lot of

00:09:12,800 --> 00:09:20,510
servers but then it raised a couple of

00:09:16,550 --> 00:09:23,860
issues because suddenly you lose the

00:09:20,510 --> 00:09:26,780
advantages of interpreted code

00:09:23,860 --> 00:09:30,350
you can't just deploy one source code

00:09:26,780 --> 00:09:33,800
file you have to deploy a monolithic

00:09:30,350 --> 00:09:36,470
binary of your application in the case

00:09:33,800 --> 00:09:39,200
of Facebook that was about one gigabyte

00:09:36,470 --> 00:09:41,330
in size and they had to set up a

00:09:39,200 --> 00:09:44,900
BitTorrent infrastructure internally to

00:09:41,330 --> 00:09:47,690
distribute the code so it's fair to say

00:09:44,900 --> 00:09:50,210
that that raised quite a few new

00:09:47,690 --> 00:09:51,980
additional problems and one of the

00:09:50,210 --> 00:09:54,530
problems they were facing the developers

00:09:51,980 --> 00:09:58,010
were facing was where we can't do that

00:09:54,530 --> 00:09:59,690
f5 thing you know I mean everybody is

00:09:58,010 --> 00:10:01,550
talking about test automation whether

00:09:59,690 --> 00:10:04,730
you have that or not a lot of developers

00:10:01,550 --> 00:10:07,700
like that quick feedback press f5 and

00:10:04,730 --> 00:10:10,730
see if my code works and with a compiled

00:10:07,700 --> 00:10:13,370
language you can't really do that so

00:10:10,730 --> 00:10:16,520
that's a disadvantage we didn't make the

00:10:13,370 --> 00:10:19,250
developers happy as an answer to that

00:10:16,520 --> 00:10:21,710
Facebook actually wrote hip hop in an

00:10:19,250 --> 00:10:26,450
interpreted version as a separate piece

00:10:21,710 --> 00:10:29,210
of software and that worked in theory in

00:10:26,450 --> 00:10:30,740
practice they realized that it was too

00:10:29,210 --> 00:10:33,620
hard for them to keep the both in sync

00:10:30,740 --> 00:10:35,390
so basically the interpreted version was

00:10:33,620 --> 00:10:38,120
behaving differently than the compiled

00:10:35,390 --> 00:10:40,130
version and that's a bad position to be

00:10:38,120 --> 00:10:42,040
in so in the long run they figured that

00:10:40,130 --> 00:10:45,530
hip hop would not be the right solution

00:10:42,040 --> 00:10:47,570
even if they had already demonstrated

00:10:45,530 --> 00:10:50,060
that they could save on a lot of system

00:10:47,570 --> 00:10:52,370
resources executing PHP code in the

00:10:50,060 --> 00:10:57,190
first place and still keep writing PHP

00:10:52,370 --> 00:10:57,190
code but executing something different

00:10:58,490 --> 00:11:04,529
in according to my observations my

00:11:01,889 --> 00:11:06,930
personal observations it went rather

00:11:04,529 --> 00:11:12,420
silent for a couple of years then and

00:11:06,930 --> 00:11:14,610
then suddenly I was in Silicon Valley

00:11:12,420 --> 00:11:17,879
last year in October with Sebastian

00:11:14,610 --> 00:11:20,249
Bergman visiting Zen koan and we got

00:11:17,879 --> 00:11:22,860
pinged by Facebook saying hey guys would

00:11:20,249 --> 00:11:25,860
you like to stop over for a visit in our

00:11:22,860 --> 00:11:28,740
office and that was when they showed us

00:11:25,860 --> 00:11:31,350
that thing HH TM and what they did that

00:11:28,740 --> 00:11:32,999
was really cool back at the time was

00:11:31,350 --> 00:11:34,920
still under NDA so we were not allowed

00:11:32,999 --> 00:11:39,149
to talk about that because they had

00:11:34,920 --> 00:11:43,620
their public release not yet planned and

00:11:39,149 --> 00:11:46,050
what they did is well that compiling

00:11:43,620 --> 00:11:49,769
everything up front thing didn't work

00:11:46,050 --> 00:11:52,170
out too well so how about combining that

00:11:49,769 --> 00:11:55,199
scripting approach with a compilation

00:11:52,170 --> 00:11:57,269
approach that's what you call a

00:11:55,199 --> 00:11:59,850
just-in-time compiler so basically you

00:11:57,269 --> 00:12:03,329
have an interpreted language just like

00:11:59,850 --> 00:12:05,040
PHP that internally has a compiler but

00:12:03,329 --> 00:12:08,670
PHP internally will compile the full

00:12:05,040 --> 00:12:12,089
script and adjust in time compiler sort

00:12:08,670 --> 00:12:15,329
of as it executes compiles bits and

00:12:12,089 --> 00:12:17,160
pieces of the code down to assembly

00:12:15,329 --> 00:12:20,129
language to machine to machine code to

00:12:17,160 --> 00:12:22,949
be correct that can be executed rather

00:12:20,129 --> 00:12:26,879
quickly and doesn't need as int engine

00:12:22,949 --> 00:12:31,379
to run on so this is basically what HTM

00:12:26,879 --> 00:12:33,449
is it's a different PHP runtime you can

00:12:31,379 --> 00:12:36,569
throw PHP code added it's going to

00:12:33,449 --> 00:12:38,370
execute the PHP code internally it's a

00:12:36,569 --> 00:12:41,040
completely different piece of software

00:12:38,370 --> 00:12:42,870
there is no Zend engine it's not PHP as

00:12:41,040 --> 00:12:45,480
we know it it's another piece of

00:12:42,870 --> 00:12:48,750
software uses different representations

00:12:45,480 --> 00:12:51,540
of the code and compiles down to machine

00:12:48,750 --> 00:12:55,259
code versus the Zend engine which

00:12:51,540 --> 00:12:58,290
interprets bytecode so every at the end

00:12:55,259 --> 00:13:01,649
of the day every microprocessor always

00:12:58,290 --> 00:13:03,660
interprets code right machine code is an

00:13:01,649 --> 00:13:06,240
interpreted language so processors work

00:13:03,660 --> 00:13:09,660
like that bytecode is the machine

00:13:06,240 --> 00:13:10,440
language of a virtual machine so you

00:13:09,660 --> 00:13:12,090
have that whole

00:13:10,440 --> 00:13:14,430
thing in software that's how the Zen

00:13:12,090 --> 00:13:19,740
engine works this is how Java VM works

00:13:14,430 --> 00:13:24,390
by the way traditionally at least so you

00:13:19,740 --> 00:13:29,060
have interpretation directly by the

00:13:24,390 --> 00:13:32,490
microprocessor versus the overhead of

00:13:29,060 --> 00:13:35,430
running as int engine now the quotes are

00:13:32,490 --> 00:13:37,200
to stress that this is overhead that the

00:13:35,430 --> 00:13:39,840
average developer in the average user of

00:13:37,200 --> 00:13:42,870
PHP is not concerned about it doesn't

00:13:39,840 --> 00:13:45,540
hurt us PHP is fast enough because I

00:13:42,870 --> 00:13:48,000
always still where the action is again

00:13:45,540 --> 00:13:50,640
if you have a large scale well if you

00:13:48,000 --> 00:13:55,880
can save on if you can significally save

00:13:50,640 --> 00:13:59,070
on resources it would be a good thing so

00:13:55,880 --> 00:14:02,190
now we suddenly have all the advantages

00:13:59,070 --> 00:14:05,670
of a scripting language back because we

00:14:02,190 --> 00:14:07,170
can deploy a single source code file we

00:14:05,670 --> 00:14:10,710
don't have to deploy the code base

00:14:07,170 --> 00:14:13,560
actually Facebook has an internal

00:14:10,710 --> 00:14:17,910
representation of PHP code that the PHP

00:14:13,560 --> 00:14:20,970
code gets translated to and they don't

00:14:17,910 --> 00:14:24,510
actually have to deploy the source code

00:14:20,970 --> 00:14:27,450
but they are deploying a sequel Lite

00:14:24,510 --> 00:14:30,780
database which contains contains an

00:14:27,450 --> 00:14:33,290
intermediary representation that then

00:14:30,780 --> 00:14:36,480
gets compiled down to machine language

00:14:33,290 --> 00:14:39,750
so it's basically from a technical point

00:14:36,480 --> 00:14:41,580
of view if you if you forgive me the

00:14:39,750 --> 00:14:44,580
term it's really crazy that I've

00:14:41,580 --> 00:14:47,490
been doing and what they've been doing

00:14:44,580 --> 00:14:51,240
is well it's it's an economic trade-off

00:14:47,490 --> 00:14:54,600
it's cheaper to change the platform it's

00:14:51,240 --> 00:14:57,089
cheaper to change the engine then to

00:14:54,600 --> 00:14:59,300
have thousands of developers that you

00:14:57,089 --> 00:15:02,339
need to retrain using a new language or

00:14:59,300 --> 00:15:04,980
even have them rewrite the whole thing

00:15:02,339 --> 00:15:06,960
and whether they had rewritten the whole

00:15:04,980 --> 00:15:08,300
thing in a different language wouldn't

00:15:06,960 --> 00:15:11,339
have been much of a help

00:15:08,300 --> 00:15:14,370
so the problem they set out to solve was

00:15:11,339 --> 00:15:16,530
cut down on resource usage and the

00:15:14,370 --> 00:15:19,830
interesting thing is that where they are

00:15:16,530 --> 00:15:23,490
at now has some consequences that

00:15:19,830 --> 00:15:24,180
actually led them to go even further

00:15:23,490 --> 00:15:26,850
steps

00:15:24,180 --> 00:15:30,060
we'll discuss those in a bit so first of

00:15:26,850 --> 00:15:32,040
all we have that performance thing we

00:15:30,060 --> 00:15:35,580
have that resource usage thing so it

00:15:32,040 --> 00:15:39,060
turns out that when you compile code you

00:15:35,580 --> 00:15:45,530
can add optimizations a funny thing is

00:15:39,060 --> 00:15:48,600
that dynamically typed languages as PHP

00:15:45,530 --> 00:15:51,150
really perform a rather bad if you

00:15:48,600 --> 00:15:54,090
compile them because you have to compile

00:15:51,150 --> 00:15:55,890
them to very generic code that has to

00:15:54,090 --> 00:15:57,720
make a distinction between is that an

00:15:55,890 --> 00:16:00,510
integer is that a string is that whatnot

00:15:57,720 --> 00:16:02,310
is that a float so that's a lot of code

00:16:00,510 --> 00:16:06,360
and that's a lot of complexity involved

00:16:02,310 --> 00:16:08,610
that basically causes step and

00:16:06,360 --> 00:16:13,050
dynamically typed code if you compile it

00:16:08,610 --> 00:16:15,720
to not perform rather well well PHP is

00:16:13,050 --> 00:16:18,000
dynamically typed as we know so there is

00:16:15,720 --> 00:16:22,560
sort of a conceptual gap between the two

00:16:18,000 --> 00:16:26,910
things as a matter of fact the speed

00:16:22,560 --> 00:16:30,240
gains from compiling result from a

00:16:26,910 --> 00:16:32,790
stronger typing so with hip hop what

00:16:30,240 --> 00:16:36,320
they did was first of all they ran a

00:16:32,790 --> 00:16:38,910
process to analyze PHP code and

00:16:36,320 --> 00:16:41,460
sometimes it's really clear that some

00:16:38,910 --> 00:16:43,320
variable is an integer and then they had

00:16:41,460 --> 00:16:45,300
a type in Firenze way but if this is an

00:16:43,320 --> 00:16:47,100
integer then you're passing it there

00:16:45,300 --> 00:16:49,740
this must be an integer so you can

00:16:47,100 --> 00:16:53,910
basically build a tree or a graph of all

00:16:49,740 --> 00:16:56,760
the types and you know what variable has

00:16:53,910 --> 00:16:59,010
what type for some of the variables not

00:16:56,760 --> 00:17:01,380
all of them and for those where it works

00:16:59,010 --> 00:17:04,350
you can compile it down to code that

00:17:01,380 --> 00:17:07,260
exactly works for that variable type

00:17:04,350 --> 00:17:08,700
because well microprocessor is there a

00:17:07,260 --> 00:17:10,920
strongly typed you can work with a

00:17:08,700 --> 00:17:12,839
character or a float or an integer you

00:17:10,920 --> 00:17:18,350
have to make a distinction at the PHP

00:17:12,839 --> 00:17:23,880
level you don't so this leads to the

00:17:18,350 --> 00:17:27,060
conclusion that writing code that's more

00:17:23,880 --> 00:17:30,180
strictly typed might actually be a good

00:17:27,060 --> 00:17:32,310
idea and a lot of people have been

00:17:30,180 --> 00:17:33,930
arguing about that in the PHP world if

00:17:32,310 --> 00:17:36,230
you ask to our developers they say oh

00:17:33,930 --> 00:17:38,059
without the strict typing

00:17:36,230 --> 00:17:39,860
well you can't really write this in

00:17:38,059 --> 00:17:42,139
software you can't write software at

00:17:39,860 --> 00:17:45,500
scale you can't manage code bases with a

00:17:42,139 --> 00:17:47,539
couple of million lines of code whether

00:17:45,500 --> 00:17:51,470
what's the what's the biggest code base

00:17:47,539 --> 00:17:54,590
in PHP we have anybody above 100,000

00:17:51,470 --> 00:17:58,970
lines roughly okay

00:17:54,590 --> 00:18:01,850
about 500,000 okay anybody above a

00:17:58,970 --> 00:18:03,740
million okay

00:18:01,850 --> 00:18:05,870
so that that's according to my

00:18:03,740 --> 00:18:09,740
experience I very very rarely see code

00:18:05,870 --> 00:18:12,320
bases above a million lines in PHP I've

00:18:09,740 --> 00:18:15,169
been listening to a Java consultant and

00:18:12,320 --> 00:18:18,740
said you know I don't start thinking

00:18:15,169 --> 00:18:21,919
below 10 million so one of the chances

00:18:18,740 --> 00:18:24,529
that a ttpm brings better performance

00:18:21,919 --> 00:18:28,190
less resource usage that sort of sounds

00:18:24,529 --> 00:18:30,710
lame because Microsoft since Windows 3

00:18:28,190 --> 00:18:33,529
Oh with each word they have told us all

00:18:30,710 --> 00:18:34,610
better performance and it's also it's

00:18:33,529 --> 00:18:35,690
jim basically it's just better

00:18:34,610 --> 00:18:38,419
performance because you had to buy a

00:18:35,690 --> 00:18:41,929
bigger computer but well they got away

00:18:38,419 --> 00:18:43,669
with it at least until now and i think

00:18:41,929 --> 00:18:46,000
now they are considering giving the

00:18:43,669 --> 00:18:50,240
operating systems away almost for free

00:18:46,000 --> 00:18:54,980
maybe that maybe that's a that's a

00:18:50,240 --> 00:18:59,360
lesson but anyway I think for many users

00:18:54,980 --> 00:19:01,580
of existing software like Magento like

00:18:59,360 --> 00:19:03,889
oxy details like big e-commerce list

00:19:01,580 --> 00:19:06,590
systems like big pieces of monolithic

00:19:03,889 --> 00:19:09,190
software that you can just use they are

00:19:06,590 --> 00:19:11,720
very interested in performance gains

00:19:09,190 --> 00:19:14,649
look at all those caching mechanisms

00:19:11,720 --> 00:19:17,450
look at all those varnish that are using

00:19:14,649 --> 00:19:19,309
so if you're one of those companies it

00:19:17,450 --> 00:19:22,370
might be actually very interesting to

00:19:19,309 --> 00:19:24,080
look at hvm and see whether you can get

00:19:22,370 --> 00:19:27,409
performance gain out of the whole thing

00:19:24,080 --> 00:19:29,120
I would never dare to say ok use hvm is

00:19:27,409 --> 00:19:31,880
going to be faster I've actually seen

00:19:29,120 --> 00:19:34,700
people benchmark hvm to be slower than

00:19:31,880 --> 00:19:36,980
PHP keep in mind that it's a

00:19:34,700 --> 00:19:40,010
just-in-time compilation so at first

00:19:36,980 --> 00:19:42,250
execution it needs to compile down it's

00:19:40,010 --> 00:19:44,809
actually slower than stock PHP on

00:19:42,250 --> 00:19:47,659
subsequent executions it's usually a lot

00:19:44,809 --> 00:19:49,710
faster so you need to do some kind of

00:19:47,659 --> 00:19:51,929
cache warming thing for

00:19:49,710 --> 00:19:54,659
your code so that you can really get up

00:19:51,929 --> 00:19:57,450
to speed but let's assume that you're a

00:19:54,659 --> 00:20:00,950
hosting company or a cloud-based hosting

00:19:57,450 --> 00:20:05,039
company and you can offer 20%

00:20:00,950 --> 00:20:08,730
performance benefit over other solutions

00:20:05,039 --> 00:20:11,940
or you can do the same with 20% fewer

00:20:08,730 --> 00:20:13,289
resources I think from an economic point

00:20:11,940 --> 00:20:16,980
of view that might be very very

00:20:13,289 --> 00:20:23,220
interesting so let's talk about more

00:20:16,980 --> 00:20:27,570
chances and risks HACC is sort of the

00:20:23,220 --> 00:20:29,820
next logical step once Facebook had

00:20:27,570 --> 00:20:34,190
realized that cross-compiling PHP code

00:20:29,820 --> 00:20:37,860
does have value they also realize that

00:20:34,190 --> 00:20:42,240
dynamically typed code is hard to

00:20:37,860 --> 00:20:44,909
cross-compiler so why not type the code

00:20:42,240 --> 00:20:47,070
more statically that's also a good idea

00:20:44,909 --> 00:20:50,130
if you can add that on top of an

00:20:47,070 --> 00:20:52,470
existing code base because it prevents

00:20:50,130 --> 00:20:54,750
developers from making mistakes that's

00:20:52,470 --> 00:20:57,510
one of the fundamental differences of a

00:20:54,750 --> 00:21:00,029
language like PHP where people say oh

00:20:57,510 --> 00:21:03,120
PHP is great because it's so easy to get

00:21:00,029 --> 00:21:05,070
started with but then PHP is sort of

00:21:03,120 --> 00:21:06,510
sake because it's so easy to get started

00:21:05,070 --> 00:21:07,860
with and you get a lot of developers

00:21:06,510 --> 00:21:10,950
that don't really know what they're

00:21:07,860 --> 00:21:13,020
doing versus a strongly typed language

00:21:10,950 --> 00:21:16,020
like Java

00:21:13,020 --> 00:21:18,270
I remember how long it took me to write

00:21:16,020 --> 00:21:20,390
my first Java program and get that to

00:21:18,270 --> 00:21:24,210
compile when I was back at university

00:21:20,390 --> 00:21:28,409
which is almost 10 years ago that's

00:21:24,210 --> 00:21:30,690
really scary so it's a lot more

00:21:28,409 --> 00:21:33,450
difficult in the beginning and this is

00:21:30,690 --> 00:21:36,179
what makes PHP so appealing to many but

00:21:33,450 --> 00:21:37,950
on the long run it turns out that this

00:21:36,179 --> 00:21:39,899
dynamic typing is not the best of ideas

00:21:37,950 --> 00:21:41,659
because you're passing around parameters

00:21:39,899 --> 00:21:45,350
without really knowing what they are

00:21:41,659 --> 00:21:47,730
where people argue that on the web

00:21:45,350 --> 00:21:50,370
strong typing doesn't really make sense

00:21:47,730 --> 00:21:53,070
because at in essence we are always

00:21:50,370 --> 00:21:55,559
processing strings it's always HTTP

00:21:53,070 --> 00:21:57,840
requests and those are strings and we

00:21:55,559 --> 00:22:00,360
always send strings back as an HTTP

00:21:57,840 --> 00:22:02,730
response so why should we have strong

00:22:00,360 --> 00:22:03,149
typing why should I need to convert

00:22:02,730 --> 00:22:05,099
every

00:22:03,149 --> 00:22:08,429
from string to something else this is

00:22:05,099 --> 00:22:11,639
why dynamic typing as PHP does it make

00:22:08,429 --> 00:22:14,549
sense from that perspective from the

00:22:11,639 --> 00:22:16,950
maintenance aspect I've been talking to

00:22:14,549 --> 00:22:19,440
companies that actually have multiple

00:22:16,950 --> 00:22:22,739
millions lines of code PHP code base and

00:22:19,440 --> 00:22:24,929
say they say you know it's very it's a

00:22:22,739 --> 00:22:29,609
very complex task for us that we

00:22:24,929 --> 00:22:31,679
actually have to execute PHP code versus

00:22:29,609 --> 00:22:34,589
have the compiler tell us that we have

00:22:31,679 --> 00:22:38,789
done stupid things so you can get away

00:22:34,589 --> 00:22:41,339
you can work around the lack of static

00:22:38,789 --> 00:22:44,070
analysis that you know that would be

00:22:41,339 --> 00:22:46,469
present in a compiled language by

00:22:44,070 --> 00:22:47,190
running more unit tests it's as simple

00:22:46,469 --> 00:22:48,749
as that

00:22:47,190 --> 00:22:51,690
if you want to make sure that something

00:22:48,749 --> 00:22:54,479
is a certain parameter type well just

00:22:51,690 --> 00:22:57,059
write a unit test pass a sensible value

00:22:54,479 --> 00:22:59,369
pass a nonsense value and you know what

00:22:57,059 --> 00:23:02,009
is what results to expect so it's

00:22:59,369 --> 00:23:05,609
actually in theory at least pretty easy

00:23:02,009 --> 00:23:10,289
to work around the type system issues if

00:23:05,609 --> 00:23:12,899
they're not real issues in well Facebook

00:23:10,289 --> 00:23:17,309
has realized that and said okay how

00:23:12,899 --> 00:23:19,710
about we add we add more typing to PHP

00:23:17,309 --> 00:23:22,679
and they went an approach they call

00:23:19,710 --> 00:23:25,859
gradual typing it's sort of we are

00:23:22,679 --> 00:23:28,859
loosely typed and we are moving towards

00:23:25,859 --> 00:23:31,440
being strictly typed but we make that

00:23:28,859 --> 00:23:34,200
optional it's sort of like the optional

00:23:31,440 --> 00:23:36,899
type ins in PHP and this is what they

00:23:34,200 --> 00:23:38,879
call hack I think the name is

00:23:36,899 --> 00:23:42,210
questionable but that's my personal

00:23:38,879 --> 00:23:46,609
taste they also change the address of

00:23:42,210 --> 00:23:51,029
Facebook headquarters to one hack away

00:23:46,609 --> 00:23:53,519
well so what what we see here is it

00:23:51,029 --> 00:23:55,710
looks almost like PHP and it's it's in

00:23:53,519 --> 00:23:59,009
essence it's backwards compatible to PHP

00:23:55,710 --> 00:24:01,320
but you can add type ins on top I'll not

00:23:59,009 --> 00:24:03,259
go deeper into the details of hack I

00:24:01,320 --> 00:24:07,859
think Sebastian has a talk coming up

00:24:03,259 --> 00:24:11,369
where he is going to do that um for

00:24:07,859 --> 00:24:13,440
Facebook they say that internally they

00:24:11,369 --> 00:24:14,680
have converted almost all of their code

00:24:13,440 --> 00:24:17,670
base to hack

00:24:14,680 --> 00:24:21,840
and they have found loads of issues

00:24:17,670 --> 00:24:26,410
without actually executing the code

00:24:21,840 --> 00:24:28,260
pitch P is not exactly known to be a

00:24:26,410 --> 00:24:32,260
language that makes it easy to perform

00:24:28,260 --> 00:24:35,640
static code analysis with hack with the

00:24:32,260 --> 00:24:38,290
type inference options that you have

00:24:35,640 --> 00:24:41,380
you're a lot better off and actually one

00:24:38,290 --> 00:24:43,570
of the things that I enjoyed most about

00:24:41,380 --> 00:24:47,470
HTM when they showed it to us

00:24:43,570 --> 00:24:49,690
hom is based on a solid defined abstract

00:24:47,470 --> 00:24:52,570
syntax tree which would be the perfect

00:24:49,690 --> 00:24:55,060
data structure to run code analysis on

00:24:52,570 --> 00:24:58,240
so I was really hooked by that because

00:24:55,060 --> 00:24:59,170
in PHP you have a token stream and this

00:24:58,240 --> 00:25:02,920
is really ugly

00:24:59,170 --> 00:25:07,000
and then every everything is well very

00:25:02,920 --> 00:25:09,400
vague let's say so that might have been

00:25:07,000 --> 00:25:11,620
an interesting option using HTM to

00:25:09,400 --> 00:25:16,380
actually perform static code analysis of

00:25:11,620 --> 00:25:18,970
PHP code one of the downsides is

00:25:16,380 --> 00:25:20,650
Facebook removed that feature somewhere

00:25:18,970 --> 00:25:24,600
on the way and that's it's rather

00:25:20,650 --> 00:25:24,600
unclear what the state of affairs is

00:25:25,710 --> 00:25:34,120
this is this is part of the next talk

00:25:29,020 --> 00:25:37,650
and I'm yeah so actually I think that

00:25:34,120 --> 00:25:41,050
hack as the new page P is a chance

00:25:37,650 --> 00:25:43,690
because hack does offer some very very

00:25:41,050 --> 00:25:46,270
interesting features like more typing

00:25:43,690 --> 00:25:47,860
like collections like stuff and stuff

00:25:46,270 --> 00:25:49,600
that you don't even understand if you

00:25:47,860 --> 00:25:52,780
first look at it there's a lot of

00:25:49,600 --> 00:25:57,190
interesting things and getting them into

00:25:52,780 --> 00:25:59,290
PHP would take years which also may be

00:25:57,190 --> 00:26:02,020
due to the fact that PHP core developers

00:25:59,290 --> 00:26:08,410
sometimes have a hard time agreeing on

00:26:02,020 --> 00:26:10,330
things we had to take bit talking about

00:26:08,410 --> 00:26:12,390
the chances first and we cut we're going

00:26:10,330 --> 00:26:20,530
to cover the risks don't worry

00:26:12,390 --> 00:26:23,740
so the PHP thing that's I think the to

00:26:20,530 --> 00:26:27,980
me that's the killer feature with hhv M

00:26:23,740 --> 00:26:31,730
you can write PHP extensions in PHP

00:26:27,980 --> 00:26:33,710
so with PHP you can easily extend the

00:26:31,730 --> 00:26:37,159
core of the language but you have to

00:26:33,710 --> 00:26:40,549
write C code to do that with hvm you can

00:26:37,159 --> 00:26:43,639
actually write extensions in PHP there

00:26:40,549 --> 00:26:46,210
is a native there is a library that

00:26:43,639 --> 00:26:49,580
allows you to perform native calls and

00:26:46,210 --> 00:26:52,100
if you look at the HTM which is open

00:26:49,580 --> 00:26:55,159
source it's available on github they

00:26:52,100 --> 00:26:57,320
have the file info extension for example

00:26:55,159 --> 00:26:59,750
and and I think a few others are written

00:26:57,320 --> 00:27:03,260
in PHP so you can actually read the PHP

00:26:59,750 --> 00:27:05,570
code of a PHP extension that's very very

00:27:03,260 --> 00:27:07,100
interesting because if you think about

00:27:05,570 --> 00:27:09,320
all those frameworks

00:27:07,100 --> 00:27:11,630
what do frameworks do frameworks add

00:27:09,320 --> 00:27:13,789
layers of abstraction to make things

00:27:11,630 --> 00:27:15,500
easier for developers with the best

00:27:13,789 --> 00:27:17,529
intent sometimes they even fail doing

00:27:15,500 --> 00:27:19,820
that but they have a good intent though

00:27:17,529 --> 00:27:23,000
what is layer of abstraction abstraction

00:27:19,820 --> 00:27:25,549
means it'll get slower because the more

00:27:23,000 --> 00:27:28,330
abstraction there is the more complexity

00:27:25,549 --> 00:27:32,210
the more stuff you need to do at runtime

00:27:28,330 --> 00:27:34,549
now in a compiled language we might

00:27:32,210 --> 00:27:36,260
actually have the abstraction in the

00:27:34,549 --> 00:27:38,990
source code with make sure which makes

00:27:36,260 --> 00:27:41,899
it more readable and more maintainable

00:27:38,990 --> 00:27:46,809
to us but we can optimize out those

00:27:41,899 --> 00:27:50,000
abstractions before we execute the code

00:27:46,809 --> 00:27:53,000
there are some approaches doing that in

00:27:50,000 --> 00:27:55,149
PHP as well and have always been sent at

00:27:53,000 --> 00:27:57,700
the PHP optimizer I think they have

00:27:55,149 --> 00:28:00,679
discontinued it now I think that

00:27:57,700 --> 00:28:03,559
optimizing byte code or PHP code or

00:28:00,679 --> 00:28:05,929
whatever code while you compile it is a

00:28:03,559 --> 00:28:08,929
very very appealing concept with a

00:28:05,929 --> 00:28:11,330
traditional interpreted language you

00:28:08,929 --> 00:28:12,679
can't really do that because you don't

00:28:11,330 --> 00:28:15,590
know how much time you're going to spend

00:28:12,679 --> 00:28:18,470
optimizing it and if you do that in the

00:28:15,590 --> 00:28:22,220
execution step you'll probably not end

00:28:18,470 --> 00:28:26,000
up with the runtime benefit Latian step

00:28:22,220 --> 00:28:30,470
and compile upfront optimizing becomes

00:28:26,000 --> 00:28:33,820
very appealing and well with vhh VM and

00:28:30,470 --> 00:28:37,220
the hip hop approach I think optimizing

00:28:33,820 --> 00:28:39,529
might be easier to do because you have a

00:28:37,220 --> 00:28:40,509
lower level language which is easier to

00:28:39,529 --> 00:28:42,639
understand

00:28:40,509 --> 00:28:45,039
from a technical point of view not from

00:28:42,639 --> 00:28:47,349
human point of view so it's probably

00:28:45,039 --> 00:28:49,419
easier to optimize and I think this

00:28:47,349 --> 00:28:52,059
might be a killer feature because a

00:28:49,419 --> 00:28:54,489
framework suddenly might be viewed as a

00:28:52,059 --> 00:28:57,579
kind of extension to PHP as a kind of

00:28:54,489 --> 00:28:59,529
library some framework developers say

00:28:57,579 --> 00:29:01,989
you know we as frameworks we provide

00:28:59,529 --> 00:29:04,509
abstraction from the actual language so

00:29:01,989 --> 00:29:06,849
if the language changes and evolves you

00:29:04,509 --> 00:29:08,739
don't need to modify your applications

00:29:06,849 --> 00:29:13,449
and there are a lot of possibilities in

00:29:08,739 --> 00:29:15,399
that then of course well I already

00:29:13,449 --> 00:29:17,739
mention that the performance aspect

00:29:15,399 --> 00:29:21,009
compiler optimizations so I got the

00:29:17,739 --> 00:29:24,489
slides in the wrong order I think we are

00:29:21,009 --> 00:29:29,289
going to see a lot more of that in HHV m

00:29:24,489 --> 00:29:33,429
and yeah we get to that so let's talk

00:29:29,289 --> 00:29:37,299
about happy people let's talk about open

00:29:33,429 --> 00:29:41,769
source projects and let's also talk

00:29:37,299 --> 00:29:47,769
about risks the risks that I see that

00:29:41,769 --> 00:29:51,009
hhv M might come attached with it's not

00:29:47,769 --> 00:29:55,719
a real open source project yes it is on

00:29:51,009 --> 00:29:57,699
github you can fork it you can have you

00:29:55,719 --> 00:30:01,259
can you can ask you can send pull

00:29:57,699 --> 00:30:03,969
requests and they'll probably merge it

00:30:01,259 --> 00:30:07,419
but it's not a true open source project

00:30:03,969 --> 00:30:09,549
because it's controlled by Facebook the

00:30:07,419 --> 00:30:13,449
people working at Facebook are paid to

00:30:09,549 --> 00:30:17,199
do this and they'll they're allowed to

00:30:13,449 --> 00:30:19,509
open source it and I fully believe them

00:30:17,199 --> 00:30:20,949
that they do in the best intent and to

00:30:19,509 --> 00:30:23,979
all the people I've talked with I'm

00:30:20,949 --> 00:30:26,709
absolutely convinced that they really

00:30:23,979 --> 00:30:30,039
love the open source principle but still

00:30:26,709 --> 00:30:33,959
it's a commercial company they make

00:30:30,039 --> 00:30:36,729
decisions based on economic whatever

00:30:33,959 --> 00:30:41,049
parameters and they might in the future

00:30:36,729 --> 00:30:44,699
just decide to not continue it as an

00:30:41,049 --> 00:30:44,699
open source project question there

00:30:46,870 --> 00:30:52,190
honestly beats me you have to look that

00:30:49,760 --> 00:30:55,460
up at github I would assume that it's

00:30:52,190 --> 00:31:00,559
BSD type but I wouldn't I wouldn't know

00:30:55,460 --> 00:31:02,450
that that's that's an outrageously great

00:31:00,559 --> 00:31:05,150
question because I've been researching

00:31:02,450 --> 00:31:07,400
around that for half a year and I've

00:31:05,150 --> 00:31:11,690
never had the idea of looking at the

00:31:07,400 --> 00:31:14,750
license so the thing is that they do

00:31:11,690 --> 00:31:16,429
what Facebook needs and the abstract

00:31:14,750 --> 00:31:18,470
syntax tree thing got into their way so

00:31:16,429 --> 00:31:25,420
they removed it and I leave the rant

00:31:18,470 --> 00:31:25,420
part on that up to Sebastian okay

00:32:25,590 --> 00:32:38,710
so we will get to that in a couple of

00:32:35,769 --> 00:32:42,070
minutes maybe I'm not sure I can answer

00:32:38,710 --> 00:32:43,720
this question so that's probably not if

00:32:42,070 --> 00:32:45,820
that's not on camera that was too much

00:32:43,720 --> 00:32:49,090
to repeat it so license question is

00:32:45,820 --> 00:32:51,399
answered it's a BSD de rivet and we

00:32:49,090 --> 00:32:53,590
really have no clue what that legally

00:32:51,399 --> 00:32:55,419
what what the legal implications of

00:32:53,590 --> 00:32:58,000
those might be that that's one of the

00:32:55,419 --> 00:32:59,769
hard things of of those licenses if you

00:32:58,000 --> 00:33:03,070
started reading them I was actually

00:32:59,769 --> 00:33:06,399
looking at the Facebook CLI CLA and said

00:33:03,070 --> 00:33:08,549
no I'm not going to sign that so I can't

00:33:06,399 --> 00:33:10,570
contribute to HTM it's a sort of a

00:33:08,549 --> 00:33:14,590
philosophical problem that I have with

00:33:10,570 --> 00:33:16,899
that Facebook could lose interest they

00:33:14,590 --> 00:33:19,480
could lose interest in running that as

00:33:16,899 --> 00:33:21,220
open source in publishing that as open

00:33:19,480 --> 00:33:23,139
source currently they are trying to

00:33:21,220 --> 00:33:25,000
build up a community they're trying to

00:33:23,139 --> 00:33:27,340
get other companies interested in using

00:33:25,000 --> 00:33:29,590
it because they can benefit if that's an

00:33:27,340 --> 00:33:31,779
open source project and maintenance is

00:33:29,590 --> 00:33:32,139
something that they don't have to do on

00:33:31,779 --> 00:33:35,559
their own

00:33:32,139 --> 00:33:39,850
plus if more people out there use it and

00:33:35,559 --> 00:33:43,659
also maybe use that as a transition path

00:33:39,850 --> 00:33:45,309
to hack then they would be more up to

00:33:43,659 --> 00:33:46,990
working for Facebook because they

00:33:45,309 --> 00:33:49,629
already know the language so for

00:33:46,990 --> 00:33:52,389
Facebook it's currently a really really

00:33:49,629 --> 00:33:54,909
good idea to run that as an open source

00:33:52,389 --> 00:33:57,369
project but one of the things that

00:33:54,909 --> 00:34:01,270
actually might happen and personally I

00:33:57,369 --> 00:34:03,220
think that that's something that we

00:34:01,270 --> 00:34:06,610
which might see happen in the next two

00:34:03,220 --> 00:34:10,030
or three years is that Facebook loses

00:34:06,610 --> 00:34:12,430
interest in supporting PHP now they are

00:34:10,030 --> 00:34:14,440
currently aiming for PHP compatibility

00:34:12,430 --> 00:34:16,750
they are actually aiming for 100%

00:34:14,440 --> 00:34:18,610
compatibility I don't think this is

00:34:16,750 --> 00:34:21,330
technically possible but they claim to

00:34:18,610 --> 00:34:24,610
be closed by running the test Suites of

00:34:21,330 --> 00:34:26,740
50 or so commonly known open-source

00:34:24,610 --> 00:34:30,910
projects and they're very very close to

00:34:26,740 --> 00:34:33,600
100% of tests that pass so that's a

00:34:30,910 --> 00:34:36,070
promising sign

00:34:33,600 --> 00:34:39,340
if they have converted everything to

00:34:36,070 --> 00:34:43,060
hack internally as they move away from

00:34:39,340 --> 00:34:44,950
PHP and there's going to be a split they

00:34:43,060 --> 00:34:48,070
say okay if PHP introduces new features

00:34:44,950 --> 00:34:49,630
we're going to adapt hack to PHP well

00:34:48,070 --> 00:34:51,520
it's actually pretty simple to do you

00:34:49,630 --> 00:34:53,440
can always write a cross compiler right

00:34:51,520 --> 00:34:57,420
they've done that before they got that

00:34:53,440 --> 00:35:00,040
down but whether it's still economically

00:34:57,420 --> 00:35:02,710
feasible or interesting for them to

00:35:00,040 --> 00:35:05,590
still support PHP on a JVM in two or

00:35:02,710 --> 00:35:07,530
three years I don't know maybe other

00:35:05,590 --> 00:35:10,480
projects have converted to hack and

00:35:07,530 --> 00:35:13,030
nobody's using PHP baizen I don't know

00:35:10,480 --> 00:35:18,130
we'll discuss that in a bit this is

00:35:13,030 --> 00:35:21,310
exactly this is exactly what could

00:35:18,130 --> 00:35:24,640
happen a split fragmentation of the

00:35:21,310 --> 00:35:29,170
community and this could happen multiple

00:35:24,640 --> 00:35:33,100
ways number one maybe hack becomes the

00:35:29,170 --> 00:35:35,920
professional Enterprise PHP maybe PHP

00:35:33,100 --> 00:35:39,510
becomes the well that's sort of for the

00:35:35,920 --> 00:35:43,720
smaller project things I could happen

00:35:39,510 --> 00:35:46,690
maybe that's not even that much of a

00:35:43,720 --> 00:35:50,650
problem maybe we already have that if

00:35:46,690 --> 00:35:53,380
you look at PHP for PHP five wasn't that

00:35:50,650 --> 00:35:56,290
pretty much the same thing PHP 5 was

00:35:53,380 --> 00:35:58,300
available everybody said well that's

00:35:56,290 --> 00:36:00,670
enterprise-d that's enterprise-ready and

00:35:58,300 --> 00:36:03,670
it was marketing at the time we know

00:36:00,670 --> 00:36:05,830
that it was not Enterprise ready but it

00:36:03,670 --> 00:36:08,890
sort of got pushed into the enterprise's

00:36:05,830 --> 00:36:10,750
and then well nowadays I think you can

00:36:08,890 --> 00:36:12,700
really really build decent enterprise

00:36:10,750 --> 00:36:14,680
applications based on PHP in current

00:36:12,700 --> 00:36:15,250
versions but still peach before was

00:36:14,680 --> 00:36:16,900
around

00:36:15,250 --> 00:36:18,940
and a lot of projects were stuck with

00:36:16,900 --> 00:36:22,990
peach before so there already was a

00:36:18,940 --> 00:36:24,760
fragmentation don't we always have that

00:36:22,990 --> 00:36:25,770
fragmentation if we introduce a new

00:36:24,760 --> 00:36:30,100
version

00:36:25,770 --> 00:36:32,920
well PHP is often picked upon for having

00:36:30,100 --> 00:36:36,730
all those old issues those old design

00:36:32,920 --> 00:36:38,170
flaws and yeah guys you don't remove

00:36:36,730 --> 00:36:39,670
them you know why they don't remove them

00:36:38,170 --> 00:36:42,880
today I care about backwards

00:36:39,670 --> 00:36:44,380
compatibility and this is a big issue if

00:36:42,880 --> 00:36:46,690
you care about backwards compatibility

00:36:44,380 --> 00:36:48,520
you can't really move forward if you

00:36:46,690 --> 00:36:49,180
move forward you have to leave people

00:36:48,520 --> 00:36:51,370
behind

00:36:49,180 --> 00:36:55,090
so you have a fragmentation you have a

00:36:51,370 --> 00:36:57,340
split I think in a way that's a very

00:36:55,090 --> 00:36:59,680
natural thing to happen and if there is

00:36:57,340 --> 00:37:01,930
a new major version of PHP at some point

00:36:59,680 --> 00:37:03,370
in the future whether that's called PHP

00:37:01,930 --> 00:37:05,230
6 or PHP 7

00:37:03,370 --> 00:37:07,060
I don't know PHP 6 the name is already

00:37:05,230 --> 00:37:09,550
taken because they tried that a couple

00:37:07,060 --> 00:37:11,470
of years ago and the thing failed but

00:37:09,550 --> 00:37:14,080
anyway it's going to be new and better

00:37:11,470 --> 00:37:16,810
if we were lucky and maybe it's not so

00:37:14,080 --> 00:37:19,060
compatible so we have that split again

00:37:16,810 --> 00:37:21,100
we have people jumping on the new

00:37:19,060 --> 00:37:22,720
version we have people sticking with the

00:37:21,100 --> 00:37:25,390
old you see the same thing happening

00:37:22,720 --> 00:37:27,460
with Drupal 7 versus Drupal 8 you see

00:37:25,390 --> 00:37:31,090
the same thing happening with Type O 3

00:37:27,460 --> 00:37:32,770
versus the new flow-based version where

00:37:31,090 --> 00:37:34,600
a lot of developers say wow oh p

00:37:32,770 --> 00:37:36,820
domain-driven design cool I'll jump on

00:37:34,600 --> 00:37:39,370
the banquette bandwagon and now let's

00:37:36,820 --> 00:37:42,100
say I'll bet scrap I want to stay with

00:37:39,370 --> 00:37:45,010
my scripting type approach and everybody

00:37:42,100 --> 00:37:48,480
is right with their decisions for what

00:37:45,010 --> 00:37:51,760
they need to do so there is no common

00:37:48,480 --> 00:37:54,550
solution and I think actually we have a

00:37:51,760 --> 00:37:57,760
split in fragmented community so maybe

00:37:54,550 --> 00:38:01,600
that's not even a risk maybe that's even

00:37:57,760 --> 00:38:05,530
a chance because it allows us to move

00:38:01,600 --> 00:38:07,660
forward this basically is exactly what

00:38:05,530 --> 00:38:10,030
the blue elephant stands for whenever

00:38:07,660 --> 00:38:12,940
cool things appear in the IT world

00:38:10,030 --> 00:38:17,550
somebody's sort offs going to adapt that

00:38:12,940 --> 00:38:23,080
into PHP now who's heard about PHP ng

00:38:17,550 --> 00:38:26,400
Wow quite a few that's a PHP next

00:38:23,080 --> 00:38:30,940
generation possibly so Zen

00:38:26,400 --> 00:38:33,250
has invested and they had their one

00:38:30,940 --> 00:38:35,200
peach peak core developer that we know

00:38:33,250 --> 00:38:38,080
of that actually works on the PHP core

00:38:35,200 --> 00:38:40,420
who is fully paid by his end and they

00:38:38,080 --> 00:38:43,930
had him work on some just-in-time

00:38:40,420 --> 00:38:46,660
compilation ideas and some other ideas

00:38:43,930 --> 00:38:48,520
and trying just-in-time compilation out

00:38:46,660 --> 00:38:50,740
they realized oh there's some things in

00:38:48,520 --> 00:38:52,660
the Zen engine that we need to change so

00:38:50,740 --> 00:38:55,060
he came up with a bunch of changes

00:38:52,660 --> 00:38:58,450
saying okay this is PHP in a different

00:38:55,060 --> 00:39:01,830
version have sort of improved it and it

00:38:58,450 --> 00:39:06,940
performs a lot better isn't that awesome

00:39:01,830 --> 00:39:10,300
this is what Facebook has done for us in

00:39:06,940 --> 00:39:12,400
the least the PHP project was urged to

00:39:10,300 --> 00:39:14,590
move forward actually that also happened

00:39:12,400 --> 00:39:16,180
when they released hip hop because

00:39:14,590 --> 00:39:20,230
following the release of hip hop

00:39:16,180 --> 00:39:24,750
we had performance increase in PHP five

00:39:20,230 --> 00:39:29,200
four five five and it was substantial

00:39:24,750 --> 00:39:32,560
they did that as an answer to Facebook

00:39:29,200 --> 00:39:35,050
releasing hip hop and now we potentially

00:39:32,560 --> 00:39:37,150
get PHP next generation whatever that

00:39:35,050 --> 00:39:38,380
may be wherever that ends up however

00:39:37,150 --> 00:39:40,660
that's going to work out that's

00:39:38,380 --> 00:39:43,390
something that the PHP core developers

00:39:40,660 --> 00:39:46,870
need to get clearer about and figure out

00:39:43,390 --> 00:39:49,390
which way to go and what to do but at

00:39:46,870 --> 00:39:52,650
the end of the day in one two or three

00:39:49,390 --> 00:39:56,740
years we will have a platform that's

00:39:52,650 --> 00:39:59,620
substantially faster probably takes

00:39:56,740 --> 00:40:01,810
fewer resources to execute that's the

00:39:59,620 --> 00:40:05,050
cool thing it's not really that

00:40:01,810 --> 00:40:10,180
important whether it's h h vm or whether

00:40:05,050 --> 00:40:12,160
it's PHP that your code runs on the most

00:40:10,180 --> 00:40:15,460
important thing is that the platform

00:40:12,160 --> 00:40:18,130
improves and by having a new kid on the

00:40:15,460 --> 00:40:20,050
block it's like oh um we need to do

00:40:18,130 --> 00:40:21,790
something otherwise people start losing

00:40:20,050 --> 00:40:23,680
interest and everybody's shifting over

00:40:21,790 --> 00:40:29,380
there because that's what are the action

00:40:23,680 --> 00:40:33,210
is so I don't really know what is going

00:40:29,380 --> 00:40:33,210
to happen I couldn't tell

00:40:33,420 --> 00:40:38,309
but I don't think it's that important

00:40:36,000 --> 00:40:40,829
because if you look at it from a code

00:40:38,309 --> 00:40:44,849
perspective you will always have to

00:40:40,829 --> 00:40:47,190
adapt your code to new platforms or to

00:40:44,849 --> 00:40:51,660
changing platforms whether that's PHP

00:40:47,190 --> 00:40:54,000
for to PHP 5 or symphony 2 Symphony 2

00:40:51,660 --> 00:40:56,930
one Symphony 2 - Symphony 2 1 where you

00:40:54,000 --> 00:41:03,299
also had to make changes whether that is

00:40:56,930 --> 00:41:06,510
whatever PHP 5 to PHP next or maybe PHP

00:41:03,299 --> 00:41:09,210
5 to hvm there's going to be a

00:41:06,510 --> 00:41:13,829
transition the cool thing is that most

00:41:09,210 --> 00:41:17,490
of the big projects since um there

00:41:13,829 --> 00:41:21,180
since the tests were run on HTTP em have

00:41:17,490 --> 00:41:24,900
also already started adopting their

00:41:21,180 --> 00:41:26,640
software to hh3m well technically it's

00:41:24,900 --> 00:41:29,040
not a big difference if you do you

00:41:26,640 --> 00:41:32,339
always find that odd switch saying ok in

00:41:29,040 --> 00:41:34,380
PHP 5 3 we'll do it that way from PHP 5

00:41:32,339 --> 00:41:36,750
4 we'll do it that way it's pretty much

00:41:34,380 --> 00:41:38,549
the same is okay if it's HTM then we'll

00:41:36,750 --> 00:41:41,220
do it that way so it's just another

00:41:38,549 --> 00:41:42,990
words introversion switch maybe in one

00:41:41,220 --> 00:41:45,540
or two years we don't even know what is

00:41:42,990 --> 00:41:49,920
running below it's just PHP code that we

00:41:45,540 --> 00:41:52,740
execute and if it performs if it doesn't

00:41:49,920 --> 00:41:57,569
crash probably everybody is really

00:41:52,740 --> 00:41:59,099
really happy so that's for my part I

00:41:57,569 --> 00:42:01,230
think we have a couple of minutes for

00:41:59,099 --> 00:42:04,650
questions it would be eager to hear

00:42:01,230 --> 00:42:07,470
about what your thoughts concerns or

00:42:04,650 --> 00:42:09,990
ideas are if you're involved I would be

00:42:07,470 --> 00:42:11,880
interested in for example I would be

00:42:09,990 --> 00:42:14,400
interested in finding out who's actively

00:42:11,880 --> 00:42:16,290
trying out hhv em and for what purposes

00:42:14,400 --> 00:42:20,579
everybody except Sebastian is allowed to

00:42:16,290 --> 00:42:23,069
answer because with him I know yep I've

00:42:20,579 --> 00:42:27,329
seen some shows of hands who's trying

00:42:23,069 --> 00:42:29,099
out HTTP em can I get some feedback what

00:42:27,329 --> 00:42:32,910
are you guys looking at what are you

00:42:29,099 --> 00:42:33,880
guys trying out just try try that for

00:42:32,910 --> 00:42:37,059
future

00:42:33,880 --> 00:42:40,209
because currently for example my

00:42:37,059 --> 00:42:42,009
location doesn't actually changes a lot

00:42:40,209 --> 00:42:44,680
I can run the same code without and

00:42:42,009 --> 00:42:46,569
eve's and as far as that goes

00:42:44,680 --> 00:42:48,369
everything's fine why not to me just

00:42:46,569 --> 00:42:51,369
anticipate what will happen in the

00:42:48,369 --> 00:42:54,339
future and be ready for it that's it

00:42:51,369 --> 00:42:57,940
there is also a speed improvements very

00:42:54,339 --> 00:43:01,299
noticeable but who knows as HP increases

00:42:57,940 --> 00:43:04,809
like this performance maybe it will be

00:43:01,299 --> 00:43:08,140
equal I don't know so for my part I've

00:43:04,809 --> 00:43:10,150
seen code my code crash a lot on hvm

00:43:08,140 --> 00:43:12,670
because some some features were missing

00:43:10,150 --> 00:43:14,920
but that was a while back and they have

00:43:12,670 --> 00:43:18,130
put in a lot of effort um

00:43:14,920 --> 00:43:20,589
and improved I think there is some

00:43:18,130 --> 00:43:24,910
there's still some extensions that are

00:43:20,589 --> 00:43:27,309
not working properly like like the xml

00:43:24,910 --> 00:43:30,009
stuff and i know a lot of applications

00:43:27,309 --> 00:43:32,680
rely on that so they don't work but on

00:43:30,009 --> 00:43:35,140
the other hand people claim that for

00:43:32,680 --> 00:43:38,920
example as complex software like Magento

00:43:35,140 --> 00:43:49,329
runs on hhg p.m. anybody has anybody any

00:43:38,920 --> 00:43:51,999
experience with that I have much to say

00:43:49,329 --> 00:43:55,690
I just started to do something to the

00:43:51,999 --> 00:43:57,579
people and well looking forward I also

00:43:55,690 --> 00:43:59,979
read some articles in the internet of

00:43:57,579 --> 00:44:01,260
people that managed to do this and some

00:43:59,979 --> 00:44:05,500
measurements

00:44:01,260 --> 00:44:08,170
well it's worth the drive so it but it

00:44:05,500 --> 00:44:12,220
works in the first place well we will

00:44:08,170 --> 00:44:15,390
see okay according to people yes it is

00:44:12,220 --> 00:44:20,020
working so why is something good okay

00:44:15,390 --> 00:44:22,930
anybody else okay then let's open up for

00:44:20,020 --> 00:44:25,960
questions I have a question about well

00:44:22,930 --> 00:44:29,950
we have yesterday we have a session

00:44:25,960 --> 00:44:31,390
about SPL and I have question about well

00:44:29,950 --> 00:44:35,680
as we always thought such an

00:44:31,390 --> 00:44:39,849
undocumented thing in today and what

00:44:35,680 --> 00:44:42,849
about hack in the situation I mean what

00:44:39,849 --> 00:44:46,299
is going on with those who fully own use

00:44:42,849 --> 00:44:50,190
it heavily and how is it working with

00:44:46,299 --> 00:44:52,839
that today on is it going to work very

00:44:50,190 --> 00:44:56,380
good questions so basically the question

00:44:52,839 --> 00:44:58,569
is will SPL work on hack I'm sure it's

00:44:56,380 --> 00:45:00,910
there because it's it's nowadays

00:44:58,569 --> 00:45:04,539
technically an integral part of PHP so

00:45:00,910 --> 00:45:06,069
PHP can't come without SPL and I'm

00:45:04,539 --> 00:45:08,710
pretty sure that they are using it and

00:45:06,069 --> 00:45:12,579
they got it to work whether it really

00:45:08,710 --> 00:45:15,039
works and behaves exactly as PHP in all

00:45:12,579 --> 00:45:16,740
the edge cases I personally don't

00:45:15,039 --> 00:45:20,829
believe that that's technically possible

00:45:16,740 --> 00:45:23,799
I've recently seen a bug regarding the

00:45:20,829 --> 00:45:27,010
Drupal web the Drupal test suite where

00:45:23,799 --> 00:45:30,160
the problem was that h h vm would return

00:45:27,010 --> 00:45:32,740
data with the elements in a different

00:45:30,160 --> 00:45:35,020
order it's technically not a bug but

00:45:32,740 --> 00:45:37,420
it's a different behavior whether that

00:45:35,020 --> 00:45:39,339
leads to a bug in your software because

00:45:37,420 --> 00:45:43,119
you are relying on the order of elements

00:45:39,339 --> 00:45:45,430
that PHP gives you that's a most

00:45:43,119 --> 00:45:48,609
interesting question so I think that

00:45:45,430 --> 00:45:51,069
technically 100% compatibility is not

00:45:48,609 --> 00:45:52,630
really possible but on the other hand

00:45:51,069 --> 00:45:54,760
the question is whether that's whether

00:45:52,630 --> 00:45:56,470
that matters because if you know that

00:45:54,760 --> 00:45:58,690
this is an issue and you sort of

00:45:56,470 --> 00:46:00,819
encapsulate and workaround which a lot

00:45:58,690 --> 00:46:03,520
of the frameworks do all the time look

00:46:00,819 --> 00:46:07,359
at all those this weird workaround for

00:46:03,520 --> 00:46:09,880
that quirky bug pieces of code in

00:46:07,359 --> 00:46:12,369
applications and frameworks and PHP unit

00:46:09,880 --> 00:46:15,599
you can tell a story about that so it's

00:46:12,369 --> 00:46:15,599
a common thing to do that

00:46:34,620 --> 00:46:39,880
to be honest with you I could answer the

00:46:37,360 --> 00:46:42,010
question if I had more than a faint clue

00:46:39,880 --> 00:46:44,350
of what guru back web toolkit actually

00:46:42,010 --> 00:46:47,230
is and does I I don't really know

00:46:44,350 --> 00:47:03,070
anything about that so I don't have the

00:46:47,230 --> 00:47:07,810
data to compare sorry very good question

00:47:03,070 --> 00:47:10,570
is there is there any sort of you're

00:47:07,810 --> 00:47:12,340
looking for guidelines when it makes

00:47:10,570 --> 00:47:15,940
when it might make sense to use hip hop

00:47:12,340 --> 00:47:18,810
right I think I can answer with a

00:47:15,940 --> 00:47:21,640
general answer whenever you ask me a

00:47:18,810 --> 00:47:25,480
performance question you have solution a

00:47:21,640 --> 00:47:29,320
and solution B and which is better I

00:47:25,480 --> 00:47:31,960
will always answer benchmark it in your

00:47:29,320 --> 00:47:34,510
situation because there are very very

00:47:31,960 --> 00:47:37,000
basic things like Auto loading in PHP

00:47:34,510 --> 00:47:40,030
where I've seen people confirm that it's

00:47:37,000 --> 00:47:43,210
slow and then I've seen people confirm

00:47:40,030 --> 00:47:44,890
that it's fast and they are alright in

00:47:43,210 --> 00:47:46,900
their situation it works in their

00:47:44,890 --> 00:47:49,030
situation it doesn't so it's always your

00:47:46,900 --> 00:47:51,640
performance bottleneck in your situation

00:47:49,030 --> 00:47:53,800
the same piece of code in a different

00:47:51,640 --> 00:47:55,450
context might not be a performance

00:47:53,800 --> 00:47:57,100
bottleneck so that's the hard thing

00:47:55,450 --> 00:47:58,690
about performance you can never say okay

00:47:57,100 --> 00:48:01,930
this is a problem and this is the

00:47:58,690 --> 00:48:05,470
solution so what you need to do is just

00:48:01,930 --> 00:48:07,810
install it it's available as an fpm or

00:48:05,470 --> 00:48:10,600
as in Farsi GI module so basically you

00:48:07,810 --> 00:48:14,830
can have a web server running PHP and

00:48:10,600 --> 00:48:17,410
HTML II and you can just try it out and

00:48:14,830 --> 00:48:20,290
see if it works and benchmark it if it's

00:48:17,410 --> 00:48:23,800
faster for you and if it lose it uses a

00:48:20,290 --> 00:48:26,200
lot fewer resources for you then it

00:48:23,800 --> 00:48:27,730
might be an option for you there is no

00:48:26,200 --> 00:48:30,520
general advice as

00:48:27,730 --> 00:48:36,300
who's that because it's quick doesn't

00:48:30,520 --> 00:48:36,300
work there was somebody back there yeah

00:48:37,830 --> 00:48:44,500
savings when using HS p.m. I know that

00:48:42,580 --> 00:48:46,540
there are savings I can't give you

00:48:44,500 --> 00:48:49,890
concrete numbers because I depend on the

00:48:46,540 --> 00:48:54,520
application but I'd say ballpark figure

00:48:49,890 --> 00:48:59,550
20-30 percent Facebook themselves they

00:48:54,520 --> 00:48:59,550
say they say memory of a factor of eight

00:49:02,040 --> 00:49:08,050
yeah if you write the application you

00:49:05,890 --> 00:49:11,320
can optimize the platform for your use

00:49:08,050 --> 00:49:13,150
case that's what makes it very appealing

00:49:11,320 --> 00:49:17,980
for Facebook whether you will be able to

00:49:13,150 --> 00:49:20,260
see the same benefits it's questionable

00:49:17,980 --> 00:49:22,030
I'm not saying it's not possible but

00:49:20,260 --> 00:49:24,420
it's it's very very much dependent on

00:49:22,030 --> 00:49:24,420
your situation

00:49:24,630 --> 00:49:31,359
yeah you are somebody here right and we

00:49:28,450 --> 00:49:34,480
know that were currently not there

00:49:31,359 --> 00:49:36,850
working on a port that's that's what I

00:49:34,480 --> 00:49:39,070
know which is sort of a funny thing

00:49:36,850 --> 00:49:41,650
because Microsoft invested a lot of

00:49:39,070 --> 00:49:44,109
money in making PHP work on Windows as a

00:49:41,650 --> 00:49:46,000
first-class citizen and now the PHP

00:49:44,109 --> 00:49:47,740
world is talking about moving to a

00:49:46,000 --> 00:49:53,130
different platform which basically puts

00:49:47,740 --> 00:49:57,250
Microsoft back on square one I think

00:49:53,130 --> 00:50:00,330
that's sort of an issue topic because

00:49:57,250 --> 00:50:03,310
Facebook just does not run Windows so

00:50:00,330 --> 00:50:06,420
it's not their use case and even if

00:50:03,310 --> 00:50:08,740
somebody makes it work on Windows

00:50:06,420 --> 00:50:10,960
honestly I think if Microsoft doesn't

00:50:08,740 --> 00:50:13,480
jump on the bandwagon and help them do

00:50:10,960 --> 00:50:15,010
that and maybe fund that it's probably

00:50:13,480 --> 00:50:19,150
not going to be a feasible solution

00:50:15,010 --> 00:50:21,340
because as Windows evolves and as h HTM

00:50:19,150 --> 00:50:23,290
or PHP evolves there's always going to

00:50:21,340 --> 00:50:27,430
be quirks we have seen that for many

00:50:23,290 --> 00:50:29,050
years in the PHP project but that may be

00:50:27,430 --> 00:50:31,400
a good incentive of switching from

00:50:29,050 --> 00:50:36,410
Windows to

00:50:31,400 --> 00:50:42,049
just saying there are other different

00:50:36,410 --> 00:50:44,510
the difference between HP where you have

00:50:42,049 --> 00:50:48,460
a lot of additional features basically

00:50:44,510 --> 00:50:51,260
that they say it's PHP plus other stuff

00:50:48,460 --> 00:50:53,000
there's probably some PHP code that

00:50:51,260 --> 00:50:57,200
doesn't work in hack I wouldn't know

00:50:53,000 --> 00:50:59,779
about the details and there's a load of

00:50:57,200 --> 00:51:02,059
new interesting features which basically

00:50:59,779 --> 00:51:06,410
is a completely new and improved

00:51:02,059 --> 00:51:09,410
language based on PHP it's it might

00:51:06,410 --> 00:51:11,359
actually be worth just looking at it to

00:51:09,410 --> 00:51:13,609
find out what is possible and what you

00:51:11,359 --> 00:51:15,140
can do and I think one of the things

00:51:13,609 --> 00:51:16,760
that is going to happen on the longer

00:51:15,140 --> 00:51:18,559
run is that a lot of people look at hack

00:51:16,760 --> 00:51:21,140
and say well that's a cool feature and

00:51:18,559 --> 00:51:23,569
we know that the PHP project has always

00:51:21,140 --> 00:51:25,339
been good at adopting those features if

00:51:23,569 --> 00:51:27,339
there are features out there that people

00:51:25,339 --> 00:51:31,609
love in other languages another platform

00:51:27,339 --> 00:51:32,779
PHP has adopted that so if you wait a

00:51:31,609 --> 00:51:34,670
little you're going to see those

00:51:32,779 --> 00:51:38,750
features or part of those features in

00:51:34,670 --> 00:51:41,720
PHP maybe if not well maybe then that's

00:51:38,750 --> 00:51:43,760
the reason for you to switch over to use

00:51:41,720 --> 00:51:45,920
hhtv mmm if you say oh those are cool

00:51:43,760 --> 00:51:48,940
features and I absolutely need them to

00:51:45,920 --> 00:51:50,750
write my software in a decent way I

00:51:48,940 --> 00:51:53,359
think one last question

00:51:50,750 --> 00:51:56,869
yogi considering that now you'll have a

00:51:53,359 --> 00:51:59,119
kind of compiled language is it possible

00:51:56,869 --> 00:52:01,670
to make libraries from another languages

00:51:59,119 --> 00:52:07,130
let's say I have a chance to create

00:52:01,670 --> 00:52:10,339
something very high yes and that's

00:52:07,130 --> 00:52:12,380
that's a you can write extension in PHP

00:52:10,339 --> 00:52:16,220
and you have a native interface that

00:52:12,380 --> 00:52:20,390
allows you to call native functions from

00:52:16,220 --> 00:52:22,940
PHP this is outrageously cool because in

00:52:20,390 --> 00:52:26,119
PHP you need to write C code to do that

00:52:22,940 --> 00:52:28,490
but now you could do it in PHP code

00:52:26,119 --> 00:52:29,619
sometimes you need for performance right

00:52:28,490 --> 00:52:31,839
means

00:52:29,619 --> 00:52:36,609
that you can write your extension in HP

00:52:31,839 --> 00:52:47,650
and then use special syntax to call into

00:52:36,609 --> 00:52:50,529
native libraries and and honestly just

00:52:47,650 --> 00:52:53,019
to give you an idea if that is something

00:52:50,529 --> 00:52:56,650
that you need I would actually consider

00:52:53,019 --> 00:52:59,769
just deploying hh3m to run one service

00:52:56,650 --> 00:53:02,380
in your company that allows you to write

00:52:59,769 --> 00:53:05,740
PHP code to dig into those libraries and

00:53:02,380 --> 00:53:08,769
benefit from them and the rest can still

00:53:05,740 --> 00:53:12,160
be PHP and you'll have to talk to that

00:53:08,769 --> 00:53:16,690
service over the wire so that's a lot of

00:53:12,160 --> 00:53:24,519
potential I think yeah I hope so

00:53:16,690 --> 00:53:27,970
okay fell asleep so there we go these

00:53:24,519 --> 00:53:30,460
are some resources that you can look

00:53:27,970 --> 00:53:34,210
basically it's hack it's hhtv m and it's

00:53:30,460 --> 00:53:35,680
the wiki page of PHP mg and this is how

00:53:34,210 --> 00:53:38,559
you can reach me if you have any further

00:53:35,680 --> 00:53:42,779
questions drop me a line thanks for

00:53:38,559 --> 00:53:42,779

YouTube URL: https://www.youtube.com/watch?v=fxHEuOXdCP0


