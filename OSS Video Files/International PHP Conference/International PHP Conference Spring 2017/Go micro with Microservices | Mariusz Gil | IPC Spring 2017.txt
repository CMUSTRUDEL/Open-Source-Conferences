Title: Go micro with Microservices | Mariusz Gil | IPC Spring 2017
Publication date: 2019-01-23
Playlist: International PHP Conference Spring 2017
Description: 
	Mariusz Gil (Source Ministry): Microservices … New architectural style oriented on splitting monolithic codebase into set of small and independent applications built around specific business needs. Microservices might be very useful in some situations, but they also can introduce set of new problems to be solved, from designing to communication between microservices in production environment. During this session I’m going to introduce core concepts of microservices architecture, possible implementations using PHP, deployment strategies and running application in production environment. You will learn also about patterns in microservices world, building blocks for your next complex projects … All topics will be presented in code, on real PHP 7 application powered by microservices.
Captions: 
	00:00:03,180 --> 00:00:09,450
[Music]

00:00:05,899 --> 00:00:11,550
okay so I think you can start thank you

00:00:09,450 --> 00:00:13,290
very much for choosing this session I'm

00:00:11,550 --> 00:00:16,440
a little bit surprised it's so many

00:00:13,290 --> 00:00:20,130
someone I love you choose this micro

00:00:16,440 --> 00:00:23,550
service talk because micro-service PHP

00:00:20,130 --> 00:00:26,609
application did just PHP application but

00:00:23,550 --> 00:00:29,779
smaller so my name is Marc Gill and

00:00:26,609 --> 00:00:32,700
today I would like to share some

00:00:29,779 --> 00:00:36,510
concepts some topics related to the

00:00:32,700 --> 00:00:41,480
micro services ecosystem at topics we

00:00:36,510 --> 00:00:46,039
have to care about but usually we didn't

00:00:41,480 --> 00:00:49,289
know nothing about them so don't expect

00:00:46,039 --> 00:00:51,239
implementation details such as PHP

00:00:49,289 --> 00:00:53,399
application is just microservice speech

00:00:51,239 --> 00:00:54,870
gratification is a just standard PHP

00:00:53,399 --> 00:00:57,809
application just need it's smaller

00:00:54,870 --> 00:01:00,960
faster but expect some more concept

00:00:57,809 --> 00:01:03,750
around the micro services top PC need to

00:01:00,960 --> 00:01:06,090
really really care about them so on the

00:01:03,750 --> 00:01:08,280
daily basis I'm working in my company

00:01:06,090 --> 00:01:11,400
which is a source ministry it's a PHP

00:01:08,280 --> 00:01:14,490
consultancy shop so I'm working with

00:01:11,400 --> 00:01:17,759
different teams on Agassi software on

00:01:14,490 --> 00:01:20,880
architecture trying to make our project

00:01:17,759 --> 00:01:23,640
a little bit better so I'm also the part

00:01:20,880 --> 00:01:27,420
one of the founder of peach Pierre's pH

00:01:23,640 --> 00:01:31,439
peers polish network of PHP developers

00:01:27,420 --> 00:01:33,930
so all PHP user groups in Poland are

00:01:31,439 --> 00:01:36,509
working together under this branch so

00:01:33,930 --> 00:01:39,329
this is really really really really

00:01:36,509 --> 00:01:43,890
funny funny stuff for me to be a part of

00:01:39,329 --> 00:01:46,290
PHP as community so the story the

00:01:43,890 --> 00:01:49,500
standout story about the micro services

00:01:46,290 --> 00:01:52,860
I've got a lot of my stories how we can

00:01:49,500 --> 00:01:54,720
move or what kind of operations we

00:01:52,860 --> 00:01:57,899
should apply to make our application

00:01:54,720 --> 00:02:01,280
better couple years ago I was working as

00:01:57,899 --> 00:02:03,600
a city or in Warsaw on

00:02:01,280 --> 00:02:07,369
I'm a really really interesting software

00:02:03,600 --> 00:02:10,470
it was PHP application dedicated to

00:02:07,369 --> 00:02:13,790
generating recommendations over the

00:02:10,470 --> 00:02:16,430
Internet we had a lot of widgets

00:02:13,790 --> 00:02:19,700
across most popular websites in Poland

00:02:16,430 --> 00:02:23,480
and all the traffic from these popular

00:02:19,700 --> 00:02:26,260
websites hated our application and will

00:02:23,480 --> 00:02:29,290
try to analyze this traffic try to

00:02:26,260 --> 00:02:32,720
generate very very personalized

00:02:29,290 --> 00:02:35,299
recommendations what kind of other what

00:02:32,720 --> 00:02:38,090
kind of other web pages or what kind of

00:02:35,299 --> 00:02:41,239
other advertisements you should visit

00:02:38,090 --> 00:02:44,420
you should click just to any money so we

00:02:41,239 --> 00:02:49,430
started from Symphony application it was

00:02:44,420 --> 00:02:53,000
one point for very very old stuff and in

00:02:49,430 --> 00:02:55,790
just one week after the seven days for

00:02:53,000 --> 00:03:00,379
the first deployment we hit at 1 million

00:02:55,790 --> 00:03:05,419
pageviews so it was from this traffic

00:03:00,379 --> 00:03:10,099
was generated by one client so in every

00:03:05,419 --> 00:03:15,470
single week every single few days we

00:03:10,099 --> 00:03:18,139
collected more and more traffic so after

00:03:15,470 --> 00:03:21,949
one year we had a lot of traffic we had

00:03:18,139 --> 00:03:25,040
out of servers on AWS cloud because this

00:03:21,949 --> 00:03:27,769
was one of our requirement we had to be

00:03:25,040 --> 00:03:30,560
very very scalable so we introduced a

00:03:27,769 --> 00:03:35,900
puppet to our infrastructure we used the

00:03:30,560 --> 00:03:39,709
the AWS API to create images of our

00:03:35,900 --> 00:03:42,019
servers we had some scalars of course

00:03:39,709 --> 00:03:45,049
some one world works as well so we had

00:03:42,019 --> 00:03:49,299
to scale up with our application but the

00:03:45,049 --> 00:03:53,090
problem with this software was it was

00:03:49,299 --> 00:03:56,449
just a monolith very very monolithic

00:03:53,090 --> 00:04:00,889
application but this application was

00:03:56,449 --> 00:04:06,579
composed with different elements we had

00:04:00,889 --> 00:04:09,439
some trackers we had had some widgets

00:04:06,579 --> 00:04:11,079
displayed over the Internet we had some

00:04:09,439 --> 00:04:14,659
processing player on our application

00:04:11,079 --> 00:04:16,849
data storage is tunnels for users for

00:04:14,659 --> 00:04:20,720
admins a lot of background processes and

00:04:16,849 --> 00:04:24,020
so on and so and so on so we had of

00:04:20,720 --> 00:04:26,430
course some developers we had some

00:04:24,020 --> 00:04:30,930
administrators working on this

00:04:26,430 --> 00:04:33,900
monolithic application and realized okay

00:04:30,930 --> 00:04:37,380
it's not it's not the best situation for

00:04:33,900 --> 00:04:40,170
us because every single time when we

00:04:37,380 --> 00:04:43,730
would like to scale up our software

00:04:40,170 --> 00:04:47,790
there's only one single way to do this

00:04:43,730 --> 00:04:51,780
we had to take our software all the

00:04:47,790 --> 00:04:54,630
packages and just create another set of

00:04:51,780 --> 00:04:59,010
instances running exactly the same

00:04:54,630 --> 00:05:02,070
software for all the components I

00:04:59,010 --> 00:05:02,780
mentioned there were only one or maybe

00:05:02,070 --> 00:05:07,710
two Oh

00:05:02,780 --> 00:05:09,390
which should be scalable is it really to

00:05:07,710 --> 00:05:14,870
be very very important to have a

00:05:09,390 --> 00:05:19,640
scalable admin panel really is it

00:05:14,870 --> 00:05:23,280
mandatory to have a scalable user panel

00:05:19,640 --> 00:05:28,560
our user our business user clients it

00:05:23,280 --> 00:05:32,910
was 2,000 people maybe our customers are

00:05:28,560 --> 00:05:37,020
our users for our software I mean the

00:05:32,910 --> 00:05:39,630
users which our process were processes

00:05:37,020 --> 00:05:40,950
by our rigid and our software yeah it

00:05:39,630 --> 00:05:43,740
was a millions of them

00:05:40,950 --> 00:05:47,190
so from all this stock from our

00:05:43,740 --> 00:05:49,500
applications only two elements I mean

00:05:47,190 --> 00:05:51,030
the the the the layer responsible for

00:05:49,500 --> 00:05:53,580
delivering the recommendations and

00:05:51,030 --> 00:05:55,340
generating recommendations yet this

00:05:53,580 --> 00:05:58,440
elements should be very very scalable

00:05:55,340 --> 00:06:01,170
but unfortunately there were part of

00:05:58,440 --> 00:06:03,300
this monolithic application so every

00:06:01,170 --> 00:06:06,360
single family who would like to increase

00:06:03,300 --> 00:06:08,850
our capacity so we had to scale up all

00:06:06,360 --> 00:06:11,520
the processes all the all the background

00:06:08,850 --> 00:06:14,640
applications and so on so and so so the

00:06:11,520 --> 00:06:19,740
problem was what was the reason for this

00:06:14,640 --> 00:06:23,400
problem I think very very bad design at

00:06:19,740 --> 00:06:26,240
the beginning because sometimes before

00:06:23,400 --> 00:06:30,780
we apply a real TDD we should think

00:06:26,240 --> 00:06:33,030
design and then develop if we were able

00:06:30,780 --> 00:06:34,350
to identify ok this is a part

00:06:33,030 --> 00:06:36,840
application which should be very very

00:06:34,350 --> 00:06:38,760
scalable so we should extract

00:06:36,840 --> 00:06:41,190
the software this part of the software

00:06:38,760 --> 00:06:43,770
for the main base maybe to another

00:06:41,190 --> 00:06:46,440
repository another deployment processes

00:06:43,770 --> 00:06:49,440
and other servers to make it really

00:06:46,440 --> 00:06:52,650
really scalable and this is a standard

00:06:49,440 --> 00:06:56,580
story behind the micro services when you

00:06:52,650 --> 00:06:58,199
need to scale up or if you need to move

00:06:56,580 --> 00:07:01,440
really really fast and don't break the

00:06:58,199 --> 00:07:04,470
things so the standard approach of

00:07:01,440 --> 00:07:06,600
monolithic systems not play so well so

00:07:04,470 --> 00:07:10,650
this is a place where we can introduce

00:07:06,600 --> 00:07:15,800
the micro services oh my god Services is

00:07:10,650 --> 00:07:18,240
not so old stuff 2014 maybe 2000

00:07:15,800 --> 00:07:21,570
beginning of the thousand fourteen the

00:07:18,240 --> 00:07:24,930
micro services term explodes right and

00:07:21,570 --> 00:07:27,180
right now we had a lot of micro services

00:07:24,930 --> 00:07:30,860
frameworks a lot of micro services talk

00:07:27,180 --> 00:07:34,740
as the micro Frances etcetera etcetera

00:07:30,860 --> 00:07:37,680
but very very first stage of the

00:07:34,740 --> 00:07:40,500
microscope this explosion was about only

00:07:37,680 --> 00:07:43,440
and only about the good stuff about the

00:07:40,500 --> 00:07:48,630
micro services the micro services will

00:07:43,440 --> 00:07:51,600
help you yes of course sometimes but

00:07:48,630 --> 00:07:54,630
sometimes there are also a hidden part

00:07:51,600 --> 00:07:56,550
of the micro services echo system so

00:07:54,630 --> 00:07:58,860
let's start from the beginning what it's

00:07:56,550 --> 00:08:01,380
the micro services those are the micro

00:07:58,860 --> 00:08:04,530
services from the audience wrote from

00:08:01,380 --> 00:08:07,440
Rochefort one of the mentors from this

00:08:04,530 --> 00:08:10,160
area it's a perfect definition it's a

00:08:07,440 --> 00:08:12,660
loosely coupled service-oriented

00:08:10,160 --> 00:08:15,060
architecture we've bounded context and

00:08:12,660 --> 00:08:16,770
every single bounded context should be

00:08:15,060 --> 00:08:19,860
completely independent from the other

00:08:16,770 --> 00:08:23,849
software so if you've got this kind of

00:08:19,860 --> 00:08:27,090
design in your software you can probably

00:08:23,849 --> 00:08:30,030
scale up only few bounded concepts you

00:08:27,090 --> 00:08:34,260
really need to scale up so instead of

00:08:30,030 --> 00:08:36,419
scoring all the system you can just pick

00:08:34,260 --> 00:08:40,830
one of them one of the elements and

00:08:36,419 --> 00:08:44,250
scale up and of course you can model

00:08:40,830 --> 00:08:47,250
your silos you can model your workflows

00:08:44,250 --> 00:08:48,350
you can mix people working from the

00:08:47,250 --> 00:08:52,640
micro service

00:08:48,350 --> 00:08:55,580
and create a very very white competence

00:08:52,640 --> 00:08:57,740
team responsible for running designing

00:08:55,580 --> 00:09:01,010
operating and maintaining micro services

00:08:57,740 --> 00:09:02,990
as they look like amazin yeah and then

00:09:01,010 --> 00:09:05,630
you've got the situation when you have a

00:09:02,990 --> 00:09:11,350
possibilities to almost unlimited

00:09:05,630 --> 00:09:15,710
scale-up but the idea of micro services

00:09:11,350 --> 00:09:21,350
is very very simple and problematic at

00:09:15,710 --> 00:09:24,140
the same time so we've got the separated

00:09:21,350 --> 00:09:26,480
part of the software completely may be

00:09:24,140 --> 00:09:28,220
completely independent in the context of

00:09:26,480 --> 00:09:31,220
the technology from the other elements

00:09:28,220 --> 00:09:35,210
of the software at the same time each

00:09:31,220 --> 00:09:38,900
micro service may use a dedicated should

00:09:35,210 --> 00:09:42,920
use may should use sorry should use a

00:09:38,900 --> 00:09:47,330
dedicated data store with data needed to

00:09:42,920 --> 00:09:49,790
run this service so if you've got ten

00:09:47,330 --> 00:09:54,530
micro services it's probably means that

00:09:49,790 --> 00:09:57,980
you've got ten data stores do you see

00:09:54,530 --> 00:10:01,670
any problem here okay so if this is

00:09:57,980 --> 00:10:03,890
let's say a micro service dedicated to

00:10:01,670 --> 00:10:06,440
serving a user data okay so this is

00:10:03,890 --> 00:10:11,060
probably sequel database maybe just one

00:10:06,440 --> 00:10:14,980
table just users serving your data's if

00:10:11,060 --> 00:10:18,920
this is a micro service dedicated to

00:10:14,980 --> 00:10:20,960
generating recommendations if you've got

00:10:18,920 --> 00:10:23,330
the user you've got information who is

00:10:20,960 --> 00:10:26,650
following who let's say we are talking

00:10:23,330 --> 00:10:30,080
about the social network application a

00:10:26,650 --> 00:10:32,330
sequel database in this place maybe not

00:10:30,080 --> 00:10:34,970
the best solution to the solution maybe

00:10:32,330 --> 00:10:38,150
a graph database or other new sequel

00:10:34,970 --> 00:10:40,250
database will be a little bit better so

00:10:38,150 --> 00:10:42,800
but this is a completely different data

00:10:40,250 --> 00:10:45,020
store and this is probably another

00:10:42,800 --> 00:10:52,520
completely different datastore maybe

00:10:45,020 --> 00:10:55,070
sequel maybe not so the benefit from the

00:10:52,520 --> 00:10:57,950
micro services is you can scale up on

00:10:55,070 --> 00:11:01,310
the dis element it's fine but what about

00:10:57,950 --> 00:11:02,000
the data what about the data if a new

00:11:01,310 --> 00:11:04,070
use

00:11:02,000 --> 00:11:06,350
or new data arrived to this micro

00:11:04,070 --> 00:11:08,510
service all other elements all other

00:11:06,350 --> 00:11:14,780
micro services should be informed okay

00:11:08,510 --> 00:11:18,230
we've got the new data so it means that

00:11:14,780 --> 00:11:22,150
at least we should have a layer for data

00:11:18,230 --> 00:11:25,850
synchronization bunch of micro services

00:11:22,150 --> 00:11:27,520
upon a single shared database it's a

00:11:25,850 --> 00:11:29,780
receipt for the failure always

00:11:27,520 --> 00:11:31,490
integrations through the databases is

00:11:29,780 --> 00:11:34,580
received for the failures no question

00:11:31,490 --> 00:11:37,310
about it so what kind of solutions and

00:11:34,580 --> 00:11:39,520
what kind of patterns we can apply to

00:11:37,310 --> 00:11:42,680
synchronize at different data stores

00:11:39,520 --> 00:11:46,400
okay so today we've got the solutions

00:11:42,680 --> 00:11:49,820
like RabbitMQ events and this is

00:11:46,400 --> 00:11:52,160
probably one of the best idea to execute

00:11:49,820 --> 00:11:53,960
and introduce to our system if something

00:11:52,160 --> 00:11:56,600
was happened in the one micro-service

00:11:53,960 --> 00:12:00,230
okay so event was fired due to the bus

00:11:56,600 --> 00:12:03,230
let's say the RabbitMQ or other

00:12:00,230 --> 00:12:06,050
solutions there are plenty of them on

00:12:03,230 --> 00:12:08,839
the market and then all the other micro

00:12:06,050 --> 00:12:13,600
services may react might introduce this

00:12:08,839 --> 00:12:18,170
value to the same the private storage

00:12:13,600 --> 00:12:21,470
it's fine try to use try to use or try

00:12:18,170 --> 00:12:27,200
to execute a transaction it's very very

00:12:21,470 --> 00:12:32,270
problematic the another thing really

00:12:27,200 --> 00:12:36,470
really hard is about the integration if

00:12:32,270 --> 00:12:40,360
we've got 100 micro services and 100

00:12:36,470 --> 00:12:40,360
micro services is very very small number

00:12:41,350 --> 00:12:46,370
there are huge projects were the overall

00:12:43,850 --> 00:12:50,600
number of micro services is counted with

00:12:46,370 --> 00:12:53,720
thousands so how we can integrate how we

00:12:50,600 --> 00:12:56,360
can provide the the feedback or the

00:12:53,720 --> 00:12:58,840
output from the application to our users

00:12:56,360 --> 00:13:01,969
so smooth demo

00:12:58,840 --> 00:13:01,969
[Music]

00:13:05,279 --> 00:13:13,660
this is a small PHP application part of

00:13:09,130 --> 00:13:14,970
the production base but few

00:13:13,660 --> 00:13:17,890
microservices

00:13:14,970 --> 00:13:19,709
were collected and composed into small

00:13:17,890 --> 00:13:23,019
application this is just a demo

00:13:19,709 --> 00:13:25,410
how many micro services do you see or it

00:13:23,019 --> 00:13:29,529
you can recognize on this on this

00:13:25,410 --> 00:13:33,459
webpage this is a small homepage where

00:13:29,529 --> 00:13:37,060
there is some randomly taken texts here

00:13:33,459 --> 00:13:39,190
and here this is a hard-coded header and

00:13:37,060 --> 00:13:39,730
this is a current action maybe not

00:13:39,190 --> 00:13:41,800
current

00:13:39,730 --> 00:13:44,070
this is exchange rate from the March

00:13:41,800 --> 00:13:47,649
from the National Bank of the Poland

00:13:44,070 --> 00:13:50,290
current rates for some for some

00:13:47,649 --> 00:13:54,339
currencies how many micro services do

00:13:50,290 --> 00:13:55,510
you see free why free which is first

00:13:54,339 --> 00:14:04,470
this is because this is probably the one

00:13:55,510 --> 00:14:09,279
this is the second and the first one was

00:14:04,470 --> 00:14:13,779
translations of course you don't see the

00:14:09,279 --> 00:14:16,810
the code so this is some cheating about

00:14:13,779 --> 00:14:18,550
the Darfur micro-services here one for

00:14:16,810 --> 00:14:20,649
the text one for the actions render it

00:14:18,550 --> 00:14:24,310
there is no translation but there are

00:14:20,649 --> 00:14:27,910
two more microservices the one is

00:14:24,310 --> 00:14:31,360
responsible for sending information how

00:14:27,910 --> 00:14:33,910
this page looks like what kind of other

00:14:31,360 --> 00:14:37,240
micro services are embedded on this

00:14:33,910 --> 00:14:40,110
webpage and there's the last one which

00:14:37,240 --> 00:14:43,120
is the first behind the web server

00:14:40,110 --> 00:14:46,570
responsible for merging all the data all

00:14:43,120 --> 00:14:50,070
the HTML is sending this information to

00:14:46,570 --> 00:14:53,589
the client so all all of them were

00:14:50,070 --> 00:14:59,079
implemented in PHP with Silex so select

00:14:53,589 --> 00:15:01,990
small web server web framework but one

00:14:59,079 --> 00:15:06,940
of them is really really slow as you see

00:15:01,990 --> 00:15:12,000
I reloaded the page so it took less than

00:15:06,940 --> 00:15:12,000
2 seconds to render the page so

00:15:12,940 --> 00:15:19,760
another possible problem how to identify

00:15:16,280 --> 00:15:22,340
the issues in the micro service world if

00:15:19,760 --> 00:15:24,200
your application is composed from 200

00:15:22,340 --> 00:15:30,590
micro services and one is very very

00:15:24,200 --> 00:15:35,180
problematic which one speaking about the

00:15:30,590 --> 00:15:40,930
integration this is a part of Amazon

00:15:35,180 --> 00:15:46,850
website and you see few micro services

00:15:40,930 --> 00:15:50,710
just few they have thousands each one of

00:15:46,850 --> 00:15:55,160
them must be very very fast maybe some

00:15:50,710 --> 00:15:58,060
some other maybe some of them are

00:15:55,160 --> 00:16:02,320
composed from the other micro services

00:15:58,060 --> 00:16:06,290
and if you would like to introduce a

00:16:02,320 --> 00:16:09,410
result to the to the user you've got a

00:16:06,290 --> 00:16:12,620
lot of options this one is called UI

00:16:09,410 --> 00:16:16,790
composition each micro service may

00:16:12,620 --> 00:16:21,110
render some UI with HTML with CSS at

00:16:16,790 --> 00:16:25,490
authority sera and one layer in your

00:16:21,110 --> 00:16:29,530
application using ESI at the thigh Ajax

00:16:25,490 --> 00:16:32,690
iframe whatever should compose this UI

00:16:29,530 --> 00:16:37,190
into the single web page and then react

00:16:32,690 --> 00:16:39,740
to that send this output to the to the

00:16:37,190 --> 00:16:42,260
customer so there are a bunch of

00:16:39,740 --> 00:16:45,470
solutions you can apply if you are using

00:16:42,260 --> 00:16:47,540
sei you can use a varnish which is very

00:16:45,470 --> 00:16:50,480
very fancy solutions you can use

00:16:47,540 --> 00:16:52,460
composure composure is a middleware can

00:16:50,480 --> 00:16:56,740
put micro service composition middle or

00:16:52,460 --> 00:17:00,320
for express so no js' but we can compose

00:16:56,740 --> 00:17:04,510
micro services generated by the and PHP

00:17:00,320 --> 00:17:07,490
stock so using this kind of composition

00:17:04,510 --> 00:17:11,630
for micro services for example using

00:17:07,490 --> 00:17:15,050
composure you can introduce some models

00:17:11,630 --> 00:17:19,130
in your HTML there are let's say this is

00:17:15,050 --> 00:17:21,170
a part of this is the first widget in

00:17:19,130 --> 00:17:24,160
separated files of course this is a

00:17:21,170 --> 00:17:26,710
second Regent but this widget

00:17:24,160 --> 00:17:28,930
should embed another micro service and

00:17:26,710 --> 00:17:31,630
this is a puff where this micro service

00:17:28,930 --> 00:17:34,560
is available so then we've got the whole

00:17:31,630 --> 00:17:38,050
webpage where the other micro services

00:17:34,560 --> 00:17:41,830
are connected so every single time where

00:17:38,050 --> 00:17:44,830
the request hits a web server web server

00:17:41,830 --> 00:17:48,580
asked the the middleware for composition

00:17:44,830 --> 00:17:51,490
hey compose this URL for me and this

00:17:48,580 --> 00:17:53,920
application will resolve all the micro

00:17:51,490 --> 00:17:56,500
services all the applications behind

00:17:53,920 --> 00:17:59,920
will be executed and the output will be

00:17:56,500 --> 00:18:03,640
collected and of course this is very

00:17:59,920 --> 00:18:05,740
very very very tiny implementation

00:18:03,640 --> 00:18:08,980
because I composure is very very complex

00:18:05,740 --> 00:18:12,330
software this is only one of possible

00:18:08,980 --> 00:18:16,630
solution we can apply so we can cache

00:18:12,330 --> 00:18:18,730
output because this is HD ap layer so we

00:18:16,630 --> 00:18:21,910
can use headers for caching at as

00:18:18,730 --> 00:18:24,400
artists artists are so UI composition is

00:18:21,910 --> 00:18:28,000
just one possible solution and there is

00:18:24,400 --> 00:18:33,130
a huge huge software in Poland which is

00:18:28,000 --> 00:18:34,660
built around this pattern if you've got

00:18:33,130 --> 00:18:37,620
a lot of micro services in your

00:18:34,660 --> 00:18:41,260
ecosystem and you would like to expose

00:18:37,620 --> 00:18:44,050
maybe a more advanced interface for user

00:18:41,260 --> 00:18:48,460
ok so you can apply another button

00:18:44,050 --> 00:18:50,800
called API gateway you can have a lot of

00:18:48,460 --> 00:18:53,290
my cursor visit all the fleet of micro

00:18:50,800 --> 00:18:55,770
services running different databases

00:18:53,290 --> 00:18:59,940
versus all in different technologies and

00:18:55,770 --> 00:19:05,550
above them you can expose another

00:18:59,940 --> 00:19:10,470
service every single request to your API

00:19:05,550 --> 00:19:13,960
will be transform it into series of

00:19:10,470 --> 00:19:17,800
requests to your micro services and the

00:19:13,960 --> 00:19:20,680
API gateway will wait for the responses

00:19:17,800 --> 00:19:25,270
compose them into the single response

00:19:20,680 --> 00:19:27,670
and sent to the client so if you are

00:19:25,270 --> 00:19:30,880
using Amazon there is a software for

00:19:27,670 --> 00:19:32,470
that on AWS cloud if you are using your

00:19:30,880 --> 00:19:34,510
software of course in your

00:19:32,470 --> 00:19:36,490
infrastructure you can write the API

00:19:34,510 --> 00:19:37,580
gateway on your own you can use for

00:19:36,490 --> 00:19:40,640
example engine plan

00:19:37,580 --> 00:19:50,120
so another set of solutions another set

00:19:40,640 --> 00:19:52,549
of possible tools to use or you can use

00:19:50,120 --> 00:19:56,419
just beckoned for differences if you've

00:19:52,549 --> 00:19:59,419
got let's say I reach a single page

00:19:56,419 --> 00:20:01,940
application running on the react or

00:19:59,419 --> 00:20:05,409
angular so you can power your

00:20:01,940 --> 00:20:11,779
application with just JSON or rest

00:20:05,409 --> 00:20:15,380
restful micro services so about the

00:20:11,779 --> 00:20:18,799
structuring do you think is it easy to

00:20:15,380 --> 00:20:22,880
split an application between the marker

00:20:18,799 --> 00:20:28,130
services what do you think is it easier

00:20:22,880 --> 00:20:32,360
or not it's really really hard why why

00:20:28,130 --> 00:20:36,970
not not easy you've got the right

00:20:32,360 --> 00:20:40,760
because if you've got your application

00:20:36,970 --> 00:20:43,309
separated into the dedicated and small

00:20:40,760 --> 00:20:46,940
applications the Microsoft one of the

00:20:43,309 --> 00:20:49,580
micro services requirement that there is

00:20:46,940 --> 00:20:52,100
no dependency between the micro services

00:20:49,580 --> 00:20:54,320
if there is no dependence between micro

00:20:52,100 --> 00:20:58,090
services it means that you should be

00:20:54,320 --> 00:21:01,820
able to deploy them in the random order

00:20:58,090 --> 00:21:03,830
if there is a specific order in your

00:21:01,820 --> 00:21:07,490
application and there is a specific

00:21:03,830 --> 00:21:09,950
order in your deployment processes why

00:21:07,490 --> 00:21:13,039
this software was divided in this way

00:21:09,950 --> 00:21:14,990
probably it will be much much easier to

00:21:13,039 --> 00:21:17,480
combine everything in the monolithic

00:21:14,990 --> 00:21:20,299
application and believe me sometimes

00:21:17,480 --> 00:21:23,419
it's much better to have a monolithic

00:21:20,299 --> 00:21:25,820
application because there is no such

00:21:23,419 --> 00:21:30,830
thing like that Microsoft but but

00:21:25,820 --> 00:21:33,110
monolith why because what the monolith

00:21:30,830 --> 00:21:36,110
are not so bad because you've got

00:21:33,110 --> 00:21:38,830
everything in single single application

00:21:36,110 --> 00:21:43,429
you can use memory to share your data

00:21:38,830 --> 00:21:46,340
the problem with the monolith is that

00:21:43,429 --> 00:21:48,490
monoliths are usually very very bad

00:21:46,340 --> 00:21:50,680
design

00:21:48,490 --> 00:21:54,010
even if your application is very very

00:21:50,680 --> 00:21:56,860
complex even if your application have a

00:21:54,010 --> 00:21:59,260
lot of different bonded contexts you can

00:21:56,860 --> 00:22:00,970
use a little a lot of different testings

00:21:59,260 --> 00:22:05,500
like domain driven design or bounded

00:22:00,970 --> 00:22:09,880
context to split to split your software

00:22:05,500 --> 00:22:12,910
into the models organize your code base

00:22:09,880 --> 00:22:17,080
into the models where every single model

00:22:12,910 --> 00:22:19,690
is communicating with other models we

00:22:17,080 --> 00:22:23,590
are the memory the other the rabbitmq or

00:22:19,690 --> 00:22:28,030
whatever but you've got the single code

00:22:23,590 --> 00:22:31,990
base easy to deploy easy to manage but

00:22:28,030 --> 00:22:34,960
if you decide to split your application

00:22:31,990 --> 00:22:40,680
into the into the micro services you

00:22:34,960 --> 00:22:44,200
need to care at least for the to link

00:22:40,680 --> 00:22:47,170
configuration service discovery editor

00:22:44,200 --> 00:22:50,710
editor at the surra if you know at least

00:22:47,170 --> 00:22:55,030
one tool you can use for every single

00:22:50,710 --> 00:23:00,460
topic yeah I think you can then you can

00:22:55,030 --> 00:23:04,090
then you are ready to start a micro

00:23:00,460 --> 00:23:07,300
service development if not you will

00:23:04,090 --> 00:23:12,130
probably stuck with some problems not

00:23:07,300 --> 00:23:20,050
now but later and let me show you an

00:23:12,130 --> 00:23:24,940
example if you've got let's say a bunch

00:23:20,050 --> 00:23:28,510
of micro services responsible for let's

00:23:24,940 --> 00:23:32,830
say for media transcoding where they're

00:23:28,510 --> 00:23:34,660
located if you are using the cloud where

00:23:32,830 --> 00:23:37,930
are your micro services where they are

00:23:34,660 --> 00:23:42,250
located how your application may touch

00:23:37,930 --> 00:23:46,090
your micro services if you are if you

00:23:42,250 --> 00:23:50,440
start up let's say 20 more instances for

00:23:46,090 --> 00:23:56,590
this service how the application should

00:23:50,440 --> 00:23:59,050
get them so service discovery or maybe

00:23:56,590 --> 00:24:01,960
some some configuration management so

00:23:59,050 --> 00:24:04,390
unfortunately for every single box

00:24:01,960 --> 00:24:09,370
a bunch of solutions a bunch of

00:24:04,390 --> 00:24:12,340
techniques usually tools which will be

00:24:09,370 --> 00:24:20,380
very very helpful to run your micro

00:24:12,340 --> 00:24:23,380
service cluster and every single box is

00:24:20,380 --> 00:24:28,809
needed to run a professional-grade

00:24:23,380 --> 00:24:33,220
application in my city in Rostov there

00:24:28,809 --> 00:24:37,029
is a company which is very very happy to

00:24:33,220 --> 00:24:40,570
work with a huge platform responsible

00:24:37,029 --> 00:24:43,510
for connecting the the other companies

00:24:40,570 --> 00:24:45,190
it's a huge business by the way but the

00:24:43,510 --> 00:24:47,200
problem is that they stuck with

00:24:45,190 --> 00:24:51,360
monolithic application and then decided

00:24:47,200 --> 00:24:55,240
to move out the micro services world but

00:24:51,360 --> 00:25:00,100
instead of hooray method and

00:24:55,240 --> 00:25:03,940
implementation they spent six month to

00:25:00,100 --> 00:25:06,159
just prepare as development process and

00:25:03,940 --> 00:25:11,230
all the processes around the micro

00:25:06,159 --> 00:25:16,210
services to prepare a just skeleton they

00:25:11,230 --> 00:25:18,909
spent so much time on the deployment

00:25:16,210 --> 00:25:23,169
processes monitoring processing this

00:25:18,909 --> 00:25:24,970
designing a best possible way how the

00:25:23,169 --> 00:25:28,330
micro services should be implemented in

00:25:24,970 --> 00:25:30,730
this company and after six month they

00:25:28,330 --> 00:25:33,370
had one micro service and production one

00:25:30,730 --> 00:25:36,250
micro service production and this micro

00:25:33,370 --> 00:25:41,890
service was about generating the current

00:25:36,250 --> 00:25:44,950
time nothing more but the same time they

00:25:41,890 --> 00:25:47,860
establish extremely good process around

00:25:44,950 --> 00:25:51,760
the micro service why they spend so much

00:25:47,860 --> 00:25:55,230
time because they know that they will

00:25:51,760 --> 00:25:58,659
have hundreds of the micro services and

00:25:55,230 --> 00:26:01,600
this is a much much better situation to

00:25:58,659 --> 00:26:06,029
spend sometimes at the beginning to have

00:26:01,600 --> 00:26:09,549
a proven and while working a process and

00:26:06,029 --> 00:26:11,590
just a single process a single method

00:26:09,549 --> 00:26:13,080
and single skeleton for the all the

00:26:11,590 --> 00:26:15,210
micro services

00:26:13,080 --> 00:26:17,910
instead of having 25 different

00:26:15,210 --> 00:26:23,160
deployment methods and 25 different

00:26:17,910 --> 00:26:25,320
monitoring methods so because like

00:26:23,160 --> 00:26:26,850
Milton Friedman said in the marker

00:26:25,320 --> 00:26:32,130
services in the world there is no such

00:26:26,850 --> 00:26:34,860
thing by free lunch so maybe from the

00:26:32,130 --> 00:26:38,160
one side there is really for the

00:26:34,860 --> 00:26:40,500
developers it's good situations to have

00:26:38,160 --> 00:26:44,160
a small applications small applications

00:26:40,500 --> 00:26:50,430
it's easy to read easy to modify easy to

00:26:44,160 --> 00:26:52,950
rev right but at the same time there's a

00:26:50,430 --> 00:26:54,660
hidden distributed complexity if I've

00:26:52,950 --> 00:27:02,520
got my application and my application

00:26:54,660 --> 00:27:04,320
should talk to other so there is some

00:27:02,520 --> 00:27:05,520
some complexity around and what about

00:27:04,320 --> 00:27:07,410
the communication maybe the

00:27:05,520 --> 00:27:09,440
communication will fail how my

00:27:07,410 --> 00:27:15,660
application should survive this

00:27:09,440 --> 00:27:18,990
information so in PHP world we are maybe

00:27:15,660 --> 00:27:22,560
not stuck but our a standard way for the

00:27:18,990 --> 00:27:25,860
communication is usually HTTP at HTTP

00:27:22,560 --> 00:27:28,980
for micro services sometimes doesn't

00:27:25,860 --> 00:27:32,040
work well especially in the PHP world

00:27:28,980 --> 00:27:34,710
which P is not the fastest language I'm

00:27:32,040 --> 00:27:37,650
sorry decided but I love the PHP but

00:27:34,710 --> 00:27:42,480
this is not the fastest language even in

00:27:37,650 --> 00:27:45,450
PHP 7 so you up the application you saw

00:27:42,480 --> 00:27:48,180
it was pure HTTP microservices

00:27:45,450 --> 00:27:51,630
communication the composts are micro

00:27:48,180 --> 00:27:54,480
service called another service just to

00:27:51,630 --> 00:27:57,720
fetch the json data how this page looks

00:27:54,480 --> 00:28:00,720
like or should look like and then the

00:27:57,720 --> 00:28:03,240
the compost micro service talk to other

00:28:00,720 --> 00:28:07,340
micro services with UI composition

00:28:03,240 --> 00:28:11,030
method - me the data fetch me the UI and

00:28:07,340 --> 00:28:14,670
but sometimes if your application is

00:28:11,030 --> 00:28:17,220
huge or if you would like to implement a

00:28:14,670 --> 00:28:20,190
micro services around a full stack

00:28:17,220 --> 00:28:23,190
sinfoni free your application will be

00:28:20,190 --> 00:28:25,110
very very slow so but fortunately we can

00:28:23,190 --> 00:28:28,779
use another

00:28:25,110 --> 00:28:31,299
communication protocols because there is

00:28:28,779 --> 00:28:33,399
no there's no need to use HTTP for all

00:28:31,299 --> 00:28:37,830
the micro services you can run your

00:28:33,399 --> 00:28:41,889
micro services let's say over AMQP and

00:28:37,830 --> 00:28:45,220
your services will be up and running all

00:28:41,889 --> 00:28:47,889
the time and to a new request from the

00:28:45,220 --> 00:28:49,929
AMQP server will arrive your data will

00:28:47,889 --> 00:28:52,480
be processed and pushed where to the

00:28:49,929 --> 00:28:56,950
AMQP so it will be much much much faster

00:28:52,480 --> 00:29:01,149
and right now I'm working on two

00:28:56,950 --> 00:29:03,749
applications of both of them are based

00:29:01,149 --> 00:29:09,129
on Symphony free where all the backend

00:29:03,749 --> 00:29:11,919
is implemented as a micro services the

00:29:09,129 --> 00:29:14,710
Symphony free application just a

00:29:11,919 --> 00:29:17,860
front-end know nothing about the micro

00:29:14,710 --> 00:29:20,740
service architecture when the request

00:29:17,860 --> 00:29:24,580
from the user arrives the Symphony free

00:29:20,740 --> 00:29:28,149
application only submit a request to the

00:29:24,580 --> 00:29:30,850
AMQP server as no matter it's a get

00:29:28,149 --> 00:29:33,929
request for the data or the submit

00:29:30,850 --> 00:29:37,980
change request form data modification

00:29:33,929 --> 00:29:42,879
it's just a message to aim copy server

00:29:37,980 --> 00:29:45,369
then this message is routed to the micro

00:29:42,879 --> 00:29:47,919
service cluster and this micro service

00:29:45,369 --> 00:29:49,690
cluster is up and running so the

00:29:47,919 --> 00:29:51,100
response is very very quick and the

00:29:49,690 --> 00:29:58,059
response is transmitted to the symphony

00:29:51,100 --> 00:30:00,789
for application so of course we can

00:29:58,059 --> 00:30:02,919
compose these methods depending on our

00:30:00,789 --> 00:30:04,389
on our needs there is no such there's no

00:30:02,919 --> 00:30:08,619
Beth to mix them together

00:30:04,389 --> 00:30:10,749
why so the same time if you've got the

00:30:08,619 --> 00:30:13,990
micro service up and running and

00:30:10,749 --> 00:30:16,720
processing your data is very very

00:30:13,990 --> 00:30:21,039
important important thing to to monitor

00:30:16,720 --> 00:30:24,399
every single action in this demo in this

00:30:21,039 --> 00:30:29,190
application do you think which of the

00:30:24,399 --> 00:30:32,879
micro service is slow if you've got okay

00:30:29,190 --> 00:30:42,610
exchange rate because that's right

00:30:32,879 --> 00:30:45,070
and it's not cashed it's not cashed now

00:30:42,610 --> 00:30:46,809
it was it was easy example if you've got

00:30:45,070 --> 00:30:51,220
to have this micro service it's not so

00:30:46,809 --> 00:30:53,080
easy to identify the issue but if you've

00:30:51,220 --> 00:30:55,240
got a good monitoring I mean good

00:30:53,080 --> 00:30:57,490
monitoring it means that you are

00:30:55,240 --> 00:31:00,490
monitoring every single micro service in

00:30:57,490 --> 00:31:01,779
the context how much time you need to

00:31:00,490 --> 00:31:05,710
process the data

00:31:01,779 --> 00:31:08,139
what is if you are using HTTP micro

00:31:05,710 --> 00:31:12,669
services what are the number of HTTP

00:31:08,139 --> 00:31:14,889
responses and the same time during the

00:31:12,669 --> 00:31:22,029
talk this application is a little bit

00:31:14,889 --> 00:31:26,279
heated in the background and this data

00:31:22,029 --> 00:31:29,740
are generated on the fly on my laptop

00:31:26,279 --> 00:31:33,730
every single micro service a compost

00:31:29,740 --> 00:31:38,019
text content page layout and exchange

00:31:33,730 --> 00:31:42,100
rates is monitored under the time

00:31:38,019 --> 00:31:46,440
execution and the response code for the

00:31:42,100 --> 00:31:48,669
HTTP all this data are collected and

00:31:46,440 --> 00:31:52,059
inserted into the influx DB and

00:31:48,669 --> 00:31:56,279
presented in grow fauna so try to image

00:31:52,059 --> 00:32:01,570
that you've got 250 micro services and

00:31:56,279 --> 00:32:04,029
your application is slow so if you if

00:32:01,570 --> 00:32:07,720
your production is slow there is no time

00:32:04,029 --> 00:32:10,179
for looking for day for the issue you

00:32:07,720 --> 00:32:13,360
should be automatically alerted which

00:32:10,179 --> 00:32:18,269
the micro service is very very slow to

00:32:13,360 --> 00:32:18,269
react so let's change small

00:32:46,010 --> 00:32:58,630
I just activated the cash application

00:32:54,260 --> 00:32:58,630
you should respond a little bit faster

00:33:02,890 --> 00:33:12,320
and this automatically visible on the on

00:33:07,040 --> 00:33:14,060
the charts so of course there is a whole

00:33:12,320 --> 00:33:18,440
stack of monitoring behind

00:33:14,060 --> 00:33:22,820
there's influx influx DB dedicated time

00:33:18,440 --> 00:33:24,980
serious databases set to collect the

00:33:22,820 --> 00:33:28,280
data from the micro services each micro

00:33:24,980 --> 00:33:31,730
service in the Silex is rapid with very

00:33:28,280 --> 00:33:33,830
very small middleware running the timer

00:33:31,730 --> 00:33:37,430
and stopping the tyrant and registering

00:33:33,830 --> 00:33:39,950
the timer each middleware is exactly the

00:33:37,430 --> 00:33:42,410
same the small difference between the

00:33:39,950 --> 00:33:45,050
micro services meteors are just the name

00:33:42,410 --> 00:33:54,260
what is the name of the metrics to

00:33:45,050 --> 00:33:55,700
submit yeah if you've got a bunch of the

00:33:54,260 --> 00:34:01,970
micro services it's really really

00:33:55,700 --> 00:34:04,430
important to get know what's happened of

00:34:01,970 --> 00:34:06,950
course monitoring is only one of the

00:34:04,430 --> 00:34:09,560
issues we should care a logging

00:34:06,950 --> 00:34:11,000
distributive logging each service

00:34:09,560 --> 00:34:13,970
generates a lot of data

00:34:11,000 --> 00:34:18,050
I mean Delta flux so you should have

00:34:13,970 --> 00:34:19,909
some small layer for log aggregation to

00:34:18,050 --> 00:34:24,470
collect all the information in single

00:34:19,909 --> 00:34:27,740
place and it's not so easy as you think

00:34:24,470 --> 00:34:30,590
it's not about collecting all the table

00:34:27,740 --> 00:34:33,379
ops into the single place if you've got

00:34:30,590 --> 00:34:36,980
the request to your application and then

00:34:33,379 --> 00:34:39,460
this request explodes to other micro

00:34:36,980 --> 00:34:44,090
services and maybe this micro service

00:34:39,460 --> 00:34:47,659
will hit another micro service if this

00:34:44,090 --> 00:34:51,050
micro service explodes is it easy to

00:34:47,659 --> 00:34:55,490
find all the paths and connect all the

00:34:51,050 --> 00:34:57,980
all the micro services call to join and

00:34:55,490 --> 00:34:59,250
find that the the original HTTP request

00:34:57,980 --> 00:35:03,050
from the user

00:34:59,250 --> 00:35:08,010
if you have no connection between them

00:35:03,050 --> 00:35:11,880
you can do this so if you've got this

00:35:08,010 --> 00:35:15,540
kind of problem you should for example

00:35:11,880 --> 00:35:18,060
use a correlation ID each service if

00:35:15,540 --> 00:35:21,530
there is a call to another service

00:35:18,060 --> 00:35:24,990
should embed somehow in the headers or

00:35:21,530 --> 00:35:28,109
somewhere the information about the ID

00:35:24,990 --> 00:35:30,990
of original request and then if you log

00:35:28,109 --> 00:35:33,540
something try to lock everything with

00:35:30,990 --> 00:35:39,300
this correlation ID then if something

00:35:33,540 --> 00:35:43,380
happens during the the further phase of

00:35:39,300 --> 00:35:46,710
your request execution you can ask your

00:35:43,380 --> 00:35:49,349
data logs and give me all the all the

00:35:46,710 --> 00:35:52,260
requests all the lobs connected with

00:35:49,349 --> 00:35:55,079
this correlation ID if you are using the

00:35:52,260 --> 00:35:58,200
docker there is there are some some

00:35:55,079 --> 00:36:01,220
solutions which allows you to add a

00:35:58,200 --> 00:36:03,329
correlation ID on the network level so

00:36:01,220 --> 00:36:07,140
from the developers perspective is

00:36:03,329 --> 00:36:10,500
almost sometimes not so important the

00:36:07,140 --> 00:36:13,500
service discovery if you are familiar

00:36:10,500 --> 00:36:16,589
with Apache zookeeper console IO the

00:36:13,500 --> 00:36:20,069
software you can use to orchestrate your

00:36:16,589 --> 00:36:22,920
micro services into the some some some

00:36:20,069 --> 00:36:27,329
catalogs when your application when your

00:36:22,920 --> 00:36:30,900
micro service is up and running this

00:36:27,329 --> 00:36:32,940
application may register itself to the

00:36:30,900 --> 00:36:35,400
to the catalog and then you have whole

00:36:32,940 --> 00:36:37,530
other elements in your application may

00:36:35,400 --> 00:36:39,990
ask the catalog hey give me the service

00:36:37,530 --> 00:36:44,010
code let's say already's or Mar sequel

00:36:39,990 --> 00:36:48,359
and then you can split this information

00:36:44,010 --> 00:36:53,089
around about the error under the default

00:36:48,359 --> 00:36:56,640
database so the most problematic part

00:36:53,089 --> 00:36:58,890
the most problematic part from the from

00:36:56,640 --> 00:37:02,730
the Microsoft world are the data stores

00:36:58,890 --> 00:37:05,160
you remember this this initial charts

00:37:02,730 --> 00:37:08,080
when all the micro services have

00:37:05,160 --> 00:37:10,150
separated databases

00:37:08,080 --> 00:37:12,010
if you are working on the monolithic

00:37:10,150 --> 00:37:16,450
application it usually means that we've

00:37:12,010 --> 00:37:19,060
got a single data store usually a huge

00:37:16,450 --> 00:37:23,290
huge my sequel database when we can

00:37:19,060 --> 00:37:27,130
create a transaction we can create a lot

00:37:23,290 --> 00:37:32,020
of joint to fetch a data this model is

00:37:27,130 --> 00:37:34,260
called a strong consistency if you got a

00:37:32,020 --> 00:37:37,810
dedicated different data stores and

00:37:34,260 --> 00:37:41,260
you've got some layers to communicate

00:37:37,810 --> 00:37:44,680
them for example with events there is no

00:37:41,260 --> 00:37:47,230
strong consistent model your model is

00:37:44,680 --> 00:37:51,400
called eventually consistent your data

00:37:47,230 --> 00:37:54,790
will be inconsistent in future maybe in

00:37:51,400 --> 00:37:58,290
next and milliseconds but right now your

00:37:54,790 --> 00:38:01,720
data stores are inconsistent state

00:37:58,290 --> 00:38:04,980
because let's say this way a sequel

00:38:01,720 --> 00:38:08,700
database was changed you're microservice

00:38:04,980 --> 00:38:11,620
publish the events the events is summer

00:38:08,700 --> 00:38:14,440
into the messaging layer but this event

00:38:11,620 --> 00:38:16,930
wasn't prepared wasn't processed by

00:38:14,440 --> 00:38:22,300
another micro service so your data are

00:38:16,930 --> 00:38:27,250
inconsistent it also means that

00:38:22,300 --> 00:38:29,980
sometimes you should care how you design

00:38:27,250 --> 00:38:31,690
your services there is no such drink

00:38:29,980 --> 00:38:34,000
like transaction on the microservices

00:38:31,690 --> 00:38:39,070
because there are different data stores

00:38:34,000 --> 00:38:41,710
so sometimes you should model your

00:38:39,070 --> 00:38:44,620
services in different ways so the

00:38:41,710 --> 00:38:47,710
general way how to model micro services

00:38:44,620 --> 00:38:50,610
is each micro service should be built

00:38:47,710 --> 00:38:54,220
upon the business not technical

00:38:50,610 --> 00:38:56,170
capabilities so you need to know how

00:38:54,220 --> 00:39:00,640
your business works really really good

00:38:56,170 --> 00:39:02,740
to identify a transaction boundaries you

00:39:00,640 --> 00:39:07,560
can use this transaction boundaries to

00:39:02,740 --> 00:39:12,310
avoid some eventual consistency issues

00:39:07,560 --> 00:39:17,440
and the last problematic part in this

00:39:12,310 --> 00:39:21,420
world is that one problematic service

00:39:17,440 --> 00:39:23,819
one very very slow micro service

00:39:21,420 --> 00:39:26,730
you ruin everything in Europe if your

00:39:23,819 --> 00:39:31,740
application is is using a synchronous

00:39:26,730 --> 00:39:33,809
calls like this demo one slow micro

00:39:31,740 --> 00:39:38,099
service ruin performance of your

00:39:33,809 --> 00:39:41,700
applications so sometimes you should

00:39:38,099 --> 00:39:44,520
care about the sacred breakers if you're

00:39:41,700 --> 00:39:47,030
part of your application one or maybe

00:39:44,520 --> 00:39:51,089
more micro services are not working well

00:39:47,030 --> 00:39:54,240
your application should be ready to cut

00:39:51,089 --> 00:39:57,329
them automatically for some time and

00:39:54,240 --> 00:39:59,160
then after time some time your

00:39:57,329 --> 00:40:00,990
application may check if this

00:39:59,160 --> 00:40:06,930
problematic micro service or fleet of

00:40:00,990 --> 00:40:12,150
micro services is operating well so you

00:40:06,930 --> 00:40:14,730
can use let's say so you could break

00:40:12,150 --> 00:40:19,430
your pattern sacred breaker pattern is

00:40:14,730 --> 00:40:24,299
very very small thing after every single

00:40:19,430 --> 00:40:26,700
success call you can notify a secret

00:40:24,299 --> 00:40:31,349
breaker that this service is up and

00:40:26,700 --> 00:40:35,299
running after the failed call you can

00:40:31,349 --> 00:40:38,309
inform there was an error and depending

00:40:35,299 --> 00:40:43,200
what depending on the threshold on the

00:40:38,309 --> 00:40:45,569
service your secret breaker may allow or

00:40:43,200 --> 00:40:48,119
block call to the micro service of

00:40:45,569 --> 00:40:51,599
course your application should be ready

00:40:48,119 --> 00:40:54,750
for this kind of operations and your

00:40:51,599 --> 00:40:59,520
application should react properly when

00:40:54,750 --> 00:41:02,640
the service is not so performant so if

00:40:59,520 --> 00:41:04,530
you are thinking should I use the micro

00:41:02,640 --> 00:41:07,619
service or not because this talk is a

00:41:04,530 --> 00:41:12,869
little bit about disadvantages and the

00:41:07,619 --> 00:41:15,809
micro service start to think if you

00:41:12,869 --> 00:41:19,589
really know the elements from the mind

00:41:15,809 --> 00:41:23,990
boxes if yes and your application your

00:41:19,589 --> 00:41:26,750
system and your organisation is a matter

00:41:23,990 --> 00:41:28,829
and you've got a lot of automatization

00:41:26,750 --> 00:41:31,980
automatic deployment automatic

00:41:28,829 --> 00:41:34,890
monitoring at the threat asura yes this

00:41:31,980 --> 00:41:35,370
in this scenario you can use the micro

00:41:34,890 --> 00:41:38,070
serve

00:41:35,370 --> 00:41:40,680
if not if you've got a lot of manual

00:41:38,070 --> 00:41:44,310
work for deployments if good got a lot

00:41:40,680 --> 00:41:48,090
of manual work for the monitoring try to

00:41:44,310 --> 00:41:50,030
fix your organization first and then try

00:41:48,090 --> 00:41:52,770
to implement a micro service

00:41:50,030 --> 00:41:55,050
architecture because in the micro

00:41:52,770 --> 00:42:00,690
service architecture if you've got let's

00:41:55,050 --> 00:42:04,170
say 100 100 micro services and three

00:42:00,690 --> 00:42:07,470
deployments per day for them it's not so

00:42:04,170 --> 00:42:09,900
easy to do to perform and the manual so

00:42:07,470 --> 00:42:11,970
that's everything for me if you've got

00:42:09,900 --> 00:42:18,390
some questions and would be happy to

00:42:11,970 --> 00:42:20,820
answer if not so thank you very much

00:42:18,390 --> 00:42:23,030
I'll be somewhere here to the end of the

00:42:20,820 --> 00:42:25,890
day so thank you

00:42:23,030 --> 00:42:28,230
[Applause]

00:42:25,890 --> 00:42:30,290
[Music]

00:42:28,230 --> 00:42:30,290

YouTube URL: https://www.youtube.com/watch?v=tewgo5zrHXA


