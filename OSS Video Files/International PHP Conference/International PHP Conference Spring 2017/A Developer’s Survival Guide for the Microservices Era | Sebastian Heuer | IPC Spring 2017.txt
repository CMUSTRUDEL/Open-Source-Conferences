Title: A Developerâ€™s Survival Guide for the Microservices Era | Sebastian Heuer | IPC Spring 2017
Publication date: 2019-01-23
Playlist: International PHP Conference Spring 2017
Description: 
	Sebastian Heuer (die kartenmacherei GmbH): Microservices architectures have emerged from a sophisticated concept to a broadly adopted pattern during the past years, so it is safe to say that they will stick around at least for the next couple of years.
But as we all know, no solution fits every problem. Based on real-world examples we will have a look at best practices and the pitfalls you can easily run into as well as at the implications Microservices can and should have on development teams, so you can decide for yourself if they are suitable for your projects.
Captions: 
	00:00:05,839 --> 00:00:12,269
so um welcome to the last regular talk

00:00:09,300 --> 00:00:15,330
before tonight's keynote it's cool to

00:00:12,269 --> 00:00:19,070
see that many faces although it's quite

00:00:15,330 --> 00:00:21,830
late already so let's get started um

00:00:19,070 --> 00:00:24,090
this is me I work for those guys and

00:00:21,830 --> 00:00:27,050
I'll talk about that in a bit because

00:00:24,090 --> 00:00:30,720
everything I tell you today is based on

00:00:27,050 --> 00:00:33,780
experienced on a real life project by

00:00:30,720 --> 00:00:37,020
that company I also do some open source

00:00:33,780 --> 00:00:40,800
stuff mostly working on five but that's

00:00:37,020 --> 00:00:42,840
a different topic because today we want

00:00:40,800 --> 00:00:44,190
to talk about micro services and you

00:00:42,840 --> 00:00:46,230
probably already have heard quite a lot

00:00:44,190 --> 00:00:51,239
about that because it's still an ongoing

00:00:46,230 --> 00:00:54,390
hot topic on almost every conference so

00:00:51,239 --> 00:00:57,210
even on on this IPC we already had two

00:00:54,390 --> 00:00:58,800
sessions dedicated to micro services and

00:00:57,210 --> 00:01:01,859
there's one more coming up tomorrow I

00:00:58,800 --> 00:01:03,359
believe so including this we're at four

00:01:01,859 --> 00:01:05,670
already and they're probably a lot more

00:01:03,359 --> 00:01:10,189
talks that deal with micro services but

00:01:05,670 --> 00:01:12,780
don't really have it in their title so

00:01:10,189 --> 00:01:14,580
it's it's still a hot topic for everyone

00:01:12,780 --> 00:01:17,580
everybody talks about it and a lot of

00:01:14,580 --> 00:01:19,860
people finally started using it and at

00:01:17,580 --> 00:01:21,900
least in my perception the general tone

00:01:19,860 --> 00:01:25,799
of the talks dealing with micro services

00:01:21,900 --> 00:01:28,619
have become a little less let's say

00:01:25,799 --> 00:01:30,509
optimistic because now people have

00:01:28,619 --> 00:01:32,520
started using it in their own projects

00:01:30,509 --> 00:01:36,329
they have production experience and

00:01:32,520 --> 00:01:43,079
maybe found out that it's not always the

00:01:36,329 --> 00:01:45,149
perfect approach for their project why

00:01:43,079 --> 00:01:47,549
preparing this talk I stumbled a powder

00:01:45,149 --> 00:01:51,509
manifesto um that I want to get started

00:01:47,549 --> 00:01:55,170
with done by a couple of smart people in

00:01:51,509 --> 00:01:57,420
2009 and most of what is stated here

00:01:55,170 --> 00:01:59,850
would actually apply to micro services

00:01:57,420 --> 00:02:05,000
so this might as well be a micro service

00:01:59,850 --> 00:02:08,789
manifesto especially statements like we

00:02:05,000 --> 00:02:10,920
prioritize intrinsic interruption the

00:02:08,789 --> 00:02:13,950
interoperability of a custom integration

00:02:10,920 --> 00:02:17,190
shared services of a specific purpose

00:02:13,950 --> 00:02:19,650
and flexibility over optimization might

00:02:17,190 --> 00:02:21,379
as well apply to microservices instead

00:02:19,650 --> 00:02:24,569
this is the so our manifesto

00:02:21,379 --> 00:02:26,400
service-oriented architecture and and

00:02:24,569 --> 00:02:29,129
that's not really a surprise I mean

00:02:26,400 --> 00:02:31,680
having services and capsule aiding

00:02:29,129 --> 00:02:34,230
functionality into services is actually

00:02:31,680 --> 00:02:37,860
not really new we did that before micro

00:02:34,230 --> 00:02:41,849
services and we for example call Tetsuo

00:02:37,860 --> 00:02:44,819
and if we look at a very simple example

00:02:41,849 --> 00:02:46,739
of that we have several services

00:02:44,819 --> 00:02:49,440
dedicated to a certain set of

00:02:46,739 --> 00:02:51,690
functionality we have some core

00:02:49,440 --> 00:02:53,459
application sitting at the top and in

00:02:51,690 --> 00:02:55,560
between we have a communication layer

00:02:53,459 --> 00:02:57,599
and in so uh that's usually the

00:02:55,560 --> 00:02:59,340
Enterprise Service bus which already

00:02:57,599 --> 00:03:01,290
sounds pretty crazy and it has

00:02:59,340 --> 00:03:04,019
enterprise in its name so that's always

00:03:01,290 --> 00:03:06,870
something where people step away from

00:03:04,019 --> 00:03:08,730
and actually the ESB might have been one

00:03:06,870 --> 00:03:13,200
of the issues with traditional ZOA

00:03:08,730 --> 00:03:15,599
because it was too complex to use so it

00:03:13,200 --> 00:03:18,420
never got the amount of attention that

00:03:15,599 --> 00:03:21,959
micro services get today so maybe this

00:03:18,420 --> 00:03:23,549
actually was the issue with that if you

00:03:21,959 --> 00:03:25,829
look at a classic micro service

00:03:23,549 --> 00:03:29,130
architecture it's very similar we still

00:03:25,829 --> 00:03:32,010
have those specifically built services

00:03:29,130 --> 00:03:34,920
we have some core or orchestration

00:03:32,010 --> 00:03:38,160
applications sitting on top but here we

00:03:34,920 --> 00:03:40,470
have a much more simple communication

00:03:38,160 --> 00:03:44,540
layer at least for us because we usually

00:03:40,470 --> 00:03:47,660
use HTTP to talk to those services and

00:03:44,540 --> 00:03:50,160
that's a lot easier than having a new

00:03:47,660 --> 00:03:54,720
entry in your tech stack for

00:03:50,160 --> 00:03:57,269
communicating now with micro services

00:03:54,720 --> 00:03:58,980
the term alone can be pretty misleading

00:03:57,269 --> 00:04:00,690
and confusing because nobody can really

00:03:58,980 --> 00:04:04,440
tell you what micro means in this

00:04:00,690 --> 00:04:07,319
context we generally say a micro service

00:04:04,440 --> 00:04:10,769
capsule a certain functionality maybe a

00:04:07,319 --> 00:04:14,130
certain domain in your business but that

00:04:10,769 --> 00:04:16,380
doesn't say anything about size so i'm

00:04:14,130 --> 00:04:18,150
if you think about the word micro

00:04:16,380 --> 00:04:20,130
service you might think of okay i need

00:04:18,150 --> 00:04:21,870
to have something that's very condensed

00:04:20,130 --> 00:04:26,250
and like i put all the functionality in

00:04:21,870 --> 00:04:27,090
a very small tiny component so sizing

00:04:26,250 --> 00:04:32,100
really

00:04:27,090 --> 00:04:34,050
isn't that easier microservices so the

00:04:32,100 --> 00:04:36,750
same example but instead of a product

00:04:34,050 --> 00:04:38,400
service we have a pricing service in the

00:04:36,750 --> 00:04:40,110
product text service and of course we

00:04:38,400 --> 00:04:43,080
would need to have a lot more services

00:04:40,110 --> 00:04:45,419
if we do this on this fine grained level

00:04:43,080 --> 00:04:47,270
and that might be fine it's highly

00:04:45,419 --> 00:04:50,639
depending on what you want to do

00:04:47,270 --> 00:04:51,990
companies like Amazon do it on this kind

00:04:50,639 --> 00:04:55,320
of levels whether they have a lot of

00:04:51,990 --> 00:04:55,880
services for you that might just be too

00:04:55,320 --> 00:05:01,950
much

00:04:55,880 --> 00:05:03,900
so sizing is hard to do and most of the

00:05:01,950 --> 00:05:05,790
time that's because it's also hard to

00:05:03,900 --> 00:05:07,830
figure out what your domains are and

00:05:05,790 --> 00:05:11,550
which functionality can be capsulated

00:05:07,830 --> 00:05:14,430
in decoupled services so that's why

00:05:11,550 --> 00:05:16,470
micro services is actually pretty close

00:05:14,430 --> 00:05:19,200
to what domain driven design teaches us

00:05:16,470 --> 00:05:21,479
if we got domain driven design right and

00:05:19,200 --> 00:05:22,830
we know about our bounded contexts then

00:05:21,479 --> 00:05:24,960
we pretty much also know what our

00:05:22,830 --> 00:05:27,330
services will be because we have the

00:05:24,960 --> 00:05:29,460
boundary context defined already so if

00:05:27,330 --> 00:05:31,590
you try to use micro services on the

00:05:29,460 --> 00:05:36,080
other side you're kind of forced to

00:05:31,590 --> 00:05:38,430
think in domains and bounded contexts

00:05:36,080 --> 00:05:41,790
well sizing isn't easy but there

00:05:38,430 --> 00:05:44,250
certainly some don'ts and best practices

00:05:41,790 --> 00:05:47,030
and rules that we can apply to our

00:05:44,250 --> 00:05:50,160
services almost all the time

00:05:47,030 --> 00:05:51,870
so here are a few examples we go back to

00:05:50,160 --> 00:05:54,150
the simple example let's say this is

00:05:51,870 --> 00:05:55,710
some ecommerce application where the

00:05:54,150 --> 00:05:58,440
service for product data we have a

00:05:55,710 --> 00:06:01,020
service for the carats of customers

00:05:58,440 --> 00:06:02,430
where they can add items to and we have

00:06:01,020 --> 00:06:04,620
a checkout that deals with the whole

00:06:02,430 --> 00:06:06,390
business logic of checkout rules like

00:06:04,620 --> 00:06:09,690
which shipment methods and payment

00:06:06,390 --> 00:06:14,729
methods do I need now this is all fine

00:06:09,690 --> 00:06:16,740
and some things you shouldn't do is like

00:06:14,729 --> 00:06:19,919
this you know have dependencies between

00:06:16,740 --> 00:06:22,229
services so service a should not talk to

00:06:19,919 --> 00:06:24,450
service B because then you will end up

00:06:22,229 --> 00:06:27,270
having chaos because you don't know what

00:06:24,450 --> 00:06:29,400
the communication ways are all your

00:06:27,270 --> 00:06:31,350
services have one clear API to the

00:06:29,400 --> 00:06:37,200
outside world that's the only contract

00:06:31,350 --> 00:06:39,120
they are offer to the outside also that

00:06:37,200 --> 00:06:40,620
goes for every kind of data source

00:06:39,120 --> 00:06:45,120
normally each service

00:06:40,620 --> 00:06:46,919
should have its own data source and you

00:06:45,120 --> 00:06:49,590
shouldn't access that from any other

00:06:46,919 --> 00:06:52,260
point in your application so the service

00:06:49,590 --> 00:06:54,419
alone owns the data source and it does

00:06:52,260 --> 00:06:56,370
not expose that to any other service and

00:06:54,419 --> 00:06:58,770
of course that also counts for the core

00:06:56,370 --> 00:07:01,199
application so core application also

00:06:58,770 --> 00:07:04,380
only knows about this API and obviously

00:07:01,199 --> 00:07:11,160
shouldn't go to some database that's

00:07:04,380 --> 00:07:12,660
owned by your service all right next

00:07:11,160 --> 00:07:14,810
point might be a bit more controversial

00:07:12,660 --> 00:07:17,699
because I think it's done quite often

00:07:14,810 --> 00:07:19,620
you might come up with a chain of

00:07:17,699 --> 00:07:21,840
services so you have a product service

00:07:19,620 --> 00:07:23,610
sitting on top that to the outside world

00:07:21,840 --> 00:07:26,520
provides you all the information

00:07:23,610 --> 00:07:28,490
regarding your products since that can

00:07:26,520 --> 00:07:32,160
be quite a lot you might come up with

00:07:28,490 --> 00:07:33,780
adding more smaller services and those

00:07:32,160 --> 00:07:36,139
are being consumed by the product

00:07:33,780 --> 00:07:40,440
service we build a chain of

00:07:36,139 --> 00:07:42,680
responsibilities here and I personally

00:07:40,440 --> 00:07:45,300
don't think it's a good idea to do that

00:07:42,680 --> 00:07:47,010
because it will also add a lot of

00:07:45,300 --> 00:07:49,560
complexity to your whole infrastructure

00:07:47,010 --> 00:07:56,250
and your general architecture that might

00:07:49,560 --> 00:08:01,470
become pretty hard to maintain okay um

00:07:56,250 --> 00:08:03,450
all this what we saw here is using HTTP

00:08:01,470 --> 00:08:06,660
right I mean usually you have HTTP

00:08:03,450 --> 00:08:09,440
communication and you use restful api is

00:08:06,660 --> 00:08:11,820
probably because everybody does that

00:08:09,440 --> 00:08:14,340
there's nothing that is dictated by

00:08:11,820 --> 00:08:16,199
micro services you could essentially do

00:08:14,340 --> 00:08:20,010
any kind of communication and data

00:08:16,199 --> 00:08:22,139
structures you want and more and more

00:08:20,010 --> 00:08:24,990
people start to use alternative

00:08:22,139 --> 00:08:26,370
communication layers and that might end

00:08:24,990 --> 00:08:29,099
up looking like this they had a message

00:08:26,370 --> 00:08:32,430
queue between the services and the core

00:08:29,099 --> 00:08:33,959
application which is fine but we're back

00:08:32,430 --> 00:08:36,209
to the Enterprise Service bus issue

00:08:33,959 --> 00:08:37,229
again because you add more complexity to

00:08:36,209 --> 00:08:39,839
the whole infrastructure on

00:08:37,229 --> 00:08:42,240
communication here and with this it

00:08:39,839 --> 00:08:44,370
might become easier to accidentally let

00:08:42,240 --> 00:08:46,170
services talk to each other instead of

00:08:44,370 --> 00:08:50,820
going through the core application and

00:08:46,170 --> 00:08:53,839
orchestrating everything from there so

00:08:50,820 --> 00:08:53,839
this could be interesting

00:08:55,100 --> 00:09:00,420
okay and one thing we really learned

00:08:57,510 --> 00:09:04,410
when applying the first set of micro

00:09:00,420 --> 00:09:07,770
services is that it also highly depends

00:09:04,410 --> 00:09:11,640
on your development team or more clearly

00:09:07,770 --> 00:09:13,620
your team's microservices are autonomous

00:09:11,640 --> 00:09:16,800
they are decoupled from outer

00:09:13,620 --> 00:09:20,400
dependencies so they are not relying on

00:09:16,800 --> 00:09:22,350
outside technologies or anything and for

00:09:20,400 --> 00:09:27,360
us the same applied to the team's

00:09:22,350 --> 00:09:30,330
implementing those services and it says

00:09:27,360 --> 00:09:32,190
teams intentionally because personally I

00:09:30,330 --> 00:09:35,370
believe if you work in a team with like

00:09:32,190 --> 00:09:36,870
three or four developers micro-services

00:09:35,370 --> 00:09:39,300
might be too much overhead for you a

00:09:36,870 --> 00:09:42,420
cool thing of micro-services is that you

00:09:39,300 --> 00:09:45,630
can distribute development or services

00:09:42,420 --> 00:09:46,800
over multiple teams so if you have three

00:09:45,630 --> 00:09:50,000
or four development teams in your

00:09:46,800 --> 00:09:52,800
company it's very straightforward to

00:09:50,000 --> 00:09:54,800
basically assign services to teams and

00:09:52,800 --> 00:09:56,940
let them develop that autonomously

00:09:54,800 --> 00:09:59,130
because that also gives the development

00:09:56,940 --> 00:10:01,320
team the freedom to make decisions

00:09:59,130 --> 00:10:04,140
within their domain within their service

00:10:01,320 --> 00:10:08,240
and they are independent of the other

00:10:04,140 --> 00:10:13,530
teams of course that leads to problems

00:10:08,240 --> 00:10:15,780
so back to our simple services let's say

00:10:13,530 --> 00:10:18,440
we have three teams and each team is

00:10:15,780 --> 00:10:21,260
responsible for one of those services

00:10:18,440 --> 00:10:24,210
that has the benefit that each team

00:10:21,260 --> 00:10:25,920
becomes a domain expert for that domain

00:10:24,210 --> 00:10:27,750
over time because well I have to know

00:10:25,920 --> 00:10:30,780
what the check out roles are in order to

00:10:27,750 --> 00:10:32,460
build a proper check out service but

00:10:30,780 --> 00:10:35,010
since they're autonomous and they are

00:10:32,460 --> 00:10:37,310
able to take their own decisions we

00:10:35,010 --> 00:10:39,450
could end up having something like this

00:10:37,310 --> 00:10:41,910
every team is able to make their own

00:10:39,450 --> 00:10:43,380
decisions so team a says we know PHP

00:10:41,910 --> 00:10:45,800
let's settle with that we build our

00:10:43,380 --> 00:10:49,800
product service PHP everything's cool

00:10:45,800 --> 00:10:51,390
team B and C well they they a bit bored

00:10:49,800 --> 00:10:54,000
so they want to try out something new

00:10:51,390 --> 00:10:57,380
and they decide okay let's do Scala or

00:10:54,000 --> 00:10:59,880
maybe go or whatever hit at the moment

00:10:57,380 --> 00:11:01,590
because this is a cool way of it for us

00:10:59,880 --> 00:11:03,360
to learn a new technology because we are

00:11:01,590 --> 00:11:07,520
in our own world we don't have to deal

00:11:03,360 --> 00:11:07,520
with anything in the outside world right

00:11:08,329 --> 00:11:12,540
while same goes for secondary click

00:11:10,679 --> 00:11:14,639
technologies like databases and data

00:11:12,540 --> 00:11:16,649
sources but that's a different topic in

00:11:14,639 --> 00:11:20,459
my opinion this is really problematic

00:11:16,649 --> 00:11:22,669
because with that you bit tightly a lot

00:11:20,459 --> 00:11:25,439
a couple your services to the team

00:11:22,669 --> 00:11:27,779
because it will be immensely hard for

00:11:25,439 --> 00:11:29,459
someone working on a product service to

00:11:27,779 --> 00:11:32,279
switch over to the checkout service for

00:11:29,459 --> 00:11:33,929
example because they have to get used to

00:11:32,279 --> 00:11:36,439
the new language and all the tools are

00:11:33,929 --> 00:11:39,569
different and it will be totally chaotic

00:11:36,439 --> 00:11:41,910
of course if all use the same technology

00:11:39,569 --> 00:11:43,859
there's still domain knowledge missing

00:11:41,910 --> 00:11:45,929
but at least you don't have to deal with

00:11:43,859 --> 00:11:47,579
all the technology issues because you

00:11:45,929 --> 00:11:50,699
know know your way around in your IDE

00:11:47,579 --> 00:11:52,350
and the tools for something secondary

00:11:50,699 --> 00:11:53,999
technology that's kind of natural we do

00:11:52,350 --> 00:11:54,600
that all the time and it does make a lot

00:11:53,999 --> 00:11:57,239
of sense

00:11:54,600 --> 00:12:00,029
because for each service we might have

00:11:57,239 --> 00:12:01,619
totally different requirements regarding

00:12:00,029 --> 00:12:07,649
what we need to store and how we need to

00:12:01,619 --> 00:12:11,689
store it we learned a lot from a video

00:12:07,649 --> 00:12:14,549
series released by Spotify a while ago

00:12:11,689 --> 00:12:16,999
they reported very openly how they

00:12:14,549 --> 00:12:20,129
organize their development teams and

00:12:16,999 --> 00:12:23,819
it's it's a lot about culture and not

00:12:20,129 --> 00:12:25,889
much about technology and we learn a lot

00:12:23,819 --> 00:12:28,079
from that we actually copied some of

00:12:25,889 --> 00:12:30,839
their organization structures how they

00:12:28,079 --> 00:12:32,639
do cross-functional teams it's really

00:12:30,839 --> 00:12:34,529
cool and the videos are really worth

00:12:32,639 --> 00:12:36,720
watching because they explain quite a

00:12:34,529 --> 00:12:39,179
lot on how cross-functional teams work

00:12:36,720 --> 00:12:42,319
and also how you can organize multiple

00:12:39,179 --> 00:12:44,639
development teams and in those videos

00:12:42,319 --> 00:12:48,869
there was one key statement that really

00:12:44,639 --> 00:12:51,299
stick to my head and they said the teams

00:12:48,869 --> 00:12:54,539
need to be loosely coupled basically is

00:12:51,299 --> 00:12:57,749
like your services but they also must be

00:12:54,539 --> 00:13:00,119
tightly aligned and that's very

00:12:57,749 --> 00:13:02,970
important because alignment among the

00:13:00,119 --> 00:13:06,410
teams really empowers them to make

00:13:02,970 --> 00:13:09,449
decisions on their own without really

00:13:06,410 --> 00:13:13,860
drifting away from the overall goals

00:13:09,449 --> 00:13:17,369
that the whole set of teams has so what

00:13:13,860 --> 00:13:18,839
they do is each team has different

00:13:17,369 --> 00:13:19,260
disciplines so there's a back and

00:13:18,839 --> 00:13:22,680
develop

00:13:19,260 --> 00:13:25,980
there's a front-end developer QA product

00:13:22,680 --> 00:13:29,280
management everything you might need and

00:13:25,980 --> 00:13:31,800
they build so called chapters over those

00:13:29,280 --> 00:13:34,350
teams so every back-end developer is

00:13:31,800 --> 00:13:37,650
part of the backend chapter and they

00:13:34,350 --> 00:13:41,460
have usual meetings like once a week

00:13:37,650 --> 00:13:44,370
probably and they just cast decisions

00:13:41,460 --> 00:13:46,860
they discuss technical issues they're

00:13:44,370 --> 00:13:50,280
facing usually before actually taking

00:13:46,860 --> 00:13:52,320
decisions so if a new technology needs

00:13:50,280 --> 00:13:54,180
to be introduced because a service

00:13:52,320 --> 00:13:54,840
really requires that and there's no way

00:13:54,180 --> 00:13:57,090
around it

00:13:54,840 --> 00:14:00,930
it is bounce with the chapter before the

00:13:57,090 --> 00:14:04,140
decisions actually taken that allows you

00:14:00,930 --> 00:14:07,740
to define overall goals and visions and

00:14:04,140 --> 00:14:09,330
guidelines and then within each team you

00:14:07,740 --> 00:14:11,550
can follow those guidelines but you can

00:14:09,330 --> 00:14:14,670
still be autonomous because you can take

00:14:11,550 --> 00:14:17,310
the decisions on yourself so you're

00:14:14,670 --> 00:14:20,040
really only consult the chapter you

00:14:17,310 --> 00:14:21,660
don't ask it for permission and that is

00:14:20,040 --> 00:14:23,760
something that helped us greatly in

00:14:21,660 --> 00:14:25,740
organizing the teams and which also

00:14:23,760 --> 00:14:28,530
might help you greatly when writing

00:14:25,740 --> 00:14:31,110
micro services because you can define

00:14:28,530 --> 00:14:32,730
standards for each service so you always

00:14:31,110 --> 00:14:34,800
use a certain kind of framework you

00:14:32,730 --> 00:14:37,080
always use a certain kind of technology

00:14:34,800 --> 00:14:38,670
for your use cases and only if you

00:14:37,080 --> 00:14:40,620
really have to drift away from that you

00:14:38,670 --> 00:14:43,230
discuss that with the rest of the

00:14:40,620 --> 00:14:46,640
chapter well again you may drift away

00:14:43,230 --> 00:14:46,640
from that but you have those standards

00:14:47,570 --> 00:14:53,790
okay so much for that I won't want to go

00:14:51,690 --> 00:14:57,120
into details on the actual use case that

00:14:53,790 --> 00:15:01,050
we had for micro services where we found

00:14:57,120 --> 00:15:02,070
micro service is useful for that I need

00:15:01,050 --> 00:15:05,580
to give you some background information

00:15:02,070 --> 00:15:08,910
on what we do and how we did it and what

00:15:05,580 --> 00:15:11,250
we're doing right now so as I said I

00:15:08,910 --> 00:15:14,400
work for a company called cotton market

00:15:11,250 --> 00:15:18,090
I which is based in Munich and we make

00:15:14,400 --> 00:15:20,640
cars it's a web to print company so you

00:15:18,090 --> 00:15:23,790
can order wedding invitations and birth

00:15:20,640 --> 00:15:26,220
cards but also photo calendars you can

00:15:23,790 --> 00:15:29,310
customize them in many many ways and

00:15:26,220 --> 00:15:31,050
well they could send to you and for that

00:15:29,310 --> 00:15:32,819
we have a pretty straightforward

00:15:31,050 --> 00:15:35,609
ecommerce site where you can order your

00:15:32,819 --> 00:15:37,739
carts so this is a category page and you

00:15:35,609 --> 00:15:41,549
see a lot of products here they all have

00:15:37,739 --> 00:15:43,709
different colors and formats and well

00:15:41,549 --> 00:15:46,619
the rest is like the usual ecommerce

00:15:43,709 --> 00:15:51,689
stuff when the business was started a

00:15:46,619 --> 00:15:55,019
couple of years ago they used a standard

00:15:51,689 --> 00:15:56,489
e-commerce system and it's well what

00:15:55,019 --> 00:15:58,229
you'd expect a couple of years ago there

00:15:56,489 --> 00:16:00,569
was a huge monolithic application

00:15:58,229 --> 00:16:02,989
there's a subtle hint maybe it's too

00:16:00,569 --> 00:16:05,399
dark to see it which sift system we used

00:16:02,989 --> 00:16:07,739
but it's not too important anyway but

00:16:05,399 --> 00:16:10,410
because everything we tell is pretty

00:16:07,739 --> 00:16:13,109
much counting for the for every kind of

00:16:10,410 --> 00:16:17,429
system like that so we had this monolith

00:16:13,109 --> 00:16:19,589
and while it was very slow we had

00:16:17,429 --> 00:16:21,329
performance issues the developers didn't

00:16:19,589 --> 00:16:23,549
want to touch the whole pace anymore we

00:16:21,329 --> 00:16:27,749
couldn't do upgrades properly we had all

00:16:23,549 --> 00:16:29,069
the usual legacy problems and I'll give

00:16:27,749 --> 00:16:30,720
you a brief explanation there's a whole

00:16:29,069 --> 00:16:32,459
talk about that

00:16:30,720 --> 00:16:35,069
I'll send around the link later if you

00:16:32,459 --> 00:16:38,129
want to go into details there but what

00:16:35,069 --> 00:16:40,049
we did was we didn't replace the whole

00:16:38,129 --> 00:16:41,879
legacy application in one step because

00:16:40,049 --> 00:16:46,109
that would have been a huge project

00:16:41,879 --> 00:16:48,539
unplayable and far too big so we decided

00:16:46,109 --> 00:16:51,179
to only step-by-step move out

00:16:48,539 --> 00:16:53,249
functionality into new software we

00:16:51,179 --> 00:16:55,529
started with what we had the most amount

00:16:53,249 --> 00:16:57,629
of pain with and that was category pages

00:16:55,529 --> 00:17:00,869
and product pages because they were

00:16:57,629 --> 00:17:03,179
pretty slow and users tend to lead tend

00:17:00,869 --> 00:17:06,000
to drop off really quickly if the page

00:17:03,179 --> 00:17:08,220
doesn't load fast enough a lot of

00:17:06,000 --> 00:17:10,169
caching issues with varnish and it was

00:17:08,220 --> 00:17:14,299
really messy so that's what we focused

00:17:10,169 --> 00:17:16,799
on first and we built a new PHP based

00:17:14,299 --> 00:17:20,309
Rondon application which would handle

00:17:16,799 --> 00:17:22,589
requests and the general idea very

00:17:20,309 --> 00:17:24,149
briefly explained is that when the

00:17:22,589 --> 00:17:28,019
customer goes to a category page or

00:17:24,149 --> 00:17:31,740
product detail page in traditional

00:17:28,019 --> 00:17:34,679
systems like the one we used you go to

00:17:31,740 --> 00:17:37,320
the database you grab data from multiple

00:17:34,679 --> 00:17:39,450
tables join them together put them into

00:17:37,320 --> 00:17:41,519
some data structure hand them over the

00:17:39,450 --> 00:17:43,529
template engine template engine produces

00:17:41,519 --> 00:17:46,080
HTML and then it is sent back to the

00:17:43,529 --> 00:17:46,380
client and that takes quite a while I

00:17:46,080 --> 00:17:47,910
mean

00:17:46,380 --> 00:17:49,380
that's why I usually have cashing in

00:17:47,910 --> 00:17:52,290
front of that because you don't always

00:17:49,380 --> 00:17:55,560
want to go to the database but the thing

00:17:52,290 --> 00:17:59,240
is those pages will always look the same

00:17:55,560 --> 00:18:02,070
so for each request the data that is

00:17:59,240 --> 00:18:04,680
eventually returned to the client will

00:18:02,070 --> 00:18:06,930
be identical so I render it all the time

00:18:04,680 --> 00:18:09,930
that doesn't really make sense for us so

00:18:06,930 --> 00:18:12,810
the approach is to have a key value

00:18:09,930 --> 00:18:15,510
storage and that key value storage

00:18:12,810 --> 00:18:18,870
ideally contains everything pre-rendered

00:18:15,510 --> 00:18:20,100
or the HTML we need to serve so all the

00:18:18,870 --> 00:18:22,410
front-end would have to do when a

00:18:20,100 --> 00:18:24,330
request comes in is go to the key value

00:18:22,410 --> 00:18:26,760
storage and say hey I have a request for

00:18:24,330 --> 00:18:29,730
this category ID please give back the

00:18:26,760 --> 00:18:32,310
HTML for that and you would get to

00:18:29,730 --> 00:18:35,970
already created HTML and send it out I

00:18:32,310 --> 00:18:38,520
know that sounds a lot like caching but

00:18:35,970 --> 00:18:40,680
actually it's not of course it's not

00:18:38,520 --> 00:18:43,680
that simple because there are some

00:18:40,680 --> 00:18:45,470
dynamic elements so of course you have

00:18:43,680 --> 00:18:47,790
some flag filters and filters are

00:18:45,470 --> 00:18:51,360
probably different from request to

00:18:47,790 --> 00:18:53,480
request so we had one more dimension to

00:18:51,360 --> 00:18:55,500
that and we use a search engine and

00:18:53,480 --> 00:18:57,750
before going to the key value storage

00:18:55,500 --> 00:18:59,940
the front end goes to the search engine

00:18:57,750 --> 00:19:02,040
and says okay I need all the products

00:18:59,940 --> 00:19:05,280
for this category ID and this set of

00:19:02,040 --> 00:19:07,940
filters and the search engine returns a

00:19:05,280 --> 00:19:10,980
flat list of product identifiers and

00:19:07,940 --> 00:19:13,320
then with those identifiers we go to the

00:19:10,980 --> 00:19:16,500
key value storage and the key value

00:19:13,320 --> 00:19:18,540
storage holds the pre-rendered HTML

00:19:16,500 --> 00:19:21,900
snippet so only the thing related to the

00:19:18,540 --> 00:19:26,460
product and can return that so we get

00:19:21,900 --> 00:19:28,290
back a list of well HTML snippets still

00:19:26,460 --> 00:19:30,960
pre-rendered on all the front end does

00:19:28,290 --> 00:19:34,050
then is pretty much glue it into an

00:19:30,960 --> 00:19:37,410
existing page template that is insanely

00:19:34,050 --> 00:19:39,300
fast and that doesn't require any sort

00:19:37,410 --> 00:19:41,160
of traditional caching so you don't need

00:19:39,300 --> 00:19:43,170
to have a varnish in front of that you

00:19:41,160 --> 00:19:44,790
can still get time to first buy it in 30

00:19:43,170 --> 00:19:49,860
milliseconds with that it works very

00:19:44,790 --> 00:19:54,060
well so as I said we only replaced parts

00:19:49,860 --> 00:19:55,800
of the legacy application so everything

00:19:54,060 --> 00:19:58,020
that's not category pages and not

00:19:55,800 --> 00:19:59,880
product detail pages is still handled by

00:19:58,020 --> 00:20:02,700
the legacy software so we

00:19:59,880 --> 00:20:05,429
need to run that in parallel what we do

00:20:02,700 --> 00:20:07,799
here is having a web server in front of

00:20:05,429 --> 00:20:10,919
that every request is handed to the new

00:20:07,799 --> 00:20:13,410
software that will then do its thing and

00:20:10,919 --> 00:20:16,380
routing and looking up the HTML snippets

00:20:13,410 --> 00:20:18,660
and eventually return them pretty

00:20:16,380 --> 00:20:20,400
straightforward now of course the key

00:20:18,660 --> 00:20:22,620
value storage and the search engine

00:20:20,400 --> 00:20:24,330
needs to need to be populated at some

00:20:22,620 --> 00:20:26,340
point I mean it's not done on request

00:20:24,330 --> 00:20:30,299
but then it needs to be some process to

00:20:26,340 --> 00:20:32,570
do that so we have a what we call

00:20:30,299 --> 00:20:36,230
back-end component which is completely

00:20:32,570 --> 00:20:39,450
decoupled from the front-end component

00:20:36,230 --> 00:20:41,220
which at certain points in time goes to

00:20:39,450 --> 00:20:43,230
the database of the legacy system

00:20:41,220 --> 00:20:47,250
because as long as we have the legacy

00:20:43,230 --> 00:20:49,530
system living that is the primary source

00:20:47,250 --> 00:20:52,200
for all the data it's a single source of

00:20:49,530 --> 00:20:53,970
truth so we retrieve all the product

00:20:52,200 --> 00:20:57,270
data and the category data from the

00:20:53,970 --> 00:21:00,090
database then do the whole rendering

00:20:57,270 --> 00:21:02,909
stuff and put the HTML snippets and the

00:21:00,090 --> 00:21:05,220
search data into the key Vegas store and

00:21:02,909 --> 00:21:06,990
the search engine this is completely

00:21:05,220 --> 00:21:08,730
independent from the request handling

00:21:06,990 --> 00:21:12,390
part this could happen at any point in

00:21:08,730 --> 00:21:14,929
time and normally you would only want to

00:21:12,390 --> 00:21:17,309
do this when data actually changed and

00:21:14,929 --> 00:21:21,360
as long as it doesn't change you still

00:21:17,309 --> 00:21:22,530
serve the data from here and you just

00:21:21,360 --> 00:21:27,870
replace it when there's something new

00:21:22,530 --> 00:21:30,000
coming in case that we have to deal with

00:21:27,870 --> 00:21:32,610
a request that is not handled by the new

00:21:30,000 --> 00:21:34,590
software we still go there we always

00:21:32,610 --> 00:21:36,299
send all requests to the new software

00:21:34,590 --> 00:21:39,650
and let the software decide ok is

00:21:36,299 --> 00:21:42,600
there's a URL or request I can deal with

00:21:39,650 --> 00:21:45,900
and it's doing that and it's fine if not

00:21:42,600 --> 00:21:48,059
it just returns a for for and then the

00:21:45,900 --> 00:21:50,250
web server does a fall back and hence

00:21:48,059 --> 00:21:53,549
the request to the legacy software which

00:21:50,250 --> 00:21:56,250
then can deal with a request as it used

00:21:53,549 --> 00:21:58,200
to do so if you go to the checkout

00:21:56,250 --> 00:22:00,299
process for example you will always go

00:21:58,200 --> 00:22:02,640
through here first it would ever return

00:22:00,299 --> 00:22:05,640
404 and then you go to the legacy

00:22:02,640 --> 00:22:07,020
software that does add overhead of

00:22:05,640 --> 00:22:08,490
course because you always have to run

00:22:07,020 --> 00:22:12,330
through the new application before you

00:22:08,490 --> 00:22:13,770
get to the old one we try to measure

00:22:12,330 --> 00:22:15,600
that and it's pretty hard

00:22:13,770 --> 00:22:18,300
because like we're within the

00:22:15,600 --> 00:22:21,720
fault-tolerant of measuring it's like 30

00:22:18,300 --> 00:22:23,820
milliseconds tops and since the also

00:22:21,720 --> 00:22:25,680
face low anyway and takes like one to

00:22:23,820 --> 00:22:28,620
two seconds to deliver page sometimes

00:22:25,680 --> 00:22:31,650
even longer that's really not not an

00:22:28,620 --> 00:22:34,370
issue for us but this makes it really

00:22:31,650 --> 00:22:36,390
easy to add more URLs to here without

00:22:34,370 --> 00:22:41,010
changing anything in the web server

00:22:36,390 --> 00:22:42,450
configuration okay what does this have

00:22:41,010 --> 00:22:44,760
to do with micro services nothing

00:22:42,450 --> 00:22:48,000
because in the first step with what we

00:22:44,760 --> 00:22:50,160
did here I mean we knew about micro

00:22:48,000 --> 00:22:53,640
services and it was already trending but

00:22:50,160 --> 00:22:55,680
there was no real use case for us we

00:22:53,640 --> 00:22:59,040
might have come up with having this and

00:22:55,680 --> 00:23:00,990
this a separate services might have

00:22:59,040 --> 00:23:02,400
caused a would've work because they are

00:23:00,990 --> 00:23:04,710
decoupled and independent from each

00:23:02,400 --> 00:23:06,870
other but it would have just generated

00:23:04,710 --> 00:23:09,480
overhead at that point in time that we

00:23:06,870 --> 00:23:11,400
didn't need I mean the front end and the

00:23:09,480 --> 00:23:15,060
back end parts of that application are

00:23:11,400 --> 00:23:17,190
one repository and that's all right we

00:23:15,060 --> 00:23:21,600
deploy it as one anyway to make it

00:23:17,190 --> 00:23:24,060
consistent and the only thing we do is

00:23:21,600 --> 00:23:28,670
we do code analysis we recently

00:23:24,060 --> 00:23:31,530
introduced defend to our infrastructure

00:23:28,670 --> 00:23:34,830
which can tell you which dependencies

00:23:31,530 --> 00:23:36,510
you have in your code so we enforce that

00:23:34,830 --> 00:23:38,190
a front-end class does not have a

00:23:36,510 --> 00:23:41,250
dependency to any back-end class and

00:23:38,190 --> 00:23:44,070
vice versa otherwise the build fails and

00:23:41,250 --> 00:23:46,590
that's all we need that's already a

00:23:44,070 --> 00:23:48,660
pretty strong bounded context and we

00:23:46,590 --> 00:23:52,740
don't need to add additional overhead

00:23:48,660 --> 00:23:53,940
but introducing micro services but now

00:23:52,740 --> 00:23:56,010
you understand the scenario and the

00:23:53,940 --> 00:23:57,810
basic setup that we have especially

00:23:56,010 --> 00:23:59,250
whether going to the new application

00:23:57,810 --> 00:24:01,100
first and then falling back to the

00:23:59,250 --> 00:24:03,270
legacy software that's quite important

00:24:01,100 --> 00:24:05,400
because we launched that quite a while

00:24:03,270 --> 00:24:08,430
ago and it works really well so now we

00:24:05,400 --> 00:24:11,910
start removing more functionality out of

00:24:08,430 --> 00:24:14,940
the legacy application and for example

00:24:11,910 --> 00:24:19,860
that will be the card of the user or the

00:24:14,940 --> 00:24:21,540
basket so right now if you go to any

00:24:19,860 --> 00:24:24,900
kind of product or category you'll

00:24:21,540 --> 00:24:27,149
always land on the new software but if

00:24:24,900 --> 00:24:28,919
you go to the Coward page

00:24:27,149 --> 00:24:30,690
you will go directly to the legacy

00:24:28,919 --> 00:24:32,909
software and everything will be handled

00:24:30,690 --> 00:24:35,809
by that and that includes front and as

00:24:32,909 --> 00:24:38,009
in markup and styles and JavaScript

00:24:35,809 --> 00:24:40,139
which is really painful for our

00:24:38,009 --> 00:24:42,779
front-end developers because they need

00:24:40,139 --> 00:24:45,059
to work with both systems now part of it

00:24:42,779 --> 00:24:47,789
is in the new system part of it is in

00:24:45,059 --> 00:24:49,649
the old system so you diplucate stylings

00:24:47,789 --> 00:24:52,710
and that that's really ugly so we need

00:24:49,649 --> 00:24:54,719
to get rid of that and this is where

00:24:52,710 --> 00:24:59,190
actually the first service came into

00:24:54,719 --> 00:25:02,159
place so what we did is introducing a

00:24:59,190 --> 00:25:08,089
card service which qualifies as a micro

00:25:02,159 --> 00:25:13,109
service which also has an HTTP API and

00:25:08,089 --> 00:25:15,869
we use that so that the when the new

00:25:13,109 --> 00:25:19,049
application handles the request for card

00:25:15,869 --> 00:25:21,659
coming in it can tell talk to the card

00:25:19,049 --> 00:25:23,969
service to retrieve the current card of

00:25:21,659 --> 00:25:27,599
the user to add an item to that card and

00:25:23,969 --> 00:25:30,059
everything that's needed for card but

00:25:27,599 --> 00:25:33,359
the service itself hands over those

00:25:30,059 --> 00:25:34,799
requests to Magento again but that's

00:25:33,359 --> 00:25:37,259
already giving us some really good

00:25:34,799 --> 00:25:39,450
benefits because here we have a clear

00:25:37,259 --> 00:25:41,960
clean API that's independent of the

00:25:39,450 --> 00:25:44,969
legacy software so our new software

00:25:41,960 --> 00:25:46,769
talks to this API and doesn't know about

00:25:44,969 --> 00:25:49,349
the fact that there's some legacy stuff

00:25:46,769 --> 00:25:55,950
going on behind that so we abstracted

00:25:49,349 --> 00:25:57,389
that away so that in the next step we

00:25:55,950 --> 00:26:00,929
can actually strip out the business

00:25:57,389 --> 00:26:02,669
logic of the legacy application but even

00:26:00,929 --> 00:26:04,649
before that this is already pretty cool

00:26:02,669 --> 00:26:06,929
because now the front-end part as in

00:26:04,649 --> 00:26:08,549
markup and CSS andreas sitting in the

00:26:06,929 --> 00:26:10,049
new application so our front-end

00:26:08,549 --> 00:26:13,080
developers can already work with the new

00:26:10,049 --> 00:26:16,979
software and the legacy software becomes

00:26:13,080 --> 00:26:19,309
a back-end merely so it's not delivering

00:26:16,979 --> 00:26:22,489
any content to the user anymore and

00:26:19,309 --> 00:26:24,719
that's already giving us a lot more

00:26:22,489 --> 00:26:28,830
speed regarding front-end development

00:26:24,719 --> 00:26:31,739
and we brush Inge and all that of course

00:26:28,830 --> 00:26:33,659
this so moving out all the business

00:26:31,739 --> 00:26:35,729
logic from the legacy application into

00:26:33,659 --> 00:26:37,549
the service is a pretty hard task

00:26:35,729 --> 00:26:40,169
because there are a lot of dependencies

00:26:37,549 --> 00:26:40,480
we might not be able to do that in in

00:26:40,169 --> 00:26:43,210
the

00:26:40,480 --> 00:26:45,490
couple of months because for example as

00:26:43,210 --> 00:26:48,220
long as the checkout is also still

00:26:45,490 --> 00:26:49,780
sitting in the legacy application I need

00:26:48,220 --> 00:26:54,100
to have the cart data available there

00:26:49,780 --> 00:26:56,169
too so there's a lot of dependencies so

00:26:54,100 --> 00:26:58,540
moving this out is actually a pretty

00:26:56,169 --> 00:27:01,270
tough task and it will probably lead for

00:26:58,540 --> 00:27:04,240
a large cart service there has to be a

00:27:01,270 --> 00:27:06,010
lot of discussion with the business to

00:27:04,240 --> 00:27:08,380
figure out the real business rules that

00:27:06,010 --> 00:27:10,660
we want to have because we're not not we

00:27:08,380 --> 00:27:15,580
are not tied to the standard anymore

00:27:10,660 --> 00:27:18,760
provided by the legacy software so

00:27:15,580 --> 00:27:21,309
there's a lot going in here now when you

00:27:18,760 --> 00:27:24,010
write a service like this there's always

00:27:21,309 --> 00:27:28,179
a framework question right as with any

00:27:24,010 --> 00:27:30,340
project so and I'm not trying to go into

00:27:28,179 --> 00:27:33,880
some like framework war or anything I

00:27:30,340 --> 00:27:35,770
mean we have the usual big three and of

00:27:33,880 --> 00:27:37,299
course they all work for that you can of

00:27:35,770 --> 00:27:39,970
course create a micro service with all

00:27:37,299 --> 00:27:42,669
that it might just not be the best idea

00:27:39,970 --> 00:27:45,760
because if you look at for example an

00:27:42,669 --> 00:27:47,320
empty Symphony project there's a lot of

00:27:45,760 --> 00:27:49,000
code in there which makes sense because

00:27:47,320 --> 00:27:50,410
it's really powerful and can do a lot of

00:27:49,000 --> 00:27:53,650
stuff and there are all the components

00:27:50,410 --> 00:27:56,970
of course so you get something like

00:27:53,650 --> 00:28:00,850
around 120,000 logical lines of code and

00:27:56,970 --> 00:28:02,910
for micro service there's a lot of stuff

00:28:00,850 --> 00:28:06,340
in there you will definitely not need

00:28:02,910 --> 00:28:08,799
since the service is not exposed to the

00:28:06,340 --> 00:28:11,500
outside world you don't have something

00:28:08,799 --> 00:28:13,270
like CSRF tokens and you won't need to

00:28:11,500 --> 00:28:17,290
deal with sessions because they should

00:28:13,270 --> 00:28:20,919
be stateless and that's well a template

00:28:17,290 --> 00:28:22,179
engine probably is also not needed so

00:28:20,919 --> 00:28:26,530
there's a lot of stuff you won't need

00:28:22,179 --> 00:28:28,179
with the big frameworks that's one of

00:28:26,530 --> 00:28:30,100
the reasons why for every one of those

00:28:28,179 --> 00:28:32,679
three there's a micro framework

00:28:30,100 --> 00:28:34,330
available for this so we have Silex we

00:28:32,679 --> 00:28:38,590
have been expressive and we have lumen

00:28:34,330 --> 00:28:42,910
and pretty much all of them go down to

00:28:38,590 --> 00:28:45,390
having well just some components mostly

00:28:42,910 --> 00:28:48,190
reused from the big sub big frameworks

00:28:45,390 --> 00:28:50,860
to give you something that is more

00:28:48,190 --> 00:28:53,020
suitable for this approach there are

00:28:50,860 --> 00:28:54,960
also others like slim which gets more

00:28:53,020 --> 00:28:58,420
and more popular

00:28:54,960 --> 00:29:01,270
but it also follows the same idea and if

00:28:58,420 --> 00:29:03,970
we look at Slim's composer Jason a

00:29:01,270 --> 00:29:07,570
reduced example we already can see that

00:29:03,970 --> 00:29:11,170
it it also relies on existing components

00:29:07,570 --> 00:29:13,540
like pimple which is a di container and

00:29:11,170 --> 00:29:16,240
here we have Nikita Papa faster route

00:29:13,540 --> 00:29:18,760
for example and this is all constructed

00:29:16,240 --> 00:29:20,920
together this works pretty well by now

00:29:18,760 --> 00:29:23,440
because we have something like Pierce r7

00:29:20,920 --> 00:29:25,030
I mean you don't have to be a fan of the

00:29:23,440 --> 00:29:28,060
interface but having this interface

00:29:25,030 --> 00:29:30,820
allowed this kind of component based

00:29:28,060 --> 00:29:33,820
framework the end expressive would be

00:29:30,820 --> 00:29:35,020
another example as probably too dark but

00:29:33,820 --> 00:29:39,280
when you bootstrap and use and

00:29:35,020 --> 00:29:41,650
expressive project it basically asks you

00:29:39,280 --> 00:29:43,420
which kind of component you want to use

00:29:41,650 --> 00:29:44,950
for example for routing so you can also

00:29:43,420 --> 00:29:48,310
choose different implementations like

00:29:44,950 --> 00:29:51,040
fast route same goes for the eye and for

00:29:48,310 --> 00:29:56,730
the template engine so we still have a

00:29:51,040 --> 00:29:56,730
template engineer how we can deselect it

00:29:57,210 --> 00:30:02,350
anyway even though we have those micro

00:29:59,560 --> 00:30:04,420
frameworks with existing components at

00:30:02,350 --> 00:30:08,050
least we decided to not use any of those

00:30:04,420 --> 00:30:11,800
and by now it might not be that popular

00:30:08,050 --> 00:30:14,650
but of course you don't need to reinvent

00:30:11,800 --> 00:30:16,390
the wheel and it's not about that you

00:30:14,650 --> 00:30:18,970
don't have to write everything for

00:30:16,390 --> 00:30:23,230
yourself but actually it's pretty easy

00:30:18,970 --> 00:30:28,240
and there's an interesting learning in

00:30:23,230 --> 00:30:31,780
that so we did actually write our own

00:30:28,240 --> 00:30:35,260
framework for several reasons

00:30:31,780 --> 00:30:36,970
it's shortly about 500 logical lines of

00:30:35,260 --> 00:30:39,070
code and it does exactly what we need

00:30:36,970 --> 00:30:44,590
for something like micro service

00:30:39,070 --> 00:30:47,830
offering a restful api and well one of

00:30:44,590 --> 00:30:50,320
the reasons we did that is we have

00:30:47,830 --> 00:30:52,600
pretty strict standards when it comes to

00:30:50,320 --> 00:30:56,710
code quality and what we consider clean

00:30:52,600 --> 00:31:00,100
code and magic doesn't belong there in

00:30:56,710 --> 00:31:02,410
all of you so that was one of the key

00:31:00,100 --> 00:31:04,210
key ideas to write something that

00:31:02,410 --> 00:31:08,020
doesn't contain magic and by magic I

00:31:04,210 --> 00:31:11,350
mean having a string that by convention

00:31:08,020 --> 00:31:14,710
is mapped to whatever control down so

00:31:11,350 --> 00:31:18,160
you have your routes as strings that is

00:31:14,710 --> 00:31:20,650
what we consider magic at least and we

00:31:18,160 --> 00:31:22,360
also did it for the learning for the

00:31:20,650 --> 00:31:24,490
development teams it was really cool to

00:31:22,360 --> 00:31:26,650
see that it's actually not that hard to

00:31:24,490 --> 00:31:30,370
write something that routes requests in

00:31:26,650 --> 00:31:32,500
a clean way dealing with sessions

00:31:30,370 --> 00:31:35,560
well we didn't that do that here but for

00:31:32,500 --> 00:31:37,360
the HTTP framework we did it is also

00:31:35,560 --> 00:31:39,040
very straightforward and it's a cool

00:31:37,360 --> 00:31:41,340
learning to see how little code you

00:31:39,040 --> 00:31:43,360
actually need to properly do that

00:31:41,340 --> 00:31:45,730
doesn't mean that everyone has to do it

00:31:43,360 --> 00:31:47,410
like that we also don't advertise this

00:31:45,730 --> 00:31:49,180
to the outside world as hey you should

00:31:47,410 --> 00:31:51,370
use this because this is like the best

00:31:49,180 --> 00:31:53,740
way to do it not at all it's just our

00:31:51,370 --> 00:31:56,320
way of doing it and it's a cool way to

00:31:53,740 --> 00:31:59,260
publish this and well do some

00:31:56,320 --> 00:32:01,390
advertisement in in terms of okay if

00:31:59,260 --> 00:32:02,950
you're interested in how we work this is

00:32:01,390 --> 00:32:09,100
something you can look at this is how we

00:32:02,950 --> 00:32:12,460
write code right logical lines of code I

00:32:09,100 --> 00:32:14,470
briefly said that 500 whatever we use it

00:32:12,460 --> 00:32:16,360
at several projects it's it's cool it

00:32:14,470 --> 00:32:18,280
works for us and we like to be in

00:32:16,360 --> 00:32:22,230
control of all the code we have so we

00:32:18,280 --> 00:32:25,990
don't have external dependencies okay

00:32:22,230 --> 00:32:27,070
let's talk about deployment it's pretty

00:32:25,990 --> 00:32:28,810
much impossible to talk about

00:32:27,070 --> 00:32:32,800
microservices and deployment without

00:32:28,810 --> 00:32:35,830
mentioning docker that sort of always

00:32:32,800 --> 00:32:37,840
goes together and there's just some

00:32:35,830 --> 00:32:40,060
basic learnings we had when when

00:32:37,840 --> 00:32:43,720
starting to use docker especially for

00:32:40,060 --> 00:32:46,330
micro services first thing when you have

00:32:43,720 --> 00:32:50,860
a build process don't rely on docker hub

00:32:46,330 --> 00:32:53,620
images when doing builds it's totally

00:32:50,860 --> 00:32:55,330
fine to base your image on whatever the

00:32:53,620 --> 00:32:58,330
docker hub has to offer especially the

00:32:55,330 --> 00:33:03,270
official images with like a beige basic

00:32:58,330 --> 00:33:05,800
engine X or a Redis or maybe even PHP

00:33:03,270 --> 00:33:10,050
but sooner or later you will end up

00:33:05,800 --> 00:33:12,460
building your own darker base images and

00:33:10,050 --> 00:33:14,470
there's several reasons for that might

00:33:12,460 --> 00:33:16,540
be you want to have full control over

00:33:14,470 --> 00:33:18,010
what happens in that box you want to

00:33:16,540 --> 00:33:20,230
understand really what's going on there

00:33:18,010 --> 00:33:21,760
you don't want to rely on anyone who

00:33:20,230 --> 00:33:24,430
maintains a specific

00:33:21,760 --> 00:33:27,970
and maybe updates virgins in a way you

00:33:24,430 --> 00:33:29,890
don't want them to be updated it can

00:33:27,970 --> 00:33:32,410
also be that you don't want to have any

00:33:29,890 --> 00:33:34,840
like dependencies to external services

00:33:32,410 --> 00:33:39,030
in your build so maybe you want your

00:33:34,840 --> 00:33:39,030
host your own private registry and

00:33:39,090 --> 00:33:45,040
unfortunately building docker images

00:33:41,610 --> 00:33:50,440
really often comes down to writing bash

00:33:45,040 --> 00:33:51,850
like scripts in the docker file and of

00:33:50,440 --> 00:33:53,950
course there are nicer ways to do this

00:33:51,850 --> 00:33:57,700
and one recommendation to look at would

00:33:53,950 --> 00:34:00,100
be ansible container it's been around a

00:33:57,700 --> 00:34:02,020
while we have always used ansible for

00:34:00,100 --> 00:34:05,380
provisioning our development virtual

00:34:02,020 --> 00:34:07,840
machines it can easily be used to do

00:34:05,380 --> 00:34:10,060
server provisioning and ansible

00:34:07,840 --> 00:34:12,400
container is connecting your answer will

00:34:10,060 --> 00:34:13,960
play books and answer the roles with

00:34:12,400 --> 00:34:15,640
your doctor container so you can

00:34:13,960 --> 00:34:17,590
provision your docker images using

00:34:15,640 --> 00:34:19,360
ansible and it's really cool because you

00:34:17,590 --> 00:34:20,980
don't need to write batch like scripts

00:34:19,360 --> 00:34:22,870
anymore in your docker file but instead

00:34:20,980 --> 00:34:24,670
you use whatever answer the role you

00:34:22,870 --> 00:34:26,560
have and you apply them to a docker

00:34:24,670 --> 00:34:29,140
container and then create an image out

00:34:26,560 --> 00:34:31,150
of that so if you're lucky you can even

00:34:29,140 --> 00:34:32,470
reuse existing roles you have because

00:34:31,150 --> 00:34:36,610
maybe you manage your service using

00:34:32,470 --> 00:34:39,970
ansible and this can usually be done by

00:34:36,610 --> 00:34:41,830
a CI server like jenkins so you pull new

00:34:39,970 --> 00:34:45,340
code for the base image containing the

00:34:41,830 --> 00:34:47,200
answer Bowl playbook then answer the

00:34:45,340 --> 00:34:50,290
container builds the image we're just in

00:34:47,200 --> 00:34:52,870
tact and pushed to your registry or to

00:34:50,290 --> 00:34:55,210
the docker hub and then building the

00:34:52,870 --> 00:34:57,460
application image but essentially the

00:34:55,210 --> 00:34:59,770
same you can do some additional checks

00:34:57,460 --> 00:35:02,710
like running tests of course and then

00:34:59,770 --> 00:35:07,780
you just use your own base image that is

00:35:02,710 --> 00:35:11,290
really tailored to what you need ok

00:35:07,780 --> 00:35:12,250
quick excursion to the docker world now

00:35:11,290 --> 00:35:13,630
there's one thing that's easily

00:35:12,250 --> 00:35:17,110
forgotten when dealing with micro

00:35:13,630 --> 00:35:19,330
services and with api's in general and

00:35:17,110 --> 00:35:21,430
it always hurts really badly when you do

00:35:19,330 --> 00:35:23,380
it too late in the process and you

00:35:21,430 --> 00:35:27,280
notice it in the late stage of the

00:35:23,380 --> 00:35:28,810
project and that's versioning especially

00:35:27,280 --> 00:35:31,210
when you have a lot of micro services

00:35:28,810 --> 00:35:33,760
using it doesn't matter if it's like

00:35:31,210 --> 00:35:34,690
HTTP or a message queue sitting there

00:35:33,760 --> 00:35:37,060
for communicating

00:35:34,690 --> 00:35:39,730
you have this one API and there's one

00:35:37,060 --> 00:35:41,140
contract to the outside world and that

00:35:39,730 --> 00:35:43,599
needs to be versioned and you should do

00:35:41,140 --> 00:35:45,730
that like from the very start and not

00:35:43,599 --> 00:35:48,010
when you realize okay I need to make a

00:35:45,730 --> 00:35:50,069
breaking change to my API no what do I

00:35:48,010 --> 00:35:50,069
do

00:35:50,190 --> 00:35:54,880
normally you want micro services to be

00:35:52,930 --> 00:35:56,859
deployed individually so they shouldn't

00:35:54,880 --> 00:35:59,619
depend on any other deployments since

00:35:56,859 --> 00:36:02,589
they are autonomous anyway so let's say

00:35:59,619 --> 00:36:06,040
we have our sample set up again we have

00:36:02,589 --> 00:36:09,010
a card service in version 1 we have the

00:36:06,040 --> 00:36:11,880
core application in version 1 now we

00:36:09,010 --> 00:36:14,859
deploy a new version of the card service

00:36:11,880 --> 00:36:17,230
that might introduce a new API and maybe

00:36:14,859 --> 00:36:19,690
it changed the data structure that is

00:36:17,230 --> 00:36:25,270
needed in the request or maybe it

00:36:19,690 --> 00:36:26,980
changed the response body since you

00:36:25,270 --> 00:36:29,589
don't know when those two applications

00:36:26,980 --> 00:36:31,900
will be deployed and you cannot rely on

00:36:29,589 --> 00:36:34,140
the fact that they are reported deployed

00:36:31,900 --> 00:36:36,609
at the same time that never works anyway

00:36:34,140 --> 00:36:40,030
you will still need to provide a way to

00:36:36,609 --> 00:36:42,819
use the old API version so that your

00:36:40,030 --> 00:36:44,260
client can still communicate the same

00:36:42,819 --> 00:36:47,650
way with the service so you need to have

00:36:44,260 --> 00:36:50,560
a version 1 and version 2 ready so when

00:36:47,650 --> 00:36:54,220
you deploy a new core application for

00:36:50,560 --> 00:36:56,560
example that can then use version 1 then

00:36:54,220 --> 00:37:00,010
you can throw the version 2 then you can

00:36:56,560 --> 00:37:02,500
throw away version 1 and that's really

00:37:00,010 --> 00:37:05,290
crucial and even if you don't use HTTP

00:37:02,500 --> 00:37:08,260
but message queues you will also need

00:37:05,290 --> 00:37:10,930
that and actually it's not really about

00:37:08,260 --> 00:37:12,730
versioning the API it's also more

00:37:10,930 --> 00:37:14,380
importantly about versioning the data

00:37:12,730 --> 00:37:16,530
structures that you send around because

00:37:14,380 --> 00:37:19,000
that's that is what usually breaks

00:37:16,530 --> 00:37:21,310
compatibility with all the versions you

00:37:19,000 --> 00:37:23,380
change the JSON of the response body or

00:37:21,310 --> 00:37:26,020
you need a different kind of request

00:37:23,380 --> 00:37:27,670
parameter that's what you need to

00:37:26,020 --> 00:37:29,710
version so maybe just add a version

00:37:27,670 --> 00:37:32,980
number to your data structure and not to

00:37:29,710 --> 00:37:37,690
the URL of your API and deal with that

00:37:32,980 --> 00:37:40,000
accordingly so looking at all of this

00:37:37,690 --> 00:37:43,359
and starting to use microservices in our

00:37:40,000 --> 00:37:46,060
environment for everything we do right

00:37:43,359 --> 00:37:47,890
now every new project we start we always

00:37:46,060 --> 00:37:48,490
really ask ourselves the questions if

00:37:47,890 --> 00:37:52,840
something like

00:37:48,490 --> 00:37:55,530
this is what we actually need and most

00:37:52,840 --> 00:37:57,790
of the time it probably isn't

00:37:55,530 --> 00:38:01,960
micro-services can solve a lot of

00:37:57,790 --> 00:38:04,240
problems but most of them you probably

00:38:01,960 --> 00:38:07,570
don't even have or you only have

00:38:04,240 --> 00:38:08,220
symptoms but microservices don't really

00:38:07,570 --> 00:38:10,360
help you there

00:38:08,220 --> 00:38:12,790
what's cool about them is that they

00:38:10,360 --> 00:38:16,060
force you to think in domains and

00:38:12,790 --> 00:38:18,520
bounded context to size your services

00:38:16,060 --> 00:38:20,260
correctly but that is something that you

00:38:18,520 --> 00:38:23,200
can really do in your code and you don't

00:38:20,260 --> 00:38:25,230
need to use micro services for that they

00:38:23,200 --> 00:38:27,310
are especially cool when you need to

00:38:25,230 --> 00:38:29,530
scale your application on a very

00:38:27,310 --> 00:38:31,750
fine-grained level so you have that one

00:38:29,530 --> 00:38:33,550
check out service and it's insanely slow

00:38:31,750 --> 00:38:35,830
and you need to add three more instances

00:38:33,550 --> 00:38:37,420
of it so you can scale the service but

00:38:35,830 --> 00:38:39,580
you know don't need to touch the rest of

00:38:37,420 --> 00:38:42,220
your application that's cool but most of

00:38:39,580 --> 00:38:44,530
the time you don't have this problem on

00:38:42,220 --> 00:38:45,730
on the scale most of the time it's

00:38:44,530 --> 00:38:48,160
perfectly fine to scale the whole

00:38:45,730 --> 00:38:49,960
application and that's it because adding

00:38:48,160 --> 00:38:52,750
micro services also it just adds

00:38:49,960 --> 00:38:55,690
complexity to your infrastructure and it

00:38:52,750 --> 00:39:00,400
requires more maintenance and a really

00:38:55,690 --> 00:39:03,609
thorough planning and good setup of your

00:39:00,400 --> 00:39:06,640
deployment infrastructure and if you

00:39:03,609 --> 00:39:09,280
have a lot of teams and you can well

00:39:06,640 --> 00:39:12,100
separate them by using those services

00:39:09,280 --> 00:39:13,810
that might work pretty well for smaller

00:39:12,100 --> 00:39:15,490
teams I don't think you should go that

00:39:13,810 --> 00:39:17,560
way and we already had a talk earlier

00:39:15,490 --> 00:39:22,900
today I think about going monolith first

00:39:17,560 --> 00:39:28,030
that's definitely a good idea and my

00:39:22,900 --> 00:39:30,490
overall summary well I want to phrase it

00:39:28,030 --> 00:39:33,450
in a way that the swih manifesto was was

00:39:30,490 --> 00:39:36,760
phrasing it with prioritizing things and

00:39:33,450 --> 00:39:39,850
I would say always prioritize compromise

00:39:36,760 --> 00:39:41,050
code over compound eyes systems because

00:39:39,850 --> 00:39:44,490
it's more important that your code is

00:39:41,050 --> 00:39:47,560
capsulated and has clear boundaries and

00:39:44,490 --> 00:39:49,510
your systems probably don't need to have

00:39:47,560 --> 00:39:52,510
that unless you're really running on a

00:39:49,510 --> 00:39:55,090
large scale and have a lot of well

00:39:52,510 --> 00:39:59,960
traffic on your site and need very

00:39:55,090 --> 00:40:01,760
fine-grained horizontal scaling

00:39:59,960 --> 00:40:03,290
so this is the Oval learning and using

00:40:01,760 --> 00:40:05,450
something like the card service helped

00:40:03,290 --> 00:40:10,190
us you know figuring out the domain and

00:40:05,450 --> 00:40:11,960
defining bounded contexts but also it's

00:40:10,190 --> 00:40:16,820
a lot of work to keep this up and

00:40:11,960 --> 00:40:17,840
running and get it into production all

00:40:16,820 --> 00:40:21,140
right um

00:40:17,840 --> 00:40:24,340
that concludes the slides and we have a

00:40:21,140 --> 00:40:24,340
couple of minutes left for questions

00:40:24,760 --> 00:40:35,709
any questions no questions okay

00:40:30,750 --> 00:40:35,709

YouTube URL: https://www.youtube.com/watch?v=76klsIBDlww


