Title: API Tips from the Frontline | Anna Filina | IPC Spring 2017
Publication date: 2019-01-23
Playlist: International PHP Conference Spring 2017
Description: 
	Anna Filina (FooLab): Starting to write an API is an easy task, but you quickly stumble upon many obstacles and hard decisions. How to manage result pagination and input errors? How to handle write operations and file uploads? Join me as I share my tricks that allowed me to ship high-profile projects in record time while keeping the code clean and maintainable.
Captions: 
	00:00:05,450 --> 00:00:09,719
so welcome to the stock API tips from

00:00:08,460 --> 00:00:12,120
the front line

00:00:09,719 --> 00:00:14,219
this talk will not cover the very basics

00:00:12,120 --> 00:00:15,389
of what rest is this assumes that you

00:00:14,219 --> 00:00:17,220
already know that from other

00:00:15,389 --> 00:00:19,770
introductory talks or tutorials you may

00:00:17,220 --> 00:00:22,020
have read so this will build on top of

00:00:19,770 --> 00:00:25,800
those and provide some more practical

00:00:22,020 --> 00:00:28,410
examples the objectives of this talk

00:00:25,800 --> 00:00:29,970
well I've built many api's and I made a

00:00:28,410 --> 00:00:33,120
lot of mistakes along the way

00:00:29,970 --> 00:00:34,739
mistakes that I've since corrected and I

00:00:33,120 --> 00:00:37,890
want to make sure that you don't repeat

00:00:34,739 --> 00:00:42,510
my mistakes so that then you don't have

00:00:37,890 --> 00:00:44,670
to refactor everything halfway and I

00:00:42,510 --> 00:00:46,770
also want to help you overcome some

00:00:44,670 --> 00:00:49,440
common obstacles because when you start

00:00:46,770 --> 00:00:52,680
building an API what happens is that you

00:00:49,440 --> 00:00:54,120
run into these common hurdles and you're

00:00:52,680 --> 00:00:56,480
not quite sure how to deal with them

00:00:54,120 --> 00:00:58,770
what's the best practice here and there

00:00:56,480 --> 00:01:01,410
so I want to help you overcome some of

00:00:58,770 --> 00:01:05,040
those and I want to help you build

00:01:01,410 --> 00:01:06,900
elegance and pragmatic api's so I'll

00:01:05,040 --> 00:01:09,420
cover a lot of topics so I won't go too

00:01:06,900 --> 00:01:11,760
deep into the implementation at the end

00:01:09,420 --> 00:01:14,310
I will provide some links for you to

00:01:11,760 --> 00:01:17,850
look at for some more implementation

00:01:14,310 --> 00:01:20,759
ideas but I won't cover too much of that

00:01:17,850 --> 00:01:22,880
here this talk will focus on things like

00:01:20,759 --> 00:01:26,580
performance security testing

00:01:22,880 --> 00:01:29,130
architecture and so on but myself

00:01:26,580 --> 00:01:32,130
quickly I'm Anna Felina from Canada I do

00:01:29,130 --> 00:01:34,320
project rescue and I develop I train I

00:01:32,130 --> 00:01:35,130
speak at conferences and that's pretty

00:01:34,320 --> 00:01:38,280
much it

00:01:35,130 --> 00:01:41,970
let's talk about end points basically

00:01:38,280 --> 00:01:44,310
it's what URL to call when so you want

00:01:41,970 --> 00:01:47,189
to get some data what will be your URL

00:01:44,310 --> 00:01:49,560
and I mean the answer is really it's up

00:01:47,189 --> 00:01:51,090
to you but it helps if you follow a

00:01:49,560 --> 00:01:54,180
standard you can follow someone else's

00:01:51,090 --> 00:01:57,299
standard which can be helpful but then

00:01:54,180 --> 00:01:58,670
you can also adapt it to your needs or

00:01:57,299 --> 00:02:01,200
even you can come up with your own

00:01:58,670 --> 00:02:03,570
standard but at least stay consistent

00:02:01,200 --> 00:02:06,420
inside your own application and across

00:02:03,570 --> 00:02:08,099
your api's otherwise if you don't follow

00:02:06,420 --> 00:02:09,330
a standard what will happen is that

00:02:08,099 --> 00:02:11,610
you're gonna have to write a lot of

00:02:09,330 --> 00:02:13,470
documentation if you write documentation

00:02:11,610 --> 00:02:15,180
for one endpoint then it

00:02:13,470 --> 00:02:17,660
apply to all the other end points

00:02:15,180 --> 00:02:22,140
because you're following a consistent

00:02:17,660 --> 00:02:24,000
routing system so this was going to be

00:02:22,140 --> 00:02:25,470
somewhat on the pinyon ad talk and feel

00:02:24,000 --> 00:02:30,390
free to disagree on certain things

00:02:25,470 --> 00:02:32,070
that's fine let's talk about lists let's

00:02:30,390 --> 00:02:34,800
say we want to extract a list of

00:02:32,070 --> 00:02:37,560
products so simple API endpoint slash

00:02:34,800 --> 00:02:40,710
products you know with the prefix maybe

00:02:37,560 --> 00:02:42,180
API slash products will give you a list

00:02:40,710 --> 00:02:46,080
of the products that you have in the

00:02:42,180 --> 00:02:48,810
system you can also constrain that by

00:02:46,080 --> 00:02:51,090
categories or any other filters that you

00:02:48,810 --> 00:02:53,520
want if you want to constrain say by

00:02:51,090 --> 00:02:56,430
category you would say you know equal

00:02:53,520 --> 00:02:58,470
games comma movies and that way you can

00:02:56,430 --> 00:03:01,410
actually have multiple values without

00:02:58,470 --> 00:03:03,710
bothering with these complex URLs just

00:03:01,410 --> 00:03:06,030
use a comma to separate the two and

00:03:03,710 --> 00:03:09,420
category here doesn't necessarily mean

00:03:06,030 --> 00:03:11,310
that it correlates directly to a column

00:03:09,420 --> 00:03:13,410
in your database you shouldn't design

00:03:11,310 --> 00:03:16,710
your API is that way it should always

00:03:13,410 --> 00:03:18,180
have a meaning for your API but not

00:03:16,710 --> 00:03:19,560
necessarily for the database you will

00:03:18,180 --> 00:03:25,380
have to do some sort of translation

00:03:19,560 --> 00:03:28,290
behind the scenes you can by defaults

00:03:25,380 --> 00:03:31,200
fetch a little bit of data and then you

00:03:28,290 --> 00:03:35,850
can include additional things if you

00:03:31,200 --> 00:03:38,130
want so have a more complete data set

00:03:35,850 --> 00:03:40,470
when it gets back so let's say we're

00:03:38,130 --> 00:03:42,390
fetching a list of video games and we

00:03:40,470 --> 00:03:45,080
want to include platforms like is it

00:03:42,390 --> 00:03:49,440
available on PC on the Xbox Playstation

00:03:45,080 --> 00:03:52,050
whatever so we want to maybe have a sub

00:03:49,440 --> 00:03:55,260
object there for the product where we'll

00:03:52,050 --> 00:03:59,519
have the ID of the category the name the

00:03:55,260 --> 00:04:01,769
slug and maybe even a link to the image

00:03:59,519 --> 00:04:05,790
the icon for that platform so you can

00:04:01,769 --> 00:04:09,209
then display it in your shop you can

00:04:05,790 --> 00:04:11,280
sort you can sort by once again this

00:04:09,209 --> 00:04:14,100
does not correspond directly to it

00:04:11,280 --> 00:04:16,620
column necessarily in your database it's

00:04:14,100 --> 00:04:18,600
really up to you what you how you want

00:04:16,620 --> 00:04:21,870
to sort things by default let's say

00:04:18,600 --> 00:04:24,690
dates means that you sort from newest

00:04:21,870 --> 00:04:27,300
first newest releases to the oldest

00:04:24,690 --> 00:04:29,009
releases and by adding a - you actually

00:04:27,300 --> 00:04:31,440
reverse the sort and that's very useful

00:04:29,009 --> 00:04:34,349
because one it's really short easy to

00:04:31,440 --> 00:04:37,470
read and also you can then use comma to

00:04:34,349 --> 00:04:40,889
sort by multiple things without having

00:04:37,470 --> 00:04:43,710
an additional parameter in there saying

00:04:40,889 --> 00:04:46,379
you know sort order which is verbose but

00:04:43,710 --> 00:04:49,979
also it doesn't really help you easily

00:04:46,379 --> 00:04:52,860
have multiple sorting columns so that's

00:04:49,979 --> 00:04:55,229
very helpful and you can imagine it of

00:04:52,860 --> 00:04:58,440
course page number two page size a

00:04:55,229 --> 00:05:00,629
hundreds I would recommend that you

00:04:58,440 --> 00:05:03,030
always have default values for all of

00:05:00,629 --> 00:05:06,990
those so always have some sort of

00:05:03,030 --> 00:05:09,629
sorting by default make sure that you

00:05:06,990 --> 00:05:12,810
have some kind of pagination so that you

00:05:09,629 --> 00:05:15,659
don't you never never want to show all

00:05:12,810 --> 00:05:17,940
of the content of your database in a

00:05:15,659 --> 00:05:20,099
single request so always have some sort

00:05:17,940 --> 00:05:22,770
of pagination you can always by default

00:05:20,099 --> 00:05:26,400
assume that it's page number one and

00:05:22,770 --> 00:05:30,030
page sizes let's say 25 it's up to you

00:05:26,400 --> 00:05:32,940
what you want this to be and if he wants

00:05:30,030 --> 00:05:35,099
to have more ideas about how to how to

00:05:32,940 --> 00:05:37,710
design your endpoints you can find some

00:05:35,099 --> 00:05:39,000
more information on JSON API org and

00:05:37,710 --> 00:05:41,610
there's a link at the end of the slides

00:05:39,000 --> 00:05:45,240
and the slides will be tweeted so you'll

00:05:41,610 --> 00:05:47,880
have access to them as well and you can

00:05:45,240 --> 00:05:50,009
have things like language for example if

00:05:47,880 --> 00:05:52,979
you want to display your data in

00:05:50,009 --> 00:05:55,349
multiple languages so if you're you know

00:05:52,979 --> 00:05:58,830
descriptions are different you know

00:05:55,349 --> 00:06:01,050
based on the language then you you will

00:05:58,830 --> 00:06:04,440
be able to present it in a different way

00:06:01,050 --> 00:06:07,710
like that now things like language and

00:06:04,440 --> 00:06:09,810
even pagination can be sent instead of

00:06:07,710 --> 00:06:12,479
sending it in the query string you can

00:06:09,810 --> 00:06:15,090
also send it using headers but always

00:06:12,479 --> 00:06:18,810
think who your end user will be for that

00:06:15,090 --> 00:06:20,610
API is it developers in your company are

00:06:18,810 --> 00:06:23,069
these people you can actually train are

00:06:20,610 --> 00:06:25,020
these people you can support or are

00:06:23,069 --> 00:06:27,240
these just a whole bunch of people out

00:06:25,020 --> 00:06:31,979
there that you don't have control over

00:06:27,240 --> 00:06:34,409
and if you then adds this complexity

00:06:31,979 --> 00:06:35,969
like headers which doesn't sound too

00:06:34,409 --> 00:06:39,080
complex but for some people it is

00:06:35,969 --> 00:06:41,629
so having headers just as a low

00:06:39,080 --> 00:06:45,199
you know extra step in the learning

00:06:41,629 --> 00:06:48,289
curve and those inexperienced developers

00:06:45,199 --> 00:06:50,090
will have trouble consuming your API so

00:06:48,289 --> 00:06:53,270
if you're going to release it publicly

00:06:50,090 --> 00:06:56,270
then simplifying things might be

00:06:53,270 --> 00:06:58,849
advantageous for you let's say we want

00:06:56,270 --> 00:07:01,430
to fetch details of a product simple

00:06:58,849 --> 00:07:04,699
just use a slug or an ID any unique

00:07:01,430 --> 00:07:09,740
identifier there's no no really a

00:07:04,699 --> 00:07:13,490
problem to expose these sequential IDs

00:07:09,740 --> 00:07:15,710
because the API is public anyway so and

00:07:13,490 --> 00:07:19,990
then you can also include additional

00:07:15,710 --> 00:07:22,400
details for that product like photos

00:07:19,990 --> 00:07:27,669
like screenshots let's say if it's a

00:07:22,400 --> 00:07:29,990
video game reviews for that products and

00:07:27,669 --> 00:07:32,810
the output would look something like

00:07:29,990 --> 00:07:36,560
that so if it's a list I'd say we output

00:07:32,810 --> 00:07:41,270
two items with just the name Skyrim and

00:07:36,560 --> 00:07:43,940
civilization 5 I would always I always

00:07:41,270 --> 00:07:48,349
suggest that you in encapsulate that

00:07:43,940 --> 00:07:51,610
data in a data key so you have a key

00:07:48,349 --> 00:07:53,990
data and under that you put your results

00:07:51,610 --> 00:07:56,240
because I've seen many people will

00:07:53,990 --> 00:07:57,800
either put it at the roots which is a

00:07:56,240 --> 00:07:59,960
problem because then you cannot have

00:07:57,800 --> 00:08:01,839
metadata because you might want to

00:07:59,960 --> 00:08:04,490
provide additional information about

00:08:01,839 --> 00:08:08,240
this request you just did like how many

00:08:04,490 --> 00:08:11,180
pages total you have how many results so

00:08:08,240 --> 00:08:13,009
that you can then when you show the list

00:08:11,180 --> 00:08:15,020
in the front and you can then generate

00:08:13,009 --> 00:08:21,469
the pagination based on that information

00:08:15,020 --> 00:08:24,020
and the reason we use data instead of

00:08:21,469 --> 00:08:26,409
products is it just makes it more

00:08:24,020 --> 00:08:29,180
standard so you don't have to constantly

00:08:26,409 --> 00:08:31,219
when you try to consume the API you have

00:08:29,180 --> 00:08:33,159
to constantly expect a different key

00:08:31,219 --> 00:08:37,130
there so you have to guess what it is

00:08:33,159 --> 00:08:39,469
it's just simpler to use data and if you

00:08:37,130 --> 00:08:42,890
have a single result when it's a details

00:08:39,469 --> 00:08:47,800
page then just put the object under data

00:08:42,890 --> 00:08:51,440
without the array let's talk about verbs

00:08:47,800 --> 00:08:53,290
people are used to using gets all the

00:08:51,440 --> 00:08:55,970
time they just don't think

00:08:53,290 --> 00:08:59,300
about verbs when they communicate with

00:08:55,970 --> 00:09:01,759
api's so when people send Ajax requests

00:08:59,300 --> 00:09:04,069
by default it's going to be a get

00:09:01,759 --> 00:09:06,440
request but the thing is there are other

00:09:04,069 --> 00:09:10,970
verbs and you should use those verbs

00:09:06,440 --> 00:09:14,329
because if you use say get a get verb

00:09:10,970 --> 00:09:16,610
for a delete operation then some of

00:09:14,329 --> 00:09:19,069
these scraping your API would just

00:09:16,610 --> 00:09:22,910
delete all the objects because robots

00:09:19,069 --> 00:09:26,060
are not very smart so use appropriate

00:09:22,910 --> 00:09:30,920
verbs verbs that say crawler would not

00:09:26,060 --> 00:09:33,889
normally send to your API so then you

00:09:30,920 --> 00:09:38,660
you would post on products to create a

00:09:33,889 --> 00:09:41,600
new product you could put or patch on

00:09:38,660 --> 00:09:43,519
products one two updates that product so

00:09:41,600 --> 00:09:45,649
the difference between PUD and patch

00:09:43,519 --> 00:09:48,350
would be put is a complete replacement

00:09:45,649 --> 00:09:53,029
of the object that's there while patch

00:09:48,350 --> 00:09:55,250
will only modify the properties that you

00:09:53,029 --> 00:09:59,029
send so only some of the changes like a

00:09:55,250 --> 00:10:00,560
diff so that's the difference and then

00:09:59,029 --> 00:10:04,670
you can use delete to delete an

00:10:00,560 --> 00:10:08,420
individual product you may have noticed

00:10:04,670 --> 00:10:12,319
that all of the URLs have products

00:10:08,420 --> 00:10:14,000
plural with an S even if when we're

00:10:12,319 --> 00:10:16,100
talking about an individual product and

00:10:14,000 --> 00:10:19,009
this is again for consistency for

00:10:16,100 --> 00:10:22,699
simplification so that you don't have to

00:10:19,009 --> 00:10:24,170
maintain these arrays of you know what

00:10:22,699 --> 00:10:27,110
is the single or what is the plural

00:10:24,170 --> 00:10:29,300
version of this you just once you know

00:10:27,110 --> 00:10:31,939
you're dealing with products then

00:10:29,300 --> 00:10:35,000
everything is going to be products so

00:10:31,939 --> 00:10:39,370
it's going to be product / one product /

00:10:35,000 --> 00:10:43,370
- whether it's a single or multiple

00:10:39,370 --> 00:10:45,980
items and of course version your API

00:10:43,370 --> 00:10:47,930
some people ask me why even bother

00:10:45,980 --> 00:10:51,199
versioning we is just going to evolve

00:10:47,930 --> 00:10:53,630
well once again it depends who's the

00:10:51,199 --> 00:10:55,490
consumer of your API but even internally

00:10:53,630 --> 00:10:57,620
I find that versioning things helps

00:10:55,490 --> 00:10:59,630
because then when we want to refactor

00:10:57,620 --> 00:11:02,899
things we don't have to change

00:10:59,630 --> 00:11:05,959
everything or at least we don't have to

00:11:02,899 --> 00:11:06,529
worry about having an immediate impact

00:11:05,959 --> 00:11:08,389
on the

00:11:06,529 --> 00:11:10,790
our application so we can start

00:11:08,389 --> 00:11:13,670
rewriting parts of the application using

00:11:10,790 --> 00:11:15,889
the new version of the API the old parts

00:11:13,670 --> 00:11:18,290
will still keep working there they'll

00:11:15,889 --> 00:11:20,329
just be suboptimal and then when we're

00:11:18,290 --> 00:11:23,029
ready we'll move everything on to the

00:11:20,329 --> 00:11:25,819
next version so having serving multiple

00:11:23,029 --> 00:11:28,100
versions of your API as your business

00:11:25,819 --> 00:11:32,540
requirements evolve as you learn more

00:11:28,100 --> 00:11:34,759
about the problem domain your API will

00:11:32,540 --> 00:11:37,160
evolve it is inevitable

00:11:34,759 --> 00:11:40,579
so version it right away you conversion

00:11:37,160 --> 00:11:43,029
it using maybe the URL like slash v1 v2

00:11:40,579 --> 00:11:45,620
or you can also say that in headers

00:11:43,029 --> 00:11:48,649
depends on who your target audience is

00:11:45,620 --> 00:11:52,509
with how experienced they are so you can

00:11:48,649 --> 00:11:55,249
send the API version inside the headers

00:11:52,509 --> 00:11:57,920
request and response so how do you

00:11:55,249 --> 00:12:02,870
format things you know there's Jason

00:11:57,920 --> 00:12:05,629
there's HTML XML all of that you can you

00:12:02,870 --> 00:12:08,569
know by default serve JSON but you can

00:12:05,629 --> 00:12:11,600
also serve you know all of these formats

00:12:08,569 --> 00:12:14,540
with one endpoint if you want so let's

00:12:11,600 --> 00:12:16,879
say we do slash products you can do

00:12:14,540 --> 00:12:20,089
slash products with an accept header and

00:12:16,879 --> 00:12:23,660
then you can specify you know do you

00:12:20,089 --> 00:12:26,000
want to to receive JSON back do you want

00:12:23,660 --> 00:12:29,029
to receive XML back or maybe you just

00:12:26,000 --> 00:12:32,300
want to receive HTML right away so you

00:12:29,029 --> 00:12:35,269
can serve different formats based on

00:12:32,300 --> 00:12:36,680
what the person who requests the API

00:12:35,269 --> 00:12:39,139
based on what they provide in the

00:12:36,680 --> 00:12:43,309
headers they will receive a different

00:12:39,139 --> 00:12:46,899
formats in the output and yeah you can

00:12:43,309 --> 00:12:51,019
you can send other things and headers

00:12:46,899 --> 00:12:53,029
when you want to post some data to your

00:12:51,019 --> 00:12:56,329
API and I've seen a lot of people make

00:12:53,029 --> 00:12:59,589
this mistake they would send their data

00:12:56,329 --> 00:13:03,069
in the headers it's not inherently wrong

00:12:59,589 --> 00:13:06,069
but if you use something like you know

00:13:03,069 --> 00:13:06,069
application/x-www-form-urlencoded

00:13:19,580 --> 00:13:24,110
code it's hard to read also like it's

00:13:22,520 --> 00:13:27,140
not human readable when you want to

00:13:24,110 --> 00:13:30,440
debug things so I would recommend

00:13:27,140 --> 00:13:33,950
instead to use content type application

00:13:30,440 --> 00:13:36,830
JSON and then have your payload instead

00:13:33,950 --> 00:13:40,280
of like URL encoding it in the headers

00:13:36,830 --> 00:13:43,610
instead sends proper JSON in the body of

00:13:40,280 --> 00:13:46,130
the request people forget that the

00:13:43,610 --> 00:13:49,040
request also have about has a body both

00:13:46,130 --> 00:13:51,950
the request and the response are you

00:13:49,040 --> 00:13:54,320
know two sides of the same thing they

00:13:51,950 --> 00:13:58,540
have headers the they have a payloads in

00:13:54,320 --> 00:14:01,580
the body and you can just create

00:13:58,540 --> 00:14:03,260
standard JSON put it in the body you

00:14:01,580 --> 00:14:06,370
know with the content type application

00:14:03,260 --> 00:14:09,230
JSON and then post it on your endpoints

00:14:06,370 --> 00:14:11,420
and it's easy on the other out the other

00:14:09,230 --> 00:14:13,430
side you just grab that you do JSON

00:14:11,420 --> 00:14:17,000
decode and it's really easy to work with

00:14:13,430 --> 00:14:19,400
and it would look something like that

00:14:17,000 --> 00:14:25,190
know if you can see it in the back here

00:14:19,400 --> 00:14:28,250
so similar to how we extract the data we

00:14:25,190 --> 00:14:31,130
saw you know there was the data keyword

00:14:28,250 --> 00:14:34,510
there and then you know the the content

00:14:31,130 --> 00:14:36,530
the properties of the of the products

00:14:34,510 --> 00:14:39,980
you would do the same thing so it

00:14:36,530 --> 00:14:41,930
becomes sort of symmetrical and it's

00:14:39,980 --> 00:14:44,510
it's really it's really easy to write

00:14:41,930 --> 00:14:48,350
that way and it's as I said it's human

00:14:44,510 --> 00:14:51,200
readable so then you would be able to

00:14:48,350 --> 00:14:55,730
create a new product with that name and

00:14:51,200 --> 00:14:57,980
price so posting JSON is quite

00:14:55,730 --> 00:15:00,320
straightforward but what about files how

00:14:57,980 --> 00:15:02,870
do you upload files and a lot of people

00:15:00,320 --> 00:15:04,640
run into this problem early on I would

00:15:02,870 --> 00:15:08,690
recommend to use tools because doing

00:15:04,640 --> 00:15:12,350
applaud yourself can be a bit tricky if

00:15:08,690 --> 00:15:14,810
you're consuming the API on the

00:15:12,350 --> 00:15:17,060
client-side like a single page

00:15:14,810 --> 00:15:20,030
application or just standards you know

00:15:17,060 --> 00:15:22,040
just some JavaScript libraries you can

00:15:20,030 --> 00:15:26,210
use something called plop loads or

00:15:22,040 --> 00:15:29,180
equivalents basically it's done in two

00:15:26,210 --> 00:15:33,200
steps as you say drag and drop files

00:15:29,180 --> 00:15:35,900
onto this widget it will instantly

00:15:33,200 --> 00:15:38,450
load everything to some end point that

00:15:35,900 --> 00:15:41,030
you specify it will you know put the

00:15:38,450 --> 00:15:43,460
file their processes and from there it

00:15:41,030 --> 00:15:45,050
will return the temporary name of where

00:15:43,460 --> 00:15:46,910
it was stored then you grab that

00:15:45,050 --> 00:15:48,710
temporary name because you're still in

00:15:46,910 --> 00:15:50,300
the context of a form right you just did

00:15:48,710 --> 00:15:52,640
the drag-and-drop you haven't submitted

00:15:50,300 --> 00:15:54,440
the form yet but the file has already

00:15:52,640 --> 00:15:57,530
been uploaded and then what you get back

00:15:54,440 --> 00:16:01,760
is this this path basically to the new

00:15:57,530 --> 00:16:04,190
file and then you can when you submit

00:16:01,760 --> 00:16:06,620
the entire form you use that value to

00:16:04,190 --> 00:16:08,600
send to the API so when you do the Ajax

00:16:06,620 --> 00:16:10,850
request to save the data from the form

00:16:08,600 --> 00:16:12,770
let's say we're modifying a user profile

00:16:10,850 --> 00:16:16,100
there's the picture there's the email

00:16:12,770 --> 00:16:18,080
address there's other stuff in there so

00:16:16,100 --> 00:16:20,360
you you can then combine all of that

00:16:18,080 --> 00:16:21,950
send it to the API and you're done so

00:16:20,360 --> 00:16:24,710
you don't actually have to worry about

00:16:21,950 --> 00:16:28,280
how files are being uploaded to the API

00:16:24,710 --> 00:16:31,610
on the server side you can use something

00:16:28,280 --> 00:16:34,340
like ghazal or just curl and upload

00:16:31,610 --> 00:16:37,820
files that way so here's an example with

00:16:34,340 --> 00:16:40,310
plupload you just instantiate it you

00:16:37,820 --> 00:16:42,920
specify the run times in the order in

00:16:40,310 --> 00:16:48,080
which you want them to be processed so

00:16:42,920 --> 00:16:52,670
if the browser does not have html5 does

00:16:48,080 --> 00:16:55,310
not support html5 it will revert to HTML

00:16:52,670 --> 00:16:57,410
4 and so forth and if you want I mean

00:16:55,310 --> 00:16:59,210
it's still available but if you feel

00:16:57,410 --> 00:17:01,310
adventurous you can use flash or

00:16:59,210 --> 00:17:03,700
Silverlight if you still have faith in

00:17:01,310 --> 00:17:03,700
those things

00:17:04,010 --> 00:17:08,690
and then you specify the URL and you can

00:17:06,170 --> 00:17:10,640
also specify the max you know size and

00:17:08,690 --> 00:17:13,280
everything and the cool thing about this

00:17:10,640 --> 00:17:15,620
widget is that it allows you to drop

00:17:13,280 --> 00:17:17,990
multiple files onto it so Multi multi

00:17:15,620 --> 00:17:19,790
uploads you can drag and drop from from

00:17:17,990 --> 00:17:22,430
your desktop and you can even shrink

00:17:19,790 --> 00:17:26,959
images on the client side before sending

00:17:22,430 --> 00:17:29,510
them to the to this URL so this URL will

00:17:26,959 --> 00:17:32,510
be the one that you write to process the

00:17:29,510 --> 00:17:37,280
file upload it will it will be available

00:17:32,510 --> 00:17:40,640
for you under the files key and then you

00:17:37,280 --> 00:17:44,210
can you can return the path to where you

00:17:40,640 --> 00:17:46,850
just store the file and in the next in

00:17:44,210 --> 00:17:52,130
the second step you will actually do

00:17:46,850 --> 00:17:53,779
an ajax request to the API with ghazal a

00:17:52,130 --> 00:17:57,740
bit more code but it's actually

00:17:53,779 --> 00:18:02,389
straightforward you creates a new

00:17:57,740 --> 00:18:04,009
request to a URL and with with castle

00:18:02,389 --> 00:18:06,289
you can do everything in one go because

00:18:04,009 --> 00:18:08,149
the file is already available for you on

00:18:06,289 --> 00:18:09,769
the server as opposed to the client

00:18:08,149 --> 00:18:11,960
where it's not yet available on the

00:18:09,769 --> 00:18:15,019
server so you can do the the whole thing

00:18:11,960 --> 00:18:17,389
at once so you create a new request and

00:18:15,019 --> 00:18:20,090
then you create a post file you know

00:18:17,389 --> 00:18:23,120
where you open the file and you say this

00:18:20,090 --> 00:18:25,370
is this is what the the clients file

00:18:23,120 --> 00:18:28,129
name should be when it's received on the

00:18:25,370 --> 00:18:32,120
other end basically under what key to to

00:18:28,129 --> 00:18:34,669
store it and then you create the body of

00:18:32,120 --> 00:18:36,230
the request where you set all the fields

00:18:34,669 --> 00:18:38,809
you want you know the data with the

00:18:36,230 --> 00:18:41,750
first name and so on and then add the

00:18:38,809 --> 00:18:43,850
file there and send it to that end point

00:18:41,750 --> 00:18:46,250
and this end point will then receive the

00:18:43,850 --> 00:18:49,240
file and can process everything in a

00:18:46,250 --> 00:18:53,179
single request instead of multiple

00:18:49,240 --> 00:18:56,149
status codes I've seen a lot of Stack

00:18:53,179 --> 00:19:00,590
Overflow threads where people say but my

00:18:56,149 --> 00:19:03,500
API has specific codes when there's an

00:19:00,590 --> 00:19:06,230
error you know some validation error how

00:19:03,500 --> 00:19:09,230
do I send it in the HTTP status code

00:19:06,230 --> 00:19:11,570
well you don't because HTTP has nothing

00:19:09,230 --> 00:19:13,730
to do with your API the HTTP is a

00:19:11,570 --> 00:19:15,889
transport protocol it's really about

00:19:13,730 --> 00:19:17,750
what happened during the transport what

00:19:15,889 --> 00:19:19,759
happened on your application level is a

00:19:17,750 --> 00:19:22,129
completely different codes and should

00:19:19,759 --> 00:19:24,350
not be sent using the HTTP status code

00:19:22,129 --> 00:19:27,080
and I'll show in a second how to handle

00:19:24,350 --> 00:19:29,570
those so everything in to hundreds means

00:19:27,080 --> 00:19:32,779
some sort of success in the 300s

00:19:29,570 --> 00:19:35,659
redirect 400s client error means that

00:19:32,779 --> 00:19:37,519
the person sending the request made a

00:19:35,659 --> 00:19:41,529
mistake and should fix it and therefore

00:19:37,519 --> 00:19:44,240
it will it will then result in a success

00:19:41,529 --> 00:19:46,009
if you get a 500 error it means

00:19:44,240 --> 00:19:48,320
something went wrong on the server maybe

00:19:46,009 --> 00:19:51,049
the database is down maybe the there's a

00:19:48,320 --> 00:19:53,059
fatal error in the code somewhere so

00:19:51,049 --> 00:19:54,950
it's really on the server and there's

00:19:53,059 --> 00:19:56,960
nothing that the client can do to

00:19:54,950 --> 00:20:00,519
resolve that they just you know they

00:19:56,960 --> 00:20:03,279
should file a bug or come back later

00:20:00,519 --> 00:20:07,240
and if you have any API specific code

00:20:03,279 --> 00:20:11,169
send it in the body of the response so

00:20:07,240 --> 00:20:16,600
let's say you have a form where you let

00:20:11,169 --> 00:20:20,320
the person create a new or updates the

00:20:16,600 --> 00:20:22,600
price of products and what you would do

00:20:20,320 --> 00:20:24,820
if the price is incorrect is it's not a

00:20:22,600 --> 00:20:27,129
valid price then you would return the

00:20:24,820 --> 00:20:30,519
status code 400 which means bad user

00:20:27,129 --> 00:20:32,409
request and then in the body you would

00:20:30,519 --> 00:20:34,570
have the JSON with all the errors that

00:20:32,409 --> 00:20:36,850
happens and these errors can have a

00:20:34,570 --> 00:20:38,559
message in the code and that's the code

00:20:36,850 --> 00:20:41,139
that used in your API so when you

00:20:38,559 --> 00:20:42,879
document your API you would have like a

00:20:41,139 --> 00:20:44,529
thousand and one means that you know

00:20:42,879 --> 00:20:46,210
your price cannot be negative or

00:20:44,529 --> 00:20:47,799
something like that and it can has to be

00:20:46,210 --> 00:20:51,100
greater than zero because nothing is

00:20:47,799 --> 00:20:54,490
free so and if the user corrects the

00:20:51,100 --> 00:20:56,499
data if so the user would this will you

00:20:54,490 --> 00:20:58,749
know be forward these errors will be

00:20:56,499 --> 00:21:01,539
forwarded to the user they will see

00:20:58,749 --> 00:21:03,249
probably like a little message under the

00:21:01,539 --> 00:21:06,580
text field where they enter the price

00:21:03,249 --> 00:21:08,740
saying you have to fix this and as soon

00:21:06,580 --> 00:21:13,350
as they fix that they submit the data

00:21:08,740 --> 00:21:15,820
again and it will save and it will pass

00:21:13,350 --> 00:21:17,619
testing testing is actually not very

00:21:15,820 --> 00:21:21,490
complicated api's are some of the

00:21:17,619 --> 00:21:25,210
easiest things to test what you do is

00:21:21,490 --> 00:21:28,869
you you leverage the HTTP protocol

00:21:25,210 --> 00:21:31,960
basically you just send a request to an

00:21:28,869 --> 00:21:34,809
API endpoint and see what the output is

00:21:31,960 --> 00:21:36,909
and see whether the output is the JSON

00:21:34,809 --> 00:21:39,429
string that you expected to see so

00:21:36,909 --> 00:21:41,860
pretty straightforward and you can use

00:21:39,429 --> 00:21:44,440
guzzle or a lot of frameworks have

00:21:41,860 --> 00:21:46,299
built-in tools that's actually sort of

00:21:44,440 --> 00:21:49,179
bypass the HTTP and instead use the

00:21:46,299 --> 00:21:52,090
internal routing components so it

00:21:49,179 --> 00:21:55,749
actually saves a bit of the overheads so

00:21:52,090 --> 00:21:57,669
you can run those tests much faster so I

00:21:55,749 --> 00:22:00,220
mean I'm mostly familiar with symfony

00:21:57,669 --> 00:22:03,249
and it does include tools that allow me

00:22:00,220 --> 00:22:05,740
to not use HTTP protocol so I can call

00:22:03,249 --> 00:22:08,289
endpoints directly from from the test

00:22:05,740 --> 00:22:10,869
there so a ghazal test would look

00:22:08,289 --> 00:22:12,970
something like this let's say we test

00:22:10,869 --> 00:22:15,399
the api products

00:22:12,970 --> 00:22:19,600
we instantiate a new guzzle clients and

00:22:15,399 --> 00:22:22,690
then we send a get request to some some

00:22:19,600 --> 00:22:24,970
sort of URL in guzzle you would have to

00:22:22,690 --> 00:22:27,299
disable the exceptions because if it's a

00:22:24,970 --> 00:22:30,070
four hundred normally guzzle will

00:22:27,299 --> 00:22:32,620
generate an exception but you don't want

00:22:30,070 --> 00:22:34,120
that because it will affect your test

00:22:32,620 --> 00:22:36,720
you don't want your test to have an

00:22:34,120 --> 00:22:38,769
exception except instead you want to

00:22:36,720 --> 00:22:40,450
continue doing your things and then

00:22:38,769 --> 00:22:42,450
maybe the status code would be four

00:22:40,450 --> 00:22:45,639
hundred and or four hundred and four and

00:22:42,450 --> 00:22:48,399
you would be able to assert that so skip

00:22:45,639 --> 00:22:51,009
the exceptions send any headers you want

00:22:48,399 --> 00:22:54,100
and then you can check the status code

00:22:51,009 --> 00:22:56,049
see dance you know this URL resolves in

00:22:54,100 --> 00:22:59,049
something alternatively you can have

00:22:56,049 --> 00:23:03,039
another test with product number nine

00:22:59,049 --> 00:23:06,970
nine nine nine and then you will then

00:23:03,039 --> 00:23:11,139
have a sort equals 404 because that

00:23:06,970 --> 00:23:13,929
product does not exist and you can also

00:23:11,139 --> 00:23:18,309
compare the the body itself to make sure

00:23:13,929 --> 00:23:20,710
that the API returned the JSON that you

00:23:18,309 --> 00:23:24,429
expected it to return based on the data

00:23:20,710 --> 00:23:26,710
in your test database so you use

00:23:24,429 --> 00:23:29,559
something called a search JSON string

00:23:26,710 --> 00:23:31,090
equals JSON string now why use something

00:23:29,559 --> 00:23:34,120
like that when you have assert equals

00:23:31,090 --> 00:23:37,029
well actually if you use assert equals

00:23:34,120 --> 00:23:39,159
and you just mess up the indentation a

00:23:37,029 --> 00:23:41,740
bit it's not the same string anymore

00:23:39,159 --> 00:23:44,440
it's going to freak out but with this it

00:23:41,740 --> 00:23:47,799
won't and also let's say your name and

00:23:44,440 --> 00:23:50,320
price are switched in the output this

00:23:47,799 --> 00:23:52,029
method will also be okay with that so it

00:23:50,320 --> 00:23:55,090
doesn't matter and the cool thing is

00:23:52,029 --> 00:23:57,190
when something does go wrong it will

00:23:55,090 --> 00:23:59,620
actually show you like a div saying this

00:23:57,190 --> 00:24:01,960
is for this specific line this is what I

00:23:59,620 --> 00:24:05,769
expected this is what I got so you get a

00:24:01,960 --> 00:24:08,230
much nicer visualization than just these

00:24:05,769 --> 00:24:10,629
two massive strings perhaps are not

00:24:08,230 --> 00:24:13,600
equal and then you have to find the bug

00:24:10,629 --> 00:24:15,789
in its it's a bit complicated so really

00:24:13,600 --> 00:24:21,510
for testing purposes if you use JSON

00:24:15,789 --> 00:24:24,429
this is what you should do so when you

00:24:21,510 --> 00:24:26,650
write tests like that make sure that you

00:24:24,429 --> 00:24:29,200
have a separate database for your tests

00:24:26,650 --> 00:24:32,260
this database must not change or as

00:24:29,200 --> 00:24:34,660
little as possible it has to be very

00:24:32,260 --> 00:24:36,910
controlled so that you don't have to

00:24:34,660 --> 00:24:38,800
maintain your tests because let's say

00:24:36,910 --> 00:24:41,740
you add another product and you then

00:24:38,800 --> 00:24:42,820
test for a list of product the output

00:24:41,740 --> 00:24:44,680
will be different and you will

00:24:42,820 --> 00:24:46,180
constantly have to update your tests and

00:24:44,680 --> 00:24:48,340
you don't want to do that you want to

00:24:46,180 --> 00:24:51,010
work on your code not spend all of your

00:24:48,340 --> 00:24:53,350
time on tests and once the tests are

00:24:51,010 --> 00:24:56,050
done they should be fixed in time they

00:24:53,350 --> 00:24:58,180
should not the result of the test should

00:24:56,050 --> 00:25:02,070
not change based on the database it can

00:24:58,180 --> 00:25:05,740
only change if you messed up your code

00:25:02,070 --> 00:25:08,080
and another interesting thing that you

00:25:05,740 --> 00:25:10,090
and a big gain basically that you get

00:25:08,080 --> 00:25:12,370
from that approach from that kind of

00:25:10,090 --> 00:25:14,200
testing is that you can write those

00:25:12,370 --> 00:25:16,570
tests before you write any code you

00:25:14,200 --> 00:25:18,580
don't have to have any code written you

00:25:16,570 --> 00:25:20,380
just write the test you talk to the

00:25:18,580 --> 00:25:22,750
front-end developer you say well let's

00:25:20,380 --> 00:25:25,480
agree on this end points and for this

00:25:22,750 --> 00:25:26,110
end point we will have this output can

00:25:25,480 --> 00:25:28,510
we agree on that

00:25:26,110 --> 00:25:31,060
yes okay let's write the test it's here

00:25:28,510 --> 00:25:34,150
great now the front-end developer can

00:25:31,060 --> 00:25:36,240
use that information to start building

00:25:34,150 --> 00:25:39,240
their front-end so they can basically

00:25:36,240 --> 00:25:42,370
grab that JSON string put it in a file

00:25:39,240 --> 00:25:45,460
point their front-end to that file

00:25:42,370 --> 00:25:48,790
instead of the API and they can start

00:25:45,460 --> 00:25:50,380
building something functional and you on

00:25:48,790 --> 00:25:53,950
the other end the person building the

00:25:50,380 --> 00:25:55,840
API will then write enough code for this

00:25:53,950 --> 00:25:59,770
test to pass and when your test passes

00:25:55,840 --> 00:26:02,020
you're done so there is no period where

00:25:59,770 --> 00:26:04,000
you have to sort of join efforts and you

00:26:02,020 --> 00:26:06,880
know make things fit they will fit

00:26:04,000 --> 00:26:10,000
because the test will ensure that and

00:26:06,880 --> 00:26:11,980
using that so that does that test is the

00:26:10,000 --> 00:26:14,640
contract between you and whoever

00:26:11,980 --> 00:26:18,400
develops the client application beats

00:26:14,640 --> 00:26:20,950
JavaScript mobile whatever and using

00:26:18,400 --> 00:26:23,080
this approach I remember I coded a

00:26:20,950 --> 00:26:25,300
project a few years ago for the United

00:26:23,080 --> 00:26:28,810
Nations they only had six weeks until a

00:26:25,300 --> 00:26:31,210
conference in Kenya and they they wanted

00:26:28,810 --> 00:26:34,000
to at least be able to demo something to

00:26:31,210 --> 00:26:35,830
the audience and in six weeks using that

00:26:34,000 --> 00:26:38,890
approach with another kick-ass front-end

00:26:35,830 --> 00:26:40,580
developer we shipped the whole thing in

00:26:38,890 --> 00:26:44,210
six weeks it was done

00:26:40,580 --> 00:26:46,970
there were and and I'm not just saying

00:26:44,210 --> 00:26:49,880
that's you know out of nowhere it's it's

00:26:46,970 --> 00:26:52,039
actually zero bugs so there were

00:26:49,880 --> 00:26:55,190
absolutely no bugs in the application

00:26:52,039 --> 00:26:58,399
and a few months later they came back to

00:26:55,190 --> 00:27:02,899
us for some additional features but not

00:26:58,399 --> 00:27:05,630
a single complaint about a bug so it is

00:27:02,899 --> 00:27:07,659
a very very good approach to code the

00:27:05,630 --> 00:27:10,700
API that way

00:27:07,659 --> 00:27:14,840
authentication yes it's annoying

00:27:10,700 --> 00:27:15,440
do you hate coding authentication some

00:27:14,840 --> 00:27:18,620
of you do

00:27:15,440 --> 00:27:20,240
alright the others maybe you just you

00:27:18,620 --> 00:27:23,630
know you don't have an opinion about it

00:27:20,240 --> 00:27:28,730
because maybe haven't coded it okay I

00:27:23,630 --> 00:27:31,460
don't mean to judge anyway so you can

00:27:28,730 --> 00:27:36,470
have multiple methods of authenticating

00:27:31,460 --> 00:27:38,210
users but one thing you should not do is

00:27:36,470 --> 00:27:40,279
send a username and password in each

00:27:38,210 --> 00:27:44,510
request that is the absolute worst thing

00:27:40,279 --> 00:27:47,840
you could do especially if you have

00:27:44,510 --> 00:27:50,210
untrusted third parties so you would you

00:27:47,840 --> 00:27:52,460
know you wouldn't want to log in with

00:27:50,210 --> 00:27:54,139
your third party and constantly hammer

00:27:52,460 --> 00:27:56,510
them with your credentials and

00:27:54,139 --> 00:27:59,720
especially if there's no SSL of course

00:27:56,510 --> 00:28:01,909
in an ideal world you have SSL but in

00:27:59,720 --> 00:28:05,179
reality there are some environments that

00:28:01,909 --> 00:28:08,210
are just so messed up that you might not

00:28:05,179 --> 00:28:10,039
have any you might not have enough

00:28:08,210 --> 00:28:16,250
control over your environment you have

00:28:10,039 --> 00:28:19,399
SSL so yeah don't don't send that

00:28:16,250 --> 00:28:24,019
because in security what you have to

00:28:19,399 --> 00:28:27,019
remember is that you have there's the

00:28:24,019 --> 00:28:30,980
concept of surface of attack and by

00:28:27,019 --> 00:28:35,120
sending the the credentials constantly

00:28:30,980 --> 00:28:38,840
there are more opportunities for someone

00:28:35,120 --> 00:28:43,389
to grab a quest that contains the

00:28:38,840 --> 00:28:45,799
credentials so that becomes more risky

00:28:43,389 --> 00:28:48,169
you can have multiple authentication

00:28:45,799 --> 00:28:49,730
methods for a single API so you can use

00:28:48,169 --> 00:28:52,100
one authorized header if it's not

00:28:49,730 --> 00:28:53,300
present and try another type try another

00:28:52,100 --> 00:28:55,660
type

00:28:53,300 --> 00:28:58,790
so users can actually choose how they

00:28:55,660 --> 00:29:02,510
authenticate with with your API you can

00:28:58,790 --> 00:29:04,610
have multiple and I know that some

00:29:02,510 --> 00:29:06,920
people might disagree with me on that

00:29:04,610 --> 00:29:08,810
one and we'll probably throw stones at

00:29:06,920 --> 00:29:10,960
me for saying this but conceptually

00:29:08,810 --> 00:29:14,750
sessions are actually similar to tokens

00:29:10,960 --> 00:29:17,290
except that you should one use the

00:29:14,750 --> 00:29:20,330
database to store them so that you can

00:29:17,290 --> 00:29:23,540
scale it later so you have multiple

00:29:20,330 --> 00:29:27,610
servers don't use the file storage for

00:29:23,540 --> 00:29:31,190
your sessions and also don't store any

00:29:27,610 --> 00:29:34,340
session data in there so just create the

00:29:31,190 --> 00:29:36,290
session the so use the the cookie will

00:29:34,340 --> 00:29:38,870
become your token basically you just use

00:29:36,290 --> 00:29:39,950
the all the automation that comes with

00:29:38,870 --> 00:29:42,140
it

00:29:39,950 --> 00:29:44,450
so you know that a session exists in the

00:29:42,140 --> 00:29:48,230
database for this user therefore they're

00:29:44,450 --> 00:29:51,980
fine they have already logged in just

00:29:48,230 --> 00:29:54,200
don't don't store any activity of that

00:29:51,980 --> 00:29:55,970
session so since the user logged in you

00:29:54,200 --> 00:29:58,520
should not say the user has done this

00:29:55,970 --> 00:30:01,580
action or that action so don't store any

00:29:58,520 --> 00:30:03,170
state in it but if you look at that and

00:30:01,580 --> 00:30:05,390
you look at how tokens work you just

00:30:03,170 --> 00:30:09,380
draw the diagram conceptually they're

00:30:05,390 --> 00:30:13,190
exactly the same but other than that you

00:30:09,380 --> 00:30:15,230
can use OAuth was - so SSL is required

00:30:13,190 --> 00:30:17,540
to use that and you get advanced

00:30:15,230 --> 00:30:19,190
features like access code what is access

00:30:17,540 --> 00:30:23,090
code well let's say you want to comment

00:30:19,190 --> 00:30:25,670
on some blog and they say you need to

00:30:23,090 --> 00:30:27,590
log in through Facebook alright so it

00:30:25,670 --> 00:30:30,860
sends you to Facebook and then you have

00:30:27,590 --> 00:30:32,420
this message that says this application

00:30:30,860 --> 00:30:34,580
will be actually will be able to access

00:30:32,420 --> 00:30:37,070
your email address your profile your

00:30:34,580 --> 00:30:39,650
friends but it will not be able to post

00:30:37,070 --> 00:30:41,510
on your behalf so that is access cope

00:30:39,650 --> 00:30:44,060
you don't give them full control over

00:30:41,510 --> 00:30:46,250
over your accounts only certain things

00:30:44,060 --> 00:30:49,160
that you allow them so access code comes

00:30:46,250 --> 00:30:51,440
with oauth2 it can be overkill if you

00:30:49,160 --> 00:30:54,590
just need basic features like just allow

00:30:51,440 --> 00:30:56,570
the users to log in but the cool thing

00:30:54,590 --> 00:30:57,500
is that you can keep credentials

00:30:56,570 --> 00:31:00,500
privates

00:30:57,500 --> 00:31:02,000
from the third parties so it is mostly

00:31:00,500 --> 00:31:05,360
used when you have third parties

00:31:02,000 --> 00:31:06,320
involved here's an example let's say you

00:31:05,360 --> 00:31:07,700
have those

00:31:06,320 --> 00:31:09,559
three parties you have the user you have

00:31:07,700 --> 00:31:11,480
the clients application which can be

00:31:09,559 --> 00:31:16,179
let's say some mobile app you're using

00:31:11,480 --> 00:31:19,370
and your own application the API so

00:31:16,179 --> 00:31:22,610
somebody is going to login into your

00:31:19,370 --> 00:31:25,340
system on the some application will log

00:31:22,610 --> 00:31:27,049
into your system on the user's behalf so

00:31:25,340 --> 00:31:28,940
when the user makes a request here I

00:31:27,049 --> 00:31:31,130
want to see this the client application

00:31:28,940 --> 00:31:33,769
will say well you're not logged in to

00:31:31,130 --> 00:31:36,110
that application so forward you to the

00:31:33,769 --> 00:31:39,230
login form of that application so the

00:31:36,110 --> 00:31:41,720
API the login the login form is then

00:31:39,230 --> 00:31:43,460
returned directly to the user not going

00:31:41,720 --> 00:31:46,279
through the client app directly to the

00:31:43,460 --> 00:31:48,679
user and then the user will type in the

00:31:46,279 --> 00:31:51,200
credentials we'll send them once again

00:31:48,679 --> 00:31:53,710
directly to the API the third party is

00:31:51,200 --> 00:31:56,360
not involved in that part of the process

00:31:53,710 --> 00:31:57,950
then the username and password will be

00:31:56,360 --> 00:32:00,230
validated because that's where your

00:31:57,950 --> 00:32:02,259
account resides on the API it will be

00:32:00,230 --> 00:32:06,320
validated a token will be created and

00:32:02,259 --> 00:32:09,230
sent then to the third party that the

00:32:06,320 --> 00:32:11,000
one in the middle of the clients app so

00:32:09,230 --> 00:32:13,669
they say the mobile application will

00:32:11,000 --> 00:32:16,100
then have a token and that token can be

00:32:13,669 --> 00:32:19,549
used in the header of all subsequent

00:32:16,100 --> 00:32:22,639
requests to authorize that request so

00:32:19,549 --> 00:32:25,250
the API will will see that token and say

00:32:22,639 --> 00:32:27,019
oh yeah that's for this user and this

00:32:25,250 --> 00:32:29,029
user is authorized to access this and

00:32:27,019 --> 00:32:30,860
that or at least this app with this

00:32:29,029 --> 00:32:33,590
token is authorized to access this and

00:32:30,860 --> 00:32:37,370
that and will be able to respond

00:32:33,590 --> 00:32:40,610
correctly it's an extra layer but it

00:32:37,370 --> 00:32:46,039
really helps to hide credentials from a

00:32:40,610 --> 00:32:48,259
third party you can also use digest

00:32:46,039 --> 00:32:52,009
there's a lot more methods like web

00:32:48,259 --> 00:32:54,049
tokens and what not digest has its own

00:32:52,009 --> 00:32:56,539
encryption and that's good for people

00:32:54,049 --> 00:33:00,379
who are paranoid about SSL backdoors and

00:32:56,539 --> 00:33:03,529
possibly for a valid reason I especially

00:33:00,379 --> 00:33:06,200
see that in the financial sector they

00:33:03,529 --> 00:33:07,730
don't want to trust the infrastructure

00:33:06,200 --> 00:33:10,309
like I mean if there's another

00:33:07,730 --> 00:33:14,389
heartbleed all of their credentials will

00:33:10,309 --> 00:33:15,830
be visible digest is now actually pretty

00:33:14,389 --> 00:33:18,279
easy to implement because a lot of

00:33:15,830 --> 00:33:19,900
libraries have that out of the box

00:33:18,279 --> 00:33:25,150
frameworks have that

00:33:19,900 --> 00:33:26,560
front-end frameworks have that also at

00:33:25,150 --> 00:33:30,010
the cool thing about that is you have a

00:33:26,560 --> 00:33:33,580
nonce which means that you cannot send

00:33:30,010 --> 00:33:36,940
use the same so at the same token twice

00:33:33,580 --> 00:33:39,430
basically so even if one of your

00:33:36,940 --> 00:33:41,440
requests is intercepted and the token is

00:33:39,430 --> 00:33:43,750
extracted it cannot be used to

00:33:41,440 --> 00:33:46,750
authenticate the next request to

00:33:43,750 --> 00:33:48,340
authorize the next request because that

00:33:46,750 --> 00:33:51,120
one is no longer valid once the user

00:33:48,340 --> 00:33:54,760
completed that part completed that

00:33:51,120 --> 00:33:57,570
request that one is no longer valid it's

00:33:54,760 --> 00:33:57,570
only used once

00:33:58,710 --> 00:34:04,510
yeah the diagram for that is a lot

00:34:01,240 --> 00:34:06,820
simpler the user or client application

00:34:04,510 --> 00:34:09,429
in that case you cannot hide it from the

00:34:06,820 --> 00:34:11,440
third party the client application will

00:34:09,429 --> 00:34:13,480
have to have access to those credentials

00:34:11,440 --> 00:34:15,940
at all times

00:34:13,480 --> 00:34:17,500
it will create a generator request the

00:34:15,940 --> 00:34:19,000
API will see oh well you're not

00:34:17,500 --> 00:34:21,850
authorized to access that because you

00:34:19,000 --> 00:34:24,880
haven't sent us the digest it will reply

00:34:21,850 --> 00:34:29,800
with a nonce so basically like a number

00:34:24,880 --> 00:34:32,110
that can only be used once and then the

00:34:29,800 --> 00:34:33,730
request will there sorry then a next

00:34:32,110 --> 00:34:36,070
request the same request will be

00:34:33,730 --> 00:34:38,260
repeated but this time with a digest

00:34:36,070 --> 00:34:41,020
which will consist of the nonce and the

00:34:38,260 --> 00:34:43,179
password so there's there's functions

00:34:41,020 --> 00:34:45,610
for that and there's a link to an

00:34:43,179 --> 00:34:47,679
implementation example in PHP so you

00:34:45,610 --> 00:34:50,500
actually can just follow the code

00:34:47,679 --> 00:34:52,149
examples there and then when the judge s

00:34:50,500 --> 00:34:54,850
is received by the API it is then

00:34:52,149 --> 00:35:01,870
processed locates the user and

00:34:54,850 --> 00:35:04,300
authorizes the request now once you once

00:35:01,870 --> 00:35:06,640
you see all these API is you think well

00:35:04,300 --> 00:35:09,820
maybe I should switch my my big

00:35:06,640 --> 00:35:12,130
application to an API because I want to

00:35:09,820 --> 00:35:14,080
leverage that it makes things simpler

00:35:12,130 --> 00:35:15,730
because we want to build they care a lot

00:35:14,080 --> 00:35:18,580
more Java Script you know in our

00:35:15,730 --> 00:35:19,330
front-end so how do you refactor to the

00:35:18,580 --> 00:35:21,250
API

00:35:19,330 --> 00:35:24,460
well don't rewrite everything at once

00:35:21,250 --> 00:35:27,850
because most rewrites fail about 99% of

00:35:24,460 --> 00:35:29,740
them a progressive rewrite is where you

00:35:27,850 --> 00:35:31,930
would rewrite just one component or

00:35:29,740 --> 00:35:33,580
module at a time you start with whatever

00:35:31,930 --> 00:35:36,400
has fewer dependency

00:35:33,580 --> 00:35:38,230
on other components or something that is

00:35:36,400 --> 00:35:40,540
the most critical something that has to

00:35:38,230 --> 00:35:42,970
be moved now out of some legitimate

00:35:40,540 --> 00:35:44,560
concerns once you've done that make sure

00:35:42,970 --> 00:35:47,440
you delete the dead code don't leave it

00:35:44,560 --> 00:35:49,390
in there and if you do copy production

00:35:47,440 --> 00:35:51,640
data to the dev environment which you

00:35:49,390 --> 00:35:54,070
should because you know it's its legacy

00:35:51,640 --> 00:35:56,920
so you have to have that potentially

00:35:54,070 --> 00:35:59,110
garbage data so that you can catch all

00:35:56,920 --> 00:36:01,240
those errors but when you do that make

00:35:59,110 --> 00:36:03,580
sure you remove a you remove like credit

00:36:01,240 --> 00:36:08,350
card numbers email addresses and other

00:36:03,580 --> 00:36:11,500
private data from there now when you

00:36:08,350 --> 00:36:14,950
start writing things you can create

00:36:11,500 --> 00:36:17,140
services like that but in for those

00:36:14,950 --> 00:36:20,620
services you can create an underlying

00:36:17,140 --> 00:36:23,110
library so for example you would have

00:36:20,620 --> 00:36:27,610
some repository you know get API list

00:36:23,110 --> 00:36:30,490
and you provide the the filters for that

00:36:27,610 --> 00:36:33,130
so these two are equivalent right you

00:36:30,490 --> 00:36:36,700
have the products table and then

00:36:33,130 --> 00:36:38,590
category equal game alright so you

00:36:36,700 --> 00:36:40,180
create something like that and you have

00:36:38,590 --> 00:36:42,760
your own logic underneath that whatever

00:36:40,180 --> 00:36:45,820
get API list does in your system is

00:36:42,760 --> 00:36:49,780
entirely up to you it allows you to

00:36:45,820 --> 00:36:54,270
bypass HTTP because you you can either

00:36:49,780 --> 00:36:57,910
use that that line I just showed you

00:36:54,270 --> 00:37:00,880
inside the controller for that end

00:36:57,910 --> 00:37:03,220
points so that end point will resolve

00:37:00,880 --> 00:37:06,160
the filters will generate this request

00:37:03,220 --> 00:37:09,040
and that they get API list actually goes

00:37:06,160 --> 00:37:12,670
to the database and grabs the data but

00:37:09,040 --> 00:37:14,560
you can also put that in any other

00:37:12,670 --> 00:37:17,320
controller where you might need

00:37:14,560 --> 00:37:19,270
additional data instead of from a

00:37:17,320 --> 00:37:21,430
controller well let's say you do like I

00:37:19,270 --> 00:37:23,080
don't know a mailing list and you want

00:37:21,430 --> 00:37:24,610
to grab a whole bunch of data about your

00:37:23,080 --> 00:37:28,360
users about the products that are

00:37:24,610 --> 00:37:31,270
currently on special things like that so

00:37:28,360 --> 00:37:33,730
instead of going and requesting the

00:37:31,270 --> 00:37:37,000
endpoint which has the whole HTTP

00:37:33,730 --> 00:37:42,310
overheads you can just use you know get

00:37:37,000 --> 00:37:44,140
API lists directly so a lot of reuse so

00:37:42,310 --> 00:37:45,820
it will also allow you to fetch without

00:37:44,140 --> 00:37:46,960
pagination because it's the same

00:37:45,820 --> 00:37:48,820
application it's a

00:37:46,960 --> 00:37:51,760
components it's not something you would

00:37:48,820 --> 00:37:53,710
allow through the through the end point

00:37:51,760 --> 00:37:57,550
but something you can allow within the

00:37:53,710 --> 00:37:59,320
controller and the cool thing is that

00:37:57,550 --> 00:38:01,480
you can hydrate two models if you're not

00:37:59,320 --> 00:38:04,150
familiar with hydration lookup or RMS

00:38:01,480 --> 00:38:06,130
and how they do that but it's really

00:38:04,150 --> 00:38:08,170
cool because then you can have an actual

00:38:06,130 --> 00:38:11,109
model instead of just an array because

00:38:08,170 --> 00:38:13,300
JSON will only translate to an array you

00:38:11,109 --> 00:38:15,369
can have proper models and those models

00:38:13,300 --> 00:38:18,730
can have business logic and you can do

00:38:15,369 --> 00:38:21,550
some more fancy stuff some

00:38:18,730 --> 00:38:25,510
implementation tips so what do I do I

00:38:21,550 --> 00:38:27,700
use Bhosle MVC frameworks and RMS aside

00:38:25,510 --> 00:38:30,390
from that I like small libraries then

00:38:27,700 --> 00:38:33,880
don't that do not do too much magic

00:38:30,390 --> 00:38:36,609
because magic means abstraction and too

00:38:33,880 --> 00:38:39,250
much abstraction makes customizing hard

00:38:36,609 --> 00:38:41,470
so if I use a library that does a whole

00:38:39,250 --> 00:38:43,540
bunch of magic but then I need to do all

00:38:41,470 --> 00:38:46,000
of the grunt work in the configuration

00:38:43,540 --> 00:38:48,430
file I mean I would rather write PHP

00:38:46,000 --> 00:38:50,650
than learning how to configure this

00:38:48,430 --> 00:38:52,839
properly and perhaps still not achieve

00:38:50,650 --> 00:38:56,109
the exact result that I want so small

00:38:52,839 --> 00:38:59,170
libraries that do just one thing that

00:38:56,109 --> 00:39:04,150
allow me to do most of the stuff in PHP

00:38:59,170 --> 00:39:05,910
I would usually go for that when you

00:39:04,150 --> 00:39:08,859
write your code make sure that you

00:39:05,910 --> 00:39:10,839
streamline the endpoint creation

00:39:08,859 --> 00:39:12,760
you know you extract those request

00:39:10,839 --> 00:39:14,260
parameters the filters the sword the

00:39:12,760 --> 00:39:16,420
pagination you you extract them

00:39:14,260 --> 00:39:19,839
automatically and use that to maybe even

00:39:16,420 --> 00:39:21,220
automatically generate a query but make

00:39:19,839 --> 00:39:23,440
sure that you keep things still

00:39:21,220 --> 00:39:25,839
customizable so yeah you need a balance

00:39:23,440 --> 00:39:28,480
between automation and customization and

00:39:25,839 --> 00:39:30,339
if possible try to decouple your stuff

00:39:28,480 --> 00:39:32,770
from the framework because you might

00:39:30,339 --> 00:39:36,040
want to reuse that in other projects

00:39:32,770 --> 00:39:38,140
that use other frameworks or maybe you

00:39:36,040 --> 00:39:39,670
know you will eventually upgrade from an

00:39:38,140 --> 00:39:42,760
older version of the framework to a

00:39:39,670 --> 00:39:45,310
newer and things will break and the step

00:39:42,760 --> 00:39:47,230
will be so much that you would just not

00:39:45,310 --> 00:39:50,070
do it and keep using an old framework

00:39:47,230 --> 00:39:52,930
that doesn't have any support anymore

00:39:50,070 --> 00:39:55,440
performance you should benchmark your

00:39:52,930 --> 00:39:58,450
stuff if you haven't tried that before

00:39:55,440 --> 00:40:01,990
try even either sideways or black fire

00:39:58,450 --> 00:40:05,140
and then make your performance part of

00:40:01,990 --> 00:40:07,810
your test suite so in developer mode you

00:40:05,140 --> 00:40:10,150
can have a block like that so or rather

00:40:07,810 --> 00:40:12,310
in test mode you can have a block like

00:40:10,150 --> 00:40:14,470
that so in addition to the data and the

00:40:12,310 --> 00:40:16,570
pagination you can return something like

00:40:14,470 --> 00:40:18,220
this that will say how much time you

00:40:16,570 --> 00:40:20,050
spent in the database how much total

00:40:18,220 --> 00:40:22,540
time the request took how much memory

00:40:20,050 --> 00:40:25,060
was consumed and you can create

00:40:22,540 --> 00:40:27,430
assertions for that so if you exceed a

00:40:25,060 --> 00:40:29,859
certain threshold in the database you

00:40:27,430 --> 00:40:33,820
know that you maybe change the query in

00:40:29,859 --> 00:40:37,060
a way that now it's taking 20 times more

00:40:33,820 --> 00:40:40,720
time than it used to so that is very

00:40:37,060 --> 00:40:42,790
useful so you basically it will result

00:40:40,720 --> 00:40:45,330
in an error hey this is an error yes

00:40:42,790 --> 00:40:48,250
your your features work but your

00:40:45,330 --> 00:40:51,940
database is like really slow right now

00:40:48,250 --> 00:40:54,760
so you you just made a change that broke

00:40:51,940 --> 00:40:56,530
it so go see your query now so instead

00:40:54,760 --> 00:40:58,630
of doing that later and trying to figure

00:40:56,530 --> 00:41:01,930
out what has changed because you might

00:40:58,630 --> 00:41:04,270
have a long change log instead maybe you

00:41:01,930 --> 00:41:07,780
will be able to spot things those

00:41:04,270 --> 00:41:09,580
mistakes right when you make them some

00:41:07,780 --> 00:41:12,640
more performance tips don't use lady

00:41:09,580 --> 00:41:15,010
lazy loading or avoid it or use it in a

00:41:12,640 --> 00:41:16,690
smart way so when you write when use or

00:41:15,010 --> 00:41:19,119
m's you know some people they forget how

00:41:16,690 --> 00:41:20,830
to write SQL make sure you make joins

00:41:19,119 --> 00:41:25,810
you know if you get additional data

00:41:20,830 --> 00:41:28,780
about something craft your select select

00:41:25,810 --> 00:41:32,440
statements carefully don't just select

00:41:28,780 --> 00:41:34,000
start do select and grab only the fields

00:41:32,440 --> 00:41:36,730
that you need because if you're

00:41:34,000 --> 00:41:39,490
displaying a list was just ID name price

00:41:36,730 --> 00:41:41,650
then that's those are the only fields

00:41:39,490 --> 00:41:44,080
you should select don't transfer data

00:41:41,650 --> 00:41:48,460
that you will not output it's just a

00:41:44,080 --> 00:41:51,490
waste and if your RM has built-in

00:41:48,460 --> 00:41:54,040
hydration when you are going if you are

00:41:51,490 --> 00:41:56,589
just going to extract data and display

00:41:54,040 --> 00:41:59,770
to the user in JSON then there's no

00:41:56,589 --> 00:42:02,650
point in converting that data into a

00:41:59,770 --> 00:42:05,050
model which takes time and memory only

00:42:02,650 --> 00:42:08,710
so that you can serialize it back to a

00:42:05,050 --> 00:42:11,170
JSON so you can just bypass that order

00:42:08,710 --> 00:42:13,960
altogether by using the

00:42:11,170 --> 00:42:16,270
you're using doctrine it will be hydrate

00:42:13,960 --> 00:42:22,359
array so you will use that hydration

00:42:16,270 --> 00:42:24,549
mode to mitigate DDoS attacks use API

00:42:22,359 --> 00:42:26,920
keys even for public endpoints because

00:42:24,549 --> 00:42:30,579
then you can disable abusive keys very

00:42:26,920 --> 00:42:33,160
easily and cut cut them out you can even

00:42:30,579 --> 00:42:36,160
put like those block keys into memcache

00:42:33,160 --> 00:42:38,380
or Redis but you can also use memcache

00:42:36,160 --> 00:42:43,210
and Ready's for other things like lists

00:42:38,380 --> 00:42:45,700
that are a very common very frequent so

00:42:43,210 --> 00:42:47,680
by blocking an abusive key using Redis

00:42:45,700 --> 00:42:50,140
it means you can disconnect those

00:42:47,680 --> 00:42:55,030
earlier and not waste any processing

00:42:50,140 --> 00:42:56,890
power on bogus requests so yeah I'm

00:42:55,030 --> 00:42:58,900
actually good on time here are some

00:42:56,890 --> 00:43:01,180
useful links I will tweet those slides

00:42:58,900 --> 00:43:03,250
actually the links are you know the

00:43:01,180 --> 00:43:05,440
standard API formats that I showed you

00:43:03,250 --> 00:43:08,650
so mine is a bit of a modified version

00:43:05,440 --> 00:43:11,260
from that how to implement digest

00:43:08,650 --> 00:43:13,329
directly from the PHP manual and there's

00:43:11,260 --> 00:43:16,000
a book you can also read called build

00:43:13,329 --> 00:43:19,540
api's you won't hate by full surgeon you

00:43:16,000 --> 00:43:21,309
can buy it only in pub and that is the

00:43:19,540 --> 00:43:24,040
end of the presentation I will tweet the

00:43:21,309 --> 00:43:26,619
slides you can go to my blog every time

00:43:24,040 --> 00:43:28,660
I find problems you know and solutions

00:43:26,619 --> 00:43:31,000
to them I will usually document how I

00:43:28,660 --> 00:43:32,650
found the solution so you can avoid

00:43:31,000 --> 00:43:35,500
doing it yourself and just follow the

00:43:32,650 --> 00:43:38,349
process things I tried what worked what

00:43:35,500 --> 00:43:40,420
didn't I also have some poems there on

00:43:38,349 --> 00:43:43,320
my site so that can be fun and I will

00:43:40,420 --> 00:43:50,529
take some questions thank you

00:43:43,320 --> 00:43:58,869
[Applause]

00:43:50,529 --> 00:43:58,869
any questions yes

00:44:17,359 --> 00:44:23,130
there are tools that allow you to

00:44:19,619 --> 00:44:26,490
automatically document your API but

00:44:23,130 --> 00:44:30,089
those tools usually involve using those

00:44:26,490 --> 00:44:32,760
tools to generate an API for documenting

00:44:30,089 --> 00:44:34,980
it I could say you you can leverage the

00:44:32,760 --> 00:44:37,859
dog box so you have your controllers a

00:44:34,980 --> 00:44:40,830
controller is basically verb + endpoints

00:44:37,859 --> 00:44:43,290
and you can write your documentation in

00:44:40,830 --> 00:44:46,520
there and grab that and generates a

00:44:43,290 --> 00:44:49,349
manual out of it that's what I would do

00:44:46,520 --> 00:44:51,839
but usually if you follow a sort of

00:44:49,349 --> 00:44:55,380
standard practice like that it's kind of

00:44:51,839 --> 00:44:56,970
self documenting except if you're doing

00:44:55,380 --> 00:45:01,230
it for the public depends if it's

00:44:56,970 --> 00:45:02,940
internal or for the wider audience for

00:45:01,230 --> 00:45:07,290
the wider audience you would need proper

00:45:02,940 --> 00:45:10,430
documentation yeah does that help ok

00:45:07,290 --> 00:45:10,430
anyone else

00:46:02,900 --> 00:46:10,770
right so where where where should the

00:46:07,410 --> 00:46:13,260
validation be the API is your

00:46:10,770 --> 00:46:14,940
application really it's the one closest

00:46:13,260 --> 00:46:17,880
to your data and it's the one that

00:46:14,940 --> 00:46:19,380
should enforce rules this is the the one

00:46:17,880 --> 00:46:23,670
that should enforce the business rules

00:46:19,380 --> 00:46:25,680
if you want to perhaps also validate

00:46:23,670 --> 00:46:27,570
things on the front-end then maybe you

00:46:25,680 --> 00:46:30,090
can have different endpoints from which

00:46:27,570 --> 00:46:31,800
you can expose those rules to the

00:46:30,090 --> 00:46:34,350
front-end instead of rewriting them

00:46:31,800 --> 00:46:37,320
there I mean you don't want to duplicate

00:46:34,350 --> 00:46:39,180
those rules but really you you will

00:46:37,320 --> 00:46:41,430
still have to enforce that on the

00:46:39,180 --> 00:46:44,040
backend because let's say on the

00:46:41,430 --> 00:46:46,320
front-end you validate something but I

00:46:44,040 --> 00:46:48,930
can always just disable the validation

00:46:46,320 --> 00:46:52,230
or write my own current request and then

00:46:48,930 --> 00:46:54,570
send garbage data into the API and then

00:46:52,230 --> 00:46:57,600
will be stored in the database the API

00:46:54,570 --> 00:46:59,430
is the last line of defense before the

00:46:57,600 --> 00:47:03,120
database so it has to enforce those

00:46:59,430 --> 00:47:05,640
rules does that help a bit well maybe we

00:47:03,120 --> 00:47:07,260
can speak in more detail afterwards all

00:47:05,640 --> 00:47:10,130
right well thank you very much I'm out

00:47:07,260 --> 00:47:16,320
of time I enjoyed the coffee break

00:47:10,130 --> 00:47:16,320

YouTube URL: https://www.youtube.com/watch?v=cFeuZJNmkI0


