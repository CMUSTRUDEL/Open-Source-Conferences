Title: Crypto for Everyone – Libsodium in PHP 7.2 | Marcus Bointon | IPC 2018
Publication date: 2019-01-23
Playlist: International PHP Conference 2018
Description: 
	Marcus Bointon (Synchromedia Limited): PHP 7.2 includes the libsodium cryptography library by default in the base language – the first time that a popular language has shipped with strong, modern crypto support as standard. Everyone can build secure apps without the risks of rolling their own crypto or using outdated libraries. So what’s in libsodium? What kind of things can you do? What risks remain? You’ll get a tour of cryptographic functions, how they have been done in the past, and how to switch to libsodium to give you a security edge.
Captions: 
	00:00:00,160 --> 00:00:04,209
[Music]

00:00:06,710 --> 00:00:16,199
crypto for everyone this talk is about

00:00:11,480 --> 00:00:18,539
lip sodium in PHP 7.2 and but I'm also

00:00:16,199 --> 00:00:20,609
going to give you an overview of what

00:00:18,539 --> 00:00:23,910
cryptography is the kind of functions

00:00:20,609 --> 00:00:26,220
that we use it for how they're

00:00:23,910 --> 00:00:27,990
implemented in live sodium and what

00:00:26,220 --> 00:00:30,869
what's different about that compared

00:00:27,990 --> 00:00:34,170
with other cryptography things that

00:00:30,869 --> 00:00:34,850
we've had in PHP in the past so to start

00:00:34,170 --> 00:00:38,280
from the beginning

00:00:34,850 --> 00:00:41,059
what's crypto well let me tell you all

00:00:38,280 --> 00:00:44,100
about Bitcoin actually no let's joke

00:00:41,059 --> 00:00:46,590
crypto is about cryptography which is

00:00:44,100 --> 00:00:48,539
from Latin crypto meaning secret graphi

00:00:46,590 --> 00:00:51,059
meaning writing so it's a lot secret

00:00:48,539 --> 00:00:52,920
writing fundamentally it's about writing

00:00:51,059 --> 00:00:57,390
messages that can only be read by the

00:00:52,920 --> 00:01:02,370
intended recipient and we call that

00:00:57,390 --> 00:01:04,049
property confidentiality another thing

00:01:02,370 --> 00:01:06,270
that you might want to do is prove that

00:01:04,049 --> 00:01:09,600
it was you that wrote a message and we

00:01:06,270 --> 00:01:11,250
call that authenticity a flipside of

00:01:09,600 --> 00:01:13,950
authenticity is something called

00:01:11,250 --> 00:01:15,450
non-repudiation whereas if you've proved

00:01:13,950 --> 00:01:19,500
that you wrote something you can't

00:01:15,450 --> 00:01:21,270
simultaneously deny that you did it

00:01:19,500 --> 00:01:23,220
proves that you wrote something and you

00:01:21,270 --> 00:01:25,500
can't prove that you didn't reserve that

00:01:23,220 --> 00:01:26,490
that's a problem in it especially if

00:01:25,500 --> 00:01:28,530
you're using it for doing things like

00:01:26,490 --> 00:01:32,490
signing documents it proves that you did

00:01:28,530 --> 00:01:33,900
right you did do that the other property

00:01:32,490 --> 00:01:35,670
which were interested in is proving that

00:01:33,900 --> 00:01:37,740
a message has not been altered in

00:01:35,670 --> 00:01:40,140
transit or during during processing

00:01:37,740 --> 00:01:41,340
whatever and we call that integrity now

00:01:40,140 --> 00:01:42,840
each of these three properties

00:01:41,340 --> 00:01:45,329
confidential confidentiality

00:01:42,840 --> 00:01:46,740
authenticity and integrity are roughly

00:01:45,329 --> 00:01:48,299
orthogonal it's actually possible to

00:01:46,740 --> 00:01:50,610
have more or less each of them entirely

00:01:48,299 --> 00:01:52,320
separately and you can use different

00:01:50,610 --> 00:01:54,000
measures according to which of them you

00:01:52,320 --> 00:01:56,100
actually want typically though you

00:01:54,000 --> 00:01:58,790
probably want all three but it depends

00:01:56,100 --> 00:02:02,310
what it is you're actually doing so

00:01:58,790 --> 00:02:06,329
fundamental question really is do you

00:02:02,310 --> 00:02:08,849
need to use cryptography code at all if

00:02:06,329 --> 00:02:12,540
you refer only talking about serving

00:02:08,849 --> 00:02:13,620
your site over TLS no you don't you

00:02:12,540 --> 00:02:16,170
don't need to do any of this

00:02:13,620 --> 00:02:18,569
it's all taken care of by your delivery

00:02:16,170 --> 00:02:20,430
stack your webserver will typically deal

00:02:18,569 --> 00:02:22,050
with all the TLS stuff and for the most

00:02:20,430 --> 00:02:24,629
part you don't have to think about that

00:02:22,050 --> 00:02:28,650
in your own code you just get it to

00:02:24,629 --> 00:02:30,060
serve your PHP over TLS but there are

00:02:28,650 --> 00:02:31,920
lots of other circumstances where you do

00:02:30,060 --> 00:02:34,580
want to do stuff and the most common of

00:02:31,920 --> 00:02:37,019
those is typically authenticating users

00:02:34,580 --> 00:02:38,760
you might be saying doing something more

00:02:37,019 --> 00:02:41,849
involved like writing your own secure

00:02:38,760 --> 00:02:45,769
messaging app or you do something

00:02:41,849 --> 00:02:45,769
simpler like encrypting cookie values

00:02:47,150 --> 00:02:51,780
should you write your own crypto code

00:02:49,970 --> 00:02:57,410
well this is a fairly straightforward

00:02:51,780 --> 00:02:57,410
answer no or to put it another way no

00:02:59,900 --> 00:03:03,720
don't write your own crypto code there's

00:03:02,670 --> 00:03:05,549
nothing wrong with writing your own

00:03:03,720 --> 00:03:09,209
crypto code so long as you don't use it

00:03:05,549 --> 00:03:10,680
in public use established tested

00:03:09,209 --> 00:03:12,599
scrutinized algorithms and

00:03:10,680 --> 00:03:14,280
implementations not homebrew stuff

00:03:12,599 --> 00:03:17,639
because unless you're a genius

00:03:14,280 --> 00:03:18,989
cryptographer it even then only after

00:03:17,639 --> 00:03:20,639
you've had the rest of the world

00:03:18,989 --> 00:03:23,819
validate and inspect your code should

00:03:20,639 --> 00:03:25,940
you actually use it in public so don't

00:03:23,819 --> 00:03:28,859
write your own crypto code user library

00:03:25,940 --> 00:03:31,170
so what kind of things do cryptography

00:03:28,859 --> 00:03:32,849
libraries provide well we can divide

00:03:31,170 --> 00:03:34,920
things up all the cryptographic

00:03:32,849 --> 00:03:37,290
functions that you might run into we can

00:03:34,920 --> 00:03:39,480
divide them up into some groups roughly

00:03:37,290 --> 00:03:42,930
according to how many keys are involved

00:03:39,480 --> 00:03:45,389
in their use at the start we have

00:03:42,930 --> 00:03:47,669
because we're programmers zero keys and

00:03:45,389 --> 00:03:50,430
in this we have things like hashes

00:03:47,669 --> 00:03:52,889
pseudo-random number generators and key

00:03:50,430 --> 00:03:54,060
derivation and you'll find there's a

00:03:52,889 --> 00:03:56,669
whole load of algorithms with

00:03:54,060 --> 00:03:59,910
complicated and cryptic names like md5

00:03:56,669 --> 00:04:01,560
and sha-1 and argon and all these things

00:03:59,910 --> 00:04:03,209
now if you're not familiar with

00:04:01,560 --> 00:04:04,889
cryptography stuff you might have

00:04:03,209 --> 00:04:08,069
absolutely no idea what these things are

00:04:04,889 --> 00:04:09,900
and that in itself is a problem because

00:04:08,069 --> 00:04:11,760
it means you don't know you don't know

00:04:09,900 --> 00:04:14,180
if one of these is weak or strong or has

00:04:11,760 --> 00:04:18,539
problems or is slow or fast or

00:04:14,180 --> 00:04:20,639
inappropriate for certain scenarios then

00:04:18,539 --> 00:04:23,070
we have things like things that use one

00:04:20,639 --> 00:04:25,349
key and these are typically message

00:04:23,070 --> 00:04:26,400
authentication codes and secret key

00:04:25,349 --> 00:04:31,320
encryption

00:04:26,400 --> 00:04:33,060
now again it's hard to know what's safe

00:04:31,320 --> 00:04:36,030
and again we've got a whole list of

00:04:33,060 --> 00:04:38,699
weird names like Blowfish and Polly 1305

00:04:36,030 --> 00:04:40,590
and cha-cha ran a yes there's all these

00:04:38,699 --> 00:04:42,240
things that you might not have any idea

00:04:40,590 --> 00:04:46,020
what they mean and it's difficult to

00:04:42,240 --> 00:04:48,810
tell what it is that you should use then

00:04:46,020 --> 00:04:51,300
finally we have things that involve two

00:04:48,810 --> 00:04:52,560
keys and that really comes down to key

00:04:51,300 --> 00:04:55,949
exchange and public key encryption

00:04:52,560 --> 00:04:57,090
digital signatures and again there's a

00:04:55,949 --> 00:04:59,490
whole load of weird names associated

00:04:57,090 --> 00:05:01,590
with these things some of them are not

00:04:59,490 --> 00:05:04,260
obvious some of them have these weird

00:05:01,590 --> 00:05:05,729
numbers in now the numbers are actually

00:05:04,260 --> 00:05:06,960
quite interesting because I saw these

00:05:05,729 --> 00:05:08,610
things and it's like well why is it that

00:05:06,960 --> 00:05:12,750
number not some other value like poly

00:05:08,610 --> 00:05:15,090
1305 and x.25 five one nine these are

00:05:12,750 --> 00:05:17,190
actually related to the rat the prime

00:05:15,090 --> 00:05:19,199
numbers that are underlying the

00:05:17,190 --> 00:05:20,639
particular ciphers and cryptography

00:05:19,199 --> 00:05:23,580
cryptographic algorithms that are

00:05:20,639 --> 00:05:25,289
underneath them poly 1305 refers to a

00:05:23,580 --> 00:05:28,740
particular prime number which is two to

00:05:25,289 --> 00:05:31,229
the power of 130 minus five and two five

00:05:28,740 --> 00:05:35,760
five one nine is two to the power of 255

00:05:31,229 --> 00:05:38,400
minus nineteen that's much shorter than

00:05:35,760 --> 00:05:39,930
writing the number that actually is 2 to

00:05:38,400 --> 00:05:44,970
the power of 255 because that is a

00:05:39,930 --> 00:05:49,560
really really big number so it's just a

00:05:44,970 --> 00:05:50,820
kind of a shortcut there are also a

00:05:49,560 --> 00:05:52,620
whole bunch of functions which are

00:05:50,820 --> 00:05:54,900
effectively not cryptographic functions

00:05:52,620 --> 00:05:56,880
themselves but they're related and that

00:05:54,900 --> 00:05:59,460
covers things like encoding compression

00:05:56,880 --> 00:06:00,449
and mathematical operations so there we

00:05:59,460 --> 00:06:03,180
have things that you might be more

00:06:00,449 --> 00:06:05,160
familiar with things like base64 bin 2x

00:06:03,180 --> 00:06:09,300
but but more unusually things like hash

00:06:05,160 --> 00:06:12,530
equals now there's been a long history

00:06:09,300 --> 00:06:16,139
of cryptographic functions within PHP

00:06:12,530 --> 00:06:18,240
there have been a whole load of things

00:06:16,139 --> 00:06:21,360
that are in the core so we've got things

00:06:18,240 --> 00:06:24,060
like m hash m crypt open ssl and then

00:06:21,360 --> 00:06:26,280
more recently things like password hash

00:06:24,060 --> 00:06:33,900
hash equals random number generator and

00:06:26,280 --> 00:06:35,340
more recently lib sodium and these

00:06:33,900 --> 00:06:37,440
things all brought different things to

00:06:35,340 --> 00:06:38,940
the party you know m crypt was around

00:06:37,440 --> 00:06:39,960
for a very long time and that has lots

00:06:38,940 --> 00:06:42,300
of cryptographic function

00:06:39,960 --> 00:06:43,860
but unfortunately it's also really

00:06:42,300 --> 00:06:45,270
really old and crufty and nobody's

00:06:43,860 --> 00:06:47,190
really paying at any attention anymore

00:06:45,270 --> 00:06:50,789
and it's that makes it actually really

00:06:47,190 --> 00:06:53,759
quite unsafe to use the password hash

00:06:50,789 --> 00:06:54,960
function introduced in PHP 5.5 that was

00:06:53,759 --> 00:06:57,060
a really important thing because it

00:06:54,960 --> 00:06:58,380
finally brought a consistent

00:06:57,060 --> 00:07:00,300
straightforward way of using

00:06:58,380 --> 00:07:02,490
cryptographically secure hash functions

00:07:00,300 --> 00:07:05,070
into passwords and that's something that

00:07:02,490 --> 00:07:06,690
previously had shown what a problem not

00:07:05,070 --> 00:07:09,120
having that was if you look at things

00:07:06,690 --> 00:07:11,130
like WordPress they classically used md5

00:07:09,120 --> 00:07:13,289
for its passwords and not surprisingly

00:07:11,130 --> 00:07:18,660
this led to lots of sites being hacked

00:07:13,289 --> 00:07:21,479
because md5 is rubbish for passwords the

00:07:18,660 --> 00:07:23,940
random number generator in PHP 7 made

00:07:21,479 --> 00:07:25,889
the random number generation much more

00:07:23,940 --> 00:07:30,419
secure random number generation is an

00:07:25,889 --> 00:07:33,870
important feature in cryptography the

00:07:30,419 --> 00:07:34,580
Lib sodium extension actually existed in

00:07:33,870 --> 00:07:38,039
impecca

00:07:34,580 --> 00:07:40,289
4 existed for several years in pakil

00:07:38,039 --> 00:07:43,620
before the PHP 7 came along of course

00:07:40,289 --> 00:07:46,500
but um so it's actually available all

00:07:43,620 --> 00:07:47,520
the way back to PHP 5.6 however it was

00:07:46,500 --> 00:07:52,620
actually rolled into the base

00:07:47,520 --> 00:07:54,389
installation of PHP in PHP 7.2 so which

00:07:52,620 --> 00:07:56,280
extension should you use I've already

00:07:54,389 --> 00:07:58,080
mentioned that M crips is really rubbish

00:07:56,280 --> 00:08:01,800
in essentially if you're typing m crypt

00:07:58,080 --> 00:08:05,460
in an editor stop you're doing it wrong

00:08:01,800 --> 00:08:06,990
open SSL is kind of middle-ground one of

00:08:05,460 --> 00:08:09,120
the problems of the open SSL is that it

00:08:06,990 --> 00:08:11,849
really suffers from real legacy bloat

00:08:09,120 --> 00:08:13,289
and it's just got an enormous number of

00:08:11,849 --> 00:08:14,729
functions in it and some of them are

00:08:13,289 --> 00:08:16,470
really complicated but some of them are

00:08:14,729 --> 00:08:17,580
also really old but of course when

00:08:16,470 --> 00:08:19,110
you're actually just looking at a list

00:08:17,580 --> 00:08:20,580
of functions you can't tell which ones

00:08:19,110 --> 00:08:24,810
are new which are hold which is safe

00:08:20,580 --> 00:08:26,520
which are weak you just can't tell but

00:08:24,810 --> 00:08:28,320
on the other hand if you're talking to

00:08:26,520 --> 00:08:30,090
something at the other end which is also

00:08:28,320 --> 00:08:32,070
using open SSL there's nothing really

00:08:30,090 --> 00:08:33,630
quite like it if you want open SSL to

00:08:32,070 --> 00:08:37,349
talk to openness to sell them that's the

00:08:33,630 --> 00:08:38,789
thing to use but trade carefully if

00:08:37,349 --> 00:08:41,159
you're in control of both ends of the

00:08:38,789 --> 00:08:43,229
conversation then sodium is the obvious

00:08:41,159 --> 00:08:45,149
choice that would apply to doing things

00:08:43,229 --> 00:08:46,709
like writing your own secure messaging

00:08:45,149 --> 00:08:48,959
application or doing things like

00:08:46,709 --> 00:08:50,880
encrypting cookie values where although

00:08:48,959 --> 00:08:52,709
I say both ends of the conversation in

00:08:50,880 --> 00:08:53,430
that case both ends are actually in the

00:08:52,709 --> 00:08:55,320
same place

00:08:53,430 --> 00:08:56,580
because typically your encrypt send

00:08:55,320 --> 00:08:57,960
stuff to the client client send stuff

00:08:56,580 --> 00:08:59,340
back to you and you decrypt it so you

00:08:57,960 --> 00:09:00,870
encrypt and decrypt in the same place

00:08:59,340 --> 00:09:03,470
but it means that you're still in

00:09:00,870 --> 00:09:06,570
control of both ends of their processing

00:09:03,470 --> 00:09:08,400
now beyond extensions and core support

00:09:06,570 --> 00:09:09,750
there's also a whole bunch of PHP

00:09:08,400 --> 00:09:14,150
cryptography libraries which of course

00:09:09,750 --> 00:09:18,350
written in PHP pair has a whole bunch of

00:09:14,150 --> 00:09:20,910
cryptography functions PHP SEC Lib is a

00:09:18,350 --> 00:09:23,070
quite an extensive library provides lots

00:09:20,910 --> 00:09:25,290
of features and implements some

00:09:23,070 --> 00:09:27,120
high-level protocols like SSH on top of

00:09:25,290 --> 00:09:28,950
the basic cryptography functions however

00:09:27,120 --> 00:09:33,240
that particular one is actually based on

00:09:28,950 --> 00:09:35,280
M crypt so you shouldn't use it there

00:09:33,240 --> 00:09:36,960
are some other ones significant ones

00:09:35,280 --> 00:09:39,860
like for example Zend framework has its

00:09:36,960 --> 00:09:43,140
own built-in cryptography libraries and

00:09:39,860 --> 00:09:46,500
those are pretty reasonable you'll see

00:09:43,140 --> 00:09:49,050
this name Paragon these guys here this

00:09:46,500 --> 00:09:49,860
Paragon I can't know what the IU stands

00:09:49,050 --> 00:09:52,620
for

00:09:49,860 --> 00:09:55,160
Paragon is run by Scott R kazursky who

00:09:52,620 --> 00:09:57,690
will mention in a minute and he has

00:09:55,160 --> 00:09:59,670
several really useful and significant

00:09:57,690 --> 00:10:00,720
libraries sodium compat is very

00:09:59,670 --> 00:10:03,270
interesting it's a complete

00:10:00,720 --> 00:10:05,250
implementation of Lib sodium itself but

00:10:03,270 --> 00:10:06,900
written in PHP which means that you can

00:10:05,250 --> 00:10:09,690
just load it into a system which doesn't

00:10:06,900 --> 00:10:12,450
have it as an extension

00:10:09,690 --> 00:10:14,220
halite is a little bit like PHP Sekulow

00:10:12,450 --> 00:10:16,350
and then it it provides implementations

00:10:14,220 --> 00:10:19,560
as some higher-level things like SSH on

00:10:16,350 --> 00:10:22,290
top of sodium compact and sodium itself

00:10:19,560 --> 00:10:24,660
and just the other day he released this

00:10:22,290 --> 00:10:26,910
thing cipher suite which is a really

00:10:24,660 --> 00:10:29,070
nice little thing it's to help you store

00:10:26,910 --> 00:10:30,740
you've probably heard about things in

00:10:29,070 --> 00:10:33,810
conjunction with gdpr about having

00:10:30,740 --> 00:10:37,380
encrypting data at rest it allows you to

00:10:33,810 --> 00:10:39,000
do searches on encrypted data which is

00:10:37,380 --> 00:10:41,640
quite a clever trick which essentially

00:10:39,000 --> 00:10:42,840
involves encrypting the things that

00:10:41,640 --> 00:10:44,910
you're going to be searching for and

00:10:42,840 --> 00:10:46,470
indexing the encrypted versions of them

00:10:44,910 --> 00:10:48,090
knowing what it was that you encrypted

00:10:46,470 --> 00:10:49,620
in the first place which means that

00:10:48,090 --> 00:10:52,440
later on you can come and do searches

00:10:49,620 --> 00:10:53,850
that will match those fields even though

00:10:52,440 --> 00:10:56,670
you can't actually see the content

00:10:53,850 --> 00:10:58,110
itself that's really quite clever and

00:10:56,670 --> 00:10:59,640
he's wrapped it up in this library so

00:10:58,110 --> 00:11:01,020
there's a whole load of things but

00:10:59,640 --> 00:11:03,450
generally speaking you should prefer

00:11:01,020 --> 00:11:04,950
extensions over libraries just for

00:11:03,450 --> 00:11:08,130
performance reason cryptography stuff

00:11:04,950 --> 00:11:09,540
can be quite CPU intensive in particular

00:11:08,130 --> 00:11:12,540
so if performance is particularly

00:11:09,540 --> 00:11:16,260
critical aim for using the extensions

00:11:12,540 --> 00:11:19,800
rather than libraries so what is lib

00:11:16,260 --> 00:11:22,140
sodium well it all stems from this thing

00:11:19,800 --> 00:11:24,330
called salt which is a library called

00:11:22,140 --> 00:11:27,090
NaCl which is the networking and

00:11:24,330 --> 00:11:30,650
cryptography library and it has a nice

00:11:27,090 --> 00:11:34,590
website and they say all docs ery PDF is

00:11:30,650 --> 00:11:36,720
salt crypto and it's intended to be

00:11:34,590 --> 00:11:38,940
high-performance legacy free heavily

00:11:36,720 --> 00:11:40,800
scrutinized open-source seed library for

00:11:38,940 --> 00:11:42,750
cryptographic functions and in

00:11:40,800 --> 00:11:44,400
particular it's resistant to many forms

00:11:42,750 --> 00:11:46,770
of attack in the things that it's chosen

00:11:44,400 --> 00:11:49,490
to implement and it's also quite heavily

00:11:46,770 --> 00:11:54,030
defended against side-channel attacks

00:11:49,490 --> 00:11:56,010
Lib sodium is a fork of salt it's also

00:11:54,030 --> 00:11:59,820
open source which you can find at lib so

00:11:56,010 --> 00:12:01,650
Dean Borg it's relative to the original

00:11:59,820 --> 00:12:04,200
salt library it's supported on more

00:12:01,650 --> 00:12:06,420
platforms it's it's got bindings for

00:12:04,200 --> 00:12:08,910
more languages and it's also had its

00:12:06,420 --> 00:12:10,170
code audited so that's an important

00:12:08,910 --> 00:12:13,620
factor if you're doing cryptography

00:12:10,170 --> 00:12:16,670
stuff again it's been available in catch

00:12:13,620 --> 00:12:19,740
P vehicle but it's now standard in 7.2

00:12:16,670 --> 00:12:22,640
and there of course some people behind

00:12:19,740 --> 00:12:25,140
this Oh something I didn't mention their

00:12:22,640 --> 00:12:26,940
lib sodium actually is actually also

00:12:25,140 --> 00:12:29,670
available as well as being available in

00:12:26,940 --> 00:12:32,400
C which is how the the PHP extension is

00:12:29,670 --> 00:12:34,050
built it's also available in JavaScript

00:12:32,400 --> 00:12:37,440
and web assembly so you can actually use

00:12:34,050 --> 00:12:38,850
it client-side as well although you have

00:12:37,440 --> 00:12:41,960
some different problems on the client

00:12:38,850 --> 00:12:44,280
side especially involving key management

00:12:41,960 --> 00:12:47,460
because there are people behind all this

00:12:44,280 --> 00:12:49,500
salt itself is a product of in

00:12:47,460 --> 00:12:52,020
particular this name Daniel J Bernstein

00:12:49,500 --> 00:12:53,580
known as DJ B Tania Lang and Peter

00:12:52,020 --> 00:12:55,980
Schroeder at the University of I

00:12:53,580 --> 00:12:58,320
intervene in the Netherlands and lots of

00:12:55,980 --> 00:13:00,360
other people and lib sodium is mainly

00:12:58,320 --> 00:13:02,070
the product of Frank Dennis who's a

00:13:00,360 --> 00:13:04,650
developer and photographer from Paris

00:13:02,070 --> 00:13:06,540
he wrote the pure FTP D FTP server

00:13:04,650 --> 00:13:09,530
amongst other things and he's been a

00:13:06,540 --> 00:13:12,120
very longtime contributor to a PHP core

00:13:09,530 --> 00:13:13,950
you'll find his his fingerprints all

00:13:12,120 --> 00:13:16,500
over anything to do cryptography within

00:13:13,950 --> 00:13:20,010
PHP Scott R kazursky

00:13:16,500 --> 00:13:21,360
you'll find him on Twitter as well he's

00:13:20,010 --> 00:13:23,519
contributed an awful lot of

00:13:21,360 --> 00:13:25,350
extra stuff around the sides of lip

00:13:23,519 --> 00:13:27,720
sodium in particular documentation z'

00:13:25,350 --> 00:13:30,929
articles on how to do encryption safely

00:13:27,720 --> 00:13:34,439
particularly in PHP and you'll find lots

00:13:30,929 --> 00:13:37,259
of examples of how to use lib sodium on

00:13:34,439 --> 00:13:39,529
his website we'll get to documentation

00:13:37,259 --> 00:13:39,529
later

00:13:39,949 --> 00:13:45,420
so I mentioned side-channel attacks

00:13:42,149 --> 00:13:46,860
earlier now it's fairly likely if you're

00:13:45,420 --> 00:13:48,239
not into cryptographic stuff that you

00:13:46,860 --> 00:13:51,059
don't know what a side channel attack is

00:13:48,239 --> 00:13:52,980
well the Wikipedia definition is this

00:13:51,059 --> 00:13:54,660
any attack based on information gained

00:13:52,980 --> 00:13:56,429
from the physical implementation of a

00:13:54,660 --> 00:13:58,769
system rather than weaknesses in the

00:13:56,429 --> 00:14:00,899
implemented algorithm itself and that's

00:13:58,769 --> 00:14:03,179
why I like this picture here the gate is

00:14:00,899 --> 00:14:05,009
great it's perfect it does exactly the

00:14:03,179 --> 00:14:06,600
job it is intended to do however the way

00:14:05,009 --> 00:14:08,670
that it's been implemented means you can

00:14:06,600 --> 00:14:10,319
just walk around it so it completely

00:14:08,670 --> 00:14:12,209
fails to achieve the level of security

00:14:10,319 --> 00:14:16,980
you set out to do but it's not the gates

00:14:12,209 --> 00:14:18,989
fault so what does these actually

00:14:16,980 --> 00:14:22,379
manifest themselves in in practical

00:14:18,989 --> 00:14:25,049
senses in in software it really refers

00:14:22,379 --> 00:14:27,299
to other ways that information can be

00:14:25,049 --> 00:14:29,279
extracted from a system that are not

00:14:27,299 --> 00:14:32,249
quite what you might expect and the most

00:14:29,279 --> 00:14:34,410
common ones of those are timing thermal

00:14:32,249 --> 00:14:37,350
emissions RF emissions light sound and

00:14:34,410 --> 00:14:39,360
power consumption there are all ways

00:14:37,350 --> 00:14:42,749
that systems leak information is often

00:14:39,360 --> 00:14:44,910
in very subtle ways that can actually

00:14:42,749 --> 00:14:46,860
result in people being able to extract

00:14:44,910 --> 00:14:49,889
data from places that they shouldn't be

00:14:46,860 --> 00:14:51,419
able to extract data from recent

00:14:49,889 --> 00:14:54,089
examples of that have been extremely

00:14:51,419 --> 00:14:57,779
high-profile the recent specter and

00:14:54,089 --> 00:15:00,989
meltdown vulnerabilities in pretty much

00:14:57,779 --> 00:15:04,110
all Intel CPUs they are effectively a

00:15:00,989 --> 00:15:07,290
timing side channel that allowed it to

00:15:04,110 --> 00:15:09,600
basically get access to memory that it

00:15:07,290 --> 00:15:11,639
shouldn't have been able to corrupt

00:15:09,600 --> 00:15:14,189
things and obtain information that

00:15:11,639 --> 00:15:15,360
shouldn't be obtained another simple

00:15:14,189 --> 00:15:17,699
example I saw which was really quite

00:15:15,360 --> 00:15:18,959
funny so some years ago you know get

00:15:17,699 --> 00:15:21,360
Ethernet switches they have a little

00:15:18,959 --> 00:15:22,739
lights that blink on and off cheap

00:15:21,360 --> 00:15:25,139
switches what they do is they just

00:15:22,739 --> 00:15:30,179
connected the LEDs on the front to the

00:15:25,139 --> 00:15:32,399
data lines and LEDs switch very fast and

00:15:30,179 --> 00:15:34,319
so if you could just read the lights you

00:15:32,399 --> 00:15:35,100
point a light sensor at them you could

00:15:34,319 --> 00:15:36,750
just

00:15:35,100 --> 00:15:38,730
watch the data and actually just have

00:15:36,750 --> 00:15:40,920
the data pouring out of the port into

00:15:38,730 --> 00:15:42,420
the led after the LED and you could just

00:15:40,920 --> 00:15:44,190
read the data that was on the network

00:15:42,420 --> 00:15:47,700
without actually having to be physically

00:15:44,190 --> 00:15:51,300
connected to it that's a light emission

00:15:47,700 --> 00:15:52,560
side channel attack now timing is is

00:15:51,300 --> 00:15:54,290
really the critical one and the one that

00:15:52,560 --> 00:15:57,180
you're actually most likely to run into

00:15:54,290 --> 00:15:58,830
so here's an example this is some PHP

00:15:57,180 --> 00:16:02,160
code which is vulnerable to a timing

00:15:58,830 --> 00:16:04,320
side channel it's also done the

00:16:02,160 --> 00:16:07,380
old-style so we're creating a password

00:16:04,320 --> 00:16:08,760
with a row we're hashing a password

00:16:07,380 --> 00:16:11,100
that's been submitted by a user so

00:16:08,760 --> 00:16:14,280
presumably this is some login page we

00:16:11,100 --> 00:16:16,770
then do a mask ul lookup where we select

00:16:14,280 --> 00:16:18,510
from the database and you notice that

00:16:16,770 --> 00:16:20,430
we're we're matching the email address

00:16:18,510 --> 00:16:22,440
which is fixed for now and the password

00:16:20,430 --> 00:16:25,350
is just the one that was passed here

00:16:22,440 --> 00:16:26,970
that was this this hash of course we're

00:16:25,350 --> 00:16:28,950
not escaping it but that doesn't really

00:16:26,970 --> 00:16:32,340
matter because it's only a hash but of

00:16:28,950 --> 00:16:33,750
course you should normally now the

00:16:32,340 --> 00:16:36,660
critical thing here is that this

00:16:33,750 --> 00:16:39,360
comparison between the password field in

00:16:36,660 --> 00:16:42,840
the database and the past value is done

00:16:39,360 --> 00:16:44,630
by the database and the problem there is

00:16:42,840 --> 00:16:46,920
that the database is optimized for speed

00:16:44,630 --> 00:16:48,000
so if you imagine we've got two strings

00:16:46,920 --> 00:16:49,440
there's the one that we're comparing

00:16:48,000 --> 00:16:50,880
against them the one in the field in the

00:16:49,440 --> 00:16:52,500
database and we're going to compare

00:16:50,880 --> 00:16:55,320
these side-by-side character by

00:16:52,500 --> 00:16:56,820
character and the thing is that the

00:16:55,320 --> 00:16:58,890
databases interest is to be able to

00:16:56,820 --> 00:17:01,740
return from this as fast as possible and

00:16:58,890 --> 00:17:03,000
so it compares the first characters they

00:17:01,740 --> 00:17:04,770
might match the second characters they

00:17:03,000 --> 00:17:08,400
might match the character doesn't match

00:17:04,770 --> 00:17:11,310
so it returns immediately but then say

00:17:08,400 --> 00:17:12,630
this password is quite long and all the

00:17:11,310 --> 00:17:14,430
characters are correct apart from the

00:17:12,630 --> 00:17:16,380
last one that one's gonna take very

00:17:14,430 --> 00:17:18,510
slightly longer to return from this

00:17:16,380 --> 00:17:20,160
function call and if you do this a

00:17:18,510 --> 00:17:22,950
sufficient number of times it's actually

00:17:20,160 --> 00:17:24,810
possible to guess the password character

00:17:22,950 --> 00:17:27,180
by character by just doing often

00:17:24,810 --> 00:17:29,730
millions of requests this is why you

00:17:27,180 --> 00:17:31,140
need to look out for things like locking

00:17:29,730 --> 00:17:34,350
out people that make too many password

00:17:31,140 --> 00:17:35,820
guesses so this is a side channel attack

00:17:34,350 --> 00:17:38,700
that leaks information through the

00:17:35,820 --> 00:17:40,800
timing but there are better ways to do

00:17:38,700 --> 00:17:44,760
this so this is how you do it safely

00:17:40,800 --> 00:17:46,470
using standard PHP now the query that

00:17:44,760 --> 00:17:48,780
we've got here you'll notice that it

00:17:46,470 --> 00:17:50,790
doesn't have a comparison with the past

00:17:48,780 --> 00:17:53,520
word it just fetches the whole record

00:17:50,790 --> 00:17:55,470
that matches the user ID this is

00:17:53,520 --> 00:17:59,480
actually vulnerable to a user

00:17:55,470 --> 00:18:02,040
enumeration thing that it will tell you

00:17:59,480 --> 00:18:03,330
if this this value here is being passed

00:18:02,040 --> 00:18:05,550
in you could use it to tell whether

00:18:03,330 --> 00:18:07,410
users exist on the system or not but

00:18:05,550 --> 00:18:09,980
generally that's probably not quite such

00:18:07,410 --> 00:18:13,350
an interesting thing as their password

00:18:09,980 --> 00:18:15,990
we fetch the whole row and then we run

00:18:13,350 --> 00:18:18,600
it through this function here password

00:18:15,990 --> 00:18:23,760
verify which compares the past in

00:18:18,600 --> 00:18:25,800
password that we used with the the hash

00:18:23,760 --> 00:18:28,260
that we had stored in the database now

00:18:25,800 --> 00:18:30,510
this this function here password verify

00:18:28,260 --> 00:18:32,730
has been very carefully written so that

00:18:30,510 --> 00:18:35,520
no matter how long the passwords and

00:18:32,730 --> 00:18:37,620
however well or badly the passwords

00:18:35,520 --> 00:18:39,300
match it always returns in the same

00:18:37,620 --> 00:18:41,250
amount of time this is known as a

00:18:39,300 --> 00:18:43,140
constant time function and that means

00:18:41,250 --> 00:18:44,970
that it's immune to a timing side

00:18:43,140 --> 00:18:47,280
channel attack it doesn't matter how

00:18:44,970 --> 00:18:48,960
long or complicated it is it will always

00:18:47,280 --> 00:18:50,340
take the same amount of time to return

00:18:48,960 --> 00:18:52,980
so that means it's deliberately

00:18:50,340 --> 00:18:56,310
inefficient but it also makes it more

00:18:52,980 --> 00:18:59,190
secure as a result now to do the same

00:18:56,310 --> 00:19:01,050
thing in Lib sodium we have this

00:18:59,190 --> 00:19:06,180
function here lift sodium you'll find is

00:19:01,050 --> 00:19:08,240
quite keen on long function names but

00:19:06,180 --> 00:19:11,340
it's pretty much the same thing

00:19:08,240 --> 00:19:14,510
say it just has a constant time function

00:19:11,340 --> 00:19:16,290
which is the sodium crypto which is the

00:19:14,510 --> 00:19:19,110
prefix that's used on all of the

00:19:16,290 --> 00:19:21,630
functions followed by the password hash

00:19:19,110 --> 00:19:23,220
string verify and then again we pass in

00:19:21,630 --> 00:19:29,850
the same values so it's essentially the

00:19:23,220 --> 00:19:33,390
same as the built in PHP one so first up

00:19:29,850 --> 00:19:36,990
hashing hash algorithms are designed for

00:19:33,390 --> 00:19:38,730
different purposes so we typically have

00:19:36,990 --> 00:19:43,800
small ones which are often used for

00:19:38,730 --> 00:19:47,880
bidding or distributing in things across

00:19:43,800 --> 00:19:49,680
sort of bins of say for example a

00:19:47,880 --> 00:19:53,160
classic example a classic use of this

00:19:49,680 --> 00:19:55,920
would be distributing keys across a

00:19:53,160 --> 00:19:59,090
cluster of memcache servers you would do

00:19:55,920 --> 00:20:01,320
something like the FNV hash for that

00:19:59,090 --> 00:20:02,430
then you have fast ones which are

00:20:01,320 --> 00:20:04,740
typically used for check something

00:20:02,430 --> 00:20:07,770
verification say for example if you've

00:20:04,740 --> 00:20:09,210
downloaded an ISO image of an operating

00:20:07,770 --> 00:20:11,940
system or something you might want to

00:20:09,210 --> 00:20:14,220
check that it is actually the same file

00:20:11,940 --> 00:20:16,530
that you intended to download or if

00:20:14,220 --> 00:20:18,120
you've got two hundred gigabyte files on

00:20:16,530 --> 00:20:19,800
two different servers you want to check

00:20:18,120 --> 00:20:21,240
that those files are the same without

00:20:19,800 --> 00:20:22,920
having to actually transfer one to the

00:20:21,240 --> 00:20:24,330
other and compare them side-by-side you

00:20:22,920 --> 00:20:26,070
can just take a hash of each one at each

00:20:24,330 --> 00:20:28,890
end and you want that to happen as fast

00:20:26,070 --> 00:20:30,540
as possible but then you have slow ones

00:20:28,890 --> 00:20:32,220
that are more appropriate for password

00:20:30,540 --> 00:20:34,050
hashing things you don't want a fast

00:20:32,220 --> 00:20:36,090
pass with a fast hash for a password

00:20:34,050 --> 00:20:38,520
because that means that they're easy to

00:20:36,090 --> 00:20:41,280
crack crackers can run them on GPUs and

00:20:38,520 --> 00:20:43,860
things and tests often billions of

00:20:41,280 --> 00:20:46,560
password combinations per second

00:20:43,860 --> 00:20:48,750
you want you want password hashes that

00:20:46,560 --> 00:20:50,370
are really slow because when you're

00:20:48,750 --> 00:20:51,630
checking a password typically you only

00:20:50,370 --> 00:20:53,400
want to know whether it matches or not

00:20:51,630 --> 00:20:57,360
and you don't mind if that takes 100

00:20:53,400 --> 00:21:00,720
milliseconds whereas a fast hash like

00:20:57,360 --> 00:21:02,460
Blake - or md5 it will take almost

00:21:00,720 --> 00:21:03,510
microseconds to do the same thing which

00:21:02,460 --> 00:21:04,980
means that you can run it millions

00:21:03,510 --> 00:21:07,170
millions of times in the same amount of

00:21:04,980 --> 00:21:09,660
time and that to our hack to our cracker

00:21:07,170 --> 00:21:13,290
is means that it's easy for you then to

00:21:09,660 --> 00:21:15,630
crack your passwords now with all of

00:21:13,290 --> 00:21:17,520
these algorithms there are typically

00:21:15,630 --> 00:21:18,510
reference implementations so for example

00:21:17,520 --> 00:21:22,140
sha-2

00:21:18,510 --> 00:21:24,030
has there are several hash for their

00:21:22,140 --> 00:21:26,450
hashes of different sizes in the family

00:21:24,030 --> 00:21:30,240
of sha-2 the most common one probably

00:21:26,450 --> 00:21:32,190
sha-256 but there are there are

00:21:30,240 --> 00:21:35,700
important distinctions within the sort

00:21:32,190 --> 00:21:37,470
of family of sha-2 functions now sha-256

00:21:35,700 --> 00:21:39,780
is actually the reference implementation

00:21:37,470 --> 00:21:42,930
which I think was written by Daniel

00:21:39,780 --> 00:21:44,850
Bernstein is actually a 32-bit algorithm

00:21:42,930 --> 00:21:46,680
and that means that if you run it on a

00:21:44,850 --> 00:21:49,680
64-bit processor it's actually

00:21:46,680 --> 00:21:51,360
relatively speaking inefficient and what

00:21:49,680 --> 00:21:53,310
you really want is a 64-bit algorithm

00:21:51,360 --> 00:21:56,220
but as it happens within the same family

00:21:53,310 --> 00:21:57,210
there's sha-512 which is originally

00:21:56,220 --> 00:22:00,120
implemented it's a reference

00:21:57,210 --> 00:22:01,820
implementation is 64-bit and that makes

00:22:00,120 --> 00:22:04,020
it quite a bit faster and more efficient

00:22:01,820 --> 00:22:07,710
so what you can do is you can take

00:22:04,020 --> 00:22:09,620
sha-512 and then truncate it to 256 bits

00:22:07,710 --> 00:22:11,850
you will actually get a different result

00:22:09,620 --> 00:22:13,980
but that doesn't matter so long as you

00:22:11,850 --> 00:22:16,179
use that approach consistently you'll

00:22:13,980 --> 00:22:19,740
get a 256 bit

00:22:16,179 --> 00:22:28,539
hache with the efficiency of the sha-512

00:22:19,740 --> 00:22:30,759
algorithm more recently there's been

00:22:28,539 --> 00:22:33,340
this new algorithm for passwords called

00:22:30,759 --> 00:22:36,009
argon 2 and there are 3 variants of this

00:22:33,340 --> 00:22:38,019
argon 2 I which was resistant

00:22:36,009 --> 00:22:41,019
particularly designed to be resistant to

00:22:38,019 --> 00:22:44,159
timing side channel attacks argon 2d

00:22:41,019 --> 00:22:46,899
which is designed to be resistant to

00:22:44,159 --> 00:22:48,250
trying to be cracked on GPUs it has

00:22:46,899 --> 00:22:50,019
things that make it difficult to

00:22:48,250 --> 00:22:52,059
parallelize massively which is the main

00:22:50,019 --> 00:22:55,389
reason that people use GPUs they've got

00:22:52,059 --> 00:22:57,009
a GPU is 512 processors on it if you run

00:22:55,389 --> 00:22:59,889
something like MD 5 you can test it on

00:22:57,009 --> 00:23:01,509
all the cores at once argon to make the

00:22:59,889 --> 00:23:04,809
algorithm makes it difficult to do that

00:23:01,509 --> 00:23:06,370
kind of scaling and then finally argon 2

00:23:04,809 --> 00:23:08,620
ID which is a slightly more recent

00:23:06,370 --> 00:23:10,240
version actually combines the two so you

00:23:08,620 --> 00:23:13,769
get timing side channel resistance and

00:23:10,240 --> 00:23:15,909
GPU resistance from the same algorithm

00:23:13,769 --> 00:23:16,990
so really if you're writing a new

00:23:15,909 --> 00:23:19,179
application you want to use the

00:23:16,990 --> 00:23:22,419
strongest thing that's available and to

00:23:19,179 --> 00:23:23,049
upgrade from a lower quality hash to a

00:23:22,419 --> 00:23:24,519
better one

00:23:23,049 --> 00:23:25,960
you can rehash when people log in

00:23:24,519 --> 00:23:27,549
because at that point you've got the

00:23:25,960 --> 00:23:29,409
password in hand so you can calculate a

00:23:27,549 --> 00:23:30,940
new hash restore that in the database

00:23:29,409 --> 00:23:34,000
and then next time it's going to use the

00:23:30,940 --> 00:23:35,279
stronger hash so how do we hash things

00:23:34,000 --> 00:23:39,639
in sodium

00:23:35,279 --> 00:23:41,679
well in PHP we've got say a short hash

00:23:39,639 --> 00:23:43,690
so this is for something like little

00:23:41,679 --> 00:23:46,769
check sums on communication packets

00:23:43,690 --> 00:23:49,570
something small the hash function in PHP

00:23:46,769 --> 00:23:52,120
gives you access to a whole long list of

00:23:49,570 --> 00:23:53,980
maybe 30 or 40 different hash algorithms

00:23:52,120 --> 00:23:56,470
and again this is the situation where

00:23:53,980 --> 00:23:58,330
you probably don't know what those hash

00:23:56,470 --> 00:24:00,340
algorithms do him I don't know most of

00:23:58,330 --> 00:24:01,870
them there are lots of things with funny

00:24:00,340 --> 00:24:04,149
names and different numbers after them

00:24:01,870 --> 00:24:05,379
and it's really not particularly clear

00:24:04,149 --> 00:24:08,049
whether these things are strong or weak

00:24:05,379 --> 00:24:11,289
or new or old they're just a list of

00:24:08,049 --> 00:24:12,879
funny names so it's left up to you as a

00:24:11,289 --> 00:24:17,320
programmer to choose one and that means

00:24:12,879 --> 00:24:19,600
you're open to error so sodium provides

00:24:17,320 --> 00:24:21,850
this function called short hash and it

00:24:19,600 --> 00:24:23,769
has a hash which is appropriate for that

00:24:21,850 --> 00:24:26,500
sort of circumstances in fact short hash

00:24:23,769 --> 00:24:28,870
calculates a 64-bit hash so it's

00:24:26,500 --> 00:24:30,670
unsuitable for things that are

00:24:28,870 --> 00:24:33,040
not going to be cracked or something but

00:24:30,670 --> 00:24:34,360
they're nice and fast and effective but

00:24:33,040 --> 00:24:36,250
the key thing is it gives you no choice

00:24:34,360 --> 00:24:38,190
of the algorithm it just does its own

00:24:36,250 --> 00:24:41,260
thing and that's it

00:24:38,190 --> 00:24:44,800
the basic theme behind all of sodium

00:24:41,260 --> 00:24:47,290
stuff is to remove choices from you it

00:24:44,800 --> 00:24:49,420
takes away the opportunity for choosing

00:24:47,290 --> 00:24:50,830
the wrong thing so if you can't choose

00:24:49,420 --> 00:24:53,770
the thing you can't make the wrong

00:24:50,830 --> 00:24:55,150
decision this is fundamental to all of

00:24:53,770 --> 00:24:56,710
these things you'll find that in almost

00:24:55,150 --> 00:24:58,330
all the functions it doesn't give you

00:24:56,710 --> 00:25:00,670
any choice about algorithms and things

00:24:58,330 --> 00:25:03,390
or very little choice or if it does give

00:25:00,670 --> 00:25:07,540
you choices then none of them are bad

00:25:03,390 --> 00:25:08,830
so let me get onto the fast hashes the

00:25:07,540 --> 00:25:10,690
main thing it has is this thing called

00:25:08,830 --> 00:25:13,150
generic hash and these is that this is a

00:25:10,690 --> 00:25:15,100
replacement for things like md5 sha-1

00:25:13,150 --> 00:25:16,870
and also many of these things in the

00:25:15,100 --> 00:25:18,550
hash function it just has this thing

00:25:16,870 --> 00:25:19,660
called generic hash you just pass in a

00:25:18,550 --> 00:25:21,940
string and it gives you back the hash

00:25:19,660 --> 00:25:23,950
internally it uses this algorithm called

00:25:21,940 --> 00:25:25,120
Blake to be which is considered to be as

00:25:23,950 --> 00:25:28,059
strong as sha-3

00:25:25,120 --> 00:25:30,880
which hasn't been deployed much but it's

00:25:28,059 --> 00:25:34,260
actually faster than md5 so that's

00:25:30,880 --> 00:25:34,260
that's a nice hash algorithm to use

00:25:34,350 --> 00:25:38,710
finally password hashes put the password

00:25:37,570 --> 00:25:41,830
hash so it's the one you saw earlier

00:25:38,710 --> 00:25:44,500
it's the crypto password hash string and

00:25:41,830 --> 00:25:46,480
that uses argon to ID which is currently

00:25:44,500 --> 00:25:49,660
the absolute state of the art as far as

00:25:46,480 --> 00:25:54,220
password hashing algorithms go now in

00:25:49,660 --> 00:25:56,530
PHP the password hash function currently

00:25:54,220 --> 00:25:58,059
uses bcrypt as the password hash

00:25:56,530 --> 00:26:00,400
function and be cooked is still pretty

00:25:58,059 --> 00:26:04,000
good I'll go in twos better but bcrypt

00:26:00,400 --> 00:26:07,450
is okay and PHP 7.3 actually adds

00:26:04,000 --> 00:26:08,559
support for argon too however it has

00:26:07,450 --> 00:26:12,700
some problems which I'll get to you

00:26:08,559 --> 00:26:14,860
later but if you use sodium it means

00:26:12,700 --> 00:26:16,360
that you can use out on to ID wherever

00:26:14,860 --> 00:26:17,620
it runs which because it's now in the

00:26:16,360 --> 00:26:20,950
base install means you've always got

00:26:17,620 --> 00:26:22,960
access to it so now we get onto the

00:26:20,950 --> 00:26:24,929
things with one key first of those

00:26:22,960 --> 00:26:27,370
message authentication codes I

00:26:24,929 --> 00:26:29,440
particularly like this image too to

00:26:27,370 --> 00:26:31,929
illustrate this the idea of using a hash

00:26:29,440 --> 00:26:33,820
to authenticate something is problematic

00:26:31,929 --> 00:26:37,420
because a hash can be calculated by

00:26:33,820 --> 00:26:39,130
anybody you can just go you know here's

00:26:37,420 --> 00:26:40,440
here's this ISO image I tweaked the

00:26:39,130 --> 00:26:42,279
contents of it and I'm going to just

00:26:40,440 --> 00:26:43,330
recalculate the hash and paste it

00:26:42,279 --> 00:26:44,409
back onto their website and they'll be

00:26:43,330 --> 00:26:47,320
none the wiser that this has been

00:26:44,409 --> 00:26:49,179
altered so this is the equivalent here

00:26:47,320 --> 00:26:50,739
of this wax seal they will be the

00:26:49,179 --> 00:26:52,809
equivalent of somebody breaking it open

00:26:50,739 --> 00:26:54,190
reading stuff inside modifying it

00:26:52,809 --> 00:26:55,830
sealing it back up and just and just

00:26:54,190 --> 00:26:58,690
remelting the wax and nobody would know

00:26:55,830 --> 00:27:00,039
but here we're adding this seal which

00:26:58,690 --> 00:27:03,129
means that if somebody breaks it andrey

00:27:00,039 --> 00:27:05,139
melts it we would know about it so it

00:27:03,129 --> 00:27:06,279
adds this stamp of authenticity and

00:27:05,139 --> 00:27:10,989
that's the thing that message

00:27:06,279 --> 00:27:13,809
authentication codes give you just like

00:27:10,989 --> 00:27:15,389
a hash but it also uses a key as well as

00:27:13,809 --> 00:27:17,200
the data that you're hashing and

00:27:15,389 --> 00:27:20,469
typically this is used for

00:27:17,200 --> 00:27:24,279
authenticating or providing signatures

00:27:20,469 --> 00:27:25,839
on on messages and the most common of

00:27:24,279 --> 00:27:28,299
these is this algorithm called H Mac

00:27:25,839 --> 00:27:30,700
which is just very simple it's the

00:27:28,299 --> 00:27:32,769
hash-based message authentication code

00:27:30,700 --> 00:27:35,529
and typically the hash of the H Mac

00:27:32,769 --> 00:27:38,409
algorithm takes a hash function and just

00:27:35,529 --> 00:27:42,190
wraps the key stuff around it so you

00:27:38,409 --> 00:27:45,999
find things like hmm d5 hmx sha-256 and

00:27:42,190 --> 00:27:48,279
so on there's also this other one which

00:27:45,999 --> 00:27:51,009
you saw a reference to earlier Poli 1305

00:27:48,279 --> 00:27:53,379
that's effectively a Mac Mac function

00:27:51,009 --> 00:27:55,149
it's not typically used by itself there

00:27:53,379 --> 00:27:58,029
it's actually used as part of a cipher

00:27:55,149 --> 00:27:59,259
suite which we'll get to you later so

00:27:58,029 --> 00:28:02,169
how'd you use Macs in sodium

00:27:59,259 --> 00:28:05,519
well PHP has a built in function for

00:28:02,169 --> 00:28:07,690
doing Mac's called hash H Mac and

00:28:05,519 --> 00:28:09,729
sodium's equivalent is called sodium

00:28:07,690 --> 00:28:12,339
crypto or because it's just about

00:28:09,729 --> 00:28:14,559
authentication so here we can see that

00:28:12,339 --> 00:28:15,849
PHP is using the hash H Mac functional

00:28:14,559 --> 00:28:19,899
and we're telling it that we don't want

00:28:15,849 --> 00:28:21,669
to use sha to sha-512 as our as our hash

00:28:19,899 --> 00:28:24,759
function inside it and we give it the

00:28:21,669 --> 00:28:26,169
message and we give it a key now here

00:28:24,759 --> 00:28:30,219
I'm actually saying that I'm actually

00:28:26,169 --> 00:28:38,049
going to cut it down to 64 bytes of

00:28:30,219 --> 00:28:40,809
output and the sodium crypto or function

00:28:38,049 --> 00:28:41,919
you notice that one thing is missing we

00:28:40,809 --> 00:28:43,989
don't have the name of the hash function

00:28:41,919 --> 00:28:44,409
because it takes that choice away from

00:28:43,989 --> 00:28:46,210
us

00:28:44,409 --> 00:28:49,029
in fact internally it actually uses

00:28:46,210 --> 00:28:51,279
sha-512 slash 256 that I mentioned

00:28:49,029 --> 00:28:53,019
earlier which is the truncated sha-512

00:28:51,279 --> 00:28:55,330
which as you can see is exactly what I

00:28:53,019 --> 00:28:56,260
did here except manually I just cut it

00:28:55,330 --> 00:28:57,160
down from 100

00:28:56,260 --> 00:29:02,530
twenty-eight bytes that would normally

00:28:57,160 --> 00:29:04,720
be down to 64 because the sodium

00:29:02,530 --> 00:29:05,530
implementation does that anyway we don't

00:29:04,720 --> 00:29:07,420
have to worry about it

00:29:05,530 --> 00:29:09,160
the other difference with the sodium one

00:29:07,420 --> 00:29:12,010
is it actually gives you the answer back

00:29:09,160 --> 00:29:14,650
as a binary string so it's actually the

00:29:12,010 --> 00:29:16,570
raw binary value of the hash rather than

00:29:14,650 --> 00:29:18,070
it being a hexadecimal representation of

00:29:16,570 --> 00:29:19,810
it so just to make them look the same

00:29:18,070 --> 00:29:21,490
I'm applying the pin to hex function

00:29:19,810 --> 00:29:25,060
here and you actually get exactly the

00:29:21,490 --> 00:29:26,200
same result out of those two but this is

00:29:25,060 --> 00:29:28,930
something I'm actually quite keen on

00:29:26,200 --> 00:29:31,060
doing in things like MySQL MySQL is

00:29:28,930 --> 00:29:33,100
perfectly happy storing raw binary

00:29:31,060 --> 00:29:34,960
values you can put things into binary

00:29:33,100 --> 00:29:37,030
fields and they have the advantage that

00:29:34,960 --> 00:29:38,680
they're half the size of their string

00:29:37,030 --> 00:29:40,360
equivalents and that means you can get

00:29:38,680 --> 00:29:42,580
twice as many records and twice as many

00:29:40,360 --> 00:29:44,410
things in your index into the same

00:29:42,580 --> 00:29:46,240
amount of memory which just makes things

00:29:44,410 --> 00:29:51,520
faster and more efficient in general and

00:29:46,240 --> 00:29:54,790
it's really quite easy to cope with now

00:29:51,520 --> 00:29:57,610
relating to the Mac function is the use

00:29:54,790 --> 00:30:00,730
of hash equals now this is exactly like

00:29:57,610 --> 00:30:02,980
the password verification stuff we

00:30:00,730 --> 00:30:05,560
looked at earlier but here this is just

00:30:02,980 --> 00:30:07,780
a straightforward comparison between two

00:30:05,560 --> 00:30:10,090
hashes and the hash equals function and

00:30:07,780 --> 00:30:12,520
the sodium crypto or verify function are

00:30:10,090 --> 00:30:15,610
both constant time functions and again

00:30:12,520 --> 00:30:17,920
in hash equals we do have to provide the

00:30:15,610 --> 00:30:19,480
the name of the hash that we're using as

00:30:17,920 --> 00:30:23,440
well as the message and the key that it

00:30:19,480 --> 00:30:25,240
was signed with but in the the sodium

00:30:23,440 --> 00:30:26,530
version we don't so it actually makes it

00:30:25,240 --> 00:30:27,850
a fair bit simpler because that choice

00:30:26,530 --> 00:30:30,190
has been taken away from us and

00:30:27,850 --> 00:30:37,720
internally again it uses the sha-512

00:30:30,190 --> 00:30:39,400
slash 256 algorithm all right now aside

00:30:37,720 --> 00:30:41,140
from the unfortunate British slang

00:30:39,400 --> 00:30:45,570
meaning of this these are actually very

00:30:41,140 --> 00:30:48,970
simple a nought is a number used once

00:30:45,570 --> 00:30:51,220
now typically these are random or

00:30:48,970 --> 00:30:52,600
pseudo-random numbers often containing a

00:30:51,220 --> 00:30:54,280
timestamp because that's quite a useful

00:30:52,600 --> 00:30:57,940
way of making something that doesn't

00:30:54,280 --> 00:31:00,850
repeat and these are used all over the

00:30:57,940 --> 00:31:03,010
place in cryptographic scenarios so if

00:31:00,850 --> 00:31:05,140
you've ever used HTTP digest mode

00:31:03,010 --> 00:31:06,670
authentication just the basic or thing

00:31:05,140 --> 00:31:08,920
or it's not the basic when it's the

00:31:06,670 --> 00:31:09,940
digest authentication in the HTTP

00:31:08,920 --> 00:31:14,290
standard that's been around

00:31:09,940 --> 00:31:17,320
for whatever 20 years you've used nonces

00:31:14,290 --> 00:31:18,700
whether you knew it or not and one of

00:31:17,320 --> 00:31:20,440
the most important things about them is

00:31:18,700 --> 00:31:22,510
that they prevent prevent replay attacks

00:31:20,440 --> 00:31:23,830
if you've got an attacker that's able to

00:31:22,510 --> 00:31:25,960
listen to the traffic between their

00:31:23,830 --> 00:31:27,280
client on a server a replay attack is

00:31:25,960 --> 00:31:28,930
where they record all of this

00:31:27,280 --> 00:31:31,990
information and then play it back later

00:31:28,930 --> 00:31:33,820
and that might allow them to say log in

00:31:31,990 --> 00:31:35,110
when the real user isn't around for

00:31:33,820 --> 00:31:39,700
example that would be a typical thing to

00:31:35,110 --> 00:31:41,800
try and do using a replay attack but if

00:31:39,700 --> 00:31:43,180
you have a nonce where each time you

00:31:41,800 --> 00:31:44,800
submit this it's actually going to have

00:31:43,180 --> 00:31:46,870
a different one of these numbers because

00:31:44,800 --> 00:31:48,130
the numbers are only ever used once so

00:31:46,870 --> 00:31:49,570
although it might be the same request

00:31:48,130 --> 00:31:51,820
you're expecting it to have a different

00:31:49,570 --> 00:31:54,720
nonce value so it should never be reused

00:31:51,820 --> 00:31:57,430
and that prevents it being used again

00:31:54,720 --> 00:32:00,280
nonces are actually what bitcoin miners

00:31:57,430 --> 00:32:01,840
are looking for when Bitcoin miners just

00:32:00,280 --> 00:32:03,490
sit there and turn away through there's

00:32:01,840 --> 00:32:05,470
these things they're actually trying to

00:32:03,490 --> 00:32:07,680
figure out the nonce that was used to

00:32:05,470 --> 00:32:10,210
sign a particular block so it's kind of

00:32:07,680 --> 00:32:11,350
trying to decrypt stuff and the problem

00:32:10,210 --> 00:32:13,780
is is that the algorithm that's used

00:32:11,350 --> 00:32:15,670
inside Bitcoin is really pretty strong

00:32:13,780 --> 00:32:17,230
and it's really hard to find this number

00:32:15,670 --> 00:32:18,820
which is why Bitcoin mining is so

00:32:17,230 --> 00:32:20,620
expensive and why it's considered a

00:32:18,820 --> 00:32:22,950
valuable commodity and that's the

00:32:20,620 --> 00:32:25,240
complete value proposition of Bitcoin

00:32:22,950 --> 00:32:30,130
it's also used as an initialization

00:32:25,240 --> 00:32:32,140
vector in encryption ciphers and these

00:32:30,130 --> 00:32:33,910
are really things like a it's like a

00:32:32,140 --> 00:32:35,920
starting point it's like a seed for a

00:32:33,910 --> 00:32:38,200
random number generator really a lot of

00:32:35,920 --> 00:32:39,400
ciphers are actually really effectively

00:32:38,200 --> 00:32:41,920
just really good random number

00:32:39,400 --> 00:32:44,140
generators that will respond in a

00:32:41,920 --> 00:32:45,490
particular known sequence so there is

00:32:44,140 --> 00:32:47,950
actually in some cases quite difficult

00:32:45,490 --> 00:32:51,730
to tell apart a an encryption cipher

00:32:47,950 --> 00:32:53,080
from a random number generator it's

00:32:51,730 --> 00:32:54,730
quite a useful thing you can actually

00:32:53,080 --> 00:32:56,320
use a cipher as a random number

00:32:54,730 --> 00:32:59,950
generator if you don't care about the

00:32:56,320 --> 00:33:02,080
input and because of this they're used

00:32:59,950 --> 00:33:05,200
extensively in both secret and public

00:33:02,080 --> 00:33:07,090
key encryption but the most important

00:33:05,200 --> 00:33:11,280
thing about a nonce is you never ever

00:33:07,090 --> 00:33:11,280
reuse it especially with the same key

00:33:12,150 --> 00:33:16,480
how do you make a nonce well it's

00:33:14,560 --> 00:33:17,770
actually really easy PHP has a really

00:33:16,480 --> 00:33:20,560
good function that was introduced to

00:33:17,770 --> 00:33:22,750
thinking in PHP 5.45 which is just

00:33:20,560 --> 00:33:23,440
called random bytes and you just say

00:33:22,750 --> 00:33:26,679
give me

00:33:23,440 --> 00:33:28,240
chunk of random data and PHP seven

00:33:26,679 --> 00:33:30,159
introduced a really good random number

00:33:28,240 --> 00:33:32,379
generator and so that's what's used to

00:33:30,159 --> 00:33:36,399
generate this data and it's just a chunk

00:33:32,379 --> 00:33:36,909
of noise and it's it's nice solid proper

00:33:36,399 --> 00:33:39,460
noise

00:33:36,909 --> 00:33:40,659
it's got no discernible patterns to it

00:33:39,460 --> 00:33:42,789
there are lots that there have been lots

00:33:40,659 --> 00:33:44,470
of analysis of random number generators

00:33:42,789 --> 00:33:47,889
and this PHP one is actually really

00:33:44,470 --> 00:33:49,690
pretty good so it's perfectly okay to

00:33:47,889 --> 00:33:50,980
rely on that and sodium doesn't attempt

00:33:49,690 --> 00:33:55,090
to replace it because there's nothing

00:33:50,980 --> 00:33:57,429
wrong with the one that's in PHP reuse

00:33:55,090 --> 00:33:58,899
of non C's can be completely faithful I

00:33:57,429 --> 00:34:02,200
don't if you've heard recently there's

00:33:58,899 --> 00:34:04,750
an attack on wpa2 encryption that's used

00:34:02,200 --> 00:34:09,490
commonly a Wi-Fi the attacks called

00:34:04,750 --> 00:34:11,740
crack spoke with a K and that actually

00:34:09,490 --> 00:34:16,240
works by forcing the reuse of a nonce

00:34:11,740 --> 00:34:19,359
and the net result is that people are

00:34:16,240 --> 00:34:21,040
able to guess passwords and that's a

00:34:19,359 --> 00:34:28,329
really severe problem for something

00:34:21,040 --> 00:34:29,889
that's meant to be secure one of the

00:34:28,329 --> 00:34:32,260
things about a nonce is we've said oh

00:34:29,889 --> 00:34:34,119
it's a number used once well how big is

00:34:32,260 --> 00:34:37,569
this number how big a number should we

00:34:34,119 --> 00:34:39,520
use and that's an invitation for you to

00:34:37,569 --> 00:34:42,639
guess and if you guess you're probably

00:34:39,520 --> 00:34:46,629
guessed wrong and so again sodium deals

00:34:42,639 --> 00:34:50,169
with this by providing a whole bunch of

00:34:46,629 --> 00:34:52,450
constants which are appropriate for that

00:34:50,169 --> 00:34:54,460
give you the appropriate size of a nonce

00:34:52,450 --> 00:34:58,240
for the particular context that you're

00:34:54,460 --> 00:34:59,859
using them in so two secret key

00:34:58,240 --> 00:35:01,510
encryption this is the first this is

00:34:59,859 --> 00:35:04,119
another thing like a Mac it uses a

00:35:01,510 --> 00:35:06,880
single key so it encrypts and decrypts

00:35:04,119 --> 00:35:08,619
using the same key and this makes it

00:35:06,880 --> 00:35:11,560
called a symmetric cipher because it is

00:35:08,619 --> 00:35:14,079
very symmetrical in it so in its basis

00:35:11,560 --> 00:35:15,910
of its processing and one of the things

00:35:14,079 --> 00:35:17,829
is that just because you've encrypted

00:35:15,910 --> 00:35:20,920
something it doesn't actually guarantee

00:35:17,829 --> 00:35:23,319
either integrity or authenticity anybody

00:35:20,920 --> 00:35:25,750
who's got the key can make something and

00:35:23,319 --> 00:35:27,490
so on and the other thing is but for the

00:35:25,750 --> 00:35:29,349
integrity side somebody can encrypt

00:35:27,490 --> 00:35:31,660
something you can tamper with the

00:35:29,349 --> 00:35:34,690
encrypted content and you won't be able

00:35:31,660 --> 00:35:37,000
to tell if that corruption is actually

00:35:34,690 --> 00:35:38,770
from the original content

00:35:37,000 --> 00:35:40,060
whether it was introduced afterwards you

00:35:38,770 --> 00:35:42,190
have no way of telling because there's

00:35:40,060 --> 00:35:43,930
no integrity checking within the concept

00:35:42,190 --> 00:35:45,010
of encryption that's why I was saying at

00:35:43,930 --> 00:35:46,360
the beginning that these things are more

00:35:45,010 --> 00:35:49,060
or less orthogonal you cannot have one

00:35:46,360 --> 00:35:52,210
thing without the others so what you

00:35:49,060 --> 00:35:54,580
need to do is in order to to guarantee

00:35:52,210 --> 00:35:56,380
this is to stick a Mac on top of it and

00:35:54,580 --> 00:35:58,030
that provides the authenticity because

00:35:56,380 --> 00:36:00,790
you've got any you've got the key there

00:35:58,030 --> 00:36:03,700
is used to provide a signature which

00:36:00,790 --> 00:36:05,380
will not match if you alter the tiniest

00:36:03,700 --> 00:36:07,300
thing in it and if you know that that

00:36:05,380 --> 00:36:10,810
key that you used to generate the Mac

00:36:07,300 --> 00:36:12,930
has not been exposed then it means that

00:36:10,810 --> 00:36:15,790
you know who did it

00:36:12,930 --> 00:36:18,580
so sodium provides a whole bunch of

00:36:15,790 --> 00:36:21,130
functions called secret box there's a

00:36:18,580 --> 00:36:22,900
whole family of them and what they do is

00:36:21,130 --> 00:36:25,540
they provide a combined encrypt-then-mac

00:36:22,900 --> 00:36:27,910
and it's important that things happen in

00:36:25,540 --> 00:36:29,500
that order because otherwise if you did

00:36:27,910 --> 00:36:32,650
it the other way around of calculator

00:36:29,500 --> 00:36:34,150
mac and then encrypt the result in order

00:36:32,650 --> 00:36:36,250
to verify it

00:36:34,150 --> 00:36:38,350
you'd have to decrypt it and then

00:36:36,250 --> 00:36:41,230
calculate the Mac now say the thing that

00:36:38,350 --> 00:36:42,370
you were decrypting was really huge it

00:36:41,230 --> 00:36:43,690
might take a long time to do the

00:36:42,370 --> 00:36:45,160
decryption you're much better off

00:36:43,690 --> 00:36:47,110
calculating it doing the encryption

00:36:45,160 --> 00:36:48,820
first and then Mac afterwards so that

00:36:47,110 --> 00:36:50,560
when you're when it comes to decoding it

00:36:48,820 --> 00:36:52,120
all you can calculate the Mac on the

00:36:50,560 --> 00:36:53,590
encrypted data and you don't have to

00:36:52,120 --> 00:36:55,510
bother decoding it just to check that

00:36:53,590 --> 00:36:58,420
it's integrity and authenticity are

00:36:55,510 --> 00:37:00,340
intact it also means that if it contains

00:36:58,420 --> 00:37:01,660
some potentially dangerous code say but

00:37:00,340 --> 00:37:03,430
somebody's trying to infiltrate your

00:37:01,660 --> 00:37:07,590
system it means that you can know that

00:37:03,430 --> 00:37:07,590
it's bad before you even decrypt it

00:37:08,160 --> 00:37:15,070
there are some other functions called a

00:37:10,990 --> 00:37:17,980
EAD now this is sort of getting more

00:37:15,070 --> 00:37:21,220
into slightly trickier cryptography

00:37:17,980 --> 00:37:22,900
functions and this really achieves

00:37:21,220 --> 00:37:25,390
pretty much the same thing as the secret

00:37:22,900 --> 00:37:28,420
box functions except instead of applying

00:37:25,390 --> 00:37:30,310
an encryption and then a Mac process it

00:37:28,420 --> 00:37:33,610
actually combines the two into a single

00:37:30,310 --> 00:37:35,740
operation and that uses some specific

00:37:33,610 --> 00:37:37,960
ciphers that actually have this

00:37:35,740 --> 00:37:41,380
signature ability built into them and

00:37:37,960 --> 00:37:45,610
the two that are available in sodium are

00:37:41,380 --> 00:37:48,310
called ChaCha 20 poly 1305 and aes-256

00:37:45,610 --> 00:37:50,650
GCM and these are both examples of what

00:37:48,310 --> 00:37:53,380
are called a e ad ciphers

00:37:50,650 --> 00:37:57,220
and aad stands for authenticated

00:37:53,380 --> 00:37:59,079
encryption with additional data and the

00:37:57,220 --> 00:38:01,630
actual practical upshot of all this is

00:37:59,079 --> 00:38:03,430
that you encrypt something and then you

00:38:01,630 --> 00:38:05,609
have a chunk of other data that's not

00:38:03,430 --> 00:38:08,680
encrypted that you just tack on to it

00:38:05,609 --> 00:38:12,009
and then you calculate a Mac on the

00:38:08,680 --> 00:38:13,779
whole lot and it's like well why would

00:38:12,009 --> 00:38:15,369
you do that as it turns out that

00:38:13,779 --> 00:38:18,519
structure is actually extremely handy

00:38:15,369 --> 00:38:21,759
because you can you can pass the nonce

00:38:18,519 --> 00:38:25,480
as part of the of the encrypted debt of

00:38:21,759 --> 00:38:29,019
the the whole package of data and you'll

00:38:25,480 --> 00:38:32,319
see how we do deal with that these

00:38:29,019 --> 00:38:35,259
ciphers you may be familiar with both of

00:38:32,319 --> 00:38:36,609
these are commonly used in TLS so you

00:38:35,259 --> 00:38:39,430
might find that if you do an inspection

00:38:36,609 --> 00:38:41,529
or run something like kalus SSL labs on

00:38:39,430 --> 00:38:42,880
your website you might find these listed

00:38:41,529 --> 00:38:45,009
amongst the algorithms that are

00:38:42,880 --> 00:38:49,359
supported these two are particularly

00:38:45,009 --> 00:38:52,150
interesting cha-cha 20 poly 1305 is a is

00:38:49,359 --> 00:38:55,509
an AE AG cipher that's written again by

00:38:52,150 --> 00:38:56,890
Daniel Bernstein and one of the things

00:38:55,509 --> 00:38:59,799
about it is that it's very very

00:38:56,890 --> 00:39:01,960
efficient it's extremely fast on low

00:38:59,799 --> 00:39:04,509
powered hardware so it's really good on

00:39:01,960 --> 00:39:06,489
things like mobiles and on embedded

00:39:04,509 --> 00:39:08,319
systems and so on it's small and fast

00:39:06,489 --> 00:39:11,799
and efficient and it doesn't require any

00:39:08,319 --> 00:39:13,390
specialized hardware AES is an extremely

00:39:11,799 --> 00:39:15,400
common algorithm it's used widely but

00:39:13,390 --> 00:39:17,829
it's much more CPU intensive however

00:39:15,400 --> 00:39:19,660
what's happened is that Intel added a

00:39:17,829 --> 00:39:22,920
whole bunch of instructions that make a

00:39:19,660 --> 00:39:25,539
AES effectively hardware accelerated and

00:39:22,920 --> 00:39:28,839
that's made it much more efficient and

00:39:25,539 --> 00:39:31,539
on desktop machines aes-256 is faster

00:39:28,839 --> 00:39:33,759
than Char Char 20 poly 1305 but on a

00:39:31,539 --> 00:39:35,349
mobile it's probably faster to use

00:39:33,759 --> 00:39:37,239
ChaCha now the problem is that when

00:39:35,349 --> 00:39:38,950
you're ordering things for TLS you can

00:39:37,239 --> 00:39:41,200
choose the order of these ciphers so

00:39:38,950 --> 00:39:44,349
which one you get is up to the server

00:39:41,200 --> 00:39:45,730
config and it's actually a kind of

00:39:44,349 --> 00:39:47,230
slightly difficult decision which which

00:39:45,730 --> 00:39:48,519
one that you choose to do first but

00:39:47,230 --> 00:39:49,960
essentially if all your if more of your

00:39:48,519 --> 00:39:51,190
clients are mobile you're better off

00:39:49,960 --> 00:39:55,269
with charger and if more of them are

00:39:51,190 --> 00:39:56,769
desktop you're better off with a yes so

00:39:55,269 --> 00:40:00,130
how do we actually use secret box

00:39:56,769 --> 00:40:02,259
encryption in practice well first of all

00:40:00,130 --> 00:40:04,460
we generate a key on Anant and the keys

00:40:02,259 --> 00:40:05,570
just it's just a random string it's

00:40:04,460 --> 00:40:07,520
are having a really good password

00:40:05,570 --> 00:40:09,200
generator that produces a totally

00:40:07,520 --> 00:40:11,000
unreadable thing I notice that the

00:40:09,200 --> 00:40:13,369
random bytes function returns just raw

00:40:11,000 --> 00:40:15,140
binary data it's not pretty if you

00:40:13,369 --> 00:40:20,150
printed the output of that it would look

00:40:15,140 --> 00:40:22,130
pretty bad so we do is we pass in to the

00:40:20,150 --> 00:40:24,470
secret box function the text that we

00:40:22,130 --> 00:40:26,000
want to encrypt the nonce that we just

00:40:24,470 --> 00:40:27,980
generated up here notice that we've got

00:40:26,000 --> 00:40:30,050
this secret box nonce by its constant

00:40:27,980 --> 00:40:32,710
telling us exactly how much data to

00:40:30,050 --> 00:40:36,980
produce and similarly for the key bytes

00:40:32,710 --> 00:40:39,230
so we give it the nonce and the key an

00:40:36,980 --> 00:40:42,380
alternative implementation is using the

00:40:39,230 --> 00:40:45,170
a EAD thing the chart our 20 poly 1305

00:40:42,380 --> 00:40:47,480
encrypt function now because it's this

00:40:45,170 --> 00:40:49,250
AE ad cipher we provide some additional

00:40:47,480 --> 00:40:51,050
data and as it happens it's quite

00:40:49,250 --> 00:40:52,369
convenient to provide the nonce so you

00:40:51,050 --> 00:40:54,680
can see we actually just provide it

00:40:52,369 --> 00:40:59,030
twice it's the same piece of data but

00:40:54,680 --> 00:41:03,020
that's fine and so this gives us either

00:40:59,030 --> 00:41:06,380
way some encrypted content now when we

00:41:03,020 --> 00:41:08,900
transmit it to decrypt it we also need a

00:41:06,380 --> 00:41:10,970
copy of the nonce but that's fine the

00:41:08,900 --> 00:41:12,650
nonce is just a number it's it has no

00:41:10,970 --> 00:41:13,640
particular significance itself other

00:41:12,650 --> 00:41:16,310
than the fact that it's used to

00:41:13,640 --> 00:41:17,630
initialize the the cipher at that

00:41:16,310 --> 00:41:18,800
particular point as I said it's a bit

00:41:17,630 --> 00:41:22,250
like a seed for a random number

00:41:18,800 --> 00:41:24,170
generator so when we decrypt it we do

00:41:22,250 --> 00:41:26,740
instead of secret box we do secret box

00:41:24,170 --> 00:41:31,880
open and we pass in again the ciphertext

00:41:26,740 --> 00:41:34,070
the nonce and the key and doing the same

00:41:31,880 --> 00:41:38,150
thing with the aad function we just pass

00:41:34,070 --> 00:41:39,859
in the nonce twice and the key there are

00:41:38,150 --> 00:41:42,170
some variants of this you'll find these

00:41:39,859 --> 00:41:45,290
ones with the IETF thinks the internet

00:41:42,170 --> 00:41:47,900
engineering task force they define some

00:41:45,290 --> 00:41:49,700
particular formats to use with for

00:41:47,900 --> 00:41:51,140
encrypted content like this and those

00:41:49,700 --> 00:41:53,119
particular implementations are

00:41:51,140 --> 00:41:55,430
compatible with the IETF specification

00:41:53,119 --> 00:41:58,070
for those in future they will actually

00:41:55,430 --> 00:42:00,770
be a function called this a a a D

00:41:58,070 --> 00:42:03,320
encrypt and the reason that it currently

00:42:00,770 --> 00:42:05,839
has these actual named algorithms here

00:42:03,320 --> 00:42:07,070
is because there's actually a

00:42:05,839 --> 00:42:10,130
competition going on at the moment

00:42:07,070 --> 00:42:11,150
called the Caesar competition and this

00:42:10,130 --> 00:42:12,800
is something that happens in

00:42:11,150 --> 00:42:15,349
cryptography quite a bit they have

00:42:12,800 --> 00:42:17,809
competitions to establish what is going

00:42:15,349 --> 00:42:22,719
to be the in

00:42:17,809 --> 00:42:26,479
of choice for say a nationally

00:42:22,719 --> 00:42:29,539
sanctioned algorithm for something now

00:42:26,479 --> 00:42:31,549
AES is a good example of this a the AES

00:42:29,539 --> 00:42:33,640
encryption algorithm was the result of a

00:42:31,549 --> 00:42:35,479
competition originally the the actual

00:42:33,640 --> 00:42:38,959
algorithm underneath it is a thing

00:42:35,479 --> 00:42:40,160
called Rhine dal which is like a Dutch

00:42:38,959 --> 00:42:45,890
word or something I can't remember it

00:42:40,160 --> 00:42:48,799
stands for and that then became the AES

00:42:45,890 --> 00:42:50,420
encryption standard now we are we're

00:42:48,799 --> 00:42:51,769
still awaiting the results of the Caesar

00:42:50,420 --> 00:42:53,930
competition it hasn't finished yet

00:42:51,769 --> 00:42:58,759
but it's probably going to be either

00:42:53,930 --> 00:43:01,039
aes-256 or a charger of 20 poly 1305 but

00:42:58,759 --> 00:43:03,529
once that's been decided sodium will

00:43:01,039 --> 00:43:04,459
nail it to this function so it'll

00:43:03,529 --> 00:43:09,769
actually make your code a little bit

00:43:04,459 --> 00:43:11,779
shorter so then we finally get on to the

00:43:09,769 --> 00:43:15,079
two keys thing which is public key

00:43:11,779 --> 00:43:16,569
encryption public key encryption is just

00:43:15,079 --> 00:43:21,650
extraordinarily clever

00:43:16,569 --> 00:43:25,789
it really is bear in mind that until the

00:43:21,650 --> 00:43:27,920
early 1970s all encryption was secret

00:43:25,789 --> 00:43:29,929
key encryption there was no such thing

00:43:27,920 --> 00:43:31,459
as public key encryption it's partly the

00:43:29,929 --> 00:43:34,219
advent of computers that have even made

00:43:31,459 --> 00:43:36,109
it possible and it relies on some

00:43:34,219 --> 00:43:37,849
mathematics that just hadn't been

00:43:36,109 --> 00:43:39,380
invented until this point and people

00:43:37,849 --> 00:43:42,439
hadn't occurred to them that they had to

00:43:39,380 --> 00:43:44,359
do this and public key encryption is

00:43:42,439 --> 00:43:46,599
what allows us to have secure websites

00:43:44,359 --> 00:43:49,189
it's a it's just a stunning bit of

00:43:46,599 --> 00:43:51,259
imagination and theorization by the

00:43:49,189 --> 00:43:52,699
mathematicians that derived it it was

00:43:51,259 --> 00:43:54,679
actually effectively invented by two

00:43:52,699 --> 00:43:56,569
groups of people separately but because

00:43:54,679 --> 00:43:58,069
they were both working for governments

00:43:56,569 --> 00:43:59,269
in completely different places then it

00:43:58,069 --> 00:44:01,549
was all super top secret

00:43:59,269 --> 00:44:05,359
neither one knew that the other had

00:44:01,549 --> 00:44:06,920
invented the same thing but

00:44:05,359 --> 00:44:08,809
fundamentally it has this thing of

00:44:06,920 --> 00:44:13,069
having a pair of keys instead of just

00:44:08,809 --> 00:44:14,900
one key and they work together and

00:44:13,069 --> 00:44:16,609
effectively message is encrypted with

00:44:14,900 --> 00:44:19,400
the public key can be decrypted with a

00:44:16,609 --> 00:44:22,039
private key and sort of vice versa and

00:44:19,400 --> 00:44:25,249
it's also a critical component of key

00:44:22,039 --> 00:44:27,259
exchange now one of the problems with

00:44:25,249 --> 00:44:29,239
this with the whole public key

00:44:27,259 --> 00:44:31,520
encryption approach is that it's

00:44:29,239 --> 00:44:33,860
extremely slow its orders of may

00:44:31,520 --> 00:44:37,460
nate'd slower than secret key encryption

00:44:33,860 --> 00:44:39,530
and so what you actually do is you use

00:44:37,460 --> 00:44:41,810
public key encryption and all you use it

00:44:39,530 --> 00:44:43,940
for is to transfer a key from one side

00:44:41,810 --> 00:44:45,890
to the other and that means that you've

00:44:43,940 --> 00:44:47,390
got you've got the public key algorithm

00:44:45,890 --> 00:44:49,160
dealing with just a tiny weeny little

00:44:47,390 --> 00:44:51,110
piece of data it's just the key itself

00:44:49,160 --> 00:44:51,470
you transfer that from one site to the

00:44:51,110 --> 00:44:53,150
other

00:44:51,470 --> 00:44:56,060
and once you've both got the same key

00:44:53,150 --> 00:44:58,400
you can then switch to using secret key

00:44:56,060 --> 00:45:01,820
encryption which is way way faster and

00:44:58,400 --> 00:45:03,380
that's exactly how TLS works during the

00:45:01,820 --> 00:45:04,970
handshake at the beginning of it it

00:45:03,380 --> 00:45:06,530
opens up this conversation it sorts out

00:45:04,970 --> 00:45:09,020
which algorithms it's going to use and

00:45:06,530 --> 00:45:10,970
then it picks the best one transfers the

00:45:09,020 --> 00:45:19,400
key and then switches to using the

00:45:10,970 --> 00:45:20,840
symmetric algorithm and again there are

00:45:19,400 --> 00:45:23,540
a whole bunch of popular algorithms to

00:45:20,840 --> 00:45:26,510
use this in key exchange RSA at

00:45:23,540 --> 00:45:29,360
diffie-hellman and more recently X 255

00:45:26,510 --> 00:45:31,280
19 all of these are what RSA is slightly

00:45:29,360 --> 00:45:33,380
different because it actually is a

00:45:31,280 --> 00:45:36,530
cipher as well as being a key exchange

00:45:33,380 --> 00:45:37,520
thing but diffie-hellman you'll see all

00:45:36,530 --> 00:45:42,820
over the place you'll see things

00:45:37,520 --> 00:45:42,820
mentioning D H occurs all over the place

00:45:43,570 --> 00:45:47,870
so how do we do public key encryption is

00:45:45,920 --> 00:45:49,460
sodium where has this whole bunch of box

00:45:47,870 --> 00:45:51,680
functions instead of being secret box

00:45:49,460 --> 00:45:55,640
it's just box because it's the public

00:45:51,680 --> 00:45:58,550
key and internally it uses X 255 19 key

00:45:55,640 --> 00:46:00,650
exchange and the X salsa 20 stream

00:45:58,550 --> 00:46:04,430
cipher which is the symmetric cipher and

00:46:00,650 --> 00:46:06,800
a poly 1305 mac to ensure integrity how

00:46:04,430 --> 00:46:10,400
do you actually do it well it's slightly

00:46:06,800 --> 00:46:12,380
more involved in using secret key

00:46:10,400 --> 00:46:14,390
encryption we're fundamentally on each

00:46:12,380 --> 00:46:16,520
end we're so imagine we have two nodes a

00:46:14,390 --> 00:46:20,450
and B on each side we do the same thing

00:46:16,520 --> 00:46:21,950
we make a key pair and we extract the

00:46:20,450 --> 00:46:24,950
secret key and the public key from the

00:46:21,950 --> 00:46:27,440
pair on each side and then we want node

00:46:24,950 --> 00:46:32,150
a to send a message to no be using B's

00:46:27,440 --> 00:46:34,610
public key and A's private key so we

00:46:32,150 --> 00:46:36,170
have our message and then literally we

00:46:34,610 --> 00:46:38,720
just this is just string concatenation

00:46:36,170 --> 00:46:39,470
in PHP is actually far simpler than you

00:46:38,720 --> 00:46:42,890
might expect

00:46:39,470 --> 00:46:44,630
we take no days secret key and node B's

00:46:42,890 --> 00:46:45,349
public key and the public key we can

00:46:44,630 --> 00:46:47,119
just go and get off

00:46:45,349 --> 00:46:50,569
website it's the first half of a TLS

00:46:47,119 --> 00:46:52,099
handshake for example but this this is

00:46:50,569 --> 00:46:53,720
outside TLS this is something you're

00:46:52,099 --> 00:46:55,759
doing it yourself instead of using TLS

00:46:53,720 --> 00:46:59,239
you might be implementing your secure

00:46:55,759 --> 00:47:01,130
chat client or something so you just tap

00:46:59,239 --> 00:47:03,950
those two things together we make a

00:47:01,130 --> 00:47:05,960
nonce again using secret box not nonce

00:47:03,950 --> 00:47:08,029
by its consonant and we feed the whole

00:47:05,960 --> 00:47:11,059
lot we got the nonce here and we just

00:47:08,029 --> 00:47:12,890
literally we just append the encrypted

00:47:11,059 --> 00:47:15,529
text with the nonce there now this is

00:47:12,890 --> 00:47:18,319
making use of the a EAD cipher feature

00:47:15,529 --> 00:47:21,619
of having some plain text embedded along

00:47:18,319 --> 00:47:23,539
with it so we pass in the nonce to that

00:47:21,619 --> 00:47:24,920
as well and the keys that we made by

00:47:23,539 --> 00:47:26,690
sticking them together and that's our

00:47:24,920 --> 00:47:29,180
cipher text we send that over to the

00:47:26,690 --> 00:47:31,609
other side where we want to decrypt it

00:47:29,180 --> 00:47:34,519
and here we do kind of the mirror image

00:47:31,609 --> 00:47:36,229
we take our own secret key which is the

00:47:34,519 --> 00:47:39,680
flip side of the public key here and

00:47:36,229 --> 00:47:41,180
then we take no days public key which is

00:47:39,680 --> 00:47:43,009
the flip side of this key so there's a

00:47:41,180 --> 00:47:46,819
nice little crossover of those two there

00:47:43,009 --> 00:47:48,710
and we pass them into here we then we

00:47:46,819 --> 00:47:50,359
need to extract the nonce which you know

00:47:48,710 --> 00:47:52,430
so we tacked on the front here and we

00:47:50,359 --> 00:47:56,180
knew how big it was so we just use the

00:47:52,430 --> 00:47:57,529
same constant to strip off that that

00:47:56,180 --> 00:47:59,660
chunk of data off the front and

00:47:57,529 --> 00:48:03,950
similarly we take the ciphertext and we

00:47:59,660 --> 00:48:05,599
just lock the rest of it off and then we

00:48:03,950 --> 00:48:07,880
pass in those parameters into there and

00:48:05,599 --> 00:48:09,739
we end up with the decrypted content so

00:48:07,880 --> 00:48:12,769
that's the whole thing that's all you

00:48:09,739 --> 00:48:17,960
have to do for for doing complete public

00:48:12,769 --> 00:48:20,539
key encryption in your own code other

00:48:17,960 --> 00:48:22,700
cryptographic functions key derivation

00:48:20,539 --> 00:48:24,799
this is really just essentially how to

00:48:22,700 --> 00:48:27,319
do the password hashing thing again I

00:48:24,799 --> 00:48:29,299
mention sodium's quite keen on returning

00:48:27,319 --> 00:48:31,579
binary values instead of like hex

00:48:29,299 --> 00:48:33,710
strings from from crits graphic

00:48:31,579 --> 00:48:35,839
functions and the crypto password hash

00:48:33,710 --> 00:48:37,969
function does exactly that it returns

00:48:35,839 --> 00:48:39,499
binary values so that it tends to me not

00:48:37,969 --> 00:48:42,109
be the kind of thing that you normally

00:48:39,499 --> 00:48:43,869
actually use but you may want to use it

00:48:42,109 --> 00:48:46,640
for compatibility reasons or something

00:48:43,869 --> 00:48:49,400
you can actually do the key exchange

00:48:46,640 --> 00:48:51,109
part that we saw during that public key

00:48:49,400 --> 00:48:53,869
encryption you can do that bit all by

00:48:51,109 --> 00:48:55,249
itself you don't have to follow up with

00:48:53,869 --> 00:48:57,890
actually transmitting a message you can

00:48:55,249 --> 00:48:58,760
just just use the public key encryption

00:48:57,890 --> 00:49:02,330
mechanism

00:48:58,760 --> 00:49:03,710
purely to transfer a key and then not do

00:49:02,330 --> 00:49:06,260
anything else not actually transfer a

00:49:03,710 --> 00:49:07,910
message at all but it then means that in

00:49:06,260 --> 00:49:09,290
future you can use that secret key

00:49:07,910 --> 00:49:14,780
because you know that the other end has

00:49:09,290 --> 00:49:17,630
got it how key exchange works is amazing

00:49:14,780 --> 00:49:19,340
it's so clever in particularly the

00:49:17,630 --> 00:49:21,650
diffie-hellman algorithm that's that's

00:49:19,340 --> 00:49:24,800
used behind all of it is it's just it's

00:49:21,650 --> 00:49:25,970
just a wonderfully elegant thing and I

00:49:24,800 --> 00:49:28,130
don't really understand the math behind

00:49:25,970 --> 00:49:29,750
it but the actual principle is just

00:49:28,130 --> 00:49:31,340
amazing there's a really good

00:49:29,750 --> 00:49:34,640
explanation on Wikipedia and there's

00:49:31,340 --> 00:49:36,980
some videos on YouTube using a color

00:49:34,640 --> 00:49:38,660
mixing as an example of the the

00:49:36,980 --> 00:49:42,619
effective way that it does it it's

00:49:38,660 --> 00:49:46,250
really clever another thing that you can

00:49:42,619 --> 00:49:47,660
do is digital signatures and this is a

00:49:46,250 --> 00:49:50,150
little bit like using public key

00:49:47,660 --> 00:49:51,680
encryption backwards where one of the

00:49:50,150 --> 00:49:53,630
problems with using a Mac to sign

00:49:51,680 --> 00:49:56,359
something is that it in order to verify

00:49:53,630 --> 00:49:59,630
a Mac you have to have the key and

00:49:56,359 --> 00:50:01,940
that's a problem because if you've got

00:49:59,630 --> 00:50:04,250
the key then sure you can verify it but

00:50:01,940 --> 00:50:05,630
you can also resize because it uses the

00:50:04,250 --> 00:50:07,790
same key it's just like secret key

00:50:05,630 --> 00:50:10,850
encryption use the same key to verify as

00:50:07,790 --> 00:50:11,869
you do to create a new one so that's a

00:50:10,850 --> 00:50:14,450
problem but you can use a digital

00:50:11,869 --> 00:50:17,780
signature which effectively reverses the

00:50:14,450 --> 00:50:19,609
thing River traverses the public key

00:50:17,780 --> 00:50:21,440
encryption mechanism which means that

00:50:19,609 --> 00:50:22,940
you actually end up not encrypting the

00:50:21,440 --> 00:50:25,790
content but you still end up with the

00:50:22,940 --> 00:50:28,280
signature and you can verify that using

00:50:25,790 --> 00:50:31,340
the public keys again but that means

00:50:28,280 --> 00:50:33,440
that you're able to verify the content

00:50:31,340 --> 00:50:36,290
without having a key that would allow

00:50:33,440 --> 00:50:38,180
you to very ate a new key for some new

00:50:36,290 --> 00:50:44,810
content because you don't have the

00:50:38,180 --> 00:50:45,980
secret key associated with it as I

00:50:44,810 --> 00:50:47,240
mentioned before there are a few little

00:50:45,980 --> 00:50:50,990
problems with the way that things have

00:50:47,240 --> 00:50:53,780
been implemented in PHP the password

00:50:50,990 --> 00:50:56,150
hash function in PHP 7.2 actually

00:50:53,780 --> 00:50:58,640
already has the password are gong to I

00:50:56,150 --> 00:51:00,830
so it does the the timing resistor the

00:50:58,640 --> 00:51:03,200
side-channel resistant version of argon

00:51:00,830 --> 00:51:04,550
2 but unfortunately that implementation

00:51:03,200 --> 00:51:07,970
is provided by a different library

00:51:04,550 --> 00:51:09,770
called Lib argon 2 which isn't included

00:51:07,970 --> 00:51:11,890
by default so you can't really rely on

00:51:09,770 --> 00:51:14,049
it being there so

00:51:11,890 --> 00:51:21,210
sodium provides a better argon to

00:51:14,049 --> 00:51:21,210
algorithms it supports argon to ID but

00:51:22,230 --> 00:51:26,920
it's not used by password hash

00:51:24,700 --> 00:51:28,450
unfortunately there was a really good

00:51:26,920 --> 00:51:30,099
Twitter conversation just recently which

00:51:28,450 --> 00:51:34,390
might mean that this does actually end

00:51:30,099 --> 00:51:37,660
up happening the argon to ID version is

00:51:34,390 --> 00:51:39,940
actually being added in PHP 7.3 so

00:51:37,660 --> 00:51:42,279
that's good but again it suffers from

00:51:39,940 --> 00:51:44,470
exactly the same problem unfortunately

00:51:42,279 --> 00:51:46,089
laravel recently added support for argon

00:51:44,470 --> 00:51:49,869
T passwords and that would have been a

00:51:46,089 --> 00:51:52,390
great opportunity to to solve that

00:51:49,869 --> 00:51:56,289
problem to bridge that gap but it just

00:51:52,390 --> 00:51:58,240
didn't really happen but ultimately you

00:51:56,289 --> 00:52:02,079
can get around it just by using sodium's

00:51:58,240 --> 00:52:09,670
crypto function I'm kind of at a time

00:52:02,079 --> 00:52:11,410
here this few minutes as a little

00:52:09,670 --> 00:52:14,890
example one of the things that I've used

00:52:11,410 --> 00:52:18,549
this for is generating API tokens in

00:52:14,890 --> 00:52:20,740
laravel and the idea here is that I want

00:52:18,549 --> 00:52:24,279
to be able to have something where I can

00:52:20,740 --> 00:52:26,140
have people log in to a website but not

00:52:24,279 --> 00:52:28,720
have to store anything about their

00:52:26,140 --> 00:52:30,819
session on the server-side and that's a

00:52:28,720 --> 00:52:32,440
really great way of scaling stuff pretty

00:52:30,819 --> 00:52:33,660
much all scalable solutions have the one

00:52:32,440 --> 00:52:35,829
thing in common is essentially

00:52:33,660 --> 00:52:37,299
offloading stuff to the client wherever

00:52:35,829 --> 00:52:40,329
possible I think one of the best

00:52:37,299 --> 00:52:42,099
examples of that is memcache memcache

00:52:40,329 --> 00:52:43,630
just scales absolutely beautifully and

00:52:42,099 --> 00:52:45,880
it does it by putting all the

00:52:43,630 --> 00:52:47,710
intelligence or the client end the

00:52:45,880 --> 00:52:49,480
individual servers have no idea that the

00:52:47,710 --> 00:52:57,339
other servers even exist but the clients

00:52:49,480 --> 00:53:01,539
do so here we get a we have a user ID

00:52:57,339 --> 00:53:05,500
and we do a JSON encode and we do I've

00:53:01,539 --> 00:53:08,049
just used the the chart r20 secret key

00:53:05,500 --> 00:53:11,380
encryption and I just encrypt it and I

00:53:08,049 --> 00:53:11,710
just tack the the API token with the

00:53:11,380 --> 00:53:13,750
nonce

00:53:11,710 --> 00:53:15,279
and the encrypted content of it into the

00:53:13,750 --> 00:53:19,410
key that's passed back after somebody's

00:53:15,279 --> 00:53:21,849
logged in because this is encrypted and

00:53:19,410 --> 00:53:24,099
we know that it's authenticated and we

00:53:21,849 --> 00:53:25,630
guarantee its integrity it's safe to

00:53:24,099 --> 00:53:27,640
give it to the client they can't

00:53:25,630 --> 00:53:29,410
put with it so we give that to the

00:53:27,640 --> 00:53:31,329
client and then if it's in a cookie or

00:53:29,410 --> 00:53:36,279
in an authentication header they give it

00:53:31,329 --> 00:53:37,180
back to us and then we can just decode

00:53:36,279 --> 00:53:40,990
it afterwards

00:53:37,180 --> 00:53:46,420
so here's is the the decoding side of it

00:53:40,990 --> 00:53:53,140
so they make a request to us there's a

00:53:46,420 --> 00:53:55,390
deer and we do something clever here

00:53:53,140 --> 00:53:56,890
this is another sodium feature this men

00:53:55,390 --> 00:53:58,539
zero when the problems here is that

00:53:56,890 --> 00:54:01,329
we've we still think we've got the key

00:53:58,539 --> 00:54:02,200
in memory but once we've used it we

00:54:01,329 --> 00:54:03,940
don't need it anymore

00:54:02,200 --> 00:54:06,519
however it's still lying around in

00:54:03,940 --> 00:54:08,710
memory and a favorite thing of binary

00:54:06,519 --> 00:54:10,180
analysts to do is to try and grab the

00:54:08,710 --> 00:54:12,490
entire contents of memory or something

00:54:10,180 --> 00:54:15,220
and analyze the the contents of it and

00:54:12,490 --> 00:54:18,039
try and find keys within that memory so

00:54:15,220 --> 00:54:19,750
this MEMS Eero function spots the space

00:54:18,039 --> 00:54:22,349
that's used by the key and over writes

00:54:19,750 --> 00:54:24,910
it with either zeros or just random data

00:54:22,349 --> 00:54:27,420
so that means that somebody doing binary

00:54:24,910 --> 00:54:33,369
analysis on it can't find it later on

00:54:27,420 --> 00:54:37,390
so we then decode the value that we

00:54:33,369 --> 00:54:39,369
decrypted from here using the same keys

00:54:37,390 --> 00:54:40,599
because because it's both ends of this

00:54:39,369 --> 00:54:43,450
conversation to have things happening

00:54:40,599 --> 00:54:44,650
under our control we've got the key so

00:54:43,450 --> 00:54:46,269
we don't have to worry about the client

00:54:44,650 --> 00:54:47,920
we give them something encrypted they

00:54:46,269 --> 00:54:51,490
give the same thing back to us and then

00:54:47,920 --> 00:54:53,289
we then verify that it is actually it

00:54:51,490 --> 00:54:55,329
basically if it's if they have tampered

00:54:53,289 --> 00:54:56,799
with it the decryption will fail and

00:54:55,329 --> 00:54:59,619
we'll count them as not being logged in

00:54:56,799 --> 00:55:05,170
so we we then go you need to log in

00:54:59,619 --> 00:55:07,359
before you do this and then we can pass

00:55:05,170 --> 00:55:09,369
in we can extract these two things and

00:55:07,359 --> 00:55:11,740
we just check that it hasn't expired and

00:55:09,369 --> 00:55:14,710
that the user actually exists and then

00:55:11,740 --> 00:55:16,599
we're we're happy with that so that's an

00:55:14,710 --> 00:55:18,849
example of actually using the sodium

00:55:16,599 --> 00:55:21,640
crypto functions in an actual practical

00:55:18,849 --> 00:55:23,349
application one of the things about

00:55:21,640 --> 00:55:24,819
sodium is the documentation and

00:55:23,349 --> 00:55:29,920
unfortunately you're gonna see a lot of

00:55:24,819 --> 00:55:31,690
this sodium because it's implemented in

00:55:29,920 --> 00:55:34,599
so many different places actually has

00:55:31,690 --> 00:55:37,299
its own documentation fortunately for

00:55:34,599 --> 00:55:39,640
the most part that all works exactly the

00:55:37,299 --> 00:55:41,470
same in PHP as it does in other language

00:55:39,640 --> 00:55:44,140
so if you go and look at lib sodium zone

00:55:41,470 --> 00:55:48,390
documentation you'll find stuff there

00:55:44,140 --> 00:55:51,010
I mentioned Scot our kazursky at Paragon

00:55:48,390 --> 00:55:53,110
he's got really good documentation lots

00:55:51,010 --> 00:55:54,940
of really great examples of how to use

00:55:53,110 --> 00:55:57,010
sodium and some of the detail on the

00:55:54,940 --> 00:55:58,810
functions and so on and I've actually

00:55:57,010 --> 00:56:00,940
been making a start on trying to

00:55:58,810 --> 00:56:02,920
actually write some of that stuff into

00:56:00,940 --> 00:56:04,030
the real PHP Docs however it's been a

00:56:02,920 --> 00:56:06,130
bit of a learning process for me I

00:56:04,030 --> 00:56:08,740
hadn't written any of the official PHP

00:56:06,130 --> 00:56:10,390
Docs before and it's quite complicated

00:56:08,740 --> 00:56:11,890
to get into it in the first place and

00:56:10,390 --> 00:56:14,380
it's not really very clear how you have

00:56:11,890 --> 00:56:15,820
to do it and the other thing is I've

00:56:14,380 --> 00:56:19,270
written stuff and it's just sitting

00:56:15,820 --> 00:56:20,890
there and I have no idea how to say can

00:56:19,270 --> 00:56:22,600
somebody look at this oh the other thing

00:56:20,890 --> 00:56:24,370
it doesn't help the lot of the PHP

00:56:22,600 --> 00:56:26,020
mailing lists don't actually work it's

00:56:24,370 --> 00:56:27,910
not possible to sign up for like the

00:56:26,020 --> 00:56:32,350
documentation mailing list and say hey

00:56:27,910 --> 00:56:33,370
can someone go go commit this please so

00:56:32,350 --> 00:56:35,170
there's a whole load of stuff just

00:56:33,370 --> 00:56:36,760
sitting there waiting to be merged and

00:56:35,170 --> 00:56:39,070
I'm not really sure when it's going to

00:56:36,760 --> 00:56:41,320
happen so I haven't been pushing too

00:56:39,070 --> 00:56:43,300
hard on that but I've I just wrote I

00:56:41,320 --> 00:56:44,710
write all the documentation for the for

00:56:43,300 --> 00:56:46,390
the password hash functions because

00:56:44,710 --> 00:56:50,800
they're probably the thing that is most

00:56:46,390 --> 00:56:53,830
likely to be used so in summary don't

00:56:50,800 --> 00:56:57,490
roll your own crypto don't use legacy

00:56:53,830 --> 00:56:58,360
crypto in new applications use sodium if

00:56:57,490 --> 00:57:01,180
you're going to do any kind of

00:56:58,360 --> 00:57:03,070
encryption in PHP with the fundamental

00:57:01,180 --> 00:57:04,450
aim that it's trying to remove ambiguity

00:57:03,070 --> 00:57:08,410
and doubt from any cryptographic

00:57:04,450 --> 00:57:10,600
functions that you're using and over all

00:57:08,410 --> 00:57:12,700
sodium really raises a security bar if

00:57:10,600 --> 00:57:15,190
you're using sodium in your app you can

00:57:12,700 --> 00:57:17,650
be pretty much sure certainly for now

00:57:15,190 --> 00:57:19,930
that you're doing stuff right you're not

00:57:17,650 --> 00:57:21,400
doing things wrong you're not going to

00:57:19,930 --> 00:57:23,770
be vulnerable so follow the

00:57:21,400 --> 00:57:26,170
documentation on sodium site and so on

00:57:23,770 --> 00:57:27,190
but it does really need your help for

00:57:26,170 --> 00:57:35,320
the docs if you're up to writing

00:57:27,190 --> 00:57:38,250
something and that's pretty much it so

00:57:35,320 --> 00:57:38,250
any questions

00:58:01,859 --> 00:58:09,819
yeah hmm

00:58:06,640 --> 00:58:13,089
well the password hash functions

00:58:09,819 --> 00:58:15,760
actually avoid that problem by actually

00:58:13,089 --> 00:58:16,779
embedding the algorithm and the thing

00:58:15,760 --> 00:58:19,000
this is such part of the difference

00:58:16,779 --> 00:58:21,520
between the the binary password hash

00:58:19,000 --> 00:58:24,069
function and the text version the text

00:58:21,520 --> 00:58:25,240
version embeds a little prefix now that

00:58:24,069 --> 00:58:26,650
if you've ever actually looked at the

00:58:25,240 --> 00:58:28,329
the prefixes generated like by the

00:58:26,650 --> 00:58:29,740
password hash function the ones

00:58:28,329 --> 00:58:31,720
generated by are gone are exactly the

00:58:29,740 --> 00:58:34,390
same kind of pattern it tells you what

00:58:31,720 --> 00:58:36,400
the algorithm was what is and the the

00:58:34,390 --> 00:58:39,579
argon two algorithm actually has two

00:58:36,400 --> 00:58:41,170
variables it tell it tells it basically

00:58:39,579 --> 00:58:44,319
how much memory to use and how much CPU

00:58:41,170 --> 00:58:45,789
to use and so it needs to store those

00:58:44,319 --> 00:58:47,680
parameters in order for you to be able

00:58:45,789 --> 00:58:49,569
to recalculate the same hash later on

00:58:47,680 --> 00:58:51,730
but that's embedded into the string that

00:58:49,569 --> 00:58:53,440
it generates so in future you will be

00:58:51,730 --> 00:58:54,670
able to still verify that and it will

00:58:53,440 --> 00:58:56,380
know that it uses that particular

00:58:54,670 --> 00:58:58,240
algorithm but any new ones that you

00:58:56,380 --> 00:59:01,000
generate will use whatever new algorithm

00:58:58,240 --> 00:59:02,760
it is now on things like the secret key

00:59:01,000 --> 00:59:05,589
encryption it's more of a problem

00:59:02,760 --> 00:59:06,970
certainly but generally if you're doing

00:59:05,589 --> 00:59:09,220
secret key you're probably in charge of

00:59:06,970 --> 00:59:11,190
both ends anyway so that's not really a

00:59:09,220 --> 00:59:13,029
problem and if it's public key is

00:59:11,190 --> 00:59:16,210
there's probably going to be a lot more

00:59:13,029 --> 00:59:19,230
headlines if someone breaks that you'll

00:59:16,210 --> 00:59:22,230
know all about it a long way in advance

00:59:19,230 --> 00:59:22,230
anymore

00:59:29,690 --> 00:59:35,750
no it doesn't actually it actually does

00:59:32,359 --> 00:59:37,819
the reverse weirdly enough sha-256 has

00:59:35,750 --> 00:59:40,099
some that nobody's actually found out a

00:59:37,819 --> 00:59:43,299
working exploit for it but there is the

00:59:40,099 --> 00:59:47,299
potential for more likely collisions in

00:59:43,299 --> 00:59:48,859
sha-256 so sha-512 slash t56 is actually

00:59:47,299 --> 00:59:52,609
considered to be slightly more secure

00:59:48,859 --> 00:59:54,559
than sha-256 is but fundamentally

00:59:52,609 --> 00:59:57,890
they're both 256-bit algorithms and the

00:59:54,559 --> 01:00:00,529
sha-2 algorithm is really pretty good

00:59:57,890 --> 01:00:02,210
for now it's it's holding up well

01:00:00,529 --> 01:00:05,440
in the face of quite a lot of attacks

01:00:02,210 --> 01:00:09,950
and attempts and lots of theorization

01:00:05,440 --> 01:00:13,630
anymore no right well I guess we're done

01:00:09,950 --> 01:00:13,630
that's conference over

01:00:13,730 --> 01:00:21,570
[Applause]

01:00:14,180 --> 01:00:21,570

YouTube URL: https://www.youtube.com/watch?v=uvlET2dceTk


