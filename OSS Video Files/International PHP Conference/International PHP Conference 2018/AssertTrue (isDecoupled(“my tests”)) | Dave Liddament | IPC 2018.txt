Title: AssertTrue (isDecoupled(“my tests”)) | Dave Liddament | IPC 2018
Publication date: 2019-02-07
Playlist: International PHP Conference 2018
Description: 
	Dave Liddament (Lamp Bristol): “Houston we have a problem! This change you want… Well, it’s one small change for the codebase but one giant change to the test suite!” We all know why tests are great. But every once in a while we just wish they’d never been written. One case when test regret occurs is when we want to alter our functionality slightly but in doing so half the test suite goes from green to red. This talk will investigate why this happens. In particular, it looks at the coupling between tests and the code under test. We’ll investigate ways of reducing this coupling and make out test suites more resilient to change. This talk is aimed at those who already write tests and have a good understanding of SOLID principles.
Captions: 
	00:00:00,160 --> 00:00:04,209
[Music]

00:00:06,170 --> 00:00:12,389
they're here extra early for the young

00:00:08,730 --> 00:00:15,299
first talk of the day as called a

00:00:12,389 --> 00:00:19,740
surgery is being coupled my tests and

00:00:15,299 --> 00:00:23,519
I'm Dave ligament so the one line after

00:00:19,740 --> 00:00:25,529
why we're here is because ESTs reduce

00:00:23,519 --> 00:00:29,220
the development of maintenance cost of

00:00:25,529 --> 00:00:30,539
the test suite so hopefully and by the

00:00:29,220 --> 00:00:33,270
end of this talk you'll see how

00:00:30,539 --> 00:00:36,329
decoupled tests can achieve that goal

00:00:33,270 --> 00:00:38,129
and why is that important and if we

00:00:36,329 --> 00:00:40,469
think about the value of tests it's

00:00:38,129 --> 00:00:43,680
essentially the cost of the bugs that

00:00:40,469 --> 00:00:44,930
are found by the tests minus the cost of

00:00:43,680 --> 00:00:49,350
the test suite

00:00:44,930 --> 00:00:51,059
so obviously bugs have all kinds of

00:00:49,350 --> 00:00:52,649
costs there's cost to fix it those

00:00:51,059 --> 00:00:54,809
reputational damage there's all those

00:00:52,649 --> 00:00:55,500
kind of costs but a test suite is not

00:00:54,809 --> 00:00:57,859
free either

00:00:55,500 --> 00:01:00,629
and there's costs to buy the code and

00:00:57,859 --> 00:01:04,019
the tests and the costs to keep it

00:01:00,629 --> 00:01:06,299
maintained and if we can lower the cost

00:01:04,019 --> 00:01:08,010
of that test suite and lower than the

00:01:06,299 --> 00:01:11,460
maintenance cost of it then we get

00:01:08,010 --> 00:01:13,130
better value from our tests and again

00:01:11,460 --> 00:01:15,000
hopefully by the end of this talk and

00:01:13,130 --> 00:01:19,189
you'll see how we're going to achieve

00:01:15,000 --> 00:01:21,299
this so that's that's why we're here and

00:01:19,189 --> 00:01:22,830
there's lots of great talks going on

00:01:21,299 --> 00:01:26,220
right now so I want to make sure you're

00:01:22,830 --> 00:01:27,630
in the right room and this talk is for

00:01:26,220 --> 00:01:29,070
you I think you probably got to do at

00:01:27,630 --> 00:01:30,990
least to some level or to make the test

00:01:29,070 --> 00:01:35,280
things get something out of it and if

00:01:30,990 --> 00:01:36,869
you want a high-level overview that of

00:01:35,280 --> 00:01:38,130
concepts can be applied for things

00:01:36,869 --> 00:01:40,020
predominantly we're talking about

00:01:38,130 --> 00:01:42,299
testing via the user interface and the

00:01:40,020 --> 00:01:43,799
integration level tests so that's kind

00:01:42,299 --> 00:01:46,280
of where we operating at we're not

00:01:43,799 --> 00:01:48,720
talking so much about unit tests today

00:01:46,280 --> 00:01:50,610
it probably isn't for you though if

00:01:48,720 --> 00:01:52,560
you're an experienced tester and you're

00:01:50,610 --> 00:01:56,460
testing all the way through your stuff

00:01:52,560 --> 00:01:57,750
West software stack and and this is all

00:01:56,460 --> 00:02:00,659
quite abstract so if you don't like

00:01:57,750 --> 00:02:05,009
abstract talks and this is probably the

00:02:00,659 --> 00:02:08,160
time to do a runner so I'm Dave

00:02:05,009 --> 00:02:10,429
liniments I work for small software

00:02:08,160 --> 00:02:12,319
consultancy called Lang Bristol

00:02:10,429 --> 00:02:14,689
helped organize a few meetups over in

00:02:12,319 --> 00:02:17,180
the UK and when I'm not doing tech stuff

00:02:14,689 --> 00:02:18,980
you might see me scuba diving that's a

00:02:17,180 --> 00:02:28,430
picture of me in the city I was a few

00:02:18,980 --> 00:02:30,620
years ago and as well I've been working

00:02:28,430 --> 00:02:33,170
the industry for about 15 years in

00:02:30,620 --> 00:02:35,359
various languages and I was fortunate

00:02:33,170 --> 00:02:36,889
there probably about half that time of

00:02:35,359 --> 00:02:40,129
working on projects where there was some

00:02:36,889 --> 00:02:42,799
kind of automated test testing going on

00:02:40,129 --> 00:02:45,349
and it's from those eight years will say

00:02:42,799 --> 00:02:47,870
that I've got a few stories of things

00:02:45,349 --> 00:02:49,250
that generally I've done badly and we'll

00:02:47,870 --> 00:02:53,389
learn from them so hopefully you don't

00:02:49,250 --> 00:02:54,889
get the same pain points that I had and

00:02:53,389 --> 00:02:56,439
but before we start on these three

00:02:54,889 --> 00:02:58,639
stories there's going to be a bit of

00:02:56,439 --> 00:02:59,810
we've kind of discussed why this is

00:02:58,639 --> 00:03:02,810
important and we're just going to do a

00:02:59,810 --> 00:03:04,370
bit of terminology so we're all on the

00:03:02,810 --> 00:03:11,780
same page when I when I use certain

00:03:04,370 --> 00:03:14,239
terms so on the whole I'm pretty happy

00:03:11,780 --> 00:03:16,459
with having a test suite and running the

00:03:14,239 --> 00:03:19,400
tests makes me feel happy seeing all the

00:03:16,459 --> 00:03:22,010
tests pass make me feel happy but every

00:03:19,400 --> 00:03:24,829
once in a while I really kind of hate my

00:03:22,010 --> 00:03:26,780
test suite and I'm one such time this

00:03:24,829 --> 00:03:28,340
one I like a really small change what

00:03:26,780 --> 00:03:30,199
appears to be a small change to the

00:03:28,340 --> 00:03:33,079
function app functionality of whatever

00:03:30,199 --> 00:03:36,680
code I'm writing and and that small

00:03:33,079 --> 00:03:39,340
change it's one tiny step for the

00:03:36,680 --> 00:03:42,139
requirements but it's one giant leap for

00:03:39,340 --> 00:03:45,019
test Suites and what happens is that our

00:03:42,139 --> 00:03:47,540
tests go from all passing we make a tiny

00:03:45,019 --> 00:03:49,970
little change and then after test suite

00:03:47,540 --> 00:03:53,180
fails and there's lots of failures and

00:03:49,970 --> 00:03:57,470
it's kind of sad face so it's confession

00:03:53,180 --> 00:03:59,449
time now and have written tests that's

00:03:57,470 --> 00:04:04,220
not actually the confession but I was

00:03:59,449 --> 00:04:05,959
near the deadline and I made a little

00:04:04,220 --> 00:04:07,519
bit of a change and suddenly all the

00:04:05,959 --> 00:04:09,409
tests failed just a whole lot of the

00:04:07,519 --> 00:04:12,290
tests failed and I looked at what was

00:04:09,409 --> 00:04:15,139
going on and I thought that's okay it's

00:04:12,290 --> 00:04:17,630
just there's nothing actually wrong the

00:04:15,139 --> 00:04:18,919
functionality is fine but I've the way

00:04:17,630 --> 00:04:20,419
I've written a test or a lot the tests

00:04:18,919 --> 00:04:21,670
mean that this this little change means

00:04:20,419 --> 00:04:23,530
I've got to go back and change

00:04:21,670 --> 00:04:25,780
there's loads of paling and thought

00:04:23,530 --> 00:04:29,260
that's a white right up against some of

00:04:25,780 --> 00:04:33,010
the deadlines I will fix this later on

00:04:29,260 --> 00:04:35,940
the got time and my confession is that

00:04:33,010 --> 00:04:38,710
six months later some of those tests

00:04:35,940 --> 00:04:40,480
still haven't been fixed even though I

00:04:38,710 --> 00:04:43,740
said I was going to do it I found I've

00:04:40,480 --> 00:04:47,110
got another confession that a year later

00:04:43,740 --> 00:04:49,510
some of these tests I just sent skipping

00:04:47,110 --> 00:04:51,580
or I've not really fixed and we're going

00:04:49,510 --> 00:04:53,320
to stop with confessions because the

00:04:51,580 --> 00:04:56,590
Enlightenment I love sounding really bad

00:04:53,320 --> 00:04:58,390
having sex that I'm just skipper for

00:04:56,590 --> 00:05:00,670
over a year now and of course that's a

00:04:58,390 --> 00:05:02,020
really bad thing because those tests

00:05:00,670 --> 00:05:03,850
were there they were there for reason

00:05:02,020 --> 00:05:06,250
they were there so but they're there now

00:05:03,850 --> 00:05:09,910
to protect my code and get against some

00:05:06,250 --> 00:05:11,740
kind of regression and because they're

00:05:09,910 --> 00:05:13,960
not being run that means that sometime

00:05:11,740 --> 00:05:16,150
in the future me or another developer

00:05:13,960 --> 00:05:17,740
will change the code in such a way that

00:05:16,150 --> 00:05:20,020
if those tests were working and

00:05:17,740 --> 00:05:22,900
operating then they would have caught

00:05:20,020 --> 00:05:25,480
whatever regression I added in but

00:05:22,900 --> 00:05:27,480
because they're not being run doesn't

00:05:25,480 --> 00:05:30,370
update them what I should have done and

00:05:27,480 --> 00:05:32,260
that means those tests on there that a

00:05:30,370 --> 00:05:33,550
safety check isn't there so in the

00:05:32,260 --> 00:05:36,390
future I'm almost definitely going to

00:05:33,550 --> 00:05:39,130
introduce some kind of regression as

00:05:36,390 --> 00:05:41,010
anyone got tests like over a year that

00:05:39,130 --> 00:05:43,570
they're being skipped for every year

00:05:41,010 --> 00:05:49,260
that's good I've don't feel so bad

00:05:43,570 --> 00:05:51,400
two years that's right buzzer okay so

00:05:49,260 --> 00:05:53,680
just another quick bit of terminology

00:05:51,400 --> 00:05:57,160
then and coupling so imagine you've got

00:05:53,680 --> 00:05:59,530
two objects a and B and coupling is the

00:05:57,160 --> 00:06:02,380
degree that these two objects know about

00:05:59,530 --> 00:06:04,180
each other so if you have two objects

00:06:02,380 --> 00:06:05,860
and they know nothing of each other

00:06:04,180 --> 00:06:07,330
they don't know any leaving the

00:06:05,860 --> 00:06:10,930
existence of each other

00:06:07,330 --> 00:06:16,300
then they're completely decoupled so if

00:06:10,930 --> 00:06:18,100
a is application and B is say our email

00:06:16,300 --> 00:06:18,640
gateway these two things don't even know

00:06:18,100 --> 00:06:21,640
about it

00:06:18,640 --> 00:06:23,650
each other but in reality in software

00:06:21,640 --> 00:06:26,800
they does need to be some knowledge of

00:06:23,650 --> 00:06:28,720
each other otherwise a cannot use B the

00:06:26,800 --> 00:06:32,910
application cannot use the email gateway

00:06:28,720 --> 00:06:37,170
so ideally all that a would know about B

00:06:32,910 --> 00:06:39,870
is it in space it would say ice when you

00:06:37,170 --> 00:06:42,240
send an email to this email address and

00:06:39,870 --> 00:06:44,460
here's a message and that ideally is all

00:06:42,240 --> 00:06:47,730
the a you need to know about the the

00:06:44,460 --> 00:06:49,500
email gateway and how B actually goes

00:06:47,730 --> 00:06:50,940
round sending those emails the

00:06:49,500 --> 00:06:54,840
application doesn't really care about

00:06:50,940 --> 00:06:56,640
you know maybe the email gateway next

00:06:54,840 --> 00:06:59,190
why 70p and sense of stuff

00:06:56,640 --> 00:07:02,400
maybe uses some kind of third-party like

00:06:59,190 --> 00:07:03,690
spot post or mail gun maybe it puts it

00:07:02,400 --> 00:07:06,780
in a queue and it all gets dealt with

00:07:03,690 --> 00:07:11,250
later but the point is the application

00:07:06,780 --> 00:07:13,290
doesn't know it doesn't care now imagine

00:07:11,250 --> 00:07:16,260
for whatever reason the application had

00:07:13,290 --> 00:07:19,440
to know more intricate details about how

00:07:16,260 --> 00:07:21,750
emails were sent and maybe you need to

00:07:19,440 --> 00:07:23,610
know the transport mechanism maybe it

00:07:21,750 --> 00:07:26,730
needed to know some credentials or

00:07:23,610 --> 00:07:28,710
something like that the problem is now

00:07:26,730 --> 00:07:30,570
the application is a lot more about the

00:07:28,710 --> 00:07:33,000
email gateway than it really needs to do

00:07:30,570 --> 00:07:35,730
and if we make a little change over

00:07:33,000 --> 00:07:37,380
there to the email gateway then maybe we

00:07:35,730 --> 00:07:38,430
also have to make a change to the

00:07:37,380 --> 00:07:40,680
application as well

00:07:38,430 --> 00:07:42,690
and maybe things are coupled to

00:07:40,680 --> 00:07:44,820
application so maybe one little things

00:07:42,690 --> 00:07:47,400
over there can ripple through our entire

00:07:44,820 --> 00:07:50,640
code base so we want to have things as

00:07:47,400 --> 00:07:53,580
loosely coupled as possible and when

00:07:50,640 --> 00:07:55,950
here the application needs to know about

00:07:53,580 --> 00:07:58,380
the internal workings of the email

00:07:55,950 --> 00:08:01,620
gateway then becoming more tightly

00:07:58,380 --> 00:08:04,830
coupled and generally that's about it or

00:08:01,620 --> 00:08:06,660
it's a very silly example it's a bit

00:08:04,830 --> 00:08:10,880
like junk food the less you know about

00:08:06,660 --> 00:08:17,810
what's going on inside it the better so

00:08:10,880 --> 00:08:19,620
one of the benefits and about having

00:08:17,810 --> 00:08:22,020
loosely coupled coned

00:08:19,620 --> 00:08:24,120
is it's very easy to have alternative

00:08:22,020 --> 00:08:25,860
implementations or something so imagine

00:08:24,120 --> 00:08:28,020
in this case airs our application and B

00:08:25,860 --> 00:08:31,410
is our payment payment gateway and we

00:08:28,020 --> 00:08:33,570
want to run tests now imagine if we had

00:08:31,410 --> 00:08:35,669
to use a real payment gateway every time

00:08:33,570 --> 00:08:37,620
we run our test suite it could get

00:08:35,669 --> 00:08:39,210
pretty expensive just to run the test

00:08:37,620 --> 00:08:41,550
Suites with all the payments we have to

00:08:39,210 --> 00:08:44,520
make so I asked ridiculous we won't

00:08:41,550 --> 00:08:47,130
really use a real payment gateway in

00:08:44,520 --> 00:08:48,810
in most of our testing and that's for

00:08:47,130 --> 00:08:49,339
specifically testing that that payment

00:08:48,810 --> 00:08:51,899
gateway

00:08:49,339 --> 00:08:53,310
so if I'll code so what we really want

00:08:51,899 --> 00:08:55,770
to do in tests is we want to replace

00:08:53,310 --> 00:08:57,810
something and that looks just like B

00:08:55,770 --> 00:09:01,529
it's not a real implementation it's a

00:08:57,810 --> 00:09:03,300
test double it behaves the same well it

00:09:01,529 --> 00:09:05,040
to the outside world to aid to the

00:09:03,300 --> 00:09:08,940
application it behaves the same but in

00:09:05,040 --> 00:09:11,490
reality it does something different so

00:09:08,940 --> 00:09:14,370
the more loosely coupled these two

00:09:11,490 --> 00:09:17,700
things are the easier it is to provide

00:09:14,370 --> 00:09:22,050
an alternative implementation for in

00:09:17,700 --> 00:09:24,630
this case our payment gateway and then

00:09:22,050 --> 00:09:30,720
again the final and a bit of terminology

00:09:24,630 --> 00:09:32,130
is the test parent and and it's kind of

00:09:30,720 --> 00:09:34,080
a way about thinking of the different

00:09:32,130 --> 00:09:37,410
levels of testing that we might do on

00:09:34,080 --> 00:09:38,910
our software and when we so the top of

00:09:37,410 --> 00:09:41,010
it is a UI that doesn't mean we're

00:09:38,910 --> 00:09:42,959
testing the UI it means we're testing

00:09:41,010 --> 00:09:47,070
our application via the user interface

00:09:42,959 --> 00:09:49,260
so that's oh that's into AI you might be

00:09:47,070 --> 00:09:51,899
doing elements of UI testing as unit

00:09:49,260 --> 00:09:53,910
test so for example if you had something

00:09:51,899 --> 00:09:55,560
in but angular app that converted a

00:09:53,910 --> 00:09:58,020
number into a currency you might

00:09:55,560 --> 00:10:00,000
actually unit test that bit of code so

00:09:58,020 --> 00:10:01,589
when I talk about UI testing today I'm

00:10:00,000 --> 00:10:04,800
talking about testing the application

00:10:01,589 --> 00:10:09,079
using the user interface as an entry

00:10:04,800 --> 00:10:12,990
point to testing it as a general rule

00:10:09,079 --> 00:10:15,510
unit tests are relative to testing by

00:10:12,990 --> 00:10:18,690
the user interface quick to write fast

00:10:15,510 --> 00:10:21,149
to run and cheap to maintain and as you

00:10:18,690 --> 00:10:24,240
kind of get up that pyramid the tests

00:10:21,149 --> 00:10:25,770
get slower to run they're more effort to

00:10:24,240 --> 00:10:29,430
write and they kind of evolve more and

00:10:25,770 --> 00:10:30,870
more bits of the system so ideally we

00:10:29,430 --> 00:10:32,370
want to maximize the number of unit

00:10:30,870 --> 00:10:33,959
tests but then you still have to make

00:10:32,370 --> 00:10:35,790
sure that all the unit tests are working

00:10:33,959 --> 00:10:37,230
correctly together so that's where

00:10:35,790 --> 00:10:39,690
you've got your integration tests and

00:10:37,230 --> 00:10:42,000
then you need to make sure that you're

00:10:39,690 --> 00:10:43,410
using spaces attached directly to that

00:10:42,000 --> 00:10:45,209
to the software you're Welling so that's

00:10:43,410 --> 00:10:49,860
why you do some tests by the user

00:10:45,209 --> 00:10:53,190
interface so that's enough terminology

00:10:49,860 --> 00:10:56,970
for now as a reminder this is is why

00:10:53,190 --> 00:10:59,630
we're here and let's see now the skelter

00:10:56,970 --> 00:11:03,600
above the first

00:10:59,630 --> 00:11:07,350
and so my first story is an application

00:11:03,600 --> 00:11:09,960
I wrote and what it was this was kind of

00:11:07,350 --> 00:11:12,960
quiz application so it was for an

00:11:09,960 --> 00:11:15,270
internal it's a a company and although

00:11:12,960 --> 00:11:17,670
employees went online and they answered

00:11:15,270 --> 00:11:19,500
these quizzes and every every couple

00:11:17,670 --> 00:11:21,600
months a new quiz would come out it was

00:11:19,500 --> 00:11:23,580
generally all a bit of fun but the word

00:11:21,600 --> 00:11:26,210
prizes for the best performing team and

00:11:23,580 --> 00:11:28,740
the best performing individual and

00:11:26,210 --> 00:11:32,070
employees would move every so often from

00:11:28,740 --> 00:11:33,570
one team to the other and the team and

00:11:32,070 --> 00:11:35,850
when you took one of these quizzes your

00:11:33,570 --> 00:11:38,400
score should be allocated to the team

00:11:35,850 --> 00:11:42,270
that you were a member of at the time we

00:11:38,400 --> 00:11:45,980
took that quiz yeah and I say it's all a

00:11:42,270 --> 00:11:50,790
bit of fun nothing too serious but so

00:11:45,980 --> 00:11:52,980
local this code and what would happen

00:11:50,790 --> 00:11:54,690
also typically user story sorry would be

00:11:52,980 --> 00:11:56,010
something like blah blah blah Green Bob

00:11:54,690 --> 00:11:58,710
would see a list of the quizzes and

00:11:56,010 --> 00:12:00,750
they'd pick one he hadn't done and then

00:11:58,710 --> 00:12:02,910
he would completely quiz he'll see a

00:12:00,750 --> 00:12:04,620
score and his team score would be

00:12:02,910 --> 00:12:08,550
updated so very simple thing that's

00:12:04,620 --> 00:12:11,430
that's kind of what would happen so

00:12:08,550 --> 00:12:13,110
initially all my testing was manual and

00:12:11,430 --> 00:12:15,750
it was done by the user interface so

00:12:13,110 --> 00:12:18,570
I've logons a site I'd click in I'd do

00:12:15,750 --> 00:12:20,730
this kind of stuff and it wasn't long

00:12:18,570 --> 00:12:23,000
before this was pretty painfully slow

00:12:20,730 --> 00:12:26,850
way of testing so I had to automate it

00:12:23,000 --> 00:12:28,529
and initially I would use tool like

00:12:26,850 --> 00:12:30,720
that's like selenium and I'd write these

00:12:28,529 --> 00:12:34,440
scripts and the scripts would kind of

00:12:30,720 --> 00:12:37,560
looked a bit like this maybe things like

00:12:34,440 --> 00:12:39,450
visit the home page find a lot in link

00:12:37,560 --> 00:12:41,910
click on the link find the element and

00:12:39,450 --> 00:12:44,250
so on and so on and so on and there's a

00:12:41,910 --> 00:12:47,220
number of problems with with tests like

00:12:44,250 --> 00:12:48,750
this and the first is not really even

00:12:47,220 --> 00:12:50,730
clear what this is doing there's been

00:12:48,750 --> 00:12:52,080
really long tests and it won't really be

00:12:50,730 --> 00:12:56,820
obvious from reading it what's actually

00:12:52,080 --> 00:12:59,490
going on and and the other thing is the

00:12:56,820 --> 00:13:01,020
tests are a really fragile so remember

00:12:59,490 --> 00:13:02,760
one change to any of these steps and

00:13:01,020 --> 00:13:07,050
potentially loads of our tests would

00:13:02,760 --> 00:13:08,310
fail so someone might come along and

00:13:07,050 --> 00:13:11,290
they say we've got this tiny little

00:13:08,310 --> 00:13:13,360
quest you know can we change the layout

00:13:11,290 --> 00:13:15,070
of the page that shows the list of

00:13:13,360 --> 00:13:18,970
quizzes now this is a perfectly

00:13:15,070 --> 00:13:20,769
reasonable request to be made and but

00:13:18,970 --> 00:13:23,350
the problem is if I go make that change

00:13:20,769 --> 00:13:24,970
and maybe I change the idea of an

00:13:23,350 --> 00:13:28,149
element somewhere on the form then

00:13:24,970 --> 00:13:30,130
suddenly all my passing tests go back to

00:13:28,149 --> 00:13:31,690
this they start all failing and this

00:13:30,130 --> 00:13:33,220
kind of comes back to the confession if

00:13:31,690 --> 00:13:34,329
you're kind of up against it you might

00:13:33,220 --> 00:13:36,009
look at it and go well I knew

00:13:34,329 --> 00:13:37,690
fundamentally I hadn't changed any of

00:13:36,009 --> 00:13:39,009
the functionality so for now I will

00:13:37,690 --> 00:13:41,589
leave all those failing to Esther I'll

00:13:39,009 --> 00:13:44,079
skip them or I'll ignore them and I will

00:13:41,589 --> 00:13:46,839
come back and fix them as we know we

00:13:44,079 --> 00:13:50,470
never well I never people don't come

00:13:46,839 --> 00:13:53,860
back and fix them and you can kind of

00:13:50,470 --> 00:14:00,089
see why I forgot fragile tests and it

00:13:53,860 --> 00:14:05,649
leads to essentially bad practices and

00:14:00,089 --> 00:14:08,380
why these things say so fragile arguably

00:14:05,649 --> 00:14:11,110
if we're testing by the user interface

00:14:08,380 --> 00:14:12,759
in terms of decoupling it could be seen

00:14:11,110 --> 00:14:16,480
as quite good because we've completely

00:14:12,759 --> 00:14:18,699
been coupled what we're testing from

00:14:16,480 --> 00:14:20,860
from the implementation detail we could

00:14:18,699 --> 00:14:22,000
take it the application we can rewrite

00:14:20,860 --> 00:14:24,519
it in a completely different language

00:14:22,000 --> 00:14:26,440
and as long as all those tests pass we

00:14:24,519 --> 00:14:29,230
know that we have the same behavior that

00:14:26,440 --> 00:14:32,350
the things we've tested however the

00:14:29,230 --> 00:14:36,040
problem with coupling our tests to the

00:14:32,350 --> 00:14:37,990
user interface is that generally a user

00:14:36,040 --> 00:14:40,089
interface is the least stable part of a

00:14:37,990 --> 00:14:41,769
software system and there will always be

00:14:40,089 --> 00:14:44,050
tiny other changes that were making

00:14:41,769 --> 00:14:45,360
which then will lead all our tests to

00:14:44,050 --> 00:14:47,800
fail

00:14:45,360 --> 00:14:50,290
so essentially what we've really done is

00:14:47,800 --> 00:14:52,240
we've coupled ourselves quite tightly to

00:14:50,290 --> 00:14:54,220
the user interface of our software under

00:14:52,240 --> 00:14:57,760
test which means our tests are pretty

00:14:54,220 --> 00:15:00,279
fragile and tiny little changes to our

00:14:57,760 --> 00:15:03,459
software test behind them cause lots of

00:15:00,279 --> 00:15:06,430
our tests to fail so I thought clearly

00:15:03,459 --> 00:15:08,860
I'm not doing the right thing and pretty

00:15:06,430 --> 00:15:10,149
much every problem in software has

00:15:08,860 --> 00:15:12,310
already been solved so I did some

00:15:10,149 --> 00:15:14,439
reading round and one way of solving

00:15:12,310 --> 00:15:17,110
this problem was something called a page

00:15:14,439 --> 00:15:19,480
object so page object sits between the

00:15:17,110 --> 00:15:23,230
tests and software under test

00:15:19,480 --> 00:15:25,810
and on one side we're kind of talking

00:15:23,230 --> 00:15:27,220
more in the language of what we're

00:15:25,810 --> 00:15:28,959
trying to achieve like we're trying to

00:15:27,220 --> 00:15:31,269
login we're trying to answer a question

00:15:28,959 --> 00:15:34,180
and that's the kind of conversation that

00:15:31,269 --> 00:15:37,180
the test has with the page object but

00:15:34,180 --> 00:15:39,699
the page object then talks more in the

00:15:37,180 --> 00:15:41,050
in the in the kind of conversation if

00:15:39,699 --> 00:15:43,660
I'm and we're picking on this link I'm

00:15:41,050 --> 00:15:46,329
trying to find this an element my name

00:15:43,660 --> 00:15:48,639
and I'm doing this quick so what you'd

00:15:46,329 --> 00:15:50,949
have here is the test would say I want

00:15:48,639 --> 00:15:52,690
to log in as this username and password

00:15:50,949 --> 00:15:55,630
and the page element would find the

00:15:52,690 --> 00:15:57,540
relevant elements on the find

00:15:55,630 --> 00:15:59,949
development bit of the form and it would

00:15:57,540 --> 00:16:09,579
put in the username and password and

00:15:59,949 --> 00:16:12,850
click Submit so a page object would kind

00:16:09,579 --> 00:16:15,490
of simulate the actions a human would do

00:16:12,850 --> 00:16:17,529
if interacting with this website so it

00:16:15,490 --> 00:16:19,510
can do things like a populated form like

00:16:17,529 --> 00:16:21,399
that login form it could pull data off

00:16:19,510 --> 00:16:24,310
the page and it can navigate to another

00:16:21,399 --> 00:16:26,050
page and a page might not a page object

00:16:24,310 --> 00:16:29,319
line on that one-to-one with like a page

00:16:26,050 --> 00:16:31,870
on the on the Internet only on the web

00:16:29,319 --> 00:16:35,980
application it might be a fragment of a

00:16:31,870 --> 00:16:40,449
page that you would view when you're

00:16:35,980 --> 00:16:42,490
looking at the page so we've kind of

00:16:40,449 --> 00:16:43,720
reduce the coupling between the tests

00:16:42,490 --> 00:16:45,819
and software in the test because we've

00:16:43,720 --> 00:16:48,100
got this intermediate object the page

00:16:45,819 --> 00:16:50,589
object in between between and it means

00:16:48,100 --> 00:16:53,230
if we make a tiny little tape change to

00:16:50,589 --> 00:16:57,160
our software under test we just need to

00:16:53,230 --> 00:16:58,660
update the page object with talks from

00:16:57,160 --> 00:17:03,180
the page objects and software the test

00:16:58,660 --> 00:17:03,180
and our test code remains the same so

00:17:03,689 --> 00:17:09,010
basically our page object is isolating

00:17:06,400 --> 00:17:12,630
changes and the user interface of the

00:17:09,010 --> 00:17:12,630
software under test

00:17:14,900 --> 00:17:19,559
and you can't if if there's only one

00:17:17,610 --> 00:17:20,610
test interacting with this then it

00:17:19,559 --> 00:17:21,929
probably wouldn't be worth it but in

00:17:20,610 --> 00:17:24,480
reality there's going to be lots of

00:17:21,929 --> 00:17:26,459
tests and doing the same kind of

00:17:24,480 --> 00:17:29,280
interaction so that's where the value

00:17:26,459 --> 00:17:30,900
comes in in a page object and now our

00:17:29,280 --> 00:17:33,059
tests kind of look a bit more like this

00:17:30,900 --> 00:17:35,460
we are going to the home page we're

00:17:33,059 --> 00:17:37,080
getting a login page from the login page

00:17:35,460 --> 00:17:38,429
we're going to try and log in then we're

00:17:37,080 --> 00:17:40,590
going to find the quiz we're interested

00:17:38,429 --> 00:17:42,299
in so again they give a load of answers

00:17:40,590 --> 00:17:46,440
they're willing to submit them and then

00:17:42,299 --> 00:17:47,910
we're going to check the score so this

00:17:46,440 --> 00:17:51,090
hopefully we can see is going to be less

00:17:47,910 --> 00:17:53,090
fat trial um but it's still not power

00:17:51,090 --> 00:17:55,890
really what we're testing here you know

00:17:53,090 --> 00:17:58,020
the test we're really asking is does an

00:17:55,890 --> 00:17:59,850
individual score get correctly allocated

00:17:58,020 --> 00:18:02,280
to their team that's what we're trying

00:17:59,850 --> 00:18:03,840
to do and even looking back about test

00:18:02,280 --> 00:18:05,429
it's not really obvious from reading

00:18:03,840 --> 00:18:08,370
through that is what we're trying to

00:18:05,429 --> 00:18:10,910
achieve or if it is you've gotta kind of

00:18:08,370 --> 00:18:13,320
spend a lot of time reading that test

00:18:10,910 --> 00:18:14,429
and also if someone wants it might want

00:18:13,320 --> 00:18:18,929
to come along and say we just got this

00:18:14,429 --> 00:18:21,270
tiny little request can we change the

00:18:18,929 --> 00:18:23,520
page a user gets to after log inning so

00:18:21,270 --> 00:18:25,140
originally they were shown say list of

00:18:23,520 --> 00:18:27,330
all the quizzes and now they're going to

00:18:25,140 --> 00:18:29,990
be taken somewhere different again a

00:18:27,330 --> 00:18:32,610
completely reasonable request to be made

00:18:29,990 --> 00:18:34,980
but if we look at our tests then all of

00:18:32,610 --> 00:18:37,169
a sudden after we log in we assume the

00:18:34,980 --> 00:18:39,270
game and my quizzes page but actually

00:18:37,169 --> 00:18:40,950
we're going somewhere else so we have

00:18:39,270 --> 00:18:42,330
the same problem again than we've made

00:18:40,950 --> 00:18:43,919
what it's essentially a tiny little

00:18:42,330 --> 00:18:45,650
change we've made no change for the

00:18:43,919 --> 00:18:52,980
business logic of the application and

00:18:45,650 --> 00:18:56,640
all our tests are failing so again we

00:18:52,980 --> 00:18:59,850
can kind of approach we can basically do

00:18:56,640 --> 00:19:02,040
the same thing again we can have now an

00:18:59,850 --> 00:19:03,960
extra layer between the tests and the

00:19:02,040 --> 00:19:07,760
page objects which could be like a

00:19:03,960 --> 00:19:11,130
domain-specific language layer and this

00:19:07,760 --> 00:19:12,540
kind of talks in the language it

00:19:11,130 --> 00:19:14,640
provides an interface to the tests which

00:19:12,540 --> 00:19:16,710
are more in the language of the business

00:19:14,640 --> 00:19:18,150
that we're trying to solve so we're

00:19:16,710 --> 00:19:20,580
talking more about things like I won't

00:19:18,150 --> 00:19:25,320
need to submit answers I want to get a

00:19:20,580 --> 00:19:27,150
team score and the DSL that layer knows

00:19:25,320 --> 00:19:28,020
if it need to submit answers in his

00:19:27,150 --> 00:19:30,990
scarf and talk

00:19:28,020 --> 00:19:33,330
this page object go to the answers page

00:19:30,990 --> 00:19:35,040
and then another page object to pull the

00:19:33,330 --> 00:19:39,560
answers back and then you can just

00:19:35,040 --> 00:19:42,960
return them all to the test so now our

00:19:39,560 --> 00:19:45,180
tests look a bit more like this we're

00:19:42,960 --> 00:19:49,740
signing a user to a team for a silent

00:19:45,180 --> 00:19:51,780
bob to team apple we're submitting Bob's

00:19:49,740 --> 00:19:53,640
user scores for quiz one and the same

00:19:51,780 --> 00:19:55,830
for engagement instead a from Drammen he

00:19:53,640 --> 00:19:58,380
said B these are multiple-choice things

00:19:55,830 --> 00:20:00,570
and then we're getting the score for

00:19:58,380 --> 00:20:03,630
Team Apple and then we can say we expect

00:20:00,570 --> 00:20:08,370
the score to be seven so this is a lot

00:20:03,630 --> 00:20:10,440
closer now to you know if this is what

00:20:08,370 --> 00:20:12,450
we want to test doesn't individual score

00:20:10,440 --> 00:20:13,860
get correctly allocated it's the team we

00:20:12,450 --> 00:20:17,160
can we can read the test and see that

00:20:13,860 --> 00:20:20,160
actually it really is testing that so

00:20:17,160 --> 00:20:24,780
not only our tests more clear to

00:20:20,160 --> 00:20:29,190
understand and they're also a lot less

00:20:24,780 --> 00:20:31,410
fragile than they were before and I've

00:20:29,190 --> 00:20:33,420
kind of highlighted the bits in green I

00:20:31,410 --> 00:20:35,910
don't have easy that is too short but a

00:20:33,420 --> 00:20:37,880
sign user to a team that is that's kind

00:20:35,910 --> 00:20:39,630
of lot closer to the business and

00:20:37,880 --> 00:20:42,360
discussion something that might be

00:20:39,630 --> 00:20:44,520
having a soon and submit answers submit

00:20:42,360 --> 00:20:46,110
users answers so that means a lot closer

00:20:44,520 --> 00:20:54,360
to whatever problem we're trying to

00:20:46,110 --> 00:20:56,430
solve so this essentially is what we've

00:20:54,360 --> 00:20:58,530
done and I've got two layers here it

00:20:56,430 --> 00:21:00,150
might not always be two layers but it's

00:20:58,530 --> 00:21:02,670
kind of what I'm saying is we need to

00:21:00,150 --> 00:21:04,680
kind of separate things out a bit and

00:21:02,670 --> 00:21:06,390
think about like all the good principles

00:21:04,680 --> 00:21:09,210
we would do if we're developing software

00:21:06,390 --> 00:21:10,500
but apply them into tests so if we're

00:21:09,210 --> 00:21:13,380
thinking about things like single

00:21:10,500 --> 00:21:15,810
responsibility principle and the page

00:21:13,380 --> 00:21:19,800
objects is their responsibility to

00:21:15,810 --> 00:21:21,570
interact with just sections of the

00:21:19,800 --> 00:21:23,820
software obsessed and they're there

00:21:21,570 --> 00:21:28,050
talking in the language of I mean it I'm

00:21:23,820 --> 00:21:29,910
clicking on this link I'm fine I'm gonna

00:21:28,050 --> 00:21:32,340
click on this link I'm inserting

00:21:29,910 --> 00:21:36,030
something into this this this form

00:21:32,340 --> 00:21:37,830
element whereas you then got a more

00:21:36,030 --> 00:21:40,630
abstract there the DSL there and that

00:21:37,830 --> 00:21:42,970
might be talking about things like I am

00:21:40,630 --> 00:21:45,100
submitting scores for user getting a

00:21:42,970 --> 00:21:47,530
team score and then your tests

00:21:45,100 --> 00:21:48,910
I've talked you more in the language of

00:21:47,530 --> 00:21:50,950
a business of whatever business

00:21:48,910 --> 00:21:53,530
requirements we are trying to solve and

00:21:50,950 --> 00:21:56,680
the important thing here is that their

00:21:53,530 --> 00:21:58,840
tests in this case should only change if

00:21:56,680 --> 00:22:01,960
a business requirement changes so that's

00:21:58,840 --> 00:22:03,970
the only time that our tester changed

00:22:01,960 --> 00:22:08,380
because we fundamentally changed some

00:22:03,970 --> 00:22:12,250
business logic now when I first start

00:22:08,380 --> 00:22:15,160
doing this stuff it was a long time ago

00:22:12,250 --> 00:22:17,230
and in reality now a lot of what we

00:22:15,160 --> 00:22:20,380
write doesn't really necessarily

00:22:17,230 --> 00:22:23,410
interface with like HTML elements on a

00:22:20,380 --> 00:22:26,590
fork on a page maybe we're talking more

00:22:23,410 --> 00:22:29,710
to like api's maybe we've got a system

00:22:26,590 --> 00:22:31,990
and it's kind of boundaries are this it

00:22:29,710 --> 00:22:33,190
gets information from a queue people put

00:22:31,990 --> 00:22:35,010
something on the queue and it pulls that

00:22:33,190 --> 00:22:37,960
information off and then it provides

00:22:35,010 --> 00:22:40,930
information to users via a web in space

00:22:37,960 --> 00:22:42,990
so actually we might not always be

00:22:40,930 --> 00:22:46,260
having page objects that are talking

00:22:42,990 --> 00:22:49,390
directly you know making HTTP requests

00:22:46,260 --> 00:22:51,580
maybe like the web thing here we're

00:22:49,390 --> 00:22:54,370
talking system in some other way so if

00:22:51,580 --> 00:22:56,050
you work out what the boundary is of

00:22:54,370 --> 00:22:57,610
your of your software under test and

00:22:56,050 --> 00:22:58,720
work out all the ways something can

00:22:57,610 --> 00:23:02,170
interact with it it might not

00:22:58,720 --> 00:23:09,610
necessarily these days always be over

00:23:02,170 --> 00:23:14,890
HTTP so what did we learn from from

00:23:09,610 --> 00:23:18,130
story one testing an application is

00:23:14,890 --> 00:23:20,620
business logic via the user interface is

00:23:18,130 --> 00:23:22,960
is quite difficult as time consuming and

00:23:20,620 --> 00:23:26,530
it requires a lot of effort I think

00:23:22,960 --> 00:23:28,120
that's probably fair to say and now if

00:23:26,530 --> 00:23:31,420
we introduce layers between the software

00:23:28,120 --> 00:23:33,430
under test then we're kind of in a way

00:23:31,420 --> 00:23:35,380
reducing our coupling between the test

00:23:33,430 --> 00:23:41,500
and the software that we're testing and

00:23:35,380 --> 00:23:43,810
we are isolating changes so if anything

00:23:41,500 --> 00:23:45,880
changes we just go to go and change one

00:23:43,810 --> 00:23:47,530
thing in the correct layer and then

00:23:45,880 --> 00:23:50,620
suddenly our tests will work

00:23:47,530 --> 00:23:52,720
and and the chain of the test do not

00:23:50,620 --> 00:23:54,880
change unless the functionality and

00:23:52,720 --> 00:23:57,940
there's the business requirements of the

00:23:54,880 --> 00:23:59,320
software under test to change and not

00:23:57,940 --> 00:24:00,940
really relevant to you but I don't

00:23:59,320 --> 00:24:02,740
really like in this kind of testing and

00:24:00,940 --> 00:24:08,940
I've largely moved away from it because

00:24:02,740 --> 00:24:11,710
it's a quite painful so this is a aim to

00:24:08,940 --> 00:24:13,240
reduce the coupling of our test Suites

00:24:11,710 --> 00:24:15,880
and hopefully you've seen that if we've

00:24:13,240 --> 00:24:17,980
done what I've just discussed and we can

00:24:15,880 --> 00:24:19,300
achieve that that goal and you might say

00:24:17,980 --> 00:24:21,520
well isn't that a lot of effort to

00:24:19,300 --> 00:24:23,170
create all of these extra layers between

00:24:21,520 --> 00:24:25,270
our software and our software under test

00:24:23,170 --> 00:24:27,160
but this essentially is going to be code

00:24:25,270 --> 00:24:30,190
that we'd have to write anyway and we're

00:24:27,160 --> 00:24:33,510
just doing it in a sensible place so I

00:24:30,190 --> 00:24:36,940
think you'll find on any non-trivial

00:24:33,510 --> 00:24:41,830
example it is probably quicker to write

00:24:36,940 --> 00:24:43,690
your code in this way that story one

00:24:41,830 --> 00:24:45,340
we've got two more stories today so he

00:24:43,690 --> 00:24:47,290
kind of needs some kind of cliffhanger

00:24:45,340 --> 00:24:50,980
to keep us all excited ready for story -

00:24:47,290 --> 00:24:52,780
well that happens if we replaced our

00:24:50,980 --> 00:24:56,500
entire website with something else like

00:24:52,780 --> 00:24:58,510
an app well what happens if we read rim

00:24:56,500 --> 00:25:02,080
it or what as ages ago we went from web

00:24:58,510 --> 00:25:04,030
ones web 2.0 well then we went from web

00:25:02,080 --> 00:25:05,470
to the Apple now we're a progressive web

00:25:04,030 --> 00:25:10,030
application all now we're going to go

00:25:05,470 --> 00:25:11,380
from that to some servicing suddenly all

00:25:10,030 --> 00:25:13,180
our tests would no longer be relevant

00:25:11,380 --> 00:25:16,690
because they are specific just that

00:25:13,180 --> 00:25:18,340
particular interface and we're going to

00:25:16,690 --> 00:25:20,230
find out how we can get round hoping

00:25:18,340 --> 00:25:22,390
potentially solve that problem and the

00:25:20,230 --> 00:25:24,100
other kind of thing it does feel like a

00:25:22,390 --> 00:25:29,200
lot of effort what we've done there just

00:25:24,100 --> 00:25:32,170
to test the business logic say story -

00:25:29,200 --> 00:25:36,100
and my tech my journey through testing

00:25:32,170 --> 00:25:38,800
continued and I was pretty sure that

00:25:36,100 --> 00:25:40,330
what we've done on that first story it

00:25:38,800 --> 00:25:41,590
was better than doing no automated

00:25:40,330 --> 00:25:43,900
testing it was a step in the right

00:25:41,590 --> 00:25:46,750
direction but I couldn't help feeling

00:25:43,900 --> 00:25:52,930
that it was a lot of effort and it must

00:25:46,750 --> 00:25:56,370
be a kind of a better way and so what

00:25:52,930 --> 00:25:56,370
what happened there was

00:25:58,620 --> 00:26:02,100
we'll just pretend I actually went on to

00:26:01,020 --> 00:26:04,850
work for a different project well we're

00:26:02,100 --> 00:26:07,740
going to pretend for this one and that

00:26:04,850 --> 00:26:09,510
we had to make some changes for

00:26:07,740 --> 00:26:12,299
application and then let's say you had

00:26:09,510 --> 00:26:14,010
to pay to start doing quizzes and you

00:26:12,299 --> 00:26:16,860
also received an email every time you

00:26:14,010 --> 00:26:20,779
completed the quiz so you get rid of the

00:26:16,860 --> 00:26:22,650
team's current running total so

00:26:20,779 --> 00:26:25,620
previously I kind of treated the

00:26:22,650 --> 00:26:28,289
software like a black box or in this

00:26:25,620 --> 00:26:29,520
diagram a big purple purple circle and I

00:26:28,289 --> 00:26:32,070
didn't know anything that was going on

00:26:29,520 --> 00:26:33,990
inside the only way of interface till it

00:26:32,070 --> 00:26:35,970
was was either by the user interface and

00:26:33,990 --> 00:26:37,140
in the case of this new functionality to

00:26:35,970 --> 00:26:42,210
have an email gateway in a payment

00:26:37,140 --> 00:26:44,159
gateway and if really my software was a

00:26:42,210 --> 00:26:46,710
big black box there is no other way of

00:26:44,159 --> 00:26:49,049
testing it other than the BIOS external

00:26:46,710 --> 00:26:50,610
interfaces but I kind of thought there

00:26:49,049 --> 00:26:52,020
must be a better way and I did some more

00:26:50,610 --> 00:26:53,669
reading around it and there's kind of

00:26:52,020 --> 00:26:56,159
two things layered architecture and

00:26:53,669 --> 00:26:57,840
exact neural architects you know I've

00:26:56,159 --> 00:27:00,360
got time to go into the details of this

00:26:57,840 --> 00:27:05,220
but we'll just pull out the principles

00:27:00,360 --> 00:27:06,690
that are most relevant here so if we

00:27:05,220 --> 00:27:09,690
could organize our code slightly

00:27:06,690 --> 00:27:12,240
differently and we might make testing a

00:27:09,690 --> 00:27:15,090
lot easier so in the center we've got

00:27:12,240 --> 00:27:16,799
the business logic and this is the code

00:27:15,090 --> 00:27:19,110
that's actually specific to whatever

00:27:16,799 --> 00:27:20,789
problem we're trying to solve and that's

00:27:19,110 --> 00:27:24,059
the kind of high value stuff that I'm

00:27:20,789 --> 00:27:25,350
really interested in testing I mean the

00:27:24,059 --> 00:27:26,970
other bits you do need to test but the

00:27:25,350 --> 00:27:29,909
business logic is what I'm really really

00:27:26,970 --> 00:27:32,309
interested in testing and and then

00:27:29,909 --> 00:27:34,799
around the business logic we've got this

00:27:32,309 --> 00:27:37,649
kind of green thing here which is the

00:27:34,799 --> 00:27:39,630
service layer which is an interface to

00:27:37,649 --> 00:27:41,070
the business logic and then we've got

00:27:39,630 --> 00:27:43,760
the framework which it all sits inside

00:27:41,070 --> 00:27:46,440
and then we've got the outside world and

00:27:43,760 --> 00:27:49,200
the deal is anything on the inner

00:27:46,440 --> 00:27:51,750
circles know nothing about the outer

00:27:49,200 --> 00:27:56,250
circles so the business logic has no

00:27:51,750 --> 00:27:59,510
idea that it is part of in this case a

00:27:56,250 --> 00:27:59,510
web application

00:28:00,149 --> 00:28:05,169
but the the outer layers can know about

00:28:02,799 --> 00:28:08,859
the inner layers so what would a service

00:28:05,169 --> 00:28:10,960
layer look like could be it's a service

00:28:08,859 --> 00:28:12,999
layer just a very thin layer to the

00:28:10,960 --> 00:28:15,129
business object and so we might have an

00:28:12,999 --> 00:28:17,859
answer submission service where you can

00:28:15,129 --> 00:28:20,259
use it to submit the users answers so

00:28:17,859 --> 00:28:23,109
you say here's the user this is the quiz

00:28:20,259 --> 00:28:26,559
ID and there's an array of balances so

00:28:23,109 --> 00:28:28,239
it's the job of the controller in this

00:28:26,559 --> 00:28:30,940
case to pull out the information from

00:28:28,239 --> 00:28:34,210
the request and then give that over to

00:28:30,940 --> 00:28:36,639
the service layer via a nice interface

00:28:34,210 --> 00:28:39,129
like this now the service layer is quite

00:28:36,639 --> 00:28:40,629
thin there and how the business logic

00:28:39,129 --> 00:28:42,489
actually goes around implements like

00:28:40,629 --> 00:28:44,950
that we don't know and we don't care

00:28:42,489 --> 00:28:47,289
maybe it's some cloud application maybe

00:28:44,950 --> 00:28:48,940
it sends off a load of events and

00:28:47,289 --> 00:28:51,849
commands it doesn't really matter

00:28:48,940 --> 00:28:58,479
that's all implementation detail that we

00:28:51,849 --> 00:29:01,539
don't really care about now testing is

00:28:58,479 --> 00:29:03,639
full of compromises and because if we

00:29:01,539 --> 00:29:05,710
kind of go down this approach now we are

00:29:03,639 --> 00:29:08,889
kind of coupling our tests to language

00:29:05,710 --> 00:29:13,419
which is chosen to like application in

00:29:08,889 --> 00:29:16,809
so that means we have a couple of

00:29:13,419 --> 00:29:19,210
ourselves to a programming language and

00:29:16,809 --> 00:29:22,779
we are coupling ourselves to this

00:29:19,210 --> 00:29:26,580
service layer however the service layer

00:29:22,779 --> 00:29:28,720
is still pretty abstract and it's better

00:29:26,580 --> 00:29:30,399
really than coupling ourselves to the

00:29:28,720 --> 00:29:35,590
user interface that for driving our

00:29:30,399 --> 00:29:37,479
tests so essentially on tests pavement

00:29:35,590 --> 00:29:44,889
we're now doing a lot of testing here at

00:29:37,479 --> 00:29:46,119
the integration level just wait but

00:29:44,889 --> 00:29:48,190
there's one kind of questioning rights

00:29:46,119 --> 00:29:50,349
to say if the inner layer there's

00:29:48,190 --> 00:29:51,820
nothing about the outer layer how on

00:29:50,349 --> 00:29:55,179
earth can the business logic do

00:29:51,820 --> 00:29:57,849
something like send an email or talk to

00:29:55,179 --> 00:30:00,070
their payment gateway so the business

00:29:57,849 --> 00:30:02,289
logic is aware of the interfaces to

00:30:00,070 --> 00:30:04,149
these things so we'll have an interface

00:30:02,289 --> 00:30:06,070
to the email gateway it knows about the

00:30:04,149 --> 00:30:09,190
interface to the yuan gateway or the

00:30:06,070 --> 00:30:10,890
interface to the payment gateway so the

00:30:09,190 --> 00:30:14,310
email gateway might look

00:30:10,890 --> 00:30:16,440
something like this and it's got a

00:30:14,310 --> 00:30:18,750
single method which is sending email

00:30:16,440 --> 00:30:21,570
who's it to visit from subject all that

00:30:18,750 --> 00:30:24,030
kind of stuff and what would happen is

00:30:21,570 --> 00:30:26,820
the real implementations would be

00:30:24,030 --> 00:30:30,300
injected in probably by the dependency

00:30:26,820 --> 00:30:33,780
injection bit of the framework and then

00:30:30,300 --> 00:30:36,120
you have adaptors and they actually know

00:30:33,780 --> 00:30:37,620
how to talk to the payment gateway or

00:30:36,120 --> 00:30:48,900
the email gateway or whatever external

00:30:37,620 --> 00:30:51,060
service it is so testing becomes a lot

00:30:48,900 --> 00:30:53,790
easier because what we can do now is we

00:30:51,060 --> 00:30:55,740
can replace all the external real

00:30:53,790 --> 00:30:57,720
implementations with things that we use

00:30:55,740 --> 00:31:01,620
for testing so for example we could have

00:30:57,720 --> 00:31:03,270
an email gateway spy and it's job it has

00:31:01,620 --> 00:31:04,710
the same interface female gateways so

00:31:03,270 --> 00:31:07,080
the business logic doesn't know if it's

00:31:04,710 --> 00:31:10,470
talking to a real email gateway or a

00:31:07,080 --> 00:31:13,760
test bubble so obviously our email

00:31:10,470 --> 00:31:15,900
gateway spy has to comply over the same

00:31:13,760 --> 00:31:17,460
interface it's got this method here to

00:31:15,900 --> 00:31:19,860
send the email but instead of actually

00:31:17,460 --> 00:31:21,750
sending email let's just say it stores

00:31:19,860 --> 00:31:26,640
all that information in an array and

00:31:21,750 --> 00:31:27,960
then we provide an extra method which is

00:31:26,640 --> 00:31:29,820
a way of retrieving all the emails that

00:31:27,960 --> 00:31:32,250
would have been sent during the test and

00:31:29,820 --> 00:31:39,240
then that can be used by our test script

00:31:32,250 --> 00:31:41,280
later so testing kind of becomes a lot

00:31:39,240 --> 00:31:42,870
easier because we've got our test we

00:31:41,280 --> 00:31:44,910
might have a layer in between that and

00:31:42,870 --> 00:31:47,820
the service layer but actually probably

00:31:44,910 --> 00:31:49,410
the language of the test and the

00:31:47,820 --> 00:31:51,390
language of the service layer are pretty

00:31:49,410 --> 00:31:54,510
similar so in our test we might say I

00:31:51,390 --> 00:31:56,580
want to submit users answers and the DSL

00:31:54,510 --> 00:31:58,290
might be saying I want to call the

00:31:56,580 --> 00:32:00,030
submit the users answers there might

00:31:58,290 --> 00:32:02,220
even be no they need to have that layer

00:32:00,030 --> 00:32:08,850
in between when we're operating at this

00:32:02,220 --> 00:32:11,400
level so the service layer will be

00:32:08,850 --> 00:32:14,460
generally far more stable than when

00:32:11,400 --> 00:32:17,940
we're testing by the user interface so

00:32:14,460 --> 00:32:19,980
we've got our application looks a bit

00:32:17,940 --> 00:32:21,240
like this the outside world's talking to

00:32:19,980 --> 00:32:23,660
it by a controller we've got the

00:32:21,240 --> 00:32:25,950
business logic and it's got the various

00:32:23,660 --> 00:32:26,850
payment gateway an email gateway to talk

00:32:25,950 --> 00:32:29,520
to the outside world

00:32:26,850 --> 00:32:33,090
and when we're testing we can replace

00:32:29,520 --> 00:32:35,580
the outside world with test bubbles and

00:32:33,090 --> 00:32:37,380
our test entry point goes and talk

00:32:35,580 --> 00:32:40,500
straight to the business logic by the

00:32:37,380 --> 00:32:42,450
service layer and if we compare how much

00:32:40,500 --> 00:32:44,760
easier that is than what we had

00:32:42,450 --> 00:32:46,410
previously when our test entry point was

00:32:44,760 --> 00:32:48,900
kind of having to talk to controller

00:32:46,410 --> 00:32:52,020
then I mean that would be really

00:32:48,900 --> 00:32:56,309
difficult to work with you'd have to do

00:32:52,020 --> 00:32:57,690
things like work out what form you're

00:32:56,309 --> 00:32:59,280
clicking on and where you're putting

00:32:57,690 --> 00:33:00,510
that information where it's now if

00:32:59,280 --> 00:33:03,150
you're talking directly to the business

00:33:00,510 --> 00:33:04,440
logic it's much easier and we didn't

00:33:03,150 --> 00:33:05,970
even address how we're going to check

00:33:04,440 --> 00:33:08,130
the emails are sent or how we're going

00:33:05,970 --> 00:33:11,790
to check payments are made when we're

00:33:08,130 --> 00:33:13,650
using the real and implementations so

00:33:11,790 --> 00:33:15,480
this is all great but it does mean you

00:33:13,650 --> 00:33:18,420
have to architect your code in this way

00:33:15,480 --> 00:33:20,309
from the start and that's fine on

00:33:18,420 --> 00:33:24,330
greenfield projects now we all know how

00:33:20,309 --> 00:33:26,309
to do this and but if our project kind

00:33:24,330 --> 00:33:28,740
of looks like this and it's all just one

00:33:26,309 --> 00:33:32,100
big blob of software what realistically

00:33:28,740 --> 00:33:34,170
can we do and and the answer is is quite

00:33:32,100 --> 00:33:37,050
a slow painful process this is no silver

00:33:34,170 --> 00:33:38,760
bullet here really but if I was

00:33:37,050 --> 00:33:40,230
presented with software like this and

00:33:38,760 --> 00:33:41,250
the first thing I would try and do say

00:33:40,230 --> 00:33:43,320
well I'm going to take one of the

00:33:41,250 --> 00:33:45,750
external things we're talking to say the

00:33:43,320 --> 00:33:49,530
email gateway I say the payment gateway

00:33:45,750 --> 00:33:51,120
I'm gonna create an adapter that talks

00:33:49,530 --> 00:33:53,150
that and provide a simple interface to

00:33:51,120 --> 00:33:56,070
it and then pull out all the code and

00:33:53,150 --> 00:33:58,020
that talks to the payment gateway put it

00:33:56,070 --> 00:34:00,150
in the adapter provide an interface and

00:33:58,020 --> 00:34:01,559
then make sure all of the code that was

00:34:00,150 --> 00:34:05,610
literally talking to the payment gateway

00:34:01,559 --> 00:34:08,060
is now doing it by this adapter I do the

00:34:05,610 --> 00:34:10,919
same for any other external services and

00:34:08,060 --> 00:34:12,300
and then the other side is like I've got

00:34:10,919 --> 00:34:13,770
the controller I need to make sure that

00:34:12,300 --> 00:34:16,010
our controllers have no business logic

00:34:13,770 --> 00:34:20,580
in so I'd be pushing the business logic

00:34:16,010 --> 00:34:22,260
into the center so then I've got all the

00:34:20,580 --> 00:34:24,179
business logic pushing into the blue the

00:34:22,260 --> 00:34:26,399
blue circle in the middle and then

00:34:24,179 --> 00:34:29,669
finally I would go around say but let's

00:34:26,399 --> 00:34:31,950
create a service there for this and then

00:34:29,669 --> 00:34:35,060
we're where we need to be so we can do

00:34:31,950 --> 00:34:35,060
our testing

00:34:36,990 --> 00:34:44,710
so if we do most of our testing by the

00:34:42,879 --> 00:34:48,099
integration level do we still need to

00:34:44,710 --> 00:34:50,169
test by the user interface and we do

00:34:48,099 --> 00:34:52,750
because we need to the question we're

00:34:50,169 --> 00:34:55,809
then asking is not does our code work

00:34:52,750 --> 00:34:58,660
we're saying have we correctly wired our

00:34:55,809 --> 00:35:02,170
user interface to our business logic so

00:34:58,660 --> 00:35:05,970
that test space is much smaller which is

00:35:02,170 --> 00:35:08,769
good so if we look at all of the tests

00:35:05,970 --> 00:35:10,690
we're running at the user interface

00:35:08,769 --> 00:35:12,369
level what we could do is you could like

00:35:10,690 --> 00:35:14,980
pick a few and go what actually that

00:35:12,369 --> 00:35:17,349
kind of covers these couple here they

00:35:14,980 --> 00:35:22,420
cover most of the interactions between

00:35:17,349 --> 00:35:24,339
the use of the interface and the and the

00:35:22,420 --> 00:35:25,750
service layer so exists that well it's

00:35:24,339 --> 00:35:28,539
going to pick those two outs and kind of

00:35:25,750 --> 00:35:33,400
rewrite them and so you interact with

00:35:28,539 --> 00:35:35,140
the tool via the user interface and then

00:35:33,400 --> 00:35:36,700
you've kind of got a take a view as to

00:35:35,140 --> 00:35:38,799
whether that's worth automating because

00:35:36,700 --> 00:35:42,339
because we've reduced our test basis so

00:35:38,799 --> 00:35:43,630
much maybe we don't necessarily have to

00:35:42,339 --> 00:35:45,819
automate it you've got to go to think

00:35:43,630 --> 00:35:47,650
what is the effort required to automate

00:35:45,819 --> 00:35:49,240
these tests is it just cheaper to pay

00:35:47,650 --> 00:35:50,710
someone to do it manually and that

00:35:49,240 --> 00:35:52,240
depends on lots of things you know how

00:35:50,710 --> 00:35:54,009
difficult will it be to write automated

00:35:52,240 --> 00:35:56,200
tests that are testing by the user

00:35:54,009 --> 00:35:59,500
interface how often does user interface

00:35:56,200 --> 00:36:01,809
change and that's a question I can't say

00:35:59,500 --> 00:36:05,410
it's just you know a project basis I

00:36:01,809 --> 00:36:07,569
definitely automate all the testing but

00:36:05,410 --> 00:36:09,460
an integration level but whether we

00:36:07,569 --> 00:36:10,809
enter and whether we automate some of

00:36:09,460 --> 00:36:17,519
the other stuff is kind of you just

00:36:10,809 --> 00:36:22,140
going to take a business call on that so

00:36:17,519 --> 00:36:24,880
the moral of our our second story is

00:36:22,140 --> 00:36:29,369
testing the application logic at the

00:36:24,880 --> 00:36:32,769
integration level is far easier and

00:36:29,369 --> 00:36:34,420
because we are introducing coupling

00:36:32,769 --> 00:36:36,960
between our software under test and the

00:36:34,420 --> 00:36:41,319
service layer but this is still

00:36:36,960 --> 00:36:42,860
relatively abstract and so I think it's

00:36:41,319 --> 00:36:45,140
a much better place to do that

00:36:42,860 --> 00:36:49,340
thing but we still do need to do some

00:36:45,140 --> 00:36:50,900
testing at the user interface level but

00:36:49,340 --> 00:36:53,750
if we are going to do this we do need to

00:36:50,900 --> 00:36:56,420
architect and our code in a way that

00:36:53,750 --> 00:36:57,740
makes this testing easier but you'll

00:36:56,420 --> 00:36:59,090
probably find if your architectural

00:36:57,740 --> 00:37:01,880
coding that way there'll be many other

00:36:59,090 --> 00:37:03,860
benefits as well like for example if we

00:37:01,880 --> 00:37:05,720
change that email gateway we can just go

00:37:03,860 --> 00:37:08,090
code up the new real email gateway

00:37:05,720 --> 00:37:13,910
adapter and everything else just remains

00:37:08,090 --> 00:37:15,320
the same and again not really relevant

00:37:13,910 --> 00:37:19,430
to you but I quite like doing this kind

00:37:15,320 --> 00:37:21,200
of testing so there we go so remember

00:37:19,430 --> 00:37:23,540
our cliffhangers from from Story one

00:37:21,200 --> 00:37:25,880
what would happen if we replaced our

00:37:23,540 --> 00:37:28,250
entire website with an application with

00:37:25,880 --> 00:37:29,780
an app what in this case we've done all

00:37:28,250 --> 00:37:32,780
our testing like this with a business

00:37:29,780 --> 00:37:34,610
logic it wouldn't really matter sure we

00:37:32,780 --> 00:37:36,710
have to throw away the tests that were

00:37:34,610 --> 00:37:39,260
testing our application by the user

00:37:36,710 --> 00:37:40,790
interface but they're there they're not

00:37:39,260 --> 00:37:42,500
there to test the business logic they're

00:37:40,790 --> 00:37:46,070
there to test that the user interface

00:37:42,500 --> 00:37:47,330
it's correctly wired up and if we come

00:37:46,070 --> 00:37:49,340
along with that

00:37:47,330 --> 00:37:51,170
then we don't need to write a load of

00:37:49,340 --> 00:37:52,790
tests for the app but then test the

00:37:51,170 --> 00:37:54,500
business object we just need to write

00:37:52,790 --> 00:37:58,520
tests make sure the app is correctly

00:37:54,500 --> 00:38:00,260
connected to our business logic because

00:37:58,520 --> 00:38:04,340
it's completely new in space we'd have

00:38:00,260 --> 00:38:08,090
to write those tests anyway and remember

00:38:04,340 --> 00:38:09,770
we thought what I thought and the way of

00:38:08,090 --> 00:38:12,470
testing via the user interface was a lot

00:38:09,770 --> 00:38:15,910
of efforts if we do it this way it's

00:38:12,470 --> 00:38:18,500
that it's definitely a lot less effort

00:38:15,910 --> 00:38:20,150
so hopefully we can see we've kind of

00:38:18,500 --> 00:38:22,220
decoupled our tests a bit more and we

00:38:20,150 --> 00:38:25,990
are reducing their the cost and of the

00:38:22,220 --> 00:38:25,990
and the maintenance of other test Suites

00:38:27,760 --> 00:38:32,060
however I still have this nagging

00:38:30,470 --> 00:38:34,070
feeling that parts of my test suite was

00:38:32,060 --> 00:38:35,840
still more tightly coupled to the

00:38:34,070 --> 00:38:41,320
software that I'm testing and that's

00:38:35,840 --> 00:38:41,320
what we explore in in Story 3

00:38:42,880 --> 00:38:47,660
so I'm far happier with how we're doing

00:38:45,710 --> 00:38:50,869
things I think we've got quite good test

00:38:47,660 --> 00:38:52,880
suite and but there were still areas

00:38:50,869 --> 00:38:55,580
where I think maybe what I'm doing is I

00:38:52,880 --> 00:38:59,330
am too tightly coupling my test code to

00:38:55,580 --> 00:39:01,190
the software under test so let's imagine

00:38:59,330 --> 00:39:03,980
that our software is doing really well

00:39:01,190 --> 00:39:06,470
and we're going to release it to more

00:39:03,980 --> 00:39:09,920
companies and each company basically has

00:39:06,470 --> 00:39:12,619
their own branded subdomain which they

00:39:09,920 --> 00:39:14,839
can go into and and when they log in and

00:39:12,619 --> 00:39:18,109
you can only log in from your company's

00:39:14,839 --> 00:39:19,450
subdomain so basically raised before we

00:39:18,109 --> 00:39:21,470
had to provide a username and password

00:39:19,450 --> 00:39:23,150
now we're kind of doing username

00:39:21,470 --> 00:39:26,359
password and subdomain only if all those

00:39:23,150 --> 00:39:29,210
three work then you're successfully

00:39:26,359 --> 00:39:31,640
authenticated so I made the changes the

00:39:29,210 --> 00:39:33,320
codes I mean again I'm taking a story

00:39:31,640 --> 00:39:36,500
from another project I did and making it

00:39:33,320 --> 00:39:38,119
this is this project I'm talking about

00:39:36,500 --> 00:39:39,619
just through dad to introduce a new

00:39:38,119 --> 00:39:41,839
project but this is a kind of a real

00:39:39,619 --> 00:39:45,040
thing that that did happen and I know

00:39:41,839 --> 00:39:48,349
and related tests and all of a sudden

00:39:45,040 --> 00:39:51,380
loads of tests failed again and I kinda

00:39:48,349 --> 00:39:55,280
was looking is why on earth does a test

00:39:51,380 --> 00:39:57,320
and that's doing this does an individual

00:39:55,280 --> 00:40:00,109
score get correctly allocated to their

00:39:57,320 --> 00:40:02,390
team why should that suddenly fail when

00:40:00,109 --> 00:40:04,339
we've changed how we authenticate users

00:40:02,390 --> 00:40:06,200
I mean it shouldn't this this this is

00:40:04,339 --> 00:40:09,859
talking nothing about authenticating

00:40:06,200 --> 00:40:10,940
users and this is coded being stable for

00:40:09,859 --> 00:40:13,790
months there's no reason for it to

00:40:10,940 --> 00:40:16,430
suddenly fail as far as I could see and

00:40:13,790 --> 00:40:19,310
it was all to do with really how I was

00:40:16,430 --> 00:40:21,619
seeding the data so integration level

00:40:19,310 --> 00:40:24,349
often you are at the start of test

00:40:21,619 --> 00:40:28,190
putting data insert into database or

00:40:24,349 --> 00:40:31,609
data repository and to get something in

00:40:28,190 --> 00:40:34,339
to enter state ready to do your your run

00:40:31,609 --> 00:40:37,040
your tests and the way I was doing this

00:40:34,339 --> 00:40:39,589
how I was seeding a database wasn't

00:40:37,040 --> 00:40:41,540
particularly sensible so I was using a

00:40:39,589 --> 00:40:43,849
tool and it would look for a Yama file

00:40:41,540 --> 00:40:45,950
and it would it would look at live it

00:40:43,849 --> 00:40:48,410
out of there I'm populating the users

00:40:45,950 --> 00:40:49,910
table and then it would create some SQL

00:40:48,410 --> 00:40:51,780
insert statements based on this

00:40:49,910 --> 00:40:55,950
information so it's an insert

00:40:51,780 --> 00:40:58,680
they allow a lot calm and so on and and

00:40:55,950 --> 00:41:05,280
it would generate all the SQL and inject

00:40:58,680 --> 00:41:06,870
it directly into the database and this

00:41:05,280 --> 00:41:09,630
is not a great way of doing things

00:41:06,870 --> 00:41:13,500
because what happens if something

00:41:09,630 --> 00:41:17,040
changes like those narrow requirements

00:41:13,500 --> 00:41:19,140
that each user belonged to a company the

00:41:17,040 --> 00:41:21,570
company ID had a not null constraint

00:41:19,140 --> 00:41:23,790
because every years I had to belong to a

00:41:21,570 --> 00:41:27,480
company and then I had to go through all

00:41:23,790 --> 00:41:29,730
of these or all of these and just add in

00:41:27,480 --> 00:41:34,590
the extra things say which company they

00:41:29,730 --> 00:41:37,350
belong to and that's why suddenly we had

00:41:34,590 --> 00:41:39,380
loads of tests working two loads of

00:41:37,350 --> 00:41:41,430
tests failing even though the business

00:41:39,380 --> 00:41:45,480
requirement with the testing remained

00:41:41,430 --> 00:41:47,910
unchanged so if we do things like this

00:41:45,480 --> 00:41:50,270
and we put data directly into a database

00:41:47,910 --> 00:41:53,130
this isn't great we're coupling

00:41:50,270 --> 00:41:55,470
implementation detail like integration

00:41:53,130 --> 00:41:57,980
level we shouldn't really care how our

00:41:55,470 --> 00:42:00,390
data is being stored

00:41:57,980 --> 00:42:01,890
so we're coupling we're having

00:42:00,390 --> 00:42:04,590
unnecessary coupling between our

00:42:01,890 --> 00:42:09,270
software and the tests and the software

00:42:04,590 --> 00:42:11,070
under test and also at test level we

00:42:09,270 --> 00:42:13,320
might not really be using real database

00:42:11,070 --> 00:42:14,850
anyway so the database I think belongs

00:42:13,320 --> 00:42:17,100
outside of the business logic

00:42:14,850 --> 00:42:19,560
it's just implementation detail it's

00:42:17,100 --> 00:42:23,820
just something else like an email

00:42:19,560 --> 00:42:26,430
gateway and sometimes in testing for

00:42:23,820 --> 00:42:30,390
Speed purposes I might not use a real

00:42:26,430 --> 00:42:33,600
database I might use a fake database and

00:42:30,390 --> 00:42:35,640
if our tests are putting data directly

00:42:33,600 --> 00:42:38,100
into a real database what it means I

00:42:35,640 --> 00:42:41,090
can't replace the real database with a

00:42:38,100 --> 00:42:41,090
fake implementation

00:42:43,290 --> 00:42:47,020
so there are a few methods working we

00:42:45,819 --> 00:42:49,599
can get around this how are we going to

00:42:47,020 --> 00:42:51,369
build our fixtures and so we've kind of

00:42:49,599 --> 00:42:54,420
looked at what is wrong with seeding

00:42:51,369 --> 00:42:58,329
directly from the file into the database

00:42:54,420 --> 00:43:00,400
so we could hand build the objects or we

00:42:58,329 --> 00:43:01,839
can use some kind of builder pattern or

00:43:00,400 --> 00:43:06,760
factory pattern like the object mother

00:43:01,839 --> 00:43:08,800
or the test builder so I could say every

00:43:06,760 --> 00:43:12,010
time I need the Protectorate particular

00:43:08,800 --> 00:43:14,650
object I'll just go and create it by

00:43:12,010 --> 00:43:16,450
hand and this is fine if I only ever do

00:43:14,650 --> 00:43:18,250
this once but in reality there's going

00:43:16,450 --> 00:43:21,400
to be loads of times in my tests but I

00:43:18,250 --> 00:43:22,720
need to register a new user so this

00:43:21,400 --> 00:43:28,119
definitely breaks they don't repeat

00:43:22,720 --> 00:43:30,310
yourself and principle and obviously

00:43:28,119 --> 00:43:32,079
every time we make new requirements for

00:43:30,310 --> 00:43:33,040
something like now a user belongs to a

00:43:32,079 --> 00:43:35,290
company I'd have to go through the

00:43:33,040 --> 00:43:38,470
entire test suite and basically make

00:43:35,290 --> 00:43:40,079
that one-line change so we don't really

00:43:38,470 --> 00:43:42,130
want to be hand building anything and

00:43:40,079 --> 00:43:45,460
certainly if we're going to make it more

00:43:42,130 --> 00:43:48,190
than once so another thing we could do

00:43:45,460 --> 00:43:50,680
is use this passing called the object

00:43:48,190 --> 00:43:54,220
mother and it's just a factory it's just

00:43:50,680 --> 00:43:58,599
a way of building an object in a known

00:43:54,220 --> 00:44:00,609
state ready for testing so we could have

00:43:58,599 --> 00:44:02,650
a user object mother and and that was

00:44:00,609 --> 00:44:06,210
the responsibility of these object

00:44:02,650 --> 00:44:10,900
mother is just to build users test users

00:44:06,210 --> 00:44:12,609
and if you use and I use the stories and

00:44:10,900 --> 00:44:15,130
you have personas then what you could

00:44:12,609 --> 00:44:17,740
actually do is let's say and I use the

00:44:15,130 --> 00:44:19,240
state stories Anna has a persona and

00:44:17,740 --> 00:44:21,579
that means something maybe Anna is the

00:44:19,240 --> 00:44:23,890
administrator and Bob's a normal user

00:44:21,579 --> 00:44:27,609
and so on and so forth so we can

00:44:23,890 --> 00:44:29,890
actually just say user object get Anna

00:44:27,609 --> 00:44:31,780
and it will create a user it has all the

00:44:29,890 --> 00:44:35,589
properties of Anna and then everyone

00:44:31,780 --> 00:44:37,900
knows what that means so our function

00:44:35,589 --> 00:44:40,450
essentially just wraps the code that we

00:44:37,900 --> 00:44:42,280
that we already had it checks if the

00:44:40,450 --> 00:44:44,920
user already exists it just returns it

00:44:42,280 --> 00:44:47,700
otherwise otherwise it builds a new user

00:44:44,920 --> 00:44:50,079
using powerful we we create users and

00:44:47,700 --> 00:44:52,900
the good thing about this is if we do

00:44:50,079 --> 00:44:55,900
need to make a change like we have to

00:44:52,900 --> 00:44:57,430
now that the users company we just

00:44:55,900 --> 00:45:02,410
there's one place where we need to make

00:44:57,430 --> 00:45:04,119
that change and another way of building

00:45:02,410 --> 00:45:06,339
things is have used the Builder pattern

00:45:04,119 --> 00:45:08,890
so we can either use a builder and if

00:45:06,339 --> 00:45:11,799
you call build it just builds a use of a

00:45:08,890 --> 00:45:13,150
whole set of default values but the

00:45:11,799 --> 00:45:14,920
other thing you can do in a user and

00:45:13,150 --> 00:45:17,319
build the pattern is you can override

00:45:14,920 --> 00:45:19,269
anything you want to say build me user

00:45:17,319 --> 00:45:21,460
but instead of calling it Anna call out

00:45:19,269 --> 00:45:27,279
Annabelle give her a different password

00:45:21,460 --> 00:45:28,749
put it in a different theme and if we

00:45:27,279 --> 00:45:30,309
start going down these patterns then

00:45:28,749 --> 00:45:33,789
actually what we probably find this

00:45:30,309 --> 00:45:37,329
we've got relatively complex you know

00:45:33,789 --> 00:45:39,249
object Maps or object graphs even and so

00:45:37,329 --> 00:45:42,759
you might find that one object mother

00:45:39,249 --> 00:45:44,859
defers to another so in this case for

00:45:42,759 --> 00:45:48,039
the user object mother when we've added

00:45:44,859 --> 00:45:51,849
this requirements that and used in our

00:45:48,039 --> 00:45:54,400
belongs to a company we might say in the

00:45:51,849 --> 00:45:56,079
in the method that creates a user we

00:45:54,400 --> 00:45:58,239
might say oh I'm going to delegate off

00:45:56,079 --> 00:45:59,739
to a company object mother to go and

00:45:58,239 --> 00:46:02,950
create the company that that user

00:45:59,739 --> 00:46:04,630
belongs to and then the company object

00:46:02,950 --> 00:46:07,420
other code will look just like the same

00:46:04,630 --> 00:46:07,869
so I'll say have we already created Acme

00:46:07,420 --> 00:46:09,640
company

00:46:07,869 --> 00:46:11,829
no we haven't I'll going create it

00:46:09,640 --> 00:46:15,940
otherwise I'll just return that company

00:46:11,829 --> 00:46:17,739
that's already created so then you kind

00:46:15,940 --> 00:46:19,329
of could come back to if you do want to

00:46:17,739 --> 00:46:21,400
populating through like Yammer files

00:46:19,329 --> 00:46:23,259
then you can and kind of have some

00:46:21,400 --> 00:46:24,970
hybrid approach so you could read

00:46:23,259 --> 00:46:26,529
through the ELMO files and instead of

00:46:24,970 --> 00:46:30,369
putting it directly into the database

00:46:26,529 --> 00:46:32,759
you could then build the objects via one

00:46:30,369 --> 00:46:34,539
of the data builder or object other type

00:46:32,759 --> 00:46:37,779
ways of doing things

00:46:34,539 --> 00:46:41,170
and then we've kind of decoupled how we

00:46:37,779 --> 00:46:43,359
create users so you just say I want to

00:46:41,170 --> 00:46:44,799
create a user and then we've got some

00:46:43,359 --> 00:46:46,989
code somewhere that knows how to create

00:46:44,799 --> 00:46:48,999
a user and if we change anything about

00:46:46,989 --> 00:46:51,489
how we create a user then none of the

00:46:48,999 --> 00:46:53,799
tests need to care about that they just

00:46:51,489 --> 00:46:55,660
say like I want any user and the code

00:46:53,799 --> 00:46:58,329
just goes and builds and you use that in

00:46:55,660 --> 00:47:01,630
a valid State so hopefully you can kind

00:46:58,329 --> 00:47:04,579
of see the benefit of of that

00:47:01,630 --> 00:47:06,410
said long story three was it was used

00:47:04,579 --> 00:47:08,479
patterns like object mother or test

00:47:06,410 --> 00:47:10,519
builders or essentially just have a

00:47:08,479 --> 00:47:13,519
single place where you build some of

00:47:10,519 --> 00:47:15,849
these complex objects for for your tests

00:47:13,519 --> 00:47:18,380
that's that's the key thing

00:47:15,849 --> 00:47:20,719
it makes our tests more robust to change

00:47:18,380 --> 00:47:23,689
and and also allows us to do things like

00:47:20,719 --> 00:47:27,979
you know use faking memory databases

00:47:23,689 --> 00:47:30,910
rather than real ones so often I use the

00:47:27,979 --> 00:47:34,729
repository pattern for persisting data

00:47:30,910 --> 00:47:36,439
so if I have one tests and sometimes the

00:47:34,729 --> 00:47:38,749
test might take half second or a second

00:47:36,439 --> 00:47:42,170
to run when using real database but if I

00:47:38,749 --> 00:47:44,390
provided like a test bubble a fake

00:47:42,170 --> 00:47:47,299
implementation of that repository which

00:47:44,390 --> 00:47:49,430
just stores everything in in memory in

00:47:47,299 --> 00:47:52,009
arrays then you know you could do

00:47:49,430 --> 00:47:59,180
hundreds of tests in about half a second

00:47:52,009 --> 00:48:01,309
or a second yeah so we're basically

00:47:59,180 --> 00:48:04,999
doing more to do a blood test for us for

00:48:01,309 --> 00:48:06,499
myself on the test so this essentially

00:48:04,999 --> 00:48:08,089
is why we're here here and we've kind of

00:48:06,499 --> 00:48:11,029
had three stories and I hopefully you've

00:48:08,089 --> 00:48:13,579
seen how what we've done is we reduce

00:48:11,029 --> 00:48:16,339
the coupling between our tests and

00:48:13,579 --> 00:48:18,829
software of the tests and I hope you've

00:48:16,339 --> 00:48:20,839
all seen the benefits of that so it's

00:48:18,829 --> 00:48:25,249
all about decoupling in some way

00:48:20,839 --> 00:48:29,059
we're just decoupling here and if we are

00:48:25,249 --> 00:48:30,799
going to test by these interface lens

00:48:29,059 --> 00:48:34,130
have layers in between so we can isolate

00:48:30,799 --> 00:48:36,109
changes ideally they we probably want to

00:48:34,130 --> 00:48:38,929
do most of our testing the business

00:48:36,109 --> 00:48:42,709
logic at the integration level and or

00:48:38,929 --> 00:48:44,719
even below and when we're doing that we

00:48:42,709 --> 00:48:46,910
need to make sure we design our code in

00:48:44,719 --> 00:48:48,769
such a way that it's really easy to

00:48:46,910 --> 00:48:52,999
replace real implementations of external

00:48:48,769 --> 00:48:53,749
services with test doubles when we're

00:48:52,999 --> 00:48:55,959
building data

00:48:53,749 --> 00:48:58,699
don't put it directly into the database

00:48:55,959 --> 00:49:00,380
put it in by some kind of build method

00:48:58,699 --> 00:49:02,839
or have some building pattern or

00:49:00,380 --> 00:49:05,299
something like that which the couples

00:49:02,839 --> 00:49:08,479
and things like the implementation

00:49:05,299 --> 00:49:09,349
detail like database schema from our

00:49:08,479 --> 00:49:12,859
tests

00:49:09,349 --> 00:49:16,309
I remember really do the white level of

00:49:12,859 --> 00:49:18,319
testing at the right area of the right

00:49:16,309 --> 00:49:19,880
part of the the test pyramid we've not

00:49:18,319 --> 00:49:21,859
really discussed anything at unit test

00:49:19,880 --> 00:49:25,400
level today that's kind of a whole talk

00:49:21,859 --> 00:49:27,589
right so and obviously we want to do

00:49:25,400 --> 00:49:30,109
most the testing we can further down the

00:49:27,589 --> 00:49:36,349
pyramid but you do have to do these

00:49:30,109 --> 00:49:38,599
higher level tests so that's our summary

00:49:36,349 --> 00:49:40,039
essentially the coupling is good just

00:49:38,599 --> 00:49:43,699
like it is when we're writing real code

00:49:40,039 --> 00:49:45,279
is equally applicable to testing because

00:49:43,699 --> 00:49:47,539
it's basically reducing our the

00:49:45,279 --> 00:49:50,509
development and maintenance costs of the

00:49:47,539 --> 00:49:53,239
test suite remember two things at the

00:49:50,509 --> 00:50:00,319
right level and yeah it's all about

00:49:53,239 --> 00:50:02,299
architecting code correctly so that's

00:50:00,319 --> 00:50:06,619
basically a summary of what we've

00:50:02,299 --> 00:50:08,660
discussed so thanks for making it to the

00:50:06,619 --> 00:50:10,749
hangover slots and David thank you for

00:50:08,660 --> 00:50:10,749
listening

00:50:15,180 --> 00:50:34,900
any questions yes so if I'm using a

00:50:28,390 --> 00:50:36,580
memory one and if if I consider that all

00:50:34,900 --> 00:50:38,440
my interaction so commonly I'll use the

00:50:36,580 --> 00:50:41,940
repository pattern so the repository

00:50:38,440 --> 00:50:45,700
pattern would say and get me a list of

00:50:41,940 --> 00:50:48,070
other users for team apple whatever and

00:50:45,700 --> 00:50:52,660
then it will return a list of users that

00:50:48,070 --> 00:50:54,850
meet that requirement so my business

00:50:52,660 --> 00:50:57,070
logic probably doesn't really care how

00:50:54,850 --> 00:50:59,260
that data is stored it's just saying I

00:50:57,070 --> 00:51:01,720
don't really care how you get me all the

00:50:59,260 --> 00:51:04,330
team members for the team apple I just

00:51:01,720 --> 00:51:09,100
want all those all those team members so

00:51:04,330 --> 00:51:13,450
and that's why I think that the database

00:51:09,100 --> 00:51:15,610
is just implementation detail like I'm

00:51:13,450 --> 00:51:17,740
testing the business object yeah however

00:51:15,610 --> 00:51:20,200
what you still need to do is you still

00:51:17,740 --> 00:51:23,110
need to test that your approximation of

00:51:20,200 --> 00:51:24,310
the database and you know your basically

00:51:23,110 --> 00:51:28,470
your test double and the real

00:51:24,310 --> 00:51:28,470
implementation function in the same way

00:51:28,920 --> 00:51:37,780
yeah and okay so you would want to push

00:51:36,280 --> 00:51:41,290
as much down as possible to the unit

00:51:37,780 --> 00:51:47,500
test level but sometimes you so for

00:51:41,290 --> 00:51:49,210
example in this particular project there

00:51:47,500 --> 00:51:51,370
would be things I would be testing at

00:51:49,210 --> 00:51:55,270
the unit levels so for example have I

00:51:51,370 --> 00:51:58,750
correctly calculate to the school of a

00:51:55,270 --> 00:52:01,630
particular quiz so what would what

00:51:58,750 --> 00:52:03,430
happen in this case is the quiz temp

00:52:01,630 --> 00:52:05,290
typically had like ten questions and

00:52:03,430 --> 00:52:08,020
each question had a different maximum

00:52:05,290 --> 00:52:10,450
score so I would unit test I will say

00:52:08,020 --> 00:52:12,280
okay if these are the questions and

00:52:10,450 --> 00:52:14,170
these the answer supplied what is the

00:52:12,280 --> 00:52:16,660
total score I would definitely do that

00:52:14,170 --> 00:52:19,570
at unit test level but then the bigger

00:52:16,660 --> 00:52:21,430
question of have I correctly pulled out

00:52:19,570 --> 00:52:24,940
all the information and worked out all

00:52:21,430 --> 00:52:26,740
of the that you know the team's score

00:52:24,940 --> 00:52:30,010
based on

00:52:26,740 --> 00:52:32,340
on you know all that all the times when

00:52:30,010 --> 00:52:35,260
the tests were completed by which user I

00:52:32,340 --> 00:52:37,390
know each my individual components work

00:52:35,260 --> 00:52:40,180
but how do I know that I've joined them

00:52:37,390 --> 00:52:42,070
together correctly so that's kind of

00:52:40,180 --> 00:52:45,520
what I'm that's that's the question I'm

00:52:42,070 --> 00:52:47,710
answering there is I know all the little

00:52:45,520 --> 00:52:49,150
bits work how about have I joined them

00:52:47,710 --> 00:52:51,820
together in the same way when you're

00:52:49,150 --> 00:52:55,510
writing PHP code you just assume that

00:52:51,820 --> 00:52:57,310
all of the PHP functions you call you

00:52:55,510 --> 00:52:59,320
just assume they work and the whole

00:52:57,310 --> 00:53:00,820
point of unit test is have I joined all

00:52:59,320 --> 00:53:02,740
those things together at the unit level

00:53:00,820 --> 00:53:33,790
where it's the same thing but just a

00:53:02,740 --> 00:53:36,580
level higher yes I would I would test

00:53:33,790 --> 00:53:38,560
details was that in score had the units

00:53:36,580 --> 00:53:43,410
as level but then I'm just saying all

00:53:38,560 --> 00:53:43,410
these things working correctly

00:53:52,920 --> 00:54:00,220
so and yes so the test mm I'm doing

00:53:58,510 --> 00:54:01,750
might be so if the integration it was

00:54:00,220 --> 00:54:04,180
quite high level one it might be saying

00:54:01,750 --> 00:54:07,000
create me a team put these users on

00:54:04,180 --> 00:54:08,920
pretend or creamy two teams put me this

00:54:07,000 --> 00:54:10,990
user in this team make them answer this

00:54:08,920 --> 00:54:13,270
quiz now move them to another team make

00:54:10,990 --> 00:54:15,310
me answer something that user answer

00:54:13,270 --> 00:54:17,010
that second quiz and make sure that the

00:54:15,310 --> 00:54:19,060
schools have been associated or

00:54:17,010 --> 00:54:23,260
allocated to it to each of the teams

00:54:19,060 --> 00:54:26,290
correctly and so in this particular

00:54:23,260 --> 00:54:28,960
example there was no single unit bit of

00:54:26,290 --> 00:54:31,000
code that did that it required lots of

00:54:28,960 --> 00:54:33,940
moving parts of the system to do that

00:54:31,000 --> 00:54:35,500
now the database that's just a data

00:54:33,940 --> 00:54:38,410
persistence thing I don't really care

00:54:35,500 --> 00:54:40,560
how that's persisted and I would do

00:54:38,410 --> 00:54:43,820
tests with a real database because

00:54:40,560 --> 00:54:47,370
I still need to make sure that my

00:54:43,820 --> 00:54:51,420
approximation of the database is correct

00:54:47,370 --> 00:54:53,850
because obviously if my database tests

00:54:51,420 --> 00:54:55,080
double and the real database do not

00:54:53,850 --> 00:54:56,640
behave in the same way then there's a

00:54:55,080 --> 00:54:58,350
matter that it all works with my tests

00:54:56,640 --> 00:55:00,690
double because I don't know that it

00:54:58,350 --> 00:55:02,910
works with with the real database so a

00:55:00,690 --> 00:55:06,120
way that I might take these two things

00:55:02,910 --> 00:55:11,810
is I might have a simple test that says

00:55:06,120 --> 00:55:14,730
I am going to create a few users

00:55:11,810 --> 00:55:17,580
allocated this team persist them and

00:55:14,730 --> 00:55:18,870
then I'm going to pull out or you know I

00:55:17,580 --> 00:55:20,310
probably have a couple of users with

00:55:18,870 --> 00:55:22,050
different teams and then I'm going to

00:55:20,310 --> 00:55:24,950
pull out all the users of star called

00:55:22,050 --> 00:55:27,480
get users for Team a get users team B

00:55:24,950 --> 00:55:31,770
then what I can do is I can have a test

00:55:27,480 --> 00:55:33,960
and I run it once with my test double

00:55:31,770 --> 00:55:37,080
and once with the real implementation

00:55:33,960 --> 00:55:39,330
and if that passes then it says to me it

00:55:37,080 --> 00:55:41,640
gives me confidence that my test double

00:55:39,330 --> 00:55:43,710
is good approximation of my real

00:55:41,640 --> 00:55:48,360
implementation of the database and then

00:55:43,710 --> 00:55:52,200
it gives me more reason to believe that

00:55:48,360 --> 00:55:53,730
my my test double is fine to use when

00:55:52,200 --> 00:55:55,740
I'm testing a business logic now the

00:55:53,730 --> 00:55:57,180
only times I would only really go to do

00:55:55,740 --> 00:56:00,960
that is when the tests are getting too

00:55:57,180 --> 00:56:03,270
slow so um like we have one test three

00:56:00,960 --> 00:56:04,770
that takes like 30 or 40 minutes to run

00:56:03,270 --> 00:56:07,140
and one of the reasons is because he's

00:56:04,770 --> 00:56:09,030
using real database and that could be an

00:56:07,140 --> 00:56:11,010
order of magnitude quicker weight

00:56:09,030 --> 00:56:14,520
probably be like from going under a

00:56:11,010 --> 00:56:20,630
minute if we had you know testable set

00:56:14,520 --> 00:56:20,630
so that's yeah

00:56:28,800 --> 00:56:41,530
yeah yeah I mean we are way out where

00:56:31,540 --> 00:56:48,670
versi either does it but yeah yeah yeah

00:56:41,530 --> 00:57:33,550
yeah yeah it's just an issue yeah

00:56:48,670 --> 00:57:34,750
absolutely so when I say fake I'm

00:57:33,550 --> 00:57:37,090
probably talking at a high level

00:57:34,750 --> 00:57:38,980
obstructional I'm saying if you've got a

00:57:37,090 --> 00:57:41,890
repository and in space a repository in

00:57:38,980 --> 00:57:44,320
space and generally that's the level

00:57:41,890 --> 00:57:47,110
well I so I don't have a my squirrel in

00:57:44,320 --> 00:57:48,910
a SQL light I might have a MySQL

00:57:47,110 --> 00:57:51,040
implementation of the repository and

00:57:48,910 --> 00:57:52,180
then I might have a PHP array

00:57:51,040 --> 00:57:54,490
implementation of the repository

00:57:52,180 --> 00:57:57,610
although when you start doing things

00:57:54,490 --> 00:58:00,010
like that the spatial stuff then I mean

00:57:57,610 --> 00:58:03,450
it takes too long to probably the

00:58:00,010 --> 00:58:03,450
database is quicker anyway you know

00:58:05,600 --> 00:58:17,490
hmm yeah but then then and yeah and that

00:58:15,150 --> 00:58:21,450
is appropriate I think for sometimes but

00:58:17,490 --> 00:58:23,430
but then you've still got your quite

00:58:21,450 --> 00:58:25,380
tightly coupled then because you need to

00:58:23,430 --> 00:58:26,880
know exactly what order the data is

00:58:25,380 --> 00:58:30,780
going to be coming in and what you're

00:58:26,880 --> 00:58:32,220
returning so I think that would be this

00:58:30,780 --> 00:58:34,200
probably we're gonna have more of a chat

00:58:32,220 --> 00:58:38,240
later I'm just with constant guys anyone

00:58:34,200 --> 00:58:38,240
I've got a quick question before yes

00:58:39,630 --> 00:58:43,740
a bit of a dinosaur and still use

00:58:41,490 --> 00:58:47,000
phpunit pretty much as a test runner for

00:58:43,740 --> 00:58:49,620
everything I do think though that and

00:58:47,000 --> 00:58:52,500
b-hat will offer a lot of it a lot of

00:58:49,620 --> 00:58:53,880
benefits but I think that the principles

00:58:52,500 --> 00:58:55,200
are applicable I think it so everything

00:58:53,880 --> 00:58:57,300
it doesn't really matter what tools you

00:58:55,200 --> 00:58:58,770
use and I do generally think that

00:58:57,300 --> 00:59:00,900
certainly if I highlight the thing I

00:58:58,770 --> 00:59:03,090
would be better off I'd have a less

00:59:00,900 --> 00:59:04,320
painful time if we use being hat just

00:59:03,090 --> 00:59:07,010
because it abstracts away some of this

00:59:04,320 --> 00:59:07,010
stuff yeah

00:59:33,280 --> 00:59:36,439
[Music]

00:59:57,470 --> 01:00:20,460
sorry so the question is you've got

01:00:00,710 --> 01:00:24,810
let's see yeah yeah yeah yeah right

01:00:20,460 --> 01:00:27,750
and that but you're not so you using the

01:00:24,810 --> 01:00:29,820
same thing across many tests and you

01:00:27,750 --> 01:00:45,720
running one test than the next based on

01:00:29,820 --> 01:00:49,210
the priests yeah yeah yeah yeah

01:00:45,720 --> 01:00:54,640
right so I think and the user you

01:00:49,210 --> 01:00:56,859
generate should be you document exactly

01:00:54,640 --> 01:00:58,809
what the properties of that user are so

01:00:56,859 --> 01:01:01,630
if for example you were doing user you

01:00:58,809 --> 01:01:03,010
had personas then everyone would know

01:01:01,630 --> 01:01:04,809
because if your document is somewhere

01:01:03,010 --> 01:01:07,660
that arrow is this kind of user and Bob

01:01:04,809 --> 01:01:11,710
is this kind of user and so if you then

01:01:07,660 --> 01:01:13,030
are trying to if you then have because

01:01:11,710 --> 01:01:14,920
the business requirement comes on that

01:01:13,030 --> 01:01:17,290
there's a different kind of user then

01:01:14,920 --> 01:01:19,089
create a new you know object mother get

01:01:17,290 --> 01:01:21,010
out of generally forget Bob and then

01:01:19,089 --> 01:01:22,599
you've got this new requirements so it

01:01:21,010 --> 01:01:24,910
could be object mother get charlie or

01:01:22,599 --> 01:01:26,230
whatever so if there are fundamentally

01:01:24,910 --> 01:01:28,410
different users or the different

01:01:26,230 --> 01:01:28,410
purposes

01:01:31,580 --> 01:01:44,940
[Music]

01:01:32,730 --> 01:01:44,940
yeah yeah

01:02:04,130 --> 01:02:09,180
how are you using the same data across

01:02:07,319 --> 01:02:15,619
tests so you're not clearing out the

01:02:09,180 --> 01:02:23,160
database but right at the start the test

01:02:15,619 --> 01:02:24,779
right okay and well yeah that's so you

01:02:23,160 --> 01:02:27,829
the problem of doing it that way is

01:02:24,779 --> 01:02:31,440
you'll run into issues like this and

01:02:27,829 --> 01:02:32,849
what you is the reason you only running

01:02:31,440 --> 01:02:35,700
it once just cuz it takes that long to

01:02:32,849 --> 01:02:37,740
put the data into it to to create the

01:02:35,700 --> 01:02:39,240
fixtures sorry we're gonna have to can

01:02:37,740 --> 01:02:41,220
we continue this I want to have a chat

01:02:39,240 --> 01:02:42,569
but we've only we're kind of that's fine

01:02:41,220 --> 01:02:43,890
and this if anyone else wants to listen

01:02:42,569 --> 01:02:50,810
in will discover

01:02:43,890 --> 01:02:50,810

YouTube URL: https://www.youtube.com/watch?v=xeIAXk4dVyA


