Title: Hansel and Gretel do TLS | Marcus Bointon
Publication date: 2019-07-25
Playlist: International PHP Conference Spring 2019
Description: 
	Speaker: Marcus Bointon (Synchromedia Limited) | https://phpconference.com/speaker/marcus-bointon/

Effective encryption is a vital component of a safe and secure internet, especially since the arrival of HTTP/2. Many sites and mobile apps still don’t use TLS to encrypt their traffic, often citing some kind of fear over the complexity of it all, or if they do, they make a mess of it, resulting in a literal false sense of security. The basics of TLS encryption are straightforward, but the practical realities run into a bewildering forest of acronyms. This talk gives you a breadcrumb trail through the backwoods of TLS, OCSP, ECDHE, ALPN, HTTP/2, HSTS, HPKP, CT, and more, including the latest changes in TLS 1.3.
You’ll get an overview of what problems TLS solves, how it works, its component pieces, how they fit together, where vulnerabilities and mitigations apply, and what tools and resources can help you get up to speed.

🤗 Come, join us at the next International PHP Conference | https://phpconference.com/
👍 Like us on Facebook | https://www.facebook.com/ipc.germany/
👉 Follow us on Twitter | https://twitter.com/phpconference
Captions: 
	00:00:00,250 --> 00:00:09,120
[Music]

00:00:04,370 --> 00:00:12,090
okay hello everybody here today to talk

00:00:09,120 --> 00:00:14,070
to you about TLS my name is Marcus

00:00:12,090 --> 00:00:15,540
Boynton I have a little two-man company

00:00:14,070 --> 00:00:19,529
that's based in the UK though I actually

00:00:15,540 --> 00:00:23,220
live in France that doesn't have a great

00:00:19,529 --> 00:00:25,470
future I think this combination but

00:00:23,220 --> 00:00:27,810
there we go

00:00:25,470 --> 00:00:30,119
you've probably used my code at some

00:00:27,810 --> 00:00:32,399
point because I'm the maintainer of PHP

00:00:30,119 --> 00:00:34,649
mailer which moreless the entire world

00:00:32,399 --> 00:00:37,620
who's used at some point if you're in

00:00:34,649 --> 00:00:39,149
IPC Munich last year I did a keynote

00:00:37,620 --> 00:00:41,030
they're all about that because it has

00:00:39,149 --> 00:00:43,770
quite an interesting story behind it

00:00:41,030 --> 00:00:45,750
I've got a long history behind this

00:00:43,770 --> 00:00:49,379
smart messages dotnet product which is a

00:00:45,750 --> 00:00:52,379
an email marketing system and as part of

00:00:49,379 --> 00:00:54,090
that I've had to do lots of security TLS

00:00:52,379 --> 00:00:56,280
privacy stuff so I've become something

00:00:54,090 --> 00:01:00,270
ever Pro C advocate as well and you I'm

00:00:56,280 --> 00:01:04,470
doing a talk on that tomorrow so first

00:01:00,270 --> 00:01:08,549
up what is TLS well it's an acronym okay

00:01:04,470 --> 00:01:11,430
for transport layer security and this is

00:01:08,549 --> 00:01:14,430
really the new name for SSL which was

00:01:11,430 --> 00:01:16,080
the secure socket layer though I say new

00:01:14,430 --> 00:01:18,479
name it's actually being called TLS

00:01:16,080 --> 00:01:18,860
since 1999 so that's not twenty years

00:01:18,479 --> 00:01:21,030
old

00:01:18,860 --> 00:01:22,619
it's old enough to drive and go to

00:01:21,030 --> 00:01:24,990
school and drink and things like that

00:01:22,619 --> 00:01:25,920
but people still call it SSL and the two

00:01:24,990 --> 00:01:27,299
terms are really pretty much

00:01:25,920 --> 00:01:32,100
interchangeable it doesn't really matter

00:01:27,299 --> 00:01:34,920
but TLS is the proper name there have

00:01:32,100 --> 00:01:38,280
been several versions of TLS through the

00:01:34,920 --> 00:01:42,360
years SSL version two and three there

00:01:38,280 --> 00:01:45,119
wasn't a one then in 99 TLS version one

00:01:42,360 --> 00:01:48,390
was released followed by 1.1

00:01:45,119 --> 00:01:52,170
not long after and then in 2008 TLS 1.2

00:01:48,390 --> 00:01:56,729
came along and then finally last year

00:01:52,170 --> 00:01:59,340
TLS 1.3 and 1.3 was quite a big set of

00:01:56,729 --> 00:02:00,780
changes and it was really a pretty

00:01:59,340 --> 00:02:02,909
important thing and it needed to be done

00:02:00,780 --> 00:02:06,899
because the last version was 10 years

00:02:02,909 --> 00:02:09,209
previously so what's in TLS well it's a

00:02:06,899 --> 00:02:10,770
set of standards for security and

00:02:09,209 --> 00:02:12,840
encryption and

00:02:10,770 --> 00:02:14,360
establishing encrypted connections

00:02:12,840 --> 00:02:17,250
between servers

00:02:14,360 --> 00:02:18,750
it's a specification really so it's not

00:02:17,250 --> 00:02:21,840
actually a thing in itself it's for

00:02:18,750 --> 00:02:23,790
other people to implement in libraries

00:02:21,840 --> 00:02:25,620
and so on and you can wrap it around any

00:02:23,790 --> 00:02:29,760
high level protocol and most often

00:02:25,620 --> 00:02:30,599
that's HTTP is HTTP SMTP in various

00:02:29,760 --> 00:02:34,739
different ways

00:02:30,599 --> 00:02:36,900
FTP but note that's FTPS not SFTP which

00:02:34,739 --> 00:02:39,599
is an SSH based protocol and completely

00:02:36,900 --> 00:02:42,450
different and other things like IMAP and

00:02:39,599 --> 00:02:44,730
so on there are some popular

00:02:42,450 --> 00:02:47,220
implementations of TLS the most popular

00:02:44,730 --> 00:02:49,230
really is open SSL and that has a long

00:02:47,220 --> 00:02:52,260
history behind it one of the problems

00:02:49,230 --> 00:02:54,269
with open SSL is that it's very old it's

00:02:52,260 --> 00:02:55,830
got a huge amount of legacy stuff in it

00:02:54,269 --> 00:02:59,099
support for operating systems that no

00:02:55,830 --> 00:03:00,810
longer exists and lots of legacy craft

00:02:59,099 --> 00:03:03,510
and lots of things that are insecure and

00:03:00,810 --> 00:03:05,549
broken and a few years ago there was a

00:03:03,510 --> 00:03:07,709
very public vulnerability called

00:03:05,549 --> 00:03:11,549
heartbleed and that was really down to

00:03:07,709 --> 00:03:13,620
just a bug in open SSL and at this point

00:03:11,549 --> 00:03:15,570
everybody realized that more or less the

00:03:13,620 --> 00:03:17,940
entire infrastructure of the secure

00:03:15,570 --> 00:03:20,489
internet was based on two people working

00:03:17,940 --> 00:03:22,500
in their spare time this is really not a

00:03:20,489 --> 00:03:23,940
very good situation and as a result of

00:03:22,500 --> 00:03:26,280
that it got a whole load of sponsorship

00:03:23,940 --> 00:03:28,709
but one of the other reactions was that

00:03:26,280 --> 00:03:30,090
it was forked a couple of times and

00:03:28,709 --> 00:03:31,859
probably the most interesting one is

00:03:30,090 --> 00:03:34,049
libre SSL and this was done by the

00:03:31,859 --> 00:03:36,840
OpenBSD people who are responsible for

00:03:34,049 --> 00:03:40,230
things like open SSH and lots of really

00:03:36,840 --> 00:03:43,170
sort of definitive secure ways of doing

00:03:40,230 --> 00:03:45,359
stuff is has originated with open BSD

00:03:43,170 --> 00:03:47,430
and what they did is they took open SSL

00:03:45,359 --> 00:03:49,769
and they just cut out all of the croft

00:03:47,430 --> 00:03:51,840
they just threw away vast amounts of it

00:03:49,769 --> 00:03:54,209
and the first few days of their change

00:03:51,840 --> 00:03:56,819
log on on the git repo is really quite

00:03:54,209 --> 00:03:57,989
funny because they were just being

00:03:56,819 --> 00:03:59,700
really aggressive and they're just

00:03:57,989 --> 00:04:02,459
slagging off all this old code in it

00:03:59,700 --> 00:04:04,200
it's quite a funny read anyway liebherr

00:04:02,459 --> 00:04:05,609
SSL is very much cut down and you'll

00:04:04,200 --> 00:04:09,019
find that installed in quite a few Linux

00:04:05,609 --> 00:04:10,920
distributions already boring SSL is

00:04:09,019 --> 00:04:13,500
essentially Google doing more or less

00:04:10,920 --> 00:04:15,420
the same thing they cut it down to

00:04:13,500 --> 00:04:16,979
really quite a limited subset and the

00:04:15,420 --> 00:04:18,930
reason they called it boring SSL is

00:04:16,979 --> 00:04:22,880
because the idea is that you will never

00:04:18,930 --> 00:04:22,880
read a headline about boring SSL

00:04:23,250 --> 00:04:27,640
so why do we want to use TLS well

00:04:25,960 --> 00:04:29,860
fundamentally it provides the the

00:04:27,640 --> 00:04:31,960
Trinity of features that we expect from

00:04:29,860 --> 00:04:33,730
a security layer provides

00:04:31,960 --> 00:04:35,830
confidentiality so that it can only be

00:04:33,730 --> 00:04:38,260
that our data can only be seen by the

00:04:35,830 --> 00:04:40,960
people we intend it to be seen by that

00:04:38,260 --> 00:04:43,840
it's we can prove its authenticity we

00:04:40,960 --> 00:04:45,610
can show we can be sure that the person

00:04:43,840 --> 00:04:48,190
that we're talking to is the person that

00:04:45,610 --> 00:04:50,170
they say they are and also we can vouch

00:04:48,190 --> 00:04:53,010
for the integrity of the data once it's

00:04:50,170 --> 00:04:55,630
got from one place to another and that's

00:04:53,010 --> 00:04:58,510
that's there are various tools in it to

00:04:55,630 --> 00:05:00,100
help with that why we might actually use

00:04:58,510 --> 00:05:01,960
it on top of the kind of the stuff that

00:05:00,100 --> 00:05:03,550
we take for granted is you get better

00:05:01,960 --> 00:05:06,580
performance because it means you can use

00:05:03,550 --> 00:05:09,010
HTTP to Google will rank you higher on

00:05:06,580 --> 00:05:11,470
in search results that that's kind of

00:05:09,010 --> 00:05:12,880
getting to the point where it's it's not

00:05:11,470 --> 00:05:16,390
really a different differentiate or

00:05:12,880 --> 00:05:19,930
anymore it's required for the backends

00:05:16,390 --> 00:05:21,400
for iOS applications and some things

00:05:19,930 --> 00:05:23,500
have become dependent on TLS

00:05:21,400 --> 00:05:25,600
independently of the standards

00:05:23,500 --> 00:05:28,120
themselves so for example in chrome 50

00:05:25,600 --> 00:05:30,580
they disabled geolocation over

00:05:28,120 --> 00:05:31,600
unencrypted HTTP and then what you might

00:05:30,580 --> 00:05:33,370
find there are various other little

00:05:31,600 --> 00:05:34,870
pieces of the kind of JavaScript

00:05:33,370 --> 00:05:36,940
environment that disappear if you're not

00:05:34,870 --> 00:05:38,830
using a secure connection fundamentally

00:05:36,940 --> 00:05:40,570
though it's all about keeping the wicked

00:05:38,830 --> 00:05:41,950
witch out keeping the bad guys away from

00:05:40,570 --> 00:05:46,900
your site and away from your data and

00:05:41,950 --> 00:05:48,910
away from your users so TLS is say it's

00:05:46,900 --> 00:05:51,880
a it's kind of a framework into which

00:05:48,910 --> 00:05:53,890
things plug the framework itself really

00:05:51,880 --> 00:05:54,460
is is the protocol and that hasn't

00:05:53,890 --> 00:05:55,660
changed

00:05:54,460 --> 00:05:57,130
enormous Lee that will go into the

00:05:55,660 --> 00:05:59,290
significant changes that have happened

00:05:57,130 --> 00:06:01,180
recently with that fundamentally there

00:05:59,290 --> 00:06:02,740
are these three utility functions that

00:06:01,180 --> 00:06:04,630
sit within this framework and are used

00:06:02,740 --> 00:06:07,480
as part of the the connection process

00:06:04,630 --> 00:06:11,650
and these are really ciphers Macs and

00:06:07,480 --> 00:06:13,840
hashes hashes are all about the

00:06:11,650 --> 00:06:16,450
integrity some people refer to them as

00:06:13,840 --> 00:06:18,250
one-way encryption because you the idea

00:06:16,450 --> 00:06:19,810
is that you can put in any amount of

00:06:18,250 --> 00:06:21,430
data whether it's a single byte or a

00:06:19,810 --> 00:06:23,380
terabyte it doesn't make any difference

00:06:21,430 --> 00:06:25,450
you get the same size output and the

00:06:23,380 --> 00:06:27,280
tiniest little change in the input will

00:06:25,450 --> 00:06:29,680
result in a completely different output

00:06:27,280 --> 00:06:32,650
so this this means that it's a very good

00:06:29,680 --> 00:06:35,110
way of identifying whether a transferred

00:06:32,650 --> 00:06:36,670
piece of data has actually remained in

00:06:35,110 --> 00:06:38,620
hacks and hasn't been corrupted in

00:06:36,670 --> 00:06:41,290
transit so you can take the hash at one

00:06:38,620 --> 00:06:43,120
end transfer it can compute the hash

00:06:41,290 --> 00:06:44,800
again at the other end and if they're

00:06:43,120 --> 00:06:46,060
the same then you mean you don't have to

00:06:44,800 --> 00:06:47,830
like go through the file and compare

00:06:46,060 --> 00:06:49,510
them byte for byte because that would

00:06:47,830 --> 00:06:50,620
mean that you have the two copies in the

00:06:49,510 --> 00:06:52,300
same place for a start

00:06:50,620 --> 00:06:55,800
or an awful lot of additional network

00:06:52,300 --> 00:06:57,550
traffic so hashes are very useful things

00:06:55,800 --> 00:06:59,230
there are a whole bunch of hash

00:06:57,550 --> 00:07:01,030
algorithms ones that you're livin

00:06:59,230 --> 00:07:04,150
countered in particular things like md5

00:07:01,030 --> 00:07:05,800
and sha-1 those ones I've marked has

00:07:04,150 --> 00:07:07,360
crossed out because they are considered

00:07:05,800 --> 00:07:09,250
broken and obsolete and you shouldn't

00:07:07,360 --> 00:07:12,190
use anything so search your code base

00:07:09,250 --> 00:07:13,780
for the term md5 and get rid of it

00:07:12,190 --> 00:07:20,230
replace it with something better like

00:07:13,780 --> 00:07:22,510
sha - now there are different hash

00:07:20,230 --> 00:07:25,540
algorithms for different purposes now

00:07:22,510 --> 00:07:27,190
md5 sha-1 sha - or all about speed

00:07:25,540 --> 00:07:28,930
they're intended to be as fast as

00:07:27,190 --> 00:07:30,520
possible only to give you a nice

00:07:28,930 --> 00:07:32,320
reliable result on a very large amount

00:07:30,520 --> 00:07:34,570
of data you can do gigabytes per second

00:07:32,320 --> 00:07:36,130
through these hashes and they would be

00:07:34,570 --> 00:07:38,560
really quick but there are other hash

00:07:36,130 --> 00:07:42,130
functions like bcrypt and argon - which

00:07:38,560 --> 00:07:43,600
are aimed at password hashing and TLS

00:07:42,130 --> 00:07:45,550
has nothing to do with that

00:07:43,600 --> 00:07:47,260
so tier lesson does not concern itself

00:07:45,550 --> 00:07:50,680
with password hashing that's dealt with

00:07:47,260 --> 00:07:52,630
in other places if you're using PHP

00:07:50,680 --> 00:07:54,490
probably the best place to get those

00:07:52,630 --> 00:07:59,290
functions by themselves is actually in

00:07:54,490 --> 00:08:00,220
Lib sodium step beyond a hash is the

00:07:59,290 --> 00:08:03,520
thing called a message authentication

00:08:00,220 --> 00:08:05,830
code and this is very much like a hash

00:08:03,520 --> 00:08:09,790
in that you put in some data and you get

00:08:05,830 --> 00:08:11,830
a fixed size output but it adds a key as

00:08:09,790 --> 00:08:14,440
well so it combines the original data

00:08:11,830 --> 00:08:15,580
and a key to give you the result now one

00:08:14,440 --> 00:08:17,560
of the important things about that is

00:08:15,580 --> 00:08:20,950
that say for example you're using your

00:08:17,560 --> 00:08:22,480
hash to to try and suggest that the file

00:08:20,950 --> 00:08:24,400
that somebody has downloaded hasn't been

00:08:22,480 --> 00:08:25,870
corrupted so you might publish your file

00:08:24,400 --> 00:08:28,330
and in the same place you might publish

00:08:25,870 --> 00:08:30,340
the hash of the file if somebody's being

00:08:28,330 --> 00:08:31,960
able to hack into the server and replace

00:08:30,340 --> 00:08:33,370
that image file then they can also

00:08:31,960 --> 00:08:35,020
replace the hash because they just

00:08:33,370 --> 00:08:36,700
simply recompute the hash and save it

00:08:35,020 --> 00:08:39,700
into the hash file and nobody's any of

00:08:36,700 --> 00:08:41,560
the wiser but if you've used a Mac they

00:08:39,700 --> 00:08:43,960
can't do that because they don't have

00:08:41,560 --> 00:08:45,910
access to the key that you use to create

00:08:43,960 --> 00:08:47,950
the Mac so it gives an additional layer

00:08:45,910 --> 00:08:50,530
of authenticity to

00:08:47,950 --> 00:08:52,060
hache result that you've computed the

00:08:50,530 --> 00:08:53,560
actual output looks like dental you

00:08:52,060 --> 00:08:57,180
can't tell whether something's in max

00:08:53,560 --> 00:09:00,070
just by looking at it you have to know

00:08:57,180 --> 00:09:01,600
the most popular algorithm really for

00:09:00,070 --> 00:09:03,730
creating max is actually a thing called

00:09:01,600 --> 00:09:05,740
H Mac which is the hash based message

00:09:03,730 --> 00:09:09,430
authentication code and that takes a

00:09:05,740 --> 00:09:12,310
hash function like md5 or sha-1 an

00:09:09,430 --> 00:09:15,100
algorithm which adds the key to enable

00:09:12,310 --> 00:09:18,040
you to do that there are some things

00:09:15,100 --> 00:09:21,130
that are not based on a hash like for

00:09:18,040 --> 00:09:23,740
example poly 1305 is a relatively recent

00:09:21,130 --> 00:09:29,050
Mac algorithm and that's not based on

00:09:23,740 --> 00:09:31,570
the hash that's a pure Mac function the

00:09:29,050 --> 00:09:33,430
one of the problems with a Mac is that

00:09:31,570 --> 00:09:35,740
although it gives you this additional

00:09:33,430 --> 00:09:37,780
layer of authenticity if you're going to

00:09:35,740 --> 00:09:40,720
be able to actually check and verify

00:09:37,780 --> 00:09:42,580
that this file has not been tampered

00:09:40,720 --> 00:09:45,310
with then you have to have a copy of the

00:09:42,580 --> 00:09:47,050
key as well so you effectively kind of

00:09:45,310 --> 00:09:48,970
moved the problem to somewhere else and

00:09:47,050 --> 00:09:50,530
if you want to solve that properly you

00:09:48,970 --> 00:09:52,390
really need to look at digital

00:09:50,530 --> 00:09:55,000
signatures which is another way of using

00:09:52,390 --> 00:09:56,500
TLS and it can do that but I'm not going

00:09:55,000 --> 00:10:00,190
to cover that today because it just ends

00:09:56,500 --> 00:10:01,360
up being too much the thing that

00:10:00,190 --> 00:10:03,760
everybody thinks about one talk about

00:10:01,360 --> 00:10:06,310
TLS in encryption is of course ciphers

00:10:03,760 --> 00:10:10,600
and ciphers are encryption algorithms

00:10:06,310 --> 00:10:13,000
and the purpose of these is to transform

00:10:10,600 --> 00:10:16,000
data in a way in a mathematical way

00:10:13,000 --> 00:10:17,880
that's hard to reverse without the key

00:10:16,000 --> 00:10:20,830
that was used to do the the forward

00:10:17,880 --> 00:10:22,600
transformation and these are based on

00:10:20,830 --> 00:10:24,790
sort of classical mathematical problems

00:10:22,600 --> 00:10:27,910
such as factoring very large integers

00:10:24,790 --> 00:10:34,660
and the discrete logarithm problem more

00:10:27,910 --> 00:10:38,680
recently on elliptic curve functions you

00:10:34,660 --> 00:10:40,000
can further divide up these ciphers into

00:10:38,680 --> 00:10:42,400
whether they're symmetric or asymmetric

00:10:40,000 --> 00:10:45,550
now this is actually a very important

00:10:42,400 --> 00:10:47,740
distinction a symmetric cipher is one

00:10:45,550 --> 00:10:50,560
where the same key is used to encrypt

00:10:47,740 --> 00:10:51,910
and decrypt the data and that's

00:10:50,560 --> 00:10:53,620
something that you would probably want

00:10:51,910 --> 00:10:56,910
to use if you were encrypting things

00:10:53,620 --> 00:11:00,130
locally now prior to the 1970s all

00:10:56,910 --> 00:11:02,319
encryption was symmetric

00:11:00,130 --> 00:11:04,509
and one of them there's a basic problem

00:11:02,319 --> 00:11:06,370
with a symmetric algorithm is that

00:11:04,509 --> 00:11:08,980
somehow you've got to get the key from

00:11:06,370 --> 00:11:11,500
one side to another without the guy in

00:11:08,980 --> 00:11:13,720
the middle seeing it you can you can

00:11:11,500 --> 00:11:15,639
encrypt some data and transfer it but

00:11:13,720 --> 00:11:17,110
then the person at the other end can't

00:11:15,639 --> 00:11:19,180
decrypt it because they don't have the

00:11:17,110 --> 00:11:20,470
key and similarly if they try and return

00:11:19,180 --> 00:11:24,009
something to you then you can't decrypt

00:11:20,470 --> 00:11:26,949
it in the late sixties early seventies

00:11:24,009 --> 00:11:28,449
some of the security agencies on both

00:11:26,949 --> 00:11:31,180
sides of the Atlantic in the u.s. in the

00:11:28,449 --> 00:11:34,750
UK and he effectively invented a

00:11:31,180 --> 00:11:37,509
symmetric ciphers whereby you actually

00:11:34,750 --> 00:11:39,399
have two keys you effectively use one to

00:11:37,509 --> 00:11:42,850
encrypt and want to decrypt but you kind

00:11:39,399 --> 00:11:45,040
of they pair in this very neat way but

00:11:42,850 --> 00:11:48,009
the net result is is that you're able to

00:11:45,040 --> 00:11:50,649
transfer to use another the other

00:11:48,009 --> 00:11:52,600
person's public key which can literally

00:11:50,649 --> 00:11:54,370
be public and viewable by everybody but

00:11:52,600 --> 00:11:56,800
you can encrypt a message using that

00:11:54,370 --> 00:11:59,500
that then only they can decrypt using

00:11:56,800 --> 00:12:01,779
their own private key and that's a

00:11:59,500 --> 00:12:05,199
really neat trick and it enables some

00:12:01,779 --> 00:12:06,850
very useful features in TLS one of the

00:12:05,199 --> 00:12:08,620
other differences between symmetric and

00:12:06,850 --> 00:12:10,930
asymmetric ciphers is that on the whole

00:12:08,620 --> 00:12:13,360
a symmetric ciphers are really slow

00:12:10,930 --> 00:12:15,430
often thousands or tens of thousand

00:12:13,360 --> 00:12:16,720
times slower than symmetric ciphers and

00:12:15,430 --> 00:12:18,970
so you don't want to use them all the

00:12:16,720 --> 00:12:21,009
time however what you can do is combine

00:12:18,970 --> 00:12:24,220
the two and this is a really handy thing

00:12:21,009 --> 00:12:25,509
called key exchange and the idea behind

00:12:24,220 --> 00:12:28,000
key exchange is that you use an

00:12:25,509 --> 00:12:30,579
isometric cipher to transfer a key and

00:12:28,000 --> 00:12:32,920
then you can switch to using a symmetric

00:12:30,579 --> 00:12:35,019
cipher which allows you to then switch

00:12:32,920 --> 00:12:37,420
to the much faster algorithm available

00:12:35,019 --> 00:12:41,769
through the symmetric cipher that's a

00:12:37,420 --> 00:12:46,990
really handy routine approach that TLS

00:12:41,769 --> 00:12:48,759
uses and HTTPS users throughout cipher

00:12:46,990 --> 00:12:50,949
algorithms typically also broken into

00:12:48,759 --> 00:12:53,800
block and stream functions like the AES

00:12:50,949 --> 00:12:57,730
algorithm that's very popular is a block

00:12:53,800 --> 00:12:59,050
cipher and the cha-cha 20 cipher is a

00:12:57,730 --> 00:13:00,670
stream cipher and the only difference

00:12:59,050 --> 00:13:02,769
really is whether it operates on a block

00:13:00,670 --> 00:13:04,980
of data at a time or a single byte at a

00:13:02,769 --> 00:13:04,980
time

00:13:05,980 --> 00:13:11,180
typical algorithms are c4 and Triple DES

00:13:09,140 --> 00:13:15,500
are now considered broken and you

00:13:11,180 --> 00:13:19,310
shouldn't use them AES is very popular

00:13:15,500 --> 00:13:21,740
it's quite CPU intensive but as a result

00:13:19,310 --> 00:13:23,660
of that Intel have built instructions

00:13:21,740 --> 00:13:26,269
into their CPUs to give you hardware

00:13:23,660 --> 00:13:27,860
acceleration for AES and if you have

00:13:26,269 --> 00:13:29,720
hardware acceleration then that's the

00:13:27,860 --> 00:13:31,779
fastest cipher to use but if you don't

00:13:29,720 --> 00:13:34,370
charge L twenty is actually much faster

00:13:31,779 --> 00:13:36,290
and in software it's about three or four

00:13:34,370 --> 00:13:40,370
times faster than a es so that's worth

00:13:36,290 --> 00:13:44,180
while the RSA cipher is kind of showing

00:13:40,370 --> 00:13:46,339
its age but is still used although the

00:13:44,180 --> 00:13:49,959
RSA key exchange mechanism that goes

00:13:46,339 --> 00:13:54,440
with it is actually no longer supported

00:13:49,959 --> 00:13:56,120
so what's new in TLS 1.3 I mentioned

00:13:54,440 --> 00:13:59,149
we're getting rid of all the weak and

00:13:56,120 --> 00:14:00,410
legacy stuff the idea behind TLS 1.3 is

00:13:59,149 --> 00:14:01,579
they wanted to really kind of clean

00:14:00,410 --> 00:14:04,670
house in the same kind of way that

00:14:01,579 --> 00:14:05,570
Lieber SSL did they want to do that kind

00:14:04,670 --> 00:14:07,160
of thing but actually in the

00:14:05,570 --> 00:14:11,149
specification itself so that all

00:14:07,160 --> 00:14:12,500
implementations follow that approach so

00:14:11,149 --> 00:14:16,579
they got rid of lots of old stuff and

00:14:12,500 --> 00:14:17,810
the net result is is that well one of

00:14:16,579 --> 00:14:19,040
the one of the problems with the earlier

00:14:17,810 --> 00:14:20,660
versions is that there were all these

00:14:19,040 --> 00:14:24,519
different options for example there's a

00:14:20,660 --> 00:14:27,230
cipher called null which doesn't encrypt

00:14:24,519 --> 00:14:29,240
it's just it's just plain text all the

00:14:27,230 --> 00:14:32,300
way through and so yes it's encrypted

00:14:29,240 --> 00:14:34,640
using the do-nothing cipher this isn't

00:14:32,300 --> 00:14:36,920
very useful and the thing is that when

00:14:34,640 --> 00:14:39,230
you get something complicated and

00:14:36,920 --> 00:14:40,730
unfamiliar to it to a new developer say

00:14:39,230 --> 00:14:42,649
and they go in and they're using this

00:14:40,730 --> 00:14:44,360
library and they go all what which one

00:14:42,649 --> 00:14:45,740
of these shall I use I don't know what

00:14:44,360 --> 00:14:47,540
all these funny acronyms mean I'm going

00:14:45,740 --> 00:14:48,649
to pick that one and they might pick

00:14:47,540 --> 00:14:52,240
something which is completely

00:14:48,649 --> 00:14:54,920
inappropriate broken too weak whatever

00:14:52,240 --> 00:14:57,050
the idea behind TLS really was to get

00:14:54,920 --> 00:15:00,370
rid of all those situations and make it

00:14:57,050 --> 00:15:02,690
that they only allowed the strong stuff

00:15:00,370 --> 00:15:05,870
so essentially there are no weak

00:15:02,690 --> 00:15:07,279
algorithms remaining in TLS 1.3 they may

00:15:05,870 --> 00:15:10,149
of course get broken in future but

00:15:07,279 --> 00:15:10,149
that's not a problem yet

00:15:10,930 --> 00:15:17,180
there's more encryption in general the

00:15:14,780 --> 00:15:20,690
the pointer in the in the connection

00:15:17,180 --> 00:15:23,150
process which after which encryption is

00:15:20,690 --> 00:15:26,060
applied happens earlier than in earlier

00:15:23,150 --> 00:15:28,550
versions of TLS there's less overhead

00:15:26,060 --> 00:15:30,110
which we'll get into in a minute it

00:15:28,550 --> 00:15:33,500
supports something called perfect

00:15:30,110 --> 00:15:34,790
forward secrecy if you imagine that

00:15:33,500 --> 00:15:38,060
you've encrypted something using your

00:15:34,790 --> 00:15:40,400
private key and you send it across a

00:15:38,060 --> 00:15:42,830
network and that traffic is intercepted

00:15:40,400 --> 00:15:44,750
by some man in the middle attack err who

00:15:42,830 --> 00:15:46,790
then scoops up all this data and just

00:15:44,750 --> 00:15:50,090
saves it takes it away spends the next

00:15:46,790 --> 00:15:51,890
two years spinning up thousands of AWS

00:15:50,090 --> 00:15:54,650
instances because they've got some evil

00:15:51,890 --> 00:15:56,810
government backing them and eventually

00:15:54,650 --> 00:15:58,250
cracks your private key if they have

00:15:56,810 --> 00:16:00,950
that private key they can then decrypt

00:15:58,250 --> 00:16:04,460
all of your traffic that's a really big

00:16:00,950 --> 00:16:05,990
problem and that's when that's the

00:16:04,460 --> 00:16:07,310
situation when you have a lack of

00:16:05,990 --> 00:16:10,550
perfect forward secrecy

00:16:07,310 --> 00:16:14,450
what forward secrecy does is adds a

00:16:10,550 --> 00:16:17,450
random string to the to your key

00:16:14,450 --> 00:16:19,370
initialization and this means that the

00:16:17,450 --> 00:16:20,870
your private key isn't used directly

00:16:19,370 --> 00:16:22,910
it's combined with this random string

00:16:20,870 --> 00:16:25,490
and that random string is only used for

00:16:22,910 --> 00:16:26,750
the duration of that TLS connection once

00:16:25,490 --> 00:16:28,820
it's done and you've finished with it

00:16:26,750 --> 00:16:30,620
and you've you've stopped using it it's

00:16:28,820 --> 00:16:35,030
never used again it's very important

00:16:30,620 --> 00:16:36,530
that it's never used again the net

00:16:35,030 --> 00:16:38,660
result is that if somebody does manage

00:16:36,530 --> 00:16:40,940
to to decrypt that particular block at

00:16:38,660 --> 00:16:42,350
some distant future time when we've got

00:16:40,940 --> 00:16:45,560
computers that can do this in five

00:16:42,350 --> 00:16:47,420
minutes they can only do that on that

00:16:45,560 --> 00:16:49,400
particular piece of data they can't

00:16:47,420 --> 00:16:52,190
decrypt everything else so it really

00:16:49,400 --> 00:16:58,070
reduces the attack surface on our on a

00:16:52,190 --> 00:16:59,810
very kind of long-term basis perfect

00:16:58,070 --> 00:17:03,140
forward secrecy is available in earlier

00:16:59,810 --> 00:17:04,760
versions of TLS but in 1.3 all of the

00:17:03,140 --> 00:17:06,980
ciphers support perfect forward secrecy

00:17:04,760 --> 00:17:09,709
and or particularly the key exchange

00:17:06,980 --> 00:17:13,400
process support all of them support

00:17:09,709 --> 00:17:14,959
perfect forward secrecy elliptic curve

00:17:13,400 --> 00:17:17,240
ciphers the thing that that's nice about

00:17:14,959 --> 00:17:19,280
elliptic curves like the charge r20

00:17:17,240 --> 00:17:20,630
algorithm is that they're very small and

00:17:19,280 --> 00:17:23,269
very fast

00:17:20,630 --> 00:17:25,250
that they're extremely efficient they

00:17:23,269 --> 00:17:28,330
were available as an option in TLS 1.2

00:17:25,250 --> 00:17:31,070
but they're there as standard in 1.3

00:17:28,330 --> 00:17:33,259
there's also a really neat trick that's

00:17:31,070 --> 00:17:34,970
actually part that partly combined with

00:17:33,259 --> 00:17:37,159
the forward secrecy thing this downgrade

00:17:34,970 --> 00:17:40,549
protection now let's say you have a TLS

00:17:37,159 --> 00:17:42,110
1.3 client and a TLS 1.3 server but

00:17:40,549 --> 00:17:44,299
you've got a man in the middle the

00:17:42,110 --> 00:17:46,220
initial connection between the two it

00:17:44,299 --> 00:17:47,090
where it said we'll get into that in a

00:17:46,220 --> 00:17:48,889
moment

00:17:47,090 --> 00:17:51,380
it sends out a thing saying these are

00:17:48,889 --> 00:17:52,669
the list of ciphers that I support it's

00:17:51,380 --> 00:17:54,919
possible for the man in the middle to

00:17:52,669 --> 00:17:57,440
interfere with that and say because so

00:17:54,919 --> 00:17:59,090
if the client says hey I can use TLS 1.3

00:17:57,440 --> 00:18:01,820
in this nice strong cipher or I can use

00:17:59,090 --> 00:18:03,879
TLS 1.0 and this really rubbish old

00:18:01,820 --> 00:18:06,289
cipher that you can break into minutes

00:18:03,879 --> 00:18:09,769
they can potentially intercept that

00:18:06,289 --> 00:18:12,110
request and remove that option from it

00:18:09,769 --> 00:18:13,399
so that the server receives it and goes

00:18:12,110 --> 00:18:15,769
oh well we'd better pick this

00:18:13,399 --> 00:18:20,299
low-quality cipher then that's called a

00:18:15,769 --> 00:18:23,690
downgrade attack but TLS 1.3 has a neat

00:18:20,299 --> 00:18:25,159
trick to the the random string that

00:18:23,690 --> 00:18:28,909
which is used to provide the perfect

00:18:25,159 --> 00:18:32,419
forward secrecy contains a little bit

00:18:28,909 --> 00:18:35,929
that isn't random and it's only set by

00:18:32,419 --> 00:18:38,090
clients that have TLS 1.3 now the man in

00:18:35,929 --> 00:18:40,429
the middle must convey that thing

00:18:38,090 --> 00:18:42,590
otherwise that the the connection won't

00:18:40,429 --> 00:18:45,980
work at all so they can't interfere with

00:18:42,590 --> 00:18:48,950
that but if they have if this string is

00:18:45,980 --> 00:18:50,600
present it means that somebody has

00:18:48,950 --> 00:18:52,399
attacked the connection and so it means

00:18:50,600 --> 00:18:53,570
that you can detect that Europe that

00:18:52,399 --> 00:18:54,950
you've got somebody at trying to

00:18:53,570 --> 00:18:58,879
downgrade your connections so you can

00:18:54,950 --> 00:19:01,340
just deny it so I mentioned this

00:18:58,879 --> 00:19:02,779
handshake thing how does it work well

00:19:01,340 --> 00:19:06,590
let's see I'll go through the two

00:19:02,779 --> 00:19:08,450
mechanisms in 1.2 or 1.3 just quickly so

00:19:06,590 --> 00:19:10,279
first of all the client says hi I want

00:19:08,450 --> 00:19:12,860
to establish a secure connection here's

00:19:10,279 --> 00:19:14,210
the list of ciphers that I support and

00:19:12,860 --> 00:19:15,889
it sends that off to the server and

00:19:14,210 --> 00:19:18,169
we're gonna say that takes say 50

00:19:15,889 --> 00:19:22,220
milliseconds on a good day so the server

00:19:18,169 --> 00:19:24,230
receives that and it says ok I'm going

00:19:22,220 --> 00:19:25,879
to choose this cipher out of the list

00:19:24,230 --> 00:19:27,350
that you gave me so hopefully you want

00:19:25,879 --> 00:19:29,720
it to choose the the best one the

00:19:27,350 --> 00:19:32,539
strongest one and I'm going to give you

00:19:29,720 --> 00:19:33,830
back my public key and the certificate

00:19:32,539 --> 00:19:36,889
and the signature

00:19:33,830 --> 00:19:38,210
to prove that I am who you think I am so

00:19:36,889 --> 00:19:42,129
it sends that back to the client the

00:19:38,210 --> 00:19:45,169
client goes great here's my public key

00:19:42,129 --> 00:19:47,389
they they have a default key that's just

00:19:45,169 --> 00:19:49,730
generated by your browser and then it

00:19:47,389 --> 00:19:51,289
says I've now finished send that back to

00:19:49,730 --> 00:19:53,989
the server the server goes right I'm

00:19:51,289 --> 00:19:56,600
finished as well the client then goes

00:19:53,989 --> 00:19:58,129
right here's my HTTP request now that

00:19:56,600 --> 00:20:00,590
we've established all that and it sends

00:19:58,129 --> 00:20:03,379
that in and then the server calculates

00:20:00,590 --> 00:20:05,210
that through PHP or whatever and returns

00:20:03,379 --> 00:20:07,340
it back to the client so we've got three

00:20:05,210 --> 00:20:10,609
complete round-trips in order to

00:20:07,340 --> 00:20:11,929
establish a new TLS connection that's

00:20:10,609 --> 00:20:14,299
really quite a lot of overhead and

00:20:11,929 --> 00:20:19,039
that's one of the things that TLS 1.3

00:20:14,299 --> 00:20:23,989
seeks to address so what's different in

00:20:19,039 --> 00:20:26,539
1.3 well to start with it just sticks

00:20:23,989 --> 00:20:29,019
more stuff into these initial handshake

00:20:26,539 --> 00:20:31,519
messages because the public key is

00:20:29,019 --> 00:20:33,230
public information there's no harm in

00:20:31,519 --> 00:20:35,269
putting it in the initial unencrypted

00:20:33,230 --> 00:20:36,739
request with the client hello so we've

00:20:35,269 --> 00:20:38,090
got the cipher list and the public key

00:20:36,739 --> 00:20:40,970
at that point so that saved us one

00:20:38,090 --> 00:20:42,409
little trick so the server receives that

00:20:40,970 --> 00:20:45,559
it picks the cipher suite in the same

00:20:42,409 --> 00:20:47,840
way it shares back its own key

00:20:45,559 --> 00:20:50,210
certificate and signature and it says I

00:20:47,840 --> 00:20:53,179
finished the client says I finished -

00:20:50,210 --> 00:20:54,830
and here's my HTTP request so the server

00:20:53,179 --> 00:20:57,109
can receive that send it back to the

00:20:54,830 --> 00:20:59,749
client and you've lost a whole round

00:20:57,109 --> 00:21:02,960
trip so that's a 33 percent improvement

00:20:59,749 --> 00:21:06,889
in latency which is really worth having

00:21:02,960 --> 00:21:08,989
and as we'll see this is this is the

00:21:06,889 --> 00:21:10,609
kind of the worst case scenario for TLS

00:21:08,989 --> 00:21:13,220
1.3 where you're having to establish a

00:21:10,609 --> 00:21:15,019
new connection from scratch this is

00:21:13,220 --> 00:21:18,470
effectively the best case scenario for

00:21:15,019 --> 00:21:24,019
TLS 1.2 so there's just been a shift in

00:21:18,470 --> 00:21:25,759
the latency and overhead with 1.3 so

00:21:24,019 --> 00:21:27,230
once we've established a connection we

00:21:25,759 --> 00:21:29,779
can then reuse some of this information

00:21:27,230 --> 00:21:31,580
because we know what's what cipher suite

00:21:29,779 --> 00:21:33,019
we're using we've already got the keys

00:21:31,580 --> 00:21:35,059
so we don't have to transfer those

00:21:33,019 --> 00:21:36,830
things again we can just reuse them the

00:21:35,059 --> 00:21:40,940
next time that that particular client

00:21:36,830 --> 00:21:43,700
wants to connect to us so this time

00:21:40,940 --> 00:21:45,559
because we've already connected we have

00:21:43,700 --> 00:21:47,090
a session ID or a ticket and the

00:21:45,559 --> 00:21:47,480
difference between an ID and a ticket is

00:21:47,090 --> 00:21:49,490
the

00:21:47,480 --> 00:21:51,650
session ideas just like a session cookie

00:21:49,490 --> 00:21:53,900
it points at a store on the server side

00:21:51,650 --> 00:21:55,670
which stores the the information about

00:21:53,900 --> 00:21:57,770
the settings that are being used by that

00:21:55,670 --> 00:22:00,590
particular client now there's a

00:21:57,770 --> 00:22:02,390
scalability problem there anytime you've

00:22:00,590 --> 00:22:03,830
got lots of clients that involve storing

00:22:02,390 --> 00:22:05,240
stuff on the server you're just gonna

00:22:03,830 --> 00:22:08,270
eventually run out of space on the

00:22:05,240 --> 00:22:10,280
server even if the things are small so

00:22:08,270 --> 00:22:13,070
what you can do in the kind of memcache

00:22:10,280 --> 00:22:15,140
style is to offload that responsibility

00:22:13,070 --> 00:22:17,600
to the client and that's what a session

00:22:15,140 --> 00:22:19,790
ticket is so instead of storing that

00:22:17,600 --> 00:22:21,500
information on the server you store on

00:22:19,790 --> 00:22:23,330
the client but it's encrypted by the

00:22:21,500 --> 00:22:25,310
server so the client can't interfere

00:22:23,330 --> 00:22:27,080
with it it can't be tampered with and

00:22:25,310 --> 00:22:29,060
you know them that it's safe and but and

00:22:27,080 --> 00:22:29,750
what's more it's scalable every time you

00:22:29,060 --> 00:22:31,370
have a new client

00:22:29,750 --> 00:22:36,260
they provide the additional storage for

00:22:31,370 --> 00:22:38,810
that ticket so then the server goes

00:22:36,260 --> 00:22:40,670
that's all cool I know who you are I

00:22:38,810 --> 00:22:43,130
know your settings so I'm all happy with

00:22:40,670 --> 00:22:46,010
that we're finished the client says I'm

00:22:43,130 --> 00:22:47,690
finished - and here's my HTTP request so

00:22:46,010 --> 00:22:50,090
the server receives that process is that

00:22:47,690 --> 00:22:52,430
and sends it back to the client so in

00:22:50,090 --> 00:22:55,600
here we've saved a round-trip relative

00:22:52,430 --> 00:22:57,740
to our starting from scratch connection

00:22:55,600 --> 00:23:02,570
how does this work in one-point-three

00:22:57,740 --> 00:23:05,330
well there's a big bonus in here in 1.3

00:23:02,570 --> 00:23:08,600
the client hello includes the session

00:23:05,330 --> 00:23:12,200
ticket the key share and it includes the

00:23:08,600 --> 00:23:13,970
HTTP GET request as well and it's

00:23:12,200 --> 00:23:17,210
important that it's a get as you'll see

00:23:13,970 --> 00:23:19,730
in a minute so the server receives that

00:23:17,210 --> 00:23:23,540
go here's my key share so that you can

00:23:19,730 --> 00:23:25,610
decrypt my responses and I finished and

00:23:23,540 --> 00:23:27,650
here's the and I'm going to include the

00:23:25,610 --> 00:23:30,170
response to your request and that means

00:23:27,650 --> 00:23:33,290
that we've actually got no overhead this

00:23:30,170 --> 00:23:35,510
is what they call zero RTT which is zero

00:23:33,290 --> 00:23:38,930
round trips in addition to what you're

00:23:35,510 --> 00:23:40,430
doing on an unencrypted connection so

00:23:38,930 --> 00:23:41,720
this really weird tier that's 1.3 it's

00:23:40,430 --> 00:23:43,580
actually possible to get to the point

00:23:41,720 --> 00:23:46,130
where there's actually no latency

00:23:43,580 --> 00:23:47,630
overhead to using TLS and that's a

00:23:46,130 --> 00:23:50,330
pretty big win

00:23:47,630 --> 00:23:52,880
when you combine that with http/2 as

00:23:50,330 --> 00:23:55,780
we'll see again this all adds up to a

00:23:52,880 --> 00:23:58,669
really a pretty considerable advantage

00:23:55,780 --> 00:24:01,789
but there's a caveat here it's not HTTP

00:23:58,669 --> 00:24:02,929
GET the thing is with this we remember

00:24:01,789 --> 00:24:04,370
we're talking about the perfect forward

00:24:02,929 --> 00:24:06,320
secrecy and having this additional

00:24:04,370 --> 00:24:09,559
factor that's that's randomized each

00:24:06,320 --> 00:24:12,640
time the thing is that here we're doing

00:24:09,559 --> 00:24:16,010
the same request over and over again and

00:24:12,640 --> 00:24:17,480
so we should limit ourselves to get

00:24:16,010 --> 00:24:19,750
requests because they should be

00:24:17,480 --> 00:24:22,400
idempotent if you're familiar with this

00:24:19,750 --> 00:24:25,370
arrest terminology that a get request

00:24:22,400 --> 00:24:27,380
should never cause a change of state on

00:24:25,370 --> 00:24:28,909
the server side so no matter how many

00:24:27,380 --> 00:24:30,950
times you issue your get request you

00:24:28,909 --> 00:24:32,840
should get the same response and because

00:24:30,950 --> 00:24:34,940
we're effectively going to be reusing

00:24:32,840 --> 00:24:37,460
our perfect forward secrecy random

00:24:34,940 --> 00:24:39,409
element it means that it's subject to

00:24:37,460 --> 00:24:40,640
replay attacks so someone can even if

00:24:39,409 --> 00:24:42,440
they can't actually read the data they

00:24:40,640 --> 00:24:46,159
can capture it and replay it back to the

00:24:42,440 --> 00:24:48,140
server again but if we make it virt that

00:24:46,159 --> 00:24:53,419
doesn't matter then this isn't actually

00:24:48,140 --> 00:24:55,250
any kind of security risk and there are

00:24:53,419 --> 00:24:57,370
even some tricks that some people have

00:24:55,250 --> 00:25:00,020
just published just back in February

00:24:57,370 --> 00:25:04,880
where they claimed to have solved this

00:25:00,020 --> 00:25:06,710
problem which is quite handy so how do

00:25:04,880 --> 00:25:08,539
we go about creating a certificate so

00:25:06,710 --> 00:25:10,700
that we can actually set all this up and

00:25:08,539 --> 00:25:13,190
have it work well first of all we need

00:25:10,700 --> 00:25:15,080
to create a public/private key pair so

00:25:13,190 --> 00:25:17,600
that we can use that for our a symmetric

00:25:15,080 --> 00:25:22,190
cipher to to do our key exchange and

00:25:17,600 --> 00:25:24,260
that needs to be at least 2048 bits and

00:25:22,190 --> 00:25:28,220
there's a because that's a requirement

00:25:24,260 --> 00:25:29,960
of HTTP two and we use that to then

00:25:28,220 --> 00:25:31,520
create a certificate signing request if

00:25:29,960 --> 00:25:34,370
you've ever used one done one of these

00:25:31,520 --> 00:25:35,960
whenever you want to to go and create a

00:25:34,370 --> 00:25:37,580
request for a new certificate it'll ask

00:25:35,960 --> 00:25:39,980
you look questions like what the domain

00:25:37,580 --> 00:25:41,929
is who the owner is what country it's in

00:25:39,980 --> 00:25:43,640
and so on it just asks you a series of

00:25:41,929 --> 00:25:44,990
questions and you fill those things in

00:25:43,640 --> 00:25:46,970
and the result is this thing called a

00:25:44,990 --> 00:25:48,799
certificate signing request it's not a

00:25:46,970 --> 00:25:53,120
certificate itself you then need to have

00:25:48,799 --> 00:25:55,309
that signed oh the the CSR itself has a

00:25:53,120 --> 00:25:56,960
signature and that must use sha-2

00:25:55,309 --> 00:25:58,850
most of the certificate authorities

00:25:56,960 --> 00:26:00,559
around now will reject anything that's

00:25:58,850 --> 00:26:01,340
using anything less it used to be common

00:26:00,559 --> 00:26:03,230
to use

00:26:01,340 --> 00:26:06,290
actually one but that's not accepted

00:26:03,230 --> 00:26:08,060
anymore so you need to get the CSR

00:26:06,290 --> 00:26:11,000
signed in order to generate a public

00:26:08,060 --> 00:26:13,130
certificate so who are you gonna get to

00:26:11,000 --> 00:26:14,930
sign it well you can sign it yourself

00:26:13,130 --> 00:26:17,570
and that results in a thing called a

00:26:14,930 --> 00:26:19,400
self signed certificate and that works

00:26:17,570 --> 00:26:21,440
perfectly well and all the encryption is

00:26:19,400 --> 00:26:24,170
as strong as any other certificate

00:26:21,440 --> 00:26:26,390
except that of course you could be

00:26:24,170 --> 00:26:27,890
anybody and nobody trusts you and nobody

00:26:26,390 --> 00:26:29,690
should trust anybody in this in these

00:26:27,890 --> 00:26:31,280
circumstances because there's nobody

00:26:29,690 --> 00:26:33,980
vouching for you just you're just going

00:26:31,280 --> 00:26:37,280
yeah yeah honestly I'm really me you've

00:26:33,980 --> 00:26:38,810
got nobody vouching for your identity so

00:26:37,280 --> 00:26:41,210
the alternative is that you get it

00:26:38,810 --> 00:26:47,090
signed by a certificate authority known

00:26:41,210 --> 00:26:50,480
as a CA so how the CAS get their

00:26:47,090 --> 00:26:52,840
authority to do this well you have a

00:26:50,480 --> 00:26:55,280
thing called a certificate chain

00:26:52,840 --> 00:26:59,060
browsers and operating system so this is

00:26:55,280 --> 00:27:02,180
all on the client side typically have a

00:26:59,060 --> 00:27:04,130
store in which they save or they have

00:27:02,180 --> 00:27:05,930
pre-loaded a whole bunch of root

00:27:04,130 --> 00:27:08,240
certificates now these root certificates

00:27:05,930 --> 00:27:10,010
are actually just simple self-signed

00:27:08,240 --> 00:27:11,900
certificates it's just that they're ones

00:27:10,010 --> 00:27:15,440
that we have specifically chosen to

00:27:11,900 --> 00:27:17,870
trust we say no the people that build

00:27:15,440 --> 00:27:20,840
the browsers want to do they do security

00:27:17,870 --> 00:27:22,130
assessments of the CAS and they go you

00:27:20,840 --> 00:27:24,230
know we want to be sure that you are

00:27:22,130 --> 00:27:25,910
following these rules about how you

00:27:24,230 --> 00:27:27,880
issue certificate which things you sign

00:27:25,910 --> 00:27:29,990
how you protect your keys and so on and

00:27:27,880 --> 00:27:32,090
if they're not sure of those things

00:27:29,990 --> 00:27:33,890
they'll get dropped and that's a really

00:27:32,090 --> 00:27:35,960
sort of life-threatening thing for a

00:27:33,890 --> 00:27:39,320
company that's actually acting as a CA

00:27:35,960 --> 00:27:40,880
so they need to make sure they don't do

00:27:39,320 --> 00:27:42,500
any of those things and it's happened

00:27:40,880 --> 00:27:44,180
there have been quite a few CAS in the

00:27:42,500 --> 00:27:46,340
last few years that have gone down for

00:27:44,180 --> 00:27:49,190
various reasons there was one called

00:27:46,340 --> 00:27:51,820
Scott that didn't reveal that it had

00:27:49,190 --> 00:27:54,410
been bought by a Chinese company and

00:27:51,820 --> 00:27:57,550
that resulted in them being dropped from

00:27:54,410 --> 00:27:57,550
essentially all browsers

00:27:58,590 --> 00:28:02,639
now the server has a copy of those same

00:28:00,960 --> 00:28:06,539
certificates but they're not really used

00:28:02,639 --> 00:28:08,299
at that point on the server we install

00:28:06,539 --> 00:28:11,399
the site certificate that we obtained

00:28:08,299 --> 00:28:12,740
from our from our signing process so

00:28:11,399 --> 00:28:15,299
we've got the certificate for our site

00:28:12,740 --> 00:28:17,039
but usually the site certificate itself

00:28:15,299 --> 00:28:19,049
is not signed directly by the root

00:28:17,039 --> 00:28:21,210
certificate these the root certificates

00:28:19,049 --> 00:28:23,309
are really precious things and they have

00:28:21,210 --> 00:28:27,570
the private halves of them are the

00:28:23,309 --> 00:28:30,330
public parts are all just public so the

00:28:27,570 --> 00:28:31,889
CAS don't want to risk the exposure of

00:28:30,330 --> 00:28:33,809
actually having stuff interact directly

00:28:31,889 --> 00:28:35,460
with their root certificates and so what

00:28:33,809 --> 00:28:37,049
they do instead is they use these extra

00:28:35,460 --> 00:28:39,029
things called intermediate certificates

00:28:37,049 --> 00:28:42,749
I know that an intermediate certificate

00:28:39,029 --> 00:28:46,649
is it is a another certificate that has

00:28:42,749 --> 00:28:48,720
been signed by the root itself and give

00:28:46,649 --> 00:28:50,399
and contains an additional authority

00:28:48,720 --> 00:28:52,379
that says you're allowed to use this key

00:28:50,399 --> 00:28:55,320
for signing other keys so for other

00:28:52,379 --> 00:28:58,169
certificates so then the site

00:28:55,320 --> 00:28:59,909
certificate is signed by the

00:28:58,169 --> 00:29:01,409
intermediate and this is why if when you

00:28:59,909 --> 00:29:03,779
go and get a certificate it typically

00:29:01,409 --> 00:29:05,879
has two files or three files you've got

00:29:03,779 --> 00:29:07,860
your private key there's the public

00:29:05,879 --> 00:29:09,299
certificate for your own domain and then

00:29:07,860 --> 00:29:12,450
you'll usually get another one as well

00:29:09,299 --> 00:29:15,059
which is belonging to whoever your CA is

00:29:12,450 --> 00:29:17,549
and then in turn that intermediate

00:29:15,059 --> 00:29:19,559
certificate is signed by the root

00:29:17,549 --> 00:29:21,360
certificate that the user already has in

00:29:19,559 --> 00:29:24,179
their browser so this establishes the

00:29:21,360 --> 00:29:25,769
chain of trust between these things and

00:29:24,179 --> 00:29:27,779
that so effectively the root certificate

00:29:25,769 --> 00:29:30,240
is vouching for the intermediate which

00:29:27,779 --> 00:29:31,830
is vouching for your site now it's

00:29:30,240 --> 00:29:33,299
possible for an intermediate to actually

00:29:31,830 --> 00:29:35,070
be signed by more than one root

00:29:33,299 --> 00:29:37,230
certificate and the reason for doing

00:29:35,070 --> 00:29:39,480
that is that it can be difficult to

00:29:37,230 --> 00:29:41,789
change this list of root certificates

00:29:39,480 --> 00:29:43,289
you know it takes time to get these

00:29:41,789 --> 00:29:46,860
things distributed into operating

00:29:43,289 --> 00:29:48,330
systems and let's encrypt had exactly

00:29:46,860 --> 00:29:50,789
this problem when they were trying to

00:29:48,330 --> 00:29:52,409
get themselves established as a CA and

00:29:50,789 --> 00:29:55,249
they were actually signed or what is

00:29:52,409 --> 00:29:57,659
what's called cross signed by two root

00:29:55,249 --> 00:30:01,169
certificates from two different other

00:29:57,659 --> 00:30:03,210
CAS until they can get into a situation

00:30:01,169 --> 00:30:05,369
where they can actually become a CA

00:30:03,210 --> 00:30:07,110
properly themselves and that's now

00:30:05,369 --> 00:30:08,820
happened but in the early days of let's

00:30:07,110 --> 00:30:09,770
encrypt they were cross signed in this

00:30:08,820 --> 00:30:11,929
way

00:30:09,770 --> 00:30:13,460
so long as that meant that so long as

00:30:11,929 --> 00:30:19,460
the client had one of these two

00:30:13,460 --> 00:30:21,890
certificates it would work so one we've

00:30:19,460 --> 00:30:24,320
deployed our certificate on to our

00:30:21,890 --> 00:30:26,600
server and the client connects to us say

00:30:24,320 --> 00:30:29,510
something so say our certificate lasts

00:30:26,600 --> 00:30:31,970
two years it's expiry set for two years

00:30:29,510 --> 00:30:35,990
in the future say something happens like

00:30:31,970 --> 00:30:37,730
the CA gets hacked and their private

00:30:35,990 --> 00:30:40,730
keys exposed you get your server hacked

00:30:37,730 --> 00:30:42,800
and your private key exposed it will be

00:30:40,730 --> 00:30:44,690
useful if there is a way of telling or

00:30:42,800 --> 00:30:46,190
assuring the client or telling the

00:30:44,690 --> 00:30:47,809
client that that certificate should no

00:30:46,190 --> 00:30:49,400
longer be trusted so if your for example

00:30:47,809 --> 00:30:51,320
if your certificate is stolen and

00:30:49,400 --> 00:30:53,480
deployed by some hacker on some other

00:30:51,320 --> 00:30:55,760
search server you want to be able to

00:30:53,480 --> 00:30:56,990
stop them from doing that and the way

00:30:55,760 --> 00:30:58,370
that you would do that is you would tell

00:30:56,990 --> 00:31:01,190
your CA and they would revoke that

00:30:58,370 --> 00:31:05,290
certificate but then the problem is how

00:31:01,190 --> 00:31:09,429
does the client find out about this well

00:31:05,290 --> 00:31:11,240
what it has to do is go and ask the CA

00:31:09,429 --> 00:31:13,940
but you can imagine that there's a

00:31:11,240 --> 00:31:15,740
problem here if every time you connect

00:31:13,940 --> 00:31:19,370
to a website you also have to connect to

00:31:15,740 --> 00:31:21,110
the CAS website that's a massive amount

00:31:19,370 --> 00:31:22,670
of overhead for your own site but it's

00:31:21,110 --> 00:31:25,550
completely overwhelming amounts of

00:31:22,670 --> 00:31:28,790
traffic for the CA so that's not really

00:31:25,550 --> 00:31:30,890
sustainable the way that they look

00:31:28,790 --> 00:31:35,170
things up is this protocol called

00:31:30,890 --> 00:31:37,550
online certificate status or OCSP and

00:31:35,170 --> 00:31:40,010
that specifically checks the state of

00:31:37,550 --> 00:31:42,559
your certificate with your CA but it

00:31:40,010 --> 00:31:45,800
adds that overhead but what you can do

00:31:42,559 --> 00:31:48,110
is a neat trick called OCSP stapling and

00:31:45,800 --> 00:31:49,610
the idea here is that when you start

00:31:48,110 --> 00:31:51,740
your web when you restart your web

00:31:49,610 --> 00:31:56,090
server and you've deployed a bunch of

00:31:51,740 --> 00:31:58,250
new keys you can go and get the OCSP

00:31:56,090 --> 00:32:00,470
response from your CA directly and you

00:31:58,250 --> 00:32:02,360
do it for your site on your server and

00:32:00,470 --> 00:32:04,910
you might think well surely that means

00:32:02,360 --> 00:32:07,340
that you can just lie what you can't

00:32:04,910 --> 00:32:09,440
because that response the OCSP response

00:32:07,340 --> 00:32:12,320
from your CA is signed by them and you

00:32:09,440 --> 00:32:14,750
can't fake that so it means there's no

00:32:12,320 --> 00:32:16,520
harm in doing that these OCSP responses

00:32:14,750 --> 00:32:18,690
are typically short-lived maybe a few

00:32:16,520 --> 00:32:21,810
days to a couple of weeks

00:32:18,690 --> 00:32:23,910
before they expire and so you don't need

00:32:21,810 --> 00:32:25,290
to root to renew them very often but

00:32:23,910 --> 00:32:27,090
your web server will just take care of

00:32:25,290 --> 00:32:28,620
that for you and Apache and nginx have

00:32:27,090 --> 00:32:30,090
all this just built in you just need to

00:32:28,620 --> 00:32:31,920
tell it to use it and it will go and use

00:32:30,090 --> 00:32:33,950
it and that what that means is that when

00:32:31,920 --> 00:32:37,710
you do that TLS handshake it includes

00:32:33,950 --> 00:32:39,660
the OCSP extension in TS TLS that

00:32:37,710 --> 00:32:41,310
provides that additional reassurance and

00:32:39,660 --> 00:32:43,320
that means that the client can be sure

00:32:41,310 --> 00:32:45,210
that the certificate they're seeing

00:32:43,320 --> 00:32:47,340
hasn't been stolen hasn't been revoked

00:32:45,210 --> 00:32:52,920
and I still is still something that they

00:32:47,340 --> 00:32:55,860
can trust so you need to get this

00:32:52,920 --> 00:32:58,110
certificate from your CA one of the

00:32:55,860 --> 00:33:00,030
things that has largely gone away

00:32:58,110 --> 00:33:04,410
thankfully is that they have these

00:33:00,030 --> 00:33:06,150
different validation levels DV o V and

00:33:04,410 --> 00:33:08,340
Evie and these stand for domain

00:33:06,150 --> 00:33:11,880
validated organization validated and

00:33:08,340 --> 00:33:14,270
extended validation and the Evie thing

00:33:11,880 --> 00:33:19,680
is what gave use gave us these green

00:33:14,270 --> 00:33:22,380
titles in your address bar now the idea

00:33:19,680 --> 00:33:24,710
behind it was that a CA needs to

00:33:22,380 --> 00:33:27,000
establish not only that they've

00:33:24,710 --> 00:33:29,460
technically signed your thing but do you

00:33:27,000 --> 00:33:31,890
are that you really are who you say you

00:33:29,460 --> 00:33:35,700
are and so they often require extensive

00:33:31,890 --> 00:33:38,280
paperwork and record searches and often

00:33:35,700 --> 00:33:40,200
signed letters from lawyers and judges

00:33:38,280 --> 00:33:41,820
and doctors and things like that in

00:33:40,200 --> 00:33:43,500
order to establish and prove that you

00:33:41,820 --> 00:33:45,030
really do own this company and that

00:33:43,500 --> 00:33:47,430
company really is the owner of this

00:33:45,030 --> 00:33:50,070
domain however they kind of undermined

00:33:47,430 --> 00:33:52,920
themselves that by charging more for

00:33:50,070 --> 00:33:54,270
this service but then actually reducing

00:33:52,920 --> 00:33:55,530
the amount of checking that they really

00:33:54,270 --> 00:33:58,320
did so they were increasing their

00:33:55,530 --> 00:34:00,210
margins but lowering their quality it

00:33:58,320 --> 00:34:02,640
ended up getting to the point where it

00:34:00,210 --> 00:34:04,200
really actually wasn't worth it and the

00:34:02,640 --> 00:34:05,820
other thing is that despite these green

00:34:04,200 --> 00:34:07,920
things in the address bar

00:34:05,820 --> 00:34:10,350
they found that users just ignored it

00:34:07,920 --> 00:34:12,630
they really didn't care as long as it

00:34:10,350 --> 00:34:14,970
had a little peddler they were happy and

00:34:12,630 --> 00:34:17,580
so now the messaging in most browsers

00:34:14,970 --> 00:34:19,770
has switched and now it will just warn

00:34:17,580 --> 00:34:21,419
you if stuff is not secure and doesn't

00:34:19,770 --> 00:34:23,310
really care how you've secured it

00:34:21,419 --> 00:34:25,140
because no matter which of these

00:34:23,310 --> 00:34:26,940
validation levels you've chosen the

00:34:25,140 --> 00:34:28,770
actual encryption that it uses is

00:34:26,940 --> 00:34:30,270
absolutely identical there's no

00:34:28,770 --> 00:34:30,919
difference in the encryption apply it up

00:34:30,270 --> 00:34:33,859
with the DVC

00:34:30,919 --> 00:34:34,429
difficut versus an Eevee certificate so

00:34:33,859 --> 00:34:36,639
they see

00:34:34,429 --> 00:34:39,049
don't bother with Eevee DV is just fine

00:34:36,639 --> 00:34:40,220
with domain validation the only thing

00:34:39,049 --> 00:34:42,020
you have to do is prove that you

00:34:40,220 --> 00:34:44,869
technically earn the domain and that's

00:34:42,020 --> 00:34:48,319
typically done by being able to serve a

00:34:44,869 --> 00:34:49,760
a carefully formed HTTP response when

00:34:48,319 --> 00:34:51,980
someone makes a request to that domain

00:34:49,760 --> 00:34:54,349
or for example putting something in your

00:34:51,980 --> 00:34:56,950
DNS so essentially if you're in a

00:34:54,349 --> 00:34:59,930
position where you can place content in

00:34:56,950 --> 00:35:01,339
specific pre identified places on your

00:34:59,930 --> 00:35:03,740
web server or that you can alter your

00:35:01,339 --> 00:35:04,700
DNS they go yeah you've got to be the

00:35:03,740 --> 00:35:09,290
owner because otherwise you wouldn't be

00:35:04,700 --> 00:35:12,380
able to do that inside your certificate

00:35:09,290 --> 00:35:17,450
you can have some extra features that

00:35:12,380 --> 00:35:18,859
work nicely together one of the

00:35:17,450 --> 00:35:21,250
extensions for TLS is this thing called

00:35:18,859 --> 00:35:23,059
SNI which is server name identification

00:35:21,250 --> 00:35:27,020
one of the problems with the early

00:35:23,059 --> 00:35:28,910
versions of TLS is that you the during

00:35:27,020 --> 00:35:31,520
the TLS connection it didn't actually

00:35:28,910 --> 00:35:33,980
know the host name so it did all of

00:35:31,520 --> 00:35:35,839
these these exchanges without actually

00:35:33,980 --> 00:35:37,099
any knowledge of the host name so you

00:35:35,839 --> 00:35:40,579
might find that you do the TLS

00:35:37,099 --> 00:35:41,839
connection and if you had multiple

00:35:40,579 --> 00:35:45,410
certificates then it might pick the

00:35:41,839 --> 00:35:47,270
wrong one and you wouldn't get a valid

00:35:45,410 --> 00:35:48,589
result when you tried to to check that

00:35:47,270 --> 00:35:51,049
it was actually the domain that you were

00:35:48,589 --> 00:35:52,309
trying to talk to so for a long time

00:35:51,049 --> 00:35:55,400
there was a limitation that you could

00:35:52,309 --> 00:35:57,680
only have one dn't one encrypted domain

00:35:55,400 --> 00:35:59,020
per IP address and that's really quite

00:35:57,680 --> 00:36:03,650
limiting especially in the days of

00:35:59,020 --> 00:36:06,950
dwindling IP version 4 addresses so sni

00:36:03,650 --> 00:36:09,079
allows the host the host name the domain

00:36:06,950 --> 00:36:11,030
name to be embedded actually down within

00:36:09,079 --> 00:36:12,410
the TLS connection itself and that means

00:36:11,030 --> 00:36:15,170
that the server can then pick the

00:36:12,410 --> 00:36:16,880
correct certificate to deliver the

00:36:15,170 --> 00:36:19,130
response with and that way you can have

00:36:16,880 --> 00:36:22,900
as many domains as you like and as many

00:36:19,130 --> 00:36:25,069
certificates as you like all on one IP

00:36:22,900 --> 00:36:26,990
this also goes nicely with this other

00:36:25,069 --> 00:36:30,349
feature called San which is server

00:36:26,990 --> 00:36:31,880
alternate name now when you generate the

00:36:30,349 --> 00:36:33,500
CSR the certificate signing request

00:36:31,880 --> 00:36:34,910
which how you better go about getting

00:36:33,500 --> 00:36:37,220
the domain in the first place and you

00:36:34,910 --> 00:36:39,020
specify the domain that it's for but

00:36:37,220 --> 00:36:41,210
it's possible to put multiple names in

00:36:39,020 --> 00:36:42,950
the same certificate and the most the

00:36:41,210 --> 00:36:44,780
most common combination of that is to

00:36:42,950 --> 00:36:47,870
have say example.com

00:36:44,780 --> 00:36:49,250
and WWE example calm there's actually

00:36:47,870 --> 00:36:51,410
two separate names within the same

00:36:49,250 --> 00:36:52,760
certificate because otherwise you have

00:36:51,410 --> 00:36:55,010
you'll have problems you end up having

00:36:52,760 --> 00:36:57,350
to redirect people only using an

00:36:55,010 --> 00:36:58,700
insecure connection and or you'll get

00:36:57,350 --> 00:37:01,040
errors because they've gone to the

00:36:58,700 --> 00:37:02,540
domain without the www on the front or

00:37:01,040 --> 00:37:04,250
whichever way around you chose to do it

00:37:02,540 --> 00:37:05,900
so there can be problems with that so

00:37:04,250 --> 00:37:07,880
sound solves that completely you can

00:37:05,900 --> 00:37:09,050
actually just have long lists I'm not

00:37:07,880 --> 00:37:12,020
really sure what the limit is but I've

00:37:09,050 --> 00:37:16,550
seen I think at least thousands of names

00:37:12,020 --> 00:37:19,820
in a single certificate so that's a

00:37:16,550 --> 00:37:22,790
useful feature to have as well you can

00:37:19,820 --> 00:37:25,460
also use wildcards and this has another

00:37:22,790 --> 00:37:28,100
one of these little Trinity things this

00:37:25,460 --> 00:37:32,720
will match anything any do any string

00:37:28,100 --> 00:37:35,360
that's a valid host name dot your domain

00:37:32,720 --> 00:37:37,220
name and you only have one certificate

00:37:35,360 --> 00:37:39,920
and it will vouch for all of them and

00:37:37,220 --> 00:37:42,440
this goes really nicely with wildcards

00:37:39,920 --> 00:37:44,480
in DNS and wildcards in virtual host

00:37:42,440 --> 00:37:47,390
definitions it means that you can have

00:37:44,480 --> 00:37:49,430
dynamic host names that change all the

00:37:47,390 --> 00:37:52,310
time without having to touch any of your

00:37:49,430 --> 00:37:58,190
TLS your dns all your web server config

00:37:52,310 --> 00:37:59,680
it's a really great combination then

00:37:58,190 --> 00:38:02,090
back to the validation thing it again

00:37:59,680 --> 00:38:04,700
issuing certificates from a technical

00:38:02,090 --> 00:38:06,710
point of view is completely trivial to

00:38:04,700 --> 00:38:08,630
sign a csr if you've got the root

00:38:06,710 --> 00:38:11,240
certificate private key right there is

00:38:08,630 --> 00:38:13,730
literally a one line command in open SSL

00:38:11,240 --> 00:38:15,620
that takes a second it's a completely

00:38:13,730 --> 00:38:17,150
trivial thing to do technically but

00:38:15,620 --> 00:38:20,060
administrative Lee certainly

00:38:17,150 --> 00:38:22,970
historically that's actually been the

00:38:20,060 --> 00:38:26,450
big problem and yet most certificate

00:38:22,970 --> 00:38:28,400
authorities actually based their pricing

00:38:26,450 --> 00:38:30,170
on the technical bit rather than the

00:38:28,400 --> 00:38:32,900
administrative bit which is really not

00:38:30,170 --> 00:38:35,180
very clever start com which is the same

00:38:32,900 --> 00:38:38,480
CA that got dropped from all the

00:38:35,180 --> 00:38:39,800
browser's actually was the only one I've

00:38:38,480 --> 00:38:43,400
ever seen which price things the other

00:38:39,800 --> 00:38:45,770
way around they charged for validation

00:38:43,400 --> 00:38:47,360
but not certificates so once you disturb

00:38:45,770 --> 00:38:49,130
lished who you were you could then have

00:38:47,360 --> 00:38:50,960
as many certificates as you like for no

00:38:49,130 --> 00:38:51,890
additional cost because they're

00:38:50,960 --> 00:38:54,740
automatable

00:38:51,890 --> 00:38:57,940
and and trivial to generate but

00:38:54,740 --> 00:39:01,510
unfortunately they don't exist anymore

00:38:57,940 --> 00:39:04,760
and now all of this overhead was really

00:39:01,510 --> 00:39:07,040
simplified a lot with let's encrypt and

00:39:04,760 --> 00:39:09,980
let's encrypt I probably heard of it

00:39:07,040 --> 00:39:12,410
it's a free Ca they will issue

00:39:09,980 --> 00:39:14,720
certificates free of charge no cost at

00:39:12,410 --> 00:39:15,800
all it's mainly backed by mozilla but

00:39:14,720 --> 00:39:19,190
there's a whole bunch of other companies

00:39:15,800 --> 00:39:21,740
behind it as well and not only are there

00:39:19,190 --> 00:39:23,540
free Ca but they also establish this

00:39:21,740 --> 00:39:26,150
thing called the Acme protocol which is

00:39:23,540 --> 00:39:28,100
a specification the standard for how to

00:39:26,150 --> 00:39:29,990
go about obtaining and renewing

00:39:28,100 --> 00:39:32,420
certificates and that just allows you to

00:39:29,990 --> 00:39:35,660
automate the whole thing now because of

00:39:32,420 --> 00:39:38,930
this there's another security bonus is

00:39:35,660 --> 00:39:41,030
that they're their certificates only

00:39:38,930 --> 00:39:43,790
lasts for 90 days three months so

00:39:41,030 --> 00:39:45,230
they're quite short-lived but that's not

00:39:43,790 --> 00:39:47,420
a problem because they're made renewing

00:39:45,230 --> 00:39:48,980
them so easy it's really quite

00:39:47,420 --> 00:39:50,690
straightforward you you essentially set

00:39:48,980 --> 00:39:52,670
up the renewal process as part of the

00:39:50,690 --> 00:39:54,260
obtaining the the original certificate

00:39:52,670 --> 00:39:56,300
and you just set up a cron script that

00:39:54,260 --> 00:39:57,650
runs every day and it just goes and

00:39:56,300 --> 00:39:59,240
renews all your certificates when they

00:39:57,650 --> 00:40:00,770
need renewing and you can more or less

00:39:59,240 --> 00:40:04,160
forget about it from that point onwards

00:40:00,770 --> 00:40:06,110
the old way of doing this was to have

00:40:04,160 --> 00:40:09,700
certificates that had long expiry times

00:40:06,110 --> 00:40:12,320
and this came up I think just last year

00:40:09,700 --> 00:40:15,910
this was a really good example of the

00:40:12,320 --> 00:40:18,590
problem of not making renewals easy

00:40:15,910 --> 00:40:21,560
Ericsson makes lots of telecom grade

00:40:18,590 --> 00:40:26,150
hardware that power lots of mobile phone

00:40:21,560 --> 00:40:28,490
networks and 10 years ago they installed

00:40:26,150 --> 00:40:30,260
a whole bunch of things for multiple

00:40:28,490 --> 00:40:33,380
networks around Europe but largely in

00:40:30,260 --> 00:40:35,480
the UK and on there because they didn't

00:40:33,380 --> 00:40:36,860
want to address this need for renewing

00:40:35,480 --> 00:40:38,720
certificates they used the TLS

00:40:36,860 --> 00:40:41,540
certificate that had a 10-year expiry

00:40:38,720 --> 00:40:44,060
time so it was good for ten years and

00:40:41,540 --> 00:40:48,020
this hardware was installed throughout

00:40:44,060 --> 00:40:54,260
Vodafone's network in the UK and all of

00:40:48,020 --> 00:40:57,050
these boxes failed at the same second it

00:40:54,260 --> 00:40:59,630
literally took down the entire Vodafone

00:40:57,050 --> 00:41:01,470
mobile phone network in the UK for about

00:40:59,630 --> 00:41:04,200
half a day

00:41:01,470 --> 00:41:05,760
that's it it took out I think bits of

00:41:04,200 --> 00:41:08,160
Denmark as well it was it was pretty

00:41:05,760 --> 00:41:12,119
far-reaching it was a very big outage

00:41:08,160 --> 00:41:16,020
and that was caused by an unrealistic

00:41:12,119 --> 00:41:16,980
--it so make it easy to do this now

00:41:16,020 --> 00:41:20,579
there's a lot little thing I mentioned

00:41:16,980 --> 00:41:22,170
here cert bots get me protocol they say

00:41:20,579 --> 00:41:23,970
it's a specification as standard and

00:41:22,170 --> 00:41:26,970
people can then write implementations

00:41:23,970 --> 00:41:29,069
for it and the cert bot it's a little

00:41:26,970 --> 00:41:30,690
command line application that implements

00:41:29,069 --> 00:41:33,960
the Acme protocol and is the official

00:41:30,690 --> 00:41:35,460
app to use for let's encrypt but there

00:41:33,960 --> 00:41:37,410
are plenty of other implementations of

00:41:35,460 --> 00:41:39,569
this protocol as well there's one that I

00:41:37,410 --> 00:41:42,119
really like called Acme dot SH which is

00:41:39,569 --> 00:41:43,680
actually also their domain name and

00:41:42,119 --> 00:41:45,900
that's a complete self-contained bash

00:41:43,680 --> 00:41:47,819
script with no dependencies so it's

00:41:45,900 --> 00:41:49,740
really easy to deploy and very easy to

00:41:47,819 --> 00:41:52,500
run and I find it's a little bit easier

00:41:49,740 --> 00:41:56,609
to work with insert bot but sir what's

00:41:52,500 --> 00:42:00,300
fine they're both excellent so if you're

00:41:56,609 --> 00:42:01,619
deploying an application using TLS how

00:42:00,300 --> 00:42:03,569
should you go about this what are the

00:42:01,619 --> 00:42:05,730
things that you should aim for well the

00:42:03,569 --> 00:42:07,710
most fundamental thing really is use TLS

00:42:05,730 --> 00:42:09,240
by default it really keeps things much

00:42:07,710 --> 00:42:12,900
simpler there's no ambiguity just

00:42:09,240 --> 00:42:15,540
encrypt all the things don't use

00:42:12,900 --> 00:42:19,619
protocol relative URLs these are URLs

00:42:15,540 --> 00:42:22,260
that start with a double slash they were

00:42:19,619 --> 00:42:24,089
kind of a budge for when people had lots

00:42:22,260 --> 00:42:26,640
of mixed-mode things or where they had a

00:42:24,089 --> 00:42:30,569
site that could be accessed either with

00:42:26,640 --> 00:42:32,460
HTTPS or HTTP while avoiding these

00:42:30,569 --> 00:42:34,440
errors what are called mixed mode errors

00:42:32,460 --> 00:42:37,230
so say for example you load an HTML page

00:42:34,440 --> 00:42:40,650
over HTTP but the images within it are

00:42:37,230 --> 00:42:41,940
loaded from an HTTP site now lots of

00:42:40,650 --> 00:42:43,530
browsers used to let you get away with

00:42:41,940 --> 00:42:45,630
that but now it's quite likely they'll

00:42:43,530 --> 00:42:49,920
either not work at all all they'll spew

00:42:45,630 --> 00:42:52,109
errors that the user now if the results

00:42:49,920 --> 00:42:54,329
that you're loading isn't available over

00:42:52,109 --> 00:42:56,490
HTTPS then you can kind of work around

00:42:54,329 --> 00:42:59,930
that by creating proxies which you can

00:42:56,490 --> 00:43:01,890
do in PHP just with a one-line script

00:42:59,930 --> 00:43:04,410
you should also make sure that your

00:43:01,890 --> 00:43:06,119
cookies have the secure only flag set on

00:43:04,410 --> 00:43:08,910
them and that means it's especially

00:43:06,119 --> 00:43:11,880
important for session cookies so our

00:43:08,910 --> 00:43:12,960
session identifier tokens JWT tokens and

00:43:11,880 --> 00:43:14,589
so on you want to make sure that these

00:43:12,960 --> 00:43:19,900
things are not exposed over

00:43:14,589 --> 00:43:21,910
encrypted connections now we described a

00:43:19,900 --> 00:43:23,140
lot of moving parts here so how do you

00:43:21,910 --> 00:43:25,019
go about configuring a server to

00:43:23,140 --> 00:43:26,769
actually use these

00:43:25,019 --> 00:43:28,749
fortunately lots of people have done

00:43:26,769 --> 00:43:33,609
this before and Mozilla put together

00:43:28,749 --> 00:43:36,339
this nice little utility which builds

00:43:33,609 --> 00:43:37,839
TLS configs for popular web servers so

00:43:36,339 --> 00:43:39,549
you go there and you just select which

00:43:37,839 --> 00:43:42,549
kind of web server you're using which

00:43:39,549 --> 00:43:45,910
TLS library you're using and what kind

00:43:42,549 --> 00:43:47,950
of target audience you're aiming at you

00:43:45,910 --> 00:43:52,059
need to make sure you redirect all

00:43:47,950 --> 00:43:54,969
requests to unsecured URLs to the secure

00:43:52,059 --> 00:43:58,299
versions use sni to host multiple

00:43:54,969 --> 00:44:00,219
domains on one IP create your own set of

00:43:58,299 --> 00:44:02,499
diffie-hellman parameters for the

00:44:00,219 --> 00:44:04,029
forward secrecy thing now that's

00:44:02,499 --> 00:44:06,279
something that can take a really long

00:44:04,029 --> 00:44:07,749
time on a slow server just so you want

00:44:06,279 --> 00:44:12,390
but you only need to do it once or maybe

00:44:07,749 --> 00:44:15,849
annually use at least TLS 1.2 if you can

00:44:12,390 --> 00:44:19,210
and disable any old or weak ciphers even

00:44:15,849 --> 00:44:22,660
within TLS 1.2 make sure you enable TLS

00:44:19,210 --> 00:44:26,559
session caching and setup OCSP stapling

00:44:22,660 --> 00:44:28,630
for your root certificates beyond those

00:44:26,559 --> 00:44:30,999
things there are a bunch of other things

00:44:28,630 --> 00:44:32,859
that you can do to improve security you

00:44:30,999 --> 00:44:35,859
can add this HTTP strict Transport

00:44:32,859 --> 00:44:37,660
Security header known as HSTs which is a

00:44:35,859 --> 00:44:39,759
way of telling your clients we always

00:44:37,660 --> 00:44:41,559
encrypt so if you've set this header on

00:44:39,759 --> 00:44:45,759
your home page which is delivered over

00:44:41,559 --> 00:44:48,430
HTTP and they see an image in the same

00:44:45,759 --> 00:44:50,440
domain but that's not from a secure

00:44:48,430 --> 00:44:51,880
version of the URL it will ignore the

00:44:50,440 --> 00:44:53,920
fact that it's not a secure one and

00:44:51,880 --> 00:44:56,650
actually just upgrade it automatically

00:44:53,920 --> 00:44:59,950
on the client side so that's that's a

00:44:56,650 --> 00:45:01,809
handy bonus now one of things about HSTs

00:44:59,950 --> 00:45:03,670
is that you can actually submit your

00:45:01,809 --> 00:45:06,099
domain to what's called a preload list

00:45:03,670 --> 00:45:09,069
which mean that which is then used in

00:45:06,099 --> 00:45:11,109
the builds of modern browsers and it

00:45:09,069 --> 00:45:13,210
then means that if your domain is in

00:45:11,109 --> 00:45:15,249
there and the browser knows about it

00:45:13,210 --> 00:45:17,140
before it's ever visited your site it

00:45:15,249 --> 00:45:18,940
means that it will never ever make an

00:45:17,140 --> 00:45:21,219
unencrypted request to your site and

00:45:18,940 --> 00:45:23,670
this avoids the problem known as trust

00:45:21,219 --> 00:45:27,630
on first use which is what

00:45:23,670 --> 00:45:29,940
if you don't have that pre-loading you

00:45:27,630 --> 00:45:31,829
can also add things in your DNS I think

00:45:29,940 --> 00:45:33,599
all of CIA record a certificate

00:45:31,829 --> 00:45:36,630
authority authorization bit of a

00:45:33,599 --> 00:45:38,400
mouthful and essentially this says only

00:45:36,630 --> 00:45:40,559
these CAS are allowed to issue

00:45:38,400 --> 00:45:41,880
certificates for this domain so if

00:45:40,559 --> 00:45:44,940
you're using let's encrypt you might

00:45:41,880 --> 00:45:47,760
have say comodo or something or or

00:45:44,940 --> 00:45:50,430
Verisign and you just list the CAS that

00:45:47,760 --> 00:45:52,349
you are intending to use so it's it's a

00:45:50,430 --> 00:45:53,549
you need your current one and any new

00:45:52,349 --> 00:45:55,170
one now these records are actually

00:45:53,549 --> 00:45:57,030
checked by the CAS themselves if

00:45:55,170 --> 00:45:58,740
somebody makes a request to issue a

00:45:57,030 --> 00:46:00,809
certificate for your domain they go and

00:45:58,740 --> 00:46:02,640
check in your DNS to see if they're on

00:46:00,809 --> 00:46:07,309
the allowed list otherwise they will

00:46:02,640 --> 00:46:10,380
deny the request content security policy

00:46:07,309 --> 00:46:12,869
this is there are there are whole talks

00:46:10,380 --> 00:46:14,790
on this header it's really big and

00:46:12,869 --> 00:46:17,010
really complicated but essentially is a

00:46:14,790 --> 00:46:19,470
way of saying I only want to load these

00:46:17,010 --> 00:46:21,420
types of media from these locations so

00:46:19,470 --> 00:46:23,579
you can list the sources of your your

00:46:21,420 --> 00:46:27,359
scripts the sources of your your Styles

00:46:23,579 --> 00:46:30,809
your images your media content whatever

00:46:27,359 --> 00:46:32,849
it is your your fonts and that's

00:46:30,809 --> 00:46:34,410
particularly useful as a defense against

00:46:32,849 --> 00:46:38,400
things like cross-site scripting attacks

00:46:34,410 --> 00:46:43,170
where you can prevent loading from from

00:46:38,400 --> 00:46:45,599
bad sites if you do TLS right it means

00:46:43,170 --> 00:46:49,680
that you get to use HTTP 2 which gives a

00:46:45,599 --> 00:46:51,030
big payoff there's an RFC for it if

00:46:49,680 --> 00:46:52,410
you're going to actually use it there's

00:46:51,030 --> 00:46:55,109
a whole load of additional constraints

00:46:52,410 --> 00:46:58,710
you've got to support TLS 1.2 you've got

00:46:55,109 --> 00:47:00,660
to support SNI you must do PFS you've

00:46:58,710 --> 00:47:02,609
got to have at least 2048 bit

00:47:00,660 --> 00:47:04,619
diffie-hellman parameters you've got to

00:47:02,609 --> 00:47:06,540
disable compression and renegotiation

00:47:04,619 --> 00:47:07,770
extensions in TLS which is something

00:47:06,540 --> 00:47:09,420
that used to be in old versions but

00:47:07,770 --> 00:47:11,220
people found security problems and

00:47:09,420 --> 00:47:13,589
you're better off actually letting HTTP

00:47:11,220 --> 00:47:14,819
to deal with that compression and that

00:47:13,589 --> 00:47:17,040
you must sign your certificates with

00:47:14,819 --> 00:47:19,349
sha-2 if you do all those things you can

00:47:17,040 --> 00:47:22,430
just enable HTTP 2 on your web server

00:47:19,349 --> 00:47:22,430
and it will just work

00:47:23,250 --> 00:47:26,820
once you've done all this you want to

00:47:24,780 --> 00:47:28,200
test it make sure it works but the

00:47:26,820 --> 00:47:30,390
easiest thing to do is in your browser

00:47:28,200 --> 00:47:31,710
when you visited the the site it'll have

00:47:30,390 --> 00:47:33,630
a little padlock in your address bar

00:47:31,710 --> 00:47:35,280
click it and it'll tell you all about

00:47:33,630 --> 00:47:37,410
the certificate that's that's been

00:47:35,280 --> 00:47:39,450
presented whether it's valid when it

00:47:37,410 --> 00:47:41,369
expires who signed it what kind of

00:47:39,450 --> 00:47:42,869
constraints it has which domains it

00:47:41,369 --> 00:47:44,520
applies to you can see all of those

00:47:42,869 --> 00:47:46,440
things inside the certificate just in

00:47:44,520 --> 00:47:48,780
your browser and anybody can check that

00:47:46,440 --> 00:47:50,849
on a command line you can do more or

00:47:48,780 --> 00:47:54,060
less the same thing using the open SSL S

00:47:50,849 --> 00:47:55,680
client function allows you to extract

00:47:54,060 --> 00:47:59,940
certificates and so on that's quite a

00:47:55,680 --> 00:48:02,550
useful tool much more easy to use is the

00:47:59,940 --> 00:48:04,920
Qualis SSL labs tester and this is

00:48:02,550 --> 00:48:06,330
something you see pushed a lot and it's

00:48:04,920 --> 00:48:07,800
a really good way of submitting your

00:48:06,330 --> 00:48:10,020
sites to a whole bunch of different

00:48:07,800 --> 00:48:12,660
tests and it will flag any like for

00:48:10,020 --> 00:48:15,330
example if you if you've allowed broken

00:48:12,660 --> 00:48:19,440
ciphers or weak hash functions and so on

00:48:15,330 --> 00:48:21,240
it will tell you to get your domain into

00:48:19,440 --> 00:48:22,619
the preload list that's built into

00:48:21,240 --> 00:48:24,330
browsers you can just go and submit it

00:48:22,619 --> 00:48:25,800
to here and it will do some checks to

00:48:24,330 --> 00:48:27,750
make sure that you're really going to do

00:48:25,800 --> 00:48:29,430
that before that allows you in and there

00:48:27,750 --> 00:48:31,970
are a whole bunch of other places that

00:48:29,430 --> 00:48:34,950
you can use particularly the observatory

00:48:31,970 --> 00:48:36,690
test SSL that Sh is very much like the

00:48:34,950 --> 00:48:38,220
quality tester but it runs on a command

00:48:36,690 --> 00:48:40,200
line and you don't have to expose

00:48:38,220 --> 00:48:43,640
anything publicly in order to use it so

00:48:40,200 --> 00:48:43,640
that's very good for internal testing

00:48:43,940 --> 00:48:50,220
CSP the site to use is report URI calm

00:48:47,580 --> 00:48:52,710
and security headers calm really really

00:48:50,220 --> 00:48:55,650
just gives you an overview of more about

00:48:52,710 --> 00:48:58,170
the security headers in HTTP rather than

00:48:55,650 --> 00:48:59,820
anything further and if you do

00:48:58,170 --> 00:49:05,310
everything right you get these nice a

00:48:59,820 --> 00:49:07,130
plus grades so it's to finish up this is

00:49:05,310 --> 00:49:11,040
the difference that doing all this makes

00:49:07,130 --> 00:49:13,740
okay this is from webpagetest.org which

00:49:11,040 --> 00:49:18,780
does a speed performance analysis on web

00:49:13,740 --> 00:49:21,030
pages is really good now the first thing

00:49:18,780 --> 00:49:22,859
that happens here this first request

00:49:21,030 --> 00:49:24,900
Unitas it doesn't have a little padlock

00:49:22,859 --> 00:49:26,849
at the beginning it does an unencrypted

00:49:24,900 --> 00:49:28,830
request to the hostname so you can see

00:49:26,849 --> 00:49:30,570
there's the pink sections or TLS

00:49:28,830 --> 00:49:31,950
handshakes and there isn't a pink

00:49:30,570 --> 00:49:34,410
section here because it's an unencrypted

00:49:31,950 --> 00:49:36,069
one but we're getting a 301 response so

00:49:34,410 --> 00:49:38,569
it's a redirect

00:49:36,069 --> 00:49:41,449
so that's cost of 300 milliseconds

00:49:38,569 --> 00:49:42,859
before we even start doing anything then

00:49:41,449 --> 00:49:44,329
it makes the request for the home page

00:49:42,859 --> 00:49:45,949
where you can see it's got a TCP

00:49:44,329 --> 00:49:47,449
connection in orange and then it does

00:49:45,949 --> 00:49:49,279
the TLS handshake and then it delivers

00:49:47,449 --> 00:49:51,079
the HTML and then it has a following

00:49:49,279 --> 00:49:53,329
follow-on bunch of resources so we've

00:49:51,079 --> 00:49:55,819
got some CSS and JavaScript and each one

00:49:53,329 --> 00:49:57,890
of those does its own TCP connection and

00:49:55,819 --> 00:49:59,329
its own TLS handshake so if you add all

00:49:57,890 --> 00:50:01,519
put all those together that's really

00:49:59,329 --> 00:50:06,499
quite a lot of additional overhead this

00:50:01,519 --> 00:50:08,059
is also all TLS 1.2 once you've done all

00:50:06,499 --> 00:50:09,709
those ones on this site it then loads

00:50:08,059 --> 00:50:11,209
under a bunch of other resources from

00:50:09,709 --> 00:50:13,130
other domains and because there are the

00:50:11,209 --> 00:50:15,079
domains you also get hit by DNS lookups

00:50:13,130 --> 00:50:17,180
and then you get the whole TCP and TLS

00:50:15,079 --> 00:50:19,249
handshakes on top of that so all of

00:50:17,180 --> 00:50:21,199
these add up take quite a long time

00:50:19,249 --> 00:50:23,059
also notice the overall time that's

00:50:21,199 --> 00:50:27,170
about two seconds to load that home page

00:50:23,059 --> 00:50:28,130
which is not great and there are sites

00:50:27,170 --> 00:50:31,400
that are much worse than that but

00:50:28,130 --> 00:50:33,229
whatever so this is that this is or the

00:50:31,400 --> 00:50:36,619
other thing you can see here is this is

00:50:33,229 --> 00:50:39,499
HTTP prior to - and you can tell that

00:50:36,619 --> 00:50:42,199
because otherwise these connections here

00:50:39,499 --> 00:50:43,999
would not be using separate TLS and TCP

00:50:42,199 --> 00:50:46,549
connections one of the things about HTTP

00:50:43,999 --> 00:50:49,459
- is it multiplexes multiple connections

00:50:46,549 --> 00:50:50,749
and requests into a single connection so

00:50:49,459 --> 00:50:54,769
you don't have to establish all those

00:50:50,749 --> 00:50:57,380
extra connections when you do it right

00:50:54,769 --> 00:50:59,329
this is one of my sites you can see the

00:50:57,380 --> 00:51:02,660
first request is encrypted because we're

00:50:59,329 --> 00:51:05,239
in the preload list overall the whole

00:51:02,660 --> 00:51:07,519
timescale is a lot shorter or at 0.7 of

00:51:05,239 --> 00:51:08,930
a second to finish loading which

00:51:07,519 --> 00:51:11,329
actually means we actually finish

00:51:08,930 --> 00:51:15,349
loading before the other site delivered

00:51:11,329 --> 00:51:18,229
its first byte which is we like that so

00:51:15,349 --> 00:51:20,839
we've got our DNS lookup TCP connection

00:51:18,229 --> 00:51:22,729
and then notice that this little this

00:51:20,839 --> 00:51:26,079
little thing here that tiny little bit

00:51:22,729 --> 00:51:29,690
of time that's TLS 1.3 doing its thing

00:51:26,079 --> 00:51:33,440
also this site is delivered over ipv6

00:51:29,690 --> 00:51:34,819
only that's another feature that may or

00:51:33,440 --> 00:51:37,369
may not help performance I'm not quite

00:51:34,819 --> 00:51:40,160
sure and then you can also see that

00:51:37,369 --> 00:51:42,289
we've got no additional connections

00:51:40,160 --> 00:51:44,420
we've got no additional TCP connections

00:51:42,289 --> 00:51:46,039
nor do we have any additional TLS

00:51:44,420 --> 00:51:47,719
connections because everything's coming

00:51:46,039 --> 00:51:48,290
from the same domain so we have no

00:51:47,719 --> 00:51:50,900
addition

00:51:48,290 --> 00:51:53,270
connections to make and all of those

00:51:50,900 --> 00:51:54,829
things added up ends up giving us a site

00:51:53,270 --> 00:51:57,859
that's effectively at least three times

00:51:54,829 --> 00:51:59,059
faster and if you actually use the site

00:51:57,859 --> 00:52:01,280
you find that it's actually really

00:51:59,059 --> 00:52:03,819
snappy and flipping around it's really

00:52:01,280 --> 00:52:03,819
nice and fast

00:52:04,599 --> 00:52:11,510
so in summary TLS can be free of charge

00:52:08,500 --> 00:52:13,579
it's faster when you use it with HTTP

00:52:11,510 --> 00:52:17,660
two because HTTP do doesn't work without

00:52:13,579 --> 00:52:19,819
it use TLS everywhere by default you can

00:52:17,660 --> 00:52:21,430
take some simple measures to maximize

00:52:19,819 --> 00:52:24,079
security over the basics and

00:52:21,430 --> 00:52:29,109
fundamentally help Hansel and Gretel

00:52:24,079 --> 00:52:29,109
make it to your site safely thank you

00:52:30,100 --> 00:52:49,010
[Music]

00:52:45,740 --> 00:52:49,010

YouTube URL: https://www.youtube.com/watch?v=9RO-cFv5Lzs


