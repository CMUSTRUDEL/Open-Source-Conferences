Title: Getting started with PHP on AWS Lambda | Thomas Bley
Publication date: 2019-10-30
Playlist: International PHP Conference Spring 2019
Description: 
	Speaker: Thomas Bley (Bringmeister GmbH) | https://phpconference.com/speaker/thomas-bley/

This talk gives you a small introduction into AWS Lambda. You will learn how to get your PHP application running inside Lambda, including scaling, deployment and testing. The talk will also provide the best usage scenarios and explain how to calculate the costs for running the service inside AWS.

ðŸ¤— Come, join us at the next International PHP Conference | https://phpconference.com/
ðŸ‘ Like us on Facebook | https://www.facebook.com/ipc.germany/
ðŸ‘‰ Follow us on Twitter | https://twitter.com/phpconference
Captions: 
	00:00:01,540 --> 00:00:07,470
[Music]

00:00:04,370 --> 00:00:12,719
welcome everybody today I'm introducing

00:00:07,470 --> 00:00:15,900
a Douglas lambda for PHP and about me

00:00:12,719 --> 00:00:18,690
yeah I'm doing PHP for a long time

00:00:15,900 --> 00:00:21,720
I'm originally from unique I'm currently

00:00:18,690 --> 00:00:23,760
working at bling mass in Berlin and yeah

00:00:21,720 --> 00:00:27,180
we have a big online shop running with

00:00:23,760 --> 00:00:30,330
PHP and yeah as you see we deliver all

00:00:27,180 --> 00:00:33,510
kinds of food we have our own cars or

00:00:30,330 --> 00:00:36,390
drivers on logistics our own shop of

00:00:33,510 --> 00:00:40,050
course and yeah currently we're

00:00:36,390 --> 00:00:43,410
operating new technologies and yeah this

00:00:40,050 --> 00:00:44,879
where we came to AWS lambda so

00:00:43,410 --> 00:00:48,629
everybody's talking about lambda

00:00:44,879 --> 00:00:51,270
functions so in the end what are lambda

00:00:48,629 --> 00:00:53,719
functions so yeah

00:00:51,270 --> 00:00:57,480
first it's a special service from Amazon

00:00:53,719 --> 00:00:59,640
yeah it's a managed service its server

00:00:57,480 --> 00:01:02,210
less in the end so there are servers but

00:00:59,640 --> 00:01:06,060
you don't need to manage them in the end

00:01:02,210 --> 00:01:09,479
yeah aw is lambda is event-driven so

00:01:06,060 --> 00:01:13,049
normally when we use PHP fpm or Apache

00:01:09,479 --> 00:01:15,540
so normally be a request driven so AWS

00:01:13,049 --> 00:01:18,420
lambda is event driven events can be

00:01:15,540 --> 00:01:22,740
requests with a from a browser but can

00:01:18,420 --> 00:01:26,790
also be other events like new messages

00:01:22,740 --> 00:01:30,150
coming on a queue or yeah new new files

00:01:26,790 --> 00:01:34,229
arriving on s3 or maybe a few others we

00:01:30,150 --> 00:01:36,030
will see later yeah as we said the

00:01:34,229 --> 00:01:38,549
resources and the service are managed by

00:01:36,030 --> 00:01:41,759
Amazon so the great thing with AWS

00:01:38,549 --> 00:01:43,920
lambda is its scaling automatically so

00:01:41,759 --> 00:01:47,159
we don't need to do anything for this in

00:01:43,920 --> 00:01:49,530
the end and what's what's the real

00:01:47,159 --> 00:01:53,579
purpose of this and the purpose of this

00:01:49,530 --> 00:01:55,799
of course to build smaller code bases on

00:01:53,579 --> 00:01:57,780
demand applications so as we are

00:01:55,799 --> 00:02:00,270
event-driven our application is not

00:01:57,780 --> 00:02:03,000
always running it's only running when an

00:02:00,270 --> 00:02:05,219
event occurs and yeah it should be

00:02:03,000 --> 00:02:08,369
responsive to events so that means also

00:02:05,219 --> 00:02:11,760
for scaling we every time when we have

00:02:08,369 --> 00:02:15,060
an event so then yeah a new

00:02:11,760 --> 00:02:17,879
function is started in the end how does

00:02:15,060 --> 00:02:21,150
it work we all know probably contain us

00:02:17,879 --> 00:02:24,360
so Amazon invented a new technology for

00:02:21,150 --> 00:02:26,930
the virtual machine namely virtual

00:02:24,360 --> 00:02:29,730
machines are quite big and take some

00:02:26,930 --> 00:02:31,829
seconds or minutes to put so they

00:02:29,730 --> 00:02:34,860
developed a very small VM that can start

00:02:31,829 --> 00:02:38,849
in hundred milliseconds and yeah then

00:02:34,860 --> 00:02:40,950
can process the event and yeah since a

00:02:38,849 --> 00:02:46,700
few months now it's also available for

00:02:40,950 --> 00:02:51,150
PHP yeah so probably we might think we

00:02:46,700 --> 00:02:54,060
are going back now to CGI so as we heard

00:02:51,150 --> 00:02:57,389
is event-driven it started event occurs

00:02:54,060 --> 00:03:01,049
and then probably shut down and yeah

00:02:57,389 --> 00:03:05,280
it's a bit like CGI but it's also a bit

00:03:01,049 --> 00:03:07,829
more so yeah about the VM from Amazon as

00:03:05,280 --> 00:03:10,500
I already said it's a very special VM

00:03:07,829 --> 00:03:13,940
it's it's very lightweight only uses

00:03:10,500 --> 00:03:17,489
memory overheads of 5 megabytes of

00:03:13,940 --> 00:03:20,579
course it uses hardware utilization

00:03:17,489 --> 00:03:22,319
currently only Intel processors but we

00:03:20,579 --> 00:03:24,569
need to care because it's all inside

00:03:22,319 --> 00:03:26,639
Amazon and yeah it's designed for a

00:03:24,569 --> 00:03:29,819
short of workloads so you can quickly

00:03:26,639 --> 00:03:33,090
start and quickly destroy it it's name

00:03:29,819 --> 00:03:36,030
firecracker it's open source it's based

00:03:33,090 --> 00:03:37,980
on some technology from Google and they

00:03:36,030 --> 00:03:41,030
did a lot of changes for that and

00:03:37,980 --> 00:03:44,579
adapted it further for the cloud service

00:03:41,030 --> 00:03:47,040
yeah as that is the VM so it provides a

00:03:44,579 --> 00:03:50,310
very high isolation level higher than

00:03:47,040 --> 00:03:55,319
probably we have fro containers and it's

00:03:50,310 --> 00:03:58,319
based on on KBM and yeah it's it's very

00:03:55,319 --> 00:04:01,109
small very fast for example they have a

00:03:58,319 --> 00:04:04,560
keyboard driver that only emulates one

00:04:01,109 --> 00:04:07,319
key so yeah it has our own kernel of

00:04:04,560 --> 00:04:09,540
course but we don't need to manage the

00:04:07,319 --> 00:04:11,909
kernel so this is a good thing so we

00:04:09,540 --> 00:04:15,750
don't need to update any holes we don't

00:04:11,909 --> 00:04:17,989
need to update any kernels we don't need

00:04:15,750 --> 00:04:20,579
to build any containers so since we

00:04:17,989 --> 00:04:22,469
since the VM start automatically in the

00:04:20,579 --> 00:04:25,500
background so what we're in the end what

00:04:22,469 --> 00:04:28,950
we provide is just our PHP code

00:04:25,500 --> 00:04:32,400
and to run the PHP code we provide PHP

00:04:28,950 --> 00:04:34,650
itself as a binary so yeah so what we

00:04:32,400 --> 00:04:36,210
don't have as I said scaling

00:04:34,650 --> 00:04:39,540
automatically so we don't need to care

00:04:36,210 --> 00:04:41,610
about any load balancers or do any auto

00:04:39,540 --> 00:04:45,450
scaling that we normally have fun on

00:04:41,610 --> 00:04:49,200
Amazon for the deployment itself it's

00:04:45,450 --> 00:04:52,170
just uploading the the PHP code as a zip

00:04:49,200 --> 00:04:55,470
file and then it's it's life so we don't

00:04:52,170 --> 00:04:58,140
need any any Bluegreen deployments as I

00:04:55,470 --> 00:05:01,230
said it's only running when there is an

00:04:58,140 --> 00:05:04,560
event so we don't need to provision any

00:05:01,230 --> 00:05:06,710
any hardware or have any any extra

00:05:04,560 --> 00:05:10,350
buffer and in case we have higher load

00:05:06,710 --> 00:05:13,230
yeah also you can directly connect it to

00:05:10,350 --> 00:05:16,140
any events so as I said scaling

00:05:13,230 --> 00:05:18,600
automatically in the end all sources are

00:05:16,140 --> 00:05:21,750
just saying okay I want now to push this

00:05:18,600 --> 00:05:24,360
event to this lambda function and then

00:05:21,750 --> 00:05:28,080
it's executed so we don't need any any

00:05:24,360 --> 00:05:30,690
big service discovery and as that we

00:05:28,080 --> 00:05:33,150
directly start a PHP binary so we don't

00:05:30,690 --> 00:05:36,830
have here any any engine X involved or

00:05:33,150 --> 00:05:39,930
or any F p.m. so it's all very small

00:05:36,830 --> 00:05:42,300
yeah as I said what we need to do and we

00:05:39,930 --> 00:05:44,540
need to provide a PHP binary so the

00:05:42,300 --> 00:05:48,419
first thing we need to do is compile it

00:05:44,540 --> 00:05:51,479
in the end everything on AWS lambda is

00:05:48,419 --> 00:05:55,080
it organized in layers so each layer and

00:05:51,479 --> 00:05:58,080
we can see as one zipped file so one zip

00:05:55,080 --> 00:06:01,650
file for our code once a file probably

00:05:58,080 --> 00:06:04,080
for composer packages and one zip file

00:06:01,650 --> 00:06:06,450
for the bootstrap layer so this is

00:06:04,080 --> 00:06:10,740
mainly containing the PHP binary that

00:06:06,450 --> 00:06:12,510
gets executed later yeah what else do we

00:06:10,740 --> 00:06:14,640
need to do so we need to create the zip

00:06:12,510 --> 00:06:17,669
files we need to upload the zip files

00:06:14,640 --> 00:06:20,280
and of course to have everything in a

00:06:17,669 --> 00:06:23,130
good security context we need to create

00:06:20,280 --> 00:06:25,950
a I am role in AWS of this gives

00:06:23,130 --> 00:06:29,610
basically permissions for the for the

00:06:25,950 --> 00:06:31,440
lambda function yeah so in the end up

00:06:29,610 --> 00:06:35,520
loading zip files is probably something

00:06:31,440 --> 00:06:38,280
we did 10-15 years ago when we had FTP

00:06:35,520 --> 00:06:38,969
or others in this case of course we're

00:06:38,280 --> 00:06:41,399
not

00:06:38,969 --> 00:06:45,509
seeing FTP so there are some some nice

00:06:41,399 --> 00:06:49,409
tools from from AWS but makes things

00:06:45,509 --> 00:06:50,879
very easy in the end yeah so yeah this

00:06:49,409 --> 00:06:57,329
is probably the hardest part to compile

00:06:50,879 --> 00:07:01,829
the PHP binary to execute PHP on lambda

00:06:57,329 --> 00:07:06,479
we need to compile the the PHP source

00:07:01,829 --> 00:07:08,219
code on a special platform so this can

00:07:06,479 --> 00:07:11,699
be easily done with soccer so we need

00:07:08,219 --> 00:07:17,189
Emma's Linux container so inside this

00:07:11,699 --> 00:07:19,439
container we are building PHP so yeah

00:07:17,189 --> 00:07:21,239
for those who are not familiar and so

00:07:19,439 --> 00:07:23,819
basically it's it's downloading the

00:07:21,239 --> 00:07:27,809
source code from github so this is what

00:07:23,819 --> 00:07:30,749
we see here right here and then we run

00:07:27,809 --> 00:07:34,169
some tools configure and make so this is

00:07:30,749 --> 00:07:36,509
basically starting compiler for the for

00:07:34,169 --> 00:07:39,719
the C code of PHP and then we have a

00:07:36,509 --> 00:07:43,409
configure command so this command and

00:07:39,719 --> 00:07:46,050
air is us to set but which extensions do

00:07:43,409 --> 00:07:48,269
we need or which extensions we don't

00:07:46,050 --> 00:07:51,149
need to compile so here in this example

00:07:48,269 --> 00:07:53,519
I said okay I need OpenSSL of course I

00:07:51,149 --> 00:07:56,279
need curl I want to do something with my

00:07:53,519 --> 00:07:57,029
sequel database and of course I want to

00:07:56,279 --> 00:07:59,129
use PDO

00:07:57,029 --> 00:08:01,249
maybe I also want to do some Swiss

00:07:59,129 --> 00:08:04,860
Unicode string so included MB string

00:08:01,249 --> 00:08:07,409
yeah I said I don't need SQLite so I

00:08:04,860 --> 00:08:09,569
skip this and I also skip here

00:08:07,409 --> 00:08:13,009
so because I don't need and you're in

00:08:09,569 --> 00:08:16,529
the end then everything is compiled and

00:08:13,009 --> 00:08:22,649
yeah what we get in the end is a PHP

00:08:16,529 --> 00:08:25,949
binary and this we copied to a second

00:08:22,649 --> 00:08:28,919
container this container and this is

00:08:25,949 --> 00:08:32,729
just basically a local lambda emulation

00:08:28,919 --> 00:08:34,019
so that we we don't need to have the

00:08:32,729 --> 00:08:36,689
full full Amazon

00:08:34,019 --> 00:08:39,689
stuff so online so we can test locally

00:08:36,689 --> 00:08:43,009
and yeah so this is the PHP binary in

00:08:39,689 --> 00:08:46,620
the end this is now in the lambda

00:08:43,009 --> 00:08:50,040
container I would say so next thing what

00:08:46,620 --> 00:08:51,540
we normally do yeah of course we we

00:08:50,040 --> 00:08:53,460
start the build command so then

00:08:51,540 --> 00:08:57,450
everything gets built

00:08:53,460 --> 00:08:59,280
then we need to test our PHP binary so

00:08:57,450 --> 00:09:01,370
when when you compiled PHP on your own

00:08:59,280 --> 00:09:04,110
there can always be some surprises like

00:09:01,370 --> 00:09:06,030
suddenly jason functions no more working

00:09:04,110 --> 00:09:10,410
or something and this is why I always

00:09:06,030 --> 00:09:13,470
run a few tests so here of course I give

00:09:10,410 --> 00:09:17,070
out the version number the minus M gives

00:09:13,470 --> 00:09:18,990
you the the compiled extensions for PHP

00:09:17,070 --> 00:09:21,890
so you can double check is everything

00:09:18,990 --> 00:09:24,510
that I really want or not want there

00:09:21,890 --> 00:09:26,700
yeah I'm also doing some some checking's

00:09:24,510 --> 00:09:29,460
for flawed numbers here so this is just

00:09:26,700 --> 00:09:34,320
and the JSON encode to see this miami

00:09:29,460 --> 00:09:36,480
jason properly working yeah so next as i

00:09:34,320 --> 00:09:38,910
said we need to create some zip file so

00:09:36,480 --> 00:09:41,220
we need the the PHP binary on our local

00:09:38,910 --> 00:09:43,200
machine so this is what we have here in

00:09:41,220 --> 00:09:45,180
the end so we take it out of the

00:09:43,200 --> 00:09:48,990
container from our lambda container and

00:09:45,180 --> 00:09:52,890
copy it just to a local machine so now

00:09:48,990 --> 00:09:56,910
we have a PHP binary that can execute on

00:09:52,890 --> 00:10:00,120
AWS yeah how does a typical lambda

00:09:56,910 --> 00:10:02,160
project look like so as I said we have a

00:10:00,120 --> 00:10:04,320
binary folder where is the the PHP

00:10:02,160 --> 00:10:06,630
binary and we have a source folder where

00:10:04,320 --> 00:10:09,450
all our sources so here just have one

00:10:06,630 --> 00:10:11,610
one and PHP file that can be a lot

00:10:09,450 --> 00:10:13,050
bigger than and can have typical

00:10:11,610 --> 00:10:15,720
structure as you normally have and

00:10:13,050 --> 00:10:18,390
there's a special bootstrap file I'm

00:10:15,720 --> 00:10:21,630
coming up next yeah and yeah you have

00:10:18,390 --> 00:10:23,010
composer for your libraries and the

00:10:21,630 --> 00:10:26,610
dockerfile is the talk of Photoshop

00:10:23,010 --> 00:10:29,430
before so this is just there for ya

00:10:26,610 --> 00:10:31,440
compiling and the trust policy this is a

00:10:29,430 --> 00:10:34,590
special file also Carbon the next slide

00:10:31,440 --> 00:10:39,420
and yeah as a set and we run a PHP

00:10:34,590 --> 00:10:42,330
function which in this case it's called

00:10:39,420 --> 00:10:45,450
just a hello PHP and it's executing the

00:10:42,330 --> 00:10:47,280
hello function and as a source we no

00:10:45,450 --> 00:10:49,680
longer get dollar requests or something

00:10:47,280 --> 00:10:52,230
so we get now everything inside the

00:10:49,680 --> 00:10:53,850
event data array so this is probably the

00:10:52,230 --> 00:10:55,980
main difference so as we said we can

00:10:53,850 --> 00:10:59,910
have many many different sources like

00:10:55,980 --> 00:11:03,180
Unisa streams s3 or others so and these

00:10:59,910 --> 00:11:05,550
all have specific formats for the for

00:11:03,180 --> 00:11:06,630
the event data in in the end we return

00:11:05,550 --> 00:11:08,819
something

00:11:06,630 --> 00:11:13,910
for our function so this is basically

00:11:08,819 --> 00:11:16,110
and what we normally do with echo so

00:11:13,910 --> 00:11:19,860
what we have the bootstrap

00:11:16,110 --> 00:11:21,569
yeah the bootstrap calls the PHP binary

00:11:19,860 --> 00:11:23,910
of course I'm setting some error

00:11:21,569 --> 00:11:26,459
handling here and I'm starting the

00:11:23,910 --> 00:11:29,329
autoloader from composer and and then

00:11:26,459 --> 00:11:32,100
comes the important thing how do we

00:11:29,329 --> 00:11:34,050
execute the the request or how do we get

00:11:32,100 --> 00:11:37,620
the event data in the end so what

00:11:34,050 --> 00:11:40,100
happens here is is a while loop so what

00:11:37,620 --> 00:11:44,279
we can do here and this one

00:11:40,100 --> 00:11:47,759
PHP process we can execute multiple

00:11:44,279 --> 00:11:50,279
events coming in each event we need to

00:11:47,759 --> 00:11:52,769
download but the HTTP request so this

00:11:50,279 --> 00:11:55,050
happens in this function and when we are

00:11:52,769 --> 00:11:58,319
finished with the execution and we say

00:11:55,050 --> 00:12:03,149
we send also the response back to those

00:11:58,319 --> 00:12:06,120
HTTP to the Amazon back-end so then when

00:12:03,149 --> 00:12:08,009
we get the request data we need to find

00:12:06,120 --> 00:12:11,699
out okay and which handler do we need to

00:12:08,009 --> 00:12:15,420
execute so this is given in the dollar

00:12:11,699 --> 00:12:19,110
in findly so and we do some quick checks

00:12:15,420 --> 00:12:21,870
so if not something bad inside and and

00:12:19,110 --> 00:12:25,439
then what we do is just running our

00:12:21,870 --> 00:12:30,529
hello PHP in the end so was include

00:12:25,439 --> 00:12:33,870
require once yeah then we run the

00:12:30,529 --> 00:12:35,639
function itself with the request data so

00:12:33,870 --> 00:12:38,850
this is basically our event data we get

00:12:35,639 --> 00:12:42,930
a response and then we send it out so

00:12:38,850 --> 00:12:47,370
normally when we run PHP fpm there is

00:12:42,930 --> 00:12:50,040
normally one process that processes one

00:12:47,370 --> 00:12:55,050
request so in this case we have one

00:12:50,040 --> 00:12:57,360
process processing multiple events so

00:12:55,050 --> 00:12:59,819
this is the main difference and yeah you

00:12:57,360 --> 00:13:03,120
may probably heard about a synchronous

00:12:59,819 --> 00:13:07,579
PHP react PHP so this is all basically

00:13:03,120 --> 00:13:11,160
doing while loops and executing things

00:13:07,579 --> 00:13:13,889
yeah what else do we need yeah of course

00:13:11,160 --> 00:13:18,300
we can do a local test and we have our

00:13:13,889 --> 00:13:20,340
lambda PHP runtime container this is we

00:13:18,300 --> 00:13:23,580
start at the end

00:13:20,340 --> 00:13:25,470
we provide the event data so here in

00:13:23,580 --> 00:13:28,700
this case is just adjacent string and

00:13:25,470 --> 00:13:31,610
then everything gets executed and yeah

00:13:28,700 --> 00:13:35,070
lambda is very specific in execution

00:13:31,610 --> 00:13:37,680
what it always has is a unique request

00:13:35,070 --> 00:13:42,200
ID so this is this long number here is

00:13:37,680 --> 00:13:46,200
this kind of user ID and yeah as we said

00:13:42,200 --> 00:13:48,839
we're doing a print R for the event data

00:13:46,200 --> 00:13:52,170
so this is basically what we get so here

00:13:48,839 --> 00:13:55,589
this is our payload and yeah for Amazon

00:13:52,170 --> 00:13:59,580
and not everything is free so then they

00:13:55,589 --> 00:14:02,670
charge you yeah in hundred millisecond

00:13:59,580 --> 00:14:06,750
steps so this is what we see here so we

00:14:02,670 --> 00:14:08,550
have basically and our our function just

00:14:06,750 --> 00:14:11,520
needed at two milliseconds because it

00:14:08,550 --> 00:14:13,260
didn't do anything at the end but the

00:14:11,520 --> 00:14:15,810
billing happens always in hundred

00:14:13,260 --> 00:14:18,420
milliseconds steps and for each function

00:14:15,810 --> 00:14:20,820
we can set amount of memory that is

00:14:18,420 --> 00:14:23,370
available and based in the more memory

00:14:20,820 --> 00:14:25,560
and we need for the function the more

00:14:23,370 --> 00:14:28,320
expensive it gets so for the pricing

00:14:25,560 --> 00:14:29,730
I'll cover late a bit here for the local

00:14:28,320 --> 00:14:33,120
environment there's a standard setting

00:14:29,730 --> 00:14:35,540
1.5 gigabyte yeah and I'm here it also

00:14:33,120 --> 00:14:38,339
says how much memory in my function used

00:14:35,540 --> 00:14:40,230
I didn't do much in the end so the

00:14:38,339 --> 00:14:44,010
memory here that is used is basically

00:14:40,230 --> 00:14:47,510
and required from the PHP binary itself

00:14:44,010 --> 00:14:50,190
so so this is let's say the minimum

00:14:47,510 --> 00:14:53,120
memory that you can use and yeah this is

00:14:50,190 --> 00:14:56,670
the return that we had the hello all

00:14:53,120 --> 00:15:00,050
so what's next is that we need to create

00:14:56,670 --> 00:15:03,420
the zip files we have three zip files

00:15:00,050 --> 00:15:06,630
one for the PHP binary and the bootstrap

00:15:03,420 --> 00:15:09,240
file one for vendor folder for composer

00:15:06,630 --> 00:15:15,200
and one for the source code itself so we

00:15:09,240 --> 00:15:19,130
create three zip files we need to create

00:15:15,200 --> 00:15:21,990
the roll so in this this is standard

00:15:19,130 --> 00:15:24,959
Amazon and to assume the role and

00:15:21,990 --> 00:15:29,790
execute under functions so this is

00:15:24,959 --> 00:15:32,560
normally just copy-paste yeah so when

00:15:29,790 --> 00:15:34,839
you have the AWS CLI on your machine

00:15:32,560 --> 00:15:37,660
the first thing normally you do is

00:15:34,839 --> 00:15:40,269
provide the keys that you have from the

00:15:37,660 --> 00:15:42,220
Amazon GUI and then you can start

00:15:40,269 --> 00:15:45,310
directly doing things and the Amazon

00:15:42,220 --> 00:15:47,050
Cloud from your local machine and so the

00:15:45,310 --> 00:15:50,699
first thing and what we do is we create

00:15:47,050 --> 00:15:54,069
their own and provide the trust policy

00:15:50,699 --> 00:15:57,069
the second thing is starting to upload

00:15:54,069 --> 00:15:59,949
the zip files so therefore we create

00:15:57,069 --> 00:16:04,480
layers so each layer then gets a unique

00:15:59,949 --> 00:16:07,509
identifier in the output and yeah this

00:16:04,480 --> 00:16:09,519
output we take just the ID out so

00:16:07,509 --> 00:16:12,959
because we need it later so we take the

00:16:09,519 --> 00:16:16,660
ID of the runtime we take the ID of the

00:16:12,959 --> 00:16:19,629
band or zip yeah Amazon has different

00:16:16,660 --> 00:16:21,730
regions so your you central this is

00:16:19,629 --> 00:16:24,519
normally Frankfurt you can also select

00:16:21,730 --> 00:16:27,189
Ireland or US as you like so each

00:16:24,519 --> 00:16:30,490
function gets executed directly in a

00:16:27,189 --> 00:16:35,110
specific region so here we said we have

00:16:30,490 --> 00:16:37,509
two layers created and the good thing is

00:16:35,110 --> 00:16:40,029
when you have multiple and/or functions

00:16:37,509 --> 00:16:43,809
the layers can be shared between the

00:16:40,029 --> 00:16:46,240
lambda function so when you have one one

00:16:43,809 --> 00:16:49,870
layer for the PHP runtime you can use it

00:16:46,240 --> 00:16:52,240
for all your lambda functions or if you

00:16:49,870 --> 00:16:55,300
want to share the the composer a zip

00:16:52,240 --> 00:16:57,759
file you can also share it so yeah so

00:16:55,300 --> 00:17:02,110
then we create the the function itself

00:16:57,759 --> 00:17:04,689
so this is our hello PHP in the end and

00:17:02,110 --> 00:17:07,720
it's in this case we created the hello

00:17:04,689 --> 00:17:10,209
zip so we upload this and we create a

00:17:07,720 --> 00:17:14,620
function we give it a name this is the

00:17:10,209 --> 00:17:16,929
PHP - hello then we need to provide the

00:17:14,620 --> 00:17:19,990
the unique identifier for the role that

00:17:16,929 --> 00:17:22,659
we created before and we need to provide

00:17:19,990 --> 00:17:25,929
the IDs for the two layers that we

00:17:22,659 --> 00:17:28,240
created before and as a set billing

00:17:25,929 --> 00:17:31,149
happens on the amount of memory so here

00:17:28,240 --> 00:17:34,690
I'm just doing the the minimum so this

00:17:31,149 --> 00:17:36,730
is 128 megabytes for small stuff it's

00:17:34,690 --> 00:17:42,340
enough but you can also increase to

00:17:36,730 --> 00:17:44,169
anything more and also in case normally

00:17:42,340 --> 00:17:46,300
we have 4 for PHP we have maximum

00:17:44,169 --> 00:17:48,640
execution time in the PHP any

00:17:46,300 --> 00:17:50,770
so for lambda and we directly said it

00:17:48,640 --> 00:17:54,010
when creating a function so in this case

00:17:50,770 --> 00:17:56,170
means the function can execute a maximum

00:17:54,010 --> 00:17:58,960
amount of 5 seconds and then it's

00:17:56,170 --> 00:18:01,110
terminated so you can also set any any

00:17:58,960 --> 00:18:07,500
higher value there are some limitations

00:18:01,110 --> 00:18:11,290
I'll show later yeah so we created our

00:18:07,500 --> 00:18:13,930
yeah our function and yeah later

00:18:11,290 --> 00:18:19,600
probably we change our code then we also

00:18:13,930 --> 00:18:21,520
need to update the function and yeah

00:18:19,600 --> 00:18:24,040
this is also just just a one-liner in

00:18:21,520 --> 00:18:26,200
the end so this is what what we call

00:18:24,040 --> 00:18:29,050
them the deployment now so we create a

00:18:26,200 --> 00:18:32,680
new zip file and just upload it and then

00:18:29,050 --> 00:18:35,290
the code is life so this is very simple

00:18:32,680 --> 00:18:38,890
everything and yeah you can can

00:18:35,290 --> 00:18:41,800
integrate this in your CI platform or do

00:18:38,890 --> 00:18:47,110
it manually from your machine so as you

00:18:41,800 --> 00:18:49,750
like so we have yeah so when we want to

00:18:47,110 --> 00:18:53,020
execute our function we can directly

00:18:49,750 --> 00:18:56,320
execute it in the cloud this is with a

00:18:53,020 --> 00:18:57,910
lambda invoke command we need to say ok

00:18:56,320 --> 00:19:00,820
which what is the name of the function

00:18:57,910 --> 00:19:03,130
is a PHP hello and then we can also

00:19:00,820 --> 00:19:06,070
provide the payload so this is basically

00:19:03,130 --> 00:19:07,810
just for testing and yeah what we would

00:19:06,070 --> 00:19:12,100
we get in the end is some some output

00:19:07,810 --> 00:19:14,860
and here we decide just do the basics

00:19:12,100 --> 00:19:17,650
for decoding yeah so and then what we

00:19:14,860 --> 00:19:20,530
get again is the hell all but in this

00:19:17,650 --> 00:19:25,810
context we execute it the function

00:19:20,530 --> 00:19:28,330
directly in the cloud so on simple yeah

00:19:25,810 --> 00:19:32,020
so as I said lambda is a bit different

00:19:28,330 --> 00:19:34,500
than the PHP code will run on engine X

00:19:32,020 --> 00:19:37,960
with fpm or Motta pesci

00:19:34,500 --> 00:19:41,560
we have a loop we saw the the while loop

00:19:37,960 --> 00:19:44,590
and yeah when we when we execute a lot

00:19:41,560 --> 00:19:46,720
of events in this loop probably and it

00:19:44,590 --> 00:19:49,750
can happen that our PHP code takes more

00:19:46,720 --> 00:19:52,240
and more memory so we can in the end if

00:19:49,750 --> 00:19:54,250
the memory can can be empty so the free

00:19:52,240 --> 00:19:55,870
memory no more available and then also

00:19:54,250 --> 00:19:58,210
the the bottom machine gets terminated

00:19:55,870 --> 00:19:59,330
so we need to do something I'll show

00:19:58,210 --> 00:20:03,080
later

00:19:59,330 --> 00:20:04,820
here also when we have in our and HP

00:20:03,080 --> 00:20:07,730
function when we open database

00:20:04,820 --> 00:20:10,129
connections or something we also need to

00:20:07,730 --> 00:20:12,679
make sure to directly close the

00:20:10,129 --> 00:20:15,230
connections so because if you don't

00:20:12,679 --> 00:20:19,580
close it then they stay open until the

00:20:15,230 --> 00:20:21,440
the execution is finished completely so

00:20:19,580 --> 00:20:24,019
this can can take many minutes or

00:20:21,440 --> 00:20:26,210
something so we need to manually close

00:20:24,019 --> 00:20:26,869
database connections so this is quite

00:20:26,210 --> 00:20:29,210
important

00:20:26,869 --> 00:20:31,730
same happens for file pointers resources

00:20:29,210 --> 00:20:36,649
and others yeah we need some different

00:20:31,730 --> 00:20:38,929
error handling because in inside the the

00:20:36,649 --> 00:20:41,359
lambda it's running in the bottom

00:20:38,929 --> 00:20:44,059
machine but everything instead except

00:20:41,359 --> 00:20:47,389
that's a slash temp folder is read-only

00:20:44,059 --> 00:20:49,759
so we need to write locks somewhere so

00:20:47,389 --> 00:20:52,399
there normally everything you run with

00:20:49,759 --> 00:20:56,059
echo is sent to Amazon CloudWatch

00:20:52,399 --> 00:20:58,190
so this is some some logging service but

00:20:56,059 --> 00:20:59,899
you can also use other services so you

00:20:58,190 --> 00:21:04,759
just connect somewhere and send the

00:20:59,899 --> 00:21:07,279
locks yeah era hand link and also since

00:21:04,759 --> 00:21:11,269
we are running in the loop we must make

00:21:07,279 --> 00:21:15,859
sure not to produce any fatals or run in

00:21:11,269 --> 00:21:18,379
any unhandled exceptions so you need to

00:21:15,859 --> 00:21:21,499
probably do some trycatch and for your

00:21:18,379 --> 00:21:25,070
code yeah as I said we're running in the

00:21:21,499 --> 00:21:28,070
loop so we can also do a different kind

00:21:25,070 --> 00:21:30,230
of caching so we don't have any any op

00:21:28,070 --> 00:21:33,289
cache or something running here so what

00:21:30,230 --> 00:21:36,499
we can do is basically create a class

00:21:33,289 --> 00:21:38,629
and and populate the members as a cache

00:21:36,499 --> 00:21:40,519
so because everything is running all the

00:21:38,629 --> 00:21:42,799
time in the loop so nothing gets

00:21:40,519 --> 00:21:44,869
destroyed automatically so everything

00:21:42,799 --> 00:21:47,149
you you save somewhere in in your

00:21:44,869 --> 00:21:49,759
classes or in variables and stays

00:21:47,149 --> 00:21:52,879
persistent so this is yeah a bit more

00:21:49,759 --> 00:21:56,239
comfortable probably as I set the memory

00:21:52,879 --> 00:21:58,639
limit we need to take care of we have a

00:21:56,239 --> 00:22:02,389
Mac maximum execution time so in this in

00:21:58,639 --> 00:22:04,700
my example I had five seconds so there's

00:22:02,389 --> 00:22:07,539
a hot limit so this also cannot be

00:22:04,700 --> 00:22:10,549
increased during runtime and as I said

00:22:07,539 --> 00:22:13,190
we have normal dollar get post request

00:22:10,549 --> 00:22:16,070
and so on so we get everything in the

00:22:13,190 --> 00:22:18,080
as the event data array so probably when

00:22:16,070 --> 00:22:20,090
we use some standard frameworks we need

00:22:18,080 --> 00:22:24,560
to write a small adapter and that wraps

00:22:20,090 --> 00:22:27,740
things into the requests and response

00:22:24,560 --> 00:22:31,670
objects yeah so as I said we don't need

00:22:27,740 --> 00:22:35,140
to do anything for scaling PHP so this

00:22:31,670 --> 00:22:37,910
means you can by default run every 1,000

00:22:35,140 --> 00:22:40,190
lambda functions in parallel by default

00:22:37,910 --> 00:22:43,610
so Amazon every time I event comes in

00:22:40,190 --> 00:22:45,350
just starts a new one this also means

00:22:43,610 --> 00:22:47,090
that when you connect your database you

00:22:45,350 --> 00:22:50,630
suddenly have 1,000 connections on the

00:22:47,090 --> 00:22:52,760
database so PHP scaling automatically

00:22:50,630 --> 00:22:54,290
but the database probably not scaling

00:22:52,760 --> 00:22:59,120
automatically so you need to be very

00:22:54,290 --> 00:23:01,340
careful with handling a databases yeah

00:22:59,120 --> 00:23:05,420
error handling as I said they're

00:23:01,340 --> 00:23:09,410
different event sources for lambda some

00:23:05,420 --> 00:23:12,320
some I executed yeah synchronously so

00:23:09,410 --> 00:23:14,060
when a new web request from a browser

00:23:12,320 --> 00:23:16,670
comes to the API gateway

00:23:14,060 --> 00:23:20,000
yeah then directly your function is

00:23:16,670 --> 00:23:22,430
executed synchronously when your

00:23:20,000 --> 00:23:25,070
function has an error then directly also

00:23:22,430 --> 00:23:27,050
error gets sent to the browser

00:23:25,070 --> 00:23:29,780
so normally 500 error if you don't

00:23:27,050 --> 00:23:32,450
handle it and there are also kanessa

00:23:29,780 --> 00:23:35,060
streams so this is the yeah the smaller

00:23:32,450 --> 00:23:38,450
version from Amazon that acts like Kafka

00:23:35,060 --> 00:23:41,870
so where you can can have some kind of

00:23:38,450 --> 00:23:45,050
message bus by you consume all kinds of

00:23:41,870 --> 00:23:46,640
messages and the the nice thing here is

00:23:45,050 --> 00:23:50,270
you don't need to write any worker

00:23:46,640 --> 00:23:52,610
that's pulling all the messages from

00:23:50,270 --> 00:23:53,510
Kinesis so in this case every time there

00:23:52,610 --> 00:23:55,010
is a new message

00:23:53,510 --> 00:23:59,950
the illunga function is directly

00:23:55,010 --> 00:24:04,100
executed and yeah when there's an error

00:23:59,950 --> 00:24:06,620
it automatically retries so this is also

00:24:04,100 --> 00:24:08,960
very comfortable so when when you have

00:24:06,620 --> 00:24:10,550
let's say of some some network problem

00:24:08,960 --> 00:24:12,230
because the database is down or

00:24:10,550 --> 00:24:15,800
something that just automatically

00:24:12,230 --> 00:24:18,280
retries there are other services like

00:24:15,800 --> 00:24:21,710
simple notification service or s/3 s/3

00:24:18,280 --> 00:24:25,010
probably the most popular and this

00:24:21,710 --> 00:24:26,870
executed hasn't Crona so for example you

00:24:25,010 --> 00:24:29,270
can set event

00:24:26,870 --> 00:24:30,980
when there is a new file uploaded and

00:24:29,270 --> 00:24:33,080
then my lambda function gets executed

00:24:30,980 --> 00:24:36,560
and then we do some processing business

00:24:33,080 --> 00:24:40,390
file there is automatically three

00:24:36,560 --> 00:24:43,220
retries and after this three retries

00:24:40,390 --> 00:24:45,230
what do we do with the request and if

00:24:43,220 --> 00:24:47,420
it's failing again so then you can set

00:24:45,230 --> 00:24:49,340
at that letter Q so this is also some

00:24:47,420 --> 00:24:51,680
some message queues in the end where you

00:24:49,340 --> 00:24:56,060
just save the payload when it completely

00:24:51,680 --> 00:24:59,480
fails yeah SQS we are also a queue

00:24:56,060 --> 00:25:02,210
service from Amazon yeah this this

00:24:59,480 --> 00:25:04,520
normally handles also things quite

00:25:02,210 --> 00:25:06,680
nicely when when something fails it's

00:25:04,520 --> 00:25:09,380
just put putting the the message back in

00:25:06,680 --> 00:25:12,650
the queue and then a next execution can

00:25:09,380 --> 00:25:16,520
take it and process it so if something

00:25:12,650 --> 00:25:21,730
fails the memory limit as a set we need

00:25:16,520 --> 00:25:25,370
to take care so in this case here I'm

00:25:21,730 --> 00:25:30,140
just setting let's say here a maximum of

00:25:25,370 --> 00:25:32,720
80 megabytes so when we when our code

00:25:30,140 --> 00:25:35,840
reaches the 80 megabytes then we stop

00:25:32,720 --> 00:25:38,900
the while loop then the the process

00:25:35,840 --> 00:25:41,480
finishes regularly and Amazon AWS okay I

00:25:38,900 --> 00:25:46,070
need to start a new one so when the next

00:25:41,480 --> 00:25:50,150
event occurs so then that way we can can

00:25:46,070 --> 00:25:51,980
handle things yeah very easy and but

00:25:50,150 --> 00:25:55,580
also we need to know what is the limit

00:25:51,980 --> 00:25:57,980
so in this case I said founder 28

00:25:55,580 --> 00:26:00,440
megabytes so I set it to 80 so and

00:25:57,980 --> 00:26:06,230
probably have 20 30 megabytes for PHP

00:26:00,440 --> 00:26:10,250
left so this this will work what else we

00:26:06,230 --> 00:26:12,470
have yeah so probably the most popular

00:26:10,250 --> 00:26:15,140
we want to process some requests from a

00:26:12,470 --> 00:26:18,170
browser there is the API gateway from

00:26:15,140 --> 00:26:22,910
Amazon there's basically some kind of

00:26:18,170 --> 00:26:27,080
proxy and for forests calls and yeah

00:26:22,910 --> 00:26:28,760
there that we for the response we need

00:26:27,080 --> 00:26:30,650
to provide also some some kind of

00:26:28,760 --> 00:26:33,590
response that the browser can read and

00:26:30,650 --> 00:26:36,350
so that means we need some HTTP status

00:26:33,590 --> 00:26:39,920
code so in the success case is the 200

00:26:36,350 --> 00:26:42,290
and yeah we need to tell the browser and

00:26:39,920 --> 00:26:44,090
what is the content type that we are

00:26:42,290 --> 00:26:46,520
providing for the data in this case is

00:26:44,090 --> 00:26:48,890
just JSON data and yeah we need to

00:26:46,520 --> 00:26:51,020
provide the data it's a full response so

00:26:48,890 --> 00:26:53,140
does this here than the body and then we

00:26:51,020 --> 00:26:57,410
put our response and then we get another

00:26:53,140 --> 00:27:01,010
JSON response and this we return and and

00:26:57,410 --> 00:27:05,300
then it gets delivered to the browser so

00:27:01,010 --> 00:27:07,910
and limitations and yeah lambda has some

00:27:05,300 --> 00:27:11,660
limitations but I think they are not too

00:27:07,910 --> 00:27:14,600
too strict so you can set maximum 3

00:27:11,660 --> 00:27:16,790
gigabyte of RAM so if your codes needs

00:27:14,600 --> 00:27:19,100
more than three gigabyte of ram to do

00:27:16,790 --> 00:27:21,260
something then probably you need to do

00:27:19,100 --> 00:27:23,290
something else like ec2 instances or

00:27:21,260 --> 00:27:26,390
yeah hosted somewhere else

00:27:23,290 --> 00:27:28,900
yeah the maximum execution time for a

00:27:26,390 --> 00:27:31,850
lambda function can be set to 15 minutes

00:27:28,900 --> 00:27:34,550
but as that we can also any any any

00:27:31,850 --> 00:27:37,100
smaller number so when you have some

00:27:34,550 --> 00:27:39,440
some cron jobs probably running for many

00:27:37,100 --> 00:27:41,810
hours you need to do something to split

00:27:39,440 --> 00:27:43,330
it to make it smaller or or process

00:27:41,810 --> 00:27:46,010
smaller chunks of data

00:27:43,330 --> 00:27:49,400
yeah maximum we can define five layers

00:27:46,010 --> 00:27:52,370
in our example and we defined two layers

00:27:49,400 --> 00:27:55,880
and yeah the the zip files that we

00:27:52,370 --> 00:27:57,890
upload have a limit of 50 megabytes so

00:27:55,880 --> 00:28:01,100
if you have probably some very large

00:27:57,890 --> 00:28:04,130
code base a huge shop that but the code

00:28:01,100 --> 00:28:06,440
itself a zip file is more than 50

00:28:04,130 --> 00:28:09,410
megabytes and then you probably also

00:28:06,440 --> 00:28:13,280
cannot use lambda and as I said we can

00:28:09,410 --> 00:28:17,720
write only to the temp file system there

00:28:13,280 --> 00:28:20,270
we can also have 512 megabytes for for

00:28:17,720 --> 00:28:23,330
storing temporary data yeah and the

00:28:20,270 --> 00:28:26,750
default limit is 1 soul so we can

00:28:23,330 --> 00:28:28,910
execute 1,000 functions in parallel and

00:28:26,750 --> 00:28:31,010
if you need a higher limit you can ask

00:28:28,910 --> 00:28:33,800
the support and then they increase it so

00:28:31,010 --> 00:28:36,230
this is just a security limit so if you

00:28:33,800 --> 00:28:37,850
have some bots or some denial of service

00:28:36,230 --> 00:28:42,050
attack or something that you're not

00:28:37,850 --> 00:28:45,440
paying too much so what we have pricing

00:28:42,050 --> 00:28:48,130
so as I said is not for free and so it's

00:28:45,440 --> 00:28:51,860
two components that we normally pay is

00:28:48,130 --> 00:28:53,540
one component is the number of requests

00:28:51,860 --> 00:28:55,760
and the second component

00:28:53,540 --> 00:28:58,640
is how long the request takes in the end

00:28:55,760 --> 00:29:01,250
and we are built by hundred millisecond

00:28:58,640 --> 00:29:04,220
cycles and yeah so this this number

00:29:01,250 --> 00:29:06,080
looks very small in the end and but but

00:29:04,220 --> 00:29:08,900
the if you have some millions of

00:29:06,080 --> 00:29:11,720
requests processing per day Sun also can

00:29:08,900 --> 00:29:14,330
can cost some money and for business

00:29:11,720 --> 00:29:16,190
side is always important to compare what

00:29:14,330 --> 00:29:19,070
does the lamda cost and or what does

00:29:16,190 --> 00:29:22,510
other for example ec2 instances cost so

00:29:19,070 --> 00:29:25,880
here I made a small comparison so I use

00:29:22,510 --> 00:29:29,810
let's say one eight gigabyte was to

00:29:25,880 --> 00:29:32,540
course and here this is on demand

00:29:29,810 --> 00:29:34,580
pricing so it's two point three dollars

00:29:32,540 --> 00:29:36,500
and for lambda it's nine point six

00:29:34,580 --> 00:29:39,080
dollars or lambda here looks more

00:29:36,500 --> 00:29:40,910
expensive and but the lambda is only

00:29:39,080 --> 00:29:43,490
executed when there is really requests

00:29:40,910 --> 00:29:46,340
happening so if you have some very low

00:29:43,490 --> 00:29:49,850
traffic at night probably you the lambda

00:29:46,340 --> 00:29:52,520
is much cheaper if you have 24 hours

00:29:49,850 --> 00:29:55,850
always full traffic then probably easy

00:29:52,520 --> 00:29:56,750
two instances is better if you have for

00:29:55,850 --> 00:29:59,540
example a cron job

00:29:56,750 --> 00:30:01,610
there's only running once per hour for

00:29:59,540 --> 00:30:04,990
let's say one or two minutes then

00:30:01,610 --> 00:30:07,550
probably the the lambda is cheaper and

00:30:04,990 --> 00:30:10,160
there was other costs if you use the API

00:30:07,550 --> 00:30:13,430
gateway and you need to pay the data

00:30:10,160 --> 00:30:15,680
transfer of Amazon and if you do logging

00:30:13,430 --> 00:30:18,920
and of course you need to pay something

00:30:15,680 --> 00:30:21,860
for the cloud watch this also depends in

00:30:18,920 --> 00:30:26,030
the end how much you log and how long

00:30:21,860 --> 00:30:29,720
you want to keep the logs here's another

00:30:26,030 --> 00:30:32,810
example this is doing direct also direct

00:30:29,720 --> 00:30:35,420
comparison this was the easy two

00:30:32,810 --> 00:30:40,310
instance so here they they choose M for

00:30:35,420 --> 00:30:44,450
large and they found out that the ec2

00:30:40,310 --> 00:30:48,650
instance is getting cheaper when when

00:30:44,450 --> 00:30:52,010
you have 82 requests per second so

00:30:48,650 --> 00:30:53,570
there's always yeah some some parts

00:30:52,010 --> 00:30:55,700
where the lambda is cheaper and some

00:30:53,570 --> 00:30:58,910
parts where they're easy to miss cheaper

00:30:55,700 --> 00:31:00,770
but normally and the the cost for

00:30:58,910 --> 00:31:02,450
administrating the lambda functions are

00:31:00,770 --> 00:31:05,330
much lower because you don't need any

00:31:02,450 --> 00:31:06,980
any TF up or something you need don't

00:31:05,330 --> 00:31:10,580
need to schedule service or something

00:31:06,980 --> 00:31:12,950
so namely lambda and has has less

00:31:10,580 --> 00:31:16,059
overhead for your business and less work

00:31:12,950 --> 00:31:18,500
for your for your DevOps so this also

00:31:16,059 --> 00:31:23,570
should be considered when checking the

00:31:18,500 --> 00:31:25,010
costs use cases as a set for example if

00:31:23,570 --> 00:31:27,530
you have a cron job only running once

00:31:25,010 --> 00:31:30,230
power for a minute so this is quite good

00:31:27,530 --> 00:31:31,970
so we because we don't need to pay all

00:31:30,230 --> 00:31:35,000
the idle time that we normally pay if we

00:31:31,970 --> 00:31:38,540
book that you see two instances yes

00:31:35,000 --> 00:31:41,059
sometimes you do TV campaigns or other

00:31:38,540 --> 00:31:43,370
marketing campaigns where you don't know

00:31:41,059 --> 00:31:45,740
how much traffic is coming so how many

00:31:43,370 --> 00:31:48,020
servers do I need in the end or if I've

00:31:45,740 --> 00:31:52,190
queuing it is cluster so what how many

00:31:48,020 --> 00:31:54,850
notes do I need to set up and for lambda

00:31:52,190 --> 00:31:58,390
it's just scaling and and we pay per use

00:31:54,850 --> 00:32:01,040
so this can can be a very good use case

00:31:58,390 --> 00:32:04,400
as I said we don't need to implement a

00:32:01,040 --> 00:32:07,010
full worker to ask kinases all the time

00:32:04,400 --> 00:32:09,080
do you have new events so we will

00:32:07,010 --> 00:32:11,090
automatically get get called when there

00:32:09,080 --> 00:32:14,690
is an event so we need to write less

00:32:11,090 --> 00:32:17,390
code in this yeah so there are also some

00:32:14,690 --> 00:32:20,330
some back-end tasks where lambda is very

00:32:17,390 --> 00:32:22,760
often used for processing files like

00:32:20,330 --> 00:32:24,980
image resizing or something so you can

00:32:22,760 --> 00:32:26,660
directly have your normal code and then

00:32:24,980 --> 00:32:30,169
from the normal code you call the lambda

00:32:26,660 --> 00:32:31,760
function and say okay here just process

00:32:30,169 --> 00:32:33,470
this file and then this happens in the

00:32:31,760 --> 00:32:36,440
background and we don't need to care for

00:32:33,470 --> 00:32:39,169
it so yeah as that we can do for sending

00:32:36,440 --> 00:32:41,059
emails for example we said we want to

00:32:39,169 --> 00:32:44,600
send out newsletters we put it in a

00:32:41,059 --> 00:32:47,870
queue like the sks queue and then every

00:32:44,600 --> 00:32:49,610
time for the for the queue the lambda

00:32:47,870 --> 00:32:53,600
function is called so that means if you

00:32:49,610 --> 00:32:55,850
have a concurrent limit of 1,000 and we

00:32:53,600 --> 00:32:59,270
can also set a lower one and we can can

00:32:55,850 --> 00:33:03,230
send out 1,000 emails in parallel also

00:32:59,270 --> 00:33:05,059
very nice and also if you are on on RDS

00:33:03,230 --> 00:33:07,400
so there's the database service from

00:33:05,059 --> 00:33:12,049
Amazon and you use the Aurora so this is

00:33:07,400 --> 00:33:14,210
a very very special version of my sequel

00:33:12,049 --> 00:33:17,690
then you can also and call lambda

00:33:14,210 --> 00:33:19,549
functions inside your SQL so normally

00:33:17,690 --> 00:33:20,690
here call is used for for the stored

00:33:19,549 --> 00:33:23,390
procedure so

00:33:20,690 --> 00:33:25,760
can call a lambda execution from your

00:33:23,390 --> 00:33:29,000
SQL code and you can also use it in in

00:33:25,760 --> 00:33:31,250
triggers or others so King can also be

00:33:29,000 --> 00:33:34,910
very nice to execute code from your

00:33:31,250 --> 00:33:38,000
database so is a yeah it's a bit crazy

00:33:34,910 --> 00:33:44,120
from the architecture side but but you

00:33:38,000 --> 00:33:47,300
can do it if you want so let's see what

00:33:44,120 --> 00:33:50,020
we have yeah I'm finish I'm saying

00:33:47,300 --> 00:33:56,210
everybody for coming and listening

00:33:50,020 --> 00:34:07,310
[Applause]

00:33:56,210 --> 00:34:10,719
[Music]

00:34:07,310 --> 00:34:10,719

YouTube URL: https://www.youtube.com/watch?v=5cLZ5jT2Gi0


