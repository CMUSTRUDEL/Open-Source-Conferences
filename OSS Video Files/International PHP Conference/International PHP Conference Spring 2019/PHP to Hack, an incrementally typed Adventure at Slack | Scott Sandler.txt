Title: PHP to Hack, an incrementally typed Adventure at Slack | Scott Sandler
Publication date: 2019-10-02
Playlist: International PHP Conference Spring 2019
Description: 
	Speaker: Scott Sandler (Slack) | https://phpconference.com/speaker/scott-sandler/

In 2016, Slack began a migration of its multi-million line PHP codebase to Facebookâ€™s Hack programming language. As we say a bittersweet goodbye to the final lines of PHP in our codebase, this talk reflects on what was surprising, challenging, and beneficial in this migration. Weâ€™ll cover some of the benefits and drawbacks of Hack, and places where the PHP community can draw inspiration.

ðŸ¤— Come, join us at the next International PHP Conference | https://phpconference.com/
ðŸ‘ Like us on Facebook | https://www.facebook.com/ipc.germany/
ðŸ‘‰ Follow us on Twitter | https://twitter.com/phpconference
Captions: 
	00:00:01,540 --> 00:00:07,230
[Music]

00:00:04,339 --> 00:00:09,570
all right thank you so much let's get

00:00:07,230 --> 00:00:11,250
started so my name is Scott Sandlin I'm

00:00:09,570 --> 00:00:14,849
going to talk about our journey from PHP

00:00:11,250 --> 00:00:15,960
to hack at slack Smee I'm a back an

00:00:14,849 --> 00:00:17,640
engineer at slack and I've been there

00:00:15,960 --> 00:00:20,100
for about four years and in that time

00:00:17,640 --> 00:00:21,600
slack has grown quite a bit today we

00:00:20,100 --> 00:00:23,580
have about 10 million people using slack

00:00:21,600 --> 00:00:24,900
every day and the backend code base on

00:00:23,580 --> 00:00:26,730
when we're talking to you about is

00:00:24,900 --> 00:00:28,560
responsible for processing every message

00:00:26,730 --> 00:00:30,000
every file every emoji everything that

00:00:28,560 --> 00:00:33,000
happens in slack goes through this

00:00:30,000 --> 00:00:35,969
codebase some history on this codebase

00:00:33,000 --> 00:00:39,809
slack launched in early 2014 with a PHP

00:00:35,969 --> 00:00:42,180
5 5 back end and we migrated to H HTM in

00:00:39,809 --> 00:00:45,300
early 2016 and the reason for this was

00:00:42,180 --> 00:00:48,030
really about performance at that time h

00:00:45,300 --> 00:00:49,260
h vm was much faster than PHP 5 and so

00:00:48,030 --> 00:00:51,120
it's really about just getting the speed

00:00:49,260 --> 00:00:53,309
out of there h h vm is an alternative

00:00:51,120 --> 00:00:55,260
runtime for PHP that was developed at

00:00:53,309 --> 00:00:57,600
facebook that it's completely rewritten

00:00:55,260 --> 00:01:00,059
the PHP runtime from the ground up but

00:00:57,600 --> 00:01:01,410
still about running PHP and it wasn't

00:01:00,059 --> 00:01:04,170
for another year that we've actually

00:01:01,410 --> 00:01:06,750
migrated to hacker so hack is a

00:01:04,170 --> 00:01:09,720
different language that also runs on h h

00:01:06,750 --> 00:01:12,689
vm its PHP but with more datatypes

00:01:09,720 --> 00:01:14,010
essentially and a static type checker so

00:01:12,689 --> 00:01:15,930
what does that mean static type checker

00:01:14,010 --> 00:01:17,729
it means that it's able to check your

00:01:15,930 --> 00:01:19,020
code and look for errors without

00:01:17,729 --> 00:01:21,150
actually running the code so it can

00:01:19,020 --> 00:01:23,400
analyze all possible code paths in the

00:01:21,150 --> 00:01:25,439
code so this is not about performance

00:01:23,400 --> 00:01:27,590
this is about writing PHP safer having

00:01:25,439 --> 00:01:30,600
less bugs and having more confidence and

00:01:27,590 --> 00:01:32,250
so you could say that we came to h HT m

00:01:30,600 --> 00:01:33,540
per for performance but we stayed

00:01:32,250 --> 00:01:36,900
because of hacker because of the type

00:01:33,540 --> 00:01:39,119
safety today obviously PHP 7 got much

00:01:36,900 --> 00:01:40,650
faster and PHP continues to get faster

00:01:39,119 --> 00:01:42,090
so I'm not going to focus too much on

00:01:40,650 --> 00:01:44,399
the performance differences between H

00:01:42,090 --> 00:01:45,840
HTM and PHP in this talk really focus

00:01:44,399 --> 00:01:47,909
about the developer experience of

00:01:45,840 --> 00:01:50,250
writing half code so since that

00:01:47,909 --> 00:01:51,990
migration in early 2017 we've been

00:01:50,250 --> 00:01:54,689
adding types to our code base and making

00:01:51,990 --> 00:01:56,250
more usage of hack and preparing for the

00:01:54,689 --> 00:01:58,259
newest version of HTM which no longer

00:01:56,250 --> 00:02:02,159
supports a PHP code at all it only runs

00:01:58,259 --> 00:02:03,659
hack so before I talk about our journey

00:02:02,159 --> 00:02:06,420
let's talk a little bit about what hack

00:02:03,659 --> 00:02:08,009
actually is and how it works the

00:02:06,420 --> 00:02:10,170
fundamental experience of writing hack

00:02:08,009 --> 00:02:10,530
code is interacting with a static type

00:02:10,170 --> 00:02:13,290
checker

00:02:10,530 --> 00:02:13,980
it's called HH client it's a binary that

00:02:13,290 --> 00:02:15,629
you can invoke on the

00:02:13,980 --> 00:02:16,680
command-line but the way we mostly use

00:02:15,629 --> 00:02:19,290
it is through this thing called the

00:02:16,680 --> 00:02:21,150
language server protocol and this will

00:02:19,290 --> 00:02:23,670
interact with text editors like vs code

00:02:21,150 --> 00:02:24,959
and them and it's a server but it

00:02:23,670 --> 00:02:26,940
doesn't run on another service still

00:02:24,959 --> 00:02:29,640
runs on your computer so what this thing

00:02:26,940 --> 00:02:31,530
is is it's watching the file system for

00:02:29,640 --> 00:02:33,959
changes to the code it has a data model

00:02:31,530 --> 00:02:36,629
about the code it understands the entire

00:02:33,959 --> 00:02:38,849
code base all at once and so if you make

00:02:36,629 --> 00:02:40,200
a change to a function and maybe you

00:02:38,849 --> 00:02:42,000
change its return type in a way that

00:02:40,200 --> 00:02:43,829
would break some of the call sites you

00:02:42,000 --> 00:02:45,870
instantly get feedback on all the

00:02:43,829 --> 00:02:48,000
breakages even if it has a hundred call

00:02:45,870 --> 00:02:49,680
sites across the entire code base within

00:02:48,000 --> 00:02:51,690
milliseconds before you even hit save

00:02:49,680 --> 00:02:53,489
you get that feedback on what will be

00:02:51,690 --> 00:02:55,530
broken by that change and that's coming

00:02:53,489 --> 00:02:57,420
from the language server protocol where

00:02:55,530 --> 00:02:59,129
happend sends this information to your

00:02:57,420 --> 00:03:01,370
editor and says please display these

00:02:59,129 --> 00:03:03,720
errors in these files on these lines

00:03:01,370 --> 00:03:05,819
additionally the text editor can ask

00:03:03,720 --> 00:03:07,500
hack questions it can say I'm mousing

00:03:05,819 --> 00:03:09,359
over this variable right now what is the

00:03:07,500 --> 00:03:11,280
type of this variable or where is this

00:03:09,359 --> 00:03:14,519
function defined so on and so forth so

00:03:11,280 --> 00:03:16,170
that's the language server protocol so

00:03:14,519 --> 00:03:17,670
this is our first example of some hack

00:03:16,170 --> 00:03:20,220
code and you probably notice that it

00:03:17,670 --> 00:03:22,200
just looks like PHP hack still feels

00:03:20,220 --> 00:03:23,519
very much like PHP pretty much the only

00:03:22,200 --> 00:03:26,010
difference here is that first line is H

00:03:23,519 --> 00:03:27,660
H instead of PHP and we have a very

00:03:26,010 --> 00:03:29,069
simple example of a type error here we

00:03:27,660 --> 00:03:31,230
have a function that wants an integer

00:03:29,069 --> 00:03:33,030
and we're passing it a string and that's

00:03:31,230 --> 00:03:34,560
a type error so this screenshot is from

00:03:33,030 --> 00:03:36,450
Visual Studio code we're showing the

00:03:34,560 --> 00:03:37,709
output of this error and you can see in

00:03:36,450 --> 00:03:40,079
the bottom the error has multiple parts

00:03:37,709 --> 00:03:41,669
to it it says invalid argument this is

00:03:40,079 --> 00:03:43,530
an int it's incompatible with a string

00:03:41,669 --> 00:03:44,730
and it gives you the line numbers for

00:03:43,530 --> 00:03:47,160
where these errors are occurring so it's

00:03:44,730 --> 00:03:48,840
a multi-part error it tells you how it

00:03:47,160 --> 00:03:50,459
figured out that there was a problem so

00:03:48,840 --> 00:03:51,780
line three this isn't int that's the

00:03:50,459 --> 00:03:53,910
type definition of the function we're

00:03:51,780 --> 00:03:55,620
calling and line eight this is a string

00:03:53,910 --> 00:03:57,930
that's the type of the local variable

00:03:55,620 --> 00:03:59,519
that was inferred in my experience these

00:03:57,930 --> 00:04:01,290
breadcrumbs of information that you get

00:03:59,519 --> 00:04:02,639
with these errors I mean that even on

00:04:01,290 --> 00:04:03,660
someone's first time writing hack code

00:04:02,639 --> 00:04:05,099
where they don't really understand the

00:04:03,660 --> 00:04:06,510
type system yet they're still able to

00:04:05,099 --> 00:04:09,329
figure out and fix these issues right

00:04:06,510 --> 00:04:11,190
away so this one is pretty trivial fix

00:04:09,329 --> 00:04:13,709
and we can just change it to an integer

00:04:11,190 --> 00:04:15,120
and now hack is happy you probably have

00:04:13,709 --> 00:04:16,859
this experience if you've used an editor

00:04:15,120 --> 00:04:18,060
like phpstorm how many of you are using

00:04:16,859 --> 00:04:21,870
a text editor where you get this kind of

00:04:18,060 --> 00:04:23,280
information a lot of you okay so what I

00:04:21,870 --> 00:04:25,500
want to focus on is the features that

00:04:23,280 --> 00:04:27,090
hacks type system has that PHP does not

00:04:25,500 --> 00:04:27,950
and the first one that comes to mind for

00:04:27,090 --> 00:04:30,900
me is Jan

00:04:27,950 --> 00:04:32,880
so generics are a style of programming

00:04:30,900 --> 00:04:35,130
in which you write code in terms of

00:04:32,880 --> 00:04:36,960
types to be specified later so you have

00:04:35,130 --> 00:04:38,340
functions and classes and data

00:04:36,960 --> 00:04:40,590
structures that can work with multiple

00:04:38,340 --> 00:04:42,600
different types but you specify the type

00:04:40,590 --> 00:04:44,670
when you use it and they're denoted by

00:04:42,600 --> 00:04:46,920
this angle bracket T this type parameter

00:04:44,670 --> 00:04:49,020
so here's an example of a stack data

00:04:46,920 --> 00:04:50,910
structure class stack it has this angle

00:04:49,020 --> 00:04:52,620
bracket T in it this capital T is a type

00:04:50,910 --> 00:04:54,030
parameter and you'll see that parameter

00:04:52,620 --> 00:04:56,190
repeated several times throughout the

00:04:54,030 --> 00:04:57,600
classes body it's in the push function

00:04:56,190 --> 00:04:59,580
it's the arguments of the push function

00:04:57,600 --> 00:05:01,650
it's in the pop function so the same

00:04:59,580 --> 00:05:03,330
data that you push on to the stack you

00:05:01,650 --> 00:05:06,150
pop that same data off the stack same

00:05:03,330 --> 00:05:08,730
data type now the pop function returns a

00:05:06,150 --> 00:05:10,260
nullable T because if you have a stack

00:05:08,730 --> 00:05:13,080
that's empty and you try to pop you will

00:05:10,260 --> 00:05:14,580
get nothing back you'll get no so this

00:05:13,080 --> 00:05:16,050
stack data structure could work with any

00:05:14,580 --> 00:05:17,910
type you could have a stack of intz a

00:05:16,050 --> 00:05:20,400
stack of strings a stack of arrays a

00:05:17,910 --> 00:05:23,340
stack of classes and that's what makes

00:05:20,400 --> 00:05:24,840
this a generic data structure but of

00:05:23,340 --> 00:05:26,130
course you can do this in PHP without

00:05:24,840 --> 00:05:27,650
just putting that T there so what does

00:05:26,130 --> 00:05:30,480
this actually provide for us

00:05:27,650 --> 00:05:32,669
so the point of this is the static type

00:05:30,480 --> 00:05:35,040
checking if we have a specific stack

00:05:32,669 --> 00:05:37,169
that is a stack of intz in this example

00:05:35,040 --> 00:05:38,520
we want a stack of integers and we try

00:05:37,169 --> 00:05:40,410
to push the value 5 on to that stack

00:05:38,520 --> 00:05:41,850
that's fine but if we try to push a

00:05:40,410 --> 00:05:43,560
string into the stack hack will tell us

00:05:41,850 --> 00:05:45,450
hey that's invalid this argument is a

00:05:43,560 --> 00:05:46,979
string it's supposed to be an int so

00:05:45,450 --> 00:05:48,630
this is where the generics actually help

00:05:46,979 --> 00:05:50,190
us if I define this data structure

00:05:48,630 --> 00:05:51,900
without the generics it could contain

00:05:50,190 --> 00:05:53,729
any type but I wouldn't be able to say

00:05:51,900 --> 00:05:56,550
what I want this specific stack to

00:05:53,729 --> 00:05:58,770
contain now I don't have to actually

00:05:56,550 --> 00:06:00,630
explicitly specify those generics even I

00:05:58,770 --> 00:06:02,729
can let them be inferred by the type

00:06:00,630 --> 00:06:05,520
system so I can just say S is a new

00:06:02,729 --> 00:06:07,560
stack push the value 5 into it and if I

00:06:05,520 --> 00:06:09,450
mouse over that X variable and ask hack

00:06:07,560 --> 00:06:11,550
what is the type of this variable it's

00:06:09,450 --> 00:06:13,770
able to infer that the T type for this

00:06:11,550 --> 00:06:15,270
stack is int which means that when we

00:06:13,770 --> 00:06:18,060
popped it off of it we get a nullable

00:06:15,270 --> 00:06:19,800
int because pop is a nullable T so the

00:06:18,060 --> 00:06:21,870
generics can be inferred you don't have

00:06:19,800 --> 00:06:23,550
to explicitly specify them this is

00:06:21,870 --> 00:06:26,550
different from something like Java for

00:06:23,550 --> 00:06:28,500
example in fact this will even work with

00:06:26,550 --> 00:06:29,910
multiple types we can have a stack and

00:06:28,500 --> 00:06:31,650
then we can put an int and a string in

00:06:29,910 --> 00:06:33,600
it and heck we'll figure this out it

00:06:31,650 --> 00:06:35,340
still feels like PHP it's still kind of

00:06:33,600 --> 00:06:37,020
a dynamically typed language at runtime

00:06:35,340 --> 00:06:38,669
so you can have these things that

00:06:37,020 --> 00:06:40,919
contain contain both instance strings

00:06:38,669 --> 00:06:41,400
and hexes ok cool it looks like this is

00:06:40,919 --> 00:06:43,590
a stack

00:06:41,400 --> 00:06:47,639
int or string in it this is sometimes

00:06:43,590 --> 00:06:49,350
called a union type okay so not having

00:06:47,639 --> 00:06:51,600
to explicitly declare these generics and

00:06:49,350 --> 00:06:53,070
letting the be inferred is somewhat

00:06:51,600 --> 00:06:54,449
useful in these classes but it's really

00:06:53,070 --> 00:06:58,080
useful when you start using generics

00:06:54,449 --> 00:07:00,210
with arrays so in PHP we have two kinds

00:06:58,080 --> 00:07:02,520
of arrays we have the associative array

00:07:00,210 --> 00:07:05,190
or also also called a hash table or map

00:07:02,520 --> 00:07:08,280
or dictionary and we have the list like

00:07:05,190 --> 00:07:09,840
or vector like array and in PHP we only

00:07:08,280 --> 00:07:11,370
have one word that we can use to

00:07:09,840 --> 00:07:13,050
describe that just array we can't really

00:07:11,370 --> 00:07:14,669
say much more about what's in it so we

00:07:13,050 --> 00:07:16,770
often use doc blocks above functions to

00:07:14,669 --> 00:07:20,430
describe the contents of an array in

00:07:16,770 --> 00:07:22,410
hack we can use generics to annotate the

00:07:20,430 --> 00:07:24,419
kind of array that we have so we have in

00:07:22,410 --> 00:07:26,190
the first example an array string comma

00:07:24,419 --> 00:07:28,139
string that means string keys string

00:07:26,190 --> 00:07:30,810
values in the second example we only

00:07:28,139 --> 00:07:32,250
have to specify the value type because

00:07:30,810 --> 00:07:34,229
we have a list like a rice so the keys

00:07:32,250 --> 00:07:37,289
are implicitly going to be integers

00:07:34,229 --> 00:07:38,940
increasing from zero okay and Haque is

00:07:37,289 --> 00:07:41,250
able to understand these types and

00:07:38,940 --> 00:07:42,389
differentiate between them so here we

00:07:41,250 --> 00:07:43,979
have an example where we have a function

00:07:42,389 --> 00:07:45,780
that wants an associative array and a

00:07:43,979 --> 00:07:48,000
function that wants a list array and we

00:07:45,780 --> 00:07:49,919
have this variable on line 7 that we

00:07:48,000 --> 00:07:51,750
declare that is a list like array and

00:07:49,919 --> 00:07:54,180
Haque infers based on the shape of that

00:07:51,750 --> 00:07:55,500
variable ok this is a list like array so

00:07:54,180 --> 00:07:57,300
you can't pass it to a function that

00:07:55,500 --> 00:07:58,860
wants an associative array so this is

00:07:57,300 --> 00:07:59,880
where inferring those generics is

00:07:58,860 --> 00:08:02,280
important because I don't have to

00:07:59,880 --> 00:08:04,500
declare this is an array of strings that

00:08:02,280 --> 00:08:06,539
is vector like it just didn't first that

00:08:04,500 --> 00:08:08,580
and so it's able to tell me that this is

00:08:06,539 --> 00:08:10,199
a potential problem so this helps

00:08:08,580 --> 00:08:12,690
because PHP array is having these two

00:08:10,199 --> 00:08:14,070
behaviors can be very problematic in in

00:08:12,690 --> 00:08:15,870
that there's some functions that will

00:08:14,070 --> 00:08:17,400
behave differently on integer key to

00:08:15,870 --> 00:08:19,169
rays and string key to race like array

00:08:17,400 --> 00:08:20,599
merge is one that comes up a lot I've

00:08:19,169 --> 00:08:22,889
had a lot of bugs with that in the past

00:08:20,599 --> 00:08:24,330
there's another problem we have with PHP

00:08:22,889 --> 00:08:26,190
arrays from the perspective of a type

00:08:24,330 --> 00:08:28,680
system which is that when you try to get

00:08:26,190 --> 00:08:31,139
a key out of a PHP array you could

00:08:28,680 --> 00:08:32,700
always get back a null because when PHP

00:08:31,139 --> 00:08:34,919
when you try to access a key that's not

00:08:32,700 --> 00:08:36,690
there PHP will log on notice and then it

00:08:34,919 --> 00:08:37,860
will just give you no so from the

00:08:36,690 --> 00:08:39,419
perspective of a type system you should

00:08:37,860 --> 00:08:42,120
treat any value you get out of an array

00:08:39,419 --> 00:08:43,830
as potentially null but that's very

00:08:42,120 --> 00:08:45,000
inconvenient because you know most of

00:08:43,830 --> 00:08:47,339
the time that the data is there that

00:08:45,000 --> 00:08:48,870
you're looking for and so if it made you

00:08:47,339 --> 00:08:51,029
do that you would kind of not want to

00:08:48,870 --> 00:08:52,500
use it at all and so what other

00:08:51,029 --> 00:08:53,940
languages do for this is they will throw

00:08:52,500 --> 00:08:54,930
an exception if you try to access a key

00:08:53,940 --> 00:08:56,220
that's not there

00:08:54,930 --> 00:08:58,410
Hach didn't want to make that change to

00:08:56,220 --> 00:09:00,450
raise because that would be a backwards

00:08:58,410 --> 00:09:01,980
incompatible behavior so instead they

00:09:00,450 --> 00:09:03,899
made new data structures we have the

00:09:01,980 --> 00:09:05,880
dict and the Veck they're a lot like

00:09:03,899 --> 00:09:07,680
those associative array and list like

00:09:05,880 --> 00:09:09,390
array but they formalize the difference

00:09:07,680 --> 00:09:10,890
between those two types and they're

00:09:09,390 --> 00:09:11,910
stricter about their data types so if

00:09:10,890 --> 00:09:13,980
you try to access a key that doesn't

00:09:11,910 --> 00:09:15,480
exist it throws an exception which means

00:09:13,980 --> 00:09:17,430
now you know if you get a value out of

00:09:15,480 --> 00:09:19,140
that array it is a string it's not going

00:09:17,430 --> 00:09:22,890
to be known so this helps make the type

00:09:19,140 --> 00:09:24,810
system more sound there's another kind

00:09:22,890 --> 00:09:26,610
of array that we often see in PHP code

00:09:24,810 --> 00:09:28,290
where we have different data types in

00:09:26,610 --> 00:09:30,480
the array here we have an array that has

00:09:28,290 --> 00:09:33,060
an integer type a string and even a

00:09:30,480 --> 00:09:34,950
complex type and kind of the best we can

00:09:33,060 --> 00:09:38,279
do from a type perspective is to say the

00:09:34,950 --> 00:09:39,720
values are mixed but mixed is not a very

00:09:38,279 --> 00:09:41,610
useful type annotation from the

00:09:39,720 --> 00:09:43,290
perspective of a static type system what

00:09:41,610 --> 00:09:44,640
can you do with mixed you can't really

00:09:43,290 --> 00:09:46,589
do anything with it and if you have to

00:09:44,640 --> 00:09:48,360
pass it to something and use it like an

00:09:46,589 --> 00:09:49,860
integer or like a string you'll have to

00:09:48,360 --> 00:09:52,770
assert on that type before you can use

00:09:49,860 --> 00:09:53,820
it which is also very inconvenient so it

00:09:52,770 --> 00:09:56,550
turns out there's a better way to deal

00:09:53,820 --> 00:09:58,380
with this we have shapes in hacker and

00:09:56,550 --> 00:10:00,000
shapes are a new data structure that

00:09:58,380 --> 00:10:02,850
represent an array with a known

00:10:00,000 --> 00:10:04,560
structure so you know what keys you

00:10:02,850 --> 00:10:06,959
expect to be there you know what values

00:10:04,560 --> 00:10:09,300
what the type should be and some keys

00:10:06,959 --> 00:10:10,860
can be optional as well at runtime these

00:10:09,300 --> 00:10:12,540
things are still just PHP arrays which

00:10:10,860 --> 00:10:14,550
is also very convenient because if you

00:10:12,540 --> 00:10:16,709
get some data back from an API call or

00:10:14,550 --> 00:10:18,839
from a JSON decode you can assert that

00:10:16,709 --> 00:10:21,420
it matches a shape structure where it's

00:10:18,839 --> 00:10:23,310
even just an array so what if shapes

00:10:21,420 --> 00:10:25,470
look like this is our shape definitions

00:10:23,310 --> 00:10:27,150
their type definitions where we have the

00:10:25,470 --> 00:10:28,470
name of a shape and then we have a list

00:10:27,150 --> 00:10:30,029
of the keys that can be present and

00:10:28,470 --> 00:10:31,920
there's kind of two very common examples

00:10:30,029 --> 00:10:33,900
of where we would use this the first one

00:10:31,920 --> 00:10:35,790
this is the options for an HTTP POST

00:10:33,900 --> 00:10:37,470
function so you're trying to do a post

00:10:35,790 --> 00:10:38,820
request and if you're writing a helper

00:10:37,470 --> 00:10:39,959
library where you're doing post requests

00:10:38,820 --> 00:10:41,490
one thing you realize is there are a

00:10:39,959 --> 00:10:43,230
million different ways you can do a post

00:10:41,490 --> 00:10:45,000
requests sometimes you're going to want

00:10:43,230 --> 00:10:47,220
to pass form data sometimes we're going

00:10:45,000 --> 00:10:48,480
to want to pass a JSON payload sometimes

00:10:47,220 --> 00:10:49,829
you will want to be overriding these or

00:10:48,480 --> 00:10:51,779
agent so you end up with a lot of

00:10:49,829 --> 00:10:52,890
optional arguments and you don't want to

00:10:51,779 --> 00:10:54,120
make each one of those into separate

00:10:52,890 --> 00:10:55,560
function arguments so you usually make

00:10:54,120 --> 00:10:57,870
something like an array where you can

00:10:55,560 --> 00:10:59,700
pass those arguments in but the problem

00:10:57,870 --> 00:11:00,990
is that how do you specify which keys

00:10:59,700 --> 00:11:02,880
are valid in that array and what their

00:11:00,990 --> 00:11:04,800
data type should be well you use a doc

00:11:02,880 --> 00:11:06,570
block but this thing can actually be

00:11:04,800 --> 00:11:08,610
statically type checked with a shape so

00:11:06,570 --> 00:11:10,019
when we're passing a key in there if we

00:11:08,610 --> 00:11:11,640
the name of the key or we passed the

00:11:10,019 --> 00:11:12,630
wrong data type it will complain and

00:11:11,640 --> 00:11:14,760
tell us you're not using the right

00:11:12,630 --> 00:11:15,810
options here so that's the use case for

00:11:14,760 --> 00:11:17,339
this first one we have all these

00:11:15,810 --> 00:11:19,290
optional fields with a question mark in

00:11:17,339 --> 00:11:20,880
front of them the second one is an

00:11:19,290 --> 00:11:23,250
example where we often have structured

00:11:20,880 --> 00:11:24,660
return types of a function the HDP

00:11:23,250 --> 00:11:27,660
functions whether it's a post or get

00:11:24,660 --> 00:11:29,130
will always return headers status code

00:11:27,660 --> 00:11:30,930
and a body they'll always return that

00:11:29,130 --> 00:11:32,910
and this allows us to describe what that

00:11:30,930 --> 00:11:34,649
return type is in terms of which keys

00:11:32,910 --> 00:11:36,300
will be present and what the data types

00:11:34,649 --> 00:11:37,769
of those keys will be so then when we

00:11:36,300 --> 00:11:39,690
use that function when we use that

00:11:37,769 --> 00:11:41,310
functions results in some code the type

00:11:39,690 --> 00:11:44,430
checker is aware of the values that are

00:11:41,310 --> 00:11:46,050
in there let's zoom in to how we

00:11:44,430 --> 00:11:49,290
actually use these optional keys with

00:11:46,050 --> 00:11:50,250
shapes so the way that we check the way

00:11:49,290 --> 00:11:51,510
that we use them is we have to first

00:11:50,250 --> 00:11:53,010
check that they exist because they're

00:11:51,510 --> 00:11:55,110
optional we use a built in function

00:11:53,010 --> 00:11:56,730
check that a shape key exists and then

00:11:55,110 --> 00:11:58,769
we can use it to for example build a

00:11:56,730 --> 00:12:00,300
query string and that's all well and

00:11:58,769 --> 00:12:03,300
good there's something subtle that's

00:12:00,300 --> 00:12:04,649
going on here though which is that the

00:12:03,300 --> 00:12:07,290
type system has learned something from

00:12:04,649 --> 00:12:09,329
this check that I did so this is again

00:12:07,290 --> 00:12:11,579
mousing over the value in Visual Studio

00:12:09,329 --> 00:12:13,350
code and saying what is the type of this

00:12:11,579 --> 00:12:15,959
thing so your mouse over options before

00:12:13,350 --> 00:12:17,670
the if statement and that form data key

00:12:15,959 --> 00:12:19,769
is optional because it's optional in the

00:12:17,670 --> 00:12:21,630
shape it might not be there but inside

00:12:19,769 --> 00:12:23,160
the scope of that if statement it is no

00:12:21,630 --> 00:12:24,810
longer optional because we have checked

00:12:23,160 --> 00:12:26,760
that it exists this is called type

00:12:24,810 --> 00:12:27,930
refinement so what the type system did

00:12:26,760 --> 00:12:29,579
is it learned something about the

00:12:27,930 --> 00:12:31,320
variable from the check that I did and

00:12:29,579 --> 00:12:32,970
now it has a more specific type and

00:12:31,320 --> 00:12:34,860
that's why I'm able to use that field

00:12:32,970 --> 00:12:36,240
and as soon as we exit the scope of that

00:12:34,860 --> 00:12:38,130
if statement on the code below there

00:12:36,240 --> 00:12:40,230
it's once again an optional field it

00:12:38,130 --> 00:12:41,730
might not be there so that's type

00:12:40,230 --> 00:12:43,769
refinement and heck we'll do this for

00:12:41,730 --> 00:12:45,810
any kinds of checks you do if you check

00:12:43,769 --> 00:12:48,510
for null if you throw exceptions check

00:12:45,810 --> 00:12:50,370
that something is a string so on and so

00:12:48,510 --> 00:12:52,199
forth it will track the types of

00:12:50,370 --> 00:12:53,310
variables as they flow through flow

00:12:52,199 --> 00:12:56,610
control they could be different types

00:12:53,310 --> 00:12:57,660
and it will keep track of all that let's

00:12:56,610 --> 00:13:00,750
talk a little bit about the standard

00:12:57,660 --> 00:13:02,130
library of PHP so PHP standard library

00:13:00,750 --> 00:13:04,860
gets some flack for a couple of issues

00:13:02,130 --> 00:13:07,140
one being the inconsistent arguing order

00:13:04,860 --> 00:13:08,399
I always have to look up array map an

00:13:07,140 --> 00:13:10,050
array filter and which one takes that

00:13:08,399 --> 00:13:11,850
array first if you don't have static

00:13:10,050 --> 00:13:14,310
analysis set up it's really easy to get

00:13:11,850 --> 00:13:15,870
this wrong and another common issue is

00:13:14,310 --> 00:13:17,610
that the built-in functions often will

00:13:15,870 --> 00:13:19,350
return either the data type you want or

00:13:17,610 --> 00:13:20,880
false and you have to check for both and

00:13:19,350 --> 00:13:22,290
from a type system perspective there's

00:13:20,880 --> 00:13:25,259
not a good data type that represents

00:13:22,290 --> 00:13:27,690
those two types there's another problem

00:13:25,259 --> 00:13:29,220
that I often see with PHP code which is

00:13:27,690 --> 00:13:30,509
we have things like this where we're

00:13:29,220 --> 00:13:32,389
calling a bunch of functions we're sort

00:13:30,509 --> 00:13:35,790
of composing function calls together and

00:13:32,389 --> 00:13:37,320
it's very hard to read for me so if you

00:13:35,790 --> 00:13:38,910
want to read this code you kind of have

00:13:37,320 --> 00:13:40,649
to start in the middle if say okay we

00:13:38,910 --> 00:13:42,509
have a file name or exploding it on

00:13:40,649 --> 00:13:44,399
slashes we're going to the end of that

00:13:42,509 --> 00:13:46,110
getting the last result or exploding

00:13:44,399 --> 00:13:47,550
that on dots and then we're keying into

00:13:46,110 --> 00:13:49,170
that and getting the first element of it

00:13:47,550 --> 00:13:50,699
and you're you're I have to jump all the

00:13:49,170 --> 00:13:52,079
way over to the other side to see that

00:13:50,699 --> 00:13:53,459
we're actually keying into it it's

00:13:52,079 --> 00:13:55,110
really easy to miss read this or not

00:13:53,459 --> 00:13:56,310
understand what the type of the data is

00:13:55,110 --> 00:13:58,019
that's going to come out of this and

00:13:56,310 --> 00:13:58,680
it's not super easy to refactor this in

00:13:58,019 --> 00:14:02,670
a way that feels

00:13:58,680 --> 00:14:04,139
ergonomic and readable so with hack

00:14:02,670 --> 00:14:05,370
standard library it has a new standard

00:14:04,139 --> 00:14:06,660
library you can still use the PHP

00:14:05,370 --> 00:14:09,029
standard library but has a new standard

00:14:06,660 --> 00:14:10,589
library that solves some of these

00:14:09,029 --> 00:14:12,750
problems so the primary argument of a

00:14:10,589 --> 00:14:13,949
function is always the first one things

00:14:12,750 --> 00:14:15,990
that would have return false now return

00:14:13,949 --> 00:14:18,180
null and everything that's name space

00:14:15,990 --> 00:14:19,620
it's easier to find the functions and

00:14:18,180 --> 00:14:20,639
this we have this pipeline operator

00:14:19,620 --> 00:14:22,860
that's the thing that I care most about

00:14:20,639 --> 00:14:25,680
here that lets us chain function calls

00:14:22,860 --> 00:14:27,329
so what does that look like this is that

00:14:25,680 --> 00:14:29,850
same example rewritten with the hack

00:14:27,329 --> 00:14:31,529
standard library so the magic here this

00:14:29,850 --> 00:14:33,360
is like a bash pipeline but the magic

00:14:31,529 --> 00:14:35,519
here is this double dollar sign which

00:14:33,360 --> 00:14:37,709
reference it refers to the results of

00:14:35,519 --> 00:14:39,810
the previous element of the pipeline so

00:14:37,709 --> 00:14:42,029
in our pipeline here we start with this

00:14:39,810 --> 00:14:43,380
file name and then we pipe it to the

00:14:42,029 --> 00:14:45,420
string split function which is like

00:14:43,380 --> 00:14:47,040
explode we pipe that to the last

00:14:45,420 --> 00:14:49,139
function so we get the last element of

00:14:47,040 --> 00:14:50,850
that then we pipe that to stir split

00:14:49,139 --> 00:14:52,110
again to get the dots and then we get

00:14:50,850 --> 00:14:54,600
the first element that so it's the same

00:14:52,110 --> 00:14:55,079
code this takes some getting used to the

00:14:54,600 --> 00:14:56,220
syntax

00:14:55,079 --> 00:14:57,839
I honestly avoided it for about the

00:14:56,220 --> 00:15:00,029
first six months because I just didn't

00:14:57,839 --> 00:15:01,350
quite understand it but the advantage to

00:15:00,029 --> 00:15:03,389
it is that you read the code in the

00:15:01,350 --> 00:15:04,889
order that it runs so you're able to

00:15:03,389 --> 00:15:06,269
make sense of the way that the computer

00:15:04,889 --> 00:15:06,889
will actually process the code that you

00:15:06,269 --> 00:15:10,620
have written

00:15:06,889 --> 00:15:13,709
that's very helpful another feature I

00:15:10,620 --> 00:15:15,750
want to highlight with hacks HSL that

00:15:13,709 --> 00:15:18,089
hack standard library is this regular

00:15:15,750 --> 00:15:19,829
expressions that are typed so we have

00:15:18,089 --> 00:15:21,810
these strings these are e prefixed

00:15:19,829 --> 00:15:23,310
strings sort of like Python we have a

00:15:21,810 --> 00:15:25,500
regular expression string it's a special

00:15:23,310 --> 00:15:27,089
kind of string and hack will statically

00:15:25,500 --> 00:15:28,470
validate the syntax of that regular

00:15:27,089 --> 00:15:30,240
expression so it knows that it's a valid

00:15:28,470 --> 00:15:32,339
regular expression it will fail the type

00:15:30,240 --> 00:15:33,839
checker otherwise and we'll also inspect

00:15:32,339 --> 00:15:35,660
the contents of the regular expression

00:15:33,839 --> 00:15:37,220
and it will understand which captured

00:15:35,660 --> 00:15:39,380
groups exist both named and numbered

00:15:37,220 --> 00:15:41,600
capture groups in there and then the

00:15:39,380 --> 00:15:44,120
type system is aware of what the type of

00:15:41,600 --> 00:15:45,800
that return will be so here it says this

00:15:44,120 --> 00:15:47,840
regex match it has a subgroup called

00:15:45,800 --> 00:15:50,120
word and that means that the return of

00:15:47,840 --> 00:15:51,920
this will be a vector of shapes that has

00:15:50,120 --> 00:15:53,990
an element called word and so then I can

00:15:51,920 --> 00:15:55,040
use that element if I try to access an

00:15:53,990 --> 00:15:57,260
element that doesn't exist in that

00:15:55,040 --> 00:15:58,670
capture groups it will complain for me

00:15:57,260 --> 00:16:00,260
this was life-changing in terms of

00:15:58,670 --> 00:16:01,910
writing regex because before I would

00:16:00,260 --> 00:16:03,500
always have to kind of var dump the

00:16:01,910 --> 00:16:04,760
output of regex match and see what it

00:16:03,500 --> 00:16:06,590
actually looks like before I used it

00:16:04,760 --> 00:16:10,460
because it was always different this

00:16:06,590 --> 00:16:12,830
makes that much better one last feature

00:16:10,460 --> 00:16:16,190
pack I wanna highlight is xhp this is a

00:16:12,830 --> 00:16:18,260
way to build type safe HTML in hack so

00:16:16,190 --> 00:16:21,290
if you've ever seen reacts JSX

00:16:18,260 --> 00:16:23,090
it's very similar this was before JSX at

00:16:21,290 --> 00:16:24,740
Facebook and inspired JSX

00:16:23,090 --> 00:16:26,750
this was actually originally created as

00:16:24,740 --> 00:16:28,790
a PHP extension even before hack existed

00:16:26,750 --> 00:16:31,610
what this gives us is a way to build

00:16:28,790 --> 00:16:34,190
HTML with type safety so it knows for

00:16:31,610 --> 00:16:35,960
all the built in html5 elements if they

00:16:34,190 --> 00:16:37,310
exist and what the names are of all the

00:16:35,960 --> 00:16:39,050
attributes they accept and what the

00:16:37,310 --> 00:16:41,270
types are of those attributes so we get

00:16:39,050 --> 00:16:43,520
validation on that we get automatic XSS

00:16:41,270 --> 00:16:45,140
escaping and we also get all those

00:16:43,520 --> 00:16:46,790
features for custom classes that we

00:16:45,140 --> 00:16:48,860
write so we're able to compose built-in

00:16:46,790 --> 00:16:50,240
HTML elements with our own classes and

00:16:48,860 --> 00:16:51,680
this was powerful enough that we have

00:16:50,240 --> 00:16:55,040
all of slack server-side rendered HTML

00:16:51,680 --> 00:16:56,270
using this note ok there's a lot more

00:16:55,040 --> 00:16:58,100
with hack that I don't have time to talk

00:16:56,270 --> 00:16:59,600
about in particular a single way to say

00:16:58,100 --> 00:17:01,280
we do multiple things in parallel kind

00:16:59,600 --> 00:17:03,020
of requires a lengthy explanation but I

00:17:01,280 --> 00:17:06,830
want to get on to slacks journey would

00:17:03,020 --> 00:17:08,990
happen so this was kind of our pathway

00:17:06,830 --> 00:17:11,210
to migrating to hacker and I'm gonna go

00:17:08,990 --> 00:17:12,230
through this timeline one element of

00:17:11,210 --> 00:17:15,200
time and talk about what was interesting

00:17:12,230 --> 00:17:16,910
along the way so the first part of the

00:17:15,200 --> 00:17:19,910
migration was to just find and replace

00:17:16,910 --> 00:17:22,520
PHP with HH and it was actually just

00:17:19,910 --> 00:17:24,860
that easy just one side one liner and

00:17:22,520 --> 00:17:26,570
this HH without the strict after it is

00:17:24,860 --> 00:17:27,800
hacked more permissive mode where it

00:17:26,570 --> 00:17:28,940
doesn't require everything is typed

00:17:27,800 --> 00:17:30,500
it'll let you do a lot of the things

00:17:28,940 --> 00:17:33,050
that you would do in PHP it's it's meant

00:17:30,500 --> 00:17:33,440
for this migration and that was easy

00:17:33,050 --> 00:17:35,570
right

00:17:33,440 --> 00:17:36,830
but of course hack had a lot to say

00:17:35,570 --> 00:17:38,660
about the code as soon as we did this

00:17:36,830 --> 00:17:40,370
there were many errors that it pointed

00:17:38,660 --> 00:17:42,350
out and so we couldn't just kind of run

00:17:40,370 --> 00:17:44,660
with this and say git commit total fix

00:17:42,350 --> 00:17:46,100
it later what we did is we started

00:17:44,660 --> 00:17:48,040
fixing the bugs that had told us about

00:17:46,100 --> 00:17:49,750
and there's kind of two main categories

00:17:48,040 --> 00:17:51,010
there's actual hundreds of bugs

00:17:49,750 --> 00:17:53,230
incredible number of bugs that it

00:17:51,010 --> 00:17:54,790
discovered and there are also cases

00:17:53,230 --> 00:17:56,350
where just the type information that's

00:17:54,790 --> 00:17:57,730
available to the type checker makes it

00:17:56,350 --> 00:18:00,160
think there might be a problem in

00:17:57,730 --> 00:18:02,290
practice will not be a problem and so we

00:18:00,160 --> 00:18:03,940
kind of fictive divided these up into

00:18:02,290 --> 00:18:06,910
two categories and fix the ones by hand

00:18:03,940 --> 00:18:08,740
that we could and there's also automated

00:18:06,910 --> 00:18:10,300
tooling that enables the migration so

00:18:08,740 --> 00:18:11,980
for some of the things that are

00:18:10,300 --> 00:18:13,570
different between hack and PHP the

00:18:11,980 --> 00:18:15,700
tooling will just transform the code to

00:18:13,570 --> 00:18:17,620
conform to that for example adding a

00:18:15,700 --> 00:18:19,180
leading slash to any code that's in the

00:18:17,620 --> 00:18:20,620
namespace that calls route namespace

00:18:19,180 --> 00:18:23,440
functions it'll just handle that for you

00:18:20,620 --> 00:18:25,120
and the last the worst case scenario is

00:18:23,440 --> 00:18:26,380
we can just say to hack our okay I want

00:18:25,120 --> 00:18:27,700
to suppress this error so you just put a

00:18:26,380 --> 00:18:29,830
comment above the line that's throwing

00:18:27,700 --> 00:18:31,570
an error you say I want to fix this

00:18:29,830 --> 00:18:33,880
later and hack will stop complaining

00:18:31,570 --> 00:18:35,680
about that so we use these three

00:18:33,880 --> 00:18:37,180
strategies to get rid of all the hackers

00:18:35,680 --> 00:18:39,370
and we would commit the code

00:18:37,180 --> 00:18:40,990
incrementally so basically hack off I

00:18:39,370 --> 00:18:42,820
some files and then once they're passing

00:18:40,990 --> 00:18:44,320
the type checker commits them and then

00:18:42,820 --> 00:18:46,570
keep doing that as we as we would

00:18:44,320 --> 00:18:48,850
incrementally do the code base and we

00:18:46,570 --> 00:18:50,170
did this with a CI test setup and

00:18:48,850 --> 00:18:51,670
continuous integration test that was

00:18:50,170 --> 00:18:52,960
running the type checker so that we

00:18:51,670 --> 00:18:54,700
would not commit any code that doesn't

00:18:52,960 --> 00:18:56,020
pass the type checker so in this way

00:18:54,700 --> 00:18:58,060
were able to slowly and gradually

00:18:56,020 --> 00:18:58,750
migrate all of our code to be conformant

00:18:58,060 --> 00:19:00,640
and be hacker

00:18:58,750 --> 00:19:01,960
there's one other piece that we had to

00:19:00,640 --> 00:19:04,510
deal with before we really started using

00:19:01,960 --> 00:19:06,580
hack syntax more which was our linter we

00:19:04,510 --> 00:19:08,110
were using PHP code sniffer how many of

00:19:06,580 --> 00:19:11,560
you have ever written a PHP code sniffer

00:19:08,110 --> 00:19:13,180
lint rule not too many the way that they

00:19:11,560 --> 00:19:15,610
work is you have to operate on this

00:19:13,180 --> 00:19:17,170
stream of tokens and essentially every

00:19:15,610 --> 00:19:19,120
lint rule that you write is a mini PHP

00:19:17,170 --> 00:19:20,800
parser we had a lot of custom lint rolls

00:19:19,120 --> 00:19:22,330
both first style things and also for

00:19:20,800 --> 00:19:24,270
kind of trying to prevent bugs it was

00:19:22,330 --> 00:19:27,100
our first foray into static analysis and

00:19:24,270 --> 00:19:29,470
with hack there's a new tool that uses

00:19:27,100 --> 00:19:30,880
an abstract abstract syntax tree a PHP

00:19:29,470 --> 00:19:32,830
also has an abstract syntax tree now

00:19:30,880 --> 00:19:34,030
it's basically a more structured way of

00:19:32,830 --> 00:19:35,980
looking at our code so rather than

00:19:34,030 --> 00:19:38,020
looking at one token at a time you can

00:19:35,980 --> 00:19:39,670
look at expressions as a holistic thing

00:19:38,020 --> 00:19:41,080
and understand which elements exists in

00:19:39,670 --> 00:19:42,610
those expressions and it allows you to

00:19:41,080 --> 00:19:44,500
write more rigorous linters with less

00:19:42,610 --> 00:19:46,450
code and we also are able to use it for

00:19:44,500 --> 00:19:49,150
those migrations where migrating code

00:19:46,450 --> 00:19:50,800
from one format to another so once we

00:19:49,150 --> 00:19:52,480
did this we were at the point were like

00:19:50,800 --> 00:19:54,160
okay we're ready to use hack again a lot

00:19:52,480 --> 00:19:56,260
more right there's one more thing we had

00:19:54,160 --> 00:19:58,060
to do actually hacker does not type

00:19:56,260 --> 00:19:59,320
check code that is at the top level

00:19:58,060 --> 00:20:01,549
anything that's not inside of a function

00:19:59,320 --> 00:20:03,320
which was surprising to me and was

00:20:01,549 --> 00:20:05,749
I think to everyone who first learned

00:20:03,320 --> 00:20:07,789
this so why is that the reason is that

00:20:05,749 --> 00:20:09,559
in this context all variables are global

00:20:07,789 --> 00:20:11,840
so they could change at any time any

00:20:09,559 --> 00:20:12,999
point in the program and we can't really

00:20:11,840 --> 00:20:15,139
reason about what their type will be

00:20:12,999 --> 00:20:17,509
additionally code that's at the top

00:20:15,139 --> 00:20:19,429
level like this could run at any time as

00:20:17,509 --> 00:20:21,860
the as a consequence of Auto

00:20:19,429 --> 00:20:23,360
loading or the include statement and so

00:20:21,860 --> 00:20:24,769
that means hack also has no way of

00:20:23,360 --> 00:20:26,269
reasoning about what the call stack will

00:20:24,769 --> 00:20:28,279
be and what the state of the program

00:20:26,269 --> 00:20:29,570
will be when this code runs so because

00:20:28,279 --> 00:20:30,710
of those two things it just doesn't fit

00:20:29,570 --> 00:20:32,509
well into the data model they don't

00:20:30,710 --> 00:20:33,799
allow this and in the partial mode of

00:20:32,509 --> 00:20:35,450
hack they're just not type checked at

00:20:33,799 --> 00:20:37,220
all and it's strict mode this is not

00:20:35,450 --> 00:20:39,230
allowed it's a parsing error so we had

00:20:37,220 --> 00:20:40,460
to migrate all of our code into putting

00:20:39,230 --> 00:20:41,989
the code into functions this was

00:20:40,460 --> 00:20:43,639
especially relevant for controllers and

00:20:41,989 --> 00:20:45,139
CLI scripts and things like that and

00:20:43,639 --> 00:20:47,149
hack does provide this little entry

00:20:45,139 --> 00:20:49,249
point attribute that says if this is the

00:20:47,149 --> 00:20:51,499
entry point of the request run this main

00:20:49,249 --> 00:20:52,970
function when we start so it won't run

00:20:51,499 --> 00:20:54,529
that if it's the side-effect of an auto

00:20:52,970 --> 00:20:55,999
load but it will run it when it's the

00:20:54,529 --> 00:20:58,909
entry point of the request and that's

00:20:55,999 --> 00:21:00,379
what we want so this was our second

00:20:58,909 --> 00:21:01,580
round of kind of finding a bunch of

00:21:00,379 --> 00:21:03,049
errors that we had missed in the first

00:21:01,580 --> 00:21:04,369
round of hacker fighting things and

00:21:03,049 --> 00:21:06,139
finally we're at the point where like

00:21:04,369 --> 00:21:08,029
okay we're using hack everywhere what do

00:21:06,139 --> 00:21:10,249
we do next we need to actually get types

00:21:08,029 --> 00:21:11,389
into our code we were using PHP 5 5

00:21:10,249 --> 00:21:13,460
before that switch meant we basically

00:21:11,389 --> 00:21:14,659
had no type annotations we had no types

00:21:13,460 --> 00:21:18,019
for arguments we had no types for

00:21:14,659 --> 00:21:19,700
returns and we thought about what was

00:21:18,019 --> 00:21:21,200
the best way to do this in the place we

00:21:19,700 --> 00:21:23,450
wanted to go was to start with the

00:21:21,200 --> 00:21:24,980
database because the types come from the

00:21:23,450 --> 00:21:26,899
database and they bubble up into the

00:21:24,980 --> 00:21:28,460
code from there so if we can get types

00:21:26,899 --> 00:21:29,929
from the database that gives us a

00:21:28,460 --> 00:21:31,850
foundation to build on at types

00:21:29,929 --> 00:21:32,929
everywhere else we had a problem we

00:21:31,850 --> 00:21:34,489
wanted to solve when we were doing this

00:21:32,929 --> 00:21:36,889
though is that we were using my sequel I

00:21:34,489 --> 00:21:38,840
PHP my sequel I extension which returns

00:21:36,889 --> 00:21:40,369
all data as strings so even if you have

00:21:38,840 --> 00:21:42,710
an integer in the database you get a

00:21:40,369 --> 00:21:44,600
string back in PHP and that was that

00:21:42,710 --> 00:21:46,549
behavior was maintained in hack with my

00:21:44,600 --> 00:21:48,409
sequel I and so we wanted to migrate to

00:21:46,549 --> 00:21:50,239
their their custom my sequel client

00:21:48,409 --> 00:21:52,100
which is asynchronous so you can run

00:21:50,239 --> 00:21:54,649
multiple queries in parallel and also

00:21:52,100 --> 00:21:56,869
returns type data so this is an example

00:21:54,649 --> 00:21:58,909
before we have this table that has an ID

00:21:56,869 --> 00:22:00,859
that's an integer if we select from that

00:21:58,909 --> 00:22:03,200
table with my sequel I we still just get

00:22:00,859 --> 00:22:03,739
back strings this caused a lot of bugs

00:22:03,200 --> 00:22:05,539
for us

00:22:03,739 --> 00:22:07,309
I remember one in particular where where

00:22:05,539 --> 00:22:09,740
someone had a constant that represented

00:22:07,309 --> 00:22:11,570
the slack box user ID and it was an

00:22:09,740 --> 00:22:13,220
integer and they compared it with some

00:22:11,570 --> 00:22:15,510
data that came out of the database the

00:22:13,220 --> 00:22:16,980
database at signature but in PHP

00:22:15,510 --> 00:22:19,440
it was a string so they used a triple

00:22:16,980 --> 00:22:20,880
equal sign the comparison fails and for

00:22:19,440 --> 00:22:22,470
a little while that bug existed no one

00:22:20,880 --> 00:22:23,520
could talk to slack bot and this kind of

00:22:22,470 --> 00:22:25,440
stuff happened to us all the time

00:22:23,520 --> 00:22:26,370
because it just continually surprises

00:22:25,440 --> 00:22:27,840
everyone who's worked in other

00:22:26,370 --> 00:22:29,100
programming languages when they get a

00:22:27,840 --> 00:22:31,770
string back for something that's an INT

00:22:29,100 --> 00:22:33,570
in the database so we migrated to the

00:22:31,770 --> 00:22:36,210
async my sequel client to get type data

00:22:33,570 --> 00:22:37,890
this code example uses async await but

00:22:36,210 --> 00:22:39,360
the important thing here is this map

00:22:37,890 --> 00:22:41,220
Rose type function where the data we're

00:22:39,360 --> 00:22:43,320
getting back is typed and then we're

00:22:41,220 --> 00:22:46,680
able to assert that that type of row

00:22:43,320 --> 00:22:48,570
matches a shape that we have defined so

00:22:46,680 --> 00:22:50,670
how do we make these shapes we brought

00:22:48,570 --> 00:22:52,530
some code that parses the sequel create

00:22:50,670 --> 00:22:54,300
table statement and we generated a shape

00:22:52,530 --> 00:22:56,430
for every database table that we had and

00:22:54,300 --> 00:22:58,080
basically every my sequel column is

00:22:56,430 --> 00:23:00,390
either going to be an int or a string in

00:22:58,080 --> 00:23:02,730
half anyway so it was pretty easy to

00:23:00,390 --> 00:23:04,380
sort of bind these things to there and

00:23:02,730 --> 00:23:05,790
now we have these data types for all of

00:23:04,380 --> 00:23:07,590
our database tables so we have a place

00:23:05,790 --> 00:23:08,640
to start bringing types in and getting

00:23:07,590 --> 00:23:11,790
them up throughout the rest of the

00:23:08,640 --> 00:23:13,500
application there's one more way that we

00:23:11,790 --> 00:23:15,690
can get kind of the foundational types

00:23:13,500 --> 00:23:17,820
which is there's this thing an HH client

00:23:15,690 --> 00:23:19,080
called infer return type you can ask it

00:23:17,820 --> 00:23:20,370
what do you think the return type of

00:23:19,080 --> 00:23:22,830
this function is and it will try to

00:23:20,370 --> 00:23:24,450
guess and if it's returning a hard-coded

00:23:22,830 --> 00:23:25,920
value or the result of a comparison

00:23:24,450 --> 00:23:28,020
something that comes out of a built-in

00:23:25,920 --> 00:23:29,490
function that has a return type then you

00:23:28,020 --> 00:23:31,620
will often be able to get the return

00:23:29,490 --> 00:23:33,060
type for free and how others tell you

00:23:31,620 --> 00:23:34,920
this function returns a string if it

00:23:33,060 --> 00:23:36,300
doesn't know it'll just say - so what we

00:23:34,920 --> 00:23:37,470
did is we made a script that just ran

00:23:36,300 --> 00:23:39,240
this for every function in the codebase

00:23:37,470 --> 00:23:40,890
and said what's the return type we added

00:23:39,240 --> 00:23:43,740
all the easy ones and so now once again

00:23:40,890 --> 00:23:45,660
we have a big swath of types we focus on

00:23:43,740 --> 00:23:46,710
return types first not argument types

00:23:45,660 --> 00:23:49,050
and this is one of the things I learned

00:23:46,710 --> 00:23:50,670
doing this because return types give you

00:23:49,050 --> 00:23:52,800
a type that's useful in all of the call

00:23:50,670 --> 00:23:54,180
sites where as argument types are kind

00:23:52,800 --> 00:23:56,130
of only helping you within the functions

00:23:54,180 --> 00:23:57,150
body so you get more bang for your

00:23:56,130 --> 00:23:59,280
typing buck if you're thinking about

00:23:57,150 --> 00:24:01,890
adding types by focusing on return types

00:23:59,280 --> 00:24:03,960
first an argument type second both are

00:24:01,890 --> 00:24:05,880
still valuable we really wanted to deal

00:24:03,960 --> 00:24:07,920
with these untyped functions because we

00:24:05,880 --> 00:24:09,330
learned very early on that there's sort

00:24:07,920 --> 00:24:11,850
of this fundamental problem when you

00:24:09,330 --> 00:24:14,190
start adding types is that any data that

00:24:11,850 --> 00:24:16,440
comes from an untyped function has an

00:24:14,190 --> 00:24:18,060
untyped value an unresolved type or the

00:24:16,440 --> 00:24:19,290
any type which means you can pass it

00:24:18,060 --> 00:24:21,420
anywhere you can do anything with it

00:24:19,290 --> 00:24:23,700
hack it does this because it has to do

00:24:21,420 --> 00:24:24,870
this to enable the migration otherwise

00:24:23,700 --> 00:24:26,910
you would have to type all of your code

00:24:24,870 --> 00:24:28,440
at once you couldn't really migrate but

00:24:26,910 --> 00:24:29,370
it leads to this kind of uncanny valley

00:24:28,440 --> 00:24:30,690
where you have this

00:24:29,370 --> 00:24:32,910
type annotation but you can't quite

00:24:30,690 --> 00:24:34,290
trust it because what would happen if we

00:24:32,910 --> 00:24:36,360
try to pass this string that's untyped

00:24:34,290 --> 00:24:38,040
into an integer function is we would

00:24:36,360 --> 00:24:39,510
just get an error logged at runtime this

00:24:38,040 --> 00:24:41,520
error is called irrecoverable error it's

00:24:39,510 --> 00:24:44,910
not a fatal so the request keeps going

00:24:41,520 --> 00:24:46,740
and we have now discovered a problem so

00:24:44,910 --> 00:24:48,480
the way that we dealt with this is by

00:24:46,740 --> 00:24:49,860
taking the error logs from those errors

00:24:48,480 --> 00:24:51,240
and aggregating them and we built a

00:24:49,860 --> 00:24:53,370
slack bot that would just post them in

00:24:51,240 --> 00:24:54,960
channel so that we could see what errors

00:24:53,370 --> 00:24:57,120
were happening and then people had to

00:24:54,960 --> 00:24:58,890
triage them and fix them and this

00:24:57,120 --> 00:25:00,540
allowed us to go through a cycle in this

00:24:58,890 --> 00:25:01,980
stage of just adding types finding

00:25:00,540 --> 00:25:03,929
errors and fixing them and we just

00:25:01,980 --> 00:25:05,550
continued iterating on that luckily with

00:25:03,929 --> 00:25:07,500
these recoverable errors there's no user

00:25:05,550 --> 00:25:08,850
impact here so as we're adding type

00:25:07,500 --> 00:25:10,559
annotations we're not breaking things

00:25:08,850 --> 00:25:11,940
for users we're just discovering places

00:25:10,559 --> 00:25:13,080
where Wow we were actually passing an

00:25:11,940 --> 00:25:14,490
array to a function that wants a string

00:25:13,080 --> 00:25:18,900
and I guess it was still working but

00:25:14,490 --> 00:25:21,179
clearly not what we intended so we found

00:25:18,900 --> 00:25:23,010
as we were going through this that every

00:25:21,179 --> 00:25:24,980
little bit of effort that we invested

00:25:23,010 --> 00:25:27,300
into adding types to our code provided

00:25:24,980 --> 00:25:29,309
dividends in terms of benefits we found

00:25:27,300 --> 00:25:30,750
bugs while doing it we saw the bugs we

00:25:29,309 --> 00:25:32,370
were preventing as we started adding

00:25:30,750 --> 00:25:33,690
more types and we start to think about

00:25:32,370 --> 00:25:35,760
how do we quantify this how do we talk

00:25:33,690 --> 00:25:37,410
about types well the way we talk about

00:25:35,760 --> 00:25:39,030
tests is we talk about test coverage how

00:25:37,410 --> 00:25:41,059
much of it-- my code is covered by tests

00:25:39,030 --> 00:25:44,400
and we can do the same thing with types

00:25:41,059 --> 00:25:46,410
so hack has its tool you can say HH

00:25:44,400 --> 00:25:48,179
client - - color and it will colorize

00:25:46,410 --> 00:25:49,559
the output of a file will tell you which

00:25:48,179 --> 00:25:51,270
regions are untyped so anything that's

00:25:49,559 --> 00:25:53,460
in red is something it does not know the

00:25:51,270 --> 00:25:55,740
type of but we can also get numbers for

00:25:53,460 --> 00:25:58,380
this we can say HH client - - coverage

00:25:55,740 --> 00:26:00,809
and it will tell us how many spots in

00:25:58,380 --> 00:26:02,880
that file are untyped both functions we

00:26:00,809 --> 00:26:04,590
call local variables everything like

00:26:02,880 --> 00:26:05,700
that and so we paid attention to this

00:26:04,590 --> 00:26:07,470
number at the bottom right which is the

00:26:05,700 --> 00:26:08,790
total coverage and in this case we're

00:26:07,470 --> 00:26:10,080
passing a file but you can also just ask

00:26:08,790 --> 00:26:12,120
it for the whole code base what is the

00:26:10,080 --> 00:26:14,010
coverage so we took this number and we

00:26:12,120 --> 00:26:15,270
recorded it after every pull request

00:26:14,010 --> 00:26:17,220
that got merged into our master branch

00:26:15,270 --> 00:26:19,980
and we also recorded who was the author

00:26:17,220 --> 00:26:21,540
and we made a leaderboard and we would

00:26:19,980 --> 00:26:23,730
post this into slack every week and this

00:26:21,540 --> 00:26:25,890
was hugely beneficial to us because

00:26:23,730 --> 00:26:27,030
everyone was just excited to be both

00:26:25,890 --> 00:26:28,559
competing with each other but also

00:26:27,030 --> 00:26:31,770
working together to make the thing

00:26:28,559 --> 00:26:33,510
better and so that was our coverage

00:26:31,770 --> 00:26:34,500
competition and that allowed us to get

00:26:33,510 --> 00:26:36,000
support we could actually have enough

00:26:34,500 --> 00:26:37,920
types to start adding that strict

00:26:36,000 --> 00:26:39,420
annotation this is where everything in a

00:26:37,920 --> 00:26:41,100
file has to be typed this was when I

00:26:39,420 --> 00:26:42,880
felt like we really found ok this was

00:26:41,100 --> 00:26:44,890
actually worth it this is really benefit

00:26:42,880 --> 00:26:47,710
and at this point were at about 75% of

00:26:44,890 --> 00:26:49,090
our files are stripped the last thing we

00:26:47,710 --> 00:26:51,340
had to do on our journey to migrating to

00:26:49,090 --> 00:26:53,020
hack was to eliminate our vendor PHP

00:26:51,340 --> 00:26:54,850
code and this is the hardest part for me

00:26:53,020 --> 00:26:55,990
because we had a lot of these PHP

00:26:54,850 --> 00:26:58,030
dependencies we're installing be a

00:26:55,990 --> 00:26:59,920
composer for every one of them we had to

00:26:58,030 --> 00:27:02,110
replace it with something that we either

00:26:59,920 --> 00:27:03,490
wrote ourselves or hack a fly it or pull

00:27:02,110 --> 00:27:06,160
it out into a web service and run it as

00:27:03,490 --> 00:27:07,360
PHP we completed that and got to

00:27:06,160 --> 00:27:09,280
remember actually able to upgrade to the

00:27:07,360 --> 00:27:12,790
latest version of hvm that does not

00:27:09,280 --> 00:27:15,580
allow PHP at all so lessons learned from

00:27:12,790 --> 00:27:17,560
this we found in fix thousands of bugs I

00:27:15,580 --> 00:27:19,210
think it's incredible when you first set

00:27:17,560 --> 00:27:20,530
up static analysis it's like lifting up

00:27:19,210 --> 00:27:22,120
a log where there's ants under the logs

00:27:20,530 --> 00:27:23,860
like how could there be that many ants

00:27:22,120 --> 00:27:25,810
in this log and yet we didn't know

00:27:23,860 --> 00:27:27,340
because we had found and fixed all the

00:27:25,810 --> 00:27:28,780
bugs people reported but all of these

00:27:27,340 --> 00:27:30,610
other bugs just existed and we're kind

00:27:28,780 --> 00:27:31,270
of waiting to be found and hack was able

00:27:30,610 --> 00:27:32,890
to find them

00:27:31,270 --> 00:27:35,110
their entire classes of problems that we

00:27:32,890 --> 00:27:36,910
no longer have as a result of this but

00:27:35,110 --> 00:27:38,530
in terms of quantitative results we

00:27:36,910 --> 00:27:39,850
can't we didn't sort of take half of our

00:27:38,530 --> 00:27:41,110
programmers and have them write PHP and

00:27:39,850 --> 00:27:43,510
the other half write hack and see who

00:27:41,110 --> 00:27:44,620
was faster or who had fewer bugs so we

00:27:43,510 --> 00:27:45,970
actually measured this in terms of

00:27:44,620 --> 00:27:48,310
developer sentiment how do you feel

00:27:45,970 --> 00:27:49,990
about your code and we found that with

00:27:48,310 --> 00:27:51,580
survey results everyone felt more

00:27:49,990 --> 00:27:53,550
confident in the changes that they were

00:27:51,580 --> 00:27:55,870
making and they felt more productive

00:27:53,550 --> 00:27:59,320
there was basically nobody who felt like

00:27:55,870 --> 00:28:01,540
this wasn't an improvement and I felt

00:27:59,320 --> 00:28:02,800
like we had this sort of test pyramid

00:28:01,540 --> 00:28:04,210
this traditional test pyramid where we

00:28:02,800 --> 00:28:05,650
have the most unit tests and then fewer

00:28:04,210 --> 00:28:07,480
of the tests that are slower to run and

00:28:05,650 --> 00:28:09,490
types kind of filled out the bottom of

00:28:07,480 --> 00:28:11,140
that pyramid for us where every type is

00:28:09,490 --> 00:28:12,490
like a cheap unit test that just is

00:28:11,140 --> 00:28:14,950
resilient it's always going to be there

00:28:12,490 --> 00:28:16,600
for you it's always providing value so

00:28:14,950 --> 00:28:18,010
types are the cheapest unit tests but

00:28:16,600 --> 00:28:19,270
only we have a lot of them when you just

00:28:18,010 --> 00:28:20,860
have a few they're not doing much yet

00:28:19,270 --> 00:28:22,780
and they're also the cheapest

00:28:20,860 --> 00:28:24,670
documentation because doc blocks are

00:28:22,780 --> 00:28:26,020
often out of date unless you have some

00:28:24,670 --> 00:28:29,020
tooling keeping them up to date or as

00:28:26,020 --> 00:28:30,400
types have to be right I also learn the

00:28:29,020 --> 00:28:31,840
typing it's best done as part of feature

00:28:30,400 --> 00:28:33,550
work when you're actually working on the

00:28:31,840 --> 00:28:34,930
code for other reasons that's where you

00:28:33,550 --> 00:28:36,730
go in and add types because you already

00:28:34,930 --> 00:28:38,080
have eyes on it you already have QA or

00:28:36,730 --> 00:28:40,180
testing it you know what's going on

00:28:38,080 --> 00:28:42,700
there if you try to just go type some

00:28:40,180 --> 00:28:43,870
stuff without doing that work it's hard

00:28:42,700 --> 00:28:45,010
to know where to stop and you just kind

00:28:43,870 --> 00:28:46,840
of keep going didn't have this big

00:28:45,010 --> 00:28:48,820
spiderweb of a PR that's touching every

00:28:46,840 --> 00:28:50,670
file it's better to do typing in the

00:28:48,820 --> 00:28:52,570
code you're actually working on anyway

00:28:50,670 --> 00:28:55,090
so you might be wondering should you

00:28:52,570 --> 00:28:56,380
switch to hack if you found this

00:28:55,090 --> 00:28:58,450
compelling the community would love to

00:28:56,380 --> 00:29:00,400
you I don't expect that everyone in the

00:28:58,450 --> 00:29:02,830
room will do that obviously losing your

00:29:00,400 --> 00:29:04,600
composure dependencies is a huge ask and

00:29:02,830 --> 00:29:06,610
you would also be taking a bet on a very

00:29:04,600 --> 00:29:08,050
small community of developers Facebook

00:29:06,610 --> 00:29:09,640
is the only people that support this we

00:29:08,050 --> 00:29:10,870
contribute a bit to it there's only a

00:29:09,640 --> 00:29:12,640
couple of other companies using hacker

00:29:10,870 --> 00:29:13,810
so I don't expect that the entire

00:29:12,640 --> 00:29:16,060
community is just going to switch over

00:29:13,810 --> 00:29:18,670
what I would like to encourage you to do

00:29:16,060 --> 00:29:20,650
is to bring packs best features back to

00:29:18,670 --> 00:29:22,420
PHP and this is already happening

00:29:20,650 --> 00:29:24,460
there's many features that HACC has

00:29:22,420 --> 00:29:27,400
implemented first which have been now

00:29:24,460 --> 00:29:29,010
either coming to PHP like the arrow

00:29:27,400 --> 00:29:31,540
functions we had lambdas in HACC

00:29:29,010 --> 00:29:33,430
generics has an RFC open I would

00:29:31,540 --> 00:29:34,690
encourage you to vote on that RFC or try

00:29:33,430 --> 00:29:36,370
to get people to vote on that RFC it

00:29:34,690 --> 00:29:37,330
hasn't been voted on yet I think it's

00:29:36,370 --> 00:29:39,730
one of the most important missing

00:29:37,330 --> 00:29:41,590
features in PHP there's at least three

00:29:39,730 --> 00:29:43,630
big community packages for static

00:29:41,590 --> 00:29:45,880
analysis I would strongly recommend you

00:29:43,630 --> 00:29:47,860
to use one or more of these if you don't

00:29:45,880 --> 00:29:49,060
already and you can have all of this

00:29:47,860 --> 00:29:53,260
stuff there's really nothing that hacks

00:29:49,060 --> 00:29:55,150
doing that PHP can't also do if you want

00:29:53,260 --> 00:29:56,500
to make your code base in a good place

00:29:55,150 --> 00:29:57,850
for static analysis there are some

00:29:56,500 --> 00:29:59,590
features of PHP I would recommend

00:29:57,850 --> 00:30:01,210
avoiding these things are things that

00:29:59,590 --> 00:30:02,530
are banned in hack that you should

00:30:01,210 --> 00:30:03,010
probably ban them in your linter if you

00:30:02,530 --> 00:30:06,400
have one

00:30:03,010 --> 00:30:08,050
because they inhibit type safety eval

00:30:06,400 --> 00:30:09,310
for example global variables that could

00:30:08,050 --> 00:30:11,580
change at any time you don't really know

00:30:09,310 --> 00:30:13,390
if they exist or what their types are

00:30:11,580 --> 00:30:14,920
references might surprise you to see

00:30:13,390 --> 00:30:16,870
that on this slide the reason for that

00:30:14,920 --> 00:30:18,640
is that you can have a reference you can

00:30:16,870 --> 00:30:19,990
store it in an array you can store it

00:30:18,640 --> 00:30:21,310
somewhere and then change its type and

00:30:19,990 --> 00:30:23,440
all of a sudden we don't know what type

00:30:21,310 --> 00:30:24,550
it is anymore so hack banned references

00:30:23,440 --> 00:30:26,050
because they couldn't reason about what

00:30:24,550 --> 00:30:27,520
the type would be in a sound way and

00:30:26,050 --> 00:30:29,350
they replaced it with a feature called

00:30:27,520 --> 00:30:30,670
in/out that would just allow you to pass

00:30:29,350 --> 00:30:32,710
data into a function and get it back out

00:30:30,670 --> 00:30:35,470
but not store and you tape that variable

00:30:32,710 --> 00:30:36,760
in every context you want to so write

00:30:35,470 --> 00:30:38,110
your code in a way that makes static

00:30:36,760 --> 00:30:39,880
analysis possible and you'll have a

00:30:38,110 --> 00:30:42,700
better time using these static analysis

00:30:39,880 --> 00:30:44,380
tools and contribute to those tools file

00:30:42,700 --> 00:30:47,950
issues against them improve them and

00:30:44,380 --> 00:30:50,320
you'll have all the same stuff alright

00:30:47,950 --> 00:30:50,650
that's all I have thanks so much

00:30:50,320 --> 00:30:53,819
everyone

00:30:50,650 --> 00:30:53,819
[Applause]

00:30:54,760 --> 00:31:10,970
[Music]

00:31:07,590 --> 00:31:10,970

YouTube URL: https://www.youtube.com/watch?v=nPMI1uSrS8g


