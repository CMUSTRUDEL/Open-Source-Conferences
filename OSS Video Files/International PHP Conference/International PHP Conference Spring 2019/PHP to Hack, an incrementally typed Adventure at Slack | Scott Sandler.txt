Title: PHP to Hack, an incrementally typed Adventure at Slack | Scott Sandler
Publication date: 2019-10-02
Playlist: International PHP Conference Spring 2019
Description: 
	Speaker: Scott Sandler (Slack) | https://phpconference.com/speaker/scott-sandler/

In 2016, Slack began a migration of its multi-million line PHP codebase to Facebook’s Hack programming language. As we say a bittersweet goodbye to the final lines of PHP in our codebase, this talk reflects on what was surprising, challenging, and beneficial in this migration. We’ll cover some of the benefits and drawbacks of Hack, and places where the PHP community can draw inspiration.

🤗 Come, join us at the next International PHP Conference | https://phpconference.com/
👍 Like us on Facebook | https://www.facebook.com/ipc.germany/
👉 Follow us on Twitter | https://twitter.com/phpconference
Captions: 
	00:00:01,540 --> 00:00:07,230
[Music]

00:00:04,339 --> 00:00:09,570
all right thank you so much let's get

00:00:07,230 --> 00:00:11,250
started so my name is Scott Sandlin I'm

00:00:09,570 --> 00:00:14,849
going to talk about our journey from PHP

00:00:11,250 --> 00:00:15,960
to hack at slack Smee I'm a back an

00:00:14,849 --> 00:00:17,640
engineer at slack and I've been there

00:00:15,960 --> 00:00:20,100
for about four years and in that time

00:00:17,640 --> 00:00:21,600
slack has grown quite a bit today we

00:00:20,100 --> 00:00:23,580
have about 10 million people using slack

00:00:21,600 --> 00:00:24,900
every day and the backend code base on

00:00:23,580 --> 00:00:26,730
when we're talking to you about is

00:00:24,900 --> 00:00:28,560
responsible for processing every message

00:00:26,730 --> 00:00:30,000
every file every emoji everything that

00:00:28,560 --> 00:00:33,000
happens in slack goes through this

00:00:30,000 --> 00:00:35,969
codebase some history on this codebase

00:00:33,000 --> 00:00:39,809
slack launched in early 2014 with a PHP

00:00:35,969 --> 00:00:42,180
5 5 back end and we migrated to H HTM in

00:00:39,809 --> 00:00:45,300
early 2016 and the reason for this was

00:00:42,180 --> 00:00:48,030
really about performance at that time h

00:00:45,300 --> 00:00:49,260
h vm was much faster than PHP 5 and so

00:00:48,030 --> 00:00:51,120
it's really about just getting the speed

00:00:49,260 --> 00:00:53,309
out of there h h vm is an alternative

00:00:51,120 --> 00:00:55,260
runtime for PHP that was developed at

00:00:53,309 --> 00:00:57,600
facebook that it's completely rewritten

00:00:55,260 --> 00:01:00,059
the PHP runtime from the ground up but

00:00:57,600 --> 00:01:01,410
still about running PHP and it wasn't

00:01:00,059 --> 00:01:04,170
for another year that we've actually

00:01:01,410 --> 00:01:06,750
migrated to hacker so hack is a

00:01:04,170 --> 00:01:09,720
different language that also runs on h h

00:01:06,750 --> 00:01:12,689
vm its PHP but with more datatypes

00:01:09,720 --> 00:01:14,010
essentially and a static type checker so

00:01:12,689 --> 00:01:15,930
what does that mean static type checker

00:01:14,010 --> 00:01:17,729
it means that it's able to check your

00:01:15,930 --> 00:01:19,020
code and look for errors without

00:01:17,729 --> 00:01:21,150
actually running the code so it can

00:01:19,020 --> 00:01:23,400
analyze all possible code paths in the

00:01:21,150 --> 00:01:25,439
code so this is not about performance

00:01:23,400 --> 00:01:27,590
this is about writing PHP safer having

00:01:25,439 --> 00:01:30,600
less bugs and having more confidence and

00:01:27,590 --> 00:01:32,250
so you could say that we came to h HT m

00:01:30,600 --> 00:01:33,540
per for performance but we stayed

00:01:32,250 --> 00:01:36,900
because of hacker because of the type

00:01:33,540 --> 00:01:39,119
safety today obviously PHP 7 got much

00:01:36,900 --> 00:01:40,650
faster and PHP continues to get faster

00:01:39,119 --> 00:01:42,090
so I'm not going to focus too much on

00:01:40,650 --> 00:01:44,399
the performance differences between H

00:01:42,090 --> 00:01:45,840
HTM and PHP in this talk really focus

00:01:44,399 --> 00:01:47,909
about the developer experience of

00:01:45,840 --> 00:01:50,250
writing half code so since that

00:01:47,909 --> 00:01:51,990
migration in early 2017 we've been

00:01:50,250 --> 00:01:54,689
adding types to our code base and making

00:01:51,990 --> 00:01:56,250
more usage of hack and preparing for the

00:01:54,689 --> 00:01:58,259
newest version of HTM which no longer

00:01:56,250 --> 00:02:02,159
supports a PHP code at all it only runs

00:01:58,259 --> 00:02:03,659
hack so before I talk about our journey

00:02:02,159 --> 00:02:06,420
let's talk a little bit about what hack

00:02:03,659 --> 00:02:08,009
actually is and how it works the

00:02:06,420 --> 00:02:10,170
fundamental experience of writing hack

00:02:08,009 --> 00:02:10,530
code is interacting with a static type

00:02:10,170 --> 00:02:13,290
checker

00:02:10,530 --> 00:02:13,980
it's called HH client it's a binary that

00:02:13,290 --> 00:02:15,629
you can invoke on the

00:02:13,980 --> 00:02:16,680
command-line but the way we mostly use

00:02:15,629 --> 00:02:19,290
it is through this thing called the

00:02:16,680 --> 00:02:21,150
language server protocol and this will

00:02:19,290 --> 00:02:23,670
interact with text editors like vs code

00:02:21,150 --> 00:02:24,959
and them and it's a server but it

00:02:23,670 --> 00:02:26,940
doesn't run on another service still

00:02:24,959 --> 00:02:29,640
runs on your computer so what this thing

00:02:26,940 --> 00:02:31,530
is is it's watching the file system for

00:02:29,640 --> 00:02:33,959
changes to the code it has a data model

00:02:31,530 --> 00:02:36,629
about the code it understands the entire

00:02:33,959 --> 00:02:38,849
code base all at once and so if you make

00:02:36,629 --> 00:02:40,200
a change to a function and maybe you

00:02:38,849 --> 00:02:42,000
change its return type in a way that

00:02:40,200 --> 00:02:43,829
would break some of the call sites you

00:02:42,000 --> 00:02:45,870
instantly get feedback on all the

00:02:43,829 --> 00:02:48,000
breakages even if it has a hundred call

00:02:45,870 --> 00:02:49,680
sites across the entire code base within

00:02:48,000 --> 00:02:51,690
milliseconds before you even hit save

00:02:49,680 --> 00:02:53,489
you get that feedback on what will be

00:02:51,690 --> 00:02:55,530
broken by that change and that's coming

00:02:53,489 --> 00:02:57,420
from the language server protocol where

00:02:55,530 --> 00:02:59,129
happend sends this information to your

00:02:57,420 --> 00:03:01,370
editor and says please display these

00:02:59,129 --> 00:03:03,720
errors in these files on these lines

00:03:01,370 --> 00:03:05,819
additionally the text editor can ask

00:03:03,720 --> 00:03:07,500
hack questions it can say I'm mousing

00:03:05,819 --> 00:03:09,359
over this variable right now what is the

00:03:07,500 --> 00:03:11,280
type of this variable or where is this

00:03:09,359 --> 00:03:14,519
function defined so on and so forth so

00:03:11,280 --> 00:03:16,170
that's the language server protocol so

00:03:14,519 --> 00:03:17,670
this is our first example of some hack

00:03:16,170 --> 00:03:20,220
code and you probably notice that it

00:03:17,670 --> 00:03:22,200
just looks like PHP hack still feels

00:03:20,220 --> 00:03:23,519
very much like PHP pretty much the only

00:03:22,200 --> 00:03:26,010
difference here is that first line is H

00:03:23,519 --> 00:03:27,660
H instead of PHP and we have a very

00:03:26,010 --> 00:03:29,069
simple example of a type error here we

00:03:27,660 --> 00:03:31,230
have a function that wants an integer

00:03:29,069 --> 00:03:33,030
and we're passing it a string and that's

00:03:31,230 --> 00:03:34,560
a type error so this screenshot is from

00:03:33,030 --> 00:03:36,450
Visual Studio code we're showing the

00:03:34,560 --> 00:03:37,709
output of this error and you can see in

00:03:36,450 --> 00:03:40,079
the bottom the error has multiple parts

00:03:37,709 --> 00:03:41,669
to it it says invalid argument this is

00:03:40,079 --> 00:03:43,530
an int it's incompatible with a string

00:03:41,669 --> 00:03:44,730
and it gives you the line numbers for

00:03:43,530 --> 00:03:47,160
where these errors are occurring so it's

00:03:44,730 --> 00:03:48,840
a multi-part error it tells you how it

00:03:47,160 --> 00:03:50,459
figured out that there was a problem so

00:03:48,840 --> 00:03:51,780
line three this isn't int that's the

00:03:50,459 --> 00:03:53,910
type definition of the function we're

00:03:51,780 --> 00:03:55,620
calling and line eight this is a string

00:03:53,910 --> 00:03:57,930
that's the type of the local variable

00:03:55,620 --> 00:03:59,519
that was inferred in my experience these

00:03:57,930 --> 00:04:01,290
breadcrumbs of information that you get

00:03:59,519 --> 00:04:02,639
with these errors I mean that even on

00:04:01,290 --> 00:04:03,660
someone's first time writing hack code

00:04:02,639 --> 00:04:05,099
where they don't really understand the

00:04:03,660 --> 00:04:06,510
type system yet they're still able to

00:04:05,099 --> 00:04:09,329
figure out and fix these issues right

00:04:06,510 --> 00:04:11,190
away so this one is pretty trivial fix

00:04:09,329 --> 00:04:13,709
and we can just change it to an integer

00:04:11,190 --> 00:04:15,120
and now hack is happy you probably have

00:04:13,709 --> 00:04:16,859
this experience if you've used an editor

00:04:15,120 --> 00:04:18,060
like phpstorm how many of you are using

00:04:16,859 --> 00:04:21,870
a text editor where you get this kind of

00:04:18,060 --> 00:04:23,280
information a lot of you okay so what I

00:04:21,870 --> 00:04:25,500
want to focus on is the features that

00:04:23,280 --> 00:04:27,090
hacks type system has that PHP does not

00:04:25,500 --> 00:04:27,950
and the first one that comes to mind for

00:04:27,090 --> 00:04:30,900
me is Jan

00:04:27,950 --> 00:04:32,880
so generics are a style of programming

00:04:30,900 --> 00:04:35,130
in which you write code in terms of

00:04:32,880 --> 00:04:36,960
types to be specified later so you have

00:04:35,130 --> 00:04:38,340
functions and classes and data

00:04:36,960 --> 00:04:40,590
structures that can work with multiple

00:04:38,340 --> 00:04:42,600
different types but you specify the type

00:04:40,590 --> 00:04:44,670
when you use it and they're denoted by

00:04:42,600 --> 00:04:46,920
this angle bracket T this type parameter

00:04:44,670 --> 00:04:49,020
so here's an example of a stack data

00:04:46,920 --> 00:04:50,910
structure class stack it has this angle

00:04:49,020 --> 00:04:52,620
bracket T in it this capital T is a type

00:04:50,910 --> 00:04:54,030
parameter and you'll see that parameter

00:04:52,620 --> 00:04:56,190
repeated several times throughout the

00:04:54,030 --> 00:04:57,600
classes body it's in the push function

00:04:56,190 --> 00:04:59,580
it's the arguments of the push function

00:04:57,600 --> 00:05:01,650
it's in the pop function so the same

00:04:59,580 --> 00:05:03,330
data that you push on to the stack you

00:05:01,650 --> 00:05:06,150
pop that same data off the stack same

00:05:03,330 --> 00:05:08,730
data type now the pop function returns a

00:05:06,150 --> 00:05:10,260
nullable T because if you have a stack

00:05:08,730 --> 00:05:13,080
that's empty and you try to pop you will

00:05:10,260 --> 00:05:14,580
get nothing back you'll get no so this

00:05:13,080 --> 00:05:16,050
stack data structure could work with any

00:05:14,580 --> 00:05:17,910
type you could have a stack of intz a

00:05:16,050 --> 00:05:20,400
stack of strings a stack of arrays a

00:05:17,910 --> 00:05:23,340
stack of classes and that's what makes

00:05:20,400 --> 00:05:24,840
this a generic data structure but of

00:05:23,340 --> 00:05:26,130
course you can do this in PHP without

00:05:24,840 --> 00:05:27,650
just putting that T there so what does

00:05:26,130 --> 00:05:30,480
this actually provide for us

00:05:27,650 --> 00:05:32,669
so the point of this is the static type

00:05:30,480 --> 00:05:35,040
checking if we have a specific stack

00:05:32,669 --> 00:05:37,169
that is a stack of intz in this example

00:05:35,040 --> 00:05:38,520
we want a stack of integers and we try

00:05:37,169 --> 00:05:40,410
to push the value 5 on to that stack

00:05:38,520 --> 00:05:41,850
that's fine but if we try to push a

00:05:40,410 --> 00:05:43,560
string into the stack hack will tell us

00:05:41,850 --> 00:05:45,450
hey that's invalid this argument is a

00:05:43,560 --> 00:05:46,979
string it's supposed to be an int so

00:05:45,450 --> 00:05:48,630
this is where the generics actually help

00:05:46,979 --> 00:05:50,190
us if I define this data structure

00:05:48,630 --> 00:05:51,900
without the generics it could contain

00:05:50,190 --> 00:05:53,729
any type but I wouldn't be able to say

00:05:51,900 --> 00:05:56,550
what I want this specific stack to

00:05:53,729 --> 00:05:58,770
contain now I don't have to actually

00:05:56,550 --> 00:06:00,630
explicitly specify those generics even I

00:05:58,770 --> 00:06:02,729
can let them be inferred by the type

00:06:00,630 --> 00:06:05,520
system so I can just say S is a new

00:06:02,729 --> 00:06:07,560
stack push the value 5 into it and if I

00:06:05,520 --> 00:06:09,450
mouse over that X variable and ask hack

00:06:07,560 --> 00:06:11,550
what is the type of this variable it's

00:06:09,450 --> 00:06:13,770
able to infer that the T type for this

00:06:11,550 --> 00:06:15,270
stack is int which means that when we

00:06:13,770 --> 00:06:18,060
popped it off of it we get a nullable

00:06:15,270 --> 00:06:19,800
int because pop is a nullable T so the

00:06:18,060 --> 00:06:21,870
generics can be inferred you don't have

00:06:19,800 --> 00:06:23,550
to explicitly specify them this is

00:06:21,870 --> 00:06:26,550
different from something like Java for

00:06:23,550 --> 00:06:28,500
example in fact this will even work with

00:06:26,550 --> 00:06:29,910
multiple types we can have a stack and

00:06:28,500 --> 00:06:31,650
then we can put an int and a string in

00:06:29,910 --> 00:06:33,600
it and heck we'll figure this out it

00:06:31,650 --> 00:06:35,340
still feels like PHP it's still kind of

00:06:33,600 --> 00:06:37,020
a dynamically typed language at runtime

00:06:35,340 --> 00:06:38,669
so you can have these things that

00:06:37,020 --> 00:06:40,919
contain contain both instance strings

00:06:38,669 --> 00:06:41,400
and hexes ok cool it looks like this is

00:06:40,919 --> 00:06:43,590
a stack

00:06:41,400 --> 00:06:47,639
int or string in it this is sometimes

00:06:43,590 --> 00:06:49,350
called a union type okay so not having

00:06:47,639 --> 00:06:51,600
to explicitly declare these generics and

00:06:49,350 --> 00:06:53,070
letting the be inferred is somewhat

00:06:51,600 --> 00:06:54,449
useful in these classes but it's really

00:06:53,070 --> 00:06:58,080
useful when you start using generics

00:06:54,449 --> 00:07:00,210
with arrays so in PHP we have two kinds

00:06:58,080 --> 00:07:02,520
of arrays we have the associative array

00:07:00,210 --> 00:07:05,190
or also also called a hash table or map

00:07:02,520 --> 00:07:08,280
or dictionary and we have the list like

00:07:05,190 --> 00:07:09,840
or vector like array and in PHP we only

00:07:08,280 --> 00:07:11,370
have one word that we can use to

00:07:09,840 --> 00:07:13,050
describe that just array we can't really

00:07:11,370 --> 00:07:14,669
say much more about what's in it so we

00:07:13,050 --> 00:07:16,770
often use doc blocks above functions to

00:07:14,669 --> 00:07:20,430
describe the contents of an array in

00:07:16,770 --> 00:07:22,410
hack we can use generics to annotate the

00:07:20,430 --> 00:07:24,419
kind of array that we have so we have in

00:07:22,410 --> 00:07:26,190
the first example an array string comma

00:07:24,419 --> 00:07:28,139
string that means string keys string

00:07:26,190 --> 00:07:30,810
values in the second example we only

00:07:28,139 --> 00:07:32,250
have to specify the value type because

00:07:30,810 --> 00:07:34,229
we have a list like a rice so the keys

00:07:32,250 --> 00:07:37,289
are implicitly going to be integers

00:07:34,229 --> 00:07:38,940
increasing from zero okay and Haque is

00:07:37,289 --> 00:07:41,250
able to understand these types and

00:07:38,940 --> 00:07:42,389
differentiate between them so here we

00:07:41,250 --> 00:07:43,979
have an example where we have a function

00:07:42,389 --> 00:07:45,780
that wants an associative array and a

00:07:43,979 --> 00:07:48,000
function that wants a list array and we

00:07:45,780 --> 00:07:49,919
have this variable on line 7 that we

00:07:48,000 --> 00:07:51,750
declare that is a list like array and

00:07:49,919 --> 00:07:54,180
Haque infers based on the shape of that

00:07:51,750 --> 00:07:55,500
variable ok this is a list like array so

00:07:54,180 --> 00:07:57,300
you can't pass it to a function that

00:07:55,500 --> 00:07:58,860
wants an associative array so this is

00:07:57,300 --> 00:07:59,880
where inferring those generics is

00:07:58,860 --> 00:08:02,280
important because I don't have to

00:07:59,880 --> 00:08:04,500
declare this is an array of strings that

00:08:02,280 --> 00:08:06,539
is vector like it just didn't first that

00:08:04,500 --> 00:08:08,580
and so it's able to tell me that this is

00:08:06,539 --> 00:08:10,199
a potential problem so this helps

00:08:08,580 --> 00:08:12,690
because PHP array is having these two

00:08:10,199 --> 00:08:14,070
behaviors can be very problematic in in

00:08:12,690 --> 00:08:15,870
that there's some functions that will

00:08:14,070 --> 00:08:17,400
behave differently on integer key to

00:08:15,870 --> 00:08:19,169
rays and string key to race like array

00:08:17,400 --> 00:08:20,599
merge is one that comes up a lot I've

00:08:19,169 --> 00:08:22,889
had a lot of bugs with that in the past

00:08:20,599 --> 00:08:24,330
there's another problem we have with PHP

00:08:22,889 --> 00:08:26,190
arrays from the perspective of a type

00:08:24,330 --> 00:08:28,680
system which is that when you try to get

00:08:26,190 --> 00:08:31,139
a key out of a PHP array you could

00:08:28,680 --> 00:08:32,700
always get back a null because when PHP

00:08:31,139 --> 00:08:34,919
when you try to access a key that's not

00:08:32,700 --> 00:08:36,690
there PHP will log on notice and then it

00:08:34,919 --> 00:08:37,860
will just give you no so from the

00:08:36,690 --> 00:08:39,419
perspective of a type system you should

00:08:37,860 --> 00:08:42,120
treat any value you get out of an array

00:08:39,419 --> 00:08:43,830
as potentially null but that's very

00:08:42,120 --> 00:08:45,000
inconvenient because you know most of

00:08:43,830 --> 00:08:47,339
the time that the data is there that

00:08:45,000 --> 00:08:48,870
you're looking for and so if it made you

00:08:47,339 --> 00:08:51,029
do that you would kind of not want to

00:08:48,870 --> 00:08:52,500
use it at all and so what other

00:08:51,029 --> 00:08:53,940
languages do for this is they will throw

00:08:52,500 --> 00:08:54,930
an exception if you try to access a key

00:08:53,940 --> 00:08:56,220
that's not there

00:08:54,930 --> 00:08:58,410
Hach didn't want to make that change to

00:08:56,220 --> 00:09:00,450
raise because that would be a backwards

00:08:58,410 --> 00:09:01,980
incompatible behavior so instead they

00:09:00,450 --> 00:09:03,899
made new data structures we have the

00:09:01,980 --> 00:09:05,880
dict and the Veck they're a lot like

00:09:03,899 --> 00:09:07,680
those associative array and list like

00:09:05,880 --> 00:09:09,390
array but they formalize the difference

00:09:07,680 --> 00:09:10,890
between those two types and they're

00:09:09,390 --> 00:09:11,910
stricter about their data types so if

00:09:10,890 --> 00:09:13,980
you try to access a key that doesn't

00:09:11,910 --> 00:09:15,480
exist it throws an exception which means

00:09:13,980 --> 00:09:17,430
now you know if you get a value out of

00:09:15,480 --> 00:09:19,140
that array it is a string it's not going

00:09:17,430 --> 00:09:22,890
to be known so this helps make the type

00:09:19,140 --> 00:09:24,810
system more sound there's another kind

00:09:22,890 --> 00:09:26,610
of array that we often see in PHP code

00:09:24,810 --> 00:09:28,290
where we have different data types in

00:09:26,610 --> 00:09:30,480
the array here we have an array that has

00:09:28,290 --> 00:09:33,060
an integer type a string and even a

00:09:30,480 --> 00:09:34,950
complex type and kind of the best we can

00:09:33,060 --> 00:09:38,279
do from a type perspective is to say the

00:09:34,950 --> 00:09:39,720
values are mixed but mixed is not a very

00:09:38,279 --> 00:09:41,610
useful type annotation from the

00:09:39,720 --> 00:09:43,290
perspective of a static type system what

00:09:41,610 --> 00:09:44,640
can you do with mixed you can't really

00:09:43,290 --> 00:09:46,589
do anything with it and if you have to

00:09:44,640 --> 00:09:48,360
pass it to something and use it like an

00:09:46,589 --> 00:09:49,860
integer or like a string you'll have to

00:09:48,360 --> 00:09:52,770
assert on that type before you can use

00:09:49,860 --> 00:09:53,820
it which is also very inconvenient so it

00:09:52,770 --> 00:09:56,550
turns out there's a better way to deal

00:09:53,820 --> 00:09:58,380
with this we have shapes in hacker and

00:09:56,550 --> 00:10:00,000
shapes are a new data structure that

00:09:58,380 --> 00:10:02,850
represent an array with a known

00:10:00,000 --> 00:10:04,560
structure so you know what keys you

00:10:02,850 --> 00:10:06,959
expect to be there you know what values

00:10:04,560 --> 00:10:09,300
what the type should be and some keys

00:10:06,959 --> 00:10:10,860
can be optional as well at runtime these

00:10:09,300 --> 00:10:12,540
things are still just PHP arrays which

00:10:10,860 --> 00:10:14,550
is also very convenient because if you

00:10:12,540 --> 00:10:16,709
get some data back from an API call or

00:10:14,550 --> 00:10:18,839
from a JSON decode you can assert that

00:10:16,709 --> 00:10:21,420
it matches a shape structure where it's

00:10:18,839 --> 00:10:23,310
even just an array so what if shapes

00:10:21,420 --> 00:10:25,470
look like this is our shape definitions

00:10:23,310 --> 00:10:27,150
their type definitions where we have the

00:10:25,470 --> 00:10:28,470
name of a shape and then we have a list

00:10:27,150 --> 00:10:30,029
of the keys that can be present and

00:10:28,470 --> 00:10:31,920
there's kind of two very common examples

00:10:30,029 --> 00:10:33,900
of where we would use this the first one

00:10:31,920 --> 00:10:35,790
this is the options for an HTTP POST

00:10:33,900 --> 00:10:37,470
function so you're trying to do a post

00:10:35,790 --> 00:10:38,820
request and if you're writing a helper

00:10:37,470 --> 00:10:39,959
library where you're doing post requests

00:10:38,820 --> 00:10:41,490
one thing you realize is there are a

00:10:39,959 --> 00:10:43,230
million different ways you can do a post

00:10:41,490 --> 00:10:45,000
requests sometimes you're going to want

00:10:43,230 --> 00:10:47,220
to pass form data sometimes we're going

00:10:45,000 --> 00:10:48,480
to want to pass a JSON payload sometimes

00:10:47,220 --> 00:10:49,829
you will want to be overriding these or

00:10:48,480 --> 00:10:51,779
agent so you end up with a lot of

00:10:49,829 --> 00:10:52,890
optional arguments and you don't want to

00:10:51,779 --> 00:10:54,120
make each one of those into separate

00:10:52,890 --> 00:10:55,560
function arguments so you usually make

00:10:54,120 --> 00:10:57,870
something like an array where you can

00:10:55,560 --> 00:10:59,700
pass those arguments in but the problem

00:10:57,870 --> 00:11:00,990
is that how do you specify which keys

00:10:59,700 --> 00:11:02,880
are valid in that array and what their

00:11:00,990 --> 00:11:04,800
data type should be well you use a doc

00:11:02,880 --> 00:11:06,570
block but this thing can actually be

00:11:04,800 --> 00:11:08,610
statically type checked with a shape so

00:11:06,570 --> 00:11:10,019
when we're passing a key in there if we

00:11:08,610 --> 00:11:11,640
the name of the key or we passed the

00:11:10,019 --> 00:11:12,630
wrong data type it will complain and

00:11:11,640 --> 00:11:14,760
tell us you're not using the right

00:11:12,630 --> 00:11:15,810
options here so that's the use case for

00:11:14,760 --> 00:11:17,339
this first one we have all these

00:11:15,810 --> 00:11:19,290
optional fields with a question mark in

00:11:17,339 --> 00:11:20,880
front of them the second one is an

00:11:19,290 --> 00:11:23,250
example where we often have structured

00:11:20,880 --> 00:11:24,660
return types of a function the HDP

00:11:23,250 --> 00:11:27,660
functions whether it's a post or get

00:11:24,660 --> 00:11:29,130
will always return headers status code

00:11:27,660 --> 00:11:30,930
and a body they'll always return that

00:11:29,130 --> 00:11:32,910
and this allows us to describe what that

00:11:30,930 --> 00:11:34,649
return type is in terms of which keys

00:11:32,910 --> 00:11:36,300
will be present and what the data types

00:11:34,649 --> 00:11:37,769
of those keys will be so then when we

00:11:36,300 --> 00:11:39,690
use that function when we use that

00:11:37,769 --> 00:11:41,310
functions results in some code the type

00:11:39,690 --> 00:11:44,430
checker is aware of the values that are

00:11:41,310 --> 00:11:46,050
in there let's zoom in to how we

00:11:44,430 --> 00:11:49,290
actually use these optional keys with

00:11:46,050 --> 00:11:50,250
shapes so the way that we check the way

00:11:49,290 --> 00:11:51,510
that we use them is we have to first

00:11:50,250 --> 00:11:53,010
check that they exist because they're

00:11:51,510 --> 00:11:55,110
optional we use a built in function

00:11:53,010 --> 00:11:56,730
check that a shape key exists and then

00:11:55,110 --> 00:11:58,769
we can use it to for example build a

00:11:56,730 --> 00:12:00,300
query string and that's all well and

00:11:58,769 --> 00:12:03,300
good there's something subtle that's

00:12:00,300 --> 00:12:04,649
going on here though which is that the

00:12:03,300 --> 00:12:07,290
type system has learned something from

00:12:04,649 --> 00:12:09,329
this check that I did so this is again

00:12:07,290 --> 00:12:11,579
mousing over the value in Visual Studio

00:12:09,329 --> 00:12:13,350
code and saying what is the type of this

00:12:11,579 --> 00:12:15,959
thing so your mouse over options before

00:12:13,350 --> 00:12:17,670
the if statement and that form data key

00:12:15,959 --> 00:12:19,769
is optional because it's optional in the

00:12:17,670 --> 00:12:21,630
shape it might not be there but inside

00:12:19,769 --> 00:12:23,160
the scope of that if statement it is no

00:12:21,630 --> 00:12:24,810
longer optional because we have checked

00:12:23,160 --> 00:12:26,760
that it exists this is called type

00:12:24,810 --> 00:12:27,930
refinement so what the type system did

00:12:26,760 --> 00:12:29,579
is it learned something about the

00:12:27,930 --> 00:12:31,320
variable from the check that I did and

00:12:29,579 --> 00:12:32,970
now it has a more specific type and

00:12:31,320 --> 00:12:34,860
that's why I'm able to use that field

00:12:32,970 --> 00:12:36,240
and as soon as we exit the scope of that

00:12:34,860 --> 00:12:38,130
if statement on the code below there

00:12:36,240 --> 00:12:40,230
it's once again an optional field it

00:12:38,130 --> 00:12:41,730
might not be there so that's type

00:12:40,230 --> 00:12:43,769
refinement and heck we'll do this for

00:12:41,730 --> 00:12:45,810
any kinds of checks you do if you check

00:12:43,769 --> 00:12:48,510
for null if you throw exceptions check

00:12:45,810 --> 00:12:50,370
that something is a string so on and so

00:12:48,510 --> 00:12:52,199
forth it will track the types of

00:12:50,370 --> 00:12:53,310
variables as they flow through flow

00:12:52,199 --> 00:12:56,610
control they could be different types

00:12:53,310 --> 00:12:57,660
and it will keep track of all that let's

00:12:56,610 --> 00:13:00,750
talk a little bit about the standard

00:12:57,660 --> 00:13:02,130
library of PHP so PHP standard library

00:13:00,750 --> 00:13:04,860
gets some flack for a couple of issues

00:13:02,130 --> 00:13:07,140
one being the inconsistent arguing order

00:13:04,860 --> 00:13:08,399
I always have to look up array map an

00:13:07,140 --> 00:13:10,050
array filter and which one takes that

00:13:08,399 --> 00:13:11,850
array first if you don't have static

00:13:10,050 --> 00:13:14,310
analysis set up it's really easy to get

00:13:11,850 --> 00:13:15,870
this wrong and another common issue is

00:13:14,310 --> 00:13:17,610
that the built-in functions often will

00:13:15,870 --> 00:13:19,350
return either the data type you want or

00:13:17,610 --> 00:13:20,880
false and you have to check for both and

00:13:19,350 --> 00:13:22,290
from a type system perspective there's

00:13:20,880 --> 00:13:25,259
not a good data type that represents

00:13:22,290 --> 00:13:27,690
those two types there's another problem

00:13:25,259 --> 00:13:29,220
that I often see with PHP code which is

00:13:27,690 --> 00:13:30,509
we have things like this where we're

00:13:29,220 --> 00:13:32,389
calling a bunch of functions we're sort

00:13:30,509 --> 00:13:35,790
of composing function calls together and

00:13:32,389 --> 00:13:37,320
it's very hard to read for me so if you

00:13:35,790 --> 00:13:38,910
want to read this code you kind of have

00:13:37,320 --> 00:13:40,649
to start in the middle if say okay we

00:13:38,910 --> 00:13:42,509
have a file name or exploding it on

00:13:40,649 --> 00:13:44,399
slashes we're going to the end of that

00:13:42,509 --> 00:13:46,110
getting the last result or exploding

00:13:44,399 --> 00:13:47,550
that on dots and then we're keying into

00:13:46,110 --> 00:13:49,170
that and getting the first element of it

00:13:47,550 --> 00:13:50,699
and you're you're I have to jump all the

00:13:49,170 --> 00:13:52,079
way over to the other side to see that

00:13:50,699 --> 00:13:53,459
we're actually keying into it it's

00:13:52,079 --> 00:13:55,110
really easy to miss read this or not

00:13:53,459 --> 00:13:56,310
understand what the type of the data is

00:13:55,110 --> 00:13:58,019
that's going to come out of this and

00:13:56,310 --> 00:13:58,680
it's not super easy to refactor this in

00:13:58,019 --> 00:14:02,670
a way that feels

00:13:58,680 --> 00:14:04,139
ergonomic and readable so with hack

00:14:02,670 --> 00:14:05,370
standard library it has a new standard

00:14:04,139 --> 00:14:06,660
library you can still use the PHP

00:14:05,370 --> 00:14:09,029
standard library but has a new standard

00:14:06,660 --> 00:14:10,589
library that solves some of these

00:14:09,029 --> 00:14:12,750
problems so the primary argument of a

00:14:10,589 --> 00:14:13,949
function is always the first one things

00:14:12,750 --> 00:14:15,990
that would have return false now return

00:14:13,949 --> 00:14:18,180
null and everything that's name space

00:14:15,990 --> 00:14:19,620
it's easier to find the functions and

00:14:18,180 --> 00:14:20,639
this we have this pipeline operator

00:14:19,620 --> 00:14:22,860
that's the thing that I care most about

00:14:20,639 --> 00:14:25,680
here that lets us chain function calls

00:14:22,860 --> 00:14:27,329
so what does that look like this is that

00:14:25,680 --> 00:14:29,850
same example rewritten with the hack

00:14:27,329 --> 00:14:31,529
standard library so the magic here this

00:14:29,850 --> 00:14:33,360
is like a bash pipeline but the magic

00:14:31,529 --> 00:14:35,519
here is this double dollar sign which

00:14:33,360 --> 00:14:37,709
reference it refers to the results of

00:14:35,519 --> 00:14:39,810
the previous element of the pipeline so

00:14:37,709 --> 00:14:42,029
in our pipeline here we start with this

00:14:39,810 --> 00:14:43,380
file name and then we pipe it to the

00:14:42,029 --> 00:14:45,420
string split function which is like

00:14:43,380 --> 00:14:47,040
explode we pipe that to the last

00:14:45,420 --> 00:14:49,139
function so we get the last element of

00:14:47,040 --> 00:14:50,850
that then we pipe that to stir split

00:14:49,139 --> 00:14:52,110
again to get the dots and then we get

00:14:50,850 --> 00:14:54,600
the first element that so it's the same

00:14:52,110 --> 00:14:55,079
code this takes some getting used to the

00:14:54,600 --> 00:14:56,220
syntax

00:14:55,079 --> 00:14:57,839
I honestly avoided it for about the

00:14:56,220 --> 00:15:00,029
first six months because I just didn't

00:14:57,839 --> 00:15:01,350
quite understand it but the advantage to

00:15:00,029 --> 00:15:03,389
it is that you read the code in the

00:15:01,350 --> 00:15:04,889
order that it runs so you're able to

00:15:03,389 --> 00:15:06,269
make sense of the way that the computer

00:15:04,889 --> 00:15:06,889
will actually process the code that you

00:15:06,269 --> 00:15:10,620
have written

00:15:06,889 --> 00:15:13,709
that's very helpful another feature I

00:15:10,620 --> 00:15:15,750
want to highlight with hacks HSL that

00:15:13,709 --> 00:15:18,089
hack standard library is this regular

00:15:15,750 --> 00:15:19,829
expressions that are typed so we have

00:15:18,089 --> 00:15:21,810
these strings these are e prefixed

00:15:19,829 --> 00:15:23,310
strings sort of like Python we have a

00:15:21,810 --> 00:15:25,500
regular expression string it's a special

00:15:23,310 --> 00:15:27,089
kind of string and hack will statically

00:15:25,500 --> 00:15:28,470
validate the syntax of that regular

00:15:27,089 --> 00:15:30,240
expression so it knows that it's a valid

00:15:28,470 --> 00:15:32,339
regular expression it will fail the type

00:15:30,240 --> 00:15:33,839
checker otherwise and we'll also inspect

00:15:32,339 --> 00:15:35,660
the contents of the regular expression

00:15:33,839 --> 00:15:37,220
and it will understand which captured

00:15:35,660 --> 00:15:39,380
groups exist both named and numbered

00:15:37,220 --> 00:15:41,600
capture groups in there and then the

00:15:39,380 --> 00:15:44,120
type system is aware of what the type of

00:15:41,600 --> 00:15:45,800
that return will be so here it says this

00:15:44,120 --> 00:15:47,840
regex match it has a subgroup called

00:15:45,800 --> 00:15:50,120
word and that means that the return of

00:15:47,840 --> 00:15:51,920
this will be a vector of shapes that has

00:15:50,120 --> 00:15:53,990
an element called word and so then I can

00:15:51,920 --> 00:15:55,040
use that element if I try to access an

00:15:53,990 --> 00:15:57,260
element that doesn't exist in that

00:15:55,040 --> 00:15:58,670
capture groups it will complain for me

00:15:57,260 --> 00:16:00,260
this was life-changing in terms of

00:15:58,670 --> 00:16:01,910
writing regex because before I would

00:16:00,260 --> 00:16:03,500
always have to kind of var dump the

00:16:01,910 --> 00:16:04,760
output of regex match and see what it

00:16:03,500 --> 00:16:06,590
actually looks like before I used it

00:16:04,760 --> 00:16:10,460
because it was always different this

00:16:06,590 --> 00:16:12,830
makes that much better one last feature

00:16:10,460 --> 00:16:16,190
pack I wanna highlight is xhp this is a

00:16:12,830 --> 00:16:18,260
way to build type safe HTML in hack so

00:16:16,190 --> 00:16:21,290
if you've ever seen reacts JSX

00:16:18,260 --> 00:16:23,090
it's very similar this was before JSX at

00:16:21,290 --> 00:16:24,740
Facebook and inspired JSX

00:16:23,090 --> 00:16:26,750
this was actually originally created as

00:16:24,740 --> 00:16:28,790
a PHP extension even before hack existed

00:16:26,750 --> 00:16:31,610
what this gives us is a way to build

00:16:28,790 --> 00:16:34,190
HTML with type safety so it knows for

00:16:31,610 --> 00:16:35,960
all the built in html5 elements if they

00:16:34,190 --> 00:16:37,310
exist and what the names are of all the

00:16:35,960 --> 00:16:39,050
attributes they accept and what the

00:16:37,310 --> 00:16:41,270
types are of those attributes so we get

00:16:39,050 --> 00:16:43,520
validation on that we get automatic XSS

00:16:41,270 --> 00:16:45,140
escaping and we also get all those

00:16:43,520 --> 00:16:46,790
features for custom classes that we

00:16:45,140 --> 00:16:48,860
write so we're able to compose built-in

00:16:46,790 --> 00:16:50,240
HTML elements with our own classes and

00:16:48,860 --> 00:16:51,680
this was powerful enough that we have

00:16:50,240 --> 00:16:55,040
all of slack server-side rendered HTML

00:16:51,680 --> 00:16:56,270
using this note ok there's a lot more

00:16:55,040 --> 00:16:58,100
with hack that I don't have time to talk

00:16:56,270 --> 00:16:59,600
about in particular a single way to say

00:16:58,100 --> 00:17:01,280
we do multiple things in parallel kind

00:16:59,600 --> 00:17:03,020
of requires a lengthy explanation but I

00:17:01,280 --> 00:17:06,830
want to get on to slacks journey would

00:17:03,020 --> 00:17:08,990
happen so this was kind of our pathway

00:17:06,830 --> 00:17:11,210
to migrating to hacker and I'm gonna go

00:17:08,990 --> 00:17:12,230
through this timeline one element of

00:17:11,210 --> 00:17:15,200
time and talk about what was interesting

00:17:12,230 --> 00:17:16,910
along the way so the first part of the

00:17:15,200 --> 00:17:19,910
migration was to just find and replace

00:17:16,910 --> 00:17:22,520
PHP with HH and it was actually just

00:17:19,910 --> 00:17:24,860
that easy just one side one liner and

00:17:22,520 --> 00:17:26,570
this HH without the strict after it is

00:17:24,860 --> 00:17:27,800
hacked more permissive mode where it

00:17:26,570 --> 00:17:28,940
doesn't require everything is typed

00:17:27,800 --> 00:17:30,500
it'll let you do a lot of the things

00:17:28,940 --> 00:17:33,050
that you would do in PHP it's it's meant

00:17:30,500 --> 00:17:33,440
for this migration and that was easy

00:17:33,050 --> 00:17:35,570
right

00:17:33,440 --> 00:17:36,830
but of course hack had a lot to say

00:17:35,570 --> 00:17:38,660
about the code as soon as we did this

00:17:36,830 --> 00:17:40,370
there were many errors that it pointed

00:17:38,660 --> 00:17:42,350
out and so we couldn't just kind of run

00:17:40,370 --> 00:17:44,660
with this and say git commit total fix

00:17:42,350 --> 00:17:46,100
it later what we did is we started

00:17:44,660 --> 00:17:48,040
fixing the bugs that had told us about

00:17:46,100 --> 00:17:49,750
and there's kind of two main categories

00:17:48,040 --> 00:17:51,010
there's actual hundreds of bugs

00:17:49,750 --> 00:17:53,230
incredible number of bugs that it

00:17:51,010 --> 00:17:54,790
discovered and there are also cases

00:17:53,230 --> 00:17:56,350
where just the type information that's

00:17:54,790 --> 00:17:57,730
available to the type checker makes it

00:17:56,350 --> 00:18:00,160
think there might be a problem in

00:17:57,730 --> 00:18:02,290
practice will not be a problem and so we

00:18:00,160 --> 00:18:03,940
kind of fictive divided these up into

00:18:02,290 --> 00:18:06,910
two categories and fix the ones by hand

00:18:03,940 --> 00:18:08,740
that we could and there's also automated

00:18:06,910 --> 00:18:10,300
tooling that enables the migration so

00:18:08,740 --> 00:18:11,980
for some of the things that are

00:18:10,300 --> 00:18:13,570
different between hack and PHP the

00:18:11,980 --> 00:18:15,700
tooling will just transform the code to

00:18:13,570 --> 00:18:17,620
conform to that for example adding a

00:18:15,700 --> 00:18:19,180
leading slash to any code that's in the

00:18:17,620 --> 00:18:20,620
namespace that calls route namespace

00:18:19,180 --> 00:18:23,440
functions it'll just handle that for you

00:18:20,620 --> 00:18:25,120
and the last the worst case scenario is

00:18:23,440 --> 00:18:26,380
we can just say to hack our okay I want

00:18:25,120 --> 00:18:27,700
to suppress this error so you just put a

00:18:26,380 --> 00:18:29,830
comment above the line that's throwing

00:18:27,700 --> 00:18:31,570
an error you say I want to fix this

00:18:29,830 --> 00:18:33,880
later and hack will stop complaining

00:18:31,570 --> 00:18:35,680
about that so we use these three

00:18:33,880 --> 00:18:37,180
strategies to get rid of all the hackers

00:18:35,680 --> 00:18:39,370
and we would commit the code

00:18:37,180 --> 00:18:40,990
incrementally so basically hack off I

00:18:39,370 --> 00:18:42,820
some files and then once they're passing

00:18:40,990 --> 00:18:44,320
the type checker commits them and then

00:18:42,820 --> 00:18:46,570
keep doing that as we as we would

00:18:44,320 --> 00:18:48,850
incrementally do the code base and we

00:18:46,570 --> 00:18:50,170
did this with a CI test setup and

00:18:48,850 --> 00:18:51,670
continuous integration test that was

00:18:50,170 --> 00:18:52,960
running the type checker so that we

00:18:51,670 --> 00:18:54,700
would not commit any code that doesn't

00:18:52,960 --> 00:18:56,020
pass the type checker so in this way

00:18:54,700 --> 00:18:58,060
were able to slowly and gradually

00:18:56,020 --> 00:18:58,750
migrate all of our code to be conformant

00:18:58,060 --> 00:19:00,640
and be hacker

00:18:58,750 --> 00:19:01,960
there's one other piece that we had to

00:19:00,640 --> 00:19:04,510
deal with before we really started using

00:19:01,960 --> 00:19:06,580
hack syntax more which was our linter we

00:19:04,510 --> 00:19:08,110
were using PHP code sniffer how many of

00:19:06,580 --> 00:19:11,560
you have ever written a PHP code sniffer

00:19:08,110 --> 00:19:13,180
lint rule not too many the way that they

00:19:11,560 --> 00:19:15,610
work is you have to operate on this

00:19:13,180 --> 00:19:17,170
stream of tokens and essentially every

00:19:15,610 --> 00:19:19,120
lint rule that you write is a mini PHP

00:19:17,170 --> 00:19:20,800
parser we had a lot of custom lint rolls

00:19:19,120 --> 00:19:22,330
both first style things and also for

00:19:20,800 --> 00:19:24,270
kind of trying to prevent bugs it was

00:19:22,330 --> 00:19:27,100
our first foray into static analysis and

00:19:24,270 --> 00:19:29,470
with hack there's a new tool that uses

00:19:27,100 --> 00:19:30,880
an abstract abstract syntax tree a PHP

00:19:29,470 --> 00:19:32,830
also has an abstract syntax tree now

00:19:30,880 --> 00:19:34,030
it's basically a more structured way of

00:19:32,830 --> 00:19:35,980
looking at our code so rather than

00:19:34,030 --> 00:19:38,020
looking at one token at a time you can

00:19:35,980 --> 00:19:39,670
look at expressions as a holistic thing

00:19:38,020 --> 00:19:41,080
and understand which elements exists in

00:19:39,670 --> 00:19:42,610
those expressions and it allows you to

00:19:41,080 --> 00:19:44,500
write more rigorous linters with less

00:19:42,610 --> 00:19:46,450
code and we also are able to use it for

00:19:44,500 --> 00:19:49,150
those migrations where migrating code

00:19:46,450 --> 00:19:50,800
from one format to another so once we

00:19:49,150 --> 00:19:52,480
did this we were at the point were like

00:19:50,800 --> 00:19:54,160
okay we're ready to use hack again a lot

00:19:52,480 --> 00:19:56,260
more right there's one more thing we had

00:19:54,160 --> 00:19:58,060
to do actually hacker does not type

00:19:56,260 --> 00:19:59,320
check code that is at the top level

00:19:58,060 --> 00:20:01,549
anything that's not inside of a function

00:19:59,320 --> 00:20:03,320
which was surprising to me and was

00:20:01,549 --> 00:20:05,749
I think to everyone who first learned

00:20:03,320 --> 00:20:07,789
this so why is that the reason is that

00:20:05,749 --> 00:20:09,559
in this context all variables are global

00:20:07,789 --> 00:20:11,840
so they could change at any time any

00:20:09,559 --> 00:20:12,999
point in the program and we can't really

00:20:11,840 --> 00:20:15,139
reason about what their type will be

00:20:12,999 --> 00:20:17,509
additionally code that's at the top

00:20:15,139 --> 00:20:19,429
level like this could run at any time as

00:20:17,509 --> 00:20:21,860
the as a consequence of Auto

00:20:19,429 --> 00:20:23,360
loading or the include statement and so

00:20:21,860 --> 00:20:24,769
that means hack also has no way of

00:20:23,360 --> 00:20:26,269
reasoning about what the call stack will

00:20:24,769 --> 00:20:28,279
be and what the state of the program

00:20:26,269 --> 00:20:29,570
will be when this code runs so because

00:20:28,279 --> 00:20:30,710
of those two things it just doesn't fit

00:20:29,570 --> 00:20:32,509
well into the data model they don't

00:20:30,710 --> 00:20:33,799
allow this and in the partial mode of

00:20:32,509 --> 00:20:35,450
hack they're just not type checked at

00:20:33,799 --> 00:20:37,220
all and it's strict mode this is not

00:20:35,450 --> 00:20:39,230
allowed it's a parsing error so we had

00:20:37,220 --> 00:20:40,460
to migrate all of our code into putting

00:20:39,230 --> 00:20:41,989
the code into functions this was

00:20:40,460 --> 00:20:43,639
especially relevant for controllers and

00:20:41,989 --> 00:20:45,139
CLI scripts and things like that and

00:20:43,639 --> 00:20:47,149
hack does provide this little entry

00:20:45,139 --> 00:20:49,249
point attribute that says if this is the

00:20:47,149 --> 00:20:51,499
entry point of the request run this main

00:20:49,249 --> 00:20:52,970
function when we start so it won't run

00:20:51,499 --> 00:20:54,529
that if it's the side-effect of an auto

00:20:52,970 --> 00:20:55,999
load but it will run it when it's the

00:20:54,529 --> 00:20:58,909
entry point of the request and that's

00:20:55,999 --> 00:21:00,379
what we want so this was our second

00:20:58,909 --> 00:21:01,580
round of kind of finding a bunch of

00:21:00,379 --> 00:21:03,049
errors that we had missed in the first

00:21:01,580 --> 00:21:04,369
round of hacker fighting things and

00:21:03,049 --> 00:21:06,139
finally we're at the point where like

00:21:04,369 --> 00:21:08,029
okay we're using hack everywhere what do

00:21:06,139 --> 00:21:10,249
we do next we need to actually get types

00:21:08,029 --> 00:21:11,389
into our code we were using PHP 5 5

00:21:10,249 --> 00:21:13,460
before that switch meant we basically

00:21:11,389 --> 00:21:14,659
had no type annotations we had no types

00:21:13,460 --> 00:21:18,019
for arguments we had no types for

00:21:14,659 --> 00:21:19,700
returns and we thought about what was

00:21:18,019 --> 00:21:21,200
the best way to do this in the place we

00:21:19,700 --> 00:21:23,450
wanted to go was to start with the

00:21:21,200 --> 00:21:24,980
database because the types come from the

00:21:23,450 --> 00:21:26,899
database and they bubble up into the

00:21:24,980 --> 00:21:28,460
code from there so if we can get types

00:21:26,899 --> 00:21:29,929
from the database that gives us a

00:21:28,460 --> 00:21:31,850
foundation to build on at types

00:21:29,929 --> 00:21:32,929
everywhere else we had a problem we

00:21:31,850 --> 00:21:34,489
wanted to solve when we were doing this

00:21:32,929 --> 00:21:36,889
though is that we were using my sequel I

00:21:34,489 --> 00:21:38,840
PHP my sequel I extension which returns

00:21:36,889 --> 00:21:40,369
all data as strings so even if you have

00:21:38,840 --> 00:21:42,710
an integer in the database you get a

00:21:40,369 --> 00:21:44,600
string back in PHP and that was that

00:21:42,710 --> 00:21:46,549
behavior was maintained in hack with my

00:21:44,600 --> 00:21:48,409
sequel I and so we wanted to migrate to

00:21:46,549 --> 00:21:50,239
their their custom my sequel client

00:21:48,409 --> 00:21:52,100
which is asynchronous so you can run

00:21:50,239 --> 00:21:54,649
multiple queries in parallel and also

00:21:52,100 --> 00:21:56,869
returns type data so this is an example

00:21:54,649 --> 00:21:58,909
before we have this table that has an ID

00:21:56,869 --> 00:22:00,859
that's an integer if we select from that

00:21:58,909 --> 00:22:03,200
table with my sequel I we still just get

00:22:00,859 --> 00:22:03,739
back strings this caused a lot of bugs

00:22:03,200 --> 00:22:05,539
for us

00:22:03,739 --> 00:22:07,309
I remember one in particular where where

00:22:05,539 --> 00:22:09,740
someone had a constant that represented

00:22:07,309 --> 00:22:11,570
the slack box user ID and it was an

00:22:09,740 --> 00:22:13,220
integer and they compared it with some

00:22:11,570 --> 00:22:15,510
data that came out of the database the

00:22:13,220 --> 00:22:16,980
database at signature but in PHP

00:22:15,510 --> 00:22:19,440
it was a string so they used a triple

00:22:16,980 --> 00:22:20,880
equal sign the comparison fails and for

00:22:19,440 --> 00:22:22,470
a little while that bug existed no one

00:22:20,880 --> 00:22:23,520
could talk to slack bot and this kind of

00:22:22,470 --> 00:22:25,440
stuff happened to us all the time

00:22:23,520 --> 00:22:26,370
because it just continually surprises

00:22:25,440 --> 00:22:27,840
everyone who's worked in other

00:22:26,370 --> 00:22:29,100
programming languages when they get a

00:22:27,840 --> 00:22:31,770
string back for something that's an INT

00:22:29,100 --> 00:22:33,570
in the database so we migrated to the

00:22:31,770 --> 00:22:36,210
async my sequel client to get type data

00:22:33,570 --> 00:22:37,890
this code example uses async await but

00:22:36,210 --> 00:22:39,360
the important thing here is this map

00:22:37,890 --> 00:22:41,220
Rose type function where the data we're

00:22:39,360 --> 00:22:43,320
getting back is typed and then we're

00:22:41,220 --> 00:22:46,680
able to assert that that type of row

00:22:43,320 --> 00:22:48,570
matches a shape that we have defined so

00:22:46,680 --> 00:22:50,670
how do we make these shapes we brought

00:22:48,570 --> 00:22:52,530
some code that parses the sequel create

00:22:50,670 --> 00:22:54,300
table statement and we generated a shape

00:22:52,530 --> 00:22:56,430
for every database table that we had and

00:22:54,300 --> 00:22:58,080
basically every my sequel column is

00:22:56,430 --> 00:23:00,390
either going to be an int or a string in

00:22:58,080 --> 00:23:02,730
half anyway so it was pretty easy to

00:23:00,390 --> 00:23:04,380
sort of bind these things to there and

00:23:02,730 --> 00:23:05,790
now we have these data types for all of

00:23:04,380 --> 00:23:07,590
our database tables so we have a place

00:23:05,790 --> 00:23:08,640
to start bringing types in and getting

00:23:07,590 --> 00:23:11,790
them up throughout the rest of the

00:23:08,640 --> 00:23:13,500
application there's one more way that we

00:23:11,790 --> 00:23:15,690
can get kind of the foundational types

00:23:13,500 --> 00:23:17,820
which is there's this thing an HH client

00:23:15,690 --> 00:23:19,080
called infer return type you can ask it

00:23:17,820 --> 00:23:20,370
what do you think the return type of

00:23:19,080 --> 00:23:22,830
this function is and it will try to

00:23:20,370 --> 00:23:24,450
guess and if it's returning a hard-coded

00:23:22,830 --> 00:23:25,920
value or the result of a comparison

00:23:24,450 --> 00:23:28,020
something that comes out of a built-in

00:23:25,920 --> 00:23:29,490
function that has a return type then you

00:23:28,020 --> 00:23:31,620
will often be able to get the return

00:23:29,490 --> 00:23:33,060
type for free and how others tell you

00:23:31,620 --> 00:23:34,920
this function returns a string if it

00:23:33,060 --> 00:23:36,300
doesn't know it'll just say - so what we

00:23:34,920 --> 00:23:37,470
did is we made a script that just ran

00:23:36,300 --> 00:23:39,240
this for every function in the codebase

00:23:37,470 --> 00:23:40,890
and said what's the return type we added

00:23:39,240 --> 00:23:43,740
all the easy ones and so now once again

00:23:40,890 --> 00:23:45,660
we have a big swath of types we focus on

00:23:43,740 --> 00:23:46,710
return types first not argument types

00:23:45,660 --> 00:23:49,050
and this is one of the things I learned

00:23:46,710 --> 00:23:50,670
doing this because return types give you

00:23:49,050 --> 00:23:52,800
a type that's useful in all of the call

00:23:50,670 --> 00:23:54,180
sites where as argument types are kind

00:23:52,800 --> 00:23:56,130
of only helping you within the functions

00:23:54,180 --> 00:23:57,150
body so you get more bang for your

00:23:56,130 --> 00:23:59,280
typing buck if you're thinking about

00:23:57,150 --> 00:24:01,890
adding types by focusing on return types

00:23:59,280 --> 00:24:03,960
first an argument type second both are

00:24:01,890 --> 00:24:05,880
still valuable we really wanted to deal

00:24:03,960 --> 00:24:07,920
with these untyped functions because we

00:24:05,880 --> 00:24:09,330
learned very early on that there's sort

00:24:07,920 --> 00:24:11,850
of this fundamental problem when you

00:24:09,330 --> 00:24:14,190
start adding types is that any data that

00:24:11,850 --> 00:24:16,440
comes from an untyped function has an

00:24:14,190 --> 00:24:18,060
untyped value an unresolved type or the

00:24:16,440 --> 00:24:19,290
any type which means you can pass it

00:24:18,060 --> 00:24:21,420
anywhere you can do anything with it

00:24:19,290 --> 00:24:23,700
hack it does this because it has to do

00:24:21,420 --> 00:24:24,870
this to enable the migration otherwise

00:24:23,700 --> 00:24:26,910
you would have to type all of your code

00:24:24,870 --> 00:24:28,440
at once you couldn't really migrate but

00:24:26,910 --> 00:24:29,370
it leads to this kind of uncanny valley

00:24:28,440 --> 00:24:30,690
where you have this

00:24:29,370 --> 00:24:32,910
type annotation but you can't quite

00:24:30,690 --> 00:24:34,290
trust it because what would happen if we

00:24:32,910 --> 00:24:36,360
try to pass this string that's untyped

00:24:34,290 --> 00:24:38,040
into an integer function is we would

00:24:36,360 --> 00:24:39,510
just get an error logged at runtime this

00:24:38,040 --> 00:24:41,520
error is called irrecoverable error it's

00:24:39,510 --> 00:24:44,910
not a fatal so the request keeps going

00:24:41,520 --> 00:24:46,740
and we have now discovered a problem so

00:24:44,910 --> 00:24:48,480
the way that we dealt with this is by

00:24:46,740 --> 00:24:49,860
taking the error logs from those errors

00:24:48,480 --> 00:24:51,240
and aggregating them and we built a

00:24:49,860 --> 00:24:53,370
slack bot that would just post them in

00:24:51,240 --> 00:24:54,960
channel so that we could see what errors

00:24:53,370 --> 00:24:57,120
were happening and then people had to

00:24:54,960 --> 00:24:58,890
triage them and fix them and this

00:24:57,120 --> 00:25:00,540
allowed us to go through a cycle in this

00:24:58,890 --> 00:25:01,980
stage of just adding types finding

00:25:00,540 --> 00:25:03,929
errors and fixing them and we just

00:25:01,980 --> 00:25:05,550
continued iterating on that luckily with

00:25:03,929 --> 00:25:07,500
these recoverable errors there's no user

00:25:05,550 --> 00:25:08,850
impact here so as we're adding type

00:25:07,500 --> 00:25:10,559
annotations we're not breaking things

00:25:08,850 --> 00:25:11,940
for users we're just discovering places

00:25:10,559 --> 00:25:13,080
where Wow we were actually passing an

00:25:11,940 --> 00:25:14,490
array to a function that wants a string

00:25:13,080 --> 00:25:18,900
and I guess it was still working but

00:25:14,490 --> 00:25:21,179
clearly not what we intended so we found

00:25:18,900 --> 00:25:23,010
as we were going through this that every

00:25:21,179 --> 00:25:24,980
little bit of effort that we invested

00:25:23,010 --> 00:25:27,300
into adding types to our code provided

00:25:24,980 --> 00:25:29,309
dividends in terms of benefits we found

00:25:27,300 --> 00:25:30,750
bugs while doing it we saw the bugs we

00:25:29,309 --> 00:25:32,370
were preventing as we started adding

00:25:30,750 --> 00:25:33,690
more types and we start to think about

00:25:32,370 --> 00:25:35,760
how do we quantify this how do we talk

00:25:33,690 --> 00:25:37,410
about types well the way we talk about

00:25:35,760 --> 00:25:39,030
tests is we talk about test coverage how

00:25:37,410 --> 00:25:41,059
much of it-- my code is covered by tests

00:25:39,030 --> 00:25:44,400
and we can do the same thing with types

00:25:41,059 --> 00:25:46,410
so hack has its tool you can say HH

00:25:44,400 --> 00:25:48,179
client - - color and it will colorize

00:25:46,410 --> 00:25:49,559
the output of a file will tell you which

00:25:48,179 --> 00:25:51,270
regions are untyped so anything that's

00:25:49,559 --> 00:25:53,460
in red is something it does not know the

00:25:51,270 --> 00:25:55,740
type of but we can also get numbers for

00:25:53,460 --> 00:25:58,380
this we can say HH client - - coverage

00:25:55,740 --> 00:26:00,809
and it will tell us how many spots in

00:25:58,380 --> 00:26:02,880
that file are untyped both functions we

00:26:00,809 --> 00:26:04,590
call local variables everything like

00:26:02,880 --> 00:26:05,700
that and so we paid attention to this

00:26:04,590 --> 00:26:07,470
number at the bottom right which is the

00:26:05,700 --> 00:26:08,790
total coverage and in this case we're

00:26:07,470 --> 00:26:10,080
passing a file but you can also just ask

00:26:08,790 --> 00:26:12,120
it for the whole code base what is the

00:26:10,080 --> 00:26:14,010
coverage so we took this number and we

00:26:12,120 --> 00:26:15,270
recorded it after every pull request

00:26:14,010 --> 00:26:17,220
that got merged into our master branch

00:26:15,270 --> 00:26:19,980
and we also recorded who was the author

00:26:17,220 --> 00:26:21,540
and we made a leaderboard and we would

00:26:19,980 --> 00:26:23,730
post this into slack every week and this

00:26:21,540 --> 00:26:25,890
was hugely beneficial to us because

00:26:23,730 --> 00:26:27,030
everyone was just excited to be both

00:26:25,890 --> 00:26:28,559
competing with each other but also

00:26:27,030 --> 00:26:31,770
working together to make the thing

00:26:28,559 --> 00:26:33,510
better and so that was our coverage

00:26:31,770 --> 00:26:34,500
competition and that allowed us to get

00:26:33,510 --> 00:26:36,000
support we could actually have enough

00:26:34,500 --> 00:26:37,920
types to start adding that strict

00:26:36,000 --> 00:26:39,420
annotation this is where everything in a

00:26:37,920 --> 00:26:41,100
file has to be typed this was when I

00:26:39,420 --> 00:26:42,880
felt like we really found ok this was

00:26:41,100 --> 00:26:44,890
actually worth it this is really benefit

00:26:42,880 --> 00:26:47,710
and at this point were at about 75% of

00:26:44,890 --> 00:26:49,090
our files are stripped the last thing we

00:26:47,710 --> 00:26:51,340
had to do on our journey to migrating to

00:26:49,090 --> 00:26:53,020
hack was to eliminate our vendor PHP

00:26:51,340 --> 00:26:54,850
code and this is the hardest part for me

00:26:53,020 --> 00:26:55,990
because we had a lot of these PHP

00:26:54,850 --> 00:26:58,030
dependencies we're installing be a

00:26:55,990 --> 00:26:59,920
composer for every one of them we had to

00:26:58,030 --> 00:27:02,110
replace it with something that we either

00:26:59,920 --> 00:27:03,490
wrote ourselves or hack a fly it or pull

00:27:02,110 --> 00:27:06,160
it out into a web service and run it as

00:27:03,490 --> 00:27:07,360
PHP we completed that and got to

00:27:06,160 --> 00:27:09,280
remember actually able to upgrade to the

00:27:07,360 --> 00:27:12,790
latest version of hvm that does not

00:27:09,280 --> 00:27:15,580
allow PHP at all so lessons learned from

00:27:12,790 --> 00:27:17,560
this we found in fix thousands of bugs I

00:27:15,580 --> 00:27:19,210
think it's incredible when you first set

00:27:17,560 --> 00:27:20,530
up static analysis it's like lifting up

00:27:19,210 --> 00:27:22,120
a log where there's ants under the logs

00:27:20,530 --> 00:27:23,860
like how could there be that many ants

00:27:22,120 --> 00:27:25,810
in this log and yet we didn't know

00:27:23,860 --> 00:27:27,340
because we had found and fixed all the

00:27:25,810 --> 00:27:28,780
bugs people reported but all of these

00:27:27,340 --> 00:27:30,610
other bugs just existed and we're kind

00:27:28,780 --> 00:27:31,270
of waiting to be found and hack was able

00:27:30,610 --> 00:27:32,890
to find them

00:27:31,270 --> 00:27:35,110
their entire classes of problems that we

00:27:32,890 --> 00:27:36,910
no longer have as a result of this but

00:27:35,110 --> 00:27:38,530
in terms of quantitative results we

00:27:36,910 --> 00:27:39,850
can't we didn't sort of take half of our

00:27:38,530 --> 00:27:41,110
programmers and have them write PHP and

00:27:39,850 --> 00:27:43,510
the other half write hack and see who

00:27:41,110 --> 00:27:44,620
was faster or who had fewer bugs so we

00:27:43,510 --> 00:27:45,970
actually measured this in terms of

00:27:44,620 --> 00:27:48,310
developer sentiment how do you feel

00:27:45,970 --> 00:27:49,990
about your code and we found that with

00:27:48,310 --> 00:27:51,580
survey results everyone felt more

00:27:49,990 --> 00:27:53,550
confident in the changes that they were

00:27:51,580 --> 00:27:55,870
making and they felt more productive

00:27:53,550 --> 00:27:59,320
there was basically nobody who felt like

00:27:55,870 --> 00:28:01,540
this wasn't an improvement and I felt

00:27:59,320 --> 00:28:02,800
like we had this sort of test pyramid

00:28:01,540 --> 00:28:04,210
this traditional test pyramid where we

00:28:02,800 --> 00:28:05,650
have the most unit tests and then fewer

00:28:04,210 --> 00:28:07,480
of the tests that are slower to run and

00:28:05,650 --> 00:28:09,490
types kind of filled out the bottom of

00:28:07,480 --> 00:28:11,140
that pyramid for us where every type is

00:28:09,490 --> 00:28:12,490
like a cheap unit test that just is

00:28:11,140 --> 00:28:14,950
resilient it's always going to be there

00:28:12,490 --> 00:28:16,600
for you it's always providing value so

00:28:14,950 --> 00:28:18,010
types are the cheapest unit tests but

00:28:16,600 --> 00:28:19,270
only we have a lot of them when you just

00:28:18,010 --> 00:28:20,860
have a few they're not doing much yet

00:28:19,270 --> 00:28:22,780
and they're also the cheapest

00:28:20,860 --> 00:28:24,670
documentation because doc blocks are

00:28:22,780 --> 00:28:26,020
often out of date unless you have some

00:28:24,670 --> 00:28:29,020
tooling keeping them up to date or as

00:28:26,020 --> 00:28:30,400
types have to be right I also learn the

00:28:29,020 --> 00:28:31,840
typing it's best done as part of feature

00:28:30,400 --> 00:28:33,550
work when you're actually working on the

00:28:31,840 --> 00:28:34,930
code for other reasons that's where you

00:28:33,550 --> 00:28:36,730
go in and add types because you already

00:28:34,930 --> 00:28:38,080
have eyes on it you already have QA or

00:28:36,730 --> 00:28:40,180
testing it you know what's going on

00:28:38,080 --> 00:28:42,700
there if you try to just go type some

00:28:40,180 --> 00:28:43,870
stuff without doing that work it's hard

00:28:42,700 --> 00:28:45,010
to know where to stop and you just kind

00:28:43,870 --> 00:28:46,840
of keep going didn't have this big

00:28:45,010 --> 00:28:48,820
spiderweb of a PR that's touching every

00:28:46,840 --> 00:28:50,670
file it's better to do typing in the

00:28:48,820 --> 00:28:52,570
code you're actually working on anyway

00:28:50,670 --> 00:28:55,090
so you might be wondering should you

00:28:52,570 --> 00:28:56,380
switch to hack if you found this

00:28:55,090 --> 00:28:58,450
compelling the community would love to

00:28:56,380 --> 00:29:00,400
you I don't expect that everyone in the

00:28:58,450 --> 00:29:02,830
room will do that obviously losing your

00:29:00,400 --> 00:29:04,600
composure dependencies is a huge ask and

00:29:02,830 --> 00:29:06,610
you would also be taking a bet on a very

00:29:04,600 --> 00:29:08,050
small community of developers Facebook

00:29:06,610 --> 00:29:09,640
is the only people that support this we

00:29:08,050 --> 00:29:10,870
contribute a bit to it there's only a

00:29:09,640 --> 00:29:12,640
couple of other companies using hacker

00:29:10,870 --> 00:29:13,810
so I don't expect that the entire

00:29:12,640 --> 00:29:16,060
community is just going to switch over

00:29:13,810 --> 00:29:18,670
what I would like to encourage you to do

00:29:16,060 --> 00:29:20,650
is to bring packs best features back to

00:29:18,670 --> 00:29:22,420
PHP and this is already happening

00:29:20,650 --> 00:29:24,460
there's many features that HACC has

00:29:22,420 --> 00:29:27,400
implemented first which have been now

00:29:24,460 --> 00:29:29,010
either coming to PHP like the arrow

00:29:27,400 --> 00:29:31,540
functions we had lambdas in HACC

00:29:29,010 --> 00:29:33,430
generics has an RFC open I would

00:29:31,540 --> 00:29:34,690
encourage you to vote on that RFC or try

00:29:33,430 --> 00:29:36,370
to get people to vote on that RFC it

00:29:34,690 --> 00:29:37,330
hasn't been voted on yet I think it's

00:29:36,370 --> 00:29:39,730
one of the most important missing

00:29:37,330 --> 00:29:41,590
features in PHP there's at least three

00:29:39,730 --> 00:29:43,630
big community packages for static

00:29:41,590 --> 00:29:45,880
analysis I would strongly recommend you

00:29:43,630 --> 00:29:47,860
to use one or more of these if you don't

00:29:45,880 --> 00:29:49,060
already and you can have all of this

00:29:47,860 --> 00:29:53,260
stuff there's really nothing that hacks

00:29:49,060 --> 00:29:55,150
doing that PHP can't also do if you want

00:29:53,260 --> 00:29:56,500
to make your code base in a good place

00:29:55,150 --> 00:29:57,850
for static analysis there are some

00:29:56,500 --> 00:29:59,590
features of PHP I would recommend

00:29:57,850 --> 00:30:01,210
avoiding these things are things that

00:29:59,590 --> 00:30:02,530
are banned in hack that you should

00:30:01,210 --> 00:30:03,010
probably ban them in your linter if you

00:30:02,530 --> 00:30:06,400
have one

00:30:03,010 --> 00:30:08,050
because they inhibit type safety eval

00:30:06,400 --> 00:30:09,310
for example global variables that could

00:30:08,050 --> 00:30:11,580
change at any time you don't really know

00:30:09,310 --> 00:30:13,390
if they exist or what their types are

00:30:11,580 --> 00:30:14,920
references might surprise you to see

00:30:13,390 --> 00:30:16,870
that on this slide the reason for that

00:30:14,920 --> 00:30:18,640
is that you can have a reference you can

00:30:16,870 --> 00:30:19,990
store it in an array you can store it

00:30:18,640 --> 00:30:21,310
somewhere and then change its type and

00:30:19,990 --> 00:30:23,440
all of a sudden we don't know what type

00:30:21,310 --> 00:30:24,550
it is anymore so hack banned references

00:30:23,440 --> 00:30:26,050
because they couldn't reason about what

00:30:24,550 --> 00:30:27,520
the type would be in a sound way and

00:30:26,050 --> 00:30:29,350
they replaced it with a feature called

00:30:27,520 --> 00:30:30,670
in/out that would just allow you to pass

00:30:29,350 --> 00:30:32,710
data into a function and get it back out

00:30:30,670 --> 00:30:35,470
but not store and you tape that variable

00:30:32,710 --> 00:30:36,760
in every context you want to so write

00:30:35,470 --> 00:30:38,110
your code in a way that makes static

00:30:36,760 --> 00:30:39,880
analysis possible and you'll have a

00:30:38,110 --> 00:30:42,700
better time using these static analysis

00:30:39,880 --> 00:30:44,380
tools and contribute to those tools file

00:30:42,700 --> 00:30:47,950
issues against them improve them and

00:30:44,380 --> 00:30:50,320
you'll have all the same stuff alright

00:30:47,950 --> 00:30:50,650
that's all I have thanks so much

00:30:50,320 --> 00:30:53,819
everyone

00:30:50,650 --> 00:30:53,819
[Applause]

00:30:54,760 --> 00:31:10,970
[Music]

00:31:07,590 --> 00:31:10,970

YouTube URL: https://www.youtube.com/watch?v=nPMI1uSrS8g


