Title: What Kind of Language is it? - Sebastian Bergmann | IPC16
Publication date: 2017-04-10
Playlist: International PHP Conference Spring 2016
Description: 
	PHP 7 is an imperative programming language that supports procedural as well as object-oriented programming. It has limited support for functional programming and language extensions for aspect-oriented programming exist. PHP 7 is dynamically, implicitly, and weakly typed but supports explicit typing and strict type checking when desired. But what does this all mean? Join Sebastian Bergmann at International PHP Conference 2016 on a whirlwind tour through the interesting land of programming language design principles and find out just what a great language PHP is.

The International PHP Conference is the worldâ€™s first PHP conference and stands since more than a decade for top-notch pragmatic expertise in PHP and web technologies. Internationally renowned experts from the PHP industry meet up with PHP users and developers from large and small companies.

More information:
https://phpconference.com/en/
Captions: 
	00:00:05,690 --> 00:00:14,190
good morning Tom just complained about

00:00:11,580 --> 00:00:20,550
the fact that the date on my slide is

00:00:14,190 --> 00:00:21,920
wrong it's not May 30th but I was

00:00:20,550 --> 00:00:28,789
supposed to give this presentation

00:00:21,920 --> 00:00:31,830
yesterday and then this happened so I

00:00:28,789 --> 00:00:36,239
want I was flying or I wanted to fly

00:00:31,830 --> 00:00:38,850
from Frankfurt to Berlin when suddenly

00:00:36,239 --> 00:00:43,559
there was a really weird smell of burnt

00:00:38,850 --> 00:00:47,280
oil in the cabin and one engine was shut

00:00:43,559 --> 00:00:51,390
down and we aborted our flight to Berlin

00:00:47,280 --> 00:00:54,210
we cruised a bit we dumped some fuel we

00:00:51,390 --> 00:00:57,750
had an emergency and landing which is

00:00:54,210 --> 00:01:00,390
not really an emergency but redundant

00:00:57,750 --> 00:01:02,100
engines one the redundancy of the

00:01:00,390 --> 00:01:04,350
engines was no longer a given so that

00:01:02,100 --> 00:01:06,900
makes it an emergency although it's a

00:01:04,350 --> 00:01:10,110
standard procedure so we landed there

00:01:06,900 --> 00:01:13,830
was lots of Fire Department vehicles and

00:01:10,110 --> 00:01:16,380
whatever and then a couple of late a

00:01:13,830 --> 00:01:20,790
couple of hours later I was able to fly

00:01:16,380 --> 00:01:23,390
to Berlin so good morning and now I have

00:01:20,790 --> 00:01:30,150
fixed the flight are you happy now Tom

00:01:23,390 --> 00:01:34,770
good hi my name is Sebastian and since

00:01:30,150 --> 00:01:38,130
the end of 1998 early 1999 I'm doing

00:01:34,770 --> 00:01:40,350
things with PHP I learned programming

00:01:38,130 --> 00:01:44,509
and the love for programming most

00:01:40,350 --> 00:01:49,829
importantly a really long time ago on

00:01:44,509 --> 00:01:53,369
amiga computers using mmm 68k assembly

00:01:49,829 --> 00:01:57,840
and then later some see some irax some

00:01:53,369 --> 00:01:59,939
basic dialects in between and some of

00:01:57,840 --> 00:02:02,640
this information babe may be relevant at

00:01:59,939 --> 00:02:05,280
later points in this presentation so I

00:02:02,640 --> 00:02:08,879
like to help teams successfully develop

00:02:05,280 --> 00:02:10,170
software that's the reason why I found

00:02:08,879 --> 00:02:12,720
it together with Anna and she I found a

00:02:10,170 --> 00:02:13,470
couple of years ago the PHP consulting

00:02:12,720 --> 00:02:16,220
company

00:02:13,470 --> 00:02:17,940
and that's all the advertising and sales

00:02:16,220 --> 00:02:19,740
information that you're going to get out

00:02:17,940 --> 00:02:22,460
of me if you would like to know how we

00:02:19,740 --> 00:02:28,650
can help you find either of us

00:02:22,460 --> 00:02:32,430
throughout the conference Thursday so

00:02:28,650 --> 00:02:34,170
lots of question marks on the board lots

00:02:32,430 --> 00:02:38,280
of questions around what type of

00:02:34,170 --> 00:02:43,680
language PHP is over the last couple of

00:02:38,280 --> 00:02:46,560
years at countless occasions on its user

00:02:43,680 --> 00:02:50,460
group events at conferences whenever I a

00:02:46,560 --> 00:02:54,510
mid PHP developers there's most of the

00:02:50,460 --> 00:02:57,150
time the question like so what type of

00:02:54,510 --> 00:03:01,170
language is PHP how does it compare to

00:02:57,150 --> 00:03:04,020
other language XYZ and what do terms

00:03:01,170 --> 00:03:07,110
like dynamic or static or weak or strong

00:03:04,020 --> 00:03:10,200
typing or manifest typing expressive

00:03:07,110 --> 00:03:12,090
typing explicit typing implicit typing

00:03:10,200 --> 00:03:15,420
type inference and whatever what do

00:03:12,090 --> 00:03:17,760
these terms mean why should I know what

00:03:15,420 --> 00:03:23,850
they mean and how can I use them to

00:03:17,760 --> 00:03:25,950
compare languages so I was really

00:03:23,850 --> 00:03:29,550
surprised that this presentation was

00:03:25,950 --> 00:03:31,080
accepted when I proposed it for IPC I'm

00:03:29,550 --> 00:03:33,300
really glad that I get a chance to talk

00:03:31,080 --> 00:03:34,800
about that and apparently there's lots

00:03:33,300 --> 00:03:44,160
just lots of interest so that's good

00:03:34,800 --> 00:03:47,040
so here goes still trying to wake up so

00:03:44,160 --> 00:03:50,519
I'm going to try to answer these

00:03:47,040 --> 00:03:53,820
questions organized into a couple of

00:03:50,519 --> 00:03:57,709
different chapters first will be how is

00:03:53,820 --> 00:04:00,600
a program written in one language

00:03:57,709 --> 00:04:02,239
executed next so let's talk about

00:04:00,600 --> 00:04:06,150
execution

00:04:02,239 --> 00:04:08,459
there are over the decades that we now

00:04:06,150 --> 00:04:10,950
have programming languages and computers

00:04:08,459 --> 00:04:14,250
and can run programs on machines that

00:04:10,950 --> 00:04:15,750
get ever faster there have been various

00:04:14,250 --> 00:04:17,489
different execution models for

00:04:15,750 --> 00:04:23,700
programming languages and it all started

00:04:17,489 --> 00:04:25,650
really really simple at some point so

00:04:23,700 --> 00:04:27,290
they are basically nowadays for

00:04:25,650 --> 00:04:30,440
different types of execution

00:04:27,290 --> 00:04:33,590
you can parse the source code which

00:04:30,440 --> 00:04:35,120
means first you scan a text file that

00:04:33,590 --> 00:04:36,710
has source code in it you read it

00:04:35,120 --> 00:04:39,470
character by character until you

00:04:36,710 --> 00:04:42,680
recognize a vert that's what the first

00:04:39,470 --> 00:04:44,210
step of a compiler does and then at the

00:04:42,680 --> 00:04:48,790
end of that first pass you have a

00:04:44,210 --> 00:04:52,820
sequence of so-called tokens or verts

00:04:48,790 --> 00:04:55,430
that then a parser tries to make sense

00:04:52,820 --> 00:04:59,030
out of its the parser that tries to

00:04:55,430 --> 00:05:02,570
answer the question do these sentences

00:04:59,030 --> 00:05:06,380
these sequences of words words make up

00:05:02,570 --> 00:05:09,470
valid sentences valid constructs in this

00:05:06,380 --> 00:05:14,300
programming language and after that we

00:05:09,470 --> 00:05:16,390
have some other representation of that

00:05:14,300 --> 00:05:23,440
program code that we can directly

00:05:16,390 --> 00:05:26,960
execute this is for instance how basic

00:05:23,440 --> 00:05:29,090
works or at least two really really old

00:05:26,960 --> 00:05:32,990
original implementations of basic or

00:05:29,090 --> 00:05:37,700
this is how PHP used to work before PHP

00:05:32,990 --> 00:05:41,000
three the original PHP personal home

00:05:37,700 --> 00:05:45,890
page tools and version to PHP / Fi

00:05:41,000 --> 00:05:49,400
they executed a PHP program by reading

00:05:45,890 --> 00:05:53,150
it line by line and if what was written

00:05:49,400 --> 00:05:56,090
on that line made some sort of sense to

00:05:53,150 --> 00:05:59,300
the PHP interpreter it would be executed

00:05:56,090 --> 00:06:03,950
immediately and yes this means that if

00:05:59,300 --> 00:06:07,220
you have a for loop for instance and the

00:06:03,950 --> 00:06:11,840
for loop starts on line ten and ends on

00:06:07,220 --> 00:06:14,480
line 20 to execute line lines 10 until

00:06:11,840 --> 00:06:17,420
20 and then on 20 regulars oh the for

00:06:14,480 --> 00:06:19,700
loop ended so you backtrack 10 lines and

00:06:17,420 --> 00:06:22,190
see whether or not the loop condition

00:06:19,700 --> 00:06:23,930
still holds whether or not you need to

00:06:22,190 --> 00:06:27,590
execute this again then you do it all

00:06:23,930 --> 00:06:30,410
over again which is of course redundant

00:06:27,590 --> 00:06:32,210
and slow and not really a nice way of

00:06:30,410 --> 00:06:35,729
executing code but that's how it all

00:06:32,210 --> 00:06:40,409
started a really long time ago

00:06:35,729 --> 00:06:42,059
you can take the source code and do some

00:06:40,409 --> 00:06:43,979
of the parts that I just described you

00:06:42,059 --> 00:06:45,749
can scan it you can parse it you can

00:06:43,979 --> 00:06:49,439
generate an intermediate representation

00:06:45,749 --> 00:06:52,499
and execute that intermediate

00:06:49,439 --> 00:06:54,870
representation and if you then have a

00:06:52,499 --> 00:06:56,580
for loop you only ever analyze the

00:06:54,870 --> 00:06:57,719
source code to get that intermediate

00:06:56,580 --> 00:07:00,809
representation that you can actually

00:06:57,719 --> 00:07:02,309
execute once and at the end of the

00:07:00,809 --> 00:07:07,199
program execution you throw everything

00:07:02,309 --> 00:07:12,059
away this is the default execution model

00:07:07,199 --> 00:07:18,139
for PHP since version version 3 it's

00:07:12,059 --> 00:07:23,069
still the default in 54 55 57 with the

00:07:18,139 --> 00:07:26,610
addition that we can now thanks to byte

00:07:23,069 --> 00:07:28,289
code caches tell PHP to not forget about

00:07:26,610 --> 00:07:29,969
this intermediate representation at the

00:07:28,289 --> 00:07:32,309
end of the request but cache it

00:07:29,969 --> 00:07:35,129
somewhere so we really do the expensive

00:07:32,309 --> 00:07:39,889
compilation to get the intermediate

00:07:35,129 --> 00:07:43,979
representation only once and of course

00:07:39,889 --> 00:07:46,800
you can compile the source code and not

00:07:43,979 --> 00:07:49,499
generate something intermediate to run

00:07:46,800 --> 00:07:52,469
but generate machine instructions that

00:07:49,499 --> 00:07:55,620
you can save in the binary that contains

00:07:52,469 --> 00:07:57,629
the machine code that is required to run

00:07:55,620 --> 00:08:00,689
something on a particular hardware

00:07:57,629 --> 00:08:02,909
platform this is for instance what you

00:08:00,689 --> 00:08:07,740
do with a programming language such as C

00:08:02,909 --> 00:08:11,159
or C++ it's not what you do with a

00:08:07,740 --> 00:08:13,379
language such as Java or C sharp

00:08:11,159 --> 00:08:16,020
for instance yes yeah you have an

00:08:13,379 --> 00:08:18,599
explicit complete compilation step but

00:08:16,020 --> 00:08:22,020
the result of that explicit compilation

00:08:18,599 --> 00:08:26,399
step is not a native binary that you can

00:08:22,020 --> 00:08:28,229
execute it's a binary that contains the

00:08:26,399 --> 00:08:31,199
intermediate representation in the case

00:08:28,229 --> 00:08:33,599
of Java the Java bytecode and then you

00:08:31,199 --> 00:08:36,690
have an interpreter the Java Runtime

00:08:33,599 --> 00:08:39,510
that takes this bytecode and executes

00:08:36,690 --> 00:08:42,000
this at least that was the original

00:08:39,510 --> 00:08:45,420
model for how Java was executed modern

00:08:42,000 --> 00:08:47,760
Java runtimes take this bytecode and on

00:08:45,420 --> 00:08:48,870
the fly compile it to native code to

00:08:47,760 --> 00:08:50,820
make it faster

00:08:48,870 --> 00:08:52,170
but at the end of the day if you look at

00:08:50,820 --> 00:08:55,080
it it's still some sort of

00:08:52,170 --> 00:08:58,470
interpretation unless the optimizer

00:08:55,080 --> 00:09:00,210
starts to kick in and does just-in-time

00:08:58,470 --> 00:09:01,850
compilation to machine code whenever

00:09:00,210 --> 00:09:07,040
necessary

00:09:01,850 --> 00:09:10,800
so that's execution and there are only

00:09:07,040 --> 00:09:13,790
four major flavors what we just saw it

00:09:10,800 --> 00:09:23,220
gets more interesting when you look at

00:09:13,790 --> 00:09:25,620
paradigms so any idea what programming

00:09:23,220 --> 00:09:33,029
paradigm PHP follows or which

00:09:25,620 --> 00:09:35,339
programming paradigms PHP allows share

00:09:33,029 --> 00:09:38,460
nothing that's basically an architecture

00:09:35,339 --> 00:09:43,980
paradigm so what type of language on a

00:09:38,460 --> 00:09:45,810
language level object-oriented yes but

00:09:43,980 --> 00:09:58,110
is it just object-oriented or can it do

00:09:45,810 --> 00:09:59,459
something else imperative yes okay it's

00:09:58,110 --> 00:10:03,720
too early in the morning not everyone

00:09:59,459 --> 00:10:06,089
had coffee yet and it's me standing up

00:10:03,720 --> 00:10:07,800
here so I should do the talking I know I

00:10:06,089 --> 00:10:13,830
know I'm lazy so let's talk about

00:10:07,800 --> 00:10:15,240
programming paradigms CSS you've got to

00:10:13,830 --> 00:10:18,390
love it

00:10:15,240 --> 00:10:20,580
so one style of programming is called

00:10:18,390 --> 00:10:23,339
declarative programming and that's a

00:10:20,580 --> 00:10:26,430
style of building structure and elements

00:10:23,339 --> 00:10:28,350
of computer programs that expresses the

00:10:26,430 --> 00:10:31,950
logic of a computation without

00:10:28,350 --> 00:10:34,170
describing its control flow and that's

00:10:31,950 --> 00:10:37,650
something really interesting and

00:10:34,170 --> 00:10:39,360
powerful because it frees the programmer

00:10:37,650 --> 00:10:44,420
from having to think about

00:10:39,360 --> 00:10:47,820
implementation details when I write a

00:10:44,420 --> 00:10:51,500
query to get data out of a relational

00:10:47,820 --> 00:10:55,260
database I do not want to care about

00:10:51,500 --> 00:10:58,020
what the most efficient way is to get

00:10:55,260 --> 00:11:01,470
that data to minimize disk reads through

00:10:58,020 --> 00:11:02,579
order and sort and whatever I don't want

00:11:01,470 --> 00:11:05,309
to care about that

00:11:02,579 --> 00:11:08,160
want to write down give me the

00:11:05,309 --> 00:11:10,339
information that I want so that's much

00:11:08,160 --> 00:11:13,139
higher level if you want then and

00:11:10,339 --> 00:11:14,160
farther away from from the Machine than

00:11:13,139 --> 00:11:18,660
some other languages

00:11:14,160 --> 00:11:21,439
that's what SQL does for instance so I

00:11:18,660 --> 00:11:23,970
just I want to be just able to write

00:11:21,439 --> 00:11:26,179
select star from programming languages

00:11:23,970 --> 00:11:29,309
where paradigm equals declarative I

00:11:26,179 --> 00:11:32,189
don't want to tell the database how to

00:11:29,309 --> 00:11:34,439
perform the steps or even what the steps

00:11:32,189 --> 00:11:37,619
are to answer this question here's a

00:11:34,439 --> 00:11:42,110
question give me the answer I don't care

00:11:37,619 --> 00:11:45,089
about the implementation details similar

00:11:42,110 --> 00:11:46,949
concept well it's the same programming

00:11:45,089 --> 00:11:50,459
program declarative programming but in a

00:11:46,949 --> 00:11:54,239
different type of application is what

00:11:50,459 --> 00:11:57,509
you do is Prolog and as surprising as

00:11:54,239 --> 00:11:59,279
that may be Prolog is still used today

00:11:57,509 --> 00:12:01,139
although it's really really old and

00:11:59,279 --> 00:12:03,829
really really weird but you can do

00:12:01,139 --> 00:12:08,239
really powerful powerful stuff with it

00:12:03,829 --> 00:12:12,569
for instance you can put research from

00:12:08,239 --> 00:12:15,480
marine biologists about how dolphins and

00:12:12,569 --> 00:12:18,779
whales communicate with each other into

00:12:15,480 --> 00:12:22,910
a Prolog knowledge base and use that to

00:12:18,779 --> 00:12:25,949
translate between humans and dolphins

00:12:22,910 --> 00:12:27,720
it's really really interesting and if

00:12:25,949 --> 00:12:30,149
you're interested in that there's a book

00:12:27,720 --> 00:12:33,059
that talks about this seven programming

00:12:30,149 --> 00:12:35,009
languages in seven weeks really

00:12:33,059 --> 00:12:36,389
interesting so if it's a Prolog

00:12:35,009 --> 00:12:38,009
knowledge base you have knowledge in

00:12:36,389 --> 00:12:42,499
there and then you can ask questions

00:12:38,009 --> 00:12:45,299
like are Sally and Erika siblings and

00:12:42,499 --> 00:12:47,730
nowhere in the knowledge base have

00:12:45,299 --> 00:12:49,679
explicitly written that down but there

00:12:47,730 --> 00:12:54,779
are algorithms involved it deduce that

00:12:49,679 --> 00:12:59,910
information really powerful but that's

00:12:54,779 --> 00:13:03,269
not how we program in PHP PHP is belongs

00:12:59,910 --> 00:13:04,799
to something else so if you have the

00:13:03,269 --> 00:13:06,989
clarity of programming on the one side

00:13:04,799 --> 00:13:10,919
on the other side you'll have imperative

00:13:06,989 --> 00:13:13,949
programming and imperative means I tell

00:13:10,919 --> 00:13:16,150
the computer what to do and exactly how

00:13:13,949 --> 00:13:19,430
to do that

00:13:16,150 --> 00:13:22,820
it uses statements that change a

00:13:19,430 --> 00:13:25,780
program's state so I have to care about

00:13:22,820 --> 00:13:28,670
states and I need to tell the computer

00:13:25,780 --> 00:13:33,980
through the program how to change that

00:13:28,670 --> 00:13:37,180
state so PHP is imperative as somebody

00:13:33,980 --> 00:13:40,670
from the audience mentioned earlier and

00:13:37,180 --> 00:13:43,010
how did imperative languages evolve it

00:13:40,670 --> 00:13:46,550
started all the way back with writing

00:13:43,010 --> 00:13:48,290
directly machine code when we got the

00:13:46,550 --> 00:13:50,390
first computers there were no

00:13:48,290 --> 00:13:51,560
programming languages it might I mean

00:13:50,390 --> 00:13:54,410
it's a chicken and egg problem

00:13:51,560 --> 00:13:55,700
I have a computer before I had the

00:13:54,410 --> 00:13:58,820
computer I had no way of running

00:13:55,700 --> 00:14:00,920
software now I have a computer I have no

00:13:58,820 --> 00:14:03,260
software now I need to override software

00:14:00,920 --> 00:14:06,230
the first thing that I'm writing

00:14:03,260 --> 00:14:10,730
probably not going to be a high level

00:14:06,230 --> 00:14:12,800
compiler that can do transformation that

00:14:10,730 --> 00:14:14,600
is necessary from a developer friendly

00:14:12,800 --> 00:14:15,560
language to something that the hardware

00:14:14,600 --> 00:14:17,900
can understand

00:14:15,560 --> 00:14:20,330
so the first machines were exclusively

00:14:17,900 --> 00:14:22,420
programmed using machine code like

00:14:20,330 --> 00:14:25,970
really really really low-level

00:14:22,420 --> 00:14:28,670
instructions for how the computer should

00:14:25,970 --> 00:14:31,730
operate the first abstraction that we

00:14:28,670 --> 00:14:35,150
got over that at the end of the 1940s

00:14:31,730 --> 00:14:37,910
was assembly language and he asked that

00:14:35,150 --> 00:14:40,840
still low level but if you look back at

00:14:37,910 --> 00:14:43,640
a time that was really really high level

00:14:40,840 --> 00:14:47,660
it was much farther away from the

00:14:43,640 --> 00:14:53,020
hardware it was an inconvenient to use

00:14:47,660 --> 00:14:55,370
because still you had no concepts of

00:14:53,020 --> 00:14:58,100
modularizing your of your program it was

00:14:55,370 --> 00:15:03,050
basically a huge list sequence of

00:14:58,100 --> 00:15:06,710
statements that got a bit better in the

00:15:03,050 --> 00:15:09,050
1960s when macros were added to assembly

00:15:06,710 --> 00:15:13,010
now it was suddenly much more convenient

00:15:09,050 --> 00:15:16,460
to write assembly code but still not fun

00:15:13,010 --> 00:15:20,270
maybe at least you're weird like me and

00:15:16,460 --> 00:15:24,920
like doing low-level assembly 3d

00:15:20,270 --> 00:15:27,440
real-time stuff on the Amiga around at

00:15:24,920 --> 00:15:28,570
the same time another programming

00:15:27,440 --> 00:15:31,180
paradigm or

00:15:28,570 --> 00:15:33,040
a refinement so imperative programming

00:15:31,180 --> 00:15:34,930
split into different directions

00:15:33,040 --> 00:15:37,210
one of those directions was functional

00:15:34,930 --> 00:15:39,340
programming this is a paradigm that

00:15:37,210 --> 00:15:41,050
treats computation as the evaluation of

00:15:39,340 --> 00:15:44,920
mathematical functions and avoids

00:15:41,050 --> 00:15:47,200
changing state and mutable data and for

00:15:44,920 --> 00:15:49,510
a programming language to be considered

00:15:47,200 --> 00:15:52,420
truly functional you need to have three

00:15:49,510 --> 00:15:54,160
characteristics it needs to have support

00:15:52,420 --> 00:15:58,210
for higher-order functions which means

00:15:54,160 --> 00:16:00,220
you need to have a first level entity

00:15:58,210 --> 00:16:02,590
called a function and you need to be

00:16:00,220 --> 00:16:05,590
able to pass around functions as

00:16:02,590 --> 00:16:07,420
arguments to other functions and need to

00:16:05,590 --> 00:16:09,550
be able to return functions as the

00:16:07,420 --> 00:16:11,950
result of computation it happens in the

00:16:09,550 --> 00:16:16,590
function that's characteristic number

00:16:11,950 --> 00:16:19,300
one number two would be purity so as

00:16:16,590 --> 00:16:22,110
you're not allowed to change state and

00:16:19,300 --> 00:16:26,490
you're not allowed to mutable data and

00:16:22,110 --> 00:16:28,540
that really leads to a conundrum because

00:16:26,490 --> 00:16:30,880
there are a lot of interesting things

00:16:28,540 --> 00:16:32,790
that I can do with the language that

00:16:30,880 --> 00:16:35,470
cannot talk to the outside world but

00:16:32,790 --> 00:16:38,380
also for most real-world use cases

00:16:35,470 --> 00:16:42,580
that's really really hard so you have to

00:16:38,380 --> 00:16:45,310
in intelligent ways break that purity

00:16:42,580 --> 00:16:49,680
and put all the nasty stuff that deals

00:16:45,310 --> 00:16:49,680
with the outside world into quarantine

00:16:50,310 --> 00:16:56,530
and the third thing is recursion you

00:16:54,280 --> 00:16:59,620
need to be able to have functions that

00:16:56,530 --> 00:17:03,370
call themselves and a couple of

00:16:59,620 --> 00:17:08,770
languages evolved some of them most of

00:17:03,370 --> 00:17:11,010
them are still in use today Common Lisp

00:17:08,770 --> 00:17:14,230
is really really interesting because

00:17:11,010 --> 00:17:20,170
already in the early 80s just like small

00:17:14,230 --> 00:17:22,329
talk it had runtime features that other

00:17:20,170 --> 00:17:25,150
programming languages like Java for

00:17:22,329 --> 00:17:27,339
instance came up with like five years

00:17:25,150 --> 00:17:29,320
ago and touted them as this is a

00:17:27,339 --> 00:17:33,700
breakthrough no other runtime ever had

00:17:29,320 --> 00:17:36,870
this like replace bytecode at runtime by

00:17:33,700 --> 00:17:36,870
the application still runs

00:17:37,250 --> 00:17:42,679
that's not something new we had that a

00:17:39,080 --> 00:17:45,590
really long time ago but okay to each

00:17:42,679 --> 00:17:50,929
their own and yes people use Haskell

00:17:45,590 --> 00:17:52,130
people use Oh camel every fund enough so

00:17:50,929 --> 00:17:54,049
apparently there are regional

00:17:52,130 --> 00:17:57,500
preferences for programming languages I

00:17:54,049 --> 00:18:01,570
have yet to meet a developer that likes

00:17:57,500 --> 00:18:04,700
a camel that does not come from France

00:18:01,570 --> 00:18:08,120
so Oh camel comes from a university in

00:18:04,700 --> 00:18:09,500
France and all the students that go

00:18:08,120 --> 00:18:11,480
there or most of the students that go

00:18:09,500 --> 00:18:13,250
there learn Oh camel and I really really

00:18:11,480 --> 00:18:18,039
happy with that and it's a really

00:18:13,250 --> 00:18:23,720
powerful language but it's kind of weird

00:18:18,039 --> 00:18:25,010
so that's functional programming so PHP

00:18:23,720 --> 00:18:28,039
is not a functional programming

00:18:25,010 --> 00:18:29,929
languages yet it allows you to do some

00:18:28,039 --> 00:18:31,600
sort of functional programming or

00:18:29,929 --> 00:18:35,659
functional programming to some degree

00:18:31,600 --> 00:18:38,419
because it has support for things like

00:18:35,659 --> 00:18:40,580
lambda functions and closures and you

00:18:38,419 --> 00:18:44,240
can pass them around and all that works

00:18:40,580 --> 00:18:47,030
but of course PHP is not a language that

00:18:44,240 --> 00:18:50,030
gives you a guarantee of purity

00:18:47,030 --> 00:18:53,360
you can change state you can mutate data

00:18:50,030 --> 00:18:57,650
there is no language level support that

00:18:53,360 --> 00:18:59,570
prohibits to change the mutation of a

00:18:57,650 --> 00:19:03,559
value that you put into a variable after

00:18:59,570 --> 00:19:06,409
it has been created and of course PHP

00:19:03,559 --> 00:19:09,730
can do recursion but not as optimized as

00:19:06,409 --> 00:19:09,730
some of these functional languages can

00:19:14,550 --> 00:19:22,350
and at least for me it's not a bad thing

00:19:19,080 --> 00:19:25,200
that PHP is not a fully functional

00:19:22,350 --> 00:19:26,670
language it's nice that I can use things

00:19:25,200 --> 00:19:29,700
like lambda functions and closures

00:19:26,670 --> 00:19:33,809
especially when I work with built-in

00:19:29,700 --> 00:19:35,490
functions in PHP to sorting and

00:19:33,809 --> 00:19:39,660
filtering and so on that's really

00:19:35,490 --> 00:19:44,960
convenient and for me what we have in

00:19:39,660 --> 00:19:49,640
PHP to accomplish that is enough but

00:19:44,960 --> 00:19:49,640
other people have other opinions so

00:19:52,010 --> 00:19:56,340
there are some or there were some

00:19:54,390 --> 00:19:58,920
refinements to imperative programming

00:19:56,340 --> 00:20:00,510
first one was structured so a

00:19:58,920 --> 00:20:05,580
programming language is considered

00:20:00,510 --> 00:20:10,440
structured if it is imperative but gives

00:20:05,580 --> 00:20:15,000
you convenience features that make it

00:20:10,440 --> 00:20:18,660
easier to group statements into

00:20:15,000 --> 00:20:21,690
sequences have we have language

00:20:18,660 --> 00:20:23,670
constructs to make a selection like I

00:20:21,690 --> 00:20:25,440
want to branch here or I want to branch

00:20:23,670 --> 00:20:29,450
there and I want to do that without

00:20:25,440 --> 00:20:29,450
using go-to and just jump around

00:20:30,620 --> 00:20:37,679
iteration like loops and recursion and

00:20:35,270 --> 00:20:42,630
one of the first languages that had that

00:20:37,679 --> 00:20:47,520
was Algol in the late 50s became much

00:20:42,630 --> 00:20:50,790
more popular with Pascal and then later

00:20:47,520 --> 00:20:53,010
modular too and Oberon the whole

00:20:50,790 --> 00:20:55,230
category of what people consider the

00:20:53,010 --> 00:20:56,640
Vote languages because although all

00:20:55,230 --> 00:20:58,980
three of them that I just mentioned were

00:20:56,640 --> 00:21:02,340
created by Nicolas word but these

00:20:58,980 --> 00:21:04,679
languages also influenced for instance

00:21:02,340 --> 00:21:07,470
kerning and in Ritchie when they

00:21:04,679 --> 00:21:10,010
designed C so all of these languages

00:21:07,470 --> 00:21:17,280
that are on that are listed here are

00:21:10,010 --> 00:21:19,740
imperative structured languages so of

00:21:17,280 --> 00:21:25,220
course PHP is structured because it's

00:21:19,740 --> 00:21:27,810
imperative it has for while loops it has

00:21:25,220 --> 00:21:31,070
the if statement it has

00:21:27,810 --> 00:21:35,520
statement and so on so imperative

00:21:31,070 --> 00:21:37,530
structured what next what can we think

00:21:35,520 --> 00:21:39,150
about somebody mentioned earlier

00:21:37,530 --> 00:21:41,190
object-oriented but we haven't you're

00:21:39,150 --> 00:21:46,440
not there yet that comes a little bit

00:21:41,190 --> 00:21:48,450
later the next thing that people desired

00:21:46,440 --> 00:21:51,810
when working with programming language

00:21:48,450 --> 00:21:54,540
with programming languages and doing

00:21:51,810 --> 00:21:56,340
development so structured was already a

00:21:54,540 --> 00:21:58,800
big step up because finally it could

00:21:56,340 --> 00:22:01,890
easily do things like an if statement or

00:21:58,800 --> 00:22:05,700
a loop and so on but there was one

00:22:01,890 --> 00:22:08,130
important thing missing that we take for

00:22:05,700 --> 00:22:10,470
granted today in in programming

00:22:08,130 --> 00:22:13,290
languages and that was the concept of

00:22:10,470 --> 00:22:15,390
routines or subroutines or functions or

00:22:13,290 --> 00:22:19,170
procedures whatever you want to call

00:22:15,390 --> 00:22:23,070
them a block a sequence of statements

00:22:19,170 --> 00:22:24,810
that you can assign a name to that can

00:22:23,070 --> 00:22:26,670
have arguments and a return value that

00:22:24,810 --> 00:22:30,450
you can then use for reuse before that

00:22:26,670 --> 00:22:32,190
it was all copypasta right if you wanted

00:22:30,450 --> 00:22:37,590
to really could reuse code you copy

00:22:32,190 --> 00:22:39,720
paste it or yeah III think that we had

00:22:37,590 --> 00:22:41,400
editors already that allowed copy paste

00:22:39,720 --> 00:22:44,670
otherwise you had to do it by hand

00:22:41,400 --> 00:22:49,260
but you had to duplicate code let's put

00:22:44,670 --> 00:22:52,260
it like that so and of course language

00:22:49,260 --> 00:22:56,160
is like basic like C had support for

00:22:52,260 --> 00:23:03,870
procedures and of course PHP is

00:22:56,160 --> 00:23:07,620
procedural and while it became popular

00:23:03,870 --> 00:23:10,440
in the late 80s it's not something that

00:23:07,620 --> 00:23:12,750
only came out in the late 80s came out

00:23:10,440 --> 00:23:15,150
in the late 60s and it's interesting to

00:23:12,750 --> 00:23:18,450
see that it's sometimes really takes one

00:23:15,150 --> 00:23:21,090
or two decades for a new concept to

00:23:18,450 --> 00:23:23,040
catch on to prove that it's worth

00:23:21,090 --> 00:23:25,640
thinking about that and applying that

00:23:23,040 --> 00:23:28,920
and of course it took some time to find

00:23:25,640 --> 00:23:30,690
an implementation in a programming

00:23:28,920 --> 00:23:34,830
language that led to widespread use

00:23:30,690 --> 00:23:37,410
so object orientation came out in the

00:23:34,830 --> 00:23:39,130
late 60s in languages like Simula and a

00:23:37,410 --> 00:23:42,580
couple of years later in

00:23:39,130 --> 00:23:44,770
small talk and this is a programming

00:23:42,580 --> 00:23:47,230
paradigm that uses objects to

00:23:44,770 --> 00:23:50,610
encapsulate data in operations and a

00:23:47,230 --> 00:23:54,330
program an object-oriented program is

00:23:50,610 --> 00:23:57,910
built around the idea that you have

00:23:54,330 --> 00:24:01,930
objects that send each other messages so

00:23:57,910 --> 00:24:04,350
it goes a little bit beyond just having

00:24:01,930 --> 00:24:07,060
procedures that you explicitly call

00:24:04,350 --> 00:24:09,610
whereas now you have an object an object

00:24:07,060 --> 00:24:13,510
represents something hopefully something

00:24:09,610 --> 00:24:15,490
from your domain and if you want to do

00:24:13,510 --> 00:24:18,190
something you send the message to that

00:24:15,490 --> 00:24:21,190
object and as the sender of that message

00:24:18,190 --> 00:24:24,100
you no longer care about how the

00:24:21,190 --> 00:24:25,900
implementation works of getting the

00:24:24,100 --> 00:24:33,400
thing done that you want to get done by

00:24:25,900 --> 00:24:38,710
sending that message so PHP is

00:24:33,400 --> 00:24:42,040
object-oriented at least since PHP 5 yes

00:24:38,710 --> 00:24:44,410
you had most of the keywords necessary

00:24:42,040 --> 00:24:47,140
and most of the language constructs the

00:24:44,410 --> 00:24:51,060
syntax and the semantics available in

00:24:47,140 --> 00:24:57,520
page before but it was not really great

00:24:51,060 --> 00:25:00,250
only with PHP 5 12 years ago that became

00:24:57,520 --> 00:25:04,540
really a viable approach to developing

00:25:00,250 --> 00:25:08,260
software as PHP but there is not just

00:25:04,540 --> 00:25:09,940
one object-oriented paradigm it has

00:25:08,260 --> 00:25:13,260
separate sub paradigms for instance

00:25:09,940 --> 00:25:17,050
class oriented so PHP is a class

00:25:13,260 --> 00:25:21,570
oriented or PHP has support for class

00:25:17,050 --> 00:25:21,570
oriented object-oriented programming

00:25:22,710 --> 00:25:29,410
what this means is that objects are

00:25:25,780 --> 00:25:35,130
built based on blueprints that you have

00:25:29,410 --> 00:25:40,780
written down as classes and inheritance

00:25:35,130 --> 00:25:44,020
happens on the class level you can

00:25:40,780 --> 00:25:47,760
inherit from a class can inherit from

00:25:44,020 --> 00:25:51,310
one parent class not like in languages

00:25:47,760 --> 00:25:52,769
not like in languages such as C++ or

00:25:51,310 --> 00:25:56,580
common

00:25:52,769 --> 00:25:58,889
you cannot inherit from multiple parent

00:25:56,580 --> 00:26:00,779
classes and that's a good thing at least

00:25:58,889 --> 00:26:03,990
it's a good thing that you cannot do it

00:26:00,779 --> 00:26:06,269
the way you have to do it in C++ would

00:26:03,990 --> 00:26:10,080
be okay if you were able to do it like

00:26:06,269 --> 00:26:13,080
in an in Common Lisp because the common

00:26:10,080 --> 00:26:16,919
list object system is build around Lisp

00:26:13,080 --> 00:26:20,159
and the Lisp runtime lets you rearrange

00:26:16,919 --> 00:26:22,380
and customize the same core semantics of

00:26:20,159 --> 00:26:25,379
the language at runtime so your program

00:26:22,380 --> 00:26:28,169
could say I want multiple inherited

00:26:25,379 --> 00:26:31,230
multiple inheritance to work exactly

00:26:28,169 --> 00:26:33,960
like this in my project so I do not run

00:26:31,230 --> 00:26:37,350
into all the common problems that

00:26:33,960 --> 00:26:40,919
multiple inheritance brings with it but

00:26:37,350 --> 00:26:43,789
I think that's out of the scope of this

00:26:40,919 --> 00:26:48,779
presentation to go into all these

00:26:43,789 --> 00:26:51,750
problems and it was but it was these

00:26:48,779 --> 00:26:54,029
problems with multiple inheritance that

00:26:51,750 --> 00:26:56,220
let the designers of Java for instance

00:26:54,029 --> 00:26:58,409
to say no we do not want multiple

00:26:56,220 --> 00:27:01,259
inheritance we do not want multiple

00:26:58,409 --> 00:27:03,960
inheritance of implementation but what

00:27:01,259 --> 00:27:06,570
we want to do is something else to get

00:27:03,960 --> 00:27:07,950
what most people want from multiple

00:27:06,570 --> 00:27:10,409
inheritance which is multiple

00:27:07,950 --> 00:27:13,639
inheritance of interface I want to be

00:27:10,409 --> 00:27:18,000
able to express that a class provides

00:27:13,639 --> 00:27:22,710
multiple interfaces and yes PHP also

00:27:18,000 --> 00:27:24,389
supports that and since PHP 5-4 we have

00:27:22,710 --> 00:27:26,519
something called traits which is a

00:27:24,389 --> 00:27:28,830
feature for horizontal reuse so we can

00:27:26,519 --> 00:27:31,860
have sets of methods that we can mix in

00:27:28,830 --> 00:27:34,440
at various points in our class hierarchy

00:27:31,860 --> 00:27:36,120
and get multiple inheritance of

00:27:34,440 --> 00:27:39,929
implementation without multiple

00:27:36,120 --> 00:27:41,879
inheritance of type so that is another

00:27:39,929 --> 00:27:44,250
approach to solve all the bad problems

00:27:41,879 --> 00:27:49,860
with multiple inheritance in a language

00:27:44,250 --> 00:27:55,409
such as C++ I just mentioned the word

00:27:49,860 --> 00:27:57,120
type and that's where things with

00:27:55,409 --> 00:27:58,799
regards to differences between

00:27:57,120 --> 00:28:01,250
programming languages become really

00:27:58,799 --> 00:28:01,250
interesting

00:28:03,530 --> 00:28:10,590
what I'm going to talk about now bear in

00:28:07,710 --> 00:28:13,170
mind that while there are many different

00:28:10,590 --> 00:28:16,860
approaches there is not one right

00:28:13,170 --> 00:28:19,250
approach at least over the last four

00:28:16,860 --> 00:28:22,080
five six decades

00:28:19,250 --> 00:28:24,690
neither the academic world of computer

00:28:22,080 --> 00:28:26,970
science rich research nor the practical

00:28:24,690 --> 00:28:31,200
world of people building software to get

00:28:26,970 --> 00:28:36,570
things done have agreed on what the best

00:28:31,200 --> 00:28:39,390
way is to handle the concept of types or

00:28:36,570 --> 00:28:41,910
most importantly how to enforce rules

00:28:39,390 --> 00:28:44,520
based on types in the programming

00:28:41,910 --> 00:28:50,970
language all of them have their pros and

00:28:44,520 --> 00:28:52,950
cons so let's get through them first of

00:28:50,970 --> 00:28:54,480
all what is a type system a type system

00:28:52,950 --> 00:28:56,580
is a collection of rules that is signed

00:28:54,480 --> 00:28:58,950
a property called type to various

00:28:56,580 --> 00:29:01,679
constructs a computer program consists

00:28:58,950 --> 00:29:05,100
of such as variables expressions

00:29:01,679 --> 00:29:07,860
functions or modules so if I have a

00:29:05,100 --> 00:29:10,470
variable that variable contains a value

00:29:07,860 --> 00:29:12,660
and that value has a type if I have a

00:29:10,470 --> 00:29:14,540
variable and I assign an integer to that

00:29:12,660 --> 00:29:17,880
then that variable has the type integer

00:29:14,540 --> 00:29:19,830
now there are languages that allow me to

00:29:17,880 --> 00:29:21,330
on the next line assign the value of

00:29:19,830 --> 00:29:23,880
some kind completely other types such

00:29:21,330 --> 00:29:26,400
variable where other languages don't

00:29:23,880 --> 00:29:30,809
allow me to do that so this is what a

00:29:26,400 --> 00:29:32,670
type system is about and as I mentioned

00:29:30,809 --> 00:29:36,120
there are many different types of type

00:29:32,670 --> 00:29:40,530
system so for instance there is explicit

00:29:36,120 --> 00:29:44,250
typing which is more commonly referred

00:29:40,530 --> 00:29:47,550
to as manifest typing because the types

00:29:44,250 --> 00:29:49,590
the type in information manifests or is

00:29:47,550 --> 00:29:53,700
manifested in the source code of the

00:29:49,590 --> 00:29:56,730
program and that's those are programming

00:29:53,700 --> 00:30:00,540
languages that require you to provide

00:29:56,730 --> 00:30:04,110
type information in the source code for

00:30:00,540 --> 00:30:06,900
each construct that can hold over their

00:30:04,110 --> 00:30:10,170
type is relevant and though there are a

00:30:06,900 --> 00:30:14,670
couple of languages that use that like C

00:30:10,170 --> 00:30:17,010
C++ Java and c-sharp so for instance

00:30:14,670 --> 00:30:21,930
ever have a Java program like this it

00:30:17,010 --> 00:30:24,680
has a method that method takes that

00:30:21,930 --> 00:30:28,950
method has an argument an argument

00:30:24,680 --> 00:30:31,710
argument names other now if I've and

00:30:28,950 --> 00:30:35,400
they'd have type information there sits

00:30:31,710 --> 00:30:38,370
day saying that if a parameter from the

00:30:35,400 --> 00:30:41,400
outside is passed to this method as an

00:30:38,370 --> 00:30:43,620
argument the types have to match the

00:30:41,400 --> 00:30:47,040
type of the parameter has to match the

00:30:43,620 --> 00:30:49,320
type of the argument so if I pass

00:30:47,040 --> 00:30:52,440
something other than the money I get the

00:30:49,320 --> 00:30:56,700
compile time error I have a local

00:30:52,440 --> 00:31:00,330
variable named sum I cannot have a

00:30:56,700 --> 00:31:03,650
variable in Java without declaring its

00:31:00,330 --> 00:31:07,920
type without telling the compiler

00:31:03,650 --> 00:31:12,480
explicitly what types of value I want to

00:31:07,920 --> 00:31:15,420
hold in that variable at the end I

00:31:12,480 --> 00:31:19,230
return return value and that return

00:31:15,420 --> 00:31:22,070
value is of type money and again that

00:31:19,230 --> 00:31:26,160
type has to match what I explicitly

00:31:22,070 --> 00:31:31,950
declared the return type of this method

00:31:26,160 --> 00:31:38,390
to be now contrast this example with

00:31:31,950 --> 00:31:41,490
speech before which is implicitly typed

00:31:38,390 --> 00:31:44,460
implicitly typing basically meaning not

00:31:41,490 --> 00:31:46,200
explicitly typed I have a class named

00:31:44,460 --> 00:31:50,550
money that money class has a method

00:31:46,200 --> 00:31:53,070
named add that method named add has an

00:31:50,550 --> 00:31:57,600
argument named other but I have no type

00:31:53,070 --> 00:31:59,910
information so now at some other place

00:31:57,600 --> 00:32:01,950
in my program I can go and create an

00:31:59,910 --> 00:32:04,680
object of type money and call the add

00:32:01,950 --> 00:32:11,730
method on that and pass something as an

00:32:04,680 --> 00:32:14,880
argument that is not money object

00:32:11,730 --> 00:32:17,730
that leaves a fatal error sorry by the

00:32:14,880 --> 00:32:20,670
way for that output I do not have peach

00:32:17,730 --> 00:32:25,190
before anymore so I've wrote peach

00:32:20,670 --> 00:32:25,190
before style code and ran it with PHP 7

00:32:26,780 --> 00:32:33,360
the arrow itself will be the same but

00:32:30,210 --> 00:32:34,730
the text probably be different but I

00:32:33,360 --> 00:32:37,500
hope that's okay

00:32:34,730 --> 00:32:42,270
couldn't get peach before to compile on

00:32:37,500 --> 00:32:44,070
a 2016 Linux system so and hopefully I'm

00:32:42,270 --> 00:32:48,240
the only one that has a problem nobody's

00:32:44,070 --> 00:32:50,400
using peach before anymore so I get an I

00:32:48,240 --> 00:32:53,760
get a runtime error so whereas a

00:32:50,400 --> 00:32:56,400
language such as Java is able to tell me

00:32:53,760 --> 00:32:58,950
at compile time because it has all the

00:32:56,400 --> 00:33:01,440
information it needs at compile time hey

00:32:58,950 --> 00:33:03,780
you're doing it wrong you're calling

00:33:01,440 --> 00:33:05,550
something that wants a money object with

00:33:03,780 --> 00:33:09,240
something that is not a money object fix

00:33:05,550 --> 00:33:17,280
this in PHP I get that problem or

00:33:09,240 --> 00:33:19,140
reported at runtime but not because it

00:33:17,280 --> 00:33:21,330
can detect at runtime that the type of

00:33:19,140 --> 00:33:24,990
the object doesn't match but it fails

00:33:21,330 --> 00:33:27,690
because that method does not exist on

00:33:24,990 --> 00:33:29,670
the object that was passed and I would

00:33:27,690 --> 00:33:31,110
get a totally different error and it

00:33:29,670 --> 00:33:39,870
would pass something that is not even an

00:33:31,110 --> 00:33:43,170
object so back in the PHP for days and

00:33:39,870 --> 00:33:46,170
that that may be for some of you a trip

00:33:43,170 --> 00:33:50,040
down memory lane is you had lots of code

00:33:46,170 --> 00:33:53,400
like this you added a guard Clause there

00:33:50,040 --> 00:33:56,850
was a function called is a I could ask

00:33:53,400 --> 00:34:01,230
hey is this variable does that contain

00:33:56,850 --> 00:34:02,790
an object of that type and of course

00:34:01,230 --> 00:34:04,290
back then pitch before we didn't have

00:34:02,790 --> 00:34:06,300
exception so we couldn't even throw an

00:34:04,290 --> 00:34:08,940
exception so we had to use trigger error

00:34:06,300 --> 00:34:12,420
to signal hey you called me with

00:34:08,940 --> 00:34:14,250
something that I don't want but that

00:34:12,420 --> 00:34:16,410
error message is already better than

00:34:14,250 --> 00:34:18,420
what I had before because instead of

00:34:16,410 --> 00:34:20,010
yeah you passed me something and I tried

00:34:18,420 --> 00:34:23,280
to call a method on that and that

00:34:20,010 --> 00:34:25,560
doesn't exist now I get hey I can tell

00:34:23,280 --> 00:34:27,180
you I want this

00:34:25,560 --> 00:34:30,260
you give me that and that doesn't

00:34:27,180 --> 00:34:37,050
mention much more helpful

00:34:30,260 --> 00:34:39,720
so with php5 added support for type

00:34:37,050 --> 00:34:42,630
declarations for function and method

00:34:39,720 --> 00:34:47,310
signatures but only allowed it for

00:34:42,630 --> 00:34:51,360
certain types it allowed it for class

00:34:47,310 --> 00:34:54,900
names interface names 55:1 introduced

00:34:51,360 --> 00:34:59,370
array at some point later we got

00:34:54,900 --> 00:35:04,920
callable but here we can now have a

00:34:59,370 --> 00:35:07,650
method named add it has a argument named

00:35:04,920 --> 00:35:11,040
other or a parameter named other and

00:35:07,650 --> 00:35:13,040
that has now a type and the types money

00:35:11,040 --> 00:35:16,920
and when I'd try to do what I did before

00:35:13,040 --> 00:35:19,590
now I don't need my own guard clause

00:35:16,920 --> 00:35:23,400
anymore there is a PHP notice that

00:35:19,590 --> 00:35:27,420
itself it doesn't do it at compile time

00:35:23,400 --> 00:35:29,190
like Java does for instance but it does

00:35:27,420 --> 00:35:31,260
it at runtime so I get a runtime error

00:35:29,190 --> 00:35:34,170
argument one pass the money add must be

00:35:31,260 --> 00:35:41,970
instance of money instead in instance of

00:35:34,170 --> 00:35:45,990
a STD class given so I already mentioned

00:35:41,970 --> 00:35:47,610
earlier opposite from explicit typing we

00:35:45,990 --> 00:35:51,110
have implicit typing and that's a type

00:35:47,610 --> 00:35:54,420
system which requires few or no type in

00:35:51,110 --> 00:35:56,070
annotations meaning type declarations of

00:35:54,420 --> 00:35:59,790
variables object members function

00:35:56,070 --> 00:36:01,920
arguments etc and there are a couple of

00:35:59,790 --> 00:36:04,500
those languages out there basically

00:36:01,920 --> 00:36:08,100
that's what people refer to when they

00:36:04,500 --> 00:36:12,330
mean dynamic languages and dynamic

00:36:08,100 --> 00:36:14,220
languages are coming all different kinds

00:36:12,330 --> 00:36:16,640
of flavours so you get functional

00:36:14,220 --> 00:36:20,250
dynamic languages like Common Lisp

00:36:16,640 --> 00:36:23,220
you'll get something like PHP you get

00:36:20,250 --> 00:36:28,440
something like Python and the list could

00:36:23,220 --> 00:36:31,590
be really really long there's an

00:36:28,440 --> 00:36:33,120
interesting mix if you couple implicit

00:36:31,590 --> 00:36:38,160
typing with something that is called

00:36:33,120 --> 00:36:39,360
type inference so you don't require the

00:36:38,160 --> 00:36:41,430
developer to put

00:36:39,360 --> 00:36:46,620
type information explicitly into the

00:36:41,430 --> 00:36:49,560
code and empower the compiler make the

00:36:46,620 --> 00:36:52,500
compiler really really powerful to

00:36:49,560 --> 00:36:56,510
deduce from the information that is

00:36:52,500 --> 00:37:00,120
there which types to develop our meant

00:36:56,510 --> 00:37:04,230
it's in fear in first types and based on

00:37:00,120 --> 00:37:09,120
that information it enforces types at

00:37:04,230 --> 00:37:12,780
compile time and for instance Haskell

00:37:09,120 --> 00:37:17,030
and oh camel do that there's currently

00:37:12,780 --> 00:37:21,330
work being done as part of PHP seven one

00:37:17,030 --> 00:37:24,990
to add type inference to PHP not

00:37:21,330 --> 00:37:27,990
necessarily at least not yet to do what

00:37:24,990 --> 00:37:29,790
languages like Haskell or Oh camel do be

00:37:27,990 --> 00:37:36,470
it at compile time or at runtime to

00:37:29,790 --> 00:37:40,560
enforce rules of the type system but to

00:37:36,470 --> 00:37:43,410
improve the optimizer of PHP compiler to

00:37:40,560 --> 00:37:46,140
generate better up code a optimized

00:37:43,410 --> 00:37:49,980
opcode optimized bytecode so that

00:37:46,140 --> 00:37:51,420
execution is faster but maybe at some

00:37:49,980 --> 00:37:54,510
point in the future that same

00:37:51,420 --> 00:37:57,090
information generated through type

00:37:54,510 --> 00:37:59,670
inference while compiling PHP source

00:37:57,090 --> 00:38:06,290
code in the PHP bytecode could be used

00:37:59,670 --> 00:38:12,920
to enforce type rules at some point

00:38:06,290 --> 00:38:16,350
interesting stuff so that was dynamic

00:38:12,920 --> 00:38:17,610
was it what if we talk about know that

00:38:16,350 --> 00:38:21,140
there was an explicit versus implicit

00:38:17,610 --> 00:38:21,140
typing sorry

00:38:21,830 --> 00:38:29,610
now we come to strong versus weak typing

00:38:24,870 --> 00:38:32,190
so a language uses strong typing that's

00:38:29,610 --> 00:38:37,230
basically what Barbara Liskov who you

00:38:32,190 --> 00:38:39,090
should be familiar with because the L in

00:38:37,230 --> 00:38:42,780
solid solid principles for good

00:38:39,090 --> 00:38:45,420
object-oriented design the L and solid

00:38:42,780 --> 00:38:48,360
to Liskov substitution principle that's

00:38:45,420 --> 00:38:49,920
Barbara Liskov whenever an object is

00:38:48,360 --> 00:38:52,410
passed from a calling function to a

00:38:49,920 --> 00:38:53,070
called function it's type must be

00:38:52,410 --> 00:38:54,930
compact

00:38:53,070 --> 00:38:57,420
with a type declared in the cult

00:38:54,930 --> 00:38:59,790
function and that's what you have in

00:38:57,420 --> 00:39:02,850
languages like Common Lisp C++ Python

00:38:59,790 --> 00:39:05,310
Java and c-sharp for instance it's not

00:39:02,850 --> 00:39:09,840
something that you have in C for

00:39:05,310 --> 00:39:14,040
instance because C is weakly typed which

00:39:09,840 --> 00:39:15,960
is surprising to some people so what

00:39:14,040 --> 00:39:17,850
does this mean it means that for

00:39:15,960 --> 00:39:20,430
instance in Java if I have code like

00:39:17,850 --> 00:39:23,190
this I declare a variable named D and

00:39:20,430 --> 00:39:27,860
tell Java that I want to store a double

00:39:23,190 --> 00:39:31,380
in there and then I declare a variable

00:39:27,860 --> 00:39:33,480
to hold an integer and then I want to

00:39:31,380 --> 00:39:36,600
assign the value that is a double to the

00:39:33,480 --> 00:39:37,370
value to the variable that holds an

00:39:36,600 --> 00:39:39,960
integer

00:39:37,370 --> 00:39:43,380
those are incompatible types Java

00:39:39,960 --> 00:39:48,890
doesn't allow me to do that it tells me

00:39:43,380 --> 00:39:53,340
go fix your there is no automatic

00:39:48,890 --> 00:39:56,250
casting going on behind the scenes so I

00:39:53,340 --> 00:39:59,850
have to do explicit casting I have to

00:39:56,250 --> 00:40:02,940
tell the compiler yeah I know about the

00:39:59,850 --> 00:40:05,100
loss of precision when I convert from a

00:40:02,940 --> 00:40:08,670
double to an int but ignore this for

00:40:05,100 --> 00:40:16,070
this statement please cast it down from

00:40:08,670 --> 00:40:18,360
double to integer and the weakest

00:40:16,070 --> 00:40:20,460
description for all of the things that

00:40:18,360 --> 00:40:25,560
I'm talking about here today that you

00:40:20,460 --> 00:40:28,230
can find is for weak typing and you see

00:40:25,560 --> 00:40:30,990
that that I didn't even bother to put

00:40:28,230 --> 00:40:32,790
one there because the most useful one

00:40:30,990 --> 00:40:35,550
that you can find is everything that is

00:40:32,790 --> 00:40:37,620
not strong typed is weak typed but there

00:40:35,550 --> 00:40:40,250
are different types of weak typing to

00:40:37,620 --> 00:40:40,250
make it more interesting

00:40:41,780 --> 00:40:49,890
so in for for our context since PHP

00:40:45,630 --> 00:40:53,130
draws a lot of inspiration from C both C

00:40:49,890 --> 00:40:57,420
and PHP are weakly typed that means in C

00:40:53,130 --> 00:40:59,310
or in PHP this would not be a problem we

00:40:57,420 --> 00:41:02,220
would not have to add the explicit cast

00:40:59,310 --> 00:41:03,870
of course you can add the explicit cast

00:41:02,220 --> 00:41:06,030
it's just optional it just happens

00:41:03,870 --> 00:41:08,660
behind the scenes if you don't put it

00:41:06,030 --> 00:41:08,660
explicitly there

00:41:08,900 --> 00:41:24,500
so PHP is weakly typed another

00:41:18,810 --> 00:41:29,090
interesting aspect is when do we enforce

00:41:24,500 --> 00:41:31,440
these the rules of our type system

00:41:29,090 --> 00:41:34,730
there's for instance static type

00:41:31,440 --> 00:41:37,470
checking which verifies the type safety

00:41:34,730 --> 00:41:41,400
of a program based on analysis of source

00:41:37,470 --> 00:41:43,860
code so that is due to static code

00:41:41,400 --> 00:41:47,730
analysis that happens at compile time

00:41:43,860 --> 00:41:51,090
and that's what you get in C C++ Java C

00:41:47,730 --> 00:41:52,080
sharp for instance if you have a Java

00:41:51,090 --> 00:41:56,570
project

00:41:52,080 --> 00:41:58,970
program like this and I I equals true

00:41:56,570 --> 00:42:01,950
Java compiler won't let you do that

00:41:58,970 --> 00:42:06,110
tells you know those are incompatible

00:42:01,950 --> 00:42:08,940
types not going to do that for you and

00:42:06,110 --> 00:42:10,770
if the compiler tells you no I'm not

00:42:08,940 --> 00:42:15,060
going to do that for you at the ports

00:42:10,770 --> 00:42:18,560
and you do not get a binary you cannot

00:42:15,060 --> 00:42:21,660
get this type of error at runtime you

00:42:18,560 --> 00:42:24,930
get it at compile time you'll never be

00:42:21,660 --> 00:42:27,300
able to execute a program that has a

00:42:24,930 --> 00:42:29,010
problem like this because your compiler

00:42:27,300 --> 00:42:33,110
will not generate something that you can

00:42:29,010 --> 00:42:33,110
execute if you have a problem like this

00:42:35,870 --> 00:42:44,640
so PHP is a little bit weird when it

00:42:39,600 --> 00:42:51,000
comes to static versus dynamic because

00:42:44,640 --> 00:42:53,940
where we are able to do type checks at

00:42:51,000 --> 00:42:56,880
compile time we do like for instance

00:42:53,940 --> 00:43:01,110
with the new void return type that was

00:42:56,880 --> 00:43:04,350
added in PHP 71 don't ask me why we

00:43:01,110 --> 00:43:06,870
didn't have the void return type in PHP

00:43:04,350 --> 00:43:10,230
7 0 it should have been there it was

00:43:06,870 --> 00:43:14,420
forgotten it came too late and there was

00:43:10,230 --> 00:43:18,840
no consensus to put that into seven oh

00:43:14,420 --> 00:43:21,170
so 57 one basically makes

00:43:18,840 --> 00:43:25,440
to return type declarations in

00:43:21,170 --> 00:43:27,840
introduced in page.php 7 much more

00:43:25,440 --> 00:43:29,910
useful makes it makes them complete so

00:43:27,840 --> 00:43:34,770
if we have a function named F in this

00:43:29,910 --> 00:43:38,550
example that says I do not have a return

00:43:34,770 --> 00:43:41,250
value and if at some point in the code

00:43:38,550 --> 00:43:46,830
there is a return statement that is

00:43:41,250 --> 00:43:49,320
something that violates the void return

00:43:46,830 --> 00:43:51,840
type declaration and that is something

00:43:49,320 --> 00:43:55,530
that I can detect that the PHP compiler

00:43:51,840 --> 00:43:59,190
can detect at compile time and at

00:43:55,530 --> 00:44:01,920
compile time you will get an error it's

00:43:59,190 --> 00:44:07,590
not something that we have to wait to

00:44:01,920 --> 00:44:10,440
detect at runtime so that's good so

00:44:07,590 --> 00:44:15,770
dynamic type checking means verifying a

00:44:10,440 --> 00:44:19,050
type safety of a program at runtime and

00:44:15,770 --> 00:44:20,640
that's what dynamic languages do that's

00:44:19,050 --> 00:44:22,920
what Common Lisp does that was that's

00:44:20,640 --> 00:44:24,780
what Python does that for PHP does it

00:44:22,920 --> 00:44:32,130
for Perl does that was that's what Ruby

00:44:24,780 --> 00:44:36,420
does and so on and if I have a function

00:44:32,130 --> 00:44:39,330
named F that says I returned a return

00:44:36,420 --> 00:44:41,640
value of type int and then I return

00:44:39,330 --> 00:44:46,860
something that is not an int but a

00:44:41,640 --> 00:44:50,180
string in this example then I get a type

00:44:46,860 --> 00:44:53,280
error at runtime this is not something

00:44:50,180 --> 00:44:57,480
that the PHP compiler can detect at

00:44:53,280 --> 00:44:59,130
compile time well at least it doesn't

00:44:57,480 --> 00:45:02,850
for this for this really really really

00:44:59,130 --> 00:45:03,470
simple case where it's obvious it could

00:45:02,850 --> 00:45:05,670
be added

00:45:03,470 --> 00:45:10,170
thanks to type interference at some

00:45:05,670 --> 00:45:12,870
point because I'm returning I have a

00:45:10,170 --> 00:45:14,580
ever have a return statement and the

00:45:12,870 --> 00:45:20,550
return statement doesn't take a variable

00:45:14,580 --> 00:45:23,580
but it returns a constant basically if

00:45:20,550 --> 00:45:25,520
you want that can that can be detected

00:45:23,580 --> 00:45:29,090
but we don't detect that at the moment

00:45:25,520 --> 00:45:29,090
that's a runtime error

00:45:35,410 --> 00:45:39,370
we talked earlier about the fact that

00:45:38,000 --> 00:45:43,280
php5

00:45:39,370 --> 00:45:48,710
introduced type declarations for

00:45:43,280 --> 00:45:51,500
function and method parameters for class

00:45:48,710 --> 00:45:55,880
for classes interfaces and arrays and

00:45:51,500 --> 00:46:00,320
collar balls but php5 did not have

00:45:55,880 --> 00:46:02,450
support for type declarations for

00:46:00,320 --> 00:46:05,780
function methods our parameters that

00:46:02,450 --> 00:46:14,420
used Sora calls gala types things like

00:46:05,780 --> 00:46:16,670
strings and floats don't really want to

00:46:14,420 --> 00:46:19,310
go into too much detail here if you're

00:46:16,670 --> 00:46:23,600
interested in how we arrived at the

00:46:19,310 --> 00:46:27,230
solution that I'm about to show come to

00:46:23,600 --> 00:46:30,200
my talk on Thursday or to the workshop

00:46:27,230 --> 00:46:32,690
on Thursday have much more time there to

00:46:30,200 --> 00:46:35,480
go to dig into the history and how how

00:46:32,690 --> 00:46:41,690
we got there but this is what we have

00:46:35,480 --> 00:46:45,110
now in 57 you can now use scalar types

00:46:41,690 --> 00:46:48,050
in type declarations for function and

00:46:45,110 --> 00:46:50,900
method parameters we can say in this

00:46:48,050 --> 00:46:53,000
example I have a method named M and M

00:46:50,900 --> 00:46:56,620
wants three arguments and the first one

00:46:53,000 --> 00:47:01,540
is a string and int and the float and

00:46:56,620 --> 00:47:05,740
the default behavior is so-called

00:47:01,540 --> 00:47:09,790
coercive meaning PHP behind-the-scenes

00:47:05,740 --> 00:47:14,800
automatically makes sure that I get an

00:47:09,790 --> 00:47:20,510
argument of a certain type is coerced

00:47:14,800 --> 00:47:23,870
cast convert it into the type that I

00:47:20,510 --> 00:47:25,550
expect for the parameter so for instance

00:47:23,870 --> 00:47:27,020
if I call this with something that is

00:47:25,550 --> 00:47:30,110
not a string of an int or not or not a

00:47:27,020 --> 00:47:32,780
float then PHP automatically converts

00:47:30,110 --> 00:47:39,500
that which may or may not be what you

00:47:32,780 --> 00:47:42,550
want if you are like me then you want

00:47:39,500 --> 00:47:42,550
things to be strict

00:47:42,610 --> 00:47:47,930
but if you are like me then you don't

00:47:45,350 --> 00:47:54,320
want them to be like this but this is

00:47:47,930 --> 00:47:57,020
what we got this there's a second mode

00:47:54,320 --> 00:48:00,860
of operation for this firm for the

00:47:57,020 --> 00:48:02,900
scalar type declarations different

00:48:00,860 --> 00:48:07,160
semantics for the same syntax if you

00:48:02,900 --> 00:48:09,650
will so if you have in one file the

00:48:07,160 --> 00:48:12,590
declaration for Class C with its method

00:48:09,650 --> 00:48:14,810
M and then in some other file you use

00:48:12,590 --> 00:48:20,360
that class and call the methods from

00:48:14,810 --> 00:48:23,570
there and if in that other file you use

00:48:20,360 --> 00:48:28,330
the pragma strict types and set it to 1

00:48:23,570 --> 00:48:28,330
which means enable strict type checking

00:48:28,840 --> 00:48:37,400
then the type declarations of the scalar

00:48:34,910 --> 00:48:42,619
type declarations of functions and

00:48:37,400 --> 00:48:46,640
methods called from this file from this

00:48:42,619 --> 00:48:48,920
file are strictly enforced if the type

00:48:46,640 --> 00:48:55,490
of argument and parameter don't match

00:48:48,920 --> 00:48:59,300
there's an error I would have liked it I

00:48:55,490 --> 00:49:00,980
mean if we have to have two modes of

00:48:59,300 --> 00:49:02,350
operations then I would have liked it

00:49:00,980 --> 00:49:05,450
the other way around

00:49:02,350 --> 00:49:08,300
meaning if I put declare strict types

00:49:05,450 --> 00:49:11,990
equals one into the file that declares a

00:49:08,300 --> 00:49:18,440
Class C that should mean everyone that

00:49:11,990 --> 00:49:20,930
calls me should be type safe but that's

00:49:18,440 --> 00:49:25,570
not what we got if you want more details

00:49:20,930 --> 00:49:31,460
on that come to the thing on Thursday

00:49:25,570 --> 00:49:32,990
okay so two modes of operations two

00:49:31,460 --> 00:49:39,260
modes of operation four scalar type

00:49:32,990 --> 00:49:41,660
declarations this is what we got just

00:49:39,260 --> 00:49:47,060
the day before yesterday I learned a new

00:49:41,660 --> 00:49:49,160
term which is called type terrorists not

00:49:47,060 --> 00:49:50,420
only I'm not at an airport I'm allowed

00:49:49,160 --> 00:49:53,600
to say the word terrorists

00:49:50,420 --> 00:49:54,570
so advert advocates for static typing

00:49:53,600 --> 00:49:56,580
are end

00:49:54,570 --> 00:49:58,620
because they argue that the only

00:49:56,580 --> 00:50:00,960
problems the only programs we should

00:49:58,620 --> 00:50:03,900
allow to run are the ones that have been

00:50:00,960 --> 00:50:06,150
verified by machines in contrast the

00:50:03,900 --> 00:50:08,790
freedom fighters contrary to these

00:50:06,150 --> 00:50:10,290
typing terrorists argue that humans can

00:50:08,790 --> 00:50:13,410
perform analysis and ISM in

00:50:10,290 --> 00:50:16,770
decision-making as well so what Jamie

00:50:13,410 --> 00:50:20,780
McCarthy is saying I want the freedom of

00:50:16,770 --> 00:50:24,030
an implicitly typed dynamically typed

00:50:20,780 --> 00:50:28,350
language because I can think for myself

00:50:24,030 --> 00:50:34,640
I do not need a machine to tell me what

00:50:28,350 --> 00:50:38,460
I'm allowed to run I know better and

00:50:34,640 --> 00:50:42,030
this is a really nice summary of the 40

00:50:38,460 --> 00:50:43,410
50 year not really war some people call

00:50:42,030 --> 00:50:46,530
it a war because it sounds more

00:50:43,410 --> 00:50:48,390
interesting just like the local

00:50:46,530 --> 00:50:50,510
newspaper from Frankfurt called

00:50:48,390 --> 00:50:53,220
yesterday's incident with my plane an

00:50:50,510 --> 00:50:55,800
emergency landing where in fact it

00:50:53,220 --> 00:50:56,580
wasn't an emergency landing nothing was

00:50:55,800 --> 00:51:00,150
on fire

00:50:56,580 --> 00:51:01,860
there was no foam Fire Department just

00:51:00,150 --> 00:51:04,230
had to show up because the redundancy

00:51:01,860 --> 00:51:06,930
was not given anymore anymore this is

00:51:04,230 --> 00:51:12,630
not a war it's just different opinions

00:51:06,930 --> 00:51:16,440
and there is no true answer to what what

00:51:12,630 --> 00:51:19,890
is better if you used if you use a

00:51:16,440 --> 00:51:23,210
statically typed language that has a

00:51:19,890 --> 00:51:27,420
strong type system you catch a lot more

00:51:23,210 --> 00:51:32,700
errors at compile time yes you probably

00:51:27,420 --> 00:51:37,140
need a lot less unit tests yes if on the

00:51:32,700 --> 00:51:41,130
other hand you use a dynamically typed

00:51:37,140 --> 00:51:43,950
language maybe with type inference to

00:51:41,130 --> 00:51:46,740
get all of the same benefits but feel

00:51:43,950 --> 00:51:49,440
better not oppressed by a terrorist

00:51:46,740 --> 00:51:54,750
compiler however you want to look at

00:51:49,440 --> 00:51:58,770
that while you're working but in my

00:51:54,750 --> 00:52:00,480
opinion only if you also have a good

00:51:58,770 --> 00:52:02,520
amount of tests that give you the same

00:52:00,480 --> 00:52:07,960
checks that the other languages gives

00:52:02,520 --> 00:52:10,330
you a compile time but at runtime so

00:52:07,960 --> 00:52:12,310
take your pick I mean you are at a PHP

00:52:10,330 --> 00:52:13,930
conference so you probably already know

00:52:12,310 --> 00:52:17,770
that this feels right for you

00:52:13,930 --> 00:52:19,960
but now you know how to how PHP relates

00:52:17,770 --> 00:52:22,510
according to all these different aspects

00:52:19,960 --> 00:52:28,050
of programming language design to other

00:52:22,510 --> 00:52:31,119
languages so PHP is dynamically typed

00:52:28,050 --> 00:52:35,260
some checks that can be performed at

00:52:31,119 --> 00:52:41,050
compile time are performed at compile

00:52:35,260 --> 00:52:44,230
time PHP is implicitly typed weakly

00:52:41,050 --> 00:52:48,040
typed it does not require you to use any

00:52:44,230 --> 00:52:52,240
type of type declaration anywhere in

00:52:48,040 --> 00:52:56,770
your code but there are more and more

00:52:52,240 --> 00:52:59,980
places in the syntax where you can add

00:52:56,770 --> 00:53:02,619
these type declarations started with PHP

00:52:59,980 --> 00:53:05,520
5 where we allowed type declarations for

00:53:02,619 --> 00:53:07,599
classes interfaces arrays color balls in

00:53:05,520 --> 00:53:11,980
method signatures and function

00:53:07,599 --> 00:53:14,050
signatures it expanded now with scalar

00:53:11,980 --> 00:53:16,839
types for type declarations in function

00:53:14,050 --> 00:53:20,710
method signatures it expanded with

00:53:16,839 --> 00:53:24,040
return type declarations at the moment

00:53:20,710 --> 00:53:27,130
there's an RFC to add type declarations

00:53:24,040 --> 00:53:31,330
to attributes of classes so you can

00:53:27,130 --> 00:53:34,119
write things like private int dollar

00:53:31,330 --> 00:53:36,220
amount for instance and PHP will then

00:53:34,119 --> 00:53:40,540
enforce at runtime that in that

00:53:36,220 --> 00:53:43,150
attribute of the object they they cannot

00:53:40,540 --> 00:53:45,670
be something that is not an int which

00:53:43,150 --> 00:53:48,480
reduces a lot the amount of code that

00:53:45,670 --> 00:53:52,420
you have to put in your code it's

00:53:48,480 --> 00:53:54,490
explicitly to ensure this type safety so

00:53:52,420 --> 00:53:59,140
I think that's good other people

00:53:54,490 --> 00:54:02,890
disagree that's why we have RFC's and

00:53:59,140 --> 00:54:04,930
discussions and votes so we can figure

00:54:02,890 --> 00:54:09,250
out what the best way is for PHP to go

00:54:04,930 --> 00:54:12,339
into the future and PHP is really in

00:54:09,250 --> 00:54:14,410
line in line with a trend in programming

00:54:12,339 --> 00:54:18,490
language design that's called gradual

00:54:14,410 --> 00:54:21,369
typing or optional typing it does not

00:54:18,490 --> 00:54:21,700
require you to write any of these type

00:54:21,369 --> 00:54:23,980
info

00:54:21,700 --> 00:54:26,290
explicitly interviewed code but it

00:54:23,980 --> 00:54:29,349
allows you to do that and if you do it

00:54:26,290 --> 00:54:33,220
then those rules are enforced so you can

00:54:29,349 --> 00:54:39,369
mix and match whatever makes the most

00:54:33,220 --> 00:54:43,480
sense to you and talking about making

00:54:39,369 --> 00:54:45,520
sense I hope that this has made sense to

00:54:43,480 --> 00:54:48,790
you was some sort of useful and not

00:54:45,520 --> 00:54:50,619
boring as far as I could tell only very

00:54:48,790 --> 00:54:52,599
few people left at some point probably

00:54:50,619 --> 00:54:54,970
to get coffee and never found back the

00:54:52,599 --> 00:54:55,990
way back I hope this was useful I hope

00:54:54,970 --> 00:54:57,790
you liked it

00:54:55,990 --> 00:54:59,980
I'll upload the slides as soon as

00:54:57,790 --> 00:55:01,750
possible if we have any questions I

00:54:59,980 --> 00:55:04,150
think we have like 5 minutes or so for

00:55:01,750 --> 00:55:06,790
questions no not really

00:55:04,150 --> 00:55:12,630
so I'm here the rest of the conference

00:55:06,790 --> 00:55:12,630

YouTube URL: https://www.youtube.com/watch?v=v7HEWb4iVsU


