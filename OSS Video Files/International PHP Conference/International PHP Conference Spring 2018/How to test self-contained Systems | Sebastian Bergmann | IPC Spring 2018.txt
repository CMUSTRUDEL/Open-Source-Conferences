Title: How to test self-contained Systems | Sebastian Bergmann | IPC Spring 2018
Publication date: 2019-02-11
Playlist: International PHP Conference Spring 2018
Description: 
	Sebastian Bergmann (thePHP.cc): Congratulations, you successfully replaced your legacy monolith. And not just with a distributed monolith comprised of microservices that depend on each other, but rather with an assembly of self-contained systems that do not share infrastructure. There is just one question left to answer: How do you test an application that consists of self-contained systems? Come to this session and learn the answer!
Captions: 
	00:00:05,899 --> 00:00:11,519
so hi I'm Sebastian I've been doing

00:00:09,389 --> 00:00:14,490
things with PHP and to PHP for a really

00:00:11,519 --> 00:00:16,650
long time now I don't know it how long

00:00:14,490 --> 00:00:19,260
exactly I want to know that like 18

00:00:16,650 --> 00:00:21,689
years ago I started to work on PHP unit

00:00:19,260 --> 00:00:24,210
and gave him my first presentation at a

00:00:21,689 --> 00:00:25,680
conference and for about one or two

00:00:24,210 --> 00:00:30,929
years before that I was already using

00:00:25,680 --> 00:00:32,640
and doing things with PHP and when I'm

00:00:30,929 --> 00:00:35,340
not at the conference or working on open

00:00:32,640 --> 00:00:37,530
source I help customers teams build

00:00:35,340 --> 00:00:39,719
better software using the PHP ecosystem

00:00:37,530 --> 00:00:42,290
everything related to knowledge transfer

00:00:39,719 --> 00:00:44,670
consulting coaching training I do that

00:00:42,290 --> 00:00:46,289
with my company the PHP consulting

00:00:44,670 --> 00:00:48,450
company together with Anna and Stefan

00:00:46,289 --> 00:00:50,730
who are also at this conference that

00:00:48,450 --> 00:00:54,300
that's all the sales pitch you're going

00:00:50,730 --> 00:00:57,120
to get out of me which brings me to this

00:00:54,300 --> 00:00:59,670
rather awkward slide where I share some

00:00:57,120 --> 00:01:01,770
secrets with you secret number one there

00:00:59,670 --> 00:01:05,369
are many things that I at least think

00:01:01,770 --> 00:01:07,830
I'm good at dancing and singing are not

00:01:05,369 --> 00:01:10,220
one of those things so please don't be

00:01:07,830 --> 00:01:13,799
disappointed if I don't sing and dance

00:01:10,220 --> 00:01:16,590
during the next 45 minutes that's in all

00:01:13,799 --> 00:01:18,990
our best interest why am I saying this

00:01:16,590 --> 00:01:20,850
after my presentation this morning there

00:01:18,990 --> 00:01:23,280
was some disappointment voiced on

00:01:20,850 --> 00:01:27,650
Twitter that I did neither do dancing or

00:01:23,280 --> 00:01:27,650
singing on stage sorry

00:01:28,130 --> 00:01:36,689
second secret when use be present as a

00:01:33,509 --> 00:01:38,850
conference like this one you have to

00:01:36,689 --> 00:01:41,790
figure out what you want to talk about

00:01:38,850 --> 00:01:44,340
like depending on the conference six to

00:01:41,790 --> 00:01:47,880
nine months ahead of time and that's

00:01:44,340 --> 00:01:49,950
usually so so now it's it's June so

00:01:47,880 --> 00:01:52,829
right before Christmas Christmas

00:01:49,950 --> 00:01:54,210
preparations hectic time of year I had

00:01:52,829 --> 00:01:56,040
to figure out what I wanted to talk

00:01:54,210 --> 00:01:59,880
about here at this conference this week

00:01:56,040 --> 00:02:01,500
and I had already the idea for the talk

00:01:59,880 --> 00:02:04,469
that I gave this morning but I needed

00:02:01,500 --> 00:02:07,079
another idea so I asked around and

00:02:04,469 --> 00:02:09,840
somebody suggested hey there is this new

00:02:07,079 --> 00:02:12,599
thing that everybody talks about like

00:02:09,840 --> 00:02:13,940
every like nine months ago everybody was

00:02:12,599 --> 00:02:16,010
talking about

00:02:13,940 --> 00:02:17,330
self-contained systems and that you need

00:02:16,010 --> 00:02:22,520
to build them and everything will be

00:02:17,330 --> 00:02:24,440
awesome so vast yawn and IBC in Berlin

00:02:22,520 --> 00:02:25,850
in June you'll talk about testing

00:02:24,440 --> 00:02:27,860
self-contained system I said okay that

00:02:25,850 --> 00:02:30,290
sounds like an interesting idea I wrote

00:02:27,860 --> 00:02:31,960
an abstract and an abstract got accepted

00:02:30,290 --> 00:02:36,740
that's why I'm here today

00:02:31,960 --> 00:02:38,900
along the way I figured out that I'll

00:02:36,740 --> 00:02:40,460
leave that to the end so that took me on

00:02:38,900 --> 00:02:41,900
a really interesting journey at least I

00:02:40,460 --> 00:02:43,580
thought it was interesting and that's

00:02:41,900 --> 00:02:45,560
that's the journey that I'm going to

00:02:43,580 --> 00:02:49,490
share with you today it involves looking

00:02:45,560 --> 00:02:51,440
a little bit into the past how the

00:02:49,490 --> 00:02:53,750
architecture of the applications that we

00:02:51,440 --> 00:02:56,150
developed the develop has evolved over

00:02:53,750 --> 00:03:00,740
time so there's the secret's out of the

00:02:56,150 --> 00:03:02,300
way we can start or yeah we'll talk a

00:03:00,740 --> 00:03:05,060
little bit about testing we talked about

00:03:02,300 --> 00:03:09,620
self-contained system self-contained

00:03:05,060 --> 00:03:13,850
systems yes but what I'm not going to

00:03:09,620 --> 00:03:15,410
talk about is like things like this not

00:03:13,850 --> 00:03:18,230
going to talk about hype driven

00:03:15,410 --> 00:03:20,870
development yeah that's what you usually

00:03:18,230 --> 00:03:22,850
get or what some people get out or take

00:03:20,870 --> 00:03:25,090
away from a conference presentation like

00:03:22,850 --> 00:03:28,060
this one I have heard a new buzzword and

00:03:25,090 --> 00:03:31,250
Monday morning when I'm back at work I

00:03:28,060 --> 00:03:33,920
need to do self-contained systems I

00:03:31,250 --> 00:03:35,720
don't know if I need them I have not

00:03:33,920 --> 00:03:37,940
really understood what they are I mean

00:03:35,720 --> 00:03:40,430
in 45 minutes how how well can you

00:03:37,940 --> 00:03:43,430
really understand a new topic but it's

00:03:40,430 --> 00:03:46,070
cool its new I have to have it please

00:03:43,430 --> 00:03:47,690
don't do that I just want to give you an

00:03:46,070 --> 00:03:49,790
idea that you know what you're talking

00:03:47,690 --> 00:03:51,410
about what others are talking about when

00:03:49,790 --> 00:03:53,480
you hear that term in the conversation

00:03:51,410 --> 00:03:55,070
I'm not going to tell you you have to do

00:03:53,480 --> 00:03:56,870
any of these stuff and I'm going to talk

00:03:55,070 --> 00:03:58,280
about right now on Monday morning

00:03:56,870 --> 00:04:01,880
whatever

00:03:58,280 --> 00:04:03,560
so no hype driven development also no

00:04:01,880 --> 00:04:04,850
reddit driven development which is I

00:04:03,560 --> 00:04:06,530
read something on reddit and the

00:04:04,850 --> 00:04:09,739
thousand people said that is really cool

00:04:06,530 --> 00:04:11,600
we need to do this no conference driven

00:04:09,739 --> 00:04:14,480
development is actually not that bad

00:04:11,600 --> 00:04:16,520
that's how open source or that's how

00:04:14,480 --> 00:04:19,730
work in open source projects gets done

00:04:16,520 --> 00:04:21,979
either because somebody who's working on

00:04:19,730 --> 00:04:24,380
the PHP core or on a component or in the

00:04:21,979 --> 00:04:26,930
PHP ecosystem needs a new topic for

00:04:24,380 --> 00:04:29,540
presentation so he or she

00:04:26,930 --> 00:04:31,940
a new feature for PHP itself for a tool

00:04:29,540 --> 00:04:33,680
like PHP unit or a completely new tool

00:04:31,940 --> 00:04:36,500
but that's conference driven development

00:04:33,680 --> 00:04:38,509
the conference the deadline of the

00:04:36,500 --> 00:04:40,250
conference keeps you motivated to

00:04:38,509 --> 00:04:42,590
implement something new in your spare

00:04:40,250 --> 00:04:43,940
time in the open-source project again

00:04:42,590 --> 00:04:45,380
that's not what we're talking about also

00:04:43,940 --> 00:04:48,139
not stack overflow you've driven

00:04:45,380 --> 00:04:50,509
development that's what I see in some

00:04:48,139 --> 00:04:52,900
parts of the world really frequently

00:04:50,509 --> 00:04:55,850
that people even though I'm on site and

00:04:52,900 --> 00:04:57,440
coaching developers to learn and you to

00:04:55,850 --> 00:04:59,360
like PHP unit for instance instead of

00:04:57,440 --> 00:05:01,220
asking me my file I'm in the room they

00:04:59,360 --> 00:05:03,260
go on Stack Overflow search for

00:05:01,220 --> 00:05:05,479
something to copy/paste into their IDE

00:05:03,260 --> 00:05:07,370
and there are even plug-ins for IDE so

00:05:05,479 --> 00:05:11,690
do this automatically for you don't do

00:05:07,370 --> 00:05:14,330
that this is a rather new trend packages

00:05:11,690 --> 00:05:17,240
driven development packages this awesome

00:05:14,330 --> 00:05:19,580
composer is awesome the problem is it's

00:05:17,240 --> 00:05:21,590
so awesome that it's too easy to

00:05:19,580 --> 00:05:24,139
integrate new dependencies into your

00:05:21,590 --> 00:05:26,180
project so you have a problem you go on

00:05:24,139 --> 00:05:28,580
packages or org to serve you search for

00:05:26,180 --> 00:05:30,500
the problem you find a package composer

00:05:28,580 --> 00:05:32,479
require vendor slash package and you

00:05:30,500 --> 00:05:34,580
have the new dependency in your system

00:05:32,479 --> 00:05:36,349
that you have not evaluated that you do

00:05:34,580 --> 00:05:40,190
not know whether it's still maintained

00:05:36,349 --> 00:05:44,080
or not don't blindly add dependencies

00:05:40,190 --> 00:05:46,760
for your project like that yeah so I

00:05:44,080 --> 00:05:51,729
promised a look back into the past and

00:05:46,760 --> 00:05:57,710
we go as far back into the past as 1969

00:05:51,729 --> 00:05:58,970
1960s last time I used those slides

00:05:57,710 --> 00:06:02,419
there was at least one person in the

00:05:58,970 --> 00:06:03,710
room who didn't know the movie do we

00:06:02,419 --> 00:06:08,440
have someone here who does not know

00:06:03,710 --> 00:06:15,380
which movie this is from 1 2 or 3 ok

00:06:08,440 --> 00:06:20,330
2001 Space Odyssey the monolith so 1968

00:06:15,380 --> 00:06:22,520
how did we build software systems in

00:06:20,330 --> 00:06:25,070
1968 well I didn't build software

00:06:22,520 --> 00:06:28,340
systems back in 1968 that was ten years

00:06:25,070 --> 00:06:31,639
before I was born but what was built

00:06:28,340 --> 00:06:33,320
back then was the state of the art was

00:06:31,639 --> 00:06:36,770
building monolith I mean back in the day

00:06:33,320 --> 00:06:40,580
back in those days you were lucky if you

00:06:36,770 --> 00:06:43,020
had a computer that fit into one room

00:06:40,580 --> 00:06:47,370
usually computer filled multiple rooms

00:06:43,020 --> 00:06:49,440
so it was only natural to have

00:06:47,370 --> 00:06:51,690
applications that were built as one big

00:06:49,440 --> 00:06:52,770
thing and if you wanted to change some

00:06:51,690 --> 00:06:54,540
little thing you had to change

00:06:52,770 --> 00:06:57,120
everything because everything was

00:06:54,540 --> 00:06:59,490
interconnected with each other and

00:06:57,120 --> 00:07:02,270
basically you talk or you talk about a

00:06:59,490 --> 00:07:04,620
monolithic system when there are no

00:07:02,270 --> 00:07:06,150
indistinguishable parts in there

00:07:04,620 --> 00:07:08,310
everything is related to everything and

00:07:06,150 --> 00:07:10,770
you cannot point at one specific area of

00:07:08,310 --> 00:07:13,290
the code or of the application say this

00:07:10,770 --> 00:07:15,990
is the point in the application where we

00:07:13,290 --> 00:07:17,580
deal with checking our business rules

00:07:15,990 --> 00:07:19,980
this is where we talk to the database

00:07:17,580 --> 00:07:21,630
everything does everything that's not

00:07:19,980 --> 00:07:24,570
really what we want we didn't knew

00:07:21,630 --> 00:07:27,720
really any better back then I'm really

00:07:24,570 --> 00:07:29,640
happy that I was born 10 years later but

00:07:27,720 --> 00:07:33,330
it took a while until things got really

00:07:29,640 --> 00:07:34,890
matter so that's the kind of monolith

00:07:33,330 --> 00:07:36,990
that keeps you up at night

00:07:34,890 --> 00:07:40,830
that does not let you go to sleep that

00:07:36,990 --> 00:07:42,870
gives you nightmares and I've had I've

00:07:40,830 --> 00:07:44,850
seen that a lot of her have lots of

00:07:42,870 --> 00:07:46,470
experience with teams that have a

00:07:44,850 --> 00:07:51,450
monolith like that soft piece of

00:07:46,470 --> 00:07:53,100
software that is 5 10 15 20 years old

00:07:51,450 --> 00:07:57,120
and yes there are applications written

00:07:53,100 --> 00:07:58,890
in PHP that are over 20 years old and

00:07:57,120 --> 00:08:02,640
are still used today they started to

00:07:58,890 --> 00:08:05,570
this PHP Fi and are now running on 57

00:08:02,640 --> 00:08:08,790
which is amazing

00:08:05,570 --> 00:08:11,550
but still it's usually one big blob of

00:08:08,790 --> 00:08:13,650
code a big ball of mud a monolith and

00:08:11,550 --> 00:08:15,060
that keeps people up at night they want

00:08:13,650 --> 00:08:19,200
to cut that down into smaller more

00:08:15,060 --> 00:08:21,870
manageable pieces so nothing really

00:08:19,200 --> 00:08:23,340
fancy happened in 1978 only that a

00:08:21,870 --> 00:08:25,670
couple of PHP developers who were

00:08:23,340 --> 00:08:27,950
recently at another conference decided

00:08:25,670 --> 00:08:31,740
1978 was the best year ever because

00:08:27,950 --> 00:08:34,410
reasons all of those people were born in

00:08:31,740 --> 00:08:36,450
that year I wasn't at the conference but

00:08:34,410 --> 00:08:40,890
I still include that slide because

00:08:36,450 --> 00:08:44,520
reasons 1983 another movie comes out so

00:08:40,890 --> 00:08:46,950
wargames comes out for me personally

00:08:44,520 --> 00:08:50,040
that is one of the earliest movies that

00:08:46,950 --> 00:08:51,960
I remember watching like actively

00:08:50,040 --> 00:08:53,060
watching and trying to understand what's

00:08:51,960 --> 00:08:55,670
going on

00:08:53,060 --> 00:08:58,670
which is a I think I don't know it to a

00:08:55,670 --> 00:09:00,380
large degree it motivated me to get into

00:08:58,670 --> 00:09:03,200
this thing called computers which was

00:09:00,380 --> 00:09:06,410
really fancy at the time I didn't have

00:09:03,200 --> 00:09:09,670
one it took like seven more years until

00:09:06,410 --> 00:09:13,160
I got one but that's how I started and

00:09:09,670 --> 00:09:13,490
1990 finally got my computer on that

00:09:13,160 --> 00:09:16,010
machine

00:09:13,490 --> 00:09:18,890
I learned programming in basic Eric's

00:09:16,010 --> 00:09:20,660
see an assembly mostly see an assembly

00:09:18,890 --> 00:09:23,750
but that's besides the point

00:09:20,660 --> 00:09:27,200
around 2000 I was at the University and

00:09:23,750 --> 00:09:35,710
that's when I've for the first time in

00:09:27,200 --> 00:09:37,820
my career witnessed or experienced hype

00:09:35,710 --> 00:09:40,670
suddenly everyone was talking about

00:09:37,820 --> 00:09:42,920
service-oriented architecture like we do

00:09:40,670 --> 00:09:45,050
not want the big monolith we want to cut

00:09:42,920 --> 00:09:50,570
it down into smaller pieces that talk to

00:09:45,050 --> 00:09:55,580
each other using protocols for instance

00:09:50,570 --> 00:09:58,370
using soap at believe it or not at some

00:09:55,580 --> 00:10:00,230
point in time soap was meant to be an

00:09:58,370 --> 00:10:03,560
acronym it was a simple object access

00:10:00,230 --> 00:10:06,350
protocol in the second revision of that

00:10:03,560 --> 00:10:08,180
standard they had this note in previous

00:10:06,350 --> 00:10:10,850
versions of the specification the soap

00:10:08,180 --> 00:10:14,360
name was an acronym this is no longer

00:10:10,850 --> 00:10:17,720
the case and they explicitly do not

00:10:14,360 --> 00:10:20,420
mention what words soap was an acronym

00:10:17,720 --> 00:10:24,560
for because they realize it's not simple

00:10:20,420 --> 00:10:26,750
and it's not very accessible and so we

00:10:24,560 --> 00:10:30,080
hide that and just say okay this is soap

00:10:26,750 --> 00:10:37,460
and everything is awesome if you use

00:10:30,080 --> 00:10:39,410
soap around 2012 microservices people

00:10:37,460 --> 00:10:42,290
realize yeah these soap services the

00:10:39,410 --> 00:10:45,350
protocol is not really nice the services

00:10:42,290 --> 00:10:49,130
are still really really big so we are

00:10:45,350 --> 00:10:50,840
basically have big monolith smaller more

00:10:49,130 --> 00:10:53,810
or less but still monoliths that talk to

00:10:50,840 --> 00:10:55,340
each other we need to cut that down even

00:10:53,810 --> 00:11:01,340
further so we need micro service means

00:10:55,340 --> 00:11:05,060
they may make it smaller so if you ask

00:11:01,340 --> 00:11:06,740
somebody what a micro service is you of

00:11:05,060 --> 00:11:08,990
course like this everything

00:11:06,740 --> 00:11:10,940
else you get different answers but they

00:11:08,990 --> 00:11:14,510
both usually fall into two categories

00:11:10,940 --> 00:11:16,730
and if you if you get an answer like if

00:11:14,510 --> 00:11:18,440
you're looking for the textbook answer

00:11:16,730 --> 00:11:20,990
then you get something like yeah

00:11:18,440 --> 00:11:23,330
micro-service it's really easy it's a

00:11:20,990 --> 00:11:25,820
mapper between an application protocol

00:11:23,330 --> 00:11:32,260
something like rest for instance or soap

00:11:25,820 --> 00:11:34,850
or whatever and the domain model and

00:11:32,260 --> 00:11:37,209
then you have two domain model like your

00:11:34,850 --> 00:11:40,820
business rules your business logic and

00:11:37,209 --> 00:11:43,279
then underneath that you have another

00:11:40,820 --> 00:11:45,350
layer of mappers where you map from the

00:11:43,279 --> 00:11:47,870
domain model to your persistence so it's

00:11:45,350 --> 00:11:52,190
really easy you have these three layers

00:11:47,870 --> 00:11:56,899
the the mapping between the domain model

00:11:52,190 --> 00:11:59,300
and the the rest of the application

00:11:56,899 --> 00:12:00,560
using the application protocol and the

00:11:59,300 --> 00:12:02,470
mapping between your domain model and

00:12:00,560 --> 00:12:05,779
persistence like the database whatever

00:12:02,470 --> 00:12:09,260
of course nobody builds micro services

00:12:05,779 --> 00:12:12,680
like that they they didn't build them in

00:12:09,260 --> 00:12:14,480
the clean radar basically build them the

00:12:12,680 --> 00:12:16,279
same way they would always build a

00:12:14,480 --> 00:12:17,990
software so they turned out still too

00:12:16,279 --> 00:12:19,579
large but now we had a term for it and

00:12:17,990 --> 00:12:22,640
because it the name has Micro in it

00:12:19,579 --> 00:12:27,529
everything is micro so however that's

00:12:22,640 --> 00:12:30,470
not what happens at least most most

00:12:27,529 --> 00:12:33,290
pieces of software that I saw that were

00:12:30,470 --> 00:12:36,020
labeled or supposed to be micro services

00:12:33,290 --> 00:12:39,770
turned out to be a monolithic mapper

00:12:36,020 --> 00:12:42,020
from rest to SQL big complicated pieces

00:12:39,770 --> 00:12:44,899
of code that do not really have any

00:12:42,020 --> 00:12:48,260
business logic in them and that just are

00:12:44,899 --> 00:12:50,690
indistinguishable parts of do I deal

00:12:48,260 --> 00:12:53,600
with rest here or do I deal with SQL

00:12:50,690 --> 00:12:55,010
here and basically rest became the new

00:12:53,600 --> 00:13:00,410
SQL and everything was used

00:12:55,010 --> 00:13:03,770
interchangeably not really nice but wait

00:13:00,410 --> 00:13:09,079
there's more you can do it even worse

00:13:03,770 --> 00:13:11,360
you can build something like this yes

00:13:09,079 --> 00:13:14,149
congratulations you just replaced your

00:13:11,360 --> 00:13:18,290
big monolith that you had before with

00:13:14,149 --> 00:13:20,329
twenty ten a hundred whatever micro

00:13:18,290 --> 00:13:22,639
services and everybody talks to every

00:13:20,329 --> 00:13:25,009
and nobody has an idea what's going on

00:13:22,639 --> 00:13:28,129
where and which protocol is used where

00:13:25,009 --> 00:13:29,929
and what do I need to do when I want to

00:13:28,129 --> 00:13:32,749
deploy a change in one of those micro

00:13:29,929 --> 00:13:36,160
services and how do I test micro service

00:13:32,749 --> 00:13:42,230
a in isolation from micro service B and

00:13:36,160 --> 00:13:44,149
not really nice so you exchanged your

00:13:42,230 --> 00:13:47,420
big monolith with a distributed monolith

00:13:44,149 --> 00:13:49,879
that didn't give you any advantage but

00:13:47,420 --> 00:13:51,529
now you have more disadvantages than you

00:13:49,879 --> 00:13:54,739
had before because now you need to deal

00:13:51,529 --> 00:13:58,839
with asynchronous processing you need to

00:13:54,739 --> 00:14:01,369
do this messaging and so on not fun and

00:13:58,839 --> 00:14:03,470
then you see quotes like this is where

00:14:01,369 --> 00:14:05,119
it's a truth universally acknowledged

00:14:03,470 --> 00:14:07,129
that a techie in possession of any

00:14:05,119 --> 00:14:10,790
production code whatsoever must be in

00:14:07,129 --> 00:14:14,239
want of a container platform because the

00:14:10,790 --> 00:14:16,309
individual services of my distributed

00:14:14,239 --> 00:14:18,019
monolith everything will be better if I

00:14:16,309 --> 00:14:20,600
put each and every one of those in a

00:14:18,019 --> 00:14:25,069
separate docker container because that

00:14:20,600 --> 00:14:26,049
will make the problem go away don't get

00:14:25,069 --> 00:14:30,169
me wrong

00:14:26,049 --> 00:14:32,660
containers are really cool the valuable

00:14:30,169 --> 00:14:35,749
tool that if used right can solve a lot

00:14:32,660 --> 00:14:40,839
of hard problems in an easy convenient

00:14:35,749 --> 00:14:44,419
efficient way I've seen teams take their

00:14:40,839 --> 00:14:47,269
15-year old monolith with a couple of

00:14:44,419 --> 00:14:48,889
million lines of code put that into a

00:14:47,269 --> 00:14:52,699
docker container and call it the micro

00:14:48,889 --> 00:14:55,459
service because the way that they

00:14:52,699 --> 00:14:57,860
understood the domain that they were

00:14:55,459 --> 00:14:59,629
working in is if it's in a docker

00:14:57,860 --> 00:15:02,569
container then it's a micro service by

00:14:59,629 --> 00:15:04,639
definition and those things have nothing

00:15:02,569 --> 00:15:06,079
in common one is an architectural

00:15:04,639 --> 00:15:11,239
pattern and the other is a technology

00:15:06,079 --> 00:15:15,169
tool so yeah so containers will not fix

00:15:11,239 --> 00:15:18,319
your broken culture they will also don't

00:15:15,169 --> 00:15:22,249
fix your distributed monolith so around

00:15:18,319 --> 00:15:24,169
that time when we as a as a larger

00:15:22,249 --> 00:15:26,839
software engineering community people

00:15:24,169 --> 00:15:29,089
who make their lives in building

00:15:26,839 --> 00:15:30,949
software figure out yeah the idea of

00:15:29,089 --> 00:15:33,379
micro services is nice but people are

00:15:30,949 --> 00:15:34,110
misunderstanding that what usually

00:15:33,379 --> 00:15:37,170
happens in

00:15:34,110 --> 00:15:40,380
situation like that is that you refine

00:15:37,170 --> 00:15:42,570
your definition of what that is but it

00:15:40,380 --> 00:15:44,700
doesn't work to use that new definition

00:15:42,570 --> 00:15:47,660
with the existing name you need a new

00:15:44,700 --> 00:15:51,269
name for that and that's where we get to

00:15:47,660 --> 00:15:51,959
2018 and of course I need a movie

00:15:51,269 --> 00:15:53,519
reference

00:15:51,959 --> 00:15:56,160
and that basically references the

00:15:53,519 --> 00:15:59,730
earlier movies so we can skip that the

00:15:56,160 --> 00:16:04,220
new term that came up last year was

00:15:59,730 --> 00:16:07,500
self-contained systems or if you will

00:16:04,220 --> 00:16:10,680
microservices done right or if you will

00:16:07,500 --> 00:16:12,839
software build right but basically any

00:16:10,680 --> 00:16:13,560
of these ideas that has to do with their

00:16:12,839 --> 00:16:15,329
content system

00:16:13,560 --> 00:16:17,850
none of them are new most of them have

00:16:15,329 --> 00:16:20,880
been around for decades it's just that

00:16:17,850 --> 00:16:23,370
now finally people want to do want to

00:16:20,880 --> 00:16:25,740
build software like that again and it

00:16:23,370 --> 00:16:29,160
needs a new name because it has to be a

00:16:25,740 --> 00:16:31,010
new thing so what's the most important

00:16:29,160 --> 00:16:33,480
thing about the self-contained system

00:16:31,010 --> 00:16:36,269
each self-contained system is an

00:16:33,480 --> 00:16:41,750
autonomous web application each thing

00:16:36,269 --> 00:16:46,170
can do its job without having to rely on

00:16:41,750 --> 00:16:49,490
another of these things so you do not

00:16:46,170 --> 00:16:52,800
end up with the distributed monolith

00:16:49,490 --> 00:16:58,260
this means that you need to cut down

00:16:52,800 --> 00:17:02,000
your problem into small pieces and that

00:16:58,260 --> 00:17:05,189
a small piece can be implemented in one

00:17:02,000 --> 00:17:07,319
piece of software that is accessible as

00:17:05,189 --> 00:17:11,370
an autonomous web application as a

00:17:07,319 --> 00:17:12,839
self-contained system and yes it's hard

00:17:11,370 --> 00:17:14,819
that requires thinking that will require

00:17:12,839 --> 00:17:19,010
thinking up front about architecture

00:17:14,819 --> 00:17:19,010
that the thinking is not going away

00:17:19,040 --> 00:17:24,000
which i think is a good thing a

00:17:21,990 --> 00:17:26,100
self-contained system should not share

00:17:24,000 --> 00:17:28,799
business code with other self-contained

00:17:26,100 --> 00:17:31,140
systems because that would just be a

00:17:28,799 --> 00:17:34,020
different manifestation of a dependency

00:17:31,140 --> 00:17:35,910
on a different system yeah everything is

00:17:34,020 --> 00:17:38,640
better because service a no longer

00:17:35,910 --> 00:17:41,010
speaks by a protocol like rest to

00:17:38,640 --> 00:17:43,830
service B but they both use the same

00:17:41,010 --> 00:17:46,710
code yeah that doesn't really solve the

00:17:43,830 --> 00:17:47,970
problem that may solve the runtime

00:17:46,710 --> 00:17:49,789
problem but that doesn't solve

00:17:47,970 --> 00:17:53,010
problems with regard to scaling

00:17:49,789 --> 00:17:55,110
development teams if team a works on

00:17:53,010 --> 00:17:57,539
service a and Team B works on service B

00:17:55,110 --> 00:18:02,450
and they need to collaborate on shared

00:17:57,539 --> 00:18:02,450
code that doesn't give any benefits in

00:18:02,480 --> 00:18:06,799
improving velocity of the team

00:18:07,220 --> 00:18:11,130
infrastructure such as database for

00:18:09,419 --> 00:18:15,960
instance should not be shared between

00:18:11,130 --> 00:18:18,450
self-contained systems in the 80s and

00:18:15,960 --> 00:18:21,090
90s it was very very popular to have an

00:18:18,450 --> 00:18:24,870
architecture to build software using an

00:18:21,090 --> 00:18:28,320
architecture where at the core was v1

00:18:24,870 --> 00:18:32,240
integration data base parts of the

00:18:28,320 --> 00:18:35,370
application did not use api's or

00:18:32,240 --> 00:18:38,190
protocols or services or whatever to

00:18:35,370 --> 00:18:41,640
talk to each other they used the

00:18:38,190 --> 00:18:53,190
database to talk to each other the first

00:18:41,640 --> 00:18:55,470
time that I looked at a web service as a

00:18:53,190 --> 00:19:01,169
consultant that was I don't know when

00:18:55,470 --> 00:19:04,470
when was that to sow 2000-2001 I went to

00:19:01,169 --> 00:19:06,289
my first customer and the way that they

00:19:04,470 --> 00:19:09,809
haven't implemented Web Services was

00:19:06,289 --> 00:19:12,830
there in my SQL database and that MySQL

00:19:09,809 --> 00:19:16,350
database was a table with PHP code in it

00:19:12,830 --> 00:19:19,530
and your some people are already

00:19:16,350 --> 00:19:22,380
laughing and smiling and yes calling a

00:19:19,530 --> 00:19:25,140
web service meant fetch the PHP code

00:19:22,380 --> 00:19:31,230
from the MySQL database and then eval it

00:19:25,140 --> 00:19:32,940
I don't so they had a really good

00:19:31,230 --> 00:19:36,120
explanation why they thought that this

00:19:32,940 --> 00:19:38,070
was a web service in the end at the end

00:19:36,120 --> 00:19:39,929
of the day I figured out that they did

00:19:38,070 --> 00:19:42,390
this because they did not know that

00:19:39,929 --> 00:19:44,280
things like version control existed so

00:19:42,390 --> 00:19:46,080
they used the database to distribute the

00:19:44,280 --> 00:19:47,490
code to all the servers or make the code

00:19:46,080 --> 00:19:53,010
available on all the service that they

00:19:47,490 --> 00:19:55,740
had this is not a web service and don't

00:19:53,010 --> 00:19:57,240
use the database to share information

00:19:55,740 --> 00:19:59,520
between different parts of the system

00:19:57,240 --> 00:20:01,630
always have well-defined API so you know

00:19:59,520 --> 00:20:04,660
who's talking to who and who you

00:20:01,630 --> 00:20:07,270
is what otherwise you are lost when you

00:20:04,660 --> 00:20:09,340
try to figure out what codes you can

00:20:07,270 --> 00:20:15,040
throw away when a feature is no longer

00:20:09,340 --> 00:20:23,320
needed so how do you test such a

00:20:15,040 --> 00:20:25,630
self-contained system then well I'll

00:20:23,320 --> 00:20:28,900
give you an example can somebody guess

00:20:25,630 --> 00:20:32,100
what the example is going to be depends

00:20:28,900 --> 00:20:32,100
on whether or not you know the movie

00:20:33,270 --> 00:20:42,640
there's a game missing tic-tac-toe is

00:20:37,960 --> 00:20:46,600
missing so let's play tic-tac-toe so

00:20:42,640 --> 00:20:51,360
let's say we have a service that we can

00:20:46,600 --> 00:20:54,520
contact Maya HTTP to play tic-tac-toe

00:20:51,360 --> 00:20:56,380
this is a tool by the way that I did not

00:20:54,520 --> 00:20:57,940
mention in my tools talk this morning

00:20:56,380 --> 00:21:01,120
because it's not really related to PHP

00:20:57,940 --> 00:21:04,030
but it's something that I started using

00:21:01,120 --> 00:21:06,220
a while ago whenever I need to interact

00:21:04,030 --> 00:21:08,050
for testing purposes or demo purposes

00:21:06,220 --> 00:21:12,660
with the web service it's a tool called

00:21:08,050 --> 00:21:15,370
HTTP HTTP like HTTP and PI like a cake

00:21:12,660 --> 00:21:17,410
and it gives you a command line tool

00:21:15,370 --> 00:21:19,150
named HTTP that allows you to make

00:21:17,410 --> 00:21:23,110
requests it's basically a wrapper around

00:21:19,150 --> 00:21:26,560
curl more convenient to use when you are

00:21:23,110 --> 00:21:27,760
working with and on web services so what

00:21:26,560 --> 00:21:30,520
we are doing here is we make a get

00:21:27,760 --> 00:21:38,200
request to that URL and this is what we

00:21:30,520 --> 00:21:39,940
get so we get some JSON back there's an

00:21:38,200 --> 00:21:41,980
error representation to this our board

00:21:39,940 --> 00:21:45,460
everything is empty because if you have

00:21:41,980 --> 00:21:47,740
a new game then we can make a post

00:21:45,460 --> 00:21:51,370
request and say okay we occupy space

00:21:47,740 --> 00:21:54,360
number five if you didn't know if we

00:21:51,370 --> 00:21:57,460
ever want to implement tic-tac-toe and

00:21:54,360 --> 00:22:03,100
really only tic-tac-toe not a generic

00:21:57,460 --> 00:22:07,150
and MK game then the best representation

00:22:03,100 --> 00:22:10,210
for the board is an array of nine

00:22:07,150 --> 00:22:12,430
elements one two three four five six

00:22:10,210 --> 00:22:15,970
seven eight nine makes it later on

00:22:12,430 --> 00:22:21,639
really easy to detect the winning move

00:22:15,970 --> 00:22:25,809
but that's outside the scope so we

00:22:21,639 --> 00:22:29,470
basically say via this put a post

00:22:25,809 --> 00:22:31,149
request I want to put my piece or the

00:22:29,470 --> 00:22:35,700
current player wants to put his or her

00:22:31,149 --> 00:22:38,620
piece into the center of the grid and

00:22:35,700 --> 00:22:41,499
when I make a get request again then I

00:22:38,620 --> 00:22:47,039
get a new state now I have an X in the

00:22:41,499 --> 00:22:48,700
middle what I just did was a manual test

00:22:47,039 --> 00:22:50,980
that's okay

00:22:48,700 --> 00:22:54,490
for situation like that I'm just working

00:22:50,980 --> 00:22:56,499
on that trying to get some experience

00:22:54,490 --> 00:22:57,999
with that web service trying to figure

00:22:56,499 --> 00:23:02,259
out whether it works the way that it was

00:22:57,999 --> 00:23:04,179
documented but I did manual work I don't

00:23:02,259 --> 00:23:05,559
know about you I do not like manual work

00:23:04,179 --> 00:23:06,759
at least when it comes to software

00:23:05,559 --> 00:23:09,940
development everything that can be

00:23:06,759 --> 00:23:13,600
automated should be automated so it's

00:23:09,940 --> 00:23:19,899
manual it's also end to end end to end

00:23:13,600 --> 00:23:25,149
is a technical look at what the test

00:23:19,899 --> 00:23:27,850
does meaning we use a real HTTP client

00:23:25,149 --> 00:23:29,700
send to send a real HTTP request to a

00:23:27,850 --> 00:23:32,320
real HTTP server

00:23:29,700 --> 00:23:38,529
triggering a real HTTP response that we

00:23:32,320 --> 00:23:40,539
evaluate using the client end-to-end

00:23:38,529 --> 00:23:45,850
test has the advantage that it always

00:23:40,539 --> 00:23:50,919
works the application I'm testing can be

00:23:45,850 --> 00:23:54,249
as badly implemented as pasa as you can

00:23:50,919 --> 00:23:56,710
imagine I can always use it I can always

00:23:54,249 --> 00:23:59,080
communicate with it end to end to test

00:23:56,710 --> 00:24:00,970
it that always works otherwise a real

00:23:59,080 --> 00:24:02,559
user using a real browser could not

00:24:00,970 --> 00:24:04,049
interact with it that would be really

00:24:02,559 --> 00:24:07,629
bad

00:24:04,049 --> 00:24:09,279
the disadvantage of end-to-end is that

00:24:07,629 --> 00:24:11,649
it's not really fine-grained

00:24:09,279 --> 00:24:13,830
it's really useful information when to

00:24:11,649 --> 00:24:16,299
end test fails that some specific

00:24:13,830 --> 00:24:19,210
high-level thing currently does not work

00:24:16,299 --> 00:24:21,580
but since everything is actually all the

00:24:19,210 --> 00:24:23,350
code is potentially executed and there's

00:24:21,580 --> 00:24:25,690
communication with external systems

00:24:23,350 --> 00:24:27,399
probably involved when a test fails you

00:24:25,690 --> 00:24:28,470
do not know where your root cause when

00:24:27,399 --> 00:24:30,510
it is and you have to

00:24:28,470 --> 00:24:34,039
attention look at a lot of things to

00:24:30,510 --> 00:24:36,870
figure out the reason and to fix it then

00:24:34,039 --> 00:24:38,960
it's also a system test because we look

00:24:36,870 --> 00:24:44,510
at the system as a whole

00:24:38,960 --> 00:24:47,970
it's an acceptance test meaning that I

00:24:44,510 --> 00:24:50,549
have I'm looking at acceptance criteria

00:24:47,970 --> 00:24:52,559
maybe I have some in some documentation

00:24:50,549 --> 00:24:54,450
when I make a get request I get to see

00:24:52,559 --> 00:24:56,159
the current state of the board and when

00:24:54,450 --> 00:24:58,799
I make a post request like that then

00:24:56,159 --> 00:25:02,159
that space is occupied whatever this is

00:24:58,799 --> 00:25:07,710
an acceptance test like an outside

00:25:02,159 --> 00:25:11,490
perspective on the system it's a

00:25:07,710 --> 00:25:15,059
functional test and that word under

00:25:11,490 --> 00:25:20,100
unfortunately has at least two meanings

00:25:15,059 --> 00:25:22,140
well if you ask someone like me it only

00:25:20,100 --> 00:25:25,049
has one meaning and everybody else is

00:25:22,140 --> 00:25:28,020
wrong but that's I know that's rather

00:25:25,049 --> 00:25:30,179
harsh but in computer science for a

00:25:28,020 --> 00:25:34,230
really long time like 4050 years

00:25:30,179 --> 00:25:36,809
functional test means any dynamic tests

00:25:34,230 --> 00:25:38,700
that verifies functional correctness of

00:25:36,809 --> 00:25:41,429
a part of a software or of a software

00:25:38,700 --> 00:25:42,630
system as a whole dynamic testing

00:25:41,429 --> 00:25:46,020
meaning we are testing the software

00:25:42,630 --> 00:25:48,690
while executing the code I have no idea

00:25:46,020 --> 00:25:51,260
how that happened but when testing

00:25:48,690 --> 00:25:54,510
software testing came to web development

00:25:51,260 --> 00:25:57,600
somebody used the name functional test

00:25:54,510 --> 00:26:01,020
for acceptance tests so for instance if

00:25:57,600 --> 00:26:03,419
you read the documentation for symphony

00:26:01,020 --> 00:26:05,159
they talked about functional tests and

00:26:03,419 --> 00:26:08,640
how functional tests are supported by

00:26:05,159 --> 00:26:12,240
their extension to PHP unit what they

00:26:08,640 --> 00:26:14,970
basically do is end-to-end or edge to

00:26:12,240 --> 00:26:18,390
edge testing using PHP unit for

00:26:14,970 --> 00:26:21,380
acceptance testing but they call it

00:26:18,390 --> 00:26:23,580
functional test which is correct but

00:26:21,380 --> 00:26:25,350
only to the degree that you're testing

00:26:23,580 --> 00:26:27,090
functional correctness but also a unit

00:26:25,350 --> 00:26:29,070
test is a functional test because also a

00:26:27,090 --> 00:26:34,169
unit test tests functional correctness

00:26:29,070 --> 00:26:35,970
but of a small part anyway it's a

00:26:34,169 --> 00:26:39,780
dynamic test because we're executing the

00:26:35,970 --> 00:26:43,299
code but we can do that in an automated

00:26:39,780 --> 00:26:45,580
way using PHP unit for instance

00:26:43,299 --> 00:26:48,039
writing a tic-tac-toe test class that

00:26:45,580 --> 00:26:51,240
extends between Inferno test case write

00:26:48,039 --> 00:26:57,480
a method test grid is originally empty

00:26:51,240 --> 00:27:00,610
doing an HTTP request to our endpoint

00:26:57,480 --> 00:27:02,529
put that resolves the string into JSON

00:27:00,610 --> 00:27:08,139
decode and assert using assert equals

00:27:02,529 --> 00:27:12,070
that we get some weird noises from the

00:27:08,139 --> 00:27:17,139
microphone or not and that the grid is

00:27:12,070 --> 00:27:19,179
empty now we have an automated test but

00:27:17,139 --> 00:27:21,639
the only thing we have changed is that

00:27:19,179 --> 00:27:23,110
is no longer manual and now automated so

00:27:21,639 --> 00:27:24,999
it's still an end-to-end test we're

00:27:23,110 --> 00:27:28,119
still testing the whole thing from

00:27:24,999 --> 00:27:30,669
request to request still a system test

00:27:28,119 --> 00:27:32,110
because we look at the system certain

00:27:30,669 --> 00:27:34,029
acceptance tests because we test an

00:27:32,110 --> 00:27:35,950
acceptance criteria it's still a

00:27:34,029 --> 00:27:38,049
functional test because we still test

00:27:35,950 --> 00:27:39,789
functional correctness it's still a

00:27:38,049 --> 00:27:43,779
dynamic test because we still execute

00:27:39,789 --> 00:27:48,929
the code and if we execute the test this

00:27:43,779 --> 00:27:51,809
is what it looks like rather boring

00:27:48,929 --> 00:27:54,220
which for unit some version information

00:27:51,809 --> 00:27:55,600
1.2 indicate progress while the tests

00:27:54,220 --> 00:27:57,940
are being executed dot meaning

00:27:55,600 --> 00:28:00,100
successful test some statistics in the

00:27:57,940 --> 00:28:04,509
end one test was executed everything was

00:28:00,100 --> 00:28:09,240
fine one of the most important questions

00:28:04,509 --> 00:28:09,240
when you're doing software testing is

00:28:09,869 --> 00:28:18,070
figure out what the smallest scope is in

00:28:13,960 --> 00:28:20,559
which you can perform the test what is

00:28:18,070 --> 00:28:22,629
the least amount of code that you need

00:28:20,559 --> 00:28:23,440
to execute to test what you're

00:28:22,629 --> 00:28:26,860
interested in

00:28:23,440 --> 00:28:29,230
the less cat code you execute during a

00:28:26,860 --> 00:28:33,519
test the more precise the information

00:28:29,230 --> 00:28:35,799
will be when the test fails when you

00:28:33,519 --> 00:28:37,929
have a unit test and your tests in that

00:28:35,799 --> 00:28:39,999
unit test a method and that method has

00:28:37,929 --> 00:28:42,399
five ten fifteen lines of code and the

00:28:39,999 --> 00:28:43,840
test fails the reason for that test

00:28:42,399 --> 00:28:46,139
failure can only mean that for those

00:28:43,840 --> 00:28:48,279
five ten fifteen lines of code and

00:28:46,139 --> 00:28:50,499
usually within a couple of seconds you

00:28:48,279 --> 00:28:53,320
spot the mistake and can fix it and can

00:28:50,499 --> 00:28:55,330
move on when you have a system level

00:28:53,320 --> 00:28:56,500
test an end-to-end test and execute

00:28:55,330 --> 00:28:59,480
everything

00:28:56,500 --> 00:29:01,160
the information that a certain feature

00:28:59,480 --> 00:29:03,710
on an aspect of a certain feature

00:29:01,160 --> 00:29:06,350
currently does not work it's valuable

00:29:03,710 --> 00:29:09,770
and important but it does not tell you

00:29:06,350 --> 00:29:11,360
where you should start looking for the

00:29:09,770 --> 00:29:12,580
root cause because potentially it can be

00:29:11,360 --> 00:29:15,620
anywhere

00:29:12,580 --> 00:29:18,110
hopefully you have both the small unit

00:29:15,620 --> 00:29:20,390
tests and the large or the larger

00:29:18,110 --> 00:29:22,430
integration end-to-end tests so yeah I

00:29:20,390 --> 00:29:24,770
never have a situation like the big test

00:29:22,430 --> 00:29:27,620
fails and no small test fails it helps

00:29:24,770 --> 00:29:32,480
you pinpoint the location but can we

00:29:27,620 --> 00:29:34,490
test this in a smaller scope can we test

00:29:32,480 --> 00:29:39,050
this while executing less code and yes

00:29:34,490 --> 00:29:43,370
we can do that we need or as a first

00:29:39,050 --> 00:29:46,280
step we need to get rid of the HTTP

00:29:43,370 --> 00:29:48,290
communication we need to get rid of the

00:29:46,280 --> 00:29:50,960
need to have a real HTTP client and a

00:29:48,290 --> 00:29:53,000
real HTTP server so we do something like

00:29:50,960 --> 00:29:56,720
this we instantiate our application

00:29:53,000 --> 00:29:59,930
object inside our test we fake a get

00:29:56,720 --> 00:30:04,430
request and let the application run this

00:29:59,930 --> 00:30:07,910
that faked get request and then look at

00:30:04,430 --> 00:30:09,530
the response and have the same assertion

00:30:07,910 --> 00:30:12,320
that we had before on the response

00:30:09,530 --> 00:30:15,650
object instead or unresponsive string

00:30:12,320 --> 00:30:18,230
rather instead of having HTTP client

00:30:15,650 --> 00:30:21,530
make an HTTP request response the full

00:30:18,230 --> 00:30:23,540
circle and then look at that that is a

00:30:21,530 --> 00:30:25,610
lot faster to execute because we don't

00:30:23,540 --> 00:30:29,270
have the network latency even if you run

00:30:25,610 --> 00:30:31,760
it locally and take some time runs in

00:30:29,270 --> 00:30:33,740
the same PHP process unless code is

00:30:31,760 --> 00:30:37,880
executed the web server is not involved

00:30:33,740 --> 00:30:39,830
a lot less moving parts makes it easier

00:30:37,880 --> 00:30:43,520
to figure out what's going on when

00:30:39,830 --> 00:30:45,770
something fails that is what is called

00:30:43,520 --> 00:30:50,300
an edge to edge test it's the next

00:30:45,770 --> 00:30:54,110
smaller thing smaller than an end-to-end

00:30:50,300 --> 00:30:56,300
test since we are testing at the edges

00:30:54,110 --> 00:30:58,040
where the real HTTP request would start

00:30:56,300 --> 00:31:02,030
and where the real HTTP response would

00:30:58,040 --> 00:31:05,020
be sent out so an acceptance test still

00:31:02,030 --> 00:31:09,680
a functional test still a dynamic test

00:31:05,020 --> 00:31:11,380
and again can we test this in a smaller

00:31:09,680 --> 00:31:16,010
scale

00:31:11,380 --> 00:31:19,910
which brings us to actually specifying

00:31:16,010 --> 00:31:24,740
what we expect from our tic-tac-toe game

00:31:19,910 --> 00:31:26,480
for instance so maybe we should have

00:31:24,740 --> 00:31:29,440
started with that maybe we should have

00:31:26,480 --> 00:31:32,990
started by gathering requirements

00:31:29,440 --> 00:31:37,400
business rules two main logic rules of

00:31:32,990 --> 00:31:41,750
our game and describe okay game starting

00:31:37,400 --> 00:31:43,310
players always X and the current player

00:31:41,750 --> 00:31:46,760
whatever the cat is the current player

00:31:43,310 --> 00:31:48,950
can occupy an empty space and that of

00:31:46,760 --> 00:31:51,770
course implies that when the current

00:31:48,950 --> 00:31:54,200
player tries to occupy a space that is

00:31:51,770 --> 00:31:55,940
already occupied that we get an error

00:31:54,200 --> 00:31:59,750
message and not that it's overwritten or

00:31:55,940 --> 00:32:02,780
something like that when the current

00:31:59,750 --> 00:32:03,200
player has met him made a move the next

00:32:02,780 --> 00:32:06,350
player

00:32:03,200 --> 00:32:09,620
the second player becomes the current

00:32:06,350 --> 00:32:12,290
player the game hopefully can detect the

00:32:09,620 --> 00:32:14,270
winning move when the game is over may

00:32:12,290 --> 00:32:17,540
hopefully it can also detect when they

00:32:14,270 --> 00:32:19,160
cannot be a winner which is the more

00:32:17,540 --> 00:32:22,370
common case when you play tic-tac-toe

00:32:19,160 --> 00:32:28,160
and we can list all of these rules and

00:32:22,370 --> 00:32:32,720
implement these rules in code we have

00:32:28,160 --> 00:32:34,640
for instance with a unit test test

00:32:32,720 --> 00:32:37,250
starting players X recreate a new game

00:32:34,640 --> 00:32:40,010
object we retrieve the current player

00:32:37,250 --> 00:32:45,340
and we assert that the current player

00:32:40,010 --> 00:32:49,190
for a fresh game is X and we can go on

00:32:45,340 --> 00:32:51,850
that is a unit test that is a test that

00:32:49,190 --> 00:32:54,440
tests only a couple of lines of code in

00:32:51,850 --> 00:32:57,860
isolation from all of the dependencies

00:32:54,440 --> 00:33:00,290
and when that test fails we know exactly

00:32:57,860 --> 00:33:02,870
where to look for the root cause you

00:33:00,290 --> 00:33:09,980
know exactly where to look and fix the

00:33:02,870 --> 00:33:12,770
problem if you follow this with the best

00:33:09,980 --> 00:33:16,580
practice of giving your tests meaningful

00:33:12,770 --> 00:33:19,700
names and test1 test2 test3 are not

00:33:16,580 --> 00:33:21,500
meaningful names naming things is still

00:33:19,700 --> 00:33:23,180
one of the hardest problems in in

00:33:21,500 --> 00:33:25,400
software engineering

00:33:23,180 --> 00:33:29,270
need to think of you need to invest some

00:33:25,400 --> 00:33:31,580
time in good names so that tomorrow next

00:33:29,270 --> 00:33:33,640
week a year from now you still

00:33:31,580 --> 00:33:36,850
understand what the code is about and

00:33:33,640 --> 00:33:40,160
actually these tests can help this that

00:33:36,850 --> 00:33:45,380
if you have the test for something like

00:33:40,160 --> 00:33:49,460
this game you can write down in the form

00:33:45,380 --> 00:33:52,730
of small precise sentences and describe

00:33:49,460 --> 00:33:57,560
each aspect that you test with such a

00:33:52,730 --> 00:33:59,060
test and then use these conventions like

00:33:57,560 --> 00:34:03,320
if you have a test method that is named

00:33:59,060 --> 00:34:06,110
test starting player is X display x HP

00:34:03,320 --> 00:34:08,270
unit with this - - test Docs option can

00:34:06,110 --> 00:34:10,580
discard two tests prefix of the method

00:34:08,270 --> 00:34:12,620
name and insert a space whenever there

00:34:10,580 --> 00:34:15,110
is a change in law in lowercase and

00:34:12,620 --> 00:34:18,560
uppercase in the camelcase notation also

00:34:15,110 --> 00:34:21,350
works with snake case you get that

00:34:18,560 --> 00:34:24,920
output and that output is really

00:34:21,350 --> 00:34:27,590
valuable you can take an output go to

00:34:24,920 --> 00:34:29,870
somebody on the project who is not a

00:34:27,590 --> 00:34:33,170
technical person not a developer and say

00:34:29,870 --> 00:34:35,570
hey this is how I understood your

00:34:33,170 --> 00:34:37,370
requirements and this by the way is how

00:34:35,570 --> 00:34:39,800
the code how the application currently

00:34:37,370 --> 00:34:43,610
works this is automatically verified

00:34:39,800 --> 00:34:46,310
through tests did I understand what you

00:34:43,610 --> 00:34:48,080
meant correctly and you do not have to

00:34:46,310 --> 00:34:50,750
look at code you can look at this output

00:34:48,080 --> 00:34:52,850
that's variable for that it's also very

00:34:50,750 --> 00:34:54,410
valuable when a new developer comes onto

00:34:52,850 --> 00:34:57,590
the team needs to work for the very

00:34:54,410 --> 00:35:00,020
first time with this game object he or

00:34:57,590 --> 00:35:03,740
she just runs the tests for that game

00:35:00,020 --> 00:35:06,890
object looks at this output knows the

00:35:03,740 --> 00:35:09,380
responsibilities and the environment of

00:35:06,890 --> 00:35:12,760
that sees how that behaves in certain

00:35:09,380 --> 00:35:14,630
conditions and when there is something

00:35:12,760 --> 00:35:17,270
specific that they are interested in

00:35:14,630 --> 00:35:18,080
maybe ok can detect winning move how do

00:35:17,270 --> 00:35:21,290
I do that

00:35:18,080 --> 00:35:26,420
you just look at it code behind that

00:35:21,290 --> 00:35:29,390
test and see an executable example for

00:35:26,420 --> 00:35:31,460
how to use how to reuse how to interact

00:35:29,390 --> 00:35:34,820
with that piece of code that is tested

00:35:31,460 --> 00:35:36,340
there and that's really powerful you can

00:35:34,820 --> 00:35:39,070
think of these tests

00:35:36,340 --> 00:35:42,340
not only as executable documentation but

00:35:39,070 --> 00:35:48,280
also as executable specification so

00:35:42,340 --> 00:35:50,770
that's the unit test whole idea of these

00:35:48,280 --> 00:35:54,910
automated tests in general and the unit

00:35:50,770 --> 00:35:58,300
tests in particular was verifications

00:35:54,910 --> 00:36:01,390
for execution I execute a piece of code

00:35:58,300 --> 00:36:03,700
for instance a method and verify that

00:36:01,390 --> 00:36:04,270
the thing that I expected to happen has

00:36:03,700 --> 00:36:06,760
happened

00:36:04,270 --> 00:36:08,410
usually there are more commonly there

00:36:06,760 --> 00:36:11,890
are three things that you test about the

00:36:08,410 --> 00:36:14,800
method you can test the return value you

00:36:11,890 --> 00:36:16,390
can test that an exception is raised

00:36:14,800 --> 00:36:19,830
when an exception should be raised in

00:36:16,390 --> 00:36:22,360
error conditions and the third thing and

00:36:19,830 --> 00:36:25,090
sometimes the heart sometimes really

00:36:22,360 --> 00:36:27,940
hard side effects and that side effect

00:36:25,090 --> 00:36:30,910
can be that the method called on one

00:36:27,940 --> 00:36:32,800
object leads leads to a method call and

00:36:30,910 --> 00:36:35,680
another object that's where mock objects

00:36:32,800 --> 00:36:38,410
and smiles come into play side effect

00:36:35,680 --> 00:36:41,020
could be that a statement is sent to the

00:36:38,410 --> 00:36:43,060
database that needs to be interject

00:36:41,020 --> 00:36:47,650
intercepted and then evaluated to see

00:36:43,060 --> 00:36:49,420
whether or not that happens or you test

00:36:47,650 --> 00:36:51,190
it end to end at least in that part and

00:36:49,420 --> 00:36:53,320
look into the database afterwards and

00:36:51,190 --> 00:36:55,030
see whether or not the expected change

00:36:53,320 --> 00:36:58,510
happened in the database that's

00:36:55,030 --> 00:37:01,320
verifications for execution and as I

00:36:58,510 --> 00:37:03,490
mentioned earlier this is also

00:37:01,320 --> 00:37:06,280
executable documentation but this is a

00:37:03,490 --> 00:37:07,420
realization that came much later this is

00:37:06,280 --> 00:37:11,130
something that happened I don't know

00:37:07,420 --> 00:37:13,180
around ten years ago that we realized

00:37:11,130 --> 00:37:16,870
verification through execution is nice

00:37:13,180 --> 00:37:19,840
but this is also documentation and oh if

00:37:16,870 --> 00:37:22,200
I do test-driven development and write

00:37:19,840 --> 00:37:24,040
my tests first its actual actually

00:37:22,200 --> 00:37:27,730
executable specification

00:37:24,040 --> 00:37:30,490
step by step I cut down the problem I'm

00:37:27,730 --> 00:37:33,040
tasked to solve into smaller manageable

00:37:30,490 --> 00:37:36,910
pieces in a document every step that I

00:37:33,040 --> 00:37:39,640
take in solving this problem in such a

00:37:36,910 --> 00:37:41,800
small test that along the way also

00:37:39,640 --> 00:37:44,170
documents how this thing that I'm

00:37:41,800 --> 00:37:46,000
currently working on actually works and

00:37:44,170 --> 00:37:48,180
it's supposed to be used this is really

00:37:46,000 --> 00:37:48,180
valuable

00:37:48,600 --> 00:37:52,900
and the primary task of a developer is

00:37:51,190 --> 00:37:54,850
not the writing of code but to

00:37:52,900 --> 00:37:56,830
understand the problem the writing of

00:37:54,850 --> 00:37:59,220
tests helps to understand the problem

00:37:56,830 --> 00:38:01,570
step by step what I just mentioned and a

00:37:59,220 --> 00:38:04,150
common misunderstanding of test-driven

00:38:01,570 --> 00:38:06,820
development is that the test drive the

00:38:04,150 --> 00:38:11,050
development as an end in itself no the

00:38:06,820 --> 00:38:13,240
tests trigger the required thinking to

00:38:11,050 --> 00:38:22,030
solve the problem and go to the next

00:38:13,240 --> 00:38:23,980
step so is this the end of the world as

00:38:22,030 --> 00:38:28,720
we know it and everybody fires the nukes

00:38:23,980 --> 00:38:31,900
and everything is over hopefully not but

00:38:28,720 --> 00:38:33,070
I think we there are some some lessons

00:38:31,900 --> 00:38:36,670
to be learned or some things to think

00:38:33,070 --> 00:38:38,320
about the there it was again the

00:38:36,670 --> 00:38:41,280
thinking I promise that it's not going

00:38:38,320 --> 00:38:43,600
away so software design is recursive

00:38:41,280 --> 00:38:46,990
there are many things that you probably

00:38:43,600 --> 00:38:49,390
already know about at a smaller level on

00:38:46,990 --> 00:38:52,770
the object level for instance things

00:38:49,390 --> 00:38:56,920
like cqs command query separation

00:38:52,770 --> 00:39:02,050
getters and setters or mutaters and

00:38:56,920 --> 00:39:05,130
query methods you do not mix if you

00:39:02,050 --> 00:39:09,390
write clean code then you do not mix

00:39:05,130 --> 00:39:13,870
reading and writing in the same method

00:39:09,390 --> 00:39:16,750
you do not violate the principle of

00:39:13,870 --> 00:39:18,880
least astonishment yeah you have a

00:39:16,750 --> 00:39:21,670
method that method has a name and that

00:39:18,880 --> 00:39:26,860
method name describes what the method

00:39:21,670 --> 00:39:29,620
does if I have a method get X then I

00:39:26,860 --> 00:39:34,420
expect that method to do nothing but

00:39:29,620 --> 00:39:37,630
return whatever X is supposed to be I've

00:39:34,420 --> 00:39:40,510
seen plenty of times where if you look

00:39:37,630 --> 00:39:44,230
at version control initially a method

00:39:40,510 --> 00:39:48,870
like get X started as a single line

00:39:44,230 --> 00:39:53,860
return this X 10 years later

00:39:48,870 --> 00:39:55,960
it reads Y changes X talks to the

00:39:53,860 --> 00:39:57,820
database calls the web service does

00:39:55,960 --> 00:40:00,580
something completely different and then

00:39:57,820 --> 00:40:01,990
returns X that's a violation of the

00:40:00,580 --> 00:40:05,080
principle of least astonishment

00:40:01,990 --> 00:40:07,119
as a user of that method that does not

00:40:05,080 --> 00:40:09,670
look into the body of that method when I

00:40:07,119 --> 00:40:12,390
want to use that I'm pretty much

00:40:09,670 --> 00:40:15,250
astonished when I figure out by

00:40:12,390 --> 00:40:17,950
searching for the root cause of a bug

00:40:15,250 --> 00:40:21,760
that get X does something more than get

00:40:17,950 --> 00:40:24,730
X maybe there's a good reason why get

00:40:21,760 --> 00:40:25,869
exchanged its behavior along the way but

00:40:24,730 --> 00:40:29,260
when that happens

00:40:25,869 --> 00:40:33,340
please rename that method to make it

00:40:29,260 --> 00:40:35,140
clear what happens so on the object ever

00:40:33,340 --> 00:40:38,050
you do not mix these read and write

00:40:35,140 --> 00:40:39,970
operations software design is recursive

00:40:38,050 --> 00:40:42,880
I said but what does it mean that means

00:40:39,970 --> 00:40:44,740
the same principle is applied not only

00:40:42,880 --> 00:40:47,340
on your object level but also on your

00:40:44,740 --> 00:40:48,550
architecture level there it's called

00:40:47,340 --> 00:40:50,260
CQRS

00:40:48,550 --> 00:40:52,180
command clear irresponsibility

00:40:50,260 --> 00:40:54,700
segregation which basically means that

00:40:52,180 --> 00:40:56,830
you treat the get requests that come

00:40:54,700 --> 00:40:59,650
into your application completely

00:40:56,830 --> 00:41:02,980
different from requests that change

00:40:59,650 --> 00:41:05,590
state obviously also implying that get

00:41:02,980 --> 00:41:07,210
requests do not mutate States somewhere

00:41:05,590 --> 00:41:11,400
on the server in the database whatever

00:41:07,210 --> 00:41:11,400
so you want to clean separation there

00:41:13,619 --> 00:41:18,730
single responsibility principle can be

00:41:16,630 --> 00:41:22,750
applied and that's where it comes from

00:41:18,730 --> 00:41:24,910
on on the object level a class should be

00:41:22,750 --> 00:41:28,750
responsible for one thing and one thing

00:41:24,910 --> 00:41:31,690
only they should only ever be one reason

00:41:28,750 --> 00:41:33,369
to change the class because something in

00:41:31,690 --> 00:41:34,960
their class the class needs changing not

00:41:33,369 --> 00:41:37,180
because I changed something in my

00:41:34,960 --> 00:41:39,369
front-end and added some change some

00:41:37,180 --> 00:41:41,680
HTML and now that class in my back by

00:41:39,369 --> 00:41:43,300
business logic needs to be changed no so

00:41:41,680 --> 00:41:45,310
things have nothing to do with each

00:41:43,300 --> 00:41:49,359
other or I changed something in the

00:41:45,310 --> 00:41:50,590
database and now I know single

00:41:49,359 --> 00:41:52,420
responsibility principle they should

00:41:50,590 --> 00:41:55,030
only ever be one reason to change that

00:41:52,420 --> 00:41:56,920
thing and you can also apply that on the

00:41:55,030 --> 00:41:58,990
architectural level which brings us back

00:41:56,920 --> 00:42:03,250
to the microservices which should now be

00:41:58,990 --> 00:42:04,960
called self-contained systems they

00:42:03,250 --> 00:42:09,400
should be such a service should be

00:42:04,960 --> 00:42:11,470
responsible for one thing and if it's

00:42:09,400 --> 00:42:13,390
only responsible for one thing then it

00:42:11,470 --> 00:42:15,790
doesn't need to talk to somebody else to

00:42:13,390 --> 00:42:18,670
get it strapped on and you can compose

00:42:15,790 --> 00:42:21,250
bigger things from these self-contained

00:42:18,670 --> 00:42:24,280
systems and then suddenly it's complete

00:42:21,250 --> 00:42:26,680
it's really easy to test them in

00:42:24,280 --> 00:42:29,650
isolation from each other to deploy them

00:42:26,680 --> 00:42:33,910
on different road maps and at different

00:42:29,650 --> 00:42:39,520
points in time and everything is a lot

00:42:33,910 --> 00:42:41,740
easier and more awesome and hopefully

00:42:39,520 --> 00:42:47,170
people will really start to implement

00:42:41,740 --> 00:42:50,170
software like that and in closing the

00:42:47,170 --> 00:42:52,690
loop think not only talking about

00:42:50,170 --> 00:42:54,640
implementation but also understanding

00:42:52,690 --> 00:42:57,100
the problem domain and making it

00:42:54,640 --> 00:42:58,930
manageable cutting it down that's what

00:42:57,100 --> 00:43:05,740
domain driven design means by bounded

00:42:58,930 --> 00:43:07,870
contexts and in such a whatever you want

00:43:05,740 --> 00:43:09,700
to call it call it micro service call it

00:43:07,870 --> 00:43:11,860
a well written micro service or call it

00:43:09,700 --> 00:43:14,800
a self-contained system they should be

00:43:11,860 --> 00:43:18,450
only functionality related to one

00:43:14,800 --> 00:43:22,030
bounded context in there because then

00:43:18,450 --> 00:43:23,650
almost by definition you get to a place

00:43:22,030 --> 00:43:33,190
where you do not have the dependencies

00:43:23,650 --> 00:43:36,850
and run into a nightmare okay that

00:43:33,190 --> 00:43:39,520
brings me to the end I hope that was

00:43:36,850 --> 00:43:40,870
interesting I shared with you the secret

00:43:39,520 --> 00:43:42,490
in the beginning that I didn't really

00:43:40,870 --> 00:43:44,350
know what I was getting going into and

00:43:42,490 --> 00:43:47,680
that it might involve some time travel

00:43:44,350 --> 00:43:50,230
and looking back at how we did things in

00:43:47,680 --> 00:43:54,400
the past and how that slowly evolved

00:43:50,230 --> 00:43:56,170
over time and I hope that this was at

00:43:54,400 --> 00:43:56,890
least to some degree useful to you thank

00:43:56,170 --> 00:44:00,350
you

00:43:56,890 --> 00:44:05,239
[Applause]

00:44:00,350 --> 00:44:05,239

YouTube URL: https://www.youtube.com/watch?v=RMpcAtnxGFA


