Title: CQRS and Event Sourcing explained | Stefan Priebsch | IPC Spring 2018
Publication date: 2019-02-11
Playlist: International PHP Conference Spring 2018
Description: 
	Stefan Priebsch (thePHP.cc): CQRS (Command/Query Responsibility Segregation) and Event Sourcing might become new buzzwords in the PHP community. But what exactly is all the fuzz about, and should you care? This talk provides a comprehensive introduction, and will enable you to decide whether CQRS and Event Sourcing might be the right choice for you.
Captions: 
	00:00:05,899 --> 00:00:17,840
hello believe it or not I do not enjoy

00:00:13,830 --> 00:00:22,619
being up here because for the hardcore

00:00:17,840 --> 00:00:24,900
technical presentations where you show

00:00:22,619 --> 00:00:27,570
code being in the big room is always a

00:00:24,900 --> 00:00:30,510
problem and I'm gonna show code so

00:00:27,570 --> 00:00:32,219
there's gonna be a problem but to make

00:00:30,510 --> 00:00:34,410
up for that I've also had some I put

00:00:32,219 --> 00:00:38,040
some fluff in for the beginning of the

00:00:34,410 --> 00:00:42,120
presentation hi I'm Stephan I'm a

00:00:38,040 --> 00:00:44,690
consultant I'd coach teams I'm writing

00:00:42,120 --> 00:00:48,059
stuff as in books ebooks and so on I

00:00:44,690 --> 00:00:50,070
give lectures at University of Rosenheim

00:00:48,059 --> 00:00:54,379
every once in a while on web programming

00:00:50,070 --> 00:00:58,910
and I'm a proven scalability expert

00:00:54,379 --> 00:01:02,190
which means I'm the father of twins I

00:00:58,910 --> 00:01:04,129
work for that company the PHP consulting

00:01:02,190 --> 00:01:07,110
company which I co-founded with

00:01:04,129 --> 00:01:09,450
Sebastian Brockman and Anna blankets we

00:01:07,110 --> 00:01:12,840
help teams build better software we help

00:01:09,450 --> 00:01:15,479
companies deal with their PHP technology

00:01:12,840 --> 00:01:17,340
related problems and sometimes also with

00:01:15,479 --> 00:01:22,470
people technology related people

00:01:17,340 --> 00:01:24,750
problems kind of things short disclaimer

00:01:22,470 --> 00:01:27,180
before I start I'm gonna show some code

00:01:24,750 --> 00:01:29,329
it's not production ready it's copy

00:01:27,180 --> 00:01:33,030
pasted and edited to fit on the screen

00:01:29,329 --> 00:01:36,060
some details are left out it's code that

00:01:33,030 --> 00:01:37,680
is meant to be for me to allow me to

00:01:36,060 --> 00:01:39,540
explain things to you it's not

00:01:37,680 --> 00:01:42,649
production-ready so don't copy and paste

00:01:39,540 --> 00:01:44,820
that and blame me that it doesn't work

00:01:42,649 --> 00:01:48,470
other than that if you have any

00:01:44,820 --> 00:01:53,640
questions feel free to interrupt me I

00:01:48,470 --> 00:02:00,090
think it's time you should meet Bob this

00:01:53,640 --> 00:02:02,850
is Bob Bob strapping young lad this is

00:02:00,090 --> 00:02:03,680
Bob's house he likes to take a swim in

00:02:02,850 --> 00:02:07,049
the morning

00:02:03,680 --> 00:02:09,060
he likes to barbeque actually this is

00:02:07,049 --> 00:02:12,770
only one of Bob's houses this is Denver

00:02:09,060 --> 00:02:15,110
he also has a house in Los Angeles

00:02:12,770 --> 00:02:19,599
an apartment in New York and I think he

00:02:15,110 --> 00:02:22,730
has another house in southern France

00:02:19,599 --> 00:02:26,090
this is how he gets from Los Angeles to

00:02:22,730 --> 00:02:28,340
New York and this is how he moves around

00:02:26,090 --> 00:02:30,890
when he's in southern France of course

00:02:28,340 --> 00:02:34,330
he has to get to southern France some

00:02:30,890 --> 00:02:37,040
way so this is how he usually does that

00:02:34,330 --> 00:02:41,630
of course he has a hobby this is his

00:02:37,040 --> 00:02:44,810
favorite hobby and bob was born and

00:02:41,630 --> 00:02:45,530
raised on a farm in Kansas he used to

00:02:44,810 --> 00:02:48,860
climb trees

00:02:45,530 --> 00:02:51,500
he built tree houses and he always said

00:02:48,860 --> 00:02:54,819
I'm gonna be big and famous when I'm

00:02:51,500 --> 00:03:00,380
grown up and after finishing high school

00:02:54,819 --> 00:03:04,190
Bob went off to work in Wall Street he

00:03:00,380 --> 00:03:08,890
was very lucky to land a great job as an

00:03:04,190 --> 00:03:12,470
investment banker with a company called

00:03:08,890 --> 00:03:17,540
Lehman Brothers so he was doing really

00:03:12,470 --> 00:03:24,680
well around 2006 and then times got a

00:03:17,540 --> 00:03:27,470
little less great Bob actually made it

00:03:24,680 --> 00:03:32,900
through the bad times pretty well his

00:03:27,470 --> 00:03:39,769
wife did not and Bob had some personal

00:03:32,900 --> 00:03:43,220
issues for a while but he was saved and

00:03:39,769 --> 00:03:48,170
actually considered turning priest but

00:03:43,220 --> 00:03:56,750
then he fell in love he met this

00:03:48,170 --> 00:04:00,920
beautiful woman she was 98 living in

00:03:56,750 --> 00:04:05,170
that castle and shortly after that they

00:04:00,920 --> 00:04:05,170
got married in an undisclosed location

00:04:05,260 --> 00:04:12,440
tragically on there a few weeks after

00:04:09,650 --> 00:04:15,799
that when they were hiking in the

00:04:12,440 --> 00:04:22,650
Himalaya the old lady mysteriously died

00:04:15,799 --> 00:04:26,880
and this is this is where Bob well

00:04:22,650 --> 00:04:30,400
okay and Bob really got bored with

00:04:26,880 --> 00:04:34,300
everything basically after a while so he

00:04:30,400 --> 00:04:40,470
chose to live as Barbara does it is

00:04:34,300 --> 00:04:42,970
Barbara she's married to Alice okay so

00:04:40,470 --> 00:04:49,780
these are crazy times we live in

00:04:42,970 --> 00:04:53,710
everything changes well where did Bob

00:04:49,780 --> 00:04:57,100
live in 2008 kind of hard to figure out

00:04:53,710 --> 00:04:59,350
right actually as of today the proper

00:04:57,100 --> 00:05:01,540
question to ask where did Barbara live

00:04:59,350 --> 00:05:03,400
in 2008 and then we do have to be clever

00:05:01,540 --> 00:05:07,360
enough to figure out that Barbara in

00:05:03,400 --> 00:05:09,160
2008 actually was Bob and we could try

00:05:07,360 --> 00:05:12,460
to figure out where Bob lived that's

00:05:09,160 --> 00:05:13,270
kind of weird right and what is Bob's

00:05:12,460 --> 00:05:17,110
gender

00:05:13,270 --> 00:05:19,680
wait what is Barbara's gender or is it

00:05:17,110 --> 00:05:22,630
depending on when we ask the question

00:05:19,680 --> 00:05:24,550
it's kind of weird and it's pretty

00:05:22,630 --> 00:05:27,550
confusing always reminds me of Back to

00:05:24,550 --> 00:05:29,320
the Future where Marty McFly after the

00:05:27,550 --> 00:05:32,080
time machine has disappeared for the

00:05:29,320 --> 00:05:34,300
first time says where the hell are they

00:05:32,080 --> 00:05:37,180
and then Doc Brown says the appropriate

00:05:34,300 --> 00:05:39,460
question is when the hell are they yeah

00:05:37,180 --> 00:05:42,850
everything changes this is really

00:05:39,460 --> 00:05:44,890
confusing so actually I've I remember

00:05:42,850 --> 00:05:48,760
having that conversation with developers

00:05:44,890 --> 00:05:52,810
about a personal record right so it's

00:05:48,760 --> 00:05:56,500
just data and we just record you know a

00:05:52,810 --> 00:06:00,160
name and gender and address written and

00:05:56,500 --> 00:06:03,460
that's it okay so but then at some point

00:06:00,160 --> 00:06:07,000
people tend to move so their address

00:06:03,460 --> 00:06:09,910
changes so actually the address data is

00:06:07,000 --> 00:06:15,430
temporal okay I can live with that

00:06:09,910 --> 00:06:20,020
well turns out that the name of people

00:06:15,430 --> 00:06:22,870
is also temporal I have multiple friends

00:06:20,020 --> 00:06:26,950
and relatives who even as males got

00:06:22,870 --> 00:06:29,500
married and took the name of their wife

00:06:26,950 --> 00:06:31,720
I mean one of my friends names was

00:06:29,500 --> 00:06:34,090
Schmidt if you're not familiar it's one

00:06:31,720 --> 00:06:35,320
of the most common names in Germany and

00:06:34,090 --> 00:06:37,000
his wife had a more you

00:06:35,320 --> 00:06:39,190
nickname so he figured it would be a

00:06:37,000 --> 00:06:43,480
good opportunity to make his name more

00:06:39,190 --> 00:06:45,580
unique so he changed his name and women

00:06:43,480 --> 00:06:48,310
have traditionally been changing their

00:06:45,580 --> 00:06:50,890
names when they got married now they can

00:06:48,310 --> 00:06:52,600
do that or they can't do it and I really

00:06:50,890 --> 00:06:54,730
haven't figured out how it's with the

00:06:52,600 --> 00:06:56,320
kids when they initially have a name and

00:06:54,730 --> 00:06:58,300
then the care and parents get married us

00:06:56,320 --> 00:07:00,760
is the name of the children all also

00:06:58,300 --> 00:07:04,330
change I don't even know that so the

00:07:00,760 --> 00:07:06,130
name is temporal well as of today it

00:07:04,330 --> 00:07:09,910
seems that the gender is temporal as

00:07:06,130 --> 00:07:11,560
well and pretty much everything else is

00:07:09,910 --> 00:07:14,890
temporal have you read the news about

00:07:11,560 --> 00:07:17,470
that guy who was like a child that was

00:07:14,890 --> 00:07:22,270
lost their parents and everything in the

00:07:17,470 --> 00:07:24,640
war and he always figured that he was so

00:07:22,270 --> 00:07:26,890
old and that that was his birthday and

00:07:24,640 --> 00:07:29,290
like fifty years later they found his

00:07:26,890 --> 00:07:31,870
original birth certificate and they

00:07:29,290 --> 00:07:35,050
realized oh no that's not your birthday

00:07:31,870 --> 00:07:38,170
your birthday is different well it seems

00:07:35,050 --> 00:07:41,560
like this kind of data is also temporal

00:07:38,170 --> 00:07:43,660
at least it needs to be able to change

00:07:41,560 --> 00:07:48,250
and that's probably something you have

00:07:43,660 --> 00:07:51,250
not accounted for now I finished that

00:07:48,250 --> 00:07:54,010
that example and you know that the

00:07:51,250 --> 00:07:56,500
same-sex marriage has legally been

00:07:54,010 --> 00:07:59,500
become possible in Germany last year and

00:07:56,500 --> 00:08:03,070
I don't know if you follow that there is

00:07:59,500 --> 00:08:05,860
a fun thing happening with that and I'm

00:08:03,070 --> 00:08:08,200
quoting from Deutsche Welle when the law

00:08:05,860 --> 00:08:10,570
takes in effect on October 1st registry

00:08:08,200 --> 00:08:13,060
systems will not allow bureaucrats to

00:08:10,570 --> 00:08:16,270
enter to people of the same gender into

00:08:13,060 --> 00:08:19,090
one marriage because the fundamental

00:08:16,270 --> 00:08:21,940
business rule has always been that a man

00:08:19,090 --> 00:08:24,280
and a woman get married and now these

00:08:21,940 --> 00:08:27,640
systems suddenly have a problem because

00:08:24,280 --> 00:08:31,090
that fundamental business rule is well

00:08:27,640 --> 00:08:33,960
has changed it seems that the

00:08:31,090 --> 00:08:36,370
administrative entity administrative

00:08:33,960 --> 00:08:41,530
institutions that register marriages

00:08:36,370 --> 00:08:43,419
were unable to keep up it continues it

00:08:41,530 --> 00:08:45,930
will take more than a year to update the

00:08:43,419 --> 00:08:45,930
software

00:08:47,170 --> 00:08:52,060
and it gets worse because for the time

00:08:50,380 --> 00:08:54,460
being people have to enter wrong

00:08:52,060 --> 00:08:58,450
information to even make it possible for

00:08:54,460 --> 00:08:59,440
same-sex couples to get married that's

00:08:58,450 --> 00:09:04,630
pretty bad

00:08:59,440 --> 00:09:07,300
I'm not I'm not really familiar with any

00:09:04,630 --> 00:09:09,490
details but as far as I could research

00:09:07,300 --> 00:09:14,260
it the problem seems to be not the

00:09:09,490 --> 00:09:15,190
original software but the the official

00:09:14,260 --> 00:09:18,700
registry

00:09:15,190 --> 00:09:21,700
that is based on an XML format and that

00:09:18,700 --> 00:09:24,490
XML format has arisen a release cycle of

00:09:21,700 --> 00:09:26,380
12 months and it was not ready as of

00:09:24,490 --> 00:09:28,840
last year so that's why they have to

00:09:26,380 --> 00:09:30,520
wait for one year because they cannot

00:09:28,840 --> 00:09:32,710
get the information they basically they

00:09:30,520 --> 00:09:35,110
cannot create the XML because they were

00:09:32,710 --> 00:09:38,920
clever enough to not put person in there

00:09:35,110 --> 00:09:43,150
but man and woman kind of thing and that

00:09:38,920 --> 00:09:48,250
doesn't work anymore maybe Jason and

00:09:43,150 --> 00:09:50,110
well no I'm not going there so um we're

00:09:48,250 --> 00:09:54,820
gonna be talking about event sourcing

00:09:50,110 --> 00:09:56,920
and secure s and this really is an

00:09:54,820 --> 00:09:58,870
introductory talk I'm gonna show code

00:09:56,920 --> 00:10:00,520
I'm gonna explain the basic concepts so

00:09:58,870 --> 00:10:02,620
if you're familiar with the concepts is

00:10:00,520 --> 00:10:05,440
probably gonna be a little boring for

00:10:02,620 --> 00:10:09,640
you but then again there will be code so

00:10:05,440 --> 00:10:13,030
it turns out that everything changes all

00:10:09,640 --> 00:10:15,580
data is temporal and it seems that a lot

00:10:13,030 --> 00:10:18,310
of problems with existing systems is

00:10:15,580 --> 00:10:20,530
that initially you assume that for the

00:10:18,310 --> 00:10:22,270
purposes of the system you are building

00:10:20,530 --> 00:10:24,520
you can safely assume that certain

00:10:22,270 --> 00:10:27,250
things are fixed and they are not gonna

00:10:24,520 --> 00:10:29,380
change but at some times some point they

00:10:27,250 --> 00:10:33,130
change maybe there is a little new legal

00:10:29,380 --> 00:10:36,250
requirement and things change and so it

00:10:33,130 --> 00:10:39,880
seems like everything is in movement

00:10:36,250 --> 00:10:42,160
everything is in flow and it seems to be

00:10:39,880 --> 00:10:43,440
really hard to deal with that and there

00:10:42,160 --> 00:10:46,810
is a reason for that

00:10:43,440 --> 00:10:50,230
traditionally as computer scientists we

00:10:46,810 --> 00:10:53,530
have always built systems that were

00:10:50,230 --> 00:10:56,380
strongly focused on state what is the

00:10:53,530 --> 00:10:58,150
state of something now what does that

00:10:56,380 --> 00:11:00,970
thing look like now

00:10:58,150 --> 00:11:04,569
that's usually what most systems

00:11:00,970 --> 00:11:06,970
you with rarely that systems kind of are

00:11:04,569 --> 00:11:10,000
able to go back in history and say what

00:11:06,970 --> 00:11:12,250
was the state of that as of like half a

00:11:10,000 --> 00:11:15,129
year ago version control actually is

00:11:12,250 --> 00:11:17,529
pretty pretty clever at that and any

00:11:15,129 --> 00:11:19,480
system really dealing with customer

00:11:17,529 --> 00:11:21,310
relations addresses and stuff they of

00:11:19,480 --> 00:11:23,529
course also have figured out that people

00:11:21,310 --> 00:11:26,620
move around we use stuff like LinkedIn

00:11:23,529 --> 00:11:29,259
or King and it's the same thing people

00:11:26,620 --> 00:11:31,269
move people change the companies but

00:11:29,259 --> 00:11:33,189
they still have their account that we

00:11:31,269 --> 00:11:35,949
are linked with so we can find them

00:11:33,189 --> 00:11:38,610
that's kind of cool but essentially it's

00:11:35,949 --> 00:11:42,819
a kind of temporal data modeling right

00:11:38,610 --> 00:11:44,889
the thing or LinkedIn ID is the

00:11:42,819 --> 00:11:47,860
identifier and under that identify you

00:11:44,889 --> 00:11:49,750
can look the person up and figure out

00:11:47,860 --> 00:11:53,079
where they're working now or where they

00:11:49,750 --> 00:11:56,139
are living now the thing is if you

00:11:53,079 --> 00:11:58,300
realize that the piece of data should

00:11:56,139 --> 00:12:00,759
have been temporal that in the original

00:11:58,300 --> 00:12:04,930
design of your software was known was

00:12:00,759 --> 00:12:07,540
modeled as non temporal all your queries

00:12:04,930 --> 00:12:10,689
are going to break because temporal data

00:12:07,540 --> 00:12:12,970
is not as easy as joining a foreign key

00:12:10,689 --> 00:12:15,819
if you think about the sequel database

00:12:12,970 --> 00:12:19,269
at least and and it is perfectly

00:12:15,819 --> 00:12:21,519
possible to model temporal databases I

00:12:19,269 --> 00:12:25,269
can assure you that it's not fun and

00:12:21,519 --> 00:12:28,120
it's not fun to query them everything is

00:12:25,269 --> 00:12:31,870
possible but it's kind of we're not

00:12:28,120 --> 00:12:34,360
enjoying ourselves so maybe we should

00:12:31,870 --> 00:12:37,269
challenge the assumption of focusing so

00:12:34,360 --> 00:12:43,660
much on state and building state based

00:12:37,269 --> 00:12:45,160
systems look at Bob's life well the

00:12:43,660 --> 00:12:48,670
state of Bob's life

00:12:45,160 --> 00:12:51,309
constantly changed the amount of money

00:12:48,670 --> 00:12:54,639
he had in his bank account state has

00:12:51,309 --> 00:12:57,040
changed his address changed his gender

00:12:54,639 --> 00:12:59,139
changed his marriage changed he was

00:12:57,040 --> 00:13:03,370
married he was unmarried he was married

00:12:59,139 --> 00:13:07,649
again so there was a lot of changes to

00:13:03,370 --> 00:13:07,649
Bob's state if you will

00:13:09,149 --> 00:13:15,880
why don't we look at those state changes

00:13:12,959 --> 00:13:19,500
at those things that happen at those

00:13:15,880 --> 00:13:22,690
events rather than the state itself

00:13:19,500 --> 00:13:26,380
because the world is based on it whence

00:13:22,690 --> 00:13:31,120
things happen and the interesting

00:13:26,380 --> 00:13:37,060
observation is while we're data seems to

00:13:31,120 --> 00:13:40,860
be temporal events are immutable if I

00:13:37,060 --> 00:13:44,560
drop a glass a glass is gonna break I

00:13:40,860 --> 00:13:49,420
cannot undo that I can repair the glass

00:13:44,560 --> 00:13:52,630
I can buy a new glass I can try to sweep

00:13:49,420 --> 00:13:56,579
it under the rug but I cannot undo the

00:13:52,630 --> 00:14:00,420
fact so an event that has happened is

00:13:56,579 --> 00:14:03,430
inevitable and we can't change it

00:14:00,420 --> 00:14:06,279
right if I say something stupid today I

00:14:03,430 --> 00:14:09,100
might regret it tomorrow but I have said

00:14:06,279 --> 00:14:12,100
it I can't undo that some people suffer

00:14:09,100 --> 00:14:14,790
badly from having done things they

00:14:12,100 --> 00:14:19,690
shouldn't have done you can't undo them

00:14:14,790 --> 00:14:22,600
so it turns out that events the world is

00:14:19,690 --> 00:14:25,839
a series of events happening and each

00:14:22,600 --> 00:14:29,560
event is something that is inevitable

00:14:25,839 --> 00:14:37,930
and immutable if it has happened we can

00:14:29,560 --> 00:14:41,980
record it it's not gonna change so why

00:14:37,930 --> 00:14:45,690
not model a system by looking at the

00:14:41,980 --> 00:14:48,520
events that have led to a certain state

00:14:45,690 --> 00:14:51,459
rather than looking at a certain state

00:14:48,520 --> 00:14:54,370
and having to deal with temporal data

00:14:51,459 --> 00:14:56,740
one of the cool thing about immutable

00:14:54,370 --> 00:14:58,720
data events are immutable data because

00:14:56,740 --> 00:15:01,899
they cannot be changed

00:14:58,720 --> 00:15:05,410
there can be corrective events following

00:15:01,899 --> 00:15:07,089
an event right if I deduct 10000 euros

00:15:05,410 --> 00:15:09,730
from my bank account today that's

00:15:07,089 --> 00:15:12,160
probably not gonna work even if the bank

00:15:09,730 --> 00:15:14,860
initially gives me the money they come

00:15:12,160 --> 00:15:15,820
back tomorrow and say I'm sorry we're

00:15:14,860 --> 00:15:20,260
gonna undo that

00:15:15,820 --> 00:15:22,330
or if it worse somebody puts puts money

00:15:20,260 --> 00:15:24,160
into a wrong account is gonna end up

00:15:22,330 --> 00:15:26,850
there but they're gonna deduct it again

00:15:24,160 --> 00:15:29,470
so it has been there

00:15:26,850 --> 00:15:31,630
there was a corrective event it's like a

00:15:29,470 --> 00:15:33,280
corrective booking and bookkeeping you

00:15:31,630 --> 00:15:35,860
don't cross out bookings you don't

00:15:33,280 --> 00:15:38,500
change bookings so the immutability

00:15:35,860 --> 00:15:40,470
concept has been around for a long time

00:15:38,500 --> 00:15:45,940
actually goes back to medieval times

00:15:40,470 --> 00:15:47,650
when in Italy bookkeeping was was being

00:15:45,940 --> 00:15:49,450
developed and actually it was a friend

00:15:47,650 --> 00:15:51,730
of Leonardo da Vinci who did that and

00:15:49,450 --> 00:15:55,420
they came up with the idea or he came up

00:15:51,730 --> 00:15:59,170
with the idea of make a journal and you

00:15:55,420 --> 00:16:02,710
never change a journal if you have made

00:15:59,170 --> 00:16:05,770
a booking it's it's recorded it's a fact

00:16:02,710 --> 00:16:08,710
you can make a corrective booking but

00:16:05,770 --> 00:16:13,510
you're never going to go back and change

00:16:08,710 --> 00:16:17,290
a booking that you made so the cool

00:16:13,510 --> 00:16:20,440
thing about immutable data is it's easy

00:16:17,290 --> 00:16:23,530
to cache because by definition it never

00:16:20,440 --> 00:16:26,470
changes right so if I put immutable data

00:16:23,530 --> 00:16:30,040
into a cache I can leave it there

00:16:26,470 --> 00:16:32,920
forever and I have I don't have to worry

00:16:30,040 --> 00:16:36,100
about invalidating that cache because

00:16:32,920 --> 00:16:38,980
that data never changes that's kind of

00:16:36,100 --> 00:16:42,220
cool so it seems that maybe we will be

00:16:38,980 --> 00:16:45,970
able to build really scalable systems

00:16:42,220 --> 00:16:48,340
using these kinds of ideas now don't be

00:16:45,970 --> 00:16:51,520
tempted to think that this is a new idea

00:16:48,340 --> 00:16:56,320
event sourcing as a term has been around

00:16:51,520 --> 00:16:59,980
I think since 2011 2010 2011 when Greg

00:16:56,320 --> 00:17:02,320
young gave presentations at UConn I

00:16:59,980 --> 00:17:06,640
believe where he said well I have built

00:17:02,320 --> 00:17:09,670
these systems based on events and a

00:17:06,640 --> 00:17:11,770
stream of events and instead of state by

00:17:09,670 --> 00:17:14,800
focusing on state he was actually

00:17:11,770 --> 00:17:17,020
building trade systems I believe and he

00:17:14,800 --> 00:17:18,880
was giving a presentation and people

00:17:17,020 --> 00:17:20,740
like Martin Fowler listened into that

00:17:18,880 --> 00:17:23,170
and said hey you need to find a term for

00:17:20,740 --> 00:17:25,300
that because it's a cool concept and you

00:17:23,170 --> 00:17:28,090
need to have a name for it so people can

00:17:25,300 --> 00:17:29,660
start adopting that that's at some point

00:17:28,090 --> 00:17:37,280
where event sourcing

00:17:29,660 --> 00:17:40,010
as a term was born in fact we have

00:17:37,280 --> 00:17:42,620
always built systems like that because

00:17:40,010 --> 00:17:45,440
most systems we have ever built deal

00:17:42,620 --> 00:17:47,840
with money whenever we deal with money

00:17:45,440 --> 00:17:50,960
we go by the rules of bookkeeping and

00:17:47,840 --> 00:17:53,240
bookkeeping is well how do you determine

00:17:50,960 --> 00:17:56,780
the amount of money that you have in

00:17:53,240 --> 00:17:58,670
your bank account you take the initial

00:17:56,780 --> 00:18:01,490
amount which usually is zero when you

00:17:58,670 --> 00:18:04,640
open up the account and then there is

00:18:01,490 --> 00:18:07,520
money coming in and money going out you

00:18:04,640 --> 00:18:12,770
add it up so you get what's in your

00:18:07,520 --> 00:18:15,410
account this is event sourcing each

00:18:12,770 --> 00:18:17,840
booking record is an event and if you

00:18:15,410 --> 00:18:20,930
source the state of your bank account

00:18:17,840 --> 00:18:23,800
from this sequence of events you get

00:18:20,930 --> 00:18:27,140
what you have in your account currently

00:18:23,800 --> 00:18:31,130
very interesting has a few interesting

00:18:27,140 --> 00:18:33,860
properties because by definition you can

00:18:31,130 --> 00:18:36,290
look at the stream of events from the

00:18:33,860 --> 00:18:38,870
beginning of times until a certain point

00:18:36,290 --> 00:18:41,930
so if you want to know how did that

00:18:38,870 --> 00:18:43,790
thing look yesterday you can just look

00:18:41,930 --> 00:18:46,940
at the sequence of events until

00:18:43,790 --> 00:18:49,280
yesterday and you will exactly be able

00:18:46,940 --> 00:18:51,830
to reproduce the state a system or an

00:18:49,280 --> 00:18:53,870
object was in yesterday state based

00:18:51,830 --> 00:18:55,670
systems usually can't do that that's why

00:18:53,870 --> 00:18:58,820
we have such a hard time reproducing

00:18:55,670 --> 00:19:01,460
bugs somebody reports a bug against

00:18:58,820 --> 00:19:06,530
production what's the problem there was

00:19:01,460 --> 00:19:09,580
a state that caused a bug and this state

00:19:06,530 --> 00:19:12,800
has changed because data has changed and

00:19:09,580 --> 00:19:14,870
I'll an hour later you will not be able

00:19:12,800 --> 00:19:18,470
to reproduce the bug you might be able

00:19:14,870 --> 00:19:19,940
by coincidence but generally nobody

00:19:18,470 --> 00:19:21,680
guarantees you that you can reproduce

00:19:19,940 --> 00:19:23,720
that bug and that's why we go back

00:19:21,680 --> 00:19:25,820
hunting so much against life systems or

00:19:23,720 --> 00:19:28,640
problems in life systems oh I can't even

00:19:25,820 --> 00:19:31,700
reproduce that on QA or on testing or on

00:19:28,640 --> 00:19:35,360
my dev box with an event source system

00:19:31,700 --> 00:19:38,140
you can because the state of the system

00:19:35,360 --> 00:19:41,090
is derived from the stream of events

00:19:38,140 --> 00:19:42,710
okay now let's get down to the

00:19:41,090 --> 00:19:43,610
nitty-gritty I brought you some sample

00:19:42,710 --> 00:19:45,970
code because that's

00:19:43,610 --> 00:19:48,260
essentially actually it's pretty well

00:19:45,970 --> 00:19:51,020
actually it's pretty simple just a few

00:19:48,260 --> 00:19:53,720
lines of code if you look at it it's

00:19:51,020 --> 00:19:55,580
probably yeah took me a while to get

00:19:53,720 --> 00:19:57,350
there and it's probably gonna take

00:19:55,580 --> 00:19:58,940
everybody a while to understand that

00:19:57,350 --> 00:20:01,940
because it's just a different way of

00:19:58,940 --> 00:20:05,150
thinking but honestly we've always done

00:20:01,940 --> 00:20:06,830
that how does your version what's what's

00:20:05,150 --> 00:20:08,299
your favorite version contours probably

00:20:06,830 --> 00:20:14,870
doing something like it right how does

00:20:08,299 --> 00:20:17,390
get work you check in a file and then

00:20:14,870 --> 00:20:20,720
you apply a change to the file what

00:20:17,390 --> 00:20:23,809
internally get creates a diff and it

00:20:20,720 --> 00:20:26,929
records the diff it doesn't record the

00:20:23,809 --> 00:20:31,040
new state of the file it just records a

00:20:26,929 --> 00:20:34,580
sequence of diffs and if you ask it for

00:20:31,040 --> 00:20:37,790
what does the file look as of now it's

00:20:34,580 --> 00:20:39,040
gonna take the initial state and apply

00:20:37,790 --> 00:20:42,830
the patches

00:20:39,040 --> 00:20:44,179
yes it's called event sourcing now if

00:20:42,830 --> 00:20:46,400
you want to see the state as of

00:20:44,179 --> 00:20:49,790
yesterday hopefully you have a tag or

00:20:46,400 --> 00:20:51,559
you have some commits against some

00:20:49,790 --> 00:20:54,350
commit ID that you can use and say okay

00:20:51,559 --> 00:20:57,710
so replay all the events until that

00:20:54,350 --> 00:21:03,650
commit and you're gonna exactly see how

00:20:57,710 --> 00:21:09,049
your file looked yesterday how about

00:21:03,650 --> 00:21:12,020
relational databases relational

00:21:09,049 --> 00:21:15,260
databases are eventsource systems do you

00:21:12,020 --> 00:21:18,200
believe me I'll prove it to you

00:21:15,260 --> 00:21:20,390
so you have tables and the table are a

00:21:18,200 --> 00:21:22,490
materialization of the current state of

00:21:20,390 --> 00:21:24,980
the database so that can't possibly be

00:21:22,490 --> 00:21:29,390
event sources you say no well what

00:21:24,980 --> 00:21:30,850
happens if your database crashes there's

00:21:29,390 --> 00:21:34,850
a binary log

00:21:30,850 --> 00:21:37,910
what's the binary log the binary log is

00:21:34,850 --> 00:21:41,000
a log of all the transactions of all the

00:21:37,910 --> 00:21:43,030
queries that you have sent against your

00:21:41,000 --> 00:21:46,549
database executed against your database

00:21:43,030 --> 00:21:49,820
so that's a log of events this query has

00:21:46,549 --> 00:21:53,690
happened this insert has happened this

00:21:49,820 --> 00:21:55,669
update has happened now if your tables

00:21:53,690 --> 00:21:56,650
become inconsistent in your database

00:21:55,669 --> 00:21:59,350
crashes

00:21:56,650 --> 00:22:04,300
what it's gonna do is gonna rebuild the

00:21:59,350 --> 00:22:09,060
tables from the binary log its event

00:22:04,300 --> 00:22:11,890
sourcing if you replicate your database

00:22:09,060 --> 00:22:13,450
to another remote database it's

00:22:11,890 --> 00:22:16,420
technically the same thing that's

00:22:13,450 --> 00:22:22,840
happening it's event sourcing and the

00:22:16,420 --> 00:22:26,200
remote is catching up so actually a lot

00:22:22,840 --> 00:22:30,010
of systems have always conceptually been

00:22:26,200 --> 00:22:32,080
event sourced for some reason we got so

00:22:30,010 --> 00:22:37,330
focused on state based systems that

00:22:32,080 --> 00:22:40,420
event sourcing kind of well fell off the

00:22:37,330 --> 00:22:46,840
table maybe Greg Young coined the term

00:22:40,420 --> 00:22:49,540
it has been very commonly used in recent

00:22:46,840 --> 00:22:52,300
years I think it's a very interesting

00:22:49,540 --> 00:22:56,500
concept so let's look at some code first

00:22:52,300 --> 00:22:58,570
of all we need events an event is really

00:22:56,500 --> 00:23:01,330
simple it's just a tto so the example

00:22:58,570 --> 00:23:03,220
I'm showing here is just a counter right

00:23:01,330 --> 00:23:05,860
you can initialize a counter with a

00:23:03,220 --> 00:23:08,830
value and you can increment the counter

00:23:05,860 --> 00:23:11,080
it's a very simple basic example so that

00:23:08,830 --> 00:23:13,690
the code will actually fit on the slides

00:23:11,080 --> 00:23:15,520
so I think you can't see the pointer so

00:23:13,690 --> 00:23:18,160
I'm gonna have a hard time pointing that

00:23:15,520 --> 00:23:24,760
out but basically this is just a DTO

00:23:18,160 --> 00:23:29,380
a data object it's just well I have a

00:23:24,760 --> 00:23:31,510
counter that has an ID I'm using a user

00:23:29,380 --> 00:23:37,300
ID for that and it has an initial value

00:23:31,510 --> 00:23:40,210
which is an integer okay and I'm using

00:23:37,300 --> 00:23:44,170
that fancy named constructor which is

00:23:40,210 --> 00:23:46,180
just has a reason that you don't see

00:23:44,170 --> 00:23:49,030
that's because I'm I've left out some

00:23:46,180 --> 00:23:50,860
code but essentially this is just you

00:23:49,030 --> 00:23:53,470
can ask it for the counter ID you can

00:23:50,860 --> 00:23:55,360
ask it for the initial value and then

00:23:53,470 --> 00:23:59,620
this is something a little special

00:23:55,360 --> 00:24:01,780
that's a string identifier of that event

00:23:59,620 --> 00:24:04,090
because I don't want to work with the

00:24:01,780 --> 00:24:07,030
class names so I'm using that string

00:24:04,090 --> 00:24:07,850
that's basically just so that code can

00:24:07,030 --> 00:24:10,550
react to

00:24:07,850 --> 00:24:15,830
and doesn't have to do that based on

00:24:10,550 --> 00:24:19,010
class names right that's it so if we

00:24:15,830 --> 00:24:23,260
record the fact that we have initialized

00:24:19,010 --> 00:24:26,810
a counter then we can create this event

00:24:23,260 --> 00:24:29,210
and let's just assume we're gonna

00:24:26,810 --> 00:24:33,440
magically store that somewhere it's

00:24:29,210 --> 00:24:37,370
called an event store now we have an

00:24:33,440 --> 00:24:39,350
second event counter incremented counter

00:24:37,370 --> 00:24:42,440
incremented well obviously we have to

00:24:39,350 --> 00:24:46,070
memorize which counter we have

00:24:42,440 --> 00:24:48,980
incremented and also which value we have

00:24:46,070 --> 00:24:54,910
incremented the counter to and then

00:24:48,980 --> 00:25:00,290
again it's just that simple detail now

00:24:54,910 --> 00:25:03,680
let's first of all figure out how we

00:25:00,290 --> 00:25:07,820
could create a counter object of these

00:25:03,680 --> 00:25:09,890
events then in a second pass let's worry

00:25:07,820 --> 00:25:13,400
about where did these events come from

00:25:09,890 --> 00:25:14,240
originally actually let's do it the

00:25:13,400 --> 00:25:18,800
other way around

00:25:14,240 --> 00:25:20,830
so this is my counter I'm gonna show you

00:25:18,800 --> 00:25:25,100
the base class I'm using in a minute

00:25:20,830 --> 00:25:28,850
when I initialize the counter I pass an

00:25:25,100 --> 00:25:31,820
initial value okay and this basically

00:25:28,850 --> 00:25:34,340
just calls the constructor and here's

00:25:31,820 --> 00:25:38,480
some fanciness because I have two ways

00:25:34,340 --> 00:25:40,160
to create this object one is if I

00:25:38,480 --> 00:25:42,620
initialize the counter that's my

00:25:40,160 --> 00:25:45,560
business constructor I now need a new

00:25:42,620 --> 00:25:47,390
counter this is the initial value and

00:25:45,560 --> 00:25:50,090
the other thing is gonna be our

00:25:47,390 --> 00:25:52,690
technical constructor that's what the

00:25:50,090 --> 00:25:55,130
one that we're going to be using when we

00:25:52,690 --> 00:25:57,380
wake up the object from persistence

00:25:55,130 --> 00:25:59,960
right so I have two different ways of

00:25:57,380 --> 00:26:03,350
creating a business object the one is

00:25:59,960 --> 00:26:06,290
that one time where I actually do a

00:26:03,350 --> 00:26:08,720
business wise creation like an invoice

00:26:06,290 --> 00:26:10,970
you created once you assign an invoice

00:26:08,720 --> 00:26:12,790
number then you may take the object and

00:26:10,970 --> 00:26:15,110
put it to sleep in your persistence

00:26:12,790 --> 00:26:17,900
infrastructure and at some later point

00:26:15,110 --> 00:26:22,540
you'll wake it up again so you recreate

00:26:17,900 --> 00:26:26,540
the object and that recreation

00:26:22,540 --> 00:26:32,330
happens here let's not deal with that so

00:26:26,540 --> 00:26:36,490
for now if we are not creating from

00:26:32,330 --> 00:26:39,530
existing events then we will record our

00:26:36,490 --> 00:26:42,380
counter initialized event we will

00:26:39,530 --> 00:26:47,210
generate a user ID and pass the initial

00:26:42,380 --> 00:26:49,850
value so this is where we create where

00:26:47,210 --> 00:26:53,030
we generate the events if the counter

00:26:49,850 --> 00:26:54,860
has decided that it can be created there

00:26:53,030 --> 00:27:00,220
might be guard clauses preventing them

00:26:54,860 --> 00:27:03,500
that then we will create an event and we

00:27:00,220 --> 00:27:08,030
will record an event we get into the

00:27:03,500 --> 00:27:08,960
record in a minute okay if we increment

00:27:08,030 --> 00:27:12,350
a counter

00:27:08,960 --> 00:27:15,470
well we'll increment the counter and

00:27:12,350 --> 00:27:17,660
we'll record the fact that the counter

00:27:15,470 --> 00:27:20,120
has been incremented now this is a very

00:27:17,660 --> 00:27:22,310
simple example there are no guard

00:27:20,120 --> 00:27:24,140
clauses there is no possibility for the

00:27:22,310 --> 00:27:26,120
counter to say I'm sorry

00:27:24,140 --> 00:27:29,720
you cannot increment me because it's

00:27:26,120 --> 00:27:31,760
Monday right in a real-life object there

00:27:29,720 --> 00:27:32,600
would be guard clauses like what it it's

00:27:31,760 --> 00:27:35,060
Monday

00:27:32,600 --> 00:27:35,780
you can't increment me or your name is

00:27:35,060 --> 00:27:37,340
Mulan

00:27:35,780 --> 00:27:42,110
you cannot increment me or whatever

00:27:37,340 --> 00:27:44,000
right and in case we are not up to being

00:27:42,110 --> 00:27:46,520
incremented as a counter we just throw

00:27:44,000 --> 00:27:50,510
an exception no you can't do it sorry

00:27:46,520 --> 00:27:52,430
Dave I can't do that okay we can ask the

00:27:50,510 --> 00:27:55,820
counter for the value and this is this

00:27:52,430 --> 00:27:58,790
this is the ugliest method now let's

00:27:55,820 --> 00:28:01,880
look at yeah okay

00:27:58,790 --> 00:28:05,360
I should have rearranged that's okay

00:28:01,880 --> 00:28:07,010
let's look at that now let's do pass too

00:28:05,360 --> 00:28:10,280
and then we get down into the

00:28:07,010 --> 00:28:14,180
nitty-gritty base class past two would

00:28:10,280 --> 00:28:17,750
be if we want to recreate I recreate our

00:28:14,180 --> 00:28:19,820
counter from events we would pass in a

00:28:17,750 --> 00:28:22,810
collection of events which is

00:28:19,820 --> 00:28:25,880
technically just an array that typed and

00:28:22,810 --> 00:28:27,860
we pass that to the constructor of the

00:28:25,880 --> 00:28:32,030
parent class some magic happens there

00:28:27,860 --> 00:28:33,950
and from a business perspective these

00:28:32,030 --> 00:28:37,610
are the two interesting methods

00:28:33,950 --> 00:28:42,050
right if there was a counter initialized

00:28:37,610 --> 00:28:44,360
event to apply that will take the IDE

00:28:42,050 --> 00:28:47,840
that we have recorded in the event this

00:28:44,360 --> 00:28:50,410
is gonna be our object ID and we take

00:28:47,840 --> 00:28:53,480
the initial value from the event and

00:28:50,410 --> 00:28:54,380
memorize that as our current initial

00:28:53,480 --> 00:28:57,920
value

00:28:54,380 --> 00:29:00,940
so essentially what the constructor does

00:28:57,920 --> 00:29:05,750
is it doesn't change the object State it

00:29:00,940 --> 00:29:09,980
records an event and when that event is

00:29:05,750 --> 00:29:13,010
applied the state change is being

00:29:09,980 --> 00:29:15,590
derived from data out of that event the

00:29:13,010 --> 00:29:17,990
same with apply counter increment will

00:29:15,590 --> 00:29:22,070
just take the value from the event and

00:29:17,990 --> 00:29:27,230
set the value now apply methods are

00:29:22,070 --> 00:29:29,720
actually used both when we initially do

00:29:27,230 --> 00:29:32,360
something and when we reconstitute our

00:29:29,720 --> 00:29:33,980
object and this is the ugliness I was

00:29:32,360 --> 00:29:36,350
talking about we need that ugliness

00:29:33,980 --> 00:29:38,720
because we don't have overloading in PHP

00:29:36,350 --> 00:29:40,940
right in a decent language well know in

00:29:38,720 --> 00:29:43,100
another language we could we could

00:29:40,940 --> 00:29:45,620
overload that method and say for counter

00:29:43,100 --> 00:29:47,660
incremented dispatch to this one for

00:29:45,620 --> 00:29:50,570
counter initialized is dispatch to that

00:29:47,660 --> 00:29:53,600
one in PHP I can do that that's why I

00:29:50,570 --> 00:29:56,960
have the name in here and I'll have to

00:29:53,600 --> 00:29:59,750
manually code that dispatch and this is

00:29:56,960 --> 00:30:02,390
why I have the strings right so I have a

00:29:59,750 --> 00:30:05,750
generic apply method apply an event to

00:30:02,390 --> 00:30:07,910
this object and if it's an initialized

00:30:05,750 --> 00:30:10,520
event then run the apply counter

00:30:07,910 --> 00:30:13,730
initialized method and if it's a counter

00:30:10,520 --> 00:30:15,590
incremented event then apply the counter

00:30:13,730 --> 00:30:20,480
incremented event that's basically just

00:30:15,590 --> 00:30:23,030
boilerplate code now that seems it seem

00:30:20,480 --> 00:30:28,190
doesn't seem complicated and the

00:30:23,030 --> 00:30:32,450
infrastructure below that is not more

00:30:28,190 --> 00:30:34,490
complicated than that so we need to be

00:30:32,450 --> 00:30:36,230
able to create an object from events

00:30:34,490 --> 00:30:42,770
that's the parent constructor thing

00:30:36,230 --> 00:30:44,600
right and we will record events that are

00:30:42,770 --> 00:30:47,480
called state changes here so whenever

00:30:44,600 --> 00:30:49,700
the state of our object changes

00:30:47,480 --> 00:31:02,059
an event is recorded that's what happens

00:30:49,700 --> 00:31:04,730
right here and here okay so this is our

00:31:02,059 --> 00:31:06,649
constructor in the case that there are

00:31:04,730 --> 00:31:08,649
events basically forget about the guard

00:31:06,649 --> 00:31:11,389
clause this is the interesting part and

00:31:08,649 --> 00:31:14,149
the rest is garbage reconstitute from

00:31:11,389 --> 00:31:18,500
events rebuild the state of this object

00:31:14,149 --> 00:31:22,940
from events now in case you thought that

00:31:18,500 --> 00:31:25,940
would be complicated it's not that's all

00:31:22,940 --> 00:31:32,919
it does okay go through all the events

00:31:25,940 --> 00:31:32,919
and apply them one by one that's all

00:31:33,370 --> 00:31:41,360
recording of events means apply them and

00:31:37,990 --> 00:31:43,490
memorize them as state changes and then

00:31:41,360 --> 00:31:46,580
there is this outrageously complex

00:31:43,490 --> 00:31:48,169
method which returns all the state

00:31:46,580 --> 00:31:51,380
changes that had happened that have

00:31:48,169 --> 00:31:53,630
happened so that's the changes that have

00:31:51,380 --> 00:31:57,950
happened to the object since it was

00:31:53,630 --> 00:32:01,519
initially created or loaded from

00:31:57,950 --> 00:32:03,049
persistence the set ID and that's crap

00:32:01,519 --> 00:32:06,230
we can basically forget that's not

00:32:03,049 --> 00:32:08,090
important it's just paranoia to make

00:32:06,230 --> 00:32:13,750
sure that the ID of an object does not

00:32:08,090 --> 00:32:16,940
change okay those events that are

00:32:13,750 --> 00:32:19,519
recorded as state changes they get

00:32:16,940 --> 00:32:21,980
stored in an event store an event store

00:32:19,519 --> 00:32:24,500
is basically just a database table that

00:32:21,980 --> 00:32:26,450
stores all the events which can be just

00:32:24,500 --> 00:32:29,179
serialized data or whatever format you

00:32:26,450 --> 00:32:33,139
like people usually use something like

00:32:29,179 --> 00:32:36,139
JSON and now we can basically fake a

00:32:33,139 --> 00:32:39,559
sequence of events we create a counter

00:32:36,139 --> 00:32:42,789
ID and initialize the counter with one

00:32:39,559 --> 00:32:45,470
and increment it twice so if we

00:32:42,789 --> 00:32:47,269
reconstitute a counter from that we

00:32:45,470 --> 00:32:51,830
actually get a counter having the value

00:32:47,269 --> 00:32:55,549
of three with a given ID now here's the

00:32:51,830 --> 00:32:59,149
fun part who is using doctrine or M or

00:32:55,549 --> 00:33:02,470
something similar how many lines of code

00:32:59,149 --> 00:33:02,470
does doctrine have

00:33:04,269 --> 00:33:07,870
how many lines of code did you see in

00:33:06,559 --> 00:33:10,399
that example

00:33:07,870 --> 00:33:14,299
that's a full-fledged persistence

00:33:10,399 --> 00:33:18,760
mechanism it's a counter domain object

00:33:14,299 --> 00:33:18,760
that can be persisted in an event store

00:33:18,850 --> 00:33:23,570
it's kind of neat so plus the event

00:33:22,039 --> 00:33:27,289
store we would actually be looking at

00:33:23,570 --> 00:33:29,360
around 300 lines of code and this is not

00:33:27,289 --> 00:33:32,360
an exaggeration I've built it and I've

00:33:29,360 --> 00:33:34,880
seen it work you can use other solutions

00:33:32,360 --> 00:33:38,450
people some people like to use Kafka or

00:33:34,880 --> 00:33:41,210
some some other queuing mechanism as an

00:33:38,450 --> 00:33:43,639
event store you can use plain MySQL and

00:33:41,210 --> 00:33:47,059
just build a database table to throw the

00:33:43,639 --> 00:33:49,220
events in there for reasons I will be

00:33:47,059 --> 00:33:52,279
explaining in a couple of minutes but

00:33:49,220 --> 00:33:54,710
that's actually all there is to it it's

00:33:52,279 --> 00:33:57,620
a seemingly new concept that has

00:33:54,710 --> 00:34:00,110
actually been very old actually it's a

00:33:57,620 --> 00:34:03,019
pretty natural concept right events

00:34:00,110 --> 00:34:05,990
happen our software makes decisions and

00:34:03,019 --> 00:34:07,850
records events and we can rebuild the

00:34:05,990 --> 00:34:09,560
state of the software from events

00:34:07,850 --> 00:34:12,619
usually people now say wow that's

00:34:09,560 --> 00:34:14,929
probably gonna be slow not really

00:34:12,619 --> 00:34:19,700
actually events or systems are pretty

00:34:14,929 --> 00:34:21,800
fast and funny enough for a regular PHP

00:34:19,700 --> 00:34:24,589
application right you have a web request

00:34:21,800 --> 00:34:27,200
that you process and say you have a

00:34:24,589 --> 00:34:29,149
million counters in your system we'll

00:34:27,200 --> 00:34:32,149
probably only work with one counter at a

00:34:29,149 --> 00:34:34,970
time so even if we have a million

00:34:32,149 --> 00:34:37,399
counter and can't punch a punch a couple

00:34:34,970 --> 00:34:41,540
of million events in our event store if

00:34:37,399 --> 00:34:44,359
we want to source one counter will

00:34:41,540 --> 00:34:47,780
actually need three events so it's just

00:34:44,359 --> 00:34:50,510
a parameterised query to our event store

00:34:47,780 --> 00:34:52,220
in database speak not to load five

00:34:50,510 --> 00:34:55,359
million events and throw them all away

00:34:52,220 --> 00:34:57,710
but select those that are relevant which

00:34:55,359 --> 00:34:59,810
coincidentally exactly those events that

00:34:57,710 --> 00:35:03,319
have originally been emitted by an

00:34:59,810 --> 00:35:05,839
encounter given that you UID so that's

00:35:03,319 --> 00:35:08,180
your mechanism to find these events and

00:35:05,839 --> 00:35:12,099
this is why our event carries the

00:35:08,180 --> 00:35:14,210
counter ID so basically counter ID or

00:35:12,099 --> 00:35:17,390
aggregate idea whatever you want

00:35:14,210 --> 00:35:20,240
all it becomes a property of your

00:35:17,390 --> 00:35:22,580
database table and you will be able to

00:35:20,240 --> 00:35:26,300
selectively load events from your event

00:35:22,580 --> 00:35:28,730
store just for one object and you can

00:35:26,300 --> 00:35:33,020
reconstitute that one object it's

00:35:28,730 --> 00:35:34,609
actually maybe maybe even quicker than

00:35:33,020 --> 00:35:37,990
the regular way but I think in that

00:35:34,609 --> 00:35:44,660
example it's probably gonna be on par

00:35:37,990 --> 00:35:48,160
okay second concept somehow closely

00:35:44,660 --> 00:35:51,890
related you'll see why in a minute but

00:35:48,160 --> 00:35:54,440
also something completely independent so

00:35:51,890 --> 00:35:56,920
what is the difference between a getter

00:35:54,440 --> 00:35:56,920
and a setter

00:35:59,170 --> 00:36:04,730
one is pure the other has side effects

00:36:01,820 --> 00:36:08,030
so the getter retrieves state and does

00:36:04,730 --> 00:36:12,170
not change the state the setter also

00:36:08,030 --> 00:36:15,440
called a mutator changes state this has

00:36:12,170 --> 00:36:16,970
been written in 1983 by bertrand maya in

00:36:15,440 --> 00:36:20,000
his book object-oriented software

00:36:16,970 --> 00:36:22,849
construction it's called the command

00:36:20,000 --> 00:36:25,940
query separation rule we all have

00:36:22,849 --> 00:36:28,130
learned to stick to that if you ask your

00:36:25,940 --> 00:36:30,740
object a question and this question

00:36:28,130 --> 00:36:31,750
changes the state of your object that's

00:36:30,740 --> 00:36:35,240
weird

00:36:31,750 --> 00:36:40,810
so what is the difference between a HTTP

00:36:35,240 --> 00:36:40,810
GET request and an HTTP POST request

00:36:44,290 --> 00:36:52,420
okay get is reading post is writing aka

00:36:49,090 --> 00:36:54,640
changing state get needs to be

00:36:52,420 --> 00:36:56,830
idempotent so you can ask the same

00:36:54,640 --> 00:36:59,350
questions as often as you like it's not

00:36:56,830 --> 00:37:01,960
gonna change the answer and if your

00:36:59,350 --> 00:37:04,450
server receives the get request it's not

00:37:01,960 --> 00:37:07,660
significant significantly going to

00:37:04,450 --> 00:37:09,040
change its state it's always technically

00:37:07,660 --> 00:37:11,560
going to change the state because it's

00:37:09,040 --> 00:37:14,940
gonna log the request which is a kind of

00:37:11,560 --> 00:37:17,830
state change but your application state

00:37:14,940 --> 00:37:21,760
usually does not change when you process

00:37:17,830 --> 00:37:24,610
a get request so the fundamental idea of

00:37:21,760 --> 00:37:27,070
this idea of this concept called CQRS

00:37:24,610 --> 00:37:31,810
which is a generalization of command

00:37:27,070 --> 00:37:35,170
query separation is let's build separate

00:37:31,810 --> 00:37:39,100
models traditionally we have built one

00:37:35,170 --> 00:37:42,670
model one piece of software for reading

00:37:39,100 --> 00:37:47,320
and writing we have used one persistence

00:37:42,670 --> 00:37:51,820
mechanism for both let's assume you have

00:37:47,320 --> 00:37:53,500
a MySQL database and I'm asking you to

00:37:51,820 --> 00:37:57,720
optimize your database because

00:37:53,500 --> 00:38:01,630
performance sucks what you're gonna do

00:37:57,720 --> 00:38:04,120
set indexes probably run some explains

00:38:01,630 --> 00:38:05,550
look at the logs find slow queries all

00:38:04,120 --> 00:38:09,730
that kind of stuff

00:38:05,550 --> 00:38:12,790
what are you optimizing for you're

00:38:09,730 --> 00:38:15,670
optimizing for reading because most

00:38:12,790 --> 00:38:19,750
traffic your application gets is read

00:38:15,670 --> 00:38:24,190
traffic so I've heard anything between

00:38:19,750 --> 00:38:28,540
10 to 1 to 10,000 to 1 as in read versus

00:38:24,190 --> 00:38:30,960
write requests we spend most of our time

00:38:28,540 --> 00:38:35,140
or application spends most of its time

00:38:30,960 --> 00:38:37,960
processing read requests and you have a

00:38:35,140 --> 00:38:39,820
software you have Java all your tables

00:38:37,960 --> 00:38:41,890
you're using an over m maybe or not

00:38:39,820 --> 00:38:44,680
you're building objects from that and

00:38:41,890 --> 00:38:47,080
then you're passing your objects to your

00:38:44,680 --> 00:38:49,090
view or you're creating arrays out of

00:38:47,080 --> 00:38:51,960
your object and pass those to your view

00:38:49,090 --> 00:38:56,920
and your view creates nice HTML and

00:38:51,960 --> 00:38:58,090
delivers that and all of that why are

00:38:56,920 --> 00:39:00,550
you doing that

00:38:58,090 --> 00:39:04,420
you're doing that because your data

00:39:00,550 --> 00:39:09,190
source is that way your data source

00:39:04,420 --> 00:39:10,720
caters to use cases you're reading from

00:39:09,190 --> 00:39:13,750
it and you're writing to it and turns

00:39:10,720 --> 00:39:17,650
out that normalized relational databases

00:39:13,750 --> 00:39:20,320
are optimized for writing well first of

00:39:17,650 --> 00:39:22,990
all they eliminate redundancy so they

00:39:20,320 --> 00:39:25,060
are optimized for saving space as in

00:39:22,990 --> 00:39:26,140
storage space because memory was

00:39:25,060 --> 00:39:29,380
expensive

00:39:26,140 --> 00:39:31,360
when databases came up nowadays storage

00:39:29,380 --> 00:39:34,180
is not expensive Google stores the whole

00:39:31,360 --> 00:39:36,970
web and even version that version and

00:39:34,180 --> 00:39:38,740
the NSA's stores the whole communication

00:39:36,970 --> 00:39:40,930
on the web and that's probably whatever

00:39:38,740 --> 00:39:46,120
so storage seems to be cheap now these

00:39:40,930 --> 00:39:49,240
days still a database is optimized for

00:39:46,120 --> 00:39:53,710
writing you can change the zip code of

00:39:49,240 --> 00:39:57,340
Berlin changing just one record in a

00:39:53,710 --> 00:40:00,190
normalized database that's great saves

00:39:57,340 --> 00:40:04,770
you a shitload of work versus changing

00:40:00,190 --> 00:40:10,200
the zip code in say a million addresses

00:40:04,770 --> 00:40:13,900
hmm is that a common use case I'd say no

00:40:10,200 --> 00:40:15,910
even if it happens well it can be slow

00:40:13,900 --> 00:40:18,970
it's not a common use case a common use

00:40:15,910 --> 00:40:24,010
case is retrieving data and to retrieve

00:40:18,970 --> 00:40:26,140
data we have to join tables we have

00:40:24,010 --> 00:40:31,450
normalized the database to save space

00:40:26,140 --> 00:40:33,280
and optimize thus for writing because we

00:40:31,450 --> 00:40:36,670
only need to change the information once

00:40:33,280 --> 00:40:39,910
and that update automatically effects a

00:40:36,670 --> 00:40:44,350
bunch of records that link to that but

00:40:39,910 --> 00:40:46,450
we seldomly right if we think in events

00:40:44,350 --> 00:40:51,010
rather than state well events are

00:40:46,450 --> 00:40:52,810
immutable the writing thing becomes a

00:40:51,010 --> 00:40:54,550
whole different story because now we are

00:40:52,810 --> 00:40:59,950
suddenly talking about an append-only

00:40:54,550 --> 00:41:00,700
store it's a log file an event store is

00:40:59,950 --> 00:41:03,910
a log file

00:41:00,700 --> 00:41:08,290
we only append we never change existing

00:41:03,910 --> 00:41:11,320
data so reading is easy to scale but how

00:41:08,290 --> 00:41:15,430
about separate models now if

00:41:11,320 --> 00:41:21,010
we have one piece of data representation

00:41:15,430 --> 00:41:24,070
in one piece of software to both run

00:41:21,010 --> 00:41:29,230
commands do the state changes make

00:41:24,070 --> 00:41:33,790
decisions and deliver content ask answer

00:41:29,230 --> 00:41:36,010
questions well how can we optimize what

00:41:33,790 --> 00:41:40,000
can we should we optimize that software

00:41:36,010 --> 00:41:42,520
it's always a foul compromise same with

00:41:40,000 --> 00:41:44,170
databases now just let's assume for a

00:41:42,520 --> 00:41:46,180
second we would be free of all

00:41:44,170 --> 00:41:48,430
limitation that there existed until this

00:41:46,180 --> 00:41:51,940
point and we'll create two separate

00:41:48,430 --> 00:41:54,100
models for that so we can have one model

00:41:51,940 --> 00:41:55,870
that's optimized for writing we could

00:41:54,100 --> 00:41:58,750
use that event sourcing stuff that I've

00:41:55,870 --> 00:42:02,620
talked about earlier so we have an event

00:41:58,750 --> 00:42:04,930
log in our software can based on this

00:42:02,620 --> 00:42:07,090
event log build business objects that

00:42:04,930 --> 00:42:11,470
make decisions so we got the command

00:42:07,090 --> 00:42:15,690
part covered and actually this is how a

00:42:11,470 --> 00:42:19,630
command looks like surprised it's a DTO

00:42:15,690 --> 00:42:21,970
it's just a data object please

00:42:19,630 --> 00:42:24,940
initialize that counter to this value

00:42:21,970 --> 00:42:29,050
looks very similar to the event but the

00:42:24,940 --> 00:42:31,350
intent is very different a command is

00:42:29,050 --> 00:42:33,880
asking the system to do something

00:42:31,350 --> 00:42:35,860
whether the system does that or not

00:42:33,880 --> 00:42:37,960
depends on the state of the system on

00:42:35,860 --> 00:42:40,840
Monday you cannot create counters so

00:42:37,960 --> 00:42:43,690
there is an exception if a counter gets

00:42:40,840 --> 00:42:46,690
created internally the event that is

00:42:43,690 --> 00:42:49,450
that we've seen before gets created and

00:42:46,690 --> 00:42:52,870
stored now we have created a fact

00:42:49,450 --> 00:42:54,790
so a command is something that you ask

00:42:52,870 --> 00:42:57,070
the system to do something it may or may

00:42:54,790 --> 00:42:59,500
not do that an event is something

00:42:57,070 --> 00:43:05,200
inevitable it has happened we can't undo

00:42:59,500 --> 00:43:08,940
that okay so what about the queries then

00:43:05,200 --> 00:43:13,290
well we have that side down the queries

00:43:08,940 --> 00:43:16,770
if you just deliver content whole day

00:43:13,290 --> 00:43:18,880
how would ideally how would your

00:43:16,770 --> 00:43:22,270
persistence mechanism or how would you

00:43:18,880 --> 00:43:23,559
set up look like I'm gonna tell you what

00:43:22,270 --> 00:43:26,709
it would look like

00:43:23,559 --> 00:43:29,410
you would put HTML files into the file

00:43:26,709 --> 00:43:33,719
system and put us a web server in front

00:43:29,410 --> 00:43:36,719
so that you can serve static files

00:43:33,719 --> 00:43:40,509
that's the fastest thing that's possible

00:43:36,719 --> 00:43:42,009
why would you put the stuff in a

00:43:40,509 --> 00:43:45,249
different format so that you have to

00:43:42,009 --> 00:43:48,400
read it and convert it and then deliver

00:43:45,249 --> 00:43:50,319
the HTML when you can directly deliver

00:43:48,400 --> 00:43:53,680
the HTML or to put that in other words

00:43:50,319 --> 00:43:56,739
you can pre generate your HTML there is

00:43:53,680 --> 00:44:00,549
no reason whatsoever to build your pages

00:43:56,739 --> 00:44:03,039
on request yes I know personalization is

00:44:00,549 --> 00:44:05,259
an issue um it doesn't hurt the general

00:44:03,039 --> 00:44:07,809
concept though you can build most of the

00:44:05,259 --> 00:44:09,519
page statically and you can build the

00:44:07,809 --> 00:44:12,209
building blocks even if they are

00:44:09,519 --> 00:44:15,969
personalized you can build them up front

00:44:12,209 --> 00:44:18,789
so your delivery is just basically

00:44:15,969 --> 00:44:20,589
delivering static data and literally

00:44:18,789 --> 00:44:22,660
there is only basically going to be the

00:44:20,589 --> 00:44:25,119
decision are you allowed to see that and

00:44:22,660 --> 00:44:27,640
if you are allowed to see more than your

00:44:25,119 --> 00:44:29,589
coworker then probably you're gonna see

00:44:27,640 --> 00:44:31,059
one representation of the data and your

00:44:29,589 --> 00:44:34,059
coworker is gonna see a different

00:44:31,059 --> 00:44:37,299
representation of the data this in this

00:44:34,059 --> 00:44:41,910
secure s world is called projections its

00:44:37,299 --> 00:44:46,509
projections of state of data its state

00:44:41,910 --> 00:44:50,609
it's essentially another type of event

00:44:46,509 --> 00:44:52,809
sourcing if we have a stream of events

00:44:50,609 --> 00:44:55,839
we can go through the stream of events

00:44:52,809 --> 00:44:57,429
and create any visual representation

00:44:55,839 --> 00:44:59,709
that we like which can be an HTML page

00:44:57,429 --> 00:45:03,849
or a building block corner HTML page or

00:44:59,709 --> 00:45:07,779
a PDF or whatever and we can put that

00:45:03,849 --> 00:45:09,219
somewhere and when people ask for it we

00:45:07,779 --> 00:45:13,179
can deliver it in a very very

00:45:09,219 --> 00:45:16,509
lightweight fashion that's CQRS

00:45:13,179 --> 00:45:20,679
to its full extent based on the idea of

00:45:16,509 --> 00:45:23,229
creating separate models for the main

00:45:20,679 --> 00:45:26,199
use cases that your application has and

00:45:23,229 --> 00:45:30,420
if you want to go back to solid

00:45:26,199 --> 00:45:33,880
principles what's the s in solid single

00:45:30,420 --> 00:45:35,949
responsibility now if and if there

00:45:33,880 --> 00:45:37,270
should only be one reason for a piece of

00:45:35,949 --> 00:45:39,550
software to change

00:45:37,270 --> 00:45:42,160
now if your piece of software is an

00:45:39,550 --> 00:45:46,060
object and this object does commands and

00:45:42,160 --> 00:45:48,460
queries you have two reasons to change

00:45:46,060 --> 00:45:50,470
the object so you're violating the s in

00:45:48,460 --> 00:45:52,690
solid that's why you have a maintenance

00:45:50,470 --> 00:45:56,080
problem in your software if you build

00:45:52,690 --> 00:45:57,820
two separate models you have less of

00:45:56,080 --> 00:45:59,890
maintenance issues because you can

00:45:57,820 --> 00:46:03,280
evolve those models independently and

00:45:59,890 --> 00:46:05,050
both only depend on the events and they

00:46:03,280 --> 00:46:07,720
don't even know each other there is no

00:46:05,050 --> 00:46:09,730
runtime dependency now you're saying

00:46:07,720 --> 00:46:11,410
well that sounds weird how do you do

00:46:09,730 --> 00:46:13,630
that well it's actually pretty simple

00:46:11,410 --> 00:46:14,370
and here's a code example that's a

00:46:13,630 --> 00:46:17,650
so-called

00:46:14,370 --> 00:46:20,860
dispatcher flow for a projector if an

00:46:17,650 --> 00:46:24,010
event has happened we're gonna look at

00:46:20,860 --> 00:46:26,440
what event is that and then we are going

00:46:24,010 --> 00:46:30,250
to create our projection which in that

00:46:26,440 --> 00:46:33,970
case is a very simple object that just

00:46:30,250 --> 00:46:36,610
builds state it has accountant in even

00:46:33,970 --> 00:46:41,020
count the amount of times it has been

00:46:36,610 --> 00:46:43,390
incremented and I can use this to create

00:46:41,020 --> 00:46:47,290
HTML or any other representation from

00:46:43,390 --> 00:46:51,010
that in a very lightweight fashion so

00:46:47,290 --> 00:46:53,620
that's how the query side works now

00:46:51,010 --> 00:46:55,420
unfortunately we have those 45 minutes

00:46:53,620 --> 00:46:58,450
time slots which is really sucky because

00:46:55,420 --> 00:47:01,120
I'm already over time luckily that's the

00:46:58,450 --> 00:47:01,870
content I've planned for allow me just

00:47:01,120 --> 00:47:06,010
that one

00:47:01,870 --> 00:47:07,660
shameless plug a while I go and I've

00:47:06,010 --> 00:47:09,760
been talking about event sourcing and

00:47:07,660 --> 00:47:12,220
securest for a while at conferences

00:47:09,760 --> 00:47:14,830
people started coming up to me like do

00:47:12,220 --> 00:47:16,690
you have source code I can look at well

00:47:14,830 --> 00:47:18,460
this is the answer there is the source

00:47:16,690 --> 00:47:22,540
code you have been asking for and

00:47:18,460 --> 00:47:24,850
actually I'm in the process of writing

00:47:22,540 --> 00:47:28,390
an e-book on the whole thing which is

00:47:24,850 --> 00:47:30,580
going to be available at this URL you

00:47:28,390 --> 00:47:32,920
can go there now and register with a

00:47:30,580 --> 00:47:36,700
mailing list which probably is not gdpr

00:47:32,920 --> 00:47:40,000
compliant I'm not sure it said it's a

00:47:36,700 --> 00:47:42,250
it's a German mailing list um and I will

00:47:40,000 --> 00:47:43,990
only email you about the book if you're

00:47:42,250 --> 00:47:48,100
interested in that um it's probably

00:47:43,990 --> 00:47:51,160
gonna take me a couple of days to write

00:47:48,100 --> 00:47:53,020
the book but the more people are signed

00:47:51,160 --> 00:47:55,030
for the mailing list and keep bugging me

00:47:53,020 --> 00:47:58,180
with wishes requests and feedback is

00:47:55,030 --> 00:47:59,770
probably gonna encourage me to to work

00:47:58,180 --> 00:48:01,870
through that more and basically the book

00:47:59,770 --> 00:48:04,480
is gonna be based on code examples that

00:48:01,870 --> 00:48:07,390
you've just seen and some more cool

00:48:04,480 --> 00:48:09,310
stuff of course this is where the slides

00:48:07,390 --> 00:48:12,430
are going to be available talks dot the

00:48:09,310 --> 00:48:14,740
PHP dot CC it was my pleasure to be your

00:48:12,430 --> 00:48:17,200
host if you have any questions I'll be

00:48:14,740 --> 00:48:19,780
around for the day and tomorrow I'll

00:48:17,200 --> 00:48:21,580
give another press I'll be giving

00:48:19,780 --> 00:48:23,590
another presentation on design patterns

00:48:21,580 --> 00:48:27,070
tomorrow morning if you're not yet fed

00:48:23,590 --> 00:48:27,780
up with me otherwise thanks for

00:48:27,070 --> 00:48:30,610
listening

00:48:27,780 --> 00:48:35,560
[Applause]

00:48:30,610 --> 00:48:35,560

YouTube URL: https://www.youtube.com/watch?v=p6mKCnS2iHM


