Title: Common Sub Expression Optimization at Facebook
Publication date: 2020-07-08
Playlist: Presto Events
Description: 
	Rongrong Zhong, Software Engineer at Facebook

In complex analytics queries, we often see repeated expressions, for example parsing the same JSON column but extracting different fields, elaborate CASE statement with common predicates and different ones. Previously, Presto will compute the same expression many times as they appear in query. With common sub expression optimization, we would only evaluate the same expression once within the same project operator or filter operator. In our workload, weâ€™ve seen 3x improvements on certain queries with expensive common sub expressions like JSON_PARSE. Microbenchmark also shows a consistent ~10% performance improvement for simple common sub-expressions like x + y. In this talk, we will talk about how this is implemented.
Captions: 
	00:00:00,030 --> 00:00:05,970
I'm a software engineer on Facebook

00:00:02,790 --> 00:00:09,420
Fresno team and today I want to talk

00:00:05,970 --> 00:00:12,620
about a recent optimization we did which

00:00:09,420 --> 00:00:18,869
has common sub-expression optimization

00:00:12,620 --> 00:00:21,000
so the motivation is kind of like with

00:00:18,869 --> 00:00:24,150
some these kind of queries a lot in

00:00:21,000 --> 00:00:27,869
production like I don't know about other

00:00:24,150 --> 00:00:32,369
people pulling facebook here loves using

00:00:27,869 --> 00:00:35,219
JSON because it's very flexible you can

00:00:32,369 --> 00:00:38,180
basically change the data without

00:00:35,219 --> 00:00:40,860
finding schema and everything but

00:00:38,180 --> 00:00:43,829
unfortunately J sound is a very

00:00:40,860 --> 00:00:49,379
expensive operation in terms of data

00:00:43,829 --> 00:00:52,440
base like data manipulation so people

00:00:49,379 --> 00:00:56,340
try to kind of do a better job so they

00:00:52,440 --> 00:00:58,590
don't just do json.parse and json

00:00:56,340 --> 00:01:00,570
extract all the time anymore they try to

00:00:58,590 --> 00:01:02,820
do it is on parts and then cast it to a

00:01:00,570 --> 00:01:07,380
row type and the row is actually quite

00:01:02,820 --> 00:01:10,409
performant so the curry so this is

00:01:07,380 --> 00:01:12,810
actually like a small part of like a

00:01:10,409 --> 00:01:16,710
real query that I'm asked out a lot of

00:01:12,810 --> 00:01:20,340
the names and stuff the actual query

00:01:16,710 --> 00:01:21,659
actually have nine json.parse the the

00:01:20,340 --> 00:01:23,729
whole crew is like probably got

00:01:21,659 --> 00:01:26,220
underlines or something and there's like

00:01:23,729 --> 00:01:27,930
a complex much manipulation after that

00:01:26,220 --> 00:01:31,860
but those are all quite efficient and

00:01:27,930 --> 00:01:33,600
the problem is there's nine JSON person

00:01:31,860 --> 00:01:37,200
in this example there are six to some

00:01:33,600 --> 00:01:39,299
horse and and they are separately like

00:01:37,200 --> 00:01:41,280
the current for how currently presto

00:01:39,299 --> 00:01:44,159
works or like how previously presto

00:01:41,280 --> 00:01:47,130
works the same expression is going to be

00:01:44,159 --> 00:01:49,829
evaluated six times or nine times in the

00:01:47,130 --> 00:01:51,810
original query and json.parse is very

00:01:49,829 --> 00:01:54,840
expensive so as a result the crew

00:01:51,810 --> 00:01:58,680
performance is terrible so if you look

00:01:54,840 --> 00:02:02,159
at the execution plan you will see that

00:01:58,680 --> 00:02:05,490
for this project this looks even more

00:02:02,159 --> 00:02:09,090
weird because try cast doesn't really

00:02:05,490 --> 00:02:11,970
print out the output type so it looks

00:02:09,090 --> 00:02:13,930
exactly the same for repeating six times

00:02:11,970 --> 00:02:15,939
but actually the con

00:02:13,930 --> 00:02:18,879
sub expression here is json.parse

00:02:15,939 --> 00:02:20,950
features and we're casting it to

00:02:18,879 --> 00:02:26,799
different types that's why there are six

00:02:20,950 --> 00:02:29,950
different expressions so obviously we

00:02:26,799 --> 00:02:32,170
want to we don't want to run like these

00:02:29,950 --> 00:02:37,420
six times especially if it's expensive

00:02:32,170 --> 00:02:39,879
right so what can we do so the solution

00:02:37,420 --> 00:02:43,120
well obviously we want to run it only

00:02:39,879 --> 00:02:44,859
once so it's just how how to do it do

00:02:43,120 --> 00:02:46,750
that right so we want to do common

00:02:44,859 --> 00:02:49,239
sub-expression optimization which means

00:02:46,750 --> 00:02:51,879
we want to extract the common

00:02:49,239 --> 00:02:56,799
sub-expression among all the productions

00:02:51,879 --> 00:03:01,349
and run that only once so how it works

00:02:56,799 --> 00:03:05,170
so first let's kind of row back to how

00:03:01,349 --> 00:03:10,120
projection works in facebook not

00:03:05,170 --> 00:03:12,459
impressed though before CSE so basically

00:03:10,120 --> 00:03:15,790
they're kind of like two sides oneness

00:03:12,459 --> 00:03:18,639
when we are processing the query there

00:03:15,790 --> 00:03:23,639
is a class called page function compiler

00:03:18,639 --> 00:03:26,440
and this it actually composed both

00:03:23,639 --> 00:03:28,989
projection and filter but we're talking

00:03:26,440 --> 00:03:31,510
about production here so the input you

00:03:28,989 --> 00:03:34,659
will see that it's a list of productions

00:03:31,510 --> 00:03:37,780
in this case it's six TriCaster from

00:03:34,659 --> 00:03:40,060
parse features the paid function

00:03:37,780 --> 00:03:43,150
compiler takes this and for each

00:03:40,060 --> 00:03:47,799
production it would generate by code it

00:03:43,150 --> 00:03:52,299
will basically generate a class generate

00:03:47,799 --> 00:03:54,370
a java class that's like at runtime you

00:03:52,299 --> 00:03:56,769
will be able to call this class to to

00:03:54,370 --> 00:03:59,919
actually evaluate the production and

00:03:56,769 --> 00:04:02,290
getting results we are iterating through

00:03:59,919 --> 00:04:05,739
all the projections in generate one

00:04:02,290 --> 00:04:07,959
class for each assignment basically so

00:04:05,739 --> 00:04:10,750
for this example you would end up have

00:04:07,959 --> 00:04:13,840
six different classes once you have

00:04:10,750 --> 00:04:17,199
these all compiled and generated and at

00:04:13,840 --> 00:04:20,650
runtime page the the project operator

00:04:17,199 --> 00:04:23,020
would take a page and try to invoke

00:04:20,650 --> 00:04:25,810
these functions on a given page and then

00:04:23,020 --> 00:04:28,090
write the output to the output page so I

00:04:25,810 --> 00:04:30,700
would see the first

00:04:28,090 --> 00:04:33,820
production is taking the input and right

00:04:30,700 --> 00:04:36,070
to the first column of the output and

00:04:33,820 --> 00:04:37,900
the second would be processing and right

00:04:36,070 --> 00:04:40,810
to the second column vice versa and I've

00:04:37,900 --> 00:04:45,580
done going forward until the sixth one

00:04:40,810 --> 00:04:47,920
in this example so now we can see the

00:04:45,580 --> 00:04:51,460
problem here because there are six

00:04:47,920 --> 00:04:53,350
separate classes and the basically don't

00:04:51,460 --> 00:04:55,630
share any common Co path that's why I

00:04:53,350 --> 00:04:56,950
like even though intuitively people

00:04:55,630 --> 00:05:00,520
might be thinking that we're actually

00:04:56,950 --> 00:05:03,760
doing it we're not and it's it's it

00:05:00,520 --> 00:05:08,190
needs actual like a refactoring to to be

00:05:03,760 --> 00:05:14,650
able to do this so yeah that's basically

00:05:08,190 --> 00:05:17,530
what we did and so first thing we did is

00:05:14,650 --> 00:05:20,890
we basically say that okay we cannot

00:05:17,530 --> 00:05:26,470
generate one class per production that's

00:05:20,890 --> 00:05:28,240
try to take these all these expressions

00:05:26,470 --> 00:05:30,910
as a whole and analyze them and

00:05:28,240 --> 00:05:33,070
generates a page projection that can

00:05:30,910 --> 00:05:39,850
produce more output see instead of only

00:05:33,070 --> 00:05:43,960
one output and so inside it this is how

00:05:39,850 --> 00:05:46,510
how it works so first when we take all

00:05:43,960 --> 00:05:48,940
the productions in will try to analyze

00:05:46,510 --> 00:05:53,020
and extract all the comments of

00:05:48,940 --> 00:05:55,780
expressions and we're gonna after we

00:05:53,020 --> 00:05:58,590
have all the set of sub expressions what

00:05:55,780 --> 00:06:01,060
divided the projection by groups of

00:05:58,590 --> 00:06:05,220
common dependencies of piece of

00:06:01,060 --> 00:06:09,820
expression so in the given example

00:06:05,220 --> 00:06:11,560
basically what we have is all the

00:06:09,820 --> 00:06:13,590
productions depend on trees and parse

00:06:11,560 --> 00:06:16,120
which is the comments of the expression

00:06:13,590 --> 00:06:19,000
so they would all end up be in the same

00:06:16,120 --> 00:06:21,070
group so compile this whole group into a

00:06:19,000 --> 00:06:24,280
single class instead of six separate

00:06:21,070 --> 00:06:27,460
classes and how do we generate the by

00:06:24,280 --> 00:06:29,740
code for each common sub-expression what

00:06:27,460 --> 00:06:32,410
does generate a function and then we

00:06:29,740 --> 00:06:36,190
would rewrite the projection with the

00:06:32,410 --> 00:06:39,880
function so instead of coding json.parse

00:06:36,190 --> 00:06:41,260
will call the function that they get is

00:06:39,880 --> 00:06:45,340
on will generate a get

00:06:41,260 --> 00:06:48,280
and then all these other expressions

00:06:45,340 --> 00:06:51,250
will be rewritten to try cast gadgets on

00:06:48,280 --> 00:06:55,570
press function you would say that well

00:06:51,250 --> 00:06:57,670
we are still calling six times yes so

00:06:55,570 --> 00:07:00,250
that's kind of wrapped inside of this

00:06:57,670 --> 00:07:02,800
function so we name this function what

00:07:00,250 --> 00:07:07,590
we do is we basically introduce the flag

00:07:02,800 --> 00:07:09,190
and the results so when the

00:07:07,590 --> 00:07:12,550
implementations the function is

00:07:09,190 --> 00:07:15,340
basically is this computed if not unless

00:07:12,550 --> 00:07:19,030
computed otherwise just return the store

00:07:15,340 --> 00:07:20,710
results and that way at runtime we would

00:07:19,030 --> 00:07:22,480
know that if it is not computed it all

00:07:20,710 --> 00:07:23,920
comes so basically the first time this

00:07:22,480 --> 00:07:25,870
function is called it will compute the

00:07:23,920 --> 00:07:31,150
results and all subsequent call would

00:07:25,870 --> 00:07:35,020
ask at the reference yeah so for that

00:07:31,150 --> 00:07:37,090
that was I this is my kind of like the

00:07:35,020 --> 00:07:40,870
poster child example of like you got

00:07:37,090 --> 00:07:43,210
really a lot of benefit with actually

00:07:40,870 --> 00:07:45,100
like the whole algorithm doesn't even

00:07:43,210 --> 00:07:47,080
need to work well to be able to handle

00:07:45,100 --> 00:07:49,210
this case it's very simple there's only

00:07:47,080 --> 00:07:51,970
one CSE and everything is combined in a

00:07:49,210 --> 00:07:56,440
group but let's see a slightly more

00:07:51,970 --> 00:07:59,200
complicated example as in expressions

00:07:56,440 --> 00:08:01,720
dependencies even though the data is

00:07:59,200 --> 00:08:05,290
actually quite common quite simple so

00:08:01,720 --> 00:08:11,740
this we have one two three four five

00:08:05,290 --> 00:08:16,030
five productions X plus y plus D X plus

00:08:11,740 --> 00:08:19,090
y times C and then the same X plus y

00:08:16,030 --> 00:08:22,120
plus C times 2 and then cost the same as

00:08:19,090 --> 00:08:29,710
well car and then times 2 times C so

00:08:22,120 --> 00:08:32,760
there are few so one thing is X plus y

00:08:29,710 --> 00:08:35,280
times D doesn't share any common

00:08:32,760 --> 00:08:37,900
sub-expression with any other

00:08:35,280 --> 00:08:41,919
projections so that would be one group

00:08:37,900 --> 00:08:44,110
and all the other ones depend on X plus

00:08:41,919 --> 00:08:48,130
one plus D so all the other ones would

00:08:44,110 --> 00:08:49,630
be in another group and in this group

00:08:48,130 --> 00:08:51,250
there's actually two common

00:08:49,630 --> 00:08:51,580
sub-expressions that depends on each

00:08:51,250 --> 00:08:55,180
other

00:08:51,580 --> 00:08:57,910
the first one is x plus y plus c

00:08:55,180 --> 00:08:59,770
and notice that we actually there's

00:08:57,910 --> 00:09:03,149
actually another one that's X plus one

00:08:59,770 --> 00:09:06,460
but we kind of optimized that out

00:09:03,149 --> 00:09:10,450
because no expression depends directly

00:09:06,460 --> 00:09:13,450
on X plus y the at least depend on X

00:09:10,450 --> 00:09:14,950
plus y plus C so we don't need to

00:09:13,450 --> 00:09:17,410
generate a separate function because

00:09:14,950 --> 00:09:20,350
function also has overhead so we don't

00:09:17,410 --> 00:09:22,709
generate a function for X plus y which

00:09:20,350 --> 00:09:26,680
is directly generate X plus y plus C and

00:09:22,709 --> 00:09:29,580
then the other one is X plus y plus C

00:09:26,680 --> 00:09:34,180
times two so this depends on the first

00:09:29,580 --> 00:09:36,760
CSC so it basically would invoke the

00:09:34,180 --> 00:09:40,000
function for the first one to get the

00:09:36,760 --> 00:09:41,680
results and compute its results and then

00:09:40,000 --> 00:09:43,660
we would have rewrite all the

00:09:41,680 --> 00:09:45,580
projections in terms of the first one

00:09:43,660 --> 00:09:47,410
would be just the first common

00:09:45,580 --> 00:09:50,310
sub-expression and the second one is

00:09:47,410 --> 00:09:53,050
just the second common sub-expression

00:09:50,310 --> 00:09:55,120
the third one is casting the first one

00:09:53,050 --> 00:09:57,700
to work hard and the first one is the

00:09:55,120 --> 00:09:59,500
second one times C so that kind of like

00:09:57,700 --> 00:10:03,060
so even if you have a dependency tree

00:09:59,500 --> 00:10:08,190
you can still about see I see this way

00:10:03,060 --> 00:10:11,320
so let's see some results there is a

00:10:08,190 --> 00:10:13,630
common sub-expression benchmark as a

00:10:11,320 --> 00:10:16,990
micro benchmark that's shipped together

00:10:13,630 --> 00:10:21,970
with the code we did some very very

00:10:16,990 --> 00:10:24,940
simple benchmarking so here for bit into

00:10:21,970 --> 00:10:27,610
it basically did X plus y I think for

00:10:24,940 --> 00:10:30,880
work harwood basically didn't like the

00:10:27,610 --> 00:10:34,930
marker version of X plus y and Jason is

00:10:30,880 --> 00:10:40,890
very simple to some parts with a and B

00:10:34,930 --> 00:10:46,029
as like like a1 b2 kind of like simple

00:10:40,890 --> 00:10:49,930
binary pair and we can see that across

00:10:46,029 --> 00:10:52,329
the board there's at least 10 10%

00:10:49,930 --> 00:10:55,870
performance improvements even on a very

00:10:52,329 --> 00:10:59,020
simple like if I have X plus y and

00:10:55,870 --> 00:11:03,400
another expression that depends on X

00:10:59,020 --> 00:11:06,490
plus y so just by doing this on a very

00:11:03,400 --> 00:11:08,830
simple expression we can still get some

00:11:06,490 --> 00:11:11,290
benefit this is a trick

00:11:08,830 --> 00:11:14,890
my major concern because like we were

00:11:11,290 --> 00:11:20,280
thinking about how to support this it's

00:11:14,890 --> 00:11:25,360
actually very hard to quantify exactly

00:11:20,280 --> 00:11:27,760
how expensive operations are and if you

00:11:25,360 --> 00:11:30,400
have a common sub-expression solution

00:11:27,760 --> 00:11:32,770
that only works for very expensive

00:11:30,400 --> 00:11:34,540
operations and not working and so

00:11:32,770 --> 00:11:40,020
basically if we introduce a regression

00:11:34,540 --> 00:11:43,240
on very very simple expressions then

00:11:40,020 --> 00:11:46,480
it's actually very hard to roll it out

00:11:43,240 --> 00:11:48,550
or very far clean about it by default so

00:11:46,480 --> 00:11:53,830
basically it would be opting instead of

00:11:48,550 --> 00:11:56,080
 out so that's kind of partly why we

00:11:53,830 --> 00:11:58,780
decided to do it in microgeneration

00:11:56,080 --> 00:12:03,030
because in Biogen originals we do it

00:11:58,780 --> 00:12:05,950
it's very unlikely to introduce large

00:12:03,030 --> 00:12:08,410
regressions if you do a planned

00:12:05,950 --> 00:12:10,720
challenge then like you potentially

00:12:08,410 --> 00:12:13,390
would introduce additional operators or

00:12:10,720 --> 00:12:15,520
additional page from true realization

00:12:13,390 --> 00:12:17,110
and stuff then it's harder to tell

00:12:15,520 --> 00:12:21,550
whether you would definitely need to

00:12:17,110 --> 00:12:22,840
give us a benefit or not so for the

00:12:21,550 --> 00:12:25,840
json.parse

00:12:22,840 --> 00:12:28,360
the original query with the 90s on first

00:12:25,840 --> 00:12:30,970
we that kind of query we do see three

00:12:28,360 --> 00:12:34,660
explains also I mean this is basically

00:12:30,970 --> 00:12:38,140
like if your crease major computers

00:12:34,660 --> 00:12:40,570
spend it on these very expensive kind of

00:12:38,140 --> 00:12:44,560
operations like parsing JSON or records

00:12:40,570 --> 00:12:48,460
match these very expensive functions

00:12:44,560 --> 00:12:50,710
then your performance is going to just

00:12:48,460 --> 00:12:53,560
be like dividing how many times you're

00:12:50,710 --> 00:12:55,810
invoking the them two to the times of

00:12:53,560 --> 00:12:57,490
being location right right so it's only

00:12:55,810 --> 00:12:59,530
three acts performance game for that

00:12:57,490 --> 00:13:02,230
word because it does a bunch of other

00:12:59,530 --> 00:13:03,880
processing as well if it's only doing a

00:13:02,230 --> 00:13:09,730
some first nine times it might be even

00:13:03,880 --> 00:13:15,450
better so what are the downside we do

00:13:09,730 --> 00:13:21,460
actually see some regressions with this

00:13:15,450 --> 00:13:22,690
so one thing we see is that if you just

00:13:21,460 --> 00:13:25,750
end up with

00:13:22,690 --> 00:13:28,330
a hundred expressions depending on the

00:13:25,750 --> 00:13:34,210
same or like if you have like a hundred

00:13:28,330 --> 00:13:36,730
productions depend on some CSE compile

00:13:34,210 --> 00:13:40,210
them into the same class basically means

00:13:36,730 --> 00:13:42,160
you get a bigger class and that at

00:13:40,210 --> 00:13:45,660
certain point can potentially trigger

00:13:42,160 --> 00:13:48,730
like large bytecode compiler failure

00:13:45,660 --> 00:13:50,980
this we kind of introduced the

00:13:48,730 --> 00:13:53,350
mitigation as so like originally our

00:13:50,980 --> 00:13:56,440
implementation is pretty naive as we

00:13:53,350 --> 00:13:58,390
just partition the production's into the

00:13:56,440 --> 00:14:00,550
ones that depend on CSE and the ones

00:13:58,390 --> 00:14:03,150
that don't and we compile everything

00:14:00,550 --> 00:14:06,880
that depends on any CSE into one class

00:14:03,150 --> 00:14:10,960
so after we see that basically say okay

00:14:06,880 --> 00:14:14,710
let's just partition the projections by

00:14:10,960 --> 00:14:17,740
CSE so only the projections that depends

00:14:14,710 --> 00:14:19,720
on the same set of common

00:14:17,740 --> 00:14:22,780
sub-expressions will become POW in the

00:14:19,720 --> 00:14:25,060
same class well that still doesn't quite

00:14:22,780 --> 00:14:28,090
cut it because I think especially for

00:14:25,060 --> 00:14:30,310
some tableau generator or whatever like

00:14:28,090 --> 00:14:32,880
you you still have like I don't know 50

00:14:30,310 --> 00:14:36,700
projections that depend on the same CSE

00:14:32,880 --> 00:14:39,400
so and then we also actually see a

00:14:36,700 --> 00:14:42,130
similar problem I mean I the problem is

00:14:39,400 --> 00:14:47,110
it's triggered by similar features which

00:14:42,130 --> 00:14:48,790
is that when the function is we think is

00:14:47,110 --> 00:14:51,100
because the function is large but

00:14:48,790 --> 00:14:54,820
basically the behavior of what we that

00:14:51,100 --> 00:14:57,850
we see is that if you have like more

00:14:54,820 --> 00:14:59,890
than 20 projections for example if you

00:14:57,850 --> 00:15:03,310
combine more than 20 expert productions

00:14:59,890 --> 00:15:05,530
into the same class and generate one

00:15:03,310 --> 00:15:09,130
class for that and run that somehow

00:15:05,530 --> 00:15:12,370
there is a wartime regression it doesn't

00:15:09,130 --> 00:15:14,320
always end up with the CPU regression

00:15:12,370 --> 00:15:19,480
but it always end up with the wartime

00:15:14,320 --> 00:15:22,810
regression we suspect it's because maybe

00:15:19,480 --> 00:15:27,310
the code cache or or something related

00:15:22,810 --> 00:15:30,190
to that I did already dip into it but we

00:15:27,310 --> 00:15:33,850
basically decided that would some micro

00:15:30,190 --> 00:15:35,890
benchmarking that's ten projections for

00:15:33,850 --> 00:15:36,610
group is pretty safe so we basically

00:15:35,890 --> 00:15:38,470
arbitrary

00:15:36,610 --> 00:15:41,860
say that will try to partition the

00:15:38,470 --> 00:15:44,649
projections by CFE but we'll keep it

00:15:41,860 --> 00:15:47,670
kappa attend if it's more than ten just

00:15:44,649 --> 00:15:50,529
split into two groups or more groups if

00:15:47,670 --> 00:15:53,260
necessary that way I mean within this

00:15:50,529 --> 00:15:55,240
group you still get benefit of CSE but

00:15:53,260 --> 00:15:58,360
then you don't need to pay the Waterbury

00:15:55,240 --> 00:16:01,209
question if anybody is interested in

00:15:58,360 --> 00:16:04,950
help us looking to why or what actually

00:16:01,209 --> 00:16:10,620
caused this let us know I would love to

00:16:04,950 --> 00:16:15,700
get the bottom but like mostly by

00:16:10,620 --> 00:16:18,550
partitioning projections and limited to

00:16:15,700 --> 00:16:22,089
ten projections per group both of the

00:16:18,550 --> 00:16:24,160
problems largely go away and if you

00:16:22,089 --> 00:16:26,050
still have an issue and there is a

00:16:24,160 --> 00:16:29,079
session property you can turn this off

00:16:26,050 --> 00:16:30,910
it's quite important it's optimized

00:16:29,079 --> 00:16:34,470
common sub-expressions just set it to

00:16:30,910 --> 00:16:34,470
false and that would turn it off

00:16:36,180 --> 00:16:42,670
so well like obviously common

00:16:40,029 --> 00:16:45,810
sub-expressions just doesn't just exist

00:16:42,670 --> 00:16:49,540
in production they also exist in water

00:16:45,810 --> 00:16:52,380
like the one simple example is X plus y

00:16:49,540 --> 00:16:56,230
is larger than ten and smaller than 100

00:16:52,380 --> 00:17:00,430
and that X plus y has might be repeated

00:16:56,230 --> 00:17:02,920
twice there are some like more like Co

00:17:00,430 --> 00:17:06,939
alluded really complex January sorter

00:17:02,920 --> 00:17:10,990
things that would have like if something

00:17:06,939 --> 00:17:13,480
is larger than zero and or or and Lord

00:17:10,990 --> 00:17:16,360
is a zero and or something else these

00:17:13,480 --> 00:17:19,829
kind of situations that happens a lot in

00:17:16,360 --> 00:17:23,439
complex career logic so it's also

00:17:19,829 --> 00:17:27,120
beneficial to do the same voter photo

00:17:23,439 --> 00:17:29,410
exactly just a simpler case for for

00:17:27,120 --> 00:17:33,270
compared to projection because photo

00:17:29,410 --> 00:17:36,340
would always have and most one

00:17:33,270 --> 00:17:39,640
expression so there it's it's basically

00:17:36,340 --> 00:17:42,130
one one expression you are trying to

00:17:39,640 --> 00:17:47,669
find the common expression within that

00:17:42,130 --> 00:17:50,440
one gigantic expression so yeah and

00:17:47,669 --> 00:17:53,230
what's next

00:17:50,440 --> 00:17:57,850
so we basically only have done this in

00:17:53,230 --> 00:18:00,970
page function processor which is used

00:17:57,850 --> 00:18:05,850
when the input is a presto page and

00:18:00,970 --> 00:18:11,230
that's the case for all the like

00:18:05,850 --> 00:18:13,570
non-leaf product or any product that's

00:18:11,230 --> 00:18:17,530
not directly on top of scan would all

00:18:13,570 --> 00:18:19,990
use page page function processor feed

00:18:17,530 --> 00:18:23,890
function compiler as it covers most of

00:18:19,990 --> 00:18:26,890
the cases are interestingly with Aria

00:18:23,890 --> 00:18:32,860
scan we've been trying to push more

00:18:26,890 --> 00:18:35,830
complex logic to scan which exposed us

00:18:32,860 --> 00:18:37,810
to this problem that some expression

00:18:35,830 --> 00:18:40,330
that we pushed down to scan can be quite

00:18:37,810 --> 00:18:44,980
complex and still have common

00:18:40,330 --> 00:18:47,350
expressions as a result so we also want

00:18:44,980 --> 00:18:49,600
to do this in cursor processor compiler

00:18:47,350 --> 00:18:51,100
unfortunately also basically the

00:18:49,600 --> 00:18:52,900
difference between page function

00:18:51,100 --> 00:18:57,340
compiler and cursor processor compiler

00:18:52,900 --> 00:18:59,710
is the input is a page as it's a column

00:18:57,340 --> 00:19:03,370
oriented format the Presto page is

00:18:59,710 --> 00:19:06,340
basically grouped organized by column

00:19:03,370 --> 00:19:09,070
blocks and the cursor processor compiler

00:19:06,340 --> 00:19:12,850
because it can kind more into the

00:19:09,070 --> 00:19:16,360
connector and the data so a lot of the

00:19:12,850 --> 00:19:19,360
connector have it as a record oriented

00:19:16,360 --> 00:19:21,820
so it's a role or in table format that's

00:19:19,360 --> 00:19:23,650
why I like the functional API it's are

00:19:21,820 --> 00:19:26,520
slightly different so their third there

00:19:23,650 --> 00:19:32,650
the the code are generally separating

00:19:26,520 --> 00:19:36,340
yeah so this is I think like a lot of

00:19:32,650 --> 00:19:41,380
the code are already out in 235 there

00:19:36,340 --> 00:19:46,300
are some bug fixes and improvements 13

00:19:41,380 --> 00:19:51,340
to 36 so you can already start using it

00:19:46,300 --> 00:19:54,370
and if you see any problems just let us

00:19:51,340 --> 00:19:58,450
know create an issue or like peanuts or

00:19:54,370 --> 00:20:02,340
slack or or anything yeah that's all of

00:19:58,450 --> 00:20:02,340
my talks any questions

00:20:06,110 --> 00:20:11,180
I see a couple of questions when alongs

00:20:08,300 --> 00:20:15,560
met me lead among the first question is

00:20:11,180 --> 00:20:18,470
from Devesh from data bricks so david

00:20:15,560 --> 00:20:20,660
says this is really cool but i dint

00:20:18,470 --> 00:20:23,780
fully understand why this was done at

00:20:20,660 --> 00:20:27,140
the page function compiler verses and

00:20:23,780 --> 00:20:29,150
analysis and planning time is it because

00:20:27,140 --> 00:20:32,030
the overhead of the additional buffering

00:20:29,150 --> 00:20:34,670
you would need to implement the comments

00:20:32,030 --> 00:20:39,440
of sub-expression optimization Thanks

00:20:34,670 --> 00:20:41,480
yes so that is one of the reason so

00:20:39,440 --> 00:20:45,190
there are actually two reasons one with

00:20:41,480 --> 00:20:45,190
third thing

00:20:51,360 --> 00:20:54,590
still planner and Alma

00:20:55,220 --> 00:21:00,740
it was kind of assumed a certain orders

00:20:57,830 --> 00:21:02,900
right like if we do it in the planner we

00:21:00,740 --> 00:21:06,440
have to do it at the end of career

00:21:02,900 --> 00:21:09,049
planning pretty much because certain

00:21:06,440 --> 00:21:11,929
optimization rules will try to enroll

00:21:09,049 --> 00:21:13,700
like basically if you do it at planning

00:21:11,929 --> 00:21:16,039
you're breaking our production into

00:21:13,700 --> 00:21:19,159
multiple productions depending on each

00:21:16,039 --> 00:21:20,809
other and you at the same time you might

00:21:19,159 --> 00:21:23,750
have organization rules best try to

00:21:20,809 --> 00:21:26,679
inline them because the aligning can

00:21:23,750 --> 00:21:29,809
potentially push down things further so

00:21:26,679 --> 00:21:31,100
the rules actually don't necessarily

00:21:29,809 --> 00:21:33,169
work with each other so you have to

00:21:31,100 --> 00:21:35,419
figure out what's what's the order of

00:21:33,169 --> 00:21:38,330
applying the rules and so this safe

00:21:35,419 --> 00:21:40,220
place is towards the end that's kind of

00:21:38,330 --> 00:21:42,260
so if it's towards the end then you

00:21:40,220 --> 00:21:45,289
pretty much only work with being a

00:21:42,260 --> 00:21:48,470
product and you don't really have this

00:21:45,289 --> 00:21:52,220
like overall like global view of things

00:21:48,470 --> 00:21:54,440
anymore and then like the second is

00:21:52,220 --> 00:21:57,080
basically if we're breaking into

00:21:54,440 --> 00:21:58,970
multiple product then in between

00:21:57,080 --> 00:22:01,039
projections you're basically writing it

00:21:58,970 --> 00:22:04,120
into a page and radio out of a page

00:22:01,039 --> 00:22:07,340
again so there are over hats to that

00:22:04,120 --> 00:22:12,350
yeah so both of these and another thing

00:22:07,340 --> 00:22:17,590
is we wanted to do this as part of like

00:22:12,350 --> 00:22:17,590
the commitment in response for

00:22:21,510 --> 00:22:27,030
fast and we figured that if we do it in

00:22:24,630 --> 00:22:29,130
quite cogeneration it either works or it

00:22:27,030 --> 00:22:31,380
doesn't work it's very unlikely to

00:22:29,130 --> 00:22:34,410
trigger some like corner case that like

00:22:31,380 --> 00:22:36,600
weird box because normally by code

00:22:34,410 --> 00:22:37,430
generation bugs tend to surface them

00:22:36,600 --> 00:22:46,470
pretty quickly

00:22:37,430 --> 00:22:50,670
that's our Oracle sirs question is from

00:22:46,470 --> 00:22:53,400
Karthik from uber Karthik asks do you DF

00:22:50,670 --> 00:22:57,540
are you deals also considered for common

00:22:53,400 --> 00:23:03,800
sub-expression evaluation yes

00:22:57,540 --> 00:23:13,020
so in general all the operators or

00:23:03,800 --> 00:23:14,060
functions and if we're talking about the

00:23:13,020 --> 00:23:18,120
[Music]

00:23:14,060 --> 00:23:22,920
Seco UDF's Seco UDF's are also compiled

00:23:18,120 --> 00:23:25,670
or handled with being the engine so yeah

00:23:22,920 --> 00:23:30,530
that would also be considered as like

00:23:25,670 --> 00:23:33,120
yeah so if you depend on the same Seco

00:23:30,530 --> 00:23:40,470
function then that sequel function would

00:23:33,120 --> 00:23:42,030
only be called once whoo so I see no

00:23:40,470 --> 00:23:45,180
more questions but I have one question

00:23:42,030 --> 00:23:49,310
from my side so you mentioned briefly

00:23:45,180 --> 00:23:54,060
that you folks are also considering

00:23:49,310 --> 00:23:56,760
updating it in the on scan operator also

00:23:54,060 --> 00:23:59,280
rate in the collector class so do you

00:23:56,760 --> 00:24:01,470
have any idea on when you guys might be

00:23:59,280 --> 00:24:12,080
able to put something out into open

00:24:01,470 --> 00:24:15,150
source yes I hope I hope sometime soon

00:24:12,080 --> 00:24:17,370
it's like it's actually not hard to do

00:24:15,150 --> 00:24:21,540
so if anybody in the community is

00:24:17,370 --> 00:24:23,460
interested in doing this the the cursor

00:24:21,540 --> 00:24:25,140
processor compiler and the page function

00:24:23,460 --> 00:24:26,810
compiler if you look at them the

00:24:25,140 --> 00:24:29,250
implementation are quite similar

00:24:26,810 --> 00:24:31,650
it's the there they're two different

00:24:29,250 --> 00:24:35,370
functions because the api's are

00:24:31,650 --> 00:24:37,350
different so basically how like

00:24:35,370 --> 00:24:38,850
projector operator invoke them are

00:24:37,350 --> 00:24:41,720
different because the dictate our data

00:24:38,850 --> 00:24:43,950
layout is different but the actual

00:24:41,720 --> 00:24:46,200
compilation of the code is the same so

00:24:43,950 --> 00:24:49,559
basically we just need to hook the same

00:24:46,200 --> 00:24:55,800
logic into a different API so it's not a

00:24:49,559 --> 00:24:58,980
lot of work so I'm inclined to have

00:24:55,800 --> 00:25:01,740
someone else working on it right now

00:24:58,980 --> 00:25:04,320
because it's a good opportunity to

00:25:01,740 --> 00:25:08,850
actually learn about my code generation

00:25:04,320 --> 00:25:11,190
and ramp up on presto so we were hoping

00:25:08,850 --> 00:25:14,190
to kind of give it to a new team member

00:25:11,190 --> 00:25:17,280
or if anybody in the community want to

00:25:14,190 --> 00:25:20,130
learn about buy code we also welcome

00:25:17,280 --> 00:25:23,100
their contributor on that you just talk

00:25:20,130 --> 00:25:24,780
to me we can work on that awesome

00:25:23,100 --> 00:25:26,100
that's great long run I think that's a

00:25:24,780 --> 00:25:27,500
great approach to this I think if

00:25:26,100 --> 00:25:30,210
somebody else can take this on

00:25:27,500 --> 00:25:33,500
definitely be able to contribution to

00:25:30,210 --> 00:25:35,370
the community so I think that's it for

00:25:33,500 --> 00:25:39,179
questions and answers today

00:25:35,370 --> 00:25:42,600
thank you all for joining us for a meter

00:25:39,179 --> 00:25:45,170
per day thanks to both our speakers when

00:25:42,600 --> 00:25:49,200
I mean wrong now these are great talks

00:25:45,170 --> 00:25:50,850
we have accorded them and if you are if

00:25:49,200 --> 00:25:53,460
your colleagues are unable to attend it

00:25:50,850 --> 00:25:55,980
or if you yourself want to review this

00:25:53,460 --> 00:25:58,170
again we will be putting out a record in

00:25:55,980 --> 00:26:02,190
in the next few days please keep an eye

00:25:58,170 --> 00:26:05,490
on the water page also if you have any

00:26:02,190 --> 00:26:09,120
other topics that you want to hear about

00:26:05,490 --> 00:26:11,190
from fresh to our engineers please share

00:26:09,120 --> 00:26:14,040
that to us on the meter page and we'll

00:26:11,190 --> 00:26:16,170
try to see if we can arrange some talks

00:26:14,040 --> 00:26:19,290
in those topics in our subsequent

00:26:16,170 --> 00:26:21,630
meetups thanks again everybody thanks

00:26:19,290 --> 00:26:23,940
for joining us and hope to see you all

00:26:21,630 --> 00:26:26,960
soon in our next Meetup have a great

00:26:23,940 --> 00:26:26,960

YouTube URL: https://www.youtube.com/watch?v=7TMj5412dQc


