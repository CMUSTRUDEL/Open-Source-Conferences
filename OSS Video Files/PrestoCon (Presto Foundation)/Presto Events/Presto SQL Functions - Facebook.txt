Title: Presto SQL Functions - Facebook
Publication date: 2020-07-08
Playlist: Presto Events
Description: 
	Rongrong Zhong, Software Engineer at Facebook

Better function support, including support for user defined SQL functions, and user defined Java functions thatâ€™s independent from Presto release and distribution, have been long term community requests. In this talk we will show how to use the recently introduced SQL function feature, how it works, and the ongoing work to support invoking arbitrary functions remotely with remote UDF server.
Captions: 
	00:00:00,000 --> 00:00:07,230
hi everybody my name is Roma I'm a

00:00:03,799 --> 00:00:10,139
software engineer working on trust oh in

00:00:07,230 --> 00:00:11,400
Facebook and today I will be talking

00:00:10,139 --> 00:00:14,070
about

00:00:11,400 --> 00:00:16,590
presto circle functions and in general

00:00:14,070 --> 00:00:22,800
function supporting presto

00:00:16,590 --> 00:00:24,930
so first off big news stick we invoked

00:00:22,800 --> 00:00:28,109
function is actually available in France

00:00:24,930 --> 00:00:30,660
note we use if you use the latest

00:00:28,109 --> 00:00:35,870
version of presto I think it's probably

00:00:30,660 --> 00:00:40,770
available since 231 - but we are doing

00:00:35,870 --> 00:00:42,899
improvements every release still and so

00:00:40,770 --> 00:00:44,129
there would be potentially changes and

00:00:42,899 --> 00:00:46,980
potentially not backward-compatible

00:00:44,129 --> 00:00:49,320
changes so if you're brave enough you

00:00:46,980 --> 00:00:51,510
can give it a try I think it's mostly

00:00:49,320 --> 00:00:54,539
stable now we are probably still gonna

00:00:51,510 --> 00:00:59,930
do some small features about fixes if

00:00:54,539 --> 00:01:02,969
you have any issues let us know so I

00:00:59,930 --> 00:01:06,360
will talk in detail about how to use

00:01:02,969 --> 00:01:09,360
this later and we are also working on

00:01:06,360 --> 00:01:12,090
trying to support remote functions this

00:01:09,360 --> 00:01:14,700
is basically the case that what there

00:01:12,090 --> 00:01:16,170
are some java functions or like even if

00:01:14,700 --> 00:01:19,500
you want to write draw a function or

00:01:16,170 --> 00:01:22,799
write a function there are some cases

00:01:19,500 --> 00:01:26,009
that is not safe to run it in presto

00:01:22,799 --> 00:01:28,560
because for example it's calling

00:01:26,009 --> 00:01:31,650
external service alright it's it's too

00:01:28,560 --> 00:01:33,990
slow or it's like too expensive for all

00:01:31,650 --> 00:01:36,030
these kind of eases or there might be

00:01:33,990 --> 00:01:38,880
cases that you have some business logic

00:01:36,030 --> 00:01:40,259
written in other languages that what we

00:01:38,880 --> 00:01:43,590
just can't run them ugbm

00:01:40,259 --> 00:01:46,920
so that's what we're trying to solve

00:01:43,590 --> 00:01:49,140
so agenda today of talking detail about

00:01:46,920 --> 00:01:52,439
if you want to try a sequel function how

00:01:49,140 --> 00:01:54,659
to set it up and how to use it and give

00:01:52,439 --> 00:01:57,240
an update on the remote function support

00:01:54,659 --> 00:02:02,130
and let me know if you have any

00:01:57,240 --> 00:02:04,049
questions ok how to set it up there is

00:02:02,130 --> 00:02:08,160
arced actually under there is

00:02:04,049 --> 00:02:12,170
documentation in the online dogs how to

00:02:08,160 --> 00:02:13,950
set up function names base managers I'll

00:02:12,170 --> 00:02:15,959
talk later

00:02:13,950 --> 00:02:18,360
well what is from turning space manager

00:02:15,959 --> 00:02:21,209
and what is a function names days but

00:02:18,360 --> 00:02:23,430
here's the link and I basically took a

00:02:21,209 --> 00:02:26,250
screenshot it's quite easy to set it up

00:02:23,430 --> 00:02:29,760
one thing it the default implementation

00:02:26,250 --> 00:02:32,459
of a function namespace manager requires

00:02:29,760 --> 00:02:33,989
a messy code database server so if you

00:02:32,459 --> 00:02:37,770
want to use this version you need to

00:02:33,989 --> 00:02:40,100
have my sequel available if you want to

00:02:37,770 --> 00:02:43,110
have a additional implementation

00:02:40,100 --> 00:02:45,030
function name space manager is somewhat

00:02:43,110 --> 00:02:48,140
similar to a connector API as a

00:02:45,030 --> 00:02:51,150
different API if you implement this API

00:02:48,140 --> 00:02:52,950
in a plugin you can have a different

00:02:51,150 --> 00:02:55,620
implementation of this as well I

00:02:52,950 --> 00:02:58,680
basically kind of need to wrap up like

00:02:55,620 --> 00:03:00,450
you need to have an external storage to

00:02:58,680 --> 00:03:02,910
store your function implementations and

00:03:00,450 --> 00:03:07,319
function metadata because this will not

00:03:02,910 --> 00:03:11,040
be part of the Presto code base so quite

00:03:07,319 --> 00:03:14,299
easy to set up you need to specify what

00:03:11,040 --> 00:03:16,709
are the function namespaces this

00:03:14,299 --> 00:03:20,609
function namespace manager is supporting

00:03:16,709 --> 00:03:25,620
and which table it's storing the actual

00:03:20,609 --> 00:03:27,510
functions so what is a function

00:03:25,620 --> 00:03:30,269
namespace or what is a function

00:03:27,510 --> 00:03:35,040
namespace manager so function namespace

00:03:30,269 --> 00:03:38,010
is kind of like if you were writing in

00:03:35,040 --> 00:03:40,799
any other programming language it's that

00:03:38,010 --> 00:03:45,120
kind of concept it's basically dot

00:03:40,799 --> 00:03:48,049
notation that would like wrap like a

00:03:45,120 --> 00:03:52,260
some some functionality or some objects

00:03:48,049 --> 00:03:56,250
as a separate packaging sort of that

00:03:52,260 --> 00:03:59,100
kind of idea but mapping to the sequel

00:03:56,250 --> 00:04:02,100
Ward we actually don't have arbitrarily

00:03:59,100 --> 00:04:04,590
long dot notation for function names

00:04:02,100 --> 00:04:08,790
days so basically a function namespace

00:04:04,590 --> 00:04:11,400
is kind of a catalog dart schema so each

00:04:08,790 --> 00:04:13,889
kernel schema can potentially be a

00:04:11,400 --> 00:04:18,660
function name space and a function name

00:04:13,889 --> 00:04:21,120
space manager is basically a piece of

00:04:18,660 --> 00:04:25,050
software or a plugin that would might

00:04:21,120 --> 00:04:27,570
manage a set of these catalog schemas we

00:04:25,050 --> 00:04:30,330
decided to have introduced in

00:04:27,570 --> 00:04:33,960
like a latke schema is basically Kellogg

00:04:30,330 --> 00:04:37,100
kind of maps to a connector impressed oh

00:04:33,960 --> 00:04:39,720
so you can have like a hive connector

00:04:37,100 --> 00:04:42,200
with the name hive or you can have a

00:04:39,720 --> 00:04:45,270
hive connector with the name my height

00:04:42,200 --> 00:04:48,810
so that would be or catalog and schema

00:04:45,270 --> 00:04:51,270
is kind of like internal concept okay or

00:04:48,810 --> 00:04:55,440
like if you can have a my sequel catalog

00:04:51,270 --> 00:04:58,020
with my sequel database at the schema we

00:04:55,440 --> 00:05:00,720
decided to separate this from the

00:04:58,020 --> 00:05:04,680
connector API because we want the

00:05:00,720 --> 00:05:09,030
flexibility of separating this catwalk

00:05:04,680 --> 00:05:11,250
schema from like your hive or or Mexico

00:05:09,030 --> 00:05:13,950
tables because essentially if we're

00:05:11,250 --> 00:05:16,190
talking about sequel functions these

00:05:13,950 --> 00:05:20,340
functions are implemented in sequel

00:05:16,190 --> 00:05:24,720
which means that they don't need to be

00:05:20,340 --> 00:05:27,900
tied to a specific table sets right like

00:05:24,720 --> 00:05:31,950
in normal sense catalogued a schema has

00:05:27,900 --> 00:05:34,230
tables in them and you these can be hive

00:05:31,950 --> 00:05:37,550
tables this can be my secret he was this

00:05:34,230 --> 00:05:40,320
can be your other like connector tables

00:05:37,550 --> 00:05:43,290
but the functions doesn't have to only

00:05:40,320 --> 00:05:45,930
work for that kind of schema which is

00:05:43,290 --> 00:05:52,200
why we sort of separated as a different

00:05:45,930 --> 00:05:56,660
plumbing if you so this is basically how

00:05:52,200 --> 00:06:01,970
you would write a sequel function its

00:05:56,660 --> 00:06:05,880
sequel standard syntax create function

00:06:01,970 --> 00:06:08,790
function name and then you have the

00:06:05,880 --> 00:06:11,280
input term today's list would implement

00:06:08,790 --> 00:06:14,040
input parameter type right this is a

00:06:11,280 --> 00:06:16,080
list so you can have additional inputs

00:06:14,040 --> 00:06:18,990
as well and then you have the return

00:06:16,080 --> 00:06:22,860
type so what is the type of this from

00:06:18,990 --> 00:06:25,200
the value of this function these are all

00:06:22,860 --> 00:06:27,500
scalar functions so you would return

00:06:25,200 --> 00:06:31,080
always a single value for a single

00:06:27,500 --> 00:06:32,970
inputs and you can't have comments

00:06:31,080 --> 00:06:35,730
comment is not sick Oh standard but I

00:06:32,970 --> 00:06:39,360
think it's we in general quite useful

00:06:35,730 --> 00:06:41,289
for users to understand what does this

00:06:39,360 --> 00:06:43,569
function do and

00:06:41,289 --> 00:06:46,360
so functions would actually include this

00:06:43,569 --> 00:06:48,999
comment so it's easier for people to

00:06:46,360 --> 00:06:51,339
discover these functions we need to

00:06:48,999 --> 00:06:54,309
specify call Convention is either

00:06:51,339 --> 00:06:56,020
returns no no input or : oil import this

00:06:54,309 --> 00:06:59,139
basic decides whether the function will

00:06:56,020 --> 00:07:01,629
be invoked if the input is no or import

00:06:59,139 --> 00:07:04,719
contains no whether the function is

00:07:01,629 --> 00:07:10,029
deterministic some optimization loss

00:07:04,719 --> 00:07:13,659
would be based on this whether we can we

00:07:10,029 --> 00:07:16,419
cannot optimize certain expressions and

00:07:13,659 --> 00:07:18,459
then this is the function body currently

00:07:16,419 --> 00:07:20,979
the only type of function body we

00:07:18,459 --> 00:07:24,069
support is an expression so basically

00:07:20,979 --> 00:07:29,080
you'll be turn'd expression so this

00:07:24,069 --> 00:07:31,059
function did erase them basically it's

00:07:29,080 --> 00:07:35,319
using the reduced to calculate the sum

00:07:31,059 --> 00:07:37,990
of the race and so essentially what

00:07:35,319 --> 00:07:41,229
currently sequel function can offer is

00:07:37,990 --> 00:07:44,020
wrapping psycho logic in a function

00:07:41,229 --> 00:07:49,120
which in a way sort of works like a

00:07:44,020 --> 00:07:51,399
macro so instead of writing like one of

00:07:49,120 --> 00:07:54,149
the really powerful thing of trust

00:07:51,399 --> 00:07:58,029
though is that you can write very

00:07:54,149 --> 00:08:00,459
complex lambda functions but it's

00:07:58,029 --> 00:08:02,680
actually may be quite hard to read and

00:08:00,459 --> 00:08:04,509
it's very hard to share these lambda

00:08:02,680 --> 00:08:07,389
function logic and you basically copy

00:08:04,509 --> 00:08:09,669
paste the code everywhere and so this

00:08:07,389 --> 00:08:11,649
way you can define in the complex lambda

00:08:09,669 --> 00:08:16,899
functions into a sequel function that

00:08:11,649 --> 00:08:20,740
people can just use it so this is how

00:08:16,899 --> 00:08:23,830
you would use sequel function you need

00:08:20,740 --> 00:08:29,249
to refer to the function as the catalog

00:08:23,830 --> 00:08:34,110
schema don't function name we decided to

00:08:29,249 --> 00:08:38,469
go with this fully qualified name

00:08:34,110 --> 00:08:40,959
collision because so potentially we can

00:08:38,469 --> 00:08:43,479
do that if you just say select erase own

00:08:40,959 --> 00:08:48,149
we meet we can't just like go through

00:08:43,479 --> 00:08:50,529
all the catalogs and see whether any

00:08:48,149 --> 00:08:53,170
function namespace manager has a

00:08:50,529 --> 00:08:55,180
function that called a resume and then

00:08:53,170 --> 00:08:58,270
depending on some ordering

00:08:55,180 --> 00:09:02,830
citing which one to use but in reality

00:08:58,270 --> 00:09:06,460
this kind of makes things a little bit

00:09:02,830 --> 00:09:09,850
hard to manage in the sense that for

00:09:06,460 --> 00:09:13,750
example I'm writing select erase on

00:09:09,850 --> 00:09:18,459
which would resolve to my erase um today

00:09:13,750 --> 00:09:22,750
and someone else introduced a new arisen

00:09:18,459 --> 00:09:25,420
function on another function namespace

00:09:22,750 --> 00:09:28,149
that has a higher priority than mine and

00:09:25,420 --> 00:09:30,190
then like I would just arbitrarily start

00:09:28,149 --> 00:09:33,570
to use a different function without me

00:09:30,190 --> 00:09:40,600
knowing it's kind of like more like

00:09:33,570 --> 00:09:43,540
hazard for DBA so which is which mapping

00:09:40,600 --> 00:09:47,800
Facebook our team is post the DBA and

00:09:43,540 --> 00:09:50,800
the tbh so we figured that we don't want

00:09:47,800 --> 00:09:55,649
to get in there but that's that if

00:09:50,800 --> 00:10:02,350
people think this is useful to have like

00:09:55,649 --> 00:10:06,089
kind of like a resolution logic and kind

00:10:02,350 --> 00:10:10,360
of using a fuzzy match and find the best

00:10:06,089 --> 00:10:12,490
candidate PRS are welcome as long as you

00:10:10,360 --> 00:10:16,120
can make sure that this feature can be

00:10:12,490 --> 00:10:19,920
turned on and off right so contribution

00:10:16,120 --> 00:10:23,410
are welcome we can do that as well so

00:10:19,920 --> 00:10:26,920
this is kind of how underlying the thing

00:10:23,410 --> 00:10:29,350
works so first because you can create a

00:10:26,920 --> 00:10:32,529
function and actually you can modify the

00:10:29,350 --> 00:10:36,640
function after it's created

00:10:32,529 --> 00:10:39,690
so as a result you the function can like

00:10:36,640 --> 00:10:42,579
unlike built-in functions which are

00:10:39,690 --> 00:10:45,700
registered and can never be changed for

00:10:42,579 --> 00:10:47,470
the lifetime of the server runtime these

00:10:45,700 --> 00:10:50,529
functions can turn to all the server's

00:10:47,470 --> 00:10:52,390
money as a result is very important that

00:10:50,529 --> 00:10:54,520
when we're running in a single query we

00:10:52,390 --> 00:10:57,399
are always using a consistent version of

00:10:54,520 --> 00:11:01,839
the function to run a single query how

00:10:57,399 --> 00:11:04,900
we do this is we make sure that we are

00:11:01,839 --> 00:11:06,910
only resolving a function once when we

00:11:04,900 --> 00:11:08,180
are parsing the query on the coordinator

00:11:06,910 --> 00:11:10,910
and one

00:11:08,180 --> 00:11:13,640
function is resolved its resolving to a

00:11:10,910 --> 00:11:15,770
version of the function so this function

00:11:13,640 --> 00:11:18,350
ID would include a version number and

00:11:15,770 --> 00:11:20,990
this information will be parsed would be

00:11:18,350 --> 00:11:22,730
passed to all workers and worker will

00:11:20,990 --> 00:11:24,800
use this function ID to retrieve the

00:11:22,730 --> 00:11:27,020
function implementation that way we'll

00:11:24,800 --> 00:11:28,880
make sure that all the worker using the

00:11:27,020 --> 00:11:36,410
same version of the function when it's

00:11:28,880 --> 00:11:39,170
running in zero purity so there as I

00:11:36,410 --> 00:11:41,839
said this is still like actively working

00:11:39,170 --> 00:11:44,029
in progress there are still features

00:11:41,839 --> 00:11:47,149
that's like coming up in the near fruit

00:11:44,029 --> 00:11:49,790
future like in the next month or so one

00:11:47,149 --> 00:11:52,120
thing is buildings echo function one

00:11:49,790 --> 00:11:55,430
thing you would ask is a riff sound is a

00:11:52,120 --> 00:11:57,830
general is a generic logic that like

00:11:55,430 --> 00:12:00,770
nobody would imagine a resume would need

00:11:57,830 --> 00:12:03,290
a different implementation and why do

00:12:00,770 --> 00:12:06,560
people need to define an array some and

00:12:03,290 --> 00:12:10,370
and write it into a different function

00:12:06,560 --> 00:12:12,680
namespace to use it this can be just the

00:12:10,370 --> 00:12:14,690
same as building functions except that

00:12:12,680 --> 00:12:16,640
instead of written in Java they're

00:12:14,690 --> 00:12:19,220
written in sequel so that's what we're

00:12:16,640 --> 00:12:22,220
working on right now so there is

00:12:19,220 --> 00:12:24,980
actually a peer out already I need to be

00:12:22,220 --> 00:12:27,220
reviewed what this does is that it

00:12:24,980 --> 00:12:33,470
allows to being sequel functions

00:12:27,220 --> 00:12:36,050
built-in functions can still be used as

00:12:33,470 --> 00:12:39,020
just the function name so you can if

00:12:36,050 --> 00:12:41,810
array sum is a building function that

00:12:39,020 --> 00:12:45,589
would mean that you can do select array

00:12:41,810 --> 00:12:47,900
some array instead of select example

00:12:45,589 --> 00:12:51,140
don't have stories don't talk example to

00:12:47,900 --> 00:12:53,089
her radar it's so like without the fully

00:12:51,140 --> 00:12:56,240
qualified name you can still just use it

00:12:53,089 --> 00:12:58,810
so and also that would mean that this

00:12:56,240 --> 00:13:01,990
function cannot be changed or modified

00:12:58,810 --> 00:13:05,329
so that's one thing another thing is

00:13:01,990 --> 00:13:07,310
currently the access control we don't

00:13:05,329 --> 00:13:10,070
really have a real access control for

00:13:07,310 --> 00:13:12,560
functions so you cannot say that you

00:13:10,070 --> 00:13:15,470
cannot grant people permission on write

00:13:12,560 --> 00:13:18,860
or read or modification on specific

00:13:15,470 --> 00:13:22,370
functions or specific function write

00:13:18,860 --> 00:13:25,640
namespaces so we want to implement

00:13:22,370 --> 00:13:27,410
access control for functions as well so

00:13:25,640 --> 00:13:30,890
these are the specific feature that's

00:13:27,410 --> 00:13:34,610
coming up in the near future for sequel

00:13:30,890 --> 00:13:37,610
functions of course we want to also

00:13:34,610 --> 00:13:40,970
expand a sequel function to support not

00:13:37,610 --> 00:13:45,890
just expression but more complex cycle

00:13:40,970 --> 00:13:48,380
constructs that is currently there is no

00:13:45,890 --> 00:13:51,860
concrete plan in the near term like as

00:13:48,380 --> 00:13:54,560
not in the next couple months but if

00:13:51,860 --> 00:13:58,550
anybody's interested in it let us know

00:13:54,560 --> 00:14:00,530
and we can if you want to contribute on

00:13:58,550 --> 00:14:02,210
that and how pump bring that feature in

00:14:00,530 --> 00:14:07,730
to press though they'll be very welcome

00:14:02,210 --> 00:14:12,110
as well okay some more updates on remote

00:14:07,730 --> 00:14:15,200
functions I seen that people were asking

00:14:12,110 --> 00:14:18,980
is it possible to use high VDS entresto

00:14:15,200 --> 00:14:21,800
so the remote function is sort of trying

00:14:18,980 --> 00:14:24,800
to address that problem a lot of the

00:14:21,800 --> 00:14:27,110
hive UDF's so first of all hi Beauty f

00:14:24,800 --> 00:14:31,340
is implemented in a totally different

00:14:27,110 --> 00:14:32,480
API than frost oh right so to run that

00:14:31,340 --> 00:14:35,540
impressed OH

00:14:32,480 --> 00:14:38,210
whoa need some like if we run it if we

00:14:35,540 --> 00:14:41,300
want to bring that impressed or today we

00:14:38,210 --> 00:14:44,810
at least need to depend on the hive PDF

00:14:41,300 --> 00:14:48,590
package and then implement up faster

00:14:44,810 --> 00:14:52,820
function and in that wrapper call the

00:14:48,590 --> 00:14:57,320
hive the UDF API in a way if you want to

00:14:52,820 --> 00:14:59,680
kind of directly reuse the hive code but

00:14:57,320 --> 00:15:05,990
there's a different problem to that so

00:14:59,680 --> 00:15:08,810
one thing is that hive in turn has

00:15:05,990 --> 00:15:14,720
better eyes like isolation so as a

00:15:08,810 --> 00:15:16,940
result these hi functions can like be

00:15:14,720 --> 00:15:18,550
more flexible in terms of what they are

00:15:16,940 --> 00:15:22,100
calling what they're using

00:15:18,550 --> 00:15:23,840
so like specifically in facebook we have

00:15:22,100 --> 00:15:26,990
higher functions that would actually

00:15:23,840 --> 00:15:31,430
call external services we have high

00:15:26,990 --> 00:15:35,150
functions that would be quite expensive

00:15:31,430 --> 00:15:36,449
or like in real unreliable or use a lot

00:15:35,150 --> 00:15:39,269
of memory

00:15:36,449 --> 00:15:42,060
so all of these can happen which are not

00:15:39,269 --> 00:15:45,029
safe to bring them directly into presto

00:15:42,060 --> 00:15:47,699
so remote function is basically saying

00:15:45,029 --> 00:15:53,670
that okay these functions would run in a

00:15:47,699 --> 00:15:57,870
separate separate JVM remotely and they

00:15:53,670 --> 00:15:59,639
can't have their own isolation so from

00:15:57,870 --> 00:16:01,230
Presto's perspective I know this

00:15:59,639 --> 00:16:04,050
function has not been a running impress

00:16:01,230 --> 00:16:06,959
though I would plan accordingly generate

00:16:04,050 --> 00:16:09,180
a different plan and if I have a

00:16:06,959 --> 00:16:10,860
functioning this manager that has the

00:16:09,180 --> 00:16:15,420
information of where to send this

00:16:10,860 --> 00:16:17,970
function to then from Presto's server's

00:16:15,420 --> 00:16:20,130
perspective problem soft right you need

00:16:17,970 --> 00:16:25,139
to implement an additional function UDF

00:16:20,130 --> 00:16:28,170
server to run it but that's a separate

00:16:25,139 --> 00:16:33,630
problem okay so this is basically how we

00:16:28,170 --> 00:16:35,730
are addressing high UDF's and so this is

00:16:33,630 --> 00:16:38,880
roughly how what needs to be turned on

00:16:35,730 --> 00:16:42,089
presto let's say that does testing that

00:16:38,880 --> 00:16:44,850
has the remote foo is a remote function

00:16:42,089 --> 00:16:50,010
that needs to run that that cannot be

00:16:44,850 --> 00:16:54,180
run on presto what we need to augment on

00:16:50,010 --> 00:16:56,940
the presto side is to say that this

00:16:54,180 --> 00:16:59,100
remote foo is a remote function so the

00:16:56,940 --> 00:17:01,170
function validator can indicate whether

00:16:59,100 --> 00:17:02,880
a function needs to be can be run local

00:17:01,170 --> 00:17:05,370
or can be there has to be run remote

00:17:02,880 --> 00:17:07,740
right and then you have this function

00:17:05,370 --> 00:17:10,530
namespace manager managing this catalog

00:17:07,740 --> 00:17:13,169
of remote functions that would know that

00:17:10,530 --> 00:17:17,490
okay for remote foo I need to talk to

00:17:13,169 --> 00:17:20,549
that cluster so on the planning side

00:17:17,490 --> 00:17:23,189
what needs to happen is it used to be

00:17:20,549 --> 00:17:27,870
that this whole expression is by

00:17:23,189 --> 00:17:30,330
quotient and run in a single path in

00:17:27,870 --> 00:17:34,260
product but now that cannot happen

00:17:30,330 --> 00:17:36,900
anymore I need to break the project into

00:17:34,260 --> 00:17:38,910
local protection and remote production

00:17:36,900 --> 00:17:41,900
and if they have dependencies they need

00:17:38,910 --> 00:17:44,909
to have like different stages of local

00:17:41,900 --> 00:17:47,490
productions and remote productions once

00:17:44,909 --> 00:17:49,440
we can break the product into local

00:17:47,490 --> 00:17:52,500
remote what we can do

00:17:49,440 --> 00:17:54,930
basically for the local protection we

00:17:52,500 --> 00:17:59,030
run as Europe for the remote projection

00:17:54,930 --> 00:18:03,000
we basically currently we are the

00:17:59,030 --> 00:18:06,030
current implementation is using the

00:18:03,000 --> 00:18:08,010
thrift the thrift connector API actually

00:18:06,030 --> 00:18:13,320
so we're piggybacking on with connector

00:18:08,010 --> 00:18:15,900
API or just directly use the thrift API

00:18:13,320 --> 00:18:19,500
to say that this converter is paid to a

00:18:15,900 --> 00:18:21,630
thrift page and you woke that function

00:18:19,500 --> 00:18:25,020
on that remote server through Swift

00:18:21,630 --> 00:18:27,690
thrift and then get the result back to

00:18:25,020 --> 00:18:29,760
me so basically you would extract the

00:18:27,690 --> 00:18:33,420
columns are needed for to compute this

00:18:29,760 --> 00:18:35,820
function and send that to a remote UDF

00:18:33,420 --> 00:18:38,160
server tier and once that computation is

00:18:35,820 --> 00:18:41,160
done the result will be sent back and

00:18:38,160 --> 00:18:45,030
then we can proceed to the next operator

00:18:41,160 --> 00:18:48,840
stage so this is what is going on right

00:18:45,030 --> 00:18:53,640
now currently we have working for West

00:18:48,840 --> 00:18:56,370
PR that's on github so if you want to

00:18:53,640 --> 00:19:00,960
check it out feel free to do so for the

00:18:56,370 --> 00:19:03,150
UDF server site we will see how much

00:19:00,960 --> 00:19:06,540
whether it's possible to open-source

00:19:03,150 --> 00:19:11,280
something so on the UDF server side it's

00:19:06,540 --> 00:19:13,920
actually the majority of the work is so

00:19:11,280 --> 00:19:16,800
there are a few things on the unity of

00:19:13,920 --> 00:19:18,510
server side one thing is the executor

00:19:16,800 --> 00:19:21,180
that can actually run the remote

00:19:18,510 --> 00:19:23,520
function either it will be run the hi

00:19:21,180 --> 00:19:25,890
function or it would be the one that if

00:19:23,520 --> 00:19:28,620
you want to have like a Python executor

00:19:25,890 --> 00:19:33,120
or if you want to have like other like

00:19:28,620 --> 00:19:35,670
PHP executor C++ executors those have

00:19:33,120 --> 00:19:38,910
more dependencies on what functions you

00:19:35,670 --> 00:19:42,750
want to run which would be different for

00:19:38,910 --> 00:19:46,710
every use case so it's kind of a little

00:19:42,750 --> 00:19:49,560
bit harder to to like it's not for the

00:19:46,710 --> 00:19:52,640
logics mostly depending on the functions

00:19:49,560 --> 00:19:56,190
which are proprietary for each use case

00:19:52,640 --> 00:19:58,950
there's another piece of it that's kind

00:19:56,190 --> 00:20:02,490
of how do you do scheduling or how do

00:19:58,950 --> 00:20:03,210
you manage this cluster depending on use

00:20:02,490 --> 00:20:06,120
case

00:20:03,210 --> 00:20:10,169
can be arbitrarily simpler or unfree

00:20:06,120 --> 00:20:13,200
complex so we will see later once we

00:20:10,169 --> 00:20:15,870
have this introduction whether it's

00:20:13,200 --> 00:20:17,789
useful to like what can be open-source

00:20:15,870 --> 00:20:21,029
then how useful it is to open-source

00:20:17,789 --> 00:20:23,399
them but other verities we can talk

00:20:21,029 --> 00:20:28,169
about how we implement them once we have

00:20:23,399 --> 00:20:31,110
those yeah so that's all for the updates

00:20:28,169 --> 00:20:37,799
from from physical functions any

00:20:31,110 --> 00:20:40,110
questions are welcome I'm gonna pick

00:20:37,799 --> 00:20:45,720
wrong on take a look at the Q&A panel

00:20:40,110 --> 00:20:47,340
and it see if there is anything but

00:20:45,720 --> 00:20:49,020
there is possible to use hi media

00:20:47,340 --> 00:20:51,330
entrusted directly without really

00:20:49,020 --> 00:20:53,700
implementing it that would be possible

00:20:51,330 --> 00:20:57,929
once we have UDF the remote idea

00:20:53,700 --> 00:21:01,289
function functionality impressed oh yeah

00:20:57,929 --> 00:21:06,390
and that's so far that seems to be the

00:21:01,289 --> 00:21:08,850
only question okay do you when you say

00:21:06,390 --> 00:21:11,190
sequel functions are versioned is this

00:21:08,850 --> 00:21:13,890
only for execution to ensure single

00:21:11,190 --> 00:21:16,020
query use the same implementation or are

00:21:13,890 --> 00:21:21,750
you managing inversions in my sequel

00:21:16,020 --> 00:21:25,590
when a function gets updated so each

00:21:21,750 --> 00:21:28,580
version like when you are so you can

00:21:25,590 --> 00:21:31,080
actually do replace function as well

00:21:28,580 --> 00:21:34,529
which would basically modify the

00:21:31,080 --> 00:21:36,690
implementation of the function each

00:21:34,529 --> 00:21:42,480
version of this function would be a

00:21:36,690 --> 00:21:48,240
different record in my sequel so I'm not

00:21:42,480 --> 00:21:50,460
exactly sure what do you mean by are you

00:21:48,240 --> 00:21:53,039
managing emergency my C : when a

00:21:50,460 --> 00:21:56,850
function gets updated so like I sort of

00:21:53,039 --> 00:21:59,720
so yes so each each version is a new

00:21:56,850 --> 00:22:02,700
record a my sequel basically and that

00:21:59,720 --> 00:22:05,909
way we'll make sure that the older

00:22:02,700 --> 00:22:07,799
versions still retrievable if a query is

00:22:05,909 --> 00:22:10,799
resolved to the old version I need to

00:22:07,799 --> 00:22:14,370
use that you're wrong for remote I hope

00:22:10,799 --> 00:22:17,100
that answers your question for remote

00:22:14,370 --> 00:22:19,559
functions are you planning to start

00:22:17,100 --> 00:22:23,190
off with hi were you planning to support

00:22:19,559 --> 00:22:25,289
other database functions so we are

00:22:23,190 --> 00:22:27,539
planning to start with hi functions

00:22:25,289 --> 00:22:32,639
internally at Facebook because that's

00:22:27,539 --> 00:22:35,549
not largest UDF repository we have most

00:22:32,639 --> 00:22:39,409
of the previous UDF's people rewrote our

00:22:35,549 --> 00:22:43,710
in life so yes we're starting with that

00:22:39,409 --> 00:22:47,190
but then like down the road we also have

00:22:43,710 --> 00:22:50,129
business need for like PHP functions and

00:22:47,190 --> 00:22:54,210
C++ function and Python functions so we

00:22:50,129 --> 00:23:00,690
also want to explore those yes any other

00:22:54,210 --> 00:23:03,509
questions I think there's one more that

00:23:00,690 --> 00:23:07,679
came in and perhaps wrap it with that

00:23:03,509 --> 00:23:11,159
one from Himanshu is functional over is

00:23:07,679 --> 00:23:12,299
functional overloading is supported so

00:23:11,159 --> 00:23:16,620
yes

00:23:12,299 --> 00:23:18,659
the function is so the function is

00:23:16,620 --> 00:23:23,759
basically the name plus or input

00:23:18,659 --> 00:23:26,399
parameter types so as long as the same

00:23:23,759 --> 00:23:28,289
name you so you can't have multiple

00:23:26,399 --> 00:23:30,690
functions with the same name but have

00:23:28,289 --> 00:23:32,940
takes different parameter inputs one

00:23:30,690 --> 00:23:36,720
limitation of the seco function is

00:23:32,940 --> 00:23:39,450
actually Seacoast's C Costa Rica spec

00:23:36,720 --> 00:23:42,210
doesn't have the concept of generic so

00:23:39,450 --> 00:23:45,899
unfortunately you sort of need to if the

00:23:42,210 --> 00:23:49,799
same even if the same implementation can

00:23:45,899 --> 00:23:51,980
take different input term two types you

00:23:49,799 --> 00:23:55,129
sort of need to define it multiple times

00:23:51,980 --> 00:24:04,440
with the different input parameter list

00:23:55,129 --> 00:24:06,899
yes that's all I think okay yep I think

00:24:04,440 --> 00:24:09,929
that seems like it so I think we are

00:24:06,899 --> 00:24:13,169
absolutely on time its 1217 thank you

00:24:09,929 --> 00:24:14,730
all on behalf of the Presto Outreach

00:24:13,169 --> 00:24:16,860
Committee thank you all for you know

00:24:14,730 --> 00:24:19,049
spending this one are with us I know

00:24:16,860 --> 00:24:20,909
it's not the same as you know being in a

00:24:19,049 --> 00:24:22,950
room together and perhaps enjoying a

00:24:20,909 --> 00:24:25,200
meal you know after a meet-up

00:24:22,950 --> 00:24:26,820
but I guess you know what we have is

00:24:25,200 --> 00:24:30,269
what we have and let's make the best of

00:24:26,820 --> 00:24:32,759
it which everybody stays healthy you

00:24:30,269 --> 00:24:35,669
the next couple of months and stay tuned

00:24:32,759 --> 00:24:37,879
for more sessions and events coming from

00:24:35,669 --> 00:24:37,879

YouTube URL: https://www.youtube.com/watch?v=rhvfjraRbno


