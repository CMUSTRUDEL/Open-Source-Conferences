Title: Parquet Column Level Access Control with Presto
Publication date: 2020-11-17
Playlist: Presto Events
Description: 
	Apache Parquet is the major columnar file storage format used by Apache Presto and several other query engines in many big data analytic frameworks today. In a lot of use cases, a portion of the column data is highly sensitive and must be protected. Column encryption at the file format level is supported in the Parquet community. Due to the rewritten code of Parquet in Presto, Parquet column encryption at Presto needs to be ported with modifications to the Presto code page. And the integration with Key Management Service (KMS) and other query engines like Hive and Spark is another challenge.

In this talk, we will show the work we have done for enabling Presto for Parquet column decryption including challenges, solutions, integration with Hive/Spark Parquet column encryption and look forward to the next step of encryption work.
Captions: 
	00:00:00,080 --> 00:00:04,080
hi everybody uh this talk is about price

00:00:02,960 --> 00:00:06,160
to security

00:00:04,080 --> 00:00:09,680
apache pro quick column level access

00:00:06,160 --> 00:00:09,680
control with price talk

00:00:10,160 --> 00:00:16,000
um a little bit introducing about

00:00:13,440 --> 00:00:18,640
myself and my colleague i'm a tech lead

00:00:16,000 --> 00:00:21,600
manager at the uber data info

00:00:18,640 --> 00:00:22,240
and i'm a apache poke committer my

00:00:21,600 --> 00:00:25,039
colleague

00:00:22,240 --> 00:00:26,320
piv who will join me today to talk about

00:00:25,039 --> 00:00:30,480
the second half

00:00:26,320 --> 00:00:33,040
of this session my team can covers

00:00:30,480 --> 00:00:34,399
big data security and storage cost

00:00:33,040 --> 00:00:36,880
efficiency

00:00:34,399 --> 00:00:39,440
we invest heavily in big data for might

00:00:36,880 --> 00:00:41,680
particularly in apache pokeway

00:00:39,440 --> 00:00:43,840
concrete column encryption is the one

00:00:41,680 --> 00:00:45,360
that we spend a lot of effort in the

00:00:43,840 --> 00:00:47,680
last two years

00:00:45,360 --> 00:00:50,079
worked with a pro quick community and

00:00:47,680 --> 00:00:52,879
brought it up to the production

00:00:50,079 --> 00:00:54,719
we do law to hive spark and presto

00:00:52,879 --> 00:00:57,039
particularly for presto

00:00:54,719 --> 00:00:59,039
because it rewrites the program reader

00:00:57,039 --> 00:01:00,000
so we need to rewrite the pocket column

00:00:59,039 --> 00:01:02,000
encryption

00:01:00,000 --> 00:01:03,039
so that's why we want to give a tech

00:01:02,000 --> 00:01:05,439
talk today

00:01:03,039 --> 00:01:07,439
to their price to community we want to

00:01:05,439 --> 00:01:10,640
work with the community to merge

00:01:07,439 --> 00:01:12,640
the changes to the upstream

00:01:10,640 --> 00:01:14,799
other than the column encryption we also

00:01:12,640 --> 00:01:17,600
invest in cost efficiency

00:01:14,799 --> 00:01:19,040
uh in pokewei we adopted several

00:01:17,600 --> 00:01:21,840
hardcore technologies

00:01:19,040 --> 00:01:22,640
uh like column pruning to remove unused

00:01:21,840 --> 00:01:24,960
columns

00:01:22,640 --> 00:01:26,159
at a fair format level this standard

00:01:24,960 --> 00:01:28,880
compression

00:01:26,159 --> 00:01:30,400
multiple column reordering decimal point

00:01:28,880 --> 00:01:32,240
session with dark et cetera

00:01:30,400 --> 00:01:34,479
so all of these innovations working

00:01:32,240 --> 00:01:37,600
together make our data

00:01:34,479 --> 00:01:38,640
data lake storage uh smaller and query

00:01:37,600 --> 00:01:40,799
faster so

00:01:38,640 --> 00:01:43,520
we can find another time to talk about

00:01:40,799 --> 00:01:43,520
those topics

00:01:43,920 --> 00:01:49,600
today's talk is organized this way

00:01:47,040 --> 00:01:50,640
first let's talk about why we want to

00:01:49,600 --> 00:01:53,439
introduce

00:01:50,640 --> 00:01:55,280
column level access control in presto

00:01:53,439 --> 00:01:57,040
then we will spend a little bit time on

00:01:55,280 --> 00:02:00,000
a particular crew in presto

00:01:57,040 --> 00:02:02,640
to set up the contacts hopefully that

00:02:00,000 --> 00:02:05,119
can provide some help to understand

00:02:02,640 --> 00:02:07,119
the following comments better then we

00:02:05,119 --> 00:02:08,000
will spend most of our time to talk

00:02:07,119 --> 00:02:09,599
about

00:02:08,000 --> 00:02:11,840
procreate column encryption and the

00:02:09,599 --> 00:02:12,560
price to column like column level access

00:02:11,840 --> 00:02:15,360
control

00:02:12,560 --> 00:02:15,680
through column encryption data masking

00:02:15,360 --> 00:02:18,160
is

00:02:15,680 --> 00:02:19,440
an important feature relates to the

00:02:18,160 --> 00:02:23,840
column encryption

00:02:19,440 --> 00:02:23,840
and we will talk about that in the end

00:02:24,080 --> 00:02:29,120
what do we cover and not cover we will

00:02:27,200 --> 00:02:31,519
focus on the discussion of

00:02:29,120 --> 00:02:32,560
fine-grained access control in hadoop

00:02:31,519 --> 00:02:34,879
data lake

00:02:32,560 --> 00:02:36,319
we focus on the technologies other than

00:02:34,879 --> 00:02:38,319
the data itself

00:02:36,319 --> 00:02:40,480
we will talk about open source

00:02:38,319 --> 00:02:42,879
technologies and internal tools

00:02:40,480 --> 00:02:43,760
like apache for quick economy encryption

00:02:42,879 --> 00:02:46,239
tms

00:02:43,760 --> 00:02:48,000
data masking et cetera but we are not

00:02:46,239 --> 00:02:50,560
covering all the aspects

00:02:48,000 --> 00:02:51,360
data security and it's not a legal

00:02:50,560 --> 00:02:54,160
advice

00:02:51,360 --> 00:02:54,160
or guidance

00:02:55,519 --> 00:02:58,879
first of all why do we need column level

00:02:57,840 --> 00:03:01,760
access control

00:02:58,879 --> 00:03:04,319
or kic in the following slides we just

00:03:01,760 --> 00:03:07,519
call it krac

00:03:04,319 --> 00:03:08,959
first we want to protect data at the

00:03:07,519 --> 00:03:12,080
lowest level

00:03:08,959 --> 00:03:12,879
data lake for example hdfs is an open

00:03:12,080 --> 00:03:15,440
system

00:03:12,879 --> 00:03:16,000
the data can be accepted from many many

00:03:15,440 --> 00:03:19,440
par

00:03:16,000 --> 00:03:21,760
price to have spark people can even

00:03:19,440 --> 00:03:23,840
directly download the data

00:03:21,760 --> 00:03:24,959
if you just provide access control at

00:03:23,840 --> 00:03:27,519
some point

00:03:24,959 --> 00:03:28,400
it doesn't really protect the data so

00:03:27,519 --> 00:03:30,720
qlec

00:03:28,400 --> 00:03:32,799
encrypts the data added storage

00:03:30,720 --> 00:03:33,599
regardless which parts you get the data

00:03:32,799 --> 00:03:36,080
from

00:03:33,599 --> 00:03:37,200
if you do not have correct permission

00:03:36,080 --> 00:03:40,560
for the key

00:03:37,200 --> 00:03:43,280
you cannot decrypt the data

00:03:40,560 --> 00:03:44,560
secondly it is for the fine green access

00:03:43,280 --> 00:03:46,720
control

00:03:44,560 --> 00:03:49,200
we know cod screen access control at the

00:03:46,720 --> 00:03:49,599
table or fail level doesn't work well

00:03:49,200 --> 00:03:52,560
for

00:03:49,599 --> 00:03:53,840
any linux tables this is because in the

00:03:52,560 --> 00:03:56,799
typical data side

00:03:53,840 --> 00:03:59,360
table usually have a lot of columns but

00:03:56,799 --> 00:04:00,480
only a small percentage of the columns

00:03:59,360 --> 00:04:03,680
are actually

00:04:00,480 --> 00:04:06,319
confidential i need to be protected

00:04:03,680 --> 00:04:08,480
to give example we see a lot of tables

00:04:06,319 --> 00:04:11,040
that have hundreds of columns where

00:04:08,480 --> 00:04:11,920
only several columns need to be

00:04:11,040 --> 00:04:14,799
protected

00:04:11,920 --> 00:04:15,439
so cost green access control brings some

00:04:14,799 --> 00:04:17,840
problems

00:04:15,439 --> 00:04:20,000
for this scenario let's walk through the

00:04:17,840 --> 00:04:23,360
next slide

00:04:20,000 --> 00:04:28,160
let's do a comparison of use cases with

00:04:23,360 --> 00:04:31,520
and without klec in the no klec scenario

00:04:28,160 --> 00:04:36,160
example 1 example 2 are the results

00:04:31,520 --> 00:04:39,600
of no chelsea example 1 we have a select

00:04:36,160 --> 00:04:42,720
on four columns the columns are a

00:04:39,600 --> 00:04:44,639
id email and b email id

00:04:42,720 --> 00:04:46,479
email and id are highlighted in the

00:04:44,639 --> 00:04:49,919
right because they are considered as

00:04:46,479 --> 00:04:53,360
sensitive data in example 2

00:04:49,919 --> 00:04:54,400
it is a similar select but this time the

00:04:53,360 --> 00:04:56,560
user is not

00:04:54,400 --> 00:04:58,000
actually trying to read any sensitive

00:04:56,560 --> 00:04:59,759
information

00:04:58,000 --> 00:05:01,120
but it still got denied because the

00:04:59,759 --> 00:05:04,160
permission can only

00:05:01,120 --> 00:05:06,560
be controlled by the table level

00:05:04,160 --> 00:05:07,919
so in the bottom part it is a kic

00:05:06,560 --> 00:05:10,320
enabled scenario

00:05:07,919 --> 00:05:11,120
the same query i issued and they are

00:05:10,320 --> 00:05:14,160
example

00:05:11,120 --> 00:05:15,919
three and four for example three

00:05:14,160 --> 00:05:17,280
the query is still rejected because they

00:05:15,919 --> 00:05:20,000
are trying to access

00:05:17,280 --> 00:05:21,280
the sensitive data but no permission for

00:05:20,000 --> 00:05:24,160
example four

00:05:21,280 --> 00:05:24,560
since the user only select column a and

00:05:24,160 --> 00:05:27,440
the b

00:05:24,560 --> 00:05:28,080
which are not sensitive you the query

00:05:27,440 --> 00:05:30,639
succeed

00:05:28,080 --> 00:05:32,960
so this will improve you the experience

00:05:30,639 --> 00:05:35,759
while still protecting the data

00:05:32,960 --> 00:05:35,759
we want to protect

00:05:36,000 --> 00:05:41,360
so we learned from the last example how

00:05:38,960 --> 00:05:43,759
klec uses scenarios

00:05:41,360 --> 00:05:44,800
now let's talk about the approach to

00:05:43,759 --> 00:05:47,840
implanted

00:05:44,800 --> 00:05:50,720
implement light the high level approach

00:05:47,840 --> 00:05:51,759
is to enforce the access control i fell

00:05:50,720 --> 00:05:54,800
from that level

00:05:51,759 --> 00:05:58,000
in our case is proclaimed and

00:05:54,800 --> 00:06:00,319
you encrypt only sensitive columns input

00:05:58,000 --> 00:06:02,960
and store the data in storage which can

00:06:00,319 --> 00:06:05,039
be hdfs or cloud which doesn't matter in

00:06:02,960 --> 00:06:08,160
this case

00:06:05,039 --> 00:06:08,639
to access control to the data column is

00:06:08,160 --> 00:06:11,919
done

00:06:08,639 --> 00:06:13,360
by access control to the key if you have

00:06:11,919 --> 00:06:14,479
permission to the key you have

00:06:13,360 --> 00:06:17,520
permission to the data

00:06:14,479 --> 00:06:18,960
otherwise it is access denied this is a

00:06:17,520 --> 00:06:21,919
very high level approach

00:06:18,960 --> 00:06:22,400
let's get deeper into poke and see how

00:06:21,919 --> 00:06:25,600
we

00:06:22,400 --> 00:06:25,600
implement this approach

00:06:25,759 --> 00:06:30,960
first let's zoom in procreate format

00:06:28,800 --> 00:06:32,000
structure for a little bit more details

00:06:30,960 --> 00:06:35,600
to build up the

00:06:32,000 --> 00:06:39,199
context here quickly is a column

00:06:35,600 --> 00:06:41,759
storage file format the data is

00:06:39,199 --> 00:06:43,440
the data in the sim columns will be put

00:06:41,759 --> 00:06:44,000
together that will make the data

00:06:43,440 --> 00:06:47,199
retrieve

00:06:44,000 --> 00:06:48,720
faster and data sets smaller program is

00:06:47,199 --> 00:06:51,680
a popular big data

00:06:48,720 --> 00:06:53,199
file format which is used very widely in

00:06:51,680 --> 00:06:57,199
presto spark

00:06:53,199 --> 00:06:57,199
and many many other applications

00:06:57,599 --> 00:07:03,919
so a program file is divided

00:07:00,880 --> 00:07:06,479
into many rule groups

00:07:03,919 --> 00:07:08,400
with a folder the folder provides schema

00:07:06,479 --> 00:07:10,720
metadata etc

00:07:08,400 --> 00:07:12,800
which is needed information will reach

00:07:10,720 --> 00:07:16,160
these poke files

00:07:12,800 --> 00:07:18,880
inside each row group is further divided

00:07:16,160 --> 00:07:20,160
into column chunks so each column chunk

00:07:18,880 --> 00:07:23,520
is corresponding to

00:07:20,160 --> 00:07:26,000
a column in a table

00:07:23,520 --> 00:07:27,280
inside a column chunk is further divided

00:07:26,000 --> 00:07:30,080
into pages

00:07:27,280 --> 00:07:31,120
so page is that you need for the

00:07:30,080 --> 00:07:35,199
encoding

00:07:31,120 --> 00:07:35,199
compression and encryption

00:07:36,639 --> 00:07:40,000
let's look into the column encryption

00:07:38,479 --> 00:07:43,120
flow for write

00:07:40,000 --> 00:07:46,160
and read in this example

00:07:43,120 --> 00:07:46,160
you have a table

00:07:46,479 --> 00:07:50,400
just two columns c1 is non-sensitive

00:07:49,680 --> 00:07:53,520
data and

00:07:50,400 --> 00:07:56,000
c2 is sensitive data and

00:07:53,520 --> 00:07:57,199
the red parts also called the encryption

00:07:56,000 --> 00:08:00,479
path

00:07:57,199 --> 00:08:02,879
public application which can be sparked

00:08:00,479 --> 00:08:04,240
have a price though it invokes the

00:08:02,879 --> 00:08:07,280
pocket library

00:08:04,240 --> 00:08:08,319
with column encryption support and it

00:08:07,280 --> 00:08:11,599
tells is that

00:08:08,319 --> 00:08:14,319
the c2 is sensitive please encrypt it

00:08:11,599 --> 00:08:16,319
and here is the key now procreate with

00:08:14,319 --> 00:08:17,840
economy encrypted functionality

00:08:16,319 --> 00:08:19,680
which is implemented in the property

00:08:17,840 --> 00:08:23,039
1178 will

00:08:19,680 --> 00:08:25,680
encrypt the data using aes and also

00:08:23,039 --> 00:08:26,720
store the key metadata along with the

00:08:25,680 --> 00:08:29,440
encrypted data

00:08:26,720 --> 00:08:29,919
and ascended to the storage when the

00:08:29,440 --> 00:08:33,279
data

00:08:29,919 --> 00:08:35,839
is sent to the air it is encrypted

00:08:33,279 --> 00:08:37,200
so you can imagine you get intersect in

00:08:35,839 --> 00:08:40,080
the middle in the air

00:08:37,200 --> 00:08:40,959
it is still protected the storage can be

00:08:40,080 --> 00:08:44,159
hdfs

00:08:40,959 --> 00:08:45,680
s3 gcs etc so it doesn't make

00:08:44,159 --> 00:08:48,640
it doesn't make difference from the

00:08:45,680 --> 00:08:51,760
encryption perspective here

00:08:48,640 --> 00:08:52,959
on the ink on the decryption path when

00:08:51,760 --> 00:08:56,160
the program file

00:08:52,959 --> 00:09:00,640
is read the key metadata will tell

00:08:56,160 --> 00:09:02,080
the reader that the column is increased

00:09:00,640 --> 00:09:04,640
a clue find out the key

00:09:02,080 --> 00:09:06,640
the clue is a crypto metadata which

00:09:04,640 --> 00:09:10,160
includes the key metadata like key

00:09:06,640 --> 00:09:13,200
index key id conversion etc

00:09:10,160 --> 00:09:13,200
that are so that

00:09:14,480 --> 00:09:18,080
with this information the reader should

00:09:16,880 --> 00:09:21,279
be able to contact

00:09:18,080 --> 00:09:24,240
the key management service or called qms

00:09:21,279 --> 00:09:25,279
to get the key and pass it to the to

00:09:24,240 --> 00:09:28,240
pocket library

00:09:25,279 --> 00:09:30,240
if you don't have permission to the key

00:09:28,240 --> 00:09:33,200
focus just decrypt it

00:09:30,240 --> 00:09:34,800
now if user doesn't have permission the

00:09:33,200 --> 00:09:38,160
application will receive

00:09:34,800 --> 00:09:39,839
access denied exception or a mask the

00:09:38,160 --> 00:09:42,240
value if you have data masking

00:09:39,839 --> 00:09:45,200
functionality for data masking paper

00:09:42,240 --> 00:09:45,200
we'll talk about later

00:09:47,360 --> 00:09:51,200
from the last slide conceptually their

00:09:50,320 --> 00:09:54,560
encryption

00:09:51,200 --> 00:09:56,320
and decryption is clear but when it is a

00:09:54,560 --> 00:09:59,440
ruler to quarantines

00:09:56,320 --> 00:10:01,600
to productions like spark hyperester

00:09:59,440 --> 00:10:03,279
you will find out several props need to

00:10:01,600 --> 00:10:05,440
be solved first

00:10:03,279 --> 00:10:08,079
you need to define which column is

00:10:05,440 --> 00:10:09,279
sensitive and what key to be used to

00:10:08,079 --> 00:10:10,959
encrypt

00:10:09,279 --> 00:10:12,320
and approach data key to the pocket

00:10:10,959 --> 00:10:14,480
library

00:10:12,320 --> 00:10:16,399
what we find out is that it is

00:10:14,480 --> 00:10:19,680
convenient to just define

00:10:16,399 --> 00:10:23,200
those information along with the schema

00:10:19,680 --> 00:10:24,560
so we extend existing schema for crypto

00:10:23,200 --> 00:10:27,519
settings

00:10:24,560 --> 00:10:28,240
and extend proper writer support to

00:10:27,519 --> 00:10:31,040
attach

00:10:28,240 --> 00:10:33,200
the crypto settings to focus schema and

00:10:31,040 --> 00:10:36,560
developed a crypto retriever

00:10:33,200 --> 00:10:38,800
as a plugin to activate the encryption

00:10:36,560 --> 00:10:41,519
based on the settings that we defined

00:10:38,800 --> 00:10:44,000
earlier in the schema

00:10:41,519 --> 00:10:45,120
in the diagram the application defined

00:10:44,000 --> 00:10:48,000
schema we

00:10:45,120 --> 00:10:50,079
with the encrypting settings in metadata

00:10:48,000 --> 00:10:52,480
or the application can read that

00:10:50,079 --> 00:10:53,519
crypto metadata from somewhere else like

00:10:52,480 --> 00:10:57,440
metadata service

00:10:53,519 --> 00:11:01,279
htms the extended program support

00:10:57,440 --> 00:11:03,360
will attach that setting to poke schema

00:11:01,279 --> 00:11:05,360
and the craft retriever will do the

00:11:03,360 --> 00:11:08,000
magic it will build up the encryption

00:11:05,360 --> 00:11:10,480
properties needed by the property and

00:11:08,000 --> 00:11:12,720
invoke poco api to do the encryption

00:11:10,480 --> 00:11:12,720
work

00:11:13,760 --> 00:11:19,440
quickly encryption has several options

00:11:17,040 --> 00:11:21,120
you can choose whether or not encrypt

00:11:19,440 --> 00:11:23,600
the footer

00:11:21,120 --> 00:11:25,360
encrypt the footer will give you more

00:11:23,600 --> 00:11:27,360
security

00:11:25,360 --> 00:11:28,800
but the column for the column live

00:11:27,360 --> 00:11:31,120
access control

00:11:28,800 --> 00:11:33,600
all the people who need to access any

00:11:31,120 --> 00:11:36,399
columns even for the plain text columns

00:11:33,600 --> 00:11:38,560
they need to access the folder first so

00:11:36,399 --> 00:11:39,120
that will add the complexity if you

00:11:38,560 --> 00:11:42,160
choose

00:11:39,120 --> 00:11:46,000
to encrypt the footer

00:11:42,160 --> 00:11:49,440
for encryption algorithm it supports aes

00:11:46,000 --> 00:11:52,560
gcm and aes ctr

00:11:49,440 --> 00:11:55,680
gcm adds an integrity check on top of

00:11:52,560 --> 00:11:58,720
ctr so you're dating to

00:11:55,680 --> 00:12:01,600
preventing unprivileged reading

00:11:58,720 --> 00:12:03,200
it also prevent malicious mutation to

00:12:01,600 --> 00:12:06,240
the original data so it is

00:12:03,200 --> 00:12:09,279
more secure but it adds more overhead

00:12:06,240 --> 00:12:11,680
and you will see it is slower

00:12:09,279 --> 00:12:12,320
encryption with authentication if you

00:12:11,680 --> 00:12:15,680
use

00:12:12,320 --> 00:12:16,880
aes gcm you can optionally provide some

00:12:15,680 --> 00:12:20,320
additional authentic

00:12:16,880 --> 00:12:23,600
data called aad if the unprivileged

00:12:20,320 --> 00:12:26,480
reader cannot provide the correct id

00:12:23,600 --> 00:12:26,800
then it will fail so it is more secure

00:12:26,480 --> 00:12:29,839
but

00:12:26,800 --> 00:12:30,880
again it will add more complexity so you

00:12:29,839 --> 00:12:33,040
can choose

00:12:30,880 --> 00:12:34,880
the different options usually is a

00:12:33,040 --> 00:12:39,760
trade-off between the security

00:12:34,880 --> 00:12:43,200
and complexity and overhead

00:12:39,760 --> 00:12:46,000
now back to presto presto supports

00:12:43,200 --> 00:12:47,360
several file formats particularly for

00:12:46,000 --> 00:12:50,720
column file format

00:12:47,360 --> 00:12:54,000
pokey and oracy price to rewrite

00:12:50,720 --> 00:12:57,519
poker readers for optimization like

00:12:54,000 --> 00:13:00,800
nested compounding lazy read predict

00:12:57,519 --> 00:13:03,440
push down a lot of others

00:13:00,800 --> 00:13:05,519
these are all great work but as i said

00:13:03,440 --> 00:13:07,440
earlier because of this rewriting

00:13:05,519 --> 00:13:09,519
the changes we made for the column

00:13:07,440 --> 00:13:12,560
encryption in the poke library

00:13:09,519 --> 00:13:13,120
which mr repository will need to be

00:13:12,560 --> 00:13:17,040
ported

00:13:13,120 --> 00:13:17,040
to the presto copy reader

00:13:18,160 --> 00:13:23,920
here are the changes needed to support

00:13:21,760 --> 00:13:26,160
for quick column decryption for read

00:13:23,920 --> 00:13:30,560
impression

00:13:26,160 --> 00:13:33,920
first upgrade poke format to version 2.7

00:13:30,560 --> 00:13:36,000
poke format is a specification pokemar

00:13:33,920 --> 00:13:38,320
progressive plus plus and other public

00:13:36,000 --> 00:13:41,519
writers or readers like presto

00:13:38,320 --> 00:13:44,480
all follow the same specification

00:13:41,519 --> 00:13:45,440
column encryption feature in procreate

00:13:44,480 --> 00:13:48,079
changed

00:13:45,440 --> 00:13:48,639
focus specification so it needs to add

00:13:48,079 --> 00:13:51,519
several

00:13:48,639 --> 00:13:53,120
fields like crypto metadata encryption

00:13:51,519 --> 00:13:55,120
organism etc

00:13:53,120 --> 00:13:57,600
so this change is released in poke

00:13:55,120 --> 00:13:59,600
format 2.7

00:13:57,600 --> 00:14:01,040
second change is to put column

00:13:59,600 --> 00:14:04,079
encryption changes

00:14:01,040 --> 00:14:05,680
from pokemon revo to procreate crystal

00:14:04,079 --> 00:14:08,639
pocket reader

00:14:05,680 --> 00:14:10,880
as i mentioned earlier because presto

00:14:08,639 --> 00:14:12,320
rewrite the popularity code so we need

00:14:10,880 --> 00:14:15,040
the relative chain input

00:14:12,320 --> 00:14:16,079
mr to be in the price the poker reader

00:14:15,040 --> 00:14:18,480
currently we are using

00:14:16,079 --> 00:14:20,160
presto for reading data only so we will

00:14:18,480 --> 00:14:23,040
start with the decryption first

00:14:20,160 --> 00:14:24,720
so all the code changes we have you know

00:14:23,040 --> 00:14:26,959
we made has been drawn out

00:14:24,720 --> 00:14:29,839
to production for quite a while they are

00:14:26,959 --> 00:14:33,120
pretty stable now

00:14:29,839 --> 00:14:35,040
presto will support etl for right uh we

00:14:33,120 --> 00:14:35,920
have a plan to power the encrypted code

00:14:35,040 --> 00:14:39,279
soon

00:14:35,920 --> 00:14:42,079
keep tuned please the third change

00:14:39,279 --> 00:14:43,680
is implementation of the crypto property

00:14:42,079 --> 00:14:45,600
factory as a plugin

00:14:43,680 --> 00:14:47,120
so in the previous slides we talked

00:14:45,600 --> 00:14:50,079
about craft retriever

00:14:47,120 --> 00:14:50,880
which is a plug-in and also a wrapper to

00:14:50,079 --> 00:14:53,360
shield

00:14:50,880 --> 00:14:54,320
all the encryption details include

00:14:53,360 --> 00:14:56,880
including

00:14:54,320 --> 00:14:58,320
wrapping up the tms client configuration

00:14:56,880 --> 00:15:00,800
for encrypting properties

00:14:58,320 --> 00:15:03,120
etc so let's talk about that in the next

00:15:00,800 --> 00:15:03,120
slides

00:15:06,160 --> 00:15:11,360
so for quick 1817 it defines the

00:15:09,440 --> 00:15:15,120
creditor

00:15:11,360 --> 00:15:15,920
factor which is interface it is a common

00:15:15,120 --> 00:15:18,000
interface

00:15:15,920 --> 00:15:19,199
for loading file encryption and

00:15:18,000 --> 00:15:21,360
decryption

00:15:19,199 --> 00:15:23,279
it makes encryption and decrypting

00:15:21,360 --> 00:15:26,320
details transparent

00:15:23,279 --> 00:15:28,720
to analytics frameworks and it

00:15:26,320 --> 00:15:30,720
leveraged property model encryption

00:15:28,720 --> 00:15:34,959
which is property1178

00:15:30,720 --> 00:15:37,040
with minimum changes the relation of

00:15:34,959 --> 00:15:38,320
these components described in this

00:15:37,040 --> 00:15:41,199
diagram

00:15:38,320 --> 00:15:42,240
presto as a service and it has pocket

00:15:41,199 --> 00:15:43,920
library

00:15:42,240 --> 00:15:47,320
this library has the encrypted

00:15:43,920 --> 00:15:49,759
functionality which implements

00:15:47,320 --> 00:15:52,560
property1178

00:15:49,759 --> 00:15:54,320
it implements basic building blocks for

00:15:52,560 --> 00:15:58,880
encryption and decryption

00:15:54,320 --> 00:16:02,480
for example aes encryption using the key

00:15:58,880 --> 00:16:04,880
that api passed in those apis allow you

00:16:02,480 --> 00:16:08,320
to pass in the encryption properties

00:16:04,880 --> 00:16:10,959
encryption keys etc that means you apply

00:16:08,320 --> 00:16:11,680
your application code in this case press

00:16:10,959 --> 00:16:14,160
the code

00:16:11,680 --> 00:16:14,959
need to change to do all the dirty work

00:16:14,160 --> 00:16:17,519
and all

00:16:14,959 --> 00:16:18,000
and call the modified pocket agi to pass

00:16:17,519 --> 00:16:20,399
in

00:16:18,000 --> 00:16:21,040
those properties not just presto or

00:16:20,399 --> 00:16:24,240
other

00:16:21,040 --> 00:16:27,600
applications like spark

00:16:24,240 --> 00:16:28,320
hive etc we need to do the same so we

00:16:27,600 --> 00:16:30,320
decide to

00:16:28,320 --> 00:16:31,360
abstract to another layer as an

00:16:30,320 --> 00:16:34,959
interview

00:16:31,360 --> 00:16:38,320
so that user can develop as a plugin

00:16:34,959 --> 00:16:41,519
that will be portable and can be shared

00:16:38,320 --> 00:16:43,440
across applications so we implement this

00:16:41,519 --> 00:16:45,600
plug-in called the crypto retriever

00:16:43,440 --> 00:16:46,560
and it is used for price to have and

00:16:45,600 --> 00:16:49,519
spark

00:16:46,560 --> 00:16:51,040
it wraps up the qms client details and

00:16:49,519 --> 00:16:53,040
the encryption settings like key

00:16:51,040 --> 00:16:54,720
metadata encryption algorithm

00:16:53,040 --> 00:16:56,639
configuration for the you know the

00:16:54,720 --> 00:16:57,839
design options that we talked about in

00:16:56,639 --> 00:16:59,759
the previous slides

00:16:57,839 --> 00:17:02,079
so all of these are wrapped up into a

00:16:59,759 --> 00:17:05,839
plugin and loaded up and loaded by the

00:17:02,079 --> 00:17:05,839
different applications

00:17:06,319 --> 00:17:11,039
here are the standards that we merge our

00:17:08,640 --> 00:17:13,199
changes to the price to open source

00:17:11,039 --> 00:17:14,880
overall the standards is we just started

00:17:13,199 --> 00:17:17,280
the first one is upgrade the pro

00:17:14,880 --> 00:17:19,280
conversion to 1.11

00:17:17,280 --> 00:17:20,640
uh and the parting of the encrypting

00:17:19,280 --> 00:17:24,959
code is tracked by their

00:17:20,640 --> 00:17:26,959
issue 12048 the decryption code change

00:17:24,959 --> 00:17:29,200
will be emerged soon after

00:17:26,959 --> 00:17:30,160
conversion upgrading and the encryption

00:17:29,200 --> 00:17:33,280
part is

00:17:30,160 --> 00:17:36,000
under planning

00:17:33,280 --> 00:17:37,200
now i will hand it over to pv to talk

00:17:36,000 --> 00:17:41,679
about the tms

00:17:37,200 --> 00:17:41,679
and data masking how will you stop

00:17:44,840 --> 00:17:47,840
sharing

00:17:50,400 --> 00:17:53,440
um are you able to see my screen yeah

00:17:52,559 --> 00:17:56,559
good

00:17:53,440 --> 00:17:59,679
okay okay so now let's talk about

00:17:56,559 --> 00:18:01,760
um how we will manage the encryption

00:17:59,679 --> 00:18:04,240
keys which are actually necessary to do

00:18:01,760 --> 00:18:06,799
the actual encryption and decryption

00:18:04,240 --> 00:18:07,679
so first of all the parking encryption

00:18:06,799 --> 00:18:09,360
implementation

00:18:07,679 --> 00:18:12,000
isn't actually restricted to any

00:18:09,360 --> 00:18:14,640
particular key management solution

00:18:12,000 --> 00:18:16,080
and it's designed so any kms could be

00:18:14,640 --> 00:18:18,720
used and plugged in

00:18:16,080 --> 00:18:20,640
to do the job of key management uh the

00:18:18,720 --> 00:18:21,440
actual key metadata that's relevant to

00:18:20,640 --> 00:18:24,000
parquet

00:18:21,440 --> 00:18:24,880
to encrypt the data is just a generic

00:18:24,000 --> 00:18:28,080
byte array

00:18:24,880 --> 00:18:28,960
which maps to a key in any kms basically

00:18:28,080 --> 00:18:31,120
you're free to

00:18:28,960 --> 00:18:32,880
choose from the vast array of any kms

00:18:31,120 --> 00:18:34,240
offering and some examples include the

00:18:32,880 --> 00:18:37,360
hadoop kms

00:18:34,240 --> 00:18:43,360
ranger kms and several cloud kms

00:18:37,360 --> 00:18:45,360
providers like aws kms and many others

00:18:43,360 --> 00:18:46,960
okay now let's take a closer look at the

00:18:45,360 --> 00:18:50,080
integration between the

00:18:46,960 --> 00:18:51,360
key management and presto so this

00:18:50,080 --> 00:18:53,360
integration is controlled through a

00:18:51,360 --> 00:18:56,160
plug-in which is added to presto

00:18:53,360 --> 00:18:57,520
to support column encrypted tables

00:18:56,160 --> 00:18:59,520
essentially this plugin

00:18:57,520 --> 00:19:01,200
is just a wrapper of a kms client and

00:18:59,520 --> 00:19:02,960
it's responsible for taking the key

00:19:01,200 --> 00:19:06,240
metadata

00:19:02,960 --> 00:19:08,000
from parquet and retrieving the

00:19:06,240 --> 00:19:09,520
encryption and decryption keys from the

00:19:08,000 --> 00:19:11,360
kms

00:19:09,520 --> 00:19:13,280
it also has a job of serializing and

00:19:11,360 --> 00:19:16,320
deserializing key metadata into a byte

00:19:13,280 --> 00:19:17,919
array which can be stored by parquet

00:19:16,320 --> 00:19:19,520
and lastly the plugin controls

00:19:17,919 --> 00:19:21,200
additional encryption properties like

00:19:19,520 --> 00:19:24,240
setting the encryption algorithm

00:19:21,200 --> 00:19:26,640
like aes encryption and different types

00:19:24,240 --> 00:19:28,400
of footer encryption modes

00:19:26,640 --> 00:19:30,480
i want to highlight that all the key

00:19:28,400 --> 00:19:32,320
metadata required to read an encrypted

00:19:30,480 --> 00:19:34,400
parquet file

00:19:32,320 --> 00:19:36,000
is stored alongside the encrypted data

00:19:34,400 --> 00:19:37,840
in the parking metadata

00:19:36,000 --> 00:19:39,760
and this is important uh because

00:19:37,840 --> 00:19:40,160
insurers uh that the encrypted data is

00:19:39,760 --> 00:19:42,720
never

00:19:40,160 --> 00:19:44,160
separated from the keys and we never end

00:19:42,720 --> 00:19:45,120
up in a situation where you have

00:19:44,160 --> 00:19:46,640
encrypted data

00:19:45,120 --> 00:19:49,360
and you don't know which key should be

00:19:46,640 --> 00:19:52,080
used to decrypt it

00:19:49,360 --> 00:19:54,080
and lastly the kms is important because

00:19:52,080 --> 00:19:57,600
this is actually how we control

00:19:54,080 --> 00:20:00,080
who gets access to what data

00:19:57,600 --> 00:20:01,360
we basically set the apples on the key

00:20:00,080 --> 00:20:03,120
and

00:20:01,360 --> 00:20:05,760
users are able to read data based on if

00:20:03,120 --> 00:20:07,360
they can access the key

00:20:05,760 --> 00:20:09,280
all right so what kind of performance

00:20:07,360 --> 00:20:12,240
overhead are we paying in order to get

00:20:09,280 --> 00:20:13,440
all these benefits of column level and

00:20:12,240 --> 00:20:15,280
access control

00:20:13,440 --> 00:20:17,039
so our performance testing indicates

00:20:15,280 --> 00:20:19,840
roughly a 5.7

00:20:17,039 --> 00:20:21,520
right overhead and a 3.7 read overhead

00:20:19,840 --> 00:20:22,960
for column encryption

00:20:21,520 --> 00:20:25,120
and if you break this down it comes down

00:20:22,960 --> 00:20:26,159
to two parts one part is the round trip

00:20:25,120 --> 00:20:28,559
time

00:20:26,159 --> 00:20:30,159
to retrieve the keys from the kms and

00:20:28,559 --> 00:20:31,679
the second part is actual encrypting and

00:20:30,159 --> 00:20:33,840
decrypting time

00:20:31,679 --> 00:20:35,520
and we found that the network round trip

00:20:33,840 --> 00:20:37,200
to the kms was minimal in our case

00:20:35,520 --> 00:20:39,120
because of good caching and

00:20:37,200 --> 00:20:41,039
low latency corporate internet

00:20:39,120 --> 00:20:42,240
deployment and the majority of this

00:20:41,039 --> 00:20:44,480
overhead is spent on the actual

00:20:42,240 --> 00:20:46,720
encrypting and decrypting process

00:20:44,480 --> 00:20:48,000
also i want to highlight that we test

00:20:46,720 --> 00:20:50,880
this on the table with 60

00:20:48,000 --> 00:20:51,200
commons encrypted and often you'll find

00:20:50,880 --> 00:20:53,280
that

00:20:51,200 --> 00:20:54,400
a lot of tables have a much lower

00:20:53,280 --> 00:20:55,039
percentage of columns that need to be

00:20:54,400 --> 00:20:57,039
encrypted

00:20:55,039 --> 00:20:59,360
and this overhead decreases as a result

00:20:57,039 --> 00:20:59,360
of that

00:21:00,320 --> 00:21:03,760
okay now i want to talk about the some

00:21:01,919 --> 00:21:07,520
active work we're doing uh

00:21:03,760 --> 00:21:09,840
related to data masking um

00:21:07,520 --> 00:21:10,880
so what is data masking data masking is

00:21:09,840 --> 00:21:13,200
just the process

00:21:10,880 --> 00:21:15,600
of obfuscating sensitive data to users

00:21:13,200 --> 00:21:17,039
who do not have access to a column

00:21:15,600 --> 00:21:18,880
and if this isn't completely clear what

00:21:17,039 --> 00:21:20,640
this looks like don't worry

00:21:18,880 --> 00:21:22,000
we'll look at some examples of data mask

00:21:20,640 --> 00:21:24,320
queries in the next few slides which

00:21:22,000 --> 00:21:27,679
will make it more clear

00:21:24,320 --> 00:21:29,440
so why do we need data masking

00:21:27,679 --> 00:21:31,120
basically it potentially allows users to

00:21:29,440 --> 00:21:33,440
do useful things without compromising

00:21:31,120 --> 00:21:35,679
the actual content of the data

00:21:33,440 --> 00:21:37,360
additionally it can improve the overall

00:21:35,679 --> 00:21:40,559
user experience of using common grip

00:21:37,360 --> 00:21:42,080
tables because this is because if a user

00:21:40,559 --> 00:21:44,559
tries to access

00:21:42,080 --> 00:21:45,919
uh uh an encrypted column which they

00:21:44,559 --> 00:21:47,600
don't have access to we can give them

00:21:45,919 --> 00:21:50,400
mass values instead of rejecting the

00:21:47,600 --> 00:21:50,400
queries outright

00:21:51,280 --> 00:21:55,120
okay so i'll go over the different types

00:21:53,200 --> 00:21:56,400
of mass and what they generally do and

00:21:55,120 --> 00:21:58,960
then we'll dive into the

00:21:56,400 --> 00:22:00,159
pros and cons of each type of mass so

00:21:58,960 --> 00:22:01,600
here are some of the mass that we're

00:22:00,159 --> 00:22:03,760
supporting right now so first we have

00:22:01,600 --> 00:22:05,120
the null mass which displays null values

00:22:03,760 --> 00:22:06,159
if a user doesn't have permission to a

00:22:05,120 --> 00:22:08,000
column

00:22:06,159 --> 00:22:09,919
we have the hash mask we can which can

00:22:08,000 --> 00:22:11,520
display precomputed hash values

00:22:09,919 --> 00:22:13,280
we have the redact mask which can

00:22:11,520 --> 00:22:15,440
display predefined

00:22:13,280 --> 00:22:16,640
redacted data if the user doesn't have x

00:22:15,440 --> 00:22:18,559
and then finally we have user defined

00:22:16,640 --> 00:22:21,200
mask which allows table owners to define

00:22:18,559 --> 00:22:23,200
custom masks on their data

00:22:21,200 --> 00:22:24,240
okay so what does the null mask look

00:22:23,200 --> 00:22:26,159
like

00:22:24,240 --> 00:22:28,000
uh so here's an example on the right of

00:22:26,159 --> 00:22:29,120
a null mass query so here we're

00:22:28,000 --> 00:22:31,600
selecting from

00:22:29,120 --> 00:22:32,480
some db table and we're selecting all

00:22:31,600 --> 00:22:33,679
the columns

00:22:32,480 --> 00:22:35,760
and then the address column is

00:22:33,679 --> 00:22:38,720
considered sensitive so uh

00:22:35,760 --> 00:22:39,600
it's bolded and here in this query we

00:22:38,720 --> 00:22:41,520
get back

00:22:39,600 --> 00:22:43,120
actual values for id and language and

00:22:41,520 --> 00:22:44,799
since the address columns is sensitive

00:22:43,120 --> 00:22:47,120
and this user doesn't have access

00:22:44,799 --> 00:22:48,720
they get back nulls instead and the

00:22:47,120 --> 00:22:50,400
advantage of the null mask is really

00:22:48,720 --> 00:22:52,080
that it's very simple and it's the bare

00:22:50,400 --> 00:22:53,760
minimum of data masking

00:22:52,080 --> 00:22:55,919
however there's a few limitations such

00:22:53,760 --> 00:22:57,840
as no joint ability between mass data

00:22:55,919 --> 00:22:59,679
there's possibly of confusion between

00:22:57,840 --> 00:23:02,159
real nulls and mass nulls

00:22:59,679 --> 00:23:04,559
and there's the inability to support

00:23:02,159 --> 00:23:06,400
non-nullable columns

00:23:04,559 --> 00:23:10,400
next we have a hash mask and again we

00:23:06,400 --> 00:23:10,400
have a similar query

00:23:10,480 --> 00:23:16,159
test query and here we get hashed values

00:23:13,600 --> 00:23:17,440
as a result rather than real values and

00:23:16,159 --> 00:23:19,360
again

00:23:17,440 --> 00:23:21,280
so the big advantage with the hash mask

00:23:19,360 --> 00:23:22,000
is that now table joins are possible

00:23:21,280 --> 00:23:24,880
even if the user

00:23:22,000 --> 00:23:27,120
doesn't have access to the column so we

00:23:24,880 --> 00:23:29,919
can join between tables on the

00:23:27,120 --> 00:23:32,240
hashed values and this allows users to

00:23:29,919 --> 00:23:34,320
do potentially useful things

00:23:32,240 --> 00:23:36,080
however there's some limitations like

00:23:34,320 --> 00:23:36,640
this is an inefficient use of storage

00:23:36,080 --> 00:23:39,200
because

00:23:36,640 --> 00:23:40,400
we have to pre-compute these hash values

00:23:39,200 --> 00:23:42,080
uh

00:23:40,400 --> 00:23:44,880
and we have to store them alongside the

00:23:42,080 --> 00:23:47,200
data in the file

00:23:44,880 --> 00:23:48,240
and lastly we have the redact mask which

00:23:47,200 --> 00:23:50,559
allows

00:23:48,240 --> 00:23:52,480
on the right here we have a query and we

00:23:50,559 --> 00:23:55,360
see that it allows the

00:23:52,480 --> 00:23:57,360
column data to be redacted so that you

00:23:55,360 --> 00:23:58,799
only see a portion of the values

00:23:57,360 --> 00:24:00,640
and the big advantage here is that it's

00:23:58,799 --> 00:24:02,480
human friendly but

00:24:00,640 --> 00:24:04,080
it's not really usable for joins we

00:24:02,480 --> 00:24:06,720
can't really support all types of

00:24:04,080 --> 00:24:07,600
uh data so this makes a lot of sense for

00:24:06,720 --> 00:24:08,880
string values

00:24:07,600 --> 00:24:10,880
but it might not make sense for like

00:24:08,880 --> 00:24:11,840
boolean values and it's an inefficient

00:24:10,880 --> 00:24:14,000
use of storage because we have to

00:24:11,840 --> 00:24:15,600
pre-compute this

00:24:14,000 --> 00:24:16,720
all right here we have some usability

00:24:15,600 --> 00:24:18,000
design considerations that we're taking

00:24:16,720 --> 00:24:21,039
into account as we roll this

00:24:18,000 --> 00:24:22,799
out uh the first thing is that uh

00:24:21,039 --> 00:24:24,480
queries are run by both humans and data

00:24:22,799 --> 00:24:26,480
and machines so

00:24:24,480 --> 00:24:27,919
data mask queries uh when we're

00:24:26,480 --> 00:24:29,600
designing data masking we have to take

00:24:27,919 --> 00:24:30,400
into account that not all of our users

00:24:29,600 --> 00:24:32,720
are humans

00:24:30,400 --> 00:24:33,600
and this affects our design another

00:24:32,720 --> 00:24:37,200
thing we have to be

00:24:33,600 --> 00:24:39,679
uh cognizant about is that communicating

00:24:37,200 --> 00:24:42,640
the mass values versus real values for

00:24:39,679 --> 00:24:42,640
example null mask

00:24:43,279 --> 00:24:47,679
the user needs to know if this is a null

00:24:45,679 --> 00:24:48,320
resulting from a mask or if it's a real

00:24:47,679 --> 00:24:49,760
null

00:24:48,320 --> 00:24:52,000
and we want to make sure we avoid

00:24:49,760 --> 00:24:53,679
surprising users as much as possible

00:24:52,000 --> 00:24:55,200
and this comes into play when we're

00:24:53,679 --> 00:24:57,520
rolling out we want to make sure as we

00:24:55,200 --> 00:25:01,120
roll out users aren't surprised by these

00:24:57,520 --> 00:25:03,279
uh null values or mass values

00:25:01,120 --> 00:25:05,039
okay to recap column level encryption

00:25:03,279 --> 00:25:06,240
enables finding control over your data

00:25:05,039 --> 00:25:08,240
sets

00:25:06,240 --> 00:25:10,640
we control permissions through the kms

00:25:08,240 --> 00:25:12,240
by controlling axles on the keys

00:25:10,640 --> 00:25:14,640
all the parking encryption details are

00:25:12,240 --> 00:25:16,000
wrapped up in our parquet in the parquet

00:25:14,640 --> 00:25:17,440
code as well as the presto parking

00:25:16,000 --> 00:25:19,520
implementation

00:25:17,440 --> 00:25:20,960
uh data masking is currently in poc as

00:25:19,520 --> 00:25:23,120
we're rolling it out

00:25:20,960 --> 00:25:24,080
and we're merging all of this the merge

00:25:23,120 --> 00:25:27,440
to open source

00:25:24,080 --> 00:25:29,520
presto is underway and lastly we're

00:25:27,440 --> 00:25:31,279
hiring and you can feel free to apply

00:25:29,520 --> 00:25:32,480
on this link if this uh kind of work is

00:25:31,279 --> 00:25:34,640
interesting to you or forward your

00:25:32,480 --> 00:25:36,080
resume to shanley

00:25:34,640 --> 00:25:38,159
so i think we have a minute to do

00:25:36,080 --> 00:25:39,919
questions now

00:25:38,159 --> 00:25:41,279
and there's one question that hasn't

00:25:39,919 --> 00:25:42,080
been answered if you can just take a

00:25:41,279 --> 00:25:43,919
look at that one

00:25:42,080 --> 00:25:45,919
is encryption of columns on each

00:25:43,919 --> 00:25:48,080
individual value or a whole block of

00:25:45,919 --> 00:25:49,360
values as a genetic and the second part

00:25:48,080 --> 00:25:51,600
of the same question is

00:25:49,360 --> 00:25:52,720
is key rotation supported yeah that's a

00:25:51,600 --> 00:25:54,320
good question so

00:25:52,720 --> 00:25:56,080
it's actually a block of values and

00:25:54,320 --> 00:25:58,080
that's actually an important point

00:25:56,080 --> 00:25:59,200
because if it was if it was each

00:25:58,080 --> 00:26:01,120
individual value

00:25:59,200 --> 00:26:02,559
there could be problems or there could

00:26:01,120 --> 00:26:05,840
be concerns about

00:26:02,559 --> 00:26:07,360
uh like encryption between two values

00:26:05,840 --> 00:26:08,720
that are the same allowing like some

00:26:07,360 --> 00:26:10,799
sort of attacker to

00:26:08,720 --> 00:26:12,400
be able to correlate values but since

00:26:10,799 --> 00:26:13,520
it's a block we kind of avoid that

00:26:12,400 --> 00:26:15,600
concern

00:26:13,520 --> 00:26:17,360
uh and then for key rotation yeah kms

00:26:15,600 --> 00:26:20,080
supports key rotation

00:26:17,360 --> 00:26:20,960
and uh you can set up processes to

00:26:20,080 --> 00:26:22,799
regularly

00:26:20,960 --> 00:26:24,720
rotate your keys every week or something

00:26:22,799 --> 00:26:25,600
like that yeah just just add a little

00:26:24,720 --> 00:26:28,720
bit about the

00:26:25,600 --> 00:26:31,840
first one the encryption is happening

00:26:28,720 --> 00:26:32,640
in the page level so the page is a you

00:26:31,840 --> 00:26:36,320
need

00:26:32,640 --> 00:26:39,600
for encoding compression and encryption

00:26:36,320 --> 00:26:39,600

YouTube URL: https://www.youtube.com/watch?v=lnk4M94_Wg4


