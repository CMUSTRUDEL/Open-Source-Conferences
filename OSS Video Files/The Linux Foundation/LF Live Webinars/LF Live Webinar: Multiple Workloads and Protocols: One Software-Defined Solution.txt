Title: LF Live Webinar: Multiple Workloads and Protocols: One Software-Defined Solution
Publication date: 2021-06-22
Playlist: LF Live Webinars
Description: 
	LF Live Webinar: Multiple Workloads and Protocols: One Software-Defined Solution

Sponsored by KIOXIA

Applications in cloud and hyperscale data centers change over time as new workloads start, increase, or decrease in activity. These applications have differing storage requirements to best accommodate the varied workloads. This leads to data centers procuring and managing an inventory of many different storage devices with varying performance profiles and protocols. This is a thankless, complicated, and error-prone task.

This webinar will:
Introduce and demonstrate a new way of unifying flash storage via an open source, software-defined, multi-protocol solution to better manage the requirements of multiple workloads and protocols.
Demonstrate how this new method will simplify the deployment of flash storage at hyperscale level, enhancing TCO while reducing inventory management headaches.
Captions: 
	00:00:03,919 --> 00:00:06,480
so

00:00:04,400 --> 00:00:07,839
good morning or i guess good afternoon

00:00:06,480 --> 00:00:10,080
or good evening to everybody

00:00:07,839 --> 00:00:11,679
uh i'd like to start off by thanking

00:00:10,080 --> 00:00:13,519
cassandra and the linux foundation for

00:00:11,679 --> 00:00:15,759
hosting this webinar

00:00:13,519 --> 00:00:17,119
um i am of course scott stetzer i work

00:00:15,759 --> 00:00:20,960
for keoksian

00:00:17,119 --> 00:00:22,960
uh one of the largest uh flash vendors

00:00:20,960 --> 00:00:24,480
and foundries out there and the inventor

00:00:22,960 --> 00:00:26,720
of flash memory

00:00:24,480 --> 00:00:26,720
uh

00:00:28,160 --> 00:00:33,040
so our talk today is about

00:00:30,720 --> 00:00:35,120
multi-protocol capabilities

00:00:33,040 --> 00:00:36,399
and how do we bring flash into the world

00:00:35,120 --> 00:00:38,559
of being able to support

00:00:36,399 --> 00:00:40,559
multiple protocols using a software

00:00:38,559 --> 00:00:42,960
defined flash api

00:00:40,559 --> 00:00:44,559
and of course open source is important

00:00:42,960 --> 00:00:46,480
software is important

00:00:44,559 --> 00:00:47,920
so this whole approach to a software

00:00:46,480 --> 00:00:50,160
defined flash api

00:00:47,920 --> 00:00:51,680
is relatively new that we'd like to

00:00:50,160 --> 00:00:53,760
introduce

00:00:51,680 --> 00:00:54,960
we've done a couple of presentations in

00:00:53,760 --> 00:00:57,440
the past

00:00:54,960 --> 00:00:58,879
this is not particularly new but the

00:00:57,440 --> 00:01:01,520
idea of showing you how

00:00:58,879 --> 00:01:02,719
multi-protocol is going to work using

00:01:01,520 --> 00:01:07,119
this flash api

00:01:02,719 --> 00:01:09,680
is a new aspect of the presentation

00:01:07,119 --> 00:01:11,600
we know today hyperscaling cloud is all

00:01:09,680 --> 00:01:13,600
built on being software defined

00:01:11,600 --> 00:01:15,200
software is actually out there eating

00:01:13,600 --> 00:01:16,400
the world and that's actually a good

00:01:15,200 --> 00:01:19,920
thing for all of the

00:01:16,400 --> 00:01:22,080
software developers out there now

00:01:19,920 --> 00:01:23,520
there's been a number of very successful

00:01:22,080 --> 00:01:25,600
software-defined approaches to

00:01:23,520 --> 00:01:27,920
redefining how hardware works

00:01:25,600 --> 00:01:30,560
i think the most notable one has been

00:01:27,920 --> 00:01:33,439
software defined networking

00:01:30,560 --> 00:01:34,880
that's been a big success out there

00:01:33,439 --> 00:01:36,479
there's also software defined

00:01:34,880 --> 00:01:38,320
computation

00:01:36,479 --> 00:01:39,600
emulation for different types of cpus

00:01:38,320 --> 00:01:40,880
and processors

00:01:39,600 --> 00:01:43,680
software-defined hardware and

00:01:40,880 --> 00:01:46,560
software-defined storage as well

00:01:43,680 --> 00:01:48,040
although that last step that last mile

00:01:46,560 --> 00:01:49,439
of connection to being fully

00:01:48,040 --> 00:01:51,439
software-defined

00:01:49,439 --> 00:01:52,880
is missing that lowest level component

00:01:51,439 --> 00:01:56,479
the storage component

00:01:52,880 --> 00:01:58,799
and in our case that flash ssd

00:01:56,479 --> 00:02:00,799
so we believe it's time to bring that

00:01:58,799 --> 00:02:04,399
flash ssd

00:02:00,799 --> 00:02:06,640
into the software defined realm and

00:02:04,399 --> 00:02:08,000
enable that capability for you the

00:02:06,640 --> 00:02:11,119
developer to define how

00:02:08,000 --> 00:02:11,119
your storage can work

00:02:11,680 --> 00:02:15,120
and why doesn't it work that way today

00:02:14,400 --> 00:02:17,200
if we look

00:02:15,120 --> 00:02:19,599
back in our history all the way back to

00:02:17,200 --> 00:02:21,440
the ancient times the 1980s

00:02:19,599 --> 00:02:22,879
computer storage was based on a hard

00:02:21,440 --> 00:02:26,000
drive and this

00:02:22,879 --> 00:02:28,560
legacy drive is

00:02:26,000 --> 00:02:29,520
still valid today it's still important

00:02:28,560 --> 00:02:31,519
today

00:02:29,520 --> 00:02:33,519
the challenge though was that legacy

00:02:31,519 --> 00:02:35,519
drive was a very mechanical thing it was

00:02:33,519 --> 00:02:38,560
a rotating magnetic storage

00:02:35,519 --> 00:02:40,480
in a somewhat linear fashion which meant

00:02:38,560 --> 00:02:42,800
there really wasn't a lot of ability to

00:02:40,480 --> 00:02:44,080
adapt that storage mechanism using

00:02:42,800 --> 00:02:46,640
software

00:02:44,080 --> 00:02:48,400
it was a black box it's a fairly

00:02:46,640 --> 00:02:51,200
inflexible in terms of being able to

00:02:48,400 --> 00:02:53,519
adapt or change how it behaves

00:02:51,200 --> 00:02:55,120
in the compute environment which means

00:02:53,519 --> 00:02:56,319
it's somewhat limited especially an

00:02:55,120 --> 00:02:58,959
aspect to doing things in a

00:02:56,319 --> 00:03:02,800
software-defined way

00:02:58,959 --> 00:03:02,800
now traditionally

00:03:02,879 --> 00:03:06,080
that backwards compatibility was

00:03:04,720 --> 00:03:09,200
incredibly important

00:03:06,080 --> 00:03:10,319
as flash was introduced uh maybe uh 15

00:03:09,200 --> 00:03:12,640
to 20 years ago

00:03:10,319 --> 00:03:14,480
as a storage medium it was very

00:03:12,640 --> 00:03:17,280
important for flash to come in

00:03:14,480 --> 00:03:19,040
and be plug and play very easy to plug

00:03:17,280 --> 00:03:21,120
in and use just like the

00:03:19,040 --> 00:03:22,959
existing paradigm for storage the hard

00:03:21,120 --> 00:03:25,840
drive

00:03:22,959 --> 00:03:27,680
and we're not going to change the way

00:03:25,840 --> 00:03:29,840
that you approach storage for

00:03:27,680 --> 00:03:31,440
standard devices like your laptop or

00:03:29,840 --> 00:03:34,959
your data center

00:03:31,440 --> 00:03:35,440
server at all they still need that level

00:03:34,959 --> 00:03:37,120
of

00:03:35,440 --> 00:03:39,440
interoperability and backwards

00:03:37,120 --> 00:03:42,159
compatibility

00:03:39,440 --> 00:03:44,080
but for developing applications

00:03:42,159 --> 00:03:46,720
especially cloud and hyperscale

00:03:44,080 --> 00:03:47,920
and self builders trying to adapt

00:03:46,720 --> 00:03:50,560
storage to their

00:03:47,920 --> 00:03:51,599
environments and their applications this

00:03:50,560 --> 00:03:55,200
new approach

00:03:51,599 --> 00:03:58,319
adds an extra quiver in the quill

00:03:55,200 --> 00:04:00,959
or that extra capability in addition to

00:03:58,319 --> 00:04:01,680
the traditional storage interfaces now

00:04:00,959 --> 00:04:05,120
we have the

00:04:01,680 --> 00:04:08,319
legacy protocols and legacy is not a bad

00:04:05,120 --> 00:04:10,080
thing our connections being sas and sata

00:04:08,319 --> 00:04:13,439
and nvme of course

00:04:10,080 --> 00:04:17,680
protocols being block storage protocols

00:04:13,439 --> 00:04:20,160
and the new one zns i do bring in zns

00:04:17,680 --> 00:04:22,479
it i consider it legacy mostly because

00:04:20,160 --> 00:04:24,880
while it's new it's based on an old

00:04:22,479 --> 00:04:26,320
hard drive paradigm of magnetic

00:04:24,880 --> 00:04:29,199
recording

00:04:26,320 --> 00:04:29,919
and again these fixed protocols cannot

00:04:29,199 --> 00:04:31,919
adapt

00:04:29,919 --> 00:04:33,199
or change depending on the application

00:04:31,919 --> 00:04:35,280
requirements

00:04:33,199 --> 00:04:36,479
so we need to think about and bring in a

00:04:35,280 --> 00:04:39,280
whole new approach

00:04:36,479 --> 00:04:42,479
to doing storage in this new

00:04:39,280 --> 00:04:43,520
software-defined world

00:04:42,479 --> 00:04:45,120
if we look at the folks that are

00:04:43,520 --> 00:04:46,720
innovating this is the cloud industry

00:04:45,120 --> 00:04:49,360
and the hyperscalers

00:04:46,720 --> 00:04:52,000
they look at these fixed devices uh as

00:04:49,360 --> 00:04:54,080
being limited by that device protocol

00:04:52,000 --> 00:04:56,160
that means they're they have an

00:04:54,080 --> 00:04:57,360
inability they can't adapt to the change

00:04:56,160 --> 00:05:00,800
in workloads

00:04:57,360 --> 00:05:01,600
easily and simply which means there's a

00:05:00,800 --> 00:05:05,120
complex

00:05:01,600 --> 00:05:06,320
supply chain issue dealing with how to

00:05:05,120 --> 00:05:08,800
populate storage

00:05:06,320 --> 00:05:10,000
in the data centers so let's take a

00:05:08,800 --> 00:05:13,440
closer look at the

00:05:10,000 --> 00:05:13,440
complexity of the supply chain

00:05:14,479 --> 00:05:19,280
if we look at the supply chain different

00:05:17,600 --> 00:05:20,960
applications require different types of

00:05:19,280 --> 00:05:23,039
devices which requires

00:05:20,960 --> 00:05:24,800
the data center source multiple drive

00:05:23,039 --> 00:05:26,800
types and keep that inventory of

00:05:24,800 --> 00:05:29,600
different drive types available

00:05:26,800 --> 00:05:32,080
depending on when and how they need to

00:05:29,600 --> 00:05:34,720
deploy their applications

00:05:32,080 --> 00:05:37,680
and then a particular application may

00:05:34,720 --> 00:05:40,880
want to use that block protocol

00:05:37,680 --> 00:05:43,840
or a zns protocol

00:05:40,880 --> 00:05:45,840
but those protocols and those devices

00:05:43,840 --> 00:05:47,840
can't switch between applications

00:05:45,840 --> 00:05:50,160
very conveniently they're very focused

00:05:47,840 --> 00:05:52,400
on achieving the results in the goals of

00:05:50,160 --> 00:05:54,240
that particular application

00:05:52,400 --> 00:05:57,680
this means it's fixed and it's not very

00:05:54,240 --> 00:05:57,680
flexible in the data center

00:05:58,319 --> 00:06:03,120
so for the as we've brought up this

00:06:01,360 --> 00:06:06,160
topic what if we could make

00:06:03,120 --> 00:06:09,039
flash that digital storage mechanism

00:06:06,160 --> 00:06:09,759
software defined and allow it to be a

00:06:09,039 --> 00:06:12,639
multiple

00:06:09,759 --> 00:06:13,520
protocol type of device so let's take a

00:06:12,639 --> 00:06:16,000
look at what

00:06:13,520 --> 00:06:17,039
or how that might look and how that

00:06:16,000 --> 00:06:20,639
would change that

00:06:17,039 --> 00:06:22,960
sourcing protocol

00:06:20,639 --> 00:06:25,120
so now we use a simplified supply chain

00:06:22,960 --> 00:06:28,000
we simplify the supply chain

00:06:25,120 --> 00:06:30,880
we can source a single based flash

00:06:28,000 --> 00:06:34,560
device a software enabled flash device

00:06:30,880 --> 00:06:35,440
in that inventory we can then go and

00:06:34,560 --> 00:06:37,440
deploy

00:06:35,440 --> 00:06:39,120
that device anywhere in the data center

00:06:37,440 --> 00:06:40,960
for any application

00:06:39,120 --> 00:06:42,800
and bring in that software enabled flash

00:06:40,960 --> 00:06:45,120
api

00:06:42,800 --> 00:06:48,639
once we have that api we can go in and

00:06:45,120 --> 00:06:50,800
define how that storage is going to work

00:06:48,639 --> 00:06:52,400
using different software drivers to

00:06:50,800 --> 00:06:55,520
define the protocol

00:06:52,400 --> 00:06:58,960
that is going to be used per application

00:06:55,520 --> 00:07:01,840
now the power for doing this

00:06:58,960 --> 00:07:03,599
is tremendous again that single flash

00:07:01,840 --> 00:07:04,880
device can be used anywhere in the data

00:07:03,599 --> 00:07:06,319
center

00:07:04,880 --> 00:07:08,240
and deployed depending on the

00:07:06,319 --> 00:07:10,000
requirements of a particular application

00:07:08,240 --> 00:07:13,120
it can even be a custom

00:07:10,000 --> 00:07:14,720
driver specific to a specific type of

00:07:13,120 --> 00:07:17,440
application

00:07:14,720 --> 00:07:18,400
and what's even more amazing from this

00:07:17,440 --> 00:07:21,440
approach

00:07:18,400 --> 00:07:23,199
is as your applications change

00:07:21,440 --> 00:07:25,039
simply redefine the storage

00:07:23,199 --> 00:07:27,759
functionality of the already deployed

00:07:25,039 --> 00:07:31,360
software-enabled flash devices by

00:07:27,759 --> 00:07:33,360
changing the software driver

00:07:31,360 --> 00:07:35,919
an example that i would use in this case

00:07:33,360 --> 00:07:36,479
is every year we get to the holidays of

00:07:35,919 --> 00:07:38,560
course

00:07:36,479 --> 00:07:40,720
and we've got cyber monday and we've got

00:07:38,560 --> 00:07:42,000
black friday and the shopping online

00:07:40,720 --> 00:07:44,639
goes crazy

00:07:42,000 --> 00:07:45,199
so that web application that web front

00:07:44,639 --> 00:07:48,479
and

00:07:45,199 --> 00:07:49,440
store for doing all of the shopping goes

00:07:48,479 --> 00:07:52,560
crazy

00:07:49,440 --> 00:07:54,879
so you may need to spin up that

00:07:52,560 --> 00:07:55,759
web application increase the size of it

00:07:54,879 --> 00:07:58,560
to handle that

00:07:55,759 --> 00:08:00,080
additional workload for the holidays and

00:07:58,560 --> 00:08:03,759
in that case you can go

00:08:00,080 --> 00:08:06,479
grab two or three locations of unused or

00:08:03,759 --> 00:08:08,319
unallocated space from some other

00:08:06,479 --> 00:08:10,720
applications

00:08:08,319 --> 00:08:12,080
increase and expand that web presence

00:08:10,720 --> 00:08:14,080
and spin that up to

00:08:12,080 --> 00:08:15,680
handle that additional workload for the

00:08:14,080 --> 00:08:17,360
holidays

00:08:15,680 --> 00:08:18,800
and then of course when the holidays are

00:08:17,360 --> 00:08:20,479
done and you no longer need that

00:08:18,800 --> 00:08:21,840
additional bandwidth for that web

00:08:20,479 --> 00:08:24,879
application

00:08:21,840 --> 00:08:26,319
you can pull that down and put the

00:08:24,879 --> 00:08:29,039
storage back to the original

00:08:26,319 --> 00:08:29,039
applications

00:08:29,120 --> 00:08:33,360
another approach is of course new

00:08:30,879 --> 00:08:35,039
applications come in all the time

00:08:33,360 --> 00:08:37,039
and you can use the same approach go

00:08:35,039 --> 00:08:38,479
grab some of that unallocated space

00:08:37,039 --> 00:08:41,360
from all of the storage that's already

00:08:38,479 --> 00:08:43,599
in place bring in that new application

00:08:41,360 --> 00:08:45,279
bring in the new driver even if it's a

00:08:43,599 --> 00:08:48,240
new completely custom written

00:08:45,279 --> 00:08:50,160
driver to run that new application

00:08:48,240 --> 00:08:53,040
without having to go out and source new

00:08:50,160 --> 00:08:53,040
types of drives

00:08:53,279 --> 00:08:58,160
this means there's a really significant

00:08:55,839 --> 00:09:00,480
tco benefit

00:08:58,160 --> 00:09:01,760
to the data center being able to use and

00:09:00,480 --> 00:09:03,920
reuse and adapt

00:09:01,760 --> 00:09:04,880
that storage using that single storage

00:09:03,920 --> 00:09:07,040
module

00:09:04,880 --> 00:09:09,519
and adapting that capability through the

00:09:07,040 --> 00:09:12,560
use of software and software drivers

00:09:09,519 --> 00:09:14,399
all of course fully customizable to the

00:09:12,560 --> 00:09:17,200
specific needs of the application or

00:09:14,399 --> 00:09:17,200
your data center

00:09:18,320 --> 00:09:22,080
so with that in mind let me reintroduce

00:09:21,279 --> 00:09:24,640
the

00:09:22,080 --> 00:09:27,519
software defined flash api we call it

00:09:24,640 --> 00:09:30,640
software enabled flash

00:09:27,519 --> 00:09:32,320
and talk to you about how that works now

00:09:30,640 --> 00:09:34,320
the really interesting thing is i get to

00:09:32,320 --> 00:09:36,399
work with a lot of really smart and

00:09:34,320 --> 00:09:38,800
creative engineers uh throughout

00:09:36,399 --> 00:09:40,800
the kyokushi corporation so there's a

00:09:38,800 --> 00:09:43,519
whole team that's been pulled together

00:09:40,800 --> 00:09:45,120
to bring this solution to to you the

00:09:43,519 --> 00:09:47,120
developer

00:09:45,120 --> 00:09:48,320
and of course the multi-protocol

00:09:47,120 --> 00:09:50,240
capabilities what we're going to be

00:09:48,320 --> 00:09:52,399
talking about here

00:09:50,240 --> 00:09:53,519
this multi-protocol capability brings

00:09:52,399 --> 00:09:55,680
that flexibility

00:09:53,519 --> 00:09:57,360
the ability to adapt and reconfigure

00:09:55,680 --> 00:10:00,000
your storage in the fly

00:09:57,360 --> 00:10:01,600
with those tco benefits of using that

00:10:00,000 --> 00:10:05,440
single flash module

00:10:01,600 --> 00:10:08,399
and saving costs in your data center

00:10:05,440 --> 00:10:10,560
so how does this work well the

00:10:08,399 --> 00:10:13,839
innovation is here

00:10:10,560 --> 00:10:16,320
we shed that legacy hdd paradigm

00:10:13,839 --> 00:10:18,399
from the interface and define the

00:10:16,320 --> 00:10:20,079
protocols through that software api

00:10:18,399 --> 00:10:22,399
which means you can bring any software

00:10:20,079 --> 00:10:25,600
driver and run any protocol

00:10:22,399 --> 00:10:27,040
that you need across that hardware that

00:10:25,600 --> 00:10:28,720
hardware allows you to adapt and

00:10:27,040 --> 00:10:30,839
customize to the storage requirements of

00:10:28,720 --> 00:10:32,880
your data center your tenant or your

00:10:30,839 --> 00:10:35,360
application

00:10:32,880 --> 00:10:36,160
and it's incredibly easy to go in and

00:10:35,360 --> 00:10:38,240
change

00:10:36,160 --> 00:10:40,880
those protocols simply by making a

00:10:38,240 --> 00:10:43,920
driver change reallocate your storage

00:10:40,880 --> 00:10:46,320
deal with the uh the flash as it ages

00:10:43,920 --> 00:10:48,160
and adapt it to new workloads and new

00:10:46,320 --> 00:10:50,720
purposes

00:10:48,160 --> 00:10:52,320
and your developers can completely

00:10:50,720 --> 00:10:53,600
customize their implementations

00:10:52,320 --> 00:10:56,800
internally by taking

00:10:53,600 --> 00:10:59,120
and adjusting or adapting or rewriting

00:10:56,800 --> 00:11:00,800
the drivers themselves

00:10:59,120 --> 00:11:02,720
we actually do believe this statement at

00:11:00,800 --> 00:11:04,800
the bottom that this is a powerful way

00:11:02,720 --> 00:11:07,120
forward for flash

00:11:04,800 --> 00:11:10,000
and this powerful wave forward for flash

00:11:07,120 --> 00:11:12,240
enables you the software developer

00:11:10,000 --> 00:11:14,160
to uh scale your data center

00:11:12,240 --> 00:11:17,360
requirements of your applications your

00:11:14,160 --> 00:11:17,360
tenants and your customers

00:11:18,720 --> 00:11:22,320
so what does this look like how is this

00:11:20,320 --> 00:11:25,360
designed well we of course

00:11:22,320 --> 00:11:27,279
are a flash vendor which means

00:11:25,360 --> 00:11:29,360
we still have the flash that we need to

00:11:27,279 --> 00:11:31,760
deliver so it really becomes that

00:11:29,360 --> 00:11:33,839
hardware and that software aspect

00:11:31,760 --> 00:11:35,440
working together very closely and this

00:11:33,839 --> 00:11:38,880
is done again through that

00:11:35,440 --> 00:11:40,880
software defined flash api

00:11:38,880 --> 00:11:42,000
the hardware side of the thing on the

00:11:40,880 --> 00:11:44,640
left

00:11:42,000 --> 00:11:45,920
this involves a small controller with

00:11:44,640 --> 00:11:49,680
the capabilities of

00:11:45,920 --> 00:11:52,079
managing the uh flash itself there's the

00:11:49,680 --> 00:11:53,040
program specific or generation specific

00:11:52,079 --> 00:11:54,959
logic

00:11:53,040 --> 00:11:56,399
that allows us to abstract different

00:11:54,959 --> 00:11:58,959
generations of flash

00:11:56,399 --> 00:12:01,120
even different vendors of flash through

00:11:58,959 --> 00:12:04,959
the api so you don't have to worry about

00:12:01,120 --> 00:12:06,240
all the low level programming aspects

00:12:04,959 --> 00:12:08,399
for the flash itself

00:12:06,240 --> 00:12:09,279
you can easily switch different types of

00:12:08,399 --> 00:12:12,560
flash

00:12:09,279 --> 00:12:15,600
without changing your upper level code

00:12:12,560 --> 00:12:17,760
the hardware also allows for those

00:12:15,600 --> 00:12:19,839
accounts that need that flexibility you

00:12:17,760 --> 00:12:21,360
can have dram in the device you can have

00:12:19,839 --> 00:12:24,399
more dram in the device

00:12:21,360 --> 00:12:26,320
or less dram in the device or completely

00:12:24,399 --> 00:12:28,399
eliminate dram altogether and go with

00:12:26,320 --> 00:12:30,399
the host side buffer

00:12:28,399 --> 00:12:31,600
there's a number of functions built into

00:12:30,399 --> 00:12:34,880
the hardware that include

00:12:31,600 --> 00:12:37,040
the ability to host offload the host cpu

00:12:34,880 --> 00:12:39,600
for example for garbage collection

00:12:37,040 --> 00:12:42,320
activities you can completely remove

00:12:39,600 --> 00:12:43,760
um host interaction for moving data

00:12:42,320 --> 00:12:46,079
around

00:12:43,760 --> 00:12:47,279
again that flash generation or flash

00:12:46,079 --> 00:12:50,399
type extraction

00:12:47,279 --> 00:12:52,000
abstraction as we move from gen 2 to gen

00:12:50,399 --> 00:12:55,200
3 to gen 5 to gen

00:12:52,000 --> 00:12:56,639
10 you won't have to change your upper

00:12:55,200 --> 00:12:58,480
level programming

00:12:56,639 --> 00:12:59,839
in order to adapt that next generation

00:12:58,480 --> 00:13:03,440
of flash that's a

00:12:59,839 --> 00:13:05,519
real time to market advantage

00:13:03,440 --> 00:13:07,519
also built into the hardware is the

00:13:05,519 --> 00:13:09,600
ability to do some very advanced

00:13:07,519 --> 00:13:11,519
die time scheduling this gives you

00:13:09,600 --> 00:13:12,160
complete control over the latency

00:13:11,519 --> 00:13:14,639
outcomes

00:13:12,160 --> 00:13:16,720
of the device itself and allows you to

00:13:14,639 --> 00:13:20,959
deliver really good parallelism

00:13:16,720 --> 00:13:24,240
across multiple channels of flash

00:13:20,959 --> 00:13:26,079
now the right side of the

00:13:24,240 --> 00:13:27,600
chart here shows the software

00:13:26,079 --> 00:13:29,360
application side of this

00:13:27,600 --> 00:13:31,600
and of course we have device drivers

00:13:29,360 --> 00:13:34,160
that are there to talk to the

00:13:31,600 --> 00:13:35,200
flash itself all defined through that

00:13:34,160 --> 00:13:37,360
software api

00:13:35,200 --> 00:13:40,639
and software libraries and there are

00:13:37,360 --> 00:13:42,959
several aspects or several

00:13:40,639 --> 00:13:45,920
ways to approach delivering that flash

00:13:42,959 --> 00:13:47,600
to your users or your applications

00:13:45,920 --> 00:13:49,519
we can go through the traditional file

00:13:47,600 --> 00:13:51,360
system with standard block drivers and

00:13:49,519 --> 00:13:52,240
reference ftls

00:13:51,360 --> 00:13:54,560
if you're running your own

00:13:52,240 --> 00:13:56,560
software-defined storage stack we can

00:13:54,560 --> 00:13:57,600
easily adapt to that software discipline

00:13:56,560 --> 00:14:00,000
storage stack

00:13:57,600 --> 00:14:01,040
or more appropriately you can define and

00:14:00,000 --> 00:14:04,240
adapt it yourself

00:14:01,040 --> 00:14:06,480
using the api library calls

00:14:04,240 --> 00:14:07,519
the opportunity also exists for an

00:14:06,480 --> 00:14:09,440
application to talk

00:14:07,519 --> 00:14:11,279
directly to the flash through the

00:14:09,440 --> 00:14:14,079
library without going through the file

00:14:11,279 --> 00:14:15,839
system or the stack as well

00:14:14,079 --> 00:14:17,839
the software gives complete and full

00:14:15,839 --> 00:14:19,920
control over data placement

00:14:17,839 --> 00:14:21,600
which gives you the ability to isolate

00:14:19,920 --> 00:14:23,600
workloads and tenants from each other

00:14:21,600 --> 00:14:25,360
all the way down to the flash dye level

00:14:23,600 --> 00:14:27,279
in hardware

00:14:25,360 --> 00:14:28,880
uh you've got control over your latency

00:14:27,279 --> 00:14:30,800
outcomes again with that die time

00:14:28,880 --> 00:14:32,959
scheduling

00:14:30,800 --> 00:14:34,720
and buffer management can be shared

00:14:32,959 --> 00:14:37,760
between the device

00:14:34,720 --> 00:14:38,480
and the host through software so a very

00:14:37,760 --> 00:14:41,440
flexible

00:14:38,480 --> 00:14:42,800
very powerful software api designed to

00:14:41,440 --> 00:14:45,839
manage both the hardware

00:14:42,800 --> 00:14:45,839
and your programming

00:14:46,480 --> 00:14:49,519
so let's talk a moment about the

00:14:48,000 --> 00:14:51,600
abstraction capabilities

00:14:49,519 --> 00:14:53,360
of course all of the low-level flash

00:14:51,600 --> 00:14:55,279
management this is the programming the

00:14:53,360 --> 00:14:57,680
flash cells the voltages

00:14:55,279 --> 00:14:58,560
the timings all managed within the

00:14:57,680 --> 00:15:01,279
hardware

00:14:58,560 --> 00:15:03,519
through the api this low level

00:15:01,279 --> 00:15:06,560
management means of course flash type

00:15:03,519 --> 00:15:07,920
whether it's mlc or tlc or qlc is

00:15:06,560 --> 00:15:11,519
managed through the api

00:15:07,920 --> 00:15:14,079
and abstracted different generations

00:15:11,519 --> 00:15:14,639
generation three four and five are all

00:15:14,079 --> 00:15:16,399
covered

00:15:14,639 --> 00:15:18,240
and managed through that abstraction as

00:15:16,399 --> 00:15:19,199
well as the possibility of different

00:15:18,240 --> 00:15:22,560
vendors

00:15:19,199 --> 00:15:24,079
which means a complete ability to use

00:15:22,560 --> 00:15:27,680
any type of flash

00:15:24,079 --> 00:15:30,800
using the api the ap api

00:15:27,680 --> 00:15:32,639
also handles that traditional noisy

00:15:30,800 --> 00:15:35,120
neighbor problem if you've got one

00:15:32,639 --> 00:15:37,600
neighbor or one application that's

00:15:35,120 --> 00:15:39,759
doing a lot of i o you don't want that

00:15:37,600 --> 00:15:40,959
io interfering with your particular

00:15:39,759 --> 00:15:43,440
application

00:15:40,959 --> 00:15:44,160
you can isolate all the way down to the

00:15:43,440 --> 00:15:47,600
hardware

00:15:44,160 --> 00:15:49,519
to individual flash die uh and set up so

00:15:47,600 --> 00:15:50,320
that one noisy neighbor does not impact

00:15:49,519 --> 00:15:51,920
another

00:15:50,320 --> 00:15:53,519
we'll be able to show you how that works

00:15:51,920 --> 00:15:54,880
as part of the demo that we're going to

00:15:53,519 --> 00:15:57,519
show you a little later in this

00:15:54,880 --> 00:15:57,519
presentation

00:15:57,680 --> 00:16:01,920
in addition to that isolation you can

00:16:00,639 --> 00:16:04,000
manage and

00:16:01,920 --> 00:16:07,040
control your latency outcomes using

00:16:04,000 --> 00:16:10,880
parallelism using that die time queuing

00:16:07,040 --> 00:16:13,199
read write is managed by the api

00:16:10,880 --> 00:16:14,560
giving you that ability to again manage

00:16:13,199 --> 00:16:16,959
your latencies through that

00:16:14,560 --> 00:16:22,399
time management and of course offloading

00:16:16,959 --> 00:16:23,680
host resources

00:16:22,399 --> 00:16:25,440
with the introduction of software

00:16:23,680 --> 00:16:27,839
enabled flash uh

00:16:25,440 --> 00:16:29,680
a little later this year the api is out

00:16:27,839 --> 00:16:32,560
today but we're also going to introduce

00:16:29,680 --> 00:16:34,079
a software development kit an sdk

00:16:32,560 --> 00:16:36,560
and what are the benefits that are going

00:16:34,079 --> 00:16:38,800
to come from bringing out that sdk in

00:16:36,560 --> 00:16:40,639
addition to the api

00:16:38,800 --> 00:16:42,720
just to let you know the api is already

00:16:40,639 --> 00:16:44,639
out in open source it's available under

00:16:42,720 --> 00:16:46,560
a bsd 3 license

00:16:44,639 --> 00:16:48,160
and it's up on github right now i'll

00:16:46,560 --> 00:16:49,600
give you links to that

00:16:48,160 --> 00:16:51,920
a little later towards the end of the

00:16:49,600 --> 00:16:53,759
presentation

00:16:51,920 --> 00:16:55,120
uh the sdk is going to bring a lot of

00:16:53,759 --> 00:16:56,720
benefits as well

00:16:55,120 --> 00:16:58,399
uh specifically it's going to bring in

00:16:56,720 --> 00:16:59,360
the ability to do accelerated

00:16:58,399 --> 00:17:01,199
development

00:16:59,360 --> 00:17:03,199
the sdk is going to give you a complete

00:17:01,199 --> 00:17:05,199
set of code that shows you exactly how

00:17:03,199 --> 00:17:08,079
to implement all the functions

00:17:05,199 --> 00:17:11,280
of the api in the library this means

00:17:08,079 --> 00:17:14,079
your applications your programming

00:17:11,280 --> 00:17:15,839
can get to market very rapidly a

00:17:14,079 --> 00:17:18,799
tremendous time to market advantage as

00:17:15,839 --> 00:17:20,959
well as that tco advantage

00:17:18,799 --> 00:17:22,880
it gives you a completely new base for

00:17:20,959 --> 00:17:24,959
development activities for any new

00:17:22,880 --> 00:17:28,319
projects coming up

00:17:24,959 --> 00:17:30,840
there's a number of options built in for

00:17:28,319 --> 00:17:32,160
virtualized and containerized

00:17:30,840 --> 00:17:35,280
applications

00:17:32,160 --> 00:17:36,960
it gives you the ability to do deploy

00:17:35,280 --> 00:17:39,440
which we haven't seen today through the

00:17:36,960 --> 00:17:42,000
ssd realm but the ability to get

00:17:39,440 --> 00:17:44,640
the full power and capability out of the

00:17:42,000 --> 00:17:47,280
flash itself

00:17:44,640 --> 00:17:48,880
and that sdk will have a number of tools

00:17:47,280 --> 00:17:50,799
built into it

00:17:48,880 --> 00:17:52,960
that will allow the developer to

00:17:50,799 --> 00:17:55,760
evaluate that software enabled flash

00:17:52,960 --> 00:17:57,280
uh api code and technology without

00:17:55,760 --> 00:17:58,559
actually having to write any code to

00:17:57,280 --> 00:18:00,880
start with

00:17:58,559 --> 00:18:02,799
we're going to be bringing to you uh

00:18:00,880 --> 00:18:05,200
functional example drivers

00:18:02,799 --> 00:18:06,880
uh source code as well as the drivers

00:18:05,200 --> 00:18:08,480
that implement both zns

00:18:06,880 --> 00:18:10,559
and block mode capabilities like a

00:18:08,480 --> 00:18:12,720
traditional or a standard ssd

00:18:10,559 --> 00:18:15,039
this will include a functional and

00:18:12,720 --> 00:18:18,080
working ftl

00:18:15,039 --> 00:18:21,039
at open source ftl

00:18:18,080 --> 00:18:22,480
it includes a cli command line interface

00:18:21,039 --> 00:18:24,240
tool that allows you to configure and

00:18:22,480 --> 00:18:26,960
talk to the devices

00:18:24,240 --> 00:18:28,240
there's even a modified version of the

00:18:26,960 --> 00:18:30,559
fio

00:18:28,240 --> 00:18:31,360
test and performance software that will

00:18:30,559 --> 00:18:33,039
be included

00:18:31,360 --> 00:18:34,640
that allows you to start talking to the

00:18:33,039 --> 00:18:37,039
devices immediately

00:18:34,640 --> 00:18:37,840
and test the capabilities as well as

00:18:37,039 --> 00:18:41,679
speed of

00:18:37,840 --> 00:18:42,080
the devices that sdk is going to be a

00:18:41,679 --> 00:18:44,160
very

00:18:42,080 --> 00:18:45,600
powerful tool to show you how to move

00:18:44,160 --> 00:18:47,679
forward with the api

00:18:45,600 --> 00:18:50,880
and start developing that base for your

00:18:47,679 --> 00:18:50,880
new development activities

00:18:52,559 --> 00:18:56,640
now functions there's quite a few

00:18:54,000 --> 00:18:57,039
functions built into the api again we're

00:18:56,640 --> 00:18:58,480
here

00:18:57,039 --> 00:19:00,640
primarily to talk about this

00:18:58,480 --> 00:19:02,320
multi-protocol capability

00:19:00,640 --> 00:19:04,480
we've mentioned flash generation

00:19:02,320 --> 00:19:06,160
abstraction the ability to isolate

00:19:04,480 --> 00:19:08,840
workloads and manage

00:19:06,160 --> 00:19:10,559
latency and cueing as well as host

00:19:08,840 --> 00:19:13,760
offload

00:19:10,559 --> 00:19:16,480
the software enabledflash.com website

00:19:13,760 --> 00:19:17,679
has materials and training and webinars

00:19:16,480 --> 00:19:19,360
that we've given already

00:19:17,679 --> 00:19:21,520
that talk about each of these different

00:19:19,360 --> 00:19:24,320
capabilities in greater detail

00:19:21,520 --> 00:19:25,120
and i'd invite everybody to go visit the

00:19:24,320 --> 00:19:27,440
site and

00:19:25,120 --> 00:19:29,600
take a look at some of those videos that

00:19:27,440 --> 00:19:33,200
will show you how these capabilities

00:19:29,600 --> 00:19:33,200
are implemented how they can be used

00:19:35,760 --> 00:19:40,320
now in terms of protocol we know in the

00:19:38,720 --> 00:19:41,760
average data center especially cloud

00:19:40,320 --> 00:19:43,760
data center

00:19:41,760 --> 00:19:44,960
we're going to be spanning across

00:19:43,760 --> 00:19:47,200
hundreds if not

00:19:44,960 --> 00:19:51,120
thousands of individual software enabled

00:19:47,200 --> 00:19:51,120
flash devices individual drives

00:19:51,360 --> 00:19:55,440
and the ability to isolate those drives

00:19:53,919 --> 00:19:57,520
for the workload so we'll talk a little

00:19:55,440 --> 00:19:59,840
bit about workload isolation

00:19:57,520 --> 00:20:01,360
uh is very important you need to be able

00:19:59,840 --> 00:20:02,640
to manage all the way down to that flash

00:20:01,360 --> 00:20:04,559
dye level

00:20:02,640 --> 00:20:06,960
in order to run different applications

00:20:04,559 --> 00:20:07,760
that might need that different protocol

00:20:06,960 --> 00:20:10,720
that we're

00:20:07,760 --> 00:20:10,720
talking about today

00:20:11,760 --> 00:20:15,840
so let's take a look at what this looks

00:20:13,679 --> 00:20:17,520
like but instead of doing this across

00:20:15,840 --> 00:20:19,919
hundreds of thousands devices

00:20:17,520 --> 00:20:22,080
let's show you the power not by spanning

00:20:19,919 --> 00:20:24,960
hundreds of devices but let's zero in on

00:20:22,080 --> 00:20:27,280
a single flash device

00:20:24,960 --> 00:20:29,200
we'll bring up a single flash device

00:20:27,280 --> 00:20:31,919
this is a traditional eight channel

00:20:29,200 --> 00:20:32,559
four die arrangement and we're going to

00:20:31,919 --> 00:20:35,760
break that

00:20:32,559 --> 00:20:38,320
down into three separate hardware

00:20:35,760 --> 00:20:39,840
isolated zones

00:20:38,320 --> 00:20:42,640
and then in these zones we're going to

00:20:39,840 --> 00:20:44,080
run different applications and different

00:20:42,640 --> 00:20:46,240
protocols

00:20:44,080 --> 00:20:48,080
yes this is different applications and

00:20:46,240 --> 00:20:51,919
different protocols on a single

00:20:48,080 --> 00:20:54,000
device so let's start

00:20:51,919 --> 00:20:56,799
with the first zone we're going to run a

00:20:54,000 --> 00:20:59,679
traditional web application as we

00:20:56,799 --> 00:21:01,600
highlighted before we'll run this with a

00:20:59,679 --> 00:21:04,320
block protocol

00:21:01,600 --> 00:21:06,320
and in order to show that the uh the

00:21:04,320 --> 00:21:06,640
device is clearly isolated we'll run

00:21:06,320 --> 00:21:09,440
that

00:21:06,640 --> 00:21:11,919
in a specific i o pattern of mixed reads

00:21:09,440 --> 00:21:11,919
and writes

00:21:13,679 --> 00:21:18,320
for the next zone we'll implement a

00:21:16,240 --> 00:21:20,559
streaming application

00:21:18,320 --> 00:21:21,919
in this case we'll use a custom written

00:21:20,559 --> 00:21:24,640
ftl

00:21:21,919 --> 00:21:26,559
protocol this is a protocol written

00:21:24,640 --> 00:21:27,679
based on the definition for a hyperscale

00:21:26,559 --> 00:21:30,480
account

00:21:27,679 --> 00:21:30,799
and again we're going to run a unique i

00:21:30,480 --> 00:21:32,480
o

00:21:30,799 --> 00:21:34,480
pattern we're going to do 100 percent

00:21:32,480 --> 00:21:37,600
read i o and only 100

00:21:34,480 --> 00:21:37,600
read i o in this zone

00:21:37,760 --> 00:21:41,360
and in the last zone we'll run a

00:21:39,280 --> 00:21:44,559
database app we'll use the

00:21:41,360 --> 00:21:47,600
zns protocol we do have implemented as a

00:21:44,559 --> 00:21:51,120
subset of the software enabled flash api

00:21:47,600 --> 00:21:51,120
a complete zns wrap

00:21:51,280 --> 00:21:55,679
so we we like cns even though it's a

00:21:53,679 --> 00:21:58,000
legacy protocol

00:21:55,679 --> 00:21:59,919
and again in order to show the isolation

00:21:58,000 --> 00:22:03,360
capabilities we'll do this with

00:21:59,919 --> 00:22:05,280
strictly 100 right io

00:22:03,360 --> 00:22:06,720
now remember we can move this uh

00:22:05,280 --> 00:22:08,640
applications and we can move the zones

00:22:06,720 --> 00:22:10,960
around we can redefine them and we can

00:22:08,640 --> 00:22:12,880
change the protocols simply by going in

00:22:10,960 --> 00:22:14,880
and change a software driver as

00:22:12,880 --> 00:22:16,720
necessary

00:22:14,880 --> 00:22:18,880
now what i would like to highlight

00:22:16,720 --> 00:22:19,840
notice i haven't used all the flash dye

00:22:18,880 --> 00:22:22,240
in this device

00:22:19,840 --> 00:22:24,840
there are flash dye unused flash dye

00:22:22,240 --> 00:22:26,159
between each of these particular

00:22:24,840 --> 00:22:28,480
applications

00:22:26,159 --> 00:22:32,320
that can exhibit that we have physically

00:22:28,480 --> 00:22:32,320
isolated each workload from each other

00:22:33,520 --> 00:22:36,559
now let's go take a look at the demo

00:22:35,760 --> 00:22:38,159
itself

00:22:36,559 --> 00:22:39,760
this is a video that we've taken of a

00:22:38,159 --> 00:22:42,640
running demo

00:22:39,760 --> 00:22:43,120
this is a heat map so the ios are going

00:22:42,640 --> 00:22:46,320
to be

00:22:43,120 --> 00:22:48,640
in blue rays are in blue and

00:22:46,320 --> 00:22:50,400
rights are in red let me get this

00:22:48,640 --> 00:22:52,240
started up

00:22:50,400 --> 00:22:54,080
and you can see we have the three

00:22:52,240 --> 00:22:57,360
separate isolated zones the block

00:22:54,080 --> 00:23:00,960
mode doing a mixed read write

00:22:57,360 --> 00:23:03,440
the custom ftl doing 100 reads

00:23:00,960 --> 00:23:04,640
and the zns mode doing 100 percent

00:23:03,440 --> 00:23:07,600
rights

00:23:04,640 --> 00:23:08,799
and again we're confirming the complete

00:23:07,600 --> 00:23:11,440
isolation

00:23:08,799 --> 00:23:13,840
based on the unused flash dyed between

00:23:11,440 --> 00:23:17,520
each of these zones

00:23:13,840 --> 00:23:20,000
again this is a single flash device

00:23:17,520 --> 00:23:21,360
running different workloads completely

00:23:20,000 --> 00:23:24,159
isolated from each other

00:23:21,360 --> 00:23:25,919
down to the hardware flash die level

00:23:24,159 --> 00:23:28,240
this is the tremendous power and

00:23:25,919 --> 00:23:30,080
flexibility and definability that

00:23:28,240 --> 00:23:31,520
software-enabled flash can bring to your

00:23:30,080 --> 00:23:37,280
development environments

00:23:31,520 --> 00:23:40,240
and your cloud data centers

00:23:37,280 --> 00:23:42,400
so what are the benefits that this

00:23:40,240 --> 00:23:44,640
approach can bring to you

00:23:42,400 --> 00:23:46,320
we have talked a bit about that single

00:23:44,640 --> 00:23:48,159
adaptable flash device

00:23:46,320 --> 00:23:50,000
instead of having to source multiple

00:23:48,159 --> 00:23:52,880
different types of drives with different

00:23:50,000 --> 00:23:54,000
capabilities you can now bring in one

00:23:52,880 --> 00:23:56,640
single flash

00:23:54,000 --> 00:23:58,080
device one for single flash drive and

00:23:56,640 --> 00:24:00,320
adapt its use case

00:23:58,080 --> 00:24:03,840
or change its use case at need through

00:24:00,320 --> 00:24:06,320
the use of software and software drivers

00:24:03,840 --> 00:24:09,600
api itself is focused on solving all of

00:24:06,320 --> 00:24:11,760
those common low-level problems

00:24:09,600 --> 00:24:13,760
through software can easily be adapted

00:24:11,760 --> 00:24:15,760
to the new high-level requirements as

00:24:13,760 --> 00:24:19,840
the workloads or the tenants change

00:24:15,760 --> 00:24:20,880
in the use cases this approach also

00:24:19,840 --> 00:24:23,679
allows a

00:24:20,880 --> 00:24:25,039
large amount of code you reuse in

00:24:23,679 --> 00:24:26,799
deploying your flash storage

00:24:25,039 --> 00:24:27,200
applications without having to worry

00:24:26,799 --> 00:24:29,120
about

00:24:27,200 --> 00:24:30,400
the changes in flash from generation to

00:24:29,120 --> 00:24:33,279
generation

00:24:30,400 --> 00:24:34,159
and this also means that you get

00:24:33,279 --> 00:24:36,400
increased or

00:24:34,159 --> 00:24:38,000
faster internal development with

00:24:36,400 --> 00:24:39,679
simplified maintenance

00:24:38,000 --> 00:24:41,520
now instead of having to pull drives out

00:24:39,679 --> 00:24:45,200
of the way and put new drives in

00:24:41,520 --> 00:24:48,799
you can simply let things stay in place

00:24:45,200 --> 00:24:50,960
and change the use case through software

00:24:48,799 --> 00:24:53,360
and continue to use that flash as it

00:24:50,960 --> 00:24:53,360
cycles

00:24:56,720 --> 00:25:01,600
for the api there's a whole lot of

00:24:59,360 --> 00:25:03,679
additional capabilities some very

00:25:01,600 --> 00:25:04,880
functional and very powerful low-level

00:25:03,679 --> 00:25:06,559
capabilities

00:25:04,880 --> 00:25:09,200
built into the software-enabled flash

00:25:06,559 --> 00:25:10,640
api there's a lot to explore

00:25:09,200 --> 00:25:12,880
again there's some tremendous

00:25:10,640 --> 00:25:15,880
information in white papers

00:25:12,880 --> 00:25:17,840
and videos up on our website

00:25:15,880 --> 00:25:19,440
softwareableflash.com

00:25:17,840 --> 00:25:21,760
some of the capabilities include the

00:25:19,440 --> 00:25:22,799
ability to define and use the nameless

00:25:21,760 --> 00:25:25,120
write

00:25:22,799 --> 00:25:27,360
this nameless write capability allows

00:25:25,120 --> 00:25:28,720
the flash to pick the best location to

00:25:27,360 --> 00:25:31,360
write your data

00:25:28,720 --> 00:25:32,880
and once that nameless write has placed

00:25:31,360 --> 00:25:34,320
the data it will return to you that

00:25:32,880 --> 00:25:38,080
physical address

00:25:34,320 --> 00:25:38,799
so as in item number five you always get

00:25:38,080 --> 00:25:42,159
a direct

00:25:38,799 --> 00:25:43,279
access physical read there's the ability

00:25:42,159 --> 00:25:46,320
to manage buffers

00:25:43,279 --> 00:25:46,960
using on device dram or or no device

00:25:46,320 --> 00:25:50,080
dram

00:25:46,960 --> 00:25:53,840
and unify those buffers with the

00:25:50,080 --> 00:25:55,679
host cpu and host memory

00:25:53,840 --> 00:25:57,039
there's a whole range of asynchronous as

00:25:55,679 --> 00:26:00,320
well as synchronous

00:25:57,039 --> 00:26:03,600
event handlers and again the

00:26:00,320 --> 00:26:05,840
ability for the flash vendor

00:26:03,600 --> 00:26:08,480
to deliver you a software enabled flash

00:26:05,840 --> 00:26:11,279
device means that the flash vendor can

00:26:08,480 --> 00:26:13,200
program into that hardware device all of

00:26:11,279 --> 00:26:16,960
the capabilities to manage the health

00:26:13,200 --> 00:26:18,960
and the lifetime of the flash itself

00:26:16,960 --> 00:26:21,840
in that device and extend its life to

00:26:18,960 --> 00:26:24,400
the best possible approach

00:26:21,840 --> 00:26:26,320
and again i i want to reiterate

00:26:24,400 --> 00:26:26,880
abstraction is an important aspect of

00:26:26,320 --> 00:26:28,640
delivering

00:26:26,880 --> 00:26:31,279
software enabled flash technology as

00:26:28,640 --> 00:26:34,320
well this abstraction allows you to keep

00:26:31,279 --> 00:26:36,000
your application layer code consistent

00:26:34,320 --> 00:26:38,640
and then you can deploy underneath that

00:26:36,000 --> 00:26:39,679
api different types of flash depending

00:26:38,640 --> 00:26:43,120
on your needs

00:26:39,679 --> 00:26:44,960
whether that's mlc or tlc or qlc media

00:26:43,120 --> 00:26:46,159
without having to rewrite the code that

00:26:44,960 --> 00:26:50,840
you're using

00:26:46,159 --> 00:26:53,520
a tremendously powerful feature flash

00:26:50,840 --> 00:26:55,279
abstraction

00:26:53,520 --> 00:26:57,200
so what does this do for us in terms of

00:26:55,279 --> 00:27:00,000
value to you especially if you're a

00:26:57,200 --> 00:27:02,960
program manager or a project manager

00:27:00,000 --> 00:27:04,720
well first and foremost for the the data

00:27:02,960 --> 00:27:07,760
center it means there's a tremendous

00:27:04,720 --> 00:27:09,600
time to market advantage imagine as

00:27:07,760 --> 00:27:10,799
you've deployed your software as you

00:27:09,600 --> 00:27:13,520
deployed your hardware

00:27:10,799 --> 00:27:15,200
in your data center and you see that

00:27:13,520 --> 00:27:16,480
there's a new generation flash that's

00:27:15,200 --> 00:27:18,480
coming out

00:27:16,480 --> 00:27:20,240
that time to market advantage to be able

00:27:18,480 --> 00:27:21,679
to transition to that newest generation

00:27:20,240 --> 00:27:24,480
of flash

00:27:21,679 --> 00:27:25,279
can happen rapidly since it's plug and

00:27:24,480 --> 00:27:27,120
play

00:27:25,279 --> 00:27:28,880
you don't have to rewrite any software

00:27:27,120 --> 00:27:30,480
to use that newest next generation of

00:27:28,880 --> 00:27:31,919
flash you can bring in that newest

00:27:30,480 --> 00:27:34,880
generation flash

00:27:31,919 --> 00:27:38,559
immediately and deploy it under and with

00:27:34,880 --> 00:27:38,559
your applications in your data center

00:27:39,520 --> 00:27:42,640
resource allocation is another value

00:27:41,440 --> 00:27:45,039
proposition

00:27:42,640 --> 00:27:46,640
resource allocation in this case is your

00:27:45,039 --> 00:27:47,760
programming resources your human

00:27:46,640 --> 00:27:49,760
resources

00:27:47,760 --> 00:27:52,080
your human resources can now be focused

00:27:49,760 --> 00:27:54,720
on development where it actually matters

00:27:52,080 --> 00:27:56,880
that is delivering your applications to

00:27:54,720 --> 00:27:58,960
the benefit of your customer base

00:27:56,880 --> 00:28:00,880
without having to worry about how to do

00:27:58,960 --> 00:28:03,919
the programming of the low-level flash

00:28:00,880 --> 00:28:06,480
itself in order to deploy the storage

00:28:03,919 --> 00:28:07,600
this this actually means you get to use

00:28:06,480 --> 00:28:10,480
the resources where

00:28:07,600 --> 00:28:11,279
the the most value for you as a data

00:28:10,480 --> 00:28:15,039
center

00:28:11,279 --> 00:28:17,360
can be applied and finally of course you

00:28:15,039 --> 00:28:20,480
get to maximize the use of your flash

00:28:17,360 --> 00:28:24,159
you've we've dropped all of the legacy

00:28:20,480 --> 00:28:25,919
hdd paradigms uh we're using flash to

00:28:24,159 --> 00:28:27,520
its fullest extent and its fullest

00:28:25,919 --> 00:28:29,520
potential

00:28:27,520 --> 00:28:31,360
you can change the workloads and a

00:28:29,520 --> 00:28:33,679
change and adapt through software

00:28:31,360 --> 00:28:36,960
how you use the flash as your workloads

00:28:33,679 --> 00:28:36,960
and your environments change

00:28:37,840 --> 00:28:42,880
we believe and understand that

00:28:41,600 --> 00:28:44,720
this new approach this software

00:28:42,880 --> 00:28:47,360
software-defined api

00:28:44,720 --> 00:28:48,960
approach to flash fundamentally will

00:28:47,360 --> 00:28:50,880
redefine that relationship

00:28:48,960 --> 00:28:54,720
between the host and the solid-state

00:28:50,880 --> 00:28:54,720
storage that you are buying

00:28:57,360 --> 00:29:00,799
and of course the tco model that we've

00:28:59,200 --> 00:29:02,480
talked about earlier

00:29:00,799 --> 00:29:04,640
also a tremendous advantage we've

00:29:02,480 --> 00:29:06,159
simplified or have the opportunity to

00:29:04,640 --> 00:29:07,600
simplify your supply chain

00:29:06,159 --> 00:29:10,559
using the software enabled flash

00:29:07,600 --> 00:29:12,320
technology you can now buy a single

00:29:10,559 --> 00:29:16,559
flash device

00:29:12,320 --> 00:29:19,039
and adapt its use cases through software

00:29:16,559 --> 00:29:21,600
to any environment or any application

00:29:19,039 --> 00:29:21,600
that you have

00:29:21,840 --> 00:29:27,840
makes your purchasing process much

00:29:24,840 --> 00:29:27,840
simpler

00:29:28,080 --> 00:29:34,480
now we of course are here in

00:29:31,279 --> 00:29:36,320
the linux foundation's webinar series

00:29:34,480 --> 00:29:38,480
and it would be important for us to

00:29:36,320 --> 00:29:39,600
identify that the best way to get to you

00:29:38,480 --> 00:29:41,919
the developer

00:29:39,600 --> 00:29:43,440
is through an open source strategy and

00:29:41,919 --> 00:29:45,120
that of course is the approach that

00:29:43,440 --> 00:29:46,480
we're taking to delivering software

00:29:45,120 --> 00:29:49,919
enabled flash technology

00:29:46,480 --> 00:29:52,399
and the software defined flash api

00:29:49,919 --> 00:29:53,360
we know not only is it for you the

00:29:52,399 --> 00:29:55,440
developer

00:29:53,360 --> 00:29:57,039
but also vendors and industry

00:29:55,440 --> 00:30:00,720
co-travelers need this

00:29:57,039 --> 00:30:02,640
open source neutral vendor-neutral

00:30:00,720 --> 00:30:05,600
location in which to collaborate and

00:30:02,640 --> 00:30:08,480
bring you the best solutions possible

00:30:05,600 --> 00:30:09,760
so we are partnering up with the linux

00:30:08,480 --> 00:30:11,520
foundation

00:30:09,760 --> 00:30:13,360
and working towards establishing an

00:30:11,520 --> 00:30:16,399
actual open source project

00:30:13,360 --> 00:30:18,320
to support and deliver the software

00:30:16,399 --> 00:30:20,559
enabled flash api

00:30:18,320 --> 00:30:21,679
as well as the software development kit

00:30:20,559 --> 00:30:23,840
to you the users

00:30:21,679 --> 00:30:25,279
so that you can easily and freely pick

00:30:23,840 --> 00:30:27,840
it up and adapt it to your own

00:30:25,279 --> 00:30:27,840
requirements

00:30:28,960 --> 00:30:32,159
so why are we doing open source this

00:30:31,679 --> 00:30:34,000
again

00:30:32,159 --> 00:30:35,919
is something that appeals to the

00:30:34,000 --> 00:30:37,360
developer community you the developers

00:30:35,919 --> 00:30:39,440
out there

00:30:37,360 --> 00:30:41,520
as we know i'm an open source developer

00:30:39,440 --> 00:30:43,039
myself so i appreciate open source

00:30:41,520 --> 00:30:44,480
because it means i can do things very

00:30:43,039 --> 00:30:49,039
quickly and adapt

00:30:44,480 --> 00:30:50,880
on need for my applications

00:30:49,039 --> 00:30:52,159
it also encourages broad adoption when

00:30:50,880 --> 00:30:54,880
it's open and

00:30:52,159 --> 00:30:55,919
available and accessible that means a

00:30:54,880 --> 00:30:58,720
wide range of

00:30:55,919 --> 00:30:59,919
customers and vendors and co-travelers

00:30:58,720 --> 00:31:03,120
can

00:30:59,919 --> 00:31:05,360
support and deliver solutions using the

00:31:03,120 --> 00:31:08,320
technology

00:31:05,360 --> 00:31:09,919
and this open source approach and the

00:31:08,320 --> 00:31:12,320
project will be

00:31:09,919 --> 00:31:13,600
pulled together and driven by a

00:31:12,320 --> 00:31:14,799
technical steering committee that's

00:31:13,600 --> 00:31:17,200
going to be focused on

00:31:14,799 --> 00:31:21,519
bringing you the developer community the

00:31:17,200 --> 00:31:24,080
best capabilities out of that flash api

00:31:21,519 --> 00:31:25,039
so where do we sit today in terms of

00:31:24,080 --> 00:31:27,120
delivery

00:31:25,039 --> 00:31:28,720
well phase one is already out there the

00:31:27,120 --> 00:31:31,440
api has been published

00:31:28,720 --> 00:31:32,320
it's available on github today it's on

00:31:31,440 --> 00:31:35,679
the kiosk

00:31:32,320 --> 00:31:37,440
github slash keoxi americas site uh

00:31:35,679 --> 00:31:39,039
we will be transferring that to the

00:31:37,440 --> 00:31:42,240
project when the project opens

00:31:39,039 --> 00:31:43,200
will be a little later this year uh in

00:31:42,240 --> 00:31:45,120
progress today

00:31:43,200 --> 00:31:47,120
is the work that is being put in place

00:31:45,120 --> 00:31:49,600
to actually create the project

00:31:47,120 --> 00:31:52,320
that's working with the linux foundation

00:31:49,600 --> 00:31:54,320
getting the legal aspects taken care of

00:31:52,320 --> 00:31:56,000
and setting up and preparing the project

00:31:54,320 --> 00:31:57,200
as well as doing the development of the

00:31:56,000 --> 00:32:00,559
device drivers

00:31:57,200 --> 00:32:00,960
and the sdk itself once this is all set

00:32:00,559 --> 00:32:02,720
up

00:32:00,960 --> 00:32:04,320
once we get through phase two and phase

00:32:02,720 --> 00:32:07,440
three we will

00:32:04,320 --> 00:32:08,960
release the project uh make that sdk as

00:32:07,440 --> 00:32:10,640
well as the api that's already out

00:32:08,960 --> 00:32:14,000
available to the public

00:32:10,640 --> 00:32:15,840
on that vendor unique site and then some

00:32:14,000 --> 00:32:17,120
time off in the future we can take a

00:32:15,840 --> 00:32:19,120
look at

00:32:17,120 --> 00:32:20,720
standards committees and see if they're

00:32:19,120 --> 00:32:21,919
applicable to the direction that

00:32:20,720 --> 00:32:28,240
software enabled flash

00:32:21,919 --> 00:32:30,399
is going we

00:32:28,240 --> 00:32:32,399
keoksi believe this software enable

00:32:30,399 --> 00:32:34,960
flash technology becomes that

00:32:32,399 --> 00:32:37,679
force multiplier in your data center

00:32:34,960 --> 00:32:37,679
economics

00:32:39,120 --> 00:32:42,320
and i believe i mentioned i was going to

00:32:41,039 --> 00:32:44,720
share with you how to get

00:32:42,320 --> 00:32:45,360
additional information we do have a

00:32:44,720 --> 00:32:47,519
website

00:32:45,360 --> 00:32:48,559
established today at software enabled

00:32:47,519 --> 00:32:50,559
flash.com

00:32:48,559 --> 00:32:53,279
there are white papers there's a link to

00:32:50,559 --> 00:32:55,120
the api that can be downloaded

00:32:53,279 --> 00:32:56,720
there's a number of videos as well as

00:32:55,120 --> 00:32:58,159
other recorded webinars

00:32:56,720 --> 00:32:59,760
talking about the technology there's

00:32:58,159 --> 00:33:01,519
some very technical

00:32:59,760 --> 00:33:03,679
deep dives into the technology through

00:33:01,519 --> 00:33:06,720
some of those webinars

00:33:03,679 --> 00:33:09,919
the api of course is out on github.com

00:33:06,720 --> 00:33:11,760
github kiosks america please feel free

00:33:09,919 --> 00:33:13,279
to go visit that site and download the

00:33:11,760 --> 00:33:15,360
api

00:33:13,279 --> 00:33:16,640
and we're always available for questions

00:33:15,360 --> 00:33:19,760
you can write to me

00:33:16,640 --> 00:33:22,399
there's a contact on here earl philhauer

00:33:19,760 --> 00:33:23,279
i would be happy to get your questions

00:33:22,399 --> 00:33:25,760
by email

00:33:23,279 --> 00:33:27,200
if you have any please reach out to us

00:33:25,760 --> 00:33:30,240
we'd very much

00:33:27,200 --> 00:33:32,960
like to hear from you this is the

00:33:30,240 --> 00:33:35,120
end of my presentation portion of this

00:33:32,960 --> 00:33:37,039
i'd like to thank everybody that has

00:33:35,120 --> 00:33:38,320
stayed with us throughout the entire

00:33:37,039 --> 00:33:41,840
presentation

00:33:38,320 --> 00:33:45,120
we're going to open this up to a q a

00:33:41,840 --> 00:33:45,519
and for the q a i'd like to bring in our

00:33:45,120 --> 00:33:47,679
chief

00:33:45,519 --> 00:33:49,440
architect the core designer of the

00:33:47,679 --> 00:33:52,559
software enabled flash api

00:33:49,440 --> 00:33:54,960
and technology mr rory bolt

00:33:52,559 --> 00:33:55,679
rory if you're there go ahead and come

00:33:54,960 --> 00:33:58,720
on board

00:33:55,679 --> 00:34:01,760
and say hello and uh

00:33:58,720 --> 00:34:05,279
we'll go ahead and open this up for

00:34:01,760 --> 00:34:07,200
q a cassandra can you help with that

00:34:05,279 --> 00:34:08,879
of course if anybody has any questions

00:34:07,200 --> 00:34:11,040
for scott or rory

00:34:08,879 --> 00:34:12,800
feel free to drop them in the q a box at

00:34:11,040 --> 00:34:13,679
the bottom of your screen and they'll go

00:34:12,800 --> 00:34:16,960
ahead and read them

00:34:13,679 --> 00:34:21,839
and answer them so anybody is welcome to

00:34:16,960 --> 00:34:21,839
ask a question

00:34:22,720 --> 00:34:25,839
so we'll give it a few minutes uh rory

00:34:24,639 --> 00:34:28,560
while we're waiting for a

00:34:25,839 --> 00:34:30,240
few questions uh is there anything you'd

00:34:28,560 --> 00:34:34,079
like to say to the

00:34:30,240 --> 00:34:36,399
linux developer community out there

00:34:34,079 --> 00:34:37,839
i guess uh first and foremost uh one of

00:34:36,399 --> 00:34:38,399
the things that we're really striving

00:34:37,839 --> 00:34:41,760
for

00:34:38,399 --> 00:34:44,879
um in the sdk that's currently the main

00:34:41,760 --> 00:34:48,079
focus of my efforts

00:34:44,879 --> 00:34:50,720
is ensuring uh that it meets all

00:34:48,079 --> 00:34:51,119
the use cases uh that we've been exposed

00:34:50,720 --> 00:34:53,599
to

00:34:51,119 --> 00:34:54,560
through all of our contacts with all our

00:34:53,599 --> 00:34:57,040
customers uh

00:34:54,560 --> 00:34:58,079
in the hyperscale community as well as

00:34:57,040 --> 00:34:59,599
um

00:34:58,079 --> 00:35:01,119
you know just trying to emphasize the

00:34:59,599 --> 00:35:03,839
fact uh

00:35:01,119 --> 00:35:05,200
that kyokushi actually invented uh uh

00:35:03,839 --> 00:35:08,000
flash media

00:35:05,200 --> 00:35:08,640
and uh we've been in the ssd business

00:35:08,000 --> 00:35:11,760
for

00:35:08,640 --> 00:35:13,280
you know quite a long time now um and so

00:35:11,760 --> 00:35:15,280
i really just want to set the

00:35:13,280 --> 00:35:17,280
expectation that uh

00:35:15,280 --> 00:35:18,640
the reference ftl is going to be a very

00:35:17,280 --> 00:35:22,720
high quality ftl

00:35:18,640 --> 00:35:26,240
um that that incorporates uh literally

00:35:22,720 --> 00:35:28,320
you know decades of experience in in uh

00:35:26,240 --> 00:35:31,760
controlling flash devices

00:35:28,320 --> 00:35:33,359
and scott uh already mentioned um

00:35:31,760 --> 00:35:35,520
you know one of the things that that

00:35:33,359 --> 00:35:38,800
makes uh

00:35:35,520 --> 00:35:39,920
flash based uh storage devices uh so

00:35:38,800 --> 00:35:42,400
powerful

00:35:39,920 --> 00:35:45,040
is their inherent parallelism the fact

00:35:42,400 --> 00:35:46,480
that that um

00:35:45,040 --> 00:35:49,200
you know there are multiple dyes that

00:35:46,480 --> 00:35:52,240
can all be operating independently

00:35:49,200 --> 00:35:56,880
and that allows us to control

00:35:52,240 --> 00:36:00,079
both bandwidth as well as

00:35:56,880 --> 00:36:01,680
interaction between applications and so

00:36:00,079 --> 00:36:03,520
it looks now that we have

00:36:01,680 --> 00:36:05,440
uh some questions we got a couple

00:36:03,520 --> 00:36:07,920
questions rory let me read off the uh

00:36:05,440 --> 00:36:11,440
the first one here that i think is uh

00:36:07,920 --> 00:36:14,320
uh very uh germain uh this uh from yash

00:36:11,440 --> 00:36:16,000
brahmani as a developer can

00:36:14,320 --> 00:36:20,720
software-enabled flash be

00:36:16,000 --> 00:36:23,440
implemented locally using flash apis

00:36:20,720 --> 00:36:24,800
all right um and once again feel free to

00:36:23,440 --> 00:36:26,800
follow up

00:36:24,800 --> 00:36:29,200
if this doesn't directly answer your

00:36:26,800 --> 00:36:32,560
question software-enabled flash

00:36:29,200 --> 00:36:33,359
um really is a pairing of the software

00:36:32,560 --> 00:36:37,359
apis

00:36:33,359 --> 00:36:39,520
and the sdk with an actual

00:36:37,359 --> 00:36:40,720
hardware device and so there are some

00:36:39,520 --> 00:36:42,800
unique aspects

00:36:40,720 --> 00:36:45,839
to the software-enabled flash controller

00:36:42,800 --> 00:36:45,839
that are necessary

00:36:47,040 --> 00:36:55,440
to interact with with the api itself

00:36:50,960 --> 00:36:57,280
but there's no need uh to

00:36:55,440 --> 00:36:58,560
although we're compatible with things

00:36:57,280 --> 00:37:01,839
like uh

00:36:58,560 --> 00:37:04,320
nvmeof there's no need to have

00:37:01,839 --> 00:37:06,160
distributed uh storage with software

00:37:04,320 --> 00:37:07,119
enabled flash and so it's entirely

00:37:06,160 --> 00:37:09,839
possible

00:37:07,119 --> 00:37:10,640
to have a single software-enabled flash

00:37:09,839 --> 00:37:13,119
device

00:37:10,640 --> 00:37:15,680
in a standalone computer and have

00:37:13,119 --> 00:37:18,240
software

00:37:15,680 --> 00:37:19,280
interacting with it locally so hopefully

00:37:18,240 --> 00:37:22,000
that is

00:37:19,280 --> 00:37:25,280
directed at the intent of the question

00:37:22,000 --> 00:37:25,280
and if not please follow up

00:37:31,200 --> 00:37:35,119
thank you rory we don't have any

00:37:32,880 --> 00:37:37,520
additional q a yet

00:37:35,119 --> 00:37:38,880
if i could just to keep us going just a

00:37:37,520 --> 00:37:41,040
little longer in case there's more

00:37:38,880 --> 00:37:44,240
questions that pop up

00:37:41,040 --> 00:37:45,359
in terms of the api and the sdk i talked

00:37:44,240 --> 00:37:48,480
quite a bit about

00:37:45,359 --> 00:37:50,560
the multi-protocol capabilities

00:37:48,480 --> 00:37:52,160
do you have a different capability or a

00:37:50,560 --> 00:37:53,839
different functionality built in that

00:37:52,160 --> 00:37:56,160
you think is the uh

00:37:53,839 --> 00:37:58,640
a key or an important facet for people

00:37:56,160 --> 00:37:58,640
to consider

00:38:01,599 --> 00:38:05,280
well um once again there are the

00:38:04,320 --> 00:38:07,839
additional uh

00:38:05,280 --> 00:38:09,119
resources that that are available on the

00:38:07,839 --> 00:38:12,400
software enable flash

00:38:09,119 --> 00:38:13,680
website uh one of the things that was

00:38:12,400 --> 00:38:17,040
introduced in this

00:38:13,680 --> 00:38:20,160
uh webinar but i think is really

00:38:17,040 --> 00:38:23,440
fairly unique is both the

00:38:20,160 --> 00:38:25,440
the hardware isolation as well as as the

00:38:23,440 --> 00:38:26,400
software isolation which really wasn't

00:38:25,440 --> 00:38:28,640
uh talked about

00:38:26,400 --> 00:38:29,920
in here with the qos domains on some of

00:38:28,640 --> 00:38:32,880
the technical deep dives

00:38:29,920 --> 00:38:35,680
we can get into more of the features and

00:38:32,880 --> 00:38:38,800
functionalities of the

00:38:35,680 --> 00:38:41,680
isolation capabilities as well

00:38:38,800 --> 00:38:42,720
as the scheduler and it's really the

00:38:41,680 --> 00:38:46,000
combination

00:38:42,720 --> 00:38:48,960
of the isolation capabilities which

00:38:46,000 --> 00:38:50,320
define which die are involved with

00:38:48,960 --> 00:38:53,440
interactions

00:38:50,320 --> 00:38:55,200
which therefore determines the amount of

00:38:53,440 --> 00:38:56,480
parallelism and the bandwidth available

00:38:55,200 --> 00:38:59,440
to the applications

00:38:56,480 --> 00:39:01,359
as well as the scheduler which really

00:38:59,440 --> 00:39:04,640
controls the latency and so

00:39:01,359 --> 00:39:08,320
you know to me uh probably

00:39:04,640 --> 00:39:10,880
the biggest uh uh potential

00:39:08,320 --> 00:39:12,240
game changer if you will for individual

00:39:10,880 --> 00:39:15,599
applications

00:39:12,240 --> 00:39:16,560
is to be able to have uh control over

00:39:15,599 --> 00:39:19,200
your bandwidth

00:39:16,560 --> 00:39:19,760
and your latency outcomes uh you know

00:39:19,200 --> 00:39:22,079
which

00:39:19,760 --> 00:39:23,280
typically uh has not been available to

00:39:22,079 --> 00:39:25,599
applications

00:39:23,280 --> 00:39:27,760
uh in the past right you're sharing

00:39:25,599 --> 00:39:30,400
these devices

00:39:27,760 --> 00:39:32,079
and you really don't have a lot of

00:39:30,400 --> 00:39:33,839
control over what's going on within the

00:39:32,079 --> 00:39:38,560
devices and what the competing

00:39:33,839 --> 00:39:43,520
uh workloads are and how you

00:39:38,560 --> 00:39:46,079
prioritize against even internal uh um

00:39:43,520 --> 00:39:47,680
housekeeping activities of the device

00:39:46,079 --> 00:39:49,920
three

00:39:47,680 --> 00:39:51,839
uh there's a question here in regards to

00:39:49,920 --> 00:39:56,320
qs domains are qs domains

00:39:51,839 --> 00:39:59,839
limited to a single device

00:39:56,320 --> 00:40:03,280
so um this is an area uh where we

00:39:59,839 --> 00:40:04,480
would love uh more community feedback to

00:40:03,280 --> 00:40:08,319
be honest with you

00:40:04,480 --> 00:40:11,599
um so in the version one of the api

00:40:08,319 --> 00:40:14,720
uh qs domains are in fact defined

00:40:11,599 --> 00:40:18,720
on a per device basis although

00:40:14,720 --> 00:40:21,760
of course you can

00:40:18,720 --> 00:40:23,839
group qos domains across devices

00:40:21,760 --> 00:40:26,000
by using things like the md filter

00:40:23,839 --> 00:40:30,079
drivers if you want

00:40:26,000 --> 00:40:33,200
so that's one mechanism to do it

00:40:30,079 --> 00:40:36,240
control over qs domains across

00:40:33,200 --> 00:40:40,000
devices is actually something that

00:40:36,240 --> 00:40:43,040
is on the uh backlog list for

00:40:40,000 --> 00:40:45,680
a future version of the api

00:40:43,040 --> 00:40:46,720
but we're really waiting for customer

00:40:45,680 --> 00:40:49,760
feedback

00:40:46,720 --> 00:40:50,640
um in particular you know one of the

00:40:49,760 --> 00:40:53,440
things

00:40:50,640 --> 00:40:55,119
that we have heard from many

00:40:53,440 --> 00:40:58,640
hyperscalers

00:40:55,119 --> 00:41:03,359
is that they view a lot of

00:40:58,640 --> 00:41:06,079
things that traditional drives

00:41:03,359 --> 00:41:07,920
and arrays do for that matter as

00:41:06,079 --> 00:41:11,040
overheads and not necessarily

00:41:07,920 --> 00:41:12,000
advantages to them so you know a typical

00:41:11,040 --> 00:41:15,440
hyperscale

00:41:12,000 --> 00:41:19,119
uh data center is already mirroring

00:41:15,440 --> 00:41:21,680
uh data um

00:41:19,119 --> 00:41:23,040
you know across in some cases they're

00:41:21,680 --> 00:41:26,079
doing triple mirroring

00:41:23,040 --> 00:41:30,000
uh two in the same rack and one uh at

00:41:26,079 --> 00:41:33,520
some geographic distance

00:41:30,000 --> 00:41:36,560
um in those types of environments

00:41:33,520 --> 00:41:39,200
they actually like to control um

00:41:36,560 --> 00:41:40,960
the grouping across devices and they

00:41:39,200 --> 00:41:44,319
view

00:41:40,960 --> 00:41:47,280
subsystems doing that as sort of a tax

00:41:44,319 --> 00:41:49,440
um or a black box that that sort of

00:41:47,280 --> 00:41:53,040
interferes with their intent

00:41:49,440 --> 00:41:56,640
but once again uh you know we've gotten

00:41:53,040 --> 00:41:59,839
a little bit of feedback uh on

00:41:56,640 --> 00:42:01,680
cross device qs domains but we're

00:41:59,839 --> 00:42:04,800
certainly

00:42:01,680 --> 00:42:06,800
as with any open source project we're

00:42:04,800 --> 00:42:08,319
out to meet the needs of the community

00:42:06,800 --> 00:42:10,480
and so we would like to understand the

00:42:08,319 --> 00:42:13,119
needs uh more thoroughly and please

00:42:10,480 --> 00:42:13,599
feel free to follow up with us regarding

00:42:13,119 --> 00:42:17,359
your

00:42:13,599 --> 00:42:19,680
individual use cases and needs

00:42:17,359 --> 00:42:20,720
great now we have one more question i

00:42:19,680 --> 00:42:22,480
think we can take this

00:42:20,720 --> 00:42:23,839
one we're getting close to our time

00:42:22,480 --> 00:42:26,880
limit but

00:42:23,839 --> 00:42:30,079
there's a question in regards to

00:42:26,880 --> 00:42:32,240
security please give your experience

00:42:30,079 --> 00:42:34,800
on firmware level cyber security with

00:42:32,240 --> 00:42:37,280
regards to protecting data centers

00:42:34,800 --> 00:42:38,960
and i'd like to extend that one slightly

00:42:37,280 --> 00:42:42,480
uh rory

00:42:38,960 --> 00:42:44,000
the ability to define security by qos

00:42:42,480 --> 00:42:45,119
domain was something that you and i

00:42:44,000 --> 00:42:47,599
talked about

00:42:45,119 --> 00:42:48,880
last week as well so let's let's add

00:42:47,599 --> 00:42:51,359
that to

00:42:48,880 --> 00:42:53,440
the question here on firmware level

00:42:51,359 --> 00:42:56,079
cyber security in the data center

00:42:53,440 --> 00:42:57,280
right and so i'll actually take that one

00:42:56,079 --> 00:42:59,760
first and then i'll

00:42:57,280 --> 00:43:01,280
start going up to the to the higher

00:42:59,760 --> 00:43:05,359
level questions

00:43:01,280 --> 00:43:08,160
um so within software enabled flash api

00:43:05,359 --> 00:43:10,079
we have the notion of physical dye

00:43:08,160 --> 00:43:13,359
isolation

00:43:10,079 --> 00:43:15,280
and so you can group physical dye into a

00:43:13,359 --> 00:43:18,319
virtual device

00:43:15,280 --> 00:43:22,400
and that virtual device can then have

00:43:18,319 --> 00:43:25,760
one or more qos domains mapped onto it

00:43:22,400 --> 00:43:26,560
and the qos domains are what present

00:43:25,760 --> 00:43:29,920
themselves

00:43:26,560 --> 00:43:32,800
as device nodes to the system

00:43:29,920 --> 00:43:33,359
so you can have individual access rights

00:43:32,800 --> 00:43:36,079
uh

00:43:33,359 --> 00:43:36,400
to the various qs domains but one thing

00:43:36,079 --> 00:43:37,920
that

00:43:36,400 --> 00:43:39,680
certainly wasn't covered in this

00:43:37,920 --> 00:43:41,839
presentation

00:43:39,680 --> 00:43:42,880
is that we actually have the ability to

00:43:41,839 --> 00:43:45,760
have

00:43:42,880 --> 00:43:46,640
separate encryption keys for each qs

00:43:45,760 --> 00:43:49,280
domain so

00:43:46,640 --> 00:43:51,040
you know here's once again in the realm

00:43:49,280 --> 00:43:54,800
of providing isolation

00:43:51,040 --> 00:43:56,480
in multi-tenant environments you can

00:43:54,800 --> 00:43:58,800
isolate against the noisy neighbor

00:43:56,480 --> 00:44:02,400
problem but you can also isolate against

00:43:58,800 --> 00:44:03,760
any sort of data leakage by in fact

00:44:02,400 --> 00:44:06,319
having separate

00:44:03,760 --> 00:44:06,839
encryption keys for each and every one

00:44:06,319 --> 00:44:10,400
of

00:44:06,839 --> 00:44:12,319
those qs domains now

00:44:10,400 --> 00:44:14,079
up leveling a little bit to the device

00:44:12,319 --> 00:44:18,240
itself um

00:44:14,079 --> 00:44:18,240
you know in modern times uh

00:44:18,319 --> 00:44:22,720
frankly uh um i don't know of anyone's

00:44:21,920 --> 00:44:26,160
of the major

00:44:22,720 --> 00:44:30,079
uh ssd providers that isn't already

00:44:26,160 --> 00:44:32,000
digitally signing their uh

00:44:30,079 --> 00:44:33,599
their firmware to try and prevent

00:44:32,000 --> 00:44:36,480
against the tax

00:44:33,599 --> 00:44:37,680
depending upon the hyperscale vendor

00:44:36,480 --> 00:44:41,119
there are actually uh

00:44:37,680 --> 00:44:41,680
um even protections outside of the

00:44:41,119 --> 00:44:44,079
device

00:44:41,680 --> 00:44:45,040
um it's it's you know sort of

00:44:44,079 --> 00:44:47,760
interesting

00:44:45,040 --> 00:44:49,440
to note that that the hyperscale layer

00:44:47,760 --> 00:44:52,000
many of these people actually don't

00:44:49,440 --> 00:44:52,880
trust devices plugged into their pca

00:44:52,000 --> 00:44:55,280
buses they're

00:44:52,880 --> 00:44:56,720
they're encrypting over the pca bus and

00:44:55,280 --> 00:44:59,839
they're actually putting

00:44:56,720 --> 00:45:00,800
security chips as sort of uh proxies

00:44:59,839 --> 00:45:03,920
between the

00:45:00,800 --> 00:45:05,280
root nodes and the devices on the pcie

00:45:03,920 --> 00:45:08,720
buses

00:45:05,280 --> 00:45:11,520
so we work very very closely

00:45:08,720 --> 00:45:13,680
uh with our hyperscale customers to meet

00:45:11,520 --> 00:45:18,319
their security requirements

00:45:13,680 --> 00:45:21,520
um and uh um you know frankly uh uh

00:45:18,319 --> 00:45:25,040
the the hyperscale data centers uh

00:45:21,520 --> 00:45:26,880
i am truly impressed with uh with

00:45:25,040 --> 00:45:28,240
the length that they're taking to try

00:45:26,880 --> 00:45:30,079
and um

00:45:28,240 --> 00:45:33,520
uh maintain the integrity of their

00:45:30,079 --> 00:45:35,359
systems uh so once again if we didn't

00:45:33,520 --> 00:45:37,680
address your question thoroughly and

00:45:35,359 --> 00:45:40,800
trying to do it at a fairly high level

00:45:37,680 --> 00:45:42,880
um please follow up with us

00:45:40,800 --> 00:45:44,319
yeah with with that said rory once again

00:45:42,880 --> 00:45:45,760
thank you for joining and uh helping

00:45:44,319 --> 00:45:47,760
with the q a section here or

00:45:45,760 --> 00:45:49,280
actually doing all the q a session

00:45:47,760 --> 00:45:51,839
really appreciate it

00:45:49,280 --> 00:45:53,599
um we're going to turn this back over to

00:45:51,839 --> 00:45:54,000
cassandra on the linux foundation as

00:45:53,599 --> 00:45:56,000
we've

00:45:54,000 --> 00:45:57,599
reached our time limit uh i'd like to

00:45:56,000 --> 00:46:01,200
thank everybody that has

00:45:57,599 --> 00:46:02,800
stuck with us through the entire session

00:46:01,200 --> 00:46:05,119
and again if you have any questions

00:46:02,800 --> 00:46:07,359
please reach out to us by email

00:46:05,119 --> 00:46:09,760
thank you very much cassandra back to

00:46:07,359 --> 00:46:11,280
you thank you so much scott and rory for

00:46:09,760 --> 00:46:13,119
your time today and thank you to

00:46:11,280 --> 00:46:15,119
everybody who participated

00:46:13,119 --> 00:46:17,040
as a reminder this reporting will be on

00:46:15,119 --> 00:46:17,760
the linux foundation's youtube page by

00:46:17,040 --> 00:46:19,280
tomorrow

00:46:17,760 --> 00:46:22,000
and we hope you join us for future

00:46:19,280 --> 00:46:26,240
webinars have a wonderful day

00:46:22,000 --> 00:46:26,240

YouTube URL: https://www.youtube.com/watch?v=hYyhOOUbFlY


