Title: Webinar: Making CI CD Builds Faster, sponsored by CircleCI
Publication date: 2021-01-26
Playlist: LF Live Webinars
Description: 
	
Captions: 
	00:00:00,240 --> 00:00:06,640
the nice introduction

00:00:03,600 --> 00:00:09,679
so yeah when

00:00:06,640 --> 00:00:13,599
maintaining cicd pipelines we

00:00:09,679 --> 00:00:16,800
always are compelled to automate

00:00:13,599 --> 00:00:20,160
more of the process and

00:00:16,800 --> 00:00:23,439
the more we automate the more

00:00:20,160 --> 00:00:27,279
slower they'll get usually unfortunately

00:00:23,439 --> 00:00:29,679
but so today i'm hoping that i can

00:00:27,279 --> 00:00:31,519
share some insights and tips and tricks

00:00:29,679 --> 00:00:34,000
about

00:00:31,519 --> 00:00:36,079
making your build faster and your

00:00:34,000 --> 00:00:38,160
deployments and software delivery more

00:00:36,079 --> 00:00:40,399
enjoyable

00:00:38,160 --> 00:00:42,160
my name is zan i'm a developer advocate

00:00:40,399 --> 00:00:45,520
at circle ci

00:00:42,160 --> 00:00:48,000
i'm based in london uk and uh my

00:00:45,520 --> 00:00:49,600
greatest joy is uh enabling and

00:00:48,000 --> 00:00:50,399
inspiring developers all around the

00:00:49,600 --> 00:00:53,280
world

00:00:50,399 --> 00:00:54,079
um yeah so if you'd like to get in touch

00:00:53,280 --> 00:00:56,840
with me

00:00:54,079 --> 00:00:58,960
i'm quite active on twitter so

00:00:56,840 --> 00:01:03,280
twitter.com zmarken

00:00:58,960 --> 00:01:06,880
or email me at xan circleci.com

00:01:03,280 --> 00:01:10,880
so yeah without further ado let's uh

00:01:06,880 --> 00:01:13,119
let's begin so yeah

00:01:10,880 --> 00:01:14,240
what we'll cover today is uh we'll cover

00:01:13,119 --> 00:01:17,680
some motivation

00:01:14,240 --> 00:01:21,439
why uh we should really be interested

00:01:17,680 --> 00:01:25,360
in our build times and why should we be

00:01:21,439 --> 00:01:29,040
kind of on top of them and uh

00:01:25,360 --> 00:01:31,360
yeah we'll look at how some ways and

00:01:29,040 --> 00:01:33,280
techniques we could use to track and

00:01:31,360 --> 00:01:36,560
measure our build times

00:01:33,280 --> 00:01:40,960
identify problems and bottlenecks

00:01:36,560 --> 00:01:44,159
and also decide how to react on those

00:01:40,960 --> 00:01:46,640
how to improve our build times

00:01:44,159 --> 00:01:47,360
and then yeah we'll actually look at how

00:01:46,640 --> 00:01:49,920
to react

00:01:47,360 --> 00:01:51,600
to some of those with practical examples

00:01:49,920 --> 00:01:54,079
um

00:01:51,600 --> 00:01:54,720
and yeah in a summary we'll cover what

00:01:54,079 --> 00:01:58,000
we covered

00:01:54,720 --> 00:02:03,759
and uh where to go next with some

00:01:58,000 --> 00:02:03,759
q a so yeah i hope you enjoy it

00:02:04,079 --> 00:02:10,239
i've lived through this

00:02:07,439 --> 00:02:11,200
so this problem of builds taking too

00:02:10,239 --> 00:02:14,400
long

00:02:11,200 --> 00:02:15,520
i know this issue too hard like very

00:02:14,400 --> 00:02:19,360
well

00:02:15,520 --> 00:02:20,959
and i'm pretty sure some of you if not

00:02:19,360 --> 00:02:23,840
most of you have heard this one

00:02:20,959 --> 00:02:23,840
as well before

00:02:25,280 --> 00:02:32,879
my story about builds taking too long is

00:02:29,760 --> 00:02:34,160
about five six years old i was on an

00:02:32,879 --> 00:02:37,519
android development team

00:02:34,160 --> 00:02:40,800
and uh we managed to

00:02:37,519 --> 00:02:43,760
create a app and uh

00:02:40,800 --> 00:02:45,200
that took eight ish hours to build

00:02:43,760 --> 00:02:48,560
essentially whole day

00:02:45,200 --> 00:02:52,319
what this meant was i would get up

00:02:48,560 --> 00:02:55,760
check my email see okay ci has failed

00:02:52,319 --> 00:02:59,440
great uh poke around make

00:02:55,760 --> 00:03:02,400
some changes try to pass this build

00:02:59,440 --> 00:03:03,120
go to work spent most of my day working

00:03:02,400 --> 00:03:06,480
and

00:03:03,120 --> 00:03:08,159
before essentially coming back

00:03:06,480 --> 00:03:10,720
starting my journey back home i would

00:03:08,159 --> 00:03:12,720
discover oh the build has failed again

00:03:10,720 --> 00:03:14,640
so let's make those changes again and

00:03:12,720 --> 00:03:17,840
try to get it passing

00:03:14,640 --> 00:03:18,640
and this would this would repeat itself

00:03:17,840 --> 00:03:21,280
like

00:03:18,640 --> 00:03:22,480
all the time and for several days in a

00:03:21,280 --> 00:03:25,120
row until we got

00:03:22,480 --> 00:03:26,560
on top of this and our team was quite

00:03:25,120 --> 00:03:27,760
small it was like four or five

00:03:26,560 --> 00:03:30,959
developers so

00:03:27,760 --> 00:03:33,440
uh it wasn't very impactful but uh

00:03:30,959 --> 00:03:34,799
still it was a very frustrating

00:03:33,440 --> 00:03:38,080
frustrating time for

00:03:34,799 --> 00:03:41,360
for everyone because we couldn't really

00:03:38,080 --> 00:03:43,519
we couldn't deliver we couldn't ship um

00:03:41,360 --> 00:03:45,360
and yeah so this is my motivation

00:03:43,519 --> 00:03:48,270
personal motivation for

00:03:45,360 --> 00:03:49,360
giving this presentation and

00:03:48,270 --> 00:03:51,360
[Music]

00:03:49,360 --> 00:03:55,120
hopefully solving this problem for for

00:03:51,360 --> 00:03:55,120
some of some others as well

00:03:55,920 --> 00:04:01,680
so yeah before we go deep into

00:03:59,439 --> 00:04:03,120
builds and uh how everything kind of

00:04:01,680 --> 00:04:06,000
comes together let me

00:04:03,120 --> 00:04:06,640
take a step back and cover some of the

00:04:06,000 --> 00:04:09,519
basics

00:04:06,640 --> 00:04:10,959
that we will be repeating throughout the

00:04:09,519 --> 00:04:14,720
throughout this conversation

00:04:10,959 --> 00:04:16,880
so ci cd sits between

00:04:14,720 --> 00:04:18,560
developers committing code to their

00:04:16,880 --> 00:04:21,680
version control systems

00:04:18,560 --> 00:04:24,880
and productionizing this

00:04:21,680 --> 00:04:28,400
those applications essentially we

00:04:24,880 --> 00:04:32,000
circle ci are the leading

00:04:28,400 --> 00:04:34,400
uh cicd platform we take

00:04:32,000 --> 00:04:35,120
code from yeah your version control

00:04:34,400 --> 00:04:38,320
system

00:04:35,120 --> 00:04:40,240
we build it we test it we run a bunch of

00:04:38,320 --> 00:04:43,440
scripts and we deploy that

00:04:40,240 --> 00:04:45,759
through to um through

00:04:43,440 --> 00:04:46,880
your anywhere really like any

00:04:45,759 --> 00:04:50,560
application

00:04:46,880 --> 00:04:52,639
from mobile apps to to kubernetes uh

00:04:50,560 --> 00:04:54,000
applications we can deploy that pretty

00:04:52,639 --> 00:04:57,120
much anywhere

00:04:54,000 --> 00:04:59,280
and uh yeah

00:04:57,120 --> 00:05:00,639
that's how this works and i'll show you

00:04:59,280 --> 00:05:03,680
briefly how

00:05:00,639 --> 00:05:06,240
um how

00:05:03,680 --> 00:05:07,440
this product looks like the platform

00:05:06,240 --> 00:05:10,639
looks like and how

00:05:07,440 --> 00:05:12,560
we actually configure it so that

00:05:10,639 --> 00:05:13,759
when we're talking about this later

00:05:12,560 --> 00:05:17,240
you'll you'll know

00:05:13,759 --> 00:05:19,080
what this all is about so the platform

00:05:17,240 --> 00:05:21,919
circleci.com

00:05:19,080 --> 00:05:25,600
app.circleci.com is essentially

00:05:21,919 --> 00:05:27,039
this dashboard of your pipelines your

00:05:25,600 --> 00:05:31,199
projects

00:05:27,039 --> 00:05:33,840
let's look at one um for example this is

00:05:31,199 --> 00:05:36,800
one of my demo applications it's a

00:05:33,840 --> 00:05:40,960
node.js application

00:05:36,800 --> 00:05:44,479
and i've configured a bunch of workflows

00:05:40,960 --> 00:05:48,000
jobs builds and each time i

00:05:44,479 --> 00:05:50,560
commit something to to my

00:05:48,000 --> 00:05:51,680
github repository which is connected to

00:05:50,560 --> 00:05:54,479
it

00:05:51,680 --> 00:05:55,520
this basically triggers another build

00:05:54,479 --> 00:06:01,120
and what this does

00:05:55,520 --> 00:06:04,160
is this is this corresponding repository

00:06:01,120 --> 00:06:07,759
it takes the file called

00:06:04,160 --> 00:06:11,759
circleci config yml so a yaml file

00:06:07,759 --> 00:06:15,120
in the dot circle ci directory

00:06:11,759 --> 00:06:16,400
and analyzes it reads it and that's how

00:06:15,120 --> 00:06:20,319
we describe

00:06:16,400 --> 00:06:23,440
what we want our ci cd to really do

00:06:20,319 --> 00:06:26,560
in our case we're defining a bunch of

00:06:23,440 --> 00:06:28,960
jobs so build and test vulnerability

00:06:26,560 --> 00:06:31,440
scan deploy docker

00:06:28,960 --> 00:06:32,240
and a workflow called node test and

00:06:31,440 --> 00:06:34,639
deploy

00:06:32,240 --> 00:06:36,160
we'll see this when we return to the

00:06:34,639 --> 00:06:38,960
dashboard

00:06:36,160 --> 00:06:39,840
and we specify how we want our workflow

00:06:38,960 --> 00:06:42,080
to look like

00:06:39,840 --> 00:06:42,960
in what order we want those jobs to

00:06:42,080 --> 00:06:46,000
execute and

00:06:42,960 --> 00:06:47,520
uh so on

00:06:46,000 --> 00:06:49,120
so anything anything can go really in

00:06:47,520 --> 00:06:51,039
those jobs uh

00:06:49,120 --> 00:06:52,160
they can run on various different

00:06:51,039 --> 00:06:55,520
environments from

00:06:52,160 --> 00:06:56,160
docker containers to mac os uh virtual

00:06:55,520 --> 00:06:59,360
machines

00:06:56,160 --> 00:07:02,000
to windows machines all sorts of stuff

00:06:59,360 --> 00:07:05,520
different sizes different uh

00:07:02,000 --> 00:07:09,199
different platforms uh

00:07:05,520 --> 00:07:11,840
yeah so going back to my

00:07:09,199 --> 00:07:14,319
pipeline you can see that for each

00:07:11,840 --> 00:07:16,639
commit that i've made

00:07:14,319 --> 00:07:17,599
it's kind of triggered and it basically

00:07:16,639 --> 00:07:20,560
does

00:07:17,599 --> 00:07:21,280
what i told it to do so in our case i've

00:07:20,560 --> 00:07:24,319
configured

00:07:21,280 --> 00:07:25,440
my pipeline to say yeah do some testing

00:07:24,319 --> 00:07:28,960
do some building

00:07:25,440 --> 00:07:30,160
do some vulnerability scan and then wait

00:07:28,960 --> 00:07:33,440
for me to approve this

00:07:30,160 --> 00:07:33,840
to to before deploying this to docker

00:07:33,440 --> 00:07:37,919
hub

00:07:33,840 --> 00:07:39,520
as a new docker image

00:07:37,919 --> 00:07:42,840
but yeah whatever whatever you're

00:07:39,520 --> 00:07:45,440
building it doesn't really matter

00:07:42,840 --> 00:07:48,560
um but yeah that's

00:07:45,440 --> 00:07:51,520
kind of the idea we've explained uh

00:07:48,560 --> 00:07:52,639
workflows contains everything that gets

00:07:51,520 --> 00:07:56,080
triggered from

00:07:52,639 --> 00:07:59,759
uh vcs commit jobs which is an

00:07:56,080 --> 00:08:02,800
individual kind of test verification

00:07:59,759 --> 00:08:04,960
building step um

00:08:02,800 --> 00:08:07,440
and yeah the whole thing is called a

00:08:04,960 --> 00:08:07,440
pipeline

00:08:07,599 --> 00:08:13,100
okay let's go back now that we know how

00:08:11,360 --> 00:08:14,960
everything kind of comes together

00:08:13,100 --> 00:08:17,919
[Music]

00:08:14,960 --> 00:08:20,000
let's go back to build speed why do you

00:08:17,919 --> 00:08:23,440
really want to care about build speed

00:08:20,000 --> 00:08:26,479
so the way i see it teams

00:08:23,440 --> 00:08:28,479
that don't wait for their builds are

00:08:26,479 --> 00:08:31,520
more productive and they can ship more

00:08:28,479 --> 00:08:33,680
and they're more effective developers

00:08:31,520 --> 00:08:35,760
they're happier developers because

00:08:33,680 --> 00:08:39,120
they're more productive

00:08:35,760 --> 00:08:42,399
um faster builds also mean

00:08:39,120 --> 00:08:45,600
that we're able to react and

00:08:42,399 --> 00:08:47,920
uh action change faster and

00:08:45,600 --> 00:08:49,680
actioning change faster is very

00:08:47,920 --> 00:08:52,959
important in this

00:08:49,680 --> 00:08:56,240
day and age um and

00:08:52,959 --> 00:08:58,160
not only faster builds that pass but

00:08:56,240 --> 00:08:59,040
also faster failing builds we really

00:08:58,160 --> 00:09:01,920
want to get

00:08:59,040 --> 00:09:02,800
to some kind of signal telling us okay

00:09:01,920 --> 00:09:05,120
our code is

00:09:02,800 --> 00:09:06,560
not doing what it's supposed to do

00:09:05,120 --> 00:09:09,680
because some tests are failing

00:09:06,560 --> 00:09:12,240
some something else is failing and

00:09:09,680 --> 00:09:14,399
uh we don't want to wait eight hours for

00:09:12,240 --> 00:09:17,519
example for this we want

00:09:14,399 --> 00:09:19,760
minutes we want uh yeah

00:09:17,519 --> 00:09:22,080
up to an hour whatever whatever whatever

00:09:19,760 --> 00:09:25,680
is important for your project really

00:09:22,080 --> 00:09:28,560
and yeah inverse to this slower builds

00:09:25,680 --> 00:09:29,360
means you're less capable to change less

00:09:28,560 --> 00:09:33,040
capable

00:09:29,360 --> 00:09:36,800
to adapt and your business is ultimately

00:09:33,040 --> 00:09:39,920
less competitive so yeah

00:09:36,800 --> 00:09:44,880
that's why we really need to care

00:09:39,920 --> 00:09:47,519
and worry about build speeds

00:09:44,880 --> 00:09:48,000
having said that let's look at how we

00:09:47,519 --> 00:09:50,080
might

00:09:48,000 --> 00:09:51,440
want to measure and track our build

00:09:50,080 --> 00:09:54,640
durations and

00:09:51,440 --> 00:09:57,120
in order to get on top of them

00:09:54,640 --> 00:09:57,839
first off how do you know that something

00:09:57,120 --> 00:10:00,000
is

00:09:57,839 --> 00:10:01,360
gone wrong something is broken with your

00:10:00,000 --> 00:10:03,440
build

00:10:01,360 --> 00:10:04,800
we're really really going to start with

00:10:03,440 --> 00:10:06,480
that because it's

00:10:04,800 --> 00:10:08,160
you can't really operate on a hunch you

00:10:06,480 --> 00:10:10,500
really need to know uh

00:10:08,160 --> 00:10:11,920
exactly what and uh

00:10:10,500 --> 00:10:15,920
[Music]

00:10:11,920 --> 00:10:19,200
how is going on so i've identified

00:10:15,920 --> 00:10:22,480
a few ways that

00:10:19,200 --> 00:10:25,040
you can look at this but

00:10:22,480 --> 00:10:26,079
there's by no means that they're not all

00:10:25,040 --> 00:10:28,399
of them obviously

00:10:26,079 --> 00:10:29,440
so you could see that your build times

00:10:28,399 --> 00:10:33,519
have been increasing

00:10:29,440 --> 00:10:35,760
you could be measuring and tracking

00:10:33,519 --> 00:10:38,560
for each build you kind of track okay

00:10:35,760 --> 00:10:41,760
this one has taken

00:10:38,560 --> 00:10:43,839
uh 10 minutes and the next week you're

00:10:41,760 --> 00:10:45,440
after 20 minutes so something must have

00:10:43,839 --> 00:10:48,959
happened that

00:10:45,440 --> 00:10:51,920
your build time has basically doubled um

00:10:48,959 --> 00:10:53,279
builds could be more broken now than

00:10:51,920 --> 00:10:55,760
they were before

00:10:53,279 --> 00:10:56,399
and that's another kind of indicator

00:10:55,760 --> 00:10:59,440
that

00:10:56,399 --> 00:11:00,000
something is something is not there and

00:10:59,440 --> 00:11:01,839
ultimately

00:11:00,000 --> 00:11:04,160
your your team will tell you like your

00:11:01,839 --> 00:11:07,200
team will tell you in retrospectives

00:11:04,160 --> 00:11:09,040
your team will tell you uh that yeah

00:11:07,200 --> 00:11:11,600
they have a problem with ci cd

00:11:09,040 --> 00:11:12,480
it and ci cd is the last thing you want

00:11:11,600 --> 00:11:15,120
to come up

00:11:12,480 --> 00:11:16,079
in in retros that it's broken because it

00:11:15,120 --> 00:11:18,320
means that

00:11:16,079 --> 00:11:19,279
you're not able to ship you're not able

00:11:18,320 --> 00:11:22,320
to

00:11:19,279 --> 00:11:23,040
to do so automatically and uh you're

00:11:22,320 --> 00:11:26,000
relying

00:11:23,040 --> 00:11:26,640
on a lot of error-prone human local

00:11:26,000 --> 00:11:30,480
builds

00:11:26,640 --> 00:11:32,399
and uh manual processes to

00:11:30,480 --> 00:11:33,920
to action your change that you're trying

00:11:32,399 --> 00:11:36,860
to that you're trying to

00:11:33,920 --> 00:11:38,320
deploy and yeah

00:11:36,860 --> 00:11:41,360
[Music]

00:11:38,320 --> 00:11:42,560
a couple of questions is a good thing to

00:11:41,360 --> 00:11:45,040
start about

00:11:42,560 --> 00:11:45,600
your your builds when when you're kind

00:11:45,040 --> 00:11:48,240
of

00:11:45,600 --> 00:11:48,959
looking at ways to benchmark this first

00:11:48,240 --> 00:11:50,800
off

00:11:48,959 --> 00:11:52,000
what's happening right i've covered a

00:11:50,800 --> 00:11:55,600
bunch of them before

00:11:52,000 --> 00:11:58,639
are your builds slower are your builds

00:11:55,600 --> 00:11:59,360
less less prone to sucks well more

00:11:58,639 --> 00:12:02,000
error-prone

00:11:59,360 --> 00:12:02,000
more flaky

00:12:03,200 --> 00:12:09,760
so you might also be able to identify

00:12:06,720 --> 00:12:10,160
which parts of your builds are the most

00:12:09,760 --> 00:12:12,240
probably

00:12:10,160 --> 00:12:14,000
problematic maybe it's not the whole

00:12:12,240 --> 00:12:16,639
build that is failing

00:12:14,000 --> 00:12:18,639
more often maybe it's just a part of it

00:12:16,639 --> 00:12:22,320
that has suddenly become

00:12:18,639 --> 00:12:24,639
slower more flaky and

00:12:22,320 --> 00:12:26,639
less stable how stable are your builds

00:12:24,639 --> 00:12:30,240
are you able to say

00:12:26,639 --> 00:12:33,519
yes today we're at uh ninety percent

00:12:30,240 --> 00:12:34,560
uh success rate for our builds and last

00:12:33,519 --> 00:12:38,240
week we were at

00:12:34,560 --> 00:12:40,320
95 so where did this five percent go

00:12:38,240 --> 00:12:41,279
uh and ultimately are they deterministic

00:12:40,320 --> 00:12:43,519
or flaky

00:12:41,279 --> 00:12:44,720
ideally you want to be as deterministic

00:12:43,519 --> 00:12:46,959
as possible so

00:12:44,720 --> 00:12:49,120
you run a single build on a single

00:12:46,959 --> 00:12:51,839
commit and it's always gonna be

00:12:49,120 --> 00:12:52,880
either passing or failing and never like

00:12:51,839 --> 00:12:55,839
halfway

00:12:52,880 --> 00:12:57,920
sometimes passing sometimes failing um

00:12:55,839 --> 00:12:59,920
but yeah for for speed we're really

00:12:57,920 --> 00:13:02,160
mostly going to focus on what's

00:12:59,920 --> 00:13:04,720
happening to your builds and

00:13:02,160 --> 00:13:06,399
identifying which parts might be the

00:13:04,720 --> 00:13:09,360
most problematic because

00:13:06,399 --> 00:13:10,560
that's often what you'll find is that a

00:13:09,360 --> 00:13:13,920
certain job a certain

00:13:10,560 --> 00:13:17,519
test that are taking longer than

00:13:13,920 --> 00:13:20,079
uh than the whole other part of your

00:13:17,519 --> 00:13:23,279
build essentially

00:13:20,079 --> 00:13:26,639
um yeah so

00:13:23,279 --> 00:13:27,839
we have uh recently released uh circle

00:13:26,639 --> 00:13:30,450
ci insights

00:13:27,839 --> 00:13:31,680
which basically tells you just that

00:13:30,450 --> 00:13:34,320
[Music]

00:13:31,680 --> 00:13:35,760
it tells you yeah how long your your

00:13:34,320 --> 00:13:38,480
builds are running so

00:13:35,760 --> 00:13:38,959
i went from one minute and 50 something

00:13:38,480 --> 00:13:42,079
to

00:13:38,959 --> 00:13:43,360
what five minutes uh reason for this is

00:13:42,079 --> 00:13:46,270
because i added the whole

00:13:43,360 --> 00:13:47,839
manual hold task that basically

00:13:46,270 --> 00:13:50,480
[Music]

00:13:47,839 --> 00:13:50,959
waited for me to to finish it but it's

00:13:50,480 --> 00:13:53,839
still

00:13:50,959 --> 00:13:54,480
reflecting on on my build you can also

00:13:53,839 --> 00:13:57,519
see that

00:13:54,480 --> 00:13:59,040
on your job so which whichever job

00:13:57,519 --> 00:14:01,760
you're kind of running so

00:13:59,040 --> 00:14:03,680
running my tests running my deployment

00:14:01,760 --> 00:14:07,760
um

00:14:03,680 --> 00:14:10,000
it identifies how long that takes and

00:14:07,760 --> 00:14:10,880
in my case yeah vulnerability scanning

00:14:10,000 --> 00:14:14,240
is what takes the

00:14:10,880 --> 00:14:15,680
the most of your of my build and usually

00:14:14,240 --> 00:14:16,639
you're usually going to find something

00:14:15,680 --> 00:14:19,680
like that

00:14:16,639 --> 00:14:22,320
when you're looking at it um

00:14:19,680 --> 00:14:24,240
obviously you you can do this with

00:14:22,320 --> 00:14:26,240
circle ci it's super convenient but

00:14:24,240 --> 00:14:27,839
like any any build tool it's able to

00:14:26,240 --> 00:14:31,760
kind of tell you

00:14:27,839 --> 00:14:34,959
it's ran for 50 seconds or it's ran for

00:14:31,760 --> 00:14:36,880
45 seconds and if you're

00:14:34,959 --> 00:14:38,959
if you're so keen you can actually just

00:14:36,880 --> 00:14:42,079
drop these into a

00:14:38,959 --> 00:14:42,839
csv or a spreadsheet and analyze them

00:14:42,079 --> 00:14:45,519
yourself

00:14:42,839 --> 00:14:46,000
right but yeah if you're using circle ci

00:14:45,519 --> 00:14:49,040
you have

00:14:46,000 --> 00:14:50,480
those insights right there as as you're

00:14:49,040 --> 00:14:53,600
developing

00:14:50,480 --> 00:14:55,760
um which is pretty cool

00:14:53,600 --> 00:14:58,000
so now we know what's happening to our

00:14:55,760 --> 00:15:00,639
builds we know which parts are slower

00:14:58,000 --> 00:15:01,920
which parts are faster so we know where

00:15:00,639 --> 00:15:05,760
to actually start

00:15:01,920 --> 00:15:05,760
focusing our efforts

00:15:09,680 --> 00:15:15,199
so now we can start

00:15:12,720 --> 00:15:16,320
looking at some techniques for

00:15:15,199 --> 00:15:19,040
optimization

00:15:16,320 --> 00:15:19,040
of our builds

00:15:19,839 --> 00:15:26,160
first technique is quite obvious

00:15:23,120 --> 00:15:27,199
but very easy to forget that software is

00:15:26,160 --> 00:15:31,440
built on machines

00:15:27,199 --> 00:15:35,360
and the more powerful your machine is

00:15:31,440 --> 00:15:39,120
your the faster it's going to perform

00:15:35,360 --> 00:15:43,040
right so uh fortunately that's

00:15:39,120 --> 00:15:46,720
quite easy for uh cicd

00:15:43,040 --> 00:15:49,839
to do right you just switch

00:15:46,720 --> 00:15:52,079
one line of code and uh you're using

00:15:49,839 --> 00:15:54,320
a machine of different size of more

00:15:52,079 --> 00:15:57,600
that's more performant that has more ram

00:15:54,320 --> 00:16:00,320
and more cpu cores and

00:15:57,600 --> 00:16:01,279
that should go faster if you weren't

00:16:00,320 --> 00:16:04,240
using a

00:16:01,279 --> 00:16:04,639
service based ci cd and you had to rely

00:16:04,240 --> 00:16:06,000
on

00:16:04,639 --> 00:16:08,079
your local machine you would obviously

00:16:06,000 --> 00:16:09,279
have to replace the processor replace

00:16:08,079 --> 00:16:12,480
the ram all that stuff

00:16:09,279 --> 00:16:15,600
and that can take a bit more time

00:16:12,480 --> 00:16:18,639
but anyway common indicators

00:16:15,600 --> 00:16:22,160
of performance lags that

00:16:18,639 --> 00:16:25,519
are easily remedied by

00:16:22,160 --> 00:16:26,880
increasing the resources or

00:16:25,519 --> 00:16:28,560
ramping up the resource that you're

00:16:26,880 --> 00:16:31,600
allocating to your builds are

00:16:28,560 --> 00:16:33,839
yeah just out of memory errors so i used

00:16:31,600 --> 00:16:36,959
to work on an android team

00:16:33,839 --> 00:16:40,079
android uses gradle as a build tool

00:16:36,959 --> 00:16:41,279
it's like got a lot of java kotlin

00:16:40,079 --> 00:16:44,639
compilation

00:16:41,279 --> 00:16:47,199
which is quite memory intensive and when

00:16:44,639 --> 00:16:48,480
apps grow and they do when you're adding

00:16:47,199 --> 00:16:50,399
dependencies

00:16:48,480 --> 00:16:51,519
you're consuming more and more memory

00:16:50,399 --> 00:16:56,399
and back then

00:16:51,519 --> 00:16:59,519
like the default machines had like 5812

00:16:56,399 --> 00:17:01,920
megs of ram and that just

00:16:59,519 --> 00:17:02,639
not enough for most most of those jobs

00:17:01,920 --> 00:17:04,400
so

00:17:02,639 --> 00:17:06,720
you really need to kind of start

00:17:04,400 --> 00:17:07,919
increasing that to avoid out of memory

00:17:06,720 --> 00:17:10,880
errors

00:17:07,919 --> 00:17:11,360
sometimes you're running uh builds and

00:17:10,880 --> 00:17:14,959
tests

00:17:11,360 --> 00:17:18,160
that uh can utilize more course of

00:17:14,959 --> 00:17:22,480
your processor and that's when

00:17:18,160 --> 00:17:24,319
yeah a bigger more processing course is

00:17:22,480 --> 00:17:27,360
is a good idea

00:17:24,319 --> 00:17:29,679
what i found is that

00:17:27,360 --> 00:17:31,520
in most kind of smaller applications

00:17:29,679 --> 00:17:34,240
that

00:17:31,520 --> 00:17:34,880
essentially things you can build locally

00:17:34,240 --> 00:17:37,520
is

00:17:34,880 --> 00:17:38,240
trying to build it locally and seeing

00:17:37,520 --> 00:17:41,200
how

00:17:38,240 --> 00:17:42,559
long that takes on your local machine

00:17:41,200 --> 00:17:46,480
with what 16

00:17:42,559 --> 00:17:50,559
gigs of ram eight cores 16 cores

00:17:46,480 --> 00:17:53,120
whatever and seeing if your ci cd is

00:17:50,559 --> 00:17:54,880
taking five times as long so if that's

00:17:53,120 --> 00:17:57,360
the case then

00:17:54,880 --> 00:17:58,000
it's very easy to just kind of increase

00:17:57,360 --> 00:18:01,679
uh

00:17:58,000 --> 00:18:03,039
the the resources and

00:18:01,679 --> 00:18:04,960
it's going to work obviously if you're

00:18:03,039 --> 00:18:07,200
building something that can't reasonably

00:18:04,960 --> 00:18:10,559
be built on a local machine

00:18:07,200 --> 00:18:14,160
or or a developer kind of

00:18:10,559 --> 00:18:18,080
consumer-grade computer then obviously

00:18:14,160 --> 00:18:20,960
you you you have a bigger problem

00:18:18,080 --> 00:18:23,840
but uh yeah that's kind of a easy

00:18:20,960 --> 00:18:23,840
benchmark that i found

00:18:24,240 --> 00:18:27,360
um in circle ci

00:18:26,250 --> 00:18:30,799
[Music]

00:18:27,360 --> 00:18:33,360
so this is just a snippet of the config

00:18:30,799 --> 00:18:36,640
file that i showed you earlier

00:18:33,360 --> 00:18:39,919
so the way to

00:18:36,640 --> 00:18:42,080
choose a resource class is by specifying

00:18:39,919 --> 00:18:46,640
a resource underscore class

00:18:42,080 --> 00:18:48,160
in your job that you're defining and

00:18:46,640 --> 00:18:50,160
you have a bunch of options available

00:18:48,160 --> 00:18:52,240
for docker for machine

00:18:50,160 --> 00:18:54,840
executors for all different kind of

00:18:52,240 --> 00:18:58,960
environments that you might be

00:18:54,840 --> 00:19:02,960
uh writing your job for

00:18:58,960 --> 00:19:04,240
and uh yeah for instance they're all

00:19:02,960 --> 00:19:07,360
they're all available in

00:19:04,240 --> 00:19:10,480
docs and i will be sharing the links to

00:19:07,360 --> 00:19:13,280
all of these things uh later

00:19:10,480 --> 00:19:14,320
so you'll be able to find links to it

00:19:13,280 --> 00:19:16,720
easier

00:19:14,320 --> 00:19:18,240
but yeah by default you kind of run on

00:19:16,720 --> 00:19:21,280
two vcpus

00:19:18,240 --> 00:19:22,960
with four gigs of ram and yeah if you

00:19:21,280 --> 00:19:26,080
want something that's closer to a

00:19:22,960 --> 00:19:30,640
modern kind of desktop great pc

00:19:26,080 --> 00:19:30,640
kind of go x large or xx large and

00:19:31,039 --> 00:19:38,960
it's immediately a lot faster

00:19:35,280 --> 00:19:42,799
but obviously not everything is

00:19:38,960 --> 00:19:46,240
as easy to improve as just adding more

00:19:42,799 --> 00:19:48,240
machine to it because obviously

00:19:46,240 --> 00:19:50,720
bigger machines bigger virtual machines

00:19:48,240 --> 00:19:52,400
cost more and

00:19:50,720 --> 00:19:53,760
you're just gonna see diminishing

00:19:52,400 --> 00:19:56,720
returns to

00:19:53,760 --> 00:19:57,440
to your to your performance especially

00:19:56,720 --> 00:19:59,840
if you're

00:19:57,440 --> 00:20:02,000
not utilizing all of the vcpus you're

00:19:59,840 --> 00:20:04,720
not utilizing all of the ram so

00:20:02,000 --> 00:20:07,280
you're gonna start seeing some uh issues

00:20:04,720 --> 00:20:09,760
come up

00:20:07,280 --> 00:20:10,480
and uh so yeah if you can't really

00:20:09,760 --> 00:20:13,600
optimize

00:20:10,480 --> 00:20:17,280
using having a bigger computer then you

00:20:13,600 --> 00:20:18,480
have to go parallel and be clever about

00:20:17,280 --> 00:20:22,320
it

00:20:18,480 --> 00:20:25,600
so yeah what you can do uh another thing

00:20:22,320 --> 00:20:28,720
is you can orchestrate your jobs to run

00:20:25,600 --> 00:20:30,880
in parallel so we've seen

00:20:28,720 --> 00:20:31,760
uh the workflow that i showed you

00:20:30,880 --> 00:20:35,440
actually had

00:20:31,760 --> 00:20:37,360
two jobs running in parallel and

00:20:35,440 --> 00:20:38,880
yeah this will essentially speed up the

00:20:37,360 --> 00:20:42,799
entire workflow because

00:20:38,880 --> 00:20:45,360
instead of having one after the other

00:20:42,799 --> 00:20:46,400
you'll just run a bunch of them together

00:20:45,360 --> 00:20:48,000
and wait for

00:20:46,400 --> 00:20:50,159
just the slowest one to finish as

00:20:48,000 --> 00:20:51,840
opposed to slowest and the next lowest

00:20:50,159 --> 00:20:55,919
and the next next lowest

00:20:51,840 --> 00:20:59,120
all the way there so in my example here

00:20:55,919 --> 00:21:00,320
i'll be splitting unit tests static code

00:20:59,120 --> 00:21:03,600
analysis and

00:21:00,320 --> 00:21:06,000
dependency vulnerability check into

00:21:03,600 --> 00:21:06,799
these kind of parallel running jobs

00:21:06,000 --> 00:21:09,840
which uh

00:21:06,799 --> 00:21:11,919
operate independently before kind of uh

00:21:09,840 --> 00:21:13,120
coming together with all the results

00:21:11,919 --> 00:21:15,679
when they're all passing

00:21:13,120 --> 00:21:16,799
and only then triggering uh some kind of

00:21:15,679 --> 00:21:19,039
deploy

00:21:16,799 --> 00:21:19,039
job

00:21:21,440 --> 00:21:27,679
so yeah when you're

00:21:24,559 --> 00:21:29,760
defining your workflows this is

00:21:27,679 --> 00:21:31,440
yeah all of these code snippets they're

00:21:29,760 --> 00:21:34,320
config yaml

00:21:31,440 --> 00:21:34,799
of circle ci so yeah you're defining

00:21:34,320 --> 00:21:37,280
your

00:21:34,799 --> 00:21:39,280
unit test job and you pass in this

00:21:37,280 --> 00:21:44,000
requires argument

00:21:39,280 --> 00:21:46,320
and tell it what job it depends on so

00:21:44,000 --> 00:21:48,240
for instance if we had something that

00:21:46,320 --> 00:21:52,080
requires us first to build something

00:21:48,240 --> 00:21:54,960
and then uh we can run these three

00:21:52,080 --> 00:21:56,960
um unit aesthetic check and

00:21:54,960 --> 00:21:58,720
vulnerability scan

00:21:56,960 --> 00:22:00,240
together um

00:21:58,720 --> 00:22:03,360
[Music]

00:22:00,240 --> 00:22:05,919
before running deploy which yeah

00:22:03,360 --> 00:22:06,880
specifies that all of these three are

00:22:05,919 --> 00:22:08,799
required

00:22:06,880 --> 00:22:10,000
so that's like a very easy thing to do

00:22:08,799 --> 00:22:11,760
and actually if

00:22:10,000 --> 00:22:13,760
if you're just listing all the jobs one

00:22:11,760 --> 00:22:14,400
after the other without using requires

00:22:13,760 --> 00:22:17,679
they will all

00:22:14,400 --> 00:22:20,960
by default run in parallel so uh

00:22:17,679 --> 00:22:24,240
yeah you can actually just get a lot of

00:22:20,960 --> 00:22:25,200
uh performance just by doing something

00:22:24,240 --> 00:22:27,440
by default

00:22:25,200 --> 00:22:29,039
but sometimes people want to see it one

00:22:27,440 --> 00:22:32,080
after the other and

00:22:29,039 --> 00:22:32,880
that's uh that's something you can you

00:22:32,080 --> 00:22:36,159
can fix

00:22:32,880 --> 00:22:40,000
by yeah parallelizing

00:22:36,159 --> 00:22:44,000
but not only workflows when you have a

00:22:40,000 --> 00:22:47,039
list of jobs you can also parallelize

00:22:44,000 --> 00:22:49,600
tests that's something

00:22:47,039 --> 00:22:51,200
we could have benefited from in my

00:22:49,600 --> 00:22:54,960
earlier example

00:22:51,200 --> 00:22:58,240
but this was this was not available and

00:22:54,960 --> 00:23:00,000
uh we actually had to go kind of figure

00:22:58,240 --> 00:23:01,120
out manually how to split all of these

00:23:00,000 --> 00:23:03,919
tests

00:23:01,120 --> 00:23:06,240
so yeah if you have a single kind of

00:23:03,919 --> 00:23:08,559
functional test job in our case

00:23:06,240 --> 00:23:10,320
um which kind of went through all the

00:23:08,559 --> 00:23:14,400
application screens and

00:23:10,320 --> 00:23:16,000
uh ran a bunch of tests like end-to-end

00:23:14,400 --> 00:23:18,320
tests like a user would

00:23:16,000 --> 00:23:19,440
um you can consider splitting those

00:23:18,320 --> 00:23:22,159
tests across

00:23:19,440 --> 00:23:22,960
uh parallel jobs that is essentially

00:23:22,159 --> 00:23:26,080
just

00:23:22,960 --> 00:23:27,760
uh work on a chunk of that small

00:23:26,080 --> 00:23:30,960
proportion of that

00:23:27,760 --> 00:23:33,600
whole test suite and

00:23:30,960 --> 00:23:34,559
yeah if your test to it takes one hour

00:23:33,600 --> 00:23:37,600
or eight hours

00:23:34,559 --> 00:23:40,320
and you're kind of splitting them to six

00:23:37,600 --> 00:23:42,000
parallel jobs you're and you'll likely

00:23:40,320 --> 00:23:45,600
end up running something for

00:23:42,000 --> 00:23:49,039
10-15 minutes instead which is uh

00:23:45,600 --> 00:23:51,679
a substantial significant improvement in

00:23:49,039 --> 00:23:54,480
your build performance and your uh

00:23:51,679 --> 00:23:54,480
sanity as well

00:23:54,880 --> 00:23:58,640
so how to do this um

00:23:58,960 --> 00:24:06,640
so circle ci comes with uh circle ci

00:24:02,840 --> 00:24:09,039
cli tool that comes installed on your

00:24:06,640 --> 00:24:10,799
on all the all the docker images all the

00:24:09,039 --> 00:24:14,000
machines

00:24:10,799 --> 00:24:17,120
that you might want to use and

00:24:14,000 --> 00:24:19,919
you use this circle ci test command

00:24:17,120 --> 00:24:21,200
tests command to basically generate a

00:24:19,919 --> 00:24:24,720
list of tests

00:24:21,200 --> 00:24:24,720
which should then pass to

00:24:24,799 --> 00:24:28,559
circle ci test split

00:24:28,720 --> 00:24:35,520
and that then lets you to

00:24:32,159 --> 00:24:38,480
split by file names class names

00:24:35,520 --> 00:24:39,279
timings i like personally timings the

00:24:38,480 --> 00:24:44,320
most

00:24:39,279 --> 00:24:44,320
because it's able to actually identify

00:24:45,120 --> 00:24:51,679
what combination of the tests in each

00:24:48,320 --> 00:24:53,919
of the parallel jobs is gonna be

00:24:51,679 --> 00:24:54,720
it's gonna run for approximately the

00:24:53,919 --> 00:24:57,120
same time

00:24:54,720 --> 00:24:58,799
so that you're not ending up with one

00:24:57,120 --> 00:24:59,440
job that's like twice as long as the

00:24:58,799 --> 00:25:01,840
others

00:24:59,440 --> 00:25:03,039
you're ending up with like this kind of

00:25:01,840 --> 00:25:05,840
normalized

00:25:03,039 --> 00:25:06,799
job length even though yeah you'll end

00:25:05,840 --> 00:25:08,400
up testing

00:25:06,799 --> 00:25:10,880
a couple of classes here a couple of

00:25:08,400 --> 00:25:12,559
classes there and just gonna mix and

00:25:10,880 --> 00:25:16,240
match of everything

00:25:12,559 --> 00:25:17,039
but yeah so you're you're likely to end

00:25:16,240 --> 00:25:20,080
up with

00:25:17,039 --> 00:25:23,440
this kind of longer uh command for

00:25:20,080 --> 00:25:26,799
testing which basically passes uh

00:25:23,440 --> 00:25:29,120
a list of list of tests to run to your

00:25:26,799 --> 00:25:29,760
uh test command in our case that's a

00:25:29,120 --> 00:25:33,679
yarn

00:25:29,760 --> 00:25:38,640
example so yarn is a testing package

00:25:33,679 --> 00:25:38,640
and build tool for node.js projects

00:25:39,600 --> 00:25:43,760
after we're done if you're using timings

00:25:42,559 --> 00:25:48,400
you need to

00:25:43,760 --> 00:25:51,039
store test results which basically

00:25:48,400 --> 00:25:53,120
sends all that information to circleci

00:25:51,039 --> 00:25:55,919
and

00:25:53,120 --> 00:25:58,000
not only tells you in a nice way whether

00:25:55,919 --> 00:25:59,039
your tests are all green or which tests

00:25:58,000 --> 00:26:02,400
have failed

00:25:59,039 --> 00:26:04,720
but also it kind of measures the times

00:26:02,400 --> 00:26:06,720
for each of the tests that it's run and

00:26:04,720 --> 00:26:10,480
then that kind of helps

00:26:06,720 --> 00:26:13,039
uh circle ci make this educated

00:26:10,480 --> 00:26:13,679
estimate of which tests to combine

00:26:13,039 --> 00:26:17,039
together

00:26:13,679 --> 00:26:20,080
so that your kind of total run is

00:26:17,039 --> 00:26:20,080
as short as possible

00:26:20,320 --> 00:26:24,720
and last thing to do is essentially to

00:26:22,159 --> 00:26:28,159
set this parallelism

00:26:24,720 --> 00:26:29,120
value to however many machines you want

00:26:28,159 --> 00:26:32,159
to run

00:26:29,120 --> 00:26:33,200
or containers you want to run your

00:26:32,159 --> 00:26:36,400
parallel jobs

00:26:33,200 --> 00:26:38,480
in and the rest

00:26:36,400 --> 00:26:40,080
happens magically basically circle ci

00:26:38,480 --> 00:26:42,480
figures out okay

00:26:40,080 --> 00:26:43,279
uh first parallel job is gonna run this

00:26:42,480 --> 00:26:45,440
first chunk

00:26:43,279 --> 00:26:46,880
then second is gonna run this second

00:26:45,440 --> 00:26:50,720
chunk and it all kind of

00:26:46,880 --> 00:26:53,200
comes from this uh

00:26:50,720 --> 00:26:53,919
command that you see here of splitting

00:26:53,200 --> 00:26:57,360
tests

00:26:53,919 --> 00:27:00,640
and uh it just figures out

00:26:57,360 --> 00:27:04,320
all of that automatically

00:27:00,640 --> 00:27:07,919
um and yeah i mentioned yeah this

00:27:04,320 --> 00:27:09,270
store test results uh let me actually

00:27:07,919 --> 00:27:12,380
show you this

00:27:09,270 --> 00:27:12,380
[Music]

00:27:13,840 --> 00:27:20,000
i can show you in a workflow actually i

00:27:15,919 --> 00:27:24,240
don't have

00:27:20,000 --> 00:27:27,440
my workflow here okay it's gonna be here

00:27:24,240 --> 00:27:29,279
tests yeah it kind of shows you here uh

00:27:27,440 --> 00:27:31,200
which whether your tests are passing or

00:27:29,279 --> 00:27:32,320
not so if you go into your test job you

00:27:31,200 --> 00:27:36,399
can actually

00:27:32,320 --> 00:27:36,399
analyze that um

00:27:37,200 --> 00:27:40,880
yeah so that's kind of what we've

00:27:38,480 --> 00:27:42,799
covered so far splitting

00:27:40,880 --> 00:27:44,880
or making job making sure that your jobs

00:27:42,799 --> 00:27:47,039
run in parallel where that's possible

00:27:44,880 --> 00:27:48,000
and to make sure that you can split your

00:27:47,039 --> 00:27:51,039
tests

00:27:48,000 --> 00:27:54,320
in the way that uh you kind of cut

00:27:51,039 --> 00:27:55,039
a very kind of long-running test suite

00:27:54,320 --> 00:27:57,600
into

00:27:55,039 --> 00:28:00,080
several smaller shorter running test

00:27:57,600 --> 00:28:00,080
suites

00:28:00,399 --> 00:28:04,559
next up when we have so many new test

00:28:03,200 --> 00:28:07,120
suites uh

00:28:04,559 --> 00:28:08,240
smaller test suites to run we can

00:28:07,120 --> 00:28:11,520
utilize

00:28:08,240 --> 00:28:14,799
uh some clever caching techniques

00:28:11,520 --> 00:28:17,919
to speed up their startup times

00:28:14,799 --> 00:28:21,600
for example because

00:28:17,919 --> 00:28:25,120
if you're using node or

00:28:21,600 --> 00:28:26,640
or java or any kind of heavy dependency

00:28:25,120 --> 00:28:30,480
heavy projects

00:28:26,640 --> 00:28:34,720
you'll you'll see that your

00:28:30,480 --> 00:28:38,240
kind of npm installs yarn installs

00:28:34,720 --> 00:28:38,640
gradle downloads of all dependencies can

00:28:38,240 --> 00:28:42,559
take

00:28:38,640 --> 00:28:45,919
really a long time and imagine that

00:28:42,559 --> 00:28:50,240
this happens on every single time you

00:28:45,919 --> 00:28:53,600
you run your parallel parallel test job

00:28:50,240 --> 00:28:56,960
so you're basically adding like 10 20 50

00:28:53,600 --> 00:28:58,960
a minute even

00:28:56,960 --> 00:29:00,399
to each of those builds and even though

00:28:58,960 --> 00:29:03,919
they run in parallel you're still

00:29:00,399 --> 00:29:06,960
adding that time secondly

00:29:03,919 --> 00:29:10,320
you can actually skip some

00:29:06,960 --> 00:29:11,520
compilation uh compilation time by

00:29:10,320 --> 00:29:13,440
basically saying

00:29:11,520 --> 00:29:14,960
compile once and then store these

00:29:13,440 --> 00:29:18,080
results

00:29:14,960 --> 00:29:20,240
and reuse this outputs

00:29:18,080 --> 00:29:21,360
in other jobs that are kind of running

00:29:20,240 --> 00:29:24,720
subsequently

00:29:21,360 --> 00:29:26,640
so we'll show you this

00:29:24,720 --> 00:29:28,559
caching dependencies obviously that's

00:29:26,640 --> 00:29:31,679
the first one the most uh

00:29:28,559 --> 00:29:32,159
easiest one to achieve so yeah if you're

00:29:31,679 --> 00:29:34,960
thinking

00:29:32,159 --> 00:29:36,240
each time you commit your uh need to

00:29:34,960 --> 00:29:39,200
download to

00:29:36,240 --> 00:29:40,240
do npm install all of that you can

00:29:39,200 --> 00:29:43,279
actually

00:29:40,240 --> 00:29:45,279
use this uh cache to

00:29:43,279 --> 00:29:47,600
make sure that if your dependencies

00:29:45,279 --> 00:29:48,159
don't change you're kind of just reusing

00:29:47,600 --> 00:29:52,000
the same

00:29:48,159 --> 00:29:56,399
uh same local

00:29:52,000 --> 00:29:59,279
local cache storage which really makes

00:29:56,399 --> 00:29:59,279
stuff faster

00:30:00,000 --> 00:30:05,600
the way to do this is add

00:30:03,039 --> 00:30:06,320
steps to your job that does the

00:30:05,600 --> 00:30:09,279
dependency

00:30:06,320 --> 00:30:10,399
installation or dependency needs

00:30:09,279 --> 00:30:13,360
dependencies

00:30:10,399 --> 00:30:13,760
so after we've checked out the code we

00:30:13,360 --> 00:30:17,600
call

00:30:13,760 --> 00:30:20,640
restore cache passing in a bunch of

00:30:17,600 --> 00:30:23,279
keys that it's going to

00:30:20,640 --> 00:30:24,320
look for first off we're kind of

00:30:23,279 --> 00:30:26,640
optimizing for

00:30:24,320 --> 00:30:27,840
whatever the branch name is and whatever

00:30:26,640 --> 00:30:30,080
the checksum is

00:30:27,840 --> 00:30:31,120
for this package lock because obviously

00:30:30,080 --> 00:30:34,559
if you're hashing

00:30:31,120 --> 00:30:36,480
this that's uh pretty easy to

00:30:34,559 --> 00:30:38,720
to figure out whether it has changed or

00:30:36,480 --> 00:30:38,720
not

00:30:39,360 --> 00:30:43,279
then we're running npm install which

00:30:42,159 --> 00:30:45,760
should be very quick

00:30:43,279 --> 00:30:46,640
if we already have the cache and

00:30:45,760 --> 00:30:49,919
afterwards

00:30:46,640 --> 00:30:52,159
we just save the cache and we've

00:30:49,919 --> 00:30:53,039
introduced two commands called restore

00:30:52,159 --> 00:30:57,279
cache and

00:30:53,039 --> 00:31:00,000
save cache to this um

00:30:57,279 --> 00:31:00,799
as a bonus if you're using circle ci

00:31:00,000 --> 00:31:05,840
orbs which

00:31:00,799 --> 00:31:05,840
are a reusable configuration

00:31:07,760 --> 00:31:14,480
which are reusable configuration tools

00:31:11,039 --> 00:31:19,840
and i think my video just went blurry

00:31:14,480 --> 00:31:19,840
give me a second

00:31:23,519 --> 00:31:27,120
yeah i'll be just looking at this one

00:31:24,960 --> 00:31:30,720
sorry

00:31:27,120 --> 00:31:33,039
um if using circle ci orbs

00:31:30,720 --> 00:31:33,760
for example the node.js orb actually

00:31:33,039 --> 00:31:36,559
when you're running

00:31:33,760 --> 00:31:37,600
node.js test job it actually come with

00:31:36,559 --> 00:31:40,480
all these cache

00:31:37,600 --> 00:31:42,320
steps written for you so you really

00:31:40,480 --> 00:31:44,080
don't need to worry about this it's just

00:31:42,320 --> 00:31:47,360
going to do this automatically which is

00:31:44,080 --> 00:31:50,880
pretty cool um

00:31:47,360 --> 00:31:54,080
next up we have uh caching between jobs

00:31:50,880 --> 00:31:56,640
so that's we were first one was like

00:31:54,080 --> 00:31:58,799
between workflow runs so between commits

00:31:56,640 --> 00:32:00,399
and now it's between jobs so if you have

00:31:58,799 --> 00:32:02,000
jobs that run sequentially you can

00:32:00,399 --> 00:32:05,039
actually uh

00:32:02,000 --> 00:32:08,399
utilize a cache that passes some uh

00:32:05,039 --> 00:32:10,559
some stuff across those as well so yeah

00:32:08,399 --> 00:32:11,440
ex for example if you have a heavy

00:32:10,559 --> 00:32:14,159
compilation

00:32:11,440 --> 00:32:14,559
step that produces a lot of kind of

00:32:14,159 --> 00:32:18,159
build

00:32:14,559 --> 00:32:20,000
artifacts then um

00:32:18,159 --> 00:32:21,279
your functional testing job is

00:32:20,000 --> 00:32:24,320
essentially using that

00:32:21,279 --> 00:32:28,159
uh those build artifacts

00:32:24,320 --> 00:32:29,919
and uh running tests on that

00:32:28,159 --> 00:32:32,720
then you can actually just build it once

00:32:29,919 --> 00:32:36,080
and skip that step altogether by just

00:32:32,720 --> 00:32:39,760
uh by just running the rest

00:32:36,080 --> 00:32:42,880
very easily so this workspace

00:32:39,760 --> 00:32:44,080
essentially mounts as a local file

00:32:42,880 --> 00:32:47,039
system that you can

00:32:44,080 --> 00:32:49,600
copy and paste stuff from your jobs

00:32:47,039 --> 00:32:52,480
which is pretty cool

00:32:49,600 --> 00:32:54,240
so what we have here is we have two jobs

00:32:52,480 --> 00:32:56,000
one is called flow and the other one is

00:32:54,240 --> 00:32:59,440
called downstream

00:32:56,000 --> 00:33:02,559
and our flow job is the first one to run

00:32:59,440 --> 00:33:03,679
which calls persist to workspace you

00:33:02,559 --> 00:33:06,720
pass in what

00:33:03,679 --> 00:33:09,600
where this where you want this to be

00:33:06,720 --> 00:33:10,399
and essentially this copies whatever you

00:33:09,600 --> 00:33:13,760
have

00:33:10,399 --> 00:33:15,039
told it to copy somewhere in our case

00:33:13,760 --> 00:33:18,399
that's like workspace

00:33:15,039 --> 00:33:22,000
echo output file which is just like

00:33:18,399 --> 00:33:22,399
one hello world and then our downstream

00:33:22,000 --> 00:33:26,799
job

00:33:22,399 --> 00:33:30,159
which comes after our flow job

00:33:26,799 --> 00:33:33,679
it first attaches this workspace and

00:33:30,159 --> 00:33:38,640
you tell it where so temporary workspace

00:33:33,679 --> 00:33:42,000
and then you can actually just

00:33:38,640 --> 00:33:43,039
here and use it as you you had it here

00:33:42,000 --> 00:33:45,519
so example

00:33:43,039 --> 00:33:46,640
for example you have like compilation

00:33:45,519 --> 00:33:50,080
heavy step

00:33:46,640 --> 00:33:52,640
you can just take those binaries

00:33:50,080 --> 00:33:53,440
and reuse them like you've already had

00:33:52,640 --> 00:33:56,080
them

00:33:53,440 --> 00:33:56,640
so pretty clever so yeah you can see

00:33:56,080 --> 00:33:58,320
that

00:33:56,640 --> 00:34:00,640
we've kind of defined the first one and

00:33:58,320 --> 00:34:01,840
then the second one downstream requires

00:34:00,640 --> 00:34:06,799
this flow job

00:34:01,840 --> 00:34:08,240
to to proceed

00:34:06,799 --> 00:34:10,240
uh the last thing i want to show you

00:34:08,240 --> 00:34:14,720
about caching is caching

00:34:10,240 --> 00:34:17,599
docker layers so uh this is useful

00:34:14,720 --> 00:34:18,399
when you're actually your output is

00:34:17,599 --> 00:34:23,440
building

00:34:18,399 --> 00:34:25,280
a docker layers docker images sorry

00:34:23,440 --> 00:34:27,359
docker layers are these kind of

00:34:25,280 --> 00:34:30,079
individual commands so like work there

00:34:27,359 --> 00:34:30,800
copy run npm install all of these they

00:34:30,079 --> 00:34:34,320
are

00:34:30,800 --> 00:34:37,440
layers in a docker file

00:34:34,320 --> 00:34:41,280
and circle ci will let you cache

00:34:37,440 --> 00:34:44,079
each one of these layers uh sequentially

00:34:41,280 --> 00:34:46,079
so that uh whenever you're building the

00:34:44,079 --> 00:34:49,040
same image again

00:34:46,079 --> 00:34:49,599
let's say if we're adding something on

00:34:49,040 --> 00:34:52,720
line

00:34:49,599 --> 00:34:56,280
12 all the lines from

00:34:52,720 --> 00:34:59,200
1 to 11 are going to be kind of

00:34:56,280 --> 00:35:02,560
immediately accessible from our cache

00:34:59,200 --> 00:35:05,680
so that we'll only need to execute

00:35:02,560 --> 00:35:09,520
uh lines 12 to to to

00:35:05,680 --> 00:35:13,119
finish in our uh in our

00:35:09,520 --> 00:35:14,720
docker file to build our image so

00:35:13,119 --> 00:35:16,400
if nothing has changed your image will

00:35:14,720 --> 00:35:20,560
be built almost automatic

00:35:16,400 --> 00:35:20,560
uh instantaneously which is pretty cool

00:35:20,960 --> 00:35:25,119
to do this um yeah you need to pass in

00:35:24,480 --> 00:35:27,359
either

00:35:25,119 --> 00:35:29,760
use either machine image or setup remote

00:35:27,359 --> 00:35:31,359
docker environment

00:35:29,760 --> 00:35:33,200
setup remote docker essentially gives

00:35:31,359 --> 00:35:36,640
you a bunch of docker related

00:35:33,200 --> 00:35:39,680
tools to build images and

00:35:36,640 --> 00:35:39,680
interact with docker

00:35:40,000 --> 00:35:44,079
and just pass in setup docker layer

00:35:42,880 --> 00:35:46,640
caching to true

00:35:44,079 --> 00:35:48,640
as an argument to this setup remote uh

00:35:46,640 --> 00:35:51,599
docker instruction

00:35:48,640 --> 00:35:53,440
which basically does everything for you

00:35:51,599 --> 00:35:58,640
um

00:35:53,440 --> 00:36:00,720
and yeah that's kind of where it is um

00:35:58,640 --> 00:36:01,839
there are obviously some limits to

00:36:00,720 --> 00:36:04,960
parallelism you can

00:36:01,839 --> 00:36:05,359
like i think if you're running like more

00:36:04,960 --> 00:36:07,599
than

00:36:05,359 --> 00:36:07,599
uh

00:36:08,480 --> 00:36:12,000
30 or 50 uh yeah it can it can have like

00:36:11,359 --> 00:36:15,760
different

00:36:12,000 --> 00:36:20,240
like 50 docker kind of um

00:36:15,760 --> 00:36:24,560
cash uh volumes created

00:36:20,240 --> 00:36:27,760
that cannot be reused across

00:36:24,560 --> 00:36:28,720
across different jobs each job that runs

00:36:27,760 --> 00:36:31,760
at one time

00:36:28,720 --> 00:36:33,760
can only use a single volume so uh you

00:36:31,760 --> 00:36:34,960
can have 50 of those so there is like if

00:36:33,760 --> 00:36:38,000
you want higher

00:36:34,960 --> 00:36:40,640
parallelism then uh you need

00:36:38,000 --> 00:36:42,000
to think about it a bit differently and

00:36:40,640 --> 00:36:43,839
the last thing is yeah docker

00:36:42,000 --> 00:36:46,079
layer caching does not apply to running

00:36:43,839 --> 00:36:46,800
jobs in docker containers so all of our

00:36:46,079 --> 00:36:49,040
node

00:36:46,800 --> 00:36:49,920
jobs that we showed earlier don't really

00:36:49,040 --> 00:36:55,839
uh

00:36:49,920 --> 00:36:55,839
need that

00:36:57,440 --> 00:37:00,800
next up is just choosing what you want

00:37:00,240 --> 00:37:03,839
to run

00:37:00,800 --> 00:37:07,440
when for example maybe your

00:37:03,839 --> 00:37:09,760
your ci cd is set up so that you have

00:37:07,440 --> 00:37:10,480
an extensive functional test suite you

00:37:09,760 --> 00:37:12,880
have

00:37:10,480 --> 00:37:15,119
coverage tests you have a bunch of

00:37:12,880 --> 00:37:18,000
different uh

00:37:15,119 --> 00:37:18,400
moving parts set up that but you don't

00:37:18,000 --> 00:37:21,680
really

00:37:18,400 --> 00:37:23,520
care about all of them at all times

00:37:21,680 --> 00:37:25,359
so for example if you're just reviewing

00:37:23,520 --> 00:37:26,240
a pull request or if you're just pushing

00:37:25,359 --> 00:37:29,200
a commit

00:37:26,240 --> 00:37:29,599
to your to your source code repository

00:37:29,200 --> 00:37:31,520
you

00:37:29,599 --> 00:37:33,440
really just need to care about unit

00:37:31,520 --> 00:37:34,640
tests and maybe a few integration tests

00:37:33,440 --> 00:37:37,440
and that's it

00:37:34,640 --> 00:37:38,160
so you can actually choose what gets run

00:37:37,440 --> 00:37:42,160
when

00:37:38,160 --> 00:37:45,040
on uh commit pr on a tag

00:37:42,160 --> 00:37:45,680
or even on a chrome job and filter

00:37:45,040 --> 00:37:49,760
basically

00:37:45,680 --> 00:37:50,880
on yeah branches tags that kind of stuff

00:37:49,760 --> 00:37:53,760
and

00:37:50,880 --> 00:37:57,440
decide which part of workflow and which

00:37:53,760 --> 00:37:57,440
workflow actually gets triggered

00:37:58,079 --> 00:38:04,480
we have this filters

00:38:01,920 --> 00:38:05,200
argument to that goes into jobs in

00:38:04,480 --> 00:38:08,560
workflows

00:38:05,200 --> 00:38:10,480
and basically you specify yeah when you

00:38:08,560 --> 00:38:13,760
want this to run for example

00:38:10,480 --> 00:38:14,160
this one is uh running functional tests

00:38:13,760 --> 00:38:16,880
uh

00:38:14,160 --> 00:38:17,280
full functional test suite only when

00:38:16,880 --> 00:38:20,400
we're

00:38:17,280 --> 00:38:22,240
touching the main branch which is yeah a

00:38:20,400 --> 00:38:24,720
pull request goes into main branch

00:38:22,240 --> 00:38:25,920
you want to run all the tests otherwise

00:38:24,720 --> 00:38:27,200
if you're just working on a feature

00:38:25,920 --> 00:38:29,440
branch for example you don't have to

00:38:27,200 --> 00:38:32,480
worry about this

00:38:29,440 --> 00:38:34,560
um next one is uh

00:38:32,480 --> 00:38:36,800
triggering yeah maybe you want to do

00:38:34,560 --> 00:38:40,000
maybe you want to set up a trigger for

00:38:36,800 --> 00:38:44,000
a nightly build that kind of produces

00:38:40,000 --> 00:38:48,480
uh deploys to some kind of uh

00:38:44,000 --> 00:38:49,920
nightly production environment and

00:38:48,480 --> 00:38:52,560
that's when you can actually use this

00:38:49,920 --> 00:38:56,000
schedule trigger which takes a cron

00:38:52,560 --> 00:38:58,839
and works on whatever branch you specify

00:38:56,000 --> 00:39:01,119
again maine is usually the most common

00:38:58,839 --> 00:39:04,480
one um

00:39:01,119 --> 00:39:07,599
yeah so that's like can really

00:39:04,480 --> 00:39:09,680
speed up your your flow and the last

00:39:07,599 --> 00:39:12,560
thing i want to mention here is just

00:39:09,680 --> 00:39:16,079
kind of not all bottlenecks are really

00:39:12,560 --> 00:39:17,680
human technical in nature sometimes

00:39:16,079 --> 00:39:21,280
there are human factors we are all

00:39:17,680 --> 00:39:21,280
humans and

00:39:21,680 --> 00:39:25,200
often there is some kind of lack of

00:39:23,680 --> 00:39:27,200
trust involved that

00:39:25,200 --> 00:39:28,320
really leads to lengthy approval

00:39:27,200 --> 00:39:30,160
processes

00:39:28,320 --> 00:39:32,079
a lot of people need to kind of add

00:39:30,160 --> 00:39:32,880
their stamp to things before we can

00:39:32,079 --> 00:39:36,079
publish we

00:39:32,880 --> 00:39:38,160
before we can release you've seen how my

00:39:36,079 --> 00:39:40,880
built earlier went from one minute to

00:39:38,160 --> 00:39:45,760
five minutes just because i added a

00:39:40,880 --> 00:39:45,760
whole step so yeah

00:39:45,839 --> 00:39:48,480
cicd

00:39:49,680 --> 00:39:55,520
is a tool that's super useful and it

00:39:52,880 --> 00:39:56,320
should be able to help you win that

00:39:55,520 --> 00:39:58,400
trust

00:39:56,320 --> 00:39:59,599
from your stakeholders from your team

00:39:58,400 --> 00:40:02,640
members

00:39:59,599 --> 00:40:05,900
uh by showing yet the change can

00:40:02,640 --> 00:40:07,680
really be actioned and managed

00:40:05,900 --> 00:40:10,960
[Music]

00:40:07,680 --> 00:40:12,960
in an effective manner

00:40:10,960 --> 00:40:15,440
if you have a lengthy approval process

00:40:12,960 --> 00:40:18,319
maybe set up some smart notification

00:40:15,440 --> 00:40:18,640
so that the person responsible uh gets

00:40:18,319 --> 00:40:21,520
it

00:40:18,640 --> 00:40:23,599
maybe pick them on slack or something

00:40:21,520 --> 00:40:26,640
and

00:40:23,599 --> 00:40:31,280
yeah so think about this it's not always

00:40:26,640 --> 00:40:32,800
technical factors i see the right time

00:40:31,280 --> 00:40:34,880
sorry to chime in here we've got about

00:40:32,800 --> 00:40:38,000
eight minutes left

00:40:34,880 --> 00:40:40,560
okay uh i will

00:40:38,000 --> 00:40:41,440
be i think i've got like one more minute

00:40:40,560 --> 00:40:44,800
so

00:40:41,440 --> 00:40:47,920
i'm pretty close to finishing

00:40:44,800 --> 00:40:50,960
um yeah

00:40:47,920 --> 00:40:52,400
so what's the right build time for your

00:40:50,960 --> 00:40:55,440
team

00:40:52,400 --> 00:40:58,480
it honestly really depends on

00:40:55,440 --> 00:41:02,079
your team i personally

00:40:58,480 --> 00:41:04,160
like this ambulance analogy to your ci

00:41:02,079 --> 00:41:06,720
cd builds

00:41:04,160 --> 00:41:07,440
they need to be as fast as possible but

00:41:06,720 --> 00:41:10,079
again

00:41:07,440 --> 00:41:11,040
not too fast because important things

00:41:10,079 --> 00:41:13,359
can really break

00:41:11,040 --> 00:41:14,319
if you're kind of skipping tests if

00:41:13,359 --> 00:41:18,640
you're

00:41:14,319 --> 00:41:20,079
if you're not really on top of

00:41:18,640 --> 00:41:21,920
all the all the things you should be

00:41:20,079 --> 00:41:25,280
really testing you should be uh

00:41:21,920 --> 00:41:27,200
caring about and yeah when the

00:41:25,280 --> 00:41:29,680
when the lights go flashing you need to

00:41:27,200 --> 00:41:30,400
act on those failing builds immediately

00:41:29,680 --> 00:41:33,440
and

00:41:30,400 --> 00:41:37,359
make sure that uh

00:41:33,440 --> 00:41:40,720
it gets unblocked on this topic

00:41:37,359 --> 00:41:42,160
we released this report called state of

00:41:40,720 --> 00:41:45,280
software delivery

00:41:42,160 --> 00:41:48,319
um i think back in uh late

00:41:45,280 --> 00:41:48,880
uh last year we looked at a bunch of

00:41:48,319 --> 00:41:51,359
stats

00:41:48,880 --> 00:41:52,480
across from across all the teams across

00:41:51,359 --> 00:41:55,280
the world

00:41:52,480 --> 00:41:55,760
and basically assembled some benchmarks

00:41:55,280 --> 00:41:58,240
for

00:41:55,760 --> 00:41:59,520
you to see what throughput teams are

00:41:58,240 --> 00:42:02,880
looking at

00:41:59,520 --> 00:42:03,359
what kind of performance uh they're

00:42:02,880 --> 00:42:06,240
seeing

00:42:03,359 --> 00:42:07,040
across the world it's pretty cool uh i

00:42:06,240 --> 00:42:11,119
would recommend

00:42:07,040 --> 00:42:13,680
you to check it out and next up

00:42:11,119 --> 00:42:14,160
lastly tomorrow we're running a meet up

00:42:13,680 --> 00:42:17,280
uh

00:42:14,160 --> 00:42:19,200
on continuous delivery topic it's an

00:42:17,280 --> 00:42:22,079
online one

00:42:19,200 --> 00:42:23,040
uh we have nick jackson from hashicorp

00:42:22,079 --> 00:42:25,680
talking about

00:42:23,040 --> 00:42:27,359
cannery deployments and angel rivera

00:42:25,680 --> 00:42:29,839
from circleci

00:42:27,359 --> 00:42:30,560
uh doing a practical introduction to our

00:42:29,839 --> 00:42:33,040
new feature

00:42:30,560 --> 00:42:34,000
runners it's going to be pretty cool you

00:42:33,040 --> 00:42:37,040
should check it out

00:42:34,000 --> 00:42:39,680
uh there is a url

00:42:37,040 --> 00:42:40,480
in there circle dot ci slash continuous

00:42:39,680 --> 00:42:44,000
delivery dash

00:42:40,480 --> 00:42:46,079
evening and that's all from me anyway

00:42:44,000 --> 00:42:49,040
thank you for attention i will take any

00:42:46,079 --> 00:42:49,040
questions you might have

00:42:56,079 --> 00:43:00,160
it looks like we might already have one

00:42:57,760 --> 00:43:01,760
in the q a box here

00:43:00,160 --> 00:43:03,520
i'm not sure if you're able to see that

00:43:01,760 --> 00:43:06,720
or i can read it for you

00:43:03,520 --> 00:43:10,400
okay yeah i can see it um

00:43:06,720 --> 00:43:13,839
does docker layer caching work with oci

00:43:10,400 --> 00:43:13,839
compliant image

00:43:14,640 --> 00:43:21,839
i don't know but if

00:43:17,920 --> 00:43:26,880
you are able to email me

00:43:21,839 --> 00:43:29,440
so i know who you are anonymous attendee

00:43:26,880 --> 00:43:30,880
then i will be able to find you that

00:43:29,440 --> 00:43:32,960
answer

00:43:30,880 --> 00:43:35,599
i don't know on off the top of my head

00:43:32,960 --> 00:43:35,599
fortunately

00:43:38,240 --> 00:43:41,440
there's another question in your

00:43:40,640 --> 00:43:43,359
experience

00:43:41,440 --> 00:43:45,760
what kind of things does a development

00:43:43,359 --> 00:43:47,440
team go through forming storming norman

00:43:45,760 --> 00:43:49,359
performing to move from problematic

00:43:47,440 --> 00:43:54,079
builds to fast builds

00:43:49,359 --> 00:43:58,720
in development uh

00:43:54,079 --> 00:43:58,720
cycle um

00:43:59,599 --> 00:44:06,240
i would say that in in our in our

00:44:02,880 --> 00:44:08,880
kind of most drastic example we were

00:44:06,240 --> 00:44:09,280
actually performing or at least we

00:44:08,880 --> 00:44:12,160
thought

00:44:09,280 --> 00:44:14,400
we were performing when our our builds

00:44:12,160 --> 00:44:16,800
became very slow just because

00:44:14,400 --> 00:44:18,560
we were so eager at adding tests and

00:44:16,800 --> 00:44:19,119
kind of making sure that every feature

00:44:18,560 --> 00:44:22,560
is

00:44:19,119 --> 00:44:26,079
is tested like end-to-end

00:44:22,560 --> 00:44:29,359
so that we really forgot about the

00:44:26,079 --> 00:44:32,960
optimization aspect and uh just

00:44:29,359 --> 00:44:34,560
woke up kind of in quotes woke up one

00:44:32,960 --> 00:44:38,240
day and discovered oh

00:44:34,560 --> 00:44:42,079
snap our belts are way too slow

00:44:38,240 --> 00:44:43,370
i would say that it really depends on

00:44:42,079 --> 00:44:45,760
every team

00:44:43,370 --> 00:44:48,800
[Music]

00:44:45,760 --> 00:44:50,319
when they kind of go from problematic

00:44:48,800 --> 00:44:53,359
builds to fast builds

00:44:50,319 --> 00:44:56,640
and uh but if there is like human

00:44:53,359 --> 00:44:59,839
human factors again like obviously

00:44:56,640 --> 00:45:00,880
storming is probably uh when no one

00:44:59,839 --> 00:45:04,240
trusts anyone

00:45:00,880 --> 00:45:07,280
is also when you're likely to see

00:45:04,240 --> 00:45:11,119
people kind of act as gatekeepers to

00:45:07,280 --> 00:45:14,160
to um to

00:45:11,119 --> 00:45:14,800
to deployments that kind of stuff do you

00:45:14,160 --> 00:45:19,280
have

00:45:14,800 --> 00:45:22,079
cisd solution for telco vertical

00:45:19,280 --> 00:45:22,079
what um

00:45:22,150 --> 00:45:28,640
[Music]

00:45:24,960 --> 00:45:32,480
i mean i don't know exact specifics or

00:45:28,640 --> 00:45:32,480
needs for telcos

00:45:33,599 --> 00:45:40,560
circle cr really works with any

00:45:37,040 --> 00:45:45,599
programming language platforms out there

00:45:40,560 --> 00:45:45,599
so i would imagine that you might find

00:45:45,760 --> 00:45:50,960
it works well for for that vertical as

00:45:49,440 --> 00:45:53,440
well

00:45:50,960 --> 00:45:55,680
i'm not sure whether there is like uh

00:45:53,440 --> 00:45:57,680
requirements beyond

00:45:55,680 --> 00:46:00,079
running something on your infrastructure

00:45:57,680 --> 00:46:03,440
or our cloud infrastructure or

00:46:00,079 --> 00:46:06,640
special kind of um

00:46:03,440 --> 00:46:10,480
machinery required to to

00:46:06,640 --> 00:46:14,000
build and deploy so or maybe even

00:46:10,480 --> 00:46:15,720
um maybe even uh

00:46:14,000 --> 00:46:17,440
kind of verifications for

00:46:15,720 --> 00:46:20,560
[Music]

00:46:17,440 --> 00:46:24,560
i know we have like several

00:46:20,560 --> 00:46:28,079
um accreditations from

00:46:24,560 --> 00:46:31,119
various organizations uh but

00:46:28,079 --> 00:46:42,720
i i i don't know about yeah specifics

00:46:31,119 --> 00:46:44,800
for telcos

00:46:42,720 --> 00:46:46,480
how to manage a large number of teams

00:46:44,800 --> 00:46:50,319
each of them are having

00:46:46,480 --> 00:46:55,240
their own circle ci um

00:46:50,319 --> 00:46:58,880
so if you're using a single kind of

00:46:55,240 --> 00:47:01,760
organization let's say on github

00:46:58,880 --> 00:47:04,400
then every member of that organization

00:47:01,760 --> 00:47:07,920
could have access to to circle ci

00:47:04,400 --> 00:47:11,040
in your in your plan um

00:47:07,920 --> 00:47:13,760
obviously whatever whatever someone sees

00:47:11,040 --> 00:47:15,040
in in your vcs is also going to be

00:47:13,760 --> 00:47:19,200
something they can access

00:47:15,040 --> 00:47:19,200
in in circle ci

00:47:19,359 --> 00:47:24,400
um what kind of what kind of issues

00:47:22,640 --> 00:47:26,000
are are you running into any particular

00:47:24,400 --> 00:47:29,599
issues regarding managing

00:47:26,000 --> 00:47:29,599
a large number of teams or

00:47:30,400 --> 00:47:33,119
or something else

00:47:37,359 --> 00:47:40,480
we definitely have like very large teams

00:47:40,240 --> 00:47:45,680
on

00:47:40,480 --> 00:47:45,680
organizations that we cover and uh

00:47:45,839 --> 00:47:50,720
but yeah i'm not sure about the

00:47:47,440 --> 00:47:50,720
specifics of your question

00:47:50,880 --> 00:47:56,559
and we are right at time here

00:47:54,480 --> 00:47:57,599
um so we maybe have time for one more

00:47:56,559 --> 00:48:00,640
question if

00:47:57,599 --> 00:48:00,640
if one comes in

00:48:02,400 --> 00:48:09,119
but yeah if anyone uh wants to kind of

00:48:06,880 --> 00:48:10,079
ask about any other questions please

00:48:09,119 --> 00:48:13,680
tweet me or

00:48:10,079 --> 00:48:17,680
email me um adsmarken on twitter or

00:48:13,680 --> 00:48:19,040
zan at circleci.com i imagine i can also

00:48:17,680 --> 00:48:23,280
share my slides with you

00:48:19,040 --> 00:48:26,640
and you can then post them

00:48:23,280 --> 00:48:28,079
yes absolutely awesome so i'll add some

00:48:26,640 --> 00:48:33,119
more resources and

00:48:28,079 --> 00:48:33,119
links so that folks can actually find

00:48:33,520 --> 00:48:37,359
what they might be looking for well

00:48:36,400 --> 00:48:40,240
thank you so much

00:48:37,359 --> 00:48:41,680
zan and thank you circle ci and thank

00:48:40,240 --> 00:48:42,720
you to all the participants who joined

00:48:41,680 --> 00:48:44,720
us today

00:48:42,720 --> 00:48:46,079
um as we mentioned at the beginning this

00:48:44,720 --> 00:48:48,160
recording will be available

00:48:46,079 --> 00:48:49,760
on the linux foundation youtube page

00:48:48,160 --> 00:48:55,200
shortly

00:48:49,760 --> 00:48:55,200

YouTube URL: https://www.youtube.com/watch?v=_Dk6X-S1AJM


