Title: LF Live Webinar: Edge Case: Considerations and Architecture for Linux Edge Deployments
Publication date: 2021-03-25
Playlist: LF Live Webinars
Description: 
	Sponsored by Red Hat

Edge deployments present IT challenges on a number of aspects, from limited hardware specs, low network bandwidth, distributed regional footprints, and more.  As architects, we can overcome these limitations by planning deployments with a focus on automation to support a GitOps approach to building and delivering Edge content at scale.
Captions: 
	00:00:00,000 --> 00:00:04,319
my name is robert sedor joining me today

00:00:02,480 --> 00:00:08,080
is andre patanga

00:00:04,319 --> 00:00:11,040
and we get to work together on a

00:00:08,080 --> 00:00:12,080
quite a few different kind of projects

00:00:11,040 --> 00:00:14,080
one of which

00:00:12,080 --> 00:00:15,200
most recently has been quite a bit of

00:00:14,080 --> 00:00:18,320
work around

00:00:15,200 --> 00:00:21,279
edge especially with rel

00:00:18,320 --> 00:00:22,400
so with regards to topology kind of

00:00:21,279 --> 00:00:24,560
jumping right in

00:00:22,400 --> 00:00:26,160
a lot of times what we're seeing is is

00:00:24,560 --> 00:00:29,519
that edge

00:00:26,160 --> 00:00:33,280
and edge discussions tend to

00:00:29,519 --> 00:00:36,559
be around extensions of the i.t

00:00:33,280 --> 00:00:38,079
shop and the it organization is

00:00:36,559 --> 00:00:40,160
trying to figure out how to piece

00:00:38,079 --> 00:00:40,719
together their existing knowledge on

00:00:40,160 --> 00:00:42,960
linux

00:00:40,719 --> 00:00:44,480
and what they're doing with edge and

00:00:42,960 --> 00:00:46,559
this oftentimes

00:00:44,480 --> 00:00:47,520
amounts to um you know what they're

00:00:46,559 --> 00:00:51,600
familiar with so

00:00:47,520 --> 00:00:53,520
racks racks that bring compute

00:00:51,600 --> 00:00:55,280
closer to the edge space where they're

00:00:53,520 --> 00:00:57,199
actually doing collection of data and a

00:00:55,280 --> 00:01:00,879
lot of times this means

00:00:57,199 --> 00:01:01,440
open shift for red hat or compute that

00:01:00,879 --> 00:01:03,920
is uh

00:01:01,440 --> 00:01:04,879
you know extending what we're doing with

00:01:03,920 --> 00:01:06,640
a pass

00:01:04,879 --> 00:01:08,400
but today we're going to actually talk

00:01:06,640 --> 00:01:09,360
about something that's actually further

00:01:08,400 --> 00:01:11,840
to the edge

00:01:09,360 --> 00:01:13,360
which is smaller devices and bringing

00:01:11,840 --> 00:01:16,400
rel and linux

00:01:13,360 --> 00:01:18,080
down to these edge devices so

00:01:16,400 --> 00:01:19,920
next slide please yeah and i would add

00:01:18,080 --> 00:01:22,080
to rob is that you know

00:01:19,920 --> 00:01:22,960
not too small devices right because

00:01:22,080 --> 00:01:25,840
there's also

00:01:22,960 --> 00:01:27,439
edge deployments that are tiny sensors

00:01:25,840 --> 00:01:29,680
and you know

00:01:27,439 --> 00:01:30,720
very specialized hardware what we're

00:01:29,680 --> 00:01:32,799
looking at today

00:01:30,720 --> 00:01:34,640
is a typical use case which is more like

00:01:32,799 --> 00:01:38,240
edge servers if i'm right right

00:01:34,640 --> 00:01:40,159
rob exactly

00:01:38,240 --> 00:01:42,640
so a little bit of housekeeping we're

00:01:40,159 --> 00:01:46,479
not going to talk about alif edge

00:01:42,640 --> 00:01:48,799
um today in particular but i think that

00:01:46,479 --> 00:01:50,799
if you're watching this webinar you

00:01:48,799 --> 00:01:54,000
should probably want to look into

00:01:50,799 --> 00:01:55,439
lf edge a chrono and edge foundry these

00:01:54,000 --> 00:01:57,840
are projects that

00:01:55,439 --> 00:01:59,119
the linux foundation and red hat are are

00:01:57,840 --> 00:02:02,640
involved with

00:01:59,119 --> 00:02:05,119
so um think of lf edge as really being

00:02:02,640 --> 00:02:07,119
kind of an umbrella that has a number of

00:02:05,119 --> 00:02:08,800
different organizations involved

00:02:07,119 --> 00:02:10,479
and they're really creating a common

00:02:08,800 --> 00:02:11,440
framework for hardware and software

00:02:10,479 --> 00:02:14,160
standards

00:02:11,440 --> 00:02:14,720
well projects like chrono is really um

00:02:14,160 --> 00:02:16,800
looking

00:02:14,720 --> 00:02:18,720
you know at a set of open infrastructure

00:02:16,800 --> 00:02:21,920
and blueprints for the edge so

00:02:18,720 --> 00:02:23,440
i really um you know would push you to

00:02:21,920 --> 00:02:26,080
really look into what those things

00:02:23,440 --> 00:02:27,360
are and how they're going to impact the

00:02:26,080 --> 00:02:29,120
industry

00:02:27,360 --> 00:02:31,760
let me second that the stuff that's

00:02:29,120 --> 00:02:34,480
going on at lf edge is super exciting

00:02:31,760 --> 00:02:36,400
uh some of these solutions are getting

00:02:34,480 --> 00:02:39,120
to a great level of maturity

00:02:36,400 --> 00:02:40,080
they're very comprehensive if you want

00:02:39,120 --> 00:02:42,879
to take

00:02:40,080 --> 00:02:45,120
rob and i's uh presentation today it's

00:02:42,879 --> 00:02:47,440
really about our learning process

00:02:45,120 --> 00:02:49,360
right we're two individual engineers

00:02:47,440 --> 00:02:51,360
that were exploring edge

00:02:49,360 --> 00:02:53,360
and exploring really the building blocks

00:02:51,360 --> 00:02:54,640
of edge right so as we're going to show

00:02:53,360 --> 00:02:57,360
we're going to talk about

00:02:54,640 --> 00:02:58,560
image building about updating the edge

00:02:57,360 --> 00:03:01,440
devices

00:02:58,560 --> 00:03:03,200
sort of reservability using open source

00:03:01,440 --> 00:03:04,720
components that are out there

00:03:03,200 --> 00:03:06,800
but if you want to look at the state of

00:03:04,720 --> 00:03:08,720
the arts and sort of the future

00:03:06,800 --> 00:03:10,480
you know and some of this really good

00:03:08,720 --> 00:03:12,239
stuff that's happening here

00:03:10,480 --> 00:03:16,319
uh you'll be remiss to not look at

00:03:12,239 --> 00:03:16,319
what's going on at lfedge.org

00:03:17,440 --> 00:03:22,640
great thanks and um so let's dive right

00:03:20,959 --> 00:03:25,200
into what we're going to really um

00:03:22,640 --> 00:03:25,680
hone in on today which is linux at the

00:03:25,200 --> 00:03:27,840
edge

00:03:25,680 --> 00:03:29,760
and and specifically how we're working

00:03:27,840 --> 00:03:31,519
with rel at the edge

00:03:29,760 --> 00:03:32,799
um this means that we have a number of

00:03:31,519 --> 00:03:33,440
different things that we have to think

00:03:32,799 --> 00:03:36,239
about from

00:03:33,440 --> 00:03:37,760
management perspectives so um how are we

00:03:36,239 --> 00:03:40,640
going to actually build

00:03:37,760 --> 00:03:42,720
the code for linux that's actually going

00:03:40,640 --> 00:03:45,680
to be put out on the edge

00:03:42,720 --> 00:03:47,599
today we're using a git ops approach

00:03:45,680 --> 00:03:48,959
we're also using ansible in order to

00:03:47,599 --> 00:03:50,560
manage that

00:03:48,959 --> 00:03:53,120
and we're looking at ansible from a

00:03:50,560 --> 00:03:56,159
couple of different

00:03:53,120 --> 00:03:58,319
key vantage points one is do we have

00:03:56,159 --> 00:03:59,519
access on the network and is the network

00:03:58,319 --> 00:04:02,480
able to provide

00:03:59,519 --> 00:04:05,439
us with enough comfort where we can

00:04:02,480 --> 00:04:08,560
manage the edge devices with ansible

00:04:05,439 --> 00:04:11,760
like we would other linux instances

00:04:08,560 --> 00:04:12,480
or should we put ansible down onto the

00:04:11,760 --> 00:04:15,280
edge

00:04:12,480 --> 00:04:16,959
and actually have it call back out so

00:04:15,280 --> 00:04:18,720
basically it's a difference between a

00:04:16,959 --> 00:04:20,400
push and a pull model

00:04:18,720 --> 00:04:21,919
and because of this we're you know we've

00:04:20,400 --> 00:04:23,360
been looking at technologies like

00:04:21,919 --> 00:04:26,479
ansible runner

00:04:23,360 --> 00:04:28,320
ansible builder and reactor

00:04:26,479 --> 00:04:30,720
which kind of make ansible really highly

00:04:28,320 --> 00:04:32,560
attractive for edge architectures

00:04:30,720 --> 00:04:33,919
and then of course the whole point of

00:04:32,560 --> 00:04:36,560
actually putting compute

00:04:33,919 --> 00:04:39,280
closer to the edge is to work with data

00:04:36,560 --> 00:04:42,880
maybe reroute data manipulate data

00:04:39,280 --> 00:04:44,479
bring rules or aiml components down

00:04:42,880 --> 00:04:46,000
to the edge and how are we going to run

00:04:44,479 --> 00:04:46,639
those and we're going to talk about

00:04:46,000 --> 00:04:49,120
podman

00:04:46,639 --> 00:04:49,680
in that context today so go ahead the

00:04:49,120 --> 00:04:52,960
next

00:04:49,680 --> 00:04:54,720
slide so another bit is

00:04:52,960 --> 00:04:56,000
from the configuration management how

00:04:54,720 --> 00:04:58,639
are we going to manage these

00:04:56,000 --> 00:04:59,040
images we know that in the past when we

00:04:58,639 --> 00:05:02,400
had

00:04:59,040 --> 00:05:03,520
um image management with vms for

00:05:02,400 --> 00:05:05,600
instance

00:05:03,520 --> 00:05:07,120
we might have image sprawl other things

00:05:05,600 --> 00:05:10,240
so how can we manage these

00:05:07,120 --> 00:05:10,639
um you know as code and can we put these

00:05:10,240 --> 00:05:13,759
in

00:05:10,639 --> 00:05:15,199
git ops kind of fashion so that we can

00:05:13,759 --> 00:05:17,440
manage them with git

00:05:15,199 --> 00:05:19,039
and then in addition to that can we

00:05:17,440 --> 00:05:20,960
manage them with

00:05:19,039 --> 00:05:22,320
novel things that we have approaches

00:05:20,960 --> 00:05:24,800
that we have such as

00:05:22,320 --> 00:05:26,479
os builder or rpm os tree which we're

00:05:24,800 --> 00:05:28,800
also going to talk about today

00:05:26,479 --> 00:05:30,720
so that we can reduce the network

00:05:28,800 --> 00:05:31,840
traffic um reduce the bandwidth

00:05:30,720 --> 00:05:35,120
requirements

00:05:31,840 --> 00:05:38,880
because many of these edge use cases

00:05:35,120 --> 00:05:44,160
actually have a limited network um

00:05:38,880 --> 00:05:44,160
either bandwidth or request latency

00:05:44,880 --> 00:05:49,199
so and then from the perspective of

00:05:47,919 --> 00:05:51,440
where are we going to

00:05:49,199 --> 00:05:52,720
design and build the applications how

00:05:51,440 --> 00:05:54,479
are we going to

00:05:52,720 --> 00:05:56,479
manage the images that are going to be

00:05:54,479 --> 00:05:58,240
brought down and actually run

00:05:56,479 --> 00:06:00,800
how are we going to actually build the

00:05:58,240 --> 00:06:02,720
edge images themselves for the os

00:06:00,800 --> 00:06:04,400
where are we going to collect telemetry

00:06:02,720 --> 00:06:05,199
and how is that telemetry going to be

00:06:04,400 --> 00:06:08,000
brought back

00:06:05,199 --> 00:06:09,919
up from the edge we're going to do that

00:06:08,000 --> 00:06:11,440
from a kubernetes environment

00:06:09,919 --> 00:06:13,600
in our example that we're going to talk

00:06:11,440 --> 00:06:17,520
about today and next slide

00:06:13,600 --> 00:06:20,319
and that brings us to openshift right so

00:06:17,520 --> 00:06:23,360
openshift is red hat's kubernetes

00:06:20,319 --> 00:06:25,360
it's a fully um certified

00:06:23,360 --> 00:06:26,800
kubernetes platform that's all open

00:06:25,360 --> 00:06:28,720
source

00:06:26,800 --> 00:06:30,400
we're running ansible on top of

00:06:28,720 --> 00:06:32,639
kubernetes we're also running

00:06:30,400 --> 00:06:34,000
um you know the elk stack on kubernetes

00:06:32,639 --> 00:06:36,400
that's going to collect our telemetry

00:06:34,000 --> 00:06:37,680
information from prometheus endpoints

00:06:36,400 --> 00:06:41,120
from those edge

00:06:37,680 --> 00:06:43,280
devices can we use smart management so

00:06:41,120 --> 00:06:44,720
what that is is satellite um you know

00:06:43,280 --> 00:06:46,560
formerly spacewalk but now

00:06:44,720 --> 00:06:48,560
satellite so are we going to add

00:06:46,560 --> 00:06:51,280
functionality so that if we are

00:06:48,560 --> 00:06:51,919
using an rpm approach versus an rpm os 3

00:06:51,280 --> 00:06:55,120
approach

00:06:51,919 --> 00:06:58,080
can we manage the os and configuration

00:06:55,120 --> 00:06:58,720
and then also um leveraging again

00:06:58,080 --> 00:07:01,199
ansible

00:06:58,720 --> 00:07:02,240
and two different approaches in order to

00:07:01,199 --> 00:07:05,120
manage these um

00:07:02,240 --> 00:07:05,120
actual devices

00:07:07,280 --> 00:07:10,880
yeah and thank you rob we're going to

00:07:09,520 --> 00:07:14,319
start by taking a look at it

00:07:10,880 --> 00:07:17,199
building these images as rob mentioned

00:07:14,319 --> 00:07:19,440
trying to define essentially a get ops

00:07:17,199 --> 00:07:21,280
pipeline to create the images

00:07:19,440 --> 00:07:23,039
so how these images are put together

00:07:21,280 --> 00:07:26,400
based on libos3

00:07:23,039 --> 00:07:28,000
rpm os3 um you know everything that you

00:07:26,400 --> 00:07:30,160
need to really create these images

00:07:28,000 --> 00:07:32,080
create the image layers

00:07:30,160 --> 00:07:34,240
put them out where the edge devices can

00:07:32,080 --> 00:07:36,960
get them update them

00:07:34,240 --> 00:07:39,120
let's take a quick look at that so the

00:07:36,960 --> 00:07:41,599
basis of it right like if you look at an

00:07:39,120 --> 00:07:43,440
edge server image uh one of the key

00:07:41,599 --> 00:07:46,879
distinctions from a traditional

00:07:43,440 --> 00:07:48,479
um you know rel operating system

00:07:46,879 --> 00:07:49,919
would be that we want to deliver that

00:07:48,479 --> 00:07:52,240
essentially as an image

00:07:49,919 --> 00:07:53,360
almost like as an appliance right for a

00:07:52,240 --> 00:07:56,639
lot of reasons

00:07:53,360 --> 00:07:57,680
so the basis of that is lib os3 uh for

00:07:56,639 --> 00:07:59,199
those of you that

00:07:57,680 --> 00:08:01,360
may not know what that is it's

00:07:59,199 --> 00:08:04,720
essentially a way to define

00:08:01,360 --> 00:08:07,360
um os file system trees

00:08:04,720 --> 00:08:09,280
almost like git right where you can have

00:08:07,360 --> 00:08:12,560
layers and tag specific

00:08:09,280 --> 00:08:14,639
versions of layers on there the essence

00:08:12,560 --> 00:08:17,039
of it is becomes almost like

00:08:14,639 --> 00:08:18,160
um an appliance deliverable that you can

00:08:17,039 --> 00:08:20,960
push out

00:08:18,160 --> 00:08:21,599
as well as the updates instead of being

00:08:20,960 --> 00:08:24,639
per

00:08:21,599 --> 00:08:27,919
rpm um sort of updates

00:08:24,639 --> 00:08:29,599
they are you know full-on um atomic

00:08:27,919 --> 00:08:31,440
updates which you may call

00:08:29,599 --> 00:08:33,279
and then has that has a lot of divide

00:08:31,440 --> 00:08:36,320
advantages for an edge

00:08:33,279 --> 00:08:36,800
um standpoint um because as we're going

00:08:36,320 --> 00:08:38,560
to see

00:08:36,800 --> 00:08:40,560
one of the things is that we want to

00:08:38,560 --> 00:08:42,320
limit the downtime limit you know

00:08:40,560 --> 00:08:44,399
maximize the uptime at those edge

00:08:42,320 --> 00:08:45,680
devices so we're going to

00:08:44,399 --> 00:08:47,760
talk a little bit about how we do

00:08:45,680 --> 00:08:48,800
rollbacks into that and sort of health

00:08:47,760 --> 00:08:51,519
checks

00:08:48,800 --> 00:08:53,440
you know it's either all in either all

00:08:51,519 --> 00:08:54,320
the updates succeeds or it kind of rolls

00:08:53,440 --> 00:08:56,720
back

00:08:54,320 --> 00:08:59,839
so but the basis of it is that take a

00:08:56,720 --> 00:09:02,399
look at rpm os3 and libos3

00:08:59,839 --> 00:09:03,200
and start thinking about how you know

00:09:02,399 --> 00:09:06,080
sort of these

00:09:03,200 --> 00:09:08,399
um complete file system trees can be

00:09:06,080 --> 00:09:08,959
delivered to the edge device as well as

00:09:08,399 --> 00:09:12,720
how that

00:09:08,959 --> 00:09:12,720
simplifies the update process

00:09:12,800 --> 00:09:17,600
so to take a quick look at rpm os 3 and

00:09:15,200 --> 00:09:20,399
how that works on rail for the edge but

00:09:17,600 --> 00:09:22,720
in general as well the idea is that it

00:09:20,399 --> 00:09:26,240
becomes an immutable um

00:09:22,720 --> 00:09:28,320
image right mostly read only

00:09:26,240 --> 00:09:29,519
we still have state maintain under var

00:09:28,320 --> 00:09:31,600
and etsy

00:09:29,519 --> 00:09:33,680
uh in the essence of it is that there's

00:09:31,600 --> 00:09:36,080
no in between states between you know in

00:09:33,680 --> 00:09:37,920
between state between the updates right

00:09:36,080 --> 00:09:40,480
it's not like i'm just adding an rpm

00:09:37,920 --> 00:09:43,360
here or modifying this or that there

00:09:40,480 --> 00:09:43,839
everything gets defined as a git uh you

00:09:43,360 --> 00:09:47,519
know

00:09:43,839 --> 00:09:49,839
uh file right everything gets defined as

00:09:47,519 --> 00:09:50,720
code as text you know configuration

00:09:49,839 --> 00:09:53,600
files

00:09:50,720 --> 00:09:54,320
and then these images are are created

00:09:53,600 --> 00:09:56,880
layers

00:09:54,320 --> 00:09:57,920
as it gets updated and then that gets

00:09:56,880 --> 00:10:01,600
pushed out to

00:09:57,920 --> 00:10:02,079
to the edge device and it gets staged

00:10:01,600 --> 00:10:04,560
there

00:10:02,079 --> 00:10:06,160
right um as the updates are coming out

00:10:04,560 --> 00:10:08,480
and pushed to the mirrors

00:10:06,160 --> 00:10:10,800
but then they only they get updated the

00:10:08,480 --> 00:10:12,959
system gets updated when you reboot

00:10:10,800 --> 00:10:14,480
right so you re you schedule that reboot

00:10:12,959 --> 00:10:17,440
at a specific time

00:10:14,480 --> 00:10:19,040
and then when it reboots it boots into

00:10:17,440 --> 00:10:22,880
this new partition

00:10:19,040 --> 00:10:24,800
and then it succeeds or rolls back

00:10:22,880 --> 00:10:26,720
and we have green boots which is a

00:10:24,800 --> 00:10:28,480
method to

00:10:26,720 --> 00:10:30,959
take a look at if it was successful and

00:10:28,480 --> 00:10:30,959
roll back

00:10:31,440 --> 00:10:35,200
so the basis of it is you know you may

00:10:33,519 --> 00:10:39,519
ask well how do i build

00:10:35,200 --> 00:10:41,760
these um you know rpm os3 images right

00:10:39,519 --> 00:10:43,519
and um you know we encourage everybody

00:10:41,760 --> 00:10:46,880
to check out the open source os

00:10:43,519 --> 00:10:49,600
build project specifically composer

00:10:46,880 --> 00:10:51,200
right so composer is a really great tool

00:10:49,600 --> 00:10:52,240
the idea with composer is that you

00:10:51,200 --> 00:10:55,279
define

00:10:52,240 --> 00:10:58,000
what goes into your image as a text

00:10:55,279 --> 00:11:00,399
human readable file and then composer

00:10:58,000 --> 00:11:04,320
has a process that generates these

00:11:00,399 --> 00:11:07,120
os 3 artifacts

00:11:04,320 --> 00:11:08,640
for you not only os 3 it does other

00:11:07,120 --> 00:11:09,839
types of images as well

00:11:08,640 --> 00:11:12,399
but for the purposes of this

00:11:09,839 --> 00:11:14,959
presentation we're going to focus on os3

00:11:12,399 --> 00:11:15,760
so the idea here you can see it's pretty

00:11:14,959 --> 00:11:18,240
easy to

00:11:15,760 --> 00:11:19,600
read and understand it's just a text

00:11:18,240 --> 00:11:23,600
file that gets committed to

00:11:19,600 --> 00:11:25,360
your github apple right to your scm repo

00:11:23,600 --> 00:11:27,120
and you know for example you can add

00:11:25,360 --> 00:11:30,000
specific packages

00:11:27,120 --> 00:11:31,279
uh in our case as rob was saying earlier

00:11:30,000 --> 00:11:32,880
our applications are going to be

00:11:31,279 --> 00:11:35,760
delivered as containers

00:11:32,880 --> 00:11:36,720
so we're using podman as the container

00:11:35,760 --> 00:11:38,959
tool for that

00:11:36,720 --> 00:11:40,959
right so in our case we would add you

00:11:38,959 --> 00:11:42,480
know podman and the specific version

00:11:40,959 --> 00:11:46,240
that we want there

00:11:42,480 --> 00:11:48,560
um this is what's called the blueprint

00:11:46,240 --> 00:11:49,680
and then once you have the you know you

00:11:48,560 --> 00:11:52,720
have your blueprint

00:11:49,680 --> 00:11:53,760
in git um you know it creates an

00:11:52,720 --> 00:11:55,600
artifact

00:11:53,760 --> 00:11:57,519
but how do you actually you know boot

00:11:55,600 --> 00:11:59,519
into that artifact into that

00:11:57,519 --> 00:12:01,760
file system tree right how do you

00:11:59,519 --> 00:12:04,399
actually uh you know provision

00:12:01,760 --> 00:12:05,600
that system and the way that we use you

00:12:04,399 --> 00:12:08,560
know to rob's point

00:12:05,600 --> 00:12:10,160
um before using traditional skill sets

00:12:08,560 --> 00:12:12,079
that you may have today

00:12:10,160 --> 00:12:14,000
in the traditional data center we're

00:12:12,079 --> 00:12:16,880
just using a kickstart file

00:12:14,000 --> 00:12:18,639
right here's a typical kickstart file

00:12:16,880 --> 00:12:21,920
and the only difference is that i'm

00:12:18,639 --> 00:12:25,360
you know kind of mounting an os tree

00:12:21,920 --> 00:12:26,240
here and it's picking that up from an

00:12:25,360 --> 00:12:29,680
http

00:12:26,240 --> 00:12:30,720
location right so remember before we

00:12:29,680 --> 00:12:34,240
said that these are

00:12:30,720 --> 00:12:36,079
immutable images right layer gets like

00:12:34,240 --> 00:12:38,079
in their characteristics

00:12:36,079 --> 00:12:40,240
i'm creating those by defining a

00:12:38,079 --> 00:12:42,079
blueprint in composer

00:12:40,240 --> 00:12:44,480
and then once those get created i just

00:12:42,079 --> 00:12:47,040
put them in an http location

00:12:44,480 --> 00:12:47,920
and then my system you know my edge

00:12:47,040 --> 00:12:50,320
server

00:12:47,920 --> 00:12:53,600
can pick up that from can pick that

00:12:50,320 --> 00:12:55,680
image up from http and boot it

00:12:53,600 --> 00:12:57,519
so right now we have basically three

00:12:55,680 --> 00:12:58,079
artifacts that i talked about so far

00:12:57,519 --> 00:13:01,200
right

00:12:58,079 --> 00:13:03,360
we have my blueprint for composer

00:13:01,200 --> 00:13:04,639
which is a text file we have my

00:13:03,360 --> 00:13:07,279
kickstart file

00:13:04,639 --> 00:13:08,160
which is just a text file and we have

00:13:07,279 --> 00:13:11,680
the actual

00:13:08,160 --> 00:13:13,760
rpm os3 file system tree

00:13:11,680 --> 00:13:15,680
and one important thing is that the good

00:13:13,760 --> 00:13:17,519
thing about using kickstart

00:13:15,680 --> 00:13:19,680
is that you can have a pre and post

00:13:17,519 --> 00:13:20,639
section like you had traditionally in

00:13:19,680 --> 00:13:22,519
kickstarts

00:13:20,639 --> 00:13:23,839
so if you want to drop in certain

00:13:22,519 --> 00:13:25,440
configurations

00:13:23,839 --> 00:13:29,519
or certain things that are specific for

00:13:25,440 --> 00:13:29,519
your use case you can do that as well

00:13:31,120 --> 00:13:34,480
we actually provide you know image

00:13:33,200 --> 00:13:37,040
builder is sort of

00:13:34,480 --> 00:13:38,560
uh the red hat product around it uh the

00:13:37,040 --> 00:13:39,680
cool thing about it is that you can do

00:13:38,560 --> 00:13:42,639
it through the command line

00:13:39,680 --> 00:13:44,160
in a git like way like which you know

00:13:42,639 --> 00:13:47,279
like we're gonna describe

00:13:44,160 --> 00:13:48,639
in this presentation but um if you're a

00:13:47,279 --> 00:13:51,519
redhead customer

00:13:48,639 --> 00:13:53,360
you can take a look at uh having a gui

00:13:51,519 --> 00:13:56,560
for it using the cockpit

00:13:53,360 --> 00:13:58,079
administration program and as you can

00:13:56,560 --> 00:14:00,880
see here you can even refer

00:13:58,079 --> 00:14:02,639
to a previous commit right so you just

00:14:00,880 --> 00:14:04,959
kind of layering that file system as

00:14:02,639 --> 00:14:06,720
changes come in

00:14:04,959 --> 00:14:10,000
and this is shipped and supported by red

00:14:06,720 --> 00:14:10,000
hat as a commercial product

00:14:10,560 --> 00:14:14,880
so overall taking all of these elements

00:14:12,959 --> 00:14:17,120
that i described so far right let's

00:14:14,880 --> 00:14:20,399
quickly take a look at this pipeline

00:14:17,120 --> 00:14:22,560
as um rob mentioned basically we have

00:14:20,399 --> 00:14:25,440
the southbound here which is my

00:14:22,560 --> 00:14:27,360
my edge nodes and the northbound which

00:14:25,440 --> 00:14:30,240
is all running in kubernetes

00:14:27,360 --> 00:14:30,560
and it's my image build pipeline right

00:14:30,240 --> 00:14:32,320
so

00:14:30,560 --> 00:14:34,720
imagine that this is a kubernetes

00:14:32,320 --> 00:14:38,399
cluster right openshift etc

00:14:34,720 --> 00:14:38,880
uh techton is the ci cd pipeline behind

00:14:38,399 --> 00:14:42,160
it

00:14:38,880 --> 00:14:44,240
so here's my get repo right my scm

00:14:42,160 --> 00:14:45,279
what do i have there i have my text

00:14:44,240 --> 00:14:48,720
blueprint

00:14:45,279 --> 00:14:50,800
very simple right how i compose my image

00:14:48,720 --> 00:14:52,320
i have my kickstart file which is

00:14:50,800 --> 00:14:54,240
everything that i need to actually do

00:14:52,320 --> 00:14:56,720
the deployment of that image

00:14:54,240 --> 00:14:57,680
so as i'm as an operator as i'm making

00:14:56,720 --> 00:15:01,040
changes to my

00:14:57,680 --> 00:15:03,920
my uh my code here right it kicks the

00:15:01,040 --> 00:15:05,440
the pipeline uh it automatically you

00:15:03,920 --> 00:15:08,639
know what we do is we launch

00:15:05,440 --> 00:15:10,720
a vm right uh you know we don't want to

00:15:08,639 --> 00:15:12,880
have like a static image builder

00:15:10,720 --> 00:15:15,040
right our infrastructure there so what

00:15:12,880 --> 00:15:18,000
we do we sort of dynamically

00:15:15,040 --> 00:15:19,120
create a system a rail system right os

00:15:18,000 --> 00:15:21,199
build system

00:15:19,120 --> 00:15:22,800
that's gonna actually do that composing

00:15:21,199 --> 00:15:25,360
that i described earlier

00:15:22,800 --> 00:15:26,160
you using our blueprint and as rob

00:15:25,360 --> 00:15:29,199
mentioned earlier

00:15:26,160 --> 00:15:32,240
before we're just using you know like

00:15:29,199 --> 00:15:32,880
that composer process it's just really

00:15:32,240 --> 00:15:35,839
creating

00:15:32,880 --> 00:15:36,959
you know a file system tree based on rpm

00:15:35,839 --> 00:15:39,279
packages

00:15:36,959 --> 00:15:41,360
these could be red hat rpm packages or

00:15:39,279 --> 00:15:42,079
third-party rpm packages that you may

00:15:41,360 --> 00:15:44,800
have

00:15:42,079 --> 00:15:45,680
your software shipped as then we

00:15:44,800 --> 00:15:48,639
download the

00:15:45,680 --> 00:15:50,240
sort of the image artifact archive the

00:15:48,639 --> 00:15:53,120
previous image artifacts

00:15:50,240 --> 00:15:53,600
artifact to nexus and then we publish

00:15:53,120 --> 00:15:56,480
you know

00:15:53,600 --> 00:15:57,759
basically that our rpm os3 artifact is a

00:15:56,480 --> 00:16:02,399
tarball

00:15:57,759 --> 00:16:04,160
um we upload that to our htcp location

00:16:02,399 --> 00:16:05,839
and then have a similar pipeline to the

00:16:04,160 --> 00:16:07,759
kickstart file right

00:16:05,839 --> 00:16:10,079
as we made any changes to our kickstart

00:16:07,759 --> 00:16:11,839
or not right it templates out that

00:16:10,079 --> 00:16:13,920
kickstart file for me

00:16:11,839 --> 00:16:14,880
archives the previous version and

00:16:13,920 --> 00:16:18,079
publishes the

00:16:14,880 --> 00:16:21,199
our kickstart here to my http location

00:16:18,079 --> 00:16:23,360
and the cool thing about this is that um

00:16:21,199 --> 00:16:26,240
it doesn't have to be like a single

00:16:23,360 --> 00:16:29,040
location where i'm going to have 2500

00:16:26,240 --> 00:16:31,120
10 000 edge nodes getting there these

00:16:29,040 --> 00:16:33,199
could be distributed regionally

00:16:31,120 --> 00:16:34,560
right i mean it's really as simple as an

00:16:33,199 --> 00:16:36,959
s3 bucket

00:16:34,560 --> 00:16:38,000
or whatever other http location that you

00:16:36,959 --> 00:16:40,480
have here

00:16:38,000 --> 00:16:42,160
uh so it's it's pretty economical and

00:16:40,480 --> 00:16:44,880
you know it can be geo

00:16:42,160 --> 00:16:46,079
geo distributed fairly easy and that's

00:16:44,880 --> 00:16:49,360
all that you need to

00:16:46,079 --> 00:16:52,240
to get your our your your um

00:16:49,360 --> 00:16:53,600
edge node to boot and the actual boot

00:16:52,240 --> 00:16:56,160
process can be

00:16:53,600 --> 00:16:57,600
done through pixie boots right just you

00:16:56,160 --> 00:17:00,000
know you imagine that i just

00:16:57,600 --> 00:17:01,040
brought in that device to the edge i

00:17:00,000 --> 00:17:03,839
light it up

00:17:01,040 --> 00:17:05,039
it's set to you know pixie boots it

00:17:03,839 --> 00:17:08,000
pixie boots

00:17:05,039 --> 00:17:10,000
picks up the kickstart file and the

00:17:08,000 --> 00:17:11,520
image artifact and then it fully builds

00:17:10,000 --> 00:17:14,640
itself

00:17:11,520 --> 00:17:14,640
with the latest version

00:17:14,880 --> 00:17:18,400
and to that point there's the idea of

00:17:17,520 --> 00:17:20,319
over-the-air

00:17:18,400 --> 00:17:21,919
updates right and some of the advantages

00:17:20,319 --> 00:17:24,079
of that as we know

00:17:21,919 --> 00:17:26,799
edge servers edge locations may have

00:17:24,079 --> 00:17:28,799
intermittent or disconnected bandwidth

00:17:26,799 --> 00:17:30,960
normally you know we want some kind of

00:17:28,799 --> 00:17:33,840
lightweight way to do that

00:17:30,960 --> 00:17:35,280
so we only transfer that those delta

00:17:33,840 --> 00:17:37,600
layers from the image

00:17:35,280 --> 00:17:40,080
right remember that i was saying that as

00:17:37,600 --> 00:17:42,240
we're updating that image we stage that

00:17:40,080 --> 00:17:44,799
we stage those images locally at the

00:17:42,240 --> 00:17:47,679
edge device and then reboot into it

00:17:44,799 --> 00:17:48,320
while we don't have to download a full

00:17:47,679 --> 00:17:50,320
you know

00:17:48,320 --> 00:17:52,880
gigabyte image every time there's an

00:17:50,320 --> 00:17:53,919
update so this is a graph that shows

00:17:52,880 --> 00:17:55,760
that right

00:17:53,919 --> 00:17:57,600
here i have um you know a couple of

00:17:55,760 --> 00:18:00,799
nodes this

00:17:57,600 --> 00:18:03,760
one the blue guy here has this version

00:18:00,799 --> 00:18:04,720
so it only needs this revision3 layer on

00:18:03,760 --> 00:18:07,039
top of it

00:18:04,720 --> 00:18:07,760
whereas a new build that doesn't have

00:18:07,039 --> 00:18:10,400
anything

00:18:07,760 --> 00:18:12,160
will get the full image any comments you

00:18:10,400 --> 00:18:13,520
want to make so far rob i'm going pretty

00:18:12,160 --> 00:18:15,520
fast

00:18:13,520 --> 00:18:16,559
yeah i think you know with with rel

00:18:15,520 --> 00:18:18,960
eight three

00:18:16,559 --> 00:18:21,360
um what we've you know we have the new

00:18:18,960 --> 00:18:23,919
image um capabilities

00:18:21,360 --> 00:18:24,640
with you know admins can now stage their

00:18:23,919 --> 00:18:27,360
updates

00:18:24,640 --> 00:18:28,880
so they can consume less data and apply

00:18:27,360 --> 00:18:29,919
the updates on the reboot like you just

00:18:28,880 --> 00:18:31,360
said but

00:18:29,919 --> 00:18:32,880
what that also means is that i can

00:18:31,360 --> 00:18:33,440
choose the best time for a maintenance

00:18:32,880 --> 00:18:37,120
window

00:18:33,440 --> 00:18:38,799
and apply the updates um on my terms you

00:18:37,120 --> 00:18:41,840
know something that maximizes

00:18:38,799 --> 00:18:42,799
you know up time so some things that

00:18:41,840 --> 00:18:46,160
we've considered

00:18:42,799 --> 00:18:48,000
are like using um performance co-pilot

00:18:46,160 --> 00:18:51,440
or pcp

00:18:48,000 --> 00:18:53,200
in order to check um bandwidth

00:18:51,440 --> 00:18:55,200
on the network for these low bandwidth

00:18:53,200 --> 00:18:56,640
or intermittent

00:18:55,200 --> 00:18:59,280
you know intermittently connected

00:18:56,640 --> 00:19:01,840
devices and then choosing when

00:18:59,280 --> 00:19:02,880
based on those um on that data and

00:19:01,840 --> 00:19:05,120
telemetry

00:19:02,880 --> 00:19:07,120
um when to actually push the updates and

00:19:05,120 --> 00:19:09,520
stage the updates right so

00:19:07,120 --> 00:19:12,720
this gives us a little more control over

00:19:09,520 --> 00:19:14,799
how we're managing the edge devices

00:19:12,720 --> 00:19:16,320
it does and another thing that's cool

00:19:14,799 --> 00:19:18,640
about it as well and we're going to get

00:19:16,320 --> 00:19:20,880
into more details about this in a second

00:19:18,640 --> 00:19:23,280
the edge nodes have the ability to kind

00:19:20,880 --> 00:19:26,320
of once every 24 hours

00:19:23,280 --> 00:19:26,640
or however frequency you want check the

00:19:26,320 --> 00:19:28,720
up

00:19:26,640 --> 00:19:30,880
to check the update mirrors to see if

00:19:28,720 --> 00:19:33,760
there's new layers to the image

00:19:30,880 --> 00:19:34,400
right so and sort of initiate a download

00:19:33,760 --> 00:19:37,679
and a pool

00:19:34,400 --> 00:19:39,200
of that of that um you know layer

00:19:37,679 --> 00:19:40,880
so the cool thing about it is that it's

00:19:39,200 --> 00:19:43,039
firewall friendly as well

00:19:40,880 --> 00:19:45,280
we're not necessarily pushing it to the

00:19:43,039 --> 00:19:47,919
edge device which will be difficult

00:19:45,280 --> 00:19:49,360
and error prone we're actually you know

00:19:47,919 --> 00:19:51,679
just updating the

00:19:49,360 --> 00:19:52,720
the mirrors using the pipeline that i

00:19:51,679 --> 00:19:54,720
showed earlier

00:19:52,720 --> 00:19:56,880
and then the edge devices can check them

00:19:54,720 --> 00:20:00,080
every 24 hours and download and stage

00:19:56,880 --> 00:20:00,080
whatever is necessary

00:20:00,799 --> 00:20:04,480
and what we want and yeah actually

00:20:02,880 --> 00:20:04,880
that's exactly what i was describing

00:20:04,480 --> 00:20:06,799
here

00:20:04,880 --> 00:20:09,200
it's a simple conf file that you would

00:20:06,799 --> 00:20:11,520
change you know your update policy can

00:20:09,200 --> 00:20:13,760
be to stage as i was describing

00:20:11,520 --> 00:20:15,120
or it can also be to update as soon as

00:20:13,760 --> 00:20:17,679
there is an update

00:20:15,120 --> 00:20:20,720
you know depending on how you prefer to

00:20:17,679 --> 00:20:22,880
it's just http traffic right

00:20:20,720 --> 00:20:25,360
and the cool thing is as i mentioned you

00:20:22,880 --> 00:20:27,760
can stage those updates at a local

00:20:25,360 --> 00:20:29,840
regional center or even you know if you

00:20:27,760 --> 00:20:35,679
have a rack of edge servers

00:20:29,840 --> 00:20:37,039
you know maybe in that rack

00:20:35,679 --> 00:20:39,200
and you know if you have any questions

00:20:37,039 --> 00:20:42,559
so far please put them in the qa

00:20:39,200 --> 00:20:44,159
i'm moving fairly fast um some of this

00:20:42,559 --> 00:20:48,640
may be new to you all

00:20:44,159 --> 00:20:50,320
so just hit us with questions no problem

00:20:48,640 --> 00:20:52,400
and finally this is the last part of

00:20:50,320 --> 00:20:54,000
what i was describing earlier right

00:20:52,400 --> 00:20:55,520
you know we want to have this image

00:20:54,000 --> 00:20:58,720
based deployable

00:20:55,520 --> 00:21:01,679
uh to our edge devices right we want to

00:20:58,720 --> 00:21:04,799
be able to layer the updates via images

00:21:01,679 --> 00:21:05,360
and we want to boot into that to rob's

00:21:04,799 --> 00:21:07,440
point

00:21:05,360 --> 00:21:08,799
whenever is the proper outage window

00:21:07,440 --> 00:21:10,880
that i have there

00:21:08,799 --> 00:21:12,480
and what i want is i don't want

00:21:10,880 --> 00:21:14,960
uncertainty and risk

00:21:12,480 --> 00:21:17,120
right because if that update fails i

00:21:14,960 --> 00:21:18,960
can't really go to that edge device and

00:21:17,120 --> 00:21:19,919
kind of touch it and kind of fix it

00:21:18,960 --> 00:21:22,559
manually

00:21:19,919 --> 00:21:23,840
right that's completely prohibitive so

00:21:22,559 --> 00:21:26,159
the idea is that

00:21:23,840 --> 00:21:27,600
because i have these atomic images right

00:21:26,159 --> 00:21:30,240
these full images

00:21:27,600 --> 00:21:31,840
what i'm gonna do is boot into that one

00:21:30,240 --> 00:21:33,440
right so here's for example on this

00:21:31,840 --> 00:21:37,280
version of the image

00:21:33,440 --> 00:21:39,200
right and i do the updates by rebooting

00:21:37,280 --> 00:21:40,240
and i boot into that second version of

00:21:39,200 --> 00:21:43,039
the image

00:21:40,240 --> 00:21:44,559
right and then what we do is we do a

00:21:43,039 --> 00:21:47,760
health check right

00:21:44,559 --> 00:21:50,240
there is a you know a arbitrary script

00:21:47,760 --> 00:21:52,080
that can actually test your application

00:21:50,240 --> 00:21:54,960
right not just the health of the

00:21:52,080 --> 00:21:55,360
update process itself but seeing if like

00:21:54,960 --> 00:21:59,039
hey

00:21:55,360 --> 00:22:01,200
after this image was updated is my dns

00:21:59,039 --> 00:22:03,520
server still responding or

00:22:01,200 --> 00:22:05,039
you know whatever is the workload that's

00:22:03,520 --> 00:22:07,440
running on that edge node

00:22:05,039 --> 00:22:08,080
is it still functioning and if it is

00:22:07,440 --> 00:22:10,400
then okay

00:22:08,080 --> 00:22:11,520
then i carry on you know and keep keep

00:22:10,400 --> 00:22:14,000
going that way

00:22:11,520 --> 00:22:14,960
but if not i can trigger an

00:22:14,000 --> 00:22:18,080
automatically

00:22:14,960 --> 00:22:20,559
an automatic um recovery routine

00:22:18,080 --> 00:22:22,320
that brings me back to the previous

00:22:20,559 --> 00:22:24,880
known and trusted image

00:22:22,320 --> 00:22:26,240
so so think of it this way um you know

00:22:24,880 --> 00:22:28,880
on boot up system d

00:22:26,240 --> 00:22:30,159
would run um some check services that

00:22:28,880 --> 00:22:32,640
are kind of grouped together

00:22:30,159 --> 00:22:34,080
under like a health target and if the

00:22:32,640 --> 00:22:36,960
targets reached

00:22:34,080 --> 00:22:38,640
um you know the status basically you

00:22:36,960 --> 00:22:41,440
know success or failure

00:22:38,640 --> 00:22:43,039
would help us determine what to do so if

00:22:41,440 --> 00:22:46,960
we rebooted

00:22:43,039 --> 00:22:50,080
and we had just done an rpm os 3 update

00:22:46,960 --> 00:22:53,520
um and something you know uh

00:22:50,080 --> 00:22:54,000
failed we could have it say you know rpm

00:22:53,520 --> 00:22:55,919
dash show

00:22:54,000 --> 00:22:57,280
us tree roll back on reboot for the

00:22:55,919 --> 00:23:00,720
failure or

00:22:57,280 --> 00:23:02,080
we could say um retry um and see if if

00:23:00,720 --> 00:23:05,039
that fixes it

00:23:02,080 --> 00:23:06,080
in either event the the goal here is to

00:23:05,039 --> 00:23:08,720
make it so that

00:23:06,080 --> 00:23:10,080
um if there's a failure we can put it

00:23:08,720 --> 00:23:12,400
back into a previously

00:23:10,080 --> 00:23:14,480
known good state right and your edge

00:23:12,400 --> 00:23:18,320
device isn't going to be taken offline

00:23:14,480 --> 00:23:18,320
just because of a failure on an update

00:23:18,400 --> 00:23:22,080
well sad so think of it uh like a

00:23:21,520 --> 00:23:24,320
generic

00:23:22,080 --> 00:23:27,520
health check framework for system d i

00:23:24,320 --> 00:23:27,520
think uh that would be

00:23:27,679 --> 00:23:31,679
yep and and that concludes the image and

00:23:30,480 --> 00:23:34,320
update section

00:23:31,679 --> 00:23:35,360
of the presentation so please post any

00:23:34,320 --> 00:23:38,000
questions you have

00:23:35,360 --> 00:23:40,159
uh so far you know again the idea is

00:23:38,000 --> 00:23:40,720
that we're not using a traditional linux

00:23:40,159 --> 00:23:43,760
image

00:23:40,720 --> 00:23:44,640
for this right we're using you know rpm

00:23:43,760 --> 00:23:48,080
os3

00:23:44,640 --> 00:23:51,279
libos3 to create essentially

00:23:48,080 --> 00:23:52,880
a fully deployable appliance right which

00:23:51,279 --> 00:23:55,039
is a file system image

00:23:52,880 --> 00:23:57,520
which is version and layered we can

00:23:55,039 --> 00:23:58,559
create these using a pipeline a git ops

00:23:57,520 --> 00:24:01,200
pipeline

00:23:58,559 --> 00:24:03,200
uh we can update those uh by just you

00:24:01,200 --> 00:24:05,360
know committing code to get

00:24:03,200 --> 00:24:07,039
um and then finally we can distribute

00:24:05,360 --> 00:24:10,640
those and pull them

00:24:07,039 --> 00:24:12,080
update them health check them and etc

00:24:10,640 --> 00:24:13,919
so the idea with this is that we're

00:24:12,080 --> 00:24:15,919
trying to solve the image builds the

00:24:13,919 --> 00:24:17,600
image deployment and the image update

00:24:15,919 --> 00:24:20,640
process

00:24:17,600 --> 00:24:22,799
and again go ahead oh and uh

00:24:20,640 --> 00:24:24,799
and another part there is you know we're

00:24:22,799 --> 00:24:27,360
also trying to optimize

00:24:24,799 --> 00:24:29,520
um the network for these edge devices

00:24:27,360 --> 00:24:32,320
recognizing that many

00:24:29,520 --> 00:24:32,799
many locations have uh network bandwidth

00:24:32,320 --> 00:24:37,120
or

00:24:32,799 --> 00:24:40,159
you know semi are sometimes disconnected

00:24:37,120 --> 00:24:42,720
issues so we're looking at

00:24:40,159 --> 00:24:43,279
you know how can we stage those updates

00:24:42,720 --> 00:24:45,520
can we

00:24:43,279 --> 00:24:47,600
create convenience maintenance windows

00:24:45,520 --> 00:24:49,200
to do those updates can we roll back to

00:24:47,600 --> 00:24:53,200
a prior known image

00:24:49,200 --> 00:24:55,840
you know if a failure happens so um and

00:24:53,200 --> 00:24:58,000
one thing i have to add andre is is that

00:24:55,840 --> 00:24:58,720
we're talking specifically about edge

00:24:58,000 --> 00:25:00,640
here

00:24:58,720 --> 00:25:03,039
with regard to rel but all these

00:25:00,640 --> 00:25:04,880
features also exist with the ability to

00:25:03,039 --> 00:25:08,080
compose images for rel

00:25:04,880 --> 00:25:10,080
not just rel for edge that's true

00:25:08,080 --> 00:25:11,120
that's true and one last comment is that

00:25:10,080 --> 00:25:14,159
again lf

00:25:11,120 --> 00:25:15,919
edge or you know initiative this is not

00:25:14,159 --> 00:25:19,440
the only way to do this

00:25:15,919 --> 00:25:20,640
right there's um complete solutions

00:25:19,440 --> 00:25:23,279
around it by the lf

00:25:20,640 --> 00:25:24,400
organization and initiative umbrella

00:25:23,279 --> 00:25:26,320
this is really a

00:25:24,400 --> 00:25:28,559
learning process that rob and i went

00:25:26,320 --> 00:25:30,480
through right to understand

00:25:28,559 --> 00:25:33,039
the individual components of the ab

00:25:30,480 --> 00:25:35,120
solution

00:25:33,039 --> 00:25:37,279
so let's take a quick run through to

00:25:35,120 --> 00:25:37,840
logging metrics and observability right

00:25:37,279 --> 00:25:40,559
so

00:25:37,840 --> 00:25:41,760
now i got my edge nodes deployed um you

00:25:40,559 --> 00:25:43,919
know how can i know that

00:25:41,760 --> 00:25:45,679
how do i know if they're up you know how

00:25:43,919 --> 00:25:47,200
does you know observability

00:25:45,679 --> 00:25:50,640
measurability

00:25:47,200 --> 00:25:52,720
um these elements come together so

00:25:50,640 --> 00:25:54,640
what you know again this been a learning

00:25:52,720 --> 00:25:56,080
process right so the idea is that we're

00:25:54,640 --> 00:25:58,880
trying to figure out

00:25:56,080 --> 00:25:59,760
uh on the edge device we need to have os

00:25:58,880 --> 00:26:01,840
metrics

00:25:59,760 --> 00:26:04,400
right we need to understand you know how

00:26:01,840 --> 00:26:07,200
my performance is going from an os

00:26:04,400 --> 00:26:08,880
perspective and as um rob was saying

00:26:07,200 --> 00:26:10,880
even things like you know network

00:26:08,880 --> 00:26:12,960
performance bandwidth

00:26:10,880 --> 00:26:14,000
you know how tied up i am for system

00:26:12,960 --> 00:26:15,760
resources

00:26:14,000 --> 00:26:18,320
so that's the first type of metrics that

00:26:15,760 --> 00:26:19,200
we wanted to get but very importantly as

00:26:18,320 --> 00:26:20,880
we're deploying

00:26:19,200 --> 00:26:22,799
these application workloads as

00:26:20,880 --> 00:26:24,720
containers we need to have

00:26:22,799 --> 00:26:26,559
pretty in-depth knowledge about the

00:26:24,720 --> 00:26:28,400
applications themselves

00:26:26,559 --> 00:26:29,679
so the way that we solve this in our

00:26:28,400 --> 00:26:32,240
demo and in our

00:26:29,679 --> 00:26:34,480
in you know test environments has been

00:26:32,240 --> 00:26:37,520
by using performance copilot

00:26:34,480 --> 00:26:38,799
you know pcp for the os metrics and

00:26:37,520 --> 00:26:41,440
we're going to explain why

00:26:38,799 --> 00:26:43,679
we chose that in a second and using

00:26:41,440 --> 00:26:45,360
prometheus to get application level

00:26:43,679 --> 00:26:46,960
metrics

00:26:45,360 --> 00:26:49,360
so basically we're running pcp

00:26:46,960 --> 00:26:51,520
performance copilot as a container

00:26:49,360 --> 00:26:53,520
running the apps as a container the apps

00:26:51,520 --> 00:26:57,600
are instrumented to provide slash

00:26:53,520 --> 00:27:00,960
metrics and uh performance copilot

00:26:57,600 --> 00:27:03,679
is also providing slash metrics os data

00:27:00,960 --> 00:27:04,480
we aggregate one of the challenges that

00:27:03,679 --> 00:27:06,000
we had

00:27:04,480 --> 00:27:07,760
is that this could be a lot of different

00:27:06,000 --> 00:27:09,840
apps a lot of different metrics

00:27:07,760 --> 00:27:12,240
and we don't want prometheus to have a

00:27:09,840 --> 00:27:14,559
ton of endpoints to mind

00:27:12,240 --> 00:27:16,640
per edge device right we wanted to

00:27:14,559 --> 00:27:18,320
present a single edge device

00:27:16,640 --> 00:27:20,640
and that's where performance copilot

00:27:18,320 --> 00:27:21,039
really worked for us we were able to

00:27:20,640 --> 00:27:23,440
kind of

00:27:21,039 --> 00:27:24,880
aggregate all the app data and all the

00:27:23,440 --> 00:27:28,240
os metrics

00:27:24,880 --> 00:27:29,840
as a single prometheus endpoint by using

00:27:28,240 --> 00:27:32,000
performance copilots

00:27:29,840 --> 00:27:34,240
which can expose you know the metrics

00:27:32,000 --> 00:27:37,200
that it gets from all of these locations

00:27:34,240 --> 00:27:39,279
as in openmetrics prometheus slash

00:27:37,200 --> 00:27:42,320
metrics

00:27:39,279 --> 00:27:43,360
so me as a system administrator right as

00:27:42,320 --> 00:27:46,159
an operator

00:27:43,360 --> 00:27:48,640
i can have a custom dashboard in grafana

00:27:46,159 --> 00:27:50,640
running on kubernetes on openshift

00:27:48,640 --> 00:27:52,480
right that's consuming that prometheus

00:27:50,640 --> 00:27:54,720
um time series data

00:27:52,480 --> 00:27:58,559
this can be persisted so i can do

00:27:54,720 --> 00:27:58,559
retroactive analysis as well

00:27:59,120 --> 00:28:02,880
a quick run through performance co-pilot

00:28:01,600 --> 00:28:05,360
for you know we want this

00:28:02,880 --> 00:28:06,960
talk to be accessible to everyone not

00:28:05,360 --> 00:28:08,480
assuming any previous knowledge so

00:28:06,960 --> 00:28:11,760
performance copilot

00:28:08,480 --> 00:28:14,640
is a great way it has these agents

00:28:11,760 --> 00:28:16,320
a ton of different agents right uh and

00:28:14,640 --> 00:28:17,120
the cool thing why we selected it for

00:28:16,320 --> 00:28:19,200
this project

00:28:17,120 --> 00:28:20,559
one is because as i mentioned you could

00:28:19,200 --> 00:28:21,520
aggregate all of these different

00:28:20,559 --> 00:28:23,600
endpoints

00:28:21,520 --> 00:28:24,960
and expose these metrics as prometheus

00:28:23,600 --> 00:28:27,840
time series data

00:28:24,960 --> 00:28:28,480
but also because it's lightweight right

00:28:27,840 --> 00:28:31,440
we've done

00:28:28,480 --> 00:28:33,520
uh tests on very lightweight deployments

00:28:31,440 --> 00:28:37,120
minimum bandwidth

00:28:33,520 --> 00:28:40,159
you know and these agents are fantastic

00:28:37,120 --> 00:28:40,640
they're mostly written in c and they

00:28:40,159 --> 00:28:42,559
give

00:28:40,640 --> 00:28:44,000
great performance for the amount and the

00:28:42,559 --> 00:28:47,039
richness of the data that they

00:28:44,000 --> 00:28:49,360
provide so basically pmcd in our event

00:28:47,039 --> 00:28:51,279
in our example is running as a container

00:28:49,360 --> 00:28:52,080
on the edge device which is here on the

00:28:51,279 --> 00:28:54,399
left

00:28:52,080 --> 00:28:56,080
and then it provides this endpoint in

00:28:54,399 --> 00:28:58,720
our case to prometheus

00:28:56,080 --> 00:29:00,559
but you can also kind of as an as an

00:28:58,720 --> 00:29:04,000
administrator use some of these other

00:29:00,559 --> 00:29:07,919
um tools to chart log and

00:29:04,000 --> 00:29:07,919
manipulate this data in various ways

00:29:09,679 --> 00:29:12,799
and here's a little bit more um this is

00:29:12,240 --> 00:29:14,399
a great

00:29:12,799 --> 00:29:16,000
i just wanted to give a shout out to the

00:29:14,399 --> 00:29:17,200
folks that created the pmda for

00:29:16,000 --> 00:29:18,880
prometheus

00:29:17,200 --> 00:29:21,679
right which allows us essentially to

00:29:18,880 --> 00:29:24,159
pick up a prometheus endpoint metric

00:29:21,679 --> 00:29:25,600
uh from anywhere right from all our

00:29:24,159 --> 00:29:27,679
applications

00:29:25,600 --> 00:29:29,039
very simple config very you know we want

00:29:27,679 --> 00:29:31,600
this to be easy

00:29:29,039 --> 00:29:32,799
to maintain and understand you know as

00:29:31,600 --> 00:29:35,919
newcomers

00:29:32,799 --> 00:29:37,360
to the edge space and this offered all

00:29:35,919 --> 00:29:40,480
of that we can capture

00:29:37,360 --> 00:29:43,840
os metrics application metrics

00:29:40,480 --> 00:29:46,240
um in a single sort of fabric and then

00:29:43,840 --> 00:29:47,919
prometheus is highly scalable right so

00:29:46,240 --> 00:29:49,520
you can have a distributed kind of

00:29:47,919 --> 00:29:50,240
depending on how many edge nodes you

00:29:49,520 --> 00:29:52,640
have

00:29:50,240 --> 00:29:54,080
you can have a federated sort of

00:29:52,640 --> 00:29:56,720
prometheus setup

00:29:54,080 --> 00:29:58,080
or it scales sufficiently well that in

00:29:56,720 --> 00:30:01,440
our test environment

00:29:58,080 --> 00:30:03,760
we have 2500 um edge nodes and

00:30:01,440 --> 00:30:06,880
and it was sufficient to have one

00:30:03,760 --> 00:30:06,880
prometheus endpoint

00:30:07,279 --> 00:30:10,399
so let me uh add on to that for a second

00:30:09,840 --> 00:30:13,120
sure

00:30:10,399 --> 00:30:14,960
so think of it this way you know when we

00:30:13,120 --> 00:30:16,559
push things down to the edge

00:30:14,960 --> 00:30:18,320
what we're really looking for is

00:30:16,559 --> 00:30:20,880
telemetry information from

00:30:18,320 --> 00:30:22,559
the operating system the thing that's

00:30:20,880 --> 00:30:25,200
going to run um either

00:30:22,559 --> 00:30:25,760
a container or the application right so

00:30:25,200 --> 00:30:27,039
in our

00:30:25,760 --> 00:30:29,200
in our instance we're going to talk

00:30:27,039 --> 00:30:30,960
about podman in a in a minute

00:30:29,200 --> 00:30:33,360
um and we're running containers within

00:30:30,960 --> 00:30:34,480
podband and then the actual application

00:30:33,360 --> 00:30:36,559
itself

00:30:34,480 --> 00:30:38,960
all those things would have normally

00:30:36,559 --> 00:30:41,200
have prometheus endpoints and they do

00:30:38,960 --> 00:30:42,480
um so we can have a prometheus exporter

00:30:41,200 --> 00:30:44,640
in our application

00:30:42,480 --> 00:30:46,559
that's running in the container but just

00:30:44,640 --> 00:30:49,760
because the application's up and running

00:30:46,559 --> 00:30:50,880
you know uh um you know if the if the

00:30:49,760 --> 00:30:52,159
container's up and running is the

00:30:50,880 --> 00:30:54,559
application running

00:30:52,159 --> 00:30:56,000
is podman working correctly did we

00:30:54,559 --> 00:30:57,440
reboot what's going on with the

00:30:56,000 --> 00:30:59,039
operating system so we have all these

00:30:57,440 --> 00:31:00,320
prometheus endpoints if we were to

00:30:59,039 --> 00:31:02,000
expose all those

00:31:00,320 --> 00:31:03,519
like you normally would in a kubernetes

00:31:02,000 --> 00:31:05,200
environment

00:31:03,519 --> 00:31:06,799
anybody who's running kubernetes knows

00:31:05,200 --> 00:31:08,799
that you have multiple you know

00:31:06,799 --> 00:31:11,039
multitudes of prometheus endpoints that

00:31:08,799 --> 00:31:12,880
are being scraped

00:31:11,039 --> 00:31:14,159
and collecting telemetry data within

00:31:12,880 --> 00:31:17,360
your cluster

00:31:14,159 --> 00:31:18,960
but from an edge perspective we don't

00:31:17,360 --> 00:31:21,039
necessarily want to

00:31:18,960 --> 00:31:22,480
call in and scrape multiple prometheus

00:31:21,039 --> 00:31:23,760
endpoints from multiple deployed

00:31:22,480 --> 00:31:26,720
applications that are

00:31:23,760 --> 00:31:27,840
running on that edge device so we

00:31:26,720 --> 00:31:30,320
knowing that we have

00:31:27,840 --> 00:31:33,039
all these prometheus endpoints could we

00:31:30,320 --> 00:31:35,039
bundle them all up using pcp

00:31:33,039 --> 00:31:36,880
and expose them to the outside world as

00:31:35,039 --> 00:31:39,039
a single prometheus endpoint

00:31:36,880 --> 00:31:41,200
scrape all that data maybe even limit

00:31:39,039 --> 00:31:44,480
that data so in an example that um

00:31:41,200 --> 00:31:48,080
andre and i um have we cut down

00:31:44,480 --> 00:31:50,320
the data by like 98 percent um

00:31:48,080 --> 00:31:51,440
so what does this mean a prometheus

00:31:50,320 --> 00:31:53,440
endpoint is an hdp

00:31:51,440 --> 00:31:55,200
endpoint that's expensive operation if

00:31:53,440 --> 00:31:57,679
we had multiples of those

00:31:55,200 --> 00:32:00,000
so what we want is um hit the prometheus

00:31:57,679 --> 00:32:02,960
7.1 prometheus endpoint

00:32:00,000 --> 00:32:04,000
scrape that data for that entire stack

00:32:02,960 --> 00:32:05,840
of stuff

00:32:04,000 --> 00:32:07,600
bring back it absolutely what's

00:32:05,840 --> 00:32:08,960
necessary so maybe some of that data is

00:32:07,600 --> 00:32:11,039
going to the noc

00:32:08,960 --> 00:32:13,440
maybe some of that data is going to go

00:32:11,039 --> 00:32:16,799
back and help us make

00:32:13,440 --> 00:32:19,760
uh deterministic um

00:32:16,799 --> 00:32:20,399
uh approaches to how we're going to

00:32:19,760 --> 00:32:22,799
download

00:32:20,399 --> 00:32:24,080
and update maybe the application or

00:32:22,799 --> 00:32:27,200
maybe push the

00:32:24,080 --> 00:32:29,519
application maybe the os update

00:32:27,200 --> 00:32:31,039
from ansible so we're going to use that

00:32:29,519 --> 00:32:32,799
data for different reasons

00:32:31,039 --> 00:32:36,320
so we want to be able to filter that

00:32:32,799 --> 00:32:39,200
data and make it as small as possible

00:32:36,320 --> 00:32:40,960
oftentimes because of network issues and

00:32:39,200 --> 00:32:41,279
we want to limit the network bandwidth

00:32:40,960 --> 00:32:42,720
and

00:32:41,279 --> 00:32:46,080
the amount of data that's going back and

00:32:42,720 --> 00:32:47,840
forth so pcp and what andre is talking

00:32:46,080 --> 00:32:51,279
about with that pmda

00:32:47,840 --> 00:32:54,320
um helping us expose that single um

00:32:51,279 --> 00:32:56,399
you know uh prometheus endpoint

00:32:54,320 --> 00:32:57,600
is an important thing to consider

00:32:56,399 --> 00:32:59,440
depending upon

00:32:57,600 --> 00:33:01,679
how you're viewing the edge is it in the

00:32:59,440 --> 00:33:05,039
data center is it really a remote

00:33:01,679 --> 00:33:06,960
device someplace um do i have network uh

00:33:05,039 --> 00:33:08,799
bandwidth considerations

00:33:06,960 --> 00:33:10,000
um you know so you have to take all that

00:33:08,799 --> 00:33:11,519
into account when

00:33:10,000 --> 00:33:13,039
when looking at these different kinds of

00:33:11,519 --> 00:33:16,240
approaches

00:33:13,039 --> 00:33:17,440
i i think what we're showing here is

00:33:16,240 --> 00:33:20,640
actually all supportable

00:33:17,440 --> 00:33:23,120
right out of the box with rel today

00:33:20,640 --> 00:33:24,080
um so we didn't implement anything that

00:33:23,120 --> 00:33:26,960
wasn't uh

00:33:24,080 --> 00:33:27,200
you know it's all open source but it's

00:33:26,960 --> 00:33:30,640
all

00:33:27,200 --> 00:33:32,399
also supportable yep if you're

00:33:30,640 --> 00:33:33,919
a red hat customer and you have rail in

00:33:32,399 --> 00:33:35,519
your environment you can play with all

00:33:33,919 --> 00:33:37,200
of these elements that we described here

00:33:35,519 --> 00:33:38,640
today

00:33:37,200 --> 00:33:40,240
one last thing i wanted to say this

00:33:38,640 --> 00:33:41,919
before we move on to the next section of

00:33:40,240 --> 00:33:44,159
the presentation is that another reason

00:33:41,919 --> 00:33:44,960
why we chose pcp which is a really cool

00:33:44,159 --> 00:33:47,120
reason

00:33:44,960 --> 00:33:48,880
is that they have this awesome pmda

00:33:47,120 --> 00:33:52,240
unite this performance

00:33:48,880 --> 00:33:55,360
agent collecting agent for bcc

00:33:52,240 --> 00:33:56,799
right which taps into bpf

00:33:55,360 --> 00:33:58,559
needless to say if you're talking

00:33:56,799 --> 00:34:02,080
observability and

00:33:58,559 --> 00:34:04,000
you know in general getting metrics in a

00:34:02,080 --> 00:34:05,519
lightweight and powerful metrics that

00:34:04,000 --> 00:34:07,919
you couldn't get before

00:34:05,519 --> 00:34:09,200
bpf is making you know a huge impact in

00:34:07,919 --> 00:34:10,960
the industry

00:34:09,200 --> 00:34:12,639
and you know when we're talking about

00:34:10,960 --> 00:34:15,280
collecting os metrics

00:34:12,639 --> 00:34:16,320
we can even collect bpf metrics through

00:34:15,280 --> 00:34:20,000
bpc

00:34:16,320 --> 00:34:23,919
through bcc and into p into the pc

00:34:20,000 --> 00:34:26,639
pcp mda so this is another great reason

00:34:23,919 --> 00:34:27,359
and um um rob was mentioning the

00:34:26,639 --> 00:34:30,159
performance

00:34:27,359 --> 00:34:31,839
uh inference engine this is another

00:34:30,159 --> 00:34:34,320
thing that's really really cool

00:34:31,839 --> 00:34:34,879
uh the the performance co-pilot project

00:34:34,320 --> 00:34:38,480
has this

00:34:34,879 --> 00:34:41,440
um sub feature called uh

00:34:38,480 --> 00:34:41,839
the inference engine which can you know

00:34:41,440 --> 00:34:43,839
make

00:34:41,839 --> 00:34:45,599
intelligence you know can make choices

00:34:43,839 --> 00:34:48,560
and trigger actions

00:34:45,599 --> 00:34:51,359
depending on certain thresholds and etc

00:34:48,560 --> 00:34:54,000
or even complex conditions of metrics

00:34:51,359 --> 00:34:56,879
so you could potentially trigger a

00:34:54,000 --> 00:35:00,160
podman run to redownload a container or

00:34:56,879 --> 00:35:00,720
an ansible run to you know fire off an

00:35:00,160 --> 00:35:03,839
alert

00:35:00,720 --> 00:35:03,839
or something like that

00:35:04,079 --> 00:35:07,680
this summarizes a little bit everything

00:35:05,760 --> 00:35:10,320
that we talked about the scalable

00:35:07,680 --> 00:35:12,320
back-end services in kubernetes

00:35:10,320 --> 00:35:16,000
picking up data as a single endpoint

00:35:12,320 --> 00:35:19,200
from each one of the edge devices

00:35:16,000 --> 00:35:21,520
and we chose these um you know

00:35:19,200 --> 00:35:23,040
chose the stack because it's simple

00:35:21,520 --> 00:35:24,960
because it ships in a row

00:35:23,040 --> 00:35:26,079
it's widely available everybody

00:35:24,960 --> 00:35:28,079
understands it

00:35:26,079 --> 00:35:29,200
you know again the idea of skills and

00:35:28,079 --> 00:35:32,800
keeping your skill set

00:35:29,200 --> 00:35:34,400
simple so now let's turn over our

00:35:32,800 --> 00:35:35,760
attention really quickly to the last

00:35:34,400 --> 00:35:37,440
part of the presentation

00:35:35,760 --> 00:35:39,040
we talked about image management and

00:35:37,440 --> 00:35:42,480
updates we talked about

00:35:39,040 --> 00:35:44,079
observability and sort of measurability

00:35:42,480 --> 00:35:46,720
and now let's take a look at application

00:35:44,079 --> 00:35:46,720
management

00:35:47,680 --> 00:35:51,839
so with podman um really we need a way

00:35:51,280 --> 00:35:53,119
to run

00:35:51,839 --> 00:35:55,440
applications that we're actually

00:35:53,119 --> 00:35:59,680
delivering down to the edge

00:35:55,440 --> 00:36:02,960
um now at red hat you know we use podman

00:35:59,680 --> 00:36:05,599
uh so i know many people are probably um

00:36:02,960 --> 00:36:07,280
uh you know used to consuming docker

00:36:05,599 --> 00:36:10,400
think of podman

00:36:07,280 --> 00:36:13,760
um it's you know it's an oci compliant

00:36:10,400 --> 00:36:15,359
um container engine you know think of it

00:36:13,760 --> 00:36:17,760
that way

00:36:15,359 --> 00:36:20,800
it's very it's highly compatible if not

00:36:17,760 --> 00:36:23,040
fully compatible with a docker api

00:36:20,800 --> 00:36:24,640
but there's some major differences so

00:36:23,040 --> 00:36:26,720
docker runs

00:36:24,640 --> 00:36:28,000
kind of in a client server architecture

00:36:26,720 --> 00:36:30,880
and podman runs

00:36:28,000 --> 00:36:32,960
in a daemon-less architecture um so when

00:36:30,880 --> 00:36:34,000
working with docker we have to consume

00:36:32,960 --> 00:36:35,520
the cli

00:36:34,000 --> 00:36:37,040
that communicates with the back end

00:36:35,520 --> 00:36:39,280
daemon um

00:36:37,040 --> 00:36:40,160
the main logic actually resides in the

00:36:39,280 --> 00:36:43,280
daemon

00:36:40,160 --> 00:36:46,320
under docker and that builds images

00:36:43,280 --> 00:36:48,720
executes containers and that requires

00:36:46,320 --> 00:36:51,599
that the daemon have root privileges

00:36:48,720 --> 00:36:52,240
podman architecture really allows us to

00:36:51,599 --> 00:36:54,320
run

00:36:52,240 --> 00:36:56,000
containers under the user that started

00:36:54,320 --> 00:36:57,200
the container so when you think of like

00:36:56,000 --> 00:36:59,920
a fork exec

00:36:57,200 --> 00:37:00,880
and that that user does not need to have

00:36:59,920 --> 00:37:02,720
root privileges

00:37:00,880 --> 00:37:04,240
so i can run rootless containers the

00:37:02,720 --> 00:37:08,320
other advantage here

00:37:04,240 --> 00:37:09,920
is is that um basically no user can see

00:37:08,320 --> 00:37:12,640
any other users

00:37:09,920 --> 00:37:13,119
um running container images right so

00:37:12,640 --> 00:37:16,560
because

00:37:13,119 --> 00:37:20,240
i'm i'm running in that demon in that

00:37:16,560 --> 00:37:24,400
rootless condition so because pilot man

00:37:20,240 --> 00:37:25,839
is uh damon-less each user

00:37:24,400 --> 00:37:29,280
can only see and modify their own

00:37:25,839 --> 00:37:31,119
containers think of it that way

00:37:29,280 --> 00:37:33,119
and there's no common daemon you know

00:37:31,119 --> 00:37:37,599
for the cli tool to really

00:37:33,119 --> 00:37:40,640
you know talk to so think of it that way

00:37:37,599 --> 00:37:44,400
when you have we have additional tooling

00:37:40,640 --> 00:37:46,800
built around that so if i want to um

00:37:44,400 --> 00:37:48,079
unlike docker if i want to have more

00:37:46,800 --> 00:37:52,320
fine grained control

00:37:48,079 --> 00:37:54,720
over how i layer container images

00:37:52,320 --> 00:37:56,480
i would also add that we use a tool

00:37:54,720 --> 00:38:00,240
called buildup

00:37:56,480 --> 00:38:02,400
yes it has a dan walsh is the

00:38:00,240 --> 00:38:03,920
person here at red hat who helped create

00:38:02,400 --> 00:38:05,440
these projects and he's from boston so

00:38:03,920 --> 00:38:07,920
we put an ah on a lot of

00:38:05,440 --> 00:38:10,079
uh at the end of a lot of these words so

00:38:07,920 --> 00:38:11,839
um i have to call out that you know dan

00:38:10,079 --> 00:38:14,320
is really responsible for a lot of this

00:38:11,839 --> 00:38:16,880
and um has done a fantastic job

00:38:14,320 --> 00:38:18,720
you know with podman and helping us

00:38:16,880 --> 00:38:21,359
create these tools

00:38:18,720 --> 00:38:23,520
scopio so how could i move an image

00:38:21,359 --> 00:38:25,920
securely from one registry to another

00:38:23,520 --> 00:38:29,119
registry so scopio is another

00:38:25,920 --> 00:38:29,119
another tool that we use

00:38:30,000 --> 00:38:34,079
this is yeah go ahead andre if you want

00:38:33,119 --> 00:38:36,160
to talk about it

00:38:34,079 --> 00:38:37,440
no no you you get started i'll add some

00:38:36,160 --> 00:38:40,240
color so

00:38:37,440 --> 00:38:41,119
um think of it as um you know we want to

00:38:40,240 --> 00:38:43,440
look for

00:38:41,119 --> 00:38:44,240
uh whether or not we have an update

00:38:43,440 --> 00:38:46,560
label

00:38:44,240 --> 00:38:48,320
and can we actually pull uh create a

00:38:46,560 --> 00:38:50,720
policy that actually pulls

00:38:48,320 --> 00:38:52,560
and does an update um of an image and

00:38:50,720 --> 00:38:55,599
runs it within podman

00:38:52,560 --> 00:38:56,960
so um this is a little um different than

00:38:55,599 --> 00:38:57,920
maybe what you're used to working with

00:38:56,960 --> 00:39:00,320
in docker but

00:38:57,920 --> 00:39:01,119
it adds um a lot of capability if we

00:39:00,320 --> 00:39:04,560
want to keep things

00:39:01,119 --> 00:39:06,880
up to date yeah it's similar to that

00:39:04,560 --> 00:39:09,040
idea that we had for the image the os

00:39:06,880 --> 00:39:10,640
image itself right the idea is that we

00:39:09,040 --> 00:39:13,040
only have these layers

00:39:10,640 --> 00:39:14,800
and they get pulled down um you know in

00:39:13,040 --> 00:39:16,960
an automated fashion

00:39:14,800 --> 00:39:17,839
you know rather than pushed to the edge

00:39:16,960 --> 00:39:19,920
device

00:39:17,839 --> 00:39:20,880
the same idea here right this is sort of

00:39:19,920 --> 00:39:23,680
like

00:39:20,880 --> 00:39:25,119
you know uh sort of as autonomous as

00:39:23,680 --> 00:39:28,400
possible right where

00:39:25,119 --> 00:39:30,000
we have the up os continually updated

00:39:28,400 --> 00:39:32,000
but we also have the application

00:39:30,000 --> 00:39:33,839
workload continually updated

00:39:32,000 --> 00:39:35,760
right podman is checking you know

00:39:33,839 --> 00:39:37,200
nightly to make sure you know at the

00:39:35,760 --> 00:39:38,960
local registry

00:39:37,200 --> 00:39:41,119
as rob mentioned we have the tools to

00:39:38,960 --> 00:39:42,960
kind of main to manage the distribution

00:39:41,119 --> 00:39:46,079
of those images to those

00:39:42,960 --> 00:39:48,079
you know regional registries and then um

00:39:46,079 --> 00:39:50,560
you know automatically update itself

00:39:48,079 --> 00:39:52,800
based on policy as new versions of the

00:39:50,560 --> 00:39:55,520
workload get deployed

00:39:52,800 --> 00:39:56,960
so uh you'll notice that we have we say

00:39:55,520 --> 00:40:00,079
you know as a system d

00:39:56,960 --> 00:40:02,720
unit here because podman is daemon-less

00:40:00,079 --> 00:40:04,720
we can communicate with systemd and the

00:40:02,720 --> 00:40:06,000
combination of system d and podman can

00:40:04,720 --> 00:40:07,760
make sure that our application is

00:40:06,000 --> 00:40:11,280
continually up and running

00:40:07,760 --> 00:40:12,160
in a lot of scenarios um we're building

00:40:11,280 --> 00:40:14,400
the images

00:40:12,160 --> 00:40:15,920
on a kubernetes platform and we're doing

00:40:14,400 --> 00:40:17,040
all our great development in a paths

00:40:15,920 --> 00:40:19,599
environment

00:40:17,040 --> 00:40:20,160
in some cases we're looking at you know

00:40:19,599 --> 00:40:23,359
putting

00:40:20,160 --> 00:40:24,720
kubernetes at the edge but that requires

00:40:23,359 --> 00:40:27,040
a lot of resources

00:40:24,720 --> 00:40:28,240
versus some of the um solutions that

00:40:27,040 --> 00:40:31,040
we're looking at

00:40:28,240 --> 00:40:32,960
uh require you know a lot less resources

00:40:31,040 --> 00:40:36,640
we have you know eight gigs of ram

00:40:32,960 --> 00:40:38,480
is a high end and you know two um

00:40:36,640 --> 00:40:40,160
two core processor we have to run a

00:40:38,480 --> 00:40:42,079
bunch of applications

00:40:40,160 --> 00:40:43,520
um so what do we really wanna do we

00:40:42,079 --> 00:40:45,599
wanna run the application

00:40:43,520 --> 00:40:47,280
we don't need to schedule the

00:40:45,599 --> 00:40:50,720
application we don't need to

00:40:47,280 --> 00:40:52,400
move it from host uh to host we don't

00:40:50,720 --> 00:40:54,240
need to

00:40:52,400 --> 00:40:56,400
do a bunch of things that kubernetes

00:40:54,240 --> 00:40:59,119
necessarily

00:40:56,400 --> 00:40:59,680
provides but we still want the advantage

00:40:59,119 --> 00:41:02,720
of running

00:40:59,680 --> 00:41:04,720
applications in containers so

00:41:02,720 --> 00:41:06,240
the from the development aspect all the

00:41:04,720 --> 00:41:07,839
way down to the deployment

00:41:06,240 --> 00:41:11,280
and using the registry and everything

00:41:07,839 --> 00:41:13,359
else so podman fits a really cool niche

00:41:11,280 --> 00:41:15,200
because we can run it as a pod

00:41:13,359 --> 00:41:17,760
and run that container in a pod and do

00:41:15,200 --> 00:41:21,200
some of those cool design patterns

00:41:17,760 --> 00:41:22,880
but really for many edge applications

00:41:21,200 --> 00:41:24,480
the application just needs to be up and

00:41:22,880 --> 00:41:25,440
running and if it fails it needs to

00:41:24,480 --> 00:41:28,400
restart and so

00:41:25,440 --> 00:41:30,640
system d in combination with podman is a

00:41:28,400 --> 00:41:34,800
perfect fit for that

00:41:30,640 --> 00:41:37,040
well said and of course

00:41:34,800 --> 00:41:38,560
where do these images come from so a lot

00:41:37,040 --> 00:41:40,160
of times people start off

00:41:38,560 --> 00:41:42,079
with their container development and

00:41:40,160 --> 00:41:42,960
they might go to docker hub and i'm not

00:41:42,079 --> 00:41:46,079
saying anything

00:41:42,960 --> 00:41:47,440
uh negative about anybody's um you know

00:41:46,079 --> 00:41:48,240
where they're storing the images but

00:41:47,440 --> 00:41:50,720
what you want

00:41:48,240 --> 00:41:52,640
is something that you uh a trusted

00:41:50,720 --> 00:41:55,119
source for your images

00:41:52,640 --> 00:41:56,319
right so whether you're if you try to

00:41:55,119 --> 00:41:58,240
create your own images you know that

00:41:56,319 --> 00:42:01,520
that's a complex task

00:41:58,240 --> 00:42:03,760
so creating a base image so um

00:42:01,520 --> 00:42:05,599
what we provide is a universal base

00:42:03,760 --> 00:42:07,680
image that you can start from

00:42:05,599 --> 00:42:10,560
uh think of it as like small medium and

00:42:07,680 --> 00:42:13,920
large you know does it require system d

00:42:10,560 --> 00:42:16,560
should it use um you know uh um

00:42:13,920 --> 00:42:18,880
is there uh you know an rpm update you

00:42:16,560 --> 00:42:21,440
know like dnf kind of capability in it

00:42:18,880 --> 00:42:23,520
how fat do you want that base image can

00:42:21,440 --> 00:42:26,720
we start off with something that is

00:42:23,520 --> 00:42:27,920
um securely securely created scanned

00:42:26,720 --> 00:42:30,480
regularly

00:42:27,920 --> 00:42:32,400
um if there is an update to that image

00:42:30,480 --> 00:42:34,319
can we pull the update to that image and

00:42:32,400 --> 00:42:34,640
have it update all of our images you

00:42:34,319 --> 00:42:37,760
know

00:42:34,640 --> 00:42:38,319
um from the base image um and so what

00:42:37,760 --> 00:42:40,720
red hat

00:42:38,319 --> 00:42:42,880
has created is what's called a ubi or

00:42:40,720 --> 00:42:46,160
universal base image

00:42:42,880 --> 00:42:49,480
um and these are if you go to um

00:42:46,160 --> 00:42:52,640
uh the catalog.redhat.com or um

00:42:49,480 --> 00:42:55,440
registry.red hat dot io what you'll find

00:42:52,640 --> 00:42:57,280
is if you do a search there on ubi um

00:42:55,440 --> 00:42:59,760
you'll find a number of different kinds

00:42:57,280 --> 00:43:01,599
of base images that you can choose from

00:42:59,760 --> 00:43:03,599
you can use these whether or not you're

00:43:01,599 --> 00:43:05,680
a red hat customer or not

00:43:03,599 --> 00:43:07,280
you'll get support if you're you know

00:43:05,680 --> 00:43:10,000
obviously a red hat customer

00:43:07,280 --> 00:43:11,119
but i would encourage you to be very

00:43:10,000 --> 00:43:12,720
careful with

00:43:11,119 --> 00:43:14,400
how you're choosing your base images

00:43:12,720 --> 00:43:16,720
many of them are unsecured

00:43:14,400 --> 00:43:19,599
they have root access if you're running

00:43:16,720 --> 00:43:21,680
them in docker you could get

00:43:19,599 --> 00:43:22,640
contamination from one container to

00:43:21,680 --> 00:43:24,839
another

00:43:22,640 --> 00:43:26,240
maybe exposing yourself to security

00:43:24,839 --> 00:43:29,280
issues um

00:43:26,240 --> 00:43:30,640
definitely look at your container image

00:43:29,280 --> 00:43:32,880
pipeline

00:43:30,640 --> 00:43:34,160
and how are you scanning that and adding

00:43:32,880 --> 00:43:35,920
to those images when you add the

00:43:34,160 --> 00:43:36,319
applications to those images and layer

00:43:35,920 --> 00:43:38,800
things

00:43:36,319 --> 00:43:40,640
in always start with something from a

00:43:38,800 --> 00:43:42,880
known trusted source

00:43:40,640 --> 00:43:45,680
whether that's from red hat or some

00:43:42,880 --> 00:43:47,119
other source or you created it yourself

00:43:45,680 --> 00:43:48,880
yep as we're deploying these

00:43:47,119 --> 00:43:52,480
applications to podman

00:43:48,880 --> 00:43:55,520
at the edge have a really good secure

00:43:52,480 --> 00:43:56,880
trusted universal base image right so

00:43:55,520 --> 00:43:58,319
you don't end up with like a very

00:43:56,880 --> 00:44:00,319
heterogeneous

00:43:58,319 --> 00:44:01,599
environment right a lot of what we're

00:44:00,319 --> 00:44:04,079
trying to do at the edge

00:44:01,599 --> 00:44:04,640
is have things look and be the same

00:44:04,079 --> 00:44:06,160
right

00:44:04,640 --> 00:44:07,839
we're creating this image based

00:44:06,160 --> 00:44:09,680
deployment so ever

00:44:07,839 --> 00:44:11,119
you know all the devices are at the same

00:44:09,680 --> 00:44:13,599
level at the os

00:44:11,119 --> 00:44:15,280
we're creating podman across the board

00:44:13,599 --> 00:44:16,560
now we're deploying these applications

00:44:15,280 --> 00:44:17,440
we don't want to have all of these

00:44:16,560 --> 00:44:20,880
different

00:44:17,440 --> 00:44:24,000
um you know versions of versions and

00:44:20,880 --> 00:44:26,560
in releases of packages right

00:44:24,000 --> 00:44:28,480
so whether or not your red hat customer

00:44:26,560 --> 00:44:30,960
universal base image

00:44:28,480 --> 00:44:31,760
runs everywhere use it it's a good way

00:44:30,960 --> 00:44:34,400
to start and

00:44:31,760 --> 00:44:35,760
standardize across your edge deployment

00:44:34,400 --> 00:44:38,560
um one last thing there

00:44:35,760 --> 00:44:39,760
is if if you've used uh red hat images

00:44:38,560 --> 00:44:42,640
in the past

00:44:39,760 --> 00:44:44,480
um they used to require a uh you know uh

00:44:42,640 --> 00:44:44,880
subscription manager on the underlying

00:44:44,480 --> 00:44:48,319
node

00:44:44,880 --> 00:44:51,599
in order for you to to use them um so

00:44:48,319 --> 00:44:54,240
uh universal base image or the ubi 8

00:44:51,599 --> 00:44:57,359
images don't require that

00:44:54,240 --> 00:45:00,079
so um i would suggest you know go

00:44:57,359 --> 00:45:01,520
give it a try give it a look if you

00:45:00,079 --> 00:45:02,960
already have docker files and you're

00:45:01,520 --> 00:45:04,000
pulling the image from some place and

00:45:02,960 --> 00:45:07,200
you see that there's

00:45:04,000 --> 00:45:07,599
a a ubi image experiment with it pull it

00:45:07,200 --> 00:45:09,200
down

00:45:07,599 --> 00:45:10,960
you know you'll probably see that

00:45:09,200 --> 00:45:12,319
there's different kinds minimal

00:45:10,960 --> 00:45:14,000
footprint

00:45:12,319 --> 00:45:16,400
larger footprint depending on the needs

00:45:14,000 --> 00:45:18,720
that you have

00:45:16,400 --> 00:45:19,680
that brings us essentially to the end i

00:45:18,720 --> 00:45:21,599
hope you've been

00:45:19,680 --> 00:45:23,280
posting questions to the chat we're

00:45:21,599 --> 00:45:25,599
going to have a little bit of time for q

00:45:23,280 --> 00:45:27,200
a uh but before we go we wanted to leave

00:45:25,599 --> 00:45:30,079
you to a couple of things

00:45:27,200 --> 00:45:32,000
lf edge i'm going to say one more time

00:45:30,079 --> 00:45:33,119
incredible work that's being done by the

00:45:32,000 --> 00:45:35,040
community

00:45:33,119 --> 00:45:38,160
sponsored by the linux foundation and an

00:45:35,040 --> 00:45:40,160
umbrella of incredibly smart people

00:45:38,160 --> 00:45:43,040
you know again our presentation really

00:45:40,160 --> 00:45:45,040
was our learning process as individuals

00:45:43,040 --> 00:45:47,359
and looking at the building blocks of an

00:45:45,040 --> 00:45:50,000
edge solution in terms of image

00:45:47,359 --> 00:45:50,720
container and etc what these folks have

00:45:50,000 --> 00:45:53,680
done

00:45:50,720 --> 00:45:55,359
is bring very complex and mature and

00:45:53,680 --> 00:45:57,599
very powerful solutions

00:45:55,359 --> 00:45:59,359
for a number of different dimensions of

00:45:57,599 --> 00:46:02,160
the edge

00:45:59,359 --> 00:46:04,720
challenge so please go there and check

00:46:02,160 --> 00:46:04,720
this out

00:46:05,280 --> 00:46:08,640
and a few more resources rob you want to

00:46:07,280 --> 00:46:09,520
take us through these resources really

00:46:08,640 --> 00:46:13,200
quickly

00:46:09,520 --> 00:46:14,640
sure i think um so ben brillard who's

00:46:13,200 --> 00:46:15,200
listed there is the first these are all

00:46:14,640 --> 00:46:17,920
videos

00:46:15,200 --> 00:46:20,000
on youtube already existing um ben

00:46:17,920 --> 00:46:21,599
brillard we work with regularly with uh

00:46:20,000 --> 00:46:24,640
the rel edge team

00:46:21,599 --> 00:46:25,359
um in addition to that there's really

00:46:24,640 --> 00:46:28,880
these seven

00:46:25,359 --> 00:46:30,640
great um videos that are here uh

00:46:28,880 --> 00:46:32,319
walking you through specifically how to

00:46:30,640 --> 00:46:34,480
create um images

00:46:32,319 --> 00:46:35,760
install the images and then deploy them

00:46:34,480 --> 00:46:37,200
doing all the things that we talked

00:46:35,760 --> 00:46:39,280
about today

00:46:37,200 --> 00:46:41,280
so um each one of these videos is

00:46:39,280 --> 00:46:43,440
probably less than 15 minutes

00:46:41,280 --> 00:46:44,720
on the material is really good i i would

00:46:43,440 --> 00:46:46,240
suggest uh you know

00:46:44,720 --> 00:46:47,839
starting there and you could do that

00:46:46,240 --> 00:46:51,119
with you know uh

00:46:47,839 --> 00:46:52,319
in a vm on your own machine and get

00:46:51,119 --> 00:46:54,480
started today

00:46:52,319 --> 00:46:55,359
that's true whether or not you're a red

00:46:54,480 --> 00:46:57,680
hat customer

00:46:55,359 --> 00:46:59,920
you know you have like a redhead account

00:46:57,680 --> 00:47:00,480
as a you can get a red hat developer

00:46:59,920 --> 00:47:03,520
account

00:47:00,480 --> 00:47:05,280
you know which is free and essentially

00:47:03,520 --> 00:47:06,880
build everything that we just talked

00:47:05,280 --> 00:47:10,079
about and some of these videos are going

00:47:06,880 --> 00:47:12,640
to walk through that process

00:47:10,079 --> 00:47:13,839
um i think we have one question in qa

00:47:12,640 --> 00:47:16,319
let me see

00:47:13,839 --> 00:47:19,200
three questions in qa you said it will

00:47:16,319 --> 00:47:21,119
boot into pixie and update

00:47:19,200 --> 00:47:23,200
what will it boot into what server

00:47:21,119 --> 00:47:24,960
configuration is required for this

00:47:23,200 --> 00:47:26,880
what edge node preparation is required

00:47:24,960 --> 00:47:28,319
that it gets into pixel versus the

00:47:26,880 --> 00:47:30,559
installed os

00:47:28,319 --> 00:47:31,599
great question so it's really really

00:47:30,559 --> 00:47:33,760
simple right

00:47:31,599 --> 00:47:35,599
imagine this right we talked about

00:47:33,760 --> 00:47:36,400
earlier that these are ad servers that

00:47:35,599 --> 00:47:38,880
are going

00:47:36,400 --> 00:47:40,480
into a small closet somewhere in a

00:47:38,880 --> 00:47:44,000
manufacturing facility

00:47:40,480 --> 00:47:44,720
right uh i'm basically i have a new

00:47:44,000 --> 00:47:46,800
factory

00:47:44,720 --> 00:47:48,880
that i want to enable with this solution

00:47:46,800 --> 00:47:51,440
right so basically i have

00:47:48,880 --> 00:47:52,400
let's say you know a couple of devices

00:47:51,440 --> 00:47:55,040
right that are

00:47:52,400 --> 00:47:55,599
you know pre-configured for me all i

00:47:55,040 --> 00:47:59,280
would do

00:47:55,599 --> 00:48:00,880
is on the bios of that uh device

00:47:59,280 --> 00:48:02,640
right that physical device that i'm

00:48:00,880 --> 00:48:05,760
delivering to the factory

00:48:02,640 --> 00:48:08,240
i would set it to boots in the bios not

00:48:05,760 --> 00:48:11,680
to the hard disk

00:48:08,240 --> 00:48:14,319
babutu pixie boots right and then

00:48:11,680 --> 00:48:14,720
within that you know environment i have

00:48:14,319 --> 00:48:17,839
a

00:48:14,720 --> 00:48:18,079
dhcp server that's pointing me to you

00:48:17,839 --> 00:48:21,280
know

00:48:18,079 --> 00:48:23,119
within that network right that that i'm

00:48:21,280 --> 00:48:23,839
part of that this device is plugging

00:48:23,119 --> 00:48:26,160
into

00:48:23,839 --> 00:48:27,680
there's a dhcp server that has a boot

00:48:26,160 --> 00:48:30,720
server record

00:48:27,680 --> 00:48:34,400
right that points me to essentially

00:48:30,720 --> 00:48:37,200
that pixie boot uh path right then

00:48:34,400 --> 00:48:37,920
in that it downloads automatically the

00:48:37,200 --> 00:48:41,440
um

00:48:37,920 --> 00:48:43,760
kickstart right from my http location

00:48:41,440 --> 00:48:46,319
that kickstart points to where the image

00:48:43,760 --> 00:48:47,200
is the image gets downloaded and laid

00:48:46,319 --> 00:48:50,559
down

00:48:47,200 --> 00:48:52,240
on the operating system and um you know

00:48:50,559 --> 00:48:54,720
there you go so it's all intense and

00:48:52,240 --> 00:48:57,280
purpose uh what you know one

00:48:54,720 --> 00:48:57,920
one thing to add there um andre is is

00:48:57,280 --> 00:49:01,440
that

00:48:57,920 --> 00:49:03,280
the initial image may be larger

00:49:01,440 --> 00:49:05,760
but the subsequent images if you're

00:49:03,280 --> 00:49:08,559
using rpm os tree are actually deltas

00:49:05,760 --> 00:49:10,000
so they're they're much smaller um than

00:49:08,559 --> 00:49:11,839
you know when you're doing traditional

00:49:10,000 --> 00:49:14,000
rpm updates

00:49:11,839 --> 00:49:15,839
that's right and in your pc boot

00:49:14,000 --> 00:49:16,480
configuration too what you can do is

00:49:15,839 --> 00:49:20,000
that

00:49:16,480 --> 00:49:21,680
you know uh the first time that you boot

00:49:20,000 --> 00:49:23,680
the server this is an important part

00:49:21,680 --> 00:49:26,800
that i i would be remiss to mention

00:49:23,680 --> 00:49:29,040
to the person that asked you know my

00:49:26,800 --> 00:49:31,119
network server my dhcp server is

00:49:29,040 --> 00:49:33,280
pointing at my pixie boot server

00:49:31,119 --> 00:49:35,119
right my pixie boot server gives me the

00:49:33,280 --> 00:49:37,680
kick starts and gives me the image

00:49:35,119 --> 00:49:38,319
i boot into it it gets installed into

00:49:37,680 --> 00:49:41,200
the uh

00:49:38,319 --> 00:49:41,760
into the hard disk right of my device

00:49:41,200 --> 00:49:44,480
and then

00:49:41,760 --> 00:49:45,119
i boot into that right then what i do in

00:49:44,480 --> 00:49:48,079
my

00:49:45,119 --> 00:49:49,440
my pixie boot server is that once i boot

00:49:48,079 --> 00:49:51,119
it once

00:49:49,440 --> 00:49:52,640
now the next time it's going to tell me

00:49:51,119 --> 00:49:55,040
to boot for my hard disk

00:49:52,640 --> 00:49:56,720
not from pixi uh this is something that

00:49:55,040 --> 00:49:58,160
red hat supports out of the box in our

00:49:56,720 --> 00:50:00,880
pixie boot server

00:49:58,160 --> 00:50:02,240
uh and then the next time that i boot

00:50:00,880 --> 00:50:06,000
i'm gonna build into my

00:50:02,240 --> 00:50:07,680
my uh up my hard disk and as rob said

00:50:06,000 --> 00:50:09,839
i can get the new version of the image

00:50:07,680 --> 00:50:11,599
if there's one and boot there

00:50:09,839 --> 00:50:12,960
so the business value of that to the

00:50:11,599 --> 00:50:15,119
person that asked the question

00:50:12,960 --> 00:50:16,800
into everybody else this is a really

00:50:15,119 --> 00:50:19,359
cool part of the solution right

00:50:16,800 --> 00:50:21,200
is that i really don't have to do

00:50:19,359 --> 00:50:21,760
anything to these physical devices

00:50:21,200 --> 00:50:24,960
before

00:50:21,760 --> 00:50:27,280
i deploy them to the edge site right

00:50:24,960 --> 00:50:28,480
literally nothing just when i buy those

00:50:27,280 --> 00:50:31,920
devices from

00:50:28,480 --> 00:50:34,800
dell from hp or from mic you know from

00:50:31,920 --> 00:50:37,200
wherever right all i just ask when that

00:50:34,800 --> 00:50:38,960
you know by my oem is that you know the

00:50:37,200 --> 00:50:41,599
bios be configured

00:50:38,960 --> 00:50:42,640
to boot from you know the network on my

00:50:41,599 --> 00:50:45,839
first time

00:50:42,640 --> 00:50:47,440
you know and and then on my network for

00:50:45,839 --> 00:50:50,400
that location where i'm deploying that

00:50:47,440 --> 00:50:53,520
physical device i configure the hcp

00:50:50,400 --> 00:50:55,680
to point to a pixie boot server you know

00:50:53,520 --> 00:50:57,200
that's really all it is you know so all

00:50:55,680 --> 00:50:58,800
the configuration just happens at the

00:50:57,200 --> 00:51:00,559
network for that area

00:50:58,800 --> 00:51:02,000
and there's nothing special that i need

00:51:00,559 --> 00:51:05,200
to boot i can bring

00:51:02,000 --> 00:51:07,200
one device two devices and importantly

00:51:05,200 --> 00:51:09,599
from a skill standpoint

00:51:07,200 --> 00:51:10,720
the person that's deploying these edge

00:51:09,599 --> 00:51:13,200
devices

00:51:10,720 --> 00:51:14,480
doesn't have to do anything about linux

00:51:13,200 --> 00:51:17,839
right doesn't have to be

00:51:14,480 --> 00:51:20,000
a deeply skilled uh engineered

00:51:17,839 --> 00:51:21,839
engineer right they're just literally

00:51:20,000 --> 00:51:23,839
putting that box there plugging into the

00:51:21,839 --> 00:51:25,920
network and booting

00:51:23,839 --> 00:51:27,760
and every other aspect of what we said

00:51:25,920 --> 00:51:28,800
is more or less like this right these

00:51:27,760 --> 00:51:31,839
images are

00:51:28,800 --> 00:51:34,079
you know updated in an automatic fashion

00:51:31,839 --> 00:51:34,960
uh podman and the container image are

00:51:34,079 --> 00:51:38,000
getting

00:51:34,960 --> 00:51:39,440
updated in an automatic fashion so from

00:51:38,000 --> 00:51:42,400
the day one

00:51:39,440 --> 00:51:44,240
when i i'm first deploying that you know

00:51:42,400 --> 00:51:47,680
edge server to my factory

00:51:44,240 --> 00:51:49,680
in my example to forever

00:51:47,680 --> 00:51:50,800
i i never really have to touch it you

00:51:49,680 --> 00:51:52,800
know what i mean unless something

00:51:50,800 --> 00:51:55,760
disastrous goes wrong

00:51:52,800 --> 00:51:57,200
with my you know hardware uh but in that

00:51:55,760 --> 00:51:58,079
case i would just take a new piece of

00:51:57,200 --> 00:52:04,160
hardware

00:51:58,079 --> 00:52:05,920
and plug in where that other one was uh

00:52:04,160 --> 00:52:07,760
let me see if we have more questions can

00:52:05,920 --> 00:52:10,319
you post it on the chat window

00:52:07,760 --> 00:52:12,400
i i just responded there andre that um

00:52:10,319 --> 00:52:15,599
everyone will get a pdf of the prezo

00:52:12,400 --> 00:52:15,599
and that has the links in it

00:52:15,920 --> 00:52:19,359
okay i see some of the questions have

00:52:17,440 --> 00:52:22,400
been responded already

00:52:19,359 --> 00:52:24,480
i think we're doing on time we're good i

00:52:22,400 --> 00:52:26,720
think we we kind of did

00:52:24,480 --> 00:52:29,119
we hit it fellas everybody who stayed on

00:52:26,720 --> 00:52:30,880
to the end we really appreciate it

00:52:29,119 --> 00:52:32,480
massive respect to all of you for

00:52:30,880 --> 00:52:34,319
learning and and kind of teaching

00:52:32,480 --> 00:52:36,480
yourself and coming with us

00:52:34,319 --> 00:52:37,839
in our learning journey this is what rob

00:52:36,480 --> 00:52:38,720
and i've been doing for the past few

00:52:37,839 --> 00:52:41,200
months

00:52:38,720 --> 00:52:43,040
don't forget to go to lf edge rob any

00:52:41,200 --> 00:52:45,119
final words from your side

00:52:43,040 --> 00:52:46,160
no i'm just responding to uh someone

00:52:45,119 --> 00:52:48,160
who's asking uh

00:52:46,160 --> 00:52:50,160
another question here but thank you very

00:52:48,160 --> 00:52:51,359
much for joining us today and we really

00:52:50,160 --> 00:52:54,800
appreciate

00:52:51,359 --> 00:52:54,800
um any feedback that you have

00:52:55,200 --> 00:52:59,599
yeah wonderful okay thank you so much

00:52:58,480 --> 00:53:01,280
andre and robert

00:52:59,599 --> 00:53:02,800
both of you for being here and leading

00:53:01,280 --> 00:53:06,079
us through this discussion today and

00:53:02,800 --> 00:53:08,160
thank you for everybody who participated

00:53:06,079 --> 00:53:10,400
as a quick reminder the recording will

00:53:08,160 --> 00:53:12,240
be on the linux foundation youtube page

00:53:10,400 --> 00:53:14,400
later today

00:53:12,240 --> 00:53:15,440
and unless you guys have anything else

00:53:14,400 --> 00:53:18,559
yet i think that

00:53:15,440 --> 00:53:20,960
um you're good

00:53:18,559 --> 00:53:22,319
yeah feel free to email me and rob with

00:53:20,960 --> 00:53:24,400
you know if you want to follow up

00:53:22,319 --> 00:53:26,480
um if this is something your company

00:53:24,400 --> 00:53:28,960
might be interested in as we mentioned

00:53:26,480 --> 00:53:30,240
uh red hat can help you with that or if

00:53:28,960 --> 00:53:31,440
you just want to talk about the open

00:53:30,240 --> 00:53:35,200
source components

00:53:31,440 --> 00:53:35,200
we're open to that conversation as well

00:53:36,800 --> 00:53:42,000
okay wonderful thank you so much again

00:53:39,000 --> 00:53:42,000

YouTube URL: https://www.youtube.com/watch?v=9HTNhnq-6MM


