Title: LF Live Webinar: What If Flash Was Software Defined?
Publication date: 2021-03-05
Playlist: LF Live Webinars
Description: 
	Sponsored by KIOXIA

The modern hyperscale data center is built on a stack of tightly coupled, software defined components.  Virtual machines and containers have made servers software defined.  Software defined networking connects those servers together.  Cluster-scale software defined file systems hold their data.  But there is one place where software defined hasn’t yet made an impact: the flash memory storage stack. This webinar will examine how these new software defined flash capabilities can fundamentally change the way storage and the host interact
Captions: 
	00:00:00,240 --> 00:00:04,000
great thank you christine before i get

00:00:02,639 --> 00:00:05,839
rolling i would like to say

00:00:04,000 --> 00:00:07,440
thank you to the linux foundation for

00:00:05,839 --> 00:00:09,280
organizing this webinar

00:00:07,440 --> 00:00:10,639
uh we've worked with some really great

00:00:09,280 --> 00:00:13,280
people and they pulled together

00:00:10,639 --> 00:00:14,880
a really great show so christine thank

00:00:13,280 --> 00:00:17,920
you very much for your help

00:00:14,880 --> 00:00:17,920
in pulling this together

00:00:18,080 --> 00:00:23,519
so i am scott stetzer i work for keoksi

00:00:21,680 --> 00:00:24,880
america in the memory and storage

00:00:23,519 --> 00:00:26,560
strategy division

00:00:24,880 --> 00:00:29,279
and keokuksu of course is one of the

00:00:26,560 --> 00:00:32,000
largest manufacturers of flash memory

00:00:29,279 --> 00:00:32,399
for the industry today back when we were

00:00:32,000 --> 00:00:35,440
known

00:00:32,399 --> 00:00:38,800
as toshiba memory we invented flash

00:00:35,440 --> 00:00:41,040
memory so we know quite a bit about it

00:00:38,800 --> 00:00:42,800
we also deliver quite a broad range of

00:00:41,040 --> 00:00:45,200
ssds to the industry

00:00:42,800 --> 00:00:47,520
and my particular group the memory and

00:00:45,200 --> 00:00:49,760
storage strategy division is focused on

00:00:47,520 --> 00:00:51,199
bringing that flash storage and software

00:00:49,760 --> 00:00:54,800
expertise

00:00:51,199 --> 00:00:54,800
forward for you the customers

00:00:55,680 --> 00:00:59,199
so data storage is a pretty interesting

00:00:57,920 --> 00:01:00,559
topic

00:00:59,199 --> 00:01:02,239
at least for me it's a fairly

00:01:00,559 --> 00:01:04,960
interesting topic

00:01:02,239 --> 00:01:06,400
ever since the very early phases of we

00:01:04,960 --> 00:01:08,400
human beings

00:01:06,400 --> 00:01:10,560
storing information about ourselves has

00:01:08,400 --> 00:01:12,479
been a thing

00:01:10,560 --> 00:01:14,640
as far back as actually putting

00:01:12,479 --> 00:01:16,720
paintings on cave walls

00:01:14,640 --> 00:01:18,479
of course that has progressed over time

00:01:16,720 --> 00:01:20,159
through things like hieroglyphs and

00:01:18,479 --> 00:01:22,320
stone tablets

00:01:20,159 --> 00:01:24,400
and when they invented ink we were

00:01:22,320 --> 00:01:26,720
putting ink on papyrus

00:01:24,400 --> 00:01:27,680
and then we we get to the industrial age

00:01:26,720 --> 00:01:29,600
and a very

00:01:27,680 --> 00:01:31,040
interesting change happened and we were

00:01:29,600 --> 00:01:34,159
able to put print

00:01:31,040 --> 00:01:36,479
on paper to such a degree that our data

00:01:34,159 --> 00:01:40,240
storage mechanism became books

00:01:36,479 --> 00:01:43,280
uh and very useful approach to

00:01:40,240 --> 00:01:44,240
storing retrieving data a little more

00:01:43,280 --> 00:01:47,040
appropriate to us

00:01:44,240 --> 00:01:48,240
as we move into the computer age uh

00:01:47,040 --> 00:01:51,439
within this last

00:01:48,240 --> 00:01:52,000
50 to 100 years the first method of

00:01:51,439 --> 00:01:54,159
storing

00:01:52,000 --> 00:01:56,159
data in the computer age was of course

00:01:54,159 --> 00:01:59,200
punch cards

00:01:56,159 --> 00:02:01,600
a very mechanical process

00:01:59,200 --> 00:02:02,399
then we changed to linear magnetic

00:02:01,600 --> 00:02:05,040
storage

00:02:02,399 --> 00:02:07,200
which of course is tape and tape was a

00:02:05,040 --> 00:02:08,720
very sequential access methodology using

00:02:07,200 --> 00:02:11,599
magnetics

00:02:08,720 --> 00:02:12,000
the next big innovation was to change

00:02:11,599 --> 00:02:14,000
that

00:02:12,000 --> 00:02:16,800
magnetic approach from linear to

00:02:14,000 --> 00:02:19,040
rotating so rotating magnetic storage

00:02:16,800 --> 00:02:21,360
what we know today is hard disk drives

00:02:19,040 --> 00:02:23,760
and used to be floppy drives

00:02:21,360 --> 00:02:25,680
and again a very mechanical approach to

00:02:23,760 --> 00:02:27,920
storing data

00:02:25,680 --> 00:02:28,800
and this created for us that hdd

00:02:27,920 --> 00:02:32,480
paradigm

00:02:28,800 --> 00:02:35,599
and that hdd paradigm has evolved over

00:02:32,480 --> 00:02:38,879
the last 35 to 40 years

00:02:35,599 --> 00:02:40,560
when we started out that hard drive was

00:02:38,879 --> 00:02:42,080
probably about the size of the average

00:02:40,560 --> 00:02:44,959
washing machine

00:02:42,080 --> 00:02:46,000
and over these 35 to 40 years we were

00:02:44,959 --> 00:02:48,400
shrinking the

00:02:46,000 --> 00:02:50,720
footprint of that storage mechanism

00:02:48,400 --> 00:02:53,280
fantastically we went from

00:02:50,720 --> 00:02:54,720
washington machine size to 16 inch to

00:02:53,280 --> 00:02:56,480
eight inch to five and a quarter inch

00:02:54,720 --> 00:02:57,920
platters of magnetics

00:02:56,480 --> 00:03:00,560
and we settled in the three and a half

00:02:57,920 --> 00:03:02,640
inch to two and a half inch range today

00:03:00,560 --> 00:03:04,879
uh and while we were doing that shrinks

00:03:02,640 --> 00:03:07,040
we were also increasing the amount of

00:03:04,879 --> 00:03:09,280
data that can be stored in that ever

00:03:07,040 --> 00:03:12,560
shrinking space

00:03:09,280 --> 00:03:14,159
now the consistent bit about this is

00:03:12,560 --> 00:03:16,159
all of this was designed quite a while

00:03:14,159 --> 00:03:18,640
ago all before flash was

00:03:16,159 --> 00:03:20,000
invented as a storage media and again

00:03:18,640 --> 00:03:23,040
it's a very mechanical

00:03:20,000 --> 00:03:24,480
approach to data storage and that

00:03:23,040 --> 00:03:26,319
mechanical approach means it's pretty

00:03:24,480 --> 00:03:28,560
much a black box

00:03:26,319 --> 00:03:30,400
it's not terribly flexible you can read

00:03:28,560 --> 00:03:32,879
to it or you can

00:03:30,400 --> 00:03:33,760
read from it or write to it but the

00:03:32,879 --> 00:03:36,000
ability to

00:03:33,760 --> 00:03:36,799
adjust how that device works is very

00:03:36,000 --> 00:03:40,000
limited

00:03:36,799 --> 00:03:43,440
there's no control over latency in that

00:03:40,000 --> 00:03:43,440
mechanical spinning disk

00:03:44,560 --> 00:03:48,879
now over the last 10 to 15 years solid

00:03:46,959 --> 00:03:49,760
state storage in the form of flashes

00:03:48,879 --> 00:03:52,319
come into play

00:03:49,760 --> 00:03:54,080
and ssds were quite a game changer for

00:03:52,319 --> 00:03:57,360
us in the industry

00:03:54,080 --> 00:04:00,560
now initially ssds they started out

00:03:57,360 --> 00:04:02,560
simply as a faster form of hdd

00:04:00,560 --> 00:04:04,799
and this was pretty important because in

00:04:02,560 --> 00:04:07,840
order for those ssds to become

00:04:04,799 --> 00:04:09,519
adopted they had to plug right into the

00:04:07,840 --> 00:04:13,200
existing storage paradigm

00:04:09,519 --> 00:04:14,239
which was the hype disk drive ssds today

00:04:13,200 --> 00:04:16,720
continue to be

00:04:14,239 --> 00:04:18,320
extremely important for all sorts of

00:04:16,720 --> 00:04:19,120
applications especially consumer

00:04:18,320 --> 00:04:20,880
applications

00:04:19,120 --> 00:04:22,160
and enterprise server ecosystem

00:04:20,880 --> 00:04:24,639
applications

00:04:22,160 --> 00:04:26,400
i can't imagine running my laptop today

00:04:24,639 --> 00:04:29,280
without an ssd in it

00:04:26,400 --> 00:04:32,800
used to have hard drives but now i can't

00:04:29,280 --> 00:04:32,800
imagine running without an ssd

00:04:33,280 --> 00:04:37,199
the challenge though is even up to today

00:04:36,000 --> 00:04:38,720
while all of this backwards

00:04:37,199 --> 00:04:40,800
compatibility is phenomenal and

00:04:38,720 --> 00:04:41,680
important in order to keep compatibility

00:04:40,800 --> 00:04:43,840
up

00:04:41,680 --> 00:04:44,720
we're still limited we're still limited

00:04:43,840 --> 00:04:47,919
by that

00:04:44,720 --> 00:04:48,720
mechanical hdd paradigm and there's a

00:04:47,919 --> 00:04:50,720
range of

00:04:48,720 --> 00:04:52,400
storage innovators out there that are

00:04:50,720 --> 00:04:54,560
looking at new ways to bring

00:04:52,400 --> 00:04:56,000
all of this capability that flash can

00:04:54,560 --> 00:04:59,280
actually bring to the equation

00:04:56,000 --> 00:05:00,800
on beyond that hdd paradigm one of those

00:04:59,280 --> 00:05:03,039
innovators of course is the cloud or

00:05:00,800 --> 00:05:05,039
hyperscale data center

00:05:03,039 --> 00:05:07,120
they're looking for ways that they might

00:05:05,039 --> 00:05:08,960
be able to bring that full capability

00:05:07,120 --> 00:05:12,960
of the digital storage media flash

00:05:08,960 --> 00:05:12,960
storage to their application development

00:05:14,080 --> 00:05:18,560
so why is it that the hdd or cloud data

00:05:17,600 --> 00:05:21,199
center is a

00:05:18,560 --> 00:05:22,160
center of innovation well one of the key

00:05:21,199 --> 00:05:24,240
aspects of this

00:05:22,160 --> 00:05:26,960
is they're vertically integrated they

00:05:24,240 --> 00:05:29,520
own the entire stack in the data center

00:05:26,960 --> 00:05:31,600
from the network to the server to the

00:05:29,520 --> 00:05:34,560
storage to the applications

00:05:31,600 --> 00:05:36,000
they control every aspect of it and

00:05:34,560 --> 00:05:38,160
they're creating all of those

00:05:36,000 --> 00:05:39,440
new and wonderful applications that we

00:05:38,160 --> 00:05:42,800
use every day

00:05:39,440 --> 00:05:44,639
and expect to work seamlessly and fast

00:05:42,800 --> 00:05:46,800
so while they're doing all of this work

00:05:44,639 --> 00:05:48,400
they're redefining and looking for how

00:05:46,800 --> 00:05:49,680
can they make storage work more

00:05:48,400 --> 00:05:52,800
efficiently

00:05:49,680 --> 00:05:54,240
for these new applications and they do

00:05:52,800 --> 00:05:54,960
all of this of course in software so

00:05:54,240 --> 00:05:57,280
they need that

00:05:54,960 --> 00:05:58,720
capability to develop storage at the

00:05:57,280 --> 00:06:02,479
speed that they deliver

00:05:58,720 --> 00:06:02,479
their software and their applications

00:06:03,039 --> 00:06:06,560
the hyperscale or the cloud data center

00:06:04,720 --> 00:06:07,759
of course is built on being software

00:06:06,560 --> 00:06:09,360
defined

00:06:07,759 --> 00:06:10,960
they've had tremendous success in in

00:06:09,360 --> 00:06:13,520
moving to a software-defined

00:06:10,960 --> 00:06:15,199
networking approach software-defined

00:06:13,520 --> 00:06:17,840
computation is there

00:06:15,199 --> 00:06:18,319
software-defined hardware is there

00:06:17,840 --> 00:06:20,840
they're

00:06:18,319 --> 00:06:22,000
starting to see a lot of use cases for

00:06:20,840 --> 00:06:24,000
fpgas

00:06:22,000 --> 00:06:25,840
in hardware definitions there's even

00:06:24,000 --> 00:06:26,639
software defined storage layers out

00:06:25,840 --> 00:06:31,039
there taking

00:06:26,639 --> 00:06:35,520
all flash arrays and delivering

00:06:31,039 --> 00:06:38,000
service approaches at the storage layer

00:06:35,520 --> 00:06:39,039
but what's missing we have this lower

00:06:38,000 --> 00:06:42,560
layer of

00:06:39,039 --> 00:06:44,400
storage mechanism the drive itself and

00:06:42,560 --> 00:06:47,440
what about the flash why isn't that

00:06:44,400 --> 00:06:48,800
software defined yet

00:06:47,440 --> 00:06:50,720
and that brings us to the talk for

00:06:48,800 --> 00:06:55,199
today's presentation

00:06:50,720 --> 00:06:57,520
what if flash was software defined

00:06:55,199 --> 00:06:58,880
and we have to ask ourselves what would

00:06:57,520 --> 00:07:02,160
we need to do to make

00:06:58,880 --> 00:07:05,360
flash storage software defined

00:07:02,160 --> 00:07:06,800
so let's explore that a little bit first

00:07:05,360 --> 00:07:09,039
let's look at some of the challenges

00:07:06,800 --> 00:07:10,720
that the industry needs to solve

00:07:09,039 --> 00:07:12,479
the industry we talk to a lot of the

00:07:10,720 --> 00:07:14,400
hyperscale customers and we've been able

00:07:12,479 --> 00:07:14,800
to gather information from a wide range

00:07:14,400 --> 00:07:16,319
of them

00:07:14,800 --> 00:07:18,880
about what it is they're looking to do

00:07:16,319 --> 00:07:21,759
and how they look to accomplish it

00:07:18,880 --> 00:07:23,199
so they're looking for data placement

00:07:21,759 --> 00:07:23,919
they know their data they know their

00:07:23,199 --> 00:07:25,599
applications

00:07:23,919 --> 00:07:27,360
they know how they want to store the

00:07:25,599 --> 00:07:29,360
data so they want to be able to have

00:07:27,360 --> 00:07:31,360
finite control over where and how they

00:07:29,360 --> 00:07:33,280
store their data

00:07:31,360 --> 00:07:35,039
at the same time they're in complete

00:07:33,280 --> 00:07:36,880
control of their workloads

00:07:35,039 --> 00:07:38,639
and they know their tenants and how to

00:07:36,880 --> 00:07:39,280
isolate the workloads from one tenant

00:07:38,639 --> 00:07:42,240
from another

00:07:39,280 --> 00:07:43,360
they're avoiding any cross-pollination

00:07:42,240 --> 00:07:45,919
of io

00:07:43,360 --> 00:07:47,520
noisy neighbor syndromes and they want

00:07:45,919 --> 00:07:49,599
to be able to control latency

00:07:47,520 --> 00:07:51,440
they want to handle how fast they can

00:07:49,599 --> 00:07:52,400
get to that io and control that so they

00:07:51,440 --> 00:07:54,319
can deliver

00:07:52,400 --> 00:07:57,440
quality of service to each of their

00:07:54,319 --> 00:08:00,000
customers or each of their applications

00:07:57,440 --> 00:08:02,000
and we all know workloads adapt and

00:08:00,000 --> 00:08:04,479
change over time so they want to be able

00:08:02,000 --> 00:08:08,160
to adapt to new workloads on the fly

00:08:04,479 --> 00:08:09,919
as those workloads change on the

00:08:08,160 --> 00:08:11,199
other side of this uh slide we're

00:08:09,919 --> 00:08:13,599
talking about a couple of other things

00:08:11,199 --> 00:08:16,400
that have to do with the hardware itself

00:08:13,599 --> 00:08:18,240
over provisioning at scale inside of our

00:08:16,400 --> 00:08:20,720
laptops we over provision

00:08:18,240 --> 00:08:21,360
and we raid the flash die inside that

00:08:20,720 --> 00:08:24,319
ssd

00:08:21,360 --> 00:08:26,479
it's a single device we want your data

00:08:24,319 --> 00:08:28,160
to be as safe as possible

00:08:26,479 --> 00:08:30,160
and we want it to work at its most

00:08:28,160 --> 00:08:33,120
optimum speed so we over provision

00:08:30,160 --> 00:08:33,440
and we add raid to the flash die what

00:08:33,120 --> 00:08:36,320
this

00:08:33,440 --> 00:08:38,399
means is we're reserving several bytes

00:08:36,320 --> 00:08:40,080
out of that available flash in order to

00:08:38,399 --> 00:08:41,680
handle that over provisioning and that

00:08:40,080 --> 00:08:44,159
raid function

00:08:41,680 --> 00:08:45,279
the hyperscale data center typically

00:08:44,159 --> 00:08:48,399
they're going to want to have

00:08:45,279 --> 00:08:51,440
access to every byte of flash

00:08:48,399 --> 00:08:52,880
because they're handling data integrity

00:08:51,440 --> 00:08:54,320
at a higher level they're handling it at

00:08:52,880 --> 00:08:56,000
the rack level not at the individual

00:08:54,320 --> 00:08:58,080
device level

00:08:56,000 --> 00:09:00,560
power loss protection circuits we put

00:08:58,080 --> 00:09:03,760
that in every ssd as well

00:09:00,560 --> 00:09:05,440
although most data centers they add

00:09:03,760 --> 00:09:07,760
power loss protection or battery

00:09:05,440 --> 00:09:10,160
backup at the rack level so power loss

00:09:07,760 --> 00:09:13,279
protection in an individual device

00:09:10,160 --> 00:09:15,519
is probably overkill

00:09:13,279 --> 00:09:17,600
so a software-defined approach can help

00:09:15,519 --> 00:09:19,600
solve some of these industry problems

00:09:17,600 --> 00:09:23,200
especially the workload tenant and

00:09:19,600 --> 00:09:25,040
workload problems

00:09:23,200 --> 00:09:27,040
if we look at these problems and say

00:09:25,040 --> 00:09:29,279
okay how can we solve these

00:09:27,040 --> 00:09:30,640
well the first method that we need to

00:09:29,279 --> 00:09:32,720
look at is

00:09:30,640 --> 00:09:34,880
we probably need to abstract the flash

00:09:32,720 --> 00:09:36,959
with a software-based programmers

00:09:34,880 --> 00:09:38,720
interface and api

00:09:36,959 --> 00:09:40,560
now this api would have to handle a

00:09:38,720 --> 00:09:42,240
number of key aspects

00:09:40,560 --> 00:09:44,080
that would include how do you handle the

00:09:42,240 --> 00:09:45,680
low-level flash itself

00:09:44,080 --> 00:09:47,200
there's flash programming in terms of

00:09:45,680 --> 00:09:49,519
voltages and timing

00:09:47,200 --> 00:09:53,440
there's handling the ecc there's dealing

00:09:49,519 --> 00:09:56,000
with bad pages and bad blocks of data

00:09:53,440 --> 00:09:57,839
the api would also need to look at the

00:09:56,000 --> 00:09:59,760
differences between different types

00:09:57,839 --> 00:10:01,839
or generations of flash and abstract

00:09:59,760 --> 00:10:02,480
that as well as differences in vendors

00:10:01,839 --> 00:10:04,480
flash

00:10:02,480 --> 00:10:06,079
and handle that through abstraction as

00:10:04,480 --> 00:10:08,000
well

00:10:06,079 --> 00:10:09,440
hardware isolation all the way down to

00:10:08,000 --> 00:10:11,839
the flash dye level

00:10:09,440 --> 00:10:12,480
would be the ability to solve that noise

00:10:11,839 --> 00:10:15,440
noisy

00:10:12,480 --> 00:10:16,720
neighbor issue that i described earlier

00:10:15,440 --> 00:10:18,800
latency is important

00:10:16,720 --> 00:10:20,800
how do we make sure that the software

00:10:18,800 --> 00:10:22,000
and the application has discrete control

00:10:20,800 --> 00:10:25,200
over that workload

00:10:22,000 --> 00:10:27,360
so you don't get any performance lags

00:10:25,200 --> 00:10:30,160
and then another aspect is that host and

00:10:27,360 --> 00:10:33,839
that server cpu is there to do

00:10:30,160 --> 00:10:37,440
applications functions so is there a way

00:10:33,839 --> 00:10:38,079
api to abstract the flash in such a way

00:10:37,440 --> 00:10:39,360
that it

00:10:38,079 --> 00:10:41,680
doesn't become a burden on host

00:10:39,360 --> 00:10:42,560
resources reduce the number of host cpu

00:10:41,680 --> 00:10:44,480
cycles

00:10:42,560 --> 00:10:46,160
that need to be done for common

00:10:44,480 --> 00:10:49,920
housekeeping features

00:10:46,160 --> 00:10:49,920
like garbage collection or wear level

00:10:51,839 --> 00:10:55,600
the next question that we would ask

00:10:53,440 --> 00:10:58,160
ourselves is if we were able to do

00:10:55,600 --> 00:11:00,399
a software defined flash approach what

00:10:58,160 --> 00:11:03,040
benefits could be derived from doing so

00:11:00,399 --> 00:11:05,760
is there a valuable service that can be

00:11:03,040 --> 00:11:08,480
performed by going software defined

00:11:05,760 --> 00:11:09,200
and the answer is pretty clearly yes

00:11:08,480 --> 00:11:11,600
today

00:11:09,200 --> 00:11:13,519
you have to buy different types of flash

00:11:11,600 --> 00:11:14,320
devices to serve different purposes in

00:11:13,519 --> 00:11:17,120
the data center

00:11:14,320 --> 00:11:18,720
fast ones slow ones cold data storage

00:11:17,120 --> 00:11:21,440
hot data storage

00:11:18,720 --> 00:11:22,560
all come with different attributes in

00:11:21,440 --> 00:11:25,200
this case with a

00:11:22,560 --> 00:11:26,320
software defined flash approach you can

00:11:25,200 --> 00:11:29,440
deliver a single

00:11:26,320 --> 00:11:32,240
adaptable flash device that can then be

00:11:29,440 --> 00:11:34,079
repurposed for different use cases

00:11:32,240 --> 00:11:35,839
this device can be focused on all those

00:11:34,079 --> 00:11:39,440
low-level flash problems like

00:11:35,839 --> 00:11:40,959
programming erasing and ecc and error

00:11:39,440 --> 00:11:43,120
management

00:11:40,959 --> 00:11:44,399
and through software it could easily be

00:11:43,120 --> 00:11:46,320
adapted to new level

00:11:44,399 --> 00:11:47,680
high level requirements up at the host

00:11:46,320 --> 00:11:49,839
change the protocol that

00:11:47,680 --> 00:11:50,720
the device works so it can be used for

00:11:49,839 --> 00:11:53,120
different

00:11:50,720 --> 00:11:54,800
use cases or data types hot data or cold

00:11:53,120 --> 00:11:56,880
data

00:11:54,800 --> 00:11:59,040
we want to be able to reuse large

00:11:56,880 --> 00:12:01,680
amounts of code that we've deployed

00:11:59,040 --> 00:12:02,880
for each of these flash devices as well

00:12:01,680 --> 00:12:05,040
as bringing

00:12:02,880 --> 00:12:06,160
through that code we use faster internal

00:12:05,040 --> 00:12:08,240
development cycles

00:12:06,160 --> 00:12:11,839
as well as simplifying the maintenance

00:12:08,240 --> 00:12:11,839
of the flash devices themselves

00:12:12,399 --> 00:12:15,839
so if we look at this and we say okay

00:12:14,160 --> 00:12:17,839
what do we really need

00:12:15,839 --> 00:12:19,200
we need to bring the speed and

00:12:17,839 --> 00:12:21,200
flexibility of flash

00:12:19,200 --> 00:12:22,880
how do we get that maximum potential out

00:12:21,200 --> 00:12:24,880
of the flash itself

00:12:22,880 --> 00:12:27,360
and we need to combine that with the

00:12:24,880 --> 00:12:29,519
ease of software definability

00:12:27,360 --> 00:12:31,519
how do we get all the benefits that

00:12:29,519 --> 00:12:32,560
flash as the digital storage media

00:12:31,519 --> 00:12:35,040
brings us

00:12:32,560 --> 00:12:39,440
without all the traditional overhead of

00:12:35,040 --> 00:12:42,079
the hdd paradigm

00:12:39,440 --> 00:12:42,560
well i'm actually privileged in my job

00:12:42,079 --> 00:12:45,839
here

00:12:42,560 --> 00:12:48,000
at geology america to work with a very

00:12:45,839 --> 00:12:49,920
large group of smart and creative

00:12:48,000 --> 00:12:53,680
engineers both here in the u.s

00:12:49,920 --> 00:12:54,959
and in japan and rather than just bring

00:12:53,680 --> 00:12:56,800
you all the challenges

00:12:54,959 --> 00:12:59,279
and the problems i'd like to also

00:12:56,800 --> 00:13:02,000
suggest a solution

00:12:59,279 --> 00:13:02,880
there is a software defined flash api

00:13:02,000 --> 00:13:07,839
available

00:13:02,880 --> 00:13:07,839
that's called software enabled flash

00:13:08,160 --> 00:13:12,000
software enabled flash is a new approach

00:13:10,639 --> 00:13:13,760
that's designed to bring

00:13:12,000 --> 00:13:15,519
flash storage innovation to you the

00:13:13,760 --> 00:13:18,240
developer it's a powerful way

00:13:15,519 --> 00:13:18,720
forward for flash to be deployed in data

00:13:18,240 --> 00:13:22,320
center

00:13:18,720 --> 00:13:26,800
and emerging storage applications

00:13:22,320 --> 00:13:30,240
completely shed the legacy hdd paradigm

00:13:26,800 --> 00:13:32,800
we'll allow flash to behave like flash

00:13:30,240 --> 00:13:34,040
which then allows us to bring that flash

00:13:32,800 --> 00:13:37,120
forward to behave in much more

00:13:34,040 --> 00:13:38,880
predictable and uniform manners

00:13:37,120 --> 00:13:40,800
that can also give you the ability to

00:13:38,880 --> 00:13:42,639
define better latency outcomes for your

00:13:40,800 --> 00:13:44,720
application

00:13:42,639 --> 00:13:45,920
and flash can be used at its native

00:13:44,720 --> 00:13:48,320
speed

00:13:45,920 --> 00:13:50,000
software enabled flash brings that

00:13:48,320 --> 00:13:52,000
software flexibility

00:13:50,000 --> 00:13:55,199
and that scalability you need in the

00:13:52,000 --> 00:13:59,040
data center to you the storage developer

00:13:55,199 --> 00:13:59,040
it's really a powerful way forward

00:13:59,680 --> 00:14:03,199
so what is software enabled flash in

00:14:01,760 --> 00:14:04,800
reality

00:14:03,199 --> 00:14:07,120
at a high level it's really about the

00:14:04,800 --> 00:14:10,000
hardware and the software

00:14:07,120 --> 00:14:11,680
working together seamlessly so let's

00:14:10,000 --> 00:14:14,800
look at the hardware portion of this

00:14:11,680 --> 00:14:16,560
briefly and say on the left of this

00:14:14,800 --> 00:14:17,760
slide you can see a hardware block

00:14:16,560 --> 00:14:19,920
diagram

00:14:17,760 --> 00:14:22,160
and in this case this is a purpose-built

00:14:19,920 --> 00:14:22,880
media-centric flash controller specific

00:14:22,160 --> 00:14:25,920
to

00:14:22,880 --> 00:14:29,279
deploying flash using the

00:14:25,920 --> 00:14:31,279
software enabled flash api

00:14:29,279 --> 00:14:33,199
this handles all of the low-level tasks

00:14:31,279 --> 00:14:35,279
of managing the flash itself

00:14:33,199 --> 00:14:36,639
flash page programming timings and

00:14:35,279 --> 00:14:38,880
voltages that are required

00:14:36,639 --> 00:14:40,240
handles the health of each individual

00:14:38,880 --> 00:14:43,120
flash cell

00:14:40,240 --> 00:14:44,000
brings forward the use of ecc and defect

00:14:43,120 --> 00:14:47,279
management

00:14:44,000 --> 00:14:49,440
within the flash controller and

00:14:47,279 --> 00:14:51,440
we've seen from some of our customers

00:14:49,440 --> 00:14:52,959
different and varying needs for how they

00:14:51,440 --> 00:14:55,760
use dram in the device

00:14:52,959 --> 00:14:58,000
so it can deploy dram on the device or

00:14:55,760 --> 00:15:00,160
you can reduce the amount of dram

00:14:58,000 --> 00:15:01,279
and or completely eliminate the use of

00:15:00,160 --> 00:15:05,040
dram

00:15:01,279 --> 00:15:07,040
on the device itself one other thing i'd

00:15:05,040 --> 00:15:08,959
like to highlight we of course being

00:15:07,040 --> 00:15:11,040
keyoxia we deploy our flash

00:15:08,959 --> 00:15:14,399
using a flash interface known as the

00:15:11,040 --> 00:15:16,959
toggle in toggle mode interface

00:15:14,399 --> 00:15:18,959
in order to make this controller capable

00:15:16,959 --> 00:15:22,079
of using different types of flash

00:15:18,959 --> 00:15:23,920
simply go in and change the flash level

00:15:22,079 --> 00:15:25,519
interface to whatever is necessary to

00:15:23,920 --> 00:15:27,360
deploy the next type of flash

00:15:25,519 --> 00:15:29,120
it's a fairly easy and straightforward

00:15:27,360 --> 00:15:30,240
process you could change that toggle

00:15:29,120 --> 00:15:33,759
mode out

00:15:30,240 --> 00:15:35,680
employ the onfi or on fee mode

00:15:33,759 --> 00:15:36,800
and a different vendor could also be

00:15:35,680 --> 00:15:38,880
used deploying

00:15:36,800 --> 00:15:42,480
software enabled flash for your use

00:15:38,880 --> 00:15:42,480
cases a multi-vendor approach

00:15:42,959 --> 00:15:46,560
now if we change the approach and start

00:15:45,759 --> 00:15:48,880
looking at the

00:15:46,560 --> 00:15:50,560
software side of this software and

00:15:48,880 --> 00:15:52,839
hardware working together

00:15:50,560 --> 00:15:54,000
the software stack is shown here on the

00:15:52,839 --> 00:15:56,240
right

00:15:54,000 --> 00:15:57,839
of course we have a device driver that

00:15:56,240 --> 00:15:58,480
talks to the hardware and the controller

00:15:57,839 --> 00:16:01,759
itself

00:15:58,480 --> 00:16:04,560
to bring that flash forward there's the

00:16:01,759 --> 00:16:06,240
software enabled flash api that comes

00:16:04,560 --> 00:16:08,800
forward in a library

00:16:06,240 --> 00:16:09,839
that gives access to the flash either

00:16:08,800 --> 00:16:10,959
through the file system and the

00:16:09,839 --> 00:16:14,000
traditional of

00:16:10,959 --> 00:16:14,959
um block level drivers and reference

00:16:14,000 --> 00:16:17,759
ftls

00:16:14,959 --> 00:16:19,360
of the operating system we have sample

00:16:17,759 --> 00:16:21,199
source code that shows how to implement

00:16:19,360 --> 00:16:23,600
that

00:16:21,199 --> 00:16:25,519
that will be made available the

00:16:23,600 --> 00:16:27,519
hyperscaler the cloud customers also

00:16:25,519 --> 00:16:28,000
have defined their own approaches to

00:16:27,519 --> 00:16:31,120
this

00:16:28,000 --> 00:16:32,000
uh file system and uh operating system

00:16:31,120 --> 00:16:35,199
stack

00:16:32,000 --> 00:16:36,720
so it's very easy to take the sef the

00:16:35,199 --> 00:16:39,040
software enabled flash library

00:16:36,720 --> 00:16:41,440
and apply it to those uh custom software

00:16:39,040 --> 00:16:43,519
defined storage stacks

00:16:41,440 --> 00:16:44,639
but what i'd like to highlight uh really

00:16:43,519 --> 00:16:47,199
quickly if i can

00:16:44,639 --> 00:16:48,320
is notice that the library this section

00:16:47,199 --> 00:16:50,079
in blue

00:16:48,320 --> 00:16:51,759
actually runs all the way up to the user

00:16:50,079 --> 00:16:54,639
application

00:16:51,759 --> 00:16:55,360
you can use flash native semantics

00:16:54,639 --> 00:16:57,839
through the

00:16:55,360 --> 00:16:59,759
software enabled flash api and library

00:16:57,839 --> 00:17:02,320
to talk directly to the flash device

00:16:59,759 --> 00:17:04,799
by bypassing the traditional file

00:17:02,320 --> 00:17:06,720
systems in your os

00:17:04,799 --> 00:17:09,360
in order to demonstrate this we do have

00:17:06,720 --> 00:17:11,760
a couple of interesting applications

00:17:09,360 --> 00:17:14,000
that use this flash native approach we

00:17:11,760 --> 00:17:15,439
have a version of roxdb

00:17:14,000 --> 00:17:17,760
that talks flash native through the

00:17:15,439 --> 00:17:19,520
software enabled flash api

00:17:17,760 --> 00:17:21,919
we've got a version of firecracker for

00:17:19,520 --> 00:17:23,919
virtualization that also talks

00:17:21,919 --> 00:17:25,120
directly to flash in the flash native

00:17:23,919 --> 00:17:27,760
mode

00:17:25,120 --> 00:17:29,520
and for testing purposes we took the uh

00:17:27,760 --> 00:17:32,559
i o generator known as

00:17:29,520 --> 00:17:35,840
fio and adapted that to the flash native

00:17:32,559 --> 00:17:35,840
api approach as well

00:17:36,640 --> 00:17:40,559
now all of this software aspects that

00:17:39,280 --> 00:17:41,280
i've talked about are going to be

00:17:40,559 --> 00:17:43,280
available

00:17:41,280 --> 00:17:45,039
through open source the api the

00:17:43,280 --> 00:17:48,160
libraries are already up

00:17:45,039 --> 00:17:49,919
and available in open source uh

00:17:48,160 --> 00:17:51,520
later this year we'll be bringing out

00:17:49,919 --> 00:17:53,039
all of the sample source codes in the

00:17:51,520 --> 00:17:54,799
form of an sdk

00:17:53,039 --> 00:17:56,320
uh and these those will also be

00:17:54,799 --> 00:17:58,240
available on open source

00:17:56,320 --> 00:18:00,080
so bear with me i'll talk a little bit

00:17:58,240 --> 00:18:02,400
about the open source strategy

00:18:00,080 --> 00:18:03,120
at the end of the presentation but let's

00:18:02,400 --> 00:18:06,080
take a look

00:18:03,120 --> 00:18:07,120
at the programming capability there's a

00:18:06,080 --> 00:18:08,640
wide range

00:18:07,120 --> 00:18:10,160
and again sample source code is

00:18:08,640 --> 00:18:12,480
available of different

00:18:10,160 --> 00:18:15,039
aspects of enabling and deploying

00:18:12,480 --> 00:18:18,240
software enabled flash

00:18:15,039 --> 00:18:18,720
anything from a cli that allows a host

00:18:18,240 --> 00:18:21,679
to

00:18:18,720 --> 00:18:22,880
automate and batch file up the creation

00:18:21,679 --> 00:18:26,000
of virtual

00:18:22,880 --> 00:18:27,280
flash devices using the scf api

00:18:26,000 --> 00:18:29,280
all the way through data handling

00:18:27,280 --> 00:18:31,200
commands and event handlers

00:18:29,280 --> 00:18:33,039
as well as our data path commands have

00:18:31,200 --> 00:18:37,360
asynchronous versions as well

00:18:33,039 --> 00:18:40,559
so a pretty flexible library

00:18:37,360 --> 00:18:43,360
now talking about

00:18:40,559 --> 00:18:45,039
programming and source code via

00:18:43,360 --> 00:18:46,799
powerpoint is probably not the most

00:18:45,039 --> 00:18:48,240
exciting thing i myself can be doing

00:18:46,799 --> 00:18:49,760
there's some really smart people that

00:18:48,240 --> 00:18:51,520
could probably make that interesting but

00:18:49,760 --> 00:18:53,360
i don't think i can

00:18:51,520 --> 00:18:56,240
so instead what i'd like to do is change

00:18:53,360 --> 00:18:57,840
the approach and not talk so much about

00:18:56,240 --> 00:18:59,679
what the source code looks like but

00:18:57,840 --> 00:19:02,720
about how you use it

00:18:59,679 --> 00:19:04,480
how do you actually turn on and enable

00:19:02,720 --> 00:19:06,080
and deploy software-enabled flash

00:19:04,480 --> 00:19:07,280
capabilities

00:19:06,080 --> 00:19:09,520
i'd like to do this through some

00:19:07,280 --> 00:19:11,360
demonstrations first we'll talk about

00:19:09,520 --> 00:19:12,559
how you define a software enabled flash

00:19:11,360 --> 00:19:14,240
device

00:19:12,559 --> 00:19:15,760
data placement and workload isolation

00:19:14,240 --> 00:19:18,799
will be a big part of that

00:19:15,760 --> 00:19:21,200
definition we'll then

00:19:18,799 --> 00:19:22,799
go and talk about how we can deploy

00:19:21,200 --> 00:19:24,960
different protocols

00:19:22,799 --> 00:19:25,840
on different applications on the already

00:19:24,960 --> 00:19:29,440
defined

00:19:25,840 --> 00:19:29,440
and isolated flash device

00:19:29,520 --> 00:19:32,960
after that we'll talk a little bit about

00:19:30,960 --> 00:19:35,039
latency and how you can control latency

00:19:32,960 --> 00:19:36,880
all the way down to the individual i o

00:19:35,039 --> 00:19:39,919
level using advanced queuing

00:19:36,880 --> 00:19:41,200
methodologies built into the api

00:19:39,919 --> 00:19:43,120
as well as we'll do a quick

00:19:41,200 --> 00:19:45,840
demonstration on how we can offload

00:19:43,120 --> 00:19:47,520
those host cpu resources

00:19:45,840 --> 00:19:50,000
for better program efficiency in the

00:19:47,520 --> 00:19:50,000
hardware

00:19:50,799 --> 00:19:54,400
so let's move forward and let's talk

00:19:52,720 --> 00:19:56,080
about how do we define a software

00:19:54,400 --> 00:19:58,000
enabled to flash device

00:19:56,080 --> 00:20:00,880
and how do we use that definition to

00:19:58,000 --> 00:20:02,960
isolate workloads from each other

00:20:00,880 --> 00:20:05,520
so the first thing we need to do you can

00:20:02,960 --> 00:20:07,440
see on the animation that i have here

00:20:05,520 --> 00:20:09,200
a typical layout for flash controller

00:20:07,440 --> 00:20:11,760
and flash die we've got eight channels

00:20:09,200 --> 00:20:13,919
with four flash diaper channel

00:20:11,760 --> 00:20:15,360
the first step would be let's isolate

00:20:13,919 --> 00:20:16,559
hardware all the way down to the flash

00:20:15,360 --> 00:20:19,200
style level

00:20:16,559 --> 00:20:20,880
in this case isolation by flash die is

00:20:19,200 --> 00:20:22,799
done by what we call

00:20:20,880 --> 00:20:24,080
defining a virtual device through the

00:20:22,799 --> 00:20:26,480
api

00:20:24,080 --> 00:20:27,600
in this case we'll take blocks of

00:20:26,480 --> 00:20:30,000
different

00:20:27,600 --> 00:20:31,600
blocks of flash dye and create virtual

00:20:30,000 --> 00:20:34,559
devices so you can see

00:20:31,600 --> 00:20:35,679
in blue virtual device 0 in red virtual

00:20:34,559 --> 00:20:39,200
device 1 and

00:20:35,679 --> 00:20:41,440
in green virtual device 2.

00:20:39,200 --> 00:20:42,400
different layouts different numbers of

00:20:41,440 --> 00:20:44,880
flash die but

00:20:42,400 --> 00:20:48,400
very easily to define completely

00:20:44,880 --> 00:20:51,360
isolated zones of flash

00:20:48,400 --> 00:20:53,039
now on top of these virtual devices we

00:20:51,360 --> 00:20:56,159
can layer a second

00:20:53,039 --> 00:20:58,640
layer of isolation through software what

00:20:56,159 --> 00:21:00,320
we call a quality of service domain

00:20:58,640 --> 00:21:02,080
now this software layer allows us to

00:21:00,320 --> 00:21:03,440
define different protocols that we want

00:21:02,080 --> 00:21:06,000
to deploy

00:21:03,440 --> 00:21:06,799
in each of these domains we can control

00:21:06,000 --> 00:21:09,520
latencies

00:21:06,799 --> 00:21:10,240
and different operations through these

00:21:09,520 --> 00:21:14,080
software

00:21:10,240 --> 00:21:14,080
isolated zones quality of service

00:21:14,840 --> 00:21:18,960
domains

00:21:16,480 --> 00:21:20,880
now that we've defined a device the real

00:21:18,960 --> 00:21:23,600
purpose for having storage is to be able

00:21:20,880 --> 00:21:26,320
to run applications and store data

00:21:23,600 --> 00:21:27,679
and every application and every device

00:21:26,320 --> 00:21:29,200
needs to run in a slightly different

00:21:27,679 --> 00:21:30,640
manner depending on your workload

00:21:29,200 --> 00:21:34,080
so let's take a look at how we can

00:21:30,640 --> 00:21:36,480
deploy different types of protocols

00:21:34,080 --> 00:21:38,320
on these defined locations within this

00:21:36,480 --> 00:21:40,320
flash device

00:21:38,320 --> 00:21:42,320
so let's start by deploying a typical

00:21:40,320 --> 00:21:43,840
web style application

00:21:42,320 --> 00:21:45,280
and of course let's start with the

00:21:43,840 --> 00:21:46,640
simplest mode which would be a

00:21:45,280 --> 00:21:49,039
traditional block motor

00:21:46,640 --> 00:21:50,720
or a typical solid-state disk drive type

00:21:49,039 --> 00:21:52,400
of operation

00:21:50,720 --> 00:21:53,840
and in this case so we can show the

00:21:52,400 --> 00:21:55,600
isolation activity

00:21:53,840 --> 00:21:59,440
we're going to run this with a mixed

00:21:55,600 --> 00:22:01,360
read and write i o pattern

00:21:59,440 --> 00:22:03,360
for qos domain 2 let's bring in a

00:22:01,360 --> 00:22:04,240
different app we'll bring in a streaming

00:22:03,360 --> 00:22:05,760
app

00:22:04,240 --> 00:22:08,159
and it's important for us to show that

00:22:05,760 --> 00:22:10,080
you can customize how you use

00:22:08,159 --> 00:22:11,679
and deploy your protocol so we're going

00:22:10,080 --> 00:22:14,960
to run this using a custom

00:22:11,679 --> 00:22:15,600
ftl capability a completely custom

00:22:14,960 --> 00:22:18,480
written

00:22:15,600 --> 00:22:20,000
protocol for deploying storage like a

00:22:18,480 --> 00:22:21,679
drive

00:22:20,000 --> 00:22:24,240
and finally in the third zone we'll run

00:22:21,679 --> 00:22:27,360
yet a third app and a third protocol

00:22:24,240 --> 00:22:28,960
we'll run a database style app so the

00:22:27,360 --> 00:22:32,000
streaming app will do 100

00:22:28,960 --> 00:22:32,400
read i o and this data base application

00:22:32,000 --> 00:22:36,000
running

00:22:32,400 --> 00:22:39,360
in zns mode will run with a 100 percent

00:22:36,000 --> 00:22:43,039
right i o pattern now

00:22:39,360 --> 00:22:46,559
notice as i've done this i have

00:22:43,039 --> 00:22:48,000
left in the layout definition open die

00:22:46,559 --> 00:22:50,000
that are unused

00:22:48,000 --> 00:22:51,760
this as we get to running the

00:22:50,000 --> 00:22:53,120
demonstration we'll show you that we are

00:22:51,760 --> 00:22:56,400
truly isolated

00:22:53,120 --> 00:22:58,799
in our working zones so let's move

00:22:56,400 --> 00:23:00,880
forward and show you the

00:22:58,799 --> 00:23:02,960
actual demonstration running on actual

00:23:00,880 --> 00:23:06,840
flash ion hardware

00:23:02,960 --> 00:23:09,760
this is a paused image of a running

00:23:06,840 --> 00:23:13,120
demonstration and if you

00:23:09,760 --> 00:23:13,520
oops let me uh get going here so you can

00:23:13,120 --> 00:23:16,640
see

00:23:13,520 --> 00:23:18,559
i've got my three separated zones going

00:23:16,640 --> 00:23:20,480
the first one of course is that block

00:23:18,559 --> 00:23:23,760
mode running in a mixed relay

00:23:20,480 --> 00:23:24,559
i o up in the upper side uh the custom

00:23:23,760 --> 00:23:28,480
ftl mode

00:23:24,559 --> 00:23:30,000
running 100 read i o read is blue right

00:23:28,480 --> 00:23:31,520
as orange

00:23:30,000 --> 00:23:34,080
and then the third zone of course is

00:23:31,520 --> 00:23:35,440
running that zns protocol with a 100

00:23:34,080 --> 00:23:37,120
percent right eye

00:23:35,440 --> 00:23:39,200
now it's important to highlight that

00:23:37,120 --> 00:23:41,120
because we need to be able to

00:23:39,200 --> 00:23:42,720
prove to you that the i o is running

00:23:41,120 --> 00:23:44,159
independently of each other

00:23:42,720 --> 00:23:46,080
and they're not interfering with each

00:23:44,159 --> 00:23:48,240
other and

00:23:46,080 --> 00:23:49,120
also to highlight from this layout you

00:23:48,240 --> 00:23:53,440
can still see

00:23:49,120 --> 00:23:56,480
the flash dye that have not been

00:23:53,440 --> 00:23:58,159
selected for use in this demonstration

00:23:56,480 --> 00:24:00,159
so let me kick off the i o that's

00:23:58,159 --> 00:24:02,000
occurring

00:24:00,159 --> 00:24:03,520
and you can see we are completely

00:24:02,000 --> 00:24:05,440
isolated from zone to zone

00:24:03,520 --> 00:24:06,720
the ios are not interfering with each

00:24:05,440 --> 00:24:08,480
other the tenants are completely

00:24:06,720 --> 00:24:10,720
isolated by a workload

00:24:08,480 --> 00:24:13,279
read write in the first zone 100 percent

00:24:10,720 --> 00:24:14,960
read in the second zone and 100

00:24:13,279 --> 00:24:17,840
right in the third zone no

00:24:14,960 --> 00:24:19,840
cross-pollination of i o

00:24:17,840 --> 00:24:21,919
you can imagine with the parallelism of

00:24:19,840 --> 00:24:24,480
flash each of these zones are running

00:24:21,919 --> 00:24:26,240
independent of each other

00:24:24,480 --> 00:24:27,679
the tenants are not being noisy

00:24:26,240 --> 00:24:29,200
neighbors to each other and they're all

00:24:27,679 --> 00:24:31,679
running at the full spleen

00:24:29,200 --> 00:24:33,440
full set the parallelism of flash can

00:24:31,679 --> 00:24:37,360
bring

00:24:33,440 --> 00:24:39,120
now one of them to highlight we don't

00:24:37,360 --> 00:24:41,120
think this is the normal mode for

00:24:39,120 --> 00:24:43,279
running a single flash device

00:24:41,120 --> 00:24:45,760
in a rack environment you're going to be

00:24:43,279 --> 00:24:47,360
running hundreds of devices

00:24:45,760 --> 00:24:49,200
and they're all going to be set up in

00:24:47,360 --> 00:24:51,840
individual zones with different

00:24:49,200 --> 00:24:53,679
softwares on top of them

00:24:51,840 --> 00:24:56,080
what this does demonstrate for you

00:24:53,679 --> 00:24:58,559
though is those different protocols

00:24:56,080 --> 00:25:00,880
can be applied and changed and workload

00:24:58,559 --> 00:25:03,919
changes in your working environment

00:25:00,880 --> 00:25:05,679
you need to change the styles case

00:25:03,919 --> 00:25:07,520
storage go in and change the software

00:25:05,679 --> 00:25:09,840
driver and you can change from

00:25:07,520 --> 00:25:11,600
a typical block mode to a custom ftl

00:25:09,840 --> 00:25:15,840
mode or to a cnn

00:25:11,600 --> 00:25:15,840
depending requirements of your workload

00:25:18,640 --> 00:25:23,520
okay i think the next portion of our

00:25:21,120 --> 00:25:26,240
talk was going to show you how we can

00:25:23,520 --> 00:25:27,120
manage late the device level now

00:25:26,240 --> 00:25:29,200
latencies

00:25:27,120 --> 00:25:31,679
come in all sorts of different forms for

00:25:29,200 --> 00:25:33,840
ssds there's a very high performance

00:25:31,679 --> 00:25:35,120
latency approach that unfortunately has

00:25:33,840 --> 00:25:38,080
a few outliers

00:25:35,120 --> 00:25:38,480
that can slow down the average latency

00:25:38,080 --> 00:25:41,679
an

00:25:38,480 --> 00:25:42,480
approach is let's not necessarily run

00:25:41,679 --> 00:25:45,279
the

00:25:42,480 --> 00:25:46,480
flash at the fastest possible speed but

00:25:45,279 --> 00:25:49,520
let's make sure that we have a

00:25:46,480 --> 00:25:50,960
consistent latency with no outliers

00:25:49,520 --> 00:25:53,039
now if you look at both of these

00:25:50,960 --> 00:25:54,640
profiles we have the same average

00:25:53,039 --> 00:25:56,159
latency between the two

00:25:54,640 --> 00:25:58,720
but there's a different performance

00:25:56,159 --> 00:26:00,799
profile expected from these

00:25:58,720 --> 00:26:02,080
and some people may ask which one is

00:26:00,799 --> 00:26:04,240
better

00:26:02,080 --> 00:26:06,480
now my chief architect likes to say this

00:26:04,240 --> 00:26:09,360
is a trick question

00:26:06,480 --> 00:26:11,039
and it's trick question is because the

00:26:09,360 --> 00:26:12,640
answer is it depends

00:26:11,039 --> 00:26:14,720
it depends on the application that's

00:26:12,640 --> 00:26:17,120
being used or deployed and how it needs

00:26:14,720 --> 00:26:18,880
to run its i o

00:26:17,120 --> 00:26:20,559
the good news is with the software

00:26:18,880 --> 00:26:22,840
enabled flash api

00:26:20,559 --> 00:26:24,960
and technology it gives you the

00:26:22,840 --> 00:26:27,520
programmer the ability to

00:26:24,960 --> 00:26:29,120
control your latency outcomes as your

00:26:27,520 --> 00:26:32,880
application requires it

00:26:29,120 --> 00:26:32,880
and change those outcomes on the fly

00:26:33,279 --> 00:26:37,039
into the software enabled flash api are

00:26:35,919 --> 00:26:40,240
three different

00:26:37,039 --> 00:26:42,559
uh cueing modes or protocols

00:26:40,240 --> 00:26:44,799
first is a priority queue methodology

00:26:42,559 --> 00:26:47,360
another one is a round robin

00:26:44,799 --> 00:26:48,000
cueing mode and the third one is a very

00:26:47,360 --> 00:26:51,440
powerful

00:26:48,000 --> 00:26:53,279
die time weighted fair queuing mode this

00:26:51,440 --> 00:26:54,559
die time weighted fair queueing mode

00:26:53,279 --> 00:26:57,200
gives applications

00:26:54,559 --> 00:26:58,400
discrete and absolute control over die

00:26:57,200 --> 00:27:00,799
time scheduling

00:26:58,400 --> 00:27:01,760
which allows you the developer to manage

00:27:00,799 --> 00:27:04,480
and deliver eight

00:27:01,760 --> 00:27:06,640
latency outcomes all the way down to the

00:27:04,480 --> 00:27:08,159
individual i o level this ensures that

00:27:06,640 --> 00:27:11,440
your i o is prioritized

00:27:08,159 --> 00:27:13,360
fairly based on your user's needs

00:27:11,440 --> 00:27:16,799
you can avoid i o starvation problems

00:27:13,360 --> 00:27:16,799
all under application control

00:27:17,760 --> 00:27:21,440
so let's go back to our animation and

00:27:20,159 --> 00:27:23,760
let's highlight that

00:27:21,440 --> 00:27:25,679
first zone where we put up two qos

00:27:23,760 --> 00:27:28,159
domains within a single hardware

00:27:25,679 --> 00:27:28,159
device

00:27:29,200 --> 00:27:33,279
we're going to run two different

00:27:30,880 --> 00:27:34,480
identical read workloads in both of

00:27:33,279 --> 00:27:36,320
those zones

00:27:34,480 --> 00:27:38,080
and then we'll show you how you can

00:27:36,320 --> 00:27:40,240
adjust on the fly

00:27:38,080 --> 00:27:41,120
using software to control your latency

00:27:40,240 --> 00:27:43,919
outcomes now

00:27:41,120 --> 00:27:45,039
notice for zone one and zone two i have

00:27:43,919 --> 00:27:47,679
two

00:27:45,039 --> 00:27:48,399
identical sorry about that two identical

00:27:47,679 --> 00:27:50,720
read weights

00:27:48,399 --> 00:27:51,760
defined and you can see the latency in

00:27:50,720 --> 00:27:53,279
the chart

00:27:51,760 --> 00:27:55,360
they're both roughly equal they're

00:27:53,279 --> 00:27:58,159
slightly offset but roughly equal

00:27:55,360 --> 00:27:58,640
now through software we can go in and

00:27:58,159 --> 00:28:00,960
change

00:27:58,640 --> 00:28:02,640
what we expect in terms of weight for

00:28:00,960 --> 00:28:05,039
each of those zones and you can see in

00:28:02,640 --> 00:28:08,159
real time

00:28:05,039 --> 00:28:11,120
that latency profile changes on the i o

00:28:08,159 --> 00:28:13,200
in process we can flip it around we can

00:28:11,120 --> 00:28:14,880
change it again and continue to give

00:28:13,200 --> 00:28:18,240
more priority

00:28:14,880 --> 00:28:21,279
to zone one the red line this

00:28:18,240 --> 00:28:24,480
shows you that you have direct

00:28:21,279 --> 00:28:26,480
finite control over latency for every i

00:28:24,480 --> 00:28:27,679
o and workload going on and that control

00:28:26,480 --> 00:28:30,720
is accessible to you

00:28:27,679 --> 00:28:32,799
in real time through software a

00:28:30,720 --> 00:28:36,080
very powerful feature of the software

00:28:32,799 --> 00:28:36,080
defined flash api

00:28:39,840 --> 00:28:43,600
all right the next demo the last demo

00:28:42,399 --> 00:28:46,399
that we have to show you

00:28:43,600 --> 00:28:47,279
is the discussion on how we can offload

00:28:46,399 --> 00:28:50,000
the host

00:28:47,279 --> 00:28:50,960
resources so the host can concentrate on

00:28:50,000 --> 00:28:53,279
doing host things

00:28:50,960 --> 00:28:54,960
running your applications without having

00:28:53,279 --> 00:28:56,799
to worry about how to deal with low

00:28:54,960 --> 00:28:59,919
level housekeeping functions

00:28:56,799 --> 00:29:01,679
down at the flash device level we need

00:28:59,919 --> 00:29:03,760
to reduce that impact on the data

00:29:01,679 --> 00:29:05,440
management of the flash so the host

00:29:03,760 --> 00:29:07,520
cpu and memory can go off and do the

00:29:05,440 --> 00:29:10,080
things that he needs to be doing

00:29:07,520 --> 00:29:12,399
to run the application in this case

00:29:10,080 --> 00:29:15,120
we're going to run a garbage collecting

00:29:12,399 --> 00:29:16,960
a garbage collection example this would

00:29:15,120 --> 00:29:17,840
also work equally well for things like

00:29:16,960 --> 00:29:20,320
where leveling

00:29:17,840 --> 00:29:21,520
or for an application level database

00:29:20,320 --> 00:29:25,200
compaction style

00:29:21,520 --> 00:29:26,080
operation the first example of course is

00:29:25,200 --> 00:29:28,159
if we were to do

00:29:26,080 --> 00:29:30,399
all of the garbage collection activity

00:29:28,159 --> 00:29:32,480
manually we would have to go out and

00:29:30,399 --> 00:29:34,080
identify and read in all of the data

00:29:32,480 --> 00:29:36,080
that we need to recover

00:29:34,080 --> 00:29:37,440
collate that and write that back out to

00:29:36,080 --> 00:29:39,120
the flash device

00:29:37,440 --> 00:29:40,480
which then allows us to go up and free

00:29:39,120 --> 00:29:44,320
up those blocks for

00:29:40,480 --> 00:29:45,760
more writing in this case it of course

00:29:44,320 --> 00:29:47,520
takes host commands

00:29:45,760 --> 00:29:50,799
read commands write commands as well as

00:29:47,520 --> 00:29:50,799
use of host dram

00:29:50,880 --> 00:29:55,279
now a feature built into the api is

00:29:53,520 --> 00:29:56,880
something we call nameless copy which is

00:29:55,279 --> 00:30:00,240
a copy offload feature

00:29:56,880 --> 00:30:01,440
this allows us allows the host to send a

00:30:00,240 --> 00:30:04,000
single command by

00:30:01,440 --> 00:30:05,279
identifying what data needs to be

00:30:04,000 --> 00:30:07,840
collected

00:30:05,279 --> 00:30:08,960
and the device itself can go read all of

00:30:07,840 --> 00:30:11,520
that data collate it

00:30:08,960 --> 00:30:12,080
and store it in new flash blocks without

00:30:11,520 --> 00:30:13,919
using

00:30:12,080 --> 00:30:15,840
any additional host resources or

00:30:13,919 --> 00:30:17,440
overhead as you can see from the

00:30:15,840 --> 00:30:21,200
animation we've reduced

00:30:17,440 --> 00:30:24,240
a set of 20 commands down to one command

00:30:21,200 --> 00:30:26,320
this reduces that burden on the host cpu

00:30:24,240 --> 00:30:27,520
reduces the burden on the host for

00:30:26,320 --> 00:30:30,799
memory buffering

00:30:27,520 --> 00:30:33,440
as well as reduces that pcie bus nvme

00:30:30,799 --> 00:30:35,279
bus bandwidth

00:30:33,440 --> 00:30:36,880
and we have a functional demonstration

00:30:35,279 --> 00:30:39,440
for you here as well

00:30:36,880 --> 00:30:41,279
running on actual hardware so of course

00:30:39,440 --> 00:30:43,520
we have the manual copy on the left

00:30:41,279 --> 00:30:44,559
and the nameless copy on the right we're

00:30:43,520 --> 00:30:47,120
going to run two

00:30:44,559 --> 00:30:48,320
identical right workloads 100 right

00:30:47,120 --> 00:30:49,919
workloads

00:30:48,320 --> 00:30:52,080
and the workload is going to be larger

00:30:49,919 --> 00:30:52,799
than the video the available storage

00:30:52,080 --> 00:30:55,200
space

00:30:52,799 --> 00:30:56,480
in each of these two zones this will

00:30:55,200 --> 00:30:58,559
force us into a mode

00:30:56,480 --> 00:31:00,240
where we have to do garbage collection

00:30:58,559 --> 00:31:01,440
to finish the workload that's been

00:31:00,240 --> 00:31:05,679
defined

00:31:01,440 --> 00:31:07,760
so let's go ahead and kick off this test

00:31:05,679 --> 00:31:08,960
red of course is the right workload blue

00:31:07,760 --> 00:31:12,080
is the

00:31:08,960 --> 00:31:13,919
copy activity

00:31:12,080 --> 00:31:15,120
and you can see there's no copy activity

00:31:13,919 --> 00:31:16,720
on the nameless site because we're not

00:31:15,120 --> 00:31:17,519
actually moving data in and out of the

00:31:16,720 --> 00:31:20,000
host

00:31:17,519 --> 00:31:21,519
but the host of course is having to read

00:31:20,000 --> 00:31:23,440
and then rewrite data

00:31:21,519 --> 00:31:25,039
to free up that space for the next write

00:31:23,440 --> 00:31:27,440
operation

00:31:25,039 --> 00:31:28,799
the nameless copy uh operation is

00:31:27,440 --> 00:31:30,399
already completed

00:31:28,799 --> 00:31:32,320
this test normally takes about three

00:31:30,399 --> 00:31:35,760
minutes so we've accelerated it

00:31:32,320 --> 00:31:37,519
quite significantly now the manual copy

00:31:35,760 --> 00:31:38,880
operation has completed

00:31:37,519 --> 00:31:40,720
you can see that we've done a fair

00:31:38,880 --> 00:31:41,919
amount of reading and writing to move

00:31:40,720 --> 00:31:44,960
data

00:31:41,919 --> 00:31:46,960
and the the results here are

00:31:44,960 --> 00:31:49,440
for the manual copy operation to

00:31:46,960 --> 00:31:51,840
complete this workload we've issued 800

00:31:49,440 --> 00:31:53,360
000 commands and moved about three

00:31:51,840 --> 00:31:56,399
gigabytes worth of data

00:31:53,360 --> 00:32:00,000
to do this garbage collection operation

00:31:56,399 --> 00:32:03,120
for the nameless copy copy copy offload

00:32:00,000 --> 00:32:04,799
operation we've issued only 24 commands

00:32:03,120 --> 00:32:06,480
to do the same workload identical

00:32:04,799 --> 00:32:09,279
workload and

00:32:06,480 --> 00:32:11,679
those 24 commands used up only 128k of

00:32:09,279 --> 00:32:14,080
data across the bus

00:32:11,679 --> 00:32:14,880
and if you look at the cpu utilization

00:32:14,080 --> 00:32:17,840
chart

00:32:14,880 --> 00:32:19,440
that nameless copy operation has done so

00:32:17,840 --> 00:32:22,880
without using so many

00:32:19,440 --> 00:32:25,760
host cpu cycles so again

00:32:22,880 --> 00:32:26,880
copy offload capability built into the

00:32:25,760 --> 00:32:30,320
software

00:32:26,880 --> 00:32:33,440
enabled flash api gives you tremendous

00:32:30,320 --> 00:32:35,519
capabilities to reduce host overhead

00:32:33,440 --> 00:32:36,799
for things like garbage collection wear

00:32:35,519 --> 00:32:38,880
leveling and even

00:32:36,799 --> 00:32:43,840
application layer database level

00:32:38,880 --> 00:32:43,840
compaction operations

00:32:44,000 --> 00:32:47,360
there's actually quite a bit more to

00:32:45,760 --> 00:32:49,760
software enabled flash

00:32:47,360 --> 00:32:52,080
that i've been able to show you in this

00:32:49,760 --> 00:32:54,480
simple set of demonstrations

00:32:52,080 --> 00:32:56,720
very powerful capabilities built into

00:32:54,480 --> 00:32:59,840
the definition to handle almost

00:32:56,720 --> 00:33:01,600
every aspect of flash management and i o

00:32:59,840 --> 00:33:03,200
expectations that can come from any

00:33:01,600 --> 00:33:06,000
developer

00:33:03,200 --> 00:33:07,200
what i would like to highlight is item

00:33:06,000 --> 00:33:09,679
number seven

00:33:07,200 --> 00:33:11,679
again and talk a little bit about the

00:33:09,679 --> 00:33:13,919
abstraction of those flash generations

00:33:11,679 --> 00:33:15,600
the ability to change from flash

00:33:13,919 --> 00:33:17,440
generation flash generation whether

00:33:15,600 --> 00:33:20,159
you're using a tlc media

00:33:17,440 --> 00:33:21,360
or a qlc media whether using a gen 4 a

00:33:20,159 --> 00:33:24,960
gen 5 or a gen

00:33:21,360 --> 00:33:28,159
6 from the fab

00:33:24,960 --> 00:33:31,120
uh is a very important capability

00:33:28,159 --> 00:33:31,600
abstraction through the api allows us to

00:33:31,120 --> 00:33:33,279
deliver

00:33:31,600 --> 00:33:35,279
different types of flash as well as

00:33:33,279 --> 00:33:36,399
different vendors to deliver flash to

00:33:35,279 --> 00:33:37,919
the api

00:33:36,399 --> 00:33:39,840
so you the programmer don't have to

00:33:37,919 --> 00:33:42,480
worry about those level low level

00:33:39,840 --> 00:33:42,480
differences

00:33:44,399 --> 00:33:48,320
and that api abstraction can bring a

00:33:47,440 --> 00:33:50,559
bunch of

00:33:48,320 --> 00:33:52,480
very good benefits right software

00:33:50,559 --> 00:33:54,559
enabled flash technology

00:33:52,480 --> 00:33:56,000
is a software-defined flash approach and

00:33:54,559 --> 00:33:58,000
that abstraction

00:33:56,000 --> 00:33:59,760
can give you a tremendous advantage in

00:33:58,000 --> 00:34:01,760
your development activities for time to

00:33:59,760 --> 00:34:05,600
market

00:34:01,760 --> 00:34:08,159
bring your next level of flash to market

00:34:05,600 --> 00:34:09,440
extremely rapidly without having to deal

00:34:08,159 --> 00:34:13,119
with a lot of overhead

00:34:09,440 --> 00:34:15,040
programming activities and those

00:34:13,119 --> 00:34:17,040
overhead programming activities your

00:34:15,040 --> 00:34:19,440
resources your resource allocation

00:34:17,040 --> 00:34:20,720
which is your human resources can be

00:34:19,440 --> 00:34:23,200
used very efficiently

00:34:20,720 --> 00:34:24,720
those programmers those developers those

00:34:23,200 --> 00:34:26,480
resources can be focused

00:34:24,720 --> 00:34:28,240
on development where it matters most at

00:34:26,480 --> 00:34:30,320
the application layer

00:34:28,240 --> 00:34:31,599
without having to deal with low level

00:34:30,320 --> 00:34:34,720
flash semantics

00:34:31,599 --> 00:34:38,079
or changes to programming required to

00:34:34,720 --> 00:34:40,560
deploy that next generation flash

00:34:38,079 --> 00:34:42,240
and equally importantly is utilize and

00:34:40,560 --> 00:34:45,520
maximize the flash that you've

00:34:42,240 --> 00:34:47,760
acquired to its utmost capability

00:34:45,520 --> 00:34:49,839
remember as your workloads change you

00:34:47,760 --> 00:34:52,079
can change the protocols

00:34:49,839 --> 00:34:54,560
on that flash device simply by going in

00:34:52,079 --> 00:34:56,240
and changing a software driver

00:34:54,560 --> 00:34:59,839
you get a whole new use case through

00:34:56,240 --> 00:35:03,440
your flag through changing software

00:34:59,839 --> 00:35:05,040
we actually fundamentally believe that

00:35:03,440 --> 00:35:06,880
software enabled flash completely

00:35:05,040 --> 00:35:09,119
redefines that relationship

00:35:06,880 --> 00:35:11,520
between the host and its solid state

00:35:09,119 --> 00:35:11,520
storage

00:35:13,680 --> 00:35:17,280
now i did mention i would talk a little

00:35:15,040 --> 00:35:20,880
bit more about the open source aspects

00:35:17,280 --> 00:35:24,640
of the api we have available today

00:35:20,880 --> 00:35:26,400
out on github the api document itself

00:35:24,640 --> 00:35:27,520
all of the command sets are exposed

00:35:26,400 --> 00:35:29,200
already

00:35:27,520 --> 00:35:31,440
as well as a header file showing how the

00:35:29,200 --> 00:35:33,920
command sets are going to be implemented

00:35:31,440 --> 00:35:34,960
uh the api document and the header file

00:35:33,920 --> 00:35:37,359
are out and available

00:35:34,960 --> 00:35:38,320
using the bsd three clause open source

00:35:37,359 --> 00:35:40,560
license

00:35:38,320 --> 00:35:42,000
i invite everybody to go download these

00:35:40,560 --> 00:35:45,839
files and take a look at them

00:35:42,000 --> 00:35:45,839
and see how they go

00:35:46,000 --> 00:35:51,200
now we also know that in order for open

00:35:48,800 --> 00:35:53,359
source to work it has to be open

00:35:51,200 --> 00:35:54,480
it has available and it has to be

00:35:53,359 --> 00:35:55,920
neutral and we

00:35:54,480 --> 00:35:57,760
of course know that we're going to need

00:35:55,920 --> 00:35:59,280
multiple vendors and multiple sources of

00:35:57,760 --> 00:36:02,960
flash

00:35:59,280 --> 00:36:05,599
so we're currently out working with

00:36:02,960 --> 00:36:06,880
the linux community to create a project

00:36:05,599 --> 00:36:09,040
in the open

00:36:06,880 --> 00:36:10,160
source community for software enabled

00:36:09,040 --> 00:36:12,720
flash

00:36:10,160 --> 00:36:14,079
we need this open and legally neutral

00:36:12,720 --> 00:36:17,599
form to bring the talking

00:36:14,079 --> 00:36:20,400
technology forward so the industry and

00:36:17,599 --> 00:36:20,880
vendors collab uh competitors can work

00:36:20,400 --> 00:36:24,320
together

00:36:20,880 --> 00:36:26,480
to make this available to you the user

00:36:24,320 --> 00:36:28,320
we expect this community-based product

00:36:26,480 --> 00:36:30,079
project will be available and out in

00:36:28,320 --> 00:36:31,280
open source in the second half of this

00:36:30,079 --> 00:36:33,280
year

00:36:31,280 --> 00:36:34,800
and all of the sample source codes for

00:36:33,280 --> 00:36:36,240
the libraries and the drivers and the

00:36:34,800 --> 00:36:38,160
software development kit

00:36:36,240 --> 00:36:42,160
will be made available through this open

00:36:38,160 --> 00:36:42,160
source project when it is turned on

00:36:45,520 --> 00:36:50,720
so i'd like to thank everybody for

00:36:48,400 --> 00:36:52,000
attending this webinar session

00:36:50,720 --> 00:36:53,760
if you're looking for additional

00:36:52,000 --> 00:36:55,599
information on what software enabled

00:36:53,760 --> 00:36:57,200
flash is i'd like to highlight that

00:36:55,599 --> 00:36:59,920
there is a website available

00:36:57,200 --> 00:37:02,079
with lots of useful information software

00:36:59,920 --> 00:37:04,480
enabled flash.com

00:37:02,079 --> 00:37:05,440
there's white papers there's tech briefs

00:37:04,480 --> 00:37:07,440
there's a lot more

00:37:05,440 --> 00:37:09,440
videos on the functionality and the

00:37:07,440 --> 00:37:11,440
capability and demonstrations of how the

00:37:09,440 --> 00:37:13,839
hardware actually works

00:37:11,440 --> 00:37:16,000
and up on the website is also a link to

00:37:13,839 --> 00:37:18,560
the api

00:37:16,000 --> 00:37:19,520
once again thank you for sticking with

00:37:18,560 --> 00:37:22,000
me through this

00:37:19,520 --> 00:37:23,520
presentation in this webinar and we have

00:37:22,000 --> 00:37:25,599
some time left

00:37:23,520 --> 00:37:27,440
so i would like to open up the session

00:37:25,599 --> 00:37:31,280
for q a

00:37:27,440 --> 00:37:35,200
and in order to do it well i would

00:37:31,280 --> 00:37:36,880
like to invite my lead architect for

00:37:35,200 --> 00:37:39,839
software enabled flash to join me

00:37:36,880 --> 00:37:41,520
rory bolt rory bolt if you can unmute

00:37:39,839 --> 00:37:44,000
and come online and join me that would

00:37:41,520 --> 00:37:47,040
be fantastic

00:37:44,000 --> 00:37:48,960
well hello scott and uh yeah i'd be

00:37:47,040 --> 00:37:49,680
happy to answer any questions that we

00:37:48,960 --> 00:37:52,560
can

00:37:49,680 --> 00:37:52,560
in the remaining time

00:37:55,680 --> 00:38:03,200
okay so we've got an anonymous

00:38:00,960 --> 00:38:04,560
question here that says to adapt this

00:38:03,200 --> 00:38:07,520
api do we need

00:38:04,560 --> 00:38:09,520
a device with some special capability a

00:38:07,520 --> 00:38:10,000
device that exposes fine level control

00:38:09,520 --> 00:38:13,599
over

00:38:10,000 --> 00:38:16,640
device resources um good question

00:38:13,599 --> 00:38:18,960
and yes in fact

00:38:16,640 --> 00:38:19,760
software enabled flash is in fact a

00:38:18,960 --> 00:38:22,960
combination

00:38:19,760 --> 00:38:23,920
of both the software libraries and apis

00:38:22,960 --> 00:38:25,680
that we're defining

00:38:23,920 --> 00:38:27,920
as well as a new class of controllers

00:38:25,680 --> 00:38:32,320
which are not available yet but

00:38:27,920 --> 00:38:35,280
uh um are currently under development so

00:38:32,320 --> 00:38:36,960
um the good news is uh that that the

00:38:35,280 --> 00:38:39,040
plan is to have

00:38:36,960 --> 00:38:40,720
the software enabled flash devices

00:38:39,040 --> 00:38:42,800
available for multiple vendors

00:38:40,720 --> 00:38:44,000
uh so you'll have your choice of who you

00:38:42,800 --> 00:38:47,119
would like to buy this

00:38:44,000 --> 00:38:48,640
technology from but you will require a

00:38:47,119 --> 00:38:51,839
new class of device

00:38:48,640 --> 00:38:54,720
uh to enjoy these benefits because

00:38:51,839 --> 00:38:56,000
frankly they allow capabilities that

00:38:54,720 --> 00:39:00,960
existing

00:38:56,000 --> 00:39:03,280
ssds literally cannot do

00:39:00,960 --> 00:39:04,720
okay thank you rory there's actually

00:39:03,280 --> 00:39:06,240
another question from

00:39:04,720 --> 00:39:08,320
michael he's asking about the

00:39:06,240 --> 00:39:10,400
relationship with roxdb

00:39:08,320 --> 00:39:12,000
he's asking is it just a library that

00:39:10,400 --> 00:39:13,760
uses flash or is

00:39:12,000 --> 00:39:16,079
or is it using the apis that we've

00:39:13,760 --> 00:39:20,320
created

00:39:16,079 --> 00:39:23,520
so with respect to the uh roxdb

00:39:20,320 --> 00:39:24,400
example we've actually taken a branch

00:39:23,520 --> 00:39:28,960
off the

00:39:24,400 --> 00:39:32,240
main rocksdb repository and we have

00:39:28,960 --> 00:39:33,680
reworked roxdb to talk directly and

00:39:32,240 --> 00:39:38,160
natively to the ceph

00:39:33,680 --> 00:39:40,400
api in particular to take advantage of

00:39:38,160 --> 00:39:41,200
some huge gains that can be made in

00:39:40,400 --> 00:39:43,200
compaction

00:39:41,200 --> 00:39:44,480
and once again that uh source code

00:39:43,200 --> 00:39:46,800
branch is not

00:39:44,480 --> 00:39:48,240
available yet but will be uh it's

00:39:46,800 --> 00:39:50,320
planned to be published with with the

00:39:48,240 --> 00:39:53,760
actual sdk itself

00:39:50,320 --> 00:39:56,320
okay thank you uh another question is

00:39:53,760 --> 00:39:58,720
popped up from mirage he's asked

00:39:56,320 --> 00:39:59,359
how does the abstraction work how can we

00:39:58,720 --> 00:40:01,920
abstract

00:39:59,359 --> 00:40:02,880
different pcie generations gen four or

00:40:01,920 --> 00:40:05,760
five

00:40:02,880 --> 00:40:08,160
or differentiating the nand how does

00:40:05,760 --> 00:40:10,640
that actually work

00:40:08,160 --> 00:40:13,359
and further how does the developer

00:40:10,640 --> 00:40:13,359
leverage that

00:40:15,200 --> 00:40:19,599
okay um sorry things are scrolling off

00:40:18,640 --> 00:40:23,280
the screen here

00:40:19,599 --> 00:40:26,400
um so that i can't see that question

00:40:23,280 --> 00:40:28,880
uh let me see i want to make sure

00:40:26,400 --> 00:40:28,880
i uh

00:40:29,440 --> 00:40:35,680
i address it correctly here so um

00:40:32,480 --> 00:40:41,280
the actual abstraction of differences

00:40:35,680 --> 00:40:44,000
such as pcie gen 4 versus gen 5

00:40:41,280 --> 00:40:45,440
happen because we will have classes of

00:40:44,000 --> 00:40:48,880
controllers

00:40:45,440 --> 00:40:52,240
that implement the specific

00:40:48,880 --> 00:40:54,960
different hardware standards but all

00:40:52,240 --> 00:40:57,280
comply to the same software api so

00:40:54,960 --> 00:40:58,079
you write your software to the common

00:40:57,280 --> 00:41:00,400
api

00:40:58,079 --> 00:41:02,079
and then uh depending upon the

00:41:00,400 --> 00:41:05,920
capabilities of the device

00:41:02,079 --> 00:41:08,560
uh it will work uh

00:41:05,920 --> 00:41:09,839
with a variety of devices that applies

00:41:08,560 --> 00:41:11,680
to both

00:41:09,839 --> 00:41:13,839
pci generations as well as flash

00:41:11,680 --> 00:41:16,160
generations

00:41:13,839 --> 00:41:16,160
okay

00:41:18,720 --> 00:41:22,160
okay uh let's move on to another

00:41:21,440 --> 00:41:25,359
question

00:41:22,160 --> 00:41:27,119
um they're asking is this

00:41:25,359 --> 00:41:29,440
is there a flash emulator this is an

00:41:27,119 --> 00:41:31,680
anonymous question but is there a flash

00:41:29,440 --> 00:41:33,680
emulator that can be used to this class

00:41:31,680 --> 00:41:36,400
of device

00:41:33,680 --> 00:41:37,839
currently there is an emulator that we

00:41:36,400 --> 00:41:39,680
are using in-house

00:41:37,839 --> 00:41:41,520
as we're developing the the hardware and

00:41:39,680 --> 00:41:43,680
so that's very common

00:41:41,520 --> 00:41:46,000
uh because software usually uh leads the

00:41:43,680 --> 00:41:49,440
hardware in terms of of delivery

00:41:46,000 --> 00:41:51,040
um we do not know at this time whether

00:41:49,440 --> 00:41:55,040
or not we will uh

00:41:51,040 --> 00:41:56,880
be um commercializing or or

00:41:55,040 --> 00:41:58,160
commercialized by the wrong wrong word

00:41:56,880 --> 00:42:00,640
don't know if we'll be releasing the

00:41:58,160 --> 00:42:03,040
emulator or not

00:42:00,640 --> 00:42:03,839
yeah i think we will have uh actual

00:42:03,040 --> 00:42:06,240
devices

00:42:03,839 --> 00:42:08,240
within this year so an emulator may not

00:42:06,240 --> 00:42:11,520
be necessary

00:42:08,240 --> 00:42:13,920
right yeah okay uh another question

00:42:11,520 --> 00:42:15,119
also anonymous is is this different or

00:42:13,920 --> 00:42:18,480
how is this different from

00:42:15,119 --> 00:42:21,280
spdk so spdk

00:42:18,480 --> 00:42:21,839
is a wonderful package from from intel

00:42:21,280 --> 00:42:27,359
but

00:42:21,839 --> 00:42:32,800
spdk is concerned primarily with uh

00:42:27,359 --> 00:42:36,000
traditional storage devices so uh sbdk

00:42:32,800 --> 00:42:39,760
back-ends to classic hdds or or

00:42:36,000 --> 00:42:42,319
ssds uh whatever your storage is

00:42:39,760 --> 00:42:43,680
and allows you to layer functionality on

00:42:42,319 --> 00:42:45,280
top of that but

00:42:43,680 --> 00:42:48,000
fundamentally you're going to be limited

00:42:45,280 --> 00:42:51,040
by the capabilities of the back end

00:42:48,000 --> 00:42:52,319
store and so for the type of advanced uh

00:42:51,040 --> 00:42:53,839
latency queuing

00:42:52,319 --> 00:42:59,839
outcomes that we want to provide you

00:42:53,839 --> 00:42:59,839
actually need a new class of hardware

00:43:00,240 --> 00:43:04,880
uh let's see packaging hardware i think

00:43:03,119 --> 00:43:05,599
we've answered there should be hardware

00:43:04,880 --> 00:43:09,680
available

00:43:05,599 --> 00:43:11,839
uh by the end of this year uh

00:43:09,680 --> 00:43:13,680
is this supposed to be connected

00:43:11,839 --> 00:43:15,760
directly via pcie

00:43:13,680 --> 00:43:18,960
or something that goes into a box that's

00:43:15,760 --> 00:43:18,960
accessed over a sam

00:43:21,040 --> 00:43:26,880
so the answer is so

00:43:24,400 --> 00:43:27,520
it depends on on that one so it is in

00:43:26,880 --> 00:43:30,079
fact

00:43:27,520 --> 00:43:32,319
at its core a pce device that can be

00:43:30,079 --> 00:43:34,880
accessed directly over pcie

00:43:32,319 --> 00:43:36,880
or could actually be used as a internal

00:43:34,880 --> 00:43:40,640
component if you were building

00:43:36,880 --> 00:43:45,119
uh some type of of external san type

00:43:40,640 --> 00:43:48,000
box or nvme of type box

00:43:45,119 --> 00:43:49,280
so you know for a typical hyperscale

00:43:48,000 --> 00:43:52,880
application

00:43:49,280 --> 00:43:54,640
they tend to use direct attached storage

00:43:52,880 --> 00:43:57,920
and would be accessing it directly

00:43:54,640 --> 00:44:01,200
over the pcie bus but there

00:43:57,920 --> 00:44:04,960
are storage vendors

00:44:01,200 --> 00:44:07,359
that produce external aggregations of

00:44:04,960 --> 00:44:07,359
storage

00:44:07,760 --> 00:44:13,520
arrays if you will that are also

00:44:10,319 --> 00:44:13,520
interested in this technology

00:44:15,440 --> 00:44:20,560
great so there are no more open

00:44:18,640 --> 00:44:22,319
questions at the moment

00:44:20,560 --> 00:44:23,839
i would like to thank everybody that has

00:44:22,319 --> 00:44:25,920
joined the webinar uh

00:44:23,839 --> 00:44:28,079
if more questions pop up we'll we'll go

00:44:25,920 --> 00:44:29,119
ahead and answer those uh before we sign

00:44:28,079 --> 00:44:31,200
off

00:44:29,119 --> 00:44:32,160
but uh as rory's identified this is a

00:44:31,200 --> 00:44:34,640
very uh

00:44:32,160 --> 00:44:35,680
interesting and new approach to using

00:44:34,640 --> 00:44:38,160
flash

00:44:35,680 --> 00:44:39,520
as flash itself rather than from the hdd

00:44:38,160 --> 00:44:42,560
paradigm

00:44:39,520 --> 00:44:44,960
uh it's available and uh out in open

00:44:42,560 --> 00:44:47,440
source for any storage developer

00:44:44,960 --> 00:44:49,119
uh i guess we do have a new question uh

00:44:47,440 --> 00:44:50,160
how do you foresee this class of

00:44:49,119 --> 00:44:53,920
hardware

00:44:50,160 --> 00:44:56,880
to work with nvme over fabric

00:44:53,920 --> 00:44:57,359
um actually uh i think it's going to

00:44:56,880 --> 00:45:00,240
work

00:44:57,359 --> 00:45:00,640
fairly transparently with nvme off the

00:45:00,240 --> 00:45:04,000
first

00:45:00,640 --> 00:45:07,359
version of the api is dealing with

00:45:04,000 --> 00:45:11,040
um direct attach

00:45:07,359 --> 00:45:12,640
however um it's my personal belief this

00:45:11,040 --> 00:45:14,000
is so don't consider this as a

00:45:12,640 --> 00:45:16,960
any sort of product commitment but it's

00:45:14,000 --> 00:45:18,240
my personal belief that the logical next

00:45:16,960 --> 00:45:20,079
step for this is dealing with

00:45:18,240 --> 00:45:21,520
aggregations of these devices in a

00:45:20,079 --> 00:45:23,760
networked environment and of course

00:45:21,520 --> 00:45:24,079
nvmeof would be the logical choice for

00:45:23,760 --> 00:45:26,800
that

00:45:24,079 --> 00:45:28,560
so um i'll take that as a very leading

00:45:26,800 --> 00:45:29,839
question and i gave you a very leading

00:45:28,560 --> 00:45:33,599
answer

00:45:29,839 --> 00:45:36,079
i'll be a personal opinion

00:45:33,599 --> 00:45:37,280
thank you rory you know i think we

00:45:36,079 --> 00:45:39,839
always envisioned

00:45:37,280 --> 00:45:41,359
the software enabled flash approach both

00:45:39,839 --> 00:45:43,520
the hardware and the software to be a

00:45:41,359 --> 00:45:45,359
building block for delivering

00:45:43,520 --> 00:45:46,560
larger and better storage type of

00:45:45,359 --> 00:45:48,480
devices

00:45:46,560 --> 00:45:50,640
so as a building block we can deliver a

00:45:48,480 --> 00:45:51,440
traditional ssd or something completely

00:45:50,640 --> 00:45:54,480
custom

00:45:51,440 --> 00:45:55,440
or as you've identified a nvme over

00:45:54,480 --> 00:45:59,599
fabric

00:45:55,440 --> 00:46:02,319
approach as well there's a question from

00:45:59,599 --> 00:46:03,359
jan asking if it can implement a key

00:46:02,319 --> 00:46:05,280
value store

00:46:03,359 --> 00:46:07,359
i i can go ahead and answer this one of

00:46:05,280 --> 00:46:10,720
course it's all driven by

00:46:07,359 --> 00:46:12,480
software a software driver can be put in

00:46:10,720 --> 00:46:13,200
place that would allow that key value

00:46:12,480 --> 00:46:16,319
store

00:46:13,200 --> 00:46:17,920
to be deployed as a protocol and if you

00:46:16,319 --> 00:46:20,400
think about it that key value store

00:46:17,920 --> 00:46:23,680
could benefit tremendously from those

00:46:20,400 --> 00:46:24,560
host offload functions imaging a key

00:46:23,680 --> 00:46:26,960
move function

00:46:24,560 --> 00:46:27,920
being done wholly within the device

00:46:26,960 --> 00:46:29,920
using that coffee

00:46:27,920 --> 00:46:31,680
offload feature rory do you want to

00:46:29,920 --> 00:46:34,720
expand on that

00:46:31,680 --> 00:46:37,440
all right i think that's a good start um

00:46:34,720 --> 00:46:39,680
so yes uh key value stores um are

00:46:37,440 --> 00:46:42,319
actually something that that

00:46:39,680 --> 00:46:43,440
we have uh considered from actually the

00:46:42,319 --> 00:46:47,040
inception

00:46:43,440 --> 00:46:47,040
um and uh

00:46:48,000 --> 00:46:52,000
there are a number of possibilities uh i

00:46:50,319 --> 00:46:54,000
know that that there are some internal

00:46:52,000 --> 00:46:57,040
skunk works projects uh

00:46:54,000 --> 00:46:59,440
within kyokushin kyocha to develop

00:46:57,040 --> 00:47:01,040
a key value store that may in fact end

00:46:59,440 --> 00:47:04,319
up as an example

00:47:01,040 --> 00:47:04,319
in the sdk itself

00:47:06,720 --> 00:47:10,000
great i think with that we're running

00:47:09,599 --> 00:47:12,480
low

00:47:10,000 --> 00:47:14,079
on time and we are out of questions at

00:47:12,480 --> 00:47:16,720
this point as well

00:47:14,079 --> 00:47:17,200
so i'd like to pass it back to christine

00:47:16,720 --> 00:47:20,160
on the

00:47:17,200 --> 00:47:21,359
linux foundation for any uh closing

00:47:20,160 --> 00:47:22,400
activity that we need to do for

00:47:21,359 --> 00:47:23,839
housekeeping

00:47:22,400 --> 00:47:25,680
once again thank you everybody for

00:47:23,839 --> 00:47:28,480
joining us please feel

00:47:25,680 --> 00:47:29,680
free to reach out to us uh with any

00:47:28,480 --> 00:47:31,839
questions that you may have

00:47:29,680 --> 00:47:33,680
we love to pick up questions you can do

00:47:31,839 --> 00:47:37,040
that either through the

00:47:33,680 --> 00:47:38,880
github site or uh through contacts

00:47:37,040 --> 00:47:40,319
available to you from the software

00:47:38,880 --> 00:47:42,640
anywhere flash.com

00:47:40,319 --> 00:47:46,000
website once again thank you very much

00:47:42,640 --> 00:47:48,559
this is scott stetzer signing off

00:47:46,000 --> 00:47:49,839
thank you so much to scott for his time

00:47:48,559 --> 00:47:51,440
today and thank you to all the

00:47:49,839 --> 00:47:54,160
participants who joined us

00:47:51,440 --> 00:47:55,839
and as a reminder this recording will be

00:47:54,160 --> 00:47:57,040
on the linux foundation youtube page

00:47:55,839 --> 00:47:58,480
later today

00:47:57,040 --> 00:48:01,680
and we hope that you're able to join us

00:47:58,480 --> 00:48:05,680
for future webinars have a wonderful day

00:48:01,680 --> 00:48:05,680

YouTube URL: https://www.youtube.com/watch?v=87sZ-gSmzNY


