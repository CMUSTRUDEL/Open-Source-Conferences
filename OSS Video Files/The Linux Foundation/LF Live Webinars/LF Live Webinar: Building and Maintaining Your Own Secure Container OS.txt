Title: LF Live Webinar: Building and Maintaining Your Own Secure Container OS
Publication date: 2021-05-13
Playlist: LF Live Webinars
Description: 
	sponsored by AWS

Bottlerocket is a free and open-source Linux-based operating system meant for hosting containers. Join us as we walk through the Bottlerocket build process and common customizations including: how to add new configuration options, how to add security policy and more!
Captions: 
	00:00:00,080 --> 00:00:03,360
awesome thanks christina and thanks

00:00:01,760 --> 00:00:04,799
everyone for joining me to

00:00:03,360 --> 00:00:06,879
today and this morning or this evening

00:00:04,799 --> 00:00:07,359
or wherever you are and um i hope this

00:00:06,879 --> 00:00:09,440
is a

00:00:07,359 --> 00:00:11,120
an interesting topic for some of you but

00:00:09,440 --> 00:00:12,960
today i'm going to be talking about

00:00:11,120 --> 00:00:14,160
uh building and maintaining your own

00:00:12,960 --> 00:00:16,080
secure container os

00:00:14,160 --> 00:00:19,119
and the the example that we're going to

00:00:16,080 --> 00:00:21,520
use is is bottle rocket os

00:00:19,119 --> 00:00:22,880
um and to to kind of dive right in i

00:00:21,520 --> 00:00:24,800
want to give a bit of an explanation as

00:00:22,880 --> 00:00:28,240
to to what bottle rocket is

00:00:24,800 --> 00:00:30,400
um so i'll talk about that first um and

00:00:28,240 --> 00:00:32,320
essentially bottle rocket is a minimal

00:00:30,400 --> 00:00:33,760
and secure linux operating system

00:00:32,320 --> 00:00:35,440
that's been purpose built from the

00:00:33,760 --> 00:00:37,760
ground up for running containers

00:00:35,440 --> 00:00:39,360
um it's secure by design and follows

00:00:37,760 --> 00:00:40,000
some of the best practices for container

00:00:39,360 --> 00:00:41,200
security

00:00:40,000 --> 00:00:42,399
so it only includes the tools that are

00:00:41,200 --> 00:00:44,160
needed to run containers and

00:00:42,399 --> 00:00:46,160
significantly reduces the attack surface

00:00:44,160 --> 00:00:48,399
and impact for vulnerabilities

00:00:46,160 --> 00:00:49,520
and by virtue of being minimal uh nodes

00:00:48,399 --> 00:00:52,000
running bottle rocket

00:00:49,520 --> 00:00:53,760
have uh essentially a fast boot time and

00:00:52,000 --> 00:00:54,559
are thus able to enable clusters to

00:00:53,760 --> 00:00:56,800
scale

00:00:54,559 --> 00:00:59,280
uh quickly in varying traffic patterns

00:00:56,800 --> 00:01:02,239
or workloads as those change

00:00:59,280 --> 00:01:03,920
so in conjunction with an orchestrator

00:01:02,239 --> 00:01:05,199
bottle rocket enables various update

00:01:03,920 --> 00:01:06,640
strategies

00:01:05,199 --> 00:01:09,119
to new versions of the software with

00:01:06,640 --> 00:01:10,880
little to no operational overhead

00:01:09,119 --> 00:01:14,320
node level updates are essentially

00:01:10,880 --> 00:01:16,960
handled in an atomic manner and provide

00:01:14,320 --> 00:01:19,520
safe and safety and visibility and

00:01:16,960 --> 00:01:21,520
throughout the entire update process

00:01:19,520 --> 00:01:22,720
and customers can always have

00:01:21,520 --> 00:01:24,320
essentially the latest and greatest

00:01:22,720 --> 00:01:26,240
version of the os running on their hosts

00:01:24,320 --> 00:01:28,880
with with minimal effort and i'm going

00:01:26,240 --> 00:01:30,560
to dive into some of these a little bit

00:01:28,880 --> 00:01:32,320
after this so i'm going to breeze

00:01:30,560 --> 00:01:33,759
through these a little bit more

00:01:32,320 --> 00:01:35,360
but separately bottle rocket also

00:01:33,759 --> 00:01:36,000
provides a suite of tools that help

00:01:35,360 --> 00:01:37,920
users

00:01:36,000 --> 00:01:40,000
build a custom community supported

00:01:37,920 --> 00:01:41,680
variant of the operating system

00:01:40,000 --> 00:01:42,640
directly from the source on github and

00:01:41,680 --> 00:01:44,640
that's going to be the bulk of what

00:01:42,640 --> 00:01:47,200
we're going to talk about today

00:01:44,640 --> 00:01:48,320
but before we really kind of dive into

00:01:47,200 --> 00:01:51,840
that i want to

00:01:48,320 --> 00:01:52,960
touch on some of these first and so

00:01:51,840 --> 00:01:54,159
one of the first areas that we want to

00:01:52,960 --> 00:01:54,880
talk about with bottle rocket is

00:01:54,159 --> 00:01:58,159
security

00:01:54,880 --> 00:02:00,159
um out of the out of the gates

00:01:58,159 --> 00:02:02,159
um and actually we've got a question

00:02:00,159 --> 00:02:02,880
that i jose i will get to your question

00:02:02,159 --> 00:02:04,960
in a little bit

00:02:02,880 --> 00:02:06,399
um it is a good question and then we'll

00:02:04,960 --> 00:02:09,520
talk to that

00:02:06,399 --> 00:02:11,200
probably a little a little length um

00:02:09,520 --> 00:02:12,800
but the idea is we wanted to build a

00:02:11,200 --> 00:02:14,879
secure operating system

00:02:12,800 --> 00:02:16,640
um straight out of the gates everything

00:02:14,879 --> 00:02:17,599
that we build at aws is essentially

00:02:16,640 --> 00:02:18,879
security first

00:02:17,599 --> 00:02:21,360
and so we wanted to build an operating

00:02:18,879 --> 00:02:23,920
system that focused on that as well

00:02:21,360 --> 00:02:24,480
and so we built it with fc linux in an

00:02:23,920 --> 00:02:26,959
um

00:02:24,480 --> 00:02:27,760
enabled and an enforcing mode by default

00:02:26,959 --> 00:02:29,760
so the

00:02:27,760 --> 00:02:31,760
the goal of the sc linux policy here is

00:02:29,760 --> 00:02:32,959
to to really separate the containers

00:02:31,760 --> 00:02:34,239
that are going to be running on that

00:02:32,959 --> 00:02:36,160
particular host

00:02:34,239 --> 00:02:37,760
from the underlying operating system

00:02:36,160 --> 00:02:39,360
itself and

00:02:37,760 --> 00:02:41,200
if you have scenarios where you need to

00:02:39,360 --> 00:02:43,280
elevate permissions um

00:02:41,200 --> 00:02:44,319
and uh gain additional permissions for

00:02:43,280 --> 00:02:45,280
the workloads that are on that running

00:02:44,319 --> 00:02:46,720
on that we want to provide the

00:02:45,280 --> 00:02:47,920
flexibility to be able to do that

00:02:46,720 --> 00:02:50,080
so there are ways to elevate your

00:02:47,920 --> 00:02:51,040
permissions but by default we want to

00:02:50,080 --> 00:02:52,959
make sure that we're

00:02:51,040 --> 00:02:54,959
separating those workloads as much as

00:02:52,959 --> 00:02:56,239
possible for safety and security

00:02:54,959 --> 00:02:59,120
concerns

00:02:56,239 --> 00:03:00,560
in addition to that we have treated the

00:02:59,120 --> 00:03:02,080
operating system much like we treat the

00:03:00,560 --> 00:03:03,040
workloads that are running on it so

00:03:02,080 --> 00:03:06,080
typically when you're building a

00:03:03,040 --> 00:03:09,519
container workload you want them to be

00:03:06,080 --> 00:03:12,640
read-only so the the the file system for

00:03:09,519 --> 00:03:14,879
bottle rocket is largely read only it's

00:03:12,640 --> 00:03:15,920
it's using something like something

00:03:14,879 --> 00:03:18,800
called dm verity

00:03:15,920 --> 00:03:19,360
which allows us to check a hash on every

00:03:18,800 --> 00:03:22,319
block

00:03:19,360 --> 00:03:24,159
that is written on the the disk um and

00:03:22,319 --> 00:03:27,280
if any changes are actually made

00:03:24,159 --> 00:03:29,280
to the the disk or the file system those

00:03:27,280 --> 00:03:32,000
are detected on read and the io

00:03:29,280 --> 00:03:33,920
operation is actually blocked and so

00:03:32,000 --> 00:03:35,920
what this allows you to do is detect if

00:03:33,920 --> 00:03:38,400
there is any changes that have occurred

00:03:35,920 --> 00:03:39,519
on your system and flag that system for

00:03:38,400 --> 00:03:42,319
being able to be

00:03:39,519 --> 00:03:43,599
quarantined and you know have a security

00:03:42,319 --> 00:03:46,080
team basically

00:03:43,599 --> 00:03:46,959
do a root cause analysis on it but we

00:03:46,080 --> 00:03:50,159
understand

00:03:46,959 --> 00:03:52,640
that you know as an operating system

00:03:50,159 --> 00:03:53,680
we actually do need some ability to

00:03:52,640 --> 00:03:56,560
write

00:03:53,680 --> 00:03:58,080
configurations so a folder like etsy for

00:03:56,560 --> 00:03:59,680
example which is where

00:03:58,080 --> 00:04:01,040
the system holds all the configuration

00:03:59,680 --> 00:04:01,920
for the applications that are running on

00:04:01,040 --> 00:04:04,959
the on the

00:04:01,920 --> 00:04:06,879
the operating system um we need to be

00:04:04,959 --> 00:04:08,720
able to make that writable but leaving

00:04:06,879 --> 00:04:10,400
it writable is essentially a risk and so

00:04:08,720 --> 00:04:13,760
what we've done is we've made it

00:04:10,400 --> 00:04:16,079
essentially a stateless file system

00:04:13,760 --> 00:04:17,600
that is empty at boot and we use a

00:04:16,079 --> 00:04:19,919
number of various helper programs to

00:04:17,600 --> 00:04:22,400
populate it with necessary components

00:04:19,919 --> 00:04:24,000
when you actually build your image and

00:04:22,400 --> 00:04:28,880
when you boot it up

00:04:24,000 --> 00:04:30,320
so essentially it starts blank and

00:04:28,880 --> 00:04:31,919
populates with the things that you need

00:04:30,320 --> 00:04:33,840
to be able to run successfully

00:04:31,919 --> 00:04:35,840
um and this these kind of these three

00:04:33,840 --> 00:04:37,680
things really do help make sure that

00:04:35,840 --> 00:04:38,639
changes can't be made on the system

00:04:37,680 --> 00:04:40,000
itself

00:04:38,639 --> 00:04:41,840
and if they are made you can detect them

00:04:40,000 --> 00:04:43,840
pretty quickly so this this

00:04:41,840 --> 00:04:45,440
security first kind of mindset really is

00:04:43,840 --> 00:04:46,960
pervasive throughout the os

00:04:45,440 --> 00:04:48,960
in addition to that we don't include any

00:04:46,960 --> 00:04:50,320
shells or interpreters so there's no way

00:04:48,960 --> 00:04:52,400
for you to actually log into the

00:04:50,320 --> 00:04:54,080
underlying host os directly

00:04:52,400 --> 00:04:55,840
we have mechanisms for that that i'll

00:04:54,080 --> 00:04:57,759
talk about in a moment

00:04:55,840 --> 00:04:59,040
but for the most part everything is is

00:04:57,759 --> 00:05:00,880
is walled off and

00:04:59,040 --> 00:05:03,280
even things like the the binaries that

00:05:00,880 --> 00:05:05,199
we've we've included within it

00:05:03,280 --> 00:05:06,639
those are built with hardened flags to

00:05:05,199 --> 00:05:07,600
ensure that they can't be leveraged or

00:05:06,639 --> 00:05:10,639
abused

00:05:07,600 --> 00:05:12,160
as best as possible we also wanted the

00:05:10,639 --> 00:05:13,600
operating system to be flexible

00:05:12,160 --> 00:05:15,759
so we understand there's multiple

00:05:13,600 --> 00:05:17,120
orchestration orchestrators for

00:05:15,759 --> 00:05:18,479
containers there's multiple cloud

00:05:17,120 --> 00:05:19,759
environments

00:05:18,479 --> 00:05:21,520
we wanted to be able to build an

00:05:19,759 --> 00:05:24,400
operating system that could support that

00:05:21,520 --> 00:05:26,080
so we allow for these things these these

00:05:24,400 --> 00:05:26,720
different builds and we refer to them as

00:05:26,080 --> 00:05:29,520
variants

00:05:26,720 --> 00:05:30,639
so every variant of bottle rocket is

00:05:29,520 --> 00:05:33,919
essentially

00:05:30,639 --> 00:05:37,280
a combination of software uh settings

00:05:33,919 --> 00:05:39,759
and disk layouts that are then used to

00:05:37,280 --> 00:05:42,560
build an actual image of the os

00:05:39,759 --> 00:05:44,160
and so um i think the easiest way to

00:05:42,560 --> 00:05:45,759
think of bottle rocket in this kind of

00:05:44,160 --> 00:05:47,840
context is that bottle rocket

00:05:45,759 --> 00:05:50,000
is essentially a container hose to us

00:05:47,840 --> 00:05:51,600
builder so you provide your spec

00:05:50,000 --> 00:05:54,000
you provide your settings and then you

00:05:51,600 --> 00:05:56,800
actually use the bottle rocket sdk

00:05:54,000 --> 00:05:58,319
to actually build the finalized os that

00:05:56,800 --> 00:06:00,479
you're going to use

00:05:58,319 --> 00:06:04,800
or you can leverage one that say like we

00:06:00,479 --> 00:06:04,800
provide through aws for running on aws

00:06:04,840 --> 00:06:09,039
um in addition to

00:06:07,600 --> 00:06:10,639
like i said like we've got security

00:06:09,039 --> 00:06:12,800
we've got the flexibility what we also

00:06:10,639 --> 00:06:15,759
wanted to do is make sure that updates

00:06:12,800 --> 00:06:17,120
um were were easy and and uh far more

00:06:15,759 --> 00:06:19,280
simplified than what you would get with

00:06:17,120 --> 00:06:21,919
something like a general purpose os

00:06:19,280 --> 00:06:22,560
and so for this we're using the update

00:06:21,919 --> 00:06:25,199
framework

00:06:22,560 --> 00:06:26,720
um and this allows us to create secure

00:06:25,199 --> 00:06:29,039
repositories for updates

00:06:26,720 --> 00:06:30,639
so that if a bottle orchid host needs to

00:06:29,039 --> 00:06:32,319
download a new version

00:06:30,639 --> 00:06:34,800
it can do so in a way that we can ensure

00:06:32,319 --> 00:06:35,840
there aren't um or there's minimized

00:06:34,800 --> 00:06:38,479
opportunities for

00:06:35,840 --> 00:06:39,919
uh security concerns in between like say

00:06:38,479 --> 00:06:43,440
during a poll of

00:06:39,919 --> 00:06:45,520
a particular um update version we verify

00:06:43,440 --> 00:06:46,560
uh crypto cryptographic keys and make

00:06:45,520 --> 00:06:48,240
sure that you're pulling from the right

00:06:46,560 --> 00:06:51,680
location

00:06:48,240 --> 00:06:52,800
the the updates themselves are handled

00:06:51,680 --> 00:06:54,880
in an atomic way

00:06:52,800 --> 00:06:57,520
so rather than like a general purpose os

00:06:54,880 --> 00:06:59,199
where um you might have one package that

00:06:57,520 --> 00:07:01,039
has an update and then that has

00:06:59,199 --> 00:07:02,639
50 dependencies downstream from it that

00:07:01,039 --> 00:07:04,400
also have updates and before you know it

00:07:02,639 --> 00:07:06,880
you know a simple update process is

00:07:04,400 --> 00:07:07,599
you're validating thousands of packages

00:07:06,880 --> 00:07:09,360
um

00:07:07,599 --> 00:07:11,199
the the way this works is it actually

00:07:09,360 --> 00:07:14,000
downloads a full image of the

00:07:11,199 --> 00:07:14,400
the the updated os to another partition

00:07:14,000 --> 00:07:16,880
on

00:07:14,400 --> 00:07:17,520
the the host itself and so you imagine

00:07:16,880 --> 00:07:18,720
you have your

00:07:17,520 --> 00:07:20,240
your partition that's running the

00:07:18,720 --> 00:07:21,680
operating system and then you've got a

00:07:20,240 --> 00:07:23,919
secondary partition

00:07:21,680 --> 00:07:26,080
it'll actually stage a new version of

00:07:23,919 --> 00:07:27,840
the os on that secondary partition and

00:07:26,080 --> 00:07:28,720
we use a tool called updog that actually

00:07:27,840 --> 00:07:30,319
handles

00:07:28,720 --> 00:07:32,560
swapping of the priority of those

00:07:30,319 --> 00:07:32,960
partitions will go through and validate

00:07:32,560 --> 00:07:34,800
that

00:07:32,960 --> 00:07:36,240
the the download is complete and it'll

00:07:34,800 --> 00:07:38,800
actually handle um

00:07:36,240 --> 00:07:40,560
the reboot and any particular failures

00:07:38,800 --> 00:07:41,759
that might occur during a reboot so

00:07:40,560 --> 00:07:42,960
if it detects that there's an issue

00:07:41,759 --> 00:07:44,560
it'll automatically roll back to the

00:07:42,960 --> 00:07:47,199
previous partition

00:07:44,560 --> 00:07:47,199
and you're good to go

00:07:47,759 --> 00:07:51,599
um and so we've got a couple questions

00:07:50,319 --> 00:07:53,360
so we've already talked about a little

00:07:51,599 --> 00:07:56,000
bit about variants

00:07:53,360 --> 00:07:57,360
and we've got another question here so

00:07:56,000 --> 00:07:58,000
the first question is you know is bottle

00:07:57,360 --> 00:08:01,520
rocket available

00:07:58,000 --> 00:08:03,120
out to run outside of aws um today it is

00:08:01,520 --> 00:08:05,840
not but that is the long-term goal

00:08:03,120 --> 00:08:09,039
so we want to be able to give you the

00:08:05,840 --> 00:08:11,759
flexibility to produce

00:08:09,039 --> 00:08:13,440
variants that will run on bare metal

00:08:11,759 --> 00:08:16,240
that'll run on other clouds

00:08:13,440 --> 00:08:17,039
that will run on prem um what we've

00:08:16,240 --> 00:08:18,800
started with

00:08:17,039 --> 00:08:20,720
because we're producing this we've

00:08:18,800 --> 00:08:22,800
started with our two orchestrators first

00:08:20,720 --> 00:08:23,440
so we've got eks and ecs that we support

00:08:22,800 --> 00:08:25,280
today

00:08:23,440 --> 00:08:26,879
and i'll go into that a little bit more

00:08:25,280 --> 00:08:28,879
but the long-term goal is to support

00:08:26,879 --> 00:08:30,800
variants and build variants that can run

00:08:28,879 --> 00:08:32,640
in wherever your containers are running

00:08:30,800 --> 00:08:34,719
so that's kind of the long-term goal

00:08:32,640 --> 00:08:36,080
and then the second question we have is

00:08:34,719 --> 00:08:36,880
why would we need bottle rocket if we

00:08:36,080 --> 00:08:38,719
already have linux

00:08:36,880 --> 00:08:40,800
operating systems with container docker

00:08:38,719 --> 00:08:42,240
engines installed on them

00:08:40,800 --> 00:08:44,320
and that's what i'm going to dive into a

00:08:42,240 --> 00:08:46,640
little bit right here

00:08:44,320 --> 00:08:47,839
and so because we've stripped everything

00:08:46,640 --> 00:08:49,839
out of the operating system

00:08:47,839 --> 00:08:51,680
this only includes the things that are

00:08:49,839 --> 00:08:54,080
necessary to run

00:08:51,680 --> 00:08:55,440
containers so basically there's no

00:08:54,080 --> 00:08:56,560
additional binaries and libraries

00:08:55,440 --> 00:08:58,000
there's no

00:08:56,560 --> 00:08:59,760
package management solution there's

00:08:58,000 --> 00:09:02,160
nothing installed on that os

00:08:59,760 --> 00:09:04,480
and outside of what the specific

00:09:02,160 --> 00:09:06,959
configuration for that variant is

00:09:04,480 --> 00:09:07,519
and essentially play docker or container

00:09:06,959 --> 00:09:10,320
d

00:09:07,519 --> 00:09:12,560
and so um with our the way we've

00:09:10,320 --> 00:09:13,519
provisioned our variants for eks and ecs

00:09:12,560 --> 00:09:15,920
is there's essentially

00:09:13,519 --> 00:09:17,440
two container runtimes on that host so

00:09:15,920 --> 00:09:18,880
there's the run time for the scheduled

00:09:17,440 --> 00:09:20,399
workloads so those that your

00:09:18,880 --> 00:09:23,440
orchestrators are going to be

00:09:20,399 --> 00:09:24,160
placing tasks or scheduling pods on and

00:09:23,440 --> 00:09:26,399
then we have

00:09:24,160 --> 00:09:27,920
essentially another another runtime that

00:09:26,399 --> 00:09:30,240
is

00:09:27,920 --> 00:09:31,680
separate from that that runs the

00:09:30,240 --> 00:09:34,640
administration tasks

00:09:31,680 --> 00:09:37,440
on the host itself so by doing this

00:09:34,640 --> 00:09:39,200
we're providing a far more secure

00:09:37,440 --> 00:09:41,760
environment for running your containers

00:09:39,200 --> 00:09:44,640
that is far more lightweight

00:09:41,760 --> 00:09:46,080
it comes with security options because

00:09:44,640 --> 00:09:47,920
security configuration

00:09:46,080 --> 00:09:49,680
out of the box without you having to

00:09:47,920 --> 00:09:51,279
necessarily do anything additional

00:09:49,680 --> 00:09:53,040
which you would typically have to do is

00:09:51,279 --> 00:09:54,640
in what we would call undifferentiated

00:09:53,040 --> 00:09:56,080
heavy lifting if you were using a more

00:09:54,640 --> 00:09:57,600
general purpose os and so

00:09:56,080 --> 00:10:00,080
what this does is it gives you these

00:09:57,600 --> 00:10:00,959
degrees and a foundation of security to

00:10:00,080 --> 00:10:03,440
start

00:10:00,959 --> 00:10:04,240
um for your container workloads on day

00:10:03,440 --> 00:10:05,600
one with

00:10:04,240 --> 00:10:08,079
versus having to figure this out and

00:10:05,600 --> 00:10:09,200
kind of grow it on your own organically

00:10:08,079 --> 00:10:12,079
and so it gives you a lot of benefit

00:10:09,200 --> 00:10:14,880
there but the idea is

00:10:12,079 --> 00:10:15,279
we've built this to be flexible secure

00:10:14,880 --> 00:10:17,920
and

00:10:15,279 --> 00:10:19,200
allow for you to have some access to the

00:10:17,920 --> 00:10:21,120
underlying host for things like

00:10:19,200 --> 00:10:23,120
development debugging troubleshooting

00:10:21,120 --> 00:10:24,640
um on the host itself like i said we've

00:10:23,120 --> 00:10:26,160
got the the runtime

00:10:24,640 --> 00:10:27,760
specifically for your workloads and

00:10:26,160 --> 00:10:29,440
we've got what we call host containers

00:10:27,760 --> 00:10:32,560
and there's a runtime of container d

00:10:29,440 --> 00:10:34,079
or docker specifically for the the host

00:10:32,560 --> 00:10:35,600
containers and we have

00:10:34,079 --> 00:10:36,880
two that we basically provide but you

00:10:35,600 --> 00:10:37,360
can add additional ones and i'll go into

00:10:36,880 --> 00:10:39,519
this

00:10:37,360 --> 00:10:41,200
later in the talk but we have one that's

00:10:39,519 --> 00:10:43,760
a control container that's on by default

00:10:41,200 --> 00:10:45,120
and this essentially exposes an api

00:10:43,760 --> 00:10:47,519
which is how you interact with the

00:10:45,120 --> 00:10:49,440
underlying host itself so you can

00:10:47,519 --> 00:10:51,040
make updates to configuration through

00:10:49,440 --> 00:10:52,720
the api you can add additional host

00:10:51,040 --> 00:10:53,440
containers through the api you can check

00:10:52,720 --> 00:10:55,440
settings

00:10:53,440 --> 00:10:57,200
and modify settings through that if you

00:10:55,440 --> 00:10:59,680
want to make any modifications to that

00:10:57,200 --> 00:11:00,320
underlying host you can use the api to

00:10:59,680 --> 00:11:02,399
add

00:11:00,320 --> 00:11:04,000
what we call an admin container this is

00:11:02,399 --> 00:11:05,519
off by default but basically when you

00:11:04,000 --> 00:11:07,440
activate it it'll go and download a

00:11:05,519 --> 00:11:09,120
container to that secondary

00:11:07,440 --> 00:11:10,640
container runtime that has additional

00:11:09,120 --> 00:11:11,279
permissions and this will allow you to

00:11:10,640 --> 00:11:13,120
get

00:11:11,279 --> 00:11:14,880
a shell prompt it will allow you to get

00:11:13,120 --> 00:11:17,120
um

00:11:14,880 --> 00:11:18,880
much more deeper hooks into the

00:11:17,120 --> 00:11:20,000
underlying os of the host

00:11:18,880 --> 00:11:21,839
and this should be used for something

00:11:20,000 --> 00:11:23,120
like deep debugging or exploration

00:11:21,839 --> 00:11:26,839
during build processes

00:11:23,120 --> 00:11:28,079
but it should be used essentially

00:11:26,839 --> 00:11:30,320
sparingly

00:11:28,079 --> 00:11:31,200
so is it possible to run on a raspberry

00:11:30,320 --> 00:11:34,240
pi 4

00:11:31,200 --> 00:11:35,519
not today but um we will get into the

00:11:34,240 --> 00:11:38,720
fact that we can

00:11:35,519 --> 00:11:40,480
cross compile to arm 64.

00:11:38,720 --> 00:11:42,079
um and so if you wanted to build a

00:11:40,480 --> 00:11:44,160
variant that could run on a raspberry

00:11:42,079 --> 00:11:45,519
pi that is something that that the

00:11:44,160 --> 00:11:47,600
community can totally do

00:11:45,519 --> 00:11:49,519
um it's just a matter of writing the

00:11:47,600 --> 00:11:50,720
config for that and going through and

00:11:49,519 --> 00:11:53,360
and building the image

00:11:50,720 --> 00:11:54,720
and this will kind of dive into that

00:11:53,360 --> 00:11:58,320
question right now

00:11:54,720 --> 00:11:58,320
as we go over some of the build concepts

00:11:59,920 --> 00:12:04,480
um some of the high level build concepts

00:12:01,839 --> 00:12:06,240
so as you start to to to try and build

00:12:04,480 --> 00:12:07,600
your disk image for

00:12:06,240 --> 00:12:09,279
for bottle rocket you're going to need a

00:12:07,600 --> 00:12:10,880
few things and so the

00:12:09,279 --> 00:12:12,560
the components look like this you've

00:12:10,880 --> 00:12:14,399
essentially got a build machine

00:12:12,560 --> 00:12:16,320
that you're gonna use to do your builds

00:12:14,399 --> 00:12:16,800
um on that machine you're gonna have

00:12:16,320 --> 00:12:19,519
some

00:12:16,800 --> 00:12:21,519
um required tooling so everything that

00:12:19,519 --> 00:12:22,000
we've built we've built uh that's first

00:12:21,519 --> 00:12:26,160
party

00:12:22,000 --> 00:12:29,040
um um we're using rust and cargo

00:12:26,160 --> 00:12:30,240
to to kind of use uh handle our packages

00:12:29,040 --> 00:12:33,200
and and build process

00:12:30,240 --> 00:12:34,160
um we'll use docker um to to actually do

00:12:33,200 --> 00:12:36,160
the build itself

00:12:34,160 --> 00:12:38,240
um so the sdk is essentially a docker

00:12:36,160 --> 00:12:39,760
image we're using rpm

00:12:38,240 --> 00:12:42,160
but we're not using in the sense that we

00:12:39,760 --> 00:12:43,600
have um rpm images that we're installing

00:12:42,160 --> 00:12:45,680
through a package manager we're using it

00:12:43,600 --> 00:12:46,959
as more of like the package spec

00:12:45,680 --> 00:12:48,880
and i'll talk to that a little bit and

00:12:46,959 --> 00:12:50,320
then there's linux build tools and so on

00:12:48,880 --> 00:12:52,160
that machine you're going to basically

00:12:50,320 --> 00:12:54,560
suck in the bottle rocket source code

00:12:52,160 --> 00:12:57,760
from our git repository

00:12:54,560 --> 00:12:58,480
and then um this will also download the

00:12:57,760 --> 00:13:00,079
sdk

00:12:58,480 --> 00:13:01,760
and then if there's any particular

00:13:00,079 --> 00:13:03,360
dependencies or packages that your your

00:13:01,760 --> 00:13:04,639
variant that you want to build needs

00:13:03,360 --> 00:13:07,360
it's going to download those

00:13:04,639 --> 00:13:08,720
as well to that build machine as you go

00:13:07,360 --> 00:13:10,480
through the build process it will

00:13:08,720 --> 00:13:11,519
produce a couple of different outputs or

00:13:10,480 --> 00:13:13,040
there's some options for different

00:13:11,519 --> 00:13:15,360
outputs so the primary output is going

00:13:13,040 --> 00:13:16,800
to be a bottle rocket disk image

00:13:15,360 --> 00:13:19,120
and then there's some optional outputs

00:13:16,800 --> 00:13:21,200
that you can you can create along with

00:13:19,120 --> 00:13:23,279
that so a bottle rocket repository so if

00:13:21,200 --> 00:13:24,720
you create say your own variant

00:13:23,279 --> 00:13:26,079
of bottle rocket and you want to be able

00:13:24,720 --> 00:13:28,000
to create an update repository you can

00:13:26,079 --> 00:13:30,240
create that and that will publish

00:13:28,000 --> 00:13:31,040
um out to wherever you want it to be so

00:13:30,240 --> 00:13:32,560
this can be

00:13:31,040 --> 00:13:34,160
you know for for the bottle rocket

00:13:32,560 --> 00:13:37,120
variants that we manage

00:13:34,160 --> 00:13:38,160
at aws these will be published to an s3

00:13:37,120 --> 00:13:39,680
bucket

00:13:38,160 --> 00:13:41,839
with a cloudfront distribution in front

00:13:39,680 --> 00:13:43,680
of it the key point here is you

00:13:41,839 --> 00:13:45,839
you need it to be accessible to the

00:13:43,680 --> 00:13:46,959
hosts so that they can check for updates

00:13:45,839 --> 00:13:48,079
regularly

00:13:46,959 --> 00:13:50,560
and if there is an update they can

00:13:48,079 --> 00:13:53,839
download it to that secondary partition

00:13:50,560 --> 00:13:54,320
um and a third option here for an output

00:13:53,839 --> 00:13:56,800
is

00:13:54,320 --> 00:13:58,560
essentially an ami or a disk image for

00:13:56,800 --> 00:14:00,320
amazon machine images

00:13:58,560 --> 00:14:02,240
and so this is you know what we use at

00:14:00,320 --> 00:14:03,760
aws to be able to run these on the

00:14:02,240 --> 00:14:04,880
actual host themselves

00:14:03,760 --> 00:14:06,800
so what it's going to do is it's going

00:14:04,880 --> 00:14:08,000
to create an ami publish that to a

00:14:06,800 --> 00:14:09,760
particular region

00:14:08,000 --> 00:14:13,680
and then when you provision a host it's

00:14:09,760 --> 00:14:13,680
going to use that ami as its disk image

00:14:15,199 --> 00:14:18,720
and i've got some questions is bottle

00:14:16,639 --> 00:14:21,440
rocket the underlying os for fargate

00:14:18,720 --> 00:14:22,480
no it is not um the underlying host for

00:14:21,440 --> 00:14:24,800
fargate is uh

00:14:22,480 --> 00:14:26,160
essentially a lightweight vm running uh

00:14:24,800 --> 00:14:27,360
using firecracker

00:14:26,160 --> 00:14:29,120
um if you wanna look that up you can

00:14:27,360 --> 00:14:30,880
look up aws firecracker and there's some

00:14:29,120 --> 00:14:33,360
some more details around that

00:14:30,880 --> 00:14:34,399
um it's somewhat similar in concept

00:14:33,360 --> 00:14:35,839
though it's it's

00:14:34,399 --> 00:14:38,079
designed to be very very very

00:14:35,839 --> 00:14:40,800
lightweight very stripped down secure

00:14:38,079 --> 00:14:42,399
um but this is um ours is a little bit

00:14:40,800 --> 00:14:44,320
more purpose built for the

00:14:42,399 --> 00:14:45,519
the task of just containers so it's it's

00:14:44,320 --> 00:14:49,519
a little bit different

00:14:45,519 --> 00:14:50,880
um and then talking tooling

00:14:49,519 --> 00:14:52,639
um some of the tools that we're going to

00:14:50,880 --> 00:14:54,079
need to go through and build uh go

00:14:52,639 --> 00:14:55,440
through the build process or things like

00:14:54,079 --> 00:14:56,639
cargo so like i said

00:14:55,440 --> 00:14:59,120
all of our first party tooling is

00:14:56,639 --> 00:15:01,040
written essentially in rust

00:14:59,120 --> 00:15:02,240
and so we're leveraging the cargo

00:15:01,040 --> 00:15:04,800
package manager which is

00:15:02,240 --> 00:15:07,040
uh comes along with that and that's

00:15:04,800 --> 00:15:09,760
going to handle a lot more than just

00:15:07,040 --> 00:15:11,199
the our packages we're essentially using

00:15:09,760 --> 00:15:12,880
it as a dependency solver

00:15:11,199 --> 00:15:14,880
for first and third party packages so

00:15:12,880 --> 00:15:16,639
it's it's going to handle a lot of the

00:15:14,880 --> 00:15:19,199
orchestration of the build process

00:15:16,639 --> 00:15:20,240
on our behalf and we'll actually invoke

00:15:19,199 --> 00:15:23,839
other tools

00:15:20,240 --> 00:15:25,600
to to handle different components

00:15:23,839 --> 00:15:27,279
when that portion of the build is is

00:15:25,600 --> 00:15:28,560
executed and we'll dive into

00:15:27,279 --> 00:15:31,920
a little bit more of explanation in a

00:15:28,560 --> 00:15:34,000
moment we're also using rpm

00:15:31,920 --> 00:15:35,759
so like i said earlier we're not

00:15:34,000 --> 00:15:37,199
installing the rpm package manager on

00:15:35,759 --> 00:15:39,360
the system itself we're essentially

00:15:37,199 --> 00:15:42,800
using the rpm spec files to

00:15:39,360 --> 00:15:44,000
identify any of the necessary packages

00:15:42,800 --> 00:15:45,040
that you want to include within your

00:15:44,000 --> 00:15:48,480
variant

00:15:45,040 --> 00:15:50,880
its dependencies its source code

00:15:48,480 --> 00:15:52,399
and the idea is that we will download

00:15:50,880 --> 00:15:53,920
all of that source code locally during

00:15:52,399 --> 00:15:54,720
the build process so when you execute a

00:15:53,920 --> 00:15:56,240
cargo

00:15:54,720 --> 00:15:58,639
make it's going to go download all those

00:15:56,240 --> 00:16:01,519
requirements it will

00:15:58,639 --> 00:16:02,160
build an rpm based on that so it's not

00:16:01,519 --> 00:16:04,560
going to pull

00:16:02,160 --> 00:16:05,759
from essentially the the typical package

00:16:04,560 --> 00:16:07,440
manager location

00:16:05,759 --> 00:16:08,800
it's going to pull all the source and

00:16:07,440 --> 00:16:10,959
compile it

00:16:08,800 --> 00:16:12,399
locally on your machine and then it's

00:16:10,959 --> 00:16:12,959
going to cache that on that build

00:16:12,399 --> 00:16:15,120
machine

00:16:12,959 --> 00:16:16,000
so in the future if you run subsequent

00:16:15,120 --> 00:16:19,040
builds

00:16:16,000 --> 00:16:20,240
it will leverage the cache for that and

00:16:19,040 --> 00:16:22,240
then it's going to use the bottle rocket

00:16:20,240 --> 00:16:24,320
sdk which is essentially

00:16:22,240 --> 00:16:25,759
includes all the necessary tools that we

00:16:24,320 --> 00:16:27,839
need to actually

00:16:25,759 --> 00:16:28,880
perform all of the builds for the the

00:16:27,839 --> 00:16:31,360
tool chain

00:16:28,880 --> 00:16:33,199
um and actually produce the output and

00:16:31,360 --> 00:16:35,440
this is essentially a docker

00:16:33,199 --> 00:16:37,600
image and then like i said we're using

00:16:35,440 --> 00:16:38,880
docker um throughout the whole stack to

00:16:37,600 --> 00:16:42,000
produce the the

00:16:38,880 --> 00:16:43,600
the exported image and

00:16:42,000 --> 00:16:44,880
um there's a question now about whether

00:16:43,600 --> 00:16:45,839
bottle rocket is being used in

00:16:44,880 --> 00:16:48,560
production and

00:16:45,839 --> 00:16:50,079
yes it is so we've got a number of of

00:16:48,560 --> 00:16:51,759
partners and customers that are using it

00:16:50,079 --> 00:16:54,480
safely in production for eks

00:16:51,759 --> 00:16:56,880
um the ecs uh is in preview right now so

00:16:54,480 --> 00:16:58,480
if you wanted to to test that in preview

00:16:56,880 --> 00:17:00,800
um for ecs by all means i would

00:16:58,480 --> 00:17:03,120
recommend you you give that a try

00:17:00,800 --> 00:17:04,400
um and as soon as that ghost ga i would

00:17:03,120 --> 00:17:05,919
recommend that for production workflows

00:17:04,400 --> 00:17:08,959
but for eks

00:17:05,919 --> 00:17:10,959
customers are using that today um and

00:17:08,959 --> 00:17:12,000
the the build process itself is is

00:17:10,959 --> 00:17:14,640
pretty straightforward

00:17:12,000 --> 00:17:15,360
um what you're gonna need essentially is

00:17:14,640 --> 00:17:17,039
a machine

00:17:15,360 --> 00:17:18,799
that's capable of actually performing

00:17:17,039 --> 00:17:20,480
the build and this is probably

00:17:18,799 --> 00:17:23,760
the most challenging part of this that

00:17:20,480 --> 00:17:25,839
the build process and its artifacts

00:17:23,760 --> 00:17:26,959
can actually run in excess of about 80

00:17:25,839 --> 00:17:28,319
gigabytes

00:17:26,959 --> 00:17:29,600
and so you want to make sure that

00:17:28,319 --> 00:17:30,240
depending upon the variant that you're

00:17:29,600 --> 00:17:32,240
building

00:17:30,240 --> 00:17:33,600
that you have enough disk space on that

00:17:32,240 --> 00:17:35,520
underlying build machine

00:17:33,600 --> 00:17:36,880
to be able to support that that storage

00:17:35,520 --> 00:17:39,039
requirement um

00:17:36,880 --> 00:17:40,559
you know if you're using like an aw 9

00:17:39,039 --> 00:17:41,679
environment you'll probably want to add

00:17:40,559 --> 00:17:43,200
additional disk space because i think

00:17:41,679 --> 00:17:44,559
they start with 20 gigabytes

00:17:43,200 --> 00:17:46,640
um so you'll you'll blow through that

00:17:44,559 --> 00:17:48,320
pretty quickly but you also want to

00:17:46,640 --> 00:17:50,080
consider that

00:17:48,320 --> 00:17:51,919
it's pretty resource intensive but it

00:17:50,080 --> 00:17:53,039
can it can scale pretty well through

00:17:51,919 --> 00:17:55,280
additional cores

00:17:53,039 --> 00:17:57,039
and so um we've got some build

00:17:55,280 --> 00:17:58,080
environments that that scale up to 32

00:17:57,039 --> 00:18:00,160
plus cores

00:17:58,080 --> 00:18:02,080
and the builds for on those systems

00:18:00,160 --> 00:18:05,039
typically take about 12 minutes

00:18:02,080 --> 00:18:05,520
um but if you've got like my macbook

00:18:05,039 --> 00:18:07,520
that i

00:18:05,520 --> 00:18:08,720
i built it on that's got eight cores or

00:18:07,520 --> 00:18:11,039
four cores actually

00:18:08,720 --> 00:18:12,160
um it took about three hours for it to

00:18:11,039 --> 00:18:14,960
go through so it's

00:18:12,160 --> 00:18:17,039
um it's gonna require um a couple of

00:18:14,960 --> 00:18:20,000
libraries and tools like i mentioned

00:18:17,039 --> 00:18:20,640
and some patients so um if you trigger a

00:18:20,000 --> 00:18:22,320
build

00:18:20,640 --> 00:18:24,400
uh i recommend you have some strong

00:18:22,320 --> 00:18:25,760
coffee and you know some kind of hobby

00:18:24,400 --> 00:18:27,039
to help you pass the time you know if

00:18:25,760 --> 00:18:28,559
you wanna get into needlepoint or

00:18:27,039 --> 00:18:29,919
crochet maybe look up some star wars

00:18:28,559 --> 00:18:31,600
patterns and have some fun

00:18:29,919 --> 00:18:33,919
um but you're gonna you're gonna take a

00:18:31,600 --> 00:18:33,919
little bit

00:18:35,280 --> 00:18:39,679
um and the way this works is it's pretty

00:18:38,080 --> 00:18:41,280
straightforward you're

00:18:39,679 --> 00:18:43,679
you're gonna start a simple cargo

00:18:41,280 --> 00:18:45,280
command which we'll go through and and

00:18:43,679 --> 00:18:47,200
it's it's the similar to make but we're

00:18:45,280 --> 00:18:48,000
using cargo to actually handle the make

00:18:47,200 --> 00:18:50,640
process

00:18:48,000 --> 00:18:51,520
so you trigger the builds using that um

00:18:50,640 --> 00:18:53,440
there's some

00:18:51,520 --> 00:18:55,039
additional flags that you can specify so

00:18:53,440 --> 00:18:56,799
if you want to build a specific variant

00:18:55,039 --> 00:18:58,320
or say you're managing multiple variants

00:18:56,799 --> 00:18:59,679
like i want to build a specific version

00:18:58,320 --> 00:19:02,080
of the eks variant

00:18:59,679 --> 00:19:03,039
you can specify that variant um like i

00:19:02,080 --> 00:19:06,160
said we support

00:19:03,039 --> 00:19:09,120
multi-arcs so if you want to run this on

00:19:06,160 --> 00:19:11,840
say like a graviton processor on aws or

00:19:09,120 --> 00:19:13,600
arm 64 processor you know you can

00:19:11,840 --> 00:19:15,440
actually build and compile

00:19:13,600 --> 00:19:17,440
a variant for that so you can specify

00:19:15,440 --> 00:19:19,280
the architecture you want to support

00:19:17,440 --> 00:19:21,760
and this will actually go and invoke a

00:19:19,280 --> 00:19:25,039
few things

00:19:21,760 --> 00:19:27,200
at the core of of cargo is

00:19:25,039 --> 00:19:29,600
essentially a make file and this is a

00:19:27,200 --> 00:19:31,840
tamil file that actually specifies

00:19:29,600 --> 00:19:32,960
um all of the environment environmental

00:19:31,840 --> 00:19:35,120
variables um

00:19:32,960 --> 00:19:36,480
and it starts to list out the tasks and

00:19:35,120 --> 00:19:38,960
build dependencies that you're gonna

00:19:36,480 --> 00:19:42,160
need to actually execute this build

00:19:38,960 --> 00:19:45,200
and so it's going to evaluate this

00:19:42,160 --> 00:19:46,880
set up all those dependencies set up

00:19:45,200 --> 00:19:48,480
some specific pathing and it'll actually

00:19:46,880 --> 00:19:50,000
start to go through and build out those

00:19:48,480 --> 00:19:51,360
dependencies

00:19:50,000 --> 00:19:52,640
if the dependencies have been built

00:19:51,360 --> 00:19:54,000
previously and they're cached it's going

00:19:52,640 --> 00:19:55,520
to leverage the cache version if there

00:19:54,000 --> 00:19:58,000
was a delta between

00:19:55,520 --> 00:19:59,120
um when it was previously cached and

00:19:58,000 --> 00:20:01,280
what's available today

00:19:59,120 --> 00:20:02,400
it will of course grab a new version and

00:20:01,280 --> 00:20:04,799
and rebuild

00:20:02,400 --> 00:20:06,320
uh based on that and you can even

00:20:04,799 --> 00:20:07,919
invalidate that yourself so if you want

00:20:06,320 --> 00:20:09,280
to build a fresh copy there's uh

00:20:07,919 --> 00:20:12,080
some arguments we can provide in the

00:20:09,280 --> 00:20:15,039
command line um to to make sure it grabs

00:20:12,080 --> 00:20:15,039
a fresh version

00:20:15,919 --> 00:20:20,240
um and so the idea here is it's going to

00:20:18,080 --> 00:20:24,559
trigger this and then we're going to

00:20:20,240 --> 00:20:26,080
actually use a feature within

00:20:24,559 --> 00:20:28,559
each of the project or each of the the

00:20:26,080 --> 00:20:30,480
packages in the project itself

00:20:28,559 --> 00:20:31,600
which is known as build rs and so this

00:20:30,480 --> 00:20:34,000
is a rust script

00:20:31,600 --> 00:20:35,520
that actually will go through um it's

00:20:34,000 --> 00:20:37,919
it's at the base of every

00:20:35,520 --> 00:20:39,600
uh package that you have it's going to

00:20:37,919 --> 00:20:40,720
be in the same directory as your cargo

00:20:39,600 --> 00:20:44,080
tomml file

00:20:40,720 --> 00:20:46,559
um and basically what this does is it um

00:20:44,080 --> 00:20:48,559
compiles all of the it'll basically be

00:20:46,559 --> 00:20:49,440
built and compiled and executed prior to

00:20:48,559 --> 00:20:50,720
the cargo package

00:20:49,440 --> 00:20:52,480
uh building the cargo package in which

00:20:50,720 --> 00:20:54,400
the cargo build was invoked and this

00:20:52,480 --> 00:20:55,679
gets kind of convoluted but the the idea

00:20:54,400 --> 00:20:56,799
is you've got two things that we're

00:20:55,679 --> 00:20:58,799
going to build here

00:20:56,799 --> 00:21:00,240
so there's the variant which we we

00:20:58,799 --> 00:21:03,200
triggered through

00:21:00,240 --> 00:21:04,960
our cargo make and then there's packages

00:21:03,200 --> 00:21:06,799
which are the dependencies

00:21:04,960 --> 00:21:08,400
and so once we've triggered the the

00:21:06,799 --> 00:21:17,840
variant build it's going to go through

00:21:08,400 --> 00:21:17,840
and find all the dependents

00:21:29,440 --> 00:21:34,080
is a pretty simple script and it's going

00:21:33,039 --> 00:21:36,240
to specify

00:21:34,080 --> 00:21:37,360
like i said two things either build

00:21:36,240 --> 00:21:39,840
variant or

00:21:37,360 --> 00:21:41,039
build um i think you can see my mouse

00:21:39,840 --> 00:21:42,480
over here so it's going to build variant

00:21:41,039 --> 00:21:44,000
or build package and it's going to use a

00:21:42,480 --> 00:21:46,880
tool called build syst to do that and

00:21:44,000 --> 00:21:48,960
this is all this build rs file does

00:21:46,880 --> 00:21:51,440
and what this will actually do is it

00:21:48,960 --> 00:21:53,360
will trigger this build sys application

00:21:51,440 --> 00:21:57,039
that will go through the bottle rocket

00:21:53,360 --> 00:21:59,280
tree and it will identify

00:21:57,039 --> 00:22:00,559
uh all the the the packages that need to

00:21:59,280 --> 00:22:02,799
be executed and built

00:22:00,559 --> 00:22:05,840
it will spin up a docker build command

00:22:02,799 --> 00:22:05,840
using the the

00:22:11,280 --> 00:22:14,799
model rocket sdk the the sdk it will

00:22:14,159 --> 00:22:16,960
then

00:22:14,799 --> 00:22:18,159
spin up a docker build for that

00:22:16,960 --> 00:22:21,520
particular one

00:22:18,159 --> 00:22:22,720
it will leverage the sdk to then build

00:22:21,520 --> 00:22:25,919
the rpm package

00:22:22,720 --> 00:22:27,360
for that that dependency and it'll copy

00:22:25,919 --> 00:22:29,760
that desired artifact

00:22:27,360 --> 00:22:31,679
out of that container onto a local disk

00:22:29,760 --> 00:22:34,240
in a in a particular directory

00:22:31,679 --> 00:22:35,520
um that will be later used when we

00:22:34,240 --> 00:22:37,520
actually go to build the variant

00:22:35,520 --> 00:22:39,039
so this seems kind of confusing but

00:22:37,520 --> 00:22:40,640
essentially it's going to go one by one

00:22:39,039 --> 00:22:42,880
through all those dependencies build

00:22:40,640 --> 00:22:45,440
them as an rpm file

00:22:42,880 --> 00:22:46,960
from source put the output in a

00:22:45,440 --> 00:22:50,159
particular directory

00:22:46,960 --> 00:22:52,559
and then move on to the next one and so

00:22:50,159 --> 00:22:54,559
it will leverage that that cargo toml

00:22:52,559 --> 00:22:56,240
file to go through and build each

00:22:54,559 --> 00:22:57,360
package and identify any additional

00:22:56,240 --> 00:22:59,039
dependencies that they need

00:22:57,360 --> 00:23:00,799
so this can get pretty nested and so

00:22:59,039 --> 00:23:03,039
this is why i say it can take

00:23:00,799 --> 00:23:04,960
quite a bit of time and so if you have a

00:23:03,039 --> 00:23:06,640
package that has other dependencies

00:23:04,960 --> 00:23:09,039
it's going to kind of spider through

00:23:06,640 --> 00:23:10,480
each of those and each time it needs to

00:23:09,039 --> 00:23:12,799
do that it's going to spin up

00:23:10,480 --> 00:23:14,240
another build process it will go through

00:23:12,799 --> 00:23:15,120
and build that put it in the output

00:23:14,240 --> 00:23:17,200
directory

00:23:15,120 --> 00:23:18,960
and so for example we've got our eks

00:23:17,200 --> 00:23:20,840
variant here and so this is going to be

00:23:18,960 --> 00:23:24,240
running kubernetes

00:23:20,840 --> 00:23:26,400
1.19 and in order to be able to

00:23:24,240 --> 00:23:27,840
connect that finished host so imagine

00:23:26,400 --> 00:23:29,919
we've gone through the build processes

00:23:27,840 --> 00:23:31,360
and we have our image

00:23:29,919 --> 00:23:32,880
when we spin up that host there's

00:23:31,360 --> 00:23:34,159
certain configuration that needs to be

00:23:32,880 --> 00:23:36,000
on there in order for that host to

00:23:34,159 --> 00:23:38,720
communicate with the eks control plane

00:23:36,000 --> 00:23:40,000
or the kubernetes masters and so we have

00:23:38,720 --> 00:23:42,400
our aws

00:23:40,000 --> 00:23:44,400
im authenticator we've got the cni and

00:23:42,400 --> 00:23:45,200
cni plug-ins so the networking can

00:23:44,400 --> 00:23:47,039
connect

00:23:45,200 --> 00:23:48,559
we have the specific kernel that we want

00:23:47,039 --> 00:23:51,120
to build we have uh

00:23:48,559 --> 00:23:53,120
the kubernetes um version that we want

00:23:51,120 --> 00:23:56,400
to to build and have a part of that

00:23:53,120 --> 00:23:57,840
and so by using this combination of

00:23:56,400 --> 00:24:01,840
these toml files

00:23:57,840 --> 00:24:01,840
and our build rs and build sys

00:24:02,400 --> 00:24:06,559
applications you can actually go through

00:24:04,559 --> 00:24:08,799
and build this very complex

00:24:06,559 --> 00:24:10,320
um set of dependencies and this this

00:24:08,799 --> 00:24:12,320
tree of dependencies into

00:24:10,320 --> 00:24:13,600
a meaningful output that can then be

00:24:12,320 --> 00:24:16,880
leveraged

00:24:13,600 --> 00:24:18,880
by the build to produce our disk image

00:24:16,880 --> 00:24:20,720
and so once it's gone through those

00:24:18,880 --> 00:24:21,840
packages and it's built all those

00:24:20,720 --> 00:24:24,000
dependencies

00:24:21,840 --> 00:24:26,400
it's basically going to then focus on

00:24:24,000 --> 00:24:28,720
actually building the variant

00:24:26,400 --> 00:24:31,039
and what this looks like is it's is it's

00:24:28,720 --> 00:24:33,679
a simple docker build command

00:24:31,039 --> 00:24:34,640
and we've specified specific directories

00:24:33,679 --> 00:24:36,240
um

00:24:34,640 --> 00:24:38,799
that that it's going to use to basically

00:24:36,240 --> 00:24:40,960
go through and and build each of these

00:24:38,799 --> 00:24:41,840
um i need to make sure i'm on time okay

00:24:40,960 --> 00:24:45,039
um

00:24:41,840 --> 00:24:46,720
and so it's gonna take all those rpms

00:24:45,039 --> 00:24:48,240
and leverage the rpms from the the

00:24:46,720 --> 00:24:49,360
output directory the artifact directory

00:24:48,240 --> 00:24:51,520
that we've created and it's going to

00:24:49,360 --> 00:24:54,400
install those as a disk image which will

00:24:51,520 --> 00:24:55,039
actually become the root file system for

00:24:54,400 --> 00:24:57,279
our image

00:24:55,039 --> 00:24:58,400
so it's going to basically use rpm to

00:24:57,279 --> 00:25:00,480
image to

00:24:58,400 --> 00:25:01,679
create that file system and then make

00:25:00,480 --> 00:25:02,400
sure everything that needs to be

00:25:01,679 --> 00:25:04,080
installed

00:25:02,400 --> 00:25:07,279
for that variant is installed and

00:25:04,080 --> 00:25:09,919
configured from those packages

00:25:07,279 --> 00:25:12,240
um and then what it will actually do is

00:25:09,919 --> 00:25:15,200
it'll output a final disk image

00:25:12,240 --> 00:25:16,960
to this build or slash build slash

00:25:15,200 --> 00:25:19,200
images directory

00:25:16,960 --> 00:25:21,440
and at that point you have your actual

00:25:19,200 --> 00:25:21,840
um completed image but it's just a disk

00:25:21,440 --> 00:25:23,919
image

00:25:21,840 --> 00:25:25,360
and so um you need to be able to put it

00:25:23,919 --> 00:25:28,080
to use and so

00:25:25,360 --> 00:25:29,520
for the sake of something running in aws

00:25:28,080 --> 00:25:32,159
like i said we want to

00:25:29,520 --> 00:25:33,440
convert that disk image into an ami so

00:25:32,159 --> 00:25:35,440
we have a cargo make

00:25:33,440 --> 00:25:36,880
a method that will actually go through

00:25:35,440 --> 00:25:39,520
and do that so it'll

00:25:36,880 --> 00:25:40,320
publish that disk image convert it to an

00:25:39,520 --> 00:25:41,919
ami

00:25:40,320 --> 00:25:43,760
get it into a specific region that we

00:25:41,919 --> 00:25:44,640
specify and then it'll actually make

00:25:43,760 --> 00:25:47,279
that

00:25:44,640 --> 00:25:49,279
public so that the the host themselves

00:25:47,279 --> 00:25:51,520
can go through and download that

00:25:49,279 --> 00:25:52,320
it's pretty straightforward um this is

00:25:51,520 --> 00:25:56,000
optional

00:25:52,320 --> 00:25:56,559
like honestly um you know for uh i'll go

00:25:56,000 --> 00:25:58,400
into this

00:25:56,559 --> 00:26:00,080
a little bit more and the way that the

00:25:58,400 --> 00:26:01,600
these um you know once we've got it

00:26:00,080 --> 00:26:03,120
published and it's out there

00:26:01,600 --> 00:26:05,039
we can go through this update process

00:26:03,120 --> 00:26:06,559
and we create essentially a repository

00:26:05,039 --> 00:26:09,279
to handle the updates

00:26:06,559 --> 00:26:10,640
this portion is is somewhat optional so

00:26:09,279 --> 00:26:12,799
if you want to run

00:26:10,640 --> 00:26:14,559
in place updates and you want to go

00:26:12,799 --> 00:26:17,120
through and build out

00:26:14,559 --> 00:26:18,720
a repository to be able to say leverage

00:26:17,120 --> 00:26:21,039
the in-place updates

00:26:18,720 --> 00:26:23,760
along with our update operator say for

00:26:21,039 --> 00:26:26,880
kubernetes that will actually keep these

00:26:23,760 --> 00:26:29,039
hosts up to date you can publish a

00:26:26,880 --> 00:26:30,320
repo and you know we publish the ones

00:26:29,039 --> 00:26:31,520
for the variants that we manage but if

00:26:30,320 --> 00:26:33,200
you want to create your own variant you

00:26:31,520 --> 00:26:36,159
can actually publish your own repo

00:26:33,200 --> 00:26:36,720
um it just requires some simple metadata

00:26:36,159 --> 00:26:39,520
um

00:26:36,720 --> 00:26:41,120
some um cryptographic hashes um

00:26:39,520 --> 00:26:43,360
basically some signing keys as well

00:26:41,120 --> 00:26:44,720
to make sure that when a host wants to

00:26:43,360 --> 00:26:46,080
connect to that repo it's

00:26:44,720 --> 00:26:48,320
doing so in a secure way and it's

00:26:46,080 --> 00:26:50,720
pulling the a validated version from

00:26:48,320 --> 00:26:51,919
the repo that you've created and cargo

00:26:50,720 --> 00:26:54,320
will actually go through and make this

00:26:51,919 --> 00:26:56,720
for you and then you basically just copy

00:26:54,320 --> 00:26:57,840
um those images to that repository

00:26:56,720 --> 00:26:59,679
wherever you want it to be stored

00:26:57,840 --> 00:27:01,679
whether that be s3 or wherever

00:26:59,679 --> 00:27:03,279
um and that can be uh it just needs to

00:27:01,679 --> 00:27:04,880
be exposed in a way that the host can

00:27:03,279 --> 00:27:06,559
actually reach it so if it's on internal

00:27:04,880 --> 00:27:07,600
network as long as those can reach it

00:27:06,559 --> 00:27:10,720
you should be fine

00:27:07,600 --> 00:27:12,720
um but the idea here is this is optional

00:27:10,720 --> 00:27:14,640
um you don't have to do in-place

00:27:12,720 --> 00:27:16,240
upgrades you know one of the beauties of

00:27:14,640 --> 00:27:18,000
of bottle rocket is the fact that it is

00:27:16,240 --> 00:27:19,360
an atomic update so you can do an

00:27:18,000 --> 00:27:22,240
alternative view where it's

00:27:19,360 --> 00:27:23,919
instead of updating this way you can

00:27:22,240 --> 00:27:26,320
just do wholesale image

00:27:23,919 --> 00:27:27,919
host replacement so you can spin up a

00:27:26,320 --> 00:27:30,080
number of new hosts running the

00:27:27,919 --> 00:27:31,520
the latest version and just replace all

00:27:30,080 --> 00:27:33,279
the existing ones

00:27:31,520 --> 00:27:34,799
and if you wanted to to run your

00:27:33,279 --> 00:27:36,080
operation that way you could even build

00:27:34,799 --> 00:27:37,840
a variant that doesn't include that

00:27:36,080 --> 00:27:39,679
secondary disk partition and does

00:27:37,840 --> 00:27:42,080
include the update process itself

00:27:39,679 --> 00:27:42,799
so i say that this is optional but we

00:27:42,080 --> 00:27:44,799
want to provide

00:27:42,799 --> 00:27:46,159
a mechanism that if you want to handle

00:27:44,799 --> 00:27:47,360
updates yourself you can do so in a

00:27:46,159 --> 00:27:49,200
secure way

00:27:47,360 --> 00:27:50,480
that enables the operating system and

00:27:49,200 --> 00:27:51,760
the hosts to to

00:27:50,480 --> 00:27:53,520
to make sure they're running the latest

00:27:51,760 --> 00:27:54,640
version at all times but if you want to

00:27:53,520 --> 00:27:57,679
run this through a different process

00:27:54,640 --> 00:27:57,679
there's that flexibility

00:27:59,120 --> 00:28:03,440
and there's a couple questions i'll get

00:28:01,360 --> 00:28:06,080
to those in a little bit

00:28:03,440 --> 00:28:07,600
um and the idea is at this point you

00:28:06,080 --> 00:28:08,640
basically have everything that you need

00:28:07,600 --> 00:28:11,279
to run

00:28:08,640 --> 00:28:12,720
the operating system um but there's ways

00:28:11,279 --> 00:28:14,240
that you might want to extend that

00:28:12,720 --> 00:28:16,799
and so you know i show you how to go

00:28:14,240 --> 00:28:18,159
through and build the the variants

00:28:16,799 --> 00:28:19,840
but the idea here is not everything

00:28:18,159 --> 00:28:21,600
needs to be built

00:28:19,840 --> 00:28:22,880
into the host os in fact we would we

00:28:21,600 --> 00:28:25,840
would actually prefer that you build

00:28:22,880 --> 00:28:27,360
minimally into the os as possible and

00:28:25,840 --> 00:28:28,960
you use one of these extension methods

00:28:27,360 --> 00:28:30,480
to add features and capabilities as

00:28:28,960 --> 00:28:32,799
needed

00:28:30,480 --> 00:28:33,840
and so one of the obvious ways that you

00:28:32,799 --> 00:28:35,679
might need

00:28:33,840 --> 00:28:37,039
to extend bottle rocket is adding

00:28:35,679 --> 00:28:38,880
additional permissions

00:28:37,039 --> 00:28:40,399
um and you know like i said at the

00:28:38,880 --> 00:28:42,240
beginning of this we have the sc linux

00:28:40,399 --> 00:28:44,320
policy in place that defines

00:28:42,240 --> 00:28:45,520
you know how to transition rules for

00:28:44,320 --> 00:28:47,120
container runtimes

00:28:45,520 --> 00:28:49,120
and we've we've set that in a very

00:28:47,120 --> 00:28:49,600
restrictive mode by default um but we

00:28:49,120 --> 00:28:52,799
have

00:28:49,600 --> 00:28:53,600
three um three methods that you can use

00:28:52,799 --> 00:28:56,080
to

00:28:53,600 --> 00:28:56,960
elevate those permissions um everything

00:28:56,080 --> 00:29:00,159
by default

00:28:56,960 --> 00:29:01,679
that's running as a workload on top of

00:29:00,159 --> 00:29:03,200
the host is going to be running in a

00:29:01,679 --> 00:29:04,320
what we call container t

00:29:03,200 --> 00:29:06,240
and so this is going to be the default

00:29:04,320 --> 00:29:06,799
for any ordinary containers this is

00:29:06,240 --> 00:29:08,399
going to be

00:29:06,799 --> 00:29:10,799
essentially a walled garden from the

00:29:08,399 --> 00:29:13,440
underlying host itself

00:29:10,799 --> 00:29:14,320
um and then anything that requires

00:29:13,440 --> 00:29:16,000
additional

00:29:14,320 --> 00:29:17,600
privileges so if you want to run a

00:29:16,000 --> 00:29:19,440
container in privilege mode or

00:29:17,600 --> 00:29:20,799
uh the control host container i'll use

00:29:19,440 --> 00:29:23,120
as an example

00:29:20,799 --> 00:29:24,240
um it's going to be running in control t

00:29:23,120 --> 00:29:26,240
and so this gives it uh

00:29:24,240 --> 00:29:27,840
elevated privileges and you kind of need

00:29:26,240 --> 00:29:29,039
to be careful here because

00:29:27,840 --> 00:29:31,440
if you think about this we've got the

00:29:29,039 --> 00:29:33,840
control host that's running on that

00:29:31,440 --> 00:29:36,640
instance that provides the api

00:29:33,840 --> 00:29:37,679
but because that control host can add

00:29:36,640 --> 00:29:40,640
additional

00:29:37,679 --> 00:29:43,200
host containers to that host there are

00:29:40,640 --> 00:29:45,760
ways to leverage that control t

00:29:43,200 --> 00:29:46,640
to get super t access which is super

00:29:45,760 --> 00:29:48,559
powered

00:29:46,640 --> 00:29:50,000
essentially you have unlimited access to

00:29:48,559 --> 00:29:51,679
the underlying host os

00:29:50,000 --> 00:29:53,520
so you want to make sure that if you're

00:29:51,679 --> 00:29:55,600
going down this path

00:29:53,520 --> 00:29:57,279
you're being very specific about why

00:29:55,600 --> 00:29:58,080
you're doing it and you have specific

00:29:57,279 --> 00:29:59,520
processes

00:29:58,080 --> 00:30:01,520
to ensure that you're doing this in a

00:29:59,520 --> 00:30:03,039
safe manner that's not introducing

00:30:01,520 --> 00:30:06,320
security holes along the way

00:30:03,039 --> 00:30:07,520
and so if you have say like a solution

00:30:06,320 --> 00:30:11,039
that needs to have

00:30:07,520 --> 00:30:13,520
tighter access to do run time scanning

00:30:11,039 --> 00:30:14,720
file access scanning something like that

00:30:13,520 --> 00:30:15,600
that requires a little bit more

00:30:14,720 --> 00:30:17,200
permissions

00:30:15,600 --> 00:30:19,120
i would do that in a way that that's

00:30:17,200 --> 00:30:21,520
cognizant of the fact that

00:30:19,120 --> 00:30:23,279
you need to to look at security and

00:30:21,520 --> 00:30:24,720
depth and defense in depth

00:30:23,279 --> 00:30:26,080
and make sure you're doing so in a way

00:30:24,720 --> 00:30:27,600
that's going to maintain that security

00:30:26,080 --> 00:30:30,799
while providing

00:30:27,600 --> 00:30:32,399
access to this the way this typically

00:30:30,799 --> 00:30:33,760
works with something like kubernetes or

00:30:32,399 --> 00:30:35,679
ecs

00:30:33,760 --> 00:30:37,600
is in your pod spec or task definition

00:30:35,679 --> 00:30:40,240
you can actually specify these in

00:30:37,600 --> 00:30:40,960
in in those files and this is the way it

00:30:40,240 --> 00:30:43,120
looks like for

00:30:40,960 --> 00:30:45,360
a kubernetes pod spec so you can come in

00:30:43,120 --> 00:30:46,320
and specify the specific uh security

00:30:45,360 --> 00:30:48,159
context

00:30:46,320 --> 00:30:49,520
um and the sd linux options you want so

00:30:48,159 --> 00:30:53,520
you can specify the user

00:30:49,520 --> 00:30:54,799
role the user type and even the level

00:30:53,520 --> 00:30:56,799
and you want to be very careful here

00:30:54,799 --> 00:30:58,559
because like i said what you provide

00:30:56,799 --> 00:31:04,320
here can actually

00:30:58,559 --> 00:31:06,159
be used to gain additional access um

00:31:04,320 --> 00:31:07,760
and if we look at this um providing

00:31:06,159 --> 00:31:09,760
containers uh if you want to look

00:31:07,760 --> 00:31:11,919
if you want to dive deeper into to how

00:31:09,760 --> 00:31:12,480
this works we've got the specific guide

00:31:11,919 --> 00:31:14,799
here

00:31:12,480 --> 00:31:16,880
that will go more in depth on what

00:31:14,799 --> 00:31:18,559
options and guidance we have around

00:31:16,880 --> 00:31:20,000
providing your workloads with additional

00:31:18,559 --> 00:31:21,840
privileges um

00:31:20,000 --> 00:31:23,440
i would say you know like i said use

00:31:21,840 --> 00:31:25,279
this sparingly and

00:31:23,440 --> 00:31:26,480
if you want to to have additional

00:31:25,279 --> 00:31:27,840
features or capabilities

00:31:26,480 --> 00:31:29,760
i would i would target something like a

00:31:27,840 --> 00:31:33,120
host or a bootstrap container

00:31:29,760 --> 00:31:34,159
and then we'll dive into ebpf and other

00:31:33,120 --> 00:31:36,000
stuff in a moment but

00:31:34,159 --> 00:31:37,840
the idea here is you can add additional

00:31:36,000 --> 00:31:40,000
host containers to

00:31:37,840 --> 00:31:41,600
the host itself so if you need to have a

00:31:40,000 --> 00:31:43,039
workload that's running

00:31:41,600 --> 00:31:45,360
that needs tighter access to say you're

00:31:43,039 --> 00:31:47,039
an isv partner or a solution provider

00:31:45,360 --> 00:31:48,399
and you need to have

00:31:47,039 --> 00:31:50,240
an agent that's running on that system

00:31:48,399 --> 00:31:52,159
at all times you can add that

00:31:50,240 --> 00:31:53,360
potentially as a host container um and

00:31:52,159 --> 00:31:55,600
so you can give that that

00:31:53,360 --> 00:31:57,360
host container privileges to be able to

00:31:55,600 --> 00:31:59,519
run it boot

00:31:57,360 --> 00:32:00,720
and essentially have access to that that

00:31:59,519 --> 00:32:03,120
system um

00:32:00,720 --> 00:32:03,919
these host containers you have to be

00:32:03,120 --> 00:32:07,519
mindful of

00:32:03,919 --> 00:32:09,279
they're not orchestrated so

00:32:07,519 --> 00:32:11,760
they only stop and start according to

00:32:09,279 --> 00:32:13,440
whether or not a an enabled flag has

00:32:11,760 --> 00:32:16,880
been specified

00:32:13,440 --> 00:32:17,840
and while they aren't um orchestrated on

00:32:16,880 --> 00:32:20,480
the host itself

00:32:17,840 --> 00:32:21,440
they are managed and monitored so if

00:32:20,480 --> 00:32:23,679
they do stop

00:32:21,440 --> 00:32:24,480
we can start them again um they're

00:32:23,679 --> 00:32:26,320
essentially run

00:32:24,480 --> 00:32:28,000
like i said in that second instance of

00:32:26,320 --> 00:32:31,120
container d so they are in a different

00:32:28,000 --> 00:32:32,960
walled area for the os

00:32:31,120 --> 00:32:34,399
and they're not updated automatically so

00:32:32,960 --> 00:32:35,519
imagine this is a container that's going

00:32:34,399 --> 00:32:37,600
to be downloaded and run

00:32:35,519 --> 00:32:39,919
on the host in another container d

00:32:37,600 --> 00:32:41,440
environment or docker environment

00:32:39,919 --> 00:32:43,360
so if you have updates to your host

00:32:41,440 --> 00:32:44,399
container you'll have to go through and

00:32:43,360 --> 00:32:46,559
disable that

00:32:44,399 --> 00:32:48,720
that container download the latest

00:32:46,559 --> 00:32:51,200
version and then enable it so it's

00:32:48,720 --> 00:32:51,840
um there's an update process there

00:32:51,200 --> 00:32:54,399
that's kind of

00:32:51,840 --> 00:32:56,000
managed separately and if you set this

00:32:54,399 --> 00:32:58,559
thing to be super powered it essentially

00:32:56,000 --> 00:32:59,919
has unlimited access to the host so you

00:32:58,559 --> 00:33:01,840
need to be mindful of that

00:32:59,919 --> 00:33:03,440
um recently we added the the concept of

00:33:01,840 --> 00:33:04,960
bootstrap containers and these are

00:33:03,440 --> 00:33:07,120
designed to help bootstrap the host

00:33:04,960 --> 00:33:10,720
before other services start

00:33:07,120 --> 00:33:12,399
and the idea here is that they're

00:33:10,720 --> 00:33:14,480
unlike normal hosts and they're not

00:33:12,399 --> 00:33:15,679
treated um with superpowers like you

00:33:14,480 --> 00:33:16,960
can't give it um

00:33:15,679 --> 00:33:20,000
like a normal host container you can't

00:33:16,960 --> 00:33:21,679
give it a super powered access

00:33:20,000 --> 00:33:24,159
they have access to the underlying root

00:33:21,679 --> 00:33:26,640
file system at slash dot bottle rocket

00:33:24,159 --> 00:33:27,440
root fs so be mindful of that

00:33:26,640 --> 00:33:30,240
essentially

00:33:27,440 --> 00:33:31,360
they start and run after systemd

00:33:30,240 --> 00:33:33,679
configured

00:33:31,360 --> 00:33:34,960
target unit is active so once that's

00:33:33,679 --> 00:33:36,240
running

00:33:34,960 --> 00:33:37,919
these bootstrap containers will be

00:33:36,240 --> 00:33:39,919
executed and they're not run in a

00:33:37,919 --> 00:33:40,559
deterministic order so the boot process

00:33:39,919 --> 00:33:43,440
will essentially

00:33:40,559 --> 00:33:44,480
wait for these two to execute and if

00:33:43,440 --> 00:33:46,960
they execute

00:33:44,480 --> 00:33:48,640
in a non-zero with a non-zero value

00:33:46,960 --> 00:33:52,080
they're actually going to stop

00:33:48,640 --> 00:33:55,120
the the the um the the boot

00:33:52,080 --> 00:33:56,399
if we set it as essential um and so this

00:33:55,120 --> 00:33:58,000
is what it kind of looks like when you

00:33:56,399 --> 00:34:00,320
want to add a host container it's

00:33:58,000 --> 00:34:01,840
a simple api call to the host container

00:34:00,320 --> 00:34:02,880
the the control container that's on

00:34:01,840 --> 00:34:05,840
there

00:34:02,880 --> 00:34:07,440
you specify the url you specify whether

00:34:05,840 --> 00:34:08,399
you want it to be enabled like i said

00:34:07,440 --> 00:34:10,960
you can this can

00:34:08,399 --> 00:34:11,679
be be downloaded and not enabled you can

00:34:10,960 --> 00:34:14,399
enable it

00:34:11,679 --> 00:34:16,079
it will and then you decide whether you

00:34:14,399 --> 00:34:18,639
want it to be super powered

00:34:16,079 --> 00:34:19,760
um and the same with the bootstrap

00:34:18,639 --> 00:34:22,560
containers as well

00:34:19,760 --> 00:34:23,839
so we've got this idea that um you know

00:34:22,560 --> 00:34:26,240
you specify the url

00:34:23,839 --> 00:34:27,280
you decide whether it's run once whether

00:34:26,240 --> 00:34:30,399
it's run always

00:34:27,280 --> 00:34:31,839
whether it's off um and then

00:34:30,399 --> 00:34:34,159
you decide whether it's essential or not

00:34:31,839 --> 00:34:36,159
so if this is essential

00:34:34,159 --> 00:34:38,800
and we go through and there's an error

00:34:36,159 --> 00:34:40,320
it will actually prevent that host from

00:34:38,800 --> 00:34:43,599
from being booted up because something

00:34:40,320 --> 00:34:45,919
in the provisioning has failed

00:34:43,599 --> 00:34:45,919
um

00:34:47,040 --> 00:34:51,040
and then if we want to extend um the

00:34:49,359 --> 00:34:52,720
capabilities even further

00:34:51,040 --> 00:34:54,720
this is honestly the the preferred

00:34:52,720 --> 00:34:56,560
method so um

00:34:54,720 --> 00:34:58,000
you know we have this this way to

00:34:56,560 --> 00:35:01,440
provide additional access

00:34:58,000 --> 00:35:04,079
we have this way to add additional um

00:35:01,440 --> 00:35:05,440
containers to that host that can perform

00:35:04,079 --> 00:35:08,400
things that may not be possible

00:35:05,440 --> 00:35:09,760
in the os so imagine you need to have

00:35:08,400 --> 00:35:11,200
additional tooling

00:35:09,760 --> 00:35:12,160
rather than installing that in the west

00:35:11,200 --> 00:35:14,880
you can install that in your host

00:35:12,160 --> 00:35:17,920
container you can add that there

00:35:14,880 --> 00:35:19,040
these should be used is like very

00:35:17,920 --> 00:35:21,280
sparing

00:35:19,040 --> 00:35:23,040
a little less sparing and this is kind

00:35:21,280 --> 00:35:25,839
of the the preferred method here so

00:35:23,040 --> 00:35:26,720
um if you want to extend i would start

00:35:25,839 --> 00:35:29,599
with um

00:35:26,720 --> 00:35:30,480
looking at kernel modules first and i

00:35:29,599 --> 00:35:33,119
would look at this

00:35:30,480 --> 00:35:34,160
using ebpf first so we're using a

00:35:33,119 --> 00:35:35,920
version of

00:35:34,160 --> 00:35:37,520
the linux kernel that supports ebpf out

00:35:35,920 --> 00:35:40,240
of the box um

00:35:37,520 --> 00:35:41,520
and so from just the containers that are

00:35:40,240 --> 00:35:43,119
running in the orchestrated

00:35:41,520 --> 00:35:46,079
environment so imagine you're running in

00:35:43,119 --> 00:35:47,280
kubernetes um you have an eks cluster

00:35:46,079 --> 00:35:48,480
that you've got a number of these bottle

00:35:47,280 --> 00:35:50,000
rocket hosts in

00:35:48,480 --> 00:35:51,760
you can have these run as a daemon set

00:35:50,000 --> 00:35:53,520
so you can have a daemon set running in

00:35:51,760 --> 00:35:56,079
that environment that has

00:35:53,520 --> 00:35:57,599
um a specific application that has an

00:35:56,079 --> 00:36:00,320
ebf ebpf connection

00:35:57,599 --> 00:36:02,560
to the underlying os and is is written

00:36:00,320 --> 00:36:03,839
in a way that it's leveraging evpf to

00:36:02,560 --> 00:36:05,119
handle any communications with the

00:36:03,839 --> 00:36:08,240
underlying kernel itself

00:36:05,119 --> 00:36:11,599
and it'll do that using the security

00:36:08,240 --> 00:36:13,280
methods provided by ebpf and so this is

00:36:11,599 --> 00:36:14,880
this is honestly the preferred way that

00:36:13,280 --> 00:36:16,480
you would do this um

00:36:14,880 --> 00:36:18,480
the only the only caveat here is you

00:36:16,480 --> 00:36:20,560
have to keep in mind that

00:36:18,480 --> 00:36:22,079
running this connection this way it's

00:36:20,560 --> 00:36:23,760
it's still going to

00:36:22,079 --> 00:36:25,680
be a read-only file system for those

00:36:23,760 --> 00:36:27,280
workloads and so anything that needs to

00:36:25,680 --> 00:36:28,240
be able to write to disk on the

00:36:27,280 --> 00:36:29,839
underlying host

00:36:28,240 --> 00:36:31,760
this may not be an option for but it is

00:36:29,839 --> 00:36:32,960
the preferred method from a security

00:36:31,760 --> 00:36:35,280
perspective

00:36:32,960 --> 00:36:36,880
when you consider it so we have another

00:36:35,280 --> 00:36:38,240
a number of vendors that are exploring

00:36:36,880 --> 00:36:41,359
capabilities in this way

00:36:38,240 --> 00:36:42,640
i'll use taigara calico as an example we

00:36:41,359 --> 00:36:43,839
recently did a really good blog post

00:36:42,640 --> 00:36:46,800
with them where

00:36:43,839 --> 00:36:47,760
we showed how to use eppf to accelerate

00:36:46,800 --> 00:36:49,839
the networking

00:36:47,760 --> 00:36:51,040
in bottle rocket so that we're using the

00:36:49,839 --> 00:36:53,920
kernel for routing

00:36:51,040 --> 00:36:54,560
using ebpf versus the networking stack

00:36:53,920 --> 00:36:57,040
per se

00:36:54,560 --> 00:36:58,800
and so we can do is actually limit the

00:36:57,040 --> 00:37:00,320
need for things like cube proxy

00:36:58,800 --> 00:37:02,800
and actually use the kernel to

00:37:00,320 --> 00:37:04,800
accelerate packet filtering and

00:37:02,800 --> 00:37:07,119
even routing of the packets to

00:37:04,800 --> 00:37:10,400
underlying containers on that host

00:37:07,119 --> 00:37:11,680
all using ebpf in in a way that is very

00:37:10,400 --> 00:37:12,400
easy to set up and straightforward and

00:37:11,680 --> 00:37:13,920
secure

00:37:12,400 --> 00:37:16,000
and so there's lots of opportunities for

00:37:13,920 --> 00:37:18,480
you very very powerful

00:37:16,000 --> 00:37:19,200
integrations with the underlying os but

00:37:18,480 --> 00:37:21,599
in a way

00:37:19,200 --> 00:37:23,040
that is is still respecting essentially

00:37:21,599 --> 00:37:25,200
the security

00:37:23,040 --> 00:37:26,240
of the underlying os itself and let me

00:37:25,200 --> 00:37:27,040
look through some of these questions

00:37:26,240 --> 00:37:28,079
because i know there's

00:37:27,040 --> 00:37:30,320
a few that have been sitting here for a

00:37:28,079 --> 00:37:30,320
while

00:37:32,480 --> 00:37:36,000
so is the ip address of the container

00:37:34,880 --> 00:37:37,920
visible from other os

00:37:36,000 --> 00:37:39,200
environments outside for integration or

00:37:37,920 --> 00:37:41,520
by permission from

00:37:39,200 --> 00:37:42,640
package managers only and so the idea is

00:37:41,520 --> 00:37:44,720
if you have a repo

00:37:42,640 --> 00:37:46,320
that you want to expose you can expose

00:37:44,720 --> 00:37:48,240
it to just those particular hosts and

00:37:46,320 --> 00:37:51,760
you can set up a specific network path

00:37:48,240 --> 00:37:54,880
the the point is um we want to make sure

00:37:51,760 --> 00:37:56,800
that if the host needs to be able to um

00:37:54,880 --> 00:37:58,000
reach that repository it has to be able

00:37:56,800 --> 00:37:59,520
to communicate from there

00:37:58,000 --> 00:38:00,720
so whether that be you know the way

00:37:59,520 --> 00:38:02,160
we're running it for the variants we

00:38:00,720 --> 00:38:03,920
manage whether there's an s3 bucket with

00:38:02,160 --> 00:38:06,560
a cloud front distribution

00:38:03,920 --> 00:38:08,560
or you just have a private bucket we

00:38:06,560 --> 00:38:09,839
want to make sure that at least

00:38:08,560 --> 00:38:11,680
you're storing it in a place that those

00:38:09,839 --> 00:38:13,119
hosts can actually reach it

00:38:11,680 --> 00:38:14,560
and it can be private to just those

00:38:13,119 --> 00:38:15,920
hosts so it doesn't need to be exposed

00:38:14,560 --> 00:38:17,599
to the world

00:38:15,920 --> 00:38:18,880
unless that's the point of the variant

00:38:17,599 --> 00:38:21,119
that you're making so imagine if you

00:38:18,880 --> 00:38:22,160
wanted to build a variant for say gcp or

00:38:21,119 --> 00:38:23,440
azure

00:38:22,160 --> 00:38:25,359
you would probably want to expose that

00:38:23,440 --> 00:38:26,160
repository in a way that we've done it

00:38:25,359 --> 00:38:29,200
for

00:38:26,160 --> 00:38:32,320
for aws so that it can do that

00:38:29,200 --> 00:38:34,320
so those hosts can actually reach it and

00:38:32,320 --> 00:38:37,200
so that's kind of the goal there

00:38:34,320 --> 00:38:38,640
are these generated generated images

00:38:37,200 --> 00:38:39,920
standard iso images that could be

00:38:38,640 --> 00:38:44,160
installed on a host

00:38:39,920 --> 00:38:45,599
offline i don't have a really good

00:38:44,160 --> 00:38:48,079
answer for this i believe we're using

00:38:45,599 --> 00:38:52,560
ovf format or vmdk format for the

00:38:48,079 --> 00:38:54,400
the the the disk image um

00:38:52,560 --> 00:38:56,400
so um that's one of those ones that i

00:38:54,400 --> 00:38:58,160
will probably um

00:38:56,400 --> 00:38:59,359
have to ask the team to to get a little

00:38:58,160 --> 00:39:00,240
bit more clarity on what that process

00:38:59,359 --> 00:39:02,079
should look like

00:39:00,240 --> 00:39:03,440
at the end of the the presentation i've

00:39:02,079 --> 00:39:05,200
got my twitter handle

00:39:03,440 --> 00:39:06,960
and so if there's a question along these

00:39:05,200 --> 00:39:09,440
lines that um i can't

00:39:06,960 --> 00:39:10,800
i can't quite answer on the the call by

00:39:09,440 --> 00:39:11,599
all means hit me up on twitter and the

00:39:10,800 --> 00:39:13,200
team and i will

00:39:11,599 --> 00:39:16,000
be happy to follow up with with

00:39:13,200 --> 00:39:18,240
additional answers and and conversation

00:39:16,000 --> 00:39:19,280
um so that one i will have to get back

00:39:18,240 --> 00:39:20,480
to you on so

00:39:19,280 --> 00:39:22,320
please feel free to hit me up at

00:39:20,480 --> 00:39:25,520
boringgeek and on twitter

00:39:22,320 --> 00:39:26,880
um when running bottle rocket os on ec2

00:39:25,520 --> 00:39:28,800
in order to start the admin container

00:39:26,880 --> 00:39:31,200
for troubleshooting we connect

00:39:28,800 --> 00:39:32,480
to the ec2 instance via ssm is there a

00:39:31,200 --> 00:39:34,000
way to start the admin container when

00:39:32,480 --> 00:39:38,320
running bottle rocket outs

00:39:34,000 --> 00:39:41,040
os outside aws and without access to ssm

00:39:38,320 --> 00:39:42,320
so yes essentially you can you can

00:39:41,040 --> 00:39:45,599
activate it two ways

00:39:42,320 --> 00:39:48,960
so you can activate it via the

00:39:45,599 --> 00:39:51,280
control container using the api itself

00:39:48,960 --> 00:39:53,359
or you can use user data so when that

00:39:51,280 --> 00:39:54,640
host is actually spun up the user data

00:39:53,359 --> 00:39:57,359
will actually specify

00:39:54,640 --> 00:39:58,400
whether or not the admin container can

00:39:57,359 --> 00:39:59,520
be activated

00:39:58,400 --> 00:40:01,760
so you don't necessarily need to

00:39:59,520 --> 00:40:03,359
activate it outside of aws but you can

00:40:01,760 --> 00:40:03,920
activate it as part of the provisioning

00:40:03,359 --> 00:40:05,760
scripts

00:40:03,920 --> 00:40:07,040
and and the user data for the host

00:40:05,760 --> 00:40:08,640
itself um

00:40:07,040 --> 00:40:10,160
and so it's there's there's kind of two

00:40:08,640 --> 00:40:12,720
ways to do that

00:40:10,160 --> 00:40:14,880
so that's that's one method regarding

00:40:12,720 --> 00:40:16,960
ebpf are the kernel headers included in

00:40:14,880 --> 00:40:17,280
bottle rocket or the the kernel compiled

00:40:16,960 --> 00:40:20,960
with

00:40:17,280 --> 00:40:23,119
k headers um

00:40:20,960 --> 00:40:24,640
i don't have the answer to this one

00:40:23,119 --> 00:40:27,119
honestly um

00:40:24,640 --> 00:40:28,720
i believe the headers are included um

00:40:27,119 --> 00:40:30,960
but i will validate that

00:40:28,720 --> 00:40:32,160
so tador if you want to hit me up at

00:40:30,960 --> 00:40:33,760
warboringgeek on twitter

00:40:32,160 --> 00:40:35,760
um i can validate that pardon me i can

00:40:33,760 --> 00:40:37,760
validate that for you

00:40:35,760 --> 00:40:39,359
and in fact you know i'm just gonna

00:40:37,760 --> 00:40:40,640
switch this over to the q a slide

00:40:39,359 --> 00:40:41,680
because we might as well just start

00:40:40,640 --> 00:40:44,000
diving into q

00:40:41,680 --> 00:40:45,119
a got about seven minutes left um is

00:40:44,000 --> 00:40:47,119
there a timeline for allowing bottle

00:40:45,119 --> 00:40:49,839
rocket via managed node groups

00:40:47,119 --> 00:40:50,319
or a timeline for gpu support i don't

00:40:49,839 --> 00:40:53,520
have

00:40:50,319 --> 00:40:56,640
a public time time for gpu support um

00:40:53,520 --> 00:40:57,440
and i i i know managed node groups is on

00:40:56,640 --> 00:40:59,200
target

00:40:57,440 --> 00:41:01,040
um so it is one of the goals that we

00:40:59,200 --> 00:41:03,920
want to to have out there

00:41:01,040 --> 00:41:05,040
um and so it's it's something you can do

00:41:03,920 --> 00:41:07,760
today as well

00:41:05,040 --> 00:41:09,440
um so it's i i want to be very clear

00:41:07,760 --> 00:41:11,119
it's like you can in in a managed node

00:41:09,440 --> 00:41:11,760
group you can actually specify a custom

00:41:11,119 --> 00:41:13,440
emi

00:41:11,760 --> 00:41:15,599
and so you can specify the bottle rocket

00:41:13,440 --> 00:41:18,960
ami and there's some config for that

00:41:15,599 --> 00:41:22,160
um if you hit me up on twitter

00:41:18,960 --> 00:41:25,440
i can actually share um our former

00:41:22,160 --> 00:41:27,920
uh evangelist actually has a

00:41:25,440 --> 00:41:30,160
github project that shows how to do this

00:41:27,920 --> 00:41:32,640
but you can basically specify

00:41:30,160 --> 00:41:33,200
um a custom emi for bottle rocket that

00:41:32,640 --> 00:41:34,800
will

00:41:33,200 --> 00:41:37,119
leverage the the same variant for say

00:41:34,800 --> 00:41:37,920
eks and we'll actually spin it up in a

00:41:37,119 --> 00:41:39,520
managed node group

00:41:37,920 --> 00:41:40,960
we are working to make that much more

00:41:39,520 --> 00:41:42,640
streamlined and just native it'll be

00:41:40,960 --> 00:41:44,079
part of the drop down essentially

00:41:42,640 --> 00:41:46,560
via manage no groups that's that's kind

00:41:44,079 --> 00:41:47,920
of the goal i don't have a timeline that

00:41:46,560 --> 00:41:48,720
i can share for that unfortunately but

00:41:47,920 --> 00:41:50,480
it is a

00:41:48,720 --> 00:41:51,520
a it is a very requested feature and

00:41:50,480 --> 00:41:52,400
it's something that we want to make sure

00:41:51,520 --> 00:41:55,440
happens

00:41:52,400 --> 00:41:57,359
um and then as far as gpu support i

00:41:55,440 --> 00:41:59,760
don't have a timeline for that but

00:41:57,359 --> 00:42:00,960
if you want to get a part of this oh and

00:41:59,760 --> 00:42:03,200
actually ben on

00:42:00,960 --> 00:42:04,160
the call is is responding so uh ben is

00:42:03,200 --> 00:42:05,680
one of our

00:42:04,160 --> 00:42:07,680
engineers or our principal engineer on

00:42:05,680 --> 00:42:10,400
the project um and so

00:42:07,680 --> 00:42:12,319
if you want a specific feature or you

00:42:10,400 --> 00:42:12,880
need a specific capability this is an

00:42:12,319 --> 00:42:15,280
open source

00:42:12,880 --> 00:42:16,720
project and so i want to make sure that

00:42:15,280 --> 00:42:18,560
you all understand like if you want to

00:42:16,720 --> 00:42:19,760
participate if you want to submit issues

00:42:18,560 --> 00:42:20,880
if you want to submit feature requests

00:42:19,760 --> 00:42:22,000
or even pull requests

00:42:20,880 --> 00:42:24,560
you can actually go directly to the

00:42:22,000 --> 00:42:26,160
project page at github.com rocket os

00:42:24,560 --> 00:42:28,800
and start to participate you can plus

00:42:26,160 --> 00:42:30,079
one features so if you need gpu support

00:42:28,800 --> 00:42:32,160
definitely go in and

00:42:30,079 --> 00:42:33,520
plus one that feature requests um ben

00:42:32,160 --> 00:42:35,200
has been very clear regarding kernel

00:42:33,520 --> 00:42:36,720
headers the kernel is compiled with k

00:42:35,200 --> 00:42:37,200
headers and we also make the kernel

00:42:36,720 --> 00:42:40,560
develop

00:42:37,200 --> 00:42:43,680
files available under slash user source

00:42:40,560 --> 00:42:46,960
kernels for the k-mod use case

00:42:43,680 --> 00:42:49,599
so that should be there um i'll be the

00:42:46,960 --> 00:42:51,200
why not this other tool guy why did you

00:42:49,599 --> 00:42:52,880
make your own build system instead of

00:42:51,200 --> 00:42:55,280
using available one like

00:42:52,880 --> 00:42:57,280
yakto for example a lot of the caching

00:42:55,280 --> 00:43:00,880
rpm packaging is done there

00:42:57,280 --> 00:43:03,440
um i don't have the the history

00:43:00,880 --> 00:43:03,920
on that one carlos unfortunately um i

00:43:03,440 --> 00:43:05,839
know

00:43:03,920 --> 00:43:07,200
that that we made selections around

00:43:05,839 --> 00:43:09,359
cargo and rust uh

00:43:07,200 --> 00:43:11,200
because of uh just that the language

00:43:09,359 --> 00:43:12,000
support and the kind of the security

00:43:11,200 --> 00:43:15,200
first

00:43:12,000 --> 00:43:18,400
capabilities of rust um and so

00:43:15,200 --> 00:43:19,760
i i i think from a simplicity standpoint

00:43:18,400 --> 00:43:21,040
that's why they went with it so

00:43:19,760 --> 00:43:23,200
everything was

00:43:21,040 --> 00:43:24,560
essentially in these these make files

00:43:23,200 --> 00:43:27,040
and tamil files and then

00:43:24,560 --> 00:43:28,720
by using cargo we could wire together

00:43:27,040 --> 00:43:29,200
all these disparate other capabilities

00:43:28,720 --> 00:43:31,200
together

00:43:29,200 --> 00:43:32,319
um pretty cleanly um in a way that

00:43:31,200 --> 00:43:34,160
worked pretty well

00:43:32,319 --> 00:43:35,520
but we are open to suggestions and so if

00:43:34,160 --> 00:43:36,960
there's um

00:43:35,520 --> 00:43:38,640
a better way of doing things by all

00:43:36,960 --> 00:43:40,960
means definitely come reach out to

00:43:38,640 --> 00:43:42,560
through the project and um you know if

00:43:40,960 --> 00:43:44,560
you want to submit a pull request

00:43:42,560 --> 00:43:47,119
and and offer suggestions like we would

00:43:44,560 --> 00:43:49,839
welcome participation uh gladly

00:43:47,119 --> 00:43:51,440
um in fact we've got a number of of of

00:43:49,839 --> 00:43:52,480
companies that are actually working with

00:43:51,440 --> 00:43:54,319
us directly on

00:43:52,480 --> 00:43:56,079
bottle rocket and building support for

00:43:54,319 --> 00:43:57,359
bottle rocket so we have a number of

00:43:56,079 --> 00:43:59,680
technology partners that are going

00:43:57,359 --> 00:44:01,280
through today um and are

00:43:59,680 --> 00:44:02,880
providing features and capability that

00:44:01,280 --> 00:44:05,680
most people are leveraging today

00:44:02,880 --> 00:44:06,640
or need and so if you want to extend

00:44:05,680 --> 00:44:07,920
this capability

00:44:06,640 --> 00:44:08,880
i'm going to go back over to this slide

00:44:07,920 --> 00:44:10,480
again if you want to extend the

00:44:08,880 --> 00:44:12,000
capability and participate by all means

00:44:10,480 --> 00:44:13,680
we welcome you in

00:44:12,000 --> 00:44:16,480
like i said at the beginning of the call

00:44:13,680 --> 00:44:19,280
we want to create additional variants

00:44:16,480 --> 00:44:20,560
to support additional workloads and and

00:44:19,280 --> 00:44:22,560
orchestrators and

00:44:20,560 --> 00:44:23,920
even cloud environments that is the

00:44:22,560 --> 00:44:25,440
long-term goal we want to make it so

00:44:23,920 --> 00:44:27,359
that bottle rocket is an os that you can

00:44:25,440 --> 00:44:30,480
run for all your container workloads

00:44:27,359 --> 00:44:32,160
um wherever they are um and so if you

00:44:30,480 --> 00:44:32,640
want to help participate in that by all

00:44:32,160 --> 00:44:34,640
means

00:44:32,640 --> 00:44:36,560
we we would love to to have you be a

00:44:34,640 --> 00:44:37,760
part of that um and if you want to get

00:44:36,560 --> 00:44:39,920
started with bottle rocket

00:44:37,760 --> 00:44:41,839
um you can go directly to the the bottle

00:44:39,920 --> 00:44:44,079
rocket project page

00:44:41,839 --> 00:44:45,119
and start getting uh getting your hands

00:44:44,079 --> 00:44:46,720
dirty with it today

00:44:45,119 --> 00:44:49,359
so um with that are there any other

00:44:46,720 --> 00:44:51,520
questions um any last-minute thoughts

00:44:49,359 --> 00:44:54,560
that that any of you have we've got

00:44:51,520 --> 00:44:57,920
about two more minutes left before

00:44:54,560 --> 00:44:57,920
we've got we've got to call it

00:44:59,359 --> 00:45:02,880
um so we got one that just came in so

00:45:01,359 --> 00:45:04,079
bottle rocket os would never be a

00:45:02,880 --> 00:45:06,079
full-blown os

00:45:04,079 --> 00:45:07,520
well technically it is a full-blown os

00:45:06,079 --> 00:45:10,160
so we should be very clear on that so

00:45:07,520 --> 00:45:12,640
bottle rocket os is a purpose built os

00:45:10,160 --> 00:45:13,520
um and so it is a full linux

00:45:12,640 --> 00:45:15,920
distribution

00:45:13,520 --> 00:45:17,280
it it comes with all the the necessary

00:45:15,920 --> 00:45:18,400
components and binaries and libraries

00:45:17,280 --> 00:45:20,000
you would need to run

00:45:18,400 --> 00:45:21,760
your containerized workloads the

00:45:20,000 --> 00:45:22,960
difference is it's not

00:45:21,760 --> 00:45:24,480
written in the same way as a general

00:45:22,960 --> 00:45:26,079
purpose os where if you consider a

00:45:24,480 --> 00:45:27,760
general purpose os

00:45:26,079 --> 00:45:29,920
it includes you know everything that you

00:45:27,760 --> 00:45:31,200
would need to run basically any workload

00:45:29,920 --> 00:45:32,400
you know you can compile and build

00:45:31,200 --> 00:45:35,520
whatever workflow you need

00:45:32,400 --> 00:45:37,359
for whatever workflow you needed um the

00:45:35,520 --> 00:45:39,280
point of bottle rocket os is really to

00:45:37,359 --> 00:45:42,319
kind of tighten up that security

00:45:39,280 --> 00:45:45,280
really minimize the footprint and and

00:45:42,319 --> 00:45:47,839
make it so it's focused on just running

00:45:45,280 --> 00:45:50,240
the container race workloads

00:45:47,839 --> 00:45:52,000
for that for that specific purpose if

00:45:50,240 --> 00:45:54,000
you wanted to make it a desktop os

00:45:52,000 --> 00:45:55,520
there's i i would imagine a certain

00:45:54,000 --> 00:45:59,040
degree of work that you would have to do

00:45:55,520 --> 00:46:01,599
because you would have to um build in

00:45:59,040 --> 00:46:02,079
support for you know something like a

00:46:01,599 --> 00:46:05,200
gnome

00:46:02,079 --> 00:46:06,640
or you know a desktop environment um and

00:46:05,200 --> 00:46:08,400
i i would imagine a lot of that would

00:46:06,640 --> 00:46:09,599
require additional binaries and

00:46:08,400 --> 00:46:12,079
libraries that we've actually

00:46:09,599 --> 00:46:13,200
removed from the system so it's not

00:46:12,079 --> 00:46:14,000
something that i would necessarily

00:46:13,200 --> 00:46:16,240
recommend for

00:46:14,000 --> 00:46:17,440
that kind of purpose like for a desktop

00:46:16,240 --> 00:46:19,440
environment typically you would want

00:46:17,440 --> 00:46:21,839
something that's more general purpose

00:46:19,440 --> 00:46:24,240
are kernel versions hard coded or can

00:46:21,839 --> 00:46:26,480
they be chosen on the variants

00:46:24,240 --> 00:46:27,359
and so when you saw my example of the

00:46:26,480 --> 00:46:31,119
code

00:46:27,359 --> 00:46:32,880
come up earlier carlos regarding the

00:46:31,119 --> 00:46:35,119
eks variant that we built we had a very

00:46:32,880 --> 00:46:37,359
specific version of kubernetes

00:46:35,119 --> 00:46:38,640
and the specific kernel version in that

00:46:37,359 --> 00:46:40,160
particular variant

00:46:38,640 --> 00:46:41,760
and so if you wanted to build a variant

00:46:40,160 --> 00:46:43,760
that had a different kernel

00:46:41,760 --> 00:46:45,839
version it would just be a matter of

00:46:43,760 --> 00:46:47,920
specifying how that that that would be

00:46:45,839 --> 00:46:49,200
built into that particular variant

00:46:47,920 --> 00:46:51,440
um and then you would have to go through

00:46:49,200 --> 00:46:54,079
any dependency management that would uh

00:46:51,440 --> 00:46:55,680
be required for that specific kernel but

00:46:54,079 --> 00:46:57,520
it is possible to go through and do that

00:46:55,680 --> 00:46:59,200
and if you think about how we've built

00:46:57,520 --> 00:47:00,880
um the kubernetes variants and even the

00:46:59,200 --> 00:47:02,720
ecs variants so far

00:47:00,880 --> 00:47:03,920
as we've evolved uh and upgraded the

00:47:02,720 --> 00:47:06,079
kernel we've done that

00:47:03,920 --> 00:47:07,680
um as part of that variant along the way

00:47:06,079 --> 00:47:10,000
so it has support for

00:47:07,680 --> 00:47:11,040
for the ability to specify that version

00:47:10,000 --> 00:47:12,880
it's just you're going to have to build

00:47:11,040 --> 00:47:13,280
that into your specific variant um and

00:47:12,880 --> 00:47:14,640
there's

00:47:13,280 --> 00:47:17,200
you know like i said there's examples in

00:47:14,640 --> 00:47:19,680
the code repository of these variants

00:47:17,200 --> 00:47:21,119
and those uh those uh make files so you

00:47:19,680 --> 00:47:23,040
can go through and see how that

00:47:21,119 --> 00:47:25,920
that process is built um if you want to

00:47:23,040 --> 00:47:27,760
dive into it a little bit more deeper

00:47:25,920 --> 00:47:28,960
can you post your linkedin and twitter

00:47:27,760 --> 00:47:31,680
id

00:47:28,960 --> 00:47:32,960
to get more updates on bottle rocket so

00:47:31,680 --> 00:47:35,760
i don't have my linkedin

00:47:32,960 --> 00:47:37,440
but it's slash curtis reecey my twitter

00:47:35,760 --> 00:47:42,160
handle is at boringgeek

00:47:37,440 --> 00:47:43,599
our project page is at github.com

00:47:42,160 --> 00:47:45,680
if you do want to participate and get

00:47:43,599 --> 00:47:47,200
more more feedback or more information

00:47:45,680 --> 00:47:49,440
by all means hit me up

00:47:47,200 --> 00:47:51,839
the team and i are very happy to to get

00:47:49,440 --> 00:47:53,200
anybody engaged and answer questions

00:47:51,839 --> 00:47:55,839
so feel free to hit me up whenever you

00:47:53,200 --> 00:47:58,960
want and i think with that

00:47:55,839 --> 00:47:58,960
we're actually at time

00:48:01,680 --> 00:48:05,280
all right thank you so much to curtis

00:48:03,520 --> 00:48:06,160
for his time today and thank you to all

00:48:05,280 --> 00:48:08,319
the participants

00:48:06,160 --> 00:48:09,920
who joined us as a reminder this

00:48:08,319 --> 00:48:12,319
recording will be on the linux

00:48:09,920 --> 00:48:13,839
foundation youtube page later today

00:48:12,319 --> 00:48:21,839
and we hope you're able to join us for

00:48:13,839 --> 00:48:21,839

YouTube URL: https://www.youtube.com/watch?v=0-Wn3DBBXlo


