Title: LF Live Webinar: Distributed Principles In A Cloud-Native Database
Publication date: 2021-06-03
Playlist: LF Live Webinars
Description: 
	sponsored by Cockroach Labs

CockroachDB is the only database architected and built from the ground up to deliver some key innovations that may not only provide value for your applications but might also give you insight into the challenges/solutions in distributed systems.

In this session, we will deliver a deep-dive exploration into the internals of the database.
Captions: 
	00:00:00,320 --> 00:00:05,120
great thank you very much uh we are

00:00:03,199 --> 00:00:07,279
recording this webinar wonderful

00:00:05,120 --> 00:00:10,080
um good morning good evening good

00:00:07,279 --> 00:00:12,639
afternoon good day to everybody

00:00:10,080 --> 00:00:15,360
my name is jim walker i am the vp of

00:00:12,639 --> 00:00:17,119
product marketing here at cockroach labs

00:00:15,360 --> 00:00:18,560
and i'm coming to you today from denver

00:00:17,119 --> 00:00:22,080
colorado with beautiful day

00:00:18,560 --> 00:00:22,880
so um you know we we have a database

00:00:22,080 --> 00:00:26,000
that um

00:00:22,880 --> 00:00:26,800
is cloud native um a database that was

00:00:26,000 --> 00:00:30,080
really built

00:00:26,800 --> 00:00:30,320
and and architected on some really kind

00:00:30,080 --> 00:00:33,120
of

00:00:30,320 --> 00:00:34,239
core you know distributed principles

00:00:33,120 --> 00:00:36,640
that i think you know

00:00:34,239 --> 00:00:37,520
have uh have have an impact on kind of

00:00:36,640 --> 00:00:39,680
the way that

00:00:37,520 --> 00:00:41,520
all of us think about our applications

00:00:39,680 --> 00:00:44,399
and services as we kind of move to the

00:00:41,520 --> 00:00:47,360
cloud and we deploy applications and so

00:00:44,399 --> 00:00:49,360
i'm hoping that this talk today while an

00:00:47,360 --> 00:00:52,480
overview of cockroach database

00:00:49,360 --> 00:00:54,079
um also opens uh eyes to

00:00:52,480 --> 00:00:55,760
some some special ways about thinking

00:00:54,079 --> 00:00:57,039
about data and thinking about systems in

00:00:55,760 --> 00:00:58,480
a distributed world

00:00:57,039 --> 00:01:00,719
and the way that we approach these

00:00:58,480 --> 00:01:02,320
things um

00:01:00,719 --> 00:01:04,000
you know people often ask us you know

00:01:02,320 --> 00:01:05,920
what kind of what level is this is

00:01:04,000 --> 00:01:07,439
a little bit more immediate you know i'm

00:01:05,920 --> 00:01:09,040
not gonna be hands-on code

00:01:07,439 --> 00:01:11,360
um but it's definitely not gonna be kind

00:01:09,040 --> 00:01:12,560
of ten thousand foot level either we're

00:01:11,360 --> 00:01:14,159
gonna we're gonna dive into the weeds

00:01:12,560 --> 00:01:15,040
we're gonna talk about raft we're gonna

00:01:14,159 --> 00:01:16,479
talk about

00:01:15,040 --> 00:01:18,240
which is a distributed consensus

00:01:16,479 --> 00:01:19,680
protocol we're gonna talk about uh

00:01:18,240 --> 00:01:20,880
you know distributed transactions and

00:01:19,680 --> 00:01:22,960
how you think about that and the

00:01:20,880 --> 00:01:24,560
distributed system in the data

00:01:22,960 --> 00:01:25,759
multi-version concurrency control

00:01:24,560 --> 00:01:27,600
another really kind of important

00:01:25,759 --> 00:01:29,119
algorithm to think about

00:01:27,600 --> 00:01:31,600
as we build out these distributed

00:01:29,119 --> 00:01:31,920
systems the effect of the speed of light

00:01:31,600 --> 00:01:34,880
on

00:01:31,920 --> 00:01:35,920
on what we do which as you move towards

00:01:34,880 --> 00:01:37,280
being distributed

00:01:35,920 --> 00:01:38,960
you no longer think about a single

00:01:37,280 --> 00:01:40,000
location you have to think about you

00:01:38,960 --> 00:01:41,280
know multiple and

00:01:40,000 --> 00:01:43,439
and the speed of light's no joke we

00:01:41,280 --> 00:01:44,000
can't beat it uh at this at this point

00:01:43,439 --> 00:01:45,439
at least i

00:01:44,000 --> 00:01:48,399
you know from what i understand we still

00:01:45,439 --> 00:01:50,000
can't uh get past that i i can't wait

00:01:48,399 --> 00:01:51,520
until we do but i don't know if i'll see

00:01:50,000 --> 00:01:52,799
that in my lifetime but but still so we

00:01:51,520 --> 00:01:54,000
have to deal with speed of light and how

00:01:52,799 --> 00:01:55,040
do we do that and then

00:01:54,000 --> 00:01:56,560
we'll talk about some of the things that

00:01:55,040 --> 00:01:57,759
we're doing in transaction pipelining

00:01:56,560 --> 00:02:00,479
some more advanced topics

00:01:57,759 --> 00:02:02,320
um in cockroach and hopefully throughout

00:02:00,479 --> 00:02:04,479
the way this is valuable to you

00:02:02,320 --> 00:02:06,079
more than just a introduction and kind

00:02:04,479 --> 00:02:08,000
of a under the covers into what

00:02:06,079 --> 00:02:09,599
cockroach database does

00:02:08,000 --> 00:02:10,879
and i hope it opens eyes from a

00:02:09,599 --> 00:02:12,400
development point of view of kind of

00:02:10,879 --> 00:02:14,480
what these things are now

00:02:12,400 --> 00:02:15,680
by way of introduction yeah i mean this

00:02:14,480 --> 00:02:17,599
is purely

00:02:15,680 --> 00:02:18,959
architected for the cloud this is not

00:02:17,599 --> 00:02:20,640
something that was like

00:02:18,959 --> 00:02:23,040
you know lift and shift let's take

00:02:20,640 --> 00:02:25,280
oracle run into a container in the cloud

00:02:23,040 --> 00:02:27,520
you know let's kind of deploy in a

00:02:25,280 --> 00:02:28,640
way that is kind of in a cloud and

00:02:27,520 --> 00:02:31,120
distributed but

00:02:28,640 --> 00:02:31,760
not totally cloud native not like not

00:02:31,120 --> 00:02:32,959
aligned

00:02:31,760 --> 00:02:34,640
with you know some of the core

00:02:32,959 --> 00:02:35,280
principles i think a lot of them are in

00:02:34,640 --> 00:02:37,120
there

00:02:35,280 --> 00:02:38,400
um but but how do we actually deal with

00:02:37,120 --> 00:02:40,000
you know these things in broadly

00:02:38,400 --> 00:02:41,599
distributed environments it's not it's

00:02:40,000 --> 00:02:42,560
not move and improve it's not take

00:02:41,599 --> 00:02:43,680
something

00:02:42,560 --> 00:02:45,920
change one piece of it to make

00:02:43,680 --> 00:02:48,319
distributed there's an emergence of

00:02:45,920 --> 00:02:50,480
a group of of databases that that are

00:02:48,319 --> 00:02:52,080
truly distributed and we we think about

00:02:50,480 --> 00:02:54,080
distributed systems looking at the code

00:02:52,080 --> 00:02:57,120
bases of these systems i think is

00:02:54,080 --> 00:02:58,480
is is truly uh valuable i i like to

00:02:57,120 --> 00:03:01,519
think of the code base of

00:02:58,480 --> 00:03:02,959
of cockroach database as almost a phd in

00:03:01,519 --> 00:03:04,720
distributed systems um

00:03:02,959 --> 00:03:06,239
and it's all open it's it's all open

00:03:04,720 --> 00:03:08,560
source so you know

00:03:06,239 --> 00:03:10,640
our git repo if you if you code and go

00:03:08,560 --> 00:03:12,319
uh it's an extra bonus because it's it's

00:03:10,640 --> 00:03:15,840
all go code so

00:03:12,319 --> 00:03:16,560
um it is it is a a great implementation

00:03:15,840 --> 00:03:19,120
you know

00:03:16,560 --> 00:03:20,879
things that we do uh in cockroach you

00:03:19,120 --> 00:03:23,200
know get contributed upstream like you

00:03:20,879 --> 00:03:26,400
know our raft implementation is

00:03:23,200 --> 00:03:28,000
has had many you know um pr's posted

00:03:26,400 --> 00:03:30,400
against you know etcd

00:03:28,000 --> 00:03:32,640
and etcd raft which is kind of a core

00:03:30,400 --> 00:03:33,760
component of kubernetes as well

00:03:32,640 --> 00:03:36,080
you know some of the things that we're

00:03:33,760 --> 00:03:37,920
running into in terms of you know being

00:03:36,080 --> 00:03:39,680
truly multi-master in those type of

00:03:37,920 --> 00:03:41,040
environments these these broadly

00:03:39,680 --> 00:03:42,400
distributed environments where the speed

00:03:41,040 --> 00:03:44,480
of light actually

00:03:42,400 --> 00:03:46,159
does have an impact on on how quickly

00:03:44,480 --> 00:03:49,280
things are actually committing

00:03:46,159 --> 00:03:50,400
uh in in places like in that cd and and

00:03:49,280 --> 00:03:52,400
how we use raft like

00:03:50,400 --> 00:03:54,640
for atomic replication you know we've

00:03:52,400 --> 00:03:56,480
contributed that stuff upstream and so

00:03:54,640 --> 00:03:58,480
you know i look at those projects as

00:03:56,480 --> 00:04:00,879
kind of the the core kind of components

00:03:58,480 --> 00:04:03,040
i i think are great for people to learn

00:04:00,879 --> 00:04:04,640
a lot about distributed systems and and

00:04:03,040 --> 00:04:05,840
how to code these things i always learn

00:04:04,640 --> 00:04:08,239
through code so

00:04:05,840 --> 00:04:10,239
i find it to be the best way to go so um

00:04:08,239 --> 00:04:12,640
but this is truly cloud native this is

00:04:10,239 --> 00:04:14,400
you know it's it's distributed sql

00:04:12,640 --> 00:04:15,680
um you know the category which you know

00:04:14,400 --> 00:04:18,479
matt aslett who is a

00:04:15,680 --> 00:04:20,079
analyst at 451 group about eight or nine

00:04:18,479 --> 00:04:21,040
years ago started calling the space news

00:04:20,079 --> 00:04:22,720
sql and

00:04:21,040 --> 00:04:24,080
actually last week or two weeks ago or

00:04:22,720 --> 00:04:26,240
something he published new

00:04:24,080 --> 00:04:28,320
uh research finding where he actually

00:04:26,240 --> 00:04:29,199
has just agreed this is distributed sql

00:04:28,320 --> 00:04:31,040
it's

00:04:29,199 --> 00:04:32,880
it's more descriptive of what these

00:04:31,040 --> 00:04:34,720
databases are doing and and for me

00:04:32,880 --> 00:04:36,160
there's really kind of five

00:04:34,720 --> 00:04:37,280
key requirements to be distributed

00:04:36,160 --> 00:04:38,880
sequel number one well it's got to be

00:04:37,280 --> 00:04:40,000
sql we're not talking about a new

00:04:38,880 --> 00:04:42,160
language

00:04:40,000 --> 00:04:43,360
um let's let's let it work and let's be

00:04:42,160 --> 00:04:44,479
familiar and let it work with all the

00:04:43,360 --> 00:04:46,400
things we already use

00:04:44,479 --> 00:04:48,160
um you have to build scale into the

00:04:46,400 --> 00:04:50,240
system that's a core principle of

00:04:48,160 --> 00:04:51,919
of distributed systems it has to you

00:04:50,240 --> 00:04:53,520
have to build for resilience in the

00:04:51,919 --> 00:04:55,520
system not around it

00:04:53,520 --> 00:04:56,960
don't don't surround it with technology

00:04:55,520 --> 00:04:58,240
to make it resilient and make it

00:04:56,960 --> 00:04:59,919
available all everywhere

00:04:58,240 --> 00:05:01,680
right i think that's one of another core

00:04:59,919 --> 00:05:03,840
principle two of them actually

00:05:01,680 --> 00:05:05,360
resilience make it available and make it

00:05:03,840 --> 00:05:07,520
available everywhere

00:05:05,360 --> 00:05:09,120
uh uh and then you know if we're gonna

00:05:07,520 --> 00:05:11,919
be a relational

00:05:09,120 --> 00:05:12,320
kind of database in this new world um

00:05:11,919 --> 00:05:15,039
you know

00:05:12,320 --> 00:05:16,160
having transactions and and and uh you

00:05:15,039 --> 00:05:18,000
know understanding

00:05:16,160 --> 00:05:19,600
guarantees around consistency also

00:05:18,000 --> 00:05:22,720
really important and then

00:05:19,600 --> 00:05:24,160
tying data location is the only way

00:05:22,720 --> 00:05:26,400
that we're going to be able to get past

00:05:24,160 --> 00:05:29,680
the speed of light period

00:05:26,400 --> 00:05:31,520
um and and lock stock and barrel um a

00:05:29,680 --> 00:05:32,880
core kind of concept you know when you

00:05:31,520 --> 00:05:34,639
when you think about a database in a

00:05:32,880 --> 00:05:37,840
distributed system

00:05:34,639 --> 00:05:39,120
um we have lots of conversations with

00:05:37,840 --> 00:05:40,800
people around this and our in our

00:05:39,120 --> 00:05:42,000
community and within our customers

00:05:40,800 --> 00:05:43,360
you know typically when you deploy a

00:05:42,000 --> 00:05:45,280
database you know you're going to prop

00:05:43,360 --> 00:05:46,240
up postgres or whatever and

00:05:45,280 --> 00:05:48,800
you know you're going to think about

00:05:46,240 --> 00:05:50,479
tables and columns and referential

00:05:48,800 --> 00:05:51,680
integrity and

00:05:50,479 --> 00:05:54,160
you know and you're just going to

00:05:51,680 --> 00:05:55,280
architect your your your your logical

00:05:54,160 --> 00:05:56,960
data model

00:05:55,280 --> 00:05:58,800
what's interesting when you move towards

00:05:56,960 --> 00:05:59,440
distributed systems and a distributed

00:05:58,800 --> 00:06:00,880
sql

00:05:59,440 --> 00:06:02,960
you have to start thinking about the

00:06:00,880 --> 00:06:04,800
physical model and and and how do we

00:06:02,960 --> 00:06:06,880
simplify the physical model so that

00:06:04,800 --> 00:06:08,319
you know data does live closest to the

00:06:06,880 --> 00:06:10,400
user um

00:06:08,319 --> 00:06:11,360
how do we disperse data throughout a

00:06:10,400 --> 00:06:14,080
cluster so that

00:06:11,360 --> 00:06:15,039
i can survive the failure of of a node

00:06:14,080 --> 00:06:17,759
or a rack

00:06:15,039 --> 00:06:18,800
an entire availability zone or a region

00:06:17,759 --> 00:06:20,800
or for that matter

00:06:18,800 --> 00:06:22,319
maybe a kubernetes cluster and so you

00:06:20,800 --> 00:06:25,440
got to start thinking about

00:06:22,319 --> 00:06:26,880
latency and and and resilience and what

00:06:25,440 --> 00:06:28,319
you want to survive

00:06:26,880 --> 00:06:29,919
when you're in distributed systems

00:06:28,319 --> 00:06:31,280
because that's what this is all about

00:06:29,919 --> 00:06:31,759
and i think this is where we're headed

00:06:31,280 --> 00:06:33,120
with

00:06:31,759 --> 00:06:34,240
with everything from a cloud native

00:06:33,120 --> 00:06:35,360
point of view and i think these are the

00:06:34,240 --> 00:06:37,520
core concepts that

00:06:35,360 --> 00:06:39,600
i feel really kind of define distributed

00:06:37,520 --> 00:06:41,039
sql now as a quick overview

00:06:39,600 --> 00:06:42,639
um let me just run through really

00:06:41,039 --> 00:06:44,000
quickly this is how we talk about

00:06:42,639 --> 00:06:45,520
cockroach at a very high level and i'm

00:06:44,000 --> 00:06:48,319
going to get really deep in the reads

00:06:45,520 --> 00:06:50,080
really quick okay you know cockroach

00:06:48,319 --> 00:06:51,680
i'll come back to that cockroach is a

00:06:50,080 --> 00:06:52,560
cloud native database it's a relational

00:06:51,680 --> 00:06:54,880
database

00:06:52,560 --> 00:06:56,400
uh we built an interface on this which

00:06:54,880 --> 00:06:58,560
is wire compatible

00:06:56,400 --> 00:07:00,639
with postgres so this is just the

00:06:58,560 --> 00:07:02,319
familiar sql database that we're all

00:07:00,639 --> 00:07:03,919
kind of used to for these kind of

00:07:02,319 --> 00:07:05,599
you know these transactional workloads

00:07:03,919 --> 00:07:06,400
heavy read write transactional workloads

00:07:05,599 --> 00:07:08,080
i think when

00:07:06,400 --> 00:07:09,919
kubernetes first started it's like oh

00:07:08,080 --> 00:07:10,800
it's for stateless and how do we do

00:07:09,919 --> 00:07:12,960
state and i

00:07:10,800 --> 00:07:14,400
i just think of you know every

00:07:12,960 --> 00:07:15,199
application has a database typically

00:07:14,400 --> 00:07:16,720
right so

00:07:15,199 --> 00:07:18,639
um this is a database that was really

00:07:16,720 --> 00:07:19,440
built and architected for this new world

00:07:18,639 --> 00:07:22,240
in fact

00:07:19,440 --> 00:07:22,960
cockroach database uh is is spawn of

00:07:22,240 --> 00:07:26,160
spanner

00:07:22,960 --> 00:07:28,160
um you know we we actually uh built off

00:07:26,160 --> 00:07:29,759
of the google cloud spanner white paper

00:07:28,160 --> 00:07:31,520
which you know you know if you look at

00:07:29,759 --> 00:07:33,280
you know jeff dean and and sanjay

00:07:31,520 --> 00:07:34,319
gemmawat and eric brewer and all they've

00:07:33,280 --> 00:07:35,680
done at google and what they've

00:07:34,319 --> 00:07:37,599
contributed to the world's

00:07:35,680 --> 00:07:38,960
phenomenal you know we took one of that

00:07:37,599 --> 00:07:40,319
paper and we built it so that it's it's

00:07:38,960 --> 00:07:41,960
available everywhere in fact

00:07:40,319 --> 00:07:43,520
kelsey is kind of a luminary in the

00:07:41,960 --> 00:07:45,360
kubernetes

00:07:43,520 --> 00:07:46,960
some of you may know him uh he tweeted

00:07:45,360 --> 00:07:48,639
this it was a couple years ago cockroach

00:07:46,960 --> 00:07:49,520
teased with spanner as kubernetes as the

00:07:48,639 --> 00:07:51,919
borg

00:07:49,520 --> 00:07:53,680
we are very well aligned with kubernetes

00:07:51,919 --> 00:07:55,599
and i think that's a core kind of piece

00:07:53,680 --> 00:07:57,120
right but also it's just basically a

00:07:55,599 --> 00:07:58,960
relational database

00:07:57,120 --> 00:08:00,560
this is a series of nodes all we do to

00:07:58,960 --> 00:08:01,680
scale the database we spin up a node

00:08:00,560 --> 00:08:03,039
pointed at the cluster

00:08:01,680 --> 00:08:04,720
and the database takes care about

00:08:03,039 --> 00:08:07,360
distribution of data

00:08:04,720 --> 00:08:09,039
every node in cockroach can accept both

00:08:07,360 --> 00:08:10,639
reads and writes every node is an

00:08:09,039 --> 00:08:12,720
endpoint which is another critical point

00:08:10,639 --> 00:08:14,319
we'll talk about that a bit

00:08:12,720 --> 00:08:16,080
we can scale within a single region we

00:08:14,319 --> 00:08:16,639
can actually scale across multiple

00:08:16,080 --> 00:08:19,039
regions

00:08:16,639 --> 00:08:20,400
this could be multiple clusters um and

00:08:19,039 --> 00:08:21,919
and how do you implement a single

00:08:20,400 --> 00:08:24,000
logical database across multiple

00:08:21,919 --> 00:08:25,680
different customers so don't federate

00:08:24,000 --> 00:08:27,120
you know the clusters just manage each

00:08:25,680 --> 00:08:27,840
one of those maybe we just federate at

00:08:27,120 --> 00:08:29,680
the data layer

00:08:27,840 --> 00:08:31,039
right and so i know those people who are

00:08:29,680 --> 00:08:32,000
interested in kind of federation of

00:08:31,039 --> 00:08:33,360
kubernetes is

00:08:32,000 --> 00:08:35,360
very very interesting but we can also do

00:08:33,360 --> 00:08:36,560
this cross clouds we can have

00:08:35,360 --> 00:08:38,399
multi-region but it can be

00:08:36,560 --> 00:08:40,159
multi-cloud as well i can have now a

00:08:38,399 --> 00:08:41,839
single logical database where any

00:08:40,159 --> 00:08:43,279
endpoint can access data

00:08:41,839 --> 00:08:44,480
across the entirety of the database

00:08:43,279 --> 00:08:45,519
that's deployed across three different

00:08:44,480 --> 00:08:48,399
cloud providers

00:08:45,519 --> 00:08:49,600
which i believe is truly phenomenal um

00:08:48,399 --> 00:08:52,000
and one of those things that really

00:08:49,600 --> 00:08:54,160
really excites me about about cockroach

00:08:52,000 --> 00:08:56,240
um it's naturally resilient right we can

00:08:54,160 --> 00:08:57,600
survive the failure of a node or a rack

00:08:56,240 --> 00:08:59,680
an easy an entire

00:08:57,600 --> 00:09:01,839
region it just depends on how we

00:08:59,680 --> 00:09:02,880
distribute data within the cluster

00:09:01,839 --> 00:09:05,279
right because we're actually writing

00:09:02,880 --> 00:09:07,360
data in triplicate so in this case maybe

00:09:05,279 --> 00:09:08,080
have one copy of data in each different

00:09:07,360 --> 00:09:10,000
cluster

00:09:08,080 --> 00:09:11,760
so that if one one cluster goes down i

00:09:10,000 --> 00:09:13,040
still have a remaining two copies of

00:09:11,760 --> 00:09:15,920
that data

00:09:13,040 --> 00:09:17,680
we can change the replication factor and

00:09:15,920 --> 00:09:18,800
really this this distribution of data

00:09:17,680 --> 00:09:20,800
comes down to

00:09:18,800 --> 00:09:22,160
you know how you actually want to get

00:09:20,800 --> 00:09:24,959
data closest to

00:09:22,160 --> 00:09:26,800
latency for for access and resilience

00:09:24,959 --> 00:09:27,519
and we're doing it at the row level in

00:09:26,800 --> 00:09:29,920
cockroach and

00:09:27,519 --> 00:09:32,080
we'll show you that as well again every

00:09:29,920 --> 00:09:34,080
node is an endpoint i can ask for data

00:09:32,080 --> 00:09:35,200
if i'm on say the us west cluster

00:09:34,080 --> 00:09:37,680
and it's going to be able to find that

00:09:35,200 --> 00:09:40,880
data say on a usb's cluster

00:09:37,680 --> 00:09:41,680
but i can also do things like i can also

00:09:40,880 --> 00:09:42,880
do things like

00:09:41,680 --> 00:09:44,000
you know i'm going to ask for data on

00:09:42,880 --> 00:09:45,760
the east coast and well i'm going to

00:09:44,000 --> 00:09:46,160
make sure that data is closest to user

00:09:45,760 --> 00:09:48,000
so

00:09:46,160 --> 00:09:50,240
i can actually uh you know deal with

00:09:48,000 --> 00:09:52,240
that um

00:09:50,240 --> 00:09:53,839
the speed of light right and so get data

00:09:52,240 --> 00:09:55,440
very very close to users

00:09:53,839 --> 00:09:56,959
people love this as well if you start

00:09:55,440 --> 00:09:58,320
thinking about the the

00:09:56,959 --> 00:10:00,000
sovereignty laws that are in place and

00:09:58,320 --> 00:10:02,160
data privacy you know

00:10:00,000 --> 00:10:04,160
can i have data that is you know german

00:10:02,160 --> 00:10:05,519
data live in german servers and so

00:10:04,160 --> 00:10:06,399
that's just all part of the setup in

00:10:05,519 --> 00:10:08,000
cockroach so

00:10:06,399 --> 00:10:10,000
we can start to help with some of these

00:10:08,000 --> 00:10:11,519
complex data compliance

00:10:10,000 --> 00:10:14,079
regulations that are going out there as

00:10:11,519 --> 00:10:15,600
well right so okay so let's get into the

00:10:14,079 --> 00:10:15,920
details right so that was about i don't

00:10:15,600 --> 00:10:18,240
know

00:10:15,920 --> 00:10:19,440
i guess i guess i did about nine minutes

00:10:18,240 --> 00:10:21,680
as an intro

00:10:19,440 --> 00:10:23,440
and probably about five on on unlike the

00:10:21,680 --> 00:10:25,440
the top level of cockroach i

00:10:23,440 --> 00:10:27,120
go out and try it is the best way i mean

00:10:25,440 --> 00:10:28,640
cockroach db core which is the open

00:10:27,120 --> 00:10:30,160
source version you go download and start

00:10:28,640 --> 00:10:31,839
you know dealing with yourself

00:10:30,160 --> 00:10:33,440
you know go into cockroach cloud and

00:10:31,839 --> 00:10:34,240
spin up a cluster and start playing with

00:10:33,440 --> 00:10:37,360
this today if

00:10:34,240 --> 00:10:38,560
you want to right okay so great now how

00:10:37,360 --> 00:10:40,240
do we do all this

00:10:38,560 --> 00:10:42,399
you know ultimately i think of every

00:10:40,240 --> 00:10:42,800
database in three layers i think there's

00:10:42,399 --> 00:10:44,880
a

00:10:42,800 --> 00:10:46,959
a communication or a language right

00:10:44,880 --> 00:10:48,560
there is a you know how do i interact

00:10:46,959 --> 00:10:50,000
with that and to me that's just sql you

00:10:48,560 --> 00:10:51,600
know we made a choice a long time ago to

00:10:50,000 --> 00:10:53,360
be wire compatible with postgres

00:10:51,600 --> 00:10:55,839
and we've done a lot of work to to build

00:10:53,360 --> 00:10:57,680
out that sql syntax so that it is filmer

00:10:55,839 --> 00:10:59,440
for people i i don't know i learned sql

00:10:57,680 --> 00:11:01,839
in college and so i've been

00:10:59,440 --> 00:11:03,360
i've been speaking sql my whole life at

00:11:01,839 --> 00:11:05,120
the very bottom layer

00:11:03,360 --> 00:11:06,480
is the storage layer how does you know

00:11:05,120 --> 00:11:08,000
ultimately a database is actually going

00:11:06,480 --> 00:11:08,720
to write to disk at some point right

00:11:08,000 --> 00:11:11,600
like

00:11:08,720 --> 00:11:12,720
that's the whole point um storing data

00:11:11,600 --> 00:11:14,880
and then in between

00:11:12,720 --> 00:11:16,880
the language and the storage is the

00:11:14,880 --> 00:11:17,680
execution you know every transaction you

00:11:16,880 --> 00:11:20,560
know

00:11:17,680 --> 00:11:21,839
select star from customer well that's

00:11:20,560 --> 00:11:24,480
going to get broken down into

00:11:21,839 --> 00:11:25,920
say three different um transactions this

00:11:24,480 --> 00:11:28,079
uh you know a start

00:11:25,920 --> 00:11:29,920
the transaction itself and then a commit

00:11:28,079 --> 00:11:31,200
more complex queries get broken down

00:11:29,920 --> 00:11:33,360
into lots of different

00:11:31,200 --> 00:11:34,640
transactions underneath right and and

00:11:33,360 --> 00:11:37,360
the database actually

00:11:34,640 --> 00:11:38,560
does that for us for us you know mere

00:11:37,360 --> 00:11:39,920
mortals we don't think about the

00:11:38,560 --> 00:11:41,519
transactions inside

00:11:39,920 --> 00:11:43,360
unless you're optimizing queries you're

00:11:41,519 --> 00:11:45,360
a dba these sort of things but

00:11:43,360 --> 00:11:46,640
uh when you're building a database this

00:11:45,360 --> 00:11:49,600
is where

00:11:46,640 --> 00:11:51,040
things can go awry if it was easy to

00:11:49,600 --> 00:11:52,720
build a database everybody would be

00:11:51,040 --> 00:11:53,839
doing it but it's all the corner cases

00:11:52,720 --> 00:11:55,760
across all the different types of

00:11:53,839 --> 00:11:57,120
transactions and and issues that can

00:11:55,760 --> 00:11:58,160
happen where things get really really

00:11:57,120 --> 00:11:59,760
interesting and so

00:11:58,160 --> 00:12:01,440
doing this in a distributed system

00:11:59,760 --> 00:12:02,880
creates some significant

00:12:01,440 --> 00:12:04,880
challenges from an architecture point of

00:12:02,880 --> 00:12:06,560
view now

00:12:04,880 --> 00:12:09,200
ultimately at the lowest layer at the

00:12:06,560 --> 00:12:12,399
storage layer cockroach is implemented

00:12:09,200 --> 00:12:13,839
as a kv store it's it's a

00:12:12,399 --> 00:12:15,680
cockroach database actually is a

00:12:13,839 --> 00:12:17,600
database on top of a database

00:12:15,680 --> 00:12:19,440
um you know cockroach uses something

00:12:17,600 --> 00:12:20,959
called pebble pebble db

00:12:19,440 --> 00:12:23,200
and pebble is something that actually we

00:12:20,959 --> 00:12:24,639
built and launched about a year ago we

00:12:23,200 --> 00:12:24,959
were originally built on something

00:12:24,639 --> 00:12:28,240
called

00:12:24,959 --> 00:12:31,040
rocks um and we actually rebuilt rocks

00:12:28,240 --> 00:12:31,600
basically um refactored it at some for

00:12:31,040 --> 00:12:32,720
for

00:12:31,600 --> 00:12:34,079
for some interesting things that we

00:12:32,720 --> 00:12:35,120
needed to do around multi-tenancy and

00:12:34,079 --> 00:12:37,839
whatnot

00:12:35,120 --> 00:12:39,440
but we rewrote it and go uh and so

00:12:37,839 --> 00:12:40,880
that's a kv store

00:12:39,440 --> 00:12:43,040
that that is the lowest layer of

00:12:40,880 --> 00:12:45,440
cockroach and ultimately for cockroach

00:12:43,040 --> 00:12:47,360
every table every row is is really kind

00:12:45,440 --> 00:12:48,480
of ordered as this monolithic logical

00:12:47,360 --> 00:12:50,160
key space right so

00:12:48,480 --> 00:12:51,680
you could think of this dogs table and

00:12:50,160 --> 00:12:52,160
here we are alphabetically for all the

00:12:51,680 --> 00:12:54,000
dogs

00:12:52,160 --> 00:12:55,360
that's the keys right and so everything

00:12:54,000 --> 00:12:58,079
is basically ordered

00:12:55,360 --> 00:12:59,600
every single table now in a traditional

00:12:58,079 --> 00:13:00,880
database the way this works say you have

00:12:59,600 --> 00:13:02,399
an inventory table

00:13:00,880 --> 00:13:04,959
you know every time i wanted to write

00:13:02,399 --> 00:13:07,120
something glove balls shirt shoes bat

00:13:04,959 --> 00:13:08,720
shoes if i wanted to write ball again i

00:13:07,120 --> 00:13:11,040
would append another record at the

00:13:08,720 --> 00:13:13,200
bottom of this this this storage right

00:13:11,040 --> 00:13:15,279
for the inventory and i use a an index

00:13:13,200 --> 00:13:17,120
to actually access these things quickly

00:13:15,279 --> 00:13:19,279
this is the traditional model right and

00:13:17,120 --> 00:13:22,160
this is kind of the structured data now

00:13:19,279 --> 00:13:24,000
structured data to me is elegant right

00:13:22,160 --> 00:13:26,000
structured data to me is what allows us

00:13:24,000 --> 00:13:27,600
to model a database like

00:13:26,000 --> 00:13:28,959
when you start to deal with like json

00:13:27,600 --> 00:13:30,639
objects and this sort of stuff or a

00:13:28,959 --> 00:13:34,480
document model database

00:13:30,639 --> 00:13:36,480
once you get above 10 12 objects

00:13:34,480 --> 00:13:38,079
making changes to these structures

00:13:36,480 --> 00:13:40,160
become really kind of

00:13:38,079 --> 00:13:41,680
difficult right because you know you're

00:13:40,160 --> 00:13:42,320
actually relying on the translation of

00:13:41,680 --> 00:13:44,079
these things

00:13:42,320 --> 00:13:46,000
in other places and not in the database

00:13:44,079 --> 00:13:46,959
itself let the database maintain the

00:13:46,000 --> 00:13:48,959
structure and so

00:13:46,959 --> 00:13:50,720
for us having this kind of relational

00:13:48,959 --> 00:13:52,480
structure is a kind of a core

00:13:50,720 --> 00:13:55,440
foundational component of what we're

00:13:52,480 --> 00:13:57,279
doing uh but but how do we take this

00:13:55,440 --> 00:13:58,959
and approach it in a different way so it

00:13:57,279 --> 00:14:00,720
can actually be distributed and so

00:13:58,959 --> 00:14:02,480
ultimately like i said we're a kv store

00:14:00,720 --> 00:14:04,800
underneath now

00:14:02,480 --> 00:14:06,880
this tabular data is all stored in this

00:14:04,800 --> 00:14:07,839
order and then basically we're using a

00:14:06,880 --> 00:14:10,880
kv pier

00:14:07,839 --> 00:14:11,360
kv pair where the k is the name of the

00:14:10,880 --> 00:14:14,240
table

00:14:11,360 --> 00:14:15,920
the index uh the key and column name and

00:14:14,240 --> 00:14:16,800
then the value is actually the column

00:14:15,920 --> 00:14:17,839
value so

00:14:16,800 --> 00:14:19,519
let me just show you how this works

00:14:17,839 --> 00:14:21,360
right so here's this simple dogs table

00:14:19,519 --> 00:14:22,959
we have id name and weight it's simple

00:14:21,360 --> 00:14:24,160
ddl there's some entries over on the

00:14:22,959 --> 00:14:25,600
right hand side

00:14:24,160 --> 00:14:27,760
and so let's just look at this table

00:14:25,600 --> 00:14:30,160
here's four entries

00:14:27,760 --> 00:14:31,839
these things get broken down into two

00:14:30,160 --> 00:14:33,600
records in the kv store

00:14:31,839 --> 00:14:36,480
right i first have the table name here's

00:14:33,600 --> 00:14:37,920
the key which is the id here i guess 34

00:14:36,480 --> 00:14:39,600
and then the column is going to be name

00:14:37,920 --> 00:14:41,040
and that value is carl

00:14:39,600 --> 00:14:43,680
and then i have you know the table the

00:14:41,040 --> 00:14:45,920
dog the id is 34 the column name is

00:14:43,680 --> 00:14:48,560
weight that value is 10.1

00:14:45,920 --> 00:14:50,000
now what we're doing is every single row

00:14:48,560 --> 00:14:51,760
gets broken out like this now we're

00:14:50,000 --> 00:14:53,920
encoding the key

00:14:51,760 --> 00:14:55,360
down into you know into hex so that we

00:14:53,920 --> 00:14:57,360
actually have some really really

00:14:55,360 --> 00:14:58,800
you know wonderful you know sorting

00:14:57,360 --> 00:15:00,480
going on and whatnot

00:14:58,800 --> 00:15:01,920
um very very quick sorting but but

00:15:00,480 --> 00:15:02,959
ultimately if you look at this like if

00:15:01,920 --> 00:15:05,120
you look at the keys

00:15:02,959 --> 00:15:06,959
they are ordered now when we want to

00:15:05,120 --> 00:15:08,720
insert something we know exactly where

00:15:06,959 --> 00:15:09,279
to insert this into the table based on

00:15:08,720 --> 00:15:10,399
the key

00:15:09,279 --> 00:15:12,320
and everything is always going to be

00:15:10,399 --> 00:15:14,560
ordered and cockroach

00:15:12,320 --> 00:15:15,680
in the meanwhile manages all of this in

00:15:14,560 --> 00:15:16,160
the background this is just all

00:15:15,680 --> 00:15:18,160
happening

00:15:16,160 --> 00:15:19,760
unbeknownst to you know the developer

00:15:18,160 --> 00:15:22,000
who's just writing a sql query

00:15:19,760 --> 00:15:22,880
right and we're doing this because it

00:15:22,000 --> 00:15:24,880
allows us for

00:15:22,880 --> 00:15:26,480
massive efficiencies in in the way that

00:15:24,880 --> 00:15:28,160
we sort data and allows us

00:15:26,480 --> 00:15:29,759
to distribute data in a very very

00:15:28,160 --> 00:15:31,920
intelligent way

00:15:29,759 --> 00:15:33,279
right we're going to take this this this

00:15:31,920 --> 00:15:34,160
range right we're going to take this

00:15:33,279 --> 00:15:35,279
entire table

00:15:34,160 --> 00:15:37,519
and we're going to break it down in

00:15:35,279 --> 00:15:38,160
these contiguous kind of 512 megabit

00:15:37,519 --> 00:15:40,320
ranges like

00:15:38,160 --> 00:15:41,199
we just upgraded this from 256 to 512

00:15:40,320 --> 00:15:43,360
recently

00:15:41,199 --> 00:15:44,720
um these ranges are small enough so that

00:15:43,360 --> 00:15:46,959
we can actually

00:15:44,720 --> 00:15:49,360
you know move them quickly while while

00:15:46,959 --> 00:15:51,759
making sure that the overhead of an

00:15:49,360 --> 00:15:53,440
index to find these things is

00:15:51,759 --> 00:15:54,000
appropriate from a performance point of

00:15:53,440 --> 00:15:55,759
view as well

00:15:54,000 --> 00:15:57,440
so let's take this table we're going to

00:15:55,759 --> 00:15:59,360
break it down into three ranges

00:15:57,440 --> 00:16:01,440
you know we have carl through jack lady

00:15:59,360 --> 00:16:03,120
through pd pine top through z

00:16:01,440 --> 00:16:05,279
these are all my friends dogs names

00:16:03,120 --> 00:16:06,880
honestly so um and so what we have to do

00:16:05,279 --> 00:16:08,000
to find these different ranges well we

00:16:06,880 --> 00:16:09,839
actually created an index

00:16:08,000 --> 00:16:11,199
structure and that index structure is

00:16:09,839 --> 00:16:12,079
implemented very much like a b tree if

00:16:11,199 --> 00:16:13,680
you're familiar with

00:16:12,079 --> 00:16:14,880
that algorithm and how that works right

00:16:13,680 --> 00:16:16,399
but that's how we actually find these

00:16:14,880 --> 00:16:18,000
ranges so that when i want to insert a

00:16:16,399 --> 00:16:19,519
record i talk to the index

00:16:18,000 --> 00:16:21,759
it knows where to find it it's in that

00:16:19,519 --> 00:16:23,839
red range great i go to the red range

00:16:21,759 --> 00:16:25,839
the red range says yeah i have space i'm

00:16:23,839 --> 00:16:27,519
good insert that record wonderful sunny

00:16:25,839 --> 00:16:29,199
is now inserted into there

00:16:27,519 --> 00:16:30,959
what happens when i want to now insert

00:16:29,199 --> 00:16:32,800
another record into that range i want to

00:16:30,959 --> 00:16:34,639
insert rudy okay great

00:16:32,800 --> 00:16:36,160
i didn't have space so it says okay let

00:16:34,639 --> 00:16:38,240
me split that let me

00:16:36,160 --> 00:16:39,680
create a new color range and i'm going

00:16:38,240 --> 00:16:41,279
to make all this extra space now i have

00:16:39,680 --> 00:16:43,199
space

00:16:41,279 --> 00:16:44,399
now this seems really simple but it's

00:16:43,199 --> 00:16:46,800
really complex to do

00:16:44,399 --> 00:16:48,160
but ultimately the value here is you

00:16:46,800 --> 00:16:50,160
don't have to worry about

00:16:48,160 --> 00:16:52,639
horizontal sharding anymore we've just

00:16:50,160 --> 00:16:54,079
done this these ranges can be thought of

00:16:52,639 --> 00:16:55,920
as shards or tablets

00:16:54,079 --> 00:16:57,759
and the database is just basically

00:16:55,920 --> 00:17:00,320
automatically doing all this there's no

00:16:57,759 --> 00:17:02,720
like layer around mysql or postgres

00:17:00,320 --> 00:17:05,120
this is literally at the storage layer

00:17:02,720 --> 00:17:07,039
of the database as well so optimize

00:17:05,120 --> 00:17:08,799
from performance and more importantly

00:17:07,039 --> 00:17:10,880
from a distribution point of view

00:17:08,799 --> 00:17:12,480
so being truly coordinated cloud native

00:17:10,880 --> 00:17:12,959
and architected from the ground up to do

00:17:12,480 --> 00:17:14,640
this

00:17:12,959 --> 00:17:16,559
is actually paramount let's not just

00:17:14,640 --> 00:17:18,160
reuse my sequel

00:17:16,559 --> 00:17:20,000
and allow that to happen and and

00:17:18,160 --> 00:17:22,559
amortize this this this

00:17:20,000 --> 00:17:23,199
range splitting and whatnot above my sql

00:17:22,559 --> 00:17:24,880
instances

00:17:23,199 --> 00:17:27,039
let's actually go in and rework the

00:17:24,880 --> 00:17:28,640
database at the storage layer to do that

00:17:27,039 --> 00:17:32,160
and that's exactly what we're doing here

00:17:28,640 --> 00:17:33,919
now we use raft uh extensively

00:17:32,160 --> 00:17:35,280
in cockroach um if you're not familiar

00:17:33,919 --> 00:17:38,400
with raft it's

00:17:35,280 --> 00:17:39,200
a pretty important protocol or algorithm

00:17:38,400 --> 00:17:40,559
i should say if

00:17:39,200 --> 00:17:42,000
you're doing distributed systems i

00:17:40,559 --> 00:17:43,440
really think it's an important thing to

00:17:42,000 --> 00:17:45,200
actually understand

00:17:43,440 --> 00:17:46,640
and really it's a distributed consensus

00:17:45,200 --> 00:17:47,280
algorithm that allows us to provide

00:17:46,640 --> 00:17:51,360
these

00:17:47,280 --> 00:17:53,679
atomic rights and consistent reads so um

00:17:51,360 --> 00:17:55,760
uh actually somebody's asking how is

00:17:53,679 --> 00:17:57,280
data integrity taken care of an example

00:17:55,760 --> 00:17:58,960
updating the same row from two different

00:17:57,280 --> 00:18:00,160
nodes and locations um

00:17:58,960 --> 00:18:02,080
we're going to actually i'm going to

00:18:00,160 --> 00:18:02,480
show you actually how we do that in in a

00:18:02,080 --> 00:18:05,120
second

00:18:02,480 --> 00:18:06,400
okay so um i'll show you exactly how we

00:18:05,120 --> 00:18:09,520
how we go through that and

00:18:06,400 --> 00:18:11,200
and it's combination of raft mvcc is

00:18:09,520 --> 00:18:12,640
is the algorithms that that that are in

00:18:11,200 --> 00:18:13,120
here and a lot of really magic stuff

00:18:12,640 --> 00:18:14,480
that

00:18:13,120 --> 00:18:16,400
you know our software engineer has built

00:18:14,480 --> 00:18:18,720
out right so so raft

00:18:16,400 --> 00:18:19,840
um that was a question in the qa you all

00:18:18,720 --> 00:18:21,039
sorry i didn't i didn't

00:18:19,840 --> 00:18:23,440
actually tell you what was going on

00:18:21,039 --> 00:18:25,200
sorry my bad um raft is a distributed

00:18:23,440 --> 00:18:26,559
consensus protocol it allows us to have

00:18:25,200 --> 00:18:27,520
these atomic rights and consensus and

00:18:26,559 --> 00:18:29,600
consistent reads

00:18:27,520 --> 00:18:30,799
across the distributed system now raft

00:18:29,600 --> 00:18:33,440
is implemented as

00:18:30,799 --> 00:18:35,039
a series of replicas right so within the

00:18:33,440 --> 00:18:36,240
raft protocol there's this concept of a

00:18:35,039 --> 00:18:38,799
replica set

00:18:36,240 --> 00:18:39,440
or a group of of replicas right so here

00:18:38,799 --> 00:18:41,120
you have

00:18:39,440 --> 00:18:42,880
remember that blue range that was on the

00:18:41,120 --> 00:18:44,880
last i think it had muddy in it

00:18:42,880 --> 00:18:46,080
right i have three replicas of that

00:18:44,880 --> 00:18:48,880
range

00:18:46,080 --> 00:18:50,559
um we can do it as five seven nine it's

00:18:48,880 --> 00:18:51,200
gotta be odd it's an odd number of

00:18:50,559 --> 00:18:52,320
replicas

00:18:51,200 --> 00:18:54,240
because we're gonna actually get

00:18:52,320 --> 00:18:56,000
something called quorum right

00:18:54,240 --> 00:18:57,679
and this this is related to the the

00:18:56,000 --> 00:18:59,440
question that was in the qa

00:18:57,679 --> 00:19:01,039
right when we write something to one of

00:18:59,440 --> 00:19:02,240
these replicas

00:19:01,039 --> 00:19:03,840
we're gonna make sure that it's gonna be

00:19:02,240 --> 00:19:04,720
right because two of three of the

00:19:03,840 --> 00:19:07,200
replicas

00:19:04,720 --> 00:19:09,280
are gonna be ensured that this is gonna

00:19:07,200 --> 00:19:11,200
have you know the right data in it right

00:19:09,280 --> 00:19:12,880
and and we're going to get that quorum

00:19:11,200 --> 00:19:15,120
that quorum right

00:19:12,880 --> 00:19:17,120
now there's this competence of a raft

00:19:15,120 --> 00:19:17,600
leader the leader is is elected amongst

00:19:17,120 --> 00:19:19,360
the

00:19:17,600 --> 00:19:21,039
the three different participants and

00:19:19,360 --> 00:19:23,600
then the other two are followers

00:19:21,039 --> 00:19:25,120
the raf leader is a special uh node or

00:19:23,600 --> 00:19:26,960
special range if you will

00:19:25,120 --> 00:19:29,039
um it does handle all kind of

00:19:26,960 --> 00:19:32,000
authoritative updates

00:19:29,039 --> 00:19:33,840
uh and and is kind of the the the the

00:19:32,000 --> 00:19:35,840
system of record i guess for that

00:19:33,840 --> 00:19:37,120
for that for that replica set so it's a

00:19:35,840 --> 00:19:39,520
really important piece

00:19:37,120 --> 00:19:40,799
um and then this allows us to do atomic

00:19:39,520 --> 00:19:42,160
replication because we could say hey

00:19:40,799 --> 00:19:44,640
look at raf leader

00:19:42,160 --> 00:19:46,480
insert this data into your range and and

00:19:44,640 --> 00:19:48,320
it's going to make sure that it happens

00:19:46,480 --> 00:19:49,520
and and it's going to be correct across

00:19:48,320 --> 00:19:50,559
the entire group

00:19:49,520 --> 00:19:52,480
right it's going to ensure that

00:19:50,559 --> 00:19:53,360
consistency happens two of three

00:19:52,480 --> 00:19:55,039
actually commit

00:19:53,360 --> 00:19:56,400
the third one's got to come along and

00:19:55,039 --> 00:19:57,039
the raft leader is always going to be

00:19:56,400 --> 00:19:59,280
right

00:19:57,039 --> 00:20:00,799
now if you want to learn more about raft

00:19:59,280 --> 00:20:02,000
there's this really wonderful website i

00:20:00,799 --> 00:20:02,400
don't know who did this but i just want

00:20:02,000 --> 00:20:04,159
to

00:20:02,400 --> 00:20:06,559
thank them personally it's called the

00:20:04,159 --> 00:20:08,080
secret lives of data it's one of these i

00:20:06,559 --> 00:20:09,600
think it's if you go check it out it's

00:20:08,080 --> 00:20:11,039
pretty straightforward but it gets much

00:20:09,600 --> 00:20:12,720
deeper into the protocol i'm just giving

00:20:11,039 --> 00:20:14,320
a quick high level overview in the

00:20:12,720 --> 00:20:15,840
context of what we're doing and the qr

00:20:14,320 --> 00:20:17,440
code there should work for you

00:20:15,840 --> 00:20:19,039
um if if you're interested in going out

00:20:17,440 --> 00:20:20,880
and getting that and again this

00:20:19,039 --> 00:20:22,320
presentation of slides will be available

00:20:20,880 --> 00:20:25,360
afterwards so

00:20:22,320 --> 00:20:26,640
okay so now that i've gone through raft

00:20:25,360 --> 00:20:27,200
i've gone through kind of the storage

00:20:26,640 --> 00:20:28,640
layer

00:20:27,200 --> 00:20:30,000
and and how we're actually breaking

00:20:28,640 --> 00:20:30,960
things out into ranges so that we can

00:20:30,000 --> 00:20:33,679
store that in a

00:20:30,960 --> 00:20:35,120
in kv right um we've talked a little bit

00:20:33,679 --> 00:20:38,240
about raft now how do we use

00:20:35,120 --> 00:20:40,159
raft to actually distribute data um

00:20:38,240 --> 00:20:42,880
well when we when we replicate data in a

00:20:40,159 --> 00:20:44,799
cluster we actually want to think about

00:20:42,880 --> 00:20:45,919
you know we want flexible options right

00:20:44,799 --> 00:20:48,400
we want to have

00:20:45,919 --> 00:20:50,799
you know kind of different signals that

00:20:48,400 --> 00:20:53,200
are going to power how we actually

00:20:50,799 --> 00:20:54,960
move data around and where data lives

00:20:53,200 --> 00:20:55,840
within this distributed environment

00:20:54,960 --> 00:20:56,799
right and so

00:20:55,840 --> 00:20:59,039
you know one of the things we think

00:20:56,799 --> 00:21:02,080
about is is typically diversity or

00:20:59,039 --> 00:21:04,480
kind of balance and utilization of say

00:21:02,080 --> 00:21:05,679
say storage across the cluster and so

00:21:04,480 --> 00:21:07,039
you know i think the most simple way of

00:21:05,679 --> 00:21:07,919
thinking about this we'll take this

00:21:07,039 --> 00:21:10,000
range

00:21:07,919 --> 00:21:11,440
uh we'll take this raft group right the

00:21:10,000 --> 00:21:14,080
first one we'll write it in three

00:21:11,440 --> 00:21:15,360
these are four um physical nodes over

00:21:14,080 --> 00:21:17,039
there on the right hand side we'll

00:21:15,360 --> 00:21:19,600
we'll write the first uh raft group

00:21:17,039 --> 00:21:21,280
across three we'll write the second one

00:21:19,600 --> 00:21:23,280
we'll write the third one now i've

00:21:21,280 --> 00:21:26,480
evenly distributed this data

00:21:23,280 --> 00:21:27,600
across uh four different nodes now this

00:21:26,480 --> 00:21:29,760
could be nine it could be

00:21:27,600 --> 00:21:30,960
fifteen it could be a hundred if you

00:21:29,760 --> 00:21:32,159
will right and so

00:21:30,960 --> 00:21:34,000
cockroach is going to be smart enough to

00:21:32,159 --> 00:21:35,679
just evenly distribute this data based

00:21:34,000 --> 00:21:37,679
on what we want to actually

00:21:35,679 --> 00:21:38,960
um you know what we want to actually uh

00:21:37,679 --> 00:21:41,360
you know either survive

00:21:38,960 --> 00:21:43,280
or or how fast we want to get access to

00:21:41,360 --> 00:21:44,720
to users information

00:21:43,280 --> 00:21:46,960
one of the other heuristics that we look

00:21:44,720 --> 00:21:48,400
at we look at load you know like let's

00:21:46,960 --> 00:21:50,799
say this this middle range

00:21:48,400 --> 00:21:52,559
lady lula muddy and pd is really really

00:21:50,799 --> 00:21:54,640
popular because you know muddy

00:21:52,559 --> 00:21:56,240
my dog is the best dog ever and

00:21:54,640 --> 00:21:56,960
everybody wants access right so i'm

00:21:56,240 --> 00:22:00,720
joking

00:21:56,960 --> 00:22:02,799
um you know so we can actually you know

00:22:00,720 --> 00:22:04,559
write those ranges on nodes that are

00:22:02,799 --> 00:22:05,440
less busy so that we can actually say

00:22:04,559 --> 00:22:06,640
hey look at

00:22:05,440 --> 00:22:08,559
you know we have this range it's a

00:22:06,640 --> 00:22:10,240
little hot let's let's isolate it off on

00:22:08,559 --> 00:22:11,200
a node so it can actually

00:22:10,240 --> 00:22:12,799
you know it's not going to hurt the

00:22:11,200 --> 00:22:14,159
performance of the database because you

00:22:12,799 --> 00:22:16,480
know lots of things are kind of in

00:22:14,159 --> 00:22:17,840
conflict on a particular node right

00:22:16,480 --> 00:22:19,440
and so we'll we'll do that as well which

00:22:17,840 --> 00:22:21,120
i think is kind of cool and we're using

00:22:19,440 --> 00:22:21,679
heuristics all the time in the database

00:22:21,120 --> 00:22:24,320
to actually

00:22:21,679 --> 00:22:27,600
deal with this uh once again let me just

00:22:24,320 --> 00:22:29,200
make sure this is going away

00:22:27,600 --> 00:22:31,360
all right yeah so and then we're so

00:22:29,200 --> 00:22:34,000
that's by load and then finally

00:22:31,360 --> 00:22:35,440
um we can also do things and and do

00:22:34,000 --> 00:22:37,600
something really special

00:22:35,440 --> 00:22:39,280
something we call geopartitioning which

00:22:37,600 --> 00:22:40,000
is a low-level kind of concept in the

00:22:39,280 --> 00:22:42,240
database

00:22:40,000 --> 00:22:43,760
but what this does it allows us to write

00:22:42,240 --> 00:22:46,640
data to a particular

00:22:43,760 --> 00:22:48,799
location when you spin a node up in

00:22:46,640 --> 00:22:51,360
cockroach you name that node

00:22:48,799 --> 00:22:52,880
right and and you you define it as

00:22:51,360 --> 00:22:55,760
living in a region

00:22:52,880 --> 00:22:56,799
or a set of nodes that are kind of

00:22:55,760 --> 00:22:59,360
logically

00:22:56,799 --> 00:23:00,640
kind of composed together right so you

00:22:59,360 --> 00:23:03,039
could imagine here i have

00:23:00,640 --> 00:23:05,440
three of them i have you know u.s west

00:23:03,039 --> 00:23:07,280
u.s east and maybe emea

00:23:05,440 --> 00:23:09,600
over in portugal and i have three nodes

00:23:07,280 --> 00:23:11,520
in each now what i can do is at the

00:23:09,600 --> 00:23:14,960
table level at the row level

00:23:11,520 --> 00:23:16,080
i can kind of overload the key right and

00:23:14,960 --> 00:23:18,799
i can add

00:23:16,080 --> 00:23:20,400
a column to the key so i can add like

00:23:18,799 --> 00:23:22,240
say country code was in each one of

00:23:20,400 --> 00:23:24,080
these dog records and there was eu as

00:23:22,240 --> 00:23:26,720
the country code now if i overload that

00:23:24,080 --> 00:23:27,919
and the k and the kv right and this is

00:23:26,720 --> 00:23:28,720
that what i went through at the very

00:23:27,919 --> 00:23:30,960
beginning

00:23:28,720 --> 00:23:32,880
now when i or when i order everything's

00:23:30,960 --> 00:23:34,640
well all the records that have eu

00:23:32,880 --> 00:23:36,240
are kind of at the top everything usc is

00:23:34,640 --> 00:23:38,480
in the middle everything and so

00:23:36,240 --> 00:23:40,559
what we're doing is we're now ordering

00:23:38,480 --> 00:23:41,360
this this lexicographically ordered kv

00:23:40,559 --> 00:23:44,080
set

00:23:41,360 --> 00:23:45,360
using data that's actually in in each

00:23:44,080 --> 00:23:47,600
row

00:23:45,360 --> 00:23:50,080
and now i can say at the table level hey

00:23:47,600 --> 00:23:51,200
i want all records that are that have

00:23:50,080 --> 00:23:53,760
this in the key

00:23:51,200 --> 00:23:54,960
to actually live on servers that are in

00:23:53,760 --> 00:23:57,120
a particular location

00:23:54,960 --> 00:23:58,720
now that's some really magic stuff and

00:23:57,120 --> 00:24:00,080
this comes back and this ties together

00:23:58,720 --> 00:24:00,720
kind of what we're doing at the storage

00:24:00,080 --> 00:24:02,080
layer

00:24:00,720 --> 00:24:04,000
with raft and how we're actually

00:24:02,080 --> 00:24:05,279
distributing this data and where it

00:24:04,000 --> 00:24:06,720
actually lives and the rules that we

00:24:05,279 --> 00:24:08,480
actually live in that we use in the

00:24:06,720 --> 00:24:10,960
database to actually do this so

00:24:08,480 --> 00:24:12,799
it's a pretty cool concept and and and

00:24:10,960 --> 00:24:14,080
and enabled by kind of lots of things

00:24:12,799 --> 00:24:16,000
that were going on

00:24:14,080 --> 00:24:18,559
um across the entirety of the of the

00:24:16,000 --> 00:24:21,200
architecture of the database

00:24:18,559 --> 00:24:22,799
so uh we can do things like we scale

00:24:21,200 --> 00:24:23,760
right so how do i just how do i scale

00:24:22,799 --> 00:24:26,159
this out so

00:24:23,760 --> 00:24:27,679
when i spin up a node and point it at a

00:24:26,159 --> 00:24:29,120
cluster cockroach is smart enough to

00:24:27,679 --> 00:24:31,120
understand like oh wait i have this new

00:24:29,120 --> 00:24:33,840
node i have new capacity

00:24:31,120 --> 00:24:35,120
what will happen is is it'll rebalance

00:24:33,840 --> 00:24:37,440
the data

00:24:35,120 --> 00:24:38,640
it'll start moving ranges around you

00:24:37,440 --> 00:24:40,159
don't have to do anything it just does

00:24:38,640 --> 00:24:42,799
this so again

00:24:40,159 --> 00:24:44,559
horizontal scale without any work which

00:24:42,799 --> 00:24:46,400
i think is pretty phenomenal

00:24:44,559 --> 00:24:48,159
and no need to actually worry about

00:24:46,400 --> 00:24:50,159
application code logic

00:24:48,159 --> 00:24:52,240
uh application logic dealing with new

00:24:50,159 --> 00:24:52,880
shards you're just asking a node for

00:24:52,240 --> 00:24:54,400
data

00:24:52,880 --> 00:24:56,559
it's gonna find that within that within

00:24:54,400 --> 00:24:59,200
that cockroach cluster we can also

00:24:56,559 --> 00:25:00,000
survive the failure of a node itself

00:24:59,200 --> 00:25:03,279
right so

00:25:00,000 --> 00:25:05,120
oh my gosh this this raft group my blue

00:25:03,279 --> 00:25:06,720
raft group here is missing one of its

00:25:05,120 --> 00:25:08,720
its partners it's like oh my gosh get

00:25:06,720 --> 00:25:10,240
this thing back so it's smart enough to

00:25:08,720 --> 00:25:12,720
understand that i've lost

00:25:10,240 --> 00:25:14,559
one of my one of my replicas in my

00:25:12,720 --> 00:25:15,760
replica set the three copies

00:25:14,559 --> 00:25:17,279
and it's going to create a new one

00:25:15,760 --> 00:25:18,640
somewhere else in the within the cluster

00:25:17,279 --> 00:25:19,520
itself now that's pretty cool as well

00:25:18,640 --> 00:25:21,039
right and so

00:25:19,520 --> 00:25:22,559
but we can also survive these kind of

00:25:21,039 --> 00:25:23,840
smaller failures when you know there's

00:25:22,559 --> 00:25:25,279
like a small

00:25:23,840 --> 00:25:27,200
little hiccup in time you know we'll

00:25:25,279 --> 00:25:27,520
just actually use logs to catch things

00:25:27,200 --> 00:25:29,679
back

00:25:27,520 --> 00:25:31,360
up the raft leader makes sure that all

00:25:29,679 --> 00:25:32,880
the replicas are right all the time and

00:25:31,360 --> 00:25:33,840
it'll just basically replay and make

00:25:32,880 --> 00:25:36,240
sure things get back

00:25:33,840 --> 00:25:38,080
back in order across all the replicas

00:25:36,240 --> 00:25:38,640
now this is really cool in terms of

00:25:38,080 --> 00:25:41,279
scale

00:25:38,640 --> 00:25:43,200
and resilience i think another feature

00:25:41,279 --> 00:25:45,120
of of distributed systems and when i

00:25:43,200 --> 00:25:46,320
think about kubernetes and pods and how

00:25:45,120 --> 00:25:49,120
we actually deploy

00:25:46,320 --> 00:25:51,679
you know compute you know automating uh

00:25:49,120 --> 00:25:53,440
rolling upgrades within a system is also

00:25:51,679 --> 00:25:55,360
pretty cool and cockroach was built for

00:25:53,440 --> 00:25:56,960
that right like this this whole concept

00:25:55,360 --> 00:25:57,360
to be able to spin a note down and spin

00:25:56,960 --> 00:25:59,520
it back

00:25:57,360 --> 00:26:01,360
up uh and it's it's going to be able to

00:25:59,520 --> 00:26:03,520
do this scale and resilience

00:26:01,360 --> 00:26:05,600
uh it's just going to basically survive

00:26:03,520 --> 00:26:07,279
those those sort of small failures

00:26:05,600 --> 00:26:08,480
well i can just bring a node down and

00:26:07,279 --> 00:26:09,679
bring it back up with a different

00:26:08,480 --> 00:26:11,440
version of the software

00:26:09,679 --> 00:26:13,039
i think we're backwards compatible up to

00:26:11,440 --> 00:26:15,120
two major versions which is i know a

00:26:13,039 --> 00:26:16,640
year a year and a half sometimes

00:26:15,120 --> 00:26:17,919
so i think cockroach can actually do

00:26:16,640 --> 00:26:19,679
that too so these kind of rolling

00:26:17,919 --> 00:26:21,760
upgrades is another kind of key

00:26:19,679 --> 00:26:23,440
kind of cool thing and i think if you if

00:26:21,760 --> 00:26:24,400
you design your your application

00:26:23,440 --> 00:26:25,760
correctly

00:26:24,400 --> 00:26:27,440
you too should be able to get really in

00:26:25,760 --> 00:26:28,480
upgrades right so if you build scale

00:26:27,440 --> 00:26:30,960
into the system

00:26:28,480 --> 00:26:31,760
if you build resilience resilience into

00:26:30,960 --> 00:26:33,679
the system

00:26:31,760 --> 00:26:35,440
and it's automated so it actually just

00:26:33,679 --> 00:26:36,559
understands as a single entity

00:26:35,440 --> 00:26:38,559
that if i've lost something i could

00:26:36,559 --> 00:26:39,760
actually come back from that well then

00:26:38,559 --> 00:26:41,679
you're going to be able to get to this

00:26:39,760 --> 00:26:43,919
concept of rolling upgrades which is

00:26:41,679 --> 00:26:45,520
really really super powerful

00:26:43,919 --> 00:26:47,200
especially as as we get to production

00:26:45,520 --> 00:26:48,880
and we want you know always on always

00:26:47,200 --> 00:26:51,120
available services no matter where

00:26:48,880 --> 00:26:53,440
they're at on the planet right so

00:26:51,120 --> 00:26:54,159
another kind of core concept okay so i'm

00:26:53,440 --> 00:26:57,840
going to take a

00:26:54,159 --> 00:26:57,840
quick class quick drink of water

00:26:58,640 --> 00:27:02,480
so let's talk about transactions um you

00:27:01,120 --> 00:27:04,320
know there was a there was a question in

00:27:02,480 --> 00:27:06,080
the qa about transactions how do we

00:27:04,320 --> 00:27:07,840
ensure consistency of transactions

00:27:06,080 --> 00:27:09,360
you know this is not something that's

00:27:07,840 --> 00:27:10,880
very simple to do i mean if you have a

00:27:09,360 --> 00:27:13,200
database and you have you know

00:27:10,880 --> 00:27:15,039
a transaction happening in sydney and

00:27:13,200 --> 00:27:15,679
you have a transaction happening in new

00:27:15,039 --> 00:27:17,200
york

00:27:15,679 --> 00:27:19,200
and it's all happening against the same

00:27:17,200 --> 00:27:21,200
account or the same customer record

00:27:19,200 --> 00:27:22,880
who wins i'm going to go through that

00:27:21,200 --> 00:27:24,480
i'm going to go through mvcc and

00:27:22,880 --> 00:27:26,240
actually how we actually deal with these

00:27:24,480 --> 00:27:27,760
kind of conflicts you know what it's

00:27:26,240 --> 00:27:29,279
going to mean to you the developer is

00:27:27,760 --> 00:27:31,520
that sometimes you have to actually

00:27:29,279 --> 00:27:33,120
wrapper things with try catch blocks

00:27:31,520 --> 00:27:34,720
it's probably a best practice anyway i

00:27:33,120 --> 00:27:35,600
was a hack programmer i never did that

00:27:34,720 --> 00:27:36,720
sort of thing but

00:27:35,600 --> 00:27:39,360
but that's kind of what we're doing but

00:27:36,720 --> 00:27:41,440
we're going to guarantee in cockroach

00:27:39,360 --> 00:27:43,200
we're going to guarantee serializable

00:27:41,440 --> 00:27:45,600
isolation which is the top level of

00:27:43,200 --> 00:27:47,279
isolation in the database if you're not

00:27:45,600 --> 00:27:48,799
familiar with isolation levels

00:27:47,279 --> 00:27:50,080
by the way don't be i wouldn't be

00:27:48,799 --> 00:27:51,440
surprised i know a lot of developers

00:27:50,080 --> 00:27:53,120
don't even think about this stuff

00:27:51,440 --> 00:27:54,640
um it actually gets it's pretty

00:27:53,120 --> 00:27:56,000
important when you start thinking about

00:27:54,640 --> 00:27:57,039
you know the things that can go wrong in

00:27:56,000 --> 00:27:58,720
a database you know like a

00:27:57,039 --> 00:28:01,600
non-repeatable read or

00:27:58,720 --> 00:28:02,000
a dirty read a phantom read there's lots

00:28:01,600 --> 00:28:03,679
of issues

00:28:02,000 --> 00:28:05,039
that can go on with your data and you

00:28:03,679 --> 00:28:06,880
know as we've seen you know

00:28:05,039 --> 00:28:09,039
deep hacks coming in from all over the

00:28:06,880 --> 00:28:10,559
planet thinking about these things in

00:28:09,039 --> 00:28:11,600
your database actually becoming more and

00:28:10,559 --> 00:28:13,840
more important

00:28:11,600 --> 00:28:15,760
i think you know as we get into this

00:28:13,840 --> 00:28:16,000
kind of more global environment and so i

00:28:15,760 --> 00:28:18,080
think

00:28:16,000 --> 00:28:19,600
isolation levels are really really

00:28:18,080 --> 00:28:21,520
critical um

00:28:19,600 --> 00:28:22,799
so how do we then implement these

00:28:21,520 --> 00:28:23,360
distributed transactions right we're

00:28:22,799 --> 00:28:25,520
gonna

00:28:23,360 --> 00:28:26,880
we're gonna optimize for isolation level

00:28:25,520 --> 00:28:28,320
serializable and we're gonna optimize

00:28:26,880 --> 00:28:30,480
for the speed of light here right so

00:28:28,320 --> 00:28:31,679
so what are we doing right so well at

00:28:30,480 --> 00:28:32,799
the core i just talked through this

00:28:31,679 --> 00:28:35,200
basically i mean the core of every

00:28:32,799 --> 00:28:38,080
database is acid right atomicity

00:28:35,200 --> 00:28:39,679
consistency isolation and durability

00:28:38,080 --> 00:28:42,320
what we're talking about here really is

00:28:39,679 --> 00:28:43,679
the eye the isolation level um in our

00:28:42,320 --> 00:28:44,960
database right and so

00:28:43,679 --> 00:28:46,960
well and that's kind of how we do it

00:28:44,960 --> 00:28:48,240
this is a quick walkthrough um

00:28:46,960 --> 00:28:49,520
let's do something that just works i'm

00:28:48,240 --> 00:28:50,960
not going to get into the corner cases

00:28:49,520 --> 00:28:52,640
where things can go wrong but i'll show

00:28:50,960 --> 00:28:53,520
you a little bit how we actually do that

00:28:52,640 --> 00:28:55,200
right so

00:28:53,520 --> 00:28:56,960
here's a simple transaction i want to

00:28:55,200 --> 00:28:57,600
insert these two records into the dog

00:28:56,960 --> 00:28:59,760
table

00:28:57,600 --> 00:29:01,679
my ranges have been dispersed across you

00:28:59,760 --> 00:29:03,360
know these four physical nodes that

00:29:01,679 --> 00:29:05,120
we've been working with before

00:29:03,360 --> 00:29:06,799
and so i'm going to ask any one of these

00:29:05,120 --> 00:29:07,760
nodes to insert this record now i've

00:29:06,799 --> 00:29:11,039
purposely

00:29:07,760 --> 00:29:12,720
drawn this gateway as as as green

00:29:11,039 --> 00:29:13,200
because it matches the green nodes of

00:29:12,720 --> 00:29:15,760
the roman

00:29:13,200 --> 00:29:16,320
left remember any node in cockroach can

00:29:15,760 --> 00:29:18,080
be an

00:29:16,320 --> 00:29:19,840
endpoint i can ask any node to do this

00:29:18,080 --> 00:29:22,159
now it's going to find

00:29:19,840 --> 00:29:23,200
you know the the the raft leader for

00:29:22,159 --> 00:29:24,720
this particular

00:29:23,200 --> 00:29:26,159
for this particular range that i want to

00:29:24,720 --> 00:29:27,360
insert this this first part of the

00:29:26,159 --> 00:29:28,720
transaction sunny

00:29:27,360 --> 00:29:31,360
and that range is going to actually

00:29:28,720 --> 00:29:32,640
create a special kind of system record

00:29:31,360 --> 00:29:34,640
that's basically saying we have a

00:29:32,640 --> 00:29:35,840
pending transaction on this range

00:29:34,640 --> 00:29:37,679
and what it's going to do it's going to

00:29:35,840 --> 00:29:39,760
go communicate with its followers

00:29:37,679 --> 00:29:41,600
and say hey followers write this but

00:29:39,760 --> 00:29:42,399
write it with like a temporary record

00:29:41,600 --> 00:29:44,399
status

00:29:42,399 --> 00:29:46,399
and as soon as one of those followers

00:29:44,399 --> 00:29:48,000
comes back because i need two of three

00:29:46,399 --> 00:29:49,679
right because i'm going to be guaranteed

00:29:48,000 --> 00:29:51,039
right well as soon as one of them comes

00:29:49,679 --> 00:29:51,600
back it's like great go on to the next

00:29:51,039 --> 00:29:53,200
step

00:29:51,600 --> 00:29:54,559
i can go on and i can actually start the

00:29:53,200 --> 00:29:56,159
second try and look at this this

00:29:54,559 --> 00:29:57,600
acknowledgement trailed and i already

00:29:56,159 --> 00:29:59,520
started the second step here

00:29:57,600 --> 00:30:00,799
the second transaction right now i'm

00:29:59,520 --> 00:30:01,919
going to write aussie it's going to go

00:30:00,799 --> 00:30:03,039
out it's going to do the same thing as

00:30:01,919 --> 00:30:04,880
soon as i get something back it's going

00:30:03,039 --> 00:30:07,600
to return an acknowledgement

00:30:04,880 --> 00:30:10,080
now this range and the raf leader has

00:30:07,600 --> 00:30:11,919
now set this transaction to commit

00:30:10,080 --> 00:30:14,080
it's going to communicate back within

00:30:11,919 --> 00:30:15,360
the gateway itself it's the transaction

00:30:14,080 --> 00:30:17,200
is going to finalize

00:30:15,360 --> 00:30:19,440
and i could send acknowledgement back to

00:30:17,200 --> 00:30:21,200
the originating user that actually asked

00:30:19,440 --> 00:30:22,399
for me to insert these two records into

00:30:21,200 --> 00:30:23,600
the database

00:30:22,399 --> 00:30:25,840
so that's kind of how it works right

00:30:23,600 --> 00:30:27,679
like and so that's how ranges are used

00:30:25,840 --> 00:30:29,760
um in the context of a transaction now

00:30:27,679 --> 00:30:30,320
you could imagine complex transactions

00:30:29,760 --> 00:30:32,399
and

00:30:30,320 --> 00:30:33,760
the amount of ranges that are going on

00:30:32,399 --> 00:30:35,520
and cockroach is going to handle and

00:30:33,760 --> 00:30:37,200
deal with kind of movement and kind of

00:30:35,520 --> 00:30:38,480
placement of all this different data

00:30:37,200 --> 00:30:40,320
and and when these transactions are

00:30:38,480 --> 00:30:41,200
going to occur now there's something

00:30:40,320 --> 00:30:43,760
special

00:30:41,200 --> 00:30:44,880
um another kind of core kind of consent

00:30:43,760 --> 00:30:46,399
concept

00:30:44,880 --> 00:30:48,159
in distributed systems if you're not

00:30:46,399 --> 00:30:49,039
familiar with multi-version concurrency

00:30:48,159 --> 00:30:51,360
control

00:30:49,039 --> 00:30:52,799
um i think it's a pretty cool algorithm

00:30:51,360 --> 00:30:54,880
uh you know

00:30:52,799 --> 00:30:56,799
funny enough i i find though the

00:30:54,880 --> 00:30:57,440
wikipedia version of this to be pretty

00:30:56,799 --> 00:30:59,519
valuable

00:30:57,440 --> 00:31:01,200
actually uh you know if you want to go

00:30:59,519 --> 00:31:02,880
read how this actually works but

00:31:01,200 --> 00:31:04,720
think of this as like how we get the

00:31:02,880 --> 00:31:05,679
isolation level in in our acid

00:31:04,720 --> 00:31:07,039
transactions

00:31:05,679 --> 00:31:08,080
in a distributed system so i'm just

00:31:07,039 --> 00:31:09,039
going to walk through the algorithm

00:31:08,080 --> 00:31:12,480
really quickly

00:31:09,039 --> 00:31:14,080
now again look it like me talking about

00:31:12,480 --> 00:31:16,320
this seems pretty simple

00:31:14,080 --> 00:31:17,279
you know the kudos to our engineering

00:31:16,320 --> 00:31:19,360
team and

00:31:17,279 --> 00:31:21,200
and how they've implemented it because

00:31:19,360 --> 00:31:22,880
actually implementing this in a single

00:31:21,200 --> 00:31:24,080
system is difficult doing it in a

00:31:22,880 --> 00:31:26,159
distributed system is

00:31:24,080 --> 00:31:27,519
is truly tremendous and so i'm going to

00:31:26,159 --> 00:31:28,720
walk through a very high level version

00:31:27,519 --> 00:31:30,559
of this but again

00:31:28,720 --> 00:31:31,760
you know if you're really interested in

00:31:30,559 --> 00:31:32,480
seeing how we did it go check out our

00:31:31,760 --> 00:31:35,519
code

00:31:32,480 --> 00:31:38,080
um again all available to people so

00:31:35,519 --> 00:31:39,760
so in in mvcc there's kind of three base

00:31:38,080 --> 00:31:40,880
components there's a transaction there's

00:31:39,760 --> 00:31:43,679
a time stamp

00:31:40,880 --> 00:31:44,399
and then there's the object of that we

00:31:43,679 --> 00:31:46,640
want to actually

00:31:44,399 --> 00:31:48,480
affect right and so when a transaction

00:31:46,640 --> 00:31:50,720
occurs basically what we do is at time

00:31:48,480 --> 00:31:52,399
zero great i have created a time stamp

00:31:50,720 --> 00:31:54,720
for this transaction

00:31:52,399 --> 00:31:55,760
at zero and i'm going to actually say

00:31:54,720 --> 00:31:59,200
write this data

00:31:55,760 --> 00:32:01,039
to this object now the object gets this

00:31:59,200 --> 00:32:03,279
and this is an arbitrary time this isn't

00:32:01,039 --> 00:32:04,960
seconds it's just basically steps right

00:32:03,279 --> 00:32:06,559
what the first thing it does the object

00:32:04,960 --> 00:32:07,360
has two timestamps it has a read

00:32:06,559 --> 00:32:09,279
timestamp

00:32:07,360 --> 00:32:11,200
and it has a right timestamp and what

00:32:09,279 --> 00:32:11,840
the object says is like hey wait a write

00:32:11,200 --> 00:32:13,200
came in

00:32:11,840 --> 00:32:14,720
let me tell you exactly when the right

00:32:13,200 --> 00:32:15,440
for this right came in the last right

00:32:14,720 --> 00:32:18,480
came in

00:32:15,440 --> 00:32:20,080
at 01. now what it does is it says hey

00:32:18,480 --> 00:32:20,720
let me create this temporary object

00:32:20,080 --> 00:32:22,399
because

00:32:20,720 --> 00:32:23,679
i want to always be in a good state like

00:32:22,399 --> 00:32:24,960
the object should always be in a good

00:32:23,679 --> 00:32:25,519
state but if i'm doing work in the

00:32:24,960 --> 00:32:26,880
object

00:32:25,519 --> 00:32:28,720
create a temporary object and so i'm

00:32:26,880 --> 00:32:30,320
going to go write that data and then and

00:32:28,720 --> 00:32:31,600
then the time it took to actually do

00:32:30,320 --> 00:32:33,200
everything and bring everything back to

00:32:31,600 --> 00:32:34,799
the original object right in my temp

00:32:33,200 --> 00:32:37,600
object and bring it back

00:32:34,799 --> 00:32:39,279
took about two seconds to say and and

00:32:37,600 --> 00:32:40,159
now i have a read time stamp so

00:32:39,279 --> 00:32:42,080
basically

00:32:40,159 --> 00:32:43,840
the work i did is now up to date and

00:32:42,080 --> 00:32:44,240
that read timestamp is at three and i

00:32:43,840 --> 00:32:45,519
can

00:32:44,240 --> 00:32:47,360
send the acknowledgement back to the

00:32:45,519 --> 00:32:50,080
originating transaction say

00:32:47,360 --> 00:32:52,320
everything's good right so what's cool

00:32:50,080 --> 00:32:53,679
is each row now has this read time stamp

00:32:52,320 --> 00:32:55,360
and a right tam stamp so you'll see the

00:32:53,679 --> 00:32:57,200
right time stamp is still

00:32:55,360 --> 00:32:59,120
the last time a ride came in and then

00:32:57,200 --> 00:33:00,240
the read was when it fully committed it

00:32:59,120 --> 00:33:03,039
and went good

00:33:00,240 --> 00:33:04,240
okay so let's do this again okay so

00:33:03,039 --> 00:33:05,840
great we'll start again

00:33:04,240 --> 00:33:07,440
we're going to the right time stamp to

00:33:05,840 --> 00:33:08,080
one i'm going to create this temporary

00:33:07,440 --> 00:33:10,399
object

00:33:08,080 --> 00:33:11,600
and now while i'm doing work in this

00:33:10,399 --> 00:33:12,720
temporary object because i want the

00:33:11,600 --> 00:33:14,159
original object to be right

00:33:12,720 --> 00:33:16,080
correct you know i want it to be correct

00:33:14,159 --> 00:33:18,000
i should say not right another

00:33:16,080 --> 00:33:19,440
transaction comes in and it says hey i

00:33:18,000 --> 00:33:22,240
want to write this data

00:33:19,440 --> 00:33:22,880
but now my timestamp for transaction two

00:33:22,240 --> 00:33:25,039
is

00:33:22,880 --> 00:33:27,039
two seconds and what it's going to say

00:33:25,039 --> 00:33:27,360
is like wait a second your two seconds

00:33:27,039 --> 00:33:28,960
is

00:33:27,360 --> 00:33:31,519
actually greater than the read time

00:33:28,960 --> 00:33:33,600
stamp so wait a second

00:33:31,519 --> 00:33:36,799
this can't work because i haven't

00:33:33,600 --> 00:33:38,720
finished doing something else yet

00:33:36,799 --> 00:33:40,320
right and so in the time it took me to

00:33:38,720 --> 00:33:41,840
do that another thing came in

00:33:40,320 --> 00:33:43,039
you need to deal with this right now

00:33:41,840 --> 00:33:44,799
we're just going to say hey basically

00:33:43,039 --> 00:33:45,360
this i have to reject this transaction

00:33:44,799 --> 00:33:47,360
because

00:33:45,360 --> 00:33:48,960
this stuff didn't work so this is on a

00:33:47,360 --> 00:33:50,399
single object imagine this going across

00:33:48,960 --> 00:33:51,440
15 different well i might have to roll

00:33:50,399 --> 00:33:52,080
back and do all these different things

00:33:51,440 --> 00:33:53,600
right so

00:33:52,080 --> 00:33:55,039
we've actually done all this in the

00:33:53,600 --> 00:33:57,120
database to actually handle this sort of

00:33:55,039 --> 00:33:59,919
thing now this is for a row of data

00:33:57,120 --> 00:34:00,960
in cockroach this is this this is a very

00:33:59,919 --> 00:34:03,440
generic

00:34:00,960 --> 00:34:05,519
algorithm that as we think about data as

00:34:03,440 --> 00:34:07,279
we think about code in our systems

00:34:05,519 --> 00:34:09,760
how are we dealing with these sort of

00:34:07,279 --> 00:34:11,520
conflicts in distributed systems because

00:34:09,760 --> 00:34:13,599
anybody could be asking an object for

00:34:11,520 --> 00:34:15,760
for data at any one time right and so

00:34:13,599 --> 00:34:17,520
this is a kind of a really critical kind

00:34:15,760 --> 00:34:19,040
of core algorithm

00:34:17,520 --> 00:34:21,280
in distributed systems that i feel is

00:34:19,040 --> 00:34:22,480
kind of cool and and pretty awesome now

00:34:21,280 --> 00:34:24,720
long story short

00:34:22,480 --> 00:34:25,679
you know it's like standing in a line um

00:34:24,720 --> 00:34:28,320
you know every

00:34:25,679 --> 00:34:28,800
transaction happens in order and ensures

00:34:28,320 --> 00:34:30,639
that

00:34:28,800 --> 00:34:32,240
that you know the the till isn't going

00:34:30,639 --> 00:34:34,240
to be out of order but but then again

00:34:32,240 --> 00:34:35,599
i'm just the marketing guy um

00:34:34,240 --> 00:34:37,200
this is a kind of a top level

00:34:35,599 --> 00:34:37,520
understanding of how this stuff works

00:34:37,200 --> 00:34:40,560
right

00:34:37,520 --> 00:34:43,119
so okay so

00:34:40,560 --> 00:34:44,399
uh let's go now to sql execution so

00:34:43,119 --> 00:34:45,200
actually there was a question that came

00:34:44,399 --> 00:34:47,119
in the chat

00:34:45,200 --> 00:34:49,200
are there any locks that are put when

00:34:47,119 --> 00:34:52,720
someone is accessing a row

00:34:49,200 --> 00:34:54,800
or range of rows for dml operations um

00:34:52,720 --> 00:34:56,320
well that kind of was covered in how we

00:34:54,800 --> 00:34:57,520
actually deal with transactions there's

00:34:56,320 --> 00:34:59,119
this kind of

00:34:57,520 --> 00:35:00,560
special hey there's a transaction

00:34:59,119 --> 00:35:02,480
pending so

00:35:00,560 --> 00:35:04,400
that's how we actually do that and then

00:35:02,480 --> 00:35:06,000
you know we're using mvcc to

00:35:04,400 --> 00:35:07,520
to ensure that that consistency is going

00:35:06,000 --> 00:35:09,760
to happen throughout

00:35:07,520 --> 00:35:10,640
um and then another really great

00:35:09,760 --> 00:35:12,320
question here was

00:35:10,640 --> 00:35:14,560
what's the minimum number of nodes

00:35:12,320 --> 00:35:17,200
needed to have a database up and running

00:35:14,560 --> 00:35:18,960
you know i think it's one or three uh in

00:35:17,200 --> 00:35:20,480
my opinion you could do two but that

00:35:18,960 --> 00:35:21,839
doesn't make a whole lot of sense right

00:35:20,480 --> 00:35:23,599
because if you're gonna have replicas

00:35:21,839 --> 00:35:24,800
three replicas you know you want them

00:35:23,599 --> 00:35:26,480
across three places or

00:35:24,800 --> 00:35:28,079
or maybe it's just all on one and you

00:35:26,480 --> 00:35:29,359
don't care about the resilience right

00:35:28,079 --> 00:35:31,200
and so i think that's kind of one of

00:35:29,359 --> 00:35:33,839
those cool things but typically

00:35:31,200 --> 00:35:34,480
four is is typically the best chance

00:35:33,839 --> 00:35:36,320
because you can

00:35:34,480 --> 00:35:38,640
survive the failure of one node going

00:35:36,320 --> 00:35:41,440
down you're always going to be secure

00:35:38,640 --> 00:35:42,240
and and be resilient um typically we'll

00:35:41,440 --> 00:35:44,480
see people do

00:35:42,240 --> 00:35:45,599
three or four in in multiple regions you

00:35:44,480 --> 00:35:47,520
know if you want to

00:35:45,599 --> 00:35:49,520
survive multiple regions they'll do like

00:35:47,520 --> 00:35:51,119
four in the west four in the east

00:35:49,520 --> 00:35:54,240
you know four in the central whatever

00:35:51,119 --> 00:35:55,839
that is um it really depends on

00:35:54,240 --> 00:35:57,680
what you want to accomplish with the

00:35:55,839 --> 00:35:59,200
database you know i i think the easiest

00:35:57,680 --> 00:36:00,079
way to do this is just use cockroach

00:35:59,200 --> 00:36:02,240
cloud

00:36:00,079 --> 00:36:03,359
and let us manage kind of how that all

00:36:02,240 --> 00:36:05,119
works and and

00:36:03,359 --> 00:36:06,720
and help you accomplish your goals right

00:36:05,119 --> 00:36:09,359
so okay

00:36:06,720 --> 00:36:09,839
so now uh distributed sql execution so

00:36:09,359 --> 00:36:11,920
again

00:36:09,839 --> 00:36:13,520
you know we've talked about the kv layer

00:36:11,920 --> 00:36:15,760
now let's talk about how we can

00:36:13,520 --> 00:36:18,000
actually push down compute to each of

00:36:15,760 --> 00:36:19,760
the the where the data lives as well

00:36:18,000 --> 00:36:21,599
uh and decompose queries so that we're

00:36:19,760 --> 00:36:23,119
actually distributing this sort of stuff

00:36:21,599 --> 00:36:25,119
i'd like to think about this you know i

00:36:23,119 --> 00:36:26,560
was originally you know i was at a

00:36:25,119 --> 00:36:28,240
company called hortonworks and

00:36:26,560 --> 00:36:30,160
you know this whole concept of mapreduce

00:36:28,240 --> 00:36:31,200
actually originated at google as well i

00:36:30,160 --> 00:36:33,200
mean this is another

00:36:31,200 --> 00:36:34,320
you know jeffrey dean and sanjay gemawat

00:36:33,200 --> 00:36:36,480
uh whitepaper

00:36:34,320 --> 00:36:37,920
around mapreduce but the core concepts

00:36:36,480 --> 00:36:39,440
that were there were actually applied in

00:36:37,920 --> 00:36:40,000
spanner and then are applied here as

00:36:39,440 --> 00:36:42,160
well right

00:36:40,000 --> 00:36:44,000
and so you know this isn't like let's

00:36:42,160 --> 00:36:46,400
let's coordinate

00:36:44,000 --> 00:36:47,280
my sql instances or let's coordinate you

00:36:46,400 --> 00:36:50,400
know postgres

00:36:47,280 --> 00:36:53,280
instances now this is a complete

00:36:50,400 --> 00:36:54,000
rework to be distributed of the

00:36:53,280 --> 00:36:55,480
execution

00:36:54,000 --> 00:36:57,920
layer of the database now there's

00:36:55,480 --> 00:36:59,359
significant benefits in doing so from

00:36:57,920 --> 00:37:00,240
definitely from a performance point of

00:36:59,359 --> 00:37:02,000
view

00:37:00,240 --> 00:37:04,160
more importantly what does distributed

00:37:02,000 --> 00:37:05,760
mean when we get into kind of cost based

00:37:04,160 --> 00:37:06,880
optimization and costs of of

00:37:05,760 --> 00:37:08,400
transactions

00:37:06,880 --> 00:37:10,480
how are we actually going to optimize a

00:37:08,400 --> 00:37:12,880
database over time and so you know

00:37:10,480 --> 00:37:13,839
reworking and re-architecting not just

00:37:12,880 --> 00:37:15,520
the storage layer

00:37:13,839 --> 00:37:17,200
not just the language but really really

00:37:15,520 --> 00:37:19,200
this execution layer

00:37:17,200 --> 00:37:20,800
and not wrappering different executions

00:37:19,200 --> 00:37:22,320
with this stuff is is really critical

00:37:20,800 --> 00:37:24,480
and something we've done so let's take a

00:37:22,320 --> 00:37:25,680
simple query we're going to count um

00:37:24,480 --> 00:37:28,079
you know we're going to count the number

00:37:25,680 --> 00:37:28,720
of countries across my customer table

00:37:28,079 --> 00:37:30,240
right

00:37:28,720 --> 00:37:32,640
and what i do is i just basically take

00:37:30,240 --> 00:37:34,720
that query i push it down to

00:37:32,640 --> 00:37:36,480
one of my nodes it's actually going to

00:37:34,720 --> 00:37:38,160
perform a scan locally there we're going

00:37:36,480 --> 00:37:40,480
to do scans locally

00:37:38,160 --> 00:37:41,680
in each of the regions we're going to

00:37:40,480 --> 00:37:42,400
take that data we're going to do the

00:37:41,680 --> 00:37:43,920
group by

00:37:42,400 --> 00:37:45,520
in each of those regions we're going to

00:37:43,920 --> 00:37:48,560
send that data back right

00:37:45,520 --> 00:37:51,040
map and then reduce right bring it back

00:37:48,560 --> 00:37:51,839
and then result uh and then send results

00:37:51,040 --> 00:37:55,040
back to the

00:37:51,839 --> 00:37:57,920
the the original requester now again

00:37:55,040 --> 00:37:58,400
uh we use this uh and chose to redo

00:37:57,920 --> 00:37:59,520
everything

00:37:58,400 --> 00:38:01,760
ultimately because we could do cost

00:37:59,520 --> 00:38:03,119
based optimization uh in this and i

00:38:01,760 --> 00:38:04,160
think if you're if you're familiar with

00:38:03,119 --> 00:38:06,079
you know

00:38:04,160 --> 00:38:07,359
traditional databases cbo is such a

00:38:06,079 --> 00:38:09,440
critical piece and

00:38:07,359 --> 00:38:10,800
and kind of a a core thing of of how we

00:38:09,440 --> 00:38:14,000
actually deal with these uh

00:38:10,800 --> 00:38:16,720
uh improving optim of transactional

00:38:14,000 --> 00:38:18,400
oh man sub oh my god i'm totally our p99

00:38:16,720 --> 00:38:19,520
latency is under five milliseconds how

00:38:18,400 --> 00:38:21,680
are you gonna do that

00:38:19,520 --> 00:38:23,839
uh and so we we work really hard to help

00:38:21,680 --> 00:38:26,560
you do those sort of things right

00:38:23,839 --> 00:38:27,359
okay now let's talk about latency um

00:38:26,560 --> 00:38:29,040
i've got about

00:38:27,359 --> 00:38:31,040
20 minutes left i probably got about 10

00:38:29,040 --> 00:38:32,880
more 15 more minutes of

00:38:31,040 --> 00:38:34,880
of stuff here maybe 12 i'll make it 12

00:38:32,880 --> 00:38:36,240
right um so let's talk a little bit

00:38:34,880 --> 00:38:37,280
about latency and let's kind of see how

00:38:36,240 --> 00:38:38,720
these things kind of let's

00:38:37,280 --> 00:38:40,400
take a step back and kind of come back

00:38:38,720 --> 00:38:41,920
up again um you know

00:38:40,400 --> 00:38:43,280
you know back in the day when you build

00:38:41,920 --> 00:38:44,240
applications you had a server and a

00:38:43,280 --> 00:38:46,960
database

00:38:44,240 --> 00:38:47,680
for me man it was so long ago this stuff

00:38:46,960 --> 00:38:50,240
all lived in

00:38:47,680 --> 00:38:51,680
actually one single box uh but then you

00:38:50,240 --> 00:38:52,800
have a database server and application

00:38:51,680 --> 00:38:54,400
server but it was like you know

00:38:52,800 --> 00:38:56,400
literally you had ethernet between the

00:38:54,400 --> 00:38:57,760
two it was really super fast right

00:38:56,400 --> 00:38:59,040
um but what's happened is you know we

00:38:57,760 --> 00:39:00,320
are distributed and people are all over

00:38:59,040 --> 00:39:02,160
the place you know now we have we're

00:39:00,320 --> 00:39:03,839
dealing with with users that

00:39:02,160 --> 00:39:05,760
you know the speed of light is actually

00:39:03,839 --> 00:39:07,440
you know a thing here right so round

00:39:05,760 --> 00:39:08,480
trip times of 12 milliseconds or 70

00:39:07,440 --> 00:39:09,920
milliseconds

00:39:08,480 --> 00:39:11,680
when you're doing that across multiple

00:39:09,920 --> 00:39:14,640
different transactions can be

00:39:11,680 --> 00:39:16,160
an issue but we also do things in our

00:39:14,640 --> 00:39:18,480
implementations today

00:39:16,160 --> 00:39:19,440
um to to cope with outages right and and

00:39:18,480 --> 00:39:22,160
how do we do

00:39:19,440 --> 00:39:23,920
backups and how do we have a secondary

00:39:22,160 --> 00:39:25,359
primary or a primary and secondary you

00:39:23,920 --> 00:39:27,359
know database so that

00:39:25,359 --> 00:39:29,200
i have failover right this has been this

00:39:27,359 --> 00:39:29,839
active passive system that we've had in

00:39:29,200 --> 00:39:33,040
place for

00:39:29,839 --> 00:39:35,280
years decades right and so you know this

00:39:33,040 --> 00:39:37,119
this active passive way to me is a thing

00:39:35,280 --> 00:39:38,240
of the past and and i think it comes out

00:39:37,119 --> 00:39:40,000
of again

00:39:38,240 --> 00:39:41,760
kind of core principles and distributed

00:39:40,000 --> 00:39:43,040
systems where everything is active how

00:39:41,760 --> 00:39:45,920
do you make everything

00:39:43,040 --> 00:39:47,440
active an active active database for us

00:39:45,920 --> 00:39:49,359
but how do you make sure that every one

00:39:47,440 --> 00:39:51,119
of your nodes and your compute nodes and

00:39:49,359 --> 00:39:53,440
what you're actually building out

00:39:51,119 --> 00:39:55,119
are active right and let's not have

00:39:53,440 --> 00:39:56,079
failover systems because they're just a

00:39:55,119 --> 00:39:58,240
waste

00:39:56,079 --> 00:39:59,839
um they aren't used it wastes it's

00:39:58,240 --> 00:40:01,760
wasted capacity

00:39:59,839 --> 00:40:03,359
there's just lots of reason and honestly

00:40:01,760 --> 00:40:04,640
asynchronous replication is only going

00:40:03,359 --> 00:40:05,839
to be so good because again you're

00:40:04,640 --> 00:40:08,240
dealing with speedlite

00:40:05,839 --> 00:40:09,599
and things aren't always out of uh

00:40:08,240 --> 00:40:11,119
aren't always on sync in fact

00:40:09,599 --> 00:40:12,319
what happens when the primary goes down

00:40:11,119 --> 00:40:13,839
and you bring up the secondary and then

00:40:12,319 --> 00:40:15,119
the primary comes back on

00:40:13,839 --> 00:40:17,200
how do you mitigate you know the

00:40:15,119 --> 00:40:18,640
differences between those two

00:40:17,200 --> 00:40:21,680
lots of different problems with kind of

00:40:18,640 --> 00:40:23,040
this active passive system right

00:40:21,680 --> 00:40:24,480
you know for something that's more of an

00:40:23,040 --> 00:40:25,920
active active system what you're doing

00:40:24,480 --> 00:40:27,440
is you're taking smaller instances and

00:40:25,920 --> 00:40:28,319
deploying them in many different places

00:40:27,440 --> 00:40:30,720
you know for us

00:40:28,319 --> 00:40:32,000
let's have five different regions so

00:40:30,720 --> 00:40:33,280
that we're going to guarantee that we're

00:40:32,000 --> 00:40:35,680
going to be sub you know

00:40:33,280 --> 00:40:37,520
40 millisecond round trip times no

00:40:35,680 --> 00:40:38,079
matter what happens across each one of

00:40:37,520 --> 00:40:40,480
these things

00:40:38,079 --> 00:40:41,359
so that when a user access data say in

00:40:40,480 --> 00:40:42,720
new york

00:40:41,359 --> 00:40:45,359
they could go us east we're going to

00:40:42,720 --> 00:40:46,960
have about a 24 millisecond read

00:40:45,359 --> 00:40:48,480
over on the west side or on the west

00:40:46,960 --> 00:40:48,960
coast maybe there's an arizona person

00:40:48,480 --> 00:40:50,240
there

00:40:48,960 --> 00:40:52,720
they're getting something back in about

00:40:50,240 --> 00:40:53,839
32 seconds right or yeah it's about 32

00:40:52,720 --> 00:40:56,400
seconds right 31

00:40:53,839 --> 00:40:57,599
right so but what happens when an entire

00:40:56,400 --> 00:41:00,160
region goes

00:40:57,599 --> 00:41:01,839
out well again remember if we've

00:41:00,160 --> 00:41:03,119
distributed the data correctly across

00:41:01,839 --> 00:41:05,680
these these

00:41:03,119 --> 00:41:06,960
these regions well that user in arizona

00:41:05,680 --> 00:41:10,640
can just redirect

00:41:06,960 --> 00:41:12,160
and go against the us west and actually

00:41:10,640 --> 00:41:14,319
man look at those round trip times are

00:41:12,160 --> 00:41:16,160
about the same right and so we actually

00:41:14,319 --> 00:41:17,200
haven't really really even lost anything

00:41:16,160 --> 00:41:19,040
right and so

00:41:17,200 --> 00:41:20,640
there's just ways of dealing with kind

00:41:19,040 --> 00:41:22,720
of these these latencies

00:41:20,640 --> 00:41:24,000
and outages that that get really really

00:41:22,720 --> 00:41:27,280
important when you have this

00:41:24,000 --> 00:41:28,960
active active system now i think active

00:41:27,280 --> 00:41:30,880
passive is interesting as well from a

00:41:28,960 --> 00:41:32,079
backup and restore point of view you

00:41:30,880 --> 00:41:34,000
know i think that's one of the reasons

00:41:32,079 --> 00:41:36,160
why we have this is backup you know

00:41:34,000 --> 00:41:38,000
but in a distributed system you know why

00:41:36,160 --> 00:41:39,280
is would you back up everything to like

00:41:38,000 --> 00:41:41,760
say one big

00:41:39,280 --> 00:41:43,520
server that's sitting in oklahoma no you

00:41:41,760 --> 00:41:45,200
want to actually do distributed backup

00:41:43,520 --> 00:41:45,520
and restore so you have you know this

00:41:45,200 --> 00:41:47,040
this

00:41:45,520 --> 00:41:49,359
the same way you have a distributed

00:41:47,040 --> 00:41:51,040
system for you know servicing queries

00:41:49,359 --> 00:41:53,040
these read writes through every node you

00:41:51,040 --> 00:41:54,079
actually want distributed backup as well

00:41:53,040 --> 00:41:55,200
and so

00:41:54,079 --> 00:41:57,280
that's how you actually deal with this

00:41:55,200 --> 00:41:58,240
within something like an active active

00:41:57,280 --> 00:41:59,920
system but again

00:41:58,240 --> 00:42:02,000
another core principle another thing to

00:41:59,920 --> 00:42:03,280
think about as we go distributed

00:42:02,000 --> 00:42:04,480
you know think about all the other

00:42:03,280 --> 00:42:06,160
things that have to be distributed that

00:42:04,480 --> 00:42:08,000
go with those things i think that's

00:42:06,160 --> 00:42:09,599
one of those big complexities as as we

00:42:08,000 --> 00:42:11,119
more move forward towards this kind of

00:42:09,599 --> 00:42:13,040
distributed mindset and distributed

00:42:11,119 --> 00:42:15,839
thinking

00:42:13,040 --> 00:42:17,119
um you know our last release we made

00:42:15,839 --> 00:42:19,839
this pretty simple to

00:42:17,119 --> 00:42:21,839
to actually implement um you know we

00:42:19,839 --> 00:42:24,560
we've boiled down this whole like where

00:42:21,839 --> 00:42:26,480
data lives and how we actually deploy

00:42:24,560 --> 00:42:28,960
a database across multiple regions down

00:42:26,480 --> 00:42:30,880
to four simple ddl statements

00:42:28,960 --> 00:42:32,880
you know we're defining cluster regions

00:42:30,880 --> 00:42:34,880
um and then we're placing a database

00:42:32,880 --> 00:42:36,480
within those regions right so

00:42:34,880 --> 00:42:37,760
we're going to start a node and place it

00:42:36,480 --> 00:42:39,040
in a region and then we're going to say

00:42:37,760 --> 00:42:41,119
hey this database

00:42:39,040 --> 00:42:42,880
has a primary region of east and then

00:42:41,119 --> 00:42:45,040
there's west and central so

00:42:42,880 --> 00:42:47,599
that's where data's going to live we can

00:42:45,040 --> 00:42:49,680
basically change goals of survival to be

00:42:47,599 --> 00:42:51,599
regional failure or maybe it's a

00:42:49,680 --> 00:42:52,960
availability zone failure

00:42:51,599 --> 00:42:54,560
and then we can actually do this down at

00:42:52,960 --> 00:42:55,680
the real level i'm not going to get too

00:42:54,560 --> 00:42:57,440
deep into this but

00:42:55,680 --> 00:42:59,119
lots of great stuff in our documentation

00:42:57,440 --> 00:43:00,560
on exactly how this stuff works we have

00:42:59,119 --> 00:43:02,800
really simplified

00:43:00,560 --> 00:43:05,520
configuration of the database itself

00:43:02,800 --> 00:43:07,680
down to four simple ddl statements which

00:43:05,520 --> 00:43:09,680
it's pretty pretty impressive work by

00:43:07,680 --> 00:43:12,000
the team here and pretty you know

00:43:09,680 --> 00:43:14,079
i'm still in awe of it but again i think

00:43:12,000 --> 00:43:15,440
our docs does a great job of of

00:43:14,079 --> 00:43:16,880
describing this and other

00:43:15,440 --> 00:43:19,200
kind of some of the principles that that

00:43:16,880 --> 00:43:22,319
i've gone through here so

00:43:19,200 --> 00:43:24,400
okay so last topic distributed

00:43:22,319 --> 00:43:26,160
performance optimization so this one's a

00:43:24,400 --> 00:43:27,920
bit more uh

00:43:26,160 --> 00:43:29,359
even even more academic and even more

00:43:27,920 --> 00:43:30,560
down in the weeds but i think one again

00:43:29,359 --> 00:43:32,000
one of these things that you know

00:43:30,560 --> 00:43:33,280
thinking about distributed systems and

00:43:32,000 --> 00:43:34,880
think about latencies

00:43:33,280 --> 00:43:36,640
how do you actually deal with you know

00:43:34,880 --> 00:43:38,960
the speed of transactions right

00:43:36,640 --> 00:43:40,319
and so we're doing things we're doing

00:43:38,960 --> 00:43:42,560
lazy transactions

00:43:40,319 --> 00:43:44,480
and we're also doing right pipelining

00:43:42,560 --> 00:43:46,079
right and so let's look at first of all

00:43:44,480 --> 00:43:46,400
let's look at lazy and pipeline together

00:43:46,079 --> 00:43:47,760
so

00:43:46,400 --> 00:43:49,040
here's our transaction we're gonna write

00:43:47,760 --> 00:43:50,240
these two records and we're gonna commit

00:43:49,040 --> 00:43:53,280
it right

00:43:50,240 --> 00:43:55,280
insert into table two records right

00:43:53,280 --> 00:43:56,880
and so in a serial way we start the

00:43:55,280 --> 00:43:59,119
transaction uh

00:43:56,880 --> 00:44:00,240
carl comes back okay carl gets written

00:43:59,119 --> 00:44:02,640
it comes back

00:44:00,240 --> 00:44:03,359
start the second right it's it's you

00:44:02,640 --> 00:44:05,440
know the second

00:44:03,359 --> 00:44:07,040
right transaction begin is transaction

00:44:05,440 --> 00:44:08,000
carl nigel right we're just doing the

00:44:07,040 --> 00:44:09,680
four things

00:44:08,000 --> 00:44:11,359
nigel comes back and then the commit is

00:44:09,680 --> 00:44:12,880
gonna come back with the keys

00:44:11,359 --> 00:44:14,880
and we're gonna come back this take a

00:44:12,880 --> 00:44:18,000
total amount of you know one one

00:44:14,880 --> 00:44:19,760
two three four round trips

00:44:18,000 --> 00:44:21,200
now with lazy and pipelining what we're

00:44:19,760 --> 00:44:22,880
doing is we're actually gonna write carl

00:44:21,200 --> 00:44:24,960
we're going to write nigel and both of

00:44:22,880 --> 00:44:26,480
those things are going to come back

00:44:24,960 --> 00:44:27,920
then we're just going to simply commit

00:44:26,480 --> 00:44:28,400
this and come back right so we've

00:44:27,920 --> 00:44:30,000
actually

00:44:28,400 --> 00:44:31,599
eliminated the need for this kind of

00:44:30,000 --> 00:44:33,760
first pending because

00:44:31,599 --> 00:44:35,680
remember in our transaction thing the

00:44:33,760 --> 00:44:37,119
the raft group is actually dealing with

00:44:35,680 --> 00:44:39,359
this pending record

00:44:37,119 --> 00:44:41,040
right the the we're using raft and the

00:44:39,359 --> 00:44:42,319
special nature there to actually deal

00:44:41,040 --> 00:44:42,800
with that so we don't actually have to

00:44:42,319 --> 00:44:44,880
have

00:44:42,800 --> 00:44:46,720
a separate transaction to start this

00:44:44,880 --> 00:44:48,240
this this kickoff this pending

00:44:46,720 --> 00:44:49,359
the the lock if you will on this

00:44:48,240 --> 00:44:50,720
particular transaction we're just going

00:44:49,359 --> 00:44:52,400
to start writing these two things

00:44:50,720 --> 00:44:54,079
against these two ranges

00:44:52,400 --> 00:44:55,680
and it's going to deal with this pending

00:44:54,079 --> 00:44:57,119
record and when those two things come

00:44:55,680 --> 00:44:58,400
back we're just going to commit

00:44:57,119 --> 00:45:00,560
and and we're going to go back and so

00:44:58,400 --> 00:45:02,400
we've actually saved you know

00:45:00,560 --> 00:45:03,359
this amount of time right and so that's

00:45:02,400 --> 00:45:04,160
what we're doing with lazy and

00:45:03,359 --> 00:45:05,839
pipelining

00:45:04,160 --> 00:45:07,440
and again it's all part of kind of how

00:45:05,839 --> 00:45:09,040
we store and how we actually execute

00:45:07,440 --> 00:45:10,400
transactions

00:45:09,040 --> 00:45:12,560
now parallel commits is something that

00:45:10,400 --> 00:45:15,200
we did over the past two years

00:45:12,560 --> 00:45:16,880
um which i find to be truly phenomenal

00:45:15,200 --> 00:45:18,319
the only way that i could describe it in

00:45:16,880 --> 00:45:20,800
english is

00:45:18,319 --> 00:45:22,240
beyond all this stuff is uh you know we

00:45:20,800 --> 00:45:23,599
couldn't change the speed of light so we

00:45:22,240 --> 00:45:25,599
changed the photons

00:45:23,599 --> 00:45:27,599
uh you know it's like what we send over

00:45:25,599 --> 00:45:28,240
is is different now we basically take it

00:45:27,599 --> 00:45:31,040
we

00:45:28,240 --> 00:45:32,400
look at a transaction we look at all the

00:45:31,040 --> 00:45:34,000
information around it we take a picture

00:45:32,400 --> 00:45:35,359
of that and the transaction itself we

00:45:34,000 --> 00:45:36,000
commit on one node and we send it over

00:45:35,359 --> 00:45:37,440
to the next

00:45:36,000 --> 00:45:38,720
then the next node says hey as long as

00:45:37,440 --> 00:45:39,280
the picture looks the same over here i'm

00:45:38,720 --> 00:45:40,880
good too

00:45:39,280 --> 00:45:43,119
and it could immediately go back and say

00:45:40,880 --> 00:45:44,800
hey we're going to be good right and so

00:45:43,119 --> 00:45:46,480
what we're doing here this is lazy

00:45:44,800 --> 00:45:46,960
pipelined and parallel so we're gonna do

00:45:46,480 --> 00:45:49,359
carl

00:45:46,960 --> 00:45:51,040
nigel and we're gonna actually come

00:45:49,359 --> 00:45:52,640
we're gonna forward commit that thing

00:45:51,040 --> 00:45:53,599
because we actually know that it's good

00:45:52,640 --> 00:45:56,800
on one node

00:45:53,599 --> 00:45:57,920
right and then what we do is when all

00:45:56,800 --> 00:45:59,760
these things come back

00:45:57,920 --> 00:46:01,359
we're good and so we've actually

00:45:59,760 --> 00:46:03,280
replaced this kind of

00:46:01,359 --> 00:46:04,800
centralized commit marker we're doing

00:46:03,280 --> 00:46:06,079
car on nigel and then come back and then

00:46:04,800 --> 00:46:07,839
the transaction thing

00:46:06,079 --> 00:46:09,280
we're just doing it all at once we're

00:46:07,839 --> 00:46:11,440
basically taking everything

00:46:09,280 --> 00:46:12,800
and as long as we're good on one side

00:46:11,440 --> 00:46:14,720
right the first line

00:46:12,800 --> 00:46:16,240
and when we're when all this goes over

00:46:14,720 --> 00:46:17,359
and we check in on it on the other side

00:46:16,240 --> 00:46:21,040
we can just actually say

00:46:17,359 --> 00:46:23,760
everything's great send it all back um

00:46:21,040 --> 00:46:25,119
that's some really really amazing

00:46:23,760 --> 00:46:26,640
software engineering and i think the

00:46:25,119 --> 00:46:29,040
first time i saw it was

00:46:26,640 --> 00:46:30,640
i was kind of dumbfounded at the what it

00:46:29,040 --> 00:46:31,200
meant for us from a performance point of

00:46:30,640 --> 00:46:34,560
view

00:46:31,200 --> 00:46:36,720
especially in broadly distributed

00:46:34,560 --> 00:46:37,680
um systems when you have things that are

00:46:36,720 --> 00:46:39,359
happening you know

00:46:37,680 --> 00:46:41,680
in sydney and in new york at the same

00:46:39,359 --> 00:46:43,119
time these things really matter because

00:46:41,680 --> 00:46:44,720
we're talking about you know

00:46:43,119 --> 00:46:46,319
what three or four hundred millisecond

00:46:44,720 --> 00:46:47,599
round trips you know back and forth a

00:46:46,319 --> 00:46:49,440
couple times you know

00:46:47,599 --> 00:46:50,880
you want to be sub 100 millisecond

00:46:49,440 --> 00:46:52,000
that's really what it means to be kind

00:46:50,880 --> 00:46:54,000
of um

00:46:52,000 --> 00:46:55,440
in real time for humans right i think

00:46:54,000 --> 00:46:56,480
that's that's where it's discernible for

00:46:55,440 --> 00:47:00,000
humans to be

00:46:56,480 --> 00:47:02,079
uh yeah uh real or or you know

00:47:00,000 --> 00:47:04,079
after that we actually notice the lag if

00:47:02,079 --> 00:47:07,599
you will right

00:47:04,079 --> 00:47:09,599
okay so i have covered uh a lot

00:47:07,599 --> 00:47:11,280
um i gave you a quick overview of

00:47:09,599 --> 00:47:13,680
cockroach

00:47:11,280 --> 00:47:14,960
we went through our storage layer we

00:47:13,680 --> 00:47:16,480
talked a bit about raft

00:47:14,960 --> 00:47:18,640
we talked about how we distribute data

00:47:16,480 --> 00:47:20,160
within the database we spoke about

00:47:18,640 --> 00:47:23,280
distributed transactions

00:47:20,160 --> 00:47:24,960
i went through mvcc we talked about how

00:47:23,280 --> 00:47:26,480
distributed execution is a little bit

00:47:24,960 --> 00:47:27,200
different than basically distributing

00:47:26,480 --> 00:47:29,520
just data

00:47:27,200 --> 00:47:31,520
or using multiple instances of a

00:47:29,520 --> 00:47:33,440
traditional execution engine

00:47:31,520 --> 00:47:35,280
um we talked about latency and the speed

00:47:33,440 --> 00:47:36,800
of light and and how we can actually

00:47:35,280 --> 00:47:38,880
you know do optimizations from a

00:47:36,800 --> 00:47:40,880
performance point of view for that so

00:47:38,880 --> 00:47:42,079
the last thing i wanted to touch on

00:47:40,880 --> 00:47:43,760
before i you know

00:47:42,079 --> 00:47:45,280
kind of end this and and open it up for

00:47:43,760 --> 00:47:47,599
any questions um

00:47:45,280 --> 00:47:48,880
you know when i first saw cockroach

00:47:47,599 --> 00:47:51,760
actually i was not it was

00:47:48,880 --> 00:47:53,119
we were on stage i was working at coreos

00:47:51,760 --> 00:47:54,559
at the time and uh

00:47:53,119 --> 00:47:56,160
and if you're not familiar coreos kind

00:47:54,559 --> 00:47:57,520
of one of these companies been around

00:47:56,160 --> 00:47:59,440
friends of the linux found linux

00:47:57,520 --> 00:48:00,160
foundation and cncf for years and years

00:47:59,440 --> 00:48:01,839
um

00:48:00,160 --> 00:48:03,359
and kind of innovators in the kubernetes

00:48:01,839 --> 00:48:03,680
space they're ultimately bought by red

00:48:03,359 --> 00:48:05,920
hat

00:48:03,680 --> 00:48:08,079
and and the ceo of coreos alex bolvi

00:48:05,920 --> 00:48:09,839
wasn't on stage showing off kubernetes

00:48:08,079 --> 00:48:11,440
showing how you can kill a pod in the

00:48:09,839 --> 00:48:11,839
data and then and the system just comes

00:48:11,440 --> 00:48:14,160
back

00:48:11,839 --> 00:48:15,920
right like it's it was awesome and the

00:48:14,160 --> 00:48:17,440
application they used to show this off

00:48:15,920 --> 00:48:18,640
was cockroach and this is about four

00:48:17,440 --> 00:48:20,880
years ago

00:48:18,640 --> 00:48:22,400
um and i think you know for me that was

00:48:20,880 --> 00:48:23,839
the the moment in time where i was like

00:48:22,400 --> 00:48:25,040
wow that's really cool i just had a

00:48:23,839 --> 00:48:27,839
database that had

00:48:25,040 --> 00:48:29,359
a very zeroed a very limited impact and

00:48:27,839 --> 00:48:31,440
it's in its performance

00:48:29,359 --> 00:48:33,119
and i'm just killing off pieces of it

00:48:31,440 --> 00:48:34,880
that's pretty awesome now

00:48:33,119 --> 00:48:36,480
you know fast forward a couple years and

00:48:34,880 --> 00:48:38,800
you know i i remember you know the

00:48:36,480 --> 00:48:40,000
federation group within the sig fed

00:48:38,800 --> 00:48:41,680
was trying to figure out oh man how are

00:48:40,000 --> 00:48:42,400
we going to federate kubernetes clusters

00:48:41,680 --> 00:48:43,839
and i think

00:48:42,400 --> 00:48:45,280
you know the work that people like you

00:48:43,839 --> 00:48:46,480
know the upbound team are doing with

00:48:45,280 --> 00:48:48,079
cross plane and

00:48:46,480 --> 00:48:49,839
you know there's their scupper for

00:48:48,079 --> 00:48:50,800
networking there's a lot of stuff going

00:48:49,839 --> 00:48:53,119
on but

00:48:50,800 --> 00:48:54,720
for me why not just federate at the data

00:48:53,119 --> 00:48:56,640
layer why not just have a single logical

00:48:54,720 --> 00:48:58,000
database that's that's going across you

00:48:56,640 --> 00:48:58,880
know multiple different kubernetes

00:48:58,000 --> 00:49:01,520
clusters

00:48:58,880 --> 00:49:02,640
and so for me i i find multi-region and

00:49:01,520 --> 00:49:03,760
global scale to be

00:49:02,640 --> 00:49:05,599
kind of the future of what we're going

00:49:03,760 --> 00:49:06,640
to do and for us if i could just deploy

00:49:05,599 --> 00:49:08,240
nodes across

00:49:06,640 --> 00:49:10,000
you know multiple different kubernetes

00:49:08,240 --> 00:49:12,400
clusters and have them all participate

00:49:10,000 --> 00:49:13,119
and any one of those endpoints can see

00:49:12,400 --> 00:49:16,000
data in

00:49:13,119 --> 00:49:17,760
any other cluster why worry about the

00:49:16,000 --> 00:49:19,280
the operational nightmare of dealing

00:49:17,760 --> 00:49:20,640
with the cluster and making those things

00:49:19,280 --> 00:49:22,640
work in multi-regions

00:49:20,640 --> 00:49:24,160
let's just let the database deal with it

00:49:22,640 --> 00:49:25,520
we have a demo that we did this i know

00:49:24,160 --> 00:49:28,319
it's on our youtube channel

00:49:25,520 --> 00:49:29,760
myself and my friend keith mclellan goes

00:49:28,319 --> 00:49:30,960
through a really great

00:49:29,760 --> 00:49:32,880
presentation of this i think we're going

00:49:30,960 --> 00:49:33,200
to do this one again we're actually we

00:49:32,880 --> 00:49:35,440
use

00:49:33,200 --> 00:49:36,960
cube doom to actually kill pods as well

00:49:35,440 --> 00:49:39,040
which was kind of fun so

00:49:36,960 --> 00:49:40,880
um that one's coming but i i to me this

00:49:39,040 --> 00:49:41,760
is you know probably one of the coolest

00:49:40,880 --> 00:49:43,760
things that

00:49:41,760 --> 00:49:45,680
you know i've seen in this space and i

00:49:43,760 --> 00:49:46,559
think the future is is truly hybrid and

00:49:45,680 --> 00:49:49,440
multi-cloud

00:49:46,559 --> 00:49:51,680
i think people you know they they

00:49:49,440 --> 00:49:54,720
question it you know networking

00:49:51,680 --> 00:49:56,640
uh security these things are a challenge

00:49:54,720 --> 00:49:58,160
in in distributed worlds especially

00:49:56,640 --> 00:49:58,640
across multiple different networks but i

00:49:58,160 --> 00:50:00,160
think

00:49:58,640 --> 00:50:02,240
it'll be interesting how this how this

00:50:00,160 --> 00:50:04,559
comes about right um

00:50:02,240 --> 00:50:05,520
we also have a kubernetes operator um

00:50:04,559 --> 00:50:07,440
you know while we

00:50:05,520 --> 00:50:09,280
are kind of like perfectly aligned with

00:50:07,440 --> 00:50:10,480
kubernetes we don't need a kubernetes

00:50:09,280 --> 00:50:12,480
operator to do

00:50:10,480 --> 00:50:13,839
you know all the basic install and scale

00:50:12,480 --> 00:50:15,119
and resilience and all these things

00:50:13,839 --> 00:50:17,040
about how you find data

00:50:15,119 --> 00:50:18,559
you know you find other databases really

00:50:17,040 --> 00:50:20,000
really complex operators

00:50:18,559 --> 00:50:21,359
for us it's all about the day two

00:50:20,000 --> 00:50:23,359
operations and the stuff that we've

00:50:21,359 --> 00:50:24,640
learned by deploying cockroach cloud on

00:50:23,359 --> 00:50:27,280
kubernetes we have

00:50:24,640 --> 00:50:29,119
you know thousands of of notes nodes

00:50:27,280 --> 00:50:30,720
running on cockroach cloud and it's all

00:50:29,119 --> 00:50:32,480
being you know managed by kubernetes

00:50:30,720 --> 00:50:34,000
from an orchestration point of view so

00:50:32,480 --> 00:50:36,160
it's kind of helping with management the

00:50:34,000 --> 00:50:37,280
rolling upgrade stuff uh you know

00:50:36,160 --> 00:50:39,200
one of the best practices around

00:50:37,280 --> 00:50:40,160
security so we're taking basically our

00:50:39,200 --> 00:50:42,240
best practices

00:50:40,160 --> 00:50:43,920
of running kubernetes cockroach at scale

00:50:42,240 --> 00:50:46,960
on kubernetes and packaging them

00:50:43,920 --> 00:50:48,960
into an operator um available

00:50:46,960 --> 00:50:50,640
lots of different people using cockroach

00:50:48,960 --> 00:50:52,000
this is a sample of some of our

00:50:50,640 --> 00:50:54,880
customers um

00:50:52,000 --> 00:50:55,520
you know we often get asked you know you

00:50:54,880 --> 00:50:57,520
know

00:50:55,520 --> 00:50:58,720
cockroaches just for global workloads oh

00:50:57,520 --> 00:50:59,760
man i don't have data all over the

00:50:58,720 --> 00:51:02,559
planet

00:50:59,760 --> 00:51:04,079
actually you know i i would say a fair

00:51:02,559 --> 00:51:05,839
majority of our customers are using us

00:51:04,079 --> 00:51:08,800
in a single region and that's because

00:51:05,839 --> 00:51:09,520
you know the pure elimination of any

00:51:08,800 --> 00:51:12,480
sort of

00:51:09,520 --> 00:51:14,400
you know of sharding and and this kind

00:51:12,480 --> 00:51:16,319
of elastic horizontal scale that we can

00:51:14,400 --> 00:51:19,680
give to people is a huge value

00:51:16,319 --> 00:51:20,640
um you know the ability to survive any

00:51:19,680 --> 00:51:22,800
failure is just

00:51:20,640 --> 00:51:24,319
it's it's a phenomenal piece and just

00:51:22,800 --> 00:51:25,680
let the database do that so you know

00:51:24,319 --> 00:51:27,440
we're being used for kind of general

00:51:25,680 --> 00:51:29,359
purpose workloads and

00:51:27,440 --> 00:51:30,720
general purpose applications and then

00:51:29,359 --> 00:51:32,400
lots of these kind of system of record

00:51:30,720 --> 00:51:34,160
where you really need this this highest

00:51:32,400 --> 00:51:35,520
level of isolation right

00:51:34,160 --> 00:51:36,800
and so i think this is one of those

00:51:35,520 --> 00:51:38,319
things where you know if you're if

00:51:36,800 --> 00:51:40,319
you're thinking about being distributed

00:51:38,319 --> 00:51:42,079
you're running something on kubernetes

00:51:40,319 --> 00:51:43,599
we're really just containerized running

00:51:42,079 --> 00:51:45,040
in any environment you know cockroach

00:51:43,599 --> 00:51:47,040
should definitely be on a list and

00:51:45,040 --> 00:51:48,880
it's kind of one of these things that um

00:51:47,040 --> 00:51:50,480
that that that you know i think once you

00:51:48,880 --> 00:51:52,640
see it you can't unsee it

00:51:50,480 --> 00:51:54,160
it's the funny thing that i've i've

00:51:52,640 --> 00:51:56,559
heard from people so

00:51:54,160 --> 00:51:57,760
um you can learn more about cockroach

00:51:56,559 --> 00:51:58,800
you could take some coursework

00:51:57,760 --> 00:52:01,040
everything is there it's

00:51:58,800 --> 00:52:03,359
it's it's all for free um you know we

00:52:01,040 --> 00:52:06,160
have some stuff on distributed databases

00:52:03,359 --> 00:52:08,000
you know cloud native apps uh lots of

00:52:06,160 --> 00:52:09,680
general purpose sql stuff and then lots

00:52:08,000 --> 00:52:11,119
of stuff about us and how to build with

00:52:09,680 --> 00:52:12,559
python and java

00:52:11,119 --> 00:52:13,680
um so you can go out and do that uh

00:52:12,559 --> 00:52:14,800
that's that's all available on our

00:52:13,680 --> 00:52:16,400
website but then again

00:52:14,800 --> 00:52:18,480
as i said you know as i mentioned before

00:52:16,400 --> 00:52:20,079
i think you know cockroach cloud is

00:52:18,480 --> 00:52:21,520
is really one of the easiest ways to get

00:52:20,079 --> 00:52:23,040
started and you know if you want to go

00:52:21,520 --> 00:52:24,880
start a cluster today that's that's

00:52:23,040 --> 00:52:28,400
that's the way to do it so

00:52:24,880 --> 00:52:31,040
okay that's 54 minutes

00:52:28,400 --> 00:52:33,280
50 with the intro so i i went through a

00:52:31,040 --> 00:52:35,119
lot um i did want to actually

00:52:33,280 --> 00:52:37,200
uh there was a couple questions i think

00:52:35,119 --> 00:52:39,520
somebody was asking about security

00:52:37,200 --> 00:52:40,400
i think tim answered these live i'm not

00:52:39,520 --> 00:52:42,319
sure

00:52:40,400 --> 00:52:44,480
um but there's lots of things that we're

00:52:42,319 --> 00:52:45,119
doing for security within cockroach

00:52:44,480 --> 00:52:47,440
itself

00:52:45,119 --> 00:52:49,040
um you know we we've gone to great

00:52:47,440 --> 00:52:50,640
lengths to make sure that we have all

00:52:49,040 --> 00:52:51,599
the core kind of concepts that you would

00:52:50,640 --> 00:52:53,119
need in a database

00:52:51,599 --> 00:52:54,960
that you would expect in a normal

00:52:53,119 --> 00:52:56,400
database are in cockroach like all the

00:52:54,960 --> 00:52:57,839
management capabilities

00:52:56,400 --> 00:52:58,960
you know integration with other things

00:52:57,839 --> 00:53:00,480
you know how do i actually you know we

00:52:58,960 --> 00:53:01,680
actually improved our logging so it

00:53:00,480 --> 00:53:03,280
works a lot better with things like

00:53:01,680 --> 00:53:05,520
splunk and data dog

00:53:03,280 --> 00:53:07,359
in in the last release you know we don't

00:53:05,520 --> 00:53:08,480
set this up with a prometheus endpoint

00:53:07,359 --> 00:53:09,599
right and so

00:53:08,480 --> 00:53:12,400
lots of different things that we're

00:53:09,599 --> 00:53:14,160
doing around the core of the database to

00:53:12,400 --> 00:53:15,599
make it work the way you work

00:53:14,160 --> 00:53:17,520
security being one of those things you

00:53:15,599 --> 00:53:19,359
know how do we integrate with ldap

00:53:17,520 --> 00:53:20,960
um you know secrets management within

00:53:19,359 --> 00:53:22,880
this um you know do we

00:53:20,960 --> 00:53:24,400
you know we encrypt data at rest and

00:53:22,880 --> 00:53:26,559
data in motion

00:53:24,400 --> 00:53:27,599
um this is all tls between you know

00:53:26,559 --> 00:53:29,520
different endpoints and

00:53:27,599 --> 00:53:31,200
whatnot so there's lots of things that

00:53:29,520 --> 00:53:31,599
we're doing if you want to deep dive

00:53:31,200 --> 00:53:33,359
into

00:53:31,599 --> 00:53:34,800
all the kind of components of security

00:53:33,359 --> 00:53:36,559
we've implemented this

00:53:34,800 --> 00:53:37,839
again i i just i always push people

00:53:36,559 --> 00:53:39,119
towards our docs i think they're a

00:53:37,839 --> 00:53:42,559
phenomenal resource

00:53:39,119 --> 00:53:45,200
the team does an amazing amazing job um

00:53:42,559 --> 00:53:46,000
doing these sort of things so uh let's

00:53:45,200 --> 00:53:48,079
see

00:53:46,000 --> 00:53:49,839
uh any other questions there was there

00:53:48,079 --> 00:53:52,400
was a lot of questions and thank you tim

00:53:49,839 --> 00:53:54,400
for jumping in and doing all this and

00:53:52,400 --> 00:53:56,000
and and reading this and answering these

00:53:54,400 --> 00:53:57,440
questions i i'll go through a couple

00:53:56,000 --> 00:53:59,440
of them just to kind of talk through

00:53:57,440 --> 00:54:02,000
them i have a minute or two

00:53:59,440 --> 00:54:02,480
somebody was asking for you know do we

00:54:02,000 --> 00:54:05,920
support

00:54:02,480 --> 00:54:07,920
spatial data yes we actually

00:54:05,920 --> 00:54:09,920
implemented those libraries in cockroach

00:54:07,920 --> 00:54:11,440
itself as well so we actually do now

00:54:09,920 --> 00:54:13,839
support spatial data

00:54:11,440 --> 00:54:15,760
um in a distributed database um which is

00:54:13,839 --> 00:54:16,800
actually added added some interesting

00:54:15,760 --> 00:54:18,800
kind of

00:54:16,800 --> 00:54:20,240
concepts there so we're actually doing

00:54:18,800 --> 00:54:25,280
that as well

00:54:20,240 --> 00:54:29,359
that was a security question

00:54:25,280 --> 00:54:29,359
um i think i got almost everything

00:54:30,880 --> 00:54:35,520
somebody was asking about bulk loading

00:54:32,960 --> 00:54:38,960
um and and how we actually do that

00:54:35,520 --> 00:54:42,000
um yeah we do we do actually uh provide

00:54:38,960 --> 00:54:43,680
bulk lighting capabilities um

00:54:42,000 --> 00:54:44,960
but i think it's we think about it in

00:54:43,680 --> 00:54:45,839
terms of the backup and restore

00:54:44,960 --> 00:54:47,440
capabilities and

00:54:45,839 --> 00:54:49,920
the batching capabilities that we have

00:54:47,440 --> 00:54:52,400
you know i know our our io team thinks a

00:54:49,920 --> 00:54:54,319
lot about these things

00:54:52,400 --> 00:54:55,680
my best answer again is go to the go to

00:54:54,319 --> 00:54:58,720
our docs i think there's lots of

00:54:55,680 --> 00:55:00,640
information there on this as well so

00:54:58,720 --> 00:55:02,160
let's see yeah i think i've answered

00:55:00,640 --> 00:55:03,839
everything else um

00:55:02,160 --> 00:55:05,440
unless there is not any other questions

00:55:03,839 --> 00:55:06,000
i mean that was that was a lot of

00:55:05,440 --> 00:55:08,799
information

00:55:06,000 --> 00:55:09,680
in a little bit of time um i do hope

00:55:08,799 --> 00:55:12,160
this was

00:55:09,680 --> 00:55:13,200
uh valuable to everybody i i hope that

00:55:12,160 --> 00:55:15,119
you know

00:55:13,200 --> 00:55:16,880
you know this wasn't just you know just

00:55:15,119 --> 00:55:18,079
cockroach talking about cockroach i'm

00:55:16,880 --> 00:55:18,960
trying to make this a little bit more

00:55:18,079 --> 00:55:20,640
about

00:55:18,960 --> 00:55:22,400
you know the some of the principles that

00:55:20,640 --> 00:55:24,000
we use and the underlying architecture

00:55:22,400 --> 00:55:25,040
to hopefully you know open your eyes to

00:55:24,000 --> 00:55:26,240
some of the things that are out there

00:55:25,040 --> 00:55:27,280
and some of the things to actually look

00:55:26,240 --> 00:55:30,400
at so

00:55:27,280 --> 00:55:33,520
um again i'm i'm jim walker i'm just at

00:55:30,400 --> 00:55:35,520
james j-a-y-m-c-e on twitter

00:55:33,520 --> 00:55:37,440
um i'm always happy to answer questions

00:55:35,520 --> 00:55:38,640
you know our our cockroach community

00:55:37,440 --> 00:55:40,640
slack channel

00:55:38,640 --> 00:55:42,319
is an extremely vibrant community lots

00:55:40,640 --> 00:55:43,200
of people asking and answering questions

00:55:42,319 --> 00:55:45,599
there

00:55:43,200 --> 00:55:46,799
um but you know for me go out and try it

00:55:45,599 --> 00:55:47,760
if you're interested in this sort of

00:55:46,799 --> 00:55:49,119
thing and then

00:55:47,760 --> 00:55:51,040
if you're looking for a phd in

00:55:49,119 --> 00:55:52,960
distributed systems i still contend that

00:55:51,040 --> 00:55:55,920
that our our code basis

00:55:52,960 --> 00:55:57,440
is a good place to to to do this so on

00:55:55,920 --> 00:55:59,280
behalf of uh you know

00:55:57,440 --> 00:56:00,799
our entire company and a lot of people

00:55:59,280 --> 00:56:02,400
worked really hard on a lot of really

00:56:00,799 --> 00:56:03,920
cool stuff here

00:56:02,400 --> 00:56:05,440
thank you for joining us and thank you

00:56:03,920 --> 00:56:06,160
to the linux foundation for having us

00:56:05,440 --> 00:56:09,280
today

00:56:06,160 --> 00:56:10,960
have a great day awesome thank you so

00:56:09,280 --> 00:56:12,799
much jim for your time today and thank

00:56:10,960 --> 00:56:13,440
you to all the participants who joined

00:56:12,799 --> 00:56:15,520
us

00:56:13,440 --> 00:56:17,280
as a reminder this recording will be up

00:56:15,520 --> 00:56:18,319
on our linux foundation youtube page

00:56:17,280 --> 00:56:19,760
later today

00:56:18,319 --> 00:56:23,520
okay thanks so much everyone have a

00:56:19,760 --> 00:56:23,520

YouTube URL: https://www.youtube.com/watch?v=qxNC0I0-RvE


