Title: Look Ma’, No (Real) Interrupt Controller! - Marc Zyngier, Google & Christoffer Dall, Arm
Publication date: 2020-11-10
Playlist: KVM Forum Europe 2020
Description: 
	Look Ma’, No (Real) Interrupt Controller! - Marc Zyngier, Google & Christoffer Dall, Arm
Captions: 
	00:00:07,359 --> 00:00:11,280
good morning

00:00:08,320 --> 00:00:12,480
and welcome to the first virtual kvm

00:00:11,280 --> 00:00:16,880
forum

00:00:12,480 --> 00:00:19,680
um i'm mark sanjay i work for google

00:00:16,880 --> 00:00:21,840
and together with christopher dahl um

00:00:19,680 --> 00:00:26,160
we're presenting

00:00:21,840 --> 00:00:29,760
the work we have done to try and revisit

00:00:26,160 --> 00:00:34,000
the way avm 64

00:00:29,760 --> 00:00:37,680
presents interrupts to its guests

00:00:34,000 --> 00:00:39,760
and without telling too much of

00:00:37,680 --> 00:00:41,120
the content of the presentation the

00:00:39,760 --> 00:00:44,000
title is quite explicit

00:00:41,120 --> 00:00:45,440
we basically want to remove the

00:00:44,000 --> 00:00:48,399
interrupt controller from the picture

00:00:45,440 --> 00:00:48,399
or at least try to

00:00:48,559 --> 00:00:54,879
why would we be doing that

00:00:51,680 --> 00:00:58,000
well hypervisors are quite complex

00:00:54,879 --> 00:01:01,440
they are very complex piece

00:00:58,000 --> 00:01:03,120
as we said and and yet they are reliable

00:01:01,440 --> 00:01:05,680
i mean we've

00:01:03,120 --> 00:01:08,799
we're in the business of building a very

00:01:05,680 --> 00:01:10,880
reliable hypervisor

00:01:08,799 --> 00:01:12,240
but that is this thing called

00:01:10,880 --> 00:01:17,439
confidential computing

00:01:12,240 --> 00:01:20,880
or trusted computing that is becoming

00:01:17,439 --> 00:01:23,439
extremely visible

00:01:20,880 --> 00:01:25,280
and security in the hypervisor is is has

00:01:23,439 --> 00:01:28,320
always been a concern but it's now

00:01:25,280 --> 00:01:28,320
even more of a con

00:01:29,040 --> 00:01:34,560
there's things we can do to to make that

00:01:32,000 --> 00:01:36,640
better or to make us feel better about

00:01:34,560 --> 00:01:36,640
it

00:01:37,040 --> 00:01:43,920
we can review audit

00:01:40,880 --> 00:01:48,240
our code and yes

00:01:43,920 --> 00:01:51,360
for those of you who are

00:01:48,240 --> 00:01:56,079
reviewers developers this is hard

00:01:51,360 --> 00:01:59,119
it takes a lot of energy dedication to

00:01:56,079 --> 00:02:02,240
properly review code

00:01:59,119 --> 00:02:03,439
we can harden things make it more

00:02:02,240 --> 00:02:08,399
difficult for

00:02:03,439 --> 00:02:11,760
bugs or exploits to appear

00:02:08,399 --> 00:02:15,200
again uh that's very useful but

00:02:11,760 --> 00:02:17,599
it tends to be reactive

00:02:15,200 --> 00:02:18,400
ideally we would prove that our code is

00:02:17,599 --> 00:02:22,080
correct

00:02:18,400 --> 00:02:22,959
um yeah that's not practical it's at

00:02:22,080 --> 00:02:24,959
scale

00:02:22,959 --> 00:02:28,080
um especially when you look at the size

00:02:24,959 --> 00:02:28,080
of something like linux

00:02:28,239 --> 00:02:34,840
one idea is to reduce

00:02:31,840 --> 00:02:36,480
the part of the hypervisor that we trust

00:02:34,840 --> 00:02:39,360
um by

00:02:36,480 --> 00:02:40,640
de-privileging some of it and only

00:02:39,360 --> 00:02:42,640
making

00:02:40,640 --> 00:02:44,319
you know the ultimate core of the

00:02:42,640 --> 00:02:47,440
hypervisor

00:02:44,319 --> 00:02:50,959
trusted it doesn't mean throwing away

00:02:47,440 --> 00:02:53,040
kvm and deciding that we need to re

00:02:50,959 --> 00:02:54,720
reinvent a hypervisor from scratch um

00:02:53,040 --> 00:02:58,400
and a good example of that

00:02:54,720 --> 00:03:02,319
um is the android protected kvm

00:02:58,400 --> 00:03:04,080
project which i'm contributing to

00:03:02,319 --> 00:03:06,480
and if you're interested in that uh

00:03:04,080 --> 00:03:09,680
please uh watch

00:03:06,480 --> 00:03:09,680
with deakin's presentation

00:03:10,959 --> 00:03:17,200
so users

00:03:14,480 --> 00:03:18,959
do care about their data especially

00:03:17,200 --> 00:03:22,000
their secrets

00:03:18,959 --> 00:03:22,000
that private data

00:03:22,879 --> 00:03:28,720
and they can store that data in what we

00:03:25,120 --> 00:03:32,400
will call confidential vms and

00:03:28,720 --> 00:03:34,560
interesting because they expect that

00:03:32,400 --> 00:03:38,239
these vms will provide a stronger

00:03:34,560 --> 00:03:41,599
isolation than normal applications

00:03:38,239 --> 00:03:44,879
so what defines a confidential vm um

00:03:41,599 --> 00:03:47,680
well it's private state in general

00:03:44,879 --> 00:03:50,400
that's to simply state you don't

00:03:47,680 --> 00:03:54,000
disclose you're registered

00:03:50,400 --> 00:03:55,040
to the third parties your memory is

00:03:54,000 --> 00:03:59,680
strictly private

00:03:55,040 --> 00:04:02,720
either unmapped or encrypted

00:03:59,680 --> 00:04:06,480
rely on things like

00:04:02,720 --> 00:04:09,120
time passing monotonically

00:04:06,480 --> 00:04:10,959
doesn't go backward that's also very

00:04:09,120 --> 00:04:14,640
important

00:04:10,959 --> 00:04:17,280
and then there are interrupts so

00:04:14,640 --> 00:04:17,280
what about them

00:04:17,759 --> 00:04:24,240
well vms need to have some guarantees

00:04:21,199 --> 00:04:26,240
about their interrupts and

00:04:24,240 --> 00:04:27,440
you can think of these interrupts are

00:04:26,240 --> 00:04:30,639
being

00:04:27,440 --> 00:04:32,320
split in two buckets

00:04:30,639 --> 00:04:33,759
on one side you have what we will call

00:04:32,320 --> 00:04:36,960
the trusted interrupts

00:04:33,759 --> 00:04:40,880
they are the interrupts that

00:04:36,960 --> 00:04:44,479
the guest needs internally for

00:04:40,880 --> 00:04:48,800
to be able to function on its own

00:04:44,479 --> 00:04:50,960
and there are things like ipis

00:04:48,800 --> 00:04:52,960
having a vcpu being able to interrupt

00:04:50,960 --> 00:04:56,320
another vcpu

00:04:52,960 --> 00:04:57,680
that's crucial linux totally relies on

00:04:56,320 --> 00:05:01,360
that for its scheduling

00:04:57,680 --> 00:05:01,360
or rcu all kind of thing

00:05:02,160 --> 00:05:06,560
and it's really important that the guest

00:05:04,960 --> 00:05:10,240
especially

00:05:06,560 --> 00:05:13,039
a confidential guest be able to

00:05:10,240 --> 00:05:15,919
trust that when it receives an ipi that

00:05:13,039 --> 00:05:18,720
ipr actually has been sent

00:05:15,919 --> 00:05:20,800
from the vm itself and it doesn't come

00:05:18,720 --> 00:05:23,919
from outer space

00:05:20,800 --> 00:05:26,320
same thing goes for cpu private devices

00:05:23,919 --> 00:05:30,160
your timers

00:05:26,320 --> 00:05:33,120
you want time to be

00:05:30,160 --> 00:05:34,479
monolithically increasing at the same

00:05:33,120 --> 00:05:36,000
time you don't want your timer

00:05:34,479 --> 00:05:38,479
interrupts to be

00:05:36,000 --> 00:05:39,280
crazy or to disappear altogether so

00:05:38,479 --> 00:05:41,520
these are the

00:05:39,280 --> 00:05:44,000
type of things that you would like to

00:05:41,520 --> 00:05:44,000
rely on

00:05:44,160 --> 00:05:47,919
on the other side you have what we will

00:05:46,160 --> 00:05:51,280
call untrusted interrupts

00:05:47,919 --> 00:05:53,360
and these are interrupts that

00:05:51,280 --> 00:05:55,360
are outside of the trusted computing

00:05:53,360 --> 00:05:59,600
phase things like

00:05:55,360 --> 00:06:03,600
your network interface your mass storage

00:05:59,600 --> 00:06:03,600
id you would distrust these interrupts

00:06:04,720 --> 00:06:10,080
so having said that and having

00:06:07,759 --> 00:06:11,039
thought about you know how to separate

00:06:10,080 --> 00:06:14,720
these two

00:06:11,039 --> 00:06:17,919
buckets uh

00:06:14,720 --> 00:06:21,039
can we make that fit in the

00:06:17,919 --> 00:06:24,639
arm 6400 architecture

00:06:21,039 --> 00:06:27,919
we wish so let's have a look at the geek

00:06:24,639 --> 00:06:31,280
architecture to find out and

00:06:27,919 --> 00:06:34,880
it's a five-minute overview

00:06:31,280 --> 00:06:38,160
and some paracetamol

00:06:34,880 --> 00:06:42,639
so the geek architecture which is

00:06:38,160 --> 00:06:45,919
at the part of the arm 64 architecture

00:06:42,639 --> 00:06:49,039
presents not one type of

00:06:45,919 --> 00:06:51,919
interrupts but actually four

00:06:49,039 --> 00:06:53,039
um we have sgis which are used to

00:06:51,919 --> 00:06:57,199
implement i

00:06:53,039 --> 00:06:59,360
ipis dpis which are

00:06:57,199 --> 00:07:00,639
interrupts that are private to a given

00:06:59,360 --> 00:07:03,840
cpu

00:07:00,639 --> 00:07:04,960
spis which are global and lprs which are

00:07:03,840 --> 00:07:08,639
global as well but

00:07:04,960 --> 00:07:10,720
only for things like msis

00:07:08,639 --> 00:07:12,400
these four classes have different

00:07:10,720 --> 00:07:15,520
interrupt life cycles

00:07:12,400 --> 00:07:17,919
a different configuration parameter and

00:07:15,520 --> 00:07:19,599
can or cannot be directly injected

00:07:17,919 --> 00:07:22,880
depending on their class

00:07:19,599 --> 00:07:24,240
and the hardware they come with all kind

00:07:22,880 --> 00:07:27,199
of tunables

00:07:24,240 --> 00:07:28,880
their group their priority their

00:07:27,199 --> 00:07:32,560
affinity

00:07:28,880 --> 00:07:35,919
and a complicated

00:07:32,560 --> 00:07:37,759
set of effects so

00:07:35,919 --> 00:07:40,319
you have the notion of an interrupt

00:07:37,759 --> 00:07:43,360
being pending being active

00:07:40,319 --> 00:07:45,520
being enabled but you also have

00:07:43,360 --> 00:07:47,520
active priorities which are both per

00:07:45,520 --> 00:07:49,759
priority and per cpu

00:07:47,520 --> 00:07:52,240
and the concept of running priority

00:07:49,759 --> 00:07:58,000
which is percept

00:07:52,240 --> 00:08:01,120
so a lot of jargon a lot of state

00:07:58,000 --> 00:08:01,120
but that's only the beginning

00:08:01,360 --> 00:08:04,639
so these interrupt classes are actually

00:08:03,039 --> 00:08:08,000
supported by

00:08:04,639 --> 00:08:11,280
three different blocks

00:08:08,000 --> 00:08:12,240
in hardware so distributor and

00:08:11,280 --> 00:08:16,080
redistributor

00:08:12,240 --> 00:08:19,440
are extremely similar the redistributor

00:08:16,080 --> 00:08:21,919
is at the per cpu level

00:08:19,440 --> 00:08:23,199
and deals with sgis and ppi so your

00:08:21,919 --> 00:08:27,199
private interrupts and

00:08:23,199 --> 00:08:27,759
ipis the distributor deals with spis

00:08:27,199 --> 00:08:30,479
which are

00:08:27,759 --> 00:08:32,800
global interrupts so it implements the

00:08:30,479 --> 00:08:36,880
routing of these interrupts

00:08:32,800 --> 00:08:40,399
to the various cpus both of these blocks

00:08:36,880 --> 00:08:44,480
are entirely mmio based

00:08:40,399 --> 00:08:47,760
and then on the side you have the

00:08:44,480 --> 00:08:50,640
its interrupt translation service

00:08:47,760 --> 00:08:52,800
which deals with lpis this thing we use

00:08:50,640 --> 00:08:56,080
to implement msis

00:08:52,800 --> 00:09:00,320
and that block is partially mmi based

00:08:56,080 --> 00:09:00,720
but also uses in memory command queues

00:09:00,320 --> 00:09:05,360
and

00:09:00,720 --> 00:09:07,200
tables the inside joke

00:09:05,360 --> 00:09:09,600
for those familiar with the gig is that

00:09:07,200 --> 00:09:11,200
the its implements page tables for

00:09:09,600 --> 00:09:14,959
interrupts

00:09:11,200 --> 00:09:15,680
and that's actually the case and the its

00:09:14,959 --> 00:09:17,920
is

00:09:15,680 --> 00:09:18,720
what is required for the architecture to

00:09:17,920 --> 00:09:22,560
provide

00:09:18,720 --> 00:09:25,440
direct injection

00:09:22,560 --> 00:09:25,760
and that was only for the physical side

00:09:25,440 --> 00:09:28,560
now

00:09:25,760 --> 00:09:30,080
on the virtual side when we implement a

00:09:28,560 --> 00:09:33,200
hypervisor

00:09:30,080 --> 00:09:36,240
what facilities do we get well

00:09:33,200 --> 00:09:39,360
the only thing we have is that

00:09:36,240 --> 00:09:43,040
the architecture virtualizes the

00:09:39,360 --> 00:09:43,040
delivery of an interrupt

00:09:43,200 --> 00:09:48,320
it's the only thing so you have two ways

00:09:46,160 --> 00:09:48,320
of

00:09:48,880 --> 00:09:54,560
ensuring that an in job gets delivered

00:09:51,440 --> 00:09:56,480
against either by

00:09:54,560 --> 00:09:58,480
putting that interrupt in what we call a

00:09:56,480 --> 00:10:02,640
list register

00:09:58,480 --> 00:10:05,839
or a set of list registers which are

00:10:02,640 --> 00:10:07,279
registers private to a cpu but that

00:10:05,839 --> 00:10:10,240
actually represents

00:10:07,279 --> 00:10:10,240
a global state

00:10:10,560 --> 00:10:15,040
if you think that's a good idea think

00:10:13,040 --> 00:10:18,560
again

00:10:15,040 --> 00:10:20,000
then we have direct injection which

00:10:18,560 --> 00:10:22,959
we would love to have everywhere

00:10:20,000 --> 00:10:26,000
unfortunately the gig only does that for

00:10:22,959 --> 00:10:29,040
lpis if you have gig v4.1

00:10:26,000 --> 00:10:31,519
and some form of sgis um

00:10:29,040 --> 00:10:32,320
if you have uh the default one so sorry

00:10:31,519 --> 00:10:36,880
lpi is

00:10:32,320 --> 00:10:36,880
hp40 sgi is give you 0.1

00:10:37,040 --> 00:10:41,839
and frankly setting that up is terribly

00:10:40,800 --> 00:10:46,959
complicated

00:10:41,839 --> 00:10:50,160
but exists for everything else which is

00:10:46,959 --> 00:10:51,839
the the whole infrastructure the

00:10:50,160 --> 00:10:55,200
hypervisor has to

00:10:51,839 --> 00:10:55,920
emulate it distributor redistributor and

00:10:55,200 --> 00:10:58,560
its

00:10:55,920 --> 00:10:59,600
there is zero support coming from the

00:10:58,560 --> 00:11:02,959
hardware

00:10:59,600 --> 00:11:05,200
has to be entirely done in software

00:11:02,959 --> 00:11:05,200
fun

00:11:06,399 --> 00:11:11,680
so what does kvm 64 do about the geek

00:11:09,519 --> 00:11:14,800
architecture

00:11:11,680 --> 00:11:18,240
well it's quite painful we support

00:11:14,800 --> 00:11:20,079
the whole gamut of the architecture

00:11:18,240 --> 00:11:21,760
but if you look at the way it works

00:11:20,079 --> 00:11:22,720
there's a lot of state duplication

00:11:21,760 --> 00:11:25,760
between

00:11:22,720 --> 00:11:28,640
emulation and injection

00:11:25,760 --> 00:11:30,959
so a lot of a lot of things happen

00:11:28,640 --> 00:11:36,320
behind the hypervisor's back

00:11:30,959 --> 00:11:36,320
remember this list registers if you put

00:11:36,480 --> 00:11:41,680
an interrupt in the list register and

00:11:39,360 --> 00:11:44,880
get the vcpu running

00:11:41,680 --> 00:11:49,839
and that another vcpu needs to for

00:11:44,880 --> 00:11:49,839
any reason need to introspect that state

00:11:50,079 --> 00:11:54,399
it's hard because oh wait the state is

00:11:53,440 --> 00:11:57,040
actually

00:11:54,399 --> 00:11:58,480
private to a cpu another cpu cannot

00:11:57,040 --> 00:12:02,079
observe it

00:11:58,480 --> 00:12:04,320
so you need some synchronization between

00:12:02,079 --> 00:12:07,440
the two physical cpus

00:12:04,320 --> 00:12:09,760
to get the vcpus out of the vm so that

00:12:07,440 --> 00:12:12,880
you can synchronize the state

00:12:09,760 --> 00:12:13,519
it means physical ipis it's hard to get

00:12:12,880 --> 00:12:15,680
it right

00:12:13,519 --> 00:12:17,920
and it's even harder to make it

00:12:15,680 --> 00:12:19,920
performance

00:12:17,920 --> 00:12:21,680
there's a lot to emulate you have

00:12:19,920 --> 00:12:23,680
literally hundreds of registers

00:12:21,680 --> 00:12:25,760
with complex semantic at both the

00:12:23,680 --> 00:12:27,920
distributor and the distributor level

00:12:25,760 --> 00:12:29,680
we have very complex its commands that

00:12:27,920 --> 00:12:33,040
require global synchronization

00:12:29,680 --> 00:12:35,680
and the opportunities for bugs are

00:12:33,040 --> 00:12:35,680
everywhere

00:12:36,079 --> 00:12:42,079
an interesting um

00:12:39,519 --> 00:12:43,120
thing to try and do would be to

00:12:42,079 --> 00:12:46,160
de-privilege

00:12:43,120 --> 00:12:47,519
that part of the accumulation and let's

00:12:46,160 --> 00:12:50,959
say like on x86

00:12:47,519 --> 00:12:53,040
try and move it to user space in theory

00:12:50,959 --> 00:12:54,000
possible and if you look at the the way

00:12:53,040 --> 00:12:55,839
the geek is split

00:12:54,000 --> 00:12:57,120
you'd say oh yeah we can move all these

00:12:55,839 --> 00:12:59,920
blocks to user space

00:12:57,120 --> 00:13:01,920
and them could be independent in

00:12:59,920 --> 00:13:03,760
practice that would result in a massive

00:13:01,920 --> 00:13:07,120
state duplication

00:13:03,760 --> 00:13:09,360
which would be again hard to synchronize

00:13:07,120 --> 00:13:10,959
um and would also result in bad

00:13:09,360 --> 00:13:12,240
performance because you would just to

00:13:10,959 --> 00:13:13,680
achieve that synchronization you would

00:13:12,240 --> 00:13:15,920
have to go all the way back to user

00:13:13,680 --> 00:13:15,920
space

00:13:17,040 --> 00:13:21,440
we also have to deal with an enormous

00:13:20,000 --> 00:13:22,720
hardware variability

00:13:21,440 --> 00:13:25,360
everything is optional in the

00:13:22,720 --> 00:13:27,760
architecture really absolutely

00:13:25,360 --> 00:13:28,720
everything there are multiple ways of

00:13:27,760 --> 00:13:33,120
doing the same thing

00:13:28,720 --> 00:13:35,760
especially around direct injection

00:13:33,120 --> 00:13:36,560
um we also have tons of architectural

00:13:35,760 --> 00:13:39,440
legacy

00:13:36,560 --> 00:13:41,440
dating from 15 years ago at the very

00:13:39,440 --> 00:13:44,720
least

00:13:41,440 --> 00:13:48,639
so does the

00:13:44,720 --> 00:13:51,600
virtualization architecture the geek

00:13:48,639 --> 00:13:52,800
succeed in simplifying the hypervisor no

00:13:51,600 --> 00:13:54,560
not really i mean

00:13:52,800 --> 00:13:57,440
you just have to look at the amount of

00:13:54,560 --> 00:14:01,600
code this represents about 70 percent

00:13:57,440 --> 00:14:05,680
of the whole kvm 64

00:14:01,600 --> 00:14:08,560
the base it's it's just enormous and

00:14:05,680 --> 00:14:11,360
we did say minimizing the trusted

00:14:08,560 --> 00:14:14,160
computing base earlier

00:14:11,360 --> 00:14:14,880
it doesn't quite cut it and that's

00:14:14,160 --> 00:14:18,639
because the

00:14:14,880 --> 00:14:20,880
geek has been designed to support

00:14:18,639 --> 00:14:21,839
extremely demanding workload you know

00:14:20,880 --> 00:14:23,920
millions of

00:14:21,839 --> 00:14:25,199
interest per second device assignment

00:14:23,920 --> 00:14:28,720
direct injection

00:14:25,199 --> 00:14:30,480
compatibility i mean the key word

00:14:28,720 --> 00:14:33,120
in the gig architecture is we want to

00:14:30,480 --> 00:14:36,160
stay compatible and that's great i mean

00:14:33,120 --> 00:14:39,360
we can run guests even 32-bit guests

00:14:36,160 --> 00:14:40,959
dating from 15 years ago they will just

00:14:39,360 --> 00:14:43,519
run

00:14:40,959 --> 00:14:44,959
but that puts the complexity in the

00:14:43,519 --> 00:14:48,000
hypervisor

00:14:44,959 --> 00:14:50,639
instead of putting it in the guest

00:14:48,000 --> 00:14:52,079
so what if we could introduce an intro

00:14:50,639 --> 00:14:55,920
controller architecture

00:14:52,079 --> 00:14:58,480
for workloads not any workload but only

00:14:55,920 --> 00:15:02,720
those who are let's say

00:14:58,480 --> 00:15:06,880
mostly compute bound not io bound

00:15:02,720 --> 00:15:10,000
and that do not do device assignment

00:15:06,880 --> 00:15:10,480
literally compiling your kernel in the

00:15:10,000 --> 00:15:13,199
vm

00:15:10,480 --> 00:15:15,199
that kind of thing only joking but yes

00:15:13,199 --> 00:15:18,000
for example

00:15:15,199 --> 00:15:19,040
can we make that hypothetical

00:15:18,000 --> 00:15:21,440
architecture

00:15:19,040 --> 00:15:23,760
as simple as possible and move the

00:15:21,440 --> 00:15:25,760
complexity

00:15:23,760 --> 00:15:27,600
to the guest instead of having it at the

00:15:25,760 --> 00:15:31,519
hypervisor level

00:15:27,600 --> 00:15:33,360
what would we gain by doing that well

00:15:31,519 --> 00:15:35,680
that's the question we asked ourselves

00:15:33,360 --> 00:15:35,680
and

00:15:36,320 --> 00:15:42,560
let's hear it from christopher with the

00:15:39,759 --> 00:15:45,279
arvik architecture

00:15:42,560 --> 00:15:46,560
hi my name is christopher dell i work

00:15:45,279 --> 00:15:48,160
for arm and i'd like to talk to you

00:15:46,560 --> 00:15:51,680
about the reduced virtual interrupt

00:15:48,160 --> 00:15:53,680
controller or arvik architecture

00:15:51,680 --> 00:15:56,240
the arabic architecture is an

00:15:53,680 --> 00:15:57,839
experimental hypervisor avi design

00:15:56,240 --> 00:15:59,440
it's publicly available in what we call

00:15:57,839 --> 00:16:02,880
an alpha state which means that it's

00:15:59,440 --> 00:16:02,880
subject to change or withdrawal

00:16:02,959 --> 00:16:06,639
the arabic architecture is a minimal set

00:16:05,440 --> 00:16:08,320
of api calls

00:16:06,639 --> 00:16:10,399
used to implement a virtual interrupt

00:16:08,320 --> 00:16:12,399
controller on rv8

00:16:10,399 --> 00:16:14,240
it seeks to have minimal impact on the

00:16:12,399 --> 00:16:16,639
hypervisor tcp

00:16:14,240 --> 00:16:18,399
and minimal impact on the nvm kernel's

00:16:16,639 --> 00:16:20,079
complexity

00:16:18,399 --> 00:16:21,680
the arboric is designed to support split

00:16:20,079 --> 00:16:24,480
mode hypervisors that have a

00:16:21,680 --> 00:16:27,279
trusted small tcp and a non-trusted

00:16:24,480 --> 00:16:27,279
larger codebase

00:16:27,839 --> 00:16:32,000
the arvik provides per cpu interrupts

00:16:30,720 --> 00:16:34,880
and all interrupts have

00:16:32,000 --> 00:16:36,880
s triggered semantics we do provide a

00:16:34,880 --> 00:16:40,160
resample operation to support

00:16:36,880 --> 00:16:41,759
um level triggered signals the arvik

00:16:40,160 --> 00:16:44,720
provides provides routing

00:16:41,759 --> 00:16:46,160
of virtual interrupts between virtual

00:16:44,720 --> 00:16:49,360
cpus

00:16:46,160 --> 00:16:51,839
and the rv provides support for threaded

00:16:49,360 --> 00:16:51,839
and drop handling

00:16:52,160 --> 00:16:55,759
the arvik architecture actually

00:16:53,519 --> 00:16:57,680
describes two separate components

00:16:55,759 --> 00:16:59,360
the arvik is the pervy cpu interrupt

00:16:57,680 --> 00:17:00,639
controller implemented in the trusted

00:16:59,360 --> 00:17:02,560
hypervisor

00:17:00,639 --> 00:17:03,920
and the rvit is the per-vm virtual

00:17:02,560 --> 00:17:07,039
distributor implemented in the

00:17:03,920 --> 00:17:07,039
non-trusted hypervisor

00:17:07,199 --> 00:17:10,640
there is one arvik instance per virtual

00:17:09,120 --> 00:17:12,720
cpu

00:17:10,640 --> 00:17:13,919
and the arg instance signals interrupts

00:17:12,720 --> 00:17:15,760
to a virtual cpu

00:17:13,919 --> 00:17:18,079
using standard rv8 virtualization

00:17:15,760 --> 00:17:18,640
mechanisms such as the virtual rqbit in

00:17:18,079 --> 00:17:21,839
the

00:17:18,640 --> 00:17:24,799
hypervisor control register

00:17:21,839 --> 00:17:25,839
the arvik exposes a hypercall interface

00:17:24,799 --> 00:17:27,839
to the vm

00:17:25,839 --> 00:17:29,280
which allows the virtual cpu to receive

00:17:27,839 --> 00:17:31,039
and handle interrupts

00:17:29,280 --> 00:17:33,280
enable and disable the entire arabic

00:17:31,039 --> 00:17:34,080
instance mask and unmask individual

00:17:33,280 --> 00:17:37,200
interrupts

00:17:34,080 --> 00:17:37,200
and to send ipis

00:17:37,679 --> 00:17:46,080
the arvid has a single instance per vm

00:17:42,960 --> 00:17:48,480
is used to route interrupts to

00:17:46,080 --> 00:17:49,840
different vcpus and their arabic

00:17:48,480 --> 00:17:52,080
instances

00:17:49,840 --> 00:17:53,440
and it exposes a hypercall interface

00:17:52,080 --> 00:17:55,919
that allows the

00:17:53,440 --> 00:17:58,080
vm to map an interrupt source to a

00:17:55,919 --> 00:18:01,600
specific arabic instance with a given

00:17:58,080 --> 00:18:03,280
interrupt id

00:18:01,600 --> 00:18:04,960
the rvec introduces the concept of

00:18:03,280 --> 00:18:06,720
trusted interrupts

00:18:04,960 --> 00:18:08,720
and trusted interrupts are managed by

00:18:06,720 --> 00:18:10,880
the trusted hypervisor

00:18:08,720 --> 00:18:13,600
an example of a trusted interrupt is an

00:18:10,880 --> 00:18:16,400
ipi where the vm can trust that the

00:18:13,600 --> 00:18:19,360
ipi was actually issued from another

00:18:16,400 --> 00:18:22,559
virtual cpu within the vm

00:18:19,360 --> 00:18:25,120
another example is vcpu local interrupts

00:18:22,559 --> 00:18:28,240
for example from the generic timer

00:18:25,120 --> 00:18:28,799
which where the vm can trust that if it

00:18:28,240 --> 00:18:31,200
sees

00:18:28,799 --> 00:18:32,799
an intro signal from the timer that the

00:18:31,200 --> 00:18:35,919
timer actually has inserted

00:18:32,799 --> 00:18:37,840
its signal on the other hand you have

00:18:35,919 --> 00:18:40,000
non-trusted interrupts which are

00:18:37,840 --> 00:18:41,600
signals um that can be generated from

00:18:40,000 --> 00:18:44,080
outside the trusted hypervisor in the

00:18:41,600 --> 00:18:45,280
non-traffic hypervisor

00:18:44,080 --> 00:18:46,960
then an example of non-trusted

00:18:45,280 --> 00:18:48,080
interrupts would be virtual peripherals

00:18:46,960 --> 00:18:49,440
implemented in the non-trusted

00:18:48,080 --> 00:18:52,400
hypervisor such as

00:18:49,440 --> 00:18:54,160
complicated devices like bird io and all

00:18:52,400 --> 00:18:56,880
non-trusted interrupts can be spoofed

00:18:54,160 --> 00:18:58,000
by non-trusted software meaning that the

00:18:56,880 --> 00:19:00,320
vm software

00:18:58,000 --> 00:19:02,720
has to be resilient against spoofed

00:19:00,320 --> 00:19:05,760
interrupts of this kind

00:19:02,720 --> 00:19:10,480
all interrupts can trust trust their

00:19:05,760 --> 00:19:13,120
mask status on the arvik instances

00:19:10,480 --> 00:19:14,480
the arabic introduces a fairly limited

00:19:13,120 --> 00:19:17,919
set of commands

00:19:14,480 --> 00:19:19,520
you can request the api version of the

00:19:17,919 --> 00:19:22,440
arabic implementation

00:19:19,520 --> 00:19:23,840
you can use the arabic info command

00:19:22,440 --> 00:19:26,080
[Music]

00:19:23,840 --> 00:19:27,679
query how many trusted and untrusted

00:19:26,080 --> 00:19:29,200
interrupts are implemented

00:19:27,679 --> 00:19:31,919
across all the arabic instances in the

00:19:29,200 --> 00:19:33,280
system you can enable and disable entire

00:19:31,919 --> 00:19:35,280
arabic instances

00:19:33,280 --> 00:19:36,799
you can set and clear the mask status of

00:19:35,280 --> 00:19:38,720
individual introverts

00:19:36,799 --> 00:19:40,080
you can query the pending status of an

00:19:38,720 --> 00:19:41,679
individual interrupt

00:19:40,080 --> 00:19:43,520
you can acknowledge a pending interrupt

00:19:41,679 --> 00:19:44,080
and obtain whatever interrupt id is

00:19:43,520 --> 00:19:46,640
pending

00:19:44,080 --> 00:19:48,160
currently you can clear the pending

00:19:46,640 --> 00:19:50,720
state of an interrupt

00:19:48,160 --> 00:19:53,440
and you can signal an interrupt on

00:19:50,720 --> 00:19:55,360
another arctic instance

00:19:53,440 --> 00:19:57,039
finally you can also re-sample the state

00:19:55,360 --> 00:20:00,480
of an interrupt which is useful for

00:19:57,039 --> 00:20:02,799
level trigger sources and a number of

00:20:00,480 --> 00:20:05,520
these commands work across

00:20:02,799 --> 00:20:08,320
arabic instances or across virtual cpus

00:20:05,520 --> 00:20:10,799
and that is really useful for

00:20:08,320 --> 00:20:13,120
rerouting interrupts and to quiesce the

00:20:10,799 --> 00:20:13,120
system

00:20:13,600 --> 00:20:17,280
the rvid only exposes two commands map

00:20:16,320 --> 00:20:19,679
and on map

00:20:17,280 --> 00:20:20,880
map maps an input signal to a target

00:20:19,679 --> 00:20:23,679
arabic instance

00:20:20,880 --> 00:20:24,720
with a particular interrupt id and unmap

00:20:23,679 --> 00:20:27,760
tells the orbit

00:20:24,720 --> 00:20:31,120
to not signal any interrupts at all

00:20:27,760 --> 00:20:31,120
for that for that device

00:20:31,360 --> 00:20:35,200
in terms of future direction we would

00:20:33,520 --> 00:20:37,280
like to evaluate the usefulness of the

00:20:35,200 --> 00:20:39,840
arabic architecture for

00:20:37,280 --> 00:20:41,520
things like google peak kvm and also for

00:20:39,840 --> 00:20:43,440
other use cases

00:20:41,520 --> 00:20:45,600
we plan to add a priority scheme to the

00:20:43,440 --> 00:20:47,520
arabic which can be used to support

00:20:45,600 --> 00:20:49,200
pseudonymize in linux

00:20:47,520 --> 00:20:50,960
and also to support other operating

00:20:49,200 --> 00:20:54,240
systems which require

00:20:50,960 --> 00:20:56,320
priority support currently

00:20:54,240 --> 00:20:57,919
our level triggered resample operation

00:20:56,320 --> 00:20:59,919
is limited to trusted interrupts we

00:20:57,919 --> 00:21:01,280
would like to expand that to

00:20:59,919 --> 00:21:03,440
non-trusted interrupts which can be

00:21:01,280 --> 00:21:06,080
useful if you want to emulate

00:21:03,440 --> 00:21:07,520
legacy components like like uarts using

00:21:06,080 --> 00:21:09,840
level triggered interrupt signals in the

00:21:07,520 --> 00:21:11,919
non-trusted hypervisor

00:21:09,840 --> 00:21:15,120
and finally we would like to add a

00:21:11,919 --> 00:21:17,200
virtual msi support in the orbit

00:21:15,120 --> 00:21:20,559
which would be useful in the context of

00:21:17,200 --> 00:21:20,559
emulated pci for example

00:21:21,120 --> 00:21:25,200
so arm would like to welcome any

00:21:22,880 --> 00:21:27,600
feedback on use cases or

00:21:25,200 --> 00:21:28,640
on changes to the arabic orbit concepts

00:21:27,600 --> 00:21:30,080
in the

00:21:28,640 --> 00:21:32,880
orbit specification in the arabic

00:21:30,080 --> 00:21:35,600
specification um

00:21:32,880 --> 00:21:36,799
and you can email me directly for any or

00:21:35,600 --> 00:21:41,440
any suggestions

00:21:36,799 --> 00:21:45,440
thank you thanks christopher

00:21:41,440 --> 00:21:49,440
so what about the arvik and kvn

00:21:45,440 --> 00:21:51,840
so we have a full arvik and avid

00:21:49,440 --> 00:21:52,640
implementation for kvm on m64 you can

00:21:51,840 --> 00:21:54,080
see

00:21:52,640 --> 00:21:55,340
the pointer to the patches at the bottom

00:21:54,080 --> 00:21:57,039
of this slide

00:21:55,340 --> 00:21:59,919
[Music]

00:21:57,039 --> 00:22:00,880
that's tiny absolutely tiny 1100 lines

00:21:59,919 --> 00:22:04,240
of code

00:22:00,880 --> 00:22:07,919
um which is less than the tenth of the

00:22:04,240 --> 00:22:12,559
dv3 equivalent um most of the changes

00:22:07,919 --> 00:22:15,840
are about moving the v gig which

00:22:12,559 --> 00:22:19,760
had its fingers in every pi

00:22:15,840 --> 00:22:22,159
of the m64 tree into its own box

00:22:19,760 --> 00:22:24,400
and keep it there so it's about it was

00:22:22,159 --> 00:22:27,840
about defining a clean interface

00:22:24,400 --> 00:22:31,039
always a good thing to do we have some

00:22:27,840 --> 00:22:33,919
very very sketchy code

00:22:31,039 --> 00:22:34,720
or kvm tool uh it's basically a huge

00:22:33,919 --> 00:22:37,840
hack

00:22:34,720 --> 00:22:41,120
which is dt only doesn't deal with live

00:22:37,840 --> 00:22:43,760
migration like the rest of kingdom tool

00:22:41,120 --> 00:22:44,559
it's really a way to get things started

00:22:43,760 --> 00:22:48,159
eventually

00:22:44,559 --> 00:22:50,880
that should be rewritten from scratch

00:22:48,159 --> 00:22:52,480
and we have a complete guest driver for

00:22:50,880 --> 00:22:55,440
linux

00:22:52,480 --> 00:22:57,919
it's about the same size about 900 lines

00:22:55,440 --> 00:23:00,159
of code plus

00:22:57,919 --> 00:23:02,159
a bit more for the msi support which

00:23:00,159 --> 00:23:04,320
we'll talk about later

00:23:02,159 --> 00:23:06,480
and frankly it was a good opportunity to

00:23:04,320 --> 00:23:10,000
clean the arm 64

00:23:06,480 --> 00:23:13,600
smp code and especially the ipi code

00:23:10,000 --> 00:23:13,600
so yeah not a bad thing to do

00:23:14,799 --> 00:23:18,240
how bad is it well it's acceptable let's

00:23:17,200 --> 00:23:20,320
say

00:23:18,240 --> 00:23:21,520
i don't have any scientific measurements

00:23:20,320 --> 00:23:24,960
but

00:23:21,520 --> 00:23:28,080
early um benchmarks show that hackbench

00:23:24,960 --> 00:23:31,200
um extremely high ipi heavy

00:23:28,080 --> 00:23:32,080
is around five percent slower not too

00:23:31,200 --> 00:23:35,360
bad

00:23:32,080 --> 00:23:36,960
uh i mean five percent is huge but

00:23:35,360 --> 00:23:39,360
in the grand scheme of things things

00:23:36,960 --> 00:23:41,679
given how this

00:23:39,360 --> 00:23:42,960
even drop controller is implemented it's

00:23:41,679 --> 00:23:45,279
not horrible

00:23:42,960 --> 00:23:47,679
um general calculation which is the

00:23:45,279 --> 00:23:49,440
benchmark i actually care about

00:23:47,679 --> 00:23:51,840
shows actually no significant difference

00:23:49,440 --> 00:23:54,320
which is quite amazing

00:23:51,840 --> 00:23:55,200
so it's very trap heavy but turns out

00:23:54,320 --> 00:23:58,000
that

00:23:55,200 --> 00:24:00,640
interacting with the hardware isn't free

00:23:58,000 --> 00:24:02,480
i mean it has a huge cost

00:24:00,640 --> 00:24:04,750
all these system registers or this every

00:24:02,480 --> 00:24:06,000
store we have to perform

00:24:04,750 --> 00:24:08,799
[Music]

00:24:06,000 --> 00:24:10,240
is also very expensive and not having

00:24:08,799 --> 00:24:13,600
any cross cpu

00:24:10,240 --> 00:24:16,400
interaction really helps here so

00:24:13,600 --> 00:24:18,640
definitely more analysis is required we

00:24:16,400 --> 00:24:21,919
want to find out um

00:24:18,640 --> 00:24:23,600
whether we can improve things or maybe

00:24:21,919 --> 00:24:26,720
things are worse than we think but

00:24:23,600 --> 00:24:27,360
honestly for now it's all right and to

00:24:26,720 --> 00:24:32,320
be honest

00:24:27,360 --> 00:24:34,240
performance wasn't the

00:24:32,320 --> 00:24:35,760
the key point for the design it was the

00:24:34,240 --> 00:24:39,919
simplicity and i think for that

00:24:35,760 --> 00:24:43,520
yeah we seem to have achieved a goal

00:24:39,919 --> 00:24:45,360
and talking about simplicity um

00:24:43,520 --> 00:24:47,120
i said earlier that we wanted to move

00:24:45,360 --> 00:24:48,799
the complexity from the hypervisor into

00:24:47,120 --> 00:24:52,640
the guest so

00:24:48,799 --> 00:24:54,000
how bad is that well let's look into

00:24:52,640 --> 00:24:55,679
what is probably one of the most

00:24:54,000 --> 00:24:56,960
complicated

00:24:55,679 --> 00:24:59,120
operation that we have to implement

00:24:56,960 --> 00:25:01,679
which is to move

00:24:59,120 --> 00:25:04,080
an interrupt from targeting a cpu to

00:25:01,679 --> 00:25:04,080
another

00:25:04,480 --> 00:25:08,159
just getting the affinity

00:25:09,760 --> 00:25:13,120
if you do that at the geek level it's

00:25:11,679 --> 00:25:14,080
quite complicated because you need to

00:25:13,120 --> 00:25:17,520
synchronize

00:25:14,080 --> 00:25:19,279
your cpus making sure that um

00:25:17,520 --> 00:25:21,600
the state cannot change from under your

00:25:19,279 --> 00:25:24,400
feet because it's it will be

00:25:21,600 --> 00:25:26,159
changed by another vcpu while you're

00:25:24,400 --> 00:25:29,760
trying to move the interrupt

00:25:26,159 --> 00:25:32,080
it's fraught with danger

00:25:29,760 --> 00:25:33,440
if you implement it entirely in the

00:25:32,080 --> 00:25:35,120
guest like we do

00:25:33,440 --> 00:25:37,360
uh with the arabic and you can look at

00:25:35,120 --> 00:25:40,240
the code that is here it's extremely

00:25:37,360 --> 00:25:41,039
simple although it's logically the what

00:25:40,240 --> 00:25:43,039
you would do

00:25:41,039 --> 00:25:44,559
at the hypervisor level as well so you

00:25:43,039 --> 00:25:48,000
mask the interrupt

00:25:44,559 --> 00:25:50,240
at the old cpu level you

00:25:48,000 --> 00:25:51,279
sample the panic state you map it onto

00:25:50,240 --> 00:25:54,799
the new cpu

00:25:51,279 --> 00:25:56,400
and if it was pending you

00:25:54,799 --> 00:25:58,480
inject that interrupt you clear the

00:25:56,400 --> 00:26:02,080
pending state on the old cpu

00:25:58,480 --> 00:26:05,200
and you clear the mass state on the new

00:26:02,080 --> 00:26:07,679
vcpu and you're done

00:26:05,200 --> 00:26:08,559
the difference here well there's no

00:26:07,679 --> 00:26:10,799
locking

00:26:08,559 --> 00:26:12,080
there's no locking whatsoever because we

00:26:10,799 --> 00:26:14,559
rely

00:26:12,080 --> 00:26:15,360
on the guest doing the locking which it

00:26:14,559 --> 00:26:18,400
needs to do

00:26:15,360 --> 00:26:20,159
anyway it's a given

00:26:18,400 --> 00:26:21,600
so if we had to do that in the

00:26:20,159 --> 00:26:25,360
hypervisor it's much harder

00:26:21,600 --> 00:26:29,840
here we just reuse something that the

00:26:25,360 --> 00:26:29,840
guest has to provide and that's key

00:26:30,720 --> 00:26:38,000
now when it comes to msi support

00:26:34,320 --> 00:26:40,880
so as we said being pvd

00:26:38,000 --> 00:26:42,559
the avid spec doesn't define what an msi

00:26:40,880 --> 00:26:45,840
is because it only has abstract input

00:26:42,559 --> 00:26:48,799
so no mmi oh no doorbell whatsoever

00:26:45,840 --> 00:26:50,320
just not the thing and that's a bit of a

00:26:48,799 --> 00:26:50,960
problem because we want to be able to

00:26:50,320 --> 00:26:54,159
reuse

00:26:50,960 --> 00:26:57,039
things like pci device models

00:26:54,159 --> 00:26:57,039
vertex or pci

00:26:57,200 --> 00:27:04,480
because we don't have level interrupts

00:27:02,320 --> 00:27:06,080
untrusted level in drops we can't

00:27:04,480 --> 00:27:10,320
implement in tech support

00:27:06,080 --> 00:27:13,840
so far so we need to

00:27:10,320 --> 00:27:17,919
grow some form of msi support

00:27:13,840 --> 00:27:20,320
so okay we've invented it um

00:27:17,919 --> 00:27:21,039
so we just reserve a bunch of um harvard

00:27:20,320 --> 00:27:23,520
input

00:27:21,039 --> 00:27:25,440
as msi's we add a fake doorbell it's

00:27:23,520 --> 00:27:28,159
which is yet another

00:27:25,440 --> 00:27:30,240
uh terrible kvm tool hack uh which is

00:27:28,159 --> 00:27:33,440
based on the gig v2 emulation

00:27:30,240 --> 00:27:35,039
um that definitely needs reworking uh

00:27:33,440 --> 00:27:36,480
so that to be independent of the arvid

00:27:35,039 --> 00:27:40,000
basically what we need to do

00:27:36,480 --> 00:27:40,559
is create a separate virtual block that

00:27:40,000 --> 00:27:43,200
is

00:27:40,559 --> 00:27:43,760
in front of the avid and which only

00:27:43,200 --> 00:27:47,679
provides

00:27:43,760 --> 00:27:49,039
input to the oven all we need to drb to

00:27:47,679 --> 00:27:52,240
grow some msi support

00:27:49,039 --> 00:27:54,640
but anyway that needs to

00:27:52,240 --> 00:27:55,679
to be changed but as a proof of context

00:27:54,640 --> 00:27:59,279
of concept

00:27:55,679 --> 00:27:59,279
but not too bad

00:27:59,760 --> 00:28:05,919
so where do we take this uh

00:28:03,279 --> 00:28:07,120
so we managed to demonstrate a few

00:28:05,919 --> 00:28:10,240
things uh

00:28:07,120 --> 00:28:13,600
it's possible to pv an intro controller

00:28:10,240 --> 00:28:17,279
with actually very little all we need to

00:28:13,600 --> 00:28:19,360
be able to do is to inject

00:28:17,279 --> 00:28:20,799
signal an exception to the guest and

00:28:19,360 --> 00:28:22,480
take a hyper call

00:28:20,799 --> 00:28:24,720
yeah most architectures are capable of

00:28:22,480 --> 00:28:24,720
that

00:28:24,960 --> 00:28:31,360
guests don't always require future

00:28:28,240 --> 00:28:34,960
rich architecture which is great because

00:28:31,360 --> 00:28:38,320
the arvik provides extremely little

00:28:34,960 --> 00:28:40,159
and we manage to keep it small it's easy

00:28:38,320 --> 00:28:43,679
to review it's easy to edit

00:28:40,159 --> 00:28:49,039
and more importantly it's

00:28:43,679 --> 00:28:49,039
easy to prove properties about it

00:28:50,320 --> 00:28:58,880
and frankly the way i see it it's a very

00:28:54,320 --> 00:29:02,159
interesting tool to prototype

00:28:58,880 --> 00:29:02,720
new intro architectures try new semantic

00:29:02,159 --> 00:29:06,720
you know

00:29:02,720 --> 00:29:09,520
we have we're freed from

00:29:06,720 --> 00:29:11,279
the hardware we have both the host and

00:29:09,520 --> 00:29:15,679
the guest we can play with that

00:29:11,279 --> 00:29:19,600
we can invent new things and we can

00:29:15,679 --> 00:29:21,760
see where that takes us also

00:29:19,600 --> 00:29:24,480
as i said in the first point because it

00:29:21,760 --> 00:29:26,320
requires so little

00:29:24,480 --> 00:29:28,480
could it have a life on other

00:29:26,320 --> 00:29:31,200
architectures can we have

00:29:28,480 --> 00:29:33,520
a cross architecture in drop control

00:29:31,200 --> 00:29:36,399
architecture

00:29:33,520 --> 00:29:36,399
i guess we'll find out

00:29:36,640 --> 00:29:41,840

YouTube URL: https://www.youtube.com/watch?v=smWN9KvhEe4


