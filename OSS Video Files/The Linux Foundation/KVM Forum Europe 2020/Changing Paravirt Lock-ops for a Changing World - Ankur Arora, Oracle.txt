Title: Changing Paravirt Lock-ops for a Changing World - Ankur Arora, Oracle
Publication date: 2020-11-10
Playlist: KVM Forum Europe 2020
Description: 
	Changing Paravirt Lock-ops for a Changing World - Ankur Arora, Oracle
Captions: 
	00:00:05,440 --> 00:00:08,480
mankor

00:00:06,560 --> 00:00:09,840
and today i'll be talking about a

00:00:08,480 --> 00:00:12,480
dynamic power word

00:00:09,840 --> 00:00:12,480
block ops

00:00:13,599 --> 00:00:18,000
so i start off talking about the

00:00:15,920 --> 00:00:20,480
motivation for this feature

00:00:18,000 --> 00:00:23,600
then i'll talk about the state machine

00:00:20,480 --> 00:00:23,600
for qt spin locks

00:00:23,680 --> 00:00:30,240
and then i'll talk about you know

00:00:27,279 --> 00:00:31,840
what does switching pv lock ops what

00:00:30,240 --> 00:00:34,239
what does that involve

00:00:31,840 --> 00:00:36,880
mostly the requirements and you know

00:00:34,239 --> 00:00:38,719
what do we need for safety

00:00:36,880 --> 00:00:41,120
and then i'll talk about the patching

00:00:38,719 --> 00:00:44,800
mechanism which is breakpoint based

00:00:41,120 --> 00:00:47,920
and the design and and

00:00:44,800 --> 00:00:51,520
implementation of b1 and then the design

00:00:47,920 --> 00:00:53,280
of the v2 for this feature

00:00:51,520 --> 00:00:55,039
so this whole thing started with wanting

00:00:53,280 --> 00:00:57,600
yes to be more dynamic

00:00:55,039 --> 00:00:58,399
and dynamic specifically in the sense

00:00:57,600 --> 00:01:01,760
that

00:00:58,399 --> 00:01:04,640
uh kvm advertises to guests

00:01:01,760 --> 00:01:05,600
um i gave him host advertisers to to

00:01:04,640 --> 00:01:09,280
guess

00:01:05,600 --> 00:01:12,320
you know this uh feature whether the

00:01:09,280 --> 00:01:15,439
the vcpus for the for the guest

00:01:12,320 --> 00:01:16,159
are over subscribed or not and if

00:01:15,439 --> 00:01:18,640
they're not

00:01:16,159 --> 00:01:20,799
then in quite a lot of respects it's

00:01:18,640 --> 00:01:22,080
fairly similar to bare metal where

00:01:20,799 --> 00:01:24,560
you know at least you know that a

00:01:22,080 --> 00:01:28,240
different process will not

00:01:24,560 --> 00:01:32,400
schedule out your vcpu

00:01:28,240 --> 00:01:35,360
and and and so if the center is true uh

00:01:32,400 --> 00:01:36,640
a kvm guest would basically use native

00:01:35,360 --> 00:01:40,079
pb locks

00:01:36,640 --> 00:01:43,040
if it isn't uh meaning

00:01:40,079 --> 00:01:45,280
it is possible that that your uh threads

00:01:43,040 --> 00:01:48,880
vcp threads can get scheduled out

00:01:45,280 --> 00:01:52,079
you use power word pv lock ops

00:01:48,880 --> 00:01:55,439
and that's

00:01:52,079 --> 00:01:58,719
that's good except that if

00:01:55,439 --> 00:02:01,280
this this hint becomes

00:01:58,719 --> 00:02:02,560
untrue at some point in the lifetime of

00:02:01,280 --> 00:02:05,759
the guest

00:02:02,560 --> 00:02:06,240
um you know the the host could could

00:02:05,759 --> 00:02:08,479
move

00:02:06,240 --> 00:02:10,879
to an old subscribe mode for for

00:02:08,479 --> 00:02:14,000
whatever reason and the guest has

00:02:10,879 --> 00:02:15,360
no control over that then typically

00:02:14,000 --> 00:02:17,280
you know the guest would see soft

00:02:15,360 --> 00:02:19,360
lockups

00:02:17,280 --> 00:02:21,200
and and you know the the recommended fix

00:02:19,360 --> 00:02:23,760
for this is that a host should only

00:02:21,200 --> 00:02:26,640
advertise this particular feature

00:02:23,760 --> 00:02:27,520
uh at this particular hint if it can

00:02:26,640 --> 00:02:29,599
guarantee

00:02:27,520 --> 00:02:31,200
the the hint for the lifetime of the

00:02:29,599 --> 00:02:35,040
guest

00:02:31,200 --> 00:02:39,040
now that seems kind of reasonable but

00:02:35,040 --> 00:02:39,040
it it does seem unsatisfying

00:02:41,120 --> 00:02:44,720
uh given that most of this presentation

00:02:43,599 --> 00:02:47,840
is about

00:02:44,720 --> 00:02:50,160
um switching power logs which are based

00:02:47,840 --> 00:02:52,160
on on on cued spin logs

00:02:50,160 --> 00:02:54,879
let's uh you know go over some of the

00:02:52,160 --> 00:02:58,239
interfaces involved

00:02:54,879 --> 00:02:59,840
um so there are five interfaces for this

00:02:58,239 --> 00:03:02,640
and you know you can see them all of

00:02:59,840 --> 00:03:05,440
them outlined in blue

00:03:02,640 --> 00:03:06,239
interestingly the the one interface

00:03:05,440 --> 00:03:09,440
which is

00:03:06,239 --> 00:03:12,720
which is not a pv lock-up is

00:03:09,440 --> 00:03:15,519
huge spinner spin lock

00:03:12,720 --> 00:03:15,840
and and that's pretty interesting and

00:03:15,519 --> 00:03:18,640
and

00:03:15,840 --> 00:03:19,920
you know that's the fact that that that

00:03:18,640 --> 00:03:21,360
causes a

00:03:19,920 --> 00:03:23,200
fair amount of trouble you know when

00:03:21,360 --> 00:03:26,080
you're done switching these because

00:03:23,200 --> 00:03:27,280
now you have no way of getting entry

00:03:26,080 --> 00:03:30,400
into

00:03:27,280 --> 00:03:34,319
um into the state machine

00:03:30,400 --> 00:03:37,440
essentially right um

00:03:34,319 --> 00:03:38,080
you you can get the pv lock ops but you

00:03:37,440 --> 00:03:40,400
cannot

00:03:38,080 --> 00:03:41,599
get queued spin lock for one thing you

00:03:40,400 --> 00:03:43,519
don't even know

00:03:41,599 --> 00:03:44,799
you know all the call sides that cued

00:03:43,519 --> 00:03:48,159
spin lock

00:03:44,799 --> 00:03:50,560
is called from um

00:03:48,159 --> 00:03:52,000
so the other notable thing in this state

00:03:50,560 --> 00:03:55,200
machine

00:03:52,000 --> 00:03:57,280
is is you know the squiggly lines so

00:03:55,200 --> 00:03:58,799
all of the interfaces on the other side

00:03:57,280 --> 00:04:02,799
of those that's basically

00:03:58,799 --> 00:04:04,400
fate kick vcpu is preempted as somewhat

00:04:02,799 --> 00:04:07,360
special i'll come to it

00:04:04,400 --> 00:04:07,840
but wait and kick are basically no ops

00:04:07,360 --> 00:04:10,879
for

00:04:07,840 --> 00:04:14,400
for the native case um

00:04:10,879 --> 00:04:17,680
did which of course i mean make sense

00:04:14,400 --> 00:04:20,720
um for the in kvm

00:04:17,680 --> 00:04:22,960
weight is kvm weight it basically goes

00:04:20,720 --> 00:04:26,000
and does a halt

00:04:22,960 --> 00:04:30,320
uh in in the host and and kick

00:04:26,000 --> 00:04:32,479
essentially it does a kvm hyper call

00:04:30,320 --> 00:04:33,360
and you know it it does what you would

00:04:32,479 --> 00:04:36,479
really expect

00:04:33,360 --> 00:04:38,720
so now uh having seen the state machine

00:04:36,479 --> 00:04:40,400
let's go a little bit into why don't we

00:04:38,720 --> 00:04:43,440
just use parallel locks

00:04:40,400 --> 00:04:46,639
all the time um so

00:04:43,440 --> 00:04:47,360
you can see that you know the unlock

00:04:46,639 --> 00:04:49,199
fast path

00:04:47,360 --> 00:04:51,840
is different for for both of them and

00:04:49,199 --> 00:04:53,919
this slide doesn't say which is which

00:04:51,840 --> 00:04:55,040
but i'm sure it's easy to guess that you

00:04:53,919 --> 00:04:57,440
know the native case

00:04:55,040 --> 00:04:59,680
it's just literally a move the power

00:04:57,440 --> 00:05:02,880
word case is a lot compare exchange

00:04:59,680 --> 00:05:04,720
and you know if that comparison fails

00:05:02,880 --> 00:05:08,000
you you take the slow path

00:05:04,720 --> 00:05:12,160
where you find the next node and

00:05:08,000 --> 00:05:14,479
kick it um and i mean clearly they are

00:05:12,160 --> 00:05:18,080
optimized for different use cases but

00:05:14,479 --> 00:05:20,639
you would pay the extra cost of a

00:05:18,080 --> 00:05:22,840
compare exchange even when you don't

00:05:20,639 --> 00:05:26,800
don't need it

00:05:22,840 --> 00:05:28,639
um okay another example is that cued

00:05:26,800 --> 00:05:31,360
spin lock slow path

00:05:28,639 --> 00:05:32,880
it's uh pessimistic by default for for

00:05:31,360 --> 00:05:36,080
parabot

00:05:32,880 --> 00:05:38,960
uh so in the native case yes you know um

00:05:36,080 --> 00:05:39,360
cued spin lock slow path would um you

00:05:38,960 --> 00:05:42,639
know

00:05:39,360 --> 00:05:45,280
spin for a little bit uh and then

00:05:42,639 --> 00:05:45,919
queue up uh if it still hasn't gotten a

00:05:45,280 --> 00:05:48,479
lock

00:05:45,919 --> 00:05:50,240
powered case the first thing it does is

00:05:48,479 --> 00:05:54,160
it gets the mcs node

00:05:50,240 --> 00:05:55,440
you know incorporation to connect you up

00:05:54,160 --> 00:05:58,080
all right now that i've hopefully

00:05:55,440 --> 00:05:58,560
convinced you uh on why we need this

00:05:58,080 --> 00:06:02,000
feature

00:05:58,560 --> 00:06:04,639
what does it involve

00:06:02,000 --> 00:06:06,240
so fundamentally what you need to do is

00:06:04,639 --> 00:06:08,160
you have five interfaces

00:06:06,240 --> 00:06:10,560
um these are spread all over you know

00:06:08,160 --> 00:06:13,039
the kernel modules and so on

00:06:10,560 --> 00:06:14,160
and you need to switch all of them

00:06:13,039 --> 00:06:18,000
atomically

00:06:14,160 --> 00:06:20,960
what does actually switching them

00:06:18,000 --> 00:06:21,280
involve so you know this is the example

00:06:20,960 --> 00:06:24,560
of

00:06:21,280 --> 00:06:27,360
spin unlock so you have to transform

00:06:24,560 --> 00:06:28,080
between the the op codes between you

00:06:27,360 --> 00:06:32,000
know one of

00:06:28,080 --> 00:06:33,600
uh from one to the other uh sequence

00:06:32,000 --> 00:06:35,440
and of course you might be doing it like

00:06:33,600 --> 00:06:38,560
multiple times

00:06:35,440 --> 00:06:38,960
um so the native cute spin unlock as i

00:06:38,560 --> 00:06:42,720
think

00:06:38,960 --> 00:06:46,000
i showed in a previous slide it's

00:06:42,720 --> 00:06:49,039
it's basically a move three bytes and

00:06:46,000 --> 00:06:52,319
uh a four byte knob

00:06:49,039 --> 00:06:54,400
the pvq spin unlock is a

00:06:52,319 --> 00:06:56,400
is a call to the actual function which

00:06:54,400 --> 00:06:58,800
you know does the queuing

00:06:56,400 --> 00:07:00,639
and it's an exchange uh which is

00:06:58,800 --> 00:07:03,680
basically a two byte knob

00:07:00,639 --> 00:07:07,039
the the call is interesting because no

00:07:03,680 --> 00:07:08,720
it's a call now you imagine a different

00:07:07,039 --> 00:07:12,560
cpu is doing the patching

00:07:08,720 --> 00:07:12,960
um while you know one cpu is in the pvq

00:07:12,560 --> 00:07:16,080
spin

00:07:12,960 --> 00:07:18,560
unlock call and it's called

00:07:16,080 --> 00:07:19,199
you know whatever this address might be

00:07:18,560 --> 00:07:22,000
when it

00:07:19,199 --> 00:07:23,680
when the sky returns uh the queue it's

00:07:22,000 --> 00:07:24,560
been unlocked when it returns from the

00:07:23,680 --> 00:07:27,759
call

00:07:24,560 --> 00:07:31,840
it returns to address 5 and it expects

00:07:27,759 --> 00:07:31,840
to execute 6690

00:07:32,479 --> 00:07:40,800
however if you have managed to

00:07:36,639 --> 00:07:40,800
finish the the switching by that point

00:07:41,280 --> 00:07:48,000
the contents of address five here

00:07:44,639 --> 00:07:50,240
are four zero zero zero

00:07:48,000 --> 00:07:51,120
and as you can imagine that probably

00:07:50,240 --> 00:07:53,599
will not go

00:07:51,120 --> 00:07:53,599
very well

00:07:55,039 --> 00:07:58,879
and you know just to deliver the point a

00:07:57,039 --> 00:08:01,039
little bit more

00:07:58,879 --> 00:08:02,240
uh you might you might have other ops

00:08:01,039 --> 00:08:06,160
which uh

00:08:02,240 --> 00:08:10,879
similarly go from a call plus no op 2

00:08:06,160 --> 00:08:10,879
to just to know up 7 or back

00:08:11,280 --> 00:08:16,240
uh now one nice thing is that spinlocks

00:08:14,400 --> 00:08:17,840
cannot sleep they could be present for

00:08:16,240 --> 00:08:18,720
for active threats but they will not be

00:08:17,840 --> 00:08:24,000
present for

00:08:18,720 --> 00:08:24,000
sleeping threats and and that's great

00:08:24,960 --> 00:08:32,159
all right so what are the possible

00:08:28,560 --> 00:08:34,240
active users uh

00:08:32,159 --> 00:08:35,599
of spinlocks while we are doing this

00:08:34,240 --> 00:08:37,599
patching

00:08:35,599 --> 00:08:39,039
so it's really the standard suspects you

00:08:37,599 --> 00:08:41,760
have tasks you have

00:08:39,039 --> 00:08:42,719
software cues you have interrupt

00:08:41,760 --> 00:08:45,360
handlers

00:08:42,719 --> 00:08:47,040
you have nmi handlers the the only thing

00:08:45,360 --> 00:08:50,480
which might not be taking spin lock

00:08:47,040 --> 00:08:52,399
is if it's in a user thread context

00:08:50,480 --> 00:08:54,080
interrupt handlers especially are

00:08:52,399 --> 00:08:56,720
interesting because

00:08:54,080 --> 00:08:57,360
uh the mechanism which i i'll describe a

00:08:56,720 --> 00:09:01,040
little more

00:08:57,360 --> 00:09:04,080
uh in a later slide is textbook pp

00:09:01,040 --> 00:09:08,880
which uses breakpoints and

00:09:04,080 --> 00:09:11,680
it's essentially a three-phased um

00:09:08,880 --> 00:09:12,160
patching process for for each call site

00:09:11,680 --> 00:09:16,080
and

00:09:12,160 --> 00:09:19,200
and so you would you know do a

00:09:16,080 --> 00:09:21,360
write write an op code

00:09:19,200 --> 00:09:22,560
after you've finished writing the opcode

00:09:21,360 --> 00:09:24,320
you need to synchro

00:09:22,560 --> 00:09:26,560
you need to ensure that all cpu

00:09:24,320 --> 00:09:28,880
pipelines they're synchronized

00:09:26,560 --> 00:09:30,080
um so the caches are synchronized by by

00:09:28,880 --> 00:09:31,600
default

00:09:30,080 --> 00:09:34,000
what you have to worry about is the

00:09:31,600 --> 00:09:36,320
pipeline synchronization

00:09:34,000 --> 00:09:39,680
um because it's possible that you know

00:09:36,320 --> 00:09:42,320
you have the pipeline cache which has

00:09:39,680 --> 00:09:44,320
uh which is prefetched prefetched you

00:09:42,320 --> 00:09:46,560
know some of these instructions

00:09:44,320 --> 00:09:48,959
maybe they've been decoded into microps

00:09:46,560 --> 00:09:52,880
and so on

00:09:48,959 --> 00:09:55,680
so so the ipi is sent out to

00:09:52,880 --> 00:09:56,160
to essentially synchronize the pipeline

00:09:55,680 --> 00:09:58,000
and

00:09:56,160 --> 00:10:00,640
essentially what happens in the ipi is

00:09:58,000 --> 00:10:03,920
that you know when the remote cpu

00:10:00,640 --> 00:10:06,240
receives an ipi it executes uh or it

00:10:03,920 --> 00:10:08,640
will eventually execute and hire it

00:10:06,240 --> 00:10:10,640
to make sure that it synchronizes the

00:10:08,640 --> 00:10:15,440
pipeline system fetches the

00:10:10,640 --> 00:10:18,560
the recent the latest version of

00:10:15,440 --> 00:10:22,000
instructions written so

00:10:18,560 --> 00:10:24,160
ipis also takes pin locks

00:10:22,000 --> 00:10:26,079
so so yeah we need to be kind of

00:10:24,160 --> 00:10:30,240
prepared for it or handle it

00:10:26,079 --> 00:10:32,000
in some way all right now let's

00:10:30,240 --> 00:10:33,760
talk a little bit about the mechanism

00:10:32,000 --> 00:10:37,040
that we use for this

00:10:33,760 --> 00:10:40,000
so the mechanism is a fairly standard uh

00:10:37,040 --> 00:10:40,399
linux mechanism um which which we use

00:10:40,000 --> 00:10:42,880
for

00:10:40,399 --> 00:10:44,240
modifying cross modifying code uh

00:10:42,880 --> 00:10:47,839
there's a there's a typo

00:10:44,240 --> 00:10:47,839
in that in the second line

00:10:47,920 --> 00:10:54,320
uh the problem it solves is of

00:10:51,120 --> 00:10:54,959
patching while potentially executing

00:10:54,320 --> 00:10:58,480
code that

00:10:54,959 --> 00:11:01,279
is being patched and the the great thing

00:10:58,480 --> 00:11:02,640
about this is that it's a single byte

00:11:01,279 --> 00:11:06,000
instruction

00:11:02,640 --> 00:11:07,360
um so so

00:11:06,000 --> 00:11:12,640
so you know that you can always

00:11:07,360 --> 00:11:12,640
atomically both write it and execute it

00:11:12,839 --> 00:11:19,760
um and the the way you use it

00:11:16,160 --> 00:11:22,000
is by writing the replacing the first

00:11:19,760 --> 00:11:23,440
byte of the sequence that you are that

00:11:22,000 --> 00:11:26,959
you're modifying

00:11:23,440 --> 00:11:31,200
by you know this op code um

00:11:26,959 --> 00:11:33,440
it serves as a barrier to to to entry

00:11:31,200 --> 00:11:34,720
uh the the one thing that you do need

00:11:33,440 --> 00:11:37,839
for that is that

00:11:34,720 --> 00:11:39,680
uh this instruction sequence

00:11:37,839 --> 00:11:41,120
that that you are in the process of

00:11:39,680 --> 00:11:44,640
writing should have just one

00:11:41,120 --> 00:11:45,839
entry uh from you know it should only be

00:11:44,640 --> 00:11:48,399
entered from the first by

00:11:45,839 --> 00:11:51,120
from the from the first byte which you

00:11:48,399 --> 00:11:53,920
just replaced with 0xcc

00:11:51,120 --> 00:11:55,680
and you know if if this barrier gets hit

00:11:53,920 --> 00:11:59,200
uh the control flow shifts

00:11:55,680 --> 00:12:00,000
in three handler and in in 300 based on

00:11:59,200 --> 00:12:02,800
the

00:12:00,000 --> 00:12:03,920
on the address of uh where this was hit

00:12:02,800 --> 00:12:07,600
you know

00:12:03,920 --> 00:12:09,200
um you you know what

00:12:07,600 --> 00:12:11,279
what is the sequence that was supposed

00:12:09,200 --> 00:12:13,600
to be there or you know

00:12:11,279 --> 00:12:15,680
that you know that was a pv lock-up or

00:12:13,600 --> 00:12:19,519
or what have you so so you know

00:12:15,680 --> 00:12:24,320
what you should emulate now

00:12:19,519 --> 00:12:27,120
and and p-lock-ops

00:12:24,320 --> 00:12:28,079
they they start their life when the

00:12:27,120 --> 00:12:30,880
kernel boots

00:12:28,079 --> 00:12:31,279
as indirect calls so fundamentally you

00:12:30,880 --> 00:12:33,279
are

00:12:31,279 --> 00:12:35,040
really just just executing those

00:12:33,279 --> 00:12:36,079
indirect calls which are functionally

00:12:35,040 --> 00:12:39,519
equivalent

00:12:36,079 --> 00:12:42,880
to the to the op that were stored here

00:12:39,519 --> 00:12:46,320
all right uh now let's talk about what

00:12:42,880 --> 00:12:46,320
we actually do in v1

00:12:46,399 --> 00:12:50,240
so one way of sidestepping you know a

00:12:48,720 --> 00:12:52,880
lot of the difficulties i

00:12:50,240 --> 00:12:55,200
outlined earlier is basically to use

00:12:52,880 --> 00:12:57,920
stock machine

00:12:55,200 --> 00:12:58,480
um so how we use it is basically there's

00:12:57,920 --> 00:13:01,760
a

00:12:58,480 --> 00:13:04,720
patching cpu the cpu patcher and

00:13:01,760 --> 00:13:06,480
a bunch of you know secondary cpus all

00:13:04,720 --> 00:13:09,040
of them essentially work in a

00:13:06,480 --> 00:13:10,000
lock step state machine interrupts are

00:13:09,040 --> 00:13:13,040
disabled

00:13:10,000 --> 00:13:15,760
you don't need ipis for

00:13:13,040 --> 00:13:15,760
sync core

00:13:16,480 --> 00:13:22,639
and you also know that given that you

00:13:20,079 --> 00:13:26,240
are essentially hogging all the vcpus

00:13:22,639 --> 00:13:27,200
uh or all the cpus you know that no pv

00:13:26,240 --> 00:13:29,279
lock ops

00:13:27,200 --> 00:13:31,120
are on the stack because you know all

00:13:29,279 --> 00:13:34,160
other threads are scheduled out

00:13:31,120 --> 00:13:37,440
and you're not executing any pv lockups

00:13:34,160 --> 00:13:37,440
so it's a cowardly way of

00:13:38,160 --> 00:13:44,720
getting rid of a lot of the difficulties

00:13:41,440 --> 00:13:47,839
and the the only

00:13:44,720 --> 00:13:50,000
remaining risk is is

00:13:47,839 --> 00:13:51,120
and because you know nmis can come they

00:13:50,000 --> 00:13:55,600
can

00:13:51,120 --> 00:13:58,079
uh on on the primary or the secondary

00:13:55,600 --> 00:13:58,079
or both

00:13:59,839 --> 00:14:06,320
and you know the nmi handler

00:14:03,040 --> 00:14:09,440
can then you know execute a spin lock

00:14:06,320 --> 00:14:11,120
um this so that's been locked if you're

00:14:09,440 --> 00:14:14,320
modifying that particular site

00:14:11,120 --> 00:14:16,880
right then would end up going to the

00:14:14,320 --> 00:14:18,079
m3 handler and you know you could have a

00:14:16,880 --> 00:14:20,639
deadlock there

00:14:18,079 --> 00:14:21,920
so so to avoid that the entry handler

00:14:20,639 --> 00:14:24,000
also needs to implement

00:14:21,920 --> 00:14:25,360
a subset of the state machine it

00:14:24,000 --> 00:14:29,279
essentially

00:14:25,360 --> 00:14:30,880
uh because all cpus are participating in

00:14:29,279 --> 00:14:32,880
the state machine

00:14:30,880 --> 00:14:34,720
you have to kind of ensure that the

00:14:32,880 --> 00:14:38,000
state machine keeps moving

00:14:34,720 --> 00:14:39,440
and uh and and you know whichever

00:14:38,000 --> 00:14:40,560
context you are in whether in thread

00:14:39,440 --> 00:14:43,680
context

00:14:40,560 --> 00:14:46,480
or in three context and

00:14:43,680 --> 00:14:48,480
with that you can make forward progress

00:14:46,480 --> 00:14:50,399
um

00:14:48,480 --> 00:14:52,079
if you have multiple nmis that

00:14:50,399 --> 00:14:56,560
complicates matters somewhat

00:14:52,079 --> 00:14:56,560
but i won't go into that right now

00:14:56,959 --> 00:15:00,959
all right so this is kind of an example

00:14:59,519 --> 00:15:03,920
of um

00:15:00,959 --> 00:15:05,680
what the state machine really looks like

00:15:03,920 --> 00:15:08,800
normally you would you would use

00:15:05,680 --> 00:15:09,360
iprs to to do some of this here as you

00:15:08,800 --> 00:15:12,480
can see

00:15:09,360 --> 00:15:15,760
you know the cpu x essentially

00:15:12,480 --> 00:15:19,360
uh does uh has does

00:15:15,760 --> 00:15:21,839
smp con load uh with require semantics

00:15:19,360 --> 00:15:23,760
to you know progress to the next stage

00:15:21,839 --> 00:15:26,959
now what is each stage

00:15:23,760 --> 00:15:29,199
so uh the the commented out section

00:15:26,959 --> 00:15:31,120
actually goes through you know how the

00:15:29,199 --> 00:15:34,560
the op codes are really arranged

00:15:31,120 --> 00:15:37,600
so the first step is you you just patch

00:15:34,560 --> 00:15:39,680
the the end three

00:15:37,600 --> 00:15:41,759
that's that's what the patcher does it

00:15:39,680 --> 00:15:42,959
just replaces the first byte within

00:15:41,759 --> 00:15:46,079
three

00:15:42,959 --> 00:15:48,079
it does a local sync and it's

00:15:46,079 --> 00:15:49,199
you know changes some state with release

00:15:48,079 --> 00:15:53,360
semantics

00:15:49,199 --> 00:15:54,160
um and all the secondary cpus they

00:15:53,360 --> 00:15:56,240
basically do

00:15:54,160 --> 00:15:59,040
acquire for that state you know so the

00:15:56,240 --> 00:16:01,199
state will be saying three written

00:15:59,040 --> 00:16:03,680
uh once they see that you know

00:16:01,199 --> 00:16:07,519
essentially e3 has been written

00:16:03,680 --> 00:16:08,399
they do the sync then you know you can

00:16:07,519 --> 00:16:10,320
go and safely

00:16:08,399 --> 00:16:12,000
uh the patcher cpu can go and safely

00:16:10,320 --> 00:16:15,839
write the rest of

00:16:12,000 --> 00:16:17,600
the the state rest of the opcode bits

00:16:15,839 --> 00:16:19,839
and you know anybody trying to execute

00:16:17,600 --> 00:16:23,279
this would at this point in time

00:16:19,839 --> 00:16:26,160
end up in the in the in 300 right

00:16:23,279 --> 00:16:27,040
uh yeah so so you write the rest of the

00:16:26,160 --> 00:16:30,959
state

00:16:27,040 --> 00:16:35,199
um you make sure that that the patcher

00:16:30,959 --> 00:16:38,320
has written it on on the secondaries

00:16:35,199 --> 00:16:41,040
if it has you you do your sync

00:16:38,320 --> 00:16:43,279
and then all that remains is for the

00:16:41,040 --> 00:16:46,639
patching cpu to write the first byte

00:16:43,279 --> 00:16:48,480
which it does and your iteration is is

00:16:46,639 --> 00:16:51,680
complete

00:16:48,480 --> 00:16:54,560
it works the

00:16:51,680 --> 00:16:55,120
only problem is this is stock machine

00:16:54,560 --> 00:16:58,240
which

00:16:55,120 --> 00:17:01,440
kind of sucks and

00:16:58,240 --> 00:17:04,319
um you know when i send the stop stream

00:17:01,440 --> 00:17:07,039
there was a review comment which i think

00:17:04,319 --> 00:17:10,079
in in hindsight was pretty understated

00:17:07,039 --> 00:17:13,360
which called it bonkett's crazy code

00:17:10,079 --> 00:17:16,640
so so now v2

00:17:13,360 --> 00:17:20,640
so you want to patch multiple

00:17:16,640 --> 00:17:24,160
sites atomically right

00:17:20,640 --> 00:17:25,600
uh your other cpus could be executing

00:17:24,160 --> 00:17:28,959
arbitrary code

00:17:25,600 --> 00:17:28,959
including spin lock code

00:17:29,280 --> 00:17:33,679
uh and in any case you know patching

00:17:32,400 --> 00:17:36,000
even a single site

00:17:33,679 --> 00:17:36,880
is not atomic there are multiple steps

00:17:36,000 --> 00:17:41,039
and each step

00:17:36,880 --> 00:17:44,559
um even in itself can get interrupted

00:17:41,039 --> 00:17:44,559
by an nmi

00:17:45,760 --> 00:17:49,600
all right so so the first step is you

00:17:48,559 --> 00:17:55,120
first introduce

00:17:49,600 --> 00:17:55,120
a site local barrier everywhere

00:17:55,600 --> 00:18:01,679
and the

00:17:59,280 --> 00:18:03,039
what this allows you to do is it allows

00:18:01,679 --> 00:18:06,320
you to control

00:18:03,039 --> 00:18:08,559
what executes so until the site local

00:18:06,320 --> 00:18:11,600
barrier is everywhere

00:18:08,559 --> 00:18:12,400
um you know you just emulate the old

00:18:11,600 --> 00:18:15,840
code

00:18:12,400 --> 00:18:15,840
so one step one is done

00:18:16,720 --> 00:18:20,960
you need to introduce a global barrier

00:18:19,520 --> 00:18:22,960
um

00:18:20,960 --> 00:18:24,160
and the idea behind the global barrier

00:18:22,960 --> 00:18:27,760
is

00:18:24,160 --> 00:18:30,240
that before this barrier

00:18:27,760 --> 00:18:31,840
you are only going to be executing all

00:18:30,240 --> 00:18:34,960
pv lock-ups

00:18:31,840 --> 00:18:38,559
after this barrier you execute only new

00:18:34,960 --> 00:18:41,760
new orbs the

00:18:38,559 --> 00:18:45,440
the important condition for this barrier

00:18:41,760 --> 00:18:45,440
is that there should be no

00:18:46,400 --> 00:18:51,440
spin locks uh and and thus you know no

00:18:50,000 --> 00:18:54,880
executing pv lock ups

00:18:51,440 --> 00:18:55,679
in the system and and once you have

00:18:54,880 --> 00:18:58,960
transitioned

00:18:55,679 --> 00:19:00,880
you know to the the new pve lock ops

00:18:58,960 --> 00:19:02,000
you're kind of done all you need to do

00:19:00,880 --> 00:19:05,280
is you need to

00:19:02,000 --> 00:19:07,919
stop emulating so you go back and and

00:19:05,280 --> 00:19:09,120
uh replace the entry that you that you

00:19:07,919 --> 00:19:11,840
prefixed with the

00:19:09,120 --> 00:19:11,840
the real opcode

00:19:13,760 --> 00:19:19,679
okay so so you know most of the

00:19:16,960 --> 00:19:20,400
the work is really in the in the global

00:19:19,679 --> 00:19:22,320
barrier

00:19:20,400 --> 00:19:24,960
how do we actually get a global barrier

00:19:22,320 --> 00:19:26,240
when you have multiple vcpus

00:19:24,960 --> 00:19:28,160
fundamentally what you need to do is you

00:19:26,240 --> 00:19:30,080
need to count all spin locks under

00:19:28,160 --> 00:19:32,559
execution

00:19:30,080 --> 00:19:34,320
and uh the counting needs to happen in

00:19:32,559 --> 00:19:34,640
the in three handler which is good you

00:19:34,320 --> 00:19:37,120
know

00:19:34,640 --> 00:19:38,559
a single point where everything kind of

00:19:37,120 --> 00:19:41,919
converges

00:19:38,559 --> 00:19:42,720
uh of course there is no real way of

00:19:41,919 --> 00:19:45,840
counting

00:19:42,720 --> 00:19:50,160
spin locks uh good spin lock is

00:19:45,840 --> 00:19:51,760
is not a pv lock op so so

00:19:50,160 --> 00:19:53,360
so you don't even know where where all

00:19:51,760 --> 00:19:55,919
of them are in the

00:19:53,360 --> 00:19:57,440
in the kernel or in the modules all that

00:19:55,919 --> 00:20:00,720
you have

00:19:57,440 --> 00:20:03,200
uh uh is what you can get via the

00:20:00,720 --> 00:20:04,400
in three handler which is the rest of

00:20:03,200 --> 00:20:07,600
the five op codes

00:20:04,400 --> 00:20:11,600
not uh cute spin lock

00:20:07,600 --> 00:20:12,559
um what's the property that this global

00:20:11,600 --> 00:20:16,960
barrier

00:20:12,559 --> 00:20:19,200
uh holds essentially

00:20:16,960 --> 00:20:20,559
so so the barrier itself is is you know

00:20:19,200 --> 00:20:23,760
pretty simple

00:20:20,559 --> 00:20:26,480
um you either via rcu

00:20:23,760 --> 00:20:27,679
or or above queue or something that you

00:20:26,480 --> 00:20:32,000
essentially execute

00:20:27,679 --> 00:20:34,880
this patch barrier on all cpus

00:20:32,000 --> 00:20:36,799
except for the worker let's say this is

00:20:34,880 --> 00:20:38,240
in the queue context so at this point

00:20:36,799 --> 00:20:40,080
you know

00:20:38,240 --> 00:20:42,000
when you're executing this barrier you

00:20:40,080 --> 00:20:45,440
know that you're not

00:20:42,000 --> 00:20:46,559
you don't actually have any locks uh on

00:20:45,440 --> 00:20:50,720
that cpu you

00:20:46,559 --> 00:20:55,039
there are no spin locks in that context

00:20:50,720 --> 00:20:58,559
on that cpu so at that point in time

00:20:55,039 --> 00:20:59,440
you can switch that cpu to a state where

00:20:58,559 --> 00:21:03,280
it says you know

00:20:59,440 --> 00:21:06,480
barrier executed right

00:21:03,280 --> 00:21:10,799
um and then you can essentially

00:21:06,480 --> 00:21:14,799
act that yeah this the cpu has executed

00:21:10,799 --> 00:21:18,400
the barrier and that from this point on

00:21:14,799 --> 00:21:20,000
the cpu needs to count uh active lock

00:21:18,400 --> 00:21:24,320
ops

00:21:20,000 --> 00:21:27,440
active lock ops then it falls to zero

00:21:24,320 --> 00:21:31,760
um means that

00:21:27,440 --> 00:21:34,559
there are no

00:21:31,760 --> 00:21:35,840
ongoing spin locks let's say or pv lock

00:21:34,559 --> 00:21:38,880
ops really

00:21:35,840 --> 00:21:39,440
in the system and at that point it's

00:21:38,880 --> 00:21:40,799
safe to

00:21:39,440 --> 00:21:43,280
switch so that's the property in the

00:21:40,799 --> 00:21:47,679
next line all cpus

00:21:43,280 --> 00:21:51,039
have uh have executed this barrier

00:21:47,679 --> 00:21:54,480
and no active lock cops in the system

00:21:51,039 --> 00:21:57,600
um so if the first line is

00:21:54,480 --> 00:22:00,640
uh the first clause is untrue uh

00:21:57,600 --> 00:22:03,840
barrier cpus is less than uh

00:22:00,640 --> 00:22:07,200
num online cpus

00:22:03,840 --> 00:22:10,080
then you could have active lock ups on

00:22:07,200 --> 00:22:10,080
you know uh

00:22:10,880 --> 00:22:17,280
on on some on on a bunch of cpus

00:22:14,159 --> 00:22:18,080
but some of them are actually counting

00:22:17,280 --> 00:22:21,360
these

00:22:18,080 --> 00:22:24,320
active lock-ups some are not

00:22:21,360 --> 00:22:24,720
but once this condition is true you know

00:22:24,320 --> 00:22:27,840
that

00:22:24,720 --> 00:22:30,880
all active lock-ups in the system are

00:22:27,840 --> 00:22:30,880
actually getting counted

00:22:31,440 --> 00:22:34,799
and and then you know there are there

00:22:34,240 --> 00:22:37,120
are

00:22:34,799 --> 00:22:39,280
issues here you know spinlock is a

00:22:37,120 --> 00:22:43,039
really hot path

00:22:39,280 --> 00:22:44,960
and uh and and so you might have to wait

00:22:43,039 --> 00:22:48,080
for a long time for this condition to be

00:22:44,960 --> 00:22:49,760
to be true um and until then you know

00:22:48,080 --> 00:22:52,159
you would kind of slow down the system

00:22:49,760 --> 00:22:54,559
but if the load is too high you can just

00:22:52,159 --> 00:22:57,840
abort and you can do things like that

00:22:54,559 --> 00:23:00,880
but um but but this condition is

00:22:57,840 --> 00:23:03,679
is um sufficient to

00:23:00,880 --> 00:23:05,039
transition to this new stage a little

00:23:03,679 --> 00:23:06,840
more on

00:23:05,039 --> 00:23:09,840
what we are counting and how we are

00:23:06,840 --> 00:23:09,840
counting

00:23:10,480 --> 00:23:14,159
so first of all notice what we cannot

00:23:12,799 --> 00:23:17,600
count we cannot

00:23:14,159 --> 00:23:20,799
count the fast path

00:23:17,600 --> 00:23:23,679
the we have

00:23:20,799 --> 00:23:24,799
no control over cued spin lock uh that

00:23:23,679 --> 00:23:27,760
does not go through the

00:23:24,799 --> 00:23:29,520
break point handler so we cannot count

00:23:27,760 --> 00:23:31,280
invocations of the fast path so there

00:23:29,520 --> 00:23:32,880
can be spin locks executing in the

00:23:31,280 --> 00:23:36,640
system

00:23:32,880 --> 00:23:41,520
uh you know you would only see them

00:23:36,640 --> 00:23:45,279
when uh they call cued spin unlock

00:23:41,520 --> 00:23:48,640
what you can count is the slow path

00:23:45,279 --> 00:23:51,360
and the great thing is that

00:23:48,640 --> 00:23:52,080
the slow path also protects the data

00:23:51,360 --> 00:23:54,400
structure

00:23:52,080 --> 00:23:55,440
because the data structure only gets

00:23:54,400 --> 00:23:58,400
accessed

00:23:55,440 --> 00:23:58,400
in the slow path

00:23:59,039 --> 00:24:06,080
or it might get accessed in the

00:24:02,240 --> 00:24:09,600
unlock if a different cpu has

00:24:06,080 --> 00:24:13,039
gone through the slow path for the same

00:24:09,600 --> 00:24:14,960
spin lock you only really need

00:24:13,039 --> 00:24:16,400
to be able to tell the difference

00:24:14,960 --> 00:24:19,440
between the two

00:24:16,400 --> 00:24:22,480
queued spin unlocks because you know

00:24:19,440 --> 00:24:23,520
one got one gets executed in the fast

00:24:22,480 --> 00:24:26,320
path

00:24:23,520 --> 00:24:29,039
um so you know you should not be

00:24:26,320 --> 00:24:31,919
dropping a reference there

00:24:29,039 --> 00:24:33,440
but you you take a reference in queued

00:24:31,919 --> 00:24:34,720
spin lock slow path

00:24:33,440 --> 00:24:37,520
which you should be dropping in the

00:24:34,720 --> 00:24:40,480
corresponding queue it's been unlocked

00:24:37,520 --> 00:24:41,760
um the the one part of data structure

00:24:40,480 --> 00:24:44,159
that gets

00:24:41,760 --> 00:24:46,559
accessed is the bit representation which

00:24:44,159 --> 00:24:49,279
marks whether this lock is taken or not

00:24:46,559 --> 00:24:50,000
and that is constrained to be compatible

00:24:49,279 --> 00:24:52,960
for

00:24:50,000 --> 00:24:54,000
both of the spin lock types because

00:24:52,960 --> 00:24:57,200
keyword spin lock

00:24:54,000 --> 00:24:58,400
is com is the same for you know both of

00:24:57,200 --> 00:25:01,440
the spin lock types

00:24:58,400 --> 00:25:04,320
so cued spin unlock has no choice but to

00:25:01,440 --> 00:25:07,760
use the same bridge representation

00:25:04,320 --> 00:25:10,640
and so the only remaining problem

00:25:07,760 --> 00:25:11,279
is uh being able to tell the cued spin

00:25:10,640 --> 00:25:13,760
unlocks

00:25:11,279 --> 00:25:15,440
part in in you know both of these cases

00:25:13,760 --> 00:25:18,080
and that you do by just keeping you know

00:25:15,440 --> 00:25:21,039
some sort of a perceived map

00:25:18,080 --> 00:25:22,480
and um and that's all there should be to

00:25:21,039 --> 00:25:25,760
to v2

00:25:22,480 --> 00:25:29,919
you can find the code here on github

00:25:25,760 --> 00:25:33,200
v2 is mostly design documents

00:25:29,919 --> 00:25:33,919
v1 you you can get the code on github

00:25:33,200 --> 00:25:37,200
and

00:25:33,919 --> 00:25:40,840
the patches on lkml

00:25:37,200 --> 00:25:43,520
and thanks for attending the talk

00:25:40,840 --> 00:25:44,400
um if you have any questions i'll take

00:25:43,520 --> 00:25:48,080
them

00:25:44,400 --> 00:25:48,720
if not um i'm happy to receive them on

00:25:48,080 --> 00:25:51,679
email

00:25:48,720 --> 00:25:53,120
or if you want to collaborate just drop

00:25:51,679 --> 00:25:57,840
me an email

00:25:53,120 --> 00:25:57,840

YouTube URL: https://www.youtube.com/watch?v=7R_s2snGlXo


