Title: Long Live Asynchronous Page Fault! - Vitaly Kuznetsov & Vivek Goyal, Red Hat
Publication date: 2020-11-12
Playlist: KVM Forum Europe 2020
Description: 
	Long Live Asynchronous Page Fault! - Vitaly Kuznetsov & Vivek Goyal, Red Hat
Captions: 
	00:00:05,120 --> 00:00:07,600
hello

00:00:05,600 --> 00:00:08,800
uh welcome to our session which is

00:00:07,600 --> 00:00:12,639
called uh long live

00:00:08,800 --> 00:00:13,120
asynchronous page fault a few words

00:00:12,639 --> 00:00:15,440
about

00:00:13,120 --> 00:00:16,320
us uh we are both from red hat my name

00:00:15,440 --> 00:00:19,520
is vitaly

00:00:16,320 --> 00:00:22,160
and i'm a kvm contributor i mostly work

00:00:19,520 --> 00:00:23,199
on pv features in kvm on hyper-v

00:00:22,160 --> 00:00:26,400
emulation

00:00:23,199 --> 00:00:30,240
windows guest support and nesting

00:00:26,400 --> 00:00:32,719
we're back hello everyone i'm vivek uh

00:00:30,240 --> 00:00:33,760
i'm a kernel developer i primarily work

00:00:32,719 --> 00:00:36,559
at red hat in

00:00:33,760 --> 00:00:37,680
storage and file system team uh right

00:00:36,559 --> 00:00:40,239
now working on

00:00:37,680 --> 00:00:41,520
what ifs have contributed to overlay fs

00:00:40,239 --> 00:00:45,840
kxf kdm

00:00:41,520 --> 00:00:45,840
block c group controllers etc

00:00:46,079 --> 00:00:52,480
back to you widely yeah so uh what event

00:00:49,600 --> 00:00:54,079
are we gonna talk about today imagine

00:00:52,480 --> 00:00:56,480
the following situation

00:00:54,079 --> 00:00:58,399
you have a guest running on kvue and

00:00:56,480 --> 00:00:59,440
there is a memory access happening in

00:00:58,399 --> 00:01:01,120
the guest

00:00:59,440 --> 00:01:03,199
and from the guest perspective this

00:01:01,120 --> 00:01:06,400
memory is available

00:01:03,199 --> 00:01:08,479
but on the host at the same time

00:01:06,400 --> 00:01:09,439
it is not present for example because

00:01:08,479 --> 00:01:12,640
the page was

00:01:09,439 --> 00:01:14,720
swapped out so what's going to happen in

00:01:12,640 --> 00:01:18,159
this situation

00:01:14,720 --> 00:01:21,920
well under normal circumstances

00:01:18,159 --> 00:01:25,840
uh kbm will have to block guests vcpu

00:01:21,920 --> 00:01:27,840
and then handle the page hold condition

00:01:25,840 --> 00:01:29,040
for example bring the page back from

00:01:27,840 --> 00:01:32,000
swap

00:01:29,040 --> 00:01:33,280
and when it's done it can resume just

00:01:32,000 --> 00:01:36,720
the cpu

00:01:33,280 --> 00:01:37,840
so it doesn't see that anything happened

00:01:36,720 --> 00:01:41,119
at this time

00:01:37,840 --> 00:01:44,960
but resolving the condition may actually

00:01:41,119 --> 00:01:48,399
take time because it involves a storage

00:01:44,960 --> 00:01:51,520
and at the same time your physical cpu

00:01:48,399 --> 00:01:53,280
may actually be idle because for example

00:01:51,520 --> 00:01:56,000
you have nothing else to run

00:01:53,280 --> 00:01:56,560
on this physical cpu if you for example

00:01:56,000 --> 00:02:00,799
use

00:01:56,560 --> 00:02:00,799
the cpu pinion for your guests

00:02:00,960 --> 00:02:08,800
so uh what can be done

00:02:04,560 --> 00:02:11,760
kvm are uses to ideas

00:02:08,800 --> 00:02:12,959
first idea requires the guest to

00:02:11,760 --> 00:02:16,319
collaborate

00:02:12,959 --> 00:02:19,200
and we let the guest know that

00:02:16,319 --> 00:02:20,879
the page it just tried to access is

00:02:19,200 --> 00:02:23,680
missing on the host

00:02:20,879 --> 00:02:25,760
but we are not blocking it so it can

00:02:23,680 --> 00:02:29,040
actually switch to some other process

00:02:25,760 --> 00:02:32,239
and do some other work while the page is

00:02:29,040 --> 00:02:35,040
brought back from swap the other idea

00:02:32,239 --> 00:02:36,560
doesn't require the guest to collaborate

00:02:35,040 --> 00:02:40,080
and the idea is called

00:02:36,560 --> 00:02:43,440
a synthetic apf hub and it's

00:02:40,080 --> 00:02:44,720
uh the same as emulating a healthy

00:02:43,440 --> 00:02:47,120
instruction

00:02:44,720 --> 00:02:49,599
which guest actually didn't execute but

00:02:47,120 --> 00:02:51,200
we pretended the guest executed it

00:02:49,599 --> 00:02:52,959
the difference between these and

00:02:51,200 --> 00:02:56,239
blocking every cpu

00:02:52,959 --> 00:02:57,519
is that uh when we do the synthetic ap

00:02:56,239 --> 00:03:00,800
of halt

00:02:57,519 --> 00:03:02,319
we keep interrupts enabled so we hope

00:03:00,800 --> 00:03:03,519
that there is going to be a scheduling

00:03:02,319 --> 00:03:05,280
interrupt in the guest

00:03:03,519 --> 00:03:06,720
and the guest will automatically switch

00:03:05,280 --> 00:03:08,959
to some other process

00:03:06,720 --> 00:03:10,400
and at the same time the memory which

00:03:08,959 --> 00:03:12,159
wasn't available before

00:03:10,400 --> 00:03:14,560
may actually become available so when it

00:03:12,159 --> 00:03:18,319
switches back to the task

00:03:14,560 --> 00:03:21,200
it may run normally

00:03:18,319 --> 00:03:22,959
uh so um today we are mostly gonna talk

00:03:21,200 --> 00:03:26,080
about the first idea which is called

00:03:22,959 --> 00:03:29,280
asynchronous page fault initially it was

00:03:26,080 --> 00:03:32,480
implemented in 2010.

00:03:29,280 --> 00:03:35,519
the main concept is that there are two

00:03:32,480 --> 00:03:37,760
events the first event is called

00:03:35,519 --> 00:03:39,920
page note present and the other is

00:03:37,760 --> 00:03:43,360
called page read

00:03:39,920 --> 00:03:47,280
to deliver these events to the guest a

00:03:43,360 --> 00:03:51,920
page fault exception is being used

00:03:47,280 --> 00:03:54,080
with a page with every page which was

00:03:51,920 --> 00:03:55,840
not available there is a token

00:03:54,080 --> 00:03:58,959
associated and this token

00:03:55,840 --> 00:04:01,680
gets passed through cr2 register

00:03:58,959 --> 00:04:02,560
also there is a shared memory structure

00:04:01,680 --> 00:04:05,280
so called like

00:04:02,560 --> 00:04:06,000
asynchronous page fault reason which

00:04:05,280 --> 00:04:08,319
indicates

00:04:06,000 --> 00:04:09,200
that the page fault which has been

00:04:08,319 --> 00:04:11,760
injected

00:04:09,200 --> 00:04:13,120
is an asynchronous page fault and not a

00:04:11,760 --> 00:04:15,599
normal page fault

00:04:13,120 --> 00:04:16,799
and it also tells us which event has

00:04:15,599 --> 00:04:19,600
been delivered to us

00:04:16,799 --> 00:04:22,160
is it a page not present event or a page

00:04:19,600 --> 00:04:22,160
ready

00:04:22,400 --> 00:04:26,160
so how does it all work

00:04:26,240 --> 00:04:30,080
imagine there is a user paid task and

00:04:28,400 --> 00:04:30,639
it's trying to access some memory which

00:04:30,080 --> 00:04:34,160
is not

00:04:30,639 --> 00:04:37,199
available on the host so kbm

00:04:34,160 --> 00:04:39,520
injects this asynchronous page fault

00:04:37,199 --> 00:04:40,639
page not present event which has been

00:04:39,520 --> 00:04:44,080
injected as

00:04:40,639 --> 00:04:46,240
a page fault exception

00:04:44,080 --> 00:04:48,000
we get into this page fault handler in

00:04:46,240 --> 00:04:50,080
the guest kernel

00:04:48,000 --> 00:04:51,600
and the guest kernel analyzes this

00:04:50,080 --> 00:04:54,240
shared memory structure

00:04:51,600 --> 00:04:55,840
it sees that the event is actually an

00:04:54,240 --> 00:04:58,240
asynchronous page fault

00:04:55,840 --> 00:04:59,199
even and not a normal page fault it

00:04:58,240 --> 00:05:02,160
freezes

00:04:59,199 --> 00:05:02,880
the task which tried the access along

00:05:02,160 --> 00:05:06,240
with

00:05:02,880 --> 00:05:08,240
the token and switches to some other

00:05:06,240 --> 00:05:12,160
tasks which hopefully won't

00:05:08,240 --> 00:05:15,440
won't call any faults

00:05:12,160 --> 00:05:19,280
so what happens when uh

00:05:15,440 --> 00:05:22,080
this page becomes available kvm

00:05:19,280 --> 00:05:23,280
again injects a page fault even to the

00:05:22,080 --> 00:05:26,560
guest

00:05:23,280 --> 00:05:28,880
and we get in the same

00:05:26,560 --> 00:05:31,280
page called handler in the guest kernel

00:05:28,880 --> 00:05:32,160
it reads the shared memory and now it

00:05:31,280 --> 00:05:33,759
sees that

00:05:32,160 --> 00:05:35,600
the event which has been delivered is a

00:05:33,759 --> 00:05:38,880
page ready event

00:05:35,600 --> 00:05:40,400
it searches for the token in its

00:05:38,880 --> 00:05:42,880
internal structures

00:05:40,400 --> 00:05:44,160
gets the task which got previously

00:05:42,880 --> 00:05:47,440
blocked

00:05:44,160 --> 00:05:50,479
it unblocks it so this task can now

00:05:47,440 --> 00:05:53,840
continue so

00:05:50,479 --> 00:05:57,520
uh a couple of extensions were

00:05:53,840 --> 00:06:01,039
developed to these first is called

00:05:57,520 --> 00:06:01,360
a stand always mode and the idea behind

00:06:01,039 --> 00:06:05,440
it

00:06:01,360 --> 00:06:08,400
is that we can not only

00:06:05,440 --> 00:06:08,880
deliver asynchronous page fault events

00:06:08,400 --> 00:06:11,919
to

00:06:08,880 --> 00:06:15,360
uh user space memory access

00:06:11,919 --> 00:06:18,400
but also to kernel memory access when uh

00:06:15,360 --> 00:06:22,000
the kernel itself is preemptable

00:06:18,400 --> 00:06:25,039
and can handle this another exception

00:06:22,000 --> 00:06:27,600
extension is uh

00:06:25,039 --> 00:06:28,319
needed when you want to run nested

00:06:27,600 --> 00:06:31,680
guests

00:06:28,319 --> 00:06:32,080
uh in case uh this asynchronous page

00:06:31,680 --> 00:06:35,680
fault

00:06:32,080 --> 00:06:38,319
event is happening for an access uh

00:06:35,680 --> 00:06:40,720
while your cpu is actually in guest mode

00:06:38,319 --> 00:06:43,919
your guest cpu is in guest mode

00:06:40,720 --> 00:06:45,919
uh we cannot just inject a page full

00:06:43,919 --> 00:06:47,759
even because it will get into

00:06:45,919 --> 00:06:50,080
your nested guest which you may not be

00:06:47,759 --> 00:06:53,360
prepared to handle this event

00:06:50,080 --> 00:06:56,479
so we inject it as a pf

00:06:53,360 --> 00:06:58,720
pm exit and the

00:06:56,479 --> 00:07:00,400
level one hypervisor your guest should

00:06:58,720 --> 00:07:02,479
be prepared to handle it

00:07:00,400 --> 00:07:04,000
so it does exactly the same as it would

00:07:02,479 --> 00:07:07,440
do for a

00:07:04,000 --> 00:07:10,800
pf exception so

00:07:07,440 --> 00:07:13,840
uh it all kind of worked for

00:07:10,800 --> 00:07:18,000
10 years since 2010 before people

00:07:13,840 --> 00:07:21,759
actually started looking at it closer

00:07:18,000 --> 00:07:24,639
and the main assumption which

00:07:21,759 --> 00:07:25,360
was well documented when this was

00:07:24,639 --> 00:07:28,720
implemented

00:07:25,360 --> 00:07:31,759
is that the guest

00:07:28,720 --> 00:07:32,720
should actually read or the shared

00:07:31,759 --> 00:07:36,400
memory structure

00:07:32,720 --> 00:07:39,120
answer to register before any other

00:07:36,400 --> 00:07:40,160
page fault even any other like real page

00:07:39,120 --> 00:07:43,280
fault

00:07:40,160 --> 00:07:44,240
can happen and uh this should be

00:07:43,280 --> 00:07:48,800
guaranteed but

00:07:44,240 --> 00:07:52,479
can it actually be guaranteed uh

00:07:48,800 --> 00:07:55,680
there was a faulty scenario presented by

00:07:52,479 --> 00:07:58,879
angela tomerski last year and

00:07:55,680 --> 00:08:01,759
uh the scenario is the following imagine

00:07:58,879 --> 00:08:03,520
are we are injecting an asynchronous

00:08:01,759 --> 00:08:06,639
page fault event

00:08:03,520 --> 00:08:10,000
and before we managed to

00:08:06,639 --> 00:08:11,440
read the cr2 and the apf reason from the

00:08:10,000 --> 00:08:14,720
shared memory structure

00:08:11,440 --> 00:08:18,240
an nmi happens it is known that in

00:08:14,720 --> 00:08:22,240
linux kernel nmi handlers can

00:08:18,240 --> 00:08:25,919
cause accesses to user space memory

00:08:22,240 --> 00:08:29,039
as these in its turn can cause uh

00:08:25,919 --> 00:08:31,280
real page fault events

00:08:29,039 --> 00:08:32,159
so what's gonna happen if this when this

00:08:31,280 --> 00:08:34,719
happens

00:08:32,159 --> 00:08:35,919
well uh the cr2 register will definitely

00:08:34,719 --> 00:08:39,360
get clobbered

00:08:35,919 --> 00:08:40,000
because real page fault will overwrite

00:08:39,360 --> 00:08:42,560
it

00:08:40,000 --> 00:08:43,760
and when we get back to the synchronous

00:08:42,560 --> 00:08:47,600
page fault

00:08:43,760 --> 00:08:49,680
handler we won't be able to handle this

00:08:47,600 --> 00:08:53,040
as internal space fault event

00:08:49,680 --> 00:08:54,959
so what's going to happen well nothing

00:08:53,040 --> 00:08:58,800
good

00:08:54,959 --> 00:09:01,040
so we started working on it and

00:08:58,800 --> 00:09:02,240
it's currently work in progress but some

00:09:01,040 --> 00:09:07,040
things were

00:09:02,240 --> 00:09:10,080
already been done in the last year

00:09:07,040 --> 00:09:14,240
so first uh it was decided that

00:09:10,080 --> 00:09:18,000
send always mode for uh

00:09:14,240 --> 00:09:22,000
asynchronous page fault is

00:09:18,000 --> 00:09:25,120
not really robust enough and

00:09:22,000 --> 00:09:28,160
also no existing

00:09:25,120 --> 00:09:31,200
well-known linux distribution builds

00:09:28,160 --> 00:09:32,000
fully preemptable kernel so the send

00:09:31,200 --> 00:09:35,680
always mode

00:09:32,000 --> 00:09:39,279
was deeper key second

00:09:35,680 --> 00:09:42,640
we decided that the main problem is that

00:09:39,279 --> 00:09:43,440
uh the same page fault exception which

00:09:42,640 --> 00:09:45,760
has been used for

00:09:43,440 --> 00:09:47,600
normal page fault is being used for

00:09:45,760 --> 00:09:50,800
asynchronous page fault

00:09:47,600 --> 00:09:54,640
so we decided that it's not really

00:09:50,800 --> 00:09:56,640
a good idea and as a first step we

00:09:54,640 --> 00:09:58,000
switched from using this page fault

00:09:56,640 --> 00:10:01,040
exception to

00:09:58,000 --> 00:10:04,000
using normal interrupts

00:10:01,040 --> 00:10:04,880
to just to deliver page ready events

00:10:04,000 --> 00:10:08,640
because these

00:10:04,880 --> 00:10:11,680
events are by design asynchronous

00:10:08,640 --> 00:10:12,079
and helium fully switched to this mode

00:10:11,680 --> 00:10:15,120
in

00:10:12,079 --> 00:10:17,519
linux 5.8 and kvm guest fully switched

00:10:15,120 --> 00:10:20,959
to this mode in linux 5.9

00:10:17,519 --> 00:10:23,200
so now uh the old way to deliver

00:10:20,959 --> 00:10:24,640
page ready events is not supported

00:10:23,200 --> 00:10:28,320
anymore neither by

00:10:24,640 --> 00:10:31,040
kvm no by linux guest

00:10:28,320 --> 00:10:32,000
uh we also have plans to do something

00:10:31,040 --> 00:10:34,560
about

00:10:32,000 --> 00:10:35,600
page not present events switch them for

00:10:34,560 --> 00:10:38,640
example to

00:10:35,600 --> 00:10:41,680
virtualization exception or

00:10:38,640 --> 00:10:44,800
change exception but there are

00:10:41,680 --> 00:10:46,480
kind of disadvantages uh

00:10:44,800 --> 00:10:48,160
both of them have some disadvantages

00:10:46,480 --> 00:10:52,079
like virtualization exception

00:10:48,160 --> 00:10:55,760
is only available on intel uh

00:10:52,079 --> 00:10:59,440
there are also ideas to use an interrupt

00:10:55,760 --> 00:11:00,000
deliver or page not ready exception but

00:10:59,440 --> 00:11:02,640
in this case

00:11:00,000 --> 00:11:04,560
we must be sure that it gets the higher

00:11:02,640 --> 00:11:08,160
priority and nothing else will

00:11:04,560 --> 00:11:13,839
get handled before it

00:11:08,160 --> 00:11:16,240
so uh about this interrupt

00:11:13,839 --> 00:11:17,680
using interrupt for delivering uh

00:11:16,240 --> 00:11:21,360
asynchronous page fault

00:11:17,680 --> 00:11:24,079
page ready events how does it work now

00:11:21,360 --> 00:11:24,640
so again the task was previously frozen

00:11:24,079 --> 00:11:26,480
uh

00:11:24,640 --> 00:11:28,399
because it tried to access some memory

00:11:26,480 --> 00:11:31,279
which is not available on the host

00:11:28,399 --> 00:11:33,120
and this memory becomes available so

00:11:31,279 --> 00:11:36,640
instead of injecting

00:11:33,120 --> 00:11:40,240
page fault exception kvm now injects

00:11:36,640 --> 00:11:43,120
an interrupt a normal epic interrupt

00:11:40,240 --> 00:11:43,760
to the guest we get into an interrupt

00:11:43,120 --> 00:11:48,720
handler

00:11:43,760 --> 00:11:48,720
in guest kernel eventually and

00:11:48,800 --> 00:11:52,079
guest kernel does the same it touches

00:11:51,200 --> 00:11:55,200
through

00:11:52,079 --> 00:11:56,959
internal structures searching for

00:11:55,200 --> 00:11:58,959
the task which was probably previously

00:11:56,959 --> 00:12:01,920
frozen with uh

00:11:58,959 --> 00:12:03,519
this token it finds it and unblocks it

00:12:01,920 --> 00:12:06,880
so this task can now

00:12:03,519 --> 00:12:08,800
run and also we've introduced an

00:12:06,880 --> 00:12:12,000
acknowledgement mechanism

00:12:08,800 --> 00:12:14,959
by which gust kernel tells kvm that it

00:12:12,000 --> 00:12:17,120
completed processing this asynchronous

00:12:14,959 --> 00:12:18,000
page fault event so the next one can get

00:12:17,120 --> 00:12:20,880
delivered

00:12:18,000 --> 00:12:23,360
either like immediately or in the

00:12:20,880 --> 00:12:23,360
meantime

00:12:23,600 --> 00:12:30,480
so uh that was it and now

00:12:27,279 --> 00:12:33,760
uh rebecca is gonna talk more about

00:12:30,480 --> 00:12:36,160
our new usages for asynchronous page

00:12:33,760 --> 00:12:36,160
fault

00:12:37,519 --> 00:12:46,560
okay so kvm pays fault error handling

00:12:42,160 --> 00:12:48,320
so like uh one question is like

00:12:46,560 --> 00:12:49,920
yeah of course we all talked about page

00:12:48,320 --> 00:12:51,519
faults happen we can deliver them in

00:12:49,920 --> 00:12:52,000
synchronous manner or asynchronous

00:12:51,519 --> 00:12:53,920
manner

00:12:52,000 --> 00:12:55,360
now the question is what happens we

00:12:53,920 --> 00:12:57,120
cannot resolve the pace for

00:12:55,360 --> 00:12:59,600
what's of behavior currently and how

00:12:57,120 --> 00:13:02,320
that behavior can be improved

00:12:59,600 --> 00:13:03,440
uh before we dive into it like i just

00:13:02,320 --> 00:13:05,839
want to address

00:13:03,440 --> 00:13:08,720
what exactly can that happen or at least

00:13:05,839 --> 00:13:10,639
where i ran into the issues

00:13:08,720 --> 00:13:13,040
uh personally i ran into the issues when

00:13:10,639 --> 00:13:17,040
i was running what ifs

00:13:13,040 --> 00:13:19,120
with dax enabled and that's where

00:13:17,040 --> 00:13:20,399
i started running a bunch of other

00:13:19,120 --> 00:13:22,320
issues

00:13:20,399 --> 00:13:23,920
before i go further like i just want to

00:13:22,320 --> 00:13:27,040
quickly uh

00:13:23,920 --> 00:13:30,240
mention what what ifs is it's fairly new

00:13:27,040 --> 00:13:31,680
and in case you have not seen it yet uh

00:13:30,240 --> 00:13:34,800
it's a pass through file system

00:13:31,680 --> 00:13:38,560
something along the lines of whatever 9p

00:13:34,800 --> 00:13:41,199
just that it's fuse based it allows

00:13:38,560 --> 00:13:44,560
to take one directory on the host and

00:13:41,199 --> 00:13:44,560
just export into the guest

00:13:45,440 --> 00:13:48,959
in this in this diagram the shared

00:13:47,600 --> 00:13:51,760
directory is

00:13:48,959 --> 00:13:52,800
let's say slash 4 which is being shared

00:13:51,760 --> 00:13:54,639
what ifst

00:13:52,800 --> 00:13:55,920
here is the daemon running on the host

00:13:54,639 --> 00:13:58,480
which is the

00:13:55,920 --> 00:14:00,160
file server and uses the v-host user

00:13:58,480 --> 00:14:03,839
protocol to communicate

00:14:00,160 --> 00:14:03,839
with the guest

00:14:03,920 --> 00:14:08,079
and recently we added deck support

00:14:06,880 --> 00:14:11,760
toward iofas

00:14:08,079 --> 00:14:14,000
this is still in the use next tree

00:14:11,760 --> 00:14:16,240
and we are hoping that it will be merged

00:14:14,000 --> 00:14:19,440
in this small cycle which is opening

00:14:16,240 --> 00:14:21,279
probably soon uh what does this do is

00:14:19,440 --> 00:14:23,199
like typically if you're accessing a

00:14:21,279 --> 00:14:26,560
file let's say food or text

00:14:23,199 --> 00:14:28,000
uh you you create another copy

00:14:26,560 --> 00:14:30,079
of the contents of the food or tax

00:14:28,000 --> 00:14:32,639
whenever somebody is reading the file

00:14:30,079 --> 00:14:34,399
we take it from the host create a copy

00:14:32,639 --> 00:14:35,040
in the guest based cache and that's how

00:14:34,399 --> 00:14:37,839
the

00:14:35,040 --> 00:14:39,279
guest process access the contents but

00:14:37,839 --> 00:14:42,639
with the dax

00:14:39,279 --> 00:14:46,320
we wanted guest process to be able to

00:14:42,639 --> 00:14:48,480
directly map host space cache and bypass

00:14:46,320 --> 00:14:50,639
the gas based cache completely

00:14:48,480 --> 00:14:53,680
and this probably has two advantages

00:14:50,639 --> 00:14:56,720
that it reduces our memory footprint

00:14:53,680 --> 00:15:00,399
on top of that it probably

00:14:56,720 --> 00:15:01,920
is a faster access and it just allows a

00:15:00,399 --> 00:15:03,519
better sharing also

00:15:01,920 --> 00:15:07,040
down the line at least because there is

00:15:03,519 --> 00:15:10,480
a single copy between multiple clients

00:15:07,040 --> 00:15:12,480
so in this case gas sends a

00:15:10,480 --> 00:15:14,720
request to map certain portion of the

00:15:12,480 --> 00:15:18,079
file to what ifsd

00:15:14,720 --> 00:15:20,639
and then qmu maps that offset

00:15:18,079 --> 00:15:22,160
and that page in the file into the qma

00:15:20,639 --> 00:15:25,040
address space

00:15:22,160 --> 00:15:26,079
which can we show the physical memory

00:15:25,040 --> 00:15:29,199
inside the gas and

00:15:26,079 --> 00:15:32,800
using dax we can directly map into the

00:15:29,199 --> 00:15:32,800
address space of the guest process

00:15:33,680 --> 00:15:41,120
now what happens if a gas

00:15:37,360 --> 00:15:42,639
process mapped a file let's say food.tax

00:15:41,120 --> 00:15:44,160
and then somebody else let's say on the

00:15:42,639 --> 00:15:47,440
host

00:15:44,160 --> 00:15:48,000
truncates that file and after that guest

00:15:47,440 --> 00:15:50,079
goes

00:15:48,000 --> 00:15:54,240
and does any load or a store operation

00:15:50,079 --> 00:15:56,639
to put that particular pace

00:15:54,240 --> 00:15:58,160
so the current behavior depends so this

00:15:56,639 --> 00:15:59,920
is an error like

00:15:58,160 --> 00:16:01,839
guests try to access a page which is not

00:15:59,920 --> 00:16:03,600
present anymore the file got truncated

00:16:01,839 --> 00:16:07,199
and it could not be faulted back

00:16:03,600 --> 00:16:09,360
in now the question is what do we do

00:16:07,199 --> 00:16:10,880
if the fault is synchronous place fault

00:16:09,360 --> 00:16:12,000
let's say a synchronous base faults are

00:16:10,880 --> 00:16:14,399
not enabled

00:16:12,000 --> 00:16:15,440
in that case currently we exit back to

00:16:14,399 --> 00:16:18,800
user space

00:16:15,440 --> 00:16:20,800
with an error say e fault but if the

00:16:18,800 --> 00:16:23,120
synchronous space faults are enabled

00:16:20,800 --> 00:16:25,040
we kind of loop in finitely and this is

00:16:23,120 --> 00:16:27,680
what happens

00:16:25,040 --> 00:16:30,480
uh we take a when guest accesses that

00:16:27,680 --> 00:16:32,959
page we take a vm exit

00:16:30,480 --> 00:16:33,759
and let's say we do it get user pages

00:16:32,959 --> 00:16:36,399
remote

00:16:33,759 --> 00:16:37,519
then it returns an error code let's say

00:16:36,399 --> 00:16:39,360
e fault

00:16:37,519 --> 00:16:40,560
but currently kvm doesn't pass that

00:16:39,360 --> 00:16:44,000
error code

00:16:40,560 --> 00:16:46,240
and upon the return it injects the page

00:16:44,000 --> 00:16:48,639
ready event into the guest

00:16:46,240 --> 00:16:49,279
guest things looks like page is ready

00:16:48,639 --> 00:16:52,480
let me

00:16:49,279 --> 00:16:53,600
try the instruction it retry again we

00:16:52,480 --> 00:16:56,240
take nvm exit

00:16:53,600 --> 00:16:57,759
and the same loop continues we again

00:16:56,240 --> 00:16:59,440
inject the page ready event and this

00:16:57,759 --> 00:17:00,959
loop just continues infinitely so

00:16:59,440 --> 00:17:01,759
basically if a synchronous page faults

00:17:00,959 --> 00:17:03,360
are enabled

00:17:01,759 --> 00:17:05,520
if the host cannot resolve the page

00:17:03,360 --> 00:17:09,199
fault because file got truncated

00:17:05,520 --> 00:17:11,520
we just get into a in finite loop

00:17:09,199 --> 00:17:13,360
so that's a problem i'm facing and i

00:17:11,520 --> 00:17:16,240
think this problem we can have

00:17:13,360 --> 00:17:17,760
any of the resources which can be file

00:17:16,240 --> 00:17:19,679
backed and guests can do

00:17:17,760 --> 00:17:20,880
directly load and store that memory

00:17:19,679 --> 00:17:23,839
location

00:17:20,880 --> 00:17:24,959
i think like for example nvidia fileback

00:17:23,839 --> 00:17:27,679
and vdm device

00:17:24,959 --> 00:17:28,000
will face the similar issue so we need

00:17:27,679 --> 00:17:29,760
to

00:17:28,000 --> 00:17:31,520
do something about it so i think there

00:17:29,760 --> 00:17:32,880
are at least two problems to fix the one

00:17:31,520 --> 00:17:34,799
problem is

00:17:32,880 --> 00:17:36,640
we need to make the behavior uniform

00:17:34,799 --> 00:17:40,080
between synchronous faults and

00:17:36,640 --> 00:17:41,600
asynchronous space faults i posted a

00:17:40,080 --> 00:17:43,360
patch for that

00:17:41,600 --> 00:17:45,280
so that even for a synchronous base

00:17:43,360 --> 00:17:47,760
faults we exit to user space

00:17:45,280 --> 00:17:48,559
with e fault if the page fault cannot be

00:17:47,760 --> 00:17:50,480
resolved

00:17:48,559 --> 00:17:51,600
this patch has not been merged yet there

00:17:50,480 --> 00:17:54,559
are still

00:17:51,600 --> 00:17:56,880
some concerns on the patch i'll i need i

00:17:54,559 --> 00:18:01,280
need to get yet to address the

00:17:56,880 --> 00:18:04,640
concern raised by other developers

00:18:01,280 --> 00:18:05,679
the other bigger problem is can we do

00:18:04,640 --> 00:18:07,840
better instead of

00:18:05,679 --> 00:18:09,760
exiting to user space when kvm cannot

00:18:07,840 --> 00:18:11,760
resolve the fault can we let guests

00:18:09,760 --> 00:18:13,679
handle it we just need to inject

00:18:11,760 --> 00:18:15,280
air back into the cache saying this

00:18:13,679 --> 00:18:17,360
cannot be resolved

00:18:15,280 --> 00:18:19,280
and then gas can take it further for

00:18:17,360 --> 00:18:21,360
example if the if it was

00:18:19,280 --> 00:18:23,200
guess process which tries to access the

00:18:21,360 --> 00:18:23,760
space we can send a sig bus to the

00:18:23,200 --> 00:18:26,080
process

00:18:23,760 --> 00:18:28,559
instead of killing the whole gas and if

00:18:26,080 --> 00:18:30,240
it was the gas kernel which was trying

00:18:28,559 --> 00:18:33,120
to access that page

00:18:30,240 --> 00:18:34,559
we can do some exception table fix up

00:18:33,120 --> 00:18:38,480
magic

00:18:34,559 --> 00:18:42,160
to come out of that loop and return to

00:18:38,480 --> 00:18:44,080
a user space with appropriate error so

00:18:42,160 --> 00:18:44,640
that's the idea that would be nice if we

00:18:44,080 --> 00:18:47,679
can

00:18:44,640 --> 00:18:50,000
achieve that and

00:18:47,679 --> 00:18:50,799
but how to do that that path is not

00:18:50,000 --> 00:18:53,039
clear like

00:18:50,799 --> 00:18:54,080
in few months back we had discussion

00:18:53,039 --> 00:18:57,039
upstream and

00:18:54,080 --> 00:18:58,000
various people have different ideas uh

00:18:57,039 --> 00:19:01,120
so one of the

00:18:58,000 --> 00:19:03,440
so one of the proposals is that

00:19:01,120 --> 00:19:05,280
at least i did this a proof of concept

00:19:03,440 --> 00:19:07,760
patch when the error happens

00:19:05,280 --> 00:19:08,880
instead of where and we inject the page

00:19:07,760 --> 00:19:12,400
ready event

00:19:08,880 --> 00:19:14,480
into the guest we also send error back

00:19:12,400 --> 00:19:16,320
to the cash so guest knows whether page

00:19:14,480 --> 00:19:18,880
is really ready or not or it's an

00:19:16,320 --> 00:19:21,440
error and if it is an error then guests

00:19:18,880 --> 00:19:23,520
can do the error handling

00:19:21,440 --> 00:19:24,799
but this did not work for multiple

00:19:23,520 --> 00:19:28,000
reasons one thing is

00:19:24,799 --> 00:19:30,960
as vitaly mentioned that now

00:19:28,000 --> 00:19:32,320
we have blocked asynchronous base fault

00:19:30,960 --> 00:19:34,880
if the guest is running

00:19:32,320 --> 00:19:36,400
at privilege level zero so if kernel

00:19:34,880 --> 00:19:37,520
accesses the gas kernel access to that

00:19:36,400 --> 00:19:39,120
memory location

00:19:37,520 --> 00:19:41,200
we will not even initiate the

00:19:39,120 --> 00:19:43,120
asynchronous space fault protocol

00:19:41,200 --> 00:19:44,480
and that means that this method is not

00:19:43,120 --> 00:19:47,200
going to work

00:19:44,480 --> 00:19:48,400
for that particular use case and the

00:19:47,200 --> 00:19:49,919
other problem is that

00:19:48,400 --> 00:19:52,080
is what pointed on the mailing list that

00:19:49,919 --> 00:19:54,480
this is to this particular patch

00:19:52,080 --> 00:19:56,240
that is too tightly coupled with the

00:19:54,480 --> 00:19:58,880
synchronous space fault mechanism and

00:19:56,240 --> 00:20:00,640
the problem exists even outside apf

00:19:58,880 --> 00:20:02,320
so like design something more generic

00:20:00,640 --> 00:20:03,440
which works both for synchronous space

00:20:02,320 --> 00:20:06,880
faults as well as

00:20:03,440 --> 00:20:08,559
asynchronous space faults so so this

00:20:06,880 --> 00:20:11,679
patch set will never merge and

00:20:08,559 --> 00:20:13,840
it's just a proof of concept thing

00:20:11,679 --> 00:20:15,760
another idea was i think andy andy

00:20:13,840 --> 00:20:17,520
lutomusky said

00:20:15,760 --> 00:20:19,039
like maybe it is a good idea to use

00:20:17,520 --> 00:20:20,480
machine check exceptions they do

00:20:19,039 --> 00:20:22,400
something similar

00:20:20,480 --> 00:20:24,880
already in the case of poison memory or

00:20:22,400 --> 00:20:28,640
something so why not use that

00:20:24,880 --> 00:20:30,320
that path and inject an mc

00:20:28,640 --> 00:20:31,679
i think there are a couple of issues or

00:20:30,320 --> 00:20:35,039
at least concerns

00:20:31,679 --> 00:20:39,679
there as well typically uh

00:20:35,039 --> 00:20:42,240
typically mcs are raised synchronously

00:20:39,679 --> 00:20:44,000
only in the case of load but stores

00:20:42,240 --> 00:20:45,120
often are silent failures and i think

00:20:44,000 --> 00:20:48,720
later

00:20:45,120 --> 00:20:50,640
when hardware detects synchronously that

00:20:48,720 --> 00:20:52,080
something has gone wrong with the memory

00:20:50,640 --> 00:20:54,400
uh we raise an

00:20:52,080 --> 00:20:56,000
mce so typically store path is a

00:20:54,400 --> 00:20:57,280
synchronous path but load path is

00:20:56,000 --> 00:21:00,080
synchronous path and

00:20:57,280 --> 00:21:03,200
we want this to be synchronous both in

00:21:00,080 --> 00:21:06,480
the case of load as well as a store

00:21:03,200 --> 00:21:08,159
uh so so so maybe

00:21:06,480 --> 00:21:09,840
to solve this maybe because we are

00:21:08,159 --> 00:21:10,480
controlling everything maybe hypervisor

00:21:09,840 --> 00:21:12,880
can inject

00:21:10,480 --> 00:21:14,400
mc both and load and store like

00:21:12,880 --> 00:21:16,240
synchronously

00:21:14,400 --> 00:21:19,039
and even if the real hardware doesn't do

00:21:16,240 --> 00:21:21,200
it but i think rest of the mce code like

00:21:19,039 --> 00:21:22,960
various copy to user and copy from user

00:21:21,200 --> 00:21:25,039
and all the code following helpers have

00:21:22,960 --> 00:21:28,159
been written with this assumption

00:21:25,039 --> 00:21:29,679
that uh that one can get an exception on

00:21:28,159 --> 00:21:31,360
the load but on this

00:21:29,679 --> 00:21:33,440
not necessary on the store so i think

00:21:31,360 --> 00:21:35,679
that particular code path and all the

00:21:33,440 --> 00:21:39,280
helpers will require a change as well

00:21:35,679 --> 00:21:40,960
and other concern was that mc is already

00:21:39,280 --> 00:21:42,320
pretty complicated and there was a

00:21:40,960 --> 00:21:44,960
resistance

00:21:42,320 --> 00:21:46,000
from few people that we don't want to be

00:21:44,960 --> 00:21:48,480
doing any

00:21:46,000 --> 00:21:49,919
special casing for this case uh in the

00:21:48,480 --> 00:21:52,000
mc handler

00:21:49,919 --> 00:21:53,440
uh nobody has posted a patch so this

00:21:52,000 --> 00:21:56,240
still remains an option

00:21:53,440 --> 00:21:56,720
uh hopefully if somebody posts a good

00:21:56,240 --> 00:21:59,360
patch

00:21:56,720 --> 00:22:00,960
hopefully the it will be more acceptable

00:21:59,360 --> 00:22:03,200
um

00:22:00,960 --> 00:22:04,000
the next one is vitaly i think refer to

00:22:03,200 --> 00:22:06,640
it briefly

00:22:04,000 --> 00:22:08,400
uh is virtualization exception so there

00:22:06,640 --> 00:22:09,679
was another proposal that intel platform

00:22:08,400 --> 00:22:12,240
has this exception

00:22:09,679 --> 00:22:13,679
hey can we make use of this to report

00:22:12,240 --> 00:22:15,760
the errors back and not just the errors

00:22:13,679 --> 00:22:17,760
once we have a good race free

00:22:15,760 --> 00:22:18,880
way to report it we can even send the

00:22:17,760 --> 00:22:21,679
page not present

00:22:18,880 --> 00:22:23,679
events as well using this but the

00:22:21,679 --> 00:22:25,520
concern here is

00:22:23,679 --> 00:22:27,200
it is only available on intel what about

00:22:25,520 --> 00:22:30,159
other architectures amd

00:22:27,200 --> 00:22:30,720
and arm64 how do we do we emulate there

00:22:30,159 --> 00:22:32,400
or

00:22:30,720 --> 00:22:33,760
like how do we find equivalent

00:22:32,400 --> 00:22:36,480
replacement there

00:22:33,760 --> 00:22:37,360
so this is an idea at this point of time

00:22:36,480 --> 00:22:41,520
nobody has

00:22:37,360 --> 00:22:44,080
posted the patches yet

00:22:41,520 --> 00:22:46,080
and the last one there was another idea

00:22:44,080 --> 00:22:47,120
can we handle the problem at what ifs

00:22:46,080 --> 00:22:49,919
level itself

00:22:47,120 --> 00:22:50,720
like uh don't even get into this

00:22:49,919 --> 00:22:52,480
situation

00:22:50,720 --> 00:22:55,120
let's say implement some sort of file

00:22:52,480 --> 00:22:56,640
leases and when one client decides to

00:22:55,120 --> 00:22:58,640
truncate the file

00:22:56,640 --> 00:22:59,679
take right leads on the file and that

00:22:58,640 --> 00:23:01,200
should ensure that

00:22:59,679 --> 00:23:04,000
all other clients if anybody has the

00:23:01,200 --> 00:23:05,280
file mapped they all unmap it before

00:23:04,000 --> 00:23:06,880
truncation happens

00:23:05,280 --> 00:23:09,280
then go ahead with the truncation and

00:23:06,880 --> 00:23:11,039
that should make sure

00:23:09,280 --> 00:23:13,600
that we don't run into this error

00:23:11,039 --> 00:23:13,600
situation

00:23:13,840 --> 00:23:18,000
maybe it will work first of all we don't

00:23:15,360 --> 00:23:19,600
have the concept of file is infused

00:23:18,000 --> 00:23:21,360
so somebody will have to introduce it

00:23:19,600 --> 00:23:24,240
and devilizing the details

00:23:21,360 --> 00:23:25,840
and hopefully we can make use of it but

00:23:24,240 --> 00:23:27,760
still there are some issues

00:23:25,840 --> 00:23:30,240
so so one of the most prominent one even

00:23:27,760 --> 00:23:32,720
if you do it it will continue to be racy

00:23:30,240 --> 00:23:34,640
because for example if somebody

00:23:32,720 --> 00:23:36,080
truncates a file directly on the host it

00:23:34,640 --> 00:23:38,320
doesn't go through another

00:23:36,080 --> 00:23:39,760
what ifs client that means the

00:23:38,320 --> 00:23:41,520
truncation is not going through what

00:23:39,760 --> 00:23:43,520
ifsd and that means

00:23:41,520 --> 00:23:44,960
this particular user will not take the

00:23:43,520 --> 00:23:47,520
leases

00:23:44,960 --> 00:23:49,279
and not participate in the protocol and

00:23:47,520 --> 00:23:52,480
that will be racy i think our

00:23:49,279 --> 00:23:54,400
past we can do it the what ifs demon is

00:23:52,480 --> 00:23:56,799
watching for the events and gets a

00:23:54,400 --> 00:23:58,400
notification and sends the notification

00:23:56,799 --> 00:24:00,640
back to the guest saying

00:23:58,400 --> 00:24:02,400
truncation just happened and unmapped

00:24:00,640 --> 00:24:04,159
anything in this file you have

00:24:02,400 --> 00:24:05,520
but that is still racy because in the

00:24:04,159 --> 00:24:07,360
meantime

00:24:05,520 --> 00:24:09,200
another user can just access the file

00:24:07,360 --> 00:24:11,919
while you are being notified

00:24:09,200 --> 00:24:12,559
so that's one concern and not only that

00:24:11,919 --> 00:24:14,480
uh it

00:24:12,559 --> 00:24:16,799
i think it probably can be a stopgap

00:24:14,480 --> 00:24:20,320
solution but what ifs is only

00:24:16,799 --> 00:24:22,080
one use case uh which can run into this

00:24:20,320 --> 00:24:24,480
issue there are other use cases

00:24:22,080 --> 00:24:26,240
like nvidia was another example if i can

00:24:24,480 --> 00:24:28,799
truncate the file back

00:24:26,240 --> 00:24:29,840
file which is backing the nvdm will run

00:24:28,799 --> 00:24:31,919
into the same thing

00:24:29,840 --> 00:24:33,919
so to me it would be nice if this is

00:24:31,919 --> 00:24:35,520
properly solved in the kvm instead and

00:24:33,919 --> 00:24:39,679
that will address the

00:24:35,520 --> 00:24:43,120
wide variety of use cases um

00:24:39,679 --> 00:24:45,120
so which proposal probably is

00:24:43,120 --> 00:24:46,880
most likely i don't know like my han

00:24:45,120 --> 00:24:47,840
says probably at this point of time more

00:24:46,880 --> 00:24:50,640
inclined toward the

00:24:47,840 --> 00:24:52,400
using the machine check exception and if

00:24:50,640 --> 00:24:53,679
there is if it works reasonably well

00:24:52,400 --> 00:24:55,919
probably

00:24:53,679 --> 00:24:58,840
that might work i don't know at this

00:24:55,919 --> 00:25:00,400
point of time but that seems to be my

00:24:58,840 --> 00:25:02,080
preference so

00:25:00,400 --> 00:25:03,919
that's it from me everybody thank you

00:25:02,080 --> 00:25:04,880
for listening and if you have any

00:25:03,919 --> 00:25:08,320
questions

00:25:04,880 --> 00:25:14,480
like i'm glad to take those questions

00:25:08,320 --> 00:25:16,559
thank you

00:25:14,480 --> 00:25:16,559

YouTube URL: https://www.youtube.com/watch?v=vRrv8OqyyWI


