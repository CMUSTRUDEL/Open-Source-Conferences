Title: HA-IOV: Applying Hardware-assisted Techniques to IO Virtualization Framework - Yifei Jiang & Bo Wan
Publication date: 2020-11-10
Playlist: KVM Forum Europe 2020
Description: 
	HA-IOV: Applying Hardware-assisted Techniques to IO Virtualization Framework - Yifei Jiang & Bo Wan, Huawei
Captions: 
	00:00:04,240 --> 00:00:08,720
hello

00:00:04,880 --> 00:00:11,759
everyone i'm jennifer from huawei

00:00:08,720 --> 00:00:15,519
here i'd like to present our work

00:00:11,759 --> 00:00:18,560
on applying hardware assisted technicals

00:00:15,519 --> 00:00:23,199
to our virtualization from the work

00:00:18,560 --> 00:00:23,199
we name this work how shall we

00:00:24,880 --> 00:00:31,920
we first explain the background

00:00:28,560 --> 00:00:34,960
and the motivation of our work

00:00:31,920 --> 00:00:38,160
then the actually architecture

00:00:34,960 --> 00:00:41,280
is introduced what tears

00:00:38,160 --> 00:00:45,120
about irv are described

00:00:41,280 --> 00:00:48,239
in the following three parts finally

00:00:45,120 --> 00:00:51,360
we conclude our work and introduce

00:00:48,239 --> 00:00:51,360
our future work

00:00:52,320 --> 00:00:56,000
the even increasing demand for high

00:00:55,199 --> 00:00:58,879
performance

00:00:56,000 --> 00:00:59,920
computing in data centers heights

00:00:58,879 --> 00:01:03,199
results

00:00:59,920 --> 00:01:06,400
in the dramatic development of

00:01:03,199 --> 00:01:09,920
various virtualization environments

00:01:06,400 --> 00:01:13,119
our virtualization is one of the most

00:01:09,920 --> 00:01:16,560
crucial components which

00:01:13,119 --> 00:01:20,159
targets not only to optimize

00:01:16,560 --> 00:01:25,280
the utilization of physical resource

00:01:20,159 --> 00:01:25,280
but also to enhance the io performance

00:01:25,680 --> 00:01:30,320
to eliminate the ielts virtualization

00:01:28,960 --> 00:01:33,040
overhangs

00:01:30,320 --> 00:01:34,159
hardware assisted technicals are

00:01:33,040 --> 00:01:37,759
proposed

00:01:34,159 --> 00:01:41,680
to directly pass through excise

00:01:37,759 --> 00:01:44,880
physical io devices but then complicate

00:01:41,680 --> 00:01:47,920
the lab migration

00:01:44,880 --> 00:01:51,119
software technicals such as

00:01:47,920 --> 00:01:54,159
four emulated io devices and

00:01:51,119 --> 00:01:54,880
para virtual io devices suffering from

00:01:54,159 --> 00:01:58,320
performance

00:01:54,880 --> 00:02:02,240
lows due to costly content switch

00:01:58,320 --> 00:02:05,520
between guests and the host our work

00:02:02,240 --> 00:02:09,759
focus on the four emulated io devices

00:02:05,520 --> 00:02:13,440
and power virtual devices

00:02:09,759 --> 00:02:16,480
why guests soften performance loads

00:02:13,440 --> 00:02:19,599
we are accessing emulated io

00:02:16,480 --> 00:02:23,200
devices implemented in the

00:02:19,599 --> 00:02:24,640
user libraries let's see the whole

00:02:23,200 --> 00:02:27,760
procedure

00:02:24,640 --> 00:02:28,879
firstly to access for emulated io

00:02:27,760 --> 00:02:33,360
devices

00:02:28,879 --> 00:02:33,360
guests should trip out to qm

00:02:33,440 --> 00:02:37,440
and the qm will further transform our

00:02:36,720 --> 00:02:40,480
request

00:02:37,440 --> 00:02:42,000
to the user library by handling

00:02:40,480 --> 00:02:45,120
exceptions

00:02:42,000 --> 00:02:50,560
thus context should switch

00:02:45,120 --> 00:02:53,360
from corner to the user space

00:02:50,560 --> 00:02:54,239
then cumulus writes process i will

00:02:53,360 --> 00:02:58,560
request

00:02:54,239 --> 00:03:04,000
and retain processing and result

00:02:58,560 --> 00:03:07,360
context will switch back to qm

00:03:04,000 --> 00:03:11,760
cam further returns back to

00:03:07,360 --> 00:03:15,040
guest through switching contacts

00:03:11,760 --> 00:03:18,159
finally the gaster resumes

00:03:15,040 --> 00:03:21,040
as we can see from the whole procedure

00:03:18,159 --> 00:03:22,000
costly context switch between host and

00:03:21,040 --> 00:03:25,519
guest

00:03:22,000 --> 00:03:28,400
exit and are unavailable

00:03:25,519 --> 00:03:30,720
in current software and the hardware

00:03:28,400 --> 00:03:33,760
architecture

00:03:30,720 --> 00:03:37,120
as for para virtual io devices

00:03:33,760 --> 00:03:40,319
which are implemented using l thread

00:03:37,120 --> 00:03:44,239
bases on what i front work there are

00:03:40,319 --> 00:03:44,239
also costly contact switch

00:03:44,560 --> 00:03:52,000
the is site the gaster traps out to

00:03:48,640 --> 00:03:55,280
qm and the qm

00:03:52,000 --> 00:03:56,239
send i will event fd to blocking ios

00:03:55,280 --> 00:03:59,439
rights

00:03:56,239 --> 00:04:02,640
this is done by sending ipi to

00:03:59,439 --> 00:04:05,439
target cpu course instead of

00:04:02,640 --> 00:04:07,040
handling exception in the same cpu

00:04:05,439 --> 00:04:10,480
course

00:04:07,040 --> 00:04:13,760
intact cpu core chrono schedule wakes

00:04:10,480 --> 00:04:16,560
up the ios thread to process

00:04:13,760 --> 00:04:16,560
i o request

00:04:17,440 --> 00:04:24,400
after the processing

00:04:20,799 --> 00:04:27,520
elseride sends interrupt bike to

00:04:24,400 --> 00:04:32,800
guest to notify the compilation

00:04:27,520 --> 00:04:38,240
of io requests gather trip out again

00:04:32,800 --> 00:04:38,240
to get watch interrupt injected

00:04:40,240 --> 00:04:46,960
of course this can be optimized by

00:04:43,759 --> 00:04:49,600
x-list interrupter mechanism but

00:04:46,960 --> 00:04:50,560
when guests say the io request the

00:04:49,600 --> 00:04:54,840
overhangs

00:04:50,560 --> 00:04:57,520
caused by gaster trapping cannot be

00:04:54,840 --> 00:05:01,919
avoided let's see the

00:04:57,520 --> 00:05:05,039
we host so we host

00:05:01,919 --> 00:05:09,280
proposed to elevate io processing

00:05:05,039 --> 00:05:12,560
overhangs by adapting chronos right

00:05:09,280 --> 00:05:13,600
but all hands caused by counter switch

00:05:12,560 --> 00:05:17,600
between guests

00:05:13,600 --> 00:05:17,600
and the host steer exit

00:05:18,000 --> 00:05:22,720
different different from we host we host

00:05:21,520 --> 00:05:25,840
the user

00:05:22,720 --> 00:05:26,560
elevate i o over hands will share the

00:05:25,840 --> 00:05:30,320
memory

00:05:26,560 --> 00:05:34,080
between guests and the host

00:05:30,320 --> 00:05:37,520
however it prevents other threats

00:05:34,080 --> 00:05:40,880
from running on the polling cpu core

00:05:37,520 --> 00:05:45,039
when watch aisle workloads

00:05:40,880 --> 00:05:48,880
become real the cpu the cpu utilization

00:05:45,039 --> 00:05:51,840
becomes lower to elevate

00:05:48,880 --> 00:05:53,199
iops overhangs in io virtualization

00:05:51,840 --> 00:05:56,960
frontal work

00:05:53,199 --> 00:06:00,080
as well as improving cpu utilization

00:05:56,960 --> 00:06:03,919
lower by polymod we introduced

00:06:00,080 --> 00:06:07,680
the ijlv node sites

00:06:03,919 --> 00:06:12,000
our techniques also targeted to avoid

00:06:07,680 --> 00:06:12,000
complicating the level migration

00:06:12,319 --> 00:06:18,639
as mentioned before when guests

00:06:15,360 --> 00:06:21,680
excise four emulated io devices

00:06:18,639 --> 00:06:25,840
costly context switch between guests and

00:06:21,680 --> 00:06:28,880
hosts reduce the performance

00:06:25,840 --> 00:06:31,759
thus we propose the actually a way

00:06:28,880 --> 00:06:33,120
to eliminate the content switch over

00:06:31,759 --> 00:06:36,160
hands

00:06:33,120 --> 00:06:39,360
we do this by directly

00:06:36,160 --> 00:06:43,840
delegating exception from guest

00:06:39,360 --> 00:06:46,639
to host the user space by passing qm

00:06:43,840 --> 00:06:49,840
more details will be described in the

00:06:46,639 --> 00:06:49,840
following slides

00:06:49,919 --> 00:06:56,880
as for para virtual io devices in corner

00:06:53,759 --> 00:07:00,840
and the user space water and

00:06:56,880 --> 00:07:04,000
we host require the guests to trap out

00:07:00,840 --> 00:07:07,840
to send api or send

00:07:04,000 --> 00:07:11,720
human time i will even type d to notify

00:07:07,840 --> 00:07:15,120
what i backend and we host the backend

00:07:11,720 --> 00:07:18,880
responsively particularly

00:07:15,120 --> 00:07:22,000
ill threads running in user space

00:07:18,880 --> 00:07:24,960
should be scheduled by corner

00:07:22,000 --> 00:07:25,759
this is further called overhangs before

00:07:24,960 --> 00:07:29,280
purchasing

00:07:25,759 --> 00:07:32,800
a request to serve the costly

00:07:29,280 --> 00:07:37,120
i'll pass over hands complaining mod

00:07:32,800 --> 00:07:40,160
in host user is used

00:07:37,120 --> 00:07:43,680
it allows the guest to interact

00:07:40,160 --> 00:07:46,720
with user level io servers

00:07:43,680 --> 00:07:47,520
directly will share the memory between

00:07:46,720 --> 00:07:50,879
gaster

00:07:47,520 --> 00:07:54,240
and the host however pulling

00:07:50,879 --> 00:07:54,879
threads prevent other strikes running on

00:07:54,240 --> 00:07:58,080
the

00:07:54,879 --> 00:08:01,520
polling cpu cores which lowers

00:07:58,080 --> 00:08:05,280
the cpu utilization

00:08:01,520 --> 00:08:09,199
here we will propose the ijr way

00:08:05,280 --> 00:08:12,720
for one thing virtual inventor interrupt

00:08:09,199 --> 00:08:16,479
mechanism is introduced to allow

00:08:12,720 --> 00:08:20,000
guests to send interrupts without

00:08:16,479 --> 00:08:22,960
tripping out to qm for another

00:08:20,000 --> 00:08:23,440
user level interrupt handler which is

00:08:22,960 --> 00:08:26,479
for

00:08:23,440 --> 00:08:27,280
handling virtual inventory interrupt can

00:08:26,479 --> 00:08:30,400
be worked

00:08:27,280 --> 00:08:33,680
up quickly by hardware assisted

00:08:30,400 --> 00:08:37,760
contact switch mechanism

00:08:33,680 --> 00:08:40,800
from above battery airway can eliminate

00:08:37,760 --> 00:08:44,240
costly content switch between hosts and

00:08:40,800 --> 00:08:47,920
guests the user level threads can

00:08:44,240 --> 00:08:47,920
be worked up quickly

00:08:48,000 --> 00:08:54,640
furthermore through the combination

00:08:51,040 --> 00:08:57,760
of vi and hcs the

00:08:54,640 --> 00:09:01,120
wasted polling cpu cores become

00:08:57,760 --> 00:09:06,000
free to run other threats

00:09:01,120 --> 00:09:09,120
it can improve the cpu utilization

00:09:06,000 --> 00:09:12,480
to validate our ideas we

00:09:09,120 --> 00:09:16,640
implement a prototype on the risk

00:09:12,480 --> 00:09:20,240
file systems in risk 5 architectures

00:09:16,640 --> 00:09:23,600
privilege mode is defined as shown

00:09:20,240 --> 00:09:26,800
in the trigger figure

00:09:23,600 --> 00:09:29,200
there are four pro privilege labs and

00:09:26,800 --> 00:09:32,399
the two virtualization modes

00:09:29,200 --> 00:09:35,680
gaster runs in virtualization mode

00:09:32,399 --> 00:09:37,360
and holster runs in non-virtualization

00:09:35,680 --> 00:09:40,560
mode

00:09:37,360 --> 00:09:44,080
an extension is proposed in

00:09:40,560 --> 00:09:46,959
risk fiber priority architecture

00:09:44,080 --> 00:09:48,800
for adding user live interrupt and

00:09:46,959 --> 00:09:51,920
exhibition handler

00:09:48,800 --> 00:09:56,959
interrupts and exceptions

00:09:51,920 --> 00:09:56,959
can thus be delegated to user library

00:09:57,440 --> 00:10:05,920
hardware can transfer control deliver

00:10:02,240 --> 00:10:10,240
delete directly to use a live

00:10:05,920 --> 00:10:13,360
trap hunter without invoking the

00:10:10,240 --> 00:10:17,040
auto execution developments

00:10:13,360 --> 00:10:20,480
to support harvey will further extend

00:10:17,040 --> 00:10:24,320
the extension with the ability

00:10:20,480 --> 00:10:28,079
to redirect exception occurs in vs model

00:10:24,320 --> 00:10:31,200
or view mode to your mod and

00:10:28,079 --> 00:10:32,240
the ability to along with modern wheel

00:10:31,200 --> 00:10:35,839
mode

00:10:32,240 --> 00:10:38,560
to be interrupted by the user level

00:10:35,839 --> 00:10:38,560
interrupts

00:10:39,120 --> 00:10:45,600
both emulated and

00:10:42,160 --> 00:10:50,079
virtual io devices can benefit from

00:10:45,600 --> 00:10:53,120
actually a way next we are showing the

00:10:50,079 --> 00:10:57,200
more details in following three

00:10:53,120 --> 00:11:00,720
parts for emulated

00:10:57,200 --> 00:11:03,920
virtual devices such as uat

00:11:00,720 --> 00:11:07,200
gets the trip out when accessing

00:11:03,920 --> 00:11:10,880
mammal region qm

00:11:07,200 --> 00:11:13,040
obtains the reason and the death of trap

00:11:10,880 --> 00:11:14,720
and the further transform service

00:11:13,040 --> 00:11:17,839
information to the

00:11:14,720 --> 00:11:21,600
user space kimtor

00:11:17,839 --> 00:11:24,640
or kumar process io request

00:11:21,600 --> 00:11:28,000
according to those informations

00:11:24,640 --> 00:11:33,360
after that country flow returns back to

00:11:28,000 --> 00:11:33,360
qm and the further returns back to guest

00:11:33,680 --> 00:11:40,640
as shown in the graph which the support

00:11:37,360 --> 00:11:43,680
of hardware a specific

00:11:40,640 --> 00:11:44,560
exception whereas the guest can be

00:11:43,680 --> 00:11:47,839
directly

00:11:44,560 --> 00:11:52,160
redirect to host user space

00:11:47,839 --> 00:11:56,959
by passing qm user level exception

00:11:52,160 --> 00:12:01,200
under first save the guest contacts

00:11:56,959 --> 00:12:04,959
also some function implemented in qm

00:12:01,200 --> 00:12:08,160
under the exception in our work

00:12:04,959 --> 00:12:11,920
they they are moving to the

00:12:08,160 --> 00:12:14,320
host user space sas procedure

00:12:11,920 --> 00:12:15,040
of obtain exhibition reason and the

00:12:14,320 --> 00:12:18,560
related

00:12:15,040 --> 00:12:21,920
data are moving to the host

00:12:18,560 --> 00:12:24,959
user space besides

00:12:21,920 --> 00:12:26,480
when corner traps occur during the i o

00:12:24,959 --> 00:12:30,320
processing

00:12:26,480 --> 00:12:34,000
new kernel stack should be a region

00:12:30,320 --> 00:12:36,399
to avoid broken the exciting corner

00:12:34,000 --> 00:12:36,399
stack

00:12:36,560 --> 00:12:40,000
to directly redirect the exception from

00:12:39,440 --> 00:12:43,760
guest

00:12:40,000 --> 00:12:47,519
to the host user space we extended

00:12:43,760 --> 00:12:50,000
an extension an extension is for

00:12:47,519 --> 00:12:53,440
adding user level exhibition and the

00:12:50,000 --> 00:12:56,959
interrupt handler in extension

00:12:53,440 --> 00:13:01,040
control state resist such as your status

00:12:56,959 --> 00:13:04,399
your scratch etc are used

00:13:01,040 --> 00:13:09,440
as shown in the following tables

00:13:04,399 --> 00:13:09,440
so we no longer determine them here

00:13:10,480 --> 00:13:17,519
use level exception handler defined in

00:13:14,000 --> 00:13:21,360
an extension can only

00:13:17,519 --> 00:13:24,480
precise exemption in your mod

00:13:21,360 --> 00:13:25,279
we here extended an extension to be able

00:13:24,480 --> 00:13:29,680
to

00:13:25,279 --> 00:13:33,200
handle exhibition rest in the guest

00:13:29,680 --> 00:13:37,200
first we added a new csr

00:13:33,200 --> 00:13:42,320
actually delegates to a long exceptions

00:13:37,200 --> 00:13:42,320
rest in guests to be

00:13:46,839 --> 00:13:49,839
delegated

00:13:55,440 --> 00:14:01,360
recording the previous

00:13:58,560 --> 00:14:02,320
privilege live and the virtualization

00:14:01,360 --> 00:14:05,680
mode

00:14:02,320 --> 00:14:09,279
country floor in guest can thus be

00:14:05,680 --> 00:14:12,720
redirected to user space also

00:14:09,279 --> 00:14:16,399
the country floor should also be able to

00:14:12,720 --> 00:14:19,519
return to back to return back to

00:14:16,399 --> 00:14:23,040
guest from the host user space

00:14:19,519 --> 00:14:25,839
directly at that time the new written

00:14:23,040 --> 00:14:27,440
instruction is extended with the

00:14:25,839 --> 00:14:30,959
semantic

00:14:27,440 --> 00:14:34,079
of a long return to vs model

00:14:30,959 --> 00:14:36,959
v mode from your mod

00:14:34,079 --> 00:14:38,320
further to avoid abusing the urethane

00:14:36,959 --> 00:14:42,079
instruction

00:14:38,320 --> 00:14:45,199
a new field called hur

00:14:42,079 --> 00:14:48,240
is added in edge status

00:14:45,199 --> 00:14:52,720
this can prevent normal slides

00:14:48,240 --> 00:14:55,839
normal user stretch to jump to any place

00:14:52,720 --> 00:14:59,519
in guest this is because

00:14:55,839 --> 00:15:02,560
the returned address counted

00:14:59,519 --> 00:15:08,000
by uepc and the youth status

00:15:02,560 --> 00:15:08,000
can be changed without any restriction

00:15:08,399 --> 00:15:15,120
besides 2ml page photo exception

00:15:12,000 --> 00:15:19,839
are added those exception

00:15:15,120 --> 00:15:23,360
will also be hand in holster user space

00:15:19,839 --> 00:15:24,079
one guest access specifically manual

00:15:23,360 --> 00:15:27,760
address

00:15:24,079 --> 00:15:28,240
of emulated io devices by loading or

00:15:27,760 --> 00:15:31,680
store

00:15:28,240 --> 00:15:35,440
instruction cross-spending exception

00:15:31,680 --> 00:15:39,120
we are being raised to implement this

00:15:35,440 --> 00:15:42,800
a new field called mammal

00:15:39,120 --> 00:15:47,120
is added in pte when mmu

00:15:42,800 --> 00:15:50,800
access the pte at the second

00:15:47,120 --> 00:15:54,880
stage translation and the mammal

00:15:50,800 --> 00:15:58,160
is said in pt mammal page 4

00:15:54,880 --> 00:15:58,160
will be raised

00:15:58,560 --> 00:16:01,839
to eliminate the performance

00:16:00,880 --> 00:16:05,600
improvements

00:16:01,839 --> 00:16:09,279
brought by ijrwe we perform

00:16:05,600 --> 00:16:12,560
our experiments on risk 5 systems

00:16:09,279 --> 00:16:16,240
which is running on the hassling

00:16:12,560 --> 00:16:20,320
compound 920 cpu cross

00:16:16,240 --> 00:16:24,959
the host is configured with 4 cpu

00:16:20,320 --> 00:16:28,800
and 2 gigabytes system memory

00:16:24,959 --> 00:16:29,199
where the guest is start up with one cpu

00:16:28,800 --> 00:16:32,480
and

00:16:29,199 --> 00:16:33,360
one gigabytes system memory which is

00:16:32,480 --> 00:16:38,240
enough

00:16:33,360 --> 00:16:41,839
to perform our test due to the lack of

00:16:38,240 --> 00:16:43,040
standardized uart benchmark we tested

00:16:41,839 --> 00:16:46,240
the performance

00:16:43,040 --> 00:16:49,600
of uart by outputting one kilo

00:16:46,240 --> 00:16:53,920
10 kilo 50 kilo 100 kilo lengths

00:16:49,600 --> 00:16:57,279
of hollow wood to the terminal

00:16:53,920 --> 00:17:01,199
as we can see from the red finger

00:16:57,279 --> 00:17:04,640
the output speed of actually based

00:17:01,199 --> 00:17:09,199
uart achieves near two terms

00:17:04,640 --> 00:17:09,199
faster than the original one

00:17:10,240 --> 00:17:16,160
corner per virtual io devices

00:17:13,280 --> 00:17:17,280
such as rehearsal knight can also

00:17:16,160 --> 00:17:20,559
benefit

00:17:17,280 --> 00:17:23,199
from ijr way

00:17:20,559 --> 00:17:25,679
in extending measured to accessing

00:17:23,199 --> 00:17:28,520
corner pro virtual io devices

00:17:25,679 --> 00:17:31,440
guests should trap out to say the

00:17:28,520 --> 00:17:35,039
notifications

00:17:31,440 --> 00:17:37,760
in actual way we propose the wii

00:17:35,039 --> 00:17:38,880
with along the guests say the supervisor

00:17:37,760 --> 00:17:42,080
interrupt

00:17:38,880 --> 00:17:44,720
without tripping out holster

00:17:42,080 --> 00:17:45,760
corner threats can thus be worked up

00:17:44,720 --> 00:17:49,039
quickly

00:17:45,760 --> 00:17:49,840
by eliminating the overhangs of contact

00:17:49,039 --> 00:17:53,760
switch

00:17:49,840 --> 00:17:53,760
between host and the guest

00:17:53,919 --> 00:18:00,880
to allow guests to notify corner threads

00:17:57,600 --> 00:18:03,919
in the host each corner slides for

00:18:00,880 --> 00:18:04,799
hunting supervisor interrupts is paired

00:18:03,919 --> 00:18:07,679
to

00:18:04,799 --> 00:18:08,880
physical virtual virtual inventor

00:18:07,679 --> 00:18:13,679
interrupt

00:18:08,880 --> 00:18:17,440
which is identified by the vr id

00:18:13,679 --> 00:18:20,720
guest only need to send the vr

00:18:17,440 --> 00:18:22,240
request number to the interrupt

00:18:20,720 --> 00:18:24,480
controller

00:18:22,240 --> 00:18:26,559
then the interrupt controller will

00:18:24,480 --> 00:18:30,160
transfer the vr request

00:18:26,559 --> 00:18:33,200
number to the vr id

00:18:30,160 --> 00:18:34,400
then the mapping information is are

00:18:33,200 --> 00:18:38,240
private

00:18:34,400 --> 00:18:41,760
by kumar and the host corner

00:18:38,240 --> 00:18:45,039
finally each via request number

00:18:41,760 --> 00:18:48,960
in a guest will be attached

00:18:45,039 --> 00:18:51,840
to a vid on the specifically

00:18:48,960 --> 00:18:51,840
cpu core

00:18:52,720 --> 00:18:56,320
more specifically following steps will

00:18:55,679 --> 00:18:59,679
be

00:18:56,320 --> 00:19:03,760
performed to send

00:18:59,679 --> 00:19:07,760
and deliver supervisor vr

00:19:03,760 --> 00:19:08,640
firstly gaster sends vi by writing via

00:19:07,760 --> 00:19:12,240
request

00:19:08,640 --> 00:19:16,400
to a new add cpu request

00:19:12,240 --> 00:19:19,679
the register is alone to access in guest

00:19:16,400 --> 00:19:22,960
so there is no need for gaster to

00:19:19,679 --> 00:19:26,480
check out then vid

00:19:22,960 --> 00:19:29,200
is obtained by wier model in cpu

00:19:26,480 --> 00:19:30,240
to further clear the rejected mapping

00:19:29,200 --> 00:19:33,679
information

00:19:30,240 --> 00:19:37,200
present in the interrupt controller

00:19:33,679 --> 00:19:41,360
finally when the target cpid is found

00:19:37,200 --> 00:19:43,280
a physical interrupter identified by vid

00:19:41,360 --> 00:19:44,720
is delivered to the wholesale

00:19:43,280 --> 00:19:47,919
cornerstones

00:19:44,720 --> 00:19:47,919
in target cpu

00:19:48,160 --> 00:19:55,520
to show the advantage of ijra

00:19:52,000 --> 00:19:57,039
will perform our test using the we host

00:19:55,520 --> 00:20:00,320
the night

00:19:57,039 --> 00:20:04,559
the experiment environment is

00:20:00,320 --> 00:20:08,640
assigned to the one to elevate the uart

00:20:04,559 --> 00:20:11,360
netport is choosing as the benchmark

00:20:08,640 --> 00:20:12,640
to evaluate the performance of

00:20:11,360 --> 00:20:15,760
rehearsing light

00:20:12,640 --> 00:20:20,320
and the actually based vehicles knight

00:20:15,760 --> 00:20:23,440
as we can see from the red fingers

00:20:20,320 --> 00:20:27,360
and with in tcp and the udp of

00:20:23,440 --> 00:20:30,720
rehearsal night can be improved by

00:20:27,360 --> 00:20:34,559
over 100 percent when message

00:20:30,720 --> 00:20:37,919
size are small

00:20:34,559 --> 00:20:41,200
finally to improve cpu utilization

00:20:37,919 --> 00:20:44,320
polymorph is replaced by

00:20:41,200 --> 00:20:45,360
virtual inventor interrupt and hardware

00:20:44,320 --> 00:20:49,840
assessor

00:20:45,360 --> 00:20:49,840
contact switch in our approach

00:20:49,919 --> 00:20:53,280
in the polling model gaster interacts

00:20:52,799 --> 00:20:56,000
with

00:20:53,280 --> 00:20:56,799
user level io devices will share the

00:20:56,000 --> 00:20:59,919
memory

00:20:56,799 --> 00:21:03,200
between guests and the host

00:20:59,919 --> 00:21:07,440
water banking cells are implemented

00:21:03,200 --> 00:21:10,960
as polling threats which still

00:21:07,440 --> 00:21:14,559
keep other threats from

00:21:10,960 --> 00:21:17,679
running on the polling cpu course

00:21:14,559 --> 00:21:21,039
when i requests become real this

00:21:17,679 --> 00:21:23,440
lowers the utilization of polling cpu

00:21:21,039 --> 00:21:23,440
cross

00:21:23,840 --> 00:21:30,559
in actual way gas the interact

00:21:26,960 --> 00:21:33,679
with the user level devices

00:21:30,559 --> 00:21:36,880
by using live

00:21:33,679 --> 00:21:40,880
virtual inventor interrupt guest

00:21:36,880 --> 00:21:44,799
is alone to send user level vi without

00:21:40,880 --> 00:21:47,760
tripping out to qm water blanket

00:21:44,799 --> 00:21:48,799
is implemented in user level interrupt

00:21:47,760 --> 00:21:51,919
handles

00:21:48,799 --> 00:21:55,280
it can be triggered by the vi

00:21:51,919 --> 00:21:58,480
instead of the schedule of scaled

00:21:55,280 --> 00:22:02,799
by the kernel it can enhance

00:21:58,480 --> 00:22:04,640
the responsiveness hardware assess the

00:22:02,799 --> 00:22:08,480
context switch

00:22:04,640 --> 00:22:11,760
is thus extended in the cpu and

00:22:08,480 --> 00:22:14,880
interrupt controller for swiping the

00:22:11,760 --> 00:22:18,400
memory space and the data structure

00:22:14,880 --> 00:22:19,679
data structure of using level interrupt

00:22:18,400 --> 00:22:23,919
handlers

00:22:19,679 --> 00:22:26,640
by passing the kernel

00:22:23,919 --> 00:22:27,919
to support the user user-level interrupt

00:22:26,640 --> 00:22:31,360
just reduced

00:22:27,919 --> 00:22:34,640
including your scratcher utility

00:22:31,360 --> 00:22:35,360
as you scratch and the ico atp should

00:22:34,640 --> 00:22:39,679
also be

00:22:35,360 --> 00:22:42,960
provided in the interrupt controller

00:22:39,679 --> 00:22:43,600
use brush saves the user level data

00:22:42,960 --> 00:22:47,280
structure

00:22:43,600 --> 00:22:50,320
of the interrupt handle where ut vector

00:22:47,280 --> 00:22:53,760
stores the venture address

00:22:50,320 --> 00:22:56,720
of the interrupt handler to achieve

00:22:53,760 --> 00:22:58,559
faster responsiveness when handling

00:22:56,720 --> 00:23:02,559
user-level interrupts

00:22:58,559 --> 00:23:06,400
register as you scratch and the ictp

00:23:02,559 --> 00:23:09,679
are extended the request

00:23:06,400 --> 00:23:12,159
as you scratch is for saving the

00:23:09,679 --> 00:23:13,919
corner data structure of the user

00:23:12,159 --> 00:23:17,679
library interrupt handler

00:23:13,919 --> 00:23:18,480
where the hutp is for saving the memory

00:23:17,679 --> 00:23:23,360
space

00:23:18,480 --> 00:23:25,280
of the user level interrupt handler

00:23:23,360 --> 00:23:26,480
when a user-level virtual inventory

00:23:25,280 --> 00:23:30,720
interrupt is

00:23:26,480 --> 00:23:34,799
sent by the guest interrupter controller

00:23:30,720 --> 00:23:38,320
creates a map information to find the vi

00:23:34,799 --> 00:23:42,559
physical number also rejects

00:23:38,320 --> 00:23:44,799
mentioned above in the target cpu cross

00:23:42,559 --> 00:23:46,720
are overwritten by the interrupt

00:23:44,799 --> 00:23:49,760
controller

00:23:46,720 --> 00:23:50,000
then the interrupt controller delivers

00:23:49,760 --> 00:23:55,039
the

00:23:50,000 --> 00:23:58,080
vid to the target cpu course

00:23:55,039 --> 00:24:00,080
when target cpu cross handles the user

00:23:58,080 --> 00:24:02,240
level interrupts

00:24:00,080 --> 00:24:04,400
hardware assists the context switch

00:24:02,240 --> 00:24:07,919
mechanism in cpu

00:24:04,400 --> 00:24:13,120
for the swap wheels in seo scratch

00:24:07,919 --> 00:24:16,080
as atp with a scratch satp

00:24:13,120 --> 00:24:16,799
the critical context including memory

00:24:16,080 --> 00:24:20,480
space

00:24:16,799 --> 00:24:23,679
and data structures of the interrupted

00:24:20,480 --> 00:24:24,799
user switch and the user level interrupt

00:24:23,679 --> 00:24:28,000
handlers

00:24:24,799 --> 00:24:32,159
are swept by the hardware access

00:24:28,000 --> 00:24:34,880
context switch

00:24:32,159 --> 00:24:37,279
handle the user live interrupts

00:24:34,880 --> 00:24:40,480
crossbending software interrupt

00:24:37,279 --> 00:24:41,520
handler is a proposed and it is

00:24:40,480 --> 00:24:45,279
architecture

00:24:41,520 --> 00:24:48,000
is shown in the red fingers

00:24:45,279 --> 00:24:48,799
a user-level interrupt handler is

00:24:48,000 --> 00:24:52,320
composed

00:24:48,799 --> 00:24:55,360
to is composed of

00:24:52,320 --> 00:24:58,720
interrupt handler and user spec

00:24:55,360 --> 00:25:02,559
user strict user threat

00:24:58,720 --> 00:25:05,520
both of which showing the

00:25:02,559 --> 00:25:07,760
same memory space and the connected

00:25:05,520 --> 00:25:10,640
structure

00:25:07,760 --> 00:25:12,000
which the interrupt handler is triggered

00:25:10,640 --> 00:25:16,400
to run

00:25:12,000 --> 00:25:19,840
contacts are saved in it is user style

00:25:16,400 --> 00:25:24,720
the saved contacts will be restored

00:25:19,840 --> 00:25:27,520
when returned to the interrupted thread

00:25:24,720 --> 00:25:28,559
during the execution of the interrupt

00:25:27,520 --> 00:25:31,760
handle

00:25:28,559 --> 00:25:35,200
from the view of corner

00:25:31,760 --> 00:25:38,559
or cpu the interrupted thread

00:25:35,200 --> 00:25:42,159
is still running and it is

00:25:38,559 --> 00:25:46,080
only regarded as interrupted

00:25:42,159 --> 00:25:48,640
in standard of being scheduled out

00:25:46,080 --> 00:25:49,840
this is done by showing the schedule

00:25:48,640 --> 00:25:53,440
information

00:25:49,840 --> 00:25:56,960
of the interrupted site with the

00:25:53,440 --> 00:26:00,159
interrupter handler

00:25:56,960 --> 00:26:03,279
however the cpu core sometimes is

00:26:00,159 --> 00:26:06,799
not in the u mode and this may

00:26:03,279 --> 00:26:10,080
post upon the handling of the user level

00:26:06,799 --> 00:26:14,320
interrupts just for one thing

00:26:10,080 --> 00:26:18,000
the period of wheels mode view mode

00:26:14,320 --> 00:26:21,039
is defined to be lower than the

00:26:18,000 --> 00:26:23,919
period of view mode

00:26:21,039 --> 00:26:24,720
user-level interrupts are able to

00:26:23,919 --> 00:26:27,360
interrupt

00:26:24,720 --> 00:26:28,640
the running guest by switching

00:26:27,360 --> 00:26:32,799
virtualization mode

00:26:28,640 --> 00:26:36,080
to non-virtualization mode for another

00:26:32,799 --> 00:26:37,360
if the targeted cpu core is in attract

00:26:36,080 --> 00:26:41,200
mode

00:26:37,360 --> 00:26:45,120
for example the other tasker is running

00:26:41,200 --> 00:26:48,960
adobe interrupt is the rest to schedule

00:26:45,120 --> 00:26:52,559
user strides since interrupt handler

00:26:48,960 --> 00:26:56,320
is triggered by the user level vr

00:26:52,559 --> 00:26:59,120
to run io process by interrupting the

00:26:56,320 --> 00:26:59,120
user slide

00:26:59,520 --> 00:27:06,159
due to the lack of dptk and

00:27:02,640 --> 00:27:09,679
spdk support in risc 5 systems

00:27:06,159 --> 00:27:11,360
we evaluate the user level vi using

00:27:09,679 --> 00:27:14,880
water block

00:27:11,360 --> 00:27:17,919
we use i-file benchmark to test the

00:27:14,880 --> 00:27:21,600
reader write render rate and run

00:27:17,919 --> 00:27:25,120
write performance of guests

00:27:21,600 --> 00:27:29,120
on the basis of water black

00:27:25,120 --> 00:27:32,240
and actually best water black

00:27:29,120 --> 00:27:36,320
from the red fingers we can see

00:27:32,240 --> 00:27:39,360
that away against the average

00:27:36,320 --> 00:27:42,399
20 percent performance improvement

00:27:39,360 --> 00:27:45,039
when message size are small

00:27:42,399 --> 00:27:45,840
also the performance in vibration

00:27:45,039 --> 00:27:49,600
results

00:27:45,840 --> 00:27:53,039
we obtained are still unstable

00:27:49,600 --> 00:27:56,399
we believe it is caused by the software

00:27:53,039 --> 00:28:00,080
where tumor melee in

00:27:56,399 --> 00:28:03,120
emulate thus fpga

00:28:00,080 --> 00:28:06,559
based platform that supports

00:28:03,120 --> 00:28:11,279
risk file virtualization is needed

00:28:06,559 --> 00:28:11,279
for fasting validated and new ideas

00:28:13,520 --> 00:28:16,880
in this talk we propose the hardware

00:28:16,320 --> 00:28:20,640
access

00:28:16,880 --> 00:28:24,240
technicals for io virtualization

00:28:20,640 --> 00:28:28,080
including user level exhibition

00:28:24,240 --> 00:28:31,440
redirection virtual inventory interrupt

00:28:28,080 --> 00:28:35,760
and hardware assisted contact switch

00:28:31,440 --> 00:28:38,799
we named it a trade away actually i will

00:28:35,760 --> 00:28:39,919
enhance performance of four emulated io

00:28:38,799 --> 00:28:43,120
devices

00:28:39,919 --> 00:28:45,760
and the per virtual devices in both the

00:28:43,120 --> 00:28:50,080
kernel and the user space

00:28:45,760 --> 00:28:54,399
besides it improved cp utilization

00:28:50,080 --> 00:28:57,840
by freeing up polling cpu cores

00:28:54,399 --> 00:28:59,120
there are some future work the vmware

00:28:57,840 --> 00:29:02,559
current hardware

00:28:59,120 --> 00:29:05,919
models in current implementation

00:29:02,559 --> 00:29:10,159
prototypes is new view

00:29:05,919 --> 00:29:14,720
so the latency of current vmap

00:29:10,159 --> 00:29:18,399
information deserves future optimization

00:29:14,720 --> 00:29:22,399
also since with vi is attached to a

00:29:18,399 --> 00:29:25,440
physical cpu core cpu affinity process

00:29:22,399 --> 00:29:26,960
for vi should be provided for load

00:29:25,440 --> 00:29:30,080
balancing

00:29:26,960 --> 00:29:33,919
due to the obturation on privilege

00:29:30,080 --> 00:29:37,279
reduced such as uepc and your status

00:29:33,919 --> 00:29:40,799
may cause some security issues

00:29:37,279 --> 00:29:41,200
much more work on enhancing the security

00:29:40,799 --> 00:29:44,480
of

00:29:41,200 --> 00:29:46,799
actually away should be taken into

00:29:44,480 --> 00:29:54,880
consideration

00:29:46,799 --> 00:29:56,960
okay this is all our work thank you

00:29:54,880 --> 00:29:56,960

YouTube URL: https://www.youtube.com/watch?v=h5zjvVJXQEk


