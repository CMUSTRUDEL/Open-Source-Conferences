Title: KVM Latency Performance Tuning - Wanpeng Li, Tencent
Publication date: 2020-11-10
Playlist: KVM Forum Europe 2020
Description: 
	KVM Latency Performance Tuning - Wanpeng Li, Tencent
Captions: 
	00:00:05,920 --> 00:00:09,120
hello

00:00:06,480 --> 00:00:10,160
i'm muang pang lee from tencent cloud

00:00:09,120 --> 00:00:13,360
i'm a long-term

00:00:10,160 --> 00:00:16,720
active km contributor in community

00:00:13,360 --> 00:00:21,439
today i will introduce some kvm latency

00:00:16,720 --> 00:00:21,439
on the scalability optimizations

00:00:21,840 --> 00:00:26,240
this is today's agenda firstly i will

00:00:25,199 --> 00:00:29,519
introduce

00:00:26,240 --> 00:00:32,480
fastpass for both ipi delivery

00:00:29,519 --> 00:00:33,200
on the tsc deadline camera then i will

00:00:32,480 --> 00:00:36,800
introduce

00:00:33,200 --> 00:00:39,520
how to boost vcpus that are delivering

00:00:36,800 --> 00:00:39,520
interrupts

00:00:41,120 --> 00:00:49,039
icr on the tsc deadline i miss our ride

00:00:44,800 --> 00:00:52,480
calls the main missiles right via mexico

00:00:49,039 --> 00:00:56,079
in cloud environment over the region

00:00:52,480 --> 00:00:59,600
multicast apis are not as common as

00:00:56,079 --> 00:01:02,640
unique cast api like reschedule vector

00:00:59,600 --> 00:01:05,920
on the call function single vector

00:01:02,640 --> 00:01:09,200
we introduced fastpass handler to

00:01:05,920 --> 00:01:11,360
handle certain performance critical msrs

00:01:09,200 --> 00:01:15,119
in a very early stage

00:01:11,360 --> 00:01:18,560
of kvm via mexico handler

00:01:15,119 --> 00:01:21,920
after writing icr vm exit

00:01:18,560 --> 00:01:25,840
various guest states save and host

00:01:21,920 --> 00:01:26,320
states load various condition checking

00:01:25,840 --> 00:01:29,600
host

00:01:26,320 --> 00:01:32,880
interrupts on the preemption enabled

00:01:29,600 --> 00:01:36,159
and also expensive rcu

00:01:32,880 --> 00:01:40,079
operations we even can be interrupt

00:01:36,159 --> 00:01:43,840
or preempted after host interrupts on

00:01:40,079 --> 00:01:47,280
the preempted enabled

00:01:43,840 --> 00:01:50,399
this mechanism is specifically

00:01:47,280 --> 00:01:54,000
used for accelerating rights to

00:01:50,399 --> 00:01:57,759
x to a peak icr that attempt to send

00:01:54,000 --> 00:01:58,640
a virtual api with physical destination

00:01:57,759 --> 00:02:01,759
mode

00:01:58,640 --> 00:02:03,840
fix the delivery mode on the single

00:02:01,759 --> 00:02:07,360
target

00:02:03,840 --> 00:02:08,160
the region is mechanism significantly

00:02:07,360 --> 00:02:11,200
reduce

00:02:08,160 --> 00:02:14,319
the latency of such virtual

00:02:11,200 --> 00:02:18,480
ipi is by sending the virtual api

00:02:14,319 --> 00:02:19,440
to the target vcpu in a very early stage

00:02:18,480 --> 00:02:22,640
of km

00:02:19,440 --> 00:02:25,360
exit handler before horse interrupts

00:02:22,640 --> 00:02:26,239
are enabled and before expensive

00:02:25,360 --> 00:02:29,840
operations

00:02:26,239 --> 00:02:33,360
such as requiring kvm as rcu

00:02:29,840 --> 00:02:36,560
lock we can observe

00:02:33,360 --> 00:02:42,000
30 percent latency reduce for

00:02:36,560 --> 00:02:46,959
api benchmark and the 22.3 percent

00:02:42,000 --> 00:02:46,959
latency reduce for kvm unit test

00:02:48,160 --> 00:02:54,160
emd svm introduced hardware

00:02:51,280 --> 00:02:55,519
acceleration to boost virtual ipi

00:02:54,160 --> 00:02:59,599
performance

00:02:55,519 --> 00:03:02,640
the source ipi doesn't need to vm exit

00:02:59,599 --> 00:03:05,760
while sending unique cast api or

00:03:02,640 --> 00:03:08,800
multicast apis in most conditions

00:03:05,760 --> 00:03:12,400
the virtual ipi can be sent to target

00:03:08,800 --> 00:03:12,800
virtual cpu directly we run hack bench

00:03:12,400 --> 00:03:16,840
and

00:03:12,800 --> 00:03:19,879
ipa benchmark on one amd rom server two

00:03:16,840 --> 00:03:23,760
sockets 196 cars

00:03:19,879 --> 00:03:28,400
192 strikes the vm is 180

00:03:23,760 --> 00:03:31,680
vcpus with sap exposed

00:03:28,400 --> 00:03:35,519
we can observe three percent hackbench

00:03:31,680 --> 00:03:40,280
performance improve its benefits

00:03:35,519 --> 00:03:44,000
single target ibi however we observe

00:03:40,280 --> 00:03:47,680
55.2 percent ipi benchmark

00:03:44,000 --> 00:03:50,319
performance drop for multicast apis

00:03:47,680 --> 00:03:54,400
it is aware that hardware acceleration

00:03:50,319 --> 00:03:54,400
worse than software emulation

00:03:54,879 --> 00:04:00,319
now i will introduce virtual tnc

00:03:57,599 --> 00:04:03,439
deadline camera for the past

00:04:00,319 --> 00:04:04,400
both arm timer and thermo fare incur vm

00:04:03,439 --> 00:04:07,280
access

00:04:04,400 --> 00:04:10,319
kvm does various housekeeping tasks

00:04:07,280 --> 00:04:10,319
before emulation

00:04:11,519 --> 00:04:15,280
we implement a further path for

00:04:14,080 --> 00:04:18,479
emulation of

00:04:15,280 --> 00:04:20,639
rights to the tsa deadline msr

00:04:18,479 --> 00:04:22,079
besides shortcutting various

00:04:20,639 --> 00:04:26,000
housekeeping tasks

00:04:22,079 --> 00:04:28,080
in the cpu loop the fastpass can also

00:04:26,000 --> 00:04:31,040
delivery the timer

00:04:28,080 --> 00:04:31,600
interrupt directly without going through

00:04:31,040 --> 00:04:34,639
qm

00:04:31,600 --> 00:04:38,080
request pending timer because

00:04:34,639 --> 00:04:41,280
it runs in this pure contacts

00:04:38,080 --> 00:04:44,639
we also implement our fastpass for the

00:04:41,280 --> 00:04:47,759
primition camera via mexic

00:04:44,639 --> 00:04:48,400
the bmx can be handled clearly so it can

00:04:47,759 --> 00:04:51,600
be

00:04:48,400 --> 00:04:54,960
performed with interrupts of on going

00:04:51,600 --> 00:04:58,639
back directly to the host

00:04:54,960 --> 00:04:59,360
we can observe satellite test latency

00:04:58,639 --> 00:05:04,479
reduced

00:04:59,360 --> 00:05:04,479
by 16.5 percent

00:05:05,680 --> 00:05:09,440
next i will introduce the mechanism to

00:05:08,960 --> 00:05:13,360
boost

00:05:09,440 --> 00:05:16,639
preempted vcpus to mitigate

00:05:13,360 --> 00:05:20,240
long holder preemption issue bcpu

00:05:16,639 --> 00:05:23,360
which spin is detected by hardware

00:05:20,240 --> 00:05:25,199
while in host vcpu use time to log

00:05:23,360 --> 00:05:29,199
holder candidate vcpu

00:05:25,199 --> 00:05:32,240
which is selected by heuristic

00:05:29,199 --> 00:05:35,199
algorithm now we want to boost

00:05:32,240 --> 00:05:38,000
not just the log holders but also with

00:05:35,199 --> 00:05:41,039
fields that are delivering in the roughs

00:05:38,000 --> 00:05:44,240
most smp core functions many codes

00:05:41,039 --> 00:05:47,440
are synchronous so the ipi target with

00:05:44,240 --> 00:05:49,759
fuels are also good your candidates we

00:05:47,440 --> 00:05:53,840
boost vcpus during recap

00:05:49,759 --> 00:05:53,840
and in the route delivery time

00:05:54,800 --> 00:06:02,560
next is the boost q head vcpu

00:05:58,160 --> 00:06:05,280
due to the flfo order spin log algorithm

00:06:02,560 --> 00:06:05,759
whenever i have a weather preempts the

00:06:05,280 --> 00:06:08,160
next

00:06:05,759 --> 00:06:08,800
winter that has not yet acquired the

00:06:08,160 --> 00:06:12,240
lock

00:06:08,800 --> 00:06:14,800
email if the log is released no other

00:06:12,240 --> 00:06:18,639
slide is allowed to acquire it

00:06:14,800 --> 00:06:21,440
until the next winter is allowed to run

00:06:18,639 --> 00:06:22,880
over commitment increase the likelihood

00:06:21,440 --> 00:06:26,400
that the queue had with

00:06:22,880 --> 00:06:28,800
fuel may have been preempted and not

00:06:26,400 --> 00:06:32,080
actively spinning

00:06:28,800 --> 00:06:33,199
reschedule q hat with field timeline to

00:06:32,080 --> 00:06:36,000
acquire the lock

00:06:33,199 --> 00:06:37,840
can get better performance than just

00:06:36,000 --> 00:06:42,319
depending on lock stealing

00:06:37,840 --> 00:06:42,319
in over the right scenario

00:06:42,720 --> 00:06:49,360
the log holder vcpu used to the q hat

00:06:46,319 --> 00:06:52,360
with cpu when unlocked to boost q

00:06:49,360 --> 00:06:53,759
head with pure which is involuntary

00:06:52,360 --> 00:06:56,560
preemption

00:06:53,759 --> 00:06:58,800
of the one which is a voluntary hull due

00:06:56,560 --> 00:07:02,880
to fuel to acquire the lock

00:06:58,800 --> 00:07:05,440
after a short spin in the guest

00:07:02,880 --> 00:07:06,880
the last one is the new hypercall to you

00:07:05,440 --> 00:07:10,560
to api target

00:07:06,880 --> 00:07:14,479
by sending a call function ipmani

00:07:10,560 --> 00:07:17,759
to vcpu used if any of the ipl target

00:07:14,479 --> 00:07:21,120
vcpu was printed we just select

00:07:17,759 --> 00:07:21,599
the printed target recipe which we found

00:07:21,120 --> 00:07:24,560
since

00:07:21,599 --> 00:07:25,120
the stage of target risk field can

00:07:24,560 --> 00:07:28,840
change

00:07:25,120 --> 00:07:31,680
underneath and to avoid the risk

00:07:28,840 --> 00:07:34,319
conditions

00:07:31,680 --> 00:07:35,919
let's see the performance number we

00:07:34,319 --> 00:07:39,759
tested this on

00:07:35,919 --> 00:07:43,120
a leong's cascade league two sockets

00:07:39,759 --> 00:07:46,240
48 cars 96 strikes

00:07:43,120 --> 00:07:48,879
each vm is 96 vcpu

00:07:46,240 --> 00:07:49,759
when vm is running a basic benchmark

00:07:48,879 --> 00:07:53,560
other vm

00:07:49,759 --> 00:07:58,199
running cpu bond workloads we can of low

00:07:53,560 --> 00:08:00,560
3.4 improvement for 1vm

00:07:58,199 --> 00:08:04,960
00:08:00,560 --> 00:08:08,479
improvement for 2 vms 48.3

00:08:04,960 --> 00:08:10,800
improvement for 3 vms smp core

00:08:08,479 --> 00:08:13,440
function many cores can be in core

00:08:10,800 --> 00:08:14,240
function interrupts on the tlb showdown

00:08:13,440 --> 00:08:17,199
path

00:08:14,240 --> 00:08:17,919
with disable para virtual tlb shootdown

00:08:17,199 --> 00:08:20,800
feature in

00:08:17,919 --> 00:08:21,440
this testing since call function

00:08:20,800 --> 00:08:23,680
interrupt

00:08:21,440 --> 00:08:27,840
is not easy to be triggered by user

00:08:23,680 --> 00:08:27,840

YouTube URL: https://www.youtube.com/watch?v=bHADddk9xlc


