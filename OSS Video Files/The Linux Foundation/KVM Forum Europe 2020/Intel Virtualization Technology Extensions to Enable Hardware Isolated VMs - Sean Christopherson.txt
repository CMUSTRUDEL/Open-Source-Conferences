Title: Intel Virtualization Technology Extensions to Enable Hardware Isolated VMs - Sean Christopherson
Publication date: 2020-11-10
Playlist: KVM Forum Europe 2020
Description: 
	Intel Virtualization Technology Extensions to Enable Hardware Isolated VMs - Sean Christopherson, Intel
Captions: 
	00:00:05,040 --> 00:00:08,800
hi i'm sean christopherson from intel

00:00:06,960 --> 00:00:10,880
welcome to the 2020

00:00:08,800 --> 00:00:13,280
kvm forum presentation on intel trust

00:00:10,880 --> 00:00:15,920
domain extensions

00:00:13,280 --> 00:00:17,279
trust domain extensions or tdx is a set

00:00:15,920 --> 00:00:19,119
of hardware and software features and

00:00:17,279 --> 00:00:20,960
upcoming intel cpus that

00:00:19,119 --> 00:00:22,960
allow for the creation of hardware

00:00:20,960 --> 00:00:25,359
isolated virtual machines

00:00:22,960 --> 00:00:27,599
trust domains trust domains provide

00:00:25,359 --> 00:00:28,320
memory and cpu state confidentiality and

00:00:27,599 --> 00:00:30,960
integrity

00:00:28,320 --> 00:00:33,200
while allowing the csp or platform owner

00:00:30,960 --> 00:00:36,160
to maintain control of system resources

00:00:33,200 --> 00:00:37,120
and maintain platform integrity on the

00:00:36,160 --> 00:00:40,320
hardware side

00:00:37,120 --> 00:00:43,120
tdx adds extensions to intel's isa and

00:00:40,320 --> 00:00:44,719
to vmx intel's virtualization technology

00:00:43,120 --> 00:00:46,239
as well as memory encryption with

00:00:44,719 --> 00:00:48,640
integrity

00:00:46,239 --> 00:00:50,559
on the software side there is a new cpu

00:00:48,640 --> 00:00:52,480
attested software module

00:00:50,559 --> 00:00:53,840
that implements the bulk of the tdx

00:00:52,480 --> 00:00:55,680
functionality

00:00:53,840 --> 00:00:57,760
due to time constraints i'll mostly be

00:00:55,680 --> 00:01:00,079
focusing on the functional aspects of

00:00:57,760 --> 00:01:01,280
tdx as well as the impact on linux and

00:01:00,079 --> 00:01:03,760
kvm

00:01:01,280 --> 00:01:05,519
for an in-depth view of the security

00:01:03,760 --> 00:01:07,040
properties of tdx and things like

00:01:05,519 --> 00:01:08,479
promote attestation

00:01:07,040 --> 00:01:12,080
please see my colleagues presentation at

00:01:08,479 --> 00:01:13,360
the linux security summit on the

00:01:12,080 --> 00:01:15,439
hardware side there's a new

00:01:13,360 --> 00:01:16,640
architectural cpu mode called secure

00:01:15,439 --> 00:01:19,840
arbitration mode or

00:01:16,640 --> 00:01:21,600
seam seam is effectively a sub mode of

00:01:19,840 --> 00:01:23,759
vmx root mode

00:01:21,600 --> 00:01:25,920
it is slightly more privileged in that

00:01:23,759 --> 00:01:26,880
it has access to some new assets in the

00:01:25,920 --> 00:01:28,960
system

00:01:26,880 --> 00:01:32,079
but beyond those it is the same

00:01:28,960 --> 00:01:34,240
privilege level as vmx root mode

00:01:32,079 --> 00:01:35,840
c-mode can only be entered through vmx

00:01:34,240 --> 00:01:39,520
root mode via new instruction

00:01:35,840 --> 00:01:41,600
scene call and then conversely can be

00:01:39,520 --> 00:01:43,840
only exited from seam root through a new

00:01:41,600 --> 00:01:47,360
instruction seam rat

00:01:43,840 --> 00:01:48,079
being a sub mode of vmx scene mode has

00:01:47,360 --> 00:01:50,880
full access

00:01:48,079 --> 00:01:52,960
to the vmx instructions so that it can

00:01:50,880 --> 00:01:54,479
create vmcs's manage vmcs's and

00:01:52,960 --> 00:01:56,640
ultimately run vms

00:01:54,479 --> 00:01:58,000
through those vmcs's through vm launch

00:01:56,640 --> 00:01:59,920
and vm resume

00:01:58,000 --> 00:02:01,759
transitioning between seam root and seam

00:01:59,920 --> 00:02:05,439
non-root

00:02:01,759 --> 00:02:07,680
on the memory side tdx builds on mkt me

00:02:05,439 --> 00:02:10,800
to add integrity where integrity in this

00:02:07,680 --> 00:02:12,879
context means that if software accesses

00:02:10,800 --> 00:02:15,120
integrity protected memory with the

00:02:12,879 --> 00:02:18,160
incorrect encryption key

00:02:15,120 --> 00:02:20,879
the hardware will poison memory

00:02:18,160 --> 00:02:21,599
and ultimately result in a recoverable

00:02:20,879 --> 00:02:24,640
machine check

00:02:21,599 --> 00:02:27,680
when that memory is next accessed

00:02:24,640 --> 00:02:30,319
tdx also partitions the mktme key id

00:02:27,680 --> 00:02:32,480
space into shared and private keys

00:02:30,319 --> 00:02:34,080
where share where private keys can only

00:02:32,480 --> 00:02:37,440
be used and programmed in

00:02:34,080 --> 00:02:39,040
c mode so for example the untrusted vmm

00:02:37,440 --> 00:02:41,440
cannot take the private key

00:02:39,040 --> 00:02:43,440
for a trust domain and shove it into its

00:02:41,440 --> 00:02:46,000
own page tables and read out

00:02:43,440 --> 00:02:47,519
the guest memory that operation will

00:02:46,000 --> 00:02:49,920
fail

00:02:47,519 --> 00:02:51,680
tdx also adds a shared bit in the guest

00:02:49,920 --> 00:02:54,400
physical address space

00:02:51,680 --> 00:02:55,280
this allows the guest the trust domain

00:02:54,400 --> 00:02:57,680
to select

00:02:55,280 --> 00:02:59,519
between shared and private memory and

00:02:57,680 --> 00:03:01,120
ultimately allows the guest to decide

00:02:59,519 --> 00:03:02,000
which memory is shared with the outside

00:03:01,120 --> 00:03:03,680
world and which

00:03:02,000 --> 00:03:05,120
memory remains private within the trust

00:03:03,680 --> 00:03:07,760
domain

00:03:05,120 --> 00:03:10,879
also related to shared memory a second

00:03:07,760 --> 00:03:13,760
ept pointer is added to the vmcs

00:03:10,879 --> 00:03:14,800
this allows the ept tables to be split

00:03:13,760 --> 00:03:16,319
into

00:03:14,800 --> 00:03:18,640
shared epg tables that are managed

00:03:16,319 --> 00:03:20,720
directly by the vmm and private or

00:03:18,640 --> 00:03:23,680
secure ept tables that are managed

00:03:20,720 --> 00:03:27,360
through the tdx module

00:03:23,680 --> 00:03:29,360
again the cpu switches on the shared bit

00:03:27,360 --> 00:03:31,120
in the gpa to select between shared and

00:03:29,360 --> 00:03:33,599
private so if this bit is set

00:03:31,120 --> 00:03:35,040
the cpu will start its ebt walk from the

00:03:33,599 --> 00:03:37,120
shared ebt pointer

00:03:35,040 --> 00:03:39,360
and if the shared bit is clear it will

00:03:37,120 --> 00:03:42,480
start its ept walk from the secure ept

00:03:39,360 --> 00:03:42,480
pointer in the vmcs

00:03:42,560 --> 00:03:47,680
on the software side there is a new

00:03:45,440 --> 00:03:48,319
intel developed module called the tdx

00:03:47,680 --> 00:03:51,040
module

00:03:48,319 --> 00:03:52,720
that runs in seam the tdx module is

00:03:51,040 --> 00:03:55,760
digitally signed and verified

00:03:52,720 --> 00:03:57,360
but not encrypted the tdx module

00:03:55,760 --> 00:03:59,439
is responsible for managing guest

00:03:57,360 --> 00:04:00,799
private state including context

00:03:59,439 --> 00:04:04,400
switching register state

00:04:00,799 --> 00:04:06,480
xsav state and select msrs and the tdx

00:04:04,400 --> 00:04:07,519
module also directly controls the secure

00:04:06,480 --> 00:04:11,120
ept tables

00:04:07,519 --> 00:04:12,959
the vmcs for the trust domains and so on

00:04:11,120 --> 00:04:15,200
because the untrusted vmm does not have

00:04:12,959 --> 00:04:16,639
access to guest register state and guest

00:04:15,200 --> 00:04:19,519
memory

00:04:16,639 --> 00:04:20,400
traditional emulation of vm exiting

00:04:19,519 --> 00:04:23,120
instructions

00:04:20,400 --> 00:04:24,639
cannot occur without explicit asks from

00:04:23,120 --> 00:04:26,160
the guest so the guest needs to be

00:04:24,639 --> 00:04:28,479
enlightened to explicitly request

00:04:26,160 --> 00:04:30,400
emulation of an instruction

00:04:28,479 --> 00:04:31,759
to aid in that the tdx module will

00:04:30,400 --> 00:04:35,199
reflect any instruction

00:04:31,759 --> 00:04:38,000
that would otherwise vm exit into the

00:04:35,199 --> 00:04:39,840
guest as a virtualization exception

00:04:38,000 --> 00:04:41,840
so this isn't all instructions that vm

00:04:39,840 --> 00:04:42,560
exit only those that are not otherwise

00:04:41,840 --> 00:04:45,120
emulated

00:04:42,560 --> 00:04:46,320
or passed through by the tdx module an

00:04:45,120 --> 00:04:48,560
example being

00:04:46,320 --> 00:04:50,880
many cpu id leafs are emulated directly

00:04:48,560 --> 00:04:54,320
by the tdx module

00:04:50,880 --> 00:04:57,840
reflecting these exits as pound ves

00:04:54,320 --> 00:04:59,360
allows the guest to run with

00:04:57,840 --> 00:05:01,199
legacy code that has not been

00:04:59,360 --> 00:05:02,880
enlightened so for example a legacy

00:05:01,199 --> 00:05:05,520
driver that

00:05:02,880 --> 00:05:06,160
is executing instructions instead of

00:05:05,520 --> 00:05:09,680
directly

00:05:06,160 --> 00:05:12,240
doing hyper calls to request emulation

00:05:09,680 --> 00:05:12,960
the tdx module also exposes an abi to

00:05:12,240 --> 00:05:15,600
the vmm

00:05:12,960 --> 00:05:16,800
to create and manage trust domains this

00:05:15,600 --> 00:05:19,520
is analogous to

00:05:16,800 --> 00:05:21,280
how kvm exposes an api to user space to

00:05:19,520 --> 00:05:23,840
create and run vms

00:05:21,280 --> 00:05:26,479
so where user space makes syscalls to

00:05:23,840 --> 00:05:27,759
create vms add vcpus to the vms and run

00:05:26,479 --> 00:05:31,600
those vcpus

00:05:27,759 --> 00:05:32,720
the tdx module exposes avi to the vmm to

00:05:31,600 --> 00:05:35,039
create trust domains

00:05:32,720 --> 00:05:36,400
add vcpus and manage these using those

00:05:35,039 --> 00:05:40,000
trust domains and

00:05:36,400 --> 00:05:42,880
run those vcpus the vmm

00:05:40,000 --> 00:05:44,639
kvnr kvm in our case is still

00:05:42,880 --> 00:05:47,520
responsible for managing resources

00:05:44,639 --> 00:05:50,400
including memory scheduling and so this

00:05:47,520 --> 00:05:52,240
allows the vmm to maintain control over

00:05:50,400 --> 00:05:54,000
what memory gets assigned to a td and

00:05:52,240 --> 00:05:55,440
reclaim that memory

00:05:54,000 --> 00:05:57,199
but everything gets routed through the

00:05:55,440 --> 00:06:00,479
tdx module that would affect the

00:05:57,199 --> 00:06:02,319
security properties of a trust domain

00:06:00,479 --> 00:06:04,479
another notable software component in

00:06:02,319 --> 00:06:06,560
tdx is the seam loader

00:06:04,479 --> 00:06:08,479
which is an authenticated code module

00:06:06,560 --> 00:06:11,199
that is responsible for verifying and

00:06:08,479 --> 00:06:13,440
loading the tdx module

00:06:11,199 --> 00:06:14,240
once loaded the tdx module was protected

00:06:13,440 --> 00:06:17,440
via a new

00:06:14,240 --> 00:06:18,400
set of range registers the cmrr and this

00:06:17,440 --> 00:06:21,440
prevents

00:06:18,400 --> 00:06:23,520
code from outside of the scene module

00:06:21,440 --> 00:06:26,560
from poking into the scene module and

00:06:23,520 --> 00:06:28,000
reading or writing its code and data

00:06:26,560 --> 00:06:30,080
another responsibility of the seam

00:06:28,000 --> 00:06:31,120
loader is to configure the scene vmcs

00:06:30,080 --> 00:06:33,600
for sim call

00:06:31,120 --> 00:06:36,560
so underneath the hood sim call is just

00:06:33,600 --> 00:06:39,520
a fancy variant of vm exit

00:06:36,560 --> 00:06:41,600
meaning that when seamcall is exited is

00:06:39,520 --> 00:06:44,720
executed in vmx root

00:06:41,600 --> 00:06:46,319
it effectively is a vm exit from vmx

00:06:44,720 --> 00:06:49,360
root into seam root

00:06:46,319 --> 00:06:52,240
where seam root is the host and

00:06:49,360 --> 00:06:52,880
vmx root is the guest state so for

00:06:52,240 --> 00:06:56,080
example

00:06:52,880 --> 00:06:57,599
when seam loader loads the tdx module it

00:06:56,080 --> 00:07:00,319
programs the entry point

00:06:57,599 --> 00:07:04,080
of the tdx module into the host rip

00:07:00,319 --> 00:07:04,080
field of the siem vmcs

00:07:05,919 --> 00:07:10,000
at boot time the kernel invokes the seam

00:07:08,479 --> 00:07:13,039
loader acm

00:07:10,000 --> 00:07:15,759
which loads the tdx module into memory

00:07:13,039 --> 00:07:17,039
again protected by the cmrr and also

00:07:15,759 --> 00:07:20,319
does some configuration

00:07:17,039 --> 00:07:24,080
of the tdx module during boot

00:07:20,319 --> 00:07:27,120
then at runtime kvm executes simcall to

00:07:24,080 --> 00:07:29,360
invoke apis provided by the tdx module

00:07:27,120 --> 00:07:32,800
and the tdx module executes seamret to

00:07:29,360 --> 00:07:35,599
return control back to kvm

00:07:32,800 --> 00:07:36,960
as mentioned earlier programming of the

00:07:35,599 --> 00:07:40,639
mktme engine

00:07:36,960 --> 00:07:42,479
is done by the tdx module for

00:07:40,639 --> 00:07:44,400
for trust domains to program up the

00:07:42,479 --> 00:07:46,000
private keys and these private keys are

00:07:44,400 --> 00:07:48,879
represented by the different color bands

00:07:46,000 --> 00:07:48,879
over on the left

00:07:49,199 --> 00:07:52,720
all data structures and private memory

00:07:51,280 --> 00:07:55,039
of a trust domain

00:07:52,720 --> 00:07:56,240
are encrypted with the private key

00:07:55,039 --> 00:07:59,919
associated with that

00:07:56,240 --> 00:08:00,960
td this includes the security pt tables

00:07:59,919 --> 00:08:04,479
the vmcs

00:08:00,960 --> 00:08:07,840
xsav state etc all the

00:08:04,479 --> 00:08:09,440
memory is conceptually owned by kvm

00:08:07,840 --> 00:08:11,039
in the sense that kvm does the

00:08:09,440 --> 00:08:13,520
management of that even though it can't

00:08:11,039 --> 00:08:15,360
directly access that memory so kvm

00:08:13,520 --> 00:08:18,080
controls the life cycle of the memory

00:08:15,360 --> 00:08:20,240
but can't directly access it or program

00:08:18,080 --> 00:08:20,240
it

00:08:21,280 --> 00:08:25,680
there are 40 and change apis provided by

00:08:24,479 --> 00:08:28,000
the tdx module

00:08:25,680 --> 00:08:28,800
that can be invoked by the vmm via

00:08:28,000 --> 00:08:30,639
seamcall

00:08:28,800 --> 00:08:32,320
and these are all the usual suspects of

00:08:30,639 --> 00:08:34,959
creating a vm

00:08:32,320 --> 00:08:35,919
adding memory to the vm configuring the

00:08:34,959 --> 00:08:38,080
key used to

00:08:35,919 --> 00:08:39,680
encrypt the vm's private memory adding

00:08:38,080 --> 00:08:42,000
vcpus

00:08:39,680 --> 00:08:44,640
adding entries into the ept tables and

00:08:42,000 --> 00:08:47,279
running the vm

00:08:44,640 --> 00:08:49,839
the tdx module also provides apis that

00:08:47,279 --> 00:08:52,839
can be executed by the guest

00:08:49,839 --> 00:08:54,320
these are done via td call a new seam

00:08:52,839 --> 00:08:56,800
only

00:08:54,320 --> 00:08:58,480
instruction tdcall is for all intents

00:08:56,800 --> 00:09:00,320
and purposes vm call just with a

00:08:58,480 --> 00:09:02,080
different exit code so that the tdx

00:09:00,320 --> 00:09:04,640
module can differentiate between

00:09:02,080 --> 00:09:06,320
enlightened code executing td call and

00:09:04,640 --> 00:09:10,480
legacy code

00:09:06,320 --> 00:09:14,480
executing a vm call this api

00:09:10,480 --> 00:09:16,000
allows the guest kernel to

00:09:14,480 --> 00:09:18,320
do some introspection on the platform

00:09:16,000 --> 00:09:20,880
capabilities except memory into its

00:09:18,320 --> 00:09:22,959
private memory space and to tunnel vm

00:09:20,880 --> 00:09:26,720
calls out to the untrusted vmm

00:09:22,959 --> 00:09:26,720
to request emulation for example

00:09:27,839 --> 00:09:33,680
in the kernel and kvm during boot the

00:09:31,200 --> 00:09:35,279
kernel will invoke the seam loader acm

00:09:33,680 --> 00:09:38,080
on the bsp

00:09:35,279 --> 00:09:39,120
and then configure the tdx module on all

00:09:38,080 --> 00:09:40,640
cpus

00:09:39,120 --> 00:09:43,839
and i'll talk about this a little bit

00:09:40,640 --> 00:09:46,240
later in a few slides

00:09:43,839 --> 00:09:47,040
on the kvm side of things the biggest

00:09:46,240 --> 00:09:50,000
change to

00:09:47,040 --> 00:09:52,720
existing code in terms of lines of code

00:09:50,000 --> 00:09:55,760
is to wrap the x86 callbacks in vmx

00:09:52,720 --> 00:09:59,200
to achieve vmx and tdx coexistence

00:09:55,760 --> 00:10:02,800
meaning a single instance of kvm

00:09:59,200 --> 00:10:04,800
can run vms and tds side by side

00:10:02,800 --> 00:10:06,399
and by wrapping those callbacks as

00:10:04,800 --> 00:10:07,440
opposed to introducing a new set of

00:10:06,399 --> 00:10:09,600
callbacks

00:10:07,440 --> 00:10:13,519
we can do so without any meaningful

00:10:09,600 --> 00:10:15,440
performance impact to vmx or svm

00:10:13,519 --> 00:10:17,839
for tdx we are able to reuse select

00:10:15,440 --> 00:10:20,800
portions of emx

00:10:17,839 --> 00:10:22,480
for example iraq and nmi trampolines for

00:10:20,800 --> 00:10:24,560
handling

00:10:22,480 --> 00:10:26,160
hardware interrupts the post-interrupt

00:10:24,560 --> 00:10:28,720
support and bmx

00:10:26,160 --> 00:10:30,880
the ebt entry points into the kvm mmu

00:10:28,720 --> 00:10:32,640
page vault and so on

00:10:30,880 --> 00:10:36,399
outside of vmx there's moderate

00:10:32,640 --> 00:10:38,560
factoring to x86 and common kvm

00:10:36,399 --> 00:10:39,760
we piggyback and repurpose the i o

00:10:38,560 --> 00:10:43,120
controls added by

00:10:39,760 --> 00:10:46,480
suv and i also do some

00:10:43,120 --> 00:10:49,600
refactoring of the lifecycle of vms as

00:10:46,480 --> 00:10:51,920
the ordering of apis dictated by the tdx

00:10:49,600 --> 00:10:55,200
module doesn't perfectly align

00:10:51,920 --> 00:10:58,079
with the existing code in kvm

00:10:55,200 --> 00:10:59,600
the most impactful changes for tdx are

00:10:58,079 --> 00:11:03,440
to support secure ept

00:10:59,600 --> 00:11:04,000
in kvm's mmu and we also likely need to

00:11:03,440 --> 00:11:06,160
modify

00:11:04,000 --> 00:11:07,839
the kernel mmu to support unmapping

00:11:06,160 --> 00:11:11,200
guest private memory which i'll

00:11:07,839 --> 00:11:11,200
talk about in a couple slides

00:11:12,560 --> 00:11:16,320
in kvm's mmu to handle shared and

00:11:14,959 --> 00:11:19,360
private memory

00:11:16,320 --> 00:11:21,360
kvm aliases the shared gpas to private

00:11:19,360 --> 00:11:24,000
gpas in the mem slots

00:11:21,360 --> 00:11:26,000
which means that we effectively treat

00:11:24,000 --> 00:11:29,200
the shared bit as an attribute bit as

00:11:26,000 --> 00:11:31,839
opposed to a real physical address bit

00:11:29,200 --> 00:11:34,399
by doing so we can hide kvm can hide the

00:11:31,839 --> 00:11:38,160
shared bit from host user space

00:11:34,399 --> 00:11:41,839
for example when exiting to user space

00:11:38,160 --> 00:11:42,399
to handle emulated mmio kvm strips the

00:11:41,839 --> 00:11:44,880
shared bit

00:11:42,399 --> 00:11:45,680
so that the host user space only ever

00:11:44,880 --> 00:11:48,560
sees the

00:11:45,680 --> 00:11:50,160
kind of real or private gpas and this

00:11:48,560 --> 00:11:51,200
means that host user space doesn't have

00:11:50,160 --> 00:11:53,200
to be enlightened

00:11:51,200 --> 00:11:54,639
to understand the difference and doesn't

00:11:53,200 --> 00:11:56,639
have to be

00:11:54,639 --> 00:11:59,839
doesn't have to manage separate memory

00:11:56,639 --> 00:12:03,360
pools for private versus shared memory

00:11:59,839 --> 00:12:05,279
for security pt tdx adds several new

00:12:03,360 --> 00:12:08,839
hooks into kvm's mmu

00:12:05,279 --> 00:12:10,160
to insert zap and remove secure ept

00:12:08,839 --> 00:12:12,240
entries

00:12:10,160 --> 00:12:15,440
this is necessary because the security

00:12:12,240 --> 00:12:18,560
pt is managed through the tdx module

00:12:15,440 --> 00:12:20,399
so whereas a traditional ept management

00:12:18,560 --> 00:12:23,120
would involve reading and writing memory

00:12:20,399 --> 00:12:26,079
directly with tdx the security pt

00:12:23,120 --> 00:12:27,120
can only be managed by invoking sim

00:12:26,079 --> 00:12:29,440
calls to

00:12:27,120 --> 00:12:31,279
again insert zap and remove security pt

00:12:29,440 --> 00:12:33,440
entries

00:12:31,279 --> 00:12:35,279
kvm still does maintain a shadow copy of

00:12:33,440 --> 00:12:36,880
the scripty tables

00:12:35,279 --> 00:12:38,800
this is because simcall is quite

00:12:36,880 --> 00:12:41,839
expensive so

00:12:38,800 --> 00:12:45,040
if kvm were to invoke seem call to read

00:12:41,839 --> 00:12:46,800
an ept entry for every level of an ebt

00:12:45,040 --> 00:12:51,200
walk handling page faults would be

00:12:46,800 --> 00:12:54,160
extremely costly in terms of latency

00:12:51,200 --> 00:12:55,360
these shadows are used any time we're

00:12:54,160 --> 00:12:56,959
walking the page tables

00:12:55,360 --> 00:12:59,360
and so it's only when we actually need

00:12:56,959 --> 00:13:01,040
to modify an entry do we invoke the same

00:12:59,360 --> 00:13:02,639
call

00:13:01,040 --> 00:13:05,600
and then secure apt also needs an

00:13:02,639 --> 00:13:08,959
additional api from the mmu

00:13:05,600 --> 00:13:12,399
to allow adding translations without

00:13:08,959 --> 00:13:15,200
in without a page fault

00:13:12,399 --> 00:13:17,680
this is necessary because the only way

00:13:15,200 --> 00:13:19,920
to load non-zero memory into

00:13:17,680 --> 00:13:20,720
i guess private memory space aka load

00:13:19,920 --> 00:13:24,160
the initial

00:13:20,720 --> 00:13:27,839
memory image is to that can only

00:13:24,160 --> 00:13:30,320
be done before vcpus are runnable and to

00:13:27,839 --> 00:13:32,480
load non-zero memory the security

00:13:30,320 --> 00:13:35,519
translations for the associated guest

00:13:32,480 --> 00:13:37,440
private memory must be in place so long

00:13:35,519 --> 00:13:39,680
story short we have to have this qpt

00:13:37,440 --> 00:13:41,920
translations before we can run vcpus

00:13:39,680 --> 00:13:43,920
which conflicts with kvm's existing

00:13:41,920 --> 00:13:47,120
model of

00:13:43,920 --> 00:13:48,720
populating the ept tables on demand

00:13:47,120 --> 00:13:51,040
in response to page faults from the

00:13:48,720 --> 00:13:51,040
guest

00:13:52,079 --> 00:13:55,680
on the private memory side of things all

00:13:54,320 --> 00:13:58,240
private memory

00:13:55,680 --> 00:13:59,120
so all memory that can be stuffed into a

00:13:58,240 --> 00:14:01,360
handed over to

00:13:59,120 --> 00:14:03,120
the tdx module to create private memory

00:14:01,360 --> 00:14:04,560
for a guest must reside in a trust

00:14:03,120 --> 00:14:08,160
domain memory region

00:14:04,560 --> 00:14:10,320
or a tdmr a tdmr is just a software

00:14:08,160 --> 00:14:12,320
construct defined by tdx module that it

00:14:10,320 --> 00:14:15,360
uses to

00:14:12,320 --> 00:14:16,800
track metadata for system memory and it

00:14:15,360 --> 00:14:19,360
does this so that

00:14:16,800 --> 00:14:20,720
it can detect attempts from the vmm to

00:14:19,360 --> 00:14:24,800
do remapping attacks

00:14:20,720 --> 00:14:27,839
or to hand the same physical page

00:14:24,800 --> 00:14:30,399
twice to a td so for example mapping

00:14:27,839 --> 00:14:32,880
multiple gpas to a single

00:14:30,399 --> 00:14:33,440
hpa in the guest to try and attack the

00:14:32,880 --> 00:14:37,279
guests

00:14:33,440 --> 00:14:37,760
that way during boot the kernel adds all

00:14:37,279 --> 00:14:41,360
ram

00:14:37,760 --> 00:14:44,079
to the tdmr array and this allows kvm to

00:14:41,360 --> 00:14:46,160
allocate private memory

00:14:44,079 --> 00:14:49,680
through the normal memory allocator apis

00:14:46,160 --> 00:14:52,800
which it then gifts to the tdx module

00:14:49,680 --> 00:14:54,240
so for example huge tlbfs transparent

00:14:52,800 --> 00:14:56,639
huge pages

00:14:54,240 --> 00:14:57,760
mfd anonymous memory etc are all

00:14:56,639 --> 00:14:59,199
naturally supported

00:14:57,760 --> 00:15:02,399
simply because we're routing through the

00:14:59,199 --> 00:15:05,519
normal memory allocator

00:15:02,399 --> 00:15:07,600
as for unmapping guest private memory

00:15:05,519 --> 00:15:08,639
because integrity failures result in

00:15:07,600 --> 00:15:10,959
machine checks

00:15:08,639 --> 00:15:12,160
leaving the guest private memory mapped

00:15:10,959 --> 00:15:13,760
in host user space

00:15:12,160 --> 00:15:16,079
would allow host user space to

00:15:13,760 --> 00:15:17,360
essentially induce machine checks out

00:15:16,079 --> 00:15:19,279
well

00:15:17,360 --> 00:15:21,600
while it's theoretically possible that

00:15:19,279 --> 00:15:23,199
we could harden the linux kernel

00:15:21,600 --> 00:15:25,120
to gracefully handle all these machine

00:15:23,199 --> 00:15:26,880
checks there's definitely

00:15:25,120 --> 00:15:28,240
a certain amount of risk associated with

00:15:26,880 --> 00:15:30,320
that approach

00:15:28,240 --> 00:15:32,800
so we're exploring unmapping guest

00:15:30,320 --> 00:15:35,120
private memory so that

00:15:32,800 --> 00:15:36,720
accesses from host user space to guest

00:15:35,120 --> 00:15:39,199
private memory would result

00:15:36,720 --> 00:15:41,680
in a page fault as opposed to a machine

00:15:39,199 --> 00:15:45,360
check

00:15:41,680 --> 00:15:48,079
for shared memory tdx allows

00:15:45,360 --> 00:15:49,279
the shared ept in tdx allows the

00:15:48,079 --> 00:15:52,320
untrusted vmm

00:15:49,279 --> 00:15:55,040
to configure select ept entries

00:15:52,320 --> 00:15:56,240
to generate ebt violation virtualization

00:15:55,040 --> 00:15:58,320
exceptions

00:15:56,240 --> 00:16:00,639
this means that instead of causing an

00:15:58,320 --> 00:16:02,720
ept vm exit

00:16:00,639 --> 00:16:04,399
faults to these addresses get reflected

00:16:02,720 --> 00:16:06,639
back to the guest as

00:16:04,399 --> 00:16:09,040
virtualization exceptions the primary

00:16:06,639 --> 00:16:11,040
use case for this is to reflect mmio

00:16:09,040 --> 00:16:13,199
addresses as pound bees

00:16:11,040 --> 00:16:14,160
so again if the guest kernel is not

00:16:13,199 --> 00:16:16,880
fully enlightened

00:16:14,160 --> 00:16:18,639
and has code that is accessing memory

00:16:16,880 --> 00:16:22,480
accessing memory mapped io

00:16:18,639 --> 00:16:24,480
instead of doing direct td calls

00:16:22,480 --> 00:16:26,480
the hardware can reflect those accesses

00:16:24,480 --> 00:16:29,600
as pound bees and then the

00:16:26,480 --> 00:16:32,240
pound ve handler and the guest can

00:16:29,600 --> 00:16:33,519
request emulation after decoding the

00:16:32,240 --> 00:16:36,639
instruction

00:16:33,519 --> 00:16:39,600
they catch with ept violation pound ve

00:16:36,639 --> 00:16:41,279
is that suppression is opt out meaning

00:16:39,600 --> 00:16:44,480
that

00:16:41,279 --> 00:16:46,399
not present ept entries if zeroed

00:16:44,480 --> 00:16:47,680
would get reflected to the guest as

00:16:46,399 --> 00:16:50,160
pound ves

00:16:47,680 --> 00:16:52,000
so from kvm mmu perspective this means

00:16:50,160 --> 00:16:54,320
we have to support a non-zero init value

00:16:52,000 --> 00:16:57,279
for ept entries

00:16:54,320 --> 00:16:58,079
this isn't a significant change in terms

00:16:57,279 --> 00:16:59,759
of

00:16:58,079 --> 00:17:03,279
lines of code but it's obviously

00:16:59,759 --> 00:17:05,360
touching a core part of the kvm mmu

00:17:03,279 --> 00:17:07,199
as for more advanced features tdx

00:17:05,360 --> 00:17:10,880
architecture supports large pages

00:17:07,199 --> 00:17:13,120
both two meg and one gig pages uh

00:17:10,880 --> 00:17:14,959
two meg pages we haven't yet implemented

00:17:13,120 --> 00:17:16,319
yet simply because we haven't gotten to

00:17:14,959 --> 00:17:18,480
them

00:17:16,319 --> 00:17:20,319
one gig pages on the other hand will

00:17:18,480 --> 00:17:21,679
require a little bit of complexity as

00:17:20,319 --> 00:17:22,400
there's some extra bookkeeping that

00:17:21,679 --> 00:17:25,520
needs to be done

00:17:22,400 --> 00:17:27,439
to first build the memory region

00:17:25,520 --> 00:17:29,360
using two make pages and then promote to

00:17:27,439 --> 00:17:31,919
a one gig page

00:17:29,360 --> 00:17:33,360
tdx also supports host page migration so

00:17:31,919 --> 00:17:36,480
for example

00:17:33,360 --> 00:17:38,559
to support pneuma balancing as well as

00:17:36,480 --> 00:17:41,120
page promotion and demotion

00:17:38,559 --> 00:17:42,880
so for example page migration for

00:17:41,120 --> 00:17:44,320
transparent huge pages to collect

00:17:42,880 --> 00:17:48,559
fractured pages

00:17:44,320 --> 00:17:48,559
and promote them into a two make page

00:17:51,360 --> 00:17:57,039
stand is for linux and kvm and qmu

00:17:54,720 --> 00:17:57,840
the basic functionality in kvm is code

00:17:57,039 --> 00:18:01,679
complete

00:17:57,840 --> 00:18:03,679
where basic here means we can build a td

00:18:01,679 --> 00:18:05,440
with an enlightened guest virtual bios

00:18:03,679 --> 00:18:07,280
an enlightened kernel

00:18:05,440 --> 00:18:09,600
boot that guest kernel which in this

00:18:07,280 --> 00:18:13,200
case is linux guest

00:18:09,600 --> 00:18:14,799
and have full access to all verdio

00:18:13,200 --> 00:18:17,200
synthetic devices

00:18:14,799 --> 00:18:19,760
so we can access the network and disk

00:18:17,200 --> 00:18:22,080
etc all within the guest

00:18:19,760 --> 00:18:24,640
qmu is functional but not as code

00:18:22,080 --> 00:18:28,080
complete as kvm

00:18:24,640 --> 00:18:30,799
on the kbm side there are

00:18:28,080 --> 00:18:32,240
40 plus files changed little over 6 000

00:18:30,799 --> 00:18:35,120
new lines of code

00:18:32,240 --> 00:18:36,320
and 700 changed lines of code give or

00:18:35,120 --> 00:18:38,400
take

00:18:36,320 --> 00:18:41,360
most of those changes being the wrapping

00:18:38,400 --> 00:18:43,200
of vmx's x86 ops

00:18:41,360 --> 00:18:44,960
the code is publicly available on

00:18:43,200 --> 00:18:49,440
intel's github

00:18:44,960 --> 00:18:51,919
for kvm and qmu will follow shortly

00:18:49,440 --> 00:18:53,120
in the near future so effectively prior

00:18:51,919 --> 00:18:56,160
to upstreaming

00:18:53,120 --> 00:18:58,720
on our to-do list is large sage support

00:18:56,160 --> 00:18:59,440
especially two meg pages and host page

00:18:58,720 --> 00:19:01,120
migration

00:18:59,440 --> 00:19:02,559
and the unmapping of guess private

00:19:01,120 --> 00:19:05,280
memory

00:19:02,559 --> 00:19:06,400
longer term our top priority is live

00:19:05,280 --> 00:19:08,840
migration

00:19:06,400 --> 00:19:10,799
and we also have line of sight to nested

00:19:08,840 --> 00:19:11,440
virtualization nested in this case

00:19:10,799 --> 00:19:15,440
meaning

00:19:11,440 --> 00:19:17,760
nesting legacy vms inside trust domains

00:19:15,440 --> 00:19:19,120
we are not planning on supporting trust

00:19:17,760 --> 00:19:24,240
domains nested within

00:19:19,120 --> 00:19:26,559
within other trust domains

00:19:24,240 --> 00:19:27,679
last but not least if you want a bit of

00:19:26,559 --> 00:19:29,679
light reading

00:19:27,679 --> 00:19:32,480
the specs for tdx are available on

00:19:29,679 --> 00:19:32,480
intel's website

00:19:33,520 --> 00:19:39,840
thank you and i hope you have a great

00:19:35,679 --> 00:19:39,840

YouTube URL: https://www.youtube.com/watch?v=AEf4ldd5JTo


