Title: Evolution of SPDK vhost Towards Secure Container Storage Service - Xiaodong Liu & Changpeng Liu
Publication date: 2020-11-10
Playlist: KVM Forum Europe 2020
Description: 
	Evolution of SPDK vhost Towards Secure Container Storage Service - Xiaodong Liu & Changpeng Liu, Intel
Captions: 
	00:00:07,200 --> 00:00:11,440
hello everyone

00:00:09,040 --> 00:00:13,679
japan and i are coming from intel

00:00:11,440 --> 00:00:15,599
storage software team

00:00:13,679 --> 00:00:16,720
we are talking about the evolution of

00:00:15,599 --> 00:00:22,160
spk

00:00:16,720 --> 00:00:22,160
towards secure container storage service

00:00:23,680 --> 00:00:30,320
spdk is a storage performance

00:00:27,279 --> 00:00:32,960
development kit it provides a set of

00:00:30,320 --> 00:00:33,840
tools and libraries for writing high

00:00:32,960 --> 00:00:37,920
performance

00:00:33,840 --> 00:00:41,920
scalable user mode storage applications

00:00:37,920 --> 00:00:45,039
sdkv host is one spk

00:00:41,920 --> 00:00:48,320
provided application as

00:00:45,039 --> 00:00:52,079
a high performance storage authorization

00:00:48,320 --> 00:00:54,800
solution with flexibility and robustness

00:00:52,079 --> 00:00:55,680
is already widely deployed by loss of

00:00:54,800 --> 00:00:59,840
csp and

00:00:55,680 --> 00:00:59,840
enterprises in their infrastructure

00:01:02,000 --> 00:01:05,920
in this topic we start another

00:01:04,479 --> 00:01:09,680
consideration on

00:01:05,920 --> 00:01:09,680
vm-based secure container

00:01:11,200 --> 00:01:19,040
from recent papers and reports of aws

00:01:14,880 --> 00:01:21,520
or id cloud secure container is the

00:01:19,040 --> 00:01:22,720
bedrock for their public cloud container

00:01:21,520 --> 00:01:26,799
service

00:01:22,720 --> 00:01:29,840
so it is popular in csp

00:01:26,799 --> 00:01:30,960
and commonly secure container is virtual

00:01:29,840 --> 00:01:33,680
machine based

00:01:30,960 --> 00:01:35,439
like cotton containers here the

00:01:33,680 --> 00:01:39,759
evaluation work we have done

00:01:35,439 --> 00:01:43,280
is based on cutter containers since

00:01:39,759 --> 00:01:44,320
it is virtual machine based can spdk

00:01:43,280 --> 00:01:48,159
warehouse

00:01:44,320 --> 00:01:52,000
directly be applied to color containers

00:01:48,159 --> 00:01:55,600
let's take a look at the characteristic

00:01:52,000 --> 00:01:58,159
of secure container the first

00:01:55,600 --> 00:01:59,680
characteristic is the high container

00:01:58,159 --> 00:02:01,520
density

00:01:59,680 --> 00:02:03,040
not like a traditional virtualization

00:02:01,520 --> 00:02:06,640
scenario that only

00:02:03,040 --> 00:02:09,759
tons of vm are running in a server

00:02:06,640 --> 00:02:10,399
secure container so more than one

00:02:09,759 --> 00:02:13,360
thousand

00:02:10,399 --> 00:02:14,640
of containers on a single on one single

00:02:13,360 --> 00:02:17,120
host

00:02:14,640 --> 00:02:18,560
which means more than one thousand of

00:02:17,120 --> 00:02:22,480
lightweight virtual machines

00:02:18,560 --> 00:02:25,840
are running on a single host

00:02:22,480 --> 00:02:29,680
the second item is resource

00:02:25,840 --> 00:02:32,480
over poisoning cpu and macro resource

00:02:29,680 --> 00:02:33,680
will not be planned and pre-assigned to

00:02:32,480 --> 00:02:36,720
specific

00:02:33,680 --> 00:02:37,680
virtual machines probably these

00:02:36,720 --> 00:02:40,560
resources

00:02:37,680 --> 00:02:41,760
will be scheduled to different container

00:02:40,560 --> 00:02:45,280
dynamically

00:02:41,760 --> 00:02:48,560
and they are always trends seriously

00:02:45,280 --> 00:02:51,519
since there are a lot of containers

00:02:48,560 --> 00:02:52,480
and commonly containers do not only

00:02:51,519 --> 00:02:55,840
focus on

00:02:52,480 --> 00:03:00,800
extremely high performance but it also

00:02:55,840 --> 00:03:00,800
focus on flexibility and robustness

00:03:02,800 --> 00:03:09,680
the first problem we might with sfdk

00:03:06,800 --> 00:03:12,000
and the square container is about the

00:03:09,680 --> 00:03:15,440
high canada density

00:03:12,000 --> 00:03:18,560
smdk application uses polling mode

00:03:15,440 --> 00:03:22,640
which is a and this while loop

00:03:18,560 --> 00:03:26,319
to pull each device check and process

00:03:22,640 --> 00:03:30,879
zero requests for warehouse device

00:03:26,319 --> 00:03:33,519
spk posts each watch queue in roms

00:03:30,879 --> 00:03:34,480
poly mode with this type of application

00:03:33,519 --> 00:03:36,959
framework

00:03:34,480 --> 00:03:38,239
is good and efficient for heavy

00:03:36,959 --> 00:03:41,519
workloads

00:03:38,239 --> 00:03:44,560
but for container their l

00:03:41,519 --> 00:03:45,280
clothes are not always so high so when

00:03:44,560 --> 00:03:48,720
containers

00:03:45,280 --> 00:03:50,640
are in high density protein to cure a

00:03:48,720 --> 00:03:54,480
massive world queues

00:03:50,640 --> 00:03:54,480
is not efficient at all

00:03:55,280 --> 00:04:03,280
the second problem is about the cpu

00:03:58,799 --> 00:04:06,319
and the memory resource overpricing

00:04:03,280 --> 00:04:07,439
when some cpu cores are running spdw

00:04:06,319 --> 00:04:11,200
host

00:04:07,439 --> 00:04:14,319
this course will be occupied or pinned

00:04:11,200 --> 00:04:17,759
by svk warehouse all the time due to

00:04:14,319 --> 00:04:20,799
pulling mode just like our slogan

00:04:17,759 --> 00:04:21,759
don't interrupt me i'm probably for

00:04:20,799 --> 00:04:25,600
memory

00:04:21,759 --> 00:04:29,680
due to user space device dma operation

00:04:25,600 --> 00:04:32,800
spdk requires memory to be pre-allocated

00:04:29,680 --> 00:04:36,400
as a huge page memory

00:04:32,800 --> 00:04:40,800
the memory pre-allocation and the cpu

00:04:36,400 --> 00:04:43,759
occupation required by spdk warehouse

00:04:40,800 --> 00:04:46,800
are barriers to our prison also

00:04:43,759 --> 00:04:49,919
resources to container

00:04:46,800 --> 00:04:50,479
okay towards secure containers can we

00:04:49,919 --> 00:04:52,800
involve

00:04:50,479 --> 00:04:54,639
as big as applications to be

00:04:52,800 --> 00:05:00,080
interruptable

00:04:54,639 --> 00:05:00,080
let's first look back on spdk internal

00:05:00,639 --> 00:05:04,639
one of the primary aims of sp is to

00:05:03,759 --> 00:05:07,840
scale

00:05:04,639 --> 00:05:11,680
skill linearly with the addition

00:05:07,840 --> 00:05:15,280
of hardware to achieve this spd

00:05:11,680 --> 00:05:16,479
execution unit must be independent from

00:05:15,280 --> 00:05:19,600
one another

00:05:16,479 --> 00:05:24,320
as much as possible and avoid

00:05:19,600 --> 00:05:27,680
soft locks instead of placing

00:05:24,320 --> 00:05:31,039
shared in a global location that

00:05:27,680 --> 00:05:31,360
all thread access after acquiring a lock

00:05:31,039 --> 00:05:35,440
as

00:05:31,360 --> 00:05:38,240
pd takes a different approach altogether

00:05:35,440 --> 00:05:40,880
as pdk will often assign that a date to

00:05:38,240 --> 00:05:43,520
a single thread

00:05:40,880 --> 00:05:44,000
when other threads want to access the

00:05:43,520 --> 00:05:46,720
did

00:05:44,000 --> 00:05:47,039
they must pass a message to the owings

00:05:46,720 --> 00:05:50,639
right

00:05:47,039 --> 00:05:53,199
to perform the operation on behalf of

00:05:50,639 --> 00:05:57,120
the threads

00:05:53,199 --> 00:05:59,840
this strategy of course is not

00:05:57,120 --> 00:06:01,360
new for instance it is one of the core

00:05:59,840 --> 00:06:04,479
design principles of

00:06:01,360 --> 00:06:06,880
eric syn long and is the main

00:06:04,479 --> 00:06:09,360
concurrency mechanism within google

00:06:06,880 --> 00:06:09,360
language

00:06:11,360 --> 00:06:18,840
spd provides several layers to construct

00:06:15,440 --> 00:06:21,680
messaging passing in front

00:06:18,840 --> 00:06:24,720
infrastructure the most fundamental

00:06:21,680 --> 00:06:27,039
libraries in spd for instance

00:06:24,720 --> 00:06:28,960
are don't do any message passing on

00:06:27,039 --> 00:06:32,720
their own it depends on as

00:06:28,960 --> 00:06:34,560
bdk's threat abstraction i speak threats

00:06:32,720 --> 00:06:37,440
thread abstraction provides

00:06:34,560 --> 00:06:38,400
a basic message passing framework and

00:06:37,440 --> 00:06:42,000
defense a

00:06:38,400 --> 00:06:45,600
key primitives

00:06:42,000 --> 00:06:49,759
first spd is an abstraction

00:06:45,600 --> 00:06:53,080
for a lightweight stack list thread of

00:06:49,759 --> 00:06:56,319
execution a low-level framework kind

00:06:53,080 --> 00:06:59,680
executed and a split thread

00:06:56,319 --> 00:07:02,960
for a single timelines by calling

00:06:59,680 --> 00:07:04,720
spdk thread pull function

00:07:02,960 --> 00:07:06,560
the lightweight slider is the

00:07:04,720 --> 00:07:09,840
fundamental abstraction

00:07:06,560 --> 00:07:10,479
for threading in sdk there are also a

00:07:09,840 --> 00:07:13,840
few

00:07:10,479 --> 00:07:17,680
additional abstract layers on top

00:07:13,840 --> 00:07:21,039
of the spd thread where is the sp

00:07:17,680 --> 00:07:23,199
polar which is a abstraction for a

00:07:21,039 --> 00:07:26,240
function that should be repeatedly

00:07:23,199 --> 00:07:28,160
called on the given thread and the other

00:07:26,240 --> 00:07:30,160
one is spdk message

00:07:28,160 --> 00:07:31,919
which is a function pointer and a

00:07:30,160 --> 00:07:34,240
context pointer

00:07:31,919 --> 00:07:36,080
that can be sent from a thread to

00:07:34,240 --> 00:07:38,319
another

00:07:36,080 --> 00:07:40,800
uh the library also defines two

00:07:38,319 --> 00:07:44,160
additional abstractions

00:07:40,800 --> 00:07:48,160
one is spkr device and

00:07:44,160 --> 00:07:50,639
the other is sbl channel

00:07:48,160 --> 00:07:53,360
in order to implement a message passing

00:07:50,639 --> 00:07:57,199
strategy the code would describe

00:07:53,360 --> 00:07:59,759
describe some object within global state

00:07:57,199 --> 00:08:01,199
and also some crossroad context

00:07:59,759 --> 00:08:03,840
associated with that

00:08:01,199 --> 00:08:03,840
abstract

00:08:07,199 --> 00:08:12,080
this makes spd very portable to a widely

00:08:11,280 --> 00:08:17,199
variety

00:08:12,080 --> 00:08:17,199
of asynchronous event based framework

00:08:19,599 --> 00:08:23,759
spd provides a framework for writing a

00:08:22,960 --> 00:08:27,039
synchronous

00:08:23,759 --> 00:08:29,120
pro mode shared nothing several

00:08:27,039 --> 00:08:32,080
applications

00:08:29,120 --> 00:08:32,959
the framework defines several concept

00:08:32,080 --> 00:08:36,080
reactors

00:08:32,959 --> 00:08:39,279
events and lightweight thread

00:08:36,080 --> 00:08:41,760
a reactor the even framework spawns

00:08:39,279 --> 00:08:43,120
when system thread per call reactor

00:08:41,760 --> 00:08:46,880
stands for the system

00:08:43,120 --> 00:08:50,480
thread events reactor

00:08:46,880 --> 00:08:52,839
connect each other with lockless cues

00:08:50,480 --> 00:08:54,560
events can be passed between the

00:08:52,839 --> 00:08:57,920
reactors the lightweight

00:08:54,560 --> 00:09:01,839
trader is a representative for sp thread

00:08:57,920 --> 00:09:05,279
who is the stackless execution unit

00:09:01,839 --> 00:09:08,320
lightweight thread in sp is

00:09:05,279 --> 00:09:11,440
linked in a list inside a

00:09:08,320 --> 00:09:14,560
reactor in this event a framework

00:09:11,440 --> 00:09:15,200
reactor running a while loop round and

00:09:14,560 --> 00:09:18,880
round

00:09:15,200 --> 00:09:22,959
posts its event queue process incoming

00:09:18,880 --> 00:09:25,519
events also post the sp thread attached

00:09:22,959 --> 00:09:27,600
in eight so that is the polar are

00:09:25,519 --> 00:09:31,200
executed

00:09:27,600 --> 00:09:34,560
this framework shows how to put the sp

00:09:31,200 --> 00:09:37,200
at piggy components together as ddd

00:09:34,560 --> 00:09:38,320
community uses data to build their

00:09:37,200 --> 00:09:43,279
applications like

00:09:38,320 --> 00:09:48,399
we use a target it glues spd components

00:09:43,279 --> 00:09:48,399
in a polling programming programming

00:09:48,839 --> 00:09:54,080
model

00:09:50,720 --> 00:09:57,920
so here for sbv whose target is applying

00:09:54,080 --> 00:09:58,240
related components esp with use space

00:09:57,920 --> 00:10:01,440
and

00:09:58,240 --> 00:10:05,040
pulling techniques

00:10:01,440 --> 00:10:08,480
when running ys delivers a target

00:10:05,040 --> 00:10:12,000
first a way the first step

00:10:08,480 --> 00:10:14,880
is if when create a vehicle the device

00:10:12,000 --> 00:10:16,480
at speedg will create a specific sp

00:10:14,880 --> 00:10:19,040
thread

00:10:16,480 --> 00:10:20,240
inside the lightweight as big thread the

00:10:19,040 --> 00:10:23,120
pullers

00:10:20,240 --> 00:10:23,839
are registered to tick and process our

00:10:23,120 --> 00:10:28,320
request

00:10:23,839 --> 00:10:28,320
in virtual cues as a front-end

00:10:28,560 --> 00:10:35,120
block device as a backhand

00:10:32,320 --> 00:10:39,040
all functions are driven by pulling

00:10:35,120 --> 00:10:39,040
exactly same injectors

00:10:40,240 --> 00:10:46,560
now we want to evolve sdk application

00:10:43,519 --> 00:10:49,279
in interrupt mode it should be

00:10:46,560 --> 00:10:50,240
compatible with current sdk event

00:10:49,279 --> 00:10:53,600
framework and

00:10:50,240 --> 00:10:54,160
sdk thread abstraction which is created

00:10:53,600 --> 00:10:56,320
for

00:10:54,160 --> 00:10:57,519
effective message passing a

00:10:56,320 --> 00:11:00,320
synchronization

00:10:57,519 --> 00:11:02,079
and run to completion characteristics

00:11:00,320 --> 00:11:05,200
used by applications

00:11:02,079 --> 00:11:05,200
inside sdk

00:11:05,760 --> 00:11:12,160
the interrupt abstraction object

00:11:08,880 --> 00:11:15,200
now are based on ipo and eventfd

00:11:12,160 --> 00:11:18,399
on linux platform it is the

00:11:15,200 --> 00:11:21,680
core concept to achieve interrupt with

00:11:18,399 --> 00:11:25,360
notify mechanism initially it is

00:11:21,680 --> 00:11:29,279
one import instance with registered

00:11:25,360 --> 00:11:31,440
target values crafters

00:11:29,279 --> 00:11:32,560
different target factors crafters

00:11:31,440 --> 00:11:35,600
represents

00:11:32,560 --> 00:11:36,800
different interrupts or even a cells for

00:11:35,600 --> 00:11:38,959
example

00:11:36,800 --> 00:11:40,320
even fd is used for internal q

00:11:38,959 --> 00:11:44,240
notification

00:11:40,320 --> 00:11:48,800
circuit fd is used for network data

00:11:44,240 --> 00:11:51,839
coming or out notification camera fd

00:11:48,800 --> 00:11:52,639
is used for periodic work we have value

00:11:51,839 --> 00:11:55,040
the fd

00:11:52,639 --> 00:11:56,320
can be used for user space device

00:11:55,040 --> 00:11:58,959
interrupt

00:11:56,320 --> 00:11:59,440
the most important one is cascading the

00:11:58,959 --> 00:12:03,920
hippo

00:11:59,440 --> 00:12:03,920
instance for grouped events

00:12:04,480 --> 00:12:12,000
if we map the interrupt abstraction of

00:12:08,560 --> 00:12:15,680
epo group then we can get spk

00:12:12,000 --> 00:12:18,880
reactor and speaker stride

00:12:15,680 --> 00:12:21,600
to be interactable we'll apply

00:12:18,880 --> 00:12:22,880
interrupt abstraction to reactor the

00:12:21,600 --> 00:12:27,600
reactor itself

00:12:22,880 --> 00:12:31,600
contains one top level e4 instance

00:12:27,600 --> 00:12:34,560
and one import and one event fd

00:12:31,600 --> 00:12:34,880
represents for its internal even the

00:12:34,560 --> 00:12:38,160
queue

00:12:34,880 --> 00:12:40,639
is registered to to the import instance

00:12:38,160 --> 00:12:41,920
or small other registered valid

00:12:40,639 --> 00:12:44,720
scriptors

00:12:41,920 --> 00:12:46,000
are all sub-level import instance which

00:12:44,720 --> 00:12:49,200
represents

00:12:46,000 --> 00:12:51,519
spk thrice which is attached to this

00:12:49,200 --> 00:12:54,800
reactor

00:12:51,519 --> 00:12:57,120
as we just decide sdk thread itself

00:12:54,800 --> 00:12:58,480
also contains one input instance as a

00:12:57,120 --> 00:13:01,279
central row

00:12:58,480 --> 00:13:04,160
then we can register corresponding file

00:13:01,279 --> 00:13:04,160
disk factors

00:13:04,560 --> 00:13:11,839
to the thread epo instance instead of

00:13:08,079 --> 00:13:14,880
registering polars to svg's right

00:13:11,839 --> 00:13:19,040
for example at force

00:13:14,880 --> 00:13:21,920
message q polar or mass q process

00:13:19,040 --> 00:13:23,839
event can be replaced by one event fd

00:13:21,920 --> 00:13:27,360
for mass queue

00:13:23,839 --> 00:13:30,240
polars with interval time can be

00:13:27,360 --> 00:13:31,040
replaced by timer fd hardware queue

00:13:30,240 --> 00:13:34,000
polars

00:13:31,040 --> 00:13:36,079
for enemy device or withheld device can

00:13:34,000 --> 00:13:40,399
be replaced by vfl

00:13:36,079 --> 00:13:44,079
event fd mbd powers can be replaced by

00:13:40,399 --> 00:13:47,519
just registering its ffd to the

00:13:44,079 --> 00:13:51,279
iphone instance aiopdel

00:13:47,519 --> 00:13:54,480
can use immediately together with rpl

00:13:51,279 --> 00:13:56,800
if a soccer group applied

00:13:54,480 --> 00:13:57,920
interrupt abstraction for its

00:13:56,800 --> 00:14:01,760
connections

00:13:57,920 --> 00:14:04,639
then sk or oem f4

00:14:01,760 --> 00:14:07,760
polars can be triggered directly by the

00:14:04,639 --> 00:14:07,760
subgroup interrupt

00:14:09,040 --> 00:14:12,959
after applying interrupt abstraction

00:14:11,680 --> 00:14:16,240
into reactor

00:14:12,959 --> 00:14:17,199
and acidic stride then one sdk

00:14:16,240 --> 00:14:20,320
application

00:14:17,199 --> 00:14:23,760
can run in such a method to get itself

00:14:20,320 --> 00:14:23,760
running in interrupt mode

00:14:24,160 --> 00:14:30,480
the application will do block weight

00:14:27,199 --> 00:14:32,320
on reactor ipo instance and do not block

00:14:30,480 --> 00:14:33,600
weight on speakers throughout the epoch

00:14:32,320 --> 00:14:37,920
instance

00:14:33,600 --> 00:14:40,399
then the system strikes of the reactors

00:14:37,920 --> 00:14:43,360
will only get blocked at the reactor

00:14:40,399 --> 00:14:43,360
equal instance

00:14:43,680 --> 00:14:47,760
if the equal instance of reactor wakes

00:14:46,399 --> 00:14:50,959
up from

00:14:47,760 --> 00:14:52,880
is even the queue then it directly comes

00:14:50,959 --> 00:14:57,279
to the unq and plus

00:14:52,880 --> 00:15:00,720
process event if it is

00:14:57,279 --> 00:15:03,760
waking up from one i speak

00:15:00,720 --> 00:15:08,079
through the message then the reactor

00:15:03,760 --> 00:15:09,839
will come to the specific sdk slide

00:15:08,079 --> 00:15:11,600
and then the thread will process the

00:15:09,839 --> 00:15:15,600
message queue

00:15:11,600 --> 00:15:18,639
if there is one epio

00:15:15,600 --> 00:15:20,160
l completion then the reactor in for

00:15:18,639 --> 00:15:23,040
instance will

00:15:20,160 --> 00:15:23,920
wake up and come to that specific spdk

00:15:23,040 --> 00:15:26,800
slide

00:15:23,920 --> 00:15:28,959
and then the thread will come to process

00:15:26,800 --> 00:15:32,000
the liberal

00:15:28,959 --> 00:15:35,600
event each time

00:15:32,000 --> 00:15:38,800
the process is completed after waking up

00:15:35,600 --> 00:15:41,759
the system thread will come back

00:15:38,800 --> 00:15:44,320
to reactor and the block on reactor e4

00:15:41,759 --> 00:15:44,320
instance

00:15:45,519 --> 00:15:51,440
spdk further provides a full block stack

00:15:48,639 --> 00:15:54,880
as a user switch library that performs

00:15:51,440 --> 00:15:57,759
many of the same operations as a

00:15:54,880 --> 00:15:58,959
block stack in an operating system

00:15:57,759 --> 00:16:01,120
kernel

00:15:58,959 --> 00:16:03,199
all of them are designed around message

00:16:01,120 --> 00:16:06,320
passing instead of locking

00:16:03,199 --> 00:16:08,480
and most of the spk libraries

00:16:06,320 --> 00:16:10,800
makes several assumptions like message

00:16:08,480 --> 00:16:13,759
passing you want call rooting

00:16:10,800 --> 00:16:16,000
or later wait threading framework so if

00:16:13,759 --> 00:16:18,160
the underlying threading model

00:16:16,000 --> 00:16:19,920
is interruptable then many of the

00:16:18,160 --> 00:16:22,880
libraries inside spdk

00:16:19,920 --> 00:16:24,160
can run directly in in interrupt mode

00:16:22,880 --> 00:16:27,360
for example

00:16:24,160 --> 00:16:30,560
the basic beta modules like

00:16:27,360 --> 00:16:33,839
ready to be down without gpt of

00:16:30,560 --> 00:16:36,399
malok video for sdk

00:16:33,839 --> 00:16:37,199
blob store and it's up layer logic

00:16:36,399 --> 00:16:39,360
volume

00:16:37,199 --> 00:16:41,600
you can always run directly in interrupt

00:16:39,360 --> 00:16:46,560
mode without any modification

00:16:41,600 --> 00:16:49,920
for sdk block fis and its fuse module

00:16:46,560 --> 00:16:50,639
they can also run directly in interrupt

00:16:49,920 --> 00:16:53,920
mode

00:16:50,639 --> 00:16:57,519
without any modification

00:16:53,920 --> 00:16:57,920
so here we have prepared a minimal set

00:16:57,519 --> 00:17:02,079
of

00:16:57,920 --> 00:17:04,160
interactable warehouse target

00:17:02,079 --> 00:17:05,439
interrupt mode for secure container

00:17:04,160 --> 00:17:09,760
evaluation

00:17:05,439 --> 00:17:13,600
based on some interrupt mode purchase

00:17:09,760 --> 00:17:14,720
it will use linux aopdo as the storage

00:17:13,600 --> 00:17:18,079
backend

00:17:14,720 --> 00:17:22,160
it will export linux mbd server

00:17:18,079 --> 00:17:24,880
is host and it will provide provider

00:17:22,160 --> 00:17:25,679
warehouse block device to the

00:17:24,880 --> 00:17:29,840
lightweight

00:17:25,679 --> 00:17:32,799
virtual machine of secure container

00:17:29,840 --> 00:17:35,280
a flexible block stack with logical

00:17:32,799 --> 00:17:35,280
volume

00:17:36,799 --> 00:17:44,559
azir for advanced block operations

00:17:41,520 --> 00:17:47,919
users can also manage this

00:17:44,559 --> 00:17:50,960
evaluation application still

00:17:47,919 --> 00:17:54,240
by svk rpc methods the

00:17:50,960 --> 00:17:56,480
difference of this application with

00:17:54,240 --> 00:17:58,000
general aspect application is that it

00:17:56,480 --> 00:18:01,120
won't be pulling

00:17:58,000 --> 00:18:03,039
or occupying cpu cores anymore when

00:18:01,120 --> 00:18:05,600
there is no workload

00:18:03,039 --> 00:18:06,640
its cpu percentage is lower than one

00:18:05,600 --> 00:18:10,160
percentage

00:18:06,640 --> 00:18:10,160
is lower than one percent

00:18:11,120 --> 00:18:17,440
a set of tools are provided by sdk

00:18:14,400 --> 00:18:18,799
some of them are also easy to run in

00:18:17,440 --> 00:18:21,919
interrupt mode

00:18:18,799 --> 00:18:24,559
for example the video protocol it is a

00:18:21,919 --> 00:18:24,559
benchmark

00:18:25,360 --> 00:18:32,080
tool of svg block device

00:18:28,480 --> 00:18:35,039
for slide and

00:18:32,080 --> 00:18:35,039
even work cost

00:18:39,360 --> 00:18:45,679
a set of tools are provided by sdk

00:18:42,480 --> 00:18:48,400
some of them are also easy to run in

00:18:45,679 --> 00:18:49,360
interrupt mode for example for video

00:18:48,400 --> 00:18:57,840
protocol

00:18:49,360 --> 00:18:57,840
it is a benchmark it is a performance

00:18:59,280 --> 00:19:05,360
a set of tools are provided by svdk

00:19:02,559 --> 00:19:07,360
some of them are also easy to draw in

00:19:05,360 --> 00:19:10,320
interrupt mode for example

00:19:07,360 --> 00:19:12,400
for video profitable it is a performance

00:19:10,320 --> 00:19:15,919
benchmark tool of svk

00:19:12,400 --> 00:19:19,039
block devices for thread and

00:19:15,919 --> 00:19:21,840
event framework cost we have

00:19:19,039 --> 00:19:24,000
added a parameter to video curve to set

00:19:21,840 --> 00:19:27,360
interrupt mode flag

00:19:24,000 --> 00:19:29,760
with this simple modification

00:19:27,360 --> 00:19:31,360
we got some brief performance evaluation

00:19:29,760 --> 00:19:34,640
and interrupt mode

00:19:31,360 --> 00:19:39,200
for you to have a preview of course

00:19:34,640 --> 00:19:39,200
there is a obvious performance drawdown

00:19:39,600 --> 00:19:46,400
it outputs a memory video

00:19:42,799 --> 00:19:47,440
it shows about the throughput of

00:19:46,400 --> 00:19:50,559
interrupt mode

00:19:47,440 --> 00:19:52,240
is less than one third of the throughput

00:19:50,559 --> 00:19:55,360
of poly mode

00:19:52,240 --> 00:19:59,120
the juan vidal park on me based

00:19:55,360 --> 00:20:01,840
alp dao it shows about the throughput of

00:19:59,120 --> 00:20:05,360
interrupt mode is

00:20:01,840 --> 00:20:08,559
around five to eight percent

00:20:05,360 --> 00:20:10,640
worse than pulling mode this

00:20:08,559 --> 00:20:12,400
is not good for extremely high

00:20:10,640 --> 00:20:15,840
performance situation

00:20:12,400 --> 00:20:20,240
but for the container scenario

00:20:15,840 --> 00:20:23,760
it will be enough

00:20:20,240 --> 00:20:26,799
the last part on top of interrupt

00:20:23,760 --> 00:20:30,880
interruptable s3 application

00:20:26,799 --> 00:20:34,000
we can provide a secure

00:20:30,880 --> 00:20:36,720
container storage service at

00:20:34,000 --> 00:20:37,039
start the most straightforward step is

00:20:36,720 --> 00:20:40,960
to

00:20:37,039 --> 00:20:40,960
providing device volume

00:20:41,280 --> 00:20:47,440
from a spdkv host by doc command

00:20:45,360 --> 00:20:49,520
provider volume service to carta

00:20:47,440 --> 00:20:52,799
containers via the interrupted

00:20:49,520 --> 00:20:56,159
sbv host target

00:20:52,799 --> 00:20:59,679
and sp

00:20:56,159 --> 00:21:03,039
logic volume can do things promoting

00:20:59,679 --> 00:21:06,720
and snapshot like a logical

00:21:03,039 --> 00:21:08,480
volume on the device member sp logic

00:21:06,720 --> 00:21:11,440
volume provides basic

00:21:08,480 --> 00:21:12,880
functionalities to meet a container root

00:21:11,440 --> 00:21:15,520
fs

00:21:12,880 --> 00:21:16,640
provide root face service to carta

00:21:15,520 --> 00:21:18,880
containers

00:21:16,640 --> 00:21:19,840
where the interrupter sbb hosts the

00:21:18,880 --> 00:21:22,960
target

00:21:19,840 --> 00:21:22,960
under the continuity

00:21:24,720 --> 00:21:31,440
how uses spd is much

00:21:28,159 --> 00:21:33,760
more diverse than we expect

00:21:31,440 --> 00:21:34,640
from a speaking hub issue and select

00:21:33,760 --> 00:21:37,600
channel

00:21:34,640 --> 00:21:38,240
we realized that there are users who run

00:21:37,600 --> 00:21:41,280
sp

00:21:38,240 --> 00:21:45,360
inside the docker container when

00:21:41,280 --> 00:21:48,480
can turn it containering isp application

00:21:45,360 --> 00:21:49,280
there are no spdk specific changes

00:21:48,480 --> 00:21:52,320
needed

00:21:49,280 --> 00:21:53,039
however general speed application always

00:21:52,320 --> 00:21:56,320
requires

00:21:53,039 --> 00:22:00,559
dedicated cpu costs and huge memories

00:21:56,320 --> 00:22:04,080
so exclusive resource occu

00:22:00,559 --> 00:22:07,120
patient is a main issue for continuing

00:22:04,080 --> 00:22:10,000
spdk application if

00:22:07,120 --> 00:22:10,799
sp application inside the container is

00:22:10,000 --> 00:22:14,240
running

00:22:10,799 --> 00:22:18,080
in the interrupt mode also with

00:22:14,240 --> 00:22:21,120
night huge memory the container

00:22:18,080 --> 00:22:26,640
density will not be impacted by a

00:22:21,120 --> 00:22:30,400
btk container

00:22:26,640 --> 00:22:31,280
and currently only basic interrupt mode

00:22:30,400 --> 00:22:33,840
is supported

00:22:31,280 --> 00:22:35,520
if we want to get sbd to be more

00:22:33,840 --> 00:22:38,159
suitable to

00:22:35,520 --> 00:22:40,280
uh secure container scenarios from

00:22:38,159 --> 00:22:45,360
container in

00:22:40,280 --> 00:22:45,360
infrastructure to container instance

00:22:46,799 --> 00:22:53,919
so let's give a summary first pulling

00:22:51,760 --> 00:22:55,520
pin the cpu and huge memory player

00:22:53,919 --> 00:22:58,720
location can be avoided

00:22:55,520 --> 00:23:01,600
from non-performance situation with the

00:22:58,720 --> 00:23:04,400
interrupt mode spdw host will be a good

00:23:01,600 --> 00:23:09,200
choice to provide a storage service

00:23:04,400 --> 00:23:13,679
to secure containers

00:23:09,200 --> 00:23:17,120
and for the future in

00:23:13,679 --> 00:23:19,360
involution we may either interrupt

00:23:17,120 --> 00:23:20,320
support on your space hardware block

00:23:19,360 --> 00:23:23,440
device packing

00:23:20,320 --> 00:23:26,240
such as the mme driver and the block

00:23:23,440 --> 00:23:29,760
layer with whole device driver and the

00:23:26,240 --> 00:23:32,799
block device layer and also we can add

00:23:29,760 --> 00:23:33,840
interrupt support or modules related

00:23:32,799 --> 00:23:37,440
with

00:23:33,840 --> 00:23:38,400
the network protocol such as mme or

00:23:37,440 --> 00:23:41,919
fabrics

00:23:38,400 --> 00:23:44,640
under the ice cushion also with a

00:23:41,919 --> 00:23:45,039
running mode switch between the pulling

00:23:44,640 --> 00:23:48,400
and the

00:23:45,039 --> 00:23:51,840
interrupt the last

00:23:48,400 --> 00:23:55,679
is we can official

00:23:51,840 --> 00:23:59,360
nine huge memory support for all the net

00:23:55,679 --> 00:23:59,360
dma sp application

00:23:59,679 --> 00:24:05,840
uh that's all for today's presentation

00:24:03,360 --> 00:24:05,840

YouTube URL: https://www.youtube.com/watch?v=vYcnTzhwqt4


