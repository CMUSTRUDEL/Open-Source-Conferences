Title: Challenges in Supporting Virtual CPU Hotplug on SoC Based Systems (like ARM64) - Salil Mehta, Huawei
Publication date: 2020-11-10
Playlist: KVM Forum Europe 2020
Description: 
	Challenges in Supporting Virtual CPU Hotplug on SoC Based Systems (like ARM64) - Salil Mehta, Huawei
Captions: 
	00:00:08,000 --> 00:00:12,480
hello everyone

00:00:09,200 --> 00:00:14,240
um welcome to my presentation

00:00:12,480 --> 00:00:16,160
so the topic for the presentation is

00:00:14,240 --> 00:00:19,039
challenges in supporting virtual cpu hot

00:00:16,160 --> 00:00:22,320
plug in shock-based systems like arm64

00:00:19,039 --> 00:00:23,119
well uh i am system software architect

00:00:22,320 --> 00:00:27,840
working at

00:00:23,119 --> 00:00:31,439
huawei technologies cambridge uk uh uk

00:00:27,840 --> 00:00:34,000
and um

00:00:31,439 --> 00:00:36,000
primarily in my past i've done a lot of

00:00:34,000 --> 00:00:39,200
networking stuff

00:00:36,000 --> 00:00:43,520
dealt with system aspects of

00:00:39,200 --> 00:00:44,079
it here in huawei i'm also official

00:00:43,520 --> 00:00:47,360
maintainer

00:00:44,079 --> 00:00:49,039
of their networking driver hns across

00:00:47,360 --> 00:00:50,550
different stocks

00:00:49,039 --> 00:00:52,160
and

00:00:50,550 --> 00:00:55,039
[Music]

00:00:52,160 --> 00:00:56,960
in my recent attempt beside this virtual

00:00:55,039 --> 00:01:00,079
cp hot plug i've been

00:00:56,960 --> 00:01:04,719
also involved in

00:01:00,079 --> 00:01:04,719
enabling xdp on hns driver

00:01:06,799 --> 00:01:10,640
agenda for today's presentation is

00:01:10,720 --> 00:01:14,479
in the recent past there have been

00:01:12,159 --> 00:01:17,119
attempts made to add the support of the

00:01:14,479 --> 00:01:18,799
virtual cpr plug for arm 64

00:01:17,119 --> 00:01:20,240
based systems in chemo and linux guest

00:01:18,799 --> 00:01:22,320
clone

00:01:20,240 --> 00:01:24,720
we have received some sort of a mixed

00:01:22,320 --> 00:01:26,960
reviews from the community

00:01:24,720 --> 00:01:30,079
and though some vendors have practical

00:01:26,960 --> 00:01:32,960
reasons to have such a support added

00:01:30,079 --> 00:01:33,200
but a few of the community members have

00:01:32,960 --> 00:01:36,000
an

00:01:33,200 --> 00:01:37,520
improvement apprehension as well to

00:01:36,000 --> 00:01:40,799
support it

00:01:37,520 --> 00:01:42,399
so this presentation is an attempt to

00:01:40,799 --> 00:01:44,479
highlight the key issues in supporting

00:01:42,399 --> 00:01:48,960
the virtual cpr plug

00:01:44,479 --> 00:01:48,960
feature for arm64 based socks

00:01:50,240 --> 00:01:54,880
outline so

00:01:53,280 --> 00:01:56,399
the entire presentation has been divided

00:01:54,880 --> 00:01:59,439
into some sort of a very quick

00:01:56,399 --> 00:02:01,520
overview uh and then we'll go through

00:01:59,439 --> 00:02:03,439
the known challenges across the system

00:02:01,520 --> 00:02:06,240
architecture kvm host

00:02:03,439 --> 00:02:08,160
hemovirtualizer guest kernel and we'll

00:02:06,240 --> 00:02:11,920
discuss the workarounds

00:02:08,160 --> 00:02:14,000
uh some implementation

00:02:11,920 --> 00:02:15,840
attempts have been made in the past and

00:02:14,000 --> 00:02:17,760
the recent times as well

00:02:15,840 --> 00:02:19,760
we'll see the problem being faced in

00:02:17,760 --> 00:02:20,720
them and then summary we'll discuss

00:02:19,760 --> 00:02:22,480
about the future work

00:02:20,720 --> 00:02:24,879
and then we'll open the session for the

00:02:22,480 --> 00:02:24,879
q a

00:02:25,599 --> 00:02:29,040
so why do we need a cp hot plug in

00:02:27,840 --> 00:02:32,640
general what we know

00:02:29,040 --> 00:02:35,599
is it can be used for provisioning

00:02:32,640 --> 00:02:36,000
uh while progress name rather so for

00:02:35,599 --> 00:02:40,080
example

00:02:36,000 --> 00:02:42,319
in case of pre-provisioned uh resources

00:02:40,080 --> 00:02:44,080
but which are auto scaled uh so

00:02:42,319 --> 00:02:47,920
orchestration frameworks like

00:02:44,080 --> 00:02:48,400
k8s can use a feature called as vertical

00:02:47,920 --> 00:02:51,040
port or

00:02:48,400 --> 00:02:52,480
scaling in which they can add up a

00:02:51,040 --> 00:02:55,120
certain cpu resources

00:02:52,480 --> 00:02:57,120
and remove them dynamically depending

00:02:55,120 --> 00:02:59,200
upon their occupancy for example during

00:02:57,120 --> 00:03:01,280
the night server systems are less

00:02:59,200 --> 00:03:03,510
occupant so they might like to remove

00:03:01,280 --> 00:03:05,519
certain cpus

00:03:03,510 --> 00:03:07,920
[Music]

00:03:05,519 --> 00:03:08,800
and it can also be done for the load

00:03:07,920 --> 00:03:10,560
balancing

00:03:08,800 --> 00:03:12,560
the thing is the on-demand provisioning

00:03:10,560 --> 00:03:14,159
so a very good example is the capacity

00:03:12,560 --> 00:03:16,159
of grid on demand in which

00:03:14,159 --> 00:03:17,200
certain kind of customers would like to

00:03:16,159 --> 00:03:21,760
add

00:03:17,200 --> 00:03:25,040
uh or increase the capacity later on

00:03:21,760 --> 00:03:25,599
once their business have grown in so now

00:03:25,040 --> 00:03:29,360
they have

00:03:25,599 --> 00:03:33,200
kind of uh they can afford

00:03:29,360 --> 00:03:35,360
that kind of so

00:03:33,200 --> 00:03:36,799
it is used for that purposes as well so

00:03:35,360 --> 00:03:39,680
you need a basic

00:03:36,799 --> 00:03:41,920
cpu feature to be able to support this

00:03:39,680 --> 00:03:46,159
particular demand

00:03:41,920 --> 00:03:49,760
and then it can be used to isolate

00:03:46,159 --> 00:03:50,959
the error causing cpus uh the offending

00:03:49,760 --> 00:03:52,560
cpus within the system

00:03:50,959 --> 00:03:55,200
due to the errors identified due to

00:03:52,560 --> 00:03:57,200
errors and uh

00:03:55,200 --> 00:03:59,280
this guy this might be required just

00:03:57,200 --> 00:04:00,000
because uh to stop the propagation of

00:03:59,280 --> 00:04:02,319
the errors

00:04:00,000 --> 00:04:03,040
within the system but i'm not very sure

00:04:02,319 --> 00:04:04,480
this is

00:04:03,040 --> 00:04:06,159
uh something which makes sense in the

00:04:04,480 --> 00:04:09,760
virtual world

00:04:06,159 --> 00:04:12,319
but anyways um uh another

00:04:09,760 --> 00:04:14,640
uh reason could be for onlining and

00:04:12,319 --> 00:04:17,680
offlining the cpus for the suspend

00:04:14,640 --> 00:04:19,120
resume this kind of support has been

00:04:17,680 --> 00:04:21,600
there for the arm 64-base

00:04:19,120 --> 00:04:23,520
systems for quite long and this is based

00:04:21,600 --> 00:04:27,280
upon pesci

00:04:23,520 --> 00:04:30,080
calls uh cp of base art plug

00:04:27,280 --> 00:04:33,360
and you could see this support is

00:04:30,080 --> 00:04:36,800
already there as part of their

00:04:33,360 --> 00:04:39,120
kernel changes

00:04:36,800 --> 00:04:40,720
for quite long and has been there

00:04:39,120 --> 00:04:42,400
there's bitter for detail which i've

00:04:40,720 --> 00:04:44,000
mentioned as part of the links you can

00:04:42,400 --> 00:04:45,600
see below and you would like to read

00:04:44,000 --> 00:04:49,919
them

00:04:45,600 --> 00:04:49,919
i'll just skip for now

00:04:50,960 --> 00:04:56,000
well there's certain even sequences

00:04:54,320 --> 00:04:59,040
which happens while you plug in

00:04:56,000 --> 00:05:03,360
the cpu and while you unplug the

00:04:59,040 --> 00:05:07,440
cpu so this is for the virtual cpr plug

00:05:03,360 --> 00:05:10,800
so um i've just added these diagrams

00:05:07,440 --> 00:05:11,600
as a completeness these are very well

00:05:10,800 --> 00:05:13,919
understood

00:05:11,600 --> 00:05:15,759
uh framework and has already been part

00:05:13,919 --> 00:05:18,320
of the kernel for quite long

00:05:15,759 --> 00:05:19,600
uh i'll just kind of scratch through it

00:05:18,320 --> 00:05:21,919
uh to get

00:05:19,600 --> 00:05:24,400
uh things started so we can see

00:05:21,919 --> 00:05:27,680
different layers like

00:05:24,400 --> 00:05:30,080
hardware host kvm kimo

00:05:27,680 --> 00:05:30,960
then acp interface and the guest kernel

00:05:30,080 --> 00:05:35,199
whenever the

00:05:30,960 --> 00:05:37,600
cpu is plugged or unplugged the

00:05:35,199 --> 00:05:39,440
events gets exchanged from the chemo

00:05:37,600 --> 00:05:40,320
through the sap interface to the guest

00:05:39,440 --> 00:05:45,039
kernel

00:05:40,320 --> 00:05:47,039
so certain kind of events get

00:05:45,039 --> 00:05:48,160
sent by the guest os to the queue as

00:05:47,039 --> 00:05:51,440
well through the

00:05:48,160 --> 00:05:54,320
acpi cpu control device

00:05:51,440 --> 00:05:55,759
and for the events uh from the kimo to

00:05:54,320 --> 00:05:59,840
the guestos

00:05:55,759 --> 00:06:01,919
ged device is used uh to intimate

00:05:59,840 --> 00:06:03,039
the kind of event which is uh which has

00:06:01,919 --> 00:06:06,400
happened

00:06:03,039 --> 00:06:06,880
so uh eventual result of these event is

00:06:06,400 --> 00:06:10,080
to

00:06:06,880 --> 00:06:11,199
kind of uh know first of all what event

00:06:10,080 --> 00:06:14,319
has happened and then

00:06:11,199 --> 00:06:17,039
uh to associate for example in case of

00:06:14,319 --> 00:06:20,880
the hot plug

00:06:17,039 --> 00:06:21,520
the the physical id which in arm term we

00:06:20,880 --> 00:06:24,080
call

00:06:21,520 --> 00:06:25,440
it as an mp idea to that of the logical

00:06:24,080 --> 00:06:29,440
cpu id

00:06:25,440 --> 00:06:33,120
and of course the

00:06:29,440 --> 00:06:36,720
in case of the reverse that is unplug

00:06:33,120 --> 00:06:38,960
you uh you identify

00:06:36,720 --> 00:06:40,560
the cpu which is being unplugged and

00:06:38,960 --> 00:06:41,199
then you try to offline that particular

00:06:40,560 --> 00:06:44,639
cpu

00:06:41,199 --> 00:06:47,280
and and the eject action takes place

00:06:44,639 --> 00:06:48,240
so i would i won't be going into detail

00:06:47,280 --> 00:06:50,240
and said

00:06:48,240 --> 00:06:51,280
uh as i said uh these are well

00:06:50,240 --> 00:06:53,520
understood uh

00:06:51,280 --> 00:06:54,479
concepts and my idea about

00:06:53,520 --> 00:06:57,680
representation

00:06:54,479 --> 00:06:58,639
is uh to assume you know already these

00:06:57,680 --> 00:07:01,280
things and

00:06:58,639 --> 00:07:03,680
i'm gonna present further the known

00:07:01,280 --> 00:07:07,360
challenges

00:07:03,680 --> 00:07:10,800
so in the in the in the previous past

00:07:07,360 --> 00:07:16,319
uh there have been certain attempts but

00:07:10,800 --> 00:07:19,599
uh what have been kind of

00:07:16,319 --> 00:07:22,080
you know attempts to uh add up

00:07:19,599 --> 00:07:22,720
this virtual cpr product support but

00:07:22,080 --> 00:07:25,039
there have been

00:07:22,720 --> 00:07:27,440
uh some problems what we have faced

00:07:25,039 --> 00:07:29,440
across different areas so

00:07:27,440 --> 00:07:30,270
in case of the arm64 system architecture

00:07:29,440 --> 00:07:32,319
first of all

00:07:30,270 --> 00:07:36,000
[Music]

00:07:32,319 --> 00:07:37,360
we know that the system architecture

00:07:36,000 --> 00:07:40,639
assets does not have

00:07:37,360 --> 00:07:42,720
any concept of physical cp hot plug

00:07:40,639 --> 00:07:44,560
there's no specification as such from

00:07:42,720 --> 00:07:46,879
the arm which defines

00:07:44,560 --> 00:07:48,400
any standard way to realize a virtual

00:07:46,879 --> 00:07:50,720
cpr plug either

00:07:48,400 --> 00:07:53,199
because you don't have a physical cpr

00:07:50,720 --> 00:07:56,000
plug specification

00:07:53,199 --> 00:07:57,840
on the other hand the arm components

00:07:56,000 --> 00:07:59,919
like gig

00:07:57,840 --> 00:08:02,560
also have not been designed to realize a

00:07:59,919 --> 00:08:04,879
physical cpu output capability

00:08:02,560 --> 00:08:12,879
as such gig requires all the cpus to be

00:08:04,879 --> 00:08:15,759
present at initialization

00:08:12,879 --> 00:08:16,319
now known challenges within the host kvm

00:08:15,759 --> 00:08:18,560
uh

00:08:16,319 --> 00:08:20,800
kvm also requires all the vcpus to be

00:08:18,560 --> 00:08:24,479
created during the vmware time

00:08:20,800 --> 00:08:27,919
um now this is something

00:08:24,479 --> 00:08:28,720
which you can say uh is kind of

00:08:27,919 --> 00:08:31,919
reflecting

00:08:28,720 --> 00:08:35,760
what the system architecture requires in

00:08:31,919 --> 00:08:35,760
but because

00:08:36,080 --> 00:08:40,159
it it should have all the vcps created

00:08:39,519 --> 00:08:43,680
and

00:08:40,159 --> 00:08:46,880
it has some sort of uh uh

00:08:43,680 --> 00:08:49,360
you know effects on other components uh

00:08:46,880 --> 00:08:52,720
which are part of the kvm for example

00:08:49,360 --> 00:08:55,360
uh the vcpu uh

00:08:52,720 --> 00:08:57,360
each vcpu will have v git related

00:08:55,360 --> 00:08:58,800
resources initialized and fixed during

00:08:57,360 --> 00:09:01,920
the creation

00:08:58,800 --> 00:09:04,480
uh and various uh

00:09:01,920 --> 00:09:05,440
vga per cpu static data structures for

00:09:04,480 --> 00:09:09,120
example they

00:09:05,440 --> 00:09:12,560
need to be initialized early

00:09:09,120 --> 00:09:14,480
some config of the related uh

00:09:12,560 --> 00:09:17,120
private interrupts for example sds and

00:09:14,480 --> 00:09:17,519
ppis they also need to be present at the

00:09:17,120 --> 00:09:20,399
time

00:09:17,519 --> 00:09:22,640
when the cpus are created so they get

00:09:20,399 --> 00:09:26,240
initialized at that time right

00:09:22,640 --> 00:09:27,640
and also uh any resources like memory

00:09:26,240 --> 00:09:30,959
regions related

00:09:27,640 --> 00:09:34,399
redistributors they also need to be uh

00:09:30,959 --> 00:09:34,959
done uh at the vmware time right so for

00:09:34,399 --> 00:09:38,240
example

00:09:34,959 --> 00:09:40,000
whenever those the vcpus are getting

00:09:38,240 --> 00:09:40,880
created and that time basically all

00:09:40,000 --> 00:09:43,360
these

00:09:40,880 --> 00:09:44,880
resources memory regions data structures

00:09:43,360 --> 00:09:47,920
get initialized

00:09:44,880 --> 00:09:52,080
and uh you cannot change them later on

00:09:47,920 --> 00:09:54,720
so uh it's all related to

00:09:52,080 --> 00:09:56,560
the vcpus which should be great which

00:09:54,720 --> 00:09:59,040
should be present

00:09:56,560 --> 00:10:02,000
and get should get created all during

00:09:59,040 --> 00:10:02,000
the vm in a time

00:10:02,560 --> 00:10:06,320
once the vcps have been created in the

00:10:04,320 --> 00:10:07,120
host kvm their destruction is also not

00:10:06,320 --> 00:10:08,959
reported yet

00:10:07,120 --> 00:10:10,240
this is not something which is on 64

00:10:08,959 --> 00:10:13,279
specific but

00:10:10,240 --> 00:10:15,120
intel uh architecture also has got the

00:10:13,279 --> 00:10:17,680
same limitation in the kvm

00:10:15,120 --> 00:10:19,440
but there are workarounds around this so

00:10:17,680 --> 00:10:20,640
this is not a big challenge but

00:10:19,440 --> 00:10:23,360
people have already solved this

00:10:20,640 --> 00:10:23,360
particular part

00:10:25,330 --> 00:10:30,839
[Music]

00:10:27,440 --> 00:10:33,839
also we know that generally

00:10:30,839 --> 00:10:35,760
the the

00:10:33,839 --> 00:10:38,000
mpidr is something which uniquely

00:10:35,760 --> 00:10:41,440
identifies the vcp in the system

00:10:38,000 --> 00:10:44,880
and for the virtual world

00:10:41,440 --> 00:10:46,959
as of now this particular value

00:10:44,880 --> 00:10:50,160
of the resistor is getting derived and

00:10:46,959 --> 00:10:52,399
set by the kvm

00:10:50,160 --> 00:10:53,600
ideally it should be a responsibility of

00:10:52,399 --> 00:10:57,519
the user space

00:10:53,600 --> 00:10:57,519
instead of the kvm and

00:10:58,560 --> 00:11:01,680
right now it is being derived using the

00:11:00,160 --> 00:11:04,880
vcp id uh

00:11:01,680 --> 00:11:07,040
which is sent by the chemo to the kvm

00:11:04,880 --> 00:11:08,079
and it does some sort of a mapping as

00:11:07,040 --> 00:11:11,279
you can see uh

00:11:08,079 --> 00:11:14,480
in the diagram and derives the

00:11:11,279 --> 00:11:15,760
uh the mpidr value which gets programmed

00:11:14,480 --> 00:11:18,959
into vip idea

00:11:15,760 --> 00:11:21,360
or register for that particular

00:11:18,959 --> 00:11:21,360
cpu

00:11:26,079 --> 00:11:31,920
so at the chemo level um

00:11:30,000 --> 00:11:34,079
because there's a limitation imposed by

00:11:31,920 --> 00:11:36,320
the v-geck at the host kvm level

00:11:34,079 --> 00:11:37,279
given must create and initialize all the

00:11:36,320 --> 00:11:41,120
vcpus at the

00:11:37,279 --> 00:11:44,079
word mark in a time now uh

00:11:41,120 --> 00:11:45,040
this has got a ripple effect kind of

00:11:44,079 --> 00:11:48,320
thing because

00:11:45,040 --> 00:11:51,440
you need to do this thing must then

00:11:48,320 --> 00:11:54,160
ensure all uh the complete

00:11:51,440 --> 00:11:56,160
initialization of the git as well

00:11:54,160 --> 00:11:57,360
this includes initialization of all the

00:11:56,160 --> 00:12:01,600
redistributors

00:11:57,360 --> 00:12:03,680
its related to all possible vcpus

00:12:01,600 --> 00:12:05,360
realization of vcpus and its threads in

00:12:03,680 --> 00:12:07,360
keyboard might not be desirable for

00:12:05,360 --> 00:12:11,839
possible vcpus which are

00:12:07,360 --> 00:12:11,839
in disabled state

00:12:20,480 --> 00:12:24,000
also the unwiring of the interrupt

00:12:22,320 --> 00:12:25,200
setups between the vcpus

00:12:24,000 --> 00:12:27,920
and the git requires further

00:12:25,200 --> 00:12:31,040
consideration in qmm

00:12:27,920 --> 00:12:31,600
and this is something which is not

00:12:31,040 --> 00:12:34,720
present

00:12:31,600 --> 00:12:36,720
by default uh in the chemo so

00:12:34,720 --> 00:12:38,720
as part of the changes of the vc virtual

00:12:36,720 --> 00:12:40,800
cpu plug this has this support has been

00:12:38,720 --> 00:12:43,519
added

00:12:40,800 --> 00:12:46,160
for arm 64 kimu lacks support to

00:12:43,519 --> 00:12:48,639
correctly specify the cpu topology

00:12:46,160 --> 00:12:51,360
that is on the basis of saw cluster

00:12:48,639 --> 00:12:53,120
course threads

00:12:51,360 --> 00:12:55,279
this is required to uniquely identify a

00:12:53,120 --> 00:12:58,320
vcp being plugged or unplugged

00:12:55,279 --> 00:13:01,839
and uh ideally

00:12:58,320 --> 00:13:05,600
this should be mapped to something

00:13:01,839 --> 00:13:10,000
uh like mp idea empid

00:13:05,600 --> 00:13:10,000
is unique remember and

00:13:11,279 --> 00:13:16,639
it's kind of broken

00:13:14,480 --> 00:13:17,600
for a physical system it does have the

00:13:16,639 --> 00:13:19,839
affinity

00:13:17,600 --> 00:13:21,040
but that affinity is something which we

00:13:19,839 --> 00:13:24,079
cannot use

00:13:21,040 --> 00:13:27,760
as suggested by our people to uh get the

00:13:24,079 --> 00:13:30,800
cp topology information so it has got

00:13:27,760 --> 00:13:34,639
no relation as such we can uh

00:13:30,800 --> 00:13:36,000
say it but uh at the virtual world

00:13:34,639 --> 00:13:38,079
within the kimo

00:13:36,000 --> 00:13:39,279
we do require some sort of association

00:13:38,079 --> 00:13:41,279
between

00:13:39,279 --> 00:13:42,720
what we are trying to plug in and where

00:13:41,279 --> 00:13:45,839
we are trying to plug in

00:13:42,720 --> 00:13:47,360
and correlate it with mp in dir using

00:13:45,839 --> 00:13:49,760
some sort of a mapping

00:13:47,360 --> 00:13:51,440
so perhaps this needs to be done and

00:13:49,760 --> 00:13:54,079
discussed

00:13:51,440 --> 00:13:54,800
also chemo labs the support of ppt table

00:13:54,079 --> 00:13:56,800
which

00:13:54,800 --> 00:14:02,000
shall be used to pass on the vcpu

00:13:56,800 --> 00:14:05,279
topology to the guest channel

00:14:02,000 --> 00:14:07,199
now within the guest kennel uh any arm

00:14:05,279 --> 00:14:08,880
64 architecture related changes done

00:14:07,199 --> 00:14:11,279
inside the kernel for the guest

00:14:08,880 --> 00:14:13,440
should seamlessly run on the host kernel

00:14:11,279 --> 00:14:15,199
now this is a big requirement because

00:14:13,440 --> 00:14:17,360
it has got a lot of implications which

00:14:15,199 --> 00:14:19,360
means that

00:14:17,360 --> 00:14:20,399
you cannot place any kind of switches

00:14:19,360 --> 00:14:22,880
within the

00:14:20,399 --> 00:14:23,920
guest kernel to distinguish whether this

00:14:22,880 --> 00:14:26,800
is a

00:14:23,920 --> 00:14:28,079
this is the code running as part of the

00:14:26,800 --> 00:14:31,839
guest kernel

00:14:28,079 --> 00:14:35,519
and is related to the cpr plug

00:14:31,839 --> 00:14:38,240
for for the virtual cpus

00:14:35,519 --> 00:14:38,240
now um

00:14:38,720 --> 00:14:42,480
vcpu as such vcpr plug might benefit

00:14:41,279 --> 00:14:44,079
from some of some sort of a

00:14:42,480 --> 00:14:44,959
standardization in the architecture and

00:14:44,079 --> 00:14:48,320
firmware

00:14:44,959 --> 00:14:51,440
is epi level uh if

00:14:48,320 --> 00:14:52,959
we can do that and any future

00:14:51,440 --> 00:14:56,560
specifications allowing

00:14:52,959 --> 00:14:59,839
physical cpu plug must

00:14:56,560 --> 00:15:01,120
not be duly constrained by vcp hot plug

00:14:59,839 --> 00:15:04,480
interface defined now

00:15:01,120 --> 00:15:07,360
uh so whatever we do

00:15:04,480 --> 00:15:09,040
as part of the standardization uh

00:15:07,360 --> 00:15:10,880
because currently physical cpu plug

00:15:09,040 --> 00:15:12,560
doesn't exist suppose in future it comes

00:15:10,880 --> 00:15:15,680
and that shouldn't contradict

00:15:12,560 --> 00:15:17,920
uh what you have done and

00:15:15,680 --> 00:15:19,600
should pay attention to that so that is

00:15:17,920 --> 00:15:21,920
just a kind of a consideration we need

00:15:19,600 --> 00:15:26,560
to paint

00:15:21,920 --> 00:15:28,560
that's a kind of a challenge as well so

00:15:26,560 --> 00:15:29,920
uh there have been certain uh workaround

00:15:28,560 --> 00:15:31,199
which has been discussed for the

00:15:29,920 --> 00:15:34,160
for the challenges what we just

00:15:31,199 --> 00:15:37,120
discussed so various workarounds

00:15:34,160 --> 00:15:37,759
um which have been discussed within the

00:15:37,120 --> 00:15:41,120
community

00:15:37,759 --> 00:15:45,600
across the years uh are

00:15:41,120 --> 00:15:48,639
something like uh all possible vcpus

00:15:45,600 --> 00:15:52,000
crate are created within the kvm and

00:15:48,639 --> 00:15:54,320
chemo at the vm initialization

00:15:52,000 --> 00:15:56,800
so it's kind of pre-creation of all of

00:15:54,320 --> 00:15:59,600
the vcpus

00:15:56,800 --> 00:16:02,880
but the chemo only realizes possible

00:15:59,600 --> 00:16:05,519
vcpus that are not disabled

00:16:02,880 --> 00:16:06,560
now remember the realization of vcpu

00:16:05,519 --> 00:16:09,839
means

00:16:06,560 --> 00:16:13,839
that the threads also get spawned right

00:16:09,839 --> 00:16:15,680
but uh as per the new changes the

00:16:13,839 --> 00:16:18,480
threads are not spawned

00:16:15,680 --> 00:16:18,800
uh for the disabled vcpus so we save a

00:16:18,480 --> 00:16:21,839
bit

00:16:18,800 --> 00:16:23,279
in that as well and that just kind of

00:16:21,839 --> 00:16:26,320
helps in

00:16:23,279 --> 00:16:28,959
just fitting the changes as part of

00:16:26,320 --> 00:16:30,000
neatly within the qm and the way the qm

00:16:28,959 --> 00:16:32,160
works as of now

00:16:30,000 --> 00:16:34,000
for the normal case as well without cpu

00:16:32,160 --> 00:16:36,000
hot plug case as well

00:16:34,000 --> 00:16:38,240
now kimo pre initializes weak

00:16:36,000 --> 00:16:39,040
distributors for all the possible vcpus

00:16:38,240 --> 00:16:42,480
in the va

00:16:39,040 --> 00:16:45,199
now i remember because the v-gec uh

00:16:42,480 --> 00:16:46,000
has got this requirement that this needs

00:16:45,199 --> 00:16:48,720
to be done

00:16:46,000 --> 00:16:48,720
as part of the

00:16:49,360 --> 00:16:53,199
initializes as part of the vma net uh

00:16:52,160 --> 00:16:56,959
process right

00:16:53,199 --> 00:16:58,800
so chemo does that and

00:16:56,959 --> 00:17:00,720
all the distributors are created along

00:16:58,800 --> 00:17:04,260
with the vcpus

00:17:00,720 --> 00:17:07,299
uh at the pma time and

00:17:04,260 --> 00:17:07,299
[Music]

00:17:11,120 --> 00:17:19,199
yeah and of course

00:17:14,319 --> 00:17:22,319
because the redistributors are

00:17:19,199 --> 00:17:25,280
like for each of the vcpu so

00:17:22,319 --> 00:17:26,959
uh they're kind of both present together

00:17:25,280 --> 00:17:28,640
at the vma at time

00:17:26,959 --> 00:17:30,240
so there have been certain discussions

00:17:28,640 --> 00:17:32,080
uh which

00:17:30,240 --> 00:17:33,679
are related to these you can refer to

00:17:32,080 --> 00:17:36,080
below i have just provided them the

00:17:33,679 --> 00:17:36,080
links

00:17:37,280 --> 00:17:41,730
well um kimu

00:17:40,400 --> 00:17:45,029
and host kvm

00:17:41,730 --> 00:17:45,029
[Music]

00:17:45,039 --> 00:17:48,559
is enhanced to support use space should

00:17:47,520 --> 00:17:50,640
be enhanced to

00:17:48,559 --> 00:17:53,280
support the user space configuration of

00:17:50,640 --> 00:17:55,039
the mpidr value of the vcpu so

00:17:53,280 --> 00:17:56,400
right now as discussed in the previous

00:17:55,039 --> 00:17:59,360
slides this is

00:17:56,400 --> 00:18:02,480
being done by the kvm and it derives the

00:17:59,360 --> 00:18:04,720
value of mpidr using the vcpu id

00:18:02,480 --> 00:18:06,640
but ideally there should be a for the

00:18:04,720 --> 00:18:09,919
virtualized case there should be a

00:18:06,640 --> 00:18:11,200
user space thing and kvm shouldn't get

00:18:09,919 --> 00:18:14,559
involved

00:18:11,200 --> 00:18:18,960
in the derivation of the np idr value

00:18:14,559 --> 00:18:21,840
except for uh

00:18:18,960 --> 00:18:24,000
configuring that value and within the

00:18:21,840 --> 00:18:27,280
vmp idr

00:18:24,000 --> 00:18:31,280
register which is a privileged operation

00:18:27,280 --> 00:18:34,480
uh also on vcp hot unplug

00:18:31,280 --> 00:18:37,840
emu parks and powers down the vcpu so

00:18:34,480 --> 00:18:40,000
remember that there was a limitation

00:18:37,840 --> 00:18:41,840
within the kvm that it you can create

00:18:40,000 --> 00:18:43,200
the bcps but you cannot destroy them

00:18:41,840 --> 00:18:46,160
which is

00:18:43,200 --> 00:18:46,799
kind of a limitation which is uh also

00:18:46,160 --> 00:18:49,919
present in

00:18:46,799 --> 00:18:51,360
intel so the common framework which has

00:18:49,919 --> 00:18:54,880
been added as part of the

00:18:51,360 --> 00:18:56,160
key move is to park down the vcpus which

00:18:54,880 --> 00:18:58,240
have been unplugged rather than

00:18:56,160 --> 00:19:01,440
destroying them at the kvm level

00:18:58,240 --> 00:19:02,720
so at kvm they always remain alive uh

00:19:01,440 --> 00:19:04,880
just that

00:19:02,720 --> 00:19:07,120
they are brought down to the low power

00:19:04,880 --> 00:19:07,120
mode

00:19:07,280 --> 00:19:10,320
now kimo provides the complete ambiguity

00:19:09,600 --> 00:19:12,400
table

00:19:10,320 --> 00:19:14,160
including all possible vcpu interfaces

00:19:12,400 --> 00:19:15,919
and it's redistributed to the guest

00:19:14,160 --> 00:19:17,360
kernel this information is used by the

00:19:15,919 --> 00:19:21,600
guest kernel

00:19:17,360 --> 00:19:23,360
to basically initialize

00:19:21,600 --> 00:19:24,310
its data structures for the base

00:19:23,360 --> 00:19:26,160
addresses

00:19:24,310 --> 00:19:30,320
[Music]

00:19:26,160 --> 00:19:32,880
and other parameters

00:19:30,320 --> 00:19:35,039
at the boot time guest channel uses info

00:19:32,880 --> 00:19:37,039
from the emulator table to sizes various

00:19:35,039 --> 00:19:39,039
data structures including initialization

00:19:37,039 --> 00:19:41,280
of redistributors as i said

00:19:39,039 --> 00:19:42,480
with all possible vcpus so

00:19:41,280 --> 00:19:44,240
redistributors

00:19:42,480 --> 00:19:45,919
also start to exist within the guest

00:19:44,240 --> 00:19:48,960
corner just that

00:19:45,919 --> 00:19:49,280
they don't have their vcpu instances for

00:19:48,960 --> 00:19:52,799
the

00:19:49,280 --> 00:19:53,520
disabled possible vcpus which gets

00:19:52,799 --> 00:19:57,120
created

00:19:53,520 --> 00:19:59,840
and reflected while the cpu is unplugged

00:19:57,120 --> 00:19:59,840
or unplugged

00:20:00,559 --> 00:20:05,039
now these are the recent and the earlier

00:20:03,919 --> 00:20:08,000
attempts

00:20:05,039 --> 00:20:11,120
which have been made very recent were

00:20:08,000 --> 00:20:14,640
the ones done in the june by me

00:20:11,120 --> 00:20:15,120
so both the kernel changes that is the

00:20:14,640 --> 00:20:18,960
guest

00:20:15,120 --> 00:20:22,320
changes and the virtual uh

00:20:18,960 --> 00:20:26,559
cpr changes for the kimo

00:20:22,320 --> 00:20:28,320
were floated uh the

00:20:26,559 --> 00:20:30,320
the host kernel didn't require any

00:20:28,320 --> 00:20:31,440
change and these were found to be

00:20:30,320 --> 00:20:33,360
working as such

00:20:31,440 --> 00:20:35,200
uh without the change any change within

00:20:33,360 --> 00:20:38,320
the host kernel

00:20:35,200 --> 00:20:40,320
though there's one change like

00:20:38,320 --> 00:20:41,760
ability to configure the mp id and from

00:20:40,320 --> 00:20:43,760
the user space that might

00:20:41,760 --> 00:20:46,000
require a bit of a change but as such

00:20:43,760 --> 00:20:49,039
these are pretty agnostic of the host

00:20:46,000 --> 00:20:52,720
so all the workarounds are take care

00:20:49,039 --> 00:20:56,159
of the limitations what we just uh

00:20:52,720 --> 00:20:58,000
kind of discussed uh within the

00:20:56,159 --> 00:20:59,280
within the chemo as well as the guest

00:20:58,000 --> 00:21:00,840
kernel and

00:20:59,280 --> 00:21:02,720
the changes in the guest candle are

00:21:00,840 --> 00:21:06,159
non-destructive

00:21:02,720 --> 00:21:10,799
but again since

00:21:06,159 --> 00:21:13,600
they are kind of done in a way

00:21:10,799 --> 00:21:14,799
and we don't have a specification so

00:21:13,600 --> 00:21:17,120
that can be a concern

00:21:14,799 --> 00:21:18,080
we'll see it later so you might like to

00:21:17,120 --> 00:21:21,760
go through these

00:21:18,080 --> 00:21:23,280
references so what are the problems

00:21:21,760 --> 00:21:26,880
being phased in upstreaming now

00:21:23,280 --> 00:21:29,039
uh arm64 system architecture does not

00:21:26,880 --> 00:21:31,280
supports physical cpu hot plug

00:21:29,039 --> 00:21:33,679
as we know now due to the absence of the

00:21:31,280 --> 00:21:35,039
suitable specification

00:21:33,679 --> 00:21:36,960
they have been concerned which have been

00:21:35,039 --> 00:21:39,760
raised to avoid

00:21:36,960 --> 00:21:41,679
any divergent system architectures being

00:21:39,760 --> 00:21:43,360
invented by different vendors so it's

00:21:41,679 --> 00:21:45,120
not just

00:21:43,360 --> 00:21:46,640
one vendor who is trying to support this

00:21:45,120 --> 00:21:49,120
thing maybe other people might come with

00:21:46,640 --> 00:21:52,080
their own ideas and

00:21:49,120 --> 00:21:53,919
it might happen if if there's no

00:21:52,080 --> 00:21:58,159
standardization of this then

00:21:53,919 --> 00:22:01,440
the things can get bit messy

00:21:58,159 --> 00:22:02,400
and probably this has left patches

00:22:01,440 --> 00:22:06,080
stranded

00:22:02,400 --> 00:22:07,840
uh across multiple attempts

00:22:06,080 --> 00:22:10,000
few patches cannot proceed till the time

00:22:07,840 --> 00:22:11,600
the guest kernel patches are duly

00:22:10,000 --> 00:22:12,480
considered by the kendall community

00:22:11,600 --> 00:22:15,760
which

00:22:12,480 --> 00:22:18,559
currently we feel that it

00:22:15,760 --> 00:22:20,559
has not been done and so i would like to

00:22:18,559 --> 00:22:23,679
request the community for more reviews

00:22:20,559 --> 00:22:23,679
and involvement in this

00:22:24,960 --> 00:22:29,360
so just to recap the summary and what is

00:22:27,679 --> 00:22:32,400
the way forwards

00:22:29,360 --> 00:22:34,480
um ac based support of the virtual cpu

00:22:32,400 --> 00:22:36,559
hot plug feature is a much requested

00:22:34,480 --> 00:22:38,159
feature for the use cases stated earlier

00:22:36,559 --> 00:22:40,640
in the slides

00:22:38,159 --> 00:22:42,640
and as you can see we have posed a

00:22:40,640 --> 00:22:44,960
practical implementation

00:22:42,640 --> 00:22:46,559
but uh it seemed to be making a little

00:22:44,960 --> 00:22:49,360
progress in the upstream

00:22:46,559 --> 00:22:50,880
uh for the reason which again we have

00:22:49,360 --> 00:22:54,159
discussed

00:22:50,880 --> 00:22:56,159
uh so the key thing is how do we

00:22:54,159 --> 00:22:59,360
overcome the resistance

00:22:56,159 --> 00:23:00,720
uh to implementing a virtual only

00:22:59,360 --> 00:23:02,720
feature

00:23:00,720 --> 00:23:04,960
while minimizing the possible clashes

00:23:02,720 --> 00:23:06,240
with the say for example any potential

00:23:04,960 --> 00:23:09,520
future

00:23:06,240 --> 00:23:12,480
physical equivalent if it ever will come

00:23:09,520 --> 00:23:13,679
but we need to take care of it now and

00:23:12,480 --> 00:23:15,600
would some sort of a minimal

00:23:13,679 --> 00:23:17,520
specification to ensure

00:23:15,600 --> 00:23:18,640
some sort of a consistency of

00:23:17,520 --> 00:23:21,039
implementation

00:23:18,640 --> 00:23:22,320
in the virtual case specifically elevate

00:23:21,039 --> 00:23:26,000
such concerns

00:23:22,320 --> 00:23:26,000
and appears how to do this

00:23:30,000 --> 00:23:34,559
the future work is which is left is

00:23:32,880 --> 00:23:37,760
around the light migration support

00:23:34,559 --> 00:23:41,679
support of the hot plug with pneuma

00:23:37,760 --> 00:23:43,760
cpu topology as mentioned earlier pptt

00:23:41,679 --> 00:23:45,760
support to hand over the right vcp

00:23:43,760 --> 00:23:49,440
topology info to the guest

00:23:45,760 --> 00:23:51,120
test cases lots of docs to explain

00:23:49,440 --> 00:23:52,799
because there are a lot of workarounds

00:23:51,120 --> 00:23:55,840
so products require a proper

00:23:52,799 --> 00:23:55,840
documentation for this

00:23:58,480 --> 00:24:01,679
well i'd like to take this opportunity

00:24:00,720 --> 00:24:03,440
to thank

00:24:01,679 --> 00:24:06,400
all the individuals who have worked for

00:24:03,440 --> 00:24:09,279
this particular topic in the past

00:24:06,400 --> 00:24:10,400
and have discussed and their ideas i'm

00:24:09,279 --> 00:24:13,679
just trying to carry

00:24:10,400 --> 00:24:14,080
forward the pass button to me and actual

00:24:13,679 --> 00:24:18,240
work

00:24:14,080 --> 00:24:19,279
have been done much earlier the concepts

00:24:18,240 --> 00:24:22,559
i just tried to

00:24:19,279 --> 00:24:24,080
implement uh the ideas which were well

00:24:22,559 --> 00:24:27,919
discussed

00:24:24,080 --> 00:24:31,120
and uh and to demonstrate that

00:24:27,919 --> 00:24:32,240
those were achievable and actually those

00:24:31,120 --> 00:24:35,679
work

00:24:32,240 --> 00:24:39,279
so anyone that i've missed into

00:24:35,679 --> 00:24:41,600
my list uh uh please forgive me

00:24:39,279 --> 00:24:43,840
as i said it's it's a tribute to

00:24:41,600 --> 00:24:47,360
everyone who was involved

00:24:43,840 --> 00:24:51,120
in this effort with this

00:24:47,360 --> 00:24:54,240
i like to open the session for any q a

00:24:51,120 --> 00:24:57,840
so and also i would like to thank you

00:24:54,240 --> 00:25:01,039
for listening patiently to my

00:24:57,840 --> 00:25:02,240
session thank you so much and i'm open

00:25:01,039 --> 00:25:15,679
for any questions

00:25:02,240 --> 00:25:15,679

YouTube URL: https://www.youtube.com/watch?v=PT2S4nrDjVQ


