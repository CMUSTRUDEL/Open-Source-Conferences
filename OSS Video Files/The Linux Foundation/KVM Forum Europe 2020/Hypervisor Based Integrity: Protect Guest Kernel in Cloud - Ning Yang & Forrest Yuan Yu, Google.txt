Title: Hypervisor Based Integrity: Protect Guest Kernel in Cloud - Ning Yang & Forrest Yuan Yu, Google
Publication date: 2020-11-10
Playlist: KVM Forum Europe 2020
Description: 
	Hypervisor Based Integrity: Protect Guest Kernel in Cloud - Ning Yang & Forrest Yuan Yu, Google
Captions: 
	00:00:07,120 --> 00:00:09,920
hello everyone

00:00:08,080 --> 00:00:12,480
thanks for attending this session my

00:00:09,920 --> 00:00:15,040
name is ning i'm working as

00:00:12,480 --> 00:00:16,640
software engineer for google cloud our

00:00:15,040 --> 00:00:18,320
team is mainly responsible for

00:00:16,640 --> 00:00:19,920
maintaining the hypervisor

00:00:18,320 --> 00:00:21,520
and the virtual machine monitor inside

00:00:19,920 --> 00:00:23,920
google and google cloud

00:00:21,520 --> 00:00:25,359
today the topic of the top is hypervisor

00:00:23,920 --> 00:00:27,920
based integrity

00:00:25,359 --> 00:00:29,599
as you can probably tell from the name

00:00:27,920 --> 00:00:31,599
we are trying to utilize the super

00:00:29,599 --> 00:00:33,200
power given by the hypervisor and

00:00:31,599 --> 00:00:35,440
hardware to provide

00:00:33,200 --> 00:00:37,920
the gas kernels running inside the cloud

00:00:35,440 --> 00:00:37,920
environment

00:00:39,920 --> 00:00:44,960
so some high level disclaimer this is

00:00:42,719 --> 00:00:47,280
not a statement of direction of planted

00:00:44,960 --> 00:00:48,559
investment by google yet we are

00:00:47,280 --> 00:00:51,120
exploring this

00:00:48,559 --> 00:00:51,760
as a possible security mechanisms and we

00:00:51,120 --> 00:00:53,600
are

00:00:51,760 --> 00:00:56,239
seeking feedbacks from the big

00:00:53,600 --> 00:00:56,239
communities

00:00:57,600 --> 00:01:00,879
a background on why we are heading this

00:01:00,160 --> 00:01:03,680
way

00:01:00,879 --> 00:01:04,080
so google cloud offer a product called

00:01:03,680 --> 00:01:07,680
should

00:01:04,080 --> 00:01:09,360
vm um in fact that's a default vm type

00:01:07,680 --> 00:01:11,600
if you try to create a virtual machine

00:01:09,360 --> 00:01:13,600
inside google cloud

00:01:11,600 --> 00:01:15,840
as you can tell from the name it comes

00:01:13,600 --> 00:01:19,439
with some enhanced security

00:01:15,840 --> 00:01:21,040
features one of them called secure boot

00:01:19,439 --> 00:01:24,000
on high level in case you are not

00:01:21,040 --> 00:01:26,799
familiar with it provide integrity check

00:01:24,000 --> 00:01:29,439
against firmware bootloader and kernel

00:01:26,799 --> 00:01:33,840
during boot time

00:01:29,439 --> 00:01:33,840
it will use as duplicates and

00:01:34,640 --> 00:01:40,880
into to verify the signature of

00:01:37,920 --> 00:01:41,600
all the modules and has been stamped

00:01:40,880 --> 00:01:44,079
correctly

00:01:41,600 --> 00:01:45,200
all the drivers and all the binaries is

00:01:44,079 --> 00:01:48,399
trying to load

00:01:45,200 --> 00:01:51,200
so it gives you a guarantee like

00:01:48,399 --> 00:01:53,360
at the end of the boot everything should

00:01:51,200 --> 00:01:54,720
be in a very good shape nothing has been

00:01:53,360 --> 00:01:57,520
modified have been

00:01:54,720 --> 00:01:58,000
or has been hijacked in any way after

00:01:57,520 --> 00:02:01,119
that

00:01:58,000 --> 00:02:01,920
most kernel modules if you try to load

00:02:01,119 --> 00:02:04,719
additional

00:02:01,920 --> 00:02:07,119
um dynamic kernel modules they will be

00:02:04,719 --> 00:02:10,080
protected by the module signings so

00:02:07,119 --> 00:02:11,039
that's code in the in the kernel which

00:02:10,080 --> 00:02:12,959
will do second to

00:02:11,039 --> 00:02:15,360
signature checkings against the module

00:02:12,959 --> 00:02:18,959
you are trying to load

00:02:15,360 --> 00:02:22,319
that's all good but in real life

00:02:18,959 --> 00:02:23,360
attackers can still find them different

00:02:22,319 --> 00:02:26,959
ways

00:02:23,360 --> 00:02:30,080
to gain like highest privileges inside

00:02:26,959 --> 00:02:34,000
a running coin if he can do that

00:02:30,080 --> 00:02:36,480
and he can modify the code page or

00:02:34,000 --> 00:02:37,360
call back in some special way like all

00:02:36,480 --> 00:02:40,879
the security

00:02:37,360 --> 00:02:43,440
gate we put in place cannot be

00:02:40,879 --> 00:02:44,400
trusted and we could put user

00:02:43,440 --> 00:02:47,760
applications

00:02:44,400 --> 00:02:47,760
in a risk state

00:02:48,480 --> 00:02:52,080
the goal is trying to protect the kernel

00:02:50,720 --> 00:02:53,920
ima at runtime

00:02:52,080 --> 00:02:55,920
since we already have all these green

00:02:53,920 --> 00:02:59,040
box checked during boot

00:02:55,920 --> 00:03:00,080
we are trying to extend what we can and

00:02:59,040 --> 00:03:03,280
help

00:03:00,080 --> 00:03:05,680
um make sure like the kernel at

00:03:03,280 --> 00:03:06,480
runtime is also protect and can be

00:03:05,680 --> 00:03:08,400
trusted

00:03:06,480 --> 00:03:10,800
if kernel has not been modified in any

00:03:08,400 --> 00:03:13,840
way and running as expected

00:03:10,800 --> 00:03:17,519
the user application can feel much safe

00:03:13,840 --> 00:03:20,000
about it and one more thing

00:03:17,519 --> 00:03:22,080
is the production we put in place the

00:03:20,000 --> 00:03:24,640
cat should not be able to turn off from

00:03:22,080 --> 00:03:24,640
the guests

00:03:24,879 --> 00:03:28,000
because i mean rootkit can gain highest

00:03:27,360 --> 00:03:30,879
privilege

00:03:28,000 --> 00:03:32,640
if he can change the settings in the gas

00:03:30,879 --> 00:03:36,400
to turn off the production then

00:03:32,640 --> 00:03:38,720
the protection is not that

00:03:36,400 --> 00:03:38,720
strong

00:03:39,519 --> 00:03:42,799
so let's talk about the threat model

00:03:41,120 --> 00:03:44,840
here so we assume

00:03:42,799 --> 00:03:46,720
the attacker has the following

00:03:44,840 --> 00:03:49,760
capabilities so it can

00:03:46,720 --> 00:03:52,799
gain ring zero access

00:03:49,760 --> 00:03:56,720
it can have arbitrary read

00:03:52,799 --> 00:03:58,959
and write permissions so it can read and

00:03:56,720 --> 00:04:02,959
any kind of memory address and write any

00:03:58,959 --> 00:04:02,959
value to any kernel memory address

00:04:03,200 --> 00:04:06,959
so how do we protect the guest kernel

00:04:04,959 --> 00:04:08,159
based on the thread model we just talked

00:04:06,959 --> 00:04:09,439
about

00:04:08,159 --> 00:04:11,599
first of all we want to make sure

00:04:09,439 --> 00:04:12,879
there's no intended modifications on the

00:04:11,599 --> 00:04:15,120
kernel code segment

00:04:12,879 --> 00:04:16,639
and read-only data segment and this is

00:04:15,120 --> 00:04:18,880
very obvious

00:04:16,639 --> 00:04:21,359
we have very real written code we don't

00:04:18,880 --> 00:04:23,840
want it get replaced by some

00:04:21,359 --> 00:04:25,520
molecular code second of all we want to

00:04:23,840 --> 00:04:27,440
make sure the code execution

00:04:25,520 --> 00:04:29,120
no code execution from other part of the

00:04:27,440 --> 00:04:31,040
kernel space

00:04:29,120 --> 00:04:32,800
data statement should always be read and

00:04:31,040 --> 00:04:35,520
write but not executable

00:04:32,800 --> 00:04:38,320
and yes this is where um buffer blur

00:04:35,520 --> 00:04:40,240
attack happens and we won't block that

00:04:38,320 --> 00:04:41,360
and third and we want to make sure

00:04:40,240 --> 00:04:43,759
there's no

00:04:41,360 --> 00:04:45,360
intended modifications of key kernel

00:04:43,759 --> 00:04:48,160
data structures

00:04:45,360 --> 00:04:48,639
for example a system call table which is

00:04:48,160 --> 00:04:51,759
a

00:04:48,639 --> 00:04:53,919
table of functional pointers hackers

00:04:51,759 --> 00:04:56,960
manage to replace it with something else

00:04:53,919 --> 00:04:58,240
user may get monitored or hacked without

00:04:56,960 --> 00:05:00,880
realizing it

00:04:58,240 --> 00:05:02,639
um as an example with control register

00:05:00,880 --> 00:05:04,240
like cr0 or cr4

00:05:02,639 --> 00:05:06,880
there's a bit in the control register in

00:05:04,240 --> 00:05:10,000
the cr0 um which is read

00:05:06,880 --> 00:05:13,360
right protection so but if you

00:05:10,000 --> 00:05:15,600
and after bit the kernel that

00:05:13,360 --> 00:05:17,919
the the process will allow you to write

00:05:15,600 --> 00:05:21,280
to a read-only memory which is

00:05:17,919 --> 00:05:24,000
not ideal and there's other

00:05:21,280 --> 00:05:25,919
msr important msrs like there's people

00:05:24,000 --> 00:05:28,960
talking about system enter

00:05:25,919 --> 00:05:32,080
msr and

00:05:28,960 --> 00:05:35,039
utilizing that msr they can hack

00:05:32,080 --> 00:05:37,120
this some system course of course

00:05:35,039 --> 00:05:38,400
similar to system call table there's a

00:05:37,120 --> 00:05:41,280
idt

00:05:38,400 --> 00:05:43,039
interrupt descrip descriptor table and

00:05:41,280 --> 00:05:45,039
gdt global descriptive

00:05:43,039 --> 00:05:46,639
table both of them has some function

00:05:45,039 --> 00:05:47,919
pointers we want to make sure it never

00:05:46,639 --> 00:05:50,160
gets overwritten

00:05:47,919 --> 00:05:50,960
of course last but not least we have the

00:05:50,160 --> 00:05:54,479
page table

00:05:50,960 --> 00:05:57,280
which has some mapping from

00:05:54,479 --> 00:05:57,919
virtual to physical so if people hacks

00:05:57,280 --> 00:06:00,240
mappings

00:05:57,919 --> 00:06:02,960
they can redirect the code execution to

00:06:00,240 --> 00:06:05,919
some other place

00:06:02,960 --> 00:06:07,440
but why we want to use hyper as another

00:06:05,919 --> 00:06:10,240
security layer

00:06:07,440 --> 00:06:12,160
and our understanding is there's always

00:06:10,240 --> 00:06:13,680
a risk of protecting guests from

00:06:12,160 --> 00:06:15,919
wheeling the guests

00:06:13,680 --> 00:06:17,360
because we we already did a lot of

00:06:15,919 --> 00:06:19,039
kernel handling work

00:06:17,360 --> 00:06:21,440
in the kernel space to make it harder

00:06:19,039 --> 00:06:22,400
and harder but it's not guaranteed to be

00:06:21,440 --> 00:06:24,880
impossible

00:06:22,400 --> 00:06:25,840
root kit or attacker can still gain

00:06:24,880 --> 00:06:27,840
highest privilege

00:06:25,840 --> 00:06:29,360
and read and write and get memories if

00:06:27,840 --> 00:06:31,199
they want

00:06:29,360 --> 00:06:32,479
and it's not easy but it's still

00:06:31,199 --> 00:06:36,479
possible

00:06:32,479 --> 00:06:39,680
so anything we put in kernel space um

00:06:36,479 --> 00:06:41,360
could be risky and but on the other hand

00:06:39,680 --> 00:06:42,080
if we guarantee like kernel number

00:06:41,360 --> 00:06:44,400
change

00:06:42,080 --> 00:06:46,160
conor code never changes then basically

00:06:44,400 --> 00:06:48,639
in return it will make sure all the

00:06:46,160 --> 00:06:51,039
security checks we put in place

00:06:48,639 --> 00:06:52,479
be more robust so this is not a

00:06:51,039 --> 00:06:54,160
replacement of all the

00:06:52,479 --> 00:06:56,080
kernel hardening work we have there we

00:06:54,160 --> 00:06:58,000
hope this is just an

00:06:56,080 --> 00:06:59,759
enhancement layer like make sure

00:06:58,000 --> 00:07:04,319
whatever you put there

00:06:59,759 --> 00:07:06,240
um is cracked and remain

00:07:04,319 --> 00:07:08,639
cracked for the entire life cycle of the

00:07:06,240 --> 00:07:08,639
vm

00:07:09,120 --> 00:07:12,240
applies the on the other hand hyper has

00:07:11,840 --> 00:07:15,360
almost

00:07:12,240 --> 00:07:16,319
21 mappings to all the production we

00:07:15,360 --> 00:07:18,479
want to achieve

00:07:16,319 --> 00:07:19,520
like hypervisor can control read write

00:07:18,479 --> 00:07:22,880
exclude bit

00:07:19,520 --> 00:07:25,759
for page align guess memory reading and

00:07:22,880 --> 00:07:26,319
utilizing the two-dimensional pages like

00:07:25,759 --> 00:07:30,000
ebt

00:07:26,319 --> 00:07:31,840
or npt for md we we can set up

00:07:30,000 --> 00:07:34,319
the permissions which guests can never

00:07:31,840 --> 00:07:36,880
change and hypervisor can

00:07:34,319 --> 00:07:39,199
protect unsafe modifications of control

00:07:36,880 --> 00:07:42,960
adjusters and msrs we just configure

00:07:39,199 --> 00:07:46,400
the vm exit on those um right

00:07:42,960 --> 00:07:46,800
to msr or control register and then we

00:07:46,400 --> 00:07:48,400
can

00:07:46,800 --> 00:07:51,199
do double check whether that's

00:07:48,400 --> 00:07:53,919
legitimate legitimate or not

00:07:51,199 --> 00:07:56,319
and hypervisor can also protect the key

00:07:53,919 --> 00:07:57,840
kernel page table

00:07:56,319 --> 00:08:00,080
there's a new feature called advisor

00:07:57,840 --> 00:08:00,960
managed to linear adjust translation for

00:08:00,080 --> 00:08:03,039
intel

00:08:00,960 --> 00:08:05,039
which allow you to set up page table

00:08:03,039 --> 00:08:07,360
mappings controlled by hypervisor and

00:08:05,039 --> 00:08:10,000
guests can never change it

00:08:07,360 --> 00:08:11,199
and most importantly for us for google

00:08:10,000 --> 00:08:14,080
cloud

00:08:11,199 --> 00:08:15,599
both of our guests all of our customer

00:08:14,080 --> 00:08:17,280
customer

00:08:15,599 --> 00:08:19,360
machines are already running in a

00:08:17,280 --> 00:08:20,000
virtual machine mode but we already have

00:08:19,360 --> 00:08:22,879
a layer

00:08:20,000 --> 00:08:25,280
underneath all those vms and we are not

00:08:22,879 --> 00:08:27,520
trying to introduce another

00:08:25,280 --> 00:08:29,280
layer of complexity here we are just

00:08:27,520 --> 00:08:32,000
using the existing layer to make

00:08:29,280 --> 00:08:34,479
everything more robust and more

00:08:32,000 --> 00:08:34,479
secure

00:08:36,959 --> 00:08:40,959
so how does everything work end to end

00:08:39,120 --> 00:08:43,039
here we want to introduce a new guest

00:08:40,959 --> 00:08:44,800
security kernel module

00:08:43,039 --> 00:08:47,440
this module should be loaded at both

00:08:44,800 --> 00:08:49,440
time ideally by the end of boot time so

00:08:47,440 --> 00:08:50,560
we the kernel has already set up all the

00:08:49,440 --> 00:08:53,600
page table

00:08:50,560 --> 00:08:55,519
idt gdt system call table etc

00:08:53,600 --> 00:08:56,640
it should be signed and protected by the

00:08:55,519 --> 00:08:58,800
secure boot

00:08:56,640 --> 00:09:01,040
so it can be trusted at both hand if

00:08:58,800 --> 00:09:04,959
anyone tries to modify it in some way

00:09:01,040 --> 00:09:06,480
a secure board will fail and it should

00:09:04,959 --> 00:09:08,560
after it gets loaded and will check

00:09:06,480 --> 00:09:11,760
whether the hybrid support

00:09:08,560 --> 00:09:13,839
special integrity protections if it does

00:09:11,760 --> 00:09:16,160
they will try to identify all the kernel

00:09:13,839 --> 00:09:17,360
code data segment and address of the key

00:09:16,160 --> 00:09:20,160
data structures

00:09:17,360 --> 00:09:21,760
and send a please protect me request to

00:09:20,160 --> 00:09:24,399
the hypervisor

00:09:21,760 --> 00:09:25,839
and then we need to wait um i cannot

00:09:24,399 --> 00:09:27,680
wait for the acknowledgement from

00:09:25,839 --> 00:09:30,800
hypervisor because

00:09:27,680 --> 00:09:34,000
we don't want to jump into the runtime

00:09:30,800 --> 00:09:34,959
and so everything become a little bit

00:09:34,000 --> 00:09:36,480
out of control

00:09:34,959 --> 00:09:39,600
during boot time everything is still in

00:09:36,480 --> 00:09:39,600
the control and in good shape

00:09:39,760 --> 00:09:44,800
on the hypotenuse side during both time

00:09:42,959 --> 00:09:45,440
it needs to decode the memory segment

00:09:44,800 --> 00:09:48,160
information

00:09:45,440 --> 00:09:49,360
sent from the guest we'll modify the

00:09:48,160 --> 00:09:51,600
second level

00:09:49,360 --> 00:09:53,040
translation table to set correct read

00:09:51,600 --> 00:09:55,440
write execute bit

00:09:53,040 --> 00:09:57,360
with a specific memory reading and it

00:09:55,440 --> 00:10:00,720
will configure the vm exit

00:09:57,360 --> 00:10:01,279
on msrs and control registers after that

00:10:00,720 --> 00:10:03,680
it should

00:10:01,279 --> 00:10:05,279
acknowledge the request and let it

00:10:03,680 --> 00:10:08,560
continue to boot

00:10:05,279 --> 00:10:12,240
we just a few actors we need to call so

00:10:08,560 --> 00:10:16,079
it should not have significant impact on

00:10:12,240 --> 00:10:19,920
guestbook during runtime

00:10:16,079 --> 00:10:23,920
the hypervisor and qmu or vmm were just

00:10:19,920 --> 00:10:28,000
handling ept and mpt access evaluations

00:10:23,920 --> 00:10:30,560
and if that happens user can config

00:10:28,000 --> 00:10:31,519
one of the following actions and kill

00:10:30,560 --> 00:10:33,839
the running vm

00:10:31,519 --> 00:10:35,279
and dump all the memories for analyze

00:10:33,839 --> 00:10:38,320
that's for

00:10:35,279 --> 00:10:40,320
the people like who care a lot

00:10:38,320 --> 00:10:42,000
about security and want to make sure

00:10:40,320 --> 00:10:45,040
nothing

00:10:42,000 --> 00:10:46,959
wrong should happen and from quadratic

00:10:45,040 --> 00:10:48,079
users we would expect we will just log

00:10:46,959 --> 00:10:50,320
up critical event

00:10:48,079 --> 00:10:52,160
and notify the user and let them decide

00:10:50,320 --> 00:10:54,880
what they want

00:10:52,160 --> 00:10:56,320
meanwhile on the other hand like we do

00:10:54,880 --> 00:10:59,760
the same thing for the controller set

00:10:56,320 --> 00:11:01,120
register and msr modifications and you

00:10:59,760 --> 00:11:04,560
may be wondering like

00:11:01,120 --> 00:11:05,519
you know in runtime we can add dynamic

00:11:04,560 --> 00:11:07,600
kernel modules

00:11:05,519 --> 00:11:09,760
those kernel modules are executable so

00:11:07,600 --> 00:11:13,120
how do we handle that

00:11:09,760 --> 00:11:14,079
our recommendation is it's much safer to

00:11:13,120 --> 00:11:16,959
do not do that

00:11:14,079 --> 00:11:18,000
but if you have to do that and we have

00:11:16,959 --> 00:11:20,480
apis

00:11:18,000 --> 00:11:22,160
exposed by the guest module so we'll

00:11:20,480 --> 00:11:24,079
modify the kernel code a little bit

00:11:22,160 --> 00:11:25,279
so first of all the kernel code will

00:11:24,079 --> 00:11:28,079
locate

00:11:25,279 --> 00:11:29,200
um read and write both memory region

00:11:28,079 --> 00:11:32,959
then copy

00:11:29,200 --> 00:11:34,959
binary into it and once the ss

00:11:32,959 --> 00:11:36,800
once the verification is done it will

00:11:34,959 --> 00:11:39,200
cause the api to change

00:11:36,800 --> 00:11:41,760
the code segment of that memory region

00:11:39,200 --> 00:11:44,079
to be read and exitable

00:11:41,760 --> 00:11:45,839
i'd rather make sure like the code

00:11:44,079 --> 00:11:47,920
segment never change

00:11:45,839 --> 00:11:50,240
after the first time you load the kernel

00:11:47,920 --> 00:11:50,240
module

00:11:50,959 --> 00:11:54,480
you may wonder like what's the promise

00:11:52,639 --> 00:11:54,959
impact since we are doing a lot of stuff

00:11:54,480 --> 00:11:57,279
here

00:11:54,959 --> 00:11:59,040
and for memory access the impact should

00:11:57,279 --> 00:12:01,680
be minimal

00:11:59,040 --> 00:12:02,639
mainly because we have supports through

00:12:01,680 --> 00:12:05,839
the hardware

00:12:02,639 --> 00:12:07,760
intel epto amd and pt

00:12:05,839 --> 00:12:09,600
if there's no violation happens there

00:12:07,760 --> 00:12:12,399
should be no impact at all

00:12:09,600 --> 00:12:13,600
but if something happens i think it's

00:12:12,399 --> 00:12:16,639
okay to

00:12:13,600 --> 00:12:17,680
pay some extra cost on the vm exam to

00:12:16,639 --> 00:12:20,320
determine whether the

00:12:17,680 --> 00:12:21,920
operation is legitimate legitimate or

00:12:20,320 --> 00:12:25,040
not

00:12:21,920 --> 00:12:28,639
and from our prototype prototyping

00:12:25,040 --> 00:12:29,360
and testing those do not happen very

00:12:28,639 --> 00:12:33,200
often

00:12:29,360 --> 00:12:36,560
if that's if it is a alc kernel

00:12:33,200 --> 00:12:38,480
well control reduction and msr

00:12:36,560 --> 00:12:39,760
module-specific regressor the impact

00:12:38,480 --> 00:12:41,760
should also be minimal

00:12:39,760 --> 00:12:43,920
and we because we don't expect a lot of

00:12:41,760 --> 00:12:46,240
modifications on a typical

00:12:43,920 --> 00:12:48,000
kernel runtime if you are running a

00:12:46,240 --> 00:12:48,959
nasty virtualization it's completely

00:12:48,000 --> 00:12:52,160
another story

00:12:48,959 --> 00:12:53,200
so we we don't expect we don't recommend

00:12:52,160 --> 00:12:55,200
people to know this

00:12:53,200 --> 00:12:56,800
if yeah they're running into these

00:12:55,200 --> 00:13:00,000
scenarios

00:12:56,800 --> 00:13:02,079
and for the page table translation it

00:13:00,000 --> 00:13:03,839
need hardware support um but currently

00:13:02,079 --> 00:13:06,880
only limited to intel

00:13:03,839 --> 00:13:10,320
other link so it's not there yet

00:13:06,880 --> 00:13:10,320
and we cannot measure it

00:13:11,839 --> 00:13:15,600
it sounds straightforward but it has a

00:13:14,720 --> 00:13:19,040
bunch of

00:13:15,600 --> 00:13:21,519
technical challenges and two major ones

00:13:19,040 --> 00:13:22,639
is like how do we distinguish between

00:13:21,519 --> 00:13:26,399
legitimate

00:13:22,639 --> 00:13:28,800
uh legitimate kernel modifications

00:13:26,399 --> 00:13:30,399
yes a bunch of reasons you can see we

00:13:28,800 --> 00:13:34,720
list here

00:13:30,399 --> 00:13:36,639
gonna want to modify itself and

00:13:34,720 --> 00:13:39,120
we need to work with our customers to

00:13:36,639 --> 00:13:42,160
either disable those

00:13:39,120 --> 00:13:45,519
disable those special scenarios

00:13:42,160 --> 00:13:46,639
in their image or we need to decode the

00:13:45,519 --> 00:13:48,240
instruction pointer

00:13:46,639 --> 00:13:51,519
and goes through the core stack and

00:13:48,240 --> 00:13:54,480
whitelist those operations

00:13:51,519 --> 00:13:55,199
another major problem is when set memory

00:13:54,480 --> 00:13:58,079
permission

00:13:55,199 --> 00:13:58,560
not all segments are nicely aligned if

00:13:58,079 --> 00:14:00,160
we have

00:13:58,560 --> 00:14:02,320
one page and because when we set

00:14:00,160 --> 00:14:04,560
permission it's on the page level

00:14:02,320 --> 00:14:06,480
if we have one page that is shared

00:14:04,560 --> 00:14:09,680
between a code segment and datastick

00:14:06,480 --> 00:14:14,480
segment will be very hard for us

00:14:09,680 --> 00:14:14,480
to set correct permission on it and

00:14:15,279 --> 00:14:18,560
we will have a potential problem here so

00:14:17,120 --> 00:14:20,560
to mitigate this issue

00:14:18,560 --> 00:14:22,240
um some change in the kernel need to

00:14:20,560 --> 00:14:24,000
happen to make sure

00:14:22,240 --> 00:14:26,000
like all the code segments all the

00:14:24,000 --> 00:14:31,680
different segments of kernel

00:14:26,000 --> 00:14:34,480
um is nicely aligned

00:14:31,680 --> 00:14:35,199
so here's a quick example of what it

00:14:34,480 --> 00:14:37,680
looks like

00:14:35,199 --> 00:14:39,440
if we turn down the protection we have a

00:14:37,680 --> 00:14:41,440
guest running on dbm 10

00:14:39,440 --> 00:14:44,000
after kernel boots we map the entire

00:14:41,440 --> 00:14:46,480
conical segment as read and executable

00:14:44,000 --> 00:14:47,519
we got a bunch of epta violations right

00:14:46,480 --> 00:14:49,680
away

00:14:47,519 --> 00:14:51,199
but if we go through the course stack

00:14:49,680 --> 00:14:53,440
for each of them it comes

00:14:51,199 --> 00:14:55,440
back to the same function which is a

00:14:53,440 --> 00:14:57,360
textbook

00:14:55,440 --> 00:14:59,279
the description of this function clearly

00:14:57,360 --> 00:15:01,120
says it's trying to update instruction

00:14:59,279 --> 00:15:03,920
on live kernel so this is a

00:15:01,120 --> 00:15:06,000
valid case for kernel modifications

00:15:03,920 --> 00:15:07,040
after we remove of that particular

00:15:06,000 --> 00:15:09,360
particular module

00:15:07,040 --> 00:15:11,600
look at that the gas running smoothly

00:15:09,360 --> 00:15:13,440
without any further violations

00:15:11,600 --> 00:15:14,800
this is this is a very good example to

00:15:13,440 --> 00:15:18,320
show you like

00:15:14,800 --> 00:15:21,760
if we configure the image correctly

00:15:18,320 --> 00:15:24,959
any violations any access violations

00:15:21,760 --> 00:15:27,839
would be a strong hint of possible

00:15:24,959 --> 00:15:27,839
attack

00:15:30,000 --> 00:15:35,759
now let's talk about to support

00:15:33,360 --> 00:15:37,519
the protection we just mentioned what

00:15:35,759 --> 00:15:41,199
are the changes we need

00:15:37,519 --> 00:15:42,880
for kvm and and first of all we want a

00:15:41,199 --> 00:15:43,759
common interface to turn down the

00:15:42,880 --> 00:15:46,000
protection

00:15:43,759 --> 00:15:48,320
as you can see during boot time the

00:15:46,000 --> 00:15:51,600
guest agent is sending some message

00:15:48,320 --> 00:15:55,440
to the hypervisor and bmm

00:15:51,600 --> 00:15:59,440
so currently we are using a select msr

00:15:55,440 --> 00:16:02,240
for these configurations it's not ideal

00:15:59,440 --> 00:16:04,720
if we can make allocator special hype

00:16:02,240 --> 00:16:07,440
call just for this purpose

00:16:04,720 --> 00:16:08,320
it will show that this is for vm only

00:16:07,440 --> 00:16:11,600
and with one

00:16:08,320 --> 00:16:14,560
it will avoid a lot of confusions and

00:16:11,600 --> 00:16:15,600
once people agree on the interface api

00:16:14,560 --> 00:16:18,639
what's a

00:16:15,600 --> 00:16:20,800
hype call looks like any hypervisor or

00:16:18,639 --> 00:16:23,440
vmm can implement

00:16:20,800 --> 00:16:23,839
the support for this api to provide the

00:16:23,440 --> 00:16:27,519
same

00:16:23,839 --> 00:16:30,720
level of production no matter where

00:16:27,519 --> 00:16:34,320
or the vm will be landing uh

00:16:30,720 --> 00:16:37,360
like azure aws or google cloud or

00:16:34,320 --> 00:16:40,800
music can all implement the same apis so

00:16:37,360 --> 00:16:41,839
the guests can move freely around

00:16:40,800 --> 00:16:44,399
different

00:16:41,839 --> 00:16:46,959
providers and gain the same level of

00:16:44,399 --> 00:16:46,959
protection

00:16:47,199 --> 00:16:55,199
we have a rfc sent out a while ago

00:16:51,040 --> 00:16:58,240
so that's for adding a hap call

00:16:55,199 --> 00:17:00,720
called abm hype call you call

00:16:58,240 --> 00:17:02,079
so this is a hype call we want to tell

00:17:00,720 --> 00:17:05,919
the high visor to

00:17:02,079 --> 00:17:08,799
to hand over to bmm to handle this

00:17:05,919 --> 00:17:10,640
uh bachelor hep course we have a link

00:17:08,799 --> 00:17:14,160
and you guys can review it

00:17:10,640 --> 00:17:15,600
um so why we need this change so today

00:17:14,160 --> 00:17:20,160
all the hype core are handled

00:17:15,600 --> 00:17:23,360
inside kvm it never caused any vm exit

00:17:20,160 --> 00:17:25,679
and but we won't have call to pass

00:17:23,360 --> 00:17:26,400
we want a hardcore interface to pass the

00:17:25,679 --> 00:17:29,360
control

00:17:26,400 --> 00:17:32,960
back to the vmin why we want to bmm to

00:17:29,360 --> 00:17:35,760
handle this request instead of kvm

00:17:32,960 --> 00:17:36,320
because bmin is responsible for setting

00:17:35,760 --> 00:17:39,520
up

00:17:36,320 --> 00:17:41,440
the guest memory mapping and should have

00:17:39,520 --> 00:17:44,480
knowledge or should control

00:17:41,440 --> 00:17:47,039
the permission associated with it

00:17:44,480 --> 00:17:49,520
and what's more important is it can

00:17:47,039 --> 00:17:52,240
simplify the support for line migration

00:17:49,520 --> 00:17:52,799
because during live migration vmm could

00:17:52,240 --> 00:17:55,360
just

00:17:52,799 --> 00:17:56,320
create the same gas memory apply the

00:17:55,360 --> 00:17:58,960
permission

00:17:56,320 --> 00:18:00,000
because it has knowledge of everything

00:17:58,960 --> 00:18:02,400
and

00:18:00,000 --> 00:18:04,480
we can keep the kvm simple kvm just need

00:18:02,400 --> 00:18:06,240
to expose api we need to turn on the

00:18:04,480 --> 00:18:07,039
production and all the status is

00:18:06,240 --> 00:18:10,960
maintained

00:18:07,039 --> 00:18:10,960
in the vmm instead of kvn

00:18:11,760 --> 00:18:16,640
so once we have the hype call defined we

00:18:14,960 --> 00:18:19,520
want to defend the message

00:18:16,640 --> 00:18:20,799
sending from the guest to bmm this is a

00:18:19,520 --> 00:18:24,320
single proposal

00:18:20,799 --> 00:18:27,760
we put here we want um

00:18:24,320 --> 00:18:30,320
we won't call it hbi request it's a

00:18:27,760 --> 00:18:33,440
hyper-based integrity request

00:18:30,320 --> 00:18:36,880
and we have a version and operation code

00:18:33,440 --> 00:18:38,559
so for operation it can be set memory

00:18:36,880 --> 00:18:41,600
protection

00:18:38,559 --> 00:18:42,799
etc etc we can extend it for future

00:18:41,600 --> 00:18:45,760
usage

00:18:42,799 --> 00:18:46,320
and for the memory for the message body

00:18:45,760 --> 00:18:48,880
um

00:18:46,320 --> 00:18:50,000
it only needs to tell us what's the pfn

00:18:48,880 --> 00:18:51,440
page physical number

00:18:50,000 --> 00:18:53,840
how many number of pages you want to

00:18:51,440 --> 00:18:54,320
protect what memory permission you want

00:18:53,840 --> 00:18:56,960
to set

00:18:54,320 --> 00:18:58,720
on this on those pages for the memory

00:18:56,960 --> 00:19:02,160
permission it can be read and they

00:18:58,720 --> 00:19:05,120
read and execute or read and write

00:19:02,160 --> 00:19:06,880
never allowed execute and write happen

00:19:05,120 --> 00:19:09,760
same time

00:19:06,880 --> 00:19:11,760
and once the request is complete gets

00:19:09,760 --> 00:19:17,200
able to

00:19:11,760 --> 00:19:17,200
get the result from this written code

00:19:18,320 --> 00:19:23,120
that's for the protocol for the guest

00:19:20,720 --> 00:19:26,160
bmm communication protocol

00:19:23,120 --> 00:19:29,840
other than that um they

00:19:26,160 --> 00:19:32,000
correctly set the memory machine

00:19:29,840 --> 00:19:33,280
we need to call the kvm set user memory

00:19:32,000 --> 00:19:35,679
reaching actor

00:19:33,280 --> 00:19:36,960
because unfortunately today the current

00:19:35,679 --> 00:19:40,160
call only supports setting

00:19:36,960 --> 00:19:43,120
memory as read and executable

00:19:40,160 --> 00:19:44,960
but we won't read and write not

00:19:43,120 --> 00:19:46,559
executable this is something

00:19:44,960 --> 00:19:48,000
at the last part today we'll try to

00:19:46,559 --> 00:19:50,480
extend it

00:19:48,000 --> 00:19:53,360
and we also want to expose the ability

00:19:50,480 --> 00:19:56,320
to do vm exit on

00:19:53,360 --> 00:19:58,080
control register modifications because

00:19:56,320 --> 00:19:59,039
there's a lot of bits we want to protect

00:19:58,080 --> 00:20:02,400
here

00:19:59,039 --> 00:20:05,039
and the hardware entire amd this

00:20:02,400 --> 00:20:09,039
part if you config for example the vmcs

00:20:05,039 --> 00:20:12,080
correctly we can get to exit on

00:20:09,039 --> 00:20:14,559
controller 0 or control register 4.

00:20:12,080 --> 00:20:16,400
and we want vmm to make its call whether

00:20:14,559 --> 00:20:18,640
we like the modification to go through

00:20:16,400 --> 00:20:21,600
or we should not

00:20:18,640 --> 00:20:23,600
last um this is basically support the

00:20:21,600 --> 00:20:26,080
new intel hybridizer man

00:20:23,600 --> 00:20:27,360
linear address translation this is new

00:20:26,080 --> 00:20:30,480
hardware i don't see

00:20:27,360 --> 00:20:33,520
what is there um i hope intel

00:20:30,480 --> 00:20:35,760
or some community members or us

00:20:33,520 --> 00:20:38,320
will work on the support for this

00:20:35,760 --> 00:20:38,320
together

00:20:38,640 --> 00:20:45,919
and for the future once we have the

00:20:41,760 --> 00:20:49,840
um the production we talk about in place

00:20:45,919 --> 00:20:51,200
we can extend this gasket module to

00:20:49,840 --> 00:20:54,240
expose apis

00:20:51,200 --> 00:20:57,520
for any kernel code to consume

00:20:54,240 --> 00:21:00,640
it can be a driver it can be a security

00:20:57,520 --> 00:21:02,720
hardening code inside the kernel so they

00:21:00,640 --> 00:21:05,760
can call the api during boot

00:21:02,720 --> 00:21:09,760
allocate a memory and write to it

00:21:05,760 --> 00:21:13,120
and then mark it as read only so

00:21:09,760 --> 00:21:16,400
we will send this memory segment to

00:21:13,120 --> 00:21:18,480
the hybridizer at the end of boot

00:21:16,400 --> 00:21:19,440
and then we make sure those memory will

00:21:18,480 --> 00:21:23,760
never change

00:21:19,440 --> 00:21:26,000
during the entire lifetime of the vm

00:21:23,760 --> 00:21:28,400
so yeah all the kernel security and

00:21:26,000 --> 00:21:31,840
driver modules can take other advantage

00:21:28,400 --> 00:21:31,840
of these to protect themselves

00:21:32,960 --> 00:21:37,039
now let's talk about some other security

00:21:35,600 --> 00:21:39,039
considerations

00:21:37,039 --> 00:21:41,200
first of all all the protection we

00:21:39,039 --> 00:21:44,480
talked about today is built on top of

00:21:41,200 --> 00:21:45,840
keyboard if skill boot is broken um our

00:21:44,480 --> 00:21:48,320
guest agent could be

00:21:45,840 --> 00:21:51,120
changed and we cannot trust the message

00:21:48,320 --> 00:21:52,720
it's sent to us

00:21:51,120 --> 00:21:54,240
so why can't we trust the keyboard in

00:21:52,720 --> 00:21:56,480
google cloud um

00:21:54,240 --> 00:21:57,280
for google cloud all the guest programs

00:21:56,480 --> 00:21:59,679
uv runway

00:21:57,280 --> 00:22:01,520
is actually immutable we inject the gas

00:21:59,679 --> 00:22:03,280
from we are doing both time to copy it

00:22:01,520 --> 00:22:06,080
into the gas memory

00:22:03,280 --> 00:22:06,720
and so even if you manage to change the

00:22:06,080 --> 00:22:09,120
front wheel

00:22:06,720 --> 00:22:10,159
in some special way during runtime after

00:22:09,120 --> 00:22:12,400
you reboot

00:22:10,159 --> 00:22:15,200
you will get a fresh piece of firmware

00:22:12,400 --> 00:22:18,320
and will restore back to a good state

00:22:15,200 --> 00:22:21,679
a lot of firmware integrity check

00:22:18,320 --> 00:22:24,320
is actually happening outside guest

00:22:21,679 --> 00:22:25,600
we know that's critical piece of code we

00:22:24,320 --> 00:22:28,320
want to make sure it's

00:22:25,600 --> 00:22:29,440
doing what we expect so a lot of

00:22:28,320 --> 00:22:32,080
security check

00:22:29,440 --> 00:22:32,640
signature check is happening we upload

00:22:32,080 --> 00:22:34,799
those

00:22:32,640 --> 00:22:36,880
also logic into the vmm processor it's

00:22:34,799 --> 00:22:38,960
not happening inside the guest

00:22:36,880 --> 00:22:41,600
and for important security boot

00:22:38,960 --> 00:22:43,520
variables primary keys

00:22:41,600 --> 00:22:45,600
signatures they are stored on remote

00:22:43,520 --> 00:22:49,039
server instead of your local disk

00:22:45,600 --> 00:22:52,480
so there's no way a guest can skip

00:22:49,039 --> 00:22:55,440
uv and skip our formula to modify the

00:22:52,480 --> 00:22:56,159
those variables directly one popular

00:22:55,440 --> 00:22:58,960
attack

00:22:56,159 --> 00:22:59,919
against secure boot is through system

00:22:58,960 --> 00:23:03,440
management mode

00:22:59,919 --> 00:23:03,440
called stm attack

00:23:04,240 --> 00:23:10,400
to reduce the attack surface

00:23:07,600 --> 00:23:11,600
and the sn smm is completely dropped

00:23:10,400 --> 00:23:14,799
from workout

00:23:11,600 --> 00:23:16,880
we don't support it at all but

00:23:14,799 --> 00:23:18,960
the protection is not perfect even if we

00:23:16,880 --> 00:23:21,200
guarantee the kernel code stays the same

00:23:18,960 --> 00:23:22,080
through the entire runtime and nothing

00:23:21,200 --> 00:23:24,799
gets executed

00:23:22,080 --> 00:23:25,440
outside this kernel code space there are

00:23:24,799 --> 00:23:27,440
still

00:23:25,440 --> 00:23:28,880
possibilities people can use something

00:23:27,440 --> 00:23:32,159
called return oriented

00:23:28,880 --> 00:23:33,600
programming drop attack and what it does

00:23:32,159 --> 00:23:37,039
is trying to find

00:23:33,600 --> 00:23:39,200
some instructions on your executable

00:23:37,039 --> 00:23:41,679
region and change them together to

00:23:39,200 --> 00:23:45,840
achieve some special goals

00:23:41,679 --> 00:23:47,679
and for example if people use drop

00:23:45,840 --> 00:23:50,480
attack to modify the kernel prototype

00:23:47,679 --> 00:23:51,120
kernel page table will still break the

00:23:50,480 --> 00:23:54,400
protection

00:23:51,120 --> 00:23:56,880
because you can modify the

00:23:54,400 --> 00:23:59,919
table translation and point the kernel

00:23:56,880 --> 00:24:03,440
code to a different memory location

00:23:59,919 --> 00:24:04,720
and if that happens that memory location

00:24:03,440 --> 00:24:08,880
is not is no longer

00:24:04,720 --> 00:24:10,880
protected by any ept or ntp so

00:24:08,880 --> 00:24:13,120
the hacker can do whatever they want

00:24:10,880 --> 00:24:18,559
there medicaid is a problem

00:24:13,120 --> 00:24:21,200
um i think funnels just randomization is

00:24:18,559 --> 00:24:22,720
very popular today let's make rubber

00:24:21,200 --> 00:24:26,320
attack a little bit harder

00:24:22,720 --> 00:24:28,480
and yes ongoing work for the

00:24:26,320 --> 00:24:29,840
internal control flow integrity make

00:24:28,480 --> 00:24:31,520
sure

00:24:29,840 --> 00:24:33,039
make it harder to happen or make sure

00:24:31,520 --> 00:24:35,600
it's never happened

00:24:33,039 --> 00:24:37,039
and there's hardware support like the

00:24:35,600 --> 00:24:38,720
hypervisor managed

00:24:37,039 --> 00:24:40,640
linear address based translation we

00:24:38,720 --> 00:24:41,520
talked about earlier where you can make

00:24:40,640 --> 00:24:43,760
sure

00:24:41,520 --> 00:24:45,600
the adjust base adjust space translation

00:24:43,760 --> 00:24:48,880
is happening on the hypervisor side

00:24:45,600 --> 00:24:50,960
so let's and avoid

00:24:48,880 --> 00:24:53,360
people hack this page table in some

00:24:50,960 --> 00:24:55,760
special way

00:24:53,360 --> 00:24:56,480
to summarize this presentation we are

00:24:55,760 --> 00:24:59,919
trying to

00:24:56,480 --> 00:25:01,919
propose a hypervisor based reinforced

00:24:59,919 --> 00:25:03,120
protection for gas memories and system

00:25:01,919 --> 00:25:06,640
registers

00:25:03,120 --> 00:25:08,080
and we want to also provide a parallel

00:25:06,640 --> 00:25:11,360
virtualization

00:25:08,080 --> 00:25:14,480
interface to enable and

00:25:11,360 --> 00:25:16,799
enable this in protection

00:25:14,480 --> 00:25:18,400
and we want to enable secure security by

00:25:16,799 --> 00:25:20,880
default um

00:25:18,400 --> 00:25:22,480
this happening we are proposing here is

00:25:20,880 --> 00:25:26,840
to extend the skill boot and

00:25:22,480 --> 00:25:28,559
provides runtime protection for kernel

00:25:26,840 --> 00:25:38,720
integrity

00:25:28,559 --> 00:25:38,720

YouTube URL: https://www.youtube.com/watch?v=8bxoezwK2ak


