Title: Bitmaps and NBD: Building Blocks of Change Block Tracking - Eric Blake, Red Hat
Publication date: 2020-11-12
Playlist: KVM Forum Europe 2020
Description: 
	Bitmaps and NBD: Building Blocks of Change Block Tracking - Eric Blake, Red Hat
Captions: 
	00:00:06,640 --> 00:00:09,360
hello

00:00:07,279 --> 00:00:10,400
i'm eric blake i am a senior software

00:00:09,360 --> 00:00:12,960
engineer at

00:00:10,400 --> 00:00:15,280
red hat where i have been working in the

00:00:12,960 --> 00:00:16,640
last few years on the qmu project as

00:00:15,280 --> 00:00:19,680
well as libvert

00:00:16,640 --> 00:00:22,160
and also with the nbd protocol in

00:00:19,680 --> 00:00:23,920
working on incremental backups today's

00:00:22,160 --> 00:00:27,359
talk bitmaps and nbd

00:00:23,920 --> 00:00:30,720
building blocks of change block tracking

00:00:27,359 --> 00:00:32,719
it's a mouthful of words but ultimately

00:00:30,720 --> 00:00:34,320
it boils down to the premise that when

00:00:32,719 --> 00:00:36,000
we're doing backups

00:00:34,320 --> 00:00:37,920
we want to optimize an incremental

00:00:36,000 --> 00:00:38,399
backup says rather than backing up

00:00:37,920 --> 00:00:41,200
everything

00:00:38,399 --> 00:00:43,120
if i can figure out which blocks changed

00:00:41,200 --> 00:00:45,920
since my last backup

00:00:43,120 --> 00:00:47,600
and only back up those blocks then i

00:00:45,920 --> 00:00:49,840
have a more efficient backup

00:00:47,600 --> 00:00:51,600
for each following day and then i can

00:00:49,840 --> 00:00:54,800
reconstruct the overall image

00:00:51,600 --> 00:00:57,360
by layering those incremental backups

00:00:54,800 --> 00:00:58,960
in this talk i will go over how cucao 2

00:00:57,360 --> 00:01:01,520
has

00:00:58,960 --> 00:01:02,879
exposed dirty bitmaps as its change

00:01:01,520 --> 00:01:05,760
block mechanism

00:01:02,879 --> 00:01:07,040
and how the nbd protocol is used

00:01:05,760 --> 00:01:12,560
alongside libvert

00:01:07,040 --> 00:01:14,000
to implement incremental backups

00:01:12,560 --> 00:01:15,759
change block tracking is a term that's

00:01:14,000 --> 00:01:19,840
been around for multiple years

00:01:15,759 --> 00:01:23,439
it has been introduced

00:01:19,840 --> 00:01:26,720
by the backup industry

00:01:23,439 --> 00:01:27,520
as a way of figuring out which portions

00:01:26,720 --> 00:01:29,200
of the disk

00:01:27,520 --> 00:01:31,360
have changed since a certain point in

00:01:29,200 --> 00:01:33,439
time there are two general

00:01:31,360 --> 00:01:35,520
common approaches to doing change block

00:01:33,439 --> 00:01:37,200
tracking one is with a generation tag

00:01:35,520 --> 00:01:38,479
every time you write to a cluster you

00:01:37,200 --> 00:01:41,520
also write

00:01:38,479 --> 00:01:44,880
a generation id metadata somewhere

00:01:41,520 --> 00:01:45,920
and the idea is then you can say at this

00:01:44,880 --> 00:01:48,960
point in time

00:01:45,920 --> 00:01:50,799
i was at id xyz

00:01:48,960 --> 00:01:52,320
all blocks that have an id greater than

00:01:50,799 --> 00:01:54,000
xyz have changed

00:01:52,320 --> 00:01:56,240
since that point in time therefore those

00:01:54,000 --> 00:01:58,399
are the blocks i care about

00:01:56,240 --> 00:01:59,520
it does require a fair amount of

00:01:58,399 --> 00:02:02,240
metadata

00:01:59,520 --> 00:02:03,920
per cluster but the nice part is you can

00:02:02,240 --> 00:02:05,840
track multiple points in time all with

00:02:03,920 --> 00:02:07,119
the same amount of metadata

00:02:05,840 --> 00:02:09,200
the other common approach is with a

00:02:07,119 --> 00:02:12,480
dirty bitmap instead of having

00:02:09,200 --> 00:02:14,640
a 64-bit id number you have a single bit

00:02:12,480 --> 00:02:16,239
that says has this block changed since a

00:02:14,640 --> 00:02:18,800
given point in time

00:02:16,239 --> 00:02:20,080
you do need one bitmap per point in time

00:02:18,800 --> 00:02:20,640
that you're tracking so it's a little

00:02:20,080 --> 00:02:24,319
less

00:02:20,640 --> 00:02:26,160
granular on when you can compare to

00:02:24,319 --> 00:02:27,599
but there are also some optimizations

00:02:26,160 --> 00:02:30,640
because there's less data

00:02:27,599 --> 00:02:32,400
being written per bitmap you can

00:02:30,640 --> 00:02:34,000
store things in memory and flush only at

00:02:32,400 --> 00:02:35,280
strategic times

00:02:34,000 --> 00:02:37,840
an important point to remember with

00:02:35,280 --> 00:02:39,840
backups a full backup

00:02:37,840 --> 00:02:41,200
is always correct as long as your guest

00:02:39,840 --> 00:02:43,519
data has

00:02:41,200 --> 00:02:44,239
not been corrupted a full backup may be

00:02:43,519 --> 00:02:46,400
slow

00:02:44,239 --> 00:02:47,360
but it will be correct change block

00:02:46,400 --> 00:02:49,680
tracking is

00:02:47,360 --> 00:02:51,040
merely an optimization so something ever

00:02:49,680 --> 00:02:53,440
goes wrong with your change block

00:02:51,040 --> 00:02:56,959
trackings if you lose a bitmap

00:02:53,440 --> 00:03:00,319
or if you corrupt your generation tag id

00:02:56,959 --> 00:03:02,080
your fallback is to do a full backup you

00:03:00,319 --> 00:03:04,159
don't lose the guest data you just have

00:03:02,080 --> 00:03:04,959
lost efficiency on handling that guest

00:03:04,159 --> 00:03:08,239
data

00:03:04,959 --> 00:03:10,800
and because of that fact the fact that

00:03:08,239 --> 00:03:12,400
backups change block tracking is an

00:03:10,800 --> 00:03:14,319
optimization

00:03:12,400 --> 00:03:16,840
there are some interesting options

00:03:14,319 --> 00:03:20,000
interesting

00:03:16,840 --> 00:03:22,400
uh uses or interesting

00:03:20,000 --> 00:03:23,040
behaviors that we can do where we're a

00:03:22,400 --> 00:03:24,879
little

00:03:23,040 --> 00:03:26,239
more cavalier on how we handle the data

00:03:24,879 --> 00:03:28,959
than we would be if it were guest

00:03:26,239 --> 00:03:28,959
visible data

00:03:30,080 --> 00:03:35,440
qt cow 2 is kumu's preferred image

00:03:33,200 --> 00:03:38,239
format

00:03:35,440 --> 00:03:40,000
we've had qca2 around for years it first

00:03:38,239 --> 00:03:44,000
used in-memory bitmaps for the block

00:03:40,000 --> 00:03:45,680
stream command introduced in 2012.

00:03:44,000 --> 00:03:47,519
over the years we decided hey bitmaps

00:03:45,680 --> 00:03:48,560
are so cool that we will use dirty

00:03:47,519 --> 00:03:51,280
bitmaps as

00:03:48,560 --> 00:03:51,840
our change block tracking mechanism and

00:03:51,280 --> 00:03:54,159
we first

00:03:51,840 --> 00:03:57,120
exposed a persistent dirty bitmap as

00:03:54,159 --> 00:03:59,519
part of the qca 2 image in 2016.

00:03:57,120 --> 00:04:00,640
it's actually done with an image

00:03:59,519 --> 00:04:03,840
extension header

00:04:00,640 --> 00:04:06,879
where we say here is the

00:04:03,840 --> 00:04:09,040
location of the bitmaps within the qco2

00:04:06,879 --> 00:04:10,159
file they're not guest visible just host

00:04:09,040 --> 00:04:12,480
visible

00:04:10,159 --> 00:04:14,640
and within those file within each of

00:04:12,480 --> 00:04:17,519
those bitmaps we track a granularity

00:04:14,640 --> 00:04:19,199
you can the default is one bit per

00:04:17,519 --> 00:04:22,160
cluster of the image

00:04:19,199 --> 00:04:25,600
but you can also do finer grained or

00:04:22,160 --> 00:04:29,759
coarser grained depending on your needs

00:04:25,600 --> 00:04:30,320
right now qcal 2 as a file format will

00:04:29,759 --> 00:04:34,160
support

00:04:30,320 --> 00:04:36,240
any size bitmap but qmu as the program

00:04:34,160 --> 00:04:38,400
using those bitmaps insists that the

00:04:36,240 --> 00:04:40,880
bitmaps be the same length as the disk

00:04:38,400 --> 00:04:40,880
itself

00:04:41,040 --> 00:04:44,479
also we took care when we added

00:04:43,280 --> 00:04:47,440
persistent bitmaps

00:04:44,479 --> 00:04:47,919
to add a autoclear feature bit if you

00:04:47,440 --> 00:04:50,240
ever

00:04:47,919 --> 00:04:52,639
operate on a qcal2 file with an older

00:04:50,240 --> 00:04:54,880
program that doesn't understand bitmaps

00:04:52,639 --> 00:04:56,160
the newer program will then see that hey

00:04:54,880 --> 00:04:59,840
the bitmaps are probably

00:04:56,160 --> 00:05:01,759
incomplete treat them as corrupt

00:04:59,840 --> 00:05:03,520
and once again as i said earlier that

00:05:01,759 --> 00:05:06,720
just means we have to do a full backup

00:05:03,520 --> 00:05:06,720
instead of an incremental

00:05:07,520 --> 00:05:10,960
kumu has also been involved with the

00:05:09,120 --> 00:05:11,919
network block device protocol over the

00:05:10,960 --> 00:05:15,120
years

00:05:11,919 --> 00:05:18,160
we first introduced nbd as a

00:05:15,120 --> 00:05:20,880
client support for qmo back in 2008

00:05:18,160 --> 00:05:23,280
as well as the program kumu mbd which

00:05:20,880 --> 00:05:26,320
acted as a rudimentary server

00:05:23,280 --> 00:05:28,800
as well as a hook to call into the

00:05:26,320 --> 00:05:28,800
kernel's

00:05:29,400 --> 00:05:35,759
nbd.ko module for

00:05:32,639 --> 00:05:39,199
accessing a block device served by an

00:05:35,759 --> 00:05:42,479
nvd server

00:05:39,199 --> 00:05:44,639
over the years we then have added things

00:05:42,479 --> 00:05:47,759
to kumu in 2012

00:05:44,639 --> 00:05:50,880
we made it possible to export a qmu

00:05:47,759 --> 00:05:53,600
image as an nbd drive

00:05:50,880 --> 00:05:55,440
while qmu is running this helps with

00:05:53,600 --> 00:05:58,639
live migration of your storage

00:05:55,440 --> 00:06:01,840
we on the source we set up

00:05:58,639 --> 00:06:03,520
a all the

00:06:01,840 --> 00:06:05,360
all the pieces we'll need to migrate on

00:06:03,520 --> 00:06:06,160
the destination we then start a qmo

00:06:05,360 --> 00:06:08,720
server

00:06:06,160 --> 00:06:10,479
the source then says do a mirror job

00:06:08,720 --> 00:06:10,880
everything that i write locally i will

00:06:10,479 --> 00:06:13,120
also

00:06:10,880 --> 00:06:14,560
mirror over to my nbd server which is on

00:06:13,120 --> 00:06:16,080
my destination

00:06:14,560 --> 00:06:18,639
when the mirror job is complete then the

00:06:16,080 --> 00:06:20,479
destination has a copy of my storage

00:06:18,639 --> 00:06:22,000
now i can do the live migration of the

00:06:20,479 --> 00:06:24,080
memory

00:06:22,000 --> 00:06:25,440
and stop the nbd server at that point

00:06:24,080 --> 00:06:28,639
and we have now copied

00:06:25,440 --> 00:06:31,280
the server the disk data over by using

00:06:28,639 --> 00:06:35,039
an nbd connection

00:06:31,280 --> 00:06:37,360
in 2016 we added tls support in 2018 we

00:06:35,039 --> 00:06:39,520
added block status block status lets you

00:06:37,360 --> 00:06:40,800
query an nbd drive and say which

00:06:39,520 --> 00:06:43,600
portions

00:06:40,800 --> 00:06:45,600
of my image have which properties uh an

00:06:43,600 --> 00:06:48,240
interesting part of the nbd protocol was

00:06:45,600 --> 00:06:51,520
that block status has multiple contexts

00:06:48,240 --> 00:06:51,840
where you can define your own context so

00:06:51,520 --> 00:06:53,919
q

00:06:51,840 --> 00:06:55,520
has done just that we defined the qmu

00:06:53,919 --> 00:06:58,479
dirty bitmap context

00:06:55,520 --> 00:06:59,680
to expose a persistent dirty bitmap in

00:06:58,479 --> 00:07:01,840
addition to the

00:06:59,680 --> 00:07:02,880
nbd standard of base allocation that

00:07:01,840 --> 00:07:06,720
says which port

00:07:02,880 --> 00:07:06,720
portions of your image read the zeros

00:07:07,039 --> 00:07:10,560
so with all of that introduction let's

00:07:08,800 --> 00:07:12,560
go ahead and

00:07:10,560 --> 00:07:13,680
play with the files we'll need to do a

00:07:12,560 --> 00:07:18,000
guest

00:07:13,680 --> 00:07:21,360
i'm going to use vert builder

00:07:18,000 --> 00:07:23,520
to grab a fedora 32 image

00:07:21,360 --> 00:07:24,880
i'm going to inject a root password so

00:07:23,520 --> 00:07:27,680
that we can ssh

00:07:24,880 --> 00:07:28,080
into it actually with fedora 32 you

00:07:27,680 --> 00:07:31,280
can't

00:07:28,080 --> 00:07:33,919
ssh with a root password you have to use

00:07:31,280 --> 00:07:34,720
a key file but that's what the ssh

00:07:33,919 --> 00:07:38,000
inject

00:07:34,720 --> 00:07:40,479
portion of the command line does

00:07:38,000 --> 00:07:42,080
it takes a little less than a minute so

00:07:40,479 --> 00:07:43,919
i will continue talking

00:07:42,080 --> 00:07:45,680
we're going to use this image for the

00:07:43,919 --> 00:07:49,199
demos and the rest of this talk

00:07:45,680 --> 00:07:51,360
uh we're going to both play with

00:07:49,199 --> 00:07:53,280
it directly in qmu and see what happens

00:07:51,360 --> 00:07:55,120
with the bitmaps as well as

00:07:53,280 --> 00:07:56,319
in lymphert and see what happens when i

00:07:55,120 --> 00:08:00,080
use libvert commands

00:07:56,319 --> 00:08:00,080
to drive an incremental backup

00:08:00,319 --> 00:08:07,199
the image is nearly ready

00:08:04,720 --> 00:08:08,080
just a few more seconds and there we go

00:08:07,199 --> 00:08:12,160
it took

00:08:08,080 --> 00:08:15,360
uh 45 seconds created a six gigabyte

00:08:12,160 --> 00:08:18,080
image containing a fedora 32 image

00:08:15,360 --> 00:08:19,520
i'm also going to create a 100 megabyte

00:08:18,080 --> 00:08:22,080
secondary disk that we can play with

00:08:19,520 --> 00:08:24,960
directly

00:08:22,080 --> 00:08:26,000
and with those disks in hand my next

00:08:24,960 --> 00:08:29,680
task

00:08:26,000 --> 00:08:32,320
will be to create a live vert domain

00:08:29,680 --> 00:08:33,760
using those disks so i'll use the vert

00:08:32,320 --> 00:08:36,399
install command

00:08:33,760 --> 00:08:38,000
pointing to those two disks uh as you

00:08:36,399 --> 00:08:41,360
can see the image is ready to go we're

00:08:38,000 --> 00:08:43,839
booting it now

00:08:41,360 --> 00:08:45,279
i'm going to finish the install by

00:08:43,839 --> 00:08:46,800
logging in as root

00:08:45,279 --> 00:08:48,880
and then we'll do the rest of our work

00:08:46,800 --> 00:08:52,000
through ssh there's no need to have

00:08:48,880 --> 00:08:54,640
multiple windows here

00:08:52,000 --> 00:08:55,600
but it's burton stall is a fun little

00:08:54,640 --> 00:08:58,160
tool for

00:08:55,600 --> 00:08:59,920
building everything libert will need and

00:08:58,160 --> 00:09:01,360
using the password i just injected in

00:08:59,920 --> 00:09:05,040
the previous step

00:09:01,360 --> 00:09:05,040
we can now tell the image

00:09:05,920 --> 00:09:11,920
to shut down give us some clean things

00:09:09,279 --> 00:09:13,200
to start with

00:09:11,920 --> 00:09:15,680
and now i'm going to run it in the

00:09:13,200 --> 00:09:18,000
background

00:09:15,680 --> 00:09:19,920
while the image is running you remember

00:09:18,000 --> 00:09:22,160
there was a few seconds at the beginning

00:09:19,920 --> 00:09:24,080
where the grub is doing a countdown

00:09:22,160 --> 00:09:26,160
before it actually starts the boot

00:09:24,080 --> 00:09:27,920
so we'll wait for those few seconds i'm

00:09:26,160 --> 00:09:31,440
going to grab the ip address

00:09:27,920 --> 00:09:31,440
of my guest

00:09:32,080 --> 00:09:37,839
i need to grab an ip address first

00:09:38,160 --> 00:09:44,000
there's my guest running at 122.10.

00:09:41,839 --> 00:09:46,000
we're gonna ssh into the guest i'm gonna

00:09:44,000 --> 00:09:48,480
make a file system on my

00:09:46,000 --> 00:09:49,839
b drive the secondary 100 megabytes that

00:09:48,480 --> 00:09:52,880
i had

00:09:49,839 --> 00:09:55,680
create a image on it touch a single file

00:09:52,880 --> 00:09:55,680
and then exit

00:09:55,920 --> 00:09:59,600
yes i do want to connect to my guest

00:09:58,080 --> 00:10:01,760
it's brand new that's why i have to

00:09:59,600 --> 00:10:05,200
accept it

00:10:01,760 --> 00:10:07,519
and for now i will shut the image back

00:10:05,200 --> 00:10:07,519
down

00:10:12,000 --> 00:10:16,959
and now that we have an image in place

00:10:14,560 --> 00:10:19,519
and all primed to use

00:10:16,959 --> 00:10:20,160
uh cumu image tells me that my secondary

00:10:19,519 --> 00:10:22,720
image

00:10:20,160 --> 00:10:24,720
is 100 megabytes wide and has no bitmaps

00:10:22,720 --> 00:10:26,880
associated let's give it one

00:10:24,720 --> 00:10:28,880
i'm going to use the new image bitmap

00:10:26,880 --> 00:10:32,320
commander added earlier this year

00:10:28,880 --> 00:10:36,240
to add to the base to file

00:10:32,320 --> 00:10:38,240
a bitmap named bmap0 and we repeat our

00:10:36,240 --> 00:10:39,839
info command and you can now see that

00:10:38,240 --> 00:10:41,920
there is a bitmap

00:10:39,839 --> 00:10:43,680
i told you earlier about the autoflag

00:10:41,920 --> 00:10:45,200
that says the bitmap is enabled any

00:10:43,680 --> 00:10:48,320
writes that i do to the image

00:10:45,200 --> 00:10:49,760
will update the contents of the bitmap

00:10:48,320 --> 00:10:52,480
so let's do some writes i'm going to

00:10:49,760 --> 00:10:55,120
create a file with the contents of hello

00:10:52,480 --> 00:10:56,640
by using guest fish i'm going to mount

00:10:55,120 --> 00:10:58,399
that image

00:10:56,640 --> 00:11:00,240
list what's currently there and then

00:10:58,399 --> 00:11:01,279
upload the contents hello into a new

00:11:00,240 --> 00:11:05,440
file named slash

00:11:01,279 --> 00:11:07,360
b and

00:11:05,440 --> 00:11:08,480
yes indeed the previous contents was

00:11:07,360 --> 00:11:10,959
just the file a

00:11:08,480 --> 00:11:11,600
now there's a file b and believe it or

00:11:10,959 --> 00:11:14,160
not

00:11:11,600 --> 00:11:15,760
adding a single file we're going to run

00:11:14,160 --> 00:11:18,399
qmu mbdo

00:11:15,760 --> 00:11:20,720
with dash capital b bmap0 to serve that

00:11:18,399 --> 00:11:23,440
bitmap

00:11:20,720 --> 00:11:25,519
and nbd info a new command this year

00:11:23,440 --> 00:11:29,120
from the lib nbd project

00:11:25,519 --> 00:11:31,440
to map that dirty bitmap

00:11:29,120 --> 00:11:33,279
from the nbd server that we have been

00:11:31,440 --> 00:11:35,120
running with qmu mbd

00:11:33,279 --> 00:11:38,079
and there you see it when i touched a

00:11:35,120 --> 00:11:42,399
single file it touched

00:11:38,079 --> 00:11:45,600
four different clusters of 64k each

00:11:42,399 --> 00:11:47,120
which makes sense the super block the

00:11:45,600 --> 00:11:48,640
directory that containing the file and

00:11:47,120 --> 00:11:52,079
the file itself

00:11:48,640 --> 00:11:55,120
all will add up to around each each of

00:11:52,079 --> 00:11:58,880
them require a cluster to be touched

00:11:55,120 --> 00:12:00,959
and with that we'll move on

00:11:58,880 --> 00:12:02,000
to another idea that we can do with kimo

00:12:00,959 --> 00:12:03,760
mbd

00:12:02,000 --> 00:12:05,040
i'm going to create an overlay file over

00:12:03,760 --> 00:12:08,560
my image

00:12:05,040 --> 00:12:12,000
um one of the benefits of qcao 2

00:12:08,560 --> 00:12:12,480
is that it is designed as backing chains

00:12:12,000 --> 00:12:14,320
in mind

00:12:12,480 --> 00:12:15,600
each file is sparse and whatever you

00:12:14,320 --> 00:12:17,920
don't get locally it comes from a

00:12:15,600 --> 00:12:20,720
backing file

00:12:17,920 --> 00:12:21,519
checking out the backing chain huh there

00:12:20,720 --> 00:12:23,600
is the

00:12:21,519 --> 00:12:26,160
bitmap that we created in the base file

00:12:23,600 --> 00:12:27,680
but the overlay does not have a bitmap

00:12:26,160 --> 00:12:29,360
so one of the things we had to implement

00:12:27,680 --> 00:12:32,720
over the last year was

00:12:29,360 --> 00:12:33,680
the libert commands to manage bitmaps

00:12:32,720 --> 00:12:35,680
under the hood

00:12:33,680 --> 00:12:37,440
in a saner way than what qmu could do

00:12:35,680 --> 00:12:39,839
automatically

00:12:37,440 --> 00:12:39,839
but even

00:12:42,000 --> 00:12:49,279
let's see next thing i'm going to do

00:12:45,680 --> 00:12:53,839
is touch some data in the overlay

00:12:49,279 --> 00:12:53,839
i don't have a bitmap tracking it

00:12:54,320 --> 00:13:00,639
but now i've touched file c we can say

00:12:57,360 --> 00:13:02,320
what with the dash capital a option

00:13:00,639 --> 00:13:05,279
we can say what is allocated in my

00:13:02,320 --> 00:13:08,079
overlay versus what is allocated in my

00:13:05,279 --> 00:13:09,760
backing file again with the nvd info

00:13:08,079 --> 00:13:12,639
command but this time we're going to map

00:13:09,760 --> 00:13:14,079
kumu allocation depth instead of kyumu

00:13:12,639 --> 00:13:16,959
dirty bitmap

00:13:14,079 --> 00:13:19,040
when we do that we can see the same four

00:13:16,959 --> 00:13:20,720
clusters have been touched locally to

00:13:19,040 --> 00:13:22,880
add my file c

00:13:20,720 --> 00:13:24,160
everything else comes from the backing

00:13:22,880 --> 00:13:26,480
file and

00:13:24,160 --> 00:13:27,600
as usual ext2 has a bunch of super

00:13:26,480 --> 00:13:28,079
blocks scattered through so you're going

00:13:27,600 --> 00:13:29,839
to have a

00:13:28,079 --> 00:13:32,880
repeating pattern of allocated and

00:13:29,839 --> 00:13:32,880
unallocated blocks

00:13:33,760 --> 00:13:37,680
and then i'm done with bitmap zero i'm

00:13:36,079 --> 00:13:41,040
going to remove it

00:13:37,680 --> 00:13:41,040
and we'll move on

00:13:41,920 --> 00:13:48,079
um when we first added the

00:13:44,959 --> 00:13:50,000
drive backup command back in 2015

00:13:48,079 --> 00:13:51,760
our original thoughts was kyumu would

00:13:50,000 --> 00:13:54,000
drive everything

00:13:51,760 --> 00:13:55,120
we'd create a single bitmap at the time

00:13:54,000 --> 00:13:58,000
you do a full

00:13:55,120 --> 00:14:00,639
full backup and then future incremental

00:13:58,000 --> 00:14:02,880
backups will use that prior bitmap state

00:14:00,639 --> 00:14:03,760
to create an external file all under qms

00:14:02,880 --> 00:14:05,760
control

00:14:03,760 --> 00:14:07,680
and reset the bitmap for the next thing

00:14:05,760 --> 00:14:09,360
so graphically

00:14:07,680 --> 00:14:12,000
we start with our image that's partially

00:14:09,360 --> 00:14:14,079
dirty we do a full backup

00:14:12,000 --> 00:14:16,079
and create our brand new bitmap all

00:14:14,079 --> 00:14:18,880
empty to say

00:14:16,079 --> 00:14:20,959
what's dirty at this point nothing then

00:14:18,880 --> 00:14:22,160
over time some bits do get dirty we

00:14:20,959 --> 00:14:25,279
write some new content

00:14:22,160 --> 00:14:27,120
the bitmap tracks those areas we say

00:14:25,279 --> 00:14:30,000
time to do another bitmap

00:14:27,120 --> 00:14:31,920
we take the dirty area copy it into a

00:14:30,000 --> 00:14:34,880
new incremental backup file and clear

00:14:31,920 --> 00:14:38,000
the bitmap all under qms control

00:14:34,880 --> 00:14:40,959
time progresses we write some more data

00:14:38,000 --> 00:14:42,000
the pattern repeats problem with having

00:14:40,959 --> 00:14:43,760
a single bitmap

00:14:42,000 --> 00:14:45,680
is that you can only track incremental

00:14:43,760 --> 00:14:49,279
backups you can't do differential

00:14:45,680 --> 00:14:51,279
so in 2018 we've modified things i had a

00:14:49,279 --> 00:14:52,880
presentation at kvm forum two years ago

00:14:51,279 --> 00:14:55,360
where we demonstrated

00:14:52,880 --> 00:14:57,199
what pull mode would entail instead of

00:14:55,360 --> 00:14:59,600
qmu writing out the file

00:14:57,199 --> 00:15:01,600
let's expose the file over mbd for

00:14:59,600 --> 00:15:04,720
third-party access

00:15:01,600 --> 00:15:06,480
and also at the time our thoughts were

00:15:04,720 --> 00:15:08,079
we're going to track multiple bitmaps

00:15:06,480 --> 00:15:09,519
for multiple points in time to let us do

00:15:08,079 --> 00:15:12,560
a differential backup

00:15:09,519 --> 00:15:14,399
so start with the same dirty data start

00:15:12,560 --> 00:15:15,279
with our initial bitmap for our first

00:15:14,399 --> 00:15:18,880
checkpoint

00:15:15,279 --> 00:15:19,600
in q in libvert and we create our full

00:15:18,880 --> 00:15:22,160
backup

00:15:19,600 --> 00:15:24,639
then as time elapses data gets written

00:15:22,160 --> 00:15:26,800
into that bitmap

00:15:24,639 --> 00:15:28,959
then we do another incremental backup

00:15:26,800 --> 00:15:31,360
and we mark b0 as disabled

00:15:28,959 --> 00:15:32,000
and now b1 has been created to track all

00:15:31,360 --> 00:15:34,639
changes

00:15:32,000 --> 00:15:35,040
since incremental backup one it starts

00:15:34,639 --> 00:15:38,160
out as

00:15:35,040 --> 00:15:39,040
empty more changes happen and notice

00:15:38,160 --> 00:15:42,880
that b0

00:15:39,040 --> 00:15:44,800
remains unchanged we only touch b1

00:15:42,880 --> 00:15:46,639
and it's time for another differential

00:15:44,800 --> 00:15:47,360
backup we can say i want to do backup

00:15:46,639 --> 00:15:50,000
from

00:15:47,360 --> 00:15:51,440
point zero where we took the full backup

00:15:50,000 --> 00:15:52,639
rather than point one where we did the

00:15:51,440 --> 00:15:54,320
incremental backup

00:15:52,639 --> 00:15:56,240
to do that i have to create a temporary

00:15:54,320 --> 00:15:59,519
bitmap that merges in

00:15:56,240 --> 00:16:01,839
all bits from b0 and b1

00:15:59,519 --> 00:16:02,720
and then expose my temporary bitmap over

00:16:01,839 --> 00:16:04,399
the wire

00:16:02,720 --> 00:16:05,839
to get the portion of the data that i

00:16:04,399 --> 00:16:08,000
need for a differential

00:16:05,839 --> 00:16:11,920
or i could do just a diff an incremental

00:16:08,000 --> 00:16:11,920
backup where i look at just b1 directly

00:16:12,079 --> 00:16:16,079
but it turns out that turning bitmaps on

00:16:15,279 --> 00:16:18,399
and off

00:16:16,079 --> 00:16:20,160
can turn into a lot of management

00:16:18,399 --> 00:16:21,360
overhead to track which bitmaps have to

00:16:20,160 --> 00:16:25,360
be enabled where

00:16:21,360 --> 00:16:25,360
especially gets messy when you have

00:16:25,440 --> 00:16:30,959
external snapshots or a backing chain so

00:16:28,959 --> 00:16:33,040
ultimately when livert finally did

00:16:30,959 --> 00:16:33,759
implement incremental backups we changed

00:16:33,040 --> 00:16:37,120
our mind

00:16:33,759 --> 00:16:39,839
yet again and now all checkpoints have a

00:16:37,120 --> 00:16:42,880
live bitmap at all times

00:16:39,839 --> 00:16:45,839
um so at our first bitmap we create

00:16:42,880 --> 00:16:47,680
our first full backup we create a bitmap

00:16:45,839 --> 00:16:50,720
over time we add bits

00:16:47,680 --> 00:16:52,079
we create an incremental backup i

00:16:50,720 --> 00:16:54,399
actually created an

00:16:52,079 --> 00:16:56,079
external snapshot you'll notice when we

00:16:54,399 --> 00:16:58,480
create an external snapshot

00:16:56,079 --> 00:17:00,800
bitmap zero is no longer changed because

00:16:58,480 --> 00:17:03,680
we're no longer writing to the base file

00:17:00,800 --> 00:17:05,120
but now overlay.qcow2 will be written we

00:17:03,680 --> 00:17:08,559
write some data

00:17:05,120 --> 00:17:12,319
there's the bitmap 0 in qcaw

00:17:08,559 --> 00:17:14,079
2 is different than the bitmap 0 in base

00:17:12,319 --> 00:17:15,439
but between those two bitmaps we still

00:17:14,079 --> 00:17:17,600
have a track of everything that's

00:17:15,439 --> 00:17:20,160
changed since our full backup

00:17:17,600 --> 00:17:20,640
so now we do an incremental backup once

00:17:20,160 --> 00:17:23,039
again

00:17:20,640 --> 00:17:23,919
we need that temporary bitmap to merge

00:17:23,039 --> 00:17:27,280
b0

00:17:23,919 --> 00:17:29,120
from our overlay and b0 from our base

00:17:27,280 --> 00:17:30,960
into what we expose over the incremental

00:17:29,120 --> 00:17:32,799
and we also create b1

00:17:30,960 --> 00:17:34,799
to start tracking changes since our

00:17:32,799 --> 00:17:36,640
incremental

00:17:34,799 --> 00:17:37,840
then we get rid of our temporary we

00:17:36,640 --> 00:17:39,600
write more data

00:17:37,840 --> 00:17:42,720
you'll notice that writing the data

00:17:39,600 --> 00:17:44,799
modifies both bitmaps at the same time

00:17:42,720 --> 00:17:46,559
whether we do this by actually writing

00:17:44,799 --> 00:17:48,799
data in kumu

00:17:46,559 --> 00:17:49,679
into the qcow 2 files at that time or

00:17:48,799 --> 00:17:51,360
optimize it

00:17:49,679 --> 00:17:53,600
and save it in one place in memory and

00:17:51,360 --> 00:17:55,120
then merge it out at the last minute

00:17:53,600 --> 00:17:57,360
is an optimization that can be done

00:17:55,120 --> 00:17:59,679
under the hood

00:17:57,360 --> 00:18:01,440
and then we do a block commit we say i

00:17:59,679 --> 00:18:02,240
want overlay's data to be merged back

00:18:01,440 --> 00:18:05,039
into base

00:18:02,240 --> 00:18:07,600
and liverick takes care of okay well

00:18:05,039 --> 00:18:08,320
base needs to have a b1 bitmap to track

00:18:07,600 --> 00:18:10,960
everything

00:18:08,320 --> 00:18:11,919
that was in b1 before the commit as well

00:18:10,960 --> 00:18:14,880
as all the data

00:18:11,919 --> 00:18:16,080
and b0 becomes the merge of the of the

00:18:14,880 --> 00:18:18,240
bitmaps

00:18:16,080 --> 00:18:19,919
if we do another incremental backup at

00:18:18,240 --> 00:18:22,960
this point

00:18:19,919 --> 00:18:24,320
we'll uh for ease livered always creates

00:18:22,960 --> 00:18:26,160
the temporary bitmap even though

00:18:24,320 --> 00:18:28,720
at this point it's just a single copy of

00:18:26,160 --> 00:18:31,200
b1 and we create our incremental backup

00:18:28,720 --> 00:18:35,679
and we're good to go

00:18:31,200 --> 00:18:35,679
so let's see this in action i'm going to

00:18:35,840 --> 00:18:42,320
um clear my screen there we go

00:18:39,840 --> 00:18:42,880
demonstration with libvard i'm going to

00:18:42,320 --> 00:18:45,679
start

00:18:42,880 --> 00:18:48,160
my domain that we created earlier it'll

00:18:45,679 --> 00:18:50,960
take a few seconds to come up but we can

00:18:48,160 --> 00:18:53,520
hardly attempt to backup oh wait

00:18:50,960 --> 00:18:56,640
incremental backup is not supported yet

00:18:53,520 --> 00:18:58,640
i am testing with qmu 5.1

00:18:56,640 --> 00:19:00,720
there are a few features in there that

00:18:58,640 --> 00:19:03,039
we did not quite have ready

00:19:00,720 --> 00:19:04,720
and libert refuses to use them until

00:19:03,039 --> 00:19:06,400
they are polished

00:19:04,720 --> 00:19:08,559
one of those is that when we are doing a

00:19:06,400 --> 00:19:11,679
block commit we have to

00:19:08,559 --> 00:19:14,320
modify the backing file to

00:19:11,679 --> 00:19:17,120
merge the bitmaps and right now that

00:19:14,320 --> 00:19:20,240
takes the x block dev reopen command

00:19:17,120 --> 00:19:22,640
qmoo5.2 will rename that to block dev

00:19:20,240 --> 00:19:24,799
reopen without the x prefix

00:19:22,640 --> 00:19:26,400
and as as such that will be when it's

00:19:24,799 --> 00:19:29,679
supported in the meantime

00:19:26,400 --> 00:19:32,799
we have a little hack

00:19:29,679 --> 00:19:34,000
i can take my xml for describing the

00:19:32,799 --> 00:19:36,480
domain

00:19:34,000 --> 00:19:38,799
and take the domain type add in an xml

00:19:36,480 --> 00:19:40,559
namespace for qmu

00:19:38,799 --> 00:19:42,320
in that namespace i'm going to add the

00:19:40,559 --> 00:19:43,360
capability incremental backup and it

00:19:42,320 --> 00:19:45,520
says

00:19:43,360 --> 00:19:47,120
use kumu even though it has to use the x

00:19:45,520 --> 00:19:50,480
prefix

00:19:47,120 --> 00:19:52,480
that tells lipvert everything he needs

00:19:50,480 --> 00:19:55,280
to do

00:19:52,480 --> 00:19:57,840
to use incremental backups so let's try

00:19:55,280 --> 00:19:57,840
this again

00:19:57,919 --> 00:20:04,960
start the domain let it boot up here

00:20:02,480 --> 00:20:06,720
i'm going to create a backup i'm going

00:20:04,960 --> 00:20:07,679
to use push mode where qmu writes the

00:20:06,720 --> 00:20:09,720
file

00:20:07,679 --> 00:20:11,440
i want to create a backup named

00:20:09,720 --> 00:20:13,760
full.qcow2

00:20:11,440 --> 00:20:14,799
i have a qcaw 2 file format for ease of

00:20:13,760 --> 00:20:16,720
use

00:20:14,799 --> 00:20:17,840
i also want to create a checkpoint at

00:20:16,720 --> 00:20:21,200
the same time i'll name it

00:20:17,840 --> 00:20:24,799
check 1. i'm pretty boring today

00:20:21,200 --> 00:20:25,679
um i will also pre-create my destination

00:20:24,799 --> 00:20:28,480
image for

00:20:25,679 --> 00:20:30,320
the sake of file permissions and with

00:20:28,480 --> 00:20:33,039
that pre-created image

00:20:30,320 --> 00:20:34,159
verse backup begin reuse the external

00:20:33,039 --> 00:20:36,159
image i just created

00:20:34,159 --> 00:20:37,440
and use those two xmls to describe what

00:20:36,159 --> 00:20:39,760
i'm doing

00:20:37,440 --> 00:20:41,679
there's my backup operation underway we

00:20:39,760 --> 00:20:44,880
can see it going

00:20:41,679 --> 00:20:46,799
uh kyumu finishes the job automatically

00:20:44,880 --> 00:20:50,640
and as soon as the job finishes

00:20:46,799 --> 00:20:52,320
i no longer have a backup backup xml to

00:20:50,640 --> 00:20:56,320
dump

00:20:52,320 --> 00:20:56,320
and with that we have a backup

00:20:57,840 --> 00:21:01,760
looking at the file size i did a backup

00:21:00,240 --> 00:21:04,960
of full

00:21:01,760 --> 00:21:05,440
using the contents of bass.1 the two are

00:21:04,960 --> 00:21:07,840
about

00:21:05,440 --> 00:21:10,559
the same size right now because it was a

00:21:07,840 --> 00:21:10,559
full backup

00:21:11,840 --> 00:21:15,120
now in livered i'm going to create an

00:21:13,360 --> 00:21:18,240
external snapshot

00:21:15,120 --> 00:21:19,039
i i want to track differential changes

00:21:18,240 --> 00:21:21,520
on top of

00:21:19,039 --> 00:21:22,880
of the base so i'm going to create a new

00:21:21,520 --> 00:21:27,760
overlay on top of

00:21:22,880 --> 00:21:29,919
base 1. there's my snapshot create

00:21:27,760 --> 00:21:31,360
see what images are used i'm still using

00:21:29,919 --> 00:21:32,640
my temporary base too we're going to

00:21:31,360 --> 00:21:35,919
ignore that

00:21:32,640 --> 00:21:37,840
i'm using the overlay image for my vda

00:21:35,919 --> 00:21:40,320
and if i look at the backing chain of

00:21:37,840 --> 00:21:45,840
overlay oh dear permission denied

00:21:40,320 --> 00:21:45,840
that's a good thing kumu is running

00:21:47,039 --> 00:21:51,840
on f32 we don't want to be messing with

00:21:49,840 --> 00:21:53,360
the disc at the same time that kumu is

00:21:51,840 --> 00:21:57,440
messing with the disc

00:21:53,360 --> 00:22:00,480
what we can do is request

00:21:57,440 --> 00:22:02,720
um i can use sudo

00:22:00,480 --> 00:22:03,679
and the dash u option to say i want to

00:22:02,720 --> 00:22:05,520
open the image

00:22:03,679 --> 00:22:08,080
in spite of it already being in use and

00:22:05,520 --> 00:22:10,960
hopefully my information is not too bad

00:22:08,080 --> 00:22:10,960
we'll do that

00:22:11,120 --> 00:22:14,159
and there's my backing chain overlay has

00:22:13,600 --> 00:22:17,600
um

00:22:14,159 --> 00:22:19,520
no backups no bitmaps and base one has

00:22:17,600 --> 00:22:20,880
the bitmap that we started earlier

00:22:19,520 --> 00:22:22,640
i just said liver does all the

00:22:20,880 --> 00:22:24,080
information to create bitmaps on the fly

00:22:22,640 --> 00:22:26,799
but we don't see one

00:22:24,080 --> 00:22:28,480
why is that because i also said qumu

00:22:26,799 --> 00:22:31,200
stores as much in memory

00:22:28,480 --> 00:22:33,440
for as long as possible so i'm going to

00:22:31,200 --> 00:22:35,600
shut down the domain

00:22:33,440 --> 00:22:36,799
and with the domain finally shut down

00:22:35,600 --> 00:22:38,320
we're going to try that again

00:22:36,799 --> 00:22:41,280
this time i don't need sudo because now

00:22:38,320 --> 00:22:43,600
there's no qmu process using the image

00:22:41,280 --> 00:22:45,280
and there we go my overlay now has a

00:22:43,600 --> 00:22:48,480
bitmap written out at the last minute as

00:22:45,280 --> 00:22:50,799
part of kyumu shutting down

00:22:48,480 --> 00:22:54,400
uh let's get sting started back up for

00:22:50,799 --> 00:22:57,280
my next part of the demo and we're going

00:22:54,400 --> 00:23:00,720
to do an incremental poll

00:22:57,280 --> 00:23:01,919
uh my second backup xml i'm going to use

00:23:00,720 --> 00:23:04,159
an incremental

00:23:01,919 --> 00:23:05,679
use based off of check 1 as my starting

00:23:04,159 --> 00:23:07,600
point i want to pull

00:23:05,679 --> 00:23:09,760
which means i need an nbd server so i

00:23:07,600 --> 00:23:10,640
want kumu to open an mbd server on

00:23:09,760 --> 00:23:14,000
localhost

00:23:10,640 --> 00:23:15,919
port 10809 is the nbd default

00:23:14,000 --> 00:23:17,039
i also want to create a new checkpoint

00:23:15,919 --> 00:23:18,799
two tour

00:23:17,039 --> 00:23:20,240
in addition to the checkpoint one that i

00:23:18,799 --> 00:23:21,919
already have

00:23:20,240 --> 00:23:23,360
i'm going to grab the ip address so we

00:23:21,919 --> 00:23:25,919
can ssh in

00:23:23,360 --> 00:23:27,520
i'm going to touch a file before we

00:23:25,919 --> 00:23:29,840
start the backup

00:23:27,520 --> 00:23:31,679
that should be included i'm going to

00:23:29,840 --> 00:23:33,200
begin the backup i'm also going to touch

00:23:31,679 --> 00:23:35,440
a file after

00:23:33,200 --> 00:23:36,720
that should be excluded my point of the

00:23:35,440 --> 00:23:38,080
backup

00:23:36,720 --> 00:23:42,640
even though i haven't copied anything

00:23:38,080 --> 00:23:47,039
yet is when i did the backup command

00:23:42,640 --> 00:23:50,720
um looking at the backup job

00:23:47,039 --> 00:23:54,880
he is running as an nbd server on

00:23:50,720 --> 00:23:57,200
over tcp i can also see that he created

00:23:54,880 --> 00:24:00,320
some temporary files

00:23:57,200 --> 00:24:04,000
named overlay.qcow2.check2

00:24:00,320 --> 00:24:07,279
for storing the changes that happened

00:24:04,000 --> 00:24:09,120
that need that are needed to

00:24:07,279 --> 00:24:11,039
get me that point in time that i started

00:24:09,120 --> 00:24:12,720
the backup no matter how slow i am at

00:24:11,039 --> 00:24:16,159
copying it

00:24:12,720 --> 00:24:16,720
i'm also going to list what that mbd

00:24:16,159 --> 00:24:20,159
server

00:24:16,720 --> 00:24:23,440
is showing he is showing two exports vda

00:24:20,159 --> 00:24:26,799
vdb each one of them has an

00:24:23,440 --> 00:24:29,120
allocation map and a dirty bitmap

00:24:26,799 --> 00:24:31,600
containing which parts of the disk are

00:24:29,120 --> 00:24:34,480
interesting

00:24:31,600 --> 00:24:36,400
and with that now i can proceed to

00:24:34,480 --> 00:24:41,600
create my backup

00:24:36,400 --> 00:24:43,840
i'm going to map that dirty bitmap

00:24:41,600 --> 00:24:44,880
see which portions of the disk are dirty

00:24:43,840 --> 00:24:48,000
um

00:24:44,880 --> 00:24:52,320
the output goes on i'm also

00:24:48,000 --> 00:24:54,960
going to a little helper script here

00:24:52,320 --> 00:24:55,760
i'm going to create a temporary file

00:24:54,960 --> 00:24:59,760
backed

00:24:55,760 --> 00:25:03,360
by my original image

00:24:59,760 --> 00:25:04,400
i'm going to then run my same map as i

00:25:03,360 --> 00:25:06,880
had here

00:25:04,400 --> 00:25:08,240
pipe that through a while loop and for

00:25:06,880 --> 00:25:11,679
every dirty line

00:25:08,240 --> 00:25:15,120
on that while loop run kumu io dash c

00:25:11,679 --> 00:25:17,760
capital c for copy on read and little c

00:25:15,120 --> 00:25:18,720
to run the command read this portion so

00:25:17,760 --> 00:25:21,440
that will populate

00:25:18,720 --> 00:25:22,080
just the dirty portions of my bitmap

00:25:21,440 --> 00:25:24,720
into

00:25:22,080 --> 00:25:26,960
my destination file and at the end my

00:25:24,720 --> 00:25:27,679
destination file is then rebased on top

00:25:26,960 --> 00:25:31,279
of

00:25:27,679 --> 00:25:33,919
the final file

00:25:31,279 --> 00:25:35,679
run that script you can see there's

00:25:33,919 --> 00:25:39,200
quite a few chunks most of that is

00:25:35,679 --> 00:25:43,039
the ext for

00:25:39,200 --> 00:25:46,320
super blocks now i can finish

00:25:43,039 --> 00:25:47,679
my incremental backup job i'm going to

00:25:46,320 --> 00:25:48,799
shut the domain down

00:25:47,679 --> 00:25:50,640
at this point we can leave it running

00:25:48,799 --> 00:25:52,400
but there's no point and i'm going to

00:25:50,640 --> 00:25:54,880
use guest fish to inspect

00:25:52,400 --> 00:25:55,440
my incremental backup make sure that he

00:25:54,880 --> 00:25:57,440
is

00:25:55,440 --> 00:25:59,520
what i expect him to so i'm going to

00:25:57,440 --> 00:26:01,360
connect him mount him

00:25:59,520 --> 00:26:03,360
list the root drive and there we see the

00:26:01,360 --> 00:26:06,000
file before but not after

00:26:03,360 --> 00:26:08,240
so we did indeed grab a snapshot of the

00:26:06,000 --> 00:26:12,080
drive while the guest is running

00:26:08,240 --> 00:26:12,080
with just those contents

00:26:13,360 --> 00:26:21,039
and looking at the file sizes

00:26:16,960 --> 00:26:23,200
um the incremental backup

00:26:21,039 --> 00:26:25,760
is slightly smaller than the overlay

00:26:23,200 --> 00:26:27,279
file which is good because the overlay

00:26:25,760 --> 00:26:28,640
file changed after we touched the

00:26:27,279 --> 00:26:30,960
incriminal backup

00:26:28,640 --> 00:26:32,400
and the full backup is slightly smaller

00:26:30,960 --> 00:26:34,320
than the base

00:26:32,400 --> 00:26:36,159
because the base modified before we did

00:26:34,320 --> 00:26:37,520
our external snapshot

00:26:36,159 --> 00:26:39,200
but the really important part is the

00:26:37,520 --> 00:26:41,279
incremental backup is much

00:26:39,200 --> 00:26:42,400
smaller than a full backup so we did

00:26:41,279 --> 00:26:44,000
save ourselves

00:26:42,400 --> 00:26:45,440
quite a bit of effort by doing an

00:26:44,000 --> 00:26:47,279
incremental backup instead of a full

00:26:45,440 --> 00:26:50,000
backup

00:26:47,279 --> 00:26:50,480
and with that you have now seen how nbd

00:26:50,000 --> 00:26:53,679
shows

00:26:50,480 --> 00:26:54,480
the dirty bit map of qcow2 and how

00:26:53,679 --> 00:26:56,240
livevert

00:26:54,480 --> 00:26:57,840
pulls that all together and manages

00:26:56,240 --> 00:27:00,400
multiple bitmap commands under the hood

00:26:57,840 --> 00:27:02,559
to do incremental backups

00:27:00,400 --> 00:27:07,840
if you have any questions now would be a

00:27:02,559 --> 00:27:07,840

YouTube URL: https://www.youtube.com/watch?v=rJCz13qnT6I


