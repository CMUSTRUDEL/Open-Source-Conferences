Title: KVM-unit-tests: When "KVM" Doesn't Mean KVM - Andrew Jones, Red Hat
Publication date: 2020-11-10
Playlist: KVM Forum Europe 2020
Description: 
	KVM-unit-tests: When "KVM" Doesn't Mean KVM - Andrew Jones, Red Hat
Captions: 
	00:00:11,519 --> 00:00:14,000
hello

00:00:12,160 --> 00:00:16,560
i'm drew jones and this presentation is

00:00:14,000 --> 00:00:19,600
about testing targets other than kvm

00:00:16,560 --> 00:00:20,880
with kvm unit tests to broaden the

00:00:19,600 --> 00:00:23,439
testing domain we

00:00:20,880 --> 00:00:25,680
also present building unit tests as fe

00:00:23,439 --> 00:00:25,680
apps

00:00:27,279 --> 00:00:30,480
presentation is organized as follows we

00:00:29,599 --> 00:00:33,760
do a quick

00:00:30,480 --> 00:00:37,200
introduction to kvu munites followed by

00:00:33,760 --> 00:00:39,040
a quick status of the non-kvm targets we

00:00:37,200 --> 00:00:40,879
already can test

00:00:39,040 --> 00:00:43,280
then we present the motivation current

00:00:40,879 --> 00:00:46,480
status and implementation

00:00:43,280 --> 00:00:49,680
of building unit tests as fe apps

00:00:46,480 --> 00:00:52,239
finally we wrap up with a summary of the

00:00:49,680 --> 00:00:52,239
main points

00:00:53,039 --> 00:00:56,800
so what are kvm unit tests well as the

00:00:55,760 --> 00:00:59,520
name suggests

00:00:56,800 --> 00:01:01,600
it's the test framework for testing kvm

00:00:59,520 --> 00:01:04,239
and it also tests communion

00:01:01,600 --> 00:01:06,080
how does it do that well we run tiny

00:01:04,239 --> 00:01:08,320
guests

00:01:06,080 --> 00:01:10,159
operating systems that when they

00:01:08,320 --> 00:01:13,280
generate

00:01:10,159 --> 00:01:16,640
traps to kvm or exits to pmu we can

00:01:13,280 --> 00:01:19,840
test for specific behaviors uh

00:01:16,640 --> 00:01:22,720
what does a unit test look like to a

00:01:19,840 --> 00:01:24,560
test developer that looks quite familiar

00:01:22,720 --> 00:01:26,799
it looks like a typical c program that

00:01:24,560 --> 00:01:31,520
starts in maine

00:01:26,799 --> 00:01:32,640
also the api in many cases is familiar

00:01:31,520 --> 00:01:36,400
such as when we

00:01:32,640 --> 00:01:38,079
mimic kernel named functions irq enable

00:01:36,400 --> 00:01:41,680
for example

00:01:38,079 --> 00:01:44,960
also we have some lipsy functions

00:01:41,680 --> 00:01:46,079
implemented uh in order to be easy to

00:01:44,960 --> 00:01:49,200
adopt

00:01:46,079 --> 00:01:49,920
uh one thing to keep in mind is that we

00:01:49,200 --> 00:01:53,200
are not in

00:01:49,920 --> 00:01:55,920
user mode when we enter this main

00:01:53,200 --> 00:01:57,520
are in kernel mode if you want to learn

00:01:55,920 --> 00:01:58,159
more about kde media tests there's a

00:01:57,520 --> 00:02:01,280
write-up

00:01:58,159 --> 00:02:04,479
on the kvm web pages

00:02:01,280 --> 00:02:06,159
which has a link found below

00:02:04,479 --> 00:02:08,720
and immediately following this

00:02:06,159 --> 00:02:09,679
presentation eric oj will present on

00:02:08,720 --> 00:02:14,959
giving me to test

00:02:09,679 --> 00:02:14,959
as well as another kvm test framework

00:02:16,720 --> 00:02:20,959
so this diagram is just to make sure

00:02:19,440 --> 00:02:22,879
we're clear on where it gave the immune

00:02:20,959 --> 00:02:25,040
tests run

00:02:22,879 --> 00:02:27,840
exactly the same place as a normal

00:02:25,040 --> 00:02:27,840
gadium vm

00:02:31,760 --> 00:02:35,280
so what's the current status of testing

00:02:33,440 --> 00:02:38,959
non-kvm targets

00:02:35,280 --> 00:02:42,319
well because a gaming media test is

00:02:38,959 --> 00:02:44,800
used as qmu for its gave me user space

00:02:42,319 --> 00:02:45,599
then other key mu accelerators are a

00:02:44,800 --> 00:02:49,120
natural

00:02:45,599 --> 00:02:51,519
target tcg is probably always

00:02:49,120 --> 00:02:54,400
worked to some degree and and been uh

00:02:51,519 --> 00:02:57,120
not only another test target but

00:02:54,400 --> 00:02:58,959
a common way to develop tests uh for

00:02:57,120 --> 00:03:02,400
cross arch

00:02:58,959 --> 00:03:04,080
before moving the tests to kvm to see

00:03:02,400 --> 00:03:05,920
if it works on kvm and real hardware as

00:03:04,080 --> 00:03:09,200
well um

00:03:05,920 --> 00:03:10,480
also hypervisor framework and windows

00:03:09,200 --> 00:03:14,000
hypervisor platform

00:03:10,480 --> 00:03:14,000
are supported for testing

00:03:14,560 --> 00:03:18,720
beyond kmu accelerators other

00:03:17,760 --> 00:03:21,519
hypervisors

00:03:18,720 --> 00:03:22,800
can already be tested for example on

00:03:21,519 --> 00:03:26,799
s390x

00:03:22,800 --> 00:03:28,480
zvm and alpine lpar hypervisors

00:03:26,799 --> 00:03:31,519
if you want to learn more about those

00:03:28,480 --> 00:03:33,760
then you can check a presentation

00:03:31,519 --> 00:03:34,879
a forum presentation from last year that

00:03:33,760 --> 00:03:38,959
was presented by

00:03:34,879 --> 00:03:42,560
januszfan finally uh

00:03:38,959 --> 00:03:46,560
just a bit over a year ago vmware

00:03:42,560 --> 00:03:49,599
contributors posted over 50 patches

00:03:46,560 --> 00:03:52,640
to kvm unit tests in order to enable the

00:03:49,599 --> 00:03:55,840
test to run on bare metal and on vmware

00:03:52,640 --> 00:03:58,080
uh the approach used for that is to

00:03:55,840 --> 00:04:01,840
launch the test from grub

00:03:58,080 --> 00:04:03,840
and they also uh used a lesser known

00:04:01,840 --> 00:04:06,319
feature of kv mutant tests which is

00:04:03,840 --> 00:04:06,959
environment variables um as stated

00:04:06,319 --> 00:04:10,319
before

00:04:06,959 --> 00:04:13,040
pvm test looks just like a user space

00:04:10,319 --> 00:04:14,239
c program with the main where you have

00:04:13,040 --> 00:04:15,920
your

00:04:14,239 --> 00:04:17,680
command line arguments that you can

00:04:15,920 --> 00:04:20,400
parse as well as

00:04:17,680 --> 00:04:21,120
uh it has an environment so you can use

00:04:20,400 --> 00:04:24,960
git in

00:04:21,120 --> 00:04:25,680
or whatever in order to be able to check

00:04:24,960 --> 00:04:28,160
for

00:04:25,680 --> 00:04:29,919
environment variables which allows a

00:04:28,160 --> 00:04:31,120
nice way to configure tests

00:04:29,919 --> 00:04:34,560
for different environments without

00:04:31,120 --> 00:04:34,560
having to re-compile them

00:04:37,120 --> 00:04:40,720
so what's the motivation for building

00:04:38,800 --> 00:04:43,919
these unit tests as

00:04:40,720 --> 00:04:44,800
fe apps well as we want to expand the

00:04:43,919 --> 00:04:48,080
domain

00:04:44,800 --> 00:04:50,320
of targets that we can test on

00:04:48,080 --> 00:04:51,520
then choosing something like an fe app

00:04:50,320 --> 00:04:54,960
which is

00:04:51,520 --> 00:04:58,479
or an fe target which is the reason

00:04:54,960 --> 00:05:00,080
why it exists in order to help

00:04:58,479 --> 00:05:01,919
operating systems and secondary boot

00:05:00,080 --> 00:05:03,360
loaders be portable

00:05:01,919 --> 00:05:05,759
we can also make gaming unit tests

00:05:03,360 --> 00:05:08,840
portable

00:05:05,759 --> 00:05:10,160
they are tiny operating systems after

00:05:08,840 --> 00:05:14,000
all

00:05:10,160 --> 00:05:15,759
also similar to the grub approach we can

00:05:14,000 --> 00:05:17,919
use environment variables if necessary

00:05:15,759 --> 00:05:19,360
to avoid

00:05:17,919 --> 00:05:22,720
having to recompile the tests for

00:05:19,360 --> 00:05:24,479
different targets as

00:05:22,720 --> 00:05:26,639
fe targets also support environment

00:05:24,479 --> 00:05:28,800
variables

00:05:26,639 --> 00:05:30,639
it's relatively easy targets to choose

00:05:28,800 --> 00:05:34,000
as well in order to

00:05:30,639 --> 00:05:34,000
to get a new target quickly

00:05:34,639 --> 00:05:40,160
and we have a couple of other benefits

00:05:36,639 --> 00:05:42,960
from choosing this particular target

00:05:40,160 --> 00:05:43,440
for example similar to the grub being

00:05:42,960 --> 00:05:45,039
able to

00:05:43,440 --> 00:05:47,520
launch straight from firmware or from

00:05:45,039 --> 00:05:49,919
boot loader

00:05:47,520 --> 00:05:51,680
we'll be able to now remove a large

00:05:49,919 --> 00:05:54,160
amount of the stack necessary

00:05:51,680 --> 00:05:56,160
when we want to develop or test the

00:05:54,160 --> 00:05:57,840
tests themselves

00:05:56,160 --> 00:06:00,080
so when emulators are used instead of

00:05:57,840 --> 00:06:02,319
hardware which is sometimes the case

00:06:00,080 --> 00:06:05,520
for developing kvm unit tests like

00:06:02,319 --> 00:06:05,520
actual tests for kvn

00:06:05,680 --> 00:06:09,759
now we should be able to make the

00:06:08,000 --> 00:06:12,479
testing process

00:06:09,759 --> 00:06:13,440
uh of those tests quicker because we

00:06:12,479 --> 00:06:17,120
won't need to boot

00:06:13,440 --> 00:06:19,360
an entire linux operating system um

00:06:17,120 --> 00:06:20,720
and even start up kvm user space we'll

00:06:19,360 --> 00:06:23,600
just go straight from

00:06:20,720 --> 00:06:23,600
firmware to test

00:06:23,759 --> 00:06:28,240
and if you're thinking that maybe not

00:06:26,400 --> 00:06:32,160
all emulators or

00:06:28,240 --> 00:06:35,360
or models will support

00:06:32,160 --> 00:06:38,160
edk2 uh in order to be able to do that

00:06:35,360 --> 00:06:39,280
well that's don't don't be have no fear

00:06:38,160 --> 00:06:43,600
um

00:06:39,280 --> 00:06:43,600
uboot also supports launching fe apps

00:06:43,919 --> 00:06:49,120
also uh maybe a lesser benefit because

00:06:46,479 --> 00:06:52,319
i'm i'm sure that uh

00:06:49,120 --> 00:06:54,960
uefi has several

00:06:52,319 --> 00:06:54,960
unit testing

00:06:55,919 --> 00:06:59,680
frameworks already so it probably

00:06:57,840 --> 00:07:02,720
doesn't need giving unit tests but

00:06:59,680 --> 00:07:06,800
we can now also test

00:07:02,720 --> 00:07:08,720
these uh fe implementations

00:07:06,800 --> 00:07:10,000
with gave me the tests if we can run on

00:07:08,720 --> 00:07:13,039
them so

00:07:10,000 --> 00:07:13,039
it's yet another target

00:07:13,759 --> 00:07:19,680
okay here's our diagram from before

00:07:17,360 --> 00:07:20,639
on the left it's basically the same it

00:07:19,680 --> 00:07:23,680
just shows

00:07:20,639 --> 00:07:26,880
that in order to run the unit test now

00:07:23,680 --> 00:07:30,160
in the typical vert stack we also

00:07:26,880 --> 00:07:35,360
need to add in the virtual machine

00:07:30,160 --> 00:07:35,360
firmware for ar64 we refer to that

00:07:35,599 --> 00:07:39,199
as avmf and for x86 we refer to it as

00:07:38,400 --> 00:07:41,759
ovmf

00:07:39,199 --> 00:07:44,400
and both of them are exist and are

00:07:41,759 --> 00:07:47,120
supported and developed so

00:07:44,400 --> 00:07:47,120
we can do that

00:07:47,520 --> 00:07:51,360
also we can cut out the entire birch

00:07:50,639 --> 00:07:52,800
stack

00:07:51,360 --> 00:07:54,960
and go straight from the hardware or

00:07:52,800 --> 00:07:57,599
emulator

00:07:54,960 --> 00:08:00,720
into the firmware which supports fe and

00:07:57,599 --> 00:08:00,720
then straight into the test

00:08:05,039 --> 00:08:09,280
so um what's the current status of this

00:08:08,160 --> 00:08:13,520
fe app building

00:08:09,280 --> 00:08:14,479
well nothing is is merged nothing is

00:08:13,520 --> 00:08:18,400
even posted yet

00:08:14,479 --> 00:08:21,840
but i do have a proof of concept patch

00:08:18,400 --> 00:08:25,039
set available in my github

00:08:21,840 --> 00:08:28,879
repository on the target effort branch

00:08:25,039 --> 00:08:31,680
and you can compile

00:08:28,879 --> 00:08:32,159
unit tests as fe apps by simply enabling

00:08:31,680 --> 00:08:35,200
the

00:08:32,159 --> 00:08:38,320
target fe configure switch

00:08:35,200 --> 00:08:38,959
running make and then when you move

00:08:38,320 --> 00:08:42,080
these

00:08:38,959 --> 00:08:44,159
fe apps to to the

00:08:42,080 --> 00:08:46,240
fat file system the empty file system

00:08:44,159 --> 00:08:49,440
for the target

00:08:46,240 --> 00:08:50,080
for example kmu and avmf then you can

00:08:49,440 --> 00:08:52,640
launch them

00:08:50,080 --> 00:08:54,720
and well currently the patch series is

00:08:52,640 --> 00:08:57,839
only for age 64 but

00:08:54,720 --> 00:09:00,560
i intend to expand that for x86 as well

00:08:57,839 --> 00:09:00,560
in the near future

00:09:00,640 --> 00:09:05,920
anyway they work great over here

00:09:03,680 --> 00:09:07,519
mu but that's not super exciting because

00:09:05,920 --> 00:09:10,080
we could already run the tests

00:09:07,519 --> 00:09:11,680
over qmu without the need for firmware

00:09:10,080 --> 00:09:13,760
even

00:09:11,680 --> 00:09:14,800
so the work in progress is to get them

00:09:13,760 --> 00:09:17,279
to also run

00:09:14,800 --> 00:09:18,959
directly on bare metal and i've already

00:09:17,279 --> 00:09:22,480
started that work

00:09:18,959 --> 00:09:26,000
testing within amd seattle and so

00:09:22,480 --> 00:09:28,480
as i said x86 is in the queue

00:09:26,000 --> 00:09:30,959
naturally i'll start with ovmf as the

00:09:28,480 --> 00:09:30,959
targets

00:09:31,040 --> 00:09:36,080
but a quick second stop over cuny for

00:09:34,399 --> 00:09:36,560
the first target but as a quick second

00:09:36,080 --> 00:09:40,000
stop

00:09:36,560 --> 00:09:43,920
uh it'll be ovmf over virtualbox because

00:09:40,000 --> 00:09:43,920
virtualbox also supports ovmf

00:09:45,200 --> 00:09:49,360
okay so the rest of the talk is about

00:09:47,360 --> 00:09:53,120
the implementation

00:09:49,360 --> 00:09:55,760
some of the details so um to do that

00:09:53,120 --> 00:09:56,320
this is kind of an outline of of the

00:09:55,760 --> 00:10:00,160
remaining

00:09:56,320 --> 00:10:01,680
slides uh first we will

00:10:00,160 --> 00:10:03,440
talk about what needs to be added the

00:10:01,680 --> 00:10:06,399
framework in order to support

00:10:03,440 --> 00:10:07,920
building as fe apps also it needs to be

00:10:06,399 --> 00:10:10,240
removed

00:10:07,920 --> 00:10:13,279
actually nothing is really removed but

00:10:10,240 --> 00:10:17,279
compiled in different ways or bypassed

00:10:13,279 --> 00:10:19,440
and then some other changes that

00:10:17,279 --> 00:10:22,320
are needed in order to start supporting

00:10:19,440 --> 00:10:22,320
multiple targets

00:10:24,880 --> 00:10:28,160
so what do we add well the main thing we

00:10:27,440 --> 00:10:31,440
add

00:10:28,160 --> 00:10:33,760
is the dependency on gnu fe

00:10:31,440 --> 00:10:35,920
which is a an effie development

00:10:33,760 --> 00:10:40,160
environment and uh that uses the gnu

00:10:35,920 --> 00:10:43,360
tool chain this um

00:10:40,160 --> 00:10:45,120
when linking with inuffy and creating fe

00:10:43,360 --> 00:10:46,560
apps in this way it's a bit of an odd

00:10:45,120 --> 00:10:48,720
build process

00:10:46,560 --> 00:10:50,320
the app that you're building you start

00:10:48,720 --> 00:10:52,720
out by compiling linking as a shared

00:10:50,320 --> 00:10:55,120
library

00:10:52,720 --> 00:10:56,160
along with obj copying select sections

00:10:55,120 --> 00:11:01,839
and to create this

00:10:56,160 --> 00:11:01,839
fe binary uh then

00:11:02,560 --> 00:11:06,320
then one thing uh to know about all the

00:11:04,640 --> 00:11:09,120
new f apps is that they

00:11:06,320 --> 00:11:10,560
they all start in an effi main function

00:11:09,120 --> 00:11:12,720
that's supposed to mean

00:11:10,560 --> 00:11:14,399
uh which you need to write yourself for

00:11:12,720 --> 00:11:17,200
your app and

00:11:14,399 --> 00:11:18,880
in our case for kvm unit tests we would

00:11:17,200 --> 00:11:21,680
like to

00:11:18,880 --> 00:11:23,600
have just a single fe app implementation

00:11:21,680 --> 00:11:27,360
that will work for all architectures

00:11:23,600 --> 00:11:31,440
and for all tests that's a goal

00:11:27,360 --> 00:11:34,959
uh also the point of the fe app for

00:11:31,440 --> 00:11:38,079
for our purposes for kvm unit test is to

00:11:34,959 --> 00:11:40,720
do the startup

00:11:38,079 --> 00:11:41,279
setup before launching the unit test

00:11:40,720 --> 00:11:44,480
which

00:11:41,279 --> 00:11:48,640
is the main function so

00:11:44,480 --> 00:11:51,519
in other words femaine will do

00:11:48,640 --> 00:11:53,120
test preparation to start up and then

00:11:51,519 --> 00:11:56,000
call main

00:11:53,120 --> 00:11:56,720
another thing that now that we're

00:11:56,000 --> 00:12:00,800
running on a

00:11:56,720 --> 00:12:04,240
fe target we can do

00:12:00,800 --> 00:12:04,959
is we can exit from the unit test or

00:12:04,240 --> 00:12:10,160
quit the

00:12:04,959 --> 00:12:11,120
unit test in a different way so one

00:12:10,160 --> 00:12:13,920
thing that's a bit

00:12:11,120 --> 00:12:15,360
odd about how kvm unit tests works when

00:12:13,920 --> 00:12:18,800
running over keem immune

00:12:15,360 --> 00:12:22,079
at kvm is there's no easy way to

00:12:18,800 --> 00:12:23,850
to exit from running vm

00:12:22,079 --> 00:12:26,000
at the vms

00:12:23,850 --> 00:12:29,360
[Music]

00:12:26,000 --> 00:12:30,959
time of choice without using sort of

00:12:29,360 --> 00:12:33,200
power management or something which

00:12:30,959 --> 00:12:34,720
originally wasn't implemented for gave

00:12:33,200 --> 00:12:39,519
me the test it is now

00:12:34,720 --> 00:12:41,920
uh for at least arm and power pc

00:12:39,519 --> 00:12:43,360
but uh we also want to be able to hand

00:12:41,920 --> 00:12:45,920
back a status code

00:12:43,360 --> 00:12:46,399
to the shell that launched the test and

00:12:45,920 --> 00:12:49,040
so

00:12:46,399 --> 00:12:50,720
even then it's uh insufficient to just

00:12:49,040 --> 00:12:52,639
implement the power management we

00:12:50,720 --> 00:12:53,920
we use a thing called a test dev allows

00:12:52,639 --> 00:12:58,800
you to

00:12:53,920 --> 00:13:02,000
pass a a status code and tell qmmu

00:12:58,800 --> 00:13:03,200
it's time to quit well we can now

00:13:02,000 --> 00:13:05,279
we can no longer do that because we

00:13:03,200 --> 00:13:08,160
don't have a test dev

00:13:05,279 --> 00:13:09,440
obvious not when running on uh directly

00:13:08,160 --> 00:13:12,720
on the hardware we can still have a test

00:13:09,440 --> 00:13:16,880
dev and running over kim you sure but

00:13:12,720 --> 00:13:20,000
now we prefer to use the fe

00:13:16,880 --> 00:13:24,079
uvfi or runtime service to be able

00:13:20,000 --> 00:13:26,240
to um to exit

00:13:24,079 --> 00:13:28,000
also i should point out the on the

00:13:26,240 --> 00:13:31,200
second to last bullet

00:13:28,000 --> 00:13:32,399
i bring up exit boot services as

00:13:31,200 --> 00:13:34,639
something else we need to do after

00:13:32,399 --> 00:13:38,560
preparing to launch the guest

00:13:34,639 --> 00:13:40,399
i want to test and this is an uefi thing

00:13:38,560 --> 00:13:44,160
um

00:13:40,399 --> 00:13:46,320
which basically says uh okay

00:13:44,160 --> 00:13:47,760
thank you ubfi for getting our app

00:13:46,320 --> 00:13:48,800
launched but now please get out of the

00:13:47,760 --> 00:13:51,680
way

00:13:48,800 --> 00:13:53,839
so some of the things it's it's a setup

00:13:51,680 --> 00:13:56,079
while running the app such as

00:13:53,839 --> 00:13:58,480
timer events so interrupts being

00:13:56,079 --> 00:13:58,480
delivered

00:13:59,279 --> 00:14:02,560
will interfere with the test of course

00:14:01,440 --> 00:14:05,839
so we need to

00:14:02,560 --> 00:14:07,920
call exit boot services in order for

00:14:05,839 --> 00:14:10,800
those things to go away the runtime

00:14:07,920 --> 00:14:13,440
services another uefi thing are

00:14:10,800 --> 00:14:17,279
left in place for us to use when we want

00:14:13,440 --> 00:14:20,800
to exit the test

00:14:17,279 --> 00:14:24,160
okay so what gets uh removed or bypassed

00:14:20,800 --> 00:14:24,959
um well our own linker script for

00:14:24,160 --> 00:14:27,519
example though

00:14:24,959 --> 00:14:29,040
it gave immune tests defaults or

00:14:27,519 --> 00:14:30,079
original linker script cannot be used

00:14:29,040 --> 00:14:33,120
anymore because

00:14:30,079 --> 00:14:35,440
gnuffee provides one so

00:14:33,120 --> 00:14:37,360
we're swapping that out uh this also

00:14:35,440 --> 00:14:40,880
means any symbols in the linker script

00:14:37,360 --> 00:14:44,720
need to be either avoided

00:14:40,880 --> 00:14:47,839
or maybe renamed uh in the case of the

00:14:44,720 --> 00:14:51,360
ar64 proof of concept i did a little

00:14:47,839 --> 00:14:51,360
both i avoided most of them but

00:14:51,440 --> 00:14:56,160
there was actually no reason not to just

00:14:53,680 --> 00:14:56,160
rename

00:14:56,240 --> 00:15:01,600
e-text to underscory text which is a

00:14:58,720 --> 00:15:04,240
more popular name for that symbol anyway

00:15:01,600 --> 00:15:04,240
then um

00:15:05,040 --> 00:15:09,120
another another goal then for this port

00:15:07,839 --> 00:15:11,519
is to

00:15:09,120 --> 00:15:13,839
take all of the assumptions or all of

00:15:11,519 --> 00:15:13,839
the

00:15:14,000 --> 00:15:17,600
references that the original linker

00:15:16,639 --> 00:15:21,360
script

00:15:17,600 --> 00:15:24,320
create and shove them into as little

00:15:21,360 --> 00:15:25,600
space as possible so just into the

00:15:24,320 --> 00:15:27,199
startup code that

00:15:25,600 --> 00:15:28,880
we have in our init section is where i

00:15:27,199 --> 00:15:32,560
want those to live

00:15:28,880 --> 00:15:35,120
that way when we build as an effie app

00:15:32,560 --> 00:15:36,399
we just need to have that in its section

00:15:35,120 --> 00:15:38,240
if theft out

00:15:36,399 --> 00:15:40,959
and we could continue from where we

00:15:38,240 --> 00:15:44,880
would have left off

00:15:40,959 --> 00:15:47,360
in the same same way for both targets

00:15:44,880 --> 00:15:48,320
so all the common initialization between

00:15:47,360 --> 00:15:52,880
being an fe app

00:15:48,320 --> 00:15:56,160
or or being a traditional target

00:15:52,880 --> 00:15:58,399
build qmu target can be

00:15:56,160 --> 00:15:59,759
shoved into the setup code which is run

00:15:58,399 --> 00:16:01,759
in c

00:15:59,759 --> 00:16:03,040
and that can be a function called from

00:16:01,759 --> 00:16:04,480
fmain

00:16:03,040 --> 00:16:07,120
so the next slide makes this a little

00:16:04,480 --> 00:16:10,480
bit more clear

00:16:07,120 --> 00:16:13,360
uh by illustrating it so

00:16:10,480 --> 00:16:14,720
on the left you see the original or

00:16:13,360 --> 00:16:18,240
default target

00:16:14,720 --> 00:16:20,240
um and on the right

00:16:18,240 --> 00:16:22,160
uh so that's the flow for that for that

00:16:20,240 --> 00:16:22,639
that target on the right the the flow

00:16:22,160 --> 00:16:25,920
for the

00:16:22,639 --> 00:16:28,320
fe app target so we've rearranged a

00:16:25,920 --> 00:16:28,800
little bit on who does the relocating of

00:16:28,320 --> 00:16:31,519
the

00:16:28,800 --> 00:16:31,920
unit test and where the stack gets set

00:16:31,519 --> 00:16:34,639
up

00:16:31,920 --> 00:16:36,560
now we rely on the effiap side we rely

00:16:34,639 --> 00:16:39,680
on the ufv

00:16:36,560 --> 00:16:39,680
loader to do it for us

00:16:41,040 --> 00:16:46,320
we also currently have the

00:16:44,560 --> 00:16:47,680
preparation of the command line

00:16:46,320 --> 00:16:51,199
arguments the

00:16:47,680 --> 00:16:54,160
the environment variables and the

00:16:51,199 --> 00:16:54,959
memory map all kind of squeeze into

00:16:54,160 --> 00:16:58,800
setup

00:16:54,959 --> 00:17:02,079
on the original target but on the

00:16:58,800 --> 00:17:06,480
fdf target a lot of that stuff it's done

00:17:02,079 --> 00:17:11,520
in fu main now using the uefi

00:17:06,480 --> 00:17:15,600
calls so we can pass that information in

00:17:11,520 --> 00:17:17,679
to setup instead on that side

00:17:15,600 --> 00:17:19,280
beyond that the setups should be the

00:17:17,679 --> 00:17:22,480
same

00:17:19,280 --> 00:17:25,120
ideally and then

00:17:22,480 --> 00:17:26,000
definitely a goal is that the unit test

00:17:25,120 --> 00:17:30,720
stays the same

00:17:26,000 --> 00:17:34,799
we shouldn't need to have different code

00:17:30,720 --> 00:17:37,120
running when we're a fe app versus not a

00:17:34,799 --> 00:17:38,559
fe app uh when when running the unit

00:17:37,120 --> 00:17:39,760
test the unit test developers should be

00:17:38,559 --> 00:17:41,280
able to focus

00:17:39,760 --> 00:17:44,559
on just what they want to test and it

00:17:41,280 --> 00:17:47,600
should run in all on all targets

00:17:44,559 --> 00:17:50,400
um and i already talked about how

00:17:47,600 --> 00:17:51,360
exit can be different um using a test

00:17:50,400 --> 00:17:54,400
dev

00:17:51,360 --> 00:17:56,720
or otherwise on the original target

00:17:54,400 --> 00:17:59,039
and on the f target you can use the

00:17:56,720 --> 00:18:02,559
runtime service call

00:17:59,039 --> 00:18:02,559
but the flow should still be the same

00:18:03,280 --> 00:18:06,559
so this slide uh talks a little bit

00:18:05,600 --> 00:18:09,200
about

00:18:06,559 --> 00:18:10,720
how those differences we saw in the

00:18:09,200 --> 00:18:13,360
previous slide

00:18:10,720 --> 00:18:14,480
on where things happen how they're

00:18:13,360 --> 00:18:18,080
actually different

00:18:14,480 --> 00:18:20,320
as well what happens so

00:18:18,080 --> 00:18:21,840
the top part uh the top line is just

00:18:20,320 --> 00:18:22,400
about the relocating and there's not

00:18:21,840 --> 00:18:25,840
much

00:18:22,400 --> 00:18:27,039
to say about it as far as getting the

00:18:25,840 --> 00:18:30,240
information

00:18:27,039 --> 00:18:32,799
um getting the device tree or other

00:18:30,240 --> 00:18:34,160
boot time information in the original

00:18:32,799 --> 00:18:36,640
target that's

00:18:34,160 --> 00:18:37,200
that's uh from dt which is actually a

00:18:36,640 --> 00:18:40,080
good thing

00:18:37,200 --> 00:18:41,120
for ar6 dt is for h64 power and

00:18:40,080 --> 00:18:44,400
multi-boot info

00:18:41,120 --> 00:18:46,080
xj6 but uh um the

00:18:44,400 --> 00:18:48,000
it's good that we already have taught

00:18:46,080 --> 00:18:48,960
gaming tests to look at the dt for these

00:18:48,000 --> 00:18:51,360
things because

00:18:48,960 --> 00:18:53,200
then when we switch to bare metal uh

00:18:51,360 --> 00:18:55,600
with the ftf target

00:18:53,200 --> 00:18:56,559
all we need to do is provide the bare

00:18:55,600 --> 00:18:59,039
metal

00:18:56,559 --> 00:19:01,200
actual hardware dt rather than the qmu

00:18:59,039 --> 00:19:04,320
machine model dt

00:19:01,200 --> 00:19:06,640
um but

00:19:04,320 --> 00:19:07,520
uh so we already can get the information

00:19:06,640 --> 00:19:08,559
we just have to get it a little bit

00:19:07,520 --> 00:19:11,120
differently on the fe

00:19:08,559 --> 00:19:12,880
side we actually need to read the btb

00:19:11,120 --> 00:19:14,960
from the fe file system

00:19:12,880 --> 00:19:16,880
whereas the dt is provided by keynote

00:19:14,960 --> 00:19:20,160
directly

00:19:16,880 --> 00:19:23,360
a pointer is directly provided to the

00:19:20,160 --> 00:19:27,440
unit test from qmu on the default side

00:19:23,360 --> 00:19:29,039
but um command line arguments come

00:19:27,440 --> 00:19:30,799
from slightly different places we could

00:19:29,039 --> 00:19:32,799
fish them out of uh

00:19:30,799 --> 00:19:34,880
we fished them out of dt on the original

00:19:32,799 --> 00:19:38,160
targets we need to get them

00:19:34,880 --> 00:19:41,360
from uvfi on the fe target

00:19:38,160 --> 00:19:43,840
and environment variables so

00:19:41,360 --> 00:19:45,440
here's where they live in the original

00:19:43,840 --> 00:19:46,640
target they actually live in an nrd

00:19:45,440 --> 00:19:50,080
that's how we

00:19:46,640 --> 00:19:52,320
provide them to the unit test but uh

00:19:50,080 --> 00:19:54,000
on the fef target well uefi supports

00:19:52,320 --> 00:19:57,200
environment variables so we get them

00:19:54,000 --> 00:19:59,840
with the native uvo5

00:19:57,200 --> 00:19:59,840
service call

00:20:00,400 --> 00:20:07,600
memory map on the

00:20:04,159 --> 00:20:09,200
original target side is uh

00:20:07,600 --> 00:20:11,919
something you can extract from bt or

00:20:09,200 --> 00:20:14,159
multi-boot info sometimes we've just

00:20:11,919 --> 00:20:16,000
uh assumed we were going to be running

00:20:14,159 --> 00:20:16,960
on qmu for so long because that was the

00:20:16,000 --> 00:20:20,000
main target

00:20:16,960 --> 00:20:22,000
that some stuff is hard-coded and

00:20:20,000 --> 00:20:23,600
so that all needs to change and use the

00:20:22,000 --> 00:20:27,600
memory map that we can get

00:20:23,600 --> 00:20:29,600
from uefi we can't just continue to

00:20:27,600 --> 00:20:31,360
obviously for bare metal we can't just

00:20:29,600 --> 00:20:34,799
have hard-coded memory

00:20:31,360 --> 00:20:38,320
map addresses but

00:20:34,799 --> 00:20:39,919
even if we were using only dt

00:20:38,320 --> 00:20:42,720
to get those addresses it wouldn't be

00:20:39,919 --> 00:20:45,919
enough because

00:20:42,720 --> 00:20:47,600
uvfi reserves some regions of its own

00:20:45,919 --> 00:20:49,919
for the runtime services that we

00:20:47,600 --> 00:20:51,760
want to make sure we're aware of so we

00:20:49,919 --> 00:20:54,880
need to pass in that map

00:20:51,760 --> 00:20:56,240
to the unit test and the unit

00:20:54,880 --> 00:20:59,440
gave me the test framework needs to be

00:20:56,240 --> 00:21:02,799
able to handle that stuff

00:20:59,440 --> 00:21:04,799
the last bullet

00:21:02,799 --> 00:21:06,480
is interesting so we we call setup from

00:21:04,799 --> 00:21:08,880
both that was

00:21:06,480 --> 00:21:09,840
a goal was to get our flows to to

00:21:08,880 --> 00:21:12,080
synchronize again

00:21:09,840 --> 00:21:15,120
after startup but there's still a

00:21:12,080 --> 00:21:18,400
difference and that difference is that

00:21:15,120 --> 00:21:20,400
when we come from on the fe app

00:21:18,400 --> 00:21:21,600
target side when we come to setup the

00:21:20,400 --> 00:21:22,640
mmu is on and

00:21:21,600 --> 00:21:24,960
some of the devices have been

00:21:22,640 --> 00:21:26,799
initialized whereas

00:21:24,960 --> 00:21:30,480
on the original targets that's not the

00:21:26,799 --> 00:21:34,480
case so this can um

00:21:30,480 --> 00:21:36,400
this can cause some other issues

00:21:34,480 --> 00:21:39,440
based on assumptions that we have in our

00:21:36,400 --> 00:21:42,720
startup code our setup code

00:21:39,440 --> 00:21:44,400
and we have to work around those

00:21:42,720 --> 00:21:46,080
so that's what brings us to the next

00:21:44,400 --> 00:21:49,120
slide

00:21:46,080 --> 00:21:51,039
so from from the point where the

00:21:49,120 --> 00:21:53,039
the paths should synchronize where both

00:21:51,039 --> 00:21:56,000
targets should have the same code

00:21:53,039 --> 00:21:56,480
which is a goal we don't want lots of uh

00:21:56,000 --> 00:22:00,640
if

00:21:56,480 --> 00:22:03,760
target fe then this and else that stuff

00:22:00,640 --> 00:22:05,679
uh then we need to remember that

00:22:03,760 --> 00:22:09,039
we've started zmu on so there might need

00:22:05,679 --> 00:22:11,600
to be at least a way to

00:22:09,039 --> 00:22:13,039
go ahead and disable that in order to

00:22:11,600 --> 00:22:15,600
allow it to be reinitialized

00:22:13,039 --> 00:22:16,640
with the same path that's quite possible

00:22:15,600 --> 00:22:21,200
to do because

00:22:16,640 --> 00:22:23,039
the uh without any trouble because uh

00:22:21,200 --> 00:22:24,480
the while the mmu is on it's actually

00:22:23,039 --> 00:22:27,600
just using an identity map

00:22:24,480 --> 00:22:30,159
so as long as we uh

00:22:27,600 --> 00:22:32,320
clean the caches when we when we uh

00:22:30,159 --> 00:22:34,960
disable emu we should be okay to

00:22:32,320 --> 00:22:35,520
to just turn it off run on uh physical

00:22:34,960 --> 00:22:38,159
memory

00:22:35,520 --> 00:22:40,159
this will have the same addresses and

00:22:38,159 --> 00:22:42,400
then turn it on in any way we want

00:22:40,159 --> 00:22:44,080
again the same way we would do for the

00:22:42,400 --> 00:22:47,120
original target

00:22:44,080 --> 00:22:48,559
um but also the

00:22:47,120 --> 00:22:50,559
the devices some of the devices have

00:22:48,559 --> 00:22:51,120
been in use at this point so they're

00:22:50,559 --> 00:22:53,280
already

00:22:51,120 --> 00:22:55,120
initialized and they maybe need to be

00:22:53,280 --> 00:22:56,240
reset before we init which is new

00:22:55,120 --> 00:22:59,039
because

00:22:56,240 --> 00:22:59,760
we always assumed in the original target

00:22:59,039 --> 00:23:02,559
the qmu

00:22:59,760 --> 00:23:04,240
kvm target that they're fresh and ready

00:23:02,559 --> 00:23:07,840
for us to start poking

00:23:04,240 --> 00:23:08,799
and using and then there's other device

00:23:07,840 --> 00:23:10,799
driver issues

00:23:08,799 --> 00:23:12,000
like i didn't have any problem writing

00:23:10,799 --> 00:23:15,200
to the uart

00:23:12,000 --> 00:23:17,280
um right away with the uh

00:23:15,200 --> 00:23:18,799
fe app target but uh i could only write

00:23:17,280 --> 00:23:21,280
32 characters

00:23:18,799 --> 00:23:22,000
because the driver is so simple just

00:23:21,280 --> 00:23:25,200
writing and

00:23:22,000 --> 00:23:27,760
nothing else to the data register

00:23:25,200 --> 00:23:28,240
um that we would fill the phi phone and

00:23:27,760 --> 00:23:31,520
just

00:23:28,240 --> 00:23:34,159
get stuck so now i've added some

00:23:31,520 --> 00:23:35,760
some fifo handling to the driver still

00:23:34,159 --> 00:23:37,760
keeping it as simple as possible

00:23:35,760 --> 00:23:39,039
which i should point out is a main goal

00:23:37,760 --> 00:23:40,400
of kvm unit tests

00:23:39,039 --> 00:23:43,679
we don't want to write another operating

00:23:40,400 --> 00:23:47,360
system we have linux for that

00:23:43,679 --> 00:23:49,039
we want it to be so simple that

00:23:47,360 --> 00:23:50,400
developers can be confident that their

00:23:49,039 --> 00:23:52,240
unit test is doing

00:23:50,400 --> 00:23:53,760
just what they wanted to do and nothing

00:23:52,240 --> 00:23:55,279
but what they wanted to do

00:23:53,760 --> 00:23:58,320
and also so they can jump in and

00:23:55,279 --> 00:23:58,320
contribute quickly

00:24:02,000 --> 00:24:05,919
i already talked about bullet three

00:24:04,400 --> 00:24:07,679
another

00:24:05,919 --> 00:24:09,679
kind of difference between the bare

00:24:07,679 --> 00:24:12,320
metal and qmu world

00:24:09,679 --> 00:24:13,919
pmu target world is sometimes you need a

00:24:12,320 --> 00:24:15,440
carriage return

00:24:13,919 --> 00:24:17,120
uh we could make that configurable of

00:24:15,440 --> 00:24:18,480
course

00:24:17,120 --> 00:24:21,200
other things we already talked about the

00:24:18,480 --> 00:24:23,279
mmu um on the last bullets there

00:24:21,200 --> 00:24:24,559
but um anything else that we find that

00:24:23,279 --> 00:24:26,400
uh

00:24:24,559 --> 00:24:27,840
well maybe we do need a different path

00:24:26,400 --> 00:24:30,640
we can't exactly have

00:24:27,840 --> 00:24:32,960
perfectly synchronized paths but we

00:24:30,640 --> 00:24:34,880
could possibly do a little better job in

00:24:32,960 --> 00:24:38,480
making these things uh dependent

00:24:34,880 --> 00:24:41,200
on environment variables or

00:24:38,480 --> 00:24:42,960
another uh tool we have and giving me to

00:24:41,200 --> 00:24:46,240
test this augs info thing

00:24:42,960 --> 00:24:47,440
ag's info isn't quite as nice as the

00:24:46,240 --> 00:24:49,279
environment variables though because you

00:24:47,440 --> 00:24:53,200
do need to recompile when you use that

00:24:49,279 --> 00:24:54,799
it's a compile-time setup

00:24:53,200 --> 00:24:56,640
well you can use the structure even

00:24:54,799 --> 00:24:56,960
after you've compiled but then you need

00:24:56,640 --> 00:25:00,080
to

00:24:56,960 --> 00:25:03,360
write to it which would be yet another

00:25:00,080 --> 00:25:03,360
path so it doesn't help

00:25:05,760 --> 00:25:11,360
so um talk about most of these or some

00:25:09,039 --> 00:25:14,880
of these problems already

00:25:11,360 --> 00:25:17,039
where we need to now

00:25:14,880 --> 00:25:19,200
get our reset the devices or get our

00:25:17,039 --> 00:25:21,600
information from different places

00:25:19,200 --> 00:25:22,880
for x86 this may require parsing acpi

00:25:21,600 --> 00:25:25,760
i'm not sure yet

00:25:22,880 --> 00:25:26,960
i forgot to mention one problem though

00:25:25,760 --> 00:25:30,720
um

00:25:26,960 --> 00:25:30,720
that i still have with say r64

00:25:31,039 --> 00:25:34,159
and that is that

00:25:34,720 --> 00:25:43,120
in order to use the

00:25:38,799 --> 00:25:44,880
uh fe memory map that we get from uvfi

00:25:43,120 --> 00:25:47,360
we need to be able to use it at the

00:25:44,880 --> 00:25:50,159
granularity that it's given to us and

00:25:47,360 --> 00:25:51,039
currently the implementation for ar64

00:25:50,159 --> 00:25:54,400
unit tests

00:25:51,039 --> 00:25:58,320
only uses 64k pages so this memory map

00:25:54,400 --> 00:26:00,240
which doesn't have 64k alignments

00:25:58,320 --> 00:26:02,000
is no good for us at the moment and uh

00:26:00,240 --> 00:26:04,000
so i need to

00:26:02,000 --> 00:26:05,679
i need to rework some of the memory

00:26:04,000 --> 00:26:09,679
management framework for

00:26:05,679 --> 00:26:13,600
the page table setup framework for ar64

00:26:09,679 --> 00:26:13,600
in order to allow 4k pages as well

00:26:17,039 --> 00:26:23,039
so um to wrap up

00:26:21,279 --> 00:26:26,159
give you immediate tests is already

00:26:23,039 --> 00:26:26,159
testing more than kvm

00:26:26,720 --> 00:26:34,000
and if we add an fe app build target

00:26:30,640 --> 00:26:37,279
to kdma test we can further expand the

00:26:34,000 --> 00:26:38,720
test targets we can run on

00:26:37,279 --> 00:26:42,320
since that'll allow us to have a

00:26:38,720 --> 00:26:42,320
portable unit test

00:26:45,120 --> 00:26:48,240
one of the other benefits of being able

00:26:47,440 --> 00:26:51,279
to

00:26:48,240 --> 00:26:53,200
run a unit test directly from firmware

00:26:51,279 --> 00:26:54,880
is that we will be able to write the

00:26:53,200 --> 00:26:57,279
test even

00:26:54,880 --> 00:26:59,600
for kvn not just for bare metal but kvn

00:26:57,279 --> 00:27:02,240
kv muni tests

00:26:59,600 --> 00:27:03,120
faster because we won't need to boot all

00:27:02,240 --> 00:27:06,640
of linux

00:27:03,120 --> 00:27:08,480
and run kvm user space on top of an

00:27:06,640 --> 00:27:12,159
uh an emulator if we don't have the

00:27:08,480 --> 00:27:14,080
hardware available to do otherwise

00:27:12,159 --> 00:27:15,360
so the proof of concept for air 64 is

00:27:14,080 --> 00:27:17,440
pretty far along

00:27:15,360 --> 00:27:18,559
but unfortunately not all the tests are

00:27:17,440 --> 00:27:22,080
running

00:27:18,559 --> 00:27:25,279
on bare metal yet so work in progress

00:27:22,080 --> 00:27:26,559
uh also work in progress although not

00:27:25,279 --> 00:27:29,679
really

00:27:26,559 --> 00:27:35,520
started much yet uh is the

00:27:29,679 --> 00:27:37,200
x86 work to be able to do it as well

00:27:35,520 --> 00:27:39,279
i expect some different challenges there

00:27:37,200 --> 00:27:41,600
and i actually hope

00:27:39,279 --> 00:27:42,799
that all the work uh done by vmware in

00:27:41,600 --> 00:27:44,880
order to

00:27:42,799 --> 00:27:46,640
remove assumptions about kimimu being

00:27:44,880 --> 00:27:47,360
the targets in order to run on bare

00:27:46,640 --> 00:27:50,480
metal

00:27:47,360 --> 00:27:53,840
and vmware already will allow

00:27:50,480 --> 00:27:56,799
the test to run more easily than

00:27:53,840 --> 00:28:00,080
on bare metal than what i'm having for

00:27:56,799 --> 00:28:00,080
my experience with ar64

00:28:01,200 --> 00:28:05,170
thank you um if i understand quite

00:28:03,840 --> 00:28:06,399
correctly there's uh

00:28:05,170 --> 00:28:08,080
[Music]

00:28:06,399 --> 00:28:09,760
going to be some question and answer

00:28:08,080 --> 00:28:12,880
time reserved after

00:28:09,760 --> 00:28:16,320
the uh after this presentation is

00:28:12,880 --> 00:28:27,919
made available so uh please

00:28:16,320 --> 00:28:27,919

YouTube URL: https://www.youtube.com/watch?v=Hj-9-CV-Qcs


