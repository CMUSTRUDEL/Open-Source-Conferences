Title: Device Keepalive State for Local Live Migration and VMM Fast Restart - Jason Zeng, Intel
Publication date: 2020-11-10
Playlist: KVM Forum Europe 2020
Description: 
	Device Keepalive State for Local Live Migration and VMM Fast Restart - Jason Zeng, Intel
Captions: 
	00:00:13,920 --> 00:00:18,800
welcome to this session today i will

00:00:16,800 --> 00:00:21,439
introduce our team's work

00:00:18,800 --> 00:00:22,960
the design and implementation of device

00:00:21,439 --> 00:00:25,439
keep live state

00:00:22,960 --> 00:00:26,480
which can be used for implementing local

00:00:25,439 --> 00:00:29,599
land migration and

00:00:26,480 --> 00:00:31,840
vm fast restart with pass-through device

00:00:29,599 --> 00:00:31,840
support

00:00:34,480 --> 00:00:37,760
we will first give an overview of the

00:00:36,719 --> 00:00:42,079
design

00:00:37,760 --> 00:00:42,079
and then dive into some major details

00:00:42,239 --> 00:00:48,480
first let's have a recap of the problem

00:00:45,920 --> 00:00:49,520
system update is the pain point of cloud

00:00:48,480 --> 00:00:52,079
vendors

00:00:49,520 --> 00:00:53,760
because system update is usually taking

00:00:52,079 --> 00:00:56,840
too long time

00:00:53,760 --> 00:00:58,000
so we see more service downtime for

00:00:56,840 --> 00:01:00,239
customers

00:00:58,000 --> 00:01:02,160
the existing solutions can be divided

00:01:00,239 --> 00:01:04,320
into several categories

00:01:02,160 --> 00:01:05,280
first choice is to move the vms

00:01:04,320 --> 00:01:08,320
somewhere else

00:01:05,280 --> 00:01:09,439
although the system can be updated the

00:01:08,320 --> 00:01:12,640
typical solution

00:01:09,439 --> 00:01:14,479
of this category is live migration

00:01:12,640 --> 00:01:16,880
however live migration doesn't support

00:01:14,479 --> 00:01:19,119
pass-through device very well

00:01:16,880 --> 00:01:20,240
the other choice is to keep the vm and

00:01:19,119 --> 00:01:23,680
local

00:01:20,240 --> 00:01:24,880
then an option is to live patching the

00:01:23,680 --> 00:01:28,159
kernel

00:01:24,880 --> 00:01:30,479
it is good for small fixes however

00:01:28,159 --> 00:01:32,240
big kernel changes will raise the

00:01:30,479 --> 00:01:35,439
failure rate

00:01:32,240 --> 00:01:36,880
our focus is the final category update

00:01:35,439 --> 00:01:39,520
the relevant components

00:01:36,880 --> 00:01:41,040
separately or in the hole on local

00:01:39,520 --> 00:01:43,520
system

00:01:41,040 --> 00:01:46,079
examples of this category include the

00:01:43,520 --> 00:01:47,119
proposal from oracle to do the tumor lab

00:01:46,079 --> 00:01:49,600
update

00:01:47,119 --> 00:01:50,240
alibaba also had a paper which talks

00:01:49,600 --> 00:01:55,840
about

00:01:50,240 --> 00:01:55,840
updating the kvm module

00:01:57,200 --> 00:02:02,240
looking into the solutions two questions

00:02:00,799 --> 00:02:05,759
need to be answered

00:02:02,240 --> 00:02:08,080
first do we allow pausing vm

00:02:05,759 --> 00:02:09,679
and the second do we allow to reboot the

00:02:08,080 --> 00:02:12,720
host

00:02:09,679 --> 00:02:15,680
if we allow pausing the vm then

00:02:12,720 --> 00:02:17,840
pass through devices and kernel update

00:02:15,680 --> 00:02:19,680
can be supported naturally

00:02:17,840 --> 00:02:20,879
because password devices can be

00:02:19,680 --> 00:02:24,160
suspended

00:02:20,879 --> 00:02:28,800
within the vm and then resumed when vm

00:02:24,160 --> 00:02:31,040
restart if we don't allow parsing the vm

00:02:28,800 --> 00:02:32,400
which means we can't require vm

00:02:31,040 --> 00:02:35,680
cooperation

00:02:32,400 --> 00:02:39,599
then we will have two further choices

00:02:35,680 --> 00:02:43,280
first don't allow host reboot

00:02:39,599 --> 00:02:45,840
then we can't update kernel

00:02:43,280 --> 00:02:47,280
we can only update userland vmm

00:02:45,840 --> 00:02:49,760
typically cumule

00:02:47,280 --> 00:02:51,040
here we still need to pass the state of

00:02:49,760 --> 00:02:53,840
the password device

00:02:51,040 --> 00:02:56,160
to the resume the qmil we also need to

00:02:53,840 --> 00:02:57,519
pass the guest memory mapping across the

00:02:56,160 --> 00:02:59,840
restart

00:02:57,519 --> 00:03:02,560
steve from oracle also had a proposal

00:02:59,840 --> 00:03:02,560
for this case

00:03:02,640 --> 00:03:06,239
vmm fast restart wants to solve the

00:03:05,040 --> 00:03:09,120
final category

00:03:06,239 --> 00:03:09,440
in which we don't allow pausing vm and

00:03:09,120 --> 00:03:13,040
we

00:03:09,440 --> 00:03:15,440
allow host reboot this is the most

00:03:13,040 --> 00:03:16,840
flexible solution which means kernel and

00:03:15,440 --> 00:03:20,400
cumin can both be

00:03:16,840 --> 00:03:24,159
updated here we can leverage

00:03:20,400 --> 00:03:27,200
k exact report to boost the reboot time

00:03:24,159 --> 00:03:30,400
we also want to support password devices

00:03:27,200 --> 00:03:32,879
there is a special situation here

00:03:30,400 --> 00:03:34,480
during the reboot time window the

00:03:32,879 --> 00:03:37,519
pass-through device has no

00:03:34,480 --> 00:03:38,159
owner since we can't rely on the guest

00:03:37,519 --> 00:03:41,519
driver

00:03:38,159 --> 00:03:44,799
to suspend the device so the choice

00:03:41,519 --> 00:03:47,840
we have is to keep the device alive

00:03:44,799 --> 00:03:47,840
across the reboot

00:03:49,680 --> 00:03:53,680
so here comes our proposal and

00:03:51,760 --> 00:03:56,560
implementation

00:03:53,680 --> 00:03:59,360
we introduce a device keep live state

00:03:56,560 --> 00:04:01,599
for pass-through devices

00:03:59,360 --> 00:04:02,560
we will talk about the overall idea of

00:04:01,599 --> 00:04:06,959
the proposal

00:04:02,560 --> 00:04:06,959
and then dive into some major details

00:04:08,080 --> 00:04:12,480
as shown in top right corner of the

00:04:11,120 --> 00:04:15,040
slide

00:04:12,480 --> 00:04:16,160
we introduce a flag in the core device

00:04:15,040 --> 00:04:19,919
data structure

00:04:16,160 --> 00:04:21,519
to denote a device is in the keep alive

00:04:19,919 --> 00:04:24,240
state

00:04:21,519 --> 00:04:26,800
what does it mean by putting a device

00:04:24,240 --> 00:04:28,800
into keep alive state

00:04:26,800 --> 00:04:30,240
it means the device hardware is still

00:04:28,800 --> 00:04:34,000
alive

00:04:30,240 --> 00:04:35,440
although it has no owner it may continue

00:04:34,000 --> 00:04:38,479
to issue dma

00:04:35,440 --> 00:04:40,560
and irq however

00:04:38,479 --> 00:04:42,320
the host software must not notify the

00:04:40,560 --> 00:04:44,720
hardware state of the device

00:04:42,320 --> 00:04:47,680
it can't bind the device to any other

00:04:44,720 --> 00:04:47,680
drivers either

00:04:47,840 --> 00:04:50,880
on the other hand the device software

00:04:50,160 --> 00:04:53,680
state

00:04:50,880 --> 00:04:54,479
which is managed by drivers must be

00:04:53,680 --> 00:04:57,520
saved

00:04:54,479 --> 00:04:59,919
at one of two stages if it

00:04:57,520 --> 00:05:01,039
can't be restored without clobbering

00:04:59,919 --> 00:05:03,520
hardware

00:05:01,039 --> 00:05:04,720
either at the time the device enters

00:05:03,520 --> 00:05:07,280
keep live state

00:05:04,720 --> 00:05:09,600
or at the time the host reboot it

00:05:07,280 --> 00:05:10,000
depends on whether it is affected by

00:05:09,600 --> 00:05:13,520
cumin

00:05:10,000 --> 00:05:16,639
run time operation or not

00:05:13,520 --> 00:05:19,440
or it is configured or maintained by the

00:05:16,639 --> 00:05:19,440
kernel or not

00:05:21,280 --> 00:05:25,440
the whole k exact reboot procedure

00:05:24,560 --> 00:05:28,720
consists

00:05:25,440 --> 00:05:31,840
of two incremental stages

00:05:28,720 --> 00:05:32,800
stage one is related to cumule when

00:05:31,840 --> 00:05:35,600
cumulus starts

00:05:32,800 --> 00:05:36,639
it opens the pass-through device when

00:05:35,600 --> 00:05:39,759
tumor quits

00:05:36,639 --> 00:05:40,639
it closes the device this will cause the

00:05:39,759 --> 00:05:43,919
device

00:05:40,639 --> 00:05:45,759
to be enabled and disabled thus changing

00:05:43,919 --> 00:05:48,400
its hardware state

00:05:45,759 --> 00:05:50,000
so if we want to keep the device alive

00:05:48,400 --> 00:05:53,600
across the restart

00:05:50,000 --> 00:05:56,800
we need to set it into keep a live state

00:05:53,600 --> 00:06:00,319
before cumule quits this is called

00:05:56,800 --> 00:06:04,080
state one hip have state

00:06:00,319 --> 00:06:07,680
stage two is related to kernel reboot

00:06:04,080 --> 00:06:10,080
some devices such as iomu its driver

00:06:07,680 --> 00:06:11,600
maintains its own state as long as the

00:06:10,080 --> 00:06:14,720
kernel is running

00:06:11,600 --> 00:06:16,880
but when kernel is about 2k exact reboot

00:06:14,720 --> 00:06:18,880
the state will need to be preserved so

00:06:16,880 --> 00:06:22,560
that it can be handed over

00:06:18,880 --> 00:06:24,400
to the new kernel this is stage two keep

00:06:22,560 --> 00:06:27,280
alive state

00:06:24,400 --> 00:06:28,479
here we can see that stage one keep

00:06:27,280 --> 00:06:30,639
alive states

00:06:28,479 --> 00:06:31,680
can be used for implementing cumulative

00:06:30,639 --> 00:06:34,240
update

00:06:31,680 --> 00:06:35,600
this is an alternative solution to the

00:06:34,240 --> 00:06:39,680
fd passing

00:06:35,600 --> 00:06:43,840
over exec it also can be applied for

00:06:39,680 --> 00:06:43,840
implementing local live migration

00:06:45,440 --> 00:06:48,560
this slide shows the example cumulative

00:06:47,919 --> 00:06:51,680
comments

00:06:48,560 --> 00:06:54,639
for implementing the vmm faster restart

00:06:51,680 --> 00:06:55,680
we put the guest memory in a dax device

00:06:54,639 --> 00:06:58,880
which is a dram

00:06:55,680 --> 00:06:59,280
emulated persistent memory and turn on

00:06:58,880 --> 00:07:03,280
its

00:06:59,280 --> 00:07:03,599
share property in this way qmil can pick

00:07:03,280 --> 00:07:06,400
up

00:07:03,599 --> 00:07:07,440
the guest memory from the persistent

00:07:06,400 --> 00:07:10,560
memory

00:07:07,440 --> 00:07:13,759
after k exact reboot

00:07:10,560 --> 00:07:17,199
the cumin common migrate set capability

00:07:13,759 --> 00:07:20,319
x ignore shared makes the

00:07:17,199 --> 00:07:23,440
save vm command ignore the

00:07:20,319 --> 00:07:27,440
guest memory region that has turned on

00:07:23,440 --> 00:07:29,840
share property so we don't

00:07:27,440 --> 00:07:31,759
need to copy the guest memory into the

00:07:29,840 --> 00:07:34,639
snapshot

00:07:31,759 --> 00:07:35,919
the cumin command set keep alive is a

00:07:34,639 --> 00:07:38,160
newly added comment

00:07:35,919 --> 00:07:39,680
to set all the password devices into

00:07:38,160 --> 00:07:42,880
keep a live state

00:07:39,680 --> 00:07:46,240
it also specifies a uuid token

00:07:42,880 --> 00:07:48,720
when cumin restarts after k exact reboot

00:07:46,240 --> 00:07:50,160
it needs to specify this token to the

00:07:48,720 --> 00:07:53,759
vfl

00:07:50,160 --> 00:07:55,840
device parameter so that the kernel can

00:07:53,759 --> 00:07:59,280
verify the received accumule

00:07:55,840 --> 00:08:01,680
has the permission to own the password

00:07:59,280 --> 00:08:01,680
device

00:08:02,080 --> 00:08:04,560
after

00:08:05,440 --> 00:08:09,199
after the resume the qmill load the

00:08:08,240 --> 00:08:12,720
snapshot

00:08:09,199 --> 00:08:15,919
we issue the set keep live off command

00:08:12,720 --> 00:08:17,680
to clear the keep live flag for all the

00:08:15,919 --> 00:08:20,240
password devices

00:08:17,680 --> 00:08:26,160
after that the password devices will

00:08:20,240 --> 00:08:28,720
start working as usual

00:08:26,160 --> 00:08:30,800
so as shown in this picture a lot of

00:08:28,720 --> 00:08:31,759
data structures or software states are

00:08:30,800 --> 00:08:35,279
involved

00:08:31,759 --> 00:08:38,880
in the lifetime of the vm to implement

00:08:35,279 --> 00:08:41,440
bmm fast restart we need to figure out

00:08:38,880 --> 00:08:42,159
which ones need to be preserved and

00:08:41,440 --> 00:08:44,959
which ones

00:08:42,159 --> 00:08:47,440
we can recreate across the k exact

00:08:44,959 --> 00:08:47,440
reboot

00:08:48,480 --> 00:08:52,160
there are some rationals to help

00:08:50,399 --> 00:08:57,279
determine this

00:08:52,160 --> 00:08:59,440
first does it need to be saved at all

00:08:57,279 --> 00:09:01,440
if the state are pure software state

00:08:59,440 --> 00:09:02,320
which means it doesn't depend on

00:09:01,440 --> 00:09:05,440
hardware state

00:09:02,320 --> 00:09:07,760
or it can be restored by reading back

00:09:05,440 --> 00:09:09,600
the hardware registers then we don't

00:09:07,760 --> 00:09:12,480
need to save it

00:09:09,600 --> 00:09:13,839
if we can only restore it by clobbering

00:09:12,480 --> 00:09:18,640
the hardware

00:09:13,839 --> 00:09:18,640
register then we will need to save it

00:09:19,440 --> 00:09:22,800
all the gray states in the picture are

00:09:21,600 --> 00:09:24,959
those

00:09:22,800 --> 00:09:26,560
we don't need to save because we can

00:09:24,959 --> 00:09:30,959
reconstruct them without

00:09:26,560 --> 00:09:33,360
clobbering hardware registers and second

00:09:30,959 --> 00:09:34,000
we don't want the resulting state saving

00:09:33,360 --> 00:09:37,040
code

00:09:34,000 --> 00:09:38,640
to be too much intrusive to other kernel

00:09:37,040 --> 00:09:41,600
components

00:09:38,640 --> 00:09:42,800
pass through devices are managed by vfio

00:09:41,600 --> 00:09:46,080
driver

00:09:42,800 --> 00:09:50,640
it is reasonable to put major device

00:09:46,080 --> 00:09:53,200
keep life management logic in vfio layer

00:09:50,640 --> 00:09:55,519
so as not to touch other components too

00:09:53,200 --> 00:09:55,519
much

00:09:55,760 --> 00:10:02,240
and third if we need to save it

00:09:59,120 --> 00:10:04,240
which stage does it belong to is it

00:10:02,240 --> 00:10:05,600
manipulated by two male run time

00:10:04,240 --> 00:10:08,720
operations

00:10:05,600 --> 00:10:12,160
or will it only be destroyed by

00:10:08,720 --> 00:10:15,839
kernel reboot for example

00:10:12,160 --> 00:10:18,560
the vfio pci device data structure

00:10:15,839 --> 00:10:21,120
has hardware dependent states the

00:10:18,560 --> 00:10:22,320
underlying pci device will be disabled

00:10:21,120 --> 00:10:24,399
when tumor quits

00:10:22,320 --> 00:10:26,160
and it will it will be enabled by

00:10:24,399 --> 00:10:29,760
communal restarts

00:10:26,160 --> 00:10:32,959
so it belongs to stage 1.

00:10:29,760 --> 00:10:36,880
in later slides we will look into these

00:10:32,959 --> 00:10:36,880
keep alive states in more details

00:10:37,680 --> 00:10:40,800
now let's dive a little bit deeper to

00:10:40,000 --> 00:10:44,320
see how

00:10:40,800 --> 00:10:47,920
we keep alive the two major

00:10:44,320 --> 00:10:50,880
device keep live states irq

00:10:47,920 --> 00:10:50,880
and dma

00:10:52,240 --> 00:10:56,240
the challenge for keeping ir2 alive is

00:10:55,120 --> 00:10:58,560
that

00:10:56,240 --> 00:10:59,519
during the key exact reboot both

00:10:58,560 --> 00:11:01,600
hardware and

00:10:59,519 --> 00:11:02,880
software are not available to handle the

00:11:01,600 --> 00:11:05,640
irq

00:11:02,880 --> 00:11:07,279
cpu is undergoing reboot and

00:11:05,640 --> 00:11:10,640
re-initialization

00:11:07,279 --> 00:11:14,079
software is not ready either

00:11:10,640 --> 00:11:17,839
there are two options to keep irq alive

00:11:14,079 --> 00:11:21,120
first one is to mask irq when the device

00:11:17,839 --> 00:11:24,399
is put into keep alive state and unmask

00:11:21,120 --> 00:11:27,360
it when vm resumes

00:11:24,399 --> 00:11:28,000
in this way device can hold from issuing

00:11:27,360 --> 00:11:32,240
irq

00:11:28,000 --> 00:11:35,519
during the restart period

00:11:32,240 --> 00:11:36,640
the problem of this approach is that msi

00:11:35,519 --> 00:11:40,160
masking

00:11:36,640 --> 00:11:42,480
is an optional feature of pci devices

00:11:40,160 --> 00:11:43,760
which means there are some devices that

00:11:42,480 --> 00:11:46,800
don't support

00:11:43,760 --> 00:11:46,800
msi masking

00:11:47,200 --> 00:11:51,839
another approach is to leverage posted

00:11:49,279 --> 00:11:55,600
interrupt which we choose here

00:11:51,839 --> 00:11:58,399
it doesn't depend on msi or msix

00:11:55,600 --> 00:12:01,040
so it is more generic and has more

00:11:58,399 --> 00:12:01,040
coverage

00:12:01,120 --> 00:12:05,920
the irq setup and teardown are triggered

00:12:04,079 --> 00:12:09,839
from the vfiopci

00:12:05,920 --> 00:12:10,720
device layer it goes through the pci and

00:12:09,839 --> 00:12:13,680
irq

00:12:10,720 --> 00:12:15,360
core layer down to the irq remapping

00:12:13,680 --> 00:12:19,440
driver to locate

00:12:15,360 --> 00:12:22,720
or free the irte which means interrupt

00:12:19,440 --> 00:12:25,760
remapping table entry meanwhile

00:12:22,720 --> 00:12:27,440
the kvm side will allocate posted

00:12:25,760 --> 00:12:30,720
interrupted descriptor

00:12:27,440 --> 00:12:33,200
pid for the vcpu it will be

00:12:30,720 --> 00:12:34,880
connected to the specific device

00:12:33,200 --> 00:12:38,880
interrupter vector

00:12:34,880 --> 00:12:41,600
via the irte

00:12:38,880 --> 00:12:42,720
so here we basically have three things

00:12:41,600 --> 00:12:47,040
to preserve

00:12:42,720 --> 00:12:48,560
pid irte and the device interrupt vector

00:12:47,040 --> 00:12:51,519
index

00:12:48,560 --> 00:12:52,800
the device interrupt vector index is not

00:12:51,519 --> 00:12:57,519
shown in this

00:12:52,800 --> 00:13:00,959
picture it is saved in the qmil snapshot

00:12:57,519 --> 00:13:07,120
next we will talk about how we save pid

00:13:00,959 --> 00:13:10,320
and irte

00:13:07,120 --> 00:13:11,920
there are also two options to notify kvm

00:13:10,320 --> 00:13:16,800
site to preserve

00:13:11,920 --> 00:13:20,000
pid one is to introduce io control

00:13:16,800 --> 00:13:23,040
comments so that qmu can issue to

00:13:20,000 --> 00:13:25,680
kvm side to save the pid

00:13:23,040 --> 00:13:26,800
another one is to leverage iq bypass

00:13:25,680 --> 00:13:30,000
mechanism

00:13:26,800 --> 00:13:31,279
which is currently used by vfio driver

00:13:30,000 --> 00:13:33,760
to notify kvm

00:13:31,279 --> 00:13:36,639
site to enable or disable posted

00:13:33,760 --> 00:13:36,639
interrupt mode

00:13:37,040 --> 00:13:40,880
we introduced two callback interfaces

00:13:39,600 --> 00:13:44,000
for the irq

00:13:40,880 --> 00:13:47,120
bypass consumer data structure

00:13:44,000 --> 00:13:50,560
when the device enters keep alive state

00:13:47,120 --> 00:13:54,880
the callback safe consumer

00:13:50,560 --> 00:13:57,120
will be invoked from the vfio side

00:13:54,880 --> 00:13:57,920
it will eventually trigger a newly added

00:13:57,120 --> 00:14:02,079
callback

00:13:57,920 --> 00:14:05,360
in kvmx86 ops

00:14:02,079 --> 00:14:09,120
which will save pid and set the suppress

00:14:05,360 --> 00:14:09,120
notification bit in the pid

00:14:10,800 --> 00:14:18,560
and for irte again two options

00:14:14,480 --> 00:14:21,600
for preserving it it is a long code path

00:14:18,560 --> 00:14:23,040
as we mentioned to set up or tear down

00:14:21,600 --> 00:14:26,240
an irq

00:14:23,040 --> 00:14:29,279
it starts from vfio driver goes

00:14:26,240 --> 00:14:32,399
through the pci core and the irq core

00:14:29,279 --> 00:14:34,720
layers and finally it arrives at irq

00:14:32,399 --> 00:14:38,240
remapping driver

00:14:34,720 --> 00:14:40,880
if we want to make the pci core and irq

00:14:38,240 --> 00:14:42,639
core layer to be aware of the keep live

00:14:40,880 --> 00:14:45,519
saving and restoring

00:14:42,639 --> 00:14:47,680
then we will need to introduce apis and

00:14:45,519 --> 00:14:51,120
pretty much code changes into these

00:14:47,680 --> 00:14:55,920
two core kernel layers which may be much

00:14:51,120 --> 00:14:55,920
intrusive to the two layers

00:14:56,480 --> 00:15:00,320
so we choose another approach by which

00:14:59,519 --> 00:15:03,199
we

00:15:00,320 --> 00:15:04,240
reuse most of the irq setup and teardown

00:15:03,199 --> 00:15:07,600
code pass

00:15:04,240 --> 00:15:11,519
we just check the device kepler flag

00:15:07,600 --> 00:15:13,839
at the irq remapping driver

00:15:11,519 --> 00:15:14,800
if the device is kept alive then we

00:15:13,839 --> 00:15:18,079
don't free

00:15:14,800 --> 00:15:21,760
the irte when iq is turned down

00:15:18,079 --> 00:15:24,800
instead we save the irte aside

00:15:21,760 --> 00:15:25,600
we also record the mapping between the

00:15:24,800 --> 00:15:28,000
irte

00:15:25,600 --> 00:15:28,959
and the irq vector index within the

00:15:28,000 --> 00:15:31,360
device

00:15:28,959 --> 00:15:33,040
so that they can be reconnected when the

00:15:31,360 --> 00:15:36,880
device iq vector

00:15:33,040 --> 00:15:39,920
index is reset up in this way

00:15:36,880 --> 00:15:40,800
we can introduce less intrusive code

00:15:39,920 --> 00:15:44,480
change

00:15:40,800 --> 00:15:44,480
for all the involved layers

00:15:47,120 --> 00:15:53,759
for dma states preserving

00:15:50,320 --> 00:15:56,399
we need to preserve the dma page table

00:15:53,759 --> 00:15:57,360
domain id and various iomu

00:15:56,399 --> 00:16:01,440
configurations

00:15:57,360 --> 00:16:04,720
for example the root table of the iomu

00:16:01,440 --> 00:16:07,839
the context table etc

00:16:04,720 --> 00:16:10,079
there is a denim situation for us about

00:16:07,839 --> 00:16:13,920
whether to preserve iomu

00:16:10,079 --> 00:16:14,720
domain or not the iomu domain data

00:16:13,920 --> 00:16:16,800
structure is

00:16:14,720 --> 00:16:19,120
a software data structure which can be

00:16:16,800 --> 00:16:20,720
recreated without clubbering hardware

00:16:19,120 --> 00:16:23,759
state

00:16:20,720 --> 00:16:24,079
if we do recreate it we will have pretty

00:16:23,759 --> 00:16:27,759
much

00:16:24,079 --> 00:16:31,440
code change to iomu driver

00:16:27,759 --> 00:16:35,519
on the other hand if we preserve it most

00:16:31,440 --> 00:16:38,480
of the code change will be in vfio

00:16:35,519 --> 00:16:39,839
then do we want to consider other device

00:16:38,480 --> 00:16:43,680
pass-through framework

00:16:39,839 --> 00:16:46,240
such as vdpa

00:16:43,680 --> 00:16:48,000
it looks more reasonable to let the iomu

00:16:46,240 --> 00:16:53,839
driver to do more things than

00:16:48,000 --> 00:16:56,560
both vdpa and vfio duplicate the efforts

00:16:53,839 --> 00:16:58,560
currently our poc work choose to

00:16:56,560 --> 00:17:05,439
preserve the iommu

00:16:58,560 --> 00:17:08,079
and this and leave this issue as an open

00:17:05,439 --> 00:17:11,039
device ownership authentication is a

00:17:08,079 --> 00:17:13,120
security issue we need to consider

00:17:11,039 --> 00:17:15,120
this is because when we when the

00:17:13,120 --> 00:17:16,079
pass-through device is put into keep

00:17:15,120 --> 00:17:19,199
live state

00:17:16,079 --> 00:17:21,760
it will be detached from its owner when

00:17:19,199 --> 00:17:22,640
the resumed vm is trying to reattach to

00:17:21,760 --> 00:17:25,280
the device

00:17:22,640 --> 00:17:26,640
there must be a mechanism to verify the

00:17:25,280 --> 00:17:29,840
ownership

00:17:26,640 --> 00:17:30,559
we leverage the vf token mechanism which

00:17:29,840 --> 00:17:33,679
is an

00:17:30,559 --> 00:17:37,200
existing feature of current vfio driver

00:17:33,679 --> 00:17:40,240
to do the job a token will be set

00:17:37,200 --> 00:17:43,679
into the vfio device when it is

00:17:40,240 --> 00:17:46,880
put into keep live state then

00:17:43,679 --> 00:17:49,520
when the queue restarts it needs to pass

00:17:46,880 --> 00:17:53,600
the token to the kernel vfi driver in

00:17:49,520 --> 00:17:53,600
order to reopen the password device

00:17:57,280 --> 00:18:04,559
kx reboot procedure also need some

00:18:00,960 --> 00:18:06,880
modifications we introduce a keep live

00:18:04,559 --> 00:18:08,480
callback notifier before okay exact

00:18:06,880 --> 00:18:11,360
reboot happens

00:18:08,480 --> 00:18:12,720
where the stage 2 keep live states can

00:18:11,360 --> 00:18:14,960
be preserved

00:18:12,720 --> 00:18:17,120
and all the cape lab states can be

00:18:14,960 --> 00:18:20,400
copied to the persistent memory

00:18:17,120 --> 00:18:21,440
to pass to the new kernel after the new

00:18:20,400 --> 00:18:24,880
kernel starts

00:18:21,440 --> 00:18:27,360
to re to boot all the keep alive states

00:18:24,880 --> 00:18:28,320
will be copied back from the persistent

00:18:27,360 --> 00:18:31,919
memory

00:18:28,320 --> 00:18:34,240
so that device states can be restored

00:18:31,919 --> 00:18:36,080
pass-through device list is another

00:18:34,240 --> 00:18:38,320
important information that needs to

00:18:36,080 --> 00:18:39,760
pass to the new kernel so that the new

00:18:38,320 --> 00:18:41,520
kernel can identify the

00:18:39,760 --> 00:18:43,840
keep alive devices and do special

00:18:41,520 --> 00:18:48,080
handling during

00:18:43,840 --> 00:18:49,840
pci enumeration we also need a memory

00:18:48,080 --> 00:18:52,000
handover mechanism to pass

00:18:49,840 --> 00:18:53,679
all this data from out kernel to new

00:18:52,000 --> 00:18:57,520
kernel and so if

00:18:53,679 --> 00:18:57,520
oracle has a proposal for us

00:18:59,600 --> 00:19:03,679
for keep alive devices pci enumeration

00:19:02,880 --> 00:19:06,720
procedure

00:19:03,679 --> 00:19:09,280
needs special handling basically

00:19:06,720 --> 00:19:11,679
we can't re-initialize the device

00:19:09,280 --> 00:19:14,320
instead we need to restore the states

00:19:11,679 --> 00:19:17,760
from the data passed from out kernel

00:19:14,320 --> 00:19:20,960
meanwhile we can't reassign pci bar

00:19:17,760 --> 00:19:23,600
resources to the keep live devices

00:19:20,960 --> 00:19:24,720
instead we need to inherit the resources

00:19:23,600 --> 00:19:27,120
from outcome

00:19:24,720 --> 00:19:30,559
which are already recorded in the bar

00:19:27,120 --> 00:19:30,559
registers of the devices

00:19:31,600 --> 00:19:37,520
so until now we have talked about how we

00:19:34,480 --> 00:19:41,120
handle the many issues we will encounter

00:19:37,520 --> 00:19:44,400
for the vm and fast restart

00:19:41,120 --> 00:19:46,480
however we still have many opens first

00:19:44,400 --> 00:19:47,520
we still can't make the keeper live flag

00:19:46,480 --> 00:19:51,440
transparent

00:19:47,520 --> 00:19:52,320
to pci core code we check device keep

00:19:51,440 --> 00:19:55,760
live flag in

00:19:52,320 --> 00:19:58,720
msi msix irq set up and tier

00:19:55,760 --> 00:20:02,640
done code pass to avoid clobbering

00:19:58,720 --> 00:20:04,880
hardware msi msix registers

00:20:02,640 --> 00:20:06,159
do we want to check the keep align flag

00:20:04,880 --> 00:20:09,440
in all pci

00:20:06,159 --> 00:20:12,559
core code paths since we already

00:20:09,440 --> 00:20:16,960
introduced this flag would that be

00:20:12,559 --> 00:20:20,400
too intrusive to pci core code

00:20:16,960 --> 00:20:23,200
and what about pci enumeration failure

00:20:20,400 --> 00:20:26,640
because of resource conflict how do we

00:20:23,200 --> 00:20:26,640
notify camera about this

00:20:28,880 --> 00:20:32,400
and since all the dependent devices

00:20:30,960 --> 00:20:35,840
along the i o paths

00:20:32,400 --> 00:20:35,840
also need to be kept live

00:20:35,919 --> 00:20:39,039
how do we handle the states of these

00:20:38,080 --> 00:20:42,880
devices

00:20:39,039 --> 00:20:44,960
for example switch port and root port

00:20:42,880 --> 00:20:47,200
they may register irqs for different

00:20:44,960 --> 00:20:49,679
pcie capabilities

00:20:47,200 --> 00:20:50,720
can we just disable them when keep live

00:20:49,679 --> 00:20:52,880
operation starts

00:20:50,720 --> 00:20:53,840
and read events back from their status

00:20:52,880 --> 00:20:56,880
registers

00:20:53,840 --> 00:21:00,480
after we reboot and re-inject

00:20:56,880 --> 00:21:00,480
those events into guest

00:21:00,720 --> 00:21:08,000
and what about sriov and sioe support

00:21:05,440 --> 00:21:09,039
pf device states also need to be

00:21:08,000 --> 00:21:12,000
preserved

00:21:09,039 --> 00:21:12,000
how do we do that

00:21:14,880 --> 00:21:20,960
currently we have finished the poc of

00:21:18,720 --> 00:21:22,559
cumin phosphate start and the full vm

00:21:20,960 --> 00:21:25,679
and fast restart

00:21:22,559 --> 00:21:28,400
with our testing environment which is

00:21:25,679 --> 00:21:32,720
hardwell and broadwell platform with

00:21:28,400 --> 00:21:36,159
intel card youtube video streaming

00:21:32,720 --> 00:21:36,720
and scp workloads in vm can be restored

00:21:36,159 --> 00:21:39,679
after k

00:21:36,720 --> 00:21:39,679
exact reboot

00:21:39,760 --> 00:21:45,200
we hope this effort can go to upstream

00:21:43,440 --> 00:21:50,080
so would like to have your comments and

00:21:45,200 --> 00:21:50,080
suggestions and cooperation is welcome

00:21:56,720 --> 00:22:10,320

YouTube URL: https://www.youtube.com/watch?v=LFwYLc9ZFS4


