Title: Trap-less Virtual Interrupt for KVM on RISC-V - Siqi Zhao, Huawei
Publication date: 2020-11-10
Playlist: KVM Forum Europe 2020
Description: 
	Trap-less Virtual Interrupt for KVM on RISC-V - Siqi Zhao, Huawei
Captions: 
	00:00:06,319 --> 00:00:09,280
hello everyone

00:00:07,279 --> 00:00:11,040
today i'll present you a work related to

00:00:09,280 --> 00:00:12,080
virtual interrupts on the risk 5

00:00:11,040 --> 00:00:13,759
architecture

00:00:12,080 --> 00:00:16,080
virtual interrupts are an integral

00:00:13,759 --> 00:00:18,240
component of a virtualization solution

00:00:16,080 --> 00:00:19,920
however since the capability of directly

00:00:18,240 --> 00:00:21,279
delivering interrupts from past through

00:00:19,920 --> 00:00:22,960
devices to a vm

00:00:21,279 --> 00:00:24,320
we have nothing much developing this

00:00:22,960 --> 00:00:25,920
menu here

00:00:24,320 --> 00:00:27,519
we like to take the opportunity of the

00:00:25,920 --> 00:00:29,039
emerging risk five architecture to

00:00:27,519 --> 00:00:29,679
introduce some new ideas to keeping

00:00:29,039 --> 00:00:31,920
improved

00:00:29,679 --> 00:00:32,719
in virtual interrupts in this

00:00:31,920 --> 00:00:34,480
presentation

00:00:32,719 --> 00:00:35,840
i'll first provide some background

00:00:34,480 --> 00:00:37,280
information on how the virtual

00:00:35,840 --> 00:00:39,200
interrupts are processed on the current

00:00:37,280 --> 00:00:42,320
risk 5 kvm architecture

00:00:39,200 --> 00:00:44,879
as to motivate our proposed improvements

00:00:42,320 --> 00:00:46,239
next i'll talk about more more detail

00:00:44,879 --> 00:00:48,200
about an improvement

00:00:46,239 --> 00:00:50,239
which includes the design of a

00:00:48,200 --> 00:00:51,280
virtualization aware interrupt

00:00:50,239 --> 00:00:53,199
controller

00:00:51,280 --> 00:00:54,879
and direct delivery of virtual

00:00:53,199 --> 00:00:56,640
interrupts to vcpu

00:00:54,879 --> 00:00:58,000
next i'll show you the detailed

00:00:56,640 --> 00:01:00,239
implementation in kvm

00:00:58,000 --> 00:01:02,320
to handle the virtual various kinds of

00:01:00,239 --> 00:01:03,199
virtual interrupts and vcpu state

00:01:02,320 --> 00:01:05,280
changes

00:01:03,199 --> 00:01:06,880
i also show you some performance results

00:01:05,280 --> 00:01:10,159
lastly i'll briefly talk about some

00:01:06,880 --> 00:01:11,840
future work and directions

00:01:10,159 --> 00:01:14,479
let's move on to the background of

00:01:11,840 --> 00:01:16,880
motivation

00:01:14,479 --> 00:01:19,040
the current hypervisor extension on risk

00:01:16,880 --> 00:01:21,360
five does not include any support for

00:01:19,040 --> 00:01:23,119
accelerating virtual interrupts all

00:01:21,360 --> 00:01:24,960
virtual interrupts are implemented on a

00:01:23,119 --> 00:01:26,479
trap and emulated approach

00:01:24,960 --> 00:01:28,240
there are three types of virtual

00:01:26,479 --> 00:01:30,159
interrupts that are of concern

00:01:28,240 --> 00:01:31,840
corresponding to three types of physical

00:01:30,159 --> 00:01:32,640
interrupts there are virtual timer

00:01:31,840 --> 00:01:34,479
interrupts

00:01:32,640 --> 00:01:36,240
virtual supervisor software generated

00:01:34,479 --> 00:01:37,600
interrupt and virtual supervisor

00:01:36,240 --> 00:01:39,600
external interrupt

00:01:37,600 --> 00:01:41,200
the current flow of the virtual timer

00:01:39,600 --> 00:01:43,200
interrupt is shown here

00:01:41,200 --> 00:01:45,040
whenever the vm kernel needs to set up

00:01:43,200 --> 00:01:47,680
the timer for a timer interrupt

00:01:45,040 --> 00:01:49,759
it needs to trap to kvm which utilizes

00:01:47,680 --> 00:01:51,759
the hr timer and the timer driver which

00:01:49,759 --> 00:01:53,040
finally traps the machine mode to set up

00:01:51,759 --> 00:01:55,520
the physical timer

00:01:53,040 --> 00:01:56,880
on the interrupt the heart is switched

00:01:55,520 --> 00:02:00,640
to machine mode first

00:01:56,880 --> 00:02:03,200
the open spi then injects

00:02:00,640 --> 00:02:04,880
timer into up to the hm mode host kernel

00:02:03,200 --> 00:02:05,920
which then injects the timer into up to

00:02:04,880 --> 00:02:07,759
the gas kernel

00:02:05,920 --> 00:02:09,039
the entire process includes multiple

00:02:07,759 --> 00:02:10,959
traps and components

00:02:09,039 --> 00:02:14,400
many cycles that spend the emulation of

00:02:10,959 --> 00:02:14,400
the timer interrupt to the guest

00:02:16,239 --> 00:02:19,840
the virtual software generated interrupt

00:02:18,720 --> 00:02:21,680
is shown here

00:02:19,840 --> 00:02:23,599
to send the virtual software generated

00:02:21,680 --> 00:02:26,000
interrupts the guest vm needs to call

00:02:23,599 --> 00:02:28,560
the emulated spi by the kvm

00:02:26,000 --> 00:02:30,319
which causes the trap to the host the

00:02:28,560 --> 00:02:32,160
host save the interrupt for the other

00:02:30,319 --> 00:02:33,840
vcpu and notify the heart that the other

00:02:32,160 --> 00:02:35,840
vcpu is running on

00:02:33,840 --> 00:02:37,920
to perform the notification the host

00:02:35,840 --> 00:02:39,599
needs to call the real sbi which causes

00:02:37,920 --> 00:02:41,920
another trap to machine mode

00:02:39,599 --> 00:02:42,959
when the machine mode interrupt arrives

00:02:41,920 --> 00:02:45,120
at the other heart

00:02:42,959 --> 00:02:46,800
the heart first switches to machine mode

00:02:45,120 --> 00:02:48,480
the open spi injects a software

00:02:46,800 --> 00:02:50,319
interrupt to the host kernel

00:02:48,480 --> 00:02:51,840
then the host kernel realizes that

00:02:50,319 --> 00:02:52,800
there's a saved software interval for

00:02:51,840 --> 00:02:55,280
the guest

00:02:52,800 --> 00:02:57,120
inje injects the this interrupt to the

00:02:55,280 --> 00:02:59,680
guest when resuming the guest

00:02:57,120 --> 00:03:00,319
we can see that software virtual

00:02:59,680 --> 00:03:02,080
software

00:03:00,319 --> 00:03:04,400
interrupts also introduce the number of

00:03:02,080 --> 00:03:07,599
traps results in the same situation as

00:03:04,400 --> 00:03:07,599
virtual timer interrupt

00:03:07,840 --> 00:03:12,000
on the current kvn multi-risk 5 to send

00:03:10,319 --> 00:03:14,400
the interrupt by the emulated virtual

00:03:12,000 --> 00:03:16,319
device in qmu the steps involves firstly

00:03:14,400 --> 00:03:17,680
to perform necessary emulation of the

00:03:16,319 --> 00:03:20,000
plic

00:03:17,680 --> 00:03:21,599
next to notify the guest vm a trap to

00:03:20,000 --> 00:03:24,720
host kernel is needed by the

00:03:21,599 --> 00:03:26,799
plic kvn modules in the host kernel next

00:03:24,720 --> 00:03:27,280
saves the interrupt info for the vcpu

00:03:26,799 --> 00:03:28,879
and

00:03:27,280 --> 00:03:30,720
uses the host software generator

00:03:28,879 --> 00:03:33,840
interrupt to notify the heart

00:03:30,720 --> 00:03:36,319
on which the vcp is executing the vcpu

00:03:33,840 --> 00:03:38,000
traps and quickly resumes the execution

00:03:36,319 --> 00:03:40,080
it picks up the interrupt during the

00:03:38,000 --> 00:03:41,920
resumption we see that again

00:03:40,080 --> 00:03:44,319
a number of traps are needed in this

00:03:41,920 --> 00:03:46,480
process

00:03:44,319 --> 00:03:47,599
during the handling of inter from the

00:03:46,480 --> 00:03:50,640
virtual

00:03:47,599 --> 00:03:52,400
um from the virtual devices again a

00:03:50,640 --> 00:03:54,879
number of traps are incurred

00:03:52,400 --> 00:03:57,040
the main reason is that the mmi access

00:03:54,879 --> 00:03:58,000
to the emulator plick calls the traps to

00:03:57,040 --> 00:03:59,760
the host

00:03:58,000 --> 00:04:02,319
there are further switches in a host

00:03:59,760 --> 00:04:02,799
with when the plic emulation coding user

00:04:02,319 --> 00:04:05,599
space

00:04:02,799 --> 00:04:05,840
interacts with the host kernel the mmio

00:04:05,599 --> 00:04:07,439
is

00:04:05,840 --> 00:04:09,280
needed to at least acknowledge the

00:04:07,439 --> 00:04:10,560
pending interrupt and to signal end of

00:04:09,280 --> 00:04:15,519
interrupt handling which

00:04:10,560 --> 00:04:17,840
involves at least two traps

00:04:15,519 --> 00:04:20,000
so we notice that all the processing of

00:04:17,840 --> 00:04:23,199
interrupts involves a number of traps

00:04:20,000 --> 00:04:25,840
meanwhile other architectures such as

00:04:23,199 --> 00:04:27,440
x86 and arm have been providing direct

00:04:25,840 --> 00:04:29,759
delivery of certain kind of virtual

00:04:27,440 --> 00:04:33,520
intro to the vcp for a while

00:04:29,759 --> 00:04:35,199
so direct delivery of virtual interrupts

00:04:33,520 --> 00:04:37,360
avoids excessive traps

00:04:35,199 --> 00:04:38,880
reducing overhead and improving the

00:04:37,360 --> 00:04:40,880
overall performance

00:04:38,880 --> 00:04:44,000
the question is can we have something

00:04:40,880 --> 00:04:44,000
like that for risk five

00:04:44,320 --> 00:04:47,520
um from that let's move on to our work

00:04:46,320 --> 00:04:51,040
that um

00:04:47,520 --> 00:04:51,040
on the risk five actually

00:04:52,320 --> 00:04:57,120
so we extended the interrupt controller

00:04:55,199 --> 00:04:57,759
on the current risk 5 architecture to

00:04:57,120 --> 00:04:59,680
support

00:04:57,759 --> 00:05:01,039
direct delivery of all kinds of virtual

00:04:59,680 --> 00:05:03,280
interrupts in

00:05:01,039 --> 00:05:04,880
including virtual timer interrupts

00:05:03,280 --> 00:05:06,400
virtual software generated interrupts

00:05:04,880 --> 00:05:07,360
and virtual supervisor external

00:05:06,400 --> 00:05:09,360
interrupt

00:05:07,360 --> 00:05:11,919
we have also implemented implementing

00:05:09,360 --> 00:05:13,440
necessary support on the kvm for kvm to

00:05:11,919 --> 00:05:15,759
validate the functional design

00:05:13,440 --> 00:05:17,120
of the extended interrupt controller

00:05:15,759 --> 00:05:19,440
note that our

00:05:17,120 --> 00:05:20,960
on extensions id are not dependent on a

00:05:19,440 --> 00:05:22,479
particular interrupt controller

00:05:20,960 --> 00:05:24,639
can be adapted to future internal

00:05:22,479 --> 00:05:26,240
controller as needed

00:05:24,639 --> 00:05:28,160
the existing interrupt controller on

00:05:26,240 --> 00:05:31,360
risk 5 consists of two parts

00:05:28,160 --> 00:05:34,080
the c-link and the plic the c-link

00:05:31,360 --> 00:05:37,360
mainly contains the local timer csr

00:05:34,080 --> 00:05:40,000
called the m-time cnp the

00:05:37,360 --> 00:05:40,479
plic acts as the routing units so to

00:05:40,000 --> 00:05:42,400
speak

00:05:40,479 --> 00:05:44,240
for external interrupts and

00:05:42,400 --> 00:05:46,400
software-generated interrupts

00:05:44,240 --> 00:05:48,400
it contains the various controls and

00:05:46,400 --> 00:05:50,320
status speeds for the interrupt sources

00:05:48,400 --> 00:05:53,840
i'll skip the details of these please

00:05:50,320 --> 00:05:53,840
refer to specs if you're interested

00:05:55,039 --> 00:05:58,479
we have extended the ceiling tennis plic

00:05:57,440 --> 00:06:01,120
with a set of

00:05:58,479 --> 00:06:02,479
csr to support the direct delivery of

00:06:01,120 --> 00:06:04,960
virtual interrupts

00:06:02,479 --> 00:06:07,280
for each type of virtual interrupts we

00:06:04,960 --> 00:06:08,240
provide csrs according to the functional

00:06:07,280 --> 00:06:11,360
requirement of the

00:06:08,240 --> 00:06:12,080
virtual interrupt for example for timer

00:06:11,360 --> 00:06:15,759
interrupt

00:06:12,080 --> 00:06:17,759
we provide a csr for vs mode and vhs

00:06:15,759 --> 00:06:21,120
mode that act as the dedicated clock

00:06:17,759 --> 00:06:21,520
event source respectively the csrs can

00:06:21,120 --> 00:06:23,600
be

00:06:21,520 --> 00:06:25,440
accessed directly from the mode they are

00:06:23,600 --> 00:06:27,840
intended for without trapping

00:06:25,440 --> 00:06:29,199
the guest vm can directly set the timer

00:06:27,840 --> 00:06:31,759
interrupt with vs

00:06:29,199 --> 00:06:32,720
time cmp for example it does not need to

00:06:31,759 --> 00:06:36,639
trap to the host

00:06:32,720 --> 00:06:38,800
or other csrs follow the same idea

00:06:36,639 --> 00:06:40,240
uh we extended the plic to handle

00:06:38,800 --> 00:06:42,479
virtual interrupts that are not

00:06:40,240 --> 00:06:44,319
local which are the virtual software

00:06:42,479 --> 00:06:47,039
generated interrupts and

00:06:44,319 --> 00:06:49,199
external interrupts these new registers

00:06:47,039 --> 00:06:51,039
contain structures that are used for

00:06:49,199 --> 00:06:52,160
routing virtual interrupts while

00:06:51,039 --> 00:06:54,479
considering

00:06:52,160 --> 00:06:55,360
the whole scheduling decisions for

00:06:54,479 --> 00:06:57,680
example

00:06:55,360 --> 00:06:59,599
for each heart x we provide the

00:06:57,680 --> 00:07:02,639
corresponding ifmap

00:06:59,599 --> 00:07:06,479
x register the ifmap register

00:07:02,639 --> 00:07:09,199
holds the evm id and vhard id pair

00:07:06,479 --> 00:07:10,560
that indicates the identity of a vcpu

00:07:09,199 --> 00:07:11,440
that is currently running on the

00:07:10,560 --> 00:07:14,720
physical

00:07:11,440 --> 00:07:16,800
physical heart x when the pure ic needs

00:07:14,720 --> 00:07:18,080
to deliver a virtual software generated

00:07:16,800 --> 00:07:21,120
interrupt it looks up

00:07:18,080 --> 00:07:24,240
all the ifmap registers in parallel

00:07:21,120 --> 00:07:26,880
to locate the target vcpu if any of

00:07:24,240 --> 00:07:29,039
these slots matches the plic knows that

00:07:26,880 --> 00:07:30,080
the target vcpu is on the heart that the

00:07:29,039 --> 00:07:31,759
corresponding

00:07:30,080 --> 00:07:33,440
that corresponds to the heart to the

00:07:31,759 --> 00:07:35,440
slot

00:07:33,440 --> 00:07:36,720
the the advantage of this design is that

00:07:35,440 --> 00:07:40,160
instead of contention

00:07:36,720 --> 00:07:42,000
on the share single share resources such

00:07:40,160 --> 00:07:43,120
as global table or certain kind of

00:07:42,000 --> 00:07:45,440
command queue

00:07:43,120 --> 00:07:47,280
each thread only writes to its own slots

00:07:45,440 --> 00:07:49,520
without taking any logs

00:07:47,280 --> 00:07:50,800
the hardware later can perform the local

00:07:49,520 --> 00:07:53,440
being parallel

00:07:50,800 --> 00:07:53,840
the other registers are designed with

00:07:53,440 --> 00:07:58,000
this

00:07:53,840 --> 00:08:00,560
same idea

00:07:58,000 --> 00:08:02,479
to directly deliver virtual interrupts

00:08:00,560 --> 00:08:04,080
the ceiling needs to be able to directly

00:08:02,479 --> 00:08:05,120
set the pending bits first for the

00:08:04,080 --> 00:08:07,440
virtual interrupts

00:08:05,120 --> 00:08:09,440
currently such in such pending bits are

00:08:07,440 --> 00:08:12,720
only set by host software

00:08:09,440 --> 00:08:15,520
we change that so that when v equals one

00:08:12,720 --> 00:08:15,919
the guess receives an interrupt directly

00:08:15,520 --> 00:08:18,479
the v

00:08:15,919 --> 00:08:19,440
bit is risk five nomenclature that

00:08:18,479 --> 00:08:22,560
whether

00:08:19,440 --> 00:08:23,759
the heart is running a vcpu to minimize

00:08:22,560 --> 00:08:25,680
the possible delay

00:08:23,759 --> 00:08:27,840
we also consider delivering the

00:08:25,680 --> 00:08:29,599
interrupts when v equals zero

00:08:27,840 --> 00:08:31,840
when a virtual interrupt arrived on a

00:08:29,599 --> 00:08:34,880
certain heart when v equals zero

00:08:31,840 --> 00:08:36,880
the host still handles it in this case

00:08:34,880 --> 00:08:38,640
the virtual interval goes along the same

00:08:36,880 --> 00:08:41,839
handling path as this

00:08:38,640 --> 00:08:42,959
existing approach so our design is as

00:08:41,839 --> 00:08:45,440
good as the

00:08:42,959 --> 00:08:46,320
existing approach in the slow pass note

00:08:45,440 --> 00:08:48,560
that also

00:08:46,320 --> 00:08:49,920
conceptually this needs differentiation

00:08:48,560 --> 00:08:52,880
between the interrupt

00:08:49,920 --> 00:08:55,839
from the same source by hand handled by

00:08:52,880 --> 00:08:55,839
different entities

00:08:57,680 --> 00:09:02,000
because even if the host claimed the

00:09:00,000 --> 00:09:02,480
virtual interrupt the handling does not

00:09:02,000 --> 00:09:04,560
finish

00:09:02,480 --> 00:09:08,000
the virtual interval should still remain

00:09:04,560 --> 00:09:09,920
pending for the guest

00:09:08,000 --> 00:09:11,360
so to differentiate the pending states

00:09:09,920 --> 00:09:13,360
of the same virtual interrupts

00:09:11,360 --> 00:09:14,800
for the hypervisor and the guest we need

00:09:13,360 --> 00:09:16,399
to introduce additional bits

00:09:14,800 --> 00:09:18,240
different types of interrupts need to be

00:09:16,399 --> 00:09:20,160
treated differently

00:09:18,240 --> 00:09:21,839
we don't need one for the virtual timer

00:09:20,160 --> 00:09:23,680
interrupt because the hypervisor doesn't

00:09:21,839 --> 00:09:24,720
really claim a virtual timer interrupt

00:09:23,680 --> 00:09:28,080
since it's

00:09:24,720 --> 00:09:32,480
level triggered having separated

00:09:28,080 --> 00:09:35,120
hip vstip bit and vsipwstip

00:09:32,480 --> 00:09:36,640
does not really make sense eventually

00:09:35,120 --> 00:09:40,240
the timer will clear

00:09:36,640 --> 00:09:43,040
any blending bits once the value inside

00:09:40,240 --> 00:09:44,000
is updated to repent to represent future

00:09:43,040 --> 00:09:46,160
time

00:09:44,000 --> 00:09:48,000
uh we do not need to separate and then

00:09:46,160 --> 00:09:51,120
and we do need to separate the enable

00:09:48,000 --> 00:09:53,800
bits though the vsie

00:09:51,120 --> 00:09:56,800
and is no longer an alias of the

00:09:53,800 --> 00:09:56,800
h-i-e-w-s-t-i-e

00:09:57,200 --> 00:10:02,800
we introduced additional bits for vssi

00:09:59,600 --> 00:10:02,800
by separating the

00:10:02,839 --> 00:10:05,839
v-s-i-p-s-i-p-build from the alias

00:10:04,880 --> 00:10:09,440
relation

00:10:05,839 --> 00:10:12,480
with hip.v ssip bit

00:10:09,440 --> 00:10:15,760
we also need to separate the enable bits

00:10:12,480 --> 00:10:17,920
we use for virtual

00:10:15,760 --> 00:10:19,519
supervisor external interrupts we use

00:10:17,920 --> 00:10:21,440
another notification interrupt to

00:10:19,519 --> 00:10:23,920
represent the host interrupts so

00:10:21,440 --> 00:10:25,200
the separation is completed with the

00:10:23,920 --> 00:10:32,079
pending bit

00:10:25,200 --> 00:10:33,600
for that notification interrupt

00:10:32,079 --> 00:10:36,320
to support the above interrupt

00:10:33,600 --> 00:10:39,120
controller extension the kvm's main task

00:10:36,320 --> 00:10:40,720
is to handle interrupt 1v equal 0

00:10:39,120 --> 00:10:43,360
and to maintain a consistent interrupt

00:10:40,720 --> 00:10:45,920
context for each vcpu

00:10:43,360 --> 00:10:47,760
the vcp using kvm essentially using one

00:10:45,920 --> 00:10:50,959
of the three states showing this

00:10:47,760 --> 00:10:52,959
in this state transition diagram kvn's

00:10:50,959 --> 00:10:54,000
main task concentrates on the right

00:10:52,959 --> 00:10:56,880
portion

00:10:54,000 --> 00:10:57,760
when the vcpu is impulsed and scheduled

00:10:56,880 --> 00:11:00,160
off state

00:10:57,760 --> 00:11:01,360
the kvm handles the virtual interrupts

00:11:00,160 --> 00:11:04,560
saving them for

00:11:01,360 --> 00:11:06,959
injection if necessary when the visible

00:11:04,560 --> 00:11:09,360
transits between the two states the kvm

00:11:06,959 --> 00:11:13,760
perform necessary context maintenance in

00:11:09,360 --> 00:11:15,200
kvmv cpu put and kvm vcp load functions

00:11:13,760 --> 00:11:17,120
the reason for the host to handle

00:11:15,200 --> 00:11:19,360
virtual intel for the guest is that if

00:11:17,120 --> 00:11:21,440
the vcpu was not scheduled off

00:11:19,360 --> 00:11:23,600
it's just paused the interrupt

00:11:21,440 --> 00:11:25,360
controller will still regard as hard as

00:11:23,600 --> 00:11:26,320
having the vcp running because the

00:11:25,360 --> 00:11:29,839
update

00:11:26,320 --> 00:11:33,279
of the ifmap x register happens in vcpu

00:11:29,839 --> 00:11:34,880
put kvm vcp put on kv and vcp load

00:11:33,279 --> 00:11:39,040
then the virtual interrupt will still

00:11:34,880 --> 00:11:42,240
arrive but the vcp is not executing

00:11:39,040 --> 00:11:44,240
next we will show how kvm performs at

00:11:42,240 --> 00:11:46,000
this these tasks for each kind of

00:11:44,240 --> 00:11:49,279
virtual interrupts

00:11:46,000 --> 00:11:52,240
that brings us to the actual trapless

00:11:49,279 --> 00:11:52,240
virtual interrupt

00:11:54,639 --> 00:11:58,480
for virtual timer interrupt to set a

00:11:57,360 --> 00:12:01,920
timer the guest

00:11:58,480 --> 00:12:05,040
writes to the vs time cmp csr via the

00:12:01,920 --> 00:12:07,440
ads scmp

00:12:05,040 --> 00:12:09,680
to set the timer the host writes

00:12:07,440 --> 00:12:12,240
directly to the vsm cmp to switch the

00:12:09,680 --> 00:12:15,920
vcb contacts

00:12:12,240 --> 00:12:17,680
when a timer interrupt fires if the vcpu

00:12:15,920 --> 00:12:21,519
is in running state

00:12:17,680 --> 00:12:24,880
v equals one so hip.vstip is set

00:12:21,519 --> 00:12:25,360
the guest handles it directly in pulse

00:12:24,880 --> 00:12:28,880
state

00:12:25,360 --> 00:12:30,240
v equals zero hip.vstip is still set

00:12:28,880 --> 00:12:33,440
however the whole standard

00:12:30,240 --> 00:12:34,560
this time for the host does this to

00:12:33,440 --> 00:12:36,560
allow

00:12:34,560 --> 00:12:39,120
a necessary priority adjustment for

00:12:36,560 --> 00:12:40,800
scheduling for example

00:12:39,120 --> 00:12:43,120
in the scheduled off state the host

00:12:40,800 --> 00:12:44,880
tracks the vcpu's timer using hr timer

00:12:43,120 --> 00:12:45,200
which is same as the existing approach

00:12:44,880 --> 00:12:49,519
so

00:12:45,200 --> 00:12:53,600
no timer virtual interrupts is handled

00:12:49,519 --> 00:12:56,240
it's fired

00:12:53,600 --> 00:12:58,240
during the vcpu state transition the kvm

00:12:56,240 --> 00:12:59,920
needs to maintain consistencies

00:12:58,240 --> 00:13:02,320
so during the transition from the

00:12:59,920 --> 00:13:04,560
running stage to the pulse state

00:13:02,320 --> 00:13:07,440
the kevin saves the state to the vsie

00:13:04,560 --> 00:13:09,760
csr so that if the vcpu enters the pulse

00:13:07,440 --> 00:13:12,959
state because it executed wfi

00:13:09,760 --> 00:13:13,920
instruction the host needs an updated

00:13:12,959 --> 00:13:16,320
view to

00:13:13,920 --> 00:13:18,480
whether the guest has enabled interrupt

00:13:16,320 --> 00:13:21,360
so they can bring the vcpu out

00:13:18,480 --> 00:13:22,320
of the vcp block function later when the

00:13:21,360 --> 00:13:24,800
interrupt is

00:13:22,320 --> 00:13:26,800
is intended for the guest for the

00:13:24,800 --> 00:13:29,519
transition between the pulse state and

00:13:26,800 --> 00:13:31,680
schedule off states the kvm needs to

00:13:29,519 --> 00:13:35,200
save the value of the vs

00:13:31,680 --> 00:13:37,360
time ca csr and utilize the host hr

00:13:35,200 --> 00:13:41,440
timer for city to track

00:13:37,360 --> 00:13:45,040
the timer set by the guest

00:13:41,440 --> 00:13:48,079
as shown in these lines

00:13:45,040 --> 00:13:50,240
on the slides the host

00:13:48,079 --> 00:13:52,880
needs to temporarily disable its own

00:13:50,240 --> 00:13:55,519
handling of vs mode virtual timer intro

00:13:52,880 --> 00:13:57,680
because if at any moment the value being

00:13:55,519 --> 00:14:00,320
saved or restored

00:13:57,680 --> 00:14:01,839
happens to be in the past the host needs

00:14:00,320 --> 00:14:03,600
to avoid double handling of the same

00:14:01,839 --> 00:14:05,199
time or interrupt again this is because

00:14:03,600 --> 00:14:06,639
we still need to maintain the level

00:14:05,199 --> 00:14:10,079
trigger semantics of

00:14:06,639 --> 00:14:13,839
timer interrupt the same as

00:14:10,079 --> 00:14:13,839
defined on the physical platform

00:14:14,079 --> 00:14:18,480
so with the extended interrupt

00:14:16,320 --> 00:14:20,240
controller and the kvm support now the

00:14:18,480 --> 00:14:22,639
virtual timer interrupt can be

00:14:20,240 --> 00:14:24,800
directly delivered to the vm kernel when

00:14:22,639 --> 00:14:28,720
the vcpu is running

00:14:24,800 --> 00:14:30,079
when the vcpu is paused the interrupt is

00:14:28,720 --> 00:14:33,680
delivered to the host

00:14:30,079 --> 00:14:36,639
which immediately injects it to the vcpu

00:14:33,680 --> 00:14:38,480
when the vcpu is scheduled off the host

00:14:36,639 --> 00:14:39,440
utilize the hr timer to track the

00:14:38,480 --> 00:14:41,680
virtual timers

00:14:39,440 --> 00:14:43,360
the hr timer uses the new timer

00:14:41,680 --> 00:14:46,959
dedicated for the hs mode

00:14:43,360 --> 00:14:46,959
avoiding traps to the machine mode

00:14:49,920 --> 00:14:53,360
so that's for virtual timer interrupt

00:14:52,800 --> 00:14:55,680
for

00:14:53,360 --> 00:14:57,040
virtual supervisor software-generated

00:14:55,680 --> 00:15:00,160
interrupt

00:14:57,040 --> 00:15:03,120
when a guest vcpu needs to

00:15:00,160 --> 00:15:04,079
send a software generator interrupt for

00:15:03,120 --> 00:15:07,199
another vcpu

00:15:04,079 --> 00:15:11,120
it writes to the s-gen ipi csr

00:15:07,199 --> 00:15:15,279
to do so it does so and specified the

00:15:11,120 --> 00:15:16,079
target vcpu id that that's intended to

00:15:15,279 --> 00:15:19,680
receive the

00:15:16,079 --> 00:15:22,639
virtual software generator interrupt

00:15:19,680 --> 00:15:24,959
after the write the poic received the

00:15:22,639 --> 00:15:28,240
target vcpuid so it looks up

00:15:24,959 --> 00:15:30,399
all the ifmap registers whether it is

00:15:28,240 --> 00:15:33,600
one that contains a specified

00:15:30,399 --> 00:15:37,040
vcpu id if found

00:15:33,600 --> 00:15:41,360
it delivers the vssi

00:15:37,040 --> 00:15:44,639
to the heart with the oops

00:15:41,360 --> 00:15:48,240
to the heart with m heart value

00:15:44,639 --> 00:15:49,440
n that which that which is the end slot

00:15:48,240 --> 00:15:52,959
that contains the

00:15:49,440 --> 00:15:54,720
matching vcpu id the vcpu can be

00:15:52,959 --> 00:15:56,800
either in running state or in pulse

00:15:54,720 --> 00:16:00,160
state if it's running the

00:15:56,800 --> 00:16:03,279
gas take the interrupt directly that

00:16:00,160 --> 00:16:04,959
handles it if the vcp is paused

00:16:03,279 --> 00:16:06,720
host takes the interrupt and injects it

00:16:04,959 --> 00:16:09,040
to the vcpu

00:16:06,720 --> 00:16:11,680
if there is no such a slot that contains

00:16:09,040 --> 00:16:14,480
the specified vcp id

00:16:11,680 --> 00:16:16,560
a notification interrupt is delivered to

00:16:14,480 --> 00:16:19,199
any host card for later injection

00:16:16,560 --> 00:16:23,199
the vcpu now must be in the scheduled

00:16:19,199 --> 00:16:27,120
off state

00:16:23,199 --> 00:16:27,440
the kvn job is also to maintain context

00:16:27,120 --> 00:16:29,040
for

00:16:27,440 --> 00:16:31,519
virtual software generating interrupts

00:16:29,040 --> 00:16:33,680
during the same stage transition

00:16:31,519 --> 00:16:35,440
when the vcpu transit between the

00:16:33,680 --> 00:16:37,759
running state and the power state

00:16:35,440 --> 00:16:39,279
the kvm synchronized the saved pending

00:16:37,759 --> 00:16:42,639
state for the vssi

00:16:39,279 --> 00:16:44,480
and the hardware vsip register record

00:16:42,639 --> 00:16:46,320
that we separated the pending bits for

00:16:44,480 --> 00:16:49,040
the guest and the host

00:16:46,320 --> 00:16:51,440
unlike the virtual timer interrupts when

00:16:49,040 --> 00:16:53,759
the vcpu is in pulse state the host

00:16:51,440 --> 00:16:55,519
handles the vss side that receives

00:16:53,759 --> 00:16:56,320
because the plic thinks that the hard

00:16:55,519 --> 00:16:58,320
target

00:16:56,320 --> 00:17:00,480
that the target vcpu is still running on

00:16:58,320 --> 00:17:03,920
a particular heart

00:17:00,480 --> 00:17:05,679
when the host schedules off a vcpu or

00:17:03,920 --> 00:17:08,000
scales on a vcpu

00:17:05,679 --> 00:17:09,839
it updates the corresponding ifmap

00:17:08,000 --> 00:17:12,559
register

00:17:09,839 --> 00:17:14,799
when the target vcpu is scheduled off

00:17:12,559 --> 00:17:16,799
the plac send the notification interrupt

00:17:14,799 --> 00:17:19,600
to the heart so that the host can

00:17:16,799 --> 00:17:22,240
wake up the target vcpu and resume its

00:17:19,600 --> 00:17:22,240
execution

00:17:23,039 --> 00:17:27,520
with the extension on the interrupt

00:17:25,760 --> 00:17:29,440
controller and kvm support

00:17:27,520 --> 00:17:31,520
now the vst site can be directly

00:17:29,440 --> 00:17:33,360
directly delivered to the vm kernel when

00:17:31,520 --> 00:17:34,880
the vcpu is running

00:17:33,360 --> 00:17:37,360
avoiding traps to the current to the

00:17:34,880 --> 00:17:39,360
host when the vcpu is not currently

00:17:37,360 --> 00:17:41,280
running the host receives the interrupt

00:17:39,360 --> 00:17:46,240
and injects it to the vcpu

00:17:41,280 --> 00:17:48,960
same as the current solution

00:17:46,240 --> 00:17:50,400
similarly for virtual supervisor

00:17:48,960 --> 00:17:53,440
external interrupt

00:17:50,400 --> 00:17:55,520
um when

00:17:53,440 --> 00:17:57,679
the virtual machine is created the host

00:17:55,520 --> 00:17:58,480
allocates a piece of memory for pending

00:17:57,679 --> 00:18:03,200
bits

00:17:58,480 --> 00:18:03,200
of the external interrupts for the vm

00:18:03,280 --> 00:18:09,280
when the emulative it external device

00:18:07,120 --> 00:18:11,200
needs to send a virtual supervisor

00:18:09,280 --> 00:18:15,600
external interrupt to the guest

00:18:11,200 --> 00:18:18,799
it writes the new vse icsr to send an

00:18:15,600 --> 00:18:21,520
external device interpreted guest

00:18:18,799 --> 00:18:22,720
it writes the vmid and the interim

00:18:21,520 --> 00:18:25,520
number

00:18:22,720 --> 00:18:28,080
into the register so that the pls

00:18:25,520 --> 00:18:30,480
receive these it looks up the virtual

00:18:28,080 --> 00:18:31,520
interrupt affinity tables pointed to by

00:18:30,480 --> 00:18:34,320
the v

00:18:31,520 --> 00:18:35,520
table base and registers and locate the

00:18:34,320 --> 00:18:36,960
vcpu that

00:18:35,520 --> 00:18:39,120
this virtual interrupt should be

00:18:36,960 --> 00:18:42,480
delivered to

00:18:39,120 --> 00:18:44,880
next the plic performs similar tasks

00:18:42,480 --> 00:18:47,840
when is looking for a particular

00:18:44,880 --> 00:18:49,600
vcpu for the software generated

00:18:47,840 --> 00:18:52,559
interrupt because

00:18:49,600 --> 00:18:52,880
this kind of interrupt also resembles

00:18:52,559 --> 00:18:54,799
the

00:18:52,880 --> 00:18:56,880
software generated interrupt because

00:18:54,799 --> 00:18:58,160
they are there between it happens

00:18:56,880 --> 00:19:01,200
between

00:18:58,160 --> 00:19:02,480
hearts so the plic looks up the ifmap

00:19:01,200 --> 00:19:05,360
registers

00:19:02,480 --> 00:19:07,520
um to see if there's a matching vcp id

00:19:05,360 --> 00:19:09,760
if they're easily delivered to

00:19:07,520 --> 00:19:10,640
the virtual interrupt to that particular

00:19:09,760 --> 00:19:13,360
heart

00:19:10,640 --> 00:19:15,360
if the heart if the vcpu is running it

00:19:13,360 --> 00:19:16,960
takes the interrupt directly if it's not

00:19:15,360 --> 00:19:18,559
the host takes the interrupt injection

00:19:16,960 --> 00:19:21,360
sci to the vcpu

00:19:18,559 --> 00:19:25,120
if not found a notification interrupt is

00:19:21,360 --> 00:19:28,480
delivered to the host

00:19:25,120 --> 00:19:29,200
after the guest received the external

00:19:28,480 --> 00:19:32,000
interrupts

00:19:29,200 --> 00:19:32,480
it needs to handle it there are at least

00:19:32,000 --> 00:19:34,400
two

00:19:32,480 --> 00:19:35,520
steps during the handling of the

00:19:34,400 --> 00:19:39,120
interrupt

00:19:35,520 --> 00:19:40,400
so for guests to claim and to signal the

00:19:39,120 --> 00:19:43,120
end of interrupt

00:19:40,400 --> 00:19:43,520
processing the guests that just directly

00:19:43,120 --> 00:19:45,600
read

00:19:43,520 --> 00:19:48,000
from the right to the vs claim register

00:19:45,600 --> 00:19:50,320
to claim and signal it

00:19:48,000 --> 00:19:51,760
reading and writing to this particular

00:19:50,320 --> 00:19:56,080
register does not

00:19:51,760 --> 00:19:56,080
cause traps to host in our design

00:19:58,960 --> 00:20:03,120
so similar to the other virtual

00:20:00,480 --> 00:20:05,919
interrupts the kvm saves and restore the

00:20:03,120 --> 00:20:07,760
hip csr when the vcpu transits between

00:20:05,919 --> 00:20:09,520
the running and power state

00:20:07,760 --> 00:20:12,000
when the power state the host handled

00:20:09,520 --> 00:20:14,240
the vsci that it receives because the

00:20:12,000 --> 00:20:16,480
plc think that the target vcpu is still

00:20:14,240 --> 00:20:20,720
running

00:20:16,480 --> 00:20:22,720
on the heart the plic reuse the same

00:20:20,720 --> 00:20:25,679
ifmap register to decide

00:20:22,720 --> 00:20:26,480
if a target vcpu is executed on any

00:20:25,679 --> 00:20:28,880
heart

00:20:26,480 --> 00:20:30,799
when the vcpu is scheduled on and off

00:20:28,880 --> 00:20:32,840
the host needs to maintain the pending

00:20:30,799 --> 00:20:35,440
bits for that particular

00:20:32,840 --> 00:20:38,559
vm um

00:20:35,440 --> 00:20:39,440
like this when the vcpu is in schedule

00:20:38,559 --> 00:20:41,360
off state

00:20:39,440 --> 00:20:42,880
the host handles any notification

00:20:41,360 --> 00:20:46,840
interrupt for

00:20:42,880 --> 00:20:49,760
vscis and that targets the schedule of

00:20:46,840 --> 00:20:52,480
vcpu

00:20:49,760 --> 00:20:55,039
so when it's with this extension and

00:20:52,480 --> 00:20:57,360
corresponding kvm support the vsci can

00:20:55,039 --> 00:21:00,400
be directly delivered to the vm kernel

00:20:57,360 --> 00:21:02,400
when the vcp is in the running state as

00:21:00,400 --> 00:21:04,400
shown in this diagram

00:21:02,400 --> 00:21:06,080
when the vcp is not running the host

00:21:04,400 --> 00:21:08,159
handles the interrupt

00:21:06,080 --> 00:21:10,960
and injects them to the vcp in a similar

00:21:08,159 --> 00:21:14,400
fashion as vssi

00:21:10,960 --> 00:21:16,480
on the processing and acknowledging side

00:21:14,400 --> 00:21:18,480
the claiming and signaling end of

00:21:16,480 --> 00:21:19,679
interrupt also happens without trapping

00:21:18,480 --> 00:21:22,720
the vm kernel that

00:21:19,679 --> 00:21:26,720
directly reads and writes a v claim csr

00:21:22,720 --> 00:21:26,720
which updates states accordingly

00:21:28,400 --> 00:21:33,280
let's move on to our information

00:21:30,080 --> 00:21:33,280
implementation results

00:21:33,760 --> 00:21:37,440
we have implemented above improving

00:21:35,919 --> 00:21:40,320
extensions in risk five

00:21:37,440 --> 00:21:42,400
qmil version five um which provides an

00:21:40,320 --> 00:21:44,799
emulated risk five environment with

00:21:42,400 --> 00:21:46,400
with a hypervisor extension we're using

00:21:44,799 --> 00:21:50,480
cumule because right now

00:21:46,400 --> 00:21:52,880
uh there have been no hardware that

00:21:50,480 --> 00:21:54,400
um risk five hardware that contains

00:21:52,880 --> 00:21:57,919
hypervisor extension

00:21:54,400 --> 00:22:00,640
so we got no choice um we have also

00:21:57,919 --> 00:22:04,320
implemented necessary kvm support

00:22:00,640 --> 00:22:06,559
uh we on this kvm support we run

00:22:04,320 --> 00:22:09,280
benchmarks that can be compiled and run

00:22:06,559 --> 00:22:11,120
in the emulator with reasonable support

00:22:09,280 --> 00:22:12,960
and obtain some performance results

00:22:11,120 --> 00:22:15,440
mainly we are able to compile around

00:22:12,960 --> 00:22:18,880
radius and unix bench

00:22:15,440 --> 00:22:18,880
and here are the results

00:22:19,919 --> 00:22:23,919
this benchmark shows the performance

00:22:21,760 --> 00:22:25,679
boost during radius obtained by

00:22:23,919 --> 00:22:27,280
adopting the extension for the virtual

00:22:25,679 --> 00:22:29,679
timer interrupt

00:22:27,280 --> 00:22:30,960
with one vcpu and the virtual timer

00:22:29,679 --> 00:22:35,360
interrupt extension

00:22:30,960 --> 00:22:37,440
we observed around 60 to 70 percent

00:22:35,360 --> 00:22:38,880
performance boost compared to the

00:22:37,440 --> 00:22:40,480
original solution

00:22:38,880 --> 00:22:42,320
the game mainly comes from the

00:22:40,480 --> 00:22:44,640
elimination of the traps

00:22:42,320 --> 00:22:45,679
to update the timer and to deliver the

00:22:44,640 --> 00:22:48,799
interrupts

00:22:45,679 --> 00:22:51,200
similar results are observed for unix

00:22:48,799 --> 00:22:51,200
bench

00:22:53,039 --> 00:22:56,799
this figure shows the performance

00:22:55,120 --> 00:22:59,200
boosting radius with both the virtual

00:22:56,799 --> 00:23:02,880
timer extension and the vssi

00:22:59,200 --> 00:23:05,600
extension with two v cpus we observe

00:23:02,880 --> 00:23:08,400
around 50 performance gain compared to

00:23:05,600 --> 00:23:11,200
the original spi based interrupts

00:23:08,400 --> 00:23:12,159
the performance scan again also comes

00:23:11,200 --> 00:23:15,200
from

00:23:12,159 --> 00:23:15,919
the elimination of the extensive traps

00:23:15,200 --> 00:23:22,000
to the host

00:23:15,919 --> 00:23:25,039
and to various modes in the host

00:23:22,000 --> 00:23:27,840
for vsdi we used ping

00:23:25,039 --> 00:23:29,840
to the virtual machine from the host and

00:23:27,840 --> 00:23:32,400
measure the latency

00:23:29,840 --> 00:23:34,000
with our extension the latency is

00:23:32,400 --> 00:23:37,280
reduced by 11

00:23:34,000 --> 00:23:38,960
on average the game also comes from

00:23:37,280 --> 00:23:41,679
elimination of traps due to i o

00:23:38,960 --> 00:23:41,679
operations

00:23:42,080 --> 00:23:46,159
the traps are like we send we ping the

00:23:45,520 --> 00:23:47,679
machine

00:23:46,159 --> 00:23:49,679
hundred and thousand times and we

00:23:47,679 --> 00:23:52,720
observe

00:23:49,679 --> 00:23:56,880
traps reduction due to mmi oh by

00:23:52,720 --> 00:23:59,520
three how around 300 000 times

00:23:56,880 --> 00:24:01,039
this number is expected because the

00:23:59,520 --> 00:24:04,320
current flow of

00:24:01,039 --> 00:24:05,679
io handling do cause like around three

00:24:04,320 --> 00:24:09,440
traps

00:24:05,679 --> 00:24:12,159
per handling one interrupt

00:24:09,440 --> 00:24:14,320
so we think these results here are

00:24:12,159 --> 00:24:16,480
strong indication that the extension can

00:24:14,320 --> 00:24:18,240
reduce the performance cost due to

00:24:16,480 --> 00:24:20,240
frequent traps

00:24:18,240 --> 00:24:22,080
although actually when implementing

00:24:20,240 --> 00:24:22,799
hardware the magnitude of the numbers

00:24:22,080 --> 00:24:24,880
may change

00:24:22,799 --> 00:24:27,440
because we are still using an emulating

00:24:24,880 --> 00:24:27,440
environment

00:24:27,600 --> 00:24:31,279
so for the future we like to continue to

00:24:30,559 --> 00:24:33,360
explore

00:24:31,279 --> 00:24:35,120
along the direction to include support

00:24:33,360 --> 00:24:36,960
for password devices

00:24:35,120 --> 00:24:38,480
which means we need an iomu in the first

00:24:36,960 --> 00:24:40,640
place

00:24:38,480 --> 00:24:42,320
we still need to furnish our extension

00:24:40,640 --> 00:24:45,360
with more details with

00:24:42,320 --> 00:24:47,919
practical practical implementations such

00:24:45,360 --> 00:24:51,279
as priority controls

00:24:47,919 --> 00:24:52,080
etc etc we also like to seek to

00:24:51,279 --> 00:24:54,400
integrate

00:24:52,080 --> 00:24:56,000
our extension with futurist risk 5

00:24:54,400 --> 00:24:58,840
interrupt controllers

00:24:56,000 --> 00:25:00,480
as well as validating our idea with more

00:24:58,840 --> 00:25:03,279
hypervisors

00:25:00,480 --> 00:25:13,520
with that i end my presentation and

00:25:03,279 --> 00:25:13,520

YouTube URL: https://www.youtube.com/watch?v=VVRlsyq9MSo


