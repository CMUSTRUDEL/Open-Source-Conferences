Title: Building a Cloud Infrastructure to Deploy Microservices as Microvm Guests - Matias Vara Larsen
Publication date: 2020-11-10
Playlist: KVM Forum Europe 2020
Description: 
	Building a Cloud Infrastructure to Deploy Microservices as Microvm Guests - Matias Vara Larsen, Huawei
Captions: 
	00:00:06,720 --> 00:00:10,800
hello everyone

00:00:07,839 --> 00:00:13,440
and uh thanks for coming i'm matthias

00:00:10,800 --> 00:00:16,240
farah and i work at huawei france

00:00:13,440 --> 00:00:18,560
in this presentation i'm going to talk

00:00:16,240 --> 00:00:20,640
about the deployment of microservice

00:00:18,560 --> 00:00:24,080
as micro vm total guests i hope you

00:00:20,640 --> 00:00:24,080
enjoyed the presentation

00:00:24,160 --> 00:00:28,480
before go deeply into the presentation i

00:00:26,240 --> 00:00:29,279
would like to picture what is a micro

00:00:28,480 --> 00:00:32,239
service

00:00:29,279 --> 00:00:34,160
richly speaking a microservice is a way

00:00:32,239 --> 00:00:36,880
to decompose a monolithic

00:00:34,160 --> 00:00:38,079
application into simpler components

00:00:36,880 --> 00:00:42,879
namely service

00:00:38,079 --> 00:00:42,879
each service provides a functionality

00:00:43,520 --> 00:00:47,600
one possible way to the deploy

00:00:46,480 --> 00:00:50,160
microservice

00:00:47,600 --> 00:00:51,840
is by using virtual machines this

00:00:50,160 --> 00:00:55,760
spotter is called

00:00:51,840 --> 00:00:55,760
service instant per vm

00:00:56,480 --> 00:01:01,840
the deployment of microservice as

00:00:59,039 --> 00:01:05,199
virtual machines has mainly two benefits

00:01:01,840 --> 00:01:08,080
first it allows to isolate microservice

00:01:05,199 --> 00:01:09,280
this means that they can interfere one

00:01:08,080 --> 00:01:11,119
each other

00:01:09,280 --> 00:01:13,600
second you can leverage from cloud

00:01:11,119 --> 00:01:17,200
infrastructure like amazon web service

00:01:13,600 --> 00:01:17,200
or google cloud engine

00:01:17,280 --> 00:01:21,280
so let's see how is the actual

00:01:19,200 --> 00:01:22,640
deployment of a micro service by

00:01:21,280 --> 00:01:25,040
following this pattern

00:01:22,640 --> 00:01:25,680
i'm going to describe a picture from

00:01:25,040 --> 00:01:28,880
button to

00:01:25,680 --> 00:01:30,880
top we have a environmental host which

00:01:28,880 --> 00:01:33,040
contain an operating system and the

00:01:30,880 --> 00:01:35,200
hypervisor

00:01:33,040 --> 00:01:37,040
in the context of each virtual machines

00:01:35,200 --> 00:01:39,200
we have the device model which is

00:01:37,040 --> 00:01:42,320
created by the virtual machine monitor

00:01:39,200 --> 00:01:44,399
which could be qui or firecracker and

00:01:42,320 --> 00:01:45,280
the microservice run as a user

00:01:44,399 --> 00:01:49,280
application

00:01:45,280 --> 00:01:49,280
on top of a general proposed os

00:01:50,640 --> 00:01:54,720
let's see what are the features that a

00:01:52,799 --> 00:01:57,280
general propose os

00:01:54,720 --> 00:01:59,200
propos propose os provides generally

00:01:57,280 --> 00:01:59,920
speaking operating systems has a

00:01:59,200 --> 00:02:03,360
scheduler

00:01:59,920 --> 00:02:05,280
file system networking and some drivers

00:02:03,360 --> 00:02:06,479
there is a separation between user and

00:02:05,280 --> 00:02:09,360
current space

00:02:06,479 --> 00:02:11,440
and the microservices executes as a user

00:02:09,360 --> 00:02:13,440
process with own memory space

00:02:11,440 --> 00:02:16,959
and the communication between user and

00:02:13,440 --> 00:02:19,200
kernel is based on cs goals

00:02:16,959 --> 00:02:21,760
however a general proposed os consumes a

00:02:19,200 --> 00:02:22,080
lot of resources like memory cpu and on

00:02:21,760 --> 00:02:24,959
this

00:02:22,080 --> 00:02:25,360
mesh also the creation and storage of

00:02:24,959 --> 00:02:28,000
this

00:02:25,360 --> 00:02:29,040
sort of vm is complicated for example

00:02:28,000 --> 00:02:31,280
it's a mesh

00:02:29,040 --> 00:02:33,599
deploying different cloud providers

00:02:31,280 --> 00:02:35,200
different drivers should be packed

00:02:33,599 --> 00:02:37,680
the reason is that for example the

00:02:35,200 --> 00:02:39,280
device model for amazon web service

00:02:37,680 --> 00:02:42,480
is not the same that the google cloud

00:02:39,280 --> 00:02:44,319
engine and also the vms stay too long to

00:02:42,480 --> 00:02:47,360
be up and running which makes

00:02:44,319 --> 00:02:50,879
hard to implement continuous integration

00:02:47,360 --> 00:02:52,640
and deployment of microsoft

00:02:50,879 --> 00:02:54,560
so the result of consuming so much

00:02:52,640 --> 00:02:56,480
resources makes

00:02:54,560 --> 00:02:58,000
that we can only host a few virtual

00:02:56,480 --> 00:03:01,200
machines per house

00:02:58,000 --> 00:03:04,239
and in addition the maintenance of these

00:03:01,200 --> 00:03:07,200
vms is high

00:03:04,239 --> 00:03:09,760
so to reduce the complexity of a general

00:03:07,200 --> 00:03:11,840
proposal as for a dedicated task

00:03:09,760 --> 00:03:13,840
as microservice and at the same time

00:03:11,840 --> 00:03:14,959
leverage on the strong insulation that

00:03:13,840 --> 00:03:18,239
virtual machines

00:03:14,959 --> 00:03:20,720
provide some approaches propose

00:03:18,239 --> 00:03:21,519
the use of a unique kernel to host micro

00:03:20,720 --> 00:03:23,680
circuits

00:03:21,519 --> 00:03:25,760
ionic kernel is when you compile the

00:03:23,680 --> 00:03:27,519
kernel with the use of applications

00:03:25,760 --> 00:03:29,200
currently there are different unique

00:03:27,519 --> 00:03:32,480
kernels which are used

00:03:29,200 --> 00:03:37,920
in different scenarios like osva

00:03:32,480 --> 00:03:37,920
mirage os unicraft nano vns etc

00:03:38,000 --> 00:03:42,080
in these approaches the kernel and

00:03:39,840 --> 00:03:44,400
applications share the memory space

00:03:42,080 --> 00:03:45,599
the kernel code and user code are

00:03:44,400 --> 00:03:47,760
combined in the

00:03:45,599 --> 00:03:49,519
single binary and in most of these

00:03:47,760 --> 00:03:50,319
approaches there is no separation

00:03:49,519 --> 00:03:53,840
between

00:03:50,319 --> 00:03:55,439
user space and kernel space no context

00:03:53,840 --> 00:04:01,120
switching no paging

00:03:55,439 --> 00:04:03,040
and the cisco shows calls to kernel code

00:04:01,120 --> 00:04:04,720
however the power of an application

00:04:03,040 --> 00:04:06,640
takes time and effort so

00:04:04,720 --> 00:04:08,560
sometimes the unicorn must be read on

00:04:06,640 --> 00:04:10,560
for each new application that need to be

00:04:08,560 --> 00:04:13,599
ported

00:04:10,560 --> 00:04:15,439
so in this context toro

00:04:13,599 --> 00:04:17,199
is a unique kernel that provides a

00:04:15,439 --> 00:04:20,000
minimalistic api

00:04:17,199 --> 00:04:23,919
to develop microservices i'm going to

00:04:20,000 --> 00:04:23,919
present total in the following slides

00:04:24,080 --> 00:04:28,000
so opto is an application oriented

00:04:26,240 --> 00:04:30,000
kernel which provides

00:04:28,000 --> 00:04:31,280
a minimalistic api to bright

00:04:30,000 --> 00:04:33,680
applications

00:04:31,280 --> 00:04:34,560
the uni kernel is mainly made of five

00:04:33,680 --> 00:04:36,639
models

00:04:34,560 --> 00:04:38,160
so for example the thread unit allows

00:04:36,639 --> 00:04:40,479
the manipulation of thread

00:04:38,160 --> 00:04:41,440
the memory unit allows the allocation of

00:04:40,479 --> 00:04:44,400
memory

00:04:41,440 --> 00:04:46,880
the whole kernel is about 18 kilo lines

00:04:44,400 --> 00:04:49,280
of code

00:04:46,880 --> 00:04:51,840
so to get better performance from kvm

00:04:49,280 --> 00:04:54,560
total focus on virtual your devices

00:04:51,840 --> 00:04:55,680
and the networking support both blocking

00:04:54,560 --> 00:04:59,600
and no blocking

00:04:55,680 --> 00:05:01,199
socket interface so in total the useful

00:04:59,600 --> 00:05:02,160
application and the kernel compile

00:05:01,199 --> 00:05:04,720
together

00:05:02,160 --> 00:05:06,479
and the user application has to

00:05:04,720 --> 00:05:07,520
explicitly define what are the

00:05:06,479 --> 00:05:10,639
components

00:05:07,520 --> 00:05:12,800
that must be included

00:05:10,639 --> 00:05:14,880
to define this the developer must

00:05:12,800 --> 00:05:17,039
specifically specify the unit

00:05:14,880 --> 00:05:19,360
that must be added by using the keyword

00:05:17,039 --> 00:05:19,360
use

00:05:21,199 --> 00:05:26,479
so the resulting elec binary contain

00:05:23,520 --> 00:05:28,560
both the kernel and the application

00:05:26,479 --> 00:05:31,039
this binary is immutable in the sense

00:05:28,560 --> 00:05:34,160
that you can use the same binary

00:05:31,039 --> 00:05:36,800
different hypervisors without modifying

00:05:34,160 --> 00:05:39,840
it thus simplifying the maintenances of

00:05:36,800 --> 00:05:39,840
the microservice

00:05:40,479 --> 00:05:47,120
then we use a script called clothing

00:05:43,680 --> 00:05:50,240
to create vms in different hypervises

00:05:47,120 --> 00:05:52,800
but let's see how much work

00:05:50,240 --> 00:05:54,560
is needed to deploy an appliance like a

00:05:52,800 --> 00:05:58,000
web server by using toro

00:05:54,560 --> 00:05:59,440
and how much work is needed

00:05:58,000 --> 00:06:01,280
to illustrate the amount of work to

00:05:59,440 --> 00:06:03,039
deploy an appliance i mean

00:06:01,280 --> 00:06:05,840
i'm going to use a rainx as a real

00:06:03,039 --> 00:06:08,080
example the web server

00:06:05,840 --> 00:06:10,720
which is a simple micro service that

00:06:08,080 --> 00:06:12,800
serves a file by using http

00:06:10,720 --> 00:06:16,160
this appliance currently uses to host

00:06:12,800 --> 00:06:16,160
the total website

00:06:16,479 --> 00:06:22,560
so in term of code this appliance needs

00:06:20,720 --> 00:06:24,160
to get connection from internet and be

00:06:22,560 --> 00:06:26,800
able to read files

00:06:24,160 --> 00:06:28,160
so it needs to include a network driver

00:06:26,800 --> 00:06:29,840
and a blog driver

00:06:28,160 --> 00:06:32,960
and in addition the appliance needs to

00:06:29,840 --> 00:06:36,160
include a file system like fad or extend

00:06:32,960 --> 00:06:38,319
and also the tcb ips stack

00:06:36,160 --> 00:06:41,199
so the micro service has to be compiled

00:06:38,319 --> 00:06:43,520
with this with this code

00:06:41,199 --> 00:06:45,120
in ter of the device model we need to

00:06:43,520 --> 00:06:47,280
set up the devices that our plan is

00:06:45,120 --> 00:06:49,440
going to use so for example in this case

00:06:47,280 --> 00:06:51,280
the device model must include a bar

00:06:49,440 --> 00:06:55,520
built in network core

00:06:51,280 --> 00:06:55,520
and a built-in block for block devices

00:06:57,039 --> 00:07:03,599
to deploy the appliance two on these

00:07:00,400 --> 00:07:04,319
files are needed first the binary that

00:07:03,599 --> 00:07:06,160
contains

00:07:04,319 --> 00:07:08,800
he could tell the code which is an elf

00:07:06,160 --> 00:07:11,199
by the els 64 binary

00:07:08,800 --> 00:07:14,240
and the files that appliance host

00:07:11,199 --> 00:07:18,639
generally speaking the binary is about

00:07:14,240 --> 00:07:23,120
250 kilobytes but the files could be

00:07:18,639 --> 00:07:23,120
in the order of megabyte or gigabyte

00:07:23,680 --> 00:07:27,440
and finally to provide networking for

00:07:26,560 --> 00:07:30,080
the vm

00:07:27,440 --> 00:07:32,960
we need to set up for example the ip of

00:07:30,080 --> 00:07:35,120
the vn but also the ip of the host

00:07:32,960 --> 00:07:37,039
and in addition to expose the vm to

00:07:35,120 --> 00:07:37,759
internet we have to set up some sort of

00:07:37,039 --> 00:07:40,560
ebay for

00:07:37,759 --> 00:07:43,599
ip forwarding for example so let's

00:07:40,560 --> 00:07:46,879
summarize the main drawbacks

00:07:43,599 --> 00:07:49,919
of this configuration first

00:07:46,879 --> 00:07:53,039
dc mesh consume memory and on this space

00:07:49,919 --> 00:07:56,319
for example each guest has its own image

00:07:53,039 --> 00:07:58,800
this mesh has to be suited in all nodes

00:07:56,319 --> 00:07:59,680
and the use of a tcp stack requires

00:07:58,800 --> 00:08:02,960
configuration

00:07:59,680 --> 00:08:06,000
like bridge and epa parker gas

00:08:02,960 --> 00:08:09,199
guest drivers devices also the use of

00:08:06,000 --> 00:08:11,360
more devices increase the attack surface

00:08:09,199 --> 00:08:13,199
sharing of files between gase and host

00:08:11,360 --> 00:08:15,680
is most of the time hard

00:08:13,199 --> 00:08:18,560
and complicated and relying on a

00:08:15,680 --> 00:08:26,400
specific file system in the guess

00:08:18,560 --> 00:08:29,280
is not good for inmodable image

00:08:26,400 --> 00:08:30,400
so the question was can we do better and

00:08:29,280 --> 00:08:32,640
when i said

00:08:30,400 --> 00:08:34,560
can we do better i mean can we simplify

00:08:32,640 --> 00:08:37,440
the configuration steps

00:08:34,560 --> 00:08:38,399
can we reduce that actual phase can we

00:08:37,440 --> 00:08:41,120
still provide

00:08:38,399 --> 00:08:41,680
a reliable share file system can we

00:08:41,120 --> 00:08:44,720
reduce

00:08:41,680 --> 00:08:48,000
the vm cpu consumption and footprints

00:08:44,720 --> 00:08:50,240
so we propose to title this

00:08:48,000 --> 00:08:52,480
issue by providing a cloud

00:08:50,240 --> 00:08:53,440
infrastructure in which vms are micro

00:08:52,480 --> 00:08:55,680
vms

00:08:53,440 --> 00:08:57,600
networking on file system in the guest

00:08:55,680 --> 00:08:58,160
is implemented by using build i o v

00:08:57,600 --> 00:09:01,040
socket

00:08:58,160 --> 00:09:01,839
and build ifs and a distributed file

00:09:01,040 --> 00:09:05,200
system

00:09:01,839 --> 00:09:06,800
is implemented by using cf

00:09:05,200 --> 00:09:08,880
in the following i'm going to briefly

00:09:06,800 --> 00:09:12,720
present these technologies and explain

00:09:08,880 --> 00:09:12,720
how they were implemented in toronto

00:09:13,440 --> 00:09:19,600
so built ifs and victory of this socket

00:09:16,480 --> 00:09:22,959
are both built-in devices different

00:09:19,600 --> 00:09:25,120
other devices they are in kernel devices

00:09:22,959 --> 00:09:25,600
so they are more performant performance

00:09:25,120 --> 00:09:28,800
than

00:09:25,600 --> 00:09:30,560
emulated devices and i'm not sure about

00:09:28,800 --> 00:09:31,920
built-in b socket but in the case of

00:09:30,560 --> 00:09:35,040
puritan effects it

00:09:31,920 --> 00:09:38,560
is in key emu since

00:09:35,040 --> 00:09:41,680
5.0 in the case

00:09:38,560 --> 00:09:43,760
in the case of micro bn it is a

00:09:41,680 --> 00:09:44,560
minimalistic qma machine which is

00:09:43,760 --> 00:09:47,600
inspired by

00:09:44,560 --> 00:09:49,360
firecracker it provides several benefits

00:09:47,600 --> 00:09:52,720
like reducing device model

00:09:49,360 --> 00:09:56,240
based on virtual improved booting time

00:09:52,720 --> 00:09:58,160
and reduced footprint so let's

00:09:56,240 --> 00:10:00,080
talk about a bit built-in fs and

00:09:58,160 --> 00:10:02,480
built-in b socket in the context of

00:10:00,080 --> 00:10:05,440
storage

00:10:02,480 --> 00:10:07,519
utwfs is a beard io device that allows

00:10:05,440 --> 00:10:08,560
to share a directory between the guest

00:10:07,519 --> 00:10:10,560
and the host

00:10:08,560 --> 00:10:12,000
in the guest site you only need a build

00:10:10,560 --> 00:10:15,440
ifs driver

00:10:12,000 --> 00:10:17,360
the device is supported by micro vm

00:10:15,440 --> 00:10:18,560
machine the only requirement is to

00:10:17,360 --> 00:10:20,240
support

00:10:18,560 --> 00:10:23,200
is that the driver has to support the

00:10:20,240 --> 00:10:25,360
built-in your mmi real transport layer

00:10:23,200 --> 00:10:26,720
in the host site you need a demo name

00:10:25,360 --> 00:10:29,519
and build ifs

00:10:26,720 --> 00:10:30,880
d in which you have to set up what is

00:10:29,519 --> 00:10:33,040
the directory to share

00:10:30,880 --> 00:10:35,279
an attack that is afterward used by the

00:10:33,040 --> 00:10:35,279
guest

00:10:36,800 --> 00:10:40,240
the use of build ifs has several

00:10:39,360 --> 00:10:42,560
benefits

00:10:40,240 --> 00:10:44,720
for example we don't need to base on a

00:10:42,560 --> 00:10:46,240
specific file system this means that the

00:10:44,720 --> 00:10:49,040
binary can be

00:10:46,240 --> 00:10:50,560
immutable the configuration for build

00:10:49,040 --> 00:10:54,000
ifs is minimal

00:10:50,560 --> 00:10:55,519
so you don't need image anymore

00:10:54,000 --> 00:10:58,000
the unique kernel source called an

00:10:55,519 --> 00:10:58,959
architecture can be drastically reduced

00:10:58,000 --> 00:11:01,680
for example

00:10:58,959 --> 00:11:02,800
the virtual file system becomes becomes

00:11:01,680 --> 00:11:07,279
a driver for read

00:11:02,800 --> 00:11:11,519
ifs you can remove buffer cache

00:11:07,279 --> 00:11:11,519
file system driver and block driver for

00:11:12,839 --> 00:11:18,480
example

00:11:14,720 --> 00:11:21,440
in the case of built-in v sockets

00:11:18,480 --> 00:11:23,519
it allows to establish a basic socket

00:11:21,440 --> 00:11:24,320
based communication between the host and

00:11:23,519 --> 00:11:28,079
the guests

00:11:24,320 --> 00:11:31,040
in which each guest has a context id to

00:11:28,079 --> 00:11:31,040
be identified

00:11:32,720 --> 00:11:36,160
so the use of glutamine circuit has

00:11:34,480 --> 00:11:37,839
several benefits like simpler

00:11:36,160 --> 00:11:40,839
configuration on the gas

00:11:37,839 --> 00:11:42,560
no need of tcp stack no need of built-in

00:11:40,839 --> 00:11:44,240
net etc

00:11:42,560 --> 00:11:46,079
in case of you want to expose the

00:11:44,240 --> 00:11:48,399
virtual machine to internet you need

00:11:46,079 --> 00:11:52,480
some sort of proxy to forward

00:11:48,399 --> 00:11:52,480
traffic from internet to the guest

00:11:53,279 --> 00:11:56,720
and the last piece in this architecture

00:11:56,079 --> 00:11:59,760
is the

00:11:56,720 --> 00:12:01,760
shelf file system follow all knows to

00:11:59,760 --> 00:12:04,800
access to a common file system

00:12:01,760 --> 00:12:06,800
we build a cfvfs cluster

00:12:04,800 --> 00:12:08,720
and we use it to provide the binaries of

00:12:06,800 --> 00:12:10,240
the vms and the files

00:12:08,720 --> 00:12:12,079
i'm going to talk a bit about this

00:12:10,240 --> 00:12:15,680
cluster

00:12:12,079 --> 00:12:15,680
and how it have been developed

00:12:16,800 --> 00:12:21,519
so to try this architecture i build a

00:12:19,200 --> 00:12:25,200
three nodes

00:12:21,519 --> 00:12:28,959
cf cluster each node participates

00:12:25,200 --> 00:12:32,480
with 10 gigabytes disk to the cluster

00:12:28,959 --> 00:12:35,120
and i use the public cloud ovh

00:12:32,480 --> 00:12:36,720
each cluster is a true core with 8

00:12:35,120 --> 00:12:40,079
gigabytes of memory

00:12:36,720 --> 00:12:42,959
and the cost of each node is about

00:12:40,079 --> 00:12:42,959
16 euros

00:12:44,800 --> 00:12:48,639
to deploy the virtual machines i

00:12:46,560 --> 00:12:50,880
rendered two cheaper nodes these are

00:12:48,639 --> 00:12:53,200
one core and two shield of memory holes

00:12:50,880 --> 00:12:55,760
that costs about 3 euros per month

00:12:53,200 --> 00:12:57,120
in this machine i mounted the cfs file

00:12:55,760 --> 00:13:00,160
system

00:12:57,120 --> 00:13:03,440
and the cluster has been used to store

00:13:00,160 --> 00:13:07,839
finites for the vns and the files

00:13:03,440 --> 00:13:07,839
that are served by the microservice

00:13:09,360 --> 00:13:13,680
the host client one and client two are

00:13:11,519 --> 00:13:17,120
used to deploy the microservice

00:13:13,680 --> 00:13:20,399
to ethercreations virtual machines and i

00:13:17,120 --> 00:13:21,279
started an open source project on these

00:13:20,399 --> 00:13:24,399
machines

00:13:21,279 --> 00:13:26,560
name it xml wrap which allows to

00:13:24,399 --> 00:13:29,839
automate the launching of vm so for

00:13:26,560 --> 00:13:34,800
example to ease the forwarding of ports

00:13:29,839 --> 00:13:38,000
to launch view fs and so on

00:13:34,800 --> 00:13:41,120
so i have some results about uh

00:13:38,000 --> 00:13:42,639
evaluation of the architecture so the

00:13:41,120 --> 00:13:46,079
binary side which is

00:13:42,639 --> 00:13:51,040
the binary include the kernel

00:13:46,079 --> 00:13:52,560
and the user application has about 235

00:13:51,040 --> 00:13:54,720
kilobytes

00:13:52,560 --> 00:13:56,800
the time to review the microservice is

00:13:54,720 --> 00:13:58,320
about 500 milliseconds which is the

00:13:56,800 --> 00:14:00,959
compilation times

00:13:58,320 --> 00:14:03,839
and which is the time that's going to

00:14:00,959 --> 00:14:06,720
impact the ability to

00:14:03,839 --> 00:14:08,240
do continuous deployment and integration

00:14:06,720 --> 00:14:11,279
of microservice

00:14:08,240 --> 00:14:12,720
and the boot cycle which is turning off

00:14:11,279 --> 00:14:15,040
and on

00:14:12,720 --> 00:14:16,320
and off the microservices about 80

00:14:15,040 --> 00:14:18,399
milliseconds

00:14:16,320 --> 00:14:19,839
and just to have in mind that an echo

00:14:18,399 --> 00:14:24,720
hello world

00:14:19,839 --> 00:14:26,639
takes about two and a half milliseconds

00:14:24,720 --> 00:14:28,880
and other important factor that was

00:14:26,639 --> 00:14:33,040
interesting was the cpu sash

00:14:28,880 --> 00:14:36,320
um in this case the

00:14:33,040 --> 00:14:40,160
um the vm comes here 90 percent of the

00:14:36,320 --> 00:14:41,760
of the cpu when it's answering a request

00:14:40,160 --> 00:14:44,240
and then when it's completely asleep

00:14:41,760 --> 00:14:47,680
means that the the core is

00:14:44,240 --> 00:14:50,639
hold or the bn is hold and it

00:14:47,680 --> 00:14:52,880
is taking about 10 hundred percent of of

00:14:50,639 --> 00:14:56,639
cpu

00:14:52,880 --> 00:14:57,279
and the memory footprint per bn is

00:14:56,639 --> 00:15:00,800
around

00:14:57,279 --> 00:15:01,839
2.9 percent of memory which is about 60

00:15:00,800 --> 00:15:05,199
megabytes

00:15:01,839 --> 00:15:07,360
or 35 bians per host

00:15:05,199 --> 00:15:08,480
in this case i have compiled a key move

00:15:07,360 --> 00:15:11,600
with all the

00:15:08,480 --> 00:15:13,920
configuration enabled and just to have

00:15:11,600 --> 00:15:15,040
in mind that the whole cluster it costs

00:15:13,920 --> 00:15:17,839
about eight

00:15:15,040 --> 00:15:18,399
58 euros months so it makes that you

00:15:17,839 --> 00:15:23,040
spend

00:15:18,399 --> 00:15:27,279
about 85 something euros per month

00:15:23,040 --> 00:15:31,040
per pm and i have also uploaded

00:15:27,279 --> 00:15:32,959
all the scripts and the tutorial to

00:15:31,040 --> 00:15:36,399
create your own cloud based on the

00:15:32,959 --> 00:15:36,399
configuration i just presented

00:15:37,680 --> 00:15:41,839
so in the following i'm going to show a

00:15:40,000 --> 00:15:46,000
video that

00:15:41,839 --> 00:15:48,639
presents the implementation of this

00:15:46,000 --> 00:15:48,639
architecture

00:15:49,839 --> 00:15:54,480
so what we use we see here is first is

00:15:52,639 --> 00:15:57,519
the dashboard of cf

00:15:54,480 --> 00:16:00,480
we can see we have three nodes

00:15:57,519 --> 00:16:02,079
and as i said each one country would

00:16:00,480 --> 00:16:05,600
with 10 gigabytes with me

00:16:02,079 --> 00:16:08,720
would make 30 gigs of total of the

00:16:05,600 --> 00:16:11,680
of the whole cluster then we have xml

00:16:08,720 --> 00:16:12,800
rad which is the tool that's going to we

00:16:11,680 --> 00:16:15,279
are using to

00:16:12,800 --> 00:16:16,959
ease the deployment of the vm so for

00:16:15,279 --> 00:16:18,320
example here we have the two nodes on

00:16:16,959 --> 00:16:21,759
the started web server

00:16:18,320 --> 00:16:24,000
microservice we have some parameters

00:16:21,759 --> 00:16:26,800
like the binary

00:16:24,000 --> 00:16:27,759
and the file system that is shared to

00:16:26,800 --> 00:16:29,440
the host

00:16:27,759 --> 00:16:32,399
and also the forwarding of the port

00:16:29,440 --> 00:16:34,480
between the host and the guest

00:16:32,399 --> 00:16:36,160
and we can also have the output of the

00:16:34,480 --> 00:16:38,399
e-screen if we click on the web socket

00:16:36,160 --> 00:16:41,519
so this is the screen of the

00:16:38,399 --> 00:16:42,079
of the bm and it could be completed by

00:16:41,519 --> 00:16:45,360
using

00:16:42,079 --> 00:16:48,480
headless but in this case i

00:16:45,360 --> 00:16:51,440
just comply with the screen

00:16:48,480 --> 00:16:55,040
and this is the total website and i'm

00:16:51,440 --> 00:16:57,440
going to refresh just to show that

00:16:55,040 --> 00:16:58,800
the viennese antonio is currently

00:16:57,440 --> 00:17:03,279
answering

00:16:58,800 --> 00:17:06,480
and so for example if now i'm refresh

00:17:03,279 --> 00:17:09,360
and we're going to see that the screen

00:17:06,480 --> 00:17:09,360
scroll up

00:17:09,520 --> 00:17:13,439
i'm going to do it again since it's not

00:17:11,839 --> 00:17:16,839
really evident

00:17:13,439 --> 00:17:19,600
you can see that the screen move

00:17:16,839 --> 00:17:22,240
up

00:17:19,600 --> 00:17:23,520
and now i'm going to just get and pick a

00:17:22,240 --> 00:17:27,600
picture and see that is

00:17:23,520 --> 00:17:27,600
quality output in the in the vm

00:17:31,440 --> 00:17:35,440
so yeah well um this is one of the

00:17:34,640 --> 00:17:38,640
challenges

00:17:35,440 --> 00:17:41,840
that i face i'm continually

00:17:38,640 --> 00:17:43,360
facing at the moment uh in order to

00:17:41,840 --> 00:17:45,120
improve the deployment of this

00:17:43,360 --> 00:17:48,799
architecture first

00:17:45,120 --> 00:17:49,280
and i would like to improve the support

00:17:48,799 --> 00:17:51,760
for

00:17:49,280 --> 00:17:52,960
live migration which is not currently

00:17:51,760 --> 00:17:56,559
supported by micro

00:17:52,960 --> 00:18:00,000
micro vm machine also

00:17:56,559 --> 00:18:02,480
i see that we have a sort of bottleneck

00:18:00,000 --> 00:18:03,200
when we have to forward traffic from the

00:18:02,480 --> 00:18:05,440
internet

00:18:03,200 --> 00:18:06,240
to the guests so we have to improve the

00:18:05,440 --> 00:18:10,000
way we do it

00:18:06,240 --> 00:18:13,039
in that case and i think we have

00:18:10,000 --> 00:18:13,679
we can improve the overall performance

00:18:13,039 --> 00:18:16,640
by

00:18:13,679 --> 00:18:18,480
using cello copy when we use built-in fs

00:18:16,640 --> 00:18:21,120
and multi-ob socket this is more

00:18:18,480 --> 00:18:22,480
in the guest site in the drivers in the

00:18:21,120 --> 00:18:26,320
total drivers

00:18:22,480 --> 00:18:28,400
and i think current evaluation of this

00:18:26,320 --> 00:18:31,840
architecture should be improved by

00:18:28,400 --> 00:18:32,720
comparing with approaches like unicorns

00:18:31,840 --> 00:18:36,160
containers

00:18:32,720 --> 00:18:39,200
and also general proposed os

00:18:36,160 --> 00:18:43,840
and all these challenge remain

00:18:39,200 --> 00:18:43,840
as a future word

00:18:45,679 --> 00:18:50,640
so well i finished the presentation so

00:18:48,640 --> 00:18:57,840
if you have any question

00:18:50,640 --> 00:18:57,840
feel free to ask thank you very much

00:19:00,559 --> 00:19:02,640

YouTube URL: https://www.youtube.com/watch?v=fLsNjMduQmA


