Title: Extremely Fast and Efficient NFV with Unikraft - Sharan Santhanam, NEC Laboratories Europe GmbH
Publication date: 2020-11-10
Playlist: KVM Forum Europe 2020
Description: 
	Extremely Fast and Efficient NFV with Unikraft - Sharan Santhanam, NEC Laboratories Europe GmbH
Captions: 
	00:00:06,160 --> 00:00:09,920
good morning

00:00:07,440 --> 00:00:10,480
i am sharon sanfana today i am here to

00:00:09,920 --> 00:00:13,120
present

00:00:10,480 --> 00:00:16,080
our work on building extremely fast and

00:00:13,120 --> 00:00:18,080
efficient industries with unica

00:00:16,080 --> 00:00:19,520
before we start on this topic let me

00:00:18,080 --> 00:00:21,680
introduce myself

00:00:19,520 --> 00:00:23,039
i work as a software specialist at nec

00:00:21,680 --> 00:00:24,960
laboratories europe

00:00:23,039 --> 00:00:26,480
and i am part of a team of eight

00:00:24,960 --> 00:00:28,000
researchers

00:00:26,480 --> 00:00:31,279
who are working as a part of the systems

00:00:28,000 --> 00:00:33,600
group in our lab one of the projects

00:00:31,279 --> 00:00:35,600
within our group is unicraft and this

00:00:33,600 --> 00:00:39,040
work contributes towards the port of

00:00:35,600 --> 00:00:41,360
tpdk on top of your craft message

00:00:39,040 --> 00:00:43,360
so for today's talk we have structured

00:00:41,360 --> 00:00:44,399
it in such a way that we begin to

00:00:43,360 --> 00:00:46,800
discuss

00:00:44,399 --> 00:00:48,079
what is existing out there then we move

00:00:46,800 --> 00:00:50,320
on to

00:00:48,079 --> 00:00:51,199
introduce unicraft the motivation behind

00:00:50,320 --> 00:00:54,079
unicraft

00:00:51,199 --> 00:00:55,440
and how everything is structured within

00:00:54,079 --> 00:00:58,000
your aircraft

00:00:55,440 --> 00:01:00,079
then we talk about how to integrate dpdk

00:00:58,000 --> 00:01:02,160
libraries on top of unicraft

00:01:00,079 --> 00:01:04,159
then we speak about the functionalities

00:01:02,160 --> 00:01:05,920
which unicraft should provide to support

00:01:04,159 --> 00:01:07,840
these dpdk libraries

00:01:05,920 --> 00:01:09,280
and we make a performance evaluation

00:01:07,840 --> 00:01:11,680
between a linux vm

00:01:09,280 --> 00:01:13,280
as well as a unigraphed image and we

00:01:11,680 --> 00:01:15,600
discuss about the synergies of the two

00:01:13,280 --> 00:01:18,640
projects unicraft and tpdk

00:01:15,600 --> 00:01:20,400
and how it fits into this ecosystem

00:01:18,640 --> 00:01:23,200
message

00:01:20,400 --> 00:01:24,640
so when we began uh what we had in our

00:01:23,200 --> 00:01:27,040
mind is something like the

00:01:24,640 --> 00:01:28,640
diagram in the slide where we have a

00:01:27,040 --> 00:01:30,960
guest operating system

00:01:28,640 --> 00:01:32,400
and we have kvm as a hypervisor and the

00:01:30,960 --> 00:01:34,720
host and the guest

00:01:32,400 --> 00:01:36,479
interacting on one another through a

00:01:34,720 --> 00:01:37,200
para virtualized framework like first

00:01:36,479 --> 00:01:39,840
item

00:01:37,200 --> 00:01:41,119
and then this part and then this uh

00:01:39,840 --> 00:01:43,200
framework was further

00:01:41,119 --> 00:01:44,399
uh optimized with something called

00:01:43,200 --> 00:01:47,439
v-hostnet

00:01:44,399 --> 00:01:48,880
to to further uh improve the performance

00:01:47,439 --> 00:01:51,439
of this communication channel

00:01:48,880 --> 00:01:52,159
and dpdk came along with his own b host

00:01:51,439 --> 00:01:53,600
user

00:01:52,159 --> 00:01:56,159
which further enhances this

00:01:53,600 --> 00:01:58,159
communication in our bottle exists

00:01:56,159 --> 00:02:00,079
but one part of this picture which has

00:01:58,159 --> 00:02:02,880
been left untouched

00:02:00,079 --> 00:02:03,360
is the guest operating system message we

00:02:02,880 --> 00:02:04,640
believe

00:02:03,360 --> 00:02:06,079
we can do better with the guest

00:02:04,640 --> 00:02:08,560
operating system we believe we can

00:02:06,079 --> 00:02:10,800
specialize the guest operating system

00:02:08,560 --> 00:02:12,959
where is wherein we take in only the

00:02:10,800 --> 00:02:14,720
required components needed by the

00:02:12,959 --> 00:02:17,760
application into the guest operating

00:02:14,720 --> 00:02:20,400
system thereby we optimize it for

00:02:17,760 --> 00:02:21,440
something like a boot time or image size

00:02:20,400 --> 00:02:24,080
or even memory

00:02:21,440 --> 00:02:25,440
memory requirements for an application

00:02:24,080 --> 00:02:27,520
and

00:02:25,440 --> 00:02:29,120
if we are only running specific

00:02:27,520 --> 00:02:31,120
application within against operating

00:02:29,120 --> 00:02:33,519
system we could also reconsider the

00:02:31,120 --> 00:02:34,879
necessity for having kernel and user

00:02:33,519 --> 00:02:36,879
space separation within the guest

00:02:34,879 --> 00:02:39,680
operating system message

00:02:36,879 --> 00:02:41,200
thus if you focus on a particular use

00:02:39,680 --> 00:02:44,400
case in mind

00:02:41,200 --> 00:02:47,840
then unicorn seems to be a good fit

00:02:44,400 --> 00:02:49,680
for that specific image

00:02:47,840 --> 00:02:51,760
so if we were to make a comparison

00:02:49,680 --> 00:02:54,239
between a virtual machine image

00:02:51,760 --> 00:02:56,400
and that of a unicorn image it looks

00:02:54,239 --> 00:02:58,239
like something like something like this

00:02:56,400 --> 00:03:00,000
uh and in a virtual machine image you

00:02:58,239 --> 00:03:02,159
have a number of applications

00:03:00,000 --> 00:03:04,159
and we have a large number of library

00:03:02,159 --> 00:03:07,040
pool and we have

00:03:04,159 --> 00:03:07,840
a single monolithic kernel from an

00:03:07,040 --> 00:03:10,720
application

00:03:07,840 --> 00:03:12,879
an application needs only some subset of

00:03:10,720 --> 00:03:15,519
these libraries from the library pool

00:03:12,879 --> 00:03:16,560
and some specific kernel components

00:03:15,519 --> 00:03:19,760
contrast this

00:03:16,560 --> 00:03:20,319
with that of a unicorn image a unicorn

00:03:19,760 --> 00:03:23,120
image

00:03:20,319 --> 00:03:25,040
is built with one purpose in mind

00:03:23,120 --> 00:03:26,959
thereby you only need

00:03:25,040 --> 00:03:28,080
an image which has the specific

00:03:26,959 --> 00:03:30,000
libraries

00:03:28,080 --> 00:03:31,760
and specific kernel components with the

00:03:30,000 --> 00:03:34,720
application as such

00:03:31,760 --> 00:03:36,640
just to summarize a unikernel image what

00:03:34,720 --> 00:03:37,360
a unikernel image is a purpose built

00:03:36,640 --> 00:03:40,080
image

00:03:37,360 --> 00:03:42,239
with a thin layer of the kernel embedded

00:03:40,080 --> 00:03:45,519
into the application message

00:03:42,239 --> 00:03:47,440
thereby the application as such has to

00:03:45,519 --> 00:03:49,120
ask to select which are all the

00:03:47,440 --> 00:03:50,560
libraries it needs

00:03:49,120 --> 00:03:52,159
and which are all the kernel components

00:03:50,560 --> 00:03:55,120
it needs

00:03:52,159 --> 00:03:57,519
since the kernel is embedded into the

00:03:55,120 --> 00:03:59,840
application image as such

00:03:57,519 --> 00:04:02,000
the necessity for kernel and user space

00:03:59,840 --> 00:04:04,480
separation is no longer needed

00:04:02,000 --> 00:04:06,080
and whatever was a syscall in a virtual

00:04:04,480 --> 00:04:09,120
machine image now becomes a function

00:04:06,080 --> 00:04:11,120
called within the unicode images

00:04:09,120 --> 00:04:13,360
and since we are picking and choosing

00:04:11,120 --> 00:04:16,239
components needed by the application

00:04:13,360 --> 00:04:17,840
you can specialize the entire software

00:04:16,239 --> 00:04:19,280
stack right from the kernel

00:04:17,840 --> 00:04:21,519
to the libraries to the application

00:04:19,280 --> 00:04:23,520
message where do we realize the

00:04:21,519 --> 00:04:25,440
potential of a unicode

00:04:23,520 --> 00:04:27,280
we can realize it in terms of faster

00:04:25,440 --> 00:04:29,199
boot times because it needs only a few

00:04:27,280 --> 00:04:31,120
milliseconds to boot a unique color

00:04:29,199 --> 00:04:33,600
whereas it takes few seconds

00:04:31,120 --> 00:04:35,199
for a virtual machine image just lower

00:04:33,600 --> 00:04:37,120
memory footprints for example

00:04:35,199 --> 00:04:38,400
a uni kernel needs only a few megabytes

00:04:37,120 --> 00:04:41,280
in size whereas

00:04:38,400 --> 00:04:42,639
a typical virtual machine needs few few

00:04:41,280 --> 00:04:44,560
hundred megabytes or

00:04:42,639 --> 00:04:46,240
a few kilo few gigabytes in size of

00:04:44,560 --> 00:04:49,040
memory

00:04:46,240 --> 00:04:49,840
and also it has a higher deployment

00:04:49,040 --> 00:04:53,199
density so it's

00:04:49,840 --> 00:04:55,199
easier to pack a lot of unicorns and

00:04:53,199 --> 00:04:56,720
its performance is comparable to that of

00:04:55,199 --> 00:04:59,840
a regular

00:04:56,720 --> 00:05:01,280
virtual machine image and also since we

00:04:59,840 --> 00:05:03,280
are only making what is

00:05:01,280 --> 00:05:04,479
necessary for an application into the

00:05:03,280 --> 00:05:06,000
final image

00:05:04,479 --> 00:05:09,280
it has a reduced attack surface because

00:05:06,000 --> 00:05:11,840
it contains what an application needs

00:05:09,280 --> 00:05:13,199
and also since the since it has only

00:05:11,840 --> 00:05:16,160
those necessary components

00:05:13,199 --> 00:05:18,800
it is as a smaller trusted computing

00:05:16,160 --> 00:05:18,800
base as such

00:05:18,880 --> 00:05:22,960
so a unicorn looks quite promising right

00:05:21,600 --> 00:05:25,440
it has good performance

00:05:22,960 --> 00:05:27,440
it has quite a nice isolation features

00:05:25,440 --> 00:05:30,560
instantiation time and image size

00:05:27,440 --> 00:05:32,960
but why the question is why has why

00:05:30,560 --> 00:05:35,199
hasn't it been adopted more often

00:05:32,960 --> 00:05:37,039
there are a number of reasons for it uh

00:05:35,199 --> 00:05:39,039
building a unicorn is quite tedious it

00:05:37,039 --> 00:05:40,080
sinks a lot of development cycles to get

00:05:39,039 --> 00:05:42,880
it right

00:05:40,080 --> 00:05:44,320
and since you are doing it for each of

00:05:42,880 --> 00:05:45,600
the specific application you keep

00:05:44,320 --> 00:05:47,680
repeating the same process

00:05:45,600 --> 00:05:49,360
again and again and it becomes a bit

00:05:47,680 --> 00:05:51,919
tedious as such

00:05:49,360 --> 00:05:52,400
and the other part is specialization is

00:05:51,919 --> 00:05:55,680
quite

00:05:52,400 --> 00:05:57,680
hard to build as such because

00:05:55,680 --> 00:06:00,319
uh when you are specializing you need a

00:05:57,680 --> 00:06:02,560
way to establish dependencies

00:06:00,319 --> 00:06:03,759
between the different components in the

00:06:02,560 --> 00:06:05,600
library pool and the different

00:06:03,759 --> 00:06:07,919
components in the kernel

00:06:05,600 --> 00:06:08,960
and the kernel and this and these

00:06:07,919 --> 00:06:11,680
components

00:06:08,960 --> 00:06:12,319
need to have a well-defined interface as

00:06:11,680 --> 00:06:14,400
such

00:06:12,319 --> 00:06:17,120
so bringing up this interface definition

00:06:14,400 --> 00:06:20,160
is also quite a difficult task

00:06:17,120 --> 00:06:21,039
also since you want to run off the shelf

00:06:20,160 --> 00:06:23,440
application

00:06:21,039 --> 00:06:25,280
on top of these libraries you need to

00:06:23,440 --> 00:06:26,720
make sure that you stick to a standard

00:06:25,280 --> 00:06:28,720
interface so these off-the-shelf

00:06:26,720 --> 00:06:31,280
applications can run on your

00:06:28,720 --> 00:06:35,199
on your library tool and and on your

00:06:31,280 --> 00:06:37,759
kernel components as such

00:06:35,199 --> 00:06:38,880
so with this we decided to come up with

00:06:37,759 --> 00:06:41,440
a tool

00:06:38,880 --> 00:06:43,440
where it makes it easier to build

00:06:41,440 --> 00:06:46,080
unicorns as such

00:06:43,440 --> 00:06:47,680
so with that in mind we had these common

00:06:46,080 --> 00:06:50,560
objectives in mind

00:06:47,680 --> 00:06:52,240
we wanted to make sure most of these

00:06:50,560 --> 00:06:53,919
components were reusable

00:06:52,240 --> 00:06:56,080
so we don't have to throw away any

00:06:53,919 --> 00:06:57,039
effort taken to build a specific

00:06:56,080 --> 00:06:59,680
application message

00:06:57,039 --> 00:07:01,280
so we wanted to build as much minimal

00:06:59,680 --> 00:07:04,000
basic blocks needed

00:07:01,280 --> 00:07:05,759
to build off we we came up with a lot of

00:07:04,000 --> 00:07:08,400
basic blocks so that we can support a

00:07:05,759 --> 00:07:10,319
wide range of use cases such as

00:07:08,400 --> 00:07:12,160
and also we needed to make sure that we

00:07:10,319 --> 00:07:16,000
have necessary tools

00:07:12,160 --> 00:07:18,000
to make sure we can uh establish these

00:07:16,000 --> 00:07:19,919
links between the different libraries

00:07:18,000 --> 00:07:23,440
and and the components

00:07:19,919 --> 00:07:26,880
and also we needed to make sure that uh

00:07:23,440 --> 00:07:30,639
the generic components or generic

00:07:26,880 --> 00:07:32,639
uh components as separated from specific

00:07:30,639 --> 00:07:34,080
uh platform specific or architecture

00:07:32,639 --> 00:07:36,639
specific components

00:07:34,080 --> 00:07:37,919
so that you can use those generic

00:07:36,639 --> 00:07:39,280
components across the different

00:07:37,919 --> 00:07:40,880
platforms

00:07:39,280 --> 00:07:42,400
and we wanted to support a wide number

00:07:40,880 --> 00:07:44,080
of hypervisors as well as

00:07:42,400 --> 00:07:45,840
archite as far as architectures are

00:07:44,080 --> 00:07:47,520
concerned

00:07:45,840 --> 00:07:49,919
so with this in mind we came up with a

00:07:47,520 --> 00:07:52,479
tool called unicraft where

00:07:49,919 --> 00:07:53,680
everything is a micro library or library

00:07:52,479 --> 00:07:57,280
in itself

00:07:53,680 --> 00:07:59,840
and the two prominent components in

00:07:57,280 --> 00:08:00,319
the entire ecosystem are the library

00:07:59,840 --> 00:08:03,759
pools

00:08:00,319 --> 00:08:04,160
and the build tools with the library

00:08:03,759 --> 00:08:06,400
pool

00:08:04,160 --> 00:08:07,280
what what you can what you can do is you

00:08:06,400 --> 00:08:10,080
can enable us

00:08:07,280 --> 00:08:12,160
disable a specific library pool and the

00:08:10,080 --> 00:08:14,720
build system provides you the necessary

00:08:12,160 --> 00:08:16,479
necessary convenience to do that and

00:08:14,720 --> 00:08:18,400
also you can establish a dependency

00:08:16,479 --> 00:08:20,639
between one library to another or one

00:08:18,400 --> 00:08:23,759
library and a kernel component

00:08:20,639 --> 00:08:24,240
and this library pool also includes the

00:08:23,759 --> 00:08:27,840
os

00:08:24,240 --> 00:08:27,840
components which are decomposed

00:08:28,000 --> 00:08:33,760
so how does it affect so

00:08:31,120 --> 00:08:36,479
and also unicraft is open source which

00:08:33,760 --> 00:08:38,560
is bst licensed

00:08:36,479 --> 00:08:40,640
so how does it take to what does it take

00:08:38,560 --> 00:08:41,039
to build an application with unicraft

00:08:40,640 --> 00:08:42,719
right

00:08:41,039 --> 00:08:44,800
let's take an example and then let's run

00:08:42,719 --> 00:08:45,279
through it so if we take an application

00:08:44,800 --> 00:08:47,440
like an

00:08:45,279 --> 00:08:49,760
uh typical dpdk application in l2

00:08:47,440 --> 00:08:51,040
forward we needed to select which are

00:08:49,760 --> 00:08:53,279
all the libraries

00:08:51,040 --> 00:08:55,200
which it needs to which which it needs

00:08:53,279 --> 00:08:57,680
to select those libraries

00:08:55,200 --> 00:08:58,240
these libraries also includes something

00:08:57,680 --> 00:09:00,080
specific

00:08:58,240 --> 00:09:02,560
like kernel components also for example

00:09:00,080 --> 00:09:03,760
a net dev provides you a net device

00:09:02,560 --> 00:09:06,000
interface

00:09:03,760 --> 00:09:08,080
so you need that in order to support an

00:09:06,000 --> 00:09:10,880
l2 forward application message

00:09:08,080 --> 00:09:12,160
and then uh unicraft provides a

00:09:10,880 --> 00:09:14,480
different set of

00:09:12,160 --> 00:09:16,880
platform architectures which it runs on

00:09:14,480 --> 00:09:18,880
so those specific libraries which are

00:09:16,880 --> 00:09:20,480
specific to a specific platform needs to

00:09:18,880 --> 00:09:22,640
be selected

00:09:20,480 --> 00:09:24,240
and also the architecture-specific code

00:09:22,640 --> 00:09:26,399
and once this is selected

00:09:24,240 --> 00:09:27,440
the unigraph build system message bakes

00:09:26,399 --> 00:09:29,440
your final image

00:09:27,440 --> 00:09:31,760
together and you have your final

00:09:29,440 --> 00:09:36,480
executable image to run on a specific

00:09:31,760 --> 00:09:40,160
platform so when we started uh

00:09:36,480 --> 00:09:41,440
our work on uh dpdk this was the mental

00:09:40,160 --> 00:09:44,640
image we had

00:09:41,440 --> 00:09:47,360
to port a dpdk image to unicraft message

00:09:44,640 --> 00:09:48,880
where we have an dpdk application and we

00:09:47,360 --> 00:09:52,160
have something like a

00:09:48,880 --> 00:09:55,440
lib uk dpdk which provides the

00:09:52,160 --> 00:09:57,600
unicraft functionality to a to a

00:09:55,440 --> 00:09:58,640
dpdk application and it interacts with

00:09:57,600 --> 00:10:02,080
the internal

00:09:58,640 --> 00:10:02,080
unicraft libraries

00:10:02,320 --> 00:10:08,720
but uh we also had

00:10:05,440 --> 00:10:10,880
uh some design considerations into uh

00:10:08,720 --> 00:10:12,720
account when we came up when we had this

00:10:10,880 --> 00:10:15,760
mental image also

00:10:12,720 --> 00:10:17,760
one of the advantages of the dpdk

00:10:15,760 --> 00:10:20,880
library is its modularity

00:10:17,760 --> 00:10:22,560
and the advan and also the benefit of

00:10:20,880 --> 00:10:24,880
unicraft is its modularity

00:10:22,560 --> 00:10:26,800
so we wanted to retain as much

00:10:24,880 --> 00:10:28,800
modularity as possible

00:10:26,800 --> 00:10:31,040
so to do that we needed to make sure

00:10:28,800 --> 00:10:32,959
that the build system of unicraft can

00:10:31,040 --> 00:10:36,399
understand the build system of

00:10:32,959 --> 00:10:40,079
dpdk thereby it can use

00:10:36,399 --> 00:10:42,640
its modular modular libraries as such

00:10:40,079 --> 00:10:45,120
and we wanted to find out where are all

00:10:42,640 --> 00:10:46,640
the possible cases where we can optimize

00:10:45,120 --> 00:10:49,600
the guest operating system

00:10:46,640 --> 00:10:50,959
that way you can simplify a lot of

00:10:49,600 --> 00:10:53,200
simplify a lot of

00:10:50,959 --> 00:10:54,320
operations for a dpdk application

00:10:53,200 --> 00:10:56,480
message

00:10:54,320 --> 00:10:58,480
and also the the final constraint which

00:10:56,480 --> 00:11:01,760
is for quoting any libraries

00:10:58,480 --> 00:11:03,519
we wanted to minimize as many

00:11:01,760 --> 00:11:06,480
minimize the changes within the upstream

00:11:03,519 --> 00:11:06,480
code within dpdk

00:11:07,200 --> 00:11:11,360
so to make sure these build system

00:11:09,920 --> 00:11:14,079
compatibilities are match

00:11:11,360 --> 00:11:15,519
we first compare and contrast the two

00:11:14,079 --> 00:11:18,079
build systems as such

00:11:15,519 --> 00:11:18,720
unicraft build system is k config based

00:11:18,079 --> 00:11:22,079
whereas

00:11:18,720 --> 00:11:24,959
a dpdk build system has some

00:11:22,079 --> 00:11:26,000
auto auto config generation happening

00:11:24,959 --> 00:11:27,839
and also

00:11:26,000 --> 00:11:29,600
a unicraft build system has some

00:11:27,839 --> 00:11:32,959
specific library name

00:11:29,600 --> 00:11:34,480
variable naming convention whereas dpdk

00:11:32,959 --> 00:11:36,399
also has a similar

00:11:34,480 --> 00:11:38,959
uh naming convention which needs to be

00:11:36,399 --> 00:11:41,040
translated from one to another

00:11:38,959 --> 00:11:42,320
and and also it had something called

00:11:41,040 --> 00:11:45,600
export sims when

00:11:42,320 --> 00:11:47,519
dp in unicraft which tries to hide

00:11:45,600 --> 00:11:48,880
uh unnecessary functionalities from a

00:11:47,519 --> 00:11:51,680
library to uh

00:11:48,880 --> 00:11:55,279
to other libraries as such similarly uh

00:11:51,680 --> 00:11:55,279
dpdk had a version map

00:11:55,600 --> 00:12:00,560
so in order to address these differences

00:11:58,959 --> 00:12:02,880
we came up with a solution

00:12:00,560 --> 00:12:04,639
using a typical unigraph approach which

00:12:02,880 --> 00:12:06,320
is to build a library around it

00:12:04,639 --> 00:12:07,920
so we came up with this library called

00:12:06,320 --> 00:12:11,200
dpdk build library

00:12:07,920 --> 00:12:13,760
what it does is it processes

00:12:11,200 --> 00:12:15,600
the make files of dpdk and translate it

00:12:13,760 --> 00:12:17,360
to the make files understandable to

00:12:15,600 --> 00:12:20,160
unicraft as such

00:12:17,360 --> 00:12:22,880
the advantage of doing it is we can add

00:12:20,160 --> 00:12:24,000
a dpdk library as such to unicraft and

00:12:22,880 --> 00:12:26,240
unicraft can then

00:12:24,000 --> 00:12:28,160
translate all its all its necessary

00:12:26,240 --> 00:12:30,639
dependencies to a unicraft build system

00:12:28,160 --> 00:12:33,760
understandable make file message

00:12:30,639 --> 00:12:35,600
thereby what advantage we gained is we

00:12:33,760 --> 00:12:37,440
were forward compatible right

00:12:35,600 --> 00:12:39,680
so as long as there was no change build

00:12:37,440 --> 00:12:42,320
system change in dpdk as such

00:12:39,680 --> 00:12:43,200
we can adapt all its libraries necessary

00:12:42,320 --> 00:12:46,399
to unicraft

00:12:43,200 --> 00:12:50,399
without without any further changes

00:12:46,399 --> 00:12:52,000
anywhere else and also this library

00:12:50,399 --> 00:12:54,399
contained if you have any specific

00:12:52,000 --> 00:12:57,519
configurations within dpdk this library

00:12:54,399 --> 00:12:59,839
contain those configurations also

00:12:57,519 --> 00:13:01,839
so with that in mind we came up with

00:12:59,839 --> 00:13:04,560
this sort of an architecture diagram

00:13:01,839 --> 00:13:05,279
or a building block diagram where we

00:13:04,560 --> 00:13:08,800
retain

00:13:05,279 --> 00:13:11,200
as much as uh the as much as the

00:13:08,800 --> 00:13:12,000
uh dpdk libraries are considered for

00:13:11,200 --> 00:13:15,120
example

00:13:12,000 --> 00:13:18,639
this rte eth div or m

00:13:15,120 --> 00:13:21,839
m um the memory cool m pools or m buffs

00:13:18,639 --> 00:13:24,560
were were not changed one bit in

00:13:21,839 --> 00:13:26,639
within unicorn whereas for each for the

00:13:24,560 --> 00:13:29,279
abstraction layer we needed to add

00:13:26,639 --> 00:13:30,639
some specific unica specific code which

00:13:29,279 --> 00:13:32,240
we'll talk about later

00:13:30,639 --> 00:13:34,720
and apart from that there are two

00:13:32,240 --> 00:13:37,360
libraries which are of consequence here

00:13:34,720 --> 00:13:38,240
which are the uk ring and the uk pmd

00:13:37,360 --> 00:13:39,839
libraries

00:13:38,240 --> 00:13:42,639
we will talk about these libraries

00:13:39,839 --> 00:13:42,639
further down the top

00:13:43,839 --> 00:13:49,920
so then uh the next part of

00:13:47,440 --> 00:13:51,920
our discussion was how to specialize the

00:13:49,920 --> 00:13:55,040
guest operating system message

00:13:51,920 --> 00:13:58,079
we we looked at three uh three parts

00:13:55,040 --> 00:14:00,320
where we could uh optimize

00:13:58,079 --> 00:14:02,000
on where you could optimize the unicraft

00:14:00,320 --> 00:14:05,120
guest operating system message

00:14:02,000 --> 00:14:06,880
one is the memory management system the

00:14:05,120 --> 00:14:09,920
second is a device management system

00:14:06,880 --> 00:14:11,760
and third is the scheduling part in

00:14:09,920 --> 00:14:13,440
terms of memory management system what

00:14:11,760 --> 00:14:16,880
unicraft provide

00:14:13,440 --> 00:14:19,920
was a static memory image

00:14:16,880 --> 00:14:22,079
where we where we have huge pages of two

00:14:19,920 --> 00:14:24,800
gigabytes mapped

00:14:22,079 --> 00:14:26,320
into the first one gigabit of the adder

00:14:24,800 --> 00:14:28,959
space

00:14:26,320 --> 00:14:30,720
so thereby we only support one gigabit

00:14:28,959 --> 00:14:32,320
of memory and

00:14:30,720 --> 00:14:33,760
and thereby we have a one to one

00:14:32,320 --> 00:14:36,160
translation between a pa

00:14:33,760 --> 00:14:37,760
and va within a physical address to a

00:14:36,160 --> 00:14:41,199
virtual address within that of a

00:14:37,760 --> 00:14:44,000
unique analysis and

00:14:41,199 --> 00:14:44,800
from an application perspective an

00:14:44,000 --> 00:14:48,800
application

00:14:44,800 --> 00:14:51,440
can specify a reserve and memory range

00:14:48,800 --> 00:14:52,000
from the unicraft uni kernel thereby you

00:14:51,440 --> 00:14:53,920
can

00:14:52,000 --> 00:14:55,519
make sure that this is specific to you

00:14:53,920 --> 00:14:57,120
can resolve this memory region

00:14:55,519 --> 00:14:59,040
and you can take this memory region and

00:14:57,120 --> 00:15:02,160
use it for your memory buffers

00:14:59,040 --> 00:15:03,360
already and also it is possible to

00:15:02,160 --> 00:15:05,760
implement

00:15:03,360 --> 00:15:06,480
multiple allocators to understand which

00:15:05,760 --> 00:15:09,279
allocator

00:15:06,480 --> 00:15:13,760
is best suited for your for your

00:15:09,279 --> 00:15:17,600
specific application message

00:15:13,760 --> 00:15:21,279
in terms of the device management itself

00:15:17,600 --> 00:15:23,199
what unicraft provides you is unicraft

00:15:21,279 --> 00:15:24,720
just probes the devices and lets the

00:15:23,199 --> 00:15:26,160
application take over the device

00:15:24,720 --> 00:15:28,000
controller altogether

00:15:26,160 --> 00:15:30,160
so unicraft identifies which are all the

00:15:28,000 --> 00:15:31,279
devices necessary for an application

00:15:30,160 --> 00:15:33,199
and just hands it over to the

00:15:31,279 --> 00:15:34,079
application and the application it's up

00:15:33,199 --> 00:15:37,440
to the application

00:15:34,079 --> 00:15:37,440
how to handle these devices

00:15:37,519 --> 00:15:41,120
you don't need any any additional file

00:15:40,079 --> 00:15:45,600
system or

00:15:41,120 --> 00:15:45,600
anything else to handle these devices

00:15:46,720 --> 00:15:53,199
and finally for scheduling message

00:15:50,079 --> 00:15:56,079
unicraft gives you the ability

00:15:53,199 --> 00:15:57,440
to make sure that you can run an

00:15:56,079 --> 00:16:01,120
application an application

00:15:57,440 --> 00:16:04,160
can hawk the cpu cycle

00:16:01,120 --> 00:16:06,160
until it can yield to another uh

00:16:04,160 --> 00:16:08,000
to another thread so unicaf uses a

00:16:06,160 --> 00:16:10,639
cooperative scheduler thereby it runs

00:16:08,000 --> 00:16:11,440
at a an application can run a task

00:16:10,639 --> 00:16:14,399
without

00:16:11,440 --> 00:16:15,600
minimal interference from the uh unique

00:16:14,399 --> 00:16:18,880
kernel as such

00:16:15,600 --> 00:16:19,839
and also if if it is possible if if

00:16:18,880 --> 00:16:21,680
necessary

00:16:19,839 --> 00:16:23,120
we can also completely do away with the

00:16:21,680 --> 00:16:27,279
scheduler and

00:16:23,120 --> 00:16:27,600
run uh run the entire application within

00:16:27,279 --> 00:16:29,680
a

00:16:27,600 --> 00:16:30,800
full polling mode where everything is

00:16:29,680 --> 00:16:32,079
even driven

00:16:30,800 --> 00:16:37,680
when everything is even driven or

00:16:32,079 --> 00:16:41,279
interrupt or name interrupting

00:16:37,680 --> 00:16:44,240
so next what is needed from unicraft to

00:16:41,279 --> 00:16:48,720
support a dpdk library session

00:16:44,240 --> 00:16:52,000
so we compare and contrast how a typical

00:16:48,720 --> 00:16:53,600
data flow works with between a unicraft

00:16:52,000 --> 00:16:55,600
library and dpdk library

00:16:53,600 --> 00:16:56,800
so on the left you have the dpdk

00:16:55,600 --> 00:16:58,079
workflow and on the right you have the

00:16:56,800 --> 00:17:00,480
unicraft workflow

00:16:58,079 --> 00:17:01,199
where you have an application wanting to

00:17:00,480 --> 00:17:04,240
send it

00:17:01,199 --> 00:17:08,240
calls the rtethd

00:17:04,240 --> 00:17:11,199
burst in uh dpdk and uk netf

00:17:08,240 --> 00:17:12,160
burst and and then it calls the what are

00:17:11,199 --> 00:17:15,919
your drivers to

00:17:12,160 --> 00:17:19,839
send out the data out so you need um

00:17:15,919 --> 00:17:23,199
and also here uh dpdk

00:17:19,839 --> 00:17:25,600
libraries handle m buffs whereas uh

00:17:23,199 --> 00:17:26,240
unicraft libraries handle net buffs

00:17:25,600 --> 00:17:27,600
sassage

00:17:26,240 --> 00:17:29,440
so there is a difference in data

00:17:27,600 --> 00:17:32,440
structure between the two libraries

00:17:29,440 --> 00:17:35,479
so we need a way to have

00:17:32,440 --> 00:17:35,479
[Music]

00:17:36,960 --> 00:17:42,160
a similar diagram for the rx part of it

00:17:39,280 --> 00:17:44,000
i'll skip this part right now

00:17:42,160 --> 00:17:45,280
so what is what is the difference

00:17:44,000 --> 00:17:48,400
between a net buff

00:17:45,280 --> 00:17:52,400
and the m buff message so

00:17:48,400 --> 00:17:55,039
with a net buff what you have is uh

00:17:52,400 --> 00:17:57,360
you had a you had a packet data with a

00:17:55,039 --> 00:17:59,120
net buff you had this network structure

00:17:57,360 --> 00:18:00,960
and then you have the user private data

00:17:59,120 --> 00:18:03,600
within the which is

00:18:00,960 --> 00:18:04,960
the net which is the applications usage

00:18:03,600 --> 00:18:06,400
of the network

00:18:04,960 --> 00:18:08,000
and then you have the packet headers and

00:18:06,400 --> 00:18:11,280
the packet data

00:18:08,000 --> 00:18:14,080
whereas if you take the equivalent of an

00:18:11,280 --> 00:18:15,760
m buff you have this m buff buffer then

00:18:14,080 --> 00:18:16,960
you had the packet data and you had some

00:18:15,760 --> 00:18:19,919
private data for it

00:18:16,960 --> 00:18:21,200
so we needed a way to mangle from one

00:18:19,919 --> 00:18:24,400
net buff to an

00:18:21,200 --> 00:18:25,600
ember message so we came up with this uk

00:18:24,400 --> 00:18:28,880
ringed library

00:18:25,600 --> 00:18:31,919
which does this mangling from one

00:18:28,880 --> 00:18:34,720
uh one data structure to another

00:18:31,919 --> 00:18:35,360
and also the pole mode driver translates

00:18:34,720 --> 00:18:37,840
the call

00:18:35,360 --> 00:18:39,360
anything which is happening within the

00:18:37,840 --> 00:18:41,360
dpdk context

00:18:39,360 --> 00:18:42,400
to that of the unicraft context within

00:18:41,360 --> 00:18:45,360
the network

00:18:42,400 --> 00:18:46,960
so thereby we were able to translate

00:18:45,360 --> 00:18:50,160
from a net buff

00:18:46,960 --> 00:18:52,400
to a m buff and m buff to a net buff

00:18:50,160 --> 00:18:54,160
with with just these manipulations

00:18:52,400 --> 00:18:57,200
whereby we point

00:18:54,160 --> 00:18:57,919
the private data of a of a m buff to the

00:18:57,200 --> 00:18:59,919
network

00:18:57,919 --> 00:19:01,760
and the private data of netbuff to a

00:18:59,919 --> 00:19:04,320
number thereby it's easier to translate

00:19:01,760 --> 00:19:04,320
from another

00:19:07,039 --> 00:19:10,960
and finally we talk about uh the

00:19:09,280 --> 00:19:15,120
performance evaluations

00:19:10,960 --> 00:19:18,320
here we used uh two sets two systems

00:19:15,120 --> 00:19:20,160
one was the packet generator receiver

00:19:18,320 --> 00:19:21,840
and the other other system is the one

00:19:20,160 --> 00:19:25,679
which runs

00:19:21,840 --> 00:19:29,600
linux vm or a unicraft vm message

00:19:25,679 --> 00:19:32,799
the one it is it is a

00:19:29,600 --> 00:19:35,440
sandy sandy bridge server with

00:19:32,799 --> 00:19:38,799
six cores on it and we have we were

00:19:35,440 --> 00:19:41,679
using dpdk 1908 chemo version

00:19:38,799 --> 00:19:42,799
4 and the linux kernel the host kernel

00:19:41,679 --> 00:19:45,919
and the guest kernel were

00:19:42,799 --> 00:19:45,919
4.19 db

00:19:46,240 --> 00:19:51,280
and in terms of the next graph where we

00:19:49,280 --> 00:19:53,840
showed the baseline performance

00:19:51,280 --> 00:19:56,240
what we do here is we vary the package

00:19:53,840 --> 00:20:00,000
sizes from 64 bytes

00:19:56,240 --> 00:20:02,400
until 1500 bytes and we measure

00:20:00,000 --> 00:20:03,200
how much throughput we get in terms of

00:20:02,400 --> 00:20:06,400
uh

00:20:03,200 --> 00:20:07,039
millions of packets per second so what

00:20:06,400 --> 00:20:10,080
we gain

00:20:07,039 --> 00:20:12,559
is we in terms of uh

00:20:10,080 --> 00:20:13,520
in terms of we measured it in four

00:20:12,559 --> 00:20:16,559
mechanisms

00:20:13,520 --> 00:20:18,559
one is using the v host user and which

00:20:16,559 --> 00:20:20,559
is the dpdk accelerated version

00:20:18,559 --> 00:20:21,919
and the then it's the kernel accelerated

00:20:20,559 --> 00:20:24,400
version and

00:20:21,919 --> 00:20:25,280
in terms of unicraft versus dpdk

00:20:24,400 --> 00:20:28,320
comparison

00:20:25,280 --> 00:20:31,520
we are quite similar in

00:20:28,320 --> 00:20:34,320
transmission performance as such

00:20:31,520 --> 00:20:35,200
similar performance we did for the rx

00:20:34,320 --> 00:20:38,640
throughput

00:20:35,200 --> 00:20:40,320
where uh the rx part of unicraft with a

00:20:38,640 --> 00:20:43,440
v host user

00:20:40,320 --> 00:20:43,919
is slightly slower than is about 11

00:20:43,440 --> 00:20:47,440
million

00:20:43,919 --> 00:20:50,880
11.5 million package whereas the

00:20:47,440 --> 00:20:53,919
rx of uh rx of uh

00:20:50,880 --> 00:20:56,400
linux vm was around 13 million packets

00:20:53,919 --> 00:20:57,360
uh for the minimal packet size and for

00:20:56,400 --> 00:21:00,480
the rest of them

00:20:57,360 --> 00:21:02,240
was quite matchy so we there are some

00:21:00,480 --> 00:21:03,360
bottlenecks within the rx which we need

00:21:02,240 --> 00:21:06,559
to figure out

00:21:03,360 --> 00:21:06,559
which is part of the future work

00:21:07,679 --> 00:21:11,280
so in the previous two experiments what

00:21:10,080 --> 00:21:14,080
we did was

00:21:11,280 --> 00:21:15,919
a packet generator keeps sending packets

00:21:14,080 --> 00:21:17,679
and we drop the packet once we receive

00:21:15,919 --> 00:21:19,600
it or once we send it

00:21:17,679 --> 00:21:22,159
here we did another experiment which is

00:21:19,600 --> 00:21:24,400
like a key value store what we did was

00:21:22,159 --> 00:21:25,919
uh a package generator sends you a

00:21:24,400 --> 00:21:28,720
stream of packets

00:21:25,919 --> 00:21:29,440
we receive the packet we read some

00:21:28,720 --> 00:21:31,840
specific

00:21:29,440 --> 00:21:33,440
based on the values in the packet we

00:21:31,840 --> 00:21:35,919
read a key value store

00:21:33,440 --> 00:21:36,480
and we send out the packet out so with

00:21:35,919 --> 00:21:39,840
that

00:21:36,480 --> 00:21:42,159
a single core is is being is now being

00:21:39,840 --> 00:21:43,840
is now processing the receive of packet

00:21:42,159 --> 00:21:45,039
processing some data within the packet

00:21:43,840 --> 00:21:47,520
and sending it out

00:21:45,039 --> 00:21:49,039
and we made a comparison of that with

00:21:47,520 --> 00:21:52,080
the linux vm

00:21:49,039 --> 00:21:53,840
and that of the unicraft and with dpdk

00:21:52,080 --> 00:21:55,679
and unicraft with network running

00:21:53,840 --> 00:21:57,600
and all of them were quite similar in

00:21:55,679 --> 00:22:00,960
terms of six million packets

00:21:57,600 --> 00:22:03,679
per second and in terms of

00:22:00,960 --> 00:22:04,320
resource usage itself uh what we

00:22:03,679 --> 00:22:07,360
observed

00:22:04,320 --> 00:22:08,320
was in terms of memory usage unicraft

00:22:07,360 --> 00:22:10,640
needed

00:22:08,320 --> 00:22:12,559
to run to run the dpdk application you

00:22:10,640 --> 00:22:14,640
need to use is one gigabit of memory

00:22:12,559 --> 00:22:15,760
whereas a linux vm needed a six gigabyte

00:22:14,640 --> 00:22:18,720
of memory so it's about

00:22:15,760 --> 00:22:21,520
six orders same savings the boot times

00:22:18,720 --> 00:22:24,480
of unicraft is about 87 milliseconds

00:22:21,520 --> 00:22:26,000
whereas the view time of a linux pm is

00:22:24,480 --> 00:22:30,880
unoptimized is about 12

00:22:26,000 --> 00:22:33,120
seconds and the image size comparison is

00:22:30,880 --> 00:22:34,880
the unicraft image is about 1.4

00:22:33,120 --> 00:22:38,080
megabytes in size whereas

00:22:34,880 --> 00:22:39,520
a linux vm is about 2.5 gigabytes in

00:22:38,080 --> 00:22:41,280
size so it's about a

00:22:39,520 --> 00:22:45,280
huge order of magnitude difference

00:22:41,280 --> 00:22:45,280
between in terms of resource you say yes

00:22:46,000 --> 00:22:52,000
finally uh the next part of our

00:22:49,919 --> 00:22:53,600
of this journey is we needed to add

00:22:52,000 --> 00:22:55,600
support for smp's

00:22:53,600 --> 00:22:56,880
drivers smp support so that we have

00:22:55,600 --> 00:22:59,520
multiple cpus

00:22:56,880 --> 00:23:01,919
and also we wanted to try out running

00:22:59,520 --> 00:23:02,960
dpdk drivers instead of unicraft drivers

00:23:01,919 --> 00:23:06,720
which were run

00:23:02,960 --> 00:23:06,720
so that we can keep it up to date

00:23:07,280 --> 00:23:11,039
so if you if you find this work

00:23:08,799 --> 00:23:12,640
interesting you could you could also

00:23:11,039 --> 00:23:14,159
for further references you could i have

00:23:12,640 --> 00:23:17,600
put on some of the links

00:23:14,159 --> 00:23:20,799
you can refer it and thus to

00:23:17,600 --> 00:23:21,440
conclude my talk uh of unicraft we made

00:23:20,799 --> 00:23:24,000
us

00:23:21,440 --> 00:23:25,600
a comparison unicraft provides you

00:23:24,000 --> 00:23:28,880
multiple platform support

00:23:25,600 --> 00:23:31,520
a specialized guest operate guest os

00:23:28,880 --> 00:23:33,039
whereby we optimize for image size

00:23:31,520 --> 00:23:36,320
memory consumption

00:23:33,039 --> 00:23:38,720
and also the boot times

00:23:36,320 --> 00:23:41,120
at the same performance and we have a

00:23:38,720 --> 00:23:42,960
simpler managed device management

00:23:41,120 --> 00:23:44,559
simpler device management for a dpdk

00:23:42,960 --> 00:23:46,960
application

00:23:44,559 --> 00:23:49,120
and we provide increased control for an

00:23:46,960 --> 00:23:52,480
application compared to that of a linux

00:23:49,120 --> 00:23:54,960
guest vm and in terms of dpdk

00:23:52,480 --> 00:23:57,120
dpdk provides you the benefit of and

00:23:54,960 --> 00:24:00,159
highly optimized network stack

00:23:57,120 --> 00:24:01,120
a specialized pnf functionality and a

00:24:00,159 --> 00:24:05,200
lot of

00:24:01,120 --> 00:24:07,840
untapped potential from the dpdk drivers

00:24:05,200 --> 00:24:08,400
so i think the two projects go hand in

00:24:07,840 --> 00:24:11,919
hand

00:24:08,400 --> 00:24:15,200
in the vnf domain and it is a

00:24:11,919 --> 00:24:18,720
benefit that we use uh unicraft

00:24:15,200 --> 00:24:21,760
as a dpdk image in the

00:24:18,720 --> 00:24:24,159
in a in the virtualized network

00:24:21,760 --> 00:24:24,159
functions

00:24:24,480 --> 00:24:28,240
if there are further questions i would

00:24:25,919 --> 00:24:28,720
like to leave the flow for further

00:24:28,240 --> 00:24:30,960
questions

00:24:28,720 --> 00:24:33,840
if you have any questions please ask

00:24:30,960 --> 00:24:33,840
thank you

00:24:45,039 --> 00:24:47,120

YouTube URL: https://www.youtube.com/watch?v=KNRa5rWN-eA


