Title: KVM Address Space Isolation - Alexandre Chartre, Oracle
Publication date: 2020-11-10
Playlist: KVM Forum Europe 2020
Description: 
	KVM Address Space Isolation - Alexandre Chartre, Oracle
Captions: 
	00:00:05,920 --> 00:00:10,240
hello everyone

00:00:06,960 --> 00:00:11,920
thanks for joining us my name is uh phil

00:00:10,240 --> 00:00:13,920
i work for google cloud

00:00:11,920 --> 00:00:16,240
today alex from oracle and i will

00:00:13,920 --> 00:00:19,680
present address space isolation for

00:00:16,240 --> 00:00:20,640
avm this idea started more than a year

00:00:19,680 --> 00:00:23,760
ago

00:00:20,640 --> 00:00:25,920
i was presented also in lpc

00:00:23,760 --> 00:00:28,080
by several different companies they were

00:00:25,920 --> 00:00:31,359
trying to merge

00:00:28,080 --> 00:00:34,079
work by ibm oracle google

00:00:31,359 --> 00:00:36,239
and potentially others into one unified

00:00:34,079 --> 00:00:39,200
framework for other space isolation

00:00:36,239 --> 00:00:40,879
but more on that slightly later on and

00:00:39,200 --> 00:00:42,640
other space isolation is a defense

00:00:40,879 --> 00:00:45,680
mechanism against

00:00:42,640 --> 00:00:47,039
a speculative microarchitectural attack

00:00:45,680 --> 00:00:48,800
and we'll discuss some of that in a

00:00:47,039 --> 00:00:51,520
second

00:00:48,800 --> 00:00:52,000
so why do we need other space isolation

00:00:51,520 --> 00:00:54,000
so

00:00:52,000 --> 00:00:55,440
about a couple of years ago we've seen

00:00:54,000 --> 00:00:58,480
attacks like l1tf

00:00:55,440 --> 00:01:01,600
and mbs that are able to get information

00:00:58,480 --> 00:01:04,479
uh for microarchitectural buffers

00:01:01,600 --> 00:01:06,080
l1tf can get data from the l1 cache and

00:01:04,479 --> 00:01:07,360
if you look at this drawing you see for

00:01:06,080 --> 00:01:10,080
example

00:01:07,360 --> 00:01:11,760
two vms running one of them the attacker

00:01:10,080 --> 00:01:13,200
vm and the other is the victim vm and

00:01:11,760 --> 00:01:16,159
the attacker vm

00:01:13,200 --> 00:01:16,960
is capable uh basically uh in scrubbing

00:01:16,159 --> 00:01:19,280
the l1 cache

00:01:16,960 --> 00:01:21,439
it doesn't even matter who this data

00:01:19,280 --> 00:01:21,920
belongs whether it belongs to the victim

00:01:21,439 --> 00:01:24,240
vm

00:01:21,920 --> 00:01:27,200
or maybe to the host attacker is capable

00:01:24,240 --> 00:01:30,320
of getting this data

00:01:27,200 --> 00:01:32,000
if we look at the mds attacks

00:01:30,320 --> 00:01:34,479
the attacker is able to get data from

00:01:32,000 --> 00:01:37,200
microarchitectural buffers

00:01:34,479 --> 00:01:37,759
for example the light buffer and this is

00:01:37,200 --> 00:01:39,360
bad

00:01:37,759 --> 00:01:41,759
and the reason this is bad is because

00:01:39,360 --> 00:01:42,479
obviously we are breaking the vm

00:01:41,759 --> 00:01:44,159
boundary

00:01:42,479 --> 00:01:45,600
one vm can still data belonging to

00:01:44,159 --> 00:01:48,880
another vm

00:01:45,600 --> 00:01:50,720
um and also a

00:01:48,880 --> 00:01:52,720
victim vm can also steal data that

00:01:50,720 --> 00:01:53,119
belongs to the host potentially the host

00:01:52,720 --> 00:01:55,840
has

00:01:53,119 --> 00:01:57,280
credentials to communicate with the rest

00:01:55,840 --> 00:01:59,840
of the data center

00:01:57,280 --> 00:02:00,880
um and while it seems initially that

00:01:59,840 --> 00:02:02,719
those attacks

00:02:00,880 --> 00:02:04,240
can only work in very specific scenarios

00:02:02,719 --> 00:02:05,119
they seem those attacks are actually

00:02:04,240 --> 00:02:08,239
very powerful

00:02:05,119 --> 00:02:08,720
because it seemed to be more practical

00:02:08,239 --> 00:02:11,039
than

00:02:08,720 --> 00:02:13,120
uh one would think so the danger is that

00:02:11,039 --> 00:02:14,800
one vm can steal data from another vm or

00:02:13,120 --> 00:02:17,200
still from the platform

00:02:14,800 --> 00:02:18,720
um and this is obviously very bad for

00:02:17,200 --> 00:02:20,400
the cloud environment

00:02:18,720 --> 00:02:21,840
and we want to come up with an efficient

00:02:20,400 --> 00:02:24,160
mitigation

00:02:21,840 --> 00:02:25,840
that allow us uh to prevent these

00:02:24,160 --> 00:02:26,640
attacks in a reasonable performance

00:02:25,840 --> 00:02:28,480
overhead

00:02:26,640 --> 00:02:29,760
so let's first see what are the obvious

00:02:28,480 --> 00:02:33,040
mitigations

00:02:29,760 --> 00:02:34,160
that one can deploy in order to prevent

00:02:33,040 --> 00:02:36,800
these attacks

00:02:34,160 --> 00:02:38,480
so one obvious mitigation is to disable

00:02:36,800 --> 00:02:41,040
hyper threading basically saying you

00:02:38,480 --> 00:02:44,480
know what hyper threading is a bad idea

00:02:41,040 --> 00:02:45,760
uh but that comes with uh that's pretty

00:02:44,480 --> 00:02:48,080
reliable solution

00:02:45,760 --> 00:02:49,599
but it's quite expensive in theory we

00:02:48,080 --> 00:02:52,160
can lose up to 30 percent

00:02:49,599 --> 00:02:54,239
if we disable either faring and that's

00:02:52,160 --> 00:02:57,519
not what we want

00:02:54,239 --> 00:03:00,959
another option is to basically

00:02:57,519 --> 00:03:03,360
make sure no two different vms

00:03:00,959 --> 00:03:04,400
are running on the same physical core

00:03:03,360 --> 00:03:06,159
again it creates

00:03:04,400 --> 00:03:08,159
a slightly more complicated scheduling

00:03:06,159 --> 00:03:09,680
it's possible but we still have the

00:03:08,159 --> 00:03:10,720
problem what happens when we need to

00:03:09,680 --> 00:03:13,280
serve a vm exit

00:03:10,720 --> 00:03:14,720
then the host need to run some code

00:03:13,280 --> 00:03:16,640
maybe bring some

00:03:14,720 --> 00:03:19,760
secret data into the cache or do some

00:03:16,640 --> 00:03:22,480
other architectural buffers

00:03:19,760 --> 00:03:22,959
and basically what you need to do then

00:03:22,480 --> 00:03:26,400
is

00:03:22,959 --> 00:03:28,319
maybe find a way to

00:03:26,400 --> 00:03:29,680
stop the other thread let's say you have

00:03:28,319 --> 00:03:32,400
one one sibling

00:03:29,680 --> 00:03:34,640
logical call serving a vm exit then

00:03:32,400 --> 00:03:37,280
before you serve the vm exit you want to

00:03:34,640 --> 00:03:38,720
somehow pause the other sibling thread

00:03:37,280 --> 00:03:40,400
um

00:03:38,720 --> 00:03:43,760
that's also quite expensive obviously

00:03:40,400 --> 00:03:45,920
and it's a quite complicated mechanism

00:03:43,760 --> 00:03:47,840
and in other space isolation what we

00:03:45,920 --> 00:03:51,519
want to do is basically

00:03:47,840 --> 00:03:53,360
deploy defense mechanisms

00:03:51,519 --> 00:03:55,280
only when we actually meet meaning only

00:03:53,360 --> 00:03:58,319
when we actually

00:03:55,280 --> 00:04:03,200
access what can be sensitive data

00:03:58,319 --> 00:04:06,640
only then we will deploy mitigations

00:04:03,200 --> 00:04:07,920
so um let's try to give some information

00:04:06,640 --> 00:04:12,159
about aside

00:04:07,920 --> 00:04:15,040
so in the next slide um

00:04:12,159 --> 00:04:16,799
if you can uh yeah uh the intuition to

00:04:15,040 --> 00:04:20,479
an asi is basically

00:04:16,799 --> 00:04:23,600
we will try uh for the most time

00:04:20,479 --> 00:04:26,080
most of the time to not have uh

00:04:23,600 --> 00:04:28,000
most memory mapped in the page and

00:04:26,080 --> 00:04:31,280
here's a preview example of

00:04:28,000 --> 00:04:32,960
um spectre version one it's a function

00:04:31,280 --> 00:04:34,960
that will access an array

00:04:32,960 --> 00:04:36,880
it's location index and if you look at

00:04:34,960 --> 00:04:39,440
the if in the beginning

00:04:36,880 --> 00:04:40,800
we will check if index is uh within the

00:04:39,440 --> 00:04:43,199
bounds of the array

00:04:40,800 --> 00:04:45,120
and then we'll access some other array

00:04:43,199 --> 00:04:46,400
with this index

00:04:45,120 --> 00:04:48,479
and what will happen is that if the

00:04:46,400 --> 00:04:51,680
index is too big and the branch

00:04:48,479 --> 00:04:53,759
will be predicted accidentally as taken

00:04:51,680 --> 00:04:55,120
we will access array location

00:04:53,759 --> 00:04:57,680
potentially million

00:04:55,120 --> 00:04:59,440
and in theory we can access an arbitrary

00:04:57,680 --> 00:05:01,840
location in memory

00:04:59,440 --> 00:05:03,360
uh and then this this memory will be

00:05:01,840 --> 00:05:04,960
brought into the l1 cache

00:05:03,360 --> 00:05:08,320
or into some other micro architecture

00:05:04,960 --> 00:05:11,120
buffers and the idea is that

00:05:08,320 --> 00:05:12,639
if when a program runs only data that is

00:05:11,120 --> 00:05:14,400
not sensitive

00:05:12,639 --> 00:05:16,160
uh will be mapping the page table then

00:05:14,400 --> 00:05:18,080
any access

00:05:16,160 --> 00:05:20,720
whether it was speculative or not

00:05:18,080 --> 00:05:24,000
speculative will cause a page fault

00:05:20,720 --> 00:05:26,080
and uh basically the processor cannot

00:05:24,000 --> 00:05:28,160
speculate behind a page if the processor

00:05:26,080 --> 00:05:31,199
doesn't know the translation between

00:05:28,160 --> 00:05:34,240
virtual to physical it cannot bring data

00:05:31,199 --> 00:05:36,160
uh into the micro architectural buffers

00:05:34,240 --> 00:05:37,360
and if you cannot bring the data then it

00:05:36,160 --> 00:05:38,960
means that

00:05:37,360 --> 00:05:40,639
sequence are not in microarchitectural

00:05:38,960 --> 00:05:42,240
buffers so

00:05:40,639 --> 00:05:44,400
that's the key information between

00:05:42,240 --> 00:05:45,120
behind aside let's basically let's not

00:05:44,400 --> 00:05:49,360
map

00:05:45,120 --> 00:05:49,360
data that we don't need to into the page

00:05:49,919 --> 00:05:54,880
so as an overview the idea is let's say

00:05:52,000 --> 00:05:57,520
we have at least in the case of vms

00:05:54,880 --> 00:05:59,600
we have two guests running and most of

00:05:57,520 --> 00:06:00,560
the time when we are serving a vm exit

00:05:59,600 --> 00:06:03,919
whether it was for

00:06:00,560 --> 00:06:06,319
an interrupt or something else we touch

00:06:03,919 --> 00:06:07,919
memory that has to do with the call and

00:06:06,319 --> 00:06:09,680
guess that is running

00:06:07,919 --> 00:06:11,520
and the idea in the science let's have a

00:06:09,680 --> 00:06:13,440
page table a limited page table you can

00:06:11,520 --> 00:06:15,600
think about it as like sty domains

00:06:13,440 --> 00:06:17,680
guest a will have in this example a

00:06:15,600 --> 00:06:20,880
slide domain one and guess the

00:06:17,680 --> 00:06:21,440
is aside domain two and when guest a is

00:06:20,880 --> 00:06:24,240
running

00:06:21,440 --> 00:06:24,880
uh to serve most vm exits we're only

00:06:24,240 --> 00:06:28,560
touching

00:06:24,880 --> 00:06:30,720
data that has to do with guest a

00:06:28,560 --> 00:06:32,840
and the idea is that if guest a is

00:06:30,720 --> 00:06:34,960
trying to steal data that belongs to

00:06:32,840 --> 00:06:36,639
itself then we're saying

00:06:34,960 --> 00:06:38,319
we're slightly relaxing the security

00:06:36,639 --> 00:06:40,800
requirements basically saying

00:06:38,319 --> 00:06:41,440
if a guest vm steals data that has to do

00:06:40,800 --> 00:06:45,600
with

00:06:41,440 --> 00:06:46,319
managing itself then we're okay it can

00:06:45,600 --> 00:06:49,280
try and steal it

00:06:46,319 --> 00:06:49,840
because there will be no uh particular

00:06:49,280 --> 00:06:53,039
secrets

00:06:49,840 --> 00:06:54,560
that can be exposed and what happens if

00:06:53,039 --> 00:06:57,039
we need to serve a vm exit

00:06:54,560 --> 00:06:59,199
and then touch some other data then we

00:06:57,039 --> 00:07:00,720
want to identify it and say okay

00:06:59,199 --> 00:07:02,800
now there's a chance we're actually

00:07:00,720 --> 00:07:04,880
touching secrets in memory

00:07:02,800 --> 00:07:06,160
and we want to be more careful maybe now

00:07:04,880 --> 00:07:08,319
we want to

00:07:06,160 --> 00:07:09,759
synchronize with the other sibling core

00:07:08,319 --> 00:07:13,680
and and posit

00:07:09,759 --> 00:07:16,479
that's sometimes known as stunning and

00:07:13,680 --> 00:07:18,400
then maybe when we uh touch privileged

00:07:16,479 --> 00:07:21,039
memory before we get back

00:07:18,400 --> 00:07:21,759
into the asi domain then maybe we want

00:07:21,039 --> 00:07:24,400
to

00:07:21,759 --> 00:07:25,919
scrub secrets from buffers for example

00:07:24,400 --> 00:07:28,000
to prevent l1df

00:07:25,919 --> 00:07:30,240
after we touch privileged memory and we

00:07:28,000 --> 00:07:33,759
want to go back into the asi domain

00:07:30,240 --> 00:07:35,599
we will only then flash the error cache

00:07:33,759 --> 00:07:37,680
and that's nice because it means that

00:07:35,599 --> 00:07:39,039
hopefully for most vm exits we're only

00:07:37,680 --> 00:07:40,720
touching guest a staff

00:07:39,039 --> 00:07:42,479
and only every once in a while we touch

00:07:40,720 --> 00:07:45,039
some other data and only then we'll

00:07:42,479 --> 00:07:46,720
flash l1 cache not on every bmx

00:07:45,039 --> 00:07:48,879
and if we want to defend against mbs

00:07:46,720 --> 00:07:50,639
attacks it means that maybe we'll run

00:07:48,879 --> 00:07:53,759
the verw

00:07:50,639 --> 00:07:54,800
scoping instruction only uh if we

00:07:53,759 --> 00:07:57,680
actually touched

00:07:54,800 --> 00:07:59,120
potentially sensitive data and and with

00:07:57,680 --> 00:08:00,639
ssi we will know that the potentially

00:07:59,120 --> 00:08:03,360
touch sensitive data because

00:08:00,639 --> 00:08:05,039
when we touch it we get a page fault uh

00:08:03,360 --> 00:08:07,039
and that's something very tangible that

00:08:05,039 --> 00:08:09,360
we can notice an event that we can

00:08:07,039 --> 00:08:11,120
uh manage and then there's also a

00:08:09,360 --> 00:08:13,680
question on

00:08:11,120 --> 00:08:16,000
uh how we end the interrupts of course

00:08:13,680 --> 00:08:20,000
uh but more on that

00:08:16,000 --> 00:08:22,080
slightly uh later on and

00:08:20,000 --> 00:08:24,840
this idea now we explain is how to

00:08:22,080 --> 00:08:28,400
manage address space isolation for

00:08:24,840 --> 00:08:32,080
kbm there are other options as well

00:08:28,400 --> 00:08:34,399
and alex now will explain what other

00:08:32,080 --> 00:08:36,640
usages can can we can have for other

00:08:34,399 --> 00:08:40,000
space exploration

00:08:36,640 --> 00:08:43,120
yeah thank you so all osi was initially

00:08:40,000 --> 00:08:46,320
designed for an application with kvm to

00:08:43,120 --> 00:08:48,800
to mitigate the uh some speculative

00:08:46,320 --> 00:08:49,839
attack we expect that we will have

00:08:48,800 --> 00:08:53,040
overusage

00:08:49,839 --> 00:08:54,000
for asi and that we can make a site more

00:08:53,040 --> 00:08:58,080
generating and not

00:08:54,000 --> 00:08:59,440
specific to to kvm so for kvm as

00:08:58,080 --> 00:09:04,240
explained obviously but

00:08:59,440 --> 00:09:07,200
to protect against this guest was attack

00:09:04,240 --> 00:09:08,080
main challenge in there is what data do

00:09:07,200 --> 00:09:11,279
we want to include

00:09:08,080 --> 00:09:13,040
in vasi well what is really sensitive

00:09:11,279 --> 00:09:16,480
and secret

00:09:13,040 --> 00:09:19,600
um what we expect asi to be used for too

00:09:16,480 --> 00:09:23,200
is to do what we call

00:09:19,600 --> 00:09:27,680
user asi which is to re-implement

00:09:23,200 --> 00:09:31,040
the um the kernel and user page table

00:09:27,680 --> 00:09:34,480
uh the page table itself and the switch

00:09:31,040 --> 00:09:38,240
with asi in order to refactor over a

00:09:34,480 --> 00:09:41,360
kernel page table isolations of the kpti

00:09:38,240 --> 00:09:42,399
which is um as a mitigation for spectral

00:09:41,360 --> 00:09:45,440
v1

00:09:42,399 --> 00:09:47,680
and kpt i use almost

00:09:45,440 --> 00:09:49,440
work almost the same way as asi that is

00:09:47,680 --> 00:09:52,000
that you have one page cable for webcam

00:09:49,440 --> 00:09:54,480
and one for your username and when you

00:09:52,000 --> 00:09:55,839
enter exit your lan card you will switch

00:09:54,480 --> 00:09:58,560
the page table

00:09:55,839 --> 00:09:59,120
so this is this is an area where we can

00:09:58,560 --> 00:10:02,160
use

00:09:59,120 --> 00:10:05,839
asi to to have

00:10:02,160 --> 00:10:05,839
the same implementation

00:10:06,640 --> 00:10:13,760
over a possibility would be to have some

00:10:10,160 --> 00:10:15,600
username aside this is some idea where i

00:10:13,760 --> 00:10:17,760
don't look into

00:10:15,600 --> 00:10:19,600
too much detail yet but the idea would

00:10:17,760 --> 00:10:22,640
be

00:10:19,600 --> 00:10:23,760
to provide the ability to use a process

00:10:22,640 --> 00:10:25,920
to have multiple

00:10:23,760 --> 00:10:27,920
address space so currently you use a

00:10:25,920 --> 00:10:29,440
process as a single address space that's

00:10:27,920 --> 00:10:31,839
a single page table

00:10:29,440 --> 00:10:33,360
but we can imagine a process having

00:10:31,839 --> 00:10:35,279
multiple page table

00:10:33,360 --> 00:10:37,600
and being able to switch between the

00:10:35,279 --> 00:10:40,640
different page table

00:10:37,600 --> 00:10:44,959
we think this may have some

00:10:40,640 --> 00:10:46,399
useful usage for a virtual environment

00:10:44,959 --> 00:10:49,519
like the virtual

00:10:46,399 --> 00:10:51,360
java virtual machine or the graphite

00:10:49,519 --> 00:10:54,079
machine or containers

00:10:51,360 --> 00:10:55,040
where you need to a single processor is

00:10:54,079 --> 00:10:58,399
running multiple

00:10:55,040 --> 00:11:00,880
environment and you want to be secure

00:10:58,399 --> 00:11:01,440
between these different environments so

00:11:00,880 --> 00:11:03,120
this is

00:11:01,440 --> 00:11:06,480
really something we are only

00:11:03,120 --> 00:11:06,480
investigating at the moment

00:11:06,959 --> 00:11:11,120
now we are going to go into more uh

00:11:09,760 --> 00:11:14,240
specifics about the

00:11:11,120 --> 00:11:18,000
uh kvm asi implementation

00:11:14,240 --> 00:11:21,279
and how this is used exactly

00:11:18,000 --> 00:11:24,800
so the idea is to have an address space

00:11:21,279 --> 00:11:28,640
with a limited kernel and vm mappings

00:11:24,800 --> 00:11:32,399
so basically we need the

00:11:28,640 --> 00:11:35,440
mapping to enter the vm

00:11:32,399 --> 00:11:37,839
and then under the vm exit the goal is

00:11:35,440 --> 00:11:41,040
really to be able to run the vm

00:11:37,839 --> 00:11:45,279
and under most vm exits

00:11:41,040 --> 00:11:48,480
at this the most we can without exiting

00:11:45,279 --> 00:11:52,639
asi so that we can loop and stay

00:11:48,480 --> 00:11:55,440
running safely with the asi

00:11:52,639 --> 00:11:56,880
so the idea is that on an isi we are

00:11:55,440 --> 00:12:00,800
going to need to map the

00:11:56,880 --> 00:12:03,760
um the data for a single vm

00:12:00,800 --> 00:12:04,240
and that way we can prevent overvm

00:12:03,760 --> 00:12:07,200
running

00:12:04,240 --> 00:12:10,880
on on the cpu core to steal data from

00:12:07,200 --> 00:12:13,920
another vm or from the host

00:12:10,880 --> 00:12:16,480
and to do that also safely we would need

00:12:13,920 --> 00:12:19,760
to synchronize on the vm entry

00:12:16,480 --> 00:12:21,600
uh if the other sibling is not running

00:12:19,760 --> 00:12:23,760
there's no need to to synchronize if

00:12:21,600 --> 00:12:25,440
you're if your sibling cpu thread is

00:12:23,760 --> 00:12:27,279
also running aside

00:12:25,440 --> 00:12:29,279
because we know it itself we know there

00:12:27,279 --> 00:12:32,959
is no data to

00:12:29,279 --> 00:12:36,000
secret data that you can get from pair

00:12:32,959 --> 00:12:38,720
but if anything else is running in

00:12:36,000 --> 00:12:42,160
kernel context not in aside then

00:12:38,720 --> 00:12:44,639
potentially you can steal something so

00:12:42,160 --> 00:12:46,079
this synchronizes synchronization is

00:12:44,639 --> 00:12:48,560
really needed

00:12:46,079 --> 00:12:50,399
and in that area core scheduling is

00:12:48,560 --> 00:12:52,160
going to help

00:12:50,399 --> 00:12:53,519
because with core scheduling you are

00:12:52,160 --> 00:12:57,040
going to be able to

00:12:53,519 --> 00:12:59,279
to schedule on the same cpu core um

00:12:57,040 --> 00:13:01,600
process from the same vm so you would

00:12:59,279 --> 00:13:05,120
know that at least that's the same vm

00:13:01,600 --> 00:13:07,519
and you just have the the risk of

00:13:05,120 --> 00:13:10,720
being in camera contacts where you can

00:13:07,519 --> 00:13:10,720
you can steal some data

00:13:12,800 --> 00:13:20,320
um so as i mentioned asis

00:13:16,240 --> 00:13:25,360
is is more generic it's not specific to

00:13:20,320 --> 00:13:27,279
to kvn and the generic lifecycle for isi

00:13:25,360 --> 00:13:28,560
is pretty simple basically you you

00:13:27,279 --> 00:13:30,639
create an isi

00:13:28,560 --> 00:13:32,320
each asi is going to have its own page

00:13:30,639 --> 00:13:35,920
table

00:13:32,320 --> 00:13:38,240
um then you would need to populate the

00:13:35,920 --> 00:13:40,240
aside page table with data you know

00:13:38,240 --> 00:13:41,279
which is not sensitive so anyone can

00:13:40,240 --> 00:13:44,720
access it it's not

00:13:41,279 --> 00:13:46,240
it's not a problem and then all you have

00:13:44,720 --> 00:13:48,800
to do is to enter asi

00:13:46,240 --> 00:13:50,560
so when you enter asi that's an explicit

00:13:48,800 --> 00:13:52,800
command and it will switch

00:13:50,560 --> 00:13:54,320
from the kernel page table to the asi

00:13:52,800 --> 00:13:56,320
page table

00:13:54,320 --> 00:13:58,160
once we are running with the aside page

00:13:56,320 --> 00:14:01,199
table we still need

00:13:58,160 --> 00:14:03,040
need obviously be able to handle the

00:14:01,199 --> 00:14:04,720
entry out the exception before the

00:14:03,040 --> 00:14:06,639
context switch

00:14:04,720 --> 00:14:08,000
and some time to do that we'll need to

00:14:06,639 --> 00:14:10,720
interrupt the uh

00:14:08,000 --> 00:14:11,519
va sign and maybe a resume depending on

00:14:10,720 --> 00:14:14,639
on the

00:14:11,519 --> 00:14:17,839
context once we are

00:14:14,639 --> 00:14:18,720
all done with that and we don't need asi

00:14:17,839 --> 00:14:21,920
anymore

00:14:18,720 --> 00:14:24,399
we exit the asl switch back to the

00:14:21,920 --> 00:14:26,320
kernel page table once we are completely

00:14:24,399 --> 00:14:30,160
done with the si we can destroy the

00:14:26,320 --> 00:14:32,639
psi and the html so that's a fairly

00:14:30,160 --> 00:14:33,199
simple use basically like yeah page

00:14:32,639 --> 00:14:35,440
label

00:14:33,199 --> 00:14:37,760
use that page table when you are done

00:14:35,440 --> 00:14:41,920
you exit

00:14:37,760 --> 00:14:45,199
if you like if we look like uh um

00:14:41,920 --> 00:14:48,240
if we look at the usage more specific to

00:14:45,199 --> 00:14:52,000
kvm uh the idea is that

00:14:48,240 --> 00:14:53,839
we will create one airside per vm

00:14:52,000 --> 00:14:55,199
or pair vcpu it depends on the

00:14:53,839 --> 00:14:58,160
implementation

00:14:55,199 --> 00:14:58,880
i know i've test both but you have prime

00:14:58,160 --> 00:15:02,000
cones

00:14:58,880 --> 00:15:04,639
for for both of them uh

00:15:02,000 --> 00:15:06,000
if you create one pair vm then you will

00:15:04,639 --> 00:15:08,800
use the same asi

00:15:06,000 --> 00:15:09,519
for all uh vcpu otherwise you can also

00:15:08,800 --> 00:15:12,560
have one

00:15:09,519 --> 00:15:14,720
very cpu it depends on

00:15:12,560 --> 00:15:16,480
the implementation you want to do

00:15:14,720 --> 00:15:21,040
exactly

00:15:16,480 --> 00:15:24,000
um then obviously you populate your kvma

00:15:21,040 --> 00:15:26,079
s i page table with things which are

00:15:24,000 --> 00:15:28,560
generic as canon information you need

00:15:26,079 --> 00:15:30,720
just to enter and run your asi

00:15:28,560 --> 00:15:34,240
and also things which are specific to

00:15:30,720 --> 00:15:34,240
your vm or your vcpu

00:15:34,800 --> 00:15:40,160
and after that the kvm asi

00:15:37,839 --> 00:15:42,079
will be used when you when you are

00:15:40,160 --> 00:15:45,920
running the vm itself so

00:15:42,079 --> 00:15:47,440
when the guests are running the vcpu

00:15:45,920 --> 00:15:50,880
guest

00:15:47,440 --> 00:15:53,199
so it will all start with the kvm run ir

00:15:50,880 --> 00:15:53,199
tool

00:15:53,440 --> 00:15:58,399
and you enter uh in kbm with vcpu run

00:15:57,199 --> 00:16:00,160
loop

00:15:58,399 --> 00:16:02,720
and during that loop we'll enter the

00:16:00,160 --> 00:16:04,959
kvmsi

00:16:02,720 --> 00:16:07,199
and right before entering the vm we need

00:16:04,959 --> 00:16:10,959
to ensure that the

00:16:07,199 --> 00:16:14,160
over sibling cpu they are also running

00:16:10,959 --> 00:16:14,720
uh with the kvma side this is where we

00:16:14,160 --> 00:16:18,480
want to

00:16:14,720 --> 00:16:20,560
ensure that what we are going in the vm

00:16:18,480 --> 00:16:22,079
we are going to run is secure and it's

00:16:20,560 --> 00:16:23,519
not going to steal our data

00:16:22,079 --> 00:16:26,000
so this is where we'll have some

00:16:23,519 --> 00:16:29,519
synchronization to to to do

00:16:26,000 --> 00:16:31,360
once we know that the zibbling cpu are

00:16:29,519 --> 00:16:34,880
also running the kbm asi

00:16:31,360 --> 00:16:38,320
we can do the vm enter run the vm

00:16:34,880 --> 00:16:40,240
once we're done we exit the vm and once

00:16:38,320 --> 00:16:43,360
we have exited the vm

00:16:40,240 --> 00:16:43,920
uh we can stop this enforcement of

00:16:43,360 --> 00:16:47,120
having

00:16:43,920 --> 00:16:49,519
a kvmsi running and disabling

00:16:47,120 --> 00:16:51,120
so we are back from the vm we're still

00:16:49,519 --> 00:16:55,279
running with asi

00:16:51,120 --> 00:16:58,240
and now we want to process the vm exits

00:16:55,279 --> 00:17:02,000
so we'll try to run most of bm exits

00:16:58,240 --> 00:17:02,000
with ksi that's really the goal

00:17:02,480 --> 00:17:06,559
if there is if we need at some point

00:17:04,480 --> 00:17:08,640
when running the handler to to exit to

00:17:06,559 --> 00:17:12,079
the kernel we'll do that

00:17:08,640 --> 00:17:13,839
but because this is uh this is a loop we

00:17:12,079 --> 00:17:15,760
are going to re-enter and we are going

00:17:13,839 --> 00:17:18,240
before doing the vm enter we are going

00:17:15,760 --> 00:17:21,039
to re-enter the kvm asi to be safe

00:17:18,240 --> 00:17:21,039
on the next run

00:17:22,480 --> 00:17:26,799
so first thing as i mentioned is too

00:17:24,720 --> 00:17:30,000
when you have an asi is to fill

00:17:26,799 --> 00:17:32,000
the page table of easi

00:17:30,000 --> 00:17:34,080
so there is a very basic solution which

00:17:32,000 --> 00:17:37,679
is the just to add each

00:17:34,080 --> 00:17:38,320
mapping that you need uh we have common

00:17:37,679 --> 00:17:41,440
like

00:17:38,320 --> 00:17:43,679
asi map where you specify your isi the

00:17:41,440 --> 00:17:45,679
address you want to map

00:17:43,679 --> 00:17:46,880
and and the the size of the buffer you

00:17:45,679 --> 00:17:50,640
want to map and

00:17:46,880 --> 00:17:51,120
and and then a mac command when you are

00:17:50,640 --> 00:17:53,679
done

00:17:51,120 --> 00:17:55,600
so this is similar to the memory

00:17:53,679 --> 00:17:57,200
allocant free

00:17:55,600 --> 00:18:00,640
so instead your map on your unmapped

00:17:57,200 --> 00:18:03,520
your page table and that works fine um

00:18:00,640 --> 00:18:05,120
if you have well known buffer you know

00:18:03,520 --> 00:18:06,720
when they are located

00:18:05,120 --> 00:18:08,480
especially if they are pre-allocated

00:18:06,720 --> 00:18:09,120
they are located at the beginning of the

00:18:08,480 --> 00:18:12,000
boot or

00:18:09,120 --> 00:18:12,840
when your module is loaded it's easy to

00:18:12,000 --> 00:18:16,480
map them

00:18:12,840 --> 00:18:19,760
before before entering your isi

00:18:16,480 --> 00:18:22,400
it's becoming more complicated

00:18:19,760 --> 00:18:24,559
uh when you have buffer which are

00:18:22,400 --> 00:18:25,760
dynamically allocated and frequently

00:18:24,559 --> 00:18:28,400
relocated

00:18:25,760 --> 00:18:30,000
especially this is happening while you

00:18:28,400 --> 00:18:32,000
are running with asi

00:18:30,000 --> 00:18:34,559
so we need some mechanisms which are

00:18:32,000 --> 00:18:36,400
more performance

00:18:34,559 --> 00:18:39,600
especially for trying to add some

00:18:36,400 --> 00:18:39,600
mapping more automatically

00:18:40,000 --> 00:18:45,600
so one first idea is to

00:18:43,360 --> 00:18:47,120
to track and tag the statically

00:18:45,600 --> 00:18:49,600
allocated buffer

00:18:47,120 --> 00:18:51,280
that we need and we know have no

00:18:49,600 --> 00:18:54,799
sensitive data

00:18:51,280 --> 00:18:58,720
so a simple solution is just to put this

00:18:54,799 --> 00:19:02,400
this data into a dedicated uh

00:18:58,720 --> 00:19:04,160
section uh it can be

00:19:02,400 --> 00:19:05,760
fairly simply done by just adding a

00:19:04,160 --> 00:19:08,720
computer section a

00:19:05,760 --> 00:19:10,320
computer a compiler attribute with the

00:19:08,720 --> 00:19:12,160
section where you want to store this

00:19:10,320 --> 00:19:14,880
information

00:19:12,160 --> 00:19:16,720
uh so a simple solution is just to

00:19:14,880 --> 00:19:19,039
define a special tag

00:19:16,720 --> 00:19:20,320
aside not sensitive which is an

00:19:19,039 --> 00:19:23,039
attribute

00:19:20,320 --> 00:19:23,440
uh compiler attributes which this fight

00:19:23,039 --> 00:19:27,200
put

00:19:23,440 --> 00:19:30,000
these data into a in delegate section

00:19:27,200 --> 00:19:30,640
and once we have that when we create an

00:19:30,000 --> 00:19:33,039
ssi

00:19:30,640 --> 00:19:34,160
we can just map the entire section into

00:19:33,039 --> 00:19:37,360
vsi we know

00:19:34,160 --> 00:19:42,160
these data are safe and

00:19:37,360 --> 00:19:42,160
but we need them to run our stuff

00:19:42,799 --> 00:19:50,240
um for the dynamically allocated buffer

00:19:47,200 --> 00:19:54,160
um what we would need to do

00:19:50,240 --> 00:19:59,120
is is to to flag this buffer

00:19:54,160 --> 00:20:01,600
uh so to do that we can use a new tag

00:19:59,120 --> 00:20:02,960
to specify that the date of the buffer

00:20:01,600 --> 00:20:06,640
we are locating

00:20:02,960 --> 00:20:10,640
is going to store non-sensitive uh data

00:20:06,640 --> 00:20:13,280
so currently there is there is a global

00:20:10,640 --> 00:20:13,840
and sensitive and local non-sensitive a

00:20:13,280 --> 00:20:17,120
global

00:20:13,840 --> 00:20:20,640
insensitive would mean that

00:20:17,120 --> 00:20:23,520
the data are not sensitive whatever

00:20:20,640 --> 00:20:24,320
asr you are using so you can map them

00:20:23,520 --> 00:20:28,240
into

00:20:24,320 --> 00:20:30,000
any asi the local non-sensitive

00:20:28,240 --> 00:20:32,080
is a bit different in that it's

00:20:30,000 --> 00:20:35,520
sensitive data

00:20:32,080 --> 00:20:37,600
but it's not sensitive only for this

00:20:35,520 --> 00:20:41,120
process for the current process

00:20:37,600 --> 00:20:45,520
a good example for kvm is the vmcs

00:20:41,120 --> 00:20:48,640
so vmcf has information about the vm

00:20:45,520 --> 00:20:51,679
but it's it's not sensitive

00:20:48,640 --> 00:20:54,559
if you are using and running the vm

00:20:51,679 --> 00:20:55,280
it's sensitive regarding a different vm

00:20:54,559 --> 00:20:58,559
but not

00:20:55,280 --> 00:21:00,480
uh regarding the current process and the

00:20:58,559 --> 00:21:03,520
current vm

00:21:00,480 --> 00:21:04,960
so when using this tag um the buffer are

00:21:03,520 --> 00:21:08,400
located

00:21:04,960 --> 00:21:11,520
and they are automatically mapped into

00:21:08,400 --> 00:21:13,280
bsi the current asi

00:21:11,520 --> 00:21:14,840
and they will be also automatically

00:21:13,280 --> 00:21:17,840
unmapped when you when you free the

00:21:14,840 --> 00:21:17,840
buffer

00:21:19,360 --> 00:21:25,760
once you have your page table

00:21:22,640 --> 00:21:28,000
defined for asi

00:21:25,760 --> 00:21:29,840
we need a mechanism to to switch the

00:21:28,000 --> 00:21:30,480
page table when you enter the asi and

00:21:29,840 --> 00:21:33,440
when you

00:21:30,480 --> 00:21:35,039
exit vsi so that's very simple

00:21:33,440 --> 00:21:37,840
especially on x86

00:21:35,039 --> 00:21:40,799
it's just a control register to update

00:21:37,840 --> 00:21:42,559
but we see a free control register

00:21:40,799 --> 00:21:45,200
so that's basically one assembly

00:21:42,559 --> 00:21:48,240
instruction very simple

00:21:45,200 --> 00:21:51,280
the complication is that it's not very

00:21:48,240 --> 00:21:54,000
efficient if you don't consider the tlb

00:21:51,280 --> 00:21:55,919
so the tlb is the translation looks like

00:21:54,000 --> 00:21:58,400
buffer this is a cache of the

00:21:55,919 --> 00:22:00,080
virtual address to physical address

00:21:58,400 --> 00:22:03,840
translation

00:22:00,080 --> 00:22:07,280
and this cache having um avoid having

00:22:03,840 --> 00:22:08,880
to go avoid diving via me to go through

00:22:07,280 --> 00:22:10,960
the entire page table to do the

00:22:08,880 --> 00:22:13,360
translation because the translation is

00:22:10,960 --> 00:22:16,480
already cached

00:22:13,360 --> 00:22:17,039
so when you switch you are required to

00:22:16,480 --> 00:22:19,440
flush

00:22:17,039 --> 00:22:21,039
the tlb and this has an impact on

00:22:19,440 --> 00:22:23,760
performance

00:22:21,039 --> 00:22:24,960
if if you don't know any special

00:22:23,760 --> 00:22:27,039
processing

00:22:24,960 --> 00:22:29,039
so now the intel processor they have

00:22:27,039 --> 00:22:32,480
some optimization which is the

00:22:29,039 --> 00:22:35,919
uh user process user context

00:22:32,480 --> 00:22:39,360
identifier the pcid um

00:22:35,919 --> 00:22:40,559
pcid that's a facility to associate to

00:22:39,360 --> 00:22:44,320
tlb entry

00:22:40,559 --> 00:22:45,679
with page table and the benefit is that

00:22:44,320 --> 00:22:48,720
it avoid

00:22:45,679 --> 00:22:49,280
flashing the entire page table or tlb

00:22:48,720 --> 00:22:52,840
you will

00:22:49,280 --> 00:22:55,280
just flush the tnb entry for your page

00:22:52,840 --> 00:22:58,720
table

00:22:55,280 --> 00:23:00,480
and so in in the implementation this is

00:22:58,720 --> 00:23:02,640
something we are taking into account so

00:23:00,480 --> 00:23:04,720
that we have

00:23:02,640 --> 00:23:09,840
an efficient page table switching

00:23:04,720 --> 00:23:09,840
mechanism when we enter and exit vsi

00:23:11,360 --> 00:23:15,760
so now we have created the page table we

00:23:14,240 --> 00:23:16,400
have a mechanism to switch the page

00:23:15,760 --> 00:23:18,720
table

00:23:16,400 --> 00:23:20,840
and now when we are running asi we need

00:23:18,720 --> 00:23:22,559
to be able to handle the entrapment the

00:23:20,840 --> 00:23:24,720
exception

00:23:22,559 --> 00:23:25,600
because yeah you still need to process

00:23:24,720 --> 00:23:28,400
them

00:23:25,600 --> 00:23:30,480
uh the problem is that you have asl you

00:23:28,400 --> 00:23:31,840
you have defined so your page table you

00:23:30,480 --> 00:23:34,320
have defined for af

00:23:31,840 --> 00:23:35,360
size may not necessarily have all the

00:23:34,320 --> 00:23:39,360
mapping to run

00:23:35,360 --> 00:23:43,360
the interrupt and exception handler

00:23:39,360 --> 00:23:46,480
so a simple solution for that is to

00:23:43,360 --> 00:23:49,679
suspend the asi when there is an

00:23:46,480 --> 00:23:51,760
interrupt process the interrupt and then

00:23:49,679 --> 00:23:54,880
re-enter vsi

00:23:51,760 --> 00:23:59,120
that's why the this drawing

00:23:54,880 --> 00:24:01,279
is showing so you start with some code

00:23:59,120 --> 00:24:02,400
running with asi there's an interrupt

00:24:01,279 --> 00:24:04,400
you switch you

00:24:02,400 --> 00:24:06,559
exit bsi switch to the kind of page

00:24:04,400 --> 00:24:10,080
table process the entire calendar

00:24:06,559 --> 00:24:10,400
when you are done you switch back to va

00:24:10,080 --> 00:24:14,320
sign

00:24:10,400 --> 00:24:17,919
and your code is going to continue

00:24:14,320 --> 00:24:20,080
that's a simple implementation we expect

00:24:17,919 --> 00:24:22,159
we can do better for some

00:24:20,080 --> 00:24:24,880
interrupt and exception handler because

00:24:22,159 --> 00:24:27,840
this mechanism require an additional

00:24:24,880 --> 00:24:27,840
page table switch

00:24:28,159 --> 00:24:33,039
so ideally we would like to be able to

00:24:30,960 --> 00:24:34,880
run the entrapment exception under with

00:24:33,039 --> 00:24:37,120
the aside page table

00:24:34,880 --> 00:24:39,200
of course this may not be always

00:24:37,120 --> 00:24:41,760
possible for particular android white

00:24:39,200 --> 00:24:45,200
it's better just to switch switch off to

00:24:41,760 --> 00:24:47,600
the to the kernel page table

00:24:45,200 --> 00:24:50,000
but still we can we can put in place a

00:24:47,600 --> 00:24:53,039
mechanism to do that

00:24:50,000 --> 00:24:55,120
so the idea is that the angler when

00:24:53,039 --> 00:24:57,840
there is an

00:24:55,120 --> 00:25:00,000
entrap the handler is going to start but

00:24:57,840 --> 00:25:01,200
it's not going to switch the page to the

00:25:00,000 --> 00:25:02,799
asi

00:25:01,200 --> 00:25:05,919
so it will continue to run with the

00:25:02,799 --> 00:25:05,919
aside page table

00:25:06,080 --> 00:25:11,760
obviously it can fail at some point

00:25:10,240 --> 00:25:13,840
because there is not the required

00:25:11,760 --> 00:25:14,960
mapping to do to do the processing in

00:25:13,840 --> 00:25:18,799
that case it's going to

00:25:14,960 --> 00:25:20,240
take a page fault and the solution there

00:25:18,799 --> 00:25:23,520
is to handle the fold

00:25:20,240 --> 00:25:26,799
and to do and switch advance point to

00:25:23,520 --> 00:25:26,799
the canon page table

00:25:27,440 --> 00:25:30,720
to continue the processes of the

00:25:29,840 --> 00:25:34,320
processing

00:25:30,720 --> 00:25:36,640
of the interrupt handler so here

00:25:34,320 --> 00:25:38,720
the figure is showing the ideal

00:25:36,640 --> 00:25:40,880
situation we've got code

00:25:38,720 --> 00:25:42,480
running with asi we take an end track we

00:25:40,880 --> 00:25:43,120
don't switch the page table and we

00:25:42,480 --> 00:25:45,919
continue

00:25:43,120 --> 00:25:49,120
and are able to process the entire the

00:25:45,919 --> 00:25:51,600
entire interrupt with asi

00:25:49,120 --> 00:25:52,240
when we are done with the interrupt

00:25:51,600 --> 00:25:54,240
return

00:25:52,240 --> 00:25:56,320
and we resume the execution of the code

00:25:54,240 --> 00:25:58,720
still with asi

00:25:56,320 --> 00:26:00,080
most of the time what is going to happen

00:25:58,720 --> 00:26:03,760
is this situation

00:26:00,080 --> 00:26:05,760
where we've got some code running we've

00:26:03,760 --> 00:26:08,799
got an interrupt

00:26:05,760 --> 00:26:11,760
uh we start processing via the interact

00:26:08,799 --> 00:26:13,279
with asi but at some point because we

00:26:11,760 --> 00:26:15,440
don't have all the mapping we are going

00:26:13,279 --> 00:26:17,840
to take a page fault in the asi

00:26:15,440 --> 00:26:19,760
so we go to the page for handler at this

00:26:17,840 --> 00:26:22,159
point we are switching to the canon page

00:26:19,760 --> 00:26:22,159
table

00:26:23,360 --> 00:26:26,799
and we retry and continue the interrupt

00:26:26,159 --> 00:26:29,760
handler

00:26:26,799 --> 00:26:32,320
with the kernel page table once we are

00:26:29,760 --> 00:26:36,480
done so we have processed the anterior

00:26:32,320 --> 00:26:38,799
entire interrupt part of it

00:26:36,480 --> 00:26:40,960
with vsi part of it with the canon page

00:26:38,799 --> 00:26:44,240
table but once we are done

00:26:40,960 --> 00:26:48,080
we return to vsi and the code continues

00:26:44,240 --> 00:26:51,200
its execution so it may be a way to

00:26:48,080 --> 00:26:54,960
to investigate which um

00:26:51,200 --> 00:26:58,159
which handler we can run um

00:26:54,960 --> 00:27:00,400
with asi and found which mapping we need

00:26:58,159 --> 00:27:02,159
to do the processing

00:27:00,400 --> 00:27:04,000
but that's basically an optimization

00:27:02,159 --> 00:27:05,520
we're trying to to be

00:27:04,000 --> 00:27:07,520
more efficient when there is an

00:27:05,520 --> 00:27:10,960
interrupt or exception

00:27:07,520 --> 00:27:10,960
while we are running an asi

00:27:11,840 --> 00:27:16,320
now there is a particular case like you

00:27:14,559 --> 00:27:19,520
have seen also with the

00:27:16,320 --> 00:27:23,039
page fault so

00:27:19,520 --> 00:27:24,559
if you have an asi and you don't have

00:27:23,039 --> 00:27:26,720
the mapping you're running away

00:27:24,559 --> 00:27:29,919
aside there's mapping which is not that

00:27:26,720 --> 00:27:34,240
you need which is not present in basi

00:27:29,919 --> 00:27:36,720
then a basic behavior is to exit vsi

00:27:34,240 --> 00:27:39,679
switch so there's page for the page for

00:27:36,720 --> 00:27:41,760
handler is going to exit bsi

00:27:39,679 --> 00:27:43,200
so switch to the canon page table and

00:27:41,760 --> 00:27:46,480
it's going to retry

00:27:43,200 --> 00:27:49,120
the instruction web of auto cure

00:27:46,480 --> 00:27:50,559
so basically we are executing the scion

00:27:49,120 --> 00:27:53,279
page fault

00:27:50,559 --> 00:27:55,360
um what we do in that case is that we

00:27:53,279 --> 00:27:56,080
log some information about the fault so

00:27:55,360 --> 00:27:59,840
that we can

00:27:56,080 --> 00:28:00,159
identify after after all what is missing

00:27:59,840 --> 00:28:04,480
in

00:28:00,159 --> 00:28:07,200
any va for nba cyan what as goes before

00:28:04,480 --> 00:28:09,279
and eventually after that we can add the

00:28:07,200 --> 00:28:10,960
missing mapping to be a sitepage table

00:28:09,279 --> 00:28:14,240
to prevent default

00:28:10,960 --> 00:28:17,120
so this is this is manual processing we

00:28:14,240 --> 00:28:20,720
have to look at blog figure out what's

00:28:17,120 --> 00:28:24,159
missing and then add the mapping

00:28:20,720 --> 00:28:27,360
we can certainly do better

00:28:24,159 --> 00:28:30,640
and there is some um

00:28:27,360 --> 00:28:32,640
automatic way to do this by

00:28:30,640 --> 00:28:34,960
automatically adding the missing mapping

00:28:32,640 --> 00:28:37,120
to the page table

00:28:34,960 --> 00:28:39,200
the only issue if we add the mapping

00:28:37,120 --> 00:28:39,760
automatically is that we need to ensure

00:28:39,200 --> 00:28:41,440
that

00:28:39,760 --> 00:28:44,399
it does not provide access to a

00:28:41,440 --> 00:28:47,919
sensitive data

00:28:44,399 --> 00:28:50,720
so if we have that we can

00:28:47,919 --> 00:28:51,760
add the mapping automatically and return

00:28:50,720 --> 00:28:53,919
to the asi

00:28:51,760 --> 00:28:55,200
so retry before the instruction and

00:28:53,919 --> 00:28:56,159
hopefully it will work and we'll

00:28:55,200 --> 00:28:59,360
continue

00:28:56,159 --> 00:29:02,640
and it will also avoid uh faulting

00:28:59,360 --> 00:29:04,399
again in the later on the same same

00:29:02,640 --> 00:29:07,840
problem

00:29:04,399 --> 00:29:11,520
um and to do that um

00:29:07,840 --> 00:29:13,760
we're also making usage of the um

00:29:11,520 --> 00:29:16,480
global non-sensitive flag i mentioned

00:29:13,760 --> 00:29:19,600
earlier about dynamic allocations

00:29:16,480 --> 00:29:20,399
if you have done if an allocation was

00:29:19,600 --> 00:29:22,880
done with

00:29:20,399 --> 00:29:24,159
that flag you know that this data is not

00:29:22,880 --> 00:29:27,120
sensitive

00:29:24,159 --> 00:29:28,240
and so you can automatically map it into

00:29:27,120 --> 00:29:30,720
vasi

00:29:28,240 --> 00:29:31,760
if there has been a fault on it so

00:29:30,720 --> 00:29:34,399
that's

00:29:31,760 --> 00:29:34,880
that's a way also to improve the mapping

00:29:34,399 --> 00:29:37,679
in an

00:29:34,880 --> 00:29:37,679
automatic way

00:29:39,360 --> 00:29:43,679
um what can happen also when you are

00:29:41,440 --> 00:29:45,600
using using asi is that you are being

00:29:43,679 --> 00:29:47,600
scheduled out

00:29:45,600 --> 00:29:50,240
and in that case the behavior would be

00:29:47,600 --> 00:29:52,320
fairly simple is that we interrupt vsi

00:29:50,240 --> 00:29:55,120
so it's going to exit vsi save the

00:29:52,320 --> 00:29:57,440
assign information for the task

00:29:55,120 --> 00:29:59,440
and once the task is scheduling then we

00:29:57,440 --> 00:30:03,279
are going to resume the aside that is

00:29:59,440 --> 00:30:07,440
enter the a sign again and with the

00:30:03,279 --> 00:30:09,840
information which were set for this task

00:30:07,440 --> 00:30:11,760
there's a bit of complexity if we secure

00:30:09,840 --> 00:30:12,640
during an interrupt an exception handler

00:30:11,760 --> 00:30:17,120
because the

00:30:12,640 --> 00:30:17,120
asi may have already been

00:30:17,520 --> 00:30:22,000
exited or interrupted so this is just

00:30:20,240 --> 00:30:24,880
thing we need to take into account into

00:30:22,000 --> 00:30:24,880
the implementation

00:30:25,919 --> 00:30:29,279
now a more complex mechanism that we are

00:30:28,399 --> 00:30:31,279
also using

00:30:29,279 --> 00:30:32,559
is the synchronization of course across

00:30:31,279 --> 00:30:34,880
cpu thread

00:30:32,559 --> 00:30:36,159
as i mentioned for kvm asi when you

00:30:34,880 --> 00:30:38,559
enter a kvm

00:30:36,159 --> 00:30:39,760
we need to make sure when you enter vm

00:30:38,559 --> 00:30:44,240
you need to make sure that the

00:30:39,760 --> 00:30:46,880
leaving cpu is also running the kbmaxi

00:30:44,240 --> 00:30:48,640
so we need a mechanism to force all cpu

00:30:46,880 --> 00:30:52,399
thread from cpu core to use

00:30:48,640 --> 00:30:54,399
a specified asi um and to do that we

00:30:52,399 --> 00:30:56,960
need this cpu

00:30:54,399 --> 00:30:58,320
to look at the other zebrain cpu if they

00:30:56,960 --> 00:31:00,159
are running asi or not

00:30:58,320 --> 00:31:03,120
if they are running inside then that's

00:31:00,159 --> 00:31:05,039
fine we can just continue to run

00:31:03,120 --> 00:31:06,640
the only thing is that they should not

00:31:05,039 --> 00:31:10,159
be allowed to to

00:31:06,640 --> 00:31:11,600
exit vasi because we want them to run

00:31:10,159 --> 00:31:13,279
aside

00:31:11,600 --> 00:31:14,720
if the sibling frame is not running

00:31:13,279 --> 00:31:17,760
aside then we need to

00:31:14,720 --> 00:31:21,360
force it to run

00:31:17,760 --> 00:31:24,640
and to do that we send um a rescue

00:31:21,360 --> 00:31:25,200
request and if the next stack is using

00:31:24,640 --> 00:31:28,080
asi

00:31:25,200 --> 00:31:30,000
then we can let it enter isi and run

00:31:28,080 --> 00:31:32,559
otherwise we need to

00:31:30,000 --> 00:31:34,799
enter aside but with weight in an idle

00:31:32,559 --> 00:31:34,799
loop

00:31:34,960 --> 00:31:41,039
so basically the mechanism is like

00:31:38,000 --> 00:31:44,159
this we've got the cpu in the middle

00:31:41,039 --> 00:31:47,279
which is running kvm

00:31:44,159 --> 00:31:52,080
suppose we have two sibling cpu

00:31:47,279 --> 00:31:54,799
uh so first the cpu running kvm

00:31:52,080 --> 00:31:56,240
uh at some point before entering the vm

00:31:54,799 --> 00:31:58,399
it's going to start this

00:31:56,240 --> 00:32:01,440
synchronization process and it's going

00:31:58,399 --> 00:32:04,720
to have a look so pick

00:32:01,440 --> 00:32:06,720
for asi if it is running on vr cpu

00:32:04,720 --> 00:32:09,200
in that case we can see that the trover

00:32:06,720 --> 00:32:10,080
cpu we are running asi so this is fine

00:32:09,200 --> 00:32:13,919
there is nothing

00:32:10,080 --> 00:32:14,880
to do and we can start the vmware cpu

00:32:13,919 --> 00:32:18,799
are running

00:32:14,880 --> 00:32:20,880
asi if one disabling cpu for example cpu

00:32:18,799 --> 00:32:23,279
to try to exit asi

00:32:20,880 --> 00:32:26,840
then we are going to block it it's going

00:32:23,279 --> 00:32:29,360
to be blocked in a sign and an idle loop

00:32:26,840 --> 00:32:32,880
until uh the main cpu

00:32:29,360 --> 00:32:35,120
exit the vm and stop the synchronization

00:32:32,880 --> 00:32:36,559
and this point is free to go into the

00:32:35,120 --> 00:32:38,480
kernel we have a

00:32:36,559 --> 00:32:42,399
cpu if it is running yes i will just

00:32:38,480 --> 00:32:46,799
continue to run

00:32:42,399 --> 00:32:48,240
if the um other cpu is not running asi

00:32:46,799 --> 00:32:50,640
that's

00:32:48,240 --> 00:32:52,080
there's a bit more complication because

00:32:50,640 --> 00:32:53,840
in that case we still

00:32:52,080 --> 00:32:56,320
still have the same beginning we stop

00:32:53,840 --> 00:32:59,600
the synchronization we look for

00:32:56,320 --> 00:33:01,440
asi and via the cpu in that case over

00:32:59,600 --> 00:33:04,080
cpu we are not running esi

00:33:01,440 --> 00:33:05,840
so we'll send a rescheduled request to

00:33:04,080 --> 00:33:08,640
this cpu

00:33:05,840 --> 00:33:10,000
so they will select a new task for

00:33:08,640 --> 00:33:12,240
example cpu 1 is going

00:33:10,000 --> 00:33:14,000
to select a task which is using ssi so

00:33:12,240 --> 00:33:15,679
that's fine it can enter asi and

00:33:14,000 --> 00:33:19,360
continue to run

00:33:15,679 --> 00:33:20,320
our cpu is picking a task which is not

00:33:19,360 --> 00:33:24,080
running asi

00:33:20,320 --> 00:33:26,559
so in that case we cannot run that task

00:33:24,080 --> 00:33:27,519
immediately instead we switch to asi and

00:33:26,559 --> 00:33:29,919
wait

00:33:27,519 --> 00:33:30,880
so at this point when both the sibling

00:33:29,919 --> 00:33:35,440
cpu

00:33:30,880 --> 00:33:37,519
grab enter asi we can run the vm safely

00:33:35,440 --> 00:33:39,039
once we are done with running the vm we

00:33:37,519 --> 00:33:42,320
stopped the synchronization

00:33:39,039 --> 00:33:44,240
so this for the cpu already running

00:33:42,320 --> 00:33:46,799
aside there's no impact

00:33:44,240 --> 00:33:47,279
but for a cpu which was in the either

00:33:46,799 --> 00:33:49,679
loop

00:33:47,279 --> 00:33:50,320
we stopped this loop and we can run the

00:33:49,679 --> 00:33:53,679
task

00:33:50,320 --> 00:33:55,760
which was not using asi so

00:33:53,679 --> 00:33:56,880
that's a bit of yeah there's a bit of

00:33:55,760 --> 00:34:00,480
complexity to do

00:33:56,880 --> 00:34:02,000
all this synchronization but and this is

00:34:00,480 --> 00:34:07,679
this is something we are still

00:34:02,000 --> 00:34:09,200
investigating and trying to to optimize

00:34:07,679 --> 00:34:10,960
another thing with this cpu

00:34:09,200 --> 00:34:12,720
synchronization is

00:34:10,960 --> 00:34:15,440
how do we handle the interrupt an

00:34:12,720 --> 00:34:18,320
exception especially

00:34:15,440 --> 00:34:20,560
if you need if there is another enter of

00:34:18,320 --> 00:34:23,359
exception and you need to exit asi

00:34:20,560 --> 00:34:25,440
and in that case we have to force all

00:34:23,359 --> 00:34:27,760
the evening cpu to interrupt

00:34:25,440 --> 00:34:31,040
so that everyone is going to stop can do

00:34:27,760 --> 00:34:31,040
the processing and interact

00:34:31,520 --> 00:34:38,159
and and so there there is

00:34:34,720 --> 00:34:39,599
a synchronization needed to when we do

00:34:38,159 --> 00:34:44,159
the processing of interrupt

00:34:39,599 --> 00:34:44,159
and we are synchronizing the va sign

00:34:44,240 --> 00:34:48,320
we are also going to look at what core

00:34:46,639 --> 00:34:51,679
scheduling is doing because

00:34:48,320 --> 00:34:54,639
they have a similar mechanism in place

00:34:51,679 --> 00:34:55,599
uh when when they got an interrupt on

00:34:54,639 --> 00:35:00,320
them

00:34:55,599 --> 00:35:00,320
on a call which is running a attack

00:35:00,839 --> 00:35:06,480
process

00:35:02,880 --> 00:35:08,400
um and now yeah we will have

00:35:06,480 --> 00:35:09,920
a bit more detail about the page level i

00:35:08,400 --> 00:35:13,119
would like to author continue

00:35:09,920 --> 00:35:15,280
about that thanks alex

00:35:13,119 --> 00:35:16,880
so now we'll give a brief discussion on

00:35:15,280 --> 00:35:18,720
how page tables look like

00:35:16,880 --> 00:35:20,400
uh there are probably several ways on

00:35:18,720 --> 00:35:23,119
how to manage page tables but this is

00:35:20,400 --> 00:35:26,160
one way that we're doing it right now

00:35:23,119 --> 00:35:27,680
uh and just like as a general

00:35:26,160 --> 00:35:29,760
background to kind of like ease into

00:35:27,680 --> 00:35:30,000
like why we design the page table as

00:35:29,760 --> 00:35:34,079
they

00:35:30,000 --> 00:35:34,079
are if we look in the next slide

00:35:35,119 --> 00:35:37,520
we have

00:35:38,160 --> 00:35:43,760
this is a rough description of uh what

00:35:41,760 --> 00:35:45,040
look how it looks like for kpti right

00:35:43,760 --> 00:35:48,160
when uh you

00:35:45,040 --> 00:35:50,320
when we're in user space only user space

00:35:48,160 --> 00:35:51,359
memory is mapped other than tiny bits of

00:35:50,320 --> 00:35:54,240
component

00:35:51,359 --> 00:35:54,640
memory when we switch into the kernel

00:35:54,240 --> 00:35:56,880
we're

00:35:54,640 --> 00:35:58,640
switching the page table into a page

00:35:56,880 --> 00:36:00,960
table that also has

00:35:58,640 --> 00:36:02,160
everything that the camera has which

00:36:00,960 --> 00:36:03,760
also belongs

00:36:02,160 --> 00:36:05,839
to all the processes in the system

00:36:03,760 --> 00:36:07,920
global variables obviously also kind of

00:36:05,839 --> 00:36:10,160
text

00:36:07,920 --> 00:36:12,079
and in kpti basically the idea is that

00:36:10,160 --> 00:36:13,280
privilege is based on whether you're in

00:36:12,079 --> 00:36:16,800
new zealand

00:36:13,280 --> 00:36:19,280
or in canon space and in asi

00:36:16,800 --> 00:36:20,160
this is uh slightly more nuanced so

00:36:19,280 --> 00:36:22,480
instead of like

00:36:20,160 --> 00:36:23,280
basically saying are you in canada space

00:36:22,480 --> 00:36:25,440
or not

00:36:23,280 --> 00:36:26,960
basically what we're saying is well

00:36:25,440 --> 00:36:29,760
we're defining privilege

00:36:26,960 --> 00:36:31,200
based on the data not necessarily on the

00:36:29,760 --> 00:36:33,599
execution net

00:36:31,200 --> 00:36:35,680
so we had for example on the right hand

00:36:33,599 --> 00:36:38,880
side user space page table

00:36:35,680 --> 00:36:41,680
and now we have uh in a simplified

00:36:38,880 --> 00:36:43,359
at least scenario two extra page tables

00:36:41,680 --> 00:36:45,359
the unrestricted page table which is

00:36:43,359 --> 00:36:46,720
basically what we used to think of

00:36:45,359 --> 00:36:49,200
the kernel page table which has

00:36:46,720 --> 00:36:51,200
everything and then we have the

00:36:49,200 --> 00:36:53,440
restricted page table which is the asi

00:36:51,200 --> 00:36:56,320
page table

00:36:53,440 --> 00:36:59,040
and the restricted page table only has

00:36:56,320 --> 00:37:01,280
mappings of non-sensitive data

00:36:59,040 --> 00:37:03,359
and the question is how do you define

00:37:01,280 --> 00:37:06,560
non-sensitive versus sensitive

00:37:03,359 --> 00:37:09,359
in general uh at least now we

00:37:06,560 --> 00:37:11,280
are hoping to use um kind of like an

00:37:09,359 --> 00:37:14,000
allow list approach of saying

00:37:11,280 --> 00:37:15,280
okay everything is a secret except for

00:37:14,000 --> 00:37:18,560
what we mean to be

00:37:15,280 --> 00:37:19,440
a non-secret or non-sensitive so this

00:37:18,560 --> 00:37:21,760
can be

00:37:19,440 --> 00:37:23,200
global and sensitive data or local and

00:37:21,760 --> 00:37:24,160
sensitive data which we'll talk about in

00:37:23,200 --> 00:37:26,720
a second

00:37:24,160 --> 00:37:27,920
but basically we're saying non-sensitive

00:37:26,720 --> 00:37:32,400
data is data that we are

00:37:27,920 --> 00:37:34,800
okay to if it's stolen if a

00:37:32,400 --> 00:37:37,359
malicious virtual machine tries to

00:37:34,800 --> 00:37:38,560
perform l1tf attack or mds attack to see

00:37:37,359 --> 00:37:40,720
that data

00:37:38,560 --> 00:37:43,040
uh stealing this data will not pose a

00:37:40,720 --> 00:37:45,520
threat to other virtual machines

00:37:43,040 --> 00:37:47,119
or to the cloud infrastructure and for

00:37:45,520 --> 00:37:49,839
performance reasons

00:37:47,119 --> 00:37:50,960
we clearly care about data that is

00:37:49,839 --> 00:37:54,480
frequently accessed

00:37:50,960 --> 00:37:56,240
in order to serve a vm exit because

00:37:54,480 --> 00:37:58,240
if data is being frequently accessed it

00:37:56,240 --> 00:38:00,000
means that if we will not

00:37:58,240 --> 00:38:01,680
uh put it in consider it is

00:38:00,000 --> 00:38:04,800
non-sensitive it means we will

00:38:01,680 --> 00:38:07,520
encore many asi exits and any asi exit

00:38:04,800 --> 00:38:10,560
obviously has a performance cost

00:38:07,520 --> 00:38:13,520
and now we can kind of like discuss a

00:38:10,560 --> 00:38:13,520
bit more in detail

00:38:13,680 --> 00:38:18,720
of that so as we said nonstick data can

00:38:16,640 --> 00:38:22,160
be accessed by lmdl for other

00:38:18,720 --> 00:38:24,240
uh information is thank you rx and

00:38:22,160 --> 00:38:25,680
we can discuss what does it mean to be

00:38:24,240 --> 00:38:27,680
local versus global data

00:38:25,680 --> 00:38:29,440
so local data as alex mentioned before

00:38:27,680 --> 00:38:32,640
it can be the vmcs

00:38:29,440 --> 00:38:36,079
maybe the file descriptor table

00:38:32,640 --> 00:38:39,200
anything that belongs to the

00:38:36,079 --> 00:38:42,160
specific vm and again we say if the vm

00:38:39,200 --> 00:38:43,280
tries to mount an attack to steal it

00:38:42,160 --> 00:38:44,960
maybe it's not ideal

00:38:43,280 --> 00:38:46,720
but doesn't necessarily cause a

00:38:44,960 --> 00:38:48,320
significant threat to other vms of

00:38:46,720 --> 00:38:52,000
infrastructure

00:38:48,320 --> 00:38:54,000
and global data is data that can be

00:38:52,000 --> 00:38:55,280
basically accessed by all virtual

00:38:54,000 --> 00:38:57,200
machines

00:38:55,280 --> 00:39:00,320
in the specific machine and if it's

00:38:57,200 --> 00:39:02,960
stolen there is no significant threat

00:39:00,320 --> 00:39:03,440
um and the nice thing about the global

00:39:02,960 --> 00:39:06,800
data

00:39:03,440 --> 00:39:08,400
is that we can share uh the pgd entries

00:39:06,800 --> 00:39:10,880
in the page table

00:39:08,400 --> 00:39:12,079
across all the different asi page tables

00:39:10,880 --> 00:39:13,839
and this gives us

00:39:12,079 --> 00:39:15,599
a really nice way to manage memory

00:39:13,839 --> 00:39:18,800
because uh

00:39:15,599 --> 00:39:21,040
if you think about uh local data and

00:39:18,800 --> 00:39:22,000
if we need to update the asi map we

00:39:21,040 --> 00:39:25,119
probably need to

00:39:22,000 --> 00:39:28,400
uh um update it

00:39:25,119 --> 00:39:30,720
uh across all the uh calls

00:39:28,400 --> 00:39:32,400
um that run the specific asi map and

00:39:30,720 --> 00:39:32,960
this is specifically a problem if you

00:39:32,400 --> 00:39:34,800
are

00:39:32,960 --> 00:39:37,040
deciding to unmap a piece of data from

00:39:34,800 --> 00:39:38,000
the asi map you probably need to flash

00:39:37,040 --> 00:39:41,040
the tlb

00:39:38,000 --> 00:39:45,119
for all calls or on the same asm app

00:39:41,040 --> 00:39:45,839
um and with the global data if we share

00:39:45,119 --> 00:39:50,240
pgds

00:39:45,839 --> 00:39:53,119
it means that we can edit uh

00:39:50,240 --> 00:39:54,480
like the global aside page table and we

00:39:53,119 --> 00:39:56,720
don't need to update even if we have

00:39:54,480 --> 00:39:58,240
hundreds or thousands of asi page tables

00:39:56,720 --> 00:39:59,680
we don't need to update them

00:39:58,240 --> 00:40:01,920
uh if they will have a page fault we

00:39:59,680 --> 00:40:03,920
will basically look to see if the page

00:40:01,920 --> 00:40:05,760
was in the area of the global and

00:40:03,920 --> 00:40:08,560
sensitive data and if it was

00:40:05,760 --> 00:40:10,160
we will just add the pgd entry and

00:40:08,560 --> 00:40:14,319
that's it

00:40:10,160 --> 00:40:17,440
um and i think now we can go

00:40:14,319 --> 00:40:20,880
to the next uh slide and talk about

00:40:17,440 --> 00:40:20,880
uh early results that we have

00:40:20,960 --> 00:40:26,160
so we have various implementations which

00:40:24,640 --> 00:40:28,480
we open to kind of like

00:40:26,160 --> 00:40:30,000
coalesce into one uh unified one but

00:40:28,480 --> 00:40:33,680
this one

00:40:30,000 --> 00:40:35,839
is one again um on elder spike ycsb

00:40:33,680 --> 00:40:36,720
uh benchmark and the first thing we can

00:40:35,839 --> 00:40:38,800
look at

00:40:36,720 --> 00:40:39,760
is the ratio of asi exits versus vm

00:40:38,800 --> 00:40:41,920
assets

00:40:39,760 --> 00:40:43,599
obviously ideally we want this ratio to

00:40:41,920 --> 00:40:45,280
be as low as possible let's say we had

00:40:43,599 --> 00:40:47,520
10 000 vm exits

00:40:45,280 --> 00:40:49,599
ideally we want only once or twice to

00:40:47,520 --> 00:40:53,520
touch something that forced us

00:40:49,599 --> 00:40:55,359
to do an ast exit uh we're not there yet

00:40:53,520 --> 00:40:55,760
but what you can see here in this data

00:40:55,359 --> 00:40:58,319
uh

00:40:55,760 --> 00:40:59,200
on the specific benchmark configuration

00:40:58,319 --> 00:41:02,560
again

00:40:59,200 --> 00:41:05,520
we had two vms and uh every vm

00:41:02,560 --> 00:41:06,000
had eight vcpus and if you look at

00:41:05,520 --> 00:41:08,880
what's

00:41:06,000 --> 00:41:10,960
uh circulating the red rectangle we can

00:41:08,880 --> 00:41:12,400
see the reaction between asi axis versus

00:41:10,960 --> 00:41:16,240
vm exits

00:41:12,400 --> 00:41:18,880
um it's between 20 and 50

00:41:16,240 --> 00:41:21,839
um which at least shows that we can

00:41:18,880 --> 00:41:24,800
implement asi in a way

00:41:21,839 --> 00:41:25,920
that we don't have to do an asi exit for

00:41:24,800 --> 00:41:28,240
every vmx

00:41:25,920 --> 00:41:30,720
and we believe that basically by adding

00:41:28,240 --> 00:41:33,680
more and more data into the asi

00:41:30,720 --> 00:41:36,240
page table we can hopefully reduce it to

00:41:33,680 --> 00:41:38,400
a very low number hopefully in the low

00:41:36,240 --> 00:41:39,520
in the lows uh two percent three percent

00:41:38,400 --> 00:41:41,920
five percent

00:41:39,520 --> 00:41:42,560
so the performance impact of asi will

00:41:41,920 --> 00:41:45,760
not be

00:41:42,560 --> 00:41:47,040
uh too significant so if you go to the

00:41:45,760 --> 00:41:51,440
next slide

00:41:47,040 --> 00:41:53,680
um we can start uh

00:41:51,440 --> 00:41:57,040
seeing uh how can we analyze what caused

00:41:53,680 --> 00:42:00,240
the vm the asi exits i think that's uh

00:41:57,040 --> 00:42:02,000
one of the one of the big challenges in

00:42:00,240 --> 00:42:04,000
asi is kind of like okay what exactly

00:42:02,000 --> 00:42:06,319
do you need to put inside your page

00:42:04,000 --> 00:42:07,520
table and as we said before whenever we

00:42:06,319 --> 00:42:10,400
have an asi

00:42:07,520 --> 00:42:12,000
exit we can log this information and if

00:42:10,400 --> 00:42:12,400
we look briefly at the columns like on

00:42:12,000 --> 00:42:14,240
the

00:42:12,400 --> 00:42:16,400
on the left side you see the instruction

00:42:14,240 --> 00:42:17,520
pointer which instruction pointer caused

00:42:16,400 --> 00:42:20,079
the page fault

00:42:17,520 --> 00:42:21,599
because the asi exit we can look at the

00:42:20,079 --> 00:42:23,599
address

00:42:21,599 --> 00:42:25,119
what was accessed and then we can start

00:42:23,599 --> 00:42:26,560
and do some analysis

00:42:25,119 --> 00:42:28,240
so if you look at the middle column

00:42:26,560 --> 00:42:29,760
which is accessor is basically

00:42:28,240 --> 00:42:31,359
an interpretation of the instruction

00:42:29,760 --> 00:42:34,880
painter saying

00:42:31,359 --> 00:42:36,560
okay what source line access this data

00:42:34,880 --> 00:42:38,079
and if we go to the next column called

00:42:36,560 --> 00:42:41,200
allocator it's basically

00:42:38,079 --> 00:42:44,560
our framework trying to interpret

00:42:41,200 --> 00:42:46,880
okay who allocated this data

00:42:44,560 --> 00:42:47,839
and this is very useful because then if

00:42:46,880 --> 00:42:51,440
we see

00:42:47,839 --> 00:42:53,200
which code allocated this data we can

00:42:51,440 --> 00:42:56,240
maybe say something smart whether this

00:42:53,200 --> 00:42:58,240
data is sensitive or non-sensitive

00:42:56,240 --> 00:43:00,079
and hopefully we can decide it's

00:42:58,240 --> 00:43:02,480
non-sensitive data and add

00:43:00,079 --> 00:43:04,400
the flag like gfp location sensitive or

00:43:02,480 --> 00:43:06,960
gfp global non-sensitive

00:43:04,400 --> 00:43:08,880
uh to edit so next time that will rerun

00:43:06,960 --> 00:43:11,599
the benchmark of the experiment

00:43:08,880 --> 00:43:14,000
it will already be in the asi map and it

00:43:11,599 --> 00:43:15,440
will not cause asi exits

00:43:14,000 --> 00:43:19,119
we can even do a little bit of more

00:43:15,440 --> 00:43:19,119
analysis if we go to the next slide

00:43:22,400 --> 00:43:26,880
so for example we can look at the

00:43:24,960 --> 00:43:30,000
allocators

00:43:26,880 --> 00:43:32,560
and kind of like uh see which

00:43:30,000 --> 00:43:33,280
uh allocators were the mo the most

00:43:32,560 --> 00:43:36,640
common

00:43:33,280 --> 00:43:39,520
because asi exit um

00:43:36,640 --> 00:43:40,000
and okay the top one is something that

00:43:39,520 --> 00:43:42,160
we

00:43:40,000 --> 00:43:43,520
couldn't infer who allocated it but

00:43:42,160 --> 00:43:45,760
again we can look at the data

00:43:43,520 --> 00:43:47,520
see which source line accessed it and

00:43:45,760 --> 00:43:50,079
maybe say something about it

00:43:47,520 --> 00:43:51,040
but if we look below we see for example

00:43:50,079 --> 00:43:54,240
the second place

00:43:51,040 --> 00:43:56,960
is uh basically allocating

00:43:54,240 --> 00:43:57,359
uh pmu uh context basically health

00:43:56,960 --> 00:44:00,400
events

00:43:57,359 --> 00:44:02,800
context which potentially we can argue

00:44:00,400 --> 00:44:04,319
that uh the context of uh pair of events

00:44:02,800 --> 00:44:04,880
maybe is not that sensitive and you can

00:44:04,319 --> 00:44:08,560
try

00:44:04,880 --> 00:44:10,160
and say okay those allocations we can

00:44:08,560 --> 00:44:13,920
consider to be non-sensitive

00:44:10,160 --> 00:44:16,560
and add into asi um we can see

00:44:13,920 --> 00:44:19,520
i think it's uh the fourth line here you

00:44:16,560 --> 00:44:21,040
see sdlc size that's a global variable

00:44:19,520 --> 00:44:23,200
that apparently was accessed quite

00:44:21,040 --> 00:44:24,640
frequent and we can look at it and say

00:44:23,200 --> 00:44:27,599
okay this global variable

00:44:24,640 --> 00:44:30,160
is probably not that sensitive just

00:44:27,599 --> 00:44:32,720
basically says what the lsc size is

00:44:30,160 --> 00:44:34,160
uh so we can add the tag of a assignment

00:44:32,720 --> 00:44:36,560
not sensitive

00:44:34,160 --> 00:44:38,560
and that way we can have an integrity uh

00:44:36,560 --> 00:44:40,720
process of saying okay we want an allow

00:44:38,560 --> 00:44:43,760
list we want to only have an asi

00:44:40,720 --> 00:44:46,000
data that begin to be done sensitive uh

00:44:43,760 --> 00:44:48,079
and we can use this debug framework to

00:44:46,000 --> 00:44:50,319
give us some visibility as to

00:44:48,079 --> 00:44:52,720
what actually causes six and hopefully

00:44:50,319 --> 00:44:55,359
by doing this utility process

00:44:52,720 --> 00:44:57,280
uh we can add more and more data uh to

00:44:55,359 --> 00:45:00,560
get better embedded performance

00:44:57,280 --> 00:45:03,040
uh for aside um

00:45:00,560 --> 00:45:04,480
now alex is gonna talk about the coin

00:45:03,040 --> 00:45:07,520
status

00:45:04,480 --> 00:45:07,520
of the ast project

00:45:07,920 --> 00:45:14,000
thanks so just a quick story of

00:45:11,599 --> 00:45:14,960
where we are coming from with asi so the

00:45:14,000 --> 00:45:18,800
idea was

00:45:14,960 --> 00:45:21,280
suggested after the i1tf speculation i

00:45:18,800 --> 00:45:21,839
attacked discovery this was yeah by the

00:45:21,280 --> 00:45:24,240
end of

00:45:21,839 --> 00:45:25,839
2008 there was first presentation like

00:45:24,240 --> 00:45:29,040
kvm forum

00:45:25,839 --> 00:45:32,720
it's mostly inspired from a fix that

00:45:29,040 --> 00:45:36,240
microsoft has done in their hyper-v

00:45:32,720 --> 00:45:37,119
for their ipov mitigation we had more

00:45:36,240 --> 00:45:41,760
discussion

00:45:37,119 --> 00:45:45,280
at linux stronger in 2019

00:45:41,760 --> 00:45:47,680
and also first development

00:45:45,280 --> 00:45:48,560
where started at oracle where we have

00:45:47,680 --> 00:45:52,000
submitted uh

00:45:48,560 --> 00:45:55,359
several rfc there was a rfc

00:45:52,000 --> 00:45:58,240
v1 which was very kb and specific

00:45:55,359 --> 00:45:59,440
and the common from upstream that was

00:45:58,240 --> 00:46:01,920
that we needed something

00:45:59,440 --> 00:46:04,160
more generic so that's what the version

00:46:01,920 --> 00:46:07,599
two has proposed

00:46:04,160 --> 00:46:12,560
um which provides a knife si

00:46:07,599 --> 00:46:15,440
framework and kvm is just a consumer

00:46:12,560 --> 00:46:16,400
v3 was the integration with pti this was

00:46:15,440 --> 00:46:19,440
another command

00:46:16,400 --> 00:46:22,319
wave upstream that asi is similar to

00:46:19,440 --> 00:46:25,520
what pti is doing so we should be using

00:46:22,319 --> 00:46:29,119
asi to implement vti

00:46:25,520 --> 00:46:32,640
as we have a generic framework framework

00:46:29,119 --> 00:46:33,359
um v3 added some page table management

00:46:32,640 --> 00:46:35,520
function

00:46:33,359 --> 00:46:36,560
which might not be the final solution we

00:46:35,520 --> 00:46:39,920
are going to but

00:46:36,560 --> 00:46:43,520
this was a first try there was a

00:46:39,920 --> 00:46:44,000
v5 which was supposed to be released

00:46:43,520 --> 00:46:47,599
after

00:46:44,000 --> 00:46:50,880
a linux plumber this year

00:46:47,599 --> 00:46:51,839
but so this was adding vsi

00:46:50,880 --> 00:46:55,440
synchronization

00:46:51,839 --> 00:46:58,240
in addition of v4

00:46:55,440 --> 00:46:59,040
but at linux plumber there was also this

00:46:58,240 --> 00:47:01,520
um

00:46:59,040 --> 00:47:03,359
a presentation from google of a

00:47:01,520 --> 00:47:05,599
different implementation

00:47:03,359 --> 00:47:07,280
so since then we are working together to

00:47:05,599 --> 00:47:09,440
go to common solution

00:47:07,280 --> 00:47:11,440
instead of developing our own

00:47:09,440 --> 00:47:13,680
implementation

00:47:11,440 --> 00:47:15,599
so really the work we are doing now is

00:47:13,680 --> 00:47:16,640
some collaboration between oracle and

00:47:15,599 --> 00:47:18,400
google

00:47:16,640 --> 00:47:20,400
to define a common solution and to

00:47:18,400 --> 00:47:23,040
convert our implementation

00:47:20,400 --> 00:47:24,720
so we have something to there's a lot of

00:47:23,040 --> 00:47:27,359
work to do especially around

00:47:24,720 --> 00:47:28,400
yeah how we do the page table management

00:47:27,359 --> 00:47:30,720
what

00:47:28,400 --> 00:47:32,480
uh what would be the solution we're

00:47:30,720 --> 00:47:34,640
going to to manage the interrupt the

00:47:32,480 --> 00:47:36,400
head section the page fault how do we do

00:47:34,640 --> 00:47:38,400
the

00:47:36,400 --> 00:47:39,599
synchronization of the cpu threads with

00:47:38,400 --> 00:47:42,800
cpu stunning

00:47:39,599 --> 00:47:43,520
uh we need to look at what's happening

00:47:42,800 --> 00:47:45,680
also on the

00:47:43,520 --> 00:47:47,200
core scheduling side where they also

00:47:45,680 --> 00:47:50,880
have a

00:47:47,200 --> 00:47:51,839
cpu stunning mechanism and also there is

00:47:50,880 --> 00:47:54,559
the

00:47:51,839 --> 00:47:56,800
pti integration to investigate because

00:47:54,559 --> 00:47:59,760
of the different implementation

00:47:56,800 --> 00:48:02,000
but the goal is really to provide um and

00:47:59,760 --> 00:48:05,359
to upstream a common implementation and

00:48:02,000 --> 00:48:09,119
not to have different implementation

00:48:05,359 --> 00:48:11,440
um so there's a lot of work to do

00:48:09,119 --> 00:48:14,240
we also preparing some predominant

00:48:11,440 --> 00:48:17,839
preliminary work which is to

00:48:14,240 --> 00:48:18,319
def related to pti which is going to

00:48:17,839 --> 00:48:20,640
help

00:48:18,319 --> 00:48:21,359
and simplify the support of asi which is

00:48:20,640 --> 00:48:24,640
to defer

00:48:21,359 --> 00:48:26,480
some page table switching that pti is

00:48:24,640 --> 00:48:27,839
doing currently in assembly code to c

00:48:26,480 --> 00:48:31,760
code

00:48:27,839 --> 00:48:34,880
so so we are doing a lot of

00:48:31,760 --> 00:48:38,480
collaboration and there is but there's

00:48:34,880 --> 00:48:38,480
still a lot to do at the moment

00:48:39,839 --> 00:48:42,880
so that's that's it for this

00:48:41,680 --> 00:48:45,920
presentation

00:48:42,880 --> 00:48:46,319
and uh thanks for uh your attention if

00:48:45,920 --> 00:48:49,280
you

00:48:46,319 --> 00:48:49,839
if you went that far and hopefully we'll

00:48:49,280 --> 00:48:52,480
have some

00:48:49,839 --> 00:48:53,119
opportunity to get some feedback and

00:48:52,480 --> 00:48:56,240
questions

00:48:53,119 --> 00:48:57,599
at the kbm forum offi is there anything

00:48:56,240 --> 00:49:00,079
you want to add

00:48:57,599 --> 00:49:02,720
uh no thank you very much alex uh we'd

00:49:00,079 --> 00:49:13,440
be happy to take questions

00:49:02,720 --> 00:49:13,440

YouTube URL: https://www.youtube.com/watch?v=sI4AIYiwW6Q


