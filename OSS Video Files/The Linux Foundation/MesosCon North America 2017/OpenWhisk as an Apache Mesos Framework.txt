Title: OpenWhisk as an Apache Mesos Framework
Publication date: 2017-09-18
Playlist: MesosCon North America 2017
Description: 
	OpenWhisk as an Apache Mesos Framework - Tyson Norris & Dragos Dascalita Haut, Adobe Systems, Inc.

OpenWhisk is quickly gaining momentum as a serverless platform, where function developers can deploy their executable code (or even docker containers), without having to manage builds or servers or monitoring or all the things required to host a conventional web application. To date, it has not been possible to leverage the cluster-wide scheduling facilities for running functions via OpenWhisk. We will present a Mesos framework for efficiently leveraging cluster resources for use by OpenWhisk functions, and trace the evolution of this framework from web application, to Mesos framework, and finally to DC/OS package based on dcos-commons.

About

Tyson Norris
Adobe Systems, Inc.
Tyson Norris is a Sr. Computer Scientist at Adobe Systems, where he works on the Adobe I/O Runtime project. He has been building web applications for 20 years, at Adobe for the last 7.


Dragos Dascalita Haut
Adobe Systems, Inc.
Project Lead, Adobe I/O
Dragos Dascalita Haut is working as Project Lead for Adobe I/O, working with his team in Romania, India and his hometown San Jose on scaling Adobeâ€™s APIs using a distributed serverless platform. Dragos prefers dynamic programming languages over static ones, dogs over cats, and like a true cloud-native developer, has not hesitation taking on challenges of scale, like fighting 100 duck-sized horses.
Captions: 
	00:00:00,179 --> 00:00:04,620
we're going to be talking about a new

00:00:02,100 --> 00:00:08,730
Apache project which is called open

00:00:04,620 --> 00:00:11,910
whisk is this a new project to you and

00:00:08,730 --> 00:00:14,820
did anyone hear about open whisk cool

00:00:11,910 --> 00:00:19,859
alright so it's not really really really

00:00:14,820 --> 00:00:22,230
new open whisk is an Apache incubating

00:00:19,859 --> 00:00:26,039
project it's a server less open source

00:00:22,230 --> 00:00:30,570
cloud platform that executes functions

00:00:26,039 --> 00:00:33,149
in response to events so why is it that

00:00:30,570 --> 00:00:35,820
we are at a message conference managing

00:00:33,149 --> 00:00:39,420
servers and yet we're talking about

00:00:35,820 --> 00:00:41,879
server lists and I have three factors

00:00:39,420 --> 00:00:43,710
that I think are important when we think

00:00:41,879 --> 00:00:46,350
of several aside I would say the first

00:00:43,710 --> 00:00:49,590
one that is a driving factor for service

00:00:46,350 --> 00:00:52,829
is the user experiences we're probably

00:00:49,590 --> 00:00:55,800
still familiar with those old times I

00:00:52,829 --> 00:00:58,559
should say once upon a time where this

00:00:55,800 --> 00:01:00,629
big desktop machines and the user

00:00:58,559 --> 00:01:03,809
experience was limited to their to that

00:01:00,629 --> 00:01:05,489
desktop machine then we had some modems

00:01:03,809 --> 00:01:09,710
and then we had a little bit of

00:01:05,489 --> 00:01:12,299
connectivity and we had this big

00:01:09,710 --> 00:01:15,030
applications in the backend then mobile

00:01:12,299 --> 00:01:17,009
apps came into the picture really cool

00:01:15,030 --> 00:01:19,439
we poured some of the DES capabilities

00:01:17,009 --> 00:01:21,840
on the mobile and in the server it also

00:01:19,439 --> 00:01:22,830
made sense to split the monoliths into

00:01:21,840 --> 00:01:26,600
smaller pieces

00:01:22,830 --> 00:01:31,280
I believe that starting with this year

00:01:26,600 --> 00:01:35,360
were we're seeing something new coming

00:01:31,280 --> 00:01:41,520
and that's mainly driven by voice AR and

00:01:35,360 --> 00:01:43,399
VR I think that these three are probably

00:01:41,520 --> 00:01:48,360
going to dominate the next generation of

00:01:43,399 --> 00:01:50,970
user experiences so one particular thing

00:01:48,360 --> 00:01:53,700
about voice is that interactions are

00:01:50,970 --> 00:01:56,430
shorter you could be in your hotel room

00:01:53,700 --> 00:01:59,159
and maybe speak with the digital

00:01:56,430 --> 00:02:02,159
assistant check on the weather check on

00:01:59,159 --> 00:02:07,110
local events restaurants which ones are

00:02:02,159 --> 00:02:09,810
popular make a reservation maybe call

00:02:07,110 --> 00:02:12,209
the reception desk whatever you know

00:02:09,810 --> 00:02:13,800
short interactions but in these few

00:02:12,209 --> 00:02:15,540
examples that I gave with my voice

00:02:13,800 --> 00:02:19,320
I was able to touch on so many systems

00:02:15,540 --> 00:02:25,110
where the reservations events hotel

00:02:19,320 --> 00:02:28,520
services so voice is pretty magical but

00:02:25,110 --> 00:02:31,560
not all experiences are real time

00:02:28,520 --> 00:02:33,150
imagine that we're at an event and we

00:02:31,560 --> 00:02:34,920
use the phone we take pictures

00:02:33,150 --> 00:02:37,020
those pictures are synchronous i

00:02:34,920 --> 00:02:39,660
synchronously copied into the cloud

00:02:37,020 --> 00:02:42,540
backed up and then while there into the

00:02:39,660 --> 00:02:44,370
cloud there is a whole process happening

00:02:42,540 --> 00:02:47,490
we have workers that can look at the

00:02:44,370 --> 00:02:49,740
pictures we have those events queued

00:02:47,490 --> 00:02:52,290
into a queue and then from the queue

00:02:49,740 --> 00:02:53,520
microservice consumes events processes

00:02:52,290 --> 00:02:56,210
them and maybe looks at the peaches

00:02:53,520 --> 00:03:02,940
where was it taken face recognition

00:02:56,210 --> 00:03:04,590
friends and and so on so I guess the

00:03:02,940 --> 00:03:06,480
point I'm trying to make is that the the

00:03:04,590 --> 00:03:07,890
richer and the more diverse the user

00:03:06,480 --> 00:03:10,980
experience is the more complex the

00:03:07,890 --> 00:03:13,800
services in the backend become and I'm

00:03:10,980 --> 00:03:16,260
really building a case for several is

00:03:13,800 --> 00:03:19,500
here so if you bear with me so the first

00:03:16,260 --> 00:03:22,380
the first factor user experiences the

00:03:19,500 --> 00:03:24,630
second one and we are familiar with this

00:03:22,380 --> 00:03:27,570
one the time how long it takes right now

00:03:24,630 --> 00:03:31,560
to provision some compute capacity we

00:03:27,570 --> 00:03:34,850
went from days if not more to provision

00:03:31,560 --> 00:03:37,200
bare-metal servers to VMs minutes

00:03:34,850 --> 00:03:41,220
probably seconds in some cases about

00:03:37,200 --> 00:03:43,770
also rather minutes then containers and

00:03:41,220 --> 00:03:45,510
I'm sure using medals were very familiar

00:03:43,770 --> 00:03:47,520
and excited with with these containers

00:03:45,510 --> 00:03:51,660
well so serverless

00:03:47,520 --> 00:03:53,910
is just a tiny little step forward on

00:03:51,660 --> 00:03:55,500
how much it takes to provision resources

00:03:53,910 --> 00:03:59,940
and we're going to look at some real

00:03:55,500 --> 00:04:01,200
them was this evening the last point

00:03:59,940 --> 00:04:02,280
that I want to bring is product the

00:04:01,200 --> 00:04:07,200
extensibility

00:04:02,280 --> 00:04:10,200
this is particularly spoken about I

00:04:07,200 --> 00:04:13,680
would say general service platforms like

00:04:10,200 --> 00:04:15,900
Amazon lambda as your functions that

00:04:13,680 --> 00:04:17,400
will be I would categorize it as general

00:04:15,900 --> 00:04:20,190
purpose server list but there's cases

00:04:17,400 --> 00:04:21,660
and adobe falls under this case where we

00:04:20,190 --> 00:04:23,610
have a platform we have services in the

00:04:21,660 --> 00:04:26,030
cloud and we want to make it easy for

00:04:23,610 --> 00:04:28,490
developers to be able to extend them

00:04:26,030 --> 00:04:30,590
and we started with API is like anybody

00:04:28,490 --> 00:04:33,350
else right API is great

00:04:30,590 --> 00:04:36,980
then we've went into the real time

00:04:33,350 --> 00:04:39,260
aspect we realize that there are events

00:04:36,980 --> 00:04:41,060
people creatives put pictures into the

00:04:39,260 --> 00:04:43,370
Creative Cloud they generate events and

00:04:41,060 --> 00:04:45,380
we said yeah we're gonna make not just

00:04:43,370 --> 00:04:48,050
api's but web hooks and they're great

00:04:45,380 --> 00:04:50,360
but web hooks they even though they're

00:04:48,050 --> 00:04:52,490
they're simple you still need to care

00:04:50,360 --> 00:04:54,160
about what's happening how in how do you

00:04:52,490 --> 00:04:56,720
handle the web hook and the event and

00:04:54,160 --> 00:04:59,750
server list provides an answer to this

00:04:56,720 --> 00:05:01,730
so server list gives not just Adobe but

00:04:59,750 --> 00:05:05,150
whoever wants to install such a platform

00:05:01,730 --> 00:05:07,370
the capability for developers to write a

00:05:05,150 --> 00:05:10,250
piece of code extend the platform and

00:05:07,370 --> 00:05:14,030
integrated with any other SAS systems

00:05:10,250 --> 00:05:16,419
that they're interested in after these

00:05:14,030 --> 00:05:21,830
three I would say that the motor apps

00:05:16,419 --> 00:05:24,680
have a richer UX are smaller composable

00:05:21,830 --> 00:05:27,080
and have this real-time aspect and

00:05:24,680 --> 00:05:29,240
without further ado I'm gonna jump into

00:05:27,080 --> 00:05:31,610
the first of the four demos that we're

00:05:29,240 --> 00:05:35,810
going to run today and I'm going to show

00:05:31,610 --> 00:05:39,020
an example with Adobe Analytics and I'm

00:05:35,810 --> 00:05:42,470
going to use my voice to get some data

00:05:39,020 --> 00:05:44,419
out of course I'm limited to the

00:05:42,470 --> 00:05:47,240
Internet so I hope it works I have on my

00:05:44,419 --> 00:05:49,700
phone an Alexa user interface it's an

00:05:47,240 --> 00:05:53,630
application called reverb and I'm going

00:05:49,700 --> 00:05:55,490
to have a dialogue with Alexa I wouldn't

00:05:53,630 --> 00:05:58,460
ask if you are using Adobe Analytics I

00:05:55,490 --> 00:06:01,610
will assume we didn't use but I saw

00:05:58,460 --> 00:06:04,490
happen that somebody installed Adobe

00:06:01,610 --> 00:06:06,470
Analytics in my in my webpage and now I

00:06:04,490 --> 00:06:09,169
want to I'm curious how many pages I got

00:06:06,470 --> 00:06:10,669
last week or visitors so without having

00:06:09,169 --> 00:06:15,669
without being skilled on the user

00:06:10,669 --> 00:06:15,669
interface I'm just gonna ask Alex am so

00:06:16,000 --> 00:06:25,669
Alexa asked Adobe Analytics welcome to

00:06:23,270 --> 00:06:29,030
Adobe Analytics which reports suite

00:06:25,669 --> 00:06:34,870
would you like to use some at demo 2017

00:06:29,030 --> 00:06:34,870
template report suite demo

00:06:35,310 --> 00:06:44,110
okay using the summit demo 2017 report

00:06:39,280 --> 00:06:51,490
sweet how can I help you how many page

00:06:44,110 --> 00:06:57,760
views last week the total number of page

00:06:51,490 --> 00:07:04,360
views is 1658 how many visitors last

00:06:57,760 --> 00:07:11,680
month the total number of visitors last

00:07:04,360 --> 00:07:15,040
month was 11,000 799 thank you alright

00:07:11,680 --> 00:07:16,960
so as you can see I just showcase some

00:07:15,040 --> 00:07:19,780
very simple things that we could do with

00:07:16,960 --> 00:07:22,780
several s and this runs the demo runs in

00:07:19,780 --> 00:07:25,150
open Wisc by the way and you know I just

00:07:22,780 --> 00:07:26,620
demoed a very simple interaction is

00:07:25,150 --> 00:07:31,300
real-time I was able to get an answer

00:07:26,620 --> 00:07:33,850
back from a very complex system this is

00:07:31,300 --> 00:07:36,940
what happened I gave a voice command it

00:07:33,850 --> 00:07:38,710
went to the echo Amazon echo it's

00:07:36,940 --> 00:07:42,160
circled back to Adobe IO I got a

00:07:38,710 --> 00:07:44,830
response back right now

00:07:42,160 --> 00:07:47,229
let's look a little bit inside Apache

00:07:44,830 --> 00:07:51,060
open whisk and I'm going to hand the

00:07:47,229 --> 00:07:53,620
microphone over to Tyson my colleague

00:07:51,060 --> 00:07:55,660
we're both working for this team in

00:07:53,620 --> 00:07:57,280
Adobe that is called Adobe I own and

00:07:55,660 --> 00:08:01,140
wear the interface between Adobe

00:07:57,280 --> 00:08:05,440
services and third-party developers

00:08:01,140 --> 00:08:09,270
thank you so I want to talk a little bit

00:08:05,440 --> 00:08:11,910
about what open was is how it works and

00:08:09,270 --> 00:08:18,280
the kind of steps that we're taking to

00:08:11,910 --> 00:08:23,289
leverage mesas underneath it so some of

00:08:18,280 --> 00:08:25,150
this is kind of marketing speak for open

00:08:23,289 --> 00:08:27,130
whisk but Apache open whisk is a

00:08:25,150 --> 00:08:29,500
serverless open source cloud platform

00:08:27,130 --> 00:08:34,839
that executes functions in response to

00:08:29,500 --> 00:08:37,659
events in docker containers and part of

00:08:34,839 --> 00:08:41,500
what it provides is a command line and a

00:08:37,659 --> 00:08:45,640
API for function management so really it

00:08:41,500 --> 00:08:48,580
gives you the vehicle to deploy pieces

00:08:45,640 --> 00:08:52,530
of code whether they're small or large

00:08:48,580 --> 00:08:55,780
into docker containers in a generic way

00:08:52,530 --> 00:08:59,020
so I want to talk a little bit about

00:08:55,780 --> 00:09:01,060
some some concepts and terminology that

00:08:59,020 --> 00:09:05,020
are used in open Wis to kind of outline

00:09:01,060 --> 00:09:10,380
how we have started leveraging them asos

00:09:05,020 --> 00:09:14,230
within so this is a simplistic

00:09:10,380 --> 00:09:16,840
architecture diagram of open Wisc how it

00:09:14,230 --> 00:09:22,500
operates without meso s-- in the picture

00:09:16,840 --> 00:09:25,810
so you can see from a internet

00:09:22,500 --> 00:09:27,700
connection there's the first entry point

00:09:25,810 --> 00:09:31,750
into the open West system is to the

00:09:27,700 --> 00:09:33,550
controller this is for the execution

00:09:31,750 --> 00:09:35,440
type of workflow not the function

00:09:33,550 --> 00:09:38,260
administration workflow but for

00:09:35,440 --> 00:09:40,810
execution events come in and are acute

00:09:38,260 --> 00:09:43,030
in Kafka and eventually they're they're

00:09:40,810 --> 00:09:45,460
processed by a component that's called

00:09:43,030 --> 00:09:49,420
an open with as the invoker and the

00:09:45,460 --> 00:09:52,210
invoker natively speaks to docker client

00:09:49,420 --> 00:09:55,320
and launches containers execute

00:09:52,210 --> 00:09:58,200
functions based on the requests

00:09:55,320 --> 00:10:00,790
resubmits the response back to Kafka

00:09:58,200 --> 00:10:02,830
responses picked up by the controller

00:10:00,790 --> 00:10:05,560
and sent back to the client if there's

00:10:02,830 --> 00:10:07,630
somebody waiting or it just keeps the

00:10:05,560 --> 00:10:12,850
response for itself if nobody's waiting

00:10:07,630 --> 00:10:17,080
for it so this is fine but let's talk

00:10:12,850 --> 00:10:20,500
about open with scaling so in order to

00:10:17,080 --> 00:10:24,430
add him invoker what happens is this

00:10:20,500 --> 00:10:27,790
whole invoker host block in the diagram

00:10:24,430 --> 00:10:30,790
gets duplicated another topic on the

00:10:27,790 --> 00:10:33,640
Kafka broker gets created and the

00:10:30,790 --> 00:10:36,220
controller has to manage knowing how

00:10:33,640 --> 00:10:38,590
many invoker's are in the system's what

00:10:36,220 --> 00:10:41,320
actions have been executed so that there

00:10:38,590 --> 00:10:48,870
can be some amount of optimization on

00:10:41,320 --> 00:10:51,220
routing but it's not it's not easy so

00:10:48,870 --> 00:10:55,060
what I was just talking about like when

00:10:51,220 --> 00:10:57,310
you add it when you add the invoker he

00:10:55,060 --> 00:10:59,680
advertises himself in Kafka that's how

00:10:57,310 --> 00:11:03,089
the controller discovers monitors

00:10:59,680 --> 00:11:07,329
monitors its health via Kafka

00:11:03,089 --> 00:11:10,269
but why we're all here because we're a

00:11:07,329 --> 00:11:13,450
meso shop and we really don't want to

00:11:10,269 --> 00:11:15,610
have competing cluster resource managers

00:11:13,450 --> 00:11:18,420
so an open with the invoker is

00:11:15,610 --> 00:11:20,649
effectively a resource manager who

00:11:18,420 --> 00:11:22,600
considers that he's he's the owner of

00:11:20,649 --> 00:11:26,680
all docker containers on any particular

00:11:22,600 --> 00:11:30,430
host and this sounds really familiar to

00:11:26,680 --> 00:11:33,040
meso s-- operators who know that when a

00:11:30,430 --> 00:11:35,079
meso agent is on the host he typically

00:11:33,040 --> 00:11:36,970
operates in the same fashion considering

00:11:35,079 --> 00:11:40,480
himself as the owner of all the docker

00:11:36,970 --> 00:11:42,370
containers on the host so you don't want

00:11:40,480 --> 00:11:47,470
competing clusters we don't want

00:11:42,370 --> 00:11:52,360
competing container managers we want to

00:11:47,470 --> 00:11:54,820
use maces to manage the cluster and yes

00:11:52,360 --> 00:11:57,490
we can't we just have to make some minor

00:11:54,820 --> 00:12:00,610
changes in open whisk to do this so I'm

00:11:57,490 --> 00:12:05,529
gonna go into some details on how we're

00:12:00,610 --> 00:12:07,320
doing that so first of all it's

00:12:05,529 --> 00:12:10,630
important to know that open whisk

00:12:07,320 --> 00:12:16,839
components are written as a cap Lakai

00:12:10,630 --> 00:12:20,140
shion's and this is helpful because it's

00:12:16,839 --> 00:12:23,079
makes it easier to decompose the

00:12:20,140 --> 00:12:26,589
application in a way that we can use

00:12:23,079 --> 00:12:32,199
messaging to drive the interactions in

00:12:26,589 --> 00:12:36,820
between the components so the steps that

00:12:32,199 --> 00:12:41,709
we're taking are we want to use open

00:12:36,820 --> 00:12:45,730
whisk to launch the docker containers

00:12:41,709 --> 00:12:47,170
but do it via mace O's and so what we're

00:12:45,730 --> 00:12:50,199
gonna do is we're gonna use a meso

00:12:47,170 --> 00:12:52,510
sackter inside the app the akka

00:12:50,199 --> 00:12:54,670
applications that open whisk is running

00:12:52,510 --> 00:13:00,220
for the controller and the invoker

00:12:54,670 --> 00:13:04,410
components so the first question is what

00:13:00,220 --> 00:13:04,410
what where do we find a mazes actor

00:13:06,290 --> 00:13:14,300
so after looking at some of the existing

00:13:10,940 --> 00:13:19,380
clients dealing with things like

00:13:14,300 --> 00:13:24,990
managing Lib mesas revving the client

00:13:19,380 --> 00:13:27,269
with the may sews versions becomes a

00:13:24,990 --> 00:13:29,790
little disheartening to try and build

00:13:27,269 --> 00:13:32,820
it's it's the classic it's difficult to

00:13:29,790 --> 00:13:35,940
build a meso sprain work story so what

00:13:32,820 --> 00:13:41,029
we did was we started from scratch a

00:13:35,940 --> 00:13:45,390
meso sackter that behaves based on the

00:13:41,029 --> 00:13:49,230
meso scheduler HTTP API and what we end

00:13:45,390 --> 00:13:52,649
up with is a single actor that

00:13:49,230 --> 00:13:55,680
encapsulates the interactions with the

00:13:52,649 --> 00:13:57,959
meso say HTTP api we can drop that actor

00:13:55,680 --> 00:14:00,029
into a NACA application and start

00:13:57,959 --> 00:14:03,300
behaving causing that application to

00:14:00,029 --> 00:14:07,769
behave as a maysa framework with doing

00:14:03,300 --> 00:14:11,339
very little work so when it goes through

00:14:07,769 --> 00:14:19,160
some details on how we're building the

00:14:11,339 --> 00:14:23,399
maysa act actor so this is a diagram of

00:14:19,160 --> 00:14:26,760
outside of open Wisc concepts how does

00:14:23,399 --> 00:14:30,060
the meso actor behave and some of these

00:14:26,760 --> 00:14:33,300
concepts will look very similar to the

00:14:30,060 --> 00:14:37,620
scheduler java api and the scheduler

00:14:33,300 --> 00:14:40,950
HTTP api but in general the the

00:14:37,620 --> 00:14:43,950
lifecycle of the actor begins with a

00:14:40,950 --> 00:14:47,430
subscription so you can send the actor a

00:14:43,950 --> 00:14:49,110
subscribe message once the subscription

00:14:47,430 --> 00:14:53,370
is complete you can send the actor a

00:14:49,110 --> 00:14:57,630
task submission message you can receive

00:14:53,370 --> 00:15:00,320
task state messages as tasks are

00:14:57,630 --> 00:15:03,870
changing state within the meso system

00:15:00,320 --> 00:15:06,930
and then you can submit delete tasks and

00:15:03,870 --> 00:15:12,149
and tear down the framework so you can

00:15:06,930 --> 00:15:14,670
see how really interacting with the meso

00:15:12,149 --> 00:15:18,649
scheduler API really becomes an exercise

00:15:14,670 --> 00:15:18,649
in a Kumasi Jing at this point

00:15:18,720 --> 00:15:27,760
so I'm gonna go through a short demo on

00:15:24,030 --> 00:15:33,910
the mesas actor thank you for holding

00:15:27,760 --> 00:15:38,260
the mic so what we have over here is my

00:15:33,910 --> 00:15:44,800
mesas cluster and you can see I don't

00:15:38,260 --> 00:15:48,840
have any active tasks so over here in

00:15:44,800 --> 00:15:53,500
IntelliJ can everybody see this okay I

00:15:48,840 --> 00:15:57,490
have a simple application I just call it

00:15:53,500 --> 00:16:01,300
sample framework and you can see so my

00:15:57,490 --> 00:16:03,820
code for starting up is just

00:16:01,300 --> 00:16:06,370
instantiating the actor giving it a

00:16:03,820 --> 00:16:09,130
framework ID pointing out where the

00:16:06,370 --> 00:16:13,960
mesas master resides giving it a

00:16:09,130 --> 00:16:16,690
failover timeout very simple once it

00:16:13,960 --> 00:16:23,110
subscribes I want to I want to receive a

00:16:16,690 --> 00:16:28,030
message for subscribe complete and after

00:16:23,110 --> 00:16:31,060
I subscribe I just launched some tasks

00:16:28,030 --> 00:16:33,310
here and you know this is the piece

00:16:31,060 --> 00:16:36,880
that's that's just not that easy to do

00:16:33,310 --> 00:16:40,120
with the scheduler API in in a lot of

00:16:36,880 --> 00:16:44,200
ways but we've kind of encapsulated the

00:16:40,120 --> 00:16:49,780
HTTP stream interaction behind this this

00:16:44,200 --> 00:16:52,350
other this mesas client actor here so

00:16:49,780 --> 00:16:52,350
when I run this

00:16:53,220 --> 00:17:03,330
I'm just running this locally and what

00:16:57,130 --> 00:17:03,330
will happen is over in my mesas cluster

00:17:04,589 --> 00:17:11,410
my my application that's behaving as a

00:17:08,760 --> 00:17:14,100
framework will start launching tasks and

00:17:11,410 --> 00:17:16,990
the way that the application is written

00:17:14,100 --> 00:17:19,110
it just simply launches some tasks waits

00:17:16,990 --> 00:17:22,030
a few seconds and then kill some tasks

00:17:19,110 --> 00:17:25,930
but you can see we've gotten gone a long

00:17:22,030 --> 00:17:30,790
ways for consuming the the meso

00:17:25,930 --> 00:17:39,440
scheduler API in in a few short steps

00:17:30,790 --> 00:17:42,140
so now my task just got killed and my my

00:17:39,440 --> 00:17:45,890
application completed and it tore itself

00:17:42,140 --> 00:17:49,420
down as a framework inside of my sews so

00:17:45,890 --> 00:17:49,420
this is our really simple example now

00:17:53,320 --> 00:17:59,750
the next the next thing then we want to

00:17:56,030 --> 00:18:01,640
go through is so it's it's it's great

00:17:59,750 --> 00:18:04,910
that we can launch tasks in May so now

00:18:01,640 --> 00:18:07,070
but that's that's not really a reliable

00:18:04,910 --> 00:18:10,790
framework and so some of the things that

00:18:07,070 --> 00:18:14,419
we're adding are dealing with highly

00:18:10,790 --> 00:18:18,010
available frameworks so you know we know

00:18:14,419 --> 00:18:23,450
that when the frameworks is running and

00:18:18,010 --> 00:18:26,870
and it it crashes or disconnects or goes

00:18:23,450 --> 00:18:30,350
through a partition we need to we need

00:18:26,870 --> 00:18:34,490
to fix that and have a new instance that

00:18:30,350 --> 00:18:37,700
becomes the manager of the tasks that

00:18:34,490 --> 00:18:39,710
this framework has launched and so the

00:18:37,700 --> 00:18:46,070
next thing I want to show is going

00:18:39,710 --> 00:18:51,640
through a a different version of sample

00:18:46,070 --> 00:18:54,830
that will deploy an act a cluster

00:18:51,640 --> 00:18:58,160
application and we're going to use a

00:18:54,830 --> 00:19:01,220
clustering to establish who is the

00:18:58,160 --> 00:19:05,240
leader and who should be managing the

00:19:01,220 --> 00:19:07,340
tasks at any given time and as a cluster

00:19:05,240 --> 00:19:09,799
these instances will work together so

00:19:07,340 --> 00:19:11,720
that if the leader becomes disconnected

00:19:09,799 --> 00:19:15,470
another member of the cluster will take

00:19:11,720 --> 00:19:17,210
over and be able to have some continuity

00:19:15,470 --> 00:19:21,530
in the task management for this

00:19:17,210 --> 00:19:24,309
particular framework so when I launch

00:19:21,530 --> 00:19:24,309
this application

00:19:28,360 --> 00:19:34,990
yeah

00:19:31,120 --> 00:19:38,530
so now my akka cluster is coming up and

00:19:34,990 --> 00:19:38,530
if I go

00:19:46,940 --> 00:19:56,179
so now I could see that my cluster has

00:19:49,909 --> 00:19:59,960
started so if I look in these tasks I

00:19:56,179 --> 00:20:02,479
can see that one of them will be the

00:19:59,960 --> 00:20:05,539
leader and is subscribing so this one

00:20:02,479 --> 00:20:07,159
has the most log messages so we happen

00:20:05,539 --> 00:20:11,259
to know that that's a good indicator

00:20:07,159 --> 00:20:14,090
that he's now receiving offers from asos

00:20:11,259 --> 00:20:18,440
so that's great so now he has the

00:20:14,090 --> 00:20:27,849
ability to launch tasks but what if what

00:20:18,440 --> 00:20:34,129
if he crashes so if we go back is this 1

00:20:27,849 --> 00:20:37,369
1 101 4 so if we go over to marathon and

00:20:34,129 --> 00:20:45,169
we choose him and we say well let's just

00:20:37,369 --> 00:20:48,259
kill that guy so let's see okay so now

00:20:45,169 --> 00:20:51,950
marathon is taking over relaunching one

00:20:48,259 --> 00:21:00,909
of our instances and now if we go back

00:20:51,950 --> 00:21:00,909
to the meso cui well now we have 4 SSS

00:21:03,590 --> 00:21:09,350
so now we have four instances running

00:21:06,360 --> 00:21:13,380
I'm not sure how I ended up with four

00:21:09,350 --> 00:21:17,850
but we can come back here and look for

00:21:13,380 --> 00:21:21,210
another one who has taken over as the

00:21:17,850 --> 00:21:23,990
leader so this guy was a leader

00:21:21,210 --> 00:21:23,990
momentarily

00:21:33,680 --> 00:21:36,310
No

00:21:38,080 --> 00:21:42,550
so we don't have a we don't have a great

00:21:40,000 --> 00:21:44,110
way to pick out which one is the leader

00:21:42,550 --> 00:21:47,680
without looking through the logs at this

00:21:44,110 --> 00:21:51,370
point so so you can see one of these

00:21:47,680 --> 00:21:54,940
tasks that is running now has taken over

00:21:51,370 --> 00:21:57,370
the responsibilities of being a leader

00:21:54,940 --> 00:22:01,470
and you can see in the logs here where

00:21:57,370 --> 00:22:03,940
the a cluster listener is is announcing

00:22:01,470 --> 00:22:07,480
that the leader changed and what's

00:22:03,940 --> 00:22:11,290
happening here is that each instance

00:22:07,480 --> 00:22:14,470
will if it becomes a leader what it will

00:22:11,290 --> 00:22:16,210
do is it will determine the framework ID

00:22:14,470 --> 00:22:18,760
that was used during the last

00:22:16,210 --> 00:22:25,620
subscription by a distributed data store

00:22:18,760 --> 00:22:25,620
in akka and it will reach

00:22:54,060 --> 00:22:57,060
self-actualization

00:22:58,250 --> 00:23:01,359
[Music]

00:23:14,240 --> 00:23:19,710
so just recapping some features that we

00:23:17,940 --> 00:23:21,450
talked about

00:23:19,710 --> 00:23:26,159
there's leader election based on a

00:23:21,450 --> 00:23:29,370
cholesterin we Reese absque Ribe a new

00:23:26,159 --> 00:23:32,399
leader that has been determined after

00:23:29,370 --> 00:23:34,440
there's a there's a failover the

00:23:32,399 --> 00:23:38,039
framework ID has to be consistent

00:23:34,440 --> 00:23:40,320
between a leader failover and a leader

00:23:38,039 --> 00:23:45,559
election so that the same tasks can be

00:23:40,320 --> 00:23:49,909
reassociate ado framework instance and

00:23:45,559 --> 00:23:52,649
there's support from asos roles in case

00:23:49,909 --> 00:23:54,720
people are allocating resources based on

00:23:52,649 --> 00:23:59,299
role and having a framework identify

00:23:54,720 --> 00:24:01,889
itself as operating in a particular role

00:23:59,299 --> 00:24:04,950
some things that are not done yet with

00:24:01,889 --> 00:24:10,220
this actor implementation is the

00:24:04,950 --> 00:24:13,860
reconcile process so in the case where a

00:24:10,220 --> 00:24:17,419
instance of a clustered framework has

00:24:13,860 --> 00:24:20,610
failed its tasks are not currently

00:24:17,419 --> 00:24:25,860
reconciled when when the new instance

00:24:20,610 --> 00:24:28,620
recent scribes and then also sharing

00:24:25,860 --> 00:24:35,029
task States so that that reconcile can

00:24:28,620 --> 00:24:36,899
happen so getting back to open whisk

00:24:35,029 --> 00:24:47,879
because that's what we're really talking

00:24:36,899 --> 00:24:50,340
about what we have a typo here well so a

00:24:47,879 --> 00:24:52,740
service platform I'm a so's massive

00:24:50,340 --> 00:24:56,460
scale operators expand and contract a

00:24:52,740 --> 00:24:58,919
maces cluster so what what alterations

00:24:56,460 --> 00:25:02,909
do we need to actually do in open wist

00:24:58,919 --> 00:25:04,830
to support this type of meso sackter to

00:25:02,909 --> 00:25:08,580
control our containers so in the

00:25:04,830 --> 00:25:11,009
controller if we recall the the diagram

00:25:08,580 --> 00:25:13,049
with open whisk components the the

00:25:11,009 --> 00:25:15,720
facade for incoming requests is the

00:25:13,049 --> 00:25:18,210
controller there's not any container

00:25:15,720 --> 00:25:21,299
interactions in that component

00:25:18,210 --> 00:25:24,929
currently the the containers are all

00:25:21,299 --> 00:25:27,990
interacted with in the invoker so what

00:25:24,929 --> 00:25:31,010
we've done in open whisk is define a

00:25:27,990 --> 00:25:33,270
an interface in the invoker for

00:25:31,010 --> 00:25:36,540
encapsulating what a container Factory

00:25:33,270 --> 00:25:39,720
is and so the outer box open whisk

00:25:36,540 --> 00:25:41,820
system will use docker CLI as a

00:25:39,720 --> 00:25:44,580
container factory so it just assumes

00:25:41,820 --> 00:25:47,490
that it has access to docker can can run

00:25:44,580 --> 00:25:50,760
docker and and run C commands on docker

00:25:47,490 --> 00:25:56,280
containers in our case we're gonna we're

00:25:50,760 --> 00:25:59,280
gonna use the meso s-- actor to to

00:25:56,280 --> 00:26:03,690
create and kill containers within the

00:25:59,280 --> 00:26:08,670
system so here's the diagram that we had

00:26:03,690 --> 00:26:10,560
where before within open whisk the

00:26:08,670 --> 00:26:14,400
invoker is is communicating directly

00:26:10,560 --> 00:26:16,410
with docker after we integrate with mace

00:26:14,400 --> 00:26:18,630
O's we're not going to we're not going

00:26:16,410 --> 00:26:21,330
to leverage docker at all anymore

00:26:18,630 --> 00:26:23,460
we're gonna have the invoker communicate

00:26:21,330 --> 00:26:26,760
with mace O's and the invoker is going

00:26:23,460 --> 00:26:31,440
to be elevated to the status of a maze

00:26:26,760 --> 00:26:35,300
O's framework and so if we compare these

00:26:31,440 --> 00:26:41,220
this is just kind of pointing out to be

00:26:35,300 --> 00:26:44,300
clear that no longer is invoker gonna be

00:26:41,220 --> 00:26:49,140
leveraging these these docker specific

00:26:44,300 --> 00:26:56,150
CLI and it's going to delegate to meso

00:26:49,140 --> 00:26:59,010
s-- so now it's going to show a demo of

00:26:56,150 --> 00:27:04,010
exactly what happens in open wisk when

00:26:59,010 --> 00:27:04,010
we do this so if we go

00:27:08,360 --> 00:27:15,929
so the way that open was operates is by

00:27:12,240 --> 00:27:19,260
a concept of actions from a developer

00:27:15,929 --> 00:27:24,030
perspective so if you look over in my

00:27:19,260 --> 00:27:29,130
terminal here I have this JavaScript

00:27:24,030 --> 00:27:33,900
snippet and this is what I want to run

00:27:29,130 --> 00:27:37,590
as a function in open wisk so what I'm

00:27:33,900 --> 00:27:42,510
gonna do is first I need to start my

00:27:37,590 --> 00:27:46,440
invoker which was already running as a

00:27:42,510 --> 00:27:48,870
container I'm just gonna restart it now

00:27:46,440 --> 00:27:54,960
remember this invoker is going to be

00:27:48,870 --> 00:27:57,330
operating now as a Mesa framework and so

00:27:54,960 --> 00:28:00,390
you'll see it here in the in the

00:27:57,330 --> 00:28:05,070
framework section of the Mesa sui so

00:28:00,390 --> 00:28:07,770
that's good and now if I go back to my

00:28:05,070 --> 00:28:11,190
list of tasks you can see that there's

00:28:07,770 --> 00:28:13,890
some tasks that were created by my open

00:28:11,190 --> 00:28:18,120
Wisc framework there they're prefixed

00:28:13,890 --> 00:28:19,590
with this Wisc load balancer ID and the

00:28:18,120 --> 00:28:21,900
reason these tasks are created is

00:28:19,590 --> 00:28:25,830
because open wisk does some optimization

00:28:21,900 --> 00:28:29,010
to speed up the code initialization

00:28:25,830 --> 00:28:31,260
process by starting some containers so

00:28:29,010 --> 00:28:33,630
that they're pre-warmed and once code

00:28:31,260 --> 00:28:37,200
arrives to be executed it doesn't have

00:28:33,630 --> 00:28:38,550
to start the container it containers

00:28:37,200 --> 00:28:42,480
available for running it will just

00:28:38,550 --> 00:28:50,179
inject the code into it and run it so

00:28:42,480 --> 00:28:50,179
now what I'll do is create my action

00:29:00,200 --> 00:29:07,789
so I'm listening my actions currently

00:29:04,090 --> 00:29:14,590
there's some tests there so now I'm

00:29:07,789 --> 00:29:20,169
gonna go I'm gonna say action create

00:29:14,590 --> 00:29:22,879
hello okay so now if I this my actions

00:29:20,169 --> 00:29:28,359
so now you'll see I have a hello action

00:29:22,879 --> 00:29:28,359
up here and now if I invoke my action

00:29:38,530 --> 00:29:50,800
what you'll see is in my action what I

00:29:45,130 --> 00:29:54,610
did was I returned a string actually

00:29:50,800 --> 00:29:59,350
adjacent result which indicates what

00:29:54,610 --> 00:30:04,120
task it was running on so incidentally

00:29:59,350 --> 00:30:07,450
if I go over to my mesas UI and look at

00:30:04,120 --> 00:30:10,300
the logs for that tasks I'll see some

00:30:07,450 --> 00:30:12,970
indication of a log message that was

00:30:10,300 --> 00:30:14,830
also generated in that task as well as

00:30:12,970 --> 00:30:18,990
this is a marker that opened which uses

00:30:14,830 --> 00:30:18,990
to look at the end of the log file and

00:30:19,800 --> 00:30:27,370
if I go back you'll notice that now

00:30:24,520 --> 00:30:29,410
instead of four tasks I have five tasks

00:30:27,370 --> 00:30:32,260
because once I start consuming

00:30:29,410 --> 00:30:33,940
containers inside of open wisk it will

00:30:32,260 --> 00:30:37,570
try and launch additional containers so

00:30:33,940 --> 00:30:40,210
that it has a steady pool of pre-warm

00:30:37,570 --> 00:30:41,350
containers available for new actions

00:30:40,210 --> 00:30:44,800
that might come in that need to be

00:30:41,350 --> 00:30:46,660
executed and it does some optimization

00:30:44,800 --> 00:30:49,960
to try and reuse containers for the same

00:30:46,660 --> 00:30:53,190
action so that the same code is is not

00:30:49,960 --> 00:30:58,470
reinitialized more often than necessary

00:30:53,190 --> 00:31:04,090
but this is our demo for open wisk and

00:30:58,470 --> 00:31:06,460
let's see thank you for coming if

00:31:04,090 --> 00:31:09,270
anybody has any questions I think we can

00:31:06,460 --> 00:31:09,270
go to the questions now

00:31:16,560 --> 00:31:21,130
sorry this might come from me not being

00:31:19,090 --> 00:31:23,560
completely familiar with a cluster how

00:31:21,130 --> 00:31:27,130
do you manage a cluster membership and

00:31:23,560 --> 00:31:30,340
is your invoker framework a measure

00:31:27,130 --> 00:31:33,790
sector that you just presented so by how

00:31:30,340 --> 00:31:35,710
I mean do you coordinate - zookeeper I

00:31:33,790 --> 00:31:40,300
think I think a cluster can do at all

00:31:35,710 --> 00:31:42,190
multicast or how does this all come

00:31:40,300 --> 00:31:44,920
together that's a great point actually

00:31:42,190 --> 00:31:47,440
and it was on my tongue I wanted also

00:31:44,920 --> 00:31:49,720
also to mention I think the reason why I

00:31:47,440 --> 00:31:52,390
personally got so excited about working

00:31:49,720 --> 00:31:54,490
again this year with it is that we do

00:31:52,390 --> 00:31:58,630
need to use any zookeeper akka

00:31:54,490 --> 00:32:02,200
clustering knows has a nice nice

00:31:58,630 --> 00:32:04,740
algorithms it uses gossip to know about

00:32:02,200 --> 00:32:07,840
the nodes in the in in the cluster and

00:32:04,740 --> 00:32:11,830
it is capable it has algorithms to pick

00:32:07,840 --> 00:32:13,690
a leader so then what we do is that once

00:32:11,830 --> 00:32:15,760
a capitulate there does the node that is

00:32:13,690 --> 00:32:17,740
going to listen is amiss framework yeah

00:32:15,760 --> 00:32:19,630
and we're I'm personally very excited

00:32:17,740 --> 00:32:21,220
about this because I don't have to

00:32:19,630 --> 00:32:24,220
depend on zookeeper into all that

00:32:21,220 --> 00:32:25,810
orchestration is as a developer when I

00:32:24,220 --> 00:32:28,360
work with acai I feel I have so much

00:32:25,810 --> 00:32:30,490
power now that somebody else implemented

00:32:28,360 --> 00:32:33,190
some algorithms for me and now I just

00:32:30,490 --> 00:32:36,760
look very like I'm very smart but I do

00:32:33,190 --> 00:32:39,360
is just use akka the one thing that I

00:32:36,760 --> 00:32:42,970
would point out is so I highlighted a

00:32:39,360 --> 00:32:45,370
very specific piece of code here so akka

00:32:42,970 --> 00:32:48,160
does operate off the notion of seed

00:32:45,370 --> 00:32:51,930
nodes to define how cluster is

00:32:48,160 --> 00:32:55,510
initialized and what we're doing here is

00:32:51,930 --> 00:32:57,400
we're leveraging marathon's application

00:32:55,510 --> 00:33:01,150
state to determine what the seed nodes

00:32:57,400 --> 00:33:03,190
are and once we determine that there are

00:33:01,150 --> 00:33:05,740
some seed nodes and that the seed nodes

00:33:03,190 --> 00:33:08,350
are healthy then we initialize the

00:33:05,740 --> 00:33:10,720
clustering based on everybody gets the

00:33:08,350 --> 00:33:12,850
same set of seed nodes and it has its

00:33:10,720 --> 00:33:15,810
own gossip protocol to establish who's

00:33:12,850 --> 00:33:15,810
the leader at that point

00:33:17,790 --> 00:33:28,420
yes how do you plan on keeping up with

00:33:25,440 --> 00:33:32,049
currency so when open whisk changes

00:33:28,420 --> 00:33:36,250
version or maysa changes version is

00:33:32,049 --> 00:33:41,440
there much work in in to upgrade your

00:33:36,250 --> 00:33:45,190
code so the way that this is a

00:33:41,440 --> 00:33:49,919
complicated answer because the way that

00:33:45,190 --> 00:33:52,960
open was is operated today is gonna be

00:33:49,919 --> 00:33:54,309
different probably in the future but the

00:33:52,960 --> 00:33:55,809
way that operates today there's the

00:33:54,309 --> 00:33:58,660
controller component and there's the

00:33:55,809 --> 00:34:01,270
invoker component and strictly speaking

00:33:58,660 --> 00:34:06,250
we can we can Rev those independently

00:34:01,270 --> 00:34:09,460
and so while the incoming facade

00:34:06,250 --> 00:34:12,190
you know the controller can be at one

00:34:09,460 --> 00:34:15,580
version we can do a rolling upgrade of

00:34:12,190 --> 00:34:17,800
the invoker's and then we'll be doing a

00:34:15,580 --> 00:34:20,800
rolling upgrade of the controllers but

00:34:17,800 --> 00:34:23,889
the short answer is that that we will

00:34:20,800 --> 00:34:26,460
have to do coordinated rolling upgrades

00:34:23,889 --> 00:34:26,460
of each component

00:34:33,669 --> 00:34:39,560
so if I understand correctly invoke her

00:34:36,619 --> 00:34:42,530
actually it natively managed the docker

00:34:39,560 --> 00:34:45,790
containers and to do actions and you

00:34:42,530 --> 00:34:48,169
modify it till top to Maysles and

00:34:45,790 --> 00:34:50,450
leverage metal capability to manage

00:34:48,169 --> 00:34:53,510
containers so I would imagine it'd be

00:34:50,450 --> 00:34:57,139
nice to abstract that like adapter layer

00:34:53,510 --> 00:34:59,869
away so invoker could not only talk to

00:34:57,139 --> 00:35:02,570
dr. daemon were Maysles or kubernetes or

00:34:59,869 --> 00:35:04,100
swarm and you have this interfaces so

00:35:02,570 --> 00:35:07,010
that the Culebra can be leveraged to

00:35:04,100 --> 00:35:10,040
manage the containers right so then that

00:35:07,010 --> 00:35:13,369
API work could be like upstream bag to

00:35:10,040 --> 00:35:17,510
open with community it is and you're

00:35:13,369 --> 00:35:19,060
right and it is so there's we're working

00:35:17,510 --> 00:35:21,550
with the open with community right now

00:35:19,060 --> 00:35:24,140
there's an open poll request that's

00:35:21,550 --> 00:35:29,480
nearing completion for the container

00:35:24,140 --> 00:35:31,430
Factory we are in close contact with a

00:35:29,480 --> 00:35:35,690
team at Red Hat who's doing the same for

00:35:31,430 --> 00:35:38,300
kubernetes and you're right it's it's a

00:35:35,690 --> 00:35:41,750
it's a generic API for launching

00:35:38,300 --> 00:35:46,609
containers with open with semantics but

00:35:41,750 --> 00:35:49,550
there is there's no exposure of of maysa

00:35:46,609 --> 00:35:58,160
dependencies upwards from that api great

00:35:49,550 --> 00:36:00,440
thanks cool there was a great thank you

00:35:58,160 --> 00:36:02,900
so a couple of quick questions one is

00:36:00,440 --> 00:36:04,640
the invoker is still the one that's

00:36:02,900 --> 00:36:07,060
reading the data from Kafka and invoking

00:36:04,640 --> 00:36:10,369
the actions right that's correct so the

00:36:07,060 --> 00:36:12,080
after it got integrated with the I mean

00:36:10,369 --> 00:36:15,500
the invoker itself is becoming a

00:36:12,080 --> 00:36:17,930
framework right now yes so the all of

00:36:15,500 --> 00:36:20,000
the actions get deployed in its own

00:36:17,930 --> 00:36:22,070
container I assume so how are you guys

00:36:20,000 --> 00:36:25,790
also scaling the invoker and how is the

00:36:22,070 --> 00:36:33,140
actions from the invoker gets called on

00:36:25,790 --> 00:36:36,220
the actual container so this is its so

00:36:33,140 --> 00:36:40,609
the way the invoker is scaled today is

00:36:36,220 --> 00:36:42,890
if you are constrained by the number of

00:36:40,609 --> 00:36:44,150
containers based on the number of hosts

00:36:42,890 --> 00:36:47,699
that run an inn

00:36:44,150 --> 00:36:50,249
your your choice today is to deploy a

00:36:47,699 --> 00:36:53,369
new host which also has another invoker

00:36:50,249 --> 00:36:56,400
on it when we're operating the invoker

00:36:53,369 --> 00:36:59,849
as a maces framework there's no real

00:36:56,400 --> 00:37:02,390
need for multiple invoker's anymore the

00:36:59,849 --> 00:37:05,849
invoker now has visibility to the entire

00:37:02,390 --> 00:37:07,979
mesas cluster the only reason that we

00:37:05,849 --> 00:37:10,680
have to operate multiple invoker's at

00:37:07,979 --> 00:37:13,199
this point is to have a highly available

00:37:10,680 --> 00:37:16,079
system so that if one of those invoker's

00:37:13,199 --> 00:37:19,499
fails the controller will route all of

00:37:16,079 --> 00:37:22,979
its requests to the other invoker's but

00:37:19,499 --> 00:37:25,380
the the ratio of invoker's to hosts is

00:37:22,979 --> 00:37:28,259
no longer relevant specifically for

00:37:25,380 --> 00:37:29,249
scaling out containers got it so that

00:37:28,259 --> 00:37:31,410
means each of these individual

00:37:29,249 --> 00:37:34,849
containers can also subscribe to Kafka

00:37:31,410 --> 00:37:34,849
directly to receive their own messages

00:37:36,469 --> 00:37:41,900
the invoker is still in the middle of

00:37:39,029 --> 00:37:44,459
processing the messages okay

00:37:41,900 --> 00:37:46,859
incidentally we're we are working on

00:37:44,459 --> 00:37:50,969
some other throughput optimizations that

00:37:46,859 --> 00:37:53,400
are specifically related to how function

00:37:50,969 --> 00:37:56,069
invocations are passed through Kafka and

00:37:53,400 --> 00:37:58,529
and process at the invoker layer that's

00:37:56,069 --> 00:38:02,729
where effectively what we want to do is

00:37:58,529 --> 00:38:04,529
share the container pool state of the

00:38:02,729 --> 00:38:06,209
entire cluster from open whisper

00:38:04,529 --> 00:38:08,009
spective all the way back to the

00:38:06,209 --> 00:38:12,089
controller so that we can really

00:38:08,009 --> 00:38:15,829
optimize how the you know how the

00:38:12,089 --> 00:38:18,420
throughput is managed in the system I

00:38:15,829 --> 00:38:20,339
can just add because I like a question

00:38:18,420 --> 00:38:21,959
you know this is the beauty of message

00:38:20,339 --> 00:38:24,089
that it takes away the container

00:38:21,959 --> 00:38:26,069
management in the cluster and we can

00:38:24,089 --> 00:38:27,449
focus on what what what is the core of a

00:38:26,069 --> 00:38:30,329
server list and actually at the core

00:38:27,449 --> 00:38:31,859
what we want to get to is even use

00:38:30,329 --> 00:38:33,930
machine learning to spin up containers

00:38:31,859 --> 00:38:36,630
ahead of time pre worm do all these

00:38:33,930 --> 00:38:38,549
other things and offload the complexity

00:38:36,630 --> 00:38:42,269
of the managing of the containers to

00:38:38,549 --> 00:38:49,609
mazes cool thank you so thank you for

00:38:42,269 --> 00:38:49,609
the question like just one last one

00:38:50,280 --> 00:38:56,310
um if we're in an environment with our

00:38:53,610 --> 00:39:02,760
Universal like containerize or runtime

00:38:56,310 --> 00:39:09,330
UCR no docker should this work well I

00:39:02,760 --> 00:39:12,390
don't know I was gonna say no but that's

00:39:09,330 --> 00:39:16,320
not that's not really true okay we're

00:39:12,390 --> 00:39:19,970
not operating that way but in theory it

00:39:16,320 --> 00:39:22,920
should work because as long as the

00:39:19,970 --> 00:39:27,860
container that's that surfaced as a

00:39:22,920 --> 00:39:31,320
masive task has a routable IP and a port

00:39:27,860 --> 00:39:33,360
it's in theory fine related question

00:39:31,320 --> 00:39:36,630
like if you do if we're doing IP per

00:39:33,360 --> 00:39:38,450
container with calico no overlay or just

00:39:36,630 --> 00:39:42,360
layer three is there any network

00:39:38,450 --> 00:39:45,300
implication should work right yeah yeah

00:39:42,360 --> 00:39:47,970
there's there's yeah so this is actually

00:39:45,300 --> 00:39:54,360
one really nice thing about open wisk

00:39:47,970 --> 00:39:57,450
currently is that the the the interface

00:39:54,360 --> 00:40:00,660
that's required of a of a container from

00:39:57,450 --> 00:40:04,770
open west perspective is strictly

00:40:00,660 --> 00:40:11,010
defined only as an HTTP interface that

00:40:04,770 --> 00:40:13,380
has a slash run endpoint on it and as as

00:40:11,010 --> 00:40:16,440
long as your container ends up with that

00:40:13,380 --> 00:40:17,700
contract in mind then technically

00:40:16,440 --> 00:40:21,410
speaking there's not really any

00:40:17,700 --> 00:40:21,410
reasoning open Wiss can't execute it so

00:40:21,680 --> 00:40:27,630
point that you said you're with calico

00:40:24,510 --> 00:40:30,810
oh using calico yeah it would be a great

00:40:27,630 --> 00:40:33,120
addition to open ways to learn how to

00:40:30,810 --> 00:40:34,980
isolate containers from from each other

00:40:33,120 --> 00:40:36,990
you see this is yet another thing that

00:40:34,980 --> 00:40:41,520
server lace environment needs to look at

00:40:36,990 --> 00:40:44,530
so thank you for the question all right

00:40:41,520 --> 00:40:46,849
thank you very much for your time

00:40:44,530 --> 00:40:46,849

YouTube URL: https://www.youtube.com/watch?v=7g_aP9USYUU


