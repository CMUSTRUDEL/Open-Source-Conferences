Title: Adopting Microservices in Healthcare, Breaking Apart the Monolith
Publication date: 2017-09-18
Playlist: MesosCon North America 2017
Description: 
	Adopting Microservices in Healthcare, Breaking Apart the Monolith - Aaron Baer, athenahealth

Healthcare systems traditionally lag behind from the curve of technology trends. Information is plentiful in the space of healthcare and data is typically in large silos. In this presentation we'll explore how our DevOps team is adopting microservices, breaking apart it's monolith, and adopting a new data fabric to allow for massive scale and increased innovation in the space of healthcare information as part of it's platform infrastructure platform. We'll talk about the architecture and tools chosen as well as what went well and what didn't along with some of the efforts still on going as part of this change.

About

Aaron Baer
Lead Member of Technical Staff, athenahealth, Inc.
Captions: 
	00:00:00,240 --> 00:00:06,060
good morning everyone my name is Aaron

00:00:04,290 --> 00:00:09,300
bear from athenahealth

00:00:06,060 --> 00:00:11,480
and today I'll be talking about breaking

00:00:09,300 --> 00:00:17,220
apart the monolith and breaking apart

00:00:11,480 --> 00:00:19,980
our monolith at athenahealth as well so

00:00:17,220 --> 00:00:23,359
the first thing I wanted to do is give a

00:00:19,980 --> 00:00:26,340
shout out to my colleague Ryan Wallner

00:00:23,359 --> 00:00:28,740
original intention was actually that he

00:00:26,340 --> 00:00:33,120
was going to be presenting this content

00:00:28,740 --> 00:00:36,180
to you today and and much of that comes

00:00:33,120 --> 00:00:38,730
directly from from his brain but he was

00:00:36,180 --> 00:00:42,920
unable to make it and so I also

00:00:38,730 --> 00:00:47,030
attending was able to step in for him so

00:00:42,920 --> 00:00:49,860
welcome to everybody and hello so myself

00:00:47,030 --> 00:00:54,629
been building business system

00:00:49,860 --> 00:00:56,430
applications for 16 years at least

00:00:54,629 --> 00:00:59,699
I've been working in the public cloud

00:00:56,430 --> 00:01:03,379
AWS Amazon space for five or more years

00:00:59,699 --> 00:01:07,080
I love writing infrastructure as code

00:01:03,379 --> 00:01:10,979
that's been my primary focus for those

00:01:07,080 --> 00:01:13,710
last five years so you know I've gone

00:01:10,979 --> 00:01:16,979
from the old-school business

00:01:13,710 --> 00:01:21,150
applications writing op op and s AP and

00:01:16,979 --> 00:01:24,290
and coming up through all of that large

00:01:21,150 --> 00:01:26,700
IT organizations infrastructure to now

00:01:24,290 --> 00:01:29,640
more recently working in the public

00:01:26,700 --> 00:01:31,920
cloud I love to build things it doesn't

00:01:29,640 --> 00:01:35,369
matter what it is I really like to build

00:01:31,920 --> 00:01:37,920
it and so now I'm building things at

00:01:35,369 --> 00:01:42,450
athenahealth on the infrastructure team

00:01:37,920 --> 00:01:49,350
there so thanks to Ryan and I'm Erin

00:01:42,450 --> 00:01:52,680
hello so often in the healthcare

00:01:49,350 --> 00:02:01,409
industry technology sticks around for a

00:01:52,680 --> 00:02:07,590
long time you know it is often becomes

00:02:01,409 --> 00:02:09,360
very old in that time and so it's hard

00:02:07,590 --> 00:02:12,050
to break into that space with new

00:02:09,360 --> 00:02:12,050
technologies

00:02:12,480 --> 00:02:20,170
for example one of the main focus one of

00:02:16,960 --> 00:02:24,240
the main functions that athenahealth

00:02:20,170 --> 00:02:29,680
performs for the healthcare industry is

00:02:24,240 --> 00:02:31,870
processing faxes so at athenahealth

00:02:29,680 --> 00:02:34,720
we're trying to do a couple of things

00:02:31,870 --> 00:02:36,820
unbreak healthcare what we like to say

00:02:34,720 --> 00:02:41,520
and what that means is we're trying very

00:02:36,820 --> 00:02:46,180
hard to bring all of the tedious

00:02:41,520 --> 00:02:49,870
difficult workflow items of a

00:02:46,180 --> 00:02:55,450
physician's day or an office

00:02:49,870 --> 00:02:57,550
administration's day and free them from

00:02:55,450 --> 00:02:58,990
that and allow them to just be doctors

00:02:57,550 --> 00:03:01,270
so al them to just be with their

00:02:58,990 --> 00:03:03,459
patients and allow them to focus on that

00:03:01,270 --> 00:03:07,990
information instead of processing like

00:03:03,459 --> 00:03:11,590
we do for many healthcare places all

00:03:07,990 --> 00:03:15,910
over you know we're processing hundreds

00:03:11,590 --> 00:03:17,860
of thousands of faxes of day and not

00:03:15,910 --> 00:03:20,950
only just things like faxes but there's

00:03:17,860 --> 00:03:26,739
still a long paper trail that exists

00:03:20,950 --> 00:03:28,060
throughout the entire industry so with

00:03:26,739 --> 00:03:31,870
that though the healthcare industry is

00:03:28,060 --> 00:03:35,459
trying to go through a digital

00:03:31,870 --> 00:03:40,300
transformation moving its information

00:03:35,459 --> 00:03:43,510
into the digital world instead of an out

00:03:40,300 --> 00:03:47,590
of an out of filing cabinets and the

00:03:43,510 --> 00:03:50,620
path to that that everyone is taking but

00:03:47,590 --> 00:03:53,650
the health industry or companies like

00:03:50,620 --> 00:03:56,560
Athena health are undergoing is that

00:03:53,650 --> 00:04:01,390
transformation from the giant monolithic

00:03:56,560 --> 00:04:06,570
application stack to microservices and a

00:04:01,390 --> 00:04:11,680
more modern framework for that so that

00:04:06,570 --> 00:04:14,489
you know we're and in that one of the

00:04:11,680 --> 00:04:17,019
challenges that we will always face

00:04:14,489 --> 00:04:19,000
especially in the EHR market which is

00:04:17,019 --> 00:04:22,479
another part of where Athena health

00:04:19,000 --> 00:04:25,770
focuses a lot is the adoption of new

00:04:22,479 --> 00:04:30,360
technologies into the these offices and

00:04:25,770 --> 00:04:34,050
to the doctors hands into whatever that

00:04:30,360 --> 00:04:37,259
may entail

00:04:34,050 --> 00:04:39,870
so at Athena health we're trying to let

00:04:37,259 --> 00:04:43,169
doctors be truly doctors not have to

00:04:39,870 --> 00:04:45,810
spend six hours every day just doing

00:04:43,169 --> 00:04:53,509
their paperwork helping to prefer I and

00:04:45,810 --> 00:04:53,509
perform efficiencies in that space so

00:04:55,340 --> 00:05:01,289
computing systems have been moving to

00:04:58,259 --> 00:05:03,930
cloud-based solutions and more hybrid

00:05:01,289 --> 00:05:08,759
models for quite a long for not quite a

00:05:03,930 --> 00:05:16,620
long time but for for a while and it's

00:05:08,759 --> 00:05:18,599
hard it is difficult to do that I will

00:05:16,620 --> 00:05:23,280
say since Ryan developed all this

00:05:18,599 --> 00:05:25,500
content that slides and content and data

00:05:23,280 --> 00:05:27,870
and and the information that I'm sharing

00:05:25,500 --> 00:05:30,719
with you although I work with on an

00:05:27,870 --> 00:05:33,479
everyday basis is definitely new for me

00:05:30,719 --> 00:05:34,919
and presentation layer to you so as we

00:05:33,479 --> 00:05:38,940
go through this I'm gonna reference

00:05:34,919 --> 00:05:42,300
notes and and hopefully we'll keep this

00:05:38,940 --> 00:05:44,099
loose so in that as well if I'm speaking

00:05:42,300 --> 00:05:45,900
and I become a little bit unclear in

00:05:44,099 --> 00:05:48,289
anything we're gonna take questions

00:05:45,900 --> 00:05:50,639
towards the end but feel free to just

00:05:48,289 --> 00:05:56,610
raise your hand and ask for that

00:05:50,639 --> 00:05:59,430
clarification at any time so that being

00:05:56,610 --> 00:06:01,319
said we're moving our products many

00:05:59,430 --> 00:06:03,469
other companies are trying to move their

00:06:01,319 --> 00:06:09,120
products into this space the cloud space

00:06:03,469 --> 00:06:11,610
the mobile space as operators at the

00:06:09,120 --> 00:06:15,210
infrastructure level and developers at

00:06:11,610 --> 00:06:18,750
the application level moving into a much

00:06:15,210 --> 00:06:23,460
more flexible sea icd pipeline making

00:06:18,750 --> 00:06:25,919
information access easier at the

00:06:23,460 --> 00:06:29,610
application level and at the end user

00:06:25,919 --> 00:06:31,529
level and provide platforms where

00:06:29,610 --> 00:06:36,560
information sharing becomes much more

00:06:31,529 --> 00:06:39,560
fluid and much more accessible so

00:06:36,560 --> 00:06:39,560
another

00:06:39,919 --> 00:06:48,379
challenged or regular system thing that

00:06:45,509 --> 00:06:53,539
happens in our space being health

00:06:48,379 --> 00:06:58,470
information is that we're often also

00:06:53,539 --> 00:07:02,340
needing to deploy that infrastructure in

00:06:58,470 --> 00:07:08,009
the old paradigm into sometimes the

00:07:02,340 --> 00:07:12,150
doctor's offices into our data centers

00:07:08,009 --> 00:07:14,039
and not as much in the past into public

00:07:12,150 --> 00:07:18,539
cloud spaces as we're moving towards

00:07:14,039 --> 00:07:23,789
today so what we're trying to do is

00:07:18,539 --> 00:07:26,099
strangle the monolithic design so and

00:07:23,789 --> 00:07:28,560
I'm here to talk about how we're

00:07:26,099 --> 00:07:32,099
creating our pathway towards breaking up

00:07:28,560 --> 00:07:38,479
this monolith and make our transition

00:07:32,099 --> 00:07:42,740
into the cloud because as an industry

00:07:38,479 --> 00:07:47,460
it's important and it's time to be cloud

00:07:42,740 --> 00:07:53,430
more than it is to have our data locked

00:07:47,460 --> 00:07:55,620
up in silos and in a place or location

00:07:53,430 --> 00:07:58,080
that's difficult to interact with the

00:07:55,620 --> 00:07:59,900
data or move that data around or share

00:07:58,080 --> 00:08:03,000
it in between platforms

00:07:59,900 --> 00:08:04,590
and I have you know health we have you

00:08:03,000 --> 00:08:10,740
know your typical monolithic design

00:08:04,590 --> 00:08:17,699
right now it's Apache pearl and Oracle

00:08:10,740 --> 00:08:20,069
and it's in one big chunk and all of it

00:08:17,699 --> 00:08:27,719
is dependent on all of the rest of it

00:08:20,069 --> 00:08:32,940
and to expand that you have to lift and

00:08:27,719 --> 00:08:35,550
shift the entire monolith and what we

00:08:32,940 --> 00:08:40,260
have found is that it's also difficult

00:08:35,550 --> 00:08:43,800
to scale that monolith in any and so

00:08:40,260 --> 00:08:47,550
that you have a stack that can perform

00:08:43,800 --> 00:08:51,060
to a certain size but the only way to

00:08:47,550 --> 00:08:53,640
continue to add customers to that or

00:08:51,060 --> 00:08:56,640
to add functionality that or or anything

00:08:53,640 --> 00:09:00,330
is to replicate the entire thing in

00:08:56,640 --> 00:09:02,310
another place and certain customers go

00:09:00,330 --> 00:09:04,740
to this one certain customers go to that

00:09:02,310 --> 00:09:06,330
one certain customers go to that one so

00:09:04,740 --> 00:09:08,490
on and so on and so on until you have

00:09:06,330 --> 00:09:14,060
all of these deployments of this big

00:09:08,490 --> 00:09:18,990
giant thing that is very unflexible

00:09:14,060 --> 00:09:23,360
you're bound by that monolith to what

00:09:18,990 --> 00:09:27,900
data you can view what data you can use

00:09:23,360 --> 00:09:30,480
what data you can see for instance in

00:09:27,900 --> 00:09:34,650
the healthcare industry a big trend is

00:09:30,480 --> 00:09:39,150
for merging large Hospital groups into

00:09:34,650 --> 00:09:41,790
larger Hospital groups and if say

00:09:39,150 --> 00:09:44,190
hypothetically a one customer was

00:09:41,790 --> 00:09:45,690
already athenahealth and merged into a

00:09:44,190 --> 00:09:48,480
hospital group there's also Athena

00:09:45,690 --> 00:09:49,650
health but they were already on two

00:09:48,480 --> 00:09:51,480
different and pheenoh health systems

00:09:49,650 --> 00:09:55,680
there's a very big challenge for us to

00:09:51,480 --> 00:10:00,390
bring those together in a useful way and

00:09:55,680 --> 00:10:04,320
so why microcircuit is in that paradigm

00:10:00,390 --> 00:10:07,110
is because that scale there's there's no

00:10:04,320 --> 00:10:11,790
way to do that in the current monolithic

00:10:07,110 --> 00:10:13,770
platform the other is that you know

00:10:11,790 --> 00:10:15,600
you're bound by that technology stack

00:10:13,770 --> 00:10:18,630
for any innovation that you can make

00:10:15,600 --> 00:10:22,290
into the market and so microservices and

00:10:18,630 --> 00:10:26,070
our path towards micro services is a way

00:10:22,290 --> 00:10:29,640
for us to be able to innovate faster so

00:10:26,070 --> 00:10:33,000
that someone can have an idea and write

00:10:29,640 --> 00:10:36,089
a service for that and tie into our data

00:10:33,000 --> 00:10:40,020
stack and have you know something up and

00:10:36,089 --> 00:10:44,580
running within days where before you

00:10:40,020 --> 00:10:47,959
know it may take quarters to get a

00:10:44,580 --> 00:10:52,260
release into the Perl code where one

00:10:47,959 --> 00:10:56,050
change might affect the entire the

00:10:52,260 --> 00:11:00,869
entire application stack in itself

00:10:56,050 --> 00:11:07,119
so also in that as a large organization

00:11:00,869 --> 00:11:10,209
that is at the head of this model in the

00:11:07,119 --> 00:11:13,089
healthcare industry having that big

00:11:10,209 --> 00:11:15,100
monolithic stack makes it hard for us as

00:11:13,089 --> 00:11:16,689
an organization to continue to hire new

00:11:15,100 --> 00:11:18,999
talent that wants to come in and do

00:11:16,689 --> 00:11:20,889
something really exciting right because

00:11:18,999 --> 00:11:24,339
we can say oh you're really smart you've

00:11:20,889 --> 00:11:26,529
got 10 years or 20 years of writing

00:11:24,339 --> 00:11:28,989
applications and you're building all

00:11:26,529 --> 00:11:31,269
these things come work for us and you

00:11:28,989 --> 00:11:33,670
can write Perl and query data out of

00:11:31,269 --> 00:11:37,529
Oracle with SQL I mean that's not too

00:11:33,670 --> 00:11:41,290
thrilling so our journey towards this

00:11:37,529 --> 00:11:44,439
microcircuits and nice toast fear

00:11:41,290 --> 00:11:47,860
environment is to allow us to be more

00:11:44,439 --> 00:11:50,230
Agnon agnostic to to what technology

00:11:47,860 --> 00:11:52,569
someone has to use to make something a

00:11:50,230 --> 00:11:57,699
part of athenahealth software offers

00:11:52,569 --> 00:11:59,410
across the board so the challenge is

00:11:57,699 --> 00:12:02,439
then breaking apart that monolith right

00:11:59,410 --> 00:12:05,439
so you know you've got this big thing

00:12:02,439 --> 00:12:07,089
and what we're trying to do is to get to

00:12:05,439 --> 00:12:09,939
all these yummy little pizzas all over

00:12:07,089 --> 00:12:13,059
the place that we can eat and consume at

00:12:09,939 --> 00:12:17,019
anytime we want to and the middle ground

00:12:13,059 --> 00:12:18,660
is breaking that apart in chunks right

00:12:17,019 --> 00:12:21,369
everybody loves pizza everybody

00:12:18,660 --> 00:12:31,689
everybody wants to have a slice

00:12:21,369 --> 00:12:39,160
everybody wants to do to make it easier

00:12:31,689 --> 00:12:41,319
to adapt into the overall platform so

00:12:39,160 --> 00:12:43,449
the one thing that is challenging but

00:12:41,319 --> 00:12:45,850
also very important is to avoid the

00:12:43,449 --> 00:12:47,499
distributed monolith right we can't just

00:12:45,850 --> 00:12:51,730
lift and shift this pizza all over the

00:12:47,499 --> 00:12:54,669
place we can't just take this big stack

00:12:51,730 --> 00:12:56,649
and containerize the big stack so that

00:12:54,669 --> 00:13:01,660
we can just launch this giant stack more

00:12:56,649 --> 00:13:03,339
times in a container you you don't get

00:13:01,660 --> 00:13:07,980
any benefit out of that you end up

00:13:03,339 --> 00:13:09,940
paying for you know paying a lot more

00:13:07,980 --> 00:13:14,700
especially in the

00:13:09,940 --> 00:13:17,650
space for no actual platform benefit as

00:13:14,700 --> 00:13:20,740
you move towards this the benefits you

00:13:17,650 --> 00:13:23,320
gain is you get a polyglot environment

00:13:20,740 --> 00:13:25,000
right you can think up of an idea write

00:13:23,320 --> 00:13:27,550
it in whatever thing you want and

00:13:25,000 --> 00:13:30,150
hopefully you're going to get the data

00:13:27,550 --> 00:13:35,440
that you need to make your application

00:13:30,150 --> 00:13:37,480
work and do really awesome things but

00:13:35,440 --> 00:13:46,530
you're not going to want to be bound by

00:13:37,480 --> 00:13:50,170
that monolith to do that and so we are

00:13:46,530 --> 00:13:54,970
using the Strangler patterns to do that

00:13:50,170 --> 00:13:56,410
so choose to keep this big monolith

00:13:54,970 --> 00:13:58,270
around we don't have too much of a

00:13:56,410 --> 00:14:02,920
choice to just get rid of it in one fell

00:13:58,270 --> 00:14:06,900
swoop but what we feel like we can do

00:14:02,920 --> 00:14:11,080
well is move towards the micro-service

00:14:06,900 --> 00:14:13,900
architecture over time moving from the

00:14:11,080 --> 00:14:15,970
old to platform 2.0 which is what we

00:14:13,900 --> 00:14:20,140
might call that at athenahealth and and

00:14:15,970 --> 00:14:25,650
and know that we can rely on what we

00:14:20,140 --> 00:14:29,890
have and we can break off chunks and

00:14:25,650 --> 00:14:34,410
start net new information and products

00:14:29,890 --> 00:14:36,610
in this new model by just kind of

00:14:34,410 --> 00:14:44,320
squeezing pieces out of that monolith

00:14:36,610 --> 00:14:49,420
over time so you know the reason why we

00:14:44,320 --> 00:14:51,790
choose to do that is that one it makes

00:14:49,420 --> 00:14:54,790
it easier to write net new functionality

00:14:51,790 --> 00:14:56,650
right with the monolith you're bound by

00:14:54,790 --> 00:14:59,200
all the interdependencies of what that

00:14:56,650 --> 00:15:02,200
model with represents you're bound by

00:14:59,200 --> 00:15:06,720
you have to write in Perl you have to

00:15:02,200 --> 00:15:09,250
know that you know not only is that host

00:15:06,720 --> 00:15:12,730
accepting the incoming queries for any

00:15:09,250 --> 00:15:16,450
requests to your application stack but

00:15:12,730 --> 00:15:18,520
it's also you know running the database

00:15:16,450 --> 00:15:20,950
and that data is only one thing it's a

00:15:18,520 --> 00:15:22,870
relational database you can do a lot of

00:15:20,950 --> 00:15:25,930
stuff with SQL but

00:15:22,870 --> 00:15:28,060
can you really do a lot of good stuff

00:15:25,930 --> 00:15:30,160
with your data in SQL or use it in

00:15:28,060 --> 00:15:35,020
different ways or move it into different

00:15:30,160 --> 00:15:37,960
patterns that you are able to support

00:15:35,020 --> 00:15:39,520
these new and exciting models that

00:15:37,960 --> 00:15:41,020
hopefully you're you're coming up with

00:15:39,520 --> 00:15:47,140
in your head and I'm hoping to become

00:15:41,020 --> 00:15:49,270
some part of the framework that we want

00:15:47,140 --> 00:15:55,360
to provide to help the industry and

00:15:49,270 --> 00:15:57,220
prove its efficiencies so you know

00:15:55,360 --> 00:16:01,020
another thing that this helps you do is

00:15:57,220 --> 00:16:06,580
move more quickly into a pattern where

00:16:01,020 --> 00:16:12,339
you can break things and fix them more

00:16:06,580 --> 00:16:14,529
quickly you can you know testing the

00:16:12,339 --> 00:16:17,890
monolith is really hard but testing a

00:16:14,529 --> 00:16:19,750
component of that monolith that I

00:16:17,890 --> 00:16:20,950
wouldn't even that's not actually

00:16:19,750 --> 00:16:22,510
correct so you're not gonna go on to

00:16:20,950 --> 00:16:24,970
test a component of the monolith in this

00:16:22,510 --> 00:16:26,740
model but testing that new functionality

00:16:24,970 --> 00:16:33,100
outside of the monolith in this model

00:16:26,740 --> 00:16:34,600
becomes a lot more easy and you know

00:16:33,100 --> 00:16:36,400
scaling that monolith with your business

00:16:34,600 --> 00:16:38,380
is really challenging it's definitely a

00:16:36,400 --> 00:16:42,970
big challenge that athenahealth follows

00:16:38,380 --> 00:16:47,490
finds in that you know the only way we

00:16:42,970 --> 00:16:47,490
can scale is to repeat this giant thing

00:16:51,180 --> 00:16:58,210
spoke to this just a bit but you know in

00:16:54,250 --> 00:17:01,360
the model if you have your you know your

00:16:58,210 --> 00:17:02,980
classic three-tier web application we've

00:17:01,360 --> 00:17:05,650
got this big giant database that holds

00:17:02,980 --> 00:17:07,360
all of your data you have some component

00:17:05,650 --> 00:17:09,670
of your application stack that accesses

00:17:07,360 --> 00:17:11,829
that data you have a layer that's doing

00:17:09,670 --> 00:17:15,579
your business logic to that information

00:17:11,829 --> 00:17:22,589
and then you present that to the user in

00:17:15,579 --> 00:17:27,220
some way as a whole so our solution and

00:17:22,589 --> 00:17:30,820
what we're working towards is breaking

00:17:27,220 --> 00:17:34,710
that apart and a really important part

00:17:30,820 --> 00:17:36,220
of that journey for us has been POC

00:17:34,710 --> 00:17:39,520
evaluations

00:17:36,220 --> 00:17:41,770
lots and lots of technologies trying

00:17:39,520 --> 00:17:47,789
them out just figuring out you know what

00:17:41,770 --> 00:17:50,230
works and what doesn't in a short-cycle

00:17:47,789 --> 00:17:52,570
environment and part of this as an

00:17:50,230 --> 00:17:56,590
organization Athena health has made a

00:17:52,570 --> 00:18:04,210
big change over the past year moving to

00:17:56,590 --> 00:18:06,250
an agile method as a company so not just

00:18:04,210 --> 00:18:10,299
in our DevOps teams not just in our

00:18:06,250 --> 00:18:14,380
operations and not just in in as a

00:18:10,299 --> 00:18:16,539
department what we call IaaS but at the

00:18:14,380 --> 00:18:18,820
developer level and at the application

00:18:16,539 --> 00:18:21,250
developer level reorganizing ourselves

00:18:18,820 --> 00:18:24,820
into scrum teams so we have smaller

00:18:21,250 --> 00:18:28,770
groups of people working on more focused

00:18:24,820 --> 00:18:33,940
points of the products and iterating on

00:18:28,770 --> 00:18:36,370
those projects much more quickly so in

00:18:33,940 --> 00:18:40,330
doing that we can function and we can

00:18:36,370 --> 00:18:42,900
perform these POCs more quickly the

00:18:40,330 --> 00:18:46,059
information that we learn out of those

00:18:42,900 --> 00:18:50,289
can be shared amongst our groups more

00:18:46,059 --> 00:18:54,940
quickly and as we find useful things out

00:18:50,289 --> 00:19:00,039
of that we can start putting them in

00:18:54,940 --> 00:19:03,820
place you know one of our mandates or or

00:19:00,039 --> 00:19:06,130
needs in the past year has been moving

00:19:03,820 --> 00:19:07,809
from only our data center so this is

00:19:06,130 --> 00:19:09,460
going to represent Athena health and its

00:19:07,809 --> 00:19:12,640
on-premise data center and all the

00:19:09,460 --> 00:19:15,940
components of what that is to the public

00:19:12,640 --> 00:19:19,390
cloud space first being you know Amazon

00:19:15,940 --> 00:19:22,780
but we're already working in as your we

00:19:19,390 --> 00:19:26,980
expect to try to be agnostic in the plap

00:19:22,780 --> 00:19:30,220
the the place where with we run

00:19:26,980 --> 00:19:32,380
applications but build an environment

00:19:30,220 --> 00:19:35,280
and an ecosystem that is consistent

00:19:32,380 --> 00:19:37,299
across all of those at the same time

00:19:35,280 --> 00:19:38,470
these are a number of the components

00:19:37,299 --> 00:19:41,980
that we've chosen so far that we're

00:19:38,470 --> 00:19:43,210
working towards right now DCOs miso

00:19:41,980 --> 00:19:46,030
support works

00:19:43,210 --> 00:19:49,159
Dakka Dakka Dakka Amazon Web Services

00:19:46,030 --> 00:19:54,919
which is the team that I work on

00:19:49,159 --> 00:19:58,929
in our group mostly Ryan is our is a

00:19:54,919 --> 00:20:02,179
counter to me in our on-prem kind of

00:19:58,929 --> 00:20:12,889
activities and deployments of this so

00:20:02,179 --> 00:20:16,039
that we are moving to an overall

00:20:12,889 --> 00:20:21,289
solution that that fits the micro

00:20:16,039 --> 00:20:24,019
service platform really well so our

00:20:21,289 --> 00:20:28,580
future state as we are transitioning

00:20:24,019 --> 00:20:31,850
from that monolith moving away from a

00:20:28,580 --> 00:20:35,480
single codebase into a much more

00:20:31,850 --> 00:20:39,320
flexible write what you want use what

00:20:35,480 --> 00:20:42,769
technology you might need environment

00:20:39,320 --> 00:20:44,600
allowing you to refactor and rewrite

00:20:42,769 --> 00:20:47,080
little components of your overall

00:20:44,600 --> 00:20:50,559
architecture stack much more quickly

00:20:47,080 --> 00:20:54,200
you know if right now if there's any

00:20:50,559 --> 00:20:56,659
component of our model if that that we

00:20:54,200 --> 00:20:59,299
want to change it's likely that it's

00:20:56,659 --> 00:21:01,250
really difficult to do that because of

00:20:59,299 --> 00:21:05,149
the interdependencies of everything else

00:21:01,250 --> 00:21:10,210
in that application stack in this micro

00:21:05,149 --> 00:21:13,279
service model you know your goal is to

00:21:10,210 --> 00:21:15,710
remove that dependency from the rest of

00:21:13,279 --> 00:21:22,519
your infrastructure so the component of

00:21:15,710 --> 00:21:26,059
that that you're deploying you can pull

00:21:22,519 --> 00:21:29,320
it out it can go away and or and it can

00:21:26,059 --> 00:21:32,059
be replaced without the entire

00:21:29,320 --> 00:21:33,860
deployment need to be updated at one

00:21:32,059 --> 00:21:37,309
point all of your patches to just go

00:21:33,860 --> 00:21:40,009
cleanly into the system on your your

00:21:37,309 --> 00:21:42,529
your second release of the quarter where

00:21:40,009 --> 00:21:46,149
if that doesn't happen you know you've

00:21:42,529 --> 00:21:50,090
got a systemic system-wide issue and

00:21:46,149 --> 00:21:56,289
this smaller model you have the ability

00:21:50,090 --> 00:21:56,289
to fail fast and fail forward

00:21:56,889 --> 00:22:02,019
you can release small alpha products

00:22:00,200 --> 00:22:05,000
into this environment

00:22:02,019 --> 00:22:09,889
to try them out it won't matter to the

00:22:05,000 --> 00:22:13,009
rest of your your stack because you can

00:22:09,889 --> 00:22:15,620
launch it try a subset of people to it

00:22:13,009 --> 00:22:19,720
pull it out next release release in beta

00:22:15,620 --> 00:22:28,309
move it out into production much more

00:22:19,720 --> 00:22:29,809
quickly once you do that then you can go

00:22:28,309 --> 00:22:32,379
back to your monolith and start pulling

00:22:29,809 --> 00:22:36,559
out bigger chunks of that monolith and

00:22:32,379 --> 00:22:39,919
moving components of that into your new

00:22:36,559 --> 00:22:48,700
infrastructure more efficiently and more

00:22:39,919 --> 00:22:53,029
successfully so another key part of what

00:22:48,700 --> 00:22:56,779
we feel is important and what seems to

00:22:53,029 --> 00:23:00,259
be a really my opinion smart idea is

00:22:56,779 --> 00:23:05,929
that you make sure that your

00:23:00,259 --> 00:23:09,250
infrastructure is also API driven that

00:23:05,929 --> 00:23:17,480
there's a level of abstraction from

00:23:09,250 --> 00:23:19,070
where you're running something that your

00:23:17,480 --> 00:23:24,879
application developer doesn't need to

00:23:19,070 --> 00:23:24,879
worry as much about excuse me

00:23:28,750 --> 00:23:41,270
so you know that that API abstraction is

00:23:34,820 --> 00:23:44,000
key value that you can provide in that

00:23:41,270 --> 00:23:48,800
abstraction is that you can move your

00:23:44,000 --> 00:23:51,080
individual business context outside of

00:23:48,800 --> 00:23:54,580
the platform with which you're running

00:23:51,080 --> 00:24:01,610
your containers or running your services

00:23:54,580 --> 00:24:04,790
into that API level so that you're not

00:24:01,610 --> 00:24:06,710
bound by having to know every single

00:24:04,790 --> 00:24:09,440
thing about what you need to run your

00:24:06,710 --> 00:24:17,530
application and you can just run your

00:24:09,440 --> 00:24:22,700
application API driven deployment cannot

00:24:17,530 --> 00:24:24,200
speed up your feedback loops from what

00:24:22,700 --> 00:24:27,830
you think is happening what you think

00:24:24,200 --> 00:24:31,790
should be happening and that that

00:24:27,830 --> 00:24:33,140
loopback is important for moving more

00:24:31,790 --> 00:24:35,170
quickly with your deployments your

00:24:33,140 --> 00:24:42,020
application development and your overall

00:24:35,170 --> 00:24:46,370
performance as a system so so a large

00:24:42,020 --> 00:24:49,580
part of also moving to this model is as

00:24:46,370 --> 00:24:53,570
an organization following it at the

00:24:49,580 --> 00:24:57,140
organization level to an agile

00:24:53,570 --> 00:25:02,510
transformation like the infrastructure

00:24:57,140 --> 00:25:05,450
itself is making a transition to and

00:25:02,510 --> 00:25:07,490
then you're hoping to push ownership of

00:25:05,450 --> 00:25:11,680
these services into the teams that are

00:25:07,490 --> 00:25:15,350
developing them and you're not having to

00:25:11,680 --> 00:25:17,330
deal with services that you may or may

00:25:15,350 --> 00:25:27,110
not know anything about at an Operations

00:25:17,330 --> 00:25:29,050
level or at the IT level and allow the

00:25:27,110 --> 00:25:32,060
application team to deploy to the API

00:25:29,050 --> 00:25:36,140
know that their system should be up and

00:25:32,060 --> 00:25:38,150
running know that when they fail they

00:25:36,140 --> 00:25:40,860
might be able to make their own update

00:25:38,150 --> 00:25:43,500
their own iteration on that

00:25:40,860 --> 00:25:47,160
and and manage how their service is

00:25:43,500 --> 00:25:55,740
working independent of the platform that

00:25:47,160 --> 00:25:58,350
it's running on another very important

00:25:55,740 --> 00:26:04,980
functionality that this is providing for

00:25:58,350 --> 00:26:08,280
us is the ability to run our underlying

00:26:04,980 --> 00:26:10,770
operand from our underlying technology

00:26:08,280 --> 00:26:12,840
stack that these applications are

00:26:10,770 --> 00:26:16,010
running on anywhere we want to

00:26:12,840 --> 00:26:20,780
and our API in front helps to

00:26:16,010 --> 00:26:24,660
orchestrate the the need the place where

00:26:20,780 --> 00:26:27,540
that container service may run for

00:26:24,660 --> 00:26:29,550
example this represents two different

00:26:27,540 --> 00:26:32,580
things it represents exactly the same

00:26:29,550 --> 00:26:36,720
thing in two different places so DCOs

00:26:32,580 --> 00:26:40,470
and miso is running in AWS DCOs and miso

00:26:36,720 --> 00:26:48,300
is running on premise bare metal in the

00:26:40,470 --> 00:26:52,380
clap our front end endpoint into what is

00:26:48,300 --> 00:26:55,110
on-premise can reuse the enterprise

00:26:52,380 --> 00:26:57,690
class net scalars that we already know

00:26:55,110 --> 00:27:00,000
as an organization and already utilize

00:26:57,690 --> 00:27:03,840
throughout our on-premise infrastructure

00:27:00,000 --> 00:27:08,370
and an ELB in front of how we get into

00:27:03,840 --> 00:27:11,130
our stack within on but the abstraction

00:27:08,370 --> 00:27:18,480
layer allows you to post your payload to

00:27:11,130 --> 00:27:21,930
the overall system and make a choice as

00:27:18,480 --> 00:27:24,450
to where you want to put it or via

00:27:21,930 --> 00:27:26,940
business logic within the API itself

00:27:24,450 --> 00:27:30,150
help you choose the best place to run

00:27:26,940 --> 00:27:31,920
this in that you know you might need

00:27:30,150 --> 00:27:33,270
access to data that can't live in the

00:27:31,920 --> 00:27:35,790
cloud in the healthcare industry

00:27:33,270 --> 00:27:40,320
possibly and so you need to run

00:27:35,790 --> 00:27:43,260
on-premise but you can rely platform in

00:27:40,320 --> 00:27:44,880
both places is exactly the same you know

00:27:43,260 --> 00:27:46,860
miso sphere says the operating system

00:27:44,880 --> 00:27:52,020
everywhere an operating system in the

00:27:46,860 --> 00:27:53,450
cloud this is the the place where we are

00:27:52,020 --> 00:27:56,110
and where we're

00:27:53,450 --> 00:27:56,110
moving to

00:28:04,120 --> 00:28:10,640
so a big thing in the model if a big

00:28:06,350 --> 00:28:14,960
thing on our challenge is silos of

00:28:10,640 --> 00:28:17,110
information giant Oracle databases that

00:28:14,960 --> 00:28:21,250
contain all this important information

00:28:17,110 --> 00:28:27,550
but there's no way there's no easy way

00:28:21,250 --> 00:28:29,960
to work with it in any model outside of

00:28:27,550 --> 00:28:32,930
SQL queries in Oracle and the way you

00:28:29,960 --> 00:28:34,850
get you know information out of that

00:28:32,930 --> 00:28:37,250
relational database you know you can

00:28:34,850 --> 00:28:42,170
hire all of this super super talented

00:28:37,250 --> 00:28:45,410
SQL Jedi's you can but you still only

00:28:42,170 --> 00:28:47,420
have that data in our case not only in

00:28:45,410 --> 00:28:55,160
one place but only in one place a bunch

00:28:47,420 --> 00:29:00,280
of times and you know when you have your

00:28:55,160 --> 00:29:00,280
data like that it is possible to affect

00:29:00,610 --> 00:29:05,510
other places where that data other

00:29:04,130 --> 00:29:10,210
places where you need to get that data

00:29:05,510 --> 00:29:15,890
in negative ways it makes it hard and so

00:29:10,210 --> 00:29:22,340
um you know goal of our data layer is to

00:29:15,890 --> 00:29:25,220
extract that out of those silos and give

00:29:22,340 --> 00:29:28,370
the application developers their choice

00:29:25,220 --> 00:29:33,680
of where they need their data and how

00:29:28,370 --> 00:29:36,610
they need it and write their

00:29:33,680 --> 00:29:41,180
applications to more effectively use

00:29:36,610 --> 00:29:43,870
sources so they can expand it out put it

00:29:41,180 --> 00:29:48,110
all back together tie it together and

00:29:43,870 --> 00:29:49,970
and then bring it back into the data

00:29:48,110 --> 00:29:52,520
silo right now bring it back into the

00:29:49,970 --> 00:29:55,850
monolith for its overall storage and

00:29:52,520 --> 00:30:00,620
interaction with our products as a whole

00:29:55,850 --> 00:30:05,990
or you know expose it out of some new

00:30:00,620 --> 00:30:11,290
service that it's that enhances our

00:30:05,990 --> 00:30:11,290
overall offerings to our customers

00:30:12,340 --> 00:30:16,770
internally one of the ways that we do

00:30:14,810 --> 00:30:21,250
that

00:30:16,770 --> 00:30:23,020
is I I guess I learned this morning in

00:30:21,250 --> 00:30:26,440
the smack stack but components of that

00:30:23,020 --> 00:30:29,800
smack stack where we can stream data out

00:30:26,440 --> 00:30:32,070
of Oracle from on-premise and move it

00:30:29,800 --> 00:30:37,900
into the cloud and transform it in ways

00:30:32,070 --> 00:30:39,790
that make it much more useful and then

00:30:37,900 --> 00:30:42,010
services then can be deployed to use the

00:30:39,790 --> 00:30:45,370
data in that manner instead of having to

00:30:42,010 --> 00:30:47,920
call back unto on Prem select the data

00:30:45,370 --> 00:30:49,150
out of the big data silo figure out what

00:30:47,920 --> 00:30:51,670
to do with it the data is coming

00:30:49,150 --> 00:30:56,920
streaming in it's being processed and

00:30:51,670 --> 00:31:00,730
transforms and it can be put back to

00:30:56,920 --> 00:31:03,880
where it needs to be to enhance the

00:31:00,730 --> 00:31:06,610
overall you know data records of

00:31:03,880 --> 00:31:10,330
patients in a doctor's office or or

00:31:06,610 --> 00:31:12,190
something along those lines you give the

00:31:10,330 --> 00:31:13,840
application developer the ability to

00:31:12,190 --> 00:31:16,510
choose the right place to put its data

00:31:13,840 --> 00:31:19,750
or the right way to use its data instead

00:31:16,510 --> 00:31:22,090
of limiting them to this this one way or

00:31:19,750 --> 00:31:26,250
no way

00:31:22,090 --> 00:31:26,250
methodology so

00:31:35,970 --> 00:31:41,250
just taking a quick look here in this

00:31:38,910 --> 00:31:43,410
song I just kind of describe one of the

00:31:41,250 --> 00:31:46,650
ways that we might be able to do this

00:31:43,410 --> 00:31:50,040
again we have our big silo of

00:31:46,650 --> 00:31:57,240
information and we can take that data

00:31:50,040 --> 00:32:01,470
out do processing in spark there's a

00:31:57,240 --> 00:32:03,990
layer this source agnostic CDC for

00:32:01,470 --> 00:32:06,440
example one way that we're transforming

00:32:03,990 --> 00:32:09,600
data out and distributing them amongst

00:32:06,440 --> 00:32:12,510
doesn't map or what plot what where the

00:32:09,600 --> 00:32:17,850
data is going necessarily could be

00:32:12,510 --> 00:32:20,070
on-premise could be in the cloud pulling

00:32:17,850 --> 00:32:22,950
the data out with Kafka streaming it

00:32:20,070 --> 00:32:25,920
using Kafka mirror maker to distribute

00:32:22,950 --> 00:32:31,370
it very quickly to our other locations

00:32:25,920 --> 00:32:33,690
of our platform using spark to do

00:32:31,370 --> 00:32:36,030
interesting data transformation or

00:32:33,690 --> 00:32:39,090
processing information on that storing

00:32:36,030 --> 00:32:43,800
it back into new data stores within the

00:32:39,090 --> 00:32:46,800
platform itself it might go from Oracle

00:32:43,800 --> 00:32:58,440
to Kafka to elasticsearch to spark back

00:32:46,800 --> 00:33:00,120
to elasticsearch to neo4j and you get

00:32:58,440 --> 00:33:01,530
that data out of the silo and in a

00:33:00,120 --> 00:33:03,150
really efficient way and then you can

00:33:01,530 --> 00:33:04,560
distribute it across your platform which

00:33:03,150 --> 00:33:10,350
your platform might be distributed

00:33:04,560 --> 00:33:12,720
across many different locations so with

00:33:10,350 --> 00:33:20,600
that there is a little bit of a demo

00:33:12,720 --> 00:33:24,990
here and what we will see is our

00:33:20,600 --> 00:33:29,460
business logic API endpoints into these

00:33:24,990 --> 00:33:32,430
two platforms where the application

00:33:29,460 --> 00:33:36,240
developer can define their marathon

00:33:32,430 --> 00:33:38,520
tasks in a way where they can either

00:33:36,240 --> 00:33:42,810
choose the destination and they want

00:33:38,520 --> 00:33:47,970
their application to be deployed to and

00:33:42,810 --> 00:33:49,920
and or multiple locations and have a

00:33:47,970 --> 00:33:54,690
single API

00:33:49,920 --> 00:33:59,670
action but be able to interact with all

00:33:54,690 --> 00:34:04,910
of our multiple platform locations to

00:33:59,670 --> 00:34:08,400
perform that and I'll just let it play

00:34:04,910 --> 00:34:11,790
hopefully we can glean from this what is

00:34:08,400 --> 00:34:13,890
happening and if and if we do end up

00:34:11,790 --> 00:34:15,960
with questions I definitely can kind of

00:34:13,890 --> 00:34:18,690
answer this but basically it starts out

00:34:15,960 --> 00:34:21,090
with a API post asking for what are my

00:34:18,690 --> 00:34:25,169
environments available and then it

00:34:21,090 --> 00:34:28,080
returns that I have this available in a

00:34:25,169 --> 00:34:31,410
playground I have in Bedford which is

00:34:28,080 --> 00:34:33,870
one of our data centers and I also have

00:34:31,410 --> 00:34:39,480
a dev environment which would be located

00:34:33,870 --> 00:34:45,900
in AWS I can define my job and in that

00:34:39,480 --> 00:34:48,150
marathon task I can give these clues to

00:34:45,900 --> 00:34:52,850
where I want my job to run how I want to

00:34:48,150 --> 00:34:52,850
run it what's happening when I run it

00:34:53,300 --> 00:34:59,750
this hopefully it's gonna be posted and

00:34:59,810 --> 00:35:09,300
we have a success it is created I can go

00:35:04,470 --> 00:35:17,240
back to my API and ask the environment

00:35:09,300 --> 00:35:17,240
for the status of what I have running

00:35:18,920 --> 00:35:24,570
fonts really small on my side too so

00:35:21,410 --> 00:35:26,700
we're getting to basically what we're

00:35:24,570 --> 00:35:30,240
doing is interacting with launching a

00:35:26,700 --> 00:35:36,540
service in two different locations with

00:35:30,240 --> 00:35:38,550
a similar with the same definition of

00:35:36,540 --> 00:35:42,270
the task we get information back we know

00:35:38,550 --> 00:35:46,710
that how many instances are running in

00:35:42,270 --> 00:35:49,050
both environments and we're seeing that

00:35:46,710 --> 00:35:51,660
we're in two different environments this

00:35:49,050 --> 00:35:53,670
is the same API interaction for the same

00:35:51,660 --> 00:35:58,500
service running in two different

00:35:53,670 --> 00:36:00,270
locations and what we'll also be able to

00:35:58,500 --> 00:36:03,490
see is that we can post the API to

00:36:00,270 --> 00:36:13,320
manage this the scale of that

00:36:03,490 --> 00:36:17,890
and in the end we have one place where a

00:36:13,320 --> 00:36:27,040
developer can interact with many systems

00:36:17,890 --> 00:36:33,670
across the environment so planning is

00:36:27,040 --> 00:36:36,070
definitely a key to this just moving the

00:36:33,670 --> 00:36:42,760
monolith to somewhere else isn't

00:36:36,070 --> 00:36:43,750
necessarily the answer making lots of

00:36:42,760 --> 00:36:46,450
POCs

00:36:43,750 --> 00:36:51,160
to experiment with technologies is

00:36:46,450 --> 00:36:53,590
really important some other challenges

00:36:51,160 --> 00:36:56,320
service discovery and load balancing is

00:36:53,590 --> 00:36:59,230
always going to be hard start small

00:36:56,320 --> 00:37:03,670
start with small components of your

00:36:59,230 --> 00:37:07,090
application stack that you may have or

00:37:03,670 --> 00:37:08,950
not and then once you are starting to

00:37:07,090 --> 00:37:12,090
get the handle of that your organization

00:37:08,950 --> 00:37:16,540
has made that transition into this new

00:37:12,090 --> 00:37:19,000
model of deploying services and creating

00:37:16,540 --> 00:37:20,980
services and then you can come back to

00:37:19,000 --> 00:37:23,560
your monolith and start pulling chunks

00:37:20,980 --> 00:37:28,990
out of it in a much more effective and

00:37:23,560 --> 00:37:30,370
much more easy way and you know the

00:37:28,990 --> 00:37:31,990
other thing that is difficult that you

00:37:30,370 --> 00:37:36,190
want to talk about sooner than later is

00:37:31,990 --> 00:37:40,150
is you know ownership of who's who's on

00:37:36,190 --> 00:37:42,100
call for what and you know instead of

00:37:40,150 --> 00:37:47,230
just typically throwing it over the wall

00:37:42,100 --> 00:37:50,350
to operations this plan might help you

00:37:47,230 --> 00:37:55,510
better serve that and help to break

00:37:50,350 --> 00:37:58,090
apart your monolith so with that if

00:37:55,510 --> 00:38:02,650
there are any questions I'm Erin at

00:37:58,090 --> 00:38:04,800
slyness on Twitter and does anyone have

00:38:02,650 --> 00:38:04,800
any questions

00:38:05,500 --> 00:38:12,760
there's my curious you mentioned moving

00:38:10,869 --> 00:38:14,290
applications and you also talked about

00:38:12,760 --> 00:38:16,599
the whole idea of streaming data out

00:38:14,290 --> 00:38:18,810
using spark and stuff which is cool it's

00:38:16,599 --> 00:38:20,950
you know I materialized view and like

00:38:18,810 --> 00:38:22,780
writing applications for like new stuff

00:38:20,950 --> 00:38:24,310
but it doesn't really address the one of

00:38:22,780 --> 00:38:25,869
the original problems that you talked

00:38:24,310 --> 00:38:30,250
about in the very beginning which is the

00:38:25,869 --> 00:38:32,260
user sharding user sharding deploying

00:38:30,250 --> 00:38:34,630
new instances of Oracle to be able to

00:38:32,260 --> 00:38:37,359
handle more users because you can't grow

00:38:34,630 --> 00:38:39,099
employee and then another issue is that

00:38:37,359 --> 00:38:41,710
all that data that's been streamed out

00:38:39,099 --> 00:38:43,090
is only it's read-only in general you're

00:38:41,710 --> 00:38:44,650
not gonna be able to screen it backwards

00:38:43,090 --> 00:38:46,270
back into Oracle and figure out which

00:38:44,650 --> 00:38:49,180
hard to go to and that kind of stuff

00:38:46,270 --> 00:38:50,680
or can you I'm not that's nice you also

00:38:49,180 --> 00:38:53,140
have a similar problem because we also

00:38:50,680 --> 00:38:55,599
bet user is so fundamental we can't just

00:38:53,140 --> 00:38:58,150
break out the users into some users

00:38:55,599 --> 00:39:00,550
service because it's too fundamental to

00:38:58,150 --> 00:39:01,750
the monolith right but from the model if

00:39:00,550 --> 00:39:04,930
you might be able to break out the

00:39:01,750 --> 00:39:07,030
authentication component or you might be

00:39:04,930 --> 00:39:09,670
able to break out a smaller component

00:39:07,030 --> 00:39:13,270
over time and pull that out and just

00:39:09,670 --> 00:39:15,130
like the streaming wouldn't be done

00:39:13,270 --> 00:39:18,250
processing the the processing would be

00:39:15,130 --> 00:39:21,070
done bark times the streaming in our

00:39:18,250 --> 00:39:23,820
case is being done using Kafka and out

00:39:21,070 --> 00:39:27,700
of that and and in that as well

00:39:23,820 --> 00:39:30,730
hopefully and in our case there can be

00:39:27,700 --> 00:39:33,250
an API in front back into the original

00:39:30,730 --> 00:39:36,280
data source and so you can stream the

00:39:33,250 --> 00:39:38,140
data out process the data transform it

00:39:36,280 --> 00:39:40,810
into an answer for what you want and

00:39:38,140 --> 00:39:42,580
then post it to an API that then gets

00:39:40,810 --> 00:39:44,890
consumed back into your original data

00:39:42,580 --> 00:39:48,820
source that's also rewrite bit about the

00:39:44,890 --> 00:39:50,170
sharding though any ideas and how your

00:39:48,820 --> 00:39:52,150
company's gonna help shard

00:39:50,170 --> 00:39:53,920
so with my knowledge base I can't

00:39:52,150 --> 00:39:56,770
actually answer that question as far as

00:39:53,920 --> 00:39:59,109
the overall structure of how they want

00:39:56,770 --> 00:40:03,130
to consume data back into the hole of

00:39:59,109 --> 00:40:05,140
Athena net but you know that's a good

00:40:03,130 --> 00:40:09,550
question it's probably answered many

00:40:05,140 --> 00:40:11,260
different ways of course but I don't

00:40:09,550 --> 00:40:13,720
think that streaming data out of a data

00:40:11,260 --> 00:40:15,609
source necessarily means that you can't

00:40:13,720 --> 00:40:18,380
put data back into that same data source

00:40:15,609 --> 00:40:21,500
after it's been processed in some way

00:40:18,380 --> 00:40:24,890
the key I think the takeaway would be

00:40:21,500 --> 00:40:28,160
try to make it as an API where you can

00:40:24,890 --> 00:40:30,530
post back to some location and then that

00:40:28,160 --> 00:40:32,600
that service or that logic is able to

00:40:30,530 --> 00:40:43,730
determine the proper place to store that

00:40:32,600 --> 00:40:46,090
again thank you all right well thank you

00:40:43,730 --> 00:40:46,090

YouTube URL: https://www.youtube.com/watch?v=za4CQvwDN9g


