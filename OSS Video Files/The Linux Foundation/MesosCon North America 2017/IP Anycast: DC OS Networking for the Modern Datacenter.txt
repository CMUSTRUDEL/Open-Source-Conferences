Title: IP Anycast: DC OS Networking for the Modern Datacenter
Publication date: 2017-09-18
Playlist: MesosCon North America 2017
Description: 
	IP Anycast: DC/OS Networking for the Modern Datacenter - Bill Green, New Relic, Inc.

Modern datacenter networks are leveraging BGP and spine-leaf topologies to enable massive scale-out. This presentation will survey New Relic's implementation of IP Anycast for Docker containers running on DC/OS. Such an implementation allows several containers to be deployed with the same IP address, allowing the network to share traffic between them. We will explore some container deployments that are greatly simplified by using this technique.

About 

Bill Green
Senior Site Reliability Engineer, New Relic, Inc.
Captions: 
	00:00:00,000 --> 00:00:05,130
what we're gonna talk about today is IP

00:00:02,159 --> 00:00:08,849
anycast and how to implement it with D

00:00:05,130 --> 00:00:10,469
cos or mezzos everything that I'm

00:00:08,849 --> 00:00:13,139
showing you here should work equally

00:00:10,469 --> 00:00:16,170
well with open source like mezzos or D

00:00:13,139 --> 00:00:18,630
cos or whatever so my name is Bill green

00:00:16,170 --> 00:00:19,020
I'm a site reliability engineer at New

00:00:18,630 --> 00:00:21,150
Relic

00:00:19,020 --> 00:00:23,070
and what I'm showing you today is

00:00:21,150 --> 00:00:25,260
something that we are sort of

00:00:23,070 --> 00:00:27,660
experimenting with in our data center

00:00:25,260 --> 00:00:29,369
and I should probably just say from the

00:00:27,660 --> 00:00:32,809
outset that what I'm going to talk about

00:00:29,369 --> 00:00:35,489
is is kind of a silver bullet it has

00:00:32,809 --> 00:00:38,040
sort of a limited number of use cases

00:00:35,489 --> 00:00:41,520
but for those cases it works pretty well

00:00:38,040 --> 00:00:44,430
but I'm hoping that in covering these

00:00:41,520 --> 00:00:47,640
topics we'll go over some stuff that's

00:00:44,430 --> 00:00:50,190
useful anyway like you know how to do

00:00:47,640 --> 00:00:52,260
networking and what plugins are and

00:00:50,190 --> 00:00:56,449
things like that so I'm hoping that you

00:00:52,260 --> 00:00:56,449
know it's it's useful broadly speaking

00:00:56,480 --> 00:01:03,300
so the first thing I guess we should

00:00:58,829 --> 00:01:04,500
talk about is so what is anycast it's

00:01:03,300 --> 00:01:06,750
one of those terms that you hear a lot

00:01:04,500 --> 00:01:10,619
and it's not role maybe it's not real

00:01:06,750 --> 00:01:13,049
clear what it is so from a layer 2

00:01:10,619 --> 00:01:16,560
perspective like on an Ethernet LAN or

00:01:13,049 --> 00:01:18,540
whatever you have broadcast traffic and

00:01:16,560 --> 00:01:21,270
you have unicast traffic and you have

00:01:18,540 --> 00:01:23,970
multicast traffic and so the differences

00:01:21,270 --> 00:01:26,400
between them are sort of how the

00:01:23,970 --> 00:01:29,400
addresses are or how the frames are

00:01:26,400 --> 00:01:31,200
address to stations on the land so

00:01:29,400 --> 00:01:33,299
broadcast goes to everybody

00:01:31,200 --> 00:01:36,509
unicast goes to one station and

00:01:33,299 --> 00:01:37,920
multicast goes to a group and the

00:01:36,509 --> 00:01:40,979
members of that group can elect

00:01:37,920 --> 00:01:46,710
themselves to be in the group IP anycast

00:01:40,979 --> 00:01:51,590
works at layer 3 and it's not so much a

00:01:46,710 --> 00:01:55,290
feature of something will go into that

00:01:51,590 --> 00:01:57,659
so what it is is it's where you have the

00:01:55,290 --> 00:02:00,780
same IP address that appears in multiple

00:01:57,659 --> 00:02:03,320
locations in the network and so you let

00:02:00,780 --> 00:02:06,390
the routing protocol decide which

00:02:03,320 --> 00:02:09,119
particular address is going to receive

00:02:06,390 --> 00:02:11,760
the traffic and so the way that this

00:02:09,119 --> 00:02:12,800
sort of works is that the routers you

00:02:11,760 --> 00:02:15,240
know keep

00:02:12,800 --> 00:02:17,840
have a routing table and they have the

00:02:15,240 --> 00:02:20,940
destinations in the routing table and

00:02:17,840 --> 00:02:24,360
normally the routers will pick the

00:02:20,940 --> 00:02:26,190
closest or the the lowest metric or you

00:02:24,360 --> 00:02:28,740
know some sort of administrative thing

00:02:26,190 --> 00:02:30,390
to pick one route and put in the routing

00:02:28,740 --> 00:02:33,090
table and that's the active route so

00:02:30,390 --> 00:02:34,860
even though you may have multiple routes

00:02:33,090 --> 00:02:38,610
to a destination the router normally

00:02:34,860 --> 00:02:39,780
only picks one with any caste it

00:02:38,610 --> 00:02:42,300
actually will make use of multiple

00:02:39,780 --> 00:02:45,150
routes and this sort of thing has been

00:02:42,300 --> 00:02:47,760
in use for a while and it's if you've

00:02:45,150 --> 00:02:51,030
ever used like you know Google's public

00:02:47,760 --> 00:02:53,220
resolver that the 8.8.8.8 that's that's

00:02:51,030 --> 00:02:54,170
an anycast thing if you try to hit that

00:02:53,220 --> 00:02:56,730
IP address

00:02:54,170 --> 00:03:00,240
you'll get routed to like the closest

00:02:56,730 --> 00:03:04,400
you know 8.8.8.8 to you and it's not

00:03:00,240 --> 00:03:07,920
necessarily the same one every time so

00:03:04,400 --> 00:03:10,110
any caste like I said is an effect it's

00:03:07,920 --> 00:03:12,180
not a feature so if you go you know

00:03:10,110 --> 00:03:13,950
thumbing through your your router manual

00:03:12,180 --> 00:03:16,050
looking for like how did it turn on any

00:03:13,950 --> 00:03:18,840
cache you're not going to find it on the

00:03:16,050 --> 00:03:22,380
feature is called ec NP or equal cost

00:03:18,840 --> 00:03:24,840
multi path and all that usually is is

00:03:22,380 --> 00:03:27,180
it's a little knob in the config where

00:03:24,840 --> 00:03:31,080
you tell the router or the routing

00:03:27,180 --> 00:03:32,940
protocol be it bgp or OSPF or you know

00:03:31,080 --> 00:03:33,330
whatever routing protocol that you're

00:03:32,940 --> 00:03:35,730
using

00:03:33,330 --> 00:03:39,450
you tell the routing protocol I want you

00:03:35,730 --> 00:03:41,250
to use multiple routes so if if you can

00:03:39,450 --> 00:03:43,650
see multiple paths to a particular

00:03:41,250 --> 00:03:45,810
destination I want you to use all of

00:03:43,650 --> 00:03:47,640
them and not just pick the best one

00:03:45,810 --> 00:03:50,910
but keep all of those in the routing

00:03:47,640 --> 00:03:53,790
table and it will do this if the the

00:03:50,910 --> 00:03:56,850
routes are of equal cost and there's

00:03:53,790 --> 00:03:59,910
there's some other details in there like

00:03:56,850 --> 00:04:03,150
if you're running BGP typically it wants

00:03:59,910 --> 00:04:07,200
to keep the same destination a yes but

00:04:03,150 --> 00:04:09,780
there's knobs to override that this this

00:04:07,200 --> 00:04:14,160
little knob for equal cost multi path

00:04:09,780 --> 00:04:17,100
will apply to BGP to OSPF both version

00:04:14,160 --> 00:04:20,370
two and three you can use it for MPLS if

00:04:17,100 --> 00:04:23,360
you're like advanced and it's it's

00:04:20,370 --> 00:04:25,710
usually as simple as just going into the

00:04:23,360 --> 00:04:28,260
configuration in

00:04:25,710 --> 00:04:31,110
how many routes you want to use and the

00:04:28,260 --> 00:04:33,630
router implementation will have limits

00:04:31,110 --> 00:04:35,790
on the number of equal cost routes that

00:04:33,630 --> 00:04:37,950
it will do usually it's on the order of

00:04:35,790 --> 00:04:39,900
like sixteen thirty-two something like

00:04:37,950 --> 00:04:42,030
that so you would say like under your

00:04:39,900 --> 00:04:43,740
BGP config like I want you to use like

00:04:42,030 --> 00:04:45,990
you know four routes or whatever and

00:04:43,740 --> 00:04:50,510
that will tell it to to enable this

00:04:45,990 --> 00:04:52,890
feature so a contrived example of this

00:04:50,510 --> 00:04:56,370
let's say and I'm sorry for being

00:04:52,890 --> 00:04:58,530
us-centric here my being an American I'm

00:04:56,370 --> 00:05:01,110
my geography is poor so I'm gonna rely

00:04:58,530 --> 00:05:03,390
on what I know so let's pretend like we

00:05:01,110 --> 00:05:05,100
have SFO San Francisco Chicago and New

00:05:03,390 --> 00:05:06,840
York and Dallas that you can imagine

00:05:05,100 --> 00:05:09,090
like a ring or something around the US

00:05:06,840 --> 00:05:10,320
so if you're connected to you San

00:05:09,090 --> 00:05:13,500
Francisco and you want to send something

00:05:10,320 --> 00:05:15,150
to something in New York you can go the

00:05:13,500 --> 00:05:16,680
northern route so San Francisco Chicago

00:05:15,150 --> 00:05:19,410
New York or you can go to the southern

00:05:16,680 --> 00:05:22,410
route some Cisco Dallas New York so the

00:05:19,410 --> 00:05:25,710
SFO router will have you know in a

00:05:22,410 --> 00:05:28,170
contrived example two equal paths to

00:05:25,710 --> 00:05:30,300
that destination so if you turn on equal

00:05:28,170 --> 00:05:32,820
cost multi path in San Francisco it will

00:05:30,300 --> 00:05:34,710
it will put both of those routes in its

00:05:32,820 --> 00:05:37,770
routing table and so if it gets a packet

00:05:34,710 --> 00:05:40,230
from A to B it will basically load

00:05:37,770 --> 00:05:44,360
balanced or load share on both of those

00:05:40,230 --> 00:05:47,670
paths now at this point the astute

00:05:44,360 --> 00:05:50,220
reader will probably freak out and say

00:05:47,670 --> 00:05:52,350
oh my god huh what if packets you know

00:05:50,220 --> 00:05:54,450
get out of order you know that kind of

00:05:52,350 --> 00:05:59,220
thing so there's implications doing this

00:05:54,450 --> 00:06:01,710
on one of them is that the ecmp will

00:05:59,220 --> 00:06:05,460
take care of the flows for you generally

00:06:01,710 --> 00:06:07,440
speaking they will hash the destinations

00:06:05,460 --> 00:06:10,050
using some sort of hashing algorithm

00:06:07,440 --> 00:06:12,960
typically it's like they will take the

00:06:10,050 --> 00:06:15,630
source and destination IPS and ports and

00:06:12,960 --> 00:06:17,820
sort of hash those together in a group

00:06:15,630 --> 00:06:20,850
of buckets so that all of the packets in

00:06:17,820 --> 00:06:23,340
the same flow will go the same route and

00:06:20,850 --> 00:06:25,950
this avoids having you know packets from

00:06:23,340 --> 00:06:27,870
it the same flow possibly being

00:06:25,950 --> 00:06:32,250
reordered if they're going in different

00:06:27,870 --> 00:06:35,760
paths there's usually knobs in the

00:06:32,250 --> 00:06:37,500
router to affect how this hashing

00:06:35,760 --> 00:06:39,069
algorithm works you can sometimes tell

00:06:37,500 --> 00:06:40,899
it to use

00:06:39,069 --> 00:06:43,270
you know source destination ports

00:06:40,899 --> 00:06:46,839
sometimes you can go as far down as like

00:06:43,270 --> 00:06:47,949
the the ethernet address if you wanted

00:06:46,839 --> 00:06:50,800
to

00:06:47,949 --> 00:06:52,869
usually on modern routers the hashing

00:06:50,800 --> 00:06:55,719
algorithm is a consistent algorithm so

00:06:52,869 --> 00:06:58,240
that if you were if one of these paths

00:06:55,719 --> 00:07:02,319
becomes unavailable you don't have to

00:06:58,240 --> 00:07:05,619
rebalance all of these hash you know the

00:07:02,319 --> 00:07:09,399
hash entries you only lose the entries

00:07:05,619 --> 00:07:12,039
for the the link that you lost and this

00:07:09,399 --> 00:07:13,300
has implications for things like you

00:07:12,039 --> 00:07:15,189
know if you're balancing long lived

00:07:13,300 --> 00:07:17,589
flows and things like that you don't

00:07:15,189 --> 00:07:20,469
want to disrupt everything if you lose

00:07:17,589 --> 00:07:25,240
one path and with that you usually don't

00:07:20,469 --> 00:07:29,559
have to so we're gonna talk a little bit

00:07:25,240 --> 00:07:32,110
now about routing in a data center so we

00:07:29,559 --> 00:07:35,020
have we have this idea of anycast and so

00:07:32,110 --> 00:07:38,649
we have to talk about routing in a data

00:07:35,020 --> 00:07:41,189
center excuse me so we know how how to

00:07:38,649 --> 00:07:44,439
sort of implement it this is the usual

00:07:41,189 --> 00:07:46,870
this is the Cisco model that was popular

00:07:44,439 --> 00:07:49,870
for a long time and I it still is in

00:07:46,870 --> 00:07:51,580
wide use and it has the idea of core

00:07:49,870 --> 00:07:54,519
distribution and access where you do

00:07:51,580 --> 00:07:57,009
this aggregation from like you know a

00:07:54,519 --> 00:07:58,899
lot of ports at top-of-rack and use you

00:07:57,009 --> 00:08:03,059
sort of aggregate your traffic as you go

00:07:58,899 --> 00:08:08,139
north in the data center and so forth

00:08:03,059 --> 00:08:11,199
this is this is not really a design that

00:08:08,139 --> 00:08:13,719
will scale it does have some benefits

00:08:11,199 --> 00:08:15,490
like it's optimized to lower the per

00:08:13,719 --> 00:08:17,499
port cost at your top-of-rack that's

00:08:15,490 --> 00:08:19,119
really what it's designed to do

00:08:17,499 --> 00:08:21,610
the drawbacks of this are pretty much

00:08:19,119 --> 00:08:25,149
everything else it is really hard to

00:08:21,610 --> 00:08:26,979
scale this it's expensive it's usually

00:08:25,149 --> 00:08:29,379
there's usually a lot of layer too

00:08:26,979 --> 00:08:32,380
involved so you get these really large

00:08:29,379 --> 00:08:34,599
broadcast domains which are sometimes

00:08:32,380 --> 00:08:38,019
hard to troubleshoot the alternative to

00:08:34,599 --> 00:08:41,949
doing it this way is with a so called

00:08:38,019 --> 00:08:44,319
spine leaf topology this is the more I'm

00:08:41,949 --> 00:08:45,240
gonna say modern way to do it this is

00:08:44,319 --> 00:08:47,550
the

00:08:45,240 --> 00:08:49,200
more popular in a data center so what

00:08:47,550 --> 00:08:52,410
you do in this sort of design is you

00:08:49,200 --> 00:08:54,779
have your top of rack and and you have a

00:08:52,410 --> 00:08:58,470
spine layer that's sort of your core and

00:08:54,779 --> 00:09:01,589
everything talks BGP so that each each

00:08:58,470 --> 00:09:03,630
of your racks then become an autonomous

00:09:01,589 --> 00:09:05,310
system and they're kind of like their

00:09:03,630 --> 00:09:07,020
own little ISP or their own little

00:09:05,310 --> 00:09:09,240
network and so all of these things

00:09:07,020 --> 00:09:12,330
become little islands that exchange

00:09:09,240 --> 00:09:14,820
routing information with the spine as if

00:09:12,330 --> 00:09:17,670
the spine were the internet provider of

00:09:14,820 --> 00:09:19,260
these these racks and at first glance it

00:09:17,670 --> 00:09:21,720
seems kind of crazy to do something like

00:09:19,260 --> 00:09:25,500
this but the advantages of doing this

00:09:21,720 --> 00:09:27,089
are that BGP is a very robust protocol

00:09:25,500 --> 00:09:30,060
it's been in use forever it's very

00:09:27,089 --> 00:09:32,490
mature it's well understood and it's

00:09:30,060 --> 00:09:35,310
actually very simple to configure it's

00:09:32,490 --> 00:09:37,260
generally as simple as just naming a

00:09:35,310 --> 00:09:39,360
route and saying hey I have this route I

00:09:37,260 --> 00:09:43,290
want you to export this to everyone else

00:09:39,360 --> 00:09:45,390
and it will go do that and so that the

00:09:43,290 --> 00:09:49,380
topological features here are that you

00:09:45,390 --> 00:09:51,089
have usually a grouping of spines that

00:09:49,380 --> 00:09:55,290
follow a power of two so you'll have

00:09:51,089 --> 00:09:58,320
like two force you know 816 spines and

00:09:55,290 --> 00:10:02,010
each top-of-rack is connected to each

00:09:58,320 --> 00:10:04,380
one of the spines and equal cost multi

00:10:02,010 --> 00:10:06,570
path routing is used throughout a design

00:10:04,380 --> 00:10:08,220
like this and what what ends up

00:10:06,570 --> 00:10:10,050
happening is that at the top of rack

00:10:08,220 --> 00:10:12,570
there if you could imagine that these

00:10:10,050 --> 00:10:14,610
are ten gig links you have an aggregate

00:10:12,570 --> 00:10:17,070
bandwidth of 40 gigs out of the top of

00:10:14,610 --> 00:10:20,010
rack and it's load balanced among these

00:10:17,070 --> 00:10:22,140
different paths and if you lose one of

00:10:20,010 --> 00:10:23,820
those links the traffic will just shift

00:10:22,140 --> 00:10:25,740
over to the remaining three so in the

00:10:23,820 --> 00:10:27,720
case of a failure you just end up

00:10:25,740 --> 00:10:29,880
degrading your bandwidth a little bit

00:10:27,720 --> 00:10:32,790
and you you have like a numbers game

00:10:29,880 --> 00:10:35,160
where you can support a maximum number

00:10:32,790 --> 00:10:36,810
of racks based on the port density of

00:10:35,160 --> 00:10:39,120
your spine typically these are on the

00:10:36,810 --> 00:10:41,339
order of like 96 ports or something like

00:10:39,120 --> 00:10:43,709
that so on it's fine layer you you'd

00:10:41,339 --> 00:10:45,899
support like a hundred racks basically

00:10:43,709 --> 00:10:48,870
and you would over subscribe the

00:10:45,899 --> 00:10:50,430
bandwidth in your racks by like an order

00:10:48,870 --> 00:10:52,890
of maybe three to one or something

00:10:50,430 --> 00:10:55,140
worried you might have you know 40 gigs

00:10:52,890 --> 00:10:57,360
aggregate out of your top of rack and in

00:10:55,140 --> 00:10:57,779
in your rack you might have 30 servers

00:10:57,360 --> 00:11:01,199
can

00:10:57,779 --> 00:11:02,610
did you know at one gig each or

00:11:01,199 --> 00:11:04,139
something like that so there's there's

00:11:02,610 --> 00:11:05,790
some oversubscription here so it

00:11:04,139 --> 00:11:09,420
requires you you know you kind of be

00:11:05,790 --> 00:11:16,110
judicious about how you provision these

00:11:09,420 --> 00:11:17,579
things so from oh sorry so the spine

00:11:16,110 --> 00:11:19,949
leaf topology so it's later three

00:11:17,579 --> 00:11:22,949
everywhere you could do OSPF the more

00:11:19,949 --> 00:11:26,879
common that I've seen is BGP usually

00:11:22,949 --> 00:11:29,389
this is e BGP so it's external so every

00:11:26,879 --> 00:11:32,610
every sort of thing here is is a

00:11:29,389 --> 00:11:35,370
autonomous system among itself and it

00:11:32,610 --> 00:11:38,759
sort of like peers with everybody the

00:11:35,370 --> 00:11:42,149
benefits are a massive scale out you can

00:11:38,759 --> 00:11:44,879
sort of see here that everything every

00:11:42,149 --> 00:11:47,819
rep becomes one hop away so it tends to

00:11:44,879 --> 00:11:49,470
equalize your latency so that everything

00:11:47,819 --> 00:11:50,850
you don't have these crazy you know

00:11:49,470 --> 00:11:53,339
where you go all the way up to the top

00:11:50,850 --> 00:11:57,209
and back down to reach you know in a in

00:11:53,339 --> 00:11:58,410
a sort of more core access distribution

00:11:57,209 --> 00:12:00,449
model you don't have to go all the way

00:11:58,410 --> 00:12:02,639
up through that stack and back down each

00:12:00,449 --> 00:12:05,269
hop is basically just one bounce off the

00:12:02,639 --> 00:12:08,610
spine layer and so it's very low latency

00:12:05,269 --> 00:12:11,910
and like I said with BGP it's simple its

00:12:08,610 --> 00:12:13,589
robust its mature so what does this look

00:12:11,910 --> 00:12:15,480
like well you have like your top of

00:12:13,589 --> 00:12:17,160
racks you have your a s's and so you

00:12:15,480 --> 00:12:21,509
might have something like this where

00:12:17,160 --> 00:12:22,949
each rack is an AAS so you can actually

00:12:21,509 --> 00:12:26,160
bring this down to the host if you

00:12:22,949 --> 00:12:28,230
wanted to you can run a BGP daemon on

00:12:26,160 --> 00:12:31,079
the host and you can have the host in

00:12:28,230 --> 00:12:33,449
its own a s and then what you do is for

00:12:31,079 --> 00:12:35,370
everything that runs on the host you

00:12:33,449 --> 00:12:37,379
just simply announce a host route for

00:12:35,370 --> 00:12:39,420
that thing now your thing can be a

00:12:37,379 --> 00:12:42,990
container it can be a service it can be

00:12:39,420 --> 00:12:45,629
whatever and then in this way as your

00:12:42,990 --> 00:12:48,209
services come and go the routes are

00:12:45,629 --> 00:12:50,490
announced and withdrawn and so this sort

00:12:48,209 --> 00:12:52,589
of saves you from having to do like a

00:12:50,490 --> 00:12:54,600
load balancer to keep track of where

00:12:52,589 --> 00:12:57,329
everything is or do like complicated

00:12:54,600 --> 00:12:59,220
service discovery schemes to maintain

00:12:57,329 --> 00:13:02,189
you know to understand where your stuff

00:12:59,220 --> 00:13:03,870
is but what does this look like as far

00:13:02,189 --> 00:13:06,300
as docker goes because this is this is

00:13:03,870 --> 00:13:10,500
where the hard part comes in so in a

00:13:06,300 --> 00:13:13,110
typical docker deploy like your your

00:13:10,500 --> 00:13:14,759
standard installed docker you you

00:13:13,110 --> 00:13:17,670
usually run this in a layer to bridge

00:13:14,759 --> 00:13:21,660
and what this is is inside the Linux

00:13:17,670 --> 00:13:24,980
kernel you get a bridge device and you

00:13:21,660 --> 00:13:28,559
have a docker 0 there and you allocate

00:13:24,980 --> 00:13:31,079
these interfaces in pairs so you might

00:13:28,559 --> 00:13:32,910
spin up a container you would allocate a

00:13:31,079 --> 00:13:34,529
namespace to the container so the

00:13:32,910 --> 00:13:38,129
container gets its own copy of the

00:13:34,529 --> 00:13:40,529
network stack and then you build a

00:13:38,129 --> 00:13:42,809
virtual Ethernet pair and you give one

00:13:40,529 --> 00:13:44,639
end to the container and then you give

00:13:42,809 --> 00:13:47,850
one end to the kernel and that's how you

00:13:44,639 --> 00:13:50,040
talk across the name space as you you do

00:13:47,850 --> 00:13:52,079
that kind of thing you can either and

00:13:50,040 --> 00:13:54,240
this is just a point-to-point link doing

00:13:52,079 --> 00:13:56,100
this bridge topology thing where you

00:13:54,240 --> 00:13:58,589
give one slide to the container and one

00:13:56,100 --> 00:14:01,110
site into the kernel that's no different

00:13:58,589 --> 00:14:02,850
from like a t1 link or something where

00:14:01,110 --> 00:14:05,279
you're like linking a remote office it's

00:14:02,850 --> 00:14:06,750
exactly the same thing except in this

00:14:05,279 --> 00:14:09,689
case you're not routing it you're

00:14:06,750 --> 00:14:12,000
bridging it so this is layer 2 so in the

00:14:09,689 --> 00:14:14,009
kernel you collect all of these virtual

00:14:12,000 --> 00:14:15,720
Ethernet interfaces that go out to your

00:14:14,009 --> 00:14:17,970
various containers and you put them in a

00:14:15,720 --> 00:14:20,250
bridge this is just like a layer 2

00:14:17,970 --> 00:14:21,870
switch so it's like you're you're you

00:14:20,250 --> 00:14:23,129
know taking all of these remote offices

00:14:21,870 --> 00:14:24,929
or whatever and you're putting them on a

00:14:23,129 --> 00:14:29,279
switch so that you have a layer 2 and

00:14:24,929 --> 00:14:31,319
you you know send the frames everywhere

00:14:29,279 --> 00:14:32,850
and there's some kernel trickery that

00:14:31,319 --> 00:14:35,209
that comes into this but this is

00:14:32,850 --> 00:14:37,829
basically what you have and the most

00:14:35,209 --> 00:14:40,049
important point is that all of the IP

00:14:37,829 --> 00:14:42,329
addresses that get allocated to the

00:14:40,049 --> 00:14:44,670
container come out of the same IP block

00:14:42,329 --> 00:14:48,629
so this is like you would a docker

00:14:44,670 --> 00:14:50,519
usually gives like 172 17 you know in

00:14:48,629 --> 00:14:51,990
this case it's like 0.1 and so every

00:14:50,519 --> 00:14:55,579
container gets an IP address on this

00:14:51,990 --> 00:14:58,889
network we can't use this to announce

00:14:55,579 --> 00:15:01,110
via bgp mainly because we'd have to

00:14:58,889 --> 00:15:03,299
announce the entire network we would not

00:15:01,110 --> 00:15:05,910
be able to like go down to the to the

00:15:03,299 --> 00:15:07,649
individual layers of the docker

00:15:05,910 --> 00:15:09,329
containers because there's only one

00:15:07,649 --> 00:15:11,819
interface here in the kernel and that's

00:15:09,329 --> 00:15:13,529
Dockers zero so you would have to either

00:15:11,819 --> 00:15:16,230
announce that you have all of the

00:15:13,529 --> 00:15:17,910
containers or none of them and so if one

00:15:16,230 --> 00:15:19,020
or two or three if your containers are

00:15:17,910 --> 00:15:20,850
not reachable

00:15:19,020 --> 00:15:24,600
black hole he would announce that you

00:15:20,850 --> 00:15:27,330
have them even though you don't so what

00:15:24,600 --> 00:15:30,780
we want instead for this anycast scheme

00:15:27,330 --> 00:15:33,210
is we want what I just showed you except

00:15:30,780 --> 00:15:34,830
we want it routed we want to we want to

00:15:33,210 --> 00:15:36,720
still give every container its own

00:15:34,830 --> 00:15:38,580
namespace we want to make a pair of

00:15:36,720 --> 00:15:40,770
virtual Ethernet we want to give one to

00:15:38,580 --> 00:15:42,120
the container and keep one but we want

00:15:40,770 --> 00:15:43,590
to route it we don't want to bridge it

00:15:42,120 --> 00:15:46,860
and the reason why we want to route it

00:15:43,590 --> 00:15:49,020
is because these become hosts routes so

00:15:46,860 --> 00:15:51,690
instead of having a bridge network we

00:15:49,020 --> 00:15:54,360
had these slosh 32s which means they're

00:15:51,690 --> 00:15:56,820
just routes to a host and these routes

00:15:54,360 --> 00:15:58,950
go in the kernel table on the host and

00:15:56,820 --> 00:16:01,200
whenever you have routes in a kernel

00:15:58,950 --> 00:16:03,450
table you can then redistribute those

00:16:01,200 --> 00:16:05,880
via the BGP daemon into the rest of your

00:16:03,450 --> 00:16:08,970
network and then as containers come and

00:16:05,880 --> 00:16:10,590
go these interfaces go down and and come

00:16:08,970 --> 00:16:12,930
up or whatever and these host routes

00:16:10,590 --> 00:16:14,790
appear and disappear and thus they're

00:16:12,930 --> 00:16:17,100
announced and withdrawn from the network

00:16:14,790 --> 00:16:22,290
so this is this is what we want to have

00:16:17,100 --> 00:16:24,570
and this allows us to we can do IP per

00:16:22,290 --> 00:16:27,540
container this way so if you if you have

00:16:24,570 --> 00:16:29,040
some some IPAM scheme where you want to

00:16:27,540 --> 00:16:32,430
you know assign IP address into

00:16:29,040 --> 00:16:34,470
containers you can do this but in our

00:16:32,430 --> 00:16:36,450
case we want to assign the same IP

00:16:34,470 --> 00:16:39,360
address to a group of containers so we

00:16:36,450 --> 00:16:42,240
want to take you know marathon and we

00:16:39,360 --> 00:16:44,760
want to deploy you know in copies of an

00:16:42,240 --> 00:16:46,350
application with marathon we want each

00:16:44,760 --> 00:16:48,480
one of those instances to come up with

00:16:46,350 --> 00:16:50,760
this exact same IP address in different

00:16:48,480 --> 00:16:54,450
parts of the network and then we want

00:16:50,760 --> 00:16:56,010
this this IP address to be announced

00:16:54,450 --> 00:16:59,010
into the network so that all of the

00:16:56,010 --> 00:17:01,380
routers see multiple paths to the same

00:16:59,010 --> 00:17:03,480
destination or what they believe is the

00:17:01,380 --> 00:17:05,610
same destination but in reality it's

00:17:03,480 --> 00:17:06,839
multiple containers so that's that's

00:17:05,610 --> 00:17:09,120
what we're trying to achieve with this

00:17:06,839 --> 00:17:11,570
so the question is how do we do this

00:17:09,120 --> 00:17:16,320
and so that's sort of the heart of this

00:17:11,570 --> 00:17:20,040
so we have this idea of plugins with

00:17:16,320 --> 00:17:22,200
both docker and with mezzo so if you're

00:17:20,040 --> 00:17:23,730
not using the docker plug-in or sorry if

00:17:22,200 --> 00:17:25,890
you're not using a docker container Iser

00:17:23,730 --> 00:17:27,600
if you're instead using de meses

00:17:25,890 --> 00:17:31,020
Universal container Iser

00:17:27,600 --> 00:17:31,850
this works in a very similar way and so

00:17:31,020 --> 00:17:33,440
on

00:17:31,850 --> 00:17:35,330
on a debt on a mezzo store DC US

00:17:33,440 --> 00:17:36,950
platform you have your choice or two

00:17:35,330 --> 00:17:39,500
different container eyes errs in both of

00:17:36,950 --> 00:17:41,840
these cases you can write plug-ins for

00:17:39,500 --> 00:17:44,150
this container Iser to customize the

00:17:41,840 --> 00:17:46,370
functionality that you want and they

00:17:44,150 --> 00:17:49,340
work a little bit differently but the

00:17:46,370 --> 00:17:52,010
end result is the same sort it so in

00:17:49,340 --> 00:17:53,330
that in the docker scheme they they have

00:17:52,010 --> 00:17:55,970
what's called the container network

00:17:53,330 --> 00:17:58,160
model and this is basically farmed out

00:17:55,970 --> 00:18:02,600
to a thing called Lib network and so in

00:17:58,160 --> 00:18:05,690
this case you have a plug-in driver that

00:18:02,600 --> 00:18:09,380
runs in a container on the host and its

00:18:05,690 --> 00:18:13,059
job is to listen to API calls from

00:18:09,380 --> 00:18:16,580
docker to do things and these things are

00:18:13,059 --> 00:18:18,409
you know I need an address i I want you

00:18:16,580 --> 00:18:20,780
to create a new network you know I have

00:18:18,409 --> 00:18:22,850
you know I want you to release the

00:18:20,780 --> 00:18:25,750
address so docker makes these various

00:18:22,850 --> 00:18:29,990
calls and you're the custom plug-in

00:18:25,750 --> 00:18:32,720
actually does the work to do this and so

00:18:29,990 --> 00:18:35,780
this this container this docker plugin

00:18:32,720 --> 00:18:36,770
is just an HTTP service it's no more

00:18:35,780 --> 00:18:39,890
complicated than that

00:18:36,770 --> 00:18:42,320
so you your plug-in is an HTTP service

00:18:39,890 --> 00:18:45,110
it runs as a container on the docker

00:18:42,320 --> 00:18:47,690
host and docker talks to it over HTTP

00:18:45,110 --> 00:18:49,820
now generally this is via a UNIX socket

00:18:47,690 --> 00:18:51,350
and not a network socket because you

00:18:49,820 --> 00:18:55,730
don't generally want to make this

00:18:51,350 --> 00:18:57,620
available to the entire network and in

00:18:55,730 --> 00:19:02,179
the container network interface which is

00:18:57,620 --> 00:19:03,470
sort of like kubernetes and the gives me

00:19:02,179 --> 00:19:05,840
the universal container Iser

00:19:03,470 --> 00:19:08,330
that's what this uses and it's it's a

00:19:05,840 --> 00:19:09,710
similar scheme except it doesn't run as

00:19:08,330 --> 00:19:12,860
an HTTP service

00:19:09,710 --> 00:19:15,260
it's an executable and so the container

00:19:12,860 --> 00:19:18,470
Iser in this case just execs the

00:19:15,260 --> 00:19:21,830
executable and passes it arguments both

00:19:18,470 --> 00:19:23,480
via standard in and with environment

00:19:21,830 --> 00:19:25,700
variables but it's the same sort of

00:19:23,480 --> 00:19:27,980
thing it makes requests of the plug-in

00:19:25,700 --> 00:19:29,539
and says hey I have a thing I want you

00:19:27,980 --> 00:19:33,020
to create me a network I want you to

00:19:29,539 --> 00:19:35,299
assign an IP address etc the other

00:19:33,020 --> 00:19:37,039
difference here is there's really two

00:19:35,299 --> 00:19:39,490
parts to this there's the network driver

00:19:37,039 --> 00:19:41,620
and there's the IP and drive

00:19:39,490 --> 00:19:44,950
and I'm gonna gloss over the IPM driver

00:19:41,620 --> 00:19:47,470
but this is what actually allocates the

00:19:44,950 --> 00:19:48,100
network or allocates the IP address and

00:19:47,470 --> 00:19:50,080
so forth

00:19:48,100 --> 00:19:52,299
it's sort of assumed if you have a

00:19:50,080 --> 00:19:54,279
custom IPAN driver that you have a

00:19:52,299 --> 00:19:56,559
larger IPM implementation in your

00:19:54,279 --> 00:19:59,230
organization typically organizations

00:19:56,559 --> 00:20:00,640
like to centralize IP management for

00:19:59,230 --> 00:20:03,130
obvious reasons so like if you're gonna

00:20:00,640 --> 00:20:05,289
do the IPAN driver that's you kind of

00:20:03,130 --> 00:20:07,870
that's how you get it plugged in to the

00:20:05,289 --> 00:20:09,820
rest of your organization for these

00:20:07,870 --> 00:20:11,110
purposes I'm going to assume that when

00:20:09,820 --> 00:20:12,789
you spin up a container you're just

00:20:11,110 --> 00:20:15,190
gonna tell it what IP address you want

00:20:12,789 --> 00:20:17,380
it to use and so it sort of bypasses the

00:20:15,190 --> 00:20:18,850
IP and driver but you need to know that

00:20:17,380 --> 00:20:21,240
both of these plugins deal with that a

00:20:18,850 --> 00:20:23,799
little differently the docker plugin

00:20:21,240 --> 00:20:25,690
there's there's two separate drivers

00:20:23,799 --> 00:20:29,470
there's the network driver and the IPAM

00:20:25,690 --> 00:20:31,480
driver with C&I there's only the the

00:20:29,470 --> 00:20:34,059
container Iser only talks to the network

00:20:31,480 --> 00:20:36,279
part and the network part is expected to

00:20:34,059 --> 00:20:39,309
talk to the IPM driver on behalf of

00:20:36,279 --> 00:20:41,080
docker but the functionality is the same

00:20:39,309 --> 00:20:44,919
it's just it works a little different in

00:20:41,080 --> 00:20:47,440
how the calls are made so ultimately

00:20:44,919 --> 00:20:49,330
what what we want to do is we want to

00:20:47,440 --> 00:20:51,700
you know have a routed network so this

00:20:49,330 --> 00:20:54,130
is where we start so usually the plugin

00:20:51,700 --> 00:20:56,500
is given a container and the container

00:20:54,130 --> 00:20:58,330
is just a bare-bones implementation of

00:20:56,500 --> 00:21:00,429
you know some sort of running process

00:20:58,330 --> 00:21:02,500
and it has its own namespace so what I'm

00:21:00,429 --> 00:21:04,419
trying to show you here is the dark blue

00:21:02,500 --> 00:21:06,159
is the namespace on the host the light

00:21:04,419 --> 00:21:08,110
blue is a namespace in the container and

00:21:06,159 --> 00:21:11,890
so the steps that you generally follow

00:21:08,110 --> 00:21:14,169
are you take this and you make a virtual

00:21:11,890 --> 00:21:16,120
Ethernet pair and again this is what

00:21:14,169 --> 00:21:17,649
we're doing in the driver so the first

00:21:16,120 --> 00:21:19,990
step in the driver is you create the

00:21:17,649 --> 00:21:21,190
virtual Ethernet pair and one end is

00:21:19,990 --> 00:21:23,679
going to go in the container the other

00:21:21,190 --> 00:21:26,140
end is going to go on the host you

00:21:23,679 --> 00:21:28,559
assign a dummy MAC address pair to

00:21:26,140 --> 00:21:31,960
assign to the the virtual Ethernet pair

00:21:28,559 --> 00:21:34,779
and you take the IP address and you

00:21:31,960 --> 00:21:38,289
assign the IP address to the interface

00:21:34,779 --> 00:21:40,090
in this case we're using the 169 254 on

00:21:38,289 --> 00:21:42,580
the host side this is a link local

00:21:40,090 --> 00:21:46,059
address and it sort of gives us a way to

00:21:42,580 --> 00:21:47,830
route to basically do a route to an

00:21:46,059 --> 00:21:49,020
interface and I'll cover that in a

00:21:47,830 --> 00:21:51,270
minute but

00:21:49,020 --> 00:21:55,380
the host the host side of this is always

00:21:51,270 --> 00:21:59,490
going to be that exact same address and

00:21:55,380 --> 00:22:03,330
then what we do is we make routes on

00:21:59,490 --> 00:22:05,790
both of these so in the host side we

00:22:03,330 --> 00:22:07,530
take the host R out of the container and

00:22:05,790 --> 00:22:09,870
we add that to the routing table so that

00:22:07,530 --> 00:22:13,020
the host now knows how to route to the

00:22:09,870 --> 00:22:15,929
Container side in the container we need

00:22:13,020 --> 00:22:17,730
two routes we need a route that's a it's

00:22:15,929 --> 00:22:20,309
an interface route and we take the link

00:22:17,730 --> 00:22:22,650
local and we say okay this link local

00:22:20,309 --> 00:22:25,230
address can be reached by putting it on

00:22:22,650 --> 00:22:26,760
this link and then we make a second

00:22:25,230 --> 00:22:28,830
route that's a default route and we

00:22:26,760 --> 00:22:31,320
point it at the link local address and

00:22:28,830 --> 00:22:35,070
this gets us out of the container and so

00:22:31,320 --> 00:22:36,870
this allows us to route out in order for

00:22:35,070 --> 00:22:40,290
this scheme to work you have to have

00:22:36,870 --> 00:22:42,240
proxy ARP enabled and on the host for at

00:22:40,290 --> 00:22:44,309
least the interfaces that are coming up

00:22:42,240 --> 00:22:48,600
and it's not usually an issue to do that

00:22:44,309 --> 00:22:50,340
but you do have to enable that and so at

00:22:48,600 --> 00:22:52,590
the end of all this this is what we have

00:22:50,340 --> 00:22:55,040
we have containers that are coming up

00:22:52,590 --> 00:22:58,200
with each container having an IP address

00:22:55,040 --> 00:23:00,840
the route to the container is contained

00:22:58,200 --> 00:23:03,240
in the hosts routing table you run a BGP

00:23:00,840 --> 00:23:05,970
daemon on the host that redistributes

00:23:03,240 --> 00:23:06,510
these addresses out to the rest of the

00:23:05,970 --> 00:23:08,100
network

00:23:06,510 --> 00:23:10,620
and so what I'm showing you here is

00:23:08,100 --> 00:23:13,800
these 192 addresses these are the

00:23:10,620 --> 00:23:15,840
addresses that your host is is numbered

00:23:13,800 --> 00:23:17,760
in so these are the this is the address

00:23:15,840 --> 00:23:19,679
face in your rack that you would have so

00:23:17,760 --> 00:23:22,590
each host is gonna get like a 192

00:23:19,679 --> 00:23:23,970
address but inside the host the

00:23:22,590 --> 00:23:25,830
individual containers are gonna have a

00:23:23,970 --> 00:23:28,200
different IP address and it's going to

00:23:25,830 --> 00:23:30,480
be a host route and that the way that

00:23:28,200 --> 00:23:32,010
you tell the rest of the network that to

00:23:30,480 --> 00:23:34,380
route to your containers is you have to

00:23:32,010 --> 00:23:35,970
have the BGP paired with the rest of

00:23:34,380 --> 00:23:38,610
your network to tell it that you have

00:23:35,970 --> 00:23:43,620
these routes so if you have this scheme

00:23:38,610 --> 00:23:45,840
it will all just sort of work so sort of

00:23:43,620 --> 00:23:48,059
the use cases for this so why why would

00:23:45,840 --> 00:23:49,559
you ever want to do this there's a

00:23:48,059 --> 00:23:53,190
couple reasons why you would want to do

00:23:49,559 --> 00:23:54,900
this one of the reasons is for like UDP

00:23:53,190 --> 00:23:56,760
endpoints so like if you're running a

00:23:54,900 --> 00:23:58,679
syslog service if you know if you want

00:23:56,760 --> 00:24:01,280
to be able to you know just send your

00:23:58,679 --> 00:24:04,860
logs to somewhere and you don't really

00:24:01,280 --> 00:24:06,540
you know if you have a few syslog

00:24:04,860 --> 00:24:08,460
services scattered around your network

00:24:06,540 --> 00:24:10,470
or whatever or if you have multiple data

00:24:08,460 --> 00:24:12,300
centers you might run a logging service

00:24:10,470 --> 00:24:14,820
in each data center you would want to be

00:24:12,300 --> 00:24:17,040
able to give you know an IP address into

00:24:14,820 --> 00:24:19,110
your hosts to be able to log to this

00:24:17,040 --> 00:24:20,730
stuff and so what you would do is you

00:24:19,110 --> 00:24:23,210
would configure your log service within

00:24:20,730 --> 00:24:25,830
anycast address so that all of your log

00:24:23,210 --> 00:24:28,710
collectors would have the exact same IP

00:24:25,830 --> 00:24:31,770
address and your host will use whichever

00:24:28,710 --> 00:24:34,050
one is topologically closer so that if

00:24:31,770 --> 00:24:35,730
you're in a data center let's say your

00:24:34,050 --> 00:24:38,220
host would tend to use the log

00:24:35,730 --> 00:24:40,740
aggregator that's in your in that same

00:24:38,220 --> 00:24:42,809
data center but if somehow you lose that

00:24:40,740 --> 00:24:44,490
one you'll still hear the routes from

00:24:42,809 --> 00:24:48,450
the other data centers and so it'll go

00:24:44,490 --> 00:24:50,580
to those instead it also works for

00:24:48,450 --> 00:24:54,210
things like you know like I mentioned

00:24:50,580 --> 00:24:56,790
DNS will do this for like it works

00:24:54,210 --> 00:24:59,429
really well for sFlow for net flow which

00:24:56,790 --> 00:25:02,070
are all UDP based services but you can

00:24:59,429 --> 00:25:04,830
also use it for TCP services there's not

00:25:02,070 --> 00:25:06,780
a restriction here so what you can do

00:25:04,830 --> 00:25:11,970
which is kind of interesting is you can

00:25:06,780 --> 00:25:13,530
deploy a che proxy and so the what you

00:25:11,970 --> 00:25:15,720
can sort of do is you can you can deploy

00:25:13,530 --> 00:25:17,790
your service like if you have a web

00:25:15,720 --> 00:25:20,910
service or whatever what you do is you

00:25:17,790 --> 00:25:24,059
deploy that and you use on minuteman if

00:25:20,910 --> 00:25:26,220
you're using DCOs to give it an IP

00:25:24,059 --> 00:25:28,740
address that's normally only reachable

00:25:26,220 --> 00:25:30,419
inside your cluster so that minuteman

00:25:28,740 --> 00:25:33,179
assigns you know some sort of dummy

00:25:30,419 --> 00:25:35,160
address and you get a host based VIP for

00:25:33,179 --> 00:25:37,770
your service so that you can run you

00:25:35,160 --> 00:25:40,470
know three copies of your of your HTTP

00:25:37,770 --> 00:25:42,870
service and you could put those behind a

00:25:40,470 --> 00:25:44,730
minuteman fit and if long as you're in

00:25:42,870 --> 00:25:46,410
the cluster that totally works great but

00:25:44,730 --> 00:25:47,970
then the problem comes from like what if

00:25:46,410 --> 00:25:51,900
you're outside the cluster and so the

00:25:47,970 --> 00:25:54,240
usual solution for this is marathon LBE

00:25:51,900 --> 00:25:57,840
or something similar where you run like

00:25:54,240 --> 00:25:59,820
an H a proxy so that relies on this sort

00:25:57,840 --> 00:26:01,800
of kooky scheme where you're like having

00:25:59,820 --> 00:26:03,960
to reload H a proxy like every time

00:26:01,800 --> 00:26:05,300
something changes and you know H a proxy

00:26:03,960 --> 00:26:07,280
was never designed to do

00:26:05,300 --> 00:26:09,830
and they've gotten better about it but I

00:26:07,280 --> 00:26:13,070
I still am kind of wary of doing stuff

00:26:09,830 --> 00:26:16,660
like that so a better case I think is to

00:26:13,070 --> 00:26:19,370
just deploy an H a proxy container and

00:26:16,660 --> 00:26:22,310
assign the front-end like you know your

00:26:19,370 --> 00:26:24,980
server side of the H a proxy and anycast

00:26:22,310 --> 00:26:28,280
address and the back side becomes that

00:26:24,980 --> 00:26:30,680
damed minuteman VIP and it's static and

00:26:28,280 --> 00:26:32,840
that config never needs to change and so

00:26:30,680 --> 00:26:35,480
you deploy you know three copies of this

00:26:32,840 --> 00:26:38,900
with any casts and it gets deployed and

00:26:35,480 --> 00:26:41,570
so your your H a proxy becomes globally

00:26:38,900 --> 00:26:43,460
reachable from anywhere and if your

00:26:41,570 --> 00:26:46,550
containers move around minutemen will

00:26:43,460 --> 00:26:48,920
take care of you know updating the you

00:26:46,550 --> 00:26:50,720
know the actual container instances but

00:26:48,920 --> 00:26:54,350
the H a proxy instance never needs to

00:26:50,720 --> 00:26:56,510
change you could do this with like if

00:26:54,350 --> 00:26:58,520
you're running you know traffic or you

00:26:56,510 --> 00:27:00,230
know any kind of load balancer that

00:26:58,520 --> 00:27:03,740
follows that kind of pattern you can

00:27:00,230 --> 00:27:06,680
deploy with any cast now the caveat to

00:27:03,740 --> 00:27:09,770
this comes from what happens when you

00:27:06,680 --> 00:27:13,040
lose you know when you lose one of those

00:27:09,770 --> 00:27:16,760
equal cost multi path routes because the

00:27:13,040 --> 00:27:18,770
routers do have to rebalance those flows

00:27:16,760 --> 00:27:21,230
that you lose when you lose one of these

00:27:18,770 --> 00:27:24,770
routes and that causes the connections

00:27:21,230 --> 00:27:27,440
to be reset for just just the flows that

00:27:24,770 --> 00:27:30,020
were using that one route the other

00:27:27,440 --> 00:27:32,870
thing is that if you deploy H a proxy

00:27:30,020 --> 00:27:35,060
using an IP anycast address you lose the

00:27:32,870 --> 00:27:38,030
ability to gracefully take your H a

00:27:35,060 --> 00:27:39,650
proxy instances out for maintenance so

00:27:38,030 --> 00:27:41,720
if you wanted to do something like this

00:27:39,650 --> 00:27:44,300
you would have to take the H a proxy

00:27:41,720 --> 00:27:45,920
instance down and it would reset all of

00:27:44,300 --> 00:27:48,380
the connections that are on there and

00:27:45,920 --> 00:27:51,170
they would be forced to use to reconnect

00:27:48,380 --> 00:27:52,490
to another H a proxy instance so as long

00:27:51,170 --> 00:27:54,500
as you've got applications that are

00:27:52,490 --> 00:27:56,930
willing to tolerate that it works well

00:27:54,500 --> 00:27:59,210
if you've got stuff that won't tolerate

00:27:56,930 --> 00:28:01,820
that or you've got or you know you're

00:27:59,210 --> 00:28:03,920
sending like large files or something

00:28:01,820 --> 00:28:05,840
via post or something like that where to

00:28:03,920 --> 00:28:08,030
reset these connections is problematic

00:28:05,840 --> 00:28:09,340
you don't want to do this because you'll

00:28:08,030 --> 00:28:12,550
run into issues

00:28:09,340 --> 00:28:16,130
so that's that's the sort of high-level

00:28:12,550 --> 00:28:21,290
I glossed over a lot of the details but

00:28:16,130 --> 00:28:23,570
what I wanted to show you I guess I'm

00:28:21,290 --> 00:28:26,570
not gonna be able to do that so there's

00:28:23,570 --> 00:28:30,500
a I'll put on this slide deck when I

00:28:26,570 --> 00:28:33,860
upload it there's there's a repo from

00:28:30,500 --> 00:28:36,920
Medallia on github that actually does

00:28:33,860 --> 00:28:39,080
the docker plugin that will enable the

00:28:36,920 --> 00:28:41,990
routed plugin and it works out of the

00:28:39,080 --> 00:28:44,240
box you can just deploy it and as long

00:28:41,990 --> 00:28:44,840
as you use that as your docker network

00:28:44,240 --> 00:28:47,870
driver

00:28:44,840 --> 00:28:50,000
it'll divvy out these on these host

00:28:47,870 --> 00:28:51,470
routes so if you have a setup like this

00:28:50,000 --> 00:28:54,440
in your data center where you're running

00:28:51,470 --> 00:28:57,140
BGP or something else and if you're set

00:28:54,440 --> 00:28:58,850
up to where you can take your hosts and

00:28:57,140 --> 00:29:01,190
peer it with the rest of your network

00:28:58,850 --> 00:29:04,460
it's really easy to do this you just

00:29:01,190 --> 00:29:07,160
need to run a plug-in in the plug-in

00:29:04,460 --> 00:29:09,080
that's called C C in M routed plug-in

00:29:07,160 --> 00:29:10,970
and you would just run this on your host

00:29:09,080 --> 00:29:13,520
and you would divvy out these host

00:29:10,970 --> 00:29:15,200
routes and suddenly your containers

00:29:13,520 --> 00:29:16,820
would be reachable from everywhere in

00:29:15,200 --> 00:29:18,380
the network and you you wouldn't

00:29:16,820 --> 00:29:20,330
necessarily even have to use any casts

00:29:18,380 --> 00:29:22,610
like I mentioned if you have like an IP

00:29:20,330 --> 00:29:24,830
per container scheme you could do this

00:29:22,610 --> 00:29:26,660
also and so it would make your IP

00:29:24,830 --> 00:29:30,200
addresses for your container reachable

00:29:26,660 --> 00:29:33,320
everywhere also so that's kind of the

00:29:30,200 --> 00:29:34,820
gist of the talk I wanted to to open it

00:29:33,320 --> 00:29:38,080
up for questions because I realized I

00:29:34,820 --> 00:29:38,080
sort of went through this fast

00:29:44,970 --> 00:29:48,180
that's right

00:30:05,960 --> 00:30:10,980
so if in other word like if you've got

00:30:08,970 --> 00:30:16,110
four of the same IP address in one rack

00:30:10,980 --> 00:30:18,150
and one over here since the hosts are

00:30:16,110 --> 00:30:20,580
doing the announcement the the top of

00:30:18,150 --> 00:30:22,950
rack would get all four of those host

00:30:20,580 --> 00:30:24,180
routes and it would announce those so

00:30:22,950 --> 00:30:26,250
everywhere in the network you're just

00:30:24,180 --> 00:30:28,530
gonna see five routes four of them

00:30:26,250 --> 00:30:33,030
happen to go to the top of rack are you

00:30:28,530 --> 00:30:34,650
thinking about aggregation so if they're

00:30:33,030 --> 00:30:37,880
on the same host in the rack that's

00:30:34,650 --> 00:30:37,880
probably not going to work because

00:30:44,179 --> 00:30:49,700
it will if you tell it to so that that's

00:30:46,999 --> 00:30:51,919
a thing like normally normally with a

00:30:49,700 --> 00:30:53,539
with a sort of garden-variety networking

00:30:51,919 --> 00:30:55,549
you want to aggregate that stuff right

00:30:53,539 --> 00:30:58,009
you don't want all these little really

00:30:55,549 --> 00:30:59,629
specific routes leaked out everywhere

00:30:58,009 --> 00:31:02,240
because you end up with these gigantic

00:30:59,629 --> 00:31:03,649
routing tables so typically you would

00:31:02,240 --> 00:31:07,009
have something on the on the router

00:31:03,649 --> 00:31:08,570
that's like you know aggregate supernet

00:31:07,009 --> 00:31:11,210
or something like that where the router

00:31:08,570 --> 00:31:12,919
will automatically take these more

00:31:11,210 --> 00:31:15,499
specific routes and aggregate them

00:31:12,919 --> 00:31:17,179
behind a single add aggregation and as

00:31:15,499 --> 00:31:19,850
long as one or more of these more

00:31:17,179 --> 00:31:23,539
specifics are reachable this route it

00:31:19,850 --> 00:31:25,240
stays announced and you don't have to do

00:31:23,539 --> 00:31:27,860
that you can you can specifically say

00:31:25,240 --> 00:31:29,779
hey if you've got anything in this net

00:31:27,860 --> 00:31:32,950
block just go ahead and announce the the

00:31:29,779 --> 00:31:32,950
32s into the network

00:31:52,000 --> 00:31:55,730
yeah

00:31:53,150 --> 00:31:57,620
so so the question was like if you if

00:31:55,730 --> 00:31:59,480
you're using it generally like IP per

00:31:57,620 --> 00:32:01,340
container and you're announcing all

00:31:59,480 --> 00:32:05,240
these slash thirty twos like what's the

00:32:01,340 --> 00:32:08,210
limit to that you don't want to have

00:32:05,240 --> 00:32:10,910
like sixty thousand containers in a data

00:32:08,210 --> 00:32:13,100
center all announcing these host routes

00:32:10,910 --> 00:32:15,350
into your network it sort of understood

00:32:13,100 --> 00:32:17,240
that you're gonna have you know a small

00:32:15,350 --> 00:32:20,150
little bit smaller implementation than

00:32:17,240 --> 00:32:22,550
that but generally speaking you're gonna

00:32:20,150 --> 00:32:24,650
run out of IP addresses before you run

00:32:22,550 --> 00:32:26,330
out of you know this kind of thing I

00:32:24,650 --> 00:32:28,970
don't even if you're using private

00:32:26,330 --> 00:32:32,420
addresses if you have these just math

00:32:28,970 --> 00:32:34,340
like if you're Facebook you're gonna you

00:32:32,420 --> 00:32:35,930
know doing IP per container is gonna be

00:32:34,340 --> 00:32:38,420
very very difficult because even if

00:32:35,930 --> 00:32:40,160
you're using private addresses it's

00:32:38,420 --> 00:32:42,800
going to get very difficult to divvy

00:32:40,160 --> 00:32:47,590
that stuff out one more question

00:32:42,800 --> 00:32:47,590
may be good

00:33:03,509 --> 00:33:08,110
in the implementation I showed you yes

00:33:06,070 --> 00:33:11,440
now you could always get around that by

00:33:08,110 --> 00:33:13,779
you know I don't know you could probably

00:33:11,440 --> 00:33:15,249
use netfilter trickery to get around

00:33:13,779 --> 00:33:16,509
that but generally generally like the

00:33:15,249 --> 00:33:18,730
colonel is going to make that decision

00:33:16,509 --> 00:33:21,039
so if the colonel has that route and its

00:33:18,730 --> 00:33:23,200
local yeah it'll use whatever local

00:33:21,039 --> 00:33:26,289
thing I don't know of an instance where

00:33:23,200 --> 00:33:30,450
you want it to go out of the RAC can you

00:33:26,289 --> 00:33:30,450
think of a like what's the use case oh

00:33:32,369 --> 00:33:36,759
yeah yeah right so like if you have like

00:33:34,929 --> 00:33:39,190
a bunch of stuff in that rack that needs

00:33:36,759 --> 00:33:40,480
to talk to that one thing yeah you would

00:33:39,190 --> 00:33:42,249
have that issue you'd have to put

00:33:40,480 --> 00:33:45,129
multiple things in that rack to sort of

00:33:42,249 --> 00:33:46,899
share the load in that case it gets

00:33:45,129 --> 00:33:49,210
really hard to sort of granularly

00:33:46,899 --> 00:33:51,730
like do this kind of stuff with this

00:33:49,210 --> 00:33:53,409
game because it's not it's not really

00:33:51,730 --> 00:33:56,619
meant for load balancing in that sense

00:33:53,409 --> 00:33:59,679
it'll it'll like load share and not load

00:33:56,619 --> 00:34:03,690
balanced if if that's like a thing is

00:33:59,679 --> 00:34:03,690
there one more question like yeah

00:34:20,570 --> 00:34:26,580
so you it depends on how your eye pan is

00:34:23,790 --> 00:34:28,470
right so you can have your eye pan do

00:34:26,580 --> 00:34:30,660
your dns for you so if you wanted to you

00:34:28,470 --> 00:34:32,550
could name these things and so you would

00:34:30,660 --> 00:34:34,230
have an IP address with a name and so in

00:34:32,550 --> 00:34:36,810
your service you know and your configs

00:34:34,230 --> 00:34:37,890
you would inject the host name and so

00:34:36,810 --> 00:34:40,140
the host name would just you would use

00:34:37,890 --> 00:34:42,870
DNS is your service discovery or you can

00:34:40,140 --> 00:34:44,880
use MELAS DNS or console or whatever but

00:34:42,870 --> 00:34:46,679
but the I Pam that I sort of glossed

00:34:44,880 --> 00:34:49,470
over that's that's where all of that

00:34:46,679 --> 00:34:52,740
happens is like how do you get that into

00:34:49,470 --> 00:34:55,500
the larger discovery thing generally and

00:34:52,740 --> 00:34:57,150
we're out of time thank you very much

00:34:55,500 --> 00:34:59,210
for attending I know it was kind of a

00:34:57,150 --> 00:35:03,519
very dense talk but I hope

00:34:59,210 --> 00:35:03,519

YouTube URL: https://www.youtube.com/watch?v=_kRW8j2cMa0


