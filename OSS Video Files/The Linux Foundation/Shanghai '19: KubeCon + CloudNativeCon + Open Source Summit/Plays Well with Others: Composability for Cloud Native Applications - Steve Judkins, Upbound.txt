Title: Plays Well with Others: Composability for Cloud Native Applications - Steve Judkins, Upbound
Publication date: 2019-07-10
Playlist: Shanghai '19: KubeCon + CloudNativeCon + Open Source Summit
Description: 
	Plays Well with Others: Composability for Cloud Native Applications - Steve Judkins, Upbound 

Writing cloud native applications today involves custom code to stitch everything together across microservices, open-source frameworks, and managed services. In this talk, we look beyond Kubernetesâ€™ usage for container orchestration and extend the Kubernetes API to the management of external resources (not running on pods or nodes). Imagine if an application developer writing a monitoring framework could ask for a SQL database and message queue for their application in the same way that the Kubernetes API enables them to ask for an abstract PersistentVolumeClaim backed by a concrete PersistentVolume implementation. We can imagine that this developer might also expose the monitoring framework as a resource for consumption by other applications. In this talk we explore the use of this new approach to facilitate composability and reuse of resources within heterogeneous applications. 

https://sched.co/Nrlf
Captions: 
	00:00:00,000 --> 00:00:05,659
hey welcome guess the evening crowd

00:00:05,720 --> 00:00:10,110
tonight I'm going to be talking a bit

00:00:07,560 --> 00:00:14,730
about composability for cloud native

00:00:10,110 --> 00:00:17,880
applications and theme of the talk plays

00:00:14,730 --> 00:00:20,820
well with others when I was growing up

00:00:17,880 --> 00:00:23,550
in school children were graded young

00:00:20,820 --> 00:00:24,869
children were graded on how well they

00:00:23,550 --> 00:00:29,250
played with other kids in the school

00:00:24,869 --> 00:00:30,840
yard and we want to make sure that when

00:00:29,250 --> 00:00:32,880
they grow up they're capable of working

00:00:30,840 --> 00:00:36,719
well with others and in different

00:00:32,880 --> 00:00:38,430
environments so we think we've seen a

00:00:36,719 --> 00:00:42,180
lot of learn lessons learned from the

00:00:38,430 --> 00:00:44,460
open source kubernetes project on how to

00:00:42,180 --> 00:00:47,820
build cloud native applications that

00:00:44,460 --> 00:00:51,239
work well with others and have greater

00:00:47,820 --> 00:00:54,690
composability and reuse so as it matures

00:00:51,239 --> 00:00:56,910
we hope to see more of that and that's

00:00:54,690 --> 00:00:59,100
what I'm going to be talking about I'm

00:00:56,910 --> 00:01:03,750
Steve Jenkins and I'm a program manager

00:00:59,100 --> 00:01:07,920
at upbound in Seattle and we love

00:01:03,750 --> 00:01:09,689
kubernetes you all probably are aware of

00:01:07,920 --> 00:01:12,630
and love kubernetes as well or you

00:01:09,689 --> 00:01:15,810
wouldn't be here so I'll be talking a

00:01:12,630 --> 00:01:18,170
bit about the benefits of container

00:01:15,810 --> 00:01:21,450
orchestration for scaling your own

00:01:18,170 --> 00:01:24,750
software deployments but that's not all

00:01:21,450 --> 00:01:26,640
that kubernetes brings to the table it

00:01:24,750 --> 00:01:31,500
also makes it easy to use

00:01:26,640 --> 00:01:33,960
declarative management API and these

00:01:31,500 --> 00:01:35,670
active state controllers can reconcile

00:01:33,960 --> 00:01:39,119
the actual state of your application

00:01:35,670 --> 00:01:43,520
with the desired state so this has shown

00:01:39,119 --> 00:01:46,680
how great it can be for complex apps and

00:01:43,520 --> 00:01:49,320
but there's even more there's it's

00:01:46,680 --> 00:01:53,180
extensible kubernetes lets us define

00:01:49,320 --> 00:01:55,259
custom resource definitions and

00:01:53,180 --> 00:01:58,409
implementing controllers is for the

00:01:55,259 --> 00:01:59,729
right way to extend kubernetes so we can

00:01:58,409 --> 00:02:03,950
manage more things within our

00:01:59,729 --> 00:02:06,500
infrastructure than we have been

00:02:03,950 --> 00:02:09,050
so if we took a look at like the modern

00:02:06,500 --> 00:02:12,170
cloud application you're probably

00:02:09,050 --> 00:02:14,420
leveraging kubernetes in your apps it

00:02:12,170 --> 00:02:17,480
just makes sense to deploy our apps to

00:02:14,420 --> 00:02:19,670
containers like many companies you've

00:02:17,480 --> 00:02:21,920
probably built these apps you've

00:02:19,670 --> 00:02:25,220
deployed them to a cluster it's just

00:02:21,920 --> 00:02:27,280
like the big container ship here when we

00:02:25,220 --> 00:02:29,270
talk about deploying with kubernetes

00:02:27,280 --> 00:02:32,150
those are running in your own cluster

00:02:29,270 --> 00:02:35,209
and you have responsibility for managing

00:02:32,150 --> 00:02:37,640
that cluster so most of us want to take

00:02:35,209 --> 00:02:39,920
advantage of cloud platforms and the

00:02:37,640 --> 00:02:41,450
cloud providers have built these big

00:02:39,920 --> 00:02:44,030
beautiful cities with lots of

00:02:41,450 --> 00:02:48,830
infrastructure they have an SLA they can

00:02:44,030 --> 00:02:52,040
give you and so in order to take

00:02:48,830 --> 00:02:56,360
advantage of that you know to manage

00:02:52,040 --> 00:02:58,900
databases we can then have scaleable

00:02:56,360 --> 00:03:02,900
databases that manage backups

00:02:58,900 --> 00:03:05,120
replication disaster recovery there's

00:03:02,900 --> 00:03:07,069
just a lot of features there that we

00:03:05,120 --> 00:03:11,600
don't have to manage when we're

00:03:07,069 --> 00:03:13,340
deploying to our own cluster so you know

00:03:11,600 --> 00:03:15,799
and of course public cloud providers

00:03:13,340 --> 00:03:18,590
have been rolling out new features

00:03:15,799 --> 00:03:20,750
advanced features at an amazing rate so

00:03:18,590 --> 00:03:24,620
if you want to take advantage of those

00:03:20,750 --> 00:03:28,190
differentiated services like search AI

00:03:24,620 --> 00:03:32,570
and it's kind of a pain to manage those

00:03:28,190 --> 00:03:34,370
in your own cluster so kind of what's

00:03:32,570 --> 00:03:36,440
wrong with the picture modern

00:03:34,370 --> 00:03:38,269
applications are basically composed more

00:03:36,440 --> 00:03:40,820
than just the services that we're

00:03:38,269 --> 00:03:44,959
writing and maintaining you're gonna

00:03:40,820 --> 00:03:47,450
have dependencies on databases object

00:03:44,959 --> 00:03:49,579
storage buckets pub/sub search

00:03:47,450 --> 00:03:52,220
monitoring sort of the typical

00:03:49,579 --> 00:03:53,780
application components but do you really

00:03:52,220 --> 00:03:57,170
want these all running in your cluster

00:03:53,780 --> 00:04:01,940
do you want to be paged at midnight I

00:03:57,170 --> 00:04:04,400
don't so the other aspect of this is

00:04:01,940 --> 00:04:06,170
that your IT and DevOps groups are

00:04:04,400 --> 00:04:09,190
typically running a completely different

00:04:06,170 --> 00:04:12,769
set of tools for orchestrating or

00:04:09,190 --> 00:04:14,480
provisioning infrastructure so that has

00:04:12,769 --> 00:04:16,370
kind of become this dumpster fire of

00:04:14,480 --> 00:04:18,199
tools that

00:04:16,370 --> 00:04:25,460
don't align with all the great

00:04:18,199 --> 00:04:29,570
kubernetes work that's been going on so

00:04:25,460 --> 00:04:31,070
can we solve this in an elegant way if

00:04:29,570 --> 00:04:33,500
we take a moment to look at the

00:04:31,070 --> 00:04:35,720
different approaches to infrastructure

00:04:33,500 --> 00:04:38,389
orchestration that are out in the wild

00:04:35,720 --> 00:04:40,600
we'll see some patterns so I kind of

00:04:38,389 --> 00:04:44,960
find it useful to categorize these

00:04:40,600 --> 00:04:48,290
components in in this way so along the

00:04:44,960 --> 00:04:50,560
vertical axis you have your services and

00:04:48,290 --> 00:04:52,810
those running in your kubernetes cluster

00:04:50,560 --> 00:04:56,479
which you might have deployed with helm

00:04:52,810 --> 00:04:59,870
you might have basic cloud provider

00:04:56,479 --> 00:05:03,380
services that you're taking advantage of

00:04:59,870 --> 00:05:05,300
and if you need something like cloud

00:05:03,380 --> 00:05:08,240
formation that can cover the gamut of

00:05:05,300 --> 00:05:12,820
AWS but doesn't extend to other cloud

00:05:08,240 --> 00:05:15,350
providers at the top of that axis is

00:05:12,820 --> 00:05:18,520
utilizing different differentiated

00:05:15,350 --> 00:05:21,440
clouds provider services across multiple

00:05:18,520 --> 00:05:24,560
cloud providers and something like

00:05:21,440 --> 00:05:27,250
terraform you know HCl allows you to

00:05:24,560 --> 00:05:31,190
basically do that kind of thing for

00:05:27,250 --> 00:05:34,010
installation and some upgrade cycles on

00:05:31,190 --> 00:05:37,160
this axis you have write the whole

00:05:34,010 --> 00:05:39,320
resource lifecycle management and many

00:05:37,160 --> 00:05:41,630
of these tools like ansible and chef and

00:05:39,320 --> 00:05:44,180
puppet have gotten you closer to the

00:05:41,630 --> 00:05:46,729
install and upgrade path but when we

00:05:44,180 --> 00:05:48,590
look at core LS you know who introduced

00:05:46,729 --> 00:05:51,740
the operator framework we see what it

00:05:48,590 --> 00:05:53,860
means to have the entire lifecycle

00:05:51,740 --> 00:05:56,479
manage within an active state controller

00:05:53,860 --> 00:05:58,430
and there been some you know projects

00:05:56,479 --> 00:06:00,710
like AWS service operators that have

00:05:58,430 --> 00:06:04,160
taken that into different cloud

00:06:00,710 --> 00:06:08,080
providers but nothing has really reached

00:06:04,160 --> 00:06:10,849
that target of having all of the complex

00:06:08,080 --> 00:06:13,490
managed services available in cloud

00:06:10,849 --> 00:06:15,440
providers across all the cloud providers

00:06:13,490 --> 00:06:17,979
or managed services and for the entire

00:06:15,440 --> 00:06:17,979
lifecycle

00:06:18,759 --> 00:06:23,559
so how could we solve this in an elegant

00:06:21,339 --> 00:06:27,279
way if it were based on the communities

00:06:23,559 --> 00:06:30,039
engine and it brings those cloud

00:06:27,279 --> 00:06:34,150
provider services and infrastructure

00:06:30,039 --> 00:06:37,599
into kubernetes gives you one API to

00:06:34,150 --> 00:06:39,789
manage everything and provides

00:06:37,599 --> 00:06:43,360
portability for those workloads that you

00:06:39,789 --> 00:06:47,860
have beyond containers it'd be nice

00:06:43,360 --> 00:06:50,669
wouldn't it so if we look back from a

00:06:47,860 --> 00:06:53,259
moment the time feels right for this

00:06:50,669 --> 00:06:57,009
we're kind of an interesting moment in

00:06:53,259 --> 00:07:00,789
the evolution of cloud native the level

00:06:57,009 --> 00:07:03,879
of abstraction is increased over time if

00:07:00,789 --> 00:07:07,930
we go back to virtual machines you know

00:07:03,879 --> 00:07:11,050
OpenStack and AWS ec2 got us into infra

00:07:07,930 --> 00:07:15,580
as a service and gave us operability and

00:07:11,050 --> 00:07:18,909
resiliency and elasticity and when

00:07:15,580 --> 00:07:22,059
kubernetes came along with managed

00:07:18,909 --> 00:07:25,120
kubernetes and GE and es you know we

00:07:22,059 --> 00:07:30,310
have containers as a service so we're

00:07:25,120 --> 00:07:33,669
now getting into more modularity and you

00:07:30,310 --> 00:07:36,370
know with with modularity and we saw the

00:07:33,669 --> 00:07:39,939
evolution of lambdas and functions as a

00:07:36,370 --> 00:07:41,949
service but I think now we're at a state

00:07:39,939 --> 00:07:44,139
where we can start to get some of the

00:07:41,949 --> 00:07:47,259
benefits of Portability and modularity

00:07:44,139 --> 00:07:49,990
out of this we have all the pieces in

00:07:47,259 --> 00:07:51,759
place within kubernetes to start billing

00:07:49,990 --> 00:07:55,419
what what I think of as portable

00:07:51,759 --> 00:07:58,930
resources and in a workload central

00:07:55,419 --> 00:08:02,229
centric model those portable resources

00:07:58,930 --> 00:08:03,969
can be span things that we're writing

00:08:02,229 --> 00:08:09,820
and in applications that we have

00:08:03,969 --> 00:08:11,920
dependencies on so

00:08:09,820 --> 00:08:15,040
when we look at building this on the

00:08:11,920 --> 00:08:17,110
kubernetes engine you know there's lots

00:08:15,040 --> 00:08:19,450
of advantages and lessons learned in

00:08:17,110 --> 00:08:22,000
kubernetes including a declarative API

00:08:19,450 --> 00:08:25,360
which is great

00:08:22,000 --> 00:08:29,290
cube CTL for native integration with

00:08:25,360 --> 00:08:31,090
other tools libraries in UI rich

00:08:29,290 --> 00:08:35,410
ecosystem and community around this

00:08:31,090 --> 00:08:36,850
obviously and letting us apply some of

00:08:35,410 --> 00:08:39,340
the lessons learned from container

00:08:36,850 --> 00:08:45,070
orchestration to multi-cloud workloads

00:08:39,340 --> 00:08:46,900
and resources so when we look at the

00:08:45,070 --> 00:08:50,830
resource lifecycle management piece of

00:08:46,900 --> 00:08:53,920
this kubernetes has custom resources and

00:08:50,830 --> 00:09:00,060
that we can use to model cloud provider

00:08:53,920 --> 00:09:03,430
services as well and we can use custom

00:09:00,060 --> 00:09:07,060
controllers to provision configure scale

00:09:03,430 --> 00:09:08,620
monitor upgrade provide failover and

00:09:07,060 --> 00:09:11,020
back up all of those lifecycle

00:09:08,620 --> 00:09:12,840
management things can be that logic can

00:09:11,020 --> 00:09:15,670
be put into a controller and that

00:09:12,840 --> 00:09:18,340
control can handle active reconciliation

00:09:15,670 --> 00:09:22,270
so that we essentially hands-up have

00:09:18,340 --> 00:09:25,230
hands-off management of those cloud

00:09:22,270 --> 00:09:25,230
provider services

00:09:28,050 --> 00:09:33,530
we also have this portable resource

00:09:30,510 --> 00:09:35,940
abstraction notion so you know

00:09:33,530 --> 00:09:39,570
kubernetes has a powerful volume

00:09:35,940 --> 00:09:42,480
abstraction it's a give its portability

00:09:39,570 --> 00:09:45,510
for stateful applications but what about

00:09:42,480 --> 00:09:48,780
other resources cloud provider resources

00:09:45,510 --> 00:09:51,350
might include databases buckets clusters

00:09:48,780 --> 00:09:54,540
caches message queues data pipelines

00:09:51,350 --> 00:09:57,900
everything there so let's abstract those

00:09:54,540 --> 00:10:02,850
two we really want to get to writing

00:09:57,900 --> 00:10:05,660
once and running anywhere and how do we

00:10:02,850 --> 00:10:05,660
do that so

00:10:09,370 --> 00:10:16,390
so about seven months ago a pound

00:10:13,750 --> 00:10:18,450
introduced crossplane it's an

00:10:16,390 --> 00:10:23,590
open-source multi-cloud control plane

00:10:18,450 --> 00:10:28,270
and it was released where it's still

00:10:23,590 --> 00:10:31,090
young it's a version 0.2 but what this

00:10:28,270 --> 00:10:35,760
does is it leverages the kubernetes api

00:10:31,090 --> 00:10:41,170
machinery at CD the workload scheduler

00:10:35,760 --> 00:10:44,380
and introduces resource controllers for

00:10:41,170 --> 00:10:47,190
both we support the three cloud

00:10:44,380 --> 00:10:49,570
providers AWS Azure and Google cloud

00:10:47,190 --> 00:10:53,110
there are other cloud providers we'd

00:10:49,570 --> 00:10:55,690
like to extend that support to and it

00:10:53,110 --> 00:10:58,270
can also provide controllers for

00:10:55,690 --> 00:11:01,690
actively managing other third-party

00:10:58,270 --> 00:11:05,650
software we'd like to see that extended

00:11:01,690 --> 00:11:08,820
to you things like elastic confluent

00:11:05,650 --> 00:11:10,870
data bricks other typical apps the

00:11:08,820 --> 00:11:13,690
typical frameworks that your apps going

00:11:10,870 --> 00:11:16,210
to manage and of course by building on

00:11:13,690 --> 00:11:19,240
the kubernetes api machinery you have

00:11:16,210 --> 00:11:23,200
all the same user interfaces and client

00:11:19,240 --> 00:11:30,910
libraries that you've grown to love and

00:11:23,200 --> 00:11:34,080
use and so when we look at one of the

00:11:30,910 --> 00:11:36,850
concepts that we're introducing here to

00:11:34,080 --> 00:11:41,500
do this as called separation of concerns

00:11:36,850 --> 00:11:45,310
where we look at developer who can

00:11:41,500 --> 00:11:47,290
compose their app and resources in a

00:11:45,310 --> 00:11:49,600
general way think about the dependencies

00:11:47,290 --> 00:11:51,700
that they have and at development time

00:11:49,600 --> 00:11:54,580
make sure that they're less tightly

00:11:51,700 --> 00:11:58,380
coupled and I kind of think of it like

00:11:54,580 --> 00:12:02,140
this image from Todd McLean who

00:11:58,380 --> 00:12:04,510
deconstructs common consumer items or

00:12:02,140 --> 00:12:07,510
household items and you see just how

00:12:04,510 --> 00:12:11,100
complex some of these simple items have

00:12:07,510 --> 00:12:15,460
become but when we think about how we

00:12:11,100 --> 00:12:16,900
build upon the machinery of software we

00:12:15,460 --> 00:12:19,810
have to get to the point where we have a

00:12:16,900 --> 00:12:21,520
factory model of components that we want

00:12:19,810 --> 00:12:26,020
to reuse

00:12:21,520 --> 00:12:28,960
and design to be modular and reused in

00:12:26,020 --> 00:12:31,440
other applications regardless of where

00:12:28,960 --> 00:12:36,730
those applications are intended to run

00:12:31,440 --> 00:12:39,310
so the separation of concerns also lets

00:12:36,730 --> 00:12:43,450
an administrator define the environment

00:12:39,310 --> 00:12:45,250
specifics and policies so at development

00:12:43,450 --> 00:12:49,600
time I might be running this in mini

00:12:45,250 --> 00:12:52,090
cube and installing crossplane using

00:12:49,600 --> 00:12:54,610
cloud resources but when I go to

00:12:52,090 --> 00:12:57,550
production that environment can be

00:12:54,610 --> 00:12:59,560
maintained by an administrator that can

00:12:57,550 --> 00:13:02,230
set policies I don't necessarily see

00:12:59,560 --> 00:13:06,700
secrets I just need a connection string

00:13:02,230 --> 00:13:10,690
or you know the secret references for a

00:13:06,700 --> 00:13:14,680
database request so how do we model that

00:13:10,690 --> 00:13:16,840
we we we looked at persistent volume

00:13:14,680 --> 00:13:20,380
claims and storage class and kubernetes

00:13:16,840 --> 00:13:23,830
and that's a model for creating resource

00:13:20,380 --> 00:13:25,930
claims and resource classes so if I have

00:13:23,830 --> 00:13:27,370
a resource class that is a database I

00:13:25,930 --> 00:13:31,810
can make a claim on that as an app

00:13:27,370 --> 00:13:34,180
developer and this allows us to do some

00:13:31,810 --> 00:13:36,670
dynamic on-demand provisioning of

00:13:34,180 --> 00:13:43,020
resources when we deploy to a specific

00:13:36,670 --> 00:13:46,210
environment so if we look at how this

00:13:43,020 --> 00:13:50,140
enables us to get to a get up style

00:13:46,210 --> 00:13:54,100
cloud native development pipeline we're

00:13:50,140 --> 00:13:58,600
going to have essentially app owners who

00:13:54,100 --> 00:14:00,370
are developing their yeah Mille for

00:13:58,600 --> 00:14:03,750
their application that includes resource

00:14:00,370 --> 00:14:07,210
claims and workloads will have

00:14:03,750 --> 00:14:11,590
administrators who are also provisioning

00:14:07,210 --> 00:14:13,450
the environment where the resource

00:14:11,590 --> 00:14:16,990
classes that are available within that

00:14:13,450 --> 00:14:21,940
environment they'll be choosing

00:14:16,990 --> 00:14:25,780
providers that basically can be used for

00:14:21,940 --> 00:14:28,480
that they might choose to use AWS or GCP

00:14:25,780 --> 00:14:31,050
and they'll be defining concrete or

00:14:28,480 --> 00:14:33,540
resources like secrets

00:14:31,050 --> 00:14:36,480
and be pcs and other things within that

00:14:33,540 --> 00:14:39,540
environment so as an app developer I'm

00:14:36,480 --> 00:14:41,220
going to be insulated from that and I

00:14:39,540 --> 00:14:44,360
think in this way the the dev and the

00:14:41,220 --> 00:14:48,269
Ops world converged on a single API

00:14:44,360 --> 00:14:51,450
kubernetes api based resource for that

00:14:48,269 --> 00:14:55,250
that stack or app definition that's

00:14:51,450 --> 00:14:55,250
composed of those two different things

00:14:55,459 --> 00:15:03,180
so just to give you an example of what a

00:14:58,680 --> 00:15:04,769
resource claim would look like as an app

00:15:03,180 --> 00:15:10,050
owner

00:15:04,769 --> 00:15:12,240
here's Postgres where the request for

00:15:10,050 --> 00:15:14,370
Postgres it doesn't have a whole lot of

00:15:12,240 --> 00:15:17,550
the environment specifics I don't yet

00:15:14,370 --> 00:15:20,279
say where this is going to run and I

00:15:17,550 --> 00:15:23,550
basically can specify the engine version

00:15:20,279 --> 00:15:27,709
that I need and that it's going to come

00:15:23,550 --> 00:15:27,709
from a cloud Postgres provider

00:15:30,070 --> 00:15:36,430
the resource class as defined I there

00:15:34,720 --> 00:15:38,500
are defaults that are installed when

00:15:36,430 --> 00:15:41,340
crossplane is installed but the system

00:15:38,500 --> 00:15:43,530
administrator can go in and update those

00:15:41,340 --> 00:15:46,270
defaults but this is going to contain

00:15:43,530 --> 00:15:49,420
properties that are defined that are

00:15:46,270 --> 00:15:54,730
specific to that cloud provider it might

00:15:49,420 --> 00:15:59,080
on a dia AWS be using a certain instance

00:15:54,730 --> 00:16:04,510
size or database size they're going to

00:15:59,080 --> 00:16:12,190
be able to define policy and allow apps

00:16:04,510 --> 00:16:13,960
to default to that so one of the

00:16:12,190 --> 00:16:18,580
partners we've been extremely fortunate

00:16:13,960 --> 00:16:20,770
to be working with is gitlab we wanted

00:16:18,580 --> 00:16:24,490
to choose a partner that has a fairly

00:16:20,770 --> 00:16:28,330
complex real-world application to prove

00:16:24,490 --> 00:16:32,620
out cross plains model and we're

00:16:28,330 --> 00:16:37,300
learning a lot about how to design the

00:16:32,620 --> 00:16:39,430
controllers and the workloads so just to

00:16:37,300 --> 00:16:42,040
give you an example get lab is currently

00:16:39,430 --> 00:16:45,580
deployed it's a helmet art it has about

00:16:42,040 --> 00:16:48,460
48 hundred lines of yamo it consists of

00:16:45,580 --> 00:16:52,240
14 deployment three jobs nine services

00:16:48,460 --> 00:16:54,760
16 config maps so there's a lot going on

00:16:52,240 --> 00:16:59,650
in there their main dependencies are on

00:16:54,760 --> 00:17:02,800
Postgres Redis and object storage so

00:16:59,650 --> 00:17:04,570
they wanted to have this run across be

00:17:02,800 --> 00:17:08,920
able to deploy across different cloud

00:17:04,570 --> 00:17:11,110
providers and we were starting to look

00:17:08,920 --> 00:17:14,020
at their current install and how could

00:17:11,110 --> 00:17:16,420
we make this better so with a custom

00:17:14,020 --> 00:17:17,650
resource definition there's a simple

00:17:16,420 --> 00:17:21,400
configured speery ins

00:17:17,650 --> 00:17:23,140
with the custom get lab controller we

00:17:21,400 --> 00:17:24,760
can generate these artifacts and

00:17:23,140 --> 00:17:27,850
essentially manage the state of the

00:17:24,760 --> 00:17:30,100
deployment and get to the point where

00:17:27,850 --> 00:17:32,380
the deployment of get lab is a fully

00:17:30,100 --> 00:17:35,830
automated and portable multi cloud

00:17:32,380 --> 00:17:38,080
deployment so this is how it kind of

00:17:35,830 --> 00:17:40,990
looks when you look at what we've design

00:17:38,080 --> 00:17:42,120
design forget lab and by the way this is

00:17:40,990 --> 00:17:44,910
all out on

00:17:42,120 --> 00:17:49,590
our open source site so you can review

00:17:44,910 --> 00:17:53,060
how this is the examples for this you'll

00:17:49,590 --> 00:17:55,620
see that basically the Postgres

00:17:53,060 --> 00:17:57,630
controller Redis controller and bucket

00:17:55,620 --> 00:18:04,680
controller are pulled in as resource

00:17:57,630 --> 00:18:06,150
claims within gitlab the on AWS or GC P

00:18:04,680 --> 00:18:09,090
or Azure those are mapped to the

00:18:06,150 --> 00:18:12,960
different cloud provider specific

00:18:09,090 --> 00:18:16,410
services so it might be buckets on AWS

00:18:12,960 --> 00:18:19,590
and you know we're gonna also be

00:18:16,410 --> 00:18:23,120
spinning up and deploying to it managed

00:18:19,590 --> 00:18:26,450
cluster so it's G key or a KS or

00:18:23,120 --> 00:18:30,330
whatever the cloud provider specific

00:18:26,450 --> 00:18:36,420
resource is so crossplane just manages

00:18:30,330 --> 00:18:39,060
this for you so right now kind of show

00:18:36,420 --> 00:18:41,400
you a demo that steps through this

00:18:39,060 --> 00:18:43,890
step-by-step it kind of decomposes it

00:18:41,400 --> 00:18:46,050
the app would normally bundle these

00:18:43,890 --> 00:18:50,090
things together but I think this will

00:18:46,050 --> 00:18:53,420
give you an idea of what it looks like

00:18:50,090 --> 00:18:53,420
switch over

00:19:01,270 --> 00:19:07,750
so first we're going to basically

00:19:04,150 --> 00:19:12,910
install crossplane in this case it's my

00:19:07,750 --> 00:19:15,820
local mini cube cluster I'm going to run

00:19:12,910 --> 00:19:19,000
it you know you might just run it where

00:19:15,820 --> 00:19:23,200
your workloads are gonna run for tests

00:19:19,000 --> 00:19:26,140
and staging so we grab crossplane from

00:19:23,200 --> 00:19:28,450
the master channel and by the way I

00:19:26,140 --> 00:19:30,580
could never type this fast and I don't

00:19:28,450 --> 00:19:34,930
want to screw up the demo so it's a

00:19:30,580 --> 00:19:38,590
video for you so we'll install the

00:19:34,930 --> 00:19:42,520
helmet chart from our master channel to

00:19:38,590 --> 00:19:44,020
get crossplane installed and the key

00:19:42,520 --> 00:19:46,660
third part of this is once we've

00:19:44,020 --> 00:19:50,760
installed crossplane we will have on our

00:19:46,660 --> 00:19:54,460
system custom resources for a set of

00:19:50,760 --> 00:19:58,150
classes so you can see here when we do a

00:19:54,460 --> 00:20:04,530
cube CTL to get those CR DS that we now

00:19:58,150 --> 00:20:08,230
have various CR DS for buckets and

00:20:04,530 --> 00:20:10,390
databases memory caches and other things

00:20:08,230 --> 00:20:12,970
that have been installed and are

00:20:10,390 --> 00:20:15,450
available from different all three cloud

00:20:12,970 --> 00:20:15,450
providers

00:20:19,550 --> 00:20:28,430
and once we've installed crossplane

00:20:23,440 --> 00:20:32,000
now we want to basically start to grab

00:20:28,430 --> 00:20:35,630
our cloud provider credentials and for

00:20:32,000 --> 00:20:37,150
this example we're just going to do the

00:20:35,630 --> 00:20:44,510
simplest possible thing we're going to

00:20:37,150 --> 00:20:51,440
grab our credentials from GCP and stuff

00:20:44,510 --> 00:20:56,960
them into a yamo file so here we grab

00:20:51,440 --> 00:21:00,170
the credentials and just copy them into

00:20:56,960 --> 00:21:07,370
our provider yeah Mille so now we have

00:21:00,170 --> 00:21:11,920
those credentials and we're going to

00:21:07,370 --> 00:21:16,810
deploy those to our cluster of secrets

00:21:11,920 --> 00:21:24,220
so with the secrets available we can

00:21:16,810 --> 00:21:24,220
then provision some resource classes

00:21:30,309 --> 00:21:36,249
so the process of provisioning resource

00:21:34,029 --> 00:21:37,989
classes is really the domain of the

00:21:36,249 --> 00:21:39,969
administrator if you're playing

00:21:37,989 --> 00:21:43,080
administrator and app developer you can

00:21:39,969 --> 00:21:45,399
put these two together but an

00:21:43,080 --> 00:21:47,619
administrator in this case might decide

00:21:45,399 --> 00:21:50,229
they're going to make available the

00:21:47,619 --> 00:21:55,690
resource classes for AWS only if you're

00:21:50,229 --> 00:21:58,479
an AWS shop and so you can go in and set

00:21:55,690 --> 00:22:03,690
various properties within this in this

00:21:58,479 --> 00:22:08,589
case back there we were setting the the

00:22:03,690 --> 00:22:13,239
storage size and region for our for our

00:22:08,589 --> 00:22:18,729
storage for the standard cloud sequel

00:22:13,239 --> 00:22:20,679
instance in GCP but we can come in and

00:22:18,729 --> 00:22:22,989
and basically configure these defaults

00:22:20,679 --> 00:22:27,070
in this case that was the Postgres

00:22:22,989 --> 00:22:28,899
configuration also look at the bucket

00:22:27,070 --> 00:22:32,289
configuration here and just make sure

00:22:28,899 --> 00:22:34,809
that it's good to go before I start

00:22:32,289 --> 00:22:40,659
having apps unleashed into our buckets

00:22:34,809 --> 00:22:47,049
so once that's set up I now basically

00:22:40,659 --> 00:22:49,659
can keep CTL create on those resource

00:22:47,049 --> 00:22:51,399
classes those are now created and

00:22:49,659 --> 00:22:53,919
they're essentially provisioned in that

00:22:51,399 --> 00:22:57,399
crossplane instance and available to any

00:22:53,919 --> 00:22:59,739
apps that want to consume them so now we

00:22:57,399 --> 00:23:02,979
go back to what does the app developer

00:22:59,739 --> 00:23:06,190
do in this case we're going to

00:23:02,979 --> 00:23:11,249
provisions to manage services in Google

00:23:06,190 --> 00:23:16,080
Cloud and then I'll show you an AWS so

00:23:11,249 --> 00:23:18,549
this is this is the dependencies for

00:23:16,080 --> 00:23:21,460
forget lap we basically make use of

00:23:18,549 --> 00:23:22,960
kubernetes so we're gonna spin up a

00:23:21,460 --> 00:23:26,440
cluster that we're going to deploy get

00:23:22,960 --> 00:23:31,239
lab two we're gonna make an instant

00:23:26,440 --> 00:23:34,179
reference to Postgres and Redis and so

00:23:31,239 --> 00:23:36,729
what we did was basically deploy the

00:23:34,179 --> 00:23:38,850
buckets they have about nine different

00:23:36,729 --> 00:23:42,520
buckets they use

00:23:38,850 --> 00:23:45,580
since we basically keep CTL applied the

00:23:42,520 --> 00:23:49,480
bucket resource we now basically have

00:23:45,580 --> 00:23:52,570
that controller going out and spinning

00:23:49,480 --> 00:23:53,620
up the buckets in GCP and once those are

00:23:52,570 --> 00:23:56,740
reconciled

00:23:53,620 --> 00:24:00,090
they'll be bound within the resource so

00:23:56,740 --> 00:24:03,280
you can kind of see that there right now

00:24:00,090 --> 00:24:06,820
only one of the buckets is bound but the

00:24:03,280 --> 00:24:09,850
others are still being created so if we

00:24:06,820 --> 00:24:11,170
switch over and look we can just keep

00:24:09,850 --> 00:24:13,240
pulling this where you can go get a

00:24:11,170 --> 00:24:16,270
coffee and just wait the buckets are

00:24:13,240 --> 00:24:18,130
fast other things might take a few

00:24:16,270 --> 00:24:19,960
minutes and but now you've got a

00:24:18,130 --> 00:24:24,310
reconciler that's just doing that work

00:24:19,960 --> 00:24:26,230
for you it's a hands off so here I kind

00:24:24,310 --> 00:24:27,940
of just switched through the console and

00:24:26,230 --> 00:24:31,480
kind of look and see what the state of

00:24:27,940 --> 00:24:34,270
things is making sure that things are

00:24:31,480 --> 00:24:41,860
spinning up but really I don't have to

00:24:34,270 --> 00:24:46,050
do this it's just to show you and so

00:24:41,860 --> 00:24:49,960
once those resources are created and

00:24:46,050 --> 00:24:52,960
bound within kubernetes we can basically

00:24:49,960 --> 00:24:55,960
then come and take those resource claims

00:24:52,960 --> 00:24:58,960
that we have and export them to our git

00:24:55,960 --> 00:25:01,510
lab help chart this these two steps

00:24:58,960 --> 00:25:03,460
would generally be bundled together in

00:25:01,510 --> 00:25:05,140
your application but we're showing them

00:25:03,460 --> 00:25:09,310
here so that you can kind of see what's

00:25:05,140 --> 00:25:12,820
going on under the covers so here we

00:25:09,310 --> 00:25:15,760
basically have the git lab resource

00:25:12,820 --> 00:25:18,310
claims that we made in our default

00:25:15,760 --> 00:25:22,600
namespace we're going to copy those to

00:25:18,310 --> 00:25:26,320
our target cluster and make sure they're

00:25:22,600 --> 00:25:29,050
available in the get lab namespace and

00:25:26,320 --> 00:25:31,350
then we're going to update the helm

00:25:29,050 --> 00:25:31,350
chart

00:25:31,580 --> 00:25:37,760
make sure we have a values file that has

00:25:33,800 --> 00:25:42,590
all of our secrets and is or references

00:25:37,760 --> 00:25:46,100
to our secrets and is ready to go so

00:25:42,590 --> 00:25:49,360
there we go we've copied over everything

00:25:46,100 --> 00:25:49,360
into the target cluster

00:25:57,029 --> 00:26:06,269
and that is ready to go so now if we

00:26:01,519 --> 00:26:12,359
grab a helmet chart and everything from

00:26:06,269 --> 00:26:17,389
the get lab repo we are basically ready

00:26:12,359 --> 00:26:20,729
to install and update it with our values

00:26:17,389 --> 00:26:23,989
so that's it now we were ready to

00:26:20,729 --> 00:26:23,989
install get lab

00:26:30,240 --> 00:26:35,010
so this essentially will be installing

00:26:33,000 --> 00:26:42,870
gitlab to our target cluster that we

00:26:35,010 --> 00:26:49,320
provision as a resource claim and we go

00:26:42,870 --> 00:26:53,670
ahead and run that get lab but takes a

00:26:49,320 --> 00:26:56,490
little while to spin up so we can either

00:26:53,670 --> 00:26:58,830
go get coffee again or we could

00:26:56,490 --> 00:27:02,570
basically watch as it spins these

00:26:58,830 --> 00:27:05,810
services up so now we're waiting for

00:27:02,570 --> 00:27:08,940
we're using kubernetes of course to

00:27:05,810 --> 00:27:11,720
check the status of whether these

00:27:08,940 --> 00:27:14,960
services are bound and you can see here

00:27:11,720 --> 00:27:21,500
the services that are being initialized

00:27:14,960 --> 00:27:21,500
including the buckets and Postgres so

00:27:21,740 --> 00:27:28,880
once those are spun up we will have an

00:27:25,800 --> 00:27:32,490
address an IP address that we can grab

00:27:28,880 --> 00:27:36,690
crossplane doesn't yet provision the

00:27:32,490 --> 00:27:38,400
things like V pcs and other open ports

00:27:36,690 --> 00:27:41,850
and other things like that we'd like to

00:27:38,400 --> 00:27:43,230
extend it to manage those things so

00:27:41,850 --> 00:27:48,050
you'll see here that I just grabbed the

00:27:43,230 --> 00:27:48,050
IP address and manually open that up

00:27:51,900 --> 00:27:58,640
drop that in and create a new DNS entry

00:27:54,720 --> 00:27:58,640
and Google

00:28:03,030 --> 00:28:07,330
and

00:28:04,840 --> 00:28:10,180
keep waiting here and we'll see what the

00:28:07,330 --> 00:28:12,190
state of our pot is you now see that the

00:28:10,180 --> 00:28:15,580
status is running or completed on

00:28:12,190 --> 00:28:17,470
everything except for their test things

00:28:15,580 --> 00:28:21,990
so we are basically ready to go we can

00:28:17,470 --> 00:28:24,790
then grab the status URL from the

00:28:21,990 --> 00:28:27,520
controller basically fire up the console

00:28:24,790 --> 00:28:30,610
and we are ready to go so basically that

00:28:27,520 --> 00:28:33,580
took a complex app and made it hands off

00:28:30,610 --> 00:28:35,920
with the get lab controller to handle

00:28:33,580 --> 00:28:38,530
all of that reconciliation and that

00:28:35,920 --> 00:28:41,050
controller can also you know continue to

00:28:38,530 --> 00:28:48,180
monitor the health and status of that

00:28:41,050 --> 00:28:48,180
good lab deployment so that is get lab

00:28:54,360 --> 00:29:05,940
with crossplane is so we'd love to

00:29:03,660 --> 00:29:08,370
welcome the community to continue to

00:29:05,940 --> 00:29:12,660
grow cross flane we're just about to hit

00:29:08,370 --> 00:29:15,300
a dot three release and but the would

00:29:12,660 --> 00:29:17,400
love to see folks get involved i put

00:29:15,300 --> 00:29:20,970
some resources up here if you want to

00:29:17,400 --> 00:29:23,010
take a look at the get lab deployment

00:29:20,970 --> 00:29:26,040
and other sample applications like

00:29:23,010 --> 00:29:30,120
woodward press on the site we have

00:29:26,040 --> 00:29:32,270
regular community meetings and would

00:29:30,120 --> 00:29:34,320
love to extend crossplane into

00:29:32,270 --> 00:29:39,090
infrastructure provisioning and other

00:29:34,320 --> 00:29:43,250
cloud providers thank you anybody else

00:29:39,090 --> 00:29:43,250
any questions from the audience

00:29:46,460 --> 00:29:53,139
okay thanks everybody oh did you have a

00:29:50,240 --> 00:29:53,139
question yeah

00:30:07,600 --> 00:30:13,050
[Music]

00:30:09,770 --> 00:30:18,950
first of all I'm a newbie to you two

00:30:13,050 --> 00:30:22,550
about containers and kubernetes so my

00:30:18,950 --> 00:30:29,070
questions might be ridiculous one but

00:30:22,550 --> 00:30:34,320
what is biggest advantage of introducing

00:30:29,070 --> 00:30:38,460
much crowd introducing your product

00:30:34,320 --> 00:30:43,670
I mean is it correct or understanding

00:30:38,460 --> 00:30:46,230
that by using your product the

00:30:43,670 --> 00:30:48,780
application code portability is

00:30:46,230 --> 00:30:52,230
guaranteed right right right

00:30:48,780 --> 00:30:54,030
so one advantage being you know all

00:30:52,230 --> 00:30:57,180
different sides of your house your

00:30:54,030 --> 00:31:00,120
administration and developers are

00:30:57,180 --> 00:31:02,550
converging on kubernetes but also the

00:31:00,120 --> 00:31:05,640
application things that you're deploying

00:31:02,550 --> 00:31:08,610
may not live in a cluster they may be

00:31:05,640 --> 00:31:10,950
managing things across clouds so your

00:31:08,610 --> 00:31:17,100
application spans that with a single

00:31:10,950 --> 00:31:18,690
development framework most in most

00:31:17,100 --> 00:31:21,450
applications today are essentially

00:31:18,690 --> 00:31:23,190
targeting a cluster or doing multi

00:31:21,450 --> 00:31:26,070
cluster deployments but it's still

00:31:23,190 --> 00:31:35,330
limited to your cluster are there any

00:31:26,070 --> 00:31:40,400
activities to minimize such gaps or

00:31:35,330 --> 00:31:44,820
products like your product activity

00:31:40,400 --> 00:31:47,960
provided by you it's recommended for the

00:31:44,820 --> 00:31:53,900
feature I think that there are two

00:31:47,960 --> 00:31:58,200
alternatives in the future like from

00:31:53,900 --> 00:32:06,480
application developer point of view if

00:31:58,200 --> 00:32:08,550
there is no gap between two clouds with

00:32:06,480 --> 00:32:12,360
regard to the application growing

00:32:08,550 --> 00:32:15,180
programming point of view no problem so

00:32:12,360 --> 00:32:18,110
I think there is a way to minimize such

00:32:15,180 --> 00:32:18,110
gaps but

00:32:18,289 --> 00:32:26,669
is there any activities to minimize gap

00:32:23,580 --> 00:32:28,350
or there's no activities well I think

00:32:26,669 --> 00:32:31,070
you know if I understand your question

00:32:28,350 --> 00:32:34,200
the there are going to continue be

00:32:31,070 --> 00:32:35,940
differences across cloud providers the

00:32:34,200 --> 00:32:37,820
they're creating walled gardens and

00:32:35,940 --> 00:32:41,580
their incentive is to have

00:32:37,820 --> 00:32:45,029
differentiated services but for many of

00:32:41,580 --> 00:32:46,619
the services like particularly services

00:32:45,029 --> 00:32:49,289
that have been taken from open source

00:32:46,619 --> 00:32:53,940
and you know put into the walled garden

00:32:49,289 --> 00:32:56,009
like databases you have compatibility at

00:32:53,940 --> 00:32:58,019
a wire protocol level like if I want

00:32:56,009 --> 00:33:02,159
Postgres you know it doesn't really

00:32:58,019 --> 00:33:04,499
matter that it's RDS so taking those and

00:33:02,159 --> 00:33:07,220
creating a portable abstraction for

00:33:04,499 --> 00:33:10,739
requesting a sequel database and

00:33:07,220 --> 00:33:15,659
allowing apps to essentially for the 80%

00:33:10,739 --> 00:33:19,980
scenario use portable extractions before

00:33:15,659 --> 00:33:22,799
you get into cloud provider specifics is

00:33:19,980 --> 00:33:27,080
a great way to essentially reduce the

00:33:22,799 --> 00:33:30,539
development time right and give people a

00:33:27,080 --> 00:33:33,869
common set of controllers that are well

00:33:30,539 --> 00:33:35,999
tested and and very rich in their active

00:33:33,869 --> 00:33:38,460
state management you can certainly go

00:33:35,999 --> 00:33:41,429
and develop a controller that is

00:33:38,460 --> 00:33:45,059
specific to a cloud provider and has all

00:33:41,429 --> 00:33:47,749
of the rich features and and so breadth

00:33:45,059 --> 00:33:51,989
and the ability to sort of configure

00:33:47,749 --> 00:33:53,309
specific features is there so ok thank

00:33:51,989 --> 00:33:56,399
you thank you

00:33:53,309 --> 00:34:01,399
and I think we're out of time

00:33:56,399 --> 00:34:01,399
yep a one to one question ok

00:34:01,700 --> 00:34:06,910
coming from that question I thought

00:34:03,890 --> 00:34:09,169
there is some service provide a

00:34:06,910 --> 00:34:10,929
controller they've been developed as an

00:34:09,169 --> 00:34:13,730
interface being developed for each

00:34:10,929 --> 00:34:16,520
service provider cloud provider is that

00:34:13,730 --> 00:34:19,610
isn't it helping to alleviate some of

00:34:16,520 --> 00:34:24,050
the issue with compatibility right so we

00:34:19,610 --> 00:34:28,179
do have resource classes for AWS Google

00:34:24,050 --> 00:34:32,000
cloud and Azure and and so there is

00:34:28,179 --> 00:34:34,240
support directly for for those it

00:34:32,000 --> 00:34:37,580
doesn't extend to the full breadth of

00:34:34,240 --> 00:34:39,590
api's and that would be something that

00:34:37,580 --> 00:34:44,300
we would continue to evolve as

00:34:39,590 --> 00:34:47,140
crossplane matures okay thank you cool

00:34:44,300 --> 00:34:47,140

YouTube URL: https://www.youtube.com/watch?v=c4YbFn1_g0Q


