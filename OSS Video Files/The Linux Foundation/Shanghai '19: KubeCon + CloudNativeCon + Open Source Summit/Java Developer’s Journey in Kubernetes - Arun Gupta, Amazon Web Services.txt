Title: Java Developer’s Journey in Kubernetes - Arun Gupta, Amazon Web Services
Publication date: 2019-07-10
Playlist: Shanghai '19: KubeCon + CloudNativeCon + Open Source Summit
Description: 
	Java Developer’s Journey in Kubernetes - Arun Gupta, Amazon Web Services 

Deploying your Java application in a Kubernetes cluster could feel like Alice in Wonderland. You keep going down the rabbit hole and don’t know how to make that ride comfortable. This no-slide and code-only session will explain how a Java application can be deployed in a Kubernetes cluster. Specifically, it will explain the following:    Package the application as Docker image  Create Kubernetes manifests  Create Helm charts  Test in a local k8s cluster  Debug pods using Java IDE  Observability using Istio  Canary and A/B testing  Migrate application from dev to prod environments  Deployment pipeline on desktop and in the cloud 

https://sched.co/NrlQ
Captions: 
	00:00:00,030 --> 00:00:05,220
right good morning my name is Arun Gupta

00:00:02,879 --> 00:00:09,710
and I work for Amazon in the open source

00:00:05,220 --> 00:00:12,990
team how many of you are Java developers

00:00:09,710 --> 00:00:15,120
know almost 90% of you so I think this

00:00:12,990 --> 00:00:18,300
talk is very relevant in that sense I've

00:00:15,120 --> 00:00:22,560
been a longtime Java developer I started

00:00:18,300 --> 00:00:28,410
my Java journey back in 99 when we were

00:00:22,560 --> 00:00:30,689
doing jdk 1.6 now as a Java developer

00:00:28,410 --> 00:00:33,600
I'm always thinking about where a new

00:00:30,689 --> 00:00:35,940
technology comes along how do I start

00:00:33,600 --> 00:00:37,680
with that technology how do I start

00:00:35,940 --> 00:00:40,200
learning that technology applying my

00:00:37,680 --> 00:00:42,180
existing skills so this is how sort of

00:00:40,200 --> 00:00:44,910
how I created this github workspace

00:00:42,180 --> 00:00:48,000
there are no slides and so this is

00:00:44,910 --> 00:00:50,219
purely gonna be code driven and workshop

00:00:48,000 --> 00:00:52,320
here so in the next 35 minutes or so I

00:00:50,219 --> 00:00:54,300
hope to guide you what should your

00:00:52,320 --> 00:00:56,250
journey look like if you are a Java

00:00:54,300 --> 00:00:58,289
developer and you want to get started

00:00:56,250 --> 00:01:00,449
with say kubernetes essentially that's

00:00:58,289 --> 00:01:02,600
sort of what it looks like okay now if

00:01:00,449 --> 00:01:06,270
you look at it here as I said earlier

00:01:02,600 --> 00:01:08,250
all of the code is available on this

00:01:06,270 --> 00:01:11,670
github repo so this is sort of the one

00:01:08,250 --> 00:01:14,490
that you wanna bookmark essentially and

00:01:11,670 --> 00:01:18,090
the way I look at it is file issues send

00:01:14,490 --> 00:01:19,560
me pull requests star it fork it you

00:01:18,090 --> 00:01:21,689
know whatever way you want to monitor it

00:01:19,560 --> 00:01:26,009
but that's sort of where all the content

00:01:21,689 --> 00:01:28,080
is sitting now as an application

00:01:26,009 --> 00:01:29,460
developer what I'm going to do is I'm

00:01:28,080 --> 00:01:31,350
going to show you quickly what our

00:01:29,460 --> 00:01:33,000
application looks like it's a simple

00:01:31,350 --> 00:01:35,400
spring good application just simple

00:01:33,000 --> 00:01:38,009
hello world that's the intent because

00:01:35,400 --> 00:01:41,250
you know how to build a lot more fancier

00:01:38,009 --> 00:01:43,290
and more better applications essentially

00:01:41,250 --> 00:01:46,200
then I'm gonna show you how you build

00:01:43,290 --> 00:01:47,820
and test that using maven then we start

00:01:46,200 --> 00:01:49,470
building that application that okay what

00:01:47,820 --> 00:01:52,619
is my first step in the journey for

00:01:49,470 --> 00:01:54,720
kubernetes I need to make a docker image

00:01:52,619 --> 00:01:56,040
out of their java application what are

00:01:54,720 --> 00:01:58,079
my choices around that so we'll talk

00:01:56,040 --> 00:02:00,240
about that briefly then we take it take

00:01:58,079 --> 00:02:02,040
a look at it particularly from the Java

00:02:00,240 --> 00:02:04,770
perspective what are the things that I

00:02:02,040 --> 00:02:06,840
need to be aware of can I use JDK as a

00:02:04,770 --> 00:02:09,899
base image should I use JRE as the base

00:02:06,840 --> 00:02:12,390
image with JDK 11 what are the things

00:02:09,899 --> 00:02:15,630
that I need to be concerned about

00:02:12,390 --> 00:02:17,280
then we talk about how do I once I build

00:02:15,630 --> 00:02:20,160
the docker image how do I take that

00:02:17,280 --> 00:02:22,530
docker image and now run it on a Cuban

00:02:20,160 --> 00:02:24,450
eros cluster and what are my choices for

00:02:22,530 --> 00:02:27,120
running kubernetes locally on my machine

00:02:24,450 --> 00:02:30,180
in the cloud so those are the different

00:02:27,120 --> 00:02:31,530
options that we can consider then we're

00:02:30,180 --> 00:02:33,300
going to migrate the application from

00:02:31,530 --> 00:02:35,490
your development mode which is on your

00:02:33,300 --> 00:02:37,860
laptop to the production mode which is

00:02:35,490 --> 00:02:39,750
in the in the cloud we'll talk a little

00:02:37,860 --> 00:02:41,490
bit about the relevance of surface mesh

00:02:39,750 --> 00:02:43,920
what does it give you what does it by

00:02:41,490 --> 00:02:48,930
you why do you need it and what are your

00:02:43,920 --> 00:02:50,580
choices around that we'll talk a little

00:02:48,930 --> 00:02:52,320
bit about deployment pipeline because

00:02:50,580 --> 00:02:54,810
that's a relevant aspect now as you are

00:02:52,320 --> 00:02:57,660
doing a good push to your application as

00:02:54,810 --> 00:02:59,550
soon as you do git push we you want the

00:02:57,660 --> 00:03:01,260
application to be available in your

00:02:59,550 --> 00:03:03,270
development or in your deployment

00:03:01,260 --> 00:03:05,730
environment so we'll talk about all of

00:03:03,270 --> 00:03:07,950
those different options okay so let's go

00:03:05,730 --> 00:03:10,050
look at our application first thing so

00:03:07,950 --> 00:03:12,330
if you look at app this is a directory

00:03:10,050 --> 00:03:13,980
where my application is sitting and as I

00:03:12,330 --> 00:03:16,830
said this is a simple spring boot

00:03:13,980 --> 00:03:19,890
application so if you look into the

00:03:16,830 --> 00:03:23,100
source and if you look at my greeting

00:03:19,890 --> 00:03:27,090
controller it's a very simple Springwood

00:03:23,100 --> 00:03:27,810
application all it returns on line 14 is

00:03:27,090 --> 00:03:29,220
hello

00:03:27,810 --> 00:03:32,100
so essentially when you run the

00:03:29,220 --> 00:03:34,500
application and you hit it on /hello it

00:03:32,100 --> 00:03:39,900
would return that hello response to you

00:03:34,500 --> 00:03:42,500
okay if you look at my Palm D'Or XML

00:03:39,900 --> 00:03:44,970
which is how I build my java application

00:03:42,500 --> 00:03:48,720
nothing fancy I'm using spring boot

00:03:44,970 --> 00:03:51,150
starter as my parent I have the spring

00:03:48,720 --> 00:03:53,250
boot maven plug-in in there and we'll

00:03:51,150 --> 00:03:56,459
talk about this profile a bit later but

00:03:53,250 --> 00:03:58,769
so very standard spring food application

00:03:56,459 --> 00:04:02,310
no special dependencies required over

00:03:58,769 --> 00:04:04,050
there okay now if I were to run this

00:04:02,310 --> 00:04:06,090
application it would return hello

00:04:04,050 --> 00:04:08,340
okay that's not the point though so if

00:04:06,090 --> 00:04:11,070
you go down here I'm going to say maven

00:04:08,340 --> 00:04:12,780
spring good run and I say Karl and it

00:04:11,070 --> 00:04:15,330
returns hello yeah I've only 35 minutes

00:04:12,780 --> 00:04:16,380
so you can only do live demos so much so

00:04:15,330 --> 00:04:19,470
I'm just gonna walk you through it

00:04:16,380 --> 00:04:21,450
essentially so now the second step for

00:04:19,470 --> 00:04:24,479
you is now that your application is up

00:04:21,450 --> 00:04:25,820
and running you want to get the exact

00:04:24,479 --> 00:04:28,380
same out

00:04:25,820 --> 00:04:29,880
from the darker image because the first

00:04:28,380 --> 00:04:32,010
step in your journey to cover notice is

00:04:29,880 --> 00:04:33,540
to create a darker image out of a java

00:04:32,010 --> 00:04:36,360
application okay so what are your

00:04:33,540 --> 00:04:38,960
choices for creating darker image you

00:04:36,360 --> 00:04:41,010
can use docker file that is one of the

00:04:38,960 --> 00:04:44,460
ways by which you create a darker image

00:04:41,010 --> 00:04:46,140
you can use a maven plug-in that is

00:04:44,460 --> 00:04:48,210
another option and there are a lot of

00:04:46,140 --> 00:04:49,650
variety for the maven plugins that is

00:04:48,210 --> 00:04:52,230
available so we'll talk a little bit

00:04:49,650 --> 00:04:53,820
about that now as you are using a darker

00:04:52,230 --> 00:04:56,460
image or a darker file

00:04:53,820 --> 00:04:59,160
what should be a base image B can I use

00:04:56,460 --> 00:05:03,060
JDK as a base image or should I use JRE

00:04:59,160 --> 00:05:05,130
as a base image with JDK 11 or the other

00:05:03,060 --> 00:05:07,470
nine onwards you can create custom

00:05:05,130 --> 00:05:09,990
Geri's so how does that work out you

00:05:07,470 --> 00:05:11,670
know because eventually when your

00:05:09,990 --> 00:05:13,980
application is deployed in kubernetes

00:05:11,670 --> 00:05:17,070
and you're using a micro services based

00:05:13,980 --> 00:05:20,940
architecture your docker image is

00:05:17,070 --> 00:05:23,190
downloaded on the fly at a particular

00:05:20,940 --> 00:05:26,790
node so it's very important that your

00:05:23,190 --> 00:05:30,000
image size is small so if we use JDK the

00:05:26,790 --> 00:05:31,740
base image then you are unnecessarily

00:05:30,000 --> 00:05:33,840
bundling the compiler and everything

00:05:31,740 --> 00:05:35,850
into the application itself that's where

00:05:33,840 --> 00:05:39,570
you start looking at it let me use JRE

00:05:35,850 --> 00:05:41,100
as a base image okay so what I'm gonna

00:05:39,570 --> 00:05:44,490
do here is I'm going to go back to my

00:05:41,100 --> 00:05:48,350
application here and I'm going to show

00:05:44,490 --> 00:05:48,350
you a docker file here okay

00:05:51,240 --> 00:05:55,080
now in this dockerfile let's talk walk

00:05:53,699 --> 00:05:56,460
through this little bit okay so first of

00:05:55,080 --> 00:05:59,910
all on line one

00:05:56,460 --> 00:06:02,400
I'm using maven as a base image okay and

00:05:59,910 --> 00:06:03,780
this is important because now I can give

00:06:02,400 --> 00:06:06,960
this docker file to anywhere where

00:06:03,780 --> 00:06:09,419
docker is available and I don't need to

00:06:06,960 --> 00:06:11,280
deploy or install maven separately I'm

00:06:09,419 --> 00:06:13,800
using maven as the base image itself

00:06:11,280 --> 00:06:16,139
that means it will download the maven

00:06:13,800 --> 00:06:19,020
docker image and it will have maven

00:06:16,139 --> 00:06:22,800
pre-installed so once I do that then I

00:06:19,020 --> 00:06:25,949
can copy my source code and now I can

00:06:22,800 --> 00:06:27,509
run maven itself now one of the steps

00:06:25,949 --> 00:06:30,509
that is commented out here is for

00:06:27,509 --> 00:06:34,470
example I can create my local maven

00:06:30,509 --> 00:06:37,590
repository and upload it into the image

00:06:34,470 --> 00:06:39,479
itself this will save time by which when

00:06:37,590 --> 00:06:41,580
the image is being built it will not

00:06:39,479 --> 00:06:43,199
download the maven every time into the

00:06:41,580 --> 00:06:45,120
image so that's some of the patterns

00:06:43,199 --> 00:06:50,370
that you can see how it can make your

00:06:45,120 --> 00:06:53,460
image a bit more efficient now this is

00:06:50,370 --> 00:06:56,010
first from statement in a darker file

00:06:53,460 --> 00:06:57,930
you can have multiple from statements

00:06:56,010 --> 00:07:00,090
and those are called as a multi-stage

00:06:57,930 --> 00:07:04,080
darker file so for example in this case

00:07:00,090 --> 00:07:06,840
my first from statement is maven and I'm

00:07:04,080 --> 00:07:09,900
calling it as a build stage okay now the

00:07:06,840 --> 00:07:13,409
second statement is from where I have

00:07:09,900 --> 00:07:15,990
open JDK 8 JRE slim as the base image

00:07:13,409 --> 00:07:19,889
and in this case what I'm doing is I'm

00:07:15,990 --> 00:07:22,530
saying from the build stage copy my jar

00:07:19,889 --> 00:07:24,479
file that was built into the second

00:07:22,530 --> 00:07:27,870
stage this is a very important step

00:07:24,479 --> 00:07:30,599
because you don't want to have all the

00:07:27,870 --> 00:07:32,940
classes all the jar files everything

00:07:30,599 --> 00:07:35,460
that may when downloaded to be included

00:07:32,940 --> 00:07:37,830
in your eventual image which is the

00:07:35,460 --> 00:07:40,409
final image so what you do is you just

00:07:37,830 --> 00:07:42,330
copy the target directory because that's

00:07:40,409 --> 00:07:45,120
exactly where everything is going to

00:07:42,330 --> 00:07:46,949
live you copy that and then you set up

00:07:45,120 --> 00:07:48,419
your java options which would be very

00:07:46,949 --> 00:07:50,250
useful if you were to debug the

00:07:48,419 --> 00:07:52,349
application using your IDE of your

00:07:50,250 --> 00:07:55,409
choice and then you fire up your

00:07:52,349 --> 00:07:58,229
application so basically you took the

00:07:55,409 --> 00:08:00,570
exact same java application and using a

00:07:58,229 --> 00:08:02,279
multi-stage dockerfile you have

00:08:00,570 --> 00:08:04,620
downloaded maven and you have used the

00:08:02,279 --> 00:08:07,080
JDK slim or JRE slim as a base

00:08:04,620 --> 00:08:13,650
image and created a new docker image for

00:08:07,080 --> 00:08:16,320
you now one of the tools that was

00:08:13,650 --> 00:08:19,470
introduced in jelly canine or other two

00:08:16,320 --> 00:08:22,350
tools they are called as J link and J

00:08:19,470 --> 00:08:24,300
depths and because Jerry canine kind of

00:08:22,350 --> 00:08:24,930
fundamentally change how the JDK itself

00:08:24,300 --> 00:08:27,330
is built

00:08:24,930 --> 00:08:30,570
so what J depths does is it takes a look

00:08:27,330 --> 00:08:33,089
at your application and it says give me

00:08:30,570 --> 00:08:35,099
the list of modules that your

00:08:33,089 --> 00:08:37,789
application depends upon okay so if you

00:08:35,099 --> 00:08:37,789
go down here

00:08:44,339 --> 00:08:53,959
so what I've done is I've created my war

00:08:47,310 --> 00:08:59,279
file I rename it to a jar file now on my

00:08:53,959 --> 00:09:02,850
jar file I'm saying run J dips okay so

00:08:59,279 --> 00:09:05,209
take the target slash AB dot jar print

00:09:02,850 --> 00:09:07,379
all the module that it depends upon

00:09:05,209 --> 00:09:09,749
because I don't want to include

00:09:07,379 --> 00:09:13,290
everything that is included as part of

00:09:09,749 --> 00:09:16,199
JDK as part of my JRE what I'm doing

00:09:13,290 --> 00:09:21,689
here is essentially creating a custom

00:09:16,199 --> 00:09:23,819
JRE so with this custom GRE it gives me

00:09:21,689 --> 00:09:25,769
the ability to print my custom modules

00:09:23,819 --> 00:09:28,110
and these are the modules that are

00:09:25,769 --> 00:09:31,620
required by spring boot as well so now

00:09:28,110 --> 00:09:35,240
what I'm doing is I have the list of all

00:09:31,620 --> 00:09:38,490
the modules that are specified by this

00:09:35,240 --> 00:09:41,490
then I'm using the tool J link saying

00:09:38,490 --> 00:09:45,990
add all the modules and create my custom

00:09:41,490 --> 00:09:48,059
JRE so up until JDK 8 there was a

00:09:45,990 --> 00:09:51,329
standard Gerry that was being shipped

00:09:48,059 --> 00:09:54,050
with Java but starting JDK 9 you have to

00:09:51,329 --> 00:09:57,480
build your custom jewelry so instead of

00:09:54,050 --> 00:09:59,129
building the entire JDK or the JRE now

00:09:57,480 --> 00:10:00,990
you're building a custom GRE which is

00:09:59,129 --> 00:10:03,059
very specific to your application and

00:10:00,990 --> 00:10:07,339
then using that as the base image

00:10:03,059 --> 00:10:07,339
essentially so if I go back here

00:10:10,820 --> 00:10:14,620
if I go to my application now

00:10:19,110 --> 00:10:25,709
and if I look at say dockerfile dorje re

00:10:21,390 --> 00:10:29,459
here so all I'm doing is I'm just saying

00:10:25,709 --> 00:10:31,820
debian 9 slim as a base image then I'm

00:10:29,459 --> 00:10:34,080
copying app dot war into the root

00:10:31,820 --> 00:10:36,630
copying the custom jewelry that was

00:10:34,080 --> 00:10:37,500
generated for me and that's it from

00:10:36,630 --> 00:10:40,800
there Jerry

00:10:37,500 --> 00:10:43,500
is where my JVM is being available and

00:10:40,800 --> 00:10:45,899
I'm using that JVM to spin up my

00:10:43,500 --> 00:10:47,579
application so it's a lot smaller darker

00:10:45,899 --> 00:10:50,370
image and as we talked about that is

00:10:47,579 --> 00:10:51,899
super important particularly because you

00:10:50,370 --> 00:10:53,970
know in a micro-services environment you

00:10:51,899 --> 00:10:55,649
want the darker image to be small so

00:10:53,970 --> 00:10:57,839
that in case it needs to be downloaded

00:10:55,649 --> 00:11:02,310
and of communities host it's easier to

00:10:57,839 --> 00:11:03,959
download another tool that is very

00:11:02,310 --> 00:11:06,149
important particularly from a Java

00:11:03,959 --> 00:11:09,240
developer perspective is and that I want

00:11:06,149 --> 00:11:11,730
to highlight here is if you look at the

00:11:09,240 --> 00:11:16,500
Palm D'Or XML it's called as a jib

00:11:11,730 --> 00:11:19,529
plugin now in my maven pom.xml I have a

00:11:16,500 --> 00:11:22,649
jib profile and I'm using the jib maven

00:11:19,529 --> 00:11:25,110
plugin this is version 1.1.2 and this

00:11:22,649 --> 00:11:28,560
plugin can us fits seamlessly with your

00:11:25,110 --> 00:11:30,690
entire pound or XML flow so what you do

00:11:28,560 --> 00:11:33,029
is you define a profile here now when

00:11:30,690 --> 00:11:35,490
you say maven package and if you specify

00:11:33,029 --> 00:11:37,770
this profile it will actually generate a

00:11:35,490 --> 00:11:41,070
darker image for you and this particular

00:11:37,770 --> 00:11:44,279
tool is particularly useful because in

00:11:41,070 --> 00:11:46,620
this case thing for your spring

00:11:44,279 --> 00:11:48,390
application in spring application how

00:11:46,620 --> 00:11:50,970
many times your dependencies change

00:11:48,390 --> 00:11:53,430
versus your application change so what

00:11:50,970 --> 00:11:55,980
it does it it says I'm gonna make the

00:11:53,430 --> 00:11:58,950
dependency as an extra layer in darker

00:11:55,980 --> 00:12:01,200
image and the application as an extra

00:11:58,950 --> 00:12:03,449
layer in darker image now if you take a

00:12:01,200 --> 00:12:05,490
step back the way your darker image is

00:12:03,449 --> 00:12:08,550
created is a bunch of layers altogether

00:12:05,490 --> 00:12:11,070
and if only a single layer is changed

00:12:08,550 --> 00:12:12,750
and when your image needs to be the new

00:12:11,070 --> 00:12:15,899
image needs to be downloaded it will

00:12:12,750 --> 00:12:18,529
download only that single layer so by

00:12:15,899 --> 00:12:22,019
splitting a spring boot application into

00:12:18,529 --> 00:12:24,990
dependencies and application and other

00:12:22,019 --> 00:12:27,240
dependencies it makes it easy for you to

00:12:24,990 --> 00:12:29,370
download only that specific layer so

00:12:27,240 --> 00:12:30,930
essentially your dependencies which may

00:12:29,370 --> 00:12:31,770
not have changed it will not download

00:12:30,930 --> 00:12:33,450
them

00:12:31,770 --> 00:12:35,130
but it will download only the

00:12:33,450 --> 00:12:37,560
application layer that has changed for

00:12:35,130 --> 00:12:40,410
you so what I'm doing here is I'm in

00:12:37,560 --> 00:12:42,570
this maven plug-in I'm saying use JRE

00:12:40,410 --> 00:12:44,610
slim as the base image and everything

00:12:42,570 --> 00:12:48,420
that I specified in my darker file is

00:12:44,610 --> 00:12:51,240
now being specified here so same image

00:12:48,420 --> 00:12:52,280
size but a little bit more optimized for

00:12:51,240 --> 00:12:56,330
your Java development environment

00:12:52,280 --> 00:12:56,330
particularly for a spring developer

00:13:09,170 --> 00:13:15,480
so now you have a basic darker image

00:13:13,110 --> 00:13:17,130
ready for you okay now you need to

00:13:15,480 --> 00:13:19,500
convert that darker image so that it can

00:13:17,130 --> 00:13:20,700
be understood by kubernetes so that's

00:13:19,500 --> 00:13:22,740
where you know you can start learning

00:13:20,700 --> 00:13:23,880
about the kubernetes terminology you

00:13:22,740 --> 00:13:26,940
need to understand that the basic

00:13:23,880 --> 00:13:30,150
terminology in kubernetes is a pod

00:13:26,940 --> 00:13:32,460
so you deploy a pod now pod is not

00:13:30,150 --> 00:13:35,390
something that you deploy by itself so

00:13:32,460 --> 00:13:38,280
pod is typically done by a deployment

00:13:35,390 --> 00:13:40,290
because in deployment is a declarative

00:13:38,280 --> 00:13:42,710
way of saying what the pod needs to have

00:13:40,290 --> 00:13:45,650
and how many replicas it needs to have

00:13:42,710 --> 00:13:48,780
so what you say is take this deployment

00:13:45,650 --> 00:13:51,270
the deployment will create the pod the

00:13:48,780 --> 00:13:53,340
pod will have the container and how many

00:13:51,270 --> 00:13:55,880
replicas of the part that you want and

00:13:53,340 --> 00:13:58,770
all of those are essentially your

00:13:55,880 --> 00:14:00,240
resource descriptions in kubernetes that

00:13:58,770 --> 00:14:01,740
you need to create so you need to

00:14:00,240 --> 00:14:03,270
understand what the schema looks like

00:14:01,740 --> 00:14:05,450
and then essentially create your

00:14:03,270 --> 00:14:09,240
resource description accordingly now

00:14:05,450 --> 00:14:11,640
just creating a pod and a deployment may

00:14:09,240 --> 00:14:13,860
not be sufficient because all of those

00:14:11,640 --> 00:14:17,190
so the pod and the deployment they're

00:14:13,860 --> 00:14:20,280
given IP address but that IP address is

00:14:17,190 --> 00:14:22,560
not accessible outside the cluster so

00:14:20,280 --> 00:14:25,080
what you end up doing is you also create

00:14:22,560 --> 00:14:27,210
a service description and that service

00:14:25,080 --> 00:14:29,400
description depending upon how you write

00:14:27,210 --> 00:14:32,700
the service description is accessible

00:14:29,400 --> 00:14:34,050
inside or outside the cluster okay so

00:14:32,700 --> 00:14:36,330
the three basic concepts that you need

00:14:34,050 --> 00:14:38,970
to understand it is a part a deployment

00:14:36,330 --> 00:14:40,890
and a service those are three resources

00:14:38,970 --> 00:14:44,820
that you need to create ok so let me

00:14:40,890 --> 00:14:50,670
show you how does that work really so if

00:14:44,820 --> 00:14:52,910
I go to the manifest directory here so I

00:14:50,670 --> 00:14:52,910
have

00:14:55,770 --> 00:15:03,240
app dot camel which is where all my app

00:15:00,070 --> 00:15:03,240
descriptions are available

00:15:09,190 --> 00:15:16,430
okay so now in this app this is sort of

00:15:14,779 --> 00:15:17,899
how my kubernetes manifest looks like so

00:15:16,430 --> 00:15:20,720
if you look at this on the line one I'm

00:15:17,899 --> 00:15:23,240
saying this is the app version 1 line 2

00:15:20,720 --> 00:15:27,350
I describe this is of a kind deployment

00:15:23,240 --> 00:15:29,959
I specify some metadata then in the spec

00:15:27,350 --> 00:15:32,329
which is a deployment spec I say 1

00:15:29,959 --> 00:15:35,870
replicas and this is one replica of the

00:15:32,329 --> 00:15:38,089
pot then I specify certain match labels

00:15:35,870 --> 00:15:39,860
that means this deployment will have the

00:15:38,089 --> 00:15:42,110
pod that are going to have these labels

00:15:39,860 --> 00:15:44,660
over there I keep going down over here

00:15:42,110 --> 00:15:47,450
this way I define my template for the

00:15:44,660 --> 00:15:49,910
deployment and this is my part spec

00:15:47,450 --> 00:15:52,730
essentially ok so this is sort of all

00:15:49,910 --> 00:15:55,610
what goes into the pod spec now I'm

00:15:52,730 --> 00:15:58,070
saying this pod has one container of the

00:15:55,610 --> 00:15:59,990
tied greeting and it has the image Arun

00:15:58,070 --> 00:16:05,779
Gupta slash greeting which is the image

00:15:59,990 --> 00:16:08,180
that we created earlier and this pod

00:16:05,779 --> 00:16:10,130
also has a label app colon greeting and

00:16:08,180 --> 00:16:11,930
the good thing is because this pod has

00:16:10,130 --> 00:16:15,019
these well what are labels labels is

00:16:11,930 --> 00:16:16,640
basically a key value pair so a key and

00:16:15,019 --> 00:16:18,740
a value you can pick them randomly

00:16:16,640 --> 00:16:21,800
whatever you want in this case I happen

00:16:18,740 --> 00:16:24,170
to choose app : greeting so the pod has

00:16:21,800 --> 00:16:26,089
these two label this one label app :

00:16:24,170 --> 00:16:28,820
greeting and in the deployment I'm

00:16:26,089 --> 00:16:33,649
saying match any part that has these

00:16:28,820 --> 00:16:36,110
labels ok the pod also expose a

00:16:33,649 --> 00:16:39,440
container port 8080 but that is only

00:16:36,110 --> 00:16:42,140
available in the part itself okay so my

00:16:39,440 --> 00:16:43,519
deployment has the pod spec so those are

00:16:42,140 --> 00:16:46,399
my two resources that I wanted to create

00:16:43,519 --> 00:16:49,490
earlier and now I also have a service in

00:16:46,399 --> 00:16:52,149
the service I'm giving the service has a

00:16:49,490 --> 00:16:55,940
selector and what the service is saying

00:16:52,149 --> 00:16:58,490
pick any pod that has this label on it

00:16:55,940 --> 00:17:01,670
so app : greeting which is again the

00:16:58,490 --> 00:17:03,560
same label that was on my pod created by

00:17:01,670 --> 00:17:06,439
the deployment so think about it this

00:17:03,560 --> 00:17:08,209
way from your perspective you had your

00:17:06,439 --> 00:17:11,720
java application the java application

00:17:08,209 --> 00:17:13,939
you converted into a docker image the

00:17:11,720 --> 00:17:17,270
docker image is what you've specified in

00:17:13,939 --> 00:17:20,360
your deployment spec and then you create

00:17:17,270 --> 00:17:21,390
a service on top of that and the way the

00:17:20,360 --> 00:17:24,150
service and the

00:17:21,390 --> 00:17:25,380
are correlated is using labels and it

00:17:24,150 --> 00:17:29,610
was a very loosely coupled architecture

00:17:25,380 --> 00:17:31,790
in that sense so now you have done a

00:17:29,610 --> 00:17:35,010
deployment and you have a service

00:17:31,790 --> 00:17:36,660
service is a standard IP address that is

00:17:35,010 --> 00:17:39,030
available to you that is accessible to

00:17:36,660 --> 00:17:41,490
you because pods are given IP address

00:17:39,030 --> 00:17:43,260
but if parts turbinate and if they come

00:17:41,490 --> 00:17:45,240
up on a different host of your

00:17:43,260 --> 00:17:46,890
kubernetes cluster may be given a

00:17:45,240 --> 00:17:49,020
different IP address that's not

00:17:46,890 --> 00:17:51,510
something that you can rely upon but

00:17:49,020 --> 00:17:54,299
service is given a standard IP address

00:17:51,510 --> 00:18:00,510
that is accessible and is fixed for the

00:17:54,299 --> 00:18:02,400
duration of the service in this case I'm

00:18:00,510 --> 00:18:04,470
also specifying a type as a load

00:18:02,400 --> 00:18:06,510
balancer and the advantage of that is

00:18:04,470 --> 00:18:08,520
depending upon where this service is

00:18:06,510 --> 00:18:11,370
deployed whether it's deployed on your

00:18:08,520 --> 00:18:13,590
local cluster or in the cloud cluster if

00:18:11,370 --> 00:18:15,540
it's deployed in a cloud cluster or say

00:18:13,590 --> 00:18:17,760
Amazon in that case so it will

00:18:15,540 --> 00:18:19,890
automatically instantiate an ELB for you

00:18:17,760 --> 00:18:23,669
so now the service is accessible to you

00:18:19,890 --> 00:18:27,270
over ELB ok so you have a service ready

00:18:23,669 --> 00:18:29,669
to go accessible on a ELB and a load

00:18:27,270 --> 00:18:31,890
balancer and then behind the scene you

00:18:29,669 --> 00:18:34,500
have a deployment and then you can scale

00:18:31,890 --> 00:18:36,809
the number of replicas up and down so

00:18:34,500 --> 00:18:38,730
every time you hit the service is going

00:18:36,809 --> 00:18:40,200
to pick one of the parts that is

00:18:38,730 --> 00:18:42,570
available as part of the deployment

00:18:40,200 --> 00:18:46,070
return that as a response back and that

00:18:42,570 --> 00:18:46,070
is the part that is serving your request

00:18:50,950 --> 00:18:55,170
now another part as you need to

00:18:52,660 --> 00:18:57,040
understand is as you are building your

00:18:55,170 --> 00:18:59,260
application which is micro services

00:18:57,040 --> 00:19:01,210
oriented typically you know your

00:18:59,260 --> 00:19:03,970
application will have a lot of micro

00:19:01,210 --> 00:19:06,850
services and each micro service in that

00:19:03,970 --> 00:19:09,220
sense will map to a deployment and a

00:19:06,850 --> 00:19:11,410
service so how do you manage all of

00:19:09,220 --> 00:19:13,780
these multiple deployments and services

00:19:11,410 --> 00:19:16,540
altogether well that's where the concept

00:19:13,780 --> 00:19:19,390
of help chart kicks in hem chart kind of

00:19:16,540 --> 00:19:20,800
defines on how your application needs to

00:19:19,390 --> 00:19:22,630
be defined it's sort of the standard way

00:19:20,800 --> 00:19:24,760
or the de facto way by which you define

00:19:22,630 --> 00:19:30,340
your kubernetes application so if I

00:19:24,760 --> 00:19:36,160
scroll down here a little bit actually

00:19:30,340 --> 00:19:41,200
in my manifest directory itself if I

00:19:36,160 --> 00:19:43,000
look at my app this directory is what

00:19:41,200 --> 00:19:45,130
indicates what a help chart looks like

00:19:43,000 --> 00:19:48,460
okay now this is using version 2 version

00:19:45,130 --> 00:19:49,990
3 is actively being developed and things

00:19:48,460 --> 00:19:53,040
are changing over there but at least for

00:19:49,990 --> 00:19:56,380
version 2 what you have is a top-level

00:19:53,040 --> 00:19:58,060
chart dot y amyl which basically defines

00:19:56,380 --> 00:19:59,830
you know the metadata about the

00:19:58,060 --> 00:20:02,080
application itself so you can say the

00:19:59,830 --> 00:20:03,340
API version the app version what the

00:20:02,080 --> 00:20:07,030
description of the helmet chart looks

00:20:03,340 --> 00:20:09,400
like then in the values 30ml you define

00:20:07,030 --> 00:20:12,280
certain values so think of this as your

00:20:09,400 --> 00:20:14,350
constants that can be used across your

00:20:12,280 --> 00:20:16,480
template files so if your application

00:20:14,350 --> 00:20:18,880
has multiple micro services that means

00:20:16,480 --> 00:20:20,770
it has multiple resource and multiple

00:20:18,880 --> 00:20:24,010
description deployments and services

00:20:20,770 --> 00:20:28,030
these values can be templatized over

00:20:24,010 --> 00:20:30,190
there in those description files so now

00:20:28,030 --> 00:20:31,690
if I go to my templates directory that's

00:20:30,190 --> 00:20:34,270
where all the magic happens essentially

00:20:31,690 --> 00:20:36,880
so here I have my greeting deployment

00:20:34,270 --> 00:20:40,420
and greeting service so if I look at my

00:20:36,880 --> 00:20:42,940
grading deployment essentially this

00:20:40,420 --> 00:20:45,040
looks very much like my deployment file

00:20:42,940 --> 00:20:46,870
that I saw earlier but now it's a lot

00:20:45,040 --> 00:20:49,720
more templatized because what I'm doing

00:20:46,870 --> 00:20:52,900
is I'm saying the metadata is the

00:20:49,720 --> 00:20:54,850
release name - greeting now this release

00:20:52,900 --> 00:20:58,570
name is the one that is defined in my

00:20:54,850 --> 00:21:01,150
values gamma already similarly I can say

00:20:58,570 --> 00:21:03,640
values not replicas count and the idea

00:21:01,150 --> 00:21:04,360
of whole idea over here is now you can

00:21:03,640 --> 00:21:06,130
have multiple

00:21:04,360 --> 00:21:09,370
deployment and a multiple service files

00:21:06,130 --> 00:21:11,170
and by using template language over

00:21:09,370 --> 00:21:13,600
there it gives you a standard mechanism

00:21:11,170 --> 00:21:16,870
on how you can access or how you can

00:21:13,600 --> 00:21:20,470
define these values rather so for

00:21:16,870 --> 00:21:24,070
example in my this is my deployment and

00:21:20,470 --> 00:21:27,730
in here I'm saying the part spec has

00:21:24,070 --> 00:21:31,559
released dot name - gridding now if I

00:21:27,730 --> 00:21:34,270
look at my grading service here in

00:21:31,559 --> 00:21:37,000
selector I'm saying the release dot name

00:21:34,270 --> 00:21:39,400
slash greeting so the chances of having

00:21:37,000 --> 00:21:41,140
a typo occurring is a lot less because

00:21:39,400 --> 00:21:43,390
what you're using is a standard template

00:21:41,140 --> 00:21:45,669
language and those values are again

00:21:43,390 --> 00:21:49,750
being specified in a single values or

00:21:45,669 --> 00:21:52,140
DML file for you so all that is fun now

00:21:49,750 --> 00:21:55,900
what I want to do is I want to actually

00:21:52,140 --> 00:21:57,460
deploy this helmet art and I want to

00:21:55,900 --> 00:21:59,710
test this application how do you test

00:21:57,460 --> 00:22:01,330
this application so then again you have

00:21:59,710 --> 00:22:03,250
multiple ways of spinning up a

00:22:01,330 --> 00:22:04,750
kubernetes cluster first of all on your

00:22:03,250 --> 00:22:06,070
local machine you know I want to test

00:22:04,750 --> 00:22:08,559
the kubernetes cluster in my local

00:22:06,070 --> 00:22:10,840
machine so a couple of options you can

00:22:08,559 --> 00:22:14,470
use docker for desktop so if you're

00:22:10,840 --> 00:22:18,130
using docker on Windows or Linux or on

00:22:14,470 --> 00:22:20,500
Mac at least on Windows and Mac you can

00:22:18,130 --> 00:22:22,809
enable kubernetes very easily so if you

00:22:20,500 --> 00:22:25,210
have darker running then you go to the

00:22:22,809 --> 00:22:28,150
preferences and say enable kubernetes

00:22:25,210 --> 00:22:30,400
and what that gives you is a single node

00:22:28,150 --> 00:22:32,590
kubernetes cluster that is running on

00:22:30,400 --> 00:22:34,540
your local machine so very easy to get

00:22:32,590 --> 00:22:37,660
started with and start playing with it

00:22:34,540 --> 00:22:39,490
well that's one option second option is

00:22:37,660 --> 00:22:41,169
to use mini cube so you can download

00:22:39,490 --> 00:22:44,080
mini cube which basically requires

00:22:41,169 --> 00:22:46,240
something like VirtualBox to spin up a

00:22:44,080 --> 00:22:46,780
single node kubernetes cluster for you

00:22:46,240 --> 00:22:49,000
as well

00:22:46,780 --> 00:22:51,610
but once you have either of those

00:22:49,000 --> 00:22:54,850
environments configured then you can

00:22:51,610 --> 00:22:56,710
install helm charge into that kubernetes

00:22:54,850 --> 00:22:59,679
cluster and you can start testing your

00:22:56,710 --> 00:23:02,530
application over there and the advantage

00:22:59,679 --> 00:23:05,260
is whatever works on a single node

00:23:02,530 --> 00:23:07,570
kubernetes cluster then you can migrate

00:23:05,260 --> 00:23:09,130
that application to in the cloud where

00:23:07,570 --> 00:23:12,840
you are possibly running a multi node

00:23:09,130 --> 00:23:12,840
kubernetes cluster okay

00:23:14,040 --> 00:23:18,340
now in terms of running a kubernetes

00:23:16,480 --> 00:23:20,500
cluster now there are several cloud

00:23:18,340 --> 00:23:23,500
providers well I work for Amazon so my

00:23:20,500 --> 00:23:27,310
preference is AWS and as a matter of

00:23:23,500 --> 00:23:30,450
fact more than 50% of kubernetes runs on

00:23:27,310 --> 00:23:34,000
AWS this is per the latest CN CF survey

00:23:30,450 --> 00:23:35,740
so all that matters is where you run

00:23:34,000 --> 00:23:38,290
your kubernetes because you need to have

00:23:35,740 --> 00:23:40,030
that wide variety of compute choices and

00:23:38,290 --> 00:23:43,120
the scalability and the resilience and

00:23:40,030 --> 00:23:45,970
the availability of all of that as part

00:23:43,120 --> 00:23:48,630
of their eks cluster so Amazon eks

00:23:45,970 --> 00:23:51,580
essentially is our our fully managed

00:23:48,630 --> 00:23:53,920
kubernetes service what it gives you is

00:23:51,580 --> 00:23:56,230
a control plane and then you bring your

00:23:53,920 --> 00:24:00,310
data plane and attach to it and that

00:23:56,230 --> 00:24:02,760
becomes your kubernetes cluster very

00:24:00,310 --> 00:24:05,650
easy way to get started with

00:24:02,760 --> 00:24:08,980
Amazon II cares you install this CL I

00:24:05,650 --> 00:24:11,730
call as brew install V works tap eks

00:24:08,980 --> 00:24:14,560
Caudill and then literally you can say e

00:24:11,730 --> 00:24:16,750
KS cuddle create cluster if I just give

00:24:14,560 --> 00:24:18,790
this command that will create our Amazon

00:24:16,750 --> 00:24:21,220
eks cluster for me now I've specified

00:24:18,790 --> 00:24:22,810
some values over here at the region and

00:24:21,220 --> 00:24:24,850
the number of nodes I want in the

00:24:22,810 --> 00:24:30,340
cluster but basically this will give me

00:24:24,850 --> 00:24:34,410
a for Lord Amazon eks cluster and if I

00:24:30,340 --> 00:24:34,410
go to my terminal here

00:24:39,670 --> 00:24:49,020
so now if I say cube cuddle config get

00:24:45,820 --> 00:24:49,020
context it shows

00:24:52,740 --> 00:24:57,480
I have multiple clusters running in the

00:24:55,230 --> 00:24:59,249
cloud okay so at any given point of time

00:24:57,480 --> 00:25:01,799
so if you look at this for example I

00:24:59,249 --> 00:25:04,049
have a mini cube cluster running I have

00:25:01,799 --> 00:25:05,789
two darker desktop clusters running and

00:25:04,049 --> 00:25:09,119
I have a few clusters running up in the

00:25:05,789 --> 00:25:10,970
cloud now once I have this application

00:25:09,119 --> 00:25:13,230
running on my local environment

00:25:10,970 --> 00:25:14,940
switching that application to

00:25:13,230 --> 00:25:15,600
environment the cluster is pretty

00:25:14,940 --> 00:25:18,240
straightforward

00:25:15,600 --> 00:25:23,190
so for example right now I am running

00:25:18,240 --> 00:25:25,679
this I'm running this on a GPU based

00:25:23,190 --> 00:25:27,299
cluster and if you see current it says

00:25:25,679 --> 00:25:30,679
that is the current cluster over there

00:25:27,299 --> 00:25:34,740
okay so I can say a cube Caudill config

00:25:30,679 --> 00:25:39,830
use context and I can pick a different

00:25:34,740 --> 00:25:40,980
cluster say I pick this cluster here

00:25:39,830 --> 00:25:43,200
okay

00:25:40,980 --> 00:25:45,990
now the context switch to that and if I

00:25:43,200 --> 00:25:47,190
say a cue card I'll get nodes it will

00:25:45,990 --> 00:25:49,379
show me the number of nodes that are

00:25:47,190 --> 00:25:51,960
available in that cluster so really all

00:25:49,379 --> 00:25:54,840
you need to do is just switch your

00:25:51,960 --> 00:25:56,789
context from the cluster that is running

00:25:54,840 --> 00:25:57,809
on the desktop to the cluster that is

00:25:56,789 --> 00:25:59,639
running in the cloud

00:25:57,809 --> 00:26:01,379
and then just redeploy the application

00:25:59,639 --> 00:26:04,279
and that is R as the recommended

00:26:01,379 --> 00:26:04,279
methodology as well

00:26:19,360 --> 00:26:26,290
so that's sort of the way you migrate

00:26:21,250 --> 00:26:27,910
from death to prod now one of the common

00:26:26,290 --> 00:26:31,030
things that you need from your

00:26:27,910 --> 00:26:33,460
applications is you want to use the

00:26:31,030 --> 00:26:35,140
right language for the right tool so you

00:26:33,460 --> 00:26:37,630
may be using Java you may be using node

00:26:35,140 --> 00:26:39,700
you may be using go so a wide variety of

00:26:37,630 --> 00:26:41,350
languages because end of the day what

00:26:39,700 --> 00:26:42,640
are these are micro services which are

00:26:41,350 --> 00:26:46,480
raised basically talking to each other

00:26:42,640 --> 00:26:48,850
using api's so the important part is now

00:26:46,480 --> 00:26:50,740
you want to get observability into those

00:26:48,850 --> 00:26:54,130
micro services so how do you get

00:26:50,740 --> 00:26:57,280
observability well the if you start

00:26:54,130 --> 00:27:00,280
doing the libraries for each specific

00:26:57,280 --> 00:27:02,770
language the java and load and go it

00:27:00,280 --> 00:27:04,060
quickly becomes a framework explosion

00:27:02,770 --> 00:27:05,770
because then we need to start

00:27:04,060 --> 00:27:08,140
maintaining different versions of these

00:27:05,770 --> 00:27:10,210
libraries then your application becomes

00:27:08,140 --> 00:27:11,890
cluttered so one of the common design

00:27:10,210 --> 00:27:15,280
patterns that we have seen in the real

00:27:11,890 --> 00:27:18,250
world is where customers use envoy as a

00:27:15,280 --> 00:27:20,260
proxy and on Y is a CNC F graduated

00:27:18,250 --> 00:27:23,410
project so we were happy to support it

00:27:20,260 --> 00:27:26,530
so customers what they do is if you

00:27:23,410 --> 00:27:29,020
think about pod pod has one container

00:27:26,530 --> 00:27:31,150
which is your application container but

00:27:29,020 --> 00:27:34,960
what you can do is in the pod you can

00:27:31,150 --> 00:27:36,550
have a sidecar container which is sort

00:27:34,960 --> 00:27:39,100
of sitting along with the main

00:27:36,550 --> 00:27:41,380
application container but now the

00:27:39,100 --> 00:27:44,080
sidecar container and the application

00:27:41,380 --> 00:27:47,380
container can talk to each other as if

00:27:44,080 --> 00:27:49,200
they are part on the same localhost so

00:27:47,380 --> 00:27:51,730
what essentially happens is any

00:27:49,200 --> 00:27:55,210
communication between the application

00:27:51,730 --> 00:27:57,910
containers across the pod doesn't happen

00:27:55,210 --> 00:27:59,950
directly it always happens through the

00:27:57,910 --> 00:28:02,170
sidecar and so if you think in terms of

00:27:59,950 --> 00:28:05,080
the logic the application container

00:28:02,170 --> 00:28:07,090
talks to the sidecar container the

00:28:05,080 --> 00:28:08,830
sidecar container then looks at the

00:28:07,090 --> 00:28:10,960
policies that are being enforced at that

00:28:08,830 --> 00:28:12,880
point of time and then it talks to the

00:28:10,960 --> 00:28:14,460
other side card container which then

00:28:12,880 --> 00:28:18,310
talks to the application container and

00:28:14,460 --> 00:28:21,820
because all the network traffic is going

00:28:18,310 --> 00:28:23,950
through the sidecar it makes you to

00:28:21,820 --> 00:28:26,430
allow some more observability in your

00:28:23,950 --> 00:28:26,430
application

00:28:29,770 --> 00:28:37,100
so with on why being the basis for your

00:28:34,250 --> 00:28:39,679
network traffic you can do a lot of fun

00:28:37,100 --> 00:28:43,910
things with it you can start doing

00:28:39,679 --> 00:28:47,480
things like canary deployment so you can

00:28:43,910 --> 00:28:49,160
say that now my servers on one of the

00:28:47,480 --> 00:28:51,620
service is running I want to introduce

00:28:49,160 --> 00:28:53,630
version two and then when I introduce

00:28:51,620 --> 00:28:56,330
the version two I only want to guide the

00:28:53,630 --> 00:28:58,549
traffic to five percent of the users or

00:28:56,330 --> 00:29:00,679
maybe the users who are coming from a

00:28:58,549 --> 00:29:02,000
certain geography only so you can start

00:29:00,679 --> 00:29:04,429
kind of narrowing the traffic to a

00:29:02,000 --> 00:29:06,710
particular part of the world okay now

00:29:04,429 --> 00:29:08,840
that is not entirely possible if you're

00:29:06,710 --> 00:29:10,400
using raw kubernetes and that's where

00:29:08,840 --> 00:29:13,070
service measures are becoming extremely

00:29:10,400 --> 00:29:13,910
popular so essentially with unwise

00:29:13,070 --> 00:29:16,210
sidecar

00:29:13,910 --> 00:29:21,250
what you're doing is you're running

00:29:16,210 --> 00:29:21,250
sidecar across all of your applications

00:29:29,630 --> 00:29:36,570
you're running on way across all of your

00:29:33,210 --> 00:29:39,180
applications so what you need is a data

00:29:36,570 --> 00:29:41,790
plane on top of it which manages all of

00:29:39,180 --> 00:29:44,850
those sidecar containers and that's

00:29:41,790 --> 00:29:47,400
where things like Sto or AWS app mesh

00:29:44,850 --> 00:29:49,440
comes in now sto works very well on

00:29:47,400 --> 00:29:51,090
Amazon he cares if you were to use it

00:29:49,440 --> 00:29:53,970
sure no no we support it I actually

00:29:51,090 --> 00:29:58,050
wrote the blog post on that on how is T

00:29:53,970 --> 00:29:59,460
runs on Amazon ETS but AWS at mesh is a

00:29:58,050 --> 00:30:04,080
fully managed service that we provide

00:29:59,460 --> 00:30:05,970
from Amazon as well so in this case I'm

00:30:04,080 --> 00:30:08,250
walking you through on how easy it is to

00:30:05,970 --> 00:30:12,110
get started with App mesh particularly

00:30:08,250 --> 00:30:12,110
if you're using for Amazon II cares

00:30:12,560 --> 00:30:17,940
excuse me

00:30:15,440 --> 00:30:19,650
so it walks you through that how do you

00:30:17,940 --> 00:30:21,720
set up the iam permissions how do you

00:30:19,650 --> 00:30:23,580
configure the app mesh so essentially

00:30:21,720 --> 00:30:26,460
what I'm doing is I'm a neighboring an

00:30:23,580 --> 00:30:28,560
aim space that anytime you deploy an

00:30:26,460 --> 00:30:31,140
application into that namespace it'll

00:30:28,560 --> 00:30:34,320
automatically inject the unwise sidecar

00:30:31,140 --> 00:30:37,020
for you so it walks you through the

00:30:34,320 --> 00:30:38,280
entire process then just like you know

00:30:37,020 --> 00:30:39,690
what you're doing is you know you're

00:30:38,280 --> 00:30:41,700
deploying your application into the

00:30:39,690 --> 00:30:45,780
kubernetes cluster you need to deploy

00:30:41,700 --> 00:30:46,890
certain app mesh specific constructs so

00:30:45,780 --> 00:30:48,720
things like you know you need to create

00:30:46,890 --> 00:30:51,420
a mesh you need to create virtual node

00:30:48,720 --> 00:30:54,330
services and deployments and then you

00:30:51,420 --> 00:30:55,620
can start doing traffic shifting so

00:30:54,330 --> 00:30:57,870
traffic shifting is the concept that

00:30:55,620 --> 00:31:00,030
where you are saying I'm introducing a

00:30:57,870 --> 00:31:03,540
new version of the application and guide

00:31:00,030 --> 00:31:06,690
only 5% of the traffic to a certain type

00:31:03,540 --> 00:31:09,030
of users so you could say if the users

00:31:06,690 --> 00:31:11,340
have a particular cookie set then guide

00:31:09,030 --> 00:31:12,480
the traffic to them or if the user is

00:31:11,340 --> 00:31:15,390
coming from a certain part of the

00:31:12,480 --> 00:31:17,850
geography or I don't care of the entire

00:31:15,390 --> 00:31:19,590
set of deployment guide only five

00:31:17,850 --> 00:31:21,150
percent of the traffic to the new

00:31:19,590 --> 00:31:23,160
service so all those things can be

00:31:21,150 --> 00:31:26,250
magically done using these deployment

00:31:23,160 --> 00:31:27,870
descriptors over here and then there are

00:31:26,250 --> 00:31:32,460
full details about how you can do that

00:31:27,870 --> 00:31:34,080
using is to you as well now the last

00:31:32,460 --> 00:31:36,360
part that I want to talk about over here

00:31:34,080 --> 00:31:40,640
is how easy it is to get started with

00:31:36,360 --> 00:31:40,640
say deployment pipelines

00:31:42,299 --> 00:31:47,110
scaffold is a tool that is available in

00:31:45,070 --> 00:31:48,850
the open source now typically what you

00:31:47,110 --> 00:31:51,190
do is as part of your development

00:31:48,850 --> 00:31:54,490
experience you want to get started with

00:31:51,190 --> 00:31:56,950
that as soon as I make a change in my

00:31:54,490 --> 00:31:58,570
source code somebody should compile it

00:31:56,950 --> 00:31:59,139
somebody should build a docker image out

00:31:58,570 --> 00:32:02,049
of it

00:31:59,139 --> 00:32:03,789
update the docker Kuban it is manifest

00:32:02,049 --> 00:32:05,679
and redeploy the application to my

00:32:03,789 --> 00:32:07,480
kubernetes cluster and this is all

00:32:05,679 --> 00:32:09,580
happening in your local development

00:32:07,480 --> 00:32:11,620
environment that is exactly what

00:32:09,580 --> 00:32:13,330
scaffold is used for and also

00:32:11,620 --> 00:32:15,309
essentially what you have is you

00:32:13,330 --> 00:32:17,200
download scaffold you setup your

00:32:15,309 --> 00:32:19,720
configuration using a scaffold or camel

00:32:17,200 --> 00:32:22,509
and it heavily relies upon convention

00:32:19,720 --> 00:32:24,820
over configuration so you put your files

00:32:22,509 --> 00:32:26,950
in a specific location it picks them up

00:32:24,820 --> 00:32:29,440
and sets up your build environment where

00:32:26,950 --> 00:32:30,580
is constantly deploying files so as soon

00:32:29,440 --> 00:32:32,980
as in your IDE

00:32:30,580 --> 00:32:36,070
if you make a change you save it it

00:32:32,980 --> 00:32:37,809
triggers the entire build cycle and your

00:32:36,070 --> 00:32:40,149
application is automatically deployed to

00:32:37,809 --> 00:32:42,190
the cluster it's very good for iterative

00:32:40,149 --> 00:32:45,129
feedback and right away the field that

00:32:42,190 --> 00:32:47,980
you get back now that's one part of it

00:32:45,129 --> 00:32:49,899
that is good for local development now

00:32:47,980 --> 00:32:52,509
when you're going into the cloud that's

00:32:49,899 --> 00:32:54,909
where you need a full-blown deployment

00:32:52,509 --> 00:32:56,289
pipeline of course Jenkins is a good

00:32:54,909 --> 00:32:58,809
solution and a lot of our customers use

00:32:56,289 --> 00:33:01,059
it but a lot of the time customers also

00:32:58,809 --> 00:33:03,399
want something that is fully managed and

00:33:01,059 --> 00:33:07,210
that's exactly where AWS code pipeline

00:33:03,399 --> 00:33:09,580
kind of comes in so this section kind of

00:33:07,210 --> 00:33:09,730
walks you through how easy it is to set

00:33:09,580 --> 00:33:12,850
up

00:33:09,730 --> 00:33:14,830
AWS quote pipeline based deployment

00:33:12,850 --> 00:33:17,559
pipeline up in the cloud it's a fully

00:33:14,830 --> 00:33:19,539
managed service so there's nothing you

00:33:17,559 --> 00:33:22,240
need to download or manage on your local

00:33:19,539 --> 00:33:24,639
machine and once AWS called pipeline is

00:33:22,240 --> 00:33:27,789
set up once again every time you make a

00:33:24,639 --> 00:33:29,649
change you know you do a good push it

00:33:27,789 --> 00:33:31,360
triggers the entire development pipeline

00:33:29,649 --> 00:33:32,769
or a deployment pipeline up in the cloud

00:33:31,360 --> 00:33:35,559
and guides you through the entire

00:33:32,769 --> 00:33:39,039
process okay so you need to set up your

00:33:35,559 --> 00:33:42,039
github token setup here I am roll

00:33:39,039 --> 00:33:44,049
cluster name and then what you see is

00:33:42,039 --> 00:33:45,850
how the code pipeline looks like so it

00:33:44,049 --> 00:33:48,429
says here's my source it is my build

00:33:45,850 --> 00:33:49,450
what's being billed and then it walks

00:33:48,429 --> 00:33:51,970
you through the entire deployment

00:33:49,450 --> 00:33:53,840
pipeline and then of course you can see

00:33:51,970 --> 00:33:56,750
the instructions for Jenkins X as well

00:33:53,840 --> 00:34:00,140
so let's go back through the entire

00:33:56,750 --> 00:34:01,970
lifecycle on how it would look like on

00:34:00,140 --> 00:34:04,640
if you were to building your application

00:34:01,970 --> 00:34:07,070
from a Java developer perspective first

00:34:04,640 --> 00:34:10,130
thing is make sure you choose your base

00:34:07,070 --> 00:34:11,960
image wisely choose your tools wisely

00:34:10,130 --> 00:34:14,600
are you using a multi-stage darker file

00:34:11,960 --> 00:34:17,240
or a maven plug-in or a Gradle plugin

00:34:14,600 --> 00:34:19,190
there are lots of options make sure to

00:34:17,240 --> 00:34:22,070
leverage the custom JRE that is

00:34:19,190 --> 00:34:23,360
available JDK 9 onwards on how you can

00:34:22,070 --> 00:34:25,520
use that that those are some of the

00:34:23,360 --> 00:34:27,560
things you need to look at when then you

00:34:25,520 --> 00:34:30,080
convert that darker image into a

00:34:27,560 --> 00:34:32,300
kubernetes manifest file you can test

00:34:30,080 --> 00:34:34,280
that on your local machine docker for

00:34:32,300 --> 00:34:36,770
desktop and a mini cube lots of

00:34:34,280 --> 00:34:38,390
different options over there then as you

00:34:36,770 --> 00:34:41,120
are migrating those applications to the

00:34:38,390 --> 00:34:43,460
cloud consider Amazon eks you know this

00:34:41,120 --> 00:34:46,460
is a managed service up in the cloud you

00:34:43,460 --> 00:34:48,980
click no eks cuttle create cluster gives

00:34:46,460 --> 00:34:50,570
you Amazon eks cluster switch the

00:34:48,980 --> 00:34:52,610
context and then you migrate your

00:34:50,570 --> 00:34:54,770
application over there then you start

00:34:52,610 --> 00:34:56,540
looking at ok how do I get observability

00:34:54,770 --> 00:34:58,400
into my application because a lot of

00:34:56,540 --> 00:35:00,500
these services are running that's where

00:34:58,400 --> 00:35:02,480
your service mesh comes in and then last

00:35:00,500 --> 00:35:04,040
but not the least think about what are

00:35:02,480 --> 00:35:05,780
your deployment pipelines looking like

00:35:04,040 --> 00:35:08,300
so there are certain steps you need to

00:35:05,780 --> 00:35:10,310
think about it hopefully this repo helps

00:35:08,300 --> 00:35:12,980
you get started and once again as I said

00:35:10,310 --> 00:35:14,480
all the code is here if anything is

00:35:12,980 --> 00:35:16,610
missing from this I would encourage

00:35:14,480 --> 00:35:18,650
filing issues or send me a pull request

00:35:16,610 --> 00:35:20,960
I'm going to be around rest of the day

00:35:18,650 --> 00:35:22,590
at the AWS booth and would love to talk

00:35:20,960 --> 00:35:28,050
thank you so much

00:35:22,590 --> 00:35:28,050

YouTube URL: https://www.youtube.com/watch?v=xtbCIAQvBE8


