Title: Why is Cloud-Native Application Development Still So Hard? - Irene Zhang & Venugopal Reddy
Publication date: 2019-07-10
Playlist: Shanghai '19: KubeCon + CloudNativeCon + Open Source Summit
Description: 
	Why is Cloud-Native Application Development Still So Hard? - Irene Zhang, Microsoft Research & University of Washington & Venugopal Reddy, Huawei 

Creating reliable, scalable, distributed cloud-native applications is still way too difficult for us mere mortal application developers. Why must we understand and solve complex distributed systems problems like data consistency, shard balancing, consensus algorithms, network partitions and exponential backoff just to build a straightforward business or social media app? Given that new real-world applications now also run across intermittently connected mobile devices, hybrid cloud servers, edge nodes, IoT devices etc, the problem is rapidly becoming even more difficult, to a point of being practically impossible.  Surely we can do much better than this?  Quinton and Irene will describe some of the recent advances in distributed systems R&D, and an open source distributed cloud operating system their groups have been collaborating on, that might just provide a way forward. 

https://sched.co/Nrlc
Captions: 
	00:00:00,089 --> 00:00:05,009
but afternoon everyone thanks for being

00:00:02,250 --> 00:00:06,990
here my name is Pinot and Emily

00:00:05,009 --> 00:00:10,769
decrypted huawei I am here with my

00:00:06,990 --> 00:00:12,990
co-speaker Irene she is a researcher at

00:00:10,769 --> 00:00:14,969
Microsoft and holds a PhD in distributed

00:00:12,990 --> 00:00:16,740
systems and I would like to mention

00:00:14,969 --> 00:00:19,529
about my colleague Quinton hole who has

00:00:16,740 --> 00:00:21,830
envisioned that this project and thought

00:00:19,529 --> 00:00:23,550
that it would be worth outsourcing it

00:00:21,830 --> 00:00:26,430
unfortunately he couldn't make it to

00:00:23,550 --> 00:00:30,330
this event due to some reasons alright

00:00:26,430 --> 00:00:31,830
let's get started our team and Irene's

00:00:30,330 --> 00:00:33,300
group had been collaborating for the

00:00:31,830 --> 00:00:36,090
past few years and a pretty exciting

00:00:33,300 --> 00:00:38,370
project to take the research and she did

00:00:36,090 --> 00:00:40,530
in distributed systems for her PhD

00:00:38,370 --> 00:00:43,950
thesis and expanded into a full-fledged

00:00:40,530 --> 00:00:50,340
open-source project in C&C F we are here

00:00:43,950 --> 00:00:52,649
to talk about this project today in

00:00:50,340 --> 00:00:54,420
today's agenda will cover the brief

00:00:52,649 --> 00:00:57,390
history of evolution of applications

00:00:54,420 --> 00:01:00,300
nature of applications development from

00:00:57,390 --> 00:01:01,350
monolithic to micro services and the

00:01:00,300 --> 00:01:04,320
skill set required for application

00:01:01,350 --> 00:01:06,720
developers system developers a service a

00:01:04,320 --> 00:01:08,520
DevOps engineers note that the

00:01:06,720 --> 00:01:10,710
application developer I meant here is

00:01:08,520 --> 00:01:12,950
not a standard industry term I will talk

00:01:10,710 --> 00:01:15,119
about it when I get to that slide and

00:01:12,950 --> 00:01:16,830
then we'll briefly touch on a broader

00:01:15,119 --> 00:01:19,950
effort to create a full distributed

00:01:16,830 --> 00:01:21,630
operating system amino s and then zoom

00:01:19,950 --> 00:01:24,560
in to the most interesting part of it I

00:01:21,630 --> 00:01:26,850
mean or an micro-service runtime system

00:01:24,560 --> 00:01:29,460
Irene will describe the internals of how

00:01:26,850 --> 00:01:30,810
this amino runtime system works and show

00:01:29,460 --> 00:01:32,850
some interesting findings from her

00:01:30,810 --> 00:01:34,290
research and then I'll summarize with

00:01:32,850 --> 00:01:36,450
current ongoing work and show that they

00:01:34,290 --> 00:01:39,020
wore face recognition app running on the

00:01:36,450 --> 00:01:39,020
minnow runtime

00:01:43,719 --> 00:01:47,710
once upon a time applications that

00:01:45,939 --> 00:01:50,319
people interacted day-to-day were pretty

00:01:47,710 --> 00:01:52,750
simple they typically support single

00:01:50,319 --> 00:01:55,179
user ran on a single operating system

00:01:52,750 --> 00:01:58,590
and on a standalone machine they were

00:01:55,179 --> 00:02:03,340
things like text editor document viewers

00:01:58,590 --> 00:02:05,560
calendars and simple games life was good

00:02:03,340 --> 00:02:07,299
for application programmers single

00:02:05,560 --> 00:02:10,840
machine operating systems work fairly

00:02:07,299 --> 00:02:12,519
well Linux Windows Mac OS all of them

00:02:10,840 --> 00:02:14,769
provide a great layer of abstraction for

00:02:12,519 --> 00:02:16,329
application programming with the basic

00:02:14,769 --> 00:02:18,750
building blocks like local process

00:02:16,329 --> 00:02:21,640
virtual memory file system

00:02:18,750 --> 00:02:23,200
synchronization primitives and locks all

00:02:21,640 --> 00:02:25,060
of these are indispensable when writing

00:02:23,200 --> 00:02:27,730
an application for sing-sing single

00:02:25,060 --> 00:02:28,989
submission mostly one or two programming

00:02:27,730 --> 00:02:30,549
languages are required to build an

00:02:28,989 --> 00:02:32,769
application and the application

00:02:30,549 --> 00:02:36,549
programmers understand that platform

00:02:32,769 --> 00:02:37,420
pretty well but suddenly everything

00:02:36,549 --> 00:02:39,730
changed

00:02:37,420 --> 00:02:41,579
cloud computing happened everybody moved

00:02:39,730 --> 00:02:43,299
to smartphone mobile for strategies

00:02:41,579 --> 00:02:46,329
ubiquitous network connectivity

00:02:43,299 --> 00:02:48,819
high-speed Internet everywhere so the

00:02:46,329 --> 00:02:50,349
type of applications changed suddenly we

00:02:48,819 --> 00:02:55,480
have social media applications like

00:02:50,349 --> 00:02:57,130
Twitter Pinterest Facebook and in

00:02:55,480 --> 00:02:59,459
addition to that some of the previously

00:02:57,130 --> 00:03:01,810
existing applications with single user

00:02:59,459 --> 00:03:05,859
also became collaborative multi-user

00:03:01,810 --> 00:03:07,750
applications there are fairly some big

00:03:05,859 --> 00:03:10,090
differences with today's applications in

00:03:07,750 --> 00:03:13,829
the nature of application and the kind

00:03:10,090 --> 00:03:13,829
of application development we need to do

00:03:14,459 --> 00:03:20,889
firstly users share these applications

00:03:18,329 --> 00:03:24,910
so the application has to run on the

00:03:20,889 --> 00:03:27,190
number of servers in the cloud next

00:03:24,910 --> 00:03:29,349
users access these applications through

00:03:27,190 --> 00:03:33,310
mobile devices like cell phones and

00:03:29,349 --> 00:03:35,530
tablets so it means that applications

00:03:33,310 --> 00:03:37,750
need to have a mobile component cloud

00:03:35,530 --> 00:03:40,239
component sometimes a desktop component

00:03:37,750 --> 00:03:42,190
and increasingly sometimes edge

00:03:40,239 --> 00:03:43,810
components too in case of smart cities

00:03:42,190 --> 00:03:47,799
and autonomous systems autonomous

00:03:43,810 --> 00:03:49,510
vehicles and lastly these application

00:03:47,799 --> 00:03:52,359
need to coordinate across distributed

00:03:49,510 --> 00:03:56,699
components over the links that are

00:03:52,359 --> 00:03:56,699
sometimes flow are unreliable

00:03:57,000 --> 00:04:01,840
today even an aquarium at home can have

00:04:00,189 --> 00:04:03,810
a Raspberry Pi attached to it that

00:04:01,840 --> 00:04:07,299
controls the water level temperature

00:04:03,810 --> 00:04:08,680
feed and the chemicals all this being

00:04:07,299 --> 00:04:14,680
controlled through the software running

00:04:08,680 --> 00:04:16,060
in the cloud in summary all this adds up

00:04:14,680 --> 00:04:19,509
to some significant challenges for

00:04:16,060 --> 00:04:21,639
application programming they have to

00:04:19,509 --> 00:04:23,440
coordinate data and computation across

00:04:21,639 --> 00:04:25,150
distributed nodes they have to meet

00:04:23,440 --> 00:04:26,949
application requirements with guaranteed

00:04:25,150 --> 00:04:29,770
performance and limitations performance

00:04:26,949 --> 00:04:31,750
limitations and failures and they have

00:04:29,770 --> 00:04:33,820
to do all this across different

00:04:31,750 --> 00:04:35,740
programming environment and varying

00:04:33,820 --> 00:04:37,630
hardware resources which means

00:04:35,740 --> 00:04:41,349
application development is really very

00:04:37,630 --> 00:04:44,440
hard with multi-user multi program multi

00:04:41,349 --> 00:04:46,120
platform multi node etcetera this is one

00:04:44,440 --> 00:04:51,070
of the reason why cloud native computing

00:04:46,120 --> 00:04:52,780
foundation exists along came essentially

00:04:51,070 --> 00:04:53,800
cnc of containers kubernetes

00:04:52,780 --> 00:04:56,470
microservices

00:04:53,800 --> 00:04:59,410
etc most of you know well about the

00:04:56,470 --> 00:05:02,020
things on this slide things have

00:04:59,410 --> 00:05:04,590
certainly got better applications can be

00:05:02,020 --> 00:05:06,610
partitioned into deployable containers

00:05:04,590 --> 00:05:07,960
programmatically orchestrated and

00:05:06,610 --> 00:05:10,930
declarative configurations with

00:05:07,960 --> 00:05:14,050
kubernetes different language can be

00:05:10,930 --> 00:05:15,610
used in every single container and we

00:05:14,050 --> 00:05:19,330
can connect micro services with service

00:05:15,610 --> 00:05:21,130
measures like link ID sto etc a service

00:05:19,330 --> 00:05:26,830
can run these things in developers and

00:05:21,130 --> 00:05:28,930
develop them however the problem is

00:05:26,830 --> 00:05:31,449
somebody still got to write the code

00:05:28,930 --> 00:05:33,699
that runs in these containers and it

00:05:31,449 --> 00:05:36,580
turns out to be it is very difficult to

00:05:33,699 --> 00:05:39,210
do it reliably in a way that use the

00:05:36,580 --> 00:05:41,229
application properties that you want

00:05:39,210 --> 00:05:43,870
companies like Google and Amazon have

00:05:41,229 --> 00:05:45,669
been doing it for quite long but they do

00:05:43,870 --> 00:05:47,080
have somewhere around 100,000 pretty

00:05:45,669 --> 00:05:48,849
good software engineers spent and

00:05:47,080 --> 00:05:52,930
building this resilient and scalable

00:05:48,849 --> 00:05:54,789
systems problem is that a company that

00:05:52,930 --> 00:05:57,360
needs to build some end-user application

00:05:54,789 --> 00:06:00,720
doesn't necessary have thousands of

00:05:57,360 --> 00:06:03,099
distributed system software engineers ax

00:06:00,720 --> 00:06:05,710
kinds of problem people run into very

00:06:03,099 --> 00:06:08,950
frequently are things like distributed

00:06:05,710 --> 00:06:09,460
concurrency synchronization reliable

00:06:08,950 --> 00:06:11,650
artist

00:06:09,460 --> 00:06:13,690
how do you make available Network look

00:06:11,650 --> 00:06:18,100
like reliable reliable from remote

00:06:13,690 --> 00:06:20,770
procedure call point-of-view how do you

00:06:18,100 --> 00:06:23,650
handle the failures disconnections

00:06:20,770 --> 00:06:25,720
reconnections replication leader

00:06:23,650 --> 00:06:27,550
election sharding for horizontal scaling

00:06:25,720 --> 00:06:29,800
all of these are complex distributed

00:06:27,550 --> 00:06:32,650
system problems that we are forcing

00:06:29,800 --> 00:06:35,350
application developers to understand

00:06:32,650 --> 00:06:37,270
them and handle them some of these areas

00:06:35,350 --> 00:06:40,930
are partially fulfilled with things like

00:06:37,270 --> 00:06:42,940
service wishes but there isn't a single

00:06:40,930 --> 00:06:45,760
platform where you can sit down at and

00:06:42,940 --> 00:06:47,290
write a distributed application and know

00:06:45,760 --> 00:06:48,730
that you have got all the primitives you

00:06:47,290 --> 00:06:51,970
need in order to build a distributed

00:06:48,730 --> 00:06:53,440
application if you contrast this with

00:06:51,970 --> 00:06:56,310
single machine operating system like

00:06:53,440 --> 00:06:58,570
Linux they provide a great abstraction

00:06:56,310 --> 00:07:03,880
but we don't have equivalent of it for

00:06:58,570 --> 00:07:06,180
distributed systems not surprisingly

00:07:03,880 --> 00:07:08,320
these are distributed system problems

00:07:06,180 --> 00:07:09,700
these are the things we study in

00:07:08,320 --> 00:07:12,070
computer science operating system

00:07:09,700 --> 00:07:13,900
classes we learn about how virtual

00:07:12,070 --> 00:07:16,300
memory manager works understand how TCP

00:07:13,900 --> 00:07:18,130
sliding-window protocol works but we

00:07:16,300 --> 00:07:20,590
don't expect application developer to

00:07:18,130 --> 00:07:23,170
implement TCP sliding-window protocol in

00:07:20,590 --> 00:07:24,550
their applications or decided which

00:07:23,170 --> 00:07:27,580
memory should go on disk and which

00:07:24,550 --> 00:07:29,500
memory should go on to ram this should

00:07:27,580 --> 00:07:32,790
be abstracted away which at the moment

00:07:29,500 --> 00:07:35,410
is not in case of distributed systems

00:07:32,790 --> 00:07:37,600
unlike single machine operating system

00:07:35,410 --> 00:07:39,340
unlike single machine operating system

00:07:37,600 --> 00:07:43,410
which takes care of them all these

00:07:39,340 --> 00:07:49,450
things under the hood so the question is

00:07:43,410 --> 00:07:50,920
what do we do about this we clearly need

00:07:49,450 --> 00:07:52,480
people to solve these problems and are

00:07:50,920 --> 00:07:56,670
not necessarily application developers

00:07:52,480 --> 00:07:56,670
and they should be specialized in this

00:08:01,690 --> 00:08:05,860
the terminology i'm using here

00:08:03,820 --> 00:08:08,380
application developer is not something

00:08:05,860 --> 00:08:10,630
everybody understands certainly not in

00:08:08,380 --> 00:08:12,070
standard term in the industry just want

00:08:10,630 --> 00:08:15,850
to be clear on what I am talking about

00:08:12,070 --> 00:08:17,740
here and I think there is a large amount

00:08:15,850 --> 00:08:19,680
of very necessary specialization

00:08:17,740 --> 00:08:22,660
developed around this area

00:08:19,680 --> 00:08:24,550
these are application developers these

00:08:22,660 --> 00:08:26,440
are the kind of people who know

00:08:24,550 --> 00:08:28,750
particular application domain very well

00:08:26,440 --> 00:08:32,440
like social networking travel finance

00:08:28,750 --> 00:08:34,599
banking etc they know what their systems

00:08:32,440 --> 00:08:38,620
need to do what their customers want

00:08:34,599 --> 00:08:40,240
what functionality they need they don't

00:08:38,620 --> 00:08:42,099
give a hoot to distributor system

00:08:40,240 --> 00:08:45,040
problems in the middle we have sis

00:08:42,099 --> 00:08:47,020
system developers they are the people

00:08:45,040 --> 00:08:48,700
who are interested in understanding and

00:08:47,020 --> 00:08:51,160
solving the complex distributed system

00:08:48,700 --> 00:08:53,770
problems they are extremely short in

00:08:51,160 --> 00:08:56,350
supply problematically they don't

00:08:53,770 --> 00:08:58,000
understand your business needs and on

00:08:56,350 --> 00:09:01,240
the right hand side we have a service

00:08:58,000 --> 00:09:04,090
DevOps engineers they are the people who

00:09:01,240 --> 00:09:06,400
understand how your actual application

00:09:04,090 --> 00:09:07,720
behaves in real life what happens when a

00:09:06,400 --> 00:09:09,760
particular customer hits your

00:09:07,720 --> 00:09:13,510
application how much capacity you will

00:09:09,760 --> 00:09:16,320
need overload what do your shouting

00:09:13,510 --> 00:09:18,430
systems look like what breaks and why

00:09:16,320 --> 00:09:20,590
once again they are not necessarily

00:09:18,430 --> 00:09:22,990
distributed system experts and not

00:09:20,590 --> 00:09:25,210
necessarily application domain expert

00:09:22,990 --> 00:09:30,340
but they do understand how to run the

00:09:25,210 --> 00:09:32,140
systems well I think it is very useful

00:09:30,340 --> 00:09:33,940
to understand these distinctions a

00:09:32,140 --> 00:09:35,920
Suri's are good at running reliable

00:09:33,940 --> 00:09:40,960
systems application developers are good

00:09:35,920 --> 00:09:42,520
at application domain so what we think

00:09:40,960 --> 00:09:46,660
is ultimately we need a distributed

00:09:42,520 --> 00:09:49,690
operating system I mean always I mean oh

00:09:46,660 --> 00:09:51,220
is this an umbrella project we think it

00:09:49,690 --> 00:09:53,860
should probably compress of at least

00:09:51,220 --> 00:09:56,560
these major subsystems first twenty

00:09:53,860 --> 00:09:58,870
Cimino run manages distributed micro

00:09:56,560 --> 00:10:01,600
services it's a distributed programming

00:09:58,870 --> 00:10:03,370
system that provides customizable and

00:10:01,600 --> 00:10:06,130
extensible deployment of mobile and

00:10:03,370 --> 00:10:07,920
cloud applications this flexibility

00:10:06,130 --> 00:10:10,530
enables program was to separate

00:10:07,920 --> 00:10:14,260
deployment logic from their applications

00:10:10,530 --> 00:10:15,400
second one is aminos sync reactive data

00:10:14,260 --> 00:10:17,200
management service

00:10:15,400 --> 00:10:20,590
which provides the persistent cloud

00:10:17,200 --> 00:10:22,480
storage and reliable synchronization

00:10:20,590 --> 00:10:24,820
between storage in mobile devices and

00:10:22,480 --> 00:10:26,860
also provides automated execution of

00:10:24,820 --> 00:10:30,570
application code in response to shared

00:10:26,860 --> 00:10:32,860
data updates third one is Cimino store

00:10:30,570 --> 00:10:35,620
distributed transaction protocol like

00:10:32,860 --> 00:10:37,480
that droids linearizable transactions

00:10:35,620 --> 00:10:39,640
using inconsistent replication

00:10:37,480 --> 00:10:43,090
unlike two-phase commit with strong

00:10:39,640 --> 00:10:46,150
replication strong consistent

00:10:43,090 --> 00:10:49,090
replications within the partition lasts

00:10:46,150 --> 00:10:51,880
20 Cimino safe distributed system that

00:10:49,090 --> 00:10:53,650
gives user control over how mobile and

00:10:51,880 --> 00:10:56,040
cloud applications share sensitive user

00:10:53,650 --> 00:10:58,060
data collected on mobile devices

00:10:56,040 --> 00:11:01,480
basically deals with privacy and

00:10:58,060 --> 00:11:03,910
security aspects we are going to talk

00:11:01,480 --> 00:11:05,800
about Amina run for today Irene will be

00:11:03,910 --> 00:11:07,510
describing it in detail just wanted to

00:11:05,800 --> 00:11:12,820
give the context and where does this

00:11:07,510 --> 00:11:14,860
amino acids this picture is

00:11:12,820 --> 00:11:16,870
self-explanatory what we really want you

00:11:14,860 --> 00:11:19,240
to be thinking is distributed cloud

00:11:16,870 --> 00:11:21,190
native applications doesn't actually

00:11:19,240 --> 00:11:23,800
have to worry about pieces which piece

00:11:21,190 --> 00:11:26,650
of code runs on which machine operating

00:11:23,800 --> 00:11:28,990
systems has to take care of them and we

00:11:26,650 --> 00:11:31,270
know it is a unified system that

00:11:28,990 --> 00:11:34,090
provides microservice runtime memory

00:11:31,270 --> 00:11:36,610
management storage and security

00:11:34,090 --> 00:11:40,200
components it needs to run across all

00:11:36,610 --> 00:11:40,200
the operating systems in the network

00:11:44,130 --> 00:11:47,610
a lot of research had been going on for

00:11:46,410 --> 00:11:50,040
several years in the university of

00:11:47,610 --> 00:11:51,990
washington but all the time Irene had

00:11:50,040 --> 00:11:54,510
published published her theses we came

00:11:51,990 --> 00:11:56,070
across it and thought that it's worth

00:11:54,510 --> 00:11:58,640
turning into an open-source project in

00:11:56,070 --> 00:12:00,870
the CNC F so that people can use it

00:11:58,640 --> 00:12:03,960
research wasn't intended for that

00:12:00,870 --> 00:12:06,450
purpose originally it was really

00:12:03,960 --> 00:12:09,060
experiment related figure out what this

00:12:06,450 --> 00:12:12,360
face looks like and what we needed in

00:12:09,060 --> 00:12:15,540
particular there are academic papers

00:12:12,360 --> 00:12:17,190
floating around in Internet some of the

00:12:15,540 --> 00:12:19,020
terminology in the papers are different

00:12:17,190 --> 00:12:21,060
from what we have described here over

00:12:19,020 --> 00:12:24,000
time we discovered that certain terms we

00:12:21,060 --> 00:12:26,880
use were confusing for example we

00:12:24,000 --> 00:12:31,080
renamed amino system to amino run aminos

00:12:26,880 --> 00:12:32,430
diamond2 amino sync etc so if you see

00:12:31,080 --> 00:12:34,200
the contradictory terms floating around

00:12:32,430 --> 00:12:36,810
the internet hopefully you'll understand

00:12:34,200 --> 00:12:39,560
the origin I'm going to hand over to

00:12:36,810 --> 00:12:39,560
Irene from here

00:12:49,149 --> 00:12:53,199
seemed like Jhelum ah on you ho okay I

00:12:51,490 --> 00:12:54,790
seen the neck wandering Roman ah ha

00:12:53,199 --> 00:12:56,589
no really I'm actually gonna do this

00:12:54,790 --> 00:13:02,290
talk in English because my Chinese is

00:12:56,589 --> 00:13:04,629
not that good so okay you've gotten a

00:13:02,290 --> 00:13:06,819
great introduction to the overview of

00:13:04,629 --> 00:13:09,100
the whole amino system I'm going to

00:13:06,819 --> 00:13:13,029
focus today on the very detailed parts

00:13:09,100 --> 00:13:15,610
of the amino run sub system sort of what

00:13:13,029 --> 00:13:16,660
the magic is and what the knobs are that

00:13:15,610 --> 00:13:19,660
make it all happen

00:13:16,660 --> 00:13:21,550
so the for this subsection of the talk

00:13:19,660 --> 00:13:24,009
I'm going to talk about the goals that

00:13:21,550 --> 00:13:26,920
we had in doing the research for this

00:13:24,009 --> 00:13:29,019
portion of the amino Run system its

00:13:26,920 --> 00:13:30,730
architecture and how it actually works

00:13:29,019 --> 00:13:33,550
and then I'll talk a little bit about

00:13:30,730 --> 00:13:36,370
deployment managers which are the magic

00:13:33,550 --> 00:13:38,079
sauce to this system and then finally

00:13:36,370 --> 00:13:40,120
I'll wrap up with some experience and

00:13:38,079 --> 00:13:45,399
evaluation and then we'll go back for a

00:13:40,120 --> 00:13:47,499
demo so when we started taking a look at

00:13:45,399 --> 00:13:50,319
this problem space of developing a

00:13:47,499 --> 00:13:54,100
distributed operating system for mobile

00:13:50,319 --> 00:13:55,569
and cloud application developers we had

00:13:54,100 --> 00:13:57,730
a couple of goals that we wanted to

00:13:55,569 --> 00:14:00,399
achieve when we were looking at building

00:13:57,730 --> 00:14:02,860
this runtime system so the first is that

00:14:00,399 --> 00:14:05,410
we did not want what we consider

00:14:02,860 --> 00:14:07,300
deployment logic to be mixed in with the

00:14:05,410 --> 00:14:10,149
application logic so you can think of

00:14:07,300 --> 00:14:11,800
this as the code that a distributed

00:14:10,149 --> 00:14:14,559
systems programmer would have to

00:14:11,800 --> 00:14:16,240
implement like building RPC compared to

00:14:14,559 --> 00:14:18,490
something that an application programmer

00:14:16,240 --> 00:14:20,740
should be building which is like you

00:14:18,490 --> 00:14:22,779
know how your operation how your

00:14:20,740 --> 00:14:26,679
application operates or you know what a

00:14:22,779 --> 00:14:28,480
tweet is we wanted to make sure that the

00:14:26,679 --> 00:14:31,300
application code itself was able to be

00:14:28,480 --> 00:14:34,540
very simple and intuitive but we still

00:14:31,300 --> 00:14:37,600
wanted application programmers or sres

00:14:34,540 --> 00:14:39,309
to be able to decide how actually to

00:14:37,600 --> 00:14:40,959
deploy their applications so we didn't

00:14:39,309 --> 00:14:42,759
want to take all of this control away

00:14:40,959 --> 00:14:44,769
even though we were going to separate

00:14:42,759 --> 00:14:48,790
the deployment code from the application

00:14:44,769 --> 00:14:50,949
code itself then you know we had some

00:14:48,790 --> 00:14:53,709
other high-level goals like we want to

00:14:50,949 --> 00:14:56,290
be able to support a large number of

00:14:53,709 --> 00:14:57,579
programming languages and then of course

00:14:56,290 --> 00:15:01,059
we want to provide reasonable

00:14:57,579 --> 00:15:02,709
performance and we want to for sure

00:15:01,059 --> 00:15:04,689
support external

00:15:02,709 --> 00:15:10,600
infrastructure systems like kubernetes

00:15:04,689 --> 00:15:13,629
sto and @cd so what we came up with was

00:15:10,600 --> 00:15:15,850
this Amino run system which is a

00:15:13,629 --> 00:15:18,430
distributed operating system that

00:15:15,850 --> 00:15:21,040
supports pluggable deployment managers

00:15:18,430 --> 00:15:23,800
which extend the functionality of the

00:15:21,040 --> 00:15:26,379
the distributed operating system in

00:15:23,800 --> 00:15:29,139
various ways and so I'll show you how

00:15:26,379 --> 00:15:30,939
these deployment managers actually allow

00:15:29,139 --> 00:15:32,800
application programmers to decide

00:15:30,939 --> 00:15:37,209
exactly how their application is going

00:15:32,800 --> 00:15:39,399
to be deployed so the best way to

00:15:37,209 --> 00:15:41,079
understand how Amino run works is by

00:15:39,399 --> 00:15:43,929
taking a look at its architecture and

00:15:41,079 --> 00:15:45,699
the key thing here to notice is that

00:15:43,929 --> 00:15:47,949
there going to be three layers to this

00:15:45,699 --> 00:15:49,569
architecture at the top will be the

00:15:47,949 --> 00:15:51,249
distributed application which is the

00:15:49,569 --> 00:15:53,529
application code that's going to run

00:15:51,249 --> 00:15:58,029
across all of your mobile devices and

00:15:53,529 --> 00:15:59,499
IOT devices and cloud servers then at

00:15:58,029 --> 00:16:01,660
the very bottom layer we have a

00:15:59,499 --> 00:16:05,110
deployment kernel which implements

00:16:01,660 --> 00:16:08,410
best-effort basic deployment tasks like

00:16:05,110 --> 00:16:10,929
just making a call to a different part

00:16:08,410 --> 00:16:14,199
of the application or being able to find

00:16:10,929 --> 00:16:16,629
other components in the application but

00:16:14,199 --> 00:16:18,429
the most important part of the amino run

00:16:16,629 --> 00:16:21,759
architecture is the deployment manager

00:16:18,429 --> 00:16:24,040
this layer so the deployment management

00:16:21,759 --> 00:16:26,309
layer extends the functionality of the

00:16:24,040 --> 00:16:28,389
deployment kernel in such a way so that

00:16:26,309 --> 00:16:30,189
application programmers can actually

00:16:28,389 --> 00:16:32,199
choose what kind of functionality the

00:16:30,189 --> 00:16:36,579
deployment kernel will offer each part

00:16:32,199 --> 00:16:39,220
of their application so to give you an

00:16:36,579 --> 00:16:41,679
example the application programmer takes

00:16:39,220 --> 00:16:45,189
their application and splits it up into

00:16:41,679 --> 00:16:47,699
a couple of large micro services what we

00:16:45,189 --> 00:16:49,959
do underneath then is that we have the

00:16:47,699 --> 00:16:52,480
deployment kernel which runs these

00:16:49,959 --> 00:16:54,399
Microsystems services but then for each

00:16:52,480 --> 00:16:56,980
micro service there's going to be a

00:16:54,399 --> 00:17:01,360
deployment manager that provides the

00:16:56,980 --> 00:17:05,670
exact functionality and deployment tasks

00:17:01,360 --> 00:17:05,670
that the applicant micro service needs

00:17:07,319 --> 00:17:15,370
so going back to the top level of the

00:17:11,130 --> 00:17:18,880
amino architecture immuno applications

00:17:15,370 --> 00:17:21,519
are fundamentally large micro-services

00:17:18,880 --> 00:17:24,730
they run in a single address space so

00:17:21,519 --> 00:17:27,579
any amino Run microservice can call any

00:17:24,730 --> 00:17:29,320
other amino Run microservice but they

00:17:27,579 --> 00:17:31,630
can execute anywhere and they can move

00:17:29,320 --> 00:17:33,490
transparent to the application itself so

00:17:31,630 --> 00:17:35,169
the application code doesn't have to

00:17:33,490 --> 00:17:37,090
worry about where these micro-services

00:17:35,169 --> 00:17:38,799
run and it doesn't have to worry about

00:17:37,090 --> 00:17:42,639
how to find where each one of these

00:17:38,799 --> 00:17:46,539
micro-services what's important about

00:17:42,639 --> 00:17:49,110
the micro-service encapsulation is that

00:17:46,539 --> 00:17:51,730
it gives a granularity for which the

00:17:49,110 --> 00:17:54,970
runtime itself the deployment kernel can

00:17:51,730 --> 00:17:57,299
decide to move and allocate instances of

00:17:54,970 --> 00:17:57,299
this application

00:18:00,050 --> 00:18:04,520
so if you had a distributed game for

00:18:02,870 --> 00:18:05,960
example you might create one micro

00:18:04,520 --> 00:18:08,330
service that holds your game board

00:18:05,960 --> 00:18:11,090
another micro-service that holds the

00:18:08,330 --> 00:18:12,980
scores of all the players and then maybe

00:18:11,090 --> 00:18:15,050
another microservice that implements

00:18:12,980 --> 00:18:18,740
some sort of game logic or physics

00:18:15,050 --> 00:18:21,170
engine so then if we look down into the

00:18:18,740 --> 00:18:23,750
deployment kernel the deployment kernel

00:18:21,170 --> 00:18:25,610
is a piece of software that is

00:18:23,750 --> 00:18:28,430
distributed but it runs on every single

00:18:25,610 --> 00:18:31,820
cloud server and mobile device its

00:18:28,430 --> 00:18:34,970
entire job is to instantiate and manage

00:18:31,820 --> 00:18:38,080
these high-level micro services that

00:18:34,970 --> 00:18:40,970
comprise the Amino run applications it

00:18:38,080 --> 00:18:44,170
tracks where each micro service is it

00:18:40,970 --> 00:18:46,520
enables micro services to move around

00:18:44,170 --> 00:18:50,120
transparent to the application and then

00:18:46,520 --> 00:18:51,440
it also makes sure that the micro

00:18:50,120 --> 00:18:54,730
services can call to each other

00:18:51,440 --> 00:18:58,490
transparently without having to you know

00:18:54,730 --> 00:19:00,230
look up the IP address and you know

00:18:58,490 --> 00:19:04,610
actually set up TCP connections and

00:19:00,230 --> 00:19:06,980
things like that so that's the bottom

00:19:04,610 --> 00:19:08,810
layer of the architecture so now I'll

00:19:06,980 --> 00:19:12,170
talk about the deployment managers which

00:19:08,810 --> 00:19:14,300
are the secret sauce so the way the

00:19:12,170 --> 00:19:16,640
deployment manager is work is that they

00:19:14,300 --> 00:19:20,150
implement sophisticated micro service

00:19:16,640 --> 00:19:22,220
deployment tasks by interposing on calls

00:19:20,150 --> 00:19:28,370
to the micro service on our pcs

00:19:22,220 --> 00:19:31,070
essentially and then routing or managing

00:19:28,370 --> 00:19:33,290
those calls so as an example to give you

00:19:31,070 --> 00:19:35,870
a concrete example one deployment

00:19:33,290 --> 00:19:38,000
manager might replicate a micro surface

00:19:35,870 --> 00:19:40,370
by creating multiple instances of that

00:19:38,000 --> 00:19:42,770
Microsoft service in different

00:19:40,370 --> 00:19:45,050
containers for example then every time

00:19:42,770 --> 00:19:49,160
the application makes a call to that

00:19:45,050 --> 00:19:51,770
micro service the deployment the

00:19:49,160 --> 00:19:55,280
deployment manager will route the call

00:19:51,770 --> 00:19:57,590
to all of the replicas so the nice thing

00:19:55,280 --> 00:20:00,530
about deployment managers is that they

00:19:57,590 --> 00:20:02,240
encapsulate deployment code and tasks

00:20:00,530 --> 00:20:05,060
separate from the application code

00:20:02,240 --> 00:20:08,330
itself so programmers can decide that

00:20:05,060 --> 00:20:10,040
they have implemented this this piece of

00:20:08,330 --> 00:20:12,200
this micro service this piece of

00:20:10,040 --> 00:20:13,850
application logic but then later they

00:20:12,200 --> 00:20:16,010
want replication

00:20:13,850 --> 00:20:18,980
they can simply add a deployment manager

00:20:16,010 --> 00:20:22,130
sort of like a library onto their micro

00:20:18,980 --> 00:20:23,840
service and transparently achieve that

00:20:22,130 --> 00:20:26,860
functionality without having to change

00:20:23,840 --> 00:20:26,860
their application code

00:20:30,210 --> 00:20:34,919
so I'll give some examples in the next

00:20:33,600 --> 00:20:38,309
section about how exactly these

00:20:34,919 --> 00:20:40,409
deployment managers work but understand

00:20:38,309 --> 00:20:43,350
a little bit better if you think of each

00:20:40,409 --> 00:20:45,119
of these as being a micro service we

00:20:43,350 --> 00:20:46,980
could decide that perhaps this game

00:20:45,119 --> 00:20:48,830
board micro service needs to be

00:20:46,980 --> 00:20:51,179
replicated so we would attach a

00:20:48,830 --> 00:20:53,820
replication deployment manager to it

00:20:51,179 --> 00:20:57,179
which would ensure that the game board

00:20:53,820 --> 00:20:59,309
micro service is replicated to and

00:20:57,179 --> 00:21:03,029
instantiated in different containers and

00:20:59,309 --> 00:21:06,029
then have each of the RPC calls to the

00:21:03,029 --> 00:21:11,119
micro Service replicated then we might

00:21:06,029 --> 00:21:14,100
have a set of least caching micro

00:21:11,119 --> 00:21:17,869
deployment managers for your scoreboard

00:21:14,100 --> 00:21:20,970
and maybe some code offloading for your

00:21:17,869 --> 00:21:22,889
physics engine so we have a large range

00:21:20,970 --> 00:21:25,049
of deployment managers the thing to

00:21:22,889 --> 00:21:26,730
understand here is that almost any

00:21:25,049 --> 00:21:28,379
deployment tasks that you might want to

00:21:26,730 --> 00:21:30,389
implement could be implemented in a

00:21:28,379 --> 00:21:32,249
deployment manager so essentially as

00:21:30,389 --> 00:21:34,679
long as you're able to implement the

00:21:32,249 --> 00:21:36,480
tasks by interposing on calls to the

00:21:34,679 --> 00:21:39,570
micro service then you're able to

00:21:36,480 --> 00:21:41,730
implement this deployment tasks inside a

00:21:39,570 --> 00:21:45,210
deployment manager and we've built a

00:21:41,730 --> 00:21:47,279
fairly extensive library already of

00:21:45,210 --> 00:21:48,960
stock deployment managers that

00:21:47,279 --> 00:21:51,749
application programmers can go ahead and

00:21:48,960 --> 00:21:54,210
use or go ahead and modify themselves if

00:21:51,749 --> 00:21:55,320
you're a distributed systems person the

00:21:54,210 --> 00:21:57,299
other thing that's interesting is that

00:21:55,320 --> 00:21:59,159
you can combine them in interesting ways

00:21:57,299 --> 00:22:02,970
so that you can use more than one

00:21:59,159 --> 00:22:04,649
deployment manager at a time so we have

00:22:02,970 --> 00:22:06,389
lots of different categories in which we

00:22:04,649 --> 00:22:08,190
group our deployment managers we have a

00:22:06,389 --> 00:22:10,919
bunch of deployment managers that just

00:22:08,190 --> 00:22:13,830
implement very primitive deployment

00:22:10,919 --> 00:22:17,960
tasks like exactly once RPC we also have

00:22:13,830 --> 00:22:20,309
caching and serial light serializability

00:22:17,960 --> 00:22:23,039
checkpointing replication mobility

00:22:20,309 --> 00:22:25,740
scalability and more so there are a very

00:22:23,039 --> 00:22:31,529
large set of these library deployment

00:22:25,740 --> 00:22:33,240
managers already and more to come so I'm

00:22:31,529 --> 00:22:38,730
gonna talk a little bit more about how

00:22:33,240 --> 00:22:41,159
the oh so how the Sapphire / Kamino run

00:22:38,730 --> 00:22:42,970
deployment manager library works in

00:22:41,159 --> 00:22:45,730
order for you to understand how

00:22:42,970 --> 00:22:52,750
possible for just any programmer to

00:22:45,730 --> 00:22:54,159
extend these deployment managers so when

00:22:52,750 --> 00:22:57,789
I talked about how the deployment

00:22:54,159 --> 00:22:59,470
managers interpose on our PC the way

00:22:57,789 --> 00:23:00,700
that we actually implement deployment

00:22:59,470 --> 00:23:03,970
managers is through an interface

00:23:00,700 --> 00:23:07,179
provided by the south by the Amino run

00:23:03,970 --> 00:23:09,100
deployment kernel so what happens

00:23:07,179 --> 00:23:11,980
actually is that each deployment manager

00:23:09,100 --> 00:23:14,440
is implemented as three separate

00:23:11,980 --> 00:23:17,169
components each of which support a

00:23:14,440 --> 00:23:19,690
sequence of up calls that the deployment

00:23:17,169 --> 00:23:22,450
kernel automatically invokes when our

00:23:19,690 --> 00:23:24,820
pcs come in so let me give you an

00:23:22,450 --> 00:23:27,340
example so we have a server side

00:23:24,820 --> 00:23:29,830
component which is co-located where with

00:23:27,340 --> 00:23:32,350
where the micro service actually runs so

00:23:29,830 --> 00:23:34,510
when an RPC comes in an up call will be

00:23:32,350 --> 00:23:38,049
made to the server side deployment

00:23:34,510 --> 00:23:39,970
manager similarly for the client side

00:23:38,049 --> 00:23:42,789
deployment manager we have another

00:23:39,970 --> 00:23:45,250
component that runs where the client

00:23:42,789 --> 00:23:46,840
makes the RPC so then from the client

00:23:45,250 --> 00:23:48,730
side whenever the client makes an RPC

00:23:46,840 --> 00:23:51,789
will invoke an up call inside this

00:23:48,730 --> 00:23:53,350
component of the deployment manager then

00:23:51,789 --> 00:23:55,000
we have a centralized component for

00:23:53,350 --> 00:23:56,590
every deployment manager which we

00:23:55,000 --> 00:23:59,440
implement on something that is

00:23:56,590 --> 00:24:01,690
essentially a an at CD kind of service

00:23:59,440 --> 00:24:04,990
to provide replication and fault

00:24:01,690 --> 00:24:07,000
tolerance for these components as you

00:24:04,990 --> 00:24:09,940
can imagine these components are going

00:24:07,000 --> 00:24:11,919
to be much slower when they run compared

00:24:09,940 --> 00:24:14,230
to the server side and client side

00:24:11,919 --> 00:24:16,150
deployment manager components so we

00:24:14,230 --> 00:24:18,960
encourage programmers to put most of

00:24:16,150 --> 00:24:22,179
their implementation into the other two

00:24:18,960 --> 00:24:25,570
so let's take a look at what happens

00:24:22,179 --> 00:24:29,110
exactly when an RPC is made to a SATA to

00:24:25,570 --> 00:24:32,940
a sapphire or Amino run micro service so

00:24:29,110 --> 00:24:35,470
when you start the micro Service the

00:24:32,940 --> 00:24:39,940
Sapphire deployment kernel will actually

00:24:35,470 --> 00:24:41,799
instantiate the deployment managers

00:24:39,940 --> 00:24:44,289
automatically so let's say we're trying

00:24:41,799 --> 00:24:48,490
to replicate this micro service so what

00:24:44,289 --> 00:24:51,580
will happen is the deployment manager

00:24:48,490 --> 00:24:54,190
will receive an up call saying that the

00:24:51,580 --> 00:24:56,920
micro Service has been created at which

00:24:54,190 --> 00:25:01,240
point it will create replicas

00:24:56,920 --> 00:25:04,450
of the microservice on to other kernel

00:25:01,240 --> 00:25:09,160
servers these replicas can talk to each

00:25:04,450 --> 00:25:13,060
other and so when the clients make calls

00:25:09,160 --> 00:25:15,010
they can the client-side deployment

00:25:13,060 --> 00:25:17,320
manager component will forward those RPC

00:25:15,010 --> 00:25:20,320
calls to where the micro service is and

00:25:17,320 --> 00:25:26,160
then those calls can be replicated to

00:25:20,320 --> 00:25:26,160
the other copies of the micro service

00:25:29,409 --> 00:25:38,419
so let's look at exactly what happens

00:25:33,470 --> 00:25:42,799
with a primary backup sort of leader

00:25:38,419 --> 00:25:46,609
based replication protocol so we first

00:25:42,799 --> 00:25:48,200
stand up three copies of the micro

00:25:46,609 --> 00:25:50,659
service for a consensus-based

00:25:48,200 --> 00:25:53,840
kind of leader based replication

00:25:50,659 --> 00:25:57,529
protocol we designate one of the micro

00:25:53,840 --> 00:26:00,289
service instances as the leader and then

00:25:57,529 --> 00:26:03,619
when any other micro service makes over

00:26:00,289 --> 00:26:06,590
RPC to this micro service the

00:26:03,619 --> 00:26:08,570
client-side component will direct the

00:26:06,590 --> 00:26:10,639
call to the leader based micro service

00:26:08,570 --> 00:26:14,570
instance which will then replicate the

00:26:10,639 --> 00:26:17,960
call to the two backups wait until the

00:26:14,570 --> 00:26:22,609
RPC finishes running and then respond to

00:26:17,960 --> 00:26:24,619
the client saying that the RPC was

00:26:22,609 --> 00:26:27,019
successfully made and of course

00:26:24,619 --> 00:26:29,899
replicated to the two other instances of

00:26:27,019 --> 00:26:32,389
the micro service so this is essentially

00:26:29,899 --> 00:26:34,309
simple state machine replication but as

00:26:32,389 --> 00:26:36,679
you can see we've been able to do it

00:26:34,309 --> 00:26:38,629
inside a library completely separate

00:26:36,679 --> 00:26:41,749
from the application code itself and

00:26:38,629 --> 00:26:44,509
we're able to essentially attach this

00:26:41,749 --> 00:26:46,519
deployment manager to a micro service

00:26:44,509 --> 00:26:48,710
and provide the state machine

00:26:46,519 --> 00:26:50,720
replication as a service without

00:26:48,710 --> 00:26:54,139
changing any of the code of the

00:26:50,720 --> 00:26:56,269
application itself so I'll go really

00:26:54,139 --> 00:26:57,739
quickly through how this works for a

00:26:56,269 --> 00:27:00,229
couple of other things because we're

00:26:57,739 --> 00:27:04,639
running a little bit short on time so

00:27:00,229 --> 00:27:06,710
another option would be taking a micro

00:27:04,639 --> 00:27:10,669
service that perhaps runs some code on

00:27:06,710 --> 00:27:13,820
the client side like maybe an IOT device

00:27:10,669 --> 00:27:16,220
of some sort and offloading that to the

00:27:13,820 --> 00:27:18,529
cloud so essentially what would happen

00:27:16,220 --> 00:27:20,450
is we would need to just create an

00:27:18,529 --> 00:27:23,239
instance of the micro Service the same

00:27:20,450 --> 00:27:27,499
code in the cloud and then just forward

00:27:23,239 --> 00:27:31,039
calls from the code that was running on

00:27:27,499 --> 00:27:33,200
the IOT device or phone to the cloud

00:27:31,039 --> 00:27:36,889
instance and so depending on which of

00:27:33,200 --> 00:27:38,539
the to run faster then we can make a

00:27:36,889 --> 00:27:41,359
decision about where to actually run

00:27:38,539 --> 00:27:42,620
that code we can sort of do the same

00:27:41,359 --> 00:27:46,190
thing essentially in

00:27:42,620 --> 00:27:49,400
reverse to cache data from a micro

00:27:46,190 --> 00:27:51,640
service locally on the mobile device so

00:27:49,400 --> 00:27:54,110
what happens is we have some sort of

00:27:51,640 --> 00:27:56,900
instance of the application micro

00:27:54,110 --> 00:27:59,780
service in the cloud then we when we

00:27:56,900 --> 00:28:02,809
make a call we bring the data from the

00:27:59,780 --> 00:28:06,470
micro service in the cloud to the mobile

00:28:02,809 --> 00:28:11,660
device and then make the call locally on

00:28:06,470 --> 00:28:14,390
the mobile device instead so those two

00:28:11,660 --> 00:28:16,190
those couple of examples that I did were

00:28:14,390 --> 00:28:18,320
pretty simple just so that you could

00:28:16,190 --> 00:28:20,660
understand how exactly the sequence of

00:28:18,320 --> 00:28:23,000
events happens inside a deployment

00:28:20,660 --> 00:28:24,980
manager but you might want to run a much

00:28:23,000 --> 00:28:28,010
more sophisticated algorithm for example

00:28:24,980 --> 00:28:32,150
to automatically deploy an application

00:28:28,010 --> 00:28:34,490
based on minimizing the latency so what

00:28:32,150 --> 00:28:36,380
we actually are able to do with the

00:28:34,490 --> 00:28:38,030
deployment kernel is things are things

00:28:36,380 --> 00:28:42,470
that are much more sophisticated so we

00:28:38,030 --> 00:28:44,240
can take a look and monitor the latency

00:28:42,470 --> 00:28:46,820
and throughput of every call between

00:28:44,240 --> 00:28:48,679
every kernel server and every micro

00:28:46,820 --> 00:28:52,400
service and then make a decision about

00:28:48,679 --> 00:28:55,070
where to place these using a distributed

00:28:52,400 --> 00:28:57,770
algorithm and we'll actually see an

00:28:55,070 --> 00:29:01,220
example of this migration and dynamic

00:28:57,770 --> 00:29:05,330
placement happening in a demo later so

00:29:01,220 --> 00:29:07,370
we can compose deployment managers as

00:29:05,330 --> 00:29:09,830
well it's done by chaining deployment

00:29:07,370 --> 00:29:11,750
managers so you can imagine every time

00:29:09,830 --> 00:29:14,690
you make an RPC the call goes through a

00:29:11,750 --> 00:29:18,080
series or a sequence of deployment

00:29:14,690 --> 00:29:19,910
managers but of course you could imagine

00:29:18,080 --> 00:29:22,220
that this rapidly gets very complicated

00:29:19,910 --> 00:29:23,720
so we don't imagine people would be

00:29:22,220 --> 00:29:27,440
chaining a lot of these deployment

00:29:23,720 --> 00:29:30,320
managers together all right

00:29:27,440 --> 00:29:32,809
so five years ago when I did this

00:29:30,320 --> 00:29:35,000
research we did a little experiment and

00:29:32,809 --> 00:29:36,559
I'll show you the experimental results

00:29:35,000 --> 00:29:37,790
although the demo that we're going to

00:29:36,559 --> 00:29:40,790
show later is probably much more

00:29:37,790 --> 00:29:42,860
interesting so we did this experiment on

00:29:40,790 --> 00:29:45,110
a couple of mobile devices they were

00:29:42,860 --> 00:29:47,660
pretty out of date and a Dell server

00:29:45,110 --> 00:29:50,020
that we just had in our lab and so all

00:29:47,660 --> 00:29:52,940
of this stuff was running over Wi-Fi and

00:29:50,020 --> 00:29:55,090
also like 3G or whatever we had at the

00:29:52,940 --> 00:29:55,090
time

00:29:55,160 --> 00:30:04,630
so essentially what we did was we built

00:29:57,290 --> 00:30:07,400
a multiplayer game so we were able to oh

00:30:04,630 --> 00:30:08,900
so we were able to use a couple of

00:30:07,400 --> 00:30:11,170
different deployments of the multiplayer

00:30:08,900 --> 00:30:15,200
game and so what you're seeing here is

00:30:11,170 --> 00:30:18,020
in each case the read and write latency

00:30:15,200 --> 00:30:22,460
for making a move and then reading the

00:30:18,020 --> 00:30:25,190
state of the board the game board in

00:30:22,460 --> 00:30:30,020
milliseconds so the first thing that we

00:30:25,190 --> 00:30:32,840
did was we put the game board as a micro

00:30:30,020 --> 00:30:36,950
service in the cloud and then we let

00:30:32,840 --> 00:30:38,900
both mobile devices make calls to the

00:30:36,950 --> 00:30:42,230
cloud to both make moves as well as

00:30:38,900 --> 00:30:44,840
fetch the state of the game board so

00:30:42,230 --> 00:30:49,310
that means that everybody sees roughly

00:30:44,840 --> 00:30:51,440
high latency uniformly but we were then

00:30:49,310 --> 00:30:53,810
able to do is change the deployment

00:30:51,440 --> 00:30:58,010
manager to move the game board micro

00:30:53,810 --> 00:31:01,130
service on to one of the onto one of the

00:30:58,010 --> 00:31:02,930
phones at which point the player whose

00:31:01,130 --> 00:31:06,110
phone the micro service is running on

00:31:02,930 --> 00:31:08,210
obviously sees very low latency and then

00:31:06,110 --> 00:31:10,610
the latency for the other player Rises

00:31:08,210 --> 00:31:12,590
and the really cool thing here is that

00:31:10,610 --> 00:31:15,230
we didn't have to actually change any

00:31:12,590 --> 00:31:17,870
application code it should change this

00:31:15,230 --> 00:31:20,960
game essentially from something that is

00:31:17,870 --> 00:31:24,110
a cloud server based game to appear to

00:31:20,960 --> 00:31:25,700
peer application and then we were able

00:31:24,110 --> 00:31:27,680
to do the same thing where we just

00:31:25,700 --> 00:31:32,390
replicated the micro service on both

00:31:27,680 --> 00:31:34,610
players devices so reading the state of

00:31:32,390 --> 00:31:36,800
the board game became very fast but then

00:31:34,610 --> 00:31:39,110
every time the player made a move they

00:31:36,800 --> 00:31:41,180
would have to update both copies of the

00:31:39,110 --> 00:31:44,420
board game on both devices which

00:31:41,180 --> 00:31:48,740
increased the write Lansing so I'm gonna

00:31:44,420 --> 00:31:52,060
skip this next experiment because it

00:31:48,740 --> 00:31:58,940
sort of shows something very similar I

00:31:52,060 --> 00:32:02,660
will also say that the the amino Run

00:31:58,940 --> 00:32:04,700
system does support multiple programming

00:32:02,660 --> 00:32:07,190
languages through the use of grail vm

00:32:04,700 --> 00:32:08,270
and so this was one of our goals to be

00:32:07,190 --> 00:32:11,059
able to be

00:32:08,270 --> 00:32:14,090
somewhat programming language agnostic

00:32:11,059 --> 00:32:16,429
so you can essentially write your amino

00:32:14,090 --> 00:32:20,360
run application and deployment managers

00:32:16,429 --> 00:32:24,830
in any of these languages so that's

00:32:20,360 --> 00:32:31,700
pretty much it for the guts of the amino

00:32:24,830 --> 00:32:38,260
run system I will give it back to Ron

00:32:31,700 --> 00:32:38,260
ooh for the next steps in demo

00:32:47,320 --> 00:32:52,070
about the next steps it's still early we

00:32:50,600 --> 00:32:54,080
have lot of ways in which we would like

00:32:52,070 --> 00:32:57,110
to extend I mean no run in the future

00:32:54,080 --> 00:32:58,940
today micro service migration only works

00:32:57,110 --> 00:33:01,070
for the state stored into the but inside

00:32:58,940 --> 00:33:04,190
the micro services but there can be

00:33:01,070 --> 00:33:05,960
local files a dynamic state where we are

00:33:04,190 --> 00:33:08,810
not migrating as of now you have to work

00:33:05,960 --> 00:33:10,400
on that and we need to support

00:33:08,810 --> 00:33:12,590
definitely need to support more language

00:33:10,400 --> 00:33:15,110
we support very few now with the support

00:33:12,590 --> 00:33:17,540
of Calvin we are going to extend it and

00:33:15,110 --> 00:33:19,130
we want to build some more DMS to

00:33:17,540 --> 00:33:21,590
integrate with external systems like

00:33:19,130 --> 00:33:26,660
load balancers sto etcd

00:33:21,590 --> 00:33:28,820
TI kv and at the end we still need to

00:33:26,660 --> 00:33:30,770
build some good edge applications and

00:33:28,820 --> 00:33:33,470
verify that everything works well at

00:33:30,770 --> 00:33:36,430
least on the qubit rather than under

00:33:33,470 --> 00:33:36,430
normal cuban it is

00:33:39,840 --> 00:33:43,380
feel free to get involved this is

00:33:41,970 --> 00:33:46,110
already open source there is a slack

00:33:43,380 --> 00:33:47,580
channel github repo website you can have

00:33:46,110 --> 00:33:53,220
a look at it and get in touch with us if

00:33:47,580 --> 00:33:58,080
you are interested in it I will run the

00:33:53,220 --> 00:33:59,640
demo perfect face recognition app okay

00:33:58,080 --> 00:34:02,040
we don't have time now we'll be doing

00:33:59,640 --> 00:34:06,440
that we'll share it offline if people

00:34:02,040 --> 00:34:06,440
are interested we are open for Q&A

00:34:12,230 --> 00:34:15,190
any questions

00:34:17,159 --> 00:34:19,940
yeah yeah

00:34:26,460 --> 00:34:33,210
oh hello okay so um you said earlier

00:34:29,550 --> 00:34:35,490
that you were able to sort of turn a a

00:34:33,210 --> 00:34:39,030
cloud game into this peer-to-peer game

00:34:35,490 --> 00:34:40,859
um is that like a live migration or is

00:34:39,030 --> 00:34:43,559
it some kind of you you need to kind of

00:34:40,859 --> 00:34:52,550
take the service down and do some sort

00:34:43,559 --> 00:34:56,329
of reset and start it back up so okay so

00:34:52,550 --> 00:34:58,470
so the question was whether the

00:34:56,329 --> 00:35:02,309
evaluation the experiment that I showed

00:34:58,470 --> 00:35:04,260
was a live migration or not so the

00:35:02,309 --> 00:35:06,210
particular example I showed was not it

00:35:04,260 --> 00:35:08,640
was a change of one line of code and

00:35:06,210 --> 00:35:10,980
then standing up the service again but

00:35:08,640 --> 00:35:13,760
the demo we have if you want to look at

00:35:10,980 --> 00:35:15,540
it online is actually live migration

00:35:13,760 --> 00:35:17,369
heading to that it's a Java

00:35:15,540 --> 00:35:21,359
serialization and deserialization so

00:35:17,369 --> 00:35:22,650
it's it's a java-based application right

00:35:21,359 --> 00:35:24,599
so it's the Java serialization and

00:35:22,650 --> 00:35:26,400
deserialization at betherine we don't

00:35:24,599 --> 00:35:30,109
have dynamic state migration as a flow

00:35:26,400 --> 00:35:30,109
we I want to extend it support

00:35:37,600 --> 00:35:41,280
thank you you're done

00:35:41,470 --> 00:35:45,850

YouTube URL: https://www.youtube.com/watch?v=Ed50t6A14a8


