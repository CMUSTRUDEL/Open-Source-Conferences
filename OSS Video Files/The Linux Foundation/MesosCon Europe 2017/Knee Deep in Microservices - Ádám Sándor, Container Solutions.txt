Title: Knee Deep in Microservices - Ádám Sándor, Container Solutions
Publication date: 2017-10-27
Playlist: MesosCon Europe 2017
Description: 
	Knee Deep in Microservices - Ádám Sándor, Container Solutions

Microservices are frequently presented as the architectural style for huge applications developed by tens of teams on the scale of Netflix. Yet it can be a sound architectural principle regardless team size or application complexity. Those who wish to harness the power of microservices should however be aware of the demos that lurk on the other side. Requirements on test and production environments, self-healing, monitoring and the DevOps culture become tougher when your application is composed of independent services. The good news is, an arsenal of Cloud Native technologies like DC/OS is quickly maturing to help tackle the demons of microservice architectures.

About Ádám Sándor
Adam moved from application development to a consultancy career in cloud native computing. He currently works at Amsterdam-based consultancy Container Solutions. He is helping companies succeed in improving their delivery of business critical software by combining his application development experience with knowledge of container-based infrastructure.
Captions: 
	00:00:00,030 --> 00:00:07,529
so hello mrs. Cohen nobody then praha

00:00:04,069 --> 00:00:10,469
it's great to be back in this town I was

00:00:07,529 --> 00:00:15,809
living here for a few years two years

00:00:10,469 --> 00:00:18,930
ago and great to be at mrs. Kahn so I'm

00:00:15,809 --> 00:00:21,800
Adam Sandor I work for container

00:00:18,930 --> 00:00:24,900
solutions and amsterdam-based

00:00:21,800 --> 00:00:28,080
consultancy company specializing in

00:00:24,900 --> 00:00:31,109
helping other companies utilize cloud

00:00:28,080 --> 00:00:34,590
native technologies to deliver software

00:00:31,109 --> 00:00:40,320
better faster more resilient all that

00:00:34,590 --> 00:00:44,579
stuff and today's talk was partially

00:00:40,320 --> 00:00:46,530
inspired by my favorite video game

00:00:44,579 --> 00:00:50,010
called doom

00:00:46,530 --> 00:00:51,120
who here has played the old one from

00:00:50,010 --> 00:00:57,210
night Wow

00:00:51,120 --> 00:00:59,309
awesome crowd great the new one not that

00:00:57,210 --> 00:01:02,760
many okay do play the new one it's

00:00:59,309 --> 00:01:06,180
 awesome I was very surprised by

00:01:02,760 --> 00:01:09,210
how awesome it is so how does doom come

00:01:06,180 --> 00:01:14,490
into a talk about micro services and

00:01:09,210 --> 00:01:17,790
cloud native technologies doom the story

00:01:14,490 --> 00:01:21,270
of doom is about scientists on Mars

00:01:17,790 --> 00:01:25,740
trying to solve Earthies energy crisis

00:01:21,270 --> 00:01:29,850
and they go as far as to open a portal

00:01:25,740 --> 00:01:32,579
to Hell to harness the energy of Hell as

00:01:29,850 --> 00:01:37,200
a clean source of energy turns out it's

00:01:32,579 --> 00:01:40,710
not all that clean and demons invade

00:01:37,200 --> 00:01:42,600
Mars and later earth and all that stands

00:01:40,710 --> 00:01:44,759
before them they practically wipe out

00:01:42,600 --> 00:01:47,430
everybody anyway but our hero goes and

00:01:44,759 --> 00:01:54,140
the doom guy just goes and kills them

00:01:47,430 --> 00:01:59,909
kills them all anyway so companies who

00:01:54,140 --> 00:02:02,640
go and start adopting microservices I'll

00:01:59,909 --> 00:02:07,079
talk a bit more why is that a good idea

00:02:02,640 --> 00:02:10,830
but what happens many times is that they

00:02:07,079 --> 00:02:13,620
go for this new architectural style go

00:02:10,830 --> 00:02:13,980
for for utilizing the cloud breaking up

00:02:13,620 --> 00:02:16,769
their

00:02:13,980 --> 00:02:20,879
applications delivering faster and they

00:02:16,769 --> 00:02:24,659
unleash a host of demons on themselves

00:02:20,879 --> 00:02:27,299
and if they're not prepared then those

00:02:24,659 --> 00:02:34,950
demons gonna cause him a lot of trouble

00:02:27,299 --> 00:02:37,140
at the very least but in a few a few

00:02:34,950 --> 00:02:39,150
years ago it was really like like this a

00:02:37,140 --> 00:02:40,950
lot of companies went down this road and

00:02:39,150 --> 00:02:43,560
really burned themselves because they're

00:02:40,950 --> 00:02:46,349
burned proper tools around to manage the

00:02:43,560 --> 00:02:50,099
complexity introduced by a highly

00:02:46,349 --> 00:02:54,060
distributed architecture but today we

00:02:50,099 --> 00:02:56,670
have new weapons that has been that have

00:02:54,060 --> 00:02:59,040
been invented in the past few years like

00:02:56,670 --> 00:03:02,310
darker and container orchestration that

00:02:59,040 --> 00:03:04,739
really help us tackle running

00:03:02,310 --> 00:03:09,420
distributed systems I would say they

00:03:04,739 --> 00:03:12,540
take it so far now that we should be

00:03:09,420 --> 00:03:15,150
architecting applications as micro

00:03:12,540 --> 00:03:16,769
services there is very smart people

00:03:15,150 --> 00:03:18,810
saying monoliths are fine

00:03:16,769 --> 00:03:21,840
don't don't overdo the whole micro

00:03:18,810 --> 00:03:25,980
service thing and they're right but the

00:03:21,840 --> 00:03:29,519
the costs associated with running micro

00:03:25,980 --> 00:03:32,910
services previously is is mitigated a

00:03:29,519 --> 00:03:37,980
lot by the fancy new tooling we have

00:03:32,910 --> 00:03:39,870
like mesos for example so just a bit of

00:03:37,980 --> 00:03:43,109
definition of what do I mean really by

00:03:39,870 --> 00:03:47,880
micro services I mean services where

00:03:43,109 --> 00:03:51,680
code is independent so no Commons

00:03:47,880 --> 00:03:55,319
library where 90% of the code resides

00:03:51,680 --> 00:03:57,810
the code is largely independent they are

00:03:55,319 --> 00:04:00,739
packaged as independent artifacts and

00:03:57,810 --> 00:04:03,989
they are ran in production as

00:04:00,739 --> 00:04:07,859
independent pieces managed by while a

00:04:03,989 --> 00:04:11,370
container Orchestrator of course so not

00:04:07,859 --> 00:04:13,290
like this not deploy two VMs just a few

00:04:11,370 --> 00:04:15,419
VMs and many applications running on the

00:04:13,290 --> 00:04:18,329
same VM because in this case the

00:04:15,419 --> 00:04:19,949
production system doesn't really know

00:04:18,329 --> 00:04:21,419
what you're really running it just is

00:04:19,949 --> 00:04:24,090
there is some VMs and there is some

00:04:21,419 --> 00:04:26,159
stuff running on them probably and also

00:04:24,090 --> 00:04:27,810
not the old-school monolithic thing of

00:04:26,159 --> 00:04:30,180
course we knew how to modular

00:04:27,810 --> 00:04:33,450
applications before microservices micro

00:04:30,180 --> 00:04:39,270
sources are not just about splitting

00:04:33,450 --> 00:04:42,540
code up but so modularized code but then

00:04:39,270 --> 00:04:45,419
packaged into a single artifact again it

00:04:42,540 --> 00:04:47,880
will not provide the benefits that a

00:04:45,419 --> 00:04:51,900
micro service architecture does so back

00:04:47,880 --> 00:04:55,889
this is what I'm talking about and why

00:04:51,900 --> 00:04:58,380
would we want to adopt a micro service

00:04:55,889 --> 00:05:02,669
architecture basically the most

00:04:58,380 --> 00:05:05,850
important thing is to leverage the

00:05:02,669 --> 00:05:08,940
elastic cloud resources that are

00:05:05,850 --> 00:05:13,010
available to us from mostly public cloud

00:05:08,940 --> 00:05:15,300
providers or internal clouds so a

00:05:13,010 --> 00:05:19,590
monolithic application that only

00:05:15,300 --> 00:05:22,190
supports vertical scaling is not able to

00:05:19,590 --> 00:05:24,330
leverage this new type of base

00:05:22,190 --> 00:05:29,120
infrastructure that is available out

00:05:24,330 --> 00:05:32,190
there and it's also not able to leverage

00:05:29,120 --> 00:05:35,940
new tooling that we have for more

00:05:32,190 --> 00:05:39,390
resilient deployment I will talk about

00:05:35,940 --> 00:05:41,250
that later but basically with micro

00:05:39,390 --> 00:05:44,460
services we want to increase development

00:05:41,250 --> 00:05:46,470
velocity especially down the line when

00:05:44,460 --> 00:05:48,300
we have lots of services and we really

00:05:46,470 --> 00:05:49,860
want to deploy them independently to

00:05:48,300 --> 00:05:52,140
know that we are not breaking the ones

00:05:49,860 --> 00:05:54,600
that we are not deploying right now with

00:05:52,140 --> 00:05:56,940
the monolith you just can't do that

00:05:54,600 --> 00:06:03,450
because you have to always deploy

00:05:56,940 --> 00:06:06,570
everything okay the other thing is

00:06:03,450 --> 00:06:09,150
resilience so when we had just a few

00:06:06,570 --> 00:06:14,880
servers in the basement resilience was

00:06:09,150 --> 00:06:16,560
not such a big deal or we had but now of

00:06:14,880 --> 00:06:19,680
course big companies were doing this

00:06:16,560 --> 00:06:22,289
before already but for smaller and

00:06:19,680 --> 00:06:25,500
medium-sized companies they rather

00:06:22,289 --> 00:06:28,080
ignore this problem but now with cloud

00:06:25,500 --> 00:06:30,090
providers everybody can build resilience

00:06:28,080 --> 00:06:31,950
into their application everybody can

00:06:30,090 --> 00:06:34,289
scale out everybody can run several

00:06:31,950 --> 00:06:37,440
instances over geographical regions or

00:06:34,289 --> 00:06:40,020
at least availability zones and there is

00:06:37,440 --> 00:06:41,520
the elasticity to actually optimize your

00:06:40,020 --> 00:06:44,310
cloud bill to only

00:06:41,520 --> 00:06:47,039
so much compute some so many instances

00:06:44,310 --> 00:06:51,770
of things that you that you need and

00:06:47,039 --> 00:06:54,840
that you can scale out scaling etc so

00:06:51,770 --> 00:06:59,280
this talk will take you down on the

00:06:54,840 --> 00:07:04,710
first episode of doom bit retitled the

00:06:59,280 --> 00:07:09,150
levels and I will show all the the

00:07:04,710 --> 00:07:11,819
demons all the problems that companies

00:07:09,150 --> 00:07:15,000
run into and cloud native technologies

00:07:11,819 --> 00:07:16,919
help tackle there is other challenges

00:07:15,000 --> 00:07:18,810
with micro services that I will not be

00:07:16,919 --> 00:07:22,080
talking about I'm focusing on the things

00:07:18,810 --> 00:07:25,280
where the containers and orchestration

00:07:22,080 --> 00:07:32,039
and stuff actually help so first

00:07:25,280 --> 00:07:35,280
packaging the one of the things micro

00:07:32,039 --> 00:07:37,849
service is a micro service architecture

00:07:35,280 --> 00:07:41,250
allows and people love to utilize is

00:07:37,849 --> 00:07:42,990
having different types of code bases

00:07:41,250 --> 00:07:49,080
different programming languages mixed

00:07:42,990 --> 00:07:53,270
together but once you have but and we

00:07:49,080 --> 00:07:56,039
needed a packaging a proper packaging to

00:07:53,270 --> 00:07:58,139
support all these we didn't have that

00:07:56,039 --> 00:08:01,349
before like running a jar file or a VAR

00:07:58,139 --> 00:08:03,240
file from Java in production was

00:08:01,349 --> 00:08:05,219
completely different than running a ruby

00:08:03,240 --> 00:08:07,110
application or a PHP application they

00:08:05,219 --> 00:08:10,530
require different runtimes different

00:08:07,110 --> 00:08:11,729
ways of deployment etc so Along Came

00:08:10,530 --> 00:08:15,030
docker

00:08:11,729 --> 00:08:16,740
which in my bit twisted analogy is the

00:08:15,030 --> 00:08:17,219
chainsaw with which you can kill all of

00:08:16,740 --> 00:08:18,569
them

00:08:17,219 --> 00:08:20,849
of course you can kill all of them with

00:08:18,569 --> 00:08:25,159
all the other weapons too but I really

00:08:20,849 --> 00:08:28,139
do love the chainsaw and so basically

00:08:25,159 --> 00:08:30,590
also it's a bit of a metaphor for darker

00:08:28,139 --> 00:08:33,450
helping us like carve up that Monell it

00:08:30,590 --> 00:08:35,099
especially that big fat one on the right

00:08:33,450 --> 00:08:38,909
the monkey boosts that that's the right

00:08:35,099 --> 00:08:40,770
for you but left yeah so so docker came

00:08:38,909 --> 00:08:42,570
along and of course containers existed

00:08:40,770 --> 00:08:45,450
before docker but I'm just simplifying

00:08:42,570 --> 00:08:48,450
it for to say that especially in the

00:08:45,450 --> 00:08:51,570
mezzos world containers were around for

00:08:48,450 --> 00:08:54,110
a while but but docker is really the one

00:08:51,570 --> 00:08:56,780
that made it really easy to

00:08:54,110 --> 00:08:58,910
utilize containers and suddenly it

00:08:56,780 --> 00:09:02,870
became straightforward to package any

00:08:58,910 --> 00:09:06,710
kind of application and ship it in that

00:09:02,870 --> 00:09:09,440
package to production that's one of the

00:09:06,710 --> 00:09:12,260
big improvements docker made on our

00:09:09,440 --> 00:09:14,420
software development the other is the

00:09:12,260 --> 00:09:17,270
docker actually supports the whole

00:09:14,420 --> 00:09:20,150
software development lifecycle so it's a

00:09:17,270 --> 00:09:25,760
build tool it can run your tests and it

00:09:20,150 --> 00:09:29,570
can push to a container registry to to

00:09:25,760 --> 00:09:31,580
host your artifacts we did have artifact

00:09:29,570 --> 00:09:33,620
registries before Java had a whole

00:09:31,580 --> 00:09:37,910
ecosystem for this but that only worked

00:09:33,620 --> 00:09:40,220
for Java we had built tools before but

00:09:37,910 --> 00:09:42,620
you had to make sure to install whatever

00:09:40,220 --> 00:09:44,900
your application your build pipeline

00:09:42,620 --> 00:09:47,780
needed on the Jenkins server or wherever

00:09:44,900 --> 00:09:50,420
now everything can can be done with

00:09:47,780 --> 00:09:53,720
docker in a nice and easy way which is a

00:09:50,420 --> 00:09:56,470
big step forward in in managing large

00:09:53,720 --> 00:09:58,370
application code bases with different

00:09:56,470 --> 00:10:04,040
potential different programming

00:09:58,370 --> 00:10:07,370
languages then our next thing is

00:10:04,040 --> 00:10:10,520
continuous delivery now basically the

00:10:07,370 --> 00:10:13,460
more application components you have the

00:10:10,520 --> 00:10:17,480
more of these pipelines you will have to

00:10:13,460 --> 00:10:19,070
manage the code test build deploy to

00:10:17,480 --> 00:10:21,380
some test environment deploy to

00:10:19,070 --> 00:10:25,340
production or another acceptance

00:10:21,380 --> 00:10:28,310
environment or whatever to achieve good

00:10:25,340 --> 00:10:32,090
continuous delivery all of these steps

00:10:28,310 --> 00:10:34,880
must work flawlessly and fast again now

00:10:32,090 --> 00:10:37,670
we have docker to support many of these

00:10:34,880 --> 00:10:40,010
steps and also container orchestrators

00:10:37,670 --> 00:10:42,650
which I'll get around in a moment the

00:10:40,010 --> 00:10:44,930
important thing is to manage a micro

00:10:42,650 --> 00:10:47,120
service application you will have many

00:10:44,930 --> 00:10:50,090
of these pipelines for each of your

00:10:47,120 --> 00:10:53,240
components you have to get them right

00:10:50,090 --> 00:10:55,190
each of them I in this talk I can't go

00:10:53,240 --> 00:10:58,760
into details how to exactly do each of

00:10:55,190 --> 00:11:00,080
the steps actually they are not that

00:10:58,760 --> 00:11:02,900
different in how we were doing things

00:11:00,080 --> 00:11:04,340
but you have to get them right because

00:11:02,900 --> 00:11:06,740
the more applications the more

00:11:04,340 --> 00:11:09,079
components you will have the more the

00:11:06,740 --> 00:11:11,300
harder it

00:11:09,079 --> 00:11:13,850
there's also another important thing in

00:11:11,300 --> 00:11:15,980
this picture is you can see all of them

00:11:13,850 --> 00:11:19,190
have different version at any point in

00:11:15,980 --> 00:11:21,470
time so don't tie your components

00:11:19,190 --> 00:11:25,220
together have a have continuous delivery

00:11:21,470 --> 00:11:27,769
on each of the components because that's

00:11:25,220 --> 00:11:29,600
what will enable you to keep your

00:11:27,769 --> 00:11:32,149
velocity down the line when you have

00:11:29,600 --> 00:11:33,889
lots of components if you I see

00:11:32,149 --> 00:11:36,199
companies doing micro services and then

00:11:33,889 --> 00:11:38,540
do big bank releases with all their

00:11:36,199 --> 00:11:40,220
micro services at the same time that

00:11:38,540 --> 00:11:42,620
does help a bit we'd like backwards

00:11:40,220 --> 00:11:46,070
compatibility and like that kind of

00:11:42,620 --> 00:11:47,810
stuff but it's way better to invest in

00:11:46,070 --> 00:11:50,839
the backwards compatibility and in

00:11:47,810 --> 00:11:52,639
making sure that services can talk to

00:11:50,839 --> 00:11:55,360
the older version of the other service

00:11:52,639 --> 00:11:58,220
rather than doing the big bank releases

00:11:55,360 --> 00:12:00,470
also when you have like lots of

00:11:58,220 --> 00:12:03,290
components just knowing that you're only

00:12:00,470 --> 00:12:04,699
deploying that one thing and not

00:12:03,290 --> 00:12:08,180
potentially breaking the whole

00:12:04,699 --> 00:12:12,050
application is a big plus so continuous

00:12:08,180 --> 00:12:15,260
delivery is was a very good idea before

00:12:12,050 --> 00:12:20,959
and it's really essential if you're

00:12:15,260 --> 00:12:23,779
running micro service applications and

00:12:20,959 --> 00:12:25,339
now got that whole build stuff out of

00:12:23,779 --> 00:12:27,529
the way we're coming to the really

00:12:25,339 --> 00:12:29,630
interesting part the scheduling of

00:12:27,529 --> 00:12:35,060
course this is meso Scone so all of you

00:12:29,630 --> 00:12:37,819
know what a container scheduler is but I

00:12:35,060 --> 00:12:40,399
would still hope that you find something

00:12:37,819 --> 00:12:42,949
interesting in what I'm going to say

00:12:40,399 --> 00:12:44,480
because what I'm I try to approach this

00:12:42,949 --> 00:12:49,970
problem not from the point of view of

00:12:44,480 --> 00:12:53,690
how to run containers on nodes and stuff

00:12:49,970 --> 00:12:54,980
but why is container scheduling and

00:12:53,690 --> 00:12:57,740
orchestration and all this stuff

00:12:54,980 --> 00:12:59,569
important for our application

00:12:57,740 --> 00:13:04,339
development how does this really help

00:12:59,569 --> 00:13:06,170
and yeah so resource allocation in a

00:13:04,339 --> 00:13:08,209
distributed environment I put a really

00:13:06,170 --> 00:13:10,910
big monster the cyberdemon up for that

00:13:08,209 --> 00:13:13,130
one because that's a really hard problem

00:13:10,910 --> 00:13:15,230
not just the resource allocation but

00:13:13,130 --> 00:13:17,060
also other distributed problems like

00:13:15,230 --> 00:13:20,569
configure managing configurations and

00:13:17,060 --> 00:13:21,560
stuff but actually for this is the

00:13:20,569 --> 00:13:24,010
problem

00:13:21,560 --> 00:13:26,480
that many have set out to tackle and

00:13:24,010 --> 00:13:29,630
actually we are really succeeding now so

00:13:26,480 --> 00:13:33,700
we have our BFG our big gun that

00:13:29,630 --> 00:13:40,279
in the form of for example mezzos to

00:13:33,700 --> 00:13:43,160
kill that son of a and yeah that's

00:13:40,279 --> 00:13:49,310
that's that's is really dead there it's

00:13:43,160 --> 00:13:51,770
not much remaining well that's it's it's

00:13:49,310 --> 00:13:53,300
kind of a a problem we're I think we

00:13:51,770 --> 00:13:55,610
were really solving very well but what

00:13:53,300 --> 00:13:58,970
let's let's get back to the basics so

00:13:55,610 --> 00:14:01,910
what is container scheduling basically

00:13:58,970 --> 00:14:03,740
once containers came around and became

00:14:01,910 --> 00:14:07,550
really easy to use the funny thing was

00:14:03,740 --> 00:14:12,020
that you can run them on any Linux

00:14:07,550 --> 00:14:13,910
machine but public clouds are not Linux

00:14:12,020 --> 00:14:18,230
machines public clouds are giant

00:14:13,910 --> 00:14:21,260
hypervisors so you actually have to spin

00:14:18,230 --> 00:14:25,130
up machines to be able to run containers

00:14:21,260 --> 00:14:27,020
on top of them which in a cloud

00:14:25,130 --> 00:14:29,240
environment is a bit of a hassle of

00:14:27,020 --> 00:14:30,410
course if you're using physical Hardware

00:14:29,240 --> 00:14:32,690
it's a no-brainer

00:14:30,410 --> 00:14:35,390
that's why containers actually came out

00:14:32,690 --> 00:14:38,210
of companies who were trying to utilize

00:14:35,390 --> 00:14:43,030
their physical hardware like Twitter and

00:14:38,210 --> 00:14:46,880
Google but still you spin up a few nodes

00:14:43,030 --> 00:14:49,880
so so how the or container scheduler

00:14:46,880 --> 00:14:52,130
works is there is one or more master

00:14:49,880 --> 00:14:55,370
nodes but we can just logically call it

00:14:52,130 --> 00:14:57,680
like one master that manages a set of

00:14:55,370 --> 00:14:59,870
virtual machines these virtual machines

00:14:57,680 --> 00:15:04,910
have their IP addresses and stuff and

00:14:59,870 --> 00:15:07,730
once you want to run containers you the

00:15:04,910 --> 00:15:10,760
master will decide where is the best to

00:15:07,730 --> 00:15:15,709
run them and these containers start up

00:15:10,760 --> 00:15:19,120
as docker containers on the on the nodes

00:15:15,709 --> 00:15:22,540
wherever the master decides to put them

00:15:19,120 --> 00:15:28,160
first problem each of these containers

00:15:22,540 --> 00:15:31,430
needs a port as you can see there you

00:15:28,160 --> 00:15:34,339
cannot trust your front-end containers

00:15:31,430 --> 00:15:35,640
to always run on port 3000 in this case

00:15:34,339 --> 00:15:38,570
because

00:15:35,640 --> 00:15:41,610
if you run two of them on the same note

00:15:38,570 --> 00:15:45,660
then they will collide so you have to

00:15:41,610 --> 00:15:49,530
start managing ports which is really not

00:15:45,660 --> 00:15:51,660
something so this is the DevOps track so

00:15:49,530 --> 00:15:54,530
I'll try to highlight this from the

00:15:51,660 --> 00:15:57,870
point of view of collaboration from

00:15:54,530 --> 00:16:01,020
between developers and operations so

00:15:57,870 --> 00:16:04,370
first thing this system is not enough

00:16:01,020 --> 00:16:07,140
because developers delivering software

00:16:04,370 --> 00:16:10,110
don't want to care about port mapping

00:16:07,140 --> 00:16:15,060
stuff and if you only have this if you

00:16:10,110 --> 00:16:16,830
only have mezzos you will they will have

00:16:15,060 --> 00:16:19,740
to care about the port mapping they will

00:16:16,830 --> 00:16:22,500
have to build logic into the application

00:16:19,740 --> 00:16:27,240
to manage the ports and somehow find the

00:16:22,500 --> 00:16:33,870
services so here is a short list of the

00:16:27,240 --> 00:16:39,030
most used container schedulers mesos

00:16:33,870 --> 00:16:42,270
kubernetes em AWS ccs nomads docker

00:16:39,030 --> 00:16:45,510
swarm they all do a great job of

00:16:42,270 --> 00:16:49,920
managing your resources in a cluster of

00:16:45,510 --> 00:16:51,990
computers but because of these

00:16:49,920 --> 00:16:54,480
networking port mapping problems and

00:16:51,990 --> 00:16:57,840
also the problem of how the hell to find

00:16:54,480 --> 00:17:02,760
your error instances let's say I want to

00:16:57,840 --> 00:17:05,010
talk to a front-end pod container then I

00:17:02,760 --> 00:17:08,370
need to build a service discovery

00:17:05,010 --> 00:17:10,770
mechanism where a container comes up

00:17:08,370 --> 00:17:12,959
registers itself like console or @ CD

00:17:10,770 --> 00:17:15,030
and then other containers must know that

00:17:12,959 --> 00:17:17,340
that service discovery mechanism exists

00:17:15,030 --> 00:17:20,880
and they have to talk to it and get the

00:17:17,340 --> 00:17:23,640
current state of the cluster so that's

00:17:20,880 --> 00:17:26,790
still not a proper micro service

00:17:23,640 --> 00:17:31,710
platform how do we get from a scheduler

00:17:26,790 --> 00:17:35,580
to a micro service platform well solving

00:17:31,710 --> 00:17:36,870
the networking problem so it's very for

00:17:35,580 --> 00:17:38,760
me I come from an application

00:17:36,870 --> 00:17:40,680
development background into the world of

00:17:38,760 --> 00:17:42,930
operations and it's really weird for me

00:17:40,680 --> 00:17:44,550
that these these are like hard problems

00:17:42,930 --> 00:17:47,040
this whole networking thing and with the

00:17:44,550 --> 00:17:49,190
ports and everything but it is it can be

00:17:47,040 --> 00:17:52,640
sold but it's it's it's

00:17:49,190 --> 00:17:55,100
so first thing we do we have to

00:17:52,640 --> 00:18:00,850
introduce a virtual network for our

00:17:55,100 --> 00:18:03,860
containers in the container cluster so

00:18:00,850 --> 00:18:06,290
if we introduce a virtual network

00:18:03,860 --> 00:18:10,670
suddenly our all our containers can get

00:18:06,290 --> 00:18:13,880
their own IP addresses so suddenly they

00:18:10,670 --> 00:18:17,360
can run on the port they wish to run on

00:18:13,880 --> 00:18:20,240
so this problem has shifted from

00:18:17,360 --> 00:18:24,200
development to operations into the

00:18:20,240 --> 00:18:27,050
platform now to make that happen with

00:18:24,200 --> 00:18:29,600
the virtual network is a tricky problem

00:18:27,050 --> 00:18:32,960
it's pretty much sold now we have

00:18:29,600 --> 00:18:35,960
overlay networks and we have IP tables

00:18:32,960 --> 00:18:37,790
magic happening at least I know more or

00:18:35,960 --> 00:18:40,460
less how it works in kubernetes it's all

00:18:37,790 --> 00:18:45,170
a lot of magic in like rewriting packets

00:18:40,460 --> 00:18:48,830
addresses in IP tables it's it works it

00:18:45,170 --> 00:18:51,410
does the job we have IP s per container

00:18:48,830 --> 00:18:53,330
I'm still a bit surprised at indie cos

00:18:51,410 --> 00:18:56,690
this is still an extra feature you turn

00:18:53,330 --> 00:19:01,100
on but it is there again it works and

00:18:56,690 --> 00:19:03,890
and you can you can wish away the whole

00:19:01,100 --> 00:19:05,840
port mapping problem of course ports

00:19:03,890 --> 00:19:08,050
will still be mapped to certain note

00:19:05,840 --> 00:19:10,340
ports but now it's so randomized and

00:19:08,050 --> 00:19:14,470
basically as a developer you don't have

00:19:10,340 --> 00:19:19,150
to care about it the next step is

00:19:14,470 --> 00:19:21,590
solving the service discovery problem so

00:19:19,150 --> 00:19:24,080
actually even before we started

00:19:21,590 --> 00:19:26,210
distributing you all our applications we

00:19:24,080 --> 00:19:29,059
had service discovery mechanisms even

00:19:26,210 --> 00:19:31,160
inside like single processes like for

00:19:29,059 --> 00:19:33,830
example Java Enterprise Edition or

00:19:31,160 --> 00:19:35,750
spring basically instantiate components

00:19:33,830 --> 00:19:38,150
and then make sure components can find

00:19:35,750 --> 00:19:40,429
each other but it all happens inside one

00:19:38,150 --> 00:19:42,200
process space so it's a whole whole

00:19:40,429 --> 00:19:44,420
different kind of logically the same

00:19:42,200 --> 00:19:47,990
problem but of course the solution is

00:19:44,420 --> 00:19:48,790
much actually simpler also but also very

00:19:47,990 --> 00:19:53,600
different

00:19:48,790 --> 00:19:55,550
how do container orchestrators and I

00:19:53,600 --> 00:19:57,830
kind of distinguish between like the

00:19:55,550 --> 00:19:59,360
schedulers are just that the scheduling

00:19:57,830 --> 00:20:01,130
part is just placement and like

00:19:59,360 --> 00:20:02,210
orchestration is like all these extra

00:20:01,130 --> 00:20:04,040
features I'm not sure

00:20:02,210 --> 00:20:06,350
I'm using that term correctly but I

00:20:04,040 --> 00:20:11,260
don't think anybody has ever defined it

00:20:06,350 --> 00:20:14,380
very well so the container orchestrators

00:20:11,260 --> 00:20:17,690
DCOs does this in the form of whips

00:20:14,380 --> 00:20:22,070
basically enable you to create something

00:20:17,690 --> 00:20:25,160
like a service that is a virtual IP

00:20:22,070 --> 00:20:27,860
address inside your virtual network and

00:20:25,160 --> 00:20:30,860
if you talk to that virtual IP address

00:20:27,860 --> 00:20:33,800
your packets will get routed to the

00:20:30,860 --> 00:20:36,460
right backing containers so now when

00:20:33,800 --> 00:20:38,720
back-end wants to talk to the front-end

00:20:36,460 --> 00:20:44,180
actually it's usually the other way

00:20:38,720 --> 00:20:49,390
around but whatever you get the point so

00:20:44,180 --> 00:20:52,610
the the backend can talk to 10 10 8 10

00:20:49,390 --> 00:20:58,370
which is not the IP of any container and

00:20:52,610 --> 00:21:01,150
the the the requests get routed using a

00:20:58,370 --> 00:21:03,710
load balancing mechanism to any

00:21:01,150 --> 00:21:08,720
front-end container that happens to run

00:21:03,710 --> 00:21:12,320
and however tricky it is to implement

00:21:08,720 --> 00:21:14,450
this this leap mechanism the scheduler

00:21:12,320 --> 00:21:16,160
it was possible to build this because

00:21:14,450 --> 00:21:17,990
the scheduler already has all the

00:21:16,160 --> 00:21:21,440
information necessary for this it knows

00:21:17,990 --> 00:21:24,410
where those front end containers run so

00:21:21,440 --> 00:21:26,030
it's possible to well and once the

00:21:24,410 --> 00:21:28,730
virtual network has been added now

00:21:26,030 --> 00:21:30,620
suddenly you can create virtual IPS in

00:21:28,730 --> 00:21:33,050
your virtual network and create

00:21:30,620 --> 00:21:35,240
something like a front end a virtual

00:21:33,050 --> 00:21:38,330
front end service that happens to be

00:21:35,240 --> 00:21:42,320
backed by a number of containers running

00:21:38,330 --> 00:21:45,590
over some servers add a bit of DNS to

00:21:42,320 --> 00:21:49,370
that and call that IP address front end

00:21:45,590 --> 00:21:52,910
not internal and suddenly you can even

00:21:49,370 --> 00:21:57,050
hard code the address of the front end

00:21:52,910 --> 00:21:58,910
into your back-end containers because

00:21:57,050 --> 00:22:02,120
you no longer you have to configure that

00:21:58,910 --> 00:22:04,250
you can just rely on the cluster DNS to

00:22:02,120 --> 00:22:05,900
be there let's say if it's an internal

00:22:04,250 --> 00:22:08,330
application and you kind of know that

00:22:05,900 --> 00:22:11,300
you will be deploying to that production

00:22:08,330 --> 00:22:13,610
environment that you always do then you

00:22:11,300 --> 00:22:15,350
can even hard code front-end that

00:22:13,610 --> 00:22:16,000
internal that that's the address of the

00:22:15,350 --> 00:22:19,660
front and

00:22:16,000 --> 00:22:24,240
just let the orchestrator take care of

00:22:19,660 --> 00:22:27,640
it so the service abstraction is

00:22:24,240 --> 00:22:30,870
essential to building a micro service

00:22:27,640 --> 00:22:37,180
platform this takes away all the pain of

00:22:30,870 --> 00:22:40,720
discovering also load balancing from the

00:22:37,180 --> 00:22:44,230
developers to and moves it all into a

00:22:40,720 --> 00:22:46,210
platform managed by operations you can

00:22:44,230 --> 00:22:49,180
see this evolution happening in the past

00:22:46,210 --> 00:22:52,330
few years because the best is to see

00:22:49,180 --> 00:22:54,510
like spring does anybody here know

00:22:52,330 --> 00:22:57,550
spring cloud the spring cloud project

00:22:54,510 --> 00:22:58,300
okay not many people all right oh yeah

00:22:57,550 --> 00:23:01,380
okay cool

00:22:58,300 --> 00:23:05,710
so spring cloud really is still a

00:23:01,380 --> 00:23:07,720
project built on on working around these

00:23:05,710 --> 00:23:09,760
limitations of public clouds where this

00:23:07,720 --> 00:23:11,950
functionality doesn't really exist so

00:23:09,760 --> 00:23:15,490
there is client-side load balancing

00:23:11,950 --> 00:23:17,740
client-side service discovery using

00:23:15,490 --> 00:23:20,140
something like console etc this is all

00:23:17,740 --> 00:23:21,790
stuff what Netflix did their thing

00:23:20,140 --> 00:23:23,650
because they were running on Amazon I

00:23:21,790 --> 00:23:25,530
did they didn't yet have all this

00:23:23,650 --> 00:23:31,650
container orchestration goodness

00:23:25,530 --> 00:23:34,990
available so yeah I already told that

00:23:31,650 --> 00:23:38,080
yeah so which ones can be like consider

00:23:34,990 --> 00:23:39,280
which orchestrators or container systems

00:23:38,080 --> 00:23:41,350
can we consider like through

00:23:39,280 --> 00:23:42,700
microservice platforms I would say

00:23:41,350 --> 00:23:44,980
kubernetes DCOs

00:23:42,700 --> 00:23:47,170
lesser degree docker swarm has less

00:23:44,980 --> 00:23:51,030
features but they do have a lot of the

00:23:47,170 --> 00:23:54,700
stuff that is that is needed so so

00:23:51,030 --> 00:23:57,160
Amazon ECS dozen doesn't do any of the

00:23:54,700 --> 00:24:01,480
networking stuff for example mezzos in

00:23:57,160 --> 00:24:04,300
itself doesn't do it so these these are

00:24:01,480 --> 00:24:06,370
the levels of abstraction you're looking

00:24:04,300 --> 00:24:08,740
for unless you're doing some very

00:24:06,370 --> 00:24:11,410
specialized thing you should just just

00:24:08,740 --> 00:24:12,550
go for DCOs if you are using mesos just

00:24:11,410 --> 00:24:14,230
go for DCOs

00:24:12,550 --> 00:24:17,020
because you don't want to burden

00:24:14,230 --> 00:24:19,360
developers with with all that stuff you

00:24:17,020 --> 00:24:21,490
want to provide a platform for them

00:24:19,360 --> 00:24:24,270
where they can just deploy I'll get back

00:24:21,490 --> 00:24:30,150
to that point we'll have a

00:24:24,270 --> 00:24:31,590
few slides about DevOps the end so next

00:24:30,150 --> 00:24:36,809
thing is of course you need to monitor

00:24:31,590 --> 00:24:39,870
your distributed applications and so to

00:24:36,809 --> 00:24:44,850
defeat the observability monsters in

00:24:39,870 --> 00:24:49,800
this talk so monitoring is a very

00:24:44,850 --> 00:24:52,590
interesting case to show because just go

00:24:49,800 --> 00:24:54,750
back here because it was considered a

00:24:52,590 --> 00:24:57,120
big problem to monitor containers

00:24:54,750 --> 00:24:59,100
because virtual machines were monitored

00:24:57,120 --> 00:25:01,020
by an agent running there and monitoring

00:24:59,100 --> 00:25:03,030
a bunch of processes that were running

00:25:01,020 --> 00:25:05,490
on that agent of course the kernel and

00:25:03,030 --> 00:25:07,050
stuff and then application processes

00:25:05,490 --> 00:25:12,900
that you were interested in and then you

00:25:07,050 --> 00:25:15,870
configure which ones to monitor and and

00:25:12,900 --> 00:25:18,750
that data was fed back to the to the

00:25:15,870 --> 00:25:21,090
monitoring system but with containers

00:25:18,750 --> 00:25:24,990
you don't know where your processes will

00:25:21,090 --> 00:25:26,760
be running so suddenly this was a big

00:25:24,990 --> 00:25:28,500
problem that any process you're

00:25:26,760 --> 00:25:31,050
interested in can just start up on any

00:25:28,500 --> 00:25:32,970
one of the nodes it turned out not to be

00:25:31,050 --> 00:25:36,210
such a hard problem because there is a

00:25:32,970 --> 00:25:38,250
very interesting thing with container

00:25:36,210 --> 00:25:40,440
orchestrators they all have very nice

00:25:38,250 --> 00:25:43,020
api and they have a tons of metadata

00:25:40,440 --> 00:25:44,850
inside them about your application so

00:25:43,020 --> 00:25:46,770
suddenly one of your monitoring tools is

00:25:44,850 --> 00:25:49,740
the orchestration tool itself you can

00:25:46,770 --> 00:25:54,300
just go and ask a lot of data about your

00:25:49,740 --> 00:25:57,840
application from it and then and and

00:25:54,300 --> 00:26:00,080
what the monitoring tools did they so

00:25:57,840 --> 00:26:04,620
here is a picture illustrating that that

00:26:00,080 --> 00:26:09,210
this Usui of course showing some data

00:26:04,620 --> 00:26:11,340
about one of your services and then what

00:26:09,210 --> 00:26:13,980
the monitoring solutions did here are

00:26:11,340 --> 00:26:15,660
some examples of cloud native monitoring

00:26:13,980 --> 00:26:21,230
solutions that can call themselves cloud

00:26:15,660 --> 00:26:24,690
native because they really can monitor

00:26:21,230 --> 00:26:27,750
natively applications running on the

00:26:24,690 --> 00:26:30,630
container orchestration clusters so like

00:26:27,750 --> 00:26:33,179
Prometheus tank driver sees the cows

00:26:30,630 --> 00:26:35,820
kale data dog there is probably more of

00:26:33,179 --> 00:26:38,370
them that I didn't mention but there's

00:26:35,820 --> 00:26:40,740
just as much space on a slide actually

00:26:38,370 --> 00:26:44,760
monitoring has really caught up with

00:26:40,740 --> 00:26:46,620
with the world of containers so so what

00:26:44,760 --> 00:26:49,980
they what they do this is an example

00:26:46,620 --> 00:26:52,800
from coast kale is like actually

00:26:49,980 --> 00:26:54,690
monitoring has become easier with

00:26:52,800 --> 00:26:56,400
container orchestration because the

00:26:54,690 --> 00:26:58,260
monitoring tools can just talk to the

00:26:56,400 --> 00:27:00,570
orchestrator ask all about your

00:26:58,260 --> 00:27:03,480
application and high level stuff like

00:27:00,570 --> 00:27:05,880
services not just like this random named

00:27:03,480 --> 00:27:07,440
container running somewhere but because

00:27:05,880 --> 00:27:09,059
the orchestrators now have this service

00:27:07,440 --> 00:27:11,640
abstraction which was originally

00:27:09,059 --> 00:27:14,220
designed to solve networking and service

00:27:11,640 --> 00:27:16,080
discovery problems now the monitoring

00:27:14,220 --> 00:27:18,600
tools can just can just use that data

00:27:16,080 --> 00:27:21,690
and know ok so you have a front-end

00:27:18,600 --> 00:27:23,280
service with five backing containers so

00:27:21,690 --> 00:27:25,530
how much memory is your front-end

00:27:23,280 --> 00:27:27,330
service using well is the sum of the

00:27:25,530 --> 00:27:30,150
memory usage of all the containers that

00:27:27,330 --> 00:27:33,330
happen to be grouped under the front-end

00:27:30,150 --> 00:27:35,340
service and they can grab this metadata

00:27:33,330 --> 00:27:36,870
so you don't even need to configure this

00:27:35,340 --> 00:27:38,880
stuff and I could create a dashboard

00:27:36,870 --> 00:27:42,179
like this in like five minutes in Ko

00:27:38,880 --> 00:27:45,210
scale after it read the metadata of my

00:27:42,179 --> 00:27:48,690
cluster so you can see there is a spike

00:27:45,210 --> 00:27:51,750
in CPU usage of the front-end service

00:27:48,690 --> 00:27:54,240
and here is a spike in number of

00:27:51,750 --> 00:27:56,070
containers of the front-end service the

00:27:54,240 --> 00:27:59,160
labels are a bit messed up but never

00:27:56,070 --> 00:28:01,200
mind that so so that's like an auto

00:27:59,160 --> 00:28:04,679
scaling event on the front end service

00:28:01,200 --> 00:28:06,900
when it's hit by load and you can see

00:28:04,679 --> 00:28:10,470
that this is all this all just just

00:28:06,900 --> 00:28:12,480
makes sense to also not just an

00:28:10,470 --> 00:28:14,910
Operations person but a developer of the

00:28:12,480 --> 00:28:16,290
application who thinks in his codebase

00:28:14,910 --> 00:28:18,540
he thinks in the codebase that I

00:28:16,290 --> 00:28:19,980
developed this front-end thing and I

00:28:18,540 --> 00:28:21,690
don't even care that much that there is

00:28:19,980 --> 00:28:24,030
five or ten of them running how much

00:28:21,690 --> 00:28:26,760
memory is it using okay is it's using a

00:28:24,030 --> 00:28:29,040
lot of CPU an aggregate of that is is

00:28:26,760 --> 00:28:31,710
very useful and I'm not saying that and

00:28:29,040 --> 00:28:34,200
that monitoring individual containers

00:28:31,710 --> 00:28:36,660
and VMs even is is just not necessary

00:28:34,200 --> 00:28:39,600
anymore but you can see how this is

00:28:36,660 --> 00:28:42,090
closer to to a high-level overview of

00:28:39,600 --> 00:28:44,250
your system and also how easy it was to

00:28:42,090 --> 00:28:46,260
implement this and how the monitoring

00:28:44,250 --> 00:28:48,150
solutions did this with the using the

00:28:46,260 --> 00:28:48,690
metadata from the orchestrator is also a

00:28:48,150 --> 00:28:51,360
great thing

00:28:48,690 --> 00:28:53,100
you can build your own tooling in a much

00:28:51,360 --> 00:28:54,960
more easier very simply because the

00:28:53,100 --> 00:28:57,000
tooling you're using on your base

00:28:54,960 --> 00:28:59,940
infrastructure has a higher level of

00:28:57,000 --> 00:29:01,650
abstraction and understands what you are

00:28:59,940 --> 00:29:05,790
running on it what your application is

00:29:01,650 --> 00:29:07,260
actually just a side note on that so one

00:29:05,790 --> 00:29:09,210
of the important things about docker I

00:29:07,260 --> 00:29:11,700
forgot to mention is that it's packaging

00:29:09,210 --> 00:29:13,710
individual application components no

00:29:11,700 --> 00:29:16,050
longer do you package like a bunch of

00:29:13,710 --> 00:29:17,580
things like on a VM but it's always one

00:29:16,050 --> 00:29:21,150
component so once you run it like this

00:29:17,580 --> 00:29:24,660
the orchestrator understands it yeah

00:29:21,150 --> 00:29:26,790
logo creation super important

00:29:24,660 --> 00:29:28,320
not that much has changed around log

00:29:26,790 --> 00:29:30,660
aggregation again you might want to

00:29:28,320 --> 00:29:33,030
aggregate logs of all the containers of

00:29:30,660 --> 00:29:35,340
a service this is from Google strike

00:29:33,030 --> 00:29:37,500
that stack driver I really like this one

00:29:35,340 --> 00:29:39,450
because they did this statistical

00:29:37,500 --> 00:29:41,910
analysis of your logs so like they find

00:29:39,450 --> 00:29:43,920
what is the really interesting part in

00:29:41,910 --> 00:29:45,930
your in your logs and just show like

00:29:43,920 --> 00:29:47,250
that error has been happening really a

00:29:45,930 --> 00:29:50,040
lot of times maybe you should take a

00:29:47,250 --> 00:29:53,550
look at that that's really cool and then

00:29:50,040 --> 00:29:55,260
there is alerting which I mainly it's

00:29:53,550 --> 00:29:57,600
also super important but I mainly

00:29:55,260 --> 00:30:02,130
mention it because of this screenshot

00:29:57,600 --> 00:30:03,960
from the new doom game where they

00:30:02,130 --> 00:30:06,150
actually like put in an error message

00:30:03,960 --> 00:30:08,820
into their system saying demonic

00:30:06,150 --> 00:30:11,030
invasion in progress you know you're

00:30:08,820 --> 00:30:17,690
doing the wrong things once you have to

00:30:11,030 --> 00:30:21,030
put in or you're really well prepared so

00:30:17,690 --> 00:30:23,520
getting towards the end of the talk the

00:30:21,030 --> 00:30:26,220
we are going down to the depths of hell

00:30:23,520 --> 00:30:30,800
and that's cooperating between people

00:30:26,220 --> 00:30:34,770
because hell is really other people and

00:30:30,800 --> 00:30:37,560
that's what DevOps is about trying to

00:30:34,770 --> 00:30:39,360
solve that is to guys end up shooting

00:30:37,560 --> 00:30:41,010
each other a lot instead of shooting you

00:30:39,360 --> 00:30:42,660
which is not a very good idea for them

00:30:41,010 --> 00:30:45,360
because then you just shoot both of them

00:30:42,660 --> 00:30:49,890
it's a beautiful tale of how people

00:30:45,360 --> 00:30:51,570
should cooperate so how do these cloud

00:30:49,890 --> 00:30:55,050
native technologies do they help with

00:30:51,570 --> 00:30:57,630
DevOps of course DevOps is mostly about

00:30:55,050 --> 00:31:01,380
cultural change about not building silos

00:30:57,630 --> 00:31:02,280
in organizations about people who know

00:31:01,380 --> 00:31:04,050
how to run

00:31:02,280 --> 00:31:06,120
in production being friends with the

00:31:04,050 --> 00:31:07,830
people who know how to write things and

00:31:06,120 --> 00:31:10,350
maybe being the same people and just

00:31:07,830 --> 00:31:12,870
having these these full-stack engineers

00:31:10,350 --> 00:31:14,970
who know everything which works up to a

00:31:12,870 --> 00:31:17,490
level but of course specialization was

00:31:14,970 --> 00:31:19,530
doesn't happen just for no good reason

00:31:17,490 --> 00:31:21,570
right there is no people who can really

00:31:19,530 --> 00:31:24,780
keep everything in their head and learn

00:31:21,570 --> 00:31:26,820
all the technologies on both sides so so

00:31:24,780 --> 00:31:28,560
development and operations is two

00:31:26,820 --> 00:31:31,020
separate things up to a certain degree

00:31:28,560 --> 00:31:34,890
is a reality and probably will keep to

00:31:31,020 --> 00:31:38,430
be a reality but what I've seen as as

00:31:34,890 --> 00:31:42,930
proud as obstacles to implementing a

00:31:38,430 --> 00:31:45,180
proper devops culture at companies is it

00:31:42,930 --> 00:31:47,700
is lot of times the tooling and there is

00:31:45,180 --> 00:31:49,740
people screaming on Twitter about it's

00:31:47,700 --> 00:31:51,720
not the tooling it's really it's like

00:31:49,740 --> 00:31:53,790
coaching and people and being nice to

00:31:51,720 --> 00:31:57,960
each other and they are right up to a

00:31:53,790 --> 00:32:00,750
degree but but I've seen initiatives at

00:31:57,960 --> 00:32:02,640
companies when the new DevOps initiative

00:32:00,750 --> 00:32:04,110
is in and then all the the operations

00:32:02,640 --> 00:32:06,810
people get in the same room with the

00:32:04,110 --> 00:32:08,580
engineers and the the engineers show

00:32:06,810 --> 00:32:10,770
them their their Java code and the

00:32:08,580 --> 00:32:13,410
operations show they're 5,000 line

00:32:10,770 --> 00:32:17,220
puppets scripting and then they look at

00:32:13,410 --> 00:32:18,870
each other and shake hands and decide

00:32:17,220 --> 00:32:21,270
this kind is probably not gonna go

00:32:18,870 --> 00:32:27,230
anywhere but let's just have more of

00:32:21,270 --> 00:32:27,230
these meetings and we'll see so

00:32:27,590 --> 00:32:34,380
container orchestration as I said it's

00:32:30,210 --> 00:32:36,060
really a brings a higher level platform

00:32:34,380 --> 00:32:37,920
to your applications kind of like a path

00:32:36,060 --> 00:32:40,950
so passes are good but they're also

00:32:37,920 --> 00:32:41,310
super limiting in what you can do with

00:32:40,950 --> 00:32:43,440
them

00:32:41,310 --> 00:32:47,130
so container orchestration or sit

00:32:43,440 --> 00:32:50,700
between passes and just pop it installed

00:32:47,130 --> 00:32:53,850
VMs in a nice sweet spot where you can

00:32:50,700 --> 00:32:55,920
do a lot of things your way but they

00:32:53,850 --> 00:32:59,300
give you still a high level interface so

00:32:55,920 --> 00:33:03,480
here is an example of a manifest file

00:32:59,300 --> 00:33:06,660
from a kubernetes application this

00:33:03,480 --> 00:33:09,810
describes the kubernetes how it should

00:33:06,660 --> 00:33:11,280
run your front-end I yeah maybe I should

00:33:09,810 --> 00:33:14,600
come up with something just front and

00:33:11,280 --> 00:33:18,289
back-end this is so generic but anyways

00:33:14,600 --> 00:33:21,450
so you can see maybe I can get the

00:33:18,289 --> 00:33:23,940
pointer over there to show some stuff if

00:33:21,450 --> 00:33:28,770
I find out which ok now this is super

00:33:23,940 --> 00:33:32,270
hard this is not good anyway so the

00:33:28,770 --> 00:33:36,090
important part here is you described a

00:33:32,270 --> 00:33:38,539
service you want to run you say how many

00:33:36,090 --> 00:33:41,280
instances it will have you could define

00:33:38,539 --> 00:33:43,080
auto-scaling for each you could you say

00:33:41,280 --> 00:33:45,419
which docker image to run of course as

00:33:43,080 --> 00:33:48,090
the most important part you'll describe

00:33:45,419 --> 00:33:51,570
some ports that need to be exposed you

00:33:48,090 --> 00:33:57,900
describe where the Health Check endpoint

00:33:51,570 --> 00:34:00,750
of your application is you specify some

00:33:57,900 --> 00:34:04,650
environment variables like what log

00:34:00,750 --> 00:34:06,690
level is getting configured so what's

00:34:04,650 --> 00:34:09,090
interesting about this is there is

00:34:06,690 --> 00:34:11,310
barely anything in here that an

00:34:09,090 --> 00:34:13,919
application developer can honestly say

00:34:11,310 --> 00:34:16,770
that he doesn't he or she doesn't care

00:34:13,919 --> 00:34:19,280
about it right this is all stuff that

00:34:16,770 --> 00:34:22,200
really describe that that actually

00:34:19,280 --> 00:34:25,440
developers should be writing down and

00:34:22,200 --> 00:34:28,440
it's formal and it's executable straight

00:34:25,440 --> 00:34:31,280
on the on the production or test or

00:34:28,440 --> 00:34:33,480
whatever environment so it means that

00:34:31,280 --> 00:34:37,080
developers can get their stuff into

00:34:33,480 --> 00:34:39,089
production without asking operations to

00:34:37,080 --> 00:34:42,000
now write some scripting for it or

00:34:39,089 --> 00:34:44,070
whatever like that so suddenly

00:34:42,000 --> 00:34:47,040
distension lot of the tension that

00:34:44,070 --> 00:34:49,080
happens in organizations in the DevOps

00:34:47,040 --> 00:34:52,409
part is that developers want to push and

00:34:49,080 --> 00:34:54,359
operations are like oh because they have

00:34:52,409 --> 00:34:57,349
to do this and that to get the new

00:34:54,359 --> 00:35:01,530
release out and whatever and but once

00:34:57,349 --> 00:35:02,730
your your application platform supports

00:35:01,530 --> 00:35:04,980
this nice high level of abstraction

00:35:02,730 --> 00:35:06,869
where where developers can actually like

00:35:04,980 --> 00:35:08,609
for in a formal way describe their

00:35:06,869 --> 00:35:10,470
application and just get out a new

00:35:08,609 --> 00:35:13,200
release without operations getting

00:35:10,470 --> 00:35:14,780
involved at all that's great that really

00:35:13,200 --> 00:35:17,400
brings a new level of cooperation

00:35:14,780 --> 00:35:19,109
because then operations can start

00:35:17,400 --> 00:35:22,380
focusing on providing new and new

00:35:19,109 --> 00:35:24,480
services to developers and on coaching

00:35:22,380 --> 00:35:26,339
developers on how to write a good

00:35:24,480 --> 00:35:28,090
manifest file and maybe don't run 300

00:35:26,339 --> 00:35:32,650
instances because you will

00:35:28,090 --> 00:35:36,040
get two requests per second so that's

00:35:32,650 --> 00:35:39,160
that's I think a very important shift in

00:35:36,040 --> 00:35:40,780
how we can do DevOps there is still all

00:35:39,160 --> 00:35:42,130
the coaching and the culture and all

00:35:40,780 --> 00:35:45,490
that stuff

00:35:42,130 --> 00:35:47,980
companies do end up with kubernetes or

00:35:45,490 --> 00:35:50,230
DCOs and still in a trench war between

00:35:47,980 --> 00:35:53,020
operations and development if they do if

00:35:50,230 --> 00:35:54,940
they don't take a close look at the

00:35:53,020 --> 00:35:57,190
culture and they don't make people work

00:35:54,940 --> 00:35:59,050
together and don't send the developers

00:35:57,190 --> 00:36:00,790
and the kubernetes training for example

00:35:59,050 --> 00:36:02,320
in this case because then the dual

00:36:00,790 --> 00:36:04,060
person will not want to ride this so

00:36:02,320 --> 00:36:05,590
there is a lot of people things that

00:36:04,060 --> 00:36:08,110
need to be done but they are all like

00:36:05,590 --> 00:36:10,870
doable and not really having to

00:36:08,110 --> 00:36:16,440
understand like the the the puppet

00:36:10,870 --> 00:36:21,070
scripting and that kind of stuff yeah

00:36:16,440 --> 00:36:24,130
last slide if you want to know more

00:36:21,070 --> 00:36:26,290
about cloud native go to the website of

00:36:24,130 --> 00:36:28,570
container solutions I probably should

00:36:26,290 --> 00:36:32,440
have put a URL in here but I'm sure

00:36:28,570 --> 00:36:35,020
you'll be able to find it and we have a

00:36:32,440 --> 00:36:37,090
new book out by Ann Curry worked with us

00:36:35,020 --> 00:36:39,760
on it it's called the cloud native

00:36:37,090 --> 00:36:41,710
attitude and kind of focuses on exactly

00:36:39,760 --> 00:36:44,230
the same stuff I was talking about here

00:36:41,710 --> 00:36:46,390
and how to really think about cloud

00:36:44,230 --> 00:36:48,660
native not they're not specific there is

00:36:46,390 --> 00:36:51,790
case studies of companies and there is

00:36:48,660 --> 00:36:54,280
just just the the mindset you should

00:36:51,790 --> 00:36:56,170
have when when you think about

00:36:54,280 --> 00:37:00,880
implementing these technologies at your

00:36:56,170 --> 00:37:05,480
organization and Q&A thank you

00:37:00,880 --> 00:37:12,690
[Applause]

00:37:05,480 --> 00:37:15,380
any questions it's all very clear or or

00:37:12,690 --> 00:37:23,000
very boring

00:37:15,380 --> 00:37:26,559
sorry lunch yeah thank you very much

00:37:23,000 --> 00:37:26,559

YouTube URL: https://www.youtube.com/watch?v=ivdaUWqZC9c


