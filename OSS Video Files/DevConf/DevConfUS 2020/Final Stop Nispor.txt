Title: Final Stop Nispor
Publication date: 2020-10-06
Playlist: DevConfUS 2020
Description: 
	Speaker: Fernando Fernandez Mancera

To simplify network configuration of Linux hosts, Nmstate provides a declarative method to manage network interfaces, routes and DNS configuration. By also reporting the current network state in the same format used for configuration, the configuration of one host can easily be transferred to another. Additionally, it allows to check the compliance of a host with the intended configuration. For this, it is important to gather the actual runtime/kernel networking configuration instead of the on-disk configuration that might not be applied properly.

On our journey to query the interface runtime status with Nmstate,
NetworkManager and Nispor we faced multiple problems. From on-disk profiles to sysfs to netlink. How is Nispor trying to solve this and how can other projects benefit from this solution using varlink?
Captions: 
	00:00:00,080 --> 00:00:06,080
all right so we have fernando with us um

00:00:03,199 --> 00:00:08,240
so i'm guessing we are gonna go with the

00:00:06,080 --> 00:00:11,519
pre-recorded session here

00:00:08,240 --> 00:00:14,160
yeah it's fine okay perfect so

00:00:11,519 --> 00:00:16,000
i'm gonna share that here in hopkin and

00:00:14,160 --> 00:00:17,680
uh since fernando is here with us if

00:00:16,000 --> 00:00:20,240
anybody has any questions

00:00:17,680 --> 00:00:21,520
please feel free to put it in the chat

00:00:20,240 --> 00:00:24,720
and um

00:00:21,520 --> 00:00:27,760
i'll also post a link to the youtube

00:00:24,720 --> 00:00:29,760
uh pre-recorded video and uh if you're

00:00:27,760 --> 00:00:31,359
facing any technical glitches while

00:00:29,760 --> 00:00:33,200
viewing it here in hopkins

00:00:31,359 --> 00:00:34,719
please feel free to directly watch it

00:00:33,200 --> 00:00:36,880
through youtube

00:00:34,719 --> 00:00:39,440
but also remember to keep your hop-in

00:00:36,880 --> 00:00:44,239
window open for the chat

00:00:39,440 --> 00:00:46,399
and please post any questions

00:00:44,239 --> 00:00:47,600
my name is fernando i work as a software

00:00:46,399 --> 00:00:49,840
engineer at red hat

00:00:47,600 --> 00:00:51,440
on the networking services team my main

00:00:49,840 --> 00:00:53,440
work is on enemy state

00:00:51,440 --> 00:00:54,800
so today i'm going to talk to you about

00:00:53,440 --> 00:00:56,960
our journey on

00:00:54,800 --> 00:00:59,840
gathering the runtime network

00:00:56,960 --> 00:00:59,840
configuration

00:01:00,160 --> 00:01:03,359
these are the main steps of our journey

00:01:03,039 --> 00:01:05,680
and

00:01:03,359 --> 00:01:07,920
hopefully the final stop will be needs

00:01:05,680 --> 00:01:07,920
more

00:01:10,240 --> 00:01:14,080
okay so nm state simplifies network

00:01:12,880 --> 00:01:18,000
configuration of

00:01:14,080 --> 00:01:20,400
linux hosts at home ms state contains

00:01:18,000 --> 00:01:21,280
two components which are lebanon state

00:01:20,400 --> 00:01:24,560
python library

00:01:21,280 --> 00:01:28,080
and enemy state ctl a command line

00:01:24,560 --> 00:01:28,640
it provides a declarative api because to

00:01:28,080 --> 00:01:31,119
manage

00:01:28,640 --> 00:01:33,680
network interfaces roots and dns

00:01:31,119 --> 00:01:33,680
computing

00:01:34,079 --> 00:01:40,320
so nmstec contains three main features

00:01:38,079 --> 00:01:42,479
which are reporting the current states

00:01:40,320 --> 00:01:45,439
so the configuration of one host

00:01:42,479 --> 00:01:48,799
can be easily transferred to another one

00:01:45,439 --> 00:01:51,280
verifies the host configuration with the

00:01:48,799 --> 00:01:52,840
intended configuration when applying a

00:01:51,280 --> 00:01:56,079
decided

00:01:52,840 --> 00:01:59,280
state and if something went wrong

00:01:56,079 --> 00:02:02,799
or the verification fails

00:01:59,280 --> 00:02:05,520
now states allow restoring the previous

00:02:02,799 --> 00:02:05,520
configuration

00:02:05,920 --> 00:02:12,959
well here we have uh the

00:02:09,039 --> 00:02:17,120
jamal uh used by nmstate

00:02:12,959 --> 00:02:20,160
the first one is defining

00:02:17,120 --> 00:02:23,280
an ethernet interface

00:02:20,160 --> 00:02:25,680
with the state up ipv4 addresses

00:02:23,280 --> 00:02:28,640
configure ipv6

00:02:25,680 --> 00:02:29,840
and the right one is configuring a

00:02:28,640 --> 00:02:32,720
billing interface

00:02:29,840 --> 00:02:33,519
with the state app the base basic base

00:02:32,720 --> 00:02:36,720
phase

00:02:33,519 --> 00:02:40,640
and the id the thing is that the

00:02:36,720 --> 00:02:44,000
main idea here is that the user does not

00:02:40,640 --> 00:02:45,980
does not need to know the whole the user

00:02:44,000 --> 00:02:47,599
only need to know

00:02:45,980 --> 00:02:51,840
[Music]

00:02:47,599 --> 00:02:51,840
what do they want

00:02:53,280 --> 00:02:59,920
this is an example of code of the

00:02:56,400 --> 00:03:03,280
of the usage of even a state

00:02:59,920 --> 00:03:06,319
python library here we are gathering the

00:03:03,280 --> 00:03:07,680
current state and we are getting the

00:03:06,319 --> 00:03:10,560
interfaces

00:03:07,680 --> 00:03:11,440
and for each interface we are setting

00:03:10,560 --> 00:03:15,519
the state

00:03:11,440 --> 00:03:18,879
as up finally we are applying the state

00:03:15,519 --> 00:03:22,159
and that's all with nine lines of code

00:03:18,879 --> 00:03:24,239
we can just uh bring up all the

00:03:22,159 --> 00:03:28,640
interfaces of the system

00:03:24,239 --> 00:03:32,000
so liberal state allowed the user

00:03:28,640 --> 00:03:35,599
to automate everything on a simple

00:03:32,000 --> 00:03:35,599
way using python

00:03:37,040 --> 00:03:44,000
why is so important the runtime

00:03:40,640 --> 00:03:46,879
status for us well m states

00:03:44,000 --> 00:03:47,920
must always show the run time network

00:03:46,879 --> 00:03:50,959
status

00:03:47,920 --> 00:03:53,680
if enemy state shows outdated or

00:03:50,959 --> 00:03:54,159
wrong network status it will generate a

00:03:53,680 --> 00:03:57,200
lot of

00:03:54,159 --> 00:04:01,040
issues because an user

00:03:57,200 --> 00:04:02,560
would transferred that network status to

00:04:01,040 --> 00:04:05,920
another machine

00:04:02,560 --> 00:04:08,959
and the new machine will contain

00:04:05,920 --> 00:04:12,080
an outdated or a wrong network status

00:04:08,959 --> 00:04:15,760
and that could be fatal for the user

00:04:12,080 --> 00:04:19,600
in addition when applying uh

00:04:15,760 --> 00:04:22,560
when applying uh uh

00:04:19,600 --> 00:04:24,800
a decided state or a decided uh network

00:04:22,560 --> 00:04:27,919
configuration

00:04:24,800 --> 00:04:30,240
we are verifying that the current

00:04:27,919 --> 00:04:31,680
configuration matches the state that the

00:04:30,240 --> 00:04:35,360
user requested

00:04:31,680 --> 00:04:37,199
so if we are gathering the current

00:04:35,360 --> 00:04:38,800
states or the current configuration in

00:04:37,199 --> 00:04:41,520
our own way

00:04:38,800 --> 00:04:42,800
that's cool generally verification fails

00:04:41,520 --> 00:04:45,759
and that

00:04:42,800 --> 00:04:45,759
will be too bad

00:04:47,680 --> 00:04:53,600
so our first option was to use

00:04:51,360 --> 00:04:55,840
network manager because network manager

00:04:53,600 --> 00:04:57,280
is the main provider of nms state

00:04:55,840 --> 00:05:01,120
currently

00:04:57,280 --> 00:05:01,520
and we were using a network manager

00:05:01,120 --> 00:05:05,919
through

00:05:01,520 --> 00:05:10,479
by the object library to manage on disk

00:05:05,919 --> 00:05:13,600
or on memory profiles so we decided that

00:05:10,479 --> 00:05:17,199
it would be a great idea to

00:05:13,600 --> 00:05:22,800
use it too for getting the runtime

00:05:17,199 --> 00:05:26,240
status the thing is that

00:05:22,800 --> 00:05:29,360
doing that we will not need to

00:05:26,240 --> 00:05:32,800
uh add more dependencies

00:05:29,360 --> 00:05:38,880
and to modify a lot the code base

00:05:32,800 --> 00:05:42,800
so everything will be simpler

00:05:38,880 --> 00:05:43,600
but well uh network manager provides two

00:05:42,800 --> 00:05:46,479
different

00:05:43,600 --> 00:05:48,080
main objects to manage the manual the

00:05:46,479 --> 00:05:52,160
network configuration

00:05:48,080 --> 00:05:54,880
and i'm setting an nm device nm setting

00:05:52,160 --> 00:05:56,960
is managing the profiles and nm device

00:05:54,880 --> 00:05:58,479
is managing the runtime information from

00:05:56,960 --> 00:06:00,400
kernel

00:05:58,479 --> 00:06:02,880
so we tried to create the whole

00:06:00,400 --> 00:06:06,800
information from nm device objects

00:06:02,880 --> 00:06:09,039
but it was not possible because

00:06:06,800 --> 00:06:10,400
there were missing objects for some

00:06:09,039 --> 00:06:14,639
interfaces

00:06:10,400 --> 00:06:14,639
or there were some objects that

00:06:14,880 --> 00:06:18,560
were not exposing all the information

00:06:16,960 --> 00:06:21,840
needed by us

00:06:18,560 --> 00:06:22,319
and obviously we could not use the nm

00:06:21,840 --> 00:06:24,639
setting

00:06:22,319 --> 00:06:26,160
object because any setting is

00:06:24,639 --> 00:06:29,199
representing the profile

00:06:26,160 --> 00:06:32,880
and the profile is any state that

00:06:29,199 --> 00:06:35,120
an user is defining so

00:06:32,880 --> 00:06:36,080
if there are any changes on the kernel

00:06:35,120 --> 00:06:39,840
sites or

00:06:36,080 --> 00:06:42,639
there are any changes uh by other tool

00:06:39,840 --> 00:06:44,400
the profile will not uh update the

00:06:42,639 --> 00:06:47,440
information though

00:06:44,400 --> 00:06:52,160
so if we got the information from the

00:06:47,440 --> 00:06:55,280
setting it will it could be updated

00:06:52,160 --> 00:06:58,560
okay so we cannot use

00:06:55,280 --> 00:07:01,120
network manager to get the runtime

00:06:58,560 --> 00:07:02,639
network configuration correctly so

00:07:01,120 --> 00:07:07,039
what's cool with

00:07:02,639 --> 00:07:08,800
um we thought on csfs sfs is a silver

00:07:07,039 --> 00:07:12,160
file system that exports

00:07:08,800 --> 00:07:13,280
multiple linux kernel subsyst subsystem

00:07:12,160 --> 00:07:16,800
information

00:07:13,280 --> 00:07:19,280
including the network subsystem

00:07:16,800 --> 00:07:20,000
that's nice this is exposing the

00:07:19,280 --> 00:07:23,039
information

00:07:20,000 --> 00:07:23,759
of all kinds of interfaces and that is

00:07:23,039 --> 00:07:27,680
very good

00:07:23,759 --> 00:07:29,759
good for us in addition

00:07:27,680 --> 00:07:32,000
from enemy state it's really easy to

00:07:29,759 --> 00:07:32,000
read

00:07:32,639 --> 00:07:39,919
the csfs information as we can do it

00:07:36,319 --> 00:07:39,919
as any other file on the system

00:07:41,520 --> 00:07:44,639
what is the problem okay we found

00:07:43,840 --> 00:07:47,680
several

00:07:44,639 --> 00:07:50,080
issues when working with csfs

00:07:47,680 --> 00:07:52,080
the first one was when using csfs we

00:07:50,080 --> 00:07:52,879
found that some exposing information was

00:07:52,080 --> 00:07:55,680
not matching

00:07:52,879 --> 00:07:56,160
the standards and that is quite bad

00:07:55,680 --> 00:07:57,840
because

00:07:56,160 --> 00:08:00,160
we will need to create translators

00:07:57,840 --> 00:08:03,440
because between csfs and

00:08:00,160 --> 00:08:04,800
the standard way in addition in some

00:08:03,440 --> 00:08:08,560
cases

00:08:04,800 --> 00:08:11,199
uh the exposed information on csfs

00:08:08,560 --> 00:08:12,639
depends on the driver for example for

00:08:11,199 --> 00:08:16,240
srov

00:08:12,639 --> 00:08:20,319
uh the intel exgb

00:08:16,240 --> 00:08:23,520
driver and the melanox mlx

00:08:20,319 --> 00:08:25,759
four and five driver

00:08:23,520 --> 00:08:26,720
were exposing the information in

00:08:25,759 --> 00:08:30,080
different ways

00:08:26,720 --> 00:08:33,360
so we will not uh

00:08:30,080 --> 00:08:37,200
we were not considering to implement

00:08:33,360 --> 00:08:39,440
different readers bases on the drivers

00:08:37,200 --> 00:08:40,880
because that will generate a lot of

00:08:39,440 --> 00:08:44,240
changes on the code

00:08:40,880 --> 00:08:45,040
and that will generate uh a lot of code

00:08:44,240 --> 00:08:48,800
that

00:08:45,040 --> 00:08:51,920
maybe it will not going to be used

00:08:48,800 --> 00:08:54,320
uh anytime so

00:08:51,920 --> 00:08:56,080
we thought on sending a patch to clear

00:08:54,320 --> 00:08:58,320
the kernel

00:08:56,080 --> 00:09:00,080
in case that we need to change for

00:08:58,320 --> 00:09:03,200
example

00:09:00,080 --> 00:09:06,320
the format of the csfs information

00:09:03,200 --> 00:09:08,480
but it is a process that is slow

00:09:06,320 --> 00:09:09,360
and we need backporting to older

00:09:08,480 --> 00:09:12,560
patients

00:09:09,360 --> 00:09:15,600
it could generate uh problems

00:09:12,560 --> 00:09:18,720
with other users so

00:09:15,600 --> 00:09:22,160
we couldn't do it and

00:09:18,720 --> 00:09:24,480
also we found another big issue and

00:09:22,160 --> 00:09:25,760
it is that there can be race conditions

00:09:24,480 --> 00:09:30,640
or race conditions

00:09:25,760 --> 00:09:30,640
or inconsistencies that's a ongoing

00:09:34,839 --> 00:09:39,600
transaction so

00:09:36,399 --> 00:09:43,440
it's important to note that csfs

00:09:39,600 --> 00:09:46,640
is not an apa

00:09:43,440 --> 00:09:47,200
api sorry so exposed parameters could be

00:09:46,640 --> 00:09:49,680
removed

00:09:47,200 --> 00:09:50,560
or changes no providing backward

00:09:49,680 --> 00:09:53,440
compatibility

00:09:50,560 --> 00:09:53,920
and that will be very very bad for us

00:09:53,440 --> 00:09:57,040
because

00:09:53,920 --> 00:09:59,920
we are an api

00:09:57,040 --> 00:10:02,560
and we need to provide backward

00:09:59,920 --> 00:10:02,560
compatibility

00:10:03,279 --> 00:10:10,240
here we have an example of a

00:10:06,800 --> 00:10:13,680
siob the first image is from uh

00:10:10,240 --> 00:10:18,880
exgb pbe

00:10:13,680 --> 00:10:22,640
device and second one is from uh

00:10:18,880 --> 00:10:26,480
uh mlx 4

00:10:22,640 --> 00:10:29,519
driver as we can see on the first one

00:10:26,480 --> 00:10:33,360
it is not exposing the information

00:10:29,519 --> 00:10:37,120
about the number of bfs the offsets

00:10:33,360 --> 00:10:39,360
the strides the total bfs the bf device

00:10:37,120 --> 00:10:40,720
so they were missing a lot of

00:10:39,360 --> 00:10:42,800
information

00:10:40,720 --> 00:10:47,839
and in other cases the information were

00:10:42,800 --> 00:10:47,839
parsed in different ways

00:10:48,560 --> 00:10:55,680
we got out of ideas most of the issues

00:10:52,640 --> 00:10:56,480
that we were having on enemy state were

00:10:55,680 --> 00:10:58,839
related with

00:10:56,480 --> 00:11:00,240
updating information from the current

00:10:58,839 --> 00:11:03,279
configuration

00:11:00,240 --> 00:11:04,560
and we thought that the best option is

00:11:03,279 --> 00:11:06,640
to use netlink

00:11:04,560 --> 00:11:08,160
but the implementation is too much code

00:11:06,640 --> 00:11:10,959
for nms state

00:11:08,160 --> 00:11:12,560
because accessing the link data with

00:11:10,959 --> 00:11:16,399
python

00:11:12,560 --> 00:11:20,160
is uh complicated and we'll need

00:11:16,399 --> 00:11:23,760
each checkers so

00:11:20,160 --> 00:11:27,279
we wouldn't want uh

00:11:23,760 --> 00:11:29,279
to implement again

00:11:27,279 --> 00:11:31,300
something that other projects

00:11:29,279 --> 00:11:33,519
implemented their own way

00:11:31,300 --> 00:11:36,240
[Music]

00:11:33,519 --> 00:11:36,880
of communicating with the kernel using

00:11:36,240 --> 00:11:41,040
net link

00:11:36,880 --> 00:11:42,880
so as other projects were implementing

00:11:41,040 --> 00:11:44,640
their own way of communicating with the

00:11:42,880 --> 00:11:47,920
kernel

00:11:44,640 --> 00:11:51,519
why no one were doing it in

00:11:47,920 --> 00:11:55,200
a common way so we thought

00:11:51,519 --> 00:11:59,040
that maybe that could be a great idea

00:11:55,200 --> 00:12:02,399
but first of all let's talk about

00:11:59,040 --> 00:12:05,519
a link okay so what is net link

00:12:02,399 --> 00:12:08,880
netlink is a socket family is used as an

00:12:05,519 --> 00:12:10,880
interface for communicating

00:12:08,880 --> 00:12:12,639
between the kernel space and the user

00:12:10,880 --> 00:12:14,880
space processes

00:12:12,639 --> 00:12:15,839
all the information about interfaces are

00:12:14,880 --> 00:12:18,800
being exposed

00:12:15,839 --> 00:12:19,600
through this index almost all the

00:12:18,800 --> 00:12:22,720
information

00:12:19,600 --> 00:12:26,079
of devices on the kernel are

00:12:22,720 --> 00:12:28,720
exposed throughout it so nellie

00:12:26,079 --> 00:12:29,920
in addition use the linux kernel lock

00:12:28,720 --> 00:12:34,160
mechanisms

00:12:29,920 --> 00:12:38,079
like rcu to avoid race conditions

00:12:34,160 --> 00:12:41,519
or inconsistencies do it due to ongoing

00:12:38,079 --> 00:12:44,639
transactions and it is

00:12:41,519 --> 00:12:46,240
unstable api so it will maintain

00:12:44,639 --> 00:12:49,279
backward compatibility

00:12:46,240 --> 00:12:50,480
only additions are possible this is very

00:12:49,279 --> 00:12:52,480
important for us

00:12:50,480 --> 00:12:55,600
because this is what we are doing right

00:12:52,480 --> 00:12:55,600
now so

00:12:56,639 --> 00:13:01,519
that link is our solution we are sure of

00:13:00,240 --> 00:13:07,839
this

00:13:01,519 --> 00:13:07,839
and then uh we got an esport

00:13:11,920 --> 00:13:16,240
nispor is a native native library that

00:13:15,519 --> 00:13:19,760
provides

00:13:16,240 --> 00:13:23,200
unified interface or linux network

00:13:19,760 --> 00:13:26,800
state querying it provides a

00:13:23,200 --> 00:13:29,839
native rust python and c

00:13:26,800 --> 00:13:32,839
apis allowing its use

00:13:29,839 --> 00:13:34,720
from other projects written in different

00:13:32,839 --> 00:13:38,000
languages

00:13:34,720 --> 00:13:39,839
in addition uh it provides a command

00:13:38,000 --> 00:13:42,800
line tool too

00:13:39,839 --> 00:13:44,240
and a barley interface so it is possible

00:13:42,800 --> 00:13:47,360
to use it from

00:13:44,240 --> 00:13:50,720
golang or c plus plus if

00:13:47,360 --> 00:13:53,120
they access to it through the barling

00:13:50,720 --> 00:13:56,959
interface

00:13:53,120 --> 00:13:59,680
we noticed that all the projects like dc

00:13:56,959 --> 00:14:00,480
ansible linux system role or network

00:13:59,680 --> 00:14:03,040
manager

00:14:00,480 --> 00:14:03,760
will benefit from it as they need to

00:14:03,040 --> 00:14:06,399
gather

00:14:03,760 --> 00:14:07,199
the runtime network configuration this

00:14:06,399 --> 00:14:09,440
way

00:14:07,199 --> 00:14:11,279
they could avoid implementing their own

00:14:09,440 --> 00:14:12,160
way their own net link communication

00:14:11,279 --> 00:14:17,279
logic

00:14:12,160 --> 00:14:21,680
and they called contributes the nispor

00:14:17,279 --> 00:14:25,839
and reduced the effort

00:14:21,680 --> 00:14:25,839
to communicate with the kernel

00:14:26,880 --> 00:14:34,880
so this is the demo time i have

00:14:30,000 --> 00:14:38,560
prepared uh i have prepared several

00:14:34,880 --> 00:14:44,639
examples so i can show you a little bit

00:14:38,560 --> 00:14:48,079
let me

00:14:44,639 --> 00:14:49,199
okay i hope this time so the first thing

00:14:48,079 --> 00:14:52,079
that i want to show

00:14:49,199 --> 00:14:52,079
about uh

00:14:53,040 --> 00:14:56,399
the first thing that i want to show you

00:14:54,720 --> 00:15:00,480
about uh

00:14:56,399 --> 00:15:04,560
nispor is the roots so we can

00:15:00,480 --> 00:15:04,560
get all the rules information

00:15:05,760 --> 00:15:11,920
just with this simple comment uh

00:15:08,880 --> 00:15:13,199
you can see here for example uh

00:15:11,920 --> 00:15:16,160
different

00:15:13,199 --> 00:15:18,000
routes and for each room we can see the

00:15:16,160 --> 00:15:22,320
family

00:15:18,000 --> 00:15:26,079
table protocol which is the scope

00:15:22,320 --> 00:15:28,000
root type like broadcast unicast the

00:15:26,079 --> 00:15:31,600
destination

00:15:28,000 --> 00:15:34,720
the interface and the

00:15:31,600 --> 00:15:34,720
preferred gateway

00:15:35,279 --> 00:15:43,120
let me see let me search for an ipv6

00:15:38,399 --> 00:15:43,120
i think i have one of them here

00:15:52,800 --> 00:15:56,720
here we have a unicast one

00:15:57,519 --> 00:15:59,759
or

00:16:01,279 --> 00:16:06,560
i think i do have yeah yeah this one

00:16:04,530 --> 00:16:09,839
[Music]

00:16:06,560 --> 00:16:09,839
maybe a better one

00:16:11,440 --> 00:16:14,480
okay i don't think so i will get a

00:16:12,800 --> 00:16:18,240
better one so

00:16:14,480 --> 00:16:21,360
uh one for example this is an

00:16:18,240 --> 00:16:25,040
ipv6 uh

00:16:21,360 --> 00:16:28,240
an ipv6 route and as you can see we are

00:16:25,040 --> 00:16:32,480
showing table protocol scope root type

00:16:28,240 --> 00:16:36,240
and the flags destination interface

00:16:32,480 --> 00:16:39,839
uh all the catchy uh

00:16:36,240 --> 00:16:42,560
parameters the metric and the perf

00:16:39,839 --> 00:16:45,279
everything is the and is getting

00:16:42,560 --> 00:16:48,079
directly from the kernel

00:16:45,279 --> 00:16:48,079
that means that

00:16:48,800 --> 00:16:56,000
if something modifies the rule

00:16:52,800 --> 00:16:56,399
when using a link we will not find any

00:16:56,000 --> 00:16:59,519
issue

00:16:56,399 --> 00:17:02,880
and the configuration will be always

00:16:59,519 --> 00:17:07,199
updated let me show you

00:17:02,880 --> 00:17:07,199
for example this one

00:17:07,760 --> 00:17:12,880
this is the state for uh ethernet device

00:17:13,600 --> 00:17:17,199
as you can see here this well this

00:17:15,919 --> 00:17:20,559
ethernet device is

00:17:17,199 --> 00:17:22,260
down and we can see here the

00:17:20,559 --> 00:17:24,480
different uh

00:17:22,260 --> 00:17:28,000
[Music]

00:17:24,480 --> 00:17:30,960
interfaces like the efface tape

00:17:28,000 --> 00:17:33,280
the states the mtu the flux and the mac

00:17:30,960 --> 00:17:36,720
address

00:17:33,280 --> 00:17:38,960
and i have created

00:17:36,720 --> 00:17:38,960
one

00:17:41,200 --> 00:17:49,760
for example this complex one

00:17:46,000 --> 00:17:52,880
this bx lan for the bx lan we have

00:17:49,760 --> 00:17:56,080
here the state down the mtu

00:17:52,880 --> 00:17:56,480
flags etc but in addition we have the

00:17:56,080 --> 00:18:00,720
whole

00:17:56,480 --> 00:18:01,520
bx lamp parameters right so we can see

00:18:00,720 --> 00:18:05,039
the remotes

00:18:01,520 --> 00:18:08,240
the bx line id the base basey phase

00:18:05,039 --> 00:18:11,679
uh ttl to s

00:18:08,240 --> 00:18:16,720
uh aging uh

00:18:11,679 --> 00:18:20,480
the udp udp uh destination port

00:18:16,720 --> 00:18:20,480
um udp checksum

00:18:20,799 --> 00:18:27,200
uh enable or not uh

00:18:24,640 --> 00:18:28,559
let's see anything else yeah well all

00:18:27,200 --> 00:18:32,080
the parameters

00:18:28,559 --> 00:18:35,760
that are related to the

00:18:32,080 --> 00:18:39,520
uh that are related to the

00:18:35,760 --> 00:18:43,679
vxlan interfaces

00:18:39,520 --> 00:18:47,280
so that's all the main idea here is that

00:18:43,679 --> 00:18:51,679
enemy state finally was able to get

00:18:47,280 --> 00:18:55,440
the runtime network configuration

00:18:51,679 --> 00:18:58,640
and other projects are interested on

00:18:55,440 --> 00:18:59,600
this for two so we are reducing the

00:18:58,640 --> 00:19:03,039
efforts

00:18:59,600 --> 00:19:03,440
and working together and in my opinion

00:19:03,039 --> 00:19:08,960
that's

00:19:03,440 --> 00:19:08,960
it's the main point of free software

00:19:09,039 --> 00:19:11,840
the midterms

00:19:15,520 --> 00:19:18,880
okay so that's all thank you for your

00:19:17,840 --> 00:19:22,960
attention

00:19:18,880 --> 00:19:38,640
and now it's time for questions

00:19:22,960 --> 00:19:42,240
so what are your questions

00:19:38,640 --> 00:19:42,799
a couple of questions here in chat i'll

00:19:42,240 --> 00:19:44,640
just

00:19:42,799 --> 00:19:46,000
quickly read them out for you and i'm

00:19:44,640 --> 00:19:49,760
hoping you can answer them

00:19:46,000 --> 00:19:52,960
live here um so a question which

00:19:49,760 --> 00:19:55,520
till mass has asked is

00:19:52,960 --> 00:19:56,640
will there be an ansible module for

00:19:55,520 --> 00:20:01,039
nispor

00:19:56,640 --> 00:20:01,039
maybe as a fact module or a plug-in

00:20:01,280 --> 00:20:08,000
uh thank you for that question

00:20:04,799 --> 00:20:09,039
that's a very good question we have been

00:20:08,000 --> 00:20:12,080
thinking of this

00:20:09,039 --> 00:20:15,760
uh our first idea is to use uh

00:20:12,080 --> 00:20:19,200
nms state on a network roar

00:20:15,760 --> 00:20:21,200
of linux system rule so this way uh

00:20:19,200 --> 00:20:22,559
network role will be using nissport

00:20:21,200 --> 00:20:25,600
directly

00:20:22,559 --> 00:20:28,880
but i haven't i have not uh

00:20:25,600 --> 00:20:30,000
thought about creating a model for

00:20:28,880 --> 00:20:33,440
nispol directly

00:20:30,000 --> 00:20:36,640
or fact model or plugin

00:20:33,440 --> 00:20:38,480
so i think the best approach here that

00:20:36,640 --> 00:20:41,760
or the approach that they are we are

00:20:38,480 --> 00:20:46,720
working on is the

00:20:41,760 --> 00:20:48,799
is the um is using element state

00:20:46,720 --> 00:20:50,880
from the network but this is right now

00:20:48,799 --> 00:20:54,080
we are working on the design of this

00:20:50,880 --> 00:20:57,760
so it's a mid-term

00:20:54,080 --> 00:20:58,320
long-term feature uh i will not expect

00:20:57,760 --> 00:21:01,679
it in

00:20:58,320 --> 00:21:06,000
shorthand so yeah i think i hope

00:21:01,679 --> 00:21:08,880
this is uh answering your question

00:21:06,000 --> 00:21:09,440
perfect thank you uh we have another

00:21:08,880 --> 00:21:12,480
question

00:21:09,440 --> 00:21:14,960
uh what is the which edward berger

00:21:12,480 --> 00:21:16,080
is asking so uh the question is what's

00:21:14,960 --> 00:21:19,280
the status on

00:21:16,080 --> 00:21:21,440
infinite band support yeah

00:21:19,280 --> 00:21:22,880
this is another good question we are

00:21:21,440 --> 00:21:25,919
currently working on this

00:21:22,880 --> 00:21:28,720
uh we have found some issues with uh

00:21:25,919 --> 00:21:30,480
uh what in the link is supposing about

00:21:28,720 --> 00:21:33,840
infiniband interfaces

00:21:30,480 --> 00:21:36,880
but we are planning on fixing that

00:21:33,840 --> 00:21:41,200
uh problem that we found but we are uh

00:21:36,880 --> 00:21:43,679
working on this right now so i hope in

00:21:41,200 --> 00:21:44,720
short or mid-term we are going to have

00:21:43,679 --> 00:21:47,679
uh

00:21:44,720 --> 00:21:48,640
infiniband support on esport and the

00:21:47,679 --> 00:21:51,679
same for

00:21:48,640 --> 00:21:53,360
uh enemy state we are working on it we

00:21:51,679 --> 00:21:57,200
have a draft vr

00:21:53,360 --> 00:21:59,760
so that is quite good probably for the

00:21:57,200 --> 00:22:01,200
uh not the next release of enemy state

00:21:59,760 --> 00:22:01,600
but for the next one we are going to

00:22:01,200 --> 00:22:05,280
have

00:22:01,600 --> 00:22:08,159
uh um enemy stage with

00:22:05,280 --> 00:22:09,919
uh infiniband support and for nispor i

00:22:08,159 --> 00:22:10,400
think it's going to take a little bit

00:22:09,919 --> 00:22:14,480
more

00:22:10,400 --> 00:22:14,480
but i hope it will be really soon

00:22:15,120 --> 00:22:19,919
for that fernando we have another

00:22:17,440 --> 00:22:22,799
question from marcelo leitner

00:22:19,919 --> 00:22:24,559
um they ask how can i list all ip

00:22:22,799 --> 00:22:27,120
addresses for the system

00:22:24,559 --> 00:22:28,080
in a similar node does it make sense to

00:22:27,120 --> 00:22:31,280
make a fuse

00:22:28,080 --> 00:22:34,080
back-end for nispor as a replacement for

00:22:31,280 --> 00:22:36,559
sysfs to avoid excessive forking and

00:22:34,080 --> 00:22:39,440
shell scripts

00:22:36,559 --> 00:22:40,240
well what we are doing now is uh i don't

00:22:39,440 --> 00:22:42,159
know if

00:22:40,240 --> 00:22:43,440
it makes sense to make a fuse back and

00:22:42,159 --> 00:22:46,159
for nisbo but

00:22:43,440 --> 00:22:47,200
i'm sure that uh what we are doing now

00:22:46,159 --> 00:22:50,320
is to provide

00:22:47,200 --> 00:22:54,480
a native uh rust uh python or

00:22:50,320 --> 00:22:55,200
c api so if you're a passion user you

00:22:54,480 --> 00:22:58,960
can just

00:22:55,200 --> 00:22:59,840
use uh nispor to gather all the

00:22:58,960 --> 00:23:02,159
interfaces

00:22:59,840 --> 00:23:03,440
and then in a for loop you can get all

00:23:02,159 --> 00:23:06,559
the ip configurations

00:23:03,440 --> 00:23:07,679
then listed i think that it's the best

00:23:06,559 --> 00:23:10,880
approach now

00:23:07,679 --> 00:23:12,320
maybe we can think on something like the

00:23:10,880 --> 00:23:14,000
feature that we are proposing here that

00:23:12,320 --> 00:23:17,039
nispor is directly

00:23:14,000 --> 00:23:19,200
showing the ip addresses all ib

00:23:17,039 --> 00:23:22,320
addresses for the system

00:23:19,200 --> 00:23:26,240
but we will need to relate it with

00:23:22,320 --> 00:23:29,919
some somehow related to to the efface

00:23:26,240 --> 00:23:29,919
to do not show uh

00:23:30,080 --> 00:23:35,679
eyepiece without context but

00:23:33,120 --> 00:23:37,919
thank you for the suggestion uh i will

00:23:35,679 --> 00:23:41,840
try to propose that and to

00:23:37,919 --> 00:23:43,360
talk about this on the with the dim and

00:23:41,840 --> 00:23:45,760
for now i think the best option is to

00:23:43,360 --> 00:23:48,159
use another language to filter the

00:23:45,760 --> 00:23:48,799
ip addresses of each interface and

00:23:48,159 --> 00:23:53,279
showing them

00:23:48,799 --> 00:23:53,279
on at least or your preferred way

00:23:53,760 --> 00:23:56,559
i hope perfect that's not quite a

00:23:55,120 --> 00:23:58,240
question yeah thank you thank you for

00:23:56,559 --> 00:24:00,080
that fernando and thank you everybody

00:23:58,240 --> 00:24:01,840
for asking your questions

00:24:00,080 --> 00:24:04,159
and please feel free to carry on the

00:24:01,840 --> 00:24:05,360
conversation in the breakout room and i

00:24:04,159 --> 00:24:08,480
just posted a link

00:24:05,360 --> 00:24:11,120
to the breakout room where you can ask

00:24:08,480 --> 00:24:12,640
any more questions that you have

00:24:11,120 --> 00:24:19,840
thank you again fernando thank you very

00:24:12,640 --> 00:24:19,840
much thank you

00:24:20,080 --> 00:24:22,159

YouTube URL: https://www.youtube.com/watch?v=PoGC_raJbgQ


