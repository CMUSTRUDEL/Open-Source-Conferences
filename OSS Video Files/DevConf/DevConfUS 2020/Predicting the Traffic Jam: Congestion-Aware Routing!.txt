Title: Predicting the Traffic Jam: Congestion-Aware Routing!
Publication date: 2020-10-07
Playlist: DevConfUS 2020
Description: 
	Speaker: Niharika Shrivastava

What if there existed no traffic congestion for anyone at all times? What if you knew that by walking for a couple minutes more to the next nearest bus station, you could save more travelling time overall? In this session, we propose a framework that provides congestion-aware routes to an entire network system by estimating future traffic flow. We showcase the effectiveness of our framework by using Singaporeâ€™s network data from OpenStreetMap coupled with its real-time traffic data. The project is built entirely using only open source tools. This should inspire attendees into intelligent urban mobility, robotics, and AI.
Captions: 
	00:00:01,599 --> 00:00:06,560
okay so hi everybody

00:00:03,439 --> 00:00:10,400
um we are going to have niharika

00:00:06,560 --> 00:00:13,280
go on next and she'll be speaking about

00:00:10,400 --> 00:00:14,400
congestion aware routing for multi-class

00:00:13,280 --> 00:00:17,359
vehicles

00:00:14,400 --> 00:00:19,119
um if you have connectivity issues

00:00:17,359 --> 00:00:22,160
please feel free to

00:00:19,119 --> 00:00:23,760
watch the video in a separate tab but do

00:00:22,160 --> 00:00:25,119
leave your hoping session open so that

00:00:23,760 --> 00:00:29,840
you can come back here

00:00:25,119 --> 00:00:29,840
for live q a so we'll get started

00:00:35,520 --> 00:00:39,680
today i am going to talk about how we

00:00:38,079 --> 00:00:42,079
can potentially

00:00:39,680 --> 00:00:44,079
predict a traffic jam by providing

00:00:42,079 --> 00:00:47,200
congestion aware awareness to every

00:00:44,079 --> 00:00:50,239
passenger in the network and

00:00:47,200 --> 00:00:54,559
basically avoid situations like

00:00:50,239 --> 00:00:57,039
these fell for a little background

00:00:54,559 --> 00:00:58,160
the problem of congestion arises because

00:00:57,039 --> 00:01:00,559
every passenger

00:00:58,160 --> 00:01:01,840
inherently opts for the shortest

00:01:00,559 --> 00:01:04,879
distance road

00:01:01,840 --> 00:01:06,720
from their source to destination so

00:01:04,879 --> 00:01:09,119
with an increase in the number of

00:01:06,720 --> 00:01:11,520
vehicles on the road over the years

00:01:09,119 --> 00:01:13,680
and with capacities of roads being

00:01:11,520 --> 00:01:16,799
approximately constant

00:01:13,680 --> 00:01:20,000
this results in increased travel times

00:01:16,799 --> 00:01:23,520
and road blockages on intersections

00:01:20,000 --> 00:01:26,880
in the network this also results

00:01:23,520 --> 00:01:30,720
in under utilization of a city's

00:01:26,880 --> 00:01:33,680
intricately built road network

00:01:30,720 --> 00:01:34,159
well i would like to introduce a concept

00:01:33,680 --> 00:01:37,439
called

00:01:34,159 --> 00:01:40,560
multi-class fleets which also serves

00:01:37,439 --> 00:01:42,720
as a major crux in our framework for

00:01:40,560 --> 00:01:44,799
implementing congressional wear outline

00:01:42,720 --> 00:01:47,360
for an entire system

00:01:44,799 --> 00:01:49,439
so the concept of multi-class fleets

00:01:47,360 --> 00:01:52,640
allow breaking a customer trip

00:01:49,439 --> 00:01:55,520
in three classes we have the first mile

00:01:52,640 --> 00:01:56,799
middle mile and the last mile the first

00:01:55,520 --> 00:01:59,520
and the last mile

00:01:56,799 --> 00:02:00,320
can use micro mobility options such as

00:01:59,520 --> 00:02:04,000
walking

00:02:00,320 --> 00:02:07,200
e-scooters and bikes and the middle mile

00:02:04,000 --> 00:02:09,679
uses fast speed vehicles such as

00:02:07,200 --> 00:02:11,680
cars private taxis or even public

00:02:09,679 --> 00:02:14,400
transports like buses

00:02:11,680 --> 00:02:14,959
so the middle mile is used to cover at

00:02:14,400 --> 00:02:19,040
least

00:02:14,959 --> 00:02:22,239
90 percent of an entire customer trip

00:02:19,040 --> 00:02:24,319
and the usage of this is that by using a

00:02:22,239 --> 00:02:27,360
multi-class setup like this

00:02:24,319 --> 00:02:30,080
in an optimal combination a customer

00:02:27,360 --> 00:02:31,519
customer can easily maneuver through

00:02:30,080 --> 00:02:35,519
crowded parts

00:02:31,519 --> 00:02:40,000
and decrease their overall travel time

00:02:35,519 --> 00:02:43,440
so allows a customer flexible options

00:02:40,000 --> 00:02:46,640
for their preferred mode of transport

00:02:43,440 --> 00:02:50,000
um on the basis of

00:02:46,640 --> 00:02:52,800
accessibility and cost so for

00:02:50,000 --> 00:02:54,000
example a customer starts walking from

00:02:52,800 --> 00:02:57,040
their source

00:02:54,000 --> 00:03:00,879
for about 250 meters and then they take

00:02:57,040 --> 00:03:03,680
a bus for about 15 minutes

00:03:00,879 --> 00:03:04,720
uh after which they bike away to their

00:03:03,680 --> 00:03:07,360
destination

00:03:04,720 --> 00:03:10,560
for 500 meters thereby completing their

00:03:07,360 --> 00:03:14,159
entire trip in three phases

00:03:10,560 --> 00:03:14,640
well so let us formulate our problem in

00:03:14,159 --> 00:03:17,920
a more

00:03:14,640 --> 00:03:18,640
defined way we essentially have to route

00:03:17,920 --> 00:03:21,760
customer

00:03:18,640 --> 00:03:23,920
trips in a congestion aware manner

00:03:21,760 --> 00:03:26,239
using this previously explained

00:03:23,920 --> 00:03:28,560
multi-class fleet of vehicles

00:03:26,239 --> 00:03:29,840
and we also want to provide optimal

00:03:28,560 --> 00:03:32,480
transit points for

00:03:29,840 --> 00:03:34,080
each trip now what this means is that if

00:03:32,480 --> 00:03:36,959
you look at this figure

00:03:34,080 --> 00:03:37,280
let's say a person wants to go from a to

00:03:36,959 --> 00:03:40,239
b

00:03:37,280 --> 00:03:40,560
and they have two possible root options

00:03:40,239 --> 00:03:43,599
a

00:03:40,560 --> 00:03:46,959
c b and a b where they can

00:03:43,599 --> 00:03:50,400
walk to their nearest bus station at

00:03:46,959 --> 00:03:52,560
c and then take a bus from c to b

00:03:50,400 --> 00:03:53,760
having their total trip time is 34

00:03:52,560 --> 00:03:57,120
minutes maybe because

00:03:53,760 --> 00:04:00,239
this bus station is really popular uh

00:03:57,120 --> 00:04:02,159
because it is closer to a or

00:04:00,239 --> 00:04:03,599
they could have worked a little bit

00:04:02,159 --> 00:04:04,959
further to their next year is

00:04:03,599 --> 00:04:07,760
fascination

00:04:04,959 --> 00:04:10,000
and then take the bus from b to b having

00:04:07,760 --> 00:04:12,159
their total trip time is 30 minutes

00:04:10,000 --> 00:04:13,200
thereby saving four minutes of overall

00:04:12,159 --> 00:04:15,439
travel time

00:04:13,200 --> 00:04:16,880
so you see that in this network the

00:04:15,439 --> 00:04:20,799
optimal

00:04:16,880 --> 00:04:21,759
path from a to b is a db and the optimal

00:04:20,799 --> 00:04:25,199
transit point

00:04:21,759 --> 00:04:27,840
is b and of c transit point means

00:04:25,199 --> 00:04:29,840
that it is a point wherein we stop

00:04:27,840 --> 00:04:30,880
taking one mode of transport and start

00:04:29,840 --> 00:04:33,440
taking another

00:04:30,880 --> 00:04:35,199
so in this case we have stopped walking

00:04:33,440 --> 00:04:37,280
as for our first smile and we have

00:04:35,199 --> 00:04:40,479
started taking a bus

00:04:37,280 --> 00:04:42,639
for our middle we

00:04:40,479 --> 00:04:43,840
also want to implement this entire

00:04:42,639 --> 00:04:47,040
network

00:04:43,840 --> 00:04:49,840
in the form of a social model so

00:04:47,040 --> 00:04:50,639
the current state of the art basically

00:04:49,840 --> 00:04:52,400
uses

00:04:50,639 --> 00:04:53,840
congestion that provides congestion

00:04:52,400 --> 00:04:56,960
awareness to just

00:04:53,840 --> 00:04:57,600
one customer and that is not a social

00:04:56,960 --> 00:05:00,320
model

00:04:57,600 --> 00:05:00,880
it implies it implements a user's

00:05:00,320 --> 00:05:04,000
selfish

00:05:00,880 --> 00:05:06,080
user-centric method so for an example

00:05:04,000 --> 00:05:07,039
let's say you are checking google maps

00:05:06,080 --> 00:05:10,400
to look

00:05:07,039 --> 00:05:13,680
for a route to your destination which

00:05:10,400 --> 00:05:14,720
is absolutely congestion free but while

00:05:13,680 --> 00:05:18,960
you are checking for

00:05:14,720 --> 00:05:19,520
roots and you all decide on the same

00:05:18,960 --> 00:05:22,479
route

00:05:19,520 --> 00:05:22,880
which shows as congestion free but when

00:05:22,479 --> 00:05:25,520
you

00:05:22,880 --> 00:05:27,199
actually take that route 800 other

00:05:25,520 --> 00:05:27,680
people also decide to take the same

00:05:27,199 --> 00:05:30,880
route

00:05:27,680 --> 00:05:34,000
simultaneously with you creating

00:05:30,880 --> 00:05:38,000
a traffic jam on that route

00:05:34,000 --> 00:05:40,160
and which will increase your overall

00:05:38,000 --> 00:05:41,199
uh travel time for every passenger in

00:05:40,160 --> 00:05:43,120
the trip

00:05:41,199 --> 00:05:44,960
so this condition of that route that was

00:05:43,120 --> 00:05:48,160
provided wasn't in real time

00:05:44,960 --> 00:05:51,440
and wasn't for the entire system

00:05:48,160 --> 00:05:53,199
we want to create this framework and

00:05:51,440 --> 00:05:55,360
scale it to the entire

00:05:53,199 --> 00:05:56,800
system by thereby creating a system

00:05:55,360 --> 00:05:59,919
equilibrium

00:05:56,800 --> 00:06:03,440
uh which incorporates every person

00:05:59,919 --> 00:06:05,680
in the network's request

00:06:03,440 --> 00:06:06,639
so let me introduce another concept

00:06:05,680 --> 00:06:09,840
called geographic

00:06:06,639 --> 00:06:11,680
information system or gis what that is

00:06:09,840 --> 00:06:14,160
that this is basically a computer

00:06:11,680 --> 00:06:17,759
software that helps us to extract

00:06:14,160 --> 00:06:20,720
and analyze geographic elements

00:06:17,759 --> 00:06:21,680
for research purposes so as you have

00:06:20,720 --> 00:06:24,960
guessed already

00:06:21,680 --> 00:06:28,400
transportation analysis comes under this

00:06:24,960 --> 00:06:30,400
there are various open source libraries

00:06:28,400 --> 00:06:33,520
in python that help us

00:06:30,400 --> 00:06:36,240
to help us to analyze

00:06:33,520 --> 00:06:36,800
this juice information for our research

00:06:36,240 --> 00:06:39,039
work

00:06:36,800 --> 00:06:41,199
so the first library that i have used is

00:06:39,039 --> 00:06:43,840
actually called osm nx

00:06:41,199 --> 00:06:45,600
what that does is that osm nx helps us

00:06:43,840 --> 00:06:47,759
to retrieve

00:06:45,600 --> 00:06:50,319
network uh street networks from the

00:06:47,759 --> 00:06:53,360
openstreetmap database

00:06:50,319 --> 00:06:56,639
and then further analyze

00:06:53,360 --> 00:06:59,759
our uh and further analyze elements of

00:06:56,639 --> 00:07:02,160
it using other libraries so one thing to

00:06:59,759 --> 00:07:03,599
note is that this entire framework was

00:07:02,160 --> 00:07:06,240
validated using

00:07:03,599 --> 00:07:06,960
singapore street network and we

00:07:06,240 --> 00:07:09,680
therefore

00:07:06,960 --> 00:07:12,160
extracted singapore street network from

00:07:09,680 --> 00:07:15,039
openstreetmap using os mnx

00:07:12,160 --> 00:07:15,759
over here we see that these are all the

00:07:15,039 --> 00:07:18,800
nodes

00:07:15,759 --> 00:07:21,919
in the singapore uh

00:07:18,800 --> 00:07:23,599
graph and this is the edge all of the

00:07:21,919 --> 00:07:26,960
edges in singapore graph

00:07:23,599 --> 00:07:29,520
so osm nx helps us to retrieve

00:07:26,960 --> 00:07:30,240
networks which are tagged either only

00:07:29,520 --> 00:07:32,319
for

00:07:30,240 --> 00:07:34,319
driving or maybe just pedestrian

00:07:32,319 --> 00:07:37,360
networks or

00:07:34,319 --> 00:07:39,919
which are only used for bicycles we

00:07:37,360 --> 00:07:40,960
the this graph actually is only a

00:07:39,919 --> 00:07:44,720
drivable

00:07:40,960 --> 00:07:46,960
network because we are calculating

00:07:44,720 --> 00:07:47,759
congestion for roads which can only be

00:07:46,960 --> 00:07:51,120
drive uh

00:07:47,759 --> 00:07:54,400
drive the different colors

00:07:51,120 --> 00:07:57,759
show if an edge is either a

00:07:54,400 --> 00:08:00,160
primary road or a highway or residential

00:07:57,759 --> 00:08:03,520
role and so on

00:08:00,160 --> 00:08:05,759
the next library that we are using

00:08:03,520 --> 00:08:06,720
is called geoparadise and it is actually

00:08:05,759 --> 00:08:09,440
an extension

00:08:06,720 --> 00:08:10,080
of the data science library pandas what

00:08:09,440 --> 00:08:13,280
it does

00:08:10,080 --> 00:08:14,400
is that it helps us to visualize the

00:08:13,280 --> 00:08:17,840
previously

00:08:14,400 --> 00:08:18,560
shown nodes and edges in form of data

00:08:17,840 --> 00:08:20,720
frames

00:08:18,560 --> 00:08:22,879
so you have one data frame four nodes

00:08:20,720 --> 00:08:26,080
and one data frame for edges

00:08:22,879 --> 00:08:28,720
so over here i have shown an

00:08:26,080 --> 00:08:29,759
edge data frame for the previously shown

00:08:28,720 --> 00:08:33,039
edge graph

00:08:29,759 --> 00:08:35,760
so you can see that let's say you and me

00:08:33,039 --> 00:08:36,240
refer to the starting and ending nodes

00:08:35,760 --> 00:08:39,599
for an

00:08:36,240 --> 00:08:42,399
edge he represents

00:08:39,599 --> 00:08:43,039
uh which lane it is so it is possible

00:08:42,399 --> 00:08:45,920
that

00:08:43,039 --> 00:08:46,880
in complex road networks such as cities

00:08:45,920 --> 00:08:49,600
or countries

00:08:46,880 --> 00:08:50,320
there could be multiple lanes within two

00:08:49,600 --> 00:08:52,880
nodes

00:08:50,320 --> 00:08:55,440
so if key is zero that means it's the

00:08:52,880 --> 00:08:58,560
first lane between

00:08:55,440 --> 00:08:59,440
the edge nodes u and v osm id is just a

00:08:58,560 --> 00:09:03,680
primary

00:08:59,440 --> 00:09:05,680
id needed to understand this entire row

00:09:03,680 --> 00:09:08,320
for the data frame

00:09:05,680 --> 00:09:10,640
name specifies the name of that

00:09:08,320 --> 00:09:13,920
particular edge so in this case

00:09:10,640 --> 00:09:15,200
avenue is the actual name of this edge

00:09:13,920 --> 00:09:17,040
in singapore

00:09:15,200 --> 00:09:19,279
highway shows whether this road is

00:09:17,040 --> 00:09:23,440
either a primary road a tertiary

00:09:19,279 --> 00:09:26,160
residential road etc maximum speed

00:09:23,440 --> 00:09:28,080
specifies the speed limit that is

00:09:26,160 --> 00:09:31,600
allowed for any vehicle

00:09:28,080 --> 00:09:32,000
to go on that road and this is decided

00:09:31,600 --> 00:09:34,320
upon

00:09:32,000 --> 00:09:35,200
government regulations length is in

00:09:34,320 --> 00:09:37,519
meters and

00:09:35,200 --> 00:09:38,240
travel time refers to free flow time

00:09:37,519 --> 00:09:40,320
that is

00:09:38,240 --> 00:09:41,920
the travel time required to go through

00:09:40,320 --> 00:09:44,160
this edge uv

00:09:41,920 --> 00:09:46,080
when there are absolutely no vehicles

00:09:44,160 --> 00:09:47,040
present on that road so that is free

00:09:46,080 --> 00:09:49,440
flow time

00:09:47,040 --> 00:09:51,760
and location uh consists of your

00:09:49,440 --> 00:09:54,640
latitude and longitude points of that

00:09:51,760 --> 00:09:54,640
particular edge

00:09:55,279 --> 00:10:00,720
so now you have your data frames of

00:09:59,120 --> 00:10:03,600
nodes and edges separately

00:10:00,720 --> 00:10:04,800
you can combine them to actually make a

00:10:03,600 --> 00:10:08,560
graph

00:10:04,800 --> 00:10:10,640
for further analysis and this is done by

00:10:08,560 --> 00:10:13,040
a library called network x

00:10:10,640 --> 00:10:15,760
so network x combines these two data

00:10:13,040 --> 00:10:18,720
frames creates a graph

00:10:15,760 --> 00:10:20,079
g consisting of edges and words and

00:10:18,720 --> 00:10:23,519
helps us to

00:10:20,079 --> 00:10:25,279
um implement algorithms such as the

00:10:23,519 --> 00:10:28,640
shortest

00:10:25,279 --> 00:10:29,440
distance route like dijkstra or bellman

00:10:28,640 --> 00:10:31,760
ford

00:10:29,440 --> 00:10:34,880
or just other analysis like nearest

00:10:31,760 --> 00:10:37,920
neighbor search and so on

00:10:34,880 --> 00:10:40,480
and the last but not the least

00:10:37,920 --> 00:10:42,959
we are using arteries so artery is

00:10:40,480 --> 00:10:44,880
actually a spatial indexing

00:10:42,959 --> 00:10:46,240
library what it does is that it

00:10:44,880 --> 00:10:50,079
basically creates

00:10:46,240 --> 00:10:50,720
a rectangle on every geographical

00:10:50,079 --> 00:10:54,000
element

00:10:50,720 --> 00:10:56,240
on the map and then by either

00:10:54,000 --> 00:10:59,279
using set operations like intersectional

00:10:56,240 --> 00:11:01,440
union you can find

00:10:59,279 --> 00:11:03,440
neighboring elements first one certain

00:11:01,440 --> 00:11:06,640
elements so you could

00:11:03,440 --> 00:11:08,480
for example find the nearest node

00:11:06,640 --> 00:11:10,000
on your list or all the neighboring

00:11:08,480 --> 00:11:14,079
nodes for a certain

00:11:10,000 --> 00:11:16,480
node given a certain radius

00:11:14,079 --> 00:11:19,680
right so let's start with actually

00:11:16,480 --> 00:11:22,320
implementing this congressional layout

00:11:19,680 --> 00:11:24,959
uh ruling framework what are we actually

00:11:22,320 --> 00:11:28,240
doing well the first and foremost step

00:11:24,959 --> 00:11:28,720
is to extract data and the first kind of

00:11:28,240 --> 00:11:32,160
data

00:11:28,720 --> 00:11:35,120
that we are extracting is network data

00:11:32,160 --> 00:11:35,760
so we use open street maps database like

00:11:35,120 --> 00:11:39,519
explained

00:11:35,760 --> 00:11:41,519
before using all these just libraries

00:11:39,519 --> 00:11:42,560
and we extract and manipulate and

00:11:41,519 --> 00:11:46,160
process

00:11:42,560 --> 00:11:49,519
the data we extract only drivable

00:11:46,160 --> 00:11:51,040
uh drivable networks road

00:11:49,519 --> 00:11:53,680
a road network because we wanted to

00:11:51,040 --> 00:11:55,279
calculate transition on that and we also

00:11:53,680 --> 00:11:56,880
extract road networks that use

00:11:55,279 --> 00:11:58,639
pedestrian networks as well because

00:11:56,880 --> 00:12:02,000
we're trying to incorporate

00:11:58,639 --> 00:12:04,160
a multi-class setup the next kind of

00:12:02,000 --> 00:12:06,320
data that we are going to

00:12:04,160 --> 00:12:07,920
collect is actually called a traffic

00:12:06,320 --> 00:12:10,160
speed bank data set

00:12:07,920 --> 00:12:12,000
and it looks something like this what is

00:12:10,160 --> 00:12:14,639
happening is that traffic speed and

00:12:12,000 --> 00:12:17,680
dataset is something that is available

00:12:14,639 --> 00:12:18,880
by singapore's government it is freely

00:12:17,680 --> 00:12:22,480
available

00:12:18,880 --> 00:12:25,519
it shows real-time average

00:12:22,480 --> 00:12:29,680
observed speed at a certain edge for

00:12:25,519 --> 00:12:32,160
every edge in the singapore's graph

00:12:29,680 --> 00:12:33,440
so in this case you see that link id

00:12:32,160 --> 00:12:36,720
refers to

00:12:33,440 --> 00:12:40,480
the osm id for which it is

00:12:36,720 --> 00:12:41,600
the osm and then you have the latitude

00:12:40,480 --> 00:12:45,920
and longitude

00:12:41,600 --> 00:12:47,839
position for that particular edge and

00:12:45,920 --> 00:12:50,959
over here this is the split band

00:12:47,839 --> 00:12:54,160
so the maximum absorbs speed was 39

00:12:50,959 --> 00:12:56,320
whereas the minimum speed was 30. so

00:12:54,160 --> 00:12:59,200
this playback data set is actually a

00:12:56,320 --> 00:13:02,240
snapshot of how speeds were observed

00:12:59,200 --> 00:13:06,160
at a particular point in time

00:13:02,240 --> 00:13:08,720
and using this we can actually

00:13:06,160 --> 00:13:10,880
calculate congestion for the entire

00:13:08,720 --> 00:13:13,680
network

00:13:10,880 --> 00:13:14,720
but okay so how do we do that we will

00:13:13,680 --> 00:13:16,480
come to that later

00:13:14,720 --> 00:13:18,320
but after we facilitate the transition

00:13:16,480 --> 00:13:21,440
for the entire network

00:13:18,320 --> 00:13:23,800
we have to typically

00:13:21,440 --> 00:13:26,399
propose an algorithm and what is

00:13:23,800 --> 00:13:29,920
algorithm's main aim

00:13:26,399 --> 00:13:35,040
is that it should minimize the overall

00:13:29,920 --> 00:13:35,040
travel time for one user in the entire

00:13:46,639 --> 00:13:51,519
after we have minimized travel time for

00:13:49,440 --> 00:13:53,760
one user we want to minimize

00:13:51,519 --> 00:13:54,800
overall travel time for every user in

00:13:53,760 --> 00:13:58,480
the system

00:13:54,800 --> 00:14:01,519
so this is achieved by actually

00:13:58,480 --> 00:14:03,680
formulating a linear programming problem

00:14:01,519 --> 00:14:05,839
wherein our cost function is to minimize

00:14:03,680 --> 00:14:09,279
the overall system's travel time

00:14:05,839 --> 00:14:11,360
and our constraints become

00:14:09,279 --> 00:14:14,800
you know constant road capacities and

00:14:11,360 --> 00:14:17,920
continuously in the network

00:14:14,800 --> 00:14:20,240
so after we have proposed these and

00:14:17,920 --> 00:14:22,880
all our mathematical tools are in place

00:14:20,240 --> 00:14:24,240
we use our above proposed algorithm to

00:14:22,880 --> 00:14:26,639
actually find

00:14:24,240 --> 00:14:27,360
optimal transit points for the middle

00:14:26,639 --> 00:14:30,000
mile

00:14:27,360 --> 00:14:32,240
after we found that we solved this

00:14:30,000 --> 00:14:35,440
linear programming problem

00:14:32,240 --> 00:14:39,600
to find transit points for every person

00:14:35,440 --> 00:14:41,920
in the network and we solve this

00:14:39,600 --> 00:14:44,079
linear programming problem by using a

00:14:41,920 --> 00:14:47,279
conditional gradient is an algorithm

00:14:44,079 --> 00:14:49,560
called frankwolf which is

00:14:47,279 --> 00:14:51,199
specifically used for

00:14:49,560 --> 00:14:54,800
transportation-based

00:14:51,199 --> 00:14:58,240
problem statements and

00:14:54,800 --> 00:15:01,279
after we have found you know

00:14:58,240 --> 00:15:02,480
system optimal flows flows which for the

00:15:01,279 --> 00:15:06,240
entire network

00:15:02,480 --> 00:15:08,560
these flows are basically um

00:15:06,240 --> 00:15:09,839
ensuring that there is zero congestion

00:15:08,560 --> 00:15:12,560
at all times

00:15:09,839 --> 00:15:14,880
we want to decompose these flows into

00:15:12,560 --> 00:15:15,760
dedicated routes for every passenger in

00:15:14,880 --> 00:15:18,240
the network

00:15:15,760 --> 00:15:19,839
so that they can just freely go on that

00:15:18,240 --> 00:15:22,399
route without having to worry about

00:15:19,839 --> 00:15:25,279
congestion at all

00:15:22,399 --> 00:15:26,320
okay so after we've done all of that

00:15:25,279 --> 00:15:28,720
awesome magic

00:15:26,320 --> 00:15:29,680
our final architecture looks something

00:15:28,720 --> 00:15:32,399
like this

00:15:29,680 --> 00:15:34,000
so let's say there are 10 customers at

00:15:32,399 --> 00:15:39,040
one point

00:15:34,000 --> 00:15:40,800
asking for requesting source destination

00:15:39,040 --> 00:15:42,560
trips you know different source

00:15:40,800 --> 00:15:45,199
destination trips

00:15:42,560 --> 00:15:46,079
our framework helps us to calculate

00:15:45,199 --> 00:15:48,079
middle mile

00:15:46,079 --> 00:15:50,240
transit modes for all of these end

00:15:48,079 --> 00:15:51,040
requests using this algorithm that we

00:15:50,240 --> 00:15:53,040
propose

00:15:51,040 --> 00:15:54,160
and it's called modified hybrid search

00:15:53,040 --> 00:15:56,480
which we will come to

00:15:54,160 --> 00:15:58,079
later after we have calculated the

00:15:56,480 --> 00:16:01,920
middle mile transformers for

00:15:58,079 --> 00:16:04,079
all n requests we use a conditional

00:16:01,920 --> 00:16:05,680
gradient descent and decompose these

00:16:04,079 --> 00:16:08,720
flows into dedicated

00:16:05,680 --> 00:16:12,000
roads where every customer in

00:16:08,720 --> 00:16:13,600
the network and something to note sorry

00:16:12,000 --> 00:16:16,240
something to note is that

00:16:13,600 --> 00:16:17,120
these nodes follow a multi-class setup

00:16:16,240 --> 00:16:20,320
where every

00:16:17,120 --> 00:16:24,000
customer would be using a combination of

00:16:20,320 --> 00:16:26,959
these vehicles so let us

00:16:24,000 --> 00:16:29,040
actually start with implementation how

00:16:26,959 --> 00:16:32,160
are we calculating congestion

00:16:29,040 --> 00:16:35,279
we use a heuristic called the bureau

00:16:32,160 --> 00:16:36,000
of public roads heuristic or bpr in

00:16:35,279 --> 00:16:39,360
short

00:16:36,000 --> 00:16:42,800
and what it does is that it tries to

00:16:39,360 --> 00:16:46,639
estimate the travel time required

00:16:42,800 --> 00:16:50,560
to go through an edge uv in the graph

00:16:46,639 --> 00:16:52,399
so okay inherent you know intuitively

00:16:50,560 --> 00:16:55,600
speaking

00:16:52,399 --> 00:16:58,959
if your available road capacity

00:16:55,600 --> 00:17:00,480
is less that means the number of

00:16:58,959 --> 00:17:04,400
vehicles on the road

00:17:00,480 --> 00:17:07,760
are more and that means your travel

00:17:04,400 --> 00:17:10,160
time to cross that road would be

00:17:07,760 --> 00:17:11,039
more so that means you're facing more

00:17:10,160 --> 00:17:13,520
congestion

00:17:11,039 --> 00:17:14,559
and traffic jam if your number of

00:17:13,520 --> 00:17:18,160
vehicles on the road

00:17:14,559 --> 00:17:21,199
are more right it's more

00:17:18,160 --> 00:17:24,400
so in this equation you can see

00:17:21,199 --> 00:17:27,760
that td uv is actually

00:17:24,400 --> 00:17:31,600
the estimated travel time to cross

00:17:27,760 --> 00:17:35,039
an edge uv and tuv refers to

00:17:31,600 --> 00:17:37,440
free flow time for ub so what again to

00:17:35,039 --> 00:17:41,039
reiterate it means that

00:17:37,440 --> 00:17:42,880
it is time that would take a person to

00:17:41,039 --> 00:17:43,760
cross you and be given that there are no

00:17:42,880 --> 00:17:46,960
roads on the

00:17:43,760 --> 00:17:48,880
no vehicles on the road at all and using

00:17:46,960 --> 00:17:50,799
this equation alpha beta are constants

00:17:48,880 --> 00:17:53,440
f refers to the number of vehicles on

00:17:50,799 --> 00:17:56,559
the road at that point and capacity

00:17:53,440 --> 00:17:59,520
uh c belongs to capacity of that road

00:17:56,559 --> 00:18:00,000
so you can say that if number of

00:17:59,520 --> 00:18:04,080
vehicles

00:18:00,000 --> 00:18:06,400
on the road are more for on an huv

00:18:04,080 --> 00:18:09,120
the estimated travel time would be

00:18:06,400 --> 00:18:11,280
really really high

00:18:09,120 --> 00:18:13,360
all right so after we've computed

00:18:11,280 --> 00:18:15,679
congestion for the entire network

00:18:13,360 --> 00:18:18,320
using this heuristic we are going to

00:18:15,679 --> 00:18:21,919
compute our middle mile transit nodes

00:18:18,320 --> 00:18:22,480
well okay to put it in a very graphical

00:18:21,919 --> 00:18:25,840
way an

00:18:22,480 --> 00:18:29,039
entire customer trip could be seen

00:18:25,840 --> 00:18:30,160
in this manner x and y become our source

00:18:29,039 --> 00:18:33,120
and destination

00:18:30,160 --> 00:18:34,320
and a and b become our transit points

00:18:33,120 --> 00:18:38,240
for the middle mile

00:18:34,320 --> 00:18:40,799
so basically we a person would be

00:18:38,240 --> 00:18:43,360
working or using micro mobility options

00:18:40,799 --> 00:18:46,000
from x to a as their first mile

00:18:43,360 --> 00:18:47,039
then taking a vehicle from a to b as

00:18:46,000 --> 00:18:49,280
their middle mile

00:18:47,039 --> 00:18:50,480
and then taking another vehicle or just

00:18:49,280 --> 00:18:53,760
walking again from b

00:18:50,480 --> 00:18:56,320
to y as their last mile so x and y

00:18:53,760 --> 00:18:58,160
are set we only need to find a and b

00:18:56,320 --> 00:19:01,520
which happen to be our optimal

00:18:58,160 --> 00:19:04,799
transit points for the middle mile

00:19:01,520 --> 00:19:07,600
how this is done is actually very simple

00:19:04,799 --> 00:19:07,919
and very intuitive so let's say this is

00:19:07,600 --> 00:19:09,679
a

00:19:07,919 --> 00:19:11,200
source and the person wants to go to

00:19:09,679 --> 00:19:14,720
their destination

00:19:11,200 --> 00:19:17,679
we first take a radius

00:19:14,720 --> 00:19:19,760
of 500 meters so total it's like 500

00:19:17,679 --> 00:19:23,200
plus 500 up to one kilometer

00:19:19,760 --> 00:19:27,200
radius for the from the person and

00:19:23,200 --> 00:19:30,240
their destination and we check what are

00:19:27,200 --> 00:19:31,120
possible nodes within this radius that a

00:19:30,240 --> 00:19:34,400
person can

00:19:31,120 --> 00:19:37,280
walk to and then

00:19:34,400 --> 00:19:38,080
take a middle mile vehicle from this

00:19:37,280 --> 00:19:41,200
node

00:19:38,080 --> 00:19:42,480
to to cover the rest of their rest of

00:19:41,200 --> 00:19:45,520
their

00:19:42,480 --> 00:19:48,559
journey right so a person

00:19:45,520 --> 00:19:51,280
could walk to either a b or c

00:19:48,559 --> 00:19:52,240
and then take a middle mile vehicle to

00:19:51,280 --> 00:19:55,760
either d

00:19:52,240 --> 00:19:58,880
e or f and after reaching i any of these

00:19:55,760 --> 00:20:00,799
points they would further walk from d e

00:19:58,880 --> 00:20:02,559
or f to their destination and complete

00:20:00,799 --> 00:20:05,760
their entire journey

00:20:02,559 --> 00:20:08,240
so already we are trying to implement a

00:20:05,760 --> 00:20:11,360
multi-class fleet setup

00:20:08,240 --> 00:20:12,480
so you can see that a person has about

00:20:11,360 --> 00:20:16,000
three into three

00:20:12,480 --> 00:20:17,360
nine combinations of possible routes to

00:20:16,000 --> 00:20:21,039
take

00:20:17,360 --> 00:20:24,080
and that route is selected

00:20:21,039 --> 00:20:26,159
which will result in the least

00:20:24,080 --> 00:20:27,600
overall travel time from source to

00:20:26,159 --> 00:20:30,159
destination

00:20:27,600 --> 00:20:31,919
right so that means a and f have to be

00:20:30,159 --> 00:20:35,039
selected in a way which will be

00:20:31,919 --> 00:20:36,720
optimal and provide minimum travel time

00:20:35,039 --> 00:20:40,080
from source to destination

00:20:36,720 --> 00:20:43,840
so how a and f are calculated

00:20:40,080 --> 00:20:45,840
uh is actually done by an algorithm that

00:20:43,840 --> 00:20:47,440
we proposed and it's called modified

00:20:45,840 --> 00:20:50,720
hybrid search

00:20:47,440 --> 00:20:52,960
so all right now this

00:20:50,720 --> 00:20:54,400
is in this graph you see that there is a

00:20:52,960 --> 00:20:57,919
point x1 y1

00:20:54,400 --> 00:21:00,640
and there is another point x2 y2 and

00:20:57,919 --> 00:21:02,159
the blue line actually corresponds to a

00:21:00,640 --> 00:21:03,760
euclidean distance which is actually

00:21:02,159 --> 00:21:07,280
just a straight line drawn

00:21:03,760 --> 00:21:11,360
and then the red line corresponds to the

00:21:07,280 --> 00:21:14,240
actual path that has to be taken to

00:21:11,360 --> 00:21:15,280
to go from this point to this point so

00:21:14,240 --> 00:21:17,039
you see

00:21:15,280 --> 00:21:18,559
theoretically speaking euclidean

00:21:17,039 --> 00:21:20,960
distances

00:21:18,559 --> 00:21:22,080
serve as a lower bound for every

00:21:20,960 --> 00:21:24,799
distance

00:21:22,080 --> 00:21:26,320
and if we try to just translate

00:21:24,799 --> 00:21:30,480
distances to time

00:21:26,320 --> 00:21:33,840
just by dividing it by constant speed

00:21:30,480 --> 00:21:34,960
so euclidean times are again serving as

00:21:33,840 --> 00:21:38,960
a lower bound

00:21:34,960 --> 00:21:41,600
for a path which has

00:21:38,960 --> 00:21:44,240
you know a path having the actual

00:21:41,600 --> 00:21:44,240
distance

00:21:44,320 --> 00:21:51,280
from a to b all right so over here

00:21:48,000 --> 00:21:55,200
what you see is that this array

00:21:51,280 --> 00:21:58,240
is a euclidean array

00:21:55,200 --> 00:22:00,480
now what that means is that

00:21:58,240 --> 00:22:02,640
let's take an example just to understand

00:22:00,480 --> 00:22:04,559
all of this easier

00:22:02,640 --> 00:22:06,480
uh in the previous example we saw that

00:22:04,559 --> 00:22:08,159
there were nine possible rules in this

00:22:06,480 --> 00:22:09,760
case let's say there were ten possible

00:22:08,159 --> 00:22:11,360
rules for the person to go from the

00:22:09,760 --> 00:22:14,880
source to destination

00:22:11,360 --> 00:22:16,799
so in their array are we have euclidean

00:22:14,880 --> 00:22:19,039
distances calculated

00:22:16,799 --> 00:22:20,480
for all the 10 possible source

00:22:19,039 --> 00:22:22,960
destination pairs

00:22:20,480 --> 00:22:24,320
and they are then sorted in increasing

00:22:22,960 --> 00:22:26,960
order of their

00:22:24,320 --> 00:22:28,400
length now again if i divided all of

00:22:26,960 --> 00:22:30,159
them with that

00:22:28,400 --> 00:22:31,600
with a constant speed they would become

00:22:30,159 --> 00:22:34,480
time so

00:22:31,600 --> 00:22:36,799
in this case these are euclidean times

00:22:34,480 --> 00:22:40,480
sorted in increasing order

00:22:36,799 --> 00:22:44,480
and ideally if i want to

00:22:40,480 --> 00:22:45,360
find a a source destination pair having

00:22:44,480 --> 00:22:48,559
the shortest

00:22:45,360 --> 00:22:49,840
distance or shortest travel time i would

00:22:48,559 --> 00:22:53,600
have to go through

00:22:49,840 --> 00:22:54,320
all these 10 uh elements and check which

00:22:53,600 --> 00:22:56,320
is the

00:22:54,320 --> 00:22:57,600
which is my minimum pair and then output

00:22:56,320 --> 00:23:00,400
it but

00:22:57,600 --> 00:23:00,799
that is not that that is not optimal at

00:23:00,400 --> 00:23:04,000
all

00:23:00,799 --> 00:23:05,760
because n could be really huge so

00:23:04,000 --> 00:23:06,480
therefore we are trying to modify the

00:23:05,760 --> 00:23:09,919
search

00:23:06,480 --> 00:23:12,559
and try to return early and

00:23:09,919 --> 00:23:14,159
in turn also provide an optimal answer

00:23:12,559 --> 00:23:15,200
all right so after we have this

00:23:14,159 --> 00:23:17,120
euclidean

00:23:15,200 --> 00:23:18,240
time sorted which is serving as our

00:23:17,120 --> 00:23:21,120
lower bound

00:23:18,240 --> 00:23:22,000
what we do is we define a cut off which

00:23:21,120 --> 00:23:25,360
is equal to

00:23:22,000 --> 00:23:28,400
sale of n by e is base of log

00:23:25,360 --> 00:23:31,039
logarithmic so which is equal to

00:23:28,400 --> 00:23:32,480
fourth element 10 by e is approximately

00:23:31,039 --> 00:23:34,480
the fourth element

00:23:32,480 --> 00:23:36,880
and then we have a decider which is

00:23:34,480 --> 00:23:37,919
equal to cut off plus one or the fifth

00:23:36,880 --> 00:23:40,640
element

00:23:37,919 --> 00:23:41,440
now the significance of this cut off is

00:23:40,640 --> 00:23:44,720
that

00:23:41,440 --> 00:23:47,760
after we have searched till our cut

00:23:44,720 --> 00:23:48,640
off we are going to stop our search and

00:23:47,760 --> 00:23:51,600
return

00:23:48,640 --> 00:23:53,039
whatever answer we have gotten till now

00:23:51,600 --> 00:23:55,200
whether it is optimal

00:23:53,039 --> 00:23:57,120
or not we will assume that that answer

00:23:55,200 --> 00:24:00,159
that we got is optimal

00:23:57,120 --> 00:24:02,400
if till cut off we haven't received an

00:24:00,159 --> 00:24:04,159
answer then we will compare with decider

00:24:02,400 --> 00:24:07,520
and return our answer

00:24:04,159 --> 00:24:11,039
okay now this cutoff was selected

00:24:07,520 --> 00:24:13,360
using a concept which was used in

00:24:11,039 --> 00:24:16,000
a problem called secret hiring secretary

00:24:13,360 --> 00:24:20,159
problem which you can read about further

00:24:16,000 --> 00:24:23,679
it basically um it basically claims

00:24:20,159 --> 00:24:26,640
that a person i mean sorry

00:24:23,679 --> 00:24:27,200
after the stopping criteria of n by e

00:24:26,640 --> 00:24:32,240
there is

00:24:27,200 --> 00:24:34,799
always a 37 percent of wind

00:24:32,240 --> 00:24:36,960
guaranteed all right so we're going to

00:24:34,799 --> 00:24:39,919
see how this works out for us

00:24:36,960 --> 00:24:41,760
so let's say what we do is that we go to

00:24:39,919 --> 00:24:45,679
our first element

00:24:41,760 --> 00:24:49,360
which has a euclidean time of 10

00:24:45,679 --> 00:24:49,679
units and we open up that element and we

00:24:49,360 --> 00:24:53,279
see

00:24:49,679 --> 00:24:56,960
that the actual travel time is 29

00:24:53,279 --> 00:25:00,400
units now this 29 units is

00:24:56,960 --> 00:25:03,840
greater than its next euclidean unit

00:25:00,400 --> 00:25:06,400
which is 20 so that means

00:25:03,840 --> 00:25:08,480
so then we try to open the second

00:25:06,400 --> 00:25:11,919
element which is 25

00:25:08,480 --> 00:25:14,480
now we see that 25 is lesser than 29

00:25:11,919 --> 00:25:14,960
so till now our minimum pair happens to

00:25:14,480 --> 00:25:18,000
be

00:25:14,960 --> 00:25:20,559
25 we also see

00:25:18,000 --> 00:25:22,960
that 25 is lesser than its next

00:25:20,559 --> 00:25:25,840
euclidean element which is 30

00:25:22,960 --> 00:25:28,159
and we know that euclidean distances or

00:25:25,840 --> 00:25:31,679
travel time serve as the lower bound

00:25:28,159 --> 00:25:34,720
that means 25 is bound to be

00:25:31,679 --> 00:25:35,520
the lowest element in all of these 10

00:25:34,720 --> 00:25:37,520
elements

00:25:35,520 --> 00:25:38,880
so we have found our optimal transit

00:25:37,520 --> 00:25:42,159
points and it's time

00:25:38,880 --> 00:25:45,440
to return that's it

00:25:42,159 --> 00:25:46,080
in case 2 we do the same thing and we

00:25:45,440 --> 00:25:47,919
open up

00:25:46,080 --> 00:25:50,400
the first element in this case we see

00:25:47,919 --> 00:25:52,880
that the actual travel time is 35 units

00:25:50,400 --> 00:25:54,320
it's greater than the next euclidean

00:25:52,880 --> 00:25:56,640
unit so we open

00:25:54,320 --> 00:25:57,440
the second element which is which is 32

00:25:56,640 --> 00:26:00,400
units

00:25:57,440 --> 00:26:02,000
till now 32 has been a minimum because

00:26:00,400 --> 00:26:05,440
it's lesser than 35

00:26:02,000 --> 00:26:08,000
so it's a minimum parallel now but 32 is

00:26:05,440 --> 00:26:09,840
still greater than its next euclidean

00:26:08,000 --> 00:26:11,520
unit so we have to open up the third

00:26:09,840 --> 00:26:15,120
element as well

00:26:11,520 --> 00:26:18,080
it happens to be 45 so our 32 units

00:26:15,120 --> 00:26:20,080
is still the minimum pair and 45 is

00:26:18,080 --> 00:26:22,640
still greater than the fourth so we open

00:26:20,080 --> 00:26:26,159
that up which is 55

00:26:22,640 --> 00:26:26,960
moving on we have 65 so we have reached

00:26:26,159 --> 00:26:30,640
the cutoff

00:26:26,960 --> 00:26:33,919
65 happens to be a decider so now

00:26:30,640 --> 00:26:35,600
we have to stop at our cut off we see 32

00:26:33,919 --> 00:26:36,960
is still lesser than our decider

00:26:35,600 --> 00:26:40,799
therefore we

00:26:36,960 --> 00:26:44,080
return our minimum pair to beat us 32

00:26:40,799 --> 00:26:46,960
and we stop our search in case

00:26:44,080 --> 00:26:47,440
there could be us an alternate case

00:26:46,960 --> 00:26:51,200
wherein

00:26:47,440 --> 00:26:54,159
we are continuously opening up our

00:26:51,200 --> 00:26:55,039
uh elements and we reach our decider

00:26:54,159 --> 00:26:58,320
again

00:26:55,039 --> 00:27:00,559
and we see that in this case actually

00:26:58,320 --> 00:27:02,159
our decider was lesser than the minimum

00:27:00,559 --> 00:27:04,159
pair we had till now

00:27:02,159 --> 00:27:05,919
so in this case we would return the

00:27:04,159 --> 00:27:07,919
decider because that has been the

00:27:05,919 --> 00:27:11,200
minimum up till now

00:27:07,919 --> 00:27:13,360
so this way we see that

00:27:11,200 --> 00:27:15,520
in either of the cases we haven't

00:27:13,360 --> 00:27:16,720
searched all 10 elements we have

00:27:15,520 --> 00:27:20,080
returned a minimum

00:27:16,720 --> 00:27:23,840
pair um before uh

00:27:20,080 --> 00:27:26,640
up till a certain cut off and

00:27:23,840 --> 00:27:27,039
something to note of interest is that

00:27:26,640 --> 00:27:29,919
this

00:27:27,039 --> 00:27:30,559
has basically helped us to reduce our

00:27:29,919 --> 00:27:34,080
number of

00:27:30,559 --> 00:27:37,840
queries which translates to that

00:27:34,080 --> 00:27:39,120
there has been um computational

00:27:37,840 --> 00:27:41,120
efficiency in

00:27:39,120 --> 00:27:42,559
all these three cases so in the first

00:27:41,120 --> 00:27:45,039
case there has been an 80

00:27:42,559 --> 00:27:47,360
reduction in number of queries and in

00:27:45,039 --> 00:27:49,840
these two cases there has been about 50

00:27:47,360 --> 00:27:50,640
reduction in the number of queries so

00:27:49,840 --> 00:27:54,320
we've gotten an

00:27:50,640 --> 00:27:58,080
answer about that much percentage uh

00:27:54,320 --> 00:27:58,080
we've gotten an answer that much faster

00:27:58,159 --> 00:28:01,840
so i pre proposed this algorithm but is

00:28:01,200 --> 00:28:05,679
it

00:28:01,840 --> 00:28:07,360
even any good so we did a number of

00:28:05,679 --> 00:28:10,159
numerical experiments

00:28:07,360 --> 00:28:12,399
just to see how it is actually scaling

00:28:10,159 --> 00:28:13,360
up to our actual singapore's network

00:28:12,399 --> 00:28:15,919
data

00:28:13,360 --> 00:28:18,320
well the first numerical experiment we

00:28:15,919 --> 00:28:19,520
did was to compare different kinds of

00:28:18,320 --> 00:28:22,480
searches so

00:28:19,520 --> 00:28:24,480
blue represents a modified hybrid search

00:28:22,480 --> 00:28:27,840
that we just explained

00:28:24,480 --> 00:28:30,480
um orange represents a search which is

00:28:27,840 --> 00:28:32,799
actually hybrid search which was

00:28:30,480 --> 00:28:33,679
which is a primitive method of the

00:28:32,799 --> 00:28:36,240
search

00:28:33,679 --> 00:28:38,720
approach we're using now and green

00:28:36,240 --> 00:28:40,480
represents our optimal exhaustive search

00:28:38,720 --> 00:28:41,440
wherein you are going to search through

00:28:40,480 --> 00:28:44,720
every element

00:28:41,440 --> 00:28:48,000
to find your minimum pair and you see

00:28:44,720 --> 00:28:51,120
that we found our optimal

00:28:48,000 --> 00:28:53,679
minimum pair in

00:28:51,120 --> 00:28:56,320
the least amount of queries for a

00:28:53,679 --> 00:28:59,520
modified hybrid search

00:28:56,320 --> 00:29:01,039
so in all three cases okay sorry

00:28:59,520 --> 00:29:04,640
something to note over here

00:29:01,039 --> 00:29:08,000
is that congestion and traffic jams

00:29:04,640 --> 00:29:11,600
depend on times so

00:29:08,000 --> 00:29:16,000
in singapore uh we basically took

00:29:11,600 --> 00:29:18,880
three slices of time to incorporate

00:29:16,000 --> 00:29:19,679
different congestion patterns throughout

00:29:18,880 --> 00:29:21,760
the day

00:29:19,679 --> 00:29:23,360
so that we can validate that our

00:29:21,760 --> 00:29:25,120
framework doesn't only work when it's

00:29:23,360 --> 00:29:27,840
high peak or off peak

00:29:25,120 --> 00:29:28,640
so we have off peak as 12 a.m or

00:29:27,840 --> 00:29:31,760
midnight

00:29:28,640 --> 00:29:34,880
we have moderately peak which is 3 p.m

00:29:31,760 --> 00:29:36,640
when it is lunch and then we have high

00:29:34,880 --> 00:29:38,000
peak which is 6 p.m when people are

00:29:36,640 --> 00:29:40,880
finally starting to

00:29:38,000 --> 00:29:42,799
go to their office sorry come back to

00:29:40,880 --> 00:29:44,240
their homes from their offices so it's a

00:29:42,799 --> 00:29:47,200
rush hour

00:29:44,240 --> 00:29:48,159
so in all these three cases we see that

00:29:47,200 --> 00:29:52,399
the number of

00:29:48,159 --> 00:29:55,440
queries required to get a minimum

00:29:52,399 --> 00:29:59,039
optimal transit point has been the least

00:29:55,440 --> 00:30:02,200
using our modified hybrid search and

00:29:59,039 --> 00:30:03,600
there has been an average reduction of

00:30:02,200 --> 00:30:07,440
70.07

00:30:03,600 --> 00:30:09,600
percent queries and then

00:30:07,440 --> 00:30:12,799
with with a negligible average delay of

00:30:09,600 --> 00:30:13,360
just 4.67 seconds so what this means is

00:30:12,799 --> 00:30:16,640
that

00:30:13,360 --> 00:30:18,720
let's say an algorithm or a framework

00:30:16,640 --> 00:30:20,159
would tell you that the estimated travel

00:30:18,720 --> 00:30:22,960
time from a to b

00:30:20,159 --> 00:30:24,880
was 30 minutes our framework would tell

00:30:22,960 --> 00:30:25,520
you that the estimated travel time from

00:30:24,880 --> 00:30:29,960
a to b

00:30:25,520 --> 00:30:33,039
is 30.467 minutes 34.4

00:30:29,960 --> 00:30:36,960
34.67 second minutes

00:30:33,039 --> 00:30:40,080
so you see that that kind of delay

00:30:36,960 --> 00:30:43,279
is absolutely negligible for a use case

00:30:40,080 --> 00:30:43,279
like transportation

00:30:44,240 --> 00:30:50,799
the second proof has been that we

00:30:47,520 --> 00:30:53,679
tried to um compare

00:30:50,799 --> 00:30:56,080
two kinds of framework our framework is

00:30:53,679 --> 00:30:59,840
using a multi-class

00:30:56,080 --> 00:31:03,279
fleet which is that it's trying to use

00:30:59,840 --> 00:31:04,960
three kinds of uh sorry two kinds of you

00:31:03,279 --> 00:31:06,720
know it's trying to break a customer

00:31:04,960 --> 00:31:11,360
trip into three classes

00:31:06,720 --> 00:31:14,960
and routing using congestion aware paths

00:31:11,360 --> 00:31:17,440
in a system equilibrium way and we

00:31:14,960 --> 00:31:18,240
are comparing it against a framework

00:31:17,440 --> 00:31:21,519
which uses

00:31:18,240 --> 00:31:22,960
just a single vehicle from source to

00:31:21,519 --> 00:31:25,600
destination

00:31:22,960 --> 00:31:28,240
in a very user-centric approach which is

00:31:25,600 --> 00:31:30,640
what we all do generally

00:31:28,240 --> 00:31:32,080
we take we tend to take the shortest

00:31:30,640 --> 00:31:34,000
distance route

00:31:32,080 --> 00:31:35,519
using just one vehicle from our source

00:31:34,000 --> 00:31:39,120
to destination

00:31:35,519 --> 00:31:42,399
so in this graph we see

00:31:39,120 --> 00:31:46,399
that there has been um

00:31:42,399 --> 00:31:47,919
about 74.26 of waiting queue size

00:31:46,399 --> 00:31:51,120
reduction so what this

00:31:47,919 --> 00:31:54,559
basically means is that there has been

00:31:51,120 --> 00:31:58,080
an increase in the network utilization

00:31:54,559 --> 00:32:02,080
by 74.26 percent by using

00:31:58,080 --> 00:32:05,360
our framework it means that you can so

00:32:02,080 --> 00:32:08,559
these many percentage people

00:32:05,360 --> 00:32:12,320
could be uh more people could

00:32:08,559 --> 00:32:16,240
be given or allotted a congestion free

00:32:12,320 --> 00:32:19,679
pass as opposed to your user

00:32:16,240 --> 00:32:23,519
equilibrium and

00:32:19,679 --> 00:32:26,399
all of these people in the network

00:32:23,519 --> 00:32:27,360
face zero congestion at all times

00:32:26,399 --> 00:32:29,279
because these

00:32:27,360 --> 00:32:30,880
congestion aware because all of these

00:32:29,279 --> 00:32:32,559
rules allotted were

00:32:30,880 --> 00:32:35,039
being allotted in a congestion aware

00:32:32,559 --> 00:32:35,039
fashion

00:32:35,519 --> 00:32:43,039
and well the third proof

00:32:38,559 --> 00:32:46,720
is that well if we calculate the overall

00:32:43,039 --> 00:32:49,200
travel time of the entire system

00:32:46,720 --> 00:32:51,120
into the number of vehicles that were

00:32:49,200 --> 00:32:51,519
actually present on the road at that

00:32:51,120 --> 00:32:54,720
time

00:32:51,519 --> 00:32:57,440
which basically means a flow time cost

00:32:54,720 --> 00:32:58,159
it is simply number of vehicles into

00:32:57,440 --> 00:33:01,679
ours

00:32:58,159 --> 00:33:03,440
travel time so for all three peaks we

00:33:01,679 --> 00:33:06,720
see again that our blue

00:33:03,440 --> 00:33:09,039
blue framework as opposed to a single

00:33:06,720 --> 00:33:13,840
class user equilibrium framework

00:33:09,039 --> 00:33:16,159
is performs better

00:33:13,840 --> 00:33:18,159
than this orange one there is a

00:33:16,159 --> 00:33:21,600
reduction of twelve point

00:33:18,159 --> 00:33:24,880
one three percent in overall

00:33:21,600 --> 00:33:26,240
average flow cost so this basically

00:33:24,880 --> 00:33:29,760
translates to that

00:33:26,240 --> 00:33:31,279
in a system um there is a reduction of

00:33:29,760 --> 00:33:34,880
33 minutes per trip

00:33:31,279 --> 00:33:38,000
so let's say on an average if a person

00:33:34,880 --> 00:33:41,919
takes one hour to go from a to b

00:33:38,000 --> 00:33:41,919
on an average a person would be

00:33:42,720 --> 00:33:46,240
there would be a reduction of 33 minutes

00:33:45,039 --> 00:33:49,679
per trip

00:33:46,240 --> 00:33:53,120
for every request in the network so

00:33:49,679 --> 00:33:56,399
all of these numerical experiments show

00:33:53,120 --> 00:33:59,760
how powerful our framework is just

00:33:56,399 --> 00:34:02,960
by increasing um

00:33:59,760 --> 00:34:05,039
the time taken just by increasing the

00:34:02,960 --> 00:34:08,720
time taken

00:34:05,039 --> 00:34:13,520
by walking or using pedestrian networks

00:34:08,720 --> 00:34:16,320
uh which most of us do not

00:34:13,520 --> 00:34:17,359
do not use because we're kind of lazy or

00:34:16,320 --> 00:34:20,960
we just want

00:34:17,359 --> 00:34:23,599
ease so

00:34:20,960 --> 00:34:27,200
okay now this is actually our framework

00:34:23,599 --> 00:34:29,440
being used against a real life example

00:34:27,200 --> 00:34:30,560
so we have used state of the art which

00:34:29,440 --> 00:34:32,560
is google maps

00:34:30,560 --> 00:34:33,839
and we see that let's say a person wants

00:34:32,560 --> 00:34:36,720
to go from

00:34:33,839 --> 00:34:37,679
this red spot to this destination over

00:34:36,720 --> 00:34:40,240
here

00:34:37,679 --> 00:34:42,560
so google maps actually gives us the

00:34:40,240 --> 00:34:45,839
brown path which is on the right

00:34:42,560 --> 00:34:46,879
over here it says that there is a total

00:34:45,839 --> 00:34:50,000
trip time

00:34:46,879 --> 00:34:52,240
of 53 minutes

00:34:50,000 --> 00:34:54,800
from your start to destination which

00:34:52,240 --> 00:34:57,520
also incorporates walking so this

00:34:54,800 --> 00:34:58,480
also is recommending you a multi-class

00:34:57,520 --> 00:35:02,320
setup

00:34:58,480 --> 00:35:02,880
but it says that it involves about 21

00:35:02,320 --> 00:35:05,520
minutes

00:35:02,880 --> 00:35:06,800
of total walking including first and

00:35:05,520 --> 00:35:09,359
last mile

00:35:06,800 --> 00:35:11,359
which is like 10 minutes here and 11

00:35:09,359 --> 00:35:12,560
minutes here and then the rest is middle

00:35:11,359 --> 00:35:16,400
mile

00:35:12,560 --> 00:35:20,160
uh having the total time is 53 minutes

00:35:16,400 --> 00:35:21,920
and then the the path on the left is our

00:35:20,160 --> 00:35:26,400
framework in pink

00:35:21,920 --> 00:35:29,680
which says that you have to walk

00:35:26,400 --> 00:35:31,440
for a total time of 33 minutes

00:35:29,680 --> 00:35:33,359
which is like 15 minutes here

00:35:31,440 --> 00:35:36,400
approximately 15 minutes here

00:35:33,359 --> 00:35:38,800
and the pink part is middle mile

00:35:36,400 --> 00:35:40,960
having your overall trip time from start

00:35:38,800 --> 00:35:42,960
to finish is 45 minutes

00:35:40,960 --> 00:35:45,200
so there has been a reduction in the

00:35:42,960 --> 00:35:48,960
overall travel time by just

00:35:45,200 --> 00:35:50,640
increasing your time in walking or

00:35:48,960 --> 00:35:53,520
bicycling

00:35:50,640 --> 00:35:55,200
by just a little more but by just a

00:35:53,520 --> 00:35:59,119
little more minutes

00:35:55,200 --> 00:36:02,480
so there so this is

00:35:59,119 --> 00:36:05,280
us trying to explain how

00:36:02,480 --> 00:36:06,320
our framework is working against state

00:36:05,280 --> 00:36:09,040
of the art

00:36:06,320 --> 00:36:10,000
because it is also trying it is not only

00:36:09,040 --> 00:36:13,760
trying to

00:36:10,000 --> 00:36:15,599
reduce um one user's overall trip time

00:36:13,760 --> 00:36:17,359
it is trying to reduce every person's

00:36:15,599 --> 00:36:19,599
trip time by

00:36:17,359 --> 00:36:22,000
analyzing congestion throughout the

00:36:19,599 --> 00:36:25,440
network

00:36:22,000 --> 00:36:28,720
and so we are at the end of

00:36:25,440 --> 00:36:31,680
our presentation and we have been

00:36:28,720 --> 00:36:33,680
able to achieve congestion aware roots

00:36:31,680 --> 00:36:35,599
in a system optimal way

00:36:33,680 --> 00:36:36,960
for our entire framework so let's

00:36:35,599 --> 00:36:40,880
summarize just

00:36:36,960 --> 00:36:41,839
guess we first start by extracting all

00:36:40,880 --> 00:36:44,400
of our data

00:36:41,839 --> 00:36:46,079
using python's open source which is

00:36:44,400 --> 00:36:49,839
libraries

00:36:46,079 --> 00:36:52,480
and then we try to implement our

00:36:49,839 --> 00:36:53,839
algorithm by finding possible notes that

00:36:52,480 --> 00:36:56,800
we could walk to or

00:36:53,839 --> 00:36:58,160
cycle to after which we could take

00:36:56,800 --> 00:37:01,599
minimum

00:36:58,160 --> 00:37:03,760
vehicles and then complete our

00:37:01,599 --> 00:37:08,320
ship so this incorporates a monthly

00:37:03,760 --> 00:37:11,599
class setup

00:37:08,320 --> 00:37:12,640
we find these optimal transit points

00:37:11,599 --> 00:37:14,960
using a pro

00:37:12,640 --> 00:37:15,920
a proposed algorithm called modified

00:37:14,960 --> 00:37:20,000
hybrid search

00:37:15,920 --> 00:37:22,240
which is fast and absolutely

00:37:20,000 --> 00:37:25,359
computationally efficient than state of

00:37:22,240 --> 00:37:29,520
the art by about 70 percent

00:37:25,359 --> 00:37:31,520
um and there is always a reduction in

00:37:29,520 --> 00:37:34,839
queries

00:37:31,520 --> 00:37:37,119
uh and and there is absolute network

00:37:34,839 --> 00:37:40,720
utilization

00:37:37,119 --> 00:37:43,520
and overall trip time and travel time is

00:37:40,720 --> 00:37:43,520
also reduced

00:37:43,680 --> 00:37:47,760
and we finally have this architecture in

00:37:46,400 --> 00:37:51,040
place

00:37:47,760 --> 00:37:53,119
which helps a system optimal

00:37:51,040 --> 00:37:56,079
condition aware routing for every

00:37:53,119 --> 00:37:59,119
customer in the network

00:37:56,079 --> 00:38:02,320
so well all these are

00:37:59,119 --> 00:38:03,440
the list of references that were used to

00:38:02,320 --> 00:38:06,480
make

00:38:03,440 --> 00:38:08,480
this framework a reality

00:38:06,480 --> 00:38:10,240
and we gained inspiration from all the

00:38:08,480 --> 00:38:12,880
police

00:38:10,240 --> 00:38:13,680
and well that is all and thank you for

00:38:12,880 --> 00:38:16,960
listening to me

00:38:13,680 --> 00:38:21,680
and i hope you all learned something and

00:38:16,960 --> 00:38:21,680
had fun in this journey with me thank

00:38:22,920 --> 00:38:25,920

YouTube URL: https://www.youtube.com/watch?v=I8v9iQEitLI


