Title: Using Containers and VMs on Free Public CIs
Publication date: 2020-10-06
Playlist: DevConfUS 2020
Description: 
	Speakers: David Davis & Mike DePaulo

At first glance, free public CIs seem insufficient for testing many open source projects. They provide only a single virtual machine with no choice of Linux distro, and no container or virtual infrastructure.

However, many projects are publishing as containers, or even kubernetes operators. Many have conventional installers that must be tested across numerous Linux distros. Some need SELinux or other CI-disabled kernel features.

This talk will explain how our project overcame all these limitations: container infrastructure and full virtual machines running on top of free public CIs, and alternative solutions that also work. The solutions will consist of a comparison of CI-compatible open source container infrastructures and hypervisors, CI design patterns for them, and other tips & tricks for integrating them.
Captions: 
	00:00:00,080 --> 00:00:03,199
sounds good thanks very much for joining

00:00:02,000 --> 00:00:05,440
and everyone stay

00:00:03,199 --> 00:00:06,799
after the video the video is about half

00:00:05,440 --> 00:00:08,080
an hour and then we'll have a question

00:00:06,799 --> 00:00:16,240
answer section with

00:00:08,080 --> 00:00:19,840
mike and david

00:00:16,240 --> 00:00:19,840
i'm going to start sharing the video now

00:00:26,240 --> 00:00:30,880
hi this is our dev talk um

00:00:29,279 --> 00:00:32,320
the topic of our talk is using

00:00:30,880 --> 00:00:35,840
containers and vms

00:00:32,320 --> 00:00:39,520
on free public cis

00:00:35,840 --> 00:00:39,520
for fun in world conquest

00:00:41,520 --> 00:00:48,399
just a brief intro my name is david

00:00:44,960 --> 00:00:51,760
davis i'm a software engineer at red hat

00:00:48,399 --> 00:00:51,760
and i work on the pulp project

00:00:54,320 --> 00:00:58,000
my name is mike depaolo i'm a service

00:00:56,559 --> 00:01:01,680
reliability engineer at red hat

00:00:58,000 --> 00:01:01,680
and i also work on the poll project

00:01:03,039 --> 00:01:09,200
okay so a quick overview of our talk

00:01:06,479 --> 00:01:10,880
first we're going to talk about pulp

00:01:09,200 --> 00:01:13,920
which is the project we work on

00:01:10,880 --> 00:01:16,799
it's sort of needed to understand

00:01:13,920 --> 00:01:18,720
our presentation next we're going to

00:01:16,799 --> 00:01:21,280
talk about the problems we faced

00:01:18,720 --> 00:01:23,920
working on poke when we used hosted ci

00:01:21,280 --> 00:01:25,040
environments

00:01:23,920 --> 00:01:28,479
after that we're going to talk about

00:01:25,040 --> 00:01:29,520
when to use containers or vms

00:01:28,479 --> 00:01:31,759
and then we're going to talk about the

00:01:29,520 --> 00:01:33,840
different solutions we tested and what

00:01:31,759 --> 00:01:35,040
our results were

00:01:33,840 --> 00:01:36,640
and then lastly we're going to talk

00:01:35,040 --> 00:01:41,840
about some tips for using vms and

00:01:36,640 --> 00:01:41,840
containers with hosted ci environments

00:01:42,320 --> 00:01:49,360
so a quick rundown of pulp um pulp is

00:01:46,159 --> 00:01:51,200
a software project you use it to

00:01:49,360 --> 00:01:54,560
organize packages of software

00:01:51,200 --> 00:01:56,960
into repositories has a plug-in

00:01:54,560 --> 00:01:58,799
architecture and we support a bunch of

00:01:56,960 --> 00:02:01,439
different content types

00:01:58,799 --> 00:02:02,799
um you can see some examples here python

00:02:01,439 --> 00:02:06,560
npm

00:02:02,799 --> 00:02:08,080
rubygems even docker images

00:02:06,560 --> 00:02:10,640
and you can create a plugin for any

00:02:08,080 --> 00:02:13,040
content type uh and extend pulp to

00:02:10,640 --> 00:02:15,520
support that content type

00:02:13,040 --> 00:02:16,239
and lastly pulp is entirely free in open

00:02:15,520 --> 00:02:18,400
source

00:02:16,239 --> 00:02:23,840
um it's on github so if you want to

00:02:18,400 --> 00:02:27,920
check it out there's a link right there

00:02:23,840 --> 00:02:30,959
um so what are hosted ci environments

00:02:27,920 --> 00:02:34,160
so these are typically free for

00:02:30,959 --> 00:02:36,480
open source projects they're public

00:02:34,160 --> 00:02:37,760
they provide a way to build and test out

00:02:36,480 --> 00:02:42,879
your code

00:02:37,760 --> 00:02:46,239
um and also these hosted ci environments

00:02:42,879 --> 00:02:49,360
they let communities um

00:02:46,239 --> 00:02:51,200
fork and test using your ci

00:02:49,360 --> 00:02:54,160
configuration

00:02:51,200 --> 00:02:56,080
and prs use the same ci environment as

00:02:54,160 --> 00:03:01,440
you to test

00:02:56,080 --> 00:03:01,440
out your your tests and stuff like that

00:03:03,280 --> 00:03:09,519
um so for uh pulp we use

00:03:06,879 --> 00:03:10,800
two different ci uh environments or

00:03:09,519 --> 00:03:12,720
hosted ci's we have

00:03:10,800 --> 00:03:14,239
experience with both uh travis and

00:03:12,720 --> 00:03:18,159
github actions

00:03:14,239 --> 00:03:18,959
um and so uh overall they're pretty

00:03:18,159 --> 00:03:21,200
similar

00:03:18,959 --> 00:03:22,480
um they do have different uh cloud

00:03:21,200 --> 00:03:24,560
backends

00:03:22,480 --> 00:03:25,519
um one uses google the only uses

00:03:24,560 --> 00:03:28,640
microsoft

00:03:25,519 --> 00:03:30,879
azure um

00:03:28,640 --> 00:03:33,120
they have the same operating system for

00:03:30,879 --> 00:03:36,879
linux they have similar

00:03:33,120 --> 00:03:40,400
uh specs on ram and disk space

00:03:36,879 --> 00:03:43,680
um their virtual cpus are also similar

00:03:40,400 --> 00:03:46,480
we ran a p7zip

00:03:43,680 --> 00:03:47,280
benchmarks against them which is a good

00:03:46,480 --> 00:03:50,959
indication of

00:03:47,280 --> 00:03:53,439
cpu uh speed those were pretty similar

00:03:50,959 --> 00:03:54,400
the one notable difference was um the

00:03:53,439 --> 00:03:56,879
disc

00:03:54,400 --> 00:03:57,680
performance um it seemed like github

00:03:56,879 --> 00:04:00,159
actions was

00:03:57,680 --> 00:04:02,159
almost three or four times faster in

00:04:00,159 --> 00:04:05,280
terms of both rated and right

00:04:02,159 --> 00:04:05,280
than travis

00:04:06,319 --> 00:04:10,560
we speculate that probably github

00:04:08,000 --> 00:04:15,840
actions is using ssds while travis is

00:04:10,560 --> 00:04:15,840
probably using hard disks

00:04:16,239 --> 00:04:19,440
um so what's the problem with uh hosting

00:04:18,160 --> 00:04:22,720
ci environments

00:04:19,440 --> 00:04:26,240
uh some problems that we encountered

00:04:22,720 --> 00:04:28,720
um is that there's a limited number of

00:04:26,240 --> 00:04:31,520
os or distros

00:04:28,720 --> 00:04:33,280
by default also the environment is

00:04:31,520 --> 00:04:34,880
pre-configured

00:04:33,280 --> 00:04:37,040
and it comes with a limited set of

00:04:34,880 --> 00:04:38,880
software packages

00:04:37,040 --> 00:04:40,400
there's also typically limited hardware

00:04:38,880 --> 00:04:44,400
resources

00:04:40,400 --> 00:04:46,479
which can make virtualization hard

00:04:44,400 --> 00:04:48,000
and then lastly you can't reboot or

00:04:46,479 --> 00:04:52,880
replace the kernel

00:04:48,000 --> 00:04:52,880
um when using a hosted ci environment

00:04:53,440 --> 00:04:56,880
um so to solve some of these problems

00:04:55,040 --> 00:04:57,440
you might turn into containers so when

00:04:56,880 --> 00:05:00,400
would you

00:04:57,440 --> 00:05:02,800
use containers um containers are pretty

00:05:00,400 --> 00:05:06,000
lightweight so you probably want to

00:05:02,800 --> 00:05:09,120
use those some cases where you

00:05:06,000 --> 00:05:10,720
would want to use them suppose you want

00:05:09,120 --> 00:05:13,520
to test against a bunch of different

00:05:10,720 --> 00:05:16,560
uh distributions of linux um containers

00:05:13,520 --> 00:05:18,639
provide a great way to do that

00:05:16,560 --> 00:05:19,840
um sometimes you might need tools like

00:05:18,639 --> 00:05:22,639
dnf which

00:05:19,840 --> 00:05:25,759
aren't available on all distros this is

00:05:22,639 --> 00:05:28,880
actually a use case for us

00:05:25,759 --> 00:05:31,280
we have an rpm plugin

00:05:28,880 --> 00:05:33,440
and we want to test using dnf to install

00:05:31,280 --> 00:05:36,240
packages from pulp

00:05:33,440 --> 00:05:36,639
of course ubuntu doesn't have that so we

00:05:36,240 --> 00:05:38,880
use

00:05:36,639 --> 00:05:41,120
it we spin up a fedora container to test

00:05:38,880 --> 00:05:42,880
that out

00:05:41,120 --> 00:05:44,160
you may want to use certain versions of

00:05:42,880 --> 00:05:45,919
software

00:05:44,160 --> 00:05:47,759
you can put that into a container and

00:05:45,919 --> 00:05:51,600
not pollute the

00:05:47,759 --> 00:05:56,080
host os that's a good use case for

00:05:51,600 --> 00:05:59,199
containers also we had a

00:05:56,080 --> 00:06:01,520
case where we're using a python package

00:05:59,199 --> 00:06:04,240
that's provided as a rpm

00:06:01,520 --> 00:06:06,080
and it gets installed system wide so we

00:06:04,240 --> 00:06:09,199
use a container for that to install

00:06:06,080 --> 00:06:12,319
and test out that package um which we

00:06:09,199 --> 00:06:12,319
don't package ourselves

00:06:12,720 --> 00:06:16,479
um so when would you want to use vms as

00:06:15,120 --> 00:06:18,840
opposed to containers

00:06:16,479 --> 00:06:20,160
well one of the big use cases we ran

00:06:18,840 --> 00:06:23,280
into

00:06:20,160 --> 00:06:26,800
is that we wanted to test against kernel

00:06:23,280 --> 00:06:29,919
modules or modes that require certain

00:06:26,800 --> 00:06:32,960
kernel parameters a couple good examples

00:06:29,919 --> 00:06:37,199
are sc linux and app armor

00:06:32,960 --> 00:06:39,840
um also we support fips 140-2

00:06:37,199 --> 00:06:40,960
this is a government standard that

00:06:39,840 --> 00:06:45,199
forbids the use

00:06:40,960 --> 00:06:47,919
of um weak uh cryptographic

00:06:45,199 --> 00:06:48,960
algorithms and centaurus and rail

00:06:47,919 --> 00:06:52,479
actually provide

00:06:48,960 --> 00:06:55,039
a mode that you can enable with a kernel

00:06:52,479 --> 00:06:55,039
parameter

00:06:55,759 --> 00:06:59,440
and it will actually turn off the use of

00:06:58,479 --> 00:07:02,080
some of these

00:06:59,440 --> 00:07:02,639
algorithms i mean of course you can't do

00:07:02,080 --> 00:07:05,919
that

00:07:02,639 --> 00:07:09,440
on using a hosted ci unless you use uh

00:07:05,919 --> 00:07:12,000
virtualization another good example is

00:07:09,440 --> 00:07:13,599
uh there's certain types of projects

00:07:12,000 --> 00:07:17,120
maybe you're working on a bootloader

00:07:13,599 --> 00:07:20,479
or a kernel module and

00:07:17,120 --> 00:07:23,520
you would have to use vms in order to

00:07:20,479 --> 00:07:23,520
test out those things

00:07:24,720 --> 00:07:29,599
so let's let's go into the nitty-gritty

00:07:27,680 --> 00:07:30,639
details of virtual machines versus

00:07:29,599 --> 00:07:33,759
containers

00:07:30,639 --> 00:07:36,479
because this affects whether we can uh

00:07:33,759 --> 00:07:40,080
run them at all in these ci environments

00:07:36,479 --> 00:07:40,080
and how we have to go about running them

00:07:40,479 --> 00:07:43,759
so like we mentioned we prefer

00:07:42,800 --> 00:07:46,160
containers

00:07:43,759 --> 00:07:47,440
over vms we only use vms when we can't

00:07:46,160 --> 00:07:50,400
use containers

00:07:47,440 --> 00:07:51,360
and uh the containers have a number of

00:07:50,400 --> 00:07:54,400
advantages

00:07:51,360 --> 00:07:56,720
because the container the all the

00:07:54,400 --> 00:07:58,000
instance all the the multiple options

00:07:56,720 --> 00:08:01,360
running share the same

00:07:58,000 --> 00:08:04,479
hardware in the same kernel uh there's

00:08:01,360 --> 00:08:08,080
no uh you know there's no performance or

00:08:04,479 --> 00:08:09,919
penalty for running them uh you get 100

00:08:08,080 --> 00:08:11,680
individual cpu performance

00:08:09,919 --> 00:08:13,039
and if a process needs ram but it's used

00:08:11,680 --> 00:08:15,360
like any other process

00:08:13,039 --> 00:08:16,960
whereas in vms you have like a 10 cp

00:08:15,360 --> 00:08:19,440
performance hit on average

00:08:16,960 --> 00:08:21,599
and on top of that the host and each

00:08:19,440 --> 00:08:23,440
guest have separate unused ram

00:08:21,599 --> 00:08:24,879
so you could have one guest that's

00:08:23,440 --> 00:08:26,720
swapping heavily and slowing down the

00:08:24,879 --> 00:08:28,319
entire system one of their guests has

00:08:26,720 --> 00:08:29,840
a gigabyte frame the host has two

00:08:28,319 --> 00:08:32,640
gigabytes free

00:08:29,840 --> 00:08:32,959
and uh there's a little you can do about

00:08:32,640 --> 00:08:35,599
that

00:08:32,959 --> 00:08:36,320
uh uh if you're if your vm's already

00:08:35,599 --> 00:08:39,919
running

00:08:36,320 --> 00:08:42,320
uh also for virtual machines we

00:08:39,919 --> 00:08:43,039
require require a special hardware

00:08:42,320 --> 00:08:46,560
feature

00:08:43,039 --> 00:08:49,120
this was implemented 15 years ago but uh

00:08:46,560 --> 00:08:49,920
rarely can you run vms on top of vms

00:08:49,120 --> 00:08:53,200
rarely is

00:08:49,920 --> 00:08:54,959
nesting as it's called uh compatible

00:08:53,200 --> 00:08:56,640
the that hardware feature is just not

00:08:54,959 --> 00:08:57,360
exposed to the guests where it's exposed

00:08:56,640 --> 00:09:00,480
to another guest

00:08:57,360 --> 00:09:02,320
usually um

00:09:00,480 --> 00:09:03,680
so it's important to note that both

00:09:02,320 --> 00:09:07,600
travis and get of actions

00:09:03,680 --> 00:09:09,600
you know they are they are running in

00:09:07,600 --> 00:09:11,600
they're cloud instances and they are

00:09:09,600 --> 00:09:13,839
like you know ephemeral and have

00:09:11,600 --> 00:09:15,519
temporary state but for

00:09:13,839 --> 00:09:17,120
for all for the appropriate wrestlers

00:09:15,519 --> 00:09:19,120
administration they're referred to them

00:09:17,120 --> 00:09:22,880
as vms

00:09:19,120 --> 00:09:25,519
uh next slide

00:09:22,880 --> 00:09:27,279
so as we mentioned we love running

00:09:25,519 --> 00:09:28,320
containers on these uh virtualized ci

00:09:27,279 --> 00:09:31,040
environments

00:09:28,320 --> 00:09:32,800
and that is our preferred approach uh

00:09:31,040 --> 00:09:34,800
and because containers on virtualization

00:09:32,800 --> 00:09:36,800
actually always work there's no reason

00:09:34,800 --> 00:09:38,480
why you can't run a container on top of

00:09:36,800 --> 00:09:41,680
a virtual machine

00:09:38,480 --> 00:09:44,080
uh we our preferred you know container

00:09:41,680 --> 00:09:46,640
runtime environment is podman

00:09:44,080 --> 00:09:48,240
but the environments do bundle docker

00:09:46,640 --> 00:09:49,839
you can use that too

00:09:48,240 --> 00:09:51,680
docker does have disadvantages like a

00:09:49,839 --> 00:09:52,720
demon that lunges root but this is a

00:09:51,680 --> 00:09:54,880
temporary scratch

00:09:52,720 --> 00:09:55,839
uh test environments that's not as much

00:09:54,880 --> 00:09:59,519
of an issue

00:09:55,839 --> 00:10:02,160
uh and but any other uh you know

00:09:59,519 --> 00:10:03,519
uh container solution nowadays will work

00:10:02,160 --> 00:10:05,680
because these containers just use

00:10:03,519 --> 00:10:08,959
standard features in the links kernel

00:10:05,680 --> 00:10:11,360
uh to to run now

00:10:08,959 --> 00:10:12,640
virtualization on containers can work as

00:10:11,360 --> 00:10:14,240
well it depends on whether

00:10:12,640 --> 00:10:16,480
the containers have privileges to run

00:10:14,240 --> 00:10:18,560
them but uh

00:10:16,480 --> 00:10:19,600
that's on that's not relevant for the

00:10:18,560 --> 00:10:20,079
rest of the presentation though because

00:10:19,600 --> 00:10:21,760
we're

00:10:20,079 --> 00:10:23,440
we've we've been tested these are

00:10:21,760 --> 00:10:25,200
environments used virtual machines

00:10:23,440 --> 00:10:27,519
uh at least once we've tested our our

00:10:25,200 --> 00:10:31,600
limited virtual machines

00:10:27,519 --> 00:10:35,279
uh next slide uh

00:10:31,600 --> 00:10:38,320
so ours are are

00:10:35,279 --> 00:10:41,760
we we have good news though uh

00:10:38,320 --> 00:10:43,519
we discovered that kvm actually works on

00:10:41,760 --> 00:10:47,120
top of travis

00:10:43,519 --> 00:10:49,920
the nested virtualization works there

00:10:47,120 --> 00:10:52,000
we tested on ubuntu 1804 and we tested

00:10:49,920 --> 00:10:55,279
on ubuntu 20.04

00:10:52,000 --> 00:10:57,519
uh now this was a surprise to us

00:10:55,279 --> 00:10:58,800
because travis doesn't advertise the

00:10:57,519 --> 00:11:00,800
fact that they support

00:10:58,800 --> 00:11:03,200
nested virtualization and all the recent

00:11:00,800 --> 00:11:06,160
q a said it's not possible

00:11:03,200 --> 00:11:07,120
uh but we ran all these commands we ran

00:11:06,160 --> 00:11:10,480
commands like

00:11:07,120 --> 00:11:11,160
kvm okay and uh more detailed commands

00:11:10,480 --> 00:11:13,760
to see the

00:11:11,160 --> 00:11:15,360
capabilities of the of the virtual cpu

00:11:13,760 --> 00:11:17,120
and there was there

00:11:15,360 --> 00:11:18,560
and we've we've been running it

00:11:17,120 --> 00:11:21,959
successfully

00:11:18,560 --> 00:11:24,399
in our in our ci now uh

00:11:21,959 --> 00:11:26,320
unfortunately it does not this does not

00:11:24,399 --> 00:11:28,560
work on top of github actions

00:11:26,320 --> 00:11:30,000
though github actions they may in the

00:11:28,560 --> 00:11:32,320
future use newer

00:11:30,000 --> 00:11:35,760
of azure instances that do support

00:11:32,320 --> 00:11:38,320
nested hardware rotation but not yet

00:11:35,760 --> 00:11:38,320
next slide

00:11:39,680 --> 00:11:43,839
so uh you may be wondering if you know

00:11:42,959 --> 00:11:46,240
if

00:11:43,839 --> 00:11:47,760
uh is there anything we can run besides

00:11:46,240 --> 00:11:49,680
virtual machines and containers

00:11:47,760 --> 00:11:51,040
especially if i want on something like a

00:11:49,680 --> 00:11:54,399
virtual machine

00:11:51,040 --> 00:11:55,920
on uh on github actions

00:11:54,399 --> 00:11:58,000
which we prefer anyway because it's

00:11:55,920 --> 00:11:59,760
faster so

00:11:58,000 --> 00:12:01,839
anyway we also been wondering what did

00:11:59,760 --> 00:12:05,519
people do before harder virtualization

00:12:01,839 --> 00:12:07,519
was introduced in 2006 or so

00:12:05,519 --> 00:12:09,440
are these old solutions actually a more

00:12:07,519 --> 00:12:10,240
elegant solution from a more civilized

00:12:09,440 --> 00:12:12,160
time

00:12:10,240 --> 00:12:14,160
are they like a lightsaber versus a

00:12:12,160 --> 00:12:17,519
clunky blaster

00:12:14,160 --> 00:12:17,519
uh next slide

00:12:18,959 --> 00:12:22,839
well the answer is unfortunately a

00:12:21,200 --> 00:12:26,240
resounding no

00:12:22,839 --> 00:12:28,720
uh so and the linux world

00:12:26,240 --> 00:12:30,240
uh the term plan nine is used because it

00:12:28,720 --> 00:12:34,399
was the name of another

00:12:30,240 --> 00:12:37,440
open source operating system uh and

00:12:34,399 --> 00:12:40,720
the movie plan nine for outer space

00:12:37,440 --> 00:12:42,800
that's the same name plan nine refers to

00:12:40,720 --> 00:12:46,000
one of the worst movies of all time

00:12:42,800 --> 00:12:47,920
possibly the worst and one of the

00:12:46,000 --> 00:12:48,480
reasons planned knife out of space is so

00:12:47,920 --> 00:12:51,360
bad

00:12:48,480 --> 00:12:52,240
is that it's convoluted in complex plots

00:12:51,360 --> 00:12:54,000
basically

00:12:52,240 --> 00:12:55,279
aliens wanted to invade the earth and

00:12:54,000 --> 00:12:56,959
rather than something simple and

00:12:55,279 --> 00:12:57,519
straightforward and efficient like you

00:12:56,959 --> 00:12:59,680
know

00:12:57,519 --> 00:13:01,440
shooting us with laser guns or

00:12:59,680 --> 00:13:02,800
propelling an asteroid at earth they

00:13:01,440 --> 00:13:04,639
just decided to

00:13:02,800 --> 00:13:06,320
raise an army of zombies and have them

00:13:04,639 --> 00:13:09,920
do the work for them

00:13:06,320 --> 00:13:13,040
it's convoluted and complex so

00:13:09,920 --> 00:13:15,680
if if our preferred plan plan a

00:13:13,040 --> 00:13:16,160
plan one is containers and our backup

00:13:15,680 --> 00:13:20,399
plan

00:13:16,160 --> 00:13:24,160
plan two is uh virtual machines

00:13:20,399 --> 00:13:26,320
uh we'll let's see what the how bad the

00:13:24,160 --> 00:13:27,680
plans three through nine are or how

00:13:26,320 --> 00:13:27,920
decent they are some of them actually

00:13:27,680 --> 00:13:30,240
are

00:13:27,920 --> 00:13:31,839
you know decent acceptables or explain

00:13:30,240 --> 00:13:32,880
um

00:13:31,839 --> 00:13:35,839
i don't want to grip on all these

00:13:32,880 --> 00:13:35,839
solutions but still

00:13:36,160 --> 00:13:38,720
next slide

00:13:39,519 --> 00:13:45,360
so uh virtualization has been around

00:13:43,199 --> 00:13:48,880
longer than 2006.

00:13:45,360 --> 00:13:51,920
uh vmware basically well

00:13:48,880 --> 00:13:52,720
ibm invented it in the 1960s and then it

00:13:51,920 --> 00:13:56,160
came to

00:13:52,720 --> 00:13:57,360
x86 computers and similar uh uh you know

00:13:56,160 --> 00:14:00,560
platforms

00:13:57,360 --> 00:14:03,680
in the early 2000s so

00:14:00,560 --> 00:14:05,360
the early and mid-2000s approach uh was

00:14:03,680 --> 00:14:08,480
software virtualization

00:14:05,360 --> 00:14:10,880
and there still is

00:14:08,480 --> 00:14:11,839
a open source implementation of this a

00:14:10,880 --> 00:14:13,279
virtual box

00:14:11,839 --> 00:14:16,000
which can run in a harder virtualization

00:14:13,279 --> 00:14:18,000
mode and by default does can still run

00:14:16,000 --> 00:14:21,440
in software regulation mode

00:14:18,000 --> 00:14:24,880
uh and basically

00:14:21,440 --> 00:14:28,079
uh uh the way this works is that

00:14:24,880 --> 00:14:28,480
uh most of the time when the this uh

00:14:28,079 --> 00:14:31,199
when

00:14:28,480 --> 00:14:32,160
the software relation runs the get the

00:14:31,199 --> 00:14:35,279
code inside

00:14:32,160 --> 00:14:35,760
inside the guest um it runs it as is it

00:14:35,279 --> 00:14:37,680
just

00:14:35,760 --> 00:14:40,399
right pass it directly to the cpu

00:14:37,680 --> 00:14:43,600
there's no uh translation to do

00:14:40,399 --> 00:14:45,199
uh but for some of the instructions such

00:14:43,600 --> 00:14:46,079
as instructions that run out of ring

00:14:45,199 --> 00:14:48,000
zero

00:14:46,079 --> 00:14:49,839
it has to translate those into

00:14:48,000 --> 00:14:51,360
instructions that the host can run

00:14:49,839 --> 00:14:53,839
or can run you know safely without

00:14:51,360 --> 00:14:57,360
clobbering itself its own os

00:14:53,839 --> 00:14:59,600
so uh

00:14:57,360 --> 00:15:00,800
uh because of this there is a

00:14:59,600 --> 00:15:03,360
performance hit

00:15:00,800 --> 00:15:04,800
and uh in order to overcome that

00:15:03,360 --> 00:15:07,279
performance hits

00:15:04,800 --> 00:15:08,399
these software hypervisors do a lot of

00:15:07,279 --> 00:15:10,000
tricks

00:15:08,399 --> 00:15:12,079
they do some of the tricks really

00:15:10,000 --> 00:15:12,880
include patching the binaries that it's

00:15:12,079 --> 00:15:15,120
running so that

00:15:12,880 --> 00:15:16,720
to replace in physical as more efficient

00:15:15,120 --> 00:15:19,199
code paths

00:15:16,720 --> 00:15:22,160
when all these tricks work well you have

00:15:19,199 --> 00:15:23,839
about two-thirds of the uh

00:15:22,160 --> 00:15:26,079
cpu performance of the uh that you

00:15:23,839 --> 00:15:29,519
originally had um

00:15:26,079 --> 00:15:33,040
so we tried this on on both ci's

00:15:29,519 --> 00:15:34,639
and it it does work on both ci's however

00:15:33,040 --> 00:15:36,480
we soon discovered that

00:15:34,639 --> 00:15:38,160
it it's even slower than original

00:15:36,480 --> 00:15:41,199
two-thirds performance

00:15:38,160 --> 00:15:43,279
we discovered that we assume that's

00:15:41,199 --> 00:15:44,880
because all those uh patching and other

00:15:43,279 --> 00:15:45,839
tricks are not not been maintained over

00:15:44,880 --> 00:15:48,480
time as everybody's just

00:15:45,839 --> 00:15:50,320
harder origin now there's all these

00:15:48,480 --> 00:15:52,240
other limitations they never bothered to

00:15:50,320 --> 00:15:55,519
implement in the software mode such as

00:15:52,240 --> 00:15:56,639
only one virtual cpu and 32-bit guest

00:15:55,519 --> 00:15:59,600
only

00:15:56,639 --> 00:16:00,720
now no hard anybody uses 32-bit since os

00:15:59,600 --> 00:16:03,360
7 and

00:16:00,720 --> 00:16:05,519
uh 64-bit sent to us i mean 32-bit

00:16:03,360 --> 00:16:08,480
number 8 doesn't exist so

00:16:05,519 --> 00:16:09,519
that's not that's not us osu real estate

00:16:08,480 --> 00:16:10,079
we want to test again you only want to

00:16:09,519 --> 00:16:13,519
test

00:16:10,079 --> 00:16:15,199
64 bits into our 7 and 8. um

00:16:13,519 --> 00:16:16,880
and then on top of this we discovered

00:16:15,199 --> 00:16:19,519
that it was we uh that this feature was

00:16:16,880 --> 00:16:21,519
actually removed in virtualbox 6.1

00:16:19,519 --> 00:16:23,440
like the command line argument is there

00:16:21,519 --> 00:16:24,880
but the gui grays it out and throws an

00:16:23,440 --> 00:16:26,240
error basically saying you know feats

00:16:24,880 --> 00:16:29,600
are not supported

00:16:26,240 --> 00:16:32,240
uh so the last version of virtualbox to

00:16:29,600 --> 00:16:35,199
support this was virtualbox 6.0

00:16:32,240 --> 00:16:36,880
however it is no longer supported when

00:16:35,199 --> 00:16:39,120
you combine the fact that uh this old

00:16:36,880 --> 00:16:41,360
version of virtualx is no longer

00:16:39,120 --> 00:16:43,519
getting support it's not getting any uh

00:16:41,360 --> 00:16:45,199
micro updates any patches

00:16:43,519 --> 00:16:47,199
the fact that it actually requires an

00:16:45,199 --> 00:16:49,759
out of tree kernel module

00:16:47,199 --> 00:16:51,120
that means that any day now ubuntu is

00:16:49,759 --> 00:16:52,480
going to issue their own kernel update

00:16:51,120 --> 00:16:54,000
and just you're not going to look to

00:16:52,480 --> 00:16:57,759
build it or compile it on a

00:16:54,000 --> 00:17:00,399
printer anymore so uh

00:16:57,759 --> 00:17:01,600
we do we do not recommend this approach

00:17:00,399 --> 00:17:05,199
uh

00:17:01,600 --> 00:17:08,319
next slide

00:17:05,199 --> 00:17:10,880
um so let's go a little bit further back

00:17:08,319 --> 00:17:14,720
in time in the early 2000s before

00:17:10,880 --> 00:17:18,240
any open source uh hypervisors existed

00:17:14,720 --> 00:17:22,079
there is emulation and the

00:17:18,240 --> 00:17:24,400
most most emulator by far is qmu

00:17:22,079 --> 00:17:25,199
now basically the way this works is that

00:17:24,400 --> 00:17:28,880
uh

00:17:25,199 --> 00:17:31,280
the all all all the code running

00:17:28,880 --> 00:17:33,679
against in the guest cpu has to be

00:17:31,280 --> 00:17:35,760
translated so it can run the host cpu

00:17:33,679 --> 00:17:37,840
in fact the host is cons is basically

00:17:35,760 --> 00:17:40,559
just breaking down every instruction and

00:17:37,840 --> 00:17:41,679
re-implementing every instruction so it

00:17:40,559 --> 00:17:44,240
uh

00:17:41,679 --> 00:17:46,160
at best it has a one-tenth of the cpu

00:17:44,240 --> 00:17:48,320
performance of the host and this all the

00:17:46,160 --> 00:17:50,559
supplies even if you're emulating xt6 on

00:17:48,320 --> 00:17:53,919
top of xt6

00:17:50,559 --> 00:17:55,120
so this is it's a lot of work to emulate

00:17:53,919 --> 00:17:55,840
it's a lot of performance penalty to

00:17:55,120 --> 00:17:57,760
emulate

00:17:55,840 --> 00:17:58,960
but it is actually very elegant and

00:17:57,760 --> 00:18:02,880
works uh

00:17:58,960 --> 00:18:04,799
really well actually and qmu on top of

00:18:02,880 --> 00:18:06,400
get it back and travis works exactly as

00:18:04,799 --> 00:18:07,919
intended which is one to the cpu

00:18:06,400 --> 00:18:09,360
performance but

00:18:07,919 --> 00:18:11,919
however traditionally you do get all the

00:18:09,360 --> 00:18:13,600
benefits of that like qmu shares code at

00:18:11,919 --> 00:18:15,440
the kbm basically so

00:18:13,600 --> 00:18:17,440
you have multiple virtual cpus you can

00:18:15,440 --> 00:18:19,840
add 64-bit gas

00:18:17,440 --> 00:18:20,559
uh you can use all the other features

00:18:19,840 --> 00:18:24,080
and like

00:18:20,559 --> 00:18:27,919
options to kvm that you normally pass um

00:18:24,080 --> 00:18:30,000
and it's also very simple for us to uh

00:18:27,919 --> 00:18:32,880
to configure vagrant to use uh

00:18:30,000 --> 00:18:34,000
qmu we'll cover this later but because

00:18:32,880 --> 00:18:36,080
it's so slow it's

00:18:34,000 --> 00:18:37,919
basically your last resorts if you're

00:18:36,080 --> 00:18:38,640
running a small utility like say a

00:18:37,919 --> 00:18:41,919
bootloader

00:18:38,640 --> 00:18:42,400
it's fast enough but if you're running a

00:18:41,919 --> 00:18:44,240
front or

00:18:42,400 --> 00:18:46,400
boot like a linux distro it'd be it's

00:18:44,240 --> 00:18:48,400
it'll be painfully slow you could

00:18:46,400 --> 00:18:50,480
you wouldn't want to you don't want to

00:18:48,400 --> 00:18:52,160
have like uh 10 minutes or so to boot

00:18:50,480 --> 00:18:57,840
just to boot into your os

00:18:52,160 --> 00:18:57,840
or more even more than that next slide

00:18:58,640 --> 00:19:02,400
um so it's worth noting that there have

00:19:00,960 --> 00:19:05,120
been other solutions

00:19:02,400 --> 00:19:07,039
uh uh over the years that are various

00:19:05,120 --> 00:19:11,120
types of software virtualization

00:19:07,039 --> 00:19:13,039
but these two mature open source ones

00:19:11,120 --> 00:19:14,320
both require the host to run a special

00:19:13,039 --> 00:19:15,919
kernel

00:19:14,320 --> 00:19:17,120
therefore we cannot run them either get

00:19:15,919 --> 00:19:17,840
it back into travis because we can't

00:19:17,120 --> 00:19:24,559
replace the

00:19:17,840 --> 00:19:27,200
crs kernel next slide

00:19:24,559 --> 00:19:27,919
okay so now that we have our preferred

00:19:27,200 --> 00:19:31,039
solutions

00:19:27,919 --> 00:19:35,520
any container runtime or uh kvm

00:19:31,039 --> 00:19:38,559
vms on top of uh uh travis specifically

00:19:35,520 --> 00:19:40,000
uh let's we now need to actually run our

00:19:38,559 --> 00:19:41,600
test code against them

00:19:40,000 --> 00:19:44,080
and like with most ci environments

00:19:41,600 --> 00:19:45,760
you're generally writing scripts so

00:19:44,080 --> 00:19:48,080
we need a way to programmatically access

00:19:45,760 --> 00:19:49,360
these vms to run containers to run our

00:19:48,080 --> 00:19:51,039
scripts against them or individual

00:19:49,360 --> 00:19:52,559
commands against them

00:19:51,039 --> 00:19:54,000
we'll cover how to do that and we'll

00:19:52,559 --> 00:19:55,520
also cover our tips for optimizing

00:19:54,000 --> 00:19:57,200
performance because

00:19:55,520 --> 00:19:59,120
as mentioned previously these

00:19:57,200 --> 00:20:00,240
environments have very limited resources

00:19:59,120 --> 00:20:04,840
especially

00:20:00,240 --> 00:20:06,960
ram only seven or eight gigabytes next

00:20:04,840 --> 00:20:10,559
slide

00:20:06,960 --> 00:20:12,080
um so to access containers this is

00:20:10,559 --> 00:20:13,760
the first bullet point is very well

00:20:12,080 --> 00:20:15,039
known there is the primary run and the

00:20:13,760 --> 00:20:17,039
docker run command

00:20:15,039 --> 00:20:19,200
that you can use to start your app the

00:20:17,039 --> 00:20:21,840
application you can also just run like

00:20:19,200 --> 00:20:23,840
commands individually this is designed

00:20:21,840 --> 00:20:26,400
around the premise that your container

00:20:23,840 --> 00:20:28,720
uh runs only one process at a time and

00:20:26,400 --> 00:20:30,720
if you need multiple processes you

00:20:28,720 --> 00:20:32,720
uh running you could share like file

00:20:30,720 --> 00:20:36,400
systems directly or you could uh

00:20:32,720 --> 00:20:37,760
also up between them or you just run

00:20:36,400 --> 00:20:38,080
them containers independently they don't

00:20:37,760 --> 00:20:40,720
share

00:20:38,080 --> 00:20:42,480
data on disk but say you do have a need

00:20:40,720 --> 00:20:43,600
to run a process inside a container it's

00:20:42,480 --> 00:20:46,320
already running

00:20:43,600 --> 00:20:47,600
so you you're uh you have the daemon

00:20:46,320 --> 00:20:49,280
already running you ran out with palm

00:20:47,600 --> 00:20:50,799
and run but now i need to launch a test

00:20:49,280 --> 00:20:52,640
suite against the

00:20:50,799 --> 00:20:55,520
system that say looks at the local disk

00:20:52,640 --> 00:20:58,159
to verify the data's

00:20:55,520 --> 00:20:59,200
there correctly or needs to use ipc for

00:20:58,159 --> 00:21:01,360
example

00:20:59,200 --> 00:21:02,640
or whatever it's maybe alternatives but

00:21:01,360 --> 00:21:04,000
it's the most efficient way to do it for

00:21:02,640 --> 00:21:05,360
your use case so

00:21:04,000 --> 00:21:07,039
there is another command that may not

00:21:05,360 --> 00:21:08,720
know about which is called podman exec

00:21:07,039 --> 00:21:11,200
and docker exec it just

00:21:08,720 --> 00:21:12,400
it launches an additional process or an

00:21:11,200 --> 00:21:14,880
interactive shell

00:21:12,400 --> 00:21:15,520
in the container that's already running

00:21:14,880 --> 00:21:18,080
uh

00:21:15,520 --> 00:21:18,080
next slide

00:21:18,559 --> 00:21:22,720
so how to access virtual machines now

00:21:21,360 --> 00:21:25,760
this is uh

00:21:22,720 --> 00:21:27,600
this is a little bit trickier so the

00:21:25,760 --> 00:21:30,000
default behavior of a virtual machine

00:21:27,600 --> 00:21:31,120
has used like vert manager or libvert

00:21:30,000 --> 00:21:34,320
with a

00:21:31,120 --> 00:21:36,400
with a vnc uh connection is virtual

00:21:34,320 --> 00:21:38,880
keyboard virtual monitor

00:21:36,400 --> 00:21:40,400
virtual mouse that's not something you

00:21:38,880 --> 00:21:43,679
want to script against

00:21:40,400 --> 00:21:46,480
uh and so the

00:21:43,679 --> 00:21:47,200
the the most elegant way to uh uh access

00:21:46,480 --> 00:21:49,919
it

00:21:47,200 --> 00:21:50,400
is to use uh a bunch of the uh utilities

00:21:49,919 --> 00:21:53,360
that are

00:21:50,400 --> 00:21:53,679
uh called cloud init now these are meant

00:21:53,360 --> 00:21:58,240
for

00:21:53,679 --> 00:21:59,919
uh you know cloud instances uh and uh

00:21:58,240 --> 00:22:01,280
you know the container the vms are

00:21:59,919 --> 00:22:02,000
created with the cloud native utilities

00:22:01,280 --> 00:22:03,840
on them

00:22:02,000 --> 00:22:06,080
and they expect some configuration so

00:22:03,840 --> 00:22:10,240
that the the ssh client

00:22:06,080 --> 00:22:12,240
uh can access it uh

00:22:10,240 --> 00:22:13,440
fortunately we can use these uh kvm

00:22:12,240 --> 00:22:17,200
style cloud images

00:22:13,440 --> 00:22:20,799
uh as libvert kvm vms

00:22:17,200 --> 00:22:23,360
um and i say fortunately because these

00:22:20,799 --> 00:22:25,360
kvm cloud images are very common

00:22:23,360 --> 00:22:26,480
basically every single distro creates

00:22:25,360 --> 00:22:28,400
them

00:22:26,480 --> 00:22:29,760
they may be listed as open stack format

00:22:28,400 --> 00:22:33,200
for example but they're

00:22:29,760 --> 00:22:35,600
perfectly usable in kvm um

00:22:33,200 --> 00:22:36,720
so the specif you would start out this

00:22:35,600 --> 00:22:39,120
out by running a

00:22:36,720 --> 00:22:40,480
cloud init command called cloud local ds

00:22:39,120 --> 00:22:43,360
this actually creates a

00:22:40,480 --> 00:22:44,159
a virtual floppy disk with a config file

00:22:43,360 --> 00:22:46,080
on it

00:22:44,159 --> 00:22:47,919
uh config file with settings like you

00:22:46,080 --> 00:22:49,360
know here's the ip address of the vm and

00:22:47,919 --> 00:22:52,080
here's the ssh key

00:22:49,360 --> 00:22:53,600
i want to use to access it and then you

00:22:52,080 --> 00:22:55,440
call the vert install command from

00:22:53,600 --> 00:22:58,159
livevert to install the container

00:22:55,440 --> 00:22:59,520
i mean to install the vm with those

00:22:58,159 --> 00:23:01,679
booted with the floppy

00:22:59,520 --> 00:23:03,600
and it boots up uses ip address and

00:23:01,679 --> 00:23:04,880
installs this hkey and then you can ssh

00:23:03,600 --> 00:23:06,559
into it you

00:23:04,880 --> 00:23:07,760
you have a fixed ip address you can

00:23:06,559 --> 00:23:08,000
access it that way that's the simplest

00:23:07,760 --> 00:23:10,400
way

00:23:08,000 --> 00:23:12,640
to do it there are guides online for

00:23:10,400 --> 00:23:15,280
using cloud init with cloud local ds

00:23:12,640 --> 00:23:16,799
with all the commands spelled out but

00:23:15,280 --> 00:23:18,480
it's not too bad it's only like four or

00:23:16,799 --> 00:23:22,000
five commands total

00:23:18,480 --> 00:23:22,880
um and once you have that stage

00:23:22,000 --> 00:23:24,640
connector of course you can run

00:23:22,880 --> 00:23:25,520
individual commands against the vm or

00:23:24,640 --> 00:23:28,960
you could

00:23:25,520 --> 00:23:31,039
uh you know uh pat pass over a script

00:23:28,960 --> 00:23:33,520
and run that script

00:23:31,039 --> 00:23:33,520
next slide

00:23:34,159 --> 00:23:37,919
um so there is a more convenient way to

00:23:37,600 --> 00:23:41,360
do

00:23:37,919 --> 00:23:43,039
all to to create these vms and

00:23:41,360 --> 00:23:45,200
it involves less scripting on your parts

00:23:43,039 --> 00:23:46,559
and it also has lots of cool features to

00:23:45,200 --> 00:23:48,080
make things more convenient for doing

00:23:46,559 --> 00:23:50,799
other stuff against it

00:23:48,080 --> 00:23:52,080
it is called vagrant vagrant the

00:23:50,799 --> 00:23:52,720
firmness of agreement is that it helps

00:23:52,080 --> 00:23:54,000
you create a

00:23:52,720 --> 00:23:55,600
development environment for your

00:23:54,000 --> 00:23:56,960
application which could also be test

00:23:55,600 --> 00:24:00,320
environment of course

00:23:56,960 --> 00:24:02,880
it has a libert plug-in it

00:24:00,320 --> 00:24:04,080
it creates the virtual machine it does

00:24:02,880 --> 00:24:06,640
uh provisions it's

00:24:04,080 --> 00:24:08,960
with uh with a prisoner code such as

00:24:06,640 --> 00:24:12,080
ansible code or chefco to pop it

00:24:08,960 --> 00:24:15,919
and also facilitate all the ssh access

00:24:12,080 --> 00:24:17,360
um so it the advantage to is that it's

00:24:15,919 --> 00:24:18,240
very convenient to use and has some

00:24:17,360 --> 00:24:21,520
features you might like

00:24:18,240 --> 00:24:23,760
however i always hesitate to add another

00:24:21,520 --> 00:24:26,640
to increase the ram usage on these uh

00:24:23,760 --> 00:24:28,320
on these cloud instances it uses a

00:24:26,640 --> 00:24:29,360
different set of images called vaping

00:24:28,320 --> 00:24:31,120
cloud boxes

00:24:29,360 --> 00:24:32,240
uh this may be a disadvantage or an

00:24:31,120 --> 00:24:33,360
advantage for you it depends on what

00:24:32,240 --> 00:24:36,720
that doesn't

00:24:33,360 --> 00:24:38,640
images or to your liking though uh

00:24:36,720 --> 00:24:40,240
that's where doing that pulps uh see the

00:24:38,640 --> 00:24:42,000
policy that paul is developing actually

00:24:40,240 --> 00:24:44,640
does use this

00:24:42,000 --> 00:24:44,640
next slide

00:24:45,360 --> 00:24:51,200
so uh previously i mentioned that uh

00:24:48,720 --> 00:24:53,520
uh that the the virtual memory on these

00:24:51,200 --> 00:24:56,720
nci instances are very limited

00:24:53,520 --> 00:24:59,840
it's uh about seven gigs on each

00:24:56,720 --> 00:25:02,799
um and uh

00:24:59,840 --> 00:25:03,279
this having little virtual ramp is a

00:25:02,799 --> 00:25:04,880
very

00:25:03,279 --> 00:25:06,080
having a little ram is a very big deal

00:25:04,880 --> 00:25:07,279
when you're running virtual machines in

00:25:06,080 --> 00:25:09,840
particular

00:25:07,279 --> 00:25:12,840
uh because if uh if out of memory needs

00:25:09,840 --> 00:25:14,559
to kill a process it can kill the entire

00:25:12,840 --> 00:25:16,159
vm

00:25:14,559 --> 00:25:17,919
even if containers could still just kill

00:25:16,159 --> 00:25:21,440
the process running a container

00:25:17,919 --> 00:25:23,279
that you may rely on so uh

00:25:21,440 --> 00:25:24,880
github actions actually gives you a four

00:25:23,279 --> 00:25:26,400
gigabyte swap file to overcome their

00:25:24,880 --> 00:25:29,760
small

00:25:26,400 --> 00:25:30,880
virtual memory but we uh we recommend

00:25:29,760 --> 00:25:33,200
creating this swap file

00:25:30,880 --> 00:25:35,600
on the as well just as we recommend

00:25:33,200 --> 00:25:37,919
training a swap file on travis

00:25:35,600 --> 00:25:39,600
extrapolate the first place on travis

00:25:37,919 --> 00:25:40,240
it's worth you may be wondering why swap

00:25:39,600 --> 00:25:43,039
files

00:25:40,240 --> 00:25:43,360
like isn't that is that that's why is

00:25:43,039 --> 00:25:45,279
that

00:25:43,360 --> 00:25:46,720
don't you have a swap partition on your

00:25:45,279 --> 00:25:48,080
on your hard disk on your developer

00:25:46,720 --> 00:25:50,960
system or a server

00:25:48,080 --> 00:25:52,240
well uh swap partitions are preferred

00:25:50,960 --> 00:25:54,559
but swap files

00:25:52,240 --> 00:25:57,039
with a performance penalty do work well

00:25:54,559 --> 00:25:58,240
as or the only way we can create swap

00:25:57,039 --> 00:26:00,240
space on these uh

00:25:58,240 --> 00:26:02,720
cloud instances because there's no blank

00:26:00,240 --> 00:26:04,400
virtual hard disk for us to access

00:26:02,720 --> 00:26:06,080
creative action actually already uses

00:26:04,400 --> 00:26:07,679
slots mount for their four gigabyte swap

00:26:06,080 --> 00:26:08,559
files we just create another one that's

00:26:07,679 --> 00:26:10,159
you know

00:26:08,559 --> 00:26:11,840
they take up the remainder of plus mount

00:26:10,159 --> 00:26:13,520
that's our recommendation

00:26:11,840 --> 00:26:15,279
and once again give actions will have

00:26:13,520 --> 00:26:17,440
much faster swap space if you do end up

00:26:15,279 --> 00:26:20,000
accessing it

00:26:17,440 --> 00:26:20,000
next slide

00:26:21,200 --> 00:26:26,720
um another performance tip we have

00:26:24,559 --> 00:26:28,159
uh which applies equally well to

00:26:26,720 --> 00:26:31,200
containers and vm images

00:26:28,159 --> 00:26:34,000
is to pre-build images with your

00:26:31,200 --> 00:26:38,080
applications dependencies

00:26:34,000 --> 00:26:40,880
so why pre-build with dependencies well

00:26:38,080 --> 00:26:42,559
uh with most software projects like pulp

00:26:40,880 --> 00:26:44,720
our dependencies which are

00:26:42,559 --> 00:26:47,120
in our case a mixture of c libraries

00:26:44,720 --> 00:26:50,400
usually from rpms or devs of the os

00:26:47,120 --> 00:26:52,720
and uh and python dependencies

00:26:50,400 --> 00:26:55,200
change rarely they'll change like every

00:26:52,720 --> 00:26:58,320
few weeks or once a month or so

00:26:55,200 --> 00:26:59,840
in contrast the uh uh our code changes

00:26:58,320 --> 00:27:03,120
constantly

00:26:59,840 --> 00:27:04,960
so we want whenever whenever we do a

00:27:03,120 --> 00:27:06,000
pull request we don't want to spend time

00:27:04,960 --> 00:27:08,000
making to always wait

00:27:06,000 --> 00:27:09,039
for it to install all the dependencies

00:27:08,000 --> 00:27:10,559
we just want to install

00:27:09,039 --> 00:27:12,400
the current version of pulp itself and

00:27:10,559 --> 00:27:14,720
test it so

00:27:12,400 --> 00:27:16,720
therefore we recommend using a type of a

00:27:14,720 --> 00:27:18,559
ci job called a cron job

00:27:16,720 --> 00:27:20,080
technically it's not the cron like you

00:27:18,559 --> 00:27:22,000
used to but it's

00:27:20,080 --> 00:27:23,200
it's it's a ci job that's scheduled some

00:27:22,000 --> 00:27:26,240
of the fun

00:27:23,200 --> 00:27:28,159
and with those uh so

00:27:26,240 --> 00:27:29,679
and those in those crown jobs you'll

00:27:28,159 --> 00:27:31,760
build a container image

00:27:29,679 --> 00:27:33,440
or vm image and you'll push to the

00:27:31,760 --> 00:27:34,640
registry at the end so the registry

00:27:33,440 --> 00:27:38,960
would be you know

00:27:34,640 --> 00:27:41,440
quay.io a docker hub vagrant cloud

00:27:38,960 --> 00:27:43,679
or directly your own place for storing

00:27:41,440 --> 00:27:47,360
vm images on

00:27:43,679 --> 00:27:50,159
it here's the url um and then

00:27:47,360 --> 00:27:51,919
for containers uh of course pulp can

00:27:50,159 --> 00:27:52,960
also serve as a container image registry

00:27:51,919 --> 00:27:56,640
we highly recommend

00:27:52,960 --> 00:27:58,720
using pulp as well uh so

00:27:56,640 --> 00:28:00,559
this if i throw that out there a little

00:27:58,720 --> 00:28:02,559
bit of self-motion but

00:28:00,559 --> 00:28:04,000
so with containers uh this is a very

00:28:02,559 --> 00:28:06,320
well known process you know

00:28:04,000 --> 00:28:07,120
you you can typically the advice is to

00:28:06,320 --> 00:28:10,399
create a

00:28:07,120 --> 00:28:12,559
container file ak docker file or use

00:28:10,399 --> 00:28:14,080
any other solution you want with a very

00:28:12,559 --> 00:28:15,520
flexible pie man with the pot and build

00:28:14,080 --> 00:28:17,279
command

00:28:15,520 --> 00:28:18,880
but say you're just trying to do

00:28:17,279 --> 00:28:20,559
something quick and you have some other

00:28:18,880 --> 00:28:22,080
reason why you need a running container

00:28:20,559 --> 00:28:23,679
with a bunch of running processes and

00:28:22,080 --> 00:28:24,880
then you save the current state of the

00:28:23,679 --> 00:28:26,240
container at the end

00:28:24,880 --> 00:28:27,840
well you can also use the parmen commit

00:28:26,240 --> 00:28:29,679
command it basically takes the

00:28:27,840 --> 00:28:31,360
containers temporary storage

00:28:29,679 --> 00:28:33,520
whatever changes make the slash file

00:28:31,360 --> 00:28:35,840
system and it

00:28:33,520 --> 00:28:38,480
creates a new container image based on

00:28:35,840 --> 00:28:41,120
that currency of the container

00:28:38,480 --> 00:28:41,919
similarly uh with vms or vagrant box

00:28:41,120 --> 00:28:45,039
repackage

00:28:41,919 --> 00:28:48,640
is a great is a great way to uh

00:28:45,039 --> 00:28:50,960
as a well with vagrants you know

00:28:48,640 --> 00:28:51,760
the images you use are called boxes and

00:28:50,960 --> 00:28:53,200
whenever when

00:28:51,760 --> 00:28:55,120
if you're done making changes to your

00:28:53,200 --> 00:28:56,880
vagrant uh you know

00:28:55,120 --> 00:28:58,559
uh dev environment you can just run the

00:28:56,880 --> 00:29:00,080
repackage command that creates a box

00:28:58,559 --> 00:29:02,559
based on the changes you made

00:29:00,080 --> 00:29:03,600
at runtime very similar to podman

00:29:02,559 --> 00:29:05,520
commits so

00:29:03,600 --> 00:29:07,200
another option with missing as well is

00:29:05,520 --> 00:29:10,320
if you want a robust way to create

00:29:07,200 --> 00:29:12,080
uh virtual machines according to

00:29:10,320 --> 00:29:14,240
reproducible you know

00:29:12,080 --> 00:29:17,520
logic uh packer is an open source

00:29:14,240 --> 00:29:22,240
utility that can do this for kvm

00:29:17,520 --> 00:29:25,440
next slide uh

00:29:22,240 --> 00:29:28,559
so our final performance tip is

00:29:25,440 --> 00:29:30,080
uh if you need to run kubernetes so

00:29:28,559 --> 00:29:31,679
remember kubernetes is a container

00:29:30,080 --> 00:29:34,399
infrastructure and it has a

00:29:31,679 --> 00:29:36,000
running daemon on a on a on a particular

00:29:34,399 --> 00:29:37,760
node that controls the rest of the nodes

00:29:36,000 --> 00:29:42,799
even if it's only one node

00:29:37,760 --> 00:29:44,880
this daemon uh is cpu and memory heavy

00:29:42,799 --> 00:29:46,640
so we tried out multiple lightweight

00:29:44,880 --> 00:29:50,240
versions of kubernetes

00:29:46,640 --> 00:29:52,399
and uh either they wouldn't work on

00:29:50,240 --> 00:29:53,360
because they were on github actions

00:29:52,399 --> 00:29:54,799
because they were

00:29:53,360 --> 00:29:57,919
actually using virtualization that's how

00:29:54,799 --> 00:29:59,919
mini cube works for example

00:29:57,919 --> 00:30:01,120
or they were not as lightweight as k3s

00:29:59,919 --> 00:30:02,399
k3s turned out to be the most

00:30:01,120 --> 00:30:04,480
lightweight so

00:30:02,399 --> 00:30:05,919
our recommendation is if you are testing

00:30:04,480 --> 00:30:07,600
against kubernetes like you are

00:30:05,919 --> 00:30:10,080
developing a

00:30:07,600 --> 00:30:11,440
you know manifest or an operator for

00:30:10,080 --> 00:30:15,039
your application

00:30:11,440 --> 00:30:16,559
that use k3s for this at install time

00:30:15,039 --> 00:30:17,679
it'll default to using its bundled

00:30:16,559 --> 00:30:20,000
container d

00:30:17,679 --> 00:30:21,440
but it also offers lets you specify i

00:30:20,000 --> 00:30:23,600
want to use docker and

00:30:21,440 --> 00:30:24,799
the ci environment actually pre-install

00:30:23,600 --> 00:30:26,559
docker

00:30:24,799 --> 00:30:28,159
you just enable that as a service in

00:30:26,559 --> 00:30:32,159
your ci config

00:30:28,159 --> 00:30:32,159
and so you can do that as well

00:30:32,480 --> 00:30:39,679
next slide so

00:30:36,480 --> 00:30:44,320
that's the end of our presentation uh

00:30:39,679 --> 00:30:51,840
any questions for for the orange

00:30:44,320 --> 00:30:51,840
and for world conquest

00:30:56,000 --> 00:30:59,440
thank you for an excellent presentation

00:30:57,919 --> 00:31:04,000
uh welcome back mike

00:30:59,440 --> 00:31:05,760
and i'm adding david as well

00:31:04,000 --> 00:31:09,600
so if anyone in the audience would like

00:31:05,760 --> 00:31:09,600
to ask questions please do so

00:31:10,880 --> 00:31:14,080
uh mike and david do you want to add any

00:31:12,720 --> 00:31:18,000
comments

00:31:14,080 --> 00:31:19,760
or thoughts

00:31:18,000 --> 00:31:20,880
i would just i would like to point out

00:31:19,760 --> 00:31:22,240
like you know we uh we've been

00:31:20,880 --> 00:31:24,000
developing our cia a little bit more

00:31:22,240 --> 00:31:26,640
since the presentation

00:31:24,000 --> 00:31:27,919
and we've uh it's it's been a lifesaver

00:31:26,640 --> 00:31:30,320
being able to like

00:31:27,919 --> 00:31:33,120
run ci tests for sc linux and fips mode

00:31:30,320 --> 00:31:33,120
which we had a requirement

00:31:34,640 --> 00:31:38,399
yeah very much very much so

00:31:42,640 --> 00:31:47,760
okay if you have any links you want to

00:31:44,559 --> 00:31:49,840
share feel free to do that or

00:31:47,760 --> 00:31:50,880
anyone uh if you want to share contact

00:31:49,840 --> 00:31:52,960
information or how

00:31:50,880 --> 00:31:55,279
anyone wants to get started or anything

00:31:52,960 --> 00:31:59,679
like that

00:31:55,279 --> 00:32:00,880
um let me think for a second

00:31:59,679 --> 00:32:03,200
i could definitely share the

00:32:00,880 --> 00:32:03,760
instructions on like using like uh cloud

00:32:03,200 --> 00:32:05,440
init

00:32:03,760 --> 00:32:06,880
uh that's you know something to be

00:32:05,440 --> 00:32:10,399
referenced there

00:32:06,880 --> 00:32:13,519
um there's als i'll i'll

00:32:10,399 --> 00:32:16,399
get that link right now uh

00:32:13,519 --> 00:32:18,080
but you know there are there there are

00:32:16,399 --> 00:32:20,480
multiple insider environments out there

00:32:18,080 --> 00:32:22,080
you know the github accents and travis

00:32:20,480 --> 00:32:23,679
still have uh you know these getting

00:32:22,080 --> 00:32:25,840
started guides

00:32:23,679 --> 00:32:27,360
and they'll but it's you have to add you

00:32:25,840 --> 00:32:29,200
just you you'll be adding the

00:32:27,360 --> 00:32:31,279
virtualization container layer on top of

00:32:29,200 --> 00:32:31,279
it

00:32:35,519 --> 00:32:39,039
okay well thank you very much i

00:32:37,519 --> 00:32:40,559
certainly appreciate the presentation

00:32:39,039 --> 00:32:43,760
and it's very well done

00:32:40,559 --> 00:32:45,760
yeah i'm sharing the link right now uh

00:32:43,760 --> 00:32:47,279
yep and thanks david for pasting the

00:32:45,760 --> 00:32:57,840
link to pulp

00:32:47,279 --> 00:32:57,840
no problem

00:33:08,840 --> 00:33:14,240
yep

00:33:10,960 --> 00:33:14,240
thanks very much that's great

00:33:14,720 --> 00:33:18,480
okay well well thanks guys i certainly

00:33:16,799 --> 00:33:20,640
appreciate it

00:33:18,480 --> 00:33:21,679
yeah thank you you're welcome thank you

00:33:20,640 --> 00:33:25,840
for having us

00:33:21,679 --> 00:33:25,840

YouTube URL: https://www.youtube.com/watch?v=7PMZP8RTYJ8


