Title: Usable Cryptography with José
Publication date: 2019-02-22
Playlist: DevConfUS 2018
Description: 
	Increased uses of cryptography in web environments, particularly authentication, have driven a set of new RFCs: JSON Object Signing and Encryption. While these standard data formats have dominated web-based applications, they also have further applicability in a wide variety of non-web contexts. This talk will introduce you to José, a plug-able, open source C implementation of these RFCs which provides both an API for direct integration and a usable command-line interface. We will discuss the techniques that we used to keep our API usable across all the possible input parameters and show example of how you can implement José in your own infrastructure. We will also discuss some of our plans for the future, including how you can help contribute.
Captions: 
	00:00:03,270 --> 00:00:09,330
yes so Jose on the left or Josie on the

00:00:06,390 --> 00:00:12,150
left is actually a set of standards rfcs

00:00:09,330 --> 00:00:14,400
and Jose is my particular implementation

00:00:12,150 --> 00:00:17,189
of them we'll be using this terminology

00:00:14,400 --> 00:00:19,619
to disambiguate throughout the talk so

00:00:17,189 --> 00:00:21,239
whenever I say Josie I'm referring to

00:00:19,619 --> 00:00:23,430
these standards and whenever I say Jose

00:00:21,239 --> 00:00:26,730
I'm referring to my implementation of

00:00:23,430 --> 00:00:30,020
those standards so Josie stands for

00:00:26,730 --> 00:00:34,200
Jason objects signing an encryption and

00:00:30,020 --> 00:00:36,210
it is a set of standards for formatting

00:00:34,200 --> 00:00:39,629
all sorts of cryptographic related stuff

00:00:36,210 --> 00:00:41,850
in JSON format now some of you are

00:00:39,629 --> 00:00:44,789
probably wondering why we need some new

00:00:41,850 --> 00:00:46,949
standards and there's actually quite a

00:00:44,789 --> 00:00:48,480
few reasons for this for those of you

00:00:46,949 --> 00:00:50,579
who've been doing cryptography at all

00:00:48,480 --> 00:00:53,249
you know that our standards have grown

00:00:50,579 --> 00:00:55,440
up organically over time so we started

00:00:53,249 --> 00:00:57,359
off you know with with various different

00:00:55,440 --> 00:00:58,769
here's how walkie works and then we

00:00:57,359 --> 00:01:01,050
started doing encryption and various

00:00:58,769 --> 00:01:03,569
other things but it got really really

00:01:01,050 --> 00:01:04,800
hairy quickly because for example what

00:01:03,569 --> 00:01:06,510
sort of format to store your

00:01:04,800 --> 00:01:08,250
certificates in what sort of formats do

00:01:06,510 --> 00:01:11,280
you store your keys in all of this stuff

00:01:08,250 --> 00:01:15,630
is everyone did sort of their own thing

00:01:11,280 --> 00:01:18,860
and so as an example GPG you know is not

00:01:15,630 --> 00:01:23,729
the same as a Vanessa cell for example

00:01:18,860 --> 00:01:25,950
so we also had need for some for doing

00:01:23,729 --> 00:01:29,130
cryptography in the web space and in

00:01:25,950 --> 00:01:32,100
particular for bundling cryptographic

00:01:29,130 --> 00:01:35,100
data inside URLs which is the one of the

00:01:32,100 --> 00:01:37,500
driving forces of this standards and so

00:01:35,100 --> 00:01:40,350
what we actually have here is the first

00:01:37,500 --> 00:01:42,630
cryptographic system that integrates all

00:01:40,350 --> 00:01:44,670
of the different parts of what we would

00:01:42,630 --> 00:01:47,490
today call a crypto system into one

00:01:44,670 --> 00:01:50,460
usable system where everything sort of

00:01:47,490 --> 00:01:52,109
works with everything else and and we're

00:01:50,460 --> 00:01:53,729
gonna walk through how to how exactly

00:01:52,109 --> 00:01:56,880
this looks we're going to start off with

00:01:53,729 --> 00:01:59,579
a really really simple example this

00:01:56,880 --> 00:02:02,840
example is just a symmetric key we call

00:01:59,579 --> 00:02:06,179
these jason web keys or jwk for short a

00:02:02,840 --> 00:02:09,270
jason web key when it's a symmetric key

00:02:06,179 --> 00:02:11,910
looks just like this we have at the top

00:02:09,270 --> 00:02:14,650
the kty parameter which just simply

00:02:11,910 --> 00:02:17,920
specifies what type of key this is in

00:02:14,650 --> 00:02:19,599
case it's octet so we should expect that

00:02:17,920 --> 00:02:22,000
it's going to have a K parameter and

00:02:19,599 --> 00:02:23,650
they and the K parameter is going to

00:02:22,000 --> 00:02:27,400
contain the actual octet of the key

00:02:23,650 --> 00:02:30,340
these are base64 URL encoded and then we

00:02:27,400 --> 00:02:32,019
also in this example have an optional

00:02:30,340 --> 00:02:34,060
value that does not that is not actually

00:02:32,019 --> 00:02:36,129
required but can be present for a

00:02:34,060 --> 00:02:37,560
variety of different keys and in this

00:02:36,129 --> 00:02:40,060
case this value is the algorithm

00:02:37,560 --> 00:02:42,450
parameter and this indicates what

00:02:40,060 --> 00:02:46,659
algorithm that this key can be used in

00:02:42,450 --> 00:02:48,430
are used with and so this is pretty much

00:02:46,659 --> 00:02:50,230
the simplest example we're going to see

00:02:48,430 --> 00:02:53,409
on the set of slides

00:02:50,230 --> 00:02:56,079
notice that this same pattern of

00:02:53,409 --> 00:02:59,139
representing binary as base64 data is

00:02:56,079 --> 00:03:02,079
going to be universal throughout the the

00:02:59,139 --> 00:03:03,849
all of the Jozy specifications any

00:03:02,079 --> 00:03:05,579
questions about this I hoping this one

00:03:03,849 --> 00:03:08,560
is pretty straightforward

00:03:05,579 --> 00:03:11,560
okay let's let's move on to a little

00:03:08,560 --> 00:03:14,769
more complex example so this is also a

00:03:11,560 --> 00:03:16,750
jwk same data format but this time we're

00:03:14,769 --> 00:03:18,519
representing not the symmetric key but

00:03:16,750 --> 00:03:21,730
we're representing an elliptic curve key

00:03:18,519 --> 00:03:23,980
in this case we also have the key type

00:03:21,730 --> 00:03:26,410
KT Y at the top exactly like the last

00:03:23,980 --> 00:03:29,769
one this specifies EC this is an

00:03:26,410 --> 00:03:32,470
elliptic curve key what we next then

00:03:29,769 --> 00:03:34,959
have the four required parameters for an

00:03:32,470 --> 00:03:36,159
elliptic curve key the first is the name

00:03:34,959 --> 00:03:38,709
of the curve that we're actually

00:03:36,159 --> 00:03:41,620
representing in this case this is a P

00:03:38,709 --> 00:03:44,650
256 key for those of you who are not

00:03:41,620 --> 00:03:46,359
familiar with elliptic curves P 256 is

00:03:44,650 --> 00:03:48,909
one of these standardized curves that's

00:03:46,359 --> 00:03:51,280
used by NIST it's one of the most widely

00:03:48,909 --> 00:03:55,540
available and it's one of the ones

00:03:51,280 --> 00:04:00,269
that's standardized in in Jezzie next we

00:03:55,540 --> 00:04:03,549
have three parameters X Y and D because

00:04:00,269 --> 00:04:05,349
keys are points public keys and elliptic

00:04:03,549 --> 00:04:07,030
curve cryptography are points on an

00:04:05,349 --> 00:04:08,949
elliptic curve we have an X and a Y

00:04:07,030 --> 00:04:11,680
value which indicates where it is on the

00:04:08,949 --> 00:04:16,510
curve and the D value is the private

00:04:11,680 --> 00:04:18,459
value or the secret value so so these

00:04:16,510 --> 00:04:20,650
these are this is a full public and

00:04:18,459 --> 00:04:23,200
private key all in all in one JSON

00:04:20,650 --> 00:04:25,360
object finally we have two more optional

00:04:23,200 --> 00:04:26,170
parameters and notice that these are

00:04:25,360 --> 00:04:27,280
different optional

00:04:26,170 --> 00:04:29,350
parameters the ones we saw in the

00:04:27,280 --> 00:04:31,450
previous slide in this case we have a

00:04:29,350 --> 00:04:35,860
key use and this is allowed to be used

00:04:31,450 --> 00:04:38,020
for encryption and finally we have a ki

00:04:35,860 --> 00:04:39,970
d parameter and this is just a unique

00:04:38,020 --> 00:04:42,700
identifier for ki it can actually be

00:04:39,970 --> 00:04:46,150
anything you want but it's pretty common

00:04:42,700 --> 00:04:48,790
to see the k ID actually be a thumbprint

00:04:46,150 --> 00:04:50,560
of the key but it can actually be any

00:04:48,790 --> 00:04:52,300
any string that you want and I'll

00:04:50,560 --> 00:04:56,970
explain more about what thumb prints are

00:04:52,300 --> 00:04:59,200
shortly any questions before we move on

00:04:56,970 --> 00:05:01,210
so from here it gets much more

00:04:59,200 --> 00:05:04,270
complicated because we are now moving

00:05:01,210 --> 00:05:07,030
into RSA keys RSA keys you notice they

00:05:04,270 --> 00:05:08,680
still have the same kkty parameter at

00:05:07,030 --> 00:05:12,070
the top this indicates what type of a

00:05:08,680 --> 00:05:14,980
key this is and we have the next what is

00:05:12,070 --> 00:05:17,290
it seven parameters or the RSA

00:05:14,980 --> 00:05:20,320
parameters actually eight are the RSA

00:05:17,290 --> 00:05:25,120
parameters so from here all the way down

00:05:20,320 --> 00:05:27,160
to here and the specific details of

00:05:25,120 --> 00:05:28,960
those I won't go into so if you want to

00:05:27,160 --> 00:05:31,330
know more about RSA keys there's lots of

00:05:28,960 --> 00:05:34,030
information on the on the interwebs and

00:05:31,330 --> 00:05:35,800
you can find it there lastly we do have

00:05:34,030 --> 00:05:38,680
two more optional parameters here in

00:05:35,800 --> 00:05:40,030
this case we have the algorithm which is

00:05:38,680 --> 00:05:42,730
like what we saw with the symmetric key

00:05:40,030 --> 00:05:46,360
this is allowed to be used with the RS

00:05:42,730 --> 00:05:48,640
256 algorithm which is a force

00:05:46,360 --> 00:05:50,860
signatures and it indicates that the

00:05:48,640 --> 00:05:53,020
data should be hashed with sha-256 and

00:05:50,860 --> 00:05:57,070
then the hash of the data should be

00:05:53,020 --> 00:05:59,140
signed with with the RSA key and then

00:05:57,070 --> 00:06:00,550
finally we have another key ID parameter

00:05:59,140 --> 00:06:02,020
you notice this time it's a date when

00:06:00,550 --> 00:06:04,360
the previous example we just had the

00:06:02,020 --> 00:06:06,340
number 1 which you in this place's case

00:06:04,360 --> 00:06:08,260
is like a serial number for keys that

00:06:06,340 --> 00:06:09,820
have been generated over time in this

00:06:08,260 --> 00:06:12,190
case if the dates in which the key was

00:06:09,820 --> 00:06:13,990
generated again this can be anything

00:06:12,190 --> 00:06:16,780
that you want it's as long as it

00:06:13,990 --> 00:06:20,260
uniquely identifies the key according to

00:06:16,780 --> 00:06:22,390
whatever system you're using so those

00:06:20,260 --> 00:06:25,600
are the three main key types that are

00:06:22,390 --> 00:06:27,190
used in the jersey crypto system there's

00:06:25,600 --> 00:06:29,260
actually another one that has just

00:06:27,190 --> 00:06:31,090
recently been standardized which for

00:06:29,260 --> 00:06:33,280
those of you who are

00:06:31,090 --> 00:06:36,040
doing cryptography on a day-to-day basis

00:06:33,280 --> 00:06:40,030
this is the CFCF RG curves so things

00:06:36,040 --> 00:06:41,920
like evey 255 1/9 and edy 4 4 8 have

00:06:40,030 --> 00:06:47,530
both recently been standardized as key

00:06:41,920 --> 00:06:50,860
types as well one last thing that we

00:06:47,530 --> 00:06:53,200
should note is that Josie actually

00:06:50,860 --> 00:06:55,210
standardizes a way to represent sets of

00:06:53,200 --> 00:06:57,130
keys as well which is something we don't

00:06:55,210 --> 00:06:59,350
see in pretty much any other crypto

00:06:57,130 --> 00:07:01,690
system so you can actually define a

00:06:59,350 --> 00:07:03,490
bundle where you have this object and

00:07:01,690 --> 00:07:06,400
you have a parameter called keys and

00:07:03,490 --> 00:07:07,930
it's just simply an array of keys but

00:07:06,400 --> 00:07:10,530
there's also extra parameters that you

00:07:07,930 --> 00:07:10,530
can put in here

00:07:12,419 --> 00:07:18,160
moving on to performing a signature this

00:07:15,910 --> 00:07:21,970
is actually the most complex example of

00:07:18,160 --> 00:07:23,830
a signature that we'll see today so at

00:07:21,970 --> 00:07:25,570
the very top we have our payload this is

00:07:23,830 --> 00:07:26,980
the data that was actually signed so

00:07:25,570 --> 00:07:29,500
whatever the message is that you want to

00:07:26,980 --> 00:07:34,150
sign is put into the payload and again

00:07:29,500 --> 00:07:36,430
base64 URL safe base64 encoded and then

00:07:34,150 --> 00:07:41,640
we have an array of signatures we have

00:07:36,430 --> 00:07:45,400
two signatures in this jws so here here

00:07:41,640 --> 00:07:47,710
each signature has a protected header

00:07:45,400 --> 00:07:55,330
now the protected header as you can see

00:07:47,710 --> 00:07:56,919
all the way on the right side and that

00:07:55,330 --> 00:07:59,560
indicates the contents of what's inside

00:07:56,919 --> 00:08:02,919
the protected header that structure is

00:07:59,560 --> 00:08:06,700
then base64 encoded and included in the

00:08:02,919 --> 00:08:08,680
protected header we have another value

00:08:06,700 --> 00:08:10,780
called header which is not protected and

00:08:08,680 --> 00:08:12,660
what this what we mean by protected and

00:08:10,780 --> 00:08:14,919
not protected by the way is that the

00:08:12,660 --> 00:08:17,169
protected header if it's modified the

00:08:14,919 --> 00:08:19,150
signature will fail to validate but the

00:08:17,169 --> 00:08:21,400
the header that is not the protected

00:08:19,150 --> 00:08:24,700
header can be modified and it doesn't

00:08:21,400 --> 00:08:27,130
invalidate the signature finally we then

00:08:24,700 --> 00:08:29,020
have the signature that is a signature

00:08:27,130 --> 00:08:32,080
over the payload and the protected

00:08:29,020 --> 00:08:35,289
header so this is the most complex

00:08:32,080 --> 00:08:38,289
example if you this is also called by

00:08:35,289 --> 00:08:39,789
the way general serialization and it's

00:08:38,289 --> 00:08:41,329
called general serialization because

00:08:39,789 --> 00:08:44,059
basically anytime

00:08:41,329 --> 00:08:46,519
more than one signature in a jws you

00:08:44,059 --> 00:08:48,110
have to have this array like this but if

00:08:46,519 --> 00:08:50,149
you have a case where you are only ever

00:08:48,110 --> 00:08:51,589
going to have one signature you can

00:08:50,149 --> 00:08:54,379
actually use another serialization

00:08:51,589 --> 00:08:56,660
called flat and the way that the

00:08:54,379 --> 00:08:58,160
flattened serialization works is it just

00:08:56,660 --> 00:09:01,670
basically takes all of the data from

00:08:58,160 --> 00:09:03,799
that one serial from that one signature

00:09:01,670 --> 00:09:06,230
and moves it up in the object hierarchy

00:09:03,799 --> 00:09:10,009
so if you go back we have protected

00:09:06,230 --> 00:09:11,689
header and signature here and then we

00:09:10,009 --> 00:09:12,949
have protected header and signature here

00:09:11,689 --> 00:09:14,720
so it just moves them up in the

00:09:12,949 --> 00:09:19,100
hierarchy and takes up a little less

00:09:14,720 --> 00:09:22,220
room and so you notice here by the way

00:09:19,100 --> 00:09:23,959
we're saying in the header we have a key

00:09:22,220 --> 00:09:26,689
this is the key that was used to sign it

00:09:23,959 --> 00:09:29,089
so so if you were to receive say this

00:09:26,689 --> 00:09:31,850
jws you could go look in some key

00:09:29,089 --> 00:09:33,769
repository for this particular key ID

00:09:31,850 --> 00:09:38,959
and that's the one that should be able

00:09:33,769 --> 00:09:40,929
to validate the signature however

00:09:38,959 --> 00:09:43,100
there's also one more serialization and

00:09:40,929 --> 00:09:46,790
what we're going to do if you remember

00:09:43,100 --> 00:09:48,049
we've got we've got four items here now

00:09:46,790 --> 00:09:49,610
we're going to leave off the header

00:09:48,049 --> 00:09:51,559
parameter what you remember is not

00:09:49,610 --> 00:09:53,629
protected so it could be modified and

00:09:51,559 --> 00:09:55,369
we're going to take just the signature

00:09:53,629 --> 00:09:59,989
the protected head around the payload

00:09:55,369 --> 00:10:02,540
and we can flatten this once again into

00:09:59,989 --> 00:10:04,429
a string where you just simply put the

00:10:02,540 --> 00:10:06,860
protected header contents followed by

00:10:04,429 --> 00:10:09,129
period followed by the payload followed

00:10:06,860 --> 00:10:11,929
by a period followed by the signature

00:10:09,129 --> 00:10:13,189
now the unique thing that we can

00:10:11,929 --> 00:10:17,179
actually do with this is we can put this

00:10:13,189 --> 00:10:20,299
in a URL so one one particular case

00:10:17,179 --> 00:10:23,149
where this came up was we were having a

00:10:20,299 --> 00:10:25,819
meeting where we wanted to have a

00:10:23,149 --> 00:10:27,079
registration system so people could sign

00:10:25,819 --> 00:10:28,519
up with their email address and it would

00:10:27,079 --> 00:10:32,749
send them an email to confirm their

00:10:28,519 --> 00:10:33,860
email and and then they would click the

00:10:32,749 --> 00:10:35,720
link of course you've done this a

00:10:33,860 --> 00:10:38,079
million times on the internet not if you

00:10:35,720 --> 00:10:40,910
know what I'm talking about right so

00:10:38,079 --> 00:10:41,959
basically I came into the meeting about

00:10:40,910 --> 00:10:43,279
three minutes late and they had already

00:10:41,959 --> 00:10:44,629
designed the whole thing and it was

00:10:43,279 --> 00:10:47,119
magnificent there were like multiple

00:10:44,629 --> 00:10:48,319
moving parts and there was databases and

00:10:47,119 --> 00:10:51,079
all sorts of stuff just for this

00:10:48,319 --> 00:10:51,540
registration system and I came in and I

00:10:51,079 --> 00:10:54,420
sort of

00:10:51,540 --> 00:10:56,339
is my hand and I said why don't we just

00:10:54,420 --> 00:10:58,860
sign their email address and send it to

00:10:56,339 --> 00:11:00,360
them in a URL using this using this data

00:10:58,860 --> 00:11:02,160
format and you don't actually have to

00:11:00,360 --> 00:11:04,019
have any state on the server because

00:11:02,160 --> 00:11:05,820
once they click the link the server just

00:11:04,019 --> 00:11:07,170
validates the signature you don't need

00:11:05,820 --> 00:11:08,490
to have databases you don't need to have

00:11:07,170 --> 00:11:10,050
all of this massive code it's just

00:11:08,490 --> 00:11:12,300
really simple and effective right so

00:11:10,050 --> 00:11:14,490
this is this is one of the one example

00:11:12,300 --> 00:11:20,069
of how the Jersey standards can be used

00:11:14,490 --> 00:11:23,190
very effectively and since Josie always

00:11:20,069 --> 00:11:25,470
uses URL safe base64 which is just like

00:11:23,190 --> 00:11:27,540
regular base 64 but two characters are

00:11:25,470 --> 00:11:29,130
different in the encoding so it is

00:11:27,540 --> 00:11:31,829
standardized but it's but it's slightly

00:11:29,130 --> 00:11:34,860
different than regular base 64 since

00:11:31,829 --> 00:11:37,589
Josie always uses URL URL save base64

00:11:34,860 --> 00:11:39,420
and then always uses periods to

00:11:37,589 --> 00:11:45,149
concatenate the fields this is always

00:11:39,420 --> 00:11:47,009
safe to be inside a URL we can do the

00:11:45,149 --> 00:11:48,480
same thing with encryption so in the

00:11:47,009 --> 00:11:49,829
last case we were talking about signing

00:11:48,480 --> 00:11:53,100
and now we're going to talk about

00:11:49,829 --> 00:11:56,540
encryption this this is the most complex

00:11:53,100 --> 00:11:59,760
example you'll see today because

00:11:56,540 --> 00:12:01,649
Christian is slightly more complicated

00:11:59,760 --> 00:12:04,410
than than signing so the way that

00:12:01,649 --> 00:12:06,930
encryption works is you are going to

00:12:04,410 --> 00:12:08,100
have an encryption key and then

00:12:06,930 --> 00:12:09,990
encryption key is going to encrypt all

00:12:08,100 --> 00:12:12,420
the data and then you're going to

00:12:09,990 --> 00:12:14,819
encrypt the encryption key using another

00:12:12,420 --> 00:12:17,370
key and that key in this case we call

00:12:14,819 --> 00:12:19,290
the recipient key so if I'm going to

00:12:17,370 --> 00:12:21,779
encrypt something to you and to you and

00:12:19,290 --> 00:12:24,810
to you I only need a encrypt the

00:12:21,779 --> 00:12:27,839
content one time and then I encrypt that

00:12:24,810 --> 00:12:29,910
one key to each of your own separate

00:12:27,839 --> 00:12:32,100
keys right and each of your recipients

00:12:29,910 --> 00:12:33,079
and that's exactly what we're looking at

00:12:32,100 --> 00:12:38,220
here

00:12:33,079 --> 00:12:41,130
so in general format we have the first

00:12:38,220 --> 00:12:42,600
thing we have is the protected header at

00:12:41,130 --> 00:12:44,790
the top here which is just like the

00:12:42,600 --> 00:12:46,199
signature so uses all the same

00:12:44,790 --> 00:12:48,209
mechanisms that we saw on a signature

00:12:46,199 --> 00:12:50,310
but it's but it's now if we can gone for

00:12:48,209 --> 00:12:52,079
encryption we have an unprotected header

00:12:50,310 --> 00:12:53,819
protecting header by the way if your

00:12:52,079 --> 00:12:56,220
member means that if you modify it then

00:12:53,819 --> 00:12:58,019
the decryption will fail but the

00:12:56,220 --> 00:13:00,300
unprotected header can be modified after

00:12:58,019 --> 00:13:02,309
the fact that decryption will not fail

00:13:00,300 --> 00:13:03,990
saving encoding over here so the

00:13:02,309 --> 00:13:07,050
protected header is actually in this

00:13:03,990 --> 00:13:08,730
format and then it's it's serialized

00:13:07,050 --> 00:13:10,769
into a string and then basically for

00:13:08,730 --> 00:13:15,119
encoded and put into this protected

00:13:10,769 --> 00:13:16,920
header after this we have the ie the

00:13:15,119 --> 00:13:19,769
initialization vector for the

00:13:16,920 --> 00:13:22,230
cryptography we have the site protected

00:13:19,769 --> 00:13:24,089
itself which is the plaintext that we've

00:13:22,230 --> 00:13:26,189
now encrypted is stored here as

00:13:24,089 --> 00:13:27,600
ciphertext and then we have a tag and

00:13:26,189 --> 00:13:29,100
the tag is the thing that validates that

00:13:27,600 --> 00:13:30,389
when we decrypt it it hasn't been

00:13:29,100 --> 00:13:34,439
modified so that gives us our

00:13:30,389 --> 00:13:36,540
authentication so all of this is

00:13:34,439 --> 00:13:39,480
basically we take the data in we

00:13:36,540 --> 00:13:42,240
generate an IV and that's stored here we

00:13:39,480 --> 00:13:43,920
encrypt the data using using a randomly

00:13:42,240 --> 00:13:46,259
generated key that comes out of

00:13:43,920 --> 00:13:48,480
ciphertext we do our authentication

00:13:46,259 --> 00:13:50,699
which produces a tag we stick the tag on

00:13:48,480 --> 00:13:52,649
there we write our parameters into the

00:13:50,699 --> 00:13:53,790
protected header and then finally we

00:13:52,649 --> 00:13:55,139
take that key that we used to the

00:13:53,790 --> 00:13:56,369
encryption and we encrypt it to the

00:13:55,139 --> 00:13:58,139
actual recipients and here's the

00:13:56,369 --> 00:14:01,740
recipients we have two of them here one

00:13:58,139 --> 00:14:04,009
and two and a recipient can have a per

00:14:01,740 --> 00:14:07,529
recipient header which is not protected

00:14:04,009 --> 00:14:09,869
and then when we were encrypted to the

00:14:07,529 --> 00:14:12,029
recipient we're encrypting the key that

00:14:09,869 --> 00:14:15,420
we use to encrypt this and that

00:14:12,029 --> 00:14:16,949
encrypted key is stored here and then we

00:14:15,420 --> 00:14:18,569
also have some optional parameters here

00:14:16,949 --> 00:14:21,449
like which algorithm was used for the

00:14:18,569 --> 00:14:24,720
encryption we have things like which PID

00:14:21,449 --> 00:14:26,309
should be used to decrypt this value and

00:14:24,720 --> 00:14:28,170
so on so this is the most complex

00:14:26,309 --> 00:14:30,329
example I've probably hurt your brain a

00:14:28,170 --> 00:14:31,619
little bit but we're gonna move on to

00:14:30,329 --> 00:14:32,790
where it can get more simple from here

00:14:31,619 --> 00:14:36,059
so hopefully it should be simple to

00:14:32,790 --> 00:14:39,179
understand if you remember we have also

00:14:36,059 --> 00:14:41,970
had for the jason web signatures we had

00:14:39,179 --> 00:14:45,059
a flat syntax which is where when you

00:14:41,970 --> 00:14:47,009
have a single a single signature you can

00:14:45,059 --> 00:14:49,259
just move all the contents upward into

00:14:47,009 --> 00:14:51,749
the object hierarchy and we have exactly

00:14:49,259 --> 00:14:53,369
the same thing here so if we go back you

00:14:51,749 --> 00:14:55,709
notice we have two recipients here and

00:14:53,369 --> 00:14:58,709
the important bits are that we have an

00:14:55,709 --> 00:15:00,809
encrypted key well in this case we also

00:14:58,709 --> 00:15:02,999
have an encrypted key and a header so if

00:15:00,809 --> 00:15:05,220
you have a single recipient you can

00:15:02,999 --> 00:15:06,620
create the same object but instead just

00:15:05,220 --> 00:15:08,300
put the encrypted key in the header

00:15:06,620 --> 00:15:13,250
in the parents object and there's an

00:15:08,300 --> 00:15:15,020
implicit recipient there just like Jason

00:15:13,250 --> 00:15:18,080
Webb signatures we also have a compact

00:15:15,020 --> 00:15:20,630
format so we're gonna come back here we

00:15:18,080 --> 00:15:23,900
have a protected unprotected IV cipher

00:15:20,630 --> 00:15:25,220
text and tag now I'm sorry protect these

00:15:23,900 --> 00:15:29,980
are the five we're gonna say protected

00:15:25,220 --> 00:15:32,510
IV cipher text tag and a cryptic key

00:15:29,980 --> 00:15:35,420
initialization vector is yeah it's

00:15:32,510 --> 00:15:38,030
basically a bit of random data to ensure

00:15:35,420 --> 00:15:40,460
that encryption is unique for each

00:15:38,030 --> 00:15:43,460
encryption operation it's it's a public

00:15:40,460 --> 00:15:46,310
value but it's used it's the very first

00:15:43,460 --> 00:15:50,360
value you put into to get a starting

00:15:46,310 --> 00:15:52,010
position in your cryptography so I did

00:15:50,360 --> 00:15:53,180
use pretty universally although it's

00:15:52,010 --> 00:15:56,320
used slightly differently depending on

00:15:53,180 --> 00:15:56,320
the algorithm you you choose

00:16:02,550 --> 00:16:08,280
so for example if you're using AES GCM

00:16:05,720 --> 00:16:23,640
it will be slightly different than if

00:16:08,280 --> 00:16:27,330
you're using the AES C BCH Mack yes

00:16:23,640 --> 00:16:29,610
so tag is the it's the authentication

00:16:27,330 --> 00:16:32,970
information for the cipher text so after

00:16:29,610 --> 00:16:34,890
you encrypt the data then you perform

00:16:32,970 --> 00:16:36,990
authentication on the cipher text to

00:16:34,890 --> 00:16:40,680
make sure that it's not modified so the

00:16:36,990 --> 00:16:42,960
tag indicates for one let me give you a

00:16:40,680 --> 00:16:43,500
concrete example of this in the

00:16:42,960 --> 00:16:47,850
algorithm

00:16:43,500 --> 00:16:51,600
AES CBC H Mac the actual encryption is

00:16:47,850 --> 00:16:53,460
done using AES CBC and then an H Mac is

00:16:51,600 --> 00:16:57,900
done over the entirety of the cipher

00:16:53,460 --> 00:17:00,120
text and the output from the H back is

00:16:57,900 --> 00:17:02,460
stored is the tag now when you go to do

00:17:00,120 --> 00:17:04,530
the decryption the first thing you do is

00:17:02,460 --> 00:17:06,270
you validates that the cipher text you

00:17:04,530 --> 00:17:08,540
run that cipher text through the H max

00:17:06,270 --> 00:17:11,699
again and the H Mac will output a value

00:17:08,540 --> 00:17:13,380
if that value doesn't match this then

00:17:11,699 --> 00:17:14,820
the cipher text has been modified and

00:17:13,380 --> 00:17:17,959
you absolutely should not do anything

00:17:14,820 --> 00:17:17,959
with it you should drop it to the floor

00:17:18,770 --> 00:17:27,329
zel yes another question oh sorry yes I

00:17:25,079 --> 00:17:30,920
should do that that question was can I

00:17:27,329 --> 00:17:30,920
explain what the tag parameter is

00:17:34,940 --> 00:17:40,380
it is the tag parameter the question is

00:17:38,130 --> 00:17:42,930
was the tag parameter used for something

00:17:40,380 --> 00:17:45,270
for algorithms other than H Mac the

00:17:42,930 --> 00:17:49,740
answer is yes for example if you're

00:17:45,270 --> 00:17:52,140
using AES GCM the tag is yielded as part

00:17:49,740 --> 00:17:54,480
of the encryption operation so in that

00:17:52,140 --> 00:17:58,590
case it's all done is one step the

00:17:54,480 --> 00:18:01,260
plaintext is input to AES GCM and the

00:17:58,590 --> 00:18:03,300
ciphertext comes out and then when you

00:18:01,260 --> 00:18:05,040
are completely finished the last block

00:18:03,300 --> 00:18:07,410
of ciphertext comes out and the tag

00:18:05,040 --> 00:18:10,880
comes out but it's all done as a single

00:18:07,410 --> 00:18:10,880
operation yes

00:18:11,540 --> 00:18:14,660
[Music]

00:18:16,679 --> 00:18:23,960
I know who sent the idealist X those are

00:18:20,269 --> 00:18:26,370
inputs which detect always would be

00:18:23,960 --> 00:18:28,139
the tag is an output during the

00:18:26,370 --> 00:18:30,840
encryption phase and it's an input

00:18:28,139 --> 00:18:33,269
during it's an input during the

00:18:30,840 --> 00:18:33,990
encryption phase and it's in no I'm

00:18:33,269 --> 00:18:37,200
saying that's wrong

00:18:33,990 --> 00:18:39,899
start again okay the tag is an output

00:18:37,200 --> 00:18:43,470
during the encryption phase and it is an

00:18:39,899 --> 00:18:45,960
input during the decryption phase yeah

00:18:43,470 --> 00:18:48,120
yep and the important thing of the tag

00:18:45,960 --> 00:18:50,190
is that it's validating that the actual

00:18:48,120 --> 00:18:52,440
message has not changed right because

00:18:50,190 --> 00:18:54,629
there's all sorts of attacks if somebody

00:18:52,440 --> 00:18:56,639
can get ahold of your ciphertext and and

00:18:54,629 --> 00:18:59,549
make changes to it and ask you to

00:18:56,639 --> 00:19:01,830
decrypt it there's all sorts of attacks

00:18:59,549 --> 00:19:03,240
you can do so the very first thing you

00:19:01,830 --> 00:19:05,309
want to do is validate the message has

00:19:03,240 --> 00:19:07,110
not been modified once you know that

00:19:05,309 --> 00:19:13,619
it's not been modified then you proceed

00:19:07,110 --> 00:19:16,710
with decryption in the case of AES a AES

00:19:13,619 --> 00:19:19,350
C BCH Mack yes it is a digest in the

00:19:16,710 --> 00:19:20,999
case of other algorithms it is not it's

00:19:19,350 --> 00:19:24,269
sort of a generic remember this is

00:19:20,999 --> 00:19:26,129
really in this particular case the jwv

00:19:24,269 --> 00:19:27,629
standards were not actually defining how

00:19:26,129 --> 00:19:30,779
the algorithms work we're defining the

00:19:27,629 --> 00:19:32,249
storage format and tag can be used in

00:19:30,779 --> 00:19:34,139
different ways by different algorithms

00:19:32,249 --> 00:19:42,320
but it does roughly the same thing for

00:19:34,139 --> 00:19:42,320
all of them so another question yes sure

00:19:51,910 --> 00:19:58,450
it is not the yes the question was is

00:19:55,780 --> 00:20:02,080
the tag also encrypted the answer is no

00:19:58,450 --> 00:20:04,120
in the case of the algorithm a CB CH Mac

00:20:02,080 --> 00:20:07,210
which is one of the algorithms defined

00:20:04,120 --> 00:20:10,750
by the Jersey Stan standards you

00:20:07,210 --> 00:20:13,360
actually generate a double length key so

00:20:10,750 --> 00:20:16,720
instead of 16 bytes you would generate

00:20:13,360 --> 00:20:19,000
32 the first half of that key is used

00:20:16,720 --> 00:20:21,370
for doing the encryption the second half

00:20:19,000 --> 00:20:23,050
of that key is used for doing H Mac I

00:20:21,370 --> 00:20:25,570
may actually have my halves backwards

00:20:23,050 --> 00:20:26,980
but it's it's one of those two so

00:20:25,570 --> 00:20:30,400
basically you generate a double sized

00:20:26,980 --> 00:20:32,980
key and one is used for HVAC and one is

00:20:30,400 --> 00:20:35,020
used for for the actual encryption for

00:20:32,980 --> 00:20:38,340
AES GCM that's not the case you use the

00:20:35,020 --> 00:20:38,340
same key for the entire operation

00:20:40,140 --> 00:20:44,010
any other questions okay

00:20:44,820 --> 00:20:49,540
so we already talked about having

00:20:47,020 --> 00:20:52,300
compact format which can again be used

00:20:49,540 --> 00:20:55,030
in URLs so for example you wanted to

00:20:52,300 --> 00:20:56,559
have some date may be that you some data

00:20:55,030 --> 00:20:58,720
excuse me some metadata that you store

00:20:56,559 --> 00:21:02,290
say like in a cookie and you want to

00:20:58,720 --> 00:21:03,820
store that on a on a client system you

00:21:02,290 --> 00:21:06,160
can use this actually if you wanted to

00:21:03,820 --> 00:21:08,110
put it in some kind of a URL like keep

00:21:06,160 --> 00:21:08,410
sending it in an email or something like

00:21:08,110 --> 00:21:10,270
that

00:21:08,410 --> 00:21:15,520
and you could actually bundle in

00:21:10,270 --> 00:21:18,100
encrypted data along with the URL the

00:21:15,520 --> 00:21:20,500
next data format we're gonna talk about

00:21:18,100 --> 00:21:23,950
is the JSON web token and a jayson web

00:21:20,500 --> 00:21:26,350
token is the closest analogy is that

00:21:23,950 --> 00:21:29,980
it's the metadata that you get usually

00:21:26,350 --> 00:21:32,080
in a certificate particularly in the

00:21:29,980 --> 00:21:34,270
footing up for the if you're using a

00:21:32,080 --> 00:21:35,470
user certificate this would be similar

00:21:34,270 --> 00:21:37,510
kind of data that you would get in that

00:21:35,470 --> 00:21:39,790
certificate so there's no actual

00:21:37,510 --> 00:21:41,170
cryptography involved in this these are

00:21:39,790 --> 00:21:44,500
just the standard parameters that are

00:21:41,170 --> 00:21:46,870
well-defined and then there's also in

00:21:44,500 --> 00:21:48,940
the standard a way to put your own data

00:21:46,870 --> 00:21:50,950
in here it basically says that either

00:21:48,940 --> 00:21:53,140
you should define a standard and publish

00:21:50,950 --> 00:21:54,029
that standard and then you can actually

00:21:53,140 --> 00:21:56,999
have

00:21:54,029 --> 00:21:57,749
a short name reserved for you or if

00:21:56,999 --> 00:22:00,119
you're doing something that's

00:21:57,749 --> 00:22:04,019
application specific then you should use

00:22:00,119 --> 00:22:07,139
a a conflict resistant format so

00:22:04,019 --> 00:22:09,899
something like you know calm example dot

00:22:07,139 --> 00:22:11,700
parameter foo and that would that would

00:22:09,899 --> 00:22:14,039
be sure not to collide with other people

00:22:11,700 --> 00:22:15,690
using using the same thing we'll just

00:22:14,039 --> 00:22:17,789
walk very briefly through what these are

00:22:15,690 --> 00:22:19,830
so the issuer is the person who is

00:22:17,789 --> 00:22:23,849
making the assertion so they're saying

00:22:19,830 --> 00:22:27,269
I'm vouching for the subject which is me

00:22:23,849 --> 00:22:31,469
and people come I am the recipient for

00:22:27,269 --> 00:22:34,200
this is Def Con that's you guys and this

00:22:31,469 --> 00:22:37,499
assertion will expire at this particular

00:22:34,200 --> 00:22:40,619
time and it's not valid before this

00:22:37,499 --> 00:22:45,679
particular time and it was issued at

00:22:40,619 --> 00:22:48,019
this particular time and finally jti is

00:22:45,679 --> 00:22:50,749
something that I forget nothing my head

00:22:48,019 --> 00:22:53,460
yes thank you it's the token identifier

00:22:50,749 --> 00:22:56,279
yeah so this is a just as like to keep

00:22:53,460 --> 00:22:58,440
the k ID parameter for P's but this is a

00:22:56,279 --> 00:23:01,499
unique identifier for this for this web

00:22:58,440 --> 00:23:04,080
token now what's interesting is not the

00:23:01,499 --> 00:23:06,599
web token itself which again has this

00:23:04,080 --> 00:23:07,950
defined information there's also some

00:23:06,599 --> 00:23:10,320
additional stuff that's been defined

00:23:07,950 --> 00:23:11,700
since this point which could be put in

00:23:10,320 --> 00:23:13,229
here and then you can add your custom

00:23:11,700 --> 00:23:15,179
day that but that's not the thing that's

00:23:13,229 --> 00:23:17,219
unique or that's not the value itself

00:23:15,179 --> 00:23:18,509
well the value of this is that you take

00:23:17,219 --> 00:23:21,690
this metadata and then you wrap it

00:23:18,509 --> 00:23:25,139
inside either a jwe jason web encryption

00:23:21,690 --> 00:23:25,859
or a jws a jason web signature so this

00:23:25,139 --> 00:23:27,479
is the way that you can

00:23:25,859 --> 00:23:30,989
cryptographically validate that this

00:23:27,479 --> 00:23:32,580
data is actually not modified and that

00:23:30,989 --> 00:23:33,809
it's who it's supposed to be and that

00:23:32,580 --> 00:23:36,779
only the person who's supposed to see

00:23:33,809 --> 00:23:39,659
the data can see it one of the things i

00:23:36,779 --> 00:23:44,339
don't like about the standard but is is

00:23:39,659 --> 00:23:48,989
well-defined is that the JWT can be

00:23:44,339 --> 00:23:51,419
wrapped in JW ease or JW @ JW SS and

00:23:48,989 --> 00:23:53,159
possibly recursively so this means that

00:23:51,419 --> 00:23:56,159
you can actually pass the data across

00:23:53,159 --> 00:23:58,499
multiple hops and you know every hop

00:23:56,159 --> 00:24:00,450
could say at its own signature or it

00:23:58,499 --> 00:24:01,950
could add encryption at various

00:24:00,450 --> 00:24:03,659
different layers and then when you

00:24:01,950 --> 00:24:04,320
receive it you basically need to unwrap

00:24:03,659 --> 00:24:07,260
all of the

00:24:04,320 --> 00:24:09,240
and and then you actually get the data

00:24:07,260 --> 00:24:12,000
at the end once you validated every

00:24:09,240 --> 00:24:14,220
single layer so it's a little bit

00:24:12,000 --> 00:24:18,440
complicated and I haven't written code

00:24:14,220 --> 00:24:22,350
for this because it's hard yes correct

00:24:18,440 --> 00:24:23,940
yep so it does have some positive uses I

00:24:22,350 --> 00:24:25,230
only don't like it because it's actually

00:24:23,940 --> 00:24:30,630
just hard to implement and I haven't

00:24:25,230 --> 00:24:31,680
implemented it yet okay so we've up

00:24:30,630 --> 00:24:32,940
until this point we've been talking

00:24:31,680 --> 00:24:35,340
about Josie which is the set of

00:24:32,940 --> 00:24:37,320
specifications so everything before this

00:24:35,340 --> 00:24:38,850
you know this slide and before it should

00:24:37,320 --> 00:24:40,920
be standard everybody should be doing it

00:24:38,850 --> 00:24:42,600
exactly the same way and everything that

00:24:40,920 --> 00:24:44,340
you see after this point is now talking

00:24:42,600 --> 00:24:48,180
about the specific complementation that

00:24:44,340 --> 00:24:50,940
I've done so we have at Red Hat created

00:24:48,180 --> 00:24:53,340
the Jose project the Jose project as a

00:24:50,940 --> 00:24:57,120
see library and I see Li implementation

00:24:53,340 --> 00:24:59,160
of the Josie specifications so we have

00:24:57,120 --> 00:25:00,900
support for all of the RFC to find

00:24:59,160 --> 00:25:03,360
algorithms this statement is actually

00:25:00,900 --> 00:25:06,000
out of date because the CF RG curves

00:25:03,360 --> 00:25:08,010
were just recently standardized but up

00:25:06,000 --> 00:25:11,430
until that point we have all of the

00:25:08,010 --> 00:25:13,080
algorithms and one of the neat things

00:25:11,430 --> 00:25:16,080
about this library is that we actually

00:25:13,080 --> 00:25:18,570
don't have any C data types natively so

00:25:16,080 --> 00:25:21,210
what you and we have no date JSON

00:25:18,570 --> 00:25:23,340
parsing why this is important first of

00:25:21,210 --> 00:25:25,080
all let's talk about the parsing parson

00:25:23,340 --> 00:25:26,250
is really dangerous I don't know if you

00:25:25,080 --> 00:25:28,440
watch CVEs

00:25:26,250 --> 00:25:30,600
there's a lot of them for parsing bugs

00:25:28,440 --> 00:25:33,000
right and what you really don't want to

00:25:30,600 --> 00:25:35,400
have is your parsing and your encryption

00:25:33,000 --> 00:25:38,070
in the same place right that would be

00:25:35,400 --> 00:25:41,160
just absolutely fundamental fail and in

00:25:38,070 --> 00:25:43,050
fact a lot of of implementers of Josey

00:25:41,160 --> 00:25:45,300
acts absolutely make this mistake

00:25:43,050 --> 00:25:47,790
they take strings as input strings as

00:25:45,300 --> 00:25:50,190
output and they serialize everything so

00:25:47,790 --> 00:25:52,910
so I want to point out specifically we

00:25:50,190 --> 00:25:56,180
do not do any JSON parsing there is a

00:25:52,910 --> 00:25:59,100
really good library called Janssen and

00:25:56,180 --> 00:26:02,340
Janssen is really battle-tested and it

00:25:59,100 --> 00:26:04,200
works really well and that is who does

00:26:02,340 --> 00:26:06,450
all of all of the parsing and it can be

00:26:04,200 --> 00:26:09,480
done in another in another thread if you

00:26:06,450 --> 00:26:12,390
wanted to and it does not have to be

00:26:09,480 --> 00:26:15,510
related to to Jose at all but you pass

00:26:12,390 --> 00:26:16,950
us those parse data types but it's also

00:26:15,510 --> 00:26:17,340
further important to note that we don't

00:26:16,950 --> 00:26:19,620
then

00:26:17,340 --> 00:26:21,420
take those data types from from Janssen

00:26:19,620 --> 00:26:23,340
and convert them into something see

00:26:21,420 --> 00:26:25,140
native and the reason for this is that

00:26:23,340 --> 00:26:26,550
actually a lot of implementations do

00:26:25,140 --> 00:26:28,620
this they make the mistake of saying

00:26:26,550 --> 00:26:30,150
well you give me something that's JSON

00:26:28,620 --> 00:26:32,280
and then all parsed it into a language

00:26:30,150 --> 00:26:33,660
structure and then we can operate in the

00:26:32,280 --> 00:26:35,310
language structure and then when we're

00:26:33,660 --> 00:26:37,440
done we'll serialize it back out as

00:26:35,310 --> 00:26:39,330
Jason well the problem with this is that

00:26:37,440 --> 00:26:42,870
the standards are intentionally designed

00:26:39,330 --> 00:26:45,120
to be extremely fluid in the amount of

00:26:42,870 --> 00:26:46,470
optional data that you can have and so

00:26:45,120 --> 00:26:48,660
what all the people do wrong when they

00:26:46,470 --> 00:26:51,180
implement this is they parse that into

00:26:48,660 --> 00:26:53,070
the CC type and anything they don't know

00:26:51,180 --> 00:26:54,540
about they drop on the floor well now

00:26:53,070 --> 00:26:56,880
you've just completely lost all of this

00:26:54,540 --> 00:26:58,950
extensibility and we don't want to do

00:26:56,880 --> 00:27:00,720
that so what we do is we don't have any

00:26:58,950 --> 00:27:02,100
native C datatypes you just parse the

00:27:00,720 --> 00:27:04,290
raw jason and once you have a raw

00:27:02,100 --> 00:27:05,640
representation of that jason you hand it

00:27:04,290 --> 00:27:08,850
to our library and we do everything from

00:27:05,640 --> 00:27:11,310
there our api is also driven by a

00:27:08,850 --> 00:27:15,690
template approach so what this means is

00:27:11,310 --> 00:27:18,030
that instead of having again native data

00:27:15,690 --> 00:27:20,370
types which specify all of your options

00:27:18,030 --> 00:27:22,860
you just hand us something that looks

00:27:20,370 --> 00:27:25,020
like the output you want so for example

00:27:22,860 --> 00:27:26,610
if you're generating a key tell us what

00:27:25,020 --> 00:27:29,550
algorithm you want that key to be for

00:27:26,610 --> 00:27:30,930
and then hand us that and the way that

00:27:29,550 --> 00:27:33,540
you tell us to what algorithm has been

00:27:30,930 --> 00:27:37,110
before if we go all the way back to the

00:27:33,540 --> 00:27:40,500
jwk we have an algorithm parameter right

00:27:37,110 --> 00:27:43,410
so give us a jason object that has only

00:27:40,500 --> 00:27:45,450
leave out all of this data has only the

00:27:43,410 --> 00:27:47,040
algorithm parameter and we'll fill in

00:27:45,450 --> 00:27:49,590
all this data for you automatically

00:27:47,040 --> 00:27:51,240
right so it does require that you know a

00:27:49,590 --> 00:27:53,670
little bit about the specification in

00:27:51,240 --> 00:27:55,740
order to craft this template but it also

00:27:53,670 --> 00:27:59,640
means that we don't have to do all sorts

00:27:55,740 --> 00:28:02,100
of overhead when manipulating these data

00:27:59,640 --> 00:28:03,780
types so it can actually be basically

00:28:02,100 --> 00:28:07,080
just parse the data give us the data

00:28:03,780 --> 00:28:08,940
directly and then you're done whenever

00:28:07,080 --> 00:28:11,460
we have missing parameters in these

00:28:08,940 --> 00:28:13,740
templates we do our best to fill in the

00:28:11,460 --> 00:28:15,750
data first of all we infer for example

00:28:13,740 --> 00:28:18,060
algorithms from keys if you don't tell

00:28:15,750 --> 00:28:19,980
us what kind of algorithm that you want

00:28:18,060 --> 00:28:21,840
to use for your encryption and you've

00:28:19,980 --> 00:28:23,730
handed us a key that has the algorithm

00:28:21,840 --> 00:28:25,830
parameter guess what we can figure out

00:28:23,730 --> 00:28:27,750
exactly which algorithm you're trying to

00:28:25,830 --> 00:28:30,210
use and we can do this without

00:28:27,750 --> 00:28:31,620
any ambiguity one of the things that's

00:28:30,210 --> 00:28:34,830
important is that if we do detective

00:28:31,620 --> 00:28:36,480
ambiguity or a conflict we bail but if

00:28:34,830 --> 00:28:38,130
we don't if it's very obvious what

00:28:36,480 --> 00:28:38,610
you're trying to do then we just do it

00:28:38,130 --> 00:28:42,360
for you

00:28:38,610 --> 00:28:43,380
so any all the parameters are inferred

00:28:42,360 --> 00:28:44,970
from keys they're inferred from the

00:28:43,380 --> 00:28:50,210
headers and we always if they're not

00:28:44,970 --> 00:28:50,210
specified use sensible secure defaults

00:28:59,120 --> 00:29:03,870
well figure out things it can figure out

00:29:01,560 --> 00:29:06,720
right so if you don't have an algorithm

00:29:03,870 --> 00:29:08,460
we can't fill that in for you but if you

00:29:06,720 --> 00:29:09,540
give us the algorithm we can fill in all

00:29:08,460 --> 00:29:14,100
of the other information that the

00:29:09,540 --> 00:29:17,040
algorithm implies right so the library

00:29:14,100 --> 00:29:20,010
design works like this we have a very

00:29:17,040 --> 00:29:23,160
core library that implements the Jozy

00:29:20,010 --> 00:29:25,650
logic and then all of the crypto itself

00:29:23,160 --> 00:29:27,480
is implemented as hooks which means you

00:29:25,650 --> 00:29:30,420
can plug in another crypto system here

00:29:27,480 --> 00:29:33,540
at some point if you want and then all

00:29:30,420 --> 00:29:35,100
of our all of our code is currently

00:29:33,540 --> 00:29:37,470
using open SSL so we've not we're not

00:29:35,100 --> 00:29:42,060
building the the algorithms are directly

00:29:37,470 --> 00:29:44,280
and then on top of the C API we provide

00:29:42,060 --> 00:29:46,350
a CLI tool which provides a thin layer

00:29:44,280 --> 00:29:47,340
around the CI API and what this means is

00:29:46,350 --> 00:29:48,810
that anything that you can do

00:29:47,340 --> 00:29:52,320
essentially in C you can also do from

00:29:48,810 --> 00:29:54,390
the command line the last thing is that

00:29:52,320 --> 00:29:56,040
we extensively unit test this against

00:29:54,390 --> 00:29:56,580
all of the test factors from the from

00:29:56,040 --> 00:29:58,860
the RFC

00:29:56,580 --> 00:30:01,440
we also use test factors that have been

00:29:58,860 --> 00:30:04,500
produced by other parties as well and

00:30:01,440 --> 00:30:06,690
we're fully conformant to all of this so

00:30:04,500 --> 00:30:09,540
here's the URL to the project github /

00:30:06,690 --> 00:30:11,610
github comm forward slash slash set

00:30:09,540 --> 00:30:14,220
forward slash jose and it's really easy

00:30:11,610 --> 00:30:17,700
to install on fedora just DNF install

00:30:14,220 --> 00:30:21,480
Jose so let's look at how to actually

00:30:17,700 --> 00:30:24,390
use the Jose code three minutes out

00:30:21,480 --> 00:30:27,450
goodness I'll go quickly so if we have a

00:30:24,390 --> 00:30:28,980
function called Jose gwk Jen it takes a

00:30:27,450 --> 00:30:31,650
configuration object which can be null

00:30:28,980 --> 00:30:33,870
and anything JJ to be a template you

00:30:31,650 --> 00:30:34,010
want you just tell it basically I want

00:30:33,870 --> 00:30:36,200
to

00:30:34,010 --> 00:30:38,390
for this algorithm and then it spits out

00:30:36,200 --> 00:30:40,070
that key generates it for you you can

00:30:38,390 --> 00:30:41,720
also specify things like I don't want

00:30:40,070 --> 00:30:44,960
this algorithm specifically I just want

00:30:41,720 --> 00:30:47,720
16 bytes and you can do that and then

00:30:44,960 --> 00:30:49,640
lastly if you specify multiple templates

00:30:47,720 --> 00:30:52,520
we will output a key set if you remember

00:30:49,640 --> 00:30:54,440
there's a key set data type and so if

00:30:52,520 --> 00:30:58,220
you just tell us generate multiple keys

00:30:54,440 --> 00:30:59,930
will output it as a set by the way

00:30:58,220 --> 00:31:02,840
anything that you put in this object in

00:30:59,930 --> 00:31:04,130
this template that that we don't know

00:31:02,840 --> 00:31:08,750
about we leave it in place we don't

00:31:04,130 --> 00:31:13,130
touch it either B so we have some jwk

00:31:08,750 --> 00:31:18,260
utilities the we have pub which removes

00:31:13,130 --> 00:31:20,900
all private key material we have a use

00:31:18,260 --> 00:31:22,850
parameter which basically says hey can I

00:31:20,900 --> 00:31:25,100
use this in ado signatures can I use it

00:31:22,850 --> 00:31:27,140
to do encryptions and it will tell us

00:31:25,100 --> 00:31:29,570
yes or no and then finally we can

00:31:27,140 --> 00:31:35,870
generate a thumbprint from the from the

00:31:29,570 --> 00:31:40,160
public key material we have algorithms

00:31:35,870 --> 00:31:42,110
for signing and we basically just at the

00:31:40,160 --> 00:31:44,000
C code is here by the way and the CLI

00:31:42,110 --> 00:31:46,280
code is here anything you can do with

00:31:44,000 --> 00:31:47,630
the CLI you can do with C and vice versa

00:31:46,280 --> 00:31:51,140
I think there's only one exception to

00:31:47,630 --> 00:31:54,650
that basically most of these parameters

00:31:51,140 --> 00:31:56,600
are null so typically if you're doing a

00:31:54,650 --> 00:31:58,910
signature the config parameter will be

00:31:56,600 --> 00:32:01,700
no the signature will be no and you'll

00:31:58,910 --> 00:32:02,870
say here's my for my DWS output is and

00:32:01,700 --> 00:32:05,000
this is the key I wanna use for the

00:32:02,870 --> 00:32:07,220
signature so but if you want more

00:32:05,000 --> 00:32:09,650
control you can fill in the other fill

00:32:07,220 --> 00:32:12,050
in the other data verification is

00:32:09,650 --> 00:32:15,740
basically done the same just in the

00:32:12,050 --> 00:32:17,450
opposite direction of course and here we

00:32:15,740 --> 00:32:19,400
do oh one thing I need to say here is

00:32:17,450 --> 00:32:22,100
that if you specify multiple keys we

00:32:19,400 --> 00:32:24,050
give you general if you do one key we

00:32:22,100 --> 00:32:26,240
give you flatten serialization if you

00:32:24,050 --> 00:32:29,000
specify the - C option we can do compact

00:32:26,240 --> 00:32:31,250
serialization and the last thing is that

00:32:29,000 --> 00:32:34,190
you can actually create a signature that

00:32:31,250 --> 00:32:35,900
does not contain the the payload in it

00:32:34,190 --> 00:32:38,140
it can be contained in another file if

00:32:35,900 --> 00:32:40,270
you want to

00:32:38,140 --> 00:32:44,440
so verification is basically the same

00:32:40,270 --> 00:32:46,900
thing just the other side of the of the

00:32:44,440 --> 00:32:48,640
signature and we have a non zero like

00:32:46,900 --> 00:32:50,830
this exit status here and zero exists at

00:32:48,640 --> 00:32:52,929
us here here's a case where we have

00:32:50,830 --> 00:32:53,880
detached payload so it's not actually in

00:32:52,929 --> 00:32:58,110
the object itself

00:32:53,880 --> 00:33:00,520
same thing with encryption you can do

00:32:58,110 --> 00:33:02,260
multiple keys you can generalize

00:33:00,520 --> 00:33:04,690
serialization one key flatten

00:33:02,260 --> 00:33:07,420
serialization this - the option gives

00:33:04,690 --> 00:33:09,730
you compact serialization and one of the

00:33:07,420 --> 00:33:11,740
downsides by the way to encrypting there

00:33:09,730 --> 00:33:15,190
or to encrypting or signing data with

00:33:11,740 --> 00:33:17,470
with the Jersey standards is that for

00:33:15,190 --> 00:33:19,419
example your cipher text if it's big

00:33:17,470 --> 00:33:21,190
cipher text it's now going to be base64

00:33:19,419 --> 00:33:22,360
encoded which makes it even bigger which

00:33:21,190 --> 00:33:24,190
is why you would want to use this to

00:33:22,360 --> 00:33:25,870
attach serialization the touch

00:33:24,190 --> 00:33:28,809
serialization is going to output the

00:33:25,870 --> 00:33:30,309
cipher text is binary and all the other

00:33:28,809 --> 00:33:37,090
parameters are just going to be inside

00:33:30,309 --> 00:33:40,840
your jason there's other stuff here too

00:33:37,090 --> 00:33:43,150
that's cool let me just say this

00:33:40,840 --> 00:33:44,980
I work we're working on adding pkcs 11

00:33:43,150 --> 00:33:47,290
support we would love to have additional

00:33:44,980 --> 00:33:49,090
crypto library support we don't have any

00:33:47,290 --> 00:33:51,040
JSON web token functions yet but if you

00:33:49,090 --> 00:33:52,870
want to add those please contribute we

00:33:51,040 --> 00:33:55,870
also would like to add functions to

00:33:52,870 --> 00:33:58,600
convert from certificates and we'd like

00:33:55,870 --> 00:34:00,910
and it's add any other RFC features of

00:33:58,600 --> 00:34:02,230
course pull requests are welcome and if

00:34:00,910 --> 00:34:03,010
you have any questions I'm happy to

00:34:02,230 --> 00:34:07,000
field those do we have time for

00:34:03,010 --> 00:34:08,500
questions okay thank you thank you I'll

00:34:07,000 --> 00:34:11,790
hang outside the door if you have

00:34:08,500 --> 00:34:11,790

YouTube URL: https://www.youtube.com/watch?v=1pRJVf413Pc


