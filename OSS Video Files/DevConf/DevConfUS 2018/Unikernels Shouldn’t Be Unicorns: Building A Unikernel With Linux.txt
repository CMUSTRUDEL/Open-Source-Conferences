Title: Unikernels Shouldn’t Be Unicorns: Building A Unikernel With Linux
Publication date: 2019-02-22
Playlist: DevConfUS 2018
Description: 
	Unikernels are showing increasing promise as a new operating system model for cloud applications that enables deep per-application optimization. Given their short startup times, unikernels are ideal for deploying microservices. A significant concern about the unikernel model is that all of today’s unikernels are reliant on almost untested software, throwing away the value of the battle-tested Linux code base and requiring a fundamentally new community, resulting in huge maintainability challenges to a company that wants to support them. This project shows our work on creating a unikernel by making negligible changes to Linux code base, making it simple to make application-specific unikernels. Applications already running on Linux will require little or no changes to be deployed on this Linux based unikernel, allowing ease of use.
Captions: 
	00:00:10,379 --> 00:00:15,760
thanks again everybody thanks for coming

00:00:12,670 --> 00:00:18,690
back in we will now begin the exciting

00:00:15,760 --> 00:00:20,410
courting portion of the afternoon

00:00:18,690 --> 00:00:22,720
actually I think it's already been

00:00:20,410 --> 00:00:25,810
fairly exciting but this is another

00:00:22,720 --> 00:00:27,760
thing that I mean there's a theme in

00:00:25,810 --> 00:00:31,300
this room it's all stuff I didn't know

00:00:27,760 --> 00:00:33,640
three months ago like all of it I

00:00:31,300 --> 00:00:34,210
thought I was pretty smart but I was

00:00:33,640 --> 00:00:37,180
wrong

00:00:34,210 --> 00:00:39,370
apparently so this is a talk about in

00:00:37,180 --> 00:00:41,560
unit kernels it turns out that a unit

00:00:39,370 --> 00:00:44,440
kernel is a very interesting thing with

00:00:41,560 --> 00:00:48,010
a lot of cool uses that I had no idea

00:00:44,440 --> 00:00:50,230
about our distinguished guest Dooley is

00:00:48,010 --> 00:00:53,320
gonna start talking about of them and

00:00:50,230 --> 00:00:54,969
then our intern Ally Raza has been

00:00:53,320 --> 00:00:57,610
working with us all summer and is

00:00:54,969 --> 00:01:05,740
working when I PhD in this subject we'll

00:00:57,610 --> 00:01:07,810
continue from there thanks Ali I would

00:01:05,740 --> 00:01:09,490
keep it short so at least the one who's

00:01:07,810 --> 00:01:11,319
still in the work and he deserves to

00:01:09,490 --> 00:01:14,549
speak for that so I just want to say

00:01:11,319 --> 00:01:17,170
that unit counts happen and torn will

00:01:14,549 --> 00:01:19,560
expand hundreds if necessary you have

00:01:17,170 --> 00:01:22,179
been of interest in academia for a while

00:01:19,560 --> 00:01:24,520
so when we are talking about something

00:01:22,179 --> 00:01:26,679
in this area which then also is useful

00:01:24,520 --> 00:01:29,109
for redheads specifically or the

00:01:26,679 --> 00:01:31,299
industry in general well we don't like

00:01:29,109 --> 00:01:33,579
to start out from scratch and do

00:01:31,299 --> 00:01:35,039
something else and expand our code base

00:01:33,579 --> 00:01:38,889
which we have to maintain and support

00:01:35,039 --> 00:01:42,159
tremendously so when we just guess this

00:01:38,889 --> 00:01:44,020
a couple of months ago so we came to the

00:01:42,159 --> 00:01:45,789
conclusion well let's try to do

00:01:44,020 --> 00:01:47,829
something else let's try to do something

00:01:45,789 --> 00:01:49,990
where we are not expanding our code base

00:01:47,829 --> 00:01:52,119
that much where we are trying to use

00:01:49,990 --> 00:01:54,669
exactly what we are already doing as Red

00:01:52,119 --> 00:01:56,919
Hat so last comlinks use event

00:01:54,669 --> 00:01:59,070
environment and try to do something

00:01:56,919 --> 00:02:01,710
which is provides the benefits of

00:01:59,070 --> 00:02:03,300
Unicron ax which Ali will explain in a

00:02:01,710 --> 00:02:05,250
bit for those who are not aware of this

00:02:03,300 --> 00:02:07,350
but at the same time makes something

00:02:05,250 --> 00:02:10,950
which we can actually support and that's

00:02:07,350 --> 00:02:13,080
going to be the Ont what Ali will

00:02:10,950 --> 00:02:17,070
present is yes this is actually possible

00:02:13,080 --> 00:02:19,350
and for us this means that perhaps we

00:02:17,070 --> 00:02:22,620
will actually be able to base products

00:02:19,350 --> 00:02:24,930
on that and we will do and be able to do

00:02:22,620 --> 00:02:27,750
more researching exactly that's area 2

00:02:24,930 --> 00:02:29,850
going forward so I might speak a couple

00:02:27,750 --> 00:02:35,880
words in the end but for now let's talk

00:02:29,850 --> 00:02:41,910
it's a hobby time yes

00:02:35,880 --> 00:02:44,400
I don't have to just point there so hi

00:02:41,910 --> 00:02:46,680
everybody I'm Ali and I'll be talking

00:02:44,400 --> 00:02:47,760
about the project that I did over the

00:02:46,680 --> 00:02:50,790
summer

00:02:47,760 --> 00:02:54,420
unicorn elf based on Linux my advices

00:02:50,790 --> 00:02:56,280
for the project are holy and Richard

00:02:54,420 --> 00:02:58,650
Jones from Red Hat and my PhD advisor

00:02:56,280 --> 00:03:01,260
professor over on free girl from bu and

00:02:58,650 --> 00:03:04,590
also from Boston University my fellow

00:03:01,260 --> 00:03:06,570
PhD students Jim and Tommy who've been

00:03:04,590 --> 00:03:09,600
also involved in this project and have

00:03:06,570 --> 00:03:13,140
been helping with this project so first

00:03:09,600 --> 00:03:15,000
questions first what is a unicorn oh so

00:03:13,140 --> 00:03:17,130
this is what a normal kind of looks like

00:03:15,000 --> 00:03:19,680
there's a separation between the kernel

00:03:17,130 --> 00:03:21,450
space and a user space the kernel

00:03:19,680 --> 00:03:25,110
contains whatever the applications might

00:03:21,450 --> 00:03:27,450
need file systems device drivers the POS

00:03:25,110 --> 00:03:29,610
functionality for example scheduler or

00:03:27,450 --> 00:03:31,620
memory management things like that and

00:03:29,610 --> 00:03:33,510
multiple applications run on top of that

00:03:31,620 --> 00:03:35,880
but in a guinea kernel

00:03:33,510 --> 00:03:38,670
there is just one application which

00:03:35,880 --> 00:03:42,090
includes only the required functionality

00:03:38,670 --> 00:03:44,010
in it as well as a library whatever is

00:03:42,090 --> 00:03:46,650
there is come contained in this one

00:03:44,010 --> 00:03:48,680
binary which then unlocks on top of the

00:03:46,650 --> 00:03:51,959
hardware this is what a unique kernel is

00:03:48,680 --> 00:03:53,579
now the next big question why unique

00:03:51,959 --> 00:03:55,690
results and the answer is really simple

00:03:53,579 --> 00:03:58,460
because they break

00:03:55,690 --> 00:04:01,760
so why are they great first of all

00:03:58,460 --> 00:04:03,410
they're lightweight because the unique

00:04:01,760 --> 00:04:04,850
kernel only contains the required

00:04:03,410 --> 00:04:06,860
functionality the bare minimum required

00:04:04,850 --> 00:04:11,030
functionality that that an application

00:04:06,860 --> 00:04:12,830
needs and nothing else which means that

00:04:11,030 --> 00:04:14,510
for example let's say if there's an

00:04:12,830 --> 00:04:16,640
application which does not be the file

00:04:14,510 --> 00:04:18,019
system support the kernel the unique

00:04:16,640 --> 00:04:20,600
linen will not have the pulse some

00:04:18,019 --> 00:04:22,370
support in it which means smaller attack

00:04:20,600 --> 00:04:25,850
surface because there's a lot less code

00:04:22,370 --> 00:04:28,250
to exploit also you can internal when

00:04:25,850 --> 00:04:30,350
booting up we only initialize devices

00:04:28,250 --> 00:04:32,480
and other things that the application

00:04:30,350 --> 00:04:36,440
needs so that results in faster boot

00:04:32,480 --> 00:04:38,840
times unique kernels also give us

00:04:36,440 --> 00:04:40,940
improved performance because since there

00:04:38,840 --> 00:04:43,430
is no separation between a user space

00:04:40,940 --> 00:04:45,680
and a kernel space there we do not do

00:04:43,430 --> 00:04:48,350
not incur the rain transition overhead

00:04:45,680 --> 00:04:50,600
and the beginning kernel we can do

00:04:48,350 --> 00:04:52,400
application specific optimizations for

00:04:50,600 --> 00:04:54,860
example in a unique kernel you can have

00:04:52,400 --> 00:04:57,140
very efficient extremely stripped down

00:04:54,860 --> 00:05:01,130
network stack because there is only one

00:04:57,140 --> 00:05:04,160
application that uses it and there are

00:05:01,130 --> 00:05:05,290
many unique kernels out there for

00:05:04,160 --> 00:05:08,360
example equality

00:05:05,290 --> 00:05:10,460
click OS Mirage OS and many others and

00:05:08,360 --> 00:05:13,250
as I already said they give us huge

00:05:10,460 --> 00:05:16,100
performance benefits for example a party

00:05:13,250 --> 00:05:17,480
gives us more than two times memcache D

00:05:16,100 --> 00:05:20,419
throughput as compared to something

00:05:17,480 --> 00:05:22,310
running on simple enough links on

00:05:20,419 --> 00:05:26,840
website which runs on link unique kernel

00:05:22,310 --> 00:05:30,740
takes only 25 MB of memory and network

00:05:26,840 --> 00:05:33,380
processing software made on clip OS the

00:05:30,740 --> 00:05:35,480
unique kernel it processes more than 5

00:05:33,380 --> 00:05:38,510
million packets per second and it's

00:05:35,480 --> 00:05:43,330
Buddha prime is under 30 milliseconds so

00:05:38,510 --> 00:05:45,830
as every scene unicorns are great but

00:05:43,330 --> 00:05:49,250
they're they've mostly been limited to

00:05:45,830 --> 00:05:52,430
academic and research circles they are

00:05:49,250 --> 00:05:53,650
not as widely used one of the reasons is

00:05:52,430 --> 00:05:54,940
that they are not general

00:05:53,650 --> 00:05:57,520
which means that you cannot just take

00:05:54,940 --> 00:05:59,889
any application and compile it into a

00:05:57,520 --> 00:06:01,240
unit readily without modification so

00:05:59,889 --> 00:06:03,430
what we're going to do we're going to

00:06:01,240 --> 00:06:06,699
look at why that is the case and what

00:06:03,430 --> 00:06:08,229
can we do for it so starting off with

00:06:06,699 --> 00:06:10,270
the development model of Kuna kernels

00:06:08,229 --> 00:06:12,009
this is one of the main reasons that

00:06:10,270 --> 00:06:13,539
many kernels are not added as widely

00:06:12,009 --> 00:06:15,070
used there are two approaches to

00:06:13,539 --> 00:06:16,660
basically build a unique kernel that

00:06:15,070 --> 00:06:18,759
have been taken by developers who've

00:06:16,660 --> 00:06:21,280
developed different unique kernels first

00:06:18,759 --> 00:06:24,039
is the clean slate approach where you

00:06:21,280 --> 00:06:25,210
start fresh write the entire unicorn

00:06:24,039 --> 00:06:29,080
will yourself build it from the ground

00:06:25,210 --> 00:06:31,240
up and the second is that you use me

00:06:29,080 --> 00:06:34,150
second is that you fork an existing code

00:06:31,240 --> 00:06:37,449
base for example Linux or net VST change

00:06:34,150 --> 00:06:39,160
it modify it do all optimizes Jui

00:06:37,449 --> 00:06:41,729
optimizations that we want strip it down

00:06:39,160 --> 00:06:44,830
and make make a unique kernel out of it

00:06:41,729 --> 00:06:48,639
as we discussed this is a great approach

00:06:44,830 --> 00:06:50,349
this has nice advantages to it for

00:06:48,639 --> 00:06:51,699
example the developers have total

00:06:50,349 --> 00:06:53,590
control over the code they can do

00:06:51,699 --> 00:06:55,990
different optimizations that you want to

00:06:53,590 --> 00:06:58,949
do and this results in great performance

00:06:55,990 --> 00:07:02,440
benefit but it also has its drawbacks

00:06:58,949 --> 00:07:04,150
for example you cannot just run any

00:07:02,440 --> 00:07:07,090
legacy application on these unique

00:07:04,150 --> 00:07:09,159
kernels without modification since there

00:07:07,090 --> 00:07:11,110
is no community around these projects

00:07:09,159 --> 00:07:12,820
for example as compared to Linux or GMC

00:07:11,110 --> 00:07:14,620
where this an entire huge community

00:07:12,820 --> 00:07:16,690
which keeps maintaining these projects

00:07:14,620 --> 00:07:18,909
these general projects they don't have

00:07:16,690 --> 00:07:23,650
that community around them so they are

00:07:18,909 --> 00:07:25,180
maintaining and testing nightmare so

00:07:23,650 --> 00:07:27,550
what can the future be what questions

00:07:25,180 --> 00:07:29,260
can be asked the main question that we

00:07:27,550 --> 00:07:29,880
ask is how can we change the development

00:07:29,260 --> 00:07:32,349
model

00:07:29,880 --> 00:07:34,870
Kandice chuh a kernel be part of the

00:07:32,349 --> 00:07:38,830
Linux codebase the Linux project and the

00:07:34,870 --> 00:07:40,510
GMC project in this develop in this

00:07:38,830 --> 00:07:42,820
development model the main thing would

00:07:40,510 --> 00:07:45,460
be that you just need a unicorn all that

00:07:42,820 --> 00:07:47,169
words it does not it might not be the

00:07:45,460 --> 00:07:48,820
best any kernel are the most optimized

00:07:47,169 --> 00:07:52,000
una kernel out there it just has to work

00:07:48,820 --> 00:07:54,430
and as over the years as Linux has

00:07:52,000 --> 00:07:55,360
undergone incremental improvements this

00:07:54,430 --> 00:07:57,729
unicorn when

00:07:55,360 --> 00:07:59,650
it will be part of Linux codebase of the

00:07:57,729 --> 00:08:03,490
GMC codebase it will also undergo

00:07:59,650 --> 00:08:05,020
incremental optimizations and also since

00:08:03,490 --> 00:08:06,639
this is a huge community they will keep

00:08:05,020 --> 00:08:10,000
maintaining this unique kernel as part

00:08:06,639 --> 00:08:12,159
of the linux and z Lipsy codebase what

00:08:10,000 --> 00:08:14,560
are the advantages for it first of all

00:08:12,159 --> 00:08:16,389
we don't have to reinvent the wheel we

00:08:14,560 --> 00:08:19,719
can just simply use the entire in xcode

00:08:16,389 --> 00:08:22,479
base which means that we have unchanged

00:08:19,719 --> 00:08:25,419
API for developers and for legacy

00:08:22,479 --> 00:08:27,520
applications and we can support all the

00:08:25,419 --> 00:08:29,439
different device drivers file systems

00:08:27,520 --> 00:08:31,569
which results in a unique NL which can

00:08:29,439 --> 00:08:34,120
run in virtual machine as well as on

00:08:31,569 --> 00:08:36,039
their metal that's an important thing so

00:08:34,120 --> 00:08:39,219
imagine with all this if this were true

00:08:36,039 --> 00:08:41,769
if we could do this imagine a unique

00:08:39,219 --> 00:08:46,870
kernel with GPU support how cool would

00:08:41,769 --> 00:08:49,089
that be right so now the big question

00:08:46,870 --> 00:08:49,620
the big elephant in the room is it even

00:08:49,089 --> 00:08:52,360
possible

00:08:49,620 --> 00:08:54,790
so yes over the summer we built such an

00:08:52,360 --> 00:08:56,589
unique island which is which is based on

00:08:54,790 --> 00:08:59,649
Linux what I'm going to show you is that

00:08:56,589 --> 00:09:04,360
feeling kernel booting up we have a

00:08:59,649 --> 00:09:07,750
simple TCP server running on it so as

00:09:04,360 --> 00:09:10,240
soon as I can figure it out so you will

00:09:07,750 --> 00:09:14,260
see the kernel booting up and then

00:09:10,240 --> 00:09:16,390
you'll see the server come up so if you

00:09:14,260 --> 00:09:17,949
can all see this is this is what we've

00:09:16,390 --> 00:09:19,870
done over the summer a unicorn and on

00:09:17,949 --> 00:09:23,350
Linux which runs a simple server and it

00:09:19,870 --> 00:09:25,240
works now what we'll discuss is what

00:09:23,350 --> 00:09:26,230
were the goals for this project and how

00:09:25,240 --> 00:09:28,870
did we actually do it

00:09:26,230 --> 00:09:31,209
goals these are based on pretty much

00:09:28,870 --> 00:09:32,949
what I have discussed before we want

00:09:31,209 --> 00:09:35,470
upstream acceptance we've got something

00:09:32,949 --> 00:09:37,360
which we want to make as little changes

00:09:35,470 --> 00:09:39,430
to the Linux codebase and the G Lib C

00:09:37,360 --> 00:09:40,870
code as possible so then we have a

00:09:39,430 --> 00:09:43,930
higher chance of this getting accepted

00:09:40,870 --> 00:09:46,750
upstream we want an unchanged in its API

00:09:43,930 --> 00:09:48,870
we want this unique kernel to be

00:09:46,750 --> 00:09:52,390
deployed on to be able to deploy it on

00:09:48,870 --> 00:09:53,410
virtual machines and bare metal and we

00:09:52,390 --> 00:09:56,649
want unique colors which are

00:09:53,410 --> 00:09:58,690
applications specific now talking about

00:09:56,649 --> 00:10:00,250
the architecture this is a normal and

00:09:58,690 --> 00:10:01,370
excited it you know how the normal next

00:10:00,250 --> 00:10:03,320
looks like this

00:10:01,370 --> 00:10:05,510
user space this applications using

00:10:03,320 --> 00:10:06,860
libraries than the C library normally

00:10:05,510 --> 00:10:08,390
what happens is that the application

00:10:06,860 --> 00:10:10,570
makes function calls in the C library

00:10:08,390 --> 00:10:13,130
and function calls into user might be

00:10:10,570 --> 00:10:16,400
user library then makes function calls

00:10:13,130 --> 00:10:19,160
into the C library and normally it is

00:10:16,400 --> 00:10:21,380
the C library which then makes system

00:10:19,160 --> 00:10:22,910
calls into the next kernel now since

00:10:21,380 --> 00:10:26,420
this is a unique owner we don't want

00:10:22,910 --> 00:10:29,270
this system call functionality what we

00:10:26,420 --> 00:10:32,300
have in its place is a very small you

00:10:29,270 --> 00:10:34,970
can library and what that does is simply

00:10:32,300 --> 00:10:36,350
see library makes function calls not

00:10:34,970 --> 00:10:38,360
system calls function calls into the

00:10:36,350 --> 00:10:40,540
Selah into the UK library which then

00:10:38,360 --> 00:10:44,990
calls appropriate code in the kernel and

00:10:40,540 --> 00:10:49,610
all of this together is our Linux base

00:10:44,990 --> 00:10:52,940
unit up and when we compile it this all

00:10:49,610 --> 00:10:54,290
becomes one big binary there's no

00:10:52,940 --> 00:10:55,670
separation between different libraries

00:10:54,290 --> 00:10:59,420
different address spaces this is just

00:10:55,670 --> 00:11:01,400
one thing which runs on hardware now

00:10:59,420 --> 00:11:03,920
this is what we've done currently this

00:11:01,400 --> 00:11:05,959
is what this is where we are now but in

00:11:03,920 --> 00:11:08,209
the future what we want is we don't want

00:11:05,959 --> 00:11:09,950
this UK liability to be there we want

00:11:08,209 --> 00:11:11,630
some of its functionality to be part of

00:11:09,950 --> 00:11:13,070
the C library and some of its

00:11:11,630 --> 00:11:15,410
functionality to be part of the next

00:11:13,070 --> 00:11:17,330
kernel and this is what we want are

00:11:15,410 --> 00:11:21,110
finally in the next base unit kernel to

00:11:17,330 --> 00:11:24,650
look like so here are some of the

00:11:21,110 --> 00:11:26,779
implementation details so this might

00:11:24,650 --> 00:11:28,339
look like that in order to build this

00:11:26,779 --> 00:11:30,110
unique kernel based on Linux we had to

00:11:28,339 --> 00:11:32,750
do so many different changes to the next

00:11:30,110 --> 00:11:36,709
codebase the gilepsy but that is not the

00:11:32,750 --> 00:11:41,029
case here we have the main dot C file

00:11:36,709 --> 00:11:43,459
from the Linux Linux tree in it just

00:11:41,029 --> 00:11:45,740
before the user space has started we add

00:11:43,459 --> 00:11:47,570
our own function the came in which comes

00:11:45,740 --> 00:11:49,670
from the application so just before the

00:11:47,570 --> 00:11:53,120
user space is started we call our own

00:11:49,670 --> 00:11:55,370
function this came in now this is some

00:11:53,120 --> 00:11:57,459
application code this came in as you can

00:11:55,370 --> 00:11:59,690
see is provided by the application

00:11:57,459 --> 00:12:01,130
continuing with the example of the PCP

00:11:59,690 --> 00:12:03,529
server that we discussed earlier that I

00:12:01,130 --> 00:12:06,430
showed you booting up this is simple TCP

00:12:03,529 --> 00:12:08,770
server code as you can see the head

00:12:06,430 --> 00:12:11,529
are same as what any application headers

00:12:08,770 --> 00:12:15,370
might look like the main thing is the

00:12:11,529 --> 00:12:17,620
initializations code now normally the

00:12:15,370 --> 00:12:19,830
initializations are done by system D but

00:12:17,620 --> 00:12:22,360
in our case we have to do them ourselves

00:12:19,830 --> 00:12:24,820
in the initialization code will run

00:12:22,360 --> 00:12:27,330
before the application code will run and

00:12:24,820 --> 00:12:30,339
it will do the application specific

00:12:27,330 --> 00:12:32,040
initializations in our case we are

00:12:30,339 --> 00:12:36,430
bringing up the network interface in

00:12:32,040 --> 00:12:39,399
this TCP server example so that cause

00:12:36,430 --> 00:12:40,930
book code goes in initialization after

00:12:39,399 --> 00:12:44,110
that the rest of the code remains same

00:12:40,930 --> 00:12:45,760
and an interesting thing you look at the

00:12:44,110 --> 00:12:48,760
bottom is that this function does not

00:12:45,760 --> 00:12:50,790
return because this is just one process

00:12:48,760 --> 00:12:53,500
in the curl right now if this returns

00:12:50,790 --> 00:12:55,180
then the kernel will be rendered

00:12:53,500 --> 00:12:59,950
unusable so this function does not

00:12:55,180 --> 00:13:02,529
return now coming on to how we compile

00:12:59,950 --> 00:13:04,750
and build this and run this as compared

00:13:02,529 --> 00:13:06,790
to how you compile and build a normal

00:13:04,750 --> 00:13:09,279
application what we are doing with in in

00:13:06,790 --> 00:13:10,270
our cases we are compiling the user

00:13:09,279 --> 00:13:13,180
application code

00:13:10,270 --> 00:13:15,220
we're also compiling the GPL library and

00:13:13,180 --> 00:13:18,040
we are packaging both of them together

00:13:15,220 --> 00:13:20,470
into a you cannot a and archive after

00:13:18,040 --> 00:13:21,970
that after making an archive what we're

00:13:20,470 --> 00:13:23,980
doing is we borrowing a lot of

00:13:21,970 --> 00:13:26,589
functionality from the Linux kernel

00:13:23,980 --> 00:13:28,900
build process so while we are making the

00:13:26,589 --> 00:13:32,050
colonel in the linking phase we add our

00:13:28,900 --> 00:13:34,390
upl dot a or RI so it gets linked at

00:13:32,050 --> 00:13:37,060
length time when that becomes one binary

00:13:34,390 --> 00:13:40,209
which can then deployed right now we are

00:13:37,060 --> 00:13:42,310
testing it on Q mu so the the video that

00:13:40,209 --> 00:13:45,970
I showed you was this same they sent

00:13:42,310 --> 00:13:50,200
this unit kernel running on Q mu in the

00:13:45,970 --> 00:13:52,870
future what we want is we just want to

00:13:50,200 --> 00:13:55,089
call make on a user application we just

00:13:52,870 --> 00:13:57,700
want to say okay use this compiler UK

00:13:55,089 --> 00:13:59,290
GCC compiler and that's it you run make

00:13:57,700 --> 00:14:00,410
on your application and it should give

00:13:59,290 --> 00:14:02,210
you a UNIX kernel with

00:14:00,410 --> 00:14:04,040
can then be deployed on bare metal on

00:14:02,210 --> 00:14:08,870
virtual machine or on some emulator like

00:14:04,040 --> 00:14:10,490
2mv so there were a lot of positive

00:14:08,870 --> 00:14:13,130
outcomes over the summer things that we

00:14:10,490 --> 00:14:16,490
can build on for example we just added

00:14:13,130 --> 00:14:18,050
one line to the Linux codebase the G Lib

00:14:16,490 --> 00:14:20,390
C code the redirection code which

00:14:18,050 --> 00:14:22,190
instead of making the sister system

00:14:20,390 --> 00:14:24,470
calls in the kernel which does function

00:14:22,190 --> 00:14:27,620
calls into the yuqian library that is in

00:14:24,470 --> 00:14:31,340
a separate sub tree if you had remained

00:14:27,620 --> 00:14:33,470
unchanged and because of all this most

00:14:31,340 --> 00:14:35,450
of the user libraries will not have to

00:14:33,470 --> 00:14:38,240
be really compiled for Jenny kernel for

00:14:35,450 --> 00:14:40,100
our unique field the ones which do make

00:14:38,240 --> 00:14:41,930
direct system calls we just need to

00:14:40,100 --> 00:14:44,450
change the name of the function and they

00:14:41,930 --> 00:14:47,390
can also be used with organic rhythm so

00:14:44,450 --> 00:14:49,670
we believe that with these modest

00:14:47,390 --> 00:14:53,870
changes our chances of getting accepted

00:14:49,670 --> 00:14:56,300
upstream eventually are very high so

00:14:53,870 --> 00:14:58,490
what are the next steps there's lots to

00:14:56,300 --> 00:15:00,560
do first of all as I said we need to

00:14:58,490 --> 00:15:02,630
take a take care of the initializations

00:15:00,560 --> 00:15:04,370
that are normally done by System D so

00:15:02,630 --> 00:15:06,470
whenever an application code runs before

00:15:04,370 --> 00:15:08,590
that we have application specific

00:15:06,470 --> 00:15:11,360
nationalizations that run

00:15:08,590 --> 00:15:13,070
also we need config options so that user

00:15:11,360 --> 00:15:15,170
based on their application can tell okay

00:15:13,070 --> 00:15:16,370
this is these are the things that I need

00:15:15,170 --> 00:15:18,320
this is their turn on these

00:15:16,370 --> 00:15:19,850
dysfunctionality and not this turn off

00:15:18,320 --> 00:15:22,970
this based on what the plication needs

00:15:19,850 --> 00:15:25,010
and does not mean so that Arjuna kernel

00:15:22,970 --> 00:15:28,520
is extremely application specific trim

00:15:25,010 --> 00:15:31,610
down we want support for P threads and

00:15:28,520 --> 00:15:32,990
C++ also we need to clean up everything

00:15:31,610 --> 00:15:34,700
as I showed you earlier it--how we're

00:15:32,990 --> 00:15:36,560
borrowing a lot from the Linux build

00:15:34,700 --> 00:15:39,110
process we want to clean this up in it

00:15:36,560 --> 00:15:41,990
so in a nice and pretty way that this

00:15:39,110 --> 00:15:44,750
can be finally accepted upstream also we

00:15:41,990 --> 00:15:46,490
want final of automatic optimization so

00:15:44,750 --> 00:15:48,710
that instead of users telling us that

00:15:46,490 --> 00:15:51,470
this is what the application needs we

00:15:48,710 --> 00:15:53,390
can just look at the code and only

00:15:51,470 --> 00:15:56,270
include those things that are needed by

00:15:53,390 --> 00:15:59,380
that application so this I think I have

00:15:56,270 --> 00:16:03,970
my work cut out for my PhD

00:15:59,380 --> 00:16:05,490
so based on what we've done and what we

00:16:03,970 --> 00:16:07,570
plan to do there are a lot of

00:16:05,490 --> 00:16:08,970
interesting research questions and

00:16:07,570 --> 00:16:11,980
interesting questions that we can ask

00:16:08,970 --> 00:16:14,560
for example what are the performance and

00:16:11,980 --> 00:16:16,750
start time benefits that we can get for

00:16:14,560 --> 00:16:18,610
example if we don't do any optimizations

00:16:16,750 --> 00:16:21,220
at all just run it as it is

00:16:18,610 --> 00:16:23,260
what is the benefit the performance and

00:16:21,220 --> 00:16:25,720
start time benefit that we can get as

00:16:23,260 --> 00:16:28,360
compared to simple Linux kernels if you

00:16:25,720 --> 00:16:30,820
only do link time optimizations what are

00:16:28,360 --> 00:16:34,240
the benefits that we get then and also

00:16:30,820 --> 00:16:36,070
after that building on what a lot of

00:16:34,240 --> 00:16:39,090
other research unique kernels have done

00:16:36,070 --> 00:16:42,580
for example customized board paths and

00:16:39,090 --> 00:16:44,440
preemptable thread sorry non preemptable

00:16:42,580 --> 00:16:46,600
threads things like that how can we get

00:16:44,440 --> 00:16:48,490
those optimizations into our unique

00:16:46,600 --> 00:16:54,220
kernel and then see what are the

00:16:48,490 --> 00:16:56,110
benefits that we can get also once we

00:16:54,220 --> 00:16:58,690
add all those up keep adding all those

00:16:56,110 --> 00:17:01,330
optimizations to our to our unique r''l

00:16:58,690 --> 00:17:03,370
can we still keep the changes to a

00:17:01,330 --> 00:17:07,150
minimum so that this can still be

00:17:03,370 --> 00:17:10,120
acceptable upstream and also this unique

00:17:07,150 --> 00:17:13,000
kernel model how can we you know get

00:17:10,120 --> 00:17:15,430
benefit off its security guarantees that

00:17:13,000 --> 00:17:17,920
it can give us and we want to look at

00:17:15,430 --> 00:17:19,810
the performance and security benefits

00:17:17,920 --> 00:17:22,240
with all the different use cases that

00:17:19,810 --> 00:17:25,180
are in use today for example normal

00:17:22,240 --> 00:17:27,310
cloud workloads memcache D how can we

00:17:25,180 --> 00:17:30,700
improve the performance of memcache D

00:17:27,310 --> 00:17:33,850
and give better security guarantees how

00:17:30,700 --> 00:17:37,360
can faster boot times help functions as

00:17:33,850 --> 00:17:39,310
a service can we explore these benefits

00:17:37,360 --> 00:17:41,680
in other use cases for example HPC and

00:17:39,310 --> 00:17:43,720
embedded systems and also for example

00:17:41,680 --> 00:17:45,130
the self storage if there is an

00:17:43,720 --> 00:17:47,800
application which is extremely i/o

00:17:45,130 --> 00:17:51,280
intensive what can we do to optimize

00:17:47,800 --> 00:17:54,160
that in order to use this here so yes as

00:17:51,280 --> 00:17:55,420
I said based on what we did and what we

00:17:54,160 --> 00:17:56,830
are going to do this

00:17:55,420 --> 00:18:00,580
there are a lot of interesting questions

00:17:56,830 --> 00:18:04,960
that are out there and we'll be looking

00:18:00,580 --> 00:18:07,180
at them and now I'll ask Cooley to give

00:18:04,960 --> 00:18:12,400
his comments and his input and where

00:18:07,180 --> 00:18:15,400
this project is going should be back on

00:18:12,400 --> 00:18:17,380
yet okay so hopefully you're a little

00:18:15,400 --> 00:18:19,390
bit more excited about the topic than

00:18:17,380 --> 00:18:20,860
before you didn't know anything about it

00:18:19,390 --> 00:18:23,140
before now it should be a little bit

00:18:20,860 --> 00:18:25,120
more excited so the main benefit is that

00:18:23,140 --> 00:18:27,370
we don't have to change much code

00:18:25,120 --> 00:18:29,530
so that is makes it this is a

00:18:27,370 --> 00:18:31,750
prerequisite for record actually using

00:18:29,530 --> 00:18:33,310
this in some future so if we actually

00:18:31,750 --> 00:18:36,640
get to the point that we can't do this

00:18:33,310 --> 00:18:39,280
we have to just recompile the kernel and

00:18:36,640 --> 00:18:41,920
some of the low-level libraries with a

00:18:39,280 --> 00:18:45,670
special option and we get it should be

00:18:41,920 --> 00:18:48,670
usable in a unique color so the you saw

00:18:45,670 --> 00:18:51,550
a couple of slides back there which we

00:18:48,670 --> 00:18:53,230
call in the moment UK LG C's however we

00:18:51,550 --> 00:18:55,300
are going to call this in the future is

00:18:53,230 --> 00:18:57,430
it remains to be seen when the goal is

00:18:55,300 --> 00:18:59,410
really that the process the only thing

00:18:57,430 --> 00:19:01,870
which a program has to change is to

00:18:59,410 --> 00:19:04,150
change use a different compiler so we

00:19:01,870 --> 00:19:06,610
will have to get from the kernel good

00:19:04,150 --> 00:19:09,730
process all the code which makes up the

00:19:06,610 --> 00:19:13,450
kernel normally as an archive that's the

00:19:09,730 --> 00:19:15,340
part we can get the startup code some of

00:19:13,450 --> 00:19:16,870
it they have to be dynamically generated

00:19:15,340 --> 00:19:18,610
when the program comes up based on the

00:19:16,870 --> 00:19:21,750
configuration of the program the user is

00:19:18,610 --> 00:19:25,000
providing then the user code C by itself

00:19:21,750 --> 00:19:27,640
plus perhaps some third-party archives

00:19:25,000 --> 00:19:29,320
of some sort and as Ali mentioned we

00:19:27,640 --> 00:19:31,120
don't even have to recompile them in

00:19:29,320 --> 00:19:34,240
many cases if these archives are not

00:19:31,120 --> 00:19:36,610
doing any system calls the ABI hasn't

00:19:34,240 --> 00:19:38,500
changed and we can just reuse them so

00:19:36,610 --> 00:19:40,780
all of this kept linked together we have

00:19:38,500 --> 00:19:42,940
something which can boot then regardless

00:19:40,780 --> 00:19:44,560
of what it is and what it is running so

00:19:42,940 --> 00:19:46,600
parts of the work which have to do as

00:19:44,560 --> 00:19:48,340
well is make this more generic so we

00:19:46,600 --> 00:19:50,860
might have to add initialization things

00:19:48,340 --> 00:19:52,360
like DHCP server clients et cetera these

00:19:50,860 --> 00:19:54,940
kind of things but we know about this

00:19:52,360 --> 00:19:56,470
and we're on the track to do that so

00:19:54,940 --> 00:19:58,030
what you see here on the slides for

00:19:56,470 --> 00:20:01,010
instance is something which is a little

00:19:58,030 --> 00:20:03,380
bit alien to me so this is not my world

00:20:01,010 --> 00:20:05,120
like function as a service so I talked

00:20:03,380 --> 00:20:07,160
with Oren about this and he said oh yeah

00:20:05,120 --> 00:20:09,020
no problem we can port in a JVM on top

00:20:07,160 --> 00:20:12,440
of Munich only a couple of days because

00:20:09,020 --> 00:20:19,370
he has done that in the past so I'm

00:20:12,440 --> 00:20:21,500
looking forward to that so okay so not

00:20:19,370 --> 00:20:23,960
yet some Python on that is very much so

00:20:21,500 --> 00:20:28,010
for those anyone you know I'm micro

00:20:23,960 --> 00:20:30,530
Python so micro piping is Python

00:20:28,010 --> 00:20:32,540
implementation for microcontrollers so I

00:20:30,530 --> 00:20:34,640
want to have this basically a normal

00:20:32,540 --> 00:20:36,380
pattern in the unit kernel which is the

00:20:34,640 --> 00:20:39,140
equivalent that form our larger machines

00:20:36,380 --> 00:20:41,270
which just can do that and there's a

00:20:39,140 --> 00:20:43,400
lease and this has implications not only

00:20:41,270 --> 00:20:45,380
for for performance it also means that

00:20:43,400 --> 00:20:47,030
some of the attacks which might exist

00:20:45,380 --> 00:20:48,260
out there will have no effect because of

00:20:47,030 --> 00:20:51,050
the seventy's programs looking

00:20:48,260 --> 00:20:52,280
completely different so but the function

00:20:51,050 --> 00:20:54,590
as a service the main thing so back to

00:20:52,280 --> 00:20:58,190
that kind of thing for functional

00:20:54,590 --> 00:21:01,880
service the main draw is that you don't

00:20:58,190 --> 00:21:05,420
waste running the code if if there's no

00:21:01,880 --> 00:21:07,670
user around so you only spin up the code

00:21:05,420 --> 00:21:12,770
when it is necessary and for this to be

00:21:07,670 --> 00:21:14,990
useful the hysteresis of the after

00:21:12,770 --> 00:21:16,340
control system which decides when you

00:21:14,990 --> 00:21:18,200
shut down the process and when you

00:21:16,340 --> 00:21:20,270
started up again has to be as narrow as

00:21:18,200 --> 00:21:22,670
possible to be efficient as possible and

00:21:20,270 --> 00:21:24,950
the first the startup time is of the

00:21:22,670 --> 00:21:26,390
process the narrow you can make it the

00:21:24,950 --> 00:21:29,360
more energy conceived even less

00:21:26,390 --> 00:21:32,090
resources you're using normal cow boots

00:21:29,360 --> 00:21:34,640
up if you tuned it you can cut it down

00:21:32,090 --> 00:21:38,180
to let's say 30 seconds this thing we

00:21:34,640 --> 00:21:40,190
can perhaps put up in a millisecond so

00:21:38,180 --> 00:21:41,090
it's much more efficient than that we

00:21:40,190 --> 00:21:43,160
can just kill it

00:21:41,090 --> 00:21:46,700
and bring it up back up again and have

00:21:43,160 --> 00:21:49,220
the same function running again so I

00:21:46,700 --> 00:21:51,860
think this this and the other part which

00:21:49,220 --> 00:21:54,440
I wanna mention as well so in my life my

00:21:51,860 --> 00:21:56,420
career here I'm mostly interested not in

00:21:54,440 --> 00:21:58,400
in Java services and these kind of

00:21:56,420 --> 00:22:00,200
things I'm mostly interested in high

00:21:58,400 --> 00:22:00,530
performance low latency computing et

00:22:00,200 --> 00:22:02,480
cetera

00:22:00,530 --> 00:22:04,820
among the master machine learning now

00:22:02,480 --> 00:22:08,780
which is just high performance computing

00:22:04,820 --> 00:22:11,480
and what has been bothering the HPC

00:22:08,780 --> 00:22:12,890
community at the very least for

00:22:11,480 --> 00:22:15,020
long time is that they don't have

00:22:12,890 --> 00:22:17,240
control over the machine as much as they

00:22:15,020 --> 00:22:19,460
want so they are doing things like core

00:22:17,240 --> 00:22:20,840
isolation now and moving interrupts a

00:22:19,460 --> 00:22:23,270
specific course and all these kind of

00:22:20,840 --> 00:22:25,850
things imagine if they are convening the

00:22:23,270 --> 00:22:28,160
application now say uni Colin have 100%

00:22:25,850 --> 00:22:35,840
control over how the different courses

00:22:28,160 --> 00:22:37,460
cetera use pins but even even in that

00:22:35,840 --> 00:22:39,320
use case you're still saying that this

00:22:37,460 --> 00:22:43,880
would have to be in vocable through

00:22:39,320 --> 00:22:46,430
something like qmu or otherwise could be

00:22:43,880 --> 00:22:48,290
but so even in the HPC cluster and

00:22:46,430 --> 00:22:53,990
functions as a service the thing would

00:22:48,290 --> 00:22:55,730
be running likely as non-root like yeah

00:22:53,990 --> 00:22:57,230
fraction is a service yes you would run

00:22:55,730 --> 00:23:00,170
this never in the container virtual

00:22:57,230 --> 00:23:02,810
machine bring this up there so this can

00:23:00,170 --> 00:23:04,820
boot on naked hardware it can boot on a

00:23:02,810 --> 00:23:06,890
virtual machines you don't need qmo

00:23:04,820 --> 00:23:10,190
under this tumor it's just for the

00:23:06,890 --> 00:23:12,710
development this is this just like a

00:23:10,190 --> 00:23:15,560
normal Linux kernel which you would have

00:23:12,710 --> 00:23:19,340
instead it doesn't spawn a PID one it

00:23:15,560 --> 00:23:21,050
does the work internally that's the only

00:23:19,340 --> 00:23:22,940
difference so this is what so what Ali

00:23:21,050 --> 00:23:25,910
showed there on the slide so in addy the

00:23:22,940 --> 00:23:28,910
exit fee is the one which spawns in it

00:23:25,910 --> 00:23:31,820
the PID one we took this out we run the

00:23:28,910 --> 00:23:34,160
code directly so this is actual code

00:23:31,820 --> 00:23:37,520
which can boot on the page my metal of

00:23:34,160 --> 00:23:39,230
virtual machines so of infrastruc ture

00:23:37,520 --> 00:23:41,410
points first of all I never said two

00:23:39,230 --> 00:23:41,410
days

00:23:41,600 --> 00:23:45,690
one thing I just want to emphasize here

00:23:43,950 --> 00:23:47,850
that it's been said that just is really

00:23:45,690 --> 00:23:51,420
important to me is that you know there's

00:23:47,850 --> 00:23:53,130
all this work going on now because we're

00:23:51,420 --> 00:23:57,090
dealing with a really high speed devices

00:23:53,130 --> 00:23:58,980
and SSDs and networks are going up 200

00:23:57,090 --> 00:24:01,440
megabits and people are moody using DP D

00:23:58,980 --> 00:24:03,450
K and s P D K and doing things in user

00:24:01,440 --> 00:24:06,630
level and bypassing the operating system

00:24:03,450 --> 00:24:08,100
and you know this approach gives you a

00:24:06,630 --> 00:24:09,600
totally different alternative way of

00:24:08,100 --> 00:24:12,450
addressing these problems you know

00:24:09,600 --> 00:24:14,760
hugely less complexity to recompile your

00:24:12,450 --> 00:24:16,200
program in this way have a part of the

00:24:14,760 --> 00:24:17,880
kernel and then we can start seeing

00:24:16,200 --> 00:24:19,650
incrementally how to get rid of copies

00:24:17,880 --> 00:24:21,450
and things like that so I think it's

00:24:19,650 --> 00:24:23,130
gonna be a much much more efficient way

00:24:21,450 --> 00:24:24,780
and the second thing is that because the

00:24:23,130 --> 00:24:25,200
application and the kernel are bundled

00:24:24,780 --> 00:24:27,510
together

00:24:25,200 --> 00:24:29,010
it's an encapsulated object so you can

00:24:27,510 --> 00:24:30,930
snapshot this thing you can move this

00:24:29,010 --> 00:24:32,880
state around you can replicate it and so

00:24:30,930 --> 00:24:34,440
it becomes a manageable object and much

00:24:32,880 --> 00:24:35,910
easier way than what we have today and

00:24:34,440 --> 00:24:39,560
that's what these guys are actually

00:24:35,910 --> 00:24:39,560
looking at with function service

00:24:41,290 --> 00:24:46,400
one question we are on like security in

00:24:44,270 --> 00:24:48,410
this way when you go to compile it do

00:24:46,400 --> 00:24:49,730
you only pull in the pieces of the Linux

00:24:48,410 --> 00:24:51,320
kernel that you care about so like for

00:24:49,730 --> 00:24:54,140
example file system drivers blah blah

00:24:51,320 --> 00:24:56,090
blah etc yeah so that's the best to go

00:24:54,140 --> 00:24:59,360
so for the time being so Holly mentioned

00:24:56,090 --> 00:25:02,960
that we are going to work this based on

00:24:59,360 --> 00:25:05,419
conflict options but later on so there's

00:25:02,960 --> 00:25:07,520
a mention of link time optimization so

00:25:05,419 --> 00:25:09,530
in this half in the compiler we actually

00:25:07,520 --> 00:25:11,570
know a lot about global information

00:25:09,530 --> 00:25:14,570
about the code we have because we see

00:25:11,570 --> 00:25:16,970
all the code so if everything is

00:25:14,570 --> 00:25:18,230
compiled with LTO enables we actually

00:25:16,970 --> 00:25:19,760
not only have to source with the binary

00:25:18,230 --> 00:25:21,440
code runs on we have all the meta

00:25:19,760 --> 00:25:23,210
information still available there you

00:25:21,440 --> 00:25:24,559
can run an information discovery based

00:25:23,210 --> 00:25:26,270
on that and then find out oh yeah

00:25:24,559 --> 00:25:28,130
there's never going to be a part system

00:25:26,270 --> 00:25:31,640
access so we compile this out there's

00:25:28,130 --> 00:25:34,250
never going to be a CCP SSDP

00:25:31,640 --> 00:25:38,570
protocol we compile that out we never

00:25:34,250 --> 00:25:40,549
have TCP compile that out so imagine how

00:25:38,570 --> 00:25:45,260
small the attack surface all of this

00:25:40,549 --> 00:25:47,299
happen becomes so you said that there is

00:25:45,260 --> 00:25:49,820
gonna be little changes needed for the

00:25:47,299 --> 00:25:51,700
user space or the kernel program but

00:25:49,820 --> 00:25:53,809
just curious if there's any sort of

00:25:51,700 --> 00:25:56,150
programming constructs that would be

00:25:53,809 --> 00:25:58,100
encouraged such as avoiding floating

00:25:56,150 --> 00:26:02,540
point or mutexes and semaphores and the

00:25:58,100 --> 00:26:05,390
like yeah and if you own so the the

00:26:02,540 --> 00:26:10,070
thing is that the only thing which you

00:26:05,390 --> 00:26:14,900
cannot do is call form so this is the

00:26:10,070 --> 00:26:16,910
one process environment and everything

00:26:14,900 --> 00:26:19,040
else should work so we have our work cut

00:26:16,910 --> 00:26:22,280
out so part of the slides first that we

00:26:19,040 --> 00:26:23,630
have to enable TLS we have to enable c++

00:26:22,280 --> 00:26:25,850
initialization all these kind of things

00:26:23,630 --> 00:26:28,490
constructors this remains work to be

00:26:25,850 --> 00:26:29,049
done but we're expecting that we

00:26:28,490 --> 00:26:32,200
actually can

00:26:29,049 --> 00:26:35,830
after the API an API being 1% compatible

00:26:32,200 --> 00:26:37,629
to that whether this and the the mutex

00:26:35,830 --> 00:26:39,190
and so this in transition Parsons on so

00:26:37,629 --> 00:26:40,989
market with sweats we will support of

00:26:39,190 --> 00:26:42,730
course we have to support a distillation

00:26:40,989 --> 00:26:44,499
is using few taxes in the kernel

00:26:42,730 --> 00:26:45,850
internally is already using few taxes

00:26:44,499 --> 00:26:47,259
there is nothing in there the only thing

00:26:45,850 --> 00:26:49,960
is that instead of having the system

00:26:47,259 --> 00:26:55,450
call we are actually using function

00:26:49,960 --> 00:26:57,009
calls in internally yes okay I just had

00:26:55,450 --> 00:26:59,590
a quick question you talked about

00:26:57,009 --> 00:27:01,720
running Java and I see all kinds of

00:26:59,590 --> 00:27:03,940
alligators right if you have dynamic

00:27:01,720 --> 00:27:05,919
class loading then all of a sudden you

00:27:03,940 --> 00:27:09,669
weren't using a particular TCP and now

00:27:05,919 --> 00:27:11,590
you are so you know ahead of time we do

00:27:09,669 --> 00:27:13,509
you that's one of the limitations which

00:27:11,590 --> 00:27:16,570
you have there so we need to have not a

00:27:13,509 --> 00:27:18,100
JVM binary you need to have the archive

00:27:16,570 --> 00:27:20,710
which makes it up and everything is

00:27:18,100 --> 00:27:22,419
statically linked dynamic linking will

00:27:20,710 --> 00:27:24,190
not will not about at least not

00:27:22,419 --> 00:27:25,899
initially supported theoretically we

00:27:24,190 --> 00:27:28,419
could do this kind of things but then we

00:27:25,899 --> 00:27:30,669
would rely on not the whole program and

00:27:28,419 --> 00:27:32,440
another analysis to actually decide what

00:27:30,669 --> 00:27:37,239
to leave out or not and it will become a

00:27:32,440 --> 00:27:38,440
user configurable and the other one was

00:27:37,239 --> 00:27:40,359
you said you're limited to one thread

00:27:38,440 --> 00:27:42,700
right but you know one process one

00:27:40,359 --> 00:27:46,419
process so I can start up several GC

00:27:42,700 --> 00:27:49,059
threads and yeah another things okay big

00:27:46,419 --> 00:27:52,440
difference process post-exposure POSIX

00:27:49,059 --> 00:27:52,440
thread POSIX process

00:27:58,390 --> 00:28:03,170
so in other words just aren't all we

00:28:01,250 --> 00:28:07,690
needed this patent work in the past and

00:28:03,170 --> 00:28:07,690
despite I claimed he said today's work

00:28:08,200 --> 00:28:12,470
have there been in the upstream comments

00:28:10,730 --> 00:28:16,309
yet no we haven't passed this on to

00:28:12,470 --> 00:28:18,710
upstream right now so that as are they

00:28:16,309 --> 00:28:20,090
distracted so far the only real change

00:28:18,710 --> 00:28:21,440
in the Connelly is a single line of code

00:28:20,090 --> 00:28:23,090
which we have to do there there will be

00:28:21,440 --> 00:28:25,400
a little bit more is unquestionably

00:28:23,090 --> 00:28:26,840
there but we can isolate these kind of

00:28:25,400 --> 00:28:29,000
things we will have discussions with the

00:28:26,840 --> 00:28:30,830
folks so the C library part is even less

00:28:29,000 --> 00:28:32,929
controversial so after fixing a couple

00:28:30,830 --> 00:28:35,600
of parts in there only thing which I had

00:28:32,929 --> 00:28:38,000
to do is add some subtree to the source

00:28:35,600 --> 00:28:40,340
code and this hasn't has it's not

00:28:38,000 --> 00:28:44,510
attached by any other configuration so I

00:28:40,340 --> 00:28:46,790
see no objections do you have a link or

00:28:44,510 --> 00:28:49,490
a github link to that or not do you have

00:28:46,790 --> 00:28:51,679
a gig or it could help link to that not

00:28:49,490 --> 00:28:53,390
yet so this it's our privates in a

00:28:51,679 --> 00:28:57,620
moment but we are going to have this at

00:28:53,390 --> 00:29:01,240
some point soon we want to clean up a

00:28:57,620 --> 00:29:01,240
lot of the build process before we

00:29:09,720 --> 00:29:15,280
yes I really got into the server to work

00:29:13,510 --> 00:29:16,780
a couple of days ago so there were a

00:29:15,280 --> 00:29:22,059
couple of challenges and he had many

00:29:16,780 --> 00:29:24,640
papers to write Lanie's professors from

00:29:22,059 --> 00:29:26,230
a security perspective so if the

00:29:24,640 --> 00:29:28,750
application and the colonel are separate

00:29:26,230 --> 00:29:30,910
when the application is compromised and

00:29:28,750 --> 00:29:33,160
the attacker also has to find the fault

00:29:30,910 --> 00:29:34,450
in the kernel to also have control of

00:29:33,160 --> 00:29:36,880
the whole system but when you combine

00:29:34,450 --> 00:29:38,350
them all into the same memory space then

00:29:36,880 --> 00:29:40,360
when the applications compromised the

00:29:38,350 --> 00:29:42,610
whole system is now coming yes right

00:29:40,360 --> 00:29:44,679
so is that knowledge about the problem

00:29:42,610 --> 00:29:46,120
with compromising Economist's only that

00:29:44,679 --> 00:29:48,039
then you can use it to leverage

00:29:46,120 --> 00:29:49,900
compromising the other applications

00:29:48,039 --> 00:29:53,309
running on it but if there aren't a lot

00:29:49,900 --> 00:29:53,309

YouTube URL: https://www.youtube.com/watch?v=EZroQKMlXqQ


