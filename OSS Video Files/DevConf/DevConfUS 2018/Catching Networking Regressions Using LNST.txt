Title: Catching Networking Regressions Using LNST
Publication date: 2019-02-25
Playlist: DevConfUS 2018
Description: 
	The evolution of networking speed and technology is remarkably increasing. This brings up the need of continuous testing to detect issues when they first rise.
Linux Network Stack Test (LNST) is a powerful tool to test multiple topologies and protocols including virtualization, tunneling, security and much more.
In this presentation you will learn:
The LNST framework and its test topology.
How to setup an LNST test.
How to write an LNST test case via examples of existing test cases.
How to run/execute your LNST test.
Interpreting results and detect regressions.
Upstream activity.

At the end of the presentation you should be equipped with the knowledge of using this framework and writing tests to successfully catch networking regressions.
Captions: 
	00:00:02,900 --> 00:00:06,030
[Music]

00:00:15,390 --> 00:00:18,510
[Music]

00:00:27,119 --> 00:00:31,240
good afternoon ladies and gentlemen

00:00:29,200 --> 00:00:33,989
thank you for coming to the 1:40 session

00:00:31,240 --> 00:00:36,550
next up we have social cool Kearney

00:00:33,989 --> 00:00:39,730
engineering manager at redhead and a

00:00:36,550 --> 00:00:42,280
nice lovely um sorry for in this

00:00:39,730 --> 00:00:44,170
pronunciation who's a software engineer

00:00:42,280 --> 00:00:46,030
at Red Hat so they're going to be

00:00:44,170 --> 00:00:48,940
talking about caching Network

00:00:46,030 --> 00:00:53,440
regressions using LNS tees good luck

00:00:48,940 --> 00:00:55,269
guys thank you all right so I think I

00:00:53,440 --> 00:00:57,970
know some people in the audience but how

00:00:55,269 --> 00:01:03,790
many people are involved in networking

00:00:57,970 --> 00:01:05,460
development no how about CI CD like it's

00:01:03,790 --> 00:01:07,540
supposed to see I see it a little bit

00:01:05,460 --> 00:01:11,619
probably not okay so this one is

00:01:07,540 --> 00:01:12,250
basically walk you through a tool called

00:01:11,619 --> 00:01:14,020
an NST

00:01:12,250 --> 00:01:18,040
a framework called amnesty that you've

00:01:14,020 --> 00:01:20,320
developed and I worked in the networking

00:01:18,040 --> 00:01:24,610
group in the cat Red Hat in so does a

00:01:20,320 --> 00:01:26,619
nice and basically show you how this

00:01:24,610 --> 00:01:31,230
what does framework does and give

00:01:26,619 --> 00:01:34,210
examples so so here's like an agenda

00:01:31,230 --> 00:01:37,300
I'll basically first talk about why we

00:01:34,210 --> 00:01:38,770
did this framework and honesty why it

00:01:37,300 --> 00:01:42,060
was required for us in the networking

00:01:38,770 --> 00:01:44,440
team and then we will also talk about

00:01:42,060 --> 00:01:45,790
leading to that waters LNS genome

00:01:44,440 --> 00:01:48,220
whatever what is this capable of doing

00:01:45,790 --> 00:01:50,710
and then we'll give you an example of

00:01:48,220 --> 00:01:55,060
how you can set up a test or topology

00:01:50,710 --> 00:01:58,540
using audacity will show you how how it

00:01:55,060 --> 00:02:00,190
reports results and that you can

00:01:58,540 --> 00:02:03,700
interpret and use for it caching

00:02:00,190 --> 00:02:05,140
regressions and in the end I'll just

00:02:03,700 --> 00:02:09,929
tell you what's going on what's coming

00:02:05,140 --> 00:02:12,670
up in the future for honesty so so few

00:02:09,929 --> 00:02:15,940
some time ago there was an engineer and

00:02:12,670 --> 00:02:19,959
the networking group and he he started

00:02:15,940 --> 00:02:22,300
writing regression tests for bonding and

00:02:19,959 --> 00:02:23,920
then he soon found out that he had to

00:02:22,300 --> 00:02:25,780
redo a lot of things when he's had to

00:02:23,920 --> 00:02:27,290
start testing teaming for example this

00:02:25,780 --> 00:02:30,200
is completed

00:02:27,290 --> 00:02:33,110
so so that's where the need for like a

00:02:30,200 --> 00:02:34,880
framework kind of arose where it would

00:02:33,110 --> 00:02:38,600
be important to have like a universal

00:02:34,880 --> 00:02:41,570
framework for running networking tests

00:02:38,600 --> 00:02:43,640
that could be easily extendable and it

00:02:41,570 --> 00:02:46,370
could be like really consistent so that

00:02:43,640 --> 00:02:48,830
you can run them over releases or over

00:02:46,370 --> 00:02:52,010
cycles of Knightley's and then kind of

00:02:48,830 --> 00:02:53,210
compare results and see like you know if

00:02:52,010 --> 00:02:57,500
there was a regression somebody

00:02:53,210 --> 00:02:59,780
introduced regression it was also

00:02:57,500 --> 00:03:02,870
important to also make it easily

00:02:59,780 --> 00:03:04,100
extendable because you didn't want

00:03:02,870 --> 00:03:07,580
something which just I'd you could do

00:03:04,100 --> 00:03:10,100
scripting but it's really not extendable

00:03:07,580 --> 00:03:12,620
so we wanted left framework but people

00:03:10,100 --> 00:03:14,480
could add new functionality into it and

00:03:12,620 --> 00:03:16,370
run it and so that you could get newer

00:03:14,480 --> 00:03:18,770
and newer topologies as people adding

00:03:16,370 --> 00:03:23,720
more and more features or more and more

00:03:18,770 --> 00:03:25,400
functional items and there's something

00:03:23,720 --> 00:03:27,800
called test recipes which I need to talk

00:03:25,400 --> 00:03:29,510
about in a little bit but we also wanted

00:03:27,800 --> 00:03:33,760
to be like something that you could

00:03:29,510 --> 00:03:36,080
describe topology in and then so that

00:03:33,760 --> 00:03:38,690
this framework could run the topology

00:03:36,080 --> 00:03:42,260
and create the topology for you and run

00:03:38,690 --> 00:03:45,230
the test the reference of see ICD was

00:03:42,260 --> 00:03:48,110
another thing where we found out that at

00:03:45,230 --> 00:03:49,490
some point we found a bug that we could

00:03:48,110 --> 00:03:52,490
have caught it really early in the cycle

00:03:49,490 --> 00:03:54,110
of the development and and if we had

00:03:52,490 --> 00:03:58,130
something that we could test at a

00:03:54,110 --> 00:04:00,849
developer level for example then that

00:03:58,130 --> 00:04:02,920
would be great so the person

00:04:00,849 --> 00:04:05,650
could run it tests and catch inner

00:04:02,920 --> 00:04:08,379
regressions or the alumina C team had

00:04:05,650 --> 00:04:10,900
RedHat could also run it and tests and

00:04:08,379 --> 00:04:13,599
casual occasions much before then maybe

00:04:10,900 --> 00:04:15,219
towards really end of the ring so so

00:04:13,599 --> 00:04:18,099
that was also so these are some of the

00:04:15,219 --> 00:04:18,880
reasons why this framework came into

00:04:18,099 --> 00:04:21,489
being

00:04:18,880 --> 00:04:23,680
so the original engineer at Red Hat he

00:04:21,489 --> 00:04:26,530
started this Giri per cookie started

00:04:23,680 --> 00:04:28,660
this framework and then this the team

00:04:26,530 --> 00:04:31,449
attracted works and this whole thing is

00:04:28,660 --> 00:04:33,639
upstream and the front page had the gate

00:04:31,449 --> 00:04:37,840
rep own so you can go up and look at it

00:04:33,639 --> 00:04:39,759
and see how can that so I'll hand it

00:04:37,840 --> 00:04:46,199
over to a nice he's gonna run through a

00:04:39,759 --> 00:04:46,199
lot more than me thank you

00:04:46,289 --> 00:04:52,120
I've been with Red Hat for a little bit

00:04:49,990 --> 00:04:58,599
over four years and I've been using LSD

00:04:52,120 --> 00:05:01,560
since since then what is the MST it's an

00:04:58,599 --> 00:05:06,940
abstraction collection of programs that

00:05:01,560 --> 00:05:10,720
helped of course to each their work it's

00:05:06,940 --> 00:05:22,780
a tool written in Python that has set of

00:05:10,720 --> 00:05:27,400
tools and definitions it is an automatic

00:05:22,780 --> 00:05:30,400
testing we know developers as sushi I

00:05:27,400 --> 00:05:32,650
mentioned when the Jericho's want to do

00:05:30,400 --> 00:05:36,190
teaming and bonding he has to do a lot

00:05:32,650 --> 00:05:38,229
of stuff so automation helps in this in

00:05:36,190 --> 00:05:42,039
this way it helps eliminating the human

00:05:38,229 --> 00:05:44,590
error or human factor by using the same

00:05:42,039 --> 00:05:49,440
commands in a sequence sequential order

00:05:44,590 --> 00:05:53,500
over and over to keep the test test

00:05:49,440 --> 00:05:55,150
portability and you write it once and

00:05:53,500 --> 00:05:56,670
that idea is to use it multiple times

00:05:55,150 --> 00:05:59,270
it's not

00:05:56,670 --> 00:06:02,460
on any hardware or special hardware

00:05:59,270 --> 00:06:04,620
could be the hardwood that you tested on

00:06:02,460 --> 00:06:06,840
could be used by another developer for

00:06:04,620 --> 00:06:14,040
example and you need another hardware

00:06:06,840 --> 00:06:19,700
you just use the same test again the

00:06:14,040 --> 00:06:19,700
fact that it is abstract and portable

00:06:19,940 --> 00:06:27,660
extendable make it really easy to use

00:06:23,130 --> 00:06:34,470
and save time for we doing tests over

00:06:27,660 --> 00:06:36,800
and over or configuring tests over is

00:06:34,470 --> 00:06:36,800
working

00:06:38,150 --> 00:06:49,960
so what can Allen is did for you and it

00:06:46,040 --> 00:06:55,190
helps you set up your your your

00:06:49,960 --> 00:06:57,919
environment faster and easier and when I

00:06:55,190 --> 00:07:00,740
say it could be used by developers it

00:06:57,919 --> 00:07:05,000
could be used by hardware guys for more

00:07:00,740 --> 00:07:07,310
guys and you can test different

00:07:05,000 --> 00:07:10,639
topologies on the fly it has a library

00:07:07,310 --> 00:07:13,729
of tests pre-designed pre-configured and

00:07:10,639 --> 00:07:16,910
you can just pick what what tests you'd

00:07:13,729 --> 00:07:20,330
like to is it bonding teaming as it

00:07:16,910 --> 00:07:23,600
virtual guest to guest house is

00:07:20,330 --> 00:07:27,770
different on multiple variety of tests

00:07:23,600 --> 00:07:32,419
you can test the functionality you can

00:07:27,770 --> 00:07:39,669
test the throughput you can use other as

00:07:32,419 --> 00:07:39,669
on IPSec my nutsac is very extendable

00:07:39,910 --> 00:07:46,669
Huzur has a feature where if there is in

00:07:44,870 --> 00:07:50,300
your lab you should have a pool of

00:07:46,669 --> 00:07:53,389
machines and basically you tell ellen st

00:07:50,300 --> 00:07:54,620
what i want to test and an audacity will

00:07:53,389 --> 00:07:57,889
go check that pool and see what

00:07:54,620 --> 00:08:02,560
configuration is good for you and use

00:07:57,889 --> 00:08:06,620
those as the top machines it logs tests

00:08:02,560 --> 00:08:08,949
with timestamp for debugging in case you

00:08:06,620 --> 00:08:12,139
catch anything or it is something that

00:08:08,949 --> 00:08:15,289
annoys you you can always go to logs and

00:08:12,139 --> 00:08:17,680
has really detailed pops and the most

00:08:15,289 --> 00:08:21,440
important thing it cleans after itself

00:08:17,680 --> 00:08:25,099
once you run it it goes set up

00:08:21,440 --> 00:08:27,890
environment do the tests and once it's

00:08:25,099 --> 00:08:30,860
done it flushes the

00:08:27,890 --> 00:08:40,070
the next and return them to their

00:08:30,860 --> 00:08:45,260
original state this is a really just

00:08:40,070 --> 00:08:48,650
that simple overview this is how it's

00:08:45,260 --> 00:08:50,660
gonna look in our tests we use beaker

00:08:48,650 --> 00:08:53,210
it's an open source program that goes

00:08:50,660 --> 00:08:55,850
and controls the systems for us

00:08:53,210 --> 00:08:59,390
provisioning what kind of offer OS I

00:08:55,850 --> 00:09:01,600
would like to use its pluggable into

00:08:59,390 --> 00:09:05,480
Jenkins which is also an automated

00:09:01,600 --> 00:09:09,410
framework that's let's see you build a

00:09:05,480 --> 00:09:11,960
kernel it will kick in Jenkins will tell

00:09:09,410 --> 00:09:13,250
Victor okay the build is ready go

00:09:11,960 --> 00:09:16,430
install these machines with this

00:09:13,250 --> 00:09:19,520
Cardinal vicar will go to the machines

00:09:16,430 --> 00:09:25,250
and the Istana for you once it's done it

00:09:19,520 --> 00:09:27,290
will take the Ln st test this blue line

00:09:25,250 --> 00:09:29,450
and this green line are totally

00:09:27,290 --> 00:09:31,430
different networks this is the

00:09:29,450 --> 00:09:35,200
controlling our how english usage for

00:09:31,430 --> 00:09:38,480
how you BNC to your systems the green

00:09:35,200 --> 00:09:42,290
network is what where your test is going

00:09:38,480 --> 00:09:45,290
to be your your things or your TC or

00:09:42,290 --> 00:09:47,750
you're running either network well

00:09:45,290 --> 00:09:48,270
whatever happens to that you will be

00:09:47,750 --> 00:09:51,399
using

00:09:48,270 --> 00:09:51,399
[Music]

00:09:52,959 --> 00:10:02,740
so how easily Nesta sets itself up in a

00:09:56,950 --> 00:10:05,670
chronological order for sake of time we

00:10:02,740 --> 00:10:08,680
will assume that we have two systems

00:10:05,670 --> 00:10:18,579
that have already over always installing

00:10:08,680 --> 00:10:20,920
them which is Linux and and they have

00:10:18,579 --> 00:10:23,350
access to this machine through a neck

00:10:20,920 --> 00:10:25,269
that is not on this design I can SSS to

00:10:23,350 --> 00:10:28,029
them I can install whatever I want like

00:10:25,269 --> 00:10:29,829
rpms all that stuff and these two necks

00:10:28,029 --> 00:10:32,230
are the one that I'm going to be testing

00:10:29,829 --> 00:10:37,500
either for after an upgrade driver

00:10:32,230 --> 00:10:41,170
upgrade or a kernel upgrade or firmware

00:10:37,500 --> 00:10:45,550
then I'll install an MST on one of the

00:10:41,170 --> 00:10:47,170
machines they have slaves you can

00:10:45,550 --> 00:10:49,720
install them through the internal stall

00:10:47,170 --> 00:10:51,880
lmst slave and you only need one

00:10:49,720 --> 00:10:53,260
controller this controller you can you

00:10:51,880 --> 00:10:55,029
could be on your laptop we could even

00:10:53,260 --> 00:10:56,570
your desktop or you could be on one of

00:10:55,029 --> 00:10:58,680
the test machines

00:10:56,570 --> 00:11:02,610
[Music]

00:10:58,680 --> 00:11:05,860
once you click the MST it will go and

00:11:02,610 --> 00:11:07,570
find those two necks that we are trying

00:11:05,860 --> 00:11:12,130
to test in this case it's going to be a

00:11:07,570 --> 00:11:15,579
pond and it will configure with two

00:11:12,130 --> 00:11:20,290
slaves with a pond given IP address to

00:11:15,579 --> 00:11:23,110
your of your choice and after that it

00:11:20,290 --> 00:11:28,050
will run traffic is with the rate

00:11:23,110 --> 00:11:28,050
setting or is it throughput performance

00:11:33,120 --> 00:11:38,459
since I'm that the end it cleaners after

00:11:35,759 --> 00:11:41,189
it blocks it reports back to you it's

00:11:38,459 --> 00:11:46,709
fresh fresh machines that can afford for

00:11:41,189 --> 00:11:49,920
a new test if you want this is as simple

00:11:46,709 --> 00:11:53,699
as it can get and we're gonna go through

00:11:49,920 --> 00:11:56,069
how it gives the arena's T was built to

00:11:53,699 --> 00:11:58,529
machines with LNS theorists live on

00:11:56,069 --> 00:12:01,350
stolen them that the controller or wes

00:11:58,529 --> 00:12:03,689
is installed and this is the final test

00:12:01,350 --> 00:12:05,129
or the final look of matters that I want

00:12:03,689 --> 00:12:09,559
to test this connection right here

00:12:05,129 --> 00:12:09,559
either for functionality or for

00:12:09,980 --> 00:12:21,870
how does a Dennis t know this bye-bye we

00:12:16,019 --> 00:12:24,809
call it recipe recipe is an XML that has

00:12:21,870 --> 00:12:27,959
attributes and you tell with machines

00:12:24,809 --> 00:12:30,180
you're gonna be using machine one is one

00:12:27,959 --> 00:12:34,379
is also supposed to be a machine that

00:12:30,180 --> 00:12:36,959
XML in your directory or your lmst pool

00:12:34,379 --> 00:12:39,809
where all the machines that an NST knows

00:12:36,959 --> 00:12:45,779
about and you know has the MAC address

00:12:39,809 --> 00:12:49,259
and has the hostname or and format for

00:12:45,779 --> 00:12:53,160
this case we pick the Machine one has

00:12:49,259 --> 00:12:55,679
one Nick and this is the IP that I'll be

00:12:53,160 --> 00:12:57,569
using in the same XML there is machine

00:12:55,679 --> 00:12:59,850
too and these three dots Heather is just

00:12:57,569 --> 00:13:02,429
like copy-paste of the same just for the

00:12:59,850 --> 00:13:05,970
sake of space with what it different

00:13:02,429 --> 00:13:09,089
with that to Alan s you will read this

00:13:05,970 --> 00:13:11,699
XML and the time that is you wanna this

00:13:09,089 --> 00:13:14,040
task which will go into the same

00:13:11,699 --> 00:13:17,420
directory look for it right here this is

00:13:14,040 --> 00:13:22,050
as simple as you can get and ports

00:13:17,420 --> 00:13:25,559
modules libraries fine a variable and it

00:13:22,050 --> 00:13:29,279
will run this command pink one from this

00:13:25,559 --> 00:13:32,370
IP to this IP how do you run it just

00:13:29,279 --> 00:13:35,830
this command l NS t color control run

00:13:32,370 --> 00:13:40,810
recipe that XML and as I said there is a

00:13:35,830 --> 00:13:42,339
variety of options what recipe and there

00:13:40,810 --> 00:13:50,490
is there are all our streams and

00:13:42,339 --> 00:13:50,490
accessible just showing the example back

00:13:54,510 --> 00:14:01,000
next one please

00:13:57,269 --> 00:14:06,370
this is another example I want to test

00:14:01,000 --> 00:14:09,130
bonded versus Nick bear middle Nick

00:14:06,370 --> 00:14:11,890
same same thing like I did not change

00:14:09,130 --> 00:14:14,350
the US I did not remove this so I'm done

00:14:11,890 --> 00:14:17,620
with next to Nick this is my second test

00:14:14,350 --> 00:14:20,050
I wanna test I can't just do l NS t that

00:14:17,620 --> 00:14:23,490
couple run the receipt that has the

00:14:20,050 --> 00:14:26,190
bonding in it and it will do the same

00:14:23,490 --> 00:14:30,910
[Music]

00:14:26,190 --> 00:14:34,000
that XML for the bonding it's one single

00:14:30,910 --> 00:14:37,899
XML it just split same thing has machine

00:14:34,000 --> 00:14:40,180
one has two next in it and the driver

00:14:37,899 --> 00:14:42,190
for the next in case the machine has

00:14:40,180 --> 00:14:45,100
more than one neck with different

00:14:42,190 --> 00:14:50,230
drivers I can specify the driver to test

00:14:45,100 --> 00:14:52,120
and the bond the name is bond zero the

00:14:50,230 --> 00:14:55,930
type of it is active backup it will

00:14:52,120 --> 00:15:00,010
enslave th1 and th2 and it will assign

00:14:55,930 --> 00:15:03,459
IP address ipv4 or ipv6 or both at the

00:15:00,010 --> 00:15:06,360
same time and machine 2 is similar to

00:15:03,459 --> 00:15:09,430
machine one from the previous xml and

00:15:06,360 --> 00:15:11,770
once it makes this python tasks it will

00:15:09,430 --> 00:15:15,130
go to it it's a more complicated

00:15:11,770 --> 00:15:17,170
I don't code than the simple network or

00:15:15,130 --> 00:15:20,920
that the thing that we just showed

00:15:17,170 --> 00:15:23,589
earlier and it's available online on a

00:15:20,920 --> 00:15:26,020
we at the end I will post the the gates

00:15:23,589 --> 00:15:29,699
will you can find all the recipes and

00:15:26,020 --> 00:15:32,019
the XML that we use that the Python also

00:15:29,699 --> 00:15:34,690
yeah so essentially just to complete

00:15:32,019 --> 00:15:37,390
Sinisa start where you can see how this

00:15:34,690 --> 00:15:40,060
recipe is actually defining the topology

00:15:37,390 --> 00:15:41,649
that if you really want to test so you

00:15:40,060 --> 00:15:44,980
can customize it to polish the what you

00:15:41,649 --> 00:15:46,779
want and in provided there are these

00:15:44,980 --> 00:15:49,000
libraries that will run the tests for

00:15:46,779 --> 00:15:52,300
you that's perfect you can just run it

00:15:49,000 --> 00:15:54,430
if there isn't then we have to add a new

00:15:52,300 --> 00:16:00,089
library or modify an existing language

00:15:54,430 --> 00:16:04,660
to do this this is a more complex setup

00:16:00,089 --> 00:16:09,130
again two systems with OS London

00:16:04,660 --> 00:16:12,250
each system has two guests DM 1v m 2 v

00:16:09,130 --> 00:16:15,790
r3 v m4 has opened this switch

00:16:12,250 --> 00:16:17,680
running the network in internally one

00:16:15,790 --> 00:16:19,930
controller and if you notice there is a

00:16:17,680 --> 00:16:22,540
slave or onion on this hosts live on the

00:16:19,930 --> 00:16:24,819
second host slave on each VM those

00:16:22,540 --> 00:16:27,640
slaves are listening for instructions

00:16:24,819 --> 00:16:30,279
from the controller to what to do

00:16:27,640 --> 00:16:32,740
configure what type of topology or what

00:16:30,279 --> 00:16:36,459
what IP I'm testing ipv4 are conceived

00:16:32,740 --> 00:16:38,620
so the controller will submit the

00:16:36,459 --> 00:16:43,500
instructions and the slaves will just

00:16:38,620 --> 00:16:45,850
execute in our case we can access

00:16:43,500 --> 00:16:48,790
functionality test either think for

00:16:45,850 --> 00:16:52,930
example between VM one on this host to V

00:16:48,790 --> 00:16:55,120
and three eth0 on h vm is the controller

00:16:52,930 --> 00:16:58,240
this is how I can SSH to this machine e

00:16:55,120 --> 00:17:01,480
th one is that the neck bottom be

00:16:58,240 --> 00:17:03,070
testing this slave will configure the a

00:17:01,480 --> 00:17:07,420
th one within

00:17:03,070 --> 00:17:10,930
and this slave will attach eth1 to the

00:17:07,420 --> 00:17:13,329
switch the physical next to this switch

00:17:10,930 --> 00:17:17,620
with the bonding with an IP address here

00:17:13,329 --> 00:17:20,470
also same thing mirror will be done on

00:17:17,620 --> 00:17:24,370
this than P then VM one will try to

00:17:20,470 --> 00:17:25,209
think v m3 and everything the results

00:17:24,370 --> 00:17:28,960
will be in the log

00:17:25,209 --> 00:17:32,350
it will also think a VM one to think VM

00:17:28,960 --> 00:17:35,380
for which is on a different veena just

00:17:32,350 --> 00:17:37,960
to see if it passes or not in the past

00:17:35,380 --> 00:17:42,250
we cut we've got a regression where the

00:17:37,960 --> 00:17:46,450
demon was crossing border crossing the

00:17:42,250 --> 00:17:48,160
VLAN ID tag and it's important to note

00:17:46,450 --> 00:17:49,990
that it's not just pain you can run any

00:17:48,160 --> 00:17:52,570
traffic generator you want you can

00:17:49,990 --> 00:17:54,910
extend it to whatever hyper if network

00:17:52,570 --> 00:17:56,710
or wheels we're also thinking about

00:17:54,910 --> 00:17:59,260
using other in-house built traffic

00:17:56,710 --> 00:18:01,330
generator than you have so yeah so

00:17:59,260 --> 00:18:09,130
essentially we're running traffic to see

00:18:01,330 --> 00:18:11,140
this regression so how does it in st

00:18:09,130 --> 00:18:16,210
report if it's a pass you will get a

00:18:11,140 --> 00:18:18,340
nice-looking detailed report with the

00:18:16,210 --> 00:18:21,220
pass and the summary at the end if you

00:18:18,340 --> 00:18:23,980
want to skip the debug debug in part as

00:18:21,220 --> 00:18:28,390
a pass if it fail it could sell for any

00:18:23,980 --> 00:18:31,810
reason but we care about the functional

00:18:28,390 --> 00:18:36,240
failures if it for example the thing

00:18:31,810 --> 00:18:36,240
didn't pass it will tell you that it

00:18:37,630 --> 00:18:44,380
you can turn the pencil the pass here

00:18:41,230 --> 00:18:47,800
for example in our test with performance

00:18:44,380 --> 00:18:51,310
as well not just the functionality this

00:18:47,800 --> 00:18:55,360
test was a result of it was using the

00:18:51,310 --> 00:18:57,820
network was 9.4 and it passes because if

00:18:55,360 --> 00:19:02,650
it was at base the base line and this

00:18:57,820 --> 00:19:07,600
line is not just an arbitrary number but

00:19:02,650 --> 00:19:10,420
it was decided this on multiple runs and

00:19:07,600 --> 00:19:15,640
making sure that that this version is

00:19:10,420 --> 00:19:18,640
stable and we are rigid in each one in

00:19:15,640 --> 00:19:22,740
our NST we don't run even network just

00:19:18,640 --> 00:19:27,640
one time it's five time and averages

00:19:22,740 --> 00:19:30,670
that were already the failures if if it

00:19:27,640 --> 00:19:34,120
fails for the throughput reason this one

00:19:30,670 --> 00:19:36,520
was less than this baseline it tells you

00:19:34,120 --> 00:19:39,760
and the second failure is for example

00:19:36,520 --> 00:19:42,910
the devii the standard deviation allowed

00:19:39,760 --> 00:19:47,230
in our chest is has to be within 20

00:19:42,910 --> 00:19:51,070
percent of the measured proper and next

00:19:47,230 --> 00:19:54,880
slide will be a more visual idea about

00:19:51,070 --> 00:19:57,610
how the deviation failures in our tests

00:19:54,880 --> 00:20:01,720
we rely on an open source project called

00:19:57,610 --> 00:20:04,180
perf repo which is that is that since we

00:20:01,720 --> 00:20:07,510
care about performance as well we have

00:20:04,180 --> 00:20:10,510
to store the data and compare it to a

00:20:07,510 --> 00:20:13,390
baseline this baseline when I spoke

00:20:10,510 --> 00:20:15,910
before is this green line and this

00:20:13,390 --> 00:20:19,180
purple has a web UI interface that makes

00:20:15,910 --> 00:20:21,910
life a little bit easier the y-axis is

00:20:19,180 --> 00:20:27,120
the throughput in gigabits per second

00:20:21,910 --> 00:20:30,220
the x-axis has the runs each each

00:20:27,120 --> 00:20:32,110
natural number is the reserved one that

00:20:30,220 --> 00:20:35,440
there was a kernel here that we run and

00:20:32,110 --> 00:20:38,350
this was the result the the orange line

00:20:35,440 --> 00:20:40,180
is the average throughput minimum

00:20:38,350 --> 00:20:41,650
throughput maximum throughput and the

00:20:40,180 --> 00:20:47,170
space between is

00:20:41,650 --> 00:20:49,240
deviation how that runs the data we

00:20:47,170 --> 00:20:52,110
collected from the runs how scared were

00:20:49,240 --> 00:20:56,740
before between the max and minima as

00:20:52,110 --> 00:20:59,320
this this so if the space is 20% of the

00:20:56,740 --> 00:21:02,520
average throughput that means there is a

00:20:59,320 --> 00:21:04,740
player like the numbers are not reliable

00:21:02,520 --> 00:21:06,940
[Music]

00:21:04,740 --> 00:21:12,250
this one is a nice one

00:21:06,940 --> 00:21:13,990
same same machines same tests not

00:21:12,250 --> 00:21:17,050
witness a scientist but it's a different

00:21:13,990 --> 00:21:19,510
test with a different protocol this is a

00:21:17,050 --> 00:21:23,200
nice-looking graph where the baseline

00:21:19,510 --> 00:21:25,030
after we tested it we decided ok this is

00:21:23,200 --> 00:21:30,400
how much is gonna be and every time it's

00:21:25,030 --> 00:21:33,550
passed this is now this is an example

00:21:30,400 --> 00:21:37,179
how early regression testing can be

00:21:33,550 --> 00:21:41,110
helpful we run here kernel versions the

00:21:37,179 --> 00:21:43,840
UN development cycle if you can see here

00:21:41,110 --> 00:21:46,059
all the threes are several times we run

00:21:43,840 --> 00:21:48,610
this test then we decided ok that this

00:21:46,059 --> 00:21:52,270
one this I could be on this base my way

00:21:48,610 --> 00:21:54,400
was this point for example and this

00:21:52,270 --> 00:21:56,590
dotted line is the our base line then

00:21:54,400 --> 00:21:58,660
after that every time we test if it

00:21:56,590 --> 00:22:02,820
fails we go and debug and see what it

00:21:58,660 --> 00:22:05,500
feels here it's a clear regression that

00:22:02,820 --> 00:22:08,200
starting this this kernel right here it

00:22:05,500 --> 00:22:12,910
was a regression and the bug was filed

00:22:08,200 --> 00:22:15,250
and the developers are working it so I

00:22:12,910 --> 00:22:21,580
that's how I needs to make it easy for

00:22:15,250 --> 00:22:27,070
us to just automate it and run it and

00:22:21,580 --> 00:22:30,580
I'll have it ok so so what's next coming

00:22:27,070 --> 00:22:34,210
up so if you saw the recipes or

00:22:30,580 --> 00:22:36,730
xml-based before that has set of

00:22:34,210 --> 00:22:38,350
limitations where it's not very it's not

00:22:36,730 --> 00:22:40,150
very flexible in some of the more

00:22:38,350 --> 00:22:44,080
complex topologies is difficult to

00:22:40,150 --> 00:22:45,710
implement or provide recipe for so the

00:22:44,080 --> 00:22:48,110
the next thing that

00:22:45,710 --> 00:22:50,600
actually underway currently is is

00:22:48,110 --> 00:22:52,460
converting all these things into adding

00:22:50,600 --> 00:22:54,530
support for Python web-based recipes

00:22:52,460 --> 00:22:57,050
then which also means we have to convert

00:22:54,530 --> 00:22:58,760
our existing recipes into Python recipes

00:22:57,050 --> 00:23:01,910
so that's one of the things that's going

00:22:58,760 --> 00:23:03,770
on like I said there were different type

00:23:01,910 --> 00:23:06,470
of traffic backends that you can put in

00:23:03,770 --> 00:23:07,730
like like hyper if net person there's

00:23:06,470 --> 00:23:10,640
another one which we're trying to use

00:23:07,730 --> 00:23:12,380
carwash in which is again a traffic

00:23:10,640 --> 00:23:14,300
generator that we built inside the

00:23:12,380 --> 00:23:16,780
networking team and it's also stream so

00:23:14,300 --> 00:23:19,010
we're trying to integrate that as well

00:23:16,780 --> 00:23:21,890
of course this work happening on the

00:23:19,010 --> 00:23:24,890
next branch this conversion from Python

00:23:21,890 --> 00:23:26,840
to to Python 3 because python 2 is going

00:23:24,890 --> 00:23:28,940
to be deprecated I believe so in a

00:23:26,840 --> 00:23:31,910
couple of years so that conversion was

00:23:28,940 --> 00:23:33,950
happening there are other supporting

00:23:31,910 --> 00:23:35,750
things that are not specific to lndustry

00:23:33,950 --> 00:23:38,480
but something that's if you remember

00:23:35,750 --> 00:23:40,910
that package that he showed about beaker

00:23:38,480 --> 00:23:43,640
Jenkins there's something else that

00:23:40,910 --> 00:23:45,560
we've added which is sometimes you see

00:23:43,640 --> 00:23:48,230
setup issues where you might get false

00:23:45,560 --> 00:23:49,850
positives so we've created these bots

00:23:48,230 --> 00:23:50,840
which will rerun the test again just to

00:23:49,850 --> 00:23:54,320
make sure we're really caught a

00:23:50,840 --> 00:23:55,880
regression so so we might integrate into

00:23:54,320 --> 00:23:57,230
LST not sure but it is something that

00:23:55,880 --> 00:24:00,890
we're running on the side so it's one

00:23:57,230 --> 00:24:02,600
runs it again we do a comma three passes

00:24:00,890 --> 00:24:04,700
so basically if we have a majority path

00:24:02,600 --> 00:24:06,200
and you know it's like a setup glitch we

00:24:04,700 --> 00:24:09,140
mark it as something that we need to go

00:24:06,200 --> 00:24:12,110
look and we fix it this test setup issue

00:24:09,140 --> 00:24:15,470
or at a specific issue or a testings

00:24:12,110 --> 00:24:17,840
issue so we also want to bisect it so

00:24:15,470 --> 00:24:19,040
that if once a regression is found we

00:24:17,840 --> 00:24:20,930
want to be able to go back and tell

00:24:19,040 --> 00:24:23,210
exactly which commit it was that caused

00:24:20,930 --> 00:24:25,730
this problem so that's another bot that

00:24:23,210 --> 00:24:26,810
we will be working on so that we can go

00:24:25,730 --> 00:24:29,040
tell the developer

00:24:26,810 --> 00:24:31,320
this is where you started revelation

00:24:29,040 --> 00:24:32,700
please fix it so that that's kind of

00:24:31,320 --> 00:24:35,190
something that that's happening as well

00:24:32,700 --> 00:24:37,020
and of course more topologies network

00:24:35,190 --> 00:24:39,180
you have so many topologies so we're

00:24:37,020 --> 00:24:41,750
adding more and more tests as people add

00:24:39,180 --> 00:24:44,490
more functionalities in the Linux kernel

00:24:41,750 --> 00:24:45,890
we we also add recipes and tests for

00:24:44,490 --> 00:24:50,790
that so that's another thing that's

00:24:45,890 --> 00:24:53,130
continually ongoing so finally have

00:24:50,790 --> 00:24:56,790
credits like the engineer who started

00:24:53,130 --> 00:24:59,190
this project GT Peugeot he's he's kind

00:24:56,790 --> 00:25:01,830
of the founder of it ten Mondrian pal

00:24:59,190 --> 00:25:04,710
Lackner is he's raised the maintainer

00:25:01,830 --> 00:25:06,450
and yond Lucca and a nice and all these

00:25:04,710 --> 00:25:10,500
guys they work in the LMS thinking as

00:25:06,450 --> 00:25:14,250
well so this is the place where you can

00:25:10,500 --> 00:25:17,400
go get the code you can if you want to

00:25:14,250 --> 00:25:20,820
contribute to writing tests or if you

00:25:17,400 --> 00:25:24,060
want to reach out for any questions

00:25:20,820 --> 00:25:31,730
we're also on IRC that I put in the

00:25:24,060 --> 00:25:35,400
beginning of the slide deck here so

00:25:31,730 --> 00:25:37,920
guarantee note at this point so reach

00:25:35,400 --> 00:25:39,720
out we should need any help with it as

00:25:37,920 --> 00:25:43,130
sound at this point I will take

00:25:39,720 --> 00:25:43,130
questions ready

00:25:46,960 --> 00:25:52,859
sorry

00:25:49,800 --> 00:25:52,859
[Music]

00:25:55,390 --> 00:26:02,980
thank you for the information so I just

00:25:58,720 --> 00:26:13,000
wanted to know if this LNS she does test

00:26:02,980 --> 00:26:17,860
for things like DP d KS r io v yeah okay

00:26:13,000 --> 00:26:21,310
so like for a PDK of I mean like what

00:26:17,860 --> 00:26:24,420
kind of you know traffic generator that

00:26:21,310 --> 00:26:24,420
is using a PMD

00:26:33,930 --> 00:26:41,410
cheers idiot okay

00:26:37,350 --> 00:26:43,570
okay thanks

00:26:41,410 --> 00:26:50,370
[Music]

00:26:43,570 --> 00:26:53,460
no more questions thank you very much

00:26:50,370 --> 00:26:53,460
thank you

00:26:54,680 --> 00:26:57,749
[Music]

00:27:02,630 --> 00:27:05,929
[Music]

00:27:09,080 --> 00:27:12,710
[Music]

00:27:10,650 --> 00:27:12,710

YouTube URL: https://www.youtube.com/watch?v=pDLB8KZYg7E


