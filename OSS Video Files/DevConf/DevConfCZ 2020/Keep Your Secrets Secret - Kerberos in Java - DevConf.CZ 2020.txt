Title: Keep Your Secrets Secret - Kerberos in Java - DevConf.CZ 2020
Publication date: 2020-03-26
Playlist: DevConfCZ 2020
Description: 
	Speakers: Josef Cacek

Kerberos is a three-headed dog from Greek mythology and it's also the name of a security protocol developed a few decades ago for authentication. There are for sure other well-established and/or fancy authentication protocols for Single-sign-on nowadays, but Kerberos is still very popular in many companies.

The protocol itself has support in standard Java API. Nevertheless, using the plain Kerberos protocol still leaves a non-trivial part of implementation on application developers.

Don't despair! There is a GSS-API to rescue. And yes, Java has support for it. You can still meet some traps set by sneaky Kerberos dog in front of you, let's discuss them before you fall into them. We will also discuss differences and similarities when compared to TLS.

Attendees will learn how to use GSS-API for authentication and establishing communication with security parameters - such as confidentiality or data integrity.

[ https://sched.co/YOqA ]

--
Recordings of talks at DevConf are a community effort. Unfortunately not everything works perfectly every time. If you're interested in helping us improve, let us know.
Captions: 
	00:00:02,139 --> 00:00:06,890
so hello Def Con

00:00:04,520 --> 00:00:07,990
welcome to the presentation keep your

00:00:06,890 --> 00:00:12,020
secret secret

00:00:07,990 --> 00:00:15,490
Kerberos for Java developers this will

00:00:12,020 --> 00:00:18,769
be presentation about really old stuff

00:00:15,490 --> 00:00:21,109
the last presentation you heard now was

00:00:18,769 --> 00:00:24,589
about new quark ooze and this is about

00:00:21,109 --> 00:00:28,669
old barrows let's start with few words

00:00:24,589 --> 00:00:31,189
about me I'm a former editor currently

00:00:28,669 --> 00:00:35,420
working a security engineer in his er

00:00:31,189 --> 00:00:40,640
cast we are making open-source in-memory

00:00:35,420 --> 00:00:43,550
data grade and streaming engine I love

00:00:40,640 --> 00:00:47,180
running long distances I have four

00:00:43,550 --> 00:00:50,449
children and although I like contribute

00:00:47,180 --> 00:00:55,640
to to open source because it's better to

00:00:50,449 --> 00:00:59,859
share we will talk about some Kerberos

00:00:55,640 --> 00:01:04,519
basics and how can we use Kerberos in

00:00:59,859 --> 00:01:07,930
Java I will show you some two linkable

00:01:04,519 --> 00:01:11,950
around it and you can also find the

00:01:07,930 --> 00:01:17,380
slides for the presentation on this

00:01:11,950 --> 00:01:20,800
address so let's start with a question

00:01:17,380 --> 00:01:24,410
are you using Kerberos authentication

00:01:20,800 --> 00:01:26,600
every redhead is using so I will ask

00:01:24,410 --> 00:01:31,120
opposite who is not using Kerberos

00:01:26,600 --> 00:01:36,770
authentication is there anybody one -

00:01:31,120 --> 00:01:40,790
okay great and the second question who

00:01:36,770 --> 00:01:43,190
knows just authentication in just API in

00:01:40,790 --> 00:01:47,570
Java it's standard Java API for

00:01:43,190 --> 00:01:51,640
authentication one not many I thought

00:01:47,570 --> 00:01:54,620
that it will be more ok nevertheless and

00:01:51,640 --> 00:02:03,020
anybody tried to play with Kerberos

00:01:54,620 --> 00:02:07,310
authentication in Java yeah one nice so

00:02:03,020 --> 00:02:09,950
let's start with some basics Kerberos

00:02:07,310 --> 00:02:15,170
protocol is network authentication

00:02:09,950 --> 00:02:22,060
protocol developed on MIT in late

00:02:15,170 --> 00:02:29,720
80s and Kerberos is a name of Greek

00:02:22,060 --> 00:02:33,560
beast three-headed dog and we also have

00:02:29,720 --> 00:02:36,380
three roles in the Kerberos protocol and

00:02:33,560 --> 00:02:39,130
three main roles are key distribution

00:02:36,380 --> 00:02:44,989
center which is the Kerberos server

00:02:39,130 --> 00:02:47,660
client and the service and Kerberos from

00:02:44,989 --> 00:02:51,110
its beginning is used for single sign-on

00:02:47,660 --> 00:02:53,350
and what's the what's important secrets

00:02:51,110 --> 00:02:55,940
are not sent over the network so it's

00:02:53,350 --> 00:03:01,400
authentication without sent sending

00:02:55,940 --> 00:03:05,269
passwords of the network and the last

00:03:01,400 --> 00:03:09,620
RFC which real Kerberos specification

00:03:05,269 --> 00:03:17,360
version 5 is from 2005 I think and it's

00:03:09,620 --> 00:03:20,720
RFC for 1 to 0 so as I've already

00:03:17,360 --> 00:03:28,450
mentioned passwords are not sent over

00:03:20,720 --> 00:03:28,450
the network and tickets are used instead

00:03:29,260 --> 00:03:40,370
the protocol supports delegation of

00:03:35,200 --> 00:03:43,820
identity or kind can say to to the

00:03:40,370 --> 00:03:46,640
server that it can further its identity

00:03:43,820 --> 00:03:50,090
to another server so some middle tier

00:03:46,640 --> 00:03:52,609
some gateway can impersonate the client

00:03:50,090 --> 00:03:54,560
and say for example if kind is through

00:03:52,609 --> 00:03:57,380
an application server connecting to

00:03:54,560 --> 00:03:59,269
database the to do database you can

00:03:57,380 --> 00:04:02,690
authenticate using

00:03:59,269 --> 00:04:10,209
Kerberos which which the user identity

00:04:02,690 --> 00:04:14,209
not the application server identity and

00:04:10,209 --> 00:04:22,590
server doesn't need to talk to Kerberos

00:04:14,209 --> 00:04:24,780
server to authenticate clients yeah

00:04:22,590 --> 00:04:31,980
what can cause problem in Kerberos

00:04:24,780 --> 00:04:35,760
protocol first one is the time it's very

00:04:31,980 --> 00:04:39,320
sensitive to synchronization for

00:04:35,760 --> 00:04:43,260
example if you're kind and server has

00:04:39,320 --> 00:04:45,810
clocks set more than five five minutes

00:04:43,260 --> 00:04:49,380
at the clock skew is more than five

00:04:45,810 --> 00:04:52,700
minutes then the client will not be able

00:04:49,380 --> 00:04:57,660
to authenticate to the server

00:04:52,700 --> 00:04:59,160
another problem can be in KDC if it's

00:04:57,660 --> 00:05:03,389
not for any reason

00:04:59,160 --> 00:05:06,150
X is accessible client is not able to

00:05:03,389 --> 00:05:08,850
retrieve ticket from the cell from the

00:05:06,150 --> 00:05:11,669
Kerberos server from the KDC and it's

00:05:08,850 --> 00:05:15,600
not possible to authenticate to prove

00:05:11,669 --> 00:05:20,430
the kind identity to the server so KDC

00:05:15,600 --> 00:05:26,550
is a single point of failure and some

00:05:20,430 --> 00:05:30,800
part or some implementations are also

00:05:26,550 --> 00:05:34,820
very sensitive to hostname handling so

00:05:30,800 --> 00:05:40,440
in in some services there is hostname

00:05:34,820 --> 00:05:41,870
hostname canonicalization and if it is

00:05:40,440 --> 00:05:44,880
not handled properly

00:05:41,870 --> 00:05:47,940
the authentication again will fail

00:05:44,880 --> 00:05:53,970
because sara will expect something and

00:05:47,940 --> 00:05:56,970
other than the kind sense yeah I already

00:05:53,970 --> 00:06:01,500
mentioned that instead of password is

00:05:56,970 --> 00:06:04,889
used at ticket it's a it's some data

00:06:01,500 --> 00:06:08,880
structure which is partly encrypted so

00:06:04,889 --> 00:06:13,740
only small piece of information is in

00:06:08,880 --> 00:06:17,250
plain text and even client sense since

00:06:13,740 --> 00:06:22,500
the ticket to the to the server only the

00:06:17,250 --> 00:06:25,289
server name and it's RAM or domain only

00:06:22,500 --> 00:06:27,810
this information is not encrypted the

00:06:25,289 --> 00:06:30,120
rest of the ticket is encrypted so

00:06:27,810 --> 00:06:32,010
client name and session key which is

00:06:30,120 --> 00:06:35,199
used then for symmetric cryptography

00:06:32,010 --> 00:06:39,719
between client and the server

00:06:35,199 --> 00:06:42,759
and of course the ticket usually has

00:06:39,719 --> 00:06:52,599
limited validity for example ten hours

00:06:42,759 --> 00:06:56,830
or one day so the protocol looks like

00:06:52,599 --> 00:07:00,939
this first kind goes to key distribution

00:06:56,830 --> 00:07:03,400
center and out indicates to it second

00:07:00,939 --> 00:07:06,939
kind wants to go to some service to some

00:07:03,400 --> 00:07:10,330
server so it first go to KBC key

00:07:06,939 --> 00:07:13,180
distribution center and masks give me a

00:07:10,330 --> 00:07:17,770
ticket for the server for the service

00:07:13,180 --> 00:07:21,099
and if the KDC agrees it sends back to

00:07:17,770 --> 00:07:26,919
the ticket and the kind presents the

00:07:21,099 --> 00:07:32,650
ticket to the server let's look into it

00:07:26,919 --> 00:07:37,949
in detail so first step protocol is

00:07:32,650 --> 00:07:45,129
going to authenticate to the to the KDC

00:07:37,949 --> 00:07:48,729
the important thing is the all the

00:07:45,129 --> 00:07:53,889
parties or the all the entities all the

00:07:48,729 --> 00:07:56,740
principal's in in the in the Kerberos

00:07:53,889 --> 00:08:02,649
domain has to share with SCADA see its

00:07:56,740 --> 00:08:07,089
its secret its its password or a secret

00:08:02,649 --> 00:08:08,919
key so they both know the password but

00:08:07,089 --> 00:08:13,089
the password is not sent over the

00:08:08,919 --> 00:08:16,449
network so yeah first that hello can you

00:08:13,089 --> 00:08:19,960
see I am see I don't encrypt anything

00:08:16,449 --> 00:08:24,270
just give me a ticket to access you the

00:08:19,960 --> 00:08:27,490
next time for the second second step and

00:08:24,270 --> 00:08:30,610
KDC looks into a database of the users

00:08:27,490 --> 00:08:35,050
and says hey I know you here is here is

00:08:30,610 --> 00:08:36,849
the ticket and it's encrypted by secret

00:08:35,050 --> 00:08:38,949
key which is generated from the

00:08:36,849 --> 00:08:42,159
passwords which we both know

00:08:38,949 --> 00:08:44,880
and inside the ticket is a session key

00:08:42,159 --> 00:08:46,760
which is used then for next

00:08:44,880 --> 00:08:50,860
communication

00:08:46,760 --> 00:08:53,690
with the KDC so in the first step the

00:08:50,860 --> 00:08:59,560
information in the replay is encrypted

00:08:53,690 --> 00:09:03,830
by secret key long-term secret keep key

00:08:59,560 --> 00:09:07,100
generated from password but the second

00:09:03,830 --> 00:09:10,880
step which we will show now the second

00:09:07,100 --> 00:09:16,310
step is encrypted by session key which

00:09:10,880 --> 00:09:21,560
was presented to the to the client in

00:09:16,310 --> 00:09:25,850
the in the first step so in the second

00:09:21,560 --> 00:09:30,470
step well we already have the ticket to

00:09:25,850 --> 00:09:33,560
access the KDC and now we we ask for

00:09:30,470 --> 00:09:39,530
another ticket to access a server and

00:09:33,560 --> 00:09:41,990
it's a service so again I'm going to KDC

00:09:39,530 --> 00:09:44,900
and asking give me please

00:09:41,990 --> 00:09:48,190
ticket for for the service and I can

00:09:44,900 --> 00:09:52,010
prove my identity by giving you this

00:09:48,190 --> 00:09:55,280
this ticket from previous step and also

00:09:52,010 --> 00:09:58,130
I am attaching and a piece of

00:09:55,280 --> 00:10:01,940
information called Authenticator which

00:09:58,130 --> 00:10:05,410
proves that I know the session key which

00:10:01,940 --> 00:10:09,050
is also part of the ticket the ticket

00:10:05,410 --> 00:10:14,170
can decrypt only the receiving side so

00:10:09,050 --> 00:10:17,720
in this case only the only the KDC and

00:10:14,170 --> 00:10:21,530
if it agrees to to give me a ticket for

00:10:17,720 --> 00:10:26,240
for the target service then it creates

00:10:21,530 --> 00:10:32,510
new ticket and encrypts it by the by the

00:10:26,240 --> 00:10:35,600
secret key of the target service so the

00:10:32,510 --> 00:10:38,120
client can't read the encrypted

00:10:35,600 --> 00:10:41,270
information from the ticket only the

00:10:38,120 --> 00:10:47,450
target services can read can decrypt the

00:10:41,270 --> 00:10:50,660
ticket yeah so if if the current

00:10:47,450 --> 00:10:54,650
successfully received the ticket it can

00:10:50,660 --> 00:10:59,820
go to the target service to the server

00:10:54,650 --> 00:11:03,930
and say yeah here am I your client

00:10:59,820 --> 00:11:08,300
I prove my identity by sending you this

00:11:03,930 --> 00:11:11,130
ticket which you can decrypt and I also

00:11:08,300 --> 00:11:13,890
attach a piece of information again the

00:11:11,130 --> 00:11:16,250
Authenticator which is valid for this

00:11:13,890 --> 00:11:19,200
five minutes

00:11:16,250 --> 00:11:21,950
encrypted by session key and server

00:11:19,200 --> 00:11:26,130
receives the session key in the ticket

00:11:21,950 --> 00:11:31,820
so yeah no password is sent over the

00:11:26,130 --> 00:11:35,040
network but in every step every party

00:11:31,820 --> 00:11:42,420
now is the piece of information which it

00:11:35,040 --> 00:11:46,170
needs to to decrypt the finger so that

00:11:42,420 --> 00:11:53,160
was about the about the protocol basics

00:11:46,170 --> 00:12:05,550
and now something about tooling yeah

00:11:53,160 --> 00:12:09,420
question it's a very good it's a very

00:12:05,550 --> 00:12:13,350
good question the question was when when

00:12:09,420 --> 00:12:17,520
the client in the first step sends the

00:12:13,350 --> 00:12:19,830
request to the to the server and says

00:12:17,520 --> 00:12:22,590
IMC how can serve a validating it

00:12:19,830 --> 00:12:27,120
doesn't need to validate it yeah because

00:12:22,590 --> 00:12:30,990
it sends back the information which is

00:12:27,120 --> 00:12:33,840
for client is encrypted by the client

00:12:30,990 --> 00:12:37,980
secret key generated from password and

00:12:33,840 --> 00:12:41,760
it's it also sends the ticket ticket

00:12:37,980 --> 00:12:45,540
granting ticket to yeah which is

00:12:41,760 --> 00:12:49,040
encrypted by the service service secret

00:12:45,540 --> 00:12:49,040
key so

00:12:54,580 --> 00:13:07,520
the authenticate yeah if it can decrypt

00:13:05,150 --> 00:13:12,140
the session key which is used for the

00:13:07,520 --> 00:13:19,910
next communication then it's proof that

00:13:12,140 --> 00:13:24,680
he the kind is the kind yeah the thing

00:13:19,910 --> 00:13:28,340
is there is extension usually used

00:13:24,680 --> 00:13:32,270
nowadays which prevents some brute force

00:13:28,340 --> 00:13:35,120
attacks by pre authentication so if the

00:13:32,270 --> 00:13:39,200
current sense this plain request I'm

00:13:35,120 --> 00:13:43,130
kind give me my ticket then Kerberos

00:13:39,200 --> 00:13:46,790
responds with Kerberos error and client

00:13:43,130 --> 00:13:51,290
has to prove that he is the current by

00:13:46,790 --> 00:13:54,830
sending the data encrypted with his

00:13:51,290 --> 00:13:57,410
secret key so he has to repeat the

00:13:54,830 --> 00:14:13,820
request and include some authentication

00:13:57,410 --> 00:14:18,380
data if it's okay so yeah a majority of

00:14:13,820 --> 00:14:21,860
you already met Kerberos Kerberos in

00:14:18,380 --> 00:14:26,210
your job you you know this to scan 8k

00:14:21,860 --> 00:14:30,650
least key destroy there is also a V&O

00:14:26,210 --> 00:14:33,920
which can retreat for you some service

00:14:30,650 --> 00:14:40,940
ticket ok admin for administration of

00:14:33,920 --> 00:14:45,470
lock user user base in in Kerberos on

00:14:40,940 --> 00:14:49,130
Windows the native tool is Kaylee's from

00:14:45,470 --> 00:14:52,510
this but its ability it has ability to

00:14:49,130 --> 00:14:55,339
to work also as a key destroy

00:14:52,510 --> 00:14:59,839
unfortunately on Windows there is no key

00:14:55,339 --> 00:15:02,400
in it but there is Active Directory

00:14:59,839 --> 00:15:06,960
module in PowerShell

00:15:02,400 --> 00:15:10,260
which you can somehow also used for K in

00:15:06,960 --> 00:15:15,470
it once you import this module into the

00:15:10,260 --> 00:15:15,470
parish shell it behaves like key in it

00:15:17,780 --> 00:15:31,110
servers the standard ones MIT Kerberos

00:15:21,440 --> 00:15:34,380
Microsoft Active Directory I'm the on

00:15:31,110 --> 00:15:38,610
Windows I've mentioned there is no key

00:15:34,380 --> 00:15:42,960
in it natively so Java Runtime on

00:15:38,610 --> 00:15:47,430
Windows when you download Oracle Java or

00:15:42,960 --> 00:15:50,760
other Java version then you will find in

00:15:47,430 --> 00:15:55,670
bin directory K in it and K list which

00:15:50,760 --> 00:16:01,770
you can use to replace the native tools

00:15:55,670 --> 00:16:06,840
and it also have a key top tool which

00:16:01,770 --> 00:16:12,360
can create you a key tab which holds

00:16:06,840 --> 00:16:15,870
secrets key secret keys with four

00:16:12,360 --> 00:16:19,050
different encryption types so you can

00:16:15,870 --> 00:16:22,680
you can say in key tab that for

00:16:19,050 --> 00:16:26,430
principal for example client the the

00:16:22,680 --> 00:16:30,330
secret key in these encryption types are

00:16:26,430 --> 00:16:34,140
are these entries so it can be reused

00:16:30,330 --> 00:16:38,390
later and the secret Keys doesn't need

00:16:34,140 --> 00:16:38,390
to be generated from the password

00:16:40,430 --> 00:16:48,810
standard configuration file on Linux is

00:16:44,460 --> 00:16:52,230
etc' cap 5 conf and what's the most

00:16:48,810 --> 00:16:57,120
important is the ramus part where you

00:16:52,230 --> 00:17:04,230
list your Kerberos realms and where the

00:16:57,120 --> 00:17:07,470
key distribution center lives so it's

00:17:04,230 --> 00:17:10,760
the most important information from the

00:17:07,470 --> 00:17:10,760
configuration point of view

00:17:11,100 --> 00:17:22,020
there are also Java implementations of

00:17:15,630 --> 00:17:25,169
KDC and both of which I mentioned here

00:17:22,020 --> 00:17:29,640
are from Apache directory project which

00:17:25,169 --> 00:17:30,360
is out project probably you you heard

00:17:29,640 --> 00:17:36,299
about it

00:17:30,360 --> 00:17:41,160
it's its directory the the Apache D s

00:17:36,299 --> 00:17:45,390
which is and the old project is is

00:17:41,160 --> 00:17:48,450
directory service which has some LDAP

00:17:45,390 --> 00:17:57,270
endpoint and it also provides cables

00:17:48,450 --> 00:18:01,440
access the advantage of running KDC in

00:17:57,270 --> 00:18:04,190
java is that you can embed it into our

00:18:01,440 --> 00:18:08,039
test into our environment and for

00:18:04,190 --> 00:18:11,640
example testing is very simplified when

00:18:08,039 --> 00:18:15,000
when you can start start with in your

00:18:11,640 --> 00:18:16,559
test the KDC or test test your

00:18:15,000 --> 00:18:23,730
application against it

00:18:16,559 --> 00:18:30,179
shutdown it and let it so I already

00:18:23,730 --> 00:18:31,679
mentioned the Apache Kirby is newer one

00:18:30,179 --> 00:18:35,730
it

00:18:31,679 --> 00:18:39,799
I think first release was 2017 maybe

00:18:35,730 --> 00:18:46,049
development on Apache project started on

00:18:39,799 --> 00:18:50,159
2015 first released 2017 and now we have

00:18:46,049 --> 00:18:55,039
version 2.0 and the usage is really

00:18:50,159 --> 00:18:57,900
simple start simple server for me and

00:18:55,039 --> 00:18:59,610
once I do this I have also

00:18:57,900 --> 00:19:02,450
administration interface

00:18:59,610 --> 00:19:06,990
I have tooling for creating key tabs and

00:19:02,450 --> 00:19:16,090
it's it's really simple to to start with

00:19:06,990 --> 00:19:19,029
SCADA see the older one Apache tears

00:19:16,090 --> 00:19:27,669
which is for example used in wildfire

00:19:19,029 --> 00:19:30,309
test suite uses annotations to to define

00:19:27,669 --> 00:19:33,609
how to define work or you can use also

00:19:30,309 --> 00:19:34,419
the API in similar way to to the Apache

00:19:33,609 --> 00:19:39,009
car babe

00:19:34,419 --> 00:19:43,210
the problem with Apache des project it's

00:19:39,009 --> 00:19:48,989
old and it's it's development is really

00:19:43,210 --> 00:19:53,919
slow because last last the deployed or

00:19:48,989 --> 00:19:58,389
last released version which was final

00:19:53,919 --> 00:20:05,309
was one five seven maybe and it it's

00:19:58,389 --> 00:20:08,859
before 2010 and in 2010 started work on

00:20:05,309 --> 00:20:12,159
version 2.0 and it's not completed yet

00:20:08,859 --> 00:20:15,729
after ten years we still don't have a

00:20:12,159 --> 00:20:24,309
version 2.0 there is my milestone 25

00:20:15,729 --> 00:20:28,659
currently yes so let's switch to to an

00:20:24,309 --> 00:20:35,919
IDE and look into a demo and what we

00:20:28,659 --> 00:20:40,599
will show we will try to look how how

00:20:35,919 --> 00:20:49,139
the how the request and response looks

00:20:40,599 --> 00:20:49,139
like I don't see my mouse

00:21:00,150 --> 00:21:07,330
so the code which I will used is just

00:21:04,300 --> 00:21:09,850
the simple Apache Kirby Code which you

00:21:07,330 --> 00:21:18,400
already seen on the slide

00:21:09,850 --> 00:21:25,410
so let's run it and it says Kerberos

00:21:18,400 --> 00:21:35,020
server I started so now I can go to

00:21:25,410 --> 00:21:43,720
console and run ok in it and choose one

00:21:35,020 --> 00:21:50,020
of the Duke should be the password tab

00:21:43,720 --> 00:21:53,740
and now again I've received a ticket

00:21:50,020 --> 00:22:03,970
granting ticket I forgot to start the

00:21:53,740 --> 00:22:07,720
Wireshark so once again so let's listen

00:22:03,970 --> 00:22:11,560
let's capture the communication on port

00:22:07,720 --> 00:22:14,980
10000 8080 the default port of Kerberos

00:22:11,560 --> 00:22:18,660
servers is 880 but because of Java I

00:22:14,980 --> 00:22:25,090
would need a root permissions then

00:22:18,660 --> 00:22:32,730
therefore I I started on 10000 880 so

00:22:25,090 --> 00:22:39,280
it's listening and let's destroy it

00:22:32,730 --> 00:22:42,690
let's check no credential cache and one

00:22:39,280 --> 00:22:51,580
more ok in it

00:22:42,690 --> 00:22:54,540
password the Duke I have the ticket

00:22:51,580 --> 00:22:57,910
granting ticket and if I look into the

00:22:54,540 --> 00:23:01,660
into the varnish our network analyzer I

00:22:57,910 --> 00:23:05,230
can see there is some authentication

00:23:01,660 --> 00:23:11,620
request and response now I can go back

00:23:05,230 --> 00:23:12,429
and ask ask for service ticket I have a

00:23:11,620 --> 00:23:22,240
service which

00:23:12,429 --> 00:23:26,619
Scott Justice thirst / localhost and now

00:23:22,240 --> 00:23:30,759
when I list the tickets yeah in my

00:23:26,619 --> 00:23:39,519
credential cash is justice that no ghost

00:23:30,759 --> 00:23:43,029
so by this K in it and ka ba no I made

00:23:39,519 --> 00:23:45,700
the first two two steps in the Kerberos

00:23:43,029 --> 00:23:48,850
protocol so ask for the ticket granting

00:23:45,700 --> 00:24:09,220
ticket first step ask for service ticket

00:23:48,850 --> 00:24:14,769
second step so the authentication okay

00:24:09,220 --> 00:24:19,950
so the authentication request as we

00:24:14,769 --> 00:24:19,950
talked about it was really the simple

00:24:20,429 --> 00:24:30,460
hey I am I'm J Duke give me my ticket to

00:24:25,179 --> 00:24:37,600
access you into in the second step so in

00:24:30,460 --> 00:24:41,919
the intro response I've received ticket

00:24:37,600 --> 00:24:46,690
and encrypted session key so the ticket

00:24:41,919 --> 00:24:50,860
is encrypted by by the KDC secret key

00:24:46,690 --> 00:24:54,159
and the session key or information for

00:24:50,860 --> 00:24:56,940
the kind are encrypted with the current

00:24:54,159 --> 00:24:56,940
secret key

00:25:02,970 --> 00:25:10,590
yeah and similar similarly it goes for

00:25:06,990 --> 00:25:17,670
the second communication ticket granting

00:25:10,590 --> 00:25:21,840
service request where the only

00:25:17,670 --> 00:25:25,740
difference is I don't send plain pine I

00:25:21,840 --> 00:25:28,200
request only I attach to the to the

00:25:25,740 --> 00:25:34,520
request also the ticket from the first

00:25:28,200 --> 00:25:34,520
step that's it

00:25:41,210 --> 00:25:51,820
so how to work with it in in Java I was

00:25:47,840 --> 00:25:59,410
asking about the who knows the jazz API

00:25:51,820 --> 00:26:04,420
because what you need to know is that to

00:25:59,410 --> 00:26:07,840
the working with which Kerberos in

00:26:04,420 --> 00:26:14,590
standard Java starts in login module

00:26:07,840 --> 00:26:14,590
which is implementation of just API

00:26:15,220 --> 00:26:21,640
fortunately you don't need to implement

00:26:17,750 --> 00:26:25,210
login module yourself but vendors has

00:26:21,640 --> 00:26:29,060
login module already prepared for you

00:26:25,210 --> 00:26:33,530
they differs a little bit in Oracle and

00:26:29,060 --> 00:26:36,560
IBM Bert but most of the options are are

00:26:33,530 --> 00:26:39,560
similar or the same so you just need to

00:26:36,560 --> 00:26:45,110
put the correct last name into the into

00:26:39,560 --> 00:26:47,270
your just configuration so just

00:26:45,110 --> 00:26:50,660
configuration can look like a simple

00:26:47,270 --> 00:26:53,090
text file where you put some name which

00:26:50,660 --> 00:26:58,840
will you you will reference from your

00:26:53,090 --> 00:27:02,000
application and into into the

00:26:58,840 --> 00:27:05,540
configuration you just mentioned the

00:27:02,000 --> 00:27:11,510
last name the flag for example if it is

00:27:05,540 --> 00:27:14,150
required or sufficient or requisite it

00:27:11,510 --> 00:27:16,850
only matters if you have more login

00:27:14,150 --> 00:27:19,820
module in the stack then then the second

00:27:16,850 --> 00:27:28,070
parameter is important and login module

00:27:19,820 --> 00:27:31,460
options in this case the back true and

00:27:28,070 --> 00:27:36,500
now once we created the named

00:27:31,460 --> 00:27:40,790
configuration in our in our application

00:27:36,500 --> 00:27:45,460
we can simply do I think think like this

00:27:40,790 --> 00:27:47,660
use the just API to create login context

00:27:45,460 --> 00:27:50,260
which reference is the name

00:27:47,660 --> 00:27:53,330
configuration from the config file

00:27:50,260 --> 00:27:57,800
called logon

00:27:53,330 --> 00:28:01,310
and get just subject which will probably

00:27:57,800 --> 00:28:05,410
if the authentication succeeded which

00:28:01,310 --> 00:28:10,820
will contain the ticket granting ticket

00:28:05,410 --> 00:28:13,070
so by finishing these few lines we

00:28:10,820 --> 00:28:15,320
finished first step of the Kerberos

00:28:13,070 --> 00:28:27,190
protocol we received the ticket granting

00:28:15,320 --> 00:28:33,340
ticket from KDC yeah I've mentioned that

00:28:27,190 --> 00:28:36,310
the normal location of the Kerberos 5

00:28:33,340 --> 00:28:37,550
configuration file is eaten et Cie

00:28:36,310 --> 00:28:42,200
five.com

00:28:37,550 --> 00:28:46,310
but we have a property to override it or

00:28:42,200 --> 00:28:51,710
you can place the kerb five.com into

00:28:46,310 --> 00:28:55,250
your Java Runtime folder where the

00:28:51,710 --> 00:28:58,160
config configuration is stored security

00:28:55,250 --> 00:29:01,280
configuration is stored so it takes

00:28:58,160 --> 00:29:07,220
precedence over the Verdon native one in

00:29:01,280 --> 00:29:10,640
the et Cie you can also play with play

00:29:07,220 --> 00:29:15,970
visit without providing corrupt five.com

00:29:10,640 --> 00:29:20,720
and just setting the random name and

00:29:15,970 --> 00:29:24,050
address of the KDC directly as a system

00:29:20,720 --> 00:29:26,960
properties the problem is the java dot

00:29:24,050 --> 00:29:32,420
security dot cap v dot k DC doesn't

00:29:26,960 --> 00:29:37,580
support the port port specification so i

00:29:32,420 --> 00:29:41,750
couldn't use it in my example and there

00:29:37,580 --> 00:29:44,510
are some there are some properties which

00:29:41,750 --> 00:29:47,120
will print some debug information what's

00:29:44,510 --> 00:29:49,790
happening inside we will see more of

00:29:47,120 --> 00:29:59,530
them later when we will talk about

00:29:49,790 --> 00:29:59,530
gssapi yesterday PR is on the next slide

00:29:59,809 --> 00:30:10,100
it's another standard API generic

00:30:08,210 --> 00:30:14,630
security service application programming

00:30:10,100 --> 00:30:18,799
interface it is a frame or framework

00:30:14,630 --> 00:30:22,130
which itself doesn't implement some

00:30:18,799 --> 00:30:25,250
security features but it provides

00:30:22,130 --> 00:30:28,910
uniform API to access underlying

00:30:25,250 --> 00:30:34,250
security mechanisms which you plug into

00:30:28,910 --> 00:30:38,660
it so it's similar to TLS TLS itself

00:30:34,250 --> 00:30:42,830
it's just a framework and you are forced

00:30:38,660 --> 00:30:46,280
to specify cipher suite which does the

00:30:42,830 --> 00:30:49,130
security stuff for the TLS protocol for

00:30:46,280 --> 00:30:53,120
the TS framework so this is very similar

00:30:49,130 --> 00:30:56,990
you have GSS API and you have to plug

00:30:53,120 --> 00:30:59,600
some implementation some security

00:30:56,990 --> 00:31:02,299
mechanism into it and in our case we

00:30:59,600 --> 00:31:11,299
want to plug into it the Kerberos

00:31:02,299 --> 00:31:14,179
protocol yeah so Kerberos is probably

00:31:11,299 --> 00:31:19,549
the most used the mechanic most used

00:31:14,179 --> 00:31:24,350
mechanism for gssapi and because of the

00:31:19,549 --> 00:31:30,049
jss api we have standardized way to to

00:31:24,350 --> 00:31:33,679
work bits which Kerberos yeah the

00:31:30,049 --> 00:31:37,850
problem is Kerberos implementations may

00:31:33,679 --> 00:31:43,370
differ may be different and they don't

00:31:37,850 --> 00:31:47,150
provide single single some standard

00:31:43,370 --> 00:31:52,910
standardized API to to work with so

00:31:47,150 --> 00:31:55,790
therefore gssapi is a safe way to work

00:31:52,910 --> 00:31:59,620
with Kerberos protocol because you use

00:31:55,790 --> 00:31:59,620
one standardized API

00:32:02,990 --> 00:32:11,510
yeah and together of its kerberos you

00:32:07,490 --> 00:32:15,320
can also meet another specification or

00:32:11,510 --> 00:32:19,789
another API or another whatever it's

00:32:15,320 --> 00:32:23,870
called SPN ago and simple and protected

00:32:19,789 --> 00:32:27,350
gssapi negotiation mechanism it's

00:32:23,870 --> 00:32:31,279
nothing else then save the mechanism

00:32:27,350 --> 00:32:34,909
which allows you if for example client

00:32:31,279 --> 00:32:38,059
and server supports multiple multiple

00:32:34,909 --> 00:32:42,049
security protocol multiple security

00:32:38,059 --> 00:32:47,990
mechanisms then Jesus API itself doesn't

00:32:42,049 --> 00:32:49,399
provide ability to to negotiate which

00:32:47,990 --> 00:32:53,450
mechanism will be used

00:32:49,399 --> 00:32:58,700
so therefore the SPN goal was created

00:32:53,450 --> 00:33:02,090
and it provides this ability it can say

00:32:58,700 --> 00:33:07,220
I support this list of this list of

00:33:02,090 --> 00:33:09,950
mechanism and I'm sending tickets to you

00:33:07,220 --> 00:33:13,909
server pick one and we can communicate

00:33:09,950 --> 00:33:15,919
in the mechanism you will choose so it's

00:33:13,909 --> 00:33:20,929
for example used for Kerberos

00:33:15,919 --> 00:33:27,830
authentication in web browsers if if you

00:33:20,929 --> 00:33:30,289
know if you use Kerberos in in your web

00:33:27,830 --> 00:33:34,179
applications you are probably probably

00:33:30,289 --> 00:33:34,179
working through the Espina go

00:33:38,470 --> 00:33:48,159
and let's move to some pictures gssapi

00:33:43,750 --> 00:33:51,429
has two phases first is some loops of

00:33:48,159 --> 00:33:55,179
initialization when kind start

00:33:51,429 --> 00:33:59,110
communication with some init security

00:33:55,179 --> 00:34:02,289
context call and as a result there is

00:33:59,110 --> 00:34:03,399
some byte array as a token the token is

00:34:02,289 --> 00:34:05,909
sent to the seller

00:34:03,399 --> 00:34:10,149
it calls accept sick contacts error

00:34:05,909 --> 00:34:13,540
accepts a context and again the result

00:34:10,149 --> 00:34:16,510
is byte array and they can loop by

00:34:13,540 --> 00:34:22,409
sending the byte array tokens one to

00:34:16,510 --> 00:34:26,409
each other and once the one side decide

00:34:22,409 --> 00:34:28,960
the context is initialized they they can

00:34:26,409 --> 00:34:32,710
start with the second round and its

00:34:28,960 --> 00:34:37,839
message transport and it's very similar

00:34:32,710 --> 00:34:40,690
to what you may know from SSL engine on

00:34:37,839 --> 00:34:45,819
one side to you call wrap and put some

00:34:40,690 --> 00:34:48,369
byte array into it and you again get

00:34:45,819 --> 00:34:51,310
token as a result you listen to the

00:34:48,369 --> 00:34:54,129
tokens to the other side the other side

00:34:51,310 --> 00:34:59,670
cause unwrap and they they will

00:34:54,129 --> 00:34:59,670
communicate in this protected manner

00:35:02,819 --> 00:35:13,119
gssapi binding in for Java has its own

00:35:08,980 --> 00:35:19,150
RFC so which standardized standardized

00:35:13,119 --> 00:35:27,220
and you can find the GSS API in the

00:35:19,150 --> 00:35:31,000
package org dot I TF dot J GSS and there

00:35:27,220 --> 00:35:33,010
are few main classes which you should

00:35:31,000 --> 00:35:37,540
know about if you want to work with

00:35:33,010 --> 00:35:40,980
Jesus API entry point to the to do API

00:35:37,540 --> 00:35:43,839
is GSS manager which is fact factory for

00:35:40,980 --> 00:35:46,089
GSS contacts Jesus name and Jesus

00:35:43,839 --> 00:35:48,260
credentials Jesus context in the

00:35:46,089 --> 00:35:52,820
security context yeah

00:35:48,260 --> 00:35:55,550
which holds the state in Jesus name name

00:35:52,820 --> 00:35:58,720
represents name of the party for example

00:35:55,550 --> 00:36:02,030
name of the client name of the service

00:35:58,720 --> 00:36:06,650
justice credential represents credential

00:36:02,030 --> 00:36:09,650
of of the party and there are some

00:36:06,650 --> 00:36:12,530
additional some additional classes

00:36:09,650 --> 00:36:16,099
message properties where you can define

00:36:12,530 --> 00:36:26,410
for example that you want the next

00:36:16,099 --> 00:36:32,630
message to be encrypted so by default

00:36:26,410 --> 00:36:35,150
GSS API in Java retrieves Kerberos staff

00:36:32,630 --> 00:36:38,210
Gerber's credentials from just subject

00:36:35,150 --> 00:36:43,280
we we saw the first step of the protocol

00:36:38,210 --> 00:36:46,430
by using cap v login module which fills

00:36:43,280 --> 00:36:51,440
the just subject it's the proper stuff

00:36:46,430 --> 00:36:52,400
for GS s API but if you don't care about

00:36:51,440 --> 00:36:57,550
the Jazz

00:36:52,400 --> 00:37:01,460
you also can use the GSS API without

00:36:57,550 --> 00:37:04,280
doing the just stuff you just to differ

00:37:01,460 --> 00:37:10,060
you just have to define some just

00:37:04,280 --> 00:37:10,060
configuration in exactly named

00:37:10,270 --> 00:37:21,109
configuration ya entry either initiate

00:37:16,550 --> 00:37:27,619
for the kind side or except for server

00:37:21,109 --> 00:37:31,400
side and then the gssapi does the first

00:37:27,619 --> 00:37:34,609
step in the Kerberos Kerberos protocol

00:37:31,400 --> 00:37:37,520
for for you automatically you will also

00:37:34,609 --> 00:37:40,420
need to define additional system

00:37:37,520 --> 00:37:40,420
property for it

00:37:43,790 --> 00:37:54,590
short mentioned about Kerberos and Java

00:37:49,160 --> 00:37:59,600
on Windows if you have Windows

00:37:54,590 --> 00:38:05,500
workstation connected to a to a Active

00:37:59,600 --> 00:38:07,940
Directory domain once you login with an

00:38:05,500 --> 00:38:11,180
account which is registered in the

00:38:07,940 --> 00:38:16,190
domain you automatically have the ticket

00:38:11,180 --> 00:38:19,369
granting ticket so it's similar as if

00:38:16,190 --> 00:38:24,859
you login into your Linux machine and

00:38:19,369 --> 00:38:28,190
duque in it just after login and Java is

00:38:24,859 --> 00:38:34,310
able to access the distich 8 granting

00:38:28,190 --> 00:38:40,520
ticket but you have to allow it first in

00:38:34,310 --> 00:38:44,300
the in the windows registries and I've

00:38:40,520 --> 00:38:46,840
already mentioned the workaround for by

00:38:44,300 --> 00:38:52,670
importing the module active directory

00:38:46,840 --> 00:38:54,740
workaround for missing native K in it if

00:38:52,670 --> 00:38:56,359
you want to play with Windows

00:38:54,740 --> 00:38:58,670
environment and you don't want to

00:38:56,359 --> 00:38:59,810
install windows and to have Microsoft

00:38:58,670 --> 00:39:04,750
account

00:38:59,810 --> 00:39:08,510
there is one simple and nice template

00:39:04,750 --> 00:39:12,410
which you just click a button and it

00:39:08,510 --> 00:39:16,100
opens micros microsoft azure environment

00:39:12,410 --> 00:39:18,200
and starts for you 2 or 3 machines it

00:39:16,100 --> 00:39:21,320
depends if you want also some kind

00:39:18,200 --> 00:39:29,840
machine or or the active directory one

00:39:21,320 --> 00:39:34,130
and the server is enough for you and now

00:39:29,840 --> 00:39:39,680
let's compare Kerberos bits transport

00:39:34,130 --> 00:39:44,530
layer layer security which you use daily

00:39:39,680 --> 00:39:46,580
on daily basis in for example HTTP both

00:39:44,530 --> 00:39:51,260
provides you client server

00:39:46,580 --> 00:39:53,050
authentication but here is a difference

00:39:51,260 --> 00:39:56,450
by default

00:39:53,050 --> 00:40:00,230
TLS authenticate into us

00:39:56,450 --> 00:40:03,620
protocol the client verifies that the

00:40:00,230 --> 00:40:07,930
server is really the server it expects

00:40:03,620 --> 00:40:11,630
in Kerberos protocol it's opposite the

00:40:07,930 --> 00:40:17,810
the server verifies that the client is

00:40:11,630 --> 00:40:19,940
the kind it which should be so yeah but

00:40:17,810 --> 00:40:22,460
both of them supports mutual

00:40:19,940 --> 00:40:25,850
authentication so when once you enable

00:40:22,460 --> 00:40:30,380
mutual authentication both parties has

00:40:25,850 --> 00:40:33,230
to authenticate to each other both

00:40:30,380 --> 00:40:37,610
provides encryption and data integrity

00:40:33,230 --> 00:40:44,800
checks and data structures are described

00:40:37,610 --> 00:40:49,220
in abstract syntax notation dot one and

00:40:44,800 --> 00:40:53,270
it's abstract syntax notation and for

00:40:49,220 --> 00:40:58,490
example if you have if you have TLS

00:40:53,270 --> 00:41:01,570
certificates you can you can read the

00:40:58,490 --> 00:41:06,410
structure of it because they are

00:41:01,570 --> 00:41:19,220
included in the sn1 and I can show you

00:41:06,410 --> 00:41:25,160
how can it look like for example I as we

00:41:19,220 --> 00:41:30,860
saw the Kerberos request the Kerberos

00:41:25,160 --> 00:41:35,410
request the first step and in abstract

00:41:30,860 --> 00:41:36,680
syntax notation none of it could be like

00:41:35,410 --> 00:41:40,930
this

00:41:36,680 --> 00:41:47,360
some Kerberos version number and then

00:41:40,930 --> 00:41:54,320
another another data described in in

00:41:47,360 --> 00:41:57,560
this data structure and to understand

00:41:54,320 --> 00:42:00,710
what's included what should be included

00:41:57,560 --> 00:42:05,840
and what is included you can group in

00:42:00,710 --> 00:42:09,190
dirt into the RFC related to the topic

00:42:05,840 --> 00:42:12,700
so in our case it would be

00:42:09,190 --> 00:42:18,290
authentication a request and in the

00:42:12,700 --> 00:42:26,320
kerberos RFC you would find the the

00:42:18,290 --> 00:42:26,320
proper structure of of the data object

00:42:30,070 --> 00:42:36,680
the difference between Kerberos and TLS

00:42:33,320 --> 00:42:40,240
Kerberos usually used for single sign-on

00:42:36,680 --> 00:42:42,800
once you get the ticket granting ticket

00:42:40,240 --> 00:42:44,300
you don't care anymore for any

00:42:42,800 --> 00:42:48,790
authentication everything is

00:42:44,300 --> 00:42:52,310
automatically on the background

00:42:48,790 --> 00:42:55,490
credentials delegation only supported in

00:42:52,310 --> 00:42:58,370
the Kerberos so I've already mentioned

00:42:55,490 --> 00:43:02,060
it if you have some middle server middle

00:42:58,370 --> 00:43:05,750
tier it can impersonate the the client

00:43:02,060 --> 00:43:11,060
and go to the target server which

00:43:05,750 --> 00:43:13,970
identity of the client usually TLS is

00:43:11,060 --> 00:43:18,560
socket based and API and Kerberos is

00:43:13,970 --> 00:43:21,560
token based and because yeah it's token

00:43:18,560 --> 00:43:23,900
based you can use selective encryption

00:43:21,560 --> 00:43:26,390
and say this message will be encrypted

00:43:23,900 --> 00:43:29,270
this message will not be encrypted and

00:43:26,390 --> 00:43:33,580
for this message or we will only use

00:43:29,270 --> 00:43:37,040
some message integrity checks and

00:43:33,580 --> 00:43:46,580
Kerberos by default supports UDP and TCP

00:43:37,040 --> 00:43:50,930
and TLS D for TLS is just TCP the

00:43:46,580 --> 00:43:54,980
problem of the Kerberos is the KDC

00:43:50,930 --> 00:43:58,240
single point of failure and TLS doesn't

00:43:54,980 --> 00:43:58,240
have this problems

00:44:01,480 --> 00:44:10,960
yeah I've already show you that great

00:44:06,460 --> 00:44:14,260
tool for analyzing the Kerberos protocol

00:44:10,960 --> 00:44:16,440
is Marsh art yeah you can use it

00:44:14,260 --> 00:44:24,670
together of its tcpdump

00:44:16,440 --> 00:44:28,750
and you can dump abstract syntax

00:44:24,670 --> 00:44:34,960
notation structures which dump ASN or

00:44:28,750 --> 00:44:38,349
the Kerby provides API to to do the same

00:44:34,960 --> 00:44:42,430
to parse abstract syntax notation one

00:44:38,349 --> 00:44:48,869
data structures I'm listing here some

00:44:42,430 --> 00:44:55,510
properties to the back gssapi and and

00:44:48,869 --> 00:45:00,550
let's go on okay now I want to share

00:44:55,510 --> 00:45:06,460
with you an example how to employ the

00:45:00,550 --> 00:45:09,579
the Kerberos authentication into some

00:45:06,460 --> 00:45:12,970
client server application which doesn't

00:45:09,579 --> 00:45:19,270
support Kerberos but which which

00:45:12,970 --> 00:45:23,859
supports just authentication so the

00:45:19,270 --> 00:45:28,660
client needs to do this first step using

00:45:23,859 --> 00:45:33,099
curve I plug-in module then using the

00:45:28,660 --> 00:45:35,680
GSS api and initialization the security

00:45:33,099 --> 00:45:38,260
context we will do the second step and

00:45:35,680 --> 00:45:41,020
from the second step we will get the

00:45:38,260 --> 00:45:45,310
ticket which we will send to the server

00:45:41,020 --> 00:45:49,890
and it will accept the ticket so the the

00:45:45,310 --> 00:45:49,890
third step will be on the server side

00:45:50,460 --> 00:45:59,099
yeah the end on the server side too to

00:45:54,130 --> 00:46:03,940
finish this we also need to initial

00:45:59,099 --> 00:46:08,260
initialize the subject because the

00:46:03,940 --> 00:46:10,720
server needs to decrypt the ticket but

00:46:08,260 --> 00:46:14,980
the server doesn't need to talk to KDC

00:46:10,720 --> 00:46:18,270
so we will use the cup 5 login module

00:46:14,980 --> 00:46:29,470
in the offline mode or in the mode which

00:46:18,270 --> 00:46:34,089
doesn't contact ADC so because I work

00:46:29,470 --> 00:46:39,250
for hazel caste my my demo will be on

00:46:34,089 --> 00:46:44,950
hazel cast MDG he took us in memory data

00:46:39,250 --> 00:46:48,369
billet and it just creates cluster of

00:46:44,950 --> 00:46:52,930
servers and clients are accessing data

00:46:48,369 --> 00:46:56,020
stored in discussed and we used standard

00:46:52,930 --> 00:47:00,820
Java data structures for example Java

00:46:56,020 --> 00:47:04,089
util megabyte to set and data in in

00:47:00,820 --> 00:47:08,410
these data structures are stored in the

00:47:04,089 --> 00:47:10,720
Castro the problem is the security

00:47:08,410 --> 00:47:15,270
feature is not part of the open source

00:47:10,720 --> 00:47:19,450
version but if you look into the demo

00:47:15,270 --> 00:47:22,930
into the demo github project there is

00:47:19,450 --> 00:47:26,920
some evaluation license included so you

00:47:22,930 --> 00:47:30,940
can play with it and usual sample code

00:47:26,920 --> 00:47:34,990
for for hazel Casas in it for me either

00:47:30,940 --> 00:47:38,349
client or the server for get from the

00:47:34,990 --> 00:47:42,609
instance some for example map Java util

00:47:38,349 --> 00:47:47,609
map and use the map as a cache and it

00:47:42,609 --> 00:47:51,310
doesn't matter if if the server if the

00:47:47,609 --> 00:47:56,619
code which runs this for example your

00:47:51,310 --> 00:47:59,170
kind if it finishes the JVM and starts

00:47:56,619 --> 00:48:02,619
you the data will be stored somewhere on

00:47:59,170 --> 00:48:04,570
the cluster so if you run this again you

00:48:02,619 --> 00:48:10,180
will have access to the data which you

00:48:04,570 --> 00:48:13,510
start into into the data structure so

00:48:10,180 --> 00:48:16,060
the client code we will use the automate

00:48:13,510 --> 00:48:21,450
way so we will not touch subject in our

00:48:16,060 --> 00:48:27,000
kind application but we will just define

00:48:21,450 --> 00:48:33,369
the GSS GSS api

00:48:27,000 --> 00:48:35,820
configuration now the important part we

00:48:33,369 --> 00:48:38,859
will need to do the second step and

00:48:35,820 --> 00:48:43,630
retrieve ticket for the first third step

00:48:38,859 --> 00:48:46,420
of the Kerberos protocol so what we need

00:48:43,630 --> 00:48:50,740
to do manager GSS manager entry point

00:48:46,420 --> 00:48:56,500
from Jesus manager we create name of the

00:48:50,740 --> 00:49:02,040
target server or target service and we

00:48:56,500 --> 00:49:05,460
are creating context for the target name

00:49:02,040 --> 00:49:08,349
we don't request mutual authentication

00:49:05,460 --> 00:49:11,589
because only client says hey I'm the

00:49:08,349 --> 00:49:13,869
kind so those the kind doesn't need to

00:49:11,589 --> 00:49:19,380
verify that the server is really the

00:49:13,869 --> 00:49:24,339
server and we can call the context

00:49:19,380 --> 00:49:28,030
initialization because it is Kerberos

00:49:24,339 --> 00:49:30,990
protocol and we don't ask for mutual

00:49:28,030 --> 00:49:34,300
authentication we know that now the

00:49:30,990 --> 00:49:38,710
after the first coral of in a sec

00:49:34,300 --> 00:49:44,830
context the context is fully initialized

00:49:38,710 --> 00:49:48,250
and we can directly send the token so we

00:49:44,830 --> 00:49:51,970
have the token and this last piece of of

00:49:48,250 --> 00:49:54,970
the code is a zakat specific you just

00:49:51,970 --> 00:49:57,580
create a kind configuration and in

00:49:54,970 --> 00:50:01,420
security configuration we provide the

00:49:57,580 --> 00:50:05,260
byte array token as a as our credentials

00:50:01,420 --> 00:50:10,839
and we start the hesychast client on

00:50:05,260 --> 00:50:14,430
server side again we are using standard

00:50:10,839 --> 00:50:21,430
api and on server side we need to

00:50:14,430 --> 00:50:24,099
implement just login module so in in the

00:50:21,430 --> 00:50:28,270
just login module server is sending the

00:50:24,099 --> 00:50:31,780
token and just logging module has to be

00:50:28,270 --> 00:50:35,260
able to consume the token and provide it

00:50:31,780 --> 00:50:38,309
to GSS context created on server side

00:50:35,260 --> 00:50:42,509
and the server side calls

00:50:38,309 --> 00:50:47,130
except token and if it is correctly

00:50:42,509 --> 00:50:50,719
accepted we can get the kind name and

00:50:47,130 --> 00:50:54,449
finish successfully and that's it so

00:50:50,719 --> 00:51:01,469
that's all you need on the server side

00:50:54,449 --> 00:51:08,150
you can find the demo in the github

00:51:01,469 --> 00:51:08,150
project demo Kerberos in Java I can I

00:51:10,729 --> 00:51:19,939
can open it here so we have already the

00:51:20,420 --> 00:51:28,140
the server started and now if you look

00:51:24,150 --> 00:51:32,099
into hazel cast is look at package there

00:51:28,140 --> 00:51:36,859
is the login module login is pretty the

00:51:32,099 --> 00:51:41,789
same as you saw on the on the slide

00:51:36,859 --> 00:51:44,599
there are other other just login module

00:51:41,789 --> 00:51:49,559
method methods which needs to be

00:51:44,599 --> 00:51:51,779
provided but there is no important logic

00:51:49,559 --> 00:51:55,289
the only important is in the commit

00:51:51,779 --> 00:51:59,670
method you need to fill the names or the

00:51:55,289 --> 00:52:03,209
sub you you need to convert the names to

00:51:59,670 --> 00:52:06,779
two principles and fill the subject

00:52:03,209 --> 00:52:09,299
which the new principles in our case we

00:52:06,779 --> 00:52:17,939
provide some identity or some hard-coded

00:52:09,299 --> 00:52:23,569
role let's see that's it and here this

00:52:17,939 --> 00:52:27,299
is just his cast related code we are

00:52:23,569 --> 00:52:29,249
starting his own cast instance with some

00:52:27,299 --> 00:52:31,920
configuration and in the configuration

00:52:29,249 --> 00:52:35,969
the important part is we are defining

00:52:31,920 --> 00:52:42,269
security through the new custom login

00:52:35,969 --> 00:52:47,219
module so if we run this it should be

00:52:42,269 --> 00:52:48,520
started and if you if we look into the

00:52:47,219 --> 00:52:54,880
client

00:52:48,520 --> 00:52:57,010
I already said that the the first step

00:52:54,880 --> 00:52:59,350
of kind of Kerberos protocol will be

00:52:57,010 --> 00:53:05,070
automatically so we have to use this

00:52:59,350 --> 00:53:12,820
system property and we start with the

00:53:05,070 --> 00:53:18,250
second step so again GSS api and we saw

00:53:12,820 --> 00:53:22,000
it in the in the slide providing the

00:53:18,250 --> 00:53:27,280
token into current configuration and now

00:53:22,000 --> 00:53:31,619
just some Kerberos some his accost kind

00:53:27,280 --> 00:53:36,280
code so we are getting some math and

00:53:31,619 --> 00:53:43,750
putting current time into it under some

00:53:36,280 --> 00:53:51,670
cases if I run it there should be some

00:53:43,750 --> 00:53:54,100
message somewhere yeah I'm looking on

00:53:51,670 --> 00:53:56,320
the server side so I have to look into

00:53:54,100 --> 00:54:00,930
the kind this is the first run of the

00:53:56,320 --> 00:54:00,930
current application if I run it again

00:54:01,770 --> 00:54:04,770
then

00:54:07,150 --> 00:54:15,590
last kind application or rainbows

00:54:10,300 --> 00:54:19,760
so on the server the data are stored on

00:54:15,590 --> 00:54:25,609
the server and client accesses through

00:54:19,760 --> 00:54:28,460
standard Java util map the data the data

00:54:25,609 --> 00:54:34,670
on the server and stores a a new data

00:54:28,460 --> 00:54:39,350
and of course it does the just

00:54:34,670 --> 00:54:42,760
authentication in the meantime each each

00:54:39,350 --> 00:54:47,600
hazel caste can creation means

00:54:42,760 --> 00:54:54,200
communication which with the server so I

00:54:47,600 --> 00:54:59,750
think that's it and you can find some

00:54:54,200 --> 00:55:00,970
resources in my slides and that's it

00:54:59,750 --> 00:55:07,420
thank you

00:55:00,970 --> 00:55:07,420

YouTube URL: https://www.youtube.com/watch?v=jrpnBtxkdSk


