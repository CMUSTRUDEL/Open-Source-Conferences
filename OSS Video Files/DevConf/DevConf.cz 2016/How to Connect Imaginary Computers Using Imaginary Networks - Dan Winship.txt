Title: How to Connect Imaginary Computers Using Imaginary Networks - Dan Winship
Publication date: 2016-02-11
Playlist: DevConf.cz 2016
Description: 
	The increasing use of virtualization and containerization technologies has led to an explosion of "virtual" network devices and technologies--tun, veth, bridges, VLAN, VXLAN, Open vSwitch, and others. This talk will give an overview of these technologies, and show how they're used in OpenShift to connect containers together in a virtual network spanning multiple physical hosts.
Captions: 
	00:00:00,829 --> 00:00:07,230
connect a file descriptor in userspace

00:00:03,240 --> 00:00:09,330
to a network interface in the kernel the

00:00:07,230 --> 00:00:11,639
difference between them is that if you

00:00:09,330 --> 00:00:13,590
have a ton device you read and write IP

00:00:11,639 --> 00:00:17,250
packets if you have a tab device you

00:00:13,590 --> 00:00:20,039
read and write raw Ethernet packets and

00:00:17,250 --> 00:00:21,840
this is used by virtualization for qmu

00:00:20,039 --> 00:00:24,240
for instance will create a tap device

00:00:21,840 --> 00:00:27,150
launched the vm it will attach the

00:00:24,240 --> 00:00:28,500
kernel network side to its imaginary

00:00:27,150 --> 00:00:30,689
local network which we'll get to later

00:00:28,500 --> 00:00:32,850
and then it uses the user space side to

00:00:30,689 --> 00:00:36,840
emulate a network card for the virtual

00:00:32,850 --> 00:00:39,090
machine so you can see here we have a

00:00:36,840 --> 00:00:42,059
computer running virtual machines each

00:00:39,090 --> 00:00:50,640
one has a tap device which connects

00:00:42,059 --> 00:00:53,730
directly to the real Colonel and with

00:00:50,640 --> 00:00:57,570
containers we tend to use veith pairs so

00:00:53,730 --> 00:01:01,260
V is a virtual ethernet interface when

00:00:57,570 --> 00:01:03,390
you create one with IP link it actually

00:01:01,260 --> 00:01:05,430
creates a pair of interfaces rather than

00:01:03,390 --> 00:01:08,970
only one like with the tunnel device and

00:01:05,430 --> 00:01:10,799
those two interfaces are a tunnel so

00:01:08,970 --> 00:01:12,420
that any packet that goes into one of

00:01:10,799 --> 00:01:15,600
them comes out the other one and vice

00:01:12,420 --> 00:01:18,090
versa normally that would be completely

00:01:15,600 --> 00:01:20,939
useless but with containers you can move

00:01:18,090 --> 00:01:23,869
one side of the tunnel into a different

00:01:20,939 --> 00:01:26,909
network namespace in a container and

00:01:23,869 --> 00:01:31,590
then you basically have a tunnel from

00:01:26,909 --> 00:01:38,670
inside the container to outside into the

00:01:31,590 --> 00:01:40,439
the main network namespace the third

00:01:38,670 --> 00:01:42,450
possibility for an imaginary network

00:01:40,439 --> 00:01:46,920
card is to actually use a real network

00:01:42,450 --> 00:01:48,659
card you can assign a real network card

00:01:46,920 --> 00:01:50,340
directly to a virtual machine or

00:01:48,659 --> 00:01:55,049
container if you're using virtualization

00:01:50,340 --> 00:01:57,090
there are CPU extensions like v TD that

00:01:55,049 --> 00:02:00,000
allow you to have the virtual machine

00:01:57,090 --> 00:02:02,579
directly talk to your your PCI card or

00:02:00,000 --> 00:02:04,439
whatever if you're using containers you

00:02:02,579 --> 00:02:06,329
can just move your real ethernet card

00:02:04,439 --> 00:02:09,390
into the network name space just like

00:02:06,329 --> 00:02:12,670
you would do with a beef pair and then

00:02:09,390 --> 00:02:14,800
the container can access it

00:02:12,670 --> 00:02:17,050
problem with this is that you probably

00:02:14,800 --> 00:02:23,080
have more virtual machines than you have

00:02:17,050 --> 00:02:25,080
network cards so they came up with

00:02:23,080 --> 00:02:27,520
something called single route io

00:02:25,080 --> 00:02:29,830
virtualization where if you have a very

00:02:27,520 --> 00:02:33,340
expensive network card it can pretend to

00:02:29,830 --> 00:02:35,920
be multiple virtual network cards and

00:02:33,340 --> 00:02:38,470
then you can assign usually it's either

00:02:35,920 --> 00:02:40,660
16 or 64 so you can then assign one of

00:02:38,470 --> 00:02:44,769
the virtual network cards to each

00:02:40,660 --> 00:02:45,940
virtual machine or container mostly

00:02:44,769 --> 00:02:49,019
virtual machines people aren't really

00:02:45,940 --> 00:02:52,360
using this with containers yet or much

00:02:49,019 --> 00:02:54,370
and then each of those virtual network

00:02:52,360 --> 00:02:56,799
cards essentially connects directly to

00:02:54,370 --> 00:02:59,110
the physical Ethernet without going

00:02:56,799 --> 00:03:01,480
through the kernel or hypervisor or

00:02:59,110 --> 00:03:02,980
anything else which on one hand is

00:03:01,480 --> 00:03:05,500
efficient on the other hand it means

00:03:02,980 --> 00:03:08,110
that you can't do extra firewalling or

00:03:05,500 --> 00:03:10,000
filtering on that card so it's only

00:03:08,110 --> 00:03:11,230
useful in a situation where you want the

00:03:10,000 --> 00:03:19,239
virtual machine to have complete access

00:03:11,230 --> 00:03:21,250
to the local network ok so we have a

00:03:19,239 --> 00:03:23,769
virtual and imaginary computer with an

00:03:21,250 --> 00:03:24,910
imaginary network card now we need to be

00:03:23,769 --> 00:03:29,739
able to talk to other imaginary

00:03:24,910 --> 00:03:33,549
computers there are two basic ways that

00:03:29,739 --> 00:03:35,650
people do this using Linux bridges which

00:03:33,549 --> 00:03:38,650
is the more basic the older technology

00:03:35,650 --> 00:03:41,590
or using open V switch either way the

00:03:38,650 --> 00:03:43,840
idea is is basically the same you have a

00:03:41,590 --> 00:03:45,910
bunch of VMs or a bunch of containers

00:03:43,840 --> 00:03:47,970
and they're all connected to a bridge

00:03:45,910 --> 00:03:50,350
which lets them talk to each other and

00:03:47,970 --> 00:03:55,930
possibly the bridge is connected to the

00:03:50,350 --> 00:03:58,299
outside world somehow so with Linux

00:03:55,930 --> 00:04:00,430
bridges and I say clinics bridges just

00:03:58,299 --> 00:04:03,489
to differentiate them from Hardware

00:04:00,430 --> 00:04:07,120
bridges or open V switch or anything

00:04:03,489 --> 00:04:09,880
like that it's just a simple network

00:04:07,120 --> 00:04:11,970
switch in the kernel you attach network

00:04:09,880 --> 00:04:14,950
interfaces to it they're called ports

00:04:11,970 --> 00:04:20,560
and then the colonel deals with routing

00:04:14,950 --> 00:04:22,450
traffic between the different ports you

00:04:20,560 --> 00:04:24,099
can add a real ethernet interface to

00:04:22,450 --> 00:04:26,500
your bridge as well if you want external

00:04:24,099 --> 00:04:28,360
connectivity sometimes instead

00:04:26,500 --> 00:04:31,300
doing that people will just use NAT and

00:04:28,360 --> 00:04:35,440
use iptables rules to connect the bridge

00:04:31,300 --> 00:04:38,770
to the external ethernet device that's

00:04:35,440 --> 00:04:41,170
the default behavior in for virtual

00:04:38,770 --> 00:04:42,790
machines with liver a lot of the time

00:04:41,170 --> 00:04:50,020
just because it requires less

00:04:42,790 --> 00:04:52,000
configuration you can use IP tables to a

00:04:50,020 --> 00:04:53,770
limited extent to control the flow of

00:04:52,000 --> 00:04:56,310
traffic along the bridge but for the

00:04:53,770 --> 00:04:59,050
most part the traffic just flows freely

00:04:56,310 --> 00:05:02,080
every machine can talk to every other

00:04:59,050 --> 00:05:03,850
machine if you want to do more

00:05:02,080 --> 00:05:06,610
complicated things you can use something

00:05:03,850 --> 00:05:09,190
like open V switch open vs which is a

00:05:06,610 --> 00:05:11,800
combined user space and Colonel networks

00:05:09,190 --> 00:05:15,250
which you can program it using the

00:05:11,800 --> 00:05:17,860
language called open flow which lets you

00:05:15,250 --> 00:05:21,370
control the traffic flow there's an

00:05:17,860 --> 00:05:22,690
example open flow rule here I'll be

00:05:21,370 --> 00:05:24,820
talking more about that a little bit

00:05:22,690 --> 00:05:26,770
later so the details don't matter but

00:05:24,820 --> 00:05:29,220
you can see this one is is routing IP

00:05:26,770 --> 00:05:32,590
packets that are going to a certain

00:05:29,220 --> 00:05:34,630
network and does a bunch of stuff with

00:05:32,590 --> 00:05:39,460
them and then eventually outputs it to

00:05:34,630 --> 00:05:41,229
port one at the end there so open vs

00:05:39,460 --> 00:05:43,720
which has both the user space component

00:05:41,229 --> 00:05:46,090
and a kernel component the the user

00:05:43,720 --> 00:05:48,669
space part manages the database of all

00:05:46,090 --> 00:05:50,860
the rules and interprets the rules when

00:05:48,669 --> 00:05:54,580
new traffic comes in the kernel part

00:05:50,860 --> 00:05:56,229
routes traffic more quickly once the

00:05:54,580 --> 00:05:58,780
user land part has already figured out

00:05:56,229 --> 00:06:10,000
where the package should go matching a

00:05:58,780 --> 00:06:12,100
given rule ok so we have a imaginary

00:06:10,000 --> 00:06:14,530
network on the local machine we want to

00:06:12,100 --> 00:06:17,229
connect to other machines so that you

00:06:14,530 --> 00:06:19,060
can have a whole cluster of computers

00:06:17,229 --> 00:06:22,440
running virtual machines or containers

00:06:19,060 --> 00:06:22,440
and have them all talking to each other

00:06:22,710 --> 00:06:28,120
there are a handful of protocols

00:06:25,260 --> 00:06:30,070
actually there are a zillion protocols

00:06:28,120 --> 00:06:34,720
everyone keeps coming up with their own

00:06:30,070 --> 00:06:36,940
new protocol for doing this one of the

00:06:34,720 --> 00:06:39,960
most popular right now is VX land the

00:06:36,940 --> 00:06:43,720
virtual extensible land

00:06:39,960 --> 00:06:46,180
it allows you to take arbitrary Ethernet

00:06:43,720 --> 00:06:47,590
packets it wraps them up in a UDP packet

00:06:46,180 --> 00:06:51,610
and then you can just send them to any

00:06:47,590 --> 00:06:53,950
other computer each packet also has a

00:06:51,610 --> 00:06:57,460
24-bit what they call virtual network

00:06:53,950 --> 00:06:59,230
identifier so that which works like VLAN

00:06:57,460 --> 00:07:01,330
identifiers so that you can have

00:06:59,230 --> 00:07:05,440
different flows of traffic all using the

00:07:01,330 --> 00:07:10,390
same VX lamb tunnel in open shift we use

00:07:05,440 --> 00:07:12,190
that to do isolation between containers

00:07:10,390 --> 00:07:15,700
that are owned by different projects we

00:07:12,190 --> 00:07:18,670
assign different VN IDs to them and then

00:07:15,700 --> 00:07:22,410
use that to control which traffic can go

00:07:18,670 --> 00:07:22,410
into which containers on the other side

00:07:22,860 --> 00:07:27,910
so one problem with doing this is that

00:07:25,630 --> 00:07:29,950
because you have an inner packet and an

00:07:27,910 --> 00:07:31,870
outer packet you need two different

00:07:29,950 --> 00:07:35,440
checksums or two different sets of

00:07:31,870 --> 00:07:37,720
checksums on it both the inner Ethernet

00:07:35,440 --> 00:07:42,030
and IP packet and the outer ethernet and

00:07:37,720 --> 00:07:45,190
IP packet and so Hardware cards that do

00:07:42,030 --> 00:07:47,350
checksum offloading initially could not

00:07:45,190 --> 00:07:49,750
deal with that they could do one set of

00:07:47,350 --> 00:07:51,850
check sums but not the other one and so

00:07:49,750 --> 00:07:54,610
you ended up losing a lot of performance

00:07:51,850 --> 00:07:57,160
on your network newer ethernet cards now

00:07:54,610 --> 00:08:08,620
have special handling for VX land to get

00:07:57,160 --> 00:08:11,710
that back before people started making

00:08:08,620 --> 00:08:13,450
network cards that supported I'm sorry

00:08:11,710 --> 00:08:15,550
no this is not checksum offloading this

00:08:13,450 --> 00:08:17,950
is TCP segment offloading so another

00:08:15,550 --> 00:08:20,170
thing that some network cards do is they

00:08:17,950 --> 00:08:22,840
can automatically do TCP segmentation

00:08:20,170 --> 00:08:24,190
for you so when you send big packets it

00:08:22,840 --> 00:08:25,870
will break it up for you and recheck

00:08:24,190 --> 00:08:28,500
some of them and all that again

00:08:25,870 --> 00:08:30,400
encapsulation like VX lan breaks that

00:08:28,500 --> 00:08:33,970
vmware came up with something called

00:08:30,400 --> 00:08:36,100
stateless transport tunneling where they

00:08:33,970 --> 00:08:37,750
they wrapped the packets inside other

00:08:36,100 --> 00:08:39,130
packets that look like they're TCP

00:08:37,750 --> 00:08:41,500
packets even though they aren't really

00:08:39,130 --> 00:08:45,040
and then the network card gets fooled

00:08:41,500 --> 00:08:47,770
into doing TCP segmentation offload for

00:08:45,040 --> 00:08:51,520
it automatically no one other than

00:08:47,770 --> 00:08:52,540
VMware really uses this though Microsoft

00:08:51,520 --> 00:08:55,509
meanwhile is using

00:08:52,540 --> 00:08:59,740
nvg re which is an extension to the GRE

00:08:55,509 --> 00:09:01,810
tunneling protocol again as a 24-bit

00:08:59,740 --> 00:09:06,910
identifier everyone seems to have pretty

00:09:01,810 --> 00:09:10,899
much settled on 24-bit identifiers it's

00:09:06,910 --> 00:09:14,380
used by Microsoft of course we all know

00:09:10,899 --> 00:09:18,279
what happens when you have multiple

00:09:14,380 --> 00:09:20,380
competing standards so now there's a

00:09:18,279 --> 00:09:24,819
standard called geneve generic network

00:09:20,380 --> 00:09:26,920
virtualization which is mostly the same

00:09:24,819 --> 00:09:30,600
as VX lan except they've now added

00:09:26,920 --> 00:09:32,529
variable length extensible headers

00:09:30,600 --> 00:09:34,060
everyone seems convinced that we're

00:09:32,529 --> 00:09:35,560
going to need these at some point I

00:09:34,060 --> 00:09:37,360
haven't actually seen any examples of

00:09:35,560 --> 00:09:38,529
what it will be used for but but

00:09:37,360 --> 00:09:41,620
everyone agrees we want to have

00:09:38,529 --> 00:09:43,089
extensions it's designed so that the

00:09:41,620 --> 00:09:45,100
routers don't need to understand the

00:09:43,089 --> 00:09:47,170
extensions and can still pass on the

00:09:45,100 --> 00:09:49,540
packets and you can still have hardware

00:09:47,170 --> 00:09:51,279
that will deal with the checksum

00:09:49,540 --> 00:09:54,579
offloading without understanding all of

00:09:51,279 --> 00:09:56,470
the extensions so in there is hardware

00:09:54,579 --> 00:09:59,620
that does that already even though no

00:09:56,470 --> 00:10:01,329
one is really using it yet but everyone

00:09:59,620 --> 00:10:03,600
is sure that we're going to be using it

00:10:01,329 --> 00:10:03,600
at some point

00:10:08,270 --> 00:10:15,770
so at the moment openshift openstack

00:10:13,700 --> 00:10:18,590
various other things are using open V

00:10:15,770 --> 00:10:21,310
switch for their local network and then

00:10:18,590 --> 00:10:24,740
VX land for connectivity between

00:10:21,310 --> 00:10:26,240
different computers everyone is doing it

00:10:24,740 --> 00:10:29,480
slightly differently with their own set

00:10:26,240 --> 00:10:31,100
of rules so the open Beast which people

00:10:29,480 --> 00:10:33,560
are now working on something called ovn

00:10:31,100 --> 00:10:35,660
open virtual network which will provide

00:10:33,560 --> 00:10:37,670
a generic implementation of this that

00:10:35,660 --> 00:10:42,290
hopefully everyone can use it's going to

00:10:37,670 --> 00:10:48,530
use geneve I'm not sure exactly how

00:10:42,290 --> 00:10:50,090
close to done it is and then there are

00:10:48,530 --> 00:10:53,420
all these other projects we've and

00:10:50,090 --> 00:10:55,550
flannel we're both created for using or

00:10:53,420 --> 00:10:58,040
for use with Cooper Nettie's which is

00:10:55,550 --> 00:10:59,830
Google's container orchestration system

00:10:58,040 --> 00:11:03,610
which openshift is built on top of

00:10:59,830 --> 00:11:07,060
calico and contrail are other projects

00:11:03,610 --> 00:11:09,860
neutron is open stacks networking layer

00:11:07,060 --> 00:11:11,780
it has its own architecture but then has

00:11:09,860 --> 00:11:13,550
plugins within that so you can have an

00:11:11,780 --> 00:11:16,580
open V switch plug-in or a calico

00:11:13,550 --> 00:11:17,690
plug-in or a contrail plug-in eventually

00:11:16,580 --> 00:11:19,670
they decided that there were too many

00:11:17,690 --> 00:11:21,380
plugins so they came up with the modular

00:11:19,670 --> 00:11:24,890
late whoops that should be modular not

00:11:21,380 --> 00:11:27,830
module modular layer to plug-in which

00:11:24,890 --> 00:11:30,170
sort of encapsulates the ideas that were

00:11:27,830 --> 00:11:32,600
common to all of their plugins and then

00:11:30,170 --> 00:11:39,020
it has plugins inside it so so it's a

00:11:32,600 --> 00:11:41,450
plug-in that has plugins but it's

00:11:39,020 --> 00:11:48,470
currently the recommended networking

00:11:41,450 --> 00:11:51,230
plug in 4 for OpenStack so open shift as

00:11:48,470 --> 00:11:53,390
i said is an orchestration framework for

00:11:51,230 --> 00:11:55,610
containers it's built on top of cooper

00:11:53,390 --> 00:11:57,980
Nettie's which is google's basic

00:11:55,610 --> 00:12:00,080
orchestration system which in turn is

00:11:57,980 --> 00:12:01,550
built on top of docker which is the

00:12:00,080 --> 00:12:03,290
system for running containers on a

00:12:01,550 --> 00:12:05,390
single local machine but doesn't worry

00:12:03,290 --> 00:12:07,900
as much about the the problem of

00:12:05,390 --> 00:12:11,150
multiple containers on multiple machines

00:12:07,900 --> 00:12:13,760
open ship uses a networking

00:12:11,150 --> 00:12:15,980
implementation called openshift Sdn that

00:12:13,760 --> 00:12:20,660
like i said before uses open V switch

00:12:15,980 --> 00:12:23,600
and VX LAN initially

00:12:20,660 --> 00:12:25,519
the openshift sdn implementation allowed

00:12:23,600 --> 00:12:28,550
all containers to talk to all other

00:12:25,519 --> 00:12:31,250
containers the more recent version of it

00:12:28,550 --> 00:12:35,449
is multi-tenant which means that each

00:12:31,250 --> 00:12:37,129
project which is a openshift concept for

00:12:35,449 --> 00:12:39,620
dividing up the containers each project

00:12:37,129 --> 00:12:41,990
has its own ID which then gets used on

00:12:39,620 --> 00:12:44,209
the VX land and in the open flow rules

00:12:41,990 --> 00:12:46,540
so that different projects can't talk to

00:12:44,209 --> 00:12:48,670
containers in other projects and

00:12:46,540 --> 00:12:51,470
therefore you can have a single

00:12:48,670 --> 00:12:53,480
openshift cluster with multiple

00:12:51,470 --> 00:12:55,189
customers that don't necessarily trust

00:12:53,480 --> 00:13:05,540
each other and all of their traffic is

00:12:55,189 --> 00:13:07,579
kept separate so it uses open V switch

00:13:05,540 --> 00:13:09,949
which uses open flow rules and and this

00:13:07,579 --> 00:13:14,300
is sort of an example of some of the

00:13:09,949 --> 00:13:16,639
kinds of rules that it uses so ok that's

00:13:14,300 --> 00:13:18,769
not really that visible traffic coming

00:13:16,639 --> 00:13:22,250
out of a container here you see we match

00:13:18,769 --> 00:13:25,279
in port which which identifies which

00:13:22,250 --> 00:13:27,740
port or which interface the traffic is

00:13:25,279 --> 00:13:29,209
coming in from we check that it has the

00:13:27,740 --> 00:13:31,610
right source address to make sure that

00:13:29,209 --> 00:13:34,370
people aren't spoofing and are using the

00:13:31,610 --> 00:13:37,100
IP address that we expect them to this

00:13:34,370 --> 00:13:39,199
load instruction here sets a register to

00:13:37,100 --> 00:13:41,439
this value which is the tenant ID or

00:13:39,199 --> 00:13:45,829
network ID for this particular container

00:13:41,439 --> 00:13:48,680
and then go to table tells it to you

00:13:45,829 --> 00:13:52,519
know go to a different table within the

00:13:48,680 --> 00:13:55,730
the openflow rules where more rules get

00:13:52,519 --> 00:13:59,000
processed later on we have this rule

00:13:55,730 --> 00:14:01,399
which directs traffic to another node so

00:13:59,000 --> 00:14:03,410
it's saying if you have IP traffic which

00:14:01,399 --> 00:14:06,880
is destined for any of these IP

00:14:03,410 --> 00:14:09,350
addresses in this network range then and

00:14:06,880 --> 00:14:11,899
again so there's this rule that moves

00:14:09,350 --> 00:14:15,380
the the network ID into the tunnel ID

00:14:11,899 --> 00:14:17,600
field sets the tunnel destination to the

00:14:15,380 --> 00:14:19,699
IP address of the other host where where

00:14:17,600 --> 00:14:22,069
this virtual network is hosted and then

00:14:19,699 --> 00:14:27,559
outputs it on port one which happens to

00:14:22,069 --> 00:14:31,189
be the VX land port and then as traffic

00:14:27,559 --> 00:14:33,160
arrives on coming in port one we go to

00:14:31,189 --> 00:14:35,920
another table where

00:14:33,160 --> 00:14:38,350
we verify that it has the right

00:14:35,920 --> 00:14:40,199
destination load the tunnel ID into

00:14:38,350 --> 00:14:42,819
register 0 go to a different table

00:14:40,199 --> 00:14:46,420
eventually we get to the table where we

00:14:42,819 --> 00:14:48,910
match on the container IP address and

00:14:46,420 --> 00:14:50,740
match that the the tunnel ID is what we

00:14:48,910 --> 00:14:54,670
expect it to and if it does then we out

00:14:50,740 --> 00:15:02,230
put it on the right port and it goes to

00:14:54,670 --> 00:15:04,420
a container for a lot more details on

00:15:02,230 --> 00:15:06,730
how openshift networking works there's

00:15:04,420 --> 00:15:09,339
another talk later today networking in a

00:15:06,730 --> 00:15:16,689
container world raja chopra who is up

00:15:09,339 --> 00:15:24,759
there and that is at four-thirty

00:15:16,689 --> 00:15:29,129
downstairs from here and that is all i

00:15:24,759 --> 00:15:29,129
have people have questions

00:15:41,010 --> 00:15:47,190
yes you don't count you're my boss

00:15:58,560 --> 00:16:02,800
s'okay so he's asking is there a drive

00:16:00,730 --> 00:16:07,030
to make the syntax simpler because this

00:16:02,800 --> 00:16:08,650
is way too complicated you can use

00:16:07,030 --> 00:16:14,800
simple syntax if you want to do simple

00:16:08,650 --> 00:16:16,930
things I guess you know it makes sense

00:16:14,800 --> 00:16:20,080
once you learn it all it's pretty simple

00:16:16,930 --> 00:16:21,310
there there you know different criteria

00:16:20,080 --> 00:16:24,040
that you can match on here we're

00:16:21,310 --> 00:16:30,610
matching IP packets this is you know the

00:16:24,040 --> 00:16:32,740
source network source so no open flow is

00:16:30,610 --> 00:16:34,570
a standard it's not only used by open V

00:16:32,740 --> 00:16:38,980
switch it's also actually used by some

00:16:34,570 --> 00:16:41,140
hardware routers and it's actually being

00:16:38,980 --> 00:16:54,190
extended with more syntax and more

00:16:41,140 --> 00:16:56,220
different possibilities so yep so the

00:16:54,190 --> 00:17:00,100
question is have we done any work with

00:16:56,220 --> 00:17:08,709
external OpenFlow routers repeaters

00:17:00,100 --> 00:17:18,420
talking to the containers no so calico

00:17:08,709 --> 00:17:24,190
uses GG the GMP or bgp thank you too to

00:17:18,420 --> 00:17:27,430
control routing tables on on routers but

00:17:24,190 --> 00:17:28,900
yeah i mean if we were going to use open

00:17:27,430 --> 00:17:30,630
flow to talk to external repeaters and

00:17:28,900 --> 00:17:35,250
that would limit what sort of hardware

00:17:30,630 --> 00:17:37,330
people could use open shift with and so

00:17:35,250 --> 00:17:40,240
we're not worrying about that we're just

00:17:37,330 --> 00:17:44,670
assuming IP connectivity between the

00:17:40,240 --> 00:17:44,670
different posts holding the containers

00:18:00,250 --> 00:18:06,350
so he's saying is there a way to not

00:18:04,490 --> 00:18:09,200
have all of these hard-coded magic

00:18:06,350 --> 00:18:11,870
numbers like import five and output 1

00:18:09,200 --> 00:18:15,950
and table 5 and all that the answer is

00:18:11,870 --> 00:18:18,890
no although I've been thinking about at

00:18:15,950 --> 00:18:20,779
least making it so internally when we're

00:18:18,890 --> 00:18:22,460
referring to all the rules inside open

00:18:20,779 --> 00:18:24,649
ships to have something that lets you

00:18:22,460 --> 00:18:25,840
substitute in variable names or

00:18:24,649 --> 00:18:28,159
something and then it will just

00:18:25,840 --> 00:18:33,429
translate those to the raw numbers

00:18:28,159 --> 00:18:33,429
before passing it to 0 vs 0 f control

00:18:43,910 --> 00:18:56,490
okay what happens when you i missed the

00:18:46,290 --> 00:18:58,410
very beginning okay so you're saying

00:18:56,490 --> 00:19:01,980
what happens when you add a new node to

00:18:58,410 --> 00:19:03,720
the open shift cluster each node listens

00:19:01,980 --> 00:19:05,550
for notifications from the open shift

00:19:03,720 --> 00:19:10,050
master and when it sees that a new node

00:19:05,550 --> 00:19:14,040
has been added it will add new rules

00:19:10,050 --> 00:19:17,660
like like like this one basically

00:19:14,040 --> 00:19:24,200
there's one of these rules for each node

00:19:17,660 --> 00:19:27,540
so that it knows which which subnet of

00:19:24,200 --> 00:19:29,400
which container subnet is on which node

00:19:27,540 --> 00:19:43,350
and then it has to add a rule for each

00:19:29,400 --> 00:19:45,780
one so sorry the master tells the nose

00:19:43,350 --> 00:19:48,690
when a new node has been created and

00:19:45,780 --> 00:19:53,130
then each node adds a rule to its own

00:19:48,690 --> 00:19:55,320
local open V switch its database I'm

00:19:53,130 --> 00:19:58,500
supposed to be throwing scarves at

00:19:55,320 --> 00:20:02,540
people but they don't really throw very

00:19:58,500 --> 00:20:02,540
well so let me try tying in a knot

00:20:41,279 --> 00:20:59,229
okay so you're asking about security

00:20:43,869 --> 00:21:01,210
specifically ok so what technology would

00:20:59,229 --> 00:21:05,889
recommend for connecting open V switches

00:21:01,210 --> 00:21:07,779
between long distances so the nice thing

00:21:05,889 --> 00:21:11,080
about VX LAN as opposed to something

00:21:07,779 --> 00:21:12,669
like VLAN is that it it's layer three so

00:21:11,080 --> 00:21:16,349
as long as you have IP connectivity

00:21:12,669 --> 00:21:19,359
between the different openshift nodes

00:21:16,349 --> 00:21:23,559
they can send packets to each other the

00:21:19,359 --> 00:21:26,289
ex LAN is not encrypted so there are

00:21:23,559 --> 00:21:28,779
people who are looking at using IPSec oh

00:21:26,289 --> 00:21:31,119
and then sending the VX land packets

00:21:28,779 --> 00:21:32,739
over an ipsec tunnel we don't have any

00:21:31,119 --> 00:21:34,239
support for configuring that

00:21:32,739 --> 00:21:36,960
automatically but it's definitely

00:21:34,239 --> 00:21:40,139
something that we're looking at for now

00:21:36,960 --> 00:21:43,809
it's generally assumed that all of the

00:21:40,139 --> 00:21:46,269
nodes are within you know the on the

00:21:43,809 --> 00:21:49,059
same network basically and that you know

00:21:46,269 --> 00:21:51,039
more or less trust that network or you

00:21:49,059 --> 00:21:52,720
have some sort of VPN or something

00:21:51,039 --> 00:21:56,950
connecting your different data centers

00:21:52,720 --> 00:21:59,789
so that the so that the packets get

00:21:56,950 --> 00:21:59,789
encrypted by that

00:22:04,090 --> 00:22:35,389
yeah their plans are creating some

00:22:28,970 --> 00:22:42,529
others because is the tendency for

00:22:35,389 --> 00:22:45,669
example Cisco also optimizes accelerate

00:22:42,529 --> 00:22:48,679
the traffic separate container or

00:22:45,669 --> 00:22:50,600
emotional because post and you can

00:22:48,679 --> 00:22:53,990
easily manage now we have still the

00:22:50,600 --> 00:22:57,370
problem that you need to a network guy

00:22:53,990 --> 00:23:00,379
that will create all the little stuff

00:22:57,370 --> 00:23:04,269
between the computers yes is there any

00:23:00,379 --> 00:23:07,269
plan rather low pitch while Reuters or

00:23:04,269 --> 00:23:07,269
fire

00:23:08,200 --> 00:23:14,420
at the moment the the planet with open

00:23:12,050 --> 00:23:18,380
shifted okay so the question is if we

00:23:14,420 --> 00:23:21,800
have plans for four more security or

00:23:18,380 --> 00:23:24,050
other fast connectivity whatever stuff

00:23:21,800 --> 00:23:26,000
between open Jeff nodes at the moment

00:23:24,050 --> 00:23:30,500
we're just working on the the simple

00:23:26,000 --> 00:23:32,090
case basically but open shift is built

00:23:30,500 --> 00:23:34,340
on top of Cooper Nettie's which has its

00:23:32,090 --> 00:23:36,140
own network plug-in system and so people

00:23:34,340 --> 00:23:37,730
will be able to write other network

00:23:36,140 --> 00:23:40,190
plugins that they can substitute in

00:23:37,730 --> 00:23:43,570
there are people who were working with

00:23:40,190 --> 00:23:46,270
who are creating more complicated or

00:23:43,570 --> 00:23:49,100
systems that plug into their own

00:23:46,270 --> 00:23:56,630
networking infrastructure i'm not sure

00:23:49,100 --> 00:23:59,300
if cisco is one of them or not basically

00:23:56,630 --> 00:24:01,640
the workmen would open this situation so

00:23:59,300 --> 00:24:03,290
there is a lot of this stuff that there

00:24:01,640 --> 00:24:07,310
is open visitation side of us respect

00:24:03,290 --> 00:24:09,350
for the open ship inside of a spec so we

00:24:07,310 --> 00:24:12,470
shove their those the MTU drops and

00:24:09,350 --> 00:24:13,610
awesome job yes mechanism or something

00:24:12,470 --> 00:24:15,110
in the world Scott why do we detect

00:24:13,610 --> 00:24:17,270
because I had really problems with at

00:24:15,110 --> 00:24:19,190
you when it says day for you to

00:24:17,270 --> 00:24:21,020
something higher than a view of the

00:24:19,190 --> 00:24:22,940
lower right there and it drops big

00:24:21,020 --> 00:24:26,060
packets so the question is about using

00:24:22,940 --> 00:24:29,050
open shift inside OpenStack and and

00:24:26,060 --> 00:24:32,510
problems with MTU and stuff like that so

00:24:29,050 --> 00:24:37,010
one way that people are deploying open

00:24:32,510 --> 00:24:40,400
shift is on openstack-based clouds so

00:24:37,010 --> 00:24:42,710
you have your OpenStack with its open V

00:24:40,400 --> 00:24:45,230
switch and and tunnels and an open shift

00:24:42,710 --> 00:24:46,970
running on the virtual machines with its

00:24:45,230 --> 00:24:49,370
tunnels and so it's tunnels are going

00:24:46,970 --> 00:24:51,830
through openstax tunnels and you lose a

00:24:49,370 --> 00:24:55,300
little bit of Mt you at each step not to

00:24:51,830 --> 00:24:58,520
mention that it's horribly inefficient

00:24:55,300 --> 00:25:03,010
we we have a Trello card open about

00:24:58,520 --> 00:25:05,090
creating a network plugin we're

00:25:03,010 --> 00:25:07,430
essentially open shift would be aware of

00:25:05,090 --> 00:25:10,360
open Stax networking so that you could

00:25:07,430 --> 00:25:12,380
avoid having the the double tunneling

00:25:10,360 --> 00:25:13,790
but yeah it's not something that we're

00:25:12,380 --> 00:25:16,310
actively working on at the moment but

00:25:13,790 --> 00:25:18,730
it's something that would we know should

00:25:16,310 --> 00:25:18,730
be addressed

00:25:28,270 --> 00:25:37,550
so so that's plot net CFG the question

00:25:35,540 --> 00:25:40,280
is so we have this this cool plot net

00:25:37,550 --> 00:25:42,470
CFG that grafts complicated networking

00:25:40,280 --> 00:25:45,590
configurations with bridges and tunnels

00:25:42,470 --> 00:25:49,210
and all of that stuff Russia it doesn't

00:25:45,590 --> 00:25:49,210
actually look at OpenFlow rules right

00:25:49,450 --> 00:25:57,730
right so so it can plot the the sort of

00:25:59,860 --> 00:26:04,850
so it can plot like at this level where

00:26:03,200 --> 00:26:06,350
it can say yeah you have these

00:26:04,850 --> 00:26:08,240
containers and they're connected to this

00:26:06,350 --> 00:26:10,310
bridge and the bridge is connected to

00:26:08,240 --> 00:26:12,740
the ethernet and all of that it doesn't

00:26:10,310 --> 00:26:14,360
recognize the flow rules so it wouldn't

00:26:12,740 --> 00:26:16,010
be able to say well the WordPress

00:26:14,360 --> 00:26:18,230
container conductor the rails container

00:26:16,010 --> 00:26:24,980
but not the Apache container because it

00:26:18,230 --> 00:26:28,160
doesn't know anything about the well

00:26:24,980 --> 00:26:29,780
there you go the author of plot net CFG

00:26:28,160 --> 00:26:31,430
says that there's a plan to add that in

00:26:29,780 --> 00:26:34,360
the future although I mean that would

00:26:31,430 --> 00:26:36,560
require parsing arbitrary rules and I

00:26:34,360 --> 00:26:42,530
guess I could just know open shifts

00:26:36,560 --> 00:26:45,290
rules specifically or maybe when we when

00:26:42,530 --> 00:26:47,710
everybody moves to ovn that will solve

00:26:45,290 --> 00:26:47,710
that problem

00:26:51,450 --> 00:27:09,970
anyone else questions I still have scarf

00:26:56,590 --> 00:27:11,770
to get rid of okay oh do we sporty 6 do

00:27:09,970 --> 00:27:14,860
we support ipv6 know at the moment

00:27:11,770 --> 00:27:19,840
docker supports ipv6 but Cooper Nettie's

00:27:14,860 --> 00:27:21,730
does not and the issue is if we wanted

00:27:19,840 --> 00:27:25,090
to support just ipv6 it would probably

00:27:21,730 --> 00:27:26,830
be pretty easy but supporting ipv6 most

00:27:25,090 --> 00:27:29,230
likely means supporting dual stack and

00:27:26,830 --> 00:27:30,730
so you need to add a second IP address

00:27:29,230 --> 00:27:33,100
field to all these different data

00:27:30,730 --> 00:27:36,760
structures so again we have a Trello

00:27:33,100 --> 00:27:38,350
card for first Trello is the system that

00:27:36,760 --> 00:27:48,630
we use for tracking all of our work on

00:27:38,350 --> 00:27:48,630
openshift so yep

00:27:55,499 --> 00:28:00,100
so docker and Cooper Nettie's both have

00:27:58,450 --> 00:28:04,419
their own solutions for this and

00:28:00,100 --> 00:28:07,379
involving what they call services and so

00:28:04,419 --> 00:28:12,220
in an open shift in particular there's a

00:28:07,379 --> 00:28:13,779
sky DNS pod that knows about all of the

00:28:12,220 --> 00:28:16,210
services and so you can look up the

00:28:13,779 --> 00:28:22,840
services by name and it will resolve to

00:28:16,210 --> 00:28:23,950
the right IP addresses oh sorry and I

00:28:22,840 --> 00:28:25,779
should have repeated the question was

00:28:23,950 --> 00:28:27,490
how do we deal with DNS because

00:28:25,779 --> 00:28:37,409
obviously these containers can't all be

00:28:27,490 --> 00:28:40,590
referring to each other by IP address ok

00:28:37,409 --> 00:28:40,590
that's it

00:34:00,129 --> 00:34:03,129
Peralta

00:38:53,680 --> 00:38:55,740

YouTube URL: https://www.youtube.com/watch?v=z1jAYuzDEig


