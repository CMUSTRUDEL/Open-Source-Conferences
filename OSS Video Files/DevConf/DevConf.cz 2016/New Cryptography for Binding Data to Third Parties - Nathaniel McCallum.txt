Title: New Cryptography for Binding Data to Third Parties - Nathaniel McCallum
Publication date: 2016-02-11
Playlist: DevConf.cz 2016
Description: 
	Keeping secrets is tough. It is hard enough when you have control over the full computing chain. But now we are expected to keep secrets while storing those secrets in cloud and SaaS infrastructures. At least we can trust the network providers, right? Of course, the answer is to encrypt the data. But then how do we know who should have access to the data and when?

This talk will look at the new cryptographic techniques implemented by the Deo open source project. It forgoes complex (and compromise-prone) key management infrastructures by using simple algorithms to bind data to third party entities. Come see how to integrate Deo into your infrastructure or software project!
Captions: 
	00:00:00,000 --> 00:00:08,340
a presentation please close the door as

00:00:03,000 --> 00:00:12,090
quietly as possible yeah like that we

00:00:08,340 --> 00:00:16,260
won't you can evaluate Syrians in this

00:00:12,090 --> 00:00:19,740
link please tweet about the presentation

00:00:16,260 --> 00:00:21,900
about conference and write blog posts

00:00:19,740 --> 00:00:26,279
about the conference and I should

00:00:21,900 --> 00:00:33,140
promote grand finale today and the end

00:00:26,279 --> 00:00:37,380
at 1630 either the 105 there will be

00:00:33,140 --> 00:00:41,640
awesome things doing and now please

00:00:37,380 --> 00:00:44,090
welcome new presenter Nathaniel my

00:00:41,640 --> 00:00:47,210
Cologne and something about cryptography

00:00:44,090 --> 00:00:49,110
thank you very much everybody hear me

00:00:47,210 --> 00:00:52,230
all right we're going to start off with

00:00:49,110 --> 00:00:55,260
a question how many of you here have a

00:00:52,230 --> 00:00:57,090
laptop with an encrypted disk okay

00:00:55,260 --> 00:00:58,800
that's a really good number okay now

00:00:57,090 --> 00:01:00,480
we're going to do another question how

00:00:58,800 --> 00:01:03,110
many of you are feeling really guilty

00:01:00,480 --> 00:01:06,030
that your hand wasn't raised before

00:01:03,110 --> 00:01:07,979
anybody yeah all right we've got some

00:01:06,030 --> 00:01:09,930
honest people right because sometimes

00:01:07,979 --> 00:01:11,760
encryption can be a little bit of pain

00:01:09,930 --> 00:01:13,530
we're going to talk about some of the

00:01:11,760 --> 00:01:15,360
problems of key management and how we

00:01:13,530 --> 00:01:17,130
hope to solve them I do ask your

00:01:15,360 --> 00:01:20,549
patience we are having some technical

00:01:17,130 --> 00:01:23,509
difficulties my slide unfortunately is

00:01:20,549 --> 00:01:26,220
on the cloud it is not on a USB key and

00:01:23,509 --> 00:01:29,070
apparently the cloud provider had a

00:01:26,220 --> 00:01:30,689
massive data failure and the entire

00:01:29,070 --> 00:01:32,670
database where the entire data center

00:01:30,689 --> 00:01:33,960
went down there was the the battery

00:01:32,670 --> 00:01:35,850
backup didn't work and all kinds of

00:01:33,960 --> 00:01:38,540
stuff so we're going to try to hobble

00:01:35,850 --> 00:01:42,119
through this and actually I was able to

00:01:38,540 --> 00:01:44,700
get a live feed here from their data

00:01:42,119 --> 00:01:46,759
center and unfortunately they're all

00:01:44,700 --> 00:01:50,130
running around like crazy right now

00:01:46,759 --> 00:01:55,860
because this is popping up everywhere in

00:01:50,130 --> 00:01:58,740
their data center and so we really need

00:01:55,860 --> 00:02:02,579
to ask a question right can we automate

00:01:58,740 --> 00:02:05,549
this because if you know usability is a

00:02:02,579 --> 00:02:06,899
major impediment to security this is

00:02:05,549 --> 00:02:09,209
something we should really try to solve

00:02:06,899 --> 00:02:10,819
so before we can answer that question

00:02:09,209 --> 00:02:13,819
let's look at

00:02:10,819 --> 00:02:15,499
how this encryption is typically done so

00:02:13,819 --> 00:02:18,139
it all starts off with a secret right

00:02:15,499 --> 00:02:19,879
oftentimes this secret is your your hard

00:02:18,139 --> 00:02:22,579
disk it could be some data that a

00:02:19,879 --> 00:02:24,829
service has but if we have something

00:02:22,579 --> 00:02:27,739
that we want to keep secret and then we

00:02:24,829 --> 00:02:30,739
usually encrypt that secret in using an

00:02:27,739 --> 00:02:33,500
encryption key now as soon as your

00:02:30,739 --> 00:02:34,730
secret grows in size one of the things

00:02:33,500 --> 00:02:36,500
are going to quickly realize is that you

00:02:34,730 --> 00:02:38,269
don't want to constantly rien crypt your

00:02:36,500 --> 00:02:39,879
data because that's a lot of work in

00:02:38,269 --> 00:02:42,739
fact there was only great talk about

00:02:39,879 --> 00:02:44,120
about lux to disagree encryption they're

00:02:42,739 --> 00:02:45,829
going to be doing it live so it's really

00:02:44,120 --> 00:02:48,260
really cool stuff so check that out on

00:02:45,829 --> 00:02:50,959
the web if you didn't go to the talk but

00:02:48,260 --> 00:02:53,480
but yeah we tryin to re-encrypt anything

00:02:50,959 --> 00:02:55,849
that is observable amount is just very

00:02:53,480 --> 00:02:57,919
difficult so what do we do in the case

00:02:55,849 --> 00:03:00,709
of compromise keys well we actually wrap

00:02:57,919 --> 00:03:02,269
this in another key okay so we have the

00:03:00,709 --> 00:03:04,549
encryption key which protects the data

00:03:02,269 --> 00:03:06,650
itself and then we have a key encryption

00:03:04,549 --> 00:03:09,019
key which protects the encryption key

00:03:06,650 --> 00:03:11,780
and the reason that we do this is that

00:03:09,019 --> 00:03:14,299
if the outer key is compromised we can

00:03:11,780 --> 00:03:16,729
just change the outer key without having

00:03:14,299 --> 00:03:20,479
to change the enter key okay then you

00:03:16,729 --> 00:03:21,949
don't have to reinterpret Atta and the

00:03:20,479 --> 00:03:23,859
typical way that this is often deployed

00:03:21,949 --> 00:03:27,259
as you saw in the beginning of my slide

00:03:23,859 --> 00:03:29,180
is that you start up your computer and

00:03:27,259 --> 00:03:32,180
you have some kind of a password and you

00:03:29,180 --> 00:03:33,790
type your password in and add what that

00:03:32,180 --> 00:03:36,739
password does is it gives you the

00:03:33,790 --> 00:03:38,269
password is the key encryption key the

00:03:36,739 --> 00:03:40,459
key encryption key is then used to

00:03:38,269 --> 00:03:42,259
decrypt the encryption key and then the

00:03:40,459 --> 00:03:44,689
encryption key is used to decrypt the

00:03:42,259 --> 00:03:46,970
data and then of course this is

00:03:44,689 --> 00:03:48,500
distributed out to all of the admins who

00:03:46,970 --> 00:03:50,720
are supposed to have access to this

00:03:48,500 --> 00:03:52,759
device of course this this immediately

00:03:50,720 --> 00:03:55,069
comes with a problem you have multiple

00:03:52,759 --> 00:03:55,969
people all sharing this password and

00:03:55,069 --> 00:03:57,620
there are lots of ways to get around

00:03:55,969 --> 00:03:59,569
this luxe gives you multiple slots for

00:03:57,620 --> 00:04:01,370
instance and that's a that's a great

00:03:59,569 --> 00:04:05,599
solution but it does have its

00:04:01,370 --> 00:04:06,979
limitations it doesn't scale and so one

00:04:05,599 --> 00:04:10,189
of the ways that we can try to automate

00:04:06,979 --> 00:04:11,209
this is we actually generate something

00:04:10,189 --> 00:04:14,090
that's a little stronger

00:04:11,209 --> 00:04:16,570
cryptographically so here we have a

00:04:14,090 --> 00:04:19,639
cryptographically strong random key and

00:04:16,570 --> 00:04:21,560
then we store this in some remote system

00:04:19,639 --> 00:04:24,400
which we can then fetch at a later time

00:04:21,560 --> 00:04:29,229
and this is pretty much the standard s

00:04:24,400 --> 00:04:37,120
remodel or is it can anybody tell what

00:04:29,229 --> 00:04:39,699
I'm missing here what's that more

00:04:37,120 --> 00:04:41,740
encryption keys you see because we can't

00:04:39,699 --> 00:04:43,840
just transfer this key over the wire

00:04:41,740 --> 00:04:45,940
because if we did so than anybody who is

00:04:43,840 --> 00:04:48,160
listening of course could immediately

00:04:45,940 --> 00:04:49,960
figure out what our key was and then we

00:04:48,160 --> 00:04:51,940
would be sunk so we've got to encrypt

00:04:49,960 --> 00:04:53,710
the channel with which we distribute the

00:04:51,940 --> 00:04:56,949
key and this is typically done with TLS

00:04:53,710 --> 00:05:01,990
or with gssapi and now we're done right

00:04:56,949 --> 00:05:04,810
oh yeah we actually have to authenticate

00:05:01,990 --> 00:05:07,449
the parties right because we can't just

00:05:04,810 --> 00:05:09,100
send this magical key to some server if

00:05:07,449 --> 00:05:11,229
we don't know that the server is the

00:05:09,100 --> 00:05:14,199
server that is claiming to be so the

00:05:11,229 --> 00:05:16,240
server itself has to have a key as part

00:05:14,199 --> 00:05:21,370
of this authentication some kind of an

00:05:16,240 --> 00:05:22,630
identity right and we're done right no

00:05:21,370 --> 00:05:24,849
because we're going to fetch the key

00:05:22,630 --> 00:05:28,150
back so now we have to know that the

00:05:24,849 --> 00:05:30,580
client also has a key so that this

00:05:28,150 --> 00:05:32,320
server can verify that this person is

00:05:30,580 --> 00:05:34,870
supposed to get the key that they're

00:05:32,320 --> 00:05:36,460
supposed to get so anybody notice that a

00:05:34,870 --> 00:05:41,020
tendency here we're getting a lot more

00:05:36,460 --> 00:05:43,419
what jeez ok so now we need a central

00:05:41,020 --> 00:05:45,430
place to manage all of these keys and

00:05:43,419 --> 00:05:47,680
this is typically done with either a KDC

00:05:45,430 --> 00:05:50,289
in the case of using Kerberos for

00:05:47,680 --> 00:05:51,130
instance with gssapi or you'll have some

00:05:50,289 --> 00:05:54,639
kind of a sort of certification

00:05:51,130 --> 00:05:55,840
Authority if you're using TLS and of

00:05:54,639 --> 00:05:56,979
course you have to handle the issuance

00:05:55,840 --> 00:05:58,780
of the keys you have to handle the

00:05:56,979 --> 00:06:00,460
revocation of the keys because if

00:05:58,780 --> 00:06:02,199
anything happens if those keys are

00:06:00,460 --> 00:06:04,539
compromised then you where key

00:06:02,199 --> 00:06:07,659
encryption key is compromised and so on

00:06:04,539 --> 00:06:09,699
down the chain and of course we also

00:06:07,659 --> 00:06:11,740
have to have backups right because we

00:06:09,699 --> 00:06:14,020
can't just deploy this now complex

00:06:11,740 --> 00:06:16,389
system without having some way to

00:06:14,020 --> 00:06:18,250
restore to this very complex state

00:06:16,389 --> 00:06:20,740
because keep in mind this escrow server

00:06:18,250 --> 00:06:22,690
is probably storing lots of keys from

00:06:20,740 --> 00:06:24,820
lots of different places and if we all

00:06:22,690 --> 00:06:27,400
of a sudden lose this escrow key we are

00:06:24,820 --> 00:06:29,289
lose this escrow servers data we're

00:06:27,400 --> 00:06:31,539
really sunk so we have to keep really

00:06:29,289 --> 00:06:32,650
accurate backups up-to-the-minute right

00:06:31,539 --> 00:06:35,110
with all the keys that are changing

00:06:32,650 --> 00:06:38,440
hands and this is a fully stateful

00:06:35,110 --> 00:06:41,020
process here so

00:06:38,440 --> 00:06:43,450
finally we are done we can rest assured

00:06:41,020 --> 00:06:49,510
that there is not going to be any kind

00:06:43,450 --> 00:06:51,130
of problem whatsoever well you see we

00:06:49,510 --> 00:06:53,380
have this problem now that we're using

00:06:51,130 --> 00:06:55,900
encryption all over the place to try to

00:06:53,380 --> 00:06:57,910
protect our keys but where you all were

00:06:55,900 --> 00:06:59,770
doing is increasing complexity in the

00:06:57,910 --> 00:07:02,170
stack and anytime that we increase

00:06:59,770 --> 00:07:05,260
complexity in the stack were increasing

00:07:02,170 --> 00:07:08,290
our attack surface and so every little

00:07:05,260 --> 00:07:11,080
wink in this diagram now is a potential

00:07:08,290 --> 00:07:12,910
point of vulnerability for our system so

00:07:11,080 --> 00:07:16,180
what we've done here is we've made it

00:07:12,910 --> 00:07:18,460
truly easy to get the key back but we've

00:07:16,180 --> 00:07:22,270
also opened up ourselves to a lot of new

00:07:18,460 --> 00:07:23,680
risk so we've learned a few lessons here

00:07:22,270 --> 00:07:25,480
we've learned that complicity in

00:07:23,680 --> 00:07:28,090
complexity increases the attack surface

00:07:25,480 --> 00:07:30,580
we learned that escrow is difficult to

00:07:28,090 --> 00:07:32,950
deploy and we also learn something else

00:07:30,580 --> 00:07:35,500
which is that speed matters because if

00:07:32,950 --> 00:07:39,190
we go back a slide here notice all of

00:07:35,500 --> 00:07:43,120
this complexity every single hop in this

00:07:39,190 --> 00:07:44,950
complex chain adds latency and so when

00:07:43,120 --> 00:07:47,169
you have a data server up a hundred

00:07:44,950 --> 00:07:49,740
thousand servers all coming up at the

00:07:47,169 --> 00:07:51,760
same exact time from a power outage

00:07:49,740 --> 00:07:54,070
what's going to happen to this server

00:07:51,760 --> 00:07:56,860
right here we're gonna have a massive

00:07:54,070 --> 00:07:58,480
bottleneck a denial of services all of

00:07:56,860 --> 00:08:01,750
these servers come online at once and

00:07:58,480 --> 00:08:07,060
try to get their keys back so speed

00:08:01,750 --> 00:08:09,810
matters so pushing number two can

00:08:07,060 --> 00:08:13,270
asymmetric cryptography help us here and

00:08:09,810 --> 00:08:15,220
the answer is actually yes and what we

00:08:13,270 --> 00:08:17,560
did is a year ago actually after the

00:08:15,220 --> 00:08:20,200
last dev comp in some brainstorming

00:08:17,560 --> 00:08:22,690
meetings we came up with a new model and

00:08:20,200 --> 00:08:26,410
we called this the day of project deo

00:08:22,690 --> 00:08:28,570
was Greek for i bind some so binding

00:08:26,410 --> 00:08:29,800
things together as the idea and one of

00:08:28,570 --> 00:08:33,160
the things that we wanted to do was we

00:08:29,800 --> 00:08:36,370
wanted to move the state out of the

00:08:33,160 --> 00:08:38,950
escrow server okay so in this case what

00:08:36,370 --> 00:08:42,520
we do is we take this key encryption key

00:08:38,950 --> 00:08:44,350
and we encrypt it again using the public

00:08:42,520 --> 00:08:46,920
encryption key of the server notice

00:08:44,350 --> 00:08:49,240
we're doing asymmetric cryptography now

00:08:46,920 --> 00:08:51,649
this step can actually be done offline

00:08:49,240 --> 00:08:54,559
as long as the client has the

00:08:51,649 --> 00:08:57,470
the server's public key and the end

00:08:54,559 --> 00:09:00,439
result is that all of our secrets still

00:08:57,470 --> 00:09:03,290
reside on the client in this system

00:09:00,439 --> 00:09:06,730
right so we no longer have any complex

00:09:03,290 --> 00:09:10,399
state on the escrow side of the equation

00:09:06,730 --> 00:09:12,529
so then what we do is during the time in

00:09:10,399 --> 00:09:16,009
which we wants to do decryption of this

00:09:12,529 --> 00:09:18,980
key we then send the encrypted key

00:09:16,009 --> 00:09:22,100
encryption key to the damn server the

00:09:18,980 --> 00:09:23,660
Deo server just uses its local key which

00:09:22,100 --> 00:09:26,569
can be stored in memory so it's all very

00:09:23,660 --> 00:09:30,139
fast and stateless and it can return

00:09:26,569 --> 00:09:32,809
back the disk encryption key notice it

00:09:30,139 --> 00:09:33,889
didn't store anything and so we don't we

00:09:32,809 --> 00:09:36,920
no longer have a central point of

00:09:33,889 --> 00:09:38,809
compromising the server and also we've

00:09:36,920 --> 00:09:40,850
reduced the load significantly because

00:09:38,809 --> 00:09:42,949
we're not calling out for disk i/o every

00:09:40,850 --> 00:09:46,309
time a request comes in so this is

00:09:42,949 --> 00:09:49,189
definitely an improvement however we

00:09:46,309 --> 00:09:52,429
have some keys here as well we have two

00:09:49,189 --> 00:09:56,749
keys in particular first we have a key

00:09:52,429 --> 00:09:59,540
for encrypting the channel where the key

00:09:56,749 --> 00:10:02,779
is being transferred across and second

00:09:59,540 --> 00:10:05,360
we have the asymmetric key pair for

00:10:02,779 --> 00:10:06,769
doing the public key crypto and so this

00:10:05,360 --> 00:10:08,629
is this is better we don't have like a

00:10:06,769 --> 00:10:10,399
full assortment of all of these these

00:10:08,629 --> 00:10:12,379
arrays of keys but we still didn't have

00:10:10,399 --> 00:10:14,720
some keys which presents some complexity

00:10:12,379 --> 00:10:17,240
and we still do have the sort of

00:10:14,720 --> 00:10:20,149
heartbleed problem right if anybody can

00:10:17,240 --> 00:10:22,790
penetrate this outer layer of encryption

00:10:20,149 --> 00:10:25,189
then when the key is coming back and

00:10:22,790 --> 00:10:27,769
it's decrypted States to the client at

00:10:25,189 --> 00:10:31,569
that point if somebody can break the

00:10:27,769 --> 00:10:34,819
encryption then they can get the key so

00:10:31,569 --> 00:10:37,189
we also still have certificate authority

00:10:34,819 --> 00:10:39,079
in backups and one of the things that we

00:10:37,189 --> 00:10:40,579
discovered when writing the software in

00:10:39,079 --> 00:10:43,549
fact there was releases of this software

00:10:40,579 --> 00:10:45,230
and one of the things we discovered that

00:10:43,549 --> 00:10:48,379
this part here actually made a pretty

00:10:45,230 --> 00:10:50,899
complex to deploy even with fairly

00:10:48,379 --> 00:10:52,910
step-by-step instructions when people

00:10:50,899 --> 00:10:55,369
were trying to reproduce this setup they

00:10:52,910 --> 00:10:58,910
had difficulty and we thought that that

00:10:55,369 --> 00:11:02,749
was not a really great way to start so

00:10:58,910 --> 00:11:04,230
we began to look again and we learned

00:11:02,749 --> 00:11:06,390
some lessons here

00:11:04,230 --> 00:11:07,830
Krypto makes it so that the server is

00:11:06,390 --> 00:11:09,300
stateless and we really liked this

00:11:07,830 --> 00:11:12,030
feature because it means that we can get

00:11:09,300 --> 00:11:15,090
high performance it also means that we

00:11:12,030 --> 00:11:19,470
can reduce attack points like say on the

00:11:15,090 --> 00:11:20,640
disk chain and whatnot the asymmetric

00:11:19,470 --> 00:11:21,720
crypto also allows for offline

00:11:20,640 --> 00:11:24,240
provisioning which is a really nice

00:11:21,720 --> 00:11:26,310
feature particularly think of in cases

00:11:24,240 --> 00:11:28,110
you know where you might have spotty

00:11:26,310 --> 00:11:30,150
internet connectivity you can have the

00:11:28,110 --> 00:11:32,190
public key on the flash drive provision

00:11:30,150 --> 00:11:33,780
a whole bunch of systems and then when

00:11:32,190 --> 00:11:37,050
the network comes back up you can you

00:11:33,780 --> 00:11:38,160
can continue to work but one of the

00:11:37,050 --> 00:11:39,960
things that we identified was that

00:11:38,160 --> 00:11:42,900
sending the keys over the wire is a risk

00:11:39,960 --> 00:11:45,240
and we'd like to ask can we do better

00:11:42,900 --> 00:11:49,830
than that we also learned that x509

00:11:45,240 --> 00:11:53,520
takes a lot of effort so our project

00:11:49,830 --> 00:11:56,100
died we killed it and we moved on to

00:11:53,520 --> 00:11:58,830
something which we think is better so

00:11:56,100 --> 00:12:05,850
let's move to question number three must

00:11:58,830 --> 00:12:09,740
the key go on the wire now my intention

00:12:05,850 --> 00:12:12,960
today is to kill someone with math so I

00:12:09,740 --> 00:12:15,780
want to see a hand if you're dead later

00:12:12,960 --> 00:12:18,270
so this is just standard el-gamal

00:12:15,780 --> 00:12:20,790
encryption ok this is this is not me

00:12:18,270 --> 00:12:24,330
doing anything anything special what we

00:12:20,790 --> 00:12:26,970
do is the server generates a key pair

00:12:24,330 --> 00:12:30,030
sends the public key to the client the

00:12:26,970 --> 00:12:32,820
client will generate its key pair and

00:12:30,030 --> 00:12:34,590
will encrypt some data using it and then

00:12:32,820 --> 00:12:36,780
when you want and then now the data is

00:12:34,590 --> 00:12:40,320
encrypted and when you want to perform

00:12:36,780 --> 00:12:43,410
decryption on the other side the client

00:12:40,320 --> 00:12:46,050
returns this K this a value in this cave

00:12:43,410 --> 00:12:48,300
al you to the server the K value is the

00:12:46,050 --> 00:12:50,520
encrypted value and the server performs

00:12:48,300 --> 00:12:53,130
a mathematical operation and returns the

00:12:50,520 --> 00:12:56,940
uppercase K here which is the plain text

00:12:53,130 --> 00:12:58,980
data ok so this is actually going to be

00:12:56,940 --> 00:13:01,680
the basis for the new crypto in this

00:12:58,980 --> 00:13:04,230
project we're going to move one step

00:13:01,680 --> 00:13:07,670
over watch very carefully we'll go back

00:13:04,230 --> 00:13:11,460
and forth a few times notice that

00:13:07,670 --> 00:13:14,790
nothing on the left hand side changes ok

00:13:11,460 --> 00:13:16,530
so the left hand side which of alcohol

00:13:14,790 --> 00:13:18,380
encryption is going to stay exactly the

00:13:16,530 --> 00:13:22,260
same

00:13:18,380 --> 00:13:26,010
in this key exchange we add only one

00:13:22,260 --> 00:13:27,900
thing which is we take this x value here

00:13:26,010 --> 00:13:31,680
and we generally generates an ephemeral

00:13:27,900 --> 00:13:34,160
keep air and by mixing this additional

00:13:31,680 --> 00:13:36,510
ephemeral keep air at decryption time

00:13:34,160 --> 00:13:39,390
into the value that we send to the

00:13:36,510 --> 00:13:41,610
server we can send the key to the server

00:13:39,390 --> 00:13:44,220
the server performs its side of the

00:13:41,610 --> 00:13:47,640
mathematical equation and returns back

00:13:44,220 --> 00:13:50,010
the result and we can now calculate the

00:13:47,640 --> 00:13:52,020
K rather than the server calculating the

00:13:50,010 --> 00:13:54,690
K now the interesting thing that this

00:13:52,020 --> 00:13:56,910
does is this means that there's no k

00:13:54,690 --> 00:13:59,790
ever on the server that means the server

00:13:56,910 --> 00:14:02,310
never knows anything about what's going

00:13:59,790 --> 00:14:04,260
on on the client it just simply says I

00:14:02,310 --> 00:14:06,960
can perform this mathematical operation

00:14:04,260 --> 00:14:08,520
and if you can contact me then I can

00:14:06,960 --> 00:14:11,220
perform it for you but it knows

00:14:08,520 --> 00:14:15,180
literally nothing about the client at

00:14:11,220 --> 00:14:18,120
least algorithmically so we created a

00:14:15,180 --> 00:14:20,400
new project called tang and this is the

00:14:18,120 --> 00:14:23,490
Tang model it looks very similar to what

00:14:20,400 --> 00:14:25,140
we had before we have our secret in the

00:14:23,490 --> 00:14:27,630
middle we have our encryption key we

00:14:25,140 --> 00:14:31,230
have our key encryption key which is

00:14:27,630 --> 00:14:33,870
generated as part of the exchange with

00:14:31,230 --> 00:14:36,390
our Tang server there's a lot of stuff

00:14:33,870 --> 00:14:38,610
missing in this slide now notice that

00:14:36,390 --> 00:14:41,340
there's no longer a TLS channel here and

00:14:38,610 --> 00:14:43,560
that's because this is done completely

00:14:41,340 --> 00:14:45,570
over the wire it's the same as a dippy

00:14:43,560 --> 00:14:47,880
Hellman same properties as like a dippy

00:14:45,570 --> 00:14:50,400
home in exchange or a public el-gamal

00:14:47,880 --> 00:14:52,170
encryption by transferring these over

00:14:50,400 --> 00:14:55,520
values over the wire nobody gets any

00:14:52,170 --> 00:14:58,290
advantage and this is provably secure so

00:14:55,520 --> 00:15:00,960
the end result is that our key

00:14:58,290 --> 00:15:05,490
encryption key always stays local and

00:15:00,960 --> 00:15:07,470
the server never sees anything of course

00:15:05,490 --> 00:15:09,210
we still do have to have backups but our

00:15:07,470 --> 00:15:11,210
backups are much more limited in scope

00:15:09,210 --> 00:15:16,380
now and the reason for this is because

00:15:11,210 --> 00:15:18,600
we have absolutely we have in Tang a set

00:15:16,380 --> 00:15:21,180
of keys for doing encryption these keys

00:15:18,600 --> 00:15:23,420
can be generated at will whatever

00:15:21,180 --> 00:15:25,890
whatever your key rotation policy states

00:15:23,420 --> 00:15:28,380
and at that time they can be inserted in

00:15:25,890 --> 00:15:31,230
backups but aside from key rotation

00:15:28,380 --> 00:15:34,530
there is absolutely no state whatsoever

00:15:31,230 --> 00:15:36,660
server and so this makes for a very very

00:15:34,530 --> 00:15:39,720
limited attack footprint the size of

00:15:36,660 --> 00:15:43,020
this server is extremely small this is

00:15:39,720 --> 00:15:44,730
the the project page here and this

00:15:43,020 --> 00:15:46,080
includes the server side demon with the

00:15:44,730 --> 00:15:48,530
clevis pin which we're going to talk

00:15:46,080 --> 00:15:50,760
about in a minute don't get too excited

00:15:48,530 --> 00:15:53,190
we are nearing our first release and it

00:15:50,760 --> 00:15:56,880
has an extensive test suite it's really

00:15:53,190 --> 00:15:59,940
fast so we can handle north of 30,000

00:15:56,880 --> 00:16:01,260
requests per second so if you think of a

00:15:59,940 --> 00:16:04,080
data center where you've got a hundred

00:16:01,260 --> 00:16:05,640
thousand machines all coming up across

00:16:04,080 --> 00:16:08,700
the span of about five that's five

00:16:05,640 --> 00:16:12,480
seconds we can handle this on one

00:16:08,700 --> 00:16:15,180
computer so very very lightweight very

00:16:12,480 --> 00:16:21,660
very fast very very small attack surface

00:16:15,180 --> 00:16:25,260
and substantially tested so now that we

00:16:21,660 --> 00:16:27,300
have accomplished this task of taking

00:16:25,260 --> 00:16:29,700
that secret that we want that data and

00:16:27,300 --> 00:16:31,680
we've now bound it to a third party and

00:16:29,700 --> 00:16:33,570
it can only be decrypted in the presence

00:16:31,680 --> 00:16:35,100
of that third party let's do a little

00:16:33,570 --> 00:16:38,630
brainstorming about some of the other

00:16:35,100 --> 00:16:41,160
kinds of things that we could do

00:16:38,630 --> 00:16:43,380
obviously the the one that Intel would

00:16:41,160 --> 00:16:45,300
be very interested in us using is the

00:16:43,380 --> 00:16:47,610
trusted platform module and this indeed

00:16:45,300 --> 00:16:50,040
would guarantee that the for instance

00:16:47,610 --> 00:16:51,060
the disk is in the computer right

00:16:50,040 --> 00:16:52,740
because there's a physical

00:16:51,060 --> 00:16:54,960
connectivities what we're testing for

00:16:52,740 --> 00:16:57,150
there and think start thinking now in

00:16:54,960 --> 00:16:59,310
terms not of keys but in terms of

00:16:57,150 --> 00:17:01,440
relationships right so in this first

00:16:59,310 --> 00:17:04,860
case we have a relationship between a

00:17:01,440 --> 00:17:07,140
disk being in a chassis in the second

00:17:04,860 --> 00:17:09,870
case we have a bluetooth LE beacon so we

00:17:07,140 --> 00:17:11,910
can implement this Tang protocol over

00:17:09,870 --> 00:17:14,280
Bluetooth Low Energy and you could say

00:17:11,910 --> 00:17:15,900
up in the ceiling of your office you

00:17:14,280 --> 00:17:18,150
could have this Bluetooth low-energy

00:17:15,900 --> 00:17:20,820
beacon and only the people that are

00:17:18,150 --> 00:17:23,850
within that you know 30 feet 50 meters

00:17:20,820 --> 00:17:25,440
whatever the range is not 50 meters but

00:17:23,850 --> 00:17:28,530
whatever the range is on your Bluetooth

00:17:25,440 --> 00:17:29,730
beacon and you know that's the range in

00:17:28,530 --> 00:17:31,860
which they will be able to perform

00:17:29,730 --> 00:17:33,750
decryption and if they go outside of

00:17:31,860 --> 00:17:36,260
that range they can't perform decryption

00:17:33,750 --> 00:17:39,180
anymore another case might be that we

00:17:36,260 --> 00:17:41,370
during the provisioning time we generate

00:17:39,180 --> 00:17:43,080
a random key and we print a QR code and

00:17:41,370 --> 00:17:45,100
you take that QR code and you stick it

00:17:43,080 --> 00:17:47,500
in a safe right and this is

00:17:45,100 --> 00:17:49,750
this is your last ditch recovery at this

00:17:47,500 --> 00:17:52,059
point all other methods of decrypting

00:17:49,750 --> 00:17:54,130
the data have failed and so you take

00:17:52,059 --> 00:17:56,200
this physical key and you go and unlock

00:17:54,130 --> 00:18:01,240
the safe and get back your QR code and

00:17:56,200 --> 00:18:03,280
then you scan it in the in the webcam so

00:18:01,240 --> 00:18:05,559
obviously techniques like facial

00:18:03,280 --> 00:18:07,480
recognition fingerprint scans mobile

00:18:05,559 --> 00:18:09,820
phones can do the same thing with

00:18:07,480 --> 00:18:12,960
Bluetooth right using the same protocol

00:18:09,820 --> 00:18:15,580
and then the standard smart card and

00:18:12,960 --> 00:18:17,289
RFIDs so these are all different kinds

00:18:15,580 --> 00:18:22,150
of relationships that your data could

00:18:17,289 --> 00:18:23,830
have with objects now how many of you

00:18:22,150 --> 00:18:26,020
went to Josh pressors talk yesterday on

00:18:23,830 --> 00:18:28,419
security security everything it was a

00:18:26,020 --> 00:18:30,070
fantastic talk and one of the things

00:18:28,419 --> 00:18:31,960
that he said in this talk i think is

00:18:30,070 --> 00:18:34,630
really worth highlighting which is that

00:18:31,960 --> 00:18:36,880
security is not a binary and oftentimes

00:18:34,630 --> 00:18:38,950
when particularly doing encryption we

00:18:36,880 --> 00:18:41,770
often think in these binary terms right

00:18:38,950 --> 00:18:44,289
is the data secure or is it not secure

00:18:41,770 --> 00:18:45,549
and one of the things i wanted to do in

00:18:44,289 --> 00:18:48,490
shifting us to thinking about

00:18:45,549 --> 00:18:51,549
relationships between data and the third

00:18:48,490 --> 00:18:53,679
parties is that we can actually now

00:18:51,549 --> 00:18:56,470
begin to think in terms that are not

00:18:53,679 --> 00:18:58,419
necessarily binary and this is this

00:18:56,470 --> 00:19:00,280
should not surprise us at all because

00:18:58,419 --> 00:19:03,190
this is precisely the way that we human

00:19:00,280 --> 00:19:05,320
beings think when we walk into a room we

00:19:03,190 --> 00:19:07,929
can quickly assess many factors in the

00:19:05,320 --> 00:19:10,840
room and you know let's say I find a

00:19:07,929 --> 00:19:13,809
white fridge in a room well that may not

00:19:10,840 --> 00:19:15,880
be anything on its own but if I find a

00:19:13,809 --> 00:19:17,860
white fridge and you know a bunch of

00:19:15,880 --> 00:19:19,570
other white stuff in a surgical table

00:19:17,860 --> 00:19:21,220
and you know I might start to piece

00:19:19,570 --> 00:19:24,130
together that maybe this is a hospital

00:19:21,220 --> 00:19:26,500
right so we gather all of these pieces

00:19:24,130 --> 00:19:28,870
of data and we weigh them collectively

00:19:26,500 --> 00:19:32,470
and we establish the relationships

00:19:28,870 --> 00:19:34,120
between them and based upon this we can

00:19:32,470 --> 00:19:35,470
reason about things and this is

00:19:34,120 --> 00:19:37,600
oftentimes the way that we reason about

00:19:35,470 --> 00:19:39,340
security right if you when you're asking

00:19:37,600 --> 00:19:40,929
the question maybe am I in a safe

00:19:39,340 --> 00:19:43,750
environment am I in a good part of town

00:19:40,929 --> 00:19:47,049
there's not a sign that says you are now

00:19:43,750 --> 00:19:48,850
entering the bad part of town right if

00:19:47,049 --> 00:19:51,669
there was lots of people get sued

00:19:48,850 --> 00:19:53,409
probably so so there's not a sign that's

00:19:51,669 --> 00:19:55,330
telling us that and so the way we reason

00:19:53,409 --> 00:19:57,040
about it is that we enter into that

00:19:55,330 --> 00:19:58,690
environment and we begin to have

00:19:57,040 --> 00:20:01,540
relationships with

00:19:58,690 --> 00:20:03,550
of the objects that are around us and we

00:20:01,540 --> 00:20:05,260
begin to reason in ways that are not

00:20:03,550 --> 00:20:08,580
necessarily binary about our

00:20:05,260 --> 00:20:10,960
relationships between these objects and

00:20:08,580 --> 00:20:15,250
so one of the questions we want to ask

00:20:10,960 --> 00:20:18,250
next is how do we make unlock policy non

00:20:15,250 --> 00:20:20,650
binary and there's actually a way to do

00:20:18,250 --> 00:20:22,690
this it's a technique called shamira

00:20:20,650 --> 00:20:25,300
secret sharing and the way that Sh

00:20:22,690 --> 00:20:28,210
Amir's works is that it allows you to

00:20:25,300 --> 00:20:30,280
take a key one of your security keys

00:20:28,210 --> 00:20:34,000
here and you can split it up into an

00:20:30,280 --> 00:20:36,460
arbitrary number of sub keys you also

00:20:34,000 --> 00:20:39,820
during this operation define a threshold

00:20:36,460 --> 00:20:42,220
the threshold can be like one in which

00:20:39,820 --> 00:20:45,340
case if any of these keys are present

00:20:42,220 --> 00:20:47,800
then we can recalculate this key if the

00:20:45,340 --> 00:20:49,930
threshold is to we would need two out of

00:20:47,800 --> 00:20:52,780
these five to recalculate the main key

00:20:49,930 --> 00:20:54,400
and so on all the way up to five so

00:20:52,780 --> 00:20:56,530
again now with shim ears actually

00:20:54,400 --> 00:20:59,730
express complex relationships between

00:20:56,530 --> 00:21:02,230
objects so we can begin to as a computer

00:20:59,730 --> 00:21:05,670
reason in a way that is fairly similar

00:21:02,230 --> 00:21:07,840
to the way the humans reason which is

00:21:05,670 --> 00:21:10,120
one of the other things that this can be

00:21:07,840 --> 00:21:12,070
nested right so you can actually then

00:21:10,120 --> 00:21:14,590
take some ears and apply it again and

00:21:12,070 --> 00:21:16,720
split this key out and so you can have

00:21:14,590 --> 00:21:19,680
nested policy and using this we can

00:21:16,720 --> 00:21:23,020
create fairly complex sets of

00:21:19,680 --> 00:21:26,860
relationships between objects so let's

00:21:23,020 --> 00:21:28,120
take an example of a simple laptop it's

00:21:26,860 --> 00:21:30,730
the laptops been issued to you back

00:21:28,120 --> 00:21:32,020
corporate IT you're probably being if

00:21:30,730 --> 00:21:34,150
you're using Linux you're probably

00:21:32,020 --> 00:21:37,180
encrypting with Lux and Lux has a great

00:21:34,150 --> 00:21:38,520
facility called slots and you can have

00:21:37,180 --> 00:21:40,990
so many slots and there's an or

00:21:38,520 --> 00:21:42,610
relationship between the keys well we

00:21:40,990 --> 00:21:44,590
can do the same we can express the same

00:21:42,610 --> 00:21:46,810
kind of relationship with SH Amir's by

00:21:44,590 --> 00:21:50,890
simply specifying a threshold of one in

00:21:46,810 --> 00:21:54,610
this case either one of these keys will

00:21:50,890 --> 00:21:57,970
allow us to reconstitute this key as a

00:21:54,610 --> 00:22:00,850
result the admin can log in with his or

00:21:57,970 --> 00:22:02,860
her password or the user can log in with

00:22:00,850 --> 00:22:04,480
his or her password right and so this

00:22:02,860 --> 00:22:06,220
makes a lot of sense because you don't

00:22:04,480 --> 00:22:08,200
want the admin knowing what your

00:22:06,220 --> 00:22:10,090
password is you want to be able to use

00:22:08,200 --> 00:22:11,650
your password on a day-to-day basis but

00:22:10,090 --> 00:22:12,370
the admin also needs to be able to

00:22:11,650 --> 00:22:13,870
recover

00:22:12,370 --> 00:22:16,750
your data if something were to happen

00:22:13,870 --> 00:22:18,850
and so we can express this now in a

00:22:16,750 --> 00:22:23,980
chemise relationship with a threshold of

00:22:18,850 --> 00:22:25,750
one now let's add Tang into the mix

00:22:23,980 --> 00:22:28,360
right so this is the same exact setup

00:22:25,750 --> 00:22:31,480
but now we're automated so we still have

00:22:28,360 --> 00:22:34,300
the admin password for recovery and we

00:22:31,480 --> 00:22:35,559
still have the user password for for the

00:22:34,300 --> 00:22:37,059
case where the tank server is

00:22:35,559 --> 00:22:38,740
unavailable but if the tank service

00:22:37,059 --> 00:22:40,960
present we're going to automatically

00:22:38,740 --> 00:22:42,910
unlock the laptop right which is a

00:22:40,960 --> 00:22:44,440
really really useful feature so think of

00:22:42,910 --> 00:22:46,240
how this might work and it may be an

00:22:44,440 --> 00:22:49,780
office setting where you walk into the

00:22:46,240 --> 00:22:51,730
office on Monday morning and you turn on

00:22:49,780 --> 00:22:53,380
your laptop and it boots and you don't

00:22:51,730 --> 00:22:54,850
type anything because it was on a

00:22:53,380 --> 00:22:56,740
corporate network and it was able to

00:22:54,850 --> 00:22:58,330
talk to the tank server it has a

00:22:56,740 --> 00:23:00,760
relation to put that tank server and

00:22:58,330 --> 00:23:03,429
therefore the decryption can work but

00:23:00,760 --> 00:23:05,320
then on Friday night you decided to take

00:23:03,429 --> 00:23:07,120
your laptop and go sit at a coffee shop

00:23:05,320 --> 00:23:09,670
well you're no longer on the corporate

00:23:07,120 --> 00:23:11,650
network you're now on some Wi-Fi hotspot

00:23:09,670 --> 00:23:13,929
and in this case you do not have access

00:23:11,650 --> 00:23:15,280
to tang so when you turn on your laptop

00:23:13,929 --> 00:23:18,730
you're going to get prompted for a

00:23:15,280 --> 00:23:20,410
password so fairly simple ways to

00:23:18,730 --> 00:23:22,540
approach these begin to approach these

00:23:20,410 --> 00:23:24,910
complex relationships let's say we have

00:23:22,540 --> 00:23:27,640
a high security system right in this

00:23:24,910 --> 00:23:30,429
case we want to guarantee that no one

00:23:27,640 --> 00:23:33,280
user can decrypt the system by him or

00:23:30,429 --> 00:23:36,280
herself and in this case we've now set

00:23:33,280 --> 00:23:39,580
the threshold to two so we have three

00:23:36,280 --> 00:23:40,750
user passwords and so long as any two of

00:23:39,580 --> 00:23:45,120
them are there to type in their

00:23:40,750 --> 00:23:45,120
passwords they can now unlock the system

00:23:46,710 --> 00:23:51,370
here's a complex policy but one that

00:23:49,480 --> 00:23:53,230
actually has some use and now you can

00:23:51,370 --> 00:23:55,120
begin to think about the way that we

00:23:53,230 --> 00:23:58,690
human beings also relates to these

00:23:55,120 --> 00:24:01,630
objects in this policy we have three

00:23:58,690 --> 00:24:04,720
layers of nested smears the first layer

00:24:01,630 --> 00:24:08,140
has a threshold of one and has a QR code

00:24:04,720 --> 00:24:10,450
as its as its method of input this is

00:24:08,140 --> 00:24:12,670
the recovery step right if all else

00:24:10,450 --> 00:24:15,429
fails you should be able to scan that

00:24:12,670 --> 00:24:18,520
hard coded QR code and get into the

00:24:15,429 --> 00:24:20,650
system and the QR code is kept locked in

00:24:18,520 --> 00:24:22,150
the safe somewhere but if that if you

00:24:20,650 --> 00:24:23,240
can't do that now we move on to the next

00:24:22,150 --> 00:24:24,830
level

00:24:23,240 --> 00:24:27,080
at this next level we have a threshold

00:24:24,830 --> 00:24:31,190
of 2 which means that both of these

00:24:27,080 --> 00:24:33,230
branches must hold true so we must have

00:24:31,190 --> 00:24:35,720
TPM in other words the disk must be in

00:24:33,230 --> 00:24:37,040
the chassis so this allows now for the

00:24:35,720 --> 00:24:40,790
admin to pull the disk out of the

00:24:37,040 --> 00:24:42,710
chassis and use the qr-code but in a

00:24:40,790 --> 00:24:45,050
normal case the disk must remain in the

00:24:42,710 --> 00:24:48,230
chassis now we go down our next branch

00:24:45,050 --> 00:24:49,670
our threshold here is to again which

00:24:48,230 --> 00:24:52,010
means that we need two methods of

00:24:49,670 --> 00:24:54,380
authentication and in this case we have

00:24:52,010 --> 00:24:55,850
four options we can type in our password

00:24:54,380 --> 00:24:58,340
we can scan our fingerprints we can

00:24:55,850 --> 00:25:01,100
contact us Tang server or we can do blue

00:24:58,340 --> 00:25:02,390
Bluetooth proximity right so let's say

00:25:01,100 --> 00:25:05,059
you're sitting at your desk in your

00:25:02,390 --> 00:25:07,640
office underneath the Bluetooth begin

00:25:05,059 --> 00:25:08,929
and you're on the corporate network well

00:25:07,640 --> 00:25:10,429
when you boot your system you're going

00:25:08,929 --> 00:25:13,790
to get in automatically because these

00:25:10,429 --> 00:25:15,200
two are going to return values but now

00:25:13,790 --> 00:25:17,770
let's say you walk into the conference

00:25:15,200 --> 00:25:20,570
room and you're not sitting at your desk

00:25:17,770 --> 00:25:21,620
now you're going to still have access to

00:25:20,570 --> 00:25:23,270
10 because you're on the corporate

00:25:21,620 --> 00:25:26,179
network but you're not going to be in

00:25:23,270 --> 00:25:27,559
proximity to your Bluetooth and so now

00:25:26,179 --> 00:25:28,850
we need to provide one of these other

00:25:27,559 --> 00:25:30,559
two and typically you probably provide

00:25:28,850 --> 00:25:31,970
this fingerprint scan because it's easy

00:25:30,559 --> 00:25:34,700
you don't think about it you just swipe

00:25:31,970 --> 00:25:37,070
your finger now again you go out to the

00:25:34,700 --> 00:25:39,170
coffee shop and so we still need two

00:25:37,070 --> 00:25:41,929
methods of authentication in this case

00:25:39,170 --> 00:25:44,030
you can specify your password in your

00:25:41,929 --> 00:25:45,980
fingerprint so this is a fairly complex

00:25:44,030 --> 00:25:48,470
policy but you can actually think now

00:25:45,980 --> 00:25:50,720
about the scenarios in which this

00:25:48,470 --> 00:25:52,880
provides a very good user experience in

00:25:50,720 --> 00:25:55,340
high security environments which we've

00:25:52,880 --> 00:26:01,480
determined by analyzing our surroundings

00:25:55,340 --> 00:26:05,840
right so this is the quote I want to

00:26:01,480 --> 00:26:08,120
leave us on we need to let business

00:26:05,840 --> 00:26:11,510
policy drive crypto policy not vice

00:26:08,120 --> 00:26:14,330
versa and the reason I say this is

00:26:11,510 --> 00:26:17,059
because often times we get in this

00:26:14,330 --> 00:26:19,220
conversation where we're asked well how

00:26:17,059 --> 00:26:22,040
can we keep our data secure and we can

00:26:19,220 --> 00:26:25,040
say well you have this one option or

00:26:22,040 --> 00:26:26,750
this two options right what we really

00:26:25,040 --> 00:26:29,510
need to be able to say now is we need to

00:26:26,750 --> 00:26:32,330
be able to describe scenarios where it's

00:26:29,510 --> 00:26:34,520
not just a binary and where we can in

00:26:32,330 --> 00:26:36,740
high security environments we can

00:26:34,520 --> 00:26:39,080
provide high usability where we don't

00:26:36,740 --> 00:26:41,260
even have to say enter passwords but

00:26:39,080 --> 00:26:43,580
then as we transition out of those high

00:26:41,260 --> 00:26:46,340
security environments into lower

00:26:43,580 --> 00:26:48,410
security environments at that point then

00:26:46,340 --> 00:26:51,320
our authentication policy gets stricter

00:26:48,410 --> 00:26:53,540
and stricter and so note that this is

00:26:51,320 --> 00:26:57,800
not binary we actually have multiple

00:26:53,540 --> 00:26:59,770
steps in these tears so this is actually

00:26:57,800 --> 00:27:03,410
implemented by a project called clevis

00:26:59,770 --> 00:27:05,870
and you can see the URL there this is

00:27:03,410 --> 00:27:08,840
client sign a pluggable key management

00:27:05,870 --> 00:27:11,660
so before when I said that Tang had a

00:27:08,840 --> 00:27:15,309
clevis pin a clevis pin is a plug-in for

00:27:11,660 --> 00:27:18,320
this framework so this actually provides

00:27:15,309 --> 00:27:20,570
HTTPS which is the standard escrow case

00:27:18,320 --> 00:27:22,429
that lots of people are already using so

00:27:20,570 --> 00:27:25,309
clevis can just go into that environment

00:27:22,429 --> 00:27:27,410
and work out of the box we also have

00:27:25,309 --> 00:27:30,200
support for custodial itch is a really

00:27:27,410 --> 00:27:32,840
really awesome key transfer framework

00:27:30,200 --> 00:27:34,370
and api that CMO is working on where are

00:27:32,840 --> 00:27:35,870
you see mo in the back if you have

00:27:34,370 --> 00:27:37,670
questions talk to him it's really cool

00:27:35,870 --> 00:27:41,240
so we actually support that

00:27:37,670 --> 00:27:43,220
out-of-the-box we have support for tang

00:27:41,240 --> 00:27:46,640
although it's not in this repo it's in

00:27:43,220 --> 00:27:49,580
the tag repo so so we did that to avoid

00:27:46,640 --> 00:27:51,550
circular dependencies we have support

00:27:49,580 --> 00:27:55,309
for password and support for some years

00:27:51,550 --> 00:27:58,190
this is minimal dependencies we only

00:27:55,309 --> 00:28:00,890
require openssl and lib Jansen but if

00:27:58,190 --> 00:28:04,640
you want HTTPS currently we require lib

00:28:00,890 --> 00:28:07,700
girl we are working also on early boots

00:28:04,640 --> 00:28:10,040
integration and this project is a little

00:28:07,700 --> 00:28:11,510
bit behind the tagging project that

00:28:10,040 --> 00:28:13,670
where the tank project is about to get

00:28:11,510 --> 00:28:16,370
its first release and is extensively

00:28:13,670 --> 00:28:19,520
tested this is still undergoing active

00:28:16,370 --> 00:28:21,760
development however I can give you a

00:28:19,520 --> 00:28:21,760
demo

00:28:29,970 --> 00:28:36,460
so we're going to start off here by

00:28:32,700 --> 00:28:40,570
actually bringing up our tank server you

00:28:36,460 --> 00:28:45,850
can see that the tank server is actually

00:28:40,570 --> 00:28:46,840
already running but there's no keys so

00:28:45,850 --> 00:28:49,420
the first thing we're going to do is

00:28:46,840 --> 00:28:53,680
we're going to generate a key and to do

00:28:49,420 --> 00:28:57,040
this make that full size so to do this

00:28:53,680 --> 00:28:58,390
we run the Tang gen command capital a

00:28:57,040 --> 00:29:01,540
means that we're going to advertise this

00:28:58,390 --> 00:29:04,540
key we're going to pick a crypto group

00:29:01,540 --> 00:29:07,270
to use and this is a signature key we

00:29:04,540 --> 00:29:08,560
also have to create a recovery key so

00:29:07,270 --> 00:29:10,420
that's it I don't have to do anything

00:29:08,560 --> 00:29:12,700
else my server has already picked up

00:29:10,420 --> 00:29:15,700
that those keys are available and will

00:29:12,700 --> 00:29:19,410
use them to any incoming connections so

00:29:15,700 --> 00:29:24,010
let's switch now to talking about clevis

00:29:19,410 --> 00:29:25,990
so we're going to go to the provisioning

00:29:24,010 --> 00:29:30,280
step we're going to start off pretty

00:29:25,990 --> 00:29:31,990
simple just a plain old password so what

00:29:30,280 --> 00:29:34,300
we have here is we have the clevis

00:29:31,990 --> 00:29:36,100
commander we're going to provision this

00:29:34,300 --> 00:29:37,750
is going to be our pin layout and we're

00:29:36,100 --> 00:29:39,520
all we're only specifying one pin and

00:29:37,750 --> 00:29:41,530
that's password and then we're going to

00:29:39,520 --> 00:29:46,060
store the provisioning metadata in a

00:29:41,530 --> 00:29:47,020
file called xxx so now we it's been

00:29:46,060 --> 00:29:49,300
we're being prompted for the password

00:29:47,020 --> 00:29:53,800
that we want to use on this provisioning

00:29:49,300 --> 00:29:55,570
i'm going to type in foo and it

00:29:53,800 --> 00:29:58,380
generates our cryptographically strong

00:29:55,570 --> 00:30:02,200
master keys is we're using currently

00:29:58,380 --> 00:30:04,150
aes-128 and so this is 128-bit key but

00:30:02,200 --> 00:30:07,180
it's encrypted using the password and

00:30:04,150 --> 00:30:08,170
now we can actually look in the file and

00:30:07,180 --> 00:30:10,480
we can see that it's just really a

00:30:08,170 --> 00:30:12,430
little bit of Jason where we're

00:30:10,480 --> 00:30:14,860
encrypting the cryptographically strong

00:30:12,430 --> 00:30:16,630
key using the password and key

00:30:14,860 --> 00:30:19,780
derivation and a variety of other

00:30:16,630 --> 00:30:21,910
parameters there and by the way if you

00:30:19,780 --> 00:30:24,670
were in the lux talk you heard about the

00:30:21,910 --> 00:30:27,540
lux metadata area which is now going to

00:30:24,670 --> 00:30:32,170
be in Jason notice that this is in Jason

00:30:27,540 --> 00:30:33,690
wonder what that might be about so now

00:30:32,170 --> 00:30:35,669
we want to

00:30:33,690 --> 00:30:38,639
that's this is per set up right so we've

00:30:35,669 --> 00:30:40,230
now set up say our partition and the

00:30:38,639 --> 00:30:41,940
next thing we want to do is we want to

00:30:40,230 --> 00:30:46,139
unlock it and this process is called

00:30:41,940 --> 00:30:49,320
acquiring and so we run the acquire we

00:30:46,139 --> 00:30:51,259
type in our password again and we get

00:30:49,320 --> 00:30:53,399
back our cryptic I've cryptographic key

00:30:51,259 --> 00:30:55,889
so now we want to do this in a

00:30:53,399 --> 00:30:58,409
completely automated way so we're going

00:30:55,889 --> 00:31:04,019
to provision again but this time we're

00:30:58,409 --> 00:31:06,269
going to use tang so again we're

00:31:04,019 --> 00:31:10,110
specifying just one pin which is a type

00:31:06,269 --> 00:31:12,210
tang and we have the coast to contact as

00:31:10,110 --> 00:31:13,620
localhost so we're going to run this and

00:31:12,210 --> 00:31:15,840
it's going to ask us if we want to trust

00:31:13,620 --> 00:31:19,139
our keys this is the same exact type of

00:31:15,840 --> 00:31:20,429
behavior you would get in say SSH so

00:31:19,139 --> 00:31:22,289
we're going to do trust on first use

00:31:20,429 --> 00:31:26,190
we're going to trust those keys and it

00:31:22,289 --> 00:31:30,059
generates our secure grip tub key there

00:31:26,190 --> 00:31:32,639
and we run the acquisition process again

00:31:30,059 --> 00:31:35,759
and without any password we get back the

00:31:32,639 --> 00:31:37,519
same key so this key by the way will be

00:31:35,759 --> 00:31:40,620
piped into your disk encryption or

00:31:37,519 --> 00:31:44,039
whatever else so let's look at one more

00:31:40,620 --> 00:31:47,580
example before we move on to nesting i'm

00:31:44,039 --> 00:31:52,710
going to start this little HTTP server

00:31:47,580 --> 00:31:55,019
and all that does is you can post data

00:31:52,710 --> 00:31:57,120
to it and it retains the data and then

00:31:55,019 --> 00:32:00,059
you can get the data back so it's like a

00:31:57,120 --> 00:32:07,590
fairly typical escrow service and so

00:32:00,059 --> 00:32:12,149
we're going to provision again and this

00:32:07,590 --> 00:32:16,080
time we are going to provision using our

00:32:12,149 --> 00:32:17,610
HTTP plug in right there and we're going

00:32:16,080 --> 00:32:18,990
to specify the format which is binary

00:32:17,610 --> 00:32:22,470
which means we're just sending the

00:32:18,990 --> 00:32:24,870
binary blob to the server so we run it

00:32:22,470 --> 00:32:26,429
again and you notice that we gotta put

00:32:24,870 --> 00:32:30,450
requests over here on the server so

00:32:26,429 --> 00:32:33,120
we've stored that in the HTTP server now

00:32:30,450 --> 00:32:35,279
we run acquisition we're going to get

00:32:33,120 --> 00:32:40,049
that object back from the server and we

00:32:35,279 --> 00:32:44,700
have the same exact crypto key again all

00:32:40,049 --> 00:32:48,409
right now we are going to look at

00:32:44,700 --> 00:32:48,409
nesting leaves with shimmers

00:32:48,620 --> 00:32:55,890
so here's an example with shim ears so

00:32:53,760 --> 00:32:57,390
we our route plugin is going to be shim

00:32:55,890 --> 00:32:59,220
ears and we're going to have a threshold

00:32:57,390 --> 00:33:02,100
of one we're going to have two children

00:32:59,220 --> 00:33:03,960
pins one of them is password and one of

00:33:02,100 --> 00:33:05,549
them is tang so this handles the case

00:33:03,960 --> 00:33:07,080
where if the tank server is available

00:33:05,549 --> 00:33:08,640
you type in your password or you don't

00:33:07,080 --> 00:33:10,080
type in your password but if the tank

00:33:08,640 --> 00:33:12,179
server is not available then you type in

00:33:10,080 --> 00:33:14,970
your password so we'll provision this it

00:33:12,179 --> 00:33:17,280
asks us for a password and it will

00:33:14,970 --> 00:33:20,490
contact the Tang server we trust the

00:33:17,280 --> 00:33:24,830
keys and it outputs are cryptographic

00:33:20,490 --> 00:33:27,179
key we run acquisition now watch this

00:33:24,830 --> 00:33:29,250
it's prompting for the password but I'm

00:33:27,179 --> 00:33:30,450
going to do nothing and as soon as it

00:33:29,250 --> 00:33:33,419
gets the result back from the tank

00:33:30,450 --> 00:33:36,690
server then we get back the same key

00:33:33,419 --> 00:33:38,250
immediately we do not have to wait and

00:33:36,690 --> 00:33:42,809
type in a password because our threshold

00:33:38,250 --> 00:33:49,710
was one so we can now change this

00:33:42,809 --> 00:33:51,750
threshold 22 and now we're going to

00:33:49,710 --> 00:33:54,090
require both so we'll type in our

00:33:51,750 --> 00:33:59,100
password again we will trust our keys

00:33:54,090 --> 00:34:01,860
from the server and now we unlock using

00:33:59,100 --> 00:34:03,390
the aqueous acquisition step and now I'm

00:34:01,860 --> 00:34:05,220
going to wait again and i'm getting a

00:34:03,390 --> 00:34:06,929
result from the server but it's not

00:34:05,220 --> 00:34:09,450
going to continue because our threshold

00:34:06,929 --> 00:34:12,060
is to at this point we have to type in

00:34:09,450 --> 00:34:14,850
our password in order to complete the

00:34:12,060 --> 00:34:19,980
chain and once the chain is completed we

00:34:14,850 --> 00:34:27,030
get our key back question what's happens

00:34:19,980 --> 00:34:31,320
if what up yeah we can do that not a

00:34:27,030 --> 00:34:35,000
problem so let's stop well I guess we

00:34:31,320 --> 00:34:35,000
can't let's do system

00:34:42,010 --> 00:34:45,810
so we'll stop the service and will stop

00:34:44,050 --> 00:34:49,659
the socket that activates the service

00:34:45,810 --> 00:34:52,780
and now we'll run our acquisition step

00:34:49,659 --> 00:34:55,630
again type in my password but it's going

00:34:52,780 --> 00:34:58,120
to timeout and not print a key because

00:34:55,630 --> 00:35:07,290
the tank server is not available and our

00:34:58,120 --> 00:35:07,290
exit status is nonzero yes

00:35:07,430 --> 00:35:18,030
I'm sorry what was the question I can't

00:35:12,930 --> 00:35:19,860
hear okay so rotation is not currently

00:35:18,030 --> 00:35:22,110
implemented it's going to be coming

00:35:19,860 --> 00:35:24,300
hopefully soon and the way that it works

00:35:22,110 --> 00:35:26,550
is that what the key that we trusted at

00:35:24,300 --> 00:35:27,840
the beginning of that phase was actually

00:35:26,550 --> 00:35:29,580
not the key that we're using for

00:35:27,840 --> 00:35:30,780
distribution that's actually the signing

00:35:29,580 --> 00:35:33,090
key if you remember at the start of the

00:35:30,780 --> 00:35:36,090
demo I created two keys assigning key

00:35:33,090 --> 00:35:38,940
and a recovery key the signing key is

00:35:36,090 --> 00:35:41,700
used to sign the advertisement of what

00:35:38,940 --> 00:35:44,190
keys the server has and that's the key

00:35:41,700 --> 00:35:47,310
we trust so our trust follows the chain

00:35:44,190 --> 00:35:49,740
of signing keys then the signing keys

00:35:47,310 --> 00:35:52,440
can sign other signing keys and then

00:35:49,740 --> 00:35:54,300
they can also sign recovery keys so at

00:35:52,440 --> 00:35:56,610
that point what happens on the server is

00:35:54,300 --> 00:35:59,880
when you want to rotate the keys you

00:35:56,610 --> 00:36:03,660
just generate new keys like we just did

00:35:59,880 --> 00:36:06,030
and then you modify the previous keys to

00:36:03,660 --> 00:36:07,860
not be advertised this means that the

00:36:06,030 --> 00:36:10,080
new the new clients will get the new

00:36:07,860 --> 00:36:12,170
keys but the old clients using the old

00:36:10,080 --> 00:36:15,840
keys will still continue to work and

00:36:12,170 --> 00:36:19,530
then when the when the clients running

00:36:15,840 --> 00:36:20,670
the old keys perform their rotation they

00:36:19,530 --> 00:36:22,590
will see the new keys in the

00:36:20,670 --> 00:36:24,540
advertisement upgrade to the new keys

00:36:22,590 --> 00:36:26,520
and after all the clients are updated

00:36:24,540 --> 00:36:35,630
then you can finally remove the old keys

00:36:26,520 --> 00:36:35,630
from the server what's up yes yeah

00:36:38,980 --> 00:36:45,680
this is where the names come from by the

00:36:41,120 --> 00:36:47,870
way it comes from any of the old

00:36:45,680 --> 00:36:50,090
techniques for binding things together

00:36:47,870 --> 00:36:52,250
like old handcuffs for instance a few if

00:36:50,090 --> 00:36:54,620
you've ever seen in museums old Roman

00:36:52,250 --> 00:36:56,360
handcuffs they would put your wrist

00:36:54,620 --> 00:36:58,460
through here and there would be a

00:36:56,360 --> 00:37:00,380
c-shaped thing and it's called a clevis

00:36:58,460 --> 00:37:03,350
and then the thing that it gets hooked

00:37:00,380 --> 00:37:05,510
to is the tang and then the pin is what

00:37:03,350 --> 00:37:12,070
binds it so that's where our terminology

00:37:05,510 --> 00:37:12,070
comes from any other questions yes

00:37:31,579 --> 00:37:36,029
nothing it's a and that's the whole

00:37:34,020 --> 00:37:38,520
point is that because you're sitting at

00:37:36,029 --> 00:37:40,440
your desk we consider that to be a high

00:37:38,520 --> 00:37:42,539
security environment right and this is

00:37:40,440 --> 00:37:45,119
part of that acceptable risk trade-off

00:37:42,539 --> 00:37:47,069
so again security is not binary it's

00:37:45,119 --> 00:37:49,349
something that people want some

00:37:47,069 --> 00:37:53,339
trade-off for security so they want to

00:37:49,349 --> 00:37:55,680
identify areas or situations in which a

00:37:53,339 --> 00:37:57,839
higher security policy is required and

00:37:55,680 --> 00:37:59,760
other situations in which a lower

00:37:57,839 --> 00:38:02,789
security policy is required so the

00:37:59,760 --> 00:38:05,760
answer is nothing prevents that and that

00:38:02,789 --> 00:38:07,650
choice was not made by me that's

00:38:05,760 --> 00:38:09,690
something that's really important the

00:38:07,650 --> 00:38:11,730
choice was not made by me as a developer

00:38:09,690 --> 00:38:15,150
it was made by the administrator who

00:38:11,730 --> 00:38:17,670
deployed it and that was made based upon

00:38:15,150 --> 00:38:20,700
a business justifications which is why i

00:38:17,670 --> 00:38:23,220
said and i highlighted this phrase let

00:38:20,700 --> 00:38:27,720
the business policy drive the crypto

00:38:23,220 --> 00:38:29,069
policy not vice versa so they've

00:38:27,720 --> 00:38:33,119
realized it was an acceptable trade-off

00:38:29,069 --> 00:38:38,000
and they chose that behavior what other

00:38:33,119 --> 00:38:38,000
questions yes

00:38:39,790 --> 00:38:48,619
yes it's it's theoretical and we haven't

00:38:42,619 --> 00:38:51,079
implemented it well if you have a

00:38:48,619 --> 00:38:52,550
thinkpad you probably have a fingerprint

00:38:51,079 --> 00:39:03,290
scanner so the practicality is pretty

00:38:52,550 --> 00:39:06,440
high you use you would use the

00:39:03,290 --> 00:39:08,599
fingerprint to encrypt a random key and

00:39:06,440 --> 00:39:11,510
the random key would then be handed back

00:39:08,599 --> 00:39:18,349
to the chain and to undo the chemise

00:39:11,510 --> 00:39:21,280
chain yes that's exactly the way the

00:39:18,349 --> 00:39:21,280
fingerprint scanning works

00:39:33,140 --> 00:39:39,020
this is the protocol itself I believe

00:39:37,380 --> 00:39:43,710
you're talking about the key exchange

00:39:39,020 --> 00:39:45,569
it's been it was published on on several

00:39:43,710 --> 00:39:47,910
crypto lists you were actually on those

00:39:45,569 --> 00:39:49,310
lists and you commented so I think

00:39:47,910 --> 00:39:51,900
that's I think that's why you're asking

00:39:49,310 --> 00:39:54,900
so yeah it was published to several

00:39:51,900 --> 00:39:57,119
Krypton lists we also advertised it at

00:39:54,900 --> 00:39:58,470
the storage developer conference and

00:39:57,119 --> 00:40:01,800
there was a crypto guy there who looked

00:39:58,470 --> 00:40:03,619
at it so the answer is it's not as is

00:40:01,800 --> 00:40:06,359
not been as we reviewed as I would like

00:40:03,619 --> 00:40:10,010
and you are happy to review it and we

00:40:06,359 --> 00:40:10,010
will we will definitely take that review

00:40:32,120 --> 00:40:39,240
can you think of some give me some ideas

00:40:34,710 --> 00:40:41,490
I'll take them okay looks like we're out

00:40:39,240 --> 00:40:43,320
of time thank you very much for coming

00:40:41,490 --> 00:40:44,790
if you were one of the people that asked

00:40:43,320 --> 00:40:46,110
questions there's I forgot to give out

00:40:44,790 --> 00:40:48,920
these scarves but they're up here if you

00:40:46,110 --> 00:40:48,920
want one come get them

00:41:08,960 --> 00:41:13,130
did it go I think it went well

00:41:20,950 --> 00:41:26,940
yeah so I read in the case for their

00:41:23,530 --> 00:41:26,940
important when things I wanted to see

00:41:30,220 --> 00:41:33,760
right next to mine

00:41:52,240 --> 00:41:57,820
so you should have plenty of time right

00:41:54,560 --> 00:41:57,820
yeah to catch everything

00:43:32,049 --> 00:43:34,079
I

00:43:36,040 --> 00:43:38,040

YouTube URL: https://www.youtube.com/watch?v=PIKRy3WEn74


