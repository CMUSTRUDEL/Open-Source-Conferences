Title: Interpreting CPU Performance Measurement Counters
Publication date: 2019-10-02
Playlist: DevConfUS 2019
Description: 
	Speaker: Ulrich Drepper

All modern CPUs have at least a few ways to get information about the performance of the currently running code. Desktop and especially server CPUs have an overwhelming number of events that can be counted. What can be counted and measured is tightly coupled to the CPU implementation and without understanding how a modern CPU is constructed. This will take as an example a modern Intel CPU, explain the CPU architecture, and then look and the PMCs and how they can be used.
Captions: 
	00:00:03,740 --> 00:00:11,010
all right this is the first of the two

00:00:09,300 --> 00:00:13,350
talks which I have their building to

00:00:11,010 --> 00:00:15,360
some extent on top of each other so you

00:00:13,350 --> 00:00:19,439
might think ninety minutes is a lot of

00:00:15,360 --> 00:00:21,989
content when I would give this talk so I

00:00:19,439 --> 00:00:23,970
have versions of this which I will

00:00:21,989 --> 00:00:27,329
probably be able to talk to you for a

00:00:23,970 --> 00:00:30,689
week about about this so this doesn't

00:00:27,329 --> 00:00:33,690
really expectation is not really that

00:00:30,689 --> 00:00:35,160
you will be able to be do much with us

00:00:33,690 --> 00:00:37,500
understand these kind of things is just

00:00:35,160 --> 00:00:39,870
to raise interest just like it is the

00:00:37,500 --> 00:00:42,149
case for most conference talks so don't

00:00:39,870 --> 00:00:44,460
be too disappointed if you are not able

00:00:42,149 --> 00:00:45,890
to sit down and immediately be an expert

00:00:44,460 --> 00:00:50,070
in these kind of things

00:00:45,890 --> 00:00:52,350
but at the same time they the topics are

00:00:50,070 --> 00:00:55,769
especially PMC's is of course nothing

00:00:52,350 --> 00:00:57,899
new and people were the very early days

00:00:55,769 --> 00:01:00,449
of course expecting oh yeah it's very

00:00:57,899 --> 00:01:02,999
easy to use because their time exactly

00:01:00,449 --> 00:01:05,610
what is going wrong with my program so

00:01:02,999 --> 00:01:07,950
in the first version of this after the

00:01:05,610 --> 00:01:10,680
first part of this talk so I will

00:01:07,950 --> 00:01:13,040
hopefully be able to dispel this myth a

00:01:10,680 --> 00:01:15,900
bit so that you actually realize that

00:01:13,040 --> 00:01:18,870
you do quite a bit of work to understand

00:01:15,900 --> 00:01:21,210
what I what is meant by this so and

00:01:18,870 --> 00:01:25,320
where's the this misconception coming

00:01:21,210 --> 00:01:29,330
from so in the those who are old enough

00:01:25,320 --> 00:01:32,090
might remember machines where he has

00:01:29,330 --> 00:01:34,650
instructions being executed nicely

00:01:32,090 --> 00:01:37,920
sequentially and son we always have two

00:01:34,650 --> 00:01:39,870
nice series of sequences each processor

00:01:37,920 --> 00:01:43,260
went through so this started from the

00:01:39,870 --> 00:01:46,470
early on so if you look at the 88 8008

00:01:43,260 --> 00:01:48,120
Intel processor 8080 once and so on they

00:01:46,470 --> 00:01:50,190
all have these nice stages each

00:01:48,120 --> 00:01:52,980
instruction went through a couple of

00:01:50,190 --> 00:01:55,200
memory cycles and so on and each of them

00:01:52,980 --> 00:01:57,150
were executing part of an instruction

00:01:55,200 --> 00:01:58,830
and so on we know exactly how the

00:01:57,150 --> 00:02:00,600
program was behavior we just have to

00:01:58,830 --> 00:02:02,430
look at the instruction and look up how

00:02:00,600 --> 00:02:04,080
many cycles it's instruction would take

00:02:02,430 --> 00:02:07,320
and be knew exactly what the throughput

00:02:04,080 --> 00:02:08,619
is and from that we were expected we

00:02:07,320 --> 00:02:11,470
were able to compute

00:02:08,619 --> 00:02:13,360
dude how how fast it is and we were able

00:02:11,470 --> 00:02:15,580
to see well if they make this and this

00:02:13,360 --> 00:02:18,159
and this change how much faster that's a

00:02:15,580 --> 00:02:22,120
program become so this already was

00:02:18,159 --> 00:02:24,970
weakened by the introduction pipeline

00:02:22,120 --> 00:02:28,060
processors we're now instead of having

00:02:24,970 --> 00:02:30,250
was just one single instruction fight we

00:02:28,060 --> 00:02:32,879
have multiple instructions which can be

00:02:30,250 --> 00:02:36,250
executed in parallel so they are not

00:02:32,879 --> 00:02:38,970
executing the same stage so this is

00:02:36,250 --> 00:02:41,950
something which was already on edit so

00:02:38,970 --> 00:02:44,109
by recognizing that the individual

00:02:41,950 --> 00:02:46,390
stages are executed to some extent at

00:02:44,109 --> 00:02:48,970
different parts of the CPU so why not

00:02:46,390 --> 00:02:52,390
keep all of the parts busy by executing

00:02:48,970 --> 00:02:54,400
different stages of each instruction so

00:02:52,390 --> 00:02:56,980
each a certain skew one of these

00:02:54,400 --> 00:02:59,500
horizontal bars this is an instruction

00:02:56,980 --> 00:03:02,620
and the yellow part is indicating that

00:02:59,500 --> 00:03:05,620
at any point in time you have from

00:03:02,620 --> 00:03:08,379
ideally from one instruction one part

00:03:05,620 --> 00:03:11,620
being executed at that point in time and

00:03:08,379 --> 00:03:14,200
the result is that we can have in this

00:03:11,620 --> 00:03:16,329
case in a typical five stage pipeline up

00:03:14,200 --> 00:03:19,450
to five instructions in fight at any

00:03:16,329 --> 00:03:21,430
point in time so of course usually this

00:03:19,450 --> 00:03:24,370
is not the case that if you have a

00:03:21,430 --> 00:03:26,980
program which completely maps to this

00:03:24,370 --> 00:03:28,480
kind of execution scheme all the time so

00:03:26,980 --> 00:03:30,940
you have bubbles in there you have

00:03:28,480 --> 00:03:32,829
dependencies which you cannot start with

00:03:30,940 --> 00:03:34,660
the execution of one instruction until

00:03:32,829 --> 00:03:35,889
you actually have two results of a prior

00:03:34,660 --> 00:03:38,829
instruction et cetera

00:03:35,889 --> 00:03:41,769
at which point some of these rows bases

00:03:38,829 --> 00:03:44,260
are empty and dandy instruction

00:03:41,769 --> 00:03:47,560
throughput false so this is something

00:03:44,260 --> 00:03:50,230
which meets performance estimates quite

00:03:47,560 --> 00:03:52,540
a lot harder it still was possible

00:03:50,230 --> 00:03:55,180
because it was predictable in the sense

00:03:52,540 --> 00:03:56,919
that memory accesses et cetera back in

00:03:55,180 --> 00:03:59,169
the days when these chemical and process

00:03:56,919 --> 00:04:01,660
architectures were prevalent so memory

00:03:59,169 --> 00:04:04,000
accesses we're still most be predictable

00:04:01,660 --> 00:04:06,669
because the CPU core speed and the

00:04:04,000 --> 00:04:09,910
memory speed have not yet diverged that

00:04:06,669 --> 00:04:13,989
much from each other and therefore we

00:04:09,910 --> 00:04:15,669
were still able to estimate to some

00:04:13,989 --> 00:04:18,870
extent what the time is but we

00:04:15,669 --> 00:04:21,540
frequently and very early on

00:04:18,870 --> 00:04:23,850
help in the form of what is usually

00:04:21,540 --> 00:04:26,370
called a timestamp counter of some sort

00:04:23,850 --> 00:04:29,010
so on the X to the six front this was

00:04:26,370 --> 00:04:30,750
introduced in the 556 already back in

00:04:29,010 --> 00:04:33,479
the base where we had a dedicated

00:04:30,750 --> 00:04:36,419
register where at any point in time we

00:04:33,479 --> 00:04:38,130
were able to request a number 64 bit

00:04:36,419 --> 00:04:41,160
number in this case which were

00:04:38,130 --> 00:04:45,330
indicating how many cycles of some sort

00:04:41,160 --> 00:04:47,910
have been have elapsed since the

00:04:45,330 --> 00:04:50,100
beginning of whatever so usually the

00:04:47,910 --> 00:04:53,280
reboot of the last reboot of the machine

00:04:50,100 --> 00:04:55,590
and by subtracting the two numbers each

00:04:53,280 --> 00:04:58,680
of the numbers got assigned to one cycle

00:04:55,590 --> 00:05:01,199
and by subtracting two numbers we knew

00:04:58,680 --> 00:05:03,539
exactly how many cycles were between

00:05:01,199 --> 00:05:05,820
inside an interval which we want to

00:05:03,539 --> 00:05:08,520
measure so this was useful

00:05:05,820 --> 00:05:10,320
so we also could estimate at the very

00:05:08,520 --> 00:05:12,510
least how many instructions were

00:05:10,320 --> 00:05:14,310
executed and therefore going like cycles

00:05:12,510 --> 00:05:17,760
per instruction which after this day is

00:05:14,310 --> 00:05:21,030
a very important measure and we could

00:05:17,760 --> 00:05:23,550
able to estimate therefore how effective

00:05:21,030 --> 00:05:26,580
a program was executed and we also were

00:05:23,550 --> 00:05:28,169
able to measure what kind of effects a

00:05:26,580 --> 00:05:30,630
certain change those program actually

00:05:28,169 --> 00:05:33,300
had so these were absolute numbers and

00:05:30,630 --> 00:05:37,139
we were able to use them to effectively

00:05:33,300 --> 00:05:40,110
measure how a program behaves so this

00:05:37,139 --> 00:05:42,330
kind of thing who is still possible

00:05:40,110 --> 00:05:44,099
today for some of the simpler processes

00:05:42,330 --> 00:05:47,099
so which you mostly find in the embedded

00:05:44,099 --> 00:05:49,380
realm so if they are not usually out of

00:05:47,099 --> 00:05:51,180
order execution processors so as they're

00:05:49,380 --> 00:05:53,880
called so they're just in order just

00:05:51,180 --> 00:05:56,099
like this maybe they have simplified

00:05:53,880 --> 00:05:59,970
stage pipelines like this as well and

00:05:56,099 --> 00:06:04,410
this is still a very valid method if it

00:05:59,970 --> 00:06:06,840
applies so but hardly anyone outside the

00:06:04,410 --> 00:06:09,150
realm of the embedded development world

00:06:06,840 --> 00:06:14,639
is using this type of process at all

00:06:09,150 --> 00:06:16,979
today it more looks like this so I

00:06:14,639 --> 00:06:21,440
always like to answer asked the question

00:06:16,979 --> 00:06:23,280
what is this because the connoisseur of

00:06:21,440 --> 00:06:25,610
microarchitecture will know exactly what

00:06:23,280 --> 00:06:25,610
it is

00:06:39,460 --> 00:06:50,480
no one it's it's obviously sunny Cove

00:06:43,760 --> 00:06:52,760
core yeah well no no that's the core

00:06:50,480 --> 00:06:54,980
it's just this is just an exodus six

00:06:52,760 --> 00:06:57,800
core implementation of the CPU the

00:06:54,980 --> 00:07:00,200
entire CPU just a single core and more

00:06:57,800 --> 00:07:02,390
specifically the samokov architecture

00:07:00,200 --> 00:07:06,670
not skylake the next generation of the

00:07:02,390 --> 00:07:10,790
skylake that's what this is so this

00:07:06,670 --> 00:07:13,100
looks like a complicated picture and it

00:07:10,790 --> 00:07:14,540
is even more complicated and when you're

00:07:13,100 --> 00:07:16,820
actually using this thing because

00:07:14,540 --> 00:07:19,840
basically all of these errors all of

00:07:16,820 --> 00:07:23,210
these boxes which are you see here are

00:07:19,840 --> 00:07:25,610
individually acting parts of the system

00:07:23,210 --> 00:07:27,560
which can of had not any point in time

00:07:25,610 --> 00:07:30,400
work on something are not work on

00:07:27,560 --> 00:07:34,370
something et cetera then the introducing

00:07:30,400 --> 00:07:36,050
problems related to overuse they're

00:07:34,370 --> 00:07:38,210
interesting problems because they're

00:07:36,050 --> 00:07:41,540
well my dad they're pendants et cetera

00:07:38,210 --> 00:07:44,020
et cetera so what I see every single

00:07:41,540 --> 00:07:46,190
line which you see here has some

00:07:44,020 --> 00:07:48,140
importance when it comes to amaz

00:07:46,190 --> 00:07:50,140
improving performance which actually

00:07:48,140 --> 00:07:53,120
running these kind of things and to

00:07:50,140 --> 00:07:55,940
understand and explain the performance

00:07:53,120 --> 00:07:59,420
of product you would have to add for

00:07:55,940 --> 00:08:01,610
every single sequence of instructions

00:07:59,420 --> 00:08:04,100
you would have to see what is actually

00:08:01,610 --> 00:08:06,470
going on the CPU and explain this based

00:08:04,100 --> 00:08:08,810
on these individual pieces and that even

00:08:06,470 --> 00:08:10,700
left out here completely only right-hand

00:08:08,810 --> 00:08:13,130
side you see there is a connection to

00:08:10,700 --> 00:08:15,230
the other course or more correctly the

00:08:13,130 --> 00:08:17,390
first of all truly what is Intel's

00:08:15,230 --> 00:08:19,790
calling uncaught parts the parts which

00:08:17,390 --> 00:08:22,310
are supporting all the course to which

00:08:19,790 --> 00:08:24,500
among other things the main memory and

00:08:22,310 --> 00:08:26,390
the last little cache are attached so

00:08:24,500 --> 00:08:30,200
these things are even left out here and

00:08:26,390 --> 00:08:32,419
those are today with what I mentioned

00:08:30,200 --> 00:08:35,060
before the discrepancy in speed between

00:08:32,419 --> 00:08:37,160
the the course in the memory where the

00:08:35,060 --> 00:08:39,110
memories or is of magnitude slower than

00:08:37,160 --> 00:08:40,700
that so that we have to introduce caches

00:08:39,110 --> 00:08:43,219
et cetera and sound but they are also

00:08:40,700 --> 00:08:46,040
introducing inconsistencies to

00:08:43,219 --> 00:08:48,110
introducing randomness and the active

00:08:46,040 --> 00:08:51,140
couple all of these kind of things

00:08:48,110 --> 00:08:53,210
together means that you are today

00:08:51,140 --> 00:08:57,320
absolutely not

00:08:53,210 --> 00:09:00,200
capable of describing how a program is

00:08:57,320 --> 00:09:03,670
really behaving when it is executing on

00:09:00,200 --> 00:09:06,410
such a core it's absolutely impossible

00:09:03,670 --> 00:09:09,050
this there's so much randomness going on

00:09:06,410 --> 00:09:13,130
that one run to the other it will behave

00:09:09,050 --> 00:09:16,100
differently period so but even if this

00:09:13,130 --> 00:09:18,200
would not be there instead just look at

00:09:16,100 --> 00:09:20,390
a number of different things which are

00:09:18,200 --> 00:09:23,990
mentioned here has sank all of them have

00:09:20,390 --> 00:09:26,960
their own own manifestation when it

00:09:23,990 --> 00:09:29,060
comes to the utilization after various

00:09:26,960 --> 00:09:32,060
instructions to see how your program is

00:09:29,060 --> 00:09:34,550
using on top of this view each of them

00:09:32,060 --> 00:09:36,950
you would have to model and understand

00:09:34,550 --> 00:09:41,720
how they interact in which other this is

00:09:36,950 --> 00:09:43,910
truly impossible so and in addition to

00:09:41,720 --> 00:09:46,700
that we have the problem that the

00:09:43,910 --> 00:09:49,310
programs we are running so even if you

00:09:46,700 --> 00:09:52,130
if you just try to say hey I can try to

00:09:49,310 --> 00:09:55,550
understand this for my program this is

00:09:52,130 --> 00:09:59,600
not what the next program will be no

00:09:55,550 --> 00:10:02,120
will do so the different programs can

00:09:59,600 --> 00:10:05,630
stress different parts of the CPU

00:10:02,120 --> 00:10:08,150
completely differently and therefore one

00:10:05,630 --> 00:10:10,400
analysis doesn't translate at all to the

00:10:08,150 --> 00:10:14,210
next one every single program has to be

00:10:10,400 --> 00:10:16,910
analyzed individually and even that is a

00:10:14,210 --> 00:10:19,790
simplification because a program usually

00:10:16,910 --> 00:10:23,090
is not homogeneous in over time in what

00:10:19,790 --> 00:10:25,550
it is actually executing so at the very

00:10:23,090 --> 00:10:28,580
least every program has to start our

00:10:25,550 --> 00:10:31,100
face of some sort then it has a perhaps

00:10:28,580 --> 00:10:33,260
some IO face some compute stuff and

00:10:31,100 --> 00:10:36,140
perhaps another IO face and then perhaps

00:10:33,260 --> 00:10:38,180
it repeats the whole thing etcetera so

00:10:36,140 --> 00:10:40,280
all these different phases ins are are

00:10:38,180 --> 00:10:42,650
stressing the system differently and you

00:10:40,280 --> 00:10:45,980
would have to map the different phases

00:10:42,650 --> 00:10:49,670
to the different parts of the code and

00:10:45,980 --> 00:10:52,140
down to the to the appropriate unit

00:10:49,670 --> 00:10:55,540
inside the CPU and make an

00:10:52,140 --> 00:10:58,090
for each of these different phases and

00:10:55,540 --> 00:11:01,000
stuff for the program as a whole so you

00:10:58,090 --> 00:11:06,520
see this is a tremendously hard problem

00:11:01,000 --> 00:11:08,830
nowadays and we need help so what is

00:11:06,520 --> 00:11:12,160
actually possible today's of course this

00:11:08,830 --> 00:11:14,140
is not something which is unobserved by

00:11:12,160 --> 00:11:18,460
other folks are actually producing these

00:11:14,140 --> 00:11:23,230
kind of machines for us obviously so

00:11:18,460 --> 00:11:28,510
let's start by a nice little analogy so

00:11:23,230 --> 00:11:31,810
I like to give as an example yes assume

00:11:28,510 --> 00:11:33,730
you have a pipe system so any physicist

00:11:31,810 --> 00:11:38,560
here who knew something like

00:11:33,730 --> 00:11:41,890
hydrodynamic so don't we don't use water

00:11:38,560 --> 00:11:43,870
we use a compressible some compressible

00:11:41,890 --> 00:11:46,030
fuel who lived in this case it's easy to

00:11:43,870 --> 00:11:49,360
ignite a map assume you have something

00:11:46,030 --> 00:11:52,480
coming out coming in the nd at the top

00:11:49,360 --> 00:11:54,550
and you want to somehow control or

00:11:52,480 --> 00:11:56,770
whatever the the way it comes out in the

00:11:54,550 --> 00:12:00,010
end so you have different ways it can

00:11:56,770 --> 00:12:02,260
move different length of pipes you have

00:12:00,010 --> 00:12:04,000
valves in different places and so on and

00:12:02,260 --> 00:12:06,850
then any point of time they can behave

00:12:04,000 --> 00:12:09,640
differently and you want to compute

00:12:06,850 --> 00:12:12,670
something like this this is a somewhat

00:12:09,640 --> 00:12:15,970
rough analogy what is going on in in a

00:12:12,670 --> 00:12:19,810
big CPU system where you have problems

00:12:15,970 --> 00:12:22,360
with different diameters of things so

00:12:19,810 --> 00:12:26,200
which corresponds to different sized

00:12:22,360 --> 00:12:28,660
pathways inside the CPU beads for just

00:12:26,200 --> 00:12:32,110
transport or for calculation and so on

00:12:28,660 --> 00:12:33,700
you have different lengths so it takes

00:12:32,110 --> 00:12:35,589
different amount of time for the

00:12:33,700 --> 00:12:38,170
material to be transported with that

00:12:35,589 --> 00:12:39,990
which by itself of course is regulating

00:12:38,170 --> 00:12:43,210
the flow so we have these kind of things

00:12:39,990 --> 00:12:46,750
inside the CPU where the performing and

00:12:43,210 --> 00:12:48,610
addition is very fast while if you have

00:12:46,750 --> 00:12:52,029
something like and it

00:12:48,610 --> 00:12:54,249
a division to be executed that by its

00:12:52,029 --> 00:12:58,989
nature of the operation will take a

00:12:54,249 --> 00:13:01,029
longer amount of time we have the

00:12:58,989 --> 00:13:03,369
equivalent of vows which are closed or

00:13:01,029 --> 00:13:06,069
opened so if they're closed so the the

00:13:03,369 --> 00:13:09,129
pathway is not able to be used in this

00:13:06,069 --> 00:13:11,679
case similarly we have shared resources

00:13:09,129 --> 00:13:13,959
in the CPU which for the execution of a

00:13:11,679 --> 00:13:16,600
specific program for some period of time

00:13:13,959 --> 00:13:19,480
might not be available so that's a bit

00:13:16,600 --> 00:13:21,639
take knowledge count we also have we

00:13:19,480 --> 00:13:24,660
think that we might only be able to

00:13:21,639 --> 00:13:27,399
extract an insert into the system

00:13:24,660 --> 00:13:30,459
material at a certain rate and maximum

00:13:27,399 --> 00:13:31,899
rate well which means that even if we

00:13:30,459 --> 00:13:36,040
are doing something in the middle which

00:13:31,899 --> 00:13:38,470
is fantastically high-performing and it

00:13:36,040 --> 00:13:40,839
can transport as much as we want well it

00:13:38,470 --> 00:13:43,920
will not have a positive effect because

00:13:40,839 --> 00:13:46,629
we cannot produce or consume appropriate

00:13:43,920 --> 00:13:49,420
amounts of material in this case in our

00:13:46,629 --> 00:13:52,299
case your instructions so we have of

00:13:49,420 --> 00:13:55,360
course limitations when it comes to just

00:13:52,299 --> 00:13:58,299
reading the code from from data from the

00:13:55,360 --> 00:14:00,339
memory or storing data and reading data

00:13:58,299 --> 00:14:01,959
and so on which puts an absolute limit

00:14:00,339 --> 00:14:05,199
as to what become consume and produce

00:14:01,959 --> 00:14:07,779
and discounting translates to the system

00:14:05,199 --> 00:14:13,480
as well finally what happens there is

00:14:07,779 --> 00:14:16,419
that the available of salinity material

00:14:13,480 --> 00:14:21,069
which is transported over whatever comes

00:14:16,419 --> 00:14:24,129
in it top must also go out at the bottom

00:14:21,069 --> 00:14:26,169
so with this means that they are not

00:14:24,129 --> 00:14:29,259
independent of each other we cannot just

00:14:26,169 --> 00:14:30,970
arbitrarily long consume more because

00:14:29,259 --> 00:14:34,299
the bar the internal volume of the

00:14:30,970 --> 00:14:36,100
system with the in the CPU sends the

00:14:34,299 --> 00:14:39,189
number of instructions which can be

00:14:36,100 --> 00:14:41,679
stored as being in flight is finite

00:14:39,189 --> 00:14:43,899
actually is a really resolutely small

00:14:41,679 --> 00:14:46,419
number depending on the complexity of

00:14:43,899 --> 00:14:48,730
the CPU it can grow so nowadays we can

00:14:46,419 --> 00:14:51,639
interfere we have a hundred instructions

00:14:48,730 --> 00:14:53,499
going on before any of them has to be

00:14:51,639 --> 00:14:56,290
what is called retire before they

00:14:53,499 --> 00:14:59,110
actually are terminating but there is a

00:14:56,290 --> 00:15:00,819
fixed limit as to that and we have to

00:14:59,110 --> 00:15:01,300
take all of these kind of things into

00:15:00,819 --> 00:15:03,459
account

00:15:01,300 --> 00:15:05,709
when we are analyzing the program

00:15:03,459 --> 00:15:07,660
because at some point we might make

00:15:05,709 --> 00:15:09,880
assumptions about how the program is

00:15:07,660 --> 00:15:11,560
done but any of these limits and son

00:15:09,880 --> 00:15:14,769
might be violated and therefore always

00:15:11,560 --> 00:15:17,740
something's wrong so it's very difficult

00:15:14,769 --> 00:15:20,050
I want you to use to look FD on

00:15:17,740 --> 00:15:21,579
individual pieces but then also have to

00:15:20,050 --> 00:15:23,529
create keep all these boundary

00:15:21,579 --> 00:15:26,920
conditions in in mind when we are

00:15:23,529 --> 00:15:28,420
actually analyzing the curves so let's

00:15:26,920 --> 00:15:31,810
go back to the picture which you saw

00:15:28,420 --> 00:15:35,260
before so what can actually go wrong

00:15:31,810 --> 00:15:39,240
when we are executing code there this is

00:15:35,260 --> 00:15:42,579
a tiny tiny little subset of what is

00:15:39,240 --> 00:15:45,100
possibly going on in some situations we

00:15:42,579 --> 00:15:46,810
are actually calling them hazards so

00:15:45,100 --> 00:15:49,060
these are things were between the

00:15:46,810 --> 00:15:50,680
program execution something is not right

00:15:49,060 --> 00:15:53,709
and we have to do something usually

00:15:50,680 --> 00:15:55,300
meaning waiting so and I'm not reading

00:15:53,709 --> 00:15:56,950
through them you're right now so

00:15:55,300 --> 00:15:59,200
completely so it doesn't really matter

00:15:56,950 --> 00:16:01,870
you just see that we have different

00:15:59,200 --> 00:16:04,300
types of situations in which we are

00:16:01,870 --> 00:16:07,209
waiting for something to happen and they

00:16:04,300 --> 00:16:13,270
are mapping to individual pieces in the

00:16:07,209 --> 00:16:16,089
actual CPU core an execution of a CPU as

00:16:13,270 --> 00:16:19,899
instruction inside the core actually

00:16:16,089 --> 00:16:22,570
worse not randomly in some there so they

00:16:19,899 --> 00:16:26,470
actually follow a path through this core

00:16:22,570 --> 00:16:30,240
implementation at the very top there you

00:16:26,470 --> 00:16:33,640
will see the level 1 instruction cache

00:16:30,240 --> 00:16:36,430
which feeds the data coming in which is

00:16:33,640 --> 00:16:41,040
the program into the instruction decoder

00:16:36,430 --> 00:16:44,050
and cetera so which translates the

00:16:41,040 --> 00:16:45,339
assembly language a binary code into

00:16:44,050 --> 00:16:48,490
something to see if you can actually

00:16:45,339 --> 00:16:51,040
work on so that's by the way whoever

00:16:48,490 --> 00:16:53,290
thinks X to the 6 is assist architecture

00:16:51,040 --> 00:16:55,480
so really doesn't know how to use work

00:16:53,290 --> 00:16:57,790
every rocket every see if you now this

00:16:55,480 --> 00:17:00,310
is the RISC architecture because the

00:16:57,790 --> 00:17:03,070
first thing an X to the 6 processor does

00:17:00,310 --> 00:17:04,780
it translates every instruction into

00:17:03,070 --> 00:17:08,050
risk instructions which are called micro

00:17:04,780 --> 00:17:09,850
ops in Intel terminology so the

00:17:08,050 --> 00:17:11,680
instruction guide translate

00:17:09,850 --> 00:17:13,720
into this micro absent and they are

00:17:11,680 --> 00:17:16,290
approached in the waiting queue and then

00:17:13,720 --> 00:17:19,690
when all the preconditions are met plus

00:17:16,290 --> 00:17:23,410
the appropriate unit which can perform

00:17:19,690 --> 00:17:26,490
the action which individual Markov is is

00:17:23,410 --> 00:17:29,530
asking for then it gets executed and

00:17:26,490 --> 00:17:32,590
after the execution the result might

00:17:29,530 --> 00:17:35,680
linger around for a while until the

00:17:32,590 --> 00:17:37,900
logic of the in the the secrets of its

00:17:35,680 --> 00:17:40,990
richness tells it oh yeah by that time

00:17:37,900 --> 00:17:43,600
now the result of this instruction can

00:17:40,990 --> 00:17:45,250
be used it is has been verified that

00:17:43,600 --> 00:17:48,010
this is the right way of doing things

00:17:45,250 --> 00:17:50,080
and therefore the results are written in

00:17:48,010 --> 00:17:52,480
in the permanent state so there are all

00:17:50,080 --> 00:17:54,490
kinds of instructions in this reorder

00:17:52,480 --> 00:17:56,620
buffer and so on that can be hundred

00:17:54,490 --> 00:17:59,710
instructions going on and floating

00:17:56,620 --> 00:18:02,890
around at any one time usually it's not

00:17:59,710 --> 00:18:05,350
that many because the program has too

00:18:02,890 --> 00:18:08,770
many possibilities to actually run if

00:18:05,350 --> 00:18:10,390
the hazards and therefore I you rarely

00:18:08,770 --> 00:18:12,780
feel this kind of thing but really

00:18:10,390 --> 00:18:16,450
really well-written code but lots of

00:18:12,780 --> 00:18:19,090
linearly executed instructions could

00:18:16,450 --> 00:18:20,800
potentially fill the reorder buffer

00:18:19,090 --> 00:18:22,720
completely and therefore make the

00:18:20,800 --> 00:18:25,780
process are really happy because it can

00:18:22,720 --> 00:18:27,760
just an issue many many instructions

00:18:25,780 --> 00:18:30,310
right away and the number of

00:18:27,760 --> 00:18:31,930
instructions which are executed in point

00:18:30,310 --> 00:18:34,330
in time is also something which has

00:18:31,930 --> 00:18:36,010
changed over time so in the beginning I

00:18:34,330 --> 00:18:37,600
mentioned we are working on one single

00:18:36,010 --> 00:18:39,700
instruction at a time then in the

00:18:37,600 --> 00:18:43,840
pipeline methods after five instructions

00:18:39,700 --> 00:18:46,180
here we can potentially issue four or

00:18:43,840 --> 00:18:49,120
five depending on the architecture micro

00:18:46,180 --> 00:18:52,150
instructions per cycle to be executed to

00:18:49,120 --> 00:18:54,580
the individual what they're calling here

00:18:52,150 --> 00:18:56,830
pipelines and so on and inside the

00:18:54,580 --> 00:18:58,510
pipelines we can have much of in some of

00:18:56,830 --> 00:19:00,490
their patterns they are not finishing a

00:18:58,510 --> 00:19:02,290
one single cycle and they can have

00:19:00,490 --> 00:19:05,080
multiple instructions in each of these

00:19:02,290 --> 00:19:07,570
pipeline stages as well so you have not

00:19:05,080 --> 00:19:10,480
only couple of instructions dozens

00:19:07,570 --> 00:19:12,130
hundred instruction to be a decoded any

00:19:10,480 --> 00:19:14,890
point of time you might even have a

00:19:12,130 --> 00:19:17,320
dozen of instructions being executed at

00:19:14,890 --> 00:19:20,610
the same time and that perhaps every

00:19:17,320 --> 00:19:24,690
single cycle in fact if you do

00:19:20,610 --> 00:19:29,429
the analysis on normal coach on Exodus

00:19:24,690 --> 00:19:31,080
six today if you have the if the number

00:19:29,429 --> 00:19:33,570
of instructions which at any point in

00:19:31,080 --> 00:19:35,820
time is executed at the same time what

00:19:33,570 --> 00:19:38,029
issued from the reorder buffer to

00:19:35,820 --> 00:19:40,470
execution part if this dips below two

00:19:38,029 --> 00:19:41,580
you know your program is in really

00:19:40,470 --> 00:19:45,210
really deep trouble

00:19:41,580 --> 00:19:48,510
we are we are aiming for instructions

00:19:45,210 --> 00:19:50,580
per cycle which is another measure which

00:19:48,510 --> 00:19:53,130
is quite important so we want to have

00:19:50,580 --> 00:19:55,139
the IPC value to be larger than two

00:19:53,130 --> 00:19:56,940
maybe even larger than three at any

00:19:55,139 --> 00:19:58,919
point in time for the program and so on

00:19:56,940 --> 00:20:00,929
that that's a good while performing

00:19:58,919 --> 00:20:03,210
program anything low is really really

00:20:00,929 --> 00:20:05,370
bad so you know you can imagine there

00:20:03,210 --> 00:20:07,380
are so many things going on and in any

00:20:05,370 --> 00:20:09,620
of these kind of stages over act as a

00:20:07,380 --> 00:20:12,330
representative at ease right dots

00:20:09,620 --> 00:20:15,269
something can go wrong there are all

00:20:12,330 --> 00:20:17,850
kinds of different things they're

00:20:15,269 --> 00:20:20,070
mapping to caches to the behavior that

00:20:17,850 --> 00:20:21,929
you might actually don't find the data

00:20:20,070 --> 00:20:24,000
in the caches all you have to write

00:20:21,929 --> 00:20:25,710
something out or you have a dependency

00:20:24,000 --> 00:20:27,149
of one instruction on the next

00:20:25,710 --> 00:20:30,570
instruction till all are mapping to

00:20:27,149 --> 00:20:33,360
different parts of the CPU itself so

00:20:30,570 --> 00:20:35,580
it's not that you can isolate in an

00:20:33,360 --> 00:20:36,889
isolation look at an individual part you

00:20:35,580 --> 00:20:39,929
have to look at the whole thing

00:20:36,889 --> 00:20:43,409
completely and try to find out by

00:20:39,929 --> 00:20:47,460
feedback from the CPU what your program

00:20:43,409 --> 00:20:51,000
actually is in lack of in most

00:20:47,460 --> 00:20:53,639
situations so and just to make sure so

00:20:51,000 --> 00:20:56,750
this is sad one of the last last

00:20:53,639 --> 00:21:01,260
generation exited six course this is not

00:20:56,750 --> 00:21:02,850
unique to that so here is a new picture

00:21:01,260 --> 00:21:05,549
one of the new features which I've got

00:21:02,850 --> 00:21:09,179
this time around this is an ARM Cortex

00:21:05,549 --> 00:21:10,980
a 72 core so you probably have now seen

00:21:09,179 --> 00:21:14,700
it exactly in this form so it's not I

00:21:10,980 --> 00:21:16,919
drew this myself to map somewhat closely

00:21:14,700 --> 00:21:19,740
to what the x86 core you saw on the

00:21:16,919 --> 00:21:22,380
previous slide is looking like that's

00:21:19,740 --> 00:21:23,820
not that much difference so especially

00:21:22,380 --> 00:21:26,340
you feel a little bit under not really

00:21:23,820 --> 00:21:28,550
that well versed in microarchitecture of

00:21:26,340 --> 00:21:30,310
CPUs you know your forgive

00:21:28,550 --> 00:21:32,570
if you think it's pretty much the same

00:21:30,310 --> 00:21:34,490
so we have the same thing we have

00:21:32,570 --> 00:21:35,840
different different ports in which

00:21:34,490 --> 00:21:38,480
different types of instruction can be

00:21:35,840 --> 00:21:40,910
executed you have various caches of

00:21:38,480 --> 00:21:43,730
levels you have decoders et cetera et

00:21:40,910 --> 00:21:46,070
cetera so the problem is exactly the

00:21:43,730 --> 00:21:48,020
same regardless of what kind of CP

00:21:46,070 --> 00:21:49,910
you're using as long as not one of these

00:21:48,020 --> 00:21:53,300
very trivial ones this microcontroller

00:21:49,910 --> 00:21:56,780
source on so the problem we have to

00:21:53,300 --> 00:22:00,230
solve is not unique to the Big Horn x86

00:21:56,780 --> 00:22:02,360
it's a general problem the thing which

00:22:00,230 --> 00:22:05,510
also should point out at this point says

00:22:02,360 --> 00:22:07,460
the number of points with Jackie on the

00:22:05,510 --> 00:22:10,640
right hand side is in this case a little

00:22:07,460 --> 00:22:12,740
bit has shorter evangelists which had on

00:22:10,640 --> 00:22:14,750
the previous slides but all of the

00:22:12,740 --> 00:22:16,850
points which you see here on the right

00:22:14,750 --> 00:22:20,330
hand side are also present on the

00:22:16,850 --> 00:22:23,300
previous slide so they are easy to map

00:22:20,330 --> 00:22:26,020
specific events which be which are

00:22:23,300 --> 00:22:28,640
causing problems to whatever

00:22:26,020 --> 00:22:32,090
architecture the CPU cores actually

00:22:28,640 --> 00:22:33,950
haven't so it's not that every single

00:22:32,090 --> 00:22:37,220
architecture has a completely different

00:22:33,950 --> 00:22:39,500
set of hazards in which which we have to

00:22:37,220 --> 00:22:42,440
look into there are there's a lot of

00:22:39,500 --> 00:22:44,840
commonality there how in exactly where

00:22:42,440 --> 00:22:46,760
we find them and perhaps how we can

00:22:44,840 --> 00:22:49,850
observe them might differ from the one

00:22:46,760 --> 00:22:51,650
CPU to the next but if you are looking

00:22:49,850 --> 00:22:53,810
at with a little bit of abstraction

00:22:51,650 --> 00:22:55,490
that's something which we can actually

00:22:53,810 --> 00:22:57,680
do and that's something which we're

00:22:55,490 --> 00:22:59,150
going to look at now but more

00:22:57,680 --> 00:23:02,840
importantly before we actually get into

00:22:59,150 --> 00:23:06,470
the point is simply that the concept of

00:23:02,840 --> 00:23:09,500
a counter has been introduced fairly

00:23:06,470 --> 00:23:12,380
having a long time back as I mentioned

00:23:09,500 --> 00:23:16,040
the TSC the timestamp counter was

00:23:12,380 --> 00:23:20,300
introduced in the 586 soon after that in

00:23:16,040 --> 00:23:24,320
686 we got the first the first instances

00:23:20,300 --> 00:23:28,060
of programmable counters inside so

00:23:24,320 --> 00:23:31,640
measurement counters inside the CPUs

00:23:28,060 --> 00:23:33,260
Exodus 6 was not really the the

00:23:31,640 --> 00:23:33,610
architecture at the forefront of these

00:23:33,260 --> 00:23:35,080
kind

00:23:33,610 --> 00:23:38,740
things quite honestly back in those days

00:23:35,080 --> 00:23:40,840
the idea the architecture which was most

00:23:38,740 --> 00:23:43,720
prominent when it comes to these kind of

00:23:40,840 --> 00:23:47,799
things was the Dec alpha so Jo might see

00:23:43,720 --> 00:23:49,600
like that the shout out so um that I

00:23:47,799 --> 00:23:50,980
thought was ahead of its time and it

00:23:49,600 --> 00:23:52,570
came to these kind of things they have

00:23:50,980 --> 00:23:58,090
these kind of performance counters off

00:23:52,570 --> 00:24:00,580
of the CPU and they have the that one of

00:23:58,090 --> 00:24:02,650
the concepts behind these performance

00:24:00,580 --> 00:24:06,730
counters is that yes it would in theory

00:24:02,650 --> 00:24:08,290
be possible to have for every single of

00:24:06,730 --> 00:24:09,970
these hazards and whatever kind of

00:24:08,290 --> 00:24:11,500
things event you might want to come it

00:24:09,970 --> 00:24:13,809
could have an individual counter

00:24:11,500 --> 00:24:15,580
assigned to them so the logic which you

00:24:13,809 --> 00:24:20,340
need for that it's actually pretty small

00:24:15,580 --> 00:24:23,679
but the thing about them is that just as

00:24:20,340 --> 00:24:26,049
counters these kind of things are not

00:24:23,679 --> 00:24:28,630
really that useful we needed a little

00:24:26,049 --> 00:24:32,140
bit of additional logic to it we need to

00:24:28,630 --> 00:24:37,030
not only measure things but we also want

00:24:32,140 --> 00:24:39,700
to have something where we can react to

00:24:37,030 --> 00:24:41,740
the count of being incremented in a

00:24:39,700 --> 00:24:43,750
general way so we are getting back to

00:24:41,740 --> 00:24:46,510
this kind of thing in a bit but in

00:24:43,750 --> 00:24:49,750
general we want to be able to say when

00:24:46,510 --> 00:24:51,910
you have $4,000 times this event

00:24:49,750 --> 00:24:54,669
happening happening for instance you

00:24:51,910 --> 00:24:56,890
miss the level one cache then let the

00:24:54,669 --> 00:24:59,440
program know that this actually happened

00:24:56,890 --> 00:25:01,990
so we have some logic associated with

00:24:59,440 --> 00:25:05,740
with the counters and this pretty much

00:25:01,990 --> 00:25:07,870
makes it impossible to have 100

00:25:05,740 --> 00:25:09,880
thousands or hundreds or thousands of

00:25:07,870 --> 00:25:12,760
these counters spread all throughout the

00:25:09,880 --> 00:25:14,740
the core implementation and have them

00:25:12,760 --> 00:25:18,309
available in the Sun so what actually

00:25:14,740 --> 00:25:22,660
happened is that pretty much every CPU

00:25:18,309 --> 00:25:24,669
since then provides us per core with a

00:25:22,660 --> 00:25:27,340
certain number of programmable

00:25:24,669 --> 00:25:29,710
performance counters in which you can

00:25:27,340 --> 00:25:32,980
basically say assigned at any point in

00:25:29,710 --> 00:25:35,980
time a specifically specific event - so

00:25:32,980 --> 00:25:36,390
this became much more sophisticated as

00:25:35,980 --> 00:25:38,970
the

00:25:36,390 --> 00:25:42,990
time went by so in the early days we had

00:25:38,970 --> 00:25:45,090
I think two or three on x86 performance

00:25:42,990 --> 00:25:47,520
counters and each of the counters could

00:25:45,090 --> 00:25:49,380
only be assigned events from a certain

00:25:47,520 --> 00:25:51,990
class et cetera so these kind of things

00:25:49,380 --> 00:25:53,940
nowadays we have a lot more so if you

00:25:51,990 --> 00:25:57,030
turn off hyper threading I think we have

00:25:53,940 --> 00:25:59,250
eight counters available per core and

00:25:57,030 --> 00:26:01,770
they can be pretty much really assigned

00:25:59,250 --> 00:26:05,309
any of the events the number of events

00:26:01,770 --> 00:26:07,770
is going in the hundreds now so if you

00:26:05,309 --> 00:26:10,049
want to have for spreadsheet where when

00:26:07,770 --> 00:26:12,750
this is Cali core where all these they

00:26:10,049 --> 00:26:15,240
are listed the list is long it's

00:26:12,750 --> 00:26:17,880
incredibly long for everything they are

00:26:15,240 --> 00:26:20,010
so much choice to actually select

00:26:17,880 --> 00:26:22,080
whatever event you want to count so you

00:26:20,010 --> 00:26:24,179
can assign pretty much any of them to

00:26:22,080 --> 00:26:25,799
arbitrary counters and for each of the

00:26:24,179 --> 00:26:28,679
counters they have an interrupt logic

00:26:25,799 --> 00:26:30,480
where you can say after n of these

00:26:28,679 --> 00:26:33,630
counters and so on as you count a

00:26:30,480 --> 00:26:36,510
hundred events race and interrupt so

00:26:33,630 --> 00:26:37,799
this is all possible so as I mentioned

00:26:36,510 --> 00:26:40,740
at the beginning alpha was at the

00:26:37,799 --> 00:26:43,919
forefront of that and they the engineers

00:26:40,740 --> 00:26:46,620
had that back in the days when they were

00:26:43,919 --> 00:26:48,900
not compact yet they were actually good

00:26:46,620 --> 00:26:51,030
and they wrote a seminal paper about

00:26:48,900 --> 00:26:54,690
statistical profiling which was the

00:26:51,030 --> 00:26:56,640
first one which was able where we

00:26:54,690 --> 00:27:00,030
actually learned how we should throw our

00:26:56,640 --> 00:27:02,760
debug on profile these kind of large

00:27:00,030 --> 00:27:05,190
programs and they use this functionality

00:27:02,760 --> 00:27:11,309
of interrupts from performance

00:27:05,190 --> 00:27:14,160
measurement counters so and the quality

00:27:11,309 --> 00:27:17,429
of implementation of the CPU is really

00:27:14,160 --> 00:27:19,679
determining the number of counters which

00:27:17,429 --> 00:27:23,120
are available for you to use but not

00:27:19,679 --> 00:27:25,620
only that also these if you vendors are

00:27:23,120 --> 00:27:27,690
charging you more the more Congress

00:27:25,620 --> 00:27:30,000
there or the other way around

00:27:27,690 --> 00:27:33,419
they are disabling counters if you don't

00:27:30,000 --> 00:27:37,620
pay them enough so the specific on and

00:27:33,419 --> 00:27:39,990
on X to the six if you're even looking

00:27:37,620 --> 00:27:43,260
at the effective low-end one I ignore

00:27:39,990 --> 00:27:45,799
this even the normal I 5x7 course which

00:27:43,260 --> 00:27:47,989
you can buy nowadays they are tripled

00:27:45,799 --> 00:27:50,269
commentation theoretically they could

00:27:47,989 --> 00:27:53,149
have huge numbers of counters but those

00:27:50,269 --> 00:27:56,450
are reserved for the input the expensive

00:27:53,149 --> 00:27:58,669
one either the I nines or these young

00:27:56,450 --> 00:28:00,169
horse which are basically the same so

00:27:58,669 --> 00:28:01,940
there's only the only difference in

00:28:00,169 --> 00:28:04,999
there is the size of the level 1 and

00:28:01,940 --> 00:28:06,440
level 2 cache and so on the rest is

00:28:04,999 --> 00:28:08,929
pretty much the same for all these kind

00:28:06,440 --> 00:28:12,169
of us except that the expensive ones

00:28:08,929 --> 00:28:13,909
have more counters for you available so

00:28:12,169 --> 00:28:16,129
which means that people like me for

00:28:13,909 --> 00:28:18,679
workstations we have to buy in the

00:28:16,129 --> 00:28:20,539
expensive ones unfortunately so what

00:28:18,679 --> 00:28:23,059
it's also means that if you want to do

00:28:20,539 --> 00:28:26,359
this kind of work on your laptop yeah

00:28:23,059 --> 00:28:28,159
it's hard because you don't have this

00:28:26,359 --> 00:28:30,559
functionality so don't be discouraged if

00:28:28,159 --> 00:28:32,450
you try to do some of these things and

00:28:30,559 --> 00:28:34,009
then do it on laptop on your small

00:28:32,450 --> 00:28:36,549
machine and so and you're not getting

00:28:34,009 --> 00:28:39,739
far that's by design

00:28:36,549 --> 00:28:41,869
- and that's some evil people who want

00:28:39,739 --> 00:28:45,320
to charge your money for that all right

00:28:41,869 --> 00:28:48,080
I said in there finally there's one

00:28:45,320 --> 00:28:50,899
other aspect which is important so I

00:28:48,080 --> 00:28:53,269
showed you the picture of the xb6 or on

00:28:50,899 --> 00:28:56,600
the cortex core and those who are just

00:28:53,269 --> 00:28:58,129
the pictures of the core but parts of

00:28:56,600 --> 00:29:00,169
what the performance which is also

00:28:58,129 --> 00:29:02,720
governing the performance is obviously

00:29:00,169 --> 00:29:04,850
the part which the course are connected

00:29:02,720 --> 00:29:07,190
to the memory they let the last level

00:29:04,850 --> 00:29:11,450
cache these kind of things so we also

00:29:07,190 --> 00:29:16,609
need counters there and that's a problem

00:29:11,450 --> 00:29:19,009
how do you govern the reading of values

00:29:16,609 --> 00:29:21,169
which are not really directly attached

00:29:19,009 --> 00:29:23,509
to your core how do can you do this in a

00:29:21,169 --> 00:29:26,830
fast enough time without delaying things

00:29:23,509 --> 00:29:29,659
where at the same time you might have

00:29:26,830 --> 00:29:31,429
requirements from every single core

00:29:29,659 --> 00:29:33,649
attached to the on core part and they

00:29:31,429 --> 00:29:36,049
want to read out the same values so if

00:29:33,649 --> 00:29:38,210
you know something about electric so

00:29:36,049 --> 00:29:40,100
electronic design you know that reading

00:29:38,210 --> 00:29:43,070
out from the same values actually a

00:29:40,100 --> 00:29:44,210
being from fan out so these kind of

00:29:43,070 --> 00:29:46,300
things are very

00:29:44,210 --> 00:29:48,860
to implement right so you have a certain

00:29:46,300 --> 00:29:51,830
things which I'm the uncle parts which

00:29:48,860 --> 00:29:53,750
need to be available on a kind of a bus

00:29:51,830 --> 00:29:55,160
system which makes it slow blah blah

00:29:53,750 --> 00:29:57,760
blah so all kinds of wrongs I'm not

00:29:55,160 --> 00:30:01,460
going to do details here but in general

00:29:57,760 --> 00:30:05,120
the a good implementation still provides

00:30:01,460 --> 00:30:07,820
you with pretty much the same level of

00:30:05,120 --> 00:30:10,220
information for the uncor parts except

00:30:07,820 --> 00:30:14,060
of course they cannot be done with

00:30:10,220 --> 00:30:16,030
somewhat the same precision especially

00:30:14,060 --> 00:30:21,350
when it comes to the time resolution

00:30:16,030 --> 00:30:23,750
that's the at that time the core single

00:30:21,350 --> 00:30:26,390
core is taking is at a higher resolution

00:30:23,750 --> 00:30:28,280
than what the uncle Pat says and more

00:30:26,390 --> 00:30:31,520
importantly that the clocks might not be

00:30:28,280 --> 00:30:33,470
completely in sync so the attribution of

00:30:31,520 --> 00:30:35,390
events might actually not be exactly

00:30:33,470 --> 00:30:38,660
match any what you have what you're

00:30:35,390 --> 00:30:40,580
seeing so there are therefore two clad

00:30:38,660 --> 00:30:42,950
at least two classes of these kind of

00:30:40,580 --> 00:30:44,750
events we are looking at are the core

00:30:42,950 --> 00:30:48,470
advanced and there are the unholy events

00:30:44,750 --> 00:30:51,800
and yeah we have to treat them carefully

00:30:48,470 --> 00:30:53,900
when they're analyzing them so this

00:30:51,800 --> 00:30:57,830
already mentioned most of the parts are

00:30:53,900 --> 00:31:00,410
very society thing is that the it's not

00:30:57,830 --> 00:31:04,010
just about providing counters it's also

00:31:00,410 --> 00:31:05,870
to do something with them so the one

00:31:04,010 --> 00:31:09,590
thing which I haven't mentioned here is

00:31:05,870 --> 00:31:14,150
that in the over the years we always

00:31:09,590 --> 00:31:16,580
have what is called machine specific or

00:31:14,150 --> 00:31:20,000
our version specific counters pretty

00:31:16,580 --> 00:31:23,870
much everywhere over time we it

00:31:20,000 --> 00:31:26,900
clarified which of the events we pretty

00:31:23,870 --> 00:31:29,060
much always want to count and so some of

00:31:26,900 --> 00:31:32,960
these counters actually we're about as

00:31:29,060 --> 00:31:35,150
part architected again into terminology

00:31:32,960 --> 00:31:37,610
a protector just means that they were

00:31:35,150 --> 00:31:40,370
elevated they were safe from now on

00:31:37,610 --> 00:31:42,560
every single futures if you will have to

00:31:40,370 --> 00:31:44,300
will provide this kind of event as well

00:31:42,560 --> 00:31:46,070
so we don't have to select this and

00:31:44,300 --> 00:31:47,870
therefore they actually dedicate

00:31:46,070 --> 00:31:51,200
specific hardware to these kind of

00:31:47,870 --> 00:31:53,410
events so on the most recent views you

00:31:51,200 --> 00:31:56,260
will find that in addition to the

00:31:53,410 --> 00:31:58,210
damn counters you will also get counters

00:31:56,260 --> 00:32:00,130
for the number of instructions which

00:31:58,210 --> 00:32:03,070
have been executed etc so they are

00:32:00,130 --> 00:32:05,050
always there you don't have to reserve

00:32:03,070 --> 00:32:08,470
some of the precious resources of the

00:32:05,050 --> 00:32:10,210
other PMC's for counting these events

00:32:08,470 --> 00:32:12,130
but this is something which various

00:32:10,210 --> 00:32:14,470
points if you were into the other so

00:32:12,130 --> 00:32:15,910
some older ones don't have that so when

00:32:14,470 --> 00:32:17,950
you're trying to use these kind of

00:32:15,910 --> 00:32:20,710
things at some point if you're trying to

00:32:17,950 --> 00:32:24,220
use for instance six different events

00:32:20,710 --> 00:32:27,580
which easily map to the four PMC's plus

00:32:24,220 --> 00:32:29,080
the because the fixed sights counters

00:32:27,580 --> 00:32:31,770
and so on which you have available on

00:32:29,080 --> 00:32:34,420
any kind of let's say static-x machine

00:32:31,770 --> 00:32:36,280
if you try to do the same thing on an

00:32:34,420 --> 00:32:39,010
ASBO a previous machine you will not

00:32:36,280 --> 00:32:41,650
perhaps to be able to do this because it

00:32:39,010 --> 00:32:43,690
doesn't have that many independent PLC's

00:32:41,650 --> 00:32:45,430
available for you to count so these kind

00:32:43,690 --> 00:32:47,440
of things you have to keep in mind there

00:32:45,430 --> 00:32:49,840
will always be differences and the

00:32:47,440 --> 00:32:52,210
difference will be even larger if you're

00:32:49,840 --> 00:32:54,970
trying to do the same time knowledge and

00:32:52,210 --> 00:32:57,190
not just for it for having exodus six on

00:32:54,970 --> 00:32:58,930
in child but also exorcistic son AMD

00:32:57,190 --> 00:33:01,090
which will have completely different set

00:32:58,930 --> 00:33:02,710
so they honor that for implementation is

00:33:01,090 --> 00:33:04,870
different so it also the counters will

00:33:02,710 --> 00:33:07,000
be different and even more promise you

00:33:04,870 --> 00:33:09,490
will have if you're trying to do the

00:33:07,000 --> 00:33:11,110
same thing on the architectures like for

00:33:09,490 --> 00:33:13,000
instance the ARM architecture if you try

00:33:11,110 --> 00:33:16,120
to use the same at the same kind of

00:33:13,000 --> 00:33:17,980
technology so it's possible you just

00:33:16,120 --> 00:33:20,110
have to be a little bit more careful and

00:33:17,980 --> 00:33:22,000
your programs which are doing this have

00:33:20,110 --> 00:33:24,850
to be aware of these limitations of work

00:33:22,000 --> 00:33:28,470
about them good news is that the tools

00:33:24,850 --> 00:33:33,580
we have available nowadays can do this

00:33:28,470 --> 00:33:35,710
so what if you want to see monitor many

00:33:33,580 --> 00:33:37,780
of these events and the number of

00:33:35,710 --> 00:33:42,250
counters which you have available is too

00:33:37,780 --> 00:33:43,930
small well we can still use that but we

00:33:42,250 --> 00:33:48,490
use the same trick we used everywhere

00:33:43,930 --> 00:33:51,280
time multiplexing and if you are not

00:33:48,490 --> 00:33:53,440
aware of the limitations of the number

00:33:51,280 --> 00:33:57,700
of counters which you have the tools

00:33:53,440 --> 00:34:00,700
usually will silently move you into this

00:33:57,700 --> 00:34:03,190
mode in their time multiplexing but the

00:34:00,700 --> 00:34:04,810
recess of course results because what

00:34:03,190 --> 00:34:06,320
they are doing basically is and here's

00:34:04,810 --> 00:34:09,030
an example of so

00:34:06,320 --> 00:34:10,919
you're dividing up your program

00:34:09,030 --> 00:34:14,339
execution in intervals of certain

00:34:10,919 --> 00:34:16,950
lengths towel in this case and every

00:34:14,339 --> 00:34:19,200
towel whatever time this is after the

00:34:16,950 --> 00:34:21,540
duration and so on you're switching to a

00:34:19,200 --> 00:34:24,149
different set of events which are

00:34:21,540 --> 00:34:26,190
counting perhaps in your PMC's and the

00:34:24,149 --> 00:34:27,869
result might be that it looks like this

00:34:26,190 --> 00:34:29,760
if you have four counters available

00:34:27,869 --> 00:34:31,980
certain events are swapped in swapped

00:34:29,760 --> 00:34:35,869
out in the end you have some left over

00:34:31,980 --> 00:34:38,310
interval and the good program which

00:34:35,869 --> 00:34:40,290
which allows you to monitor these kind

00:34:38,310 --> 00:34:42,810
of events will actually tell you yeah I

00:34:40,290 --> 00:34:45,270
have gone through was it eight event

00:34:42,810 --> 00:34:49,349
cycles and then point eight of the last

00:34:45,270 --> 00:34:51,960
event cycle and here are the counts for

00:34:49,349 --> 00:34:54,510
all of these in events in all of these

00:34:51,960 --> 00:34:56,790
specific intervals so all of the

00:34:54,510 --> 00:35:00,359
information which is see here being in

00:34:56,790 --> 00:35:02,130
could be accessible when it comes to the

00:35:00,359 --> 00:35:04,440
termination of program and for us to

00:35:02,130 --> 00:35:07,890
actually analyze code so the result is

00:35:04,440 --> 00:35:10,140
that we can create a table like on the

00:35:07,890 --> 00:35:13,020
right hand side more correctly we can

00:35:10,140 --> 00:35:14,640
look at the first three columns first

00:35:13,020 --> 00:35:18,150
one of course being the name that we can

00:35:14,640 --> 00:35:21,599
reconstruct the total count and the

00:35:18,150 --> 00:35:24,119
total time the individual event was

00:35:21,599 --> 00:35:26,910
being counted we can reconstruct us from

00:35:24,119 --> 00:35:29,190
the data the performance analysis tools

00:35:26,910 --> 00:35:31,890
are providing us with but now comes the

00:35:29,190 --> 00:35:35,220
important points if you're not aware of

00:35:31,890 --> 00:35:37,109
this or if you deliberately are using

00:35:35,220 --> 00:35:41,400
more events than they are counters

00:35:37,109 --> 00:35:43,200
available interpolation happens so we

00:35:41,400 --> 00:35:46,470
know that the total program execution

00:35:43,200 --> 00:35:50,280
time is eight point eight and any

00:35:46,470 --> 00:35:53,160
measure we want to print printout has to

00:35:50,280 --> 00:35:55,920
be based on the same time basis the only

00:35:53,160 --> 00:35:58,010
time basis which makes sense is the full

00:35:55,920 --> 00:36:00,450
length of the program and therefore

00:35:58,010 --> 00:36:04,050
events which are not counted for the

00:36:00,450 --> 00:36:06,330
entire duration of the program run will

00:36:04,050 --> 00:36:08,670
be multiplied appropriately in the

00:36:06,330 --> 00:36:11,960
account and therefore they are have a

00:36:08,670 --> 00:36:15,030
much lower precision than the other ones

00:36:11,960 --> 00:36:17,550
specifically if your program is not

00:36:15,030 --> 00:36:18,930
homogeneous over the execution time

00:36:17,550 --> 00:36:20,970
if you have as I mentioned at the

00:36:18,930 --> 00:36:22,860
beginning you have some startup phase

00:36:20,970 --> 00:36:24,840
than you have might have some compute

00:36:22,860 --> 00:36:28,830
phase and perhaps to confuse computers

00:36:24,840 --> 00:36:31,920
by itself is varying over time if your

00:36:28,830 --> 00:36:35,100
event were scheduled in times of refined

00:36:31,920 --> 00:36:36,780
sense low arithmetic activity but you're

00:36:35,100 --> 00:36:39,450
counting an arithmetic event

00:36:36,780 --> 00:36:41,190
well the interpolation which you're

00:36:39,450 --> 00:36:44,040
getting out of this in the end will be

00:36:41,190 --> 00:36:46,200
completely off on the other hand you can

00:36:44,040 --> 00:36:48,990
have exactly the same opposite effect

00:36:46,200 --> 00:36:50,760
you're only counting arithmetic events

00:36:48,990 --> 00:36:52,650
in the short period of times when you're

00:36:50,760 --> 00:36:55,260
doing energy arithmetic in the program

00:36:52,650 --> 00:36:57,690
and you're always debating this from the

00:36:55,260 --> 00:37:00,270
counters themselves and from the

00:36:57,690 --> 00:37:02,340
programs there is no way that you can

00:37:00,270 --> 00:37:04,800
get this kind of information out of this

00:37:02,340 --> 00:37:06,510
and that's what you can do is you can

00:37:04,800 --> 00:37:08,340
run it multiple times and hope that

00:37:06,510 --> 00:37:10,620
that's enough randomization there that

00:37:08,340 --> 00:37:12,570
the events are not coinciding at the

00:37:10,620 --> 00:37:15,090
same time with the same kind of parts of

00:37:12,570 --> 00:37:17,700
the program execution et cetera but much

00:37:15,090 --> 00:37:21,090
better it would be and if your program

00:37:17,700 --> 00:37:24,210
is actually repeatable so it's reliably

00:37:21,090 --> 00:37:27,050
repeatable would it it would be to not

00:37:24,210 --> 00:37:30,300
rely on time artifacts in but instead

00:37:27,050 --> 00:37:33,720
use multiple runs of the same programs

00:37:30,300 --> 00:37:36,150
with different set of event counters but

00:37:33,720 --> 00:37:39,630
again this is not something the tools

00:37:36,150 --> 00:37:41,640
like perf will tell you at this point

00:37:39,630 --> 00:37:44,940
they they will just say well yeah here

00:37:41,640 --> 00:37:47,100
here's the result be happy with it you

00:37:44,940 --> 00:37:52,260
have to be actually looking actively for

00:37:47,100 --> 00:37:54,780
that same that was a lot of complexity

00:37:52,260 --> 00:37:57,480
already but it's getting worse to some

00:37:54,780 --> 00:37:59,160
extent because you know how do we

00:37:57,480 --> 00:38:07,110
actually use this so if we want to use

00:37:59,160 --> 00:38:10,620
this kind of tools by themselves and so

00:38:07,110 --> 00:38:12,390
if we are measuring the numbers which

00:38:10,620 --> 00:38:14,550
are getting out of the counters how does

00:38:12,390 --> 00:38:19,170
obviously are providing us with absolute

00:38:14,550 --> 00:38:22,140
values so if the program is executing

00:38:19,170 --> 00:38:24,900
four billion CPU cycles and it does 1

00:38:22,140 --> 00:38:26,420
million memory writes so this is an is

00:38:24,900 --> 00:38:28,670
an output which

00:38:26,420 --> 00:38:33,070
performance analysis tool can give us

00:38:28,670 --> 00:38:33,070
about a program is this good or bad

00:38:33,280 --> 00:38:39,320
it doesn't matter so you can repeat it I

00:38:37,250 --> 00:38:43,040
can say have repeated many times and

00:38:39,320 --> 00:38:45,140
perhaps it's plus minus a tenth of a

00:38:43,040 --> 00:38:46,640
percent so it doesn't matter in this

00:38:45,140 --> 00:38:51,920
case the question is not about the

00:38:46,640 --> 00:38:53,300
variance so is this good or bad yeah no

00:38:51,920 --> 00:38:54,980
so what in this case it doesn't really

00:38:53,300 --> 00:38:58,580
matter so they of course the point here

00:38:54,980 --> 00:39:00,650
is not how reliable is the data but if

00:38:58,580 --> 00:39:02,540
this is a program which computes the

00:39:00,650 --> 00:39:04,190
state of the universe at this point in

00:39:02,540 --> 00:39:06,560
time I would say it's a fantastic

00:39:04,190 --> 00:39:08,300
program if it's a program which computes

00:39:06,560 --> 00:39:12,500
the time of day I would say it's a lousy

00:39:08,300 --> 00:39:15,220
program this is not enough information

00:39:12,500 --> 00:39:18,770
for us to say it's a good program or not

00:39:15,220 --> 00:39:21,560
regardless of what the variances we have

00:39:18,770 --> 00:39:24,610
to look at every single of the values of

00:39:21,560 --> 00:39:29,840
a performance counters in a context and

00:39:24,610 --> 00:39:34,150
the most reliable way to do this is to

00:39:29,840 --> 00:39:37,100
actually look at ratios so a

00:39:34,150 --> 00:39:41,150
long-running program obviously will take

00:39:37,100 --> 00:39:44,720
half more cycles but perhaps it's

00:39:41,150 --> 00:39:46,610
actually an expected result if a program

00:39:44,720 --> 00:39:48,190
does more computation obviously it runs

00:39:46,610 --> 00:39:52,010
longer

00:39:48,190 --> 00:39:54,710
so therefore getting a ratio was

00:39:52,010 --> 00:39:56,450
basically SAS so we're going back to the

00:39:54,710 --> 00:39:58,600
numbers on the previous slide how many

00:39:56,450 --> 00:40:02,150
memory operations we are doing per cycle

00:39:58,600 --> 00:40:04,970
that's a more reasonable value to look

00:40:02,150 --> 00:40:07,340
at and there we can potentially argue

00:40:04,970 --> 00:40:10,280
then saying that this is a reasonable

00:40:07,340 --> 00:40:13,160
it's a good value it's a bad value so

00:40:10,280 --> 00:40:15,740
ratios are the foundation of performance

00:40:13,160 --> 00:40:17,810
analysis when it comes to these then so

00:40:15,740 --> 00:40:20,960
at the top level to actually make

00:40:17,810 --> 00:40:23,720
judgment calls when it comes later on to

00:40:20,960 --> 00:40:25,820
the actual process of optimizing your

00:40:23,720 --> 00:40:29,330
program where we want to see whether a

00:40:25,820 --> 00:40:31,700
certain change makes a an advance in our

00:40:29,330 --> 00:40:33,610
program so it improves the program

00:40:31,700 --> 00:40:36,160
perhaps then absolute values

00:40:33,610 --> 00:40:38,140
certainly we'll make make it come back

00:40:36,160 --> 00:40:42,490
because then we could say for the same

00:40:38,140 --> 00:40:45,460
input the program now the producers who

00:40:42,490 --> 00:40:47,500
are requires now 10% less cycles that's

00:40:45,460 --> 00:40:50,290
an absolute judgment call it's

00:40:47,500 --> 00:40:52,720
definitely possible but for a general

00:40:50,290 --> 00:40:55,870
analysis of the performance of a program

00:40:52,720 --> 00:41:00,160
absolute values are useless pretty much

00:40:55,870 --> 00:41:02,740
and we need to rely on ratios so ratios

00:41:00,160 --> 00:41:05,290
are everywhere I mentioned already a

00:41:02,740 --> 00:41:07,120
couple of them so it's a CPI Li PC there

00:41:05,290 --> 00:41:10,750
they have reverse of each other cycles

00:41:07,120 --> 00:41:15,990
per instruction so having a CPI value

00:41:10,750 --> 00:41:18,520
which is even 10.5 or higher indicates

00:41:15,990 --> 00:41:20,560
usually four into the CPU that's

00:41:18,520 --> 00:41:23,440
something it's wrong so fun X to the 6

00:41:20,560 --> 00:41:25,510
EP you for an arms of you I would argue

00:41:23,440 --> 00:41:28,630
that probably that's not actually that

00:41:25,510 --> 00:41:30,280
much of a problem in many situations so

00:41:28,630 --> 00:41:32,290
especially for if they have an order

00:41:30,280 --> 00:41:34,150
execution course then you don't have

00:41:32,290 --> 00:41:36,820
this kind of thing so the even the

00:41:34,150 --> 00:41:41,940
ratios have to be looked at in the

00:41:36,820 --> 00:41:45,580
context but if you are looking at an

00:41:41,940 --> 00:41:48,130
environment and hormones and homogeneous

00:41:45,580 --> 00:41:50,560
environment for instance Nexus 6 server

00:41:48,130 --> 00:41:53,740
application of who have a program that's

00:41:50,560 --> 00:41:56,430
certain amount of work comparing the

00:41:53,740 --> 00:41:59,800
ratios is actually very reasonable thing

00:41:56,430 --> 00:42:01,770
but here again think back to the problem

00:41:59,800 --> 00:42:04,540
which I mentioned with time multiplexing

00:42:01,770 --> 00:42:07,150
so because you're dividing one by the

00:42:04,540 --> 00:42:10,720
other and if one of them is small etc

00:42:07,150 --> 00:42:13,680
etc the variants you will get out of the

00:42:10,720 --> 00:42:16,750
time multiplexing numbers can completely

00:42:13,680 --> 00:42:21,460
make the outcoming

00:42:16,750 --> 00:42:23,800
ratios useless so you also have to be

00:42:21,460 --> 00:42:27,100
very very careful when you're doing this

00:42:23,800 --> 00:42:29,260
kind of thing so ratios which as I said

00:42:27,100 --> 00:42:31,570
CPI is one of them another one which

00:42:29,260 --> 00:42:33,390
definitely makes sense is number of

00:42:31,570 --> 00:42:36,290
cache misses per hour

00:42:33,390 --> 00:42:37,980
the operation or memory you operation

00:42:36,290 --> 00:42:39,660
things like that

00:42:37,980 --> 00:42:41,330
which are common sense when you're

00:42:39,660 --> 00:42:44,820
thinking about what your program does

00:42:41,330 --> 00:42:46,650
they all are going to be making the

00:42:44,820 --> 00:42:48,540
appearance when you're doing the

00:42:46,650 --> 00:42:50,790
performance analysis of your program

00:42:48,540 --> 00:42:52,350
when our the other ones which are worth

00:42:50,790 --> 00:42:54,690
mentioning at this point is the

00:42:52,350 --> 00:42:57,090
probability of a branch mints branch

00:42:54,690 --> 00:42:59,040
misses creating bubbles in the CPU which

00:42:57,090 --> 00:43:02,880
are one of the worst offenders when it

00:42:59,040 --> 00:43:05,510
comes to to actually creating battery

00:43:02,880 --> 00:43:08,430
performance programs so if you have a

00:43:05,510 --> 00:43:11,460
probability of branch misprediction of

00:43:08,430 --> 00:43:13,650
let's say even 20% your program sucks

00:43:11,460 --> 00:43:17,280
and the program and the performance as

00:43:13,650 --> 00:43:22,560
well so things like that are easy

00:43:17,280 --> 00:43:24,330
targets for one to try to measure just

00:43:22,560 --> 00:43:26,430
without even looking at the inner

00:43:24,330 --> 00:43:28,890
details of a program getting these kind

00:43:26,430 --> 00:43:32,400
of top-level measurements is actually

00:43:28,890 --> 00:43:34,890
very useful so going back to the prompt

00:43:32,400 --> 00:43:37,620
are similar from example which got

00:43:34,890 --> 00:43:40,260
before so you have two counters you're

00:43:37,620 --> 00:43:42,990
measuring them so but how do you now

00:43:40,260 --> 00:43:44,580
compute these various ratios so for

00:43:42,990 --> 00:43:48,180
instance how do you compute the CPI

00:43:44,580 --> 00:43:50,280
value do you take for instance the cycle

00:43:48,180 --> 00:43:52,170
and the number of retired instructions

00:43:50,280 --> 00:43:54,510
from the first interval do you bite them

00:43:52,170 --> 00:43:57,990
and produce perhaps in this case five

00:43:54,510 --> 00:44:00,660
different values that's useful you would

00:43:57,990 --> 00:44:04,980
know how the program is evolving over

00:44:00,660 --> 00:44:07,710
time but perhaps this is not always the

00:44:04,980 --> 00:44:10,190
the data is not always available not so

00:44:07,710 --> 00:44:14,040
it will fluctuate quite dramatically

00:44:10,190 --> 00:44:17,760
so perhaps you want to instead sum up

00:44:14,040 --> 00:44:20,490
the values but here's you see that we

00:44:17,760 --> 00:44:23,160
are counting the number of cycles every

00:44:20,490 --> 00:44:25,610
single time every single time interval

00:44:23,160 --> 00:44:28,140
but we are counting the number of

00:44:25,610 --> 00:44:30,450
instructions only ones because we have a

00:44:28,140 --> 00:44:34,410
limited number of counters how do you

00:44:30,450 --> 00:44:36,390
compute it then do you average out the

00:44:34,410 --> 00:44:41,640
number of cycles per interval divided by

00:44:36,390 --> 00:44:43,320
66 so if you're any kind of scientist at

00:44:41,640 --> 00:44:45,029
this point it will say you will try to

00:44:43,320 --> 00:44:48,599
associate the

00:44:45,029 --> 00:44:51,059
time intervals worth units and he would

00:44:48,599 --> 00:44:53,819
say oh no doesn't work because you're

00:44:51,059 --> 00:44:57,390
putting in the same equations completely

00:44:53,819 --> 00:45:01,199
unrelated values the 66 for instance has

00:44:57,390 --> 00:45:04,409
nothing to do with the 95 psych around

00:45:01,199 --> 00:45:06,959
after second time interval it just

00:45:04,409 --> 00:45:09,209
happens to be that if we would have

00:45:06,959 --> 00:45:11,219
measured through it number of we type

00:45:09,209 --> 00:45:12,599
instruction that time interval we might

00:45:11,219 --> 00:45:14,519
have gotten a number in this

00:45:12,599 --> 00:45:16,890
neighborhood as well but this has

00:45:14,519 --> 00:45:19,769
absolutely no foundation in you

00:45:16,890 --> 00:45:21,929
believing this is the case still if you

00:45:19,769 --> 00:45:23,880
have few resources available for you to

00:45:21,929 --> 00:45:25,559
actually measure these things this might

00:45:23,880 --> 00:45:27,989
be the best hope you can get it but it

00:45:25,559 --> 00:45:31,799
means that you have to be aware of the

00:45:27,989 --> 00:45:33,449
fact that this number is noisy an option

00:45:31,799 --> 00:45:35,489
absolute number and often times you will

00:45:33,449 --> 00:45:37,380
see them programs of course quoting out

00:45:35,489 --> 00:45:40,849
the numbers with seven digits after the

00:45:37,380 --> 00:45:44,609
digit decimal point so it's it's it's

00:45:40,849 --> 00:45:48,349
stupid but this also means that simply

00:45:44,609 --> 00:45:51,179
prone people are not thinking about it

00:45:48,349 --> 00:45:53,400
so far the miss prediction here in this

00:45:51,179 --> 00:45:56,069
case we have values always measuring at

00:45:53,400 --> 00:46:00,419
the same time but which of them are you

00:45:56,069 --> 00:46:02,509
looking at so do you always look at the

00:46:00,419 --> 00:46:05,130
the sums when they are available or not

00:46:02,509 --> 00:46:08,009
because in some situations you might

00:46:05,130 --> 00:46:11,959
actually want to know why how a specific

00:46:08,009 --> 00:46:16,380
part of the program is behaving so it's

00:46:11,959 --> 00:46:18,239
becoming very quickly very much a big

00:46:16,380 --> 00:46:22,739
data problem I like this for this

00:46:18,239 --> 00:46:25,049
keyword here because we can measure huge

00:46:22,739 --> 00:46:29,640
numbers of values and all of a sudden

00:46:25,049 --> 00:46:32,459
you have the ability well at least you

00:46:29,640 --> 00:46:34,769
have the possibility to do all kinds of

00:46:32,459 --> 00:46:37,169
computations on that and the possibility

00:46:34,769 --> 00:46:39,449
in that you're doing something stupid if

00:46:37,169 --> 00:46:46,450
you don't know how are the CPU works is

00:46:39,449 --> 00:46:49,400
really really high all right so the

00:46:46,450 --> 00:46:51,320
important thing is that it's the you

00:46:49,400 --> 00:46:53,240
need to do adjustment for instance for

00:46:51,320 --> 00:46:55,430
situations when your program is not run

00:46:53,240 --> 00:46:57,230
doing counting certain events but if

00:46:55,430 --> 00:46:59,300
you're doing this you are introducing

00:46:57,230 --> 00:47:01,130
possible errors and you have to keep

00:46:59,300 --> 00:47:06,530
them in mind when you're doing all kinds

00:47:01,130 --> 00:47:08,120
of analysis based on that so how to talk

00:47:06,530 --> 00:47:10,220
to you about all these kind of nice

00:47:08,120 --> 00:47:13,310
things and whether we can use them and

00:47:10,220 --> 00:47:17,960
also bad things to not use them so how

00:47:13,310 --> 00:47:19,670
do would we actually use them so the

00:47:17,960 --> 00:47:22,550
step which I mentioned before these

00:47:19,670 --> 00:47:25,400
ratios for an entire program are useful

00:47:22,550 --> 00:47:26,780
to get an overview but after that we

00:47:25,400 --> 00:47:30,140
actually want to learn something more

00:47:26,780 --> 00:47:32,690
about the program as it proceeds because

00:47:30,140 --> 00:47:38,020
just getting an overview and saying all

00:47:32,690 --> 00:47:42,440
your program runs with a CPI of five

00:47:38,020 --> 00:47:44,180
which is bad so just saying that about

00:47:42,440 --> 00:47:46,790
the program is not enough you actually

00:47:44,180 --> 00:47:49,310
need to be able to say well where in my

00:47:46,790 --> 00:47:51,470
program it am I actually wasting that

00:47:49,310 --> 00:47:53,360
much time and for that you have a couple

00:47:51,470 --> 00:47:58,090
of different possibilities at the very

00:47:53,360 --> 00:48:00,230
least you can go and actually analyze

00:47:58,090 --> 00:48:02,930
explicitly certain parts of a program

00:48:00,230 --> 00:48:07,100
and measure how they are behaving there

00:48:02,930 --> 00:48:09,530
etc so this is very much possible but

00:48:07,100 --> 00:48:12,350
it's also time consuming because that's

00:48:09,530 --> 00:48:14,450
not an easy way to inject the

00:48:12,350 --> 00:48:16,490
measurement code in your program code

00:48:14,450 --> 00:48:18,650
perhaps in the binary or in the source

00:48:16,490 --> 00:48:20,210
code to get this for all kinds of

00:48:18,650 --> 00:48:21,620
combinations of function quality

00:48:20,210 --> 00:48:24,440
sessions such as these kind of things

00:48:21,620 --> 00:48:26,630
the easier way and this is back to the

00:48:24,440 --> 00:48:29,870
seminal paper from Jack back in the days

00:48:26,630 --> 00:48:31,160
they introduced statistical profiling as

00:48:29,870 --> 00:48:33,440
something which doesn't require

00:48:31,160 --> 00:48:36,020
modification of the binary and where it

00:48:33,440 --> 00:48:38,150
can still learn from the outside without

00:48:36,020 --> 00:48:40,610
doing anything to the binary or the

00:48:38,150 --> 00:48:43,520
source code about the program as it

00:48:40,610 --> 00:48:46,610
behaves over time but with the limited

00:48:43,520 --> 00:48:50,000
precision so both of these methods are

00:48:46,610 --> 00:48:51,860
useful and should be applied but and

00:48:50,000 --> 00:48:53,119
none of them are really providing us

00:48:51,860 --> 00:48:57,319
with one different

00:48:53,119 --> 00:48:59,720
the answer so for instance here have

00:48:57,319 --> 00:49:01,910
another nice little example I don't know

00:48:59,720 --> 00:49:03,559
but it's nice but going back to the

00:49:01,910 --> 00:49:07,059
count which we have seen before

00:49:03,559 --> 00:49:10,039
so we could use these measurements and

00:49:07,059 --> 00:49:12,230
not just as a single value as we have

00:49:10,039 --> 00:49:15,109
you seen it before but we could do it

00:49:12,230 --> 00:49:18,230
something like that where we have we

00:49:15,109 --> 00:49:19,720
compute the two values the CPI seconds

00:49:18,230 --> 00:49:21,920
for instruction and the branch

00:49:19,720 --> 00:49:26,960
mispredictions with predictions over

00:49:21,920 --> 00:49:30,410
time so in this case here we have the

00:49:26,960 --> 00:49:32,539
the red lines indicating CPI and the

00:49:30,410 --> 00:49:35,329
green lines are indicating different am

00:49:32,539 --> 00:49:37,789
the miss predictions and began a picture

00:49:35,329 --> 00:49:40,430
which looks like this but it means that

00:49:37,789 --> 00:49:42,859
for many parts of the program one ratio

00:49:40,430 --> 00:49:44,779
or the other is not not present let's

00:49:42,859 --> 00:49:47,720
again back to the time multiplexing

00:49:44,779 --> 00:49:49,579
problem so we have to either live for

00:49:47,720 --> 00:49:52,490
this or we can work around this in many

00:49:49,579 --> 00:49:54,920
situations so we can also try to do

00:49:52,490 --> 00:49:57,380
something else but in general what you

00:49:54,920 --> 00:50:01,489
get out of this is just these these

00:49:57,380 --> 00:50:03,859
numbers it says just based on the time

00:50:01,489 --> 00:50:06,829
the program is executing here are the

00:50:03,859 --> 00:50:09,589
points at which the ratio is this note

00:50:06,829 --> 00:50:11,900
there is something missing which is the

00:50:09,589 --> 00:50:14,359
reference back from these time periods

00:50:11,900 --> 00:50:17,900
inside the code or inside the floor

00:50:14,359 --> 00:50:20,509
program code itself this is not provided

00:50:17,900 --> 00:50:24,230
by just observing these values you need

00:50:20,509 --> 00:50:26,059
something else so as I said before there

00:50:24,230 --> 00:50:28,160
are these two ways the first one is

00:50:26,059 --> 00:50:31,009
obviously we can use explicit counting

00:50:28,160 --> 00:50:33,589
there are interfaces available where

00:50:31,009 --> 00:50:36,230
ordinary user level programs can access

00:50:33,589 --> 00:50:38,390
these kind of powders the interface

00:50:36,230 --> 00:50:41,779
which I've been using for ever for very

00:50:38,390 --> 00:50:43,549
long times called poppy P IPI and it

00:50:41,779 --> 00:50:46,519
allows you to create the event sets and

00:50:43,549 --> 00:50:48,440
so on it then just say poppy read and it

00:50:46,519 --> 00:50:51,440
reads out the state of certain

00:50:48,440 --> 00:50:53,900
characters period very simple these come

00:50:51,440 --> 00:50:56,930
out come 64-bit values which we can

00:50:53,900 --> 00:50:58,460
store somewhere and subsequent parts of

00:50:56,930 --> 00:51:00,320
this will

00:50:58,460 --> 00:51:02,330
we'll return different absolute values

00:51:00,320 --> 00:51:04,099
and the difference of them obviously is

00:51:02,330 --> 00:51:06,710
the time span for a number of events

00:51:04,099 --> 00:51:09,140
between two different counts so this is

00:51:06,710 --> 00:51:11,480
easily doable but instead you would have

00:51:09,140 --> 00:51:14,450
to integrate this kind of code in every

00:51:11,480 --> 00:51:18,260
single function of interest inside your

00:51:14,450 --> 00:51:20,839
program it's something which I

00:51:18,260 --> 00:51:23,240
personally do when it comes down to

00:51:20,839 --> 00:51:25,640
measuring the effects of a certain

00:51:23,240 --> 00:51:27,830
change because then the absolute values

00:51:25,640 --> 00:51:31,099
are definitely useful I can use it also

00:51:27,830 --> 00:51:33,050
to compute ratios obviously but it's

00:51:31,099 --> 00:51:36,020
usually too much time to try to cover

00:51:33,050 --> 00:51:38,650
the entire program with that so the

00:51:36,020 --> 00:51:42,380
other one is as I mentioned before

00:51:38,650 --> 00:51:45,109
statistical analysis and the picture

00:51:42,380 --> 00:51:48,010
which you see here is very similar to

00:51:45,109 --> 00:51:50,420
what you have seen before these these

00:51:48,010 --> 00:51:52,070
whatever I tried to show you there where

00:51:50,420 --> 00:51:53,690
are certain events are counted at any

00:51:52,070 --> 00:51:56,869
point in time and so on we are counting

00:51:53,690 --> 00:52:00,170
the absolute values now the difference

00:51:56,869 --> 00:52:03,589
here is that instead of just counting

00:52:00,170 --> 00:52:06,830
the events we are asking the processor

00:52:03,589 --> 00:52:10,089
to to say that every single time the

00:52:06,830 --> 00:52:13,730
event 1 has been seen five times

00:52:10,089 --> 00:52:16,700
give me a notification and similarly for

00:52:13,730 --> 00:52:19,790
event - every single time it was called

00:52:16,700 --> 00:52:22,099
which was was increment at 10 times so

00:52:19,790 --> 00:52:23,810
this is why you see at the top there if

00:52:22,099 --> 00:52:27,560
you level part the program being

00:52:23,810 --> 00:52:29,780
executed and after hit event 1 5 times

00:52:27,560 --> 00:52:32,839
immediate raishin interrupts some color

00:52:29,780 --> 00:52:35,750
code get executed which not only does

00:52:32,839 --> 00:52:38,060
the counting of this event but also

00:52:35,750 --> 00:52:40,490
because it's an interrupt it can

00:52:38,060 --> 00:52:42,800
actually query where the program was

00:52:40,490 --> 00:52:45,830
interrupted and if you can remember this

00:52:42,800 --> 00:52:47,599
information and with modern CPUs there's

00:52:45,830 --> 00:52:49,250
so much additional information which we

00:52:47,599 --> 00:52:53,450
can collect because there's something

00:52:49,250 --> 00:52:56,119
like OTL be our last branch must branch

00:52:53,450 --> 00:52:58,099
Mazak registers and so on we are

00:52:56,119 --> 00:53:00,170
basically we can know where the program

00:52:58,099 --> 00:53:02,570
was before so this kind of information

00:53:00,170 --> 00:53:05,300
can be recorded and then a program is

00:53:02,570 --> 00:53:08,900
resumed so the counter gets reset

00:53:05,300 --> 00:53:11,029
basically if it again here just 5 it

00:53:08,900 --> 00:53:13,549
welcome to interrupts in the same same

00:53:11,029 --> 00:53:17,480
thing happened for the second one the

00:53:13,549 --> 00:53:20,029
result is that we are collecting through

00:53:17,480 --> 00:53:22,039
these interrupts not just vanity

00:53:20,029 --> 00:53:24,950
information about the total number of

00:53:22,039 --> 00:53:27,259
the events which have happened but also

00:53:24,950 --> 00:53:30,829
getting statistical information about

00:53:27,259 --> 00:53:33,769
where the events happen and by the way

00:53:30,829 --> 00:53:35,660
limits - tender unrealistic yeah an

00:53:33,769 --> 00:53:37,700
enormous if you were counting them in

00:53:35,660 --> 00:53:39,499
multiples of two thousand four thousand

00:53:37,700 --> 00:53:43,279
something like that because these events

00:53:39,499 --> 00:53:46,130
happen so frequently but this means that

00:53:43,279 --> 00:53:48,259
we get information about the locality

00:53:46,130 --> 00:53:50,720
the program we're inside the program

00:53:48,259 --> 00:53:54,529
certain operations are predominant and

00:53:50,720 --> 00:53:56,839
by measuring different events over the

00:53:54,529 --> 00:53:59,210
same program execution in different runs

00:53:56,839 --> 00:54:01,009
we know for instance where I see a

00:53:59,210 --> 00:54:02,660
memory heavy stuff where's arithmetic

00:54:01,009 --> 00:54:04,670
heavy stuff and sound we can map this

00:54:02,660 --> 00:54:06,109
through a source code or first of all to

00:54:04,670 --> 00:54:10,099
the binary quadrant and hood to the

00:54:06,109 --> 00:54:11,900
source code and the this sounds good

00:54:10,099 --> 00:54:13,579
this sounds almost too good but we have

00:54:11,900 --> 00:54:15,920
to be aware of the fact that the

00:54:13,579 --> 00:54:16,369
resulting information is really coarse

00:54:15,920 --> 00:54:19,549
grained

00:54:16,369 --> 00:54:22,489
it's statistical because we only get

00:54:19,549 --> 00:54:25,009
interrupted every in this case five or

00:54:22,489 --> 00:54:28,190
ten times in reality 2,000 or 4,000

00:54:25,009 --> 00:54:31,339
times the event happened so if we have a

00:54:28,190 --> 00:54:33,230
piece of code which by accident is where

00:54:31,339 --> 00:54:35,690
an arithmetic for instance instructions

00:54:33,230 --> 00:54:38,569
to execute exactly every 2000 site has

00:54:35,690 --> 00:54:40,460
2000 times and the rest of them are

00:54:38,569 --> 00:54:42,049
doing rest of your thematic instruction

00:54:40,460 --> 00:54:45,970
happen something completely differently

00:54:42,049 --> 00:54:49,279
we can see completely different results

00:54:45,970 --> 00:54:51,559
this is statistics and we have to be

00:54:49,279 --> 00:54:54,739
aware of this one we also have to apply

00:54:51,559 --> 00:54:56,960
many of the statistical analysis

00:54:54,739 --> 00:55:00,140
techniques to the data unfortunately

00:54:56,960 --> 00:55:01,430
still isn't done because well you

00:55:00,140 --> 00:55:06,950
actually have to know statistics for

00:55:01,430 --> 00:55:09,859
that so the accuracy is limited by that

00:55:06,950 --> 00:55:12,890
the actor is also limited by the fact

00:55:09,859 --> 00:55:16,579
that we have out of order execution

00:55:12,890 --> 00:55:19,430
course so if you have up to a hundred

00:55:16,579 --> 00:55:20,260
instructions to be executed at any point

00:55:19,430 --> 00:55:22,380
in time

00:55:20,260 --> 00:55:25,660
and you have an interrupt being raised

00:55:22,380 --> 00:55:29,530
it's actually not that easy and you can

00:55:25,660 --> 00:55:32,860
imagine why to who - to actually fall a

00:55:29,530 --> 00:55:34,900
specific instruction for the the event

00:55:32,860 --> 00:55:36,880
how do they actually find out one of

00:55:34,900 --> 00:55:38,560
these onerous instructions which is

00:55:36,880 --> 00:55:41,050
exactly the one which is has been

00:55:38,560 --> 00:55:43,390
causing this event so this has been

00:55:41,050 --> 00:55:46,090
solved in some it something like this

00:55:43,390 --> 00:55:48,280
iterations after CPUs but there's a lot

00:55:46,090 --> 00:55:50,860
of effort went into this so in turn

00:55:48,280 --> 00:55:53,770
introduce what is called PPS precise an

00:55:50,860 --> 00:55:56,500
event based sampling I think about ten

00:55:53,770 --> 00:56:00,340
years ago and they have improved it ever

00:55:56,500 --> 00:56:02,110
since and we can see this that there are

00:56:00,340 --> 00:56:04,420
different levels of this by the way you

00:56:02,110 --> 00:56:07,420
have to interact inside the per program

00:56:04,420 --> 00:56:10,750
which comes on lands gonna interact this

00:56:07,420 --> 00:56:14,380
so you have to add a colon P or : PP or

00:56:10,750 --> 00:56:17,620
colon P P P or 1 PP PP - the event name

00:56:14,380 --> 00:56:20,410
to request the special level of

00:56:17,620 --> 00:56:22,450
precision you're actually asking for so

00:56:20,410 --> 00:56:24,310
these things are not as easy to do so

00:56:22,450 --> 00:56:26,200
but they are possible for some of the

00:56:24,310 --> 00:56:28,000
events nowadays because they have been

00:56:26,200 --> 00:56:29,890
proven to be useful but it meant that n

00:56:28,000 --> 00:56:31,540
that the circuit manufacturers actually

00:56:29,890 --> 00:56:36,550
have to spend a lot of cycles on

00:56:31,540 --> 00:56:39,250
implementing this correctly so let's see

00:56:36,550 --> 00:56:41,800
of an exactly example of how this works

00:56:39,250 --> 00:56:44,650
in reality and I'm really limiting

00:56:41,800 --> 00:56:47,080
ourselves to pop you've already seen so

00:56:44,650 --> 00:56:48,820
curve is not the one that's the program

00:56:47,080 --> 00:56:51,730
which come is part of the last panel

00:56:48,820 --> 00:56:54,070
after value of efforts in the form of

00:56:51,730 --> 00:56:55,990
the Oh profile program always we're

00:56:54,070 --> 00:56:57,730
lingering around because the way in is

00:56:55,990 --> 00:57:00,460
about independently of the column and

00:56:57,730 --> 00:57:02,200
the interface never matched up at some

00:57:00,460 --> 00:57:04,030
point account developers got sick of it

00:57:02,200 --> 00:57:07,300
and implement the own staff which is

00:57:04,030 --> 00:57:10,870
perf so perf has a huge amount of

00:57:07,300 --> 00:57:13,570
functionality and the events as we are

00:57:10,870 --> 00:57:15,190
calling them have which it can record at

00:57:13,570 --> 00:57:18,880
any point in time you can't where you

00:57:15,190 --> 00:57:21,610
this but just learning purpose and what

00:57:18,880 --> 00:57:25,120
you see here are just the first lines if

00:57:21,610 --> 00:57:29,680
you run this today on the on a high-end

00:57:25,120 --> 00:57:31,840
system so again your 10 new laptop might

00:57:29,680 --> 00:57:32,420
not have as many events there although

00:57:31,840 --> 00:57:34,100
many

00:57:32,420 --> 00:57:36,650
the events are not happier events their

00:57:34,100 --> 00:57:38,030
software events but the events which are

00:57:36,650 --> 00:57:40,400
getting there are numbering in the

00:57:38,030 --> 00:57:42,290
hundreds and those are only though the

00:57:40,400 --> 00:57:44,210
ones which actually have been given

00:57:42,290 --> 00:57:46,280
names there are other ways I'm actually

00:57:44,210 --> 00:57:48,800
specifying events which are called raw

00:57:46,280 --> 00:57:51,830
names so raw events where you can

00:57:48,800 --> 00:57:53,750
program basically the performance

00:57:51,830 --> 00:57:55,640
measurement counters directly instruct

00:57:53,750 --> 00:57:57,530
perfectly to this therapy by giving it

00:57:55,640 --> 00:58:00,020
numbers which it has to put in which

00:57:57,530 --> 00:58:02,480
register et cetera so you can with this

00:58:00,020 --> 00:58:04,910
act very every single event which is

00:58:02,480 --> 00:58:07,940
available in your machine and there's a

00:58:04,910 --> 00:58:10,670
huge number of them and usually if

00:58:07,940 --> 00:58:13,220
you're just diddling around with it you

00:58:10,670 --> 00:58:14,480
will have a hard time making sense of

00:58:13,220 --> 00:58:18,950
all this kind of things which are coming

00:58:14,480 --> 00:58:20,960
out but if you're trying to do something

00:58:18,950 --> 00:58:22,550
you just want to get an overview the

00:58:20,960 --> 00:58:25,060
good news is you don't have to worry

00:58:22,550 --> 00:58:27,710
about this in Jamo so this there's a

00:58:25,060 --> 00:58:31,070
command a subcommander curve what's that

00:58:27,710 --> 00:58:33,200
if you're using purpose that without

00:58:31,070 --> 00:58:35,300
anything it will give you a nice

00:58:33,200 --> 00:58:38,450
overview with some commonly used

00:58:35,300 --> 00:58:40,610
counters and it would print out the

00:58:38,450 --> 00:58:42,470
appropriate values over an entire run of

00:58:40,610 --> 00:58:44,480
the program so it gives us the last

00:58:42,470 --> 00:58:46,610
parameter there the sample of stuff in

00:58:44,480 --> 00:58:49,130
the end that's the name of the program

00:58:46,610 --> 00:58:52,310
it gets which gets executed but you can

00:58:49,130 --> 00:58:54,620
also monitor the entire system running

00:58:52,310 --> 00:58:56,600
with us to the setter etc so that's all

00:58:54,620 --> 00:59:00,140
possible and easily doable you can also

00:58:56,600 --> 00:59:02,180
specify with - II here than events which

00:59:00,140 --> 00:59:05,300
we are interested in in the specific

00:59:02,180 --> 00:59:07,940
instance that's possible as well so you

00:59:05,300 --> 00:59:09,980
see there it specifies CPU cycles and

00:59:07,940 --> 00:59:11,900
instructions sometimes CPU cycles

00:59:09,980 --> 00:59:15,500
branches branch misses etcetera etcetera

00:59:11,900 --> 00:59:17,510
so all these kind of things the these

00:59:15,500 --> 00:59:19,370
are commonly defined names and their

00:59:17,510 --> 00:59:22,190
work across architectures that's a nice

00:59:19,370 --> 00:59:25,040
thing about curve because normally these

00:59:22,190 --> 00:59:26,630
the events which are counted there and

00:59:25,040 --> 00:59:29,090
when you're looking at the architecture

00:59:26,630 --> 00:59:30,980
memories of the specific processes they

00:59:29,090 --> 00:59:33,800
have completely different names but they

00:59:30,980 --> 00:59:35,660
have been unified in inside part of many

00:59:33,800 --> 00:59:38,690
of them at least so the interesting

00:59:35,660 --> 00:59:42,620
thing which you see here is the notation

00:59:38,690 --> 00:59:45,880
here with the curly braces anyone wants

00:59:42,620 --> 00:59:45,880
to make a guess what this means

00:59:50,740 --> 00:59:53,740
No

00:59:56,170 --> 01:00:01,160
so if we want to compute ratios one of

00:59:59,540 --> 01:00:03,860
the things which I told you before is

01:00:01,160 --> 01:00:07,070
that dividing one number through another

01:00:03,860 --> 01:00:10,760
number only makes sense if they actually

01:00:07,070 --> 01:00:14,780
have been computed at the same time so

01:00:10,760 --> 01:00:17,030
if I would instruct the CPU to count the

01:00:14,780 --> 01:00:19,130
cycles and the instructions and branches

01:00:17,030 --> 01:00:20,870
and promises et cetera and then compute

01:00:19,130 --> 01:00:23,200
some ratios which is see here is

01:00:20,870 --> 01:00:26,150
happening so you see here for instance

01:00:23,200 --> 01:00:29,930
2.10 instruction per cycle that's one of

01:00:26,150 --> 01:00:32,090
the ratios if I'm telling the CPU to not

01:00:29,930 --> 01:00:36,800
count them always at the same time the

01:00:32,090 --> 01:00:40,910
ratio is at very best it has a large

01:00:36,800 --> 01:00:43,490
error by using these curly braces I'm

01:00:40,910 --> 01:00:46,250
telling the CPU that these counters

01:00:43,490 --> 01:00:50,300
which are listed inside they always have

01:00:46,250 --> 01:00:51,890
to be scheduled at the same time I can

01:00:50,300 --> 01:00:53,900
have multiple of these curly braces

01:00:51,890 --> 01:00:57,080
which then each of them the each of

01:00:53,900 --> 01:01:00,290
these groups can be time multiplexed but

01:00:57,080 --> 01:01:05,020
it means that I can definitely compute

01:01:00,290 --> 01:01:07,550
the ratios based on reasonable values

01:01:05,020 --> 01:01:09,980
that's an important thing so this is not

01:01:07,550 --> 01:01:13,960
actually not that long ago so Waymon do

01:01:09,980 --> 01:01:13,960
you remember what when this was edit

01:01:16,030 --> 01:01:20,150
yeah this kind of thing so this is

01:01:18,710 --> 01:01:22,130
something which was only and it I think

01:01:20,150 --> 01:01:24,080
took perf something like four or five

01:01:22,130 --> 01:01:28,010
years ago for a long time we went

01:01:24,080 --> 01:01:29,690
without that so that's important to keep

01:01:28,010 --> 01:01:31,730
in mind when you're doing this so the

01:01:29,690 --> 01:01:33,410
the thing which I mentioned before that

01:01:31,730 --> 01:01:34,850
that you have to think what you're

01:01:33,410 --> 01:01:36,590
measuring and think about what you're

01:01:34,850 --> 01:01:38,660
doing before you computing the ratios is

01:01:36,590 --> 01:01:40,130
exactly for this and the good news is we

01:01:38,660 --> 01:01:42,890
have ways to actually making sure this

01:01:40,130 --> 01:01:46,340
is the case so keep this in mind when

01:01:42,890 --> 01:01:48,860
you're doing your experiments so this

01:01:46,340 --> 01:01:51,500
was about the absolute numbers and

01:01:48,860 --> 01:01:52,900
getting over hue 20 I mentioned that for

01:01:51,500 --> 01:01:55,330
getting

01:01:52,900 --> 01:01:58,300
spatial information we need to do

01:01:55,330 --> 01:02:00,490
sampling so sampling is done differently

01:01:58,300 --> 01:02:03,250
so you have to start command to record

01:02:00,490 --> 01:02:05,590
it takes in the event specification

01:02:03,250 --> 01:02:10,240
exactly the same way as before so you

01:02:05,590 --> 01:02:12,550
say CPU superb event record and - II and

01:02:10,240 --> 01:02:15,820
then all these names then have a program

01:02:12,550 --> 01:02:17,920
name at the end it runs the program and

01:02:15,820 --> 01:02:20,440
process something like this Nick creates

01:02:17,920 --> 01:02:22,720
normally by default to program a file

01:02:20,440 --> 01:02:24,970
called perfect data but you can specify

01:02:22,720 --> 01:02:28,000
using the - all parameters a different

01:02:24,970 --> 01:02:30,070
file name and but the panel would need

01:02:28,000 --> 01:02:32,260
so this is then containing all the data

01:02:30,070 --> 01:02:35,140
and you can see here so this file is

01:02:32,260 --> 01:02:39,370
already five megabytes in size huge

01:02:35,140 --> 01:02:42,160
number of events are counted and each of

01:02:39,370 --> 01:02:43,960
the individual counts has all kinds of

01:02:42,160 --> 01:02:46,300
information in them like for instance

01:02:43,960 --> 01:02:47,770
Western medicine where in the program it

01:02:46,300 --> 01:02:49,780
actually happened and more importantly

01:02:47,770 --> 01:02:52,290
our modern CPUs not only where it

01:02:49,780 --> 01:02:55,870
happens but where was the program before

01:02:52,290 --> 01:02:57,340
all kinds of information is there so to

01:02:55,870 --> 01:02:59,140
look at the D that you don't have to do

01:02:57,340 --> 01:03:01,660
it manually obviously so that's the

01:02:59,140 --> 01:03:03,670
supplement report you run perf report

01:03:01,660 --> 01:03:05,890
which by default view looks at the perf

01:03:03,670 --> 01:03:07,690
data file it will spit out something

01:03:05,890 --> 01:03:10,120
like this and where it says oh yeah I

01:03:07,690 --> 01:03:12,490
have two different groups of counters

01:03:10,120 --> 01:03:14,980
count the number of curly braces out

01:03:12,490 --> 01:03:18,670
there and I can select them individually

01:03:14,980 --> 01:03:21,220
and looking at them and at the top level

01:03:18,670 --> 01:03:22,990
it will look something like that so this

01:03:21,220 --> 01:03:24,880
is abbreviated there are constant tons

01:03:22,990 --> 01:03:30,150
of stuff missing where it basically says

01:03:24,880 --> 01:03:33,190
that it sorts them by how frequently the

01:03:30,150 --> 01:03:34,720
event was counted in certain certain

01:03:33,190 --> 01:03:36,790
parts of the program blah blah blah

01:03:34,720 --> 01:03:39,160
etcetera so this is what you can then

01:03:36,790 --> 01:03:41,350
use and more importantly inside the

01:03:39,160 --> 01:03:43,180
peripheral and we can even go with with

01:03:41,350 --> 01:03:45,550
the cursor keys up and down here and

01:03:43,180 --> 01:03:47,170
actually press the key and says show me

01:03:45,550 --> 01:03:48,970
the source code then I could even tell

01:03:47,170 --> 01:03:51,130
you exactly in which instruction and

01:03:48,970 --> 01:03:54,130
which presently in which source code

01:03:51,130 --> 01:03:56,440
line the events actually happen so the

01:03:54,130 --> 01:03:59,300
important thing here is based on that

01:03:56,440 --> 01:04:01,790
this is not the raw data which has been

01:03:59,300 --> 01:04:05,839
which has been collected this is already

01:04:01,790 --> 01:04:08,480
pre analyzed data the program as part of

01:04:05,839 --> 01:04:10,970
the periphery ports that time will will

01:04:08,480 --> 01:04:12,800
aggregate data which are data points

01:04:10,970 --> 01:04:14,480
which it has measured which are in the

01:04:12,800 --> 01:04:17,180
same location for instance the same

01:04:14,480 --> 01:04:19,640
function or a function group etc it will

01:04:17,180 --> 01:04:21,710
and getting together and present them as

01:04:19,640 --> 01:04:24,349
such then provide you with with ratios

01:04:21,710 --> 01:04:26,390
being basically saying oh yeah so so

01:04:24,349 --> 01:04:28,790
many percent of all the samples actually

01:04:26,390 --> 01:04:30,530
happened here that's what you can see

01:04:28,790 --> 01:04:33,980
here and it even tries to be more

01:04:30,530 --> 01:04:36,200
helpful by showing you with rats oh this

01:04:33,980 --> 01:04:39,380
is a little bit much they are over my

01:04:36,200 --> 01:04:42,349
threshold then you can look exactly

01:04:39,380 --> 01:04:43,730
where things might have going wrong so I

01:04:42,349 --> 01:04:46,970
don't say that

01:04:43,730 --> 01:04:49,190
for instance this being red doesn't mean

01:04:46,970 --> 01:04:51,530
this is bad it just means that this

01:04:49,190 --> 01:04:53,630
event happened there frequently but if

01:04:51,530 --> 01:04:55,670
you have an intern in the entire program

01:04:53,630 --> 01:04:57,710
exactly one place we're doing all the

01:04:55,670 --> 01:05:00,109
arithmetic operations and you're

01:04:57,710 --> 01:05:02,720
counting arithmetic operations in Poland

01:05:00,109 --> 01:05:04,609
unless obviously it says it gives you a

01:05:02,720 --> 01:05:06,440
number of let's say 80% of our

01:05:04,609 --> 01:05:09,859
arithmetic happens in this location

01:05:06,440 --> 01:05:11,720
that's not bad you have to interpret the

01:05:09,859 --> 01:05:15,349
numbers in the context of the program

01:05:11,720 --> 01:05:17,060
and what you know about it so if you

01:05:15,349 --> 01:05:20,770
want to have something more you can

01:05:17,060 --> 01:05:25,490
actually request the individual data

01:05:20,770 --> 01:05:26,960
records by running per script there are

01:05:25,490 --> 01:05:29,330
a lot of arguments to be learned as well

01:05:26,960 --> 01:05:30,920
so now you have access to the individual

01:05:29,330 --> 01:05:33,010
records which have been recorded and you

01:05:30,920 --> 01:05:36,140
can do your own analysis based on that

01:05:33,010 --> 01:05:37,730
you can also be crazy like me and I have

01:05:36,140 --> 01:05:40,400
written my own library to do these kind

01:05:37,730 --> 01:05:41,660
of things which is a little bit faster

01:05:40,400 --> 01:05:43,339
because this goes through a textual

01:05:41,660 --> 01:05:44,950
representation or some other form for a

01:05:43,339 --> 01:05:48,790
presentation of mine is passed

01:05:44,950 --> 01:05:52,210
all right so then what's the first part

01:05:48,790 --> 01:05:52,210
any questions

01:05:58,890 --> 01:06:03,840
everywhere can't wait to sign it I think

01:06:02,310 --> 01:06:08,310
one of your summer mentees has been

01:06:03,840 --> 01:06:11,430
looking at periphery cord and in in

01:06:08,310 --> 01:06:14,370
under KVM in virtualization and that's

01:06:11,430 --> 01:06:15,960
something that we've wanted to to get

01:06:14,370 --> 01:06:18,470
some better use of first time of our

01:06:15,960 --> 01:06:23,280
work and I was kind of surprised that

01:06:18,470 --> 01:06:26,520
it's in a very early stage I we run all

01:06:23,280 --> 01:06:29,700
of our code in virtualization in the

01:06:26,520 --> 01:06:32,190
cloud so why are there real tools for

01:06:29,700 --> 01:06:34,590
doing that or do not need them or what

01:06:32,190 --> 01:06:37,860
do you think about that you can you can

01:06:34,590 --> 01:06:39,990
run curve inside the container or

01:06:37,860 --> 01:06:41,910
internet side to brush your domain what

01:06:39,990 --> 01:06:47,730
they're looking at is measuring the

01:06:41,910 --> 01:06:49,850
virtual domain from the outside so our

01:06:47,730 --> 01:06:53,160
custom operating system does that the

01:06:49,850 --> 01:06:55,050
the the support inside so yeah there's

01:06:53,160 --> 01:06:57,030
no support so we have to do this and as

01:06:55,050 --> 01:06:59,760
a sauna this is something which is like

01:06:57,030 --> 01:07:02,670
Oh many the perfect event

01:06:59,760 --> 01:07:04,530
our pens events and pegs is not

01:07:02,670 --> 01:07:07,200
supported in a virtual environment on

01:07:04,530 --> 01:07:10,820
Intel CPUs at the moment so it

01:07:07,200 --> 01:07:15,840
there are rich features on bare metal

01:07:10,820 --> 01:07:20,040
but they're not available yes usually

01:07:15,840 --> 01:07:23,040
really so I would not do really

01:07:20,040 --> 01:07:26,090
sophisticated performance analyst except

01:07:23,040 --> 01:07:26,090
if I run that metal

01:07:31,300 --> 01:07:36,130
just to follow up to that if you're

01:07:33,370 --> 01:07:38,230
running a virtual machine with the

01:07:36,130 --> 01:07:41,200
workload in it and then really nothing

01:07:38,230 --> 01:07:43,800
else can you count the next eight to you

01:07:41,200 --> 01:07:46,090
can you can you still count those events

01:07:43,800 --> 01:07:49,060
external to the virtual machine like

01:07:46,090 --> 01:07:52,210
actually monitor the hardware and sort

01:07:49,060 --> 01:07:53,920
of by proxy get an understanding of

01:07:52,210 --> 01:08:01,780
what's happening inside the virtual

01:07:53,920 --> 01:08:04,390
machine does allow you I'm bare metal to

01:08:01,780 --> 01:08:06,700
reach into the virtual machine and be

01:08:04,390 --> 01:08:09,250
sampling events from in there I just I

01:08:06,700 --> 01:08:10,090
don't know if there's any overhead or

01:08:09,250 --> 01:08:12,940
loss j--

01:08:10,090 --> 01:08:14,590
because of that but you know this also

01:08:12,940 --> 01:08:16,630
probably depends on exactly the process

01:08:14,590 --> 01:08:19,650
of version but more importantly you

01:08:16,630 --> 01:08:23,100
don't I don't think you can get the the

01:08:19,650 --> 01:08:25,750
IP recording you don't get the LPR

01:08:23,100 --> 01:08:28,270
information etc because that's the

01:08:25,750 --> 01:08:30,220
different address base you might be able

01:08:28,270 --> 01:08:35,380
to count the events and so on but not

01:08:30,220 --> 01:08:38,710
really much information so by the way

01:08:35,380 --> 01:08:46,330
just a job it is to work with her not

01:08:38,710 --> 01:08:48,490
mine so yes the revolve is coming when

01:08:46,330 --> 01:08:50,590
you are reaching into a guest machine

01:08:48,490 --> 01:08:54,190
and you are asking for samples you do

01:08:50,590 --> 01:08:57,040
pass in pointers to not only to a your

01:08:54,190 --> 01:08:59,440
symbol table and yeah it doesn't do the

01:08:57,040 --> 01:09:01,240
resolution of anything in this sense so

01:08:59,440 --> 01:09:03,820
there's a limit as to what it actually

01:09:01,240 --> 01:09:06,730
can do because the I think the the

01:09:03,820 --> 01:09:08,380
double page table fountains on so along

01:09:06,730 --> 01:09:11,620
the work which has to be done is far too

01:09:08,380 --> 01:09:13,450
much work when interrupted so in the end

01:09:11,620 --> 01:09:15,520
this is something which probably will

01:09:13,450 --> 01:09:17,320
improve over time more and more that's

01:09:15,520 --> 01:09:19,720
more of the workloads which people are

01:09:17,320 --> 01:09:21,970
interested in are in this category and

01:09:19,720 --> 01:09:23,650
if I remember in the first days when we

01:09:21,970 --> 01:09:26,650
gonna be a mess it that me and none of

01:09:23,650 --> 01:09:32,429
that worked at all ever this was added

01:09:26,650 --> 01:09:35,190
over time that has another question

01:09:32,429 --> 01:09:38,670
so in you mention the mapping from the

01:09:35,190 --> 01:09:43,529
for x86 the Sisk instructions to the to

01:09:38,670 --> 01:09:45,509
the microcode is so the only way that

01:09:43,529 --> 01:09:47,460
I've worked is with the Sisk

01:09:45,509 --> 01:09:50,670
instructions but we know that those

01:09:47,460 --> 01:09:54,540
those mappings can be there you can have

01:09:50,670 --> 01:09:58,050
many many risk instructions backing so

01:09:54,540 --> 01:09:59,460
is is there any way to hook into the to

01:09:58,050 --> 01:10:01,590
the actual micro code that's being

01:09:59,460 --> 01:10:04,860
executed if you know an Intel employee

01:10:01,590 --> 01:10:07,830
yes uh-huh because quite honestly so the

01:10:04,860 --> 01:10:10,409
way they're in there are testing new

01:10:07,830 --> 01:10:13,140
functionalities they can reprogram the

01:10:10,409 --> 01:10:15,150
microcode and introduce completely new

01:10:13,140 --> 01:10:17,370
functionality so similarly we have seen

01:10:15,150 --> 01:10:20,909
this with the security problems which we

01:10:17,370 --> 01:10:23,730
have seen in the last two years and most

01:10:20,909 --> 01:10:25,949
of them Intel was at least level with

01:10:23,730 --> 01:10:28,560
time penalties but they were able to fix

01:10:25,949 --> 01:10:32,280
them by micro code updates so this thing

01:10:28,560 --> 01:10:34,380
is incredibly powerful but it also to

01:10:32,280 --> 01:10:37,800
some extent explains why Intel has to go

01:10:34,380 --> 01:10:40,170
to such great lengths to keep up with

01:10:37,800 --> 01:10:41,790
the performance of the AMD silence on by

01:10:40,170 --> 01:10:43,530
using all this out of order and the

01:10:41,790 --> 01:10:46,170
speculative stuff and so on in the first

01:10:43,530 --> 01:10:50,489
place I think a bi AMD doesn't have such

01:10:46,170 --> 01:10:52,650
a such a highly extractable microcode as

01:10:50,489 --> 01:10:58,409
the Intel side has their mapping more

01:10:52,650 --> 01:10:59,820
closely to hard right all right so

01:10:58,409 --> 01:11:04,340
what's the time actually

01:10:59,820 --> 01:11:04,340
sarens do we have to stop right away

01:11:04,580 --> 01:11:12,320
yeah but your your your my room

01:11:09,690 --> 01:11:12,320
coordinator

01:11:14,850 --> 01:11:20,130
yeah yeah it's to us I can I can't

01:11:17,100 --> 01:11:21,690
continue yeah I can continue right away

01:11:20,130 --> 01:11:30,030
or what I have to give you a break

01:11:21,690 --> 01:11:31,860
silent yeah all right I say you have to

01:11:30,030 --> 01:11:35,000
be back in two minutes so that it can

01:11:31,860 --> 01:11:35,000

YouTube URL: https://www.youtube.com/watch?v=ANSla_-Bc4Y


