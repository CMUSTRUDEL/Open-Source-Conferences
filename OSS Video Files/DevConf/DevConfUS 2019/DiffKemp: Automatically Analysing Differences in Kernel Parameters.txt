Title: DiffKemp: Automatically Analysing Differences in Kernel Parameters
Publication date: 2019-10-02
Playlist: DevConfUS 2019
Description: 
	Speaker: Viktor Malik

We present the DiffKemp project - a tool for automatic analysis of differences in the code between versions of the Linux kernel. The tool will help to partially automate checking of compatibility of kernel options (sysctl options, module parameters) and of the kernel ABI, which will make the process of the kernel development and deployment more efficient and reliable. The approach that we use is based on static analysis of the kernel source code, which makes sure that all program paths are covered. For syntactic comparison of the code, we transform it into the intermediary representation of the LLVM (clang) compiler. Moreover, we show how advanced formal methods can be used to prove an equivalence of semantics of programs even when the code is syntactically different.
Captions: 
	00:00:02,560 --> 00:00:11,460
a few minutes after the start so welcome

00:00:08,080 --> 00:00:11,460
to run thank you for coming

00:00:11,589 --> 00:00:17,140
my name is Victor and I'm a software

00:00:14,200 --> 00:00:19,570
engineer and Red Hat and today I'll

00:00:17,140 --> 00:00:21,970
present you become project which is a

00:00:19,570 --> 00:00:24,490
project I'm working on

00:00:21,970 --> 00:00:28,780
I'd like to mention also that besides

00:00:24,490 --> 00:00:31,180
being an engineer in Bernal University

00:00:28,780 --> 00:00:33,820
of Technology I'm working in our branch

00:00:31,180 --> 00:00:36,969
office in the Czech Republic and one of

00:00:33,820 --> 00:00:41,499
my goals or one of the things I like to

00:00:36,969 --> 00:00:44,140
work on is to bring methods and

00:00:41,499 --> 00:00:47,350
stuff from from research after science

00:00:44,140 --> 00:00:50,949
into industry into rap so this is what

00:00:47,350 --> 00:00:54,460
this project actually points so it's

00:00:50,949 --> 00:00:59,019
kind of bringing research to to

00:00:54,460 --> 00:01:01,960
production or production code so what

00:00:59,019 --> 00:01:04,269
the project is about it's about what it

00:01:01,960 --> 00:01:08,590
says automatically analyzing differences

00:01:04,269 --> 00:01:10,719
in kernel parameters so let's dig a bit

00:01:08,590 --> 00:01:13,780
into what that means what is our goal

00:01:10,719 --> 00:01:16,479
our goal is to check that a part of the

00:01:13,780 --> 00:01:18,789
kernel we are talking about Linux kernel

00:01:16,479 --> 00:01:20,950
here part of the kernel behaves the same

00:01:18,789 --> 00:01:25,930
between two different versions of the

00:01:20,950 --> 00:01:28,329
kernel well how do you do it first

00:01:25,930 --> 00:01:31,869
obvious choice would be the traditional

00:01:28,329 --> 00:01:33,939
one and which is to write tests write a

00:01:31,869 --> 00:01:36,850
bunch of tests that will check whether

00:01:33,939 --> 00:01:40,600
the behavior of the some part that you

00:01:36,850 --> 00:01:45,130
want check is the same as the behavior

00:01:40,600 --> 00:01:47,530
of the new version this won't work but

00:01:45,130 --> 00:01:50,799
unfortunately you can never write as

00:01:47,530 --> 00:01:52,509
manages to cover all possible behaviors

00:01:50,799 --> 00:01:56,590
of for example let's say a single

00:01:52,509 --> 00:01:59,469
function writing as many tests to have a

00:01:56,590 --> 00:02:01,659
100% coverage is nearly impossible which

00:01:59,469 --> 00:02:05,229
means that we still can miss some

00:02:01,659 --> 00:02:06,999
behaviors using just testing so instead

00:02:05,229 --> 00:02:09,550
what we do in this project we take a

00:02:06,999 --> 00:02:12,519
different approach and we use so called

00:02:09,550 --> 00:02:14,200
static analysis we compare the source

00:02:12,519 --> 00:02:17,470
code directly look at

00:02:14,200 --> 00:02:20,830
code and compare source code of the

00:02:17,470 --> 00:02:23,170
kernel versions and like running the

00:02:20,830 --> 00:02:26,400
static analysis we determine if there

00:02:23,170 --> 00:02:29,860
may be a difference in in behavior of

00:02:26,400 --> 00:02:33,340
for example kernel functions what is the

00:02:29,860 --> 00:02:35,410
motivation why would we want to do this

00:02:33,340 --> 00:02:37,209
analysis well there are two main reasons

00:02:35,410 --> 00:02:40,840
and those are stability and

00:02:37,209 --> 00:02:44,590
compatibility for example it's the first

00:02:40,840 --> 00:02:46,209
part maybe if you are you if you have

00:02:44,590 --> 00:02:48,730
some setting in a car let's say you have

00:02:46,209 --> 00:02:51,519
a this control option that you have set

00:02:48,730 --> 00:02:53,920
to some value where you want to upgrade

00:02:51,519 --> 00:02:55,989
the kernel to a new version and you want

00:02:53,920 --> 00:02:59,380
to know if you want if you can preserve

00:02:55,989 --> 00:03:01,870
the same setting and if if you preserve

00:02:59,380 --> 00:03:06,580
the same setting if it does exactly the

00:03:01,870 --> 00:03:08,440
same that it did before in such case you

00:03:06,580 --> 00:03:11,190
have to you want to know that the part

00:03:08,440 --> 00:03:14,440
of the kernel that be setting my

00:03:11,190 --> 00:03:15,180
influence behaves the same as it did

00:03:14,440 --> 00:03:17,680
before

00:03:15,180 --> 00:03:20,980
second problem second example is for

00:03:17,680 --> 00:03:22,750
example that breadhead guarantees

00:03:20,980 --> 00:03:24,280
something the stability of something

00:03:22,750 --> 00:03:26,920
that is called kernel application binary

00:03:24,280 --> 00:03:29,680
interface KBI which is essentially a

00:03:26,920 --> 00:03:31,870
list of symbols list of mostly functions

00:03:29,680 --> 00:03:36,070
but rather the guarantees to be stable

00:03:31,870 --> 00:03:38,680
between or across minor versions of Red

00:03:36,070 --> 00:03:41,980
Hat Enterprise Linux this is another

00:03:38,680 --> 00:03:44,019
thing we guarantee the stability and we

00:03:41,980 --> 00:03:46,450
want to know while releasing a new

00:03:44,019 --> 00:03:52,450
version that this these functions are

00:03:46,450 --> 00:03:54,310
really stable let me just set up what we

00:03:52,450 --> 00:03:56,920
are comparing here generally where we

00:03:54,310 --> 00:03:59,799
will be talking and talking about

00:03:56,920 --> 00:04:03,010
comparing functions so we have a

00:03:59,799 --> 00:04:05,590
function in everyone to know if the new

00:04:03,010 --> 00:04:07,030
implementation of the function or the

00:04:05,590 --> 00:04:10,350
function in the new version of the

00:04:07,030 --> 00:04:13,840
kernel plays the same as it did before

00:04:10,350 --> 00:04:17,950
as I said in the previous slide we also

00:04:13,840 --> 00:04:21,659
can compare settings and usually

00:04:17,950 --> 00:04:24,910
settings in kernel are stored in the

00:04:21,659 --> 00:04:27,010
mean or our state as globular

00:04:24,910 --> 00:04:29,080
if you said some sitting it's usually a

00:04:27,010 --> 00:04:31,890
global variable that we get sent to such

00:04:29,080 --> 00:04:34,980
an value in such case when comparing

00:04:31,890 --> 00:04:37,570
effect of two global variables we

00:04:34,980 --> 00:04:40,420
basically take all functions that can

00:04:37,570 --> 00:04:44,590
use that global variable and compare

00:04:40,420 --> 00:04:47,050
them pairwise here we have a slight

00:04:44,590 --> 00:04:48,970
advantage and we can we don't have to

00:04:47,050 --> 00:04:50,980
compare home functions we only need to

00:04:48,970 --> 00:04:53,860
compare parts of those functions that

00:04:50,980 --> 00:04:56,170
the setting the global variable can

00:04:53,860 --> 00:04:59,680
influence we don't have to look at those

00:04:56,170 --> 00:05:01,570
part of the functions that value of the

00:04:59,680 --> 00:05:06,010
global variable cannot influence in in

00:05:01,570 --> 00:05:08,260
control or data sensor but basically we

00:05:06,010 --> 00:05:11,380
reduce all to comparison functions so in

00:05:08,260 --> 00:05:15,370
this talk I will talk about comparison

00:05:11,380 --> 00:05:18,040
of functions so the first obvious method

00:05:15,370 --> 00:05:20,080
when using instead that when comparing

00:05:18,040 --> 00:05:24,310
source code would be why don't we just

00:05:20,080 --> 00:05:27,150
use the one we just take functions give

00:05:24,310 --> 00:05:31,240
them and see if there is any difference

00:05:27,150 --> 00:05:34,900
well I have put here two functions these

00:05:31,240 --> 00:05:36,370
are actually functions from KBI and we

00:05:34,900 --> 00:05:39,010
have here a version of the same function

00:05:36,370 --> 00:05:42,660
from rel 75 and well 76

00:05:39,010 --> 00:05:46,000
the question is are these the same do

00:05:42,660 --> 00:05:49,360
these function do this have the same

00:05:46,000 --> 00:05:52,150
effect well if we give them this would

00:05:49,360 --> 00:05:55,930
be empty so it would say that yes they

00:05:52,150 --> 00:05:58,680
are by looking at it they really seem to

00:05:55,930 --> 00:06:01,510
be equal they actually are like

00:05:58,680 --> 00:06:04,720
lexicographically these are equal as the

00:06:01,510 --> 00:06:07,360
different proof however this function by

00:06:04,720 --> 00:06:10,150
a webpage calls another function cause

00:06:07,360 --> 00:06:12,460
called maxsize offset which is not

00:06:10,150 --> 00:06:16,900
necessarily the same and in this case

00:06:12,460 --> 00:06:18,669
it's really not the return or return

00:06:16,900 --> 00:06:20,320
expression that is returned from this

00:06:18,669 --> 00:06:23,410
function changes a bit or changed

00:06:20,320 --> 00:06:27,280
between the two versions and in the new

00:06:23,410 --> 00:06:29,380
version there is some one more function

00:06:27,280 --> 00:06:31,900
edited to do to the original result and

00:06:29,380 --> 00:06:36,120
which we choose either the original

00:06:31,900 --> 00:06:37,960
result or some number of maximum sectors

00:06:36,120 --> 00:06:42,009
so

00:06:37,960 --> 00:06:43,539
this case sorry the problem requires at

00:06:42,009 --> 00:06:44,410
least checking of the call function so

00:06:43,539 --> 00:06:46,599
it's not that easy

00:06:44,410 --> 00:06:48,580
we cannot just use plaintiff we have to

00:06:46,599 --> 00:06:54,669
understand the code at least to some

00:06:48,580 --> 00:06:57,729
extent we can go your further again the

00:06:54,669 --> 00:06:59,710
same question we have two functions or

00:06:57,729 --> 00:07:02,590
we have a single function tcp propene it

00:06:59,710 --> 00:07:05,620
in two different versions loops 310 and

00:07:02,590 --> 00:07:09,009
411 and the question is are these

00:07:05,620 --> 00:07:11,020
function the same well if we is DIF look

00:07:09,009 --> 00:07:12,940
at it they are not because the the new

00:07:11,020 --> 00:07:15,060
function implements some kind of check

00:07:12,940 --> 00:07:18,550
at the beginning wholesome accrue that

00:07:15,060 --> 00:07:21,940
creates a back if some unexpected

00:07:18,550 --> 00:07:24,840
situation happens however if you

00:07:21,940 --> 00:07:28,000
remember I was talking about comparing

00:07:24,840 --> 00:07:31,090
kernel options which are essentially

00:07:28,000 --> 00:07:34,090
kernel variable global variables in this

00:07:31,090 --> 00:07:37,330
case what if we want to compare these

00:07:34,090 --> 00:07:39,550
not whole functions but just functions

00:07:37,330 --> 00:07:42,460
with respect to the value of the global

00:07:39,550 --> 00:07:45,880
variable book size let's say user kernel

00:07:42,460 --> 00:07:49,840
user has a possibility to set the value

00:07:45,880 --> 00:07:52,680
of the variable size to some value we

00:07:49,840 --> 00:07:55,389
want to know if the value that here set

00:07:52,680 --> 00:07:58,090
has the same effect on this particle

00:07:55,389 --> 00:08:00,580
function in both versions in this case

00:07:58,090 --> 00:08:02,949
if we only compare the functions with

00:08:00,580 --> 00:08:05,500
respect to the value of business

00:08:02,949 --> 00:08:07,870
we'll find out that they are exactly the

00:08:05,500 --> 00:08:11,320
same because the only parts of the code

00:08:07,870 --> 00:08:14,650
that value of both size may affect our

00:08:11,320 --> 00:08:19,330
G's this Margaret and these two are

00:08:14,650 --> 00:08:21,580
exactly the same so again receive it we

00:08:19,330 --> 00:08:25,210
have to understand the code to some

00:08:21,580 --> 00:08:28,599
extent to be able to decide the equality

00:08:25,210 --> 00:08:31,270
or not equality actually we could go

00:08:28,599 --> 00:08:32,529
even further this is not from kernel

00:08:31,270 --> 00:08:37,630
these are two different implementations

00:08:32,529 --> 00:08:39,640
of C library function STR PB r KY from

00:08:37,630 --> 00:08:42,399
daya Lipsy and OpenBSD

00:08:39,640 --> 00:08:45,190
and the question again is the same are

00:08:42,399 --> 00:08:46,959
these two functions equal so do they

00:08:45,190 --> 00:08:49,910
have the same shape for every

00:08:46,959 --> 00:08:53,570
combination if we

00:08:49,910 --> 00:08:55,760
sent to our same argument here and to

00:08:53,570 --> 00:09:00,530
some arguments here will the result be

00:08:55,760 --> 00:09:04,460
always be the same this is not so easy

00:09:00,530 --> 00:09:07,190
to see by by just looking at the

00:09:04,460 --> 00:09:08,960
functions we could certainly write some

00:09:07,190 --> 00:09:12,310
tests but as I said it would not cover

00:09:08,960 --> 00:09:17,720
all possible behaviors probably but

00:09:12,310 --> 00:09:21,740
actually they are and actually there are

00:09:17,720 --> 00:09:24,860
tools that can prove this this is

00:09:21,740 --> 00:09:27,710
exactly where science come in to come

00:09:24,860 --> 00:09:30,350
into play and yeah there are tools based

00:09:27,710 --> 00:09:32,090
on quite advanced scientific formal

00:09:30,350 --> 00:09:35,660
methods that can prove that these two

00:09:32,090 --> 00:09:37,280
functions are the same they have exactly

00:09:35,660 --> 00:09:42,500
the same behavior for every possible

00:09:37,280 --> 00:09:44,930
combination of arguments so in this case

00:09:42,500 --> 00:09:46,460
the problem requires quite a deep

00:09:44,930 --> 00:09:49,820
understanding of the code so if you want

00:09:46,460 --> 00:09:51,800
to build something like this or a tool

00:09:49,820 --> 00:09:53,930
that does this automatically we need a

00:09:51,800 --> 00:09:54,410
tool to understand the code so how do we

00:09:53,930 --> 00:09:57,710
do it

00:09:54,410 --> 00:10:00,830
well as we already said using div is not

00:09:57,710 --> 00:10:02,420
an option it's efficient we can analyze

00:10:00,830 --> 00:10:04,370
the C code yeah that's what we are

00:10:02,420 --> 00:10:05,900
essentially doing but analyzing C code

00:10:04,370 --> 00:10:07,130
directly would be quite impractical

00:10:05,900 --> 00:10:09,290
because we would have to write a parser

00:10:07,130 --> 00:10:11,810
essentially would have to write a

00:10:09,290 --> 00:10:15,050
compiler to some representation that we

00:10:11,810 --> 00:10:18,410
would then compare so yeah it's C combo

00:10:15,050 --> 00:10:20,360
is quite a linux the other part we could

00:10:18,410 --> 00:10:22,730
use a compiler and analyze the produced

00:10:20,360 --> 00:10:25,250
assembly code we could do that but

00:10:22,730 --> 00:10:27,320
there's another problem it's two

00:10:25,250 --> 00:10:29,390
instruction there's a way too much

00:10:27,320 --> 00:10:30,950
information lost when when compiling

00:10:29,390 --> 00:10:33,320
into assembly and it would be quite

00:10:30,950 --> 00:10:35,300
difficult to compare directly assembly

00:10:33,320 --> 00:10:38,420
so the solution is somewhere in the

00:10:35,300 --> 00:10:40,160
middle and we use a compiler but we use

00:10:38,420 --> 00:10:44,020
a compilers internal representation

00:10:40,160 --> 00:10:47,410
every compiler GCC client gets

00:10:44,020 --> 00:10:50,090
traditionally transfer or translates the

00:10:47,410 --> 00:10:51,770
C code into an intermediate

00:10:50,090 --> 00:10:54,680
representation that they do a bunch of

00:10:51,770 --> 00:10:58,130
transformations analysis etc and then

00:10:54,680 --> 00:11:00,950
they compile this into assembly for the

00:10:58,130 --> 00:11:02,520
processor so what we do is that we use

00:11:00,950 --> 00:11:06,209
the compiler internal

00:11:02,520 --> 00:11:08,010
and reanalyze the we compare that what

00:11:06,209 --> 00:11:09,899
are the advantages well we get a sore

00:11:08,010 --> 00:11:12,630
throat parcel for free because we used

00:11:09,899 --> 00:11:14,190
an off-the-shelf compiler and still the

00:11:12,630 --> 00:11:17,190
coop the internal representation is

00:11:14,190 --> 00:11:19,649
quite a structured representation that

00:11:17,190 --> 00:11:21,959
contains things such as types integer

00:11:19,649 --> 00:11:23,370
Russell we can read we have much more

00:11:21,959 --> 00:11:27,740
information we also have debugging

00:11:23,370 --> 00:11:31,050
symbols etc in this case we use Clank or

00:11:27,740 --> 00:11:33,420
LLVM so we done this GCC which is the

00:11:31,050 --> 00:11:35,910
default choice to compile the kernel we

00:11:33,420 --> 00:11:38,279
use a lot of em instead why do we do

00:11:35,910 --> 00:11:42,270
that there are multiple benefits of

00:11:38,279 --> 00:11:45,660
using LLVM over GCC first one is it has

00:11:42,270 --> 00:11:49,440
quite well-structured and human readable

00:11:45,660 --> 00:11:51,600
internal representation we when we talk

00:11:49,440 --> 00:11:55,440
about internal presentation we usually

00:11:51,600 --> 00:11:57,450
say it as LLVM IR so when I say IR it's

00:11:55,440 --> 00:12:00,089
a internal presentation of all of you

00:11:57,450 --> 00:12:03,060
here we can have an example there's a

00:12:00,089 --> 00:12:08,120
function the computes absolute value of

00:12:03,060 --> 00:12:12,510
x and here's the code transformed into a

00:12:08,120 --> 00:12:14,820
LLVM IR there are tools that enable you

00:12:12,510 --> 00:12:17,310
to visualize the code quite nicely so

00:12:14,820 --> 00:12:20,279
it's very critical in debugging when

00:12:17,310 --> 00:12:21,480
finding the problems and so on also LVM

00:12:20,279 --> 00:12:24,600
has quite a nice infrastructure

00:12:21,480 --> 00:12:26,250
containing many useful analysis and code

00:12:24,600 --> 00:12:28,320
transformations that are already built

00:12:26,250 --> 00:12:30,089
in so we can use those we don't have to

00:12:28,320 --> 00:12:32,339
write our own transformations of the

00:12:30,089 --> 00:12:34,940
code that we want to use because a lot

00:12:32,339 --> 00:12:38,640
of them are already built into our game

00:12:34,940 --> 00:12:41,490
also it is poisonous API and last but

00:12:38,640 --> 00:12:43,589
not least there's already a number of

00:12:41,490 --> 00:12:49,670
static analyzers that are built over

00:12:43,589 --> 00:12:54,120
LLVM both commercial ones ones running

00:12:49,670 --> 00:12:57,120
some analyzers that are running on a

00:12:54,120 --> 00:13:00,570
production code also there are research

00:12:57,120 --> 00:13:03,890
or science tools that that run over LLVM

00:13:00,570 --> 00:13:06,240
and implement advance from lifeÃ­s etc so

00:13:03,890 --> 00:13:08,970
this is another advantage that we can

00:13:06,240 --> 00:13:12,630
build or we can use others work we don't

00:13:08,970 --> 00:13:14,850
have to wait in one wheel so now let's

00:13:12,630 --> 00:13:19,259
get into how this camp does

00:13:14,850 --> 00:13:22,110
gay analysis we do it in two phases the

00:13:19,259 --> 00:13:24,930
first phase generate phase takes a

00:13:22,110 --> 00:13:27,690
kernel source takes a list of parameters

00:13:24,930 --> 00:13:29,730
or or KBI symbols or whatever we want to

00:13:27,690 --> 00:13:31,560
compare and generates a so-called a lot

00:13:29,730 --> 00:13:37,110
of em snapshot album snapshot is

00:13:31,560 --> 00:13:39,149
basically a set of LLVM of files in LLVM

00:13:37,110 --> 00:13:41,579
internal representation that contain

00:13:39,149 --> 00:13:44,220
definitions of functions that we want to

00:13:41,579 --> 00:13:46,440
compare afterwards in the second phase

00:13:44,220 --> 00:13:48,600
we take the snapshot and we run the

00:13:46,440 --> 00:13:51,870
actual comparison and the result is well

00:13:48,600 --> 00:13:53,610
either for each function that is in the

00:13:51,870 --> 00:13:56,399
snapshot or that we want to compare

00:13:53,610 --> 00:13:58,019
either the effect of the function

00:13:56,399 --> 00:14:01,199
semantics or the function is he is the

00:13:58,019 --> 00:14:03,810
same or which is not the same if it's

00:14:01,199 --> 00:14:05,699
not the same we also provide an

00:14:03,810 --> 00:14:10,610
additional info for to the user so that

00:14:05,699 --> 00:14:10,610
he knows where the actual difference is

00:14:11,089 --> 00:14:19,980
right so generate face as I said takes a

00:14:16,980 --> 00:14:23,189
source code and parameters and guilt and

00:14:19,980 --> 00:14:25,829
LLVM snapshot how do we do that it's

00:14:23,189 --> 00:14:29,730
basically composed of two small faces

00:14:25,829 --> 00:14:32,339
first of all we need to find in which C

00:14:29,730 --> 00:14:36,089
sources those the functions that we are

00:14:32,339 --> 00:14:39,689
interested in are are defined to this we

00:14:36,089 --> 00:14:42,480
can use a wall or quite widely use this

00:14:39,689 --> 00:14:45,420
cop tool which for for function can give

00:14:42,480 --> 00:14:46,980
you a source where the function is

00:14:45,420 --> 00:14:50,100
defined where the implementation of

00:14:46,980 --> 00:14:52,319
diffraction occurs and afterwards when

00:14:50,100 --> 00:14:55,350
we once we have the source we compile it

00:14:52,319 --> 00:14:59,430
into the album planner today we use the

00:14:55,350 --> 00:15:01,860
compiler of course we do that in such a

00:14:59,430 --> 00:15:03,480
way that we we find a comment that would

00:15:01,860 --> 00:15:05,850
be run by K build K build is the

00:15:03,480 --> 00:15:08,220
internal kernel internal build system we

00:15:05,850 --> 00:15:10,170
find a comment that would be fun that

00:15:08,220 --> 00:15:12,720
would be run by cable to build that file

00:15:10,170 --> 00:15:15,350
and we replace GCC by plank this way we

00:15:12,720 --> 00:15:19,620
get the same optimizations the same

00:15:15,350 --> 00:15:22,139
include libraries etc once we have the

00:15:19,620 --> 00:15:24,410
album snapshot we can go comparing this

00:15:22,139 --> 00:15:26,630
suffice that the swath of the right

00:15:24,410 --> 00:15:30,139
before the comparison itself

00:15:26,630 --> 00:15:33,170
we run a number of simplifications of

00:15:30,139 --> 00:15:35,839
code transformations that will let's say

00:15:33,170 --> 00:15:37,579
remove all the code that is not relevant

00:15:35,839 --> 00:15:39,170
for the analysis and then we will

00:15:37,579 --> 00:15:41,000
simplify the code so that it is much

00:15:39,170 --> 00:15:42,740
easier to be compared later because the

00:15:41,000 --> 00:15:46,910
comparison itself is quite a difficult

00:15:42,740 --> 00:15:49,870
task it takes some time so the last code

00:15:46,910 --> 00:15:52,360
we need to compare the faster it will be

00:15:49,870 --> 00:15:56,690
afterwards we run the actual difference

00:15:52,360 --> 00:15:59,269
in case the semantic drift says that the

00:15:56,690 --> 00:16:01,730
functions are equal in case it says that

00:15:59,269 --> 00:16:03,889
they're not we have to run the

00:16:01,730 --> 00:16:06,100
difference localization or we try to

00:16:03,889 --> 00:16:08,720
find where the difference occurs and

00:16:06,100 --> 00:16:10,670
supply to user as many as much

00:16:08,720 --> 00:16:18,290
information as possible slower he knows

00:16:10,670 --> 00:16:21,319
where the where the word so code SAVE

00:16:18,290 --> 00:16:23,449
slicing and simplifying this is a face

00:16:21,319 --> 00:16:25,069
as I said to you simplify the code as

00:16:23,449 --> 00:16:26,509
much as possible and one of the main

00:16:25,069 --> 00:16:29,269
techniques that we are using is

00:16:26,509 --> 00:16:31,970
so-called code slicing code slicing is

00:16:29,269 --> 00:16:33,829
removing technique for removing all the

00:16:31,970 --> 00:16:36,500
code that is not relevant for the

00:16:33,829 --> 00:16:38,329
analysis I'll get back to the example I

00:16:36,500 --> 00:16:40,730
showed in the beginning and we have

00:16:38,329 --> 00:16:43,250
function and but we know that we want to

00:16:40,730 --> 00:16:45,980
compare it or we will analyze it with

00:16:43,250 --> 00:16:47,990
respect to the value of a variable book

00:16:45,980 --> 00:16:50,509
size so in this case we can slice this

00:16:47,990 --> 00:16:54,259
function so that we only keep those

00:16:50,509 --> 00:16:57,290
instructions those those commands that

00:16:54,259 --> 00:16:59,930
the value of the variable size can

00:16:57,290 --> 00:17:03,069
affect so in this case we can remove

00:16:59,930 --> 00:17:06,020
these first two lines basically because

00:17:03,069 --> 00:17:08,270
whatever the value of bouff size will be

00:17:06,020 --> 00:17:10,640
there will be always executed the same

00:17:08,270 --> 00:17:12,470
way so in this case we can slice this

00:17:10,640 --> 00:17:15,319
code we can slice out these two first

00:17:12,470 --> 00:17:18,559
lines and obtain only this part which is

00:17:15,319 --> 00:17:21,350
which is exactly this these are the all

00:17:18,559 --> 00:17:22,730
all those commands are affected by the

00:17:21,350 --> 00:17:25,039
value of the book size because it either

00:17:22,730 --> 00:17:28,640
appears in the command or for example

00:17:25,039 --> 00:17:32,120
here we are testing some subfield of a

00:17:28,640 --> 00:17:34,250
variable which is set by calling a

00:17:32,120 --> 00:17:38,150
function which depends on there's a

00:17:34,250 --> 00:17:38,750
transitive dependence also after slicing

00:17:38,150 --> 00:17:40,490
we run

00:17:38,750 --> 00:17:43,179
a bunch of code simplifications such as

00:17:40,490 --> 00:17:47,000
for example in Colonel you can have

00:17:43,179 --> 00:17:49,309
functions that are yeah become functions

00:17:47,000 --> 00:17:51,320
function calls that as an argument have

00:17:49,309 --> 00:17:54,350
a string which contains an absolute path

00:17:51,320 --> 00:17:55,850
to debt source file of course it will be

00:17:54,350 --> 00:17:59,240
different from from the other one

00:17:55,850 --> 00:18:00,679
because you can have the kernel the two

00:17:59,240 --> 00:18:03,230
kernels that you are comparing store in

00:18:00,679 --> 00:18:05,840
different directories so we'll remove

00:18:03,230 --> 00:18:08,990
these or normalize these we run that

00:18:05,840 --> 00:18:11,960
code elimination which removes all the

00:18:08,990 --> 00:18:13,909
code that is not reachable when executed

00:18:11,960 --> 00:18:15,770
because if there is a difference in in

00:18:13,909 --> 00:18:17,450
the code that is not reachable that we

00:18:15,770 --> 00:18:19,909
don't care because it will never be

00:18:17,450 --> 00:18:24,169
exactly G so that difference will never

00:18:19,909 --> 00:18:26,659
occur etc etc this shows the advantage

00:18:24,169 --> 00:18:28,220
of LLVM because it already has that code

00:18:26,659 --> 00:18:32,600
elimination pass caused the propagation

00:18:28,220 --> 00:18:36,250
passes and so on afterwards we render

00:18:32,600 --> 00:18:39,530
this itself the diff itself is again

00:18:36,250 --> 00:18:42,220
leveraging on LVM infrastructure and we

00:18:39,530 --> 00:18:45,080
are using an elegant component called

00:18:42,220 --> 00:18:46,549
function cooperator which it's a

00:18:45,080 --> 00:18:48,289
component that goes instruction by

00:18:46,549 --> 00:18:48,799
instruction and compares them for

00:18:48,289 --> 00:18:51,730
equality

00:18:48,799 --> 00:18:54,470
so this basically does syntactic

00:18:51,730 --> 00:18:59,690
equality or syntactic ative thanks to

00:18:54,470 --> 00:19:01,640
using LLVM ir instead of of c we already

00:18:59,690 --> 00:19:04,309
can handle stuff like for example

00:19:01,640 --> 00:19:06,380
variable renaming now the vampire chose

00:19:04,309 --> 00:19:11,330
not to use the original variable names

00:19:06,380 --> 00:19:13,429
so it just checks whether the iri are in

00:19:11,330 --> 00:19:16,760
LLVM piece of control flow graph is a

00:19:13,429 --> 00:19:18,679
graph of of instructions and control

00:19:16,760 --> 00:19:20,450
flow edges so it just checks whether the

00:19:18,679 --> 00:19:21,679
graph has the same structure so it

00:19:20,450 --> 00:19:25,210
doesn't care about the names of the

00:19:21,679 --> 00:19:28,250
variables we extend this comparator by

00:19:25,210 --> 00:19:30,950
handling changes or by identifying

00:19:28,250 --> 00:19:33,049
patterns that we know that are

00:19:30,950 --> 00:19:33,950
syntactically different but have the

00:19:33,049 --> 00:19:36,409
same semantics

00:19:33,950 --> 00:19:38,450
such as for example changes in structure

00:19:36,409 --> 00:19:41,929
layout that preserves semantics or for

00:19:38,450 --> 00:19:44,510
example moving code into functions yes a

00:19:41,929 --> 00:19:45,860
function that calls unquote and in the

00:19:44,510 --> 00:19:48,020
new version of the function you say that

00:19:45,860 --> 00:19:49,700
code put it into another function I call

00:19:48,020 --> 00:19:52,549
it this is exactly

00:19:49,700 --> 00:19:55,429
different but if if you analyze it

00:19:52,549 --> 00:19:57,350
correctly you will find out that it does

00:19:55,429 --> 00:20:02,440
actually the same so we can handle these

00:19:57,350 --> 00:20:05,029
kinds of situations but more importantly

00:20:02,440 --> 00:20:07,039
the last I would say that the last step

00:20:05,029 --> 00:20:10,130
is even more important than the previous

00:20:07,039 --> 00:20:12,169
one because it's nice to find out that

00:20:10,130 --> 00:20:14,360
the functions are equal or not but if

00:20:12,169 --> 00:20:17,029
you say to the user hey these two

00:20:14,360 --> 00:20:20,360
functions are not equal well he won't be

00:20:17,029 --> 00:20:23,870
very happy because well it's nice to

00:20:20,360 --> 00:20:25,460
know that they are not equal but how

00:20:23,870 --> 00:20:29,149
does he know where a difference occurs

00:20:25,460 --> 00:20:31,690
and so on so this is one of I would say

00:20:29,149 --> 00:20:34,549
the most important component and it

00:20:31,690 --> 00:20:36,909
provides the user information about the

00:20:34,549 --> 00:20:40,309
found difference what we can currently

00:20:36,909 --> 00:20:41,690
find is we find the symbol in which the

00:20:40,309 --> 00:20:43,070
difference occurs this is not

00:20:41,690 --> 00:20:44,750
necessarily the symbol that we are

00:20:43,070 --> 00:20:46,639
generally comparing right so we are

00:20:44,750 --> 00:20:50,440
comparing two functions but the

00:20:46,639 --> 00:20:52,940
difference can be in some cool function

00:20:50,440 --> 00:20:54,769
moreover it's not necessarily in a

00:20:52,940 --> 00:20:56,630
function it can be in a macro it can be

00:20:54,769 --> 00:21:00,380
in an inline assembly code we can even

00:20:56,630 --> 00:21:03,880
identify all of these next we determine

00:21:00,380 --> 00:21:06,919
where the symbol definition is

00:21:03,880 --> 00:21:09,200
physically is located in in the source

00:21:06,919 --> 00:21:12,289
file so we get the name of the source

00:21:09,200 --> 00:21:15,830
file and the line in which the different

00:21:12,289 --> 00:21:18,190
symbol is defined then we get a program

00:21:15,830 --> 00:21:21,559
path from the analyzed symbol to the

00:21:18,190 --> 00:21:26,690
reference table we just give a plane

00:21:21,559 --> 00:21:32,240
call SEC where each line contains a

00:21:26,690 --> 00:21:35,809
function call with a company with a file

00:21:32,240 --> 00:21:39,320
name and and the line number I will show

00:21:35,809 --> 00:21:41,480
these in the demo and at the end finally

00:21:39,320 --> 00:21:44,510
we have the actual difference so we take

00:21:41,480 --> 00:21:46,130
the different functions and we return we

00:21:44,510 --> 00:21:48,789
run them through a diff tool and we

00:21:46,130 --> 00:21:51,710
return the result

00:21:48,789 --> 00:21:54,019
just to mention these all these

00:21:51,710 --> 00:21:55,789
information are retrieved or is in is

00:21:54,019 --> 00:21:58,519
retrieved for either from debugging

00:21:55,789 --> 00:21:59,539
symbols and also we do an initial

00:21:58,519 --> 00:22:01,909
analysis of the

00:21:59,539 --> 00:22:04,609
see code because for example macros are

00:22:01,909 --> 00:22:07,809
lost usage of makers is lost during

00:22:04,609 --> 00:22:12,559
compilation so we analyze C code

00:22:07,809 --> 00:22:14,840
directly again using debugging symbols

00:22:12,559 --> 00:22:18,229
so that we know which parts we have to

00:22:14,840 --> 00:22:23,019
analyze and this way we can combine for

00:22:18,229 --> 00:22:26,779
example differences in macros etc now

00:22:23,019 --> 00:22:29,840
this is a part that before showing the

00:22:26,779 --> 00:22:34,639
demo I would like to show one more thing

00:22:29,840 --> 00:22:38,210
and the question is can we do more can

00:22:34,639 --> 00:22:39,409
we really analyze if you remember in the

00:22:38,210 --> 00:22:42,649
beginning I showed these two

00:22:39,409 --> 00:22:44,419
implementations of C library function

00:22:42,649 --> 00:22:45,679
that were completely syntactically

00:22:44,419 --> 00:22:47,989
different but there were semantically

00:22:45,679 --> 00:22:51,679
the same can we do this here do you

00:22:47,989 --> 00:22:57,440
support such things Inc yes we do we

00:22:51,679 --> 00:22:59,869
have an option or experimental step that

00:22:57,440 --> 00:23:04,220
is called advanced semantic t'v and that

00:22:59,869 --> 00:23:09,049
can really do this this is based on

00:23:04,220 --> 00:23:12,080
using tools that use formal methods to

00:23:09,049 --> 00:23:14,570
prove that two programs are semantically

00:23:12,080 --> 00:23:17,119
equal we use one such tool called ll

00:23:14,570 --> 00:23:19,849
wrap it's a tool developed by some

00:23:17,119 --> 00:23:23,179
researchers at a university in Karlsruhe

00:23:19,849 --> 00:23:25,460
Germany and we used we found its tool

00:23:23,179 --> 00:23:27,679
and we use it because it operates over

00:23:25,460 --> 00:23:30,559
LLVM so it's quite simple for us to use

00:23:27,679 --> 00:23:33,979
it we just take the LLVM

00:23:30,559 --> 00:23:35,629
ir files that we compiled and feed them

00:23:33,979 --> 00:23:39,739
to the tool and it will give us the

00:23:35,629 --> 00:23:43,070
result so the tool is not written by us

00:23:39,739 --> 00:23:47,239
but i wanted to show you that this is

00:23:43,070 --> 00:23:48,950
the size part of the of the talk and i

00:23:47,239 --> 00:23:51,919
will show you that there are really

00:23:48,950 --> 00:23:56,080
methods how to find that two programs

00:23:51,919 --> 00:24:01,129
are semantically equal how this is done

00:23:56,080 --> 00:24:03,649
well especially in these two the compare

00:24:01,129 --> 00:24:05,559
programs are translated into a logical

00:24:03,649 --> 00:24:08,029
formula so we take the program and

00:24:05,559 --> 00:24:10,519
translate it into a logical formula

00:24:08,029 --> 00:24:12,720
which expresses the effect of the

00:24:10,519 --> 00:24:14,760
program in terms of logical variable

00:24:12,720 --> 00:24:16,049
afterwards there is a tool for solving

00:24:14,760 --> 00:24:19,020
logical formulae

00:24:16,049 --> 00:24:21,270
these tools are called SMT solvers you

00:24:19,020 --> 00:24:23,760
may know for example z3 it's one of the

00:24:21,270 --> 00:24:24,270
most known ones and we ask you the

00:24:23,760 --> 00:24:28,830
question

00:24:24,270 --> 00:24:31,290
is there an input I so that executing

00:24:28,830 --> 00:24:33,540
the first program with this input yields

00:24:31,290 --> 00:24:35,970
a different result then executing the

00:24:33,540 --> 00:24:38,669
second program with the same input in

00:24:35,970 --> 00:24:41,100
case the tool tells us that yes there is

00:24:38,669 --> 00:24:43,260
such an input then we know that programs

00:24:41,100 --> 00:24:45,150
are not equal moreover it gives us

00:24:43,260 --> 00:24:47,160
so-called counter example which means

00:24:45,150 --> 00:24:51,660
that it gives us exactly the dead input

00:24:47,160 --> 00:24:53,880
so we can maybe or we could potentially

00:24:51,660 --> 00:24:56,190
parse it analyze it and provide the user

00:24:53,880 --> 00:24:59,190
more information in case it says no

00:24:56,190 --> 00:25:00,929
there is no such input then we are sure

00:24:59,190 --> 00:25:04,500
that the programs are equal because

00:25:00,929 --> 00:25:06,720
there is no such such input that the

00:25:04,500 --> 00:25:09,480
effect of the functions would be

00:25:06,720 --> 00:25:11,880
different here by input it's not

00:25:09,480 --> 00:25:13,679
necessarily argument already arguments

00:25:11,880 --> 00:25:16,530
it can be a side of the stack or state

00:25:13,679 --> 00:25:18,780
of the heap also the result is not

00:25:16,530 --> 00:25:22,429
necessarily only the reserved the return

00:25:18,780 --> 00:25:27,419
value function it can be for example

00:25:22,429 --> 00:25:30,360
against a door deep but this way we can

00:25:27,419 --> 00:25:34,230
prove real proof proof a soundly proof

00:25:30,360 --> 00:25:38,730
that two functions are semantically

00:25:34,230 --> 00:25:41,549
equivalent okay let's get into demo I

00:25:38,730 --> 00:25:46,290
will show you shortly more on how this

00:25:41,549 --> 00:25:48,720
actually works so we'll compare we will

00:25:46,290 --> 00:25:51,270
compare the function that we have seen

00:25:48,720 --> 00:25:53,160
in the beginning and first of all we

00:25:51,270 --> 00:25:54,900
need to create a list of functions that

00:25:53,160 --> 00:25:57,210
we want to compare in this case we only

00:25:54,900 --> 00:25:59,640
are comparing a single function so I

00:25:57,210 --> 00:26:02,059
will create a file which will contain

00:25:59,640 --> 00:26:05,010
the name of the function bio at page

00:26:02,059 --> 00:26:08,669
yeah I will store it in some file cavity

00:26:05,010 --> 00:26:10,890
wall right now as the next part we will

00:26:08,669 --> 00:26:12,750
generate a snapshot LLVM snapshot that

00:26:10,890 --> 00:26:16,020
will contain the definitely or the the

00:26:12,750 --> 00:26:19,919
LLVM files that contain definition of

00:26:16,020 --> 00:26:23,340
which function so let's run this camp we

00:26:19,919 --> 00:26:25,130
generate command and first of all we

00:26:23,340 --> 00:26:29,030
specify which kernel we want to come

00:26:25,130 --> 00:26:32,450
so I have his in kernel Linux this is

00:26:29,030 --> 00:26:34,940
the version of kernel for resident 5

00:26:32,450 --> 00:26:42,080
next we specify when we where we want to

00:26:34,940 --> 00:26:43,270
store the snapshot so a bit uh larger is

00:26:42,080 --> 00:26:48,530
it better

00:26:43,270 --> 00:26:50,450
can you see okay cool yeah Andrew and we

00:26:48,530 --> 00:26:53,300
said we say which file we are actually

00:26:50,450 --> 00:26:54,620
comparing which is or which file

00:26:53,300 --> 00:26:58,330
contains the functions that we are

00:26:54,620 --> 00:27:00,770
actually comparing this game says that

00:26:58,330 --> 00:27:02,540
it has found one one function in the

00:27:00,770 --> 00:27:05,780
file and that the definition of the

00:27:02,540 --> 00:27:09,380
function can be found in the file FS /

00:27:05,780 --> 00:27:12,860
bio-dad C which was compiled into a file

00:27:09,380 --> 00:27:14,870
FS / bio ll now we do the same for the

00:27:12,860 --> 00:27:17,150
other kernel because we are we always

00:27:14,870 --> 00:27:20,960
have to compare two versions so we take

00:27:17,150 --> 00:27:25,310
a version of the following of the

00:27:20,960 --> 00:27:27,380
following RAL version so the first one

00:27:25,310 --> 00:27:29,030
sir the first one the most well seven

00:27:27,380 --> 00:27:32,510
five this will be real seven six so

00:27:29,030 --> 00:27:36,140
let's store it into a snapshot / 7 6

00:27:32,510 --> 00:27:38,840
yeah we check the same list of functions

00:27:36,140 --> 00:27:43,010
again it was compiled into the same

00:27:38,840 --> 00:27:45,820
thing and now let's run the comparison

00:27:43,010 --> 00:27:48,590
so let's run this campaign compare mode

00:27:45,820 --> 00:27:49,220
specifying snapshots so first one is

00:27:48,590 --> 00:27:53,690
Relson

00:27:49,220 --> 00:27:57,200
5 second one is RL 7 6 and let's tell

00:27:53,690 --> 00:27:57,650
him that we want to show diff and it is

00:27:57,200 --> 00:28:01,340
found

00:27:57,650 --> 00:28:03,380
yeah please the result there is an

00:28:01,340 --> 00:28:06,410
output which means there is a difference

00:28:03,380 --> 00:28:09,140
and this tells us everything that we can

00:28:06,410 --> 00:28:11,660
found out our difference first of all

00:28:09,140 --> 00:28:14,120
what is different is this is this symbol

00:28:11,660 --> 00:28:16,610
so we are comparing a symbol by o at

00:28:14,120 --> 00:28:18,350
page which is different while you refers

00:28:16,610 --> 00:28:21,470
occurs the difference occurs in a

00:28:18,350 --> 00:28:24,170
function called blk Max blk max eyes

00:28:21,470 --> 00:28:26,270
offset in the beginning I'll show you

00:28:24,170 --> 00:28:28,940
that this was exactly a function that

00:28:26,270 --> 00:28:31,880
contained the difference here our

00:28:28,940 --> 00:28:34,040
caustics on how to get from this symbol

00:28:31,880 --> 00:28:37,010
from the compared one to the 2d symbol

00:28:34,040 --> 00:28:39,020
to the different one in both kernels so

00:28:37,010 --> 00:28:43,390
in the first kernel this

00:28:39,020 --> 00:28:46,610
function is called at FS by OC in line

00:28:43,390 --> 00:28:47,810
816 the same function is in the second

00:28:46,610 --> 00:28:53,060
kernel called

00:28:47,810 --> 00:28:55,340
at Fayette line 818 and then follows the

00:28:53,060 --> 00:28:57,140
actual difference which you can see is

00:28:55,340 --> 00:28:59,690
exactly what we have seen at the

00:28:57,140 --> 00:29:03,220
beginning so the return value or the

00:28:59,690 --> 00:29:06,610
return expression changed here is the

00:29:03,220 --> 00:29:08,720
introduced another thing besides

00:29:06,610 --> 00:29:12,320
comparing plain functions what we see

00:29:08,720 --> 00:29:15,020
that we support is comparing sysctl

00:29:12,320 --> 00:29:22,120
options so current options that you can

00:29:15,020 --> 00:29:25,640
you can you can set on the running file

00:29:22,120 --> 00:29:27,470
again we will create a file with a list

00:29:25,640 --> 00:29:29,180
of functions or list of options now that

00:29:27,470 --> 00:29:30,530
we want to compare in this case it will

00:29:29,180 --> 00:29:34,820
be just one option which is called

00:29:30,530 --> 00:29:38,840
kernel schedule agency and s and we will

00:29:34,820 --> 00:29:42,560
save it in this control demo and we

00:29:38,840 --> 00:29:44,270
generate a snapshot so legend or a

00:29:42,560 --> 00:29:47,720
snapshot now we say that we are working

00:29:44,270 --> 00:29:50,660
with these control parameters default

00:29:47,720 --> 00:29:56,630
behavior is comparing functions yeah

00:29:50,660 --> 00:30:02,720
let's take a kernel for Linux or l76

00:29:56,630 --> 00:30:05,650
and yeah story in Tyrell seven six - is

00:30:02,720 --> 00:30:09,230
control and yeah let's specify the file

00:30:05,650 --> 00:30:12,230
good now the output is a bit more

00:30:09,230 --> 00:30:15,470
verbose because we are now comparing an

00:30:12,230 --> 00:30:19,160
option this is a kernel option that a

00:30:15,470 --> 00:30:21,710
user can specify this option can affect

00:30:19,160 --> 00:30:23,560
six functions in total the first one is

00:30:21,710 --> 00:30:26,720
a procedure handle functions which is a

00:30:23,560 --> 00:30:30,020
which is a function which is triggered

00:30:26,720 --> 00:30:32,540
once the or when this the setting of

00:30:30,020 --> 00:30:35,750
value of the setting changes and the

00:30:32,540 --> 00:30:37,580
rest five are functions that are using a

00:30:35,750 --> 00:30:40,280
data variable which is said that a

00:30:37,580 --> 00:30:43,430
variable sis controls head latency which

00:30:40,280 --> 00:30:45,460
is set to the value of the of the

00:30:43,430 --> 00:30:48,590
setting that the user sets so this is

00:30:45,460 --> 00:30:52,370
police the functions that this setting

00:30:48,590 --> 00:30:55,430
can affect in kernel for Relson sake

00:30:52,370 --> 00:31:05,030
we do the same for our l77

00:30:55,430 --> 00:31:07,220
which is us the relevant colonel we

00:31:05,030 --> 00:31:11,270
store it in a snapshot Terrell seven

00:31:07,220 --> 00:31:13,880
seven is control yes take the same file

00:31:11,270 --> 00:31:16,250
it will give us the same with the

00:31:13,880 --> 00:31:18,050
functions and now when we run compare it

00:31:16,250 --> 00:31:20,330
will compare these functions pairwise so

00:31:18,050 --> 00:31:22,580
we will compare procedure procedure

00:31:20,330 --> 00:31:25,420
handle functions then we'll go compare

00:31:22,580 --> 00:31:37,580
these two functions these two etc etc

00:31:25,420 --> 00:31:44,510
let's run the compare just quickly seven

00:31:37,580 --> 00:31:46,420
and the result will be empty which means

00:31:44,510 --> 00:31:52,550
that all of these functions are

00:31:46,420 --> 00:31:54,440
semantically equal at the end I would

00:31:52,550 --> 00:31:56,570
like to show you some of our experiments

00:31:54,440 --> 00:32:01,310
or I would like to show you that we

00:31:56,570 --> 00:32:04,610
actually ran this on whole kernels in

00:32:01,310 --> 00:32:07,670
Red Hat and these are the results so we

00:32:04,610 --> 00:32:12,910
compared versions of kernel for rail 74

00:32:07,670 --> 00:32:16,220
up to l77 we are always compared to well

00:32:12,910 --> 00:32:18,890
secretory versions and we also compared

00:32:16,220 --> 00:32:23,120
a dough with Edwin beta which is which

00:32:18,890 --> 00:32:25,550
are the new items will you can see here

00:32:23,120 --> 00:32:31,460
let's take an example of the a dough to

00:32:25,550 --> 00:32:34,940
add a 1 beta these two kernels have 471

00:32:31,460 --> 00:32:36,680
KPI symbols in common there's a list of

00:32:34,940 --> 00:32:39,590
KPI symbols that will guarantee to be

00:32:36,680 --> 00:32:42,050
stable and there's 471 of them out of

00:32:39,590 --> 00:32:45,770
these 80 percent so something around

00:32:42,050 --> 00:32:48,560
trip 380 are proved to be equal there

00:32:45,770 --> 00:32:51,590
are 67 that are different and there's

00:32:48,560 --> 00:32:54,220
some number that we still cannot decide

00:32:51,590 --> 00:32:58,130
the method that we are using is

00:32:54,220 --> 00:32:59,870
generally comparing functions for

00:32:58,130 --> 00:33:02,750
semantic equality is an undesirable

00:32:59,870 --> 00:33:05,190
problem from the computation theory

00:33:02,750 --> 00:33:07,110
point of view it's undecidable

00:33:05,190 --> 00:33:08,670
however a lot of it can be aside a lot

00:33:07,110 --> 00:33:10,560
of it can be found as you can see but

00:33:08,670 --> 00:33:12,780
still there's a number of unknown

00:33:10,560 --> 00:33:16,320
results which we are working on to to

00:33:12,780 --> 00:33:18,660
remove however out of these 767

00:33:16,320 --> 00:33:21,960
functions that are not equal course 67

00:33:18,660 --> 00:33:23,550
KB I suppose they contain 80 unique

00:33:21,960 --> 00:33:28,140
differences a unique difference means

00:33:23,550 --> 00:33:30,150
that a single KPI symbol ket can contain

00:33:28,140 --> 00:33:31,620
multiple differences it can call multi

00:33:30,150 --> 00:33:35,220
functions that are actually different

00:33:31,620 --> 00:33:37,940
and also one difference can affect

00:33:35,220 --> 00:33:41,580
multiple KPI symbols but there are 80

00:33:37,940 --> 00:33:43,950
unique differences out of which 73 occur

00:33:41,580 --> 00:33:46,260
in function seven of them occur in the

00:33:43,950 --> 00:33:48,980
macro the last column potential false

00:33:46,260 --> 00:33:52,230
positives gives the number of

00:33:48,980 --> 00:33:54,750
differences that we we reported that

00:33:52,230 --> 00:33:59,010
there is a difference however we did not

00:33:54,750 --> 00:34:01,770
find any any syntactical difference

00:33:59,010 --> 00:34:04,680
anywhere that would be related to it so

00:34:01,770 --> 00:34:07,050
we think that probably this is a false

00:34:04,680 --> 00:34:10,170
positive this is probably an error of

00:34:07,050 --> 00:34:13,200
our tool and yeah we are working on

00:34:10,170 --> 00:34:14,520
identifying dos and and removing them so

00:34:13,200 --> 00:34:18,570
as you can see it's still working

00:34:14,520 --> 00:34:21,060
progress we still have some areas where

00:34:18,570 --> 00:34:23,070
we would like to improve however there's

00:34:21,060 --> 00:34:25,830
quite a lot of things that we can

00:34:23,070 --> 00:34:27,950
already proof and quite a lot of

00:34:25,830 --> 00:34:30,990
differences that we can already find

00:34:27,950 --> 00:34:31,530
yeah that's it that's everything from my

00:34:30,990 --> 00:34:33,690
site

00:34:31,530 --> 00:34:35,100
thank you for listening if you want to

00:34:33,690 --> 00:34:38,700
write a tune

00:34:35,100 --> 00:34:43,590
feel free to foreclose whatever do with

00:34:38,700 --> 00:34:45,510
our repo if any feedback you can open

00:34:43,590 --> 00:34:48,110
issue reports you can even fix them and

00:34:45,510 --> 00:34:51,120
send PRS we'll be more than happy for

00:34:48,110 --> 00:34:53,250
better usage we are preparing an RPM

00:34:51,120 --> 00:34:55,470
package which should be ready hopefully

00:34:53,250 --> 00:34:57,330
in following weeks ok that's it thank

00:34:55,470 --> 00:35:00,230
you for the attention and if you have

00:34:57,330 --> 00:35:00,230
any questions feel free to ask

00:35:03,760 --> 00:35:12,540
oh yes the song yeah I can repeat the

00:35:10,359 --> 00:35:16,050
question if you want so the question is

00:35:12,540 --> 00:35:18,760
if this can be used for different

00:35:16,050 --> 00:35:22,200
projects than just criminal

00:35:18,760 --> 00:35:24,250
the answer is technically yes why not

00:35:22,200 --> 00:35:25,630
currently we only support Colonel

00:35:24,250 --> 00:35:28,380
because we want to use it for that so

00:35:25,630 --> 00:35:31,210
you would have to at least fright or

00:35:28,380 --> 00:35:34,630
implement the part that translates your

00:35:31,210 --> 00:35:36,930
source code into LLVM ir and then you

00:35:34,630 --> 00:35:38,500
can use our our infrastructure so

00:35:36,930 --> 00:35:40,450
technically it's all a problem

00:35:38,500 --> 00:35:43,810
technically you can compare anything

00:35:40,450 --> 00:35:46,210
that is compatible into LLVM PI R which

00:35:43,810 --> 00:35:48,820
means that it's not only see it's also

00:35:46,210 --> 00:35:51,609
C++ it's rust which is naturally

00:35:48,820 --> 00:35:56,250
compiled we just found a Joe can be

00:35:51,609 --> 00:35:59,910
compiled basically since album is quite

00:35:56,250 --> 00:36:02,830
expanding a lot I think that a lot of

00:35:59,910 --> 00:36:05,800
well there are works that compile almost

00:36:02,830 --> 00:36:07,600
every procedural language into LLVM so

00:36:05,800 --> 00:36:10,570
we are technically you can you can do

00:36:07,600 --> 00:36:14,020
that we just right now support colonel

00:36:10,570 --> 00:36:17,290
however if you had the front end to to

00:36:14,020 --> 00:36:30,210
compile your project into Olivia Meyer

00:36:17,290 --> 00:36:30,210
why not it could be used yes I guess yes

00:36:34,350 --> 00:36:48,609
sorry I formal method actually yes yeah

00:36:45,359 --> 00:36:51,070
this is all fully automatic as you've

00:36:48,609 --> 00:36:52,930
seen also if we if we plugged in the the

00:36:51,070 --> 00:36:54,940
formal methods part yes it is full of

00:36:52,930 --> 00:36:59,670
like there there is no requirement for

00:36:54,940 --> 00:36:59,670
any any and parcel

00:37:04,020 --> 00:37:09,119
I does the optimization level like mess

00:37:07,650 --> 00:37:12,480
with this at all is that something you

00:37:09,119 --> 00:37:14,910
guys have experimented with is that what

00:37:12,480 --> 00:37:16,980
level of optimization you lose in with

00:37:14,910 --> 00:37:19,590
LLVM coming out in the code that it

00:37:16,980 --> 00:37:22,380
spits out does that does that cause any

00:37:19,590 --> 00:37:30,320
problems with the diffing or like is

00:37:22,380 --> 00:37:33,480
that you understand what I'm saying yeah

00:37:30,320 --> 00:37:36,150
so even is there I guess what I'm asking

00:37:33,480 --> 00:37:41,460
is does that is any of that does that

00:37:36,150 --> 00:37:44,820
come in at the IR phase I guess I'm not

00:37:41,460 --> 00:37:47,730
quite sure how the what phase in the

00:37:44,820 --> 00:37:52,590
compile process you're coming in so so

00:37:47,730 --> 00:37:56,970
we're coming in we're on the parser we

00:37:52,590 --> 00:37:58,740
get the the a living by our and so it's

00:37:56,970 --> 00:38:02,760
a normal presentation and before running

00:37:58,740 --> 00:38:05,250
the optimizations that's where we where

00:38:02,760 --> 00:38:07,170
we get it ok so there's no there's no

00:38:05,250 --> 00:38:12,330
like optimization phase that happens

00:38:07,170 --> 00:38:14,010
just on the ir no ok we control

00:38:12,330 --> 00:38:16,859
everything or we control our

00:38:14,010 --> 00:38:19,410
optimizations by hand so we explicitly

00:38:16,859 --> 00:38:24,600
say what we want to run and we control

00:38:19,410 --> 00:38:25,890
how the how the ir is transformed okay

00:38:24,600 --> 00:38:28,290
right then we analyze it so you could

00:38:25,890 --> 00:38:33,810
turn that on if you wanted yes okay cool

00:38:28,290 --> 00:38:37,020
yeah now currently we're running no no

00:38:33,810 --> 00:38:40,130
transition only those that we we choose

00:38:37,020 --> 00:38:40,130
to run such as dead code elimination

00:38:48,190 --> 00:38:55,260
what are the what are the next steps or

00:38:50,650 --> 00:38:57,880
future plans okay so the first one is

00:38:55,260 --> 00:39:00,460
written here the RPM package we would

00:38:57,880 --> 00:39:02,559
like to the kernel developers to start

00:39:00,460 --> 00:39:04,869
using these experimenting with the tool

00:39:02,559 --> 00:39:09,579
we'll wait for the feedback so currently

00:39:04,869 --> 00:39:14,470
the the next step I would say is let's

00:39:09,579 --> 00:39:17,260
see what users what are the most known

00:39:14,470 --> 00:39:20,260
problems or what are promised that users

00:39:17,260 --> 00:39:25,930
will have try to fix those

00:39:20,260 --> 00:39:28,990
besides that we are trying to we're

00:39:25,930 --> 00:39:34,030
trying to work on few advanced stuff

00:39:28,990 --> 00:39:37,299
such as simplifying the LLVM ir so that

00:39:34,030 --> 00:39:39,880
we can run the the formal method tools

00:39:37,299 --> 00:39:43,089
easier because the former method tools

00:39:39,880 --> 00:39:45,460
limits health research tools in general

00:39:43,089 --> 00:39:48,910
they do not scale on large projects so

00:39:45,460 --> 00:39:51,599
we want to simplify the code as as much

00:39:48,910 --> 00:39:55,270
as possible so that we can maybe use

00:39:51,599 --> 00:39:56,559
these tools for for logical basis that's

00:39:55,270 --> 00:40:02,250
one of the things that we are thinking

00:39:56,559 --> 00:40:02,250
on right now so there's another question

00:40:04,770 --> 00:40:11,490
are there any plans to like install this

00:40:07,839 --> 00:40:13,059
in a continuous integration plan yeah

00:40:11,490 --> 00:40:17,260
thanks for the question

00:40:13,059 --> 00:40:23,260
good one yes there I'm discussing with

00:40:17,260 --> 00:40:26,289
guys who who ran the or who maintained

00:40:23,260 --> 00:40:30,160
the KPI list and yeah one of the

00:40:26,289 --> 00:40:33,819
possible usages is to run this in the

00:40:30,160 --> 00:40:36,309
kernel CI and to get the output back to

00:40:33,819 --> 00:40:38,289
the maintainer of of individual KPI

00:40:36,309 --> 00:40:40,240
symbols in case that something breaks

00:40:38,289 --> 00:40:42,750
between ours that there is a difference

00:40:40,240 --> 00:40:42,750
between two

00:40:50,220 --> 00:40:56,660
all right I guess that's it thank you

00:40:52,980 --> 00:40:56,660
for coming thank you for listening

00:41:03,150 --> 00:41:05,210

YouTube URL: https://www.youtube.com/watch?v=x6exbMjshVM


