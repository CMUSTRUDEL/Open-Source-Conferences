Title: Objtool: A Hidden Gem of Executable Parsing
Publication date: 2019-10-02
Playlist: DevConfUS 2019
Description: 
	Speaker: Matt Helsley

While ELF is an old standard it has enabled the development of remarkable tools and the Linux Kernel's objtool scanner is a great example of this. Objtool has evolved over time from a stack checker to enabling such kernel features as reliable, super-low overhead stack tracing, live patching, and more. Recently checks for Spectre/Meltdown mitigation and other useful checks have also been incorporated. Objtool achieves these feats by scanning the object files produced by the compiler, checking code patterns, and collecting information that the kernel uses at runtime to implement these features. We'll go into detail on how objtool does this and, finally, we'll discuss ongoing work incorporating other kernel build-time scanning tools into objtool.
Captions: 
	00:00:02,550 --> 00:00:12,480
I am Matt Helsley I work for the VMware

00:00:10,260 --> 00:00:15,270
open source Technology Center this talk

00:00:12,480 --> 00:00:17,730
is about odd tool a kernel tool that

00:00:15,270 --> 00:00:19,820
basically takes in object files produced

00:00:17,730 --> 00:00:24,410
by the compiler

00:00:19,820 --> 00:00:26,970
basically it's it works on x86 right now

00:00:24,410 --> 00:00:30,780
but it has the foundations for expanding

00:00:26,970 --> 00:00:33,360
to other architectures it does certain

00:00:30,780 --> 00:00:35,520
checks on the object files it's it

00:00:33,360 --> 00:00:37,140
checks for stack validation it checks

00:00:35,520 --> 00:00:39,600
for a certain vulnerability problems

00:00:37,140 --> 00:00:42,390
like with Specter and then more recently

00:00:39,600 --> 00:00:45,060
it's been modified to add some stack

00:00:42,390 --> 00:00:47,760
data to the kernel and that's going to

00:00:45,060 --> 00:00:49,440
be useful later one of the interesting

00:00:47,760 --> 00:00:52,649
things about the kernel is it does use

00:00:49,440 --> 00:00:55,950
the file format so it's not that

00:00:52,649 --> 00:00:58,380
different from regular executables there

00:00:55,950 --> 00:01:01,020
is some magic that the kernel does but a

00:00:58,380 --> 00:01:05,629
lot of it also relies on the elf format

00:01:01,020 --> 00:01:05,629
so it builds tables using those sections

00:01:05,780 --> 00:01:10,829
elf is the executable and linkable

00:01:08,189 --> 00:01:14,219
format it's been a standard for a long

00:01:10,829 --> 00:01:16,530
time and there are per CPU architecture

00:01:14,219 --> 00:01:18,920
additions to the standard so that it can

00:01:16,530 --> 00:01:21,539
work on multiple architectures

00:01:18,920 --> 00:01:23,219
it's found in object files the dot o

00:01:21,539 --> 00:01:23,700
files that you see when you compile a C

00:01:23,219 --> 00:01:26,520
code

00:01:23,700 --> 00:01:30,409
it's found in executables the regular

00:01:26,520 --> 00:01:30,409
programs and your share libraries

00:01:30,600 --> 00:01:34,740
it describes the actual compiled code as

00:01:32,700 --> 00:01:36,119
well as how to link it when you're when

00:01:34,740 --> 00:01:38,189
you're building the executables and then

00:01:36,119 --> 00:01:42,869
runtime linking as well the dynamic

00:01:38,189 --> 00:01:44,759
linking so objects tool what it does is

00:01:42,869 --> 00:01:47,729
it uses an external library called good

00:01:44,759 --> 00:01:50,310
elf and Lib elf is responsible for

00:01:47,729 --> 00:01:53,039
actually loading the B file into memory

00:01:50,310 --> 00:01:58,520
using a set of data structures that are

00:01:53,039 --> 00:02:01,349
defined by the standard and and what

00:01:58,520 --> 00:02:04,139
Opstal does is it takes those data

00:02:01,349 --> 00:02:06,149
structures and it takes the offsets

00:02:04,139 --> 00:02:08,940
within the file and converts them into

00:02:06,149 --> 00:02:13,050
pointer data structures that is ready to

00:02:08,940 --> 00:02:15,690
access all of these these structures

00:02:13,050 --> 00:02:18,180
and it will link things like names for

00:02:15,690 --> 00:02:20,160
the various sections into the sections

00:02:18,180 --> 00:02:22,290
it'll it'll look up the symbols and

00:02:20,160 --> 00:02:25,700
produce hash tables for them that sort

00:02:22,290 --> 00:02:27,980
of thing and then on top of that it has

00:02:25,700 --> 00:02:30,510
little flags for checking whether

00:02:27,980 --> 00:02:31,950
sections have changed whether we need to

00:02:30,510 --> 00:02:36,810
write them out to disk that sort of

00:02:31,950 --> 00:02:40,560
thing no belt itself handles the

00:02:36,810 --> 00:02:41,940
differences between 32-bit and 64-bit so

00:02:40,560 --> 00:02:43,530
you have different word sizes even on

00:02:41,940 --> 00:02:45,120
the same architecture the same

00:02:43,530 --> 00:02:47,190
architecture can also have different

00:02:45,120 --> 00:02:48,780
endianness so you can have big endian in

00:02:47,190 --> 00:02:51,750
little-endian on architectures like

00:02:48,780 --> 00:02:54,030
PowerPC and MIPS that sort of thing and

00:02:51,750 --> 00:02:55,709
what Lib elf does is it kind of

00:02:54,030 --> 00:02:58,230
normalizes all this stuff when it puts

00:02:55,709 --> 00:03:01,380
it in memory it uses some genetic more

00:02:58,230 --> 00:03:02,910
generic data structures so for for

00:03:01,380 --> 00:03:04,650
example with the different word sizes

00:03:02,910 --> 00:03:06,930
it'll take 32 bit fields and it will

00:03:04,650 --> 00:03:08,640
expand them to 64 bit and then when it's

00:03:06,930 --> 00:03:12,330
gonna put it back on disk it shrinks it

00:03:08,640 --> 00:03:16,709
back down it also uses these functions

00:03:12,330 --> 00:03:18,870
to basically attach data to the to the

00:03:16,709 --> 00:03:21,989
structures so it has some representation

00:03:18,870 --> 00:03:26,820
of what was on disk and what's going to

00:03:21,989 --> 00:03:30,030
go back so this is all nice but the

00:03:26,820 --> 00:03:31,980
problem with the the live elf output is

00:03:30,030 --> 00:03:35,730
it doesn't actually it's not easily

00:03:31,980 --> 00:03:38,130
linked together and from my case it's

00:03:35,730 --> 00:03:40,350
also got health written everywhere so it

00:03:38,130 --> 00:03:42,570
kind of gets a little repetitive and

00:03:40,350 --> 00:03:44,310
your your guys and glaze over

00:03:42,570 --> 00:03:46,440
where is up shal what it does is it

00:03:44,310 --> 00:03:48,360
defines its own data structures uses a

00:03:46,440 --> 00:03:51,989
lot of the similar kernel patterns that

00:03:48,360 --> 00:03:53,340
you might be familiar with and then kind

00:03:51,989 --> 00:03:55,560
of links everything everything together

00:03:53,340 --> 00:03:58,470
so you can easily walk over say the

00:03:55,560 --> 00:04:00,239
sections using using a linked list or

00:03:58,470 --> 00:04:03,360
you can use look up certain temples

00:04:00,239 --> 00:04:09,090
using the santur kernel hash tables that

00:04:03,360 --> 00:04:10,830
sort of thing so what our school sees is

00:04:09,090 --> 00:04:12,840
it sees these object files that come in

00:04:10,830 --> 00:04:14,910
during the kernel build process this is

00:04:12,840 --> 00:04:17,669
before the object files get linked into

00:04:14,910 --> 00:04:19,919
the final kernel so it doesn't have

00:04:17,669 --> 00:04:23,640
things like program header tables that

00:04:19,919 --> 00:04:25,690
sort of thing it's also mainly looking

00:04:23,640 --> 00:04:28,420
at the instructions that

00:04:25,690 --> 00:04:30,880
present in the in the object file and

00:04:28,420 --> 00:04:32,530
this is part of the checking process and

00:04:30,880 --> 00:04:35,200
this is one of the reasons it's specific

00:04:32,530 --> 00:04:38,190
to x86 right now it has code for

00:04:35,200 --> 00:04:42,850
decoding x86 instructions and

00:04:38,190 --> 00:04:44,950
specifically looking at the the way that

00:04:42,850 --> 00:04:50,140
the x86 manages or doesn't manage the

00:04:44,950 --> 00:04:51,310
stack pointer or warframe player so

00:04:50,140 --> 00:04:54,100
informally I'm just gonna call these

00:04:51,310 --> 00:04:59,410
instructions assembly or machine

00:04:54,100 --> 00:05:01,720
instructions so the other thing that

00:04:59,410 --> 00:05:04,690
obsolesce to deal with is it deals with

00:05:01,720 --> 00:05:06,870
not only the compiler output but since

00:05:04,690 --> 00:05:09,790
kernel developers write assembly on a

00:05:06,870 --> 00:05:11,350
fairly regular basis or at least deal

00:05:09,790 --> 00:05:12,820
with assembly on a fairly regular basis

00:05:11,350 --> 00:05:15,640
has to deal with handwritten assembly

00:05:12,820 --> 00:05:16,870
too and this this can make things a

00:05:15,640 --> 00:05:21,490
little more difficult but at the same

00:05:16,870 --> 00:05:24,100
time it adds it it's a little easier to

00:05:21,490 --> 00:05:27,820
follow a human written sequence of

00:05:24,100 --> 00:05:29,440
assembly instructions the other problem

00:05:27,820 --> 00:05:31,600
with it with that though is the fact

00:05:29,440 --> 00:05:33,940
that a lot of things a lot of times the

00:05:31,600 --> 00:05:36,190
human won't really necessarily add in

00:05:33,940 --> 00:05:38,650
frame pointers for example or they might

00:05:36,190 --> 00:05:40,840
forget some aspect of the assembly code

00:05:38,650 --> 00:05:43,990
that they need to follow for the kernel

00:05:40,840 --> 00:05:46,150
to be to be secure so our school has an

00:05:43,990 --> 00:05:49,210
opportunity to recognize that and remind

00:05:46,150 --> 00:05:50,800
people hey you need to do this it

00:05:49,210 --> 00:05:51,880
started out as a stack validator it

00:05:50,800 --> 00:05:54,460
would go through and it would look

00:05:51,880 --> 00:05:57,760
through the sequence of instructions and

00:05:54,460 --> 00:06:00,190
follow how the stack pointer changed and

00:05:57,760 --> 00:06:02,410
whether or not the back pointer was

00:06:00,190 --> 00:06:03,820
updated according to those changes and

00:06:02,410 --> 00:06:05,830
it could actually worn either oh hey

00:06:03,820 --> 00:06:07,990
like you're writing this assembly you

00:06:05,830 --> 00:06:11,050
you didn't actually add the back corner

00:06:07,990 --> 00:06:12,669
here and those are for config frame

00:06:11,050 --> 00:06:16,000
cleaner builds but at the same time

00:06:12,669 --> 00:06:17,680
those builds cost some performance and

00:06:16,000 --> 00:06:19,620
so a lot of times people build the

00:06:17,680 --> 00:06:22,830
kernel without those string cleaners and

00:06:19,620 --> 00:06:25,530
so that gets into more of the other

00:06:22,830 --> 00:06:27,730
aspects of actual what it's used for but

00:06:25,530 --> 00:06:30,880
the other thing it does is it does some

00:06:27,730 --> 00:06:32,620
specter checks so a lot of the speculate

00:06:30,880 --> 00:06:37,180
speculative execution problems that

00:06:32,620 --> 00:06:38,160
you've seen recently last few years it

00:06:37,180 --> 00:06:40,410
will actually check for

00:06:38,160 --> 00:06:43,740
in certain patterns and say okay well

00:06:40,410 --> 00:06:46,490
this is this is a problem and here's and

00:06:43,740 --> 00:06:49,290
you'll be able to go in there and fix it

00:06:46,490 --> 00:06:51,210
it also does some some uaccess checking

00:06:49,290 --> 00:06:52,620
so that's when you've got code that

00:06:51,210 --> 00:06:57,150
accesses user space you want to make

00:06:52,620 --> 00:06:58,830
sure that it's very limited in where the

00:06:57,150 --> 00:07:00,810
kernel can access the user space from

00:06:58,830 --> 00:07:03,000
and this will actually check for

00:07:00,810 --> 00:07:05,610
transitions in and out of those those

00:07:03,000 --> 00:07:07,200
sections and find when you might be

00:07:05,610 --> 00:07:12,930
trying to access user space when you

00:07:07,200 --> 00:07:15,360
shouldn't so a writer with the Luther

00:07:12,930 --> 00:07:17,910
Specter stuff this is in direct branches

00:07:15,360 --> 00:07:20,910
causing problems where you've got

00:07:17,910 --> 00:07:23,040
speculative execution and an attacker

00:07:20,910 --> 00:07:26,520
can can actually control the way that

00:07:23,040 --> 00:07:28,770
the processor goes in terms of guessing

00:07:26,520 --> 00:07:30,570
where where you've got a branch at which

00:07:28,770 --> 00:07:32,790
direction it's going to go and then it

00:07:30,570 --> 00:07:36,030
can observe what happens look at the

00:07:32,790 --> 00:07:39,150
timing of what happened and kind of

00:07:36,030 --> 00:07:43,050
determine the value of of the branch

00:07:39,150 --> 00:07:50,990
like those sorts of and so what this

00:07:43,050 --> 00:07:50,990
does is it's let's see

00:07:54,389 --> 00:08:01,539
so basically what the attacker can do is

00:07:57,849 --> 00:08:04,509
they will adjust they will run some code

00:08:01,539 --> 00:08:07,119
that will fill the I think it's the the

00:08:04,509 --> 00:08:09,459
branch history buffer and the idea is

00:08:07,119 --> 00:08:11,589
that it the processor will then look at

00:08:09,459 --> 00:08:15,699
this branch PC bus buffer to anticipate

00:08:11,589 --> 00:08:17,829
where it should go and you want to be

00:08:15,699 --> 00:08:19,839
able to prevent the processor from

00:08:17,829 --> 00:08:22,209
actually using those heuristics you want

00:08:19,839 --> 00:08:23,529
it to use a heuristic that can it's not

00:08:22,209 --> 00:08:25,689
really vulnerable to these kinds of

00:08:23,529 --> 00:08:28,749
attacks and so the solution is a read

00:08:25,689 --> 00:08:31,539
rapidly and this one is sort of like

00:08:28,749 --> 00:08:34,180
where you you set the return address but

00:08:31,539 --> 00:08:35,649
in the return address is actually the

00:08:34,180 --> 00:08:39,789
place that you want to jump to either

00:08:35,649 --> 00:08:43,059
for a call or an actual jump and the way

00:08:39,789 --> 00:08:46,240
it works is you basically have a setup

00:08:43,059 --> 00:08:48,930
section that calls a function that then

00:08:46,240 --> 00:08:50,709
takes and puts the return address

00:08:48,930 --> 00:08:53,500
replaces the return address with the

00:08:50,709 --> 00:08:56,589
address you want to go to and just after

00:08:53,500 --> 00:08:58,809
that call is normally where any same

00:08:56,589 --> 00:09:00,309
processor decides that this is the most

00:08:58,809 --> 00:09:01,779
likely place you're going to return to

00:09:00,309 --> 00:09:03,430
and therefore it doesn't actually look

00:09:01,779 --> 00:09:04,930
at the branch history

00:09:03,430 --> 00:09:06,879
it just says okay well you're gonna come

00:09:04,930 --> 00:09:09,850
here next so I have no problems and so

00:09:06,879 --> 00:09:12,819
it'll go through and anticipate

00:09:09,850 --> 00:09:15,279
executing that infinite loop it won't

00:09:12,819 --> 00:09:17,529
actually do anything that's driven by

00:09:15,279 --> 00:09:20,170
the attacker and so this is this is how

00:09:17,529 --> 00:09:23,259
you fix those are up liens but the how

00:09:20,170 --> 00:09:24,579
you fix the vulnerability but there are

00:09:23,259 --> 00:09:26,410
some there's some pitfalls like

00:09:24,579 --> 00:09:29,410
especially in handwritten assembly if

00:09:26,410 --> 00:09:31,899
you hand code this might actually fall

00:09:29,410 --> 00:09:34,059
into that infinite loop and so there are

00:09:31,899 --> 00:09:35,379
some checks that obstacle does two to

00:09:34,059 --> 00:09:38,559
verify that you haven't done those

00:09:35,379 --> 00:09:40,170
things it will actually look at the the

00:09:38,559 --> 00:09:42,459
branches do you're making and say okay

00:09:40,170 --> 00:09:45,670
you're making some indirect calls here

00:09:42,459 --> 00:09:49,209
and I don't see this clean sequence

00:09:45,670 --> 00:09:50,709
after it it will ignore certain sections

00:09:49,209 --> 00:09:54,279
because there are some small sections of

00:09:50,709 --> 00:09:55,389
kernel code that they actually do use

00:09:54,279 --> 00:09:58,180
indirect branches that have been

00:09:55,389 --> 00:10:00,160
reviewed at safe and they're also

00:09:58,180 --> 00:10:02,819
annotations for those sections that it

00:10:00,160 --> 00:10:02,819
knows to ignore

00:10:02,850 --> 00:10:09,749
and let's see so there is an excellent

00:10:05,879 --> 00:10:13,249
write up by Google about Specter so I

00:10:09,749 --> 00:10:13,249
definitely recommend checking that out

00:10:16,129 --> 00:10:21,869
so the other thing that optional does is

00:10:19,709 --> 00:10:23,279
it helps to stack traversal so when

00:10:21,869 --> 00:10:25,019
you're doing a SAP traversal you're

00:10:23,279 --> 00:10:27,199
generally trying to provide some

00:10:25,019 --> 00:10:31,850
debugging information to the to the user

00:10:27,199 --> 00:10:34,439
or the kernel developer most likely and

00:10:31,850 --> 00:10:36,839
you want to be able to see the sequence

00:10:34,439 --> 00:10:39,689
of function calls on the stack what

00:10:36,839 --> 00:10:41,999
happens is the the assembly code will

00:10:39,689 --> 00:10:44,489
adjust the stack pointer it will set up

00:10:41,999 --> 00:10:46,589
call frame I mean and that call frame

00:10:44,489 --> 00:10:49,079
might include the the frame pointer

00:10:46,589 --> 00:10:51,389
going back to the previous frame but it

00:10:49,079 --> 00:10:53,069
might not because of because you as I

00:10:51,389 --> 00:10:55,229
went over earlier the human writer

00:10:53,069 --> 00:10:56,789
forgotten it or the compiler may have

00:10:55,229 --> 00:10:59,339
omitted it in order to get some

00:10:56,789 --> 00:11:00,600
additional performance so we want

00:10:59,339 --> 00:11:02,609
something that's going to be able to

00:11:00,600 --> 00:11:05,939
replace all that it's got to be more

00:11:02,609 --> 00:11:08,579
reliable and it has to have no overhead

00:11:05,939 --> 00:11:12,929
as you're normally executing the

00:11:08,579 --> 00:11:15,569
function calls so we want that we want

00:11:12,929 --> 00:11:19,169
to avoid adjusting setting up the frame

00:11:15,569 --> 00:11:20,899
pointer if possible yeah also there's a

00:11:19,169 --> 00:11:23,399
there's kind of a race here between

00:11:20,899 --> 00:11:26,609
interrupts and exceptions and and these

00:11:23,399 --> 00:11:29,759
stack frames where you could in between

00:11:26,609 --> 00:11:31,259
you know pushing something onto the

00:11:29,759 --> 00:11:32,939
stack or adjusting the stack pointer you

00:11:31,259 --> 00:11:34,559
may not have there's gonna be there's

00:11:32,939 --> 00:11:37,559
gonna be a tiny window where you haven't

00:11:34,559 --> 00:11:39,899
adjusted the frame pointer in the stack

00:11:37,559 --> 00:11:41,879
frame and then you can get an exception

00:11:39,899 --> 00:11:44,189
then so you can't necessarily rely on it

00:11:41,879 --> 00:11:51,359
even then and that's one of the great

00:11:44,189 --> 00:11:53,489
things about what Opstal does so one of

00:11:51,359 --> 00:11:55,649
so what this shows up as you'll actually

00:11:53,489 --> 00:11:58,470
miss function calls in the stack you'll

00:11:55,649 --> 00:12:00,689
see a call and it'll actually go back to

00:11:58,470 --> 00:12:02,549
the previous function not the actual

00:12:00,689 --> 00:12:04,499
color so sometimes you'll see these

00:12:02,549 --> 00:12:07,199
strange transitions in the stack face

00:12:04,499 --> 00:12:08,640
and you have to understand that okay

00:12:07,199 --> 00:12:11,220
well the assembly function

00:12:08,640 --> 00:12:14,579
it admitted this this particular on a

00:12:11,220 --> 00:12:18,089
back pointer and that makes things

00:12:14,579 --> 00:12:20,100
challenging so now we have a August tool

00:12:18,089 --> 00:12:25,110
that introduces this this work format

00:12:20,100 --> 00:12:27,720
and what work does is it it takes and

00:12:25,110 --> 00:12:29,519
looks at the instruction pointer the

00:12:27,720 --> 00:12:32,970
state of the stack at each instruction

00:12:29,519 --> 00:12:35,940
pointer value and then it looks for the

00:12:32,970 --> 00:12:38,760
transitions and it builds a table that's

00:12:35,940 --> 00:12:41,370
that's outside of the the regular

00:12:38,760 --> 00:12:43,740
instruction flow and this table goes

00:12:41,370 --> 00:12:46,740
into an elf section and the table is

00:12:43,740 --> 00:12:49,290
indexed by the instruction player so

00:12:46,740 --> 00:12:51,120
based off of only the instruction

00:12:49,290 --> 00:12:53,940
pointer and the current stack pointer

00:12:51,120 --> 00:12:56,970
you can actually find the back-trace

00:12:53,940 --> 00:13:00,079
without having to have the the stack or

00:12:56,970 --> 00:13:03,089
the frame pointer in the stack frames

00:13:00,079 --> 00:13:04,410
what it does is it looks at okay for

00:13:03,089 --> 00:13:06,269
this instruction pointer here's the

00:13:04,410 --> 00:13:07,649
offset from the stack pointer to the

00:13:06,269 --> 00:13:09,690
beginning of the frame and then from

00:13:07,649 --> 00:13:10,740
there you can get the next or the

00:13:09,690 --> 00:13:15,949
instruction pointer you're going to

00:13:10,740 --> 00:13:15,949
return to and so on so

00:13:22,940 --> 00:13:27,660
the kernel of the kernel itself consumes

00:13:25,410 --> 00:13:30,870
this this it's it's one of those cases

00:13:27,660 --> 00:13:32,699
where the it's useful for the kernel

00:13:30,870 --> 00:13:36,180
itself to be able to consume it so it

00:13:32,699 --> 00:13:37,949
has has some pointers that point to the

00:13:36,180 --> 00:13:40,139
section where the section has been

00:13:37,949 --> 00:13:41,430
loaded and then it can actually go

00:13:40,139 --> 00:13:44,040
through and one of the first things it

00:13:41,430 --> 00:13:45,449
does is it actually sorts the entry by

00:13:44,040 --> 00:13:48,509
the instruction player because you can't

00:13:45,449 --> 00:13:51,029
guarantee that the instruction that the

00:13:48,509 --> 00:13:52,709
entries are sorted initially this is one

00:13:51,029 --> 00:13:55,500
of the thoroughly but-- it'll go through

00:13:52,709 --> 00:13:57,300
and sort that and then it will actually

00:13:55,500 --> 00:13:58,920
be able to search the table based off in

00:13:57,300 --> 00:14:00,660
the instruction pointer so if you have

00:13:58,920 --> 00:14:02,459
one kernel thread for example that wants

00:14:00,660 --> 00:14:04,920
to know but another kernel thread is

00:14:02,459 --> 00:14:07,709
doing this one this one can kind of look

00:14:04,920 --> 00:14:09,120
at the other ones stack and it can

00:14:07,709 --> 00:14:10,610
follow it without having to worry about

00:14:09,120 --> 00:14:14,250
okay well are the frame pointers

00:14:10,610 --> 00:14:18,259
perfectly set up or not so that's useful

00:14:14,250 --> 00:14:25,730
for a couple a couple things

00:14:18,259 --> 00:14:29,910
the see here so one of the things that

00:14:25,730 --> 00:14:32,399
so does the test sack traversal okay so

00:14:29,910 --> 00:14:33,779
I I mentioned that it is source the

00:14:32,399 --> 00:14:36,810
table and then when you're actually

00:14:33,779 --> 00:14:37,889
trying to do the stack traversal it's it

00:14:36,810 --> 00:14:40,110
looks at the current instruction pointer

00:14:37,889 --> 00:14:42,630
the current stack pointer both of which

00:14:40,110 --> 00:14:46,139
have to be maintained there they're

00:14:42,630 --> 00:14:48,480
always correct it determines where that

00:14:46,139 --> 00:14:51,779
stack frame is look looking through the

00:14:48,480 --> 00:14:54,630
table finding the offset and then it

00:14:51,779 --> 00:14:56,430
takes the instruction pointer and again

00:14:54,630 --> 00:14:59,880
goes back to the previous frame and so

00:14:56,430 --> 00:15:01,519
on so there's no need to keep frame

00:14:59,880 --> 00:15:04,800
pointers you get to save all of those

00:15:01,519 --> 00:15:07,709
all of those instructions and adjust the

00:15:04,800 --> 00:15:09,540
stack frame during regular run time but

00:15:07,709 --> 00:15:12,779
there is a cost to work and that is that

00:15:09,540 --> 00:15:14,699
you have a big table essentially that

00:15:12,779 --> 00:15:17,880
this kind of off to the side it's not

00:15:14,699 --> 00:15:20,130
typically loaded in cash so it doesn't

00:15:17,880 --> 00:15:23,430
have a proper product and impact on the

00:15:20,130 --> 00:15:25,949
registers at runtime but it is a big

00:15:23,430 --> 00:15:27,660
table and Mary and I think the numbers

00:15:25,949 --> 00:15:30,990
that I saw were typically like a two

00:15:27,660 --> 00:15:31,529
megabytes to eight megabyte table is

00:15:30,990 --> 00:15:35,519
that this is

00:15:31,529 --> 00:15:37,050
actually it's it's big for you know

00:15:35,519 --> 00:15:39,540
compared to using frame fighters but at

00:15:37,050 --> 00:15:41,459
the same time it's much smaller than the

00:15:39,540 --> 00:15:45,600
dwarf information the dwarf information

00:15:41,459 --> 00:15:47,999
for the kernel is huge so it's it's a

00:15:45,600 --> 00:15:53,519
little nicer in that respect that you

00:15:47,999 --> 00:15:54,959
also still have a bigger kernel and one

00:15:53,519 --> 00:15:57,180
of the things that work helps with is

00:15:54,959 --> 00:16:00,029
because you have these reliable stacked

00:15:57,180 --> 00:16:02,009
phases now you can do things like look

00:16:00,029 --> 00:16:04,410
into what another kernel thread is doing

00:16:02,009 --> 00:16:06,839
a task process you know those things and

00:16:04,410 --> 00:16:09,290
figure out ok well it's currently

00:16:06,839 --> 00:16:13,620
executing these kernel functions and

00:16:09,290 --> 00:16:14,999
during a during live patching we can

00:16:13,620 --> 00:16:16,529
actually say okay well it's not

00:16:14,999 --> 00:16:19,370
executing any of the function that I'm

00:16:16,529 --> 00:16:22,559
patching right now and so I can actually

00:16:19,370 --> 00:16:25,800
patch that function for that that task

00:16:22,559 --> 00:16:27,059
without worrying about it either one

00:16:25,800 --> 00:16:34,019
stepping right other's toes

00:16:27,059 --> 00:16:39,629
so let's see so it helps with life

00:16:34,019 --> 00:16:42,899
patching and the main the main thing is

00:16:39,629 --> 00:16:44,519
you want to avoid use patching pieces

00:16:42,899 --> 00:16:45,439
that are being used by current currently

00:16:44,519 --> 00:16:48,959
running processes

00:16:45,439 --> 00:16:52,110
the other aspect of life patching is it

00:16:48,959 --> 00:16:54,839
can run without orc but it it's less

00:16:52,110 --> 00:16:56,279
reliable in itself so it'll wait for our

00:16:54,839 --> 00:16:57,870
user space to go all the way back out of

00:16:56,279 --> 00:17:00,660
the kernel and then it can actually

00:16:57,870 --> 00:17:02,970
patch the functions that user space was

00:17:00,660 --> 00:17:04,890
using the problem is you can have

00:17:02,970 --> 00:17:06,990
multiple processes coming in out of the

00:17:04,890 --> 00:17:11,299
kernel and so there's a chance that the

00:17:06,990 --> 00:17:13,380
functions are always in use or it might

00:17:11,299 --> 00:17:15,149
always seem to be in use because you

00:17:13,380 --> 00:17:16,289
can't look at the stack reliably but

00:17:15,149 --> 00:17:17,549
once you can't look at the stack

00:17:16,289 --> 00:17:20,780
reliability you're much more likely to

00:17:17,549 --> 00:17:20,780
be able to patch the functions out

00:17:21,510 --> 00:17:29,690
so there are some more more checks being

00:17:25,439 --> 00:17:33,120
considered on LK bill I saw one recently

00:17:29,690 --> 00:17:34,350
in there you know there are some other

00:17:33,120 --> 00:17:36,840
things that I'm actually working on

00:17:34,350 --> 00:17:38,850
where I'm trying to incorporate a tool

00:17:36,840 --> 00:17:41,990
called record mm Inc to up school and

00:17:38,850 --> 00:17:46,350
what that does is that one looks at the

00:17:41,990 --> 00:17:47,880
function entry tracing so you have yeah

00:17:46,350 --> 00:17:49,620
the standard compiler tools will

00:17:47,880 --> 00:17:53,790
generate a function call at the very

00:17:49,620 --> 00:17:57,240
beginning of each function and in order

00:17:53,790 --> 00:18:02,220
to help you do profile generation and

00:17:57,240 --> 00:18:03,750
develop a call graph and so look what

00:18:02,220 --> 00:18:05,540
record and count does is it goes and

00:18:03,750 --> 00:18:07,799
turns all those calls and tin dough ops

00:18:05,540 --> 00:18:09,780
and of course the locations of those

00:18:07,799 --> 00:18:12,419
calls so that later on we can do dynamic

00:18:09,780 --> 00:18:14,370
tracing where you can enable tracing of

00:18:12,419 --> 00:18:15,809
certain functions within the kernel at

00:18:14,370 --> 00:18:18,270
runtime and you don't have to worry

00:18:15,809 --> 00:18:22,610
about constantly having that overhead of

00:18:18,270 --> 00:18:26,760
having the B call graph being recorded

00:18:22,610 --> 00:18:28,919
and that's what recording count does but

00:18:26,760 --> 00:18:31,110
it's not currently incorporated and

00:18:28,919 --> 00:18:33,240
powerful it's it's its own elf parser

00:18:31,110 --> 00:18:36,299
that has its own structures it has some

00:18:33,240 --> 00:18:38,280
very weird patterns there that aren't

00:18:36,299 --> 00:18:40,049
really easy to understand unless you

00:18:38,280 --> 00:18:42,030
really stare at the code for a long time

00:18:40,049 --> 00:18:45,059
and so I'm trying to incorporate it into

00:18:42,030 --> 00:18:47,790
obstacles and use use out tools better

00:18:45,059 --> 00:18:49,770
elf interfaces that are their standard

00:18:47,790 --> 00:18:51,809
kernel patterns that to kind of make it

00:18:49,770 --> 00:18:56,190
easier to understand and more

00:18:51,809 --> 00:18:57,510
maintainable and the one thing about the

00:18:56,190 --> 00:19:00,870
core team count those presents some

00:18:57,510 --> 00:19:02,340
problems is it's a little more widely

00:19:00,870 --> 00:19:04,440
supported on multiple architectures

00:19:02,340 --> 00:19:06,240
where it's optional right now is x86

00:19:04,440 --> 00:19:08,370
specifics so that's one of the things

00:19:06,240 --> 00:19:10,799
I'm working on testing and making sure

00:19:08,370 --> 00:19:14,100
that I can build ops tools for other

00:19:10,799 --> 00:19:15,570
architectures the other the other things

00:19:14,100 --> 00:19:17,610
that might be in the future

00:19:15,570 --> 00:19:19,830
replacing sort X table which is very

00:19:17,610 --> 00:19:21,390
similar to record and count it goes

00:19:19,830 --> 00:19:23,070
through and looks at the exception

00:19:21,390 --> 00:19:25,890
entries for the kernel and then it sorts

00:19:23,070 --> 00:19:28,500
of those and then there's also one

00:19:25,890 --> 00:19:30,140
called generate Kasem's which walks

00:19:28,500 --> 00:19:32,090
through the kernel table and

00:19:30,140 --> 00:19:37,070
the symbol names and it makes those

00:19:32,090 --> 00:19:39,320
available to the colonel too so those of

00:19:37,070 --> 00:19:41,420
those calls sort of be incorporated into

00:19:39,320 --> 00:19:44,900
our tool as different little commits

00:19:41,420 --> 00:19:46,670
subcommands al has a check set of

00:19:44,900 --> 00:19:48,530
command for example and it generates of

00:19:46,670 --> 00:19:52,490
command for the checking and generate

00:19:48,530 --> 00:19:54,590
report data respectively and then one of

00:19:52,490 --> 00:19:56,030
the things that we can do the other that

00:19:54,590 --> 00:19:57,440
I think we can do is you can also have

00:19:56,030 --> 00:19:59,540
it so that you only have to run how much

00:19:57,440 --> 00:20:01,820
to once to do all those passes so you

00:19:59,540 --> 00:20:04,730
could do a check pass a generate pass

00:20:01,820 --> 00:20:08,240
and then and then make the tracing tool

00:20:04,730 --> 00:20:10,460
pass as well and so you would only have

00:20:08,240 --> 00:20:12,650
to load the elevator once you could

00:20:10,460 --> 00:20:14,960
process the whole file with different

00:20:12,650 --> 00:20:23,150
passes and then return the queries right

00:20:14,960 --> 00:20:25,450
now you reload elf file does anybody

00:20:23,150 --> 00:20:25,450
have any questions

00:20:29,600 --> 00:20:34,040
it's part of what FJ seizes yeah so it's

00:20:32,120 --> 00:20:35,960
it's building the tables inside the

00:20:34,040 --> 00:20:38,240
kernel the F Tracy's it's kind of like

00:20:35,960 --> 00:20:40,690
the way that that actual builds or

00:20:38,240 --> 00:20:47,630
tables record unkindest kind of the

00:20:40,690 --> 00:20:49,900
corresponding part for trace any other

00:20:47,630 --> 00:20:49,900
questions

00:20:54,980 --> 00:20:58,100

YouTube URL: https://www.youtube.com/watch?v=I7srCw-Ns7Y


