Title: Prophet: On holistic analysis of microservice applications - DevConf.CZ 2021
Publication date: 2021-03-19
Playlist: DevConfCZ 2021
Description: 
	Speakers: Tomas Cerny; Andrew Walker; Dipta Das; Vincent Bushong; Michael Coffey


Moderator: Langdon White


Since the modern trend of application development moves towards the cloud, microservices, and containers, the conventional code-centric analysis tools are becoming obsolete. Thus, we need to realign analysis tools to address the specifics of modern distributed web applications. We introduce Prophet for a holistic analysis of enterprise microservice apps, which utilizes code analysis. Each microservice module is analyzed separately, but the outcomes are combined in the context of other system modules. In particular, we construct a context map (canonical model) from microservice bounded contexts and extract module interaction to understand the overall system detail and resolve the systems' inner dependencies. With this module "fusion" we can treat the system holistically to perform various analytical tasks. Our current experimentation shows confidence with Java and Python projects, utilizing both source code or bytecode, which opens the path for integration into any phase of software development life-cycle or even to deployment management systems Kubernetes to serve DevOps and SysOps.

With the infrastructure we have developed so far, we could respond with automation to recently identified microservice bad smells (bad design practice) and recognize 11 different patterns apparent in the distributed settings. Besides, we can automate Software Architecture Reconstruction (SAR), which is often attempted manually via reverse engineering process. SAR derives a representation of software architecture from artifacts like documentation or source code. The ability to see the system as a whole is essential since SAR is key to architecture verification, conformance checking, and trade-off analysis. Additionally, we manage to assess inconsistencies and errors in Role-based Access Control (RBAC) applied to microservice apps through Java EE Security API Specification (JSR 375) or Spring Security. Specifically in this field, Gartner reposts critical infrastructural gaps and challenges. With Prophet, we face new challenges that emerged in current design trends.


Schedule: https://sched.co/gmPg
Captions: 
	00:00:01,680 --> 00:00:06,080
hi everybody

00:00:03,600 --> 00:00:07,680
uh i'm langdon white and uh welcome to

00:00:06,080 --> 00:00:10,320
uh devconf cz

00:00:07,680 --> 00:00:11,759
uh if uh if you just came for me that's

00:00:10,320 --> 00:00:13,360
cool i really appreciate it

00:00:11,759 --> 00:00:16,160
but i really really hope you've been

00:00:13,360 --> 00:00:17,520
attending the other sessions uh i'm sure

00:00:16,160 --> 00:00:18,880
you know whatever you attended was great

00:00:17,520 --> 00:00:20,000
i know the things that i went to have

00:00:18,880 --> 00:00:23,199
been really awesome

00:00:20,000 --> 00:00:24,880
uh we're here to talk about uh some

00:00:23,199 --> 00:00:26,240
research work that some students have

00:00:24,880 --> 00:00:29,199
been doing

00:00:26,240 --> 00:00:31,359
and it's a particular sorry it's a

00:00:29,199 --> 00:00:33,200
little project called profit

00:00:31,359 --> 00:00:35,680
and what it's about is uh trying to

00:00:33,200 --> 00:00:38,239
analyze microservice applications

00:00:35,680 --> 00:00:39,360
uh we have a bunch of speakers as part

00:00:38,239 --> 00:00:40,879
of this keynote

00:00:39,360 --> 00:00:42,640
but we're going to lead off with the

00:00:40,879 --> 00:00:43,280
kind of the professor who's behind the

00:00:42,640 --> 00:00:46,480
project

00:00:43,280 --> 00:00:47,039
uh professor uh tomas cherny and uh he's

00:00:46,480 --> 00:00:50,160
gonna come

00:00:47,039 --> 00:00:52,559
on and introduce the uh

00:00:50,160 --> 00:00:54,480
project and then we'll introduce all the

00:00:52,559 --> 00:00:59,039
people who are speaking kind of as we go

00:00:54,480 --> 00:01:02,239
uh so uh dr cherny do you to uh

00:00:59,039 --> 00:01:05,519
share your screen or share your video

00:01:02,239 --> 00:01:07,119
hello everyone and greetings so i'm

00:01:05,519 --> 00:01:08,560
gonna tell you something about a project

00:01:07,119 --> 00:01:10,840
that we are involved in so

00:01:08,560 --> 00:01:12,159
we could come to the next slide like

00:01:10,840 --> 00:01:14,799
that

00:01:12,159 --> 00:01:17,040
okay let's be and uh now about a project

00:01:14,799 --> 00:01:18,479
so i believe that most of you are here

00:01:17,040 --> 00:01:20,159
today because

00:01:18,479 --> 00:01:22,159
we shared the same passion about

00:01:20,159 --> 00:01:25,439
microservices and we like to

00:01:22,159 --> 00:01:27,759
develop microservices so what we can

00:01:25,439 --> 00:01:29,280
typically do with microservices is

00:01:27,759 --> 00:01:31,280
nicely divide the team

00:01:29,280 --> 00:01:32,799
so that someone is developing one micro

00:01:31,280 --> 00:01:34,000
service and everything is developing

00:01:32,799 --> 00:01:36,320
another microservice

00:01:34,000 --> 00:01:37,920
and so on why we do that well because

00:01:36,320 --> 00:01:38,320
this is the mainstream direction these

00:01:37,920 --> 00:01:39,840
days

00:01:38,320 --> 00:01:41,920
right so what do we know about

00:01:39,840 --> 00:01:44,960
microservices they are self-contained

00:01:41,920 --> 00:01:48,240
and we can deploy them anytime we want

00:01:44,960 --> 00:01:50,799
well this has many benefits but it could

00:01:48,240 --> 00:01:53,119
lead into some sort of issues especially

00:01:50,799 --> 00:01:55,680
when we have multiple micro services

00:01:53,119 --> 00:01:56,159
so what could what would happen here

00:01:55,680 --> 00:01:58,640
well

00:01:56,159 --> 00:02:00,799
i like to talk about it like a black box

00:01:58,640 --> 00:02:02,479
to you versus a while box view

00:02:00,799 --> 00:02:04,079
so if you are the developer of a

00:02:02,479 --> 00:02:05,759
particular module you of course know

00:02:04,079 --> 00:02:08,000
everything about your module

00:02:05,759 --> 00:02:09,599
but if you are talking to the team that

00:02:08,000 --> 00:02:11,280
is developing some module

00:02:09,599 --> 00:02:13,120
that you are interacting with you don't

00:02:11,280 --> 00:02:15,120
know much about it so you can see it as

00:02:13,120 --> 00:02:18,000
a black box right

00:02:15,120 --> 00:02:18,720
and the sort of same situation is

00:02:18,000 --> 00:02:21,840
happening

00:02:18,720 --> 00:02:22,800
when you pass off your micro service to

00:02:21,840 --> 00:02:24,319
the sysops

00:02:22,800 --> 00:02:25,920
and they're deploying it they know

00:02:24,319 --> 00:02:27,599
everything about the deployment they

00:02:25,920 --> 00:02:29,760
know everything about the platform but

00:02:27,599 --> 00:02:30,800
they don't know that much about the

00:02:29,760 --> 00:02:32,640
specifics

00:02:30,800 --> 00:02:34,000
and specific aspects of your

00:02:32,640 --> 00:02:36,720
microservices

00:02:34,000 --> 00:02:38,160
so there are times where we would like

00:02:36,720 --> 00:02:40,800
to have the holistic view

00:02:38,160 --> 00:02:42,160
however microservices do not provide us

00:02:40,800 --> 00:02:45,440
with the holistic view

00:02:42,160 --> 00:02:45,440
so next slide please london

00:02:45,920 --> 00:02:51,120
and naturally the question comes how can

00:02:48,959 --> 00:02:52,800
we get the holistic picture of the

00:02:51,120 --> 00:02:55,040
overall distributed system

00:02:52,800 --> 00:02:57,280
so there is something that is called

00:02:55,040 --> 00:02:59,280
software architecture reconstruction

00:02:57,280 --> 00:03:00,720
and as you can see this is sort of a

00:02:59,280 --> 00:03:03,200
process where we want to

00:03:00,720 --> 00:03:05,360
build from this whole distributed cloud

00:03:03,200 --> 00:03:07,200
the holistic picture of what's going on

00:03:05,360 --> 00:03:08,560
well we could do that manually and this

00:03:07,200 --> 00:03:11,200
is how it's most

00:03:08,560 --> 00:03:12,800
done most of the time these days but

00:03:11,200 --> 00:03:15,599
what if we would like to

00:03:12,800 --> 00:03:17,360
sort of make it automate it so let's

00:03:15,599 --> 00:03:18,000
look into what would the holistic

00:03:17,360 --> 00:03:20,319
picture give

00:03:18,000 --> 00:03:22,319
us if we had it let's go to the next

00:03:20,319 --> 00:03:24,640
slide

00:03:22,319 --> 00:03:26,879
so first of all we understand the system

00:03:24,640 --> 00:03:28,879
right for instance we want to modify

00:03:26,879 --> 00:03:30,080
something and we need to locate it first

00:03:28,879 --> 00:03:31,599
we would like to eliminate the

00:03:30,080 --> 00:03:33,120
efficiencies and there could be

00:03:31,599 --> 00:03:34,159
especially because it's distributed

00:03:33,120 --> 00:03:36,000
system and it was

00:03:34,159 --> 00:03:37,200
optimized per module rather than

00:03:36,000 --> 00:03:40,000
holistically

00:03:37,200 --> 00:03:41,840
uh conformance verification so how do i

00:03:40,000 --> 00:03:43,519
know that one module is enforcing

00:03:41,840 --> 00:03:44,720
something like the other module

00:03:43,519 --> 00:03:46,799
we would like to extract the

00:03:44,720 --> 00:03:49,280
documentation unless it exists but

00:03:46,799 --> 00:03:50,720
i believe it doesn't exist because we

00:03:49,280 --> 00:03:52,319
are developers we don't want to

00:03:50,720 --> 00:03:54,400
deal with documentation of ever

00:03:52,319 --> 00:03:56,959
exchanging project right

00:03:54,400 --> 00:03:58,640
uh for module overview so what are the

00:03:56,959 --> 00:04:01,200
dependencies between modules

00:03:58,640 --> 00:04:03,040
are there some relationships we would

00:04:01,200 --> 00:04:04,799
like to do optimization

00:04:03,040 --> 00:04:06,799
very common especially for the

00:04:04,799 --> 00:04:08,799
distributed system we developed it it

00:04:06,799 --> 00:04:10,720
scales we deploy it and then we get our

00:04:08,799 --> 00:04:12,159
first bill and we are not happy about it

00:04:10,720 --> 00:04:13,040
right how many of you have that

00:04:12,159 --> 00:04:15,040
experience

00:04:13,040 --> 00:04:17,040
or security assessment very big topic

00:04:15,040 --> 00:04:19,519
these days and so on

00:04:17,040 --> 00:04:20,239
so let's look one more slide before i

00:04:19,519 --> 00:04:23,280
pass off

00:04:20,239 --> 00:04:24,880
the work to my colleagues so profit is

00:04:23,280 --> 00:04:26,560
the tool that we are introducing

00:04:24,880 --> 00:04:28,880
and that we are developing and

00:04:26,560 --> 00:04:29,840
experimenting with so the idea is to

00:04:28,880 --> 00:04:31,759
automate

00:04:29,840 --> 00:04:32,960
the extraction of software architecture

00:04:31,759 --> 00:04:34,800
reconstruction

00:04:32,960 --> 00:04:36,960
for microservice systems that are

00:04:34,800 --> 00:04:38,880
distributed so how do we do that of

00:04:36,960 --> 00:04:41,280
course it's a holistic so

00:04:38,880 --> 00:04:42,560
we pretty much take each individual

00:04:41,280 --> 00:04:44,960
microservice

00:04:42,560 --> 00:04:47,440
we analyze it from the code perspective

00:04:44,960 --> 00:04:50,800
currently we do that for java platforms

00:04:47,440 --> 00:04:52,960
and from there we try to build a

00:04:50,800 --> 00:04:55,199
holistic model and

00:04:52,960 --> 00:04:56,160
we will learn in a second how to do that

00:04:55,199 --> 00:04:58,160
but maybe i will

00:04:56,160 --> 00:05:00,000
mention one more thing how do we do

00:04:58,160 --> 00:05:01,919
these things well we could do code

00:05:00,000 --> 00:05:03,120
analysis with the source code or with a

00:05:01,919 --> 00:05:05,360
byte code

00:05:03,120 --> 00:05:07,440
and we do both actually and it is a

00:05:05,360 --> 00:05:08,960
different use case one fits very nicely

00:05:07,440 --> 00:05:11,280
the continuous integration

00:05:08,960 --> 00:05:12,800
for the software development lifecycle

00:05:11,280 --> 00:05:15,600
so if developer does something

00:05:12,800 --> 00:05:17,440
we can holistically access the system if

00:05:15,600 --> 00:05:18,639
we have some functionality which we have

00:05:17,440 --> 00:05:21,919
and we will show you

00:05:18,639 --> 00:05:23,919
in a bit and the second option is

00:05:21,919 --> 00:05:25,039
that we actually do that on the bytecode

00:05:23,919 --> 00:05:26,560
level so this

00:05:25,039 --> 00:05:28,800
goes to the integration for the

00:05:26,560 --> 00:05:31,360
kubernetes for instance or still

00:05:28,800 --> 00:05:33,039
and uh the defaults uh sorry the sysops

00:05:31,360 --> 00:05:34,960
could actually benefit out of this

00:05:33,039 --> 00:05:36,560
so let's move on and dipta is going to

00:05:34,960 --> 00:05:39,600
tell you something about

00:05:36,560 --> 00:05:42,720
how how profit works so thank you and

00:05:39,600 --> 00:05:45,120
enjoy thanks so much

00:05:42,720 --> 00:05:46,479
um and so as we're kind of moving

00:05:45,120 --> 00:05:47,840
through these we want to kind of talk a

00:05:46,479 --> 00:05:49,919
little bit to the uh

00:05:47,840 --> 00:05:51,440
you know kind of the next speaker uh so

00:05:49,919 --> 00:05:54,000
tell us a little bit about uh what

00:05:51,440 --> 00:05:55,120
you're doing currently at baylor and uh

00:05:54,000 --> 00:05:57,199
you know kind of how you might have

00:05:55,120 --> 00:06:00,800
gotten involved in the project yeah

00:05:57,199 --> 00:06:03,919
so i am doing my masters at baylor

00:06:00,800 --> 00:06:05,680
and uh since 2019

00:06:03,919 --> 00:06:08,880
and since then i am working with dr

00:06:05,680 --> 00:06:10,800
johnny and on this profit project

00:06:08,880 --> 00:06:12,400
cool and what is it that attracted you

00:06:10,800 --> 00:06:15,199
to the project like what did you find

00:06:12,400 --> 00:06:16,400
interesting uh i i think the most

00:06:15,199 --> 00:06:19,600
interesting part is

00:06:16,400 --> 00:06:21,120
uh generating this uh holistic picture

00:06:19,600 --> 00:06:23,520
of the micro services

00:06:21,120 --> 00:06:24,319
uh some with some kind of automated uh

00:06:23,520 --> 00:06:26,880
process

00:06:24,319 --> 00:06:29,120
because it's uh really important to

00:06:26,880 --> 00:06:31,199
automate the process uh for large number

00:06:29,120 --> 00:06:34,560
of microservices

00:06:31,199 --> 00:06:36,479
neat yeah i yeah i definitely agree um

00:06:34,560 --> 00:06:38,800
you know uh why don't we let you kind of

00:06:36,479 --> 00:06:39,919
go on to talk about your uh component of

00:06:38,800 --> 00:06:42,479
the project

00:06:39,919 --> 00:06:45,520
yeah uh you can go to the next slides so

00:06:42,479 --> 00:06:48,720
as uh dr chan was discussing profit was

00:06:45,520 --> 00:06:50,639
properties uh merging the microservices

00:06:48,720 --> 00:06:52,880
so

00:06:50,639 --> 00:06:54,880
in profit we have like three perspective

00:06:52,880 --> 00:06:58,960
of mars merging the microservices

00:06:54,880 --> 00:07:02,319
and the first one we actually merged the

00:06:58,960 --> 00:07:04,720
data models and in the second step we uh

00:07:02,319 --> 00:07:05,840
identify the remote calls or rest calls

00:07:04,720 --> 00:07:07,680
and merge them

00:07:05,840 --> 00:07:10,400
and in the third step we actually

00:07:07,680 --> 00:07:13,199
analyze the deployment descriptors or

00:07:10,400 --> 00:07:14,800
uh kubernetes configuration files to

00:07:13,199 --> 00:07:17,120
merge the microservices

00:07:14,800 --> 00:07:18,240
so we can go to the next slides where we

00:07:17,120 --> 00:07:21,759
will discuss

00:07:18,240 --> 00:07:24,639
about the bounded context so we

00:07:21,759 --> 00:07:24,960
merge the bounded context which uh which

00:07:24,639 --> 00:07:27,039
is

00:07:24,960 --> 00:07:29,280
done through the static code analysis

00:07:27,039 --> 00:07:32,560
for source code or bytecode

00:07:29,280 --> 00:07:36,000
and then for each microservice we

00:07:32,560 --> 00:07:38,400
extract the data models and

00:07:36,000 --> 00:07:39,759
then we merge the data models together

00:07:38,400 --> 00:07:42,960
into one large

00:07:39,759 --> 00:07:46,319
uh data models so we

00:07:42,960 --> 00:07:48,639
we do so uh by analyzing natural by

00:07:46,319 --> 00:07:49,360
um analyzing natural language processing

00:07:48,639 --> 00:07:51,280
or

00:07:49,360 --> 00:07:52,479
uh finding the similarity between data

00:07:51,280 --> 00:07:56,000
models

00:07:52,479 --> 00:07:59,599
the next slides uh we

00:07:56,000 --> 00:08:03,199
yeah in the next slide here we

00:07:59,599 --> 00:08:04,879
uh talk about the uh merging the

00:08:03,199 --> 00:08:07,280
rest interactions among the

00:08:04,879 --> 00:08:08,720
microservices so here we also use the

00:08:07,280 --> 00:08:12,240
static code analysis

00:08:08,720 --> 00:08:12,720
which is less costly and more faster and

00:08:12,240 --> 00:08:14,960
this

00:08:12,720 --> 00:08:16,639
generates us the service view of the

00:08:14,960 --> 00:08:18,639
software architecture reconstruction

00:08:16,639 --> 00:08:20,240
which i think andrew will discuss more

00:08:18,639 --> 00:08:22,479
later and

00:08:20,240 --> 00:08:24,080
in this step we have two phases in the

00:08:22,479 --> 00:08:26,160
first phase we scan

00:08:24,080 --> 00:08:27,759
the rest endpoints and rest calls of the

00:08:26,160 --> 00:08:30,639
micro services

00:08:27,759 --> 00:08:33,039
and in the second phase we match the url

00:08:30,639 --> 00:08:35,919
institute type and parameters of rest

00:08:33,039 --> 00:08:38,080
and points and rest calls

00:08:35,919 --> 00:08:40,240
in the next slide we will talk about the

00:08:38,080 --> 00:08:42,880
containerized microservices

00:08:40,240 --> 00:08:44,800
so this is important because not always

00:08:42,880 --> 00:08:45,839
we have the access to the source code or

00:08:44,800 --> 00:08:48,399
byte code

00:08:45,839 --> 00:08:50,560
and what we have only the deployment

00:08:48,399 --> 00:08:52,320
files for example kubernetes deployment

00:08:50,560 --> 00:08:56,240
files or docker files

00:08:52,320 --> 00:08:58,080
so it is still possible for us to

00:08:56,240 --> 00:08:59,920
generate this rest interaction graph for

00:08:58,080 --> 00:09:02,640
the container as micro services

00:08:59,920 --> 00:09:03,600
so what we do for this we analyze the

00:09:02,640 --> 00:09:06,320
kubernetes

00:09:03,600 --> 00:09:07,120
uh deployment files through a kubernetes

00:09:06,320 --> 00:09:09,519
client

00:09:07,120 --> 00:09:11,760
and we extract the container name entry

00:09:09,519 --> 00:09:14,880
point path and service discovery

00:09:11,760 --> 00:09:17,920
after that uh we

00:09:14,880 --> 00:09:19,279
extract the executable jar files from

00:09:17,920 --> 00:09:21,040
those containers

00:09:19,279 --> 00:09:22,320
uh that is located on the entry point

00:09:21,040 --> 00:09:24,959
path and

00:09:22,320 --> 00:09:25,600
we do so by mounting the docker socket

00:09:24,959 --> 00:09:28,080
uh

00:09:25,600 --> 00:09:28,959
into a separate container which ensures

00:09:28,080 --> 00:09:31,200
that

00:09:28,959 --> 00:09:32,560
the same container is being analyzed

00:09:31,200 --> 00:09:33,200
that is running on the kubernetes

00:09:32,560 --> 00:09:35,519
cluster

00:09:33,200 --> 00:09:36,720
after we extract the jar file or

00:09:35,519 --> 00:09:39,040
bytecode

00:09:36,720 --> 00:09:40,320
the next steps are the same as we did

00:09:39,040 --> 00:09:43,040
before

00:09:40,320 --> 00:09:44,399
so in the next step i think andrew will

00:09:43,040 --> 00:09:47,760
discuss more about the software

00:09:44,399 --> 00:09:47,760
architecture is construction

00:09:47,839 --> 00:09:52,320
thanks dr and uh we'll give andrew a

00:09:51,680 --> 00:09:55,279
second to

00:09:52,320 --> 00:09:57,200
to click the right buttons uh and uh

00:09:55,279 --> 00:09:59,600
thanks for being on the show with us

00:09:57,200 --> 00:10:00,959
um and uh why don't you tell us a little

00:09:59,600 --> 00:10:04,320
bit about what you're doing

00:10:00,959 --> 00:10:07,040
at uh baylor so could you tell us what

00:10:04,320 --> 00:10:08,320
got you involved in the project yeah so

00:10:07,040 --> 00:10:10,560
i started working

00:10:08,320 --> 00:10:12,560
with dr cherny a couple years ago and it

00:10:10,560 --> 00:10:14,640
was just kind of an exciting way to look

00:10:12,560 --> 00:10:16,240
at things beyond the classroom

00:10:14,640 --> 00:10:18,079
and what we don't want we get to work

00:10:16,240 --> 00:10:20,000
with and then it gradually kind of grew

00:10:18,079 --> 00:10:22,720
into this thing that we realized

00:10:20,000 --> 00:10:25,760
had real ramifications in industry and

00:10:22,720 --> 00:10:29,040
had a lot of great applications

00:10:25,760 --> 00:10:29,600
so so okay so that's that's really

00:10:29,040 --> 00:10:31,279
pretty cool

00:10:29,600 --> 00:10:34,959
um why don't you tell us a little bit

00:10:31,279 --> 00:10:34,959
about how you are interpreting

00:10:35,279 --> 00:10:39,040
sorry what was that oh i'm sorry i think

00:10:37,760 --> 00:10:40,720
uh we're getting uh

00:10:39,040 --> 00:10:42,000
some inbound microphone if somebody

00:10:40,720 --> 00:10:42,560
could check their mics and make sure

00:10:42,000 --> 00:10:45,760
they're not

00:10:42,560 --> 00:10:49,200
sharing their microphone um

00:10:45,760 --> 00:10:52,079
so it's kind of odd

00:10:49,200 --> 00:10:53,040
uh so uh yeah hopefully the audience is

00:10:52,079 --> 00:10:55,279
not hearing this and

00:10:53,040 --> 00:10:56,160
it's just us uh why don't you uh go

00:10:55,279 --> 00:10:57,839
ahead and

00:10:56,160 --> 00:11:00,640
talk about uh the interpretation that

00:10:57,839 --> 00:11:03,279
you do and i'll switch the next slide

00:11:00,640 --> 00:11:04,800
so what dipto is describing there is

00:11:03,279 --> 00:11:07,040
really a process called software

00:11:04,800 --> 00:11:09,440
architecture reconstruction

00:11:07,040 --> 00:11:12,160
and this is where we construct a very

00:11:09,440 --> 00:11:14,000
simplified overview of an application

00:11:12,160 --> 00:11:15,279
as dr charney mentioned this can really

00:11:14,000 --> 00:11:17,680
be done

00:11:15,279 --> 00:11:19,360
in a manual or an automatic way and the

00:11:17,680 --> 00:11:22,000
vast majority right now

00:11:19,360 --> 00:11:23,680
is done manually and this really isn't

00:11:22,000 --> 00:11:25,200
applicable for a micro service

00:11:23,680 --> 00:11:27,680
application because they just kind of

00:11:25,200 --> 00:11:30,000
get way too

00:11:27,680 --> 00:11:32,240
big and complicated and developers have

00:11:30,000 --> 00:11:33,360
a hard time understanding the entire

00:11:32,240 --> 00:11:36,640
system

00:11:33,360 --> 00:11:38,480
and this is done in four phases and to

00:11:36,640 --> 00:11:40,160
start with the extraction phase

00:11:38,480 --> 00:11:42,079
this is where you get kind of the

00:11:40,160 --> 00:11:45,839
biggest divide between an automatic

00:11:42,079 --> 00:11:47,120
and a manual system so the extraction is

00:11:45,839 --> 00:11:48,320
where you pull anything that you're

00:11:47,120 --> 00:11:50,160
going to need

00:11:48,320 --> 00:11:53,279
for the different phases that are left

00:11:50,160 --> 00:11:54,720
in sar and this can be

00:11:53,279 --> 00:11:56,399
really anything i mean it's truly

00:11:54,720 --> 00:11:57,920
unlimited it's just a matter of what

00:11:56,399 --> 00:11:59,360
kind of views you're wanting to build

00:11:57,920 --> 00:12:02,240
from sar

00:11:59,360 --> 00:12:03,200
and so in a manual way you may pull

00:12:02,240 --> 00:12:06,720
things like

00:12:03,200 --> 00:12:09,680
uml diagrams or readmes or

00:12:06,720 --> 00:12:10,000
other you know brds different documents

00:12:09,680 --> 00:12:12,639
about

00:12:10,000 --> 00:12:14,880
the application in an automatic system

00:12:12,639 --> 00:12:16,720
which we're doing we kind of have to be

00:12:14,880 --> 00:12:18,560
a little more selective because we can't

00:12:16,720 --> 00:12:19,680
really interpret something like a uml

00:12:18,560 --> 00:12:23,120
diagram

00:12:19,680 --> 00:12:27,040
um so we pull stuff

00:12:23,120 --> 00:12:29,680
like the code and the deployment

00:12:27,040 --> 00:12:31,120
the documents and we use those

00:12:29,680 --> 00:12:32,639
automatically

00:12:31,120 --> 00:12:34,880
through some like you know like static

00:12:32,639 --> 00:12:36,560
code analysis dynamic code analysis and

00:12:34,880 --> 00:12:37,279
that lets us create these different

00:12:36,560 --> 00:12:38,800
views

00:12:37,279 --> 00:12:40,320
and so we move on to construction where

00:12:38,800 --> 00:12:42,560
we actually do that and we

00:12:40,320 --> 00:12:44,399
scan all these different source code and

00:12:42,560 --> 00:12:46,800
the related documents

00:12:44,399 --> 00:12:49,839
and we construct the different views for

00:12:46,800 --> 00:12:51,279
each of the individual modules

00:12:49,839 --> 00:12:53,200
at this point we're just treating each

00:12:51,279 --> 00:12:54,480
module like its own little monolithic

00:12:53,200 --> 00:12:56,639
application

00:12:54,480 --> 00:12:57,920
but in the next stage which is

00:12:56,639 --> 00:12:59,920
manipulation

00:12:57,920 --> 00:13:01,360
we're actually going to start combining

00:12:59,920 --> 00:13:04,240
these different

00:13:01,360 --> 00:13:06,160
module kind of views in themselves and

00:13:04,240 --> 00:13:07,519
so we're able to build a way more

00:13:06,160 --> 00:13:09,200
holistic picture

00:13:07,519 --> 00:13:11,839
by starting to match the different

00:13:09,200 --> 00:13:13,839
aspects of the different micro services

00:13:11,839 --> 00:13:15,360
and so at the end of the manipulation

00:13:13,839 --> 00:13:17,519
phase we have this huge

00:13:15,360 --> 00:13:19,120
overview of the application which

00:13:17,519 --> 00:13:20,639
consists of a bunch of different

00:13:19,120 --> 00:13:22,240
views which i'll get to on the next

00:13:20,639 --> 00:13:24,800
slide but

00:13:22,240 --> 00:13:25,760
that lets us get into the analysis phase

00:13:24,800 --> 00:13:27,839
where

00:13:25,760 --> 00:13:30,000
the analysis phase is really just what

00:13:27,839 --> 00:13:32,560
questions do you want to answer about

00:13:30,000 --> 00:13:34,160
an application and again this can be

00:13:32,560 --> 00:13:36,800
kind of whatever you want

00:13:34,160 --> 00:13:38,399
what you build in the previous phases is

00:13:36,800 --> 00:13:39,519
really going to depend on what questions

00:13:38,399 --> 00:13:41,040
you want to answer

00:13:39,519 --> 00:13:42,639
and later in the presentation we'll

00:13:41,040 --> 00:13:45,279
demonstrate a couple questions that

00:13:42,639 --> 00:13:48,320
we've been able to answer with them

00:13:45,279 --> 00:13:50,639
so linkedin if you want wanna

00:13:48,320 --> 00:13:51,760
yeah so i wanna talk briefly about the

00:13:50,639 --> 00:13:55,440
different views that

00:13:51,760 --> 00:13:57,440
we're going to be building and basically

00:13:55,440 --> 00:13:59,440
we have four that we focus on and we

00:13:57,440 --> 00:14:01,279
feel that this allows us to get the most

00:13:59,440 --> 00:14:04,639
bang for our buck basically

00:14:01,279 --> 00:14:06,560
and be able to kind of answer the most

00:14:04,639 --> 00:14:09,279
amount of questions with this minimal

00:14:06,560 --> 00:14:11,199
overhead so the first one we do is the

00:14:09,279 --> 00:14:13,120
domain view which is basically just all

00:14:11,199 --> 00:14:14,399
the entities of a system

00:14:13,120 --> 00:14:16,800
and then we kind of go through this

00:14:14,399 --> 00:14:18,639
process of merging them using

00:14:16,800 --> 00:14:20,880
you know some field matching name

00:14:18,639 --> 00:14:23,199
matching a little bit of nlp

00:14:20,880 --> 00:14:25,120
and we kind of start to find the overlap

00:14:23,199 --> 00:14:28,000
in them and are able to

00:14:25,120 --> 00:14:30,320
identify you know kind of how they

00:14:28,000 --> 00:14:32,079
interact as a whole and build a giant

00:14:30,320 --> 00:14:35,440
domain model out of that

00:14:32,079 --> 00:14:36,959
or kind of just see the overlap and see

00:14:35,440 --> 00:14:38,560
what are the commonalities like in

00:14:36,959 --> 00:14:40,240
figure one where it just pulls out

00:14:38,560 --> 00:14:43,120
what's the same

00:14:40,240 --> 00:14:44,560
we also have the technology view which

00:14:43,120 --> 00:14:48,000
is where we kind of map

00:14:44,560 --> 00:14:49,199
all those uh you know api calls between

00:14:48,000 --> 00:14:50,639
the different modules

00:14:49,199 --> 00:14:53,360
and we're able to show the different

00:14:50,639 --> 00:14:55,760
dependencies based on api calls between

00:14:53,360 --> 00:14:59,839
the different microservices

00:14:55,760 --> 00:15:03,920
we also have the service view which is

00:14:59,839 --> 00:15:06,320
basically um sorry i misspoke the

00:15:03,920 --> 00:15:07,600
service view is all of the api calls

00:15:06,320 --> 00:15:09,839
between the different

00:15:07,600 --> 00:15:11,440
microservices the technology view is

00:15:09,839 --> 00:15:14,079
what did you actually use

00:15:11,440 --> 00:15:15,600
to implement those microservices and so

00:15:14,079 --> 00:15:17,120
this can be

00:15:15,600 --> 00:15:19,120
you know the very great thing about

00:15:17,120 --> 00:15:19,440
microservices is they can be implemented

00:15:19,120 --> 00:15:21,199
with

00:15:19,440 --> 00:15:22,800
whatever language you want whatever

00:15:21,199 --> 00:15:25,360
version of the language you want

00:15:22,800 --> 00:15:26,880
you know whatever frameworks you want

00:15:25,360 --> 00:15:27,440
but there does come a certain point

00:15:26,880 --> 00:15:29,839
where

00:15:27,440 --> 00:15:31,199
you may be going too diverse and so

00:15:29,839 --> 00:15:31,600
that's something that we wanted to look

00:15:31,199 --> 00:15:33,279
at

00:15:31,600 --> 00:15:35,360
and so the technology view is just what

00:15:33,279 --> 00:15:37,360
are you using for you know your front

00:15:35,360 --> 00:15:40,079
end or your data storage

00:15:37,360 --> 00:15:41,600
or you know the actual service layer

00:15:40,079 --> 00:15:44,320
architecture

00:15:41,600 --> 00:15:45,040
and so then service view was the api

00:15:44,320 --> 00:15:48,240
calls and then

00:15:45,040 --> 00:15:51,040
operation view is kind of

00:15:48,240 --> 00:15:52,160
the deployment of the application and so

00:15:51,040 --> 00:15:54,240
it's looking at

00:15:52,160 --> 00:15:56,880
things like the docker images docker

00:15:54,240 --> 00:15:58,720
files kubernetes deployment

00:15:56,880 --> 00:16:00,160
uh configuration files and just

00:15:58,720 --> 00:16:02,480
understanding how it is

00:16:00,160 --> 00:16:04,240
that the different micro services are

00:16:02,480 --> 00:16:06,240
deployed

00:16:04,240 --> 00:16:07,360
sorry i also had to find the buttons to

00:16:06,240 --> 00:16:09,759
come back on the screen

00:16:07,360 --> 00:16:11,199
uh thanks so much andrew uh and uh you

00:16:09,759 --> 00:16:12,800
know hopefully that will be the end of

00:16:11,199 --> 00:16:14,079
our technical difficulties for the day

00:16:12,800 --> 00:16:15,839
maybe for the conference

00:16:14,079 --> 00:16:17,440
uh but we wanna you know we want to hit

00:16:15,839 --> 00:16:20,160
it hard for you uh

00:16:17,440 --> 00:16:21,440
you know or maybe one of our speakers is

00:16:20,160 --> 00:16:24,160
actually on the trip to

00:16:21,440 --> 00:16:24,880
mars and they got some background noise

00:16:24,160 --> 00:16:26,720
from that

00:16:24,880 --> 00:16:28,560
uh vincent uh thanks so much for coming

00:16:26,720 --> 00:16:31,199
on uh why don't you tell us a little bit

00:16:28,560 --> 00:16:33,279
about what you're doing at baylor

00:16:31,199 --> 00:16:35,120
certainly i am also a second year

00:16:33,279 --> 00:16:38,320
master's student at baylor i started in

00:16:35,120 --> 00:16:39,279
2019 and i've been involved with dr

00:16:38,320 --> 00:16:40,800
cherny's lab and

00:16:39,279 --> 00:16:42,480
profit project since the beginning of

00:16:40,800 --> 00:16:44,320
2020.

00:16:42,480 --> 00:16:45,839
cool and what was it that kind of

00:16:44,320 --> 00:16:48,480
attracted you the project what was

00:16:45,839 --> 00:16:50,079
interesting for you well for me it just

00:16:48,480 --> 00:16:52,880
seemed like a very practical

00:16:50,079 --> 00:16:55,120
project obviously microservices are

00:16:52,880 --> 00:16:56,720
pretty much the de facto standard for

00:16:55,120 --> 00:16:58,639
a lot of new development not all of it

00:16:56,720 --> 00:16:59,680
but obviously a lot of things now depend

00:16:58,639 --> 00:17:01,839
on that so

00:16:59,680 --> 00:17:03,360
anything to make that easier to

00:17:01,839 --> 00:17:06,000
understand and dissect

00:17:03,360 --> 00:17:07,600
especially for like um onboarding new

00:17:06,000 --> 00:17:08,160
developers onto a project being that

00:17:07,600 --> 00:17:10,480
faster

00:17:08,160 --> 00:17:11,199
i thought that was a really cool thing

00:17:10,480 --> 00:17:14,079
neat yeah

00:17:11,199 --> 00:17:15,360
definitely definitely a challenge um so

00:17:14,079 --> 00:17:17,360
why don't we go ahead and get started

00:17:15,360 --> 00:17:19,439
with your uh segment

00:17:17,360 --> 00:17:20,559
all right so i'm just going to talk a

00:17:19,439 --> 00:17:22,720
little bit about

00:17:20,559 --> 00:17:24,880
um the project itself and the prototype

00:17:22,720 --> 00:17:27,280
we have deployed this is just a

00:17:24,880 --> 00:17:30,640
simple little demo of the project

00:17:27,280 --> 00:17:32,000
prototype that we have right now

00:17:30,640 --> 00:17:34,400
so first off we have a couple of

00:17:32,000 --> 00:17:36,559
different uh test beds that we test

00:17:34,400 --> 00:17:39,120
against a couple repositories the tms

00:17:36,559 --> 00:17:39,600
project what you see here um that's a

00:17:39,120 --> 00:17:42,160
simple

00:17:39,600 --> 00:17:42,880
in-house microservice benchmark that we

00:17:42,160 --> 00:17:44,559
created

00:17:42,880 --> 00:17:46,799
very simple just three services for a

00:17:44,559 --> 00:17:49,919
proof-of-concept type thing

00:17:46,799 --> 00:17:51,039
the train ticket repository is actually

00:17:49,919 --> 00:17:53,440
a more extensive

00:17:51,039 --> 00:17:55,440
externally made repository it's got

00:17:53,440 --> 00:17:57,919
about 40 micro services in it

00:17:55,440 --> 00:17:59,679
so um it's going to be a lot more

00:17:57,919 --> 00:18:01,840
extensive in the kinds of analysis

00:17:59,679 --> 00:18:03,600
verification we do on it

00:18:01,840 --> 00:18:06,080
we're going to actually use that a

00:18:03,600 --> 00:18:07,360
little bit later on in the talk later

00:18:06,080 --> 00:18:09,919
but for now we're just going to use the

00:18:07,360 --> 00:18:12,320
tms for a simple demonstration

00:18:09,919 --> 00:18:14,160
so right now in the visualization aspect

00:18:12,320 --> 00:18:15,679
of this we're focusing on two different

00:18:14,160 --> 00:18:18,799
kinds of diagrams

00:18:15,679 --> 00:18:20,880
communication diagrams like you see here

00:18:18,799 --> 00:18:23,840
and then below that we also have context

00:18:20,880 --> 00:18:25,360
maps or domain diagrams

00:18:23,840 --> 00:18:27,200
and this is really just visualizing the

00:18:25,360 --> 00:18:28,000
results of the software architecture

00:18:27,200 --> 00:18:30,640
reconstruction

00:18:28,000 --> 00:18:32,320
process itself so in this communication

00:18:30,640 --> 00:18:33,520
diagram this is that service view that

00:18:32,320 --> 00:18:35,039
andrew was mentioning

00:18:33,520 --> 00:18:36,880
you see that we extract all the

00:18:35,039 --> 00:18:38,720
different services you see the cms

00:18:36,880 --> 00:18:40,480
ems qms those are the three different

00:18:38,720 --> 00:18:42,080
services in the test bed

00:18:40,480 --> 00:18:44,320
and then we extract all the different

00:18:42,080 --> 00:18:46,080
calls between them so that's

00:18:44,320 --> 00:18:48,080
all the communication that happens among

00:18:46,080 --> 00:18:50,480
the microservices

00:18:48,080 --> 00:18:51,840
you see that we get um the http methods

00:18:50,480 --> 00:18:53,039
and the methods that are called in the

00:18:51,840 --> 00:18:55,280
services

00:18:53,039 --> 00:18:58,080
below that you have the context maps and

00:18:55,280 --> 00:19:00,240
this is just an extracted domain diagram

00:18:58,080 --> 00:19:01,280
for the entire system what we do is we

00:19:00,240 --> 00:19:03,600
find all of the

00:19:01,280 --> 00:19:04,640
entities all the objects are acting as

00:19:03,600 --> 00:19:07,679
entities

00:19:04,640 --> 00:19:08,960
within each individual microservice

00:19:07,679 --> 00:19:11,120
and we find its properties and

00:19:08,960 --> 00:19:13,200
relationships etc

00:19:11,120 --> 00:19:14,240
each individual service has a different

00:19:13,200 --> 00:19:15,679
view of the data

00:19:14,240 --> 00:19:18,080
so you can see below there we have

00:19:15,679 --> 00:19:21,520
domain diagrams for each individual

00:19:18,080 --> 00:19:22,559
microservice so we go into each

00:19:21,520 --> 00:19:24,400
microservice

00:19:22,559 --> 00:19:25,679
find all of its entities and its

00:19:24,400 --> 00:19:27,360
relationships

00:19:25,679 --> 00:19:28,720
and then we kind of aggregate those

00:19:27,360 --> 00:19:31,919
together into

00:19:28,720 --> 00:19:32,880
a single combined view so we find what

00:19:31,919 --> 00:19:35,760
relationships

00:19:32,880 --> 00:19:37,679
exist among entities across the

00:19:35,760 --> 00:19:40,240
microservices

00:19:37,679 --> 00:19:41,280
and then we combine those into a single

00:19:40,240 --> 00:19:43,039
place

00:19:41,280 --> 00:19:44,880
and both of those diagrams again are

00:19:43,039 --> 00:19:46,320
just visualizations

00:19:44,880 --> 00:19:48,080
of the software architecture

00:19:46,320 --> 00:19:52,000
reconstruction process

00:19:48,080 --> 00:19:55,120
so on the next slide i just have a

00:19:52,000 --> 00:19:57,120
bit more of a expounding on what i was

00:19:55,120 --> 00:19:58,960
saying there about the domain diagrams

00:19:57,120 --> 00:20:00,640
uh and what we're doing so if you have

00:19:58,960 --> 00:20:01,600
two different services that have these

00:20:00,640 --> 00:20:04,400
entities so

00:20:01,600 --> 00:20:06,080
uh service one has um specifically

00:20:04,400 --> 00:20:09,039
looking at the question and entity

00:20:06,080 --> 00:20:10,159
it's got a lot of relationships to a lot

00:20:09,039 --> 00:20:11,919
of other things

00:20:10,159 --> 00:20:13,120
and then service to the question entity

00:20:11,919 --> 00:20:14,960
doesn't have nearly as many

00:20:13,120 --> 00:20:16,720
relationships but it has a new one that

00:20:14,960 --> 00:20:19,760
the first service doesn't have

00:20:16,720 --> 00:20:20,640
the question to exam relationship so

00:20:19,760 --> 00:20:23,440
essentially

00:20:20,640 --> 00:20:24,960
we're just extracting those services or

00:20:23,440 --> 00:20:26,400
extracting those entities and then we're

00:20:24,960 --> 00:20:29,200
combining them together

00:20:26,400 --> 00:20:29,520
in the combined result on the right you

00:20:29,200 --> 00:20:31,520
have

00:20:29,520 --> 00:20:33,440
all the extra relationships that service

00:20:31,520 --> 00:20:34,640
one has but also the exam entity that

00:20:33,440 --> 00:20:36,080
was in service too

00:20:34,640 --> 00:20:38,080
that's just a basic overview of what

00:20:36,080 --> 00:20:41,600
we're doing there so on the next slide

00:20:38,080 --> 00:20:43,120
what i want to talk about briefly is

00:20:41,600 --> 00:20:46,080
where we'll be going next so if you can

00:20:43,120 --> 00:20:46,080
move to the next slide

00:20:46,320 --> 00:20:51,360
so right now as i mentioned we're only

00:20:49,520 --> 00:20:52,960
visualizing that bare bone software

00:20:51,360 --> 00:20:55,120
architecture reconstruction

00:20:52,960 --> 00:20:56,960
itself just the those different views

00:20:55,120 --> 00:20:59,360
that andrew mentioned

00:20:56,960 --> 00:21:00,080
in the future um what we're doing right

00:20:59,360 --> 00:21:03,760
now is

00:21:00,080 --> 00:21:06,000
analyzing different system concerns so

00:21:03,760 --> 00:21:07,360
we're going to talk about security in

00:21:06,000 --> 00:21:09,120
just a second we're going to talk about

00:21:07,360 --> 00:21:10,880
code quality through looking at code

00:21:09,120 --> 00:21:13,120
clones in a minute

00:21:10,880 --> 00:21:15,200
these are other things that we want to

00:21:13,120 --> 00:21:16,159
analyze and that we also want to include

00:21:15,200 --> 00:21:19,039
in the visualization

00:21:16,159 --> 00:21:21,760
process so we want to show a way to

00:21:19,039 --> 00:21:23,440
share that information with the user

00:21:21,760 --> 00:21:25,840
we also want to look into some other

00:21:23,440 --> 00:21:27,360
formats one thing that we ran into when

00:21:25,840 --> 00:21:30,159
we were analyzing the

00:21:27,360 --> 00:21:32,559
4d microservice benchmark is that 2d

00:21:30,159 --> 00:21:34,240
graphs get very limited very quickly

00:21:32,559 --> 00:21:35,840
in the information that they can

00:21:34,240 --> 00:21:37,440
concisely display

00:21:35,840 --> 00:21:40,240
so we want to look into some other

00:21:37,440 --> 00:21:41,600
formats for example using 3d or some

00:21:40,240 --> 00:21:45,520
kind of

00:21:41,600 --> 00:21:47,360
ar or vr setup in order to help users

00:21:45,520 --> 00:21:49,679
kind of navigate these microservice

00:21:47,360 --> 00:21:52,400
meshes we also want to make it a bit

00:21:49,679 --> 00:21:55,440
more interactive of a process

00:21:52,400 --> 00:21:56,559
so allowing users to form some kind of

00:21:55,440 --> 00:21:58,799
query about

00:21:56,559 --> 00:21:59,679
what exactly they're looking for so

00:21:58,799 --> 00:22:02,559
they'll be able to

00:21:59,679 --> 00:22:04,240
narrow down the results instead of well

00:22:02,559 --> 00:22:05,919
they'll be able to start with the

00:22:04,240 --> 00:22:07,280
large overall graph but then be able to

00:22:05,919 --> 00:22:08,799
slice it down to

00:22:07,280 --> 00:22:11,120
what specific services are they

00:22:08,799 --> 00:22:13,039
interested in what concerns do they want

00:22:11,120 --> 00:22:14,559
to look at and what relationships

00:22:13,039 --> 00:22:16,960
between the microservices are they

00:22:14,559 --> 00:22:18,720
specifically interested in

00:22:16,960 --> 00:22:20,080
so those are the kinds of things that

00:22:18,720 --> 00:22:22,080
we'll be pushing

00:22:20,080 --> 00:22:24,159
in the future on this project back to

00:22:22,080 --> 00:22:26,720
you langdon

00:22:24,159 --> 00:22:28,240
so we can expect to see a vr version of

00:22:26,720 --> 00:22:30,559
this in the vr

00:22:28,240 --> 00:22:31,280
uh for the conference uh is what you're

00:22:30,559 --> 00:22:33,360
saying

00:22:31,280 --> 00:22:35,200
so if we go right yeah it's live right

00:22:33,360 --> 00:22:36,000
now you can you can go into the matrix

00:22:35,200 --> 00:22:37,760
right now and

00:22:36,000 --> 00:22:39,360
hack with that's all you want right

00:22:37,760 --> 00:22:41,440
right good to know um

00:22:39,360 --> 00:22:43,200
well thanks so much uh and uh we'd like

00:22:41,440 --> 00:22:46,799
to welcome uh diptobac

00:22:43,200 --> 00:22:48,320
to talk about uh kind of some example

00:22:46,799 --> 00:22:48,960
uses we're gonna go through a couple of

00:22:48,320 --> 00:22:51,600
different

00:22:48,960 --> 00:22:54,400
uh scenarios and dipt is gonna lead us

00:22:51,600 --> 00:22:57,440
off with endpoint security

00:22:54,400 --> 00:22:59,360
yeah so uh in the next slide we are

00:22:57,440 --> 00:23:00,960
going to discuss about

00:22:59,360 --> 00:23:02,720
uh some application of the software

00:23:00,960 --> 00:23:05,919
architecture reconstruction

00:23:02,720 --> 00:23:06,880
that uh prophet was doing so one of them

00:23:05,919 --> 00:23:10,000
is

00:23:06,880 --> 00:23:11,440
analyzing the urban inconsistency in the

00:23:10,000 --> 00:23:14,400
api endpoints

00:23:11,440 --> 00:23:16,559
so we defined five different kind of

00:23:14,400 --> 00:23:19,520
violation or inconsistency

00:23:16,559 --> 00:23:21,840
related to our back policies so the

00:23:19,520 --> 00:23:24,480
first one is missing role violations

00:23:21,840 --> 00:23:25,679
which happens when one epa endpoint do

00:23:24,480 --> 00:23:28,880
not have any

00:23:25,679 --> 00:23:31,520
uh arabic rules associated with it

00:23:28,880 --> 00:23:33,120
so it can be false positive because some

00:23:31,520 --> 00:23:35,440
endpoints are really public

00:23:33,120 --> 00:23:37,600
and that is intentional however

00:23:35,440 --> 00:23:40,320
sometimes developers forget to

00:23:37,600 --> 00:23:41,760
uh provide those api roles on the ipa

00:23:40,320 --> 00:23:43,600
endpoints

00:23:41,760 --> 00:23:45,840
and the second one is unknown access

00:23:43,600 --> 00:23:46,559
violation uh that happens when you

00:23:45,840 --> 00:23:49,440
define a

00:23:46,559 --> 00:23:50,000
are back role on api endpoint but that

00:23:49,440 --> 00:23:51,840
arbitrage

00:23:50,000 --> 00:23:53,120
rule doesn't present in your role

00:23:51,840 --> 00:23:55,039
hierarchy as

00:23:53,120 --> 00:23:56,559
uh roll higher as the role hierarchy

00:23:55,039 --> 00:24:00,000
shown in the

00:23:56,559 --> 00:24:01,679
left and in the right and then the third

00:24:00,000 --> 00:24:05,200
one is entity access violation

00:24:01,679 --> 00:24:05,520
which happens when two api endpoints

00:24:05,200 --> 00:24:08,000
have

00:24:05,520 --> 00:24:10,159
same input and output that means they

00:24:08,000 --> 00:24:10,720
have the same response type and request

00:24:10,159 --> 00:24:14,799
type

00:24:10,720 --> 00:24:18,400
but they have different arbitrals

00:24:14,799 --> 00:24:20,559
and this three violation happens for the

00:24:18,400 --> 00:24:22,320
endpoint methods and the next two

00:24:20,559 --> 00:24:24,320
conflicting hierarchy violation and

00:24:22,320 --> 00:24:26,159
unrelated access violation happens for

00:24:24,320 --> 00:24:29,600
the intermediate methods

00:24:26,159 --> 00:24:32,960
so when an intermediate method uh

00:24:29,600 --> 00:24:36,400
have two different roles uh that are

00:24:32,960 --> 00:24:37,200
uh that are uh ancestor of each other's

00:24:36,400 --> 00:24:39,440
for example

00:24:37,200 --> 00:24:40,480
user and advent they are the ancestor of

00:24:39,440 --> 00:24:41,760
each other's

00:24:40,480 --> 00:24:43,840
when this happens we call this

00:24:41,760 --> 00:24:47,600
conflicting hierarchy violations

00:24:43,840 --> 00:24:50,240
and when to different

00:24:47,600 --> 00:24:51,760
uh intermediate method have uh one

00:24:50,240 --> 00:24:54,240
intermediate method they have

00:24:51,760 --> 00:24:55,360
uh two roles that are in different sub

00:24:54,240 --> 00:24:58,960
trees for example

00:24:55,360 --> 00:25:01,520
users user and uh moderator these two

00:24:58,960 --> 00:25:03,679
roles are in different subtree we call

00:25:01,520 --> 00:25:06,960
this unrelated access violation

00:25:03,679 --> 00:25:09,279
so in the next slide uh we

00:25:06,960 --> 00:25:10,400
talk about how we detect this kind of

00:25:09,279 --> 00:25:13,520
violations

00:25:10,400 --> 00:25:14,159
so first we extract the rest interaction

00:25:13,520 --> 00:25:16,000
graph

00:25:14,159 --> 00:25:17,440
and method call graph by using the

00:25:16,000 --> 00:25:20,400
static code analysis

00:25:17,440 --> 00:25:21,520
and we also extract the outback roles

00:25:20,400 --> 00:25:24,720
associated with

00:25:21,520 --> 00:25:27,600
each api endpoints after that we combine

00:25:24,720 --> 00:25:29,360
the method called graphs by utilizing

00:25:27,600 --> 00:25:32,000
the wrist interaction graph

00:25:29,360 --> 00:25:33,520
and then we perform reduction where we

00:25:32,000 --> 00:25:36,799
just keep the lowest

00:25:33,520 --> 00:25:39,120
role of each api endpoints and then

00:25:36,799 --> 00:25:40,320
in the aggregation phase we push the

00:25:39,120 --> 00:25:42,880
role from the root

00:25:40,320 --> 00:25:44,000
to the leaf node of the method combined

00:25:42,880 --> 00:25:47,200
method called graph

00:25:44,000 --> 00:25:49,200
and then we analyze each intermediate

00:25:47,200 --> 00:25:51,120
nodes and each api endpoint nodes of the

00:25:49,200 --> 00:25:54,080
combined method called graph

00:25:51,120 --> 00:25:55,039
for and look for those violations the

00:25:54,080 --> 00:25:57,840
next step

00:25:55,039 --> 00:26:00,240
in the next slide we talk about how this

00:25:57,840 --> 00:26:01,760
combined method called graph is prepared

00:26:00,240 --> 00:26:03,919
so you can see that we have the

00:26:01,760 --> 00:26:04,960
application x and it contains all the

00:26:03,919 --> 00:26:08,080
jar files so

00:26:04,960 --> 00:26:09,679
we assume that each jar file describe

00:26:08,080 --> 00:26:12,240
one micro services

00:26:09,679 --> 00:26:13,440
so here we in the discovery module we

00:26:12,240 --> 00:26:15,919
have the

00:26:13,440 --> 00:26:17,360
micro service a and micro service b and

00:26:15,919 --> 00:26:18,559
we have the method called separate

00:26:17,360 --> 00:26:21,520
method called graphs

00:26:18,559 --> 00:26:23,120
of those two micro services and then

00:26:21,520 --> 00:26:24,799
after the flow matcher module

00:26:23,120 --> 00:26:26,400
we have the rest interaction between

00:26:24,799 --> 00:26:28,400
these two microservices what

00:26:26,400 --> 00:26:30,000
is shown with the arrow and this is a

00:26:28,400 --> 00:26:32,799
get request

00:26:30,000 --> 00:26:35,120
as indicating in the arrow and then

00:26:32,799 --> 00:26:37,840
after the analysis module

00:26:35,120 --> 00:26:38,240
we perform aggregation and reduction and

00:26:37,840 --> 00:26:41,279
here

00:26:38,240 --> 00:26:43,679
you can see uh all the method called

00:26:41,279 --> 00:26:47,039
graphs are actually combined into one

00:26:43,679 --> 00:26:48,320
ah by analyzing or by using the rest

00:26:47,039 --> 00:26:50,559
interaction graph

00:26:48,320 --> 00:26:52,320
and in the next slide we talk about how

00:26:50,559 --> 00:26:53,360
we are performing the aggregation and

00:26:52,320 --> 00:26:56,559
reduction

00:26:53,360 --> 00:26:59,120
so here you can see uh

00:26:56,559 --> 00:26:59,919
in the role we have the controller

00:26:59,120 --> 00:27:02,880
method one

00:26:59,919 --> 00:27:05,039
which have role abc and the control

00:27:02,880 --> 00:27:07,600
method two which have role pq

00:27:05,039 --> 00:27:09,120
and in the after the reduction phase we

00:27:07,600 --> 00:27:12,320
just keep the lowest one

00:27:09,120 --> 00:27:13,360
that means uh c from abc and q from the

00:27:12,320 --> 00:27:16,799
pq

00:27:13,360 --> 00:27:18,720
uh based on the role hierarchy graph

00:27:16,799 --> 00:27:20,080
on the left and then after the

00:27:18,720 --> 00:27:22,720
aggregation phase we

00:27:20,080 --> 00:27:23,440
push down all the roles from the root to

00:27:22,720 --> 00:27:26,559
leaf

00:27:23,440 --> 00:27:29,919
and we also combined uh the role c

00:27:26,559 --> 00:27:33,279
and q in the repository method

00:27:29,919 --> 00:27:36,159
zero one here so here the repository

00:27:33,279 --> 00:27:38,720
methods 0 1 have the two

00:27:36,159 --> 00:27:39,279
different rows c and q and we can see

00:27:38,720 --> 00:27:41,200
that c

00:27:39,279 --> 00:27:42,640
and q are in the different sub tree of

00:27:41,200 --> 00:27:44,720
the roll hierarchy graph

00:27:42,640 --> 00:27:46,320
so we can call this as unrelated access

00:27:44,720 --> 00:27:48,159
violation

00:27:46,320 --> 00:27:49,760
and in the next slide we have a small

00:27:48,159 --> 00:27:52,960
demo how we are

00:27:49,760 --> 00:27:56,080
uh running this application to detect

00:27:52,960 --> 00:27:58,240
against a testbed so london can you just

00:27:56,080 --> 00:28:01,279
play it in the full screen

00:27:58,240 --> 00:28:03,520
yeah so here on the left uh we are

00:28:01,279 --> 00:28:04,880
running our application and on the right

00:28:03,520 --> 00:28:07,039
we will compile our

00:28:04,880 --> 00:28:09,039
micro services so this is a spring boot

00:28:07,039 --> 00:28:09,679
project so we just run maven string boot

00:28:09,039 --> 00:28:12,799
run

00:28:09,679 --> 00:28:13,760
and it will run our project on the 8080

00:28:12,799 --> 00:28:16,720
report

00:28:13,760 --> 00:28:18,320
and on the right we have the tms testbed

00:28:16,720 --> 00:28:21,760
this is the same testbed

00:28:18,320 --> 00:28:24,399
vincent was talking about so

00:28:21,760 --> 00:28:25,279
let's see what do we have inside this

00:28:24,399 --> 00:28:27,919
project

00:28:25,279 --> 00:28:28,880
so you can see we have four different

00:28:27,919 --> 00:28:33,039
microservices

00:28:28,880 --> 00:28:34,720
cms ems qms and ums all

00:28:33,039 --> 00:28:36,880
have separate folder and there is a

00:28:34,720 --> 00:28:37,600
build script so we just run this brilli

00:28:36,880 --> 00:28:40,000
script

00:28:37,600 --> 00:28:41,760
and it will prepare the jar files for

00:28:40,000 --> 00:28:44,320
each microservices

00:28:41,760 --> 00:28:46,399
so it will take some time to compile all

00:28:44,320 --> 00:28:48,799
those micro services only one

00:28:46,399 --> 00:28:49,760
and prepare the jar file for each micro

00:28:48,799 --> 00:28:52,080
services

00:28:49,760 --> 00:28:52,799
so as you can see we are building the

00:28:52,080 --> 00:28:56,240
cms

00:28:52,799 --> 00:28:59,600
and now it is building the ems project

00:28:56,240 --> 00:29:02,000
and then it is building the qms project

00:28:59,600 --> 00:29:02,799
so all four microservices are uh

00:29:02,000 --> 00:29:05,760
prepared

00:29:02,799 --> 00:29:06,240
uh for analysis and then we'll send just

00:29:05,760 --> 00:29:09,360
send a

00:29:06,240 --> 00:29:12,480
rest request and here we can see

00:29:09,360 --> 00:29:14,399
uh it is the past part to the jar files

00:29:12,480 --> 00:29:15,279
where all the micro services or all the

00:29:14,399 --> 00:29:17,919
jar files

00:29:15,279 --> 00:29:18,960
are located it's the same path here and

00:29:17,919 --> 00:29:21,440
then

00:29:18,960 --> 00:29:22,720
this organization path is actually used

00:29:21,440 --> 00:29:25,360
to filter out

00:29:22,720 --> 00:29:26,000
unnecessary or third party libraries

00:29:25,360 --> 00:29:28,320
because we just

00:29:26,000 --> 00:29:29,679
want to analyze our own project not the

00:29:28,320 --> 00:29:31,440
third part libraries

00:29:29,679 --> 00:29:34,320
and then in the security analyzer

00:29:31,440 --> 00:29:36,559
interface we define or we

00:29:34,320 --> 00:29:37,840
specify the role hierarchy graph as we

00:29:36,559 --> 00:29:40,080
saw earlier and

00:29:37,840 --> 00:29:41,520
in the output part is the where we

00:29:40,080 --> 00:29:44,799
actually generate the

00:29:41,520 --> 00:29:47,919
graphics file here we got the response

00:29:44,799 --> 00:29:49,520
uh from our application and all security

00:29:47,919 --> 00:29:51,279
method actually contains the

00:29:49,520 --> 00:29:53,520
metadata after aggregation and

00:29:51,279 --> 00:29:54,080
reductions so we are not actually

00:29:53,520 --> 00:29:55,600
interested

00:29:54,080 --> 00:29:57,440
in this we are mainly interested in the

00:29:55,600 --> 00:30:00,320
continuous violation here

00:29:57,440 --> 00:30:01,840
so as you can see the constant violation

00:30:00,320 --> 00:30:05,039
uh we have all those

00:30:01,840 --> 00:30:07,039
uh inconsistency or violation

00:30:05,039 --> 00:30:08,240
and here you can see the concrete

00:30:07,039 --> 00:30:11,360
configuration method

00:30:08,240 --> 00:30:14,880
have two rows admin and users and

00:30:11,360 --> 00:30:17,679
those are actually uh

00:30:14,880 --> 00:30:18,080
ancestor of each other so we call this

00:30:17,679 --> 00:30:22,000
uh

00:30:18,080 --> 00:30:25,120
hierarchy access violation and similarly

00:30:22,000 --> 00:30:27,360
in the find all configuration method

00:30:25,120 --> 00:30:28,880
we have moderator and user role after

00:30:27,360 --> 00:30:31,840
aggregation and reduction

00:30:28,880 --> 00:30:32,640
and these two moderator and users are

00:30:31,840 --> 00:30:34,399
actually

00:30:32,640 --> 00:30:36,320
in two different sub trees of the role

00:30:34,399 --> 00:30:39,840
hierarchy graph so we call this an

00:30:36,320 --> 00:30:42,799
unrelated access violation and finally

00:30:39,840 --> 00:30:44,720
uh let's see the output path it's in the

00:30:42,799 --> 00:30:47,039
download folder so just move into the

00:30:44,720 --> 00:30:49,039
download folder

00:30:47,039 --> 00:30:50,080
here you can see the grab this file is

00:30:49,039 --> 00:30:53,440
generated

00:30:50,080 --> 00:30:55,600
we'll open this and

00:30:53,440 --> 00:30:57,120
here's the graphics file we just

00:30:55,600 --> 00:30:59,120
visualize it

00:30:57,120 --> 00:31:01,840
and it will show the rest interaction

00:30:59,120 --> 00:31:03,519
graph among the microservices along with

00:31:01,840 --> 00:31:05,120
all other configurations so it is the

00:31:03,519 --> 00:31:07,760
same

00:31:05,120 --> 00:31:10,000
thing has been said was showing with uh

00:31:07,760 --> 00:31:12,240
with a little bit more details

00:31:10,000 --> 00:31:14,960
so thank you for watching this demo it's

00:31:12,240 --> 00:31:14,960
longer tweet

00:31:15,120 --> 00:31:21,600
apologies for that not sure why it's uh

00:31:19,440 --> 00:31:23,440
decided to act up on me um apparently

00:31:21,600 --> 00:31:26,640
it's the technical difficulty day

00:31:23,440 --> 00:31:27,039
um so uh we'd like to welcome uh andrew

00:31:26,640 --> 00:31:29,919
back

00:31:27,039 --> 00:31:32,480
uh to talk about code smells um and this

00:31:29,919 --> 00:31:33,440
one is a true test for me uh where we

00:31:32,480 --> 00:31:36,640
are gonna go

00:31:33,440 --> 00:31:37,279
rapidly through uh various uh code smell

00:31:36,640 --> 00:31:39,840
examples

00:31:37,279 --> 00:31:41,360
so uh andrew go ahead and take it away

00:31:39,840 --> 00:31:43,679
yeah thank you so

00:31:41,360 --> 00:31:45,360
it's always great to hear talking about

00:31:43,679 --> 00:31:46,080
you know very applicable things like

00:31:45,360 --> 00:31:49,279
security

00:31:46,080 --> 00:31:50,240
our back role consistency but i like to

00:31:49,279 --> 00:31:52,399
talk about

00:31:50,240 --> 00:31:53,679
things that aren't so perilous but

00:31:52,399 --> 00:31:55,279
equally as important

00:31:53,679 --> 00:31:56,880
and it's something that a lot of

00:31:55,279 --> 00:31:59,840
developers i think

00:31:56,880 --> 00:32:01,200
don't really take into consideration and

00:31:59,840 --> 00:32:03,440
that's code smells

00:32:01,200 --> 00:32:04,720
so i know no one really likes to deal

00:32:03,440 --> 00:32:05,919
with code smells

00:32:04,720 --> 00:32:07,840
because they're really this poor

00:32:05,919 --> 00:32:10,159
programming practice they don't really

00:32:07,840 --> 00:32:11,120
impact the functionality of an

00:32:10,159 --> 00:32:13,679
application

00:32:11,120 --> 00:32:14,559
but they do impact the reusability the

00:32:13,679 --> 00:32:17,039
testability

00:32:14,559 --> 00:32:18,799
and the maintainability and so it's

00:32:17,039 --> 00:32:19,279
something that people need to be aware

00:32:18,799 --> 00:32:21,200
of

00:32:19,279 --> 00:32:23,279
but it's often difficult to kind of lock

00:32:21,200 --> 00:32:26,399
them down and even more so

00:32:23,279 --> 00:32:26,399
in microservices

00:32:26,559 --> 00:32:31,440
the next slide yeah so micro services

00:32:29,120 --> 00:32:34,320
are kind of unique because not only does

00:32:31,440 --> 00:32:35,360
each individual module have all of your

00:32:34,320 --> 00:32:38,799
traditional

00:32:35,360 --> 00:32:40,480
code smells you also have micro service

00:32:38,799 --> 00:32:42,240
specific code smells

00:32:40,480 --> 00:32:44,799
that deal with kind of the interaction

00:32:42,240 --> 00:32:45,840
of the modules and not just the code

00:32:44,799 --> 00:32:49,440
within them

00:32:45,840 --> 00:32:50,960
and so traditional tools really can't

00:32:49,440 --> 00:32:53,360
work on these because

00:32:50,960 --> 00:32:55,039
you need a way of generating a holistic

00:32:53,360 --> 00:32:57,200
view of the application

00:32:55,039 --> 00:32:58,240
in order to find these so that's where

00:32:57,200 --> 00:33:00,559
our sar

00:32:58,240 --> 00:33:01,760
process comes in and we're actually able

00:33:00,559 --> 00:33:04,320
to find them

00:33:01,760 --> 00:33:06,080
so i want to go through the 11 code

00:33:04,320 --> 00:33:09,039
smells that we detect

00:33:06,080 --> 00:33:10,799
and hopefully you recognize them but

00:33:09,039 --> 00:33:12,559
don't think to yourself oh

00:33:10,799 --> 00:33:14,480
this is something that i just did on the

00:33:12,559 --> 00:33:15,760
application i'm working on

00:33:14,480 --> 00:33:18,320
but i just want to demonstrate that

00:33:15,760 --> 00:33:22,080
these are things that are important

00:33:18,320 --> 00:33:25,039
and can be found with our process

00:33:22,080 --> 00:33:26,559
so to kick things off we have enterprise

00:33:25,039 --> 00:33:29,200
service bus usage

00:33:26,559 --> 00:33:30,640
i know esps used to be fairly popular

00:33:29,200 --> 00:33:31,600
back in like service oriented

00:33:30,640 --> 00:33:34,399
architecture

00:33:31,600 --> 00:33:35,760
but now they are considered bad practice

00:33:34,399 --> 00:33:38,159
they provide a

00:33:35,760 --> 00:33:39,840
pretty single point of failure which is

00:33:38,159 --> 00:33:43,039
not something that we want so you want

00:33:39,840 --> 00:33:43,039
to avoid using those

00:33:43,360 --> 00:33:46,480
we have too many standards kind of like

00:33:45,120 --> 00:33:47,440
what i was mentioning previously you

00:33:46,480 --> 00:33:50,080
know you can

00:33:47,440 --> 00:33:51,600
have anything you want to implement your

00:33:50,080 --> 00:33:53,120
different microservices

00:33:51,600 --> 00:33:54,880
but at a certain point you may be

00:33:53,120 --> 00:33:55,919
getting too diverse and you need to kind

00:33:54,880 --> 00:33:57,360
of reign it back

00:33:55,919 --> 00:34:00,000
so that it's more seamless for your

00:33:57,360 --> 00:34:02,960
developers

00:34:00,000 --> 00:34:03,360
wrong cuts is kind of a tricky one it's

00:34:02,960 --> 00:34:06,080
where

00:34:03,360 --> 00:34:06,880
your micro services are cut along the

00:34:06,080 --> 00:34:09,119
presentation

00:34:06,880 --> 00:34:09,919
business and data layers of an

00:34:09,119 --> 00:34:12,159
application

00:34:09,919 --> 00:34:13,599
instead of by feature so you really want

00:34:12,159 --> 00:34:14,720
to make sure that they're cut along the

00:34:13,599 --> 00:34:17,440
features and each

00:34:14,720 --> 00:34:18,639
microservice has its own presentation

00:34:17,440 --> 00:34:23,200
business and data

00:34:18,639 --> 00:34:24,560
within it not having an api gateway is

00:34:23,200 --> 00:34:26,399
another big one

00:34:24,560 --> 00:34:27,760
now if it's a really small application

00:34:26,399 --> 00:34:29,839
you're probably fine

00:34:27,760 --> 00:34:30,960
but research has shown that over 50

00:34:29,839 --> 00:34:33,040
microservices

00:34:30,960 --> 00:34:35,440
and developers are no longer able to

00:34:33,040 --> 00:34:37,280
accurately keep track of the system

00:34:35,440 --> 00:34:38,560
so at that point you want to start using

00:34:37,280 --> 00:34:42,240
an api gateway

00:34:38,560 --> 00:34:45,200
just to make it simpler on everyone

00:34:42,240 --> 00:34:46,399
api versioning you should be versioning

00:34:45,200 --> 00:34:48,639
your apis

00:34:46,399 --> 00:34:49,760
it's helpful for everyone involved you

00:34:48,639 --> 00:34:52,399
know qa

00:34:49,760 --> 00:34:53,679
deployment users developers everyone

00:34:52,399 --> 00:34:56,960
benefits from

00:34:53,679 --> 00:34:56,960
having a versioned api

00:34:57,280 --> 00:35:01,920
microservice greedy is another

00:34:59,599 --> 00:35:02,320
interesting one it's a little subjective

00:35:01,920 --> 00:35:04,960
it's

00:35:02,320 --> 00:35:06,560
where you have so many tiny

00:35:04,960 --> 00:35:08,800
microservices

00:35:06,560 --> 00:35:10,400
that it gets to be a little unwieldy and

00:35:08,800 --> 00:35:12,160
it would be better to just kind of

00:35:10,400 --> 00:35:15,119
aggregate a couple of them

00:35:12,160 --> 00:35:16,240
into some larger microservices that are

00:35:15,119 --> 00:35:19,520
better suited

00:35:16,240 --> 00:35:19,520
and easier to manage

00:35:19,760 --> 00:35:23,760
shared persistency is where two

00:35:21,760 --> 00:35:27,440
different microservices are accessing

00:35:23,760 --> 00:35:27,440
the same data in a database

00:35:29,440 --> 00:35:33,760
hard-coded endpoints is when you hard

00:35:31,839 --> 00:35:36,400
code an endpoint that you call

00:35:33,760 --> 00:35:37,040
um specifically around stuff like ip and

00:35:36,400 --> 00:35:38,720
port

00:35:37,040 --> 00:35:40,480
because once you start deploying that

00:35:38,720 --> 00:35:41,280
can always change and it's something

00:35:40,480 --> 00:35:44,400
that

00:35:41,280 --> 00:35:47,040
is way too brittle for a real enterprise

00:35:44,400 --> 00:35:47,040
application

00:35:47,200 --> 00:35:50,640
inappropriate service intimacy is kind

00:35:49,839 --> 00:35:52,880
of similar

00:35:50,640 --> 00:35:55,040
to shared persistency but it's a little

00:35:52,880 --> 00:35:56,800
different it's where each microservice

00:35:55,040 --> 00:35:59,680
has its own database

00:35:56,800 --> 00:36:00,800
but one of them is also accessing some

00:35:59,680 --> 00:36:03,520
private data

00:36:00,800 --> 00:36:05,599
within another's database and usually

00:36:03,520 --> 00:36:06,400
this is done just because it's the easy

00:36:05,599 --> 00:36:08,320
way out

00:36:06,400 --> 00:36:10,240
and developers are lazy and don't want

00:36:08,320 --> 00:36:11,359
to write the proper channels to get that

00:36:10,240 --> 00:36:13,440
data

00:36:11,359 --> 00:36:16,560
but this one in particular is really bad

00:36:13,440 --> 00:36:16,560
and you want to avoid it

00:36:16,880 --> 00:36:20,560
shared libraries is another where if a

00:36:19,760 --> 00:36:23,119
lot of

00:36:20,560 --> 00:36:25,359
microservices are using the same library

00:36:23,119 --> 00:36:26,720
it might be better suited to be deployed

00:36:25,359 --> 00:36:28,960
as its own

00:36:26,720 --> 00:36:31,359
microservice and then could be scaled as

00:36:28,960 --> 00:36:31,359
needed

00:36:32,560 --> 00:36:36,480
cyclic dependency is super

00:36:34,839 --> 00:36:39,599
self-explanatory it's where

00:36:36,480 --> 00:36:43,440
your chain of api calls winds up making

00:36:39,599 --> 00:36:43,440
a cycle between microservices

00:36:44,320 --> 00:36:48,880
and that's all 11 of them again

00:36:47,040 --> 00:36:50,560
hopefully you recognize them but don't

00:36:48,880 --> 00:36:52,079
think that you've implemented any of

00:36:50,560 --> 00:36:54,240
them recently

00:36:52,079 --> 00:36:55,119
if you want to check we do have a

00:36:54,240 --> 00:36:58,880
publicly

00:36:55,119 --> 00:37:01,440
open source tool called msa nodes at our

00:36:58,880 --> 00:37:02,720
labs github repository you know and we

00:37:01,440 --> 00:37:05,520
always welcome

00:37:02,720 --> 00:37:06,640
feedback and pull requests and you know

00:37:05,520 --> 00:37:09,119
anything like that

00:37:06,640 --> 00:37:10,960
so with that i'm going to turn it back

00:37:09,119 --> 00:37:13,200
over to linkedin

00:37:10,960 --> 00:37:15,040
thanks so much um i don't think i

00:37:13,200 --> 00:37:17,839
screwed it up too badly so that's nice

00:37:15,040 --> 00:37:18,320
um and uh so what we'd like to do is uh

00:37:17,839 --> 00:37:21,599
welcome

00:37:18,320 --> 00:37:22,800
our next speaker um so uh michael why

00:37:21,599 --> 00:37:24,640
don't you tell us a little bit about

00:37:22,800 --> 00:37:26,720
uh why you're at baylor or what you're

00:37:24,640 --> 00:37:29,040
doing at baylor

00:37:26,720 --> 00:37:30,800
yeah so i'm actually in my first year of

00:37:29,040 --> 00:37:31,760
uh the graduate program at baylor

00:37:30,800 --> 00:37:34,079
university

00:37:31,760 --> 00:37:35,520
i actually just graduated there last may

00:37:34,079 --> 00:37:37,680
with my undergrad

00:37:35,520 --> 00:37:39,280
i was in the same class as andrew and so

00:37:37,680 --> 00:37:41,119
i decided to come back and

00:37:39,280 --> 00:37:42,560
learn a little more from dr cherny and

00:37:41,119 --> 00:37:44,800
the rest of the people at baylor

00:37:42,560 --> 00:37:47,119
do it all again uh so what attracted you

00:37:44,800 --> 00:37:50,079
to uh this particular project

00:37:47,119 --> 00:37:50,720
yeah so um in my undergrad um andrew and

00:37:50,079 --> 00:37:54,640
i

00:37:50,720 --> 00:37:56,640
uh we began study on uh the limitations

00:37:54,640 --> 00:37:59,280
of static code analysis

00:37:56,640 --> 00:38:00,320
and so i i really got intrigued by that

00:37:59,280 --> 00:38:02,240
especially since

00:38:00,320 --> 00:38:03,359
a lot of people don't really use static

00:38:02,240 --> 00:38:04,960
code analysis at least

00:38:03,359 --> 00:38:06,960
not as much as they should be using in

00:38:04,960 --> 00:38:08,800
their software

00:38:06,960 --> 00:38:10,400
and uh it's because of these limitations

00:38:08,800 --> 00:38:13,200
that are present

00:38:10,400 --> 00:38:14,400
and so from this i was able to branch

00:38:13,200 --> 00:38:16,240
out and

00:38:14,400 --> 00:38:19,200
kind of look at the limitations of the

00:38:16,240 --> 00:38:20,480
static analysis tools over microservices

00:38:19,200 --> 00:38:22,160
which is what i'll be talking to you

00:38:20,480 --> 00:38:24,400
guys about today

00:38:22,160 --> 00:38:26,800
cool yeah so uh why don't you go ahead

00:38:24,400 --> 00:38:28,880
and take it away and uh tell us about uh

00:38:26,800 --> 00:38:31,440
the work you're you're planning on doing

00:38:28,880 --> 00:38:34,560
for your i think for your masters right

00:38:31,440 --> 00:38:36,800
yes sir all right yeah

00:38:34,560 --> 00:38:39,599
so as i just said with landon there are

00:38:36,800 --> 00:38:41,280
limitations in static code analysis

00:38:39,599 --> 00:38:43,520
here i'm focusing on the limitations of

00:38:41,280 --> 00:38:44,800
static application security testing over

00:38:43,520 --> 00:38:46,720
microservices

00:38:44,800 --> 00:38:49,359
so static application security testing

00:38:46,720 --> 00:38:50,240
is used to find vulnerabilities in

00:38:49,359 --> 00:38:52,240
software

00:38:50,240 --> 00:38:54,160
however this foreign testing is not

00:38:52,240 --> 00:38:56,640
enough to gain coverage of security

00:38:54,160 --> 00:38:58,400
vulnerabilities in microservices

00:38:56,640 --> 00:39:00,320
so since the static application security

00:38:58,400 --> 00:39:02,560
testing only looks

00:39:00,320 --> 00:39:04,000
at the source code of software it can

00:39:02,560 --> 00:39:04,800
miss potential vulnerabilities that

00:39:04,000 --> 00:39:07,040
might exist

00:39:04,800 --> 00:39:08,000
due to the communication between modules

00:39:07,040 --> 00:39:10,640
that is present

00:39:08,000 --> 00:39:11,599
in a microservice architecture due to

00:39:10,640 --> 00:39:14,480
this limitation

00:39:11,599 --> 00:39:16,079
developers are required to use dynamic

00:39:14,480 --> 00:39:18,560
application security testing to find the

00:39:16,079 --> 00:39:21,760
vulnerabilities that the static form

00:39:18,560 --> 00:39:23,040
were unable to detect so the problem

00:39:21,760 --> 00:39:24,560
with this is that

00:39:23,040 --> 00:39:26,720
is that the dynamic application security

00:39:24,560 --> 00:39:27,359
testing is a much more costly form of

00:39:26,720 --> 00:39:29,119
testing

00:39:27,359 --> 00:39:31,040
than static application security testing

00:39:29,119 --> 00:39:32,960
due to its dynamic nature

00:39:31,040 --> 00:39:34,960
so that is why we've begun research to

00:39:32,960 --> 00:39:38,000
find a way to limit this need

00:39:34,960 --> 00:39:39,440
for dynamic outpatient security testing

00:39:38,000 --> 00:39:41,119
so in order to limit this need we need

00:39:39,440 --> 00:39:42,720
to we have found

00:39:41,119 --> 00:39:44,800
that we can combine static application

00:39:42,720 --> 00:39:46,960
security testing with

00:39:44,800 --> 00:39:48,560
software architecture reconstruction in

00:39:46,960 --> 00:39:50,000
order to gain more coverage of the

00:39:48,560 --> 00:39:51,280
security vulnerabilities that might

00:39:50,000 --> 00:39:52,880
become present

00:39:51,280 --> 00:39:55,119
due to microservice and

00:39:52,880 --> 00:39:57,520
interconnectivity

00:39:55,119 --> 00:39:59,119
so we plan on combining the profit tool

00:39:57,520 --> 00:40:00,960
that we've discussed earlier

00:39:59,119 --> 00:40:02,720
with the fabricate analytics quality

00:40:00,960 --> 00:40:04,000
assurance tool in order to achieve this

00:40:02,720 --> 00:40:05,680
goal

00:40:04,000 --> 00:40:07,119
so the fabricates analytics the

00:40:05,680 --> 00:40:07,599
fabricate analytics quality assurance

00:40:07,119 --> 00:40:10,319
tool

00:40:07,599 --> 00:40:11,760
acts as a framework for static code

00:40:10,319 --> 00:40:13,359
analysis tools

00:40:11,760 --> 00:40:15,920
which will allow us to customize our

00:40:13,359 --> 00:40:17,520
testing to get the best coverage

00:40:15,920 --> 00:40:20,480
out of the static application security

00:40:17,520 --> 00:40:22,880
testing tools that we are using

00:40:20,480 --> 00:40:24,240
now in this study we intend on showing

00:40:22,880 --> 00:40:26,640
how this combination

00:40:24,240 --> 00:40:28,160
can limit the need for the costly

00:40:26,640 --> 00:40:29,200
dynamic application security testing

00:40:28,160 --> 00:40:32,160
that

00:40:29,200 --> 00:40:34,240
i mentioned earlier so like like

00:40:32,160 --> 00:40:36,000
landings landon said this is just

00:40:34,240 --> 00:40:38,000
preliminary research that we've begun

00:40:36,000 --> 00:40:40,319
over this and i'm excited

00:40:38,000 --> 00:40:41,920
and uh trying to figure out exactly how

00:40:40,319 --> 00:40:46,960
this is going to work

00:40:41,920 --> 00:40:46,960
and and uh writing up this for my thesis

00:40:47,599 --> 00:40:52,880
awesome uh thanks so much um

00:40:50,640 --> 00:40:55,280
so i think that was pretty much the kind

00:40:52,880 --> 00:40:58,079
of content we kind of had for you today

00:40:55,280 --> 00:40:59,359
uh and we are basically over time so uh

00:40:58,079 --> 00:41:01,920
i wanted to

00:40:59,359 --> 00:41:02,960
uh welcome uh dr cherny back to the

00:41:01,920 --> 00:41:06,000
stage for a minute

00:41:02,960 --> 00:41:08,640
um just to kind of say hey you know

00:41:06,000 --> 00:41:10,240
as per all open source looking for pr's

00:41:08,640 --> 00:41:11,119
looking for more people to get involved

00:41:10,240 --> 00:41:14,000
please do

00:41:11,119 --> 00:41:14,720
uh and uh you know dr cherney do you

00:41:14,000 --> 00:41:17,040
want to uh

00:41:14,720 --> 00:41:19,280
kind of give your plea for how how

00:41:17,040 --> 00:41:21,040
awesome this could be

00:41:19,280 --> 00:41:22,640
oh yeah i would like to thank everyone

00:41:21,040 --> 00:41:25,760
that they joined us today and

00:41:22,640 --> 00:41:26,640
of course you know get your hands on i'm

00:41:25,760 --> 00:41:28,560
sure that you are

00:41:26,640 --> 00:41:30,640
bored with what you have been doing

00:41:28,560 --> 00:41:33,119
let's say for a couple of

00:41:30,640 --> 00:41:34,560
months and if you have a friday

00:41:33,119 --> 00:41:36,319
afternoon of

00:41:34,560 --> 00:41:38,079
anything like that you could join us we

00:41:36,319 --> 00:41:39,200
would be very happy we are looking for

00:41:38,079 --> 00:41:41,760
collaborators

00:41:39,200 --> 00:41:42,319
you can participate on the grounds as a

00:41:41,760 --> 00:41:44,960
as

00:41:42,319 --> 00:41:47,599
some advanced collaborator who has the

00:41:44,960 --> 00:41:50,880
technical knowledge who is exposed to

00:41:47,599 --> 00:41:53,280
practice we would love to help

00:41:50,880 --> 00:41:54,800
your health and work with you on some

00:41:53,280 --> 00:41:57,119
tasks that you perhaps

00:41:54,800 --> 00:41:58,560
can define so you can come and say hey

00:41:57,119 --> 00:42:00,240
guys you know we don't really have time

00:41:58,560 --> 00:42:01,280
to do that but i think this would be a

00:42:00,240 --> 00:42:04,079
great project

00:42:01,280 --> 00:42:05,040
what we also have been doing is to

00:42:04,079 --> 00:42:07,760
employ some

00:42:05,040 --> 00:42:09,599
redhead volunteers as a co-supervisor so

00:42:07,760 --> 00:42:11,920
i have been working with

00:42:09,599 --> 00:42:12,720
multiple of you uh already on some

00:42:11,920 --> 00:42:15,119
projects

00:42:12,720 --> 00:42:16,720
that you are doing and we had summer

00:42:15,119 --> 00:42:18,400
surgery that we are doing with red hat

00:42:16,720 --> 00:42:20,480
which is very exciting and in fact

00:42:18,400 --> 00:42:21,920
andrew and michael came from from that

00:42:20,480 --> 00:42:24,079
sort of incubation

00:42:21,920 --> 00:42:24,960
uh of uh being good developers

00:42:24,079 --> 00:42:26,720
eventually

00:42:24,960 --> 00:42:28,480
and we are looking for transition to

00:42:26,720 --> 00:42:30,880
practice so all these things

00:42:28,480 --> 00:42:31,839
really just reach out we will be more

00:42:30,880 --> 00:42:35,280
than happy and

00:42:31,839 --> 00:42:37,680
there is never a bad idea there is never

00:42:35,280 --> 00:42:39,599
a bad question

00:42:37,680 --> 00:42:41,280
uh so thanks so much for giving the talk

00:42:39,599 --> 00:42:43,359
um as i said we're pretty much out of

00:42:41,280 --> 00:42:45,520
time so if you had any questions

00:42:43,359 --> 00:42:46,640
please try to find us either on kind of

00:42:45,520 --> 00:42:49,520
the general chat

00:42:46,640 --> 00:42:50,880
inside hop in which i know is kind of

00:42:49,520 --> 00:42:53,760
rough

00:42:50,880 --> 00:42:54,800
or if you can find us in the keynote

00:42:53,760 --> 00:42:58,400
questions

00:42:54,800 --> 00:42:58,800
channel in discord um there's so many

00:42:58,400 --> 00:43:00,800
now

00:42:58,800 --> 00:43:02,400
instant messaging platforms that uh i

00:43:00,800 --> 00:43:03,760
have to think about which one i'm

00:43:02,400 --> 00:43:07,040
currently talking about

00:43:03,760 --> 00:43:08,960
um so in the discord uh i will at least

00:43:07,040 --> 00:43:10,880
be there or we can follow up with

00:43:08,960 --> 00:43:13,440
any questions that you might have later

00:43:10,880 --> 00:43:15,440
um and i would also like to thank the

00:43:13,440 --> 00:43:17,599
presentation and power gods that we just

00:43:15,440 --> 00:43:20,000
had a couple of technical difficulties

00:43:17,599 --> 00:43:21,200
all of our speakers were in texas uh

00:43:20,000 --> 00:43:22,960
which is currently having rolling

00:43:21,200 --> 00:43:25,520
blackouts in a lot of places uh

00:43:22,960 --> 00:43:26,000
so i am very happy that we were able to

00:43:25,520 --> 00:43:27,520
be this

00:43:26,000 --> 00:43:29,599
successful even if we had a couple of

00:43:27,520 --> 00:43:30,000
challenges uh so thanks so much for your

00:43:29,599 --> 00:43:31,680
time

00:43:30,000 --> 00:43:34,079
and uh we hope you enjoy the rest of

00:43:31,680 --> 00:43:37,280
devconf uh don't forget to uh

00:43:34,079 --> 00:43:40,079
participate in the kind of extra events

00:43:37,280 --> 00:43:40,880
you know as well as going to the talks

00:43:40,079 --> 00:43:44,160
you know and

00:43:40,880 --> 00:43:53,119
get your yoga on and we'll see you

00:43:44,160 --> 00:43:53,119

YouTube URL: https://www.youtube.com/watch?v=tnqxGqIu9So


