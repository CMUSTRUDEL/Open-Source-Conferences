Title: 2020: Identify map problems in OSM by connectivity check
Publication date: 2020-07-18
Playlist: State of the Map 2020
Description: 
	https://media.ccc.de/v/sotm2020-4341-identify-map-problems-in-osm-by-connectivity-check



In an ideal map, every point is reachable to another. However, in OSM data for instance, only 98.59% of Singapore’s nodes are reachable to each other by a path. In this talk, we identify OSM map problems by checking the connectivity of the road network using strongly connected component algorithms and introduce a creative visualisation to help map ops pinpoint the fix effortlessly. Using this approach, we have fixed thousands of map problems in SEA.

In an ideal map, every point is reachable to another. Like any crowd-sourced product, it is a challenging goal for OSM to be ideal because the edits are from contributors with various backgrounds. For instance, only 98.59% of Singapore’s nodes are reachable to each other. This could cause significant problems when routing from one point to another for any business use case. In June 2019, some contributor mistakenly tagged one of the five major expressways  in Singapore with Access=No, which subsequently caused all the routing through the expressway to fail. 

In this talk, we address the issue  by using strongly connected component algorithms to identify such map problems and building a creative visualisation to help map analysts pinpoint the fix effortlessly. Using this technique, we identify map errors such as two one-way roads meeting each other with opposite directions;  duplicate nodes causing roads disconnected; parking lots not connected to main road network and more. The detected map errors spread everywhere on the map that motivates us to build a creative visualisation to help map analysts pinpoint the erroneous nodes/ways. Using this approach, we have fixed thousands of map problems in SEA.

Evan Hossain

https://2020.stateofthemap.org/sessions/URVEBF/
Captions: 
	00:00:07,839 --> 00:00:10,400
welcome

00:00:08,480 --> 00:00:11,920
welcome back everybody welcome back to

00:00:10,400 --> 00:00:15,200
this session of

00:00:11,920 --> 00:00:17,840
the of the early finish morning

00:00:15,200 --> 00:00:18,640
i'm going to to introduce the the these

00:00:17,840 --> 00:00:21,039
talks

00:00:18,640 --> 00:00:23,039
the talks is about is done by evan ossin

00:00:21,039 --> 00:00:25,599
this is a senior software engineering at

00:00:23,039 --> 00:00:26,560
grab i remind you that if you have

00:00:25,599 --> 00:00:28,480
questions

00:00:26,560 --> 00:00:29,679
for during the talk don't wait at the

00:00:28,480 --> 00:00:32,079
end of the talk

00:00:29,679 --> 00:00:33,760
and also make your question during the

00:00:32,079 --> 00:00:35,520
talk at the part that you can find on

00:00:33,760 --> 00:00:38,960
the program webpage

00:00:35,520 --> 00:00:41,280
and the talk that was carried by aviano

00:00:38,960 --> 00:00:42,399
even will be focused on the use of

00:00:41,280 --> 00:00:44,879
algorithm

00:00:42,399 --> 00:00:46,239
of to identify some prob some map

00:00:44,879 --> 00:00:49,360
problem and issue

00:00:46,239 --> 00:00:53,760
if there are related to the routing

00:00:49,360 --> 00:00:55,920
hi i am ivan i am currently working as a

00:00:53,760 --> 00:00:58,559
software engineer at graph

00:00:55,920 --> 00:01:00,399
today i am going to talk about how we

00:00:58,559 --> 00:01:04,320
identify map problems

00:01:00,399 --> 00:01:04,320
in warsam by connectivity check

00:01:06,000 --> 00:01:10,400
grab has been relying on open state map

00:01:08,560 --> 00:01:13,439
for various things

00:01:10,400 --> 00:01:16,000
like improving eta accuracy calculating

00:01:13,439 --> 00:01:18,159
electronic road pricing etc

00:01:16,000 --> 00:01:19,600
we are also enriching osm and the

00:01:18,159 --> 00:01:22,080
community

00:01:19,600 --> 00:01:24,000
by adding and updating roads

00:01:22,080 --> 00:01:27,040
collaborating with contributors like

00:01:24,000 --> 00:01:28,560
openstreetcam and mobility for street

00:01:27,040 --> 00:01:31,920
level imagery

00:01:28,560 --> 00:01:34,479
organizing my python-like events and

00:01:31,920 --> 00:01:36,880
all of this in a large scale across

00:01:34,479 --> 00:01:39,680
southeast asia

00:01:36,880 --> 00:01:41,680
and in this process sometimes we

00:01:39,680 --> 00:01:45,759
encounter certain problems

00:01:41,680 --> 00:01:45,759
and opportunities to improve osm

00:01:46,399 --> 00:01:49,840
routing failure in osm is one of those

00:01:48,880 --> 00:01:52,720
problems we

00:01:49,840 --> 00:01:52,720
see at times

00:01:53,600 --> 00:01:57,200
ideally we expect osm to completely

00:01:56,560 --> 00:02:01,280
reflect

00:01:57,200 --> 00:02:03,119
real world map and as in real world

00:02:01,280 --> 00:02:06,560
we should be able to find a route

00:02:03,119 --> 00:02:08,959
between any two places in osm

00:02:06,560 --> 00:02:10,640
in other words each place should be

00:02:08,959 --> 00:02:14,000
reachable from any other place

00:02:10,640 --> 00:02:17,120
on the map but unfortunately

00:02:14,000 --> 00:02:20,840
that's not always true osm is

00:02:17,120 --> 00:02:22,319
not quite reflecting the real world map

00:02:20,840 --> 00:02:24,480
yet

00:02:22,319 --> 00:02:25,520
this sometimes results in incorrect

00:02:24,480 --> 00:02:29,200
route

00:02:25,520 --> 00:02:32,080
and even no route at all at some cases

00:02:29,200 --> 00:02:32,879
meaning there is no way to get from for

00:02:32,080 --> 00:02:36,080
example plus

00:02:32,879 --> 00:02:37,680
a to place b this can

00:02:36,080 --> 00:02:39,599
cause fallback to other options

00:02:37,680 --> 00:02:42,720
depending on the use cases

00:02:39,599 --> 00:02:43,280
for example if we want estimated time of

00:02:42,720 --> 00:02:46,000
travel

00:02:43,280 --> 00:02:46,640
from place a to place b straight line

00:02:46,000 --> 00:02:48,720
distance

00:02:46,640 --> 00:02:50,400
might be used in case of a failure to

00:02:48,720 --> 00:02:52,640
find the route

00:02:50,400 --> 00:02:55,120
we notice these problems from different

00:02:52,640 --> 00:02:55,120
places

00:02:56,080 --> 00:02:59,120
two of the major sources indicating

00:02:58,000 --> 00:03:01,599
these issues

00:02:59,120 --> 00:03:03,680
are tracking related business metrics

00:03:01,599 --> 00:03:05,840
and regular monitoring by our operations

00:03:03,680 --> 00:03:05,840
team

00:03:06,080 --> 00:03:12,720
so why do these problems exist actually

00:03:09,040 --> 00:03:12,720
there could be several reasons behind

00:03:13,040 --> 00:03:18,239
like human error and in this case

00:03:16,080 --> 00:03:21,920
most common one is probably putting

00:03:18,239 --> 00:03:21,920
wrong direction of travel by mistake

00:03:22,400 --> 00:03:27,120
poor outdated or no satellite images in

00:03:25,120 --> 00:03:29,680
some cases

00:03:27,120 --> 00:03:30,720
and of course even though osm community

00:03:29,680 --> 00:03:33,680
is large

00:03:30,720 --> 00:03:36,319
it's finite there is so much we can

00:03:33,680 --> 00:03:38,159
update with manual effort only

00:03:36,319 --> 00:03:41,280
let's look at some examples to better

00:03:38,159 --> 00:03:41,280
understand these cases

00:03:42,959 --> 00:03:48,400
here is an example of a human error one

00:03:46,159 --> 00:03:50,159
of this direction has to be wrong

00:03:48,400 --> 00:03:52,799
we call this scenario wrong direction of

00:03:50,159 --> 00:03:52,799
travel error

00:03:54,159 --> 00:03:59,360
this one is little more tricky it's not

00:03:57,200 --> 00:04:01,680
really obvious from the satellite image

00:03:59,360 --> 00:04:04,080
if there are roads connecting these

00:04:01,680 --> 00:04:06,319
existing road segments or not

00:04:04,080 --> 00:04:09,360
of course it's okay to have incomplete

00:04:06,319 --> 00:04:11,840
map where we need further verification

00:04:09,360 --> 00:04:12,480
but how do we know that this part

00:04:11,840 --> 00:04:15,840
perhaps

00:04:12,480 --> 00:04:17,680
needs verification later we want to

00:04:15,840 --> 00:04:19,919
bring all these latent problems to the

00:04:17,680 --> 00:04:19,919
front

00:04:21,040 --> 00:04:24,320
looking at the problems and probable

00:04:23,120 --> 00:04:28,560
root causes

00:04:24,320 --> 00:04:31,360
we have come up with couple of goals

00:04:28,560 --> 00:04:33,440
first we want to automatically identify

00:04:31,360 --> 00:04:35,440
why some places are not reachable from

00:04:33,440 --> 00:04:38,240
others

00:04:35,440 --> 00:04:39,360
then we need to find a way for our

00:04:38,240 --> 00:04:43,840
operations team

00:04:39,360 --> 00:04:43,840
to take a look and fix those problems

00:04:43,919 --> 00:04:49,280
here is a visual of the end goal we want

00:04:47,120 --> 00:04:49,919
to bring the red circular area to our

00:04:49,280 --> 00:04:53,199
attention

00:04:49,919 --> 00:04:56,080
and fix it if it doesn't make sense

00:04:53,199 --> 00:04:57,840
at this moment don't worry this picture

00:04:56,080 --> 00:05:00,080
will come at a later point again

00:04:57,840 --> 00:05:02,400
and hopefully then we can easily relate

00:05:00,080 --> 00:05:02,400
to this

00:05:03,039 --> 00:05:08,000
now our biggest challenge is how do we

00:05:05,520 --> 00:05:10,320
find these problems

00:05:08,000 --> 00:05:12,720
enumerating all possible pair of places

00:05:10,320 --> 00:05:14,240
and checking if they are routable or not

00:05:12,720 --> 00:05:17,039
is not an option

00:05:14,240 --> 00:05:18,479
that will take forever we need a

00:05:17,039 --> 00:05:22,320
deterministic solution

00:05:18,479 --> 00:05:22,320
which is reasonably fast as well

00:05:23,120 --> 00:05:26,960
as a result we have come up with this

00:05:25,199 --> 00:05:30,000
hypothesis

00:05:26,960 --> 00:05:31,600
as routing failures are rare we know

00:05:30,000 --> 00:05:34,800
that majority of the places

00:05:31,600 --> 00:05:37,360
are routable from each other if we can

00:05:34,800 --> 00:05:39,680
group these routable process together

00:05:37,360 --> 00:05:41,600
and visualize on the map we should be

00:05:39,680 --> 00:05:44,479
able to see where the remaining parts

00:05:41,600 --> 00:05:44,479
are disconnected

00:05:45,120 --> 00:05:49,440
let's look at the picture on the right

00:05:46,720 --> 00:05:51,440
to better understand this claim

00:05:49,440 --> 00:05:52,960
the pink section in the image is the

00:05:51,440 --> 00:05:55,520
routable group

00:05:52,960 --> 00:05:58,319
meaning any two places in pink are

00:05:55,520 --> 00:06:00,560
reachable from one another

00:05:58,319 --> 00:06:01,919
and the green section is not reachable

00:06:00,560 --> 00:06:05,520
from any pink section

00:06:01,919 --> 00:06:07,680
or vice versa as you can see some

00:06:05,520 --> 00:06:09,600
island-like places in green are not

00:06:07,680 --> 00:06:12,880
routable from pink section

00:06:09,600 --> 00:06:13,199
which is not surprising but there are

00:06:12,880 --> 00:06:16,720
some

00:06:13,199 --> 00:06:19,120
other green places which seem suspicious

00:06:16,720 --> 00:06:20,160
so the goal is to have this few

00:06:19,120 --> 00:06:22,880
investigate

00:06:20,160 --> 00:06:23,199
and fix those suspicious places rather

00:06:22,880 --> 00:06:24,960
than

00:06:23,199 --> 00:06:27,360
exhaustively looking at all possible

00:06:24,960 --> 00:06:27,360
routes

00:06:28,639 --> 00:06:32,800
before diving deeper into how we have

00:06:30,720 --> 00:06:34,800
developed this process

00:06:32,800 --> 00:06:36,720
it's important to get familiar with some

00:06:34,800 --> 00:06:38,240
terminologies

00:06:36,720 --> 00:06:41,680
which are required to have clear

00:06:38,240 --> 00:06:41,680
understanding of our methods

00:06:42,000 --> 00:06:46,000
starting with directed graph a directed

00:06:45,520 --> 00:06:48,080
graph

00:06:46,000 --> 00:06:49,360
is a set of nodes that are connected

00:06:48,080 --> 00:06:51,360
together

00:06:49,360 --> 00:06:53,520
where all edges are directed from one

00:06:51,360 --> 00:06:55,280
vertex to another

00:06:53,520 --> 00:06:58,560
here on the right side we have an

00:06:55,280 --> 00:06:58,560
example of a directed graph

00:07:00,400 --> 00:07:04,880
next is strongly connected component or

00:07:02,880 --> 00:07:07,599
scc in short

00:07:04,880 --> 00:07:08,000
a directed graph is strongly connected

00:07:07,599 --> 00:07:10,080
if

00:07:08,000 --> 00:07:11,520
there is path between any pairs of

00:07:10,080 --> 00:07:13,840
vertices

00:07:11,520 --> 00:07:16,720
the parts which are strongly connected

00:07:13,840 --> 00:07:18,960
are called strongly connected components

00:07:16,720 --> 00:07:20,000
in other words in a strongly connected

00:07:18,960 --> 00:07:22,240
component

00:07:20,000 --> 00:07:25,120
any node is reachable from any other

00:07:22,240 --> 00:07:28,319
node following the directions

00:07:25,120 --> 00:07:31,840
in the example nodes b c d e

00:07:28,319 --> 00:07:31,840
form a strongly connected component

00:07:32,720 --> 00:07:38,479
now that we know all the terminologies

00:07:35,280 --> 00:07:40,639
we can simplify our hypothesis like this

00:07:38,479 --> 00:07:41,599
we want to find the largest ssc in the

00:07:40,639 --> 00:07:43,599
map

00:07:41,599 --> 00:07:45,599
and figure out why other parts are

00:07:43,599 --> 00:07:48,160
disconnected from it

00:07:45,599 --> 00:07:51,599
referring back to the image pink section

00:07:48,160 --> 00:07:51,599
denotes the largest ssa

00:07:52,560 --> 00:07:59,759
now let's talk about how to find sss

00:07:56,720 --> 00:08:01,120
there are several ways to find ssas two

00:07:59,759 --> 00:08:03,360
of the most popular ones

00:08:01,120 --> 00:08:05,520
are kosarajas algorithm and tarzan's

00:08:03,360 --> 00:08:07,759
algorithm

00:08:05,520 --> 00:08:09,520
both of these algorithms have similar

00:08:07,759 --> 00:08:12,160
time and space complexity

00:08:09,520 --> 00:08:12,720
which is linear we chose the first one

00:08:12,160 --> 00:08:16,240
because of

00:08:12,720 --> 00:08:18,639
its ease of implementation it's worth

00:08:16,240 --> 00:08:20,720
mentioning that a naive algorithm

00:08:18,639 --> 00:08:22,960
could take forever to run ssc's among

00:08:20,720 --> 00:08:25,280
millions of nodes

00:08:22,960 --> 00:08:28,479
so let's take a brief look at how kosher

00:08:25,280 --> 00:08:28,479
resist algorithm works

00:08:29,199 --> 00:08:33,760
there are three major steps in the

00:08:30,800 --> 00:08:37,039
algorithm we will use this example to

00:08:33,760 --> 00:08:37,039
illustrate the whole process

00:08:37,200 --> 00:08:41,760
first step is to perform depth first

00:08:39,599 --> 00:08:44,000
search from each node

00:08:41,760 --> 00:08:45,279
and push the nodes found along the way

00:08:44,000 --> 00:08:48,480
into a stack

00:08:45,279 --> 00:08:51,200
in topological order we start performing

00:08:48,480 --> 00:08:54,320
depth first search from node a

00:08:51,200 --> 00:08:57,440
mark it yellow to denote that this node

00:08:54,320 --> 00:08:57,440
is still in process

00:08:57,839 --> 00:09:03,120
then we move to the neighboring node b

00:09:00,720 --> 00:09:05,279
and start processing it

00:09:03,120 --> 00:09:06,480
and like that we keep visiting

00:09:05,279 --> 00:09:09,839
unprocessed neighbors

00:09:06,480 --> 00:09:09,839
in a depth first manner

00:09:11,839 --> 00:09:16,640
once we reach node f we can't visit any

00:09:14,800 --> 00:09:20,000
other node from here

00:09:16,640 --> 00:09:22,959
that means we are done processing f so

00:09:20,000 --> 00:09:25,279
we mark it in green and push it into the

00:09:22,959 --> 00:09:25,279
stack

00:09:26,000 --> 00:09:31,200
now coming back to the previous step we

00:09:28,640 --> 00:09:33,040
continue to process neighbors of c

00:09:31,200 --> 00:09:37,519
and keep pushing the nodes into the

00:09:33,040 --> 00:09:39,440
stack when they are done processing

00:09:37,519 --> 00:09:40,560
following the process animated in the

00:09:39,440 --> 00:09:43,600
example

00:09:40,560 --> 00:09:47,120
our final stack is f g

00:09:43,600 --> 00:09:50,320
e d c b a note that

00:09:47,120 --> 00:09:53,440
we had processed a at the very end so a

00:09:50,320 --> 00:09:53,440
is at top of our stack

00:09:56,000 --> 00:09:59,680
next step is to transpose the graph in

00:09:58,880 --> 00:10:04,640
other words

00:09:59,680 --> 00:10:07,760
reverse the direction of all the edges

00:10:04,640 --> 00:10:08,240
the last step is to pop an unprocessed

00:10:07,760 --> 00:10:10,800
node

00:10:08,240 --> 00:10:12,720
from the stack and visit all the nodes

00:10:10,800 --> 00:10:14,880
reachable from this node

00:10:12,720 --> 00:10:16,480
again we can visit the nodes in depth

00:10:14,880 --> 00:10:20,079
first manner

00:10:16,480 --> 00:10:23,600
look at our stack first node is a

00:10:20,079 --> 00:10:27,120
which is not processed for this step yet

00:10:23,600 --> 00:10:32,320
we take it out and our stack becomes

00:10:27,120 --> 00:10:35,680
f g e d c b

00:10:32,320 --> 00:10:38,800
as we can't go to any other node from a

00:10:35,680 --> 00:10:42,320
we have our first sse note that

00:10:38,800 --> 00:10:47,279
ssa can be made of only one node as well

00:10:42,320 --> 00:10:50,560
next we have b at top of our stack

00:10:47,279 --> 00:10:55,200
so we start visiting node starting at b

00:10:50,560 --> 00:10:55,200
this time we can visit e d and c

00:10:56,320 --> 00:10:59,360
so we have our second strongly connected

00:10:58,160 --> 00:11:02,880
component

00:10:59,360 --> 00:11:04,959
comprising of b c d and e

00:11:02,880 --> 00:11:09,120
as we have processed all of these four

00:11:04,959 --> 00:11:09,120
nodes we take this out of the stack

00:11:09,920 --> 00:11:15,760
next we process the remaining nodes g

00:11:13,200 --> 00:11:18,079
and f similarly and our stack becomes

00:11:15,760 --> 00:11:18,079
empty

00:11:18,240 --> 00:11:22,480
all of these four different colors

00:11:19,839 --> 00:11:28,079
denote four different ss's

00:11:22,480 --> 00:11:30,959
bcde being the largest

00:11:28,079 --> 00:11:33,360
now that we know how to find sss time to

00:11:30,959 --> 00:11:36,880
work on visualization

00:11:33,360 --> 00:11:39,120
gps exchange format gpx in short

00:11:36,880 --> 00:11:40,480
is an xml schema designed as a common

00:11:39,120 --> 00:11:44,320
gps data format

00:11:40,480 --> 00:11:46,800
for software applications we have chosen

00:11:44,320 --> 00:11:49,360
to represent the data in this format

00:11:46,800 --> 00:11:52,240
as it's well known and works seamlessly

00:11:49,360 --> 00:11:52,240
with jvsm

00:11:53,120 --> 00:11:57,279
putting everything together the workflow

00:11:55,680 --> 00:12:01,680
looks like this

00:11:57,279 --> 00:12:04,399
first we find the largest ssc in a map

00:12:01,680 --> 00:12:06,800
then we separate the largest ssc and the

00:12:04,399 --> 00:12:09,200
rest of the graph

00:12:06,800 --> 00:12:11,519
then create gpx files for both of the

00:12:09,200 --> 00:12:15,200
graphs

00:12:11,519 --> 00:12:17,120
finally visualize everything in jvsm

00:12:15,200 --> 00:12:20,800
let's take a look at how it looks like

00:12:17,120 --> 00:12:20,800
at the end for a portion of the map

00:12:22,800 --> 00:12:27,519
this is how it looks like once we load

00:12:24,720 --> 00:12:29,680
both the gpx files for the map

00:12:27,519 --> 00:12:31,120
at this point it's not making much sense

00:12:29,680 --> 00:12:32,880
is it

00:12:31,120 --> 00:12:34,560
let's put a different color for the

00:12:32,880 --> 00:12:38,240
largest sse

00:12:34,560 --> 00:12:41,680
it's easy to do that in jvsm

00:12:38,240 --> 00:12:43,519
the largest ssc is in blue color

00:12:41,680 --> 00:12:45,920
if you remember the hypothesis we had

00:12:43,519 --> 00:12:46,639
about largest ssc covering most of the

00:12:45,920 --> 00:12:50,160
places

00:12:46,639 --> 00:12:51,360
is held true now let's zoom into one of

00:12:50,160 --> 00:12:53,519
the pink section

00:12:51,360 --> 00:12:57,279
on the right image to see why it got

00:12:53,519 --> 00:12:57,279
separated from the largest ssc

00:12:57,519 --> 00:13:01,040
let's take a closer look on the image on

00:12:59,360 --> 00:13:03,519
the right and

00:13:01,040 --> 00:13:06,320
also we are overlaying the gpx files on

00:13:03,519 --> 00:13:09,839
top of osm standard black and white map

00:13:06,320 --> 00:13:09,839
to better understand the reasons

00:13:10,320 --> 00:13:13,600
taking a closer look we see two likely

00:13:13,040 --> 00:13:16,000
reasons

00:13:13,600 --> 00:13:18,320
for this section to be disconnected from

00:13:16,000 --> 00:13:21,360
the largest ssc

00:13:18,320 --> 00:13:21,839
both 1 and two have two dead ends where

00:13:21,360 --> 00:13:23,600
they are

00:13:21,839 --> 00:13:25,839
very likely to be connected in real

00:13:23,600 --> 00:13:25,839
world

00:13:26,240 --> 00:13:29,680
these disconnections mean that we can't

00:13:29,360 --> 00:13:32,160
have

00:13:29,680 --> 00:13:34,240
any routes in osm going through either

00:13:32,160 --> 00:13:36,399
of these two ends

00:13:34,240 --> 00:13:37,920
taking a closer look we can see that

00:13:36,399 --> 00:13:41,600
both the roads have

00:13:37,920 --> 00:13:41,600
two lanes of opposite directions

00:13:42,480 --> 00:13:48,880
but as the probable u-turns are missing

00:13:45,600 --> 00:13:50,399
these two lanes are disconnected these

00:13:48,880 --> 00:13:53,120
problems could have been remained

00:13:50,399 --> 00:13:55,040
undiscovered for indefinite time

00:13:53,120 --> 00:13:57,040
and we would have probably been

00:13:55,040 --> 00:13:59,360
suggested some other route

00:13:57,040 --> 00:14:00,959
or no route at all when requested in

00:13:59,360 --> 00:14:03,440
this area

00:14:00,959 --> 00:14:07,839
now that we see the problem we can take

00:14:03,440 --> 00:14:07,839
necessary steps to fix this in osm

00:14:10,320 --> 00:14:14,399
if you remember these examples from the

00:14:12,800 --> 00:14:16,320
earlier slides

00:14:14,399 --> 00:14:19,680
these were also surfaced using the same

00:14:16,320 --> 00:14:19,680
process i just explained

00:14:20,959 --> 00:14:26,160
throughout the process we have observed

00:14:23,360 --> 00:14:28,720
few key points

00:14:26,160 --> 00:14:30,800
more than 90 of the nodes are usually

00:14:28,720 --> 00:14:33,360
part of the largest ssa

00:14:30,800 --> 00:14:34,000
that means more than 90 percent of the

00:14:33,360 --> 00:14:37,680
places

00:14:34,000 --> 00:14:37,680
are reachable from one another

00:14:37,839 --> 00:14:42,639
many of the disconnection happen due to

00:14:39,839 --> 00:14:45,120
parking lots or private properties

00:14:42,639 --> 00:14:47,680
which means that there are roads ending

00:14:45,120 --> 00:14:49,360
at and beginning from those places

00:14:47,680 --> 00:14:51,120
without any interconnection between

00:14:49,360 --> 00:14:54,959
themselves

00:14:51,120 --> 00:14:54,959
this causes disconnection in the graph

00:14:56,320 --> 00:14:59,360
there are more wrong direction of travel

00:14:58,079 --> 00:15:03,040
cases in osm

00:14:59,360 --> 00:15:03,040
than we had anticipated

00:15:03,839 --> 00:15:07,839
although this system is helping us

00:15:05,680 --> 00:15:11,440
making worse and better every day

00:15:07,839 --> 00:15:14,000
there are still ways to improve

00:15:11,440 --> 00:15:15,360
the system can be much more effective by

00:15:14,000 --> 00:15:18,399
removing some

00:15:15,360 --> 00:15:21,920
obvious flags like parking lots or

00:15:18,399 --> 00:15:21,920
private properties etc

00:15:22,160 --> 00:15:25,760
by definition of ssa we can say that

00:15:24,800 --> 00:15:28,560
more nodes

00:15:25,760 --> 00:15:30,000
in the largest scc likely refers to

00:15:28,560 --> 00:15:33,040
better map

00:15:30,000 --> 00:15:34,800
as that means more places are reachable

00:15:33,040 --> 00:15:37,120
from one another

00:15:34,800 --> 00:15:39,680
assessing map quality automatically by

00:15:37,120 --> 00:15:44,000
comparing ssds in different version

00:15:39,680 --> 00:15:44,000
can help us keeping the quality high

00:15:44,720 --> 00:15:50,079
that is all from my side for this talk

00:15:48,000 --> 00:15:52,839
if you have any questions regarding this

00:15:50,079 --> 00:15:57,759
talk please reach out to me at

00:15:52,839 --> 00:15:57,759
iwan.housing at grab.com thank you

00:15:58,880 --> 00:16:05,920
thank you to one

00:16:03,040 --> 00:16:08,320
thank you very much even for your talk

00:16:05,920 --> 00:16:12,320
so we are here for the question

00:16:08,320 --> 00:16:14,480
i cannot see you so if you would like to

00:16:12,320 --> 00:16:15,360
to unmute and to show yourself okay

00:16:14,480 --> 00:16:18,240
perfect

00:16:15,360 --> 00:16:19,440
so we have some thank you for the the

00:16:18,240 --> 00:16:22,160
quest that the talk was

00:16:19,440 --> 00:16:24,000
very very technical so we have some

00:16:22,160 --> 00:16:26,639
really technical questions

00:16:24,000 --> 00:16:27,759
uh i have just one curiosity just for

00:16:26,639 --> 00:16:30,800
you

00:16:27,759 --> 00:16:33,279
this tool is isn't is use is not

00:16:30,800 --> 00:16:33,920
published it's just used for by you

00:16:33,279 --> 00:16:36,399
because it's

00:16:33,920 --> 00:16:37,120
too much computer expensive because it's

00:16:36,399 --> 00:16:38,959
uh

00:16:37,120 --> 00:16:41,680
too much uh it's not it's a in a

00:16:38,959 --> 00:16:44,800
developing phase

00:16:41,680 --> 00:16:48,560
uh by the tool do you mean the algorithm

00:16:44,800 --> 00:16:52,560
yeah yeah i think uh it's not

00:16:48,560 --> 00:16:55,759
that like resource

00:16:52,560 --> 00:16:58,160
consuming so yeah it's just

00:16:55,759 --> 00:17:00,800
linear in complexity so i think it's as

00:16:58,160 --> 00:17:03,680
simple as it can get

00:17:00,800 --> 00:17:05,120
okay okay there is a similar question

00:17:03,680 --> 00:17:07,199
that we can see there is a

00:17:05,120 --> 00:17:10,000
there is any open source code we can we

00:17:07,199 --> 00:17:11,600
have we can adapt to in other country so

00:17:10,000 --> 00:17:15,039
the reply is that it's

00:17:11,600 --> 00:17:17,520
too much computing right yeah so

00:17:15,039 --> 00:17:18,400
if you remember uh it's not a good

00:17:17,520 --> 00:17:20,880
question

00:17:18,400 --> 00:17:21,439
so the algorithm we used the main

00:17:20,880 --> 00:17:24,640
algorithm

00:17:21,439 --> 00:17:27,679
ssa to find the components it's

00:17:24,640 --> 00:17:30,840
uh quite available everywhere and yeah

00:17:27,679 --> 00:17:33,919
i think it's easily available it's not

00:17:30,840 --> 00:17:34,559
something that we have developed but the

00:17:33,919 --> 00:17:39,200
process

00:17:34,559 --> 00:17:42,320
is what i'm trying to convey here

00:17:39,200 --> 00:17:46,480
okay we have a technical question

00:17:42,320 --> 00:17:49,360
by kirill why do you need a check

00:17:46,480 --> 00:17:51,039
in the direct graph in my import is he

00:17:49,360 --> 00:17:53,280
make the example of his validator

00:17:51,039 --> 00:17:54,400
in my validator i mean i've implemented

00:17:53,280 --> 00:17:57,039
connectivity check

00:17:54,400 --> 00:17:58,240
using non-direct graph just ignoring

00:17:57,039 --> 00:18:02,000
one-way tag

00:17:58,240 --> 00:18:03,760
the algorithm to to find eisen becomes

00:18:02,000 --> 00:18:05,440
much more simple but the results are

00:18:03,760 --> 00:18:07,039
practically the same

00:18:05,440 --> 00:18:09,360
do we have to test this aspect do you

00:18:07,039 --> 00:18:12,160
decide to don't

00:18:09,360 --> 00:18:13,120
um i'm not sure if i get the question

00:18:12,160 --> 00:18:17,039
correctly

00:18:13,120 --> 00:18:20,160
so okay we can ask to the user to make

00:18:17,039 --> 00:18:23,679
make it more clear maybe because yeah

00:18:20,160 --> 00:18:25,280
okay so more clarifications can

00:18:23,679 --> 00:18:28,000
can make it more clear we're saying this

00:18:25,280 --> 00:18:30,640
since we can make it more easy

00:18:28,000 --> 00:18:32,480
uh there is more another one can you

00:18:30,640 --> 00:18:34,400
just play in a wrong direction

00:18:32,480 --> 00:18:36,880
both ways seems connected by the same

00:18:34,400 --> 00:18:38,000
node i think it's refreshed to the to

00:18:36,880 --> 00:18:41,760
the slide with the

00:18:38,000 --> 00:18:43,840
two highways yeah so

00:18:41,760 --> 00:18:44,799
if you remember so there is single node

00:18:43,840 --> 00:18:48,720
and we have

00:18:44,799 --> 00:18:50,880
uh direction from both directions

00:18:48,720 --> 00:18:53,039
and both are like one-way roads so one

00:18:50,880 --> 00:18:55,600
of them has to be wrong direction

00:18:53,039 --> 00:18:56,880
so it's supposed to be like the one of

00:18:55,600 --> 00:18:58,720
the direction has to be correct and

00:18:56,880 --> 00:19:00,559
another one should just follow

00:18:58,720 --> 00:19:03,120
so otherwise there would be a collision

00:19:00,559 --> 00:19:05,280
in that single point of node

00:19:03,120 --> 00:19:06,720
okay so that was what i meant by wrong

00:19:05,280 --> 00:19:10,160
direction of travel

00:19:06,720 --> 00:19:12,799
okay okay

00:19:10,160 --> 00:19:14,559
uh do wrong direction opposite direction

00:19:12,799 --> 00:19:17,919
cause this connectivity

00:19:14,559 --> 00:19:20,559
too is captured by the algorithm

00:19:17,919 --> 00:19:22,080
um sorry which question is it i can it's

00:19:20,559 --> 00:19:23,919
the fourth the fourth one

00:19:22,080 --> 00:19:26,000
do wrong the direction because this can

00:19:23,919 --> 00:19:28,000
be called this connectivity

00:19:26,000 --> 00:19:30,480
and then of course about the current

00:19:28,000 --> 00:19:34,000
okay yeah

00:19:30,480 --> 00:19:37,360
so even uh if you remember the example

00:19:34,000 --> 00:19:41,120
i showed in the slide that uh we also

00:19:37,360 --> 00:19:41,120
found that throughout the algorithm only

00:19:42,880 --> 00:19:45,440
okay just

00:19:46,240 --> 00:19:51,760
i am i'm just having to reload my path

00:19:49,280 --> 00:19:54,320
because there is some problem okay

00:19:51,760 --> 00:19:55,280
are you con concentrating only on the

00:19:54,320 --> 00:19:58,400
car routing

00:19:55,280 --> 00:20:00,720
or you think about other users

00:19:58,400 --> 00:20:01,840
so this algorithm actually works on

00:20:00,720 --> 00:20:04,320
graph

00:20:01,840 --> 00:20:05,120
so it doesn't matter which graph you

00:20:04,320 --> 00:20:07,760
present

00:20:05,120 --> 00:20:09,120
it can be car walking or anything it

00:20:07,760 --> 00:20:12,799
doesn't matter

00:20:09,120 --> 00:20:12,799
it can work on all kind of grass

00:20:14,320 --> 00:20:17,280
okay so we have

00:20:17,360 --> 00:20:21,280
there is a i don't know if it's a

00:20:18,720 --> 00:20:22,240
request or uh or a question i think more

00:20:21,280 --> 00:20:23,919
is a request

00:20:22,240 --> 00:20:25,840
you can contribute all these to the

00:20:23,919 --> 00:20:27,840
ideas checkers

00:20:25,840 --> 00:20:28,960
maybe it can be a suggestion or also you

00:20:27,840 --> 00:20:31,520
can share the

00:20:28,960 --> 00:20:33,280
your work that can be easily implemented

00:20:31,520 --> 00:20:35,520
soon

00:20:33,280 --> 00:20:36,559
yeah i think most of the things are

00:20:35,520 --> 00:20:39,280
already available

00:20:36,559 --> 00:20:40,000
publicly uh it's just putting the things

00:20:39,280 --> 00:20:42,960
together

00:20:40,000 --> 00:20:45,440
and i would say it's a big effort to put

00:20:42,960 --> 00:20:47,120
things together it's not just symphony

00:20:45,440 --> 00:20:48,720
the result at the end is very simple but

00:20:47,120 --> 00:20:50,799
the process to arrive to the result is

00:20:48,720 --> 00:20:53,840
generally very complex

00:20:50,799 --> 00:20:54,880
right i'd say i don't have any immediate

00:20:53,840 --> 00:20:57,679
plan but

00:20:54,880 --> 00:21:00,840
i can take it to the relevant teams who

00:20:57,679 --> 00:21:03,760
handles these things for grab

00:21:00,840 --> 00:21:07,039
okay okay we reply most of them there is

00:21:03,760 --> 00:21:12,640
just some comments that say that we have

00:21:07,039 --> 00:21:14,799
it's really hard generally to to have a

00:21:12,640 --> 00:21:16,640
to a map road in area where there are a

00:21:14,799 --> 00:21:18,559
lot of trees that maybe user does

00:21:16,640 --> 00:21:19,919
does not really believe that the the

00:21:18,559 --> 00:21:21,600
road goes to the direction that is

00:21:19,919 --> 00:21:22,159
expected maybe there is some changes so

00:21:21,600 --> 00:21:25,280
they

00:21:22,159 --> 00:21:26,799
they prefer down to to to check i just

00:21:25,280 --> 00:21:28,320
i just think in one case that i have

00:21:26,799 --> 00:21:30,559
fronted if you are thinking

00:21:28,320 --> 00:21:32,640
if there are there are the possibility

00:21:30,559 --> 00:21:34,720
that the algorithm identify

00:21:32,640 --> 00:21:36,960
small island for example if you are

00:21:34,720 --> 00:21:37,440
going to map routes in a small island

00:21:36,960 --> 00:21:38,799
like i

00:21:37,440 --> 00:21:41,760
have an example for a project in the

00:21:38,799 --> 00:21:44,080
commerce island in the near madagascar

00:21:41,760 --> 00:21:45,679
and there is like a very small area and

00:21:44,080 --> 00:21:47,679
i try some checker

00:21:45,679 --> 00:21:49,440
and most of them say that all these

00:21:47,679 --> 00:21:51,120
roads are separated for the main graph

00:21:49,440 --> 00:21:52,159
but the issue is that the road are very

00:21:51,120 --> 00:21:54,000
few

00:21:52,159 --> 00:21:56,000
so there is something that check like

00:21:54,000 --> 00:21:58,799
your idea of having a block

00:21:56,000 --> 00:22:00,320
say that identify that if there are some

00:21:58,799 --> 00:22:04,480
other road near

00:22:00,320 --> 00:22:07,120
or is just isolated block of roads

00:22:04,480 --> 00:22:08,240
yes for now it's just the isolated block

00:22:07,120 --> 00:22:10,640
of roads

00:22:08,240 --> 00:22:12,240
and the idea is to make the

00:22:10,640 --> 00:22:14,480
visualization easy

00:22:12,240 --> 00:22:16,559
so we kind of know where the roads are

00:22:14,480 --> 00:22:20,640
getting disconnected

00:22:16,559 --> 00:22:20,640
yeah okay but it's not automated yet

00:22:21,200 --> 00:22:26,320
okay we have uh we have some correction

00:22:24,080 --> 00:22:28,400
in the first question

00:22:26,320 --> 00:22:29,760
why do you need a check in the direct

00:22:28,400 --> 00:22:32,799
graph

00:22:29,760 --> 00:22:33,840
i'm in in my validate i've implemented

00:22:32,799 --> 00:22:35,840
connectivity check

00:22:33,840 --> 00:22:36,960
using not the red graph just ignoring

00:22:35,840 --> 00:22:39,679
the one-way target

00:22:36,960 --> 00:22:41,520
the algorithm find iceland island is a

00:22:39,679 --> 00:22:44,480
later sub grapher so what we're

00:22:41,520 --> 00:22:45,120
talking because there are there are much

00:22:44,480 --> 00:22:47,039
becomes

00:22:45,120 --> 00:22:48,559
much much simpler but the results are

00:22:47,039 --> 00:22:50,159
particularly the same

00:22:48,559 --> 00:22:51,679
you don't really need to analyze the

00:22:50,159 --> 00:22:52,559
oriented graph just analyze the

00:22:51,679 --> 00:22:54,480
connectivity

00:22:52,559 --> 00:22:55,679
i think that the question is the aspect

00:22:54,480 --> 00:22:57,600
is asking why do

00:22:55,679 --> 00:22:58,720
you need to analyze the direction of the

00:22:57,600 --> 00:23:00,240
single arc

00:22:58,720 --> 00:23:01,919
and not just the presence of the arc

00:23:00,240 --> 00:23:05,120
between the nodes

00:23:01,919 --> 00:23:06,960
right right so going back to the wrong

00:23:05,120 --> 00:23:09,760
direction of treble case

00:23:06,960 --> 00:23:10,559
so if we ignore the direction part we

00:23:09,760 --> 00:23:13,600
would have not

00:23:10,559 --> 00:23:15,760
got the case where two unit directional

00:23:13,600 --> 00:23:18,320
roads are colliding

00:23:15,760 --> 00:23:21,039
yeah i guess that kind of explains why

00:23:18,320 --> 00:23:23,840
we choose to have directional graph

00:23:21,039 --> 00:23:25,760
okay yes this exactly can be the if you

00:23:23,840 --> 00:23:27,760
depends on the on your proposed so if

00:23:25,760 --> 00:23:29,440
you'd like us to identify this aspect

00:23:27,760 --> 00:23:30,799
it's not possible to you to identify

00:23:29,440 --> 00:23:34,840
this

00:23:30,799 --> 00:23:36,159
okay so there was just a suggestion to

00:23:34,840 --> 00:23:39,039
map

00:23:36,159 --> 00:23:40,960
streets that are isolated when we don't

00:23:39,039 --> 00:23:44,000
have trees to use lighter data yes

00:23:40,960 --> 00:23:45,120
this can be definitely used we need this

00:23:44,000 --> 00:23:48,400
divider data to be

00:23:45,120 --> 00:23:50,880
to be present okay okay

00:23:48,400 --> 00:23:52,880
this can there is another question

00:23:50,880 --> 00:23:54,640
profiles matters in my opinion for

00:23:52,880 --> 00:23:57,360
pedestrian era slash plaza

00:23:54,640 --> 00:23:59,120
with bicycle access with a special case

00:23:57,360 --> 00:24:00,799
of route for routing

00:23:59,120 --> 00:24:03,200
do you think that it can be can be a

00:24:00,799 --> 00:24:05,200
change of the approved passing from the

00:24:03,200 --> 00:24:06,799
from the from the highway to from just

00:24:05,200 --> 00:24:08,320
the car to this other aspect

00:24:06,799 --> 00:24:10,000
that can be also related to the other

00:24:08,320 --> 00:24:10,880
ask to the to the next question that is

00:24:10,000 --> 00:24:13,919
related to the

00:24:10,880 --> 00:24:15,760
to the copied that is the how we can use

00:24:13,919 --> 00:24:16,080
the reverse algorithm for covet make a

00:24:15,760 --> 00:24:19,520
more

00:24:16,080 --> 00:24:22,240
social distances sounds like an

00:24:19,520 --> 00:24:22,240
interesting question

00:24:22,400 --> 00:24:26,080
let me see if there is a quick answer i

00:24:24,720 --> 00:24:28,480
can think of

00:24:26,080 --> 00:24:29,360
i can just sport make an example in that

00:24:28,480 --> 00:24:31,360
i found

00:24:29,360 --> 00:24:33,600
there is a very diffuse example starting

00:24:31,360 --> 00:24:35,679
from an example of new york where the

00:24:33,600 --> 00:24:37,200
some public data open data are not

00:24:35,679 --> 00:24:39,200
directly from princeton but they are

00:24:37,200 --> 00:24:42,559
used for compute the

00:24:39,200 --> 00:24:43,600
the width of the sidewalk and to measure

00:24:42,559 --> 00:24:45,600
the

00:24:43,600 --> 00:24:47,520
the the if the social discipline is

00:24:45,600 --> 00:24:49,120
possible in most of the cities

00:24:47,520 --> 00:24:50,880
the first one was the new yorker that i

00:24:49,120 --> 00:24:53,440
know that was done by an

00:24:50,880 --> 00:24:54,159
italian user in most of all the city in

00:24:53,440 --> 00:24:56,720
italy

00:24:54,159 --> 00:24:57,600
and in different others part of the

00:24:56,720 --> 00:25:00,400
world for sure

00:24:57,600 --> 00:25:01,360
for using this open code but these these

00:25:00,400 --> 00:25:03,279
data are very

00:25:01,360 --> 00:25:04,880
generally messy the one that also i

00:25:03,279 --> 00:25:07,760
tested so it can be

00:25:04,880 --> 00:25:09,440
effectively useful to find some some

00:25:07,760 --> 00:25:12,640
algorithm that can processes and

00:25:09,440 --> 00:25:14,720
improve this data but as you say that

00:25:12,640 --> 00:25:16,240
the algorithm can be used on every graph

00:25:14,720 --> 00:25:20,799
doesn't depend really on the

00:25:16,240 --> 00:25:23,919
which is that the the scope

00:25:20,799 --> 00:25:23,919
yeah okay

00:25:25,360 --> 00:25:28,880
okay so we have all for the question if

00:25:27,840 --> 00:25:30,400
you have more

00:25:28,880 --> 00:25:31,919
detailed question more technical

00:25:30,400 --> 00:25:32,640
questions that you think that was we

00:25:31,919 --> 00:25:35,840
don't have

00:25:32,640 --> 00:25:38,720
enough time to do it you are free to

00:25:35,840 --> 00:25:40,559
to ask to to even in privacy leave the

00:25:38,720 --> 00:25:42,080
email at the end of the conversation or

00:25:40,559 --> 00:25:43,520
you can reach it in the the social that

00:25:42,080 --> 00:25:45,279
you leave in the pad

00:25:43,520 --> 00:25:47,120
so thank you to everybody thank you and

00:25:45,279 --> 00:25:57,840
even for your presentation

00:25:47,120 --> 00:25:57,840
see you in next year in the next session

00:26:03,840 --> 00:26:05,919

YouTube URL: https://www.youtube.com/watch?v=YkHC1bHdMMQ


