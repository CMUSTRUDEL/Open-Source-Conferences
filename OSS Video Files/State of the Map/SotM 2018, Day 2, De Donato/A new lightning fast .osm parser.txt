Title: A new lightning fast .osm parser
Publication date: 2018-09-22
Playlist: SotM 2018, Day 2, De Donato
Description: 
	ikushan, State of the Map 2018
https://2018.stateofthemap.org/2018/L037-A_new_lightning_fast__osm_parser/

Downloading and processing OSM XML are some of the slowest tasks in the iD editor. As a user navigates around the map, this activity can block other work, causing delayed rendering and unresponsiveness. However, OSM XML files follow a well-defined format that can be easily parsed, and modern browsers are able to execute tasks asynchronously in multiple threads using a feature called web workers.

This talk showcases several techniques for improving the performance of downloading and parsing data from the OSM API. Weâ€™ll do a quick overview of how this faster parser works, discuss performance tricks used, and evaluate the resulting speed and size benefits of the new parser.
Captions: 
	00:00:00,030 --> 00:00:08,880
hello hi I'm Cassandra she and I work at

00:00:05,910 --> 00:00:12,120
my box as a front-end developer and I

00:00:08,880 --> 00:00:14,250
also have worked on ID editor as a

00:00:12,120 --> 00:00:16,230
google Summer of Code student and later

00:00:14,250 --> 00:00:19,859
on helping Bryan with some of the things

00:00:16,230 --> 00:00:21,300
and after that I started working on oMG

00:00:19,859 --> 00:00:23,699
ah the front-end

00:00:21,300 --> 00:00:27,750
it's a front-end developer and I've also

00:00:23,699 --> 00:00:32,489
worked on to fix if if you've seen to

00:00:27,750 --> 00:00:35,190
fix and today I'm going to talk about ID

00:00:32,489 --> 00:00:39,390
editor and how can we improve the

00:00:35,190 --> 00:00:42,290
performance using multi-threading so

00:00:39,390 --> 00:00:44,340
Before we jump in let's break down what

00:00:42,290 --> 00:00:48,739
actually is happening when you are

00:00:44,340 --> 00:00:52,260
editing and there's a map in ID editor

00:00:48,739 --> 00:00:53,879
so if you look at what is happening

00:00:52,260 --> 00:00:56,640
behind the scenes so this is the

00:00:53,879 --> 00:00:59,039
breakdown of ID editor when you're

00:00:56,640 --> 00:01:01,559
working on it so as you can see the 64%

00:00:59,039 --> 00:01:04,070
of the time is spent with JavaScript

00:01:01,559 --> 00:01:07,200
which is basically computing and

00:01:04,070 --> 00:01:10,920
figuring out what to do and then 15% is

00:01:07,200 --> 00:01:13,680
rendering and hTML is not even there

00:01:10,920 --> 00:01:16,500
because ID is very very JavaScript

00:01:13,680 --> 00:01:19,890
intensive so as you can see there's this

00:01:16,500 --> 00:01:22,229
major chunk of 64% which probably is the

00:01:19,890 --> 00:01:24,570
place where we can improve and if you

00:01:22,229 --> 00:01:27,090
break down the JavaScript processing of

00:01:24,570 --> 00:01:31,530
ID editor this is the breakdown of what

00:01:27,090 --> 00:01:32,909
actually javascript is doing and 42% of

00:01:31,530 --> 00:01:37,439
the time is just figuring out the

00:01:32,909 --> 00:01:39,900
vectors and SVG's but there's this 27%

00:01:37,439 --> 00:01:42,960
time where ID is actually trying to

00:01:39,900 --> 00:01:47,610
parse the XML which is the OSM standard

00:01:42,960 --> 00:01:50,430
for data so I was curious about how the

00:01:47,610 --> 00:01:52,500
ways we can improve this 27% and you

00:01:50,430 --> 00:01:56,969
know probably figure out different ways

00:01:52,500 --> 00:02:00,299
we can reduce this number so yeah it's

00:01:56,969 --> 00:02:02,040
it takes 25% of the CPU time so what are

00:02:00,299 --> 00:02:04,200
the solutions where we can you know

00:02:02,040 --> 00:02:06,869
reduce the time so we can just stop

00:02:04,200 --> 00:02:09,989
passing the XML and this just not talked

00:02:06,869 --> 00:02:12,720
about the problem or recently I tried

00:02:09,989 --> 00:02:13,810
out different ways where we can defer

00:02:12,720 --> 00:02:16,270
the parsing since

00:02:13,810 --> 00:02:18,940
is the least important thing we would

00:02:16,270 --> 00:02:21,340
rather want to focus our CPU time on the

00:02:18,940 --> 00:02:24,580
user the mouse and an interactive event

00:02:21,340 --> 00:02:27,250
so that it feels more snappier so we can

00:02:24,580 --> 00:02:29,170
probably defer the parsing of XML so

00:02:27,250 --> 00:02:31,800
that when user is not doing anything we

00:02:29,170 --> 00:02:37,060
behind the scenes quickly parse the XML

00:02:31,800 --> 00:02:38,350
but it had some problems and so what is

00:02:37,060 --> 00:02:41,650
the other way that we can figure out

00:02:38,350 --> 00:02:44,830
it's looking into the CPU like as you

00:02:41,650 --> 00:02:47,769
know every CPU right now has multi-core

00:02:44,830 --> 00:02:49,300
processors and probably that is one way

00:02:47,769 --> 00:02:53,680
where we can figure out how to improve

00:02:49,300 --> 00:02:55,989
the parsing but javascript is a

00:02:53,680 --> 00:02:57,940
single-threaded of language as you know

00:02:55,989 --> 00:03:02,230
like it doesn't support multi-threading

00:02:57,940 --> 00:03:03,400
but recently in the web world we have a

00:03:02,230 --> 00:03:06,569
new thing called

00:03:03,400 --> 00:03:10,090
web workers where you can offload a task

00:03:06,569 --> 00:03:13,620
to another thread in your browser and

00:03:10,090 --> 00:03:15,910
most of the browser's support it and

00:03:13,620 --> 00:03:18,610
parsing is one thing which can be easily

00:03:15,910 --> 00:03:20,709
offloaded to a separate thread because

00:03:18,610 --> 00:03:23,709
it doesn't really involve in anything

00:03:20,709 --> 00:03:25,420
related to the UI so it's something it's

00:03:23,709 --> 00:03:27,459
like a black box where we can defer it

00:03:25,420 --> 00:03:29,829
to the separate thread and the main

00:03:27,459 --> 00:03:33,549
thread in ID can simply ask for what is

00:03:29,829 --> 00:03:35,489
the past data and the result would be it

00:03:33,549 --> 00:03:37,660
would improve the response time and

00:03:35,489 --> 00:03:39,280
elevate some of the pressure on the main

00:03:37,660 --> 00:03:41,650
thread so the main thread can do more

00:03:39,280 --> 00:03:43,660
things like talking to you guys or

00:03:41,650 --> 00:03:46,720
taking the input or saving your chain

00:03:43,660 --> 00:03:49,810
set while the separate thread processes

00:03:46,720 --> 00:03:50,829
the XML behind-the-scenes so so there

00:03:49,810 --> 00:03:54,280
are some problems with this approach

00:03:50,829 --> 00:03:55,930
obviously it's not perfect so the web

00:03:54,280 --> 00:03:58,750
workers are designed in a way they do

00:03:55,930 --> 00:04:01,590
not support the DOM and XML so there's

00:03:58,750 --> 00:04:04,930
no Dom parser in the web workers so

00:04:01,590 --> 00:04:07,060
there's really like this was designed by

00:04:04,930 --> 00:04:10,660
the browser so that it doesn't interfere

00:04:07,060 --> 00:04:11,859
with the main thread and ID wasn't

00:04:10,660 --> 00:04:15,130
written to be executed in a

00:04:11,859 --> 00:04:17,620
multi-threaded environment so I back in

00:04:15,130 --> 00:04:19,510
2012 and 13 they it wasn't really like

00:04:17,620 --> 00:04:21,880
nobody thought that we can probably run

00:04:19,510 --> 00:04:23,480
JavaScript in multiple threads so these

00:04:21,880 --> 00:04:26,150
are the problems that me

00:04:23,480 --> 00:04:28,370
and Brian are trying to figure out so I

00:04:26,150 --> 00:04:31,640
do sir commend the problem of parsing

00:04:28,370 --> 00:04:33,980
XML in a separate thread I created a

00:04:31,640 --> 00:04:36,890
library called or some Bisley which

00:04:33,980 --> 00:04:39,860
passes the XML by not treating it as an

00:04:36,890 --> 00:04:42,500
XML but just treating it as a string it

00:04:39,860 --> 00:04:45,890
only understands the OSM XML and not any

00:04:42,500 --> 00:04:47,660
other XML so that reduces the problem

00:04:45,890 --> 00:04:52,580
statement so we can just focus on the

00:04:47,660 --> 00:04:55,040
XML of oh boy Sam and it rest with this

00:04:52,580 --> 00:04:56,690
reduced problem it tries to give a

00:04:55,040 --> 00:05:00,080
really really impressive performance on

00:04:56,690 --> 00:05:03,020
paper so these are the different passes

00:05:00,080 --> 00:05:05,870
that I tried it out and as you can see

00:05:03,020 --> 00:05:08,060
the osmium and the it's it's a bit

00:05:05,870 --> 00:05:10,730
faster than the osmium which is the C C

00:05:08,060 --> 00:05:14,150
library and it's it's it's half as fast

00:05:10,730 --> 00:05:17,960
as if it's twice as fast as the ID D

00:05:14,150 --> 00:05:20,420
native XML parser right now so how does

00:05:17,960 --> 00:05:23,720
it actually work so so the way it works

00:05:20,420 --> 00:05:26,660
is it treats every line as a string and

00:05:23,720 --> 00:05:29,030
since it can assumes its it assumes

00:05:26,660 --> 00:05:31,490
certain things so that if it only

00:05:29,030 --> 00:05:33,590
targets EOS m XML so we pass it by line

00:05:31,490 --> 00:05:36,440
by line and whenever encounters an

00:05:33,590 --> 00:05:39,110
entity like Way node or relation it

00:05:36,440 --> 00:05:41,860
simply creates an javascript object as

00:05:39,110 --> 00:05:44,360
you can see on the left hand side and

00:05:41,860 --> 00:05:46,670
the moment it encounters any attributes

00:05:44,360 --> 00:05:49,040
so all the attributes in ID are simply

00:05:46,670 --> 00:05:51,520
in double quote in XML or double quotes

00:05:49,040 --> 00:05:55,880
so it simply starts populating the

00:05:51,520 --> 00:05:57,590
attributes like this UID and from that

00:05:55,880 --> 00:06:01,580
it goes to the next line if it encounter

00:05:57,590 --> 00:06:03,950
certain tags which are the nd or tag it

00:06:01,580 --> 00:06:06,830
can simply put them populating them in

00:06:03,950 --> 00:06:09,920
the way and whenever we encounter a

00:06:06,830 --> 00:06:12,980
closing tag it simply starts a new

00:06:09,920 --> 00:06:14,690
object so this is the basic idea behind

00:06:12,980 --> 00:06:18,409
it so that we don't really have to rely

00:06:14,690 --> 00:06:20,989
on any sort of osm xml parser

00:06:18,409 --> 00:06:25,339
and the way it works is it just focuses

00:06:20,989 --> 00:06:27,800
on voice mxml so that data takeaways so

00:06:25,339 --> 00:06:30,529
we can use multi-threading to improve

00:06:27,800 --> 00:06:33,619
the performance of ID or SM Beasley is a

00:06:30,529 --> 00:06:36,080
new string parsing of ASM XML to

00:06:33,619 --> 00:06:37,699
overcome the limitations and it opens

00:06:36,080 --> 00:06:39,349
the future possibility of offloading

00:06:37,699 --> 00:06:41,949
more tasks to the web worker in the

00:06:39,349 --> 00:07:00,379
future to improve the ID performance

00:06:41,949 --> 00:07:03,819
thank you time for questions as always I

00:07:00,379 --> 00:07:06,559
only ask obvious questions

00:07:03,819 --> 00:07:10,909
why didn't you investigate your first

00:07:06,559 --> 00:07:13,550
option stop parsing XML oh it was not

00:07:10,909 --> 00:07:15,259
actually an option it's just but but the

00:07:13,550 --> 00:07:18,050
thing is it is not an option because

00:07:15,259 --> 00:07:22,939
it's completely possible to supply

00:07:18,050 --> 00:07:25,159
chosen format data from the OSM api and

00:07:22,939 --> 00:07:28,909
this actually been work on doing that

00:07:25,159 --> 00:07:30,769
it's just never been completed so yeah

00:07:28,909 --> 00:07:33,829
that is one option but in our domain

00:07:30,769 --> 00:07:36,319
like how do we just focus on idv like so

00:07:33,829 --> 00:07:37,939
that is one solution because the OSM XML

00:07:36,319 --> 00:07:39,800
API hasn't changed since I don't know

00:07:37,939 --> 00:07:48,389
two thousand nine or eight it's just

00:07:39,800 --> 00:07:53,879
there's a JSON thing sorry sorry

00:07:48,389 --> 00:07:57,629
if you want you want to reply there is

00:07:53,879 --> 00:08:00,120
events generated yeah it says stopgaps

00:07:57,629 --> 00:08:02,819
till we get a JSON API which would

00:08:00,120 --> 00:08:08,729
really what our web browsers understand

00:08:02,819 --> 00:08:11,009
really well if you were to design your

00:08:08,729 --> 00:08:13,530
ideal format for the API to send stuff

00:08:11,009 --> 00:08:15,719
quickly in a way that you could read in

00:08:13,530 --> 00:08:17,669
a multi-threaded way what would you want

00:08:15,719 --> 00:08:21,210
it to do I mean right now I just think

00:08:17,669 --> 00:08:23,099
it's J's on because gel ID anyway can

00:08:21,210 --> 00:08:25,710
what's it first into a JavaScript object

00:08:23,099 --> 00:08:28,020
and then instantiates it so there's just

00:08:25,710 --> 00:08:30,990
one heavy step which is the Dom parsing

00:08:28,020 --> 00:08:33,510
and since we are not mutating the Dom

00:08:30,990 --> 00:08:35,339
tree which xml creates it it's just one

00:08:33,510 --> 00:08:38,310
redundant step we can probably remove

00:08:35,339 --> 00:08:39,990
okay and presumably for this you've

00:08:38,310 --> 00:08:41,760
already very interested in the read

00:08:39,990 --> 00:08:44,579
calls you don't have to worry too much

00:08:41,760 --> 00:08:47,100
about sending one of four messages back

00:08:44,579 --> 00:08:49,440
I mean when a user just saves the change

00:08:47,100 --> 00:08:51,510
sets then we also would like I mean if

00:08:49,440 --> 00:09:00,860
to be consistent it should be also shown

00:08:51,510 --> 00:09:00,860
yeah sure any more questions okay

00:09:04,850 --> 00:09:14,690
would there be an advantage to write the

00:09:09,800 --> 00:09:18,300
XML or API protozoan webassembly

00:09:14,690 --> 00:09:20,940
webassembly yeah so webassembly

00:09:18,300 --> 00:09:23,250
is another way to really really speed up

00:09:20,940 --> 00:09:24,870
things on the browser side but the

00:09:23,250 --> 00:09:27,540
problem is web assembly is not really

00:09:24,870 --> 00:09:31,830
supported well with the browsers and ID

00:09:27,540 --> 00:09:34,260
supports IE 11 and so it's it's we have

00:09:31,830 --> 00:09:36,200
to really take care that most of the our

00:09:34,260 --> 00:09:41,630
OEM users are able to use the technology

00:09:36,200 --> 00:09:50,130
so that's why no webassembly right now

00:09:41,630 --> 00:09:51,440
okay there are questions thank you so if

00:09:50,130 --> 00:09:56,970
anyone has any

00:09:51,440 --> 00:10:00,180
sorry I'm still experimenting with this

00:09:56,970 --> 00:10:07,800
and right now I don't have the exact

00:10:00,180 --> 00:10:15,050
numbers but yeah let's see okay anybody

00:10:07,800 --> 00:10:15,050
else okay so thank you

00:10:16,550 --> 00:10:19,640

YouTube URL: https://www.youtube.com/watch?v=9GElceCXzTI


