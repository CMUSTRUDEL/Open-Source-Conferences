Title: Solving vehicle routing problems with OpenStreetMap and VROOM
Publication date: 2018-08-17
Playlist: SotM 2018, Day 2, S.0.2
Description: 
	Julien Coupey (VERSO), State of the Map 2018
https://2018.stateofthemap.org/2018/T053-Solving_vehicle_routing_problems_with_OpenStreetMap_and_VROOM/

VROOM is an open-source software written in C++ to solve vehicle routing problems (VRP) arising in logistics and more widely in any context with geographically distributed tasks. Using OpenStreetMap data to solve real-life problems, VROOM offers an out-of-the-box integration with OSRM and is extensible to work on top of any routing engine.

The solving approach aims at providing high quality solutions efficiently by using dedicated (meta-)heuristics. This allows to get solutions very fast and/or to scale to huge problem sizes. Testing against TSPLIB, the reference benchmark for the Traveling salesman problem, shows an average optimal gap of only +2.47% while solving most instances in a few (milli)seconds.

We will describe the different ways to use VROOM by going through sample use-cases, and present the recent work toward supporting more VRP variants.
Captions: 
	00:00:02,290 --> 00:00:07,689
so my name is Jack Cooper I work at

00:00:04,960 --> 00:00:11,020
there's a company that does optimization

00:00:07,689 --> 00:00:14,050
software and among other topics we work

00:00:11,020 --> 00:00:18,130
on solving the routing problems with

00:00:14,050 --> 00:00:21,090
rule I'll give a bit of context on what

00:00:18,130 --> 00:00:24,039
kind of problems we're trying to solve

00:00:21,090 --> 00:00:26,980
then try to explain the outline of the

00:00:24,039 --> 00:00:28,510
solving approach and get to how you

00:00:26,980 --> 00:00:31,180
could use the project if you're

00:00:28,510 --> 00:00:33,070
interested so this is a talk about of

00:00:31,180 --> 00:00:33,969
instrument data usage for for

00:00:33,070 --> 00:00:39,550
transportation

00:00:33,969 --> 00:00:42,879
beyond routing vehicle routing problems

00:00:39,550 --> 00:00:44,710
come in all sort of flavors the most

00:00:42,879 --> 00:00:46,870
simple one the probably less known one

00:00:44,710 --> 00:00:49,569
is a TSP services on problem where you

00:00:46,870 --> 00:00:52,210
need to visit a list of places with only

00:00:49,569 --> 00:00:54,489
one route then if you have other

00:00:52,210 --> 00:00:57,489
constraints like capacity restrictions

00:00:54,489 --> 00:00:59,769
or time timing constraints and so on you

00:00:57,489 --> 00:01:02,979
have many different variants of the same

00:00:59,769 --> 00:01:06,340
problem but it's actually very simple to

00:01:02,979 --> 00:01:09,280
state the problem it's just okay we need

00:01:06,340 --> 00:01:13,930
a cheap set of routes across a set of

00:01:09,280 --> 00:01:15,910
points that match the constraints but

00:01:13,930 --> 00:01:16,420
it's actually known to be very hard to

00:01:15,910 --> 00:01:18,280
solve

00:01:16,420 --> 00:01:22,780
there are hundreds and thousands of

00:01:18,280 --> 00:01:25,300
articles on those subjects and one of

00:01:22,780 --> 00:01:26,650
the main main part is that whatever the

00:01:25,300 --> 00:01:28,300
approach you choose to solve those

00:01:26,650 --> 00:01:30,550
problems there's always a point where

00:01:28,300 --> 00:01:35,020
the computing time goes completely wild

00:01:30,550 --> 00:01:38,560
if the problem size increases we don't

00:01:35,020 --> 00:01:43,600
aim at writing a new paper with a new

00:01:38,560 --> 00:01:45,610
approach for an academic purpose we

00:01:43,600 --> 00:01:51,280
really want to have a prediction already

00:01:45,610 --> 00:01:53,650
solver so this we have a few

00:01:51,280 --> 00:01:56,409
requirements like real life routine

00:01:53,650 --> 00:01:59,380
this might sound obvious but usually

00:01:56,409 --> 00:02:02,050
papers don't actually treat the routine

00:01:59,380 --> 00:02:05,350
side they focus on the optimization and

00:02:02,050 --> 00:02:09,420
they take the input the travel times

00:02:05,350 --> 00:02:11,739
input as a granted like I said with

00:02:09,420 --> 00:02:13,629
getting optimal solution is usually out

00:02:11,739 --> 00:02:15,500
of reach so we don't really care about

00:02:13,629 --> 00:02:19,100
getting optimal solutions we want

00:02:15,500 --> 00:02:20,690
solution to that good enough and one

00:02:19,100 --> 00:02:22,690
very important thing is we want to

00:02:20,690 --> 00:02:25,430
maintain the completing times very low

00:02:22,690 --> 00:02:28,460
for several reasons because it makes the

00:02:25,430 --> 00:02:30,740
solver easier to use of course but also

00:02:28,460 --> 00:02:35,930
because it enables to scale to solve

00:02:30,740 --> 00:02:39,530
huge problems everything starts from the

00:02:35,930 --> 00:02:41,540
data of course and then it's well known

00:02:39,530 --> 00:02:43,190
that we have several efficient routing

00:02:41,540 --> 00:02:45,290
engines to work on a Boone Street Map

00:02:43,190 --> 00:02:48,820
data one of them is always REM so we

00:02:45,290 --> 00:02:51,770
rely on rsrm to follow all routine

00:02:48,820 --> 00:02:53,630
matters it's you're familiar with that

00:02:51,770 --> 00:02:56,240
you know you can configure routing with

00:02:53,630 --> 00:02:58,400
profiles and what we actually do is we

00:02:56,240 --> 00:03:02,810
add another optimization layer on top of

00:02:58,400 --> 00:03:04,970
that and as input we take the cost the

00:03:02,810 --> 00:03:12,800
metrics cost that computed from bi or

00:03:04,970 --> 00:03:15,500
SRM let's look at examples there have

00:03:12,800 --> 00:03:18,200
been many examples involving drinking

00:03:15,500 --> 00:03:20,750
pints in old pubs in a country or city

00:03:18,200 --> 00:03:23,120
but I don't feel it

00:03:20,750 --> 00:03:25,850
we should advertise beer drinking on a

00:03:23,120 --> 00:03:28,940
Sunday morning so I've set up an example

00:03:25,850 --> 00:03:30,950
with all restaurants that are tagged

00:03:28,940 --> 00:03:32,410
with cuisine pizza in the OpenStreetMap

00:03:30,950 --> 00:03:34,550
in Balam

00:03:32,410 --> 00:03:38,660
so let's say we want to visit them all

00:03:34,550 --> 00:03:40,250
maybe it's a silly task but from a

00:03:38,660 --> 00:03:42,260
mapping perspective it could be a way to

00:03:40,250 --> 00:03:47,299
check different objects on the ground

00:03:42,260 --> 00:03:48,670
for example if we solve a problem we

00:03:47,299 --> 00:03:55,540
just solve a travelling salesman problem

00:03:48,670 --> 00:04:00,620
so one who to cross all points that was

00:03:55,540 --> 00:04:03,950
228 places and the computing time is

00:04:00,620 --> 00:04:06,370
around 300 milliseconds if you look at

00:04:03,950 --> 00:04:09,470
the detail no no if you can see that

00:04:06,370 --> 00:04:12,049
loading part is actually getting the

00:04:09,470 --> 00:04:15,019
problem parsing the problem and most of

00:04:12,049 --> 00:04:17,359
it is computing the cost metrics so

00:04:15,019 --> 00:04:19,459
that's always our own work then the

00:04:17,359 --> 00:04:22,010
solving part is actually faster on that

00:04:19,459 --> 00:04:24,260
example and the routing class is on me

00:04:22,010 --> 00:04:28,570
about getting the to tail geometry for

00:04:24,260 --> 00:04:30,760
this plane but maybe we want to

00:04:28,570 --> 00:04:33,970
of several routes to perform the same

00:04:30,760 --> 00:04:36,460
tasks so maybe you want to add vehicle

00:04:33,970 --> 00:04:39,400
to do that you would say if we know I

00:04:36,460 --> 00:04:41,770
have two vehicle starting but the front

00:04:39,400 --> 00:04:44,260
end will do there is assigned some

00:04:41,770 --> 00:04:51,130
capacity restrictions to make sure two

00:04:44,260 --> 00:04:52,480
routes are generated so we can get now

00:04:51,130 --> 00:04:54,700
we have two different routes two

00:04:52,480 --> 00:04:58,990
round-trips to perform the same

00:04:54,700 --> 00:05:02,800
different tasks what we can do is decide

00:04:58,990 --> 00:05:05,080
on other starting points because let's

00:05:02,800 --> 00:05:09,730
say we have someone that lives here we

00:05:05,080 --> 00:05:13,660
want to start here and maybe is favorite

00:05:09,730 --> 00:05:16,270
pizza place is dal Pugliese and he wants

00:05:13,660 --> 00:05:21,190
to to end up there to get its favorite

00:05:16,270 --> 00:05:24,820
pizza if we solve the problem now we get

00:05:21,190 --> 00:05:27,240
a round trip for vehicle one and vehicle

00:05:24,820 --> 00:05:29,920
two starts here and ends here so we have

00:05:27,240 --> 00:05:32,620
great flexibility in the way we can defy

00:05:29,920 --> 00:05:34,690
the sleep you can model like single

00:05:32,620 --> 00:05:36,640
Depot situations multiple Depot or

00:05:34,690 --> 00:05:40,660
distributed fleet with different start

00:05:36,640 --> 00:05:44,320
and em what you can even do is only

00:05:40,660 --> 00:05:47,920
provide the start or the end for example

00:05:44,320 --> 00:05:49,870
is if we that's it we own the last day

00:05:47,920 --> 00:05:54,340
we don't want to get back to state of

00:05:49,870 --> 00:05:57,280
freedom at location and let's say we

00:05:54,340 --> 00:05:59,530
want to start here and if we do that the

00:05:57,280 --> 00:06:01,960
optimization phase will decide on the

00:05:59,530 --> 00:06:09,160
last visited job and the last place

00:06:01,960 --> 00:06:10,900
where we design open trips so now to

00:06:09,160 --> 00:06:14,770
give a bit of background on the project

00:06:10,900 --> 00:06:16,930
it actually all started as a proof of

00:06:14,770 --> 00:06:20,830
concept that one could solve TSP very

00:06:16,930 --> 00:06:24,540
efficiently with real-life data Ravan

00:06:20,830 --> 00:06:28,300
OpenStreetMap and full OS or integration

00:06:24,540 --> 00:06:30,670
we had several releases since version 1

00:06:28,300 --> 00:06:32,260
was about designing a stable API some

00:06:30,670 --> 00:06:35,590
work on multi-threading

00:06:32,260 --> 00:06:39,660
we can also support the use of OS RM as

00:06:35,590 --> 00:06:43,960
a library it enables to to compute the

00:06:39,660 --> 00:06:46,900
matrices faster because we use the RM

00:06:43,960 --> 00:06:49,630
from C++ directly and that latest

00:06:46,900 --> 00:06:52,990
release just about one month ago is

00:06:49,630 --> 00:06:55,960
about handling multiple vehicles we can

00:06:52,990 --> 00:06:57,250
define skills assigned to jobs and then

00:06:55,960 --> 00:07:00,970
they need to be served by matching

00:06:57,250 --> 00:07:02,950
vehicles or drivers we can define

00:07:00,970 --> 00:07:05,110
multi-dimensional capacities it means

00:07:02,950 --> 00:07:08,050
that you can impose restrictions on

00:07:05,110 --> 00:07:09,660
several metrics maybe you have weight

00:07:08,050 --> 00:07:12,160
restrictions volume restriction

00:07:09,660 --> 00:07:14,200
restrictions on number of items and jobs

00:07:12,160 --> 00:07:16,510
and so on and so you can decide what

00:07:14,200 --> 00:07:18,960
here which you which you have your own

00:07:16,510 --> 00:07:23,320
metrics and there's been some work on

00:07:18,960 --> 00:07:25,660
the ability to define you using matrices

00:07:23,320 --> 00:07:30,730
that you might want to compute from

00:07:25,660 --> 00:07:33,340
another source no how do we get the

00:07:30,730 --> 00:07:35,380
solution like I said we started with the

00:07:33,340 --> 00:07:38,800
T speed so we have a dedicated we

00:07:35,380 --> 00:07:40,180
restrict solve gspie heuristics is just

00:07:38,800 --> 00:07:44,020
a simple process to get the initial

00:07:40,180 --> 00:07:46,570
solution it's a way to get started and

00:07:44,020 --> 00:07:48,160
to handle multiple vehicles with

00:07:46,570 --> 00:07:51,070
capacity restriction we have a dedicated

00:07:48,160 --> 00:07:53,590
clustering eristic the problem here is

00:07:51,070 --> 00:07:57,070
that usual clustering algorithms remote

00:07:53,590 --> 00:07:59,140
work because first they want and all

00:07:57,070 --> 00:08:02,950
different starting and ending points for

00:07:59,140 --> 00:08:04,930
vehicles and also because they won't let

00:08:02,950 --> 00:08:08,050
you monitor all the the size of the

00:08:04,930 --> 00:08:09,850
cluster so you can't impose a capacity

00:08:08,050 --> 00:08:12,250
restrictions with usual clustering

00:08:09,850 --> 00:08:17,650
algorithms so what we actually do is we

00:08:12,250 --> 00:08:21,250
build the clusters by increasing the

00:08:17,650 --> 00:08:23,140
spanning trees in a concurrent way in

00:08:21,250 --> 00:08:25,600
order to try and minimize the overall

00:08:23,140 --> 00:08:27,040
cost and then once we're done this

00:08:25,600 --> 00:08:29,560
intervals to money twelve a Tversky

00:08:27,040 --> 00:08:31,900
restrictions and once we're done we

00:08:29,560 --> 00:08:36,340
solve it is before for each cluster

00:08:31,900 --> 00:08:38,979
simply of course you can see it's biased

00:08:36,340 --> 00:08:41,580
it's just a uracil process for example

00:08:38,979 --> 00:08:46,240
that that route is very weird because

00:08:41,580 --> 00:08:49,390
this those jobs were inputted at the end

00:08:46,240 --> 00:08:51,870
of the process they should not belong to

00:08:49,390 --> 00:08:54,910
vehicle starting here for example

00:08:51,870 --> 00:08:57,880
so what we do once we have that initial

00:08:54,910 --> 00:08:59,860
heuristic solution is we actually try to

00:08:57,880 --> 00:09:02,589
improve it we have local search things

00:08:59,860 --> 00:09:05,020
where we try to get from something like

00:09:02,589 --> 00:09:07,240
this to something like that where you

00:09:05,020 --> 00:09:11,589
can see those jobs of being assigned to

00:09:07,240 --> 00:09:14,950
routes that start at other places we've

00:09:11,589 --> 00:09:18,520
been able to fix a strange mess here

00:09:14,950 --> 00:09:20,910
which looks much better this train route

00:09:18,520 --> 00:09:23,320
spanning across several places here is

00:09:20,910 --> 00:09:27,220
split into different route and it makes

00:09:23,320 --> 00:09:29,290
much more sense so just to explain that

00:09:27,220 --> 00:09:35,470
a bit how do we do that is we apply

00:09:29,290 --> 00:09:37,990
several operation and for example just

00:09:35,470 --> 00:09:40,230
simple operations like you might want to

00:09:37,990 --> 00:09:43,450
change the job from one route to another

00:09:40,230 --> 00:09:48,160
you might want to exchange two jobs from

00:09:43,450 --> 00:09:51,779
two different routes you can do that

00:09:48,160 --> 00:09:55,440
with a set of two protective jobs

00:09:51,779 --> 00:09:59,470
changing or exchanger and we also have

00:09:55,440 --> 00:10:03,339
more complex operators that will switch

00:09:59,470 --> 00:10:05,920
the end of one route with the end of

00:10:03,339 --> 00:10:08,830
another route they will exchange whole

00:10:05,920 --> 00:10:11,830
part of the route so this is a more

00:10:08,830 --> 00:10:15,640
deeper change so it's a bit more tricky

00:10:11,830 --> 00:10:18,670
to to check - to use with the validity

00:10:15,640 --> 00:10:20,920
the capacity constraints and we are the

00:10:18,670 --> 00:10:23,260
same if rules go in the opposite

00:10:20,920 --> 00:10:26,110
direction we can replace the start of

00:10:23,260 --> 00:10:30,490
that fluid and it becomes the end of the

00:10:26,110 --> 00:10:33,400
other one can we reverse everything how

00:10:30,490 --> 00:10:36,459
do we apply those we have a basic local

00:10:33,400 --> 00:10:38,890
search step where we actually look at

00:10:36,459 --> 00:10:42,940
all pair of roots we evaluate the

00:10:38,890 --> 00:10:44,890
options of moving things like that are

00:10:42,940 --> 00:10:48,160
they valid moves do they improve the

00:10:44,890 --> 00:10:51,010
results now this is the most expensive

00:10:48,160 --> 00:10:53,620
part then we perform the best move the

00:10:51,010 --> 00:10:55,360
best option we have and then the good

00:10:53,620 --> 00:10:58,120
news is we don't need to recompute

00:10:55,360 --> 00:11:00,010
everything next time because we because

00:10:58,120 --> 00:11:02,180
we just change to loads so we only need

00:11:00,010 --> 00:11:04,130
to update was related to those two

00:11:02,180 --> 00:11:07,010
and we go back like that and apply

00:11:04,130 --> 00:11:12,380
operations until there's no improvement

00:11:07,010 --> 00:11:15,500
left sometimes this is not enough and

00:11:12,380 --> 00:11:16,330
you might want to to get out of local

00:11:15,500 --> 00:11:19,790
minimum

00:11:16,330 --> 00:11:21,890
where you would need to move job from

00:11:19,790 --> 00:11:24,500
more roots like three four five roots

00:11:21,890 --> 00:11:27,680
this is too expensive to check

00:11:24,500 --> 00:11:30,830
exhaustively so what we do instead is we

00:11:27,680 --> 00:11:33,170
spot the worst jobs we remove them from

00:11:30,830 --> 00:11:36,440
the solution to kind of loosen the

00:11:33,170 --> 00:11:39,800
constraints and then we put them back in

00:11:36,440 --> 00:11:43,430
a fully better way and go over on the

00:11:39,800 --> 00:11:46,040
only local such step the good thing

00:11:43,430 --> 00:11:49,760
where this is it allows to a different

00:11:46,040 --> 00:11:53,029
level of of exploration and we expose

00:11:49,760 --> 00:11:54,529
that in the API from zero to five zero

00:11:53,029 --> 00:11:57,350
means I want the fastest solution

00:11:54,529 --> 00:11:59,779
possible and each time you increase that

00:11:57,350 --> 00:12:02,810
that level it means ok I'm prepared to

00:11:59,779 --> 00:12:08,740
compute for a longer time in order to

00:12:02,810 --> 00:12:11,390
get a better solution maybe how do we

00:12:08,740 --> 00:12:14,000
look at our results how can we assert

00:12:11,390 --> 00:12:17,660
that we have good results the only way

00:12:14,000 --> 00:12:19,010
to do that is to work on benchmarks just

00:12:17,660 --> 00:12:22,700
believe is a reference benchmark from

00:12:19,010 --> 00:12:24,980
TSP so no map here sorry it's just

00:12:22,700 --> 00:12:27,130
played a fleeting distance but it's

00:12:24,980 --> 00:12:29,690
actually the only way to check because

00:12:27,130 --> 00:12:33,220
those problems have been easily studied

00:12:29,690 --> 00:12:33,220
so all optimal solutions are known

00:12:33,520 --> 00:12:42,440
instances are quite good quite big I

00:12:38,000 --> 00:12:45,200
mean up to nearly 20,000 points a word

00:12:42,440 --> 00:12:47,150
on the results it doesn't because the

00:12:45,200 --> 00:12:48,680
size are really different doesn't make

00:12:47,150 --> 00:12:50,450
sense to look at the average computing

00:12:48,680 --> 00:12:53,270
time but the median computing time it's

00:12:50,450 --> 00:12:55,070
28 milliseconds which means that all of

00:12:53,270 --> 00:12:56,660
the instances are solved in less than

00:12:55,070 --> 00:13:00,980
twenty eight milliseconds which is very

00:12:56,660 --> 00:13:02,930
fast the gap to optimal solution this

00:13:00,980 --> 00:13:05,240
just means that if the optimal solution

00:13:02,930 --> 00:13:08,630
cost 1 and greater whatever the unit

00:13:05,240 --> 00:13:12,670
then we provide solution that cost 103

00:13:08,630 --> 00:13:15,040
on average so

00:13:12,670 --> 00:13:17,260
the thing is we say that's good enough

00:13:15,040 --> 00:13:21,279
and we don't want you to look further

00:13:17,260 --> 00:13:23,769
because it's fast and I've provided a

00:13:21,279 --> 00:13:26,170
few a few a result to give a sense of

00:13:23,769 --> 00:13:29,050
scale for the computing times if you

00:13:26,170 --> 00:13:32,050
look at small problems in the hundreds

00:13:29,050 --> 00:13:36,160
it's just a matter of milliseconds then

00:13:32,050 --> 00:13:38,740
if you reach 2 mm it's just 1 a bit more

00:13:36,160 --> 00:13:41,110
than once again and start to grow more

00:13:38,740 --> 00:13:44,920
but for the biggest problem nearly

00:13:41,110 --> 00:13:50,829
twenty thousand points we are only half

00:13:44,920 --> 00:13:54,029
an hour also to be complete with

00:13:50,829 --> 00:13:58,050
benchmarks there are benchmarks for the

00:13:54,029 --> 00:14:00,940
CVR P there is capacity restrictions

00:13:58,050 --> 00:14:05,890
what's difficult in those benchmarks is

00:14:00,940 --> 00:14:08,470
that the amount if you think of capacity

00:14:05,890 --> 00:14:10,540
restrictions in terms of weight the

00:14:08,470 --> 00:14:14,140
ranges here represent the amount for a

00:14:10,540 --> 00:14:18,970
job so it might make sense that this job

00:14:14,140 --> 00:14:20,800
would be in a route that pass close but

00:14:18,970 --> 00:14:22,630
it's not possible because of the

00:14:20,800 --> 00:14:25,540
restrictions so that's what makes a

00:14:22,630 --> 00:14:30,220
problem difficult here and in those

00:14:25,540 --> 00:14:33,029
benchmarks there's a huge tightness

00:14:30,220 --> 00:14:36,550
which means if you want to solve the

00:14:33,029 --> 00:14:39,459
instances and handle whole jobs then you

00:14:36,550 --> 00:14:42,010
need to have nearly always full vehicles

00:14:39,459 --> 00:14:45,730
which is how to achieve because of the

00:14:42,010 --> 00:14:47,920
packing problem here a word of the

00:14:45,730 --> 00:14:50,010
results so I'm reporting results for the

00:14:47,920 --> 00:14:54,300
in the first column for the fastest

00:14:50,010 --> 00:14:56,980
exploration level and and the best one

00:14:54,300 --> 00:15:00,399
you can see that computing times stay

00:14:56,980 --> 00:15:03,010
quite low we are not able to always

00:15:00,399 --> 00:15:05,019
assign all jobs but we will nearly we're

00:15:03,010 --> 00:15:09,010
really close more than 99 percent of the

00:15:05,019 --> 00:15:11,860
jobs assigned as a result not all

00:15:09,010 --> 00:15:14,140
instances of all jobs solve so we do

00:15:11,860 --> 00:15:16,449
provide a solution but we just also say

00:15:14,140 --> 00:15:19,680
ok we have a list of a few job that

00:15:16,449 --> 00:15:22,390
could not be assigned and for all

00:15:19,680 --> 00:15:23,830
instances where we we could assign all

00:15:22,390 --> 00:15:25,960
jobs then it makes sense to

00:15:23,830 --> 00:15:29,040
compared the cost we have with the best

00:15:25,960 --> 00:15:33,220
known solutions in the literature and

00:15:29,040 --> 00:15:35,020
you can see that you reach good gaps -

00:15:33,220 --> 00:15:38,230
best known solutions that can be even

00:15:35,020 --> 00:15:43,060
lowered if you if your computer or a bit

00:15:38,230 --> 00:15:44,560
longer so now that may be the most

00:15:43,060 --> 00:15:46,900
interesting part if you want to use a

00:15:44,560 --> 00:15:50,350
project how quick can you get started

00:15:46,900 --> 00:15:52,750
first you need a no SRM server running

00:15:50,350 --> 00:15:55,660
on top of sri tab data it could be your

00:15:52,750 --> 00:15:58,450
own or remote service or whatever you

00:15:55,660 --> 00:16:00,930
need to clone the backend solver from

00:15:58,450 --> 00:16:04,060
the room project namespace on github

00:16:00,930 --> 00:16:08,350
compile it then you can use the room as

00:16:04,060 --> 00:16:10,630
they come online if this is not really

00:16:08,350 --> 00:16:13,390
convenient you might want to use that on

00:16:10,630 --> 00:16:16,270
server and make remote calls there is a

00:16:13,390 --> 00:16:19,120
small wrapper or that from Express is

00:16:16,270 --> 00:16:21,840
just an Express GS server that will

00:16:19,120 --> 00:16:24,070
receive post requests containing the

00:16:21,840 --> 00:16:27,580
problem

00:16:24,070 --> 00:16:29,110
I suppose data handled solving and give

00:16:27,580 --> 00:16:34,330
back the answer in there in their

00:16:29,110 --> 00:16:36,480
response and if you even want a simpler

00:16:34,330 --> 00:16:39,190
way to do that you can use the front end

00:16:36,480 --> 00:16:42,460
which is what I showed you the demo

00:16:39,190 --> 00:16:44,590
earlier say oh this is open source of

00:16:42,460 --> 00:16:46,660
course you can run that on your own in

00:16:44,590 --> 00:16:48,400
sense the demo art I've been showing

00:16:46,660 --> 00:16:52,480
everything was running on my on my

00:16:48,400 --> 00:16:55,510
laptop good news is if you don't even

00:16:52,480 --> 00:16:59,230
want to set that on your machine we have

00:16:55,510 --> 00:17:01,900
a demo server you can fire your request

00:16:59,230 --> 00:17:06,780
to and there's also a demo front-end so

00:17:01,900 --> 00:17:11,830
we can just try with a few mouse clicks

00:17:06,780 --> 00:17:16,480
a quick look at I would come online look

00:17:11,830 --> 00:17:19,860
- not very surprising you can use some

00:17:16,480 --> 00:17:23,650
data or input or output or provide files

00:17:19,860 --> 00:17:26,290
you can provide a number of threads for

00:17:23,650 --> 00:17:30,100
paralyzation this the expression level

00:17:26,290 --> 00:17:32,620
you can set up the address and port of

00:17:30,100 --> 00:17:33,670
the u.s. arm server so if you don't have

00:17:32,620 --> 00:17:36,400
an orange

00:17:33,670 --> 00:17:41,470
if you run that you will eat the OS our

00:17:36,400 --> 00:17:44,350
demo server using a post request with

00:17:41,470 --> 00:17:47,860
curl the interesting part is you can

00:17:44,350 --> 00:17:51,429
send your request to our demo server

00:17:47,860 --> 00:17:52,900
server dot room project at all so you

00:17:51,429 --> 00:17:55,210
can actually get started just by

00:17:52,900 --> 00:18:00,160
formatting your own problem in chitin

00:17:55,210 --> 00:18:02,770
probably the API M and and try it as a

00:18:00,160 --> 00:18:04,840
conclusion why we didn't use room if you

00:18:02,770 --> 00:18:06,309
have this kind of problem to solve

00:18:04,840 --> 00:18:08,950
of course it's based on the pin Street

00:18:06,309 --> 00:18:11,710
Map makes use of the opus repÃºblica C

00:18:08,950 --> 00:18:13,270
ecosystem tools like OS RM is based a

00:18:11,710 --> 00:18:16,179
license so you can do pretty much

00:18:13,270 --> 00:18:18,370
whatever you want I hope I've convinced

00:18:16,179 --> 00:18:21,070
you that it's efficient and efficient

00:18:18,370 --> 00:18:24,549
means both you will get good solutions

00:18:21,070 --> 00:18:29,380
and also you get solutions fast and this

00:18:24,549 --> 00:18:30,970
is the very important thing in the way

00:18:29,380 --> 00:18:33,660
we design the approach because it allows

00:18:30,970 --> 00:18:36,490
you to scale and fill in instances and

00:18:33,660 --> 00:18:39,429
this will probably be the first question

00:18:36,490 --> 00:18:42,100
if I don't mention it we do have plans

00:18:39,429 --> 00:18:45,700
to include chiming constraints of next

00:18:42,100 --> 00:18:48,299
release so letting you with the few

00:18:45,700 --> 00:18:51,070
links if you want to check out the demo

00:18:48,299 --> 00:18:54,370
head up to map the room project at all

00:18:51,070 --> 00:18:57,460
the wiki has all required information

00:18:54,370 --> 00:19:01,760
for building using and you can full

00:18:57,460 --> 00:19:04,859
project news on Twitter thank you

00:19:01,760 --> 00:19:04,859
[Applause]

00:19:07,220 --> 00:19:14,640
thank you for the presentation oceans

00:19:11,420 --> 00:19:17,580
thanks what are the advantages of using

00:19:14,640 --> 00:19:18,840
room over something like optic liner is

00:19:17,580 --> 00:19:22,470
there's a lot of data on why this is

00:19:18,840 --> 00:19:26,160
good like if I have to choose a vehicle

00:19:22,470 --> 00:19:27,920
routing solution why is this or what is

00:19:26,160 --> 00:19:32,640
different about this then like over over

00:19:27,920 --> 00:19:37,370
optical inner entrepreneur well up to

00:19:32,640 --> 00:19:39,990
planner is an all-purpose solving engine

00:19:37,370 --> 00:19:42,630
it includes the same kind of local

00:19:39,990 --> 00:19:44,850
search procedure but it's really a

00:19:42,630 --> 00:19:47,400
generic tool that can be used to solve

00:19:44,850 --> 00:19:52,290
recruiting problems but also scheduling

00:19:47,400 --> 00:19:57,390
problems and it's it's there's a more

00:19:52,290 --> 00:20:00,300
broad range of application so as a

00:19:57,390 --> 00:20:02,309
result it's more generic Oh on the

00:20:00,300 --> 00:20:04,650
contrary like I said we have a very

00:20:02,309 --> 00:20:06,600
dedicated approach to solve a TSP if you

00:20:04,650 --> 00:20:08,280
want to solve the trace be it ESP with

00:20:06,600 --> 00:20:10,140
room you'll go through the TSP code that

00:20:08,280 --> 00:20:13,440
makes use of the problem is

00:20:10,140 --> 00:20:15,420
actually simpler so it really may be it

00:20:13,440 --> 00:20:17,880
will be quite the same term of quality

00:20:15,420 --> 00:20:25,770
but it will be I would expect it to be

00:20:17,880 --> 00:20:28,110
much faster that's right do you support

00:20:25,770 --> 00:20:31,650
different routing modes like moto

00:20:28,110 --> 00:20:35,790
transport car feel support different

00:20:31,650 --> 00:20:39,270
modes of transport like our HTV

00:20:35,790 --> 00:20:41,880
pedestrian cycling yeah it's all holes

00:20:39,270 --> 00:20:45,470
RMBS right but you are the API that

00:20:41,880 --> 00:20:49,170
talks to OS RM back young so can you

00:20:45,470 --> 00:20:51,330
actually include moto transport or is it

00:20:49,170 --> 00:20:53,970
all car do you mean on the on the

00:20:51,330 --> 00:20:56,550
solving side or you know in a metric

00:20:53,970 --> 00:20:59,850
side so if you computer mattresses with

00:20:56,550 --> 00:21:02,160
oars RM you can yeah give it more than

00:20:59,850 --> 00:21:05,220
transport right the first answer to this

00:21:02,160 --> 00:21:07,890
is yes we do because it's it's all our

00:21:05,220 --> 00:21:10,410
routing matter so you can you can do

00:21:07,890 --> 00:21:13,890
whatever you want at that level and it

00:21:10,410 --> 00:21:15,570
will just impact the cost we get and we

00:21:13,890 --> 00:21:17,820
work with the cost you have from from

00:21:15,570 --> 00:21:19,980
your routing profiles so if you just

00:21:17,820 --> 00:21:23,900
switch profile we work with whatever

00:21:19,980 --> 00:21:28,110
choose to work for routing right but

00:21:23,900 --> 00:21:31,380
boom is the API that talks to the O's RN

00:21:28,110 --> 00:21:34,740
back-end right so as a user I would not

00:21:31,380 --> 00:21:39,929
really see the O's RN again so I would

00:21:34,740 --> 00:21:42,179
not be able to talk to him right yeah so

00:21:39,929 --> 00:21:45,540
I would have to specify a mode of

00:21:42,179 --> 00:21:49,140
transport within your API you have to do

00:21:45,540 --> 00:21:52,049
that here actually well we do support it

00:21:49,140 --> 00:21:53,640
there's a flag we do have a flag for

00:21:52,049 --> 00:21:56,970
mode of transportation from the common

00:21:53,640 --> 00:21:59,160
line and this will change the the

00:21:56,970 --> 00:22:03,600
request you do to I saw em but then you

00:21:59,160 --> 00:22:06,570
have to have your own load balancer here

00:22:03,600 --> 00:22:08,970
to to hit different toys run servers you

00:22:06,570 --> 00:22:11,340
can do that cause but you have work to

00:22:08,970 --> 00:22:14,730
set up different modes of transport here

00:22:11,340 --> 00:22:17,400
right so there's also native support in

00:22:14,730 --> 00:22:19,740
whom to specify the printer

00:22:17,400 --> 00:22:22,080
well transit to be precise there's a

00:22:19,740 --> 00:22:24,750
command line flag that will change the

00:22:22,080 --> 00:22:28,020
way the OEM request is written if

00:22:24,750 --> 00:22:30,390
there's a profile parameter the bad news

00:22:28,020 --> 00:22:32,490
is it's not actually in use in the US

00:22:30,390 --> 00:22:36,059
arm a P I so you would have to set up

00:22:32,490 --> 00:22:39,870
your own proxy server with Angie I need

00:22:36,059 --> 00:22:41,850
whatever to direct the request okay this

00:22:39,870 --> 00:22:45,620
is rather and always very related

00:22:41,850 --> 00:22:48,840
question and that's it thank you

00:22:45,620 --> 00:22:51,570
currently you've got one matrix which

00:22:48,840 --> 00:22:53,910
you used for the entire problem so kind

00:22:51,570 --> 00:22:56,190
of two-dimensional matrix when you're

00:22:53,910 --> 00:22:57,809
doing vehicle routing across a whole

00:22:56,190 --> 00:23:01,160
day's mission alone quite a busy urban

00:22:57,809 --> 00:23:04,440
area the traffic levels for different

00:23:01,160 --> 00:23:07,380
journeys in the matrix might change so a

00:23:04,440 --> 00:23:09,570
road which is good to take at 6 a.m.

00:23:07,380 --> 00:23:12,299
because it's low traffic might be really

00:23:09,570 --> 00:23:14,400
bad road to taker to 3 p.m. when was

00:23:12,299 --> 00:23:16,380
loads of traffic around have you had any

00:23:14,400 --> 00:23:18,919
thoughts about supporting effectively

00:23:16,380 --> 00:23:22,470
three dimensional matrices where the

00:23:18,919 --> 00:23:27,000
weather times between columns and Rome's

00:23:22,470 --> 00:23:28,650
change during the day yeah well the easy

00:23:27,000 --> 00:23:31,840
answer to this is it's actually a

00:23:28,650 --> 00:23:33,970
routing problem so if you have

00:23:31,840 --> 00:23:35,980
good routing here with traffic

00:23:33,970 --> 00:23:39,240
information of course you will improve

00:23:35,980 --> 00:23:43,720
the results of the optimization but

00:23:39,240 --> 00:23:46,360
actually having several formula we have

00:23:43,720 --> 00:23:48,580
only one metrics to describe the cost so

00:23:46,360 --> 00:23:52,470
we can't take into account the changes

00:23:48,580 --> 00:23:54,790
of the cost during the day that would be

00:23:52,470 --> 00:23:56,650
maybe another this would be an option to

00:23:54,790 --> 00:24:02,320
have several matrices but it would incur

00:23:56,650 --> 00:24:04,360
also performances drawbacks because if

00:24:02,320 --> 00:24:05,950
you change a route like in the local

00:24:04,360 --> 00:24:07,810
search phase if you modify your route

00:24:05,950 --> 00:24:10,690
like you add a job you will be shifting

00:24:07,810 --> 00:24:12,640
everything after that job so you will

00:24:10,690 --> 00:24:15,310
potentially be changing at all cost

00:24:12,640 --> 00:24:17,730
so you would need it would require to go

00:24:15,310 --> 00:24:20,380
through the old route which is much more

00:24:17,730 --> 00:24:23,980
complex in term of algorithm complexity

00:24:20,380 --> 00:24:25,780
so probably this would be much expensive

00:24:23,980 --> 00:24:28,480
much more expensive in terms of

00:24:25,780 --> 00:24:30,310
computing time okay they don't support

00:24:28,480 --> 00:24:33,490
that right yeah yeah I can ascend that a

00:24:30,310 --> 00:24:37,240
slight slight follow-up question the

00:24:33,490 --> 00:24:39,220
pace of development on OS RM seems to

00:24:37,240 --> 00:24:40,530
have gone kind of quiet in the last

00:24:39,220 --> 00:24:43,570
couple of months

00:24:40,530 --> 00:24:46,510
do you have any thoughts on how that

00:24:43,570 --> 00:24:50,260
might impact room are you planning to

00:24:46,510 --> 00:24:52,390
stay tightly coupled to OS RM or might

00:24:50,260 --> 00:24:57,610
be worth looking at other routing for

00:24:52,390 --> 00:25:00,310
light as well the good thing about but

00:24:57,610 --> 00:25:03,280
this is if you want you can actually

00:25:00,310 --> 00:25:05,440
change that if you want to use room with

00:25:03,280 --> 00:25:07,720
any other routing engine you just have

00:25:05,440 --> 00:25:10,360
to rewrite a small wrapper for the

00:25:07,720 --> 00:25:12,420
queries and you could just change just

00:25:10,360 --> 00:25:17,920
that bit and it will work all the same

00:25:12,420 --> 00:25:20,290
so on the other side our sorry I'm is

00:25:17,920 --> 00:25:21,820
quite efficient this that's the reason

00:25:20,290 --> 00:25:24,400
why room uses the OS room it's very

00:25:21,820 --> 00:25:27,820
efficient for metrics computing and I

00:25:24,400 --> 00:25:29,650
mean it works even if it's not actively

00:25:27,820 --> 00:25:33,760
maintained or we'll see what future

00:25:29,650 --> 00:25:40,710
holds but I mean it does work okay thank

00:25:33,760 --> 00:25:43,720
you hello over here

00:25:40,710 --> 00:25:44,450
so you're calculating the matrix and

00:25:43,720 --> 00:25:46,850
then

00:25:44,450 --> 00:25:49,580
into the optimization engine but have

00:25:46,850 --> 00:25:53,060
you thought about u-turn prevention at a

00:25:49,580 --> 00:25:54,620
location you're optimizing so you're

00:25:53,060 --> 00:25:57,250
arriving they don't want to make a

00:25:54,620 --> 00:26:01,610
u-turn let's say you have a big truck

00:25:57,250 --> 00:26:05,180
picking up stuff and livering stuff yeah

00:26:01,610 --> 00:26:08,240
data actually there's actually an option

00:26:05,180 --> 00:26:10,160
for that you know sorry request for the

00:26:08,240 --> 00:26:12,470
approaches you can make sure that the

00:26:10,160 --> 00:26:15,310
approaches will be on the right side of

00:26:12,470 --> 00:26:17,650
the road or you can avoid the u-turns

00:26:15,310 --> 00:26:21,140
the results you get from all this are in

00:26:17,650 --> 00:26:26,360
so you can actually tweak that in to

00:26:21,140 --> 00:26:31,190
impact the the cost matrix yeah but what

00:26:26,360 --> 00:26:33,350
about so those are from A to B but what

00:26:31,190 --> 00:26:35,900
if you your optimization engine says we

00:26:33,350 --> 00:26:38,210
arrive at the location a and then go to

00:26:35,900 --> 00:26:39,890
location B it has to be at the level of

00:26:38,210 --> 00:26:41,570
the optimization yeah yeah I see what

00:26:39,890 --> 00:26:44,960
you mean it depends on on the order of

00:26:41,570 --> 00:26:49,010
the points yeah no we actually demand

00:26:44,960 --> 00:26:50,780
that that level of priority but we are

00:26:49,010 --> 00:26:53,960
planning things for for whole day I'm

00:26:50,780 --> 00:26:58,460
not sure this is that important for the

00:26:53,960 --> 00:27:00,910
whole planning row business but if you

00:26:58,460 --> 00:27:04,049
have experience with that I've discussed

00:27:00,910 --> 00:27:04,049

YouTube URL: https://www.youtube.com/watch?v=HHkwYvFMRiI


