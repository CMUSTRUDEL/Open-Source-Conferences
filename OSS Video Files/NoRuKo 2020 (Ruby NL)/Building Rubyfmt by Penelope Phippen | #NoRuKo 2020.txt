Title: Building Rubyfmt by Penelope Phippen | #NoRuKo 2020
Publication date: 2020-09-11
Playlist: #NoRuKo 2020
Description: 
	In this talk I'll discuss Rubyfmt, a work in progress Ruby autoformatter. Why I'm building it, and how it differs from Rubocop, the closest similar tool that you might be familiar with. I'll get deep in to the weeds on some of the technical challenges of building a system like this, and what the overall goals for the project are.

Penelope Phippen makes Rubyfmt, and was previously a lead maintainer of the Rspec testing framework. She's been writing Ruby for just about a decade, and still remembers writing Ruby for 1.8.6.

Welcome to the #NoRuKo conference. A virtual unconference organized by Stichting Ruby NL.

#NoRuKo playlist with all talks and panels: https://www.youtube.com/playlist?list=PL9_A7olkztLlmJIAc567KQgKcMi7-qnjg

Recorded 21th of August, 2020.
NoRuKo website: https://noruko.org/
Stichting Ruby NL website: https://rubynl.org/
Captions: 
	00:00:01,360 --> 00:00:04,000
welcome back

00:00:04,160 --> 00:00:11,679
hey and we're back

00:00:07,440 --> 00:00:15,759
so um before our next talk we have some

00:00:11,679 --> 00:00:18,960
fun interactive game for you all

00:00:15,759 --> 00:00:22,800
so as developers we all have opinions

00:00:18,960 --> 00:00:25,119
and uh our sponsor ab signal has created

00:00:22,800 --> 00:00:27,119
these really fun interactive cards

00:00:25,119 --> 00:00:30,160
called developer dilemmas

00:00:27,119 --> 00:00:32,480
so you will see a link of

00:00:30,160 --> 00:00:33,840
the one of the developer dilemma cards

00:00:32,480 --> 00:00:36,559
right in the chat

00:00:33,840 --> 00:00:38,079
and basically you can pick your favorite

00:00:36,559 --> 00:00:41,600
what kind of developer are you

00:00:38,079 --> 00:00:44,719
are you a move fast break things person

00:00:41,600 --> 00:00:48,160
or are you strive for zero errors

00:00:44,719 --> 00:00:50,480
kind of person developer so jump in

00:00:48,160 --> 00:00:52,640
cast your vote but wait don't go

00:00:50,480 --> 00:00:53,440
anywhere just yet like don't touch that

00:00:52,640 --> 00:00:55,840
dial

00:00:53,440 --> 00:00:56,960
because we still have penelope's talk

00:00:55,840 --> 00:00:59,760
coming up

00:00:56,960 --> 00:01:00,559
and i'm sure ramon can tell a bit more

00:00:59,760 --> 00:01:04,159
about her

00:01:00,559 --> 00:01:06,280
please ramon absolutely i'd be happy to

00:01:04,159 --> 00:01:07,680
so penelope is a director at

00:01:06,280 --> 00:01:10,080
rubycentral.org which

00:01:07,680 --> 00:01:12,400
amongst other things uh brings us

00:01:10,080 --> 00:01:14,240
rubyconf and railsconf

00:01:12,400 --> 00:01:16,000
she's led the development of rspect in

00:01:14,240 --> 00:01:18,000
the past as well as major

00:01:16,000 --> 00:01:19,360
one of the major testing rules uh tools

00:01:18,000 --> 00:01:22,000
for ruby

00:01:19,360 --> 00:01:23,360
and she's been writing ruby for just

00:01:22,000 --> 00:01:26,960
about a decade

00:01:23,360 --> 00:01:27,840
around the time of 1.8.6 and she's gonna

00:01:26,960 --> 00:01:30,640
tell us

00:01:27,840 --> 00:01:31,439
all about ruby formatter so please

00:01:30,640 --> 00:01:34,960
penelope

00:01:31,439 --> 00:01:38,159
take it away the stage is yours

00:01:34,960 --> 00:01:39,920
absolutely thank you so much and i see

00:01:38,159 --> 00:01:40,799
you have my slides cool all right let's

00:01:39,920 --> 00:01:43,520
go

00:01:40,799 --> 00:01:44,000
hi everyone this is building ruby format

00:01:43,520 --> 00:01:47,119
let's

00:01:44,000 --> 00:01:48,159
get started so to build on that

00:01:47,119 --> 00:01:50,560
introduction slightly

00:01:48,159 --> 00:01:51,520
my name is penelope flippin i go by

00:01:50,560 --> 00:01:53,920
penelope zone

00:01:51,520 --> 00:01:55,040
almost everywhere on the internet i use

00:01:53,920 --> 00:01:58,479
she her pronouns

00:01:55,040 --> 00:01:59,119
and i'm a trans woman as mentioned i'm a

00:01:58,479 --> 00:02:02,040
director

00:01:59,119 --> 00:02:03,200
at ruby central ruby central is the

00:02:02,040 --> 00:02:05,680
501c3

00:02:03,200 --> 00:02:06,960
not-for-profit in the united states that

00:02:05,680 --> 00:02:09,520
organizes rubyconf

00:02:06,960 --> 00:02:10,479
and railsconf and so every year we put

00:02:09,520 --> 00:02:13,040
on the two

00:02:10,479 --> 00:02:13,840
sort of like largest biggest like uh

00:02:13,040 --> 00:02:17,040
conferences

00:02:13,840 --> 00:02:18,959
in our community and we have uh rubyconf

00:02:17,040 --> 00:02:20,480
coming up in in just a little while the

00:02:18,959 --> 00:02:22,560
cfp for rubyconf

00:02:20,480 --> 00:02:23,680
is currently open and like every

00:02:22,560 --> 00:02:26,000
conference this year

00:02:23,680 --> 00:02:28,319
it's going to be entirely virtual um and

00:02:26,000 --> 00:02:29,360
so if you have not yet submitted a talk

00:02:28,319 --> 00:02:32,000
to ruby half

00:02:29,360 --> 00:02:34,319
i would highly encourage you to do so uh

00:02:32,000 --> 00:02:37,120
this is a great way to get uh

00:02:34,319 --> 00:02:38,800
started and especially uh because it's a

00:02:37,120 --> 00:02:40,000
large event that this year you don't

00:02:38,800 --> 00:02:42,720
have to travel for

00:02:40,000 --> 00:02:45,040
i would really encourage you to submit

00:02:42,720 --> 00:02:47,200
uh along with my my role at ruby central

00:02:45,040 --> 00:02:48,239
i will also be programmed sharing

00:02:47,200 --> 00:02:50,319
railsconf

00:02:48,239 --> 00:02:52,319
next year and it's not quite clear to us

00:02:50,319 --> 00:02:53,680
whether railsconf in april will be

00:02:52,319 --> 00:02:55,440
virtual or

00:02:53,680 --> 00:02:57,760
in person yet but i'd also encourage you

00:02:55,440 --> 00:03:01,360
to watch out and submit to that when the

00:02:57,760 --> 00:03:03,120
cfv opens um the other thing i wanted to

00:03:01,360 --> 00:03:06,159
say before i got too far into this

00:03:03,120 --> 00:03:06,640
is um this slide deck that i have been

00:03:06,159 --> 00:03:09,040
building

00:03:06,640 --> 00:03:11,040
crashed keynote this morning when i was

00:03:09,040 --> 00:03:11,840
working on it like an update occurred or

00:03:11,040 --> 00:03:13,920
something

00:03:11,840 --> 00:03:15,840
so we're all gonna pray that like

00:03:13,920 --> 00:03:19,120
computers work

00:03:15,840 --> 00:03:22,000
uh this morning and hopefully everything

00:03:19,120 --> 00:03:23,360
will be fine and with that sort of like

00:03:22,000 --> 00:03:25,120
preamble out of the way

00:03:23,360 --> 00:03:26,560
let's get into it and talk about like

00:03:25,120 --> 00:03:30,319
what ruby format

00:03:26,560 --> 00:03:32,080
actually is and like the the easiest

00:03:30,319 --> 00:03:34,640
answer to that question is like ruby

00:03:32,080 --> 00:03:36,239
format is a ruby auto formatter and like

00:03:34,640 --> 00:03:37,680
i could finish the talk

00:03:36,239 --> 00:03:39,680
here and like that would answer the

00:03:37,680 --> 00:03:41,280
question but it's not like super useful

00:03:39,680 --> 00:03:42,720
so instead let's go like straight to a

00:03:41,280 --> 00:03:44,560
demonstration

00:03:42,720 --> 00:03:46,239
so like what you see here is me just

00:03:44,560 --> 00:03:47,760
like typing some ruby

00:03:46,239 --> 00:03:49,760
and the thing that you will probably

00:03:47,760 --> 00:03:50,159
most note about this ruby code is it

00:03:49,760 --> 00:03:51,920
looks

00:03:50,159 --> 00:03:53,200
nothing like the ruby code you would

00:03:51,920 --> 00:03:55,680
write on a daily basis

00:03:53,200 --> 00:03:57,120
it's really bad i saved the file though

00:03:55,680 --> 00:03:59,519
and the code just snaps

00:03:57,120 --> 00:04:00,159
into place and this is ruby format

00:03:59,519 --> 00:04:01,840
working

00:04:00,159 --> 00:04:03,760
in the background ruby format is

00:04:01,840 --> 00:04:05,519
designed to just sit there in your

00:04:03,760 --> 00:04:07,040
editor watch for your changes and every

00:04:05,519 --> 00:04:10,000
time you save your file

00:04:07,040 --> 00:04:12,000
overwrite it with a formatted version in

00:04:10,000 --> 00:04:14,239
other words ruby format is a program

00:04:12,000 --> 00:04:16,079
that is designed to consume ruby source

00:04:14,239 --> 00:04:18,799
code transform it

00:04:16,079 --> 00:04:19,680
and output semantically equivalent ruby

00:04:18,799 --> 00:04:22,160
source code

00:04:19,680 --> 00:04:23,280
just with very much cleaned up

00:04:22,160 --> 00:04:24,880
formatting and

00:04:23,280 --> 00:04:26,479
and that's like sort of the core idea

00:04:24,880 --> 00:04:28,720
review format is a program that

00:04:26,479 --> 00:04:29,360
transforms ruby programs into equivalent

00:04:28,720 --> 00:04:31,919
ones

00:04:29,360 --> 00:04:32,400
that just have cleaner formatting but

00:04:31,919 --> 00:04:34,479
like

00:04:32,400 --> 00:04:35,680
beyond that ruby format is also designed

00:04:34,479 --> 00:04:39,360
to be a program

00:04:35,680 --> 00:04:41,120
that lives in your editor like

00:04:39,360 --> 00:04:42,720
one of my sort of like core philosophies

00:04:41,120 --> 00:04:45,840
is formatting should happen

00:04:42,720 --> 00:04:47,520
as you're editing not like uh you know

00:04:45,840 --> 00:04:48,800
in ci like you shouldn't have to have

00:04:47,520 --> 00:04:49,520
this whole back and forth you should be

00:04:48,800 --> 00:04:52,639
able to get it in

00:04:49,520 --> 00:04:54,560
almost real time and so like to that end

00:04:52,639 --> 00:04:56,240
like from the very beginning ruby format

00:04:54,560 --> 00:04:57,440
was designed to be a program that lives

00:04:56,240 --> 00:04:59,919
in your text editor

00:04:57,440 --> 00:05:00,720
today we have like strong support for

00:04:59,919 --> 00:05:03,680
vmac

00:05:00,720 --> 00:05:04,880
vim emax and atom uh sublime support is

00:05:03,680 --> 00:05:06,720
like kind of questionable

00:05:04,880 --> 00:05:08,080
and like i'm not really sure what's

00:05:06,720 --> 00:05:11,199
going on with vs code

00:05:08,080 --> 00:05:14,479
if you are a vs code or sublime user

00:05:11,199 --> 00:05:16,800
please please please please come to the

00:05:14,479 --> 00:05:18,560
ruby format issue tracker and like

00:05:16,800 --> 00:05:20,400
test it out and let us know whether or

00:05:18,560 --> 00:05:23,440
not it works for you

00:05:20,400 --> 00:05:25,199
um i would really love to like finally

00:05:23,440 --> 00:05:28,800
release this thing with full support

00:05:25,199 --> 00:05:30,560
for all of the text editors

00:05:28,800 --> 00:05:32,720
um the other thing that's like sort of

00:05:30,560 --> 00:05:35,199
very important about ruby format

00:05:32,720 --> 00:05:36,080
is that it's fast it's really really

00:05:35,199 --> 00:05:39,360
fast and like

00:05:36,080 --> 00:05:42,240
this is just a necessary feature if you

00:05:39,360 --> 00:05:43,520
live in somebody's text editor you don't

00:05:42,240 --> 00:05:45,440
want to be in a place

00:05:43,520 --> 00:05:47,199
where you like save the file and then

00:05:45,440 --> 00:05:49,520
have to wait an appreciable

00:05:47,199 --> 00:05:50,720
amount of time before you can resume

00:05:49,520 --> 00:05:52,639
editing and so like

00:05:50,720 --> 00:05:54,560
to that end the sort of like performance

00:05:52,639 --> 00:05:56,479
numbers as they stand today

00:05:54,560 --> 00:05:58,240
is that if you run ruby format over a

00:05:56,479 --> 00:06:01,039
2500 line

00:05:58,240 --> 00:06:01,919
file it's gonna take 60 milliseconds

00:06:01,039 --> 00:06:04,960
it's going to

00:06:01,919 --> 00:06:07,360
like finish faster than you can notice

00:06:04,960 --> 00:06:08,880
that like anything has been happening

00:06:07,360 --> 00:06:10,400
and this is really powerful because it

00:06:08,880 --> 00:06:13,360
enables that kind of like

00:06:10,400 --> 00:06:14,720
uh format on save workflow i

00:06:13,360 --> 00:06:17,440
demonstrated

00:06:14,720 --> 00:06:18,319
earlier but the thing that's really

00:06:17,440 --> 00:06:20,800
interesting about

00:06:18,319 --> 00:06:21,680
designing in this like performance as a

00:06:20,800 --> 00:06:23,280
feature

00:06:21,680 --> 00:06:25,440
is that it means that like on sort of

00:06:23,280 --> 00:06:28,240
like larger applications

00:06:25,440 --> 00:06:29,840
like you can run ruby format on your

00:06:28,240 --> 00:06:32,800
entire project

00:06:29,840 --> 00:06:34,000
in like very little time at its sort of

00:06:32,800 --> 00:06:37,840
peak ruby format

00:06:34,000 --> 00:06:39,759
can do about 30 000 lines of ruby code

00:06:37,840 --> 00:06:41,919
per second and if you think about what

00:06:39,759 --> 00:06:43,840
that means inserting ruby format onto

00:06:41,919 --> 00:06:46,560
even like very very large

00:06:43,840 --> 00:06:48,240
ruby applications as a ci pass is going

00:06:46,560 --> 00:06:50,240
to barely take any time

00:06:48,240 --> 00:06:51,680
whatsoever and like this means that it's

00:06:50,240 --> 00:06:54,080
going to enable you both to use it in

00:06:51,680 --> 00:06:56,080
your editor and enable you to use it in

00:06:54,080 --> 00:06:57,199
ci and i think that's like a really cool

00:06:56,080 --> 00:07:00,639
and powerful

00:06:57,199 --> 00:07:03,440
benefit um ruby format also has no

00:07:00,639 --> 00:07:05,039
style related configuration unlike

00:07:03,440 --> 00:07:07,360
robocop there's no rubicon

00:07:05,039 --> 00:07:08,560
yaml there's no flags to change how

00:07:07,360 --> 00:07:11,120
formatting works

00:07:08,560 --> 00:07:11,919
like ruby format has one style that is

00:07:11,120 --> 00:07:13,919
the style

00:07:11,919 --> 00:07:15,039
and like there's nothing you can really

00:07:13,919 --> 00:07:17,280
do to change it

00:07:15,039 --> 00:07:18,639
besides like actually changing the code

00:07:17,280 --> 00:07:20,880
of ruby format

00:07:18,639 --> 00:07:21,840
itself um and this is really powerful

00:07:20,880 --> 00:07:25,039
i'll talk about

00:07:21,840 --> 00:07:27,919
why i made this decision in a little bit

00:07:25,039 --> 00:07:29,120
but like it ends up making the program

00:07:27,919 --> 00:07:32,400
incredibly simple

00:07:29,120 --> 00:07:33,280
as a side effect um ruby format is also

00:07:32,400 --> 00:07:35,440
designed to work

00:07:33,280 --> 00:07:37,280
like a unix tool uh and what that means

00:07:35,440 --> 00:07:39,680
is it can like consume on standard in

00:07:37,280 --> 00:07:40,720
and output to stand it out it has flags

00:07:39,680 --> 00:07:44,160
for changing

00:07:40,720 --> 00:07:46,560
modes of operation but the idea here

00:07:44,160 --> 00:07:47,520
is that like by designing ruby format as

00:07:46,560 --> 00:07:49,680
a unix tool

00:07:47,520 --> 00:07:51,840
it can interrupt with a whole bunch of

00:07:49,680 --> 00:07:54,479
other tools because fundamentally text

00:07:51,840 --> 00:07:55,280
and pipes are like a universal interface

00:07:54,479 --> 00:07:57,840
right and so like

00:07:55,280 --> 00:07:59,599
if you just say ruby format file name

00:07:57,840 --> 00:08:01,039
it's going to output to standard out and

00:07:59,599 --> 00:08:03,759
let you chain that with other

00:08:01,039 --> 00:08:05,440
stuff uh we have flags for in place it

00:08:03,759 --> 00:08:07,280
works with directories and

00:08:05,440 --> 00:08:08,720
and so on and so on right it's like

00:08:07,280 --> 00:08:09,840
designed very much from the beginning to

00:08:08,720 --> 00:08:12,639
be one of those like simple

00:08:09,840 --> 00:08:13,520
do one thing well unix tools that we've

00:08:12,639 --> 00:08:16,000
heard about

00:08:13,520 --> 00:08:17,199
and like one of the side effects of this

00:08:16,000 --> 00:08:19,759
unix tool

00:08:17,199 --> 00:08:20,319
like design is that ruby format is not a

00:08:19,759 --> 00:08:22,080
gem

00:08:20,319 --> 00:08:24,160
ruby format is not a gem ruby format

00:08:22,080 --> 00:08:24,800
will never be a gem and like this has

00:08:24,160 --> 00:08:28,080
actually been

00:08:24,800 --> 00:08:29,599
a point of some controversy it turns out

00:08:28,080 --> 00:08:31,759
that ruby developers

00:08:29,599 --> 00:08:32,640
really want to be able to access their

00:08:31,759 --> 00:08:36,080
tools

00:08:32,640 --> 00:08:39,120
via ruby gems but if you think about

00:08:36,080 --> 00:08:40,000
what ruby format is kind of this command

00:08:39,120 --> 00:08:43,039
line

00:08:40,000 --> 00:08:43,599
program that like can't actually even be

00:08:43,039 --> 00:08:45,839
loaded

00:08:43,599 --> 00:08:48,000
into a ruby project like it's not a ruby

00:08:45,839 --> 00:08:50,800
library you can just load in

00:08:48,000 --> 00:08:51,839
it doesn't really make any sense to

00:08:50,800 --> 00:08:54,560
distribute

00:08:51,839 --> 00:08:54,959
uh ruby format as a ruby gem um and so

00:08:54,560 --> 00:08:56,480
like

00:08:54,959 --> 00:08:59,120
it's never the case that i want you to

00:08:56,480 --> 00:09:00,160
jam install ruby format but there will

00:08:59,120 --> 00:09:02,240
be alternate

00:09:00,160 --> 00:09:03,360
uh distribution channels available and

00:09:02,240 --> 00:09:06,160
today we use

00:09:03,360 --> 00:09:06,959
uh github releases and so you may be

00:09:06,160 --> 00:09:09,680
thinking to yourself

00:09:06,959 --> 00:09:11,680
like cool penelope that's great i really

00:09:09,680 --> 00:09:13,279
want to use this like a ruby autofocus

00:09:11,680 --> 00:09:14,160
is exactly the tool my team has been

00:09:13,279 --> 00:09:16,080
looking for

00:09:14,160 --> 00:09:17,839
can i have it please and like

00:09:16,080 --> 00:09:21,440
unfortunately like the answer is

00:09:17,839 --> 00:09:22,720
no like it's not really ready for usage

00:09:21,440 --> 00:09:25,839
yet but it's like

00:09:22,720 --> 00:09:27,920
less strong of a no than it was uh

00:09:25,839 --> 00:09:29,920
the last time i gave this talk in the

00:09:27,920 --> 00:09:32,560
spring at brighton ruby

00:09:29,920 --> 00:09:34,320
like ruby format is kind of in a state

00:09:32,560 --> 00:09:36,480
today where if you don't mind some sharp

00:09:34,320 --> 00:09:36,800
edges you could download and play with

00:09:36,480 --> 00:09:39,040
it

00:09:36,800 --> 00:09:40,000
but it probably will still uh do some

00:09:39,040 --> 00:09:43,519
interesting things

00:09:40,000 --> 00:09:46,399
so like like prima facie um it won't

00:09:43,519 --> 00:09:48,000
break your code anymore like there were

00:09:46,399 --> 00:09:49,519
versions of ruby format that i released

00:09:48,000 --> 00:09:50,959
where you could run it on your project

00:09:49,519 --> 00:09:52,080
and it would transform your code and

00:09:50,959 --> 00:09:54,240
produce either

00:09:52,080 --> 00:09:55,279
invalid ruby files or ruby files that

00:09:54,240 --> 00:09:58,320
did something different

00:09:55,279 --> 00:10:00,959
the ruby file that came in and

00:09:58,320 --> 00:10:02,640
obviously that's really not what you

00:10:00,959 --> 00:10:05,519
want from a tool like this

00:10:02,640 --> 00:10:06,959
um so like we fixed that and the way we

00:10:05,519 --> 00:10:10,079
did that is just by like

00:10:06,959 --> 00:10:13,120
testing the hell out of it so today

00:10:10,079 --> 00:10:14,160
ruby format runs ci not only on like

00:10:13,120 --> 00:10:16,640
examples

00:10:14,160 --> 00:10:18,399
of like small units of ruby code but

00:10:16,640 --> 00:10:19,680
also like entire open source

00:10:18,399 --> 00:10:21,440
repositories like all of

00:10:19,680 --> 00:10:24,160
our spec and some of the thoughtbot

00:10:21,440 --> 00:10:26,640
rails applications to really begin to

00:10:24,160 --> 00:10:28,399
uh push the boundaries of like the

00:10:26,640 --> 00:10:30,160
testing and so so what this means is we

00:10:28,399 --> 00:10:32,240
have a high degree of confidence

00:10:30,160 --> 00:10:35,040
that if you run ruby format on a ruby

00:10:32,240 --> 00:10:37,279
program it won't break that ruby program

00:10:35,040 --> 00:10:38,320
it will either fail to format it or

00:10:37,279 --> 00:10:40,480
produce a new

00:10:38,320 --> 00:10:41,600
ruby program which is semantically

00:10:40,480 --> 00:10:44,560
equivalent and like

00:10:41,600 --> 00:10:45,600
this is exactly what we want uh from

00:10:44,560 --> 00:10:47,279
ruby format so like

00:10:45,600 --> 00:10:49,920
we have at least solved the testing

00:10:47,279 --> 00:10:51,839
problem but like the the problem now is

00:10:49,920 --> 00:10:54,079
that some of the output has really sharp

00:10:51,839 --> 00:10:55,920
edges and in particular like today

00:10:54,079 --> 00:10:58,480
ruby format kind of deletes your

00:10:55,920 --> 00:11:00,000
comments uh a bunch of the time and like

00:10:58,480 --> 00:11:02,079
people really like their comments

00:11:00,000 --> 00:11:05,200
comments are very important

00:11:02,079 --> 00:11:07,200
uh to folks and so you know if you're

00:11:05,200 --> 00:11:08,959
okay with testing a program that will

00:11:07,200 --> 00:11:10,560
format your ruby nicely but might delete

00:11:08,959 --> 00:11:12,720
all your comments that's fine

00:11:10,560 --> 00:11:14,480
i would not recommend it for day-to-day

00:11:12,720 --> 00:11:17,040
uh production use

00:11:14,480 --> 00:11:18,720
yet um so you might be asking yourself

00:11:17,040 --> 00:11:21,279
like penelope

00:11:18,720 --> 00:11:22,880
why are you doing this like this seems

00:11:21,279 --> 00:11:25,680
like a really hard problem

00:11:22,880 --> 00:11:28,320
uh why on earth would you decide to

00:11:25,680 --> 00:11:30,320
build a ruby auto formatter and

00:11:28,320 --> 00:11:32,079
to answer that i kind of want to talk

00:11:30,320 --> 00:11:34,640
about this this idea i

00:11:32,079 --> 00:11:36,640
vaguely mentioned on the greater than

00:11:34,640 --> 00:11:38,160
code podcast which is this this idea of

00:11:36,640 --> 00:11:41,519
like a hierarchy

00:11:38,160 --> 00:11:42,160
of nitpicking and so for those of you

00:11:41,519 --> 00:11:44,480
that have been

00:11:42,160 --> 00:11:46,800
around for a while you may remember like

00:11:44,480 --> 00:11:48,480
building ruby before we had robocop

00:11:46,800 --> 00:11:49,920
like you would fire up a pull request

00:11:48,480 --> 00:11:51,839
and people would be like i think we

00:11:49,920 --> 00:11:54,079
should use like the new hash syntax

00:11:51,839 --> 00:11:55,440
versus the old hash syntax or like

00:11:54,079 --> 00:11:57,120
i think like you should do it this way

00:11:55,440 --> 00:11:59,120
instead of that way or like you know

00:11:57,120 --> 00:12:01,440
this seems error-prone what about like

00:11:59,120 --> 00:12:03,600
like those kinds of sort of like very

00:12:01,440 --> 00:12:05,680
small nitpicky conversations

00:12:03,600 --> 00:12:07,040
and pull request review where it didn't

00:12:05,680 --> 00:12:08,480
matter

00:12:07,040 --> 00:12:10,720
but somebody was trying to make an

00:12:08,480 --> 00:12:12,560
argument from consistency

00:12:10,720 --> 00:12:14,079
and this is like a this is like a pretty

00:12:12,560 --> 00:12:16,320
valid thing to do right we want our code

00:12:14,079 --> 00:12:18,240
to look consistent so that somebody new

00:12:16,320 --> 00:12:20,079
uh to a file can begin to understand it

00:12:18,240 --> 00:12:21,040
because like similar structures look the

00:12:20,079 --> 00:12:23,760
same

00:12:21,040 --> 00:12:24,079
right and then and then rubricop came in

00:12:23,760 --> 00:12:26,320
right

00:12:24,079 --> 00:12:27,440
and with robocop you have sort of the

00:12:26,320 --> 00:12:30,240
ability to

00:12:27,440 --> 00:12:30,560
begin to enforce some of those nitpicks

00:12:30,240 --> 00:12:33,440
uh

00:12:30,560 --> 00:12:34,480
by automating it but like rubocop has

00:12:33,440 --> 00:12:36,560
this problem

00:12:34,480 --> 00:12:38,720
that like almost nobody likes the

00:12:36,560 --> 00:12:40,800
rubicop defaults and so like

00:12:38,720 --> 00:12:43,040
every single ruby application i've ever

00:12:40,800 --> 00:12:44,399
worked on has a customized rubric

00:12:43,040 --> 00:12:46,959
configuration

00:12:44,399 --> 00:12:48,639
well it turns out that like customizing

00:12:46,959 --> 00:12:50,240
your rubocop configuration is just

00:12:48,639 --> 00:12:53,519
taking those nitpicks

00:12:50,240 --> 00:12:54,959
and moving them to a different place

00:12:53,519 --> 00:12:55,440
you've moved them from a place where

00:12:54,959 --> 00:12:58,240
like

00:12:55,440 --> 00:12:59,279
one person it will like always put them

00:12:58,240 --> 00:13:01,519
in a pull request

00:12:59,279 --> 00:13:02,800
to a place where like now the team has

00:13:01,519 --> 00:13:03,519
sort of like agreed on them and now

00:13:02,800 --> 00:13:06,959
they're being done

00:13:03,519 --> 00:13:09,279
in an automated fashion except that like

00:13:06,959 --> 00:13:10,800
it turns out this doesn't really solve

00:13:09,279 --> 00:13:13,600
the nitpicking problem

00:13:10,800 --> 00:13:14,160
either because it turns out that like

00:13:13,600 --> 00:13:16,639
what

00:13:14,160 --> 00:13:17,839
uh pull request review actually exposes

00:13:16,639 --> 00:13:20,000
really strongly

00:13:17,839 --> 00:13:21,440
is sort of like an idea of power

00:13:20,000 --> 00:13:23,440
dynamics around

00:13:21,440 --> 00:13:25,600
uh things like being underrepresented

00:13:23,440 --> 00:13:29,079
gender minorities race minorities

00:13:25,600 --> 00:13:31,600
uh disabilities like uh being

00:13:29,079 --> 00:13:32,320
non-neurotypical um and so on and so on

00:13:31,600 --> 00:13:35,920
right

00:13:32,320 --> 00:13:37,519
and like um it is very clear from data

00:13:35,920 --> 00:13:39,760
if you look at open source data if you

00:13:37,519 --> 00:13:42,240
look at some companies internal data

00:13:39,760 --> 00:13:43,839
um like men tend to get their pull

00:13:42,240 --> 00:13:44,560
requests approved more quickly than

00:13:43,839 --> 00:13:47,040
women

00:13:44,560 --> 00:13:47,760
uh get fewer comments get fewer nitpicks

00:13:47,040 --> 00:13:50,480
that like

00:13:47,760 --> 00:13:52,480
all of that stuff right um and like with

00:13:50,480 --> 00:13:56,079
aruba cop.yaml what we actually

00:13:52,480 --> 00:13:58,880
see is um people

00:13:56,079 --> 00:14:01,120
uh trying to make changes to a robocop

00:13:58,880 --> 00:14:04,720
configuration will have an easier time

00:14:01,120 --> 00:14:06,720
if they have more power um and so like

00:14:04,720 --> 00:14:08,079
there's this really interesting like

00:14:06,720 --> 00:14:11,279
aspect of

00:14:08,079 --> 00:14:13,600
code review that inherently exposes the

00:14:11,279 --> 00:14:14,800
the social power dynamics in software

00:14:13,600 --> 00:14:18,160
engineering

00:14:14,800 --> 00:14:18,880
and so like building ruby format there

00:14:18,160 --> 00:14:21,839
is no

00:14:18,880 --> 00:14:23,440
configuration there's no place for you

00:14:21,839 --> 00:14:26,480
and your company to have that

00:14:23,440 --> 00:14:29,199
argument right you have to come to like

00:14:26,480 --> 00:14:31,199
the ruby format repo and argue in the

00:14:29,199 --> 00:14:32,720
open why it's better for like the entire

00:14:31,199 --> 00:14:33,120
language to look this way it sort of

00:14:32,720 --> 00:14:34,880
like

00:14:33,120 --> 00:14:37,199
entirely eliminates the problem of

00:14:34,880 --> 00:14:39,920
having this discussion and by doing so

00:14:37,199 --> 00:14:41,279
removes an opportunity for subtle power

00:14:39,920 --> 00:14:44,240
dynamics to play

00:14:41,279 --> 00:14:45,680
uh themselves out and like this was not

00:14:44,240 --> 00:14:48,560
actually like the original

00:14:45,680 --> 00:14:49,360
intention of the construction of ruby

00:14:48,560 --> 00:14:52,639
format

00:14:49,360 --> 00:14:54,160
um but it came to me when i had a

00:14:52,639 --> 00:14:55,920
conversation with someone who was a

00:14:54,160 --> 00:14:56,639
relatively junior engineer who was a

00:14:55,920 --> 00:14:58,959
woman

00:14:56,639 --> 00:15:00,000
and what she said to me really resonated

00:14:58,959 --> 00:15:02,639
with me she said

00:15:00,000 --> 00:15:03,680
i'm really excited for ruby format

00:15:02,639 --> 00:15:05,440
because

00:15:03,680 --> 00:15:06,800
i work with this this guy who's an

00:15:05,440 --> 00:15:08,720
 senior

00:15:06,800 --> 00:15:10,320
and he like will never listen to me when

00:15:08,720 --> 00:15:12,800
i make suggestions that

00:15:10,320 --> 00:15:13,760
for changes to our robocop configuration

00:15:12,800 --> 00:15:15,600
that could

00:15:13,760 --> 00:15:16,800
improve it and i'm excited for ruby

00:15:15,600 --> 00:15:19,519
format because it means like

00:15:16,800 --> 00:15:21,680
i don't have to make uh those arguments

00:15:19,519 --> 00:15:22,399
when i disagree with some configuration

00:15:21,680 --> 00:15:24,560
because

00:15:22,399 --> 00:15:25,680
instead like that person has to go argue

00:15:24,560 --> 00:15:27,839
with you penelope

00:15:25,680 --> 00:15:29,600
right and like now of course you could

00:15:27,839 --> 00:15:31,120
just argue and it's totally reasonable

00:15:29,600 --> 00:15:32,639
to argue that we are now moving this

00:15:31,120 --> 00:15:36,560
power dynamics problem

00:15:32,639 --> 00:15:39,199
onto penelope um and the sort of like

00:15:36,560 --> 00:15:41,120
broad answer to that is one of like ruby

00:15:39,199 --> 00:15:41,680
format is kind of community sourced and

00:15:41,120 --> 00:15:44,320
i am just

00:15:41,680 --> 00:15:46,160
leading it right like ultimately the

00:15:44,320 --> 00:15:49,360
decisions are mine at the end of the day

00:15:46,160 --> 00:15:52,399
but like i am well placed i think to uh

00:15:49,360 --> 00:15:54,880
adopt these changes uh

00:15:52,399 --> 00:15:55,440
in a way that like many individual teams

00:15:54,880 --> 00:15:57,279
are

00:15:55,440 --> 00:15:59,279
not uh and so that's sort of like the

00:15:57,279 --> 00:16:01,839
hierarchy of nitpicking

00:15:59,279 --> 00:16:03,759
argument in a nutshell um i'd also like

00:16:01,839 --> 00:16:07,199
to talk just a little bit about like

00:16:03,759 --> 00:16:09,680
the existing solution space right

00:16:07,199 --> 00:16:10,639
nobody has ever actually tried to build

00:16:09,680 --> 00:16:14,000
a ruby

00:16:10,639 --> 00:16:14,560
auto formatter um that are like the

00:16:14,000 --> 00:16:17,440
closest

00:16:14,560 --> 00:16:18,079
existing solution right isn't actually

00:16:17,440 --> 00:16:20,560
great at

00:16:18,079 --> 00:16:21,120
the formatting task like it's robocop

00:16:20,560 --> 00:16:22,639
right like

00:16:21,120 --> 00:16:24,480
we've talked about it a bunch already

00:16:22,639 --> 00:16:26,880
and rumor covers great

00:16:24,480 --> 00:16:28,079
many things robocop is a really useful

00:16:26,880 --> 00:16:31,279
ruby linting

00:16:28,079 --> 00:16:33,920
tool but like formatting just

00:16:31,279 --> 00:16:34,399
isn't a core competency of robocop and

00:16:33,920 --> 00:16:36,959
like

00:16:34,399 --> 00:16:38,399
that's fine tools don't have to be great

00:16:36,959 --> 00:16:40,639
at everything

00:16:38,399 --> 00:16:41,680
but like robocop introduces this fixed

00:16:40,639 --> 00:16:43,759
flag as like

00:16:41,680 --> 00:16:45,839
a separate part of its architecture to

00:16:43,759 --> 00:16:48,160
the like detecting problems

00:16:45,839 --> 00:16:49,839
piece and because like robocop was never

00:16:48,160 --> 00:16:50,560
built from the ground up to accomplish

00:16:49,839 --> 00:16:52,880
this task

00:16:50,560 --> 00:16:53,759
it's just like naturally not as good at

00:16:52,880 --> 00:16:55,440
it as a tool

00:16:53,759 --> 00:16:56,800
home grown and specially designed to

00:16:55,440 --> 00:16:59,440
solve this problem

00:16:56,800 --> 00:16:59,839
in fact like when justin cells and i

00:16:59,440 --> 00:17:02,240
were

00:16:59,839 --> 00:17:04,640
working on standard which is like

00:17:02,240 --> 00:17:06,799
justin's layer on top of rubocop that

00:17:04,640 --> 00:17:09,600
also attempts to solve this config

00:17:06,799 --> 00:17:10,559
this uh configuration problem we

00:17:09,600 --> 00:17:12,400
actually found

00:17:10,559 --> 00:17:14,240
that sort of like the biggest source of

00:17:12,400 --> 00:17:17,120
rubicop bugs

00:17:14,240 --> 00:17:18,720
were hyphen hyphen fix and that like in

00:17:17,120 --> 00:17:20,480
particular robocop

00:17:18,720 --> 00:17:21,839
can get into these cycles where it's

00:17:20,480 --> 00:17:23,360
trying to fix something

00:17:21,839 --> 00:17:24,959
and then it detects a new problem and it

00:17:23,360 --> 00:17:26,240
tries to fix that and it puts the old

00:17:24,959 --> 00:17:27,600
problem back in place

00:17:26,240 --> 00:17:29,600
and it does this forever until it

00:17:27,600 --> 00:17:30,960
crashes this is actually a behavior i've

00:17:29,600 --> 00:17:32,640
seen in rubricop

00:17:30,960 --> 00:17:34,480
uh recently in my day-to-day work at

00:17:32,640 --> 00:17:36,799
straight um and so like

00:17:34,480 --> 00:17:38,480
right robocop was just never designed to

00:17:36,799 --> 00:17:39,679
solve this problem we need a whole new

00:17:38,480 --> 00:17:42,000
class of tool

00:17:39,679 --> 00:17:42,880
to do it and like as i've mentioned

00:17:42,000 --> 00:17:44,640
right

00:17:42,880 --> 00:17:47,200
rogue club enables the worst kind of

00:17:44,640 --> 00:17:49,760
bike shed like rumor cop has literally

00:17:47,200 --> 00:17:51,039
hundreds of configuration flags and

00:17:49,760 --> 00:17:51,440
unless you've gone through all of them

00:17:51,039 --> 00:17:53,200
and made

00:17:51,440 --> 00:17:55,120
a conscious decision you're opting into

00:17:53,200 --> 00:17:56,720
the defaults and like the defaults may

00:17:55,120 --> 00:17:58,160
actually not be appropriate for your

00:17:56,720 --> 00:17:59,679
team and your

00:17:58,160 --> 00:18:01,360
context right and deciding which ones

00:17:59,679 --> 00:18:01,919
you want can be a long and arduous

00:18:01,360 --> 00:18:04,160
process

00:18:01,919 --> 00:18:06,000
and so like my sort of like core goal

00:18:04,160 --> 00:18:08,320
with the ruby format project

00:18:06,000 --> 00:18:10,080
is to eliminate all of this work we're

00:18:08,320 --> 00:18:12,400
doing uh configuring

00:18:10,080 --> 00:18:14,240
configuring robocop for formatting and

00:18:12,400 --> 00:18:15,200
instead moving all of that into ruby

00:18:14,240 --> 00:18:17,600
format

00:18:15,200 --> 00:18:19,360
um as you might have guessed i believe

00:18:17,600 --> 00:18:21,760
that tiny focused tools are

00:18:19,360 --> 00:18:23,120
good ruby format only does one thing it

00:18:21,760 --> 00:18:25,679
formats ruby files

00:18:23,120 --> 00:18:27,280
ruby format can't link to your ruby

00:18:25,679 --> 00:18:28,160
files it can't tell you if some

00:18:27,280 --> 00:18:30,320
structure

00:18:28,160 --> 00:18:32,080
is likely problematic or incorrect ruby

00:18:30,320 --> 00:18:33,919
format doesn't know how to do that

00:18:32,080 --> 00:18:36,240
what it does know how to do is format

00:18:33,919 --> 00:18:39,600
files really really quickly

00:18:36,240 --> 00:18:40,160
and as i've mentioned ruby format has no

00:18:39,600 --> 00:18:42,160
style

00:18:40,160 --> 00:18:44,080
related configuration and what that

00:18:42,160 --> 00:18:47,679
means is we have to get style

00:18:44,080 --> 00:18:48,960
right basically like the first time

00:18:47,679 --> 00:18:50,960
because i don't want you to have to do

00:18:48,960 --> 00:18:53,039
like one huge formatting commit and then

00:18:50,960 --> 00:18:56,720
like two or three years down the line

00:18:53,039 --> 00:18:58,720
do another huge formatting commit and so

00:18:56,720 --> 00:19:00,880
the way i'm sort of thinking about this

00:18:58,720 --> 00:19:03,679
is like i really kind of want

00:19:00,880 --> 00:19:04,480
ruby format to only ever have one major

00:19:03,679 --> 00:19:06,320
version

00:19:04,480 --> 00:19:08,080
and that would be 1.0 and we would

00:19:06,320 --> 00:19:10,080
define a major version

00:19:08,080 --> 00:19:12,000
as something where you run the formatter

00:19:10,080 --> 00:19:14,240
and it formats everything and then like

00:19:12,000 --> 00:19:16,799
that's it it will never reformat the

00:19:14,240 --> 00:19:19,600
same piece of code until you change it

00:19:16,799 --> 00:19:20,720
because we want like uh style to remain

00:19:19,600 --> 00:19:23,200
consistent throughout

00:19:20,720 --> 00:19:24,080
ruby format and so to do that like we're

00:19:23,200 --> 00:19:26,559
being very

00:19:24,080 --> 00:19:27,760
very careful about the formatting

00:19:26,559 --> 00:19:30,240
decisions we make

00:19:27,760 --> 00:19:32,240
and i am very much taking my time and

00:19:30,240 --> 00:19:34,720
thinking through things and also like

00:19:32,240 --> 00:19:36,640
i have like made decisions being like

00:19:34,720 --> 00:19:38,400
this is what we will do

00:19:36,640 --> 00:19:39,840
and then reverse those decisions because

00:19:38,400 --> 00:19:40,400
i realized they were actually the wrong

00:19:39,840 --> 00:19:43,120
decision

00:19:40,400 --> 00:19:44,080
after i've learned more about ruby's

00:19:43,120 --> 00:19:46,000
syntax

00:19:44,080 --> 00:19:47,679
and like the perfect example of this is

00:19:46,000 --> 00:19:49,840
trailing commas

00:19:47,679 --> 00:19:51,120
so like intuitively i think a lot of us

00:19:49,840 --> 00:19:51,760
like trailing commas because they

00:19:51,120 --> 00:19:55,280
minimize

00:19:51,760 --> 00:19:57,600
git churn uh on uh structures where

00:19:55,280 --> 00:19:59,919
there are new lines separated by commas

00:19:57,600 --> 00:20:01,760
right but as i was building ruby format

00:19:59,919 --> 00:20:02,880
i found myself adding more and more

00:20:01,760 --> 00:20:04,960
complexity

00:20:02,880 --> 00:20:06,000
uh in order to be able to correctly deal

00:20:04,960 --> 00:20:08,240
with trailing commas

00:20:06,000 --> 00:20:09,760
because it turns out trailing commas are

00:20:08,240 --> 00:20:13,919
not valid

00:20:09,760 --> 00:20:14,960
in a number of places in ruby's syntax

00:20:13,919 --> 00:20:18,559
they're not valid

00:20:14,960 --> 00:20:19,919
in params lists with optional arguments

00:20:18,559 --> 00:20:21,840
and they're not valid in the equivalent

00:20:19,919 --> 00:20:22,960
positions in our lists and a few other

00:20:21,840 --> 00:20:24,320
special cases right

00:20:22,960 --> 00:20:26,880
and so i was looking at this and i was

00:20:24,320 --> 00:20:28,080
like well i'm dealing with all of this

00:20:26,880 --> 00:20:30,640
complexity

00:20:28,080 --> 00:20:32,080
to make it work for the few cases i want

00:20:30,640 --> 00:20:33,600
what happens if i remove

00:20:32,080 --> 00:20:34,960
like trailing commas everywhere just

00:20:33,600 --> 00:20:36,080
enforced there will be no trailing

00:20:34,960 --> 00:20:38,080
commas

00:20:36,080 --> 00:20:39,280
and the code of ruby format got a lot

00:20:38,080 --> 00:20:42,159
simpler by

00:20:39,280 --> 00:20:43,600
doing this and what this said to me is

00:20:42,159 --> 00:20:45,440
that um

00:20:43,600 --> 00:20:47,200
probably having trailing commas is bad

00:20:45,440 --> 00:20:49,520
and so i changed my opinion

00:20:47,200 --> 00:20:51,120
right and this is all to say if you

00:20:49,520 --> 00:20:51,840
disagree with something ruby format is

00:20:51,120 --> 00:20:54,640
doing

00:20:51,840 --> 00:20:56,400
please come to github and file an issue

00:20:54,640 --> 00:20:57,360
and we will talk about it i would rather

00:20:56,400 --> 00:20:59,840
get this right

00:20:57,360 --> 00:21:00,640
than hold on to what i think my opinions

00:20:59,840 --> 00:21:02,880
are

00:21:00,640 --> 00:21:05,039
the goal is to have a minimal consistent

00:21:02,880 --> 00:21:07,280
subset of the ruby language

00:21:05,039 --> 00:21:08,320
and to do that basically what we're

00:21:07,280 --> 00:21:10,000
doing is we're taking

00:21:08,320 --> 00:21:11,919
all of the possible ruby and we're

00:21:10,000 --> 00:21:12,720
squishing it down to a subset of the

00:21:11,919 --> 00:21:15,200
grammar

00:21:12,720 --> 00:21:16,000
like the output of ruby format is much

00:21:15,200 --> 00:21:18,400
less

00:21:16,000 --> 00:21:20,400
than the sum total of all ruby that is

00:21:18,400 --> 00:21:22,240
possible ruby format actually outputs

00:21:20,400 --> 00:21:24,080
a minimal subset of ruby and i think

00:21:22,240 --> 00:21:26,400
that's a really powerful idea to build

00:21:24,080 --> 00:21:28,480
this consistency

00:21:26,400 --> 00:21:29,600
so that's kind of like the what and the

00:21:28,480 --> 00:21:31,039
philosophy

00:21:29,600 --> 00:21:32,799
now i'd like to get actually sort of

00:21:31,039 --> 00:21:33,520
like down into the nitty-gritty and talk

00:21:32,799 --> 00:21:35,679
about the

00:21:33,520 --> 00:21:36,799
implementation details so like

00:21:35,679 --> 00:21:39,039
originally

00:21:36,799 --> 00:21:41,280
uh ruby format was written entirely

00:21:39,039 --> 00:21:42,480
end-to-end in ruby it would consume a

00:21:41,280 --> 00:21:44,320
ruby file

00:21:42,480 --> 00:21:46,400
build a data structure called a parse

00:21:44,320 --> 00:21:48,320
tree using a ruby library

00:21:46,400 --> 00:21:50,000
called ripper which basically consumes

00:21:48,320 --> 00:21:50,799
ruby source and produces this data

00:21:50,000 --> 00:21:52,799
structure

00:21:50,799 --> 00:21:54,240
uh some code to walk the data structure

00:21:52,799 --> 00:21:54,720
and produce what's called a rendering

00:21:54,240 --> 00:21:56,240
queue

00:21:54,720 --> 00:21:58,080
which is basically just like a list of

00:21:56,240 --> 00:21:59,679
tokens to be output to a file

00:21:58,080 --> 00:22:01,280
and then it would walk the rendering hue

00:21:59,679 --> 00:22:03,600
to output those into

00:22:01,280 --> 00:22:05,360
the file um the ruby standard library

00:22:03,600 --> 00:22:06,080
and call includes a ruby parser called

00:22:05,360 --> 00:22:08,080
ripper

00:22:06,080 --> 00:22:09,679
um and what this means basically is that

00:22:08,080 --> 00:22:12,559
like we can run ripper

00:22:09,679 --> 00:22:14,159
over ruby files and get syntax trees um

00:22:12,559 --> 00:22:16,400
and the syntax trees look like this

00:22:14,159 --> 00:22:17,200
they are basically arrays where the

00:22:16,400 --> 00:22:19,440
first item

00:22:17,200 --> 00:22:21,200
in the array is a tag representing the

00:22:19,440 --> 00:22:23,679
thing that has just been parsed

00:22:21,200 --> 00:22:25,520
and then the array contains more nodes

00:22:23,679 --> 00:22:26,000
indicating things like the name or the

00:22:25,520 --> 00:22:28,320
value

00:22:26,000 --> 00:22:29,360
or the position and to perhaps make this

00:22:28,320 --> 00:22:32,960
more concrete

00:22:29,360 --> 00:22:35,039
if you open up irb and call ripper.sexp

00:22:32,960 --> 00:22:36,559
over a string of ruby code it will

00:22:35,039 --> 00:22:39,039
actually produce

00:22:36,559 --> 00:22:40,640
uh an array which is the parse tree that

00:22:39,039 --> 00:22:42,559
represents that program

00:22:40,640 --> 00:22:43,919
right and so you can see here like i

00:22:42,559 --> 00:22:46,559
have a tag like

00:22:43,919 --> 00:22:47,600
colon at ident which is a symbol that is

00:22:46,559 --> 00:22:50,320
at ident

00:22:47,600 --> 00:22:50,720
with say and that maps to the identifier

00:22:50,320 --> 00:22:52,159
say

00:22:50,720 --> 00:22:54,159
in the program that is the name of the

00:22:52,159 --> 00:22:55,600
function being called you'll also see we

00:22:54,159 --> 00:22:57,440
have their arg paren

00:22:55,600 --> 00:22:58,880
that's because parentheses are optional

00:22:57,440 --> 00:23:00,320
in ruby and so like

00:22:58,880 --> 00:23:02,559
the parse tree tells us there were

00:23:00,320 --> 00:23:04,159
parens there then odds add block which

00:23:02,559 --> 00:23:04,960
tells us we have an args list and then

00:23:04,159 --> 00:23:07,520
at

00:23:04,960 --> 00:23:09,280
uh in and then the string one which

00:23:07,520 --> 00:23:11,600
tells us there was an argument one

00:23:09,280 --> 00:23:13,280
right and so like you can see here we

00:23:11,600 --> 00:23:14,080
have a data structure that represents

00:23:13,280 --> 00:23:16,240
the program

00:23:14,080 --> 00:23:17,760
that we can then walk to actually do

00:23:16,240 --> 00:23:19,360
formatting and that was basically how

00:23:17,760 --> 00:23:20,880
ruby format worked

00:23:19,360 --> 00:23:22,720
and we actually got this working to the

00:23:20,880 --> 00:23:23,360
point where we could get every single

00:23:22,720 --> 00:23:26,640
test

00:23:23,360 --> 00:23:28,320
in the aspect repo passing uh after

00:23:26,640 --> 00:23:30,320
all of our spec had been formatted with

00:23:28,320 --> 00:23:33,200
ruby format which is like a huge win

00:23:30,320 --> 00:23:34,720
uh and on this 186 line file this was

00:23:33,200 --> 00:23:36,960
like plenty fast enough

00:23:34,720 --> 00:23:39,520
but unlike a 2000 line file this was too

00:23:36,960 --> 00:23:43,120
slow it took 188 milliseconds

00:23:39,520 --> 00:23:46,000
188 milliseconds is too slow

00:23:43,120 --> 00:23:48,000
to be able to do ruby auto formatting

00:23:46,000 --> 00:23:50,960
but this begs the question

00:23:48,000 --> 00:23:52,880
like how fast is fast enough like how

00:23:50,960 --> 00:23:54,480
fast does ruby format have to be

00:23:52,880 --> 00:23:56,640
in order for it to be a reasonably

00:23:54,480 --> 00:23:58,159
designed auto formatter

00:23:56,640 --> 00:24:00,080
and to answer that question we need to

00:23:58,159 --> 00:24:02,559
understand just like a little bit about

00:24:00,080 --> 00:24:04,159
uh the performance of modern computers

00:24:02,559 --> 00:24:06,559
so if you have a non

00:24:04,159 --> 00:24:08,640
high refresh rate display uh it will

00:24:06,559 --> 00:24:11,200
refresh uh 60 times a second

00:24:08,640 --> 00:24:12,799
and 60 times a second is equivalent to

00:24:11,200 --> 00:24:14,880
16 milliseconds

00:24:12,799 --> 00:24:16,559
um the other performance number that's

00:24:14,880 --> 00:24:17,520
kind of important here is 100

00:24:16,559 --> 00:24:20,240
milliseconds

00:24:17,520 --> 00:24:21,039
100 milliseconds is about the fastest

00:24:20,240 --> 00:24:24,480
any human

00:24:21,039 --> 00:24:25,919
can react to like a change on the screen

00:24:24,480 --> 00:24:28,080
and so like with these two numbers in

00:24:25,919 --> 00:24:29,440
mind we can begin to look at various

00:24:28,080 --> 00:24:31,840
ways of building

00:24:29,440 --> 00:24:32,880
ruby format uh and their relative

00:24:31,840 --> 00:24:35,600
performance

00:24:32,880 --> 00:24:35,919
so like to establish a baseline if you

00:24:35,600 --> 00:24:38,559
run

00:24:35,919 --> 00:24:38,960
bundle exec rubricop over a four line

00:24:38,559 --> 00:24:41,200
file

00:24:38,960 --> 00:24:42,240
basically like an empty file how long

00:24:41,200 --> 00:24:44,799
does it take

00:24:42,240 --> 00:24:45,679
and the answer turns out to be about 800

00:24:44,799 --> 00:24:49,279
milliseconds

00:24:45,679 --> 00:24:52,799
and of that about 425 milliseconds

00:24:49,279 --> 00:24:56,480
is bundler booting and so like we

00:24:52,799 --> 00:24:59,679
can't use bundler we can't be a ruby gem

00:24:56,480 --> 00:25:02,080
because if we were we would in uh impose

00:24:59,679 --> 00:25:04,240
a static 400 millisecond cost

00:25:02,080 --> 00:25:06,799
every time we wanted to run and that is

00:25:04,240 --> 00:25:09,520
just too slow to be acceptable

00:25:06,799 --> 00:25:10,960
uh to run on save and we also can't

00:25:09,520 --> 00:25:12,559
inherit from rubricorp

00:25:10,960 --> 00:25:14,640
like the very first design i had a ruby

00:25:12,559 --> 00:25:15,440
format was well what if we just loaded

00:25:14,640 --> 00:25:17,440
robocop

00:25:15,440 --> 00:25:19,120
and like did stuff with that and but

00:25:17,440 --> 00:25:21,760
like robocop is also too

00:25:19,120 --> 00:25:23,600
slow so let's go to the very other end

00:25:21,760 --> 00:25:25,919
of the spectrum what if we just run

00:25:23,600 --> 00:25:26,799
ruby on an empty program it's like ruby

00:25:25,919 --> 00:25:29,520
itself

00:25:26,799 --> 00:25:30,640
fast enough and it turns out evaluating

00:25:29,520 --> 00:25:34,080
an empty program

00:25:30,640 --> 00:25:35,679
with the ruby interpreter alone takes 75

00:25:34,080 --> 00:25:37,120
milliseconds

00:25:35,679 --> 00:25:39,600
but there's one thing that's happening

00:25:37,120 --> 00:25:42,240
here that like we can kind of eliminate

00:25:39,600 --> 00:25:44,320
so if you just run ruby on the command

00:25:42,240 --> 00:25:45,360
line it's actually going to load ruby

00:25:44,320 --> 00:25:48,320
germs

00:25:45,360 --> 00:25:49,600
rubygems is a library it's not just like

00:25:48,320 --> 00:25:51,520
the idea of gems

00:25:49,600 --> 00:25:53,279
and installing them it is also a library

00:25:51,520 --> 00:25:57,120
that ruby will load

00:25:53,279 --> 00:25:58,159
um in order to uh like be able to load

00:25:57,120 --> 00:26:01,120
ruby gems

00:25:58,159 --> 00:26:02,000
and it turns out you can just turn that

00:26:01,120 --> 00:26:04,960
off

00:26:02,000 --> 00:26:06,559
and so um like i have this ruby hyphen

00:26:04,960 --> 00:26:09,200
hyphen disable equal gems

00:26:06,559 --> 00:26:10,080
uh hyphen e empty string and that only

00:26:09,200 --> 00:26:13,120
takes 25

00:26:10,080 --> 00:26:14,240
milliseconds and so this is fast enough

00:26:13,120 --> 00:26:16,640
running ruby

00:26:14,240 --> 00:26:17,679
uh without ruby jams uh in a 25

00:26:16,640 --> 00:26:20,480
millisecond boot

00:26:17,679 --> 00:26:21,679
gives us 75 milliseconds remaining to

00:26:20,480 --> 00:26:24,720
actually run a ruby

00:26:21,679 --> 00:26:26,159
auto formatter and so after we like did

00:26:24,720 --> 00:26:29,120
all of this engineering work

00:26:26,159 --> 00:26:31,039
uh we ran ruby format on an empty file

00:26:29,120 --> 00:26:31,840
um and it was basically taking the same

00:26:31,039 --> 00:26:34,640
amount of time

00:26:31,840 --> 00:26:36,400
as booting ruby that is like uh ruby

00:26:34,640 --> 00:26:38,400
format had no additional overhead over

00:26:36,400 --> 00:26:40,640
booting ruby which was indicative

00:26:38,400 --> 00:26:41,600
that it would be fast enough uh to be

00:26:40,640 --> 00:26:44,799
able to run in this

00:26:41,600 --> 00:26:46,960
uh format on save workflow

00:26:44,799 --> 00:26:49,200
so we still have this 188 uh

00:26:46,960 --> 00:26:50,960
milliseconds runtime what do we do

00:26:49,200 --> 00:26:52,559
well i've kind of like already sort of

00:26:50,960 --> 00:26:53,840
talked around this so let's talk about

00:26:52,559 --> 00:26:56,080
it directly like

00:26:53,840 --> 00:26:57,279
if you want to write a fast and correct

00:26:56,080 --> 00:26:59,679
program today

00:26:57,279 --> 00:27:00,400
uh rust really is the best language uh

00:26:59,679 --> 00:27:02,880
that you have

00:27:00,400 --> 00:27:04,960
available to you to do that and so i was

00:27:02,880 --> 00:27:06,080
like what if i just wrote a ruby author

00:27:04,960 --> 00:27:08,400
formatter in

00:27:06,080 --> 00:27:09,200
rust surely that will be fun and easy

00:27:08,400 --> 00:27:13,200
right

00:27:09,200 --> 00:27:16,240
um the answer is no uh

00:27:13,200 --> 00:27:18,000
pass.y which is ruby's um parser

00:27:16,240 --> 00:27:20,000
the thing that the ripper library i

00:27:18,000 --> 00:27:22,480
mentioned earlier is built on top

00:27:20,000 --> 00:27:25,120
of is actually not separable from the

00:27:22,480 --> 00:27:26,960
ruby interpreter you need to have

00:27:25,120 --> 00:27:28,640
most of a booted ruby interpreter

00:27:26,960 --> 00:27:31,120
available to you

00:27:28,640 --> 00:27:32,640
in order to be able to run the ruby

00:27:31,120 --> 00:27:35,120
parser in order to be able to

00:27:32,640 --> 00:27:36,640
pass it to rust so like what we actually

00:27:35,120 --> 00:27:39,360
end up with is like ruby

00:27:36,640 --> 00:27:40,320
and rust executing together in this like

00:27:39,360 --> 00:27:42,399
beautiful

00:27:40,320 --> 00:27:44,559
marriage of like two of my favorite

00:27:42,399 --> 00:27:46,640
programming languages in the world

00:27:44,559 --> 00:27:48,080
um and so like the intermediate state

00:27:46,640 --> 00:27:50,080
the state that ruby format was

00:27:48,080 --> 00:27:51,520
in for like a little bit of time is we

00:27:50,080 --> 00:27:53,760
ran a ruby process

00:27:51,520 --> 00:27:55,520
that ruby process read the source file

00:27:53,760 --> 00:27:56,720
ran ripper over it and then turned it

00:27:55,520 --> 00:28:00,000
into json

00:27:56,720 --> 00:28:03,279
this by the way is the json logo

00:28:00,000 --> 00:28:05,840
it's this weird circly grey thing um and

00:28:03,279 --> 00:28:08,080
so what we had is big json blob

00:28:05,840 --> 00:28:09,520
and then we sent the json blob into a

00:28:08,080 --> 00:28:11,360
rust program because i was like

00:28:09,520 --> 00:28:13,039
how do you send things between languages

00:28:11,360 --> 00:28:15,679
use json right it

00:28:13,039 --> 00:28:16,080
totally works um so it was a really bad

00:28:15,679 --> 00:28:18,240
idea

00:28:16,080 --> 00:28:20,080
but it was enough to get going and then

00:28:18,240 --> 00:28:21,760
we just turned the json back into the

00:28:20,080 --> 00:28:22,640
exact same data structure as we had on

00:28:21,760 --> 00:28:23,840
the ruby side

00:28:22,640 --> 00:28:26,320
and then we do like all of the

00:28:23,840 --> 00:28:26,880
computation and rust and it's like way

00:28:26,320 --> 00:28:29,200
faster

00:28:26,880 --> 00:28:30,000
this this structure with json was

00:28:29,200 --> 00:28:33,279
actually fast

00:28:30,000 --> 00:28:35,360
enough um for us to be able to

00:28:33,279 --> 00:28:36,880
uh like run in less than 100

00:28:35,360 --> 00:28:39,520
milliseconds on every file

00:28:36,880 --> 00:28:40,640
but like json's not ideal like it would

00:28:39,520 --> 00:28:43,520
be great if we didn't

00:28:40,640 --> 00:28:44,720
have to do that um and so we don't uh

00:28:43,520 --> 00:28:47,279
today what we actually do

00:28:44,720 --> 00:28:48,080
is instead of passing json between ruby

00:28:47,279 --> 00:28:52,320
and rust

00:28:48,080 --> 00:28:55,120
uh we pass a pointer to the ruby objects

00:28:52,320 --> 00:28:55,840
um it turns out that the ruby

00:28:55,120 --> 00:28:59,120
interpreter

00:28:55,840 --> 00:29:00,080
is written in c and so it's very easy to

00:28:59,120 --> 00:29:02,320
integrate uh

00:29:00,080 --> 00:29:03,600
ruby programs into c programs and it

00:29:02,320 --> 00:29:05,200
also turns out it's very easy to

00:29:03,600 --> 00:29:07,520
integrate c programs

00:29:05,200 --> 00:29:09,679
into rust programs and so basically like

00:29:07,520 --> 00:29:12,240
we are giving rust

00:29:09,679 --> 00:29:12,720
a value which represents a ruby object

00:29:12,240 --> 00:29:15,600
and then

00:29:12,720 --> 00:29:17,440
rust itself knows how to navigate the

00:29:15,600 --> 00:29:18,640
ruby objects by calling into the ruby

00:29:17,440 --> 00:29:21,679
interpreter which

00:29:18,640 --> 00:29:24,960
is wild um but it totally works

00:29:21,679 --> 00:29:25,279
i also didn't do this alone sean griffin

00:29:24,960 --> 00:29:27,600
who

00:29:25,279 --> 00:29:29,600
is speaking later today actually did

00:29:27,600 --> 00:29:32,320
most of their heavy lifting

00:29:29,600 --> 00:29:33,440
here and it was really great of them to

00:29:32,320 --> 00:29:34,799
contribute that i wouldn't have been

00:29:33,440 --> 00:29:37,120
able to do it on my own

00:29:34,799 --> 00:29:39,200
also um for those of you who don't know

00:29:37,120 --> 00:29:42,159
this is sean's daughter

00:29:39,200 --> 00:29:43,120
they named their daughter ruby uh and so

00:29:42,159 --> 00:29:45,919
i think it is safe

00:29:43,120 --> 00:29:46,480
for us to say that sean loves ruby more

00:29:45,919 --> 00:29:49,120
than

00:29:46,480 --> 00:29:49,120
all of us

00:29:50,080 --> 00:29:53,360
so like there is not just a performance

00:29:52,640 --> 00:29:55,600
reason

00:29:53,360 --> 00:29:57,919
uh to use rust writing rust code

00:29:55,600 --> 00:30:01,600
actually also has a ton of benefits

00:29:57,919 --> 00:30:04,159
uh beyond that a big one is types

00:30:01,600 --> 00:30:04,640
so instead of expressing everything as

00:30:04,159 --> 00:30:06,640
like

00:30:04,640 --> 00:30:08,559
just dynamic types we can express

00:30:06,640 --> 00:30:09,600
everything with static types and what

00:30:08,559 --> 00:30:11,760
this means

00:30:09,600 --> 00:30:13,440
is we're able to determine a lot more

00:30:11,760 --> 00:30:14,399
about how to work with the parse tree at

00:30:13,440 --> 00:30:16,080
compile time

00:30:14,399 --> 00:30:17,440
prevents us from making mistakes it's

00:30:16,080 --> 00:30:19,679
very good uh

00:30:17,440 --> 00:30:22,080
rust is very fast this is actually how

00:30:19,679 --> 00:30:23,360
we achieve the 60 millisecond uh

00:30:22,080 --> 00:30:24,799
performance number

00:30:23,360 --> 00:30:27,760
uh it wouldn't have been possible if we

00:30:24,799 --> 00:30:30,640
didn't uh use the rust language

00:30:27,760 --> 00:30:31,039
uh so why aren't you done penelope like

00:30:30,640 --> 00:30:32,640
you

00:30:31,039 --> 00:30:34,080
built this thing you converted it to

00:30:32,640 --> 00:30:35,600
rust like surely

00:30:34,080 --> 00:30:38,720
you must be close to being finished

00:30:35,600 --> 00:30:41,440
right um it turns out the syntax of the

00:30:38,720 --> 00:30:44,320
ruby language is extremely weird

00:30:41,440 --> 00:30:45,919
um this is how we write multi-line

00:30:44,320 --> 00:30:48,399
strings we use hair dogs like

00:30:45,919 --> 00:30:49,520
why on earth is this a feature of the

00:30:48,399 --> 00:30:53,120
ruby language

00:30:49,520 --> 00:30:56,159
i don't know but it turns out you can

00:30:53,120 --> 00:30:58,000
embed hair dots inside other

00:30:56,159 --> 00:30:59,279
hair docs like this is a completely

00:30:58,000 --> 00:31:01,279
legal ruby program

00:30:59,279 --> 00:31:02,720
that starts one here doc and then starts

00:31:01,279 --> 00:31:05,840
another hairdoc and like

00:31:02,720 --> 00:31:09,039
this assembles to a string um

00:31:05,840 --> 00:31:11,519
you can define classes inside rescue

00:31:09,039 --> 00:31:13,679
clauses in begin rescue and like these

00:31:11,519 --> 00:31:16,320
are legal ruby programs that work and

00:31:13,679 --> 00:31:18,159
do something reasonable and that means i

00:31:16,320 --> 00:31:19,760
have to be able to format them and these

00:31:18,159 --> 00:31:23,360
are real stress tests

00:31:19,760 --> 00:31:26,000
uh from uh ruby format's unit test case

00:31:23,360 --> 00:31:26,480
um ripper is weird like if you have an

00:31:26,000 --> 00:31:29,360
array

00:31:26,480 --> 00:31:30,799
like one two three it looks very normal

00:31:29,360 --> 00:31:33,039
and it passes like this

00:31:30,799 --> 00:31:34,720
but if you say like a equals one comma

00:31:33,039 --> 00:31:36,799
star b which is like

00:31:34,720 --> 00:31:38,559
how you splat one array into another

00:31:36,799 --> 00:31:39,679
like the par the path structure

00:31:38,559 --> 00:31:43,200
completely changes

00:31:39,679 --> 00:31:43,840
um in ruby word arrays pause as arrays

00:31:43,200 --> 00:31:46,159
and like this

00:31:43,840 --> 00:31:48,000
ends up looking like this and like in

00:31:46,159 --> 00:31:49,679
ruby we just use dynamic types like we

00:31:48,000 --> 00:31:52,480
index into stuff we see what's there

00:31:49,679 --> 00:31:52,960
it works just fine um in rust we have to

00:31:52,480 --> 00:31:56,159
write

00:31:52,960 --> 00:31:58,240
all of this code just to be able to tell

00:31:56,159 --> 00:32:00,320
rust like what all the different

00:31:58,240 --> 00:32:02,480
possibilities of an array

00:32:00,320 --> 00:32:03,600
are it's like a lot more work to be able

00:32:02,480 --> 00:32:05,600
to convince rust

00:32:03,600 --> 00:32:07,919
what the data structure i'm giving it

00:32:05,600 --> 00:32:09,039
actually is and so it turns out getting

00:32:07,919 --> 00:32:10,799
this data structure right

00:32:09,039 --> 00:32:12,960
is extremely hard because there is no

00:32:10,799 --> 00:32:16,240
formal specification

00:32:12,960 --> 00:32:18,080
of the ruby language um serialization

00:32:16,240 --> 00:32:18,480
requires a bunch of extra code but i

00:32:18,080 --> 00:32:21,039
don't

00:32:18,480 --> 00:32:23,679
have super bunch of time to go into that

00:32:21,039 --> 00:32:25,440
so let's just quickly summarize

00:32:23,679 --> 00:32:28,000
ruby format is the most incredibly

00:32:25,440 --> 00:32:31,360
technically complex piece of software

00:32:28,000 --> 00:32:34,559
i've ever worked on the code is like

00:32:31,360 --> 00:32:35,679
so vast like understanding the grammar

00:32:34,559 --> 00:32:37,600
of ruby alone

00:32:35,679 --> 00:32:39,279
is one of the most complicated technical

00:32:37,600 --> 00:32:42,159
underpinnings someone could take

00:32:39,279 --> 00:32:44,159
uh it is really hard i think i

00:32:42,159 --> 00:32:46,399
accidentally became a global expert

00:32:44,159 --> 00:32:48,159
on the syntax of ruby by doing this uh

00:32:46,399 --> 00:32:50,320
but it's been a lot of fun

00:32:48,159 --> 00:32:52,480
um i have been really sweating the

00:32:50,320 --> 00:32:55,519
details and trying very hard to get

00:32:52,480 --> 00:32:56,000
this right uh i think ruby deserves to

00:32:55,519 --> 00:32:58,960
have a really

00:32:56,000 --> 00:33:00,080
truly amazing auto formatter and we

00:32:58,960 --> 00:33:02,960
don't have one today

00:33:00,080 --> 00:33:04,880
and i think i can be the one to do it

00:33:02,960 --> 00:33:07,440
i'm so excited to share this

00:33:04,880 --> 00:33:09,519
with you um i wanted to say like a

00:33:07,440 --> 00:33:12,320
genuine thanks to the river cop

00:33:09,519 --> 00:33:12,640
and sorbet teams they have proven there

00:33:12,320 --> 00:33:14,960
is an

00:33:12,640 --> 00:33:16,159
appetite for great developer tooling in

00:33:14,960 --> 00:33:19,120
the ruby language

00:33:16,159 --> 00:33:20,640
and uh i should also say i work for

00:33:19,120 --> 00:33:21,440
stripe stripe is the company that made

00:33:20,640 --> 00:33:22,960
sorbet

00:33:21,440 --> 00:33:24,720
they are not paying me to say nice

00:33:22,960 --> 00:33:26,240
things about sorbet i just think sorbet

00:33:24,720 --> 00:33:27,919
is actually pretty great

00:33:26,240 --> 00:33:30,480
and like without it we wouldn't have

00:33:27,919 --> 00:33:33,200
been able to build all of this great

00:33:30,480 --> 00:33:33,679
tooling um if you want to get the code

00:33:33,200 --> 00:33:36,640
it's

00:33:33,679 --> 00:33:37,519
uh github.com penelope's own slash ruby

00:33:36,640 --> 00:33:40,880
format

00:33:37,519 --> 00:33:42,720
um that's all i got these are my contact

00:33:40,880 --> 00:33:43,600
details i will leave them up for a

00:33:42,720 --> 00:33:46,080
couple seconds

00:33:43,600 --> 00:33:48,559
and i will be happy to take some

00:33:46,080 --> 00:33:48,559
questions

00:33:50,240 --> 00:33:53,279
that was wonderful thank you so much

00:33:52,080 --> 00:33:55,679
penelope

00:33:53,279 --> 00:33:56,480
before we get to the q a let's give you

00:33:55,679 --> 00:33:58,720
a short

00:33:56,480 --> 00:34:00,480
chance to have a drink relax a little

00:33:58,720 --> 00:34:02,159
and i will share with the folks

00:34:00,480 --> 00:34:04,080
what's going on in the developer

00:34:02,159 --> 00:34:07,760
dilemmas

00:34:04,080 --> 00:34:10,639
so let's have a look the final tally is

00:34:07,760 --> 00:34:11,679
44 of you voted for move fast and break

00:34:10,639 --> 00:34:14,560
things

00:34:11,679 --> 00:34:15,679
56 percent of you voted for strive for

00:34:14,560 --> 00:34:17,679
zero errors

00:34:15,679 --> 00:34:19,679
would you look at that look at that so

00:34:17,679 --> 00:34:21,839
folks let's jump into some questions

00:34:19,679 --> 00:34:23,679
type them into the youtube chat please

00:34:21,839 --> 00:34:25,839
we'll be bringing them to penelope as we

00:34:23,679 --> 00:34:25,839
go

00:34:27,679 --> 00:34:33,839
uh penelope thank you very much for your

00:34:30,720 --> 00:34:34,560
talk um we have a few questions so one

00:34:33,839 --> 00:34:37,919
of them

00:34:34,560 --> 00:34:41,040
is um can i use

00:34:37,919 --> 00:34:44,480
ruby format in ruby mine together

00:34:41,040 --> 00:34:49,280
uh with idea film um

00:34:44,480 --> 00:34:52,560
that is a great question um i

00:34:49,280 --> 00:34:54,800
don't know um i suspect so i suspect the

00:34:52,560 --> 00:34:57,040
answer is with with uh ruby mine someone

00:34:54,800 --> 00:35:00,320
would have to write a plugin for it or

00:34:57,040 --> 00:35:01,359
um i believe it has like a formatter

00:35:00,320 --> 00:35:03,599
selector

00:35:01,359 --> 00:35:04,640
um and so someone would have to reach

00:35:03,599 --> 00:35:06,880
out to the folks that

00:35:04,640 --> 00:35:08,160
make ruby mine and be like please add

00:35:06,880 --> 00:35:11,359
for ruby format

00:35:08,160 --> 00:35:14,720
um so you should do that

00:35:11,359 --> 00:35:16,320
um i but yeah i don't the answer is i

00:35:14,720 --> 00:35:16,960
don't know if they have it integrated

00:35:16,320 --> 00:35:20,000
today

00:35:16,960 --> 00:35:22,079
i certainly have not integrated it yet

00:35:20,000 --> 00:35:23,599
today and so i would assume the answer

00:35:22,079 --> 00:35:26,880
is no um

00:35:23,599 --> 00:35:30,000
yeah thanks a lot

00:35:26,880 --> 00:35:31,520
um andy's wondering great work penelope

00:35:30,000 --> 00:35:33,440
i was wondering where the ruby format

00:35:31,520 --> 00:35:36,640
enforces a maximum line length

00:35:33,440 --> 00:35:38,480
and how it handles overflow yeah that's

00:35:36,640 --> 00:35:41,359
a that's a fantastic question

00:35:38,480 --> 00:35:42,720
um i have gone so the answer is i

00:35:41,359 --> 00:35:46,640
haven't decided yet

00:35:42,720 --> 00:35:50,000
um there are sort of currently two modes

00:35:46,640 --> 00:35:50,640
we're exploring one is to enforce a line

00:35:50,000 --> 00:35:53,839
length

00:35:50,640 --> 00:35:55,200
limit and then like break constructs

00:35:53,839 --> 00:35:56,800
from being like single line onto

00:35:55,200 --> 00:35:58,800
multi-line so for example

00:35:56,800 --> 00:36:00,560
ruby phone actually knows today how to

00:35:58,800 --> 00:36:02,400
take a hash or an array

00:36:00,560 --> 00:36:03,839
and uh take it from a single line

00:36:02,400 --> 00:36:06,160
version with multiple keys

00:36:03,839 --> 00:36:06,880
or multiple entries to a multi-line

00:36:06,160 --> 00:36:08,240
version

00:36:06,880 --> 00:36:10,000
um and it will actually like you can

00:36:08,240 --> 00:36:12,640
just do that like that

00:36:10,000 --> 00:36:14,560
um it also knows how to break method

00:36:12,640 --> 00:36:16,800
chains and by default it will

00:36:14,560 --> 00:36:18,160
do that uh by leaving the dot at the end

00:36:16,800 --> 00:36:20,240
of the line and then just

00:36:18,160 --> 00:36:22,400
uh show i think at the end or beginning

00:36:20,240 --> 00:36:26,000
i forget it's also not important

00:36:22,400 --> 00:36:28,480
um and so so we kind of have this

00:36:26,000 --> 00:36:30,160
uh line length limit enforcement today

00:36:28,480 --> 00:36:31,680
that's not like fully fleshed out but

00:36:30,160 --> 00:36:34,000
that that's one idea

00:36:31,680 --> 00:36:36,320
and then the other idea i have that i

00:36:34,000 --> 00:36:40,400
i'm i'm sort of very much encouraged by

00:36:36,320 --> 00:36:43,040
is um respecting the user's choice so

00:36:40,400 --> 00:36:44,800
we would let you go as wide as you want

00:36:43,040 --> 00:36:45,599
but the very second you break a

00:36:44,800 --> 00:36:48,000
construct

00:36:45,599 --> 00:36:49,520
onto multiple lines we would then apply

00:36:48,000 --> 00:36:51,839
the multi-line version

00:36:49,520 --> 00:36:53,599
of whatever construct you're doing and

00:36:51,839 --> 00:36:54,320
so so in that case if you have a method

00:36:53,599 --> 00:36:56,480
chain

00:36:54,320 --> 00:36:57,920
and it's like say 300 characters long

00:36:56,480 --> 00:37:00,160
and you still haven't broken it

00:36:57,920 --> 00:37:01,440
we would let you keep that but the very

00:37:00,160 --> 00:37:03,200
second you move something

00:37:01,440 --> 00:37:05,520
down onto the next line we would

00:37:03,200 --> 00:37:08,960
actually verticalize the whole thing

00:37:05,520 --> 00:37:10,640
for you and so so like this is really

00:37:08,960 --> 00:37:14,000
compelling to me because it lets

00:37:10,640 --> 00:37:14,640
ruby developers choose where the length

00:37:14,000 --> 00:37:17,280
limit

00:37:14,640 --> 00:37:19,200
is and i i'm like not actually convinced

00:37:17,280 --> 00:37:22,240
that we need to have

00:37:19,200 --> 00:37:24,400
a hard length limit like no like

00:37:22,240 --> 00:37:26,079
because this is such a varied opinion

00:37:24,400 --> 00:37:28,240
how wide people's screens are there are

00:37:26,079 --> 00:37:31,040
accessibility concerns like

00:37:28,240 --> 00:37:31,599
i really think excuse me i really think

00:37:31,040 --> 00:37:33,440
that like

00:37:31,599 --> 00:37:34,800
leaving it somewhat to people's choice

00:37:33,440 --> 00:37:38,160
is actually a really interesting

00:37:34,800 --> 00:37:40,400
idea but then having support so that you

00:37:38,160 --> 00:37:42,960
can sort of tell the formatter what you

00:37:40,400 --> 00:37:44,320
want is also is like a is this very

00:37:42,960 --> 00:37:46,640
compelling idea to me

00:37:44,320 --> 00:37:47,760
and so so i also think right perhaps

00:37:46,640 --> 00:37:50,160
more generally

00:37:47,760 --> 00:37:51,599
than this specific thing like the

00:37:50,160 --> 00:37:52,960
formatter is going to have to adapt to

00:37:51,599 --> 00:37:54,320
people work as much as people are going

00:37:52,960 --> 00:37:55,200
to have to adapt to how the formatter

00:37:54,320 --> 00:37:56,800
works

00:37:55,200 --> 00:37:58,880
what i actually saw when i started

00:37:56,800 --> 00:38:01,920
working in go is that like

00:37:58,880 --> 00:38:03,280
i changed how i was editing code to tell

00:38:01,920 --> 00:38:06,960
the formatter

00:38:03,280 --> 00:38:11,359
what i wanted it to do and my suspicion

00:38:06,960 --> 00:38:14,079
is that as the formatter

00:38:11,359 --> 00:38:16,000
improves uh people will learn to work

00:38:14,079 --> 00:38:19,040
with it more than like against it

00:38:16,000 --> 00:38:21,680
right and so the answer is i am not

00:38:19,040 --> 00:38:23,280
convinced that we should have a hard

00:38:21,680 --> 00:38:25,839
line length limit even though there is

00:38:23,280 --> 00:38:25,839
one today

00:38:29,200 --> 00:38:32,560
um i think we still have time for

00:38:31,359 --> 00:38:36,480
another question

00:38:32,560 --> 00:38:37,359
um so this one so penelope i was

00:38:36,480 --> 00:38:39,520
wondering

00:38:37,359 --> 00:38:41,760
if it's such a complex project would you

00:38:39,520 --> 00:38:43,760
be able to keep it updated with recent

00:38:41,760 --> 00:38:45,119
ruby versions and upcoming changes in

00:38:43,760 --> 00:38:47,520
syntax

00:38:45,119 --> 00:38:48,400
oh that's a that's a fantastic question

00:38:47,520 --> 00:38:51,200
so so

00:38:48,400 --> 00:38:52,320
um if you are following me on twitter

00:38:51,200 --> 00:38:55,520
you will see that

00:38:52,320 --> 00:38:56,560
uh as matz was announcing new syntaxes

00:38:55,520 --> 00:38:58,960
in ruby 3

00:38:56,560 --> 00:39:00,079
i was tweeting like screams in formatter

00:38:58,960 --> 00:39:03,359
maintainer

00:39:00,079 --> 00:39:04,240
um support is not automatic support

00:39:03,359 --> 00:39:07,119
requires

00:39:04,240 --> 00:39:08,880
like manual coding up of support for new

00:39:07,119 --> 00:39:11,760
constructs so actually like today ruby

00:39:08,880 --> 00:39:14,400
format does not support the 2.7

00:39:11,760 --> 00:39:16,000
uh case matching uh pattern matching

00:39:14,400 --> 00:39:17,839
syntax just because like

00:39:16,000 --> 00:39:20,160
i if this is an open source project that

00:39:17,839 --> 00:39:23,200
i am not paid to work on and i have not

00:39:20,160 --> 00:39:26,079
uh yet had time to

00:39:23,200 --> 00:39:28,079
uh work on it right um and that will

00:39:26,079 --> 00:39:30,880
also be true with uh

00:39:28,079 --> 00:39:32,000
any new syntaxes in the final version of

00:39:30,880 --> 00:39:36,160
ruby three

00:39:32,000 --> 00:39:38,960
um we today just for pragmatic reasons

00:39:36,160 --> 00:39:40,240
uh support ruby's i think it's two six

00:39:38,960 --> 00:39:43,520
and two seven

00:39:40,240 --> 00:39:46,160
um because like supporting older rubies

00:39:43,520 --> 00:39:46,720
um is not something that's sort of like

00:39:46,160 --> 00:39:49,280
uh

00:39:46,720 --> 00:39:50,800
feasible at the moment and and like that

00:39:49,280 --> 00:39:52,800
is generally

00:39:50,800 --> 00:39:54,240
the sort of idea is to only maintain

00:39:52,800 --> 00:39:56,000
current ish rubies

00:39:54,240 --> 00:39:57,920
and like right now we're catching up

00:39:56,000 --> 00:40:00,160
right so like for example

00:39:57,920 --> 00:40:02,480
the go language was designed from the

00:40:00,160 --> 00:40:04,240
ground up to support auto formatting

00:40:02,480 --> 00:40:06,400
and it still took them more than a year

00:40:04,240 --> 00:40:09,680
to build the go formatter

00:40:06,400 --> 00:40:11,280
ruby was in no sense designed to support

00:40:09,680 --> 00:40:13,599
auto for my thing and like

00:40:11,280 --> 00:40:14,880
the fact that it even flies at all is

00:40:13,599 --> 00:40:17,359
like kind of a miracle

00:40:14,880 --> 00:40:19,119
like like i like i said this in the talk

00:40:17,359 --> 00:40:22,560
and i will perhaps reinforce this

00:40:19,119 --> 00:40:24,079
um i had to learn more about the grammar

00:40:22,560 --> 00:40:25,680
of the ruby language then i think

00:40:24,079 --> 00:40:27,359
perhaps nearly anybody else on the

00:40:25,680 --> 00:40:28,720
planet maybe even mats

00:40:27,359 --> 00:40:30,160
actually has at this point in time

00:40:28,720 --> 00:40:31,599
because like so many different people

00:40:30,160 --> 00:40:35,200
have worked on it

00:40:31,599 --> 00:40:37,280
right um that and saying that

00:40:35,200 --> 00:40:38,640
right like we're still not there like

00:40:37,280 --> 00:40:41,119
i'm not done yet

00:40:38,640 --> 00:40:42,400
um and so the idea is that like by by

00:40:41,119 --> 00:40:44,720
the time we get we're getting close to a

00:40:42,400 --> 00:40:47,200
1.0 we will support all of that syntax

00:40:44,720 --> 00:40:51,040
we'll also support all of ruby three

00:40:47,200 --> 00:40:52,880
um and that like that will happen

00:40:51,040 --> 00:40:54,400
there's also this question about like

00:40:52,880 --> 00:40:57,359
what happens if

00:40:54,400 --> 00:40:58,480
the ruby language ever makes a breaking

00:40:57,359 --> 00:41:02,400
change

00:40:58,480 --> 00:41:04,079
um to ruby's syntax and that's very

00:41:02,400 --> 00:41:05,200
philosophically is like we don't want to

00:41:04,079 --> 00:41:07,200
make breaking changes we love

00:41:05,200 --> 00:41:10,720
compatibility it's super important

00:41:07,200 --> 00:41:14,079
um if it becomes impossible

00:41:10,720 --> 00:41:15,040
for us to support new and old versions

00:41:14,079 --> 00:41:16,960
of ruby

00:41:15,040 --> 00:41:19,040
that would be perhaps the the only

00:41:16,960 --> 00:41:20,240
reason ruby format would ever have like

00:41:19,040 --> 00:41:22,720
a 2.0

00:41:20,240 --> 00:41:24,640
is to break compatibility with a version

00:41:22,720 --> 00:41:26,720
of ruby we can no longer maintain

00:41:24,640 --> 00:41:28,640
if we want to support a new ruby right

00:41:26,720 --> 00:41:32,319
and at that point we would also allow

00:41:28,640 --> 00:41:34,560
breaking syntax changes um but

00:41:32,319 --> 00:41:35,839
the way i sort of look at this is as

00:41:34,560 --> 00:41:38,960
long as

00:41:35,839 --> 00:41:42,560
it is possible to represent both say

00:41:38,960 --> 00:41:45,440
ruby two six and ruby four

00:41:42,560 --> 00:41:46,800
grammars uh simultaneously uh ruby

00:41:45,440 --> 00:41:50,640
format will never need to have

00:41:46,800 --> 00:41:53,119
a major version or a breaking change

00:41:50,640 --> 00:41:54,880
awesome thank you so much penelope this

00:41:53,119 --> 00:41:56,480
has been absolutely incredible

00:41:54,880 --> 00:41:58,640
too too and and thank you for sharing

00:41:56,480 --> 00:42:02,000
your journey it's much appreciated

00:41:58,640 --> 00:42:04,319
of course so folks now

00:42:02,000 --> 00:42:06,160
we're out of time for this segment we're

00:42:04,319 --> 00:42:08,160
gonna go into a tiny break

00:42:06,160 --> 00:42:10,240
and we'll be back at you in about three

00:42:08,160 --> 00:42:16,960
minutes with tatiana's talk

00:42:10,240 --> 00:42:16,960

YouTube URL: https://www.youtube.com/watch?v=0R3FO666Jzk


