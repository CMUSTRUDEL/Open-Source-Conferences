Title: OSMC 2019 |  Zabbix LLD from a C Module by Jan Piet Mens
Publication date: 2019-11-18
Playlist: OSMC 2019 | Open Source Monitoring Conference
Description: 
	Low-level discovery provides a way to automatically create items, triggers, and graphs for different entities. For instance, Zabbix can automatically start monitoring file systems or network interfaces on your machine, without the need to create items for each file system or network interface manually. Using a real-life practical example which we use to monitor vehicles issued with GPS trackers which communicate via MQTT, we will discuss how we implement Zabbix Low-Level Discovery directly from a C module and how the same C module is used to provide up-to-date information from the vehicles to Zabbix items. This basic principle can easily be adapted to provide similar functionility to Internet of Things (IoT) projects. While it helps if you can read a bit of C language code, we’ll explain what’s going on behind the scenes even if you don’t.


NETWAYS
Konferenzen: https://www.netways.de/events
Schulungen: https://www.netways.de/schulungen
Shop: https://shop.netways.de/
Blog: http://blog.netways.de/
NWS: https://nws.netways.de

Webinare
Archiv Link: https://www.netways.de/webinare/archi...
Aktuell: https://www.netways.de/wb

Social Media
SlideShare: http://de.slideshare.net/netways
YouTube: https://www.netways.de/youtube
Facebook: https://www.facebook.com/netways
Twitter: https://twitter.com/netways
Instagram: https://www.instagram.com/netwaysgmbh/

Musik: FRAMETRAXX
Captions: 
	00:00:09,379 --> 00:00:14,519
so zabbix loadable seed modules and

00:00:12,090 --> 00:00:16,049
low-level discovery I was considering

00:00:14,519 --> 00:00:17,580
putting the whole talk just into the

00:00:16,049 --> 00:00:21,329
title but I thought this will keep it a

00:00:17,580 --> 00:00:24,840
bit shorter um so I'm young Pete Manson

00:00:21,329 --> 00:00:28,080
JP means I amongst a number of other

00:00:24,840 --> 00:00:30,060
things I created a project called own

00:00:28,080 --> 00:00:33,449
tracks which one or the other of you

00:00:30,060 --> 00:00:36,620
might have heard of we produce or create

00:00:33,449 --> 00:00:41,610
open source tracking applications for

00:00:36,620 --> 00:00:42,809
mobile phones iOS and Android and it's

00:00:41,610 --> 00:00:45,900
completely open source you host it

00:00:42,809 --> 00:00:47,790
yourself it runs over MQTT or HTTP I'm

00:00:45,900 --> 00:00:51,510
telling you this as a as a prelude to

00:00:47,790 --> 00:00:53,220
what's coming we don't know where you

00:00:51,510 --> 00:00:55,619
are of course this is purely hosted by

00:00:53,220 --> 00:00:57,479
yourself this I'm showing you this map

00:00:55,619 --> 00:00:59,010
because you I assume you're about the

00:00:57,479 --> 00:01:02,180
short sighted as I am so you can't see

00:00:59,010 --> 00:01:04,650
the details this is where my family is

00:01:02,180 --> 00:01:09,289
and they track me and we try to each

00:01:04,650 --> 00:01:13,289
other and this has become relatively

00:01:09,289 --> 00:01:16,320
relatively popular so we created this

00:01:13,289 --> 00:01:20,880
this project and another project we

00:01:16,320 --> 00:01:23,609
created was on tracks for for vehicles

00:01:20,880 --> 00:01:26,939
and what we do with on tracks for

00:01:23,609 --> 00:01:29,219
vehicles is we have devices these these

00:01:26,939 --> 00:01:30,570
devices approximately the size of half a

00:01:29,219 --> 00:01:32,390
cigarette five half a package of

00:01:30,570 --> 00:01:36,840
cigarettes a bit thinner which

00:01:32,390 --> 00:01:40,679
communicate over TCP to a piece of open

00:01:36,840 --> 00:01:42,569
source and from there onwards via an qtt

00:01:40,679 --> 00:01:45,950
into into all sort of other

00:01:42,569 --> 00:01:48,780
infrastructure and what we what we

00:01:45,950 --> 00:01:51,780
wanted was a mechanism by which we can

00:01:48,780 --> 00:01:54,810
monitor particular vehicles however what

00:01:51,780 --> 00:02:00,329
we did not want to do was to create a

00:01:54,810 --> 00:02:04,530
vehicle manually so or our monitoring

00:02:00,329 --> 00:02:06,119
system of choice became zabbix now the

00:02:04,530 --> 00:02:08,009
reason it became our monitoring system

00:02:06,119 --> 00:02:10,560
of choice a number of reasons but one of

00:02:08,009 --> 00:02:13,980
the main reasons is it's very extensible

00:02:10,560 --> 00:02:16,620
and a symmetry to my mind rightly said

00:02:13,980 --> 00:02:17,319
earlier is the expert I just fell in

00:02:16,620 --> 00:02:19,299
love with

00:02:17,319 --> 00:02:21,459
component and those of the loadable

00:02:19,299 --> 00:02:25,480
modules otherwise I'm not a specific is

00:02:21,459 --> 00:02:27,579
that it's expert as Dimitri rightly said

00:02:25,480 --> 00:02:28,139
earlier if you were listening to his

00:02:27,579 --> 00:02:31,840
talk

00:02:28,139 --> 00:02:33,489
zabbix is very extensible we can get all

00:02:31,840 --> 00:02:35,439
sorts of data into that later on I'm

00:02:33,489 --> 00:02:37,900
going to show you maybe something that

00:02:35,439 --> 00:02:41,590
is a little bit less well known those

00:02:37,900 --> 00:02:43,659
are notable low CC modules so zabbix

00:02:41,590 --> 00:02:45,400
out-of-the-box cannot possibly support

00:02:43,659 --> 00:02:46,569
everything you wanted there is a lot of

00:02:45,400 --> 00:02:49,959
support for a lot of different

00:02:46,569 --> 00:02:52,689
components but we can extend it via a

00:02:49,959 --> 00:02:55,150
number of different possibilities I'm

00:02:52,689 --> 00:02:57,040
not showing you four of them the system

00:02:55,150 --> 00:03:00,459
run user parameter so-called external

00:02:57,040 --> 00:03:07,209
checks and loadable modules the first

00:03:00,459 --> 00:03:10,319
three are extensible or possibility to

00:03:07,209 --> 00:03:12,489
extends extending zabbix via basically

00:03:10,319 --> 00:03:14,500
executive all programs so maybe a shell

00:03:12,489 --> 00:03:17,590
script a ruby program C program whatever

00:03:14,500 --> 00:03:20,079
and in this in these cases we have to be

00:03:17,590 --> 00:03:22,000
a little bit careful because the either

00:03:20,079 --> 00:03:23,439
the zabbix server or the zabbix agent

00:03:22,000 --> 00:03:28,090
depending when this is where these

00:03:23,439 --> 00:03:31,329
things are running a second will cause

00:03:28,090 --> 00:03:33,189
or can cause severe load due to the fact

00:03:31,329 --> 00:03:36,569
that these processes start forking and

00:03:33,189 --> 00:03:38,680
executing executive alts the last

00:03:36,569 --> 00:03:40,840
mechanism here so-called loadable

00:03:38,680 --> 00:03:43,659
modules is slightly more complex

00:03:40,840 --> 00:03:45,340
loadable modules are created currently

00:03:43,659 --> 00:03:47,199
in the C language so a little bit more

00:03:45,340 --> 00:03:49,239
complex but I would like to introduce

00:03:47,199 --> 00:03:52,840
you very carefully to that show you a

00:03:49,239 --> 00:03:55,750
small relatively trivial example which I

00:03:52,840 --> 00:03:58,720
hope will demonstrate or at least

00:03:55,750 --> 00:04:03,639
illustrate what we are what we're doing

00:03:58,720 --> 00:04:06,219
so system run runs on an agent system

00:04:03,639 --> 00:04:08,650
run you basically have system run and

00:04:06,219 --> 00:04:11,500
here user local beam whatever 1 2 3 and

00:04:08,650 --> 00:04:16,199
this is basically a shell script Remi an

00:04:11,500 --> 00:04:21,909
executive program whatever Ruby Python

00:04:16,199 --> 00:04:25,180
this is run periodically the system run

00:04:21,909 --> 00:04:27,660
runs on the agent and the agent and

00:04:25,180 --> 00:04:31,380
returns this parameter

00:04:27,660 --> 00:04:35,700
under the appropriate key to the zabbix

00:04:31,380 --> 00:04:39,390
server system run must be enabled by

00:04:35,700 --> 00:04:41,250
enabling remote commands and optionally

00:04:39,390 --> 00:04:44,330
logging remote commands and these

00:04:41,250 --> 00:04:47,250
commands event logged in the normal

00:04:44,330 --> 00:04:49,620
another possibility again on the agent

00:04:47,250 --> 00:04:52,230
so-called user parameters where in the

00:04:49,620 --> 00:04:55,260
agent configuration we configure a user

00:04:52,230 --> 00:04:57,780
parameter for example named CN whatever

00:04:55,260 --> 00:05:00,570
and then a shell script R shall line

00:04:57,780 --> 00:05:08,250
which is executed there this is

00:05:00,570 --> 00:05:10,770
something I'm very wary of doing logging

00:05:08,250 --> 00:05:13,410
is not as good as I would hope it would

00:05:10,770 --> 00:05:16,620
be anyway but this is something that

00:05:13,410 --> 00:05:21,150
everybody can very very easily do to

00:05:16,620 --> 00:05:24,990
extend the agent on the server we have

00:05:21,150 --> 00:05:26,280
so-called external checks these external

00:05:24,990 --> 00:05:28,770
checks here once again

00:05:26,280 --> 00:05:32,070
or for example shell scripts or Ruby

00:05:28,770 --> 00:05:34,950
programs or Python whatever which can be

00:05:32,070 --> 00:05:36,420
parameterized and these programs produce

00:05:34,950 --> 00:05:38,760
would produce standard output under

00:05:36,420 --> 00:05:41,100
standard output is then consumed by the

00:05:38,760 --> 00:05:43,860
zabbix server and that turns into

00:05:41,100 --> 00:05:48,570
metrics here these external checks once

00:05:43,860 --> 00:05:50,730
again run on the server and there is an

00:05:48,570 --> 00:05:52,680
external script path which needs to be

00:05:50,730 --> 00:05:54,660
configured and in that path in that

00:05:52,680 --> 00:05:57,870
directory that's where you would place

00:05:54,660 --> 00:05:59,520
your your programs so these are things

00:05:57,870 --> 00:06:01,410
which have existed for quite some time

00:05:59,520 --> 00:06:04,080
and what has also existed for quite a

00:06:01,410 --> 00:06:07,440
number of years are loadable modules and

00:06:04,080 --> 00:06:09,990
loadable modules are currently written

00:06:07,440 --> 00:06:13,200
in the C language I say currently

00:06:09,990 --> 00:06:17,280
because zabbix has helped me Demetri and

00:06:13,200 --> 00:06:21,240
I think in 4.4 introduced an agent in go

00:06:17,280 --> 00:06:23,700
to my knowledge no guarantees but to my

00:06:21,240 --> 00:06:25,990
knowledge there is currently no no local

00:06:23,700 --> 00:06:27,640
modules for the go I feel I understand

00:06:25,990 --> 00:06:29,650
when is still thinking a little bit

00:06:27,640 --> 00:06:32,620
about it so loadable modules are written

00:06:29,650 --> 00:06:35,950
in C language they are thus compiled

00:06:32,620 --> 00:06:38,650
they are dynamically loaded and they can

00:06:35,950 --> 00:06:41,650
be loaded they can be read into the

00:06:38,650 --> 00:06:44,200
server into a proxy or into an agent and

00:06:41,650 --> 00:06:46,320
the agent that's where that's the point

00:06:44,200 --> 00:06:49,510
that that interests us particularly much

00:06:46,320 --> 00:06:52,530
so what can these modules do where can

00:06:49,510 --> 00:06:55,120
these modules obtain metrics from well

00:06:52,530 --> 00:06:57,430
actually just your imagination is the

00:06:55,120 --> 00:06:59,860
limit basically these modules these

00:06:57,430 --> 00:07:01,480
since there are C module C functions

00:06:59,860 --> 00:07:04,270
they can do whatever they like we could

00:07:01,480 --> 00:07:07,590
access sockets we could access system 5

00:07:04,270 --> 00:07:11,800
IPC inter-process communication we could

00:07:07,590 --> 00:07:15,100
access files databases any communication

00:07:11,800 --> 00:07:19,660
protocol you want a IOT sensors

00:07:15,100 --> 00:07:22,050
Dmitry's can bus thing what you call it

00:07:19,660 --> 00:07:26,410
the LM what was the number two one four

00:07:22,050 --> 00:07:28,720
seven five nine whatever exactly and so

00:07:26,410 --> 00:07:31,300
these loadable modules can basically do

00:07:28,720 --> 00:07:35,200
anything that any data function in the C

00:07:31,300 --> 00:07:37,450
language can do so de facto anything the

00:07:35,200 --> 00:07:40,270
only thing we need to be slightly aware

00:07:37,450 --> 00:07:43,600
of or we need to be a little bit careful

00:07:40,270 --> 00:07:47,290
with is first of all the loadable

00:07:43,600 --> 00:07:50,050
modules are loaded into the process of

00:07:47,290 --> 00:07:54,040
the agent respectively the proxy or the

00:07:50,050 --> 00:07:55,810
server that means if a programming error

00:07:54,040 --> 00:07:57,040
causes module to crash then of course

00:07:55,810 --> 00:07:59,500
that would take down the whole agent

00:07:57,040 --> 00:08:03,370
although one has to be careful testing

00:07:59,500 --> 00:08:06,700
is a bit more maybe a bit more intensive

00:08:03,370 --> 00:08:09,490
and we have we're running in the context

00:08:06,700 --> 00:08:12,190
of a zabbix process be it the agent will

00:08:09,490 --> 00:08:14,260
appear the server or the proxy and thus

00:08:12,190 --> 00:08:16,720
we have to be slightly careful with that

00:08:14,260 --> 00:08:19,290
and with permissions so let's have a

00:08:16,720 --> 00:08:22,330
look at how a custom module is

00:08:19,290 --> 00:08:26,470
configured first of all we have a path

00:08:22,330 --> 00:08:28,720
so zabbix is will only load a module if

00:08:26,470 --> 00:08:30,910
we have a load module path configured

00:08:28,720 --> 00:08:33,160
that means in slash user slash lives

00:08:30,910 --> 00:08:34,649
annex agent that is where these modules

00:08:33,160 --> 00:08:36,479
are to be found there

00:08:34,649 --> 00:08:38,909
objects Australian a moment have created

00:08:36,479 --> 00:08:41,149
and we can load basically any number of

00:08:38,909 --> 00:08:43,919
modules here I've got an example

00:08:41,149 --> 00:08:46,649
contracts module dot s owed or shared

00:08:43,919 --> 00:08:49,339
object and another module to data so the

00:08:46,649 --> 00:08:52,619
fabrics would load these two modules in

00:08:49,339 --> 00:08:57,600
and sequence and would provide whatever

00:08:52,619 --> 00:09:00,540
functions are contained these modules

00:08:57,600 --> 00:09:03,209
are as I mentioned already they are C

00:09:00,540 --> 00:09:04,980
programs which are dynamically linked

00:09:03,209 --> 00:09:08,699
this is a make file which would create

00:09:04,980 --> 00:09:11,309
it so we have here our file called own

00:09:08,699 --> 00:09:14,399
tracks module dot C which is compiled as

00:09:11,309 --> 00:09:16,019
shared code out of that comes a dot as

00:09:14,399 --> 00:09:17,639
our shared object which is then

00:09:16,019 --> 00:09:19,649
installed a copied into the appropriate

00:09:17,639 --> 00:09:23,160
directory ok so that is how we would

00:09:19,649 --> 00:09:25,499
build these modules zabbix modules

00:09:23,160 --> 00:09:27,779
cervix loadable modules can be built in

00:09:25,499 --> 00:09:30,290
the source in designing source tree or

00:09:27,779 --> 00:09:32,610
outside of the zabbix source tree I

00:09:30,290 --> 00:09:36,449
personally prefer building them outside

00:09:32,610 --> 00:09:40,589
of the zabbix source tree so I have my

00:09:36,449 --> 00:09:43,889
own directory my own documentation etc

00:09:40,589 --> 00:09:46,019
made file and I can build them

00:09:43,889 --> 00:09:48,629
irrespective of the actual zabbix

00:09:46,019 --> 00:09:51,509
release on version and in order to do

00:09:48,629 --> 00:09:55,139
that I have a module dot H file which I

00:09:51,509 --> 00:09:56,999
copy in to my code and the only thing we

00:09:55,139 --> 00:09:58,769
have to do this is the module dot H file

00:09:56,999 --> 00:10:00,769
which is provided by the appropriate

00:09:58,769 --> 00:10:03,569
cervix release and we just have to

00:10:00,769 --> 00:10:06,059
change this this line by these two lines

00:10:03,569 --> 00:10:08,129
that's all so we copy that into our

00:10:06,059 --> 00:10:09,959
source code and into our source code

00:10:08,129 --> 00:10:12,949
directory and and from then on we can

00:10:09,959 --> 00:10:16,579
create these modules the module itself

00:10:12,949 --> 00:10:19,769
has a number of can have a number of

00:10:16,579 --> 00:10:23,069
functions which are invoked by zabbix

00:10:19,769 --> 00:10:25,230
there's one mandatory function and that

00:10:23,069 --> 00:10:29,189
is the functions that the execs module

00:10:25,230 --> 00:10:31,170
API version that module must exist a big

00:10:29,189 --> 00:10:35,839
upon that function must be defined by my

00:10:31,170 --> 00:10:40,290
module all others are optional however

00:10:35,839 --> 00:10:42,480
if we only have the module API version

00:10:40,290 --> 00:10:44,279
function then our mod you will defect

00:10:42,480 --> 00:10:44,800
I'll not do anything except provide a

00:10:44,279 --> 00:10:46,930
version

00:10:44,800 --> 00:10:50,740
that's all that provides and we'll look

00:10:46,930 --> 00:10:53,019
at the others in a moment the function

00:10:50,740 --> 00:10:56,740
that the exotics module history right

00:10:53,019 --> 00:10:59,920
call back I've stricken out here it

00:10:56,740 --> 00:11:04,390
still exists it is documented though

00:10:59,920 --> 00:11:07,180
very very badly and/or very similarly

00:11:04,390 --> 00:11:09,750
and my recommendation would be not to

00:11:07,180 --> 00:11:11,589
use that there's an alternative

00:11:09,750 --> 00:11:15,220
capability and I'll show you a moment

00:11:11,589 --> 00:11:18,190
what that will be so Becky Park module

00:11:15,220 --> 00:11:20,410
in it will initialize our function or

00:11:18,190 --> 00:11:22,540
will initialize our module this is where

00:11:20,410 --> 00:11:24,670
for example I could open a socket

00:11:22,540 --> 00:11:27,250
connection to something I could open a

00:11:24,670 --> 00:11:29,620
database module an init will sort of

00:11:27,250 --> 00:11:31,750
Dion D initialize that is when zabbix is

00:11:29,620 --> 00:11:33,640
going to unload the module in other

00:11:31,750 --> 00:11:35,500
words Alex is terminating for example

00:11:33,640 --> 00:11:39,970
have the possibility to clean up things

00:11:35,500 --> 00:11:44,589
and module item list is where we will

00:11:39,970 --> 00:11:46,870
get we will define a table of keys so

00:11:44,589 --> 00:11:49,720
called zabbix item keys to function

00:11:46,870 --> 00:11:53,860
socially in a second so let's look at

00:11:49,720 --> 00:11:57,490
this we have certain cases we return

00:11:53,860 --> 00:12:01,209
values B please very very careful with

00:11:57,490 --> 00:12:03,279
string values string values are we

00:12:01,209 --> 00:12:06,250
always return a copy of a string value

00:12:03,279 --> 00:12:08,320
this looks a bit strange if you are C

00:12:06,250 --> 00:12:11,050
programmer or if you're used to looking

00:12:08,320 --> 00:12:12,370
at real sheep or returning a copy of the

00:12:11,050 --> 00:12:14,140
string is always a bit difficult because

00:12:12,370 --> 00:12:16,600
you need somebody to D initialize that

00:12:14,140 --> 00:12:20,290
to free it zabbix does that for us

00:12:16,600 --> 00:12:23,110
that's a little bit difficult to get

00:12:20,290 --> 00:12:26,589
used that's the way it works so our C

00:12:23,110 --> 00:12:29,170
module starts off with an include on our

00:12:26,589 --> 00:12:33,850
module dot age and here we define the

00:12:29,170 --> 00:12:36,010
sole mandatory function zabbix module

00:12:33,850 --> 00:12:38,860
API version and the only thing we do is

00:12:36,010 --> 00:12:41,860
return this constant the reason this

00:12:38,860 --> 00:12:44,680
exists is so that when for example a

00:12:41,860 --> 00:12:47,560
future zabbix version would load my

00:12:44,680 --> 00:12:49,990
compiled module which I hadn't recompile

00:12:47,560 --> 00:12:52,000
compiled it today and a future zabbix

00:12:49,990 --> 00:12:54,870
version might have a different API

00:12:52,000 --> 00:12:58,320
version zabbix could then warn me

00:12:54,870 --> 00:13:00,900
say this API version does not match the

00:12:58,320 --> 00:13:04,410
code that I currently have some have to

00:13:00,900 --> 00:13:07,440
recompile maybe also redefined okay so

00:13:04,410 --> 00:13:12,030
this is the only or the single mandatory

00:13:07,440 --> 00:13:13,530
function and basically you just copy

00:13:12,030 --> 00:13:16,470
these three lines these four lines in

00:13:13,530 --> 00:13:19,530
there so what do we then have the

00:13:16,470 --> 00:13:22,890
initialize respectively D initializer

00:13:19,530 --> 00:13:28,170
init init functions what I'm doing here

00:13:22,890 --> 00:13:30,180
is I open a database and set to global

00:13:28,170 --> 00:13:32,100
and upon shutting down I close that

00:13:30,180 --> 00:13:33,870
that's all I do that's all I have to do

00:13:32,100 --> 00:13:38,220
in this particular very very trivial

00:13:33,870 --> 00:13:41,520
example and other than that we return

00:13:38,220 --> 00:13:43,890
and okay respectively a failure code if

00:13:41,520 --> 00:13:46,920
we return a failure code zabbix will not

00:13:43,890 --> 00:13:49,380
have loaded our module or in other words

00:13:46,920 --> 00:13:51,660
has tried to load the module the module

00:13:49,380 --> 00:13:53,370
has said we can't run the database so

00:13:51,660 --> 00:13:56,160
that box will then stop with an

00:13:53,370 --> 00:14:01,020
appropriate diagnostic message which is

00:13:56,160 --> 00:14:03,510
correct then we have the zabbix module

00:14:01,020 --> 00:14:07,140
item list function the zabbix item

00:14:03,510 --> 00:14:10,110
modulus function it will return a an

00:14:07,140 --> 00:14:14,370
array of structures and these structures

00:14:10,110 --> 00:14:18,180
define an item key so called zabbix item

00:14:14,370 --> 00:14:21,660
key zabbix item is like a field whether

00:14:18,180 --> 00:14:25,080
or not the the function gets parameters

00:14:21,660 --> 00:14:28,530
so I've named the key on track stop ping

00:14:25,080 --> 00:14:30,180
that gets no parameters on track LLL

00:14:28,530 --> 00:14:32,100
deal or level discovery gets no

00:14:30,180 --> 00:14:36,090
parameters and on track start well

00:14:32,100 --> 00:14:39,120
velocity that gets parameters okay the

00:14:36,090 --> 00:14:41,010
answer actual internal C function which

00:14:39,120 --> 00:14:43,320
will see defined in a moment that's

00:14:41,010 --> 00:14:46,590
these are the names of the C function

00:14:43,320 --> 00:14:50,250
and appropriate test parameters which

00:14:46,590 --> 00:14:53,600
are used I forgotten I think they use

00:14:50,250 --> 00:14:56,610
when one side zabbix was - P sort of a

00:14:53,600 --> 00:15:00,690
test to test the internal the internal

00:14:56,610 --> 00:15:03,120
module just an example and this the

00:15:00,690 --> 00:15:06,420
function own tracks underscore Val

00:15:03,120 --> 00:15:07,080
velocity will be getting a an e my

00:15:06,420 --> 00:15:09,120
number

00:15:07,080 --> 00:15:11,490
International mobile equipment

00:15:09,120 --> 00:15:13,260
identifier and that is how it will

00:15:11,490 --> 00:15:14,670
determine which a vehicle is being

00:15:13,260 --> 00:15:18,300
queried but I'll show you that in a

00:15:14,670 --> 00:15:20,130
second so these are the names that Sam

00:15:18,300 --> 00:15:22,350
picks is going to query or we can have

00:15:20,130 --> 00:15:24,029
query in zabbix and this is the report

00:15:22,350 --> 00:15:30,089
these are the appropriate C functions

00:15:24,029 --> 00:15:32,010
which will be invoked as a small example

00:15:30,089 --> 00:15:34,200
let's look at this function let me

00:15:32,010 --> 00:15:38,550
excuse me just go back this function own

00:15:34,200 --> 00:15:42,570
tracks underscore ping gets a zabbix

00:15:38,550 --> 00:15:45,089
agent request and a pointer to results

00:15:42,570 --> 00:15:46,980
the only thing that this function is

00:15:45,089 --> 00:15:50,070
going to do is it's going to copy a

00:15:46,980 --> 00:15:53,250
result here the integer 42 back to

00:15:50,070 --> 00:15:57,060
zabbix and then returns with an ok value

00:15:53,250 --> 00:16:01,380
okay so zabbix will every time that this

00:15:57,060 --> 00:16:03,390
function is invoked by the item on track

00:16:01,380 --> 00:16:06,360
stop thing is going to invoke this

00:16:03,390 --> 00:16:08,430
function on tracks underscore ping that

00:16:06,360 --> 00:16:11,010
function underscore ping is going to

00:16:08,430 --> 00:16:12,839
return the value 42 and we can test that

00:16:11,010 --> 00:16:15,029
after restarting the appropriate agent

00:16:12,839 --> 00:16:17,310
or the server we can test it for example

00:16:15,029 --> 00:16:19,620
with zabbix get on the server

00:16:17,310 --> 00:16:22,410
respectively agent name with a key on

00:16:19,620 --> 00:16:26,880
track ping and we see the value 42 any

00:16:22,410 --> 00:16:33,720
zabbix key that you can query ours is

00:16:26,880 --> 00:16:36,209
called on track something so these items

00:16:33,720 --> 00:16:39,420
that we have created they can be loaded

00:16:36,209 --> 00:16:43,410
into the front end and on the front end

00:16:39,420 --> 00:16:45,750
we are going to create simple checks and

00:16:43,410 --> 00:16:48,270
we're going to do that for inside of its

00:16:45,750 --> 00:16:50,579
agent respectively active agent and

00:16:48,270 --> 00:16:51,770
these items we can on the front end we

00:16:50,579 --> 00:16:54,300
can of course create for example

00:16:51,770 --> 00:16:57,600
programmatically either in the user

00:16:54,300 --> 00:16:59,370
interface or using I've just used an

00:16:57,600 --> 00:17:03,890
example here because I'm a great fan of

00:16:59,370 --> 00:17:06,990
automating things so creating an item

00:17:03,890 --> 00:17:10,439
programmatically with the with the API

00:17:06,990 --> 00:17:12,839
and you see the key the field key is on

00:17:10,439 --> 00:17:15,089
drugs not ping and that is what is then

00:17:12,839 --> 00:17:18,419
literally copied into the key so

00:17:15,089 --> 00:17:19,860
whenever this field is invoked every

00:17:18,419 --> 00:17:22,500
here 60 seconds

00:17:19,860 --> 00:17:24,800
as defined by the delay then that field

00:17:22,500 --> 00:17:28,230
will be or that key will be invoked

00:17:24,800 --> 00:17:31,560
zabbix knows that key because it has

00:17:28,230 --> 00:17:33,930
loaded it during the server start and

00:17:31,560 --> 00:17:35,940
respectively agents are knows what to do

00:17:33,930 --> 00:17:40,290
and will actually invoke that and return

00:17:35,940 --> 00:17:43,380
that value so let's look at a little bit

00:17:40,290 --> 00:17:47,040
more complex function and there is the

00:17:43,380 --> 00:17:49,740
contracts dot velocity you will recall

00:17:47,040 --> 00:17:51,750
let me just go back three pages you will

00:17:49,740 --> 00:17:53,640
recall antrax dot velocity was a

00:17:51,750 --> 00:17:55,500
function on tracks or invoke the

00:17:53,640 --> 00:17:58,620
function on tracks underscore Vil and

00:17:55,500 --> 00:18:02,760
got parameters let's go forward and look

00:17:58,620 --> 00:18:04,620
at this function basically the function

00:18:02,760 --> 00:18:06,930
header the function signature is

00:18:04,620 --> 00:18:09,240
identical and what we're doing is

00:18:06,930 --> 00:18:11,880
checking whether we actually have a

00:18:09,240 --> 00:18:13,590
request parameter if we have no request

00:18:11,880 --> 00:18:17,070
parameter or more than one request

00:18:13,590 --> 00:18:18,570
parameter we return with a an error

00:18:17,070 --> 00:18:20,880
message and this error message will be

00:18:18,570 --> 00:18:23,100
then made visible in the user interface

00:18:20,880 --> 00:18:26,210
in the zabbix user interface show you in

00:18:23,100 --> 00:18:30,120
a moment that error message would be

00:18:26,210 --> 00:18:32,340
would be seen and here recall I said we

00:18:30,120 --> 00:18:35,310
always return as a copy of the string

00:18:32,340 --> 00:18:38,550
this is an example we return here the

00:18:35,310 --> 00:18:41,730
error message string duct so duplicate

00:18:38,550 --> 00:18:43,590
and a copy of the mystery other than

00:18:41,730 --> 00:18:45,450
that what this function does is goes

00:18:43,590 --> 00:18:48,750
into the database looks for the

00:18:45,450 --> 00:18:55,910
appropriate parameter and then returns a

00:18:48,750 --> 00:18:58,590
copy of that of that value and this this

00:18:55,910 --> 00:19:01,950
function all tracks underscore Val

00:18:58,590 --> 00:19:03,930
velocity will be returning the speed or

00:19:01,950 --> 00:19:09,210
the velocity that appropriate Imai

00:19:03,930 --> 00:19:12,930
number is driving it so what we now so

00:19:09,210 --> 00:19:14,970
far have is a see module with a number

00:19:12,930 --> 00:19:16,770
of compiled functions which has been

00:19:14,970 --> 00:19:19,440
loaded by the agent respectively by the

00:19:16,770 --> 00:19:21,540
server and these functions can be

00:19:19,440 --> 00:19:23,430
invoked by calling them with the

00:19:21,540 --> 00:19:26,430
appropriate parameters just like we

00:19:23,430 --> 00:19:28,050
would any other zabbix function okay so

00:19:26,430 --> 00:19:29,850
so far there's nothing really special

00:19:28,050 --> 00:19:33,720
the only special thing

00:19:29,850 --> 00:19:37,080
is basically that we have this data

00:19:33,720 --> 00:19:38,760
being returned by a dynamically loadable

00:19:37,080 --> 00:19:42,240
module which we've compiled from a c

00:19:38,760 --> 00:19:46,049
source so very fast and contained in

00:19:42,240 --> 00:19:47,910
within the server within the agent now

00:19:46,049 --> 00:19:48,900
let's talk a little bit about low-level

00:19:47,910 --> 00:19:50,850
discovery

00:19:48,900 --> 00:19:53,370
who've you have already heard about

00:19:50,850 --> 00:19:53,929
low-level discovery ins in generally

00:19:53,370 --> 00:19:59,520
speaking

00:19:53,929 --> 00:20:01,260
okay so low-level discovery is quite

00:19:59,520 --> 00:20:04,470
widely used and there are a number of

00:20:01,260 --> 00:20:07,500
built-in mechanisms or built-in methods

00:20:04,470 --> 00:20:10,770
which zabbix has to provide low-level

00:20:07,500 --> 00:20:15,390
discovery for example network interfaces

00:20:10,770 --> 00:20:17,820
or CPUs or SNMP oh I DS can be returned

00:20:15,390 --> 00:20:22,049
through low-level discovery so called

00:20:17,820 --> 00:20:25,309
JMX objects we can have ODBC queries who

00:20:22,049 --> 00:20:28,320
uses ODBC I got shutters on ie ODBC

00:20:25,309 --> 00:20:30,840
Windows services file systems things

00:20:28,320 --> 00:20:32,610
like that zabbix can return with

00:20:30,840 --> 00:20:34,380
low-level discovery now the interesting

00:20:32,610 --> 00:20:38,610
thing about low-level discovery is that

00:20:34,380 --> 00:20:42,179
we can add our own so it's basically no

00:20:38,610 --> 00:20:44,730
limit to what we can discover and that

00:20:42,179 --> 00:20:46,590
is what I'm going to show you here now

00:20:44,730 --> 00:20:49,080
the way that low-level discovery works

00:20:46,590 --> 00:20:51,090
is that we create an item in zabbix a

00:20:49,080 --> 00:20:53,039
so-called trapper item can be any kind

00:20:51,090 --> 00:20:57,179
of item for example a trapper item and

00:20:53,039 --> 00:21:01,080
we push into that item from outside and

00:20:57,179 --> 00:21:04,169
we push adjacent in a very specific

00:21:01,080 --> 00:21:07,380
format which of course that supports and

00:21:04,169 --> 00:21:10,530
the fact that we are putting or copying

00:21:07,380 --> 00:21:14,490
Jason into that trapper item will cause

00:21:10,530 --> 00:21:18,390
Avex to create new items new graph items

00:21:14,490 --> 00:21:21,299
new templates whatever so loan level

00:21:18,390 --> 00:21:23,580
discovery discovers entities and not

00:21:21,299 --> 00:21:26,400
actual value so what we're going to

00:21:23,580 --> 00:21:27,929
create with a low-level discovery is in

00:21:26,400 --> 00:21:30,510
this particular example for our

00:21:27,929 --> 00:21:32,010
particular use case is since we're

00:21:30,510 --> 00:21:34,770
monitoring vehicles we're going to

00:21:32,010 --> 00:21:37,049
create new vehicles any time a new

00:21:34,770 --> 00:21:39,600
vehicle shows up any time we configure a

00:21:37,049 --> 00:21:41,190
new a new car a new truck a new bus with

00:21:39,600 --> 00:21:42,590
one of these devices gets an email

00:21:41,190 --> 00:21:44,929
number this

00:21:42,590 --> 00:21:47,150
a my number is published by MQTT to a

00:21:44,929 --> 00:21:49,400
specific broker and zabbix will then

00:21:47,150 --> 00:21:51,500
automatically get that email number and

00:21:49,400 --> 00:21:54,200
we'll create an item for that email

00:21:51,500 --> 00:21:58,880
number and form the number part of the

00:21:54,200 --> 00:22:02,419
of the device actually in a second so

00:21:58,880 --> 00:22:05,600
the way we do this is we have vehicles

00:22:02,419 --> 00:22:07,789
buses cars automobiles any any vehicle

00:22:05,600 --> 00:22:11,779
with these devices with these cute Ripa

00:22:07,789 --> 00:22:15,169
devices and what we do is we get that

00:22:11,779 --> 00:22:17,630
data provided by these devices the data

00:22:15,169 --> 00:22:19,850
is published typically once once a

00:22:17,630 --> 00:22:22,370
minute respectively every hundred meters

00:22:19,850 --> 00:22:26,090
or when a car turns a corner whenever

00:22:22,370 --> 00:22:27,710
whenever the GPS system detects that

00:22:26,090 --> 00:22:32,799
it's going around the corner then we

00:22:27,710 --> 00:22:35,809
automatically publish a new message and

00:22:32,799 --> 00:22:37,820
this data is going to be picked up by a

00:22:35,809 --> 00:22:39,919
process that we've created this process

00:22:37,820 --> 00:22:41,450
of sharing a moment where it does but

00:22:39,919 --> 00:22:45,350
amongst all the things it's going to

00:22:41,450 --> 00:22:48,320
feed a LM DB database elem DB the

00:22:45,350 --> 00:22:51,620
Lightning database originally created by

00:22:48,320 --> 00:22:54,890
Howard true for open LDAP is one of is

00:22:51,620 --> 00:22:57,289
an embedded database it's very very fast

00:22:54,890 --> 00:22:59,149
blindingly fast and it's relatively easy

00:22:57,289 --> 00:23:02,840
to use and it's embedded and that for us

00:22:59,149 --> 00:23:05,720
is ideal so basically it's attached to

00:23:02,840 --> 00:23:07,909
our seam module which has been loaded in

00:23:05,720 --> 00:23:10,159
the agent here on the left-hand side we

00:23:07,909 --> 00:23:14,330
have our Sonic's agent on each of the

00:23:10,159 --> 00:23:16,490
service that we want to use we have this

00:23:14,330 --> 00:23:18,409
agent this agent has our loadable

00:23:16,490 --> 00:23:20,179
dynamically loadable C module this

00:23:18,409 --> 00:23:22,580
dynamically viewer will see module with

00:23:20,179 --> 00:23:26,539
the alum DB database and will then

00:23:22,580 --> 00:23:28,909
provide data and values to this a big

00:23:26,539 --> 00:23:30,350
server and amongst others it will not

00:23:28,909 --> 00:23:32,990
only provide the values for example

00:23:30,350 --> 00:23:34,700
which what is the velocity of a mine

00:23:32,990 --> 00:23:36,830
number 1 what is the velocity of a my

00:23:34,700 --> 00:23:38,809
number 2 but it will also provide

00:23:36,830 --> 00:23:43,700
low-level discovery information which it

00:23:38,809 --> 00:23:45,860
cleans out of that LM DB database so

00:23:43,700 --> 00:23:47,990
what this process that we have here this

00:23:45,860 --> 00:23:53,030
blue process what that does is it

00:23:47,990 --> 00:23:54,380
subscribes to an MQTT Channel and reads

00:23:53,030 --> 00:23:57,200
all topics that come

00:23:54,380 --> 00:23:58,970
coming out it extracts our own tracks

00:23:57,200 --> 00:23:59,930
Jason payload I'll show you an example

00:23:58,970 --> 00:24:03,470
in a second

00:23:59,930 --> 00:24:08,990
it updates the device storm so it

00:24:03,470 --> 00:24:11,510
basically creates an entry in the LM DB

00:24:08,990 --> 00:24:15,080
database for low-level discovery

00:24:11,510 --> 00:24:16,790
it will also determine this process will

00:24:15,080 --> 00:24:20,270
also determine when a device for example

00:24:16,790 --> 00:24:22,430
goes dead it will remove the entry it

00:24:20,270 --> 00:24:25,400
will as soon as it updates the entry it

00:24:22,430 --> 00:24:27,110
updates also time to live a time to live

00:24:25,400 --> 00:24:29,960
is automatically decremented later on

00:24:27,110 --> 00:24:32,090
and we what we also store in the

00:24:29,960 --> 00:24:34,340
database our device details which can be

00:24:32,090 --> 00:24:36,920
picked up for example by our own tracks

00:24:34,340 --> 00:24:39,920
underscore Val function to determine

00:24:36,920 --> 00:24:42,200
velocity or specific other data that we

00:24:39,920 --> 00:24:44,030
want monitored I'm just showing you the

00:24:42,200 --> 00:24:44,480
velocity here to keep it to keep it

00:24:44,030 --> 00:24:47,840
simple

00:24:44,480 --> 00:24:49,070
the this actual process is about one

00:24:47,840 --> 00:24:53,150
hundred hundred and twenty lines of

00:24:49,070 --> 00:24:56,030
Python so it's relatively trivial so how

00:24:53,150 --> 00:24:58,340
do we use an MDB and why did we use LM

00:24:56,030 --> 00:25:01,760
DB we use it because we are in process

00:24:58,340 --> 00:25:04,520
we would need to subscribe otherwise

00:25:01,760 --> 00:25:07,430
from multiple agents it would be

00:25:04,520 --> 00:25:09,980
difficult to determine which agent has

00:25:07,430 --> 00:25:12,560
got which value and what we have here is

00:25:09,980 --> 00:25:14,600
with LM DB we have a single writer that

00:25:12,560 --> 00:25:16,880
is the process and we have multiple

00:25:14,600 --> 00:25:21,080
readers those are the agents so perfect

00:25:16,880 --> 00:25:23,000
for us no additional moving parts so we

00:25:21,080 --> 00:25:27,020
keep things as simple as possible and

00:25:23,000 --> 00:25:30,620
for and we are very weary of moving

00:25:27,020 --> 00:25:34,100
parts moving parts always cause movement

00:25:30,620 --> 00:25:35,780
and in LM DB we have multiple language

00:25:34,100 --> 00:25:41,060
bindings so we can for example write

00:25:35,780 --> 00:25:43,640
from Python a read from C and the actual

00:25:41,060 --> 00:25:47,480
data the actual payload that is in the

00:25:43,640 --> 00:25:49,610
database looks like this we have a a

00:25:47,480 --> 00:25:52,160
device which is sent out with an e my

00:25:49,610 --> 00:25:53,390
number and we have a JSON payload which

00:25:52,160 --> 00:25:56,050
are formatted here so as you can see

00:25:53,390 --> 00:26:01,660
what it looks like this is the original

00:25:56,050 --> 00:26:01,660
payload format that we also use on the

00:26:01,980 --> 00:26:07,350
apps so we have Jason with a location

00:26:04,590 --> 00:26:10,830
type we have a timestamp latitude

00:26:07,350 --> 00:26:14,100
longitude course over ground altitude

00:26:10,830 --> 00:26:17,399
velocity a so-called tracker ID battery

00:26:14,100 --> 00:26:22,159
level and an additional name in the

00:26:17,399 --> 00:26:22,159
particular case of a vehicle these are

00:26:22,610 --> 00:26:28,139
usually if the customer wants it so the

00:26:25,769 --> 00:26:29,940
license plates of the other vehicles

00:26:28,139 --> 00:26:33,539
which for the customers normally

00:26:29,940 --> 00:26:36,500
something that is that defines what it

00:26:33,539 --> 00:26:39,389
is and this payload has been meanwhile

00:26:36,500 --> 00:26:41,549
adopted by quite a number of open-source

00:26:39,389 --> 00:26:44,490
projects for example home assistant

00:26:41,549 --> 00:26:47,789
openhab supports J our own tracks

00:26:44,490 --> 00:26:50,789
payload etc so this is the payload that

00:26:47,789 --> 00:26:53,630
then is entered into the database and

00:26:50,789 --> 00:26:59,909
then we go and define the so-called

00:26:53,630 --> 00:27:03,149
low-level discovery in zabbix and upon

00:26:59,909 --> 00:27:05,760
defining low-level discovery rules we

00:27:03,149 --> 00:27:09,570
can then later on create item prototypes

00:27:05,760 --> 00:27:12,750
and we can create graphs for example we

00:27:09,570 --> 00:27:15,389
can create triggers here is a trapper

00:27:12,750 --> 00:27:18,000
item as an example we have a trapper

00:27:15,389 --> 00:27:19,860
item which we create zabbix type trapper

00:27:18,000 --> 00:27:21,750
kin name my item will show you a

00:27:19,860 --> 00:27:25,230
different one in a moment and we can

00:27:21,750 --> 00:27:28,230
send out to that server this item name

00:27:25,230 --> 00:27:32,220
that is that item and the data that we

00:27:28,230 --> 00:27:38,669
send out is a JSON blob so Jason is an

00:27:32,220 --> 00:27:42,419
array of an array of JSON objects with

00:27:38,669 --> 00:27:45,090
macros this thing here in braces brace

00:27:42,419 --> 00:27:47,940
open hash brace close brace open hash

00:27:45,090 --> 00:27:52,320
brace close inside there is a macro name

00:27:47,940 --> 00:27:55,950
and what we have called it is simply ot

00:27:52,320 --> 00:27:57,419
ot for contracts and then we do the mi

00:27:55,950 --> 00:27:59,519
number that's the International Mobile

00:27:57,419 --> 00:28:02,130
Equipment identifier that's the unique

00:27:59,519 --> 00:28:05,370
number of the GPS tracker and for

00:28:02,130 --> 00:28:09,149
example the plate the license plate okay

00:28:05,370 --> 00:28:11,390
so this data that goes into zabbix will

00:28:09,149 --> 00:28:15,760
automatically create

00:28:11,390 --> 00:28:18,020
an item discovery item for this item

00:28:15,760 --> 00:28:22,520
with the e my number zero one two three

00:28:18,020 --> 00:28:24,230
four five or whatever so this JSON

00:28:22,520 --> 00:28:26,870
format that is something that has been

00:28:24,230 --> 00:28:28,370
defined by is Alex and the only thing we

00:28:26,870 --> 00:28:31,190
have to do is to adhere to it we can

00:28:28,370 --> 00:28:33,080
send in any number of markers with any

00:28:31,190 --> 00:28:37,940
number of values and these macro values

00:28:33,080 --> 00:28:40,040
we'll see in a moment we we get back so

00:28:37,940 --> 00:28:45,500
this JSON format we can also of course

00:28:40,040 --> 00:28:48,110
provide for from our loadable module and

00:28:45,500 --> 00:28:51,920
that is what this function does you

00:28:48,110 --> 00:28:54,590
recall we had that defined antrax dot

00:28:51,920 --> 00:28:58,850
contracts underscore ll D is the

00:28:54,590 --> 00:29:01,520
function name and what we do here make

00:28:58,850 --> 00:29:04,610
it simple what we do here is basically

00:29:01,520 --> 00:29:07,370
create let me just go back a second what

00:29:04,610 --> 00:29:11,750
we do is create this data structure this

00:29:07,370 --> 00:29:13,910
JSON data structure from all devices in

00:29:11,750 --> 00:29:17,390
the database so we would create an array

00:29:13,910 --> 00:29:20,360
of objects of JSON objects which contain

00:29:17,390 --> 00:29:25,340
OTE my and ot plate number for each of

00:29:20,360 --> 00:29:31,010
the devices that we have seen we return

00:29:25,340 --> 00:29:33,410
a copy of that and exotics will then

00:29:31,010 --> 00:29:35,660
consume it so we have a discovery rule

00:29:33,410 --> 00:29:38,030
here that makes agent running on the

00:29:35,660 --> 00:29:40,070
zabbix agent the key that we're reading

00:29:38,030 --> 00:29:42,770
is on tracks not allow LTE which will

00:29:40,070 --> 00:29:45,380
expand into this function so that's

00:29:42,770 --> 00:29:47,870
where the data is coming from zabbix is

00:29:45,380 --> 00:29:50,330
going to read this every 120 seconds

00:29:47,870 --> 00:29:52,600
that's what we've different so every 120

00:29:50,330 --> 00:29:55,580
seconds is going to invoke that function

00:29:52,600 --> 00:29:57,980
that function is going to produce Jason

00:29:55,580 --> 00:30:00,350
that Jason is read by zabbix and grab as

00:29:57,980 --> 00:30:02,630
alex is then going to from that create

00:30:00,350 --> 00:30:03,920
with prototypes going to create triggers

00:30:02,630 --> 00:30:07,280
for example is going to create items

00:30:03,920 --> 00:30:10,310
going to create graphs a marvelous

00:30:07,280 --> 00:30:13,910
feature of zabbix is we can say keep

00:30:10,310 --> 00:30:16,790
lost resources period and it's set here

00:30:13,910 --> 00:30:21,210
to 3600 and that means the following if

00:30:16,790 --> 00:30:28,710
our low-level discovery rule

00:30:21,210 --> 00:30:31,740
level discovery item no longer for 3600

00:30:28,710 --> 00:30:33,780
seconds no longer provides a particular

00:30:31,740 --> 00:30:36,000
entry for example for a vehicle which

00:30:33,780 --> 00:30:38,580
doesn't exist anymore then sabich's will

00:30:36,000 --> 00:30:42,720
automatically expire that and remove

00:30:38,580 --> 00:30:45,420
that entry from its database and from

00:30:42,720 --> 00:30:48,210
from its interface and from its from its

00:30:45,420 --> 00:30:51,150
database so that's a really very nice

00:30:48,210 --> 00:30:53,700
very nice feature what we then do is

00:30:51,150 --> 00:30:56,100
create item prototypes here key on

00:30:53,700 --> 00:30:57,900
tracks not valve velocity that was that

00:30:56,100 --> 00:31:02,040
key that we created and we passed the E

00:30:57,900 --> 00:31:04,920
minor okay we call please that this data

00:31:02,040 --> 00:31:07,590
comes from here so we are using this

00:31:04,920 --> 00:31:10,290
macro OT dot e mice or later on on the

00:31:07,590 --> 00:31:12,270
user interface we can see this

00:31:10,290 --> 00:31:16,260
Emine number and then of course the the

00:31:12,270 --> 00:31:18,380
plate number and the name of the the

00:31:16,260 --> 00:31:23,280
name of the entry or the name of the

00:31:18,380 --> 00:31:25,740
type is e my dollar one that is that

00:31:23,280 --> 00:31:27,150
number and we see here the plate number

00:31:25,740 --> 00:31:30,930
I'll show you in a moment what that

00:31:27,150 --> 00:31:33,690
looks like we can create trigger

00:31:30,930 --> 00:31:35,100
prototypes for example here's a trivial

00:31:33,690 --> 00:31:37,530
little example where I send out a

00:31:35,100 --> 00:31:38,580
warning if here's the rule it's very

00:31:37,530 --> 00:31:41,250
hard to read there that's why here

00:31:38,580 --> 00:31:43,770
larger if antrax velocity for a

00:31:41,250 --> 00:31:46,590
particular email number the last

00:31:43,770 --> 00:31:48,390
velocity gleaned is greater than 90 km/h

00:31:46,590 --> 00:31:50,940
we send the velocity in kilometers per

00:31:48,390 --> 00:31:54,210
hour then we would alert we would

00:31:50,940 --> 00:31:57,090
trigger on that okay and this of course

00:31:54,210 --> 00:32:00,810
results in a warning for example speed

00:31:57,090 --> 00:32:04,230
of license plate 729 3fq probably looks

00:32:00,810 --> 00:32:11,670
looks such speed of that vehicle is

00:32:04,230 --> 00:32:14,870
greater than 90 km/h so low-level

00:32:11,670 --> 00:32:18,690
discovery in action after a few minutes

00:32:14,870 --> 00:32:21,660
our functions have produced low-level

00:32:18,690 --> 00:32:23,730
discovery data which zabbix has consumed

00:32:21,660 --> 00:32:27,000
in the it automatically creates the

00:32:23,730 --> 00:32:29,790
zabbix prototypes and we see here the

00:32:27,000 --> 00:32:31,620
individual devices in my with that

00:32:29,790 --> 00:32:33,420
number and that plate in mind

00:32:31,620 --> 00:32:36,270
on that plate and cetera see all these

00:32:33,420 --> 00:32:38,970
devices that show up in the user

00:32:36,270 --> 00:32:42,000
interface and are being fed by the

00:32:38,970 --> 00:32:44,610
zabbix agent or by a zabbix agent or by

00:32:42,000 --> 00:32:47,790
a number of zabbix agents and recall

00:32:44,610 --> 00:32:53,190
these agents are reading the database

00:32:47,790 --> 00:32:55,500
from a or by a dynamically loaded module

00:32:53,190 --> 00:32:57,900
within zabbix and this is really a very

00:32:55,500 --> 00:33:01,470
fine very fast and very efficient

00:32:57,900 --> 00:33:03,300
mechanism of doing this much much more

00:33:01,470 --> 00:33:06,679
efficient than if we started working and

00:33:03,300 --> 00:33:09,480
creating external processes to do this

00:33:06,679 --> 00:33:11,250
what we will then see if you look at

00:33:09,480 --> 00:33:15,450
latest data for example we see the

00:33:11,250 --> 00:33:17,700
individual devices and for example the

00:33:15,450 --> 00:33:20,040
last speeds yeah the graphing is

00:33:17,700 --> 00:33:22,020
automatically handled by zabbix etc we

00:33:20,040 --> 00:33:26,460
don't do anything there so he says that

00:33:22,020 --> 00:33:28,380
for us here's an example of a device

00:33:26,460 --> 00:33:31,920
this number which I couldn't read here

00:33:28,380 --> 00:33:33,600
doesn't matter has reported an error and

00:33:31,920 --> 00:33:35,730
a warning and if we look at that warning

00:33:33,600 --> 00:33:37,920
the item is not discovered anymore and

00:33:35,730 --> 00:33:41,390
will be deleted in 57 minutes and 45

00:33:37,920 --> 00:33:44,220
seconds okay so during the last run

00:33:41,390 --> 00:33:46,920
zabbix got the low-level discovery data

00:33:44,220 --> 00:33:52,679
from that Jason that we produced however

00:33:46,920 --> 00:33:55,620
the element for this mi number there

00:33:52,679 --> 00:33:58,710
four five six or something transient was

00:33:55,620 --> 00:34:00,570
no longer in the data set so that makes

00:33:58,710 --> 00:34:04,080
it's warning us and it will

00:34:00,570 --> 00:34:07,140
automatically expire this item and all

00:34:04,080 --> 00:34:09,480
its data after in this case thirty seven

00:34:07,140 --> 00:34:12,720
minutes which for us is excellent

00:34:09,480 --> 00:34:14,970
because we have devices that that come

00:34:12,720 --> 00:34:17,070
and go for example if the device goes

00:34:14,970 --> 00:34:18,690
offline for a longer period of time then

00:34:17,070 --> 00:34:21,210
we don't want to be alerted for it it

00:34:18,690 --> 00:34:26,010
should just sort of disappear yeah or if

00:34:21,210 --> 00:34:28,379
a customer decides to trash or to be up

00:34:26,010 --> 00:34:29,909
to replace the device then we don't have

00:34:28,379 --> 00:34:32,040
to we don't have to manage it manually

00:34:29,909 --> 00:34:35,760
it is managed so to speak

00:34:32,040 --> 00:34:39,960
automatically graph prototypes in the

00:34:35,760 --> 00:34:42,149
discovery system also enable us to

00:34:39,960 --> 00:34:43,320
create graphs automatically we just

00:34:42,149 --> 00:34:45,090
create a prototype

00:34:43,320 --> 00:34:47,340
and zabbix will automatically start

00:34:45,090 --> 00:34:49,980
feeding these graphs as soon as new

00:34:47,340 --> 00:34:56,580
devices show up so this also for us is

00:34:49,980 --> 00:35:11,880
something that is hugely useful and

00:34:56,580 --> 00:35:16,770
she's a hugely practical so what we have

00:35:11,880 --> 00:35:18,390
now seen so far is a low CC module with

00:35:16,770 --> 00:35:23,360
a number of functions one of these

00:35:18,390 --> 00:35:26,820
functions has produced a JSON array with

00:35:23,360 --> 00:35:30,060
with data elements which zabbix consumes

00:35:26,820 --> 00:35:31,980
and after consuming it then starts going

00:35:30,060 --> 00:35:34,590
out and queries our same loadable

00:35:31,980 --> 00:35:37,650
modules for the actual data that it's

00:35:34,590 --> 00:35:39,360
going to use in for example in creating

00:35:37,650 --> 00:35:43,290
prototypes and creating graphs and

00:35:39,360 --> 00:35:46,350
creating data what is also interesting

00:35:43,290 --> 00:35:49,710
is what we can do I wouldn't recommend

00:35:46,350 --> 00:35:53,580
it but what we can do is history export

00:35:49,710 --> 00:35:56,850
also via AC function in our lower level

00:35:53,580 --> 00:35:59,520
module this functions only lower this

00:35:56,850 --> 00:36:01,470
only works if the module is loaded on

00:35:59,520 --> 00:36:05,370
the server does not work if it's loaded

00:36:01,470 --> 00:36:08,000
on the agent it is quite complicated and

00:36:05,370 --> 00:36:13,560
not to say very complicated it is rather

00:36:08,000 --> 00:36:15,810
badly documented probably or possibly I

00:36:13,560 --> 00:36:17,510
don't know but possibly because almost

00:36:15,810 --> 00:36:20,760
never uses it

00:36:17,510 --> 00:36:23,550
it's invoked at server start and then

00:36:20,760 --> 00:36:26,310
periodically for example documentation

00:36:23,550 --> 00:36:28,880
it is not exactly specified when it is

00:36:26,310 --> 00:36:32,850
invoked it is just periodically invoked

00:36:28,880 --> 00:36:37,200
and the good thing about history export

00:36:32,850 --> 00:36:40,730
is we can replace it by the so-called

00:36:37,200 --> 00:36:43,440
real-time export into JSON files which

00:36:40,730 --> 00:36:46,980
zabbix already supports so let me just

00:36:43,440 --> 00:36:49,200
show you a very very small excerpt as

00:36:46,980 --> 00:36:52,100
you see it's incomplete here very very

00:36:49,200 --> 00:36:52,100
small excerpt of

00:36:52,300 --> 00:36:58,210
is function module history right

00:36:54,670 --> 00:37:00,700
callbacks where we define which fields

00:36:58,210 --> 00:37:02,350
we want to actually write we have to say

00:37:00,700 --> 00:37:05,890
I've got an integer and I've got a

00:37:02,350 --> 00:37:08,080
string we need for the individual

00:37:05,890 --> 00:37:10,330
integers we have to go through from zero

00:37:08,080 --> 00:37:14,070
to history count we sort of work through

00:37:10,330 --> 00:37:17,050
zabbix internal history information

00:37:14,070 --> 00:37:19,630
which defines how many values it

00:37:17,050 --> 00:37:21,280
actually has this is this is very very

00:37:19,630 --> 00:37:25,000
error-prone and I would really not

00:37:21,280 --> 00:37:27,580
recommend you do it instead there's a

00:37:25,000 --> 00:37:29,980
functionality called history export real

00:37:27,580 --> 00:37:32,860
time history export which writes out

00:37:29,980 --> 00:37:35,080
into JSON files it will rotate these

00:37:32,860 --> 00:37:37,530
JSON files also and then we just have

00:37:35,080 --> 00:37:40,180
Jason which can reproduce which can be

00:37:37,530 --> 00:37:43,210
processed with any jason capable tool

00:37:40,180 --> 00:37:45,550
you can look at it with JQ or handle it

00:37:43,210 --> 00:37:49,740
with python i would see or whatever you

00:37:45,550 --> 00:37:52,390
you like so here we have an example that

00:37:49,740 --> 00:37:55,330
that field we had earlier as really dot

00:37:52,390 --> 00:37:58,390
CN was one of our external parameters or

00:37:55,330 --> 00:38:00,910
user parameters rather we have a clock

00:37:58,390 --> 00:38:04,150
that's the epoch timestamp the unix

00:38:00,910 --> 00:38:05,800
epoch timestamp and the actual value and

00:38:04,150 --> 00:38:08,740
here for example we have an application

00:38:05,800 --> 00:38:11,050
file systems and the item ID that's the

00:38:08,740 --> 00:38:13,420
item in within the zabbix interface so

00:38:11,050 --> 00:38:18,820
we will get everything all the values

00:38:13,420 --> 00:38:20,950
all of all the settings ok so that is

00:38:18,820 --> 00:38:25,560
history export when if you want bulk and

00:38:20,950 --> 00:38:30,100
real time export of the zabbix data

00:38:25,560 --> 00:38:31,060
right I'm almost done because I'm on I'm

00:38:30,100 --> 00:38:33,670
the only thing that's standing between

00:38:31,060 --> 00:38:37,960
you or us and I think the beer

00:38:33,670 --> 00:38:42,220
so I'll get it going if you care to look

00:38:37,960 --> 00:38:43,750
at this more closely it's this is

00:38:42,220 --> 00:38:46,300
basically what needs to be done a

00:38:43,750 --> 00:38:48,820
low-level recipe if you like you write

00:38:46,300 --> 00:38:51,550
and compile and of course test your C

00:38:48,820 --> 00:38:53,500
code into a module you edit a

00:38:51,550 --> 00:38:55,780
configuration you specify that the

00:38:53,500 --> 00:38:57,970
module is to be loaded you restart the

00:38:55,780 --> 00:39:01,060
agent to server on the proxy depending

00:38:57,970 --> 00:39:03,820
on where you want this module loaded you

00:39:01,060 --> 00:39:05,380
create your items and that extent goes

00:39:03,820 --> 00:39:12,700
out get that data

00:39:05,380 --> 00:39:17,200
and uses it it is quite difficult to

00:39:12,700 --> 00:39:18,490
crash a server so it's not really not

00:39:17,200 --> 00:39:22,660
something that will happen very quickly

00:39:18,490 --> 00:39:24,910
very easily and of course you might also

00:39:22,660 --> 00:39:28,960
ask why should I do this

00:39:24,910 --> 00:39:30,400
in my opinion C functions are extremely

00:39:28,960 --> 00:39:32,350
fast it's the fastest

00:39:30,400 --> 00:39:35,530
currently the fastest mechanism to get

00:39:32,350 --> 00:39:37,540
external data unless you're writing into

00:39:35,530 --> 00:39:39,640
it unless you have proper items and C

00:39:37,540 --> 00:39:43,990
functions are very fast a low-level

00:39:39,640 --> 00:39:45,940
discovery is highly flexible we talked

00:39:43,990 --> 00:39:48,040
shortly about the fact that zabbix

00:39:45,940 --> 00:39:49,600
internally uses low-level discovery for

00:39:48,040 --> 00:39:52,750
example for file systems or network

00:39:49,600 --> 00:39:54,700
interfaces and I hope I've Illustrated

00:39:52,750 --> 00:39:56,620
how we can use lower-level discovery

00:39:54,700 --> 00:40:00,760
basically to discover anything yeah to

00:39:56,620 --> 00:40:03,520
discover anything Dimitri was saying

00:40:00,760 --> 00:40:05,140
earlier that he was using something like

00:40:03,520 --> 00:40:10,630
a trapper item for example to cut the

00:40:05,140 --> 00:40:14,060
the data the obd data into into sabich's

00:40:10,630 --> 00:40:15,480
this would also be a possibility okay

00:40:14,060 --> 00:40:17,740
[Music]

00:40:15,480 --> 00:40:21,130
not only a possibility but a highly

00:40:17,740 --> 00:40:24,130
efficient possibility so together this

00:40:21,130 --> 00:40:28,450
is a very powerful combination and in

00:40:24,130 --> 00:40:31,210
addition to the zabbix API which it says

00:40:28,450 --> 00:40:34,090
for example create items or graphs or

00:40:31,210 --> 00:40:36,700
whatever from outside this is really

00:40:34,090 --> 00:40:41,320
very very nice thing unfortunately this

00:40:36,700 --> 00:40:43,960
API has no support for logging and no

00:40:41,320 --> 00:40:46,480
support for reading zabbix conf so it

00:40:43,960 --> 00:40:49,390
would be very nice to be able to have

00:40:46,480 --> 00:40:51,820
own configuration parameters for

00:40:49,390 --> 00:40:53,650
whatever functions we have would be nice

00:40:51,820 --> 00:40:56,050
to have them in the same zabbix not

00:40:53,650 --> 00:40:57,910
confuse we feel which we possibly deploy

00:40:56,050 --> 00:41:01,390
automatically etc but there is

00:40:57,910 --> 00:41:04,840
unfortunately no specific API to read

00:41:01,390 --> 00:41:07,890
that there's also no logging API so your

00:41:04,840 --> 00:41:10,240
C module would maybe use syslog or

00:41:07,890 --> 00:41:14,980
static files or something like that or

00:41:10,240 --> 00:41:19,069
IPC whatever to get rid of to get rid of

00:41:14,980 --> 00:41:23,309
dog logs or to to produce logging

00:41:19,069 --> 00:41:25,770
documentation is slight but it's

00:41:23,309 --> 00:41:28,020
readable and there are a number of

00:41:25,770 --> 00:41:31,710
examples and you could use this as an

00:41:28,020 --> 00:41:36,690
example to get started and yeah that's

00:41:31,710 --> 00:41:47,480
about it thank you

00:41:36,690 --> 00:41:47,480
[Music]

00:41:50,520 --> 00:41:53,849
you

00:41:51,070 --> 00:41:53,849

YouTube URL: https://www.youtube.com/watch?v=i8oGWT4CoUM


