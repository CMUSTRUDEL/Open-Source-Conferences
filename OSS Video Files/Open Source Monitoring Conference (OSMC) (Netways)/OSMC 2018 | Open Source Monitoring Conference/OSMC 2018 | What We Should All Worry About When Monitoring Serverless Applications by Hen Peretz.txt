Title: OSMC 2018 | What We Should All Worry About When Monitoring Serverless Applications by Hen Peretz
Publication date: 2018-11-17
Playlist: OSMC 2018 | Open Source Monitoring Conference
Description: 
	Worried about problems or performance issues in your user experience? Discover the metrics that are critical when monitoring your serverless applications. A serverless expert will take you through the evolution of application architectures and their monitoring challenges. Participants will learn how to better monitor and troubleshoot issues and better understand how the events in their serverless applications are connected. This session is helpful for people who have a basic understanding of serverless environments as well as seasoned serverless developers.
The fine folks will get a short and accurate review of the evolution that happened regarding infrastructure and the way we develop software; I will guide and enlight them on the acute troubleshooting and operations problems that they experience every day while showing them how it SHOULD be. In addition, I will present some available solutions to overcome these issues.


NETWAYS
Konferenzen: https://www.netways.de/events
Schulungen: https://www.netways.de/schulungen
Shop: https://shop.netways.de/
Blog: http://blog.netways.de/
NWS: https://nws.netways.de

Webinare
Archiv Link: https://www.netways.de/webinare/archi...
Aktuell: https://www.netways.de/wb

Social Media
SlideShare: http://de.slideshare.net/netways
YouTube: https://www.netways.de/youtube
Facebook: https://www.facebook.com/netways
Twitter: https://twitter.com/netways
Instagram: https://www.instagram.com/netwaysgmbh/

www.musicfox.com
Captions: 
	00:00:01,940 --> 00:00:13,650
[Music]

00:00:12,320 --> 00:00:17,970
thank you

00:00:13,650 --> 00:00:21,529
Thank You Marcus so everybody I'm Ken

00:00:17,970 --> 00:00:26,250
I'm from Epsilon and I'm very excited

00:00:21,529 --> 00:00:29,340
first time that I speak in Scarface so

00:00:26,250 --> 00:00:30,810
today I'm going to talk about what we

00:00:29,340 --> 00:00:35,610
should all worried about when monitoring

00:00:30,810 --> 00:00:38,100
service applications and what I'm going

00:00:35,610 --> 00:00:41,719
to go through this talk is about the

00:00:38,100 --> 00:00:44,550
evolution that the software is made to

00:00:41,719 --> 00:00:46,050
till we get to service and how it

00:00:44,550 --> 00:00:49,260
effects our monitoring and what we shall

00:00:46,050 --> 00:00:54,660
pay attention by res event anyone here

00:00:49,260 --> 00:00:59,730
heard the word service and who is using

00:00:54,660 --> 00:01:04,439
several this here yeah so a little bit

00:00:59,730 --> 00:01:05,880
about myself I'm Han with Asha and don't

00:01:04,439 --> 00:01:09,150
try to pronounce it with their hand

00:01:05,880 --> 00:01:11,700
because it's chicken and that's all

00:01:09,150 --> 00:01:14,400
you're gonna remember for nee now I'm a

00:01:11,700 --> 00:01:18,150
senior engineer at depths are gone I in

00:01:14,400 --> 00:01:20,310
the last year I developed a distributed

00:01:18,150 --> 00:01:22,710
racing engine this is what we do in UPS

00:01:20,310 --> 00:01:26,159
agon and we develop a monitoring

00:01:22,710 --> 00:01:30,450
solution for service I mainly in my past

00:01:26,159 --> 00:01:33,210
did a lot of R&D companies from finance

00:01:30,450 --> 00:01:34,110
to industrial robots I can allow that

00:01:33,210 --> 00:01:36,630
later if you want

00:01:34,110 --> 00:01:40,650
in the intelligence forces of the idea

00:01:36,630 --> 00:01:43,290
if I did the mainly embedded and most

00:01:40,650 --> 00:01:46,939
exciting news on fresh dad I have a

00:01:43,290 --> 00:01:49,770
newborn daughter a two-month year old

00:01:46,939 --> 00:01:52,510
she's gonna see this lecture so maybe

00:01:49,770 --> 00:01:57,490
you can applaud to her

00:01:52,510 --> 00:01:59,950
she's also a symbolist fan and now from

00:01:57,490 --> 00:02:04,480
tel-aviv okay so now that we got past

00:01:59,950 --> 00:02:07,270
that let's continue so I'm sure you saw

00:02:04,480 --> 00:02:11,380
this like ten thousand times in the past

00:02:07,270 --> 00:02:13,780
few days what I want to take from this

00:02:11,380 --> 00:02:16,840
is to explain why do we even need

00:02:13,780 --> 00:02:19,390
monitoring so for me the first thing we

00:02:16,840 --> 00:02:21,730
need is to track our system health want

00:02:19,390 --> 00:02:25,360
to be able that everything is up that we

00:02:21,730 --> 00:02:27,700
can handle the load that we can notice

00:02:25,360 --> 00:02:29,440
any errors if they occur and once they

00:02:27,700 --> 00:02:33,040
occur we want to be able to troubleshoot

00:02:29,440 --> 00:02:34,240
and to fix them and we want to do it as

00:02:33,040 --> 00:02:36,880
fast as we can because that's probably

00:02:34,240 --> 00:02:39,100
can happen 4:00 a.m. when your baby is

00:02:36,880 --> 00:02:41,440
crying it's a good excuse to get up the

00:02:39,100 --> 00:02:42,970
room and leave that to your wife but you

00:02:41,440 --> 00:02:45,910
really want to fix that fast in order to

00:02:42,970 --> 00:02:48,370
you can do other stuff and the last

00:02:45,910 --> 00:02:51,930
thing when the morning can help us is to

00:02:48,370 --> 00:02:54,790
be able to optimize our performance and

00:02:51,930 --> 00:02:55,959
optimize our cost and our cost is

00:02:54,790 --> 00:02:58,890
something that is very crucial in

00:02:55,959 --> 00:03:02,020
service and I get back to that later so

00:02:58,890 --> 00:03:04,030
monitoring hasn't really changed the

00:03:02,020 --> 00:03:06,520
need for monitoring hasn't really

00:03:04,030 --> 00:03:08,800
changed in the past years what's changed

00:03:06,520 --> 00:03:12,880
is the the way we developed software we

00:03:08,800 --> 00:03:15,940
used to write code in a monolithic way

00:03:12,880 --> 00:03:20,739
which we had took all our features and

00:03:15,940 --> 00:03:23,170
all and all our business logic and we

00:03:20,739 --> 00:03:26,260
put them all in one place and work for

00:03:23,170 --> 00:03:28,300
us we can just put it in it will work we

00:03:26,260 --> 00:03:30,250
would love it we had multi processes it

00:03:28,300 --> 00:03:32,140
worked fine but as we start to become

00:03:30,250 --> 00:03:35,260
more modern we realized I think we need

00:03:32,140 --> 00:03:40,209
to scale we to come to a much bigger

00:03:35,260 --> 00:03:42,430
crowd so this turned us to take that

00:03:40,209 --> 00:03:45,160
monolithic application and split it in

00:03:42,430 --> 00:03:48,760
two into pieces and those pieces we call

00:03:45,160 --> 00:03:50,440
them micro services and what happened

00:03:48,760 --> 00:03:52,750
with micro services is fascinating

00:03:50,440 --> 00:03:54,670
because it first starts to change the

00:03:52,750 --> 00:03:56,380
way we monitor things we now need to

00:03:54,670 --> 00:04:00,760
monitor things that are more distributed

00:03:56,380 --> 00:04:03,519
and let's get back on the main topic of

00:04:00,760 --> 00:04:06,410
MU which is service so service is

00:04:03,519 --> 00:04:10,600
actually to simplify it it's

00:04:06,410 --> 00:04:13,610
a specific use case of microservices and

00:04:10,600 --> 00:04:16,310
I want us to to talk about that for a

00:04:13,610 --> 00:04:18,110
bit so what do you think when you hear

00:04:16,310 --> 00:04:21,190
about several s so you think there are

00:04:18,110 --> 00:04:24,260
no servers right and that everything

00:04:21,190 --> 00:04:27,500
magically happens and it's almost

00:04:24,260 --> 00:04:29,330
entirely true we take that micro service

00:04:27,500 --> 00:04:31,850
that you originally split it from a

00:04:29,330 --> 00:04:34,660
monolithic application and you split it

00:04:31,850 --> 00:04:37,880
to even much more greater pieces and

00:04:34,660 --> 00:04:40,790
that tiny pieces you can just deploy it

00:04:37,880 --> 00:04:42,440
to the amazing cloud and you can say

00:04:40,790 --> 00:04:45,440
that I want this piece of code to be

00:04:42,440 --> 00:04:48,350
triggered by a HTTP request for example

00:04:45,440 --> 00:04:50,480
and once that event will occur your code

00:04:48,350 --> 00:04:52,220
will execute and that is promised to you

00:04:50,480 --> 00:04:56,830
about many cloud providers like Google

00:04:52,220 --> 00:05:02,060
cloud functions as your IBM Amazon and

00:04:56,830 --> 00:05:04,600
these functions this ability to be able

00:05:02,060 --> 00:05:07,520
to not worry about infrastructure is

00:05:04,600 --> 00:05:08,000
what makes me think that service is so

00:05:07,520 --> 00:05:10,280
great

00:05:08,000 --> 00:05:13,000
and I'm not here to preach about service

00:05:10,280 --> 00:05:15,770
but let's I get through that don't worry

00:05:13,000 --> 00:05:18,470
go back to topic so I think service is

00:05:15,770 --> 00:05:21,290
great mainly I just loved I love using

00:05:18,470 --> 00:05:24,740
it because it made my the company that I

00:05:21,290 --> 00:05:28,190
work for to to iterate so much faster we

00:05:24,740 --> 00:05:31,910
can this excel accelerated us our

00:05:28,190 --> 00:05:34,750
development velocity it helped us not

00:05:31,910 --> 00:05:37,100
even thinking about all the scaling for

00:05:34,750 --> 00:05:38,840
it's not completely true but there are

00:05:37,100 --> 00:05:40,610
many parts that you can also scale it

00:05:38,840 --> 00:05:43,850
not interfere if you write a function

00:05:40,610 --> 00:05:46,100
you can if it runs one time of 1,000

00:05:43,850 --> 00:05:47,870
times you most of the times they don't

00:05:46,100 --> 00:05:50,620
need to do anything most of the times

00:05:47,870 --> 00:05:53,330
your external resources will handle that

00:05:50,620 --> 00:05:55,850
and the last thing that's so important

00:05:53,330 --> 00:05:58,790
of a service is that you only pay for

00:05:55,850 --> 00:06:02,919
for what you use this means that you no

00:05:58,790 --> 00:06:05,540
longer need to buy a server to handle a

00:06:02,919 --> 00:06:08,660
billion users if you want per month and

00:06:05,540 --> 00:06:10,520
you need to pay for that 24/7 you only

00:06:08,660 --> 00:06:12,770
pay for the amount of users that visited

00:06:10,520 --> 00:06:15,440
your website today which is an

00:06:12,770 --> 00:06:19,670
incredible incredible advantage for

00:06:15,440 --> 00:06:22,470
service so let's get back to topic

00:06:19,670 --> 00:06:25,530
what is so different when we monitor

00:06:22,470 --> 00:06:28,020
service application than any other type

00:06:25,530 --> 00:06:29,970
of application so I said the three

00:06:28,020 --> 00:06:32,700
things before I'm gonna try to tackle

00:06:29,970 --> 00:06:37,100
them one by one so the first thing is to

00:06:32,700 --> 00:06:37,100
be able to track our system health and

00:06:37,490 --> 00:06:43,890
when we think about it what is exactly

00:06:40,830 --> 00:06:46,200
our system we took that micro service we

00:06:43,890 --> 00:06:48,570
split it into pieces and now we want to

00:06:46,200 --> 00:06:53,130
be able to track them is tracking or

00:06:48,570 --> 00:06:55,080
functions enough and what we need to ask

00:06:53,130 --> 00:06:58,770
yourself is if the system really

00:06:55,080 --> 00:07:00,540
consists of our functions and what we

00:06:58,770 --> 00:07:06,120
think about that I want us to remember

00:07:00,540 --> 00:07:09,900
that we live in what I like to call the

00:07:06,120 --> 00:07:11,340
era of api's we got so hooked about the

00:07:09,900 --> 00:07:13,830
idea that we no longer need to worry

00:07:11,340 --> 00:07:14,250
about scale that we want to do it for

00:07:13,830 --> 00:07:18,540
everything

00:07:14,250 --> 00:07:20,100
I don't want if I'm using AWS for other

00:07:18,540 --> 00:07:24,150
ways lambda I don't want to worry about

00:07:20,100 --> 00:07:26,370
storage and maintain my own file storage

00:07:24,150 --> 00:07:29,220
I can just use the managed storage like

00:07:26,370 --> 00:07:31,890
s free or and no SQL DB like the animal

00:07:29,220 --> 00:07:34,229
DB and if I'm developing a software now

00:07:31,890 --> 00:07:36,150
and I want I'm getting users and I want

00:07:34,229 --> 00:07:38,310
them to start paying I don't want to

00:07:36,150 --> 00:07:40,290
come to my team and tell them okay let's

00:07:38,310 --> 00:07:42,630
stop working on our entire business

00:07:40,290 --> 00:07:45,060
logic and let's start thinking about

00:07:42,630 --> 00:07:48,120
payment that's going to be a bad idea

00:07:45,060 --> 00:07:50,910
right we got to get start to handle with

00:07:48,120 --> 00:07:52,650
rejections and all that kind of stuff

00:07:50,910 --> 00:07:55,770
that no one wants to mess with so I

00:07:52,650 --> 00:07:58,229
rather use stripe stripe is so easy they

00:07:55,770 --> 00:07:59,669
did it way better than us and now I can

00:07:58,229 --> 00:08:01,260
continue working on what I do and just

00:07:59,669 --> 00:08:04,979
write a small function that will handle

00:08:01,260 --> 00:08:06,900
the request so all of this shown by my

00:08:04,979 --> 00:08:09,950
my entire application to be highly

00:08:06,900 --> 00:08:16,229
distributed and highly event-driven and

00:08:09,950 --> 00:08:19,770
this eventually made me not have any

00:08:16,229 --> 00:08:21,240
access to any server so I let's still

00:08:19,770 --> 00:08:23,540
still think if our system is our

00:08:21,240 --> 00:08:26,130
function so I want us to think about

00:08:23,540 --> 00:08:28,500
when we look at this example this is the

00:08:26,130 --> 00:08:31,110
famous example not sure how many of you

00:08:28,500 --> 00:08:32,750
saw it already but this is an example of

00:08:31,110 --> 00:08:35,539
young Kui which is a

00:08:32,750 --> 00:08:37,640
famous bloggers very known in the

00:08:35,539 --> 00:08:40,909
service community and he took a

00:08:37,640 --> 00:08:42,560
monolithic application God knows why and

00:08:40,909 --> 00:08:44,180
turned that into fully service

00:08:42,560 --> 00:08:46,640
application you want to prove a point I

00:08:44,180 --> 00:08:48,260
want to prove that any almost any one

00:08:46,640 --> 00:08:50,180
monolithic application you can turn that

00:08:48,260 --> 00:08:52,760
into service and he also took the time

00:08:50,180 --> 00:08:54,260
to draw that architecture and when we

00:08:52,760 --> 00:08:56,600
think of our system this is a system

00:08:54,260 --> 00:08:59,270
service system if the if our system is

00:08:56,600 --> 00:09:02,150
only consist of functions then we

00:08:59,270 --> 00:09:05,000
probably only see those orange ones

00:09:02,150 --> 00:09:08,450
which is the SS lambda but we also see

00:09:05,000 --> 00:09:11,420
DynamoDB we see the API gateway which is

00:09:08,450 --> 00:09:14,570
the HTTP endpoint so this what comes to

00:09:11,420 --> 00:09:16,310
my final conclusion the system is not

00:09:14,570 --> 00:09:19,100
just our functions if you want to be

00:09:16,310 --> 00:09:21,230
able to track our system it's not enough

00:09:19,100 --> 00:09:23,780
to track only our functions mean it's

00:09:21,230 --> 00:09:26,990
also subtract our our api's and our

00:09:23,780 --> 00:09:29,840
resources because if stripe which did an

00:09:26,990 --> 00:09:33,530
amazing job is down it's not just drive

00:09:29,840 --> 00:09:37,580
problem it's also my problem and and now

00:09:33,530 --> 00:09:39,200
I want to continue to my next think my

00:09:37,580 --> 00:09:40,940
next topic is about troubleshoot and fix

00:09:39,200 --> 00:09:44,210
in an error when it occurs

00:09:40,940 --> 00:09:48,140
so why troubleshooting and fixing an

00:09:44,210 --> 00:09:50,330
error is so different in service so it's

00:09:48,140 --> 00:09:52,130
different because let's if we take a

00:09:50,330 --> 00:09:55,730
look another if you take a note and I'll

00:09:52,130 --> 00:09:57,350
look at on Anyang example we can clearly

00:09:55,730 --> 00:10:00,830
see that there's an error in this

00:09:57,350 --> 00:10:02,900
function so for those of you who already

00:10:00,830 --> 00:10:06,320
use service how we will you start

00:10:02,900 --> 00:10:10,580
investigating that if you there anyone

00:10:06,320 --> 00:10:12,170
wants to participate you have an error

00:10:10,580 --> 00:10:14,900
in this function and you want to get to

00:10:12,170 --> 00:10:16,550
the root cause okay I'll continue so

00:10:14,900 --> 00:10:18,560
what comes out of the box with the

00:10:16,550 --> 00:10:20,720
weather Muslims being able to look at

00:10:18,560 --> 00:10:22,460
the metrics and know when this happens

00:10:20,720 --> 00:10:24,440
so we can try to figure out when it

00:10:22,460 --> 00:10:28,280
happened and once it happen we can go

00:10:24,440 --> 00:10:30,170
through this exhausting list of logs of

00:10:28,280 --> 00:10:31,640
invocations and go through all them

00:10:30,170 --> 00:10:34,880
until we find that specific invocation

00:10:31,640 --> 00:10:37,190
and once we do that we already we we can

00:10:34,880 --> 00:10:39,410
try find a specific log file that

00:10:37,190 --> 00:10:42,140
contained the error but will that alone

00:10:39,410 --> 00:10:44,750
help me get to the root cause so the

00:10:42,140 --> 00:10:46,670
answer is absolutely not because it's

00:10:44,750 --> 00:10:48,890
not enough for us just to track us

00:10:46,670 --> 00:10:51,050
cific function this function is a part

00:10:48,890 --> 00:10:55,280
of a whole application this was probably

00:10:51,050 --> 00:10:57,110
triggered by malformed function free

00:10:55,280 --> 00:11:00,260
hops away and we need to have the

00:10:57,110 --> 00:11:02,090
ability to track this so tracking

00:11:00,260 --> 00:11:03,710
functions in order to troubleshoot an

00:11:02,090 --> 00:11:06,430
error is not that it is not enough we

00:11:03,710 --> 00:11:09,110
need also to track uh synchronous events

00:11:06,430 --> 00:11:11,990
we need to be able to look at

00:11:09,110 --> 00:11:13,640
application in a form of system

00:11:11,990 --> 00:11:16,850
executions we need to look at them as

00:11:13,640 --> 00:11:19,130
full transactions and to end and if we

00:11:16,850 --> 00:11:21,650
take another look once more on the UH

00:11:19,130 --> 00:11:24,860
example we can see that there's many

00:11:21,650 --> 00:11:28,700
types I I drew it like a transaction or

00:11:24,860 --> 00:11:30,290
end-to-end process which is on this

00:11:28,700 --> 00:11:33,290
example and you can see there are some

00:11:30,290 --> 00:11:35,210
simple ones there's some one on the top

00:11:33,290 --> 00:11:37,190
left which is a with a revisiting node

00:11:35,210 --> 00:11:38,870
which is much more complex and we need

00:11:37,190 --> 00:11:42,290
to have the ability to to track all of

00:11:38,870 --> 00:11:45,110
these so what we need to do we need to

00:11:42,290 --> 00:11:47,840
start thinking about distributed tracing

00:11:45,110 --> 00:11:51,320
which is a topic that came a lot in this

00:11:47,840 --> 00:11:52,940
conference and it's a it's something

00:11:51,320 --> 00:11:57,010
that's very crucial to distributed

00:11:52,940 --> 00:12:00,380
systems not just cellular systems so

00:11:57,010 --> 00:12:03,620
like the line says a transaction is

00:12:00,380 --> 00:12:05,270
basically a story from one end to the

00:12:03,620 --> 00:12:07,580
other it tells us what happened in our

00:12:05,270 --> 00:12:09,770
system in in a certain point of time and

00:12:07,580 --> 00:12:12,200
if you want to be able to track this

00:12:09,770 --> 00:12:15,560
like look at this example we have a

00:12:12,200 --> 00:12:17,960
client with a load balancer with three

00:12:15,560 --> 00:12:21,050
types of services one is a resource API

00:12:17,960 --> 00:12:23,000
one is the billing RPC and one of the

00:12:21,050 --> 00:12:25,160
authentication service and if you want

00:12:23,000 --> 00:12:27,290
to be able to see what really happened

00:12:25,160 --> 00:12:30,320
here we need to be able to collect all

00:12:27,290 --> 00:12:33,080
of these events and and pack them

00:12:30,320 --> 00:12:36,470
together and maybe if you did our job

00:12:33,080 --> 00:12:38,750
right we can put it in there are many

00:12:36,470 --> 00:12:41,390
distributed traces engine not only UPS

00:12:38,750 --> 00:12:43,970
agon does it everyone do it right now uh

00:12:41,390 --> 00:12:45,920
so we have we have everyone did it way

00:12:43,970 --> 00:12:48,530
before and we have Yaeger

00:12:45,920 --> 00:12:50,510
which allows us to take these traces and

00:12:48,530 --> 00:12:55,430
view them in a timeline manner it allows

00:12:50,510 --> 00:12:59,090
us to be able to troubleshoot the error

00:12:55,430 --> 00:13:00,089
that happened right here and to know to

00:12:59,090 --> 00:13:02,249
know that okay

00:13:00,089 --> 00:13:04,139
so 15 milliseconds above something else

00:13:02,249 --> 00:13:05,939
up and then maybe that is related and

00:13:04,139 --> 00:13:08,009
maybe I can get to the root cousin

00:13:05,939 --> 00:13:15,170
really solve the problem not just patch

00:13:08,009 --> 00:13:18,649
it so this is another example of digital

00:13:15,170 --> 00:13:21,600
tracing we have your a block site that

00:13:18,649 --> 00:13:23,819
this is the chain of events so in the

00:13:21,600 --> 00:13:27,209
end we have your an error and if I'm

00:13:23,819 --> 00:13:28,889
able to to trace all of this and we'll

00:13:27,209 --> 00:13:33,089
be able to see all the errors right here

00:13:28,889 --> 00:13:35,399
I can go to that lambda and see what

00:13:33,089 --> 00:13:37,529
really made it to the crash which is

00:13:35,399 --> 00:13:41,519
division by zero which is pretty obvious

00:13:37,529 --> 00:13:43,110
what once once I see this this this tack

00:13:41,519 --> 00:13:45,420
trace it's not that enough to really see

00:13:43,110 --> 00:13:49,439
it because I want to know who triggered

00:13:45,420 --> 00:13:51,149
it and in this map it's very easy to

00:13:49,439 --> 00:13:53,040
understand we have a new post that is

00:13:51,149 --> 00:13:55,199
triggering a lambda which you try to

00:13:53,040 --> 00:13:57,899
authenticate the user and once it does

00:13:55,199 --> 00:13:59,850
that it sends a message to the SNS for

00:13:57,899 --> 00:14:03,899
those of you do not know it's a like a

00:13:59,850 --> 00:14:06,059
managed queue of of Amazon and once that

00:14:03,899 --> 00:14:08,370
message is is there it's also triggers

00:14:06,059 --> 00:14:09,629
the post analysis lambda and that one is

00:14:08,370 --> 00:14:11,309
the one that fails so if you want to

00:14:09,629 --> 00:14:13,589
really troubleshoot the issue we need to

00:14:11,309 --> 00:14:17,790
go back and see what happened in there

00:14:13,589 --> 00:14:19,920
in the notification and what what was

00:14:17,790 --> 00:14:22,350
the what was this function trying to do

00:14:19,920 --> 00:14:23,790
and we can see that it failed to

00:14:22,350 --> 00:14:25,860
authenticate the user this can give us a

00:14:23,790 --> 00:14:27,889
lead and with that we can be able to

00:14:25,860 --> 00:14:30,540
troubleshoot our R which is much faster

00:14:27,889 --> 00:14:32,999
so how do we start to implement

00:14:30,540 --> 00:14:36,029
distributed tracing so you heard a lot

00:14:32,999 --> 00:14:38,550
about open tracing which is the standard

00:14:36,029 --> 00:14:41,730
that defines us how a trace should look

00:14:38,550 --> 00:14:44,550
like and in in all kinds of languages so

00:14:41,730 --> 00:14:47,279
we can start doing manual tracing adding

00:14:44,550 --> 00:14:50,160
to each resource what we are doing to a

00:14:47,279 --> 00:14:51,990
get label it and this can work for a

00:14:50,160 --> 00:14:55,529
while especially in non service

00:14:51,990 --> 00:14:58,259
applications but in service this issues

00:14:55,529 --> 00:15:01,559
become much harder because we need to

00:14:58,259 --> 00:15:04,519
now maintain issues maintain what we are

00:15:01,559 --> 00:15:08,639
doing and and if we're going to do any

00:15:04,519 --> 00:15:10,889
any error in tracing we might when you

00:15:08,639 --> 00:15:12,760
try to troubleshoot we might get quite a

00:15:10,889 --> 00:15:15,399
few errors where and

00:15:12,760 --> 00:15:17,470
and our troubleshoot can go wrong and

00:15:15,399 --> 00:15:19,089
this can also lead like I said to a

00:15:17,470 --> 00:15:22,870
potential high potential averse because

00:15:19,089 --> 00:15:25,120
in service our complex system contains

00:15:22,870 --> 00:15:26,740
much more functions than the regular

00:15:25,120 --> 00:15:28,870
micro service we took the micro service

00:15:26,740 --> 00:15:31,839
and we broke it into pieces so each

00:15:28,870 --> 00:15:34,810
function there acts into certain events

00:15:31,839 --> 00:15:37,810
and if we need to continue and and

00:15:34,810 --> 00:15:41,139
maintaining this tracing feature for

00:15:37,810 --> 00:15:42,880
application developers we lose focus and

00:15:41,139 --> 00:15:44,649
will not focus on our main business

00:15:42,880 --> 00:15:47,529
logic and this will generate damage our

00:15:44,649 --> 00:15:50,980
developer velocity and on top of that we

00:15:47,529 --> 00:15:56,260
have challenges that are unique only to

00:15:50,980 --> 00:15:58,149
service because once your code runs your

00:15:56,260 --> 00:16:00,610
cloud providers is the one that is in

00:15:58,149 --> 00:16:02,260
charge of the whole thing he can pull

00:16:00,610 --> 00:16:03,100
the plug whenever he wants and he has

00:16:02,260 --> 00:16:05,410
some constraints

00:16:03,100 --> 00:16:07,570
it doesn't allow you to use as much as

00:16:05,410 --> 00:16:09,490
memory memory that you want it doesn't

00:16:07,570 --> 00:16:09,990
allow you to run for as much time as you

00:16:09,490 --> 00:16:12,399
want

00:16:09,990 --> 00:16:16,779
Amazon recently raised the five-minute

00:16:12,399 --> 00:16:18,670
bar to 15-minute bar but still it's it's

00:16:16,779 --> 00:16:20,470
a limit that you once you exceeded

00:16:18,670 --> 00:16:24,839
you're going to get a timeout not

00:16:20,470 --> 00:16:27,190
talking about call start which is just

00:16:24,839 --> 00:16:30,760
something that really affects that the

00:16:27,190 --> 00:16:32,350
way your system works and the retries

00:16:30,760 --> 00:16:36,399
mechanism you're not sure if the trace

00:16:32,350 --> 00:16:38,050
was retried once in a while and so we

00:16:36,399 --> 00:16:41,230
have many challenges that are only

00:16:38,050 --> 00:16:44,079
unique to service so how can this be

00:16:41,230 --> 00:16:48,250
done differently in service so the truth

00:16:44,079 --> 00:16:49,899
is there's not a true answer because we

00:16:48,250 --> 00:16:53,579
are many companies trying to solve this

00:16:49,899 --> 00:16:57,550
issue Epsilon trying to solve this issue

00:16:53,579 --> 00:17:00,220
edibles himself with with X ray so but

00:16:57,550 --> 00:17:02,350
what's what's so common to all of us is

00:17:00,220 --> 00:17:04,809
what we are trying to do we're trying to

00:17:02,350 --> 00:17:07,150
implement automation on on tracing

00:17:04,809 --> 00:17:08,949
system we want to tell our developers

00:17:07,150 --> 00:17:13,150
you don't no longer need to manually

00:17:08,949 --> 00:17:15,669
trace things you can use automatic

00:17:13,150 --> 00:17:17,650
instrumentations in order to speed up

00:17:15,669 --> 00:17:19,270
with the development speed to keep up

00:17:17,650 --> 00:17:25,120
with this bill the development speed of

00:17:19,270 --> 00:17:26,600
service so the last thing I want to talk

00:17:25,120 --> 00:17:30,270
about is

00:17:26,600 --> 00:17:31,830
being able to use monitoring in service

00:17:30,270 --> 00:17:34,830
to optimize your performance and

00:17:31,830 --> 00:17:36,690
optimize your cost and in service when

00:17:34,830 --> 00:17:38,549
you optimize your performance you

00:17:36,690 --> 00:17:42,690
automatically also optimize your cost

00:17:38,549 --> 00:17:44,429
because in service time is money okay as

00:17:42,690 --> 00:17:46,799
long as your function once you pay for

00:17:44,429 --> 00:17:49,169
it which can be a wonderful thing if you

00:17:46,799 --> 00:17:51,330
don't want to continue paying for four

00:17:49,169 --> 00:17:54,419
recesses that you don't use but it can

00:17:51,330 --> 00:17:57,320
also damage you and you need to think

00:17:54,419 --> 00:18:00,330
about how much time your function really

00:17:57,320 --> 00:18:03,240
really what it does what it does execute

00:18:00,330 --> 00:18:06,960
so two main things that your function is

00:18:03,240 --> 00:18:09,720
consist of is is your own code you make

00:18:06,960 --> 00:18:12,360
some calculation you try to read from

00:18:09,720 --> 00:18:15,059
somewhere and that's the time you waste

00:18:12,360 --> 00:18:18,600
but there's also another thing which is

00:18:15,059 --> 00:18:21,809
your api's every API you send a request

00:18:18,600 --> 00:18:24,210
to you can wait how long time that you

00:18:21,809 --> 00:18:27,179
wait for a response but you continue to

00:18:24,210 --> 00:18:30,570
pay for the entire cycle you don't it's

00:18:27,179 --> 00:18:33,630
you pay for every API call that you send

00:18:30,570 --> 00:18:36,299
so I want to share with you a real-life

00:18:33,630 --> 00:18:38,640
example that we had in EPS agon which is

00:18:36,299 --> 00:18:42,299
quite embarrassing but it really proves

00:18:38,640 --> 00:18:45,659
the point and I don't care I wasn't the

00:18:42,299 --> 00:18:48,900
one in charge of it so what happened is

00:18:45,659 --> 00:18:51,390
that when we first started we we wanted

00:18:48,900 --> 00:18:53,880
to track our sister check our users

00:18:51,390 --> 00:18:57,360
functions we want to to read their logs

00:18:53,880 --> 00:19:00,330
and be able to take stuff like how many

00:18:57,360 --> 00:19:02,400
time errors or timeouts and and and like

00:19:00,330 --> 00:19:05,340
to start to build analytics and metrics

00:19:02,400 --> 00:19:07,799
from that and what we did is scan all

00:19:05,340 --> 00:19:09,090
their functions also we we are also

00:19:07,799 --> 00:19:11,309
hooked on server so we said okay let's

00:19:09,090 --> 00:19:13,530
do it we are only two functions only two

00:19:11,309 --> 00:19:16,470
pieces of code one piece of code all it

00:19:13,530 --> 00:19:18,720
does is goes through your users all our

00:19:16,470 --> 00:19:21,870
users which was not that a lot but they

00:19:18,720 --> 00:19:24,090
go through all that users and they scan

00:19:21,870 --> 00:19:27,000
their functions and and after that it

00:19:24,090 --> 00:19:29,280
invokes another lambda function which

00:19:27,000 --> 00:19:32,130
all she does all she knows in the world

00:19:29,280 --> 00:19:35,669
is to read a log file and what happened

00:19:32,130 --> 00:19:37,830
this worked pretty good and it was very

00:19:35,669 --> 00:19:40,320
fun our users we didn't have any issues

00:19:37,830 --> 00:19:42,179
but one day

00:19:40,320 --> 00:19:45,000
as we started to really evolve up our

00:19:42,179 --> 00:19:46,980
monitoring system someone went to the

00:19:45,000 --> 00:19:48,570
room said okay let's start using our own

00:19:46,980 --> 00:19:50,940
monitoring solution on our own

00:19:48,570 --> 00:19:52,620
monitoring back end so we said okay

00:19:50,940 --> 00:19:55,620
let's do it at 10 and we have the

00:19:52,620 --> 00:19:59,279
ability to to see how much time how much

00:19:55,620 --> 00:20:02,880
money we could how much how much money

00:19:59,279 --> 00:20:05,130
our functions could cost us and when we

00:20:02,880 --> 00:20:08,159
do that when we did that we started

00:20:05,130 --> 00:20:11,009
saying some weird things and this is a

00:20:08,159 --> 00:20:12,299
real conversation from my CEO and CTO we

00:20:11,009 --> 00:20:14,870
probably won't understand cases in

00:20:12,299 --> 00:20:17,340
Hebrew and he looked at the at the at

00:20:14,870 --> 00:20:20,039
the logs and he said and he saw that

00:20:17,340 --> 00:20:22,590
this two specific functions gonna cost

00:20:20,039 --> 00:20:24,990
us 30 hundred dollars a month which in

00:20:22,590 --> 00:20:28,049
lambda terms it's like what the hell did

00:20:24,990 --> 00:20:28,230
you did and he asked them is this for

00:20:28,049 --> 00:20:31,740
real

00:20:28,230 --> 00:20:35,820
and then what this made our CTO do is

00:20:31,740 --> 00:20:38,009
hold his head and say okay Sunday

00:20:35,820 --> 00:20:40,350
morning in Israel we work on Sunday so

00:20:38,009 --> 00:20:42,120
Sunday morning everyone get in the in

00:20:40,350 --> 00:20:44,850
the office and want to solve this issue

00:20:42,120 --> 00:20:47,460
so we started looking at what really

00:20:44,850 --> 00:20:49,139
happened and we noticed that that

00:20:47,460 --> 00:20:52,799
external API that we used which was the

00:20:49,139 --> 00:20:55,379
cloud Bush log reader has a limit on how

00:20:52,799 --> 00:20:58,110
much time you can query it concurrently

00:20:55,379 --> 00:21:01,799
from one account so what happened that

00:20:58,110 --> 00:21:04,950
we had 5,000 functions running in

00:21:01,799 --> 00:21:07,590
parallel and all they did is wait for

00:21:04,950 --> 00:21:10,559
that reader to allow them to read and

00:21:07,590 --> 00:21:12,179
this turned them to work for almost five

00:21:10,559 --> 00:21:13,799
minutes they didn't timeout so we didn't

00:21:12,179 --> 00:21:18,779
get any error so it was almost five

00:21:13,799 --> 00:21:20,820
minutes like 452 like that and which is

00:21:18,779 --> 00:21:24,059
the perfect number to not track a bug

00:21:20,820 --> 00:21:25,919
and what happened is it went for five

00:21:24,059 --> 00:21:27,720
minutes the whole time and we

00:21:25,919 --> 00:21:30,710
practically paid for the whole month for

00:21:27,720 --> 00:21:33,720
5,000 lambdas concurrently and we also

00:21:30,710 --> 00:21:36,240
configured with high memory so it costs

00:21:33,720 --> 00:21:42,750
us a lot of money so another example of

00:21:36,240 --> 00:21:49,650
that is and if anyone here and maybe can

00:21:42,750 --> 00:21:53,760
identify what issue can happens here no

00:21:49,650 --> 00:21:56,130
okay I'll help so we have here a new

00:21:53,760 --> 00:21:58,980
post that has been triggering a function

00:21:56,130 --> 00:22:01,950
trying to authenticate a user and once

00:21:58,980 --> 00:22:05,040
authenticated moves on its send an SMS

00:22:01,950 --> 00:22:07,890
message notification and it moves on as

00:22:05,040 --> 00:22:12,150
a new post so what you can notice here

00:22:07,890 --> 00:22:15,420
is is the amount of time it took to run

00:22:12,150 --> 00:22:18,720
the query and try to authenticate that

00:22:15,420 --> 00:22:20,610
user which is not that much time if you

00:22:18,720 --> 00:22:25,650
think about 700 seconds but once you

00:22:20,610 --> 00:22:27,390
have many new posts from for many users

00:22:25,650 --> 00:22:30,330
you gonna start paying for that a lot

00:22:27,390 --> 00:22:32,850
and if you look at the whole it this is

00:22:30,330 --> 00:22:36,030
a transaction right so if you look at as

00:22:32,850 --> 00:22:38,990
a whole the 700 milliseconds like 80% of

00:22:36,030 --> 00:22:41,700
the entire run of this of this flow so

00:22:38,990 --> 00:22:44,520
it's not okay that we waste so much

00:22:41,700 --> 00:22:48,090
money and and my question is how can we

00:22:44,520 --> 00:22:49,560
start identifying such issues in a

00:22:48,090 --> 00:22:52,680
service application that can help us

00:22:49,560 --> 00:22:54,780
optimize our system and one thing is

00:22:52,680 --> 00:22:57,860
start to think different is to take

00:22:54,780 --> 00:23:00,450
those distributed traces and be able to

00:22:57,860 --> 00:23:02,550
aggregate them and find patterns in them

00:23:00,450 --> 00:23:04,470
because it's system has its own patterns

00:23:02,550 --> 00:23:06,420
has its own business flows like a block

00:23:04,470 --> 00:23:09,840
size he has two main thing you can read

00:23:06,420 --> 00:23:11,730
a post and you can submit a post so this

00:23:09,840 --> 00:23:13,350
is example of what happens when you read

00:23:11,730 --> 00:23:16,470
a post this is what happens when you

00:23:13,350 --> 00:23:19,430
submit a post and if you take these

00:23:16,470 --> 00:23:22,050
visits flows and you are able to

00:23:19,430 --> 00:23:26,130
aggregate them and and gather statistics

00:23:22,050 --> 00:23:29,010
on them you can only then you can look

00:23:26,130 --> 00:23:31,980
like at the end of the week you can have

00:23:29,010 --> 00:23:33,270
this pretty list you can do a write with

00:23:31,980 --> 00:23:36,530
a script to do this calculation you

00:23:33,270 --> 00:23:40,020
don't you don't have to use anything and

00:23:36,530 --> 00:23:42,480
what you can do it helps you to focus on

00:23:40,020 --> 00:23:45,450
what you want your development tip team

00:23:42,480 --> 00:23:47,670
to to work on if we look here we see

00:23:45,450 --> 00:23:49,920
something problematic like everyone you

00:23:47,670 --> 00:23:52,560
are so beautiful and the last one takes

00:23:49,920 --> 00:23:54,810
average of eight minutes and the next

00:23:52,560 --> 00:23:56,550
time of 10 minutes it's not doesn't

00:23:54,810 --> 00:23:58,080
sound like something that should be for

00:23:56,550 --> 00:23:59,850
something that only updates statistics

00:23:58,080 --> 00:24:02,550
right and we can go with this

00:23:59,850 --> 00:24:03,630
information to our development team and

00:24:02,550 --> 00:24:06,120
tell them okay we have an issue

00:24:03,630 --> 00:24:08,610
specifically in this transaction and

00:24:06,120 --> 00:24:10,440
this rejection consists this function

00:24:08,610 --> 00:24:13,740
and this is our diploma ters that it

00:24:10,440 --> 00:24:15,510
queries and we can now start working on

00:24:13,740 --> 00:24:18,330
how to optimize that and not only that

00:24:15,510 --> 00:24:21,780
it alerts us on what we should optimize

00:24:18,330 --> 00:24:24,360
we can later on be able to see if that

00:24:21,780 --> 00:24:25,560
number drops if if we did our job and

00:24:24,360 --> 00:24:29,130
asked for a raise

00:24:25,560 --> 00:24:31,080
this is really important so to sum it up

00:24:29,130 --> 00:24:33,120
if you want to track your system health

00:24:31,080 --> 00:24:35,700
in several eyes it's not enough only to

00:24:33,120 --> 00:24:37,770
track functions you need to track your

00:24:35,700 --> 00:24:39,990
api's you need to check your resources

00:24:37,770 --> 00:24:42,360
like I said if stripe is down it's not

00:24:39,990 --> 00:24:43,470
only their problem it's also ours and if

00:24:42,360 --> 00:24:45,780
you want to troubleshoot and fix

00:24:43,470 --> 00:24:46,920
something in your service application

00:24:45,780 --> 00:24:49,200
you need to start looking at a

00:24:46,920 --> 00:24:51,810
synchronous events and implement this

00:24:49,200 --> 00:24:53,910
will be retracing whatever you want but

00:24:51,810 --> 00:24:56,040
you need to start implement usable

00:24:53,910 --> 00:24:58,590
distributed tracing and I must have poly

00:24:56,040 --> 00:25:01,680
try to do it automatically and the last

00:24:58,590 --> 00:25:03,000
thing is to be able to if you want to be

00:25:01,680 --> 00:25:05,430
able to optimize the performance and

00:25:03,000 --> 00:25:08,690
cost we need to look at all these traces

00:25:05,430 --> 00:25:12,090
that we got from the distributed tracing

00:25:08,690 --> 00:25:14,760
agent and figure out a way how we can

00:25:12,090 --> 00:25:17,850
aggregate them and look at them later on

00:25:14,760 --> 00:25:20,330
in order to spot many bottlenecks and

00:25:17,850 --> 00:25:25,500
know what we should focus us on as a

00:25:20,330 --> 00:25:28,860
development team and last thing I want

00:25:25,500 --> 00:25:31,980
to talk about is in Epsilon

00:25:28,860 --> 00:25:34,020
what I'll do it more so in epsilon we

00:25:31,980 --> 00:25:35,730
also decided to write some tools for the

00:25:34,020 --> 00:25:38,280
open source community we want to help

00:25:35,730 --> 00:25:41,840
service users to identify issues without

00:25:38,280 --> 00:25:45,390
having to pay us and we did that by

00:25:41,840 --> 00:25:48,240
writing a few tools to men of them is be

00:25:45,390 --> 00:25:49,980
able to track all your functions all

00:25:48,240 --> 00:25:53,180
your functions from all the regions and

00:25:49,980 --> 00:25:55,800
it's just a simple table that shows you

00:25:53,180 --> 00:25:57,120
the lat you can sort it by last

00:25:55,800 --> 00:26:00,240
invocation that's modified and this

00:25:57,120 --> 00:26:01,710
helps you detect dead functions and when

00:26:00,240 --> 00:26:05,250
you have a death function usually you

00:26:01,710 --> 00:26:06,900
also have a dead service that you also

00:26:05,250 --> 00:26:09,240
have a dead resource that you're

00:26:06,900 --> 00:26:11,220
probably paying for so this can help you

00:26:09,240 --> 00:26:12,270
save some time maybe you have some part

00:26:11,220 --> 00:26:14,400
of your application that no one ever

00:26:12,270 --> 00:26:16,630
uses you can notice that and the next

00:26:14,400 --> 00:26:19,570
thing is we

00:26:16,630 --> 00:26:21,730
the tool that help you look at your your

00:26:19,570 --> 00:26:24,250
functions and it gives you an estimation

00:26:21,730 --> 00:26:26,710
how much money it will cost by the end

00:26:24,250 --> 00:26:30,270
of the month and this is very helpful

00:26:26,710 --> 00:26:32,830
for developers that are now trying to

00:26:30,270 --> 00:26:34,900
implement some improvement and they can

00:26:32,830 --> 00:26:37,140
see if that number will the jobs and

00:26:34,900 --> 00:26:40,540
they can really get an improvement so

00:26:37,140 --> 00:26:42,940
that's all for me I'm can feel free to

00:26:40,540 --> 00:26:51,520
ping me later if you want to talk about

00:26:42,940 --> 00:26:53,460
anything thank you very much so any

00:26:51,520 --> 00:27:04,540
questions since we have a service

00:26:53,460 --> 00:27:07,450
service expert here actually so a

00:27:04,540 --> 00:27:11,290
question from my side weather is storing

00:27:07,450 --> 00:27:14,220
not tracing right now right now is

00:27:11,290 --> 00:27:19,080
Epsilon where we store in this tracing

00:27:14,220 --> 00:27:21,280
where you're storing the tracing data so

00:27:19,080 --> 00:27:23,260
in epsilon this is what we do we're

00:27:21,280 --> 00:27:24,880
building a monitoring solution so we

00:27:23,260 --> 00:27:27,120
take the traces from the users we set

00:27:24,880 --> 00:27:29,980
them in a database and then we do some

00:27:27,120 --> 00:27:34,110
configuration but this can be done by

00:27:29,980 --> 00:27:40,800
anyone else okay so thank you very much

00:27:34,110 --> 00:27:51,030
[Applause]

00:27:40,800 --> 00:27:51,030

YouTube URL: https://www.youtube.com/watch?v=0dYn5Y2RskA


