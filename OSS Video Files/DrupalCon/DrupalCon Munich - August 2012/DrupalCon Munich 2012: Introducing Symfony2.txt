Title: DrupalCon Munich 2012: Introducing Symfony2
Publication date: 2013-03-29
Playlist: DrupalCon Munich - August 2012
Description: 
	During his last keynote in Denver, Dries made it clear that Symfony2 is going to play an extremely important role in the making of the upcoming version(s) of Drupal: this session will be an occasion to uncover some of the concepts and libraries that are being introduced in the making of our beloved CMS.

Some Object Oriented Design fundamentals will be covered such as orthogonal code, inversion of control and pervasive testing along with some of most important features of the framework and it will show how clean and tested applications can be developed using the rich set of components it comes with.

Some of the topics that will be covered:

What's Symfony2
Bad practices that should be left behind
Principles of Class Design or How To Make Proper Use Of That Object Oriented Thingy
The most important Symfony2 components
The framework and the standard distribution
The most important third-party libraries
Captions: 
	                              alright so I think we can start so this                               session is going to be about same                                     you might in fear from the title and                               about a few other selected topics I                               believe are important for today's PHP                               developers eh bien Drupal developers of                               course so before we start allow me to                               introduce myself my name is Claudio I've                               got six years of experience in PHP                                development mostly divided between Italy                                and France even though lately I shifting                                toward germany where I found it with                                other five people company called a gavi                                unfortunately we don't have any fusion                                announcement to do but besides that I'm                                also one of the founders of the Drupal I                                Association which is organizing events                                about Drupal in Italy since                                       believe it's enough about me so let's                                start by trying to answer the probably                                most important question so what is this                                symfony                                                              talking about lately so first of all and                                that's probably the part i prefer the                                most symfony                                                         decoupled & Co as if components start                                build leveraging the latest feature                                introduced with PHP                                               namespaces and it has been built in                                order to you know being as reusable as                                possible and each component has been                                designed to be to not need any other you                                know dependency so in order to better                                understand how does this this work we                                have to go back to year two thousand six                                when the development for the design                                phase started and yeah when when Fabian                                potency the project leader which was                                already shaping Symphony version one                                you know notice that all the frameworks                                and products in the PHP world basically                                had a problem they weren't interoperable                                at all so if we think of symphony one or                                even Drupal it wasn't that easy to pick                                you know for instance the hook system                                just the name one and reuse it wherever                                we need it without you know feeling                                great pain so it started to design this                                set of components and the framework with                                this idea in mind to be as much as                                interoperable as possible and today with                                so many products that are starting you                                know using the symphony components                                Drupal being just one of them we see the                                results of that shift in approach before                                that we had just vertical monolithic                                frameworks that were hard to reuse other                                than being a set of components clearly                                Symphony ships a full stock web                                framework that is probably what the                                people mostly expect when you know                                talking about it so it provides                                additional features such as the bundles                                the bundle system and you know the glue                                between the different components and                                some noticeable libraries such as twig                                or aesthetic or monologue and stuff like                                that so it provides a better user                                experience for the developer so that we                                can start developing you know faster the                                last thing it's worth not saying about                                same                                                                    frameworks that mostly implement the MVC                                framework the focus has been put on on                                the HTTP specification on the HTTP                                protocol so that it's more correct to                                call it a request-response framework                                instead of an MVC framework even though                                symfony                                                               natively y relies on external libraries                                for the mold apart but you know the most                                important thing is that it is not built                                around                                the MVC pattern while it's try to stick                                as much as it can to the HTTP                                specification ah yeah clearly it just                                tanked the tried it symfony                                           to you know reinvent the wheel again and                                again so it uses the standards as much                                as we can as much as it cans and so                                other than HTTP which is heavily relied                                upon for instance for caching sinfoni                                doesn't provide a caching system an                                application page caching system it                                relies on HTTP cache it also uses other                                standards such as the NRA Java RFC for                                the form validation and clearly promotes                                best practices which we are going to you                                know see in a little while at least a                                 few so what there are not just the best                                 practices clearly all the developers                                 outside of this room sometimes you know                                 had a few bad habits that I briefly                                 described here so such as code                                 duplication or bad naming for variables                                 classes and function and stuff like that                                 not mentioning you know the tight                                 coupling between you know the pieces of                                 our code such as classes or function                                 that brought the code to be unmaintained                                 able and unreliable and very hard to                                 test but I'm not here to you know talk                                 about the bad stuff because I'd like to                                 focus a bit on a few class design                                 principles that are you know general                                 they are not related directly to                                 Symphony itself but are the big can be                                 used anywhere but of course being                                 general that can be applied to seem                                 foreign to you as well so the first the                                 first one is the single responsibility                                 principle that basically states that                                 every class should have a single one and                                 only one single responsibility and fully                                 encapsulated it's                                 I think it makes quite sense because the                                 more with we strive to localize the                                 changes in our code you know the less we                                 tend to have bugs or you know                                 unpredictable count behaviors so yeah                                 trying to stick to this to this                                 principle will likely reduce the risk of                                 ripple effects and produce you know more                                 responsible code Robert Martin if you                                 don't if this name doesn't ring a bell I                                 suggest you to look for it on the                                 internet which is one of the fathers of                                 the design patterns identifies this as                                 the reason for a change so each class                                 should just have one reason for a change                                 I better describe that with an example                                 it's very simple i use this model                                 interface to describe how this six lines                                 seven lines of code violates the single                                 responsibility principle even though the                                 interface looks reasonable it's pretty                                 simple and straightforward we can                                 identify two different responsibilities                                 here basically the connection management                                 and data communication so if you want to                                 follow this this principle and try to                                 you know achieve less ripple effects and                                 and stuff we should try to split this                                 this interface in two separate ones each                                 one dealing with its own specific                                 responsibilities so the second one is                                 the open/close principle as Drupal                                 developers I think we're all used to                                 this principle even though in other                                 terms basically it says that software                                 entities should be open for extension                                 but closed for modification if don't                                 hack the core basically sounds like this                                 principle in a way even though it's not                                 a class but it's I mean it's easy to                                 define the similarity between the two                                 principal because we don't want to                                 reduce the reliability and                                 maintainability of our                                 server code in this case client and                                 server are imagine them as PHP classes                                 the server being I don't know in a                                 Facebook API library so whenever we use                                 a correct sorry whenever we use a                                 firewall we should pay the license so                                 whenever we use some server code we                                 don't want to need to hack it in order                                 to achieve the function that we need we                                 want it to be designed to be extensible                                 the third principle called the list of                                 substitution principle is probably the                                 hardest one to grass because it is sub                                 to subtle effects on real code that are                                 quite hard to grasp basically it says                                 that any any parent type should be                                 replaceable with a child type without                                 affecting the correctness of the program                                 this is this seems reasonable but it                                 doesn't suffice to rely on the syntactic                                 contract that we you know put in place                                 when defining interface and then                                 abstract classes and this kind of stuff                                 because it's a semantic problem I show                                 you an example to better explain that so                                 try to imagine we got a program that                                 drove some shapes rectangles and squares                                 and we have to you know design some                                 classes a few classes for doing the task                                 it seems reasonable to model the the                                 problem as in our base rectangle class                                 which comes with width and height                                 properties with the related accessory                                 mutator methods and then derive the                                 square the square class and that extends                                 the rectangle by and just you know                                 overrides the set with and set                                 methods but if you try to run your brain                                 command-line interpreter on the function                                 drove that that's on the right column                                 you will see that you know if you pass a                                 pure rectangle and then set width and                                 height and then assert that width times                                 height makes                                                             whenever you you you pass in a square                                 which perfectly respect the contract of                                 this function and set width and height                                 again that assertion will fail because                                 the square behaves differently so we see                                 there is a flow of a flow in in this                                 design and in this case you might be                                 quite easy to grasp but generally                                 speaking even though a rectangle sorry s                                 square is a rectangle that doesn't all                                 true in the case of square and rectangle                                 objects so be careful about the public                                 behaviors of your API and try to make                                 them respect to respect it in order to                                 conform to this principle it will it                                 could lead to you know quite hard bugs                                 quite hard to do to debug problems so                                 and moreover it's not easy to always                                 apply it the fourth is the interface                                 segregation principle and basically                                 states that smaller specialized                                 interface are better than a big one this                                 is quite simple to understand also                                 because again it's a matter of reducing                                 the code that we need to to modify or or                                 you know to interact with for instance                                 when we need to instantiate a printer                                 and it does just have to print there is                                 no need for scanner fax                                 function in it that might bring you no                                 problems it's better to separate this is                                 actually a real life example where that                                 goes back many years from now where the                                 bob martin i mentioned before when took                                 Sarek's to try to solve you know the                                 problem they had at the time because i                                 mean their software became so big and                                 take it took so much time to compile and                                 you know be tested that they had to find                                 solution and that was what he proposed                                 them                                 and now the dependency inversion                                 principle the last one basically we were                                 used to a kind of architecture that                                 basically made higher level in the                                 technology stack to rely on the the                                 lower ones so for instance you know a                                 library relying on a lower level one and                                 that that caused a a big coupling                                 between you know the two layers that                                 made almost impossible for the high                                 level layer to change the the lower                                 level one the dependency inversion                                 principle tries to address this problem                                 by inverting actually the dependency                                 between the two layers so that it's not                                 the higher level that depends on the                                 lower one while it's the opposite so the                                 component a package for instance defines                                 a service that the component the lower                                 level component should should implement                                 in order to you know to provide the                                 service that's needed again here's an                                 example let's say that we have a vehicle                                 that clearly used tires for moving we                                 have this class it's very simple where                                 you know the bike will instantiate four                                 tires and then we have the class tire                                 that provides you know a diameter in and                                 that's it so here we see that but                                 vehicle class which is our higher level                                 layer strictly requires the lower one to                                 exist to function basically and that's                                 not good because we can't easily you                                 know change the tires in the vehicle                                 without packing without changing the                                 code of the vehicle and that's not what                                 we want to achieve because it makes                                 called harder to maintain and even less                                 testable                                 so this is the same this is the same                                 problem where we inverted the                                 dependences so now the the component a                                 the higher one which is the vehicle                                 defines a contract called abstract tire                                 so it's basically says okay in order for                                 me to function i need the tire and it                                 should behave like that so we are free                                 to provide any kind of lower level kind                                 of tired by just implementing you know                                 by respecting that contract so in this                                 case implementing that abstract class                                 and this brings much more flexibility                                 and it makes called way easier to test                                 and way more reliable so we've seen this                                 principles and some of them are already                                 used in being already implemented in                                 symphony most notably dependency                                 inversion principle is what you know it                                 backs the service container which we are                                 going to see in in a few moments but                                 before that let's say you look at the                                 class loader so this is a very important                                 component that not because of its                                 implementation but because of the                                 conventions behind it not too much time                                 ago a convention called PSR                                            emerged from a working group a PHP                                 working group basically grabbed some                                 representative from various frameworks                                 Drupal's included so they agreed on a                                 way to load autoload classes it's pretty                                 simple I does have two different                                 conventions                                                              for older underscore names based classes                                 that we can see there so for instance                                 whenever we need to instantiate a                                 symphony core request object the class                                 loader will                                 intercept the that request so basically                                 when it's made through the SPL SPL also                                 what register that takes care of of this                                 task so it takes the name of of the                                 function of the attacks the fully                                 qualified domain name of the of the                                 class converts it into a path basically                                 just reversing the slash in this case                                 and you know prepending a path for for                                 the vendor library and and try to                                 require it same things applies for the                                 underscored namespace classes it just                                 converts the underscores to two slashes                                 and that was like Zen one was already                                 working so this way we will get rid of                                 you know any require once in our code so                                 it would be way easier to to handle the                                 dependencies in you know the class                                 dependencies in our project and at the                                 same time we will get lazy loading which                                 means that for a given execution path we                                 won't need to load the hell out of                                 everything but we just instant load the                                 class that are used for that given                                 product in execution path Moraga since                                 probably more or less all the biggest                                 frameworks are already you know shifted                                 to PSR                                                          interoperability in that we just need                                 the classes to use this convention and                                 any class loader that it's compatible                                 with with PSR                                                        them so that we can pick you know a few                                 classes from project and upload them                                 without any problem                                 and now the big superstar so the service                                 container before defining what a service                                 container is I think we should define                                 what a service itself is well basically                                 is nothing but a PHP class HP object                                 which basically performs a global tasks                                 such a mailer or a dbl structure layer                                 or a templating system whatsoever so a                                 mailer could be a service Swift mailer                                 for instance but a specific email                                 message won't be a service so it has                                 this global property if you want to try                                 to find it and the service container is                                 nothing but a glorified array basically                                 that centralizes and standardizes the                                 way these objects and services our                                 constructor are built inside our                                 application so basically it takes care                                 of the instantiation and and and the                                 configuration of of these services well                                 actually the configuration is what we                                 need to do in order to make the service                                 container to work but that's it whenever                                 we will need anything any service the                                 mail or again the the Bay abstraction                                 layer we will just ask the container to                                 give them to us and we're ready to use                                 it you will care about configuring it                                 and instantiate it we can see it as a                                 sort of satellite orbiting around our                                 application which is sending that the                                 the needed dependencies when we are                                 asking to do so so here's some code I                                 borrowed from the Drupal                                                modified it a little bit but this is to                                 show how a service container is working                                 basically we just need to instantiate a                                 container and then we're ready to go we                                 can set parameters such as the config                                 storage option array where we put a you                                 know the parameters for our connection                                 and then we can register a service by                                 giving in an ID and then a class so                                 config that storage is the idea of our                                 service while Drupal / core backslash                                 backslash config back / that way storage                                 will be the the class that represent                                 that service other than that we can pass                                 arguments to its constructor in this                                 case we have the config storage option                                 we defined few lines before and or we                                 can call methods on it such as I don't                                 know a flag finally with just invoking                                 the get method and the ID of the service                                 we can get this debt service and start                                 using it it's just a simple stuff this                                 is again borrowed by by the Drupal the                                 Drupal                                                                the way I think the container will be                                 fetched but I'm not sure about that                                 actually so anyway the only thing I                                 would like to you know to note in the                                 end is that it's best not to you know                                 use the container for for everything                                 basically to pass it around as know it's                                 crazy because in that case our code will                                 be you know a couple with that specific                                 instance of the container and does you                                 know in validating a bit all the                                 dependency all the decoupling we are                                 trying to achieve with it                                 okay another component is the even                                 dispatcher which is nothing but the an                                 implementation of the observer pattern                                 we already seen it we already got used                                 to it for instance think well the uke                                 system and even this even dispatcher can                                 be seen as an object oriented version of                                 the yogic system way or think about you                                 know JavaScript events this is more or                                 less the same thing we just define you                                 know in even the spectra and the co and                                 valid PHP callable and we attach it to a                                 specific event in this case food bar and                                 whenever we need it quick a week we can                                 fire that event and the caller bowl will                                 will respond and in this case you know                                 log of warning on a database                                 so this is one of the most important one                                 most important component in the symphony                                 in the symphony environment and                                 basically it's a a library that replaces                                 the PHP global variables and functions                                 and provides an object-oriented API that                                 basically is modeled after HTTP the HTTP                                 specification again it's besides being                                 object-oriented it's a mean being of the                                 object oriented it means that we've got                                 a an easier way to test this kind of                                 code or to mock request or response                                 which is very great for testing and                                 moreover it provides a higher level of                                 abstraction that will that is you know                                 hiding a few tricky tricky edge cases                                 you know when handling HTTP connections                                 using it is as simple as as the other                                 components and that we can just create a                                 request object by invoking the static                                 create from Global's function method to                                 in the request class and then we can                                 start using it we can access you know                                 any any kind of property four meters to                                 you know three parameters and stuff like                                 that and it's also very easy to to                                 create a request from scratch for you                                 know any any reason we need it basically                                 could be for testing purposes same                                 things applies for the response we can                                 create a new response and then check                                 that it's compliant with the request                                 that we received and then send it so                                 it's it's yeah it's a you know implement                                 a way better implementation of highlight                                 HTTP works then the one we can have in                                 native PHP which got you know global                                 variables                                 strange name functions and stuff like                                 that and finally the HTTP kernel is the                                 is the very core of symfony                                       mentioned before sinfonie is considered                                 a request-response framework and this                                 very simple interface that defines just                                 one method is the proof of what I have                                 said before so basically this interface                                 states that when for what we said that                                 each and every request that is received                                 should be then converted into a response                                 by using any kind of PHP callable and                                 that is why also why this framework is                                 not necessarily bound to the MVC model                                 because we might even not use a                                 controller we can use just a function as                                 as we prefer so it is so important that                                 if you see it has been marked with an                                 API tag that ensure that for each                                 versions of subversion of symfony                                     won't change ever for any reason this is                                 how the default implementation works and                                 basically we see that whenever we                                 receive a request a request event is is                                 fired and if any listener is returning a                                 response then we skip all the all the                                 workflow in the middle and just return                                 that response but before that a response                                 event is fired and then the response is                                 returned every time an event is fire we                                 have the opportunity to you know add a                                 listener and modify that specific the                                 specific data that that is you know                                 bound to that event for instance when we                                 have a request event fired we can                                 I don't remove either's and stuff like                                 that and the same the same way we can                                 change the response how we like it so                                 it's no if no events it's not listener a                                 return a request then the routing system                                 comes in in the case of symphony and                                 tries to resolve that request to a                                 controller so basically tries to                                 associate that request to a specific                                 controller if a controller is found the                                 controller the controller event is fired                                 again so we have the opportunity to                                 change it and then the arguments are                                 resolved to and finally the controller                                 is cold so as we saw theoretically the                                 controller should return a response                                 because the contract we've seen before                                 states that but in case it doesn't the                                 view layer intervene and tries to                                 transform the result of the of the                                 controller into an actual response                                 object in other way in other words if a                                 controller doesn't return a response the                                 view layer will try to you know get the                                 correct view and push the values that                                 has been returned by the controller                                 render that view package it into a                                 response and then send it to the client                                 after a response has been sent a                                 terminator event is fired so that we                                 have the opportunity to do some final                                 tasks such as logging or sending                                 messages or emails or stuff like that                                 and yeah in case an exception is thrown                                 symphony will catch it and it will fire                                 an exception event and again package it                                 into a a proper response so that we can                                 have stack trace and stuff like that one                                 thing worth mentioning is also the sub                                 request the sub request thing because in                                 this way is this we                                 go back yeah we said we see that we have                                 two two constants defined in in the                                 interface for mass requests and sub                                 request this are important for for                                 caching basically because as we said                                 before there is no application caching                                 so forget about page cache or block cash                                 or query cache and stuff like that                                 unless you implement it but we have a                                 different type of caching which is the                                 HTTP cache so by using sub requests we                                 are able to differently you know control                                 the cache aspiration time or validation                                 and therefore differently catch the                                 different parts of the page and for                                 doing that we can use reverse proxy that                                 is bundled with symphony or no bringing                                 varnish                                 and now                                 twink is well I think most of you                                 already know it but for the for those                                 who doesn't who don't I just say that                                 it's probably the most beautiful                                 template engine the PHP at least I've                                 ever seen it does come with a great set                                 of features very expressive syntax and                                 it does bring good perform really good                                 performances because it by default it                                 compiles the templates to PHP PHP                                 classes and there is an optional see                                 extension that allows you to                                 transparently substitute the rendering                                 function with their see counterparts if                                 any of you was in Copenhagen two out two                                 years ago and remember the keynote from                                 Rasmus who at the time suggested to you                                 know chain to improve the Drupal                                 performances by you know implementing                                 part of the rendering engine in NC as a                                 siiiick sanction well we we got it in                                 this case because by using twig at least                                 I mean we follow that suggest suggestion                                 by you know having no effort because                                 it's right there it's working and it's                                 super easy to install as it was                                 insufficient a twig is really radically                                 ridiculous easy to to extend and very                                 well documented so in the end it's a                                 great boost for our view for our                                 presentation layer and I haven't met                                 anyone who ever complied about it as of                                 now                                 so it does consist of three type of                                 stags which are the common tags which                                 don't do anything then there are the                                 block tags that do some things such as                                 setting variables or invoking control                                 statements for if or whatever and                                 finally there are the print tags that                                 say something to print something such as                                 a string plus a variable concatenated to                                 arrival so other than these three tags                                 there are also a lot of tags filters                                 function and a test that really makes                                 make easy to you know to develop the                                 view layer it's just a great pleasure                                 this is a very compressed example of a                                 twig template and we can see on the                                 first line you know comment and then one                                 of the features I like the most because                                 it really you know gives a structure to                                 our view layer the extent tag so                                 basically trick tags are able to inner                                 it from other twig twig templates or fig                                 templates are able to enter it from                                 other three templates and that's just                                 great because it will make us to reuse a                                 lot of code so after the gig extends tag                                 we have a macro which is nothing but a                                 view function where we can do more or                                 less whatever we we are able to do given                                 the functionalities we haven't twig so                                 for instance in this case we print a div                                 containing a node ID we can access the                                 an object property by using the dot                                 notation and if the properties are not                                 public                                 the accessor will be called so if we                                 have I don't know the title attribute on                                 an odd object which is protected but a                                 gap not get title method is implemented                                 then twig will automatically resolve                                 that then we see filters for instance                                 the title is passed through a title                                 filter that basically uppercase the                                 first letter of each word in the string                                 or we can form a date or even we can                                 implode arrays and you know lowercase                                 then or we can invoke a function to know                                 print the slug of the notepad then in                                 the block body which is which could be                                 probably the only piece the only the                                 only block we actually extend from the                                 layout given that the layout might have                                 now a heater block which which contains                                 a standard either and the filter then we                                 just override the body and we see that                                 we in this case we loop on the nodes                                 which could be any PHP iterable or an                                 array and render the given node there's                                 also this nice for else statement that                                 in case there are no nodes it just                                 prints we did not find any node and pass                                 it through the translation field so                                 actually the slug function does not                                 exist in twig so here is how we create                                 it and it's that simple we just need to                                 extend the twig underscore extension                                 class and define the get functions                                 method to read in order that it returns                                 an array of an array keyed sorry an                                 array which keys are the name of the                                 functions and which values are the                                 actual object that wrap the meat that                                 would need whether we need to call so in                                 this case this                                 function will be a twig underscore                                 function underscore meted object that                                 refers to the slug meets the                                 implementation we've got there and then                                 we can implement whatever function we                                 need just as you needed this is just an                                 example it probably doesn't make sense                                 but it just for the sake of no-show so I                                 run quite a bit but I would like to                                 share with you a few links that I've                                 used for preparing this presentation                                 plus five books I believe are quite                                 important and i suggest you to read to                                 our PHP specific and are about objects                                 PHP objects patterns and practices and                                 the other one is about you know PHP or                                 factoring and we'll give you another                                 view on some interesting topics such as                                 called smell or how to you know                                 effectively refactor PHP code and how to                                 keep up today the other three are                                 completely aren't related to PHP but I                                 think are useful for each developer and                                 they cover basically xen eight patterns                                 X enix test patterns and in this case if                                 we're using phpunit those concept will                                 will apply the other problem or                                 test-driven development that will help                                 us to better understand the implication                                 of you know all the concept we briefly                                 mentioned today and you know will help                                 us apply them in practice because as                                 soon as you start trying to do                                 test-driven development you will see how                                 the old way of writing code is                                 completely completely wrong in this new                                 perspective and in that case simply to                                 really help us to                                 to the test driven development and I                                 think this is it I would like to ask you                                 to rate the session and if anybody has                                 question just fire thank you anyone                                 demonstrated using events and symphony                                 yep and I'm just curious I know with                                 with JavaScript when you do event-based                                 development if the whole pattern changes                                 and it seems that in the Drupal universe                                 hooks are kind of closest to events                                 because you're you're causing things to                                 happen that are decoupled and trying to                                 meet you on some curious how triple                                 programming may change if we you know                                 what what's the relationship of the                                 hooks to events and how my things change                                 if we shipped using more events instead                                 of hooks or should hooks be reappointed                                 in terms of events relationship well I'm                                 I'm not sure how the i'm not sure if                                 they are going to replace the hook                                 system with the event dispatcher of                                 symphony because I'm for sure they're                                 going to use it because of of the HTTP                                 Colonel but I'm not sure about you know                                 the implementation so the hook system is                                 somewhat similar to its probably it's                                 probably the closest thing we have in                                 Drupal that might reminds you of of this                                 this is probabilities Patrick little                                 they're not the same thing so                                 well actually even the two I would                                 rather go for a complete object-oriented                                 system but I see that there are also you                                 know we also have to care about backward                                 compatibility in in a way so and give                                 time to you know people to get used that                                 I wouldn't be surprised though if we                                 won't be using both I mean was we won't                                 be using any of them because you know                                 things are changing all the time and                                 even the observer pattern is is I mean                                 some people is trying to deprecate it                                 because it's pretty too verbose and                                 introduces some side effects that are                                 sort of bad for applications so i                                 wouldn't be surprised if seem funny to                                 point whatever will ship a different                                 system and therefore we will end up not                                 using hooks and an end observer pattern                                 in the end welcome                                 okay so another question fine
YouTube URL: https://www.youtube.com/watch?v=9lb0eMZUr4I


