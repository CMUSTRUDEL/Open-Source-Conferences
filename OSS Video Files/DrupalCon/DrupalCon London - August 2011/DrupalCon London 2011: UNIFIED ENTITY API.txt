Title: DrupalCon London 2011: UNIFIED ENTITY API
Publication date: 2013-03-23
Playlist: DrupalCon London - August 2011
Description: 
	Problem: 
Unified Entity API as Part of the Configuration Management Initiative
The divergent APIs and representations for different core entities means that there can be no standard way to export, import, or configure them.

In addition, this makes Drupal core harder to develop and maintain, and make the module builder DX worse too.

An Entity Property API for Drupal 8
Having the entity API unifying CRUD for Drupal 8 is already a great step forward. It seems obvious that it should handle full CRUD, but for it to be really useful we need to care more about the entity properties, fields and their differences.

While fields feature APIs for validation, access information, widgets, display formatters or translatability, we have nothing like that for regular entity properties. However, for modules to be able to work with entities in general, we need some of those features for regular entity properties too. Consider the use-case "RESTful web services", or any module that wants to generically use or update data from entities, like the Search API or Rules already do.

Proposed solution: 
Unified Entity API as Part of the Configuration Management Initiative
As a sub-effort of the Configuration management initiative, we need to standardize the core Entity API.

catch and I discussed this possibility in Chicago. This conversation will be an update on progress and plans going forward.

An Entity Property API for Drupal 8
The entity API module achieves already something similar in Drupal 7. It comes with an Entity property information system, which kind of wraps Drupal's divergent data structures behind unified data wrappers.

However for Drupal 8 we want to avoid the need for unnecessary wrappers. So we need to come up with an API that fulfills developer's needs without anything extra. So should be everything a field then?

I'd like to present and debate a slightly different approach: The entity property API, which cares about an unified and easy way for accessing and updating property values, validation, access information as well as other property metadata.
With such an entity property API in place, fields could very much build upon this generally useful API and complement it wherever necessary. Related, we might want to look into streamlining field storage and entity storage, and provide a storage system that can handle translatable properties out of the box.
Captions: 
	                              okay I guess I'm starting so this is                               kind of a an extended update and                               discussion on where we're going with                               entity API in Drupal                                             signed up to this because I I thought                               catch was coming the thing that I could                               rub them into work it do it with me but                               happily Vagos here and so he put                               together some slides and this is going                                to kind of extend from what Greg talked                                about yesterday in terms of the core                                initiatives and basically we've been                                talking since I don't know when San                                Francisco timis it's good yeah about                                even long before that if you look at                                Drupal core api's you compare our node                                module comment module user module you                                start to cry because you see that none                                of them call in at the same code in the                                same order drupal                                                     in terms of having at least a little                                more consistency of which hooks are                                called but if you look at the Drupal                                  code you'll see that we have a comment                                hook we have a fuel hook we have a                                entity generic hook so we basically have                                every hook repeated at least three times                                with different variants in part to                                support all kinds of legacy code that                                expects a certain naming so moving                                forward we want to really unify these                                and this is really about solving a lot                                of the technical debt that's still                                present in Drupal                                                      Drupal                                                                  API went in sort of the last relative                                last minute things like making all                                entities able to have fields on them was                                relatively late in the development cycle                                and so there's a lot of implications of                                that that change and just bringing a                                better developer experience by having                                consistent API so that if you want to                                load or save any kind of empty you don't                                have to think hard about which                                parameters                                sin or which kind of data you need to                                use that it's going to be consistent                                throughout throughout every entity type                                you know both the core types and custom                                pipes so the idea here is that you know                                entities really become our generic                                framework for handling data people are                                starting to use them this way in Drupal                                                                                                      API is considering making every making                                the votes on a node entities now this                                you know initially I thought wow that's                                crazy but if you consider that at least                                in Drupal                                                           just a wrapper around saving data to one                                table well this is exactly what voting                                API is already doing it's just every                                time your poor to vote we insert a row                                into the table so you know let's let's                                just think about using entities as our                                basically our storage framework for for                                everything so we'll have consistent a                                consistent API will use this                                consistently every time we want to store                                data somewhere who is I guess that man                                was saying you know he wants all                                developers to forget about SQL so this                                is kind of even regardless of what we                                think about the storage back end this                                moves us in the direction of forgetting                                about SQL yes some of the other things                                in Drupal into these like blocks for                                instance um good question is block doing                                it down to that yeah                                question was raised when I was talking                                about making blocks on instinct and I                                said no                                                                 of special because you know things like                                of you can up in a block and they're                                really things for putting on pages and                                so may be different from yeah yeah yeahs                                custom box probably should be in these                                because yeah you think about okay                                there's a box table and it you know has                                mr. blocks in each block is each of them                                is basically static pieces of data yo so                                by the s-block see general maybe not                                yeah I think there really is a                                difference about a bit of blog this                                concept of beautiful building your site                                on as a display container and their                                custom block you want to um sure yes                                so in drupal                                                            some amount of pluggable storage for                                 fields and i think we'll talk more that                                 you know we want to remove any any                                 conception of field API as a separate                                 API that that you know fields are the                                 way that you add more data to entities                                 therefore if we have a unified way of                                 storing data entity data then all the                                 field storage is underneath that NT                                 system again this you know integrates                                 well with what Damien talked about sort                                 of independently if you saw his his                                 discussion and you know since you can                                 you know make the storage pluggable very                                 naturally you can if you want store                                 entities as a whole in any kind of                                 either local or remote data store I am I                                 think neither of us is convinced that                                 you need to be able to store parts of                                 entities in different locations so you                                 know we would really only see you know                                 entire entities you know store locally                                 stored remotely that should be supported                                 so in talking certain about our general                                 roadmap and how how we're going to get                                 there you know we can't do it all at                                 once obviously so the first step and you                                 know we have sort of the rough rough                                 outlines of how this code would already                                 look from San Francisco and vago was                                 already actually implemented versions of                                 this for Drupal                                                         but you basically taking that kind of                                 code and defining an API so where you do                                 all the basic you know create you know                                 load saved fleet operations for energy                                 and you start out with some kind of test                                 entity may be actual test cases my                                 simple test so that we at least have                                 confidence that these basic functions                                 work I am some kind of toy entity can be                                 loaded and saved and that's the easy                                 part right now we can basically already                                 have that code from Drupal                                               at least a working version we can argue                                 about some of the details of how the API                                 should look you know how we want to use                                                                                                   there's some interesting changes in how                                 you can use for example class methods in                                 PHP                                                              refactor some of the users in code but                                 the interesting part comes in report you                                 start porting core FG so the idea is we                                 would basically set up parallel system                                 you know so we work for a custom entity                                 and then we start porting or entities                                 one by one to this new API and you know                                 as we do this we probably want to do                                 performance testing for each qty we're                                 converting let's let's check and see if                                 you know the performance gets better and                                 hopefully hopefully not if it gets even                                 worse than we have a problem we need to                                 revisit what we're doing that kind of                                 Lee needs to be an ongoing part of this                                 cycle our hope is that actually                                 performance will get better because as a                                 i said before you basically have your                                 revoking every hook roughly three times                                 if you look at you know the load and say                                 especially the save operations for                                 example also load operations these hooks                                 are invoked extra time so we're going to                                 eliminate you know a lot of that                                 duplicated hook in vacations were also                                 going to be as we go along illuminating                                 essentially duplicated code you know so                                 we'll remove essentially be able to                                 remove large swathes of the common                                 module use a module node module all the                                 stuff that deals with you know loading                                 saving maybe even viewing those entities                                 will get removed in favor this more                                 unified version so Fargo is going to                                 talk more about his some of the details                                 but yeah I think at least you know you                                 provide some kind of viewing mechanism                                 that's generic for entities now maybe                                 that you know nodes are special                                 need you know there are versions of                                 viewing but that means that if i define                                 an entity than the baby i don't have to                                 be exactly yeah that's cydia yeah right                                 so that you make it much easier for                                 people defines what new entities as sort                                 of content and maybe you don't have to                                 use the node for every kind of data                                 source so we'll come back to some                                 questions about revisions as we start to                                 get in yeah so the first example might                                 be comment module or something intensity                                 without revisions and then it gets even                                 more interesting as we start converting                                 energy type with revisions like the node                                 module and once once all the core                                 empties are converted basically at that                                 point we can start refactoring the field                                 storage functions so right now you we                                 have all these fields attached pumpkins                                 and things like that that are in the                                 various load and save hooks and so we                                 would reef after those and move that the                                 code relevant there into the entity                                 basically storage controllers right so                                 there would no longer be a separate way                                 to load and save fields that's a                                 distinct from the way that you load and                                 save an FC so status so basically pago                                 and catch have actually started on some                                 of this the first step is which looks                                 like we need to reroll a patch to move                                 into the api into a module and really                                 this is just moving code around and for                                 so a lot of the NPAPI stuff in drupal                                   end up in system module just because                                 that's the dumping ground for new code                                 so yeah as the first step to sort of you                                 know having a clean place to work on                                 this kind of api that we move move all                                 that code that's really just moving                                 things around we should be able to get                                 that in pretty soon and then there's                                 a work in progress not not yet you know                                 ready to review or you commit it's                                 basically just a part of the stuff of                                 the entity by modeling in into /                                     plate and just the start of refactoring                                 that's                                                                 want to have later on so it's working                                 borders but it already basically works                                 but it's ya need to work so you know at                                 least we do have inertial start and once                                 you know once this first one is done                                 then really the basic crud operations I                                 mean that's that's where we're defining                                 the API and that's where we will need to                                 make some of the architectural decisions                                 about how we use our how we break up the                                 code and other things like that but I                                 think it would be interesting so one of                                 the questions if you remember from                                 Chicago we discuss here should we have                                 in a na p I that presents a a crud                                 interface to developer or a crap                                 interface to the phone so if you weren't                                 there the difference is crud is create                                 read update delete and crap is create                                 read append purged and the distance is                                 in a crap model I think it's isn't it a                                 FF touch I'm not true i think it was                                 positive pent i was it off of archive                                 okay archive verge but so two                                 differences i mean busy in the the crap                                 model we we generally assume that we're                                 always making revisions of you know so                                 we never actually update in place and                                 instead of deleting anything we we                                 basically archive it and we might purge                                 it later actually delete it from storage                                 but that the delete isn't an immediate                                 operation now you could make crap look                                 like crud to the developer right you                                 don't have to tell the developer that                                 you archiving you you can have a                                 function called delete and behind the                                 scenes it just you know Flags it and                                 doesn't actually delete it I think one                                 of the questions either we as a                                 community need to decide is what what do                                 we want the API to look like we actually                                 want you know a function called you know                                 archive or we'd rather have no delete I                                 think people i think you know under your                                 deletes is one i think one will discuss                                 later as if let's say you're                                 synchronizing content between sites it                                 might be better to synchronize the fact                                 that you've archived this node rather                                 than trying to keep track of which notes                                 you've deleted right so you're basically                                 synchronizing the current state of the                                 node as archived rather than trying to                                 keep track of the fact that you deleted                                 it and also it's basically a different                                 approach to the whole divisions work                                 because you trust created a vision every                                 time you you ate it update something and                                 you don't have to specifically say okay                                 now I want to create a new division the                                 code Elvis started so yeah                                 it's not just going to be so when                                 contained you mean like using like a                                 reference or term reference field or do                                 this well way but the food the fields                                 never contain entities today I mean                                 having the least normally I think you                                 use reference yeah usually you think                                 it's a live lens and interpret seven as                                 a module a few collections baby                                 basically works that way that you have a                                 collection of fields that is another                                 entity but yeah in the end it's just an                                 entity reference to so for modules like                                 that it would be actually probably it                                 would make sense to do it that way so                                 say that you create divisions of the                                 field collection serves to because for                                 the usage should work like a whole                                 entity yeah but it's good is in certain                                 case is everything would be division                                 yeah of course so you would end up with                                 some duplicated data and you would have                                 to just want more data but the idea is                                 that data isn't isn't expensive today                                 and you might want to have to data later                                 on so yeah it's nice when the data is                                 there but still you you need a purge                                 operations and yeah probably you want to                                 be able to configure how the purge                                 operation works on medical why so the                                 question is whether it's either/or                                 perversions I yes I think it would be                                 fine yes you could say that when you                                 update you always create a new revision                                 that it's I think the question here is                                 more about what we present as the                                 developer experience versus what the                                 implementation is so I mean we could we                                 could definitely say yes every time you                                 call update it creates new revision                                 that's fine and we could also say every                                 time you call delete it marks the note                                 as art as archived or they're not linked                                 directly I'm just yeah that the real                                 question is you know do we want as a                                 developer experience do you want to                                 think about archiving content for later                                 purging or do you want to think about                                 the leading it what is the better                                 developer experience or not even better                                 but like the the easier one to                                 comprehend easier to comprehend so and                                 yes then a sort of separate question is                                 do we really want to revision every                                 chain and make every change a new                                 revision or is is there ever a value to                                 updating place other than you no worries                                 about storage                                 I think you know there are cases where                                 people do insane things updating you                                 know extremely frequently I think are                                 those actually valid or that is that                                 she's broken code so if if someone has a                                 use case we're really I want to be                                 publishing and publishing my content                                 every five minutes or something like                                 that is that is that a foul a use case                                 or is there some you know should you                                 just have found a better technique that                                 whatever you're trying to achieve we                                 don't review comments right now but that                                 also means if you want to go back to the                                 state of the native these the state of                                 your site right so then right so the                                 comment is you know if you revision                                 everything included comments you you                                 potentially could go back to the state                                 of your site at some point in the past                                 at least in terms of your content which                                 may be very useful for certain use cases                                 also personally I think for every                                 developer it should be really be a cot                                 interface because this this is the                                 interface that developers know today and                                 they are used to using it I think it                                 would be just a another to police me if                                 you would just have archived and not                                 delete and and we would have to teach                                 that to all the developer so I'm much in                                 phase a favor of a call interface and I                                 think still if you have a car interface                                 for developers we could implement crap                                 indentity controllers if you wanted so                                 we could have got and cut                                 complicated but having making it not be                                 a choice would I think be good just                                 based on this whole leg issue summary                                 thing creeping through the keen about                                 that but you know endo you can update in                                 place or you can make a revision and it                                 weighs on the entity level but that                                 don't have a separate API for updating                                 place versus revision just like for one                                 entity it's one way or another it's                                 another way of it right so Jennifer's                                 saying a single entity should not have                                 both the options regardless of so yeah                                 but I think if you repeat the question                                 so so so ken is saying revisions can                                 make things really complicated for                                 something like access control if you                                 have different taxonomy terms on                                 revision                                                                so and ken saying so for example if I                                 want to feel that really controls note                                 access perhaps I don't want revisions on                                 that field I want it to be the same                                 across all revisions so that if the                                 current user can see the current node                                 they could also see all past visions of                                 that node basically                                 yesterday was if we decide to go to                                 everything's revision all the time we                                 can solve that problem that prom so                                 right so what are the input yet so if we                                 go to revisions all the time how do we                                 how do we solve this problem activity I                                 haven't thought about it too much I mean                                 I think the easiest case is you pay                                 something like X has control off the                                 current published revision or something                                 like that for all the past revisions but                                 don't use cases for saying the access                                 controls should change based on                                 revisions today sorry the access to the                                 current node is going to be based on the                                 current state state of all of the fields                                 right so ken is saying he five passes                                 his problem in Drupal                                                    tables and not using entity or feels                                 horrible I mean menu the venue suspends                                 the same drop right menus adds all that                                 non-religion no property data is the                                 exact same issue                                 bread so so part of the problem is also                                 things like pass on a node that you                                 can't revision necessarily because the                                 the link that it's referencing is not                                 revision along with it so many links and                                 path aliases are you asking should they                                 be entities or are you saying yeah good                                 question I mean the yes probably links                                 should probably entities I mean they are                                 in this sense data they really you know                                 you can you can delete every menu link                                 and your site still works right same way                                 you could delete every now that the                                 sites to work she can move half aliases                                 I don't know I've you I haven't fought                                 personally about it but I'm buy into it                                 my intuition would be not to make them                                 entity entities but um I must say I                                 haven't really gave it a fault so we                                 would have to Denis that definitely will                                 need to some discussion on what we know                                 that we would have to need a look at                                 that yeah okay I think we should move on                                 yeah yeah okay we're close to the end of                                 the mean it's basically generation that                                 yeah fungo is going to be more up                                 selling it yeah m the second half so                                 it's basically continuing for food so                                 also we are great talk just about you                                 you IDs so we even if we're not focusing                                 on that initially clearly we have to                                 have that in the back of our mind as you                                 know how we handle you IDs so for the                                 sake of simplicity and speed probably                                 most operations like the load operation                                 the default                                 that will be to use integer because if                                 you're coming into a page path you're                                 going to have integer ID handy you don't                                 want to have to go through the extra                                 step of looking at you you ID but                                 clearly we're going to need to implement                                 you'd have load functions that take a                                 uuid either for you know a in entity or                                 for specific empty revision and one you                                 know thing here is again if we're doing                                 revisions is there any use for having an                                 integer ID for each revision or should                                 we just have uuid so if you think again                                 about reference fields generally only                                 reference effectively the current                                 revision which is the shortcut to the                                 crocker vision is integer ID so maybe                                 there's no real cost to only using you                                 IDs for the reference or revision and                                 that would make the code kind of simpler                                 you know if you're trying to load a                                 revision you always get a very specific                                 thing based on its uuid rather than                                 getting something that might be                                 different on one side versus another                                 site so you know again part of where                                 we're going with this is to move to                                 utilizing more the oil features so you                                 know we think about having a base class                                 that implements some kind of interface                                 right that would be common for                                 everything in core every core entity                                 would do this and that once we do that                                 we can start again defining specific                                 classes for each entity type so a node                                 class a common class the user class                                 whatever class you want and that would                                 you know either probably extend the base                                 entity class in a lot of places or at                                 least implement this interface so that                                 we always knew we can always check that                                 you know object we're dealing with                                 implement the right interface and more                                 specifically                                 right so we don't have standard cleft                                 out anymore that means we can do                                 actually better checking out our data                                 right so you could do all right we'll                                 skip ahead here so in vacuo if you have                                 an operation that you don't leave                                 operate on a node you can you can type                                 hint in PHP right and then PHP will you                                 know throw an exception or fail I figure                                 what kind of fatal error gives you if                                 you pass a standard class into this it                                 no longer works well this is just an                                 example so you know if you have as some                                 kind of function or some kind of method                                 that requires that only operates on                                 nodes you know as the suggestive yeah I                                 don't think that you should do any other                                 medals on note beside the medals in the                                 entity interface because the entities                                 really represent all our data into open                                 unleash so that the object itself also                                 should also only deal with about the                                 data so they are really the                                 representation of our data model and if                                 you think about it it's also the only                                 way the only way it can work because to                                 police modular and any any module may                                 provide are a lot of functions that work                                 with notes and you won't be able to to                                 get those all in the class anyway so                                 it's really the only weight is                                 consistent across all modules and I                                 think it's yeah pretty much fix fits to                                 the vision of having entities                                 representing your your data and loop                                 around not having entities to deal with                                 anything or everything and let's see if                                 we back up i think there's one more                                 discussion point we wanted a it may one                                 back yeah okay so there are a couple                                 more discussion points we won't have I                                 mean this is cork conversation so so                                 when we think about having an entity                                 interface we're basically building on                                 what we have a Drupal                                                 there is sort of a controller and the                                 controller actually it's not the the                                 entity class                                 that does the heavy lifting it's a                                 controller and this is a abstraction                                 that's a little confusing when you see                                 it but the value for this especially as                                 we move forward is that we can have you                                 know standard controllers to define a                                 new entity I mean and Drupal                                           does this you define a new energy type                                 you already have a default controller                                 which already handles storage already                                 handles load save all these other things                                 for you you don't have to you know embed                                 all of that code in a default to entity                                 class that everything else is extending                                 and you know one one thing we're                                 thinking about for Drupal                                              actually split this up a lot more so                                 there's for Drupal                                                       one controller for for each entity type                                 and it handles every possible operation                                 in the sort of crud cycle whereas for                                 Drupal                                                               make this more granular so we have                                 different controller for storage for                                 caching for display for maybe building                                 an edit form maybe a different control                                 of her access that entity and by                                 hair-splitting that up it would make it                                 easier to customize the entity bad                                 basically you know substituting a                                 different controller it's a question                                 will every entity be comment to bowl Oh                                 could be eyes I didn't Drupal                                            in dopest                                                            Drupal                                                                  the way to making comments basically                                 reference fields so I think that's                                 that's sort of a side issue to this but                                 I think you know that might you know                                 feed him to the display controller you                                 know maybe just play nice now if it                                 pulls you know a referenced comment                                 thread the idea of that is basically                                 related to you only need to have the                                 storage controller that all other                                 controls are optional                                 so you know you have methods too deep                                 with your data and then you have an easy                                 way of enabling more controllers you can                                 enable display control of one controller                                 access controller and so you can easily                                 provide entity types that's do more to                                 win or do less house and then awesome if                                 you are implementing your entity type                                 when you're implementing the form or the                                 display you can overwrite an extent                                 controller to do your customizations in                                 that way so that brings us sort of the                                 next discussion point which this is                                 really an open question I mean we're                                 discussing and don't have an answer                                 whether when you want to customize                                 energy type do you want to focus the                                 customizations on the entity class or on                                 the controller and an example of this is                                 I guess comment module where it does                                 some manipulations of the data on the                                 comment i think it may be calculates the                                 threading some other things during the                                 save operation so should that kind of                                 special logic should that live in the                                 comment class or should that live in the                                 comment storage controller now you know                                 there's sort of arguments both ways so                                 if you put it in the storage controller                                 maybe you end up having to cut replicate                                 that code if you define a new storage                                 for comments if you put it in the                                 comment class you know it means you're                                 kind of carrying around more more code                                 with comments I don't know what was the                                 other you felt like there's some                                 downside to this hmm no it actually                                 can't think of any don't forget you know                                 there's yeah so this is maybe not too                                 obvious downsides but but it means that                                 the the these entity class is moving                                 move from being sort of a pure semantic                                 thing                                 are they they just sort of reference                                 their controllers and have some yeah                                 maybe property maybe the Dons it is that                                 it's a little bit split up between the                                 entity class and the controller which                                 cares about the storage right so Tomas                                 right so Thomas says another downside is                                 you can't have sort of an external                                 function that really invokes a save for                                 an entity which you might want to do as                                 a programmatic operation you would                                 always end up going through class method                                 or an instance method again yeah it's                                 not clear that this is downside because                                 maybe every time you save an entity you                                 need to instantiate it in anyhow so then                                 you have the instancing you call save on                                 it but you know it is a potential                                 downside if we want to have sort of                                 functional functional forms of a lot of                                 these things where you can just call                                 something like energy save rather than                                 calling you know dollar node you know                                 save I think the main advantage of                                 putting the customizations in the entity                                 class would be that it makes it easier                                 to make the storage controller pluggable                                 but but if we really would go into the                                 direction of the document oriented                                 storage like demon who posted it might                                 be not necessarily the order to have to                                 control us bloggers brother so that's                                 definitely a point you need to net                                 discuss follow yeah I think one more                                 thing we were discussed before faggle                                 moves under his selection which was yeah                                 just a little more about documentaries                                 storage and kind of thinking ahead                                 drupal                                                                   the document orient storage is the right                                 answer and the way we're going to move                                 then there's no reason we can't have                                 different fields for each instance of an                                 entity                                 so you could decide you know a                                 particular node gets a file fueled and                                 no other nodes of that node type have a                                 file field for example and is that you                                 know how valuable is that is that you                                 know does that make things so difficult                                 we want to don't want to go there or is                                 that add such great flexibility and                                 really is that much better than sort of                                 the bundle system we have now where                                 every node is constrained to have                                 exactly the same fields so I think you                                 know that's that something Damon didn't                                 really mention with document storage is                                 actually really important implication of                                 using doctrine Orion storage versus                                 relational storage we use now for                                 entities and so we can discuss an hour                                 or we'll just leave you with this                                 thought and ya want them yeah okay so I                                 think we just before okay so um I'm                                 about to shortly talk about the entity                                 poverty I so if you think of an entity                                 in the Upper                                                            to enter the object in code and you just                                 know it's an entity and you don't really                                 know its its type so the problem is if                                 it you can't really do a lot of it right                                 so you inquire if you if you know the                                 entity type here you can do some stuff                                 like getting the label the UI and also                                 it would be nice to save it once we have                                 the dakar thing in Drupal                                             proposed stuff we talked earlier about                                 it basically we would be able to do                                 stuff like that but still we won't be                                 able to do I have a look at what is                                 inside the entity so if you have an                                 everyday entity object here I think it                                 would be really important so that you                                 are able to get a list of older the                                 properties the entity head yes so you                                 can actually do something with the                                 poverties so you need to be able to get                                 some information about the power is and                                 also they need to be                                 handy little getters and setters that                                 they allow you to do to get and set the                                 property values before okay Jennifer                                 asked but a property actually is and                                 when I'm talking about an entity poverty                                 I mean it's something that is not a feed                                 like and not status not offer so but                                 what my particularly is a bottle is                                 making that poverty is more powerful and                                 making them more similar to what a field                                 is actually not that much difference                                 between those so yes that way I think on                                 a field should be a poverty too so that                                 it's really working the same way so when                                 you have a look at the getters and                                 setters I think it really it's really                                 important that developers can use them                                 for feeds and for properties the same                                 play and additionally if you look at the                                 example just get me in and poverty you                                 need to know somehow what you are                                 getting so you need to have to have in                                 poverty information which tells you what                                 is the data type you are getting oh and                                 is it the user is it Justin know me I                                 caddy your stuff like that you really                                 need to have some ADA information about                                 it and I also think it would be nice to                                 have some labels and descriptions                                 included for some modules that make use                                 of the poverties in in some UI so uh                                 actually there's some discussions we had                                 with catch and clara but if you want to                                 do some lazy loading of entities and                                 wherever you want to use some metric to                                 trigger than the lazy loading so in PHP                                 you could implement an magic function                                 underscore underscore cat which one is                                 automatically invoked if you access an                                 entity poverty that is not there so that                                 way we could actually do entity objects                                 that are not loaded so they can contain                                 only the entity                                 d and as soon as you access the poverty                                 it automatically gets loaded so you                                 don't that way you don't need to pass                                 the entity ID and the entity type around                                 anymore you could just instance ate an                                 object which only contains the ID n is                                 not loaded yet and pass it around so we                                 would have a more uniform API and                                 developers don't want don't have to take                                 any more about specifically loading a                                 certain entity if the only have the idea                                 is it loaded yet or not yeah the                                 question is it doesn't eat imply that we                                 don't only together and set us anymore                                 to some extent yes but internally they                                 still would use togethers and setters                                 and also I'm not really a big fan of                                 that idea because it really makes it                                 difficult to detect the code flow and if                                 you just success in poverty you are not                                 really you can't be the issue of what                                 happens and if the developer does that                                 he might not be aware of the fact it                                 might trigger some loading somewhere                                 else so I think we need to be careful                                 with that and also on it might do to                                 lead to some unexpected consequences if                                 you just write an avid le poverty you                                 funny bit identity and its biggest some                                 code or somewhere else you don't expect                                 it and it really can lead to some                                 strange side effects so what we came up                                 with is that we want to restrict that to                                 the list of defined poverty's so this we                                 are important that we have something                                 like and hook entity poverty info that                                 makes it impossible to define the list                                 of what is this the list of properties                                 that are actually available then we can                                 restrict the magic to that also                                 additionally it would be just                                 the default way of getting and setting a                                 poverty to directly access it but if in                                 more advanced situations like when you                                 need to get a bob with your feet in a                                 certain language or stuff like that it                                 would be nice to have a gather where you                                 can just specify the language option yep                                 same place loading yeah it's not clear                                 whether it's actually a good                                 optimization so probably postponed Intel                                 everything else is working yes p                                 dimensions it's not clear whether it's                                 good yeah and actually good idea to do                                 and yeah it's very trust an open point                                 for discussion and I'm not anything we                                 are sure we should implement I'm not                                 true of unscented fashion both what is                                 it saving you to do is basically that                                 you don't have to care about whether you                                 pass another entity ID or fully loaded                                 entity objects so for the the code that                                 it's getting cold you don't have to pay                                 any more so that's the main advantage                                 and that way you could actually end up                                 with some optimizations that you pass                                 around an entity objects that actually                                 in the end you'd never gets loaded                                 because some Court decides our I don't                                 want to deal with that entity anymore                                 and just keep loading it at all so that                                 way it might lead to something for                                 performance improvement although there                                 are two different ideas of implementing                                 that so catch came up with the idea of                                 having it managed by the controller so                                 that in the end each time you                                 instantiate an entity object it releases                                 it at the controller and then if loading                                 an entity                                 act is triggered the controller are just                                 starts and actually loads all that                                 entities that have indicated in the in                                 the controller so it if there's a page                                 and three nodes would be used in that                                 page and as soon as the the first node                                 would be loaded the controller would be                                 able to do an entity load multiple for                                 that word written lead some performance                                 improvement personally I'm not sure                                 about where ever you should do it                                 because it might be a bit strange of you                                 are using a single node and you're                                 loading a single node and somehow                                 multiple nodes get loaded and all the                                 hooks fire up so it might be a bit                                 unexpected for developers so a different                                 approach would be that we do it only in                                 a more declarative way so that we have                                 something like an entity set class which                                 allows you to get an object which                                 basically represents an array of                                 entities but which are not loaded                                 immediately butter lazy Lolita C soon as                                 soon as you use a single entity of the                                 set okay and in regard to properties                                 it's really important to cover some                                 additional metadata so if you think                                 about what you want to do with an entity                                 and what we want to do to be able to do                                 with an entity I think it's also good                                 idea to think of Drupal as an arrest so                                 if you have each entity as an Alaska                                 source but you need to be able to do and                                 what do you need to be able to to know                                 about the entity in order to make things                                 happen so if you want to update an                                 everyday entity you really need to know                                 is the current user allowed to do the                                 update so you really need to have                                 poverty level excess metadata so you                                 know who is allowed to change the node                                 order or not and so on and we basically                                 have to read now for feeds but I think                                 we really need to have accommodate by                                 for that for all properties and the                                 various invades for validation if                                 you updating about their identities                                 based on the in the journal fashion we                                 really need a validation a pair that is                                 decoupled from form validation but works                                 generally so you could still just a web                                 service called a safe an entity and if                                 the data doesn't fit it needs to give                                 you an L so we definitely need                                 invalidation API for that so we can                                 handle that we probably probably want to                                 look into how we can make a good                                 validation API that works well for for                                 form validation to but is decoupled from                                 form validation and then there's also                                 the need for having translation for                                 properties so I think it's a would be                                 really important to have each poverty                                 being able to be mark this translatable                                 so that's basically it behaves like a                                 translatable field and all applies need                                 to be aware of that fact and needs to                                 take it in the count so the yep yep it's                                 it's really much be a similar to fields                                 and I'm going to talk about it later on                                 as well ok so in Drupal                                        implemented lots of them in the entity                                 api module and it basically has some                                 support for handling access validation                                 and also it has a simple marker for                                 translation for all entity properties so                                 you could basically implement lots of                                 stuff of that already by implementing                                 the entity poverty information if you                                 have the entity a pair module in                                        really the problem with it it's it's not                                 native it's just an additional layer                                 above the entity system we have the core                                 and we really you want to use the                                 tentative web provides as its disarm                                 some sunglasses that's web to enter the                                 objects that allow you to make use of                                 the API easily so it's really more a                                 separate system built on top of the                                 quantity quantity of epi we have and I                                 think it's working already pretty well                                 but the polymer is just yeah it's not                                 native we have weapons and we don't want                                 to have that we want to have tonight                                 with api out of the box so this is how                                 it looks like                                                     information away for an not graded                                 poverty and icici it's basically                                 specifies in labor and the day and type                                 so the type of it the state and was                                 really important years that actually                                 it's documented and defined somewhere                                 how did the data of a certain type looks                                 like so I've just for the entity family                                 for seven I've just specified date has                                 to be timestamp so any one who who gets                                 the date knows what he is getting and                                 actually can do something over then                                 there's also some additional metadata                                 like Sarah Cole back and that specifies                                 how the data is actually set on an                                 entity and the permissions and                                 description and stuff like that dear so                                 for the data types I think it would be                                 important that we have something like an                                 hook that also specifies the data types                                 to dial available systems and that the                                 hook and the system has to come with a                                 set of we define simple data types that                                 basically for the entity my journal /                                   i've took the data types that are very                                 similar to xml xml schema schema because                                 it's a set of data types that is                                 powerful enough to basically depict any                                  data you need then you also want to have                                  entities as supported as regular data                                  types you can just say oh it's a user                                  entity and we also need to have                                  something like complex types or data                                  types this compound and build off of                                  multiple other simple data types like if                                  you think of a file field it actually                                  has a file in the description on stuff                                  like that so this actually is some kind                                  of an data structure that exists of our                                  RS data types                                  and also built up in the data types we                                  can also build RIE pies so if you think                                  of the storage a pie or display a pie on                                  forms a pie so I think of the Denman                                   api and or whether something is                                  competitive with something other so that                                  idea poverty is compatible with a                                  certain plug-in with a certain this                                  weblog in a widget plugin really should                                  depend on the plot with the information                                  than particular on the data type so once                                  we have a specified set of poverty                                  information we really can build lots of                                  components that are designed to work                                  with a certain kind of data and nice                                  fiendin actually is that you can give it                                  any kind of data that fulfills the                                  defined interface and it just works ok                                  so let's have a look about how                                  translation would work another tier so I                                  think it really needs to be built in so                                  that any poverty can be marked as                                  considerable as I said previously then                                  also the together and Sarah fertility                                  support on an optional language key so                                  you can get and set and probably in a                                  certain language if you want but we                                  really need an easy way to access and                                  set the default language by default so I                                  think if you just access the poverty on                                  the entity level it always should make                                  use of the default language regardless                                  whether so you don't have to deal with                                  it like where are the properties                                  translatable or not if you don't want to                                  have to if you don't want to care about                                  that but if you want to access its own                                  language of an inflatable poverty you                                  still can use the dedicated getters and                                  setters to get to get and set the values                                  you know yeah I think we Peter asked                                  Peter off Twitter this should work for                                  feeds to yes and I think it's really                                  important that we should make it work                                  that way for fields too because I'd not                                  necessarily a developer experience issue                                  that we always have that deeply nested                                  data structure and they really should                                  make sure that is as easy as possible                                  for developers what does work with the                                  current context language no I think                                  there's something like an interface                                  language and like in content language                                  it's sad so I think a different kind of                                  languages and probably the entity type                                  might want to have videos specifying                                  what kind of let me she wants to use but                                  basically I think we want to use the                                  content language for that okay so this                                  is how I would imagine that this                                  actually could work and play together so                                  we have an unhooked that defines poverty                                  information and it defines how the                                  entity properties actually look like and                                  thats basically would be the contact for                                  everyone that uses an entity so that the                                  storage system really would have to take                                  care about loading or storing entities                                  that look exactly that way and then also                                  all other systems that do something with                                  an entity would also know what they                                  expect the eggshell actually really                                  would know okay this is the way the data                                  looks like and this is the way the data                                  has to look like when I want to divide                                  it back so we could be good to the                                  display components and form components                                  that are really make use of that                                  metadata and work exactly with the data                                  as it is specified and actually nice                                  veneer is that we could start doing                                  display and form components like we have                                  them for the field API and work them as                                  and make them work on top of the defined                                  property information so we could go and                                  started lee using that Pichet and                                  display for models also for regular                                  entity properties if we are able to                                  decouple it and if you just say okay                                  they need that kind of certain data we                                  can use them with any data and so we                                  would be able to use them not only for                                  fields but only for our API level yes                                  close glossy asks whether one heads to                                  has to implement took schema anymore                                  manual if one implements hook in the tip                                  of it info and yes I think we should do                                  it that way but it really depends on the                                  entity controller we built so in the                                  first step we might be easier that that                                  we have it just duplicated just as an                                  interim step during development but the                                  end in the end I think we really want to                                  have just the hook entity poverty in                                  from which the storage controller can                                  derive all the necessary information                                  first door on it ok so don't have much                                  time anymore but on storage i think that                                  the important thing is that the entity                                  pod with information outlines the way                                  the data data has to look like and it                                  has to store that way that baby it would                                  be really simple to say we have                                  something like an translatable no title                                  because we only would have to care that                                  the storage clear that the entity                                  controllers stored in the airport                                  fashion and and the upper layers like                                  the deform a dozen all the getters and                                  setters really don't should have to care                                  how hard store and later if you have                                  some better automated storage system it                                  could be even be handled in an automated                                  fashion but i think the nice thing if we                                  start with an entity property                                  information system is that we could                                  could do it manually in the starting                                  trust implement manual entity                                  controllers which trusts to it similar                                  to legatus now in the delay in the long                                  of                                  we can improve things and make that even                                  work more automated yes no the question                                  is how do we make the entity controllers                                  swappable but we talked a little but                                  that early already soon I think the main                                  web know is what is in poverty noise                                  it's the same than a feed or not and I                                  think yeah if we improve the property                                  system that way it's really pretty much                                  like an improved feel dead guy but it's                                  a little more decoupled to me I have                                  fielded by the cupboard in separate API                                  totally usable independently of feeds so                                  what I think then what feeds ends up                                  being is really just another poverty so                                  if it is really just not up already but                                  which is custom and configurable soil                                  that in the way that the user is defined                                  this is a field and i have a new a new                                  image on the node and you file on a node                                  but it's not defining by module and it's                                  not required by module to work yes so                                  yeah the really important thing is                                  fields in power this the interface                                  should be the same developers shouldn't                                  have to care ok
YouTube URL: https://www.youtube.com/watch?v=dcTaWedgSK0


