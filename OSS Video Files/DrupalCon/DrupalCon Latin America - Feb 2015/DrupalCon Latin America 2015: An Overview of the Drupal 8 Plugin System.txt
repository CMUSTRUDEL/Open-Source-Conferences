Title: DrupalCon Latin America 2015: An Overview of the Drupal 8 Plugin System
Publication date: 2015-02-11
Playlist: DrupalCon Latin America - Feb 2015
Description: 
	Speakers: eojthebrave
Goodbye hook_block_info(), hello Block Plugins.

The Drupal 8 plugin system provides a set of guidelines and reusable code components that allow developers to expose pluggable functionality within their code and (as needed) support managing these components through the user interface. Understanding the ins and outs of the plugin system will be critical for anyone developing modules for Drupal 8. Blocks, field types, widgets, and views displays are just some of the places youâ€™ll encounter plugins in D8.

In this presentation Joe will draw on his experience working with Drupal 8 plugins in order to write about and helping document the plugin system, and walk through:

What are plugins and why, when, where are they used?
How Drupal discovers plugins.
Annotations and how they relate to plugins.
Defining a plugin.
Using plugin derivatives to allow for many instances of a single plugin.
Defining new plugin types in your own module.
This presentation will be useful for anyone who will be writing new Drupal 8 modules or porting existing code from Drupal 7 to Drupal 8. It will help developers to better understand where plugins fit in the architecture of a Drupal module, and help to map your Drupal 7 knowledge about info hooks and callback functions to Drupal 8 plugins.
Captions: 
	00:00:00,060 --> 00:00:04,680
I'm going to go ahead and get started. I'm going to be talking about the Drupal 8 plugin system.

00:00:04,680 --> 00:00:09,190
There are a bunch of new ways as module developers

00:00:09,190 --> 00:00:12,820
that you can extend and enhance Drupal 8's functionality.

00:00:12,820 --> 00:00:17,970
In Drupal 7, this was almost all done using the concept of hooks.

00:00:17,970 --> 00:00:22,080
Any time you wanted to change the way that Drupal did something or you wanted to add

00:00:22,080 --> 00:00:26,630
additional functionality or you wanted to mess with somebody else's functionality, 

00:00:26,630 --> 00:00:30,679
the recommended way to do that was to use a hook. In Drupal 8, we've got a bunch of new ways

00:00:30,679 --> 00:00:35,700
to handle various types of interactions. One of those, and the one that you're probably

00:00:35,700 --> 00:00:41,480
most likely to encounter first as a Drupal developer moving from Drupal 7 to Drupal 8,

00:00:41,480 --> 00:00:46,010
is the plugin system. We're going to talk a bit about that.

00:00:46,010 --> 00:00:52,070
A bit about me first. My name is Joe or eojthebrave on Drupal.org

00:00:52,070 --> 00:00:57,970
and Twitter and pretty much anything internet that was invented after about 1990.

00:00:57,970 --> 00:01:01,460
I work at Lullabot. At Lullabot, I mostly work on the Drupalize Me team

00:01:01,460 --> 00:01:07,270
doing educational stuff, trying to help take some of the more complex concepts

00:01:07,270 --> 00:01:13,289
and things about Drupal and break them down into easier to understand pieces of information.

00:01:13,289 --> 00:01:17,249
I really enjoy that, too. Things like the plugin system, which I didn't actually write.

00:01:17,249 --> 00:01:20,219
This was written by a bunch of other people

00:01:20,219 --> 00:01:24,310
that are way smarter than I am. I came along behind them and kind of read

00:01:24,310 --> 00:01:27,950
what they did and asked them a lot of questions about, "How did you do this?" and "Why did

00:01:27,950 --> 00:01:31,060
you do this?" "Let me take that information and turn it

00:01:31,060 --> 00:01:36,889
into something that's useful for everyone else so that we can all figure out how to

00:01:36,889 --> 00:01:41,869
use it." This presentation starts out pretty simple

00:01:41,869 --> 00:01:48,049
with kind of a basic explanation of what plugins are, why plugins exist, and the problem that

00:01:48,049 --> 00:01:53,229
we're attempting to solve with plugins, and then it gets really technical really fast.

00:01:53,229 --> 00:01:56,840
It's going to start out with a bunch of cute illustrations, and by the end we're just going

00:01:56,840 --> 00:02:00,779
to have slides full of code, I promise.

00:02:00,779 --> 00:02:05,799
I'm going to talk about what are plugins and why do they exist, and then I'm going to cover

00:02:05,799 --> 00:02:11,879
some of the prerequisites that you'll need to understand about how Drupal works and really

00:02:11,879 --> 00:02:16,950
about how PHP and object-oriented programming work in order to get the most out of the plugin system.

00:02:16,950 --> 00:02:20,170
Then we'll talk about, in order to really

00:02:20,170 --> 00:02:24,930
understand how plugins work, how all of the pieces that make plugins in Drupal possible

00:02:24,930 --> 00:02:28,189
fit together. I think that will help create a mental

00:02:28,189 --> 00:02:35,189
model for understanding when to use plugins and how to use them.

00:02:36,650 --> 00:02:43,040
Drupal.org handbooks says this about plugins: "The Drupal 8 plugin system provides a set

00:02:43,040 --> 00:02:49,069
of guidelines and reusable code components to allow developers to expose pluggable components

00:02:49,069 --> 00:02:53,950
within their code and (as needed) support managing these components through the user interface."

00:02:53,950 --> 00:02:56,040
The first time I read that...

00:02:56,040 --> 00:03:00,420
The first five times I read that, I was like, "What? I don't get it."

00:03:00,420 --> 00:03:05,810
I've gone through and I've underlined the parts of this that I feel are the most important

00:03:05,810 --> 00:03:12,810
aspect of what we're trying to do with plugins. There's no specific piece of code that is

00:03:13,900 --> 00:03:17,079
like, "These are plugins." Plugins is more of a guideline.

00:03:17,079 --> 00:03:22,099
It's a pattern that you can follow in order to solve a specific problem within a certain

00:03:22,099 --> 00:03:28,230
context in Drupal. Hopefully, when you write plugins, you're

00:03:28,230 --> 00:03:31,959
writing code that is reusable, and hopefully more reusable than the code that we're writing

00:03:31,959 --> 00:03:35,650
in Drupal 7. Larry talked about this a bit this morning,

00:03:35,650 --> 00:03:42,650
but Drupal's position in the larger PHP ecosphere and how that's all kind of playing out.

00:03:43,030 --> 00:03:49,319
One of the ideas is that plugins allow us to write functionality as more discrete components

00:03:49,319 --> 00:03:54,719
that we can include into Drupal, but may also be useful to other applications or other projects

00:03:54,719 --> 00:04:01,719
that we're working on. The big thing here with plugins is that plugins

00:04:02,180 --> 00:04:07,569
solve a problem in which we need to provide a user interface that allows people to choose

00:04:07,569 --> 00:04:12,269
from one or more of the many options to perform a certain action.

00:04:12,269 --> 00:04:17,549
We'll talk about what those types of actions are.

00:04:17,549 --> 00:04:20,669
Sometimes this is really complicated. Thinking through all of this was hard for

00:04:20,669 --> 00:04:23,389
me at first. It was easier for me if I could break it down

00:04:23,389 --> 00:04:27,190
into something that was non-technical and not programming.

00:04:27,190 --> 00:04:32,039
One of the ways that I've been able to explain the problem that we're trying to solve with

00:04:32,039 --> 00:04:36,729
plugins is by thinking about what it would be like to be the owner of an ice cream shop

00:04:36,729 --> 00:04:41,009
and the types of tasks that you would have to deal with on a daily basis.

00:04:41,009 --> 00:04:46,389
If you worked in an ice cream shop... Let's say my name's Drupal and I work in this

00:04:46,389 --> 00:04:51,130
colorful ice cream shop. When I show up in the morning and a customer comes in, I have

00:04:51,130 --> 00:04:54,720
to be able to do things like discover all of the different flavors of ice cream that

00:04:54,720 --> 00:05:00,919
are available in this ice cream shop. There needs to be hopefully an easy way for

00:05:00,919 --> 00:05:06,660
me to just see what are all of the options that are available that I can serve to someone.

00:05:06,660 --> 00:05:11,610
I need to make sure that there's any easy way for myself or any of my employees to consistently

00:05:11,610 --> 00:05:17,009
access that, so I don't want every single employee to have to learn a different way

00:05:17,009 --> 00:05:20,789
to scoop every type of ice cream, right? That would be so inefficient, and it would

00:05:20,789 --> 00:05:23,380
cost so much. It would be easier if every ice cream came

00:05:23,380 --> 00:05:27,880
in the same size tub and you used the same type of scoop to get the ice cream out of

00:05:27,880 --> 00:05:31,960
the tub. I need the system, or people that work in

00:05:31,960 --> 00:05:37,430
my ice cream shop, to be able to do certain things with those flavors of ice cream, like

00:05:37,430 --> 00:05:43,139
calculate how much it should cost, figure out how to serve it to a customer and so forth.

00:05:43,139 --> 00:05:49,080
The most important thing here is once someone's come into the ice cream shop and they've talked

00:05:49,080 --> 00:05:52,139
to an employee who has discovered all the flavors of ice cream, and they've selected

00:05:52,139 --> 00:05:56,479
the appropriate one to serve you, you need to know what to be able to do with that thing.

00:05:56,479 --> 00:06:00,090
Luckily, ice cream is pretty easy, right? You get it in a cone as a little ball on top

00:06:00,090 --> 00:06:02,610
and you just lick away, and it's pretty easy. Plugins are...

00:06:02,610 --> 00:06:07,270
Well, some of them are a little bit more complicated. Some of them are actually that easy.

00:06:07,270 --> 00:06:13,720
That's kind of the problem we're trying to solve with plugins in Drupal 8, though.

00:06:13,720 --> 00:06:19,030
Things for which Drupal needs to be able to generate or discover a list of all of the

00:06:19,030 --> 00:06:22,819
available options. Really common examples: Blocks.

00:06:22,819 --> 00:06:27,180
Any module can come along and add a new block or multiple blocks to Drupal, but Drupal needs

00:06:27,180 --> 00:06:33,530
to know that your module is providing a block. Field types and widgets, actions, image effects.

00:06:33,530 --> 00:06:36,740
There are tons of examples that are that same thing.

00:06:36,740 --> 00:06:43,740
Drupal says, "Hey, modules, give me a list of all of your options for thing X."

00:06:44,470 --> 00:06:47,330
In Drupal 7, this was often accomplished with info hooks, right?

00:06:47,330 --> 00:06:52,199
You would have "hook_block_info" and you would return a list of all of the blocks that your

00:06:52,199 --> 00:06:59,199
module provided, or you might do image effects. Same thing.

00:07:00,990 --> 00:07:06,770
Then once the system has discovered all of those discrete things that it can deal with,

00:07:06,770 --> 00:07:11,789
it needs to provide a user interface that allows administrators to choose one or more

00:07:11,789 --> 00:07:17,639
of the options for their specific use case. You need to be able to choose one block for

00:07:17,639 --> 00:07:21,520
the home page or the three blocks that made up the side bar on the about page.

00:07:21,520 --> 00:07:27,330
You need to choose which image effect or multiple effects you combine together in order to manipulate

00:07:27,330 --> 00:07:32,150
the image and get the thumbnail that you want. Once you've chosen them, a lot of times those

00:07:32,150 --> 00:07:36,909
things also require some amount of configuration. Plugins, same thing.

00:07:36,909 --> 00:07:41,150
Instead of having an info hook that returns a list of all of the image effects, you've

00:07:41,150 --> 00:07:48,110
now got a list of image effect plugins, but each of those plugins has some amount of configuration,

00:07:48,110 --> 00:07:54,530
the idea being that each plugin or each image effect takes one piece of known input,

00:07:54,530 --> 00:08:00,069
so an image, in this case, does whatever it needs to do and then returns some known output.

00:08:00,069 --> 00:08:05,050
As far as Drupal's concerned, it just needs to know, "I give you an image, you do something

00:08:05,050 --> 00:08:09,240
with it, and I get a different version of that image back."

00:08:09,240 --> 00:08:12,939
You might have configuration there, like if I'm going to change the color of the image,

00:08:12,939 --> 00:08:16,340
it doesn't make sense to write a plugin for every single color.

00:08:16,340 --> 00:08:20,669
You'd have millions of colors. We would all wish that IE6 was still our default

00:08:20,669 --> 00:08:26,419
browser because then we'd only have to have 256 colors.

00:08:26,419 --> 00:08:32,450
Plugins helps to solve those types of problems. What's interesting about this is that when

00:08:32,450 --> 00:08:37,310
I started thinking about it more, it kind of made me also realize that what we've got

00:08:37,310 --> 00:08:42,390
here is akin to what is often in programming referred to as a design pattern.

00:08:42,390 --> 00:08:48,300
A design pattern is this idea of having a general and reusable solution to a recurring

00:08:48,300 --> 00:08:54,820
problem in some common or given context. It's not fully written code that solves the

00:08:54,820 --> 00:09:00,550
problem every time. It's an example of: If you're in this situation,

00:09:00,550 --> 00:09:03,779
dependency injection is the right solution to the problem.

00:09:03,779 --> 00:09:09,899
If you need to sort an array, using a binary sort is the right solution in this situation.

00:09:09,899 --> 00:09:13,079
Those are all design patterns. Plugins is the same thing.

00:09:13,079 --> 00:09:17,380
It's not actually a system that's fully written and all of the pieces are there, and you just go,

00:09:17,380 --> 00:09:21,600
"All right, Plugins. It's working." It's really a pattern that describes how you

00:09:21,600 --> 00:09:27,269
can add additional functionality to Drupal. As a developer, what you need to do is learn

00:09:27,269 --> 00:09:32,700
the pattern so that you can see when it's time for me to create a block, I need to follow

00:09:32,700 --> 00:09:37,050
the pattern for creating a block plugin. If I want to add the ability for people to

00:09:37,050 --> 00:09:40,649
write plugins for my code, here's the pattern that will allow them to do so.

00:09:40,649 --> 00:09:47,490
Think of it more like a template for solving a problem rather than being the full-baked

00:09:47,490 --> 00:09:54,490
solution to the problem. Why plugins and not info hooks?

00:09:58,320 --> 00:10:02,779
There are a lot of reasons. These are some of my favorites.

00:10:02,779 --> 00:10:08,100
My absolute favorite thing about plugins is that all of the code that does the functionality

00:10:08,100 --> 00:10:13,120
is in the same place. An example of this would be if you ever wanted

00:10:13,120 --> 00:10:18,410
to create a block in Drupal 7, you'd have an info hook and "hook_block_view" and "hook_block_configuration_save"...

00:10:18,410 --> 00:10:23,260
I don't even remember all of the hook names. There are a bunch of them that you would need

00:10:23,260 --> 00:10:28,600
to implement in order to make that possible. In Drupal 8, with a plugin you've got all

00:10:28,600 --> 00:10:31,709
of the code for that specific block in one discrete class.

00:10:31,709 --> 00:10:36,529
It makes it really easy to find all of the code that is doing the various different things,

00:10:36,529 --> 00:10:43,529
and I like that. Being able to have all of our code componentized

00:10:44,089 --> 00:10:49,350
and contained into a single class or a discrete object means that the code that we write is

00:10:49,350 --> 00:10:54,850
hopefully more reusable. Again, playing into what Larry was talking about this morning,

00:10:54,850 --> 00:11:00,740
designing systems in Drupal that allow us to write code so that our code is also usable

00:11:00,740 --> 00:11:04,839
in other contexts is pretty cool. Plugins attempts to solve that.

00:11:04,839 --> 00:11:10,290
It's not yet a perfect solution. Most likely the plugin will be a bit of a

00:11:10,290 --> 00:11:15,550
wrapper around your more general PHP component, but I do feel that it's a step in the right direction.

00:11:15,550 --> 00:11:21,079
Plugins are extensible, and you don't have

00:11:21,079 --> 00:11:24,970
to copy and paste them in order to make a different version of them.

00:11:24,970 --> 00:11:30,880
A really great example of this is I recently had a project where I needed to make a slight

00:11:30,880 --> 00:11:34,740
change to the way that the image field in Drupal 7 worked.

00:11:34,740 --> 00:11:39,290
Basically, I needed to add some links right under the field that would allow you to manipulate

00:11:39,290 --> 00:11:43,230
the image a bit. There wasn't an easy way for me to just hook in.

00:11:43,230 --> 00:11:45,399
There was no hook that would allow me to get

00:11:45,399 --> 00:11:49,910
in there and add the links to do just what I wanted to, so I go, "Okay, I guess I'm going

00:11:49,910 --> 00:11:56,910
to have to make Joe's awesome advanced image field instead of just the regular image field."

00:11:57,149 --> 00:12:02,040
I copied the image module and I renamed it to "image advanced," and then I went through

00:12:02,040 --> 00:12:07,300
and I renamed every function in there to "image advanced" as well because that was really

00:12:07,300 --> 00:12:13,570
the best way for me to extend Drupal 7's image field.

00:12:13,570 --> 00:12:17,660
Fields in Drupal 8 are plugins. The image field type is a plugin.

00:12:17,660 --> 00:12:21,260
If I want to do something different, that plugin is just a class.

00:12:21,260 --> 00:12:27,170
All I need to do is make a new class, "Joe's awesome image," that extends Drupal 8's image

00:12:27,170 --> 00:12:29,889
field. Make the one change that I needed to and the

00:12:29,889 --> 00:12:34,170
method that I needed to change something, and I inherit all of the rest of the functionality

00:12:34,170 --> 00:12:37,889
from the existing plugin. It makes those things that are plugins much

00:12:37,889 --> 00:12:42,610
more reusable. There are some other benefits, too.

00:12:42,610 --> 00:12:46,660
Plugins are lazy-loaded into the system, so Drupal knows about all the plugins,

00:12:46,660 --> 00:12:52,230
but it won't actually load and execute the code unless it needs to versus Drupal 7 where you would

00:12:52,230 --> 00:12:56,980
have to put all of your hook implementations inside of a .module file, and that module

00:12:56,980 --> 00:13:00,940
file would have to be loaded on every page request just to make sure the function was

00:13:00,940 --> 00:13:07,940
there when Drupal does that "if function exists," my hook name, and then execute the code.

00:13:09,310 --> 00:13:16,310
That's kind of the awesome about Plugins. Before you can really get into writing a plugin

00:13:20,029 --> 00:13:26,610
yourself or creating a new plugin system within Drupal, these are some of the things that

00:13:26,610 --> 00:13:30,310
you'll need to be able to do. Actually, not some of them.

00:13:30,310 --> 00:13:34,089
These are the things that you'll need to be able to do in order to write plugins.

00:13:34,089 --> 00:13:38,420
You're going to need to understand the PSR-4 standard.

00:13:38,420 --> 00:13:42,449
We'll talk about that briefly. You'll need to understand Drupal's annotations

00:13:42,449 --> 00:13:46,250
or, rather, Doctrine's annotations and how Drupal uses them.

00:13:46,250 --> 00:13:52,310
You need to understand the concept of dependency injection, and if you want to write a module

00:13:52,310 --> 00:13:56,759
that adds a new plugin type so someone else could write plugins to interact with your

00:13:56,759 --> 00:14:01,350
system, you'll also need to know how Drupal's service container works.

00:14:01,350 --> 00:14:05,759
Contrary to popular belief, you do not actually need to know how Symfony works in order to

00:14:05,759 --> 00:14:09,670
write plugins. I bring this up because initially I think

00:14:09,670 --> 00:14:14,130
people were very convinced that in order for me to be able to do this, I also have to know

00:14:14,130 --> 00:14:16,589
how Symfony works. Not true.

00:14:16,589 --> 00:14:20,980
It certainly helps because Symfony uses all of these same concepts for things that it

00:14:20,980 --> 00:14:27,980
does, but it's not a requirement. Real quick, PSR-4 is a PHP standard that allows

00:14:32,170 --> 00:14:35,620
you to have systems that know where your code lives.

00:14:35,620 --> 00:14:41,680
Basically, it's a convention for the way that you name a class, and then based on the name

00:14:41,680 --> 00:14:47,600
of that class, where in the file system you should place the code so that at run time

00:14:47,600 --> 00:14:52,589
when PHP needs to instantiate that class, it knows where to find the file and load it up.

00:14:52,589 --> 00:14:55,230
It works like this:

00:14:55,230 --> 00:15:00,940
You've got the concept of a "VendorNamespace," a "SubNamespace," and a "ClassName,"

00:15:00,940 --> 00:15:07,649
so in your code you need to use the appropriate namespace for your class, and then based on

00:15:07,649 --> 00:15:13,769
that namespace, the code goes into a certain directory within your module.

00:15:13,769 --> 00:15:19,430
I won't go super in depth into how all of this works, but the idea is that what you're

00:15:19,430 --> 00:15:23,829
doing is you're putting the code that you write into a place that it can be automatically located.

00:15:23,829 --> 00:15:28,920
I guess the Drupal 7 way of doing this would

00:15:28,920 --> 00:15:34,449
be, in your .info file, you'd have to add "files," opening bracket, closing bracket

00:15:34,449 --> 00:15:41,310
equals "path to the file." In Drupal 8, you don't need to do that, but

00:15:41,310 --> 00:15:44,370
you do need to make sure the code is placed in the right place.

00:15:44,370 --> 00:15:50,279
This is important with plugins because this sub-namespace here becomes important.

00:15:50,279 --> 00:15:55,470
The type of plugin that you're writing... If you're writing a new block plugin,

00:15:55,470 --> 00:15:59,860
for example, it will dictate what that sub-namespace needs to be.

00:15:59,860 --> 00:16:06,860
Your class, if you're writing a block plugin, needs to be in the "plugin/block" subnamespace

00:16:08,120 --> 00:16:13,440
in order for Drupal to find it and make use of it.

00:16:13,440 --> 00:16:16,949
More information here. I'll make sure all the slides are available

00:16:16,949 --> 00:16:21,430
and links as well. You need to know a little bit about how annotations work.

00:16:21,430 --> 00:16:25,190
The reason that we use annotations in the

00:16:25,190 --> 00:16:31,980
plugin system is primarily to provide metadata about our plugin for Drupal.

00:16:31,980 --> 00:16:38,440
The scenario is when you go to the block administration page, Drupal needs a way to list all of the

00:16:38,440 --> 00:16:44,750
available blocks in the system, so this is part of that discoverability aspect of Plugins.

00:16:44,750 --> 00:16:50,630
In order for it to be efficient, rather than having to load every single plugin class and

00:16:50,630 --> 00:16:56,420
create a new instance of that object and run some code, Drupal actually just reads in these

00:16:56,420 --> 00:17:02,269
annotation blocks that you'll find at the top of a plugin, and it gets some of the metadata

00:17:02,269 --> 00:17:06,950
that it needs from those. The idea of our plugin, usually things like

00:17:06,950 --> 00:17:11,970
the title and a human-readable label, things that you'll see in the user interface that

00:17:11,970 --> 00:17:15,900
kind of allow an administrator or someone to say, "Oh, yeah. That block. That's the

00:17:15,900 --> 00:17:22,900
system information block," without having to actually run any of the plugin's code.

00:17:23,300 --> 00:17:29,690
Drupal uses Doctrine's annotation parsing system with a couple of enhancements in order

00:17:29,690 --> 00:17:35,980
to allow for translation of labels and stuff. You can see here in this example, it's showing

00:17:35,980 --> 00:17:40,460
the admin label for a block. That is the title that will show up on the

00:17:40,460 --> 00:17:45,110
administration page for someone who is choosing which blocks to display, and we wrap it with

00:17:45,110 --> 00:17:52,110
this @translation construct, which allows the multi-language system to allow that label

00:17:53,470 --> 00:17:59,100
to be translatable. Taking the time to understand a little bit

00:17:59,100 --> 00:18:06,060
about how annotations work is important. Later on, we'll talk about how you know what

00:18:06,060 --> 00:18:11,040
information to put in an annotation, depending on the type of plugin that you're creating.

00:18:11,040 --> 00:18:17,420
You'll also want to know a little bit about dependency injection in order to deal with plugins.

00:18:17,420 --> 00:18:24,370
Again, I'm not going to go too far into this.

00:18:24,370 --> 00:18:29,620
These are all topics that I could probably talk for 45 minutes about how each of these works,

00:18:29,620 --> 00:18:33,290
but I want to give you this information so that you can spend the time to brush up

00:18:33,290 --> 00:18:37,890
on it before you start getting into writing Drupal 8 plugins.

00:18:37,890 --> 00:18:43,100
Dependency injection. I've got the same bit of code here or two

00:18:43,100 --> 00:18:50,100
different ways of writing the same functionality. The one on the top is a not injected class.

00:18:50,710 --> 00:18:57,710
The idea here is that my code, in this case, is creating a new instance of the database

00:19:00,770 --> 00:19:04,860
object that it's going to make use of. I know I'm going to have to query the database,

00:19:04,860 --> 00:19:08,310
so inside of my code I said, "Cool. Give me a new database instance."

00:19:08,310 --> 00:19:15,040
This, however, is now hard-coded into my plugin. There's no way for someone else to come along

00:19:15,040 --> 00:19:19,950
and say, "Actually, block plugin, I want you to use this copy. I want you to connect to

00:19:19,950 --> 00:19:25,000
a Postgres server instead of the MySQL server," or whatever the case may be.

00:19:25,000 --> 00:19:31,550
The version on the bottom uses what's called dependency injection, which is a really complicated

00:19:31,550 --> 00:19:37,400
way of saying passing in the objects that you're going to use as arguments instead of

00:19:37,400 --> 00:19:43,920
instantiating them inside of the class. This one here, I've got two lines where I've said,

00:19:43,920 --> 00:19:50,330
"Create a new MySQL database object and then create a new instance of MyClass

00:19:50,330 --> 00:19:56,250
and pass in the database object." The benefit of the latter version is that

00:19:56,250 --> 00:20:00,790
some other code could come along and say, "Actually, in this case I want you to use

00:20:00,790 --> 00:20:07,230
a different database object," and as long as it conforms to the same interface,

00:20:07,230 --> 00:20:11,780
the plugin will know how to deal with that. That's a good thing to learn about.

00:20:11,780 --> 00:20:16,950
The thing is dependency injection is really easy when all you're doing is injecting one dependency,

00:20:16,950 --> 00:20:21,240
but most things in Drupal are dependent on all the other things in Drupal,

00:20:21,240 --> 00:20:25,240
so you very quickly end up in the scenario where not only do you need to create a copy

00:20:25,240 --> 00:20:31,970
of the database, but you also need one for form API and the plugin manager and the requests

00:20:31,970 --> 00:20:37,290
and the response services and so on. It can be really hard to map all of those dependencies.

00:20:37,290 --> 00:20:40,890
Drupal has this service container.

00:20:40,890 --> 00:20:45,800
What the service container does is it's basically smart about what the various services you

00:20:45,800 --> 00:20:49,910
might need are. I need the database service to make a query,

00:20:49,910 --> 00:20:53,720
and it says, "Cool. That database service? That's dependent on these other things, so

00:20:53,720 --> 00:20:58,400
if you ask me for a copy of the database service, I will also make sure that those other things

00:20:58,400 --> 00:21:02,800
are present." This is another instance of something that

00:21:02,800 --> 00:21:07,400
Drupal has learned and inherited from other PHP projects.

00:21:07,400 --> 00:21:12,600
Our service container is largely based on the Symfony service container.

00:21:12,600 --> 00:21:17,010
You can learn a lot about how that works, again, by learning Symfony, but not necessarily

00:21:17,010 --> 00:21:20,330
required either. The truth is, for the most part, you don't

00:21:20,330 --> 00:21:24,050
really need to know how the intricacies of the service container work.

00:21:24,050 --> 00:21:28,190
You just need to know how to ask it for the service that you need to query the database

00:21:28,190 --> 00:21:34,500
or send a JSON response or whatever it is that you are trying to do.

00:21:34,500 --> 00:21:41,490
Before you write plugins, take a couple of minutes to understand how PSR-4 works,

00:21:41,490 --> 00:21:45,550
really just to understand what the naming convention is there.

00:21:45,550 --> 00:21:51,460
Read up on annotations and learn a little bit about dependency injection and the service container,

00:21:51,460 --> 00:21:55,860
mostly because you'll see these in action when you write plugins.

00:21:55,860 --> 00:22:00,520
For me, it was one of those, "What is going on here? Where did this variable come from?"

00:22:00,520 --> 00:22:04,600
I had to read a little bit further up the stack and go, "Oh, that's because my block

00:22:04,600 --> 00:22:11,270
plugin is actually an instance of an injected plugin, so it got a copy of the services that

00:22:11,270 --> 00:22:15,900
I need when it was created." Knowing what's going on and how the system

00:22:15,900 --> 00:22:20,540
works means that you're going to be able to write better plugins in the long run.

00:22:20,540 --> 00:22:24,160
Once you've got that part mastered, this is how you write a plugin.

00:22:24,160 --> 00:22:27,790
The first thing you need to do: Think of what type of plugin you're going

00:22:27,790 --> 00:22:30,110
to create. Are you creating a block plugin?

00:22:30,110 --> 00:22:33,250
Are you creating a new field widget? Is this an image effect?

00:22:33,250 --> 00:22:37,130
Knowing that will dictate the answer to the rest of these questions.

00:22:37,130 --> 00:22:40,140
The first thing you do: Figure out what type of plugin you're going to write.

00:22:40,140 --> 00:22:44,670
That will tell you: "Where should I put the metadata for this plugin?"

00:22:44,670 --> 00:22:51,250
A block plugin, as we just saw in the example, uses annotations for metadata.

00:22:51,250 --> 00:22:55,510
There are a couple other ways that you can get that information, and it depends on the

00:22:55,510 --> 00:22:58,610
type of plugin you're using. Where does the code go?

00:22:58,610 --> 00:23:02,340
It's a block plugin or it's a field widget plugin.

00:23:02,340 --> 00:23:07,900
That dictates the sub-namespace in that PSR-4 standard, so I have to know: "Okay, I'm going

00:23:07,900 --> 00:23:13,100
to create a block plugin. I have to follow this PSR-4 pattern in order to make sure that

00:23:13,100 --> 00:23:20,100
Drupal can locate my code when it needs it." Then another one is: "Is there a base class?"

00:23:21,100 --> 00:23:27,350
Generally, when you're implementing a new plugin, like a block for example, Drupal provides

00:23:27,350 --> 00:23:31,770
a base class that you can extend in order to create your plugin,

00:23:31,770 --> 00:23:37,130
the idea being that a lot of plugins probably have fairly boilerplate code.

00:23:37,130 --> 00:23:40,830
Blocks, for example. Every block has that configuration form where you can say,

00:23:40,830 --> 00:23:46,460
"Which page is it visible on? Which region should it be in and which theme?"

00:23:46,460 --> 00:23:51,310
All of that is common for pretty much every block unless, of course, you need to make

00:23:51,310 --> 00:23:55,120
it slightly different for your block, in which case you can, but why not just extend the

00:23:55,120 --> 00:23:59,990
base class which has all of that already? If you need to, you can override one of the methods.

00:23:59,990 --> 00:24:06,040
Once you have that information out of the way,

00:24:06,040 --> 00:24:12,210
the other tip here is, for the most part what you can do with Drupal--this is one of

00:24:12,210 --> 00:24:15,800
the things that's awesome about Open Source and learning Drupal--is, really, just copy

00:24:15,800 --> 00:24:19,800
and paste what somebody else did and make a couple of changes, and now you've got a

00:24:19,800 --> 00:24:23,450
block plugin. All of the systems in Drupal that implement

00:24:23,450 --> 00:24:27,710
a new plugin type, they don't just implement a plugin in type and they're like, "Yeah,

00:24:27,710 --> 00:24:32,060
this is just in case somebody wants to provide a plugin of this type some time maybe."

00:24:32,060 --> 00:24:36,010
They implement it because Drupal needs to provide plugins of that type.

00:24:36,010 --> 00:24:41,810
Every time you know block plugins, field plugins, whatever the case may be, core will also contain

00:24:41,810 --> 00:24:47,030
instances of those plugins. A really great way to learn how that particular

00:24:47,030 --> 00:24:54,030
plugin type works is to look at an existing example.

00:24:54,960 --> 00:25:01,460
Here's what a block plugin would look like. If I wanted to write a block plugin, I figured

00:25:01,460 --> 00:25:05,860
out, okay, I want to write a block plugin. I need to make sure that I put it in the appropriate

00:25:05,860 --> 00:25:12,860
namespace based on the fact that it's using the PSR-4 standard, so the plugin/block namespace.

00:25:13,880 --> 00:25:20,800
I included my metadata for this in an annotation that's in the comment for this plugin class.

00:25:20,800 --> 00:25:27,790
Then I extended the block base class, and then I implemented, in the case of a block

00:25:27,790 --> 00:25:32,610
plugin, this build method, which is responsible for returning the content of the block.

00:25:32,610 --> 00:25:38,160
That's it. This file will allow Drupal to have a block

00:25:38,160 --> 00:25:43,850
that printed the context "Hello World" that had in the administration user interface a

00:25:43,850 --> 00:25:48,030
label that says "Chad block." Apparently I wanted to name my block Chad.

00:25:48,030 --> 00:25:52,080
It's in the "Tacos" category. I don't know.

00:25:52,080 --> 00:25:57,080
It must have been late. I've created a new block that prints out the

00:25:57,080 --> 00:26:01,440
text "Hello World," and this is like 10 lines of executable code.

00:26:01,440 --> 00:26:04,290
That's it. All of the code is contained in one place

00:26:04,290 --> 00:26:08,460
too. Versus Drupal 7, you'd have to have an info hook, a "hook_block_view,"

00:26:08,460 --> 00:26:14,020
a configuration hook and so forth in order to accomplish this same thing.

00:26:14,020 --> 00:26:20,420
Not only that, but what you'd really probably have is like "hook_block_view" with the delta

00:26:20,420 --> 00:26:25,450
or the idea of the block passed in, and then a giant freaking switch statement that was like,

00:26:25,450 --> 00:26:28,080
"Okay, which block did you actually want?"

00:26:28,080 --> 00:26:32,450
You're like, "What I really want is the system info block," and you'd have to kind of parse

00:26:32,450 --> 00:26:36,390
through all that. You've got this massive pile of code for generating

00:26:36,390 --> 00:26:41,580
all of the blocks that the system module wants to provide all in one place.

00:26:41,580 --> 00:26:47,910
Great. Again, pro tip: Extend the base class when

00:26:47,910 --> 00:26:54,910
it exists. In 99% of the time, what you'll be doing is...

00:26:55,340 --> 00:26:59,360
You only want to deal with the things that are unique to your situation and allow Drupal

00:26:59,360 --> 00:27:02,390
to handle the rest of it. You don't need to deal with all the boilerplate

00:27:02,390 --> 00:27:07,680
code in a block for determining access restrictions and visibility and so forth.

00:27:07,680 --> 00:27:11,730
Let Drupal handle that by extending the base class.

00:27:11,730 --> 00:27:17,460
Of course, you can because it's all object-oriented. You're just inheriting or extending that class.

00:27:17,460 --> 00:27:23,330
You can override any of the functionality in your own plugin should you need to.

00:27:23,330 --> 00:27:30,330
That went the wrong way. There we go.

00:27:31,890 --> 00:27:38,300
That's kind of the gist of why plugins, the basics of how plugins work.

00:27:38,300 --> 00:27:41,870
If I wanted to write a block plugin, really what I would do is copy and paste somebody

00:27:41,870 --> 00:27:46,640
else's block plugin and rename it "Joe's awesome block plugin."

00:27:46,640 --> 00:27:50,390
If you really want to take advantage of the system, I think it helps to understand how

00:27:50,390 --> 00:27:55,090
all of the pieces work. What we're going to do now is walk through

00:27:55,090 --> 00:28:01,600
how Drupal, or you if you wanted to in your own module, could declare a new plugin type

00:28:01,600 --> 00:28:06,860
and dictate what the namespace is, where the metadata is found, and how copies of those

00:28:06,860 --> 00:28:13,710
plugins get loaded by the system. Behind the scenes, when you've got a plugin

00:28:13,710 --> 00:28:19,040
type, the thing that's controlling all of that is called a plugin manager.

00:28:19,040 --> 00:28:23,210
There's a block plugin manager. There's a field formatter plugin manager.

00:28:23,210 --> 00:28:30,210
Some of them get really long names, I promise. What that manager does is it dictates:

00:28:31,040 --> 00:28:37,710
How should plugins of this type be discovered? Where in the code or where in general should

00:28:37,710 --> 00:28:42,680
Drupal look or should the plugin system look to find block plugins.

00:28:42,680 --> 00:28:49,680
Once it's found one, and somebody requests a copy of that block or of that field widget,

00:28:50,480 --> 00:28:57,480
how do I load and execute the code that is that plugin?

00:28:57,580 --> 00:29:01,880
Then we'll talk a little bit about the mapper, which also deals with how do you load and

00:29:01,880 --> 00:29:08,880
execute the appropriate code. All of this is done by implementing the "PluginManagerInterface."

00:29:11,200 --> 00:29:15,280
The interface here is basically me saying, "I'm going to implement this interface.

00:29:15,280 --> 00:29:20,350
I'm going to sign a contract that says I wanted to create plugins that are of the type

00:29:20,350 --> 00:29:26,640
'ice cream flavor' and by doing so I promise to tell you how to discover them, how to instantiate

00:29:26,640 --> 00:29:32,480
a copy of it, and in general how to deal with those ice cream flavors."

00:29:32,480 --> 00:29:34,700
Plugin discovery. There's a handful of ways that this can be

00:29:34,700 --> 00:29:39,410
handled in Drupal. By far, the most common is annotated class discovery.

00:29:39,410 --> 00:29:42,450
That's what we saw with the block plugin,

00:29:42,450 --> 00:29:48,500
where you had the annotation and the comment above the class in your file.

00:29:48,500 --> 00:29:54,860
If you want to use annotated class discovery, and you do want to use annotated class discovery,

00:29:54,860 --> 00:29:58,070
this is what you need to specify in your plugin manager.

00:29:58,070 --> 00:30:03,360
Plugin/block. That's our sub-namespace there, so that's the

00:30:03,360 --> 00:30:07,840
part where I am saying, "The block system, when you're creating a new plugin and you

00:30:07,840 --> 00:30:13,460
want to know what to put in for the PSR-4 subnamespace, we're declaring it that in our

00:30:13,460 --> 00:30:20,070
plugin manager." Here we've got "Drupal/icecream/FlavorInterface,"

00:30:20,070 --> 00:30:27,070
so you're saying, "What namespace is it in? Plugins of my type need to implement this

00:30:28,370 --> 00:30:33,110
PHP interface." What that allows for is it means that the

00:30:33,110 --> 00:30:38,350
plugin manager can now get a copy of any plugin as long as it implements the interface and

00:30:38,350 --> 00:30:43,020
it knows what methods are available on that interface, because you're mapping to an interface

00:30:43,020 --> 00:30:48,630
and by doing so, you're saying, "I guarantee that my block plugin is going to have a build

00:30:48,630 --> 00:30:53,110
method because if it doesn't PHP is going to be really upset."

00:30:53,110 --> 00:30:59,010
You're telling the system which interface those plugins need to conform to.

00:30:59,010 --> 00:31:06,010
Then you're telling it here which class dictates the values for the annotation that's used

00:31:07,800 --> 00:31:10,860
for your plugin. What's a little bit interesting about these

00:31:10,860 --> 00:31:17,860
annotations is that the content of the annotation, the things that you put in it are different

00:31:17,910 --> 00:31:22,120
depending on the plugin type. Kind of like how in Drupal 7 when you had

00:31:22,120 --> 00:31:27,570
an info hook, the values that were returned in that giant associative array were different

00:31:27,570 --> 00:31:32,300
depending on the specific info hook. Blocks needed one thing and field types needed another.

00:31:32,300 --> 00:31:34,290
Same thing here.

00:31:34,290 --> 00:31:41,290
We need to provide different metadata depending on the plugin type.

00:31:41,980 --> 00:31:47,030
Annotated class discovery is the most common by far and the one that I would recommend

00:31:47,030 --> 00:31:52,050
using if you're creating your own new plugin type, unless of course you run into one of

00:31:52,050 --> 00:31:57,200
these other scenarios, which are much rarer. Hook discovery.

00:31:57,200 --> 00:32:02,150
Actually, this set of slides is a little bit old, and I looked into this this morning,

00:32:02,150 --> 00:32:07,820
and I couldn't find any examples of hook discovery being used in core anymore.

00:32:07,820 --> 00:32:14,660
What this does, and I think part of why it existed was sort of allowing for transition

00:32:14,660 --> 00:32:21,660
from info hooks to annotated class discovery and not requiring us to move everything all

00:32:23,230 --> 00:32:26,830
at once. Hook discovery says, "Instead of reading an

00:32:26,830 --> 00:32:33,690
annotation for the metadata, implement a hook." That returns an array that provides the metadata.

00:32:33,690 --> 00:32:40,690
The hook discovery name of the hook that you want to execute, this would be identical to

00:32:41,330 --> 00:32:46,460
implementing "hook_block_info" in Drupal 7. I mention this at this point because hook

00:32:46,460 --> 00:32:51,490
discovery is still an option in core, but it's not actually used anywhere right now

00:32:51,490 --> 00:32:56,670
other than the tests that make sure that it works.

00:32:56,670 --> 00:33:03,330
YAML discovery is another way that we can provide metadata about our plugins.

00:33:03,330 --> 00:33:10,330
YAML discovery works by placing a "mymodule.stringoftext.yml" file inside of your module directory, and

00:33:15,590 --> 00:33:20,100
Drupal will look there for the metadata about plugins.

00:33:20,100 --> 00:33:25,310
In this case, YAML discovery, I said, "Okay, I'm going to put the metadata into a file

00:33:25,310 --> 00:33:32,310
named 'blocks.yml.'" The reason for YAML discovery is to allow

00:33:34,770 --> 00:33:41,510
Drupal to discover information about and create instances of plugins much earlier during the

00:33:41,510 --> 00:33:48,510
page request cycle. In a sense, for things that we want to be

00:33:52,100 --> 00:33:58,310
able to discover without actually having to use Bootstrap Drupal and use PHP in order

00:33:58,310 --> 00:34:01,880
to discover them. We don't want to have to instantiate the Doctrine

00:34:01,880 --> 00:34:05,960
parser and so forth. A good example of this being used in core

00:34:05,960 --> 00:34:11,960
is for menu items. Now when you define a menu item, instead of

00:34:11,960 --> 00:34:16,960
implementing "hook menu," you actually need to define a menu item plugin.

00:34:16,960 --> 00:34:23,000
You do so by providing a YAML file, or a .yml file, in your module directory that says,

00:34:23,000 --> 00:34:29,139
"Here are my instances of menu item plugins." This allows the system to read in that YAML

00:34:29,139 --> 00:34:35,060
file, find all of the plugins, and cache that data and be a bit more efficient about loading

00:34:35,060 --> 00:34:40,080
it in the future. Finally, there is static discovery.

00:34:40,080 --> 00:34:45,770
Static discovery is basically like hard-coding the discovery of your plugin.

00:34:45,770 --> 00:34:52,750
Really, it's useful for tests, but it's saying, if my plugin manager, if my plugin type,

00:34:52,750 --> 00:34:58,230
I only want to ever have these two plugin instances and I don't want to allow people to dynamically

00:34:58,230 --> 00:35:05,070
add them with annotations or YAML files or so forth, I can hard-code the path to that file.

00:35:05,070 --> 00:35:11,430
Those are the four different ways in which

00:35:11,430 --> 00:35:16,750
plugins can be discovered. Primarily we use annotated class discovery,

00:35:16,750 --> 00:35:19,910
and I would recommend that you do that too if you are ever implementing your own plugin type.

00:35:19,910 --> 00:35:24,370
Of course, this is Drupal, and we like to

00:35:24,370 --> 00:35:29,230
make things infinitely more flexible than just those four options, so we add the concept

00:35:29,230 --> 00:35:33,440
of Decorator Classes. Now you've basically got discovery mechanisms

00:35:33,440 --> 00:35:39,700
that wrap around your discovery mechanism to make sure that it's more flexible.

00:35:39,700 --> 00:35:46,620
This allows for things like the concept of an "alter hook" in Drupal 7.

00:35:46,620 --> 00:35:52,080
Drupal 7 calls "hook_block_info," and it gathers a big array of all of the blocks that could

00:35:52,080 --> 00:35:57,960
be used anywhere, and then immediately afterwards, it says, "hook_block_info_alter."

00:35:57,960 --> 00:36:02,190
Here's the list of all of the blocks. Does anybody want to make changes to it?

00:36:02,190 --> 00:36:05,920
Decorator Classes essentially allows for that in the plugin system.

00:36:05,920 --> 00:36:11,310
It says, "Go off and get a list of all of the block plugins and then let anybody that

00:36:11,310 --> 00:36:18,100
wants to make changes to that list." It also adds some interesting things like

00:36:18,100 --> 00:36:24,880
the derivative discovery decorator here, which ends up being probably the most used in core.

00:36:24,880 --> 00:36:31,880
What this allows you to do is create a single plugin class that can be instantiated as multiple

00:36:34,710 --> 00:36:41,710
different instances of the same plugin. Think about how in core you can create new

00:36:44,050 --> 00:36:48,150
custom block types. Actually, probably a better example would

00:36:48,150 --> 00:36:53,770
be menus in core. Any time you create a new menu in the UI,

00:36:53,770 --> 00:36:59,480
you also get a corresponding block for that menu that you can place somewhere in your theme.

00:36:59,480 --> 00:37:04,040
Rather than having to write a new block plugin

00:37:04,040 --> 00:37:10,780
for every single menu, there's actually one menu block plugin that uses this derivative

00:37:10,780 --> 00:37:17,040
discovery decorator. This is the code that is capable of saying,

00:37:17,040 --> 00:37:23,140
"Take a menu and render it." Then there's the decorator, which wraps it

00:37:23,140 --> 00:37:28,720
and says, "Okay, but before you do that, here's the name of the menu I want you to use."

00:37:28,720 --> 00:37:31,990
It's really as simple as that. It's one set of code that you can pass in

00:37:31,990 --> 00:37:37,230
and say, "I want the navigation menu," or "I want the footer menu," or so forth.

00:37:37,230 --> 00:37:42,260
The code is smart enough to then go, "Okay, cool. I'll look up that menu and render that

00:37:42,260 --> 00:37:49,260
list of links," rather than me having to write an individual plugin for every menu that I

00:37:49,340 --> 00:37:56,340
wanted a block for. That's how discovery works and that's how

00:37:57,590 --> 00:38:02,070
Drupal goes through the process of figuring out what plugins are available for the system

00:38:02,070 --> 00:38:06,900
and what it should list for users to be able to use.

00:38:06,900 --> 00:38:09,870
You've discovered all of the plugins, now you actually need to be able to...

00:38:09,870 --> 00:38:14,510
When a person says, "Okay, I want to display a system info block," how does Drupal get

00:38:14,510 --> 00:38:20,020
a copy of that plugin and make use of it? It uses what are called plugin factories.

00:38:20,020 --> 00:38:24,730
There's a handful of different plugin factories that you can use and a plugin manager, but

00:38:24,730 --> 00:38:31,730
they all really boil down to this: Figuring out what's the name of the class

00:38:31,850 --> 00:38:37,670
that implements this particular block and what arguments do I need to pass into the

00:38:37,670 --> 00:38:41,860
constructor of that class when I create a new copy of it?

00:38:41,860 --> 00:38:48,860
There are a couple of these. We've got the default factor and the container

00:38:51,860 --> 00:38:56,450
factory, which both basically do the same thing.

00:38:56,450 --> 00:39:01,320
You can kind of read the code here. This variable is the name of the class, so

00:39:01,320 --> 00:39:07,430
the factory says, "Okay, I'm just going to say 'name of the class,' 'constructor,' pass

00:39:07,430 --> 00:39:14,430
in a couple of arguments," the arguments here being any configuration for the plugin, the

00:39:15,590 --> 00:39:20,410
plugin ID, and the plugin definition. These two variables are parsed directly out

00:39:20,410 --> 00:39:23,410
of that annotation or out of the YAML file or whatever.

00:39:23,410 --> 00:39:28,280
It's basically saying, "Hey, plugin instance, here's your metadata in case you want to do

00:39:28,280 --> 00:39:32,760
anything with it." The container factory, which is actually the

00:39:32,760 --> 00:39:39,510
one that's used by default in most cases... The naming is a little challenging, we'll

00:39:39,510 --> 00:39:42,900
say. The container factory does exactly the same thing.

00:39:42,900 --> 00:39:45,890
What's the name of the class?

00:39:45,890 --> 00:39:52,890
Here's the metadata that describes your plugin. But it also uses dependency injection to inject

00:39:54,570 --> 00:40:01,560
a copy of Drupal's services container so that your plugin now has access to all of the services.

00:40:01,560 --> 00:40:08,350
For example, your block plugin, which is instantiated using a container factory, gets a copy of

00:40:08,350 --> 00:40:14,220
the service container, and can use that to get an instance of the database object that

00:40:14,220 --> 00:40:19,450
it needs in order to query and find out which menu you're trying to display in this particular

00:40:19,450 --> 00:40:26,390
block or so forth. If you're creating your own plugin type,

00:40:26,390 --> 00:40:31,480
the default that Drupal will use, if you implement this system, is the container factory,

00:40:31,480 --> 00:40:36,870
and in most cases, that's probably sufficient, and you wouldn't need to do anything different.

00:40:36,870 --> 00:40:42,270
The default factory would be a little bit more efficient in terms of actually instantiating it,

00:40:42,270 --> 00:40:47,600
but in most cases you're going to want to allow people that are implementing your

00:40:47,600 --> 00:40:54,580
plugin type to also have access to all of the other services that Drupal provides.

00:40:54,580 --> 00:40:59,720
The other two are widget factory and reflection factory.

00:40:59,720 --> 00:41:05,110
The widget factory is used for instances where you've got plugins that take settings that

00:41:05,110 --> 00:41:10,620
are a bit more complicated than just what's in the annotation.

00:41:10,620 --> 00:41:14,970
The name here actually kind of works because this is used for things like field widgets

00:41:14,970 --> 00:41:21,660
primarily, where field widgets are a plugin, but they have additional user configurable

00:41:21,660 --> 00:41:28,660
settings that aren't part of the annotation. Our block plugin has an admin label that we

00:41:28,980 --> 00:41:34,580
put into the annotation, and it's okay to hard-code that and say the system info block

00:41:34,580 --> 00:41:39,180
has a label of system info. When you create a new field, you don't initially

00:41:39,180 --> 00:41:43,050
know what the label of that field is going to be, so you can't hard-code it into the

00:41:43,050 --> 00:41:46,510
system. You need to allow someone to fill out a form

00:41:46,510 --> 00:41:50,860
that says, "I'm creating a new field with this name and it has this label."

00:41:50,860 --> 00:41:57,860
When the system needs to get a new copy of the text field plugin, it needs to also tell

00:41:59,070 --> 00:42:06,070
that instance, "Hey, text field, your name is 'email,' and your human-readable label

00:42:06,410 --> 00:42:12,480
is 'please insert your email address here.'" The widget factory allows for that.

00:42:12,480 --> 00:42:19,480
The reflection factory is also rarely used. What it does is it allows for a plugin to

00:42:21,570 --> 00:42:28,570
basically do introspection on itself at the time that it's instantiated, so your plugin

00:42:28,820 --> 00:42:34,360
instance, the code within it can say, "This is how you should make a copy of me."

00:42:34,360 --> 00:42:40,400
That's basically what the reflection factory allows for.

00:42:40,400 --> 00:42:45,180
Probably when you would use that is if you had a plugin type that required a dynamic

00:42:45,180 --> 00:42:48,640
set of arguments. It's not a fixed number of arguments.

00:42:48,640 --> 00:42:53,230
It's not the same every time. The arguments that are passed in depend on

00:42:53,230 --> 00:43:00,230
application state or context. Kind of like we have decorators for discovering

00:43:06,730 --> 00:43:11,940
plugins, we also have the plugin mapper, which adds an additional layer on top of how you

00:43:11,940 --> 00:43:18,940
instantiate a plugin. The idea here is that somebody asking for

00:43:19,060 --> 00:43:24,390
a copy of a plugin might not always know specifically which one they want right away, so we need

00:43:24,390 --> 00:43:31,390
to figure it out for them and then return that. Somebody comes into your ice cream shop,

00:43:32,100 --> 00:43:34,680
and they're really into ice cream. They're a bit of a connoisseur.

00:43:34,680 --> 00:43:38,600
Instead of just saying, "I'd like some vanilla,"

00:43:38,600 --> 00:43:43,170
they come into the ice cream shop and they say, "What's your best flavor? What would

00:43:43,170 --> 00:43:47,440
you recommend I have?" The person working there needs to be able

00:43:47,440 --> 00:43:54,440
to figure out, "Well, this guy, he's kind of tall. He's got red hair. I'm going to guess,

00:43:55,070 --> 00:43:59,410
based on these various different attributes, that he'd probably like chocolate, so I'll

00:43:59,410 --> 00:44:02,760
get a copy of the chocolate plugin and give it to him."

00:44:02,760 --> 00:44:07,980
A mapper does that. Where we see this in Drupal is things like

00:44:07,980 --> 00:44:14,510
Drupal's RESTServer, for example. The RESTServer itself and how it responds

00:44:14,510 --> 00:44:18,360
and returns data is actually a plugin. You can do it in a couple of different ways.

00:44:18,360 --> 00:44:24,600
You could return JSON, or you could return XML, but you can't hard-code that because

00:44:24,600 --> 00:44:31,350
it's based on the incoming request. Did my application specify a JSON header or

00:44:31,350 --> 00:44:34,770
an XML header? Depending on that, Drupal needs to be able

00:44:34,770 --> 00:44:41,770
to say, "Okay, this request is asking for a plugin to build a response. It has the XML

00:44:42,810 --> 00:44:49,810
header, so I need to load the XML response plugin and use that one."

00:44:51,660 --> 00:44:56,700
Based on other things that are going on in your environment, figuring out which block

00:44:56,700 --> 00:45:02,620
or which plugin to get a copy of. That's the plugin manager.

00:45:02,620 --> 00:45:07,870
All of these things come together in order to create the "PluginManagerInterface."

00:45:07,870 --> 00:45:14,870
If you want to create a plugin type of your own, what you need to do is sign the contract

00:45:15,460 --> 00:45:20,910
that says, "I'm going to declare all of those things. I'm going to declare which discovery

00:45:20,910 --> 00:45:26,310
method should I use." Once a plugin of this type is discovered,

00:45:26,310 --> 00:45:30,930
how do I want to allow copies of it to be instantiated, so which factories should I

00:45:30,930 --> 00:45:35,060
use? Then do I want to allow for a mapper or not?

00:45:35,060 --> 00:45:41,340
The mapper here is optional. It kind of depends on the use case.

00:45:41,340 --> 00:45:45,510
Kind of like how we have base classes for blocks in other plugins so you don't have

00:45:45,510 --> 00:45:50,730
to do all of this boilerplate code all the time, if you want to create your own plugin type,

00:45:50,730 --> 00:45:57,730
you can do so by extending the "DefaultPluginManager," which basically does everything for you with

00:45:58,690 --> 00:46:03,200
some assumptions. The "DefaultPluginManager" assumes certain

00:46:03,200 --> 00:46:07,240
discovery methods and certain factories and so forth, so we'll talk more about that.

00:46:07,240 --> 00:46:12,900
What we're going to do real quick is write some code that creates a plugin manager that

00:46:12,900 --> 00:46:16,150
solves this problem. We're going to provide a new plugin type that

00:46:16,150 --> 00:46:23,150
allows us to define ice cream flavors. The plugin manager will define what does it

00:46:25,610 --> 00:46:30,040
mean to be an ice cream flavor? What information do I have to provide if I

00:46:30,040 --> 00:46:33,760
am a flavor of ice cream? We're going to provide a base class because

00:46:33,760 --> 00:46:37,280
we're nice and we don't want people to have to do extra work if they don't have to, and

00:46:37,280 --> 00:46:42,770
we're going to provide some sample flavors. Why would we implement a system that we're

00:46:42,770 --> 00:46:48,060
not ever going to use? The first thing you would do...

00:46:48,060 --> 00:46:53,840
The code here is a little bit abbreviated, a very little bit.

00:46:53,840 --> 00:46:58,740
I'll have a link so you can see all of this code at the end.

00:46:58,740 --> 00:47:04,670
You extend the "DefaultPluginManager." When you do that, all you really have to do

00:47:04,670 --> 00:47:08,500
is declare what type of discovery do you want to use?

00:47:08,500 --> 00:47:13,600
The truth is, you want to use annotated class discovery, so all you really have to do is say,

00:47:13,600 --> 00:47:20,600
"What's the PSR-4 namespace that I want plugins of my type to live in? What information

00:47:22,240 --> 00:47:27,800
is in the annotation, and what's the interface that they need to implement?"

00:47:27,800 --> 00:47:31,790
You're basically setting up a system so that someone who wants to come along and implement

00:47:31,790 --> 00:47:37,170
a plugin of your type knows what they need to do and what information they need to provide.

00:47:37,170 --> 00:47:44,170
You've got your plugin manager. You need to provide a class that declares,

00:47:44,680 --> 00:47:48,700
"What's the information that can go in this annotation?"

00:47:48,700 --> 00:47:55,510
That's done by extending the plugin annotation class, so this class.

00:47:55,510 --> 00:48:01,920
It's in the Drupal component annotation plugin namespace.

00:48:01,920 --> 00:48:08,000
What you do is you add new properties to that class, just empty properties, and then write

00:48:08,000 --> 00:48:12,170
a string of documentation that says, "What should this property contain?"

00:48:12,170 --> 00:48:19,170
These classes aren't actually ever used in the system at all other than to provide documentation

00:48:19,480 --> 00:48:26,070
for what should exist in an annotation. This is important because when you want to

00:48:26,070 --> 00:48:30,480
implement somebody else's plugin type, and it's based on annotated class discovery, how

00:48:30,480 --> 00:48:34,030
do you know what information to put in the annotation?

00:48:34,030 --> 00:48:40,650
The answer is you find this class that's in the module that is implementing that plugin type.

00:48:40,650 --> 00:48:46,060
There is a block class that extends the annotation

00:48:46,060 --> 00:48:52,060
plugin class, and it has a number of different properties with documentation for each of

00:48:52,060 --> 00:48:56,730
those properties in the class. Those are the things that you could include

00:48:56,730 --> 00:49:01,880
in your annotation. Generally, it will say, "This ID property

00:49:01,880 --> 00:49:08,400
or this label property is required," but that's kind of how, as a developer, I can discover

00:49:08,400 --> 00:49:14,080
what should go in this annotation? This one was actually really tricky for me

00:49:14,080 --> 00:49:15,780
when I was trying to learn how all of this stuff works.

00:49:15,780 --> 00:49:19,340
I kept reading these annotations and being like, "Okay, I get it, and I can copy and

00:49:19,340 --> 00:49:23,060
paste the existing one, but what are all the things that could be here that I don't know about?"

00:49:23,060 --> 00:49:26,100
The way to find the things that weren't in

00:49:26,100 --> 00:49:31,880
the one that I copied and pasted was to find this annotation class and look at that.

00:49:31,880 --> 00:49:38,880
Then, of course, we need to provide an interface. We extend the plugin extension interface with

00:49:42,010 --> 00:49:47,760
our new flavor interface, and what we're doing with an interface is we're saying that any

00:49:47,760 --> 00:49:54,400
instance of a plugin of our type needs to provide this functionality.

00:49:54,400 --> 00:50:01,400
If you're going to provide an ice cream flavor, you're required to provide a name or a "getName"

00:50:02,660 --> 00:50:07,680
method for that ice cream flavor. That ensures that I, as someone who just wants

00:50:07,680 --> 00:50:12,960
to get a scoop of ice cream, can say, "Give me a scoop of ice cream," and then based on

00:50:12,960 --> 00:50:17,720
you returning that, I know one of the things I can do with this thing you've just given

00:50:17,720 --> 00:50:24,410
me is "call the 'getName' method," because it's guaranteed it'll be there.

00:50:24,410 --> 00:50:29,619
Whether the variable is named "$vanilla" or "$icecreamscoop" or whatever, "$block,"

00:50:29,619 --> 00:50:36,619
I know I can call "getName" on that object, and it will provide me the name of that flavor.

00:50:37,180 --> 00:50:40,110
Of course, we're super nice and we don't want people to have to do a lot of work, so we

00:50:40,110 --> 00:50:47,110
provide a base class that they can extend. We implemented this "getName" function,

00:50:47,590 --> 00:50:53,290
and what I did here is I actually just read in from the annotation the plugin definition,

00:50:53,290 --> 00:50:58,540
so back on the previous slide. There are a lot of previous slides.

00:50:58,540 --> 00:51:05,540
Back here, we said, "Okay. Our plugins can have the annotation with the ID of 'name,'"

00:51:06,119 --> 00:51:11,400
and then in this one I said, "Okay. In my plugin, whatever the value of that annotation

00:51:11,400 --> 00:51:14,970
was, I'm just going to return that as the name of the plugin."

00:51:14,970 --> 00:51:20,030
When somebody wants to create a new ice cream flavor, really all they have to do in this

00:51:20,030 --> 00:51:27,030
case is actually just extend our base class, give it their name, so "vanilla" in this case,

00:51:28,010 --> 00:51:35,010
make sure that it's in the appropriate subnamespace based on the PSR-4 standard, and then provide

00:51:35,950 --> 00:51:40,200
an annotation. Our annotation has this name key in it.

00:51:40,200 --> 00:51:44,100
We extended "FlavorBase," so we actually don't have to do anything else at this point.

00:51:44,100 --> 00:51:49,170
It's already got that "getName" method that's reading in the annotation.

00:51:49,170 --> 00:51:55,119
If we wanted to, we could, of course, do something a bit more complicated.

00:51:55,119 --> 00:52:02,119
We might want to have a different flavor of ice cream, "chocolate" in this case.

00:52:02,660 --> 00:52:05,890
All of the other things are the same. It's got a name in the annotation.

00:52:05,890 --> 00:52:12,860
It extends the "FlavorBase." What we've done is overridden the slogan method

00:52:12,860 --> 00:52:15,660
because we decided that actually vanilla is not the best ice cream.

00:52:15,660 --> 00:52:22,660
Chocolate is the best flavor of ice cream. This is a pretty contrived example, but what

00:52:22,880 --> 00:52:27,920
it demonstrates is a plugin system, or whenever you're implementing plugin types of your own,

00:52:27,920 --> 00:52:33,600
you should make it really easy for someone to provide a new instance of that plugin type.

00:52:33,600 --> 00:52:38,430
Do all of the boilerplate and default work for them, and make it so you only need to

00:52:38,430 --> 00:52:44,680
write the code that is specific to their instance. If I want to write a "Hello World" block,

00:52:44,680 --> 00:52:48,760
the only thing I should really have to do is write the string "Hello World" so that

00:52:48,760 --> 00:52:51,860
it gets printed out on the screen. I don't need to worry about all of the other

00:52:51,860 --> 00:52:57,160
pieces of the system. If you're writing a plugin system or if your

00:52:57,160 --> 00:53:02,240
module is saying, "Okay, I'm going to allow for people to have plugins," you want to provide

00:53:02,240 --> 00:53:08,930
them with that same level of "all I need to do is the work that is custom to my specific implementation."

00:53:08,930 --> 00:53:14,190
A summary of that: If you want to create your

00:53:14,190 --> 00:53:21,190
own plugin type and then implement a plugin of that type, you declare what sub-namespace

00:53:23,900 --> 00:53:26,930
those things are in. Basically, how are my plugins going to be discovered?

00:53:26,930 --> 00:53:33,930
You're saying, "Here's where the annotation is.

00:53:34,940 --> 00:53:41,869
Here's the PSR-4 pattern that you need to follow, and then extend the base class."

00:53:41,869 --> 00:53:45,740
Basically say, "All right, I'm going to create a block. There's a block base class.

00:53:45,740 --> 00:53:52,740
I'll just start from there and just make the changes that are unique for my specific instance.

00:53:54,170 --> 00:54:01,170
If you are doing a plugin manager of your own, you've declared a plugin type.

00:54:04,050 --> 00:54:09,490
The other thing that you're going to need to do is also actually make use of those plugins.

00:54:09,490 --> 00:54:14,570
We could say, "Here's the block plugin type," but Drupal also needs to say, "Okay, cool,"

00:54:14,570 --> 00:54:20,730
and you can place blocks on the pages in places, and when you do so your content will be displayed.

00:54:20,730 --> 00:54:27,730
You need to expose your plugin manager to Drupal so that you as the module developer

00:54:28,650 --> 00:54:35,190
who created the plugin manager can also use the plugin manager to get a list of all of

00:54:35,190 --> 00:54:39,700
the blocks or of all of the field types or whatever the case may be.

00:54:39,700 --> 00:54:45,310
In Drupal we do that using the services container. I talked a little bit about that at the beginning.

00:54:45,310 --> 00:54:51,960
The implication here is that if you create a new plugin manager, you should do so by

00:54:51,960 --> 00:54:58,130
defining it as a service. That way when you, most likely, or anyone

00:54:58,130 --> 00:55:03,369
else wants to make use of your plugin manager, they ask the Drupal service container, "Hey,

00:55:03,369 --> 00:55:09,480
give me a copy of the 'ice cream' plugin manager," and I can use that to do things like get a

00:55:09,480 --> 00:55:15,950
list of all of the ice cream flavors. I can use that to say, "Cool. I want a scoop of

00:55:15,950 --> 00:55:20,760
vanilla," and the plugin manager will say, "Okay, cool. I know how to do that. You said

00:55:20,760 --> 00:55:26,190
that I'm going to use the container factory for returning plugins of this type." It takes

00:55:26,190 --> 00:55:32,790
the vanilla ID. It uses that to locate the appropriate class based on the PSR-4 standard,

00:55:32,790 --> 00:55:38,580
and then it instantiates a copy of that class using the container factory, and finally returns

00:55:38,580 --> 00:55:44,650
you a scoop of vanilla ice cream, which you know what to do with because it implements

00:55:44,650 --> 00:55:51,650
that interface. A recap of everything we covered here:

00:55:51,940 --> 00:55:58,940
Most importantly, plugins are reusable bits of functionality that are configurable, re-usable,

00:55:59,810 --> 00:56:04,830
and really plugins do just one thing. Each instance of a plugin does exactly one thing.

00:56:04,830 --> 00:56:09,710
An image effect takes an image, changes its color,

00:56:09,710 --> 00:56:15,230
and returns a copy of that image. It doesn't take an image, change its color,

00:56:15,230 --> 00:56:18,750
send somebody an email, and then return a copy of the image.

00:56:18,750 --> 00:56:25,750
It's just responsible for that one task. Plugins are PHP classes that implement a defined interface.

00:56:28,130 --> 00:56:30,830
If you want to create a new block or a new

00:56:30,830 --> 00:56:35,430
field or implement a specific plugin type, really what you're doing is writing a new

00:56:35,430 --> 00:56:41,520
class that follows the PHP interface defined for that plugin type.

00:56:41,520 --> 00:56:46,840
If you want to create new plugin types or write plugins of your own, some of the background

00:56:46,840 --> 00:56:52,450
knowledge that you'll want to know about--we've covered this a bunch now--is PSR-4, annotation,

00:56:52,450 --> 00:56:57,109
and sometimes dependency injection and the service container.

00:56:57,109 --> 00:57:04,109
Finally, plugins in Drupal... The type is defined by a plugin manager,

00:57:06,359 --> 00:57:12,350
and if you ever want to add a new plugin type, you'll need to implement a plugin manager.

00:57:12,350 --> 00:57:16,390
The exercise then here would be going through and figuring out, when you're writing your

00:57:16,390 --> 00:57:22,520
own module, what are the things that you would want to allow people to write plugins for?

00:57:22,520 --> 00:57:27,630
When do you want to provide a user interface that will allow for an administrator to choose

00:57:27,630 --> 00:57:32,420
one from a list of options to execute some particular functionality.

00:57:32,420 --> 00:57:39,070
There are all kinds of examples of this in core, like blocks and field types and how

00:57:39,070 --> 00:57:43,280
do you send an email? Do you us SMTP or do you use the built-in

00:57:43,280 --> 00:57:50,280
PHP mailer, all kinds of different options. In the contrib space or when you start writing

00:57:50,700 --> 00:57:56,590
your own, you're inevitably going to encounter a scenario in which you say to yourself, "Self,

00:57:56,590 --> 00:58:02,830
it would be really nice and make my code more reusable if I made it so that other people

00:58:02,830 --> 00:58:08,630
could provide a plugin that allowed their custom functionality.

00:58:08,630 --> 00:58:13,850
Off-hand, something like the Voting API module might be a good example of where you would

00:58:13,850 --> 00:58:18,140
implement a plugin type. Rather than me writing a module that's like,

00:58:18,140 --> 00:58:24,109
"In my code, I have to account for every possible way that someone would ever want to tally

00:58:24,109 --> 00:58:31,109
votes," instead I'll just create a plugin type and I'll write one tally plugin that

00:58:31,280 --> 00:58:36,290
says, "Well, just add them all together," and the total is the outcome of the vote.

00:58:36,290 --> 00:58:41,020
I'll make it possible so that anyone else can come along and write, "Well, for our specific

00:58:41,020 --> 00:58:46,880
use case, we need to use instant run-off voting" or "for our use case, we need to throw away

00:58:46,880 --> 00:58:52,200
all of the votes that were registered on Tuesday and Thursday because that's what we do on

00:58:52,200 --> 00:58:56,250
our website. When you encounter those types of problems

00:58:56,250 --> 00:59:01,619
when you're writing a module, Plugins is probably the right solution to implement.

00:59:01,619 --> 00:59:08,619
That's what I've got. At this URL lb.cm/d8-plugins, I also have

00:59:11,510 --> 00:59:18,510
all of this information written out too, so if you want to go home and review afterwards,

00:59:18,980 --> 00:59:22,930
if you want to look it up again at another time, this is all written out there along

00:59:22,930 --> 00:59:27,650
with a bit more complete example code. The example code there you can actually install

00:59:27,650 --> 00:59:31,520
in Drupal 8 and it will let you create new ice cream flavors, because who doesn't like

00:59:31,520 --> 00:59:35,960
ice cream? If you wouldn't mind taking a minute some

00:59:35,960 --> 00:59:40,980
time today to provide feedback for this session, that would be awesome.

00:59:40,980 --> 00:59:45,770
The DA and camps like this make use of this information to make sure that we're able to

00:59:45,770 --> 00:59:50,320
continue to offer really good sessions, and I can use this to make sure that next time

00:59:50,320 --> 00:59:53,300
I have to explain Plugins to someone I can do it even better.

00:59:53,300 --> 00:59:59,100
That's what I got. Thank you.

00:59:59,100 --> 01:00:05,609
Questions, of course. We're kind of right up against the time, but

01:00:05,609 --> 01:00:10,180
I'm also happy to answer questions until they kick us out, and then we can stand over in

01:00:10,180 --> 01:00:17,180
the corner and keep talking. Yeah.

01:00:19,330 --> 01:00:26,330
-Is there any way to auto-write your dependencies in your plugins?

01:00:29,730 --> 01:00:32,430
-Is there any way to overwrite? -Auto. Auto-inject.

01:00:32,430 --> 01:00:39,430
-To inject dependencies automatically, yes. The question is: Is there any way to automatically

01:00:39,810 --> 01:00:45,630
inject dependencies into your plugin type, basically?

01:00:45,630 --> 01:00:51,180
You're like, "I'm implementing a new plugin type and I want all of the instances to get

01:00:51,180 --> 01:00:57,500
this dependency?" -I have a service, [inaudible] service, and

01:00:57,500 --> 01:01:04,500
I need to an entity manager service. Is there any way that I can say, "Okay, I'm

01:01:05,340 --> 01:01:11,680
going to use this entity manager service"? Give me one instance automatically.

01:01:11,680 --> 01:01:16,670
-Yes. The way to do that would be, when you're creating

01:01:16,670 --> 01:01:22,260
your plugin manager to declare your new plugin type and you have to declare the factory that

01:01:22,260 --> 01:01:27,600
it will use to create instances of your plugins, you could do two things in this case.

01:01:27,600 --> 01:01:33,920
You could use the default container factory, which will inject Drupal's service container,

01:01:33,920 --> 01:01:40,740
and you could have your dependency just be a service that's registered with the container,

01:01:40,740 --> 01:01:46,359
and then it will be available, or there's nothing that stops you from creating your

01:01:46,359 --> 01:01:52,190
own new factory class. In this case, you could say, "You know what?

01:01:52,190 --> 01:01:57,349
The container factory isn't quite what I want, so I'll just extend the container factory

01:01:57,349 --> 01:02:04,349
and let it do all of its things, but I will also, when I call plugins of my type,

01:02:04,790 --> 01:02:10,099
pass in this one additional argument to their constructor. Does that make sense?

01:02:10,099 --> 01:02:16,950
-Yeah, but I was kind of looking for something to inject the dependency without having to

01:02:16,950 --> 01:02:23,950
pass arguments, an aspect-oriented way to inject. Kind of like a [inaudible]

01:02:41,190 --> 01:02:48,190
-The answer to the question is yes, and I think what you need to do in this particular

01:02:52,450 --> 01:02:59,450
case is either write your own or somehow modify one of the existing factories because the

01:03:00,230 --> 01:03:06,630
factory is the thing that says, "When I'm instantiating a copy of this plugin, here's

01:03:06,630 --> 01:03:08,930
how I should do it." Really, it's up to you.

01:03:08,930 --> 01:03:13,640
You can instantiate it however you want to as long as it returns an instance of that class.

01:03:13,640 --> 01:03:16,510
There are a lot of different ways that can

01:03:16,510 --> 01:03:23,510
be done, and it would be by overriding or just creating a new factory, I think.

01:03:23,980 --> 01:03:27,940
-Thank you. -You're welcome.

01:03:27,940 --> 01:03:34,940
Any other questions? -Yes, you mentioned earlier that the plugin

01:03:36,760 --> 01:03:38,730
system is something that... Some clarification, maybe.

01:03:38,730 --> 01:03:43,849
It was similar to what Symfony was doing. Was the plugin system like the wrapper that

01:03:43,849 --> 01:03:50,530
was unique to Drupal or is it a very similar system to what Symfony uses?

01:03:50,530 --> 01:03:56,510
-The plugin system itself is very much a Drupalism at this point.

01:03:56,510 --> 01:04:00,810
That design pattern is unique to Drupal, but a lot of the things that the plugin system

01:04:00,810 --> 01:04:06,550
uses in order to work are also things that Symfony uses, like dependency injection.

01:04:06,550 --> 01:04:13,550
The service container that we use in Drupal is based off of Symfony's service container.

01:04:14,290 --> 01:04:18,780
Plugins themselves in that whole pattern are unique to Drupal, but learning a lot of the

01:04:18,780 --> 01:04:24,140
components of Symfony will also help you better understand the plugin system.

01:04:24,140 --> 01:04:31,140
-You mentioned in the plugin discovery there are the annotation discovery and hook discovery,

01:04:33,470 --> 01:04:40,470
but Drupal is not using the hooks anymore. Will it be the correct way to proceed using

01:04:43,359 --> 01:04:48,550
only annotations? -The question is essentially like, "Why does

01:04:48,550 --> 01:04:54,320
hook discovery exist if we're not using it?" I think the best way to answer that question

01:04:54,320 --> 01:05:00,119
is it's mostly there as a compatibility layer during the time for which we're transitioning

01:05:00,119 --> 01:05:05,920
everything from hooks to annotations and plugins and so forth.

01:05:05,920 --> 01:05:12,920
If you're creating a new plugin type in Drupal 8, you don't want to use hook discovery, basically.

01:05:13,180 --> 01:05:20,060
It's probably slightly more efficient in terms of overall processing time, but YAML discovery

01:05:20,060 --> 01:05:26,710
would be even more efficient. Ultimately, I would say annotated class discovery

01:05:26,710 --> 01:05:33,710
unless you need to have your plugins available really early, basically before the annotation

01:05:33,830 --> 01:05:39,930
parser has been instantiated in Drupal, then you would use YAML discovery.

01:05:39,930 --> 01:05:43,180
Static discovery is like if you're writing tests and you want to just make sure nobody

01:05:43,180 --> 01:05:50,180
can ever change this, and hook discovery is basically a thing of the past at this point.

01:05:51,390 --> 01:05:53,930
Yeah? -Hi, Joe.

01:05:53,930 --> 01:05:59,200
Just a small question about caching. You have all these layers that are abstractions,

01:05:59,200 --> 01:06:01,900
not direct. We're not just declaring directly the elements,

01:06:01,900 --> 01:06:03,520
right? We depend on the auto-loader.

01:06:03,520 --> 01:06:08,500
We depend on declaration of service, YAML files, that stuff.

01:06:08,500 --> 01:06:14,400
Which parts of this are cached, do we have just ready?

01:06:14,400 --> 01:06:21,060
-This is a complex system with a lot of moving parts, and some of them would be very expensive

01:06:21,060 --> 01:06:26,000
to have to read every single time. For example, having to read the annotations

01:06:26,000 --> 01:06:30,090
on every single plugin class every time would be an expensive process.

01:06:30,090 --> 01:06:35,880
The discovery process of plugins is cached by default.

01:06:35,880 --> 01:06:39,840
When you create your new plugin type or you implement the default plugin manager,

01:06:39,840 --> 01:06:44,869
one of the things that it does is it provides a caching mechanism for whatever discovery

01:06:44,869 --> 01:06:49,369
you're using. That information is cached, and that's fine

01:06:49,369 --> 01:06:55,460
because you really only need to get a list of what plugins are available at the time

01:06:55,460 --> 01:07:00,080
that somebody installs a new module. Otherwise that list really rarely changes.

01:07:00,080 --> 01:07:04,230
Maybe if they're a derivative plugin, when they added a new menu or something, you would

01:07:04,230 --> 01:07:07,810
also need to refresh that list. For the most part, that list is just used

01:07:07,810 --> 01:07:12,410
for things like the admin UI so it can be efficient for that.

01:07:12,410 --> 01:07:18,490
Instantiating a copy of a plugin is generally not cached because a lot of times, the thing

01:07:18,490 --> 01:07:24,260
that the plugin needs to do is going to be sensitive to whatever context and state the

01:07:24,260 --> 01:07:31,260
application is currently in. The actual instantiation of the block plugin

01:07:32,150 --> 01:07:37,869
and having the block plugin build its content, that process isn't cached, though the block

01:07:37,869 --> 01:07:43,400
itself or that plugin--and in the case of blocks it does do this--its output could be

01:07:43,400 --> 01:07:46,530
cached. You could say next time you call the system

01:07:46,530 --> 01:07:51,180
info block, you still have to create a copy of that class, but it doesn't have to do all

01:07:51,180 --> 01:07:55,490
of the work to go off and query some external system and pull in the information.

01:07:55,490 --> 01:08:00,349
It can just use the cached output from the previous time, but that part becomes a little

01:08:00,349 --> 01:08:06,410
bit more dependent on the specific plugin type, and you as the person implementing the

01:08:06,410 --> 01:08:13,010
new plugin type would need to decide, "Are plugins of my time potentially doing expensive

01:08:13,010 --> 01:08:18,000
work to output their content? Do I want to cache the content?"

01:08:18,000 --> 01:08:21,900
-It comes for free with the default plugin manager, right?

01:08:21,900 --> 01:08:28,900
-Yes, caching of the discovery you get virtually for free if you extend the default plugin

01:08:29,040 --> 01:08:36,040
manager type. If you want to learn more about how that works,

01:08:38,000 --> 01:08:42,130
I highly recommend printing out a copy of the default plugin manager and reading it

01:08:42,130 --> 01:08:48,480
as a light bedtime reading some time. It will teach you a lot about where plugins

01:08:48,480 --> 01:08:53,480
come from, how plugins are created and so forth, and really help you better understand

01:08:53,480 --> 01:09:00,480
all of the moving parts of the system. -Hello. What is the difference between plugins

01:09:01,390 --> 01:09:03,089
and modules? -Yeah, right?

01:09:03,089 --> 01:09:10,089
This is really confusing because plugins, which are provided by modules, add extra functionality

01:09:10,170 --> 01:09:16,350
to Drupal, but they're parts of modules, which add extra functionality to Drupal.

01:09:16,350 --> 01:09:22,940
It's like this recursive problem. Plugins have to be provided by a module.

01:09:22,940 --> 01:09:27,650
In order for Drupal to even know that your plugin exists, the first step of course is

01:09:27,650 --> 01:09:31,520
creating a new module. The module that you're writing is going to

01:09:31,520 --> 01:09:36,609
dictate some of the things, like when you're following the PSR-4 standard, for example,

01:09:36,609 --> 01:09:43,609
what's the vendor namespace and so forth? The answer to the question is: Plugins exist

01:09:44,000 --> 01:09:51,000
as one of the things that modules can do. -Just a quick one.

01:09:57,130 --> 01:10:03,820
How stable is all this Drupal 8 plugin system? Can we confidently create new plugins all

01:10:03,820 --> 01:10:09,130
around the modules or do we have to expect some changes in the near future?

01:10:09,130 --> 01:10:15,840
-The question is: How stable is this system, and do we anticipate it changing before a

01:10:15,840 --> 01:10:20,900
stable version of Drupal 8 comes out? I would say at this point the plugin system

01:10:20,900 --> 01:10:25,250
is pretty stable. I wouldn't anticipate any major changes to

01:10:25,250 --> 01:10:28,590
how it works. At most, you're going to see things that make

01:10:28,590 --> 01:10:33,460
it faster. An example of something that changed somewhat

01:10:33,460 --> 01:10:40,460
recently--this has also existed for a couple of years now at this point--is you used to

01:10:43,900 --> 01:10:50,900
not be required to provide an interface for your plugin type, but now you are required to.

01:10:53,150 --> 01:10:54,950
There are enhancements that are happening

01:10:54,950 --> 01:10:59,880
to make the system easier for developers to learn and understand, but I doubt that any

01:10:59,880 --> 01:11:06,880
of how it works is going to change at this point, especially because thousands of things

01:11:07,170 --> 01:11:11,400
in Drupal 8 have already been converted to use this plugin system.

01:11:11,400 --> 01:11:15,960
Virtually all of the things that were like, "hook_block_info, give me the name of a function

01:11:15,960 --> 01:11:22,860
that I should call," are now plugins in Drupal 8.

01:11:22,860 --> 01:11:29,110
I'm going to move so that whoever has to get up here next can do so, but I'm happy to answer

01:11:29,110 --> 01:11:33,150
questions if people have additional questions or just reach out to me on Twitter and I can

01:11:33,150 --> 01:11:35,310
try to answer them there or whatever the case may be.

01:11:35,310 --> 01:11:35,650

YouTube URL: https://www.youtube.com/watch?v=9pVg2-5dcVg


