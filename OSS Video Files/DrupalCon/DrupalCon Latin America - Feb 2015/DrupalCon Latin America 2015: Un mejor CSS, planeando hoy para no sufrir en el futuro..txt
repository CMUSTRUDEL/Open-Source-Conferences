Title: DrupalCon Latin America 2015: Un mejor CSS, planeando hoy para no sufrir en el futuro.
Publication date: 2015-02-11
Playlist: DrupalCon Latin America - Feb 2015
Description: 
	Speakers: jleiva
No importa el tamaño del proyecto en el que estemos trabajando, desgraciadamente siempre es posible terminar con CSS poco mantenible, difícil de debuggear y en el que repetimos una y otra vez las mismas reglas.

El objetivo de esta charla es, que nuestro “yo” del futuro no nos odie ;)

La sesión incluye temas como:

Como organizar nuestro CSS/Sass
La idea de componentes en CSS
CSS naming conventions
Crear layouts y componentes reutilizables con Views y Display Suite.
Extra tips, Grunt JS para que nuestros Sass sea más limpio
Slides: http://www.slideshare.net/leivajd/planeand

Ego title

Jose Leiva, Front-End Developer en Backcountry.com. He hablado en diferentes conferencias sobre CSS, Sass y Drupal Theming. Durante 4 años he trabajado para diferentes Drupal Shop en Costa Rica como Drupal Themer.
Captions: 
	00:00:00,950 --> 00:00:07,399
The 5:00 session is called "Better CSS. Preparing today for tomorrow's challenges."

00:00:07,399 --> 00:00:14,399
Let's wait a couple minutes to see if anyone else will be joining us.

00:00:15,360 --> 00:00:18,470
Or let's just go ahead and get started.

00:00:18,470 --> 00:00:22,610
My name is Jose Leiva. I'm from Costa Rica.

00:00:22,610 --> 00:00:29,610
Around 2007, I started building web sites.

00:00:29,670 --> 00:00:41,670
In 2007 I started with Drupal, and for about three years, I worked in different

00:00:41,790 --> 00:00:46,620
Drupal Shops in Costa Rica, doing timing and inside building.

00:00:46,620 --> 00:00:52,210
I spent about two years at an e-commerce company called Backcountry.

00:00:52,210 --> 00:00:58,100
Basically, what we do is guide people to their passions.

00:00:58,100 --> 00:01:03,110
I invite you now to the Drupal Camp in Costa Rica.

00:01:03,110 --> 00:01:06,969
It is happening from July 29 to July 30.

00:01:06,969 --> 00:01:08,240
You are all invited.

00:01:08,240 --> 00:01:18,120
Ever since I started with Drupal I got involved in the Drupal community, giving talks and sharing

00:01:18,249 --> 00:01:21,139
a little bit of what I've learned along the way.

00:01:21,139 --> 00:01:28,139
The purpose of today's discussion is that our future selves don't hate us.

00:01:28,459 --> 00:01:34,920
As I mentioned, my primary role since I started has been frontend stuff.

00:01:34,920 --> 00:01:40,529
CSS, Javascript, Inside Building.

00:01:40,529 --> 00:01:47,529
I have worked freelance, writing CSS by myself from home.

00:01:50,380 --> 00:01:54,520
Since 2010 I have worked as a member of different teams.

00:01:54,520 --> 00:01:58,419
I've been on teams of two people and teams of five people.

00:01:58,419 --> 00:02:05,399
Now, working with this company, we have about six teams, each of which is responsible for different

00:02:05,399 --> 00:02:07,759
parts of the site.

00:02:07,759 --> 00:02:14,750
And you can imagine how complicated it can get to not overlook any files

00:02:14,750 --> 00:02:18,930
when we're all working with them, right?

00:02:18,930 --> 00:02:25,930
So what we're going to talk about today is what I've learned from my experience

00:02:26,930 --> 00:02:29,150
in both the company I work for currently and in those I worked for previously.

00:02:29,150 --> 00:02:34,829
Some of that experience has involved Drupal projects and some has not.

00:02:34,829 --> 00:02:37,260
First point: CSS is easy.

00:02:37,260 --> 00:02:39,760
That's what everyone in backend says.

00:02:39,760 --> 00:02:44,349
That's why they don't do frontend—CSS is just so easy.

00:02:44,349 --> 00:02:47,890
CSS 101, am I right?

00:02:47,890 --> 00:02:56,210
We have a selector that can be pretty much anything contained in our HTML document.

00:02:57,969 --> 00:03:04,180
We can assign the selector a property and a value.

00:03:04,180 --> 00:03:08,920
For example, the property can be used to change the font size.

00:03:08,920 --> 00:03:09,439


00:03:09,439 --> 00:03:11,480
And the value can change the unit.

00:03:11,480 --> 00:03:13,980
It's simple.

00:03:13,980 --> 00:03:21,959
Our declaration block can have one, two, or any number of properties and values.

00:03:23,740 --> 00:03:30,320
And our CSS file consists of any given number of declaration blocks.

00:03:30,510 --> 00:03:32,140
Easy, right?

00:03:32,140 --> 00:03:35,230
So what do we use CSS for?

00:03:35,230 --> 00:03:41,439
We use it to add styles to the appearance of our sites or our applications.

00:03:41,439 --> 00:03:49,859
Writing CSS is very simple, but some real-world examples might be helpful.

00:03:52,400 --> 00:04:00,360
Those who are familiar with Drupal know where we're headed with this.

00:04:00,480 --> 00:04:05,319
One, two, three, four selectors to add a background color.

00:04:05,319 --> 00:04:07,150
This is from a real project.

00:04:10,500 --> 00:04:20,940
If you're familiar with Views, you'll recognize the three selectors here, two of which are linked.

00:04:27,370 --> 00:04:29,680
It's a good idea to group selectors together.

00:04:29,680 --> 00:04:32,290
There is nothing wrong with that.

00:04:32,290 --> 00:04:39,830
But why have two, three, four, five different selectors 

00:04:39,920 --> 00:04:42,790
if there's a way to have just one?

00:04:42,790 --> 00:04:46,290
What do you see here?

00:04:46,290 --> 00:04:48,290
Well, we see "high specificity."

00:04:48,290 --> 00:04:56,530
I assume that everyone here is familiar with CSS, so we're going to step back and look at the big picture.

00:04:56,670 --> 00:04:58,250


00:04:58,250 --> 00:05:00,970
We're not going to get into the specifics.

00:05:00,970 --> 00:05:05,970
So what problems do these examples illustrate?

00:05:05,970 --> 00:05:08,840
High specificity, right?

00:05:08,840 --> 00:05:15,500
For example, in this one, the second selector has a class and an ID.

00:05:15,500 --> 00:05:22,500
If for some reason I wanted to overwrite one of these rules I would have to increase the specificity.

00:05:22,500 --> 00:05:24,570


00:05:25,160 --> 00:05:28,340
"High dependence on HTML".

00:05:28,340 --> 00:05:33,180
If you looked at any case—take views, for example: if we remove one of the selectors, the rule stops working.

00:05:33,180 --> 00:05:35,400


00:05:35,400 --> 00:05:41,500
Or if, for example, we modified our HTML code and cleaned the views a bit,

00:05:41,500 --> 00:05:43,750
it will also stop working.

00:05:43,750 --> 00:05:46,620
"Hits performance".

00:05:46,620 --> 00:05:53,620
Everyone knows that a browser reads from right to left, and the faster it can find a match

00:05:54,000 --> 00:06:01,000
with the rule the selector is looking for to apply the styles, the better the performance.

00:06:01,830 --> 00:06:04,140
And they are "hard to reuse".

00:06:04,140 --> 00:06:11,140
All of the examples that I've shown you are tied to a specific case or HTML block.

00:06:13,140 --> 00:06:15,330
And a sad face.

00:06:17,500 --> 00:06:21,360
Once again: "Writing CSS is extremely simple."

00:06:21,360 --> 00:06:25,630
Anyone could do it after the brief introduction I just gave you.

00:06:25,630 --> 00:06:27,890
So what's the catch?

00:06:27,890 --> 00:06:31,320
Project design is not so simple.

00:06:31,320 --> 00:06:37,610
It takes time, it requires planning, and it involves organization.

00:06:37,610 --> 00:06:44,610
And when we talk about project architecture, which is a hot topic right now,

00:06:45,530 --> 00:06:52,080
we'll be talking about what tools are, what planning is, and what it means to write code,

00:06:52,080 --> 00:06:57,140
or CSS in our case, in a way that produces quality code.

00:06:57,500 --> 00:07:05,600
For example, here are a couple of things that indicate that our code is high quality: 

00:07:05,710 --> 00:07:09,620
How good is its performance? How reusable is the code that we have?

00:07:09,620 --> 00:07:16,160
Does our code do what it's supposed to do? Is it maintainable and scalable?

00:07:16,160 --> 00:07:21,120
These are a few questions to ask to determine whether or not our code is high quality.

00:07:21,120 --> 00:07:27,560
In my opinion, maintainability and scalability of the code are the most important things.

00:07:27,560 --> 00:07:32,050
And that deserves a smiley face.

00:07:32,050 --> 00:07:37,270
So what can we do to achieve high-quality code?

00:07:37,270 --> 00:07:43,840
A lot of the time, what we need to do is rethink things, including our processes and workflow.

00:07:45,780 --> 00:07:48,010
Think of the backend people.

00:07:48,500 --> 00:07:54,690
Backend people are excellent at planning.

00:07:54,690 --> 00:08:01,480
If, for example, you were going to write a widget in JavaScript, you're probably not going to just sit around and do nothing.

00:08:01,480 --> 00:08:04,530
You would start running code to see if it works.

00:08:04,530 --> 00:08:07,660
And if it doesn't work, you rewrite it and run it again. If it doesn't work again, you rewrite it and try it again.

00:08:07,660 --> 00:08:11,250
It's a waste of time and resources.

00:08:11,250 --> 00:08:14,970
We usually plan and organize the way we're going to work on something.

00:08:14,970 --> 00:08:16,150
So what do our backend friends have?

00:08:16,150 --> 00:08:20,520
They have variables, partials, and objects.

00:08:20,520 --> 00:08:26,460
We have all requested objects, and JavaScript has requested objects,

00:08:26,600 --> 00:08:30,160
and they handle everything that is part of abstraction.

00:08:30,170 --> 00:08:32,779
What does that allow them to do?

00:08:32,779 --> 00:08:37,440
It helps them cope with change and with the complexity of today's systems.

00:08:37,440 --> 00:08:37,710


00:08:37,710 --> 00:08:42,610
Frontend is not far behind.

00:08:42,610 --> 00:08:48,220
Building a website is much more difficult now than it was five years ago.

00:08:48,220 --> 00:08:53,020
As time goes on, we need more and more layers, performance becomes more and more important, 

00:08:53,020 --> 00:08:58,210
and it is ever more crucial that our project be maintainable and scalable.

00:08:58,210 --> 00:09:01,140
This creates certain complexities.

00:09:05,460 --> 00:09:17,660
Some of the methodologies that are used in CSS include: OOCSS, BEM, and SMACSS.

00:09:17,820 --> 00:09:21,300
Those three things are not libraries nor frameworks.

00:09:21,310 --> 00:09:23,150
They are working methodologies.

00:09:23,150 --> 00:09:30,150
And what they help us do is understand the whole and its parts, as well as how to organize and structure our code,

00:09:30,220 --> 00:09:37,620
and they work for vanilla CSS or with CSS preprocessors.

00:09:37,940 --> 00:09:41,000


00:09:41,820 --> 00:09:43,240
Anyway.

00:09:43,240 --> 00:09:48,960
Any of these three methods. And once again, we're not saying that we're going to

00:09:48,960 --> 00:09:54,730
to work with SMACSS and simply because of that our problems

00:09:54,730 --> 00:09:58,340
will be solved. That's not true.

00:09:58,340 --> 00:10:02,580
Where I work we use a mix of all three.

00:10:02,580 --> 00:10:09,580
You've basically got to study and find the information that's available for free online. There are so many

00:10:09,660 --> 00:10:20,400
books, articles, videos, etc., and we've got to seek out the ones that are of most interest to us

00:10:20,510 --> 00:10:22,910
and the ones that apply to our project.

00:10:26,560 --> 00:10:28,630
We were also talking before about preprocessors.

00:10:28,630 --> 00:10:35,130
As I told you at the beginning, our friends in backend have variables and constants, 

00:10:35,130 --> 00:10:39,890
and they have partials, plus a lot of things that we do not have in normal CSS.

00:10:40,160 --> 00:10:43,400
Preprocessors fill that void.

00:10:43,400 --> 00:10:50,400
Now with SASS or LESS or Stylus we can have variables and mixins, we can work with partials, 

00:10:51,279 --> 00:10:57,519
and it's easier to abstract the code that we are interested in or that we're going to work with.

00:10:58,840 --> 00:11:08,500
For those who aren't sure what a preprocessor is, it's basically one more layer in our CSS, so to speak.

00:11:08,580 --> 00:11:09,200


00:11:09,200 --> 00:11:18,800
If we are working with SASS, and in this case the syntax is SCSS, we would practically write

00:11:18,980 --> 00:11:24,880
in a SASS syntax that's very similar to CSS.

00:11:25,140 --> 00:11:32,480
SASS will compile what we write and then output it as CSS.

00:11:33,560 --> 00:11:42,940
It's just one more layer, and this abstraction layer, once again, gives us funcitonality that CSS does not give us.

00:11:43,540 --> 00:11:46,410


00:11:47,040 --> 00:11:49,410
What about these preprocessors?

00:11:49,410 --> 00:11:55,130
They are an excellent tool as long as we use them properly.

00:11:56,020 --> 00:12:01,460
They let us divide our code into smaller pieces, and give us the ability to extract code.

00:12:01,460 --> 00:12:08,460
It's important to keep in mind, however, that these tools don't replace a knowledge of CSS and all that we understand about architecture.

00:12:08,480 --> 00:12:10,840


00:12:14,740 --> 00:12:19,440
Are they excellent, if we use them correctly? Yes.

00:12:19,640 --> 00:12:22,940
Very simple. A selector: "foo".

00:12:22,940 --> 00:12:29,290
And then we have another rule block in which we have a descending selector called "zaa," right?

00:12:29,290 --> 00:12:32,050


00:12:32,050 --> 00:12:41,770
"foo" is the parent selector, and if we had more elements within "foo" we'd have

00:12:41,820 --> 00:12:43,000
to keep saying:

00:12:43,000 --> 00:12:46,900
"foo" is a selector, "foo" is a selector, "foo" is a selector.

00:12:47,680 --> 00:12:55,040
LESS and SASS give us this functionality of nesting.

00:12:55,040 --> 00:12:57,570
We could do something like this in SASS.

00:12:57,990 --> 00:13:04,970
Inside "foo" I could declare the rules that apply to "zaa." It's very simple.

00:13:04,970 --> 00:13:11,970
It is one of the basic functionalities when you start working with processors, and it's very useful.

00:13:12,740 --> 00:13:14,141


00:13:14,490 --> 00:13:17,130
What else does it do?

00:13:17,130 --> 00:13:18,380
It saves us time, right?

00:13:18,380 --> 00:13:21,089
What's going on?

00:13:21,089 --> 00:13:25,870
It is also one that is very misused.

00:13:25,870 --> 00:13:32,130
This is the same as with a real project.

00:13:32,130 --> 00:13:38,410
SASS is nesting four levels.

00:13:41,600 --> 00:13:48,600
That would be the output, once our code has been compiled.

00:13:49,100 --> 00:13:57,840
I think it would be unlikely that we'd do something like this if we were writing Vanilla CSS.

00:13:58,950 --> 00:14:05,530
We'd be shooting ourselves in the foot if we did something like that for every rule block.

00:14:05,710 --> 00:14:12,050
So you've got to be very careful with nesting.

00:14:12,050 --> 00:14:17,160
It's very common that nesting doesn't exactly match our HTML structure.

00:14:17,160 --> 00:14:22,149
We can have a block that has different elements inside 

00:14:22,149 --> 00:14:27,360
and we can begin to nest our code to match the HTML.

00:14:27,360 --> 00:14:32,660
And what we're doing there is making a stronger and stronger connection from our CSS rules to the HTML.

00:14:32,660 --> 00:14:34,060


00:14:34,060 --> 00:14:39,180
Be very careful with the output.

00:14:39,180 --> 00:14:45,160
When we are writing, it's very easy to do this, and if we're not

00:14:45,160 --> 00:14:51,370
monitoring the output, we will be building rules like these ones.

00:14:52,320 --> 00:14:56,289
If possible, it's best to avoid nesting.

00:14:58,120 --> 00:15:05,120
There's a general rule that says you shouldn't nest more than three levels.

00:15:05,800 --> 00:15:07,670
Why are these last two points important?

00:15:07,670 --> 00:15:16,330
Because it is a way of maintaining the specificity of our code to a similar level.

00:15:18,200 --> 00:15:23,900
Two other important points about preprocessors is that they make it possible to divide our code into small pieces.

00:15:23,910 --> 00:15:25,550


00:15:25,550 --> 00:15:29,350
I don't know how many of your Drupalers have done things like this.

00:15:29,350 --> 00:15:39,970
I took this from a Drupal 6, or one of the last Drupal 7s that I made without SASS, and this was my bread and butter.

00:15:40,220 --> 00:15:47,860


00:15:48,100 --> 00:15:54,020
I created specific CSS archives for specific things.

00:15:54,020 --> 00:16:00,170
So I had one for my reset, and one for things related to Drupal, about writing a pager or menus.

00:16:00,170 --> 00:16:04,250


00:16:04,250 --> 00:16:11,250
I had a CSS as a basis for layout and everything related to typography.

00:16:11,279 --> 00:16:17,910
And if there was something that included a module that I didn't want, I used, for example, this technique they called "FOD."

00:16:17,910 --> 00:16:21,360


00:16:21,360 --> 00:16:24,040
How many of you have used that?

00:16:24,140 --> 00:16:25,040
Nobody.

00:16:25,160 --> 00:16:30,020
Basically "FOD" is "Fuck Off and Die".

00:16:30,040 --> 00:16:35,420
What we're saying from the .info file is to look for this file in this folder.

00:16:35,420 --> 00:16:42,420
As the file does not exist, and basically there is no request, I did not command it to call, and it doesn't include it.

00:16:42,750 --> 00:16:43,910


00:16:43,910 --> 00:16:50,060
So the first file of the display module and to not have to be overwriting

00:16:50,060 --> 00:16:57,060
everything that came from that file I just killed the callout of that file.

00:16:57,660 --> 00:17:06,260
When I start working with SASS the section of my CSS stays in one line and I move the FOD to Magic.

00:17:06,420 --> 00:17:09,680


00:17:10,380 --> 00:17:17,379
In the previous lecture, Ian Carrico gave a short introduction to Magic.

00:17:17,379 --> 00:17:19,119


00:17:19,119 --> 00:17:23,649
Magic is a very interesting module for the world of frontend.

00:17:23,649 --> 00:17:29,139
One of the features of Magic is that we can tell it which CSS files we don't want to load.

00:17:29,139 --> 00:17:31,339
Period.

00:17:35,200 --> 00:17:42,200
This is a screenshot of my screen.scss.

00:17:42,669 --> 00:17:49,070
As you saw in the previous slide, I only one file, but the logic

00:17:49,070 --> 00:17:54,519
required to divide my CSS in smaller pieces can now be done using partials.

00:17:54,519 --> 00:18:01,519
So in one partial, I just load all the variables and mixins, and in another I load everything related to pages,

00:18:01,540 --> 00:18:08,540
 patterns, layouts, modules, etc.

00:18:09,460 --> 00:18:16,460
This is a snapshot of the basic structure for one of the projects.

00:18:19,799 --> 00:18:25,559
I just have one file that is going to be compiled, and it is the screen.scss file.

00:18:25,559 --> 00:18:30,409
The other files that are locked are called partials.

00:18:30,409 --> 00:18:34,330
If I don't call out those files, they will not compile.

00:18:34,330 --> 00:18:35,730
What does that mean?

00:18:35,730 --> 00:18:37,799
It means that they are not going to generate code.

00:18:37,799 --> 00:18:48,359
It means that I could alter the structure of my entire site in different partials, and if I don't

00:18:48,369 --> 00:18:53,949
call them out from a file that will compile, we're not going to have any of that code.

00:18:56,220 --> 00:19:03,220
For example, this is what I would have in one of the smallest files that I have,

00:19:03,529 --> 00:19:06,149
which is part of the patterns folder.

00:19:10,240 --> 00:19:16,860
Which is simply a rule concerning my links.

00:19:16,869 --> 00:19:21,809
If I had components, they could be formed by different patterns.

00:19:21,809 --> 00:19:27,749
What is the advantage of having such small files as partials?

00:19:27,749 --> 00:19:36,580
Imagine, for example, working as a team and having a bad merge.

00:19:36,580 --> 00:19:42,220
If we have a bad merge with a file of this size, it's incredibly simple to find the problem and fix the bad merge.

00:19:42,220 --> 00:19:44,889


00:19:44,889 --> 00:19:51,889
Now imagine what it would be like to fix a bad merge in a file that has 2,000 lines of CSS.

00:19:52,379 --> 00:19:56,559
It would drive you absolutely crazy.

00:19:58,260 --> 00:20:05,260
Another great thing about preprocessors is that they provide abstraction.

00:20:05,749 --> 00:20:10,629
Thinking of objects or abstractions and breaking down those components in small pieces should

00:20:10,629 --> 00:20:15,239
be our goal when we start working on a project.

00:20:15,239 --> 00:20:23,619
In a previous lecture about UX, the speaker said that Inside Building

00:20:23,619 --> 00:20:29,739
and Teaming don't start when we install Drupal from a test server.

00:20:29,739 --> 00:20:35,769
Rather, they start from the very moment that we speak with the client.

00:20:35,769 --> 00:20:36,239
Why is that?

00:20:36,239 --> 00:20:41,820
Because once we make contact with the client and establish requirements, we can

00:20:41,820 --> 00:20:48,700
start thinking about how we want to structure the project.

00:20:48,700 --> 00:20:53,009
When I have worked on teams where I've had the responsibility of doing Inside Building and Teaming, 

00:20:53,009 --> 00:21:00,009
usually someone holds up a document and says:

00:21:00,299 --> 00:21:04,249
"For this type of content we're going to have these fields." Am I right?

00:21:04,249 --> 00:21:06,889
And that is an act of structuring.

00:21:06,889 --> 00:21:13,889
Once that is ready, we begin to clean the HTML.

00:21:15,749 --> 00:21:24,109
We often complain about Drupal and its brand and about CSS and how glitchy it is, and so forth.

00:21:24,109 --> 00:21:26,909


00:21:26,909 --> 00:21:33,909
But if we don't do anything to clean that, we'll always have the same problem.

00:21:34,269 --> 00:21:37,929
When I work with these teams, what I usually do is:

00:21:37,929 --> 00:21:43,340
we take some time once we've planned and we know what each type of content is going to look like,

00:21:43,340 --> 00:21:46,340
what the views will look like, and what the blocks will be like.

00:21:46,340 --> 00:21:53,169
Now we begin to use the same Drupal features to clean that markup.

00:21:53,169 --> 00:21:59,259
And now 3 views with Drupal 7. Everyone that has worked with Drupal knows that we have options

00:21:59,259 --> 00:22:07,199
that let us choose the markup we want for a given field, or if we want to assign that field a class.

00:22:07,200 --> 00:22:14,460
We have modules like Block Class that allow us to assign each block a specific class.

00:22:15,260 --> 00:22:20,540
We have modules like Display Suit that are also very powerful.

00:22:22,180 --> 00:22:25,559
So why is it important to think about objects and abstractions?

00:22:25,559 --> 00:22:28,099
Well, because they are reusable.

00:22:29,060 --> 00:22:32,120
And then there's what I was saying about views.

00:22:33,820 --> 00:22:38,279
In this case, that's a small example of an object.

00:22:38,279 --> 00:22:41,929
My object will have a class called "promo-box."

00:22:41,929 --> 00:22:45,950
And inside the "promo-box" I have a title that is an "h3."

00:22:45,950 --> 00:22:52,009
It's a very simple way to give a title style..

00:22:52,009 --> 00:22:58,789
But what happens if it turns out that in a certain section of the site the titles are "h4" instead of "h3"?

00:22:58,789 --> 00:23:01,799


00:23:01,799 --> 00:23:08,200
A very simple solution would be to group selectors once again.

00:23:08,200 --> 00:23:10,710
But we are still linked to the markup.

00:23:10,710 --> 00:23:17,119
What if you do an "h5" or a "p" or one of the Drupal Spandy Folds?

00:23:17,119 --> 00:23:19,659


00:23:19,659 --> 00:23:24,379
Our block of selectors would be gigantic, like one of the first examples we looked at.

00:23:24,379 --> 00:23:25,320


00:23:25,320 --> 00:23:33,700
One simple option would be to assign it a class, and then my title can be any element.

00:23:33,700 --> 00:23:36,460
 

00:23:36,460 --> 00:23:38,720
What is the one thing I'd have to do?

00:23:38,720 --> 00:23:45,169
Assign that title or that element a class.

00:23:45,169 --> 00:23:47,009
One more example.

00:23:47,009 --> 00:23:55,749
This is also very common, and the first selector is one of the things we have to edit.

00:23:55,749 --> 00:23:56,600


00:23:56,600 --> 00:23:59,340
In doing that, we are over-qualifying selectors.

00:23:59,340 --> 00:24:05,119
We are telling it that in using this type of "product-list," it will only work with "ul" elements.

00:24:05,119 --> 00:24:06,739


00:24:06,739 --> 00:24:11,859
What if becomes an "ol"?

00:24:11,859 --> 00:24:17,080
My rules wouldn't work anymore.

00:24:17,080 --> 00:24:20,190
We would be improving this a bit.

00:24:20,190 --> 00:24:27,960
The first selector would no longer be tied to the markup, though it would be, shall we say, slightly tied to the markup.

00:24:27,960 --> 00:24:30,289


00:24:30,289 --> 00:24:37,289
Why? Because the key selector, or the selector which we are targeting is a "li".

00:24:37,309 --> 00:24:38,639


00:24:38,639 --> 00:24:42,549
Again, what if we don't want it to be a "li"?

00:24:42,549 --> 00:24:51,209
In the first case (and it would be a good choice) we could likewise have a class and apply

00:24:51,210 --> 00:24:53,320
it to the elements we want.

00:24:53,320 --> 00:24:59,100
Or just leave it as a single element.

00:25:01,160 --> 00:25:06,100
Why? Because we might end up using it elsewhere.

00:25:06,129 --> 00:25:13,009
You'll notice that the following example, example number two, is a "p," and example three is a "div."

00:25:13,009 --> 00:25:21,799
As seen in the first example, this malpractice happens often.

00:25:21,800 --> 00:25:28,800
When you start assigning classes to everything, it's what we usually call "divitis."

00:25:29,440 --> 00:25:38,540
What I've learned from experience, reading, and observing is that you've got to be very careful with dogmas.

00:25:39,139 --> 00:25:42,519
For a long time we've been afraid of divitis.

00:25:42,519 --> 00:25:49,249
But if something like what we saw in the last slide works for us and works for the project

00:25:49,249 --> 00:25:53,590
and for the team, there's no reason to change the way we do things. 

00:25:53,590 --> 00:25:58,889
And common sense is very important, am I right?

00:25:58,889 --> 00:26:05,479
When we write patterns, we should write them once and make sure they're reusable.

00:26:05,479 --> 00:26:15,719
For example, with multi-side projects, we could have a base theme, and in that theme

00:26:15,720 --> 00:26:23,260
we could have any number of patterns, each one in its partial, and only create structures

00:26:23,739 --> 00:26:30,739
without styles, so to speak, related to branding or schemes.

00:26:33,609 --> 00:26:40,109
And then to the established themes we'd just have to add the branding elements of the particular site.

00:26:40,109 --> 00:26:44,639


00:26:44,639 --> 00:26:50,029
Another very important point that we must keep in mind is work teams.

00:26:50,029 --> 00:26:55,639
Why? Because the more people there are working, the more problems we will have.

00:26:55,639 --> 00:27:02,639
It is very easy for me, if I'm working alone on a project, to choose which preprocessor

00:27:03,509 --> 00:27:09,749
I will use, how I am going to name the classes, and how I will organize my files.

00:27:09,749 --> 00:27:11,220
It is very simple.

00:27:11,220 --> 00:27:15,369
But what if there are 10 or 20 of us working?

00:27:15,369 --> 00:27:22,369
It's important that everyone on our team have similar knowledge.

00:27:23,720 --> 00:27:30,720
And one way to accomplish that is by listening to lectures or TED Talks as a team.

00:27:33,769 --> 00:27:40,769
Another way to minimize the problem of lots of people altering the code is to establish best practices.

00:27:41,950 --> 00:27:42,549


00:27:42,549 --> 00:27:47,549
An example of best practice would be syntax.

00:27:47,549 --> 00:27:54,549
How we will format our code, what naming conventions we will use, etc.

00:27:56,489 --> 00:28:03,489
Anyone who has used Drupal knows that Drupal contains certain conventions.

00:28:06,179 --> 00:28:11,739
If you're going to contribute a theme or a module, you have to follow and comply with the conventions

00:28:11,739 --> 00:28:13,320
of standard code.

00:28:13,320 --> 00:28:16,169
Even for basic things like spaces.

00:28:16,169 --> 00:28:21,649
Some people use two or even four spaces to indent a line.

00:28:21,649 --> 00:28:25,649
Others use the tab key, and there's a huge debate over this.

00:28:25,649 --> 00:28:28,330
Over something so insignificant.

00:28:28,330 --> 00:28:34,119
But when we're working as part of a team, such insignificant things are actually important.

00:28:34,119 --> 00:28:41,070
Why? Because my code must be such that any of my teammates can interpret it,

00:28:41,070 --> 00:28:46,989
and I must be able to read my teammates' code from top to bottom and understand what they're doing.

00:28:46,989 --> 00:28:51,109


00:28:51,109 --> 00:28:58,109
This is a rule, and this block follows a naming convention.

00:29:04,749 --> 00:29:10,820
There is a space between the selector and the bracket.

00:29:10,820 --> 00:29:16,330
Each property or each declaration appears on its own line, and you can see that it's all organized

00:29:16,330 --> 00:29:22,570
alphabetically, using shorthand for colors.

00:29:22,570 --> 00:29:29,570
It seems silly to give examples like these ones, but when we are working on big projects,

00:29:30,889 --> 00:29:36,929
these small things determine how fast or how slow we will be able to make

00:29:36,929 --> 00:29:41,799
a change or a minor adjustment to the code.

00:29:41,799 --> 00:29:48,799
If we have defined our standard code as a team and we are using SASS, Grunt

00:29:53,059 --> 00:30:00,059
has a task called SCSS lint, and basically we can configure whichever options we want

00:30:05,580 --> 00:30:07,879
it to validate upon compilation.

00:30:07,879 --> 00:30:14,879
Simple things like, "We'll use double code or single code."

00:30:15,529 --> 00:30:17,759
Each property will be on its own line.

00:30:17,759 --> 00:30:24,759
Again, if we are working as a team, and we do code reviews, this could be a very useful tool

00:30:26,049 --> 00:30:33,049
for validating the basic elements of the team's standard code when we compile locally.

00:30:35,429 --> 00:30:38,289


00:30:38,289 --> 00:30:43,359
Once the code reaches code review, we can focus on important things

00:30:43,359 --> 00:30:50,359
like code logic and code reuse instead of getting sidetracked by things like

00:30:51,279 --> 00:30:53,320


00:30:53,320 --> 00:31:00,320
"Hey, you need to change your indentation from two tabs to four tabs," or "Hey, remember that each property

00:31:02,029 --> 00:31:06,119
has to go on its own line."

00:31:06,119 --> 00:31:13,119
Along the same lines, it's important that everyone on the team is on the same page regarding naming conventions.

00:31:13,309 --> 00:31:16,139


00:31:16,139 --> 00:31:23,139
This is a code that's part of the internal documentation of the team I work with, and

00:31:25,469 --> 00:31:31,710
it's like the heading that appears before the description of how we will manage

00:31:31,710 --> 00:31:35,389
the names of each class or element.

00:31:35,389 --> 00:31:42,389
SMACSS, BEMM, and OOCSS all have principles that can help facilitate the process of naming elements.

00:31:44,789 --> 00:31:47,609


00:31:47,609 --> 00:31:54,609
We follow OOCSS, and there are basically four rules. The first is clarity: each selector that we name should be extremely clear.

00:31:56,879 --> 00:31:59,119


00:31:59,119 --> 00:32:06,119
It must be semantic, and not in the sense that we used with HTML, where we said:

00:32:07,359 --> 00:32:12,559
"Hey, semantic means that if I have a text block and it's a paragraph, I should mark it with a "p", not with a "div", right?

00:32:12,559 --> 00:32:15,649


00:32:15,649 --> 00:32:22,649
In that sense, what we mean by semantic is that the selector or class that I am

00:32:23,090 --> 00:32:29,889
naming should represent something, and it should be fairly easy to recognize what it is.

00:32:29,889 --> 00:32:30,389


00:32:30,389 --> 00:32:31,820
It has to be generic.

00:32:31,820 --> 00:32:36,729
Why? Because it should be reusable, not just in the site we're working on,

00:32:36,729 --> 00:32:39,289
but virtually anywhere.

00:32:39,289 --> 00:32:41,929
Think about the kinds of views.

00:32:41,929 --> 00:32:48,139
If you want to move your CSS code to a different project that doesn't have views installed,

00:32:48,139 --> 00:32:50,590
you can't reuse any component.

00:32:50,590 --> 00:32:53,190
And it has to be brief.

00:32:53,190 --> 00:32:57,330
Why? When it comes to performance, every bit counts.

00:32:57,330 --> 00:33:04,330
Of course, here we must point out something important: we must never sacrifice clarity for brevity.

00:33:06,590 --> 00:33:07,570


00:33:07,570 --> 00:33:14,570
It is much more important to be clear enough for other team members to understand than it is to use short names.

00:33:15,929 --> 00:33:16,109


00:33:16,109 --> 00:33:21,729
Here are some examples of how to name.

00:33:21,729 --> 00:33:27,129
For example, these are keys that serve as modifiers.

00:33:27,129 --> 00:33:34,129
First, if we want to edit a feature for touch,

00:33:34,129 --> 00:33:36,129
 

00:33:38,849 --> 00:33:41,440
we can use a key such as "is-touch".

00:33:47,080 --> 00:33:50,330
To hide an element, we can call it "is-hidden".

00:33:50,330 --> 00:33:53,159
And so on.

00:33:53,159 --> 00:33:53,659
If we have something in JavaScript, we can add an element to hide it.

00:33:53,659 --> 00:33:54,809
For example,

00:33:54,809 --> 00:34:01,809
We can have a "tab", and within that block, within the "tab" object, we have a selector called "is-selected".

00:34:01,989 --> 00:34:05,489


00:34:05,489 --> 00:34:09,990
The important thing here is that upon output, whatever I'm declaring in

00:34:09,990 --> 00:34:16,529
the "is-selected" will only take effect when it appears as "tab".

00:34:16,529 --> 00:34:23,529
I could have 20 "is-selected" classes for different objects, but if I encapsulate them

00:34:25,020 --> 00:34:30,970
like so, they will not affect one another.

00:34:30,970 --> 00:34:32,730
Here's an example of an object.

00:34:32,730 --> 00:34:36,950
This is my button object, a simple class.

00:34:36,950 --> 00:34:43,879
Any team that sees that it's called .btm knows that it's a button.

00:34:43,879 --> 00:34:48,369
A couple of "father and son" classes, there's a relationship there.

00:34:48,369 --> 00:34:51,649
And we could even simplify that poorly.

00:34:51,649 --> 00:34:54,779
That's not bad, but we could simplify more.

00:34:54,779 --> 00:34:56,789
It could work that way.

00:34:56,789 --> 00:35:03,789
We could be more specific, and our "product-list" object could have its own rules, and in a separate block of

00:35:06,770 --> 00:35:10,849
rules we could have anything related to our object labeled "product-list-on".

00:35:10,849 --> 00:35:17,849
Why? Because that's how we can maintain the specificity at a constant level.

00:35:19,230 --> 00:35:25,710
If I did something like this and for "a" or for "b" wanted to overwrite everything related to

00:35:25,710 --> 00:35:31,299
"item-thumb", I would have to raise the level of specificity of my selector in order to overwrite it.

00:35:31,299 --> 00:35:34,529


00:35:34,529 --> 00:35:41,529
We also must keep in mind the context in which we're working, and remember that

00:35:41,650 --> 00:35:48,650
style changes should only affect elements that change by page, and not objects.

00:35:48,680 --> 00:35:50,680
What do I mean by that?

00:35:50,680 --> 00:35:57,680
This is very common in Drupal; in the body we have classes such as "cart" or "front". or when it's logged or not.

00:35:59,210 --> 00:36:01,720


00:36:01,720 --> 00:36:08,720
It may be that the on the "cart" page, I want "sidebar" or "main content" columns

00:36:10,319 --> 00:36:17,319
to have a design or certain rules that are different from what is on the rest of the site.

00:36:17,549 --> 00:36:18,559
This is completely valid.

00:36:18,559 --> 00:36:21,559
What is not a good idea?

00:36:21,559 --> 00:36:23,250
Doing something like this.

00:36:23,250 --> 00:36:30,069
For example, I have my "promo-box" object, and in the sidebar I might want to overwrite the background color.

00:36:30,069 --> 00:36:31,160


00:36:31,160 --> 00:36:34,500
Why? Because here we are binding ourselves to the structure.

00:36:34,500 --> 00:36:41,500
It is easier to do something called sub-classing, which basically entails adding a second class to my element.

00:36:44,460 --> 00:36:46,400


00:36:46,400 --> 00:36:53,220
In this case we're making use of cascading.

00:36:53,220 --> 00:36:58,349
The second class, promo-box-dark, will overwrite the color through cascading.

00:36:58,349 --> 00:37:04,640
In this case we are riding on the fact that the sidebar class exists.

00:37:04,640 --> 00:37:09,270
If the sidebar class does not exist, this will not work.

00:37:09,270 --> 00:37:16,270
In this case, using something like the block-class, we could add different classes to our blocks.

00:37:22,230 --> 00:37:23,029


00:37:23,029 --> 00:37:27,020
And it doesn't matter if that block is in the sidebar or not, 

00:37:27,020 --> 00:37:33,839
nor if it is in the head or not. The rules still apply.

00:37:33,839 --> 00:37:40,839
Along the lines of subclassing, SASS has a feature called "extend".

00:37:40,970 --> 00:37:45,789
As you saw in the previous slide, I must have two different classes, or two different blocks.

00:37:45,789 --> 00:37:46,069


00:37:46,069 --> 00:37:53,069
Here I have two blocks of classes, but my element will only get one class.

00:37:54,490 --> 00:38:01,289
Why? Because with promo-box-dark I am extending what is in promo-box.

00:38:01,289 --> 00:38:06,670
The output of that would be something like this.

00:38:06,670 --> 00:38:13,670
Extend groups both the base class, which in this case is promo-box, and the promo-box-dark class,

00:38:16,240 --> 00:38:23,240
in which we are extending promo-box.

00:38:24,200 --> 00:38:30,880
[Inaudible]

00:38:30,880 --> 00:38:37,880
Exactly, the idea is that the block can be anywhere, independent of the sidebar.

00:38:53,869 --> 00:38:56,609


00:38:56,609 --> 00:38:59,170
[Inaudible]

00:38:59,170 --> 00:39:05,680
Okay. There are some precautions you must take when working with the extend.

00:39:05,680 --> 00:39:10,839
Let's say that the three points between the final class, the final block, and everything else form a completely separate file.

00:39:10,839 --> 00:39:16,799


00:39:16,799 --> 00:39:22,020
This is what will happen.

00:39:22,020 --> 00:39:25,520
Promo-box-dark doesn't exist, as you can see here.

00:39:25,520 --> 00:39:32,520
But extend, because of the way it works, you should imagine that it extends everything related to promo-box.

00:39:33,750 --> 00:39:35,069


00:39:35,069 --> 00:39:42,069
And that is enough to drive you crazy if you use extend extensively throughout the code base.

00:39:46,210 --> 00:39:51,700
If for some reason we wanted to use extend, there is an alternative option that is much cleaner

00:39:51,700 --> 00:39:57,079
and much easier to use. It is called "placeholder", or silent class.

00:39:57,079 --> 00:40:04,079
Unlike extend, where whatever we extend is a class, in this case what we use is

00:40:04,539 --> 00:40:11,539
a percentage, and in the first block we would declare all of the rules that we want to be general.

00:40:19,349 --> 00:40:26,349
Then, for each of my buttons, I'll extend the placeholder, which has the percentage.

00:40:27,250 --> 00:40:28,970


00:40:28,970 --> 00:40:34,579
Within each of those blocks, I would add different things.

00:40:34,579 --> 00:40:40,220
For the positive, a green background, and for the negative, a red background.

00:40:40,220 --> 00:40:43,089
The output would be something like this.

00:40:43,089 --> 00:40:45,910
It is much cleaner than extend.

00:40:45,910 --> 00:40:50,029
And even this example makes much more sense than the previous example.

00:40:50,029 --> 00:40:57,029
Why? Because everything is related.

00:40:58,619 --> 00:41:03,910
Often we want to come up with unique names for some reason.

00:41:03,910 --> 00:41:10,910
For example, think of when we work with JavaScript and we give it an ID and an element that serves as a bank.

00:41:11,230 --> 00:41:14,529


00:41:14,529 --> 00:41:21,279
But what happens if the selector we want to use for JavaScript is going to appear in more than one element?

00:41:21,279 --> 00:41:25,390


00:41:25,390 --> 00:41:30,599
One solution would be to use prefixes.

00:41:30,599 --> 00:41:37,599
In this example I have three classes within my class, but I have different prefixes.

00:41:39,150 --> 00:41:44,299
I have one with a prefix of "ui", one with prefix "js", and one with a prefix of "qa".

00:41:44,299 --> 00:41:51,299
Within the team, what we use is "qa" for the Selenium test, so

00:41:54,799 --> 00:41:58,190
these are the selectors it uses.

00:41:58,190 --> 00:42:05,190
If I occupy a JavaScript hook, we use the selector whose prefix is "js", and if the element

00:42:06,579 --> 00:42:11,990
with which I am working uses various styles, and I would only use a class that has a prefix of "ui".

00:42:11,990 --> 00:42:13,990


00:42:13,990 --> 00:42:16,730
So that is the point of this?

00:42:16,730 --> 00:42:22,910
If at any time we need to make a change to that element, we know what

00:42:22,910 --> 00:42:25,039
we can remove and what we cannot remove.

00:42:25,039 --> 00:42:32,039
If a widget is going to be removed from the base code, you can simply search for the elements that have

00:42:33,119 --> 00:42:35,579
these classes and they can be removed without any trouble.

00:42:35,579 --> 00:42:42,579
And you can rest assured that you won't lose any other partial or any other

00:42:43,630 --> 00:42:50,470
any other object; no other components will be affected.

00:42:50,470 --> 00:42:55,269
Why is all of this so important?

00:42:55,269 --> 00:42:57,609
You've got to have a convention.

00:42:57,609 --> 00:42:59,500
We must document it.

00:42:59,500 --> 00:43:04,279
And it's important, and the hardest thing about it is to stick to that convention.

00:43:04,279 --> 00:43:11,279
A couple of suggested readings about how to name things.

00:43:12,849 --> 00:43:14,799
Point number three, then. Documentation.

00:43:14,799 --> 00:43:21,799
Internally, we use a tool called Conference.

00:43:22,289 --> 00:43:29,289
Some people make it open, as does CodePen, and it's like their standard code.

00:43:30,250 --> 00:43:35,779
But what I've seen work better are comments.

00:43:35,779 --> 00:43:40,960
Why? Because whether we have all the information on our website or we have

00:43:40,960 --> 00:43:47,480
a tool in our Internet like Conference, it is very easy to update.

00:43:47,480 --> 00:43:54,480
Why? Because information can change from month to month, and if we don't modify it,

00:43:57,859 --> 00:44:00,640
new people will not be in the know.

00:44:00,640 --> 00:44:06,720
But if we work directly with comments in our code, it's very

00:44:06,720 --> 00:44:11,190
simple, it's extremely fast, and it's always easy for us to access.

00:44:11,190 --> 00:44:15,930
These are default or standard comments for CSS.

00:44:15,930 --> 00:44:22,930
I've always liked having a table of contents at the beginning that identifies each

00:44:26,349 --> 00:44:32,589
one of the sections in which I have related rules.

00:44:32,589 --> 00:44:38,829
When I'm creating blocks for that section, I have a section title,

00:44:38,829 --> 00:44:45,289
 and it's the same name that appears in the table of contents: reset.

00:44:45,289 --> 00:44:52,180
But I've learned that if you insert a character that we don't have in CSS or that we're never going to use,

00:44:52,180 --> 00:44:56,490
 like the equals sign (=) in this example, I can do a search by typing 

00:44:56,490 --> 00:45:03,490
"Control F + =Reset or =R" and it jumps right to that spot.

00:45:03,510 --> 00:45:10,510
It's very simple, but I have friends that say that the best developers are the laziest ones,

00:45:13,690 --> 00:45:18,150
the ones that like everything quick and easy.

00:45:18,150 --> 00:45:24,150
Specific titles, specific comments for a block.

00:45:24,150 --> 00:45:31,019
If we are trying to overwrite something, if we have a rule that we are marking as

00:45:31,019 --> 00:45:35,849
important, we can have a description of why we're marking it as important or why

00:45:35,849 --> 00:45:42,849
that rule or that block is out of place.

00:45:45,960 --> 00:45:51,779
These are syntax comments for SASS.

00:45:51,779 --> 00:45:58,779
In my partial of mixins we can have one mixin and have a brief description of what it does

00:46:00,329 --> 00:46:03,809
as an example of what to call the mixin.

00:46:03,809 --> 00:46:08,730
If I had parameters, I could say: "Ok, what are the parameters and how do I satisfy them?", as we do in this case.

00:46:08,730 --> 00:46:13,640


00:46:13,640 --> 00:46:20,640
And that's documentation that would make it so we could change or remove a mixin, and it is simply erased.

00:46:21,000 --> 00:46:22,470


00:46:22,470 --> 00:46:29,099
If we insert a new mixin directly in the partial and add a comment about how it works

00:46:29,099 --> 00:46:36,099
 and giving an example, our documentation will always work.

00:46:36,309 --> 00:46:43,309
As I mentioned before, CSS is not the problem here, and it's not always the problem.

00:46:44,029 --> 00:46:44,700


00:46:44,700 --> 00:46:49,890
Often the problem is that we have too many people on our team,

00:46:49,890 --> 00:46:54,980
and perhaps there's some discrepancy of knowledge between different team members.

00:46:54,980 --> 00:47:01,559
Each different member of the team uses different techniques and approaches to write CSS.

00:47:01,559 --> 00:47:05,150


00:47:05,150 --> 00:47:07,069
Therein lies the problem.

00:47:07,069 --> 00:47:08,410
Okay.

00:47:08,410 --> 00:47:10,700
Let's try to pull together everything we have been talking about.

00:47:10,700 --> 00:47:17,700
Pragmatism is more important than perfection.

00:47:17,730 --> 00:47:24,380
Having a "good enough" today is better than a "perfect" tomorrow.

00:47:24,380 --> 00:47:28,990
Whether or not we start working with one of the methodologies we have mentioned,

00:47:28,990 --> 00:47:35,799
and whether or not we use preprocessors, it's important to rethink how we are working

00:47:35,799 --> 00:47:42,799
and prepare our code base for changes and for the future.

00:47:42,829 --> 00:47:47,369
The team's code should be a book that anybody can read, not a personal journal

00:47:47,369 --> 00:47:52,140
that only I understand or that only one person understands.

00:47:52,140 --> 00:47:58,589
Because it's very common that whoever knew how the features of the base code worked

00:47:58,589 --> 00:48:05,589
gets fired or moves away, and then we're left without a way to modify a mixin since we don't understand how the features work.

00:48:05,819 --> 00:48:10,289


00:48:10,289 --> 00:48:12,400
Write less CSS.

00:48:12,400 --> 00:48:19,400
The more we abstract and simplify our code, the fewer moving parts

00:48:22,049 --> 00:48:29,049
we will have, and that gives us the advantage of being able to reduce failures.

00:48:30,130 --> 00:48:34,109
Why? Because every moving part is a potential failure.

00:48:34,109 --> 00:48:40,420
So we welcome any opportunity to reduce features or code.

00:48:40,420 --> 00:48:44,130
And modularity in CSS is not really the goal.

00:48:44,130 --> 00:48:45,940
Maintainability is the goal.

00:48:45,940 --> 00:48:52,410
If the CSS is modular but difficult to maintain, then we are not achieving what we want to.

00:48:52,410 --> 00:48:59,410
Why? Because the objective is that in the future, one month or one year from now,

00:48:59,549 --> 00:49:06,490
when we are working on the same project, it is easy to maintain or scale the project.

00:49:06,490 --> 00:49:07,859


00:49:07,859 --> 00:49:14,859
We cannot think in terms of today alone. We cannot think to use the latest features of SASS or

00:49:15,029 --> 00:49:19,059
LESS or whatever, and forget the important part.

00:49:19,059 --> 00:49:22,740
And, thank you very much.

00:49:22,740 --> 00:49:26,420
That's what I prepared for you.

00:49:26,420 --> 00:49:33,240
The slides will be here.

00:49:33,240 --> 00:49:40,240
You are invited to Drupal Camp, and you can evaluate the session when you have . . . [inaudible]

00:49:50,279 --> 00:49:55,960
Any questions?

00:49:55,960 --> 00:50:02,960
We were hoping you could give us a suggestion.

00:50:04,119 --> 00:50:09,650
How would you organize the responsive part if you've got it separated into components, would you sort it by the

00:50:09,650 --> 00:50:16,279
breakups or within the component, in case you have to use media queries, especially?

00:50:16,279 --> 00:50:17,089


00:50:17,089 --> 00:50:19,500
We'll see.

00:50:19,500 --> 00:50:26,500
One of the features of SASS is that it allows us to move around within the same block via queries.

00:50:30,819 --> 00:50:35,339


00:50:35,339 --> 00:50:42,339
Usually, with normal, or vanilla, CSS, we would write all the rules and then

00:50:49,210 --> 00:50:56,210
open the part of media queries and within that section overwrite or add to the rules.

00:50:56,859 --> 00:50:59,049


00:50:59,049 --> 00:51:06,049
SASS and LESS allow us to extend functionality, use variables to handle the break points,

00:51:06,450 --> 00:51:13,450
and nest within a selector in the same block anything related to that object.

00:51:14,420 --> 00:51:18,210


00:51:18,210 --> 00:51:25,210
Normally, I would not handle it in a separate file linked to a responsive because

00:51:25,319 --> 00:51:30,640
things can get a little complicated when ensuring maintainability or making a change.

00:51:30,640 --> 00:51:34,289
Why? Because you'd have to go to another file to make the change.

00:51:34,289 --> 00:51:41,289
If I have a block, and that block is the header, within the rules of my header and in

00:51:43,839 --> 00:51:50,839
my file, header.scss, I would write the corresponding things for responsive or non-responsive.

00:51:52,859 --> 00:51:54,029


00:51:54,029 --> 00:52:01,029
Now, in 2015, you've got to stop thinking in terms of responsive.

00:52:01,339 --> 00:52:07,420
That should be part of our flow.

00:52:07,420 --> 00:52:12,619
There are people who still want to charge extra, on grounds of "do you want your site to be responsive or not?"

00:52:12,619 --> 00:52:13,829


00:52:13,829 --> 00:52:19,809
That was a valid statement four years ago.

00:52:19,809 --> 00:52:26,809
Now, breakpoints are the easiest part of a responsive project.

00:52:27,470 --> 00:52:33,359
There are more complex and complicated things a client pays for than the act of defining where the breaks are.

00:52:33,359 --> 00:52:40,359


00:52:41,440 --> 00:52:48,440
My question has to do with tools and how you use them.

00:52:49,180 --> 00:52:55,039
For example, I don't have experience as a Drupal Teamer, and I'm not a frontend developer; I'm actually a backend developer.

00:52:55,039 --> 00:52:59,059


00:52:59,059 --> 00:53:04,109
So I try to do everything in CSS in order to avoid trouble everywhere else.

00:53:04,109 --> 00:53:06,940


00:53:06,940 --> 00:53:13,940
But if we use that technique of SCSS or SASS and I make a change to one of the modules,

00:53:15,750 --> 00:53:21,670
or to one of the partials, the problem would be that if I make that change,

00:53:21,670 --> 00:53:27,900
I wouldn't be able to see it automatically until I recompile all the other partials.

00:53:27,900 --> 00:53:33,720
So is there some tool that allows me to see if I make a quick change in some element?

00:53:33,720 --> 00:53:40,289


00:53:40,289 --> 00:53:42,640
Let's see.

00:53:42,640 --> 00:53:44,529
If you have something like ...

00:53:44,529 --> 00:53:51,529
Okay, if you have something like this, and let's say you make a change in the variables,

00:54:05,019 --> 00:54:07,759
right? Variables is a partial.

00:54:07,759 --> 00:54:14,759
So by default, if you run SASS to compile, it has a feature called

00:54:18,400 --> 00:54:25,400
"watch", which detects any change in variables automatically as the compiler runs.

00:54:30,369 --> 00:54:31,640
Right?

00:54:31,640 --> 00:54:38,640
And if, by default, you have a file like the screen, which is where I'm importing all

00:54:42,329 --> 00:54:49,329
my partials, the counterpart that would be screen.css will reflect the change.

00:54:49,999 --> 00:54:56,999
If you want it to be even faster, you can use, for example, a tool like Live Reload.

00:54:57,380 --> 00:55:00,049


00:55:00,049 --> 00:55:07,049
If you install Live Reload, then right when it detects a change, the page you have

00:55:09,769 --> 00:55:12,289
open and are working on will refresh.

00:55:12,289 --> 00:55:15,450
Thank you.

00:55:15,450 --> 00:55:21,789
One more question.

00:55:21,789 --> 00:55:28,789
I work with SASS, but I use it in a development setting.

00:55:29,210 --> 00:55:35,910
How do you do it, do you work with SASS in production? Or if you don't do it in production,

00:55:35,910 --> 00:55:42,509
do you work with CSS secure when you have to make a change and you forget about the site in development

00:55:42,509 --> 00:55:49,509
since if you make a change in CSS above, the development and production sites will not be synchronized? 

00:55:50,960 --> 00:55:51,839


00:55:51,839 --> 00:55:57,089
How would you handle that situation? Would you recommend using it in production or only in development?

00:55:57,089 --> 00:56:01,980


00:56:01,980 --> 00:56:04,880
The short answer: local.

00:56:04,880 --> 00:56:09,490
In other words, stick to development.

00:56:09,490 --> 00:56:15,470
It seems too dangerous to me to be making changes directly in production.

00:56:15,470 --> 00:56:21,369
That's not a good practice.

00:56:21,369 --> 00:56:28,369
We've all done that at some point, right? It's normal.

00:56:28,740 --> 00:56:32,569
We learn the hard way that it's not a good idea to do that.

00:56:32,569 --> 00:56:38,960
But it's best to work locally, whether you're working alone or as part of a team.

00:56:38,960 --> 00:56:41,890
If you work locally, all of your configurations are local.

00:56:41,890 --> 00:56:46,720
SASS will be local, it will be running locally, and compiling locally.

00:56:46,720 --> 00:56:53,700
And once you have everything read you just upload the compiled file to your production server.

00:56:53,700 --> 00:56:54,220


00:56:54,220 --> 00:57:01,150
[Inaudible]

00:57:01,150 --> 00:57:08,150
With everything I've experienced, I would not make a change in production, 

00:57:16,259 --> 00:57:18,839
no matter how small it is.

00:57:18,839 --> 00:57:23,440
I would try to make it locally, then compile again and upload the compiled version.

00:57:23,440 --> 00:57:29,890
Questions? Complaints? Anything else?

00:57:29,890 --> 00:57:31,499
Okay.

00:57:31,499 --> 00:57:33,539

YouTube URL: https://www.youtube.com/watch?v=VTCUnGmijDQ


