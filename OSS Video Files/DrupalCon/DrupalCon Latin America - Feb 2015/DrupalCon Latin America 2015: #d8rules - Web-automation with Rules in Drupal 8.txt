Title: DrupalCon Latin America 2015: #d8rules - Web-automation with Rules in Drupal 8
Publication date: 2015-02-11
Playlist: DrupalCon Latin America - Feb 2015
Description: 
	Speakers: dasjo
The #d8rules initiative works on porting the Rules module to Drupal 8. In this session we will learn how to upgrade our Drupal 7 modules that integrate with Rules to Drupal 8.

* Applying new architectural patterns in Drupal 8
* Understanding the Core Plug-in & Context systems
* CMI: Configuration entities and YAML files
* Rules API Changes
* Typed data & Entity API changes
* Using Rules Action, Condition & Event APIs
* Embedding reusable components: Use rules conditions in the Blocks UI
* Contributing to Rules in Drupal 8

The session will be a great case study for people familiar with basic Drupal development concepts eager to jump into developing for Drupal 8. As Rules tries to leverage best-practices as much as possible, it is a great starting point to learn all the new things.
Captions: 
	00:00:00,000 --> 00:00:11,080
[Spanish] Hello, I am Josef Dabernig.

00:00:11,269 --> 00:00:17,859
Who of you has used the Rules module in Drupal 7 or 6?

00:00:17,859 --> 00:00:23,539
I guess more than half of you. That's cool. Awesome.

00:00:23,539 --> 00:00:30,539
Today I'm talking about Rules in Drupal 8. It's not ready, disclaimer, but we can already

00:00:30,699 --> 00:00:37,660
see a lot of things and hope there will be stuff that gets you interested.

00:00:37,660 --> 00:00:42,450
My name is Josef Dabernig. My Twitter handle and wherever in the community,

00:00:42,450 --> 00:00:49,309
you can find me as dasjo. I'm originally from Austria.

00:00:49,309 --> 00:00:53,690
That's in Europe. The capital city is Vienna, but I recently

00:00:53,690 --> 00:00:58,320
moved to Zurich to work with the amazing guys from Amazee Labs.

00:00:58,320 --> 00:01:03,620
I work as a Deputy Head of Technology together with Michael Schnitzel.

00:01:03,620 --> 00:01:07,740
You probably know him from taking pictures of DrupalCons.

00:01:07,740 --> 00:01:13,540
Together we run a team of 12 developers, and we also have sister companies in Austin and

00:01:13,540 --> 00:01:20,540
another company, Amazee Metrics, which is specifically dedicated to SEO solutions.

00:01:24,759 --> 00:01:30,320
That's our team. We are very dedicated to design, and we always

00:01:30,320 --> 00:01:35,820
have job offers open. If you want to move to Zurich or Austin and

00:01:35,820 --> 00:01:42,820
you feel like you want to be part of that amazing team, obviously let us know.

00:01:43,250 --> 00:01:50,250
You might also know me from contributed modules, like the Facet API Pretty Paths or my master

00:01:50,610 --> 00:01:56,110
thesis that I wrote on Geocluster, which is about how can I put millions of points on

00:01:56,110 --> 00:02:05,510
a map and still have a performant user experience. What really keeps me passionate for Drupal

00:02:05,759 --> 00:02:09,789
is not just the technology, but you guys, the community.

00:02:09,789 --> 00:02:14,349
Actually, I started using Drupal extensively when I lived in Central America.

00:02:14,349 --> 00:02:20,330
There, I started using Drupal tours, so I traveled from down

00:02:20,330 --> 00:02:26,800
Nicaragua through El Salvador, Guatemala, Belize, and Mexico.

00:02:26,800 --> 00:02:33,230
Two years later, I traveled again down to Costa Rica, doing presentations about Drupal

00:02:33,230 --> 00:02:47,210
because I think the ability to share is what helped me being a successful contributor and

00:02:47,230 --> 00:02:52,430
doing a successful business with Drupal. I think it's very crucial that we share this knowledge.

00:02:52,430 --> 00:02:57,620
This also makes me very happy to be able to

00:02:57,620 --> 00:03:03,040
be part of the first Latin American DrupalCon. Yes.

00:03:03,040 --> 00:03:11,500
Okay, so far for the intro. D8rules is an initiative that is not just me,

00:03:11,750 --> 00:03:17,849
but we are actually a team. Surprise, all of those five guys, we are from Austria.

00:03:17,849 --> 00:03:22,310
There is the creator of the Rules module, Fago.

00:03:22,310 --> 00:03:24,540
You might know him also from other modules

00:03:24,540 --> 00:03:31,099
like the Entity API, Field Collection, Profile2, and much, much more.

00:03:31,099 --> 00:03:34,480
Klausi is his co-maintainer. We also have Fubhy on the team.

00:03:34,480 --> 00:03:44,680
He is the creator of the Omega4 module. They are very dedicated Drupal core contributors.

00:03:45,319 --> 00:03:49,840
I'm responsible for communication, and we also have a designer on board.

00:03:49,840 --> 00:03:54,769
Nico has also done quite some designs. They have the Drupical website.

00:03:54,769 --> 00:03:58,430
Maybe you know that. Drupical is a website where you can have a

00:03:58,430 --> 00:04:08,050
nice overview of all the Drupal events. Together, we figured the Rules module in Drupal 8,

00:04:08,209 --> 00:04:10,739
it's going to be difficult.

00:04:10,739 --> 00:04:18,219
The reason is Rules is a very complex module. Has anyone ever debugged the Rules module?

00:04:18,630 --> 00:04:23,030
Has anyone ever tried to start debug through Rules?

00:04:23,030 --> 00:04:25,810
How did you like it? Yeah.

00:04:26,020 --> 00:04:36,940
I had the same experience. We figured it's going to be hard because those

00:04:37,210 --> 00:04:41,080
guys are really, really busy. Klausi is working on the security team.

00:04:41,080 --> 00:04:47,340
Fago is maintaining Drupal core modules. He's running his own business.

00:04:47,340 --> 00:04:53,759
We kind of want to do this, so we formed a team and we did some other steps that I will explain later.

00:04:53,759 --> 00:05:00,759
What is Rules actually?

00:05:00,870 --> 00:05:05,840
There's this great presentation from amitaibu. You should look it up.

00:05:05,840 --> 00:05:08,880
It's from DrupalCon Copenhagen, which was my first DrupalCon.

00:05:08,880 --> 00:05:16,680
It's about organic groups. Amitaibu was interviewing different people from the United Nations.

00:05:16,860 --> 00:05:22,460
There, he has a quote where Angela Merkel,

00:05:22,460 --> 00:05:29,460
the Germany Chancellor, she says, "There must be rules in the world."

00:05:29,800 --> 00:05:33,460
I guess at some point we all need rules. We also need rules in our community.

00:05:33,460 --> 00:05:37,970
We even have a code of conduct, which helps us be respectful with each other.

00:05:37,970 --> 00:05:43,729
Rules, obviously, in terms of Drupal, it's more about, I want to have some logic in the system.

00:05:43,729 --> 00:05:50,600
I want to make something happen on the website.

00:05:50,600 --> 00:05:54,100
There's an acting user or something that's happening in the system.

00:05:54,100 --> 00:05:58,680
It doesn't have to be a person, per se. It can also be a cron job that's running that's

00:05:58,680 --> 00:06:03,870
generating an event. Then we have some conditions to validate, 

00:06:03,870 --> 00:06:07,750
"Do we really want to do something right now?", for example.

00:06:07,750 --> 00:06:14,190
The content has been updated, and if the content author is different than the acting user,

00:06:14,190 --> 00:06:20,240
then I want to invoke something. Let's have an action.

00:06:20,240 --> 00:06:26,060
In this case, I will send out a notification. That's the very basic concept of rules,

00:06:26,060 --> 00:06:32,850
and by just combining any kind of event with any kind of condition and any kind of action,

00:06:32,850 --> 00:06:39,850
we actually can create what we call in software engineering a Turing complete machine.

00:06:40,130 --> 00:06:47,130
It basically allows us to do any programming. The cool thing is, you can do this in code,

00:06:48,020 --> 00:06:52,410
but the Rules module allows you to do this via the admin user interface.

00:06:52,410 --> 00:06:58,729
It really is an efficient way to create those events, specify the conditions based on all

00:06:58,729 --> 00:07:05,650
the metadata that is available in the system, and then react on it.

00:07:05,650 --> 00:07:12,099
Rules really is about building flexible workflows using those events, conditions, and actions.

00:07:12,099 --> 00:07:19,099
For example, we often give it to our clients so that they can customize the emails they

00:07:19,300 --> 00:07:22,259
want to send out. Have you ever had the experience that

00:07:22,259 --> 00:07:29,220
the client wants to change some string that has to be sent out, and you have to ask your developer

00:07:29,220 --> 00:07:33,610
to change that string in the code, and you have to deploy it?

00:07:33,610 --> 00:07:36,900
It's really tedious, right? It's not the work that we want to do on a daily basis.

00:07:36,900 --> 00:07:40,509
Why not just set up a rule that the client

00:07:40,509 --> 00:07:47,509
can configure themselves? We can also create custom re-directions, system messages.

00:07:47,979 --> 00:07:54,520
The Rules module has shown to be pretty successful.

00:07:54,520 --> 00:07:58,639
It's not something that you would install on every site.

00:07:58,639 --> 00:08:03,129
I also know a lot of people that say, "I don't need Rules. I don't like this module. It's

00:08:03,129 --> 00:08:10,129
not the way that a developer should work with this system. It's like this clicky thingy, right?"

00:08:10,139 --> 00:08:14,509
On the other hand, we can say there's hundreds of integration modules.

00:08:14,509 --> 00:08:19,960
It integrates into the whole system that makes Drupal so powerful.

00:08:19,960 --> 00:08:24,370
We expose all the entity metadata, the fields.

00:08:24,370 --> 00:08:31,370
We can iterate upon Views. We can access all the data from hundreds of

00:08:31,849 --> 00:08:36,870
integration modules. On one hand, Rules might be considered as

00:08:36,870 --> 00:08:43,870
a toy that site builders want to play with, but on the other hand it's also very good

00:08:44,099 --> 00:08:51,099
for the developers so they can be forced to specify the important APIs.

00:08:52,180 --> 00:08:59,180
Rules, from my feeling, is a very good system that allows the bridge between the developer

00:08:59,860 --> 00:09:06,860
and the site builder to be as efficient as possible because when you provide an integration with Rules,

00:09:07,130 --> 00:09:14,130
you will be sure that anyone can integrate.

00:09:15,730 --> 00:09:19,070
That was kind of the success story of Rules in Drupal 7.

00:09:19,070 --> 00:09:24,230
For Drupal 8, we obviously had some ideas.

00:09:24,230 --> 00:09:27,210
In general, we have seen from the keynote,

00:09:27,450 --> 00:09:33,110
there is a lot of excitement about the object-oriented programming.

00:09:33,110 --> 00:09:37,750
Rules in Drupal 7 already embraces some of the object-oriented programming, but now we

00:09:37,750 --> 00:09:45,790
can really rely on the plugins and all the systems that are already in place for Drupal 8,

00:09:46,060 --> 00:09:53,060
and we don't have to bring in our own plugin system, for example.

00:09:54,490 --> 00:10:01,490
That's the general excitement for Drupal 8. What we want to bring as a Rules initiative

00:10:01,660 --> 00:10:10,380
to the developers is really align how you work with Rules with the Drupal 8 developer experience.

00:10:10,610 --> 00:10:18,650
The object-oriented style, the dependency injection and everything should be as aligned as possible.

00:10:18,850 --> 00:10:23,390
Also, as we are one of the first big contrib modules,

00:10:23,390 --> 00:10:31,810
we want to show developers how the coding style of Drupal 8 should look like

00:10:32,070 --> 00:10:36,490
from our perspective. That's by using extensively the plugin system.

00:10:36,490 --> 00:10:43,490
We are relying on all the good things that Fago brought into the Drupal project as the

00:10:43,829 --> 00:10:50,829
entity API, which now has a spin-off called typed data, which is actually more of an abstraction.

00:10:53,649 --> 00:11:00,649
Typed data is really a low-level API that allows you to specify how the data is structured.

00:11:02,120 --> 00:11:05,860
We can use that in Entities. We can use that in Fields, but we can also

00:11:05,860 --> 00:11:12,860
use it just for parameter configuration. The way that Rules works, we always need to

00:11:12,920 --> 00:11:17,589
specify some input parameters that we can then process upon and then forward it,

00:11:17,589 --> 00:11:22,680
for example, to the next action. All that system can now be based on the generic

00:11:22,680 --> 00:11:29,560
typed data API that is shared across the whole Drupal 8 ecosystem.

00:11:29,560 --> 00:11:36,560
Who has used Panels? You remember the confusion about context in

00:11:36,579 --> 00:11:42,579
Panels and the Context module? Context and Panels is actually the very same

00:11:42,579 --> 00:11:49,100
thing as we are dealing with in Rules because we want to specify the data that we need,

00:11:49,100 --> 00:11:53,870
and then we want to forward it and so on. The way that Panels Context works is really the same.

00:11:53,870 --> 00:11:57,510
I mean, you specify an input parameter of type user.

00:11:57,510 --> 00:12:01,200
Then, I'm going to use the email address of the user, for example.

00:12:01,200 --> 00:12:06,470
We have some common problems across contrib in Drupal 8,

00:12:06,470 --> 00:12:13,470
and the earlier as possible we are going to tackle those, the better the whole

00:12:13,750 --> 00:12:20,750
consistency of the system will end up being. Deployable config via CMI.

00:12:21,350 --> 00:12:27,810
I mean, who doesn't love CMI? Rules in Drupal 7 already had its own exportables,

00:12:27,810 --> 00:12:31,529
but now we can really be aligned with the whole system.

00:12:31,529 --> 00:12:37,820
I think from a developer's perspective, those are the big wins that we envision for Rules

00:12:37,820 --> 00:12:41,610
in Drupal 8. Then, there's this whole topic I already mentioned

00:12:41,610 --> 00:12:47,820
a bit about the reusable components. We're trying to share the context API with

00:12:47,820 --> 00:12:53,529
projects that already exist. Page Manager is like a spin-off of CTools

00:12:53,529 --> 00:12:56,800
in Drupal 8. It's already using the Drupal core context API.

00:12:56,800 --> 00:13:00,519
We're working together on fixing core bugs

00:13:00,519 --> 00:13:05,829
or improving those APIs so that all the systems can work well together.

00:13:05,829 --> 00:13:10,950
We will need tokens. You remember, specifying email.

00:13:10,950 --> 00:13:15,730
Within the email, you want to have the username being printed.

00:13:15,730 --> 00:13:21,339
Who had problems with tokens in Drupal 7? Incompatibilities?

00:13:21,339 --> 00:13:26,279
Yeah. I'm not sure if we're going to be able to

00:13:26,279 --> 00:13:31,950
fix all of the problems, but at least we are trying.

00:13:31,950 --> 00:13:38,950
We want to make tokens reusable. Then, typed data, the way that you can specify parameters.

00:13:39,610 --> 00:13:43,959
On top of specification, what Rules usually

00:13:43,959 --> 00:13:50,029
does is exposing a form that the user, for example, can enter the date that is required

00:13:50,029 --> 00:13:56,120
to execute this component. That's also used, for example, in Views bulk operations.

00:13:56,120 --> 00:14:01,250
That's probably something that not everyone has used,

00:14:01,250 --> 00:14:07,529
but in Drupal 7 you can specify Rules components, then you can tie them into

00:14:07,529 --> 00:14:14,529
the Views bulk operations, and then the user can input the data that is additionally being configured.

00:14:15,639 --> 00:14:21,380
Such widgets for inputting the data and also

00:14:21,380 --> 00:14:26,519
formatting any structured data, we will have to do it in Rules in Drupal 8, and we want

00:14:26,519 --> 00:14:32,540
to make it reusable, because it's not something that is specific to the Rules use case, 

00:14:32,540 --> 00:14:35,579
but it's something that we can solve on a general level.

00:14:35,579 --> 00:14:41,360
If you have been to the talk of Eclipse, did you see yesterday?

00:14:41,360 --> 00:14:46,860
All the things about making components better decoupled, I think it's really important.

00:14:46,860 --> 00:14:53,490
It's something that we want to embrace doing the Rules Drupal 8 port.

00:14:53,490 --> 00:15:03,710
Then, I think embeddable UI components. For example, right now Drupal 8 conditions

00:15:04,010 --> 00:15:10,990
API is already tied into the block system. What you could also do is then a Rules condition.

00:15:10,990 --> 00:15:17,480
It could just be exposed into the block UI configuration as a selection rule.

00:15:17,480 --> 00:15:24,389
Specifying the visibility of blocks via Rules conditions is, for example, a possibility

00:15:24,389 --> 00:15:31,019
that we see here. Finally, I think one of the major advantages

00:15:31,019 --> 00:15:37,300
of the Rules module is obviously the UI. You remember the data selector.

00:15:37,300 --> 00:15:44,060
There would be so many places in Drupal where we can reuse the same data selector.

00:15:44,060 --> 00:15:49,949
When we, in Panels, specify a context, we could just use the very same data selector

00:15:49,949 --> 00:15:56,949
as we have it available in Rules. That's kind of our vision here.

00:15:58,920 --> 00:16:11,760
Site builders should obviously get all the admin UI improvements that we have seen on the general level in Drupal 8.

00:16:12,180 --> 00:16:21,280
Drupal 8 has a much more consistent UI. Unfortunately, at the very same moment,

00:16:21,579 --> 00:16:27,440
but there's a very good session from Lewis Nyman about how they created the style guide for the Seven theme.

00:16:27,440 --> 00:16:31,440
We're working hard on solving the problems

00:16:31,440 --> 00:16:36,899
that we see for the Rules UI. We haven't implemented it yet.

00:16:36,899 --> 00:16:43,720
The idea is that all the UI components that we have to implement for Rules, they should

00:16:43,720 --> 00:16:50,720
be shareable because there will be similar problems that other modules have to solve.

00:16:50,930 --> 00:16:57,310
For example, you need kind of a complex adds dialogue. We have already seen that in the Views UI.

00:16:57,310 --> 00:17:03,300
In Views, you kind of say, "Add a filter," and you can select from all the available filters.

00:17:03,300 --> 00:17:06,400
In Rules it's pretty much the same.

00:17:06,400 --> 00:17:11,140
I want to add an action, I want to have the actions grouped by category, so why don't

00:17:11,140 --> 00:17:16,939
we just rely on the same UI patterns? That will also help site builders use the

00:17:16,939 --> 00:17:23,370
site more efficiently, because when we have the similar approaches across the system,

00:17:23,370 --> 00:17:28,780
it just makes more sense to them. Site builders, as mentioned, the Views bulk

00:17:28,780 --> 00:17:35,780
operations that Larry showed in the morning, they are a part of Drupal core.

00:17:36,660 --> 00:17:40,390
There's also an action and conditions API in core.

00:17:40,390 --> 00:17:46,760
If we would be able to expose Rules actions using the standard actions API, then we would

00:17:46,760 --> 00:17:52,130
be able to use just right away the simple bulk operations.

00:17:52,130 --> 00:17:59,130
I think that's pretty cool. Who has worked with Rules components?

00:18:00,410 --> 00:18:06,900
I have this experience that working with Rules components sometimes is a bit hard for creating

00:18:06,900 --> 00:18:10,650
advanced logic. Maybe advanced logic shouldn't have been Rules at all,

00:18:10,650 --> 00:18:16,450
but if we already have the tools available, I want to do an if/else, or I want to do this

00:18:16,450 --> 00:18:20,500
kind of logic. You really, really quickly hit the boundary

00:18:20,500 --> 00:18:24,820
where Rules forces you to build the logic bottom-up.

00:18:24,820 --> 00:18:31,049
You have to first create the components that you then call the parent rule, that you then call the buff.

00:18:31,049 --> 00:18:36,840
Nobody understands the system at all anymore. There is a contrib module, you should check

00:18:36,840 --> 00:18:42,620
it out in Drupal 7, that's called Rules conditional, which allows you to create those advanced logics.

00:18:42,620 --> 00:18:48,140
For Drupal 8, we kind of feel that "Inline Rules"

00:18:48,140 --> 00:18:52,980
is a concept that will just help us get rid of all of those problems.

00:18:52,980 --> 00:18:59,980
If you are able to nest rules in Rules using a top-down approach, and we haven't figured

00:19:00,090 --> 00:19:06,070
out the UI on that yet, but I think that will really help us.

00:19:06,070 --> 00:19:11,150
If any of those ideas gets you interested, you should really come tomorrow to the sprints

00:19:11,150 --> 00:19:18,150
and discuss details on that with us. That all sounds nice.

00:19:20,130 --> 00:19:24,620
I think you should already go online and download the Rules module, right?

00:19:24,620 --> 00:19:31,620
Then you can just try it out. Before that, we have to do.

00:19:33,260 --> 00:19:40,260
It was almost a year ago just before Drupal Developer Days where I talked to Fago about

00:19:41,110 --> 00:19:47,309
the concerns that we have that Rules will never be ported to Drupal 8 because everyone

00:19:47,309 --> 00:19:53,960
is just too busy trying to work on Drupal core, and contrib is usually an afterthought.

00:19:53,960 --> 00:19:59,480
We felt like it's really, really important, and this is why we came up with the #d8rules

00:19:59,480 --> 00:20:04,110
campaign. You probably have seen such stickers around.

00:20:04,110 --> 00:20:10,520
We are really trying to get some momentum there.

00:20:10,520 --> 00:20:17,200
The vision is that the earlier Rules is there, the earlier other contributed modules can

00:20:17,200 --> 00:20:24,200
also get their integrations ported. The big goal of #d8rules is accelerate all

00:20:26,110 --> 00:20:33,110
the Drupal 8 uptake all together. Obviously, site builders will be able to create

00:20:33,549 --> 00:20:38,669
their flexible workflows. The whole initiative for us is also about

00:20:38,669 --> 00:20:48,469
making a statement that contribution just takes a lot of time, and we are in an Open Source society

00:20:48,669 --> 00:20:52,679
where we kind of rely on each other.

00:20:52,679 --> 00:20:59,620
I would really recommend, I don't want to go too much into detail because this session

00:20:59,620 --> 00:21:05,480
is more about developers, what you can expect for Drupal 8 in Rules, but I think the whole

00:21:05,480 --> 00:21:12,480
discussion about sustainability in Drupal is really important to have.

00:21:12,799 --> 00:21:19,159
Dries did a very great keynote in Amsterdam that you can watch online about his vision

00:21:19,159 --> 00:21:25,590
of how the whole Drupal ecosystem can make contribution more sustainable.

00:21:25,590 --> 00:21:32,320
Check this out. We decided, "Okay, we will do some crowdfunding."

00:21:32,320 --> 00:21:39,320
Thanks to those more than 300 individuals who donated to help us get the Rules module ported.

00:21:40,830 --> 00:21:46,140
Because I said the developers don't have enough free time,

00:21:46,140 --> 00:21:53,140
so our decision was the companies that employ Fago and Klausi, they provide

00:21:54,130 --> 00:22:03,290
a community rate of 45 euros. Usually in Austria you would charge your client

00:22:03,549 --> 00:22:09,309
100 euros, for example. It's like the base cost where they can employ

00:22:09,309 --> 00:22:15,830
their developers to work on it, but they don't make any money anymore.

00:22:15,830 --> 00:22:27,510
All those individuals and also those generous companies help us gather the funds that we

00:22:27,870 --> 00:22:32,620
need to get the Rules module ported. How can we help with this number?

00:22:32,620 --> 00:22:39,610
It's basically a bit more than 1,000 development hours that have been estimated to port the

00:22:39,610 --> 00:22:43,350
whole Rules module from Drupal 7 to Drupal 8.

00:22:43,350 --> 00:22:48,700
As you can see, milestone one we have successfully funded.

00:22:48,700 --> 00:22:54,700
We haven't figured out a solution for the other milestones yet, but it was really a

00:22:54,700 --> 00:23:01,700
great success for us, being able to motivate so many people to just chip in and help us

00:23:02,039 --> 00:23:09,039
free up some very precious top Drupal core developer time to not only work on Drupal

00:23:09,419 --> 00:23:16,419
core, but also work on the Rules module. We did that campaign about April to May last year.

00:23:20,370 --> 00:23:24,820
Then we had the money.

00:23:24,820 --> 00:23:30,289
Then we just had to do it. The development road map looks like this,

00:23:30,289 --> 00:23:37,289
so in milestone one, we worked on the Rules core engine, implement all the plugins, the

00:23:37,490 --> 00:23:41,200
Rules actions and conditions APIs of Drupal core.

00:23:41,200 --> 00:23:48,200
Our vision was really to match them. If we can decide to fork the system 

00:23:49,210 --> 00:23:56,210
or can try to fix it in Drupal core. As long as Drupal core is not frozen, 

00:23:59,520 --> 00:24:04,970
that's the thing to do, obviously. All of these steps, they have an error,

00:24:04,970 --> 00:24:11,169
so they are almost complete. Milestone two is about completing the Rules

00:24:11,169 --> 00:24:16,750
engine features, the advanced plugins like Events and Loops, the entity token support,

00:24:16,750 --> 00:24:22,260
the CMI integration that has already started, and some generic integrations.

00:24:22,260 --> 00:24:27,770
In milestone three, we'll tackle the user interface, the reusable UI components.

00:24:27,770 --> 00:24:34,679
We'll also have to upgrade the scheduling. Finally, the existing integrations.

00:24:34,679 --> 00:24:41,210
Rules ships with quite some actions that integrate with Drupal core.

00:24:41,210 --> 00:24:47,169
For example, there is an action to send out the mail.

00:24:47,169 --> 00:24:54,169
Together with the community in sprints, we've already ported lots of those core conditions.

00:24:54,640 --> 00:25:01,640
It's really a great thing where we work together with the community to train all of you on

00:25:01,679 --> 00:25:08,679
the new Drupal 8 APIs, and we did that at several DrupalCamps and DrupalCons.

00:25:09,779 --> 00:25:16,779
Right now, we already have 45 forks of the Rules module, which is developed on GitHub.

00:25:16,929 --> 00:25:23,929
All those people have patches committed or pull requests being merged, so that's really cool,

00:25:24,150 --> 00:25:29,600
and thanks to all of those. If you want to be part of that, find me tomorrow in the sprints.

00:25:29,600 --> 00:25:36,600
That's how that works.

00:25:42,240 --> 00:25:48,200
How many of you are developers that kind of would be interested?

00:25:48,200 --> 00:25:53,169
Awesome. Cool. Who has already written Rules integration,

00:25:53,169 --> 00:26:00,169
let's say, in Drupal 6 or 7? Implement, action, condition...

00:26:00,190 --> 00:26:02,159
Cool. Awesome.

00:26:02,159 --> 00:26:09,159
The way we are going to do this in Drupal 8 right now, we need a working Drupal 8 installation, obviously.

00:26:09,169 --> 00:26:11,830
Then we go in GitHub and just fork the Rules

00:26:11,830 --> 00:26:16,120
module from Fago's repository. It's pretty straightforward.

00:26:16,120 --> 00:26:22,340
As mentioned, already 45 people have forked it.

00:26:22,340 --> 00:26:26,140
Then we kind of have to figure out what to do there.

00:26:26,140 --> 00:26:32,320
In the issue queue we have some novice tasks, so there are some pretty easy tasks to get started,

00:26:32,320 --> 00:26:36,600
but most of them are a little bit more advanced.

00:26:36,600 --> 00:26:43,600
I'd like to walk you through the different APIs that you will work with.

00:26:46,460 --> 00:26:53,010
To make a disclaimer, on a daily basis I'm not developing anymore.

00:26:53,010 --> 00:27:00,010
I have a background in computer science, but I wouldn't consider myself as the best developer

00:27:00,179 --> 00:27:04,440
at Amazee Labs. I'm more like specifying tasks and reviewing

00:27:04,440 --> 00:27:09,980
all that stuff, so bear with me if there are any errors in there.

00:27:09,980 --> 00:27:16,980
I try my best to understand what Fago and Klausi and Fubhy did there.

00:27:18,289 --> 00:27:25,289
There are different APIs in Drupal 7 for Rules. One of them allows you to expose structured

00:27:27,169 --> 00:27:32,919
data to the Rules. In Drupal 7, we have the Rules data info,

00:27:32,919 --> 00:27:40,779
and the whole entity API, the whole entity system is exposed, so there are those two hooks.

00:27:41,000 --> 00:27:44,059
Want to add new data?

00:27:44,059 --> 00:27:49,309
If you want to expose, for example, you have some custom table in your database and you

00:27:49,309 --> 00:27:55,940
want to make Rules aware of the custom-structured table, you can do that via Rules data info.

00:27:55,940 --> 00:28:00,960
If you want to add some additional properties, you just do it with the entity info property alter,

00:28:00,960 --> 00:28:06,279
and Rules will automatically pick up. It's the same process, for example, that we

00:28:06,279 --> 00:28:10,669
use when working with search API. If we want to index something in addition,

00:28:10,669 --> 00:28:15,140
we just create our own properties, which is cool.

00:28:15,140 --> 00:28:21,740
In Drupal 8, we have the whole typed data system. The typed data system, as I said, allows us

00:28:21,740 --> 00:28:27,059
to access the structured data, and there are some interfaces.

00:28:27,059 --> 00:28:29,210
There are the primitive types and the complex types.

00:28:29,210 --> 00:28:40,650
I can show you some examples. You can see that there's a primitive base that,

00:28:40,880 --> 00:28:47,279
for example, the floating class extends. We can already see that there are some annotations being used.

00:28:47,279 --> 00:28:53,059
It's pretty straightforward.

00:28:53,059 --> 00:29:03,359
The primitives need some castings. Then there's more complex properties.

00:29:04,690 --> 00:29:13,350
For example, if something is like a structure, what we do here is specify all the properties

00:29:13,799 --> 00:29:19,270
in the property definition function. For example, the link item has a URL

00:29:19,270 --> 00:29:24,899
and a title and so forth. I tried to reduce those examples to the most

00:29:24,899 --> 00:29:31,740
important stuff. That's the way that we can describe data in

00:29:31,740 --> 00:29:36,500
Drupal 8. Basically, all you have to do in Drupal 8

00:29:36,500 --> 00:29:43,500
is implement your own data type plugins. It's just a plugin class that will be picked

00:29:44,690 --> 00:29:48,520
up by the system, and then Rules can also deal with that.

00:29:48,520 --> 00:29:58,340
The entity property info alter is now based on the Drupal hook that is called hook_data_type_info_alter.

00:29:59,720 --> 00:30:04,600
The usual stuff that you do when working with Rules is you want to create your own actions.

00:30:04,600 --> 00:30:11,450
You want to create your own conditions. You want to create your own event.

00:30:11,450 --> 00:30:17,440
To do that, let's get a quick introduction in the whole object-oriented programming style

00:30:17,440 --> 00:30:22,100
that has changed quite a lot from Drupal 7 to Drupal 8.

00:30:22,100 --> 00:30:29,100
We're using annotations to describe the plugins that we have instead of info hooks.

00:30:30,159 --> 00:30:37,159
We have auto-loading, so it just puts the plugins under a specified folder and file structure,

00:30:39,289 --> 00:30:46,289
and the system will automatically recognize them.

00:30:47,820 --> 00:30:51,110
Discovery is basically together with the auto-loading. Derivatives.

00:30:51,110 --> 00:30:58,110
We have not implemented any derivatives for Rules yet, but we will certainly have them.

00:30:58,730 --> 00:31:05,730
Imagine there is a "create entity" action. We could create derivatives that say, "Create

00:31:05,769 --> 00:31:11,919
entity of type node action" or, "Create user action." "Create a taxonomy term action."

00:31:11,919 --> 00:31:18,919
This would basically be derivatives of a standard plugin based on the entity type.

00:31:22,010 --> 00:31:27,480
How do we provide conditions? In Drupal 7, we had some info hooks and some

00:31:27,480 --> 00:31:33,809
call-backs, not very well structured. I think that the way that we have it now in

00:31:33,809 --> 00:31:39,440
Drupal 8 is much more approachable because you have everything self-contained, as the

00:31:39,440 --> 00:31:45,809
following example. This is the class that says "node is sticky,"

00:31:45,809 --> 00:31:49,760
so I have a condition that checks if a node is sticky.

00:31:49,760 --> 00:31:56,070
Instead of the info hook that is somewhere else in the system, I really have it right

00:31:56,070 --> 00:32:02,950
next to the class in the annotation. There are no first-class annotations in PHP,

00:32:02,950 --> 00:32:12,190
but we use the dock blocks to get there. The condition itself, what we usually expect

00:32:13,200 --> 00:32:20,200
in an info hook is now within the annotation. We can see that, for example, there are @translation

00:32:20,480 --> 00:32:27,480
tags which allow us to make that translatable. I will get into the context later on, 

00:32:28,500 --> 00:32:35,500
but that just tells the system, "Okay, I will have now the machine in Rules 'node is sticky'

00:32:35,679 --> 00:32:42,679
in the category of the nodes," so this condition is now based on that annotation being registered.

00:32:42,830 --> 00:32:46,950
That's it. Then what do I have to do?

00:32:46,950 --> 00:32:53,029
I will just extend the Rules condition base and implement the evaluation function.

00:32:53,029 --> 00:32:58,100
I will explain the context later, but what the condition usually does is return a true

00:32:58,100 --> 00:33:01,279
or false value. In this case, we are checking if the node

00:33:01,279 --> 00:33:08,279
is sticky, and that's all the rules do. Who thinks this is too complicated?

00:33:12,110 --> 00:33:14,539
Cool. Awesome.

00:33:14,539 --> 00:33:19,440
Okay, actions. It's pretty much the same.

00:33:19,440 --> 00:33:24,950
We, again, have the annotation. In this case we have an action that deletes

00:33:24,950 --> 00:33:29,950
any entity. We could have derivatives which allow us to

00:33:29,950 --> 00:33:36,950
delete just nodes, but for the sake of simplicity, let's just keep it with the entity delete.

00:33:38,840 --> 00:33:44,149
Instead of an evaluate, we have an execute function, and that's it.

00:33:44,149 --> 00:33:47,799
Pretty straightforward. Finally, events.

00:33:47,799 --> 00:33:54,799
We don't have events yet. It just hasn't been implemented yet.

00:33:56,890 --> 00:34:00,510
What we have right now is all the actions and conditions.

00:34:00,510 --> 00:34:05,980
We already have 10 conditions, 10 actions ported.

00:34:05,980 --> 00:34:09,849
It's pretty cool. It's not only this, but we will see how to test

00:34:09,849 --> 00:34:14,609
them later on. It's a really good way to get into the whole

00:34:14,609 --> 00:34:21,609
plugin system of Drupal 8. Good.

00:34:24,510 --> 00:34:31,510
Context. Rules have to act upon a specified context.

00:34:34,320 --> 00:34:40,389
All the data that the rule gets, for example, the event would be "entity has been created."

00:34:40,389 --> 00:34:46,510
Obviously, there is an entity to be expected that we want to work upon in the system.

00:34:46,510 --> 00:34:51,909
The way we do this is, in the annotation we also have the context keyword, which allows

00:34:51,909 --> 00:34:58,909
us to specify the context that this action expects.

00:35:01,450 --> 00:35:06,750
In this case, the "entity delete" needs an entity which should be deleted.

00:35:06,750 --> 00:35:12,460
It's pretty easy. We can see down there, we can get the entity

00:35:12,460 --> 00:35:19,460
by this "get context" value, and the value just corresponds to the key up there.

00:35:24,020 --> 00:35:28,619
In this case, it's of type "entity," but this could be any type data.

00:35:28,619 --> 00:35:35,619
I could also get a parameter of type "float," for example, and then it would just be the same.

00:35:36,589 --> 00:35:39,839
That's the way we specify the context.

00:35:39,839 --> 00:35:44,099
For using the context, I have a more complex example here.

00:35:44,099 --> 00:35:51,099
There's an action that's called "DataListItemRemove." I will get a list of items, and I will also

00:35:53,829 --> 00:35:59,290
get just a single item. What this basically does, it's just iterating

00:35:59,290 --> 00:36:04,060
all the items in the list, checking for the items that match.

00:36:04,060 --> 00:36:08,440
It's removing them. In this case, we are not only getting the context,

00:36:08,440 --> 00:36:12,339
we are first getting the list of items, and the individual item, but we also

00:36:12,339 --> 00:36:20,899
have to update the context. The new list will now be kind of similar to

00:36:21,430 --> 00:36:31,750
if it's being treated as a reference. That's how the context here works.

00:36:33,210 --> 00:36:36,020
We have been working with the context that we receive.

00:36:36,020 --> 00:36:42,470
We have updated the context, but in some cases the actions also provide new values.

00:36:42,470 --> 00:36:49,470
In this case, "FetchEntityById" will get an entity type and the entity ID and then do

00:36:49,710 --> 00:36:56,710
its magic using the entity manager by loading the specific entity.

00:36:56,720 --> 00:37:01,760
What it will do in the end is set a provided value, so that all the subsequent actions

00:37:01,760 --> 00:37:10,020
in the Rules execution stream will be able to access it with this name.

00:37:13,490 --> 00:37:18,400
That was using context, so we can get a context, we can set a context, and we can set provided values.

00:37:18,400 --> 00:37:22,619
I guess this is really the basics that you

00:37:22,619 --> 00:37:25,750
really need when you work with the Rules system.

00:37:25,750 --> 00:37:35,690
There is also a way to use Rules programmatically. What you can see here is there is an expression

00:37:36,050 --> 00:37:41,640
manager, so everything in Rules is an expression. An action is an expression, and an event is

00:37:41,640 --> 00:37:43,730
an expression. A condition is an expression.

00:37:43,730 --> 00:37:47,349
The expression manager allows us to create a rule.

00:37:47,349 --> 00:37:54,349
In this case, we specify that there should be a context of type "string."

00:37:55,660 --> 00:38:00,520
Then to the created rule with the context, we can add a condition.

00:38:00,520 --> 00:38:07,520
What we do now is the context mapping. The text that's needed, it should be "select."

00:38:11,349 --> 00:38:18,349
That's then mapped to the test here. Finally, we can add an action to be executed

00:38:20,349 --> 00:38:27,349
and set the value test to be the test value, and then execute it.

00:38:29,000 --> 00:38:36,000
When you're not using the user interface... Has anybody used the Rules API without the interface?

00:38:37,140 --> 00:38:42,430
We did it quite some time because, I don't know,

00:38:42,430 --> 00:38:49,430
you have used the entity metadata wrapper, and it's just a bit easier from the command line.

00:38:50,780 --> 00:38:57,780
A bit more of an advanced example with context is that,

00:39:00,770 --> 00:39:07,770
for example, consider a condition that provides the provided text variable.

00:39:14,970 --> 00:39:21,920
Then there's an action which provides a concatenated variable.

00:39:21,920 --> 00:39:28,920
In the end, we sometimes need the context mapping because if the same action was executed twice,

00:39:30,160 --> 00:39:37,160
it would just override the previous provided parameter.

00:39:39,640 --> 00:39:46,310
If we specified a mapping here, we can say that the second action, the second Rules test string,

00:39:46,310 --> 00:39:51,570
instead of "concatenated," the variable should be named "concatenated2."

00:39:51,570 --> 00:39:58,210
That's basically what Rules does internally. Maybe you have noticed that when adding the

00:39:58,210 --> 00:40:04,220
"add variable" action several times, the variables will just get different names.

00:40:04,220 --> 00:40:20,180
Obviously, it makes sense to do so. About storing configuration, in Drupal 7 we

00:40:21,020 --> 00:40:25,260
have different systems how to export configuration data.

00:40:25,260 --> 00:40:30,810
We have the whole CTools exportables ecosystem and Features.

00:40:30,810 --> 00:40:37,810
Rules kind of had its own system. For readability, we decided to provide some

00:40:41,520 --> 00:40:46,970
kind of JSON export, so whenever you look at exported rules in Drupal 7, you will see

00:40:46,970 --> 00:40:53,970
that it's pretty well indented, and it's not just a serialized array or just a serialized dump.

00:40:55,220 --> 00:40:59,690
It's actually a prettified JSON output of the rule.

00:40:59,690 --> 00:41:04,210
That's all the functions that we have in Drupal 7.

00:41:04,210 --> 00:41:07,349
In Drupal 8, it's going to be much easier.

00:41:07,349 --> 00:41:14,349
We'll just rely on the YML files. We're still working out some details there,

00:41:15,319 --> 00:41:22,319
and we'll implement it. It will just be easier to operate.

00:41:23,760 --> 00:41:28,130
I guess that concludes the basics that you deal with.

00:41:28,130 --> 00:41:33,619
When working with Rules in Drupal 8, you will want to specify additional metadata to be

00:41:33,619 --> 00:41:38,410
exposed to rules. You will have to implement the actions,

00:41:38,410 --> 00:41:45,069
the events, and conditions, and you will obviously deal with the context API.

00:41:45,069 --> 00:41:50,990
Context API, by the way, is part of Drupal core, so it's also used in other systems.

00:41:50,990 --> 00:42:00,930
If you want to look a little bit deeper, you can also specify your own plugins.

00:42:01,500 --> 00:42:05,480
One example would be the Rules conditional module in Drupal 7.

00:42:05,480 --> 00:42:12,480
It provides a separate plugin for the "if and else" statement.

00:42:13,170 --> 00:42:18,510
That you're going to do just by extending the Rules expression plugins.

00:42:18,510 --> 00:42:28,750
There is the possibility to specify input evaluators and the possibility to specify

00:42:29,150 --> 00:42:34,680
data processors. An example for a data processor would be the

00:42:34,680 --> 00:42:41,680
numeric offset. I guess you have seen this when you have an

00:42:44,940 --> 00:42:51,940
action that requires a number, you can also use the data selector to select, for example,

00:42:52,740 --> 00:42:59,150
let's say the count of users or whatever you have stored there.

00:42:59,150 --> 00:43:06,150
The numeric offset would allow you then to just add a number as an offset to that.

00:43:07,349 --> 00:43:13,480
User interface. It's not there.

00:43:13,480 --> 00:43:15,380
Sorry. You don't need it.

00:43:15,380 --> 00:43:22,380
The APIs are so beautiful, why would you ever need a UI?

00:43:22,480 --> 00:43:29,480
We should do a console integration tomorrow. There have been some proposals.

00:43:30,900 --> 00:43:37,900
I think the Rules UI is kind of controversial. Some say it's too overwhelming.

00:43:38,880 --> 00:43:44,950
Some say it's too limited. I guess it's really hard to make a perfect

00:43:44,950 --> 00:43:48,970
user interface for such a generic tool that we have.

00:43:48,970 --> 00:43:55,970
There was a research project called Fluxkraft. It's really interesting.

00:43:56,690 --> 00:44:03,510
It's not just about the UI stuff. Fluxkraft is about creating the whole rep automation

00:44:03,510 --> 00:44:08,790
like IfThisThenThat.com, but based on Open Source technologies.

00:44:08,790 --> 00:44:15,790
The idea of Fluxkraft was to use Rules and all the user interface capabilities to create

00:44:16,589 --> 00:44:20,280
an "if this then that" based on Open Source technology.

00:44:20,280 --> 00:44:27,170
Part of that was creating UI proposals to make it simpler.

00:44:27,170 --> 00:44:34,170
The Rules user interface sometimes is considered to be just too complex.

00:44:35,000 --> 00:44:41,359
I have a ticket in the queue that lists all the referents, so if you are interested in

00:44:41,359 --> 00:44:47,849
studying those proposals, there's the Fluxkraft UI.

00:44:47,849 --> 00:44:53,470
There is a module that's been around for quite a while, but it never was really picked up,

00:44:53,470 --> 00:44:57,190
I guess. It's not that the concept is not so cool,

00:44:57,190 --> 00:45:01,170
but maybe the implementation was not great, but that already exists.

00:45:01,170 --> 00:45:03,790
Rules Transformers already exists in Drupal 7.

00:45:03,790 --> 00:45:09,500
It would be just another way of how you do the programming in a visual style that you

00:45:09,500 --> 00:45:14,800
have the individual actions. Then input parameters and output parameters

00:45:14,800 --> 00:45:20,880
can just be connected in a flowchart style. There is also the NoFlo project, which has

00:45:20,880 --> 00:45:27,880
got quite some momentum on Kickstarter. Fubhy is thinking about we should experiment

00:45:28,650 --> 00:45:33,730
with the JavaScript based front-end for the Rules configuration.

00:45:33,730 --> 00:45:40,730
There is a ticket, 2251267, if you're interested in jumping into this discussion.

00:45:42,470 --> 00:45:49,470
I think this is the time when we can incorporate feedback.

00:45:49,670 --> 00:45:56,670
The 1,000 hours that we have estimated will not include any fancy user interface.

00:45:57,040 --> 00:46:04,040
The plan for the initiative still is pretty much port the existing Rules interface to

00:46:04,230 --> 00:46:13,030
the new technologies of Drupal 8, but iterate in smaller pieces where we kind of see opportunities

00:46:13,390 --> 00:46:18,030
to streamline. At the moment, we do not plan to make a crazy re-write.

00:46:18,030 --> 00:46:21,369
As everything is plug-able, anyone can come

00:46:21,369 --> 00:46:28,369
and implement the Rules user interface at their taste.

00:46:31,010 --> 00:46:38,010
While the UI is not there, how can we do stuff with Rules?

00:46:38,670 --> 00:46:44,180
I mean, it's super boring. We implement our actions, we implement our conditions,

00:46:44,180 --> 00:46:48,310
but we don't know if they really work.

00:46:48,310 --> 00:46:55,310
As everything in Drupal core, we embrace automated testing quite extensively.

00:46:55,560 --> 00:47:02,560
We have some unit tests to test the individual components internally, but Rules is really

00:47:03,020 --> 00:47:09,220
more about integration because we kind of need the action manager, condition manager

00:47:09,220 --> 00:47:13,180
type data manger. It doesn't really make sense for us to mock

00:47:13,180 --> 00:47:22,540
all the systems. In a unit test, you really focus on that unit

00:47:22,750 --> 00:47:27,790
that you want to test, and if that unit has inter-dependencies in other systems, you usually

00:47:27,790 --> 00:47:34,790
create mocks for them. We are kind of in a hybrid situation where

00:47:35,000 --> 00:47:40,420
we don't bootstrap all the Drupal system for performance, and we don't really need it,

00:47:40,420 --> 00:47:46,170
but still we're writing more integration tests because it doesn't really make sense to...

00:47:46,170 --> 00:47:50,630
As you've seen before, the execute statements are usually just one or two lines of an action.

00:47:50,630 --> 00:47:54,740
It doesn't really make sense to just test this part.

00:47:54,740 --> 00:48:01,010
We feel that it makes more sense to test the integration here.

00:48:01,010 --> 00:48:08,010
Okay, let's look at an example. "DataListCountIs" is a condition that checks

00:48:10,440 --> 00:48:17,440
if the count is equal, less, or more. We have basically three important parameters.

00:48:20,000 --> 00:48:23,349
You have the list. You have the operator and the value.

00:48:23,349 --> 00:48:29,770
Based on the combination, it will just return if the data list count is greater, equal,

00:48:29,770 --> 00:48:34,829
or lower than. Pretty straightforward condition.

00:48:34,829 --> 00:48:37,349
The test. That's an abbreviation.

00:48:37,349 --> 00:48:44,349
We have lots of more test cases, but how it looks like, it extends to integration test base.

00:48:44,599 --> 00:48:51,599
Then what we do is we create a condition,

00:48:52,869 --> 00:48:58,760
and we set all the context values, like the list should be 1, 2, 3, 4, operator greater than 2.

00:48:58,760 --> 00:49:03,910
The list count of a list with 4 items should

00:49:03,910 --> 00:49:10,910
be greater than 2, so what we do is assert that this condition evaluates to "true."

00:49:10,910 --> 00:49:17,910
Easy. Vice versa, should not equal 0,

00:49:18,290 --> 00:49:25,290
the count of a list that has 3 items, so we are asserting "false" that it's equal.

00:49:27,140 --> 00:49:34,119
That's what the tests look like. Then we also have the "EntityIntegrationTestBase,"

00:49:34,119 --> 00:49:41,040
which brings in the whole entity system, so usually in those tests when you look at them,

00:49:41,040 --> 00:49:45,089
you would have to do a lot of bootstrapping. You have to mock all the systems, get all

00:49:45,089 --> 00:49:49,210
the managers ready for you. This is why we have some test bases that allow

00:49:49,210 --> 00:49:56,210
you to do so. Let's look at another condition, "entity_is_of_type,"

00:49:56,270 --> 00:50:03,270
so we get the entity, we get the type string. Then we just return if the entity type matches.

00:50:04,720 --> 00:50:11,720
When we look at the test for this, this took me a little longer to figure out how it works.

00:50:11,770 --> 00:50:22,770
What we do is, we create a mock for the entity. We don't do an "entity create" or we don't instantiate

00:50:23,089 --> 00:50:28,930
a real object, but we get the mock that implements the entity interface.

00:50:28,930 --> 00:50:35,930
Then we set expectations. It's like, you create something that's not there,

00:50:40,670 --> 00:50:44,500
but you specify how it should look because that's the only thing that you really

00:50:44,500 --> 00:50:50,520
care about. What I care about here is that "GetEntityTypeId"

00:50:50,520 --> 00:50:57,359
should be called twice later on. That kind of struck me because right now I

00:50:57,359 --> 00:51:04,359
already have to think about what's coming down there, and that's not the way my programming

00:51:04,480 --> 00:51:09,250
mind works so far. Anyways, let's just assume this is how we

00:51:09,250 --> 00:51:13,880
do it. We expect "GetEntityType" to be called twice,

00:51:13,880 --> 00:51:20,880
and it will always return "node." We now have a fake object that two times on

00:51:21,589 --> 00:51:27,970
"GetEntityType" will return "node," and what are we going to do with it?

00:51:27,970 --> 00:51:37,150
Down here, we have the condition and we set the context value entity to be the mocked

00:51:37,640 --> 00:51:42,170
entity, and we set the context value of the condition to be "node."

00:51:42,170 --> 00:51:47,550
Then we check. This condition should evaluate to "true" because

00:51:47,550 --> 00:51:53,150
we have a mock object that returns "node." We are checking for nodes, so this should

00:51:53,150 --> 00:51:58,970
be true. Then in a second test case, we set the context

00:51:58,970 --> 00:52:04,089
value to "taxonomy_term," and now we assert to "false."

00:52:04,089 --> 00:52:11,089
All those two together match to exactly two. That's it.

00:52:12,280 --> 00:52:17,609
All right. Just a quick mention.

00:52:17,609 --> 00:52:22,250
If you dive into the Rules APIs, you will deal with the RulesState that keeps track

00:52:22,250 --> 00:52:28,609
of all the variables that allows Rules to apply the data selection.

00:52:28,609 --> 00:52:35,430
Based on the current execution state, which obviously changes from every action being

00:52:35,430 --> 00:52:39,480
executed or every condition being executed, the state kind of changes.

00:52:39,480 --> 00:52:45,030
If a condition has been executed, Rules usually knows a bit more about the variables that

00:52:45,030 --> 00:52:48,099
are available. This is, for example, the reason why often

00:52:48,099 --> 00:52:55,099
you have to put an "entities of type" or "entities of bundle" condition in the beginning of your

00:52:55,099 --> 00:53:02,099
rule so that you later can access properties. The system defers automatically.

00:53:03,359 --> 00:53:08,079
Based on conditions, it knows more about the entity.

00:53:08,079 --> 00:53:11,599
That's all handled in the RulesState. Also, auto-saving is a feature that Rules has.

00:53:11,599 --> 00:53:15,960
For performance reasons, it doesn't do a save

00:53:15,960 --> 00:53:21,849
on every single action, but it does it in a more intelligent way.

00:53:21,849 --> 00:53:28,660
Traits. Who has used traits?

00:53:28,660 --> 00:53:32,700
Anyone has used traits? Yeah.

00:53:32,700 --> 00:53:34,869
Okay. We use them.

00:53:34,869 --> 00:53:40,410
What are traits? Traits kind of solved the problem of multiple inheritance.

00:53:40,410 --> 00:53:46,839
We are not able in PHP to inherit from two parents.

00:53:46,839 --> 00:53:53,839
If I'm a car, I cannot be both a vehicle and

00:53:54,319 --> 00:54:00,589
an object if they are not parents of each other.

00:54:00,589 --> 00:54:07,589
There's a quote that says traits are basically copy and paste on the compiler level or on

00:54:08,190 --> 00:54:15,190
the... Is it really a compiler? Correct me if I'm wrong.

00:54:15,400 --> 00:54:20,720
There's one trait that, when you deal with Drupal 8 code, you will quickly find it.

00:54:20,720 --> 00:54:26,930
It's the "StringTranslationTrait." All it provides us is the "t" function.

00:54:26,930 --> 00:54:33,900
As in Drupal 8, we do not want to use globals. In Drupal 7, the "t" function is just a function

00:54:33,900 --> 00:54:40,900
that you call globally, but in Drupal 8 we usually rely on services to provide us the functionality.

00:54:42,299 --> 00:54:49,299
Bootstrapping those services just takes a bit of instantiation with all the dependency injection that

00:54:49,490 --> 00:54:54,869
I will not show today, but you will definitely find it out in other sessions.

00:54:54,869 --> 00:55:00,549
Basically, the "StringTranslationTrait" is something that can be used in as many classes

00:55:00,549 --> 00:55:06,400
as we want to. String translation will be a requisite that

00:55:06,400 --> 00:55:11,950
we want to, for example, have in MyClass. I want to use string translation, and then

00:55:11,950 --> 00:55:20,470
in any function I can just call this the method "t" if it was declared in MyClass.

00:55:20,740 --> 00:55:26,599
A really powerful concept. You have to use it wisely.

00:55:26,599 --> 00:55:32,119
You can also rename classes, so if you have two traits that conflict with each other with

00:55:32,119 --> 00:55:39,119
the same method names, you can use Traits a bit more in an advanced way, but maybe it

00:55:40,220 --> 00:55:45,839
will also freak your developers out when they try to debug stuff.

00:55:45,839 --> 00:55:52,839
We use Traits for the context, so there's a "RulesContextTrait."

00:55:53,720 --> 00:55:59,549
There's a "ContextAwarePluginBase" in Drupal core, but we need a bit more to be able to

00:55:59,549 --> 00:56:04,290
deal with the provided values, for example, that are a part of the core's context system.

00:56:04,290 --> 00:56:08,339
We use it both in the ActionBase and in the ConditionBase.

00:56:08,339 --> 00:56:15,140
That's a use case where we kind of need Traits because we want to inject functionality in

00:56:15,140 --> 00:56:22,140
a horizontal way into many classes without them being crazily inherited from each other.

00:56:28,859 --> 00:56:35,859
Just a reminder: If you want a part of this, if that sounds fun, contribution can be many things.

00:56:36,829 --> 00:56:42,380
You can just give us money.

00:56:42,380 --> 00:56:48,230
We don't waste that money. We really use it for solving hard problems,

00:56:48,230 --> 00:56:53,690
and we try to give back as much as possible to the whole community, so I guess if you

00:56:53,690 --> 00:56:59,660
know anybody interested in donating to Rules. I wouldn't encourage yourself being for it,

00:56:59,660 --> 00:57:05,819
because you're already part of this community. We should talk to the people that have much

00:57:05,819 --> 00:57:11,490
money to get this done. Yeah, you can just talk about it.

00:57:11,490 --> 00:57:15,880
You can help us with graphic design. You can set up a sprint.

00:57:15,880 --> 00:57:22,880
We are happy for any help regarding documentation, bug reports, and, and, and...

00:57:22,950 --> 00:57:29,950
There are a lot of opportunities to help us out, so currently we are porting actions and conditions,

00:57:30,950 --> 00:57:37,950
and you can find more information here or just directly at the sprints tomorrow.

00:57:39,160 --> 00:57:43,240
That kind of concludes my session. I'm happy to take your questions.

00:57:43,240 --> 00:57:43,680

YouTube URL: https://www.youtube.com/watch?v=P3Jq7NUWv8I


