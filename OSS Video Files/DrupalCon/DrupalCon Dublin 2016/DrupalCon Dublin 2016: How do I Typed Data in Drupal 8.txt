Title: DrupalCon Dublin 2016: How do I Typed Data in Drupal 8
Publication date: 2016-09-27
Playlist: DrupalCon Dublin 2016
Description: 
	I was excited by the improvements and shininess in Drupal 8, but then I found the enigmatic Typed Data API lurking beneath the surface of high-level functionality including the Field and Entity APIs. The Typed Data Manager remains one of the more elusive and esoteric services in Drupal 8, and stands on its own as powerful tool to model complex data types without the storage concern of the Entity system.

Developers can leverage the Typed Data API in Drupal 8 components such as Serialization and Web Services.

In this session I will share how I leverage Typed Data covering the following topics:

What was the equivalent in Drupal 6 and 7?
What is a data type and data definition?
What are the possible uses, advantages and disadvantages of Typed Data?
How do I unit test the Typed Data Manager monster?
The session is designed for experienced developers who are interested in data modeling and integrating with external services. Some familiarity with the Drupal 8 Plugin, Form, PHPUnit or Render API is assumed.
Captions: 
	00:00:00,030 --> 00:00:06,600
all right good afternoon everyone so the

00:00:04,770 --> 00:00:09,660
title of this talk is how do I type data

00:00:06,600 --> 00:00:11,550
there's no typo in the title this talk

00:00:09,660 --> 00:00:13,799
is not about data entry or typing

00:00:11,550 --> 00:00:17,039
layouts no matter how fascinating those

00:00:13,799 --> 00:00:18,840
are I love Dvorak myself but today we

00:00:17,039 --> 00:00:21,900
will talk about the elusive type data

00:00:18,840 --> 00:00:24,210
API in Drupal 8 so in the last couple of

00:00:21,900 --> 00:00:27,449
years I've explored this once

00:00:24,210 --> 00:00:30,449
undocumented API a couple times and a

00:00:27,449 --> 00:00:33,390
few similar talks at mid camp in Chicago

00:00:30,449 --> 00:00:36,480
Drupal Camp Atlanta and Drupal camp Ohio

00:00:33,390 --> 00:00:40,320
and each time I just go a bit deeper

00:00:36,480 --> 00:00:41,760
down the rabbit hole so to speak so one

00:00:40,320 --> 00:00:44,460
of the titles of the talk was down the

00:00:41,760 --> 00:00:46,710
rabbit hole with type data before I

00:00:44,460 --> 00:00:48,980
begin a little bit about myself my name

00:00:46,710 --> 00:00:50,850
is Matthew Radcliffe I work for a small

00:00:48,980 --> 00:00:52,500
software and web development company

00:00:50,850 --> 00:00:55,170
called Co SATA were based out of

00:00:52,500 --> 00:00:58,949
Columbus and Athens Ohio in the United

00:00:55,170 --> 00:01:00,840
States we do we make a visual

00:00:58,949 --> 00:01:03,059
programming software called brew it's

00:01:00,840 --> 00:01:05,790
not related to Drupal but it's for

00:01:03,059 --> 00:01:08,970
visual artists and to create dynamic art

00:01:05,790 --> 00:01:11,340
installations and applications but on

00:01:08,970 --> 00:01:12,150
the website of things we use Drupal so

00:01:11,340 --> 00:01:15,030
I've been involved in the community

00:01:12,150 --> 00:01:17,100
since the 2007 roughly making

00:01:15,030 --> 00:01:19,740
contributed modules I like hacking on

00:01:17,100 --> 00:01:21,330
things I like integrating with api's and

00:01:19,740 --> 00:01:24,590
figuring out the unknown and I have a

00:01:21,330 --> 00:01:28,590
lot of opinions but enough about myself

00:01:24,590 --> 00:01:30,090
so describe to talk just a summary I'm

00:01:28,590 --> 00:01:33,060
going to go over the concept of type

00:01:30,090 --> 00:01:36,150
data and what the use cases you might

00:01:33,060 --> 00:01:38,520
find you use it for and then a little

00:01:36,150 --> 00:01:41,340
bit about why you would choose type data

00:01:38,520 --> 00:01:43,649
over say entity API and Filan we'll get

00:01:41,340 --> 00:01:46,500
into working with data definitions and

00:01:43,649 --> 00:01:48,960
data types and how you go about using a

00:01:46,500 --> 00:01:52,710
data type instantiate it through

00:01:48,960 --> 00:01:55,170
services and into some complex examples

00:01:52,710 --> 00:02:00,110
and finally we'll look at unit testing

00:01:55,170 --> 00:02:02,549
type data so to begin with we have and

00:02:00,110 --> 00:02:04,950
what in my own words I described the

00:02:02,549 --> 00:02:06,930
tape type data API as a meta for

00:02:04,950 --> 00:02:09,330
primitive and composite data types in

00:02:06,930 --> 00:02:11,849
Drupal that are not otherwise defined

00:02:09,330 --> 00:02:13,390
and provide a strongly typed interface

00:02:11,849 --> 00:02:15,940
that can be passed into

00:02:13,390 --> 00:02:19,959
various subsystems so if we think back

00:02:15,940 --> 00:02:21,640
to programming class in college you

00:02:19,959 --> 00:02:23,980
think about what a primitive datatype is

00:02:21,640 --> 00:02:26,140
that's a basic or built-in type of a

00:02:23,980 --> 00:02:28,690
programming language composite data

00:02:26,140 --> 00:02:30,580
types or any data type that are made up

00:02:28,690 --> 00:02:32,260
a primitive or rather composite data

00:02:30,580 --> 00:02:34,570
type so well you know structs and

00:02:32,260 --> 00:02:38,170
classes but again we're I'm talking

00:02:34,570 --> 00:02:40,840
about a meta around data types so type

00:02:38,170 --> 00:02:43,930
data API is the low level API describe

00:02:40,840 --> 00:02:46,000
data within Drupal and not necessarily

00:02:43,930 --> 00:02:46,540
about instantiating and creating new PHP

00:02:46,000 --> 00:02:49,540
types

00:02:46,540 --> 00:02:57,250
it's a meta language around describing

00:02:49,540 --> 00:02:59,320
data and about any of you but I find

00:02:57,250 --> 00:03:02,560
myself integrating Drupal with external

00:02:59,320 --> 00:03:04,630
web services API is all the time I mean

00:03:02,560 --> 00:03:07,810
is anybody integrate Drupal with other

00:03:04,630 --> 00:03:13,060
with third-party api's right a lot of

00:03:07,810 --> 00:03:14,950
people and using those api's they're

00:03:13,060 --> 00:03:17,769
often described around kind of data and

00:03:14,950 --> 00:03:21,000
it's not Drupal data for instance in the

00:03:17,769 --> 00:03:25,870
education world we have the IMS global

00:03:21,000 --> 00:03:28,660
specifications LTI lis we you know I

00:03:25,870 --> 00:03:31,060
work with the accounting software 0 to

00:03:28,660 --> 00:03:33,459
integrate with that Salesforce YouTube

00:03:31,060 --> 00:03:35,320
in all sorts of api's that describe data

00:03:33,459 --> 00:03:37,390
in there our own special snowflake way

00:03:35,320 --> 00:03:42,040
or maybe it's Drupal that's a snowflake

00:03:37,390 --> 00:03:45,010
but in any case so I began just kind of

00:03:42,040 --> 00:03:46,840
a history lesson here I one of the

00:03:45,010 --> 00:03:50,110
examples I gave is how I integrate with

00:03:46,840 --> 00:03:52,600
the Xero accounting platform so I'm just

00:03:50,110 --> 00:03:54,130
gonna describe that a little bit and and

00:03:52,600 --> 00:03:57,940
so you understand where I'm coming from

00:03:54,130 --> 00:04:01,209
in this use case so 0 provides a restful

00:03:57,940 --> 00:04:04,120
api and I created a module back several

00:04:01,209 --> 00:04:06,220
years ago to integrate with the Xero API

00:04:04,120 --> 00:04:07,570
so we can easily just post invoices with

00:04:06,220 --> 00:04:09,670
a couple clicks and go back to coding

00:04:07,570 --> 00:04:12,269
because we're not accountants you just

00:04:09,670 --> 00:04:14,230
want to get our invoices done with right

00:04:12,269 --> 00:04:17,260
integrating with e-commerce systems

00:04:14,230 --> 00:04:19,359
creating bank transactions all you need

00:04:17,260 --> 00:04:20,919
to know there about zeros you know you

00:04:19,359 --> 00:04:23,020
have accounts receivable and bank

00:04:20,919 --> 00:04:24,530
reconciliations so a bank transaction

00:04:23,020 --> 00:04:27,740
kind of

00:04:24,530 --> 00:04:30,020
the two together yeah and this data

00:04:27,740 --> 00:04:31,640
that's stored in a row it's off-site and

00:04:30,020 --> 00:04:34,610
I just want I'm not gonna chill zero

00:04:31,640 --> 00:04:37,250
it's whatever it is and you don't really

00:04:34,610 --> 00:04:39,410
need to know accounting but in this

00:04:37,250 --> 00:04:43,970
example and I'm just describing the

00:04:39,410 --> 00:04:44,930
types of data so back in in in Drupal 6

00:04:43,970 --> 00:04:47,900
and Drupal 7

00:04:44,930 --> 00:04:51,290
I created this module and I'm using curl

00:04:47,900 --> 00:04:53,900
and HTTP Drupal HTTP request to make a

00:04:51,290 --> 00:04:57,230
walk sign request I do a little form

00:04:53,900 --> 00:04:59,330
validation and then I finally model the

00:04:57,230 --> 00:05:02,390
data as associative arrays because if

00:04:59,330 --> 00:05:04,070
Drupal we love our associative arrays so

00:05:02,390 --> 00:05:07,640
it's not strongly typed this was before

00:05:04,070 --> 00:05:10,580
entities and I also had to use some

00:05:07,640 --> 00:05:12,919
external PHP libraries to to do the curl

00:05:10,580 --> 00:05:19,850
stuff and things I don't really want to

00:05:12,919 --> 00:05:22,100
maintain like this let's move on so it's

00:05:19,850 --> 00:05:25,070
really really when I'm looking at

00:05:22,100 --> 00:05:28,430
implementing Drupal 8 and implementing

00:05:25,070 --> 00:05:30,590
my module in Drupal 8 the goal was again

00:05:28,430 --> 00:05:32,930
it's to make HTTP requests to integrate

00:05:30,590 --> 00:05:36,440
with external systems and what I want

00:05:32,930 --> 00:05:38,090
and I need is to describe 0 types into

00:05:36,440 --> 00:05:41,000
something that drivel understands and

00:05:38,090 --> 00:05:44,000
vice-versa so I have both primitive and

00:05:41,000 --> 00:05:45,470
comply complex data types and they're

00:05:44,000 --> 00:05:47,540
and these need to be flexible enough to

00:05:45,470 --> 00:05:50,120
handle the custom use case of not

00:05:47,540 --> 00:05:53,540
relying on storage sorry yeah I don't

00:05:50,120 --> 00:05:56,810
like storing things in two places it's

00:05:53,540 --> 00:06:00,800
just my opinion so that was one of my

00:05:56,810 --> 00:06:02,270
little criteria so as I began looking

00:06:00,800 --> 00:06:05,240
and triple-eight we have these awesome

00:06:02,270 --> 00:06:07,669
things like does Alando a subscriber

00:06:05,240 --> 00:06:11,270
plugin we have composer to bring in all

00:06:07,669 --> 00:06:12,410
all these libraries but again now you

00:06:11,270 --> 00:06:13,640
don't really want to go into guzzle

00:06:12,410 --> 00:06:15,650
because there's another session and

00:06:13,640 --> 00:06:17,660
about and composer because there's

00:06:15,650 --> 00:06:20,780
another session about composer on

00:06:17,660 --> 00:06:23,360
Thursday but to make a long story short

00:06:20,780 --> 00:06:25,640
I found a nice little symphony bundle I

00:06:23,360 --> 00:06:30,200
was able to pull that in so I could I

00:06:25,640 --> 00:06:31,820
could handle pretty much the guzzle

00:06:30,200 --> 00:06:34,760
stuff on its own I can focus on other

00:06:31,820 --> 00:06:37,490
things we also got the serialization

00:06:34,760 --> 00:06:40,490
module which ties into type data

00:06:37,490 --> 00:06:42,199
I'll explain that a little bit and that

00:06:40,490 --> 00:06:46,430
comes again a little history lesson back

00:06:42,199 --> 00:06:48,139
in 2012 in Munich I was around a birds

00:06:46,430 --> 00:06:51,289
of a feather session and around a table

00:06:48,139 --> 00:06:53,060
in the coder lounge and I was surrounded

00:06:51,289 --> 00:06:56,150
by all these fascinating people who are

00:06:53,060 --> 00:06:58,669
talking about the HDTV specification and

00:06:56,150 --> 00:07:00,229
RESTful API and the end result of that

00:06:58,669 --> 00:07:02,509
was we brought in the serials they

00:07:00,229 --> 00:07:04,340
sterilized er component in Dec Drupal

00:07:02,509 --> 00:07:09,680
core and we created a serialization

00:07:04,340 --> 00:07:11,840
module so I got serializer

00:07:09,680 --> 00:07:15,410
I've got guzzle that has pretty much

00:07:11,840 --> 00:07:17,900
solved most of my module but the one

00:07:15,410 --> 00:07:19,220
thing that's missing in forces is a way

00:07:17,900 --> 00:07:21,289
of describing data and that's where I

00:07:19,220 --> 00:07:22,880
found type data I mean it makes sense

00:07:21,289 --> 00:07:24,530
something that's called type data

00:07:22,880 --> 00:07:28,280
describing data type so I was like oh

00:07:24,530 --> 00:07:29,780
okay sounds like what I need right so

00:07:28,280 --> 00:07:33,139
looking at the types of data I'm

00:07:29,780 --> 00:07:37,099
integrating in my use case I've got

00:07:33,139 --> 00:07:39,199
simple data types like amounts or tax

00:07:37,099 --> 00:07:41,419
amounts they're integers and floats

00:07:39,199 --> 00:07:43,520
I've got relatively simple but

00:07:41,419 --> 00:07:45,680
structured types such as accounts these

00:07:43,520 --> 00:07:48,500
are bank accounts or sales accounts and

00:07:45,680 --> 00:07:51,199
I've got a relatively complex type such

00:07:48,500 --> 00:07:53,210
as an invoice which include other data

00:07:51,199 --> 00:07:54,320
types like accounts and contacts and a

00:07:53,210 --> 00:07:57,080
list of line items

00:07:54,320 --> 00:08:00,110
amongst other things so again I'm

00:07:57,080 --> 00:08:02,090
speaking of line items my night UM's

00:08:00,110 --> 00:08:04,550
aren't themselves kind of on their own

00:08:02,090 --> 00:08:09,050
they're inclusive they're only included

00:08:04,550 --> 00:08:11,960
in in other data types so I begin to

00:08:09,050 --> 00:08:14,719
evaluate type data and say okay why type

00:08:11,960 --> 00:08:17,710
data it looks like a flexible way of

00:08:14,719 --> 00:08:22,250
defining and describing my data types

00:08:17,710 --> 00:08:24,919
from outside of Drupal the hike data is

00:08:22,250 --> 00:08:26,810
injectable all right I can use it in

00:08:24,919 --> 00:08:29,000
forms and routes route controllers

00:08:26,810 --> 00:08:33,250
normalize errs so it's going to fit in

00:08:29,000 --> 00:08:36,050
with these other tools that I found and

00:08:33,250 --> 00:08:37,940
in my opinion I think that that type

00:08:36,050 --> 00:08:43,969
data will work well with other core and

00:08:37,940 --> 00:08:47,390
controls such as rules on the other hand

00:08:43,969 --> 00:08:50,200
type data is kind of is a low-level API

00:08:47,390 --> 00:08:53,070
so if you're used to the entity API

00:08:50,200 --> 00:08:56,769
and all the cool things you get like

00:08:53,070 --> 00:08:59,709
access handlers form handlers caching

00:08:56,769 --> 00:09:01,690
you know type data is low enough there's

00:08:59,709 --> 00:09:06,160
a lower level API where you don't get

00:09:01,690 --> 00:09:08,800
those those things so you have to kind

00:09:06,160 --> 00:09:12,120
of weigh whether you're describing data

00:09:08,800 --> 00:09:14,889
that that really needs all those things

00:09:12,120 --> 00:09:19,329
or you're describing data that that

00:09:14,889 --> 00:09:22,089
that's kind of on its own in my opinion

00:09:19,329 --> 00:09:23,709
in this case I think that anything a P I

00:09:22,089 --> 00:09:27,519
had too much baggage so that's why I

00:09:23,709 --> 00:09:29,380
looked at implementing type data again

00:09:27,519 --> 00:09:33,579
you know you can override and ignore

00:09:29,380 --> 00:09:35,500
things but will other controls behave

00:09:33,579 --> 00:09:37,300
the same way if I if I make and I

00:09:35,500 --> 00:09:42,040
implement entities and then and I'm not

00:09:37,300 --> 00:09:44,050
using them so I just wanted them to have

00:09:42,040 --> 00:09:46,980
a lower level representation and I think

00:09:44,050 --> 00:09:48,339
that's a better fit for external api's

00:09:46,980 --> 00:09:51,880
all right

00:09:48,339 --> 00:09:56,680
that's my use case so a little bit about

00:09:51,880 --> 00:09:59,290
type data and it really comes down to

00:09:56,680 --> 00:10:03,699
this one class and that is the map class

00:09:59,290 --> 00:10:06,390
and that is the one complex data type in

00:10:03,699 --> 00:10:10,649
Drupal that does not describe an entity

00:10:06,390 --> 00:10:13,779
so maps are basically associative arrays

00:10:10,649 --> 00:10:16,720
okay maybe that's maybe that's a little

00:10:13,779 --> 00:10:19,420
exaggeration so so a map you know like

00:10:16,720 --> 00:10:21,089
kind of like the hash map in the hash in

00:10:19,420 --> 00:10:24,160
c-sharp

00:10:21,089 --> 00:10:27,040
it's an iterator so you can you can you

00:10:24,160 --> 00:10:28,449
innovation on it you have definite you

00:10:27,040 --> 00:10:30,579
know you can define properties so you

00:10:28,449 --> 00:10:33,600
can have constraints so it's a little

00:10:30,579 --> 00:10:38,890
bit more than an associative array and

00:10:33,600 --> 00:10:41,920
so when I talk about Maps usually every

00:10:38,890 --> 00:10:43,420
complex data type I have is extending

00:10:41,920 --> 00:10:47,139
map in a certain way just because it's

00:10:43,420 --> 00:10:49,750
so flexible so how do i define a data

00:10:47,139 --> 00:10:53,050
type it's a plugin like most things in

00:10:49,750 --> 00:10:55,720
drupal this plug-in extends that the

00:10:53,050 --> 00:10:58,980
type data class or the map class is

00:10:55,720 --> 00:11:02,779
everybody not familiar with a plug-in is

00:10:58,980 --> 00:11:07,200
good they're all the things

00:11:02,779 --> 00:11:09,390
you know the data the data type plug-in

00:11:07,200 --> 00:11:12,180
has a constructor that usually inherit

00:11:09,390 --> 00:11:14,430
so I'm a lot of my classes are pretty

00:11:12,180 --> 00:11:15,810
much empty so it's pretty much

00:11:14,430 --> 00:11:18,720
implementing a class and I can and

00:11:15,810 --> 00:11:21,510
that's why I'm using map although you

00:11:18,720 --> 00:11:22,860
might want to add some useful methods so

00:11:21,510 --> 00:11:27,540
what is the what does the plug-in looked

00:11:22,860 --> 00:11:32,000
like we've got our annotation type right

00:11:27,540 --> 00:11:32,000
data type we've got our plugin ID

00:11:32,450 --> 00:11:36,690
translation for a label and then I'm

00:11:35,250 --> 00:11:39,210
gonna skip down here to lift data type

00:11:36,690 --> 00:11:41,850
all this data type isn't necessary for

00:11:39,210 --> 00:11:44,850
all type data but it can be particularly

00:11:41,850 --> 00:11:47,490
useful if you're implementing a a web

00:11:44,850 --> 00:11:52,529
service and you need to target a

00:11:47,490 --> 00:11:53,779
specific like to target specific

00:11:52,529 --> 00:11:56,070
normalizer

00:11:53,779 --> 00:11:58,800
and then finally we have something

00:11:56,070 --> 00:12:01,410
called a data definition class or

00:11:58,800 --> 00:12:04,620
definition class so what is a data

00:12:01,410 --> 00:12:06,180
definition and that's where we are

00:12:04,620 --> 00:12:08,940
describing properties this is very

00:12:06,180 --> 00:12:10,770
you're probably kind of thinking it's

00:12:08,940 --> 00:12:13,230
similar and of course it is similar

00:12:10,770 --> 00:12:15,720
because it's the lower level API it's

00:12:13,230 --> 00:12:17,370
similar to your base field definitions

00:12:15,720 --> 00:12:19,560
that you're using in your in entity API

00:12:17,370 --> 00:12:20,880
but it's again it's much lower level

00:12:19,560 --> 00:12:24,890
you're you know you're only defining

00:12:20,880 --> 00:12:28,080
properties you know definitions offer

00:12:24,890 --> 00:12:29,279
constraints such as regex choice you

00:12:28,080 --> 00:12:32,790
know all the symphonie constraints that

00:12:29,279 --> 00:12:34,560
we're now getting used to you probably

00:12:32,790 --> 00:12:36,480
can't implement some of the Drupal

00:12:34,560 --> 00:12:37,940
constraints it allowed value because

00:12:36,480 --> 00:12:41,400
it's got some implications about

00:12:37,940 --> 00:12:44,970
entities and you can you know assign

00:12:41,400 --> 00:12:47,700
labels and descriptions and each each

00:12:44,970 --> 00:12:50,459
data definition describes another data

00:12:47,700 --> 00:12:54,360
type so again the difference between a

00:12:50,459 --> 00:12:55,910
data type and a data definition is sort

00:12:54,360 --> 00:12:59,040
of similar to the fact that the

00:12:55,910 --> 00:13:02,070
definition describes properties of a

00:12:59,040 --> 00:13:04,890
data type and the and the data type is

00:13:02,070 --> 00:13:10,650
the logical means of representing the

00:13:04,890 --> 00:13:14,490
data so an example of a definition let's

00:13:10,650 --> 00:13:15,570
say I'm implementing a color it has

00:13:14,490 --> 00:13:22,260
three properties

00:13:15,570 --> 00:13:24,390
red green and blue and so I'm gonna

00:13:22,260 --> 00:13:26,430
describe this as the typed example color

00:13:24,390 --> 00:13:31,140
it's an it's an example module of mine

00:13:26,430 --> 00:13:32,850
so we have the each each day a

00:13:31,140 --> 00:13:35,640
definition crate you know we use the

00:13:32,850 --> 00:13:38,820
create method static method and we

00:13:35,640 --> 00:13:41,760
supply a type which is the the plug-in

00:13:38,820 --> 00:13:43,500
ID the data type plug-in ID so again

00:13:41,760 --> 00:13:47,210
this is very similar to bass field

00:13:43,500 --> 00:13:50,850
definition and the create method on that

00:13:47,210 --> 00:13:54,000
we're pretty much just implemented get

00:13:50,850 --> 00:13:56,580
property definitions method in your in

00:13:54,000 --> 00:13:59,160
your definition class and it's probably

00:13:56,580 --> 00:14:02,700
going to extend complex data definition

00:13:59,160 --> 00:14:04,890
base I'm not sure if anyone else is

00:14:02,700 --> 00:14:06,630
confused but I see get property

00:14:04,890 --> 00:14:08,130
definitions data definitions property

00:14:06,630 --> 00:14:09,990
definitions data definitions would turn

00:14:08,130 --> 00:14:11,970
this property definitions right it's

00:14:09,990 --> 00:14:15,000
like I'm at Disneyland and I'm going

00:14:11,970 --> 00:14:18,300
round around at the teacup ride and type

00:14:15,000 --> 00:14:21,990
data it can be confusing because some of

00:14:18,300 --> 00:14:24,480
the terms are similar and it is also

00:14:21,990 --> 00:14:26,490
recursive so you have to when you're

00:14:24,480 --> 00:14:28,080
going through it in your debugger you're

00:14:26,490 --> 00:14:33,560
you're constantly going back and forth

00:14:28,080 --> 00:14:37,920
through type data manager in another

00:14:33,560 --> 00:14:41,340
example here I'm describing a more

00:14:37,920 --> 00:14:43,140
complex type so in this this this data

00:14:41,340 --> 00:14:48,750
definition is you describe a type that

00:14:43,140 --> 00:14:50,820
uses the previous definition and set it

00:14:48,750 --> 00:14:52,530
to the primary color again this is an

00:14:50,820 --> 00:14:55,140
example of Sam describing a set of

00:14:52,530 --> 00:14:56,250
colors and you know when you describe a

00:14:55,140 --> 00:14:57,630
set of colors you have your primary

00:14:56,250 --> 00:14:59,820
color and your secondary colors you know

00:14:57,630 --> 00:15:01,560
your color wheel and you never thought

00:14:59,820 --> 00:15:03,480
you'd hear color theory being mentioned

00:15:01,560 --> 00:15:09,090
in a coding and development session did

00:15:03,480 --> 00:15:10,980
you well so we get down down here to the

00:15:09,090 --> 00:15:13,560
the list state definition which is a

00:15:10,980 --> 00:15:16,980
little different so what a list of

00:15:13,560 --> 00:15:20,820
definition does is allow us to describe

00:15:16,980 --> 00:15:22,830
a property on our on our data that

00:15:20,820 --> 00:15:26,430
that's an array and it basically an

00:15:22,830 --> 00:15:28,800
index act as an index array of a typed

00:15:26,430 --> 00:15:29,340
index array so we use listing the

00:15:28,800 --> 00:15:32,640
definition

00:15:29,340 --> 00:15:35,670
the class but the the actual data type

00:15:32,640 --> 00:15:42,450
class is going to be you know the item

00:15:35,670 --> 00:15:46,140
class of that that data type again just

00:15:42,450 --> 00:15:49,740
to highlight that so let's apply what we

00:15:46,140 --> 00:15:52,220
now know to a different example so let's

00:15:49,740 --> 00:15:55,230
say we are implementing a Spotify API

00:15:52,220 --> 00:15:58,740
just as an example Spotify as you know

00:15:55,230 --> 00:16:02,270
an album model which has a list of

00:15:58,740 --> 00:16:04,950
tracks a list of artists a type a name

00:16:02,270 --> 00:16:08,339
so how would we go about describing that

00:16:04,950 --> 00:16:10,080
in driveling and a definition so we

00:16:08,339 --> 00:16:13,290
would have an album definition there's a

00:16:10,080 --> 00:16:15,690
data definition class it would describe

00:16:13,290 --> 00:16:18,029
our get property definitions would

00:16:15,690 --> 00:16:20,910
describe a list of properties so we have

00:16:18,029 --> 00:16:23,850
name and type and artists and each

00:16:20,910 --> 00:16:28,410
property is instantiated with a data

00:16:23,850 --> 00:16:30,600
definition of a certain type all right

00:16:28,410 --> 00:16:33,150
I'm starting to make sense to visualize

00:16:30,600 --> 00:16:40,920
it in this way you can map out your your

00:16:33,150 --> 00:16:43,050
data types all right so that's that's

00:16:40,920 --> 00:16:44,850
that's about it for how to create data

00:16:43,050 --> 00:16:50,300
types but how do you actually use type

00:16:44,850 --> 00:16:52,680
data right and so it's summary of that

00:16:50,300 --> 00:16:54,630
there's a couple ways to start

00:16:52,680 --> 00:16:56,700
instantiated a type so you can use the

00:16:54,630 --> 00:17:00,060
type data manager so we have a plugin

00:16:56,700 --> 00:17:06,179
manager to create data types and and

00:17:00,060 --> 00:17:07,890
data based out of default values one of

00:17:06,179 --> 00:17:10,260
the biggest uses of type data is through

00:17:07,890 --> 00:17:13,829
the normalization service and how and

00:17:10,260 --> 00:17:16,790
I'm using this myself to transform the

00:17:13,829 --> 00:17:19,230
z-row what the data I get from the API

00:17:16,790 --> 00:17:22,410
into something truthful understands and

00:17:19,230 --> 00:17:24,510
then through that you can use serializer

00:17:22,410 --> 00:17:26,520
and guzzle in a consistent and

00:17:24,510 --> 00:17:29,460
maintainable way to to communicate with

00:17:26,520 --> 00:17:32,550
third party API and then i've also

00:17:29,460 --> 00:17:36,570
started to explore type data beyond what

00:17:32,550 --> 00:17:38,970
is what is out-of-the-box to add some

00:17:36,570 --> 00:17:40,020
kind of helpers which which i'll get

00:17:38,970 --> 00:17:42,990
into

00:17:40,020 --> 00:17:44,940
a little bit so the basics very similar

00:17:42,990 --> 00:17:48,930
to entity API we have getters and

00:17:44,940 --> 00:17:51,570
setters on our type dated classes and we

00:17:48,930 --> 00:17:53,640
have the you also have to get value and

00:17:51,570 --> 00:17:54,960
set value these are also available you

00:17:53,640 --> 00:17:57,060
know you see these you probably have

00:17:54,960 --> 00:18:00,840
seen these and use these in NV API and

00:17:57,060 --> 00:18:03,150
that's because you're going down level

00:18:00,840 --> 00:18:04,670
all the way down to those primitive data

00:18:03,150 --> 00:18:09,240
types eventually

00:18:04,670 --> 00:18:11,790
now get value is going to return native

00:18:09,240 --> 00:18:15,650
PHP types like array or string but it's

00:18:11,790 --> 00:18:18,300
not gonna return you an integer or float

00:18:15,650 --> 00:18:20,370
particularly in the the default type

00:18:18,300 --> 00:18:22,980
data normalizer is always going to

00:18:20,370 --> 00:18:25,290
return you a string so if your if you

00:18:22,980 --> 00:18:28,830
won't have like a very specific use case

00:18:25,290 --> 00:18:31,010
for for exposing strict integer and

00:18:28,830 --> 00:18:33,450
float types in your API in JavaScript

00:18:31,010 --> 00:18:36,690
then you'll have to work around that by

00:18:33,450 --> 00:18:39,750
using the get casted value method and

00:18:36,690 --> 00:18:43,230
finally type data manager creates data

00:18:39,750 --> 00:18:45,060
from definitions so let's try and do

00:18:43,230 --> 00:18:46,680
that so this example again is coming

00:18:45,060 --> 00:18:51,180
from my type example module which I've

00:18:46,680 --> 00:18:53,040
recently published in my sandbox to do

00:18:51,180 --> 00:18:55,380
that it's type data manager is a service

00:18:53,040 --> 00:18:57,390
we get the service hopefully through

00:18:55,380 --> 00:19:00,210
injection and not through the the Drupal

00:18:57,390 --> 00:19:03,420
object we call the create data

00:19:00,210 --> 00:19:04,740
definition method and we provided a type

00:19:03,420 --> 00:19:07,860
so this is going to return the the

00:19:04,740 --> 00:19:10,230
definition that complex data definition

00:19:07,860 --> 00:19:12,180
that we defined earlier and then I can

00:19:10,230 --> 00:19:15,320
give it some default values they

00:19:12,180 --> 00:19:18,120
probably want so again when you use map

00:19:15,320 --> 00:19:20,220
youryour values that your if you wanted

00:19:18,120 --> 00:19:23,160
to create it's just an associative array

00:19:20,220 --> 00:19:27,180
again map is almost like an associative

00:19:23,160 --> 00:19:29,190
array itself and then I can use the

00:19:27,180 --> 00:19:32,640
create method on type data manager to

00:19:29,190 --> 00:19:36,240
actually create an instance of the data

00:19:32,640 --> 00:19:41,820
type defined by the definition with

00:19:36,240 --> 00:19:43,980
those default values we're on say we

00:19:41,820 --> 00:19:47,970
want to get the representation for the

00:19:43,980 --> 00:19:49,820
primary attribute or property we you

00:19:47,970 --> 00:19:52,250
would get if you use the get method

00:19:49,820 --> 00:19:54,590
you're going to get the

00:19:52,250 --> 00:19:56,660
type data representation but if let's

00:19:54,590 --> 00:19:59,120
say I wanted to get the actual raw value

00:19:56,660 --> 00:20:02,480
again I would need to go and call get

00:19:59,120 --> 00:20:06,590
value or get casted value on that on

00:20:02,480 --> 00:20:11,450
that that returned value if I did

00:20:06,590 --> 00:20:13,660
for instance data get value that would

00:20:11,450 --> 00:20:19,250
return to me an associative array

00:20:13,660 --> 00:20:23,690
similar to what we saw over here and I'm

00:20:19,250 --> 00:20:26,900
skip a slide here all right how another

00:20:23,690 --> 00:20:30,380
example so let's say I want to create a

00:20:26,900 --> 00:20:35,210
form a select list in a form populated

00:20:30,380 --> 00:20:37,490
by type data so I do this in my reserve

00:20:35,210 --> 00:20:41,960
multiple providing a select list of

00:20:37,490 --> 00:20:43,820
accounts default accounts well ignore

00:20:41,960 --> 00:20:46,460
kind of this black box method for now

00:20:43,820 --> 00:20:51,730
all it's going to return is a list of

00:20:46,460 --> 00:20:56,180
accounts which you know through guzzle I

00:20:51,730 --> 00:20:59,300
can because I'm using the complex data

00:20:56,180 --> 00:21:01,160
and using map my accounts it's an

00:20:59,300 --> 00:21:04,250
iterator so I can go through each

00:21:01,160 --> 00:21:07,070
account get the property four code and

00:21:04,250 --> 00:21:09,740
get its actual raw value and then create

00:21:07,070 --> 00:21:15,200
a little associative array to then

00:21:09,740 --> 00:21:17,150
populate my select list down below so I

00:21:15,200 --> 00:21:19,160
had to make sense this kind of you know

00:21:17,150 --> 00:21:20,480
familiar with the the entity API so

00:21:19,160 --> 00:21:23,540
let's go into a little bit more in

00:21:20,480 --> 00:21:25,070
advance example about normalization so I

00:21:23,540 --> 00:21:28,160
had to kind of figure this out on my own

00:21:25,070 --> 00:21:31,270
a couple years ago since there was no

00:21:28,160 --> 00:21:34,190
documentation at the time and

00:21:31,270 --> 00:21:38,450
normalization is is the act of

00:21:34,190 --> 00:21:41,540
transforming data to normalize form from

00:21:38,450 --> 00:21:44,390
like a specific form so we have our date

00:21:41,540 --> 00:21:47,480
our Drupal data types and normalization

00:21:44,390 --> 00:21:50,450
is once you turn them into what is

00:21:47,480 --> 00:21:54,200
needed generic form so what is needed

00:21:50,450 --> 00:21:56,270
for communicating with the API if you've

00:21:54,200 --> 00:21:58,580
never defined a normalized before it's

00:21:56,270 --> 00:22:01,100
again it's another service it's a tagged

00:21:58,580 --> 00:22:01,630
service which basically means it has

00:22:01,100 --> 00:22:03,640
another

00:22:01,630 --> 00:22:07,840
Tyler can pass if you're not familiar

00:22:03,640 --> 00:22:10,330
with the the symphony container so so

00:22:07,840 --> 00:22:13,570
these these services have like a little

00:22:10,330 --> 00:22:15,970
extra thing going on with them you'll

00:22:13,570 --> 00:22:21,220
want to inject the type data manager

00:22:15,970 --> 00:22:25,300
service the first important thing to

00:22:21,220 --> 00:22:27,700
remember about the normalization class

00:22:25,300 --> 00:22:29,230
is this supported interface or class and

00:22:27,700 --> 00:22:31,180
actually just recently there was a

00:22:29,230 --> 00:22:34,450
commit and I think it's coming in 8.2

00:22:31,180 --> 00:22:37,930
that makes this optional but for me I

00:22:34,450 --> 00:22:40,690
need to implement this because 0 being a

00:22:37,930 --> 00:22:42,850
special snowflake API has some

00:22:40,690 --> 00:22:45,580
requirements I and so I want to target

00:22:42,850 --> 00:22:46,840
my my data type so this is one way of of

00:22:45,580 --> 00:22:48,850
having your normal you know have

00:22:46,840 --> 00:22:51,280
normalizer be restricted to just your

00:22:48,850 --> 00:22:54,820
data types to have to have an implement

00:22:51,280 --> 00:22:57,190
an interface skipping down of it I'm

00:22:54,820 --> 00:23:01,090
gonna ignore the normalized method which

00:22:57,190 --> 00:23:03,580
is pretty straightforward so when I get

00:23:01,090 --> 00:23:07,210
bad data back from the API denormalize

00:23:03,580 --> 00:23:08,980
it into type data again I'm gonna use

00:23:07,210 --> 00:23:10,870
the type data manager to create a list

00:23:08,980 --> 00:23:13,840
data definition and they don't see this

00:23:10,870 --> 00:23:16,150
use of this context variable the context

00:23:13,840 --> 00:23:17,950
parameter doesn't really have any

00:23:16,150 --> 00:23:20,080
documentation around it in symphony it's

00:23:17,950 --> 00:23:22,450
coming from symphony and this is one of

00:23:20,080 --> 00:23:24,070
the gotchas that i I ran into inside

00:23:22,450 --> 00:23:28,650
what is what is this context parameter

00:23:24,070 --> 00:23:31,030
and is essentially just a free-form

00:23:28,650 --> 00:23:33,400
parameter that sterilizers and

00:23:31,030 --> 00:23:36,640
normalizes use so it could be anything

00:23:33,400 --> 00:23:40,630
but in this case we passed the plugin

00:23:36,640 --> 00:23:43,060
the plugin ID via the plugin ID key of

00:23:40,630 --> 00:23:46,090
the context parameter again the contacts

00:23:43,060 --> 00:23:48,460
parameter was added in 2013 I the commit

00:23:46,090 --> 00:23:51,790
message for it's kind of amusing

00:23:48,460 --> 00:23:53,620
Benjamin Everleigh committed a

00:23:51,790 --> 00:23:56,110
completely refactoring the steriliser

00:23:53,620 --> 00:23:59,620
options pull request to push context

00:23:56,110 --> 00:24:01,300
information directly and avoid state to

00:23:59,620 --> 00:24:03,550
end dependencies between serializer

00:24:01,300 --> 00:24:06,640
interface and encoders slash normalize

00:24:03,550 --> 00:24:07,299
errs again not really straightforward of

00:24:06,640 --> 00:24:09,730
what that

00:24:07,299 --> 00:24:11,700
and that's literally all the

00:24:09,730 --> 00:24:18,039
documentation there is on that and

00:24:11,700 --> 00:24:20,710
except for this session so how do I use

00:24:18,039 --> 00:24:22,119
normalizer you know normalizer is great

00:24:20,710 --> 00:24:24,759
by itself it's not really gonna do

00:24:22,119 --> 00:24:27,639
anything so guzzle and sterilizers is

00:24:24,759 --> 00:24:29,679
how you do that there's a excellent

00:24:27,639 --> 00:24:31,929
session on the guzzle on Thursday at

00:24:29,679 --> 00:24:35,139
10:45 unfortunately the same time as

00:24:31,929 --> 00:24:38,190
that composure session so you'll have to

00:24:35,139 --> 00:24:42,369
choose your battles there so let's let's

00:24:38,190 --> 00:24:43,389
run through a little quick example the

00:24:42,369 --> 00:24:45,070
first thing I need to do is I need to

00:24:43,389 --> 00:24:46,210
serialize my data so this is how

00:24:45,070 --> 00:24:49,149
normalizer works

00:24:46,210 --> 00:24:50,889
you call serialize on and then serialize

00:24:49,149 --> 00:24:52,809
the serialize ur component symphony is

00:24:50,889 --> 00:24:54,609
going to go down the chain and and

00:24:52,809 --> 00:24:58,749
normalize first and then call the

00:24:54,609 --> 00:25:01,629
encoder to encode the data in XML or

00:24:58,749 --> 00:25:03,850
JSON so here's that context parameter

00:25:01,629 --> 00:25:05,919
again again I've got an extra thing in

00:25:03,850 --> 00:25:10,480
there just or you know a random thing

00:25:05,919 --> 00:25:12,309
not documented anywhere I call serialize

00:25:10,480 --> 00:25:15,129
on it I'm sorry I call serialize on the

00:25:12,309 --> 00:25:17,769
data so that's my data type that I my

00:25:15,129 --> 00:25:19,450
instantiation of type data and then I

00:25:17,769 --> 00:25:24,429
you know give it a format and give it

00:25:19,450 --> 00:25:27,249
the context I get the the XML back in

00:25:24,429 --> 00:25:29,409
this case and my I put in my body of the

00:25:27,249 --> 00:25:32,590
message I'm going to send and then I

00:25:29,409 --> 00:25:33,700
call the ghusl client method with it

00:25:32,590 --> 00:25:37,269
with the appropriate method on the

00:25:33,700 --> 00:25:41,080
endpoint passing in request options and

00:25:37,269 --> 00:25:43,629
I get back a nice PS ar7 response and

00:25:41,080 --> 00:25:45,730
then I can then with my response and I'm

00:25:43,629 --> 00:25:48,460
lucky in that when I post an account I

00:25:45,730 --> 00:25:49,989
get an account may not always be the

00:25:48,460 --> 00:25:52,960
case in the API to implement but it

00:25:49,989 --> 00:25:55,269
should be I will get I will deserialize

00:25:52,960 --> 00:26:00,039
the contents of that body into the

00:25:55,269 --> 00:26:02,440
respective type data and that's

00:26:00,039 --> 00:26:05,350
essentially what I'm using most about

00:26:02,440 --> 00:26:09,970
type data in Xero but I need a little

00:26:05,350 --> 00:26:12,340
bit more so I 0 I implemented a kind of

00:26:09,970 --> 00:26:14,529
like a little class to help me build

00:26:12,340 --> 00:26:16,210
forms so I've recently abstracted that

00:26:14,529 --> 00:26:17,290
out into the type 2 element builder

00:26:16,210 --> 00:26:19,930
service and a

00:26:17,290 --> 00:26:22,990
and in the type of widget module so this

00:26:19,930 --> 00:26:25,000
creates dinette it dynamically creates

00:26:22,990 --> 00:26:28,000
form elements from data definitions and

00:26:25,000 --> 00:26:31,180
plug-in IDs it even supports entities

00:26:28,000 --> 00:26:33,010
and fields but its main use cases for

00:26:31,180 --> 00:26:35,950
things that implement map and primitive

00:26:33,010 --> 00:26:37,480
data types hopefully maybe I can I'm

00:26:35,950 --> 00:26:40,090
working with Fargo and maybe make this

00:26:37,480 --> 00:26:40,510
too it might might put it into rules as

00:26:40,090 --> 00:26:42,970
well

00:26:40,510 --> 00:26:45,400
not you know to drive the data selectors

00:26:42,970 --> 00:26:50,460
they you know in rules because it

00:26:45,400 --> 00:26:53,260
essentially does what what that does so

00:26:50,460 --> 00:26:54,820
it's it's a little it's pretty easy to

00:26:53,260 --> 00:26:57,430
use I'll give an example

00:26:54,820 --> 00:26:59,920
so we have basis this one method that's

00:26:57,430 --> 00:27:03,010
that I primarily use it for is get

00:26:59,920 --> 00:27:05,080
element 4 I pass it the plugin ID of the

00:27:03,010 --> 00:27:08,110
data type and I get a form element back

00:27:05,080 --> 00:27:12,250
in this case date/time ISO 8601 type is

00:27:08,110 --> 00:27:14,320
gonna return the HTML 5 you know form

00:27:12,250 --> 00:27:19,360
element render element and Drupal that

00:27:14,320 --> 00:27:21,810
gives me an HTML 5 data element and I

00:27:19,360 --> 00:27:25,420
can do like get element 4 on the the

00:27:21,810 --> 00:27:27,220
data representation for user which at

00:27:25,420 --> 00:27:29,470
the moment is just gonna call the form

00:27:27,220 --> 00:27:31,900
handler for entities or I can just get a

00:27:29,470 --> 00:27:38,010
I can pass a second option to get just

00:27:31,900 --> 00:27:42,090
the mail property on the the entity user

00:27:38,010 --> 00:27:44,620
data definition so a little example

00:27:42,090 --> 00:27:46,150
again let's say I have a form just

00:27:44,620 --> 00:27:49,720
playing yep

00:27:46,150 --> 00:27:53,740
so I have a form I get my element

00:27:49,720 --> 00:27:56,200
builder I call my method get element 4 I

00:27:53,740 --> 00:27:58,930
pass it a plug-in ID so we're gonna use

00:27:56,200 --> 00:28:00,760
that same complex data type that had the

00:27:58,930 --> 00:28:04,810
name the primary color and the secondary

00:28:00,760 --> 00:28:07,090
color list I can then skipping down a

00:28:04,810 --> 00:28:09,730
bit let's look at the submit for this I

00:28:07,090 --> 00:28:11,550
have a form so I can get my values from

00:28:09,730 --> 00:28:14,590
my form state right that's familiar

00:28:11,550 --> 00:28:19,600
interpolate then using type Data Manager

00:28:14,590 --> 00:28:23,020
I create my data definition from my my

00:28:19,600 --> 00:28:25,510
using a data type and then with the data

00:28:23,020 --> 00:28:28,000
definition I can get back to type data

00:28:25,510 --> 00:28:30,040
using type data managers create method

00:28:28,000 --> 00:28:35,050
passing in my definition

00:28:30,040 --> 00:28:37,930
and my form state values so I just

00:28:35,050 --> 00:28:41,440
basically created a form L you know a

00:28:37,930 --> 00:28:43,300
form in about three lines of code if I

00:28:41,440 --> 00:28:45,940
you know other than writing that class

00:28:43,300 --> 00:28:56,530
so it looks it would look a little bit

00:28:45,940 --> 00:28:59,800
like this all right color red in this

00:28:56,530 --> 00:29:01,810
case it created an html5 element so I

00:28:59,800 --> 00:29:05,200
have all that nice fancy browsers

00:29:01,810 --> 00:29:14,470
validation there's me failing to select

00:29:05,200 --> 00:29:15,880
with a mouse show you and that's it so

00:29:14,470 --> 00:29:19,320
that's my module that I wrote recently

00:29:15,880 --> 00:29:26,020
it's now on on drupal.org does anybody

00:29:19,320 --> 00:29:28,390
like it no awesome okay okay if you feel

00:29:26,020 --> 00:29:31,450
better now I might get a stable release

00:29:28,390 --> 00:29:33,100
so I think it's in attendance I I think

00:29:31,450 --> 00:29:35,080
the code is kind of ugly and it needs to

00:29:33,100 --> 00:29:38,440
be improved it needs help to make it a

00:29:35,080 --> 00:29:40,870
little bit more extendable so I'm you

00:29:38,440 --> 00:29:43,830
know if you have opinions on this please

00:29:40,870 --> 00:29:51,040
go ahead and post in the issue queue

00:29:43,830 --> 00:29:52,390
I'd like to extinct that type data when

00:29:51,040 --> 00:29:54,310
you implement your own type data you're

00:29:52,390 --> 00:29:57,910
missing things like like you get on on

00:29:54,310 --> 00:30:00,580
fields or on entities like form handlers

00:29:57,910 --> 00:30:03,810
so maybe we can you know add to the like

00:30:00,580 --> 00:30:07,450
a default interface or abstract class

00:30:03,810 --> 00:30:09,910
that builds a form you you know build

00:30:07,450 --> 00:30:15,520
element or a few element I'm doing that

00:30:09,910 --> 00:30:17,140
a little bit in in 0 module okay so that

00:30:15,520 --> 00:30:18,730
was really cool right there's an awesome

00:30:17,140 --> 00:30:20,890
little thing now we're gonna go to

00:30:18,730 --> 00:30:23,290
something a little bit uglier I'm gonna

00:30:20,890 --> 00:30:26,800
mold downer I'm not sure why I chose

00:30:23,290 --> 00:30:28,150
that path but we're gonna talk about PHP

00:30:26,800 --> 00:30:29,770
unit and type data

00:30:28,150 --> 00:30:32,620
I like unit tests they're awesome and

00:30:29,770 --> 00:30:36,130
fast but type Data Manager is big and

00:30:32,620 --> 00:30:38,230
scary type data calls itself so mocking

00:30:36,130 --> 00:30:40,600
is not straightforward and data

00:30:38,230 --> 00:30:42,910
definitions use static methods which is

00:30:40,600 --> 00:30:45,220
not great again static methods are not

00:30:42,910 --> 00:30:47,920
for isolating unit tests and you also

00:30:45,220 --> 00:30:49,120
need to mark the service container but

00:30:47,920 --> 00:30:50,680
on the other hand I

00:30:49,120 --> 00:30:53,860
I like seeing pretty coverage and

00:30:50,680 --> 00:30:56,590
complexity graphs so that's why I went

00:30:53,860 --> 00:30:58,810
down that rabbit alone one of the

00:30:56,590 --> 00:31:01,030
questions I like to ask myself and what

00:30:58,810 --> 00:31:02,740
all I'll answer here in the following

00:31:01,030 --> 00:31:06,400
code slides is what is actually

00:31:02,740 --> 00:31:07,510
necessary for decent code coverage yeah

00:31:06,400 --> 00:31:08,710
this is something you could ask yourself

00:31:07,510 --> 00:31:11,850
as you're watching these two other

00:31:08,710 --> 00:31:15,130
sessions you know one today at five

00:31:11,850 --> 00:31:16,960
automated testing PHP unit all the way

00:31:15,130 --> 00:31:18,100
so right again if you want to learn PHP

00:31:16,960 --> 00:31:21,070
unit you probably should go to that

00:31:18,100 --> 00:31:23,980
session I cut out a few slides because I

00:31:21,070 --> 00:31:25,000
didn't want to steal their thunder and

00:31:23,980 --> 00:31:26,770
again there's another one about

00:31:25,000 --> 00:31:29,410
evaluating different types of testing

00:31:26,770 --> 00:31:31,090
tomorrow at 10:45 so I highly suggest

00:31:29,410 --> 00:31:35,650
going to those sessions if you if you're

00:31:31,090 --> 00:31:38,410
interested in in PHP unit unit test for

00:31:35,650 --> 00:31:41,020
dead definitions are pretty easy to get

00:31:38,410 --> 00:31:42,910
coverage on right I I usually only have

00:31:41,020 --> 00:31:44,890
the get property definitions method and

00:31:42,910 --> 00:31:46,900
all it's doing is returning in an array

00:31:44,890 --> 00:31:49,870
an associative array of property names

00:31:46,900 --> 00:31:51,310
of other data definitions and those data

00:31:49,870 --> 00:31:55,270
definitions are usually covered by

00:31:51,310 --> 00:31:58,980
course tests so then I'm not sure what

00:31:55,270 --> 00:32:01,630
the value how much value there is in in

00:31:58,980 --> 00:32:06,340
creating testing this other than just

00:32:01,630 --> 00:32:09,850
getting coverage symbol coverage for

00:32:06,340 --> 00:32:13,840
example if I look at you know this test

00:32:09,850 --> 00:32:15,910
I'm testing that color class right you

00:32:13,840 --> 00:32:19,240
know I really just have to instantiate

00:32:15,910 --> 00:32:21,040
the color definition and then call the

00:32:19,240 --> 00:32:24,910
get property definitions and one of my

00:32:21,040 --> 00:32:28,240
testing the labels mean there's no logic

00:32:24,910 --> 00:32:30,460
there right I don't I'm not sure I don't

00:32:28,240 --> 00:32:34,990
really see that that much value value in

00:32:30,460 --> 00:32:37,090
that but on the other hand we've got

00:32:34,990 --> 00:32:40,180
something a little bit more complex in

00:32:37,090 --> 00:32:43,510
that that is type data manager and it's

00:32:40,180 --> 00:32:46,630
a little bit uglier so one of the issues

00:32:43,510 --> 00:32:49,120
with with testing type data is that the

00:32:46,630 --> 00:32:52,780
type data manager when it calls its

00:32:49,120 --> 00:32:54,100
create method or what data definitions

00:32:52,780 --> 00:32:56,650
are called through their create method

00:32:54,100 --> 00:32:58,600
the complex ones will call type data

00:32:56,650 --> 00:33:02,290
pater made it through the drupal object

00:32:58,600 --> 00:33:05,020
this is bad right we have to mark a

00:33:02,290 --> 00:33:08,800
service container we can't inject the

00:33:05,020 --> 00:33:11,320
dependency isn't injected sometimes we

00:33:08,800 --> 00:33:15,130
need to mark the object in a specific

00:33:11,320 --> 00:33:18,820
order so like in my normalizer class you

00:33:15,130 --> 00:33:21,820
know I I need to return things in a

00:33:18,820 --> 00:33:24,160
certain order so that type datatype when

00:33:21,820 --> 00:33:27,010
I call type Data Manager it's going to

00:33:24,160 --> 00:33:28,540
go recursively down through the the data

00:33:27,010 --> 00:33:31,690
type so it has to be done in a certain

00:33:28,540 --> 00:33:34,390
order again when I really originally

00:33:31,690 --> 00:33:36,610
wrote a class I hadn't found the

00:33:34,390 --> 00:33:39,460
returned value map method which helped a

00:33:36,610 --> 00:33:40,840
lot later so you can't be a maybe a

00:33:39,460 --> 00:33:42,880
little a little sloppy

00:33:40,840 --> 00:33:44,680
if order isn't important but if order is

00:33:42,880 --> 00:33:46,660
important you have you know you might

00:33:44,680 --> 00:33:49,210
have to rely on things and if

00:33:46,660 --> 00:33:52,200
consecutively mocking objects which is

00:33:49,210 --> 00:33:55,260
you know I think it's an anti-pattern

00:33:52,200 --> 00:33:57,840
the main method you're going to mark is

00:33:55,260 --> 00:34:00,370
the get property instance method

00:33:57,840 --> 00:34:03,910
sometimes I mark the get definition

00:34:00,370 --> 00:34:05,380
method and get definitions but mainly I

00:34:03,910 --> 00:34:08,800
really just need to mark and get

00:34:05,380 --> 00:34:12,760
property instance and and and return a a

00:34:08,800 --> 00:34:14,590
mark of the other data type so an

00:34:12,760 --> 00:34:16,419
example with prophecy if you're not

00:34:14,590 --> 00:34:18,280
familiar with prophecy that is included

00:34:16,419 --> 00:34:21,130
in Drupal core it's what's called an

00:34:18,280 --> 00:34:24,659
opinionated testing framework but

00:34:21,130 --> 00:34:27,790
nowhere does it say why it's opinionated

00:34:24,659 --> 00:34:29,950
so you have to find you know if you dig

00:34:27,790 --> 00:34:31,960
in the issue queue on github you'll find

00:34:29,950 --> 00:34:34,450
out that it's opinionated because it

00:34:31,960 --> 00:34:36,909
doesn't mock bad things like static

00:34:34,450 --> 00:34:39,640
methods magic methods or methods that

00:34:36,909 --> 00:34:40,780
return the dis objects so methods are

00:34:39,640 --> 00:34:42,940
useful for object chaining

00:34:40,780 --> 00:34:47,140
so if you need to do any of those you

00:34:42,940 --> 00:34:49,570
can't use prophecy but prophecy does is

00:34:47,140 --> 00:34:53,140
usually a little less verbose it's

00:34:49,570 --> 00:34:57,970
without further ado there's some bunch

00:34:53,140 --> 00:35:00,160
of slides of code so this first set of

00:34:57,970 --> 00:35:02,800
calls is pretty simple

00:35:00,160 --> 00:35:05,020
I'm not using prophecy so what I'm I

00:35:02,800 --> 00:35:06,940
don't usually bother with mocking the

00:35:05,020 --> 00:35:09,609
simple primitive data types because it's

00:35:06,940 --> 00:35:12,400
just so easy to do so I'm

00:35:09,609 --> 00:35:15,130
not really saving any time so I'm gonna

00:35:12,400 --> 00:35:18,460
mock out some string of a couple floats

00:35:15,130 --> 00:35:21,069
you know my float for a color and then

00:35:18,460 --> 00:35:24,509
finally down here I'm going to to

00:35:21,069 --> 00:35:29,739
prophesize the the color data type and

00:35:24,509 --> 00:35:32,710
I'll just for now I'm just marking the

00:35:29,739 --> 00:35:35,099
the get method with the red parameter to

00:35:32,710 --> 00:35:40,239
return this float data I set up here and

00:35:35,099 --> 00:35:41,289
then down here I'm I'm really lazy in

00:35:40,239 --> 00:35:47,200
this example actually

00:35:41,289 --> 00:35:49,329
so I instigate a list an item list I'm

00:35:47,200 --> 00:35:52,630
sorry I mocked I promised eyes an item

00:35:49,329 --> 00:35:54,190
list class and then I you know it's an

00:35:52,630 --> 00:35:56,109
item list as it's sort of like an index

00:35:54,190 --> 00:35:59,650
array so I marked the get method with

00:35:56,109 --> 00:36:02,170
the first index and you know I'm lazy so

00:35:59,650 --> 00:36:06,359
I'm just returning the same data type I

00:36:02,170 --> 00:36:12,210
instantiate there that's probably but

00:36:06,359 --> 00:36:15,130
I'm lazy so type Data Manager I

00:36:12,210 --> 00:36:17,200
prophesized that and I'm gonna just mock

00:36:15,130 --> 00:36:22,269
out and get property and since I'm with

00:36:17,200 --> 00:36:24,009
different arguments and then you know I

00:36:22,269 --> 00:36:25,359
have to build a container and set my

00:36:24,009 --> 00:36:29,739
type data manager service into the

00:36:25,359 --> 00:36:31,630
container and then finally I can create

00:36:29,739 --> 00:36:35,170
my data type and call the set value

00:36:31,630 --> 00:36:36,730
method on it and and get a set value I

00:36:35,170 --> 00:36:40,839
just pass in like an associative array

00:36:36,730 --> 00:36:43,539
as my values so what am i testing this

00:36:40,839 --> 00:36:45,910
is where I'm testing one line I'm

00:36:43,539 --> 00:36:48,849
testing this this is kind of I did all

00:36:45,910 --> 00:36:51,640
that so I can basically assert that when

00:36:48,849 --> 00:36:54,190
I call the getter on my my custom data

00:36:51,640 --> 00:36:55,900
type I get the right class and that's

00:36:54,190 --> 00:36:58,269
all I get that's all the value I can get

00:36:55,900 --> 00:37:02,319
out of it and the reason is I've mocked

00:36:58,269 --> 00:37:06,579
those the the return values of that

00:37:02,319 --> 00:37:08,920
getter is mocked out so if I said yeah

00:37:06,579 --> 00:37:12,400
if I want if I asserted that the the

00:37:08,920 --> 00:37:16,569
return value of get read get value was

00:37:12,400 --> 00:37:19,569
255 who doesn't there's no value because

00:37:16,569 --> 00:37:20,330
I just mocked that value I am like hey

00:37:19,569 --> 00:37:24,970
hey

00:37:20,330 --> 00:37:27,620
not a valid test so really you know

00:37:24,970 --> 00:37:30,560
that's pretty much what my goal is in

00:37:27,620 --> 00:37:33,680
testing is to assert that I'm getting

00:37:30,560 --> 00:37:35,470
the right instance out of it this is

00:37:33,680 --> 00:37:40,150
just using a simple little data provider

00:37:35,470 --> 00:37:43,850
to make it even shorter in this example

00:37:40,150 --> 00:37:47,180
so let's look at something you know

00:37:43,850 --> 00:37:49,190
using the the PHP unit Mart's so this is

00:37:47,180 --> 00:37:51,350
what I you know I learned prophecy a

00:37:49,190 --> 00:37:53,270
little like in the last year but I wrote

00:37:51,350 --> 00:37:58,280
this test for zero like two and a half

00:37:53,270 --> 00:38:00,920
years ago so this is a little uglier I'm

00:37:58,280 --> 00:38:02,180
testing my normalizer class I mentioned

00:38:00,920 --> 00:38:05,750
before that I didn't find the return

00:38:02,180 --> 00:38:09,460
value map method until after I'd written

00:38:05,750 --> 00:38:13,970
this written the code for this while you

00:38:09,460 --> 00:38:16,840
so what I have to do here is you know

00:38:13,970 --> 00:38:21,200
call this a little bit more verbose code

00:38:16,840 --> 00:38:23,150
mark out we create method mark out the

00:38:21,200 --> 00:38:25,220
get property instance method none and I

00:38:23,150 --> 00:38:28,400
have to go and this is just a small

00:38:25,220 --> 00:38:30,740
snippet this function is huge because I

00:38:28,400 --> 00:38:33,590
have to I have all this data here that

00:38:30,740 --> 00:38:35,600
I'm I'm mocking and then I have all

00:38:33,590 --> 00:38:38,870
these other data definitions that I have

00:38:35,600 --> 00:38:41,270
to instantiate and mock there's one

00:38:38,870 --> 00:38:43,910
that's even longer because I have to I

00:38:41,270 --> 00:38:46,490
have a code path that splits whether you

00:38:43,910 --> 00:38:50,300
have one item or two items and the the

00:38:46,490 --> 00:38:51,890
the output is slightly different but as

00:38:50,300 --> 00:38:55,010
again essentially so I can call the

00:38:51,890 --> 00:38:57,560
normalized method with my items and

00:38:55,010 --> 00:39:01,730
assert that I got an associative array

00:38:57,560 --> 00:39:06,770
that matches my expected input for zero

00:39:01,730 --> 00:39:08,750
based on my type data that's a lot right

00:39:06,770 --> 00:39:11,360
I just showed you like what four or five

00:39:08,750 --> 00:39:13,820
lines of five slides of code something

00:39:11,360 --> 00:39:16,820
like that so to apologize I wrote a poem

00:39:13,820 --> 00:39:19,610
about mocking Drupal what I learned not

00:39:16,820 --> 00:39:22,460
to do I resign myself to that fate

00:39:19,610 --> 00:39:25,070
besides core does it too so please do

00:39:22,460 --> 00:39:27,350
not hate this container so small is not

00:39:25,070 --> 00:39:29,300
actually in my app at all I do not wish

00:39:27,350 --> 00:39:32,120
to load or directly invoke the container

00:39:29,300 --> 00:39:33,230
to get variables into my code but to be

00:39:32,120 --> 00:39:35,960
a better maintainer

00:39:33,230 --> 00:39:46,810
forgive what I leverage all I want is

00:39:35,960 --> 00:39:46,810
pretty coverage an alternative opinion

00:39:46,990 --> 00:39:52,790
is that I'm crazy it and you know it's

00:39:50,210 --> 00:39:56,330
it's true like why go through all of

00:39:52,790 --> 00:40:01,520
that right I mean that was a lot of

00:39:56,330 --> 00:40:05,300
effort to to run tests you know to you

00:40:01,520 --> 00:40:07,850
to do all that I mean the reason is my

00:40:05,300 --> 00:40:09,740
previous code wasn't testable and I use

00:40:07,850 --> 00:40:13,390
untight to socialism one that strictly

00:40:09,740 --> 00:40:15,680
typed and I if I want to you say

00:40:13,390 --> 00:40:17,780
integration test I couldn't do it

00:40:15,680 --> 00:40:20,000
because if you're written an automated

00:40:17,780 --> 00:40:22,340
test for an external API or for in a

00:40:20,000 --> 00:40:25,340
public repository you can't go embedding

00:40:22,340 --> 00:40:27,700
your API keys into github or drupal.org

00:40:25,340 --> 00:40:30,050
that's you know you're gonna get stolen

00:40:27,700 --> 00:40:31,400
all right so this is something that you

00:40:30,050 --> 00:40:34,220
know you have to do that if you're

00:40:31,400 --> 00:40:39,350
implementing Web Services API s and you

00:40:34,220 --> 00:40:41,720
want to you have code coverage and yeah

00:40:39,350 --> 00:40:44,420
I also think that did definitions and

00:40:41,720 --> 00:40:46,160
types better model non Drupal data which

00:40:44,420 --> 00:40:49,880
makes it a little less complex integrate

00:40:46,160 --> 00:40:51,410
on the normalization side yeah you

00:40:49,880 --> 00:40:53,660
probably could get away with just a

00:40:51,410 --> 00:40:54,230
million normalizer yeah custom

00:40:53,660 --> 00:40:56,390
normalizer

00:40:54,230 --> 00:40:58,640
but you know yeah you'd have to to

00:40:56,390 --> 00:41:01,850
really target that entity that you've

00:40:58,640 --> 00:41:04,670
done and I don't I don't need storage I

00:41:01,850 --> 00:41:06,619
don't need access handlers I'll let my

00:41:04,670 --> 00:41:09,140
forms deal with that and my routes deal

00:41:06,619 --> 00:41:15,530
with access my rest some things will

00:41:09,140 --> 00:41:18,410
deal with access and I think it will

00:41:15,530 --> 00:41:23,030
integrate better with with with talking

00:41:18,410 --> 00:41:24,619
to Tripp so what do we cover today went

00:41:23,030 --> 00:41:27,500
over how to create data types and data

00:41:24,619 --> 00:41:30,220
definition plugins we went over how to

00:41:27,500 --> 00:41:33,290
use type data and how to instantiate

00:41:30,220 --> 00:41:35,900
data types and use it with serializer

00:41:33,290 --> 00:41:39,200
and to implement to integrate with a

00:41:35,900 --> 00:41:40,550
third party API and shut off type of

00:41:39,200 --> 00:41:43,010
widget today and then really create

00:41:40,550 --> 00:41:44,750
forms from data definitions and we

00:41:43,010 --> 00:41:45,860
looked a little bit about testing with

00:41:44,750 --> 00:41:48,740
with peach

00:41:45,860 --> 00:41:50,150
to mock type data manager there's all

00:41:48,740 --> 00:41:51,440
still a lot more to learn I'm still

00:41:50,150 --> 00:41:53,660
going down the rabbit hole

00:41:51,440 --> 00:41:55,790
like there's type config now which is

00:41:53,660 --> 00:41:59,660
another topic of its own so there's a

00:41:55,790 --> 00:42:03,440
similar service for for creating and

00:41:59,660 --> 00:42:05,600
data types from configuration I think

00:42:03,440 --> 00:42:07,640
there's a lot of to dues there to turn

00:42:05,600 --> 00:42:09,820
it into talk data but I like to open up

00:42:07,640 --> 00:42:12,920
the floor to ask and discuss or share

00:42:09,820 --> 00:42:15,650
type data use cases questions about type

00:42:12,920 --> 00:42:17,870
data manager text widget comments about

00:42:15,650 --> 00:42:20,000
type data API complex any improvements

00:42:17,870 --> 00:42:22,790
we also have the evaluate this session

00:42:20,000 --> 00:42:24,860
if you could or you can tweet me when

00:42:22,790 --> 00:42:27,290
yeah my username on on dribble auto

00:42:24,860 --> 00:42:34,100
words and radcliffe but i am matt convey

00:42:27,290 --> 00:42:36,260
on on twitter any questions go ahead and

00:42:34,100 --> 00:42:38,600
step up if you I know it's a little hard

00:42:36,260 --> 00:42:41,380
if you use the mic I'd be appreciated

00:42:38,600 --> 00:42:43,370
yeah mmm in the example and one of the

00:42:41,380 --> 00:42:48,890
slides in the beginning there was the

00:42:43,370 --> 00:42:53,120
getter where it's a get read or no no I

00:42:48,890 --> 00:42:54,830
should get primer and and get thread is

00:42:53,120 --> 00:42:58,130
there a way of doing it without strings

00:42:54,830 --> 00:43:01,070
like its type data anyway so it should

00:42:58,130 --> 00:43:04,040
be possible to use a variable name or

00:43:01,070 --> 00:43:06,200
something yes so the question is is it

00:43:04,040 --> 00:43:10,130
possible to use like a variable name to

00:43:06,200 --> 00:43:13,490
to get to use the getter and and that

00:43:10,130 --> 00:43:16,790
answer is yes yeah I could have created

00:43:13,490 --> 00:43:18,140
a function to say get just get a

00:43:16,790 --> 00:43:22,460
property name and then pass that

00:43:18,140 --> 00:43:24,800
property name in yeah you can do that I

00:43:22,460 --> 00:43:28,940
just before the exam you say give an

00:43:24,800 --> 00:43:32,110
example I wanted to be verbose how the

00:43:28,940 --> 00:43:32,110
answers your question

00:43:35,260 --> 00:43:41,770
yeah can you step up to the mic okay

00:43:45,250 --> 00:43:50,060
okay so the the question was what about

00:43:48,320 --> 00:43:53,630
data storage and what if I wanted to

00:43:50,060 --> 00:43:55,940
store data in the database so again the

00:43:53,630 --> 00:43:57,890
disadvantage of type data is that you

00:43:55,940 --> 00:43:59,930
don't get all the nice the nice-to-haves

00:43:57,890 --> 00:44:03,500
like the entity so entities provide

00:43:59,930 --> 00:44:05,510
storage you get field storage so you

00:44:03,500 --> 00:44:06,950
would have to implement your own so if

00:44:05,510 --> 00:44:08,840
you really didn't want to use entities

00:44:06,950 --> 00:44:13,640
and you want to implement your type data

00:44:08,840 --> 00:44:15,680
with storage you could then perhaps

00:44:13,640 --> 00:44:19,490
implement a service that that calls the

00:44:15,680 --> 00:44:21,590
database service and then you know do

00:44:19,490 --> 00:44:24,950
the you know do queries yourself to

00:44:21,590 --> 00:44:26,750
insert data based on this on that an

00:44:24,950 --> 00:44:29,330
example could be storing data in the

00:44:26,750 --> 00:44:31,820
JSON type that does actually be a really

00:44:29,330 --> 00:44:33,710
fascinating little module to write would

00:44:31,820 --> 00:44:38,900
be to create like an entity storage

00:44:33,710 --> 00:44:42,410
layer that instead of saving data in in

00:44:38,900 --> 00:44:45,320
the columns just use a sterilizer to

00:44:42,410 --> 00:44:48,700
JSON encode and store it in the database

00:44:45,320 --> 00:44:52,430
directly or started chasing decode I

00:44:48,700 --> 00:44:53,720
think I'd be a fun little module it's

00:44:52,430 --> 00:44:59,680
pretty really if you use Postgres each

00:44:53,720 --> 00:44:59,680
one they answer a question

00:45:05,760 --> 00:45:13,140
I think you mentioned it it's just to

00:45:09,600 --> 00:45:15,300
confirm but does the entity API then the

00:45:13,140 --> 00:45:18,780
field API eventually trickle down to the

00:45:15,300 --> 00:45:21,120
type data so or is that completely

00:45:18,780 --> 00:45:23,100
separate so the question is does the

00:45:21,120 --> 00:45:26,550
entity API and the field API trickle

00:45:23,100 --> 00:45:27,240
down to and you start the API and the

00:45:26,550 --> 00:45:31,950
answer is yes

00:45:27,240 --> 00:45:33,840
so when because your entity field

00:45:31,950 --> 00:45:36,600
definitions so you think about base

00:45:33,840 --> 00:45:39,120
field definition so if I create a base

00:45:36,600 --> 00:45:41,580
field definition of integer that is

00:45:39,120 --> 00:45:45,620
actually a field item of field item

00:45:41,580 --> 00:45:48,180
integer and that's composed itself of

00:45:45,620 --> 00:45:51,600
property definitions and those are

00:45:48,180 --> 00:45:54,630
usually inflating data definition and so

00:45:51,600 --> 00:45:57,690
the data definition create methods on on

00:45:54,630 --> 00:46:01,470
the field item integers properties are

00:45:57,690 --> 00:46:06,120
going to be primitive data types and so

00:46:01,470 --> 00:46:08,790
eventually when you call get on that on

00:46:06,120 --> 00:46:11,550
that property and the entity you then

00:46:08,790 --> 00:46:15,180
have to call get value which is probably

00:46:11,550 --> 00:46:18,470
I believe is wrapping calls down to to

00:46:15,180 --> 00:46:18,470
the primitive data types

00:46:25,280 --> 00:46:33,800
you have any questions okay one last

00:46:31,520 --> 00:46:35,480
thing I'd like to welcome everyone to

00:46:33,800 --> 00:46:38,450
join us for the contribution sprints on

00:46:35,480 --> 00:46:40,940
Friday the first time sprint sprayer

00:46:38,450 --> 00:46:43,700
workshop to help set up a triple-eight

00:46:40,940 --> 00:46:46,220
environment to work work on core with

00:46:43,700 --> 00:46:48,350
the mentor Corps sprint so where people

00:46:46,220 --> 00:46:51,860
like myself I'm a mentor you work with

00:46:48,350 --> 00:46:52,940
with us to work on issues or and also

00:46:51,860 --> 00:46:56,060
the general sprints if you're more

00:46:52,940 --> 00:46:58,070
familiar with core process to to join

00:46:56,060 --> 00:47:00,680
just join the general sprints and and

00:46:58,070 --> 00:47:02,930
work on a topic like type Widgit

00:47:00,680 --> 00:47:04,610
although I'm not sure if I'll be having

00:47:02,930 --> 00:47:08,000
much time on Friday to do that as a

00:47:04,610 --> 00:47:10,220
mentor you're welcome to to submit

00:47:08,000 --> 00:47:13,520
patches for four types widget or maybe

00:47:10,220 --> 00:47:16,370
rules I work with Fargo I'm see if he

00:47:13,520 --> 00:47:21,970
needs help on implementing type data in

00:47:16,370 --> 00:47:21,970
rules we got another question go ahead

00:47:26,020 --> 00:47:38,210
so question is can I store type data

00:47:28,850 --> 00:47:40,900
into a into a field value so probably

00:47:38,210 --> 00:47:43,460
you there is nothing that will save

00:47:40,900 --> 00:47:47,180
field values outside of an entity

00:47:43,460 --> 00:47:50,300
so again if you you probably just use an

00:47:47,180 --> 00:47:57,950
entity to do that and use field off an

00:47:50,300 --> 00:47:59,750
entity you you could theoretically you

00:47:57,950 --> 00:48:02,150
might have to override some methods on

00:47:59,750 --> 00:48:04,130
your field type or you know basically

00:48:02,150 --> 00:48:06,080
ignore some methods on that field type

00:48:04,130 --> 00:48:12,260
but you could you know get the value and

00:48:06,080 --> 00:48:14,750
then again you'd have to go through the

00:48:12,260 --> 00:48:19,360
database storage a service similar to

00:48:14,750 --> 00:48:21,390
your other question yep

00:48:19,360 --> 00:48:21,390
Oh

00:48:46,870 --> 00:48:55,360
so yeah Peter mentioned that he is go

00:48:52,370 --> 00:48:55,360
ahead and repeat it what you said

00:48:55,870 --> 00:49:00,020
pretend this didn't happen before so

00:48:58,490 --> 00:49:02,420
just to add to that question I've

00:49:00,020 --> 00:49:04,580
actually done that and you can store

00:49:02,420 --> 00:49:07,100
type data in a dump field that

00:49:04,580 --> 00:49:09,980
serialized in the database and you have

00:49:07,100 --> 00:49:12,320
to use the core data type of any which

00:49:09,980 --> 00:49:13,820
allows any type of data to be stored it

00:49:12,320 --> 00:49:15,800
doesn't make any assumptions about what

00:49:13,820 --> 00:49:17,420
it is and you make sure that your fields

00:49:15,800 --> 00:49:19,820
handler is actually returning the

00:49:17,420 --> 00:49:22,100
correct type data by basically adding a

00:49:19,820 --> 00:49:26,360
step that creates the instance of type

00:49:22,100 --> 00:49:27,920
data from that serialize data so I've

00:49:26,360 --> 00:49:31,450
got some examples if you want to talk

00:49:27,920 --> 00:49:31,450
through after I can show you as well

00:49:36,270 --> 00:49:40,860
all right if there's any more questions

00:49:38,040 --> 00:49:43,380
you just see me afterwards let you go

00:49:40,860 --> 00:49:45,740
and have a break and get enjoy the next

00:49:43,380 --> 00:49:45,740

YouTube URL: https://www.youtube.com/watch?v=v7m6qOxH1t0


