Title: DrupalCon Dublin 2016: HTTP 2: what no one is telling you
Publication date: 2016-09-27
Playlist: DrupalCon Dublin 2016
Description: 
	HTTP/2 (or "H2" as the cool kids call it) has been ratified for months and browsers already support or have committed to supporting the protocol. Everything we hear tells us that the new version of HTTP will provide significant performance benefits while requiring little to no change to our applications -- all the problems with HTTP/1.x have seemingly been addressed, we no longer need the "hacks" that enabled us to circumvent them, and the Internet is about to be a happy place, at last!

But maybe we should put the pom poms down for a minute! Deploying HTTP/2 may not be as easy as it seems, since the protocol brings with it new complications and issues. Likewise, the new features the spec introduces may not work as seamlessly as we'd hope. In this session, we'll take a practical look at HTTP/2 and examine some of its core features and how they relate to real-world conditions. We'll discuss positives, negatives, and new caveats and practical considerations for deploying HTTP/2. Specifically, we'll cover:

- The single-connection model, and the impact of degraded network conditions on HTTP/2 vs HTTP/1

- How server push interacts (or doesnâ€™t) with modern browser caches

- What HTTP/2's flow control mechanism means for server-to-client communication

- New considerations for deploying HPACK compression

- Difficulties in troubleshooting HTTP/2 communications, new tools, and new ways to use old tools

----

The audience will walk understanding the basic concepts of HTTP/2, and its pitfalls, allowing them to properly implement it.
Captions: 
	00:00:00,120 --> 00:00:09,540
hello everyone so you want to learn

00:00:02,790 --> 00:00:11,639
about HTTP - I know you do okay I'm

00:00:09,540 --> 00:00:14,130
gonna get started I have a lot to tell

00:00:11,639 --> 00:00:15,960
you today so I need all the time I can

00:00:14,130 --> 00:00:17,699
get where he lost 20 seconds

00:00:15,960 --> 00:00:20,820
my name is human I'm the VP of

00:00:17,699 --> 00:00:24,630
Technology of fastly we're a CDN we're

00:00:20,820 --> 00:00:26,519
here downstairs come visit us all of us

00:00:24,630 --> 00:00:29,279
except one person is wearing really

00:00:26,519 --> 00:00:33,899
really bright red outfits you'll see

00:00:29,279 --> 00:00:37,559
them right here okay I'm gonna get going

00:00:33,899 --> 00:00:40,440
the title of this presentation was

00:00:37,559 --> 00:00:43,110
really really valid about six months ago

00:00:40,440 --> 00:00:44,219
when we came up with it some people have

00:00:43,110 --> 00:00:49,260
started talking about some of this stuff

00:00:44,219 --> 00:00:51,870
so I had to amend it despite that if

00:00:49,260 --> 00:00:55,530
you're like me a lot of what you heard

00:00:51,870 --> 00:00:58,469
about HTTP - sounded like this

00:00:55,530 --> 00:01:02,100
it was panacea it was a promise of a

00:00:58,469 --> 00:01:03,629
great internet in the future there was

00:01:02,100 --> 00:01:06,900
so much of this actually I felt like it

00:01:03,629 --> 00:01:10,170
was clickbait after a while despite all

00:01:06,900 --> 00:01:13,020
of this what I wanted to do is I wanted

00:01:10,170 --> 00:01:15,080
to take a step back and look at the

00:01:13,020 --> 00:01:17,670
protocol somewhat objectively and

00:01:15,080 --> 00:01:19,350
practically and see how it acts in the

00:01:17,670 --> 00:01:20,700
real world and what are those practical

00:01:19,350 --> 00:01:22,490
considerations for the real world I have

00:01:20,700 --> 00:01:24,930
a bunch of data I want to share with you

00:01:22,490 --> 00:01:25,950
and at the end of the day I want us all

00:01:24,930 --> 00:01:27,659
to have a better understanding of the

00:01:25,950 --> 00:01:30,450
good and the bad and talk about what

00:01:27,659 --> 00:01:32,520
happens next my assumption is that

00:01:30,450 --> 00:01:34,470
you're familiar with general web

00:01:32,520 --> 00:01:36,720
performance topics I'm hoping you've all

00:01:34,470 --> 00:01:37,979
seen a waterfall from a web page you

00:01:36,720 --> 00:01:40,229
know general things about web

00:01:37,979 --> 00:01:42,240
performance and you're somewhat familiar

00:01:40,229 --> 00:01:43,710
with HTTP as a protocol what I'm gonna

00:01:42,240 --> 00:01:47,220
do first though is I'm going to go

00:01:43,710 --> 00:01:48,869
through the basics of h2 and sort of lay

00:01:47,220 --> 00:01:52,560
the groundwork before I get into the

00:01:48,869 --> 00:01:57,840
meat of the presentation so in the

00:01:52,560 --> 00:02:01,770
beginning of time 1999 or so sorry 1991

00:01:57,840 --> 00:02:04,020
or so there was HTTP one HTTP one ran

00:02:01,770 --> 00:02:07,110
over the TCP protocol and you probably

00:02:04,020 --> 00:02:08,429
know that HTTP and TCP have

00:02:07,110 --> 00:02:10,709
traditionally not worked well together

00:02:08,429 --> 00:02:12,720
what happens is a client opens a TCP

00:02:10,709 --> 00:02:13,680
connection to a server sends a request

00:02:12,720 --> 00:02:15,540
over that can

00:02:13,680 --> 00:02:17,579
and the server responds and while that

00:02:15,540 --> 00:02:19,799
exchange is happening nothing else can

00:02:17,579 --> 00:02:21,329
happen over that connection this is

00:02:19,799 --> 00:02:23,609
something we call had a line blocking

00:02:21,329 --> 00:02:25,349
essentially an outstanding request

00:02:23,609 --> 00:02:28,140
doesn't allow that connection to be used

00:02:25,349 --> 00:02:29,969
for anything else the protocol had

00:02:28,140 --> 00:02:32,099
something called pipelining provision in

00:02:29,969 --> 00:02:33,930
which sort of was supposed to address at

00:02:32,099 --> 00:02:35,879
least half of this problem the idea was

00:02:33,930 --> 00:02:37,620
to send a lot of requests one after

00:02:35,879 --> 00:02:39,510
another over a connection and get the

00:02:37,620 --> 00:02:41,609
responses back one after another it

00:02:39,510 --> 00:02:43,950
never worked we never actually used it

00:02:41,609 --> 00:02:45,299
and one of the problems with it was when

00:02:43,950 --> 00:02:47,040
you send a bunch of requests over a

00:02:45,299 --> 00:02:48,959
connection they all had to come back in

00:02:47,040 --> 00:02:51,329
the same order you could never inter

00:02:48,959 --> 00:02:53,099
leave those responses so that was still

00:02:51,329 --> 00:02:55,109
somewhat had a line blocking if an

00:02:53,099 --> 00:02:56,400
outstanding request or a response the

00:02:55,109 --> 00:02:59,069
response took a long time to come back

00:02:56,400 --> 00:03:00,840
sort of blocked everything behind it so

00:02:59,069 --> 00:03:02,519
we did is we try to address it in the

00:03:00,840 --> 00:03:05,400
browser by opening multiple connections

00:03:02,519 --> 00:03:07,409
you probably know this browsers open six

00:03:05,400 --> 00:03:09,239
connections per host and this is their

00:03:07,409 --> 00:03:10,769
attempt to do some concurrency and

00:03:09,239 --> 00:03:12,659
alleviate this header line bracket

00:03:10,769 --> 00:03:14,310
blocking that still wasn't good enough

00:03:12,659 --> 00:03:17,849
so we came up with clever techniques

00:03:14,310 --> 00:03:19,859
like concatenation consolidation sprites

00:03:17,849 --> 00:03:22,500
a bunch of inlining an entire industry

00:03:19,859 --> 00:03:24,419
called feo or front-end optimization was

00:03:22,500 --> 00:03:27,959
born out of addressing these

00:03:24,419 --> 00:03:29,609
inefficiencies but still something

00:03:27,959 --> 00:03:32,849
needed to be addressed at the protocol

00:03:29,609 --> 00:03:36,389
level so the primary problems that were

00:03:32,849 --> 00:03:37,829
sort of identified with h1 HTTP one was

00:03:36,389 --> 00:03:38,849
that there was a bad concurrency or

00:03:37,829 --> 00:03:40,379
multiplexing model

00:03:38,849 --> 00:03:42,000
you couldn't interleave things so

00:03:40,379 --> 00:03:44,009
everything had to come back in order one

00:03:42,000 --> 00:03:46,049
after another then interact with TCP

00:03:44,009 --> 00:03:47,879
very well and there seemed to be a

00:03:46,049 --> 00:03:50,099
general header bloat problem so there

00:03:47,879 --> 00:03:52,379
was a companion sort of effort to

00:03:50,099 --> 00:03:56,129
address that and turn to the picture

00:03:52,379 --> 00:03:59,220
HTTP to ratified as RFC 7540 just over a

00:03:56,129 --> 00:04:00,840
year ago I'm gonna give you basically a

00:03:59,220 --> 00:04:02,009
five minute crash course on it at the

00:04:00,840 --> 00:04:04,370
end you're all gonna be experts it's

00:04:02,009 --> 00:04:08,370
gonna be amazing it's a binary protocol

00:04:04,370 --> 00:04:10,949
that means it's all ones and zeros it's

00:04:08,370 --> 00:04:12,599
a binary protocol what that means on the

00:04:10,949 --> 00:04:15,299
wire is that it's actually easier to

00:04:12,599 --> 00:04:18,239
develop for because everything is in a

00:04:15,299 --> 00:04:20,039
predetermined well-defined place if

00:04:18,239 --> 00:04:21,659
you've ever developed anything for HTTP

00:04:20,039 --> 00:04:23,760
you've had a very hard time with text

00:04:21,659 --> 00:04:25,529
parsing or slash hour / ends at the end

00:04:23,760 --> 00:04:26,920
of lines or anything in that nature all

00:04:25,529 --> 00:04:28,270
that stuff is gone

00:04:26,920 --> 00:04:30,840
binary protocols allow us to develop

00:04:28,270 --> 00:04:33,430
really really well but also gone is

00:04:30,840 --> 00:04:35,710
telling to port 80 and typing get /

00:04:33,430 --> 00:04:36,130
that's gone as well we can't do that

00:04:35,710 --> 00:04:38,860
anymore

00:04:36,130 --> 00:04:41,230
when he tools and mechanisms that are

00:04:38,860 --> 00:04:42,070
outside the protocol to help ahold help

00:04:41,230 --> 00:04:44,260
us do that stuff

00:04:42,070 --> 00:04:46,390
ok the communication itself starts with

00:04:44,260 --> 00:04:49,840
a connection a client opens a connection

00:04:46,390 --> 00:04:52,330
with a server and in h2 everything

00:04:49,840 --> 00:04:54,070
happens over a single long lasting TCP

00:04:52,330 --> 00:04:56,530
connection so it's a single connection

00:04:54,070 --> 00:04:57,960
model and the theory is that by doing

00:04:56,530 --> 00:05:00,580
everything over a single connection

00:04:57,960 --> 00:05:02,080
better congestion management can happen

00:05:00,580 --> 00:05:03,880
by the server and the client because

00:05:02,080 --> 00:05:05,380
multiple connections aren't vying for

00:05:03,880 --> 00:05:08,380
the same physical resources on the

00:05:05,380 --> 00:05:10,360
network everything happens over TLS and

00:05:08,380 --> 00:05:12,130
this is not mandated by the protocol the

00:05:10,360 --> 00:05:14,170
protocol actions a clear text version of

00:05:12,130 --> 00:05:15,490
itself but all the browser's have said

00:05:14,170 --> 00:05:17,290
they're not supporting anything other

00:05:15,490 --> 00:05:18,550
than the TLS version of the protocol so

00:05:17,290 --> 00:05:20,980
everything we're gonna see what h2 is

00:05:18,550 --> 00:05:23,250
basically going to be over TLS this is

00:05:20,980 --> 00:05:26,170
done through an extension called a LPN

00:05:23,250 --> 00:05:27,520
application layer protocol negotiation I

00:05:26,170 --> 00:05:29,110
believe if you've never seen it

00:05:27,520 --> 00:05:30,370
basically what happens is during an SSL

00:05:29,110 --> 00:05:33,010
handshake the client says I want to

00:05:30,370 --> 00:05:35,320
speak h2 and the service says you can

00:05:33,010 --> 00:05:37,630
speak h2 and after that over that

00:05:35,320 --> 00:05:40,330
connection they start communicating over

00:05:37,630 --> 00:05:42,460
h2 there's also a provision in the

00:05:40,330 --> 00:05:45,520
protocol to coalesce multiple connection

00:05:42,460 --> 00:05:47,500
multiple to do connection reuse so if

00:05:45,520 --> 00:05:49,780
you have requests going to two different

00:05:47,500 --> 00:05:51,610
host names that map to the same IP

00:05:49,780 --> 00:05:53,170
address and have the same certificate

00:05:51,610 --> 00:05:55,240
then you can send all those things over

00:05:53,170 --> 00:05:56,830
a single connection again with the goal

00:05:55,240 --> 00:05:58,420
of pushing everything over a single

00:05:56,830 --> 00:06:01,450
connection for better condition

00:05:58,420 --> 00:06:02,710
management over the long term over that

00:06:01,450 --> 00:06:05,740
connection are these things called

00:06:02,710 --> 00:06:07,300
streams streams are essentially virtual

00:06:05,740 --> 00:06:09,070
communication channels between the

00:06:07,300 --> 00:06:11,430
client and the server they can

00:06:09,070 --> 00:06:15,220
concurrently exist over the connection

00:06:11,430 --> 00:06:17,410
and either side can initiate them each

00:06:15,220 --> 00:06:19,120
stream has a stream ID stream IDs that

00:06:17,410 --> 00:06:21,220
are odds are the ones started by the

00:06:19,120 --> 00:06:22,390
client stream IDs that are even are the

00:06:21,220 --> 00:06:25,300
ones that are started by the server and

00:06:22,390 --> 00:06:28,780
stream ID 0 is sort of reserved for

00:06:25,300 --> 00:06:30,880
management purposes the only basic rules

00:06:28,780 --> 00:06:32,140
are each ID generated from each side has

00:06:30,880 --> 00:06:33,850
to be bigger than once came before it

00:06:32,140 --> 00:06:36,700
and you can't reuse stream IDs over

00:06:33,850 --> 00:06:39,760
connection with a 31 bit space that's

00:06:36,700 --> 00:06:41,410
roughly 1 billion streams per and

00:06:39,760 --> 00:06:44,530
and over the lifetime of the connection

00:06:41,410 --> 00:06:45,940
streams are stateful I'm not gonna go

00:06:44,530 --> 00:06:47,140
over this at all it was just I just

00:06:45,940 --> 00:06:47,560
gonna show it to you in case you didn't

00:06:47,140 --> 00:06:49,300
believe me

00:06:47,560 --> 00:06:51,370
it's totally stateful as a matter of

00:06:49,300 --> 00:06:54,400
fact h2 is a very staple protocol gone

00:06:51,370 --> 00:06:56,770
is the statelessness of h1 the smallest

00:06:54,400 --> 00:06:59,680
unit of communication in h2 is this

00:06:56,770 --> 00:07:00,970
thing called a frame every thing that

00:06:59,680 --> 00:07:02,920
happens between a client/server

00:07:00,970 --> 00:07:04,870
essentially happens with frames

00:07:02,920 --> 00:07:08,020
everything is framed up each frame

00:07:04,870 --> 00:07:09,420
carries a stream ID and frames basically

00:07:08,020 --> 00:07:11,410
can flow in either direction

00:07:09,420 --> 00:07:13,030
concurrently throughout the lifetime of

00:07:11,410 --> 00:07:14,470
the connection the best way to show you

00:07:13,030 --> 00:07:17,320
this is to show you what it looked like

00:07:14,470 --> 00:07:19,750
before and after so this is a h2 be one

00:07:17,320 --> 00:07:22,030
request in response exchange the client

00:07:19,750 --> 00:07:25,090
sends request headers the server sent

00:07:22,030 --> 00:07:26,650
response headers with the body in h2 the

00:07:25,090 --> 00:07:28,750
client doesn't send request letters it

00:07:26,650 --> 00:07:30,790
sends a headers frame that carries the

00:07:28,750 --> 00:07:32,920
request headers and the server sends a

00:07:30,790 --> 00:07:35,320
headers frame that carries the response

00:07:32,920 --> 00:07:38,080
headers and the body is sort of packaged

00:07:35,320 --> 00:07:40,240
up and sent in data frames these are two

00:07:38,080 --> 00:07:41,650
of the many frames that the protocol

00:07:40,240 --> 00:07:44,020
defines the protocol defines all of

00:07:41,650 --> 00:07:46,360
these frames none of which I'm gonna go

00:07:44,020 --> 00:07:48,040
through except a couple later on in the

00:07:46,360 --> 00:07:50,140
presentation I am gonna talk about the

00:07:48,040 --> 00:07:51,910
settings frame really quick the settings

00:07:50,140 --> 00:07:55,180
frame is essentially a management frame

00:07:51,910 --> 00:07:56,650
and the two sides use this to define the

00:07:55,180 --> 00:07:58,360
parameters for the connection things

00:07:56,650 --> 00:08:00,250
like how many concurrent streams I can

00:07:58,360 --> 00:08:02,770
have over the connection how big are the

00:08:00,250 --> 00:08:04,630
frame sizes server push which is a

00:08:02,770 --> 00:08:06,100
feature any other features that need to

00:08:04,630 --> 00:08:07,900
be enabled or disabled are done through

00:08:06,100 --> 00:08:09,820
settings frames there's an act

00:08:07,900 --> 00:08:11,380
acknowledgement mechanism and actually

00:08:09,820 --> 00:08:13,000
the connection starts with both sides

00:08:11,380 --> 00:08:15,220
exchanging settings frames sort of set

00:08:13,000 --> 00:08:16,930
the framework for the for the connection

00:08:15,220 --> 00:08:19,750
and if you send new settings frame with

00:08:16,930 --> 00:08:23,440
new settings they just sort of out date

00:08:19,750 --> 00:08:25,360
the they obviate the previous setting so

00:08:23,440 --> 00:08:27,220
what's the protocol look like well if

00:08:25,360 --> 00:08:28,840
this was HTTP one when he had a

00:08:27,220 --> 00:08:29,830
connection and you sent a request then

00:08:28,840 --> 00:08:32,140
you got a response

00:08:29,830 --> 00:08:33,940
this is HTTP to the client sends a

00:08:32,140 --> 00:08:35,770
headers frame with the request headers

00:08:33,940 --> 00:08:37,210
the server sends a headers frame with

00:08:35,770 --> 00:08:39,000
the response headers and a bunch of data

00:08:37,210 --> 00:08:41,380
frames that carry the body and when we

00:08:39,000 --> 00:08:44,410
managed concurrency by opening multiple

00:08:41,380 --> 00:08:47,620
connections in h1 we managed concurrency

00:08:44,410 --> 00:08:50,710
in h2 by just talking h2 we can send

00:08:47,620 --> 00:08:51,980
frames data and and header frames in

00:08:50,710 --> 00:08:54,170
either direction

00:08:51,980 --> 00:08:56,600
header frames can come one after another

00:08:54,170 --> 00:08:57,649
without data frames both in the client

00:08:56,600 --> 00:09:00,170
of server direction and the server

00:08:57,649 --> 00:09:01,639
decline could connect the direction data

00:09:00,170 --> 00:09:03,170
frames can be interleaved so you can

00:09:01,639 --> 00:09:04,519
send a data frame from stream one and

00:09:03,170 --> 00:09:06,199
then say to data frame from stream three

00:09:04,519 --> 00:09:09,079
and then another data data frame from

00:09:06,199 --> 00:09:10,940
stream one this is how we get

00:09:09,079 --> 00:09:14,120
concurrency and interleaving somebody

00:09:10,940 --> 00:09:17,500
thought this was best shown as candy so

00:09:14,120 --> 00:09:20,600
this is a delicious analogy of what h2

00:09:17,500 --> 00:09:22,550
does if you've ever looked at waterfalls

00:09:20,600 --> 00:09:24,320
and I really hope you have this is an h1

00:09:22,550 --> 00:09:26,360
of waterfall you can see it has the

00:09:24,320 --> 00:09:28,490
familiar waterfall the reason is called

00:09:26,360 --> 00:09:30,320
the waterfall this is an h2 waterfall

00:09:28,490 --> 00:09:31,910
lots of things happening concurrently

00:09:30,320 --> 00:09:34,250
you can see that when we talk about

00:09:31,910 --> 00:09:35,899
concurrency and multi multiplexing this

00:09:34,250 --> 00:09:38,690
is what it looks like and if you're like

00:09:35,899 --> 00:09:42,529
me and looking at packet captures I'm

00:09:38,690 --> 00:09:45,649
sorry that's your that's your disease

00:09:42,529 --> 00:09:47,240
like mine but this is what it looks like

00:09:45,649 --> 00:09:49,399
over the wire you can see a whole bunch

00:09:47,240 --> 00:09:50,839
of things happening back and forth see

00:09:49,399 --> 00:09:52,220
that one packet down there that's got a

00:09:50,839 --> 00:09:53,810
whole bunch of header frames together

00:09:52,220 --> 00:09:55,790
that's the server responding a bunch of

00:09:53,810 --> 00:09:57,529
with a bunch of response headers without

00:09:55,790 --> 00:10:00,170
sending any body that's not a thing we

00:09:57,529 --> 00:10:01,760
did in h1 so that's kind of cool every

00:10:00,170 --> 00:10:03,350
browser pretty much supports this now

00:10:01,760 --> 00:10:04,819
and all the servers are starting to

00:10:03,350 --> 00:10:06,709
support it as well there's modules for

00:10:04,819 --> 00:10:08,839
Apache nginx if you never heard of a

00:10:06,709 --> 00:10:10,459
server called h2o I highly recommend you

00:10:08,839 --> 00:10:12,980
check it out is an amazing amazing

00:10:10,459 --> 00:10:15,829
server supports both h1 and h2 Ouisa to

00:10:12,980 --> 00:10:19,790
fastly there's a list of these servers

00:10:15,829 --> 00:10:21,920
also on Wikipedia and I hope that all of

00:10:19,790 --> 00:10:23,449
you are using CD ends because they're

00:10:21,920 --> 00:10:24,889
great and you should be using them and

00:10:23,449 --> 00:10:26,089
if you're using them

00:10:24,889 --> 00:10:27,589
it's your CDN that's going to be

00:10:26,089 --> 00:10:31,779
terminating those connections so talk to

00:10:27,589 --> 00:10:34,730
them if you want to partake in h2 magic

00:10:31,779 --> 00:10:36,350
ok you are now all h2 experts

00:10:34,730 --> 00:10:40,579
congratulations I will have certificates

00:10:36,350 --> 00:10:43,250
for you after the event we're gonna talk

00:10:40,579 --> 00:10:44,930
about performance because arguably the

00:10:43,250 --> 00:10:48,260
most talked about feature of the

00:10:44,930 --> 00:10:50,120
protocol is performance so I am a cynic

00:10:48,260 --> 00:10:53,029
by Nature and I have to kind of see this

00:10:50,120 --> 00:10:55,459
for myself so to test it I constructed

00:10:53,029 --> 00:10:57,290
basically the perfect page for h2 which

00:10:55,459 --> 00:10:59,810
is a page that has no browser rendering

00:10:57,290 --> 00:11:02,089
with scripts or CSS whatsoever it's just

00:10:59,810 --> 00:11:03,350
a page with a hundred images on it

00:11:02,089 --> 00:11:04,070
they're the same image just named

00:11:03,350 --> 00:11:07,910
differently

00:11:04,070 --> 00:11:09,350
it's a very simple page 110km ages to

00:11:07,910 --> 00:11:11,959
highlight the the performance features

00:11:09,350 --> 00:11:13,279
of h1 sorry h2 this is what the

00:11:11,959 --> 00:11:16,670
waterfall looks like before and after

00:11:13,279 --> 00:11:18,440
you can see the familiar waterfall form

00:11:16,670 --> 00:11:20,569
before and obviously all the concurrency

00:11:18,440 --> 00:11:23,060
after if you decide to do this yourself

00:11:20,569 --> 00:11:25,880
I highly recommend that use a different

00:11:23,060 --> 00:11:27,440
image that I chose because this is great

00:11:25,880 --> 00:11:29,480
the first couple of times you look at it

00:11:27,440 --> 00:11:31,670
but I can't tell you the nightmares this

00:11:29,480 --> 00:11:34,310
induces after you've looked at it a

00:11:31,670 --> 00:11:36,589
hundred times it is horrible please

00:11:34,310 --> 00:11:38,569
choose a different image and then what I

00:11:36,589 --> 00:11:39,639
used is a tool called webpagetest raise

00:11:38,569 --> 00:11:43,370
your hands if you've heard of this tool

00:11:39,639 --> 00:11:45,050
yes if you haven't familiarize yourself

00:11:43,370 --> 00:11:47,240
with it it's an amazing tool it's

00:11:45,050 --> 00:11:49,730
basically a synthetic web testing tool

00:11:47,240 --> 00:11:51,529
that lets you put in a URL and it

00:11:49,730 --> 00:11:53,240
generates that waterfall for you the

00:11:51,529 --> 00:11:55,370
best thing about it is that it lets you

00:11:53,240 --> 00:11:57,050
emulate real-world conditions so you

00:11:55,370 --> 00:11:59,420
have bandwidth profiles and latency

00:11:57,050 --> 00:12:01,880
profiles basically can simulate a real

00:11:59,420 --> 00:12:03,529
user and use real browsers it's a

00:12:01,880 --> 00:12:05,569
magnificent tool there's a public

00:12:03,529 --> 00:12:07,100
version of it free to use or you can

00:12:05,569 --> 00:12:09,560
install a private version of it and

00:12:07,100 --> 00:12:11,420
deploy your own clients and use it

00:12:09,560 --> 00:12:13,120
in-house it's a fantastic tool I highly

00:12:11,420 --> 00:12:15,769
recommend you use it so I used it I

00:12:13,120 --> 00:12:18,139
deployed a private version of it I used

00:12:15,769 --> 00:12:19,639
a profile of five Meg's down one Meg up

00:12:18,139 --> 00:12:20,990
with 40 milliseconds of latency

00:12:19,639 --> 00:12:24,139
I picked 40 milliseconds because that

00:12:20,990 --> 00:12:27,560
was roughly the median across all CBN's

00:12:24,139 --> 00:12:29,779
in the US and five and one was the

00:12:27,560 --> 00:12:31,970
default profile used by web page that's

00:12:29,779 --> 00:12:34,550
public so I just sort of took their word

00:12:31,970 --> 00:12:38,019
for it I use Chrome compared h1 to h2

00:12:34,550 --> 00:12:40,910
and instead of testing three five nine

00:12:38,019 --> 00:12:42,800
ten times I test it two hundred and

00:12:40,910 --> 00:12:46,790
seventy times because I really wanted to

00:12:42,800 --> 00:12:53,029
see patterns this is the scatterplot of

00:12:46,790 --> 00:12:56,750
the results so orange is h1 blues h2 ok

00:12:53,029 --> 00:12:58,339
it's seems to be slightly faster I was

00:12:56,750 --> 00:13:00,860
maybe hoping for a little bit more

00:12:58,339 --> 00:13:02,240
separation that would have been kind of

00:13:00,860 --> 00:13:04,370
what the expectation was considering

00:13:02,240 --> 00:13:06,199
that this is the perfect page but we can

00:13:04,370 --> 00:13:10,670
probably argue by the scatter plot that

00:13:06,199 --> 00:13:13,100
h2 is faster than h1 certainly over you

00:13:10,670 --> 00:13:14,839
know a large data set you've probably

00:13:13,100 --> 00:13:17,640
seen some version of this upon other

00:13:14,839 --> 00:13:20,310
people where they say h2 is perform

00:13:17,640 --> 00:13:22,710
but I had never seen though is anything

00:13:20,310 --> 00:13:24,570
that includes packet loss packet loss is

00:13:22,710 --> 00:13:27,750
something that happens naturally in the

00:13:24,570 --> 00:13:29,190
wild and none of the simulations that

00:13:27,750 --> 00:13:32,100
I'd seen or any of the data that I'd

00:13:29,190 --> 00:13:34,410
seen for h2 included any packet loss

00:13:32,100 --> 00:13:36,390
fortunately webpagetest gives me packet

00:13:34,410 --> 00:13:38,070
loss so I can just put packet loss right

00:13:36,390 --> 00:13:39,030
in that can simulate packet loss as well

00:13:38,070 --> 00:13:41,370
so I did that

00:13:39,030 --> 00:13:43,410
let's take our scatter plot put in the

00:13:41,370 --> 00:13:45,060
corner let's introduce packet loss of

00:13:43,410 --> 00:13:49,610
the picture here's half a percent packet

00:13:45,060 --> 00:13:52,830
loss 1% packet loss and 2% packet loss

00:13:49,610 --> 00:13:55,980
certainly a different picture so you can

00:13:52,830 --> 00:13:57,720
see that packet loss has a an adverse

00:13:55,980 --> 00:13:59,630
effect on the performance and h2 in this

00:13:57,720 --> 00:14:02,190
case an h1 actually performs better

00:13:59,630 --> 00:14:04,260
generally with the higher the packet

00:14:02,190 --> 00:14:05,880
loss okay maybe this is a chrome thing

00:14:04,260 --> 00:14:08,520
let's be thorough let's test Firefox

00:14:05,880 --> 00:14:10,320
pretty much the same thing actually it

00:14:08,520 --> 00:14:12,960
actually stands out a little better okay

00:14:10,320 --> 00:14:15,090
I've heard a lot about how h2 is

00:14:12,960 --> 00:14:16,950
supposed to help mobile connections and

00:14:15,090 --> 00:14:18,930
slow connections let's do that

00:14:16,950 --> 00:14:21,660
what pace this allows me to do it here's

00:14:18,930 --> 00:14:25,410
a terribly slow connection I've seen

00:14:21,660 --> 00:14:27,450
worse but this is one it's a slow 3G 780

00:14:25,410 --> 00:14:29,130
down 330 up 200 milliseconds of latency

00:14:27,450 --> 00:14:32,940
which is a lot of latency let's see if

00:14:29,130 --> 00:14:34,230
things change nope they pretty much stay

00:14:32,940 --> 00:14:35,910
the same maybe there's a bit more

00:14:34,230 --> 00:14:38,490
separation with zero percent packet loss

00:14:35,910 --> 00:14:40,410
but certainly we see h1 stand out with

00:14:38,490 --> 00:14:43,020
two percent packet loss you see that

00:14:40,410 --> 00:14:44,610
little bump in the upper like in the

00:14:43,020 --> 00:14:46,530
beginning of all these scatter plots I

00:14:44,610 --> 00:14:48,089
thought about taking that out but what

00:14:46,530 --> 00:14:50,220
happened there was my server stop

00:14:48,089 --> 00:14:52,290
talking h2 so everything that looked

00:14:50,220 --> 00:14:54,570
like h2 was actually h1 and you can see

00:14:52,290 --> 00:14:56,490
that all the blue dots sort of commingle

00:14:54,570 --> 00:14:57,750
with the orange dots I thought that was

00:14:56,490 --> 00:15:00,270
an interesting thing to sort of show you

00:14:57,750 --> 00:15:03,030
can see what that that gap in h2 is

00:15:00,270 --> 00:15:04,680
because the server stop talking h2 I'm

00:15:03,030 --> 00:15:06,089
gonna switch gears instead of show you

00:15:04,680 --> 00:15:07,830
scatter plots I'm gonna show you CDF

00:15:06,089 --> 00:15:09,960
charts if you don't know what a CDF

00:15:07,830 --> 00:15:13,770
chart is it basically graphs percentile

00:15:09,960 --> 00:15:16,380
versus time metric so in this case the

00:15:13,770 --> 00:15:19,980
upper left-hand graph says at the 50th

00:15:16,380 --> 00:15:23,000
percentile h2 performed at roughly 2000

00:15:19,980 --> 00:15:25,890
milliseconds and h1 performed at roughly

00:15:23,000 --> 00:15:28,110
2200 milliseconds and in the bottom

00:15:25,890 --> 00:15:30,310
right graph you can see that there's

00:15:28,110 --> 00:15:31,990
separation between h1 and h2 and you

00:15:30,310 --> 00:15:34,540
direction basically as you look at CDF

00:15:31,990 --> 00:15:36,550
charts to the if you the more if your to

00:15:34,540 --> 00:15:37,930
the left you're performing better the

00:15:36,550 --> 00:15:39,910
perfect CDF chart would be a vertical

00:15:37,930 --> 00:15:40,960
line but there's always variation and

00:15:39,910 --> 00:15:42,840
the higher percentiles they're always

00:15:40,960 --> 00:15:44,920
slower so that's what you'll see curves

00:15:42,840 --> 00:15:48,339
let's put both browsers on the same

00:15:44,920 --> 00:15:51,700
graph this is what they look like blue

00:15:48,339 --> 00:15:54,610
and orange or Firefox h2 and h1 red and

00:15:51,700 --> 00:15:58,380
green are chrome h2 and h1 again that

00:15:54,610 --> 00:16:01,690
you see the effect of packet loss over

00:15:58,380 --> 00:16:03,790
the performance now what I'm looking at

00:16:01,690 --> 00:16:05,440
is a metric known as document complete

00:16:03,790 --> 00:16:10,050
time which is a common metric we

00:16:05,440 --> 00:16:12,640
generally take it as the metric that

00:16:10,050 --> 00:16:14,380
signifies how fast the pages that's not

00:16:12,640 --> 00:16:16,360
an entirely accurate thing I'll get to

00:16:14,380 --> 00:16:17,680
that in a second but to show this to you

00:16:16,360 --> 00:16:19,270
I wanted to show you everything in a

00:16:17,680 --> 00:16:21,640
scorecard so here's kind of what it look

00:16:19,270 --> 00:16:24,070
like so far I started looking at other

00:16:21,640 --> 00:16:26,170
metrics I saw a presentation that's a

00:16:24,070 --> 00:16:27,610
Dom content loaded is an entire as an

00:16:26,170 --> 00:16:29,410
important metric to ecommerce sites

00:16:27,610 --> 00:16:31,150
great presentation by the way at a

00:16:29,410 --> 00:16:33,040
velocity conference by Tammy Robertson

00:16:31,150 --> 00:16:35,380
Pat meaning check it out if you haven't

00:16:33,040 --> 00:16:39,250
already this is what Dom content loaded

00:16:35,380 --> 00:16:41,920
look like little bummed about the h1

00:16:39,250 --> 00:16:43,839
doing better with 0% packet loss but ok

00:16:41,920 --> 00:16:45,670
and I wanted to look at a metric called

00:16:43,839 --> 00:16:47,290
speed index which is a webpagetest

00:16:45,670 --> 00:16:50,800
metric it's an aggregate calculated

00:16:47,290 --> 00:16:52,900
metric that takes into effect takes into

00:16:50,800 --> 00:16:55,540
account the visual completion of the

00:16:52,900 --> 00:16:58,390
page as it builds so it's a sort of an

00:16:55,540 --> 00:17:01,450
aggregate metric and we see that h2 does

00:16:58,390 --> 00:17:03,730
better with 0% packet loss that h1 sort

00:17:01,450 --> 00:17:05,709
of does a little bit better with 2%

00:17:03,730 --> 00:17:07,390
packet loss why is this happening well

00:17:05,709 --> 00:17:10,240
it's happening because this analogy is

00:17:07,390 --> 00:17:12,579
actually inaccurate and misleading this

00:17:10,240 --> 00:17:14,679
isn't the way to compare HT to h1 this

00:17:12,579 --> 00:17:17,319
is actually a more accurate analogy

00:17:14,679 --> 00:17:19,270
because remember in h1 we communicate

00:17:17,319 --> 00:17:21,280
with a server over six concurrent

00:17:19,270 --> 00:17:22,750
connections look what happens to a TCP

00:17:21,280 --> 00:17:25,660
connection when it's subjected to packet

00:17:22,750 --> 00:17:27,189
loss here's a TCP connection with zero

00:17:25,660 --> 00:17:30,160
percent packet loss the way TCP works

00:17:27,189 --> 00:17:32,530
now what I'm gonna tell you is subject

00:17:30,160 --> 00:17:34,720
of like for your PhD dissertations and

00:17:32,530 --> 00:17:36,370
I'm going to give you TCP in 30 seconds

00:17:34,720 --> 00:17:39,429
so this isn't the whole story but this

00:17:36,370 --> 00:17:41,020
is the basics this is what TCP does when

00:17:39,429 --> 00:17:43,090
it's ramping up the connection the

00:17:41,020 --> 00:17:43,539
server sends more and more data over the

00:17:43,090 --> 00:17:45,580
wire

00:17:43,539 --> 00:17:47,590
until natural loss happens and then what

00:17:45,580 --> 00:17:49,840
happens is it slows down and it

00:17:47,590 --> 00:17:51,789
increases gradually until it gets to a

00:17:49,840 --> 00:17:54,279
point where there's less loss less or no

00:17:51,789 --> 00:17:57,279
loss with the goal in the long term of

00:17:54,279 --> 00:18:00,970
committing packets into the network at

00:17:57,279 --> 00:18:03,789
an amount that basically causes 0% 0 /

00:18:00,970 --> 00:18:05,559
ket loss so it's sort of converges over

00:18:03,789 --> 00:18:08,289
time here's what you see here you see a

00:18:05,559 --> 00:18:10,210
fast ramp up probably a loss event that

00:18:08,289 --> 00:18:12,129
slowed things down and some sort of

00:18:10,210 --> 00:18:13,869
normalization this is what happens the

00:18:12,129 --> 00:18:15,129
y-axis is something called Seawind which

00:18:13,869 --> 00:18:16,389
is the number of bytes that a server's

00:18:15,129 --> 00:18:18,489
things that can put on the network

00:18:16,389 --> 00:18:20,289
without packet loss and on the y axis on

00:18:18,489 --> 00:18:22,090
the x axis you see time look at what

00:18:20,289 --> 00:18:24,309
happens to this connection when there's

00:18:22,090 --> 00:18:26,979
packet loss that's a severe degradation

00:18:24,309 --> 00:18:29,590
and performance and imagine that what's

00:18:26,979 --> 00:18:31,239
happened now is you have every

00:18:29,590 --> 00:18:33,970
communication that happens in H -

00:18:31,239 --> 00:18:35,499
subjected to this one thing because

00:18:33,970 --> 00:18:37,059
everything happens over a single TCP

00:18:35,499 --> 00:18:38,950
connection so what we've done is

00:18:37,059 --> 00:18:41,769
essentially we've taken head of line

00:18:38,950 --> 00:18:44,200
blocking away from HTTP and actually put

00:18:41,769 --> 00:18:46,299
it in TCP we've exposed TCP header line

00:18:44,200 --> 00:18:47,739
blocking this is a known issue I'm not

00:18:46,299 --> 00:18:51,039
the first one to point it out it's

00:18:47,739 --> 00:18:54,639
actually mentioned in the RFC but still

00:18:51,039 --> 00:18:57,099
it was a risk reward that was worth

00:18:54,639 --> 00:19:03,369
taken to the authors if you look at that

00:18:57,099 --> 00:19:05,139
same 1% packet loss ratio inflicted on 6

00:19:03,369 --> 00:19:06,759
connections at any one time if I add up

00:19:05,139 --> 00:19:08,830
the number of bytes to the server

00:19:06,759 --> 00:19:10,269
consent across all six connections you

00:19:08,830 --> 00:19:11,889
see that's more than what a single

00:19:10,269 --> 00:19:15,820
connection can do and this is the

00:19:11,889 --> 00:19:17,139
primary reason h1 does better ok up

00:19:15,820 --> 00:19:20,200
until now everything I've done with this

00:19:17,139 --> 00:19:21,879
with a the fake page and simulated tests

00:19:20,200 --> 00:19:23,259
why don't we do this with real pages I

00:19:21,879 --> 00:19:25,779
wanted to see what this looked like with

00:19:23,259 --> 00:19:28,239
some real pages so I took 8 real pages

00:19:25,779 --> 00:19:29,769
from 8 real sites most of which I can't

00:19:28,239 --> 00:19:32,349
tell you about unfortunately but I'll

00:19:29,769 --> 00:19:34,629
give you some hints I tested 16

00:19:32,349 --> 00:19:38,289
different bandwidth profiles of

00:19:34,629 --> 00:19:39,519
different download and upload parameters

00:19:38,289 --> 00:19:41,470
a whole bunch of different latency

00:19:39,519 --> 00:19:44,289
parameters subjected all of them to the

00:19:41,470 --> 00:19:46,599
four different PLR profiles I test the

00:19:44,289 --> 00:19:47,769
firefox and chrome TLS only and

00:19:46,599 --> 00:19:48,999
collected all the metrics now one of the

00:19:47,769 --> 00:19:52,239
things to remember as I go through this

00:19:48,999 --> 00:19:55,929
is HTTP 1 was clear text or could be

00:19:52,239 --> 00:19:57,309
clear text an h2 is TLS all I tested

00:19:55,929 --> 00:19:59,649
here was the

00:19:57,309 --> 00:20:01,720
version of the h1 pages which are

00:19:59,649 --> 00:20:04,509
inherently slightly slower than the

00:20:01,720 --> 00:20:06,340
clear text versions so the versions of

00:20:04,509 --> 00:20:08,529
the pages so take that into account

00:20:06,340 --> 00:20:11,230
probably the clear text version of these

00:20:08,529 --> 00:20:13,509
pages is slightly faster than I want I'm

00:20:11,230 --> 00:20:15,190
going to show you but I didn't want to

00:20:13,509 --> 00:20:17,710
get into this should we go secure or not

00:20:15,190 --> 00:20:18,429
argument nice make everything secure and

00:20:17,710 --> 00:20:20,019
go from there

00:20:18,429 --> 00:20:21,970
and I ran each of these three to 400

00:20:20,019 --> 00:20:26,529
different times this adds up to about

00:20:21,970 --> 00:20:30,429
1.2 million test runs on webpage tests

00:20:26,529 --> 00:20:32,769
which I kept in a place to analyze this

00:20:30,429 --> 00:20:34,869
is a fork it looks a lot like the one I

00:20:32,769 --> 00:20:36,820
wanted to stab myself with repeatedly as

00:20:34,869 --> 00:20:38,740
I was going through 1.2 million data

00:20:36,820 --> 00:20:41,230
rows it was very difficult to see

00:20:38,740 --> 00:20:45,190
patterns develop I really wanted to come

00:20:41,230 --> 00:20:46,960
here and not myself and give you lessons

00:20:45,190 --> 00:20:50,860
about what the path those patterns are

00:20:46,960 --> 00:20:53,440
but I can't that's a bit of a spoiler so

00:20:50,860 --> 00:20:55,960
what I did is I divided all the pages

00:20:53,440 --> 00:20:58,720
into three different buckets one where

00:20:55,960 --> 00:21:01,749
most of the requests 75% or more moved

00:20:58,720 --> 00:21:03,730
from h1 to h2 one we're about half of

00:21:01,749 --> 00:21:07,720
the requests moved from h1 to h2 and one

00:21:03,730 --> 00:21:08,710
we're about 25% or lower so less assets

00:21:07,720 --> 00:21:10,629
moved from h1 to h2

00:21:08,710 --> 00:21:12,460
I considered it on two profiles a

00:21:10,629 --> 00:21:15,749
broadband one which was five Meg's down

00:21:12,460 --> 00:21:18,369
one Meg up with the four packet loss

00:21:15,749 --> 00:21:19,960
profiles and a slow 3G one like the one

00:21:18,369 --> 00:21:21,549
we already talked about and I focused on

00:21:19,960 --> 00:21:24,070
three metrics same three metrics that we

00:21:21,549 --> 00:21:25,659
talked about so site one is a page on

00:21:24,070 --> 00:21:26,740
the fastly website it's our customers

00:21:25,659 --> 00:21:28,600
page it's where we show off our

00:21:26,740 --> 00:21:30,909
customers it's got about a hundred and

00:21:28,600 --> 00:21:32,740
thirty or so requests about a hundred of

00:21:30,909 --> 00:21:33,999
them moved from h1 to h2 this is what

00:21:32,740 --> 00:21:35,710
the waterfall looks like before and

00:21:33,999 --> 00:21:38,320
after I'm gonna go through the CDF

00:21:35,710 --> 00:21:42,129
charts really really quick so brace

00:21:38,320 --> 00:21:45,070
yourselves look for blue h1 for firefox

00:21:42,129 --> 00:21:47,590
and read as sorry blue as h2 for firefox

00:21:45,070 --> 00:21:49,960
and red as h2 for chrome orange and

00:21:47,590 --> 00:21:51,700
green as h1 for firefox and chrome this

00:21:49,960 --> 00:21:53,409
is doc complete broadband I'm just gonna

00:21:51,700 --> 00:21:56,200
go through real quick I have a scorecard

00:21:53,409 --> 00:22:01,480
at the end Dom content loaded speed

00:21:56,200 --> 00:22:04,389
index broadband doc complete slow 3G Dom

00:22:01,480 --> 00:22:06,629
content loaded in this case you see h2

00:22:04,389 --> 00:22:09,940
actually did ok with 2% Pecola's and

00:22:06,629 --> 00:22:12,739
speed index here's a scorecard

00:22:09,940 --> 00:22:15,320
okay again not really stoked on the h1

00:22:12,739 --> 00:22:17,149
coming ahead with 0% packet loss but

00:22:15,320 --> 00:22:21,559
certainly we see packet loss have an

00:22:17,149 --> 00:22:24,619
effect on a h2 and performance with 2%

00:22:21,559 --> 00:22:26,869
packet loss your site too is a travel

00:22:24,619 --> 00:22:29,029
site it's about a hundred requests half

00:22:26,869 --> 00:22:30,739
of them are moving from h1 to h2 but

00:22:29,029 --> 00:22:32,779
notice that it's about 75% of the

00:22:30,739 --> 00:22:33,739
payload this is what the waterfall looks

00:22:32,779 --> 00:22:35,929
like before and after

00:22:33,739 --> 00:22:37,369
because I'm not cruel I'm not gonna show

00:22:35,929 --> 00:22:40,039
you all the CDF charts anymore I'm just

00:22:37,369 --> 00:22:42,230
gonna show you the scorecard here's one

00:22:40,039 --> 00:22:44,509
the dot dot dot complete looks like h2

00:22:42,230 --> 00:22:47,239
fares pretty well but each one does

00:22:44,509 --> 00:22:50,539
better with packet loss same thing with

00:22:47,239 --> 00:22:53,629
Dom content loaded slightly different

00:22:50,539 --> 00:22:56,299
story with speed index site 3 had many

00:22:53,629 --> 00:22:59,059
more requests it's a media site so lots

00:22:56,299 --> 00:23:01,190
of third-party content only about 25% of

00:22:59,059 --> 00:23:03,679
the assets moved from h1 to h2 but

00:23:01,190 --> 00:23:05,989
notice that it's more than half of the

00:23:03,679 --> 00:23:07,730
payload this is what the waterfalls look

00:23:05,989 --> 00:23:09,230
like you can barely tell which request

00:23:07,730 --> 00:23:10,309
went from h1 to h2 because there's so

00:23:09,230 --> 00:23:12,289
much on the page

00:23:10,309 --> 00:23:15,830
this is what the scorecard is there's

00:23:12,289 --> 00:23:17,889
dock complete here's Dom content loaded

00:23:15,830 --> 00:23:21,230
hey that's all green that's nice and

00:23:17,889 --> 00:23:23,840
speed it next not so good let's put all

00:23:21,230 --> 00:23:30,499
of them on a thing here's a big grade

00:23:23,840 --> 00:23:32,239
sheet broadband only just slow 3G only

00:23:30,499 --> 00:23:36,379
let's just put that up there and take a

00:23:32,239 --> 00:23:38,659
moment certainly we see that packet loss

00:23:36,379 --> 00:23:41,629
has an effect on performance but again

00:23:38,659 --> 00:23:45,679
not really stoked on those red squares

00:23:41,629 --> 00:23:47,779
with zero percent packet loss certainly

00:23:45,679 --> 00:23:49,429
this is raising more questions than

00:23:47,779 --> 00:23:50,840
answering them

00:23:49,429 --> 00:23:53,149
this doesn't I mean there's still more

00:23:50,840 --> 00:23:54,919
green on this then then red that doesn't

00:23:53,149 --> 00:23:58,249
mean h2 is in performance but certainly

00:23:54,919 --> 00:24:04,039
it means that it's not a magic bullet if

00:23:58,249 --> 00:24:07,970
you will what does this all mean I have

00:24:04,039 --> 00:24:10,159
no idea basically it means that we

00:24:07,970 --> 00:24:12,169
shouldn't be sure about this

00:24:10,159 --> 00:24:14,779
certainly packet loss is having an

00:24:12,169 --> 00:24:16,519
effect and it looks like metrics later

00:24:14,779 --> 00:24:17,840
in the page are affected more adversely

00:24:16,519 --> 00:24:19,999
I just although I'd really want to be

00:24:17,840 --> 00:24:21,830
careful with that because in the life of

00:24:19,999 --> 00:24:23,570
time of a TCP connection a single page

00:24:21,830 --> 00:24:24,860
is so short

00:24:23,570 --> 00:24:26,720
what I would have loved to see and I

00:24:24,860 --> 00:24:29,930
can't gather it without more work which

00:24:26,720 --> 00:24:32,660
I will do is what happens to three four

00:24:29,930 --> 00:24:34,460
or five pages deep into the navigation

00:24:32,660 --> 00:24:35,660
that would be interesting because TCP

00:24:34,460 --> 00:24:38,840
has had a chance to sort of adjust

00:24:35,660 --> 00:24:40,700
itself we saw lots of exceptions we saw

00:24:38,840 --> 00:24:42,800
places where h2 holds up with packet

00:24:40,700 --> 00:24:45,440
loss we certainly saw places where h1

00:24:42,800 --> 00:24:46,730
was better without packet loss and we

00:24:45,440 --> 00:24:48,890
definitely saw the firefox and chrome

00:24:46,730 --> 00:24:50,660
are not behaving the same that is not a

00:24:48,890 --> 00:24:53,900
thing I wanted to begin to Gus probably

00:24:50,660 --> 00:24:54,830
another two three hour talk and like I

00:24:53,900 --> 00:24:56,360
said we probably have more questions

00:24:54,830 --> 00:24:59,420
than answers

00:24:56,360 --> 00:25:01,640
but this is data that we probably should

00:24:59,420 --> 00:25:03,260
take into account so the natural next

00:25:01,640 --> 00:25:05,210
question is what does Pilar look like in

00:25:03,260 --> 00:25:06,590
the real world okay PLR seems to affect

00:25:05,210 --> 00:25:08,000
performance what's it look like in the

00:25:06,590 --> 00:25:11,000
real world it's actually very difficult

00:25:08,000 --> 00:25:11,630
to measure but we try at fastly at

00:25:11,000 --> 00:25:13,460
fastly

00:25:11,630 --> 00:25:15,800
we have about two and a half to three

00:25:13,460 --> 00:25:17,450
and a half million requests per second

00:25:15,800 --> 00:25:21,050
going through our network at any given

00:25:17,450 --> 00:25:22,520
time we sampled those two two to sort of

00:25:21,050 --> 00:25:23,990
figure out what network profiles look

00:25:22,520 --> 00:25:25,780
like here's what it looks like in the US

00:25:23,990 --> 00:25:27,830
this is graphed

00:25:25,780 --> 00:25:30,170
here's let me narrate this through this

00:25:27,830 --> 00:25:32,720
for you I'm first of all the x-axis is

00:25:30,170 --> 00:25:36,950
round-trip time and this is the 70th

00:25:32,720 --> 00:25:39,020
percentile in the US so 70% or more 70%

00:25:36,950 --> 00:25:40,940
of the people that went through our

00:25:39,020 --> 00:25:43,310
caches in the US had 60 milliseconds

00:25:40,940 --> 00:25:45,830
around trip time or lower what we're

00:25:43,310 --> 00:25:50,120
measuring here is the number of requests

00:25:45,830 --> 00:25:53,120
that were that noticed packet loss the

00:25:50,120 --> 00:25:55,910
orange band is 0% packet loss the blue

00:25:53,120 --> 00:25:57,890
band is request that saw 0 to 1.5%

00:25:55,910 --> 00:25:59,720
packet loss and the green band is

00:25:57,890 --> 00:26:01,610
requests that are greater than 1.5%

00:25:59,720 --> 00:26:04,640
packet loss what I've done here is I've

00:26:01,610 --> 00:26:07,400
only limited it to requests that are 100

00:26:04,640 --> 00:26:08,480
bytes sorry 100 packets or more so

00:26:07,400 --> 00:26:10,640
enough packets on the network to

00:26:08,480 --> 00:26:12,800
actually measure packet loss and this is

00:26:10,640 --> 00:26:16,160
mostly h1 this is just what packet loss

00:26:12,800 --> 00:26:17,440
profiles look like so that's what this

00:26:16,160 --> 00:26:20,570
is this is what looks like in Germany

00:26:17,440 --> 00:26:23,150
kind of the same basically what we're

00:26:20,570 --> 00:26:25,130
saying here is roughly 20% of the

00:26:23,150 --> 00:26:27,260
requests are experiencing some level of

00:26:25,130 --> 00:26:30,620
packet loss it could be worse that

00:26:27,260 --> 00:26:32,510
orange band is very broad and big that's

00:26:30,620 --> 00:26:33,710
great but there is definitely packet

00:26:32,510 --> 00:26:36,290
loss in the world I am NOT the first

00:26:33,710 --> 00:26:37,130
person to talk about h2s performance

00:26:36,290 --> 00:26:39,110
issues not

00:26:37,130 --> 00:26:41,360
a ch2 not being a performance panacea or

00:26:39,110 --> 00:26:42,800
the effective packet loss here's a bunch

00:26:41,360 --> 00:26:43,910
of reading I'll make sure these slides

00:26:42,800 --> 00:26:46,690
are available to you afterwards so you

00:26:43,910 --> 00:26:49,790
can follow up now what do we do well

00:26:46,690 --> 00:26:51,680
first of all some words of caution I'm

00:26:49,790 --> 00:26:53,180
not going to stand up here and I've done

00:26:51,680 --> 00:26:55,310
this talk now three times in the last

00:26:53,180 --> 00:26:57,680
five days I had none of those places did

00:26:55,310 --> 00:26:59,660
I stand up and make grand conclusions

00:26:57,680 --> 00:27:02,480
not gonna do any of that because I don't

00:26:59,660 --> 00:27:04,070
think that this data gives us any huge

00:27:02,480 --> 00:27:06,200
conclusions the only thing we can

00:27:04,070 --> 00:27:09,170
conclude is that packet loss seems to

00:27:06,200 --> 00:27:12,080
matter and that h2 isn't always faster

00:27:09,170 --> 00:27:14,030
h2 isn't this magic bullet that many of

00:27:12,080 --> 00:27:15,770
us maybe thought it was going to be now

00:27:14,030 --> 00:27:18,110
what I did is all simulated it was

00:27:15,770 --> 00:27:20,690
simulated packet loss packet loss in the

00:27:18,110 --> 00:27:22,820
real old world happens very differently

00:27:20,690 --> 00:27:24,440
than injected simulated packet loss

00:27:22,820 --> 00:27:26,120
packet loss happens because router

00:27:24,440 --> 00:27:27,560
buffers bloat packet loss happens

00:27:26,120 --> 00:27:28,880
because you turn on your microwave at

00:27:27,560 --> 00:27:31,160
home and your Wi-Fi router decides to

00:27:28,880 --> 00:27:32,510
drop a couple packets that's very

00:27:31,160 --> 00:27:34,820
different than the sort of things that I

00:27:32,510 --> 00:27:36,980
injected this was sort of a first step

00:27:34,820 --> 00:27:40,250
we need real world data and your mileage

00:27:36,980 --> 00:27:41,660
will vary when you do this if we decide

00:27:40,250 --> 00:27:43,850
to do this on your own so the biggest

00:27:41,660 --> 00:27:47,300
lesson from all of this is don't listen

00:27:43,850 --> 00:27:49,820
to anyone and I mean anyone don't listen

00:27:47,300 --> 00:27:51,710
to anyone do this for yourselves and

00:27:49,820 --> 00:27:52,760
that's if you're interested in this this

00:27:51,710 --> 00:27:55,220
is something that you want to do for

00:27:52,760 --> 00:27:57,950
yourself Patrick from the Financial

00:27:55,220 --> 00:27:59,930
Times did it Patrick Amon had this

00:27:57,950 --> 00:28:02,600
presentation he gave a little while ago

00:27:59,930 --> 00:28:04,760
where they tested h2 versus h1 and

00:28:02,600 --> 00:28:08,150
you'll see that in his case the dot dot

00:28:04,760 --> 00:28:12,350
complete time for his users showed

00:28:08,150 --> 00:28:14,990
benefit at higher latencies and did not

00:28:12,350 --> 00:28:16,370
show that much benefit with h2 at lower

00:28:14,990 --> 00:28:18,020
latencies now there's two things that

00:28:16,370 --> 00:28:19,880
are interesting about this one we have

00:28:18,020 --> 00:28:22,160
no idea what percent of the users fall

00:28:19,880 --> 00:28:24,350
into each of the bands that's a that's

00:28:22,160 --> 00:28:25,640
uh that's not clear from this it's clear

00:28:24,350 --> 00:28:26,990
from the next graph I'll show you and

00:28:25,640 --> 00:28:29,930
the other thing that's interesting is

00:28:26,990 --> 00:28:32,270
everybody wants CDNs to do h2 and CDNs

00:28:29,930 --> 00:28:34,730
basically live in the 100 millisecond or

00:28:32,270 --> 00:28:37,070
less band and it's interesting to me

00:28:34,730 --> 00:28:39,590
that there was no benefit there so this

00:28:37,070 --> 00:28:41,030
is just an interesting data point he

00:28:39,590 --> 00:28:43,400
goes on to say that it seemed to help

00:28:41,030 --> 00:28:44,690
his 95th percentile which is in line

00:28:43,400 --> 00:28:46,640
with what a lot of the pundits are

00:28:44,690 --> 00:28:47,840
saying that if we're gonna see benefits

00:28:46,640 --> 00:28:49,910
we're gonna generally see them in the

00:28:47,840 --> 00:28:50,720
95th percentile but the 95th percentile

00:28:49,910 --> 00:28:52,669
for Patrick

00:28:50,720 --> 00:28:55,340
site is gonna be different than the 95th

00:28:52,669 --> 00:28:57,289
percentile for your sites and this is

00:28:55,340 --> 00:29:00,080
why it's probably a good idea for you to

00:28:57,289 --> 00:29:01,730
do this yourself so instead of digging

00:29:00,080 --> 00:29:03,620
through 1.2 million data points to

00:29:01,730 --> 00:29:07,130
standing up here and going through them

00:29:03,620 --> 00:29:09,409
and killing you with it I decided a gift

00:29:07,130 --> 00:29:11,990
was better so I wrote the script now I

00:29:09,409 --> 00:29:14,150
can't write code so when I say I wrote

00:29:11,990 --> 00:29:15,919
the script it means I took up crayon and

00:29:14,150 --> 00:29:18,230
basically wrote on some napkins and

00:29:15,919 --> 00:29:19,909
somebody named Mark Teodoro who is great

00:29:18,230 --> 00:29:22,490
and I have the fortune of working with

00:29:19,909 --> 00:29:24,890
took it up and clean it up and here's a

00:29:22,490 --> 00:29:26,780
script it uses webpagetest whether your

00:29:24,890 --> 00:29:28,340
private version or the public one you

00:29:26,780 --> 00:29:30,320
put in your bandwidth profile packet

00:29:28,340 --> 00:29:32,450
loss put in your site a test h1 versus

00:29:30,320 --> 00:29:33,980
h2 and it spits out a PDF that sort of

00:29:32,450 --> 00:29:36,080
gives you a scatterplot of what's going

00:29:33,980 --> 00:29:37,940
on sort of what I have but this should

00:29:36,080 --> 00:29:39,679
be just the beginning real-world data is

00:29:37,940 --> 00:29:42,409
much much more valuable did you know

00:29:39,679 --> 00:29:45,409
about this this is chrome dot load times

00:29:42,409 --> 00:29:47,750
in Chrome tells you what the connection

00:29:45,409 --> 00:29:49,760
was if you were speaking h2 or not if

00:29:47,750 --> 00:29:52,250
you use rum and I really hope you are

00:29:49,760 --> 00:29:54,110
you can actually measure whether using

00:29:52,250 --> 00:29:56,059
you can use your measurements and then

00:29:54,110 --> 00:29:57,590
Mark things as whether they were h1 or

00:29:56,059 --> 00:29:59,330
h2 and come up with some of these

00:29:57,590 --> 00:30:00,820
measurements for yourself this is

00:29:59,330 --> 00:30:04,190
probably a good time to talk about quick

00:30:00,820 --> 00:30:07,070
quick is a new protocol you've probably

00:30:04,190 --> 00:30:08,030
heard of it in the context of Google

00:30:07,070 --> 00:30:10,130
because they're the only ones that are

00:30:08,030 --> 00:30:12,830
using it they came up with it it's a

00:30:10,130 --> 00:30:14,030
udp-based vertical and it's actually on

00:30:12,830 --> 00:30:16,940
the standards track now there is a

00:30:14,030 --> 00:30:19,340
proposed spec for it what it does is it

00:30:16,940 --> 00:30:21,799
takes the transport which we've always

00:30:19,340 --> 00:30:23,750
had over TCP for HTTP and makes it UDP

00:30:21,799 --> 00:30:25,580
and one of the biggest motivations for

00:30:23,750 --> 00:30:27,350
it was to take congestion avoidance

00:30:25,580 --> 00:30:30,260
which is the mechanism that controls how

00:30:27,350 --> 00:30:32,270
TCP reacts to packet loss and moves it

00:30:30,260 --> 00:30:34,130
to the user space so they can code it

00:30:32,270 --> 00:30:36,230
and iterate on it quickly that was one

00:30:34,130 --> 00:30:38,179
of the biggest motivations for it

00:30:36,230 --> 00:30:40,010
quic is a protocol that we're all super

00:30:38,179 --> 00:30:41,539
excited about and I think it's gonna

00:30:40,010 --> 00:30:44,990
address some of the issues that we've

00:30:41,539 --> 00:30:46,549
seen ok how are we doing so far

00:30:44,990 --> 00:30:48,710
is it are we good am i bumming you out

00:30:46,549 --> 00:30:49,100
you okay Jason is this okay all right

00:30:48,710 --> 00:30:51,080
that's all right

00:30:49,100 --> 00:30:52,900
all right let's keep going let's talk

00:30:51,080 --> 00:30:55,400
about we have half an hour that's great

00:30:52,900 --> 00:30:58,190
let's talk about server push probably

00:30:55,400 --> 00:30:59,480
the most talked about feature did I say

00:30:58,190 --> 00:31:01,460
that about performance probably the

00:30:59,480 --> 00:31:04,039
other most talked about feature I server

00:31:01,460 --> 00:31:04,519
push the idea of server push is we're

00:31:04,039 --> 00:31:06,789
going to

00:31:04,519 --> 00:31:09,379
push things from a server to a browser

00:31:06,789 --> 00:31:11,330
before the browser requests them

00:31:09,379 --> 00:31:14,269
actually before the browser even knows

00:31:11,330 --> 00:31:16,789
it wants them this is what server pushes

00:31:14,269 --> 00:31:19,459
it's a hop by hop property which means

00:31:16,789 --> 00:31:21,109
middle boxes like CD ends or caches or

00:31:19,459 --> 00:31:22,759
anything in the middle can act

00:31:21,109 --> 00:31:25,429
independently from themselves to a

00:31:22,759 --> 00:31:27,739
client rather than themselves to server

00:31:25,429 --> 00:31:29,320
behind them whether you support push or

00:31:27,739 --> 00:31:31,219
not as negotiator in a settings frame

00:31:29,320 --> 00:31:33,679
remove talked about a settings for him

00:31:31,219 --> 00:31:34,820
actually pushes on by default so the

00:31:33,679 --> 00:31:36,979
only time you're going to send a

00:31:34,820 --> 00:31:39,200
settings and a parameter in the settings

00:31:36,979 --> 00:31:40,519
form that says anything my push is when

00:31:39,200 --> 00:31:42,559
you don't support it so here's a

00:31:40,519 --> 00:31:44,179
settings frame saying it doesn't support

00:31:42,559 --> 00:31:46,039
push that my client is in supporting

00:31:44,179 --> 00:31:48,079
push everything in push happens with a

00:31:46,039 --> 00:31:50,450
special frame called a push promise

00:31:48,079 --> 00:31:51,829
here's how it works the client sends a

00:31:50,450 --> 00:31:55,009
request for let's say index dot HTML

00:31:51,829 --> 00:31:56,809
that index.html is going to have a CSS

00:31:55,009 --> 00:31:59,869
file in it so what the server does is

00:31:56,809 --> 00:32:01,489
before sending the HTML it sends a push

00:31:59,869 --> 00:32:04,070
promise frame this push promise frame

00:32:01,489 --> 00:32:05,959
says I'm about to push you the CSS file

00:32:04,070 --> 00:32:07,489
there's two things that are important in

00:32:05,959 --> 00:32:10,279
this prompt to push promise frame one is

00:32:07,489 --> 00:32:11,779
a promise stream ID so it's to put the

00:32:10,279 --> 00:32:13,369
stream ID that the pushing is gonna

00:32:11,779 --> 00:32:14,479
happen over that's going to be an even

00:32:13,369 --> 00:32:18,079
number because it's gonna be a server

00:32:14,479 --> 00:32:20,329
initiated stream ID the second is the

00:32:18,079 --> 00:32:22,129
would be request headers that the client

00:32:20,329 --> 00:32:24,589
would send if it was to naturally

00:32:22,129 --> 00:32:26,899
request this asset itself so it's

00:32:24,589 --> 00:32:28,309
actually sending request headers in a in

00:32:26,899 --> 00:32:31,820
a frame from the server to the client

00:32:28,309 --> 00:32:34,279
the only rule is the push promise has to

00:32:31,820 --> 00:32:36,019
come before the thing that references it

00:32:34,279 --> 00:32:38,599
the reference is the thing that we're

00:32:36,019 --> 00:32:40,489
pushing so if this is CSS the only rule

00:32:38,599 --> 00:32:42,950
is the push promise frame needs to come

00:32:40,489 --> 00:32:45,259
before the HTML header or data frames

00:32:42,950 --> 00:32:47,059
that reference that thing that's being

00:32:45,259 --> 00:32:49,159
pushed so in this case you see the push

00:32:47,059 --> 00:32:51,200
promised frame ago then I start sending

00:32:49,159 --> 00:32:52,879
the client some of that HTML with the

00:32:51,200 --> 00:32:55,579
headers and data and then I start

00:32:52,879 --> 00:32:57,529
pushing the CSS file again with headers

00:32:55,579 --> 00:32:59,929
frames and data frames and I can

00:32:57,529 --> 00:33:02,269
interleave the CSS with the HTML because

00:32:59,929 --> 00:33:05,289
this is a mechanism that HTTP 2 allows

00:33:02,269 --> 00:33:07,969
me to do you can see it in dev tools

00:33:05,289 --> 00:33:10,099
here's what it looks like and actually

00:33:07,969 --> 00:33:11,839
if you hover over those assets you can

00:33:10,099 --> 00:33:14,029
see that those four first four things

00:33:11,839 --> 00:33:16,849
check it out those first four assets are

00:33:14,029 --> 00:33:18,309
pushed and you can see that with dev

00:33:16,849 --> 00:33:21,770
tool so the dev tools tells you that

00:33:18,309 --> 00:33:24,110
there's two big questions with push 1 we

00:33:21,770 --> 00:33:25,700
have no idea what to push this is

00:33:24,110 --> 00:33:27,410
outside the scope of the protocol the

00:33:25,700 --> 00:33:29,420
protocol just created a mechanism for it

00:33:27,410 --> 00:33:30,590
so it's up to you and up to us and our

00:33:29,420 --> 00:33:32,360
applications to figure out what the

00:33:30,590 --> 00:33:35,450
right thing to push is and second and

00:33:32,360 --> 00:33:38,809
bigger is it turns out that browsers

00:33:35,450 --> 00:33:41,600
don't really work well with push their

00:33:38,809 --> 00:33:43,520
browser cache that is in fact the push

00:33:41,600 --> 00:33:45,140
cache and the object cache are two

00:33:43,520 --> 00:33:47,570
separate things and they don't know

00:33:45,140 --> 00:33:49,790
about each other so the protocol creates

00:33:47,570 --> 00:33:52,220
a mechanism has a mechanism with a frame

00:33:49,790 --> 00:33:54,170
called a reset reset stream that lets

00:33:52,220 --> 00:33:55,280
you reject a push so if you're trying to

00:33:54,170 --> 00:33:57,200
push me if I'm a client or the server

00:33:55,280 --> 00:33:58,220
you trying to push me something and I

00:33:57,200 --> 00:34:00,370
don't want it because I have it in my

00:33:58,220 --> 00:34:03,170
cache I can send you a reset the stream

00:34:00,370 --> 00:34:05,300
two things one I've never seen a recess

00:34:03,170 --> 00:34:07,520
stream sent because browsers kind of

00:34:05,300 --> 00:34:09,560
don't know what's in their cache or that

00:34:07,520 --> 00:34:12,530
part that part piece hasn't been wired

00:34:09,560 --> 00:34:14,899
in yet and two even if I did send you a

00:34:12,530 --> 00:34:16,369
reset stream it's already too late you

00:34:14,899 --> 00:34:19,610
send me you've sent me this thing is

00:34:16,369 --> 00:34:21,560
just gonna Wow you sent me a push push

00:34:19,610 --> 00:34:24,260
promise and you probably started pushing

00:34:21,560 --> 00:34:25,970
me the content by the time I rejected

00:34:24,260 --> 00:34:27,770
there's an entire round trip that's

00:34:25,970 --> 00:34:29,659
happened so a whole bunch of stuff has

00:34:27,770 --> 00:34:32,240
shown up on the wire and was being

00:34:29,659 --> 00:34:34,429
pushed to me so even if the browser was

00:34:32,240 --> 00:34:36,800
rejecting it the mechanism is sort of

00:34:34,429 --> 00:34:38,899
flawed look what happens here's a

00:34:36,800 --> 00:34:41,869
waterfall without push this is my cold

00:34:38,899 --> 00:34:43,669
cash request I grab a page the first

00:34:41,869 --> 00:34:45,770
floor requests or CSS files everything

00:34:43,669 --> 00:34:47,389
is an image I'm a good performance

00:34:45,770 --> 00:34:48,710
citizen so I put good cache control

00:34:47,389 --> 00:34:51,109
headers on this and then I go back to

00:34:48,710 --> 00:34:53,210
the page with a repeat view nothing

00:34:51,109 --> 00:34:54,919
happens except the HTML that I chose not

00:34:53,210 --> 00:34:56,659
to cash in this case that's great this

00:34:54,919 --> 00:34:58,820
is the way we expect our waterfalls look

00:34:56,659 --> 00:35:02,240
what happens with push here's the

00:34:58,820 --> 00:35:04,130
waterfall with push I took this for CSS

00:35:02,240 --> 00:35:06,170
files and push them that's the for first

00:35:04,130 --> 00:35:08,810
sport request you see there and then I

00:35:06,170 --> 00:35:11,570
do repeat view and guess what they get

00:35:08,810 --> 00:35:13,640
pushed again this is bad and what's

00:35:11,570 --> 00:35:15,470
happened is even if the browser ends up

00:35:13,640 --> 00:35:17,840
using the CSS files that was in this

00:35:15,470 --> 00:35:20,180
cache I've now put more content on the

00:35:17,840 --> 00:35:23,119
wire and this is not good for bandwidth

00:35:20,180 --> 00:35:24,380
usage so let's put that aside for a

00:35:23,119 --> 00:35:27,619
second let's figure out

00:35:24,380 --> 00:35:30,290
let's take into let's take let's

00:35:27,619 --> 00:35:31,220
consider a situation where you know what

00:35:30,290 --> 00:35:33,589
to push

00:35:31,220 --> 00:35:35,390
there's a few use cases that we've come

00:35:33,589 --> 00:35:38,690
up with the world has come up with four

00:35:35,390 --> 00:35:40,339
server push first is as a replacement

00:35:38,690 --> 00:35:42,230
for inlining if you've ever inline

00:35:40,339 --> 00:35:44,089
before you take CSS and JavaScript sort

00:35:42,230 --> 00:35:45,829
of put it in your HTML inlining broke

00:35:44,089 --> 00:35:48,680
caching because you couldn't cache those

00:35:45,829 --> 00:35:50,060
CSS and JavaScript independently now you

00:35:48,680 --> 00:35:51,410
can push them and because they're

00:35:50,060 --> 00:35:54,290
independent objects you can cache them

00:35:51,410 --> 00:35:55,550
those pushed the push content can have

00:35:54,290 --> 00:35:59,829
cache control headers then go into the

00:35:55,550 --> 00:36:03,500
cache that's one the second thing is

00:35:59,829 --> 00:36:06,470
pushing content relevant and essential

00:36:03,500 --> 00:36:08,390
to this navigation the page I'm on this

00:36:06,470 --> 00:36:09,200
is very similar to link rel preload if

00:36:08,390 --> 00:36:11,119
you're familiar with this mechanism

00:36:09,200 --> 00:36:13,250
which basically invokes the browser's

00:36:11,119 --> 00:36:15,829
preloader so the browser starts fetching

00:36:13,250 --> 00:36:17,359
those things before it parses the HTML

00:36:15,829 --> 00:36:19,760
and get to them this saves you one

00:36:17,359 --> 00:36:22,490
round-trip time look what happens here's

00:36:19,760 --> 00:36:24,530
the CSS files pushed vs. not pushed so

00:36:22,490 --> 00:36:27,140
if I push them I basically save myself

00:36:24,530 --> 00:36:29,930
one round-trip time why is it only one

00:36:27,140 --> 00:36:31,520
round-trip time because a ch2 and h2

00:36:29,930 --> 00:36:34,880
lets me do a bunch of things at once

00:36:31,520 --> 00:36:36,560
so if h to parse the page and saw parse

00:36:34,880 --> 00:36:38,480
the headers parse the page and saw that

00:36:36,560 --> 00:36:40,130
it needed at CSS it could send all those

00:36:38,480 --> 00:36:41,660
requests at once that's a single

00:36:40,130 --> 00:36:44,270
roundtrip that's what H 2 gives us

00:36:41,660 --> 00:36:46,240
concurrency so if you were to push

00:36:44,270 --> 00:36:48,349
things that are essential for this

00:36:46,240 --> 00:36:50,420
navigation you're essentially serving

00:36:48,349 --> 00:36:50,960
one round-trip time that's okay that's

00:36:50,420 --> 00:36:52,790
great

00:36:50,960 --> 00:36:54,890
we like to save as many Artie T's as

00:36:52,790 --> 00:36:57,440
possible but it isn't a huge win

00:36:54,890 --> 00:36:59,869
necessarily you could have a big win if

00:36:57,440 --> 00:37:02,119
you did things during what we call

00:36:59,869 --> 00:37:04,760
server think time and this is the amount

00:37:02,119 --> 00:37:06,859
of time it takes or a browser to get the

00:37:04,760 --> 00:37:08,300
HTML from the server that server thing

00:37:06,859 --> 00:37:08,900
time could be anything from a long

00:37:08,300 --> 00:37:10,339
distance

00:37:08,900 --> 00:37:14,210
like if you're fetching something over

00:37:10,339 --> 00:37:15,800
you know long network distances or the

00:37:14,210 --> 00:37:17,660
server more likely the server taking

00:37:15,800 --> 00:37:19,490
time to generate a page I have an

00:37:17,660 --> 00:37:22,160
exaggerated waterfall that shows you

00:37:19,490 --> 00:37:25,220
this here's an HTML that took three

00:37:22,160 --> 00:37:27,530
seconds to come back to the client and

00:37:25,220 --> 00:37:29,359
during that time nothing would normally

00:37:27,530 --> 00:37:31,310
happen so what I can do is I can use

00:37:29,359 --> 00:37:33,050
that time and shove those things down

00:37:31,310 --> 00:37:34,819
the pipe to the browser and let the

00:37:33,050 --> 00:37:36,950
browser cache them so once the HTML

00:37:34,819 --> 00:37:38,210
arrives the rendering will be much much

00:37:36,950 --> 00:37:40,609
quicker because all those things are in

00:37:38,210 --> 00:37:42,650
the browser cache now this is

00:37:40,609 --> 00:37:45,020
exaggerated and if you ever talk to me

00:37:42,650 --> 00:37:47,330
about HTML I'm gonna do every

00:37:45,020 --> 00:37:49,850
my power to get you to cash that HTML

00:37:47,330 --> 00:37:53,030
your CDN and never have to incur this

00:37:49,850 --> 00:37:54,830
sort of big greenness in waterfalls but

00:37:53,030 --> 00:37:57,110
there are times that HTML content is

00:37:54,830 --> 00:37:59,600
absolutely uncatchable and those times

00:37:57,110 --> 00:38:01,550
push can give us a good mechanism your

00:37:59,600 --> 00:38:02,900
vise has a good blog post about this he

00:38:01,550 --> 00:38:03,410
goes into this much more in much more

00:38:02,900 --> 00:38:05,000
detail

00:38:03,410 --> 00:38:06,530
that's the blog post this isn't a

00:38:05,000 --> 00:38:08,240
trivial thing to do because it's an

00:38:06,530 --> 00:38:10,160
asynchronous operation if you're doing

00:38:08,240 --> 00:38:11,720
this in a CDN something has to go to

00:38:10,160 --> 00:38:13,670
origin while something is you know

00:38:11,720 --> 00:38:16,250
simultaneously going to the client so

00:38:13,670 --> 00:38:18,680
talk to your CDN to see if this is

00:38:16,250 --> 00:38:20,390
doable or not a lot of people thought

00:38:18,680 --> 00:38:22,580
push would be great for next navigation

00:38:20,390 --> 00:38:24,380
the next page it can be used for the

00:38:22,580 --> 00:38:26,030
next page but we already have a bunch of

00:38:24,380 --> 00:38:28,070
mechanisms in place in the form of

00:38:26,030 --> 00:38:29,660
resource hints that allow us to do this

00:38:28,070 --> 00:38:32,690
if you've ever heard of link rel

00:38:29,660 --> 00:38:34,790
prefetch and link rel pre-render those

00:38:32,690 --> 00:38:36,380
are ways where as you're reading a page

00:38:34,790 --> 00:38:37,640
for example the browser can be invoked

00:38:36,380 --> 00:38:39,500
and go fetch things that you're gonna

00:38:37,640 --> 00:38:41,090
need in future navigation those

00:38:39,500 --> 00:38:43,940
mechanisms are kind of in place already

00:38:41,090 --> 00:38:45,140
you can use push but we already have

00:38:43,940 --> 00:38:46,700
mechanisms that are pretty much good

00:38:45,140 --> 00:38:48,830
enough we still have two big questions

00:38:46,700 --> 00:38:51,050
what do we push we still don't know

00:38:48,830 --> 00:38:53,660
Google published a paper that paper is a

00:38:51,050 --> 00:38:54,860
good paper that sort of did an analysis

00:38:53,660 --> 00:38:58,220
of this they have some rules of thumb

00:38:54,860 --> 00:39:00,620
about what to push and how often to push

00:38:58,220 --> 00:39:02,810
them it's a good paper to read if you're

00:39:00,620 --> 00:39:04,310
interested in server push and we still

00:39:02,810 --> 00:39:05,960
don't have the answer to the question of

00:39:04,310 --> 00:39:07,880
what do we do if the thing is in the

00:39:05,960 --> 00:39:09,140
browser cache already there's two ways

00:39:07,880 --> 00:39:11,810
that I know of that this is being

00:39:09,140 --> 00:39:14,300
addressed none of which are sort of

00:39:11,810 --> 00:39:15,500
fully baked one h2o the server that I

00:39:14,300 --> 00:39:18,080
talked about earlier has a mechanism

00:39:15,500 --> 00:39:20,000
called Casper where basically there's a

00:39:18,080 --> 00:39:21,230
cookie generated it's a through a bloom

00:39:20,000 --> 00:39:23,960
filter it's like a sophisticated

00:39:21,230 --> 00:39:27,560
mechanism once I get bloom filter I'd

00:39:23,960 --> 00:39:29,720
black out that is essentially a way for

00:39:27,560 --> 00:39:31,760
the browser to tell the server what's in

00:39:29,720 --> 00:39:33,170
it's browser cache so it's a signal so

00:39:31,760 --> 00:39:35,300
the browser so the server won't push

00:39:33,170 --> 00:39:37,010
things there in the cache this is being

00:39:35,300 --> 00:39:40,040
it's an experimental feature it's being

00:39:37,010 --> 00:39:42,560
standardized in a mechanism called cache

00:39:40,040 --> 00:39:44,540
digest which is the first couple of

00:39:42,560 --> 00:39:46,640
iterations that's the idea is the same

00:39:44,540 --> 00:39:48,410
is to have a way for the browser to

00:39:46,640 --> 00:39:50,660
signal the server what it has in its

00:39:48,410 --> 00:39:50,900
cache so the server doesn't push those

00:39:50,660 --> 00:39:53,450
things

00:39:50,900 --> 00:39:54,950
h2o also doesn't push assets on a

00:39:53,450 --> 00:39:56,810
connection that it's already pushed it

00:39:54,950 --> 00:39:57,609
remembers so that's another safety

00:39:56,810 --> 00:39:59,559
mechanism

00:39:57,609 --> 00:40:02,140
but still that's an unanswered question

00:39:59,559 --> 00:40:03,999
for us with push I think actually the

00:40:02,140 --> 00:40:04,989
most interesting use cases are push are

00:40:03,999 --> 00:40:07,029
the ones that we haven't thought about

00:40:04,989 --> 00:40:09,220
yet because push enables all sorts of

00:40:07,029 --> 00:40:10,779
 that we hadn't thought about so I

00:40:09,220 --> 00:40:12,489
think what's going to be interesting is

00:40:10,779 --> 00:40:15,130
when we get creative and figure out new

00:40:12,489 --> 00:40:16,329
ways of using server push Facebook's

00:40:15,130 --> 00:40:18,039
done a couple of things they actually

00:40:16,329 --> 00:40:22,029
just released this video a few days ago

00:40:18,039 --> 00:40:23,589
it's a very interesting watch and they

00:40:22,029 --> 00:40:25,119
you know they do some things creatively

00:40:23,589 --> 00:40:29,049
for their application for their use

00:40:25,119 --> 00:40:31,779
cases with server push okay let's keep

00:40:29,049 --> 00:40:35,170
going h pack we're still okay everybody

00:40:31,779 --> 00:40:37,749
asleep or with me okay good I see it one

00:40:35,170 --> 00:40:40,089
smile that's good that's Eleni okay

00:40:37,749 --> 00:40:43,150
let's not buy h pack h pack is the

00:40:40,089 --> 00:40:45,249
companion RFC 75 41 this is header

00:40:43,150 --> 00:40:46,900
compression this is the supposed to

00:40:45,249 --> 00:40:49,329
address the header bloat problem and

00:40:46,900 --> 00:40:52,210
it's got two primary mechanisms one is

00:40:49,329 --> 00:40:55,720
all headers or huffman encoded so you

00:40:52,210 --> 00:40:58,720
know a becomes purple and B becomes blue

00:40:55,720 --> 00:41:01,210
and like it's the whole thing and the

00:40:58,720 --> 00:41:03,130
idea is that over time you're basically

00:41:01,210 --> 00:41:06,789
going to create this table where instead

00:41:03,130 --> 00:41:08,619
of using headers you index them the idea

00:41:06,789 --> 00:41:10,150
is instead of sending for example user

00:41:08,619 --> 00:41:13,239
agent blah blah blah blah blah blah blah

00:41:10,150 --> 00:41:14,680
you send index 3 and that means the same

00:41:13,239 --> 00:41:16,619
thing to the both sides and you know

00:41:14,680 --> 00:41:19,180
you've compressed headers that way

00:41:16,619 --> 00:41:22,259
there's two tables there's a static

00:41:19,180 --> 00:41:24,910
table which is defined by the RFC it's

00:41:22,259 --> 00:41:26,559
super static it's never gonna change the

00:41:24,910 --> 00:41:28,660
RFC goes out of its way to say this

00:41:26,559 --> 00:41:29,829
definition is never changing I don't

00:41:28,660 --> 00:41:31,779
know what that happens when you come up

00:41:29,829 --> 00:41:33,220
with new headers but we'll see and then

00:41:31,779 --> 00:41:36,839
there's a dynamic table the two sites

00:41:33,220 --> 00:41:39,460
build over time and they you know add

00:41:36,839 --> 00:41:40,809
entries to it as they communicate it's a

00:41:39,460 --> 00:41:41,859
five flow table so things will fall out

00:41:40,809 --> 00:41:43,299
of it

00:41:41,859 --> 00:41:45,700
here's what the static table looks like

00:41:43,299 --> 00:41:48,519
this is the one that's defined 61

00:41:45,700 --> 00:41:51,220
indexes indices and the dynamic table is

00:41:48,519 --> 00:41:52,539
from 62 on now when I hear the word

00:41:51,220 --> 00:41:55,900
compression the first thing I think

00:41:52,539 --> 00:41:57,160
about is performance not just because I

00:41:55,900 --> 00:41:58,660
live in the performance world but

00:41:57,160 --> 00:42:00,430
because that's compression right Comfort

00:41:58,660 --> 00:42:01,960
let's compress things make them smaller

00:42:00,430 --> 00:42:03,309
perform so what are the performance

00:42:01,960 --> 00:42:05,890
benefits now I'm gonna show you two

00:42:03,309 --> 00:42:07,930
things that are kind of obvious post

00:42:05,890 --> 00:42:10,989
facto but it didn't make sense to me

00:42:07,930 --> 00:42:12,490
until I actually saw them so when you're

00:42:10,989 --> 00:42:14,230
compressing

00:42:12,490 --> 00:42:17,320
you're supposed to send less data right

00:42:14,230 --> 00:42:20,980
so let's look at that here is the data

00:42:17,320 --> 00:42:23,470
sent from a browser to a server with h1

00:42:20,980 --> 00:42:25,630
vs. h2 using H pack you'll see there's a

00:42:23,470 --> 00:42:27,070
lot less data that's cool the browser to

00:42:25,630 --> 00:42:28,900
server Direction has a lot less data

00:42:27,070 --> 00:42:30,250
going and that makes sense because most

00:42:28,900 --> 00:42:32,560
of the traffic between a browser and a

00:42:30,250 --> 00:42:34,840
server is request the headers right this

00:42:32,560 --> 00:42:36,220
headers so if we've cut down those

00:42:34,840 --> 00:42:38,050
headers obviously we're going to cut

00:42:36,220 --> 00:42:39,120
down the amount of data what happens in

00:42:38,050 --> 00:42:42,490
the other direction

00:42:39,120 --> 00:42:44,350
not much the reason for that is most of

00:42:42,490 --> 00:42:46,990
the content that we get from a server is

00:42:44,350 --> 00:42:49,210
payload very like a small fraction of it

00:42:46,990 --> 00:42:51,370
is actually headers so we see a tiny bit

00:42:49,210 --> 00:42:52,810
of benefit there but not a huge benefit

00:42:51,370 --> 00:42:54,580
so if you're expecting performance

00:42:52,810 --> 00:42:57,550
benefits in the server to browser

00:42:54,580 --> 00:42:58,990
direction in H in with H pack there's

00:42:57,550 --> 00:43:00,730
not gonna be that much of it if your

00:42:58,990 --> 00:43:02,290
bandwidth constraint towards the server

00:43:00,730 --> 00:43:05,020
you're gonna see some benefits and in

00:43:02,290 --> 00:43:08,100
fact h2 couldn't operate without H pack

00:43:05,020 --> 00:43:11,680
because if you had headers

00:43:08,100 --> 00:43:13,120
world h1 headers like big headers you

00:43:11,680 --> 00:43:14,830
wouldn't be able to do all those things

00:43:13,120 --> 00:43:16,060
at the same time one of the reasons h2

00:43:14,830 --> 00:43:18,420
can do all those things at the same time

00:43:16,060 --> 00:43:22,690
is because it can send very very short

00:43:18,420 --> 00:43:24,330
frames Dropbox had a blog post about

00:43:22,690 --> 00:43:26,410
this that basically said the same thing

00:43:24,330 --> 00:43:28,660
what you see in that blue line is when

00:43:26,410 --> 00:43:30,760
they enabled it they their ingress

00:43:28,660 --> 00:43:32,380
bandwidth dropped significantly this is

00:43:30,760 --> 00:43:34,330
the incoming traffic incoming bandwidth

00:43:32,380 --> 00:43:36,700
and not much happened to their egress

00:43:34,330 --> 00:43:39,880
outgoing bandwidth some things to note

00:43:36,700 --> 00:43:43,030
about H pack well the dynamic table has

00:43:39,880 --> 00:43:46,230
a default size of 4k and that's for the

00:43:43,030 --> 00:43:48,670
whole dynamic table and browsers can

00:43:46,230 --> 00:43:50,440
adjust it there's a settings parameter

00:43:48,670 --> 00:43:53,620
that says I'm gonna adjust my table size

00:43:50,440 --> 00:43:56,320
but no browser does so the table size is

00:43:53,620 --> 00:43:58,030
staying at 4k this is the content

00:43:56,320 --> 00:43:59,620
security policy header from Twitter if

00:43:58,030 --> 00:44:01,660
you go to Twitter right now and look at

00:43:59,620 --> 00:44:05,050
your dev tools this is the CSP header

00:44:01,660 --> 00:44:07,150
you're not big it is that big so that

00:44:05,050 --> 00:44:10,180
means half the dynamic table gets taken

00:44:07,150 --> 00:44:11,590
up by one header and it's a FIFO table

00:44:10,180 --> 00:44:13,090
right so that thing's gonna go into the

00:44:11,590 --> 00:44:14,500
table and come out of the table and go

00:44:13,090 --> 00:44:17,410
into the table and come out of the table

00:44:14,500 --> 00:44:20,950
so that table may not be as efficient as

00:44:17,410 --> 00:44:23,320
you want it to be so that's a thing to

00:44:20,950 --> 00:44:25,270
take into account there is a proposed

00:44:23,320 --> 00:44:27,460
protocol called site wide headers

00:44:25,270 --> 00:44:29,230
which is intended to basically say

00:44:27,460 --> 00:44:30,640
headers that you're gonna keep sending

00:44:29,230 --> 00:44:32,440
over and over again especially from the

00:44:30,640 --> 00:44:34,540
server to client side just send it once

00:44:32,440 --> 00:44:36,160
and be done with it that's a proposed

00:44:34,540 --> 00:44:38,200
draft right now

00:44:36,160 --> 00:44:39,850
compression context is for connection so

00:44:38,200 --> 00:44:42,220
once that connection drops the dynamic

00:44:39,850 --> 00:44:44,050
table gets wiped so you're keep alive

00:44:42,220 --> 00:44:45,910
timers are now a bigger deal because you

00:44:44,050 --> 00:44:48,040
want to maintain that context for longer

00:44:45,910 --> 00:44:50,160
it is definitely a tack vector and

00:44:48,040 --> 00:44:53,619
there's a paper from Imperva that

00:44:50,160 --> 00:44:55,869
basically attacks it over and over again

00:44:53,619 --> 00:44:58,480
exploits all sorts of things it's a fun

00:44:55,869 --> 00:44:59,680
paper to read a little scary but you

00:44:58,480 --> 00:45:00,760
know we're early in the lifetime of this

00:44:59,680 --> 00:45:02,380
protocol so we're gonna learn these

00:45:00,760 --> 00:45:04,420
lessons you can't turn it off

00:45:02,380 --> 00:45:06,369
so you can't experiment and again like I

00:45:04,420 --> 00:45:08,160
said it's you couldn't be doing

00:45:06,369 --> 00:45:11,830
pipelining without it anyway

00:45:08,160 --> 00:45:13,500
that's H pack last thing I want to talk

00:45:11,830 --> 00:45:17,050
to you about is prioritization

00:45:13,500 --> 00:45:21,700
prioritization is probably the least

00:45:17,050 --> 00:45:25,240
understood mechanism in h2 and also

00:45:21,700 --> 00:45:27,070
probably the most powerful it's a very

00:45:25,240 --> 00:45:28,600
interesting mechanism and the idea is

00:45:27,070 --> 00:45:29,859
that with all these concurrency and all

00:45:28,600 --> 00:45:32,470
these things happening at the same time

00:45:29,859 --> 00:45:34,570
we have to give the server a way to

00:45:32,470 --> 00:45:35,830
resolve contention issues we were giving

00:45:34,570 --> 00:45:37,960
a lot to the server at the same time

00:45:35,830 --> 00:45:40,900
priorities are a way for the server to

00:45:37,960 --> 00:45:42,550
be able to pick what to do before what

00:45:40,900 --> 00:45:44,680
else it comes with two mechanisms

00:45:42,550 --> 00:45:46,990
there's a stream weight which is

00:45:44,680 --> 00:45:48,400
basically the importance of the stream

00:45:46,990 --> 00:45:51,480
and then there's a dependency mechanism

00:45:48,400 --> 00:45:53,590
so you build this tree you dictate

00:45:51,480 --> 00:45:55,450
priorities through headers frames when

00:45:53,590 --> 00:45:57,160
you send a request send a headers frame

00:45:55,450 --> 00:45:58,810
you put a priority in it or you can

00:45:57,160 --> 00:46:02,290
adjust priorities with a dedicated frame

00:45:58,810 --> 00:46:03,609
called a priority frame and the spec

00:46:02,290 --> 00:46:06,220
goes out of its way to say that

00:46:03,609 --> 00:46:09,100
priorities are suggestions that means

00:46:06,220 --> 00:46:10,930
that basically it's a it's a suggestion

00:46:09,100 --> 00:46:12,940
from the browser to the server server

00:46:10,930 --> 00:46:14,920
doesn't need to do anything with it or

00:46:12,940 --> 00:46:16,510
the protocol doesn't say this is the way

00:46:14,920 --> 00:46:18,760
you're supposed to prioritize it's just

00:46:16,510 --> 00:46:21,310
a suggestion let's look at it some

00:46:18,760 --> 00:46:22,480
examples here's a simple one so we're

00:46:21,310 --> 00:46:24,760
going to build trees right this is a

00:46:22,480 --> 00:46:26,500
it's a priority and dependency tree so

00:46:24,760 --> 00:46:27,760
here's the root node everything comes

00:46:26,500 --> 00:46:29,619
off the root node and you have two

00:46:27,760 --> 00:46:31,270
streams a and B and these are their

00:46:29,619 --> 00:46:32,800
weights twelve and four basically what

00:46:31,270 --> 00:46:35,890
this means is it's a suggestion from the

00:46:32,800 --> 00:46:37,519
browser to server to give 3/4 of its

00:46:35,890 --> 00:46:39,259
resources to the stream a

00:46:37,519 --> 00:46:41,149
and 1/4 of the resources to stream be

00:46:39,259 --> 00:46:43,399
it's the ratio that matters so it could

00:46:41,149 --> 00:46:46,880
be 12 and 4 or 3 and 1 it would mean the

00:46:43,399 --> 00:46:48,559
exact same thing this is not for me this

00:46:46,880 --> 00:46:50,959
is from a book called browser networking

00:46:48,559 --> 00:46:53,809
familiar Burak it's a fantastic book I

00:46:50,959 --> 00:46:55,579
don't mean to say that I came up with

00:46:53,809 --> 00:46:57,469
these examples read that book if you

00:46:55,579 --> 00:47:00,649
have read the book read this book I talk

00:46:57,469 --> 00:47:03,890
about it again later here's a dependency

00:47:00,649 --> 00:47:05,749
example you have see here dependent on D

00:47:03,890 --> 00:47:07,219
the weights actually don't matter in

00:47:05,749 --> 00:47:10,069
this case what it means here what this

00:47:07,219 --> 00:47:11,659
means essentially is get done with D and

00:47:10,069 --> 00:47:13,909
then after you're done giving all your

00:47:11,659 --> 00:47:15,319
resources to D give your all your

00:47:13,909 --> 00:47:17,599
resources to see this is what this

00:47:15,319 --> 00:47:20,059
dependency means we combine them looks

00:47:17,599 --> 00:47:22,789
like this and this means work on D alone

00:47:20,059 --> 00:47:25,579
after you're done with D work on C and

00:47:22,789 --> 00:47:27,709
after you only the C work on or put 3/4

00:47:25,579 --> 00:47:30,469
your resources on a and 1/4 your

00:47:27,709 --> 00:47:33,289
resources on B and now in the advanced

00:47:30,469 --> 00:47:35,059
class we can look at this and basically

00:47:33,289 --> 00:47:36,799
what this means is you start with

00:47:35,059 --> 00:47:38,359
everything indeed after you're done with

00:47:36,799 --> 00:47:40,609
D you give half your resources to e

00:47:38,359 --> 00:47:42,079
and half your sister to see those H no

00:47:40,609 --> 00:47:43,880
matter matter it's just the ratio

00:47:42,079 --> 00:47:46,819
between them and then after you're done

00:47:43,880 --> 00:47:48,049
with C take three-quarters of the

00:47:46,819 --> 00:47:49,819
resources you gave to C so

00:47:48,049 --> 00:47:51,829
three-quarters of the 50% that you have

00:47:49,819 --> 00:47:54,469
getting you had given the C and put them

00:47:51,829 --> 00:47:57,199
an A and 1/4 and give it to be that's

00:47:54,469 --> 00:47:59,179
the idea now when this gets really cool

00:47:57,199 --> 00:48:00,769
is if you look at the browser trees the

00:47:59,179 --> 00:48:03,619
way the browsers build them here's how

00:48:00,769 --> 00:48:07,009
Firefox does it Firefox starts with five

00:48:03,619 --> 00:48:08,809
streams that actually have no requests

00:48:07,009 --> 00:48:11,929
over them they just sort of sit and like

00:48:08,809 --> 00:48:15,079
like roots of a tree and all the actual

00:48:11,929 --> 00:48:17,089
streams that carry data are coming off

00:48:15,079 --> 00:48:19,279
of these nodes this is in mind this is

00:48:17,089 --> 00:48:20,989
work but done by a guy named moto from

00:48:19,279 --> 00:48:23,599
Yahoo Japan who's done great

00:48:20,989 --> 00:48:25,099
contribution to h2 definitely check out

00:48:23,599 --> 00:48:26,389
this presentation I have a couple more

00:48:25,099 --> 00:48:28,099
references to his work later

00:48:26,389 --> 00:48:29,869
basically at Firefox does a build this

00:48:28,099 --> 00:48:31,969
tree I have no idea why they built it

00:48:29,869 --> 00:48:34,159
this way but it looks really really

00:48:31,969 --> 00:48:36,319
smart so I'm gonna guess that some

00:48:34,159 --> 00:48:37,549
serious data scientist sat down and said

00:48:36,319 --> 00:48:39,499
this is the best way to build this tree

00:48:37,549 --> 00:48:41,809
and what each of those branches get used

00:48:39,499 --> 00:48:44,630
for is four different elements so images

00:48:41,809 --> 00:48:46,339
get one branch CSS in the head gets a

00:48:44,630 --> 00:48:47,689
different branch JavaScript in the head

00:48:46,339 --> 00:48:49,700
gets a different branch I was gonna the

00:48:47,689 --> 00:48:51,710
body gets slightly different branch

00:48:49,700 --> 00:48:54,230
and that's the way they do it chrome

00:48:51,710 --> 00:48:57,020
used to look like this basically this

00:48:54,230 --> 00:48:58,309
means weights only and everything was

00:48:57,020 --> 00:49:00,770
dependent on the root note so no

00:48:58,309 --> 00:49:02,780
dependencies that's changed recently in

00:49:00,770 --> 00:49:05,359
chrome 53 they started doing some

00:49:02,780 --> 00:49:08,750
dependencies and here's what I know it's

00:49:05,359 --> 00:49:10,430
really difficult to read here's a here's

00:49:08,750 --> 00:49:12,079
a tree here's a dependency and priority

00:49:10,430 --> 00:49:13,549
tree for Chrome I'm gonna make it a lot

00:49:12,079 --> 00:49:16,579
more difficult to read because this is

00:49:13,549 --> 00:49:18,260
what it actually looks like Fredrik one

00:49:16,579 --> 00:49:19,970
of the guys that works in our h2 team

00:49:18,260 --> 00:49:21,260
came up with this tool where you can

00:49:19,970 --> 00:49:22,369
basically map out what Chrome's

00:49:21,260 --> 00:49:25,150
priorities look like that's what the

00:49:22,369 --> 00:49:27,859
tool is check this out it's kind of neat

00:49:25,150 --> 00:49:29,780
what's interesting about this is you see

00:49:27,859 --> 00:49:31,849
all those that branch that goes straight

00:49:29,780 --> 00:49:33,470
down with those exclusive dependencies

00:49:31,849 --> 00:49:35,690
what that basically means if you think

00:49:33,470 --> 00:49:37,730
about it is that breaks intervening

00:49:35,690 --> 00:49:39,260
because that means you can't work on the

00:49:37,730 --> 00:49:41,359
next response until you're done with

00:49:39,260 --> 00:49:42,559
this response the whole idea behind h2

00:49:41,359 --> 00:49:44,569
is to be able to the whole bunch of

00:49:42,559 --> 00:49:46,160
stuff at the same time right this that

00:49:44,569 --> 00:49:47,780
entire branch that goes down like this

00:49:46,160 --> 00:49:50,420
that breaks it that makes it look a lot

00:49:47,780 --> 00:49:51,650
more like h1 my guess with chrome and I

00:49:50,420 --> 00:49:53,000
love chrome is that they're just

00:49:51,650 --> 00:49:55,190
iterating right now and they're trying

00:49:53,000 --> 00:49:57,140
to figure out what the best thing to do

00:49:55,190 --> 00:49:59,930
is canary actually looks slightly

00:49:57,140 --> 00:50:02,150
different so this is I'm just gonna give

00:49:59,930 --> 00:50:03,470
them the benefit out for now if it keeps

00:50:02,150 --> 00:50:06,950
going like this for color versions then

00:50:03,470 --> 00:50:09,770
I'll pick on them and Microsoft has no

00:50:06,950 --> 00:50:12,589
dependencies and no priorities last we

00:50:09,770 --> 00:50:15,470
checked I may be not surprising maybe

00:50:12,589 --> 00:50:17,089
it's different now I have no idea okay

00:50:15,470 --> 00:50:18,470
I've done a lot of stuff at you right

00:50:17,089 --> 00:50:20,030
I'm just going at a hundred miles an

00:50:18,470 --> 00:50:21,980
hour and we have nine minutes is not

00:50:20,030 --> 00:50:24,140
exciting I don't have nine minutes of

00:50:21,980 --> 00:50:25,730
content thank God I'm gonna give some

00:50:24,140 --> 00:50:27,530
tools and resources first of all I'll

00:50:25,730 --> 00:50:29,690
read this book if you haven't read this

00:50:27,530 --> 00:50:31,700
book read this book it's an amazing book

00:50:29,690 --> 00:50:33,200
gives you a lot of insight into how

00:50:31,700 --> 00:50:35,450
browsers work especially when it comes

00:50:33,200 --> 00:50:36,950
to networking and Elia added an h2

00:50:35,450 --> 00:50:40,460
chapter to this which is a great

00:50:36,950 --> 00:50:44,000
overview of HTTP - it's only about 25 30

00:50:40,460 --> 00:50:46,460
pages it's a fantastic sort of primer if

00:50:44,000 --> 00:50:49,190
you want to learn if you'd rather read

00:50:46,460 --> 00:50:50,990
like a chewed-up version of the protocol

00:50:49,190 --> 00:50:52,700
rather than the spec itself and this is

00:50:50,990 --> 00:50:54,530
a very well chewed up version of it's a

00:50:52,700 --> 00:50:57,380
very very good overview it's the first

00:50:54,530 --> 00:50:59,359
thing I read for h2 actually there's a

00:50:57,380 --> 00:51:01,819
little extension for both Firefox and

00:50:59,359 --> 00:51:02,470
Chrome that tells you if the site you're

00:51:01,819 --> 00:51:04,270
on is

00:51:02,470 --> 00:51:06,400
using h2 or h1 it puts a little

00:51:04,270 --> 00:51:09,040
lightning bolt up there I started using

00:51:06,400 --> 00:51:11,290
about a year and a half ago I can't not

00:51:09,040 --> 00:51:13,630
look at it anymore every site that I go

00:51:11,290 --> 00:51:15,070
to in the world my eye instantly goes to

00:51:13,630 --> 00:51:18,730
the lightening bolt to see what protocol

00:51:15,070 --> 00:51:20,890
I'm talking this really really hampers

00:51:18,730 --> 00:51:22,599
the casual surfing like if I'm buying

00:51:20,890 --> 00:51:24,010
something in Amazon at some point I'm

00:51:22,599 --> 00:51:27,190
gonna look at dev tools and see how

00:51:24,010 --> 00:51:28,599
they're using h2 dev tools shows you

00:51:27,190 --> 00:51:30,730
what's going on there's a protocol

00:51:28,599 --> 00:51:33,040
column it's not on by default right

00:51:30,730 --> 00:51:34,720
click on the columns and add it you can

00:51:33,040 --> 00:51:36,670
see if you're talking h2 or h1 to a

00:51:34,720 --> 00:51:39,070
server and if you want to get geekier

00:51:36,670 --> 00:51:40,990
there's a net internals panel that gives

00:51:39,070 --> 00:51:42,760
you all sorts of stuff about your http/2

00:51:40,990 --> 00:51:44,230
connection if you click on that if you

00:51:42,760 --> 00:51:45,790
look look there and click on that one

00:51:44,230 --> 00:51:47,590
stream you actually see the frames go

00:51:45,790 --> 00:51:49,619
back and forth which is really cool and

00:51:47,590 --> 00:51:51,460
that ends up being the input for that

00:51:49,619 --> 00:51:55,300
priority graph that I showed you earlier

00:51:51,460 --> 00:51:56,950
I can't have a talk without mentioning

00:51:55,300 --> 00:51:58,560
Wireshark and I know I've done it once

00:51:56,950 --> 00:52:00,760
so I'm gonna mention it a second time

00:51:58,560 --> 00:52:02,080
Wireshark is an amazing tool that lets

00:52:00,760 --> 00:52:03,849
you look at packets on the network and

00:52:02,080 --> 00:52:05,770
frames on the network and it has a

00:52:03,849 --> 00:52:08,470
decoder for h-2b - it's not the best

00:52:05,770 --> 00:52:10,210
decoder it sort of has a couple of flaws

00:52:08,470 --> 00:52:11,650
but it's great because you can actually

00:52:10,210 --> 00:52:13,540
see what's happening on the wire now

00:52:11,650 --> 00:52:15,430
because everything is TLS things have

00:52:13,540 --> 00:52:17,830
gotten really difficult with Wireshark

00:52:15,430 --> 00:52:20,980
that link right there tells you how to

00:52:17,830 --> 00:52:23,020
sort of decode it the easiest way it's

00:52:20,980 --> 00:52:26,020
still not super easy but it does make

00:52:23,020 --> 00:52:28,540
things slightly easier curl supports it

00:52:26,020 --> 00:52:30,280
we love curl and there's a new version

00:52:28,540 --> 00:52:32,290
of curl actually it's not new anymore

00:52:30,280 --> 00:52:33,609
but it may not be in the the standard

00:52:32,290 --> 00:52:36,970
distribution so you need to install it

00:52:33,609 --> 00:52:38,740
yourself that supports h2 and it's a

00:52:36,970 --> 00:52:41,470
flag you get to see some h2 things

00:52:38,740 --> 00:52:43,030
happening and it's h2 compliant there is

00:52:41,470 --> 00:52:46,630
a curl like tool called

00:52:43,030 --> 00:52:49,450
ng HTTP that's actually amazing it's

00:52:46,630 --> 00:52:51,310
similar to curl its h2 only and it gives

00:52:49,450 --> 00:52:53,170
you a lot of debug info about what's

00:52:51,310 --> 00:52:55,300
happening inside the connection with

00:52:53,170 --> 00:52:56,859
frames and streams and everything you

00:52:55,300 --> 00:52:58,420
get to see push promises you get to see

00:52:56,859 --> 00:53:00,010
pushed frames you see data frames you

00:52:58,420 --> 00:53:01,960
see everything it's great there's a

00:53:00,010 --> 00:53:05,170
bunch of other tools out there most of

00:53:01,960 --> 00:53:08,170
them start with h2 proxies have started

00:53:05,170 --> 00:53:09,830
adding it h2 sees a good tool for

00:53:08,170 --> 00:53:12,140
sort of

00:53:09,830 --> 00:53:14,180
analyzing things with it's kind of a

00:53:12,140 --> 00:53:16,250
man-in-the-middle proxy and the working

00:53:14,180 --> 00:53:17,960
group itself is putting a list of tools

00:53:16,250 --> 00:53:19,300
together sort of as reference and

00:53:17,960 --> 00:53:20,920
there's a link to that at the bottom

00:53:19,300 --> 00:53:24,050
okay

00:53:20,920 --> 00:53:25,820
this by the way is slide number 179 I'm

00:53:24,050 --> 00:53:27,800
proud of you for not falling asleep all

00:53:25,820 --> 00:53:29,240
at once I saw you know some of you may

00:53:27,800 --> 00:53:30,890
have been here and there but all of you

00:53:29,240 --> 00:53:34,970
did not follow see what once 107 ex

00:53:30,890 --> 00:53:36,950
lights h2 is complicated my intent

00:53:34,970 --> 00:53:39,290
wasn't to come here and bum you out

00:53:36,950 --> 00:53:41,720
about it my intent was just to take a

00:53:39,290 --> 00:53:45,230
sort of a practical look this is by no

00:53:41,720 --> 00:53:46,790
means the end of this we need to do more

00:53:45,230 --> 00:53:49,490
of this we need to take some real-world

00:53:46,790 --> 00:53:52,760
data and feedback into the system it's

00:53:49,490 --> 00:53:55,400
okay if h2 isn't perfect

00:53:52,760 --> 00:53:57,380
it's a step we iterated finally on a

00:53:55,400 --> 00:54:00,170
protocol that was 25 years old and I

00:53:57,380 --> 00:54:03,140
guarantee you h3 will not take 25 more

00:54:00,170 --> 00:54:06,320
years H 2 to H 3 is going to be shorter

00:54:03,140 --> 00:54:08,300
it's up to us to feed back into the sort

00:54:06,320 --> 00:54:09,710
of community and inform what the

00:54:08,300 --> 00:54:11,900
decisions are going to be for the next

00:54:09,710 --> 00:54:13,370
version I know the authors and all the

00:54:11,900 --> 00:54:14,840
people in the working group are hungry

00:54:13,370 --> 00:54:16,760
for data and that data is gonna come

00:54:14,840 --> 00:54:18,770
from us I'm gonna try to do everything I

00:54:16,760 --> 00:54:21,080
can because I'm in a position with a CDN

00:54:18,770 --> 00:54:22,550
where I can maybe provide some data but

00:54:21,080 --> 00:54:23,900
real-world data from you and your

00:54:22,550 --> 00:54:25,520
applications is gonna be much more

00:54:23,900 --> 00:54:28,010
valuable than aggregated things that I

00:54:25,520 --> 00:54:29,300
can provide what we learn is it's

00:54:28,010 --> 00:54:30,980
probably not gonna be as fast as you

00:54:29,300 --> 00:54:32,630
like it to be but maybe it will be fast

00:54:30,980 --> 00:54:35,030
as you like it to be so it's gonna be on

00:54:32,630 --> 00:54:37,250
a case-by-case basis and most more most

00:54:35,030 --> 00:54:39,800
importantly are the sites that I tested

00:54:37,250 --> 00:54:41,930
where sites that were built for h1 may

00:54:39,800 --> 00:54:44,060
be building sites for h2 to leverage the

00:54:41,930 --> 00:54:45,920
mechanisms that h2 gives us we're going

00:54:44,060 --> 00:54:47,780
to let us sort of uncover some of its

00:54:45,920 --> 00:54:49,310
features a lot better so it's time that

00:54:47,780 --> 00:54:51,170
we understand some of these features

00:54:49,310 --> 00:54:53,660
better and hopefully this was a you know

00:54:51,170 --> 00:54:56,120
good primer to start you and start

00:54:53,660 --> 00:54:58,700
building our applications with those

00:54:56,120 --> 00:55:01,040
features in place we still have a lot of

00:54:58,700 --> 00:55:02,840
learning to do but I think feeding back

00:55:01,040 --> 00:55:04,580
into the system h2 is ultimately the way

00:55:02,840 --> 00:55:07,070
we're gonna be going forward feeding

00:55:04,580 --> 00:55:08,570
back into the system and sharing data if

00:55:07,070 --> 00:55:10,400
you find anything that looks like this

00:55:08,570 --> 00:55:12,560
if you do your own tests find anything

00:55:10,400 --> 00:55:14,360
that can that's that's educational

00:55:12,560 --> 00:55:16,250
publish it everybody wants to see these

00:55:14,360 --> 00:55:18,140
things especially now we're in a very

00:55:16,250 --> 00:55:21,590
special place we get to see a protocol

00:55:18,140 --> 00:55:22,370
be built and that's not a position a lot

00:55:21,590 --> 00:55:24,230
of people

00:55:22,370 --> 00:55:26,750
the luxury of being in so let's take

00:55:24,230 --> 00:55:29,540
advantage of that I have 4 minutes and

00:55:26,750 --> 00:55:30,740
30 seconds for questions and I'm gonna

00:55:29,540 --> 00:55:31,880
be round I'm gonna be outside right

00:55:30,740 --> 00:55:33,530
after if you want to come up to me

00:55:31,880 --> 00:55:38,740
afterwards and ask questions are there

00:55:33,530 --> 00:55:38,740
any questions yes

00:55:45,090 --> 00:55:47,720
yes

00:55:53,440 --> 00:55:57,910
that I'm gonna so the question is H 2h

00:55:56,020 --> 00:56:01,119
pad can't be disabled and is an attack

00:55:57,910 --> 00:56:03,400
vector the answer is yes it doesn't mean

00:56:01,119 --> 00:56:04,630
all implementations and that the actual

00:56:03,400 --> 00:56:06,760
question is does that mean I should

00:56:04,630 --> 00:56:07,480
never use H to know everything we use is

00:56:06,760 --> 00:56:08,980
an attack vector

00:56:07,480 --> 00:56:11,470
everything is at some point or another

00:56:08,980 --> 00:56:13,720
an attack vector and it's up to and it's

00:56:11,470 --> 00:56:15,880
up to implementers to make sure those

00:56:13,720 --> 00:56:17,230
those points are addressed now if you

00:56:15,880 --> 00:56:19,030
read that particular paper it will tell

00:56:17,230 --> 00:56:21,160
you what they attacked and what's been

00:56:19,030 --> 00:56:23,380
done since because just like any

00:56:21,160 --> 00:56:25,660
security advisory things get it man I

00:56:23,380 --> 00:56:27,730
did that like 20 times today things get

00:56:25,660 --> 00:56:28,960
exposed and we fix them what's happened

00:56:27,730 --> 00:56:31,150
with H 2 is a whole bunch of new

00:56:28,960 --> 00:56:32,890
mechanisms in place and we have a lot of

00:56:31,150 --> 00:56:34,569
learning to do and those things get

00:56:32,890 --> 00:56:35,020
exploited and we fix them and we move

00:56:34,569 --> 00:56:37,810
forward

00:56:35,020 --> 00:56:43,500
so yes and no it doesn't mean you don't

00:56:37,810 --> 00:56:43,500
need to use H - yeah anything else yes

00:57:00,369 --> 00:57:04,719
that's a good question I showed a

00:57:02,049 --> 00:57:06,759
comparison between h1 and h2 in data

00:57:04,719 --> 00:57:08,589
sent from the browser to server and the

00:57:06,759 --> 00:57:11,469
server to the browser the question is

00:57:08,589 --> 00:57:11,979
was it gzip was it not gzip what was the

00:57:11,469 --> 00:57:14,920
content

00:57:11,979 --> 00:57:17,499
well the browser to server Direction was

00:57:14,920 --> 00:57:18,910
just all requests so there's no there

00:57:17,499 --> 00:57:20,469
wasn't any content to Gees up there and

00:57:18,910 --> 00:57:22,749
that was what I was showing there was h1

00:57:20,469 --> 00:57:24,460
verses H back to h2 which is the only

00:57:22,749 --> 00:57:27,640
version that's where the biggest gap was

00:57:24,460 --> 00:57:30,400
the response was in that particular site

00:57:27,640 --> 00:57:31,359
was actually all images actually no that

00:57:30,400 --> 00:57:32,759
one was the fastest site so it's

00:57:31,359 --> 00:57:34,989
compressed everything is compressed

00:57:32,759 --> 00:57:37,630
basically I took the standard site and

00:57:34,989 --> 00:57:39,069
is what it would be like with H pack and

00:57:37,630 --> 00:57:40,450
without H pack that's what I was showing

00:57:39,069 --> 00:57:42,969
so whatever content was coming across

00:57:40,450 --> 00:57:44,499
was the same for both h1 and h2 and what

00:57:42,969 --> 00:57:47,079
you were seeing was the Delta between

00:57:44,499 --> 00:57:49,119
basically Delta caused by H pack which

00:57:47,079 --> 00:57:52,589
was about this big for server to browser

00:57:49,119 --> 00:57:52,589
communication so make sense

00:58:08,089 --> 00:58:12,469
oh why don't just gzip headers that's a

00:58:11,869 --> 00:58:15,079
good question

00:58:12,469 --> 00:58:17,359
I think speedy tried that and it was a

00:58:15,079 --> 00:58:18,799
problem so one of the design decisions

00:58:17,359 --> 00:58:19,999
they made I don't mean may not I mean

00:58:18,799 --> 00:58:21,559
gzip there was some compression

00:58:19,999 --> 00:58:22,939
algorithm that they put for headers one

00:58:21,559 --> 00:58:26,269
of the design decisions made

00:58:22,939 --> 00:58:27,559
when speedy turned into h2 was to use

00:58:26,269 --> 00:58:28,969
Huffman encoding I don't know what the

00:58:27,559 --> 00:58:30,559
motivations were I tried to stay out of

00:58:28,969 --> 00:58:39,009
it say give me a paper to read and I

00:58:30,559 --> 00:58:42,949
learned anything else yes sorry Oh

00:58:39,009 --> 00:58:44,779
question is speedy actually finished yes

00:58:42,949 --> 00:58:46,099
Chrome is pretty much pulling out

00:58:44,779 --> 00:58:48,049
support if they already haven't

00:58:46,099 --> 00:58:50,989
Firefox is gonna pull out support speedy

00:58:48,049 --> 00:58:52,699
turned into h2 and one of the things

00:58:50,989 --> 00:58:54,049
that happen this may not be interesting

00:58:52,699 --> 00:58:55,880
to you but it's interesting to me is

00:58:54,049 --> 00:58:57,890
when h2 started there was a call for

00:58:55,880 --> 00:58:59,390
proposals basically a where do we start

00:58:57,890 --> 00:59:01,279
there was three or four different ones

00:58:59,390 --> 00:59:03,079
actually and speedy was one of them and

00:59:01,279 --> 00:59:06,170
speedy was the one that was chosen and

00:59:03,079 --> 00:59:09,859
speedy turned into what's h2 and speedy

00:59:06,170 --> 00:59:11,900
is also part of what's enabling quick so

00:59:09,859 --> 00:59:13,969
quick can actually be a transport for

00:59:11,900 --> 00:59:16,609
speedy and quick can be a transfer for

00:59:13,969 --> 00:59:19,729
h2 so a transport for h2 so over time

00:59:16,609 --> 00:59:21,289
cook is gonna be more h2 carrying and

00:59:19,729 --> 00:59:24,349
then the standard version of quick will

00:59:21,289 --> 00:59:26,140
be H 2 versus speedy so speedy is

00:59:24,349 --> 00:59:32,449
basically getting phased out yes

00:59:26,140 --> 00:59:34,279
anything else ok we have 26 seconds left

00:59:32,449 --> 00:59:34,699
way to go I'm proud of you thank you for

00:59:34,279 --> 00:59:35,630
your time

00:59:34,699 --> 00:59:38,650
I'm gonna be it right out here if you

00:59:35,630 --> 00:59:38,650

YouTube URL: https://www.youtube.com/watch?v=0yzJAKknE_k


