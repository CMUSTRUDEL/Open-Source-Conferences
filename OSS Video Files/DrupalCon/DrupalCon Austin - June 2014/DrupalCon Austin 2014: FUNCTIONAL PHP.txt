Title: DrupalCon Austin 2014: FUNCTIONAL PHP
Publication date: 2014-06-03
Playlist: DrupalCon Austin - June 2014
Description: 
	Speakers: Crell
Functional programming. Some see that term and think "functions? You mean procedural programming. I've been doing that for years." Others see it and think "you mean that crazy academic nonsense that no one understands? Pfft!"

In truth, functional programming is fundamentally an approach to software development, not a particular language or syntax. With PHP 5.3, it is an approach that is now more readily available and powerful than ever before. Even if you're not writing in Erlang or ML, there is still much to learn from the principles of functional programming to help write better code.

This session will discuss the history of functional programming and how it compares to other programming paradigms (procedural and object-oriented). We will then discuss by example how functional concepts and techniques, plus new language capabilities in PHP 5.3 such as anonymous functions can make our code more robust, maintainable, and bug-free. Even without a truly functional language, there is much we can learn from functional programming as a technique.
Captions: 
	00:00:00,000 --> 00:00:04,259
this talk is functional PHP if that's

00:00:02,070 --> 00:00:05,730
not what you're here for then one of us

00:00:04,259 --> 00:00:07,319
is in the wrong room

00:00:05,730 --> 00:00:10,160
and I hope it's not me because that to

00:00:07,319 --> 00:00:10,160
be very embarrassing

00:00:10,620 --> 00:00:15,450
my name is Larry Garfield you may know

00:00:12,870 --> 00:00:17,070
me as Krell online or you mean those of

00:00:15,450 --> 00:00:21,320
you who are here early this morning may

00:00:17,070 --> 00:00:21,320
know my alter-ego Lord over-engineering

00:00:24,800 --> 00:00:30,150
when I'm not so over acting horribly

00:00:27,599 --> 00:00:32,460
I'm a senior architect with Palantir net

00:00:30,150 --> 00:00:34,200
we're a web development shop based in

00:00:32,460 --> 00:00:37,050
Chicago doing mostly Drupal development

00:00:34,200 --> 00:00:40,079
we work mostly with universities

00:00:37,050 --> 00:00:44,010
publishing companies museums cultural

00:00:40,079 --> 00:00:47,219
institutions healthcare large nonprofits

00:00:44,010 --> 00:00:49,079
is our primary target audience for

00:00:47,219 --> 00:00:51,210
Drupal 8 I'm also the web services lead

00:00:49,079 --> 00:00:54,300
so the Whiskey initiative which has

00:00:51,210 --> 00:00:55,710
nothing to alcohol I apologize I'm also

00:00:54,300 --> 00:00:57,420
the troop representative to the

00:00:55,710 --> 00:00:59,280
framework interoperability group it's

00:00:57,420 --> 00:01:01,320
kind of the United Nations of the PHP

00:00:59,280 --> 00:01:04,650
world with all of the good and bad

00:01:01,320 --> 00:01:06,030
implications that analogy has advisors

00:01:04,650 --> 00:01:08,010
with Drupal Association and general

00:01:06,030 --> 00:01:09,390
purpose loveable pendant and my

00:01:08,010 --> 00:01:12,780
colleagues made to speed the first part

00:01:09,390 --> 00:01:14,100
of that but not the second but that's

00:01:12,780 --> 00:01:17,310
really the last of the Drupal we're

00:01:14,100 --> 00:01:18,689
going to talk about in this session I'll

00:01:17,310 --> 00:01:21,210
give you a heads up this is gonna be a

00:01:18,689 --> 00:01:23,400
fairly heavy talk we're talking about

00:01:21,210 --> 00:01:26,100
computer science concepts here not just

00:01:23,400 --> 00:01:28,970
general programming so please bear with

00:01:26,100 --> 00:01:31,890
me I will try to keep it as

00:01:28,970 --> 00:01:34,140
understandable as possible but let's

00:01:31,890 --> 00:01:35,100
first go back a little ways because if

00:01:34,140 --> 00:01:37,400
you want to understand something you

00:01:35,100 --> 00:01:39,360
need to understand its beginnings I

00:01:37,400 --> 00:01:40,770
don't remember where this line came from

00:01:39,360 --> 00:01:42,150
originally it was on Twitter somewhere

00:01:40,770 --> 00:01:42,780
if you look at the history of computers

00:01:42,150 --> 00:01:44,850
backwards

00:01:42,780 --> 00:01:46,740
it starts with kids flailing and smart

00:01:44,850 --> 00:01:48,810
men and ends with some smart men solving

00:01:46,740 --> 00:01:50,189
really hard problems so let's go back

00:01:48,810 --> 00:01:52,619
and look at some of those really hard

00:01:50,189 --> 00:01:56,610
problems people who are now dead we're

00:01:52,619 --> 00:02:01,820
trying to solve a century ago start back

00:01:56,610 --> 00:02:04,259
in the 20s and 30s 1920s and 1930s when

00:02:01,820 --> 00:02:05,820
logicians and mathematicians were trying

00:02:04,259 --> 00:02:08,580
to figure out what does it mean to

00:02:05,820 --> 00:02:11,760
compute something you know this back

00:02:08,580 --> 00:02:13,590
when a computer was a person usually a

00:02:11,760 --> 00:02:16,349
woman who sat all day and did math for

00:02:13,590 --> 00:02:19,739
her job that was a computer electronic

00:02:16,349 --> 00:02:22,379
things came in later and scientists are

00:02:19,739 --> 00:02:24,120
trying to think through and what does it

00:02:22,379 --> 00:02:26,040
mean to compute something what does it

00:02:24,120 --> 00:02:28,709
mean to calculate and there are two

00:02:26,040 --> 00:02:30,840
largely you know the two main camps

00:02:28,709 --> 00:02:34,110
that's developed one was a paper

00:02:30,840 --> 00:02:35,690
published by Alonzo Church describing

00:02:34,110 --> 00:02:37,560
something he called lambda calculus

00:02:35,690 --> 00:02:39,239
calculus because he's a mathematician

00:02:37,560 --> 00:02:41,120
and mathematicians like to call things

00:02:39,239 --> 00:02:44,340
calculus because it sounds cool and

00:02:41,120 --> 00:02:45,540
lambda because he got really tired of

00:02:44,340 --> 00:02:47,579
writing the word function out in

00:02:45,540 --> 00:02:48,959
longhand and so as any good scientist he

00:02:47,579 --> 00:02:50,640
started using Greek letters instead and

00:02:48,959 --> 00:02:52,440
so lambda is an alternate word for

00:02:50,640 --> 00:02:54,360
function that's pretty much all you need

00:02:52,440 --> 00:02:56,340
to think about they're fundamentally

00:02:54,360 --> 00:02:57,720
though he was describing computation

00:02:56,340 --> 00:02:59,700
what is this thing that computers do

00:02:57,720 --> 00:03:01,530
what is this thing that logic does as a

00:02:59,700 --> 00:03:04,560
relationship between mathematical

00:03:01,530 --> 00:03:07,290
functions in this worldview everything

00:03:04,560 --> 00:03:10,860
is a mathematical function and you can

00:03:07,290 --> 00:03:12,840
do anything with that he was in the US

00:03:10,860 --> 00:03:14,819
and within a few months of when he

00:03:12,840 --> 00:03:17,040
published his paper and man named Alan

00:03:14,819 --> 00:03:18,630
Turing over in the UK published a

00:03:17,040 --> 00:03:20,700
different paper that took a different

00:03:18,630 --> 00:03:22,889
approach and he coined something called

00:03:20,700 --> 00:03:26,359
a Turing machine so called because he

00:03:22,889 --> 00:03:28,859
had a bigger ego than Alonzo Church did

00:03:26,359 --> 00:03:30,870
which is essentially an abstract state

00:03:28,859 --> 00:03:32,819
machine it deals with state it deals

00:03:30,870 --> 00:03:35,579
with the state of information and the

00:03:32,819 --> 00:03:37,109
transformations between them these are

00:03:35,579 --> 00:03:39,150
just some of the people are gonna talk

00:03:37,109 --> 00:03:40,440
about who or just way too smart to for

00:03:39,150 --> 00:03:42,930
the fact that we don't know enough about

00:03:40,440 --> 00:03:45,470
them people don't learn about some of

00:03:42,930 --> 00:03:49,819
these people which is very depressing

00:03:45,470 --> 00:03:51,540
but these two men up there they're very

00:03:49,819 --> 00:03:53,489
respectable mathematicians and

00:03:51,540 --> 00:03:55,290
scientists so looked at each other's

00:03:53,489 --> 00:03:57,239
work and said wait a minute this looks

00:03:55,290 --> 00:03:59,579
familiar and they went on to prove that

00:03:57,239 --> 00:04:03,090
in fact these two ways of looking at the

00:03:59,579 --> 00:04:05,280
world are equivalent there is no problem

00:04:03,090 --> 00:04:07,380
in computer science in programming in

00:04:05,280 --> 00:04:09,480
computers that you can solve in one way

00:04:07,380 --> 00:04:13,799
or the other you can always approach it

00:04:09,480 --> 00:04:16,919
in both ways so let's fast forward a

00:04:13,799 --> 00:04:19,019
little bit to World War two and shortly

00:04:16,919 --> 00:04:21,780
thereafter and another crazy smart

00:04:19,019 --> 00:04:23,340
mathematician named John von Neumann for

00:04:21,780 --> 00:04:24,720
whom math mathematics was just kind of

00:04:23,340 --> 00:04:27,810
his side hobby he also

00:04:24,720 --> 00:04:29,430
worked on set theory quantum theory

00:04:27,810 --> 00:04:31,770
nuclear physics he was on the Manhattan

00:04:29,430 --> 00:04:35,070
Project just way too smart for his own

00:04:31,770 --> 00:04:37,440
good as was often the case and he was

00:04:35,070 --> 00:04:39,090
also a consultant on the ENIAC computer

00:04:37,440 --> 00:04:41,010
one of the very first electronic

00:04:39,090 --> 00:04:44,120
computers and on edvac which is the

00:04:41,010 --> 00:04:48,020
other very first electronic computer and

00:04:44,120 --> 00:04:50,520
both of these systems under his guidance

00:04:48,020 --> 00:04:53,010
definitely were implementations of the

00:04:50,520 --> 00:04:55,380
Turing machine they took the stateful

00:04:53,010 --> 00:04:57,270
approach of defining all right if we

00:04:55,380 --> 00:05:00,240
want to build an electronic magic box

00:04:57,270 --> 00:05:02,070
that computes stuff how are we going to

00:05:00,240 --> 00:05:05,300
do it and they took the Turing machine

00:05:02,070 --> 00:05:07,200
approach of tracking state and this

00:05:05,300 --> 00:05:09,840
architecture became known as the von

00:05:07,200 --> 00:05:12,630
Neumann architecture von Neumann

00:05:09,840 --> 00:05:16,410
architecture is this idea of a historic

00:05:12,630 --> 00:05:18,930
program a program is simply data program

00:05:16,410 --> 00:05:21,900
is instructions and is a series of steps

00:05:18,930 --> 00:05:25,650
a series of steps followed in order

00:05:21,900 --> 00:05:28,860
linearly one step after another and this

00:05:25,650 --> 00:05:31,980
job of a step is to alter the value in

00:05:28,860 --> 00:05:35,370
some place in memory in that magic box

00:05:31,980 --> 00:05:37,980
computer and one of the things that you

00:05:35,370 --> 00:05:41,669
can alter is the place in that magic box

00:05:37,980 --> 00:05:43,770
that says what step to run next and that

00:05:41,669 --> 00:05:46,919
just right there gives you enormous

00:05:43,770 --> 00:05:50,190
power that is how all computers work

00:05:46,919 --> 00:05:51,960
today and this leads to a concept called

00:05:50,190 --> 00:05:53,760
imperative programming this is

00:05:51,960 --> 00:05:55,470
imperative in the linguistic sense of an

00:05:53,760 --> 00:05:58,260
imperative move like you're giving

00:05:55,470 --> 00:06:01,410
commands go here do this add that set

00:05:58,260 --> 00:06:03,510
that print that that's what imperative

00:06:01,410 --> 00:06:06,390
programming is it's a series of commands

00:06:03,510 --> 00:06:08,400
a series of instructions very precise

00:06:06,390 --> 00:06:12,630
commands remember computers are stupid

00:06:08,400 --> 00:06:14,820
they only do what you tell them and as

00:06:12,630 --> 00:06:17,100
this concept called state state are

00:06:14,820 --> 00:06:21,090
values they are pieces of information

00:06:17,100 --> 00:06:23,310
that change over time the this value

00:06:21,090 --> 00:06:26,070
will change and the point of a program

00:06:23,310 --> 00:06:28,710
is to run a series of steps that will

00:06:26,070 --> 00:06:31,020
change that state the purpose of a

00:06:28,710 --> 00:06:35,760
program in imperative programming is to

00:06:31,020 --> 00:06:37,750
change state to change the value of its

00:06:35,760 --> 00:06:40,810
change value of something

00:06:37,750 --> 00:06:43,600
and this is how virtually every piece of

00:06:40,810 --> 00:06:45,430
modern hardware works from the phone in

00:06:43,600 --> 00:06:48,640
your pockets to the laptop on your lap -

00:06:45,430 --> 00:06:50,980
the giant servers running a wall street

00:06:48,640 --> 00:06:52,720
they're all at the hardware level doing

00:06:50,980 --> 00:06:56,380
this exact same thing they're just

00:06:52,720 --> 00:06:58,060
pushing state around conceptually you

00:06:56,380 --> 00:07:00,400
can think of imperative programming like

00:06:58,060 --> 00:07:03,010
following a recipe for a cake you've got

00:07:00,400 --> 00:07:04,600
this big bowl that is your memory and

00:07:03,010 --> 00:07:05,980
you add an ingredient to it you've

00:07:04,600 --> 00:07:07,270
changed a state and you have another

00:07:05,980 --> 00:07:09,220
ingredient to it and you change state

00:07:07,270 --> 00:07:11,380
and you mix it and you've changed the

00:07:09,220 --> 00:07:14,080
state and you put it in an oven and

00:07:11,380 --> 00:07:16,630
you've baked it and you've changed its

00:07:14,080 --> 00:07:18,760
state in all of these you are just

00:07:16,630 --> 00:07:20,500
manipulating state in the case of a

00:07:18,760 --> 00:07:23,650
computer instead of a bowl you have RAM

00:07:20,500 --> 00:07:25,900
or data on a hard drive or the registers

00:07:23,650 --> 00:07:29,800
in the CPU but fundamentally you are

00:07:25,900 --> 00:07:31,660
just manipulating state this led of

00:07:29,800 --> 00:07:34,419
course this is hard to do so this led to

00:07:31,660 --> 00:07:36,940
procedural programming which is

00:07:34,419 --> 00:07:39,669
essentially just a step above imperative

00:07:36,940 --> 00:07:42,160
it's not much of a change and has the

00:07:39,669 --> 00:07:44,500
concept of a procedure a procedure or

00:07:42,160 --> 00:07:47,950
subroutine as it is often called it's

00:07:44,500 --> 00:07:49,510
simply a reusable set of commands all it

00:07:47,950 --> 00:07:51,580
is is reusable bits of imperative

00:07:49,510 --> 00:07:54,220
programming but that does give you this

00:07:51,580 --> 00:07:55,960
concept of structured programming which

00:07:54,220 --> 00:07:59,380
gives you these sort of high-level

00:07:55,960 --> 00:08:01,150
abstractions like if and for loops and

00:07:59,380 --> 00:08:04,450
while loops so instead of directly

00:08:01,150 --> 00:08:05,560
manipulating registers you can say wow

00:08:04,450 --> 00:08:08,080
this value

00:08:05,560 --> 00:08:10,000
well this register is still five or

00:08:08,080 --> 00:08:11,979
greater than five or whatever run these

00:08:10,000 --> 00:08:13,600
instructions over and over again which

00:08:11,979 --> 00:08:15,370
is still pretty low-level but it's less

00:08:13,600 --> 00:08:17,979
low-level than dealing with the memory

00:08:15,370 --> 00:08:20,229
registers directly very very simple

00:08:17,979 --> 00:08:22,150
procedural program I can look like this

00:08:20,229 --> 00:08:27,750
got I can't actually see it from the

00:08:22,150 --> 00:08:30,700
side here but we've defined our list and

00:08:27,750 --> 00:08:33,880
we have this biggest variable and then

00:08:30,700 --> 00:08:37,630
we defined this set of commands and then

00:08:33,880 --> 00:08:40,750
we call it C and then we print out the

00:08:37,630 --> 00:08:42,610
value at the end that's a procedural

00:08:40,750 --> 00:08:44,110
program I don't think this is an actual

00:08:42,610 --> 00:08:45,750
language although it might be some

00:08:44,110 --> 00:08:48,790
clothes to put in the early languages

00:08:45,750 --> 00:08:51,760
but notice we are manipulating states we

00:08:48,790 --> 00:08:53,930
are changing values as we go

00:08:51,760 --> 00:08:57,110
essentially it's like singing a song

00:08:53,930 --> 00:08:59,060
with a refrain where you can repeat the

00:08:57,110 --> 00:09:01,010
chorus over and over again it's reusable

00:08:59,060 --> 00:09:02,750
you just reference it but you're still

00:09:01,010 --> 00:09:06,560
singing one line after another after

00:09:02,750 --> 00:09:07,970
another after another imperative

00:09:06,560 --> 00:09:12,440
programming is based on the idea of

00:09:07,970 --> 00:09:15,140
defining how a program should work who's

00:09:12,440 --> 00:09:16,400
familiar with this if you've ever

00:09:15,140 --> 00:09:17,630
written code and pretty much any

00:09:16,400 --> 00:09:23,780
language your hand should be up right

00:09:17,630 --> 00:09:26,300
now okay if you've written PHP ever or

00:09:23,780 --> 00:09:28,010
JavaScript ever you've done exactly this

00:09:26,300 --> 00:09:29,900
and it's just abstractions and

00:09:28,010 --> 00:09:33,220
abstractions and syntactic sugar on top

00:09:29,900 --> 00:09:36,920
of pushing state around on disk

00:09:33,220 --> 00:09:38,990
everything we do above you know moving

00:09:36,920 --> 00:09:40,210
registers around in the CPU is purely

00:09:38,990 --> 00:09:42,530
syntactic sugar

00:09:40,210 --> 00:09:45,350
everything we do in programming is

00:09:42,530 --> 00:09:49,520
syntactic sugar over pushing values

00:09:45,350 --> 00:09:50,720
around and changing values but let's

00:09:49,520 --> 00:09:53,300
take a look at a different way of

00:09:50,720 --> 00:09:56,060
approaching the problem declarative

00:09:53,300 --> 00:09:58,040
programming declarative programming does

00:09:56,060 --> 00:09:59,600
not just say how a program should work

00:09:58,040 --> 00:10:03,890
it just defines what it should

00:09:59,600 --> 00:10:07,670
accomplish you'd simply define this is

00:10:03,890 --> 00:10:09,500
how something should end up and then

00:10:07,670 --> 00:10:11,630
it's the computers job or a compilers

00:10:09,500 --> 00:10:15,970
job to figure out what that means in

00:10:11,630 --> 00:10:18,650
practice who here is written SQL

00:10:15,970 --> 00:10:20,690
declarative programming you're not

00:10:18,650 --> 00:10:22,400
saying you know here's how you pull data

00:10:20,690 --> 00:10:24,410
out of this data structure in this file

00:10:22,400 --> 00:10:25,970
or whatever you're just saying these two

00:10:24,410 --> 00:10:27,380
values from these two tables should

00:10:25,970 --> 00:10:29,960
merge together and give me a result

00:10:27,380 --> 00:10:35,360
that's declarative programming who's

00:10:29,960 --> 00:10:36,650
written CSS declarative programming all

00:10:35,360 --> 00:10:39,800
of the llamÃ³ files interpolate

00:10:36,650 --> 00:10:43,700
declarative programming spreadsheets

00:10:39,800 --> 00:10:45,080
who's written a spreadsheet declarative

00:10:43,700 --> 00:10:48,860
programming you're simply stating what

00:10:45,080 --> 00:10:50,839
this value of a Cell should be which

00:10:48,860 --> 00:10:55,100
brings us to our next very smart old

00:10:50,839 --> 00:10:56,660
mathematician John Bacchus John Bacchus

00:10:55,100 --> 00:10:58,550
was among other things one of the

00:10:56,660 --> 00:11:00,160
inventors of the Fortran language it was

00:10:58,550 --> 00:11:03,580
one of the first to be first

00:11:00,160 --> 00:11:05,830
third-generation language that gave you

00:11:03,580 --> 00:11:08,500
something above assembly to actually

00:11:05,830 --> 00:11:13,180
work with and as penance for writing

00:11:08,500 --> 00:11:14,920
Fortran you got the joke okay he went to

00:11:13,180 --> 00:11:17,410
him to help develop Bacchus in our form

00:11:14,920 --> 00:11:19,649
who's heard of this BNF or EB NF yeah

00:11:17,410 --> 00:11:22,570
that's that Bacchus which is a

00:11:19,649 --> 00:11:24,820
standardized way of describing a

00:11:22,570 --> 00:11:26,649
language describing a programming

00:11:24,820 --> 00:11:28,720
language

00:11:26,649 --> 00:11:31,540
he also co-developed Algol which is a

00:11:28,720 --> 00:11:35,260
mechanism for defining algorithms and in

00:11:31,540 --> 00:11:37,930
1990 is 1977 while receiving Turing

00:11:35,260 --> 00:11:39,820
Award ironically he gave a paper called

00:11:37,930 --> 00:11:42,640
can programming be liberated from the

00:11:39,820 --> 00:11:45,339
von Neumann style a functional style and

00:11:42,640 --> 00:11:48,430
it's algebra of programs functional

00:11:45,339 --> 00:11:49,959
programming as a term came about here

00:11:48,430 --> 00:11:51,700
and we say functional we don't mean that

00:11:49,959 --> 00:11:56,589
it works I mean these programs when

00:11:51,700 --> 00:11:58,870
we're working well before 1977 but it's

00:11:56,589 --> 00:12:00,310
a functional like mathematics like the

00:11:58,870 --> 00:12:02,579
math you remember from high school or

00:12:00,310 --> 00:12:04,779
aqaq or from college where you had

00:12:02,579 --> 00:12:06,640
inputs and transformations and you got

00:12:04,779 --> 00:12:10,209
an output out of it that kind of

00:12:06,640 --> 00:12:12,730
function mathematical functions again

00:12:10,209 --> 00:12:16,270
Bacchus did not invent this stuff if

00:12:12,730 --> 00:12:17,320
anything this is simply lambda calculus

00:12:16,270 --> 00:12:19,750
all over again

00:12:17,320 --> 00:12:22,180
in fact I think even references that

00:12:19,750 --> 00:12:25,089
this is simply saying should we go back

00:12:22,180 --> 00:12:26,649
to that of course you know I said he

00:12:25,089 --> 00:12:27,910
didn't invent it list people claimed

00:12:26,649 --> 00:12:29,680
that they did invent it because list

00:12:27,910 --> 00:12:32,829
claims to have invented everything but

00:12:29,680 --> 00:12:35,260
that's another story but in functional

00:12:32,829 --> 00:12:39,399
programming what you're declaring work

00:12:35,260 --> 00:12:42,000
toward defining is your algorithm that's

00:12:39,399 --> 00:12:45,070
declaring steps to accomplish a task

00:12:42,000 --> 00:12:47,459
you're defining the algorithm for a task

00:12:45,070 --> 00:12:50,500
the relationship that defines a task and

00:12:47,459 --> 00:12:53,649
then actually turning that into steps is

00:12:50,500 --> 00:12:57,550
not your problem it's not your job that

00:12:53,649 --> 00:13:00,339
is what a compiler is for functional

00:12:57,550 --> 00:13:01,630
programming has three core concepts

00:13:00,339 --> 00:13:04,029
which we're all gonna go over pure

00:13:01,630 --> 00:13:06,459
functions in mutable variables and

00:13:04,029 --> 00:13:08,170
higher-order functions the higher-order

00:13:06,459 --> 00:13:09,490
functions first-class functions they are

00:13:08,170 --> 00:13:11,800
technically different things to the

00:13:09,490 --> 00:13:13,720
mathematical purists but they're close

00:13:11,800 --> 00:13:15,130
enough for our purposes that I'm going

00:13:13,720 --> 00:13:17,440
to treat them as they're as though

00:13:15,130 --> 00:13:20,880
so anyone here who actually has a CS

00:13:17,440 --> 00:13:20,880
degree please don't throw tomatoes at me

00:13:21,090 --> 00:13:25,720
but we said before you've probably done

00:13:24,160 --> 00:13:29,070
something like this who's written

00:13:25,720 --> 00:13:30,840
formulas in a spreadsheet at some point

00:13:29,070 --> 00:13:34,120
functional programming

00:13:30,840 --> 00:13:36,670
you're not saying take this value and

00:13:34,120 --> 00:13:39,010
this value and add them and multiply by

00:13:36,670 --> 00:13:41,790
this value you know in steps you're

00:13:39,010 --> 00:13:44,440
saying no the value of this cell is

00:13:41,790 --> 00:13:48,370
these two cells multiplied together and

00:13:44,440 --> 00:13:51,580
the value in this cell is that value

00:13:48,370 --> 00:13:54,270
plus the value in this cell what order

00:13:51,580 --> 00:13:56,650
that happens in when it gets calculated

00:13:54,270 --> 00:13:59,040
completely not your problem you are

00:13:56,650 --> 00:14:01,870
defining a cell's value as being

00:13:59,040 --> 00:14:07,440
something in relation to other cells how

00:14:01,870 --> 00:14:09,790
it actually happens me not their job so

00:14:07,440 --> 00:14:11,850
you know functional if comparative

00:14:09,790 --> 00:14:14,220
programming is following a recipe

00:14:11,850 --> 00:14:16,420
procedural programming is singing

00:14:14,220 --> 00:14:20,140
functional programming is filling out

00:14:16,420 --> 00:14:21,760
spreadsheets so next time you start

00:14:20,140 --> 00:14:24,280
making fun of the project managers who's

00:14:21,760 --> 00:14:26,350
you do all kinds of crazy stuff in Excel

00:14:24,280 --> 00:14:30,750
or in google spreadsheets they're doing

00:14:26,350 --> 00:14:30,750
functional programming respect

00:14:31,140 --> 00:14:35,380
and you know you're probably thinking

00:14:33,520 --> 00:14:41,710
about sitting out there thinking now so

00:14:35,380 --> 00:14:42,180
what we're in PHP not in Excel but

00:14:41,710 --> 00:14:44,290
here's the thing

00:14:42,180 --> 00:14:47,530
everything I just described everything I

00:14:44,290 --> 00:14:48,160
just talked about is what you should be

00:14:47,530 --> 00:14:51,010
doing anyway

00:14:48,160 --> 00:14:52,720
most of the principles of functional

00:14:51,010 --> 00:14:55,170
programming while there are languages

00:14:52,720 --> 00:14:58,780
that will enforce them as syntactically

00:14:55,170 --> 00:15:00,340
are simply what in object-oriented

00:14:58,780 --> 00:15:05,440
languages or in procedural languages we

00:15:00,340 --> 00:15:07,660
call good coding practices so let's take

00:15:05,440 --> 00:15:10,630
a look at pure functions first a pure

00:15:07,660 --> 00:15:13,180
function is one that has no side effects

00:15:10,630 --> 00:15:15,700
that is it does not affect the state of

00:15:13,180 --> 00:15:16,990
the world other than taking input and

00:15:15,700 --> 00:15:19,690
returning output it does not print

00:15:16,990 --> 00:15:22,000
anything it does not set any variables

00:15:19,690 --> 00:15:25,180
other than its return value it does not

00:15:22,000 --> 00:15:27,040
take input it does not change the state

00:15:25,180 --> 00:15:29,470
of anything other than computing

00:15:27,040 --> 00:15:32,380
something it has very very specific

00:15:29,470 --> 00:15:34,900
explicit input usually through function

00:15:32,380 --> 00:15:37,140
parameters and very specific output its

00:15:34,900 --> 00:15:40,540
return value that's it

00:15:37,140 --> 00:15:43,210
that's all it does it that means it is

00:15:40,540 --> 00:15:46,180
stateless stateless meaning it does not

00:15:43,210 --> 00:15:48,190
track any values between runs you call a

00:15:46,180 --> 00:15:50,230
function with parameter five to get back

00:15:48,190 --> 00:15:51,730
twelve you called the five again you

00:15:50,230 --> 00:15:53,530
will get back twelve again there is no

00:15:51,730 --> 00:15:57,220
state that is persisted from one run to

00:15:53,530 --> 00:16:00,640
the next clear input clear outputs

00:15:57,220 --> 00:16:03,970
that's it here's an example of a pure

00:16:00,640 --> 00:16:06,460
function this function takes an array of

00:16:03,970 --> 00:16:08,890
we're going to assume strings and a

00:16:06,460 --> 00:16:13,690
string and it builds up some other

00:16:08,890 --> 00:16:16,180
string and returns it the only inputs to

00:16:13,690 --> 00:16:19,720
this function are items and type that's

00:16:16,180 --> 00:16:21,940
it the only output is a string nothing

00:16:19,720 --> 00:16:24,010
in the entirety of the universe changes

00:16:21,940 --> 00:16:26,470
from as a result of this function other

00:16:24,010 --> 00:16:29,800
than returning a value that's a pure

00:16:26,470 --> 00:16:32,020
function that is a good thing what's the

00:16:29,800 --> 00:16:35,650
advantage of a pure function for one it

00:16:32,020 --> 00:16:36,790
is really easy to test because if you

00:16:35,650 --> 00:16:38,440
want to test something you're in a unit

00:16:36,790 --> 00:16:40,930
test it you need to be able to control

00:16:38,440 --> 00:16:43,060
its inputs and then check its output if

00:16:40,930 --> 00:16:43,620
all of its inputs are sitting right

00:16:43,060 --> 00:16:45,660
there

00:16:43,620 --> 00:16:48,000
you and its output is right here for you

00:16:45,660 --> 00:16:49,350
you're done it becomes really simple you

00:16:48,000 --> 00:16:50,640
don't have to set up some environment

00:16:49,350 --> 00:16:53,520
for it it's just right there waiting for

00:16:50,640 --> 00:16:55,620
you you don't get spooky action at a

00:16:53,520 --> 00:16:57,930
distance who's ever had a problem where

00:16:55,620 --> 00:17:03,920
you know you make a change over here and

00:16:57,930 --> 00:17:07,490
then some bug shows up way over here

00:17:03,920 --> 00:17:09,839
normally I have a mark wireless mic

00:17:07,490 --> 00:17:12,600
who's had that kind of problem like what

00:17:09,839 --> 00:17:14,640
I would how are these things in any way

00:17:12,600 --> 00:17:17,069
related that's spooky action at a

00:17:14,640 --> 00:17:18,990
distance and that makes you sad because

00:17:17,069 --> 00:17:24,020
that is how lives are lost debugging

00:17:18,990 --> 00:17:27,000
things please don't be sad

00:17:24,020 --> 00:17:28,679
they're completely self-contained that

00:17:27,000 --> 00:17:32,280
means they are really easy to understand

00:17:28,679 --> 00:17:33,660
I don't need to know oh this value this

00:17:32,280 --> 00:17:35,460
value or this part of this function is

00:17:33,660 --> 00:17:36,870
gonna do this because this global

00:17:35,460 --> 00:17:38,130
variable is set over here by this other

00:17:36,870 --> 00:17:39,510
routine that I'm going to assume is

00:17:38,130 --> 00:17:41,760
already run but if it doesn't then this

00:17:39,510 --> 00:17:42,780
other thing no no no right there the

00:17:41,760 --> 00:17:44,670
code right in front of you is the

00:17:42,780 --> 00:17:48,960
entirety of what you need to know to

00:17:44,670 --> 00:17:51,929
understand this function there's no i/o

00:17:48,960 --> 00:17:54,300
at all so it's not printing anything

00:17:51,929 --> 00:17:56,420
it's not taking in a user input doing

00:17:54,300 --> 00:17:59,100
nothing other than computing something

00:17:56,420 --> 00:18:00,630
and that makes it idempotent which is

00:17:59,100 --> 00:18:04,230
the fancy math mathematical way of

00:18:00,630 --> 00:18:07,170
saying repeatable if before you call

00:18:04,230 --> 00:18:09,630
something with five and returns 12 you

00:18:07,170 --> 00:18:12,210
are mathematically guaranteed I can

00:18:09,630 --> 00:18:13,200
promise you with absolute certainty next

00:18:12,210 --> 00:18:16,410
time you call it with five you will get

00:18:13,200 --> 00:18:19,290
back twelve again and if I call it with

00:18:16,410 --> 00:18:20,510
five one time and six another time and I

00:18:19,290 --> 00:18:22,590
get back whatever the results are

00:18:20,510 --> 00:18:23,940
doesn't matter which order I call it in

00:18:22,590 --> 00:18:26,850
calling it with six we're getting back

00:18:23,940 --> 00:18:28,800
you know 50 calling five will get me

00:18:26,850 --> 00:18:30,240
back twelve and I can order those

00:18:28,800 --> 00:18:31,730
however I want they're completely

00:18:30,240 --> 00:18:35,340
independent of each other

00:18:31,730 --> 00:18:38,040
this makes code easy to understand this

00:18:35,340 --> 00:18:42,179
makes code easy to test easy to follow

00:18:38,040 --> 00:18:43,770
easy to grok that description suits

00:18:42,179 --> 00:18:45,510
actor should sound familiar to a lot of

00:18:43,770 --> 00:18:48,690
people who's been in any of these

00:18:45,510 --> 00:18:51,120
symphony trainings so far today all

00:18:48,690 --> 00:18:54,470
right they talk about this a fair bit

00:18:51,120 --> 00:18:56,600
service objects ever heard that term

00:18:54,470 --> 00:19:00,740
service objects our state

00:18:56,600 --> 00:19:01,550
or they're supposed to be they serve one

00:19:00,740 --> 00:19:05,480
purpose only

00:19:01,550 --> 00:19:08,870
they're very self-contained they are

00:19:05,480 --> 00:19:10,970
supposed to be idempotent and they have

00:19:08,870 --> 00:19:12,680
no side effects unless it's a service

00:19:10,970 --> 00:19:15,830
that's bridging to some kind of aisle

00:19:12,680 --> 00:19:18,650
like a database connection or you know

00:19:15,830 --> 00:19:19,850
an output stream or whatever but aside

00:19:18,650 --> 00:19:21,800
from reading and writing to some

00:19:19,850 --> 00:19:25,550
external Channel with outside of your

00:19:21,800 --> 00:19:29,180
program they have no side effects a good

00:19:25,550 --> 00:19:32,030
service object is a pure function they

00:19:29,180 --> 00:19:35,750
are conceptually exactly the same thing

00:19:32,030 --> 00:19:38,090
and all the benefits of goods service

00:19:35,750 --> 00:19:39,710
objects and good pure functions of apply

00:19:38,090 --> 00:19:43,160
in both directions whoo-hoo sure the

00:19:39,710 --> 00:19:46,820
term iceburg class before nobody a few

00:19:43,160 --> 00:19:49,790
people an iceberg class is a class that

00:19:46,820 --> 00:19:51,890
has only one public method everything

00:19:49,790 --> 00:19:53,450
else is a protected method or a private

00:19:51,890 --> 00:19:56,590
or your call to some other object but

00:19:53,450 --> 00:19:59,480
it's public facing API is one method a

00:19:56,590 --> 00:20:02,510
class or an object with one method on it

00:19:59,480 --> 00:20:03,920
that is a pure function is exactly the

00:20:02,510 --> 00:20:05,870
same thing as a pure function it's just

00:20:03,920 --> 00:20:10,090
a syntactic difference it is

00:20:05,870 --> 00:20:13,430
conceptually the exact same thing

00:20:10,090 --> 00:20:16,850
immutable variables immutable variables

00:20:13,430 --> 00:20:18,650
are not variable mmm they're variable

00:20:16,850 --> 00:20:20,930
that once sense cannot have its value

00:20:18,650 --> 00:20:23,720
changed they are placeholders for a

00:20:20,930 --> 00:20:27,740
value rather than state that is going to

00:20:23,720 --> 00:20:29,330
change over time now if you have the

00:20:27,740 --> 00:20:30,470
ability to enforce that then you can

00:20:29,330 --> 00:20:32,780
make some very interesting memory

00:20:30,470 --> 00:20:34,160
optimizations like not copying a value

00:20:32,780 --> 00:20:35,750
in memory because you know it's not

00:20:34,160 --> 00:20:38,690
going to change so you don't need to

00:20:35,750 --> 00:20:41,110
duplicate it just in case it reduces

00:20:38,690 --> 00:20:43,520
that spooky action at a distance because

00:20:41,110 --> 00:20:46,520
if you know you've got a value here and

00:20:43,520 --> 00:20:48,530
the value here and here cannot change

00:20:46,520 --> 00:20:50,690
that value I know I can rely on this

00:20:48,530 --> 00:20:52,820
value not changing over here that's

00:20:50,690 --> 00:20:54,140
useful because of this values gonna

00:20:52,820 --> 00:20:59,030
change out from under me that's gonna

00:20:54,140 --> 00:21:00,850
make me very sad and the whatever comes

00:20:59,030 --> 00:21:03,650
down to is state is where bugs come from

00:21:00,850 --> 00:21:05,270
who has spent time with a real-time

00:21:03,650 --> 00:21:07,190
debugger or something like that or maybe

00:21:05,270 --> 00:21:08,540
print statements stepping through a

00:21:07,190 --> 00:21:09,090
program because you know at some point

00:21:08,540 --> 00:21:12,090
he

00:21:09,090 --> 00:21:13,710
this value is this string and down here

00:21:12,090 --> 00:21:16,020
it's this other string which is wrong

00:21:13,710 --> 00:21:18,120
and somewhere in these 50 thousand lines

00:21:16,020 --> 00:21:20,790
of code had changed and where did to

00:21:18,120 --> 00:21:23,970
change my god who has lost hours of

00:21:20,790 --> 00:21:25,500
their life to that that's what I thought

00:21:23,970 --> 00:21:29,730
more people than a few spreadsheets

00:21:25,500 --> 00:21:31,590
alright yeah if you can rely on the

00:21:29,730 --> 00:21:33,300
value of not changing you can very

00:21:31,590 --> 00:21:35,640
easily break it down to the individual

00:21:33,300 --> 00:21:38,160
pieces rather than oh I have to trace

00:21:35,640 --> 00:21:41,370
this very this values change to over

00:21:38,160 --> 00:21:41,790
time you want to be an enemy of the

00:21:41,370 --> 00:21:46,020
state

00:21:41,790 --> 00:21:49,410
don't tell the NSA I said that because

00:21:46,020 --> 00:21:51,930
that gives you much easier ability to

00:21:49,410 --> 00:21:53,610
focus on parts of the problem and it

00:21:51,930 --> 00:21:56,580
also really forces you to have small

00:21:53,610 --> 00:21:57,540
functions or small classes that are not

00:21:56,580 --> 00:21:59,520
going to be tracking state over time

00:21:57,540 --> 00:22:01,890
they're going to do exactly one thing

00:21:59,520 --> 00:22:04,350
because the code won't let you do more

00:22:01,890 --> 00:22:06,270
than one thing and code that does one

00:22:04,350 --> 00:22:08,820
thing and one thing only is easier to

00:22:06,270 --> 00:22:12,660
understand test debug and so forth and

00:22:08,820 --> 00:22:14,720
reuse this should be familiar value

00:22:12,660 --> 00:22:19,620
objects you've heard that term before

00:22:14,720 --> 00:22:21,900
okay a value object is an object in oh

00:22:19,620 --> 00:22:28,650
oh that once it's constructors done

00:22:21,900 --> 00:22:31,350
running its values cannot change example

00:22:28,650 --> 00:22:34,590
here if you have a class that represents

00:22:31,350 --> 00:22:36,180
a point and as an x and a y properties

00:22:34,590 --> 00:22:38,070
you set those in the constructor you

00:22:36,180 --> 00:22:40,620
cannot then change that if you want to

00:22:38,070 --> 00:22:42,750
get another point that is that you know

00:22:40,620 --> 00:22:44,790
point moved over then you get a new

00:22:42,750 --> 00:22:47,520
point object it happens to be somewhere

00:22:44,790 --> 00:22:49,460
relative that first one who's had to

00:22:47,520 --> 00:22:52,440
deal with a date/time object in PHP

00:22:49,460 --> 00:22:54,390
which changes itself as it goes which

00:22:52,440 --> 00:22:56,220
means you can't actually say all right

00:22:54,390 --> 00:22:57,930
what's this value going to be you know

00:22:56,220 --> 00:23:00,270
what's the date a month for now or a

00:22:57,930 --> 00:23:02,460
week from now oh what crap I deleted my

00:23:00,270 --> 00:23:06,000
first Valley now what I what I do that's

00:23:02,460 --> 00:23:07,440
because that's not a value object value

00:23:06,000 --> 00:23:09,660
objects make testing a lot easier

00:23:07,440 --> 00:23:11,910
because again you know what's not going

00:23:09,660 --> 00:23:13,880
to happen you know what can't happen so

00:23:11,910 --> 00:23:17,450
you don't need to bother testing it

00:23:13,880 --> 00:23:19,560
again less spooky action at a distance

00:23:17,450 --> 00:23:22,370
they are very often easier to read

00:23:19,560 --> 00:23:24,530
because they lead to code that forces

00:23:22,370 --> 00:23:27,940
to have a clear structure rather than

00:23:24,530 --> 00:23:30,410
just oh this value is going to change I

00:23:27,940 --> 00:23:32,030
means you can reuse these objects safely

00:23:30,410 --> 00:23:33,470
if you have an object that represents

00:23:32,030 --> 00:23:36,740
more than just you know points on a

00:23:33,470 --> 00:23:39,650
graph but some rich value say a node or

00:23:36,740 --> 00:23:41,690
a user we can reuse it and get the

00:23:39,650 --> 00:23:43,490
memory savings of reusing it without

00:23:41,690 --> 00:23:46,120
having to worry about oh wait it changed

00:23:43,490 --> 00:23:49,010
over here now everything else is broken

00:23:46,120 --> 00:23:50,210
why is we taking a bad thing well let's

00:23:49,010 --> 00:23:54,340
have a look at this code got this

00:23:50,210 --> 00:23:56,150
function foo it takes two parameters and

00:23:54,340 --> 00:23:58,730
there's a bug there they should be

00:23:56,150 --> 00:24:02,480
passing a second second parameter in

00:23:58,730 --> 00:24:05,750
here and we call get bar get that value

00:24:02,480 --> 00:24:07,880
out then I format a and make changes to

00:24:05,750 --> 00:24:14,200
a and then we output the formatted

00:24:07,880 --> 00:24:16,309
string so and bars value 1 all right

00:24:14,200 --> 00:24:22,880
who knows what Valley is going to come

00:24:16,309 --> 00:24:26,600
out here you think value 1 nope where'd

00:24:22,880 --> 00:24:28,730
that come from I had absolutely no idea

00:24:26,600 --> 00:24:31,250
I wrote this code I have no idea where

00:24:28,730 --> 00:24:33,350
that value came from the get bar changed

00:24:31,250 --> 00:24:35,510
the value didn't make changes affect the

00:24:33,350 --> 00:24:37,820
the formatted string already you know

00:24:35,510 --> 00:24:39,200
that has that kind of your back change I

00:24:37,820 --> 00:24:42,320
have no idea

00:24:39,200 --> 00:24:44,000
I can't tell that's a bad thing this is

00:24:42,320 --> 00:24:47,990
a bad sign for your code if you can't

00:24:44,000 --> 00:24:49,970
tell what's going on and finally

00:24:47,990 --> 00:24:52,000
first-class functions these are the fun

00:24:49,970 --> 00:24:52,000
ones

00:24:53,970 --> 00:24:58,750
first class functions higher-order

00:24:56,020 --> 00:25:03,130
functions these are functions that can

00:24:58,750 --> 00:25:04,630
be a variable and therefore they can be

00:25:03,130 --> 00:25:06,670
a parameter to another function

00:25:04,630 --> 00:25:09,429
they can even be returned from a

00:25:06,670 --> 00:25:11,559
function anything you can do with a

00:25:09,429 --> 00:25:13,150
variable that is an int or a string or

00:25:11,559 --> 00:25:15,730
an object you can do with the variable

00:25:13,150 --> 00:25:20,559
that is a function that's a first-class

00:25:15,730 --> 00:25:24,059
function in PHP we have disability added

00:25:20,559 --> 00:25:26,890
in 5.3 called anonymous functions and

00:25:24,059 --> 00:25:28,809
the syntax for it looks like this we're

00:25:26,890 --> 00:25:31,210
going to find a function that takes one

00:25:28,809 --> 00:25:34,000
parameter and returns that parameter

00:25:31,210 --> 00:25:35,950
times five and we're going to assign

00:25:34,000 --> 00:25:39,370
that function that piece of executable

00:25:35,950 --> 00:25:42,309
logic to a value and then we're going to

00:25:39,370 --> 00:25:47,380
invoke that value with of with some

00:25:42,309 --> 00:25:50,610
parameter nice simple approach but can

00:25:47,380 --> 00:25:53,320
have a lot of really powerful effects

00:25:50,610 --> 00:25:56,440
for instance you heard of strategy

00:25:53,320 --> 00:25:58,750
pattern strategy and you have an object

00:25:56,440 --> 00:25:59,950
that does whatever it's going to do but

00:25:58,750 --> 00:26:01,330
it's missing part of its algorithm you

00:25:59,950 --> 00:26:03,070
pass another object into it

00:26:01,330 --> 00:26:05,140
why pass an object in why not just pass

00:26:03,070 --> 00:26:06,730
a function here use this function that

00:26:05,140 --> 00:26:10,000
is your the rest of your algorithm done

00:26:06,730 --> 00:26:11,980
nice and simple can lazy evaluate things

00:26:10,000 --> 00:26:14,440
that function we just define a moment

00:26:11,980 --> 00:26:18,520
ago doesn't actually run it doesn't do

00:26:14,440 --> 00:26:21,070
anything until we actually call it so if

00:26:18,520 --> 00:26:23,380
we have a function that contains

00:26:21,070 --> 00:26:25,660
information that you know the logic to

00:26:23,380 --> 00:26:28,090
compute something we want or something

00:26:25,660 --> 00:26:31,059
that we maybe want we can define that

00:26:28,090 --> 00:26:32,710
and then later on call it or not if we

00:26:31,059 --> 00:26:35,290
call it we get back the value that we

00:26:32,710 --> 00:26:36,550
wanted if we don't call it we never have

00:26:35,290 --> 00:26:39,250
to spend the time computing that value

00:26:36,550 --> 00:26:41,980
we don't need anonymous functions give

00:26:39,250 --> 00:26:44,320
us that ability may give ability to do

00:26:41,980 --> 00:26:45,929
something called partial evaluation or

00:26:44,320 --> 00:26:48,010
curry we'll get to that in a moment

00:26:45,929 --> 00:26:50,260
or there's a really cool shorthand for

00:26:48,010 --> 00:26:51,570
objects because really that's what PHP

00:26:50,260 --> 00:26:54,150
does under the hood

00:26:51,570 --> 00:26:56,410
case in point here's a nice simple

00:26:54,150 --> 00:26:58,660
anonymous function it takes two

00:26:56,410 --> 00:27:00,910
parameters and returns true or false

00:26:58,660 --> 00:27:02,410
depending on if they are equal by the

00:27:00,910 --> 00:27:05,800
definition of equal that we're defining

00:27:02,410 --> 00:27:07,000
and then we can call it just like any

00:27:05,800 --> 00:27:09,520
other function

00:27:07,000 --> 00:27:12,820
you know fine pair passing two cards and

00:27:09,520 --> 00:27:15,580
get back a boolean what PHP does under

00:27:12,820 --> 00:27:19,750
the hood is compile this to a class that

00:27:15,580 --> 00:27:23,110
looks like this as a 5/3 any class can

00:27:19,750 --> 00:27:24,940
have an invoke magic method on it and if

00:27:23,110 --> 00:27:26,860
you call an object as if it were a

00:27:24,940 --> 00:27:29,020
function then underscore invoke gets

00:27:26,860 --> 00:27:31,090
called this is what happens behind the

00:27:29,020 --> 00:27:34,060
scenes in the PHP engine when you use

00:27:31,090 --> 00:27:36,900
anonymous functions could you just write

00:27:34,060 --> 00:27:41,950
all of your code this way instead yes

00:27:36,900 --> 00:27:44,170
would it take more work to do yes this

00:27:41,950 --> 00:27:46,840
is a much shorter and easier way of

00:27:44,170 --> 00:27:48,760
writing this code and you're not

00:27:46,840 --> 00:27:50,230
polluting your namespace with I've got

00:27:48,760 --> 00:27:51,280
to name a whole bunch of extra classes

00:27:50,230 --> 00:27:52,660
that only get called once and they're

00:27:51,280 --> 00:27:54,880
gonna live over here in this other file

00:27:52,660 --> 00:27:59,260
no no all of my code is right here in

00:27:54,880 --> 00:28:01,780
the same place you can also when you

00:27:59,260 --> 00:28:04,450
define a function say you know what I

00:28:01,780 --> 00:28:06,760
want to access some value from my

00:28:04,450 --> 00:28:09,100
context for my lexical context

00:28:06,760 --> 00:28:10,990
syntactically here

00:28:09,100 --> 00:28:12,040
so in a lot of languages when you have

00:28:10,990 --> 00:28:15,250
anonymous functions that happens

00:28:12,040 --> 00:28:17,500
automatically when you use the name of a

00:28:15,250 --> 00:28:19,270
variable it will magically figure out if

00:28:17,500 --> 00:28:20,470
it's from the parent scope or not PHP

00:28:19,270 --> 00:28:22,240
will net forces you to specify it

00:28:20,470 --> 00:28:24,040
explicitly which i think is a really

00:28:22,240 --> 00:28:27,730
really good thing who's written

00:28:24,040 --> 00:28:29,170
JavaScript who's had an anonymous

00:28:27,730 --> 00:28:30,820
function JavaScript where you reference

00:28:29,170 --> 00:28:32,110
a variable and you're like oh wait

00:28:30,820 --> 00:28:34,030
that's not the variable in my function

00:28:32,110 --> 00:28:35,320
it's the variable outside my function or

00:28:34,030 --> 00:28:38,950
maybe it is the variable inside my

00:28:35,320 --> 00:28:40,720
function right yeah in PHP it's

00:28:38,950 --> 00:28:43,510
syntactically explicit which I really

00:28:40,720 --> 00:28:45,180
like a lot of purists think is wrong but

00:28:43,510 --> 00:28:49,060
this makes it a lot easier to avoid bugs

00:28:45,180 --> 00:28:50,800
so in this case we're saying use wild

00:28:49,060 --> 00:28:53,290
that use that value and then the value

00:28:50,800 --> 00:28:55,930
wild is available inside our function

00:28:53,290 --> 00:29:00,100
when we call it whenever we end up

00:28:55,930 --> 00:29:01,870
calling it much later this is

00:29:00,100 --> 00:29:04,210
conceptually and again this is exactly

00:29:01,870 --> 00:29:05,980
what happens inside the PHP engine the

00:29:04,210 --> 00:29:08,290
same is writing a class but take

00:29:05,980 --> 00:29:10,060
something in its constructor this is

00:29:08,290 --> 00:29:12,880
what happens under the hood in the PHP

00:29:10,060 --> 00:29:16,330
engine could you write this yourself

00:29:12,880 --> 00:29:17,890
just you know save the value in from the

00:29:16,330 --> 00:29:20,309
constructor to a property and then use

00:29:17,890 --> 00:29:23,440
it when you call it later yes

00:29:20,309 --> 00:29:25,600
would it be twice as long yes

00:29:23,440 --> 00:29:28,120
do you want to writes twice as much code

00:29:25,600 --> 00:29:33,780
to get the same effect no at least I

00:29:28,120 --> 00:29:36,929
don't and all of you do you can also

00:29:33,780 --> 00:29:40,179
because a function is just the value use

00:29:36,929 --> 00:29:42,130
another function so here we've got our

00:29:40,179 --> 00:29:45,910
we're gonna factor out that is wild

00:29:42,130 --> 00:29:48,220
logic to a separate function and we've

00:29:45,910 --> 00:29:52,570
got you know it takes a card and it uses

00:29:48,220 --> 00:29:54,669
that wild value and then is pair is

00:29:52,570 --> 00:29:59,470
going to take that is wilds function

00:29:54,669 --> 00:30:01,600
adds a closure so when when you

00:29:59,470 --> 00:30:03,100
reference a variable like this the fancy

00:30:01,600 --> 00:30:05,230
way of saying it is a a closure is

00:30:03,100 --> 00:30:06,610
created over that value don't worry

00:30:05,230 --> 00:30:09,100
about that closure people like to use

00:30:06,610 --> 00:30:12,150
closure to mean a Lammas function PHP

00:30:09,100 --> 00:30:17,500
even does in the engine so roll with it

00:30:12,150 --> 00:30:26,700
but then when we call fine pair it will

00:30:17,500 --> 00:30:26,700
simply call is wild for us what's that I

00:30:26,880 --> 00:30:32,250
keep giving this talk and I had didn't

00:30:28,990 --> 00:30:34,600
notice that typo before yes it is yeah

00:30:32,250 --> 00:30:40,179
second function card one card to or c1

00:30:34,600 --> 00:30:42,929
and c2 this should look familiar this

00:30:40,179 --> 00:30:51,850
concept I broke anyone heard of

00:30:42,929 --> 00:30:55,270
dependency injection right so let's

00:30:51,850 --> 00:30:58,650
write a class that uses this concept we

00:30:55,270 --> 00:31:01,720
have pH B's magic get and set methods

00:30:58,650 --> 00:31:04,299
what those do is if you set a value that

00:31:01,720 --> 00:31:06,370
doesn't exist on the class or on an

00:31:04,299 --> 00:31:08,230
object of that class then it calls this

00:31:06,370 --> 00:31:09,760
function instead and if you try and

00:31:08,230 --> 00:31:11,650
access a property that doesn't exist it

00:31:09,760 --> 00:31:15,100
calls this function instead there this

00:31:11,650 --> 00:31:17,290
function so let's say when you try and

00:31:15,100 --> 00:31:19,960
set a value you're going to set it with

00:31:17,290 --> 00:31:21,669
a function with an anonymous function

00:31:19,960 --> 00:31:24,640
with a closure and we're just going to

00:31:21,669 --> 00:31:26,679
save that function to run later and then

00:31:24,640 --> 00:31:31,600
we'll try to access it then we're going

00:31:26,679 --> 00:31:33,280
to run whatever that function was and so

00:31:31,600 --> 00:31:36,460
we can now use it like this

00:31:33,280 --> 00:31:41,820
create art container object and we're

00:31:36,460 --> 00:31:46,120
going to assign this Khan property quote

00:31:41,820 --> 00:31:48,520
this anonymous function which is not run

00:31:46,120 --> 00:31:51,760
yet and that function is going to access

00:31:48,520 --> 00:31:55,150
the info property of the container of

00:31:51,760 --> 00:31:56,470
the object and info we define we can

00:31:55,150 --> 00:31:59,230
define it later that's fine

00:31:56,470 --> 00:32:02,710
to return this array of configuration

00:31:59,230 --> 00:32:08,860
values and so when we then ask for that

00:32:02,710 --> 00:32:10,809
Khan property get is invoked and it

00:32:08,860 --> 00:32:12,520
looks up that function we just assign

00:32:10,809 --> 00:32:17,110
and calls that function that returns its

00:32:12,520 --> 00:32:19,870
value that function is right here which

00:32:17,110 --> 00:32:22,690
is going to look up info what's going to

00:32:19,870 --> 00:32:26,710
call get with the I get the other

00:32:22,690 --> 00:32:28,890
function which returns our configuration

00:32:26,710 --> 00:32:31,570
parameters put that into that object

00:32:28,890 --> 00:32:35,490
instantiate it and returns that and we

00:32:31,570 --> 00:32:39,250
now have a nice cleanly injected

00:32:35,490 --> 00:32:40,780
database connection we just wrote a

00:32:39,250 --> 00:32:46,270
dependency injection container on one

00:32:40,780 --> 00:32:48,100
slide which is pretty damn cool you want

00:32:46,270 --> 00:32:49,059
to see more of this technique have a

00:32:48,100 --> 00:32:50,679
look at pimple

00:32:49,059 --> 00:32:52,630
it's a PHP dependency injection

00:32:50,679 --> 00:32:55,059
container written by Febby on pompton CA

00:32:52,630 --> 00:32:57,250
the project lead of Symphony built on

00:32:55,059 --> 00:32:59,559
exactly this model it does more than

00:32:57,250 --> 00:33:02,169
this quite a bit more than this actually

00:32:59,559 --> 00:33:04,240
but it fits in like 150 lines of code a

00:33:02,169 --> 00:33:07,120
complete dependency injection container

00:33:04,240 --> 00:33:09,539
just using anonymous functions in 150

00:33:07,120 --> 00:33:09,539
lines of code

00:33:12,509 --> 00:33:16,859
what else can we do I'm just with this

00:33:14,759 --> 00:33:20,789
concept who's ever had to import data

00:33:16,859 --> 00:33:26,009
into a system everyone's done everything

00:33:20,789 --> 00:33:29,159
that's awesome so let's try it defining

00:33:26,009 --> 00:33:31,549
an importer that looks like this we're

00:33:29,159 --> 00:33:35,579
going to we have an importer class and

00:33:31,549 --> 00:33:39,359
we're going to you know take a mapping

00:33:35,579 --> 00:33:42,059
object and that mapping here then we're

00:33:39,359 --> 00:33:45,119
going to get a sum source value coming

00:33:42,059 --> 00:33:47,639
in out of some third party system or CSV

00:33:45,119 --> 00:33:50,729
file or you know whatever data you're

00:33:47,639 --> 00:33:53,159
importing from we're going to create one

00:33:50,729 --> 00:33:56,009
of our local objects whatever it is node

00:33:53,159 --> 00:33:57,809
some other entity you know just records

00:33:56,009 --> 00:34:00,869
in a database table whatever it is

00:33:57,809 --> 00:34:03,479
you're doing and then we're going to

00:34:00,869 --> 00:34:06,389
iterate over the set of mapping

00:34:03,479 --> 00:34:08,700
instructions and for each one of those

00:34:06,389 --> 00:34:11,819
we're going to invoke whatever that

00:34:08,700 --> 00:34:15,809
function is and set the result that

00:34:11,819 --> 00:34:19,829
mapping object looks like this we have

00:34:15,809 --> 00:34:23,869
an array of caller balls an array of

00:34:19,829 --> 00:34:27,419
functions and so when we get to title

00:34:23,869 --> 00:34:28,889
then we'll call the title callback which

00:34:27,419 --> 00:34:33,149
is this function and has a reference

00:34:28,889 --> 00:34:34,319
this other other service and it's going

00:34:33,149 --> 00:34:37,980
to do whatever it's going to do to pull

00:34:34,319 --> 00:34:40,279
out the value we want then body it's

00:34:37,980 --> 00:34:42,059
going to do what it wants to do and

00:34:40,279 --> 00:34:44,429
extra we're just gonna hard code

00:34:42,059 --> 00:34:46,769
something in here and we just return

00:34:44,429 --> 00:34:50,399
back that array of importing commands

00:34:46,769 --> 00:34:54,569
array of mapping commands which means we

00:34:50,399 --> 00:34:57,420
can then import any values we want just

00:34:54,569 --> 00:35:00,180
by adding stuff to that array and then

00:34:57,420 --> 00:35:03,450
we can call it very simply by taking

00:35:00,180 --> 00:35:06,240
some external object passing it to map

00:35:03,450 --> 00:35:09,809
date in and we get our our object back

00:35:06,240 --> 00:35:13,799
to safe we just wrote an entire import

00:35:09,809 --> 00:35:15,269
engine on one slide this isn't made up

00:35:13,799 --> 00:35:18,660
either we actually did this on a project

00:35:15,269 --> 00:35:20,819
at Palantir last year this is slightly

00:35:18,660 --> 00:35:22,339
simplified code from an actual

00:35:20,819 --> 00:35:25,500
production project

00:35:22,339 --> 00:35:27,359
if you'll also notice these objects are

00:35:25,500 --> 00:35:31,230
immutable their items are there

00:35:27,359 --> 00:35:33,630
idempotent so I can reuse them I can

00:35:31,230 --> 00:35:35,550
import as many records as I want and the

00:35:33,630 --> 00:35:38,490
state will never change its state of

00:35:35,550 --> 00:35:41,790
these objects never changes I can run

00:35:38,490 --> 00:35:44,190
that over 10,000 import records from a

00:35:41,790 --> 00:35:46,260
third-party system I could chop the data

00:35:44,190 --> 00:35:48,869
in half and run it in two separate

00:35:46,260 --> 00:35:51,270
processes with you know five thousand

00:35:48,869 --> 00:35:54,359
each and it worked just as well because

00:35:51,270 --> 00:35:56,040
there's the the services themselves are

00:35:54,359 --> 00:35:59,280
immutable because they're idempotent I

00:35:56,040 --> 00:36:01,230
can mathematically prove that there can

00:35:59,280 --> 00:36:04,530
be no bugs between the two from

00:36:01,230 --> 00:36:09,869
splitting the problem up that way that's

00:36:04,530 --> 00:36:11,849
cool that functional programming has a

00:36:09,869 --> 00:36:13,770
lot of tools to it once you have these

00:36:11,849 --> 00:36:15,630
assumptions in place there's a lot that

00:36:13,770 --> 00:36:18,750
you can do we're gonna go through a

00:36:15,630 --> 00:36:21,210
number of these here first one who's

00:36:18,750 --> 00:36:24,060
heard the phrase MapReduce before all

00:36:21,210 --> 00:36:26,400
right MapReduce is useful for

00:36:24,060 --> 00:36:30,030
embarrassingly parallel problems that is

00:36:26,400 --> 00:36:32,339
problems where you know you're doing

00:36:30,030 --> 00:36:34,560
something to a lot of values but there's

00:36:32,339 --> 00:36:37,710
really nothing between one value in the

00:36:34,560 --> 00:36:40,410
next that is going to impact it it

00:36:37,710 --> 00:36:42,030
consists of two parts map which is you

00:36:40,410 --> 00:36:44,359
take whatever your problem space is and

00:36:42,030 --> 00:36:48,540
split it up into a whole bunch of

00:36:44,359 --> 00:36:50,190
identical sub problems and then you

00:36:48,540 --> 00:36:53,970
distribute that each of those sub

00:36:50,190 --> 00:36:56,190
problems to separate workers and then

00:36:53,970 --> 00:36:58,020
reduce which is alright those workers

00:36:56,190 --> 00:37:01,290
have finished collect all of those

00:36:58,020 --> 00:37:03,180
answers back together and runs them back

00:37:01,290 --> 00:37:06,359
up into the results of your original

00:37:03,180 --> 00:37:08,010
problem this is really useful if you

00:37:06,359 --> 00:37:10,470
have really really epically huge

00:37:08,010 --> 00:37:13,770
datasets like let's say Google or

00:37:10,470 --> 00:37:17,339
Twitter or Amazon if you want to analyze

00:37:13,770 --> 00:37:19,349
tweets that's an easy MapReduce problem

00:37:17,339 --> 00:37:21,150
because you're going to analyze you're

00:37:19,349 --> 00:37:22,859
not going to analyze fifty thousand

00:37:21,150 --> 00:37:26,130
tweets or fifty million tweets you can

00:37:22,859 --> 00:37:27,810
analyze one tweet 50 million times and

00:37:26,130 --> 00:37:31,830
you can do that in parallel if you

00:37:27,810 --> 00:37:33,859
wanted to and this could get very very

00:37:31,830 --> 00:37:34,980
complicated there are some very large

00:37:33,859 --> 00:37:36,300
very

00:37:34,980 --> 00:37:39,720
expensive systems that do this on a

00:37:36,300 --> 00:37:42,740
large scale or in PHP we have a function

00:37:39,720 --> 00:37:47,270
called array map who's used the rain map

00:37:42,740 --> 00:37:47,270
that's Map Reduce that's all it is

00:37:47,310 --> 00:37:51,359
the second parameter it should be the

00:37:48,840 --> 00:37:53,580
first parameter to any call 'evil it to

00:37:51,359 --> 00:37:55,440
array map can be any callable that is

00:37:53,580 --> 00:37:59,430
name of a function which you've probably

00:37:55,440 --> 00:38:02,880
used before an anonymous function or an

00:37:59,430 --> 00:38:08,160
array representing a method of an object

00:38:02,880 --> 00:38:09,600
or method of a static class you've

00:38:08,160 --> 00:38:11,190
probably done this before where you had

00:38:09,600 --> 00:38:12,420
some function you defined that's a

00:38:11,190 --> 00:38:13,050
one-off function then you put its name

00:38:12,420 --> 00:38:14,760
in here

00:38:13,050 --> 00:38:16,020
you don't need the one-off function

00:38:14,760 --> 00:38:17,940
somewhere else to keep track of the

00:38:16,020 --> 00:38:21,030
logic is right here you can inline it

00:38:17,940 --> 00:38:24,300
all at once because it's just a value a

00:38:21,030 --> 00:38:26,760
function can just be a value how a map

00:38:24,300 --> 00:38:29,040
also lets you do merging of arrays so

00:38:26,760 --> 00:38:31,980
pass in two arrays and get back one

00:38:29,040 --> 00:38:34,859
results so like add together or multiply

00:38:31,980 --> 00:38:41,940
together parallel values from two arrays

00:38:34,859 --> 00:38:43,560
and you can put in any set of any combo

00:38:41,940 --> 00:38:46,530
so in this case it's the method a method

00:38:43,560 --> 00:38:50,190
of the object it's a very wonky syntax

00:38:46,530 --> 00:38:54,180
but hey it's PHP what do you want and

00:38:50,190 --> 00:38:55,920
this is really great it's effectively

00:38:54,180 --> 00:38:58,770
the same thing is doing it for each but

00:38:55,920 --> 00:39:01,380
it separates your application logic from

00:38:58,770 --> 00:39:03,630
your loop it means you're looping code

00:39:01,380 --> 00:39:05,760
can be completely separate from your

00:39:03,630 --> 00:39:07,500
code that's doing the actual work now I

00:39:05,760 --> 00:39:09,420
can unit test the code that does the

00:39:07,500 --> 00:39:14,250
actual work without having to think

00:39:09,420 --> 00:39:16,770
about loose separate your concerns is it

00:39:14,250 --> 00:39:18,720
slower than doing for each yes because

00:39:16,770 --> 00:39:19,830
you have extra function calls is it

00:39:18,720 --> 00:39:22,260
slower enough to matter

00:39:19,830 --> 00:39:23,310
no eliminate one SQL query from your

00:39:22,260 --> 00:39:25,350
system and reload you will more than

00:39:23,310 --> 00:39:26,100
make up for the time spent on a couple

00:39:25,350 --> 00:39:28,380
of function calls

00:39:26,100 --> 00:39:32,119
if you benchmark that and find something

00:39:28,380 --> 00:39:32,119
different turn off X debug and try again

00:39:33,230 --> 00:39:40,020
now one problem with array map is it

00:39:37,440 --> 00:39:42,690
does not work on iterator objects it

00:39:40,020 --> 00:39:44,940
only works on actual arrays which is a

00:39:42,690 --> 00:39:46,740
problem but let's see if we can work

00:39:44,940 --> 00:39:48,060
around that and do things declaratively

00:39:46,740 --> 00:39:51,550
in PHP

00:39:48,060 --> 00:39:53,920
so if we wanted to do it the old-school

00:39:51,550 --> 00:39:57,369
way and import a whole bunch of records

00:39:53,920 --> 00:39:59,230
then we have some array of the data

00:39:57,369 --> 00:40:02,140
coming in on a ray of you know lines out

00:39:59,230 --> 00:40:04,180
of a CSV file or whatever and we just

00:40:02,140 --> 00:40:08,020
iterate over them and run that importer

00:40:04,180 --> 00:40:08,980
on each record all right can we do

00:40:08,020 --> 00:40:10,690
better than that can we just

00:40:08,980 --> 00:40:14,650
declaratively say I want you to operate

00:40:10,690 --> 00:40:17,320
on this whole array well we could do it

00:40:14,650 --> 00:40:19,240
with an array but if I'm importing a ton

00:40:17,320 --> 00:40:20,080
of data I don't want to pull it all into

00:40:19,240 --> 00:40:22,060
memory at once

00:40:20,080 --> 00:40:23,619
that'll be terrible I want to build an

00:40:22,060 --> 00:40:26,650
iterator that will load stuff slowly

00:40:23,619 --> 00:40:29,530
line at a time out of my CSV file or web

00:40:26,650 --> 00:40:32,710
service or whatever so it's really easy

00:40:29,530 --> 00:40:37,359
to write a function that does a ring map

00:40:32,710 --> 00:40:38,350
on an iterator it's very simple we're

00:40:37,359 --> 00:40:43,540
just really just wrapping the for each

00:40:38,350 --> 00:40:47,020
and now we can say apply that mapping

00:40:43,540 --> 00:40:49,990
logic to everything that iterator and we

00:40:47,020 --> 00:40:52,119
will get back on an array of our mapped

00:40:49,990 --> 00:40:57,220
imported objects our note objects or

00:40:52,119 --> 00:41:00,280
whatever now look that could we go a

00:40:57,220 --> 00:41:02,020
step further and not end up having a

00:41:00,280 --> 00:41:03,970
gigantic array of all of our nodes or

00:41:02,020 --> 00:41:07,020
what of our target objects could we just

00:41:03,970 --> 00:41:09,070
save each one on the fly yes we could

00:41:07,020 --> 00:41:12,240
I'll leave that as an exercise to the

00:41:09,070 --> 00:41:13,660
reader I only got so much time here

00:41:12,240 --> 00:41:16,119
memoization

00:41:13,660 --> 00:41:19,869
is they fancy academic way of saying

00:41:16,119 --> 00:41:22,000
result caching that's all it is remember

00:41:19,869 --> 00:41:24,310
pure functions have the same input get

00:41:22,000 --> 00:41:26,740
the same output every time very

00:41:24,310 --> 00:41:28,720
predictably mathematically provable so

00:41:26,740 --> 00:41:30,550
if you get the same input why bother

00:41:28,720 --> 00:41:33,910
computing the output if you can just

00:41:30,550 --> 00:41:35,170
remember it from last time right you

00:41:33,910 --> 00:41:36,580
have probably done this before I can

00:41:35,170 --> 00:41:38,050
guarantee you you have seen code like

00:41:36,580 --> 00:41:40,600
this at some point in your career

00:41:38,050 --> 00:41:42,400
Drupal needs to be full of it that came

00:41:40,600 --> 00:41:45,930
out wrong

00:41:42,400 --> 00:41:48,610
drupal used to use this technique a lot

00:41:45,930 --> 00:41:51,820
where you have some function you

00:41:48,610 --> 00:41:54,070
maintain a static if a value is not sets

00:41:51,820 --> 00:41:55,300
you go and compute it and cache it to

00:41:54,070 --> 00:41:57,160
the static and then just return it out

00:41:55,300 --> 00:41:58,660
of that cache next time you call it

00:41:57,160 --> 00:42:01,540
great it's already in the static cache

00:41:58,660 --> 00:42:05,770
you just return it yeah that's wonderful

00:42:01,540 --> 00:42:07,750
it's simple it's easy but it means

00:42:05,770 --> 00:42:10,240
you're confusing your actual business

00:42:07,750 --> 00:42:12,730
logic that whatever that expensive

00:42:10,240 --> 00:42:15,820
operation is with your caching you're

00:42:12,730 --> 00:42:18,730
tightly coupling those also what happens

00:42:15,820 --> 00:42:22,630
when you try to unit test this all right

00:42:18,730 --> 00:42:24,970
all right we had to build all kinds of

00:42:22,630 --> 00:42:26,470
hideous hacks into Drupal to get around

00:42:24,970 --> 00:42:28,350
the fact that we kept doing this and it

00:42:26,470 --> 00:42:30,220
was breaking all of our unit tests

00:42:28,350 --> 00:42:32,370
sometimes you have functions I have an

00:42:30,220 --> 00:42:34,780
extra reset parameter it is not Knut's

00:42:32,370 --> 00:42:36,430
others we've got this Drupal static

00:42:34,780 --> 00:42:37,810
function you've probably used those are

00:42:36,430 --> 00:42:43,330
all workaround so the fact that this is

00:42:37,810 --> 00:42:45,160
a bad way to do it instead you know so

00:42:43,330 --> 00:42:47,410
let's take a look at this function this

00:42:45,160 --> 00:42:50,140
is computing factorial mathematical

00:42:47,410 --> 00:42:53,650
concepts five factorial is 5 times 4

00:42:50,140 --> 00:42:55,960
times 3 times 2 times 1 4 factorial is 4

00:42:53,650 --> 00:42:58,840
times 3 times 2 times 1 so 5 factorial

00:42:55,960 --> 00:43:00,550
is 4 factorial times 5 still with me

00:42:58,840 --> 00:43:05,650
am I getting flashbacks to high school

00:43:00,550 --> 00:43:07,240
now all right so this is exactly how you

00:43:05,650 --> 00:43:09,670
would define that as an anonymous

00:43:07,240 --> 00:43:13,930
function PHP so we can we're defining it

00:43:09,670 --> 00:43:16,060
recursively and we're referencing our

00:43:13,930 --> 00:43:17,890
outer variable so we're calling this

00:43:16,060 --> 00:43:20,080
anonymous function is calling itself the

00:43:17,890 --> 00:43:22,030
ampersand lets you use a value by

00:43:20,080 --> 00:43:24,160
reference so if you change it it does

00:43:22,030 --> 00:43:26,470
get updated what you need to do when

00:43:24,160 --> 00:43:28,660
you're self referencing like this so we

00:43:26,470 --> 00:43:32,290
call factorial 3 and then factorial 4

00:43:28,660 --> 00:43:34,240
and this is what we got we call

00:43:32,290 --> 00:43:36,760
factorial 3 which called spectral 2

00:43:34,240 --> 00:43:39,910
which called spectral 1 return return

00:43:36,760 --> 00:43:42,640
return we get a result of 6 we then call

00:43:39,910 --> 00:43:45,670
factorial 4 which calls for than 3 than

00:43:42,640 --> 00:43:48,340
2 than 1 return return return return and

00:43:45,670 --> 00:43:49,690
we get a result why are we computing

00:43:48,340 --> 00:43:54,190
those over again and we just figured out

00:43:49,690 --> 00:43:55,240
what factorial 3 is fortunately there's

00:43:54,190 --> 00:43:57,790
a way to cash

00:43:55,240 --> 00:43:59,589
anything externally and that's

00:43:57,790 --> 00:44:02,619
memoization this is a nice simple

00:43:59,589 --> 00:44:05,650
utility function but wrapped up here is

00:44:02,619 --> 00:44:07,089
a lot of the concept behind where

00:44:05,650 --> 00:44:09,040
anonymous functions get really really

00:44:07,089 --> 00:44:13,330
powerful so we're gonna take this

00:44:09,040 --> 00:44:15,520
factorial function and memorize it which

00:44:13,330 --> 00:44:18,970
means we're going to in this function up

00:44:15,520 --> 00:44:22,089
here take this function in and return a

00:44:18,970 --> 00:44:25,210
new function we're gonna transform to a

00:44:22,089 --> 00:44:28,000
new function that has that same static

00:44:25,210 --> 00:44:29,440
hashing logic we just saw based on

00:44:28,000 --> 00:44:35,550
whatever the parameters are to the

00:44:29,440 --> 00:44:39,760
function and if it's not already cached

00:44:35,550 --> 00:44:42,280
in our static variable we'll go ahead

00:44:39,760 --> 00:44:46,020
and call the original function so now we

00:44:42,280 --> 00:44:51,099
call our new factorial with three and

00:44:46,020 --> 00:44:53,890
then call it again with four and calling

00:44:51,099 --> 00:44:56,460
it three nothing's cached so it just all

00:44:53,890 --> 00:45:00,280
goes through and computes everything

00:44:56,460 --> 00:45:01,780
then called factorial 4 factorial 4

00:45:00,280 --> 00:45:04,570
factorial at this point is this inner

00:45:01,780 --> 00:45:09,180
inner function and so it's gonna look up

00:45:04,570 --> 00:45:13,810
in our static results array do we have a

00:45:09,180 --> 00:45:16,770
value already for factorial 3 and it's

00:45:13,810 --> 00:45:19,180
gonna say yes here it is and return that

00:45:16,770 --> 00:45:22,390
instead of calling the original

00:45:19,180 --> 00:45:25,450
factorial function we can now take any

00:45:22,390 --> 00:45:30,550
function wrap this around it and it

00:45:25,450 --> 00:45:33,000
becomes cached that's cool which means I

00:45:30,550 --> 00:45:36,580
can now test that original function

00:45:33,000 --> 00:45:38,140
without worrying about caching there is

00:45:36,580 --> 00:45:39,820
no caching as far as that function is

00:45:38,140 --> 00:45:43,780
concerned it's a completely separate

00:45:39,820 --> 00:45:45,730
process as it should be can you do this

00:45:43,780 --> 00:45:48,700
two objects absolutely you should be

00:45:45,730 --> 00:45:51,130
doing it to your objects if you have an

00:45:48,700 --> 00:45:53,560
interface to find which you should you

00:45:51,130 --> 00:45:55,570
can do it like this got some major face

00:45:53,560 --> 00:45:59,080
you have got some class that computes

00:45:55,570 --> 00:46:00,280
something expensive here and then you

00:45:59,080 --> 00:46:03,660
just build another object that

00:46:00,280 --> 00:46:06,490
implements this same interface and wraps

00:46:03,660 --> 00:46:08,300
whatever that object is congratulations

00:46:06,490 --> 00:46:10,130
you have now memorized that service

00:46:08,300 --> 00:46:14,330
whatever's happening inside that compute

00:46:10,130 --> 00:46:17,480
function is now tribulus but you can

00:46:14,330 --> 00:46:20,120
still test your fancy class without

00:46:17,480 --> 00:46:22,280
having to think about cashing this makes

00:46:20,120 --> 00:46:25,010
your unit tests really really easy and

00:46:22,280 --> 00:46:29,750
it makes your code really really fast

00:46:25,010 --> 00:46:31,220
and those are a good combination called

00:46:29,750 --> 00:46:33,790
compute the second time here with

00:46:31,220 --> 00:46:36,200
whatever its values gonna be and you

00:46:33,790 --> 00:46:39,640
know it does not call it the second time

00:46:36,200 --> 00:46:39,640
it just pulls the value out of the cache

00:46:40,570 --> 00:46:45,320
can you just if you only have the one

00:46:43,340 --> 00:46:49,520
method can you just use memorize for it

00:46:45,320 --> 00:46:51,650
yes because remember any object and

00:46:49,520 --> 00:46:54,350
method can be represented in PHP as this

00:46:51,650 --> 00:46:58,670
weird array syntax so here we're gonna

00:46:54,350 --> 00:47:01,790
memorize that callable so now we call F

00:46:58,670 --> 00:47:06,910
cached and it's going to call that

00:47:01,790 --> 00:47:11,090
function that memo eyes produced which

00:47:06,910 --> 00:47:14,480
will in turn call the compute method of

00:47:11,090 --> 00:47:18,560
the fancy object of F save the result

00:47:14,480 --> 00:47:20,600
and return it we now have a tool that

00:47:18,560 --> 00:47:23,420
can cache the result of anything you can

00:47:20,600 --> 00:47:25,420
put parentheses after and it took like

00:47:23,420 --> 00:47:27,710
what six lines eight lines

00:47:25,420 --> 00:47:29,290
that's what functional programming gets

00:47:27,710 --> 00:47:33,230
you as a concept

00:47:29,290 --> 00:47:35,170
who likes Indian food this has

00:47:33,230 --> 00:47:39,080
absolutely nothing to do with that

00:47:35,170 --> 00:47:42,260
sorry currying is in fact named after

00:47:39,080 --> 00:47:43,340
mr. Haskell curry to among other in

00:47:42,260 --> 00:47:45,110
another one of these crazy smart

00:47:43,340 --> 00:47:48,260
mathematicians well among other things

00:47:45,110 --> 00:47:50,030
is the person after whom the Haskell

00:47:48,260 --> 00:47:51,740
programming language is named which is

00:47:50,030 --> 00:47:54,650
ironic given that according to his wife

00:47:51,740 --> 00:47:56,420
he hated his name and so we named both a

00:47:54,650 --> 00:47:58,520
programming concept and a programming

00:47:56,420 --> 00:48:04,070
language after him because computer

00:47:58,520 --> 00:48:05,630
science people are morons currying is

00:48:04,070 --> 00:48:08,300
the process of splitting a

00:48:05,630 --> 00:48:09,800
multi-parameter function into a series

00:48:08,300 --> 00:48:13,430
of single parameter functions that do

00:48:09,800 --> 00:48:14,750
the same thing in general this concept

00:48:13,430 --> 00:48:18,580
is called partial application you're

00:48:14,750 --> 00:48:18,580
going to halfway call a function

00:48:19,470 --> 00:48:23,880
let's take this function ad takes two

00:48:22,510 --> 00:48:29,410
values we're gonna add them together

00:48:23,880 --> 00:48:32,410
alright we can create a partial ad where

00:48:29,410 --> 00:48:34,240
we can call it with one value and get

00:48:32,410 --> 00:48:37,359
back a new function that persists that

00:48:34,240 --> 00:48:39,880
value and we can then call that second

00:48:37,359 --> 00:48:42,940
function with some other value and we'll

00:48:39,880 --> 00:48:44,619
add the two together could you do this

00:48:42,940 --> 00:48:47,560
by passing a value into a constructor of

00:48:44,619 --> 00:48:49,180
an object and saving it that way that's

00:48:47,560 --> 00:48:51,850
exactly what the PHP does under the hood

00:48:49,180 --> 00:48:54,520
but it's not this a lot shorter this is

00:48:51,850 --> 00:48:58,660
way less syntax didn't have to do the

00:48:54,520 --> 00:49:00,640
same thing where's this family go well

00:48:58,660 --> 00:49:01,780
that's the initial value you can just

00:49:00,640 --> 00:49:03,790
pull out of some configuration or

00:49:01,780 --> 00:49:07,320
whatever and because it's been a

00:49:03,790 --> 00:49:10,630
callable we can now apply it to anything

00:49:07,320 --> 00:49:12,970
so I can have pieces of my program that

00:49:10,630 --> 00:49:15,070
are set up and call halfway based on

00:49:12,970 --> 00:49:18,369
configuration and then call the rest of

00:49:15,070 --> 00:49:21,369
the way on actual user data and I can

00:49:18,369 --> 00:49:23,050
still test it as one function by passing

00:49:21,369 --> 00:49:28,830
in both pieces both my configuration and

00:49:23,050 --> 00:49:30,790
my user data which is pretty darn cool

00:49:28,830 --> 00:49:35,140
so let's have a look at this practically

00:49:30,790 --> 00:49:37,600
can we abstract this yes just like we

00:49:35,140 --> 00:49:40,690
had a memorize function we can create a

00:49:37,600 --> 00:49:45,070
partial function it takes a function to

00:49:40,690 --> 00:49:47,500
call or any call go and whatever the

00:49:45,070 --> 00:49:49,900
initial arguments are going to be so if

00:49:47,500 --> 00:49:51,670
a function takes in the case of say the

00:49:49,900 --> 00:49:53,550
dates function PHP it takes two

00:49:51,670 --> 00:49:57,700
parameters we're gonna call it first

00:49:53,550 --> 00:50:02,350
with the first parameter and we're going

00:49:57,700 --> 00:50:04,210
to get back a new function that keeps

00:50:02,350 --> 00:50:08,890
track of the initial function and that

00:50:04,210 --> 00:50:10,900
initial parameter recalled with and then

00:50:08,890 --> 00:50:13,060
when we call that new function with the

00:50:10,900 --> 00:50:15,040
second parameter it takes the first

00:50:13,060 --> 00:50:17,109
parameter it saved the second parameter

00:50:15,040 --> 00:50:19,450
we just gave it and calls that first

00:50:17,109 --> 00:50:26,880
function so date never actually gets

00:50:19,450 --> 00:50:26,880
called but we get back our nice result

00:50:26,940 --> 00:50:31,750
this should also seem very familiar

00:50:29,560 --> 00:50:33,970
this is dependency injection all over

00:50:31,750 --> 00:50:35,589
again this is put stuff in constructor

00:50:33,970 --> 00:50:36,520
and then call methods later that take

00:50:35,589 --> 00:50:39,640
advantage of the stuff from the

00:50:36,520 --> 00:50:41,980
constructor the exact same concept just

00:50:39,640 --> 00:50:45,130
done any much smaller cursor tighter

00:50:41,980 --> 00:50:47,920
package but what's important here is

00:50:45,130 --> 00:50:51,810
that we get to see what we're doing much

00:50:47,920 --> 00:50:54,099
more clearly we could see we're defining

00:50:51,810 --> 00:50:59,579
relationships rather than moving valleys

00:50:54,099 --> 00:50:59,579
around what's that

00:51:00,510 --> 00:51:05,470
not necessarily because if the valleys

00:51:03,819 --> 00:51:07,240
themselves are immutable that I can

00:51:05,470 --> 00:51:09,190
still see all right what's the valley

00:51:07,240 --> 00:51:12,579
that's persisted in this object it's

00:51:09,190 --> 00:51:16,720
five that five oh I know five is wrong

00:51:12,579 --> 00:51:18,550
and as if I'm setting it up it's much

00:51:16,720 --> 00:51:20,560
easier with this kind of approach to say

00:51:18,550 --> 00:51:23,859
I can see look at this code and just

00:51:20,560 --> 00:51:25,089
visually tell that this is not wrong I

00:51:23,859 --> 00:51:27,130
can tell that this is right because I

00:51:25,089 --> 00:51:28,030
know something's not gonna change unless

00:51:27,130 --> 00:51:30,460
I know about it

00:51:28,030 --> 00:51:32,890
you can persist values through a system

00:51:30,460 --> 00:51:34,480
without having them change randomly once

00:51:32,890 --> 00:51:37,450
I've set that value once I've set that

00:51:34,480 --> 00:51:39,160
format here I know that when I call date

00:51:37,450 --> 00:51:41,079
format I'm never going to be using a

00:51:39,160 --> 00:51:43,630
format other than the one I specified

00:51:41,079 --> 00:51:45,040
originally it is impossible for my

00:51:43,630 --> 00:51:47,950
program to suddenly start printing it

00:51:45,040 --> 00:51:51,460
out using a different date format that's

00:51:47,950 --> 00:51:55,420
why it's not sad could you do this to a

00:51:51,460 --> 00:51:57,300
method - absolutely it's a callable so

00:51:55,420 --> 00:52:00,160
let's bring this all together a bit

00:51:57,300 --> 00:52:03,520
remember we saw this code before with

00:52:00,160 --> 00:52:05,700
our new cards the problem is it's kind

00:52:03,520 --> 00:52:08,079
of hard to test anonymous functions

00:52:05,700 --> 00:52:09,609
because well they're anonymous I don't

00:52:08,079 --> 00:52:12,670
know what to you name them they're just

00:52:09,609 --> 00:52:15,099
defined inline and other code so let's

00:52:12,670 --> 00:52:17,950
rewrite that to be testable we have an

00:52:15,099 --> 00:52:22,750
is wild function that takes a wild card

00:52:17,950 --> 00:52:25,569
and a card object and it's alright is

00:52:22,750 --> 00:52:28,150
that card that wild and fine pair is

00:52:25,569 --> 00:52:30,579
going to take that is wild operation to

00:52:28,150 --> 00:52:32,890
use and then the two cards to compare

00:52:30,579 --> 00:52:35,220
and they've got the same syntax error

00:52:32,890 --> 00:52:38,099
here I apologize

00:52:35,220 --> 00:52:39,960
now we can test them is wild and find

00:52:38,099 --> 00:52:42,990
pair we can very easily test we can mock

00:52:39,960 --> 00:52:46,560
is wild we want to but it's really easy

00:52:42,990 --> 00:52:47,609
to unit test these pieces but I don't

00:52:46,560 --> 00:52:48,690
want to have to pass something every

00:52:47,609 --> 00:52:54,000
time all right

00:52:48,690 --> 00:52:59,099
partial it will take is wild and half

00:52:54,000 --> 00:53:00,630
way call it with our wild card so we

00:52:59,099 --> 00:53:02,460
wrap up this this function will be

00:53:00,630 --> 00:53:05,700
always he called with five of hearts as

00:53:02,460 --> 00:53:09,119
the the first parameter and then we

00:53:05,700 --> 00:53:12,230
partial fine pair with the fiber part

00:53:09,119 --> 00:53:15,290
C's wild function we just created and

00:53:12,230 --> 00:53:18,589
then we can call that pair checker

00:53:15,290 --> 00:53:21,930
repeatedly just as we did before

00:53:18,589 --> 00:53:24,480
or we could make both of these into

00:53:21,930 --> 00:53:27,060
classes and objects and pass them to the

00:53:24,480 --> 00:53:29,609
constructor and this slide would be four

00:53:27,060 --> 00:53:33,240
slides long or it can just put it right

00:53:29,609 --> 00:53:35,400
here all together we can go a step

00:53:33,240 --> 00:53:36,450
further we know if two cards are going

00:53:35,400 --> 00:53:39,690
to be a pair they're gonna be a pair of

00:53:36,450 --> 00:53:41,160
next time as well so memorize it in this

00:53:39,690 --> 00:53:43,050
case it's not a hard comparison but

00:53:41,160 --> 00:53:48,390
pretend it's a really hard comparison to

00:53:43,050 --> 00:53:50,700
do and now we can call this cached

00:53:48,390 --> 00:53:54,480
version for determining if something's a

00:53:50,700 --> 00:53:55,109
pair anytime we need and it will leave

00:53:54,480 --> 00:53:57,990
fast

00:53:55,109 --> 00:53:59,310
and testable and simple and

00:53:57,990 --> 00:54:01,079
straightforward to read because we're

00:53:59,310 --> 00:54:02,190
just looking at those the only function

00:54:01,079 --> 00:54:04,520
you need to read to understand what's

00:54:02,190 --> 00:54:04,520
going on

00:54:08,369 --> 00:54:13,499
you can keep on going to say

00:54:11,039 --> 00:54:15,839
three-of-a-kind what is three of a kind

00:54:13,499 --> 00:54:18,150
three of a kind is is pair is cart one

00:54:15,839 --> 00:54:20,460
and card two a pair and is card two and

00:54:18,150 --> 00:54:25,289
card three a pair so we can define it

00:54:20,460 --> 00:54:26,730
exactly that way and then we can create

00:54:25,289 --> 00:54:28,920
that partial that references the pair

00:54:26,730 --> 00:54:31,859
and memorize that too and now we have a

00:54:28,920 --> 00:54:34,619
cached way of checking of set of cards

00:54:31,859 --> 00:54:37,859
or three of a kind which the function

00:54:34,619 --> 00:54:41,009
itself is defined by what the definition

00:54:37,859 --> 00:54:44,339
of three of a kind is let's go back here

00:54:41,009 --> 00:54:46,319
this is the definition of wild

00:54:44,339 --> 00:54:47,670
we're not defining steps nowhere in here

00:54:46,319 --> 00:54:49,470
am I saying this is the steps you take

00:54:47,670 --> 00:54:51,720
to define to determine something wild

00:54:49,470 --> 00:54:53,130
I'm saying this is the definition of

00:54:51,720 --> 00:54:55,529
what it means for it to be a wild card

00:54:53,130 --> 00:55:00,269
does it is it the same as this card we

00:54:55,529 --> 00:55:03,150
specified are these two cards a pair the

00:55:00,269 --> 00:55:05,009
definition of them being a pair is do

00:55:03,150 --> 00:55:08,039
they have the same value or is one of

00:55:05,009 --> 00:55:11,099
them wild that is exactly what the code

00:55:08,039 --> 00:55:14,369
says there are no steps here there are

00:55:11,099 --> 00:55:17,420
simply definitions we are simply

00:55:14,369 --> 00:55:20,999
building the atomic pieces of our

00:55:17,420 --> 00:55:24,809
problem space your job as a developer is

00:55:20,999 --> 00:55:27,599
not to solve problems your job is to

00:55:24,809 --> 00:55:31,259
define the problem in such a way that it

00:55:27,599 --> 00:55:32,849
becomes solved that's a big shift if

00:55:31,259 --> 00:55:35,249
you're used to pushing data around in

00:55:32,849 --> 00:55:36,690
memory but pushing data in around in

00:55:35,249 --> 00:55:41,099
memory is how you get weird weird weird

00:55:36,690 --> 00:55:43,650
bugs instead define the problem in such

00:55:41,099 --> 00:55:46,349
a way that the answer becomes obvious

00:55:43,650 --> 00:55:48,690
and then the computer takes care of it

00:55:46,349 --> 00:55:53,249
from there pushing data around in memory

00:55:48,690 --> 00:55:55,230
is boring and hard and dumb boring hard

00:55:53,249 --> 00:55:56,519
dumb that's what computers are for is to

00:55:55,230 --> 00:56:01,559
do that so that we don't have to because

00:55:56,519 --> 00:56:02,630
we're better than that so this is a lot

00:56:01,559 --> 00:56:05,039
to take in

00:56:02,630 --> 00:56:06,630
there's an important observation to make

00:56:05,039 --> 00:56:08,339
here purely functional languages which

00:56:06,630 --> 00:56:11,400
enforce all of this stuff rather than

00:56:08,339 --> 00:56:13,829
make an optional have this advantage all

00:56:11,400 --> 00:56:15,749
data flow is explicit so you know

00:56:13,829 --> 00:56:18,390
exactly where everything is coming from

00:56:15,749 --> 00:56:21,239
at all times they have visited this

00:56:18,390 --> 00:56:27,029
advantage sometimes it really sucks to

00:56:21,239 --> 00:56:29,069
have to specify everything explicitly so

00:56:27,029 --> 00:56:33,210
takeaways I want you to have from this

00:56:29,069 --> 00:56:36,559
talk are make your data flow explicit

00:56:33,210 --> 00:56:38,970
most of the time there are exceptions

00:56:36,559 --> 00:56:40,349
where it's just too much work but for

00:56:38,970 --> 00:56:42,239
the most part when you if you really

00:56:40,349 --> 00:56:44,309
think about it you can make most things

00:56:42,239 --> 00:56:46,769
explicit and we and end up with code

00:56:44,309 --> 00:56:48,749
that is easier to test easier to verify

00:56:46,769 --> 00:56:50,309
is correct and you can just look at it

00:56:48,749 --> 00:56:53,640
and tell that it's right because you are

00:56:50,309 --> 00:56:56,009
defining the problem space using pure

00:56:53,640 --> 00:56:56,489
functions let you do all kinds of cool

00:56:56,009 --> 00:56:58,769
stuff

00:56:56,489 --> 00:57:01,650
and when I say pure functions I include

00:56:58,769 --> 00:57:03,720
service objects what when you're running

00:57:01,650 --> 00:57:05,609
for Drupal 8 most of the business logic

00:57:03,720 --> 00:57:08,910
of your modules should be in stateless

00:57:05,609 --> 00:57:10,619
service objects controllers and forms

00:57:08,910 --> 00:57:15,089
and once all the stuff are just glue

00:57:10,619 --> 00:57:16,799
code for that last 10% of weirdness but

00:57:15,089 --> 00:57:19,589
your actual module business logic should

00:57:16,799 --> 00:57:22,109
live off in service objects which are

00:57:19,589 --> 00:57:25,019
pure functions if they're not you're

00:57:22,109 --> 00:57:27,480
doing it wrong approach the problem in

00:57:25,019 --> 00:57:30,359
terms of what's not how don't think

00:57:27,480 --> 00:57:32,039
about how am I going to you know move

00:57:30,359 --> 00:57:35,819
this data from here to here how am I

00:57:32,039 --> 00:57:38,339
going to compute this thing define what

00:57:35,819 --> 00:57:40,140
it is you are trying to do define what

00:57:38,339 --> 00:57:41,579
it means for something to be a pair to

00:57:40,140 --> 00:57:43,440
find what it means for something to be a

00:57:41,579 --> 00:57:44,579
wild card to find what it means for

00:57:43,440 --> 00:57:48,239
something to be three of a kind

00:57:44,579 --> 00:57:50,069
and then actually using it just falls

00:57:48,239 --> 00:57:53,730
out naturally because you define the

00:57:50,069 --> 00:57:57,900
relationships between different concepts

00:57:53,730 --> 00:57:59,489
in your program separate out the what

00:57:57,900 --> 00:58:01,289
from the how you will at some point

00:57:59,489 --> 00:58:03,599
probably still need to push a few

00:58:01,289 --> 00:58:05,279
variables around somewhere that's okay

00:58:03,599 --> 00:58:07,230
keep that nice and self-contained

00:58:05,279 --> 00:58:10,619
separate from your definitions of the

00:58:07,230 --> 00:58:12,839
problem space when you have to do i oh

00:58:10,619 --> 00:58:14,609
when you have to do impure things keep

00:58:12,839 --> 00:58:16,859
those separate in a purely functional

00:58:14,609 --> 00:58:19,380
language there's weird workarounds that

00:58:16,859 --> 00:58:21,119
play games with the definition of pure

00:58:19,380 --> 00:58:23,970
to make it work whatever word this is

00:58:21,119 --> 00:58:25,230
PHP we're not pure but if you have an

00:58:23,970 --> 00:58:26,970
object that's talking to the database

00:58:25,230 --> 00:58:29,309
all it does is talk to the database

00:58:26,970 --> 00:58:31,109
that's it and everything else is

00:58:29,309 --> 00:58:33,180
communicates with it you're gonna have

00:58:31,109 --> 00:58:34,680
an object that does output to the screen

00:58:33,180 --> 00:58:36,960
or printing it to a

00:58:34,680 --> 00:58:39,810
object or whatever you're doing that is

00:58:36,960 --> 00:58:41,760
all it does keep those impurities

00:58:39,810 --> 00:58:45,210
isolated so that the rest of your

00:58:41,760 --> 00:58:45,870
program is really really easy to test if

00:58:45,210 --> 00:58:48,060
you've heard of the single

00:58:45,870 --> 00:58:50,070
responsibility principle an object to do

00:58:48,060 --> 00:58:50,880
one thing or things that are only going

00:58:50,070 --> 00:58:53,160
to change together

00:58:50,880 --> 00:58:55,770
it's that same concept taken to an

00:58:53,160 --> 00:58:58,050
extreme because when you do that you end

00:58:55,770 --> 00:59:00,510
up with these small tiny reusable pieces

00:58:58,050 --> 00:59:03,390
of code that you can assemble very very

00:59:00,510 --> 00:59:05,310
easily and individually look at and tell

00:59:03,390 --> 00:59:08,220
whether they're right or not it becomes

00:59:05,310 --> 00:59:10,140
really easy to debug visually keep in

00:59:08,220 --> 00:59:12,540
mind state is where bugs come from

00:59:10,140 --> 00:59:14,250
so less state you have in your program

00:59:12,540 --> 00:59:16,410
the less of your program is spent

00:59:14,250 --> 00:59:18,330
keeping track of variables here and all

00:59:16,410 --> 00:59:20,250
over the place the fewer bugs you will

00:59:18,330 --> 00:59:24,390
have because the fewer places there are

00:59:20,250 --> 00:59:25,890
for bugs to be lurking keep in mind when

00:59:24,390 --> 00:59:28,260
they say functional programming it is

00:59:25,890 --> 00:59:29,940
not a specific language I don't mean you

00:59:28,260 --> 00:59:31,740
must write in Haskell or you must write

00:59:29,940 --> 00:59:33,960
in Lisp but you must write in Erlang or

00:59:31,740 --> 00:59:37,020
any of these other things no functional

00:59:33,960 --> 00:59:40,380
programming is a concept it's really

00:59:37,020 --> 00:59:44,210
just good coding practices that's all it

00:59:40,380 --> 00:59:44,210
is thank you

00:59:55,510 --> 01:00:00,260
once again my name is Larry Garfield's

00:59:57,740 --> 01:00:03,800
with palliative nets do you want to know

01:00:00,260 --> 01:00:05,720
what girls were doing or where else will

01:00:03,800 --> 01:00:07,310
be speaking follow us on Twitter check

01:00:05,720 --> 01:00:09,530
out a newsletter I swear it's very low

01:00:07,310 --> 01:00:11,780
volume we also have a booth down in the

01:00:09,530 --> 01:00:13,609
exhibit hall booth 215 you want to talk

01:00:11,780 --> 01:00:16,250
further we are out of time for questions

01:00:13,609 --> 01:00:19,310
but I can answer them you know between

01:00:16,250 --> 01:00:21,440
sessions speedlight thank you slides

01:00:19,310 --> 01:00:24,050
will be posted very shortly sometime

01:00:21,440 --> 01:00:25,970
later today I'll be tweeting a link from

01:00:24,050 --> 01:00:28,100
the app Palantir account and they'll

01:00:25,970 --> 01:00:30,710
eventually get linked from the DrupalCon

01:00:28,100 --> 01:00:34,270
website so probably have talents here if

01:00:30,710 --> 01:00:34,270

YouTube URL: https://www.youtube.com/watch?v=M3_xnTK6-pA


