Title: DrupalCon Prague 2013: WRITING UNIT TESTABLE CODE IN DRUPAL 8
Publication date: 2013-09-26
Playlist: DrupalCon Prague - September 2013
Description: 
	As a developer, you want to know that your code does what it's supposed to do, in every possible scenario. You also want to know your code can be reliably reused in contexts that you have not specifically foreseen. Writing unit-testable code means solving both of these problems at the same time: the unit tests you write for your class represent the first re-use of that code. They show you that outside of the context in which they were written, your code behaves exactly as intended for any given set of inputs to it.

But writing unit tests - tests that test your class or method in total isolation from the "normal" context in which it usually runs - can be very difficult if that code has hard dependencies on aspects of that context. This session will help you understand the fundamentals of writing unit-testable code, including an overview of the Dependency Injection pattern which is central to achieving this goal. It will use examples of contributed modules in Drupal 7 that can be made unit-testable in Drupal 8 by following the newly adopted best practices for designing classes that are loosely coupled from each other.

The session will also cover some essentials for writing PHPUnit tests for your beautifully designed, loosely-coupled classes.
Captions: 
	00:00:01,250 --> 00:00:06,480
okay I think we're going to get going

00:00:03,419 --> 00:00:08,429
here thank you for staying and coming to

00:00:06,480 --> 00:00:12,269
a five o'clock session especially one

00:00:08,429 --> 00:00:13,980
that's going to be code heavy so this is

00:00:12,269 --> 00:00:16,859
a talk by me and kat bailey but you'll

00:00:13,980 --> 00:00:20,119
notice capability is not here so which

00:00:16,859 --> 00:00:22,350
you couldn't make it so it is just me

00:00:20,119 --> 00:00:25,680
I'm marks on a bomb I'm a performance

00:00:22,350 --> 00:00:27,779
engineer a Takuya although my job is

00:00:25,680 --> 00:00:29,460
mostly performance I also do a lot of

00:00:27,779 --> 00:00:32,640
work just to object-oriented programming

00:00:29,460 --> 00:00:35,760
in general in Drupal 8 and I helped get

00:00:32,640 --> 00:00:37,469
the get phpunit integer play so I'm

00:00:35,760 --> 00:00:43,820
passionate about unit testing and unit

00:00:37,469 --> 00:00:47,160
testability so first what is a unit test

00:00:43,820 --> 00:00:51,090
it verifies the behavior of a unit of

00:00:47,160 --> 00:00:55,860
code in isolation independent of

00:00:51,090 --> 00:00:59,359
application context they're fast but

00:00:55,860 --> 00:01:01,190
fast tests aren't always unit tests

00:00:59,359 --> 00:01:03,780
unfortunately they do not replace

00:01:01,190 --> 00:01:06,750
integration and acceptance tests as slow

00:01:03,780 --> 00:01:08,790
as our test suite is now we will never

00:01:06,750 --> 00:01:10,229
get it into like 10 seconds by making

00:01:08,790 --> 00:01:11,250
them all unit tests because we can't

00:01:10,229 --> 00:01:16,080
convert them all we still need

00:01:11,250 --> 00:01:21,240
acceptance tests and integration so why

00:01:16,080 --> 00:01:23,600
unit test mostly code quality when you

00:01:21,240 --> 00:01:26,100
force them to do unit tested you you're

00:01:23,600 --> 00:01:27,930
you're forcing that code to be context

00:01:26,100 --> 00:01:29,520
independent you're saying I can run this

00:01:27,930 --> 00:01:31,740
code and I can verify its behavior

00:01:29,520 --> 00:01:35,579
outside of the context that it's run in

00:01:31,740 --> 00:01:37,979
a good unit test also serves as

00:01:35,579 --> 00:01:40,560
documentation there are other

00:01:37,979 --> 00:01:42,290
communities that are not not necessarily

00:01:40,560 --> 00:01:45,630
in the PHP or especially Drupal world

00:01:42,290 --> 00:01:47,759
where the tests are actually their best

00:01:45,630 --> 00:01:49,259
documentation and often times they're

00:01:47,759 --> 00:01:51,180
better than written documentation

00:01:49,259 --> 00:01:56,159
because you can see exactly how things

00:01:51,180 --> 00:01:57,950
used their refactoring it's very very

00:01:56,159 --> 00:02:01,200
painful to refactor without unit tests

00:01:57,950 --> 00:02:04,290
anyone who has worked on Drupal 8 and

00:02:01,200 --> 00:02:06,600
had a random test failure for some web

00:02:04,290 --> 00:02:09,300
test and had to debug that you probably

00:02:06,600 --> 00:02:12,360
felt that pain the feedback loop on that

00:02:09,300 --> 00:02:13,270
is very very slow and it may break

00:02:12,360 --> 00:02:16,330
something that is complete

00:02:13,270 --> 00:02:18,970
unrelated to what you're doing the

00:02:16,330 --> 00:02:20,830
feedback is also extremely valuable when

00:02:18,970 --> 00:02:23,080
you're coding and you have unit tests

00:02:20,830 --> 00:02:24,640
you're constantly running them and you

00:02:23,080 --> 00:02:26,170
know instantly when you break something

00:02:24,640 --> 00:02:31,990
and it's a constant feedback loop with

00:02:26,170 --> 00:02:34,600
the tests now we talked a lot about

00:02:31,990 --> 00:02:38,080
testable code I'm sure if you've been

00:02:34,600 --> 00:02:39,940
involved in Drupal 8 especially with the

00:02:38,080 --> 00:02:42,370
if you familiar with the service

00:02:39,940 --> 00:02:45,550
container and at the general dependency

00:02:42,370 --> 00:02:48,730
injection trend and Drupal 8 you've

00:02:45,550 --> 00:02:50,380
probably heard about testable code but

00:02:48,730 --> 00:02:52,660
just to define it I like this quote from

00:02:50,380 --> 00:02:55,180
the growing object-oriented software

00:02:52,660 --> 00:02:57,520
guided by test book for class to be easy

00:02:55,180 --> 00:02:58,660
to unit test the class mess has explicit

00:02:57,520 --> 00:03:01,330
dependencies that can be easily

00:02:58,660 --> 00:03:04,710
substituted and clear responsibilities

00:03:01,330 --> 00:03:08,680
that can be easily invoked and verified

00:03:04,710 --> 00:03:12,180
so to sort of illustrate that point and

00:03:08,680 --> 00:03:12,180
here's an example of some code from t 7

00:03:12,600 --> 00:03:19,390
this code adds a role to a user I

00:03:16,350 --> 00:03:23,709
believe it is triggered with the action

00:03:19,390 --> 00:03:25,090
that does that it is an action right

00:03:23,709 --> 00:03:26,800
it's just really confusing because the

00:03:25,090 --> 00:03:30,370
word action never appears anywhere here

00:03:26,800 --> 00:03:32,140
but so if you look at this code if we

00:03:30,370 --> 00:03:34,510
look at the dependencies all right we

00:03:32,140 --> 00:03:35,709
see the we see the parameters right so

00:03:34,510 --> 00:03:38,260
you have an explicit dependency on

00:03:35,709 --> 00:03:39,370
accounts operation and roll you have

00:03:38,260 --> 00:03:41,470
operation because it does multiple

00:03:39,370 --> 00:03:44,050
things and then you have implicit

00:03:41,470 --> 00:03:48,610
dependencies you have DB query user load

00:03:44,050 --> 00:03:51,730
multiple and user save so those right

00:03:48,610 --> 00:03:53,590
there and now if you're in a unit test

00:03:51,730 --> 00:03:55,480
and you were trying to run this you

00:03:53,590 --> 00:03:57,430
would need all of those functions

00:03:55,480 --> 00:04:00,100
available so you'd include the files

00:03:57,430 --> 00:04:02,610
that have those but those function calls

00:04:00,100 --> 00:04:05,170
those functions call other functions and

00:04:02,610 --> 00:04:09,580
so now you need all the files that those

00:04:05,170 --> 00:04:13,989
are in and the files that are those are

00:04:09,580 --> 00:04:16,980
in and on and on this is the level which

00:04:13,989 --> 00:04:16,980
I stopped doing this by hand

00:04:19,620 --> 00:04:31,360
yes so the same code from d8 so a drool

00:04:28,689 --> 00:04:33,969
you or a droll user object a little bit

00:04:31,360 --> 00:04:38,409
strangely named but it is an action

00:04:33,969 --> 00:04:40,409
plugin it takes the account and then it

00:04:38,409 --> 00:04:42,969
has the role the role actually got

00:04:40,409 --> 00:04:45,520
injected be its constructor because it's

00:04:42,969 --> 00:04:49,080
a plug-in a little weird but to explicit

00:04:45,520 --> 00:04:51,969
dependencies and here all we have is a

00:04:49,080 --> 00:04:54,639
call to has role and then if it doesn't

00:04:51,969 --> 00:04:58,680
have the role it calls a droll and save

00:04:54,639 --> 00:05:00,939
on that user object so no function calls

00:04:58,680 --> 00:05:04,569
now if we look at the test for this this

00:05:00,939 --> 00:05:06,779
has actually existing core you start

00:05:04,569 --> 00:05:09,330
that out by creating an account mock and

00:05:06,779 --> 00:05:11,020
in this example it's using mock builder

00:05:09,330 --> 00:05:12,759
sometimes you need that when you're

00:05:11,020 --> 00:05:14,169
creating a mock from a test or from a

00:05:12,759 --> 00:05:17,909
class instead of an interface so that

00:05:14,169 --> 00:05:20,620
later and then you set up an expectation

00:05:17,909 --> 00:05:25,029
you're saying that the method add role

00:05:20,620 --> 00:05:29,409
will never be called and then you set up

00:05:25,029 --> 00:05:31,930
an expectation that the has roll the has

00:05:29,409 --> 00:05:35,020
roll method will be called with this

00:05:31,930 --> 00:05:37,599
value and it will return true and so

00:05:35,020 --> 00:05:39,159
that's basically saying and then if you

00:05:37,599 --> 00:05:41,139
notice the test is called test execute

00:05:39,159 --> 00:05:43,000
at existing roll it's saying I'm going

00:05:41,139 --> 00:05:44,919
to test the situation where the user

00:05:43,000 --> 00:05:46,060
already has this role I'm going to step

00:05:44,919 --> 00:05:48,009
the hazard roll method so that it

00:05:46,060 --> 00:05:49,990
returns true and so that i'm going to

00:05:48,009 --> 00:05:53,979
verify that a droll never gets called

00:05:49,990 --> 00:05:57,370
and then you basically set up that

00:05:53,979 --> 00:06:01,060
object and then you just do execute

00:05:57,370 --> 00:06:04,330
you'll notice there's no assertion at

00:06:01,060 --> 00:06:11,050
the end who hears written a simple test

00:06:04,330 --> 00:06:13,029
for okay dhp unit okay so especially the

00:06:11,050 --> 00:06:15,159
people who done simple test you're

00:06:13,029 --> 00:06:18,490
probably used to just always using like

00:06:15,159 --> 00:06:20,610
this assert equal assert something the

00:06:18,490 --> 00:06:23,110
assertion here is in the expectation

00:06:20,610 --> 00:06:25,959
this is an example of using a true mock

00:06:23,110 --> 00:06:27,639
and when you say like on the second one

00:06:25,959 --> 00:06:30,009
that's more of a stub because it's

00:06:27,639 --> 00:06:30,460
saying this any but when you say this

00:06:30,009 --> 00:06:32,259
never

00:06:30,460 --> 00:06:35,199
that means if the method is called once

00:06:32,259 --> 00:06:41,680
the test fails it has the test only

00:06:35,199 --> 00:06:43,120
passes when it gets called zero times so

00:06:41,680 --> 00:06:45,009
i would say in this example we have

00:06:43,120 --> 00:06:48,550
clear responsibilities and they're very

00:06:45,009 --> 00:06:49,990
easy to invoke and verify and they're

00:06:48,550 --> 00:06:54,960
explicit and it was very easy to

00:06:49,990 --> 00:06:58,810
substitute them so i mentioned briefly

00:06:54,960 --> 00:07:03,009
mocks and stubs to clarify these these

00:06:58,810 --> 00:07:05,199
terms there too two types of attest

00:07:03,009 --> 00:07:07,870
doubles that's a sort of a recent dish

00:07:05,199 --> 00:07:11,259
term but it's a it's an useful one for

00:07:07,870 --> 00:07:14,289
describing these these objects so say we

00:07:11,259 --> 00:07:17,470
have this class it's a super simple

00:07:14,289 --> 00:07:19,060
class it takes a storage interface and

00:07:17,470 --> 00:07:21,250
the only method it has is get stuff and

00:07:19,060 --> 00:07:24,699
then it just calls it delegates directly

00:07:21,250 --> 00:07:25,750
to stuff storage get and then you just

00:07:24,699 --> 00:07:30,250
create the interface that just has

00:07:25,750 --> 00:07:33,250
gettin set extremely simple so the first

00:07:30,250 --> 00:07:37,150
type of object and the simplest is a

00:07:33,250 --> 00:07:38,860
fake so when you're using a fake you

00:07:37,150 --> 00:07:41,770
actually just implement that interface

00:07:38,860 --> 00:07:44,669
you just create a class and in this

00:07:41,770 --> 00:07:47,590
example it's basically in memory storage

00:07:44,669 --> 00:07:49,270
right if you're if you worked on drupal

00:07:47,590 --> 00:07:51,729
test before you'll see this a lot this

00:07:49,270 --> 00:07:55,690
is what we've done quite often we did NT

00:07:51,729 --> 00:07:58,360
7 and then when you test it you just

00:07:55,690 --> 00:08:00,580
instantiate that object you set it that

00:07:58,360 --> 00:08:03,909
value manually and then you inject it

00:08:00,580 --> 00:08:04,960
and assert the response that comes back

00:08:03,909 --> 00:08:11,229
and make sure that you got the right

00:08:04,960 --> 00:08:12,370
thing now a stub is similar except with

00:08:11,229 --> 00:08:14,169
the stub you don't actually have to make

00:08:12,370 --> 00:08:16,419
that class as long as the interface

00:08:14,169 --> 00:08:19,419
exists you can just tell phpunit get

00:08:16,419 --> 00:08:23,110
mock for this interface and then set an

00:08:19,419 --> 00:08:25,780
expectation so and then expects any

00:08:23,110 --> 00:08:28,210
method get and it will turn that value

00:08:25,780 --> 00:08:30,580
and then use the same thing as before

00:08:28,210 --> 00:08:31,690
and then assert the value at the end so

00:08:30,580 --> 00:08:35,260
you're asserting the state that came

00:08:31,690 --> 00:08:37,149
back I think when people see this

00:08:35,260 --> 00:08:38,709
initially it maybe seems like a lot of

00:08:37,149 --> 00:08:40,599
setup and may it may be a little

00:08:38,709 --> 00:08:42,430
laborious but I think compared to

00:08:40,599 --> 00:08:43,820
actually creating a class and the other

00:08:42,430 --> 00:08:47,150
one this is still

00:08:43,820 --> 00:08:49,640
work and it's probably a little

00:08:47,150 --> 00:08:51,290
confusing also that the method is called

00:08:49,640 --> 00:08:55,760
get mock and I'm saying that this is a

00:08:51,290 --> 00:08:57,380
stub it's it's not that great of an area

00:08:55,760 --> 00:08:59,390
but uh if you actually look at the peach

00:08:57,380 --> 00:09:00,830
puter documentation they do they're

00:08:59,390 --> 00:09:04,010
clear about these are stubs they just

00:09:00,830 --> 00:09:07,190
all come from the mock method because

00:09:04,010 --> 00:09:09,950
they can sort of P both so a stub is

00:09:07,190 --> 00:09:12,920
used for indirect input and it asserts

00:09:09,950 --> 00:09:15,320
on state meaning you use the stub when

00:09:12,920 --> 00:09:17,300
you have input that's happening or input

00:09:15,320 --> 00:09:19,130
that you need to do the job that your

00:09:17,300 --> 00:09:22,460
method needs to do that is not passed

00:09:19,130 --> 00:09:27,950
and that can earn the method signature

00:09:22,460 --> 00:09:29,570
and then you do an assertion on state so

00:09:27,950 --> 00:09:33,800
mocks on the other hand are a bit

00:09:29,570 --> 00:09:35,780
different so you might say you thought

00:09:33,800 --> 00:09:37,850
we've always used mocks and Drupal if

00:09:35,780 --> 00:09:40,850
you looked at the file system you see a

00:09:37,850 --> 00:09:42,950
lot of things called mocks those aren't

00:09:40,850 --> 00:09:47,090
actually box pretty much all of them are

00:09:42,950 --> 00:09:49,820
fakes so here's what the test with a

00:09:47,090 --> 00:09:51,560
mock would look like notice it is very

00:09:49,820 --> 00:09:53,090
similar to these stub but the big

00:09:51,560 --> 00:09:55,970
difference is instead of saying this any

00:09:53,090 --> 00:09:57,650
I say this once and there's my

00:09:55,970 --> 00:09:59,330
expectation again if it gets called

00:09:57,650 --> 00:10:02,540
twice perfectly it's called zero times

00:09:59,330 --> 00:10:04,070
this test fails and then I don't

00:10:02,540 --> 00:10:05,210
actually like I assign that stuff

00:10:04,070 --> 00:10:06,770
variable and I don't actually do

00:10:05,210 --> 00:10:09,800
anything with it because I don't care

00:10:06,770 --> 00:10:12,230
what the return value is because all my

00:10:09,800 --> 00:10:14,870
classes responsible for is delegating

00:10:12,230 --> 00:10:16,700
this call to another another class I

00:10:14,870 --> 00:10:19,820
don't necessarily need to return I don't

00:10:16,700 --> 00:10:22,190
need to test the return key word so in

00:10:19,820 --> 00:10:24,170
this example I know all I need to test

00:10:22,190 --> 00:10:28,850
is how this object interacts with the

00:10:24,170 --> 00:10:31,970
other object so mocks are used for

00:10:28,850 --> 00:10:34,760
indirect output and they assert on

00:10:31,970 --> 00:10:36,500
behavior so I saying before we're

00:10:34,760 --> 00:10:39,590
basically asserting that this object

00:10:36,500 --> 00:10:40,880
acts or it behaves how it should with

00:10:39,590 --> 00:10:45,560
this other object they send the right

00:10:40,880 --> 00:10:47,840
messages to each other now if you've

00:10:45,560 --> 00:10:49,040
looked into mocks you've probably heard

00:10:47,840 --> 00:10:52,460
somebody to say that you should only

00:10:49,040 --> 00:10:54,050
mock what you own it's a bit of an

00:10:52,460 --> 00:10:56,889
advanced topic for us but I think it's

00:10:54,050 --> 00:10:59,889
worth the introducing

00:10:56,889 --> 00:11:02,199
and so from similar people but in a

00:10:59,889 --> 00:11:03,790
different paper mock objects is a design

00:11:02,199 --> 00:11:05,079
technique so programmers should only

00:11:03,790 --> 00:11:06,879
write mock for the types that they can

00:11:05,079 --> 00:11:08,499
change otherwise they cannot change the

00:11:06,879 --> 00:11:11,139
design to respond to requirements that

00:11:08,499 --> 00:11:12,429
arise from the process meaning when

00:11:11,139 --> 00:11:14,799
you're programming of mocks and you're

00:11:12,429 --> 00:11:16,989
writing your tests first and then you

00:11:14,799 --> 00:11:18,850
realize okay at this point I have this

00:11:16,989 --> 00:11:20,980
other interface that I haven't made yet

00:11:18,850 --> 00:11:22,929
but I'm making it now so that my test

00:11:20,980 --> 00:11:25,089
can finish and so that my class can do

00:11:22,929 --> 00:11:26,649
it it needs to do at that point you're

00:11:25,089 --> 00:11:30,189
looking at the design and you might make

00:11:26,649 --> 00:11:32,799
changes to it and you can't do that with

00:11:30,189 --> 00:11:35,879
an object that's not your own if that

00:11:32,799 --> 00:11:39,399
doesn't make sense that's totally fine

00:11:35,879 --> 00:11:41,499
it's not not a hard rule you can mock

00:11:39,399 --> 00:11:43,119
other things but in general like a

00:11:41,499 --> 00:11:46,169
simpler example is I don't try to mock

00:11:43,119 --> 00:11:50,199
PDO that's not a good idea instead

00:11:46,169 --> 00:11:52,119
create a class that wraps video and then

00:11:50,199 --> 00:11:57,249
mock your class that you just made now

00:11:52,119 --> 00:12:00,279
you're mocking something that you own so

00:11:57,249 --> 00:12:02,829
look a bit about earn look a bit of

00:12:00,279 --> 00:12:07,169
Drupal 8 and how this helps us now

00:12:02,829 --> 00:12:09,790
here's an example cat put together this

00:12:07,169 --> 00:12:11,589
piece of code sort of reef at formatted

00:12:09,790 --> 00:12:15,549
to fit on the slide and cut down from

00:12:11,589 --> 00:12:18,850
the sub path auto module all it is here

00:12:15,549 --> 00:12:21,369
is just look up on path to get the alias

00:12:18,850 --> 00:12:22,600
Ibsen alias and then cuts it down the

00:12:21,369 --> 00:12:25,419
important part is the troop will look up

00:12:22,600 --> 00:12:28,239
path so in this example like the one

00:12:25,419 --> 00:12:30,059
before you end up with those

00:12:28,239 --> 00:12:32,319
dependencies I did not trace them

00:12:30,059 --> 00:12:33,459
farther than that they have more

00:12:32,319 --> 00:12:37,600
dependencies but I didn't want to do

00:12:33,459 --> 00:12:40,329
that again but I mean the big one there

00:12:37,600 --> 00:12:44,470
DB query it's sort of game over at that

00:12:40,329 --> 00:12:46,749
point so here's the new version when you

00:12:44,470 --> 00:12:50,079
turn this into a plugin path processors

00:12:46,749 --> 00:12:52,449
are an object like there are all objects

00:12:50,079 --> 00:12:55,449
in Drupal 8 and they all get run in a

00:12:52,449 --> 00:12:58,239
certain sequence and so this actually

00:12:55,449 --> 00:13:02,709
had this object gets actually let's skip

00:12:58,239 --> 00:13:05,289
to that it defines a service for itself

00:13:02,709 --> 00:13:07,419
and it says i need injected the path

00:13:05,289 --> 00:13:09,189
processor alias and so there's another

00:13:07,419 --> 00:13:10,840
path processor object that all it does

00:13:09,189 --> 00:13:12,580
is it resolve these aliases

00:13:10,840 --> 00:13:15,670
and I need that injected into my object

00:13:12,580 --> 00:13:20,940
and so once that's injected all I do is

00:13:15,670 --> 00:13:23,230
I call this process inbound on it and

00:13:20,940 --> 00:13:26,200
then you have to tag it path processor

00:13:23,230 --> 00:13:29,320
and down it's a little goofy so here's

00:13:26,200 --> 00:13:31,120
the test for it basically do the same

00:13:29,320 --> 00:13:33,430
thing to do before because this is a

00:13:31,120 --> 00:13:34,720
class and not an interface use the mock

00:13:33,430 --> 00:13:35,650
builder and disable the constructor

00:13:34,720 --> 00:13:38,290
because you don't let the code from the

00:13:35,650 --> 00:13:40,330
constructor running and then you send an

00:13:38,290 --> 00:13:43,000
expectation that process inbound is

00:13:40,330 --> 00:13:44,980
going to be called once with that

00:13:43,000 --> 00:13:46,320
argument and then you're giving it a

00:13:44,980 --> 00:13:51,090
return value and so you're basically

00:13:46,320 --> 00:13:51,090
simulating it giving you the unalienable

00:13:53,280 --> 00:13:59,770
machi ana stuff in the sense if I had

00:13:57,370 --> 00:14:01,090
this any this was just purely BS dub but

00:13:59,770 --> 00:14:04,380
it doesn't hurt you to say this once and

00:14:01,090 --> 00:14:06,610
get both of them so you inject that and

00:14:04,380 --> 00:14:08,470
then go ahead and call process inbound

00:14:06,610 --> 00:14:10,960
and then assert that you get the right

00:14:08,470 --> 00:14:13,770
value and so this is a very unit

00:14:10,960 --> 00:14:15,970
testable version and really that's just

00:14:13,770 --> 00:14:21,550
not much trickery there that's just how

00:14:15,970 --> 00:14:24,580
this thing works in Drupal 8 so you

00:14:21,550 --> 00:14:28,450
might say testable classes all need to

00:14:24,580 --> 00:14:34,210
be defined in services there read this

00:14:28,450 --> 00:14:40,150
in IRC more than a couple times that's

00:14:34,210 --> 00:14:42,730
not true so as an example it's kind of a

00:14:40,150 --> 00:14:45,900
silly example because this is hooks but

00:14:42,730 --> 00:14:49,720
it's a simple one the hook discovery

00:14:45,900 --> 00:14:52,750
plugin plugin discovery object here's a

00:14:49,720 --> 00:14:55,390
test for that and then it's just at the

00:14:52,750 --> 00:14:56,650
top I just define one hook that I'm it's

00:14:55,390 --> 00:15:00,520
going to get called and so I can assert

00:14:56,650 --> 00:15:01,660
on it and in is also an example of like

00:15:00,520 --> 00:15:03,780
when you need something like this when

00:15:01,660 --> 00:15:05,950
you need a fake function or a fake class

00:15:03,780 --> 00:15:09,490
don't be afraid to just stick it at the

00:15:05,950 --> 00:15:11,800
top of the test I know we have like

00:15:09,490 --> 00:15:13,210
rules about where things go but in tests

00:15:11,800 --> 00:15:16,300
like all bets are off it doesn't matter

00:15:13,210 --> 00:15:17,830
just to find a function and so this is

00:15:16,300 --> 00:15:19,240
what the test will look like regardless

00:15:17,830 --> 00:15:21,250
of what is happening in the class right

00:15:19,240 --> 00:15:23,089
we just do a simple assertion on what

00:15:21,250 --> 00:15:25,309
the expected value comes back

00:15:23,089 --> 00:15:27,740
and what we expect is that we want to be

00:15:25,309 --> 00:15:29,839
told this module the sub sub module

00:15:27,740 --> 00:15:34,459
implements some hook and it returns some

00:15:29,839 --> 00:15:35,990
idea so the first like drupal 7 style

00:15:34,459 --> 00:15:37,610
version of doing this you just call

00:15:35,990 --> 00:15:38,809
module implements there's actually still

00:15:37,610 --> 00:15:41,660
code and Drupal 8 the calls module

00:15:38,809 --> 00:15:43,819
implements if you try that you will get

00:15:41,660 --> 00:15:47,779
an undefined function because in PHP

00:15:43,819 --> 00:15:48,920
unit we don't include any code except

00:15:47,779 --> 00:15:51,110
for the stuff that's in the like the

00:15:48,920 --> 00:15:55,970
small bootstrap file and the code that's

00:15:51,110 --> 00:15:58,939
auto loaded this I would consider

00:15:55,970 --> 00:16:01,519
untestable a strict there's some way

00:15:58,939 --> 00:16:02,689
there are ways to conditionally define

00:16:01,519 --> 00:16:04,399
functions we do it in a couple places

00:16:02,689 --> 00:16:07,309
but it's a bad idea and you generally

00:16:04,399 --> 00:16:10,339
never want to do it so when you have

00:16:07,309 --> 00:16:12,019
functions you have no auto load when you

00:16:10,339 --> 00:16:14,329
use require like say you require like

00:16:12,019 --> 00:16:15,949
the common dank or whatever has that

00:16:14,329 --> 00:16:17,360
function you're polluting your test

00:16:15,949 --> 00:16:18,860
environment you're bringing in a bunch

00:16:17,360 --> 00:16:20,540
of code that has nothing to do with your

00:16:18,860 --> 00:16:21,649
test and you will end up with implicit

00:16:20,540 --> 00:16:23,269
dependencies that you don't know about

00:16:21,649 --> 00:16:26,059
because you're loading all of the code

00:16:23,269 --> 00:16:28,879
and as we saw before it is unpredictable

00:16:26,059 --> 00:16:33,920
dependencies it will make you want to

00:16:28,879 --> 00:16:36,439
bring your radio on at the bath and so

00:16:33,920 --> 00:16:38,329
say we make this small change to it we

00:16:36,439 --> 00:16:41,779
change that module implements for drupal

00:16:38,329 --> 00:16:43,189
module handler get implementation this

00:16:41,779 --> 00:16:44,870
is also something you see a lot in

00:16:43,189 --> 00:16:46,970
triple especially in the entity system

00:16:44,870 --> 00:16:51,110
where there's not a lot of injection for

00:16:46,970 --> 00:16:56,089
reasons it just calls straight out to

00:16:51,110 --> 00:16:57,769
this quite often and so you might wonder

00:16:56,089 --> 00:17:01,990
if this is actually testable because it

00:16:57,769 --> 00:17:05,449
is a static method call it is here's how

00:17:01,990 --> 00:17:07,730
you create a module handler mock then

00:17:05,449 --> 00:17:09,199
you set an expectation on it that's the

00:17:07,730 --> 00:17:10,760
part you're going to have to do normally

00:17:09,199 --> 00:17:13,309
but then you have to create a new

00:17:10,760 --> 00:17:16,039
container set the module handler on that

00:17:13,309 --> 00:17:19,000
container and then set the global

00:17:16,039 --> 00:17:22,159
container singleton on the Drupal class

00:17:19,000 --> 00:17:24,169
so that when that drupal module handler

00:17:22,159 --> 00:17:26,689
gets called it'll be pulling from your

00:17:24,169 --> 00:17:27,860
container and not Drupal's and actually

00:17:26,689 --> 00:17:31,549
it'll fail if you don't do this because

00:17:27,860 --> 00:17:36,430
there is no container in peach p.m. so

00:17:31,549 --> 00:17:40,610
that passes accessible but it's painful

00:17:36,430 --> 00:17:43,490
so you do get autoload but you also have

00:17:40,610 --> 00:17:45,950
non-object under test code running and

00:17:43,490 --> 00:17:47,600
the term you'll see object under test

00:17:45,950 --> 00:17:49,700
system under test is basically the thing

00:17:47,600 --> 00:17:51,590
you're testing because you should be

00:17:49,700 --> 00:17:54,380
testing that and nothing else in a unit

00:17:51,590 --> 00:17:55,850
test and then if you do have this you

00:17:54,380 --> 00:18:02,720
have to include a setter or else it just

00:17:55,850 --> 00:18:04,550
doesn't work so another example you

00:18:02,720 --> 00:18:07,730
could hide that call to drupal module

00:18:04,550 --> 00:18:10,040
handler in a local method and here it's

00:18:07,730 --> 00:18:11,690
basically the same thing except in get

00:18:10,040 --> 00:18:13,760
definitions instead of calling out to

00:18:11,690 --> 00:18:17,450
the drupal class it's talking to itself

00:18:13,760 --> 00:18:19,190
and then in the module handler it'll

00:18:17,450 --> 00:18:23,810
only call out to drupal module handler

00:18:19,190 --> 00:18:27,110
if the local variable is not set it's a

00:18:23,810 --> 00:18:30,650
one way to test with this is in your

00:18:27,110 --> 00:18:34,580
test a subclass that class and add a

00:18:30,650 --> 00:18:36,860
setter some people find it very very

00:18:34,580 --> 00:18:39,860
confusing if you just add a setter to

00:18:36,860 --> 00:18:43,670
that class because I suppose it might

00:18:39,860 --> 00:18:45,680
imply that you could use that although I

00:18:43,670 --> 00:18:47,780
think in general that's probably not a

00:18:45,680 --> 00:18:50,030
big deal if you want to make it really

00:18:47,780 --> 00:18:51,440
explicit you can just make I mean on

00:18:50,030 --> 00:18:53,660
your route normal class you can just say

00:18:51,440 --> 00:18:55,670
set test module handler which is very

00:18:53,660 --> 00:18:57,920
explicit that you'd only use that during

00:18:55,670 --> 00:18:59,840
the test and then you just basically

00:18:57,920 --> 00:19:06,910
call the set module handler and your

00:18:59,840 --> 00:19:06,910
tests works so that is totally testable

00:19:06,940 --> 00:19:17,030
it mocks V inheritance or just a test

00:19:10,160 --> 00:19:19,550
only center so last example is just

00:19:17,030 --> 00:19:22,250
straight dependency injection I'm here

00:19:19,550 --> 00:19:23,690
this the subject normally just had the

00:19:22,250 --> 00:19:25,280
hook so we add module handler to the

00:19:23,690 --> 00:19:26,600
constructor and then you just call

00:19:25,280 --> 00:19:29,150
straight out to module handler because

00:19:26,600 --> 00:19:33,380
it had it when it was a when it was

00:19:29,150 --> 00:19:36,170
constructed and the test for this is

00:19:33,380 --> 00:19:41,660
pretty simple you lose the the call for

00:19:36,170 --> 00:19:43,630
the setter that passes so that is very

00:19:41,660 --> 00:19:46,190
testable

00:19:43,630 --> 00:19:49,460
now it mocks just via new just be a

00:19:46,190 --> 00:19:51,200
making a new class but it requires a

00:19:49,460 --> 00:19:52,820
service definition or a factory method

00:19:51,200 --> 00:19:56,000
meaning if you have the service

00:19:52,820 --> 00:19:57,830
definition that is what's going to allow

00:19:56,000 --> 00:20:00,080
you to specify which dependencies get

00:19:57,830 --> 00:20:02,750
injected into it or you'll notice with

00:20:00,080 --> 00:20:04,670
like form I think forms controllers and

00:20:02,750 --> 00:20:06,860
plugins they have like a static create

00:20:04,670 --> 00:20:10,310
method and the idea there is that you

00:20:06,860 --> 00:20:13,070
have a container aware factory but your

00:20:10,310 --> 00:20:14,600
classes and container aware and if I

00:20:13,070 --> 00:20:16,040
probably haven't mentioned that you

00:20:14,600 --> 00:20:18,470
don't want your classes to be container

00:20:16,040 --> 00:20:20,240
aware because one easy way to do this

00:20:18,470 --> 00:20:21,710
would be to just inject your kin the

00:20:20,240 --> 00:20:23,990
whole container in your class then you

00:20:21,710 --> 00:20:26,480
can get whatever you want but that's not

00:20:23,990 --> 00:20:29,000
like an explicit dependency you should

00:20:26,480 --> 00:20:31,640
you should strictly limit what your

00:20:29,000 --> 00:20:33,620
class has access to and so if you have

00:20:31,640 --> 00:20:34,490
to do that or if you if you need stuff

00:20:33,620 --> 00:20:36,230
and you don't want to actually have a

00:20:34,490 --> 00:20:37,880
service the best thing you can do is

00:20:36,230 --> 00:20:40,250
just create a factory that has the

00:20:37,880 --> 00:20:43,370
container and then the factory injects

00:20:40,250 --> 00:20:45,380
those into your class but this is enough

00:20:43,370 --> 00:20:50,330
to make the dependency injection please

00:20:45,380 --> 00:20:53,780
happy so you might ask which method

00:20:50,330 --> 00:20:56,140
should i use so constructor injection is

00:20:53,780 --> 00:20:59,480
that like that should be your default

00:20:56,140 --> 00:21:03,220
definitely use it for but i'm calling

00:20:59,480 --> 00:21:06,440
domain collaborators so like if you're

00:21:03,220 --> 00:21:11,720
if you're like the token module and then

00:21:06,440 --> 00:21:14,000
there's a token storage class assuming

00:21:11,720 --> 00:21:15,290
there is i don't know if there is those

00:21:14,000 --> 00:21:18,290
are both like sort of in the same domain

00:21:15,290 --> 00:21:19,820
and so you you have a very cliquey of a

00:21:18,290 --> 00:21:24,260
high cohesion with that class you

00:21:19,820 --> 00:21:27,230
probably want to inject that so the test

00:21:24,260 --> 00:21:29,410
only setter you want to use that when

00:21:27,230 --> 00:21:32,870
you have dependencies with safe defaults

00:21:29,410 --> 00:21:38,120
so an example of that is say like a

00:21:32,870 --> 00:21:39,940
logger a translator URL generator these

00:21:38,120 --> 00:21:42,290
are objects that it's very unlikely that

00:21:39,940 --> 00:21:45,110
we're going to have more than one

00:21:42,290 --> 00:21:46,460
instance of in a drupal request it's

00:21:45,110 --> 00:21:48,500
pretty rare I mean we might swap them

00:21:46,460 --> 00:21:52,190
out but probably not more than once in a

00:21:48,500 --> 00:21:54,140
request and it's also a good idea when

00:21:52,190 --> 00:21:56,250
you have a really bloated constructor if

00:21:54,140 --> 00:21:59,620
you have a constructor with nine

00:21:56,250 --> 00:22:01,240
parameters in it which we do the ones

00:21:59,620 --> 00:22:04,270
that have safe defaults you might just

00:22:01,240 --> 00:22:05,740
move to test only setters because the

00:22:04,270 --> 00:22:08,170
only reason that you're injecting them

00:22:05,740 --> 00:22:09,820
most likely is that you want to be able

00:22:08,170 --> 00:22:11,890
to test your object so if you can test

00:22:09,820 --> 00:22:13,660
it through a setter but it's really just

00:22:11,890 --> 00:22:15,820
like an application like drupal level

00:22:13,660 --> 00:22:17,200
dependency feel free to get it out of

00:22:15,820 --> 00:22:18,490
your constructor because it's not really

00:22:17,200 --> 00:22:23,799
that important to what your object is

00:22:18,490 --> 00:22:28,990
doing so replacing the singleton via the

00:22:23,799 --> 00:22:30,280
Drupal class avoid it if you can if it's

00:22:28,990 --> 00:22:34,660
I think could probably be better to have

00:22:30,280 --> 00:22:35,950
a no it's not going to be better the

00:22:34,660 --> 00:22:37,990
least you can do is to make a

00:22:35,950 --> 00:22:40,299
local-access ur if you're talking to a

00:22:37,990 --> 00:22:42,790
dependency don't ever talk straight

00:22:40,299 --> 00:22:44,230
outside only talk to yourself and then

00:22:42,790 --> 00:22:46,960
wrap that dependency in a very small

00:22:44,230 --> 00:22:52,150
method and that's totally easy not a lot

00:22:46,960 --> 00:22:53,830
of overhead and much much better so you

00:22:52,150 --> 00:22:57,970
might say that it takes so much work to

00:22:53,830 --> 00:22:59,980
set up my unit tests this is this is a

00:22:57,970 --> 00:23:04,450
sign and you should listen to this

00:22:59,980 --> 00:23:07,660
feedback so all dependencies are not

00:23:04,450 --> 00:23:09,130
created equal convention before some are

00:23:07,660 --> 00:23:15,580
closely related your class some are not

00:23:09,130 --> 00:23:18,010
so this comes with the idea of cohesion

00:23:15,580 --> 00:23:20,020
and coupling so elements are coupled if

00:23:18,010 --> 00:23:23,020
a change in one forces a change in

00:23:20,020 --> 00:23:24,700
another and cohesion is a measure of

00:23:23,020 --> 00:23:27,820
whether responsibilities form a

00:23:24,700 --> 00:23:29,260
meaningful unit so if two classes are

00:23:27,820 --> 00:23:30,790
doing something similar they're close

00:23:29,260 --> 00:23:32,970
collaborators they live in the same

00:23:30,790 --> 00:23:36,190
domain that's that it's a high cohesion

00:23:32,970 --> 00:23:37,780
entities storage controller has a our

00:23:36,190 --> 00:23:41,799
node storage controller is highly

00:23:37,780 --> 00:23:45,400
cohesive with node right it's not

00:23:41,799 --> 00:23:50,470
necessarily cohesive to module handler

00:23:45,400 --> 00:23:55,030
that is a coupling so here's an example

00:23:50,470 --> 00:23:59,230
to pick on Peter woman maybe you wrote

00:23:55,030 --> 00:24:01,179
this I don't know the local task manager

00:23:59,230 --> 00:24:03,190
it's a new one and so he'll probably get

00:24:01,179 --> 00:24:10,410
refactor he knows it is a lot of

00:24:03,190 --> 00:24:10,410
dependencies okay sweet good to know

00:24:12,480 --> 00:24:19,750
okay well I might have a suggestion so

00:24:17,610 --> 00:24:23,020
when I see a class with this many

00:24:19,750 --> 00:24:24,340
dependencies my first thought is to look

00:24:23,020 --> 00:24:26,980
at what they are and how they're being

00:24:24,340 --> 00:24:28,780
used because it's pretty rare that you

00:24:26,980 --> 00:24:31,840
should ever have this many dependencies

00:24:28,780 --> 00:24:35,800
in one class it's a good indicator that

00:24:31,840 --> 00:24:38,309
your class is doing too much so the

00:24:35,800 --> 00:24:41,830
first thing that pops out of me is these

00:24:38,309 --> 00:24:44,830
so we have request route provider and

00:24:41,830 --> 00:24:46,179
access manager if you look at access

00:24:44,830 --> 00:24:47,919
manager it actually already has a

00:24:46,179 --> 00:24:49,890
reference to route parameter a route

00:24:47,919 --> 00:24:52,090
provider and I believe it also has a

00:24:49,890 --> 00:24:55,540
request and so these three are related

00:24:52,090 --> 00:24:58,630
and if this is a manager object meaning

00:24:55,540 --> 00:25:00,700
it probably shouldn't have any

00:24:58,630 --> 00:25:04,120
significant business logic it's mostly

00:25:00,700 --> 00:25:05,710
be delegating to other objects I would

00:25:04,120 --> 00:25:07,510
take whatever is happening in these

00:25:05,710 --> 00:25:10,390
three objects and move them to a

00:25:07,510 --> 00:25:11,890
different one and then have the local

00:25:10,390 --> 00:25:13,780
task manager just delegate to that

00:25:11,890 --> 00:25:18,340
instead and then you turn three

00:25:13,780 --> 00:25:21,010
dependencies into one hopefully that

00:25:18,340 --> 00:25:25,870
makes some sense looks like you

00:25:21,010 --> 00:25:28,570
something to say right this is hard

00:25:25,870 --> 00:25:31,540
right except that it's hard but I think

00:25:28,570 --> 00:25:32,919
like the point though here is that if

00:25:31,540 --> 00:25:34,540
you can find things that are related

00:25:32,919 --> 00:25:37,120
like these are related and they're not

00:25:34,540 --> 00:25:40,570
related to those other ones I think it's

00:25:37,120 --> 00:25:42,940
pretty likely that you could that those

00:25:40,570 --> 00:25:44,860
that this functionality could exist in

00:25:42,940 --> 00:25:47,530
an object that doesn't have a controller

00:25:44,860 --> 00:25:49,780
resolver module handler cash back end

00:25:47,530 --> 00:25:53,260
and language manager I think that's

00:25:49,780 --> 00:25:57,520
likely so the other one is module

00:25:53,260 --> 00:25:59,500
handler and this is a subtle point but

00:25:57,520 --> 00:26:01,630
we have this all throughout our code now

00:25:59,500 --> 00:26:07,530
so all the code that would have used

00:26:01,630 --> 00:26:07,530
module invoke modular call alter

00:26:07,559 --> 00:26:11,500
implement or module implements are all

00:26:10,059 --> 00:26:14,320
using the module handler now so

00:26:11,500 --> 00:26:15,580
basically if you have a hook or you just

00:26:14,320 --> 00:26:16,990
need to list of modules for any reason

00:26:15,580 --> 00:26:18,190
you have to have a copy of the module

00:26:16,990 --> 00:26:21,850
handler

00:26:18,190 --> 00:26:23,690
this isn't a great trend in my opinion

00:26:21,850 --> 00:26:25,430
what's a little odd about this is

00:26:23,690 --> 00:26:27,560
actually it's just using it to call this

00:26:25,430 --> 00:26:30,500
ultra info which it turns out is a

00:26:27,560 --> 00:26:32,990
plug-in thing where you set that and

00:26:30,500 --> 00:26:36,590
then the plug-in calls the hook on your

00:26:32,990 --> 00:26:38,660
behalf so instead of this what I would

00:26:36,590 --> 00:26:41,270
do I know I'm just trading one

00:26:38,660 --> 00:26:42,890
dependency for another here is that was

00:26:41,270 --> 00:26:45,920
instead have a dependency on the event

00:26:42,890 --> 00:26:47,930
dispatcher because if you have a

00:26:45,920 --> 00:26:49,790
dependency on the event dispatcher all

00:26:47,930 --> 00:26:52,610
you're doing is you're saying i have

00:26:49,790 --> 00:26:54,740
this event that happens and here's the

00:26:52,610 --> 00:26:57,110
thing that goes along with it somebody

00:26:54,740 --> 00:27:00,500
do something with it all you can do that

00:26:57,110 --> 00:27:02,210
object is is dispatch with the module

00:27:00,500 --> 00:27:03,740
handler if you look at the public

00:27:02,210 --> 00:27:05,510
interface of the module handler you have

00:27:03,740 --> 00:27:09,830
access to weigh more than you should

00:27:05,510 --> 00:27:11,960
have that's basically a a dependency on

00:27:09,830 --> 00:27:14,990
all of Drupal when you have the module

00:27:11,960 --> 00:27:18,980
handler versus the event dispatcher

00:27:14,990 --> 00:27:22,310
which is much much simpler I trust some

00:27:18,980 --> 00:27:23,330
people will disagree but I think it's an

00:27:22,310 --> 00:27:27,320
important point because it's all over

00:27:23,330 --> 00:27:29,990
the place and now i don't i don't have

00:27:27,320 --> 00:27:33,230
too much on this but I can't talk about

00:27:29,990 --> 00:27:35,150
unit testing without mentioning TDD I'm

00:27:33,230 --> 00:27:36,290
sure everyone has heard of CDD you

00:27:35,150 --> 00:27:39,770
probably heard it talked about a lot

00:27:36,290 --> 00:27:42,920
when simple tests went in another

00:27:39,770 --> 00:27:44,930
disappointing realization there is that

00:27:42,920 --> 00:27:47,200
we were actually never doing TDD and

00:27:44,930 --> 00:27:49,580
it's almost impossible to do in Drupal i

00:27:47,200 --> 00:27:51,980
have i have talked to one person who did

00:27:49,580 --> 00:27:55,760
it with unit test base but it's pretty

00:27:51,980 --> 00:27:57,520
rare the the distinguishing piece of TDD

00:27:55,760 --> 00:28:01,040
is that you write your tests first and

00:27:57,520 --> 00:28:04,970
we don't do that is anyone right there

00:28:01,040 --> 00:28:07,300
web test first right that would be

00:28:04,970 --> 00:28:07,300
insane

00:28:08,399 --> 00:28:21,130
what is there an objection to somebody

00:28:10,570 --> 00:28:25,419
do that so that's an integration test

00:28:21,130 --> 00:28:27,519
okay it's doable the feedback loop on

00:28:25,419 --> 00:28:29,230
though on that is so slow though it

00:28:27,519 --> 00:28:31,000
generally doesn't facilitate that and

00:28:29,230 --> 00:28:34,419
the idea is like you write your tests

00:28:31,000 --> 00:28:36,370
first and then that determines like so

00:28:34,419 --> 00:28:37,510
you write it for one class and then you

00:28:36,370 --> 00:28:40,980
figure out who that class's

00:28:37,510 --> 00:28:44,049
collaborators are by that design process

00:28:40,980 --> 00:28:45,639
so another good quote on that you write

00:28:44,049 --> 00:28:47,679
your tests first we're a chance for the

00:28:45,639 --> 00:28:49,389
code instead of using testing to verify

00:28:47,679 --> 00:28:51,880
our work after it's done TD turns

00:28:49,389 --> 00:28:53,919
testing into a design activity we use it

00:28:51,880 --> 00:28:57,190
has to clarify our ideas about what we

00:28:53,919 --> 00:29:00,130
want the code to do and so this is the

00:28:57,190 --> 00:29:01,539
trick to unit testing it's it's great

00:29:00,130 --> 00:29:04,000
for refactoring and telling you that

00:29:01,539 --> 00:29:05,679
your code still works there is some

00:29:04,000 --> 00:29:09,190
value there and telling you that your

00:29:05,679 --> 00:29:12,240
code is correct the real value is that

00:29:09,190 --> 00:29:14,200
it makes you write good code and

00:29:12,240 --> 00:29:16,059
especially when you write your tests

00:29:14,200 --> 00:29:18,149
first when you get to the writing unit

00:29:16,059 --> 00:29:21,100
tests and you have and it's very painful

00:29:18,149 --> 00:29:22,899
that process will change once you start

00:29:21,100 --> 00:29:24,279
writing your test first because you'll

00:29:22,899 --> 00:29:26,440
design better interfaces and you're

00:29:24,279 --> 00:29:28,690
designing your interfaces from the

00:29:26,440 --> 00:29:30,580
clients perspective because you're

00:29:28,690 --> 00:29:31,779
saying this object is going to need to

00:29:30,580 --> 00:29:33,760
collaborate with this other thing that I

00:29:31,779 --> 00:29:35,620
haven't written and this is what I would

00:29:33,760 --> 00:29:37,090
like the interface to look like and you

00:29:35,620 --> 00:29:39,250
always get better interfaces when you do

00:29:37,090 --> 00:29:42,130
that and so I would just encourage

00:29:39,250 --> 00:29:43,450
everybody when you're writing PHP or you

00:29:42,130 --> 00:29:47,080
have a new class to make your porting

00:29:43,450 --> 00:29:49,059
your modules just give it a shot it's

00:29:47,080 --> 00:29:51,070
going to be painful at first you'll

00:29:49,059 --> 00:29:52,600
probably give up on it but just keep

00:29:51,070 --> 00:29:57,159
trying because once it clicks it's

00:29:52,600 --> 00:29:58,779
totally worth it they're just couple of

00:29:57,159 --> 00:30:00,190
references for things i mentioned

00:29:58,779 --> 00:30:02,110
directly in the talk and things that

00:30:00,190 --> 00:30:04,210
have influenced my thinking on this the

00:30:02,110 --> 00:30:06,820
growing object-oriented software guided

00:30:04,210 --> 00:30:09,100
by tests that's probably the top one x

00:30:06,820 --> 00:30:11,110
student test patterns there's the paper

00:30:09,100 --> 00:30:14,289
mock role is not objects from oopsla

00:30:11,110 --> 00:30:15,970
that has explains uh mocking what you

00:30:14,289 --> 00:30:17,559
own and then the sandy Mets book

00:30:15,970 --> 00:30:19,179
practical object oriented design and

00:30:17,559 --> 00:30:22,590
Ruby which really is not that Ruby

00:30:19,179 --> 00:30:27,670
specific but as a great test in chapter

00:30:22,590 --> 00:30:29,920
so that's all I have take questions and

00:30:27,670 --> 00:30:31,120
then feedback if you can follow those

00:30:29,920 --> 00:30:43,900
instructions if you want to give

00:30:31,120 --> 00:30:46,270
feedback yeah questions I can stand here

00:30:43,900 --> 00:30:47,260
awkwardly for a really long time oh yeah

00:30:46,270 --> 00:30:53,260
and if you want to ask a question you up

00:30:47,260 --> 00:30:55,890
to go to the mic I don't know I'll try

00:30:53,260 --> 00:30:55,890
to repeat it I guess

00:31:06,659 --> 00:31:16,379
yes yes right so our stubs and mocks

00:31:13,590 --> 00:31:18,149
useful in their own ways like sex so you

00:31:16,379 --> 00:31:20,009
use one in someone situation one and

00:31:18,149 --> 00:31:24,210
another not use one of the other yeah

00:31:20,009 --> 00:31:26,039
absolutely and so that's that's right I

00:31:24,210 --> 00:31:28,619
think thanks for fine like fake I think

00:31:26,039 --> 00:31:30,419
it's all depends on what you're dealing

00:31:28,619 --> 00:31:31,739
with if it's really simple for you to

00:31:30,419 --> 00:31:33,119
just create the fake and not deal with

00:31:31,739 --> 00:31:36,049
it or if you're going to especially for

00:31:33,119 --> 00:31:38,639
going to reuse the fake like having a

00:31:36,049 --> 00:31:41,849
memory-based say we had a memory based

00:31:38,639 --> 00:31:43,619
database connection right that would be

00:31:41,849 --> 00:31:45,210
really useful because we'd use that all

00:31:43,619 --> 00:31:48,720
over the place and so maybe it's worth

00:31:45,210 --> 00:31:50,489
making a fake in that case but it's like

00:31:48,720 --> 00:31:52,109
most design questions I mean because

00:31:50,489 --> 00:31:53,989
this is basically a test design question

00:31:52,109 --> 00:31:57,720
it's you should let your pain guide you

00:31:53,989 --> 00:31:59,099
if it hurts do the other thing but

00:31:57,720 --> 00:32:01,799
between mocks and studs like there's a

00:31:59,099 --> 00:32:03,989
pretty important distinction there you

00:32:01,799 --> 00:32:07,440
use a stub when you want to verify the

00:32:03,989 --> 00:32:09,869
behavior of your method but you need

00:32:07,440 --> 00:32:12,419
input from somewhere else to accomplish

00:32:09,869 --> 00:32:14,669
that task and you use mocks when you

00:32:12,419 --> 00:32:18,659
want to verify how your object interacts

00:32:14,669 --> 00:32:20,729
with another object I think like I could

00:32:18,659 --> 00:32:23,419
say you should try to always use mocks

00:32:20,729 --> 00:32:26,429
and that's a consumer object-oriented

00:32:23,419 --> 00:32:28,979
geek thing to say but it's a really hard

00:32:26,429 --> 00:32:30,119
thing to do and so you should try but

00:32:28,979 --> 00:32:31,739
you're probably still going to need subs

00:32:30,119 --> 00:32:33,629
here and there and really a mock has a

00:32:31,739 --> 00:32:35,789
specialization of a stub sometimes when

00:32:33,629 --> 00:32:37,440
you have mocks you need some return

00:32:35,789 --> 00:32:39,389
values so that it does what it does and

00:32:37,440 --> 00:32:42,210
also you said the three things there's

00:32:39,389 --> 00:32:45,479
actually more that I left out right oh

00:32:42,210 --> 00:32:47,460
right there's the does a dummy object

00:32:45,479 --> 00:32:48,779
like when you just need to fulfill a

00:32:47,460 --> 00:32:50,159
constructor but it's not actually gonna

00:32:48,779 --> 00:32:51,539
be used that's called the donee object

00:32:50,159 --> 00:32:54,809
it's probably not that important that

00:32:51,539 --> 00:33:05,879
you know any of that did you just give

00:32:54,809 --> 00:33:06,779
up on your question oh okay yeah so I so

00:33:05,879 --> 00:33:09,080
I thought it's hot packed column

00:33:06,779 --> 00:33:14,390
currently over there

00:33:09,080 --> 00:33:21,490
oh alright that's just morning anything

00:33:14,390 --> 00:33:21,490

YouTube URL: https://www.youtube.com/watch?v=dMxSMPNu094


