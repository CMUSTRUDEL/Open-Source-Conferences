Title: DrupalCon New Orleans 2016: Typed Drupal - A great combination of Drupal 8 and PHP 7
Publication date: 2016-05-10
Playlist: DrupalCon New Orleans - May 2016
Description: 
	There are many advantages of a strongly typed language. Strong typing is a communication tool for explicit statements of intent backed by the guard of compilation. Strong typing has the following features:

Errors / Warnings in your editor as you code.
Better overall code readability.
Ease of Refactoring
Less bugs in your code.
Traditionally, PHP is a Weakly typed / Dynamically typed language. So, as a result, when we wrote custom modules in Drupal, we were not able to use strong typing and all other benefits typing provides. Also, PHP tries to convert the given variable to the type of the data value it is assigned when the types don't match (called Type Juggling), this can be a pain point and cause unexpected issues in your program. But, now with the advent of PHP 7, we can write typed code and there is an optional strict mode too!, How cool is that?

In this session, we will look at how we can use typed PHP code and write custom modules in Drupal 8. Writing Custom modules in Drupal 8 with PHP 7 is a very satisfying experience as we'll see in this session. We'll also see how to code modules in Drupal using strict typing mode of PHP 7.

 We will cover the following topics in this session:

Strongly Typed vs Weakly Typed Debate, Who wins?
Typing in PHP 7
Scalar Type Hints in PHP 7 and How to use them.
Return Type declarations and how to use them.
Using Strict Typing mode in PHP 7
Handling Type error exceptions.
Designing "Typed" Drupal modules with PHP 7.
Finally, we'll see how creating 'Typed' Drupal modules in PHP 7 is a winning combination and will help us build better, stable and bug-free modules.
Captions: 
	00:00:00,000 --> 00:00:07,460
all right welcome to New Orleans

00:00:03,510 --> 00:00:11,040
everybody and welcome to the 27th

00:00:07,460 --> 00:00:14,790
drupalcon could you hear me right there

00:00:11,040 --> 00:00:16,740
I did back yeah great so I came here

00:00:14,790 --> 00:00:18,810
like couple of days back in New Orleans

00:00:16,740 --> 00:00:22,020
the great city i went to the french

00:00:18,810 --> 00:00:24,720
quarters Bourbon Street and i'm sure

00:00:22,020 --> 00:00:27,180
most of you guys have went there too so

00:00:24,720 --> 00:00:32,040
yeah it's a great city a great drupalcon

00:00:27,180 --> 00:00:35,840
so yeah welcome here a quick note before

00:00:32,040 --> 00:00:39,360
we start our session drupal association

00:00:35,840 --> 00:00:41,399
encourages all of you to participate in

00:00:39,360 --> 00:00:45,930
the code sprints which will happen on

00:00:41,399 --> 00:00:47,280
friday the 13th and so there is

00:00:45,930 --> 00:00:49,020
something for everyone so if you are a

00:00:47,280 --> 00:00:52,410
newbie if you are a newbie to course

00:00:49,020 --> 00:00:55,170
prints you could join the first time

00:00:52,410 --> 00:00:57,059
sprinter workshop if you are a pro if

00:00:55,170 --> 00:01:00,270
you know how cold spring works you could

00:00:57,059 --> 00:01:02,160
join the generals friends or if you want

00:01:00,270 --> 00:01:05,580
a mentor course print you could join the

00:01:02,160 --> 00:01:07,830
mentor course print workshop as well so

00:01:05,580 --> 00:01:09,659
coats prints are a great way to

00:01:07,830 --> 00:01:13,500
contribute back to Drupal so I encourage

00:01:09,659 --> 00:01:20,610
all of you to go there and make your

00:01:13,500 --> 00:01:23,159
mark thank you all right so many of you

00:01:20,610 --> 00:01:26,250
might have seen the session description

00:01:23,159 --> 00:01:29,220
and many of you might have questions

00:01:26,250 --> 00:01:30,900
what is type Drupal so the answer is

00:01:29,220 --> 00:01:35,729
there is nothing like type Drupal I have

00:01:30,900 --> 00:01:39,479
made it up so what did what what so what

00:01:35,729 --> 00:01:41,820
this really means is now all of you know

00:01:39,479 --> 00:01:46,409
there is PHP there is a new PHP out

00:01:41,820 --> 00:01:48,720
there PHP 7 it's a brand new PHP with

00:01:46,409 --> 00:01:51,299
lots of cool features and one of the

00:01:48,720 --> 00:01:53,909
cool feature is the scalar type printing

00:01:51,299 --> 00:01:57,990
feature the return type declarations

00:01:53,909 --> 00:01:59,640
feature and some two or three features

00:01:57,990 --> 00:02:02,040
regarding typing so what we are doing

00:01:59,640 --> 00:02:04,920
here is I will see in this session how

00:02:02,040 --> 00:02:07,860
we could leverage those features those

00:02:04,920 --> 00:02:10,110
typing features and write better code in

00:02:07,860 --> 00:02:12,690
general and better Drupal 8 code in

00:02:10,110 --> 00:02:13,560
general so that's what type Drupal is if

00:02:12,690 --> 00:02:16,170
we leverage page

00:02:13,560 --> 00:02:18,780
7 it's typing features to write Drupal 8

00:02:16,170 --> 00:02:22,170
code so we will understand what are the

00:02:18,780 --> 00:02:24,870
features of typing features of PHP will

00:02:22,170 --> 00:02:27,480
look at some examples will then look at

00:02:24,870 --> 00:02:35,280
a module which is created in d8 a Drupal

00:02:27,480 --> 00:02:39,360
8 which uses PHP 7 let me quickly

00:02:35,280 --> 00:02:42,630
introduce myself my name is Aditya you

00:02:39,360 --> 00:02:45,209
can call me Adi I work as a solution

00:02:42,630 --> 00:02:48,319
architect in blistering solutions which

00:02:45,209 --> 00:02:51,090
is headquartered here in California

00:02:48,319 --> 00:02:54,540
blistering has been involved in Drupal

00:02:51,090 --> 00:02:56,340
development since 2007 especially the

00:02:54,540 --> 00:02:59,040
headless all decoupled Drupal

00:02:56,340 --> 00:03:00,989
development and if you have any further

00:02:59,040 --> 00:03:02,940
questions I mean we have been fortunate

00:03:00,989 --> 00:03:05,849
to support many Drupal constant Drupal

00:03:02,940 --> 00:03:09,209
camps we were the diamond sponsors for

00:03:05,849 --> 00:03:11,610
the large rupal corn in Asia in Mumbai

00:03:09,209 --> 00:03:14,099
and if you have any more questions you

00:03:11,610 --> 00:03:18,140
get contact me on this e-mail or you

00:03:14,099 --> 00:03:18,140
could contact me on this twitter handle

00:03:21,049 --> 00:03:28,260
all right let us quickly go through the

00:03:24,090 --> 00:03:31,470
agenda for today first we'll look at the

00:03:28,260 --> 00:03:34,109
concept of typing what it generally

00:03:31,470 --> 00:03:35,700
means and this goes beyond PHP this is a

00:03:34,109 --> 00:03:37,890
programming concept it's a very basic

00:03:35,700 --> 00:03:40,650
concept but we'll get to know what is

00:03:37,890 --> 00:03:42,000
typing as a concept then we'll see how

00:03:40,650 --> 00:03:46,250
different programming languages

00:03:42,000 --> 00:03:48,840
including PHP structure the type systems

00:03:46,250 --> 00:03:51,500
structure the type systems including

00:03:48,840 --> 00:03:54,209
typing as a concept then we'll see the

00:03:51,500 --> 00:03:56,700
existing type hinting for each end PHP

00:03:54,209 --> 00:03:59,579
which is not something new in PHP 7 its

00:03:56,700 --> 00:04:02,850
existing previously also we look at the

00:03:59,579 --> 00:04:06,269
type ending feature in PHP look at non

00:04:02,850 --> 00:04:09,989
scalar type ending feature we look at a

00:04:06,269 --> 00:04:12,329
feature or a flaw whatever you can call

00:04:09,989 --> 00:04:14,609
it will look at type juggling in PHP so

00:04:12,329 --> 00:04:18,570
this is all which is this these five

00:04:14,609 --> 00:04:21,060
points are all existing in PHP so this

00:04:18,570 --> 00:04:24,390
is not something new in PHP 7 but what

00:04:21,060 --> 00:04:28,120
is new in PHP 7r this thing

00:04:24,390 --> 00:04:30,760
scalar type ending in PHP return type

00:04:28,120 --> 00:04:33,490
declarations in PHP 7 type checking

00:04:30,760 --> 00:04:35,230
modes type exceptions which are a part

00:04:33,490 --> 00:04:39,640
of a broader concept called engine

00:04:35,230 --> 00:04:42,220
exceptions in PHP 7 and finally we'll

00:04:39,640 --> 00:04:44,410
see about we'll see how we could use PHP

00:04:42,220 --> 00:04:49,860
seven to write drupal 8 code using the

00:04:44,410 --> 00:04:49,860
principles that we have learnt so yeah

00:04:58,770 --> 00:05:07,480
alright so typing as a concept what does

00:05:04,360 --> 00:05:11,650
typing or type printing means right it

00:05:07,480 --> 00:05:13,810
simply means we give datatypes to

00:05:11,650 --> 00:05:17,470
variable declarations where we declare

00:05:13,810 --> 00:05:19,270
variables to parameters or arguments of

00:05:17,470 --> 00:05:22,390
a function when we declare a function or

00:05:19,270 --> 00:05:24,820
define function sorry return value of a

00:05:22,390 --> 00:05:26,800
function and expressions so typing

00:05:24,820 --> 00:05:28,690
simply means giving data types to

00:05:26,800 --> 00:05:30,400
variable declarations parameters of

00:05:28,690 --> 00:05:32,530
functions or arguments of a function

00:05:30,400 --> 00:05:34,300
return value of a function expression

00:05:32,530 --> 00:05:35,980
this is a is a pretty basic thing right

00:05:34,300 --> 00:05:40,660
this is not related to pizza basic

00:05:35,980 --> 00:05:43,330
programming kranj concept so now as we

00:05:40,660 --> 00:05:45,430
saw right a typing means giving data

00:05:43,330 --> 00:05:48,360
types two variables parameters written

00:05:45,430 --> 00:05:51,070
values now various programming languages

00:05:48,360 --> 00:05:55,480
structure that type systems according to

00:05:51,070 --> 00:05:57,160
these rules now like in PHP right in PHP

00:05:55,480 --> 00:06:00,280
we don't give a type of a variable by

00:05:57,160 --> 00:06:01,860
defining a variable so these rules are

00:06:00,280 --> 00:06:04,330
different in different languages and

00:06:01,860 --> 00:06:07,990
languages structure their type systems

00:06:04,330 --> 00:06:10,030
according to these rules so let us look

00:06:07,990 --> 00:06:13,030
at those type systems and whenever you

00:06:10,030 --> 00:06:14,470
search about type systems you will get

00:06:13,030 --> 00:06:18,340
these four terms that we are going to

00:06:14,470 --> 00:06:22,090
see first is strong type system now what

00:06:18,340 --> 00:06:25,270
this strong type system means is these

00:06:22,090 --> 00:06:27,430
type systems generally don't allow type

00:06:25,270 --> 00:06:30,100
violations in your program now what type

00:06:27,430 --> 00:06:32,800
violation means is suppose you declare a

00:06:30,100 --> 00:06:35,770
variable you declare a variable as an

00:06:32,800 --> 00:06:38,110
integer and then somewhere down the line

00:06:35,770 --> 00:06:40,960
in your program you assign a string

00:06:38,110 --> 00:06:43,060
value to your integer so that is a type

00:06:40,960 --> 00:06:45,070
violation right you declare an integer

00:06:43,060 --> 00:06:47,200
it's supposed to have an integer value

00:06:45,070 --> 00:06:48,640
but then down the line you give it a

00:06:47,200 --> 00:06:51,000
string value so that is the type

00:06:48,640 --> 00:06:53,860
violation so strong type systems

00:06:51,000 --> 00:06:55,600
generally don't allow type violation it

00:06:53,860 --> 00:06:58,350
will they will throw and compile error

00:06:55,600 --> 00:07:02,020
all they will throw an runtime exception

00:06:58,350 --> 00:07:04,810
when you try to do that some examples of

00:07:02,020 --> 00:07:08,370
languages having strong type systems are

00:07:04,810 --> 00:07:08,370
java and python

00:07:09,330 --> 00:07:17,800
second is the week type system week type

00:07:14,380 --> 00:07:20,290
system is a system where in case of type

00:07:17,800 --> 00:07:25,600
violations it allows it basically

00:07:20,290 --> 00:07:28,510
performs some kind of type conversion so

00:07:25,600 --> 00:07:31,930
let's let's take is the same example you

00:07:28,510 --> 00:07:34,510
defined an integer you gave that integer

00:07:31,930 --> 00:07:37,120
integer value but at some point in your

00:07:34,510 --> 00:07:40,180
program you assign that integer a string

00:07:37,120 --> 00:07:42,070
so it will try to convert that string

00:07:40,180 --> 00:07:44,710
value into integer so it will try to

00:07:42,070 --> 00:07:47,170
convert some kind of try to do some kind

00:07:44,710 --> 00:07:52,630
of type conversion PHP is an example of

00:07:47,170 --> 00:07:55,660
weak type system static type system

00:07:52,630 --> 00:07:59,410
these the languages having static type

00:07:55,660 --> 00:08:01,270
systems are Java and C sharp they are

00:07:59,410 --> 00:08:04,360
more likely to throw and compile time

00:08:01,270 --> 00:08:06,730
error if there are type violations in

00:08:04,360 --> 00:08:10,720
your program so they check the type

00:08:06,730 --> 00:08:14,710
violations at compile time the last one

00:08:10,720 --> 00:08:17,380
is a dynamic type systems they interpret

00:08:14,710 --> 00:08:19,950
the value of n variable the type of that

00:08:17,380 --> 00:08:22,630
variable or type violations at runtime

00:08:19,950 --> 00:08:25,390
so yeah so these are the four type

00:08:22,630 --> 00:08:29,350
systems that we generally see when you

00:08:25,390 --> 00:08:35,010
talk about typing or type in ting so

00:08:29,350 --> 00:08:37,300
yeah now these four types of type system

00:08:35,010 --> 00:08:41,430
generate or give us interesting

00:08:37,300 --> 00:08:44,440
two-dimensional space if you see here a

00:08:41,430 --> 00:08:47,080
language a programming language could

00:08:44,440 --> 00:08:50,200
could either have a strong type system

00:08:47,080 --> 00:08:52,720
or a weak type system a programming

00:08:50,200 --> 00:08:55,630
language could have either a static type

00:08:52,720 --> 00:08:57,580
system or a dynamic type system so

00:08:55,630 --> 00:09:00,850
strong and weak are like opposites

00:08:57,580 --> 00:09:05,140
static and dynamic are like opposites so

00:09:00,850 --> 00:09:07,540
Java here is having strong type system

00:09:05,140 --> 00:09:11,200
and a static type system what that means

00:09:07,540 --> 00:09:13,660
is Java is likely to throw compile-time

00:09:11,200 --> 00:09:18,520
errors if there are type violations in

00:09:13,660 --> 00:09:22,060
your program and yeah and it's more

00:09:18,520 --> 00:09:26,080
likely to not allow type why

00:09:22,060 --> 00:09:27,790
relations in your program and so Python

00:09:26,080 --> 00:09:32,380
right python is an example of strong

00:09:27,790 --> 00:09:34,360
typing and dynamic typing PHP our own

00:09:32,380 --> 00:09:40,410
PHP is an example of dynamic and weak

00:09:34,360 --> 00:09:46,510
typing okay so any questions still here

00:09:40,410 --> 00:09:49,450
okay right so one important point here

00:09:46,510 --> 00:09:52,300
is nothing is absolute in this case so

00:09:49,450 --> 00:09:55,990
there is nothing such as absolute strong

00:09:52,300 --> 00:09:59,590
typing system so this diagram with this

00:09:55,990 --> 00:10:03,130
classification just shows you that Java

00:09:59,590 --> 00:10:04,960
or Java tends to be a strong type system

00:10:03,130 --> 00:10:07,500
tends to have a strong type system and

00:10:04,960 --> 00:10:09,760
Java tends to have a static type system

00:10:07,500 --> 00:10:12,970
so there are still some components in

00:10:09,760 --> 00:10:15,390
Java with which follow the week type

00:10:12,970 --> 00:10:15,390
system

00:10:19,290 --> 00:10:27,029
right now we'll move on to type ending

00:10:23,040 --> 00:10:30,209
in PHP what type ending is it simply

00:10:27,029 --> 00:10:33,029
means it allows you to specify the type

00:10:30,209 --> 00:10:35,819
of data which a method is expecting so

00:10:33,029 --> 00:10:41,240
let us look at this function I have one

00:10:35,819 --> 00:10:46,170
function re function that accepts an

00:10:41,240 --> 00:10:48,959
integer array and array I have called

00:10:46,170 --> 00:10:52,920
this function at the bottom by passing

00:10:48,959 --> 00:10:55,339
it an array so are the function what

00:10:52,920 --> 00:10:59,160
this code tells you is are the function

00:10:55,339 --> 00:11:01,440
accepts one argument which is airing so

00:10:59,160 --> 00:11:04,889
that is type in ting simply you tell the

00:11:01,440 --> 00:11:08,850
function that you will accept you will

00:11:04,889 --> 00:11:11,180
expect an airing as an argument its type

00:11:08,850 --> 00:11:11,180
ending

00:11:15,390 --> 00:11:21,390
yeah so we saw our type hinting which is

00:11:17,970 --> 00:11:24,210
just specifying the type of your

00:11:21,390 --> 00:11:26,850
argument then we'll see about non scalar

00:11:24,210 --> 00:11:28,530
type in ting now before that let me

00:11:26,850 --> 00:11:31,530
explain you the difference between

00:11:28,530 --> 00:11:34,650
scalar and non scalar variables non

00:11:31,530 --> 00:11:37,140
scalar types and scalar types scalar

00:11:34,650 --> 00:11:41,280
types are your primitive data types like

00:11:37,140 --> 00:11:43,290
integer bulleen string float and non

00:11:41,280 --> 00:11:45,540
scalar types are your complex data types

00:11:43,290 --> 00:11:50,880
like objects arrays khali balls

00:11:45,540 --> 00:11:54,270
interface so so these are non scalar and

00:11:50,880 --> 00:11:58,490
scalar types now what php5 supports is

00:11:54,270 --> 00:11:58,490
they support non scalar type hinting

00:11:59,180 --> 00:12:05,670
yeah so the same example that we saw

00:12:02,160 --> 00:12:08,400
earlier this is PHP 5 by the way the

00:12:05,670 --> 00:12:12,210
same example functionality function has

00:12:08,400 --> 00:12:15,300
one argument it takes an array it prints

00:12:12,210 --> 00:12:18,680
an array and we are passing it a diary

00:12:15,300 --> 00:12:21,780
so everything should work well this

00:12:18,680 --> 00:12:30,060
snippet should return you should print

00:12:21,780 --> 00:12:35,610
an array correct now let us look at this

00:12:30,060 --> 00:12:41,790
example this example would give us an

00:12:35,610 --> 00:12:44,610
error yeah it will give us this error so

00:12:41,790 --> 00:12:48,030
let us look what this error is argument

00:12:44,610 --> 00:12:52,680
1 past 2 r.d function must be an

00:12:48,030 --> 00:12:56,730
instance of int integer given so what

00:12:52,680 --> 00:12:59,730
this means is PHP 5 doesn't support

00:12:56,730 --> 00:13:03,570
scalar type painting so you could not

00:12:59,730 --> 00:13:06,540
suggest that dollar my integer could be

00:13:03,570 --> 00:13:11,520
an integer float bullying or string so

00:13:06,540 --> 00:13:16,130
what this does is the system hunts for a

00:13:11,520 --> 00:13:20,430
class named integer and it expects

00:13:16,130 --> 00:13:22,740
object of int class integer class in

00:13:20,430 --> 00:13:24,510
this function but it doesn't find any so

00:13:22,740 --> 00:13:26,940
that is why it throws an error argument

00:13:24,510 --> 00:13:28,730
one pass 2 r.d function must be an

00:13:26,940 --> 00:13:30,980
instance of integer

00:13:28,730 --> 00:13:38,990
so that means PFI doesn't support scalar

00:13:30,980 --> 00:13:43,459
type printing yet so uh so by not having

00:13:38,990 --> 00:13:46,940
scalar type hinting what is the issue

00:13:43,459 --> 00:13:50,269
what's the problem right so the problem

00:13:46,940 --> 00:13:53,870
is type juggling so type juggling is a

00:13:50,269 --> 00:13:56,500
feature where we convert a variable type

00:13:53,870 --> 00:13:59,180
to the most appropriate variable type

00:13:56,500 --> 00:14:01,699
according to the action performed to

00:13:59,180 --> 00:14:07,279
explain it further let us go to this

00:14:01,699 --> 00:14:10,820
function it's a very simple function it

00:14:07,279 --> 00:14:13,160
just accepts two arguments it compares

00:14:10,820 --> 00:14:16,490
the first argument with the second it

00:14:13,160 --> 00:14:18,230
prints if the first argument is less

00:14:16,490 --> 00:14:20,000
than second argument it prints first is

00:14:18,230 --> 00:14:23,300
less than second otherwise it prints

00:14:20,000 --> 00:14:25,220
second is less than first so everything

00:14:23,300 --> 00:14:26,839
looks fine here we have a function we

00:14:25,220 --> 00:14:30,529
have two arguments I've called the

00:14:26,839 --> 00:14:34,399
function with two integers very simple

00:14:30,529 --> 00:14:39,019
right this should return you first is

00:14:34,399 --> 00:14:41,500
less than second correct all right 10 is

00:14:39,019 --> 00:14:47,269
less than 12 first is less than second

00:14:41,500 --> 00:14:50,300
so now look at this what i'm doing here

00:14:47,269 --> 00:14:52,819
is instead of passing 12 as the second

00:14:50,300 --> 00:14:59,260
input or second argument in the compare

00:14:52,819 --> 00:15:03,769
function i am passing a string foo it

00:14:59,260 --> 00:15:06,050
still gives us and varied output which

00:15:03,769 --> 00:15:08,060
is second is less than first now now

00:15:06,050 --> 00:15:10,910
this is something this is a problem this

00:15:08,060 --> 00:15:14,060
is bizarre because 10 and a string

00:15:10,910 --> 00:15:16,720
called foo cannot be compared but it

00:15:14,060 --> 00:15:20,720
will still return you a valid output

00:15:16,720 --> 00:15:22,730
that second is less than first and

00:15:20,720 --> 00:15:24,800
believe me this is a very small function

00:15:22,730 --> 00:15:27,829
but if you have a code base which is

00:15:24,800 --> 00:15:30,170
huge and if you have some functions like

00:15:27,829 --> 00:15:32,930
this so in place of an integer you pass

00:15:30,170 --> 00:15:34,970
and string it's very difficult to debug

00:15:32,930 --> 00:15:37,160
or find out where the problem is because

00:15:34,970 --> 00:15:39,680
your program would be running smoothly

00:15:37,160 --> 00:15:42,050
there would be no errors but it's still

00:15:39,680 --> 00:15:43,070
wrong right you cannot compare 10 and

00:15:42,050 --> 00:15:47,190
foo

00:15:43,070 --> 00:15:48,899
so this is where the problem is now to

00:15:47,190 --> 00:15:54,990
solve this problem what I need to do in

00:15:48,899 --> 00:15:57,720
this code is I need to basically check

00:15:54,990 --> 00:16:01,949
if the dot if dollar first or dollar

00:15:57,720 --> 00:16:05,610
second is an integer or not right this

00:16:01,949 --> 00:16:08,820
makes sense so I check if both a dollar

00:16:05,610 --> 00:16:14,399
first and dollar second are integers

00:16:08,820 --> 00:16:16,230
then only I compare them and now what

00:16:14,399 --> 00:16:21,060
we'll get now I call the same function

00:16:16,230 --> 00:16:23,370
with 10 and string foo so it will return

00:16:21,060 --> 00:16:25,980
me an output please pass integer inputs

00:16:23,370 --> 00:16:28,800
that is correct right so this function

00:16:25,980 --> 00:16:30,269
should accept integer inputs and passing

00:16:28,800 --> 00:16:32,490
a string it should return me something

00:16:30,269 --> 00:16:37,620
to tell me that please pass integer

00:16:32,490 --> 00:16:40,350
inputs so I have to write this tedious

00:16:37,620 --> 00:16:43,110
up functions like this tedious check

00:16:40,350 --> 00:16:46,860
logic everywhere is integer is array is

00:16:43,110 --> 00:16:48,930
empty set to check in my functions that

00:16:46,860 --> 00:16:52,850
if the types of the variable past are

00:16:48,930 --> 00:17:00,660
correct or not so this could be avoided

00:16:52,850 --> 00:17:02,750
in PHP 7 now PHP 7 is a huge improvement

00:17:00,660 --> 00:17:06,660
or PHP I don't need to tell you that

00:17:02,750 --> 00:17:10,290
there are many cool features in PHP 71

00:17:06,660 --> 00:17:13,770
is scalar type hinting so scalar type

00:17:10,290 --> 00:17:17,850
painting was introduced in PHP last year

00:17:13,770 --> 00:17:20,309
and it was an RFC you can look you can

00:17:17,850 --> 00:17:23,459
have a look at the RFC here the proposal

00:17:20,309 --> 00:17:27,569
was passed and scalar type painting was

00:17:23,459 --> 00:17:30,030
introduced in PHP seven right so it was

00:17:27,569 --> 00:17:32,910
one of the most controversial proposals

00:17:30,030 --> 00:17:35,640
in PHP so there is a very heated debate

00:17:32,910 --> 00:17:38,820
out there on if we if we should

00:17:35,640 --> 00:17:41,940
introduce scalar type hinting on in PHP

00:17:38,820 --> 00:17:43,650
or not but i am not going to go there we

00:17:41,940 --> 00:17:45,390
the point is we have a feature called

00:17:43,650 --> 00:17:49,559
scalar type in ting and we are going to

00:17:45,390 --> 00:17:54,620
use it in PHP style right so what this

00:17:49,559 --> 00:17:54,620
means is let's look at the last example

00:17:56,770 --> 00:18:05,020
this example right so it didn't allow me

00:18:01,010 --> 00:18:07,790
to specify my argument type as integer

00:18:05,020 --> 00:18:09,680
it will allow me to specify my argument

00:18:07,790 --> 00:18:15,070
type as array object or callable which

00:18:09,680 --> 00:18:15,070
are non scalar types but now in PHP 7

00:18:19,990 --> 00:18:28,929
this will work fine right so what I've

00:18:24,790 --> 00:18:31,600
done here is I have made the same

00:18:28,929 --> 00:18:33,940
function are the function it expects one

00:18:31,600 --> 00:18:35,650
argument which is integer I have

00:18:33,940 --> 00:18:38,590
specified that this should be an integer

00:18:35,650 --> 00:18:41,980
and I am calling the function passing an

00:18:38,590 --> 00:18:43,780
integer 1 so this should work well and

00:18:41,980 --> 00:18:47,650
it should return me an output well

00:18:43,780 --> 00:18:49,929
output 1 so this this happens in PHP you

00:18:47,650 --> 00:18:51,429
could write in place of integer then you

00:18:49,929 --> 00:18:58,059
could write float you could write pool

00:18:51,429 --> 00:19:00,429
in you could write string as well yeah

00:18:58,059 --> 00:19:03,400
so this is the contrast I was referring

00:19:00,429 --> 00:19:07,510
to right this is PHP 5 this is PHP seven

00:19:03,400 --> 00:19:09,880
so PHP 7 you can specify our methods

00:19:07,510 --> 00:19:13,780
argument as integer you could pass and

00:19:09,880 --> 00:19:19,030
and it would work and php5 it will it

00:19:13,780 --> 00:19:25,240
would throw of an error now let's see

00:19:19,030 --> 00:19:26,980
here this is PHP 7 I'm sorry so I have

00:19:25,240 --> 00:19:29,380
made the same function function are the

00:19:26,980 --> 00:19:31,630
function it accepts an integer I've

00:19:29,380 --> 00:19:33,970
specified the argument type as integer

00:19:31,630 --> 00:19:37,230
and I've calling the function by passing

00:19:33,970 --> 00:19:41,290
a string so this will return me an error

00:19:37,230 --> 00:19:42,970
uncaught type error argument one pass to

00:19:41,290 --> 00:19:47,140
Adi function must be of type integer

00:19:42,970 --> 00:19:49,420
string given so if you compare this with

00:19:47,140 --> 00:19:53,380
my last example the compare function I

00:19:49,420 --> 00:19:55,750
needed to check if the past integer was

00:19:53,380 --> 00:19:58,840
indeed an integer or not but in at this

00:19:55,750 --> 00:20:03,280
stage PHP seven does it for does it for

00:19:58,840 --> 00:20:05,110
me so it checks if the past variable

00:20:03,280 --> 00:20:08,200
which is hey in this case a string which

00:20:05,110 --> 00:20:10,090
is not matching to the parameter hint

00:20:08,200 --> 00:20:15,850
which is integer or parameter type which

00:20:10,090 --> 00:20:18,160
is integer it will throw an error yeah

00:20:15,850 --> 00:20:20,910
so this is the same example that we saw

00:20:18,160 --> 00:20:24,730
earlier compare function takes two

00:20:20,910 --> 00:20:26,290
variables it checks if the first

00:20:24,730 --> 00:20:29,410
variable is less than second variable

00:20:26,290 --> 00:20:33,160
and basically echoes or prints these

00:20:29,410 --> 00:20:34,090
statements accordingly so as you can see

00:20:33,160 --> 00:20:36,220
here

00:20:34,090 --> 00:20:40,000
the last time when we had executed this

00:20:36,220 --> 00:20:42,279
function it worked and it gave us an

00:20:40,000 --> 00:20:44,110
output second is less than first by

00:20:42,279 --> 00:20:47,080
comparing 10 and integer foo which is

00:20:44,110 --> 00:20:51,279
not which should not be done but here in

00:20:47,080 --> 00:20:53,590
PHP 7 this piece of code will throw us

00:20:51,279 --> 00:20:57,070
an error the error would be and got type

00:20:53,590 --> 00:20:59,140
error argument to passed to compare

00:20:57,070 --> 00:21:03,760
function must be of type integer string

00:20:59,140 --> 00:21:07,600
given right so this is how type hinting

00:21:03,760 --> 00:21:10,809
works in PHP 7 you specify the type ends

00:21:07,600 --> 00:21:13,440
of your arguments when defining a

00:21:10,809 --> 00:21:16,870
function and we are calling the function

00:21:13,440 --> 00:21:18,429
you make sure that you follow the type

00:21:16,870 --> 00:21:20,620
that you are given so you cannot pass a

00:21:18,429 --> 00:21:22,919
string in where it's expecting an

00:21:20,620 --> 00:21:22,919
integer

00:21:27,549 --> 00:21:32,529
alright so what are the benefits of

00:21:30,879 --> 00:21:34,509
scalar type painting right so we have

00:21:32,529 --> 00:21:36,159
seen scalar type printing but what are

00:21:34,509 --> 00:21:38,950
the benefits why it was introduced in

00:21:36,159 --> 00:21:41,559
the first place so the first benefit is

00:21:38,950 --> 00:21:46,029
less bugs so I we just saw a piece of

00:21:41,559 --> 00:21:48,100
code which compared to integers and it

00:21:46,029 --> 00:21:49,840
allowed us to compare integer in a

00:21:48,100 --> 00:21:54,519
string and it still gave us an valid

00:21:49,840 --> 00:21:56,830
output but so and so this kind of bugs

00:21:54,519 --> 00:21:59,110
are very difficult to find especially

00:21:56,830 --> 00:22:02,279
your code bases if your code base is

00:21:59,110 --> 00:22:05,769
very huge so in that case type printing

00:22:02,279 --> 00:22:09,070
defining your functions and your

00:22:05,769 --> 00:22:13,690
arguments with tie pins will reduce your

00:22:09,070 --> 00:22:15,909
bugs code readability if you give type

00:22:13,690 --> 00:22:17,739
hints to your function parameters it

00:22:15,909 --> 00:22:19,239
improves your code readability jobbers

00:22:17,739 --> 00:22:21,220
by looking at your code you would see

00:22:19,239 --> 00:22:24,700
what this function does what this piece

00:22:21,220 --> 00:22:26,529
of code does concrete function

00:22:24,700 --> 00:22:29,289
definition as I told you right so if you

00:22:26,529 --> 00:22:31,539
define a function which accepts three

00:22:29,289 --> 00:22:33,730
arguments and if you specify the type of

00:22:31,539 --> 00:22:34,779
these three arguments you won't even

00:22:33,730 --> 00:22:36,940
need to look at the function

00:22:34,779 --> 00:22:38,350
documentation to see what the function

00:22:36,940 --> 00:22:40,419
does just look at the function

00:22:38,350 --> 00:22:45,609
definition you would get to know what

00:22:40,419 --> 00:22:49,299
this function does alright so the next

00:22:45,609 --> 00:22:52,119
part of this is return type declarations

00:22:49,299 --> 00:22:54,909
in PHP 7 which is a part of this broad

00:22:52,119 --> 00:23:01,739
scalar type hinting feature so up by the

00:22:54,909 --> 00:23:01,739
way of any doubt still here all right

00:23:01,940 --> 00:23:13,009
so right so in PHP 7 we could specify

00:23:10,220 --> 00:23:15,590
the data type of a return value of a

00:23:13,009 --> 00:23:17,629
function so if you define a function if

00:23:15,590 --> 00:23:19,370
it suppose if it's supposed to be return

00:23:17,629 --> 00:23:21,409
an integer you could specify that this

00:23:19,370 --> 00:23:25,940
function is supposed to return an

00:23:21,409 --> 00:23:29,929
integer so if you look at this code here

00:23:25,940 --> 00:23:32,960
in PHP 7 you could do that function are

00:23:29,929 --> 00:23:37,309
the function same function it takes the

00:23:32,960 --> 00:23:39,799
same integer argument but here if you

00:23:37,309 --> 00:23:42,350
see the colon thing there so I have

00:23:39,799 --> 00:23:45,919
written a colon space integer so what

00:23:42,350 --> 00:23:49,639
this means is this function will always

00:23:45,919 --> 00:23:52,070
return an integer so the return value

00:23:49,639 --> 00:23:55,129
then so this function would always

00:23:52,070 --> 00:23:57,980
return an integer so these are the

00:23:55,129 --> 00:24:00,559
return type declarations then add line

00:23:57,980 --> 00:24:02,179
number 7 i've basically passing the

00:24:00,559 --> 00:24:05,360
integer there and it's returning the

00:24:02,179 --> 00:24:08,509
same integer so this function this piece

00:24:05,360 --> 00:24:17,299
of code would work and it will give us

00:24:08,509 --> 00:24:22,190
the output 1 ok let's look at the same

00:24:17,299 --> 00:24:24,679
piece of code now what I'm doing is I

00:24:22,190 --> 00:24:26,870
have defined a function the return value

00:24:24,679 --> 00:24:28,789
of return type of that functions integer

00:24:26,870 --> 00:24:31,250
but this function is returning and

00:24:28,789 --> 00:24:33,500
string my string is the string so that

00:24:31,250 --> 00:24:35,870
is not allowed so if you define a

00:24:33,500 --> 00:24:38,720
function which is written value as

00:24:35,870 --> 00:24:41,299
integer you cannot read another string

00:24:38,720 --> 00:24:42,860
same way if you define a function with

00:24:41,299 --> 00:24:46,039
its return value as string you cannot

00:24:42,860 --> 00:24:48,080
return anything else so up this will

00:24:46,039 --> 00:24:49,610
throw of an error return value of our

00:24:48,080 --> 00:24:54,039
the function must be of type integer

00:24:49,610 --> 00:24:54,039
string return ok

00:24:56,730 --> 00:25:05,500
no it will not allow now I twill the so

00:25:01,500 --> 00:25:07,120
so if your function returns null there

00:25:05,500 --> 00:25:09,759
is a possibility that it will return

00:25:07,120 --> 00:25:20,080
none so you should not use type return

00:25:09,759 --> 00:25:21,460
type things yeah it's an a type error

00:25:20,080 --> 00:25:31,990
exception yeah so we'll get to that

00:25:21,460 --> 00:25:36,870
later yeah yeah yeah no I don't think so

00:25:31,990 --> 00:25:36,870
no okay

00:25:37,160 --> 00:25:44,340
yeah I could return arrays and objects

00:25:39,690 --> 00:25:47,490
that one right so what are the features

00:25:44,340 --> 00:25:49,440
of return type declaration right it's a

00:25:47,490 --> 00:25:51,990
nice contract between the collar and

00:25:49,440 --> 00:25:55,200
called function so if I'm calling a

00:25:51,990 --> 00:25:57,030
function I could reasonably I could be

00:25:55,200 --> 00:26:00,090
reasonably sure that this function would

00:25:57,030 --> 00:26:02,280
return what what it is promising so if I

00:26:00,090 --> 00:26:04,050
am calling a function which has a return

00:26:02,280 --> 00:26:06,060
value as integer it will always return

00:26:04,050 --> 00:26:08,850
me an integer I could be sure of so I

00:26:06,060 --> 00:26:11,130
don't I add in I don't need to check the

00:26:08,850 --> 00:26:13,650
output returned by the function in my

00:26:11,130 --> 00:26:15,930
program I don't need to do those nasty

00:26:13,650 --> 00:26:18,540
is integer is string or Ziggy's empty

00:26:15,930 --> 00:26:21,390
checks at my end well this is a good

00:26:18,540 --> 00:26:23,520
stuff so yeah as I told you no error

00:26:21,390 --> 00:26:25,500
handling required in the caller function

00:26:23,520 --> 00:26:27,150
so if I am calling something I can be

00:26:25,500 --> 00:26:29,310
absolutely sure that the function which

00:26:27,150 --> 00:26:32,480
is returning which has a return type is

00:26:29,310 --> 00:26:34,890
a type it will return the same time

00:26:32,480 --> 00:26:37,770
function definitions are more readable

00:26:34,890 --> 00:26:39,900
it's basically complete for just one

00:26:37,770 --> 00:26:42,150
look at the function you would get to

00:26:39,900 --> 00:26:45,390
know what type of arguments is expecting

00:26:42,150 --> 00:26:51,030
and what type of return value it should

00:26:45,390 --> 00:26:54,570
give and yeah so how many of you are

00:26:51,030 --> 00:26:59,430
Drupal developers here sorry wrong

00:26:54,570 --> 00:27:01,920
question to ask but yeah so how many of

00:26:59,430 --> 00:27:06,120
you remember this is said and not

00:27:01,920 --> 00:27:08,820
empties right right so I understand I'm

00:27:06,120 --> 00:27:12,300
even even in the Drupal core functions

00:27:08,820 --> 00:27:14,910
like user load load load they are so

00:27:12,300 --> 00:27:17,700
user load cat return and false value if

00:27:14,910 --> 00:27:19,350
the user doesn't exist in the system so

00:27:17,700 --> 00:27:22,350
you have to check it in your code so if

00:27:19,350 --> 00:27:23,850
you have if you basically call user load

00:27:22,350 --> 00:27:25,980
function you have to check if the user

00:27:23,850 --> 00:27:28,320
load returns false that means the user

00:27:25,980 --> 00:27:30,120
does not exist in the system if its

00:27:28,320 --> 00:27:33,990
return an object usually exist in the

00:27:30,120 --> 00:27:37,260
system so point is in Drupal 7 code and

00:27:33,990 --> 00:27:41,190
even in Drupal 8 code you need to have

00:27:37,260 --> 00:27:44,220
such Czechs everywhere in your code just

00:27:41,190 --> 00:27:45,900
for your just to be safe just to be sure

00:27:44,220 --> 00:27:48,530
that you are handling all cases

00:27:45,900 --> 00:27:48,530
correctly

00:27:48,540 --> 00:27:56,650
so by using type hinting by using type

00:27:54,880 --> 00:27:58,390
hinting you don't need to handle these

00:27:56,650 --> 00:28:02,200
cases so you could be absolutely sure

00:27:58,390 --> 00:28:03,640
that what I am getting here what the

00:28:02,200 --> 00:28:12,549
function is returning is an integer

00:28:03,640 --> 00:28:16,600
nothing else all right now we saw some

00:28:12,549 --> 00:28:20,679
concepts of typing non scalar typing

00:28:16,600 --> 00:28:24,760
scalar typing return type declarations

00:28:20,679 --> 00:28:28,330
now CEO now we will see how those types

00:28:24,760 --> 00:28:31,140
are implemented in PHP 7 so PHP 7 has

00:28:28,330 --> 00:28:34,360
something called as type checking modes

00:28:31,140 --> 00:28:38,350
so there are two type shaking modes one

00:28:34,360 --> 00:28:41,350
is weak mode so what this week mode does

00:28:38,350 --> 00:28:43,480
is it's your default checking mode so

00:28:41,350 --> 00:28:46,360
whatever code you write in PHP 7 by

00:28:43,480 --> 00:28:50,320
default follows this week mode and what

00:28:46,360 --> 00:28:53,140
week mode does is it will still try to

00:28:50,320 --> 00:28:55,799
perform the type juggling or type type

00:28:53,140 --> 00:28:59,679
conversion in case the types don't match

00:28:55,799 --> 00:29:04,330
right so let us look at this piece of

00:28:59,679 --> 00:29:08,110
code you can define week mode in your

00:29:04,330 --> 00:29:10,870
file by writing a declare statement line

00:29:08,110 --> 00:29:14,190
number 3 declare strict types is equal

00:29:10,870 --> 00:29:16,870
to 0 that means the code which follows

00:29:14,190 --> 00:29:18,910
and this will be the first statement in

00:29:16,870 --> 00:29:21,010
the file so the code which follows this

00:29:18,910 --> 00:29:22,419
declare statement will follow the week

00:29:21,010 --> 00:29:24,419
mode and we don't need to do that

00:29:22,419 --> 00:29:28,410
explicitly because this is by default

00:29:24,419 --> 00:29:34,770
PHP 07 by default follows the week mode

00:29:28,410 --> 00:29:37,000
so let us look at the example here I am

00:29:34,770 --> 00:29:39,790
defining the same function are the

00:29:37,000 --> 00:29:43,030
function which accepts an integer input

00:29:39,790 --> 00:29:47,470
and returns an integer but when I try to

00:29:43,030 --> 00:29:53,830
call that function using one but it is n

00:29:47,470 --> 00:29:56,710
string 1 this will this will be passed

00:29:53,830 --> 00:30:00,520
this won't throw off any error because

00:29:56,710 --> 00:30:01,460
what it did was it converted the string

00:30:00,520 --> 00:30:05,480
1 in

00:30:01,460 --> 00:30:07,429
two numeric one and the fire the program

00:30:05,480 --> 00:30:10,730
works well so this is how weak mode

00:30:07,429 --> 00:30:13,130
works it will still try to perform type

00:30:10,730 --> 00:30:15,820
juggling or type converse conversion if

00:30:13,130 --> 00:30:19,640
your past value doesn't match the

00:30:15,820 --> 00:30:25,730
function type int a pass an argument

00:30:19,640 --> 00:30:30,860
type int now let us look at this this

00:30:25,730 --> 00:30:33,850
will return ass and error now let's see

00:30:30,860 --> 00:30:37,760
what what's happened here same function

00:30:33,850 --> 00:30:40,429
same argument same return value I have

00:30:37,760 --> 00:30:42,950
just instead of numeric 1 i've passed a

00:30:40,429 --> 00:30:47,390
string called hey which is obviously

00:30:42,950 --> 00:30:50,630
it's not an integer so the corner the

00:30:47,390 --> 00:30:52,399
conversion field type juggling failed it

00:30:50,630 --> 00:30:54,860
gave us an error uncaught type error

00:30:52,399 --> 00:30:59,080
argument one pass 2 r.d function must be

00:30:54,860 --> 00:30:59,080
of type in dere string given yeah

00:31:04,270 --> 00:31:09,940
because that would otherwise been cast

00:31:10,700 --> 00:31:23,580
correct yes let's a different kind of

00:31:17,100 --> 00:31:30,630
type juggling yeah so weak mode still

00:31:23,580 --> 00:31:33,500
has some back doors so in this case it

00:31:30,630 --> 00:31:35,669
will still try to perform type juggling

00:31:33,500 --> 00:31:37,620
string one could be converted into

00:31:35,669 --> 00:31:40,799
integer 1b and that's why this function

00:31:37,620 --> 00:31:42,419
this program would succeed but this code

00:31:40,799 --> 00:31:47,669
would feel because he could not be

00:31:42,419 --> 00:31:53,240
converted into an integer right now

00:31:47,669 --> 00:31:53,240
let's look at the strict mode what it is

00:31:53,360 --> 00:31:59,970
yeah so strict mode very simple at the

00:31:57,570 --> 00:32:01,860
first line of your file write this

00:31:59,970 --> 00:32:06,900
statement declare strict types is equal

00:32:01,860 --> 00:32:10,740
to one I have used the same function Adi

00:32:06,900 --> 00:32:14,490
function it accepts one argument integer

00:32:10,740 --> 00:32:17,130
argument it returns an integer and now

00:32:14,490 --> 00:32:21,690
I'm calling that function down and I am

00:32:17,130 --> 00:32:25,070
passing one which is a string one in

00:32:21,690 --> 00:32:29,039
this case it will not allow at all

00:32:25,070 --> 00:32:31,289
because this is PHP's strict mode it

00:32:29,039 --> 00:32:33,330
will not allow a string value even if

00:32:31,289 --> 00:32:35,669
it's one it will not allow a string

00:32:33,330 --> 00:32:38,100
value when it's expecting an integer

00:32:35,669 --> 00:32:42,150
value so this is a crucial difference

00:32:38,100 --> 00:32:46,650
between PHP's week mode and strict mode

00:32:42,150 --> 00:32:48,990
so in week mode it allowed us to pass a

00:32:46,650 --> 00:32:53,250
string one when it's expecting an

00:32:48,990 --> 00:32:57,919
integer parameter but in strict mode it

00:32:53,250 --> 00:32:57,919
didn't allow us yeah

00:32:59,750 --> 00:33:02,750
sorry

00:33:06,930 --> 00:33:13,470
it is it's based upon a file so if when

00:33:11,340 --> 00:33:16,470
you when you write a PHP file and if you

00:33:13,470 --> 00:33:20,010
write a declare statement here so all

00:33:16,470 --> 00:33:23,780
functions called from that file will

00:33:20,010 --> 00:33:35,780
follow the strict checking in this case

00:33:23,780 --> 00:33:35,780
yeah we for reform sorry no

00:33:38,860 --> 00:33:42,929
so the point was

00:33:53,260 --> 00:34:03,280
the am sorry it's in file so it's file

00:34:00,790 --> 00:34:04,960
wise so when you write a file and when

00:34:03,280 --> 00:34:06,280
you it should those are declare

00:34:04,960 --> 00:34:09,639
statement should be the first statement

00:34:06,280 --> 00:34:12,220
in your file and the functions which are

00:34:09,639 --> 00:34:14,679
called in your files the call function

00:34:12,220 --> 00:34:18,210
calls would follow the strict the type

00:34:14,679 --> 00:34:18,210
checking mode that you are defined I

00:34:26,010 --> 00:34:32,800
don't think so because yeah I think this

00:34:30,399 --> 00:34:49,360
statement should be the first line your

00:34:32,800 --> 00:34:51,940
program right so I mean I haven't tried

00:34:49,360 --> 00:35:00,310
that but certainly an interesting piece

00:34:51,940 --> 00:35:05,710
to look at yeah sure okay so the reason

00:35:00,310 --> 00:35:08,260
a 24 PHP to follow the default week

00:35:05,710 --> 00:35:10,930
modus they didn't want to enforce the

00:35:08,260 --> 00:35:13,300
type system on everybody so this still

00:35:10,930 --> 00:35:15,940
wanted to preserve the ethos of being a

00:35:13,300 --> 00:35:18,040
very dynamic and flexible language but

00:35:15,940 --> 00:35:20,620
still wanted their developers to use

00:35:18,040 --> 00:35:22,690
strong typing just in case if they want

00:35:20,620 --> 00:35:26,340
to use them you could very well use

00:35:22,690 --> 00:35:26,340
strict typing in your own custom code

00:35:29,140 --> 00:35:35,789
some important points to note here

00:35:32,069 --> 00:35:39,309
return type declarations are optional

00:35:35,789 --> 00:35:45,309
the only type conversion allowed is

00:35:39,309 --> 00:35:48,400
integer to float so if your function is

00:35:45,309 --> 00:35:50,799
expecting an argument of float you could

00:35:48,400 --> 00:35:53,859
still pass that function an argument of

00:35:50,799 --> 00:35:56,470
integer because the rd the point here is

00:35:53,859 --> 00:35:58,630
if you convert an integer into float no

00:35:56,470 --> 00:36:00,970
data is lost but if you try to convert a

00:35:58,630 --> 00:36:05,140
float into integer data could be lost

00:36:00,970 --> 00:36:07,059
right so even in even in strict typing

00:36:05,140 --> 00:36:10,119
the only type conversion allowed is

00:36:07,059 --> 00:36:11,859
integer to float and now it's still

00:36:10,119 --> 00:36:15,400
allowed as a default value for a

00:36:11,859 --> 00:36:20,170
function parameter so this snippet is

00:36:15,400 --> 00:36:22,589
still valid what I've done here is I've

00:36:20,170 --> 00:36:26,529
created one function the exception float

00:36:22,589 --> 00:36:29,289
I've passed it an integer it typed it

00:36:26,529 --> 00:36:36,160
allowed us to do so and it allowed us to

00:36:29,289 --> 00:36:38,880
set a default null value also sorry no I

00:36:36,160 --> 00:36:38,880
don't think so done past

00:36:40,110 --> 00:36:43,040
hmm

00:36:46,240 --> 00:36:51,170
so if you don't want to pass anything so

00:36:49,490 --> 00:36:56,380
that I mean that is the point of default

00:36:51,170 --> 00:36:56,380
value ring now this is just an example

00:37:18,840 --> 00:37:26,520
right right right right so that is

00:37:23,190 --> 00:37:28,230
correct so this is just an example of to

00:37:26,520 --> 00:37:29,700
show you that this could be done I would

00:37:28,230 --> 00:37:33,210
not personally do it because that would

00:37:29,700 --> 00:37:37,550
defeat the purpose of typing for me but

00:37:33,210 --> 00:37:37,550
still this is something you could do all

00:37:37,940 --> 00:37:53,100
right so so anybody remember this the

00:37:44,160 --> 00:37:55,200
white screen of that right so anybody

00:37:53,100 --> 00:37:58,020
who has worked with PHP applications or

00:37:55,200 --> 00:38:00,150
drupal must know this right so there was

00:37:58,020 --> 00:38:04,020
an error in your PHP script your PHP

00:38:00,150 --> 00:38:06,420
script hides and it does not return HTML

00:38:04,020 --> 00:38:09,960
and you what what do you see is an white

00:38:06,420 --> 00:38:15,120
screen of that so PHP 7 has an

00:38:09,960 --> 00:38:17,430
interesting tool which are called as

00:38:15,120 --> 00:38:22,500
engine exceptions so what they do is

00:38:17,430 --> 00:38:25,020
they throw your most common errors as an

00:38:22,500 --> 00:38:27,690
exception so you could handle them and

00:38:25,020 --> 00:38:32,340
end your script or end your program

00:38:27,690 --> 00:38:34,680
gracefully so and type exceptions are

00:38:32,340 --> 00:38:37,320
one of those exceptions to answer your

00:38:34,680 --> 00:38:41,310
question so yeah look at this piece of

00:38:37,320 --> 00:38:43,410
code I have one function which is

00:38:41,310 --> 00:38:47,430
expecting an integer returning an

00:38:43,410 --> 00:38:49,560
integer and I have passed it and string

00:38:47,430 --> 00:38:52,590
1 and this is the strict mode as you can

00:38:49,560 --> 00:38:55,110
see from the top so this will throw us

00:38:52,590 --> 00:38:59,190
and this will throw in type error so

00:38:55,110 --> 00:39:02,400
I've got the type error here and it will

00:38:59,190 --> 00:39:06,180
basically allow you to handle in

00:39:02,400 --> 00:39:07,980
whatever way you like to so this is our

00:39:06,180 --> 00:39:10,820
type errors are thrown in PHP if there

00:39:07,980 --> 00:39:10,820
are type violations

00:39:15,869 --> 00:39:18,869
sorry

00:39:27,610 --> 00:39:38,030
so some of you might think this is

00:39:33,350 --> 00:39:40,820
drupalcon right so what about drupal so

00:39:38,030 --> 00:39:45,890
we are talking about PHP till now so

00:39:40,820 --> 00:39:48,440
what about Drupal so I believe Drupal 8

00:39:45,890 --> 00:39:52,730
and PHP 7 is a great combination I've

00:39:48,440 --> 00:39:55,910
tried that personally and drupal 8 as an

00:39:52,730 --> 00:39:58,460
has a hundred percent pass on PHP 7 so

00:39:55,910 --> 00:40:01,490
all automated tests on Drupal off Drupal

00:39:58,460 --> 00:40:03,560
8 passed on PHP 7 so you could

00:40:01,490 --> 00:40:06,170
technically use page b7 in your Drupal 8

00:40:03,560 --> 00:40:08,180
development Drupal 7 I think there are

00:40:06,170 --> 00:40:10,490
still couple of issues to be solved so

00:40:08,180 --> 00:40:13,190
Drupal 7 is not one hundred percent

00:40:10,490 --> 00:40:21,770
compatible with PHP seven but Drupal 8

00:40:13,190 --> 00:40:24,080
is right so let's look at a typed date

00:40:21,770 --> 00:40:27,650
module and what I mean by type date

00:40:24,080 --> 00:40:30,500
modulus we are using PHP 7 to build a d8

00:40:27,650 --> 00:40:34,820
module with the typing features that we

00:40:30,500 --> 00:40:38,560
just saw so it's a very dumb module what

00:40:34,820 --> 00:40:43,300
it does is it takes and string it

00:40:38,560 --> 00:40:47,150
removes your spaces converts your

00:40:43,300 --> 00:40:49,160
characters into lower case and it will

00:40:47,150 --> 00:40:50,900
throw a string like this so basically to

00:40:49,160 --> 00:40:56,270
convert your string into a URL format

00:40:50,900 --> 00:40:59,080
maybe yeah the module so sorry so let me

00:40:56,270 --> 00:40:59,080
go back

00:41:07,220 --> 00:41:17,780
right so up this is the module a pretty

00:41:12,140 --> 00:41:25,640
basic module it's a form where I could

00:41:17,780 --> 00:41:28,040
just write my name or any string it will

00:41:25,640 --> 00:41:30,980
return the slug ified version of the

00:41:28,040 --> 00:41:40,400
string pretty simple right basic now

00:41:30,980 --> 00:41:42,530
let's look at the code right so up for

00:41:40,400 --> 00:41:45,250
those who know Drupal 8 module

00:41:42,530 --> 00:41:50,599
development we have a win for yml file

00:41:45,250 --> 00:41:56,810
we have a form okay so it's a very

00:41:50,599 --> 00:42:02,030
simple form it's a it's a it has a URL

00:41:56,810 --> 00:42:07,700
field and a submit button so what I've

00:42:02,030 --> 00:42:09,950
done here is Drupal 8 recommends you to

00:42:07,700 --> 00:42:12,320
follow a service based architecture so

00:42:09,950 --> 00:42:14,690
whatever you have to do create a service

00:42:12,320 --> 00:42:17,359
out of it and in then inject your

00:42:14,690 --> 00:42:22,609
service into the piece of code very

00:42:17,359 --> 00:42:26,690
wanted service so I am I have created a

00:42:22,609 --> 00:42:29,660
service called slugga fire service which

00:42:26,690 --> 00:42:34,550
is nothing but a class and a function

00:42:29,660 --> 00:42:36,290
inside it right so it actually performs

00:42:34,550 --> 00:42:38,240
the operation of converting a string

00:42:36,290 --> 00:42:41,619
into its lucky fight version it's a

00:42:38,240 --> 00:42:41,619
pretty simple basic code and

00:42:45,150 --> 00:42:52,529
yeah so if you could see I have created

00:42:50,520 --> 00:42:56,849
this service I have extended an

00:42:52,529 --> 00:42:59,279
interface from here so this interface

00:42:56,849 --> 00:43:03,210
has my function prototype slug if I

00:42:59,279 --> 00:43:09,839
function and as you can see i have given

00:43:03,210 --> 00:43:12,270
type hints for every parameter right so

00:43:09,839 --> 00:43:14,309
do you could not do this in PHP 5 so

00:43:12,270 --> 00:43:17,849
this is something you could do in PHP 7

00:43:14,309 --> 00:43:24,349
and if you try to run this a piece of

00:43:17,849 --> 00:43:26,670
code in PHP 5 it will throw an error so

00:43:24,349 --> 00:43:28,890
same thing I've implemented the same

00:43:26,670 --> 00:43:31,680
function in my class where I've

00:43:28,890 --> 00:43:35,099
implemented that interface same

00:43:31,680 --> 00:43:37,319
arguments return value and then I have

00:43:35,099 --> 00:43:44,609
used this function I have injected that

00:43:37,319 --> 00:43:48,630
function here in this form why a

00:43:44,609 --> 00:43:53,160
constructor and I have used this slug

00:43:48,630 --> 00:43:54,930
service like if I function so so this

00:43:53,160 --> 00:43:57,299
function I could be absolutely sure that

00:43:54,930 --> 00:44:01,010
this would return me a string and this

00:43:57,299 --> 00:44:03,539
would accept and string all the time so

00:44:01,010 --> 00:44:06,510
so the point is when writing our own

00:44:03,539 --> 00:44:09,349
services we could start using the typing

00:44:06,510 --> 00:44:15,510
features you could start creating

00:44:09,349 --> 00:44:17,910
function prototypes like this and this

00:44:15,510 --> 00:44:20,010
would be a great way to start using the

00:44:17,910 --> 00:44:25,369
typing features of PHP 7 in your Drupal

00:44:20,010 --> 00:44:25,369
8 code so yeah

00:44:29,400 --> 00:44:32,030
oops

00:44:37,349 --> 00:44:56,400
yeah so that was all from me any

00:44:41,430 --> 00:45:02,700
questions could you go to the night

00:44:56,400 --> 00:45:05,190
please I'm not everything so in the last

00:45:02,700 --> 00:45:09,410
example you gave here if you would

00:45:05,190 --> 00:45:14,039
implement an exception example how would

00:45:09,410 --> 00:45:16,559
how would you do that typically you want

00:45:14,039 --> 00:45:20,609
to know how to catch an exception no

00:45:16,559 --> 00:45:22,950
just if you would wrap an exception

00:45:20,609 --> 00:45:25,019
around this example the last example you

00:45:22,950 --> 00:45:27,210
gave you want to see how to catch an

00:45:25,019 --> 00:45:35,039
exception here yeah in this example yeah

00:45:27,210 --> 00:45:42,509
all right what I could do here is where

00:45:35,039 --> 00:45:47,180
I am basically using this form using

00:45:42,509 --> 00:45:47,180
this function try catch

00:46:19,360 --> 00:46:22,020
alright

00:46:27,940 --> 00:46:33,100
we could do that now I am just giving

00:46:30,790 --> 00:46:35,530
example out to catch an exception so

00:46:33,100 --> 00:46:38,320
this in this case specifically we should

00:46:35,530 --> 00:46:40,620
do a valid form technically when writing

00:46:38,320 --> 00:46:40,620
code

00:46:54,569 --> 00:47:00,789
all right let's try yeah you would say

00:46:58,059 --> 00:47:03,039
the for my role in this is a hmm

00:47:00,789 --> 00:47:05,619
you would you would sit in a form era in

00:47:03,039 --> 00:47:11,770
this example for Mira or you would do

00:47:05,619 --> 00:47:13,450
this in a valid 80 so okay so what i'm

00:47:11,770 --> 00:47:16,930
doing here is i'm just showing you how

00:47:13,450 --> 00:47:19,000
to catch an exception in case this lug

00:47:16,930 --> 00:47:21,039
if I function y accepts and string so

00:47:19,000 --> 00:47:23,470
I'm passing an integer so it should it's

00:47:21,039 --> 00:47:25,690
likely to throw an error so I'm just

00:47:23,470 --> 00:47:27,640
doing how to catch an error and

00:47:25,690 --> 00:47:29,020
basically handle it in your own way

00:47:27,640 --> 00:47:32,220
maybe showing my sister and maybe

00:47:29,020 --> 00:47:32,220
redirect the user somewhere

00:47:40,590 --> 00:47:46,440
yeah so you could basically write

00:47:44,070 --> 00:47:52,410
anything in your catch function and

00:47:46,440 --> 00:47:56,010
handle that error yeah a work with PHP

00:47:52,410 --> 00:47:58,650
by so this concept here with adding the

00:47:56,010 --> 00:48:02,460
type to the function that only worked if

00:47:58,650 --> 00:48:05,010
you're using like you can write user

00:48:02,460 --> 00:48:07,950
contributed modules and put them within

00:48:05,010 --> 00:48:10,380
these concepts because then you

00:48:07,950 --> 00:48:16,310
correctly won't work in you'd be correct

00:48:10,380 --> 00:48:19,050
that's a good point that's a good point

00:48:16,310 --> 00:48:23,250
because you cannot force anyone to use

00:48:19,050 --> 00:48:25,560
PHP 7 and your contributed module then

00:48:23,250 --> 00:48:28,950
if you write a contributed model using

00:48:25,560 --> 00:48:30,690
typing features so you are generally you

00:48:28,950 --> 00:48:33,330
are actually forcing the users to using

00:48:30,690 --> 00:48:37,140
PHP 7 but technically Drupal 8 could run

00:48:33,330 --> 00:48:42,180
in PHP 5.6 also so the best way to do it

00:48:37,140 --> 00:48:44,250
is write your own custom code in PHP 7

00:48:42,180 --> 00:48:46,890
so if you are contributing modules don't

00:48:44,250 --> 00:48:51,480
use typing but it's more likely that we

00:48:46,890 --> 00:48:55,610
will see typed code in future as people

00:48:51,480 --> 00:48:55,610
generally progress towards triple 7 yeah

00:49:08,500 --> 00:49:13,390
mmm

00:49:10,609 --> 00:49:13,390
ok

00:49:13,800 --> 00:49:16,800
mm-hmm

00:49:18,750 --> 00:49:25,810
okay okay okay so there's a lot of like

00:49:22,630 --> 00:49:29,110
endemic polymorphism in Drupal core

00:49:25,810 --> 00:49:31,330
right so you'll have these dock box that

00:49:29,110 --> 00:49:33,750
are like okay I'll take a string or an

00:49:31,330 --> 00:49:36,490
array or an integer and I'll process it

00:49:33,750 --> 00:49:38,230
according to the input right and then

00:49:36,490 --> 00:49:40,660
the same thing right like user load is

00:49:38,230 --> 00:49:45,400
you'll get a either read user object or

00:49:40,660 --> 00:49:47,170
false so is there some accommodation for

00:49:45,400 --> 00:49:49,180
that with typing or is this so new to

00:49:47,170 --> 00:49:50,500
PHP that kind of like the question

00:49:49,180 --> 00:49:54,130
earlier we can't say we're going to

00:49:50,500 --> 00:49:57,010
return a string or false right now how

00:49:54,130 --> 00:50:01,930
do you have a you suggest you handle

00:49:57,010 --> 00:50:05,410
that kind of polymorphism ah I think the

00:50:01,930 --> 00:50:07,240
best way to start is to when you are

00:50:05,410 --> 00:50:08,680
writing your own code when you are

00:50:07,240 --> 00:50:12,100
writing your own service that could be

00:50:08,680 --> 00:50:15,280
used in some other modules to make your

00:50:12,100 --> 00:50:18,040
own service as typed so basically your

00:50:15,280 --> 00:50:19,750
service would be typed but you are not

00:50:18,040 --> 00:50:22,330
forcing anyone else to do that same

00:50:19,750 --> 00:50:24,550
thing so you will have to as of now you

00:50:22,330 --> 00:50:27,430
would have to do the error handling that

00:50:24,550 --> 00:50:29,710
you we used to do but at least you could

00:50:27,430 --> 00:50:32,590
make your own module type that others

00:50:29,710 --> 00:50:34,990
won't have to handle that as of now so

00:50:32,590 --> 00:50:39,130
is there if I'm writing a so I have a

00:50:34,990 --> 00:50:40,740
pod service right and it's going to look

00:50:39,130 --> 00:50:43,860
something up and either

00:50:40,740 --> 00:50:46,740
me an object or go ahead false right you

00:50:43,860 --> 00:50:48,060
basically it PHP 7 still couldn't type

00:50:46,740 --> 00:50:55,820
the return value because you'd either

00:50:48,060 --> 00:50:55,820
return false over an object yes yes yep

00:51:05,500 --> 00:51:07,980
then

00:51:12,170 --> 00:51:20,480
okay yeah we'll type inning reduce the

00:51:16,400 --> 00:51:22,099
need for triple equals triple equals no

00:51:20,480 --> 00:51:27,369
I don't think so strong typing would not

00:51:22,099 --> 00:51:27,369
I mean sorry D strict mode would not

00:51:33,570 --> 00:51:48,300
right anyone else anything okay then

00:51:39,800 --> 00:51:51,270
thank you and you can have a look at

00:51:48,300 --> 00:51:54,720
that coat and the gate repository if you

00:51:51,270 --> 00:52:00,650
want to and please give the feedback for

00:51:54,720 --> 00:52:00,650
this session on this URL yeah thank you

00:52:05,790 --> 00:52:11,240

YouTube URL: https://www.youtube.com/watch?v=SkNBilOAzns


