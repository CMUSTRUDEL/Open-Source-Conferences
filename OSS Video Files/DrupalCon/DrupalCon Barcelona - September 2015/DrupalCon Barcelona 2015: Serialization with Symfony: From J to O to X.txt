Title: DrupalCon Barcelona 2015: Serialization with Symfony: From J to O to X
Publication date: 2015-09-22
Playlist: DrupalCon Barcelona - September 2015
Description: 
	One of the key challenges for CMS today is that they do not just need to serve HTML with some pictures. Instead in a multi channel, multi app world, it is often necessary to support other data formats as well. With Drupal 8 the native support for JSON based REST interface will therefore see a much needed step up. This talk will introduce the Symfony Serialization component that is used by Drupal 8. While the component initially just covered very simple use cases it has grown over the course of the last year quite siginificantly to become quite a power house. Understanding what it can do will help both leverage as well as customize the REST support in Drupal 8.
Captions: 
	00:00:00,000 --> 00:00:04,410
yes so welcome I see that very did a

00:00:02,879 --> 00:00:07,710
better job of filling this room than I

00:00:04,410 --> 00:00:11,070
am then again maybe people are still

00:00:07,710 --> 00:00:14,480
pouring in over lunch which is fine

00:00:11,070 --> 00:00:18,210
anyway so I'll get started so this is

00:00:14,480 --> 00:00:21,210
serialization with symphony and my name

00:00:18,210 --> 00:00:24,150
is Lucas Smith I'm developer at leap in

00:00:21,210 --> 00:00:27,630
Switzerland I did a few things in the

00:00:24,150 --> 00:00:29,880
PHP world one of the things was actually

00:00:27,630 --> 00:00:32,880
that i started the serializer component

00:00:29,880 --> 00:00:35,760
with jordy it's kinda actually kind of

00:00:32,880 --> 00:00:37,110
funny because when I you know started on

00:00:35,760 --> 00:00:38,910
this talk or proposing was taught I

00:00:37,110 --> 00:00:41,040
didn't quite remember if i actually did

00:00:38,910 --> 00:00:44,730
start it or not so i'd look at the

00:00:41,040 --> 00:00:46,170
commit history yeah i mean was it in the

00:00:44,730 --> 00:00:48,300
very early days of symphony that we

00:00:46,170 --> 00:00:50,100
started feeling that we needed something

00:00:48,300 --> 00:00:52,079
like a serializer and I think it started

00:00:50,100 --> 00:00:53,640
I think it started initially outside of

00:00:52,079 --> 00:00:56,430
symphony and then was brought into

00:00:53,640 --> 00:00:58,980
something a little bit later on yeah you

00:00:56,430 --> 00:01:01,949
can find me on Twitter on with my with L

00:00:58,980 --> 00:01:05,010
Smith now I have a slight confession to

00:01:01,949 --> 00:01:07,979
make so some of you might know this guy

00:01:05,010 --> 00:01:11,909
and maybe as a quick show of hands who

00:01:07,979 --> 00:01:14,970
here was it do boo con la okay one

00:01:11,909 --> 00:01:17,549
person to person okay I don't sure it

00:01:14,970 --> 00:01:20,610
did anybody attempt this talk by if so

00:01:17,549 --> 00:01:22,500
serializer talking in LA so no okay

00:01:20,610 --> 00:01:24,390
that's great because actually ended up

00:01:22,500 --> 00:01:28,140
stealing Hugo slides for the most part

00:01:24,390 --> 00:01:30,540
and just updating them mostly because I

00:01:28,140 --> 00:01:32,009
have a yeah two weeks ago I got married

00:01:30,540 --> 00:01:33,869
so I got i ended up being a little bit

00:01:32,009 --> 00:01:35,369
more busy than expected and also this

00:01:33,869 --> 00:01:38,820
day is kind of crazy for me because i'm

00:01:35,369 --> 00:01:40,140
actually doing three talks and then i

00:01:38,820 --> 00:01:41,579
decided actually in the end that in the

00:01:40,140 --> 00:01:43,350
open source spirit kind of makes more

00:01:41,579 --> 00:01:44,670
sense that i improve upon what is

00:01:43,350 --> 00:01:47,070
already being created rather than

00:01:44,670 --> 00:01:49,649
creating the same side again just with a

00:01:47,070 --> 00:01:51,390
different layout so these lights are

00:01:49,649 --> 00:01:52,530
updated from the version from LA there

00:01:51,390 --> 00:01:54,750
are two things that have happened in

00:01:52,530 --> 00:01:57,270
this year as a component since then a

00:01:54,750 --> 00:01:59,700
few typos said I fixed and obviously I'm

00:01:57,270 --> 00:02:03,840
going to put a slightly different slant

00:01:59,700 --> 00:02:07,860
on few of these slides over C so yeah so

00:02:03,840 --> 00:02:09,720
without further ado let's get going yeah

00:02:07,860 --> 00:02:10,990
so the today's topic is this year liser

00:02:09,720 --> 00:02:12,010
component and maybe

00:02:10,990 --> 00:02:14,140
first we need to figure out what

00:02:12,010 --> 00:02:17,590
serialization is and essentially it's

00:02:14,140 --> 00:02:20,290
taking you know a data structure usually

00:02:17,590 --> 00:02:22,870
in memory and then you know some object

00:02:20,290 --> 00:02:24,880
state or whatever and then you know

00:02:22,870 --> 00:02:27,790
bringing it to a different format that

00:02:24,880 --> 00:02:31,420
allows you to store and reconstruct this

00:02:27,790 --> 00:02:34,270
data usually in a you know string format

00:02:31,420 --> 00:02:35,830
and the different ways of you know or

00:02:34,270 --> 00:02:38,440
different formats that you can you know

00:02:35,830 --> 00:02:40,600
convert into or out of so for example

00:02:38,440 --> 00:02:42,700
HTT messages these are in the end just

00:02:40,600 --> 00:02:45,430
plain text messages so you can you know

00:02:42,700 --> 00:02:47,550
in 15 theory also just take you know an

00:02:45,430 --> 00:02:51,010
object and then see realize that to

00:02:47,550 --> 00:02:53,650
deviant message and back in a way

00:02:51,010 --> 00:02:55,300
Symphony kind of does that you know we

00:02:53,650 --> 00:02:57,250
have a request and we have a response

00:02:55,300 --> 00:02:59,350
objects and they got kind of transferred

00:02:57,250 --> 00:03:02,440
to string representations they don't use

00:02:59,350 --> 00:03:04,450
the serializer component though more

00:03:02,440 --> 00:03:07,090
classical ways of viewing serialization

00:03:04,450 --> 00:03:12,490
would be going to XML or back soap

00:03:07,090 --> 00:03:15,520
messages JSON llamo CSV and so on so

00:03:12,490 --> 00:03:16,690
forth I think in theory I don't adopt it

00:03:15,520 --> 00:03:17,770
anybody has done it but I guess you

00:03:16,690 --> 00:03:20,430
could also use this year lies a

00:03:17,770 --> 00:03:24,520
component to generate pdfs and images

00:03:20,430 --> 00:03:26,260
but that would sort of be kind of hard

00:03:24,520 --> 00:03:28,360
to deserialize again but you could even

00:03:26,260 --> 00:03:31,930
do like text recognition then I don't

00:03:28,360 --> 00:03:34,090
know anyway so the most common use cases

00:03:31,930 --> 00:03:36,520
of using serialization is you know you

00:03:34,090 --> 00:03:40,960
want to store some object state into a

00:03:36,520 --> 00:03:43,060
file or a database rest api is probably

00:03:40,960 --> 00:03:46,210
even more the prime use case and this is

00:03:43,060 --> 00:03:48,700
how Drupal 8 uses the syrah dizer

00:03:46,210 --> 00:03:50,920
component mostly you know generating

00:03:48,700 --> 00:03:53,050
soap in fear you could also use this to

00:03:50,920 --> 00:03:55,930
sort of distributed object instances the

00:03:53,050 --> 00:03:58,120
java does that where you know you can

00:03:55,930 --> 00:03:59,920
serialize an object to a string and then

00:03:58,120 --> 00:04:04,530
instantiate it back in a different

00:03:59,920 --> 00:04:07,110
server and continue processing there so

00:04:04,530 --> 00:04:09,010
before we dive into the symphony

00:04:07,110 --> 00:04:10,180
serializing component let's look at some

00:04:09,010 --> 00:04:12,370
of the ways how we can actually do

00:04:10,180 --> 00:04:18,130
serialization just with out-of-the-box

00:04:12,370 --> 00:04:20,840
features from HP so there's you know the

00:04:18,130 --> 00:04:23,750
obvious choice is this utilized method

00:04:20,840 --> 00:04:25,880
so you basically throw in almost

00:04:23,750 --> 00:04:28,940
everything into the serialized method

00:04:25,880 --> 00:04:31,040
and you will then get back some string

00:04:28,940 --> 00:04:34,370
representation like this it's a little

00:04:31,040 --> 00:04:36,889
bit cryptic but somewhat RIA ball and

00:04:34,370 --> 00:04:40,100
then you can of course uncie realize

00:04:36,889 --> 00:04:42,110
that data and get back you know from

00:04:40,100 --> 00:04:45,229
that screen representation to an actual

00:04:42,110 --> 00:04:47,419
variable with the different types and so

00:04:45,229 --> 00:04:49,729
on so as you can see here you can have

00:04:47,419 --> 00:04:54,650
like nose and boolean value streams

00:04:49,729 --> 00:04:57,080
arrays and even objects as well now

00:04:54,650 --> 00:05:00,560
there is something that is a little bit

00:04:57,080 --> 00:05:02,600
tricky with serialization is actually

00:05:00,560 --> 00:05:06,530
let me go back here so as you can see

00:05:02,600 --> 00:05:08,150
here I don't have anything or example of

00:05:06,530 --> 00:05:10,389
serializing a resource and that's

00:05:08,150 --> 00:05:12,320
because it's not possible with the PHP

00:05:10,389 --> 00:05:14,630
serialize methods so basically if you

00:05:12,320 --> 00:05:16,490
try to use serialize something that

00:05:14,630 --> 00:05:18,169
contains the resource being a you know

00:05:16,490 --> 00:05:20,240
the reefs or did sell for an array with

00:05:18,169 --> 00:05:24,169
resources or an object with resources

00:05:20,240 --> 00:05:26,180
you will get an error and with objects

00:05:24,169 --> 00:05:29,539
however you can work around this problem

00:05:26,180 --> 00:05:31,600
and there are these two magic methods

00:05:29,539 --> 00:05:37,039
that you can implement in your class

00:05:31,600 --> 00:05:39,530
underscore sleep and wake up and with

00:05:37,039 --> 00:05:42,800
these methods you can solve the problem

00:05:39,530 --> 00:05:44,479
of you know dealing with resources so

00:05:42,800 --> 00:05:46,970
let me give you a quick example here so

00:05:44,479 --> 00:05:49,669
this would be some database connection

00:05:46,970 --> 00:05:52,580
class you want to you know a capsule 8p

00:05:49,669 --> 00:05:53,810
do for example for some reason and you

00:05:52,580 --> 00:05:57,229
know in the constructor you might pass

00:05:53,810 --> 00:05:59,870
and a DSN username and a password and

00:05:57,229 --> 00:06:01,580
then you have this connect method that

00:05:59,870 --> 00:06:03,800
you call at some point which actually

00:06:01,580 --> 00:06:06,110
creates an PDO instance and assigns it

00:06:03,800 --> 00:06:09,650
to a property and actually underneath

00:06:06,110 --> 00:06:11,990
PBO there is a resource and it will run

00:06:09,650 --> 00:06:14,389
into problems if you just see realize

00:06:11,990 --> 00:06:17,750
that it's not going to come out properly

00:06:14,389 --> 00:06:20,389
connected to your database so the way to

00:06:17,750 --> 00:06:22,520
solve that is to implement these sleep

00:06:20,389 --> 00:06:24,169
and wake up methods so in the sleep

00:06:22,520 --> 00:06:27,050
method you basically specify which

00:06:24,169 --> 00:06:29,780
properties you want to include in the

00:06:27,050 --> 00:06:32,480
serializer it's your alized format so in

00:06:29,780 --> 00:06:34,820
this case we're specifying the DSN user

00:06:32,480 --> 00:06:37,040
and password properties and if you're

00:06:34,820 --> 00:06:39,650
not familiar with this curly bracket

00:06:37,040 --> 00:06:42,500
syntax this is a short or array syntax

00:06:39,650 --> 00:06:44,720
that was introduced in PHP 54 so this is

00:06:42,500 --> 00:06:46,190
essentially like when the return the

00:06:44,720 --> 00:06:48,830
u.s. end user password district is the

00:06:46,190 --> 00:06:52,070
same as saying return array parentheses

00:06:48,830 --> 00:06:54,110
and then these strings so that takes

00:06:52,070 --> 00:06:56,720
care about the case when we called

00:06:54,110 --> 00:06:57,800
serialize and then with wake up this

00:06:56,720 --> 00:07:01,040
method is called when you call

00:06:57,800 --> 00:07:04,340
uncivilized on a string containing a

00:07:01,040 --> 00:07:05,600
reference to this class connection so

00:07:04,340 --> 00:07:07,190
what we do on the wake up we just

00:07:05,600 --> 00:07:09,110
basically call this connect method again

00:07:07,190 --> 00:07:11,720
that we saw in the previous slide so

00:07:09,110 --> 00:07:13,880
it'll you know take those the you know

00:07:11,720 --> 00:07:15,350
the values from the properties that I've

00:07:13,880 --> 00:07:17,270
already been set then from the

00:07:15,350 --> 00:07:20,390
unrealized method and then create the

00:07:17,270 --> 00:07:22,520
PDO instance again so we can thanks to

00:07:20,390 --> 00:07:24,560
these two methods here we can safely

00:07:22,520 --> 00:07:28,010
serialize the connection class and

00:07:24,560 --> 00:07:32,660
unsere lies it again and immediately

00:07:28,010 --> 00:07:34,040
have it connected so essentially you

00:07:32,660 --> 00:07:35,510
could do something like this you know

00:07:34,040 --> 00:07:39,170
make an instance of that connection

00:07:35,510 --> 00:07:41,630
class run a query serialize the instance

00:07:39,170 --> 00:07:47,000
unser utilize it again and then run

00:07:41,630 --> 00:07:49,340
another query now there's also a new

00:07:47,000 --> 00:07:52,700
interface that was added or trying to

00:07:49,340 --> 00:07:55,280
remember a thing goes p 354 serializable

00:07:52,700 --> 00:07:56,810
interface so this gives you another

00:07:55,280 --> 00:07:59,060
option so instead of using these

00:07:56,810 --> 00:08:01,250
underscore underscore methods you can

00:07:59,060 --> 00:08:04,070
also implement the serializable

00:08:01,250 --> 00:08:05,660
interface and then you have this methods

00:08:04,070 --> 00:08:08,540
you realize that you can override and

00:08:05,660 --> 00:08:10,700
here you basically return an array which

00:08:08,540 --> 00:08:13,190
can be you know a quite liberal data

00:08:10,700 --> 00:08:15,770
structure of things that you want to

00:08:13,190 --> 00:08:18,190
serialize so you get more control in

00:08:15,770 --> 00:08:22,220
many ways so you even do some data

00:08:18,190 --> 00:08:24,020
massaging like you know removing some

00:08:22,220 --> 00:08:26,450
additional data that you don't think

00:08:24,020 --> 00:08:29,210
belongs in to this serialize it's

00:08:26,450 --> 00:08:31,430
utilized format and then in the unto

00:08:29,210 --> 00:08:33,770
your lives method you basically get that

00:08:31,430 --> 00:08:36,020
data back serialized you can unsere lies

00:08:33,770 --> 00:08:38,330
it again and then do additional things

00:08:36,020 --> 00:08:41,510
that you feel are important to do during

00:08:38,330 --> 00:08:42,860
the an serialization process you know

00:08:41,510 --> 00:08:45,710
these magic underscore underscore

00:08:42,860 --> 00:08:49,220
methods are sort of like an old style I

00:08:45,710 --> 00:08:52,310
would say so this approach to me is

00:08:49,220 --> 00:08:54,950
definitely more object-oriented and so

00:08:52,310 --> 00:08:58,010
therefore i would recommend it if you

00:08:54,950 --> 00:09:00,650
have a reason enough PHP version now

00:08:58,010 --> 00:09:03,320
this format of course this is a PHP

00:09:00,650 --> 00:09:08,630
custom format it has been you know

00:09:03,320 --> 00:09:10,730
fairly stable over many years but you

00:09:08,630 --> 00:09:12,440
know it's a PHP specific format and

00:09:10,730 --> 00:09:14,000
often times you might want to exchange

00:09:12,440 --> 00:09:17,870
data with other systems when you do

00:09:14,000 --> 00:09:19,790
serialization so for that PHP also

00:09:17,870 --> 00:09:21,350
provides some ways to dealing with JSON

00:09:19,790 --> 00:09:23,240
for example which is becoming more and

00:09:21,350 --> 00:09:25,130
more of a popular way to deal with

00:09:23,240 --> 00:09:29,270
civilization and data exchange between

00:09:25,130 --> 00:09:31,670
different systems now there's two method

00:09:29,270 --> 00:09:33,970
to function story json encode and decode

00:09:31,670 --> 00:09:36,560
they're basically the equivalent of

00:09:33,970 --> 00:09:39,920
serialized and unser your lies and then

00:09:36,560 --> 00:09:44,630
there's also a fairly new edition also

00:09:39,920 --> 00:09:46,700
the Jason serializable interface so the

00:09:44,630 --> 00:09:48,230
Jason serializable interface it kind of

00:09:46,700 --> 00:09:50,270
boils down to something very similar to

00:09:48,230 --> 00:09:54,770
what we saw with the serializable

00:09:50,270 --> 00:09:57,350
interface and you know you just get this

00:09:54,770 --> 00:09:59,030
Jason serialize method that you need to

00:09:57,350 --> 00:10:04,670
implement and then this will be used

00:09:59,030 --> 00:10:07,460
during encoding ok so that was very fast

00:10:04,670 --> 00:10:09,890
just going through the basics of how you

00:10:07,460 --> 00:10:11,510
can do serialization with PHP out of the

00:10:09,890 --> 00:10:15,550
box without installing any additional

00:10:11,510 --> 00:10:17,480
components and so on so forth however

00:10:15,550 --> 00:10:19,100
often times when you deal with

00:10:17,480 --> 00:10:20,960
serialization you will end up in

00:10:19,100 --> 00:10:22,550
situations that are much more complex to

00:10:20,960 --> 00:10:26,240
deal with than what is possible out of

00:10:22,550 --> 00:10:28,870
the box and this is where the simply

00:10:26,240 --> 00:10:32,240
serializer can help quite a bit actually

00:10:28,870 --> 00:10:34,640
and i said that i started the serializer

00:10:32,240 --> 00:10:37,790
but when i originally started it was

00:10:34,640 --> 00:10:40,370
much more simple and it has grown quite

00:10:37,790 --> 00:10:42,620
a bit thanks to several other developers

00:10:40,370 --> 00:10:44,300
that have contributed to the component

00:10:42,620 --> 00:10:46,460
and i actually haven't done anything to

00:10:44,300 --> 00:10:48,740
the component except for one

00:10:46,460 --> 00:10:52,010
think little thing for the composer JSON

00:10:48,740 --> 00:10:53,030
file a few days ago so many of the

00:10:52,010 --> 00:10:55,040
things that you're going to see here are

00:10:53,030 --> 00:10:57,790
not to my credit or Jordi's but actually

00:10:55,040 --> 00:11:01,580
other people in the symphony community

00:10:57,790 --> 00:11:03,590
so one of the things that we wanted to

00:11:01,580 --> 00:11:05,600
do with this utilized component was to

00:11:03,590 --> 00:11:08,960
really enable people to deal with all

00:11:05,600 --> 00:11:10,700
sorts of formats so XML and Jason were

00:11:08,960 --> 00:11:12,470
the two that we focus in the beginning

00:11:10,700 --> 00:11:14,090
but from the very architect from the

00:11:12,470 --> 00:11:16,490
very beginning we architected things to

00:11:14,090 --> 00:11:18,980
enable people to be able to support

00:11:16,490 --> 00:11:20,780
other formats if they wish even very

00:11:18,980 --> 00:11:23,030
custom formats or high level formats

00:11:20,780 --> 00:11:26,000
like you could have serialize to your

00:11:23,030 --> 00:11:27,800
personal style of JSON where you have a

00:11:26,000 --> 00:11:29,930
specific structure and Jason that you

00:11:27,800 --> 00:11:33,920
want and that would be very easy to

00:11:29,930 --> 00:11:35,630
achieve that and essentially the the

00:11:33,920 --> 00:11:39,170
architecture that we came up with what

00:11:35,630 --> 00:11:41,620
it was this so if you start up from from

00:11:39,170 --> 00:11:44,420
the object at the top and you want to

00:11:41,620 --> 00:11:45,890
serialize that what we have is the

00:11:44,420 --> 00:11:48,050
process called normalization which

00:11:45,890 --> 00:11:50,120
basically brings you to sort of an array

00:11:48,050 --> 00:11:51,920
representation and then the area

00:11:50,120 --> 00:11:54,020
representation is passed on to what we

00:11:51,920 --> 00:11:56,870
call it encoder which then actually does

00:11:54,020 --> 00:11:58,400
the actual serialization and then the

00:11:56,870 --> 00:11:59,780
you know going back it's the same

00:11:58,400 --> 00:12:03,020
essentially the same process in Reverse

00:11:59,780 --> 00:12:05,450
you first decode into an array and then

00:12:03,020 --> 00:12:08,690
you d normalize that into an object

00:12:05,450 --> 00:12:10,640
instance there are methods that actually

00:12:08,690 --> 00:12:13,000
allow you to sort of start in the middle

00:12:10,640 --> 00:12:15,860
and then directly jump to an object or

00:12:13,000 --> 00:12:18,290
directly go to a format but the normal

00:12:15,860 --> 00:12:20,300
process is that you actually call these

00:12:18,290 --> 00:12:22,640
serialize and deserialized methods which

00:12:20,300 --> 00:12:25,220
basically do all of you these two steps

00:12:22,640 --> 00:12:29,930
for you in one go so you don't have to

00:12:25,220 --> 00:12:31,370
call these separate methods so basically

00:12:29,930 --> 00:12:33,740
what you will be working with is an

00:12:31,370 --> 00:12:35,810
instance of the serializer and as I

00:12:33,740 --> 00:12:37,250
mentioned most of the time you'll just

00:12:35,810 --> 00:12:39,710
use this here lies in deserialized

00:12:37,250 --> 00:12:42,770
methods the serialize method basically

00:12:39,710 --> 00:12:44,350
gets some data can be whatever the

00:12:42,770 --> 00:12:47,060
format that you want to serialize into

00:12:44,350 --> 00:12:49,070
and then a context and we'll see you

00:12:47,060 --> 00:12:51,580
later how that context can be very

00:12:49,070 --> 00:12:53,770
useful to sort of customized

00:12:51,580 --> 00:12:56,710
should happen when the code happens and

00:12:53,770 --> 00:13:00,100
then this year lies is very similar you

00:12:56,710 --> 00:13:02,260
have a data type this is useful if you

00:13:00,100 --> 00:13:06,550
you know to specify sort of what object

00:13:02,260 --> 00:13:08,970
you want to DC lies into because you

00:13:06,550 --> 00:13:12,760
don't necessarily embed that into your

00:13:08,970 --> 00:13:15,880
serialized result the format again and

00:13:12,760 --> 00:13:17,980
then another the context again but if

00:13:15,880 --> 00:13:20,410
you wish to you can of course sort of

00:13:17,980 --> 00:13:22,990
skip some of the steps directly just do

00:13:20,410 --> 00:13:24,820
a normal eyes or denormalize encode and

00:13:22,990 --> 00:13:26,380
decode and then with supports

00:13:24,820 --> 00:13:28,840
normalization and denormalization you

00:13:26,380 --> 00:13:31,510
can sort of validate ahead of time if

00:13:28,840 --> 00:13:33,730
this will actually work or not and the

00:13:31,510 --> 00:13:36,240
same same thing for encoding there's the

00:13:33,730 --> 00:13:39,570
supports encoding and decoding methods

00:13:36,240 --> 00:13:41,530
so let's briefly see how that works I

00:13:39,570 --> 00:13:45,760
assume that everybody is sort of

00:13:41,530 --> 00:13:48,160
familiar with namespace syntax teach p53

00:13:45,760 --> 00:13:50,650
so you start off you know with a few use

00:13:48,160 --> 00:13:53,100
statements just to be able to use

00:13:50,650 --> 00:13:56,140
shorter class names in your coat then

00:13:53,100 --> 00:13:58,360
you instantiate an array of so-called

00:13:56,140 --> 00:14:00,340
normalize errs then an area of soda

00:13:58,360 --> 00:14:01,750
porter encoders and you pass those in as

00:14:00,340 --> 00:14:05,380
the first and second parameter to

00:14:01,750 --> 00:14:07,930
serialize ER and then and that's that's

00:14:05,380 --> 00:14:10,390
really key that basically depending on

00:14:07,930 --> 00:14:11,800
what sort of you pass in there depends

00:14:10,390 --> 00:14:14,380
on how the serializer is going to work

00:14:11,800 --> 00:14:17,160
so if you for example skip adding that

00:14:14,380 --> 00:14:21,250
XML encoder then you will not be able to

00:14:17,160 --> 00:14:23,020
serialize them to xml and if you add

00:14:21,250 --> 00:14:24,580
additional normalizes then they can have

00:14:23,020 --> 00:14:26,530
different priority of different

00:14:24,580 --> 00:14:30,010
behaviors and to produce different

00:14:26,530 --> 00:14:32,200
results for you but essentially it's

00:14:30,010 --> 00:14:35,620
fairly easy to use them so once that

00:14:32,200 --> 00:14:37,690
serializer instance has been set up then

00:14:35,620 --> 00:14:39,610
you can just call serialize pass in your

00:14:37,690 --> 00:14:41,320
data the format that you want and you

00:14:39,610 --> 00:14:43,120
just you know get your sea lies format

00:14:41,320 --> 00:14:45,670
back and then you can deserialize this

00:14:43,120 --> 00:14:47,470
quite easily here we can see in this

00:14:45,670 --> 00:14:49,930
case when we call deserialize we saying

00:14:47,470 --> 00:14:53,560
okay that data there is actually an

00:14:49,930 --> 00:14:56,140
instance of an eight me user object so

00:14:53,560 --> 00:14:58,720
please use that class when you you know

00:14:56,140 --> 00:15:01,540
denormalize that data and then in this

00:14:58,720 --> 00:15:02,770
case we're saying this is actually you

00:15:01,540 --> 00:15:03,250
know what's your life situation so

00:15:02,770 --> 00:15:07,360
unsere

00:15:03,250 --> 00:15:09,960
is that right so here's a quick overview

00:15:07,360 --> 00:15:12,790
of the normalizer sandy normalizes

00:15:09,960 --> 00:15:15,370
there's a small addition that happened

00:15:12,790 --> 00:15:17,770
since that talk in la the era d

00:15:15,370 --> 00:15:19,330
normalizer was added I think it's in 2.8

00:15:17,770 --> 00:15:23,320
so I think it's not yet in stable

00:15:19,330 --> 00:15:25,300
release most many cases you get away

00:15:23,320 --> 00:15:27,580
with just using that simple property

00:15:25,300 --> 00:15:29,440
normalize errs the the get set method

00:15:27,580 --> 00:15:31,600
normalize errs and the object normalizes

00:15:29,440 --> 00:15:33,930
are actually quite similar the object

00:15:31,600 --> 00:15:38,680
normalizer is a little bit more fancy

00:15:33,930 --> 00:15:40,990
can deal with yeah it uses the property

00:15:38,680 --> 00:15:46,060
excess component from Symphony to figure

00:15:40,990 --> 00:15:49,180
out if there is a method defined to to

00:15:46,060 --> 00:15:51,790
get the data from the object or if it

00:15:49,180 --> 00:15:53,650
should use a property and the get set

00:15:51,790 --> 00:15:55,360
method normalizer just has a little bit

00:15:53,650 --> 00:15:56,950
simpler logic and trying to figure out

00:15:55,360 --> 00:16:00,090
if there are methods to call rather than

00:15:56,950 --> 00:16:02,650
just directly taking the property values

00:16:00,090 --> 00:16:05,520
the area d normalizer is just a very

00:16:02,650 --> 00:16:10,270
handy thing if you have an array of

00:16:05,520 --> 00:16:12,490
objects normalized and will later see

00:16:10,270 --> 00:16:14,589
actually the full employment or most of

00:16:12,490 --> 00:16:17,470
the implementation of it so you can dive

00:16:14,589 --> 00:16:18,910
into detail how it works then encoders

00:16:17,470 --> 00:16:21,580
that are available out of the box is the

00:16:18,910 --> 00:16:23,339
Jason encoder and XML encoder so that's

00:16:21,580 --> 00:16:25,540
this is it what you have out of the box

00:16:23,339 --> 00:16:27,310
then there's also the chain encoder and

00:16:25,540 --> 00:16:29,680
chain decoder because you might want to

00:16:27,310 --> 00:16:31,780
chain these so for example as I

00:16:29,680 --> 00:16:35,290
mentioned earlier you know you might

00:16:31,780 --> 00:16:38,980
have some high-level syntax based on

00:16:35,290 --> 00:16:41,470
JSON that you want to these work into

00:16:38,980 --> 00:16:45,040
then you can have I don't know your your

00:16:41,470 --> 00:16:47,770
hell encoder which extends the JSON

00:16:45,040 --> 00:16:50,800
encode or something like that could be

00:16:47,770 --> 00:16:53,050
possible but inheritance is always kind

00:16:50,800 --> 00:16:54,550
of a tricky thing so with the chain

00:16:53,050 --> 00:16:57,220
encoder you basically don't need to

00:16:54,550 --> 00:16:58,960
inherit you can basically just say ok

00:16:57,220 --> 00:17:00,670
here's the first encoder then the second

00:16:58,960 --> 00:17:06,069
encoder that you should use in these in

00:17:00,670 --> 00:17:08,050
these cases so a basic usage let's look

00:17:06,069 --> 00:17:10,150
at you know a very simple example we

00:17:08,050 --> 00:17:12,760
have a movie class a bunch of private

00:17:10,150 --> 00:17:14,300
properties they can of course also be

00:17:12,760 --> 00:17:17,120
protected

00:17:14,300 --> 00:17:20,660
and you know you make an instance of

00:17:17,120 --> 00:17:22,280
that object you know assigning different

00:17:20,660 --> 00:17:24,170
values to these properties through

00:17:22,280 --> 00:17:27,830
setters of course doesn't need to be

00:17:24,170 --> 00:17:30,200
setters but and then you can serialize

00:17:27,830 --> 00:17:32,750
and uncivilized that so that's pretty

00:17:30,200 --> 00:17:35,450
straightforward we really haven't done

00:17:32,750 --> 00:17:39,530
much more really that what we would get

00:17:35,450 --> 00:17:42,110
with the core features here a little

00:17:39,530 --> 00:17:44,690
word on the property serialization so

00:17:42,110 --> 00:17:46,010
basically in this case we're we're just

00:17:44,690 --> 00:17:50,030
using that very simple property

00:17:46,010 --> 00:17:52,850
normalizer and so what we end up with is

00:17:50,030 --> 00:17:55,070
adjacent representation that really maps

00:17:52,850 --> 00:17:58,610
1212 the property names we had in our

00:17:55,070 --> 00:18:00,910
class and same case for the xml

00:17:58,610 --> 00:18:03,560
serialization so that's basically

00:18:00,910 --> 00:18:05,390
depending on if you encode it to JSON or

00:18:03,560 --> 00:18:08,690
XML these were the two representations

00:18:05,390 --> 00:18:11,450
that you would get d serialization is

00:18:08,690 --> 00:18:13,340
then also fairly easy again that's

00:18:11,450 --> 00:18:16,730
pretty much straightforward what you

00:18:13,340 --> 00:18:19,490
essentially get with the core JSON

00:18:16,730 --> 00:18:22,220
encode and decode in this case then here

00:18:19,490 --> 00:18:23,660
the XML example you know we just get our

00:18:22,220 --> 00:18:25,640
representation back and this is

00:18:23,660 --> 00:18:26,840
essentially that print our statement on

00:18:25,640 --> 00:18:31,400
the previous slide this is what it would

00:18:26,840 --> 00:18:33,710
basically provide us with so exactly

00:18:31,400 --> 00:18:36,980
what we would want there's already one

00:18:33,710 --> 00:18:39,860
really cool feature in there is that for

00:18:36,980 --> 00:18:41,900
the D D normalization or D serialization

00:18:39,860 --> 00:18:44,150
sorry one thing that it does it actually

00:18:41,900 --> 00:18:46,610
int respects the constructor and if it

00:18:44,150 --> 00:18:50,210
finds that the property names on your

00:18:46,610 --> 00:18:53,690
class match at least some of the or all

00:18:50,210 --> 00:18:54,650
of the constructor parameters then it

00:18:53,690 --> 00:18:56,750
will actually call the constructor

00:18:54,650 --> 00:19:00,530
rather than directly setting the old

00:18:56,750 --> 00:19:02,870
properties so if you follow that rule of

00:19:00,530 --> 00:19:06,020
naming your constructor parameters the

00:19:02,870 --> 00:19:09,320
same way as you name your properties on

00:19:06,020 --> 00:19:10,970
your on your class you basically get an

00:19:09,320 --> 00:19:13,010
automatic call to constructor which

00:19:10,970 --> 00:19:15,590
could be useful to do certain things

00:19:13,010 --> 00:19:17,570
doing set up like setting up some

00:19:15,590 --> 00:19:23,030
resource of things like that so that's

00:19:17,570 --> 00:19:25,490
just very handy all right so really this

00:19:23,030 --> 00:19:27,290
is this is more basics again we haven't

00:19:25,490 --> 00:19:28,550
really gained much compared to the core

00:19:27,290 --> 00:19:31,310
features so now

00:19:28,550 --> 00:19:40,490
next thing is actually seeing what more

00:19:31,310 --> 00:19:42,590
we can do all right so gather hazard

00:19:40,490 --> 00:19:44,420
easier method normalizer so this

00:19:42,590 --> 00:19:45,860
basically I'm not sure if you're all

00:19:44,420 --> 00:19:49,430
familiar with this term so if you have

00:19:45,860 --> 00:19:52,310
like I get something said something has

00:19:49,430 --> 00:19:53,990
something or is something method these

00:19:52,310 --> 00:19:56,840
are called like getter hazard is or and

00:19:53,990 --> 00:19:58,550
so and so forth so basically you can

00:19:56,840 --> 00:20:01,340
leverage these if you use either the

00:19:58,550 --> 00:20:05,450
object normalizer or the get set method

00:20:01,340 --> 00:20:07,940
mobilizers and so in this code example

00:20:05,450 --> 00:20:09,770
here we basically added those two first

00:20:07,940 --> 00:20:12,350
lines up there basically adding those

00:20:09,770 --> 00:20:13,850
additional normalizes and what's

00:20:12,350 --> 00:20:16,520
important here to take away is that the

00:20:13,850 --> 00:20:18,950
order matters so the normalizes are

00:20:16,520 --> 00:20:21,560
called in the order that they're put

00:20:18,950 --> 00:20:23,960
into this array and remember there was

00:20:21,560 --> 00:20:26,030
this supports normalization method on

00:20:23,960 --> 00:20:28,460
the serializer actually the normalizes

00:20:26,030 --> 00:20:30,470
have this method as well and so when the

00:20:28,460 --> 00:20:33,530
serializer goes through to determine if

00:20:30,470 --> 00:20:35,480
it which normalized you take it looks at

00:20:33,530 --> 00:20:37,880
the first one in the area sees if that

00:20:35,480 --> 00:20:39,980
one if the supports normalization method

00:20:37,880 --> 00:20:42,530
that's true then it will actually call

00:20:39,980 --> 00:20:45,980
that normalizer so the order is very

00:20:42,530 --> 00:20:47,540
important to consider so in this case we

00:20:45,980 --> 00:20:49,100
have the object normalizer first and

00:20:47,540 --> 00:20:51,020
then the get set method normalized or

00:20:49,100 --> 00:20:53,960
second and then the property normalized

00:20:51,020 --> 00:20:55,850
or third which i think will probably

00:20:53,960 --> 00:20:59,210
boil down to it will probably most

00:20:55,850 --> 00:21:00,650
always use the object normalizer but i'm

00:20:59,210 --> 00:21:01,850
not entirely sure because the object

00:21:00,650 --> 00:21:03,620
normalized will probably call up

00:21:01,850 --> 00:21:07,550
everything with this supports call

00:21:03,620 --> 00:21:10,700
anyway what is nice about this is that

00:21:07,550 --> 00:21:12,590
if let's say we have extended our movie

00:21:10,700 --> 00:21:14,900
class to add some more methods like we

00:21:12,590 --> 00:21:17,920
have this get ID get title and then it

00:21:14,900 --> 00:21:20,420
has John Ryan is released method that

00:21:17,920 --> 00:21:22,730
the object normalized will actually pick

00:21:20,420 --> 00:21:24,800
up these has John Rue and is released

00:21:22,730 --> 00:21:27,710
methods and actually add that to the

00:21:24,800 --> 00:21:29,750
serialized data it will also go through

00:21:27,710 --> 00:21:32,060
the gate ID and the get title methods

00:21:29,750 --> 00:21:36,410
rather than directly accessing accessing

00:21:32,060 --> 00:21:38,510
the properties so in this case once you

00:21:36,410 --> 00:21:41,059
know we've added this basically we would

00:21:38,510 --> 00:21:45,139
get a serialization result where we

00:21:41,059 --> 00:21:47,299
have these added peels here like John

00:21:45,139 --> 00:21:52,159
released and as you might know this year

00:21:47,299 --> 00:21:54,110
it's not has donor or is released so

00:21:52,159 --> 00:21:58,149
this is sort of some special feature

00:21:54,110 --> 00:22:01,070
there in the object normalizer and then

00:21:58,149 --> 00:22:05,419
this xml serialization representation

00:22:01,070 --> 00:22:07,730
would look similar to that now next is

00:22:05,419 --> 00:22:09,620
sometimes you don't want to serialize

00:22:07,730 --> 00:22:11,389
everything that you have in your object

00:22:09,620 --> 00:22:13,190
like to example you might have user

00:22:11,389 --> 00:22:16,850
object you might not want to serialize

00:22:13,190 --> 00:22:19,759
the password hash or whatever so you can

00:22:16,850 --> 00:22:23,179
do that by calling the set ignored

00:22:19,759 --> 00:22:25,490
attributes method on the normalizer so

00:22:23,179 --> 00:22:28,190
basically if we say setting or

00:22:25,490 --> 00:22:31,070
attributes and we say ignore stored key

00:22:28,190 --> 00:22:35,299
then basic means that that normalizer

00:22:31,070 --> 00:22:39,049
will ignore any property or you know get

00:22:35,299 --> 00:22:41,389
storage key or whatever method when it

00:22:39,049 --> 00:22:43,249
does the serialization so here we

00:22:41,389 --> 00:22:45,080
basically just have the same

00:22:43,249 --> 00:22:48,499
representation as before just with that

00:22:45,080 --> 00:22:49,730
one line Oh made it so now you know

00:22:48,499 --> 00:22:51,590
you're starting to see that there are

00:22:49,730 --> 00:22:53,980
some things that are you know more

00:22:51,590 --> 00:22:57,799
advanced compared to the core

00:22:53,980 --> 00:22:59,539
utilization capabilities now another

00:22:57,799 --> 00:23:01,669
thing that you might be concerned about

00:22:59,539 --> 00:23:05,570
is X to the naming inside your

00:23:01,669 --> 00:23:07,490
serialized format so for example what

00:23:05,570 --> 00:23:10,100
you can do is you could use the camel

00:23:07,490 --> 00:23:11,740
case to snake case name converter and

00:23:10,100 --> 00:23:15,230
pass that in as the second parameter

00:23:11,740 --> 00:23:19,220
into your normalizer and then that will

00:23:15,230 --> 00:23:23,809
change the way that the deserialization

00:23:19,220 --> 00:23:25,549
then happens to that you have in this

00:23:23,809 --> 00:23:27,649
case where we had release date that was

00:23:25,549 --> 00:23:31,009
previously camel case this is now a

00:23:27,649 --> 00:23:32,779
snake case so that that's also quite

00:23:31,009 --> 00:23:34,519
convenient and in fact you can even

00:23:32,779 --> 00:23:36,889
customize that so you can create your

00:23:34,519 --> 00:23:38,629
own name converter so in this example we

00:23:36,889 --> 00:23:44,179
want to create a name converter that

00:23:38,629 --> 00:23:46,759
actually prefixes the serialization of

00:23:44,179 --> 00:23:51,320
each of these properties with the name

00:23:46,759 --> 00:23:53,419
of the class or sorry no with it with

00:23:51,320 --> 00:23:55,490
the prefix I'm sorry so just with the

00:23:53,419 --> 00:23:57,500
prefix so this is you know you can

00:23:55,490 --> 00:23:59,509
create this on your own just implement

00:23:57,500 --> 00:24:03,980
that name converter interface which has

00:23:59,509 --> 00:24:06,200
been introduced in symphony 2.7 and you

00:24:03,980 --> 00:24:08,629
would get this result so you call name

00:24:06,200 --> 00:24:10,669
or you you make an instance of the

00:24:08,629 --> 00:24:13,850
prefix name converter you created passed

00:24:10,669 --> 00:24:15,409
in that prefix you want and then set up

00:24:13,850 --> 00:24:16,759
your your normalizer and then if you

00:24:15,409 --> 00:24:19,070
would see realize that you basically

00:24:16,759 --> 00:24:23,629
would get everything prefixed with movie

00:24:19,070 --> 00:24:25,250
underscore another thing that we you

00:24:23,629 --> 00:24:27,679
might notice here is that in the xml

00:24:25,250 --> 00:24:30,619
representation we always have this

00:24:27,679 --> 00:24:32,210
response tag at the root and you might

00:24:30,619 --> 00:24:36,159
want to change that and this is where

00:24:32,210 --> 00:24:38,570
this context thing comes into play so

00:24:36,159 --> 00:24:42,169
here we are using that third parameter

00:24:38,570 --> 00:24:45,080
on this context parameter which is just

00:24:42,169 --> 00:24:48,799
an array and we passed an xml root node

00:24:45,080 --> 00:24:50,919
name movie and as a result now we have a

00:24:48,799 --> 00:24:53,090
movie tagged rather than response tag

00:24:50,919 --> 00:24:55,580
and of course if you then you know you

00:24:53,090 --> 00:24:58,179
could you know have that context XML

00:24:55,580 --> 00:25:00,619
root name configured but then choose to

00:24:58,179 --> 00:25:05,119
utilize to Jason and then it will just

00:25:00,619 --> 00:25:06,619
be ignored now deserializing into an

00:25:05,119 --> 00:25:09,820
existing object is also something that

00:25:06,619 --> 00:25:12,109
you might want so you might have like a

00:25:09,820 --> 00:25:13,460
some data that comes from the outside

00:25:12,109 --> 00:25:16,179
and some data that comes from your

00:25:13,460 --> 00:25:17,990
database and you want to enrich that

00:25:16,179 --> 00:25:19,429
object that you got back from the

00:25:17,990 --> 00:25:21,409
database with some data that's coming

00:25:19,429 --> 00:25:24,710
from the outside so basically what you

00:25:21,409 --> 00:25:26,869
can do is you could you can have a movie

00:25:24,710 --> 00:25:29,090
instance in this case so here we see

00:25:26,869 --> 00:25:31,309
that this dollar movie 1 in this case

00:25:29,090 --> 00:25:32,539
we're manually instantiating it but it

00:25:31,309 --> 00:25:35,600
could come from you know any other

00:25:32,539 --> 00:25:38,480
system and then in the DC Airlines we

00:25:35,600 --> 00:25:43,249
could in the context specify object to

00:25:38,480 --> 00:25:45,350
populate and then instead of creating a

00:25:43,249 --> 00:25:48,049
new instance it would take that instance

00:25:45,350 --> 00:25:50,749
and put in whatever it finds in the

00:25:48,049 --> 00:25:53,450
serialized data and adds that to the

00:25:50,749 --> 00:25:58,119
given properties and you know whatever

00:25:53,450 --> 00:25:58,119
it doesn't override will then stay as is

00:25:58,389 --> 00:26:03,950
so so here in this example we see in XML

00:26:02,029 --> 00:26:05,250
where you know we have duration and

00:26:03,950 --> 00:26:07,500
release date

00:26:05,250 --> 00:26:11,370
and when we first created that movie

00:26:07,500 --> 00:26:14,610
instance we didn't set these but thanks

00:26:11,370 --> 00:26:16,500
to this object to populate we would have

00:26:14,610 --> 00:26:18,630
both the data that we set up during the

00:26:16,500 --> 00:26:24,720
construction of the movie instance as

00:26:18,630 --> 00:26:34,430
well as what we had in the xml file all

00:26:24,720 --> 00:26:37,860
right so far so good so some even more

00:26:34,430 --> 00:26:39,260
complements things so one of the the

00:26:37,860 --> 00:26:42,930
challenging things to deal with

00:26:39,260 --> 00:26:45,030
serialization is you usually or in many

00:26:42,930 --> 00:26:46,470
cases end up having object graphs so you

00:26:45,030 --> 00:26:48,780
have you know one object that has a

00:26:46,470 --> 00:26:50,610
property in which you store another

00:26:48,780 --> 00:26:55,110
object and you know that drap can get

00:26:50,610 --> 00:26:56,850
really deep and so for this case there

00:26:55,110 --> 00:26:59,910
are some things that have been added to

00:26:56,850 --> 00:27:01,380
the serializer and these are these are

00:26:59,910 --> 00:27:02,670
the things that in our initial

00:27:01,380 --> 00:27:05,190
implementation we didn't even bother

00:27:02,670 --> 00:27:07,800
dealing with so it's really great that

00:27:05,190 --> 00:27:11,370
this has been added so let's say we have

00:27:07,800 --> 00:27:13,560
in this movie class we have a property

00:27:11,370 --> 00:27:16,890
called genre which stores an instance of

00:27:13,560 --> 00:27:18,750
a John reclass we have another property

00:27:16,890 --> 00:27:21,150
called directors which is actually an

00:27:18,750 --> 00:27:26,310
array of director class instances and

00:27:21,150 --> 00:27:29,100
then we have a rule which is also an

00:27:26,310 --> 00:27:31,350
area of role instances and that role

00:27:29,100 --> 00:27:34,910
actually also has references to movies

00:27:31,350 --> 00:27:38,220
so we basically have a cyclic oh

00:27:34,910 --> 00:27:40,260
dependency here so we'll see how to deal

00:27:38,220 --> 00:27:42,570
with that so first up let's look at just

00:27:40,260 --> 00:27:43,830
the simple first case with the genre we

00:27:42,570 --> 00:27:46,470
have a one-to-one uni-directional

00:27:43,830 --> 00:27:49,800
relationship so that's not so hard to

00:27:46,470 --> 00:27:52,050
deal with so an example here first we

00:27:49,800 --> 00:27:54,030
make an instance of genre we make an

00:27:52,050 --> 00:27:55,950
instance of movie assign that genre

00:27:54,030 --> 00:27:58,560
instance and then we see realize that to

00:27:55,950 --> 00:28:02,100
xml you know just for good measure we

00:27:58,560 --> 00:28:05,220
set at the root name to movie and voila

00:28:02,100 --> 00:28:06,870
this is what we would get in xml so kind

00:28:05,220 --> 00:28:09,660
of what we would hope for right we have

00:28:06,870 --> 00:28:14,730
the genre object embedded into the

00:28:09,660 --> 00:28:18,460
serialization of the movie tag and then

00:28:14,730 --> 00:28:19,870
for json again what we would expect

00:28:18,460 --> 00:28:22,000
what's kind of nice here is that you

00:28:19,870 --> 00:28:24,760
might notice that the the tagname genre

00:28:22,000 --> 00:28:26,110
here so here we don't we only need to

00:28:24,760 --> 00:28:29,740
set this for the route we need to set

00:28:26,110 --> 00:28:31,840
what what name to use here it will you

00:28:29,740 --> 00:28:33,490
automatically use the property name so

00:28:31,840 --> 00:28:36,220
there again just for the route we need

00:28:33,490 --> 00:28:39,480
to man you set it from then on it will

00:28:36,220 --> 00:28:42,250
already know what tagging into use

00:28:39,480 --> 00:28:44,800
alright so next up let's look at the

00:28:42,250 --> 00:28:49,240
director case so this is we basically

00:28:44,800 --> 00:28:51,190
dealing with an area of object instances

00:28:49,240 --> 00:28:54,160
that are stored in the property so one

00:28:51,190 --> 00:28:59,370
too many so we set up multiple directors

00:28:54,160 --> 00:29:01,690
and assign these to the movie class

00:28:59,370 --> 00:29:05,200
again here you get kind of what you

00:29:01,690 --> 00:29:10,150
would hope for kinda so here you have a

00:29:05,200 --> 00:29:12,160
sort of direct tours tag and honestly it

00:29:10,150 --> 00:29:14,680
what I would wish for here rather is to

00:29:12,160 --> 00:29:18,580
be have a director tag I guess but you

00:29:14,680 --> 00:29:19,870
know it depends on your taste but or you

00:29:18,580 --> 00:29:22,000
might want something that you know you

00:29:19,870 --> 00:29:25,390
have a director's tag and then you have

00:29:22,000 --> 00:29:27,610
multiple director tags within but this

00:29:25,390 --> 00:29:28,600
is what you get out of the box with

00:29:27,610 --> 00:29:30,340
you're doing if you're calling a

00:29:28,600 --> 00:29:34,960
sterilizer and this is what you would

00:29:30,340 --> 00:29:37,530
get with the JSON so that's how this box

00:29:34,960 --> 00:29:40,000
already more that's what you would want

00:29:37,530 --> 00:29:43,690
with a you know directors key and then

00:29:40,000 --> 00:29:44,920
an area underneath now next up it gets a

00:29:43,690 --> 00:29:47,080
little bit more tricky so we have the

00:29:44,920 --> 00:29:49,480
many-to-many relationship between the

00:29:47,080 --> 00:29:51,970
role because our role class looks like

00:29:49,480 --> 00:29:55,150
this we basically have a movie instance

00:29:51,970 --> 00:29:59,530
in there as well and so if we have a

00:29:55,150 --> 00:30:02,380
movie instance you know with you know

00:29:59,530 --> 00:30:04,510
that actually has several roles attached

00:30:02,380 --> 00:30:06,550
to it and the rules themselves also have

00:30:04,510 --> 00:30:09,220
the same movie reference you basically

00:30:06,550 --> 00:30:11,620
have a graph and that becomes a little

00:30:09,220 --> 00:30:13,180
bit more tricky to deal with because you

00:30:11,620 --> 00:30:14,440
know if you just keep serializing then

00:30:13,180 --> 00:30:17,590
you know you come back and you basically

00:30:14,440 --> 00:30:20,290
are stuck in the loop so out of the box

00:30:17,590 --> 00:30:22,270
if you just call serialize now you would

00:30:20,290 --> 00:30:24,990
get an exception like this so it's

00:30:22,270 --> 00:30:27,550
circular reference exception essentially

00:30:24,990 --> 00:30:31,630
but there's really some nice feature

00:30:27,550 --> 00:30:32,190
here you can set certainly a reference

00:30:31,630 --> 00:30:39,700
have

00:30:32,190 --> 00:30:41,830
on your normalizer what you and what you

00:30:39,700 --> 00:30:45,210
pass in here is actually callable so in

00:30:41,830 --> 00:30:48,820
this case we're just using a closer and

00:30:45,210 --> 00:30:50,470
you just return an ID instead so

00:30:48,820 --> 00:30:54,040
basically whenever it now occur

00:30:50,470 --> 00:30:55,600
encounters it or determines that this is

00:30:54,040 --> 00:30:57,309
a circular dependency instead of

00:30:55,600 --> 00:31:01,360
throwing that exception it's going to

00:30:57,309 --> 00:31:04,690
call that closure to figure out what

00:31:01,360 --> 00:31:08,410
representation to use instead so now if

00:31:04,690 --> 00:31:10,960
we see realize that rolls thing it will

00:31:08,410 --> 00:31:12,910
detect when it comes to the movie that

00:31:10,960 --> 00:31:14,380
this is a circular reference and then

00:31:12,910 --> 00:31:16,090
instead of going through the normal

00:31:14,380 --> 00:31:17,950
serialization process to try and see

00:31:16,090 --> 00:31:21,540
realize that it's just going to call or

00:31:17,950 --> 00:31:24,190
closure and get that ID so obviously

00:31:21,540 --> 00:31:27,250
this is a little bit simple in the sense

00:31:24,190 --> 00:31:29,080
that you might have like multiple you

00:31:27,250 --> 00:31:31,270
know scenarios for circular graphs and

00:31:29,080 --> 00:31:33,220
maybe it's not always the get ID method

00:31:31,270 --> 00:31:34,690
that you need to use there so maybe that

00:31:33,220 --> 00:31:36,250
function needs to be more complex like

00:31:34,690 --> 00:31:38,140
you actually need to check is it an

00:31:36,250 --> 00:31:39,610
instant of that then call this method is

00:31:38,140 --> 00:31:42,940
an instead of that than call that method

00:31:39,610 --> 00:31:46,990
but yeah so basically it's now possible

00:31:42,940 --> 00:31:48,340
to deal with circular dependencies now

00:31:46,990 --> 00:31:51,040
another thing that you might want to do

00:31:48,340 --> 00:31:53,170
and this is actually how do po8 uses the

00:31:51,040 --> 00:31:55,150
symphony serializing component

00:31:53,170 --> 00:31:59,830
extensively is with custom normalize

00:31:55,150 --> 00:32:01,690
errs so so one thing that you know you

00:31:59,830 --> 00:32:04,000
might want to do is you might want to

00:32:01,690 --> 00:32:06,280
use at the date-time instance rather

00:32:04,000 --> 00:32:09,070
than just the string for the date in

00:32:06,280 --> 00:32:11,350
your object and so if you would see

00:32:09,070 --> 00:32:13,150
realize that and you know it works you

00:32:11,350 --> 00:32:15,250
know your serialize state will just look

00:32:13,150 --> 00:32:17,620
like this which is basically the

00:32:15,250 --> 00:32:20,110
civilized representation of a daytime

00:32:17,620 --> 00:32:22,570
object which is probably however not

00:32:20,110 --> 00:32:29,050
what you really want so what you could

00:32:22,570 --> 00:32:33,190
do is you could use a custom call back

00:32:29,050 --> 00:32:35,830
in your normalizer to deal with that

00:32:33,190 --> 00:32:39,460
specific case so we can we use the

00:32:35,830 --> 00:32:41,590
standard object normalizer and then we

00:32:39,460 --> 00:32:43,270
create a call back in this again again

00:32:41,590 --> 00:32:45,610
this is a callable we're using a closure

00:32:43,270 --> 00:32:47,290
here and then you just set a call back

00:32:45,610 --> 00:32:49,660
and you define for which properties

00:32:47,290 --> 00:32:51,580
names you want to use the callback so in

00:32:49,660 --> 00:32:56,140
this case we do is release date birth

00:32:51,580 --> 00:32:58,870
date and death day and then instead of

00:32:56,140 --> 00:33:00,960
getting this ginormous representation we

00:32:58,870 --> 00:33:04,240
get a much more compact representation

00:33:00,960 --> 00:33:06,400
of a date which you know includes the

00:33:04,240 --> 00:33:08,590
day the time and the time zone which

00:33:06,400 --> 00:33:13,350
would be sufficient to get our daytime

00:33:08,590 --> 00:33:18,640
object we it stated when we deserialize

00:33:13,350 --> 00:33:20,500
so here's the JSON representation yeah

00:33:18,640 --> 00:33:22,720
and actually I kind of got confused so i

00:33:20,500 --> 00:33:24,970
just sold user kolbeck normalizer this

00:33:22,720 --> 00:33:27,780
is not what Drupal 8 is using this is

00:33:24,970 --> 00:33:31,480
what do plate is using custom organizers

00:33:27,780 --> 00:33:33,190
so basically a custom normalizer base

00:33:31,480 --> 00:33:36,940
you just need to implement the

00:33:33,190 --> 00:33:39,250
normalizable interface and then either

00:33:36,940 --> 00:33:41,350
the normalized method if you just want

00:33:39,250 --> 00:33:42,970
to have a normalizer or as well to

00:33:41,350 --> 00:33:45,820
denormalize ER if you want to have a

00:33:42,970 --> 00:33:50,910
dino analyzer as well so it's a look

00:33:45,820 --> 00:33:54,160
here so this is a custom normalizer or

00:33:50,910 --> 00:33:57,640
sorry Lawrence I'm getting confused

00:33:54,160 --> 00:34:00,100
again so we're still not where what to

00:33:57,640 --> 00:34:02,830
play accuses so this is sorry

00:34:00,100 --> 00:34:04,360
backtracking so this is something so

00:34:02,830 --> 00:34:06,940
with this custom normalizer what you can

00:34:04,360 --> 00:34:08,649
do is you can actually attach some logic

00:34:06,940 --> 00:34:12,159
about how to normalize that give an

00:34:08,649 --> 00:34:14,109
object to that class itself so here we

00:34:12,159 --> 00:34:17,919
have the role and the role implements

00:34:14,109 --> 00:34:19,510
the normalizable interface and so with

00:34:17,919 --> 00:34:21,730
that normalized interface instead of

00:34:19,510 --> 00:34:24,250
going through the normal normalizer when

00:34:21,730 --> 00:34:26,470
it encounters such a an object instance

00:34:24,250 --> 00:34:31,300
is going to call the normalized method

00:34:26,470 --> 00:34:32,530
on that class so so basically this

00:34:31,300 --> 00:34:34,389
enables you especially when you're

00:34:32,530 --> 00:34:36,490
dealing with larger object graphs

00:34:34,389 --> 00:34:38,530
sometimes it might not make sense to

00:34:36,490 --> 00:34:40,359
have like this ginormous chain of

00:34:38,530 --> 00:34:42,159
normalizes that you register to deal

00:34:40,359 --> 00:34:45,010
with all these special cases for all

00:34:42,159 --> 00:34:49,000
these different classes so with this

00:34:45,010 --> 00:34:51,159
normalizer interface you can add attach

00:34:49,000 --> 00:34:54,429
these this logic to the classes

00:34:51,159 --> 00:34:55,810
themselves so this is has the advantage

00:34:54,429 --> 00:34:57,730
that you don't have to register at many

00:34:55,810 --> 00:34:59,590
normalizes because as you might remember

00:34:57,730 --> 00:35:01,420
otherwise we would have to iterate over

00:34:59,590 --> 00:35:03,880
every normalizer to find the right one

00:35:01,420 --> 00:35:05,770
for the given class so this is sort of a

00:35:03,880 --> 00:35:07,780
way to optimize performance if you need

00:35:05,770 --> 00:35:09,430
to deal with lots of normalize errs what

00:35:07,780 --> 00:35:12,460
is kind of ugly with it is that you're

00:35:09,430 --> 00:35:15,090
you end up sort of polluting your role

00:35:12,460 --> 00:35:18,430
object was something that I find is not

00:35:15,090 --> 00:35:21,100
responsibility of the role class itself

00:35:18,430 --> 00:35:22,690
to know how to serialize it how it just

00:35:21,100 --> 00:35:25,720
utilize it sells or hard to normalize

00:35:22,690 --> 00:35:27,640
itself to an array so I think it's a

00:35:25,720 --> 00:35:31,570
sort of a little bit of a performing

00:35:27,640 --> 00:35:34,000
attack in my opinion but it can also be

00:35:31,570 --> 00:35:37,210
sort of nice in the way that you keep

00:35:34,000 --> 00:35:38,920
everything in one place yeah if you

00:35:37,210 --> 00:35:42,930
start end up having lots of normalizes

00:35:38,920 --> 00:35:45,250
then this might be a better alternative

00:35:42,930 --> 00:35:46,869
there's also the serializer aware

00:35:45,250 --> 00:35:49,830
interface so this is something if you

00:35:46,869 --> 00:35:52,810
create a custom normalizer you can

00:35:49,830 --> 00:35:54,790
basically have it implement the

00:35:52,810 --> 00:35:56,650
serializable utilizar aware interface

00:35:54,790 --> 00:35:58,359
which basically means it's automatically

00:35:56,650 --> 00:36:01,660
going to get the serializer attached to

00:35:58,359 --> 00:36:03,630
it and this is this area d normalizer

00:36:01,660 --> 00:36:09,760
that i talked to talked about that is

00:36:03,630 --> 00:36:12,160
coming in a symphony 2.8 basically what

00:36:09,760 --> 00:36:15,010
that that arity normalizer does is that

00:36:12,160 --> 00:36:16,869
when you call the denormalized method

00:36:15,010 --> 00:36:19,720
there was the second parameter which is

00:36:16,869 --> 00:36:24,850
called type and this type you usually

00:36:19,720 --> 00:36:26,320
specify a class name and with this era d

00:36:24,850 --> 00:36:29,170
normalizer what you can do is you can

00:36:26,320 --> 00:36:30,490
deal with areas of class instances so

00:36:29,170 --> 00:36:32,859
instead of just passing in the class

00:36:30,490 --> 00:36:36,010
name you actually specify a class name

00:36:32,859 --> 00:36:39,310
and then brackets opening and closing

00:36:36,010 --> 00:36:41,260
brackets in the type that you pass in

00:36:39,310 --> 00:36:42,970
and as you see here in the supports you

00:36:41,260 --> 00:36:46,480
normalization method what it does it

00:36:42,970 --> 00:36:49,690
checks is the end of that string opening

00:36:46,480 --> 00:36:52,570
and closing brackets and do I support d

00:36:49,690 --> 00:36:54,910
normalization of the type without those

00:36:52,570 --> 00:36:57,190
opening and closing brackets then it

00:36:54,910 --> 00:36:59,350
says this era d normalizer candy

00:36:57,190 --> 00:37:01,270
normalize this and then in z normalizer

00:36:59,350 --> 00:37:06,130
method itself what it does it actually

00:37:01,270 --> 00:37:08,770
calls the D normalizer and without those

00:37:06,130 --> 00:37:10,510
curly brackets so again the point is

00:37:08,770 --> 00:37:11,079
that you can deal with an area of object

00:37:10,510 --> 00:37:14,469
instance

00:37:11,079 --> 00:37:19,779
and hint the type that you want to

00:37:14,469 --> 00:37:21,430
deserialize into another really cool

00:37:19,779 --> 00:37:26,380
feature that was added to the serializer

00:37:21,430 --> 00:37:28,150
is utilization groups and this can be

00:37:26,380 --> 00:37:30,309
quite useful for example if you have

00:37:28,150 --> 00:37:32,079
different permissions and depending on

00:37:30,309 --> 00:37:36,190
permissions you want to show more or

00:37:32,079 --> 00:37:38,979
less so let's say here we have the movie

00:37:36,190 --> 00:37:41,160
class again and we want to show the ID

00:37:38,979 --> 00:37:44,109
only to admin so when we see realized

00:37:41,160 --> 00:37:46,839
but the title should be also viewable by

00:37:44,109 --> 00:37:49,589
other roles like publishers and users

00:37:46,839 --> 00:37:52,930
and so on so forth so these annotations

00:37:49,589 --> 00:37:55,239
also llamo configuration or XML

00:37:52,930 --> 00:37:59,019
configuration and in fact I think you

00:37:55,239 --> 00:38:03,059
can also configure it via PHP you can

00:37:59,019 --> 00:38:03,059
configure these serialization groups

00:38:03,599 --> 00:38:08,410
then creating or setting up your

00:38:07,209 --> 00:38:11,799
serialize it becomes a little bit more

00:38:08,410 --> 00:38:13,269
complicated so you need to set up the

00:38:11,799 --> 00:38:15,400
metadata loaders that you want to use

00:38:13,269 --> 00:38:16,809
you don't have to use all of them of

00:38:15,400 --> 00:38:19,420
course so if you just use annotations

00:38:16,809 --> 00:38:23,140
you don't need the xml file or the mo

00:38:19,420 --> 00:38:27,519
file loader and yes you basically

00:38:23,140 --> 00:38:29,650
configure your annotation loader attach

00:38:27,519 --> 00:38:31,690
that to your class meta data factory and

00:38:29,650 --> 00:38:34,509
then pass that in as the first parameter

00:38:31,690 --> 00:38:35,739
to the object normalizer and you know

00:38:34,509 --> 00:38:37,420
you just need to do that once of course

00:38:35,739 --> 00:38:41,410
in your code or when you set up your

00:38:37,420 --> 00:38:44,319
service and there you go you now would

00:38:41,410 --> 00:38:46,269
have support for this group feature so

00:38:44,319 --> 00:38:49,329
if you call this utilize method now you

00:38:46,269 --> 00:38:51,400
can add in your context you know the

00:38:49,329 --> 00:38:53,319
group that you want to serialize to so

00:38:51,400 --> 00:38:55,539
users for example and then it will

00:38:53,319 --> 00:38:57,279
automatically apply the rules in this

00:38:55,539 --> 00:38:58,509
case it would skip the ID property and

00:38:57,279 --> 00:39:01,650
would not see realize that annex

00:38:58,509 --> 00:39:05,410
therefore not expose that to the outside

00:39:01,650 --> 00:39:07,719
now there's of course still development

00:39:05,410 --> 00:39:11,140
going on so one thing that is currently

00:39:07,719 --> 00:39:14,289
under discussion is in the denomination

00:39:11,140 --> 00:39:16,479
to use type hitting on so in many cases

00:39:14,289 --> 00:39:20,799
it actually is possible to sort of

00:39:16,479 --> 00:39:23,709
figure out what class to denormalize

00:39:20,799 --> 00:39:24,369
into when you're dealing with an object

00:39:23,709 --> 00:39:26,589
graph

00:39:24,369 --> 00:39:28,990
because that's kind of like currently

00:39:26,589 --> 00:39:31,180
not really nicely possible so let's say

00:39:28,990 --> 00:39:35,230
we have an invoice class this invoice

00:39:31,180 --> 00:39:38,529
class has a property with a customer and

00:39:35,230 --> 00:39:39,910
you know we have the customer method and

00:39:38,529 --> 00:39:42,849
it you know it has a type in for the

00:39:39,910 --> 00:39:46,059
customer class and the idea here is that

00:39:42,849 --> 00:39:48,279
based on that said customer method and

00:39:46,059 --> 00:39:49,539
the type in that we have here is that

00:39:48,279 --> 00:39:51,730
the serializer could actually

00:39:49,539 --> 00:39:52,809
automatically figure out that in fact it

00:39:51,730 --> 00:39:56,499
needs to create an instead of the

00:39:52,809 --> 00:39:59,619
customer when it DC realises so this is

00:39:56,499 --> 00:40:01,509
currently being worked on as far as I

00:39:59,619 --> 00:40:04,089
know this will actually result in

00:40:01,509 --> 00:40:06,190
another component right fuggin are we

00:40:04,089 --> 00:40:10,839
doing the yeah so this is going to be a

00:40:06,190 --> 00:40:12,640
new component so Kevin you basically had

00:40:10,839 --> 00:40:15,609
already created a component for dealing

00:40:12,640 --> 00:40:18,609
with basically having a single API that

00:40:15,609 --> 00:40:21,069
can introspect and try to find such

00:40:18,609 --> 00:40:25,029
information not only from tie pins but

00:40:21,069 --> 00:40:29,289
also from from PHP dog comments it also

00:40:25,029 --> 00:40:32,799
supports PHP seven return type ins and

00:40:29,289 --> 00:40:34,450
things like that and I think it also

00:40:32,799 --> 00:40:37,660
supports even hack clang I don't know

00:40:34,450 --> 00:40:40,650
exactly I haven't looked at the code in

00:40:37,660 --> 00:40:43,299
detail but with once we have that

00:40:40,650 --> 00:40:45,869
component inside symphony we can start

00:40:43,299 --> 00:40:48,999
using that in the serializer to vary

00:40:45,869 --> 00:40:53,619
more elegantly deal with DC realization

00:40:48,999 --> 00:40:55,809
of object graphs all right so how do you

00:40:53,619 --> 00:40:57,940
use all of that in Drupal so as I

00:40:55,809 --> 00:40:59,789
mentioned the serialization component is

00:40:57,940 --> 00:41:03,130
actually a core piece of tuple eight

00:40:59,789 --> 00:41:05,049
it's part of you know that the rest api

00:41:03,130 --> 00:41:07,960
said Greece was talking about this

00:41:05,049 --> 00:41:09,609
morning and so they're basically two

00:41:07,960 --> 00:41:11,799
modules so the first one is the

00:41:09,609 --> 00:41:15,309
serialization module which basically

00:41:11,799 --> 00:41:17,829
does the core work of integrating the

00:41:15,309 --> 00:41:21,190
symphony serializer into Drupal and I'm

00:41:17,829 --> 00:41:22,839
not a roupa expert by any means I think

00:41:21,190 --> 00:41:24,819
the only time that I install Drupal is

00:41:22,839 --> 00:41:27,539
kind of through platform at sage and

00:41:24,819 --> 00:41:30,249
spinning up a drupal instance there and

00:41:27,539 --> 00:41:33,940
I try to update these slides a little

00:41:30,249 --> 00:41:35,380
bit based on like just seeing that the

00:41:33,940 --> 00:41:36,610
state has changed a little bit since the

00:41:35,380 --> 00:41:38,320
LA talk

00:41:36,610 --> 00:41:40,480
there's minor things that have changed

00:41:38,320 --> 00:41:43,750
since then essentially has a you know

00:41:40,480 --> 00:41:46,270
your core module you know with your your

00:41:43,750 --> 00:41:47,710
standard files the most entering is

00:41:46,270 --> 00:41:49,360
interesting one and I'm actually going

00:41:47,710 --> 00:41:51,610
to show a little bit about that in the

00:41:49,360 --> 00:41:56,080
coming slides is the the services that

00:41:51,610 --> 00:41:58,960
are being defined Drupal 8 ships with

00:41:56,080 --> 00:42:02,440
lots of custom encoders and normalizes

00:41:58,960 --> 00:42:04,750
and they in turn use what is called

00:42:02,440 --> 00:42:06,640
entity resolvers so this is a dupe Oh

00:42:04,750 --> 00:42:10,720
specific concept that's not part of

00:42:06,640 --> 00:42:13,960
symphony itself and so here you see an

00:42:10,720 --> 00:42:16,990
overview of the normalizer so these are

00:42:13,960 --> 00:42:20,860
several normalizes available out of the

00:42:16,990 --> 00:42:23,010
box in Drupal 8 and as far as I know out

00:42:20,860 --> 00:42:25,060
of the box none of the symphony

00:42:23,010 --> 00:42:32,200
normalizes are being used in to play

00:42:25,060 --> 00:42:34,960
right and now if you look at that

00:42:32,200 --> 00:42:36,610
serialization services code llamo this

00:42:34,960 --> 00:42:38,820
is not the entire content of the file

00:42:36,610 --> 00:42:41,230
essentially what you have here is you

00:42:38,820 --> 00:42:44,560
define a serial there's a see realises

00:42:41,230 --> 00:42:47,680
he R a normalizer and an encoder that's

00:42:44,560 --> 00:42:49,150
defined here what you might notice here

00:42:47,680 --> 00:42:51,430
is that you know these arguments to the

00:42:49,150 --> 00:42:54,340
serializer so this was this array of

00:42:51,430 --> 00:42:56,740
normalizes and areas of encoders this is

00:42:54,340 --> 00:42:58,260
the empty here what what happens here is

00:42:56,740 --> 00:43:01,810
that Drupal actually uses something

00:42:58,260 --> 00:43:04,330
that's called tags in that is supported

00:43:01,810 --> 00:43:08,350
by the dependency injection container so

00:43:04,330 --> 00:43:11,130
here you see in that normalizer list

00:43:08,350 --> 00:43:14,440
service it has a tag called name

00:43:11,130 --> 00:43:16,480
normalizer and based on that Drupal will

00:43:14,440 --> 00:43:18,910
actually automatically realize that this

00:43:16,480 --> 00:43:20,950
is supposed to be normalizer and add

00:43:18,910 --> 00:43:23,650
that to the array that is being passed

00:43:20,950 --> 00:43:25,900
as the first argument up into that see

00:43:23,650 --> 00:43:29,020
réaliser service the same thing happens

00:43:25,900 --> 00:43:31,030
with the encoder so here adjacent

00:43:29,020 --> 00:43:34,600
encoder instance is defined and then

00:43:31,030 --> 00:43:37,720
with the tag name encoder it's going to

00:43:34,600 --> 00:43:41,110
be created as an instance and pass into

00:43:37,720 --> 00:43:45,910
an area as a second parameter for the

00:43:41,110 --> 00:43:48,490
format JSON so you end up with you know

00:43:45,910 --> 00:43:51,250
lots of services that are being defined

00:43:48,490 --> 00:43:52,390
in most part the only one that you

00:43:51,250 --> 00:43:54,910
should be using is the one at the top

00:43:52,390 --> 00:43:57,520
serializer so that's the one that should

00:43:54,910 --> 00:43:59,980
be considered sort of public the rest as

00:43:57,520 --> 00:44:01,930
far as I sort of figure out from the

00:43:59,980 --> 00:44:05,230
Drupal 8 call code is actually also

00:44:01,930 --> 00:44:09,160
public so you can also get from the

00:44:05,230 --> 00:44:11,890
dependency injection container but I

00:44:09,160 --> 00:44:14,040
wouldn't advise to use them because they

00:44:11,890 --> 00:44:17,500
might go away later in Drupal 8 or so on

00:44:14,040 --> 00:44:19,030
because you really should need to use

00:44:17,500 --> 00:44:21,400
them because you can get everything that

00:44:19,030 --> 00:44:24,090
you need sort of by just working with

00:44:21,400 --> 00:44:27,010
the methods available in the serializer

00:44:24,090 --> 00:44:30,360
now there's a second module in there

00:44:27,010 --> 00:44:33,340
called the hell module which sort of

00:44:30,360 --> 00:44:39,700
expands on the basic Jason support to

00:44:33,340 --> 00:44:41,650
support hell how is basically a custom

00:44:39,700 --> 00:44:43,210
format on top of JSON actually it's also

00:44:41,650 --> 00:44:45,700
available for xmls remember correctly

00:44:43,210 --> 00:44:47,920
which basically enables you to build

00:44:45,700 --> 00:44:49,210
REST API is with a little bit more

00:44:47,920 --> 00:44:52,030
assumptions that you get from the

00:44:49,210 --> 00:44:54,340
standard JSON representation and so this

00:44:52,030 --> 00:44:57,340
module basically just adds a bunch of

00:44:54,340 --> 00:44:59,170
encoders and normalize errs and some

00:44:57,340 --> 00:45:01,000
additional services that are then

00:44:59,170 --> 00:45:03,100
through this tagging system also being

00:45:01,000 --> 00:45:07,600
attached to the serializer module

00:45:03,100 --> 00:45:10,420
serializer service yeah so your

00:45:07,600 --> 00:45:12,580
basically get some additional services

00:45:10,420 --> 00:45:14,890
and here actually all of these should be

00:45:12,580 --> 00:45:19,180
considered private I just screwed up on

00:45:14,890 --> 00:45:20,619
this right there now that basically

00:45:19,180 --> 00:45:22,990
concludes what I wanted to talk about

00:45:20,619 --> 00:45:24,970
for the serialize a component I just

00:45:22,990 --> 00:45:27,880
wanted to briefly mention j med

00:45:24,970 --> 00:45:29,650
serializer library and this is actually

00:45:27,880 --> 00:45:31,240
a library that is actually the main

00:45:29,650 --> 00:45:35,050
reason why I stopped working on the

00:45:31,240 --> 00:45:37,390
serializer component itself because your

00:45:35,050 --> 00:45:39,010
honor Schmidt who created that did a

00:45:37,390 --> 00:45:43,800
really good job in very quickly

00:45:39,010 --> 00:45:47,410
supporting in handling circular graphs

00:45:43,800 --> 00:45:50,109
very elegantly and what he did there was

00:45:47,410 --> 00:45:52,119
also that instead of where are you in

00:45:50,109 --> 00:45:54,010
the core serializer what we have is

00:45:52,119 --> 00:45:56,680
basically you have these normalizes that

00:45:54,010 --> 00:45:59,200
are just expected to be quite generic

00:45:56,680 --> 00:46:00,970
and how they deal with things or if you

00:45:59,200 --> 00:46:02,580
make them more specific you end up with

00:46:00,970 --> 00:46:05,410
this gigantic array

00:46:02,580 --> 00:46:07,750
what he did there was basically you have

00:46:05,410 --> 00:46:09,810
a lot of mapping files with where you

00:46:07,750 --> 00:46:12,520
specify how things should be normalized

00:46:09,810 --> 00:46:14,770
so it's a very different way of dealing

00:46:12,520 --> 00:46:17,290
with normalization I thought at least

00:46:14,770 --> 00:46:20,230
initially it's more elegant it turns out

00:46:17,290 --> 00:46:23,050
that his approach is indeed very elegant

00:46:20,230 --> 00:46:25,510
it's also very flexible and it's very

00:46:23,050 --> 00:46:28,119
powerful but it comes at a big overhead

00:46:25,510 --> 00:46:30,640
so basically especially for simpler cat

00:46:28,119 --> 00:46:32,710
cases you're going to have slower

00:46:30,640 --> 00:46:35,710
performance than what you could achieve

00:46:32,710 --> 00:46:39,640
easily with a serializer with less work

00:46:35,710 --> 00:46:42,040
in configuration so on so forth so I

00:46:39,640 --> 00:46:43,869
would say generally use the JMS

00:46:42,040 --> 00:46:46,090
serializer if you have very elaborate

00:46:43,869 --> 00:46:48,160
very deep object graphs and very much

00:46:46,090 --> 00:46:51,760
and in many situations where you need to

00:46:48,160 --> 00:46:55,990
customize things and I would simpler

00:46:51,760 --> 00:46:58,240
cases use the simpler serializer there's

00:46:55,990 --> 00:47:00,640
one other thing to consider which is

00:46:58,240 --> 00:47:03,369
important from a legal perspective the

00:47:00,640 --> 00:47:05,290
JMS serializer uses the apache license

00:47:03,369 --> 00:47:07,600
which is incompatible with the GPL

00:47:05,290 --> 00:47:09,220
license so of course if you're creating

00:47:07,600 --> 00:47:12,520
your own code you can combine as you

00:47:09,220 --> 00:47:14,280
wish but if you ship that code then

00:47:12,520 --> 00:47:17,080
you're sort of an illegal grey area

00:47:14,280 --> 00:47:19,240
because so if you distribute code that

00:47:17,080 --> 00:47:22,240
is mixed between GPL and apache license

00:47:19,240 --> 00:47:24,490
then considering the fact that both are

00:47:22,240 --> 00:47:28,270
incompatible you're actually violating

00:47:24,490 --> 00:47:29,740
the licenses at least of the GPL so

00:47:28,270 --> 00:47:31,660
that's something to consider and that's

00:47:29,740 --> 00:47:35,310
also one of the reasons why the jamis

00:47:31,660 --> 00:47:35,310
realize it was never considered for core

00:47:35,940 --> 00:47:42,850
alright so I'm already through with my

00:47:38,710 --> 00:47:45,720
slides and I assume there are probably

00:47:42,850 --> 00:47:47,859
some questions that I could answer

00:47:45,720 --> 00:47:50,290
there's a microphone over there if you

00:47:47,859 --> 00:47:52,210
have questions that we best but if not I

00:47:50,290 --> 00:47:56,940
can just repeat it so we get it on the

00:47:52,210 --> 00:48:01,240
recording there is no movement

00:47:56,940 --> 00:48:03,490
everything was clear no questions any

00:48:01,240 --> 00:48:04,930
comments or additions from some of the

00:48:03,490 --> 00:48:07,660
Drupal experts that can maybe say

00:48:04,930 --> 00:48:11,440
something relevant about Drupal that I

00:48:07,660 --> 00:48:13,810
cannot add I guess then we're done a

00:48:11,440 --> 00:48:15,500
little bit early I can I will try to

00:48:13,810 --> 00:48:17,900
name drop something here

00:48:15,500 --> 00:48:20,930
so later on today I'm doing a talk

00:48:17,900 --> 00:48:22,850
together with a co-worker of mine the

00:48:20,930 --> 00:48:24,290
talk is name is teal is the new orange

00:48:22,850 --> 00:48:28,280
i'm not sure if everybody gets the

00:48:24,290 --> 00:48:31,520
reference to the TV show but the topic

00:48:28,280 --> 00:48:33,560
this is actually sort of a soft topic

00:48:31,520 --> 00:48:35,810
we're talking about self managing

00:48:33,560 --> 00:48:37,550
organizations we talk a lot about

00:48:35,810 --> 00:48:40,220
basically how the company I work for

00:48:37,550 --> 00:48:41,690
leap is organized and how its evolving

00:48:40,220 --> 00:48:44,780
and what we have planned for the future

00:48:41,690 --> 00:48:47,300
so it's non technical but to me this

00:48:44,780 --> 00:48:49,010
talk is really exciting I feel a lot of

00:48:47,300 --> 00:48:52,880
pressure because I feel very passionate

00:48:49,010 --> 00:48:55,010
about what we are talking there and so I

00:48:52,880 --> 00:48:56,600
hope I don't screw it up but I would

00:48:55,010 --> 00:48:59,060
appreciate to have lots of people there

00:48:56,600 --> 00:49:00,800
because I think it's something that any

00:48:59,060 --> 00:49:03,380
organization can benefit for from

00:49:00,800 --> 00:49:05,330
benefit from or at least to have sort of

00:49:03,380 --> 00:49:07,910
a new back of your head you know

00:49:05,330 --> 00:49:09,980
thinking of organizations that are much

00:49:07,910 --> 00:49:11,870
more engaging much more rewarding to

00:49:09,980 --> 00:49:14,570
people and then I think fundamentally

00:49:11,870 --> 00:49:16,100
also more productive so anyway thank you

00:49:14,570 --> 00:49:18,340
very much for listening and have a great

00:49:16,100 --> 00:49:18,340

YouTube URL: https://www.youtube.com/watch?v=dPthEizTrSY


