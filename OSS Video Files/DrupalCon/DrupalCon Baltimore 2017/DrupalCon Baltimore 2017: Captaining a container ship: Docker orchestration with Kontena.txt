Title: DrupalCon Baltimore 2017: Captaining a container ship: Docker orchestration with Kontena
Publication date: 2017-04-25
Playlist: DrupalCon Baltimore 2017
Description: 
	In this talk, I’m going to introduce Kontena, an orchestration tool that lets you level up from plain Docker without spending days reading and banging your head on the desk.

Docker containers turned out to be a great tool for spinning up applications in development, testing or even production environments. Using the same deployment mechanism in dev as in ops makes life easier for everyone and significantly shortens cycle times. But as soon as the number of containers rises (and it always does because Docker is fun), things seem to get complicated. This is the point where others suggest studying for a web operations degree (by recommending  Ansible, Chef, Swarm, Rancher, Kubernetes or even Mesosphere). Welcome to Yak Shaving 101...

Or you could use a nice little Docker orchestration platform from Finland. It's called Kontena and it's as easy to set up as it is getting an application stack running on it. If you’re already familiar with Docker Compose, you’ll need only a few minutes to get a full application stack running. (Later, you can still use Kontena to build a distributed infrastructure across multiple cloud providers.)

At freistilbox, we tried Kontena in our internship programme and promptly put it to use in our Drupal hosting infrastructure. In my talk, I'm going to cover topics like:

Why choose Kontena?
The Kontena architecture
Setting up a Kontena cluster for development or production
Upgrading from Docker Compose
Deploying a multi-container application stack
Network and security
I'm still amazed how simple it is to use Kontena, and this talk will be easy to understand even by developers and sysadmins unfamiliar with Docker.
Captions: 
	00:00:00,000 --> 00:00:15,839
it grep orc said crap awk said grab awk

00:00:12,650 --> 00:00:19,529
don't worry that's just a an old eunuchs

00:00:15,839 --> 00:00:23,779
ritual to appease the demo gods they

00:00:19,529 --> 00:00:27,320
like the sacrifice of Pike Place roast

00:00:23,779 --> 00:00:28,680
welcome to captaining a container ship

00:00:27,320 --> 00:00:33,660
docker

00:00:28,680 --> 00:00:37,820
orchestration with container docker

00:00:33,660 --> 00:00:41,180
orchestration what's that for well

00:00:37,820 --> 00:00:44,750
orchestration is basically running

00:00:41,180 --> 00:00:49,829
docker containers at scale if you are

00:00:44,750 --> 00:00:51,989
only running single containers that's

00:00:49,829 --> 00:00:56,910
still quite easy you can do everything

00:00:51,989 --> 00:01:00,690
by hand docker gives you a lot of tools

00:00:56,910 --> 00:01:03,120
that you can use to download images spin

00:01:00,690 --> 00:01:12,170
up containers check if they're running

00:01:03,120 --> 00:01:17,280
and shut them down again who of you is

00:01:12,170 --> 00:01:20,009
already at that state running a handful

00:01:17,280 --> 00:01:23,460
of containers spinning up one from time

00:01:20,009 --> 00:01:29,640
to time for development or testing or

00:01:23,460 --> 00:01:32,579
things like that well the probability is

00:01:29,640 --> 00:01:35,880
high that you like docker

00:01:32,579 --> 00:01:42,420
because it's really easy to get into and

00:01:35,880 --> 00:01:46,320
to get started and when the number of

00:01:42,420 --> 00:01:51,180
containers grows things are getting much

00:01:46,320 --> 00:01:56,250
more complex so if you're really more at

00:01:51,180 --> 00:02:00,570
that stage you can't do any manual stuff

00:01:56,250 --> 00:02:03,810
anymore and you need to have solutions

00:02:00,570 --> 00:02:06,990
that will help you maintain all these

00:02:03,810 --> 00:02:13,440
containers or their relationships and

00:02:06,990 --> 00:02:14,040
stuff and if you don't learn to use

00:02:13,440 --> 00:02:17,219
these two

00:02:14,040 --> 00:02:33,590
will these orchestration tools you might

00:02:17,219 --> 00:02:33,590
end up like this so who is at that stage

00:02:33,859 --> 00:02:40,500
all right

00:02:35,250 --> 00:02:43,889
let's prepare you for it why are

00:02:40,500 --> 00:02:48,090
castration as soon as you started using

00:02:43,889 --> 00:02:50,340
docker in earnest there will be more

00:02:48,090 --> 00:02:52,919
than one container because if you are

00:02:50,340 --> 00:02:56,220
following the docker philosophy of one

00:02:52,919 --> 00:02:59,599
single application per container you'll

00:02:56,220 --> 00:03:03,000
end up with groups of containers and

00:02:59,599 --> 00:03:05,159
these containers all have to be managed

00:03:03,000 --> 00:03:08,480
you need to spin them up you need to

00:03:05,159 --> 00:03:11,849
shut them down they need to be

00:03:08,480 --> 00:03:15,560
distributed if you like to for example

00:03:11,849 --> 00:03:16,709
use different resources for different

00:03:15,560 --> 00:03:21,150
applications

00:03:16,709 --> 00:03:24,030
so let's pick an example running a web

00:03:21,150 --> 00:03:25,379
server like Apache will require much

00:03:24,030 --> 00:03:27,930
different resources from your

00:03:25,379 --> 00:03:31,049
infrastructure than for example running

00:03:27,930 --> 00:03:35,190
in my sequel container you might want to

00:03:31,049 --> 00:03:39,349
run my sequel on a host that uses SSD

00:03:35,190 --> 00:03:42,810
based storage you might want to run a

00:03:39,349 --> 00:03:49,139
memcache tea container on a machine that

00:03:42,810 --> 00:03:51,359
has lots of RAM and so you have to

00:03:49,139 --> 00:03:54,479
select the right infrastructure for the

00:03:51,359 --> 00:03:56,250
right container they need to be

00:03:54,479 --> 00:04:00,599
scheduled which means they need to be

00:03:56,250 --> 00:04:03,359
spun up and if they go down by accident

00:04:00,599 --> 00:04:08,180
or because you want them to you probably

00:04:03,359 --> 00:04:11,699
want to start them again sometime

00:04:08,180 --> 00:04:14,099
they need to be load balanced especially

00:04:11,699 --> 00:04:18,079
if you are using the distributed nature

00:04:14,099 --> 00:04:22,469
of these things you'd like to be able to

00:04:18,079 --> 00:04:25,620
distribute load between multiple Drupal

00:04:22,469 --> 00:04:28,440
containers for example

00:04:25,620 --> 00:04:34,710
and that gets quite complex as soon as

00:04:28,440 --> 00:04:37,020
the number of containers grows then

00:04:34,710 --> 00:04:42,150
there's all these dependencies between

00:04:37,020 --> 00:04:46,979
containers if your Drupal container for

00:04:42,150 --> 00:04:49,530
example needs to talk to the database or

00:04:46,979 --> 00:04:52,410
needs to talk to memcache D there needs

00:04:49,530 --> 00:04:55,620
to be some way of these containers

00:04:52,410 --> 00:05:03,780
knowing of each other they need to be

00:04:55,620 --> 00:05:07,560
linked or connected by other means if

00:05:03,780 --> 00:05:12,870
you have outages and say one of your

00:05:07,560 --> 00:05:16,830
container hosts goes down and you spin

00:05:12,870 --> 00:05:20,160
up another host with a new memcache the

00:05:16,830 --> 00:05:23,130
instance for example your Drupal

00:05:20,160 --> 00:05:25,130
container needs to discover that the old

00:05:23,130 --> 00:05:29,510
memcache the instance has gone away and

00:05:25,130 --> 00:05:29,510
that there's a new one to replace it

00:05:31,250 --> 00:05:36,270
another thing that gets quite

00:05:33,539 --> 00:05:39,570
interesting quickly is sharing secrets

00:05:36,270 --> 00:05:44,310
between these containers for example if

00:05:39,570 --> 00:05:46,620
you are creating a tool to database the

00:05:44,310 --> 00:05:48,539
database server that creates it needs to

00:05:46,620 --> 00:05:51,960
use the same user account and password

00:05:48,539 --> 00:05:54,840
as your Drupal container that wants to

00:05:51,960 --> 00:05:57,990
connect to this database how do you make

00:05:54,840 --> 00:05:59,639
sure that for example if you change the

00:05:57,990 --> 00:06:02,250
database password and spin up a new

00:05:59,639 --> 00:06:05,510
database that your clutter containers

00:06:02,250 --> 00:06:09,889
will automatically use the new password

00:06:05,510 --> 00:06:13,889
if you are doing this by hand you'll get

00:06:09,889 --> 00:06:16,410
into a situation quickly where things

00:06:13,889 --> 00:06:19,560
don't work anymore because you forgot to

00:06:16,410 --> 00:06:24,030
update a certain setting here or forgot

00:06:19,560 --> 00:06:26,520
to replicate a configuration file to

00:06:24,030 --> 00:06:29,039
another location things like that and

00:06:26,520 --> 00:06:33,879
that's where our castrations

00:06:29,039 --> 00:06:44,259
will take a lot of work of you

00:06:33,879 --> 00:06:48,939
a simple incarnation of this is included

00:06:44,259 --> 00:06:51,819
in the standard docker application suite

00:06:48,939 --> 00:06:55,179
it's called docker compose and it lets

00:06:51,819 --> 00:06:57,749
you spin up multiple containers on a

00:06:55,179 --> 00:07:03,069
single host normally your workstation

00:06:57,749 --> 00:07:08,050
and takes care of all these things like

00:07:03,069 --> 00:07:10,419
links and declaring shared secrets is

00:07:08,050 --> 00:07:13,149
easy because you only have one single

00:07:10,419 --> 00:07:16,059
file where you declare all these things

00:07:13,149 --> 00:07:18,159
since everything is limited to a single

00:07:16,059 --> 00:07:20,469
machine as soon as you start spreading

00:07:18,159 --> 00:07:24,459
out especially if you want to run a

00:07:20,469 --> 00:07:33,389
production infrastructure you'll need

00:07:24,459 --> 00:07:37,659
something like container container is as

00:07:33,389 --> 00:07:40,599
the company behind the application also

00:07:37,659 --> 00:07:43,479
called called container says is an open

00:07:40,599 --> 00:07:46,930
source contain a platform built to

00:07:43,479 --> 00:07:49,990
maximize developed or happiness works on

00:07:46,930 --> 00:07:58,959
any cloud easy to setup simple to use

00:07:49,990 --> 00:08:01,719
and that's why I immediately started to

00:07:58,959 --> 00:08:06,129
like container when I started using it

00:08:01,719 --> 00:08:07,959
and dabbling with it because they keep

00:08:06,129 --> 00:08:11,559
their promise it's easy to setup it's

00:08:07,959 --> 00:08:16,499
simple to use and it still can do a lot

00:08:11,559 --> 00:08:23,319
of stuff so why choose container over

00:08:16,499 --> 00:08:27,999
other alternative container is simple in

00:08:23,319 --> 00:08:30,789
this talk I'll show you how to spin up

00:08:27,999 --> 00:08:35,969
single containers and a whole stack with

00:08:30,789 --> 00:08:39,579
a load balanced Drupal installation and

00:08:35,969 --> 00:08:41,860
if you use the demo script that I've

00:08:39,579 --> 00:08:47,500
made available I showed you the link

00:08:41,860 --> 00:08:51,570
later you could do from 0 to running

00:08:47,500 --> 00:08:51,570
rupal infrastructure in five minutes

00:08:52,590 --> 00:08:58,090
it's inexpensive since it's open-source

00:08:55,090 --> 00:09:00,820
software it's fully featured in the

00:08:58,090 --> 00:09:02,980
sense that it has everything for you to

00:09:00,820 --> 00:09:05,560
go to the next level if you are still

00:09:02,980 --> 00:09:08,980
using the docker command like docker run

00:09:05,560 --> 00:09:13,870
and stuff or even docker compose it'll

00:09:08,980 --> 00:09:16,780
be just an easy step to to get into

00:09:13,870 --> 00:09:19,450
container and start using a multi host

00:09:16,780 --> 00:09:22,570
infrastructure for your containers its

00:09:19,450 --> 00:09:26,430
production ready and people are using it

00:09:22,570 --> 00:09:31,120
in production and it's a can handle

00:09:26,430 --> 00:09:32,770
production load it's secure it supports

00:09:31,120 --> 00:09:34,570
a lot of stuff that you need to run

00:09:32,770 --> 00:09:42,220
secure web applications and it's

00:09:34,570 --> 00:09:44,610
flexible because it is very adaptive you

00:09:42,220 --> 00:09:48,790
can install it in less than one hour

00:09:44,610 --> 00:09:52,240
everything comes bundled of course in

00:09:48,790 --> 00:09:55,150
the form of containers again and it

00:09:52,240 --> 00:09:57,970
simply built on the Yama syntax that

00:09:55,150 --> 00:10:01,089
docker compose uses and it simply

00:09:57,970 --> 00:10:05,200
extends it to be able to run on multiple

00:10:01,089 --> 00:10:09,070
hosts there are alternatives of course

00:10:05,200 --> 00:10:12,460
and you probably know a few of them the

00:10:09,070 --> 00:10:16,120
most prominent is kubernetes or there's

00:10:12,460 --> 00:10:19,450
also things like mazes but when I

00:10:16,120 --> 00:10:20,589
started looking into these things last

00:10:19,450 --> 00:10:26,380
year

00:10:20,589 --> 00:10:28,800
it felt like using these alternatives is

00:10:26,380 --> 00:10:33,400
like if you're if you want to start

00:10:28,800 --> 00:10:35,950
baking cupcakes the recipe would start

00:10:33,400 --> 00:10:38,730
with first let's build an industrial

00:10:35,950 --> 00:10:38,730
oven

00:10:38,930 --> 00:10:50,119
and container isn't like that another

00:10:46,910 --> 00:10:52,430
thing that makes container inexpensive

00:10:50,119 --> 00:10:55,040
is that you can even use let's encrypt

00:10:52,430 --> 00:10:57,529
out of the box so you don't have you

00:10:55,040 --> 00:11:00,429
don't even have to spend money on SSL

00:10:57,529 --> 00:11:02,720
Certificates

00:11:00,429 --> 00:11:05,420
it comes with all the building blocks

00:11:02,720 --> 00:11:07,670
you need it has its own private image

00:11:05,420 --> 00:11:10,309
registry so you don't have to put your

00:11:07,670 --> 00:11:13,179
docker images into the public docker hub

00:11:10,309 --> 00:11:16,790
it comes with a load balancer that's

00:11:13,179 --> 00:11:21,170
amazingly easy to use it supports

00:11:16,790 --> 00:11:25,069
service discovery it has its own secret

00:11:21,170 --> 00:11:27,379
storage where passwords and things like

00:11:25,069 --> 00:11:30,050
that or ssl certificates can be stored

00:11:27,379 --> 00:11:33,679
securely and of course there's an

00:11:30,050 --> 00:11:36,589
unwritten law in IT that all secrets

00:11:33,679 --> 00:11:41,420
storage has to be named vault because

00:11:36,589 --> 00:11:43,720
that makes googling easy and it has its

00:11:41,420 --> 00:11:46,699
own key value store so if you need to

00:11:43,720 --> 00:11:48,740
store information about your

00:11:46,699 --> 00:11:51,649
infrastructure about your application

00:11:48,740 --> 00:11:54,009
stack in a central place it has that as

00:11:51,649 --> 00:11:54,009
well

00:11:55,929 --> 00:12:04,279
container has well-thought-out user

00:12:00,230 --> 00:12:06,439
authentication it uses OAuth for user

00:12:04,279 --> 00:12:09,559
authentication so that the people that

00:12:06,439 --> 00:12:14,779
use container can authenticate against a

00:12:09,559 --> 00:12:18,199
central user registry it supports health

00:12:14,779 --> 00:12:21,470
checks that are both used in load

00:12:18,199 --> 00:12:24,350
balancing so that traffic doesn't go to

00:12:21,470 --> 00:12:27,230
a container that has just gone away and

00:12:24,350 --> 00:12:29,809
it also uses it for scheduling because

00:12:27,230 --> 00:12:32,299
you can define things like I'd like to

00:12:29,809 --> 00:12:35,929
have three Drupal machines or three

00:12:32,299 --> 00:12:38,029
brutal containers and if one of these

00:12:35,929 --> 00:12:40,999
three containers goes down container

00:12:38,029 --> 00:12:46,569
will automatically take care and make

00:12:40,999 --> 00:12:49,910
sure that a another container is spun up

00:12:46,569 --> 00:12:51,860
it supports stateful applications which

00:12:49,910 --> 00:12:55,579
means applications that store

00:12:51,860 --> 00:12:58,370
or file data locally these containers

00:12:55,579 --> 00:13:01,240
aren't as easy to relocate on other

00:12:58,370 --> 00:13:05,839
machines as a stateless container and

00:13:01,240 --> 00:13:10,540
container container does support that it

00:13:05,839 --> 00:13:15,860
has a real-time logging and statistics

00:13:10,540 --> 00:13:19,070
engine built in and it allows to view an

00:13:15,860 --> 00:13:21,800
audit trail so you can see at any time

00:13:19,070 --> 00:13:26,269
who did what to the infrastructure at

00:13:21,800 --> 00:13:31,130
what time that brings us to the tropical

00:13:26,269 --> 00:13:34,910
security all container managed

00:13:31,130 --> 00:13:38,120
containers are located in virtual

00:13:34,910 --> 00:13:40,940
networks that have their own IP address

00:13:38,120 --> 00:13:43,190
space and they're all the traffic

00:13:40,940 --> 00:13:54,800
between the containers is encrypted

00:13:43,190 --> 00:13:58,790
automatically in order to access these

00:13:54,800 --> 00:14:04,630
containers directly container allows you

00:13:58,790 --> 00:14:08,779
to connect via a common VPN software

00:14:04,630 --> 00:14:12,170
where you can access the encrypted

00:14:08,779 --> 00:14:16,519
Network and for example push images to

00:14:12,170 --> 00:14:22,100
the local private registry that's in the

00:14:16,519 --> 00:14:25,940
encrypted network as well this image

00:14:22,100 --> 00:14:28,970
shows the platforms that are support

00:14:25,940 --> 00:14:32,930
supported by container you can run

00:14:28,970 --> 00:14:36,529
container using Amazon Web Services I'm

00:14:32,930 --> 00:14:39,040
using it here the digital ocean you can

00:14:36,529 --> 00:14:41,890
run it on your own on-premise

00:14:39,040 --> 00:14:45,459
infrastructure for example on reddit

00:14:41,890 --> 00:14:50,209
Linux or Ubuntu

00:14:45,459 --> 00:14:51,829
so container is really very flexible in

00:14:50,209 --> 00:14:55,880
terms of infrastructure and it allows

00:14:51,829 --> 00:14:58,970
you to even build hybrid infrastructures

00:14:55,880 --> 00:15:02,589
that run in part for example on AWS and

00:14:58,970 --> 00:15:02,589
in part on premise

00:15:06,110 --> 00:15:15,060
before we get into the practical stuff

00:15:10,460 --> 00:15:18,390
just a few words about myself my name is

00:15:15,060 --> 00:15:24,660
Johan delish I'm chief everything

00:15:18,390 --> 00:15:27,870
officer at fries delight he'd fry steel

00:15:24,660 --> 00:15:29,310
is the German word for freestyle and

00:15:27,870 --> 00:15:31,490
it's pronounced affect the other way

00:15:29,310 --> 00:15:31,490
around

00:15:33,470 --> 00:15:38,940
I've been told that there are people in

00:15:36,570 --> 00:15:42,630
the USA that like to fry everything I

00:15:38,940 --> 00:15:45,330
don't know why you wanted to fry steel

00:15:42,630 --> 00:15:48,600
but that's exactly how our economy name

00:15:45,330 --> 00:15:52,080
is pronounced on Twitter I mean gee whiz

00:15:48,600 --> 00:15:53,820
and you can find my email here so if you

00:15:52,080 --> 00:15:56,430
have any questions about this talk or

00:15:53,820 --> 00:16:01,980
everything else simply give me a shout

00:15:56,430 --> 00:16:04,910
and I'd be happy to respond our main

00:16:01,980 --> 00:16:08,340
product is fry steel box which is a

00:16:04,910 --> 00:16:10,410
managed hosting platform specialized in

00:16:08,340 --> 00:16:13,650
running business-critical Drupal and

00:16:10,410 --> 00:16:19,020
WordPress websites we started in 2010

00:16:13,650 --> 00:16:22,260
with a 100% specialization for Drupal

00:16:19,020 --> 00:16:24,680
and in 2013 we added wordpress support

00:16:22,260 --> 00:16:29,460
as well we limit ourselves to these two

00:16:24,680 --> 00:16:34,500
content management systems because what

00:16:29,460 --> 00:16:36,920
we do is we implement a DevOps workflow

00:16:34,500 --> 00:16:40,140
with our customers so other than with

00:16:36,920 --> 00:16:42,720
common hosting providers you have direct

00:16:40,140 --> 00:16:45,990
access to our engineers and they

00:16:42,720 --> 00:16:48,960
complement the development teams of our

00:16:45,990 --> 00:16:52,160
agency customers during the whole

00:16:48,960 --> 00:16:56,730
application lifecycle you can of course

00:16:52,160 --> 00:17:00,230
simply get a frosty box plan and run

00:16:56,730 --> 00:17:04,350
everything yourself but the magic is

00:17:00,230 --> 00:17:06,780
having a basically a no ops scenario for

00:17:04,350 --> 00:17:08,550
our customers where we take care of

00:17:06,780 --> 00:17:11,459
everything that needs to be done on the

00:17:08,550 --> 00:17:13,649
infrastructure side and developers can

00:17:11,459 --> 00:17:18,350
take care of the application

00:17:13,649 --> 00:17:24,240
one can't go without the other though um

00:17:18,350 --> 00:17:27,539
just this morning we had a conference

00:17:24,240 --> 00:17:31,440
call with a customer who had trouble

00:17:27,539 --> 00:17:33,960
using their database and we did an

00:17:31,440 --> 00:17:41,600
analysis of all the database queries and

00:17:33,960 --> 00:17:44,720
found that in 24 hours their database

00:17:41,600 --> 00:17:47,190
query their their application creates

00:17:44,720 --> 00:17:50,220
billions and billions of database rows

00:17:47,190 --> 00:17:52,409
and we worked out with the customer why

00:17:50,220 --> 00:17:56,549
that was and what to change in their

00:17:52,409 --> 00:17:59,460
drupal application so our database got

00:17:56,549 --> 00:18:03,840
to work much faster again and their

00:17:59,460 --> 00:18:06,360
application as well so we have the

00:18:03,840 --> 00:18:09,809
necessary know-how on the Drupal and

00:18:06,360 --> 00:18:15,200
WordPress internals that we can help our

00:18:09,809 --> 00:18:24,090
customers and really make a 100%

00:18:15,200 --> 00:18:31,019
complete DevOps cycle back to using

00:18:24,090 --> 00:18:35,129
container the basic container setup is

00:18:31,019 --> 00:18:38,720
very simple there's a single container

00:18:35,129 --> 00:18:43,259
server that does all the management and

00:18:38,720 --> 00:18:48,619
then you have the container nodes each

00:18:43,259 --> 00:18:51,659
running the container agent that

00:18:48,619 --> 00:18:55,980
communicates with the container server

00:18:51,659 --> 00:19:02,039
and executes what the server tells them

00:18:55,980 --> 00:19:06,720
to do so the server controls the whole

00:19:02,039 --> 00:19:11,309
platform you get access to the server

00:19:06,720 --> 00:19:14,100
via OAuth you can either use the OAuth

00:19:11,309 --> 00:19:17,730
provider that container runs on

00:19:14,100 --> 00:19:23,070
container I oh cloud container dot IO to

00:19:17,730 --> 00:19:25,710
be precise and you can also use your own

00:19:23,070 --> 00:19:37,530
Roth provider if you

00:19:25,710 --> 00:19:40,200
so what creating a container server is

00:19:37,530 --> 00:19:43,350
easy you simply install the container

00:19:40,200 --> 00:19:46,920
CLI rubygem which provides you with the

00:19:43,350 --> 00:19:50,670
command line client and then you execute

00:19:46,920 --> 00:19:52,980
a command like this here I'm using the

00:19:50,670 --> 00:19:56,750
digital ocean plug-in to spin up

00:19:52,980 --> 00:20:00,420
droplets on digital ocean and I

00:19:56,750 --> 00:20:06,710
basically tell container to start a

00:20:00,420 --> 00:20:09,720
droplet deploy the container server and

00:20:06,710 --> 00:20:15,720
name it container

00:20:09,720 --> 00:20:19,200
DCL use my digital ocean token that I've

00:20:15,720 --> 00:20:24,450
stored in an environment variable use

00:20:19,200 --> 00:20:27,960
the region London one my SSH key the

00:20:24,450 --> 00:20:32,490
droplet will have the size of 1 gigabyte

00:20:27,960 --> 00:20:37,380
and I can use the container cloud for

00:20:32,490 --> 00:20:41,660
authentication so let's see if my

00:20:37,380 --> 00:20:41,660
sacrifice did work out

00:20:44,230 --> 00:21:01,030
looks like I'm still connected so this

00:20:55,810 --> 00:21:02,980
will take a minute and it'll first spin

00:21:01,030 --> 00:21:05,020
up the droplet and then deploy all the

00:21:02,980 --> 00:21:08,160
software that's necessary to run the

00:21:05,020 --> 00:21:11,290
container server which is quite an

00:21:08,160 --> 00:21:14,670
simple thing the container server

00:21:11,290 --> 00:21:17,560
application is written in Ruby and

00:21:14,670 --> 00:21:20,920
consists of the web application on one

00:21:17,560 --> 00:21:25,840
side and a MongoDB instance as its

00:21:20,920 --> 00:21:29,010
back-end and that also makes quite easy

00:21:25,840 --> 00:21:31,380
to run a high availability

00:21:29,010 --> 00:21:35,680
infrastructure by simply using the

00:21:31,380 --> 00:21:37,990
common techniques to get redundancy for

00:21:35,680 --> 00:21:40,950
a web application and get redundancy on

00:21:37,990 --> 00:21:40,950
the MongoDB side

00:22:11,550 --> 00:22:23,000
come on these to the ocean no as long as

00:22:19,680 --> 00:22:26,250
the thing is spinning it's not the Wi-Fi

00:22:23,000 --> 00:22:35,580
connected to our mobile data so I'm not

00:22:26,250 --> 00:22:39,930
dependent on the Wi-Fi a to command to

00:22:35,580 --> 00:22:41,670
be honest first of all install the CLI

00:22:39,930 --> 00:22:45,240
so it simply generally installed

00:22:41,670 --> 00:22:50,190
container - CLI and I had to set the

00:22:45,240 --> 00:22:53,010
digitalocean token in the environment

00:22:50,190 --> 00:22:56,940
variable and that was it um and I put

00:22:53,010 --> 00:22:59,730
the demo script on github so you can

00:22:56,940 --> 00:23:06,110
take a look at it later so now we have

00:22:59,730 --> 00:23:08,520
our master server and as you see it's

00:23:06,110 --> 00:23:17,180
created the droplet then it installed

00:23:08,520 --> 00:23:17,180
the software and also created a grid

00:23:22,900 --> 00:23:35,630
grades are separate groups of container

00:23:28,520 --> 00:23:40,130
nodes of host machines and each grid has

00:23:35,630 --> 00:23:41,360
its own encrypted ops sorry encrypted

00:23:40,130 --> 00:23:45,500
overlay Network

00:23:41,360 --> 00:23:49,550
so actually each container grid uses the

00:23:45,500 --> 00:23:52,460
ten dot 81 IP address space I think if I

00:23:49,550 --> 00:23:55,130
recall that correctly but since

00:23:52,460 --> 00:23:58,640
everything is contained in this virtual

00:23:55,130 --> 00:24:00,920
network they don't get in conflict with

00:23:58,640 --> 00:24:04,010
with each other so you can run as many

00:24:00,920 --> 00:24:06,470
grids as you like and each grid is

00:24:04,010 --> 00:24:11,330
basically its own self-contained

00:24:06,470 --> 00:24:16,250
universe and you can if you like connect

00:24:11,330 --> 00:24:20,990
to each grid via VPN the container see

00:24:16,250 --> 00:24:24,050
LRU has a VPN sub command that spits out

00:24:20,990 --> 00:24:28,430
an Open VPN configuration that you can

00:24:24,050 --> 00:24:31,160
use right out out of the box so if you

00:24:28,430 --> 00:24:33,440
don't want to use the test grid that has

00:24:31,160 --> 00:24:38,030
been created automatically you can use

00:24:33,440 --> 00:24:40,790
the container grid command to create

00:24:38,030 --> 00:24:44,870
your own and to tell container that all

00:24:40,790 --> 00:24:48,860
subsequent commands are will be

00:24:44,870 --> 00:24:51,290
associated with this grid and I also can

00:24:48,860 --> 00:24:54,680
tell container what the initial size of

00:24:51,290 --> 00:24:59,770
the grid will be in a size of two is the

00:24:54,680 --> 00:25:05,540
minimum required size because container

00:24:59,770 --> 00:25:09,050
uses a quorum based database for both

00:25:05,540 --> 00:25:11,240
service discovery where all services

00:25:09,050 --> 00:25:14,960
that come up get registered and can be

00:25:11,240 --> 00:25:19,040
queried and for the key value store and

00:25:14,960 --> 00:25:25,730
in order to have always a quorum you

00:25:19,040 --> 00:25:27,440
need to have at least three nodes and in

00:25:25,730 --> 00:25:29,810
that case if you start with two nodes

00:25:27,440 --> 00:25:32,720
you'll have to load and the container

00:25:29,810 --> 00:25:34,450
server itself and that gives you the

00:25:32,720 --> 00:25:47,279
minimum

00:25:34,450 --> 00:25:47,279
of three nodes in the quorum come in

00:25:48,989 --> 00:26:06,850
yeah the question was is SVD run on the

00:25:54,159 --> 00:26:15,070
master as well it is yeah that's just

00:26:06,850 --> 00:26:17,730
the name of the grid that's arbitrary so

00:26:15,070 --> 00:26:17,730
let's see

00:26:26,720 --> 00:26:34,370
so that was pretty fast I simply spin up

00:26:30,530 --> 00:26:38,360
another grid called demo grid and with

00:26:34,370 --> 00:26:42,760
container great use I've told the CLR

00:26:38,360 --> 00:26:42,760
here to use that great from here on

00:26:44,890 --> 00:26:50,780
let's get to the nodes all these nodes

00:26:48,290 --> 00:26:54,020
are discovered automatically as soon as

00:26:50,780 --> 00:26:57,530
you spin up a new node a new container

00:26:54,020 --> 00:26:58,940
agent it will automatically connect to

00:26:57,530 --> 00:27:02,780
the container

00:26:58,940 --> 00:27:05,870
server and it will keep this the network

00:27:02,780 --> 00:27:08,800
connection up so container doesn't

00:27:05,870 --> 00:27:12,460
require open firewall ports on each node

00:27:08,800 --> 00:27:16,460
all the nodes simply need to be able to

00:27:12,460 --> 00:27:24,530
connect to the container server and the

00:27:16,460 --> 00:27:26,660
API that runs on it it's easy to create

00:27:24,530 --> 00:27:31,730
nodes as well there's another command

00:27:26,660 --> 00:27:34,340
container node create in this case I'm

00:27:31,730 --> 00:27:39,680
using digitalocean again with my token

00:27:34,340 --> 00:27:47,060
and the essential details that I need to

00:27:39,680 --> 00:27:49,190
use let's see how that works out in this

00:27:47,060 --> 00:27:51,520
case I'm spinning up two nodes one after

00:27:49,190 --> 00:27:51,520
each other

00:28:20,499 --> 00:28:28,730
yeah I've created a topic on page on the

00:28:25,490 --> 00:28:32,960
feisty box.com website where you'll find

00:28:28,730 --> 00:28:37,070
a link to my session page on for topic

00:28:32,960 --> 00:28:40,009
on where you also can download the

00:28:37,070 --> 00:28:43,700
slides and have a link to get up where

00:28:40,009 --> 00:28:46,249
I've published the demo script that I'm

00:28:43,700 --> 00:28:48,830
using here just to avoid typing errors

00:28:46,249 --> 00:28:54,309
of course the token that displayed here

00:28:48,830 --> 00:28:57,440
isn't my real digitalocean token I

00:28:54,309 --> 00:28:58,340
accidentally hard hard coded the

00:28:57,440 --> 00:29:02,059
digitalocean

00:28:58,340 --> 00:29:06,499
token in my first instance of the demo

00:29:02,059 --> 00:29:08,480
script but I've changed that to use the

00:29:06,499 --> 00:29:10,940
environment variable and I've made

00:29:08,480 --> 00:29:12,289
another commit on github so the token

00:29:10,940 --> 00:29:15,100
thing of course as everyone knows is

00:29:12,289 --> 00:29:15,100
resolved

00:29:15,490 --> 00:29:21,610
no need to look at the previous commit

00:29:31,629 --> 00:29:40,269
so that was know number one let's get

00:29:35,690 --> 00:29:43,960
node number two added to the grid and

00:29:40,269 --> 00:29:43,960
we'll be good to go

00:30:00,040 --> 00:30:03,550
by the way you might have noticed that I

00:30:01,780 --> 00:30:07,020
have a very confusing accent that's

00:30:03,550 --> 00:30:07,020
because I'm a German living in Ireland

00:30:17,600 --> 00:30:20,320
come on

00:30:34,230 --> 00:30:41,790
so just go to the next slide that is

00:30:38,520 --> 00:30:42,660
working in the background so we are all

00:30:41,790 --> 00:30:45,330
good to go

00:30:42,660 --> 00:30:48,630
and the first thing that we can use now

00:30:45,330 --> 00:30:51,630
is container services a service is

00:30:48,630 --> 00:30:54,000
basically an abstract name for a

00:30:51,630 --> 00:30:57,210
container image that runs somewhere in

00:30:54,000 --> 00:30:59,730
our infrastructure so you can define a

00:30:57,210 --> 00:31:02,550
service in a simple llaman file and

00:30:59,730 --> 00:31:04,440
that's where it's container is very

00:31:02,550 --> 00:31:07,020
similar to docker compose and it simply

00:31:04,440 --> 00:31:09,350
build on that syntax you can define

00:31:07,020 --> 00:31:12,720
which container image you'd like to use

00:31:09,350 --> 00:31:16,380
you can define things like volumes for

00:31:12,720 --> 00:31:19,200
file storage you can limit resources for

00:31:16,380 --> 00:31:22,980
example how much memory the container is

00:31:19,200 --> 00:31:27,150
supposed to use you define if the

00:31:22,980 --> 00:31:30,210
service is in some kind connected to

00:31:27,150 --> 00:31:32,490
another service you can define

00:31:30,210 --> 00:31:35,640
environment variables that are going to

00:31:32,490 --> 00:31:37,440
be used by the container image you can

00:31:35,640 --> 00:31:41,840
define secrets that's something that

00:31:37,440 --> 00:31:44,280
container adds and the registration

00:31:41,840 --> 00:31:46,830
happens automatically as soon as you

00:31:44,280 --> 00:31:50,610
start a service it gets registered with

00:31:46,830 --> 00:31:51,540
the central database and other services

00:31:50,610 --> 00:31:53,730
can query

00:31:51,540 --> 00:32:03,240
I'd like to connect to a service named

00:31:53,730 --> 00:32:07,110
my sequel where do I have to ask you

00:32:03,240 --> 00:32:12,020
also define the deployment strategy that

00:32:07,110 --> 00:32:15,810
can be one of three variants it's H a

00:32:12,020 --> 00:32:19,260
demon or random random simply takes the

00:32:15,810 --> 00:32:25,310
container and spins it spins it up on a

00:32:19,260 --> 00:32:28,380
random node the high-availability

00:32:25,310 --> 00:32:32,670
setup is where you can define okay I'd

00:32:28,380 --> 00:32:36,570
like three instances of this container

00:32:32,670 --> 00:32:41,580
at any time and daemon will install the

00:32:36,570 --> 00:32:45,240
container image on all nodes that's very

00:32:41,580 --> 00:32:47,400
handy for example for infrastructure

00:32:45,240 --> 00:32:50,700
services if you'd like for example

00:32:47,400 --> 00:32:53,670
run a monitoring application on each of

00:32:50,700 --> 00:32:56,160
your nodes you simply tell container to

00:32:53,670 --> 00:32:59,610
run it to deploy deploy it via the

00:32:56,160 --> 00:33:01,380
daemon strategy and as soon as you spin

00:32:59,610 --> 00:33:03,059
up a new node you'll have another

00:33:01,380 --> 00:33:07,440
instance of the monitoring service

00:33:03,059 --> 00:33:09,900
running on it you can define affinities

00:33:07,440 --> 00:33:17,130
to other services so you can tell for

00:33:09,900 --> 00:33:19,830
example always run my sequel on the same

00:33:17,130 --> 00:33:23,610
host say memcache D or something like

00:33:19,830 --> 00:33:26,670
that and in order to have high

00:33:23,610 --> 00:33:28,740
availability you can even define a port

00:33:26,670 --> 00:33:31,760
to wait for so if you spin up the total

00:33:28,740 --> 00:33:33,900
container for example you can say okay

00:33:31,760 --> 00:33:37,830
starting the container isn't quite

00:33:33,900 --> 00:33:41,309
enough I expect this container also to

00:33:37,830 --> 00:33:43,650
answer to respond on port 80 for example

00:33:41,309 --> 00:33:46,970
and only if that's the case I consider

00:33:43,650 --> 00:33:50,550
this container as successfully started

00:33:46,970 --> 00:33:53,040
and you can define health checks that

00:33:50,550 --> 00:33:57,150
will be executed periodic periodically

00:33:53,040 --> 00:34:00,870
and for can for example be used for load

00:33:57,150 --> 00:34:03,480
balancing so that's an example for a

00:34:00,870 --> 00:34:05,610
stateless service it's very similar to

00:34:03,480 --> 00:34:07,860
the run-of-the-mill docker run command

00:34:05,610 --> 00:34:11,580
you'll simply say okay I'd like to use

00:34:07,860 --> 00:34:16,040
the latest image for nginx and use that

00:34:11,580 --> 00:34:19,889
as the service also called nginx and

00:34:16,040 --> 00:34:23,429
please map the port 80 of the container

00:34:19,889 --> 00:34:27,750
to port 80 of its host so I can talk to

00:34:23,429 --> 00:34:32,370
the container and container will

00:34:27,750 --> 00:34:33,240
probably spin it up somewhere so let's

00:34:32,370 --> 00:34:39,270
see how that works

00:34:33,240 --> 00:34:41,790
I hope we are already working so here's

00:34:39,270 --> 00:34:44,310
a list of our two nodes just to make

00:34:41,790 --> 00:34:45,860
sure okay there are two nodes both

00:34:44,310 --> 00:34:50,419
running on digitalocean

00:34:45,860 --> 00:34:50,419
in the London data center

00:34:51,790 --> 00:35:02,050
and now we are creating the service that

00:34:59,430 --> 00:35:06,040
didn't spin up a container it's just the

00:35:02,050 --> 00:35:09,250
service definition and with the

00:35:06,040 --> 00:35:12,160
following command I'll actually deploy a

00:35:09,250 --> 00:35:14,610
container that will be spun up and can

00:35:12,160 --> 00:35:14,610
be talked to

00:35:24,760 --> 00:35:34,300
that's that and the CLI tells me I

00:35:27,750 --> 00:35:36,880
created this container on node one if I

00:35:34,300 --> 00:35:40,000
want to see more details about this

00:35:36,880 --> 00:35:44,350
service I can use the container service

00:35:40,000 --> 00:35:47,440
show nginx command and it'll list a lot

00:35:44,350 --> 00:35:52,030
of details for example in the lower part

00:35:47,440 --> 00:35:55,570
on which nodes the service is running

00:35:52,030 --> 00:35:59,500
and what the public IP address is so if

00:35:55,570 --> 00:36:03,070
you would try to connect to 138 and so

00:35:59,500 --> 00:36:05,850
on you would be talking to our new nginx

00:36:03,070 --> 00:36:05,850
instance

00:36:13,979 --> 00:36:19,920
with the stateful option I can spin up

00:36:17,619 --> 00:36:24,459
another container and the only

00:36:19,920 --> 00:36:27,789
difference would be that once container

00:36:24,459 --> 00:36:31,209
has chosen a node for this service

00:36:27,789 --> 00:36:33,459
it'll keep using this node even if I

00:36:31,209 --> 00:36:36,190
shut down the container and two days

00:36:33,459 --> 00:36:38,619
later I'll spin it up again I can be

00:36:36,190 --> 00:36:42,400
sure that it will be created on the same

00:36:38,619 --> 00:36:47,979
node again because container expects the

00:36:42,400 --> 00:36:52,719
container to use a file volume on this

00:36:47,979 --> 00:36:54,670
node and if the container would be spun

00:36:52,719 --> 00:36:58,809
up on another node it would lose all its

00:36:54,670 --> 00:37:03,599
data because the file data stored in

00:36:58,809 --> 00:37:03,599
volumes doesn't travel via instances

00:37:13,420 --> 00:37:19,809
it's easy to scale up a service so if I

00:37:16,200 --> 00:37:23,529
for example would like to grow from one

00:37:19,809 --> 00:37:32,380
single nginx instances to three I simply

00:37:23,529 --> 00:37:37,210
use this command so that's the public IP

00:37:32,380 --> 00:37:41,829
address again and now I'm scaling nginx

00:37:37,210 --> 00:37:48,670
up to two and then automatically show

00:37:41,829 --> 00:37:54,309
the details and what we are going to see

00:37:48,670 --> 00:37:59,170
is that nginx isn't will now be on two

00:37:54,309 --> 00:38:01,710
nodes and available on two public IP

00:37:59,170 --> 00:38:01,710
addresses

00:38:08,720 --> 00:38:21,690
let's stop that right away so we can go

00:38:13,560 --> 00:38:24,530
on to more interesting things things get

00:38:21,690 --> 00:38:30,030
interesting when you start connecting

00:38:24,530 --> 00:38:33,800
services and these groups of connected

00:38:30,030 --> 00:38:37,620
services are called container stacks

00:38:33,800 --> 00:38:39,810
there are sets of services defined in a

00:38:37,620 --> 00:38:43,890
Yama file and this Yama file will be

00:38:39,810 --> 00:38:47,190
versioned so you can update your stack

00:38:43,890 --> 00:38:53,490
definition and work with different

00:38:47,190 --> 00:38:56,310
revisions of this each stack gets its

00:38:53,490 --> 00:39:00,000
own sub domain local in the grid it's

00:38:56,310 --> 00:39:05,310
running in which makes addressing parts

00:39:00,000 --> 00:39:13,520
of the stack quite easy so let's take a

00:39:05,310 --> 00:39:17,640
look at sorry yeah so if you have a

00:39:13,520 --> 00:39:21,570
stack defined in say here The Container

00:39:17,640 --> 00:39:24,120
dot Yama file you can install this stack

00:39:21,570 --> 00:39:26,910
definition and name it

00:39:24,120 --> 00:39:29,280
for example Drupal and let's take a

00:39:26,910 --> 00:39:31,170
closer look at that definition the Yama

00:39:29,280 --> 00:39:34,890
file will be in the github repository as

00:39:31,170 --> 00:39:38,330
well so it starts with a preamble I've

00:39:34,890 --> 00:39:44,070
called this stack examples Drupal and

00:39:38,330 --> 00:39:48,240
gave it version 1 and then I start

00:39:44,070 --> 00:39:52,110
listing a number of variables that I'll

00:39:48,240 --> 00:39:56,760
be using during this file and that's

00:39:52,110 --> 00:39:59,730
quite interesting because here I'm using

00:39:56,760 --> 00:40:04,110
the container vault for secret

00:39:59,730 --> 00:40:08,130
management and it's amazingly simple I

00:40:04,110 --> 00:40:10,770
am defining in this case two variables

00:40:08,130 --> 00:40:14,490
called one called Drupal my sequel root

00:40:10,770 --> 00:40:20,250
and a bit below Drupal my sequel

00:40:14,490 --> 00:40:24,180
password both are of type string

00:40:20,250 --> 00:40:29,520
and I can tell container where to get

00:40:24,180 --> 00:40:33,450
the value for this variable and where to

00:40:29,520 --> 00:40:36,390
store the value of the variable in the

00:40:33,450 --> 00:40:39,930
case of from where I get the value of

00:40:36,390 --> 00:40:45,750
the variable from I can tell a container

00:40:39,930 --> 00:40:48,180
to use two alternatives I prefer getting

00:40:45,750 --> 00:40:51,119
the value of the variable from the

00:40:48,180 --> 00:40:55,560
container vault with the key Drupal my

00:40:51,119 --> 00:40:57,480
sequel route but if it's not there for

00:40:55,560 --> 00:41:01,849
example because I'm just starting to

00:40:57,480 --> 00:41:04,470
show people at Rubicon how this works it

00:41:01,849 --> 00:41:07,470
alternatively fall back to a random

00:41:04,470 --> 00:41:13,500
string with a length of 32 characters

00:41:07,470 --> 00:41:16,890
and regardless of where I got the value

00:41:13,500 --> 00:41:21,180
for this variable from I store it in the

00:41:16,890 --> 00:41:23,010
walls under the same name and with the

00:41:21,180 --> 00:41:25,950
second variable I'm doing exactly the

00:41:23,010 --> 00:41:29,070
same so that makes things very easy I

00:41:25,950 --> 00:41:30,660
simply take on say container well I'd

00:41:29,070 --> 00:41:33,780
like to define a variable Drupal my

00:41:30,660 --> 00:41:35,640
sequel root you should be able to find

00:41:33,780 --> 00:41:39,000
it in the world under the same name if

00:41:35,640 --> 00:41:40,770
not simply generate a value and then

00:41:39,000 --> 00:41:43,460
make sure to store it in the world so we

00:41:40,770 --> 00:41:43,460
can get it next time

00:41:48,200 --> 00:41:56,460
and the services section is where we use

00:41:52,890 --> 00:42:01,230
these variables I'm defining a service

00:41:56,460 --> 00:42:03,810
Drupal using a image I'm using the

00:42:01,230 --> 00:42:06,570
official Drupal image in version 8.2 I

00:42:03,810 --> 00:42:12,210
define it as stateful because I'm using

00:42:06,570 --> 00:42:16,080
a number of volumes I'll expose port 80

00:42:12,210 --> 00:42:18,330
I'll define a an environment variable

00:42:16,080 --> 00:42:21,450
named my single user with the value

00:42:18,330 --> 00:42:24,870
Drupal and I'm using a number of Secrets

00:42:21,450 --> 00:42:29,880
and that case the Drupal my sequel

00:42:24,870 --> 00:42:32,250
password secret and stop that in the

00:42:29,880 --> 00:42:38,400
environment variable my sequel password

00:42:32,250 --> 00:42:40,710
and then a number of volumes so the more

00:42:38,400 --> 00:42:46,050
important part of my application will be

00:42:40,710 --> 00:42:49,320
exposed in single volumes and then I'll

00:42:46,050 --> 00:42:55,010
add the other necessary part the my

00:42:49,320 --> 00:42:57,810
sequel service with the MariaDB image

00:42:55,010 --> 00:43:02,880
equally stateful a few environment

00:42:57,810 --> 00:43:04,680
variables as well these should be in

00:43:02,880 --> 00:43:06,030
sync with the variables I'm using in

00:43:04,680 --> 00:43:07,730
Drupal otherwise that two containers

00:43:06,030 --> 00:43:10,710
won't be able to talk to each other and

00:43:07,730 --> 00:43:13,820
to secret that are necessary to spin up

00:43:10,710 --> 00:43:13,820
the necessary databases

00:43:17,619 --> 00:43:25,720
let's see I okay let's hop right to

00:43:22,569 --> 00:43:27,759
load-balancing if I'd like to run more

00:43:25,720 --> 00:43:31,420
than one duper container and have load

00:43:27,759 --> 00:43:34,210
balancing there are only a few minor

00:43:31,420 --> 00:43:39,130
changes I need to make to my definition

00:43:34,210 --> 00:43:41,349
I add a new service called rule lb that

00:43:39,130 --> 00:43:45,339
uses the load balancer image from

00:43:41,349 --> 00:43:50,170
container and uses port 80 as well I'll

00:43:45,339 --> 00:43:52,359
add an instances value to Drupal in that

00:43:50,170 --> 00:43:55,499
case I'm spinning up two instances and

00:43:52,359 --> 00:43:58,660
then I have to define a few additional

00:43:55,499 --> 00:44:01,660
environment variables that tell the

00:43:58,660 --> 00:44:05,019
container to automatically connect or

00:44:01,660 --> 00:44:07,390
other the load balancer container will

00:44:05,019 --> 00:44:10,450
automatically connect to my dutiful

00:44:07,390 --> 00:44:14,619
containers in that case that's happening

00:44:10,450 --> 00:44:18,569
because I link these two services via

00:44:14,619 --> 00:44:18,569
the links statement

00:44:22,740 --> 00:44:28,960
these are official these images I'm

00:44:26,020 --> 00:44:31,930
using our official docker images that

00:44:28,960 --> 00:44:35,349
will be pulled from the docker hub these

00:44:31,930 --> 00:44:37,290
they are public so let's see how that

00:44:35,349 --> 00:44:41,290
works

00:44:37,290 --> 00:44:47,079
first of all I'm deploying my stack

00:44:41,290 --> 00:44:50,950
definition and since I'm using the

00:44:47,079 --> 00:44:54,910
deploy option to the install command it

00:44:50,950 --> 00:44:58,329
will not only store the stack definition

00:44:54,910 --> 00:45:00,579
it also goes right to deploying it and

00:44:58,329 --> 00:45:03,000
that's why it starts to deploy the load

00:45:00,579 --> 00:45:03,000
balancer

00:45:13,170 --> 00:45:17,910
now it's deploying the My Secret Service

00:45:25,800 --> 00:45:30,290
and now it's deploying my Drupal

00:45:27,870 --> 00:45:30,290
containers

00:46:07,190 --> 00:46:10,190
yeah

00:46:36,820 --> 00:46:42,910
that's a great question I've actually

00:46:39,250 --> 00:46:47,740
left that out yet yeah the question is

00:46:42,910 --> 00:46:52,000
so if I start off sorry start up a few

00:46:47,740 --> 00:46:55,000
nodes they get somehow added to the load

00:46:52,000 --> 00:46:57,700
balancer and if at a later time I spin

00:46:55,000 --> 00:46:59,680
up another node will that also be

00:46:57,700 --> 00:47:02,830
automatically added to the load

00:46:59,680 --> 00:47:06,910
balancing and the answer is yes what

00:47:02,830 --> 00:47:09,970
this load balancer image does is go

00:47:06,910 --> 00:47:13,720
through all containers that are linking

00:47:09,970 --> 00:47:16,030
to you look for these these special

00:47:13,720 --> 00:47:16,660
environment variables that tell you how

00:47:16,030 --> 00:47:22,300
to behave

00:47:16,660 --> 00:47:26,560
and then do it and container is using H

00:47:22,300 --> 00:47:30,550
a proxy for that and the H a proxy is

00:47:26,560 --> 00:47:33,130
actually talking to the SCD and as soon

00:47:30,550 --> 00:47:35,050
as a new node spins up linking to the

00:47:33,130 --> 00:47:38,380
load balancer it'll get all the

00:47:35,050 --> 00:47:40,710
necessary details from SCD and add that

00:47:38,380 --> 00:47:44,350
to its load balancer configuration

00:47:40,710 --> 00:47:47,170
reload the configuration and within a

00:47:44,350 --> 00:47:50,350
fraction of second a new node will be in

00:47:47,170 --> 00:47:52,720
load balancing and if you have defined

00:47:50,350 --> 00:47:55,180
health checks they will also be applied

00:47:52,720 --> 00:47:57,430
so for example if a container doesn't

00:47:55,180 --> 00:47:59,320
answer for five seconds it'll

00:47:57,430 --> 00:48:00,600
automatically be removed from the load

00:47:59,320 --> 00:48:03,310
balancing

00:48:00,600 --> 00:48:05,290
that's quite ingenious and it's really

00:48:03,310 --> 00:48:07,540
as simple as it looks there's nothing I

00:48:05,290 --> 00:48:10,120
have done in the background or isn't

00:48:07,540 --> 00:48:14,050
necessary now that everything is

00:48:10,120 --> 00:48:16,660
deployed we have a Drupal cluster of in

00:48:14,050 --> 00:48:20,280
that case two nodes behind a load

00:48:16,660 --> 00:48:23,950
balancer and both Drupal nodes

00:48:20,280 --> 00:48:29,170
automatically talking to the my sequel

00:48:23,950 --> 00:48:31,390
instance and if you like here are the

00:48:29,170 --> 00:48:35,200
different services so we see two drupal

00:48:31,390 --> 00:48:38,740
instances one my sequel and what to

00:48:35,200 --> 00:48:41,050
Drupal lb instances even forever I think

00:48:38,740 --> 00:48:43,240
I've installed that load balancer in the

00:48:41,050 --> 00:48:45,430
daemon configuration so it's

00:48:43,240 --> 00:48:49,360
automatically spun up on all nodes I'll

00:48:45,430 --> 00:48:50,260
ever have so I might be able to do

00:48:49,360 --> 00:48:51,880
something to

00:48:50,260 --> 00:48:57,760
make even my load-balanced are redundant

00:48:51,880 --> 00:49:00,550
and if you like connect to one of these

00:48:57,760 --> 00:49:03,220
public IP addresses which are the IP

00:49:00,550 --> 00:49:08,230
addresses of the load balancers and

00:49:03,220 --> 00:49:11,610
you'll be talking to a Drupal 8.2 of

00:49:08,230 --> 00:49:11,610
course it's a newly installed Drupal

00:49:20,580 --> 00:49:39,550
could you repeat the question please yes

00:49:26,710 --> 00:49:42,010
it is the same file system on all the

00:49:39,550 --> 00:49:45,220
nodes so I can actually spin up my

00:49:42,010 --> 00:49:48,250
Drupal containers anywhere I want and I

00:49:45,220 --> 00:49:50,620
find the same files at the moment I'm

00:49:48,250 --> 00:49:53,800
simply deploying them as stateful but

00:49:50,620 --> 00:49:56,410
that won't help me because files written

00:49:53,800 --> 00:50:00,930
by one node won't be accessible by the

00:49:56,410 --> 00:50:02,460
other node so that setup isn't actually

00:50:00,930 --> 00:50:07,330
production-ready

00:50:02,460 --> 00:50:10,320
what you can do is use a central

00:50:07,330 --> 00:50:13,410
filesystem NFS or something else a

00:50:10,320 --> 00:50:18,910
distributed file system and then in

00:50:13,410 --> 00:50:20,800
import that as volumes container won't

00:50:18,910 --> 00:50:24,130
know anything it'll simply use these

00:50:20,800 --> 00:50:26,080
paths use defined in the domicile and

00:50:24,130 --> 00:50:30,720
you'll have to manage the shared file

00:50:26,080 --> 00:50:34,180
system yourself I'm pretty sure that

00:50:30,720 --> 00:50:39,220
sometime this year container the company

00:50:34,180 --> 00:50:42,780
will add shared file system or volume

00:50:39,220 --> 00:50:42,780
migration or something like that

00:50:48,240 --> 00:50:53,099
you can use these these container images

00:50:50,490 --> 00:50:54,420
to build a replication setup is my

00:50:53,099 --> 00:50:58,410
sequel but you will have to do that

00:50:54,420 --> 00:51:01,950
yourself container doesn't provide you

00:50:58,410 --> 00:51:04,430
with anything like that so just a quick

00:51:01,950 --> 00:51:08,280
look at SSL because that's equally easy

00:51:04,430 --> 00:51:11,400
you can use let's encrypt you simply say

00:51:08,280 --> 00:51:15,000
okay I'd like to register at let's

00:51:11,400 --> 00:51:17,760
encrypt with my email address and I'd

00:51:15,000 --> 00:51:20,700
like to authorize to get a certificate

00:51:17,760 --> 00:51:24,540
for WWE example.com

00:51:20,700 --> 00:51:27,060
I get the necessary DNS authentication

00:51:24,540 --> 00:51:30,480
details that I'll have to add in a DNS

00:51:27,060 --> 00:51:32,700
record and as soon as that propagated I

00:51:30,480 --> 00:51:37,530
can use container certificate get and

00:51:32,700 --> 00:51:39,750
I'll get my certificate that certificate

00:51:37,530 --> 00:51:42,780
will be automatically stored in the

00:51:39,750 --> 00:51:45,630
container vault and then can be used

00:51:42,780 --> 00:51:48,720
with the container load balancer simply

00:51:45,630 --> 00:51:50,760
by adding these additional settings now

00:51:48,720 --> 00:51:57,300
the load balancer should be talking on

00:51:50,760 --> 00:51:59,040
443 and I'm using the SSL certs

00:51:57,300 --> 00:52:00,960
environment variable which will

00:51:59,040 --> 00:52:04,890
automatically be used by the load

00:52:00,960 --> 00:52:08,339
balancer image and I in that case I'm

00:52:04,890 --> 00:52:11,430
using the value behind le certificate

00:52:08,339 --> 00:52:13,560
underscore domain name underscore bundle

00:52:11,430 --> 00:52:16,410
that's the default name that container

00:52:13,560 --> 00:52:22,220
will store the certificate under and I'm

00:52:16,410 --> 00:52:22,220
good to go it is

00:52:22,490 --> 00:52:27,140
that's why so lettin trip is free you

00:52:25,369 --> 00:52:29,240
can use that out of the box without

00:52:27,140 --> 00:52:37,280
paying anything and you get a valid

00:52:29,240 --> 00:52:39,680
certificate and I don't think let

00:52:37,280 --> 00:52:46,060
encrypt support wild card you'll have to

00:52:39,680 --> 00:52:46,060
create certificates for each for each

00:52:47,020 --> 00:53:00,410
distinct certificate so the projector is

00:52:51,500 --> 00:53:05,920
giving not looks like it but just to

00:53:00,410 --> 00:53:05,920
summarize container really is simple

00:53:07,060 --> 00:53:16,609
it's inexpensive open source and let's

00:53:11,180 --> 00:53:19,510
encrypt it's full-featured regard except

00:53:16,609 --> 00:53:23,330
and share file system

00:53:19,510 --> 00:53:25,730
it's production-ready it's secure it's

00:53:23,330 --> 00:53:28,099
flexible and most of all it's really

00:53:25,730 --> 00:53:30,260
worth a try because it doesn't cost you

00:53:28,099 --> 00:53:33,020
anything in terms of money and within

00:53:30,260 --> 00:53:35,680
one or two hours you'll have a feeling

00:53:33,020 --> 00:53:40,250
if container is something for you

00:53:35,680 --> 00:53:45,940
so if you'd like to take another look at

00:53:40,250 --> 00:53:49,040
my slides simply go to www.facebook.com

00:53:45,940 --> 00:53:54,170
/ DrupalCon

00:53:49,040 --> 00:53:56,440
dot HTML and there will be links to

00:53:54,170 --> 00:53:56,440
everything

00:53:58,200 --> 00:54:06,370

YouTube URL: https://www.youtube.com/watch?v=B6O04boY3js


