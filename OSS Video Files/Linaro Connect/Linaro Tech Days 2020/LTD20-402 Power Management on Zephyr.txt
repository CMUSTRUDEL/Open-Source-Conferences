Title: LTD20-402 Power Management on Zephyr
Publication date: 2020-04-09
Playlist: Linaro Tech Days 2020
Description: 
	Over the past few months, Vincent Wan has been working on adding power

management support to TI's CC1352R1 on Zephyr. In this session, he talks about the things he has learnt.


Speaker: Vincent Wan, Texas Instruments


Vincent Wan is a Linaro assignee from Texas Instruments on the team. He has been working on adding support for TI MCU platforms to the RTOS, with a recent focus on Power Management.


You can view the presentation for this session here:
https://connect.linaro.org/resources/ltd20/ltd20-402/
Captions: 
	00:00:00,589 --> 00:00:08,450
and we are recording so welcome everyone

00:00:04,770 --> 00:00:12,330
today we have Vincent van from TI

00:00:08,450 --> 00:00:14,429
presenting his session and talk on power

00:00:12,330 --> 00:00:17,690
management on Zephyr take it away

00:00:14,429 --> 00:00:21,300
Vincent Thank You Vicki

00:00:17,690 --> 00:00:24,619
so hi everyone today I'd like to talk to

00:00:21,300 --> 00:00:28,680
you about power measurement on center

00:00:24,619 --> 00:00:31,050
over the past few months I've been

00:00:28,680 --> 00:00:36,960
working towards having power management

00:00:31,050 --> 00:00:39,809
support for the PI since 1952 on etc and

00:00:36,960 --> 00:00:45,149
like to share few some things I'm

00:00:39,809 --> 00:00:49,440
learning so receptor is a real-time OS

00:00:45,149 --> 00:00:52,710
that four focuses on connected resource

00:00:49,440 --> 00:00:55,079
constrained devices and resource

00:00:52,710 --> 00:00:57,149
constraint here includes constraint on

00:00:55,079 --> 00:01:01,530
empowerment power consumption these

00:00:57,149 --> 00:01:03,960
medications and etc has an existing

00:01:01,530 --> 00:01:12,299
power management subsystem to deal with

00:01:03,960 --> 00:01:15,090
that and I saw several 2.20 the here the

00:01:12,299 --> 00:01:19,049
features that I supported the mainly

00:01:15,090 --> 00:01:22,500
divided into two separate knobs if you

00:01:19,049 --> 00:01:26,100
want there's the system punishment and

00:01:22,500 --> 00:01:29,310
the Vice power management under system

00:01:26,100 --> 00:01:32,579
punishment the focus there is to define

00:01:29,310 --> 00:01:37,290
sleep and deep sleep State they'll be

00:01:32,579 --> 00:01:39,479
entered when the CPU is idle and how the

00:01:37,290 --> 00:01:43,560
system decides which stated going to is

00:01:39,479 --> 00:01:48,210
the a partnership policy function that

00:01:43,560 --> 00:01:52,200
is residency based meaning that it would

00:01:48,210 --> 00:01:54,390
take the state that that would be the

00:01:52,200 --> 00:01:57,930
highest latency that would match up with

00:01:54,390 --> 00:02:02,729
a basically the amount of time through

00:01:57,930 --> 00:02:06,170
the next system deadline and the idea is

00:02:02,729 --> 00:02:10,470
that by taking the high latency state

00:02:06,170 --> 00:02:12,390
time it's way in the deepest state but

00:02:10,470 --> 00:02:14,540
if the sleep state which means we say

00:02:12,390 --> 00:02:21,689
the most power

00:02:14,540 --> 00:02:23,370
and the system under supports the power

00:02:21,689 --> 00:02:25,950
state locking feature which means that

00:02:23,370 --> 00:02:27,569
she can tell the policy okay I don't

00:02:25,950 --> 00:02:30,360
want to enter sudden sleep stay so

00:02:27,569 --> 00:02:34,079
please don't go into them by locking

00:02:30,360 --> 00:02:39,420
these they found and also this ability

00:02:34,079 --> 00:02:41,459
to foresee power state basically by

00:02:39,420 --> 00:02:44,970
initiating that state while asleep you

00:02:41,459 --> 00:02:47,640
is active so you can think of that so

00:02:44,970 --> 00:02:54,120
when say you want to initially shut down

00:02:47,640 --> 00:02:58,739
for example and then there's a device

00:02:54,120 --> 00:03:02,129
punishment and there are the scheme that

00:02:58,739 --> 00:03:06,930
use cost centralized method really what

00:03:02,129 --> 00:03:11,659
that is is the before the cpr goes to

00:03:06,930 --> 00:03:14,609
sleep or deep sleep would notify how the

00:03:11,659 --> 00:03:17,840
device drivers on a system or basic

00:03:14,609 --> 00:03:20,930
telling them okay please low-power or

00:03:17,840 --> 00:03:25,230
suspend the device that you're managing

00:03:20,930 --> 00:03:32,970
and then the drivers would do that and

00:03:25,230 --> 00:03:36,239
then when the CP resumes then would tell

00:03:32,970 --> 00:03:40,859
all the drivers to bring the bring the

00:03:36,239 --> 00:03:43,260
device back to the active mode it's a

00:03:40,859 --> 00:03:45,389
simple scheme and it's now turned in the

00:03:43,260 --> 00:03:49,349
documentation is that her caught it

00:03:45,389 --> 00:03:50,879
should go that method but I don't see

00:03:49,349 --> 00:03:54,150
that being implemented in the code base

00:03:50,879 --> 00:03:57,510
I left that out for this slide and then

00:03:54,150 --> 00:04:02,519
teach other features here that I'll

00:03:57,510 --> 00:04:05,909
touch on later on presentation on top

00:04:02,519 --> 00:04:08,489
these are there's also something called

00:04:05,909 --> 00:04:13,620
a ticklish kernel mode that Center

00:04:08,489 --> 00:04:18,209
supports and what that is is when when

00:04:13,620 --> 00:04:18,900
the CPU is idle to program up the system

00:04:18,209 --> 00:04:21,090
timer

00:04:18,900 --> 00:04:24,690
such a way that they wouldn't wake up

00:04:21,090 --> 00:04:27,180
the CPU until the next system deadline

00:04:24,690 --> 00:04:30,240
supposedly working off periodically

00:04:27,180 --> 00:04:32,190
and then for the cpt final okay it has

00:04:30,240 --> 00:04:35,400
nothing to do so I'll go back to sleep

00:04:32,190 --> 00:04:37,830
and waste power that way

00:04:35,400 --> 00:04:41,160
so there's a brief overview and you like

00:04:37,830 --> 00:04:45,240
more on these go to the separate

00:04:41,160 --> 00:04:49,590
documentation and go check out the

00:04:45,240 --> 00:04:53,699
source code you like so here's the board

00:04:49,590 --> 00:04:57,110
that I've been working on this is since

00:04:53,699 --> 00:05:00,750
these the 1352 hall on launch pad and

00:04:57,110 --> 00:05:05,520
the devices on there is a on context

00:05:00,750 --> 00:05:09,060
employer running at 48 megahertz and it

00:05:05,520 --> 00:05:13,250
consumes roughly three milliamps while

00:05:09,060 --> 00:05:19,169
active I suppose three low power modes

00:05:13,250 --> 00:05:22,410
idle where the CPU and the RAM is power

00:05:19,169 --> 00:05:27,150
clock gated so it has very low latency

00:05:22,410 --> 00:05:35,699
and then there's a standby mode where

00:05:27,150 --> 00:05:40,979
the CPU has in has retention so it knows

00:05:35,699 --> 00:05:45,599
why he resumed once it it comes back to

00:05:40,979 --> 00:05:48,870
fall asleep and in that case the

00:05:45,599 --> 00:05:52,979
real-time counter polyline plot on the

00:05:48,870 --> 00:05:55,520
device his lap on but other than that

00:05:52,979 --> 00:06:00,630
all the other peripherals are turned off

00:05:55,520 --> 00:06:02,909
so it's a fairly no power mode and then

00:06:00,630 --> 00:06:06,139
there's also the shutdown mode where

00:06:02,909 --> 00:06:09,590
really everything is off except for the

00:06:06,139 --> 00:06:13,979
aisle being lashed and it's ready to

00:06:09,590 --> 00:06:19,650
receive input from external events such

00:06:13,979 --> 00:06:23,159
as the punish example and here's the

00:06:19,650 --> 00:06:26,760
implementation the user application

00:06:23,159 --> 00:06:31,970
count in suffer and then suffer has a

00:06:26,760 --> 00:06:34,530
bunch of drivers the power policy and

00:06:31,970 --> 00:06:37,110
SOC definition where it knows how to

00:06:34,530 --> 00:06:39,830
initiate the various sleep in deep sleep

00:06:37,110 --> 00:06:41,510
states and these would

00:06:39,830 --> 00:06:46,360
going through something called API

00:06:41,510 --> 00:06:52,000
hardware abstraction layer support and

00:06:46,360 --> 00:06:55,430
it in this hot track into your house

00:06:52,000 --> 00:06:59,600
there's a TI power manager that I

00:06:55,430 --> 00:07:01,610
leverage more substantially and in there

00:06:59,600 --> 00:07:04,390
there's a function of power slipped are

00:07:01,610 --> 00:07:07,630
used for initiating the standby mode

00:07:04,390 --> 00:07:12,200
this efficient of how dependencies that

00:07:07,630 --> 00:07:15,860
basically turn on/off peripherals and

00:07:12,200 --> 00:07:18,020
power domains depending on whether they

00:07:15,860 --> 00:07:21,800
are needed or not but reference counting

00:07:18,020 --> 00:07:26,600
them the featured we showed it is has

00:07:21,800 --> 00:07:30,680
the resources and it's a nice way to

00:07:26,600 --> 00:07:32,260
automatically do that and then there's a

00:07:30,680 --> 00:07:36,950
feature called

00:07:32,260 --> 00:07:38,240
power constraints which is not

00:07:36,950 --> 00:07:44,260
essentially needed because it's

00:07:38,240 --> 00:07:48,770
identical to to the power locking

00:07:44,260 --> 00:07:50,840
mechanism physical however we anticipate

00:07:48,770 --> 00:07:54,430
bringing in some TI drivers such as the

00:07:50,840 --> 00:07:57,680
PRF driver with which leverages this

00:07:54,430 --> 00:08:00,790
this feature so I'll add that Inder and

00:07:57,680 --> 00:08:03,200
made sure that the policies the posters

00:08:00,790 --> 00:08:06,560
and then there's a power notification

00:08:03,200 --> 00:08:10,370
feature which allows the the drivers to

00:08:06,560 --> 00:08:13,070
register a callback function with the

00:08:10,370 --> 00:08:18,710
power manager so that when the device

00:08:13,070 --> 00:08:22,720
are Wixom it can be notified of that the

00:08:18,710 --> 00:08:22,720
event and they can go ahead and

00:08:22,900 --> 00:08:28,550
reinforce if needed

00:08:25,190 --> 00:08:30,920
and this is because in the case where

00:08:28,550 --> 00:08:36,440
system punishment is turn on but device

00:08:30,920 --> 00:08:37,850
punishment is not turned on then the the

00:08:36,440 --> 00:08:41,780
device drivers are currently not

00:08:37,850 --> 00:08:43,880
notified of these wake up events and

00:08:41,780 --> 00:08:49,790
I've said leveraging this to work around

00:08:43,880 --> 00:08:53,390
that far and the parameter are never

00:08:49,790 --> 00:09:00,350
just the device warning layer the BPL

00:08:53,390 --> 00:09:04,610
but some basic timing and support along

00:09:00,350 --> 00:09:09,350
with this TI driver library which has

00:09:04,610 --> 00:09:12,800
some basic function key access the the

00:09:09,350 --> 00:09:17,480
registers on a device so that's the

00:09:12,800 --> 00:09:21,380
picture and now I was just walking a

00:09:17,480 --> 00:09:24,860
little bit through my journey so I first

00:09:21,380 --> 00:09:28,550
added time arrival that is based on the

00:09:24,860 --> 00:09:30,730
Orton scene because it has the ability

00:09:28,550 --> 00:09:33,800
to wake up the device from standby mode

00:09:30,730 --> 00:09:36,980
as opposed to the standard Cystic timer

00:09:33,800 --> 00:09:40,820
that's all the info which doesn't have

00:09:36,980 --> 00:09:42,410
that capability and as part of that I

00:09:40,820 --> 00:09:44,360
make sure that it supports that this

00:09:42,410 --> 00:09:51,399
kind of mode so that we can understand

00:09:44,360 --> 00:09:55,399
and then I'm at the sleep states to the

00:09:51,399 --> 00:09:58,430
supportive power modes on the device and

00:09:55,399 --> 00:10:01,640
separ supports up to three sleep states

00:09:58,430 --> 00:10:05,810
and to the deep sleep states only needed

00:10:01,640 --> 00:10:07,660
three total the mapping is pre

00:10:05,810 --> 00:10:10,399
straightforward except for the fact that

00:10:07,660 --> 00:10:16,940
standby mode it's kind of like acting

00:10:10,399 --> 00:10:22,130
between things so it it gets the what is

00:10:16,940 --> 00:10:24,440
most of the device down so that makes it

00:10:22,130 --> 00:10:27,529
more like a deep sleep state according

00:10:24,440 --> 00:10:31,160
to is that less definition at the same

00:10:27,529 --> 00:10:32,510
time it resumes from my laptop so that

00:10:31,160 --> 00:10:35,510
makes it more like a sleep state

00:10:32,510 --> 00:10:39,970
according to that in the end after some

00:10:35,510 --> 00:10:45,620
discussion until I opted for it to be a

00:10:39,970 --> 00:10:50,690
sleep state because of that nature and

00:10:45,620 --> 00:10:55,899
then I initialized the atomic marching

00:10:50,690 --> 00:11:00,290
system initialization in suffering and

00:10:55,899 --> 00:11:02,690
after that I created customize the power

00:11:00,290 --> 00:11:05,360
policy function that is residency based

00:11:02,690 --> 00:11:07,639
as well and the reason I don't want to

00:11:05,360 --> 00:11:09,800
use the default one is

00:11:07,639 --> 00:11:12,950
I only want to kind of skip States I

00:11:09,800 --> 00:11:15,560
don't want the device to shut down or

00:11:12,950 --> 00:11:22,040
the magnet for me while the CPU is idle

00:11:15,560 --> 00:11:24,350
and then use the CPU state I also check

00:11:22,040 --> 00:11:28,639
any power constraints that are drivers

00:11:24,350 --> 00:11:30,529
to support that feature and I also

00:11:28,639 --> 00:11:33,170
schedule a take a timer to wake up just

00:11:30,529 --> 00:11:36,560
lightly ahead of the next system that

00:11:33,170 --> 00:11:38,870
line J account for any any work of

00:11:36,560 --> 00:11:45,170
latency so that we really do meet the

00:11:38,870 --> 00:11:49,579
deadlines and then I implemented our

00:11:45,170 --> 00:11:54,829
management enjoyments and first I need

00:11:49,579 --> 00:11:57,850
to define a list of all devices and what

00:11:54,829 --> 00:12:01,430
core devices are just devices that B

00:11:57,850 --> 00:12:06,610
power last before going to sleep and

00:12:01,430 --> 00:12:09,470
power back on first after reasoning and

00:12:06,610 --> 00:12:12,589
these are typically things like system

00:12:09,470 --> 00:12:15,380
timer and the you are to support timing

00:12:12,589 --> 00:12:22,040
and logging services for as long as

00:12:15,380 --> 00:12:22,820
possible and then I am evil all the i/o

00:12:22,040 --> 00:12:26,600
pins

00:12:22,820 --> 00:12:30,829
I selected sources in the GPIO driver

00:12:26,600 --> 00:12:35,300
I guess primarily because this is also

00:12:30,829 --> 00:12:37,279
how care artist does it in action to

00:12:35,300 --> 00:12:39,620
that Center Karen doesn't have a formal

00:12:37,279 --> 00:12:46,130
mechanism that we defined with Deb

00:12:39,620 --> 00:12:49,130
sources and then I implemented a PM

00:12:46,130 --> 00:12:51,290
control function in each driver to

00:12:49,130 --> 00:12:54,319
handle the low power assist band and

00:12:51,290 --> 00:12:56,300
hostage and I handled them on the same

00:12:54,319 --> 00:13:04,370
way because these devices only have four

00:12:56,300 --> 00:13:07,279
nasty and then I cut the lock tell the

00:13:04,370 --> 00:13:09,829
same time mode whenever there is the

00:13:07,279 --> 00:13:14,449
ongoing transfer in the news at least

00:13:09,829 --> 00:13:15,319
rival and as part of doing that I found

00:13:14,449 --> 00:13:19,579
out that your driver

00:13:15,319 --> 00:13:20,780
API is no support our power friendly it

00:13:19,579 --> 00:13:23,020
has the

00:13:20,780 --> 00:13:25,850
function call you are pulling which

00:13:23,020 --> 00:13:27,380
basically expects that you want to be on

00:13:25,850 --> 00:13:29,360
at all times

00:13:27,380 --> 00:13:32,540
so that when they go the functions car

00:13:29,360 --> 00:13:34,910
and just pick up the next character so

00:13:32,540 --> 00:13:37,790
it's very difficult locked out I stand

00:13:34,910 --> 00:13:40,370
by mode in the driver one that has that

00:13:37,790 --> 00:13:42,110
expectation the application has step in

00:13:40,370 --> 00:13:45,560
which means that it's not as

00:13:42,110 --> 00:13:48,550
user-friendly and in the last point I've

00:13:45,560 --> 00:13:48,550
already touched on earlier

00:13:49,510 --> 00:13:57,590
so here the two features that I skipped

00:13:53,860 --> 00:14:02,060
so there's a this device this indication

00:13:57,590 --> 00:14:06,650
on the device punishment and that's used

00:14:02,060 --> 00:14:10,550
to indicate a device it's busy and this

00:14:06,650 --> 00:14:12,380
is pretty much very similar to the power

00:14:10,550 --> 00:14:15,190
state locking mechanism

00:14:12,380 --> 00:14:18,050
I thought to be actually more useful

00:14:15,190 --> 00:14:21,140
because it has the ability that's not

00:14:18,050 --> 00:14:23,930
okay I don't want a specific are sleep

00:14:21,140 --> 00:14:26,210
State I don't want stand by my seconds

00:14:23,930 --> 00:14:28,480
they just locked out standby mode which

00:14:26,210 --> 00:14:32,839
is this nice night

00:14:28,480 --> 00:14:36,260
disability game in addition I don't see

00:14:32,839 --> 00:14:38,570
the PC starting checked anywhere in the

00:14:36,260 --> 00:14:41,480
occultation Zephyr so you can start it

00:14:38,570 --> 00:14:46,550
all day long but it's not being checked

00:14:41,480 --> 00:14:48,680
it's not it's not very useful so maybe

00:14:46,550 --> 00:14:52,700
it's no it's a features do on the

00:14:48,680 --> 00:14:57,130
development or maybe it needs to be an

00:14:52,700 --> 00:15:03,400
example to show me how to use this and

00:14:57,130 --> 00:15:06,740
then this device I love homage that's

00:15:03,400 --> 00:15:09,310
pretty much similar to the power

00:15:06,740 --> 00:15:11,990
dependency unit Lea power manager

00:15:09,310 --> 00:15:15,260
already finding a reference count to

00:15:11,990 --> 00:15:18,490
each device and then I'll turn the

00:15:15,260 --> 00:15:20,510
device off when the count is zero

00:15:18,490 --> 00:15:23,530
unfortunately did not work very well

00:15:20,510 --> 00:15:27,950
with the centralized power mesh method

00:15:23,530 --> 00:15:32,690
because I when the secure resumed from

00:15:27,950 --> 00:15:33,980
say standby then it would go and and try

00:15:32,690 --> 00:15:36,470
to we

00:15:33,980 --> 00:15:39,590
initializing the repower ordered other

00:15:36,470 --> 00:15:41,960
devices in college drivers regardless of

00:15:39,590 --> 00:15:44,930
what the records count is so it doesn't

00:15:41,960 --> 00:15:49,370
check that count apparently so there's

00:15:44,930 --> 00:15:51,610
some integration issue there and also it

00:15:49,370 --> 00:15:54,800
doesn't have the concept power domains

00:15:51,610 --> 00:15:56,570
and sorry I forgot to define all that

00:15:54,800 --> 00:15:58,940
means earlier that powder mains are

00:15:56,570 --> 00:16:03,950
basically partitioning of the device

00:15:58,940 --> 00:16:08,090
that can be turned on and off as a whole

00:16:03,950 --> 00:16:12,830
together and because doesn't have this

00:16:08,090 --> 00:16:22,370
this concept it's it was better to use

00:16:12,830 --> 00:16:24,970
of the TI power manager instead so in

00:16:22,370 --> 00:16:28,970
order to make sure that this works I

00:16:24,970 --> 00:16:32,180
disempower nations using the definitions

00:16:28,970 --> 00:16:36,610
of God yeah I call energy trace and what

00:16:32,180 --> 00:16:40,390
that is is RTI has added some extra

00:16:36,610 --> 00:16:44,870
emulation hardware on a board to allow

00:16:40,390 --> 00:16:47,810
us to measure the current flow to the

00:16:44,870 --> 00:16:51,110
target and digitize those measurements

00:16:47,810 --> 00:16:52,910
and then provide some software tooling

00:16:51,110 --> 00:16:58,490
or the whole side to retrieve these

00:16:52,910 --> 00:17:00,800
measurements automatically and it has

00:16:58,490 --> 00:17:04,460
negative roughly 0.5 Michael and in this

00:17:00,800 --> 00:17:08,690
case a range of one Michael ninety one

00:17:04,460 --> 00:17:12,620
hundred millions sampling rate of 256

00:17:08,690 --> 00:17:16,580
you know samples per second and bodies

00:17:12,620 --> 00:17:22,460
nationals I took were average over 10

00:17:16,580 --> 00:17:25,850
seconds worth of samples and here if you

00:17:22,460 --> 00:17:30,920
look at the first scenario it basic

00:17:25,850 --> 00:17:33,400
response to stand by and the inset we're

00:17:30,920 --> 00:17:35,540
also able to measure roughly 1 micro M

00:17:33,400 --> 00:17:38,690
which is in line with the normal

00:17:35,540 --> 00:17:41,060
thinking and when I compared with here

00:17:38,690 --> 00:17:43,880
are tasks I could see that was roughly

00:17:41,060 --> 00:17:47,000
the same so that is good and that should

00:17:43,880 --> 00:17:49,480
be expected because we are using Tom on

00:17:47,000 --> 00:17:49,480
my shed

00:17:49,539 --> 00:17:58,759
and then I tried to learn hello world

00:17:54,529 --> 00:18:01,700
and printing out once a second and then

00:17:58,759 --> 00:18:04,909
going to stand by in between and under

00:18:01,700 --> 00:18:09,440
set her heart that came out to about 12

00:18:04,909 --> 00:18:13,129
micro ends and that's slightly higher

00:18:09,440 --> 00:18:14,840
than PR artists but that's to be

00:18:13,129 --> 00:18:17,419
expected because ultimately using two

00:18:14,840 --> 00:18:19,820
different you are drivers here and then

00:18:17,419 --> 00:18:24,529
your drivers etc is not as efficient

00:18:19,820 --> 00:18:27,379
currently it reduces it reduces calling

00:18:24,529 --> 00:18:33,830
and it doesn't make use of any buffering

00:18:27,379 --> 00:18:35,479
in the you are personal some indication

00:18:33,830 --> 00:18:40,369
of some optimization that could be done

00:18:35,479 --> 00:18:42,950
there and then the next two scenarios

00:18:40,369 --> 00:18:46,849
are basically just examples taken from

00:18:42,950 --> 00:18:52,279
sector managers to show what kind of

00:18:46,849 --> 00:18:58,039
power consumption we get when spa and

00:18:52,279 --> 00:19:02,049
i2c are being used and then in the last

00:18:58,039 --> 00:19:04,609
scenario the shutdown mode the

00:19:02,049 --> 00:19:07,309
consumption was too low for me to

00:19:04,609 --> 00:19:10,849
measure without a entry so I used an

00:19:07,309 --> 00:19:14,539
old-fashioned multimeter and hook it up

00:19:10,849 --> 00:19:17,859
through the power rail to to the target

00:19:14,539 --> 00:19:20,599
and then and then the numbers came out

00:19:17,859 --> 00:19:26,570
not too far from the denominator figures

00:19:20,599 --> 00:19:30,769
as well so I know that come on others

00:19:26,570 --> 00:19:34,629
are have some interest in seeing demo

00:19:30,769 --> 00:19:36,379
and P ing trace so initially that

00:19:34,629 --> 00:19:41,419
thoroughly when I still have some time

00:19:36,379 --> 00:19:47,109
so so here's a my set up so I have a

00:19:41,419 --> 00:19:51,169
Dell laptop running Windows and

00:19:47,109 --> 00:19:53,539
connected to the board and what one

00:19:51,169 --> 00:19:56,839
shown you is s tune which is

00:19:53,539 --> 00:20:01,700
command-line utility from play icon

00:19:56,839 --> 00:20:04,550
composer studio or CCS and it

00:20:01,700 --> 00:20:09,320
Allah has the ability to pick up the

00:20:04,550 --> 00:20:12,200
power missions and then I want to show

00:20:09,320 --> 00:20:15,080
you energy pie which is a bunch of

00:20:12,200 --> 00:20:19,010
Python wrappers that some interns are

00:20:15,080 --> 00:20:22,960
taught that's right some time ago and I

00:20:19,010 --> 00:20:28,850
was addicted from our servers and they

00:20:22,960 --> 00:20:31,490
invoke s2 in and xdist EAP utility which

00:20:28,850 --> 00:20:37,630
gives access to some relation to the

00:20:31,490 --> 00:20:40,430
third is on the device and and basically

00:20:37,630 --> 00:20:45,800
this is able to bring all that data into

00:20:40,430 --> 00:20:50,450
Python so let me first show you as to

00:20:45,800 --> 00:20:55,370
him so here I am in in the air student

00:20:50,450 --> 00:20:59,980
directory in CCS and my question that

00:20:55,370 --> 00:21:05,600
brings me into the shell Augustine and

00:20:59,980 --> 00:21:09,140
let me connect up the ball you actually

00:21:05,600 --> 00:21:11,900
measuring something so currently I

00:21:09,140 --> 00:21:17,210
preloaded the hello world scenario on

00:21:11,900 --> 00:21:21,290
the on target and and I'd like to

00:21:17,210 --> 00:21:25,030
connect to the ball so so I connect

00:21:21,290 --> 00:21:27,620
using this - that's the option using

00:21:25,030 --> 00:21:34,880
standard CCS that configuration found

00:21:27,620 --> 00:21:38,240
and connected using p IX emulation and

00:21:34,880 --> 00:21:42,110
then after that I want to run these

00:21:38,240 --> 00:21:47,090
energy trace command over five seconds

00:21:42,110 --> 00:21:52,400
or 5,000 millisecond and send the output

00:21:47,090 --> 00:21:55,790
to this CSV file and measure over the

00:21:52,400 --> 00:21:59,090
one Michael Pam through the to 100

00:21:55,790 --> 00:22:01,070
million range and use the extend

00:21:59,090 --> 00:22:04,280
actually trace mode to do that which I

00:22:01,070 --> 00:22:10,700
found to be more accurate in this case

00:22:04,280 --> 00:22:13,190
and it's currently running it's starting

00:22:10,700 --> 00:22:14,690
after five seconds and

00:22:13,190 --> 00:22:19,560
[Music]

00:22:14,690 --> 00:22:22,500
we should be able to see the measurement

00:22:19,560 --> 00:22:24,570
limited it takes a little bit of time to

00:22:22,500 --> 00:22:28,050
compile that system car

00:22:24,570 --> 00:22:33,240
so here this so five seconds and it

00:22:28,050 --> 00:22:36,450
shows the average maximum and minimum on

00:22:33,240 --> 00:22:40,970
the current consumption and also the

00:22:36,450 --> 00:22:51,810
total amount of energy that was consumed

00:22:40,970 --> 00:22:56,370
and let me show you this so I'll put

00:22:51,810 --> 00:22:59,700
this be it produce two files because it

00:22:56,370 --> 00:23:05,340
actually chunks them up into your four

00:22:59,700 --> 00:23:08,660
second periods and here's the data so

00:23:05,340 --> 00:23:12,740
you can see the time stand you can see

00:23:08,660 --> 00:23:15,240
the voltage which is constant and then

00:23:12,740 --> 00:23:19,620
current measurements and the energy

00:23:15,240 --> 00:23:22,440
value so it'd be nice to be able to say

00:23:19,620 --> 00:23:30,810
plus some of this and that's why python

00:23:22,440 --> 00:23:37,140
comes in so let me just use that to make

00:23:30,810 --> 00:23:42,530
sure we clean slate so here we're in the

00:23:37,140 --> 00:23:46,500
energy PI installation direction and

00:23:42,530 --> 00:23:51,360
from here I like to run this Python

00:23:46,500 --> 00:23:53,280
script I wrote demo WI and then passed

00:23:51,360 --> 00:23:56,910
it B are excludable that I want to

00:23:53,280 --> 00:24:01,170
measure and Wow

00:23:56,910 --> 00:24:05,910
it's running let me show you what's in

00:24:01,170 --> 00:24:12,420
the in the script and exp double so the

00:24:05,910 --> 00:24:15,690
script is very simple it basically

00:24:12,420 --> 00:24:22,620
creates a for instance from mg PI and

00:24:15,690 --> 00:24:27,830
then it flashes the the binary to the

00:24:22,620 --> 00:24:33,809
board and we set the board and then

00:24:27,830 --> 00:24:35,429
perform power measuring using s2 and it

00:24:33,809 --> 00:24:39,299
collects the data into this lucky key

00:24:35,429 --> 00:24:42,419
data variable and then it basically

00:24:39,299 --> 00:24:47,969
plotted using a package in Python taught

00:24:42,419 --> 00:24:54,299
math not that and then let's look at

00:24:47,969 --> 00:24:57,269
main dot C so the application first

00:24:54,299 --> 00:24:59,849
thing I did was shut down the external

00:24:57,269 --> 00:25:02,849
flash on the board that is automatically

00:24:59,849 --> 00:25:05,129
powered when the board is connected

00:25:02,849 --> 00:25:08,219
I don't really new mean he's this flash

00:25:05,129 --> 00:25:11,159
for this application so I don't wanted

00:25:08,219 --> 00:25:17,820
to show up in the ng measurement so I

00:25:11,159 --> 00:25:21,779
turn it off and then I set up the GPIO

00:25:17,820 --> 00:25:23,369
for a push-button that can be used to

00:25:21,779 --> 00:25:30,509
wake up the device if needed

00:25:23,369 --> 00:25:35,629
after it shuts down and then I bc wait

00:25:30,509 --> 00:25:38,039
for five seconds after that i sleep for

00:25:35,629 --> 00:25:41,369
two thousand micro second which is two

00:25:38,039 --> 00:25:44,460
millisecond and that's a very small time

00:25:41,369 --> 00:25:49,799
which means that the power policy

00:25:44,460 --> 00:25:53,969
function would pick the idle mode in

00:25:49,799 --> 00:25:56,460
this case after that I ask for three

00:25:53,969 --> 00:25:58,409
seconds which is longer and the

00:25:56,460 --> 00:26:03,899
pomposity function would pick on a

00:25:58,409 --> 00:26:07,889
standby mode in this case and after that

00:26:03,899 --> 00:26:10,619
I forced the deep sleep state number one

00:26:07,889 --> 00:26:17,789
which corresponds to shut down load and

00:26:10,619 --> 00:26:23,509
shut down device so with that I believe

00:26:17,789 --> 00:26:23,509
the script is done and it's the ground

00:26:24,080 --> 00:26:30,019
so yeah my machine is looking well there

00:26:28,649 --> 00:26:35,999
you go

00:26:30,019 --> 00:26:38,940
so it's against the the first chunk here

00:26:35,999 --> 00:26:40,970
is basically when the device is easy

00:26:38,940 --> 00:26:44,450
waiting

00:26:40,970 --> 00:26:46,520
and you can see that only three little

00:26:44,450 --> 00:26:49,130
the three seconds of it because there's

00:26:46,520 --> 00:26:50,540
a delay between when when the program

00:26:49,130 --> 00:26:52,640
starts and when the measurement actually

00:26:50,540 --> 00:26:55,370
starts so we don't see all five seconds

00:26:52,640 --> 00:26:57,650
of it but that's why the visa waiting

00:26:55,370 --> 00:27:02,360
happens and then we see a transition and

00:26:57,650 --> 00:27:05,120
if we zoom into the transition we can

00:27:02,360 --> 00:27:09,440
see that okay it jumped briefly into

00:27:05,120 --> 00:27:13,010
idle which is where it consumes roughly

00:27:09,440 --> 00:27:17,410
another less than one half one nine LEM

00:27:13,010 --> 00:27:22,490
and and then it goes back up acted

00:27:17,410 --> 00:27:27,920
before dropping out off into the standby

00:27:22,490 --> 00:27:31,790
mode and let me zoom out and basically

00:27:27,920 --> 00:27:36,320
we stay in in standby mode for three

00:27:31,790 --> 00:27:39,830
seconds so from three point to roughly

00:27:36,320 --> 00:27:42,110
into six point two well you can stand by

00:27:39,830 --> 00:27:46,220
and you can see these spikes see that

00:27:42,110 --> 00:27:50,030
these basically recharge pulses while

00:27:46,220 --> 00:27:52,190
the device is in standby because the the

00:27:50,030 --> 00:27:55,760
CPU still has to be tension so there

00:27:52,190 --> 00:27:59,530
needs to be some power to avoid to

00:27:55,760 --> 00:28:03,020
retain that logic so that's what we saw

00:27:59,530 --> 00:28:06,080
and then after the three seconds are

00:28:03,020 --> 00:28:08,630
done then we wake up and then we forced

00:28:06,080 --> 00:28:11,540
the shutdown and you can see that after

00:28:08,630 --> 00:28:15,440
a faulty shut da mode then not much is

00:28:11,540 --> 00:28:19,870
happening after that so you can kind of

00:28:15,440 --> 00:28:22,820
see the possibilities here in terms of

00:28:19,870 --> 00:28:32,960
graphing and finalizing this measurement

00:28:22,820 --> 00:28:35,750
data all right so just so in summary

00:28:32,960 --> 00:28:38,840
Center provides a basic punishment

00:28:35,750 --> 00:28:41,810
framework and with the help of the power

00:28:38,840 --> 00:28:45,140
manager was able to get decent results

00:28:41,810 --> 00:28:49,820
in the statics dinerral that measured

00:28:45,140 --> 00:28:54,420
and both our system and device

00:28:49,820 --> 00:28:57,150
management support or the 1352 have been

00:28:54,420 --> 00:29:01,310
they merged and the shutdown will

00:28:57,150 --> 00:29:04,070
support our is still pending with you

00:29:01,310 --> 00:29:06,240
and in general I just say that the

00:29:04,070 --> 00:29:08,820
emergence of system could benefit from

00:29:06,240 --> 00:29:12,570
more features and just that integration

00:29:08,820 --> 00:29:15,680
between the features and also between

00:29:12,570 --> 00:29:20,970
the features and some of the aspect like

00:29:15,680 --> 00:29:24,300
device driver API for example and I

00:29:20,970 --> 00:29:25,790
believe it's encouraging to see or or

00:29:24,300 --> 00:29:29,430
the brainstorming that's been going on

00:29:25,790 --> 00:29:32,120
online so be very interesting to see

00:29:29,430 --> 00:29:37,440
what happens

00:29:32,120 --> 00:29:42,870
and that's pretty much like any

00:29:37,440 --> 00:29:49,350
questions a couple questions of tickets

00:29:42,870 --> 00:29:51,480
notes or Vincent 0.85 micrograms you in

00:29:49,350 --> 00:29:53,730
your routine all the the ADK SRAM that's

00:29:51,480 --> 00:29:58,890
an impressive number it's not a question

00:29:53,730 --> 00:30:00,390
just a comment thank you when you show

00:29:58,890 --> 00:30:02,820
those power numbers there's a footnote

00:30:00,390 --> 00:30:05,220
that says external flash off what do you

00:30:02,820 --> 00:30:07,410
mean by that I assume external flash

00:30:05,220 --> 00:30:09,690
like that's SPI flash or something or

00:30:07,410 --> 00:30:12,480
cue SPI flash not the internal flash

00:30:09,690 --> 00:30:15,480
memory yeah so there's some external

00:30:12,480 --> 00:30:20,420
flash that is sitting on the launch pad

00:30:15,480 --> 00:30:24,170
itself that's not part of the device and

00:30:20,420 --> 00:30:28,740
the device communicates to it via spy

00:30:24,170 --> 00:30:32,450
and this this plash is automatically

00:30:28,740 --> 00:30:36,510
turned on when the phone is powered up

00:30:32,450 --> 00:30:38,970
and how consumption of that of that

00:30:36,510 --> 00:30:40,740
flash shows up in the in the

00:30:38,970 --> 00:30:43,560
measurements so I had to turn that off

00:30:40,740 --> 00:30:46,260
you know it not he dominate the

00:30:43,560 --> 00:30:50,040
measuring especially in the cases though

00:30:46,260 --> 00:30:53,400
I have very low numbers like in standby

00:30:50,040 --> 00:30:59,010
mode example it would it would pretty

00:30:53,400 --> 00:31:01,850
much you know make measurement like ten

00:30:59,010 --> 00:31:04,580
times what it is understand

00:31:01,850 --> 00:31:06,170
the same with putting your pins pull-up

00:31:04,580 --> 00:31:07,580
resistors or things like that you want

00:31:06,170 --> 00:31:13,010
to set them before you go into the deep

00:31:07,580 --> 00:31:15,280
sleeper um I was thinking what what my

00:31:13,010 --> 00:31:17,750
concern would be let's say we want to

00:31:15,280 --> 00:31:20,270
add a frameless the question was clear

00:31:17,750 --> 00:31:22,220
in my head well I was I was working on

00:31:20,270 --> 00:31:24,350
the driver for a demo a couple weeks ago

00:31:22,220 --> 00:31:28,010
for an embedded world demos that have

00:31:24,350 --> 00:31:30,220
still been poking around it and it

00:31:28,010 --> 00:31:32,210
basically has a set of sensors

00:31:30,220 --> 00:31:34,280
spectrometer but it takes me about one

00:31:32,210 --> 00:31:36,320
second to get a sample from the sensors

00:31:34,280 --> 00:31:38,000
so I'll start the I squared C

00:31:36,320 --> 00:31:40,700
transaction and then I just have to wait

00:31:38,000 --> 00:31:43,610
like 800 milliseconds before my sample

00:31:40,700 --> 00:31:44,840
is ready I guess this comes back that

00:31:43,610 --> 00:31:47,120
you were saying that we don't use like

00:31:44,840 --> 00:31:49,910
the device tree busy flag at all but how

00:31:47,120 --> 00:31:51,920
would how in your opinion in a sensor

00:31:49,910 --> 00:31:54,500
driver or a device driver where we know

00:31:51,920 --> 00:31:56,120
we need to stay active for 800

00:31:54,500 --> 00:31:58,190
milliseconds before we can go to sleep

00:31:56,120 --> 00:32:00,350
is there a way to indicate something

00:31:58,190 --> 00:32:01,910
like that that in in Zephir and the

00:32:00,350 --> 00:32:03,380
power management library today like

00:32:01,910 --> 00:32:06,080
let's say I get a call back to say okay

00:32:03,380 --> 00:32:07,730
time to go to sleep it can attract

00:32:06,080 --> 00:32:09,320
innocence drivers say don't wait hang on

00:32:07,730 --> 00:32:12,470
I'm waiting for a result and I need

00:32:09,320 --> 00:32:14,660
another 200 milliseconds yeah I leave

00:32:12,470 --> 00:32:19,340
that that can be done using the power

00:32:14,660 --> 00:32:22,430
locking feature basically you call an

00:32:19,340 --> 00:32:27,680
API before the sensors not to transfer

00:32:22,430 --> 00:32:31,010
and to tell the the power policy okay I

00:32:27,680 --> 00:32:35,570
need I need to do not know in this

00:32:31,010 --> 00:32:39,160
sudden sleep states and then when the

00:32:35,570 --> 00:32:43,010
transmits over you can unlock that state

00:32:39,160 --> 00:32:45,520
that means that then the CPU would be

00:32:43,010 --> 00:32:56,840
able to enter that state and continue on

00:32:45,520 --> 00:32:59,300
say power I guess I was curious it and

00:32:56,840 --> 00:33:01,550
this is just me putting my let's make

00:32:59,300 --> 00:33:03,860
things complicated hat on is there any

00:33:01,550 --> 00:33:06,740
sort of timer like with a driver let's

00:33:03,860 --> 00:33:09,799
say I tell there's a system event where

00:33:06,740 --> 00:33:11,690
I say enter specific sleep mode

00:33:09,799 --> 00:33:14,749
and then that will send a callback to

00:33:11,690 --> 00:33:16,369
other drivers what do you have to get a

00:33:14,749 --> 00:33:18,409
response back or is there some sort of

00:33:16,369 --> 00:33:21,139
timeout like if a driver just doesn't

00:33:18,409 --> 00:33:24,789
detect something and doesn't go into low

00:33:21,139 --> 00:33:29,720
power motors is there any sort of

00:33:24,789 --> 00:33:33,739
currently the the schema studies simple

00:33:29,720 --> 00:33:37,999
in zephyr arm it just basically call a

00:33:33,739 --> 00:33:40,369
function each driver totality to either

00:33:37,999 --> 00:33:44,619
go into low-power mode or suspends they

00:33:40,369 --> 00:33:50,679
and and then the driver would then

00:33:44,619 --> 00:33:54,859
initiate the device off sequence and

00:33:50,679 --> 00:33:56,299
bring the device and then when the

00:33:54,859 --> 00:34:01,730
steeps unity comes back on it would

00:33:56,299 --> 00:34:04,940
reactivate all these devices so if you

00:34:01,730 --> 00:34:08,419
need anything beyond that then it would

00:34:04,940 --> 00:34:10,609
be part of the an application well if

00:34:08,419 --> 00:34:12,589
that process is really slow like maybe

00:34:10,609 --> 00:34:14,450
it takes like 500 milliseconds to shut

00:34:12,589 --> 00:34:16,730
something down there's a go motor you

00:34:14,450 --> 00:34:20,059
need to stop or something like that I'm

00:34:16,730 --> 00:34:21,200
just curious what just I mean I make it

00:34:20,059 --> 00:34:23,149
looks complicated but maybe just

00:34:21,200 --> 00:34:24,970
something to keep into your mind where

00:34:23,149 --> 00:34:27,559
you can't just stop a motor instantly

00:34:24,970 --> 00:34:33,980
before you go to sleep you have to sort

00:34:27,559 --> 00:34:37,339
of slowly yeah yeah definitely that the

00:34:33,980 --> 00:34:38,720
latency can be an issue if you if you're

00:34:37,339 --> 00:34:42,379
the peripheral that you're dealing with

00:34:38,720 --> 00:34:46,240
is it's slow you might be waiting a long

00:34:42,379 --> 00:34:52,329
time for it to to shut down and that

00:34:46,240 --> 00:34:56,720
that is only concern and that is why the

00:34:52,329 --> 00:34:59,059
the latencies for each sleep and deep

00:34:56,720 --> 00:35:01,690
sleep state is programmable so it can be

00:34:59,059 --> 00:35:06,200
configured as part of the key config a

00:35:01,690 --> 00:35:09,770
mechanism etc and so if you have a motor

00:35:06,200 --> 00:35:13,520
and it takes I don't know maybe like one

00:35:09,770 --> 00:35:16,700
second to shut down then then you can

00:35:13,520 --> 00:35:22,390
set up that latency to be little longer

00:35:16,700 --> 00:35:26,619
and then and then account for that

00:35:22,390 --> 00:35:29,230
while the so that the policy would know

00:35:26,619 --> 00:35:34,960
okay it takes one second to go into this

00:35:29,230 --> 00:35:36,490
slip state so I only have 750 I'm your

00:35:34,960 --> 00:35:38,920
second till the next Airlines I better

00:35:36,490 --> 00:35:41,200
not do this so it would it would just

00:35:38,920 --> 00:35:42,280
not go into that state oh good that's

00:35:41,200 --> 00:35:44,020
good that's good that somebody's

00:35:42,280 --> 00:35:46,210
thinking with that then I say I'm just

00:35:44,020 --> 00:35:48,040
I'm quite ignorant about the power of

00:35:46,210 --> 00:35:51,310
the power management systems today and

00:35:48,040 --> 00:35:52,270
that's specified in the device tree no

00:35:51,310 --> 00:35:55,180
currently odd

00:35:52,270 --> 00:35:59,200
there's no usage of the device tree

00:35:55,180 --> 00:36:05,170
directly so that is actually specify as

00:35:59,200 --> 00:36:07,000
part of a cake on fake option okay I'm

00:36:05,170 --> 00:36:08,920
just gonna stop pause here I'm going to

00:36:07,000 --> 00:36:11,770
call it I'm going to end the recording

00:36:08,920 --> 00:36:14,740
but please keep going with the questions

00:36:11,770 --> 00:36:17,290
if you if you want and I'm gonna hand it

00:36:14,740 --> 00:36:18,660
over to Kumar from after this point so

00:36:17,290 --> 00:36:23,170
thank you Vincent

00:36:18,660 --> 00:36:27,300
for the presentation and I'm ending the

00:36:23,170 --> 00:36:27,300

YouTube URL: https://www.youtube.com/watch?v=8D15e4h0_dg


