Title: LTD20-207 Making Pi ServerReady: time for cheap Arm infrastructure be standards-compliant
Publication date: 2020-04-01
Playlist: Linaro Tech Days 2020
Description: 
	Description:
Arm hardware and firmware standards are the foundational pillars for Arm servers, and a major reason for the early successes and continued investment and growth of this horizontally-integrated ecosystem. Non-server "Edge" systems, however, are still an embedded-style vertically-integrated market, which is getting in the way of massive adoption and proliferation of Edge/IoT Compute. So let's make the Edge systems standards compliant and start with the highest-volume and better known platform of them all - the Raspberry Pi! Let's teach the Pi how to boot off-the-shelf SBBR -compliant Linux, *BSDs and of course VMware ESXi-Arm and Microsoft Windows.

Even if you don't care about IoT, getting this class of devices to be standards-compliant will provide developers, tech evangelists and early adopters with $50-$100 ServerReady platforms, solving a real headache today around pricing/availability of systems in the market.

This is a technical presentation (and demo) on VMware's and Arm's joint open efforts to bring Arm ServerReady experiences to the Pi 4 as community-developed SBBR firmware, as part of the larger narrative that SBSA/SBBR is perhaps even more important at the Edge than it is in the Cloud or on-prem. The session covers the history of the Pi UEFI port, current status and technical challenges that remain to be solved.

The point of this session is to build community interest/participation in this effort and other efforts to make Edge systems ServerReady, such as Arm's Project Cassini. If we can do it on the Pi, we can do it on other Arm boards too.

Session Speakers
Andrei Warkentin
Arm Enablement Architect (VMware)

Co-founder and lead for the ESXi-Arm project in the Cloud Platform Business Unit at VMware, conducting advanced development of vSphere hypervisor technology for the 64-bit Arm architecture. Andrei works in a wide range of directions pertaining to Arm enablement and strategy, ranging from low-level hypervisor design and implementation, to product definition and partner and ecosystem engagement.


Samer El-Haj-Mahmoud
System Architect (Arm)

Samer El-Haj-Mahmoud is a Principal Systems Architect at Arm Architecture and Technology Group, working on Arm infrastructure enablement and industry standards. His experience includes server development, firmware, system software, and hardware management. Samer is an active participant and contributor to industry standards, including UEFI, ACPI, CXL, and DMTF Redfish. 



You can find this sessions presentation here:
https://connect.linaro.org/resources/ltd20/ltd20-207/
Captions: 
	00:00:01,129 --> 00:00:08,540
okay hi everybody and welcome to this

00:00:04,740 --> 00:00:10,680
session which we called is your PI

00:00:08,540 --> 00:00:13,920
severity and of course we're referring

00:00:10,680 --> 00:00:17,460
to the Raspberry Pi 4 and this session

00:00:13,920 --> 00:00:21,950
will be about embracing arm service

00:00:17,460 --> 00:00:25,710
standards at the edge my name is Andre

00:00:21,950 --> 00:00:30,840
I'm a tech lead for the ESXi arm project

00:00:25,710 --> 00:00:33,810
at VMware and my name is Samuel Hodge

00:00:30,840 --> 00:00:36,810
machmood I am a system architect at the

00:00:33,810 --> 00:00:39,280
ARM architecture and Technology Group at

00:00:36,810 --> 00:00:42,270
at arm

00:00:39,280 --> 00:00:45,040
and so the rough agenda today is we'll

00:00:42,270 --> 00:00:47,890
briefly mention what arms are already is

00:00:45,040 --> 00:00:51,880
I will talk about signal board computers

00:00:47,890 --> 00:00:53,470
will briefly go over how we are

00:00:51,880 --> 00:00:57,070
prototyping this with the Raspberry Pi

00:00:53,470 --> 00:01:00,870
for mention some challenges show you a

00:00:57,070 --> 00:01:09,100
demo well a very static looking demo and

00:01:00,870 --> 00:01:12,700
provide a brief call to action alright

00:01:09,100 --> 00:01:19,110
I'll start by talking a little bit about

00:01:12,700 --> 00:01:23,500
the arm server ready program so in the

00:01:19,110 --> 00:01:27,940
server market which is a horizontally

00:01:23,500 --> 00:01:32,259
integrated market there is a need to

00:01:27,940 --> 00:01:33,399
design systems that just work for the

00:01:32,259 --> 00:01:35,580
end user

00:01:33,399 --> 00:01:39,509
with the ability to install and run

00:01:35,580 --> 00:01:44,700
standard off-the-shelf operating systems

00:01:39,509 --> 00:01:46,930
and in order to do that there are

00:01:44,700 --> 00:01:49,570
minimum set of hardware and thermal

00:01:46,930 --> 00:01:54,520
requirements that need to be followed in

00:01:49,570 --> 00:02:00,009
designing such a system so for the arm

00:01:54,520 --> 00:02:02,830
ecosystem this need first arrived in the

00:02:00,009 --> 00:02:06,909
server segment the arm server ready

00:02:02,830 --> 00:02:09,250
compliance program was introduced to to

00:02:06,909 --> 00:02:15,090
provide this just works solution for

00:02:09,250 --> 00:02:20,320
servers the program provides blueprints

00:02:15,090 --> 00:02:24,220
for designing arm servers that is are

00:02:20,320 --> 00:02:25,870
based on industry standards such as some

00:02:24,220 --> 00:02:31,000
of the hardware and firmware standards

00:02:25,870 --> 00:02:33,910
like PCIe UEFI and NCPI as well as arm

00:02:31,000 --> 00:02:38,200
defined requirements and standards like

00:02:33,910 --> 00:02:42,700
the SBS a and SBB R which we will go

00:02:38,200 --> 00:02:46,450
over in more details in addition the

00:02:42,700 --> 00:02:48,520
program is a company with a compliance

00:02:46,450 --> 00:02:51,970
test suite the because the architecture

00:02:48,520 --> 00:02:53,590
combines suite or ACS and a process for

00:02:51,970 --> 00:02:59,340
certification

00:02:53,590 --> 00:03:02,980
the goal is to to have the arm servers

00:02:59,340 --> 00:03:05,200
just work with off-the-shelf operating

00:03:02,980 --> 00:03:08,080
systems at least enough to use a

00:03:05,200 --> 00:03:11,950
standard OS image to be able to install

00:03:08,080 --> 00:03:14,880
a boot and then can install missing

00:03:11,950 --> 00:03:20,530
drivers and software packages so it

00:03:14,880 --> 00:03:23,620
behaves in a familiar way to the

00:03:20,530 --> 00:03:26,200
ecosystem OMS and ODMs software

00:03:23,620 --> 00:03:35,760
developers and and IT staff and

00:03:26,200 --> 00:03:40,900
customers excite us thank you

00:03:35,760 --> 00:03:44,709
so the first main component of the arm

00:03:40,900 --> 00:03:47,830
supported program is the server based

00:03:44,709 --> 00:03:54,330
system architecture or the SBS a the SBS

00:03:47,830 --> 00:04:01,650
a specification covers the hardware

00:03:54,330 --> 00:04:06,370
requirements for servers that includes

00:04:01,650 --> 00:04:10,480
requirements to run these standard

00:04:06,370 --> 00:04:13,540
operating systems based on both industry

00:04:10,480 --> 00:04:16,150
standards as well as arm standards so

00:04:13,540 --> 00:04:20,350
that that covers a range of requirements

00:04:16,150 --> 00:04:22,740
for the processor memory subsystem the

00:04:20,350 --> 00:04:25,660
interrupt controllers the serial

00:04:22,740 --> 00:04:27,640
controllers the airport controllers PCIe

00:04:25,660 --> 00:04:32,200
device integration and and

00:04:27,640 --> 00:04:34,960
implementation etc so there is coverage

00:04:32,200 --> 00:04:38,370
for PCIe of course as an industry

00:04:34,960 --> 00:04:41,020
standard in the future you may see other

00:04:38,370 --> 00:04:44,220
interconnect technologies like C Excel

00:04:41,020 --> 00:04:48,330
or c6 included in this standard as well

00:04:44,220 --> 00:04:51,460
but there are also reliance on ARM

00:04:48,330 --> 00:04:53,380
architecture hardware standards

00:04:51,460 --> 00:05:00,490
including the the ARM architecture

00:04:53,380 --> 00:05:03,750
itself the extensions for ass and other

00:05:00,490 --> 00:05:07,060
and other specifications from our the

00:05:03,750 --> 00:05:09,180
SBS a was designed

00:05:07,060 --> 00:05:14,100
to have multiple compliance levels

00:05:09,180 --> 00:05:17,230
starting with level zero which is least

00:05:14,100 --> 00:05:20,230
interoperable mostly implementation

00:05:17,230 --> 00:05:23,950
defined and then goes all the way to

00:05:20,230 --> 00:05:26,530
level six with each level being adding

00:05:23,950 --> 00:05:30,460
additional requirements and raising the

00:05:26,530 --> 00:05:35,250
bar with additional functionality and if

00:05:30,460 --> 00:05:39,700
you look at the next slide as an example

00:05:35,250 --> 00:05:46,450
for level six you can see that there is

00:05:39,700 --> 00:05:50,050
a traction on adding more requirements

00:05:46,450 --> 00:05:52,270
that that map with France

00:05:50,050 --> 00:05:54,310
for instance additional functionality

00:05:52,270 --> 00:05:59,230
and features added to the arm v8

00:05:54,310 --> 00:06:02,430
architecture and and you can see here

00:05:59,230 --> 00:06:06,940
from from just the sample of

00:06:02,430 --> 00:06:09,760
requirements that are introduced in

00:06:06,940 --> 00:06:14,050
these levels is that they span from the

00:06:09,760 --> 00:06:17,979
processor PE processor core requirements

00:06:14,050 --> 00:06:22,510
to on chip IO and even system level

00:06:17,979 --> 00:06:26,229
design requirements for example in SBS a

00:06:22,510 --> 00:06:29,590
level 6 we added an appendix that show

00:06:26,229 --> 00:06:32,940
how PCIe is properly PSC including

00:06:29,590 --> 00:06:37,210
endpoints are properly implemented and

00:06:32,940 --> 00:06:39,430
presented in the system including things

00:06:37,210 --> 00:06:41,020
like the ECAM or the enhanced

00:06:39,430 --> 00:06:45,340
configuration access method

00:06:41,020 --> 00:06:50,760
implementation so that's that's the SBS

00:06:45,340 --> 00:06:53,110
a the second and equally important

00:06:50,760 --> 00:06:57,220
specification that's part of this

00:06:53,110 --> 00:06:58,690
program is the SBB are the server based

00:06:57,220 --> 00:07:03,460
boot requirements

00:06:58,690 --> 00:07:06,910
similar to the SBS a which is a set of

00:07:03,460 --> 00:07:12,130
requirements for the hardware the SBB

00:07:06,910 --> 00:07:16,140
our focuses on thermal requirements for

00:07:12,130 --> 00:07:20,889
operating systems and hypervisors

00:07:16,140 --> 00:07:27,749
leveraging industry standards like UEFI

00:07:20,889 --> 00:07:32,620
CPI as some bias PCI firmware and TPM

00:07:27,749 --> 00:07:36,789
interfaces from TCG for example as well

00:07:32,620 --> 00:07:39,729
as the the foundational common elements

00:07:36,789 --> 00:07:46,469
from from the armed firmer architectures

00:07:39,729 --> 00:07:51,069
including the PSC I and other interfaces

00:07:46,469 --> 00:07:57,240
provided by the trusted firmer this this

00:07:51,069 --> 00:08:02,349
set of interfaces if implemented offers

00:07:57,240 --> 00:08:04,360
the standard boot handshake to the

00:08:02,349 --> 00:08:07,990
operating system as well as the required

00:08:04,360 --> 00:08:12,719
runtime interfaces for discovery power

00:08:07,990 --> 00:08:16,259
management and and other functions now

00:08:12,719 --> 00:08:19,330
so everything we talked about so far is

00:08:16,259 --> 00:08:20,889
server ready servers server based

00:08:19,330 --> 00:08:25,029
architecture server based boot

00:08:20,889 --> 00:08:28,719
requirements so you may ask well how is

00:08:25,029 --> 00:08:30,310
this related to the by since this this

00:08:28,719 --> 00:08:35,649
session is talking about the Raspberry

00:08:30,310 --> 00:08:38,130
Pi oh that's that's exactly what we want

00:08:35,649 --> 00:08:41,289
to get out of this session is that the

00:08:38,130 --> 00:08:44,800
the the approach the standards-based

00:08:41,289 --> 00:08:49,839
approach that was taken first in the

00:08:44,800 --> 00:08:57,630
server segment can be can equally apply

00:08:49,839 --> 00:09:00,699
in other segments where you you want to

00:08:57,630 --> 00:09:03,360
to achieve this interoperability between

00:09:00,699 --> 00:09:07,540
players including operating systems

00:09:03,360 --> 00:09:10,600
silicon manufacturers and and OEMs or

00:09:07,540 --> 00:09:16,390
device manufacturers so so think of it

00:09:10,600 --> 00:09:21,910
as standards-based rather than server

00:09:16,390 --> 00:09:26,019
based in today's beyond servers the arm

00:09:21,910 --> 00:09:32,880
ecosystem is is by nature is very

00:09:26,019 --> 00:09:35,560
diverse it covers many verticals from

00:09:32,880 --> 00:09:39,190
embedded IOT

00:09:35,560 --> 00:09:41,800
automotive it's a really a wide a wide

00:09:39,190 --> 00:09:48,089
range of devices and with that diversity

00:09:41,800 --> 00:09:48,089
of the classes of devices you have

00:09:48,270 --> 00:09:53,200
diversity and and the solutions of being

00:09:51,339 --> 00:09:56,860
the harder solutions and the firmer and

00:09:53,200 --> 00:10:01,900
even the operating systems in the

00:09:56,860 --> 00:10:08,850
embedded space even as we talk about

00:10:01,900 --> 00:10:12,250
higher end edge devices that that that

00:10:08,850 --> 00:10:15,910
have higher capabilities in in the

00:10:12,250 --> 00:10:19,660
processing power the the the ecosystem

00:10:15,910 --> 00:10:21,730
is still mostly treated as embedded

00:10:19,660 --> 00:10:25,060
devices that are vertically integrated

00:10:21,730 --> 00:10:30,610
ecosystem running custom firmware and

00:10:25,060 --> 00:10:32,410
custom operating systems usually Linux

00:10:30,610 --> 00:10:38,800
kernels that are customized for that

00:10:32,410 --> 00:10:41,320
device by having these devices behave as

00:10:38,800 --> 00:10:45,490
embedded systems with custom operating

00:10:41,320 --> 00:10:49,480
systems you lose the ability to for

00:10:45,490 --> 00:10:52,660
example get updates security patches and

00:10:49,480 --> 00:10:56,500
interoperability of adding devices and

00:10:52,660 --> 00:10:58,750
switching OSS and hardware the kind of

00:10:56,500 --> 00:11:06,670
flexibility that you have in a

00:10:58,750 --> 00:11:10,860
horizontal ecosystem like in servers so

00:11:06,670 --> 00:11:13,570
is there life can we do something about

00:11:10,860 --> 00:11:15,310
it seems that standard shouldn't be just

00:11:13,570 --> 00:11:18,550
for servers and if you look at the other

00:11:15,310 --> 00:11:24,670
architecture they clearly aren't right

00:11:18,550 --> 00:11:28,990
and at the arm tech con 2019 we saw arm

00:11:24,670 --> 00:11:31,270
extending the idea of server ready

00:11:28,990 --> 00:11:34,510
compliance or stannis compliance to

00:11:31,270 --> 00:11:36,339
other segments where conceptually it

00:11:34,510 --> 00:11:39,640
allows off-the-shelf a soft

00:11:36,339 --> 00:11:44,520
off-the-shelf system software to run on

00:11:39,640 --> 00:11:46,560
a wide range of systems now

00:11:44,520 --> 00:11:49,110
so really it's not about server

00:11:46,560 --> 00:11:50,460
requirements it's more about different

00:11:49,110 --> 00:11:54,240
kinds of standardized user system

00:11:50,460 --> 00:11:56,010
requirements for the same class of say

00:11:54,240 --> 00:11:58,140
compute elements right in this case

00:11:56,010 --> 00:12:00,690
we're talking about a what's known as

00:11:58,140 --> 00:12:02,730
the a application profile arm systems

00:12:00,690 --> 00:12:04,170
okay so what systems do we have there

00:12:02,730 --> 00:12:06,420
well we have servers okay that's pretty

00:12:04,170 --> 00:12:09,630
easy right those goes those go data

00:12:06,420 --> 00:12:13,260
centers cloud to go into infrastructure

00:12:09,630 --> 00:12:14,820
edge no work equipment then of course we

00:12:13,260 --> 00:12:17,340
have client devices so that's laptops

00:12:14,820 --> 00:12:22,560
tablets edge devices could be IOT

00:12:17,340 --> 00:12:25,020
gateways and there's no reason why today

00:12:22,560 --> 00:12:29,300
these are all wily or more or less while

00:12:25,020 --> 00:12:32,760
incompatible I can use an x86 laptop

00:12:29,300 --> 00:12:34,860
$200 thing to develop an operating

00:12:32,760 --> 00:12:36,750
system that will boot on a high-end

00:12:34,860 --> 00:12:37,200
server or an application I don't have to

00:12:36,750 --> 00:12:38,850
worry

00:12:37,200 --> 00:12:40,950
it may be implemented very differently

00:12:38,850 --> 00:12:44,250
but from the system software perspective

00:12:40,950 --> 00:12:49,560
from an IT perspective really they are

00:12:44,250 --> 00:12:53,580
equivalent and so arm they'll be pretty

00:12:49,560 --> 00:12:56,640
fantastic to have a common standard

00:12:53,580 --> 00:12:59,070
definition across a wide range of these

00:12:56,640 --> 00:13:02,640
a profile chips a profile based

00:12:59,070 --> 00:13:04,800
solutions it could be based on on the

00:13:02,640 --> 00:13:07,470
existing server ready specifications

00:13:04,800 --> 00:13:09,690
such as the SBS a in his VB are that

00:13:07,470 --> 00:13:15,560
summer talked about are the security

00:13:09,690 --> 00:13:18,870
specification now clearly servers and

00:13:15,560 --> 00:13:21,240
non service systems while they may have

00:13:18,870 --> 00:13:24,750
a large degree of commonality they will

00:13:21,240 --> 00:13:28,560
have of course places where they diverge

00:13:24,750 --> 00:13:32,820
simply by by the requirements again it's

00:13:28,560 --> 00:13:34,080
not inconceivable to imagine that you

00:13:32,820 --> 00:13:36,990
could see a common set of specifications

00:13:34,080 --> 00:13:40,020
and server and edge and climb

00:13:36,990 --> 00:13:42,960
adaptations to those that would actually

00:13:40,020 --> 00:13:46,590
go and and and be more stringent for

00:13:42,960 --> 00:13:48,930
servers maybe or relax certain aspects

00:13:46,590 --> 00:13:50,850
would you find even different different

00:13:48,930 --> 00:13:53,100
requirements for client devices where of

00:13:50,850 --> 00:13:55,470
course if you look between laptops and

00:13:53,100 --> 00:13:58,259
servers that there are different

00:13:55,470 --> 00:14:02,069
requirements there right

00:13:58,259 --> 00:14:07,319
so obviously we've heard about ebbr

00:14:02,069 --> 00:14:09,839
before it sounds like ebbr could be kind

00:14:07,319 --> 00:14:13,319
of the solution right and ebbr is the

00:14:09,839 --> 00:14:17,609
embedded base boot requirements however

00:14:13,319 --> 00:14:22,499
what ebbr accomplishes today is it

00:14:17,609 --> 00:14:25,139
basically says that the boot firmer

00:14:22,499 --> 00:14:27,809
interface should should act like efi and

00:14:25,139 --> 00:14:29,669
maybe that's real efi isn't like a

00:14:27,809 --> 00:14:33,059
full-fledged implementation such as

00:14:29,669 --> 00:14:34,439
based on tynacorp or that's a bloomin

00:14:33,059 --> 00:14:36,959
tation based on you put okay but it

00:14:34,439 --> 00:14:41,999
doesn't talk about how hardware should

00:14:36,959 --> 00:14:44,519
be interfaced or described okay and a

00:14:41,999 --> 00:14:46,410
good example of an ebbr system would be

00:14:44,519 --> 00:14:49,439
a Raspberry Pi that boots with you boot

00:14:46,410 --> 00:14:52,259
and flattened device tree right which

00:14:49,439 --> 00:14:56,399
allows an EFI OS loader such as grow up

00:14:52,259 --> 00:14:59,369
to be to be used another example that I

00:14:56,399 --> 00:15:03,029
will claim is ebbr it's just my opinion

00:14:59,369 --> 00:15:05,970
alone is something like the windows an

00:15:03,029 --> 00:15:07,230
arm laptop based around the Qualcomm 835

00:15:05,970 --> 00:15:11,609
they should be and the x2

00:15:07,230 --> 00:15:14,730
yes its efi yes it's a CPI but it's not

00:15:11,609 --> 00:15:16,679
as BSA or SBB are compliant in fact you

00:15:14,730 --> 00:15:20,009
cannot boot an OS image which hasn't

00:15:16,679 --> 00:15:22,019
been tailored to run on the Snapdragon

00:15:20,009 --> 00:15:27,480
chip alright so mine in my view that

00:15:22,019 --> 00:15:30,089
that's basically ebbr now hello quickly

00:15:27,480 --> 00:15:33,239
check check believe there's some chat

00:15:30,089 --> 00:15:34,049
messages just to make sure okay got it

00:15:33,239 --> 00:15:36,929
okay yes

00:15:34,049 --> 00:15:42,059
roughly folks are chatting about the

00:15:36,929 --> 00:15:45,689
same assembler concepts okay so all just

00:15:42,059 --> 00:15:47,399
what can we do about this right so we

00:15:45,689 --> 00:15:51,679
would like to bring standards to the

00:15:47,399 --> 00:15:55,169
edge great where should we start let's

00:15:51,679 --> 00:15:58,289
take the highest volume and cheapest

00:15:55,169 --> 00:16:02,749
platform that anybody can buy I know

00:15:58,289 --> 00:16:02,749
everybody has their own favorite arm SBC

00:16:03,319 --> 00:16:07,889
why not the Raspberry Pi it's a fifty

00:16:05,699 --> 00:16:12,030
dollar device you can buy it anywhere in

00:16:07,889 --> 00:16:15,340
the world there are no volume problems

00:16:12,030 --> 00:16:17,770
Minoo in fact even from a just an image

00:16:15,340 --> 00:16:19,090
perspective there they believe that

00:16:17,770 --> 00:16:21,790
other people out there who haven't heard

00:16:19,090 --> 00:16:25,830
about arm but they have heard about the

00:16:21,790 --> 00:16:28,600
raspberry pi also the PI presents a

00:16:25,830 --> 00:16:32,080
pretty solid ecosystem it'll be around

00:16:28,600 --> 00:16:34,630
for a while right so we are in PI for

00:16:32,080 --> 00:16:36,430
today and I can easily use the PI to you

00:16:34,630 --> 00:16:38,950
know people laugh about raspbian being

00:16:36,430 --> 00:16:40,330
32-bit there'd be too bit but still you

00:16:38,950 --> 00:16:42,040
know this value in providing a calling

00:16:40,330 --> 00:16:44,920
software ecosystem a Raspberry Pi

00:16:42,040 --> 00:16:47,290
foundation actually raspberry pi is an

00:16:44,920 --> 00:16:51,010
example of a successful vertically

00:16:47,290 --> 00:16:53,200
integrated ecosystem but you know what

00:16:51,010 --> 00:16:56,530
I'll claim is that there's only so much

00:16:53,200 --> 00:16:58,420
space for for vertically integrated

00:16:56,530 --> 00:17:01,360
ecosystem and I would say there's only

00:16:58,420 --> 00:17:04,260
space for one Apple right if you think

00:17:01,360 --> 00:17:06,850
it can be Apple probably not right and

00:17:04,260 --> 00:17:08,680
this also maybe not that much value I

00:17:06,850 --> 00:17:10,810
mean it is for a single vendor they can

00:17:08,680 --> 00:17:12,970
extract some value of being able to

00:17:10,810 --> 00:17:14,890
provide this turnkey solution but for

00:17:12,970 --> 00:17:16,360
others to be able to compete with that

00:17:14,890 --> 00:17:18,880
we have to start doing something

00:17:16,360 --> 00:17:21,160
different okay so people claim their

00:17:18,880 --> 00:17:23,560
boards out there are pie killers well in

00:17:21,160 --> 00:17:25,360
what way though a lot of them suffer

00:17:23,560 --> 00:17:27,940
from the same problem where they need a

00:17:25,360 --> 00:17:30,910
custom software stack they they're kind

00:17:27,940 --> 00:17:32,890
of a pain to reflash I won't even know

00:17:30,910 --> 00:17:35,740
they'll have any system software this

00:17:32,890 --> 00:17:37,660
mainline or upstream in two years that

00:17:35,740 --> 00:17:39,130
will run on them all right so that's the

00:17:37,660 --> 00:17:41,110
comment I'm making around you know the

00:17:39,130 --> 00:17:42,880
pile will be around for a long time some

00:17:41,110 --> 00:17:45,250
of these other boards may not actually

00:17:42,880 --> 00:17:47,410
be I have a few bricks of my own that I

00:17:45,250 --> 00:17:49,600
can't do anything with okay supplies

00:17:47,410 --> 00:17:52,840
cheap I'll be around it'll be a PI 5

00:17:49,600 --> 00:17:55,180
maybe it'll be even better nose also is

00:17:52,840 --> 00:17:56,950
a PI feasible so for those of you

00:17:55,180 --> 00:17:59,920
familiar with a Raspberry Pi

00:17:56,950 --> 00:18:02,320
they are pretty strange right so it's a

00:17:59,920 --> 00:18:05,230
system where the ARM cores take a back

00:18:02,320 --> 00:18:08,560
seat to what's known as a video core or

00:18:05,230 --> 00:18:10,210
GPU and yet the PI 4 is a lot less

00:18:08,560 --> 00:18:12,940
strange than then things have been in

00:18:10,210 --> 00:18:14,800
the past so it finally has a regular

00:18:12,940 --> 00:18:17,110
interrupt controller you know it finally

00:18:14,800 --> 00:18:19,900
uses USB 3 and actually it's a pretty

00:18:17,110 --> 00:18:24,580
standard ex-ac I so that's the regular

00:18:19,900 --> 00:18:26,740
USB 3 host controller there's a feasible

00:18:24,580 --> 00:18:30,760
pathetically claimant status compliant

00:18:26,740 --> 00:18:34,240
it may be right I mean yes a USB 3 is

00:18:30,760 --> 00:18:36,909
wired up through PCI Express but we

00:18:34,240 --> 00:18:38,649
could just pretend PCI Express doesn't

00:18:36,909 --> 00:18:40,690
exist I mean there's no physical slot so

00:18:38,649 --> 00:18:44,320
it's not as if there's any meaningful

00:18:40,690 --> 00:18:46,390
value of exposing that so maybe could do

00:18:44,320 --> 00:18:49,320
level two level three is BSA compliance

00:18:46,390 --> 00:18:52,000
right okay that's not great okay and

00:18:49,320 --> 00:18:54,580
here's where many folks might chime in

00:18:52,000 --> 00:18:57,639
and say look you know you can claim a

00:18:54,580 --> 00:19:00,340
toaster as compliant right but you lose

00:18:57,639 --> 00:19:02,860
99% of its functionality right and so

00:19:00,340 --> 00:19:05,320
okay we're not trying to you know kind

00:19:02,860 --> 00:19:08,799
of pass on a technicality the real

00:19:05,320 --> 00:19:11,260
question is what can be done today but

00:19:08,799 --> 00:19:14,200
then you know moving forward you know

00:19:11,260 --> 00:19:17,019
can we use the Raspberry Pi 4 as a good

00:19:14,200 --> 00:19:19,870
example of a good system as a good

00:19:17,019 --> 00:19:24,130
example where we can come up with that

00:19:19,870 --> 00:19:26,110
appendix for a common server sense not

00:19:24,130 --> 00:19:28,840
sort of a standardized systems and

00:19:26,110 --> 00:19:30,639
firmer specification that will actually

00:19:28,840 --> 00:19:33,309
give you say 80% or 90% of the

00:19:30,639 --> 00:19:34,809
functionality or 100% of the rest by for

00:19:33,309 --> 00:19:35,139
functionality we're clearly not there

00:19:34,809 --> 00:19:37,360
today

00:19:35,139 --> 00:19:40,899
right but we are where we are today

00:19:37,360 --> 00:19:44,110
though is that the PI should be usable

00:19:40,899 --> 00:19:46,059
kind of as BSA's VBR if you're willing

00:19:44,110 --> 00:19:47,470
just to use you know usually storage and

00:19:46,059 --> 00:19:50,230
maybe you're on board networking I mean

00:19:47,470 --> 00:19:51,700
that's not too bad right ok anyway so if

00:19:50,230 --> 00:19:54,149
we're gonna do something right we should

00:19:51,700 --> 00:19:57,669
use a platform that's cheap and common

00:19:54,149 --> 00:19:59,649
we should take a platform which is not

00:19:57,669 --> 00:20:01,299
obvious that it could be may serve

00:19:59,649 --> 00:20:02,590
already so this way it actually poses

00:20:01,299 --> 00:20:04,269
some challenges and there's some

00:20:02,590 --> 00:20:07,960
discovery in the work to be done to

00:20:04,269 --> 00:20:10,360
adapt specifications because you can't

00:20:07,960 --> 00:20:12,309
expect every single edge system or a

00:20:10,360 --> 00:20:13,539
client system do we start getting built

00:20:12,309 --> 00:20:15,580
like a server that's never going to

00:20:13,539 --> 00:20:17,950
happen so start with a system that is

00:20:15,580 --> 00:20:19,000
pretty far away from that how else

00:20:17,950 --> 00:20:21,370
should this be done it should be done

00:20:19,000 --> 00:20:23,139
out in the open community it should be

00:20:21,370 --> 00:20:27,010
an open source project it should be a

00:20:23,139 --> 00:20:29,019
kind of collaboration of equals again

00:20:27,010 --> 00:20:30,730
this should be an example to others

00:20:29,019 --> 00:20:32,820
right you want to build a Raspberry Pi

00:20:30,730 --> 00:20:36,340
killer well maybe you should focus on

00:20:32,820 --> 00:20:37,029
building something that isn't basically

00:20:36,340 --> 00:20:37,580
a dead end

00:20:37,029 --> 00:20:39,680
right

00:20:37,580 --> 00:20:43,520
a sense that hey you know I'll be able

00:20:39,680 --> 00:20:47,270
to take upstream suffer off-the-shelf

00:20:43,520 --> 00:20:49,010
RedHat Ubuntu Debian BSD and put on your

00:20:47,270 --> 00:20:51,020
board and in five years will still be

00:20:49,010 --> 00:20:54,470
usable okay so if you want to build it

00:20:51,020 --> 00:20:56,600
build a resume plug for killer then this

00:20:54,470 --> 00:20:58,430
kind of a project I'm trying to

00:20:56,600 --> 00:21:00,950
standardize at pi/4 will actually enable

00:20:58,430 --> 00:21:03,380
those okay so maybe we're talking about

00:21:00,950 --> 00:21:05,360
edge and klein but you know for those of

00:21:03,380 --> 00:21:07,870
you who are server boss why would you

00:21:05,360 --> 00:21:11,780
care so we know is a problem today still

00:21:07,870 --> 00:21:13,910
that there's not enough systems at a low

00:21:11,780 --> 00:21:16,280
enough price point for folks to start

00:21:13,910 --> 00:21:19,310
kind of kicking the tires with so we

00:21:16,280 --> 00:21:20,630
think we think about a $50 a device that

00:21:19,310 --> 00:21:22,580
kind of looks like an arm server from

00:21:20,630 --> 00:21:25,190
Sopris perspective could be actually

00:21:22,580 --> 00:21:27,890
pretty interesting right i mean 50 bucks

00:21:25,190 --> 00:21:29,420
is 50 bucks 500 bucks and all volume is

00:21:27,890 --> 00:21:30,230
exactly what it sounds like in some of

00:21:29,420 --> 00:21:33,020
these other systems out there

00:21:30,230 --> 00:21:36,620
unfortunately are like way above a

00:21:33,020 --> 00:21:40,390
thousand dollars okay finally and this

00:21:36,620 --> 00:21:44,150
is my belief is that men you may share

00:21:40,390 --> 00:21:47,060
is that there needs to be a good amount

00:21:44,150 --> 00:21:49,460
of client platforms to get that massive

00:21:47,060 --> 00:21:52,490
developers on one hand if you look at

00:21:49,460 --> 00:21:54,590
arm servers they build upon the sort of

00:21:52,490 --> 00:21:58,670
the success that arm had with the

00:21:54,590 --> 00:22:01,340
embedded mobile ecosystem right so but

00:21:58,670 --> 00:22:04,220
there's this what I call a Grand Canyon

00:22:01,340 --> 00:22:06,530
between that world of the legacy world

00:22:04,220 --> 00:22:09,650
and this new server ready world and

00:22:06,530 --> 00:22:11,930
that's that doesn't exist for the other

00:22:09,650 --> 00:22:14,180
architectures right by the time anybody

00:22:11,930 --> 00:22:18,290
for example even thought you could could

00:22:14,180 --> 00:22:20,390
build and kind of a production or you

00:22:18,290 --> 00:22:25,250
know I'll say enterprise it's a corny

00:22:20,390 --> 00:22:27,280
word Enterprise ready x86 server x86 by

00:22:25,250 --> 00:22:30,290
then had already dominated basically

00:22:27,280 --> 00:22:33,140
small businesses and home computers and

00:22:30,290 --> 00:22:34,310
at that point it was obvious the servers

00:22:33,140 --> 00:22:36,740
were just gonna be a compatible

00:22:34,310 --> 00:22:38,900
extension of everything else the arm

00:22:36,740 --> 00:22:40,910
sirs that was very different arm servers

00:22:38,900 --> 00:22:42,740
are inherently incompatible you know

00:22:40,910 --> 00:22:44,450
standardized within themselves and may

00:22:42,740 --> 00:22:47,270
be compatible to the x86 servers to

00:22:44,450 --> 00:22:49,520
degree but now we got to go back and fix

00:22:47,270 --> 00:22:51,140
this other thing right is what about

00:22:49,520 --> 00:22:51,620
Harvard for the rest of us what about

00:22:51,140 --> 00:22:54,440
all the

00:22:51,620 --> 00:22:56,300
non server hardware that needs to feed

00:22:54,440 --> 00:22:59,540
into the arm stereo system and again

00:22:56,300 --> 00:23:01,870
this will help do that okay now what

00:22:59,540 --> 00:23:05,090
could you do with as a

00:23:01,870 --> 00:23:07,970
standards-compliant Raspberry Pi well

00:23:05,090 --> 00:23:09,800
you could run as bbr and as BSA

00:23:07,970 --> 00:23:13,190
operating systems right again I'm

00:23:09,800 --> 00:23:15,140
choosing to define as PBR and as VSA

00:23:13,190 --> 00:23:16,910
here as standards compliant or then

00:23:15,140 --> 00:23:18,410
server compliant but you know even today

00:23:16,910 --> 00:23:20,960
you could you could boot summer

00:23:18,410 --> 00:23:24,070
complying OS as long as you're okay with

00:23:20,960 --> 00:23:26,390
which again with that kind of firmer

00:23:24,070 --> 00:23:30,260
should have exists it should be still

00:23:26,390 --> 00:23:33,200
able to use MBR OSS because device tree

00:23:30,260 --> 00:23:36,440
is a I would say is kind of the first

00:23:33,200 --> 00:23:38,210
class system description on the

00:23:36,440 --> 00:23:40,850
reservoir is probably one of the only

00:23:38,210 --> 00:23:42,980
systems in the world that that's

00:23:40,850 --> 00:23:44,600
available even before any from boots

00:23:42,980 --> 00:23:48,140
that's kind of cool

00:23:44,600 --> 00:23:50,160
okay so are we doing something about it

00:23:48,140 --> 00:23:53,070
let's have a look

00:23:50,160 --> 00:23:57,040
next line okay so we have the pipe for

00:23:53,070 --> 00:23:59,380
first today and where does this project

00:23:57,040 --> 00:24:01,300
start way back in 2016

00:23:59,380 --> 00:24:04,810
Microsoft actually created the first

00:24:01,300 --> 00:24:07,090
32-bit efi port of china court I put

00:24:04,810 --> 00:24:10,170
this up on github they did this as part

00:24:07,090 --> 00:24:17,260
of the row 32-bit Windows IOT core work

00:24:10,170 --> 00:24:19,240
also later that year our our the missile

00:24:17,260 --> 00:24:23,410
I apologize if I just destroyed your

00:24:19,240 --> 00:24:26,620
last name started the early work in

00:24:23,410 --> 00:24:30,820
64-bit ef5 4 PI 3 using trusted former a

00:24:26,620 --> 00:24:33,550
for PSC I of course and I I thought I'd

00:24:30,820 --> 00:24:35,800
spend a few days kind of banging it all

00:24:33,550 --> 00:24:37,840
together given that we have these io

00:24:35,800 --> 00:24:40,780
drivers on Microsoft side and I have

00:24:37,840 --> 00:24:44,110
this early port and I gotta start from

00:24:40,780 --> 00:24:46,960
that you know added use be support for

00:24:44,110 --> 00:24:49,450
pi/3 which incidentally came and belief

00:24:46,960 --> 00:24:53,040
from some phone code that Leonora was

00:24:49,450 --> 00:24:55,840
working on and then could boot PI 3

00:24:53,040 --> 00:24:57,640
Susie on the PI 364 was Susie and PI 3

00:24:55,840 --> 00:25:00,190
with device tree

00:24:57,640 --> 00:25:02,260
some folks challenged to boot windows

00:25:00,190 --> 00:25:04,480
and arm we got Windows an arm booting I

00:25:02,260 --> 00:25:06,400
work with VMware I got challenged to

00:25:04,480 --> 00:25:08,170
boot ESXi arm

00:25:06,400 --> 00:25:10,450
I kept explaining to people how you

00:25:08,170 --> 00:25:14,530
couldn't do it and I decided to actually

00:25:10,450 --> 00:25:17,920
prove myself wrong so great and the most

00:25:14,530 --> 00:25:20,580
important item here is February 2019

00:25:17,920 --> 00:25:24,220
where a gentleman my name of pbut art

00:25:20,580 --> 00:25:26,740
kindly took my code from github clean it

00:25:24,220 --> 00:25:29,470
up and started working with the tannic

00:25:26,740 --> 00:25:31,360
or indicated platforms maintainer z-- to

00:25:29,470 --> 00:25:34,000
upstream that was a massive amount of

00:25:31,360 --> 00:25:38,730
work but what that means is today you

00:25:34,000 --> 00:25:43,090
can go and build tynacorp EFI firmware

00:25:38,730 --> 00:25:47,140
for your Raspberry Pi 3 3 B 3 B plus 3 a

00:25:43,090 --> 00:25:51,550
as well actually and use it right and in

00:25:47,140 --> 00:25:53,380
in September of a year I started a joint

00:25:51,550 --> 00:25:56,230
collaboration project between via one

00:25:53,380 --> 00:25:58,720
arm that basically became this community

00:25:56,230 --> 00:26:02,559
project to add PI for support to the

00:25:58,720 --> 00:26:06,789
existing upstream PI 3 EFI support

00:26:02,559 --> 00:26:08,440
we showed this at the armed tech con and

00:26:06,789 --> 00:26:10,809
has been moving actually pretty pretty

00:26:08,440 --> 00:26:13,389
fast right so another gentleman by name

00:26:10,809 --> 00:26:15,879
of Jeremy looked and contributed pci

00:26:13,389 --> 00:26:20,009
express support for efi which meant we

00:26:15,879 --> 00:26:23,139
had USB 3 support india as well and then

00:26:20,009 --> 00:26:28,240
and last year we were doing as DB our

00:26:23,139 --> 00:26:30,460
boots of debian and that bsd even have

00:26:28,240 --> 00:26:33,730
onboard networking now both working in

00:26:30,460 --> 00:26:36,480
that bsd in linux and can even boot with

00:26:33,730 --> 00:26:39,309
a great set of limitations Windows 10

00:26:36,480 --> 00:26:41,529
and some of the recent wins there is

00:26:39,309 --> 00:26:45,129
we're getting at the onboard networking

00:26:41,529 --> 00:26:49,059
driver cleaned up and ready for EFI was

00:26:45,129 --> 00:26:52,720
developed by the net bsd arm platform

00:26:49,059 --> 00:26:56,529
guy jarred McNeil and that's they'll be

00:26:52,720 --> 00:27:00,220
up stream soon so most important place

00:26:56,529 --> 00:27:01,809
to track is our PI for - if Ida dev this

00:27:00,220 --> 00:27:05,649
is a blog we track all the releases

00:27:01,809 --> 00:27:07,809
there may be some kind of opine opinion

00:27:05,649 --> 00:27:10,960
it's there but that's where you can

00:27:07,809 --> 00:27:12,879
track exactly what works what doesn't

00:27:10,960 --> 00:27:14,830
there's a firmer Status page however

00:27:12,879 --> 00:27:16,960
Status page there's a github page as

00:27:14,830 --> 00:27:20,340
well it contains releases and bug

00:27:16,960 --> 00:27:22,389
trackers so that the github is where

00:27:20,340 --> 00:27:25,570
again we actually working completely

00:27:22,389 --> 00:27:27,970
upstream now ok so really the the

00:27:25,570 --> 00:27:29,830
branching on github is more internal

00:27:27,970 --> 00:27:33,009
private branches for people as they work

00:27:29,830 --> 00:27:35,409
and stuff but we are fully working with

00:27:33,009 --> 00:27:39,249
indicator platforms upstream and with

00:27:35,409 --> 00:27:41,470
trusted firmware upstream as well the

00:27:39,249 --> 00:27:43,570
bug trackers are kept though on P FTF

00:27:41,470 --> 00:27:48,490
which makes sense and we also publish

00:27:43,570 --> 00:27:50,470
the ACS compliance reports there here's

00:27:48,490 --> 00:27:53,379
an example of what the server already

00:27:50,470 --> 00:27:55,240
blog is about you can click on the about

00:27:53,379 --> 00:27:57,990
page that kind of gives you why it makes

00:27:55,240 --> 00:28:00,789
sense to make edge stands compliant and

00:27:57,990 --> 00:28:02,259
if people are interested about that we

00:28:00,789 --> 00:28:05,200
can maybe cover that at the end of the

00:28:02,259 --> 00:28:07,480
session and there's a status page as

00:28:05,200 --> 00:28:09,129
well for every release you can figure

00:28:07,480 --> 00:28:12,490
out basically what the bugs were fixed

00:28:09,129 --> 00:28:13,960
what bugs exist what works in the

00:28:12,490 --> 00:28:16,400
firmware what does what works in the

00:28:13,960 --> 00:28:19,910
hardware isn't being exposed to the

00:28:16,400 --> 00:28:21,340
to the operating system so what does

00:28:19,910 --> 00:28:24,890
work right that's a good question

00:28:21,340 --> 00:28:29,230
so trusted firmer pretty much all set

00:28:24,890 --> 00:28:33,350
actually PSC I CPU off was unimplemented

00:28:29,230 --> 00:28:36,320
but that CPU off not see beyond city on

00:28:33,350 --> 00:28:39,410
on was okay CPU off actually in the

00:28:36,320 --> 00:28:42,980
process of fixing that upstream support

00:28:39,410 --> 00:28:45,350
for serial ports SDI that's coming soon

00:28:42,980 --> 00:28:48,670
that's this software delegated exception

00:28:45,350 --> 00:28:51,620
a model for basically providing nm eyes

00:28:48,670 --> 00:28:55,160
device support in the FI itself we have

00:28:51,620 --> 00:28:57,260
the RNG serial ports we support kind of

00:28:55,160 --> 00:29:00,500
faking the RAM today which is backed by

00:28:57,260 --> 00:29:03,200
a file on the PI this is the code that's

00:29:00,500 --> 00:29:06,650
shared with PI 3 on the PI 4 we may be

00:29:03,200 --> 00:29:09,429
able to squeeze some space on the SPI

00:29:06,650 --> 00:29:12,380
flash chip and use some space therefore

00:29:09,429 --> 00:29:15,980
for firmer variables but that's to be

00:29:12,380 --> 00:29:18,880
done we support EFI frame buffer using

00:29:15,980 --> 00:29:25,730
basically everything the PI supports so

00:29:18,880 --> 00:29:28,150
DSi composite HDMI dpi basically if you

00:29:25,730 --> 00:29:29,929
get a rainbow screen it should work

00:29:28,150 --> 00:29:33,170
including different kinds of virtual

00:29:29,929 --> 00:29:36,710
resolutions we support the legacy is b2

00:29:33,170 --> 00:29:39,140
controller that's on type C on the PI 4

00:29:36,710 --> 00:29:43,220
of course is the regular type Ajax on

00:29:39,140 --> 00:29:45,440
the PI 3 we do support use b3 in EFI

00:29:43,220 --> 00:29:48,370
that's of course provided using the PCI

00:29:45,440 --> 00:29:53,300
Express base controller the vli chip

00:29:48,370 --> 00:29:57,080
support the eros on that's the old SDHC

00:29:53,300 --> 00:29:58,730
i4 microsd pi 3 also had there's the

00:29:57,080 --> 00:30:02,020
host controller which is not wired up to

00:29:58,730 --> 00:30:05,330
anything on the PI 4 we now have the

00:30:02,020 --> 00:30:07,370
onboard networking drive driver but of

00:30:05,330 --> 00:30:10,610
course we all can also support USB use

00:30:07,370 --> 00:30:12,920
beam X right of course picks avoiding a

00:30:10,610 --> 00:30:16,130
scuzzy Ram disks HTTP boots some are

00:30:12,920 --> 00:30:17,960
just upstream that lots of good stuff

00:30:16,130 --> 00:30:19,280
you know being able to do I scuzzy

00:30:17,960 --> 00:30:21,350
booting up I think is pretty cool

00:30:19,280 --> 00:30:23,300
actually and exhibiting a regular kind

00:30:21,350 --> 00:30:25,340
of picks a coding system descriptions

00:30:23,300 --> 00:30:28,160
you can now you can still boot device

00:30:25,340 --> 00:30:30,210
tree operating systems and we support

00:30:28,160 --> 00:30:32,490
overlays so if you describe some kind of

00:30:30,210 --> 00:30:34,560
in config dot text yep they'll work and

00:30:32,490 --> 00:30:36,960
we have very early ECPI support where we

00:30:34,560 --> 00:30:40,260
describe you b3 and the on-board

00:30:36,960 --> 00:30:42,300
networking called Gina there are quite a

00:30:40,260 --> 00:30:45,120
bit of challenges involved with

00:30:42,300 --> 00:30:48,000
supporting PCI Express of course on this

00:30:45,120 --> 00:30:51,240
board and does use b3 because of silicon

00:30:48,000 --> 00:30:54,300
box so there's a three gigabit 3 Giga by

00:30:51,240 --> 00:30:57,470
DM a limit so for boards I have forgive

00:30:54,300 --> 00:31:00,270
forgive Ram what are you gonna do

00:30:57,470 --> 00:31:02,520
finally if you look at all the what I

00:31:00,270 --> 00:31:06,120
call the legacy devices so these are all

00:31:02,520 --> 00:31:09,780
devices that are behind the GPU so PCI

00:31:06,120 --> 00:31:12,930
and Gina are not but say the MMC

00:31:09,780 --> 00:31:15,300
controllers video framework for all this

00:31:12,930 --> 00:31:17,640
stuff actually has a one gigabyte DMA

00:31:15,300 --> 00:31:20,010
limit another translation there anyway

00:31:17,640 --> 00:31:23,580
these challenges aren't things that

00:31:20,010 --> 00:31:25,380
necessarily violate standards but have

00:31:23,580 --> 00:31:26,940
never been done before or have no

00:31:25,380 --> 00:31:28,430
meaningful support in any operating

00:31:26,940 --> 00:31:35,280
system yeah that's a bit of a challenge

00:31:28,430 --> 00:31:38,850
so oh but we expose PCI Express use be

00:31:35,280 --> 00:31:41,700
using a CPI so idea is that we'll just

00:31:38,850 --> 00:31:43,560
expose again PCI is not standard on the

00:31:41,700 --> 00:31:46,860
reservoir for it so you cannot expose it

00:31:43,560 --> 00:31:49,500
as II can write in fact you also can

00:31:46,860 --> 00:31:52,370
really expose it almost ECAM it violates

00:31:49,500 --> 00:31:54,990
the alignment requirements you have to

00:31:52,370 --> 00:31:56,700
know that you can't scan before

00:31:54,990 --> 00:31:57,500
basically divide zero so that's not

00:31:56,700 --> 00:32:01,080
great

00:31:57,500 --> 00:32:03,660
also PCI Express is not cache coherent I

00:32:01,080 --> 00:32:08,280
am pretty sure somewhere in this BSA

00:32:03,660 --> 00:32:10,500
spec it talks about coherency for PCI

00:32:08,280 --> 00:32:14,190
Express maybe I'm wrong here but again

00:32:10,500 --> 00:32:17,160
it's not really standard today that's

00:32:14,190 --> 00:32:19,470
assembly that's the challenges

00:32:17,160 --> 00:32:22,560
themselves so we can just expose use b3

00:32:19,470 --> 00:32:26,670
as a straight-up a CPI device that is

00:32:22,560 --> 00:32:29,550
pretty easy and all we have to do is

00:32:26,670 --> 00:32:32,310
provide the node right in a CPI now of

00:32:29,550 --> 00:32:35,010
course if I will you know might shut off

00:32:32,310 --> 00:32:36,660
most mastering on the way out or an

00:32:35,010 --> 00:32:39,240
operating system on the way out of EFI

00:32:36,660 --> 00:32:41,910
my disable bus mastering for security

00:32:39,240 --> 00:32:43,490
reasons so again but this is easy you

00:32:41,910 --> 00:32:45,350
know a CPI unlike

00:32:43,490 --> 00:32:48,650
device tree and as this interpreted by

00:32:45,350 --> 00:32:50,420
code every everything in the method and

00:32:48,650 --> 00:32:52,970
everything for the device is a method

00:32:50,420 --> 00:32:55,490
they can can have side effects in this

00:32:52,970 --> 00:32:58,280
case we use the initialization method to

00:32:55,490 --> 00:33:01,070
go and make sure that the device is

00:32:58,280 --> 00:33:03,679
decoding and capable of doing DMA okay

00:33:01,070 --> 00:33:06,320
so when an AC when they always boots it

00:33:03,679 --> 00:33:08,540
detects this a CPI device behind the

00:33:06,320 --> 00:33:12,140
scenes the PCI device is enabled and

00:33:08,540 --> 00:33:13,220
everything just kind of works great

00:33:12,140 --> 00:33:16,600
right

00:33:13,220 --> 00:33:20,630
so with that actually that gives you

00:33:16,600 --> 00:33:22,520
working Linux ex-ac I on one gig and two

00:33:20,630 --> 00:33:25,640
big boards of course that's working for

00:33:22,520 --> 00:33:28,940
the quartz so why because of the DMA

00:33:25,640 --> 00:33:32,900
constraint now the good news the good

00:33:28,940 --> 00:33:35,510
news is that there is a way in a CPI to

00:33:32,900 --> 00:33:40,480
support this there's this concept of a

00:33:35,510 --> 00:33:43,760
DMA method being described in a a a CPI

00:33:40,480 --> 00:33:46,280
bus device so which basically describes

00:33:43,760 --> 00:33:47,929
how child devices can do DMA the

00:33:46,280 --> 00:33:53,360
constraints it describes translation

00:33:47,929 --> 00:33:55,490
describes limits today again the specs

00:33:53,360 --> 00:33:57,890
of the arm specs never talked about it

00:33:55,490 --> 00:33:59,780
and so it's been sort of sparkly

00:33:57,890 --> 00:34:02,059
implemented by several OSS but usually

00:33:59,780 --> 00:34:07,100
only in the context of PCI Express

00:34:02,059 --> 00:34:08,419
support okay so first of all of course

00:34:07,100 --> 00:34:10,520
we added an option to just boot with

00:34:08,419 --> 00:34:12,679
three gigs of ram just to let people at

00:34:10,520 --> 00:34:16,669
least use three gigs of ram on apply for

00:34:12,679 --> 00:34:18,350
so that's not ideal but the good news is

00:34:16,669 --> 00:34:22,310
that it looks like there's a like a

00:34:18,350 --> 00:34:25,639
5-line patch for linux to make USB 3

00:34:22,310 --> 00:34:28,490
work with four gigs of ram and this is

00:34:25,639 --> 00:34:31,310
by basically honoring the DMA constrains

00:34:28,490 --> 00:34:33,950
these underscore DMA method results for

00:34:31,310 --> 00:34:38,240
a CPI devices which are not part of the

00:34:33,950 --> 00:34:40,190
PCI device deck also in that bsd we have

00:34:38,240 --> 00:34:43,609
complete full support for this which is

00:34:40,190 --> 00:34:46,310
pretty good with Windows Windows does

00:34:43,609 --> 00:34:54,550
not support this sort of DMA constraints

00:34:46,310 --> 00:34:54,550
today so a lot of us got TBD and ok so

00:34:55,960 --> 00:35:02,360
way but so I guess you'll have to settle

00:34:59,840 --> 00:35:04,820
for these static pictures picture a is

00:35:02,360 --> 00:35:06,800
tynacorp booting picture B is of course

00:35:04,820 --> 00:35:10,490
stack or setup screen and then you can

00:35:06,800 --> 00:35:12,590
see that the s PCI Express works in in

00:35:10,490 --> 00:35:16,190
the EFI shell and it's enumerated the

00:35:12,590 --> 00:35:19,520
use B host controller the picture the

00:35:16,190 --> 00:35:21,860
bottom is the ESXi on running in the

00:35:19,520 --> 00:35:25,010
reservoir for with fergus of ram and

00:35:21,860 --> 00:35:26,360
last picture his picture windows running

00:35:25,010 --> 00:35:27,620
the installer in this installer you

00:35:26,360 --> 00:35:29,870
can't even do anything because again

00:35:27,620 --> 00:35:33,040
there's no way I oh no no used to be

00:35:29,870 --> 00:35:38,530
support another gentleman on on Twitter

00:35:33,040 --> 00:35:43,010
managed to run Windows 10 on the PI for

00:35:38,530 --> 00:35:46,550
using the USB using the USB to the

00:35:43,010 --> 00:35:50,060
design where to use B two drivers again

00:35:46,550 --> 00:35:51,590
using the type C port and those these

00:35:50,060 --> 00:35:54,740
are proprietary drivers from a company

00:35:51,590 --> 00:35:56,510
called MCC I and actually he only could

00:35:54,740 --> 00:35:58,430
boot with one gig of ram because that

00:35:56,510 --> 00:36:00,890
specific driver doesn't anticipate

00:35:58,430 --> 00:36:02,450
seeing physical addresses it beyond one

00:36:00,890 --> 00:36:06,740
gig

00:36:02,450 --> 00:36:09,560
so yeah now Before we jump into action

00:36:06,740 --> 00:36:11,360
on that the PI for code base is

00:36:09,560 --> 00:36:16,190
literally the same as the PI 3 code base

00:36:11,360 --> 00:36:17,630
all the works done upstream in fact was

00:36:16,190 --> 00:36:21,440
I think it's pretty exciting is that

00:36:17,630 --> 00:36:25,250
even if you don't care much about you

00:36:21,440 --> 00:36:28,700
know PI 4 and a CPI this is this EFI

00:36:25,250 --> 00:36:32,090
refer one that we have today I think is

00:36:28,700 --> 00:36:34,880
even a game changer for the PI 3 a PI 3

00:36:32,090 --> 00:36:38,150
B 4 the compute module which I hope to

00:36:34,880 --> 00:36:41,420
add support for as soon as well because

00:36:38,150 --> 00:36:43,670
it already does fix some of the sort of

00:36:41,420 --> 00:36:46,310
deployment headaches you see around say

00:36:43,670 --> 00:36:48,160
the Raspberry Pi 3 oh you have a

00:36:46,310 --> 00:36:51,650
non-standard way of now recruiting

00:36:48,160 --> 00:36:53,350
describing these settings even if you

00:36:51,650 --> 00:36:55,940
still have to use device tree for those

00:36:53,350 --> 00:36:58,900
ok summer would you like to talk about

00:36:55,940 --> 00:37:02,930
the call to action sure thanks foundry

00:36:58,900 --> 00:37:06,620
so as wrapping up this session with with

00:37:02,930 --> 00:37:09,170
the calls to action first if you would

00:37:06,620 --> 00:37:13,280
like to get involved we are

00:37:09,170 --> 00:37:16,599
King for more help of course a project

00:37:13,280 --> 00:37:19,099
is open source so if you go to the

00:37:16,599 --> 00:37:22,069
project think that that was provided in

00:37:19,099 --> 00:37:25,910
and one of the slides you could see the

00:37:22,069 --> 00:37:31,329
issues the discussions the the list of

00:37:25,910 --> 00:37:31,329
tasks that that we have for the future

00:37:31,420 --> 00:37:38,030
the actual patches are being submitted

00:37:34,369 --> 00:37:40,640
upstream to T encore ET que too so you

00:37:38,030 --> 00:37:42,410
can also review those and and and test

00:37:40,640 --> 00:37:44,960
and participate and submit your own

00:37:42,410 --> 00:37:49,640
patches like you so from from Andy's

00:37:44,960 --> 00:37:52,339
comments earlier we had multiple folks

00:37:49,640 --> 00:37:56,119
jump and developers and and help really

00:37:52,339 --> 00:37:58,069
move the project move big obstacles from

00:37:56,119 --> 00:38:03,619
from the project with with their

00:37:58,069 --> 00:38:07,400
contributions there is a chat channel on

00:38:03,619 --> 00:38:10,430
discord dedicated for this project so if

00:38:07,400 --> 00:38:13,549
you would like to join it's the our pie

00:38:10,430 --> 00:38:17,059
for UEFI dev channel on the arm

00:38:13,549 --> 00:38:22,549
developer ecosystem this code server the

00:38:17,059 --> 00:38:26,089
link for the invite is is on is on our

00:38:22,549 --> 00:38:28,970
blog you can have you can directly email

00:38:26,089 --> 00:38:34,880
under you and myself as well if if you

00:38:28,970 --> 00:38:37,670
have questions or ideas and the the the

00:38:34,880 --> 00:38:40,730
goal is is really also beyond the pie

00:38:37,670 --> 00:38:43,490
alright the the pies is the first is the

00:38:40,730 --> 00:38:47,059
most important one in this in towards

00:38:43,490 --> 00:38:50,569
getting to this code of standardized was

00:38:47,059 --> 00:38:53,089
an ecosystem support on these on these

00:38:50,569 --> 00:38:56,530
types of platforms but other interesting

00:38:53,089 --> 00:39:00,799
platforms include the the nvidia tegra

00:38:56,530 --> 00:39:04,329
say if you are and other platforms the

00:39:00,799 --> 00:39:04,329
rockchip rk3288

00:39:10,670 --> 00:39:16,790
edge type devices that are built around

00:39:13,670 --> 00:39:20,059
that associ in fact andre already has

00:39:16,790 --> 00:39:22,800
some port for for that chip to UEFI to

00:39:20,059 --> 00:39:24,630
indicate to that that needs

00:39:22,800 --> 00:39:26,760
more work and up streaming so that

00:39:24,630 --> 00:39:29,910
that's on the list

00:39:26,760 --> 00:39:34,200
and the and and what one thing one other

00:39:29,910 --> 00:39:36,360
thing to add is remember SB BR is a

00:39:34,200 --> 00:39:41,070
standard it's not about implementation

00:39:36,360 --> 00:39:45,080
so Tiano core and edk two happens to be

00:39:41,070 --> 00:39:47,610
the the mature and popular and upstream

00:39:45,080 --> 00:39:52,080
implementation of UEFI a CPI as some

00:39:47,610 --> 00:39:55,440
bias but you you can have other

00:39:52,080 --> 00:39:59,310
implementations to and and there are you

00:39:55,440 --> 00:40:02,990
boot UEFI implementations for ebbr that

00:39:59,310 --> 00:40:06,240
are focused on just getting the UEFI ABI

00:40:02,990 --> 00:40:08,490
working maybe with device three but

00:40:06,240 --> 00:40:11,820
there could also be work to add a CPI

00:40:08,490 --> 00:40:14,220
support there in fact ebbr as a standard

00:40:11,820 --> 00:40:17,280
allows for either a device your a CPI

00:40:14,220 --> 00:40:21,240
but you can even think of I'm really

00:40:17,280 --> 00:40:24,150
having SB be our compliance implemented

00:40:21,240 --> 00:40:26,760
a new boot if if that's if that's of

00:40:24,150 --> 00:40:29,190
interest to the community and finally

00:40:26,760 --> 00:40:32,670
from from arm points of view we are

00:40:29,190 --> 00:40:38,100
really working on shaping the standards

00:40:32,670 --> 00:40:41,070
to to make this this this type of enable

00:40:38,100 --> 00:40:43,830
meant more possible and using the the

00:40:41,070 --> 00:40:48,120
Raspberry Pi project and and these other

00:40:43,830 --> 00:40:50,730
potential projects as as a way to learn

00:40:48,120 --> 00:40:54,300
more about about this this type of

00:40:50,730 --> 00:40:56,820
devices and and drive changes in the

00:40:54,300 --> 00:40:59,550
standards if needed so if you are

00:40:56,820 --> 00:41:04,380
interested in the standards work we do

00:40:59,550 --> 00:41:06,900
have a consortium a committee it's

00:41:04,380 --> 00:41:10,530
called the arm server Advisory Council

00:41:06,900 --> 00:41:12,350
or server AC because that's the the arm

00:41:10,530 --> 00:41:14,940
ecosystem committee were the server

00:41:12,350 --> 00:41:18,870
standardization where SBB RS BSA were

00:41:14,940 --> 00:41:21,990
defined if you are interested in in

00:41:18,870 --> 00:41:24,270
joining you can send me a note and we

00:41:21,990 --> 00:41:26,430
can we can talk about how you can

00:41:24,270 --> 00:41:32,040
participate in under that umbrella as

00:41:26,430 --> 00:41:34,260
well yeah so again may many of you may

00:41:32,040 --> 00:41:35,610
have some thoughts you look at this you

00:41:34,260 --> 00:41:36,300
might well it's a bit of a science

00:41:35,610 --> 00:41:38,100
experiment

00:41:36,300 --> 00:41:39,660
you gotta use be three working and you

00:41:38,100 --> 00:41:44,100
know onboard networking working that's

00:41:39,660 --> 00:41:48,030
great but how will this ever work for no

00:41:44,100 --> 00:41:49,320
kind of real edge platforms where you

00:41:48,030 --> 00:41:51,300
don't want to lose all the other

00:41:49,320 --> 00:41:53,340
interfaces and how will this work for

00:41:51,300 --> 00:41:56,400
client platforms with power management

00:41:53,340 --> 00:42:01,860
and so the the arms tennis committee

00:41:56,400 --> 00:42:03,840
that Sameer point out there's this whole

00:42:01,860 --> 00:42:08,300
effort that's basically getting started

00:42:03,840 --> 00:42:10,560
right now is specifically in not about

00:42:08,300 --> 00:42:11,970
pretending that we can call everything

00:42:10,560 --> 00:42:16,550
server ready

00:42:11,970 --> 00:42:20,730
but it's about scoping out both how

00:42:16,550 --> 00:42:24,030
systems being built today or effectively

00:42:20,730 --> 00:42:26,190
sold tomorrow how those chips how much

00:42:24,030 --> 00:42:28,050
of that can be can be usable in this

00:42:26,190 --> 00:42:29,910
more Stennis compliant manner and that

00:42:28,050 --> 00:42:32,550
can go a bit into what I mean with that

00:42:29,910 --> 00:42:35,370
but and also these long-term

00:42:32,550 --> 00:42:37,170
recommendations right to go and see how

00:42:35,370 --> 00:42:40,350
these systems could evolve in the future

00:42:37,170 --> 00:42:43,290
how these chips it's pretty obvious you

00:42:40,350 --> 00:42:45,690
can just tell silicon eventers how they

00:42:43,290 --> 00:42:47,820
should go do things it's always very

00:42:45,690 --> 00:42:49,680
easy to share an opinion but in the end

00:42:47,820 --> 00:42:50,880
they're paying for it right and today

00:42:49,680 --> 00:42:52,290
they're already paying to produce these

00:42:50,880 --> 00:42:56,690
chips they're not going to randomly

00:42:52,290 --> 00:43:00,240
respond and so many ways it is about

00:42:56,690 --> 00:43:04,490
selling the silicon providers on the

00:43:00,240 --> 00:43:07,770
vision on the idea that there is no

00:43:04,490 --> 00:43:09,810
reason why they should be all doing

00:43:07,770 --> 00:43:12,720
different things for booting for example

00:43:09,810 --> 00:43:15,210
for discovering or for PCI Express or

00:43:12,720 --> 00:43:17,550
there are things that make no sense and

00:43:15,210 --> 00:43:20,430
if we can slowly guide them to that and

00:43:17,550 --> 00:43:22,140
provide them an easy way of integrating

00:43:20,430 --> 00:43:24,210
something that's where that works and

00:43:22,140 --> 00:43:26,070
that's cheap so that everybody can stand

00:43:24,210 --> 00:43:28,320
eyes on there's a large common base that

00:43:26,070 --> 00:43:31,350
can stand eyes on but there are things

00:43:28,320 --> 00:43:33,690
that are present in the edge and the

00:43:31,350 --> 00:43:36,960
client footprints that are very

00:43:33,690 --> 00:43:38,990
different from servers so for example

00:43:36,960 --> 00:43:41,520
how do you standardize power management

00:43:38,990 --> 00:43:45,350
how do you stand out so like give EFS

00:43:41,520 --> 00:43:45,350
for devices how do you guys

00:43:46,580 --> 00:43:55,170
like power on and reset blocks our reset

00:43:50,400 --> 00:43:57,060
blocks how do you stand guys GPIO and it

00:43:55,170 --> 00:44:00,720
seems like it should be right there's no

00:43:57,060 --> 00:44:02,220
reason why it shouldn't be but then it's

00:44:00,720 --> 00:44:05,460
one thing to come up with a number of

00:44:02,220 --> 00:44:07,380
directives or prescriptions for what

00:44:05,460 --> 00:44:08,640
people should do is a wholly different

00:44:07,380 --> 00:44:11,040
man to understand

00:44:08,640 --> 00:44:13,440
well can we come up with a mechanism to

00:44:11,040 --> 00:44:14,820
go and support these systems today but

00:44:13,440 --> 00:44:17,850
support them in a way that doesn't

00:44:14,820 --> 00:44:20,580
involve platform-specific drivers in the

00:44:17,850 --> 00:44:23,550
operating system so drift was teeny

00:44:20,580 --> 00:44:25,100
asked a question in zoom chat and folks

00:44:23,550 --> 00:44:29,190
have questions this is a great place to

00:44:25,100 --> 00:44:33,630
put them in like how earth could be

00:44:29,190 --> 00:44:37,340
support hat overlays so I think one nice

00:44:33,630 --> 00:44:39,240
property of device tree is that

00:44:37,340 --> 00:44:41,960
everything that can be presented in

00:44:39,240 --> 00:44:44,820
device tree can be present in a CPI and

00:44:41,960 --> 00:44:49,070
this is not magic this was done on

00:44:44,820 --> 00:44:51,990
purpose there is this notion of device

00:44:49,070 --> 00:44:54,119
specific data device tree properties

00:44:51,990 --> 00:44:58,050
it's basically a way to encode device

00:44:54,119 --> 00:45:02,700
tree properties within an ACP I am El

00:44:58,050 --> 00:45:05,070
device now so that kind of means that if

00:45:02,700 --> 00:45:06,480
your device so every device can be

00:45:05,070 --> 00:45:09,180
actually explore every device tree

00:45:06,480 --> 00:45:12,330
device can be transformed into an

00:45:09,180 --> 00:45:15,200
equivalent EML object okay and in fact

00:45:12,330 --> 00:45:18,750
there's there's even a kind of a generic

00:45:15,200 --> 00:45:21,150
ACPI device that just means go look at

00:45:18,750 --> 00:45:24,540
the device tree a compatible ID to

00:45:21,150 --> 00:45:26,190
figure out what really is ok so you can

00:45:24,540 --> 00:45:28,350
you can already kind of convert right

00:45:26,190 --> 00:45:31,530
device tree to a CPI you know in

00:45:28,350 --> 00:45:33,080
principle okay and I know that some

00:45:31,530 --> 00:45:36,810
folks with an arm I've been working on

00:45:33,080 --> 00:45:38,880
kind of creating those set of tools of

00:45:36,810 --> 00:45:40,859
course when you start doing that you

00:45:38,880 --> 00:45:42,780
want to be careful because you don't

00:45:40,859 --> 00:45:44,280
want to have different ways of

00:45:42,780 --> 00:45:45,960
describing the same thing so there's a

00:45:44,280 --> 00:45:47,790
read a CPI way of describing something

00:45:45,960 --> 00:45:49,770
that that should be adopted and that

00:45:47,790 --> 00:45:51,359
actually makes conversion tedious

00:45:49,770 --> 00:45:52,950
because now it's not just a blind

00:45:51,359 --> 00:45:55,260
conversion but yeah they haven't kind of

00:45:52,950 --> 00:45:57,660
know that you know not all objects are

00:45:55,260 --> 00:45:59,400
presenting this way some properties have

00:45:57,660 --> 00:46:00,170
to be translated in some ACPI way of

00:45:59,400 --> 00:46:03,809
doing things

00:46:00,170 --> 00:46:06,059
conceptually if our efi driver if our

00:46:03,809 --> 00:46:08,910
EFI firmware today had an I squared C

00:46:06,059 --> 00:46:11,609
driver it could detect what the PI hat

00:46:08,910 --> 00:46:14,849
was right it could basically grab that

00:46:11,609 --> 00:46:18,299
overlay right from there from the Hat

00:46:14,849 --> 00:46:20,519
itself and turn that into an ASIC a

00:46:18,299 --> 00:46:23,430
description right or if you just use DT

00:46:20,519 --> 00:46:25,849
overlays and config that text then again

00:46:23,430 --> 00:46:29,099
the system is born with that device tree

00:46:25,849 --> 00:46:31,019
if I gets that device 200 boots you know

00:46:29,099 --> 00:46:36,059
in my mind again this is a pine tree

00:46:31,019 --> 00:46:37,799
it'll be fantastic to see if I configure

00:46:36,059 --> 00:46:40,079
itself based in that device tree right

00:46:37,799 --> 00:46:43,170
so today pretty much every year five

00:46:40,079 --> 00:46:45,479
implementation I've seen it did a hard

00:46:43,170 --> 00:46:49,890
code what what device what addresses

00:46:45,479 --> 00:46:51,689
what yeah what addresses they use in the

00:46:49,890 --> 00:46:55,170
kind of cool there was some concept of

00:46:51,689 --> 00:46:56,939
like an FD T bus Dixie right an MDT bus

00:46:55,170 --> 00:46:59,729
driver that would basically go and

00:46:56,939 --> 00:47:02,279
produce all the bus bus children that

00:46:59,729 --> 00:47:04,019
will be bound by the relevant efi

00:47:02,279 --> 00:47:05,910
drivers and again since he had this

00:47:04,019 --> 00:47:07,739
description you could this is was born

00:47:05,910 --> 00:47:10,769
with it you should use it that generate

00:47:07,739 --> 00:47:14,279
a CPI I mean today we don't but you know

00:47:10,769 --> 00:47:16,469
my kind of up you know pipe dream vision

00:47:14,279 --> 00:47:19,259
is that you could have a single EFI

00:47:16,469 --> 00:47:20,759
binary that would boot on PI 3 and PI 4

00:47:19,259 --> 00:47:23,390
and for those of you who know how to

00:47:20,759 --> 00:47:26,849
different those are you kind of see that

00:47:23,390 --> 00:47:28,880
there's some work to do towards that but

00:47:26,849 --> 00:47:31,349
you know I believe you boot today

00:47:28,880 --> 00:47:34,049
supports configurations in device tree

00:47:31,349 --> 00:47:37,439
so there's no reason why not

00:47:34,049 --> 00:47:41,160
anyway so there is work to be done in

00:47:37,439 --> 00:47:42,869
figuring out what requirements client

00:47:41,160 --> 00:47:45,150
and edge systems have the different from

00:47:42,869 --> 00:47:48,420
servers and to make sure that those can

00:47:45,150 --> 00:47:51,119
be handled in a way without a platform

00:47:48,420 --> 00:47:52,920
specific drivers in fact even on servers

00:47:51,119 --> 00:47:57,479
there's already an aspect there that is

00:47:52,920 --> 00:47:59,579
a little painful for those of you who

00:47:57,479 --> 00:48:02,579
work on server ready servers you know

00:47:59,579 --> 00:48:06,689
that there's this concept of GPIO

00:48:02,579 --> 00:48:08,819
signaled a CGI system events again that

00:48:06,689 --> 00:48:13,490
relies on a GPIO driver to be present in

00:48:08,819 --> 00:48:15,770
the OS okay so yes there's an arm IP

00:48:13,490 --> 00:48:17,780
that people can use but some silicon

00:48:15,770 --> 00:48:19,610
vendors do their own thing right and

00:48:17,780 --> 00:48:20,750
again so now you have system events

00:48:19,610 --> 00:48:23,780
which I would consider to be a pretty

00:48:20,750 --> 00:48:25,670
core notion but now that's depending on

00:48:23,780 --> 00:48:27,680
a platform driver okay so that's kind of

00:48:25,670 --> 00:48:29,960
bad but then you know why do we need a

00:48:27,680 --> 00:48:32,090
special driver for GPIO can't we

00:48:29,960 --> 00:48:35,090
abstract that somehow all right so again

00:48:32,090 --> 00:48:37,040
when you talk about abstraction this is

00:48:35,090 --> 00:48:38,540
a pretty interesting topic by itself for

00:48:37,040 --> 00:48:41,150
example I had this notion that maybe

00:48:38,540 --> 00:48:46,220
maybe we could just make PCC I see my

00:48:41,150 --> 00:48:48,520
work right so by basically using the SC

00:48:46,220 --> 00:48:51,200
mind SCM I forget what it stands for

00:48:48,520 --> 00:48:55,119
system controlled management interface

00:48:51,200 --> 00:48:58,100
maybe it's basically a way by which

00:48:55,119 --> 00:49:01,280
operating system can basically in an

00:48:58,100 --> 00:49:05,200
ACPI way use shared memory to talk to

00:49:01,280 --> 00:49:07,850
system control CPU system system control

00:49:05,200 --> 00:49:09,500
processor right but then again like what

00:49:07,850 --> 00:49:11,840
if that could be done and trusted firmer

00:49:09,500 --> 00:49:13,790
ok well some vendors don't like the idea

00:49:11,840 --> 00:49:16,940
of putting more stuff in trusted firmer

00:49:13,790 --> 00:49:18,710
because it kind of ruins the perception

00:49:16,940 --> 00:49:19,850
of the kind of the root of trust right

00:49:18,710 --> 00:49:22,280
you don't want to have too much code

00:49:19,850 --> 00:49:24,320
there anyway there's possibly many

00:49:22,280 --> 00:49:26,450
different approaches imagine if we got

00:49:24,320 --> 00:49:29,359
the pipe Raspberry Pi foundation people

00:49:26,450 --> 00:49:32,000
on board there's no reason why the video

00:49:29,359 --> 00:49:34,130
core processor is implementing the

00:49:32,000 --> 00:49:35,869
mailbox the way does today what if it

00:49:34,130 --> 00:49:38,180
employ what if it implemented SCM I

00:49:35,869 --> 00:49:41,450
write if the VP you was actually eating

00:49:38,180 --> 00:49:44,930
SC my command says to to communicate

00:49:41,450 --> 00:49:46,460
then again we could completely actually

00:49:44,930 --> 00:49:49,670
hide this without using even trusted

00:49:46,460 --> 00:49:52,310
former there's questions about how how

00:49:49,670 --> 00:49:55,670
or should if we had all abstract PCI

00:49:52,310 --> 00:49:58,190
Express access for edge SBC's I mean

00:49:55,670 --> 00:50:00,530
everybody gets PCI Express wrong but

00:49:58,190 --> 00:50:04,100
when you look at SBC's it's a special

00:50:00,530 --> 00:50:06,590
kind of hell because yeah it's not even

00:50:04,100 --> 00:50:08,690
close to ECAM it's like random registers

00:50:06,590 --> 00:50:11,450
and you write your bus to this and your

00:50:08,690 --> 00:50:14,140
device to that then you use 32-bit only

00:50:11,450 --> 00:50:16,550
accesses and then maybe maybe it'll work

00:50:14,140 --> 00:50:17,930
if you when you look at all of this you

00:50:16,550 --> 00:50:20,690
know like well I'd love for people to

00:50:17,930 --> 00:50:22,430
adopt ECAM but what if I have a fallback

00:50:20,690 --> 00:50:24,290
that's basically a trusted firmer

00:50:22,430 --> 00:50:26,390
interface for that and there is a

00:50:24,290 --> 00:50:27,050
precedent you know the Itanium did this

00:50:26,390 --> 00:50:30,400
with

00:50:27,050 --> 00:50:33,770
the system abstraction layer cell and

00:50:30,400 --> 00:50:36,500
the open power echo system does this

00:50:33,770 --> 00:50:38,510
today with opal opal is the firmer but I

00:50:36,500 --> 00:50:40,400
mean conceptually opal is more like if I

00:50:38,510 --> 00:50:44,600
run fence services it's not really a

00:50:40,400 --> 00:50:46,880
separate privilege like trust firmer so

00:50:44,600 --> 00:50:49,130
and actually you know if you're gonna

00:50:46,880 --> 00:50:51,830
put random runtime interfaces you know

00:50:49,130 --> 00:50:54,830
trusted firm is one place EFI runtime

00:50:51,830 --> 00:50:57,110
services is another so all these options

00:50:54,830 --> 00:51:01,190
on the table we'd love to see

00:50:57,110 --> 00:51:02,630
contributions in the space because I

00:51:01,190 --> 00:51:04,610
think it's pretty clear we have to

00:51:02,630 --> 00:51:07,580
figure out how to make non server

00:51:04,610 --> 00:51:09,170
systems become boring as well and not

00:51:07,580 --> 00:51:11,450
just boring kind of in their own little

00:51:09,170 --> 00:51:14,210
world but in a way where it keeps

00:51:11,450 --> 00:51:16,790
feeding the server systems as well so it

00:51:14,210 --> 00:51:21,110
has to be compatible to some level some

00:51:16,790 --> 00:51:23,540
error and any parting thoughts I think

00:51:21,110 --> 00:51:26,600
that's that's good if anyone have

00:51:23,540 --> 00:51:28,820
questions it would like to join us

00:51:26,600 --> 00:51:31,820
yeah the discourse of the armed

00:51:28,820 --> 00:51:35,090
developer ecosystem disco server is a

00:51:31,820 --> 00:51:36,860
great place how do you get to that go to

00:51:35,090 --> 00:51:39,530
the website our PI for you fight that

00:51:36,860 --> 00:51:43,660
death and then there'll be a link there

00:51:39,530 --> 00:51:46,760
that link is actually an invite and so

00:51:43,660 --> 00:51:48,530
click on that create an account and then

00:51:46,760 --> 00:51:52,120
you'll have to manually navigate today

00:51:48,530 --> 00:51:53,840
like pound our PI for - efi - dev

00:51:52,120 --> 00:51:55,910
unfortunately there's no easy way to

00:51:53,840 --> 00:51:58,790
create a link to channel on this core

00:51:55,910 --> 00:52:01,430
server but that's basically what all the

00:51:58,790 --> 00:52:05,480
development happens so looking forward

00:52:01,430 --> 00:52:08,380
to seeing there alright thanks everybody

00:52:05,480 --> 00:52:08,380

YouTube URL: https://www.youtube.com/watch?v=JTtUbUcXqk0


