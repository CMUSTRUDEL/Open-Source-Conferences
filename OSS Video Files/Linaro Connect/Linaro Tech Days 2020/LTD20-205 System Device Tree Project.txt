Title: LTD20-205 System Device Tree Project
Publication date: 2020-04-01
Playlist: Linaro Tech Days 2020
Description: 
	Description: 
Today's heterogeneous SoCs are very hard to configure. Issues such as which cores, memory and devices belong to which operating systems, hypervisors and firmware is done in an ad-hoc, error prone way. Even harder is to set up shared resources, e.g. shared pages for virtio.

System Device Trees will change all that by extending today's device trees, used by Linux, Xen, U-Boot, etc. to describe the full system and also include configuration information on what belongs where. This will enable any operating environment, including open source and proprietary Real-Time Operating Systems to be configured form one true source. System Device Trees are part of the Linaro Device Tree Evolution Project.

This talk will discuss the progress that has been made up to date, both in terms of specification as well as tooling. The open source Lopper tool will be demonstrated with different backends to show how to "prune" the System Device Tree to a traditional Device Tree as well as generating "#define" information usable for an RTOS.

Session Speakers
Stefano Stabellini
Principal Engineer (Xilinx)

Stefano Stabellini serves as system software architect and virtualization lead at Xilinx, the world\'s largest supplier of FPGA solutions. Previously, at Aporeto, he created a virtualization-based security solution for containers and authored several security articles. As Senior Principal Software Engineer in Citrix, he led a small group of passionate engineers working on Open Source projects. Stefano has been involved in Xen development since 2007. He created libxenlight in November 2009 and started the Xen port to ARM with virtualization extensions in 2011. Today he is a Xen Project committer, and he maintains Xen on ARM and Xen support in Linux and QEMU.
Bruce Ashfield
Principal System Software Engineer (Xilinx)

Bruce has worked in embedded software and linux for 20 years and has a variety of technical areas of interest. Ranging from kernel to virtualization/containers and edge system design.
Tomas Evensen
CTO Embedded SW - Xilinx

Tomas Evensen is Chief Technology Officer, Embedded Software at Xilinx. In this role he is responsible for the embedded software strategy for Xilinx All Programmable SoCs. Prior to joining Xilinx, Evensen was Chief Technology Officer at Wind River for 7 years, as well as GM for the Wind River Tools Division and VP of Engineering for the VxWorks operating system. Before that he was the creator of the Diab Data C/C++ compilers. Evensen received his MSEE at the Royal Institute of Technology in Stockholm, Sweden.



You view this sessions presentation here:
https://connect.linaro.org/resources/ltd20/ltd20-205/
Captions: 
	00:00:00,590 --> 00:00:06,080
all right so let's get started here so

00:00:03,819 --> 00:00:08,270
good morning good afternoon good evening

00:00:06,080 --> 00:00:10,580
everyone my name is Thomas Evans and I'm

00:00:08,270 --> 00:00:13,490
from silence I'm going to talk about

00:00:10,580 --> 00:00:16,190
system device trees today together with

00:00:13,490 --> 00:00:18,589
stefano of stability and gross Ashfield

00:00:16,190 --> 00:00:19,990
so we have lots of material so we'll go

00:00:18,589 --> 00:00:22,910
through this pretty quickly here

00:00:19,990 --> 00:00:24,679
obviously the slides are uploaded and

00:00:22,910 --> 00:00:27,499
there's some contact information at the

00:00:24,679 --> 00:00:30,859
end if you want to engage in this the

00:00:27,499 --> 00:00:32,900
way we have set up this is an informal

00:00:30,859 --> 00:00:35,390
frequently asked questions so instead of

00:00:32,900 --> 00:00:36,680
going through all the various slides and

00:00:35,390 --> 00:00:39,140
we've been doing that in various

00:00:36,680 --> 00:00:41,240
contexts before we thought that instead

00:00:39,140 --> 00:00:43,790
we will mix it up a little bit then and

00:00:41,240 --> 00:00:45,440
answer some questions around device

00:00:43,790 --> 00:00:47,420
trees and the first ones are more

00:00:45,440 --> 00:00:48,950
general and would serve as an

00:00:47,420 --> 00:00:52,190
introduction to the system device rates

00:00:48,950 --> 00:00:53,840
as well out there all right great so

00:00:52,190 --> 00:00:57,590
first question here what is the system

00:00:53,840 --> 00:01:00,650
device James if you come to the next one

00:00:57,590 --> 00:01:05,030
there the system device tree really

00:01:00,650 --> 00:01:08,539
trying to to solve the problem of how do

00:01:05,030 --> 00:01:11,259
we get hardware information to the

00:01:08,539 --> 00:01:15,469
software stacks so in particular

00:01:11,259 --> 00:01:17,780
operating systems firmware hypervisors

00:01:15,469 --> 00:01:21,109
those kind of things that need to know

00:01:17,780 --> 00:01:23,090
about where is the memory what memory is

00:01:21,109 --> 00:01:26,149
allocated to me where are all the

00:01:23,090 --> 00:01:29,560
devices where are they mapped in memory

00:01:26,149 --> 00:01:32,899
the interrupt so on so forth right and

00:01:29,560 --> 00:01:34,880
in particular these new systems are out

00:01:32,899 --> 00:01:38,090
there now are very heterogeneous so you

00:01:34,880 --> 00:01:40,729
have multiple processors and they have

00:01:38,090 --> 00:01:43,520
multiple execution environments so you

00:01:40,729 --> 00:01:46,159
might have a Linux running at the same

00:01:43,520 --> 00:01:49,130
time as an autos at the same time as a

00:01:46,159 --> 00:01:51,170
hypervisor and so on so forth and so we

00:01:49,130 --> 00:01:53,389
need to come up with a way on how do we

00:01:51,170 --> 00:01:58,459
get all this kind of information to

00:01:53,389 --> 00:02:01,429
these different software stacks and this

00:01:58,459 --> 00:02:04,100
is really tricky to do in in general and

00:02:01,429 --> 00:02:06,799
in the past it's being done in an ad hoc

00:02:04,100 --> 00:02:09,590
way so what we really might need here is

00:02:06,799 --> 00:02:12,039
a standard way of doing it if you go to

00:02:09,590 --> 00:02:12,039
the next slide

00:02:13,490 --> 00:02:20,420
and since there already is a standard

00:02:18,650 --> 00:02:24,440
that really serves as well which is

00:02:20,420 --> 00:02:27,560
device trees used by Linux you vote Xen

00:02:24,440 --> 00:02:31,400
hypervisor and other things what we

00:02:27,560 --> 00:02:34,010
wanted to do was to extend that to be

00:02:31,400 --> 00:02:37,340
able to handle multiple different

00:02:34,010 --> 00:02:39,740
environments at the same time so we're

00:02:37,340 --> 00:02:42,470
extending the device trees backwards

00:02:39,740 --> 00:02:45,980
compatible so that you can have multiple

00:02:42,470 --> 00:02:48,860
CPU clusters and you can define how we

00:02:45,980 --> 00:02:51,920
want to share things and we really have

00:02:48,860 --> 00:02:54,110
two different parts here one is adding

00:02:51,920 --> 00:02:56,270
to the traditional device tree

00:02:54,110 --> 00:02:58,940
specification so you can add new CPU

00:02:56,270 --> 00:03:01,970
clusters and their views of the

00:02:58,940 --> 00:03:04,250
addressing space and so on and then

00:03:01,970 --> 00:03:07,690
we're also adding a section so that you

00:03:04,250 --> 00:03:10,490
can define the allocation of resources

00:03:07,690 --> 00:03:12,740
so let's say that you want to have one

00:03:10,490 --> 00:03:15,740
gig of memory going to the your Linux

00:03:12,740 --> 00:03:17,750
and another gig going to your your are

00:03:15,740 --> 00:03:21,110
toast or you want to have the NIC

00:03:17,750 --> 00:03:25,490
assigned to the Otto's but the your

00:03:21,110 --> 00:03:27,470
design assigned to to the Linux so

00:03:25,490 --> 00:03:29,630
there's a way then to specify those

00:03:27,470 --> 00:03:31,130
things so those are the two section are

00:03:29,630 --> 00:03:33,260
we're trying to separate that a little

00:03:31,130 --> 00:03:35,900
bit so one is the motorway describing

00:03:33,260 --> 00:03:38,390
the hardware and the other one is more

00:03:35,900 --> 00:03:42,260
about how do you configure it how do you

00:03:38,390 --> 00:03:46,910
allocate the resources all right the

00:03:42,260 --> 00:03:48,500
next one as part of this we are going to

00:03:46,910 --> 00:03:50,420
talk about something we call execution

00:03:48,500 --> 00:03:51,950
domain so it's going to talk a little

00:03:50,420 --> 00:03:58,880
bit about that here if you go to the

00:03:51,950 --> 00:04:01,460
next one it's an execution domain pretty

00:03:58,880 --> 00:04:03,140
simple concept in general it's you can

00:04:01,460 --> 00:04:05,180
view it as an address space that's

00:04:03,140 --> 00:04:07,640
unique and different from from other

00:04:05,180 --> 00:04:11,090
things so for example in Linux kernel

00:04:07,640 --> 00:04:13,220
has a an address space so that would be

00:04:11,090 --> 00:04:15,950
one execution domain if you have a

00:04:13,220 --> 00:04:17,690
hypervisor like the Zen well it's

00:04:15,950 --> 00:04:19,700
running on the same CPU but it actually

00:04:17,690 --> 00:04:22,130
has a different view on the memory and

00:04:19,700 --> 00:04:24,530
the devices so that would be a different

00:04:22,130 --> 00:04:26,960
execution domain so an execution domain

00:04:24,530 --> 00:04:29,660
could be running

00:04:26,960 --> 00:04:32,930
a separate core for example if you have

00:04:29,660 --> 00:04:36,979
a cortex-m or cortex or versus a cortex

00:04:32,930 --> 00:04:39,259
84 or multiple clusters it could be on

00:04:36,979 --> 00:04:41,419
the same core but that you have

00:04:39,259 --> 00:04:43,310
different execution levels so the user

00:04:41,419 --> 00:04:45,319
space versus operating system and

00:04:43,310 --> 00:04:48,650
hypervisor and the trusted firmware and

00:04:45,319 --> 00:04:52,160
so on and you also have a way of

00:04:48,650 --> 00:04:54,139
dividing or other space using trust zone

00:04:52,160 --> 00:04:56,599
so the trusted execution environment

00:04:54,139 --> 00:05:00,710
would be for example in a different

00:04:56,599 --> 00:05:04,580
domain then the earlier looks as an

00:05:00,710 --> 00:05:07,310
example so the domain is really the abs

00:05:04,580 --> 00:05:09,860
based view of the memory and an

00:05:07,310 --> 00:05:11,840
operating environment it's really the

00:05:09,860 --> 00:05:16,250
open system or firmware or hypervisor

00:05:11,840 --> 00:05:19,070
that's running within that context okay

00:05:16,250 --> 00:05:23,630
over to the next and I think Stefano you

00:05:19,070 --> 00:05:25,220
take over here right so what's the

00:05:23,630 --> 00:05:29,539
difference between system device tree

00:05:25,220 --> 00:05:31,370
and device tree so concretely system

00:05:29,539 --> 00:05:34,789
device tree needs to be able to describe

00:05:31,370 --> 00:05:36,650
more to describe food platform with the

00:05:34,789 --> 00:05:38,720
thorough general CPU clusters for

00:05:36,650 --> 00:05:42,289
instance a platform with the cortex a

00:05:38,720 --> 00:05:44,509
cluster and the cortex are cluster and

00:05:42,289 --> 00:05:47,840
also to describe execution domains

00:05:44,509 --> 00:05:50,979
integrated the Thomas just introduced

00:05:47,840 --> 00:05:54,580
them so for the first set of

00:05:50,979 --> 00:05:56,630
descriptions of the hardware description

00:05:54,580 --> 00:05:58,940
actually we can do everything with these

00:05:56,630 --> 00:06:00,740
three new concepts so these are three

00:05:58,940 --> 00:06:03,830
new additions to the device tree spec

00:06:00,740 --> 00:06:06,650
that allow us to describe these

00:06:03,830 --> 00:06:09,020
authoritarian systems so one is CPU

00:06:06,650 --> 00:06:11,659
cluster of course you need a way to take

00:06:09,020 --> 00:06:13,729
to explain to describe there is more

00:06:11,659 --> 00:06:15,710
than once if you cluster and that is

00:06:13,729 --> 00:06:19,009
what is attributes if you cluster is

00:06:15,710 --> 00:06:21,770
four then it might be that certain

00:06:19,009 --> 00:06:25,130
resources a bus a device is only

00:06:21,770 --> 00:06:27,710
accessible is only wired to one of the

00:06:25,130 --> 00:06:28,280
c2c few clusters one of the many CPU

00:06:27,710 --> 00:06:30,349
clusters

00:06:28,280 --> 00:06:32,630
that's why we have been the rest in the

00:06:30,349 --> 00:06:34,340
red path which is a new type of bus it

00:06:32,630 --> 00:06:35,839
does not automatically map to the pilot

00:06:34,340 --> 00:06:39,830
address space means that is not

00:06:35,839 --> 00:06:40,550
automatically visible and address map is

00:06:39,830 --> 00:06:42,919
too

00:06:40,550 --> 00:06:45,020
explicitly map these resources like

00:06:42,919 --> 00:06:47,509
indirect buses so that you can

00:06:45,020 --> 00:06:49,400
explicitly say this resource is actually

00:06:47,509 --> 00:06:51,949
visible from this domain and not from

00:06:49,400 --> 00:06:55,039
the other so I'm gonna show you a

00:06:51,949 --> 00:06:58,129
concrete example so here we have still

00:06:55,039 --> 00:07:00,259
your you know the usual CPU cluster the

00:06:58,129 --> 00:07:03,139
default cluster would be the cortex a

00:07:00,259 --> 00:07:05,810
cluster where Linux run for instance and

00:07:03,139 --> 00:07:08,840
then we have another cluster here a

00:07:05,810 --> 00:07:14,000
cortex r5 cluster which is compatible

00:07:08,840 --> 00:07:15,650
CPUs cluster and finally we have a bus

00:07:14,000 --> 00:07:18,470
and indirect bus so the idea is that

00:07:15,650 --> 00:07:21,590
this bus is only visible by the r5

00:07:18,470 --> 00:07:23,780
cluster so to do that we specify the

00:07:21,590 --> 00:07:26,270
seizing the red bus is compatible to

00:07:23,780 --> 00:07:29,300
indirect pass of course and also we

00:07:26,270 --> 00:07:31,370
explicitly mapped into the cortex our

00:07:29,300 --> 00:07:34,190
cluster address space using the address

00:07:31,370 --> 00:07:35,780
mass property because it was non map

00:07:34,190 --> 00:07:37,340
there is no other smart property into

00:07:35,780 --> 00:07:39,979
the whole cluster there could be but

00:07:37,340 --> 00:07:44,289
it's not used then the bus is not

00:07:39,979 --> 00:07:46,880
feasible to their default cluster so

00:07:44,289 --> 00:07:49,069
speaking of default clusters so one

00:07:46,880 --> 00:07:51,770
question you might have why still have

00:07:49,069 --> 00:07:54,229
it I mean if we go back in you can see I

00:07:51,770 --> 00:07:57,199
mean clearly we could have described the

00:07:54,229 --> 00:07:59,029
system using Shu CPU clusters or in the

00:07:57,199 --> 00:08:02,569
new way right I mean these new

00:07:59,029 --> 00:08:04,190
compatible string well one reason is

00:08:02,569 --> 00:08:07,940
that it's actually convenient to have

00:08:04,190 --> 00:08:10,009
one default that owns everything but

00:08:07,940 --> 00:08:11,750
everything is assigned by default it's

00:08:10,009 --> 00:08:13,550
also very common in many configuration

00:08:11,750 --> 00:08:17,930
when there is a Linux system that has

00:08:13,550 --> 00:08:20,210
all resources except for a few but also

00:08:17,930 --> 00:08:23,389
this is more subtle but maybe more

00:08:20,210 --> 00:08:25,819
important it really turns cisternae tree

00:08:23,389 --> 00:08:28,400
into a natural addition on top of the

00:08:25,819 --> 00:08:31,400
battery it makes it much easier and

00:08:28,400 --> 00:08:34,969
simpler to introduce these new concepts

00:08:31,400 --> 00:08:36,829
I wanna just discussed on top of the

00:08:34,969 --> 00:08:40,000
regular device tree specification and

00:08:36,829 --> 00:08:42,919
add them themselves to the specification

00:08:40,000 --> 00:08:44,240
finally it gives us a chance to maintain

00:08:42,919 --> 00:08:48,440
backward compatibility with existing

00:08:44,240 --> 00:08:51,050
system so with the default CPU cluster

00:08:48,440 --> 00:08:53,000
it is conceivable to produce a system

00:08:51,050 --> 00:08:53,449
device tree described more than one

00:08:53,000 --> 00:08:54,060
cluster

00:08:53,449 --> 00:08:59,280
Basti

00:08:54,060 --> 00:09:01,230
we're Linux is able to boot all right so

00:08:59,280 --> 00:09:03,660
there are a number of questions and we

00:09:01,230 --> 00:09:05,370
usually get on system device tree and

00:09:03,660 --> 00:09:07,920
one on one of the top one is how do we

00:09:05,370 --> 00:09:09,480
describe interrupts so you know you just

00:09:07,920 --> 00:09:12,150
use these three new concept there is

00:09:09,480 --> 00:09:14,430
nothing about interrupts there so let's

00:09:12,150 --> 00:09:18,480
start by explaining out will describe

00:09:14,430 --> 00:09:21,030
interrupt controllers so in in a literal

00:09:18,480 --> 00:09:22,830
general system typically like the one we

00:09:21,030 --> 00:09:24,990
are using as an example with the cortex

00:09:22,830 --> 00:09:26,550
our cluster in the cortex a cluster each

00:09:24,990 --> 00:09:29,670
cluster is gonna have his own private

00:09:26,550 --> 00:09:31,710
internal controller and to be able to

00:09:29,670 --> 00:09:33,210
describe that we need to be able to show

00:09:31,710 --> 00:09:35,730
that one internal controller is only

00:09:33,210 --> 00:09:37,080
visible by one cluster and the only the

00:09:35,730 --> 00:09:39,870
other interrupt controller is only

00:09:37,080 --> 00:09:42,390
visible by the other cluster and we do

00:09:39,870 --> 00:09:45,060
that using the same address map and the

00:09:42,390 --> 00:09:50,220
internet bus trick that we use before so

00:09:45,060 --> 00:09:53,160
in this example the cortex are interrupt

00:09:50,220 --> 00:09:56,430
controller is underneath the bus which

00:09:53,160 --> 00:09:59,910
is only mapped by the cortex our cluster

00:09:56,430 --> 00:10:02,520
vice versa the cortex a cluster

00:09:59,910 --> 00:10:04,530
interrupt controller is under a normal

00:10:02,520 --> 00:10:06,240
simple bus that means it's gonna

00:10:04,530 --> 00:10:08,490
automatically translate to the parent

00:10:06,240 --> 00:10:11,490
outer space so the default cluster blue

00:10:08,490 --> 00:10:13,380
see the quarter the cortex our cluster

00:10:11,490 --> 00:10:15,960
will not see it because it's not

00:10:13,380 --> 00:10:18,150
explicitly map using the address map

00:10:15,960 --> 00:10:20,580
property so this is the technique that

00:10:18,150 --> 00:10:24,360
is generally applicable and you can use

00:10:20,580 --> 00:10:26,460
it to describe any kind of resources

00:10:24,360 --> 00:10:28,620
that are only visible when one of the

00:10:26,460 --> 00:10:30,690
cluster not visible by the other cluster

00:10:28,620 --> 00:10:34,200
or or a by a subset of clusters to

00:10:30,690 --> 00:10:36,590
really describe how the whole board has

00:10:34,200 --> 00:10:38,910
been wired

00:10:36,590 --> 00:10:41,460
what about interrupts themselves this

00:10:38,910 --> 00:10:43,470
was about interrupt controllers so

00:10:41,460 --> 00:10:45,900
typically what we want to show is a

00:10:43,470 --> 00:10:48,720
resource as interrupt good that I were

00:10:45,900 --> 00:10:50,880
to go to both interrupt controllers and

00:10:48,720 --> 00:10:53,130
then you know depending on configuration

00:10:50,880 --> 00:10:56,040
only one of the two clusters my still

00:10:53,130 --> 00:10:58,470
receive the interest but I'm worried it

00:10:56,040 --> 00:11:00,930
goes to both and we can do that you'll

00:10:58,470 --> 00:11:04,170
in the existing standard properties in

00:11:00,930 --> 00:11:06,510
the in trauma in the inter mark mask and

00:11:04,170 --> 00:11:07,680
interrupt map pass through this is the

00:11:06,510 --> 00:11:09,750
way that describes

00:11:07,680 --> 00:11:12,050
three specification today so this is not

00:11:09,750 --> 00:11:14,580
new and this is saying that basically

00:11:12,050 --> 00:11:18,870
this canvas interrupts which I picked

00:11:14,580 --> 00:11:20,760
just as an example it goes to both as

00:11:18,870 --> 00:11:22,290
two parents interrupt controllers so it

00:11:20,760 --> 00:11:24,149
goes to both the interrupt controller of

00:11:22,290 --> 00:11:29,700
the a cluster and to the interrupt

00:11:24,149 --> 00:11:34,920
controller of the our cluster all right

00:11:29,700 --> 00:11:38,550
so these tell us how to describe most

00:11:34,920 --> 00:11:41,790
hardware configurations and but what

00:11:38,550 --> 00:11:44,459
about how we configure the system the

00:11:41,790 --> 00:11:47,010
software the film were to assign

00:11:44,459 --> 00:11:48,420
resources to dedicate resources to CPU

00:11:47,010 --> 00:11:50,880
clusters so this is not about wiring

00:11:48,420 --> 00:11:54,720
this is about the execution domain

00:11:50,880 --> 00:11:57,930
configuration so let's look in details

00:11:54,720 --> 00:12:01,380
about about execution domains so the

00:11:57,930 --> 00:12:04,800
idea is domain as specified where you

00:12:01,380 --> 00:12:05,730
know which CPUs is is related to so

00:12:04,800 --> 00:12:08,940
where the software is running

00:12:05,730 --> 00:12:11,850
specifically what memory region are

00:12:08,940 --> 00:12:14,490
dedicated to them and what devices are

00:12:11,850 --> 00:12:16,920
dedicated the way is described is using

00:12:14,490 --> 00:12:19,920
this format there is a CPU attribute

00:12:16,920 --> 00:12:22,190
that tell us which are the CPUs where

00:12:19,920 --> 00:12:24,959
the software is running on in this case

00:12:22,190 --> 00:12:28,170
cortex our cluster there can be such a

00:12:24,959 --> 00:12:30,990
flux to explain also to describe the

00:12:28,170 --> 00:12:35,130
execution mode lockstep not lost that

00:12:30,990 --> 00:12:37,650
and also there is a fusion level then a

00:12:35,130 --> 00:12:40,410
memory attribute that tell us which

00:12:37,650 --> 00:12:42,450
memory region have been dedicated to the

00:12:40,410 --> 00:12:45,300
execution domain that it can be more

00:12:42,450 --> 00:12:48,180
than one range like in this example the

00:12:45,300 --> 00:12:49,620
second range is just one page in it is

00:12:48,180 --> 00:12:52,200
meant to show that you can use this

00:12:49,620 --> 00:12:54,660
simple technique also to describe shared

00:12:52,200 --> 00:12:57,570
memory regions between a multiple

00:12:54,660 --> 00:12:59,579
execution domains that way you can set

00:12:57,570 --> 00:13:02,880
up a page with a ring buffer for

00:12:59,579 --> 00:13:05,700
communication and finally maybe most

00:13:02,880 --> 00:13:07,680
important is the access list the access

00:13:05,700 --> 00:13:12,000
list is a list of links to resources

00:13:07,680 --> 00:13:14,490
that can be accessed by this by this

00:13:12,000 --> 00:13:17,910
exclusion domain possibly only uniquely

00:13:14,490 --> 00:13:21,110
accessible by execution domain so before

00:13:17,910 --> 00:13:23,600
I dig more into what that means

00:13:21,110 --> 00:13:25,610
I would like to point out that we in

00:13:23,600 --> 00:13:28,339
this example there is a new top-level

00:13:25,610 --> 00:13:30,680
node called domains the purpose of that

00:13:28,339 --> 00:13:33,620
is to collect all these execution domain

00:13:30,680 --> 00:13:35,750
configurations so given that these are

00:13:33,620 --> 00:13:37,149
software and pyramid configuration it's

00:13:35,750 --> 00:13:40,130
good to keep them separate and

00:13:37,149 --> 00:13:42,829
originally the word we were proposing

00:13:40,130 --> 00:13:45,170
you know adding them under the chosen

00:13:42,829 --> 00:13:47,300
node however for reason that would

00:13:45,170 --> 00:13:50,360
become apparent soon

00:13:47,300 --> 00:13:53,380
and so it's defeasible it's cleaner and

00:13:50,360 --> 00:13:56,510
better and better to have them separate

00:13:53,380 --> 00:13:58,430
all right so how do we configure bath

00:13:56,510 --> 00:14:00,260
firewalls so often in order to dedicate

00:13:58,430 --> 00:14:03,410
if you really want to dedicate and

00:14:00,260 --> 00:14:05,990
protect a device you really need to

00:14:03,410 --> 00:14:08,930
configure the bus firewall to do it so

00:14:05,990 --> 00:14:11,779
the idea is that out of the information

00:14:08,930 --> 00:14:14,000
on the system device tree in the

00:14:11,779 --> 00:14:16,550
execution domain configuration it is

00:14:14,000 --> 00:14:18,440
possible to generate the bus firewall

00:14:16,550 --> 00:14:20,810
configuration so this is information the

00:14:18,440 --> 00:14:24,019
bus fan will need just not in the format

00:14:20,810 --> 00:14:26,329
the bus file will need it so the idea is

00:14:24,019 --> 00:14:29,450
there - you know we could write a

00:14:26,329 --> 00:14:30,470
plug-in from Lotter the tool that Bruce

00:14:29,450 --> 00:14:32,899
will introduce soon

00:14:30,470 --> 00:14:34,850
to pass this to the batteries to

00:14:32,899 --> 00:14:36,440
generate out of this information the

00:14:34,850 --> 00:14:38,750
appropriate bus firewall configuration

00:14:36,440 --> 00:14:40,730
if you can see here the membrane ranges

00:14:38,750 --> 00:14:43,820
you can find all the information from

00:14:40,730 --> 00:14:47,079
the link about the MM area region of the

00:14:43,820 --> 00:14:49,550
device so all the information is there

00:14:47,079 --> 00:14:51,290
so there is one things as missing that

00:14:49,550 --> 00:14:53,300
we have been thinking about and I'm

00:14:51,290 --> 00:14:55,730
telling about this drop more like a

00:14:53,300 --> 00:14:58,579
problem statement we don't really have a

00:14:55,730 --> 00:15:02,240
defined solution yet but often bus

00:14:58,579 --> 00:15:04,130
firewalls don't have that many slots so

00:15:02,240 --> 00:15:06,680
it is common to have a configuration

00:15:04,130 --> 00:15:09,890
where there are more devices to protect

00:15:06,680 --> 00:15:12,620
more domains that the amount of slots by

00:15:09,890 --> 00:15:14,750
the bus firewall as to protection so in

00:15:12,620 --> 00:15:17,269
these incision areas we have to make the

00:15:14,750 --> 00:15:19,760
difficult choice of protecting only some

00:15:17,269 --> 00:15:22,010
only the most important devices and the

00:15:19,760 --> 00:15:24,260
most important domains that's why I

00:15:22,010 --> 00:15:26,660
think we need to do something like

00:15:24,260 --> 00:15:29,149
priorities like a priority per domain to

00:15:26,660 --> 00:15:30,829
say this domain as a higher priority

00:15:29,149 --> 00:15:33,110
that is all the domain it should

00:15:30,829 --> 00:15:34,860
definitely be protected first I like

00:15:33,110 --> 00:15:37,380
maybe a safety critical domain

00:15:34,860 --> 00:15:41,250
but we might even have might even need

00:15:37,380 --> 00:15:44,370
higher granularity such as per memory

00:15:41,250 --> 00:15:47,070
range or third device priority to be

00:15:44,370 --> 00:15:50,100
able to say this device actually has a

00:15:47,070 --> 00:15:54,960
much higher priority than the other

00:15:50,100 --> 00:15:57,060
device yeah we'll discuss with discuss

00:15:54,960 --> 00:16:02,130
priorities in one in one of the next

00:15:57,060 --> 00:16:05,040
open up codes all right I have only one

00:16:02,130 --> 00:16:08,940
last point here that's about chosen and

00:16:05,040 --> 00:16:12,110
reserved memory so chosen and reserved

00:16:08,940 --> 00:16:14,730
memory our firmware and software

00:16:12,110 --> 00:16:17,700
configurations they exist today they're

00:16:14,730 --> 00:16:20,100
top-level nodes for instance chosen as

00:16:17,700 --> 00:16:24,150
information about the common line

00:16:20,100 --> 00:16:26,550
arguments for Linux so insistent battery

00:16:24,150 --> 00:16:28,800
they still exist and they still have the

00:16:26,550 --> 00:16:30,660
same meaning that they have today

00:16:28,800 --> 00:16:33,150
meaning that they have software

00:16:30,660 --> 00:16:37,350
configuration of the software running on

00:16:33,150 --> 00:16:40,410
the default CPU cluster so the Linux

00:16:37,350 --> 00:16:42,570
running on the cortex a cluster is at

00:16:40,410 --> 00:16:46,160
the default cluster it will still get

00:16:42,570 --> 00:16:48,870
the argument under chosen however other

00:16:46,160 --> 00:16:50,370
also execution terrain still live their

00:16:48,870 --> 00:16:52,170
own but potentially they need their own

00:16:50,370 --> 00:16:54,510
common line argument for the operating

00:16:52,170 --> 00:16:56,730
system running there or they need

00:16:54,510 --> 00:16:59,850
special memory reservation for special

00:16:56,730 --> 00:17:02,490
drivers like reserved memory reserved

00:16:59,850 --> 00:17:04,770
memory does so we need another another

00:17:02,490 --> 00:17:06,240
chosen and reserved memory node and the

00:17:04,770 --> 00:17:09,330
rich domain to express these

00:17:06,240 --> 00:17:11,280
configurations so the idea is that each

00:17:09,330 --> 00:17:13,020
domain will come with all the

00:17:11,280 --> 00:17:16,020
configuration needed for the software

00:17:13,020 --> 00:17:21,240
running on top and at the end of my part

00:17:16,020 --> 00:17:23,130
and I'll let Bruce continue yeah

00:17:21,240 --> 00:17:25,800
hopefully everybody can hear me I've

00:17:23,130 --> 00:17:27,630
been having some network bandwidth

00:17:25,800 --> 00:17:30,360
issues the issues this morning so I'm

00:17:27,630 --> 00:17:33,900
not going to turn my video on for safety

00:17:30,360 --> 00:17:36,780
we since that I might disappear so I'm

00:17:33,900 --> 00:17:40,200
gonna do a very quick overview of what

00:17:36,780 --> 00:17:42,540
is what is Lauper if we can jump to the

00:17:40,200 --> 00:17:45,480
next slide Stefan

00:17:42,540 --> 00:17:48,389
so it's something that we've been poking

00:17:45,480 --> 00:17:51,690
away at and I've been working on since

00:17:48,389 --> 00:17:53,700
probably May of last year and it's a

00:17:51,690 --> 00:17:56,009
tool for manipulating the system and

00:17:53,700 --> 00:17:58,590
advice trees because they can be quite

00:17:56,009 --> 00:18:02,100
large and we're trying to eliminate some

00:17:58,590 --> 00:18:04,470
of the errors and manual editing and and

00:18:02,100 --> 00:18:06,720
and supporting these different workflows

00:18:04,470 --> 00:18:08,750
of different people working on assistant

00:18:06,720 --> 00:18:12,659
advice tree as it goes through a system

00:18:08,750 --> 00:18:14,850
and but the primary goal that we had you

00:18:12,659 --> 00:18:17,100
know when it started and it still exists

00:18:14,850 --> 00:18:19,190
is that it's to produce a standard

00:18:17,100 --> 00:18:21,929
device tree to support existing

00:18:19,190 --> 00:18:24,870
platforms and operating system so you

00:18:21,929 --> 00:18:27,330
know it inevitably you can take a system

00:18:24,870 --> 00:18:29,580
device tree and the default that comes

00:18:27,330 --> 00:18:33,179
out of lopper is a device tree that

00:18:29,580 --> 00:18:35,220
linux or what anything that's used to

00:18:33,179 --> 00:18:37,320
parsing or manipulating a standard

00:18:35,220 --> 00:18:39,120
device tree it won't have any component

00:18:37,320 --> 00:18:42,000
elements that it doesn't understand so

00:18:39,120 --> 00:18:44,070
you don't have to modify every operating

00:18:42,000 --> 00:18:48,210
system immediately to work with a system

00:18:44,070 --> 00:18:50,759
device tree it is data-driven it doesn't

00:18:48,210 --> 00:18:53,519
fundamentally understand the stim device

00:18:50,759 --> 00:18:56,340
tree I have a slide that shows a few of

00:18:53,519 --> 00:18:58,889
the inputs very quickly so that it

00:18:56,340 --> 00:19:02,340
there's no hard-coded logic in a tree it

00:18:58,889 --> 00:19:06,090
works on various inputs and it uses

00:19:02,340 --> 00:19:08,429
plugins and operations to do to do

00:19:06,090 --> 00:19:11,990
anything from generate code do custom

00:19:08,429 --> 00:19:14,700
output sort or due to ice trees it is

00:19:11,990 --> 00:19:16,919
going to be it's open source it's under

00:19:14,700 --> 00:19:18,659
a BSD 3 license I have the link to where

00:19:16,919 --> 00:19:21,509
it will be probably by the end of the

00:19:18,659 --> 00:19:24,360
day that's a landing page which will be

00:19:21,509 --> 00:19:28,080
updated to the code where it will sit on

00:19:24,360 --> 00:19:30,960
github or or whatever we put it under it

00:19:28,080 --> 00:19:36,840
is literally just Python and Lib ftt and

00:19:30,960 --> 00:19:39,029
the Python bindings it works with DTC to

00:19:36,840 --> 00:19:41,730
compile device trees but then after that

00:19:39,029 --> 00:19:43,350
it works completely on dtbs' at the

00:19:41,730 --> 00:19:46,350
moment and we're exploring different

00:19:43,350 --> 00:19:48,389
ways to manipulate the backend but right

00:19:46,350 --> 00:19:50,159
now that's you know that's sort of it's

00:19:48,389 --> 00:19:52,019
using as little as possible to be as

00:19:50,159 --> 00:19:57,509
simple as possible and portable as

00:19:52,019 --> 00:19:59,759
possible and it also you there's modes

00:19:57,509 --> 00:20:01,890
where we can output device trees and it

00:19:59,759 --> 00:20:03,570
performs extra validation and

00:20:01,890 --> 00:20:05,640
assistance he checking during output so

00:20:03,570 --> 00:20:09,270
if you end up doing something that drops

00:20:05,640 --> 00:20:11,640
one of your P handles that Stefano was

00:20:09,270 --> 00:20:14,040
showing in the access note it knows how

00:20:11,640 --> 00:20:15,480
to either notify you or or make

00:20:14,040 --> 00:20:18,800
corrections through the tree on the way

00:20:15,480 --> 00:20:18,800
out all right

00:20:18,860 --> 00:20:26,010
so we can jump right these this I just

00:20:21,720 --> 00:20:30,120
had a slide here that shows one of the

00:20:26,010 --> 00:20:32,160
different parts that go into lopper and

00:20:30,120 --> 00:20:34,350
you know fundamentally on the left it is

00:20:32,160 --> 00:20:36,150
only we didn't create anything they're

00:20:34,350 --> 00:20:38,670
all standards-based inputs so whether

00:20:36,150 --> 00:20:41,790
their system device tree or normal

00:20:38,670 --> 00:20:44,760
device tree T DTS files are overlays and

00:20:41,790 --> 00:20:46,680
these mops which are law for operations

00:20:44,760 --> 00:20:49,190
and they're also actually in specified

00:20:46,680 --> 00:20:51,330
right now in a device tree type format

00:20:49,190 --> 00:20:54,990
and then you see in the middle what

00:20:51,330 --> 00:20:57,510
lopper is it's just it's python dtc cpp

00:20:54,990 --> 00:21:00,180
everything that you'd expect with a

00:20:57,510 --> 00:21:03,000
bunch of different sort of back ends

00:21:00,180 --> 00:21:05,880
where you can say go back to DTS if you

00:21:03,000 --> 00:21:08,280
want to nibble ate the source more you

00:21:05,880 --> 00:21:10,200
can do DTB to see if you want to

00:21:08,280 --> 00:21:14,130
generate C device drivers for an artists

00:21:10,200 --> 00:21:16,290
or bare metal or it can do a custom you

00:21:14,130 --> 00:21:19,440
know firewall bus firewall specification

00:21:16,290 --> 00:21:21,300
that Stefano was talking about so the

00:21:19,440 --> 00:21:23,700
point is that it's using open source

00:21:21,300 --> 00:21:25,730
inputs it many plays a device tree and

00:21:23,700 --> 00:21:32,730
then it has various backends to do

00:21:25,730 --> 00:21:34,140
whatever output you may need so I just

00:21:32,730 --> 00:21:35,730
did a quick capture of you know the

00:21:34,140 --> 00:21:36,990
question is how do I run lopper as I

00:21:35,730 --> 00:21:40,680
mentioned that's the primary goal is to

00:21:36,990 --> 00:21:43,350
create a traditional device tree and

00:21:40,680 --> 00:21:45,720
it's you know it pretty much it takes

00:21:43,350 --> 00:21:48,030
that assistant device tree it takes a

00:21:45,720 --> 00:21:49,500
domain node as inputs and then a bunch

00:21:48,030 --> 00:21:51,660
of lopper operations whether their

00:21:49,500 --> 00:21:54,660
customer built-in it outputs a standard

00:21:51,660 --> 00:21:56,580
device tree so what it does and the flow

00:21:54,660 --> 00:21:58,830
is always it applies operation so the

00:21:56,580 --> 00:22:02,490
tree is specified in the operations file

00:21:58,830 --> 00:22:04,770
it finds a domain node it can call an

00:22:02,490 --> 00:22:06,060
assist or do basic operations on those

00:22:04,770 --> 00:22:09,120
domain nodes which one would it be like

00:22:06,060 --> 00:22:11,250
the tree and then it outputs the

00:22:09,120 --> 00:22:14,550
modified system device tree you can

00:22:11,250 --> 00:22:15,299
either do it as this sort of raw DTB

00:22:14,550 --> 00:22:18,029
dump or you can

00:22:15,299 --> 00:22:20,070
validate the tree on the way out and go

00:22:18,029 --> 00:22:24,749
back to source but either way the output

00:22:20,070 --> 00:22:26,549
is a standard device tree oh and this

00:22:24,749 --> 00:22:27,690
yeah it's a bit small but it's more here

00:22:26,549 --> 00:22:31,320
for reference this is just an example

00:22:27,690 --> 00:22:33,360
we'll run where we're taking this r5

00:22:31,320 --> 00:22:36,029
domain that is definitely was using as

00:22:33,360 --> 00:22:38,999
an example a system device tree for a

00:22:36,029 --> 00:22:41,129
versal and it's outputting a Linux r5

00:22:38,999 --> 00:22:43,249
GTS and you can see the run and there's

00:22:41,129 --> 00:22:46,619
some things here where it knows how to

00:22:43,249 --> 00:22:50,009
it hunt in two different CPU clusters it

00:22:46,619 --> 00:22:51,899
deletes one it renames some nodes it

00:22:50,009 --> 00:22:54,539
does and then the bottom part here it's

00:22:51,899 --> 00:22:58,379
writing this this output DTS which I can

00:22:54,539 --> 00:22:59,999
see I left food on ETS in there it does

00:22:58,379 --> 00:23:01,879
validation and you can see that it's

00:22:59,999 --> 00:23:04,039
doing some piano replacement and

00:23:01,879 --> 00:23:07,470
validation of the tree on the way out

00:23:04,039 --> 00:23:09,149
and just in this example I just grabbed

00:23:07,470 --> 00:23:12,570
a couple things that the system device

00:23:09,149 --> 00:23:15,960
tree on the way in it had 84 elements if

00:23:12,570 --> 00:23:18,090
you will just you know so a block in the

00:23:15,960 --> 00:23:20,429
device tree that was how to label and

00:23:18,090 --> 00:23:23,159
after we've run it we're now you know

00:23:20,429 --> 00:23:25,379
we're down to 41 so it dropped half of

00:23:23,159 --> 00:23:28,320
the system device tree and for example

00:23:25,379 --> 00:23:32,279
before we started the CPUs node was the

00:23:28,320 --> 00:23:34,440
cortex a 72 and after we run it which is

00:23:32,279 --> 00:23:36,749
the right hand side it's now been

00:23:34,440 --> 00:23:39,989
renamed as the default CPUs are now the

00:23:36,749 --> 00:23:44,039
are fox so it knew as part of this

00:23:39,989 --> 00:23:46,230
manipulation to drop the the a 72 s it

00:23:44,039 --> 00:23:49,919
kept the are 5 s and it renamed them to

00:23:46,230 --> 00:23:51,659
CPUs as the default boots say for Linux

00:23:49,919 --> 00:23:56,940
or whatever would only be looking under

00:23:51,659 --> 00:23:58,440
CPUs and the question is what about an

00:23:56,940 --> 00:24:00,840
hour tops or something without device

00:23:58,440 --> 00:24:03,779
tree support what can you do

00:24:00,840 --> 00:24:05,669
and so again same inputs always

00:24:03,779 --> 00:24:07,759
assistant device tree you don't need a

00:24:05,669 --> 00:24:10,230
domain note in this case potentially

00:24:07,759 --> 00:24:13,019
lauper operations and what in this case

00:24:10,230 --> 00:24:15,989
it does applies the operations process

00:24:13,019 --> 00:24:17,879
of the tree in this case there is a it

00:24:15,989 --> 00:24:20,070
will always put out the device tree that

00:24:17,879 --> 00:24:23,299
was a reference however was changed but

00:24:20,070 --> 00:24:26,220
it has an OS specific module that

00:24:23,299 --> 00:24:28,679
outputs in this case some see defines

00:24:26,220 --> 00:24:31,499
and some code based on the

00:24:28,679 --> 00:24:33,210
five device dream and I just did a

00:24:31,499 --> 00:24:35,669
little snippet of an example that I ran

00:24:33,210 --> 00:24:37,559
one where I was pretending I was doing a

00:24:35,669 --> 00:24:39,600
safety critical device tree and we took

00:24:37,559 --> 00:24:42,119
the versatile and we wanted to output

00:24:39,600 --> 00:24:44,519
the artists header dot H and so in this

00:24:42,119 --> 00:24:46,889
case it knew how to modify the device

00:24:44,519 --> 00:24:49,679
tree and made a bunch of defines with

00:24:46,889 --> 00:24:51,960
constants that were left as a sample and

00:24:49,679 --> 00:24:53,789
it also was putting out in implementing

00:24:51,960 --> 00:24:55,919
some structures based on what was left

00:24:53,789 --> 00:24:58,169
in the field that's completely flexible

00:24:55,919 --> 00:25:00,720
that's just a Python assist that I wrote

00:24:58,169 --> 00:25:03,389
to show how easy it is to modify device

00:25:00,720 --> 00:25:06,899
tree and then print out C code as an

00:25:03,389 --> 00:25:10,169
example all right I think we're out of

00:25:06,899 --> 00:25:12,119
time on the slide deck that's uploaded

00:25:10,169 --> 00:25:13,919
we have an extra slide that talks about

00:25:12,119 --> 00:25:16,889
how you can engage with system device

00:25:13,919 --> 00:25:19,139
tree so this is a project under the

00:25:16,889 --> 00:25:20,340
Lenora device tree evolution project

00:25:19,139 --> 00:25:22,950
that's going on in Glenora

00:25:20,340 --> 00:25:24,840
and it's under there open an umbrella

00:25:22,950 --> 00:25:26,580
we're driving this system device tree

00:25:24,840 --> 00:25:28,559
and there's a couple of links there so

00:25:26,580 --> 00:25:31,139
you can get in touch with us and there's

00:25:28,559 --> 00:25:32,879
a mailing list as well I guess we have

00:25:31,139 --> 00:25:35,429
one question there is an address map

00:25:32,879 --> 00:25:38,159
property new for system device tree so

00:25:35,429 --> 00:25:40,649
Stefano maybe you can take that and yeah

00:25:38,159 --> 00:25:42,990
the others map property is new and was

00:25:40,649 --> 00:25:47,879
one of those introduced specifically for

00:25:42,990 --> 00:25:51,179
CSUN device tree yeah it's and it's

00:25:47,879 --> 00:25:54,179
meant to map especially in the red buses

00:25:51,179 --> 00:25:57,179
that otherwise has no and no way of

00:25:54,179 --> 00:25:59,629
being mapped into the other space of CPU

00:25:57,179 --> 00:25:59,629

YouTube URL: https://www.youtube.com/watch?v=2o-B21unV9M


