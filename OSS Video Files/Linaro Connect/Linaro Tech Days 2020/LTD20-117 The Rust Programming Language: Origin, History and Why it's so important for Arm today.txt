Title: LTD20-117 The Rust Programming Language: Origin, History and Why it's so important for Arm today
Publication date: 2020-03-25
Playlist: Linaro Tech Days 2020
Description: 
	Description:
Rust is a modern programming language designed from its inception to solve whole classes of problems that contribute to safety and security vulnerabilities. That, without sacrificing expressiveness, programmer convenience, performance and interoperability with legacy code.

Today Rust is rapidly turning into the first choice for developing code intended to run in high performance, concurrent and safety critical environments. This is happening at all layers of the software stack including firmware, TEEs, OS kernels, web frameworks, the lot with contributions from all the usual (big) suspect organisations.

The story of the inception, design, development, evolution and uptake of Rust is a very interesting tale that sheds light on the real problems facing programming in the large in the face of today's safety and security landscape.

In this joint talk by Florian Gilcher (from Ferrous Systems and a member of the Rust language core team) and Robin Randhawa (from Arm, a long time friend of Linaro who focuses on the intersection of open source and safety) the audience will learn about the motivations and history of Rust, how it manages to do what it does and the plans for making Arm support in Rust be best in class.

Session Speakers
Robin Randhawa
Technical Director (Arm)


Robin works for Arm and dabbles in operating system stacks and systems programming languages. Robin is a part of Arm's system software architecture team at Cambridge, UK.His primary focus is open source software used in safety critical domains. He spends his time working with system software and hardware designers to find ways in which Arm's safety conscious partners can benefit from open source software.


Florian Gilcher
Managing Director (Ferrous Systems)


Florian works for Ferrous Systems and has been closely involved with the evolution of Rust in his capacity as a Rust Language Core Team Observer and a member of the Governance working group. Florian is a noted Rust evangelist and his lectures included in most major Rust events around the world are very popular. He regularly runs training workshops on Rust. As a part of Ferrous Systems he works with key embedded Rust projects running on Arm silicon. 



You can find the presentation for this session on connect.linaro.org:
https://connect.linaro.org/resources/ltd20/ltd20-117/
Captions: 
	00:00:00,000 --> 00:00:05,160
um probably most of you won't know me so

00:00:03,240 --> 00:00:07,230
quickly going to introduce myself as

00:00:05,160 --> 00:00:09,240
most of you can see my face up close

00:00:07,230 --> 00:00:12,240
there's a small picture of me I'm

00:00:09,240 --> 00:00:14,790
hurryin I've been a rust developer since

00:00:12,240 --> 00:00:18,000
2013 so close to seven years now and the

00:00:14,790 --> 00:00:21,029
trainer since 2015 and a founder of the

00:00:18,000 --> 00:00:23,189
building users group and the European

00:00:21,029 --> 00:00:26,039
conference is West fest and oxidize

00:00:23,189 --> 00:00:28,349
oxidize being the conference focused on

00:00:26,039 --> 00:00:31,369
embedded software development on rust

00:00:28,349 --> 00:00:34,649
and as a fellow conference organizer

00:00:31,369 --> 00:00:36,149
that has canceled one of those that's

00:00:34,649 --> 00:00:38,430
probably thinking about canceling the

00:00:36,149 --> 00:00:40,050
second thank you for running this and

00:00:38,430 --> 00:00:44,789
thank you for me through all this

00:00:40,050 --> 00:00:48,539
trouble this year that has been yeah a

00:00:44,789 --> 00:00:50,820
year already I'm part of the rest

00:00:48,539 --> 00:00:53,190
community team and of the rust core team

00:00:50,820 --> 00:00:55,320
and I'm the co-founder of a company

00:00:53,190 --> 00:00:57,600
called ferry systems we are a group of

00:00:55,320 --> 00:01:00,629
rust developers often coming from the

00:00:57,600 --> 00:01:02,969
project but not all of us that help in

00:01:00,629 --> 00:01:04,470
adopting rust in larger enterprise

00:01:02,969 --> 00:01:06,210
organizations through training

00:01:04,470 --> 00:01:08,430
development and for example also

00:01:06,210 --> 00:01:09,930
maintenance of software libraries and

00:01:08,430 --> 00:01:13,100
work on the bus compiler should there be

00:01:09,930 --> 00:01:15,869
any issues that need to be solved

00:01:13,100 --> 00:01:17,820
quickly on the area now I'm going to

00:01:15,869 --> 00:01:19,259
give a short background of what rust is

00:01:17,820 --> 00:01:20,700
and short run through its history

00:01:19,259 --> 00:01:25,350
because there's a lot of interesting

00:01:20,700 --> 00:01:27,270
things to dig note there I'm going to

00:01:25,350 --> 00:01:30,150
talk a little bit about rust on embedded

00:01:27,270 --> 00:01:33,329
platforms about adoption strategies that

00:01:30,150 --> 00:01:35,280
we have seen out in the wild but a

00:01:33,329 --> 00:01:37,530
couple of hallmark projects have where

00:01:35,280 --> 00:01:40,829
the language tends today and that small

00:01:37,530 --> 00:01:43,829
summary at the end the rust programming

00:01:40,829 --> 00:01:47,070
language is a language in the range

00:01:43,829 --> 00:01:51,200
between C and C++ but with static memory

00:01:47,070 --> 00:01:55,170
safeties so there's it is impossible in

00:01:51,200 --> 00:01:56,549
rust to write any kind of memory to run

00:01:55,170 --> 00:01:59,189
into any kind of memory on safety

00:01:56,549 --> 00:02:00,899
situations but it also has features

00:01:59,189 --> 00:02:02,640
making it competitive with a wide range

00:02:00,899 --> 00:02:05,430
of other languages for example it has

00:02:02,640 --> 00:02:08,129
specific kinds of safeguards around

00:02:05,430 --> 00:02:10,619
concurrency and it is industry friendly

00:02:08,129 --> 00:02:13,620
and industry proven what I mean by that

00:02:10,619 --> 00:02:16,440
is it has seen actual use in the in

00:02:13,620 --> 00:02:19,620
three in the last five years large-scale

00:02:16,440 --> 00:02:23,970
use and it is as a project set up to be

00:02:19,620 --> 00:02:26,370
actually interacted with and rust aims

00:02:23,970 --> 00:02:27,930
to eliminate classes of bugs as a

00:02:26,370 --> 00:02:30,269
language so we want to make sure that

00:02:27,930 --> 00:02:32,659
certain classes of bugs just are not

00:02:30,269 --> 00:02:36,510
possible anymore in this language and

00:02:32,659 --> 00:02:38,489
instead of making for example like we're

00:02:36,510 --> 00:02:40,500
not nudging people towards doing the

00:02:38,489 --> 00:02:44,760
right thing we're making sure they do

00:02:40,500 --> 00:02:46,859
the right thing rust has a couple of

00:02:44,760 --> 00:02:49,709
core values and the first and foremost

00:02:46,859 --> 00:02:50,910
and this is what has drawn me into the

00:02:49,709 --> 00:02:54,090
project twelve years ago

00:02:50,910 --> 00:02:57,000
rust is a language intended for

00:02:54,090 --> 00:02:58,829
industrial use it was never a research

00:02:57,000 --> 00:03:02,220
platform there was a research face

00:02:58,829 --> 00:03:05,879
obviously but it was always aimed to be

00:03:02,220 --> 00:03:07,709
used in in the industry and as such

00:03:05,879 --> 00:03:10,200
everything that lost has his use case

00:03:07,709 --> 00:03:12,239
driven so it was always built with the

00:03:10,200 --> 00:03:12,900
idea in mind that what should this be

00:03:12,239 --> 00:03:15,120
used for

00:03:12,900 --> 00:03:17,220
in practice it gives strong

00:03:15,120 --> 00:03:18,690
backwards-compatibility guarantees with

00:03:17,220 --> 00:03:21,030
strong Quality Assurance to make sure

00:03:18,690 --> 00:03:23,190
that they happen it still isn't a

00:03:21,030 --> 00:03:25,290
stagnant language the claim that we have

00:03:23,190 --> 00:03:27,000
is we want stability without stagnation

00:03:25,290 --> 00:03:28,470
so we want to move forward but we also

00:03:27,000 --> 00:03:31,169
want to make sure that old stuff doesn't

00:03:28,470 --> 00:03:33,480
break that brings us to the idea of

00:03:31,169 --> 00:03:35,400
allowing paste iteration we want to make

00:03:33,480 --> 00:03:37,500
sure that there are changes happening

00:03:35,400 --> 00:03:39,569
but things get more ergonomic and better

00:03:37,500 --> 00:03:44,120
but that we're also not meeting people

00:03:39,569 --> 00:03:46,349
in the dust and while moving forward the

00:03:44,120 --> 00:03:48,989
language and the core project in itself

00:03:46,349 --> 00:03:51,629
has a strong documentation culture we

00:03:48,989 --> 00:03:53,160
have fully documented standard and core

00:03:51,629 --> 00:03:53,730
libraries we have multiple books written

00:03:53,160 --> 00:03:55,530
about that

00:03:53,730 --> 00:03:57,060
and we want to be an approach of the

00:03:55,530 --> 00:04:00,799
project and what we mean by approachable

00:03:57,060 --> 00:04:03,269
is both by individuals and by companies

00:04:00,799 --> 00:04:06,120
rust has a couple of core innovations

00:04:03,269 --> 00:04:07,859
we're bringing a linear type system into

00:04:06,120 --> 00:04:10,260
mainstream use it's the last time I'm

00:04:07,859 --> 00:04:12,180
using that term we got a different

00:04:10,260 --> 00:04:14,250
terminology around that and it brings

00:04:12,180 --> 00:04:16,769
region-based memory management into

00:04:14,250 --> 00:04:18,120
mainstream use what is the advantage of

00:04:16,769 --> 00:04:19,620
region based memory management it

00:04:18,120 --> 00:04:21,269
doesn't rely on garbage collection while

00:04:19,620 --> 00:04:23,880
providing memory to a fee and that gives

00:04:21,269 --> 00:04:27,420
you predictable performance in memory

00:04:23,880 --> 00:04:29,460
recollection one of the reasons why

00:04:27,420 --> 00:04:33,450
people would still rely on memory and

00:04:29,460 --> 00:04:35,730
memory manual memory management and it

00:04:33,450 --> 00:04:38,220
is such is the usage of algebraic data

00:04:35,730 --> 00:04:40,500
types in distance programming so data

00:04:38,220 --> 00:04:43,860
types that abstract certain cases a

00:04:40,500 --> 00:04:45,150
number of cases and it's establishing a

00:04:43,860 --> 00:04:47,460
systems programming language with the

00:04:45,150 --> 00:04:50,000
tool set of modern high-level languages

00:04:47,460 --> 00:04:52,830
so for example languages like Java

00:04:50,000 --> 00:04:56,090
JavaScript or others so we're taking

00:04:52,830 --> 00:04:57,930
inspiration from this and it's

00:04:56,090 --> 00:05:00,480
establishing a systems programming

00:04:57,930 --> 00:05:02,850
language that provides more information

00:05:00,480 --> 00:05:04,980
so for example in rust the aliasing

00:05:02,850 --> 00:05:08,820
situation of every reference is known so

00:05:04,980 --> 00:05:12,960
we know how many other point is to point

00:05:08,820 --> 00:05:15,060
us to a certain value we have I'm going

00:05:12,960 --> 00:05:17,100
to show you a little bit of code I can't

00:05:15,060 --> 00:05:19,920
make a long run through the language but

00:05:17,100 --> 00:05:26,250
this is a piece of rust and do you see

00:05:19,920 --> 00:05:27,750
my mouse pointer I'll swim you down so

00:05:26,250 --> 00:05:30,330
the first line here allocates

00:05:27,750 --> 00:05:32,100
a number of bytes in memory I'm doing

00:05:30,330 --> 00:05:33,450
something with it just simply because

00:05:32,100 --> 00:05:36,150
this is a slight example I'm going to

00:05:33,450 --> 00:05:38,790
add +1 to each of them I'm gonna print

00:05:36,150 --> 00:05:40,200
them out so how do you recollect this

00:05:38,790 --> 00:05:43,200
memory that I have allocated in the

00:05:40,200 --> 00:05:43,380
first line I just don't do anything with

00:05:43,200 --> 00:05:46,020
it

00:05:43,380 --> 00:05:47,970
at the moment you stop using memory it's

00:05:46,020 --> 00:05:50,520
going to be allocated in this case it's

00:05:47,970 --> 00:05:53,640
falling out of scope in this moment the

00:05:50,520 --> 00:05:56,310
vector that was previously allocated was

00:05:53,640 --> 00:05:58,170
is D allocated and the important thing

00:05:56,310 --> 00:05:59,910
here is they are introduced into a

00:05:58,170 --> 00:06:02,460
program is owned only once so there's

00:05:59,910 --> 00:06:06,930
always in this case the main function

00:06:02,460 --> 00:06:08,580
owning this data and in other cases

00:06:06,930 --> 00:06:10,320
other parts of the program are the owner

00:06:08,580 --> 00:06:13,020
but there's only ever one and that's

00:06:10,320 --> 00:06:15,660
fundamental because that makes it easy

00:06:13,020 --> 00:06:17,190
to figure out when data is has to be

00:06:15,660 --> 00:06:19,260
removed from memory because if there's

00:06:17,190 --> 00:06:21,390
only one owner it's basically reference

00:06:19,260 --> 00:06:23,340
counting but if you're only counting to

00:06:21,390 --> 00:06:29,100
1 the compiler can figure out when

00:06:23,340 --> 00:06:32,040
dereference drops in the second core

00:06:29,100 --> 00:06:35,190
concept on top of that is borrowing rust

00:06:32,040 --> 00:06:38,660
has references just as c plus plus has

00:06:35,190 --> 00:06:40,680
and we also using the ampersand

00:06:38,660 --> 00:06:41,490
annotation for that with a slight

00:06:40,680 --> 00:06:43,110
difference there

00:06:41,490 --> 00:06:45,390
two different references in Rusty's

00:06:43,110 --> 00:06:46,800
references I'm allowed to mutate through

00:06:45,390 --> 00:06:49,170
and others that I'm not allowed to

00:06:46,800 --> 00:06:54,000
mutate to what I'm doing in this small

00:06:49,170 --> 00:06:56,670
code example is I'm taking a so called

00:06:54,000 --> 00:07:00,170
slice away sub view on a collection of

00:06:56,670 --> 00:07:03,150
data in memory on the first two items of

00:07:00,170 --> 00:07:05,400
this data that I just allocated I'm

00:07:03,150 --> 00:07:07,200
going to just add one to each of those

00:07:05,400 --> 00:07:09,060
two and then I'm going to print it out

00:07:07,200 --> 00:07:10,830
and as you see that results different

00:07:09,060 --> 00:07:12,240
it's two three three four instead of

00:07:10,830 --> 00:07:15,030
adding one to each other

00:07:12,240 --> 00:07:17,220
I've annotated this idea of region based

00:07:15,030 --> 00:07:20,070
memory management to the right so I have

00:07:17,220 --> 00:07:21,930
the long region this is how long the

00:07:20,070 --> 00:07:24,480
vector lives and then I have the smaller

00:07:21,930 --> 00:07:28,170
region this is how long my reference is

00:07:24,480 --> 00:07:30,660
valid and used and the magic of rust

00:07:28,170 --> 00:07:32,400
behind memory safety is essentially that

00:07:30,660 --> 00:07:34,620
we track these regions and if these

00:07:32,400 --> 00:07:37,380
regions don't overlap this is going to

00:07:34,620 --> 00:07:40,890
be an error so for example if I reach

00:07:37,380 --> 00:07:43,020
for the forceful deallocation so I go

00:07:40,890 --> 00:07:46,530
and say explicitly now deallocate my

00:07:43,020 --> 00:07:49,020
vector what happens is that the compiler

00:07:46,530 --> 00:07:50,850
will figure out oh the time that these

00:07:49,020 --> 00:07:54,000
two things are in memory doesn't overlap

00:07:50,850 --> 00:07:57,480
which means after the drop statement the

00:07:54,000 --> 00:07:59,670
reference will go invalid and you are

00:07:57,480 --> 00:08:02,970
not allowed to dereference it anymore

00:07:59,670 --> 00:08:06,810
making the for loop illegal and the

00:08:02,970 --> 00:08:10,230
compiler catches that and even gives me

00:08:06,810 --> 00:08:11,550
good era Diagnostics these error

00:08:10,230 --> 00:08:13,410
Diagnostics are a little bit misaligned

00:08:11,550 --> 00:08:17,270
because it's not a monospace font to the

00:08:13,410 --> 00:08:19,920
right but they I'm sorry for that and

00:08:17,270 --> 00:08:24,420
rust memory management rules fit on a

00:08:19,920 --> 00:08:26,700
slide it's every value is owned exactly

00:08:24,420 --> 00:08:29,040
once either by a function or by as of

00:08:26,700 --> 00:08:31,170
other values so for example in this case

00:08:29,040 --> 00:08:32,940
the vector owns the numbers at the

00:08:31,170 --> 00:08:35,490
moment you let the vector drop out of

00:08:32,940 --> 00:08:39,030
scope the numbers also be allocated or

00:08:35,490 --> 00:08:41,670
the bytes in this case this ownership

00:08:39,030 --> 00:08:43,230
can be passed on or given up and the

00:08:41,670 --> 00:08:47,670
moment you give it up you remove the

00:08:43,230 --> 00:08:50,340
data from memory and the owner can then

00:08:47,670 --> 00:08:52,830
hand out references to these values and

00:08:50,340 --> 00:08:55,110
that can either do that by handing out

00:08:52,830 --> 00:08:58,350
immutable references as often

00:08:55,110 --> 00:09:01,829
like all mutable references only exactly

00:08:58,350 --> 00:09:04,140
once and immutable and mutable

00:09:01,829 --> 00:09:05,700
references are mutually exclusive so you

00:09:04,140 --> 00:09:09,649
are never allowed to have two of those

00:09:05,700 --> 00:09:13,019
active at the same time and rust

00:09:09,649 --> 00:09:14,550
eliminates shared mutable access through

00:09:13,019 --> 00:09:17,940
these simple rules because you're never

00:09:14,550 --> 00:09:20,100
allowed to have mutable access to a

00:09:17,940 --> 00:09:21,600
space where there's already someone

00:09:20,100 --> 00:09:24,660
reading from it by having an immutable

00:09:21,600 --> 00:09:28,170
reference there's a couple of common

00:09:24,660 --> 00:09:30,690
misconceptions around this this process

00:09:28,170 --> 00:09:33,810
called borrowed checking in the Ling of

00:09:30,690 --> 00:09:36,720
the rust language only applies to the

00:09:33,810 --> 00:09:39,990
heap all my examples have been using a

00:09:36,720 --> 00:09:42,779
heap this is actually not the case

00:09:39,990 --> 00:09:44,610
baroque checking is general in general

00:09:42,779 --> 00:09:47,700
even in the sense that rust as a

00:09:44,610 --> 00:09:50,579
language is not at all aware of the

00:09:47,700 --> 00:09:53,250
existence of heap memory vector in this

00:09:50,579 --> 00:09:55,380
case as in heap allocating type is a

00:09:53,250 --> 00:09:56,790
standard the type that knows that

00:09:55,380 --> 00:09:59,550
there's a memory allocator and can

00:09:56,790 --> 00:10:02,160
memory allocate but from the perspective

00:09:59,550 --> 00:10:06,300
of the language it just behaves as every

00:10:02,160 --> 00:10:08,070
every other type as well and um that

00:10:06,300 --> 00:10:10,529
this ownership concept is only for

00:10:08,070 --> 00:10:12,540
memory management and this is also not

00:10:10,529 --> 00:10:15,360
true ownership models ownership of any

00:10:12,540 --> 00:10:17,970
kind of resource which can in one case

00:10:15,360 --> 00:10:19,980
be memory but also for example kernel

00:10:17,970 --> 00:10:22,649
handles I open a file I need to close it

00:10:19,980 --> 00:10:25,019
at some point when do I close it the

00:10:22,649 --> 00:10:27,500
moment I'd like to drop out of scope it

00:10:25,019 --> 00:10:31,199
is even used for for example handling

00:10:27,500 --> 00:10:34,050
interaction with devices and ownership

00:10:31,199 --> 00:10:39,390
for example of volatile data a volatile

00:10:34,050 --> 00:10:40,890
memory locations and when I was talking

00:10:39,390 --> 00:10:43,079
about rust has concurrency safety

00:10:40,890 --> 00:10:45,449
features rust eliminates shared

00:10:43,079 --> 00:10:46,949
mutability so it allows mutability here

00:10:45,449 --> 00:10:48,930
there's not a functional language in the

00:10:46,949 --> 00:10:52,230
sense that it for example says memory is

00:10:48,930 --> 00:10:54,180
semantically immutable it allows you to

00:10:52,230 --> 00:10:56,970
directly manipulate and point to memory

00:10:54,180 --> 00:10:58,560
but for example through that rule that

00:10:56,970 --> 00:11:00,839
there can never be a mutable reference

00:10:58,560 --> 00:11:03,240
and an immutable reference at the same

00:11:00,839 --> 00:11:04,920
time to say memory location if you look

00:11:03,240 --> 00:11:08,330
at this function and here an experience

00:11:04,920 --> 00:11:14,130
rust programmer like tree

00:11:08,330 --> 00:11:15,960
like beginner level then you can

00:11:14,130 --> 00:11:17,940
immediately deduce from this that buffer

00:11:15,960 --> 00:11:20,580
and data cannot be the same because that

00:11:17,940 --> 00:11:25,560
would be a violation of the of the

00:11:20,580 --> 00:11:27,900
immutability immutability rule and rust

00:11:25,560 --> 00:11:32,160
has a pretty interesting split there

00:11:27,900 --> 00:11:35,370
safe and unsafe rust all that I've been

00:11:32,160 --> 00:11:37,460
showing is so-called safe rust say Frost

00:11:35,370 --> 00:11:40,020
has absolutely no undefined behavior

00:11:37,460 --> 00:11:41,940
also in America like for example number

00:11:40,020 --> 00:11:44,330
overflow is always well-defined and all

00:11:41,940 --> 00:11:47,700
of these kind of things it has

00:11:44,330 --> 00:11:50,310
absolutely no illegal memory accesses it

00:11:47,700 --> 00:11:53,790
has no null pointers for example and it

00:11:50,310 --> 00:11:56,700
has proper tracking against data races

00:11:53,790 --> 00:12:01,110
it's impossible to build data races but

00:11:56,700 --> 00:12:03,980
that sometimes you do need to mess with

00:12:01,110 --> 00:12:07,080
things especially its external things

00:12:03,980 --> 00:12:09,270
like hardware and rust has an unsafe

00:12:07,080 --> 00:12:11,790
supply anguish that allows you to

00:12:09,270 --> 00:12:14,100
exactly do those unsafe things there's

00:12:11,790 --> 00:12:16,350
also a misconception about that the

00:12:14,100 --> 00:12:18,510
unsafe sub language does not put any of

00:12:16,350 --> 00:12:20,070
the safeguards off it does only allow

00:12:18,510 --> 00:12:22,830
you to do a couple of additional things

00:12:20,070 --> 00:12:24,810
so for example dealing with raw pointers

00:12:22,830 --> 00:12:26,370
calling it a foreign code because we

00:12:24,810 --> 00:12:29,190
can't say anything about foreign code

00:12:26,370 --> 00:12:31,200
and about its safety properties calling

00:12:29,190 --> 00:12:32,850
already known unsafe functions so for

00:12:31,200 --> 00:12:37,650
example raw device and when we access

00:12:32,850 --> 00:12:39,630
our QA engineer has has made a good

00:12:37,650 --> 00:12:42,210
statement about this safe code means you

00:12:39,630 --> 00:12:44,970
can take better risks we're constraining

00:12:42,210 --> 00:12:46,560
those places where you can do unsafe

00:12:44,970 --> 00:12:48,570
stuff and we're annotating them so you

00:12:46,560 --> 00:12:51,690
know where to look where the unsafe

00:12:48,570 --> 00:12:53,600
stuff happens we're preventing

00:12:51,690 --> 00:12:57,180
pragmatics around the case that there

00:12:53,600 --> 00:13:00,480
there will always be some amount of

00:12:57,180 --> 00:13:04,320
unsafe coding happening just to give you

00:13:00,480 --> 00:13:06,780
a short feeling around that on a code

00:13:04,320 --> 00:13:09,840
base of 100,000 lines of code we're

00:13:06,780 --> 00:13:12,000
often talking about like 400 to 500

00:13:09,840 --> 00:13:13,940
lines of unsafe thrust and that's pretty

00:13:12,000 --> 00:13:16,080
often in device interaction something

00:13:13,940 --> 00:13:20,840
application level coding is usually

00:13:16,080 --> 00:13:22,640
fully in safest and to orient Russ

00:13:20,840 --> 00:13:25,940
a little bit around C and C++ because

00:13:22,640 --> 00:13:27,470
those are two obvious competitors the

00:13:25,940 --> 00:13:29,750
interesting thing is that rust lands

00:13:27,470 --> 00:13:31,910
between C and C++ and I think that makes

00:13:29,750 --> 00:13:33,950
it a lot pretty teasing for

00:13:31,910 --> 00:13:35,540
organizations that for example find C++

00:13:33,950 --> 00:13:38,930
too heavy but see sometimes a little too

00:13:35,540 --> 00:13:42,830
bit too bare-bones it is a function and

00:13:38,930 --> 00:13:47,930
data structures language like C so we

00:13:42,830 --> 00:13:49,280
only have we primitive types and

00:13:47,930 --> 00:13:51,410
combinations of primitive types in

00:13:49,280 --> 00:13:53,420
memory but on the other hand it is a

00:13:51,410 --> 00:13:55,100
generic language like C so you can

00:13:53,420 --> 00:13:57,050
easily write functions that are generic

00:13:55,100 --> 00:13:59,090
for example overall numbers or things

00:13:57,050 --> 00:14:02,030
like that or collections that are

00:13:59,090 --> 00:14:05,120
getting generic over all data types that

00:14:02,030 --> 00:14:06,620
you might want to store in them we have

00:14:05,120 --> 00:14:08,240
error management on the other hand that

00:14:06,620 --> 00:14:12,050
works to values we don't rely on

00:14:08,240 --> 00:14:14,810
exceptions like you would do it in C but

00:14:12,050 --> 00:14:19,340
with some additions through the type

00:14:14,810 --> 00:14:23,750
system that gives you and Russ memory

00:14:19,340 --> 00:14:26,420
management is very similar to our III

00:14:23,750 --> 00:14:29,000
practices from C++

00:14:26,420 --> 00:14:33,020
so our research acquisition is initiated

00:14:29,000 --> 00:14:37,910
initialization but he's basically based

00:14:33,020 --> 00:14:40,520
into the the language is completely has

00:14:37,910 --> 00:14:42,230
a completely baked in so we compile time

00:14:40,520 --> 00:14:43,610
check and validate that so we're pretty

00:14:42,230 --> 00:14:46,460
much standing on the shoulders of giants

00:14:43,610 --> 00:14:48,200
day we're taking a lot of practices from

00:14:46,460 --> 00:14:49,610
previous systems programming languages

00:14:48,200 --> 00:14:53,960
and then coding them in a new fashion

00:14:49,610 --> 00:14:55,550
and a little bit of rust history I'm not

00:14:53,960 --> 00:14:58,040
going to run through all of this but a

00:14:55,550 --> 00:15:01,810
couple of core points and rust is

00:14:58,040 --> 00:15:04,250
actually started in 2006 as part of an a

00:15:01,810 --> 00:15:05,990
personal project and then in was of a

00:15:04,250 --> 00:15:07,400
researchers part of an experiment to

00:15:05,990 --> 00:15:11,090
write a better and safer browser engine

00:15:07,400 --> 00:15:13,100
and that's quite interesting it that

00:15:11,090 --> 00:15:14,720
means the language was always used for a

00:15:13,100 --> 00:15:18,230
piece of software and not just to invent

00:15:14,720 --> 00:15:20,030
a programming language by itself it was

00:15:18,230 --> 00:15:22,790
it initially developed in o'connell so

00:15:20,030 --> 00:15:25,010
if you see a lot of mal influences in

00:15:22,790 --> 00:15:27,620
rust that's where it comes from space on

00:15:25,010 --> 00:15:29,690
the LLVM though I have to say nowadays

00:15:27,620 --> 00:15:32,800
you don't only need to use a lobby M for

00:15:29,690 --> 00:15:34,569
cogeneration you can also do use user

00:15:32,800 --> 00:15:37,040
packets

00:15:34,569 --> 00:15:39,290
first public announcement was in 2010

00:15:37,040 --> 00:15:40,490
public release was in 2012 the

00:15:39,290 --> 00:15:43,519
interesting thing about the public

00:15:40,490 --> 00:15:46,069
release was it was released almost to

00:15:43,519 --> 00:15:47,990
the same time as go was released in

00:15:46,069 --> 00:15:50,449
March 2012 and the big question that we

00:15:47,990 --> 00:15:52,519
had back then was well who needs go but

00:15:50,449 --> 00:15:55,610
from Mozilla so it had run time it had a

00:15:52,519 --> 00:15:58,040
garbage collector and they basically

00:15:55,610 --> 00:16:00,290
that set us on the path of okay probably

00:15:58,040 --> 00:16:02,509
we should do something else the first

00:16:00,290 --> 00:16:04,160
release was on May 15 2015 so the

00:16:02,509 --> 00:16:07,279
language is mostly five years old

00:16:04,160 --> 00:16:09,800
nowadays for the embedded use case the

00:16:07,279 --> 00:16:13,610
whole history is a little bit lagging in

00:16:09,800 --> 00:16:16,670
the sense of that we they rust became

00:16:13,610 --> 00:16:18,439
stable for embedded in 2018 so rust is

00:16:16,670 --> 00:16:24,410
probably older than you think it's not

00:16:18,439 --> 00:16:26,209
the thing in there's a couple of

00:16:24,410 --> 00:16:27,800
interesting aspects are that history so

00:16:26,209 --> 00:16:29,449
first of all rust was developed in an

00:16:27,800 --> 00:16:31,279
engineering organization that built one

00:16:29,449 --> 00:16:32,809
of the largest in C and C++ code bases

00:16:31,279 --> 00:16:34,699
in the world so it was built by people

00:16:32,809 --> 00:16:38,149
that have maybe intimate Lang knowledge

00:16:34,699 --> 00:16:40,220
of C and C++ and rust was always

00:16:38,149 --> 00:16:41,689
industrial application of research so

00:16:40,220 --> 00:16:44,029
Mozilla research is interesting in the

00:16:41,689 --> 00:16:46,639
sense that they don't do green field

00:16:44,029 --> 00:16:48,470
research what they do is how much of all

00:16:46,639 --> 00:16:51,589
of those papers that we read can return

00:16:48,470 --> 00:16:55,399
to something you can use in practical

00:16:51,589 --> 00:16:57,139
terms and but that also influences how

00:16:55,399 --> 00:16:59,180
the project looks like so all released

00:16:57,139 --> 00:17:00,860
code that you had was always under

00:16:59,180 --> 00:17:03,410
quality insurance there was always CIA

00:17:00,860 --> 00:17:05,089
there was always a lot of proper

00:17:03,410 --> 00:17:06,890
engineering practices around that that

00:17:05,089 --> 00:17:09,860
sometimes you would in a research

00:17:06,890 --> 00:17:12,439
project just let slide because you have

00:17:09,860 --> 00:17:14,059
something else to do which is fine but

00:17:12,439 --> 00:17:18,439
given the goal of the language that

00:17:14,059 --> 00:17:19,789
wasn't and it has a very strong choice

00:17:18,439 --> 00:17:22,069
of focus do we write our own code

00:17:19,789 --> 00:17:23,689
generator no we use the LLVM do we write

00:17:22,069 --> 00:17:25,850
our own optimization framework no at

00:17:23,689 --> 00:17:27,740
first we use the LLVM because that does

00:17:25,850 --> 00:17:30,409
a lot of that do we want to innovate on

00:17:27,740 --> 00:17:32,390
syntax no probably something C like

00:17:30,409 --> 00:17:34,250
isn't that bad do we want to build a

00:17:32,390 --> 00:17:36,649
sound type system yes because that's our

00:17:34,250 --> 00:17:38,480
point do we want to provide good tooling

00:17:36,649 --> 00:17:40,340
yes because that's what we need for

00:17:38,480 --> 00:17:41,809
being productive and one of the first

00:17:40,340 --> 00:17:43,460
things that I've seen where during the

00:17:41,809 --> 00:17:44,929
project was someone saying hey finally a

00:17:43,460 --> 00:17:47,030
language from people who understand what

00:17:44,929 --> 00:17:47,650
we still use see finally someone who

00:17:47,030 --> 00:17:50,680
knows what

00:17:47,650 --> 00:17:55,750
c and c++ and takes that and bake that

00:17:50,680 --> 00:17:57,340
into a new language and a lot of those

00:17:55,750 --> 00:17:59,620
early years were a lot of

00:17:57,340 --> 00:18:01,120
experimentation and removal so can we

00:17:59,620 --> 00:18:03,400
have a memory sake can we have memory

00:18:01,120 --> 00:18:05,350
safety without a garbage collector how

00:18:03,400 --> 00:18:07,930
about we experiment porting that browser

00:18:05,350 --> 00:18:09,580
engine towards not using a GC and then

00:18:07,930 --> 00:18:10,690
removing it from the language once we

00:18:09,580 --> 00:18:13,260
know that we can do a browser engine

00:18:10,690 --> 00:18:15,670
without it that's probably a good proof

00:18:13,260 --> 00:18:18,100
why doesn't blast have classes there's a

00:18:15,670 --> 00:18:19,420
question that I often hear yeah we had

00:18:18,100 --> 00:18:22,810
them they didn't really fit there were

00:18:19,420 --> 00:18:24,580
two releases that had classes so at that

00:18:22,810 --> 00:18:27,160
moment languages are surprising effects

00:18:24,580 --> 00:18:29,320
law can we write write large software in

00:18:27,160 --> 00:18:32,380
rust yes we have written a browser

00:18:29,320 --> 00:18:34,600
engineer before it was released can we

00:18:32,380 --> 00:18:36,430
do bare metal programming in rust that

00:18:34,600 --> 00:18:38,650
was something that was researched back

00:18:36,430 --> 00:18:40,660
then by a project called zinc RS which

00:18:38,650 --> 00:18:42,450
is very very interesting but now defunct

00:18:40,660 --> 00:18:44,380
because they figured that yes it works

00:18:42,450 --> 00:18:49,210
but probably you should use a different

00:18:44,380 --> 00:18:50,980
approach and another thing that we use

00:18:49,210 --> 00:18:53,230
that time for is we cue the innovation

00:18:50,980 --> 00:18:56,110
budget ownership and borrowing are

00:18:53,230 --> 00:18:57,910
really really fundamental and that's

00:18:56,110 --> 00:18:59,500
something that hits people really early

00:18:57,910 --> 00:19:01,720
that they need to learn about this

00:18:59,500 --> 00:19:04,390
before before get becoming productive in

00:19:01,720 --> 00:19:07,870
the language that takes a week go to so

00:19:04,390 --> 00:19:10,630
we avoid introducing a lot of more novel

00:19:07,870 --> 00:19:16,000
concepts on top of that because that

00:19:10,630 --> 00:19:19,330
would just over a lot of people we

00:19:16,000 --> 00:19:22,180
release in 2015 a with a rather stable

00:19:19,330 --> 00:19:24,520
release called under the claimed safety

00:19:22,180 --> 00:19:26,890
concurrent fast so it's a safe language

00:19:24,520 --> 00:19:29,710
a memory safe language it is concurrency

00:19:26,890 --> 00:19:33,760
focused or it has support of concurrency

00:19:29,710 --> 00:19:35,560
and it is fast it was basically

00:19:33,760 --> 00:19:37,270
ownership and borrowing at its core as a

00:19:35,560 --> 00:19:40,480
generic language it was stable for

00:19:37,270 --> 00:19:41,580
server-side Lee use but with out of the

00:19:40,480 --> 00:19:43,870
box support for cross compilation

00:19:41,580 --> 00:19:46,270
especially using a lot of the tooling

00:19:43,870 --> 00:19:48,760
that the LLVM provided us and we started

00:19:46,270 --> 00:19:50,290
a pretty new release model for

00:19:48,760 --> 00:19:52,360
programming languages which you may know

00:19:50,290 --> 00:19:55,960
as browser release model rust releases

00:19:52,360 --> 00:19:57,430
every six weeks and that gives us

00:19:55,960 --> 00:19:58,920
actually a lot of benefits that I come

00:19:57,430 --> 00:20:02,850
to those benefits

00:19:58,920 --> 00:20:04,980
and even after 2015 we saw a number of

00:20:02,850 --> 00:20:08,120
interesting adoptions for example a most

00:20:04,980 --> 00:20:11,970
firecracker which is a virtual machine

00:20:08,120 --> 00:20:13,800
thin virtual machine written in rust now

00:20:11,970 --> 00:20:15,180
if you're running any kind of Amazon

00:20:13,800 --> 00:20:17,820
lambda functions you're running Amazon

00:20:15,180 --> 00:20:20,220
fire cracker Dropbox we wrote their

00:20:17,820 --> 00:20:23,550
back-end services NPM delivered the

00:20:20,220 --> 00:20:25,170
back-end service rewrote their some of

00:20:23,550 --> 00:20:26,400
their backends and delivery services so

00:20:25,170 --> 00:20:30,840
if you're downloading JavaScript you're

00:20:26,400 --> 00:20:33,180
running rust and a number of others

00:20:30,840 --> 00:20:35,460
adopters and that was quite interesting

00:20:33,180 --> 00:20:37,710
Firefox took two years to actually adopt

00:20:35,460 --> 00:20:40,830
the only in-house language and that was

00:20:37,710 --> 00:20:47,310
a good exercise actually in side of

00:20:40,830 --> 00:20:49,230
Mozilla arguing for then for that your

00:20:47,310 --> 00:20:52,320
thing is something that actually solves

00:20:49,230 --> 00:20:54,180
problems and it was not adopted just by

00:20:52,320 --> 00:20:58,230
this is our in-house language but um

00:20:54,180 --> 00:20:59,910
there was a strong uphill now I wouldn't

00:20:58,230 --> 00:21:01,080
say up a battle that's the wrong way of

00:20:59,910 --> 00:21:03,060
saying it but there was a strong

00:21:01,080 --> 00:21:08,010
interchange of having to argue for the

00:21:03,060 --> 00:21:12,360
benefits of it we have a 2018 release

00:21:08,010 --> 00:21:15,030
later the claim of that was performance

00:21:12,360 --> 00:21:17,970
reliability and productivity we moved a

00:21:15,030 --> 00:21:20,040
little bit back on the speed aspect of

00:21:17,970 --> 00:21:23,220
it because it turns out what people were

00:21:20,040 --> 00:21:25,350
using rust for was performance control

00:21:23,220 --> 00:21:27,060
that might not necessarily mean you need

00:21:25,350 --> 00:21:28,800
you want to have the last bit of

00:21:27,060 --> 00:21:33,540
performance out of it but you want

00:21:28,800 --> 00:21:37,110
something predictable so this claim fit

00:21:33,540 --> 00:21:38,790
much better for us the 2018 release is

00:21:37,110 --> 00:21:41,310
notable in the sense that it ships a new

00:21:38,790 --> 00:21:44,340
language profile if you use rust before

00:21:41,310 --> 00:21:47,190
2018 and you came away a little bit this

00:21:44,340 --> 00:21:48,600
language is hard to use that got a lot

00:21:47,190 --> 00:21:50,460
better because we work a lot of a

00:21:48,600 --> 00:21:54,060
language economics especially around the

00:21:50,460 --> 00:21:55,830
memory safety checking we provided a lot

00:21:54,060 --> 00:21:59,250
of migration tooling which means that

00:21:55,830 --> 00:22:04,410
nowadays roughly 90 95 % of all code

00:21:59,250 --> 00:22:07,830
bases are actually ported and rust code

00:22:04,410 --> 00:22:10,670
being in rust 2015 between 2015 means

00:22:07,830 --> 00:22:12,269
it's probably old animated the

00:22:10,670 --> 00:22:13,739
interesting thing

00:22:12,269 --> 00:22:16,080
I have to note there though talking

00:22:13,739 --> 00:22:18,479
about backwards compatibility you can

00:22:16,080 --> 00:22:20,459
still use 2015 rust code you can link it

00:22:18,479 --> 00:22:23,459
with 2018 rust code and you can link

00:22:20,459 --> 00:22:27,570
2015 code to rust 2018 code as much as

00:22:23,459 --> 00:22:32,190
you want let's talk a little bit about

00:22:27,570 --> 00:22:34,229
rust for embedded and they have always

00:22:32,190 --> 00:22:35,789
been our early experiments around it was

00:22:34,229 --> 00:22:37,859
known that rust could be used for

00:22:35,789 --> 00:22:40,889
embedded but for the 2015 release we

00:22:37,859 --> 00:22:43,499
explicitly said it as an on goal but

00:22:40,889 --> 00:22:44,729
with an eye to not block any usage on

00:22:43,499 --> 00:22:48,149
embedded systems and this is how our

00:22:44,729 --> 00:22:50,820
engineering roles we set a focus on this

00:22:48,149 --> 00:22:53,700
is something we need to get done and for

00:22:50,820 --> 00:22:56,549
that case it was Mozilla needed it for

00:22:53,700 --> 00:22:58,769
desktop applications and server use but

00:22:56,549 --> 00:23:00,659
we said it as a target for the 2018

00:22:58,769 --> 00:23:02,789
release it set up a working group a year

00:23:00,659 --> 00:23:05,190
before and the working group was done in

00:23:02,789 --> 00:23:08,279
August 2018 which was our intended

00:23:05,190 --> 00:23:10,139
release date for rust is as 80 but we

00:23:08,279 --> 00:23:13,379
needed to push the release to November

00:23:10,139 --> 00:23:15,119
2018 for other reasons and since then we

00:23:13,379 --> 00:23:19,379
have seen a notable uptake and rust

00:23:15,119 --> 00:23:21,389
usage in that field to the point where

00:23:19,379 --> 00:23:25,409
the company that I was referring to for

00:23:21,389 --> 00:23:28,919
systems had intended to make money using

00:23:25,409 --> 00:23:30,899
network services and spend it into

00:23:28,919 --> 00:23:34,799
embedded development because we saw

00:23:30,899 --> 00:23:38,159
chance there and like building up our

00:23:34,799 --> 00:23:39,299
embedded business nowadays is much more

00:23:38,159 --> 00:23:42,450
that we're making our money with

00:23:39,299 --> 00:23:44,219
embedded development and so it has

00:23:42,450 --> 00:23:47,039
become a viable opportunity and a viable

00:23:44,219 --> 00:23:50,279
business opportunity how does West look

00:23:47,039 --> 00:23:52,079
for embedded development it's very much

00:23:50,279 --> 00:23:53,999
the same language except these two

00:23:52,079 --> 00:23:55,979
annotations that you see there no main

00:23:53,999 --> 00:23:57,149
and no standard which says don't assume

00:23:55,979 --> 00:24:00,570
that there's a standard library and

00:23:57,149 --> 00:24:02,190
allocator and heap available and don't

00:24:00,570 --> 00:24:04,499
write don't let the compiler write you

00:24:02,190 --> 00:24:07,169
main function instead we're going to

00:24:04,499 --> 00:24:09,619
ship those as a library what you see

00:24:07,169 --> 00:24:12,989
here is a library called cortex MRT

00:24:09,619 --> 00:24:15,479
which is the cortex-m runtime importing

00:24:12,989 --> 00:24:18,089
that as a runtime we're importing an

00:24:15,479 --> 00:24:21,139
annotation that's called entry which

00:24:18,089 --> 00:24:23,429
marks the entry point where after the

00:24:21,139 --> 00:24:26,010
processor has started up it will

00:24:23,429 --> 00:24:28,890
actually call it to that and

00:24:26,010 --> 00:24:30,870
we have a second crate which is called

00:24:28,890 --> 00:24:32,520
panic halt which just says if there's

00:24:30,870 --> 00:24:38,930
any kind of error just stop the whole

00:24:32,520 --> 00:24:42,510
board the embedded working group has had

00:24:38,930 --> 00:24:44,190
notable output they have written a

00:24:42,510 --> 00:24:46,800
hardware abstraction layer that was

00:24:44,190 --> 00:24:48,600
completely built on rust concepts so

00:24:46,800 --> 00:24:50,970
that you can for example use timers as

00:24:48,600 --> 00:24:52,980
an abstract thing instead of relying on

00:24:50,970 --> 00:24:56,520
the exact specifics of every time or of

00:24:52,980 --> 00:24:59,430
every device it has a user level on the

00:24:56,520 --> 00:25:02,580
lower level buck written it provides

00:24:59,430 --> 00:25:04,620
code generation tooling to use as DD XML

00:25:02,580 --> 00:25:07,560
files to automatically generate rust

00:25:04,620 --> 00:25:08,850
libraries and it constantly works and

00:25:07,560 --> 00:25:10,560
further improvements to the cross

00:25:08,850 --> 00:25:15,270
compilation story especially with bare

00:25:10,560 --> 00:25:17,010
metal in mind it also ships a number of

00:25:15,270 --> 00:25:21,420
board kits this for example is a board

00:25:17,010 --> 00:25:24,540
kit for a PWM quantized one deck a white

00:25:21,420 --> 00:25:26,970
board and the way that works in rust

00:25:24,540 --> 00:25:30,240
lingo is you import another library I've

00:25:26,970 --> 00:25:32,880
skipped that the gwm and in the first

00:25:30,240 --> 00:25:34,920
slime you say I take the board this is

00:25:32,880 --> 00:25:36,960
the ownership thinking I take ownership

00:25:34,920 --> 00:25:39,870
list this part of the program takes

00:25:36,960 --> 00:25:41,610
ownership of the complete board and then

00:25:39,870 --> 00:25:47,310
takes ownership of one of the timers

00:25:41,610 --> 00:25:50,490
that makes an LED blink in the loop goes

00:25:47,310 --> 00:25:55,770
even as far that rust as a language has

00:25:50,490 --> 00:25:58,500
a async/await like concept that usually

00:25:55,770 --> 00:26:03,660
is only present in languages like net

00:25:58,500 --> 00:26:05,850
and and JavaScript and but builds that

00:26:03,660 --> 00:26:09,390
in a system programming language fashion

00:26:05,850 --> 00:26:11,400
and the sense of it is a different mode

00:26:09,390 --> 00:26:13,320
of code generation in this case

00:26:11,400 --> 00:26:16,890
something that allows you to for example

00:26:13,320 --> 00:26:19,290
wait a when you're sending stuff to UART

00:26:16,890 --> 00:26:21,240
you wait for this ending to happen so

00:26:19,290 --> 00:26:24,870
that team a actions can happen in the

00:26:21,240 --> 00:26:26,850
background but that does not require a

00:26:24,870 --> 00:26:28,590
runtime you can support your own runtime

00:26:26,850 --> 00:26:30,960
you can be let the hardware be the

00:26:28,590 --> 00:26:32,910
runtime in very much indifference to for

00:26:30,960 --> 00:26:36,590
example if you are using something like

00:26:32,910 --> 00:26:36,590
dance so

00:26:37,740 --> 00:26:44,830
I'll kind of skip on tooling a little

00:26:39,970 --> 00:26:47,740
because I'm running late the rust has a

00:26:44,830 --> 00:26:50,740
very gradual adoption strategy and and

00:26:47,740 --> 00:26:52,780
and every organization where we see was

00:26:50,740 --> 00:26:56,380
successfully adopted it's never by let's

00:26:52,780 --> 00:26:57,760
rewrite that all it's because rust is

00:26:56,380 --> 00:26:59,380
assistance programming language you can

00:26:57,760 --> 00:27:03,910
easily call in to see it you can easily

00:26:59,380 --> 00:27:05,320
have FC called in to rust and that

00:27:03,910 --> 00:27:07,510
allows you to gradually replace

00:27:05,320 --> 00:27:09,670
components so for example identifying a

00:27:07,510 --> 00:27:11,530
part that is currently problematic

00:27:09,670 --> 00:27:13,870
evaluating if that place to rust

00:27:11,530 --> 00:27:15,400
strengths and then use was there it is

00:27:13,870 --> 00:27:17,380
important for any kind of adoption that

00:27:15,400 --> 00:27:19,480
your first project is non critical and

00:27:17,380 --> 00:27:20,950
so on technically because otherwise

00:27:19,480 --> 00:27:22,660
there will be so much pressure on the

00:27:20,950 --> 00:27:24,760
team they kind of properly experiment

00:27:22,660 --> 00:27:29,590
which is bad for adopting in you'd taken

00:27:24,760 --> 00:27:32,740
a lot of you like to highlight a couple

00:27:29,590 --> 00:27:35,380
of hallmark projects in the space that

00:27:32,740 --> 00:27:37,690
we're talking here one of the things

00:27:35,380 --> 00:27:39,910
that we're involved in is occlusion

00:27:37,690 --> 00:27:42,160
armistice armistice is a program of

00:27:39,910 --> 00:27:43,780
platform for running security sensitive

00:27:42,160 --> 00:27:46,360
applications and provides access to

00:27:43,780 --> 00:27:49,240
cryptographic keys stored on a device so

00:27:46,360 --> 00:27:51,070
it makes it easy to separate the

00:27:49,240 --> 00:27:53,140
security critical parts and the

00:27:51,070 --> 00:27:54,970
application code it's targeting

00:27:53,140 --> 00:27:58,030
currently targeting the f-secure USB

00:27:54,970 --> 00:28:00,460
armory which is a cortex a but usually

00:27:58,030 --> 00:28:02,020
those use the Armory's are shipped with

00:28:00,460 --> 00:28:03,490
an embedded Linux but they would like to

00:28:02,020 --> 00:28:07,330
skip the whole embedded Linux part

00:28:03,490 --> 00:28:10,090
because they want to make sure that they

00:28:07,330 --> 00:28:12,040
you can on this whole thing without a an

00:28:10,090 --> 00:28:14,770
operating system and all the bugs that

00:28:12,040 --> 00:28:16,900
operating system brings with it Amazon

00:28:14,770 --> 00:28:18,430
fire cracker is interesting it as I said

00:28:16,900 --> 00:28:20,830
before a lightweight virtualization

00:28:18,430 --> 00:28:24,130
system powering opposite lambda there's

00:28:20,830 --> 00:28:25,660
a whole embedded operating system that's

00:28:24,130 --> 00:28:27,640
built for running multiple concurrent

00:28:25,660 --> 00:28:29,170
mutually distrustful applications in low

00:28:27,640 --> 00:28:31,750
memory and low-power microcontrollers

00:28:29,170 --> 00:28:32,950
and what I find interesting about it

00:28:31,750 --> 00:28:35,170
it's not a development

00:28:32,950 --> 00:28:36,790
pretty much when rust 100 was released

00:28:35,170 --> 00:28:39,400
and it was a research project for one to

00:28:36,790 --> 00:28:41,800
two years but it's now used heavily for

00:28:39,400 --> 00:28:46,210
example in Google open SK which is a

00:28:41,800 --> 00:28:48,400
Phaedo 2 Authenticator token that is

00:28:46,210 --> 00:28:50,890
built for soaking application that's

00:28:48,400 --> 00:28:53,140
built for and Nordic on earth fifty two

00:28:50,890 --> 00:28:57,549
basically that's

00:28:53,140 --> 00:28:59,870
rust today is a 250 people project and

00:28:57,549 --> 00:29:01,460
it's four times the most loved language

00:28:59,870 --> 00:29:03,529
on the Stack Overflow survey we're

00:29:01,460 --> 00:29:06,260
waiting for this year we hope we can can

00:29:03,529 --> 00:29:08,210
make number five and as a project it's

00:29:06,260 --> 00:29:10,039
split over working groups and teams it's

00:29:08,210 --> 00:29:11,750
very much built for making open-source

00:29:10,039 --> 00:29:13,520
where it happened that is very very

00:29:11,750 --> 00:29:15,140
different for if you use to a company

00:29:13,520 --> 00:29:17,179
organization structure we have multiple

00:29:15,140 --> 00:29:19,850
teams can see a number here core

00:29:17,179 --> 00:29:21,620
language libraries all of that event

00:29:19,850 --> 00:29:23,419
support we have a team for event support

00:29:21,620 --> 00:29:25,549
and that just has saved us because we

00:29:23,419 --> 00:29:28,940
had to help for events and shutting down

00:29:25,549 --> 00:29:32,029
structured so we're still but we're

00:29:28,940 --> 00:29:33,500
still a very lean project you can be

00:29:32,029 --> 00:29:35,750
involved in the project from anything

00:29:33,500 --> 00:29:38,679
between two hours a week or 40 hours a

00:29:35,750 --> 00:29:41,000
week depending on how much you like like

00:29:38,679 --> 00:29:43,309
we have very high standards of quality

00:29:41,000 --> 00:29:45,529
insurance we always have a clean master

00:29:43,309 --> 00:29:47,270
so if you pull our github and we'll

00:29:45,529 --> 00:29:50,840
always build on all platforms because

00:29:47,270 --> 00:29:52,610
it's CI tested we don't we run CI before

00:29:50,840 --> 00:29:56,000
merging tomas that we don't run CI on

00:29:52,610 --> 00:29:57,350
master it has industry standard security

00:29:56,000 --> 00:29:58,970
practices we have no infrastructure

00:29:57,350 --> 00:30:01,429
access to anyone who does need it we

00:29:58,970 --> 00:30:04,429
have to if a everywhere things like that

00:30:01,429 --> 00:30:06,200
we do not ship unfinished things if you

00:30:04,429 --> 00:30:08,330
download the stable compiler everything

00:30:06,200 --> 00:30:10,520
but the silo of compatible compile is

00:30:08,330 --> 00:30:13,450
stable otherwise it will say this is an

00:30:10,520 --> 00:30:15,620
unstable feature and I refuse using it

00:30:13,450 --> 00:30:17,270
we have a number of interesting checks

00:30:15,620 --> 00:30:19,490
and balances for example the core team

00:30:17,270 --> 00:30:21,590
which I'm in is has no technical power

00:30:19,490 --> 00:30:25,510
at all I am NOT allowed to tell people

00:30:21,590 --> 00:30:28,220
what to do we are a steering committee

00:30:25,510 --> 00:30:29,929
new features need sign-off by for

00:30:28,220 --> 00:30:31,700
example a release team so for example

00:30:29,929 --> 00:30:34,539
the compiler team or the language team

00:30:31,700 --> 00:30:38,419
cannot push the changes past the release

00:30:34,539 --> 00:30:39,950
wardens and this is where the six weeks

00:30:38,419 --> 00:30:41,870
release cycle helps us a lot because

00:30:39,950 --> 00:30:45,049
that keeps the cost of blocking low if

00:30:41,870 --> 00:30:46,820
you miss this week's release there's

00:30:45,049 --> 00:30:48,380
going to be the next one in six weeks so

00:30:46,820 --> 00:30:51,049
that makes it easier to tell people no

00:30:48,380 --> 00:30:52,610
this is not getting in and we do a lot

00:30:51,049 --> 00:30:54,470
of collaborations with vendors for

00:30:52,610 --> 00:30:57,350
example currently collaborating with arm

00:30:54,470 --> 00:31:01,429
for even upping the Quality Assurance

00:30:57,350 --> 00:31:04,610
for arm devices and one example for what

00:31:01,429 --> 00:31:05,149
we do if we are not sure if they fix

00:31:04,610 --> 00:31:08,139
actually

00:31:05,149 --> 00:31:10,729
brakes code and we it's hard to assess

00:31:08,139 --> 00:31:13,219
we're radical about this we download all

00:31:10,729 --> 00:31:14,899
the code that we know about build it and

00:31:13,219 --> 00:31:16,940
check it for regressions which is a

00:31:14,899 --> 00:31:18,649
three days process so the build run is

00:31:16,940 --> 00:31:20,799
one for three days and then we check

00:31:18,649 --> 00:31:24,469
that the version before that change

00:31:20,799 --> 00:31:27,830
build as build as well as the version

00:31:24,469 --> 00:31:29,899
after this change and rust is also an

00:31:27,830 --> 00:31:33,739
innovation driver rust has inspired

00:31:29,899 --> 00:31:35,450
Swift and Swift has inspired rust our

00:31:33,739 --> 00:31:37,489
tooling is seen as a reference that

00:31:35,450 --> 00:31:40,190
people live up to I have become at the

00:31:37,489 --> 00:31:42,499
to limit our n messages and diagnostic

00:31:40,190 --> 00:31:44,450
systems are seen as top of the class to

00:31:42,499 --> 00:31:46,789
the point where tc9 error messages are

00:31:44,450 --> 00:31:49,969
clearly very inspired by ours and we're

00:31:46,789 --> 00:31:52,309
very proud of others adopting our

00:31:49,969 --> 00:31:55,429
practices and making life better for

00:31:52,309 --> 00:31:58,369
everyone and we have a governance

00:31:55,429 --> 00:32:00,349
structure that does diverge from either

00:31:58,369 --> 00:32:01,849
design by committee but also from be

00:32:00,349 --> 00:32:04,489
Bennett benevolent obtain a full life

00:32:01,849 --> 00:32:06,259
for what just one person is responsible

00:32:04,489 --> 00:32:07,759
for the whole language which gives us a

00:32:06,259 --> 00:32:12,529
certain kind of organizational

00:32:07,759 --> 00:32:14,450
resilience so by and large rust improves

00:32:12,529 --> 00:32:19,909
other languages into the ecosystem as

00:32:14,450 --> 00:32:22,429
well the way we try to do to improve

00:32:19,909 --> 00:32:24,080
rust currently is the next logical step

00:32:22,429 --> 00:32:26,089
for us as ferrous systems is about

00:32:24,080 --> 00:32:29,330
enabling rust in the safety critical

00:32:26,089 --> 00:32:31,519
space because a lot of the things that

00:32:29,330 --> 00:32:34,729
you need for safety critical space have

00:32:31,519 --> 00:32:36,559
not been fully done yet for that we have

00:32:34,729 --> 00:32:38,539
an initiative called seed rust to

00:32:36,559 --> 00:32:40,190
qualify the rust language and compiler

00:32:38,539 --> 00:32:41,899
for use in the safety-critical domain I

00:32:40,190 --> 00:32:44,899
cannot go into detail on that but

00:32:41,899 --> 00:32:49,330
there's two blog posts that talk about

00:32:44,899 --> 00:32:51,710
that and in 2020 rust is here to stay

00:32:49,330 --> 00:32:53,809
rust has crossed the threshold from

00:32:51,710 --> 00:32:57,320
individual projects to organization wide

00:32:53,809 --> 00:32:59,659
adoption just in by the end of 2019

00:32:57,320 --> 00:33:02,269
Ryan Levesque for Microsoft keynote

00:32:59,659 --> 00:33:03,979
address fest and said we are adopting

00:33:02,269 --> 00:33:05,960
rust it's not we are thinking about

00:33:03,979 --> 00:33:09,229
adopting Ross know we as an organization

00:33:05,960 --> 00:33:14,359
are it was so and that happens in a lot

00:33:09,229 --> 00:33:16,460
of other organizations currently now all

00:33:14,359 --> 00:33:18,460
major players that we know of now have

00:33:16,460 --> 00:33:19,840
substantial rust code bases

00:33:18,460 --> 00:33:22,060
it has become a general language of

00:33:19,840 --> 00:33:25,710
choice for startups in in fields where

00:33:22,060 --> 00:33:28,450
it's interesting in also in a bedded and

00:33:25,710 --> 00:33:30,490
we'd like to make it a pleasant day so

00:33:28,450 --> 00:33:32,170
if any of this has raised questions

00:33:30,490 --> 00:33:35,710
interest or whatever please get in touch

00:33:32,170 --> 00:33:37,360
with me you will find all my contact on

00:33:35,710 --> 00:33:40,360
the slides if there's any kind of

00:33:37,360 --> 00:33:42,820
business to project inquiry I can highly

00:33:40,360 --> 00:33:44,380
recommend talking to the core a trust

00:33:42,820 --> 00:33:46,900
language or email because the second

00:33:44,380 --> 00:33:49,810
thing that we pose us is also a known

00:33:46,900 --> 00:33:51,340
group of trusted people so we're not

00:33:49,810 --> 00:33:52,900
allowed to talk about that I'm not even

00:33:51,340 --> 00:33:55,390
allowed to talk about that in my company

00:33:52,900 --> 00:33:58,320
for example and with that I would like

00:33:55,390 --> 00:33:58,320
to hand over to Robin

00:34:08,980 --> 00:34:27,100
thanks florian can you hear me yes you

00:34:16,480 --> 00:34:27,100
cool just a second did I see this

00:34:30,339 --> 00:34:33,269
not yet

00:34:45,990 --> 00:34:52,480
any luck

00:34:47,409 --> 00:34:56,950
yes now we can awesome right conscious

00:34:52,480 --> 00:34:58,930
of time I'll try and sit through this

00:34:56,950 --> 00:35:03,070
yeah so this segment of the presentation

00:34:58,930 --> 00:35:07,360
is about what we're doing at armed with

00:35:03,070 --> 00:35:09,700
rust what we like about it what what we

00:35:07,360 --> 00:35:13,380
perceive as gaps and maybe want to take

00:35:09,700 --> 00:35:16,360
it in the future so a bit about me I

00:35:13,380 --> 00:35:19,180
work in arms open source software in

00:35:16,360 --> 00:35:22,300
bridge I'm a longtime friend of Leonardo

00:35:19,180 --> 00:35:24,460
right from the beginning I was the lead

00:35:22,300 --> 00:35:26,770
forearms operating systems powerpuff

00:35:24,460 --> 00:35:28,570
team for about seven years and for the

00:35:26,770 --> 00:35:32,200
past two what years I've been looking at

00:35:28,570 --> 00:35:34,810
safety themed architecture now the track

00:35:32,200 --> 00:35:36,730
I own is called the safety track and it

00:35:34,810 --> 00:35:38,290
looks at the overlap between safety

00:35:36,730 --> 00:35:42,280
domains and open source software which

00:35:38,290 --> 00:35:46,150
is a bizarre space it's good fun if you

00:35:42,280 --> 00:35:48,010
like pain the Charter of the track is to

00:35:46,150 --> 00:35:49,660
promote the uptake of our my peen safety

00:35:48,010 --> 00:35:52,450
critical domains using open-source

00:35:49,660 --> 00:35:54,670
software as a medium so I won't explain

00:35:52,450 --> 00:35:56,740
all of this but there are like four key

00:35:54,670 --> 00:35:58,120
areas I look at and I just want to

00:35:56,740 --> 00:36:00,970
introduce this because it forms the

00:35:58,120 --> 00:36:04,000
basis for why I ventured towards rust

00:36:00,970 --> 00:36:05,530
it's a kernel architecture monolithic

00:36:04,000 --> 00:36:08,080
micro kernels what do the proprietary

00:36:05,530 --> 00:36:10,630
companies do why does it make sense is

00:36:08,080 --> 00:36:13,660
there something we can do similarly in

00:36:10,630 --> 00:36:15,610
open-source do we start from scratch can

00:36:13,660 --> 00:36:18,100
we pick up something isolation

00:36:15,610 --> 00:36:20,770
techniques right is it hardware that

00:36:18,100 --> 00:36:22,930
needs to have the isolation first how

00:36:20,770 --> 00:36:26,380
expensive is it in terms of dollars how

00:36:22,930 --> 00:36:29,380
expensive is it for software right do we

00:36:26,380 --> 00:36:31,180
need both one of the other functional

00:36:29,380 --> 00:36:33,130
safety process tie-ins right what are

00:36:31,180 --> 00:36:36,820
these safety standards all about do they

00:36:33,130 --> 00:36:39,190
mix with open-source software or is it

00:36:36,820 --> 00:36:40,720
just impossible what what is the

00:36:39,190 --> 00:36:41,710
sensible approach there is there

00:36:40,720 --> 00:36:44,110
something that can be done with

00:36:41,710 --> 00:36:48,640
open-source communities that can make

00:36:44,110 --> 00:36:51,010
open source of deployable and then safe

00:36:48,640 --> 00:36:54,610
languages and runtimes I got asked by

00:36:51,010 --> 00:36:56,560
senior people at arm to explore key

00:36:54,610 --> 00:36:59,110
phrases they were hearing all along

00:36:56,560 --> 00:37:01,720
ADA ere long I spent some time doing

00:36:59,110 --> 00:37:05,950
analyses built up a vocabulary that

00:37:01,720 --> 00:37:07,900
helped me qualify what safety means in

00:37:05,950 --> 00:37:11,530
the domain sera was interested in going

00:37:07,900 --> 00:37:18,490
into write and on that basis I latched

00:37:11,530 --> 00:37:20,290
on to rust now basically I there was

00:37:18,490 --> 00:37:22,720
this like aha moment I hide where I

00:37:20,290 --> 00:37:24,640
realized that memory safety is actually

00:37:22,720 --> 00:37:29,500
one of those things and that underpins

00:37:24,640 --> 00:37:31,540
many industries right and it also

00:37:29,500 --> 00:37:34,030
completely like the emphasis on memory

00:37:31,540 --> 00:37:36,700
safety or lack thereof completely

00:37:34,030 --> 00:37:40,300
trashed my kind of upcoming vision back

00:37:36,700 --> 00:37:41,860
in the day so I'm making a point to kind

00:37:40,300 --> 00:37:44,230
of like shout from the rooftops and tell

00:37:41,860 --> 00:37:45,850
people who are programmers that they

00:37:44,230 --> 00:37:47,830
should be paying a lot more attention to

00:37:45,850 --> 00:37:51,040
memory safety when I started using

00:37:47,830 --> 00:37:54,340
filters to try and choose programming

00:37:51,040 --> 00:37:56,500
languages tools anything I made sure

00:37:54,340 --> 00:37:59,170
that memory safety was one of those

00:37:56,500 --> 00:38:01,330
filters that made it a yay or nay

00:37:59,170 --> 00:38:06,220
decision for that tool of that language

00:38:01,330 --> 00:38:07,810
right so what is it just reiterating and

00:38:06,220 --> 00:38:09,970
emphasizing it's a state of being

00:38:07,810 --> 00:38:12,250
protected from various software bugs and

00:38:09,970 --> 00:38:14,170
security vulnerabilities when dealing

00:38:12,250 --> 00:38:16,420
with memory access such as buffer

00:38:14,170 --> 00:38:19,800
overflows and under flows dangling

00:38:16,420 --> 00:38:22,210
pointers use after free take your pick

00:38:19,800 --> 00:38:24,670
people don't realize how prevalent this

00:38:22,210 --> 00:38:27,130
is right so this is a slide from friends

00:38:24,670 --> 00:38:28,870
in Microsoft Research they're talking

00:38:27,130 --> 00:38:31,060
about the Microsoft ecosystem over here

00:38:28,870 --> 00:38:33,340
but you can go to the CVE repositories

00:38:31,060 --> 00:38:35,980
the public ones most software and you'll

00:38:33,340 --> 00:38:38,620
find fundamentally the same trend right

00:38:35,980 --> 00:38:42,300
seventy percent of memory safety related

00:38:38,620 --> 00:38:45,300
problems are behind any reported exploit

00:38:42,300 --> 00:38:47,830
now arm invests heavily in hardware

00:38:45,300 --> 00:38:50,620
instruction set architecture evolutions

00:38:47,830 --> 00:38:54,340
to make everything more secure but the

00:38:50,620 --> 00:38:58,960
point behind the slide is this is hugely

00:38:54,340 --> 00:39:01,750
prevalent and what people don't realize

00:38:58,960 --> 00:39:05,410
is that many things have evolved to try

00:39:01,750 --> 00:39:07,810
and cover the gaps opened up by the

00:39:05,410 --> 00:39:09,220
memory safety issue but a lot of those

00:39:07,810 --> 00:39:11,590
things have

00:39:09,220 --> 00:39:14,590
the explicit costs or implicit costs and

00:39:11,590 --> 00:39:16,900
they tied up the stooling that's evolved

00:39:14,590 --> 00:39:19,290
its static analysis dynamic analysis

00:39:16,900 --> 00:39:22,960
hardware has been designed to be

00:39:19,290 --> 00:39:24,670
partition able there are memory ring

00:39:22,960 --> 00:39:28,030
fences this all kind of stuff right

00:39:24,670 --> 00:39:29,650
software development standards ISO 26262

00:39:28,030 --> 00:39:31,240
it's about you know making sure that the

00:39:29,650 --> 00:39:33,490
quality of software is okay it's

00:39:31,240 --> 00:39:36,040
performing to spec it does not have an

00:39:33,490 --> 00:39:37,780
inherent bug guess what a lot of the

00:39:36,040 --> 00:39:39,570
bugs they speak of in very abstract

00:39:37,780 --> 00:39:42,340
terms I actually memory safety-related

00:39:39,570 --> 00:39:45,160
so my point over here is that memory

00:39:42,340 --> 00:39:47,650
safety is at the root of a lot of extra

00:39:45,160 --> 00:39:49,180
cost thing it's hard to find people who

00:39:47,650 --> 00:39:51,040
understand the processes the

00:39:49,180 --> 00:39:54,130
certification standard so understand

00:39:51,040 --> 00:39:56,349
this is how the Assessors think people

00:39:54,130 --> 00:39:58,180
try and add language extensions

00:39:56,349 --> 00:40:00,849
dependent to try and work around this

00:39:58,180 --> 00:40:04,480
it's a different culture it's very

00:40:00,849 --> 00:40:06,550
expensive now where does I'm coming to

00:40:04,480 --> 00:40:09,430
all of this well as we all know hum is

00:40:06,550 --> 00:40:11,170
everywhere everywhere and that's not a

00:40:09,430 --> 00:40:13,300
nice place to be farmed from a safety

00:40:11,170 --> 00:40:14,740
and security point of view so we're

00:40:13,300 --> 00:40:19,119
constantly looking for better options

00:40:14,740 --> 00:40:20,980
for our partners and I started looking

00:40:19,119 --> 00:40:23,140
for technically sound options which had

00:40:20,980 --> 00:40:25,810
the right attributes for safety security

00:40:23,140 --> 00:40:29,050
and I found the trust has many of those

00:40:25,810 --> 00:40:32,440
attributes so on the language spectrum

00:40:29,050 --> 00:40:33,760
this Florine already spoke about this

00:40:32,440 --> 00:40:35,530
right so if you use those kind of

00:40:33,760 --> 00:40:37,570
subjective definition of high level

00:40:35,530 --> 00:40:40,720
languages and low level languages trust

00:40:37,570 --> 00:40:42,280
kind of lines somewhere in the middle I

00:40:40,720 --> 00:40:44,020
won't go through all of these details

00:40:42,280 --> 00:40:45,580
right but fundamentally you have more

00:40:44,020 --> 00:40:47,589
control with lower level languages in

00:40:45,580 --> 00:40:49,510
terms of code and data placement you

00:40:47,589 --> 00:40:51,670
have like the potential for

00:40:49,510 --> 00:40:53,920
deterministic execution the potential

00:40:51,670 --> 00:40:56,619
for getting wire speed out of whatever

00:40:53,920 --> 00:40:57,880
Hardware you're you're taking right but

00:40:56,619 --> 00:40:59,260
you'll have a very restricted

00:40:57,880 --> 00:41:00,730
programming environment you don't have

00:40:59,260 --> 00:41:03,550
access to lots of bells and whistles

00:41:00,730 --> 00:41:06,060
typically you have all of that with high

00:41:03,550 --> 00:41:07,900
level languages but then you sacrifice

00:41:06,060 --> 00:41:11,200
determinism and stuff like that

00:41:07,900 --> 00:41:13,540
rust is different right and this is

00:41:11,200 --> 00:41:15,910
where I end up sounding like an like an

00:41:13,540 --> 00:41:19,690
evangelical person but and I have lots

00:41:15,910 --> 00:41:22,480
of debates with people in and outside on

00:41:19,690 --> 00:41:22,779
I was the C guy who was saying oh here's

00:41:22,480 --> 00:41:26,829
a

00:41:22,779 --> 00:41:29,439
language but actually rusks ends up

00:41:26,829 --> 00:41:32,019
being a language that gives you the kind

00:41:29,439 --> 00:41:35,109
of speed envelope right associated with

00:41:32,019 --> 00:41:38,289
C C++ but with the kind of capabilities

00:41:35,109 --> 00:41:40,929
with modern more beefier languages like

00:41:38,289 --> 00:41:44,019
C++ but expressiveness like the high

00:41:40,929 --> 00:41:46,089
level languages most critically it gives

00:41:44,019 --> 00:41:48,459
you memory safety at compile time which

00:41:46,089 --> 00:41:52,169
I do not believe any other language

00:41:48,459 --> 00:41:55,029
paradigm has provided thus far not one

00:41:52,169 --> 00:41:57,039
so that's great but you know what does

00:41:55,029 --> 00:41:59,709
that really mean can you contrast these

00:41:57,039 --> 00:42:03,009
languages and that's really hard but I

00:41:59,709 --> 00:42:04,959
tried all the same these are numbers are

00:42:03,009 --> 00:42:06,699
borrowed from the infamous computer

00:42:04,959 --> 00:42:09,130
language benchmarks came they taken on

00:42:06,699 --> 00:42:11,079
an x86 64 host I'm getting numbers out

00:42:09,130 --> 00:42:13,749
for here at 64 hosts as well I haven't

00:42:11,079 --> 00:42:15,459
finished that yet first push back

00:42:13,749 --> 00:42:17,799
everyone has is oh you're using micro

00:42:15,459 --> 00:42:20,439
benchmarks I won't talk to you but hold

00:42:17,799 --> 00:42:22,900
on I mean it's hard to find a collection

00:42:20,439 --> 00:42:24,669
of algorithms that can be that have

00:42:22,900 --> 00:42:26,829
already been implemented idiomatically

00:42:24,669 --> 00:42:29,199
in the whole spectrum of languages this

00:42:26,829 --> 00:42:31,089
is the one resource I found and don't

00:42:29,199 --> 00:42:32,799
forget that micro benchmarks actually

00:42:31,089 --> 00:42:34,539
are the first port of call for processor

00:42:32,799 --> 00:42:36,400
designers an IP designers because when

00:42:34,539 --> 00:42:37,119
you're running at 10 kilohertz on RTL

00:42:36,400 --> 00:42:39,789
simulation

00:42:37,119 --> 00:42:42,429
you can't run Linux or Windows there so

00:42:39,789 --> 00:42:44,829
there's value here and actually if you

00:42:42,429 --> 00:42:47,650
look at it these are all the the

00:42:44,829 --> 00:42:48,909
benchmarks that are modeled inside the

00:42:47,650 --> 00:42:50,859
computer language benchmarks game

00:42:48,909 --> 00:42:54,549
website the links here trust is quite

00:42:50,859 --> 00:42:56,499
compelling I wanted to put in something

00:42:54,549 --> 00:42:59,859
other than a micro benchmark and what I

00:42:56,499 --> 00:43:02,679
found was the taken power kind of web

00:42:59,859 --> 00:43:04,239
server framework shoot out and there's

00:43:02,679 --> 00:43:07,689
this thing called act exquisite Ihnen

00:43:04,239 --> 00:43:09,249
rust it basically wipes the floor right

00:43:07,689 --> 00:43:11,140
with all the others which written in

00:43:09,249 --> 00:43:13,779
other languages is that a strong

00:43:11,140 --> 00:43:15,699
endorsement not really but you know you

00:43:13,779 --> 00:43:17,799
can't ignore this so there are

00:43:15,699 --> 00:43:19,689
criticisms right there is an initial

00:43:17,799 --> 00:43:21,519
learning curve especially when you

00:43:19,689 --> 00:43:24,640
grapple with the compiler and the memory

00:43:21,519 --> 00:43:26,759
safety checks compilation times are

00:43:24,640 --> 00:43:29,469
pretty high this is all being worked on

00:43:26,759 --> 00:43:31,449
there are some problem use cases where

00:43:29,469 --> 00:43:33,699
it just doesn't fit well today right

00:43:31,449 --> 00:43:36,880
like gooeys but there are always kind of

00:43:33,699 --> 00:43:39,070
mixed opinions ax a bi stability

00:43:36,880 --> 00:43:41,200
rust affords to be nimble while at the

00:43:39,070 --> 00:43:43,180
same time being backwards compatible but

00:43:41,200 --> 00:43:45,310
then API stability is one of those

00:43:43,180 --> 00:43:47,380
aspects that gets affected there is no

00:43:45,310 --> 00:43:51,369
iso style language spec like you have

00:43:47,380 --> 00:43:53,800
with C or C++ now all of these areas

00:43:51,369 --> 00:43:57,700
where there's work underway to fix it

00:43:53,800 --> 00:43:59,770
for arm the rest community has worked on

00:43:57,700 --> 00:44:02,470
a class definition and a policy for

00:43:59,770 --> 00:44:04,660
classifying different architecture

00:44:02,470 --> 00:44:07,240
specific targets in terms of support so

00:44:04,660 --> 00:44:08,980
that the tier 1 tier 2 tier 3 you had 64

00:44:07,240 --> 00:44:12,339
targets are not tier 1 yet right so

00:44:08,980 --> 00:44:14,619
that's that's a gap now what do we want

00:44:12,339 --> 00:44:17,710
to do a time now this is a highly

00:44:14,619 --> 00:44:21,670
stylized view of pretty much any typical

00:44:17,710 --> 00:44:23,020
stack of modern software it doesn't make

00:44:21,670 --> 00:44:24,640
sense to rip out everything in rewrite

00:44:23,020 --> 00:44:26,530
in rust for all of the good reason cycle

00:44:24,640 --> 00:44:28,210
previously but there are certain

00:44:26,530 --> 00:44:31,089
foundational aspects like secure from

00:44:28,210 --> 00:44:34,119
the boot loaders hypervisors which are

00:44:31,089 --> 00:44:36,490
so much in the hot path of safety and

00:44:34,119 --> 00:44:40,030
security that it does make sense to

00:44:36,490 --> 00:44:45,310
actually consider in part or outright

00:44:40,030 --> 00:44:46,750
rewrites so I'm helping find ways in

00:44:45,310 --> 00:44:49,810
which we can work with the last

00:44:46,750 --> 00:44:52,540
community and businesses peripheral to

00:44:49,810 --> 00:44:55,720
the last community to come up with these

00:44:52,540 --> 00:44:58,240
three layers done for cortex a cortex

00:44:55,720 --> 00:44:59,859
are and cortex-m processor profiles some

00:44:58,240 --> 00:45:02,740
of this is already underway some of it

00:44:59,859 --> 00:45:04,180
is in the offing in the future this is

00:45:02,740 --> 00:45:06,640
the sequence we're gonna follow I'm

00:45:04,180 --> 00:45:08,500
working with the the core team the rust

00:45:06,640 --> 00:45:10,869
language core team to implement a CI

00:45:08,500 --> 00:45:13,119
loop which is one big blocker for the

00:45:10,869 --> 00:45:14,680
tier 1 categorization once we've

00:45:13,119 --> 00:45:17,080
attained that I will be working with

00:45:14,680 --> 00:45:20,349
andrey Richter's excellent cortex a

00:45:17,080 --> 00:45:23,650
great adding abstractions therefore mmm

00:45:20,349 --> 00:45:25,390
use gigs etc and then that unblocks in a

00:45:23,650 --> 00:45:29,260
standardized way the implementation of

00:45:25,390 --> 00:45:31,260
firmware for cortex a a boot load story

00:45:29,260 --> 00:45:33,550
like the excellent old boot project and

00:45:31,260 --> 00:45:36,460
what I believe is really important or

00:45:33,550 --> 00:45:37,150
type-1 at least a partitioning

00:45:36,460 --> 00:45:39,400
hypervisor

00:45:37,150 --> 00:45:41,650
in rust that's an open question right

00:45:39,400 --> 00:45:43,570
now and I'm happy to discuss options and

00:45:41,650 --> 00:45:45,970
ideas over there we are also working on

00:45:43,570 --> 00:45:47,650
getting simp support for arm same D

00:45:45,970 --> 00:45:49,380
intrinsic sin to the rust language this

00:45:47,650 --> 00:45:51,849
is also underway

00:45:49,380 --> 00:45:53,980
Florine mentioned seal rust that's

00:45:51,849 --> 00:45:56,500
hugely important I think that's what

00:45:53,980 --> 00:46:00,220
will give us like like an executable

00:45:56,500 --> 00:46:02,800
formally verifiable specification for

00:46:00,220 --> 00:46:05,920
the language or a small safe subset of

00:46:02,800 --> 00:46:08,080
it and that's interesting enough for a

00:46:05,920 --> 00:46:10,450
lot of people who take note and we'll be

00:46:08,080 --> 00:46:13,270
working with shield Russ to try and help

00:46:10,450 --> 00:46:16,810
define that get the right buy-in involve

00:46:13,270 --> 00:46:20,260
the right people so that's my ten minute

00:46:16,810 --> 00:46:24,720
take on where arm comes in and where

00:46:20,260 --> 00:46:24,720
comes going with this that's all I had

00:46:25,050 --> 00:46:28,170
thank you

00:46:29,700 --> 00:46:34,480
Thank You Robin Florian there's a couple

00:46:33,099 --> 00:46:36,190
questions in the chat I don't know if

00:46:34,480 --> 00:46:44,980
you guys wanted to take a few minutes to

00:46:36,190 --> 00:46:47,950
go through some of those well sure sorry

00:46:44,980 --> 00:46:51,520
uh have you have you are those available

00:46:47,950 --> 00:46:53,260
in the chat window or yeah if you open

00:46:51,520 --> 00:46:56,200
do you have the chat the zoom webinar

00:46:53,260 --> 00:47:01,210
chat open I don't seem to see it loading

00:46:56,200 --> 00:47:03,839
do you should be next to the share

00:47:01,210 --> 00:47:03,839
screen button

00:47:08,089 --> 00:47:17,499
Oh on you you that if you mute yourself

00:47:20,140 --> 00:47:23,900
okay at this there was actually a

00:47:22,459 --> 00:47:25,939
question any richer arrest events

00:47:23,900 --> 00:47:29,299
meetups workshops upcoming there was

00:47:25,939 --> 00:47:33,829
actually one last Friday which as I run

00:47:29,299 --> 00:47:35,900
the oxidized conference we did something

00:47:33,829 --> 00:47:38,599
called the oxidized 1k ten speakers

00:47:35,900 --> 00:47:42,709
ten minutes and euros like every we talk

00:47:38,599 --> 00:47:43,849
ten minutes not the whole event and that

00:47:42,709 --> 00:47:50,299
was really good

00:47:43,849 --> 00:47:55,099
and there's other events like all other

00:47:50,299 --> 00:47:57,709
events have now basically committed to

00:47:55,099 --> 00:48:00,019
have an online component or fully gogit

00:47:57,709 --> 00:48:03,049
role so rust Fest has been pushed back

00:48:00,019 --> 00:48:06,410
it should have been in June and the

00:48:03,049 --> 00:48:09,619
Netherlands has disallowed all public

00:48:06,410 --> 00:48:12,199
gatherings until June 1st and it was

00:48:09,619 --> 00:48:14,809
planned for June 6 and that will

00:48:12,199 --> 00:48:16,789
probably happen component day I can

00:48:14,809 --> 00:48:21,319
highly recommend going to oxidize conf

00:48:16,789 --> 00:48:27,199
calm for following like baby embedded

00:48:21,319 --> 00:48:28,489
news there yeah there's a couple of

00:48:27,199 --> 00:48:31,459
other questions there if you want to

00:48:28,489 --> 00:48:33,289
have a look at those fluorine mm-hmm

00:48:31,459 --> 00:48:37,579
what's the smallest microcontroller than

00:48:33,289 --> 00:48:39,589
Russ can target I have to I have to

00:48:37,579 --> 00:48:41,569
admit I studied a better development and

00:48:39,589 --> 00:48:42,769
then I built CD ends for a while and

00:48:41,569 --> 00:48:46,640
then I moved back into embedded

00:48:42,769 --> 00:48:52,969
development I'm going to go come back to

00:48:46,640 --> 00:48:56,029
you with a question later but tiny a our

00:48:52,969 --> 00:48:58,189
goal is everything that C runs on and in

00:48:56,029 --> 00:48:59,959
the end what you can always do is you

00:48:58,189 --> 00:49:03,619
can do away with all the conveniences of

00:48:59,959 --> 00:49:05,439
the language not use generics for binary

00:49:03,619 --> 00:49:08,749
size and all these kind of things and

00:49:05,439 --> 00:49:11,119
this always attempts to build trust

00:49:08,749 --> 00:49:14,630
programs that are smaller C programs so

00:49:11,119 --> 00:49:16,039
yeah really often this the biggest

00:49:14,630 --> 00:49:18,199
problem that we pretty often have is

00:49:16,039 --> 00:49:21,349
because our main code generator is

00:49:18,199 --> 00:49:25,009
currently LLVM the

00:49:21,349 --> 00:49:27,529
as always does the LLVM support this

00:49:25,009 --> 00:49:28,940
particular piece of hardware that's the

00:49:27,529 --> 00:49:31,039
biggest problem and if not you don't

00:49:28,940 --> 00:49:32,660
have to write it for a worst case you

00:49:31,039 --> 00:49:36,650
have to write another VM target for it

00:49:32,660 --> 00:49:38,979
which is its own fear of load

00:49:36,650 --> 00:49:42,559
although the LLVM project has become

00:49:38,979 --> 00:49:44,930
much much better at integrating those

00:49:42,559 --> 00:49:49,220
targets but also what you need to bring

00:49:44,930 --> 00:49:50,599
is maintenance guarantees so they won't

00:49:49,220 --> 00:49:54,249
merge anything where they're not sure

00:49:50,599 --> 00:49:54,249
that this will not be a code um

00:50:00,039 --> 00:50:04,670
basically the question about can you use

00:50:02,539 --> 00:50:08,029
rust to write an i2c driver or a you

00:50:04,670 --> 00:50:09,619
boot absolutely there already is a the

00:50:08,029 --> 00:50:12,700
numerous implementations are fairly

00:50:09,619 --> 00:50:14,869
capable boot loaders written interest

00:50:12,700 --> 00:50:16,729
I've personally been involved with the

00:50:14,869 --> 00:50:18,529
microkernel written in rust there are a

00:50:16,729 --> 00:50:23,509
whole bunch of drivers on it that we

00:50:18,529 --> 00:50:29,089
wrote in rust microchannels redox if

00:50:23,509 --> 00:50:32,390
you're interesting Trust doesn't need

00:50:29,089 --> 00:50:34,579
semaphores rust does need semaphores but

00:50:32,390 --> 00:50:35,869
I think that entirely depends on what

00:50:34,579 --> 00:50:36,349
you're trying to synchronize and put a

00:50:35,869 --> 00:50:40,849
train

00:50:36,349 --> 00:50:42,950
I suppose it's fair to say that in the

00:50:40,849 --> 00:50:45,950
general case because a lot of tea is

00:50:42,950 --> 00:50:47,690
kind of these checks are done by the

00:50:45,950 --> 00:50:50,569
compiler for you for example if you got

00:50:47,690 --> 00:50:53,329
some mutable state that's shared and you

00:50:50,569 --> 00:50:56,690
decide to use a lock so kind of

00:50:53,329 --> 00:50:58,369
arbitrate access as opposed to the case

00:50:56,690 --> 00:50:59,719
where you were using C where you would

00:50:58,369 --> 00:51:01,489
have to pick a semaphore but you might

00:50:59,719 --> 00:51:03,650
have forgotten to take it and introduced

00:51:01,489 --> 00:51:05,920
a bug you won't have that problem with

00:51:03,650 --> 00:51:08,539
rust because the compiler will ensure a

00:51:05,920 --> 00:51:11,239
synchronization primitive is taken when

00:51:08,539 --> 00:51:16,420
an access to the memory that it protects

00:51:11,239 --> 00:51:20,749
happens so yeah it's usually valuable

00:51:16,420 --> 00:51:22,450
yeah there's a there's a lot of strategy

00:51:20,749 --> 00:51:24,710
around implementation strategy around

00:51:22,450 --> 00:51:26,539
any kind of synchronization primitives

00:51:24,710 --> 00:51:27,950
that make sure that all unlocking and

00:51:26,539 --> 00:51:29,539
locking is done properly that you don't

00:51:27,950 --> 00:51:32,660
forget unlocking and all of these kind

00:51:29,539 --> 00:51:34,580
of things and that you um rust can for

00:51:32,660 --> 00:51:37,430
example also ensure that you don't

00:51:34,580 --> 00:51:44,320
hold a reference to the part that was

00:51:37,430 --> 00:51:48,740
locked while while unlocking it again so

00:51:44,320 --> 00:51:50,830
there's a there's a lot of safety gains

00:51:48,740 --> 00:51:54,160
also in single-threaded code to be had

00:51:50,830 --> 00:51:54,160
absolutely yeah

00:51:54,190 --> 00:52:00,950
how many rust libraries are available

00:51:56,300 --> 00:52:02,570
Wow standard library a library for some

00:52:00,950 --> 00:52:05,180
particular applications

00:52:02,570 --> 00:52:06,740
the problem this this is actually an

00:52:05,180 --> 00:52:09,200
interesting question

00:52:06,740 --> 00:52:11,690
these tons of rust libraries available

00:52:09,200 --> 00:52:14,750
we're talking 50,000 60,000 something

00:52:11,690 --> 00:52:16,100
like that but if you'd heard the

00:52:14,750 --> 00:52:17,920
question is always what's your frame of

00:52:16,100 --> 00:52:21,130
reference if you're comparing that to

00:52:17,920 --> 00:52:25,130
they say there's a nice website that

00:52:21,130 --> 00:52:28,550
gives you graphs for all the for all the

00:52:25,130 --> 00:52:30,290
package managers and in the systems

00:52:28,550 --> 00:52:33,740
programming language space rust is the

00:52:30,290 --> 00:52:40,010
leader if you click on JavaScript all

00:52:33,740 --> 00:52:43,340
lines of flat the interesting thing is

00:52:40,010 --> 00:52:46,490
which area it's it's given that the

00:52:43,340 --> 00:52:49,010
language is five years old mostly and

00:52:46,490 --> 00:52:50,540
the the real industry adoption big

00:52:49,010 --> 00:52:54,230
industry adoption has happened roughly

00:52:50,540 --> 00:52:57,050
around over the last three years it may

00:52:54,230 --> 00:52:59,450
end up that some areas have huge gaps so

00:52:57,050 --> 00:53:01,670
for example AI is completely dominated

00:52:59,450 --> 00:53:03,560
by tensorflow currently and no one's got

00:53:01,670 --> 00:53:05,480
the money and the investment to write

00:53:03,560 --> 00:53:07,550
something equivalent to tensorflow

00:53:05,480 --> 00:53:09,650
on the other hand everything that has to

00:53:07,550 --> 00:53:11,480
do with xml parsing rendering and

00:53:09,650 --> 00:53:15,650
whatever is really really in a good

00:53:11,480 --> 00:53:20,080
shape why because our our initial

00:53:15,650 --> 00:53:22,940
project was a render engine and

00:53:20,080 --> 00:53:25,880
everything that has to do with C and C++

00:53:22,940 --> 00:53:27,920
integration is also in a very good shape

00:53:25,880 --> 00:53:31,160
why because Mozilla has to do that all

00:53:27,920 --> 00:53:36,080
the time for Firefox so even complex

00:53:31,160 --> 00:53:41,650
things like gluing C++ classes into for

00:53:36,080 --> 00:53:45,500
a Russ code and homework for embedded

00:53:41,650 --> 00:53:47,570
especially it's basically depending on

00:53:45,500 --> 00:53:48,380
how easy the board is to work with a lot

00:53:47,570 --> 00:53:54,470
of the things are

00:53:48,380 --> 00:53:56,690
by by companies and by companies are not

00:53:54,470 --> 00:53:59,809
by the port vendor themselves currently

00:53:56,690 --> 00:54:00,200
and that means things that are easy to

00:53:59,809 --> 00:54:04,119
work with

00:54:00,200 --> 00:54:04,119
without vendor support get support first

00:54:05,680 --> 00:54:08,720
there's another thing which I am

00:54:07,490 --> 00:54:11,779
compelled to say I don't know how much

00:54:08,720 --> 00:54:13,819
time you have but one interesting thing

00:54:11,779 --> 00:54:15,230
that I realized was that as we move

00:54:13,819 --> 00:54:18,410
towards like safety in

00:54:15,230 --> 00:54:20,569
security-conscious future openness and

00:54:18,410 --> 00:54:23,420
transparency are an absolute requirement

00:54:20,569 --> 00:54:24,950
right but that also flies in the face of

00:54:23,420 --> 00:54:26,509
the traditional approach to safety and

00:54:24,950 --> 00:54:29,150
security which is all about propriety

00:54:26,509 --> 00:54:31,160
closed driven by a committee driven by

00:54:29,150 --> 00:54:33,710
you know like Assessor than certifiers

00:54:31,160 --> 00:54:35,750
what I found interesting about rust was

00:54:33,710 --> 00:54:37,430
that the evolution of the language the

00:54:35,750 --> 00:54:38,390
technical and strategic evolution of the

00:54:37,430 --> 00:54:41,839
language is done

00:54:38,390 --> 00:54:43,910
it's an is on github you can create an

00:54:41,839 --> 00:54:45,049
out of C and say this is a feature which

00:54:43,910 --> 00:54:47,299
I think rust should have and make a

00:54:45,049 --> 00:54:49,460
strong technical argument or a strategic

00:54:47,299 --> 00:54:50,930
one and if it has merit that will

00:54:49,460 --> 00:54:52,819
directly influence the evolution of the

00:54:50,930 --> 00:54:54,470
language you don't have that kind of

00:54:52,819 --> 00:54:57,019
power when you're working with saying in

00:54:54,470 --> 00:55:00,529
C++ for any language that I've come

00:54:57,019 --> 00:55:03,500
across which is which is interesting

00:55:00,529 --> 00:55:05,859
right so I like that because I want to

00:55:03,500 --> 00:55:08,390
see a future where you know like

00:55:05,859 --> 00:55:11,029
especially safety and security related

00:55:08,390 --> 00:55:12,880
software is absolutely open-source and

00:55:11,029 --> 00:55:15,289
there's no two ways about it

00:55:12,880 --> 00:55:21,950
having the language be completely open

00:55:15,289 --> 00:55:23,930
is a fantastic way to get that off I'd

00:55:21,950 --> 00:55:27,019
also like to highlight especially you

00:55:23,930 --> 00:55:29,029
see C++ community has taken a lot of the

00:55:27,019 --> 00:55:31,700
interactions that we had and in a very

00:55:29,029 --> 00:55:33,650
very positive way so there's a lot of

00:55:31,700 --> 00:55:36,470
cross-pollination so for example our

00:55:33,650 --> 00:55:40,039
async/await feature is currently

00:55:36,470 --> 00:55:41,569
influencing future design in c++ for

00:55:40,039 --> 00:55:46,730
example and the other way around

00:55:41,569 --> 00:55:49,750
so this is much less of a battle as

00:55:46,730 --> 00:55:53,450
people sometimes try to make it be it's

00:55:49,750 --> 00:55:56,029
from most people that I know that are

00:55:53,450 --> 00:55:59,089
very high involved in programming

00:55:56,029 --> 00:56:01,880
language development it's usually Oh

00:55:59,089 --> 00:56:02,160
finally systems programming is on the

00:56:01,880 --> 00:56:05,460
tail

00:56:02,160 --> 00:56:08,520
again so finally people are talking

00:56:05,460 --> 00:56:09,930
about my problems again and this is very

00:56:08,520 --> 00:56:11,250
much the conversation that I would like

00:56:09,930 --> 00:56:13,260
to have and we have an approach to all

00:56:11,250 --> 00:56:17,190
of these kind of things other languages

00:56:13,260 --> 00:56:19,560
have other approaches so another

00:56:17,190 --> 00:56:22,590
interesting one Lake so a lot of people

00:56:19,560 --> 00:56:24,390
would in in my debates inside an outside

00:56:22,590 --> 00:56:26,310
arm they would come and say that you've

00:56:24,390 --> 00:56:28,340
drunk the kool-aid stop making so many

00:56:26,310 --> 00:56:30,630
assumptions about trust and I was like

00:56:28,340 --> 00:56:32,940
please try it out right so before

00:56:30,630 --> 00:56:35,400
forming an opinion spend a weekend let's

00:56:32,940 --> 00:56:38,160
just treat the book read a few total

00:56:35,400 --> 00:56:39,960
tutorials try and write that one program

00:56:38,160 --> 00:56:42,000
that command-line thing you wrote in C

00:56:39,960 --> 00:56:45,330
or C++ is right right if you're a Python

00:56:42,000 --> 00:56:48,420
Ruby there's something to be said for

00:56:45,330 --> 00:56:51,180
how approachable case once you beyond

00:56:48,420 --> 00:56:52,500
the initial curve okay can answer you

00:56:51,180 --> 00:56:59,040
lost two questions we still have time

00:56:52,500 --> 00:57:00,300
for that you know I'm so there's no one

00:56:59,040 --> 00:57:02,250
coming and after you so yeah feel free

00:57:00,300 --> 00:57:04,380
okay okay good because I think they're

00:57:02,250 --> 00:57:06,050
very interesting so will it make it

00:57:04,380 --> 00:57:08,600
difficult to standardize the C and C++

00:57:06,050 --> 00:57:11,430
that's difficult in the security world

00:57:08,600 --> 00:57:13,710
we do have so first of all the the

00:57:11,430 --> 00:57:16,680
benefit of having the whole track record

00:57:13,710 --> 00:57:18,840
of our development open is that there is

00:57:16,680 --> 00:57:20,730
already a lot of specification so how

00:57:18,840 --> 00:57:24,930
should a certain feature behave is in

00:57:20,730 --> 00:57:28,110
the RFC what's missing is and that's

00:57:24,930 --> 00:57:30,990
what we do in that's what we was our

00:57:28,110 --> 00:57:32,280
intention with this us project is taking

00:57:30,990 --> 00:57:34,650
all of these things and moving them

00:57:32,280 --> 00:57:36,990
together it's also not as we not as like

00:57:34,650 --> 00:57:38,130
we don't care that plays into the second

00:57:36,990 --> 00:57:44,840
question where the rest has a memory

00:57:38,130 --> 00:57:48,960
model like C++ 11 and we do not have a

00:57:44,840 --> 00:57:51,000
fully fixed memory model yet because due

00:57:48,960 --> 00:57:54,240
to certain kind of things like borrowing

00:57:51,000 --> 00:57:57,510
or has a different semantics from just

00:57:54,240 --> 00:58:00,360
plain references rust references have a

00:57:57,510 --> 00:58:04,170
different have a different memory they

00:58:00,360 --> 00:58:07,110
have you not at runtime but logically

00:58:04,170 --> 00:58:08,910
and that means that part of this is a

00:58:07,110 --> 00:58:11,390
research question but that research has

00:58:08,910 --> 00:58:14,490
been happening since 2014 at the

00:58:11,390 --> 00:58:17,030
University of the broken it's called the

00:58:14,490 --> 00:58:19,710
sealed Russ project a

00:58:17,030 --> 00:58:22,610
it's called the a stuff project I'm

00:58:19,710 --> 00:58:24,870
confusing the Rust Belt project and

00:58:22,610 --> 00:58:28,200
everyone on the Rust Belt project is

00:58:24,870 --> 00:58:31,830
actually part of the rust team so that's

00:58:28,200 --> 00:58:36,390
already integrated within our project so

00:58:31,830 --> 00:58:39,300
what's missing is the final push to make

00:58:36,390 --> 00:58:40,740
that into an industry consumable form

00:58:39,300 --> 00:58:46,050
and that also means that for example

00:58:40,740 --> 00:58:47,880
borrowing and ownership is is logically

00:58:46,050 --> 00:58:51,900
verified and proven so if there's a

00:58:47,880 --> 00:58:53,970
there's a there's a proper logical proof

00:58:51,900 --> 00:58:56,490
that it fulfills all the assumptions

00:58:53,970 --> 00:58:59,130
that we have and we have found bugs it

00:58:56,490 --> 00:59:01,350
like not in the core concept but for

00:58:59,130 --> 00:59:03,660
example a number of standard library

00:59:01,350 --> 00:59:07,710
types are also have also been modeled

00:59:03,660 --> 00:59:08,610
with improving and it's very quickly if

00:59:07,710 --> 00:59:11,520
you have Atomics

00:59:08,610 --> 00:59:14,070
I mean rust has a Atomics and if you use

00:59:11,520 --> 00:59:16,050
variables of an atomic type you can

00:59:14,070 --> 00:59:17,940
specify the memory consistency property

00:59:16,050 --> 00:59:20,130
you want for accesses made to that

00:59:17,940 --> 00:59:21,390
variable so you can have like you can

00:59:20,130 --> 00:59:24,300
say I want a sequentially consistent

00:59:21,390 --> 00:59:26,640
access etc from that standpoint the

00:59:24,300 --> 00:59:29,310
memory model that rust uses is actually

00:59:26,640 --> 00:59:32,040
the right memory model that LLVM affords

00:59:29,310 --> 00:59:35,400
it right I know this because I asked

00:59:32,040 --> 00:59:39,810
once and I was told that since LLVM has

00:59:35,400 --> 00:59:42,060
a view on memory consistency associated

00:59:39,810 --> 00:59:43,830
with Atomics and since pretty much that

00:59:42,060 --> 00:59:45,960
part of the LLVM has been adopted by

00:59:43,830 --> 00:59:47,700
rust for its implementation of Atomics

00:59:45,960 --> 00:59:55,680
that's essentially the memory model in

00:59:47,700 --> 00:59:58,020
use today and the final question does

00:59:55,680 --> 00:59:59,520
was recognize that's natively no rust

00:59:58,020 --> 01:00:01,800
has no idea of a thread and that's

00:59:59,520 --> 01:00:04,650
that's what that's a bit a bit a bit of

01:00:01,800 --> 01:00:06,890
a brain tease of the language is the

01:00:04,650 --> 01:00:11,340
whole concurrency safety story comes by

01:00:06,890 --> 01:00:13,620
not allowing in any case to be mutable

01:00:11,340 --> 01:00:16,350
access to a memory location active where

01:00:13,620 --> 01:00:18,780
there's any kind of reading or other

01:00:16,350 --> 01:00:21,480
writing access there and that's as

01:00:18,780 --> 01:00:24,770
abstract as it goes but that means we

01:00:21,480 --> 01:00:27,210
can make we can make sure that

01:00:24,770 --> 01:00:29,460
independent off your concurrency model

01:00:27,210 --> 01:00:30,210
or or your parallelize model of B

01:00:29,460 --> 01:00:33,690
threads

01:00:30,210 --> 01:00:35,310
or something like that rust has no idea

01:00:33,690 --> 01:00:38,670
of that but it can provide safety

01:00:35,310 --> 01:00:40,770
guarantees around this rust for example

01:00:38,670 --> 01:00:43,470
understands when a value travels between

01:00:40,770 --> 01:00:45,240
two concurrent components and that's

01:00:43,470 --> 01:00:46,349
really really interesting because it

01:00:45,240 --> 01:00:48,089
doesn't know what the concurrent

01:00:46,349 --> 01:00:52,530
component is that could be two pieces of

01:00:48,089 --> 01:00:54,750
hardware but could be two two pieces of

01:00:52,530 --> 01:00:57,990
hardware on the same board things like

01:00:54,750 --> 01:01:00,150
that that doesn't go like infinitely

01:00:57,990 --> 01:01:03,599
deep so obviously there's there's limits

01:01:00,150 --> 01:01:05,609
but the same goes was what I hinted that

01:01:03,599 --> 01:01:09,150
with the async/await syntax is that the

01:01:05,609 --> 01:01:11,099
language gives you primitives but you

01:01:09,150 --> 01:01:14,490
need to fill them in and that gives you

01:01:11,099 --> 01:01:18,080
the freedom of of choosing how you fill

01:01:14,490 --> 01:01:19,800
them in for example in the case of a

01:01:18,080 --> 01:01:22,770
concurrent program

01:01:19,800 --> 01:01:24,480
what does trigger like basically this

01:01:22,770 --> 01:01:26,550
awaits in text says I waiting for the

01:01:24,480 --> 01:01:28,349
completion of something how can it how

01:01:26,550 --> 01:01:31,230
do I get notified of completion either

01:01:28,349 --> 01:01:33,660
the kernel calls me on Linux or a

01:01:31,230 --> 01:01:36,150
hardware triggers a piece of hardware

01:01:33,660 --> 01:01:38,580
triggers the timer triggers and that

01:01:36,150 --> 01:01:42,950
wakes me up and that's all possible in

01:01:38,580 --> 01:01:46,530
that model just a question from me

01:01:42,950 --> 01:01:48,359
Florian the standard library does treat

01:01:46,530 --> 01:01:50,520
threads as first-class citizens the

01:01:48,359 --> 01:01:53,730
writers in like you can use study thread

01:01:50,520 --> 01:01:56,599
and kind of spawn threads and

01:01:53,730 --> 01:01:59,190
synchronize between them etcetera right

01:01:56,599 --> 01:02:01,290
yeah yeah but it's a standard library

01:01:59,190 --> 01:02:12,320
concern yes yeah yeah and the static

01:02:01,290 --> 01:02:12,320
library introduced this by using West

01:02:14,750 --> 01:02:21,060
that's a good question first of all you

01:02:18,990 --> 01:02:23,040
can always trigger a compiler bug like

01:02:21,060 --> 01:02:24,839
the grass compiler is not perfect and

01:02:23,040 --> 01:02:32,640
it's pretty hard to trigger compiler

01:02:24,839 --> 01:02:36,300
bugs but so but that's with any kind of

01:02:32,640 --> 01:02:38,400
larger larger system this is also one of

01:02:36,300 --> 01:02:40,560
the reasons why compiler bugs explicitly

01:02:38,400 --> 01:02:42,630
ruled out from back from backwards

01:02:40,560 --> 01:02:44,040
compatibility if there's a if there's a

01:02:42,630 --> 01:02:45,750
a sound that's all

01:02:44,040 --> 01:02:48,060
in the type system this is considered a

01:02:45,750 --> 01:02:49,320
bug and will be fixed in the next

01:02:48,060 --> 01:02:50,130
version even if your code doesn't

01:02:49,320 --> 01:02:58,220
compile it anymore

01:02:50,130 --> 01:02:58,220
and we did run something called the

01:02:58,400 --> 01:03:05,220
hazard cult these kind of contests where

01:03:03,060 --> 01:03:13,290
you try to sneak something into into a

01:03:05,220 --> 01:03:20,040
program like a Trojan yeah they had the

01:03:13,290 --> 01:03:22,950
name yesterday but forget today and we

01:03:20,040 --> 01:03:25,560
did try run a contest where you you but

01:03:22,950 --> 01:03:29,280
all bets off and you were encouraged to

01:03:25,560 --> 01:03:32,910
build a a security problem problem into

01:03:29,280 --> 01:03:34,530
a back door into a Russ program it

01:03:32,910 --> 01:03:38,790
turned out that a lot of people found it

01:03:34,530 --> 01:03:41,310
very hard to do so but one of the axes

01:03:38,790 --> 01:03:42,990
actually did so through an

01:03:41,310 --> 01:03:47,070
implementation bug in the standard

01:03:42,990 --> 01:03:48,450
library so if one of the but if one of

01:03:47,070 --> 01:03:50,550
the types in the standard library has a

01:03:48,450 --> 01:03:55,830
bug there we go

01:03:50,550 --> 01:04:00,210
and we fix that bug later another one

01:03:55,830 --> 01:04:06,240
actually used our infrastructure to ship

01:04:00,210 --> 01:04:09,050
a configuration payload it's pretty hard

01:04:06,240 --> 01:04:11,400
yeah you know who might be angling for

01:04:09,050 --> 01:04:12,900
Russ to school and all and you made a

01:04:11,400 --> 01:04:15,360
strong case for how it really helped

01:04:12,900 --> 01:04:16,770
safety in security but what if the what

01:04:15,360 --> 01:04:18,990
if there's our kind of like a design

01:04:16,770 --> 01:04:22,350
decision that was wrong right or the

01:04:18,990 --> 01:04:24,420
logic was flawed in some way okay is

01:04:22,350 --> 01:04:27,240
there like is there a repository of

01:04:24,420 --> 01:04:30,390
information about typical logical flaws

01:04:27,240 --> 01:04:32,790
in software construction and how does

01:04:30,390 --> 01:04:34,350
rust stack up in terms of trying to

01:04:32,790 --> 01:04:36,210
prevent them or at least that's my

01:04:34,350 --> 01:04:43,020
interpretation of his question

01:04:36,210 --> 01:04:45,720
okay okay there's a positive around that

01:04:43,020 --> 01:04:48,300
and one of the problems being and this

01:04:45,720 --> 01:04:52,260
is a pretty clear problem and unsafe

01:04:48,300 --> 01:04:54,360
Ross is not see and that means rust has

01:04:52,260 --> 01:04:56,460
for example different kinds of undefined

01:04:54,360 --> 01:04:57,630
behavior when we're talking about unsafe

01:04:56,460 --> 01:05:01,559
rust and see

01:04:57,630 --> 01:05:05,779
as so pretty often a problem that we see

01:05:01,559 --> 01:05:08,279
is people making assumptions around

01:05:05,779 --> 01:05:10,890
pointers assuming that they know how

01:05:08,279 --> 01:05:12,839
they behave and know how they and

01:05:10,890 --> 01:05:14,940
without having proper knowledge and for

01:05:12,839 --> 01:05:17,519
example how rust references should

01:05:14,940 --> 01:05:21,750
behave so on the edge of unsafe to save

01:05:17,519 --> 01:05:24,900
rust you need a thorough amount of

01:05:21,750 --> 01:05:32,700
knowledge about the language itself and

01:05:24,900 --> 01:05:34,920
if it's how should I say it sometimes

01:05:32,700 --> 01:05:39,240
looks like something else like it's a

01:05:34,920 --> 01:05:41,400
it's a it's it's sometimes easy to fall

01:05:39,240 --> 01:05:46,589
into the trap to think you know how it

01:05:41,400 --> 01:05:49,589
behaves and I think that is a we will

01:05:46,589 --> 01:05:52,440
see we both see these kinds of issues

01:05:49,589 --> 01:05:55,019
I think Raghu makes an interesting point

01:05:52,440 --> 01:05:56,759
though again I'm just like conjuring

01:05:55,019 --> 01:05:59,599
this output I assume this is what he

01:05:56,759 --> 01:06:02,670
meant basically there is a case for

01:05:59,599 --> 01:06:04,769
somebody recording what are you like you

01:06:02,670 --> 01:06:07,319
know anti-patterns in security software

01:06:04,769 --> 01:06:09,079
design right as i'd like here are the

01:06:07,319 --> 01:06:12,890
things that are kind of like

01:06:09,079 --> 01:06:15,150
traditionally horrible right and and I

01:06:12,890 --> 01:06:16,559
mean in a very focused way I don't mean

01:06:15,150 --> 01:06:17,700
generally speaking because there's so

01:06:16,559 --> 01:06:19,500
much you can do the wrong way but

01:06:17,700 --> 01:06:21,539
fundamentally when you do security

01:06:19,500 --> 01:06:25,259
software other are these anti patterns

01:06:21,539 --> 01:06:28,259
that are prevalent with C and C++ and is

01:06:25,259 --> 01:06:32,039
there it does does rusts memory safety

01:06:28,259 --> 01:06:33,930
kind of how does that how does that

01:06:32,039 --> 01:06:35,460
affect that anti-pattern it does it does

01:06:33,930 --> 01:06:35,970
it help in kind of dismissing it

01:06:35,460 --> 01:06:38,250
outright

01:06:35,970 --> 01:06:39,839
or not I think that's a good question

01:06:38,250 --> 01:06:47,730
and that's something we should we should

01:06:39,839 --> 01:06:50,180
talk about we can't solve the world we

01:06:47,730 --> 01:06:53,930
solve the specific specific problem

01:06:50,180 --> 01:06:53,930
there's actually a pretty interesting

01:06:54,140 --> 01:07:00,299
blog post by the inventor of life going

01:06:57,269 --> 01:07:03,210
horror on the release of rs.10 when he

01:07:00,299 --> 01:07:05,369
wasn't with the team anymore but about

01:07:03,210 --> 01:07:07,650
things that rust has solved and things

01:07:05,369 --> 01:07:10,680
that rust hasn't solved for example it

01:07:07,650 --> 01:07:13,260
hasn't done it hasn't made

01:07:10,680 --> 01:07:14,910
error-handling at large more convenient

01:07:13,260 --> 01:07:19,490
that's still a problem how do whole

01:07:14,910 --> 01:07:22,380
applications handle errors properly and

01:07:19,490 --> 01:07:24,000
that sometimes that sometimes a problem

01:07:22,380 --> 01:07:27,840
where people just ignore errors for

01:07:24,000 --> 01:07:29,280
convenience that's like that's a classic

01:07:27,840 --> 01:07:31,050
thing like I don't want to forward this

01:07:29,280 --> 01:07:33,330
I don't want like I just want to forget

01:07:31,050 --> 01:07:35,130
this and then then it was something

01:07:33,330 --> 01:07:39,630
important I've actually seen the

01:07:35,130 --> 01:07:42,150
converse of that rain I've seen when the

01:07:39,630 --> 01:07:44,850
compiler is actually not very good at

01:07:42,150 --> 01:07:47,190
giving you reports on stuff that you've

01:07:44,850 --> 01:07:50,160
done wrong yeah which is unfortunately

01:07:47,190 --> 01:07:53,670
typically the case with C and C++ then

01:07:50,160 --> 01:07:55,530
the programmers attitude is I'll do

01:07:53,670 --> 01:07:57,810
whatever I can to get rid of the

01:07:55,530 --> 01:07:59,340
warnings and or just ignore them

01:07:57,810 --> 01:08:01,890
outright so I can ship my product right

01:07:59,340 --> 01:08:04,320
so that's like that that's one level of

01:08:01,890 --> 01:08:06,630
existence in rust comes along and the

01:08:04,320 --> 01:08:09,120
compiler absolutely bombards you with a

01:08:06,630 --> 01:08:11,010
warning saying no you have to fix these

01:08:09,120 --> 01:08:13,590
things otherwise either not let you pass

01:08:11,010 --> 01:08:16,710
and then the attitude becomes one of I

01:08:13,590 --> 01:08:19,320
can't do anything with this thing which

01:08:16,710 --> 01:08:21,330
is like completely off the rails right

01:08:19,320 --> 01:08:23,400
now the compilers going out of its way

01:08:21,330 --> 01:08:25,410
to tell you dude you can't do that

01:08:23,400 --> 01:08:26,940
buffer overflow can you please fix it

01:08:25,410 --> 01:08:28,920
otherwise I will not let you pause right

01:08:26,940 --> 01:08:40,560
and now suddenly a man I can't deal

01:08:28,920 --> 01:08:42,630
with this yeah yeah okay I hope we went

01:08:40,560 --> 01:08:46,940
into all the currents of this question

01:08:42,630 --> 01:08:49,410
[Laughter]

01:08:46,940 --> 01:08:51,560
if there's any more please please be in

01:08:49,410 --> 01:08:51,560

YouTube URL: https://www.youtube.com/watch?v=yE55ZpQmw9Q


