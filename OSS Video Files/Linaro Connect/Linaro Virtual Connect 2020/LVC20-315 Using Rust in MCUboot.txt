Title: LVC20-315 Using Rust in MCUboot
Publication date: 2020-09-22
Playlist: Linaro Virtual Connect 2020
Description: 
	DESCRIPTION 
It seems the Rust programming language comes up frequently these days, and there is a lot of interest in it. We have been using Rust to implement a simulation test environment within MCUboot since 2017. This presentation will discuss our experience with Rust, and our hopes of how this language might help other projects in the future, especially in regards to security.


Watch the video and download the slides for this session here: https://connect.linaro.org/resources/lvc20/lvc20-315/
Captions: 
	00:00:26,160 --> 00:00:30,000
the rest programming language was

00:00:27,760 --> 00:00:32,880
initially developed a bit over ten years

00:00:30,000 --> 00:00:34,480
ago by great and and others while

00:00:32,880 --> 00:00:37,680
at mozilla

00:00:34,480 --> 00:00:40,000
the 1.0 release was about five years ago

00:00:37,680 --> 00:00:42,480
and the language and community around it

00:00:40,000 --> 00:00:44,320
have grown since

00:00:42,480 --> 00:00:45,840
the goal was to create a language that

00:00:44,320 --> 00:00:46,719
could be used for the same types of

00:00:45,840 --> 00:00:49,039
problems as c

00:00:46,719 --> 00:00:50,160
plus plus but without all the issues of

00:00:49,039 --> 00:00:51,840
memory safety

00:00:50,160 --> 00:00:54,160
and the challenges of managing that

00:00:51,840 --> 00:00:55,840
memory languages like java

00:00:54,160 --> 00:00:58,000
address the memory safety issues by

00:00:55,840 --> 00:01:00,399
using garbage collection

00:00:58,000 --> 00:01:01,840
pointers can be freely shared but there

00:01:00,399 --> 00:01:03,840
is an overhead needed

00:01:01,840 --> 00:01:05,360
to figure out what memory is no longer

00:01:03,840 --> 00:01:08,159
used

00:01:05,360 --> 00:01:10,080
in rust programs that don't make use of

00:01:08,159 --> 00:01:12,720
the unsafe back door

00:01:10,080 --> 00:01:14,720
shouldn't be able to cause a seg fault

00:01:12,720 --> 00:01:15,680
rust manages this by introducing the

00:01:14,720 --> 00:01:18,880
concepts

00:01:15,680 --> 00:01:20,720
of ownership and borrowing ownership

00:01:18,880 --> 00:01:22,880
simply states that every entity managed

00:01:20,720 --> 00:01:24,880
by the program has a single owner

00:01:22,880 --> 00:01:27,439
this owner may be a particular part of

00:01:24,880 --> 00:01:28,880
the code or it may be a field in another

00:01:27,439 --> 00:01:30,960
data structure

00:01:28,880 --> 00:01:33,680
the ownership can be moved but the old

00:01:30,960 --> 00:01:35,439
location is then no longer valid

00:01:33,680 --> 00:01:37,840
references to these items can be

00:01:35,439 --> 00:01:39,680
borrowed and the correct use of both

00:01:37,840 --> 00:01:41,920
ownership and borrowing are strictly

00:01:39,680 --> 00:01:43,520
checked at compile time

00:01:41,920 --> 00:01:45,840
although i don't have that much time in

00:01:43,520 --> 00:01:48,399
this presentation to go into much detail

00:01:45,840 --> 00:01:49,920
about rust's concept of borrowing

00:01:48,399 --> 00:01:51,920
i think it would be helpful to give a

00:01:49,920 --> 00:01:54,479
few examples

00:01:51,920 --> 00:01:55,759
this first example creates a local

00:01:54,479 --> 00:01:58,159
variable in a function

00:01:55,759 --> 00:01:59,360
foo and passes a reference to that

00:01:58,159 --> 00:02:00,960
variable to bar

00:01:59,360 --> 00:02:03,439
where bar can print the value of the

00:02:00,960 --> 00:02:04,640
variable this isn't very different than

00:02:03,439 --> 00:02:08,239
what could be done in c

00:02:04,640 --> 00:02:10,399
or c plus plus however the compiler

00:02:08,239 --> 00:02:13,120
enforces that this reference to

00:02:10,399 --> 00:02:14,400
a can never be used beyond what the

00:02:13,120 --> 00:02:17,120
variable itself

00:02:14,400 --> 00:02:19,360
would live so if barr were to try to

00:02:17,120 --> 00:02:21,920
store this reference somewhere or if

00:02:19,360 --> 00:02:22,879
foo tried to return it the result would

00:02:21,920 --> 00:02:25,840
be a compile

00:02:22,879 --> 00:02:27,680
error so in addition to regular

00:02:25,840 --> 00:02:29,120
references we can also have mutable

00:02:27,680 --> 00:02:30,959
references

00:02:29,120 --> 00:02:32,800
rust is more strict about mutable

00:02:30,959 --> 00:02:35,200
references in that any given place

00:02:32,800 --> 00:02:37,599
through the execution of the code

00:02:35,200 --> 00:02:38,239
there can only be a single mutable

00:02:37,599 --> 00:02:40,640
reference

00:02:38,239 --> 00:02:42,480
to something if we tried to use a

00:02:40,640 --> 00:02:44,800
non-mutable reference to a

00:02:42,480 --> 00:02:47,920
while this mutable reference were live

00:02:44,800 --> 00:02:49,840
it would result again in a compile error

00:02:47,920 --> 00:02:51,599
now this next example shows a data

00:02:49,840 --> 00:02:53,519
structure where we have a method that

00:02:51,599 --> 00:02:56,640
returns a mutable reference

00:02:53,519 --> 00:02:58,319
to something inside of that struct the

00:02:56,640 --> 00:03:00,319
compiler is able to determine that the

00:02:58,319 --> 00:03:01,440
mutable reference to the inside of the

00:03:00,319 --> 00:03:03,200
struct

00:03:01,440 --> 00:03:05,599
also means that there's a reference to

00:03:03,200 --> 00:03:07,440
the struct and is able to restrict other

00:03:05,599 --> 00:03:10,000
references to the struct

00:03:07,440 --> 00:03:11,599
this can sometimes be a bit clumsy if

00:03:10,000 --> 00:03:13,599
you need to have references to different

00:03:11,599 --> 00:03:15,200
parts of the same struct

00:03:13,599 --> 00:03:16,720
and is one of the aspects of rust that

00:03:15,200 --> 00:03:17,120
makes it somewhat more difficult to

00:03:16,720 --> 00:03:20,400
learn

00:03:17,120 --> 00:03:22,319
than a lot of other languages however

00:03:20,400 --> 00:03:24,239
although something like c or c plus plus

00:03:22,319 --> 00:03:25,840
lets you fairly arbitrarily take these

00:03:24,239 --> 00:03:27,519
kind of references

00:03:25,840 --> 00:03:29,440
it's also fairly easy to do in an

00:03:27,519 --> 00:03:31,200
invalid way

00:03:29,440 --> 00:03:33,040
now because not all programs can be

00:03:31,200 --> 00:03:35,120
expressed with these more strict rules

00:03:33,040 --> 00:03:37,599
about ownership and borrowing

00:03:35,120 --> 00:03:39,840
the russ standard library also has types

00:03:37,599 --> 00:03:41,680
for shared references including both

00:03:39,840 --> 00:03:43,920
single threaded and thread safe

00:03:41,680 --> 00:03:45,920
reference counted pointers

00:03:43,920 --> 00:03:47,519
another aspect of the borrow checker is

00:03:45,920 --> 00:03:51,840
that the compiler is able to ensure

00:03:47,519 --> 00:03:51,840
thread safety across the sharing of data

00:03:52,400 --> 00:03:56,239
because of this checking and the

00:03:54,239 --> 00:03:57,360
increase in the safety and security of

00:03:56,239 --> 00:03:59,280
the code

00:03:57,360 --> 00:04:01,920
there is a growing interest in the rust

00:03:59,280 --> 00:04:03,760
language and adoption by numerous large

00:04:01,920 --> 00:04:07,439
players

00:04:03,760 --> 00:04:09,840
this brings us to mcu boot mcu boot

00:04:07,439 --> 00:04:11,680
began as the bootloader for the minute

00:04:09,840 --> 00:04:14,000
real-time operating system which was

00:04:11,680 --> 00:04:17,199
developed by runtime.io

00:04:14,000 --> 00:04:19,120
i david brown working for lenaro ported

00:04:17,199 --> 00:04:20,639
this bootloader to zephyr

00:04:19,120 --> 00:04:22,880
and this code is now used in other

00:04:20,639 --> 00:04:24,400
places as well such as the bootloader

00:04:22,880 --> 00:04:28,080
for the trusted firmware m

00:04:24,400 --> 00:04:31,440
project this bootloader is written in c

00:04:28,080 --> 00:04:33,600
with some support tools in python and go

00:04:31,440 --> 00:04:34,479
the purpose of mcu boot as a secure

00:04:33,600 --> 00:04:36,560
bootloader

00:04:34,479 --> 00:04:38,320
is to establish a cryptographically

00:04:36,560 --> 00:04:41,520
strong route of trust

00:04:38,320 --> 00:04:42,000
in microcontroller devices it validates

00:04:41,520 --> 00:04:45,199
digital

00:04:42,000 --> 00:04:47,280
signatures on images before running them

00:04:45,199 --> 00:04:48,639
as well as validating signatures on

00:04:47,280 --> 00:04:50,639
upgrade

00:04:48,639 --> 00:04:52,320
and before installing these upgrade

00:04:50,639 --> 00:04:54,720
images

00:04:52,320 --> 00:04:56,000
the most complicated operation the mcu

00:04:54,720 --> 00:04:59,040
boot performs

00:04:56,000 --> 00:05:01,360
is with an update method known as swap

00:04:59,040 --> 00:05:02,479
the idea which may sound simple at first

00:05:01,360 --> 00:05:04,560
is to take

00:05:02,479 --> 00:05:06,160
the images in two separate areas of

00:05:04,560 --> 00:05:08,960
flash known as slots

00:05:06,160 --> 00:05:11,039
and exchange them this has to be done in

00:05:08,960 --> 00:05:12,639
such a way that if power is lost during

00:05:11,039 --> 00:05:14,960
the operation

00:05:12,639 --> 00:05:15,919
it's able to recover and complete the

00:05:14,960 --> 00:05:17,759
swap

00:05:15,919 --> 00:05:19,039
we currently have two variants of the

00:05:17,759 --> 00:05:21,840
operation

00:05:19,039 --> 00:05:23,600
and a third is under development now

00:05:21,840 --> 00:05:24,240
there's other configuration choices

00:05:23,600 --> 00:05:26,560
available

00:05:24,240 --> 00:05:28,800
such as one known as direct execute in

00:05:26,560 --> 00:05:31,440
place where the code's not moved

00:05:28,800 --> 00:05:33,280
but linked to run at the correct address

00:05:31,440 --> 00:05:35,280
in addition it can also be configured to

00:05:33,280 --> 00:05:37,759
load the code from flash into ram

00:05:35,280 --> 00:05:39,680
although there's many microcontrollers

00:05:37,759 --> 00:05:42,400
that don't have enough sram to really be

00:05:39,680 --> 00:05:42,400
able to do this

00:05:44,000 --> 00:05:50,320
this swap process is fairly complicated

00:05:47,199 --> 00:05:52,000
and is crucial that it be correct it's

00:05:50,320 --> 00:05:54,560
the only part of mcu boot

00:05:52,000 --> 00:05:56,080
that modifies persistent state it

00:05:54,560 --> 00:05:57,840
modifies flash

00:05:56,080 --> 00:05:59,759
and if it goes wrong the end result is

00:05:57,840 --> 00:06:03,039
usually an unusable device or

00:05:59,759 --> 00:06:05,120
a brick another reason it's so important

00:06:03,039 --> 00:06:08,479
that the swap code be correct

00:06:05,120 --> 00:06:09,840
is that mcu boot itself is difficult if

00:06:08,479 --> 00:06:12,880
not impossible

00:06:09,840 --> 00:06:14,800
to upgrade in a deployed device

00:06:12,880 --> 00:06:16,639
for this reason we attempt to place as

00:06:14,800 --> 00:06:17,680
little functionality as possible in the

00:06:16,639 --> 00:06:19,840
bootloader

00:06:17,680 --> 00:06:22,080
but being able to safely and securely

00:06:19,840 --> 00:06:24,479
install an upgrade is part of this core

00:06:22,080 --> 00:06:27,199
functionality

00:06:24,479 --> 00:06:29,120
while i was porting mcu boot to zephyr i

00:06:27,199 --> 00:06:30,240
began to realize that of all of the

00:06:29,120 --> 00:06:31,919
parts of the code

00:06:30,240 --> 00:06:34,960
this swap operation was the most

00:06:31,919 --> 00:06:36,400
difficult to test because power loss can

00:06:34,960 --> 00:06:38,800
occur at any time

00:06:36,400 --> 00:06:41,520
really testing this code would require

00:06:38,800 --> 00:06:43,520
causing a power failure at any stage

00:06:41,520 --> 00:06:46,479
testing at this level is pretty much

00:06:43,520 --> 00:06:49,759
impossible on real devices

00:06:46,479 --> 00:06:52,880
instead i chose to write a simulator

00:06:49,759 --> 00:06:54,479
and test framework to test this based on

00:06:52,880 --> 00:06:56,000
some past experience

00:06:54,479 --> 00:06:57,599
as well as some of the advantages of

00:06:56,000 --> 00:06:58,319
rust we decided to implement this

00:06:57,599 --> 00:07:01,599
simulator

00:06:58,319 --> 00:07:03,440
in rust the simulator attaches to mcu

00:07:01,599 --> 00:07:06,080
boot at the api level

00:07:03,440 --> 00:07:07,840
of calls to the flash driver which

00:07:06,080 --> 00:07:11,199
primarily consists of read

00:07:07,840 --> 00:07:12,160
write and erase and writing this in rust

00:07:11,199 --> 00:07:14,000
gives us some

00:07:12,160 --> 00:07:15,840
pretty immediate advantages the rust

00:07:14,000 --> 00:07:18,560
language ecosystem

00:07:15,840 --> 00:07:20,400
already has a test framework which

00:07:18,560 --> 00:07:21,599
supports running multiple tests in

00:07:20,400 --> 00:07:23,360
parallel

00:07:21,599 --> 00:07:25,280
because of the ownership and borrow

00:07:23,360 --> 00:07:26,720
checker in the compiler

00:07:25,280 --> 00:07:28,560
many types of bugs that would be

00:07:26,720 --> 00:07:31,840
difficult to find in the simulator

00:07:28,560 --> 00:07:32,319
can now be found at compile time now the

00:07:31,840 --> 00:07:34,319
main

00:07:32,319 --> 00:07:37,440
challenge of doing this was handling the

00:07:34,319 --> 00:07:39,520
mismatch of calling between rust and c

00:07:37,440 --> 00:07:41,280
it turns out it's not actually that bad

00:07:39,520 --> 00:07:43,440
a struct in rust can be given a

00:07:41,280 --> 00:07:45,199
directive which tells the compiler

00:07:43,440 --> 00:07:47,759
to ensure it's laid out in memory the

00:07:45,199 --> 00:07:50,479
same way that the c compiler would

00:07:47,759 --> 00:07:53,199
calling in to c and back does require

00:07:50,479 --> 00:07:54,960
the use of the unsafe keyword in rust

00:07:53,199 --> 00:07:59,039
but it's contained to a small part of

00:07:54,960 --> 00:08:01,199
the code and fairly easily managed

00:07:59,039 --> 00:08:03,520
in the end we developed a test framework

00:08:01,199 --> 00:08:04,080
that's able to test the behavior of mcu

00:08:03,520 --> 00:08:06,319
boot

00:08:04,080 --> 00:08:08,400
when power is lost at every part of the

00:08:06,319 --> 00:08:10,639
code where this can happen

00:08:08,400 --> 00:08:12,960
it also tests multiple failures in a

00:08:10,639 --> 00:08:13,520
random manner it can't test all of these

00:08:12,960 --> 00:08:15,360
because

00:08:13,520 --> 00:08:17,360
the number of possible occurrences is

00:08:15,360 --> 00:08:19,680
too large

00:08:17,360 --> 00:08:22,240
these simulator tests allowed us to find

00:08:19,680 --> 00:08:23,039
and fix a number of bugs in the mcu boot

00:08:22,240 --> 00:08:25,120
code

00:08:23,039 --> 00:08:27,199
that could cause device failures on real

00:08:25,120 --> 00:08:30,080
devices if power was removed at those

00:08:27,199 --> 00:08:31,680
particular points in the operation

00:08:30,080 --> 00:08:33,279
now in addition to the power down

00:08:31,680 --> 00:08:35,519
testing we have added code to the

00:08:33,279 --> 00:08:36,240
simulator to test other features of mcu

00:08:35,519 --> 00:08:38,000
boot

00:08:36,240 --> 00:08:39,519
and continue to work to bring the level

00:08:38,000 --> 00:08:43,519
of testing up to the point where

00:08:39,519 --> 00:08:43,519
every feature is tested

00:08:45,040 --> 00:08:50,240
rust however isn't a panacea

00:08:48,560 --> 00:08:52,160
although it does bring definite

00:08:50,240 --> 00:08:54,720
advantages to us

00:08:52,160 --> 00:08:56,240
there were some hurdles to get over and

00:08:54,720 --> 00:08:59,040
a few issues that we still

00:08:56,240 --> 00:09:01,040
encounter one of the first things that

00:08:59,040 --> 00:09:04,399
we discovered is that the rus test

00:09:01,040 --> 00:09:06,880
framework tries to run tests on as many

00:09:04,399 --> 00:09:08,959
cpus as are available

00:09:06,880 --> 00:09:10,160
since mcu boot was originally written as

00:09:08,959 --> 00:09:11,920
embedded code

00:09:10,160 --> 00:09:13,839
most of the state was simply stored in

00:09:11,920 --> 00:09:15,279
global variables and this didn't work

00:09:13,839 --> 00:09:17,279
very well

00:09:15,279 --> 00:09:18,720
at all when it was invoked for multiple

00:09:17,279 --> 00:09:20,640
threads

00:09:18,720 --> 00:09:23,600
our initial workaround was simply to add

00:09:20,640 --> 00:09:25,279
a mutex that was taken by each test

00:09:23,600 --> 00:09:27,920
this effectively made it so that only

00:09:25,279 --> 00:09:29,920
one test would run at a time

00:09:27,920 --> 00:09:31,440
eventually we move this global state

00:09:29,920 --> 00:09:32,320
into a struct that would be passed

00:09:31,440 --> 00:09:33,920
around

00:09:32,320 --> 00:09:36,000
for the embedded builds there is a

00:09:33,920 --> 00:09:37,120
single instance of this that is used but

00:09:36,000 --> 00:09:39,200
for testing

00:09:37,120 --> 00:09:40,640
it's allocated by the test framework in

00:09:39,200 --> 00:09:43,360
rust and passed

00:09:40,640 --> 00:09:44,959
in now cleaning the global state up in

00:09:43,360 --> 00:09:45,760
this way also helped us to make sure

00:09:44,959 --> 00:09:48,399
that when

00:09:45,760 --> 00:09:49,200
simulating a power loss the global state

00:09:48,399 --> 00:09:51,360
is

00:09:49,200 --> 00:09:54,160
truly cleared and we didn't rely on

00:09:51,360 --> 00:09:56,399
values persisting across the reboot in

00:09:54,160 --> 00:09:58,240
memory

00:09:56,399 --> 00:09:59,760
now the other primary difficulty we

00:09:58,240 --> 00:10:01,279
encountered with rust

00:09:59,760 --> 00:10:02,959
is a lack of developers that are

00:10:01,279 --> 00:10:05,680
knowledgeable in rust

00:10:02,959 --> 00:10:06,079
what this means is most contributions to

00:10:05,680 --> 00:10:08,480
the c

00:10:06,079 --> 00:10:10,240
code of mcu boot don't come with

00:10:08,480 --> 00:10:11,839
simulator tests to test this

00:10:10,240 --> 00:10:15,200
functionality

00:10:11,839 --> 00:10:17,200
we've mitigated this in two primary ways

00:10:15,200 --> 00:10:19,519
one is to encourage contributors to at

00:10:17,200 --> 00:10:21,279
least try to build the simulator

00:10:19,519 --> 00:10:23,120
and make sure that their change doesn't

00:10:21,279 --> 00:10:26,079
break the simulator

00:10:23,120 --> 00:10:27,680
although ci will catch this breakage we

00:10:26,079 --> 00:10:29,519
do run the tests

00:10:27,680 --> 00:10:31,600
these contributions need to at least be

00:10:29,519 --> 00:10:33,920
able to run the simulator

00:10:31,600 --> 00:10:36,640
in order to be able to debug and fix the

00:10:33,920 --> 00:10:39,120
problems that it finds for them

00:10:36,640 --> 00:10:40,959
the other mitigation is that at least

00:10:39,120 --> 00:10:43,279
two of the primary maintainers for the

00:10:40,959 --> 00:10:44,800
project are versed in rust

00:10:43,279 --> 00:10:47,120
beyond just making sure that new

00:10:44,800 --> 00:10:48,880
contributions don't break existing tests

00:10:47,120 --> 00:10:52,640
we've added numerous tests

00:10:48,880 --> 00:10:55,680
test the new functionality as well

00:10:52,640 --> 00:10:57,920
overall we find that using rust to drive

00:10:55,680 --> 00:11:00,640
our simulation and testing framework

00:10:57,920 --> 00:11:02,560
benefits the project one question that

00:11:00,640 --> 00:11:04,480
comes up from time to time however is

00:11:02,560 --> 00:11:07,440
whether the bootloader itself

00:11:04,480 --> 00:11:09,279
should be rewritten in rust many of the

00:11:07,440 --> 00:11:09,920
advantages of memory safety would

00:11:09,279 --> 00:11:12,880
benefit

00:11:09,920 --> 00:11:15,120
this security critical piece of code

00:11:12,880 --> 00:11:16,000
support for rust on embedded devices is

00:11:15,120 --> 00:11:18,000
nascent

00:11:16,000 --> 00:11:19,760
there are a few different efforts most

00:11:18,000 --> 00:11:20,640
have only a few boards that are

00:11:19,760 --> 00:11:22,320
supported

00:11:20,640 --> 00:11:24,880
and the hardware that is supported on

00:11:22,320 --> 00:11:26,320
these boards is minimal

00:11:24,880 --> 00:11:28,240
it could still be a worthwhile

00:11:26,320 --> 00:11:29,920
investigative effort to see if rust

00:11:28,240 --> 00:11:31,839
would be helpful here

00:11:29,920 --> 00:11:34,320
but it will be a while before there is a

00:11:31,839 --> 00:11:37,040
community around embedded rust

00:11:34,320 --> 00:11:40,079
and enough device support for this to be

00:11:37,040 --> 00:11:42,320
a truly viable solution

00:11:40,079 --> 00:11:43,680
another possible way to support rust on

00:11:42,320 --> 00:11:46,320
embedded targets

00:11:43,680 --> 00:11:46,959
would be to port the rust run time to an

00:11:46,320 --> 00:11:49,920
existing

00:11:46,959 --> 00:11:51,120
rtos such as zephyr the rtos would still

00:11:49,920 --> 00:11:52,800
be written in c

00:11:51,120 --> 00:11:54,560
and the application will call into it

00:11:52,800 --> 00:11:56,880
from rust

00:11:54,560 --> 00:11:57,839
the memory safety improvements would be

00:11:56,880 --> 00:12:00,800
seen however

00:11:57,839 --> 00:12:02,399
in the bootloader so an important

00:12:00,800 --> 00:12:04,160
consideration when thinking about

00:12:02,399 --> 00:12:06,800
another programming language

00:12:04,160 --> 00:12:09,279
is whether this is worth doing there's

00:12:06,800 --> 00:12:10,720
kind of an ongoing joke which is not

00:12:09,279 --> 00:12:12,399
really a joke

00:12:10,720 --> 00:12:13,920
about the tendency people have when

00:12:12,399 --> 00:12:16,720
learning rust to want to

00:12:13,920 --> 00:12:18,079
rewrite their project in rust

00:12:16,720 --> 00:12:20,880
interestingly at least

00:12:18,079 --> 00:12:23,200
once there's good embedded support mcu

00:12:20,880 --> 00:12:25,760
boot may be a good candidate for that

00:12:23,200 --> 00:12:27,600
isn't too large of a body of code and

00:12:25,760 --> 00:12:29,200
it's code that would really benefit from

00:12:27,600 --> 00:12:31,120
the features that russ brings to the

00:12:29,200 --> 00:12:33,519
table

00:12:31,120 --> 00:12:35,600
realistically a rust bootloader would

00:12:33,519 --> 00:12:37,600
probably be a separate project

00:12:35,600 --> 00:12:38,880
possibly sharing data formats and

00:12:37,600 --> 00:12:41,120
algorithms

00:12:38,880 --> 00:12:43,680
and could have the opportunity to grow

00:12:41,120 --> 00:12:53,839
and develop on its own

00:12:43,680 --> 00:12:53,839
thank you very much

00:13:00,639 --> 00:13:02,720

YouTube URL: https://www.youtube.com/watch?v=hFbjxUsMObU


