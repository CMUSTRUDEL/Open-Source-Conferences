Title: LVC20 119 Extending SCMI beyond Embedded
Publication date: 2020-10-08
Playlist: Linaro Virtual Connect 2020
Description: 
	The ARM SCMI specification provides a standardized interface for OS/Firmware coordinated power management. SCMI has been adopted today for platforms primarily targeted at the mobile/client/embedded segment. As Arm-based SoCs increasingly find their way into Infrastructure and Automotive, standardizing Power Management in products targeted at these segments becomes a necessity to prevent software fragmentation.

In this session we will explore how SCMI can be extended to standardize power management for Arm-based SoCs targeted at Infrastructure and Automotive. We will look at how SCMI can work through ACPI which is commonly used in most kernels targeted at the Infrastructure space. We would also have a look at how an Automotive Power Management stack can be setup with the help of SCMI.

For the presentation see: https://static.linaro.org/connect/lvc20/presentations/LVC20-119-0.pdf
Captions: 
	00:00:00,160 --> 00:00:04,159
thanks everybody for joining um

00:00:04,720 --> 00:00:10,719
in this session i try to cover um

00:00:07,839 --> 00:00:11,759
the upcoming deployment scenarios of

00:00:10,719 --> 00:00:14,719
scmi

00:00:11,759 --> 00:00:15,679
in other environments typically we've

00:00:14,719 --> 00:00:18,800
seen how hdmi

00:00:15,679 --> 00:00:20,560
works on device 3 based systems uh

00:00:18,800 --> 00:00:21,840
we'll try to see how that can be scaled

00:00:20,560 --> 00:00:23,760
across and then i'll

00:00:21,840 --> 00:00:25,599
follow through with a few more updates

00:00:23,760 --> 00:00:28,160
as well um

00:00:25,599 --> 00:00:30,640
i'll probably use 20 odd minutes but in

00:00:28,160 --> 00:00:34,160
case you have some questions in between

00:00:30,640 --> 00:00:35,280
please keep them popping up on the chat

00:00:34,160 --> 00:00:40,320
screen and we'll take them

00:00:35,280 --> 00:00:42,320
up so as far as the agenda today goes

00:00:40,320 --> 00:00:43,760
i'll do a brief introduction of what

00:00:42,320 --> 00:00:46,960
scmi is

00:00:43,760 --> 00:00:48,719
in case there are people who

00:00:46,960 --> 00:00:50,320
would like to have a small introduction

00:00:48,719 --> 00:00:52,480
of what it is

00:00:50,320 --> 00:00:55,760
i'll provide some updates on the

00:00:52,480 --> 00:00:59,199
upcoming version 3 of the specification

00:00:55,760 --> 00:01:01,280
should be released quite shortly um then

00:00:59,199 --> 00:01:04,559
i provide an overview of how you could

00:01:01,280 --> 00:01:05,760
use an scmi compliant firmware for acpi

00:01:04,559 --> 00:01:08,479
based systems

00:01:05,760 --> 00:01:09,760
now this would be important if you are

00:01:08,479 --> 00:01:12,240
one of those

00:01:09,760 --> 00:01:14,320
who would like to have us the same

00:01:12,240 --> 00:01:17,600
silicon run acpi as well

00:01:14,320 --> 00:01:20,000
as well as device 3 based software

00:01:17,600 --> 00:01:21,280
and you'd still like to keep a unified

00:01:20,000 --> 00:01:22,720
firmware binary

00:01:21,280 --> 00:01:24,960
so that'll be very useful in these

00:01:22,720 --> 00:01:26,640
scenarios and the fourth slide i will

00:01:24,960 --> 00:01:30,159
provide a little bit of overview of

00:01:26,640 --> 00:01:32,000
scmi and one of the deployment scenarios

00:01:30,159 --> 00:01:35,439
in virtualization

00:01:32,000 --> 00:01:37,360
i think uh etienne and vincent did talk

00:01:35,439 --> 00:01:38,720
about that in one of their slides it's

00:01:37,360 --> 00:01:42,079
just a

00:01:38,720 --> 00:01:42,079
deeper dive into what that is

00:01:46,720 --> 00:01:52,640
introduction to scmi

00:01:50,079 --> 00:01:53,680
now semi is a firmware interface

00:01:52,640 --> 00:01:55,759
specification

00:01:53,680 --> 00:01:56,799
that's specifically targeted at power

00:01:55,759 --> 00:01:59,520
management

00:01:56,799 --> 00:02:01,600
and system control and you could use it

00:01:59,520 --> 00:02:03,840
for your bare metal systems or your

00:02:01,600 --> 00:02:06,640
virtualized systems as well

00:02:03,840 --> 00:02:08,879
so it provides both kinds of capability

00:02:06,640 --> 00:02:09,599
primarily because the specification

00:02:08,879 --> 00:02:13,440
itself

00:02:09,599 --> 00:02:15,599
is comprising of two layers

00:02:13,440 --> 00:02:16,879
one is a messaging layers messaging

00:02:15,599 --> 00:02:20,000
layer which is

00:02:16,879 --> 00:02:23,520
uh fixed which which is the way in which

00:02:20,000 --> 00:02:26,080
you encode messages for power control

00:02:23,520 --> 00:02:27,840
to send across to the smi server

00:02:26,080 --> 00:02:29,680
wherever it resides

00:02:27,840 --> 00:02:31,440
and the other part of the specification

00:02:29,680 --> 00:02:33,840
talks about transports

00:02:31,440 --> 00:02:35,440
uh now semi does provide you with a

00:02:33,840 --> 00:02:38,879
choice of transports

00:02:35,440 --> 00:02:41,360
and the ability to select whichever is

00:02:38,879 --> 00:02:42,879
the most optimal for your own deployment

00:02:41,360 --> 00:02:44,800
and configuration

00:02:42,879 --> 00:02:46,959
now the specification does provide

00:02:44,800 --> 00:02:48,800
examples of a few transports

00:02:46,959 --> 00:02:50,560
but you could even have your own

00:02:48,800 --> 00:02:52,319
transport if you're willing to upstream

00:02:50,560 --> 00:02:55,120
that code into linux and that

00:02:52,319 --> 00:02:56,000
works fairly as well so the messaging

00:02:55,120 --> 00:02:58,000
part is

00:02:56,000 --> 00:03:00,080
fairly well decoupled from the transport

00:02:58,000 --> 00:03:01,040
paths and it provides you the capability

00:03:00,080 --> 00:03:03,920
to pro

00:03:01,040 --> 00:03:05,680
to choose whatever you wish to so for

00:03:03,920 --> 00:03:07,440
example today we have

00:03:05,680 --> 00:03:10,159
transports that work not only on

00:03:07,440 --> 00:03:12,879
hardware-based mailboxes but also on

00:03:10,159 --> 00:03:15,840
smc hvc based doorbells so that's the

00:03:12,879 --> 00:03:18,159
flexibility that it provides

00:03:15,840 --> 00:03:20,000
the specification continues to evolve in

00:03:18,159 --> 00:03:21,599
collaboration with partners and the open

00:03:20,000 --> 00:03:23,120
source community and that's where a lot

00:03:21,599 --> 00:03:25,680
of the inputs come from and

00:03:23,120 --> 00:03:27,120
a lot a lot of the drive comes from so

00:03:25,680 --> 00:03:29,200
if any of you have got

00:03:27,120 --> 00:03:30,560
questions have got more inputs that you

00:03:29,200 --> 00:03:32,720
want to provide do get us

00:03:30,560 --> 00:03:34,720
get in touch with us and we'll be happy

00:03:32,720 --> 00:03:38,000
to take forward their inputs and

00:03:34,720 --> 00:03:40,319
provide resolve issues in whatever ways

00:03:38,000 --> 00:03:41,920
we can in the specification

00:03:40,319 --> 00:03:44,080
um and the reference kernel and the

00:03:41,920 --> 00:03:46,080
firmware support are fairly regularly

00:03:44,080 --> 00:03:47,440
available through open source software

00:03:46,080 --> 00:03:48,959
so you could have a look at the

00:03:47,440 --> 00:03:50,319
specification you could have a look at

00:03:48,959 --> 00:03:51,840
the reference kernel and firmware and

00:03:50,319 --> 00:03:52,400
you'll get a fairly good idea of how you

00:03:51,840 --> 00:03:54,239
could

00:03:52,400 --> 00:03:55,920
bring your system up within various

00:03:54,239 --> 00:03:57,360
considerations and of course there are

00:03:55,920 --> 00:04:00,000
different leonardo projects running

00:03:57,360 --> 00:04:01,439
related to hdmi or deploying the semi

00:04:00,000 --> 00:04:03,200
server in different configurations

00:04:01,439 --> 00:04:03,519
that's fairly useful as well because you

00:04:03,200 --> 00:04:07,120
would

00:04:03,519 --> 00:04:07,120
you could use a lot of the code

00:04:08,319 --> 00:04:13,360
scmi v3 now we are coming up with a new

00:04:11,439 --> 00:04:14,560
version of the specification the one

00:04:13,360 --> 00:04:17,040
you'll see currently

00:04:14,560 --> 00:04:18,799
that's in um developers i see my v2 the

00:04:17,040 --> 00:04:20,000
v3 has not yet been released but i'll

00:04:18,799 --> 00:04:22,720
provide provide you with

00:04:20,000 --> 00:04:23,360
a false small snapshot of what has been

00:04:22,720 --> 00:04:25,360
added

00:04:23,360 --> 00:04:26,800
um typically i've just copied this

00:04:25,360 --> 00:04:30,000
diagram from the

00:04:26,800 --> 00:04:32,000
cmi specification and you'll see there

00:04:30,000 --> 00:04:35,040
are two parts that have been

00:04:32,000 --> 00:04:38,080
um highlighted in red

00:04:35,040 --> 00:04:39,520
that is the voltage and that is a new

00:04:38,080 --> 00:04:41,199
protocol that we have added which is the

00:04:39,520 --> 00:04:44,320
voltage domain protocol

00:04:41,199 --> 00:04:47,120
and this was uh this

00:04:44,320 --> 00:04:47,759
is something that would intercept the

00:04:47,120 --> 00:04:50,479
linux

00:04:47,759 --> 00:04:51,120
voltage regulator framework there was a

00:04:50,479 --> 00:04:54,000
lot of

00:04:51,120 --> 00:04:55,199
requirement a lot of a lot of asks from

00:04:54,000 --> 00:04:57,840
different partners

00:04:55,199 --> 00:04:59,919
to enable something because there are

00:04:57,840 --> 00:05:00,720
genuine use cases where you need to

00:04:59,919 --> 00:05:04,479
control

00:05:00,720 --> 00:05:07,520
the voltages of of peripherals like

00:05:04,479 --> 00:05:08,960
sd cards uh maybe your touch panels and

00:05:07,520 --> 00:05:11,120
so on and so forth

00:05:08,960 --> 00:05:14,320
so this is one which that would readily

00:05:11,120 --> 00:05:14,320
take over that role

00:05:14,479 --> 00:05:17,840
the other part that we have added is in

00:05:17,199 --> 00:05:21,039
sensors

00:05:17,840 --> 00:05:24,080
now sensors as an as an protocol

00:05:21,039 --> 00:05:24,880
used to exist right from the version one

00:05:24,080 --> 00:05:27,039
itself

00:05:24,880 --> 00:05:29,360
but here we have extended the protocol

00:05:27,039 --> 00:05:32,720
and this is this has been made mostly

00:05:29,360 --> 00:05:34,639
for automotive use cases where you need

00:05:32,720 --> 00:05:35,840
complicated sensors and multi-axis

00:05:34,639 --> 00:05:37,680
sensor support

00:05:35,840 --> 00:05:39,759
so if you have sensors like

00:05:37,680 --> 00:05:43,039
accelerometers gyroscopes

00:05:39,759 --> 00:05:45,280
um or a inertial measurement unit

00:05:43,039 --> 00:05:47,680
then semi provides you now the

00:05:45,280 --> 00:05:48,880
capability to map these multi-axis

00:05:47,680 --> 00:05:52,240
sensors

00:05:48,880 --> 00:05:55,520
in in a standardized way into the kernel

00:05:52,240 --> 00:05:58,319
it provides you also the capability

00:05:55,520 --> 00:06:00,000
now to instead of requesting a read from

00:05:58,319 --> 00:06:00,960
the sensor every single time you could

00:06:00,000 --> 00:06:03,919
just configure

00:06:00,960 --> 00:06:04,639
a rate at which the firmware notifies

00:06:03,919 --> 00:06:06,800
you

00:06:04,639 --> 00:06:08,240
of sensor readings so you don't have to

00:06:06,800 --> 00:06:09,680
go and manually read the

00:06:08,240 --> 00:06:11,680
sensor every time you can just say

00:06:09,680 --> 00:06:13,840
notify me after

00:06:11,680 --> 00:06:16,240
x milliseconds and you would get that

00:06:13,840 --> 00:06:19,520
rate of response from the firmware

00:06:16,240 --> 00:06:21,680
by an hdmi notification

00:06:19,520 --> 00:06:23,440
and the good thing is that it's it's

00:06:21,680 --> 00:06:24,160
sort of compliant with the industrial

00:06:23,440 --> 00:06:26,639
ios

00:06:24,160 --> 00:06:27,840
framework in linux so you could have an

00:06:26,639 --> 00:06:29,600
industrial i o type

00:06:27,840 --> 00:06:31,199
standardized driver on top as well to

00:06:29,600 --> 00:06:34,240
consume all this data

00:06:31,199 --> 00:06:35,280
um and it's primarily for automotive use

00:06:34,240 --> 00:06:37,440
cases so that

00:06:35,280 --> 00:06:39,039
even if you have got different sensor

00:06:37,440 --> 00:06:41,199
chips or different

00:06:39,039 --> 00:06:43,440
types of sensors on your platform you

00:06:41,199 --> 00:06:44,160
could provide the os with a standardized

00:06:43,440 --> 00:06:46,560
view

00:06:44,160 --> 00:06:48,240
and all the complexity can be hidden

00:06:46,560 --> 00:06:51,120
away into a layer of firmware

00:06:48,240 --> 00:06:51,120
lower down the stack

00:06:51,280 --> 00:06:57,039
then another thing that we added was

00:06:54,319 --> 00:07:00,080
enhanced support for virtualization

00:06:57,039 --> 00:07:03,199
this was something for which we added

00:07:00,080 --> 00:07:03,680
a vertio based transport capability now

00:07:03,199 --> 00:07:06,240
as

00:07:03,680 --> 00:07:07,120
uh as we i mentioned in the earlier

00:07:06,240 --> 00:07:10,160
slide

00:07:07,120 --> 00:07:11,840
stmi does allow you the capability to

00:07:10,160 --> 00:07:14,400
choose a transport of your choice

00:07:11,840 --> 00:07:17,120
so as a result the specification itself

00:07:14,400 --> 00:07:18,400
is very flexible so we made some

00:07:17,120 --> 00:07:20,160
changes in the wording of the

00:07:18,400 --> 00:07:22,319
specification to make sure that

00:07:20,160 --> 00:07:23,599
vertio type transports can be easily

00:07:22,319 --> 00:07:25,919
accommodated

00:07:23,599 --> 00:07:28,160
but in parallel there is a companion

00:07:25,919 --> 00:07:30,240
scmi vertio device specification

00:07:28,160 --> 00:07:31,280
proposal in the os is what i o mailing

00:07:30,240 --> 00:07:33,039
list today

00:07:31,280 --> 00:07:35,199
so you can go and have a look at that if

00:07:33,039 --> 00:07:38,639
you're interested in seeing how that

00:07:35,199 --> 00:07:40,240
hdmi vertio device looks so all the smi

00:07:38,639 --> 00:07:43,520
what io device would be

00:07:40,240 --> 00:07:46,240
is a separate transport layer and the

00:07:43,520 --> 00:07:48,479
upper layers of scmi in the linux kernel

00:07:46,240 --> 00:07:50,160
which does voltage clock reset

00:07:48,479 --> 00:07:52,319
performance power sensors

00:07:50,160 --> 00:07:53,840
management would be standardized so

00:07:52,319 --> 00:07:54,800
there's only a fairly little change

00:07:53,840 --> 00:07:56,400
linux kernel

00:07:54,800 --> 00:07:58,960
and there's a lot of benefit because you

00:07:56,400 --> 00:07:59,919
could then virtualize the entire stack

00:07:58,960 --> 00:08:02,560
and take the

00:07:59,919 --> 00:08:03,280
hdmi server capability into a different

00:08:02,560 --> 00:08:06,080
portion

00:08:03,280 --> 00:08:06,080
of your software

00:08:07,199 --> 00:08:11,199
um i think this is all that i have as

00:08:09,599 --> 00:08:12,240
far as hdmi version 3 updates are

00:08:11,199 --> 00:08:15,360
concerned

00:08:12,240 --> 00:08:18,080
i'll move quickly to the acpi

00:08:15,360 --> 00:08:19,199
questions so there there is now an

00:08:18,080 --> 00:08:22,560
increasing demand

00:08:19,199 --> 00:08:26,400
for having hdmi type deployments in

00:08:22,560 --> 00:08:29,919
systems which use acpi um

00:08:26,400 --> 00:08:31,680
and the the core requirement here

00:08:29,919 --> 00:08:33,519
is that you need to have a unified

00:08:31,680 --> 00:08:35,279
firmware for both acpi and device tree

00:08:33,519 --> 00:08:36,880
based implementations because while the

00:08:35,279 --> 00:08:38,320
kernel is different for device-to-base

00:08:36,880 --> 00:08:40,240
systems and

00:08:38,320 --> 00:08:41,599
acpi based systems you would like to

00:08:40,240 --> 00:08:45,279
reuse your firmware

00:08:41,599 --> 00:08:48,480
and use the same interfaces for both so

00:08:45,279 --> 00:08:50,160
in this in this i there are two parts um

00:08:48,480 --> 00:08:52,320
to these slides in the first slide i'll

00:08:50,160 --> 00:08:53,600
show how processor idle state management

00:08:52,320 --> 00:08:54,000
and processors perform performance state

00:08:53,600 --> 00:08:56,560
management

00:08:54,000 --> 00:08:57,920
can be done in a standardized manner in

00:08:56,560 --> 00:08:59,920
combination with the arm

00:08:57,920 --> 00:09:01,760
fixed functional hardware specification

00:08:59,920 --> 00:09:05,120
and that's a specification you can get

00:09:01,760 --> 00:09:08,320
off developer.com and

00:09:05,120 --> 00:09:09,680
uh the broad guidance over here is that

00:09:08,320 --> 00:09:12,560
in acps systems

00:09:09,680 --> 00:09:12,959
we use the native acpi method as defined

00:09:12,560 --> 00:09:15,920
and as

00:09:12,959 --> 00:09:16,560
already supported in the kernel and scmi

00:09:15,920 --> 00:09:19,120
provides

00:09:16,560 --> 00:09:20,959
just the transport layer for con for

00:09:19,120 --> 00:09:23,600
communicating with your firmware which

00:09:20,959 --> 00:09:25,360
understands a cmi so for processor idle

00:09:23,600 --> 00:09:27,440
states we use the

00:09:25,360 --> 00:09:29,600
underscore lpi method which is a

00:09:27,440 --> 00:09:32,959
standardized method in lpi

00:09:29,600 --> 00:09:33,519
and the ffh which is which is as a part

00:09:32,959 --> 00:09:36,880
of the arm

00:09:33,519 --> 00:09:37,440
ffh specification provides you a way to

00:09:36,880 --> 00:09:39,440
discover

00:09:37,440 --> 00:09:41,839
entry methods power state residency and

00:09:39,440 --> 00:09:43,760
user statistics through psci

00:09:41,839 --> 00:09:44,959
there are examples for it already there

00:09:43,760 --> 00:09:47,519
that you could use

00:09:44,959 --> 00:09:49,040
and the psci agent then can reside

00:09:47,519 --> 00:09:50,880
wherever it does today

00:09:49,040 --> 00:09:52,880
same as dt based implementations and

00:09:50,880 --> 00:09:54,959
that agent can use hdmi

00:09:52,880 --> 00:09:56,080
for changing power domains as it sees

00:09:54,959 --> 00:09:58,000
fit uh

00:09:56,080 --> 00:10:00,240
and this ff8 support is supported in the

00:09:58,000 --> 00:10:02,240
mainline kernel today for low power idle

00:10:00,240 --> 00:10:03,680
and this maps to psci calls so that

00:10:02,240 --> 00:10:06,880
should take care of at least

00:10:03,680 --> 00:10:08,720
the cpu idle parts for you

00:10:06,880 --> 00:10:10,560
um coming to processor performance

00:10:08,720 --> 00:10:12,480
management uh now

00:10:10,560 --> 00:10:14,480
here is what what where you would like

00:10:12,480 --> 00:10:17,040
to use uh cppc

00:10:14,480 --> 00:10:18,000
in acpi terms uh collaborative

00:10:17,040 --> 00:10:20,240
performance processor

00:10:18,000 --> 00:10:22,640
performance control and that uses

00:10:20,240 --> 00:10:24,800
underscore cpc methods in acpi

00:10:22,640 --> 00:10:26,079
which is continuous performance control

00:10:24,800 --> 00:10:29,519
now if you're using

00:10:26,079 --> 00:10:32,079
cpc method um you provide you have to

00:10:29,519 --> 00:10:35,440
provide certain capabilities

00:10:32,079 --> 00:10:37,120
by your asl tables you provide

00:10:35,440 --> 00:10:38,959
performance capabilities and they can be

00:10:37,120 --> 00:10:40,320
encoded as d worse you can just put the

00:10:38,959 --> 00:10:42,240
data in there which is your max

00:10:40,320 --> 00:10:43,839
performance min performance lowest

00:10:42,240 --> 00:10:46,079
nominal performance and so on and so

00:10:43,839 --> 00:10:48,640
forth performance monitoring

00:10:46,079 --> 00:10:50,720
capabilities are exposed using the arm

00:10:48,640 --> 00:10:51,920
activity monitors unit and this is

00:10:50,720 --> 00:10:54,399
enabled to ffh

00:10:51,920 --> 00:10:56,399
so all arm implementations which have an

00:10:54,399 --> 00:10:58,959
arm activity monitors unit

00:10:56,399 --> 00:11:00,640
can use the cpu counters and the

00:10:58,959 --> 00:11:04,240
reference performance counters

00:11:00,640 --> 00:11:06,800
and the ffh tells you how to do that

00:11:04,240 --> 00:11:08,880
performance control is achieved using

00:11:06,800 --> 00:11:11,839
scmi fast channels

00:11:08,880 --> 00:11:13,920
that's a direct map via system memory

00:11:11,839 --> 00:11:14,240
and the performance limited register as

00:11:13,920 --> 00:11:16,880
this

00:11:14,240 --> 00:11:17,839
as the acps specification tells you to

00:11:16,880 --> 00:11:19,920
today is

00:11:17,839 --> 00:11:20,880
points points to an unused zeroed

00:11:19,920 --> 00:11:24,480
location

00:11:20,880 --> 00:11:27,680
uh so the scpi 6.3 air rata version

00:11:24,480 --> 00:11:28,959
will clarify that in case your register

00:11:27,680 --> 00:11:30,000
performs limited register is not

00:11:28,959 --> 00:11:33,839
implemented it's

00:11:30,000 --> 00:11:35,680
fair to return zeros so the status of

00:11:33,839 --> 00:11:38,160
the patches for performance monitoring

00:11:35,680 --> 00:11:39,839
using ffh is work in progress

00:11:38,160 --> 00:11:41,360
as you can see if you use the semi fast

00:11:39,839 --> 00:11:42,000
channels performance controls becomes

00:11:41,360 --> 00:11:43,680
very trivial

00:11:42,000 --> 00:11:45,279
you just need to map the location of the

00:11:43,680 --> 00:11:48,640
fast channel into

00:11:45,279 --> 00:11:51,200
your into your acpi tables and you're

00:11:48,640 --> 00:11:51,200
done for it

00:11:52,639 --> 00:11:57,440
now using sc my compliant firmware and

00:11:54,639 --> 00:11:59,360
acpi systems uh we covered um

00:11:57,440 --> 00:12:00,880
how to do idle how to do performance

00:11:59,360 --> 00:12:03,279
management and then there are

00:12:00,880 --> 00:12:04,079
miscellaneous other use cases um you

00:12:03,279 --> 00:12:06,240
might need to

00:12:04,079 --> 00:12:08,320
access a sensor you might need to do

00:12:06,240 --> 00:12:11,040
other different things as well

00:12:08,320 --> 00:12:11,920
so for that there is a way in which the

00:12:11,040 --> 00:12:14,639
hdmi

00:12:11,920 --> 00:12:15,120
protocol today maps over pcc channel

00:12:14,639 --> 00:12:18,560
type

00:12:15,120 --> 00:12:18,959
three so we recommend that in acpi you

00:12:18,560 --> 00:12:21,519
use

00:12:18,959 --> 00:12:24,000
pcc channel type three for most of the

00:12:21,519 --> 00:12:26,560
other use cases that acpi supports

00:12:24,000 --> 00:12:28,720
and on the right hand side is a diagram

00:12:26,560 --> 00:12:29,279
that shows you how that maps to an scmi

00:12:28,720 --> 00:12:31,760
channel

00:12:29,279 --> 00:12:32,399
so if you see that the pcc channel types

00:12:31,760 --> 00:12:36,000
so

00:12:32,399 --> 00:12:37,600
so pcc channel works via a table

00:12:36,000 --> 00:12:39,920
mechanism over here

00:12:37,600 --> 00:12:40,639
there is a subspace structure and these

00:12:39,920 --> 00:12:43,839
are the

00:12:40,639 --> 00:12:45,360
fields that the acpi specification says

00:12:43,839 --> 00:12:48,480
that must exist

00:12:45,360 --> 00:12:51,519
so in these fields the base address is

00:12:48,480 --> 00:12:52,320
which points to the hdmi shared memory

00:12:51,519 --> 00:12:56,079
location

00:12:52,320 --> 00:12:59,519
and the sdmi channel layout is shown

00:12:56,079 --> 00:13:02,079
at the rightmost section where

00:12:59,519 --> 00:13:03,760
you have a signature your mailbox flags

00:13:02,079 --> 00:13:04,560
length message header and the message

00:13:03,760 --> 00:13:07,600
payload

00:13:04,560 --> 00:13:10,959
they all sit within the shared memory

00:13:07,600 --> 00:13:12,160
and then if you look at b that is the

00:13:10,959 --> 00:13:14,720
platform interrupt

00:13:12,160 --> 00:13:15,680
it maps to the platform interrupt in our

00:13:14,720 --> 00:13:17,040
mail box

00:13:15,680 --> 00:13:19,680
in our mailbox platform interrupt

00:13:17,040 --> 00:13:20,480
mechanism in the hdmi specifications

00:13:19,680 --> 00:13:23,279
specifically

00:13:20,480 --> 00:13:25,279
this refers to the mailbox in case of

00:13:23,279 --> 00:13:28,480
shared memory doorbell type usages

00:13:25,279 --> 00:13:30,880
and c is your adorable and then

00:13:28,480 --> 00:13:32,079
channel complete check mask and update

00:13:30,880 --> 00:13:34,800
masks are

00:13:32,079 --> 00:13:35,360
are the simple ways in which you just um

00:13:34,800 --> 00:13:38,160
set

00:13:35,360 --> 00:13:39,360
set and update your channels so any in

00:13:38,160 --> 00:13:42,560
your channel status

00:13:39,360 --> 00:13:46,000
so all of this maps very very directly

00:13:42,560 --> 00:13:48,320
to the scmi

00:13:46,000 --> 00:13:50,079
shared memory mailbox structure as

00:13:48,320 --> 00:13:52,560
defined in the specification

00:13:50,079 --> 00:13:54,560
so if you're using a pcc channel type 3

00:13:52,560 --> 00:13:55,839
for communication you should be able to

00:13:54,560 --> 00:13:57,839
pass messages

00:13:55,839 --> 00:13:59,600
directly using the same channel to an

00:13:57,839 --> 00:14:02,399
semi compliant firmware

00:13:59,600 --> 00:14:02,880
so all that you need to do is use the

00:14:02,399 --> 00:14:06,000
same

00:14:02,880 --> 00:14:09,199
acpi based intrinsics that we use

00:14:06,000 --> 00:14:09,760
in platforms today you don't need to

00:14:09,199 --> 00:14:12,240
change

00:14:09,760 --> 00:14:13,199
a lot in the kernel and still your

00:14:12,240 --> 00:14:16,160
firmware which

00:14:13,199 --> 00:14:17,440
talks scmi should be able to work for

00:14:16,160 --> 00:14:20,720
such a system

00:14:17,440 --> 00:14:23,680
using a native acpi language

00:14:20,720 --> 00:14:24,720
um important part over here is that you

00:14:23,680 --> 00:14:27,519
could even use

00:14:24,720 --> 00:14:28,399
an operation uh support for pc channel

00:14:27,519 --> 00:14:30,720
type three

00:14:28,399 --> 00:14:31,680
and now the operation support is

00:14:30,720 --> 00:14:34,160
something that

00:14:31,680 --> 00:14:35,680
for pc channel type 3 i i'm not very

00:14:34,160 --> 00:14:36,320
sure whether the kernel supports it

00:14:35,680 --> 00:14:38,720
today

00:14:36,320 --> 00:14:40,959
uh we'll have to have a look but it's

00:14:38,720 --> 00:14:41,760
it's possible nonetheless to just use a

00:14:40,959 --> 00:14:44,079
basic channel

00:14:41,760 --> 00:14:45,519
pcc channel to type 3 communication and

00:14:44,079 --> 00:14:48,639
communicate with an hdmi

00:14:45,519 --> 00:14:50,720
compliant firmware on the other side and

00:14:48,639 --> 00:14:53,760
this is for all other use cases which

00:14:50,720 --> 00:14:55,040
you which is not cppc or which is which

00:14:53,760 --> 00:14:59,519
is not performance

00:14:55,040 --> 00:15:02,240
or which is not cpu idle

00:14:59,519 --> 00:15:04,240
and finally uh so that that takes care

00:15:02,240 --> 00:15:08,000
of your acp ibe systems

00:15:04,240 --> 00:15:10,639
um and then finally you have

00:15:08,000 --> 00:15:12,480
the virtualization story and this is

00:15:10,639 --> 00:15:13,279
mind you this is again one of the modes

00:15:12,480 --> 00:15:15,440
of deployment

00:15:13,279 --> 00:15:17,120
this is not the only mode of deployment

00:15:15,440 --> 00:15:19,839
though there are various other modes of

00:15:17,120 --> 00:15:21,519
deployment that you could do

00:15:19,839 --> 00:15:22,880
one of the modes of deployment is an

00:15:21,519 --> 00:15:25,519
hdmi server

00:15:22,880 --> 00:15:27,040
which runs in a virtual machine so if

00:15:25,519 --> 00:15:29,759
you look at the diagram

00:15:27,040 --> 00:15:30,880
you have a vm1 which is a standard

00:15:29,759 --> 00:15:32,800
virtual machine

00:15:30,880 --> 00:15:34,639
that has an operating system and let's

00:15:32,800 --> 00:15:37,279
suppose you have a device

00:15:34,639 --> 00:15:39,120
that's assigned to this particular vm

00:15:37,279 --> 00:15:40,480
and for the device the power control

00:15:39,120 --> 00:15:42,800
paths are shown below

00:15:40,480 --> 00:15:45,120
so you have cpu flex support your reset

00:15:42,800 --> 00:15:47,199
framework support gen pd support

00:15:45,120 --> 00:15:49,120
hardware on support clock framework and

00:15:47,199 --> 00:15:51,680
regulator framework supports right

00:15:49,120 --> 00:15:52,720
and the blue parts are the linux

00:15:51,680 --> 00:15:55,440
specific

00:15:52,720 --> 00:15:55,920
frameworks and the orange parts below

00:15:55,440 --> 00:15:59,120
are the

00:15:55,920 --> 00:16:00,399
scmi protocols that map to those parts

00:15:59,120 --> 00:16:03,600
of the framework

00:16:00,399 --> 00:16:04,800
and then they all talk via the smi

00:16:03,600 --> 00:16:08,079
transport

00:16:04,800 --> 00:16:11,360
which can be hvc smc as i mentioned

00:16:08,079 --> 00:16:13,040
earlier there is a vertio hdmi transport

00:16:11,360 --> 00:16:15,360
that has been proposed

00:16:13,040 --> 00:16:16,560
so you could talk over hdmi vert io as

00:16:15,360 --> 00:16:19,199
well and that

00:16:16,560 --> 00:16:20,959
would take you to an smi server that

00:16:19,199 --> 00:16:24,079
runs in a virtual machine

00:16:20,959 --> 00:16:25,680
and the virtual machine again the blocks

00:16:24,079 --> 00:16:28,160
over the virtual machine that i've shown

00:16:25,680 --> 00:16:29,199
over here the blocks of the smi server

00:16:28,160 --> 00:16:31,440
are blocks per se

00:16:29,199 --> 00:16:32,240
it is not necessarily that this is how

00:16:31,440 --> 00:16:35,519
your

00:16:32,240 --> 00:16:38,160
server looks but the overall idea is

00:16:35,519 --> 00:16:40,959
that for all your performance requests

00:16:38,160 --> 00:16:42,480
for all your peripheral reset requests

00:16:40,959 --> 00:16:43,680
for all your power domain control

00:16:42,480 --> 00:16:46,880
requests

00:16:43,680 --> 00:16:48,560
um for your clock requests and for

00:16:46,880 --> 00:16:51,680
voltage domain requests

00:16:48,560 --> 00:16:53,040
you can go over is scmi and again if

00:16:51,680 --> 00:16:55,920
you've got hardware mon

00:16:53,040 --> 00:16:57,680
or iio type sensors you could again have

00:16:55,920 --> 00:16:59,680
your sensor device that sits on the

00:16:57,680 --> 00:17:01,920
standard hdmi sensor protocol and still

00:16:59,680 --> 00:17:04,799
use the same vertical transport layer

00:17:01,920 --> 00:17:06,160
to go to a server that exists in a

00:17:04,799 --> 00:17:08,959
controlled vm

00:17:06,160 --> 00:17:10,160
somewhere in your system and as i said

00:17:08,959 --> 00:17:12,160
this is

00:17:10,160 --> 00:17:14,640
one of the applications and then you

00:17:12,160 --> 00:17:18,000
could have the control vm

00:17:14,640 --> 00:17:19,439
talk via dedicated mailbox channel to a

00:17:18,000 --> 00:17:21,760
power microcontroller

00:17:19,439 --> 00:17:23,520
power core processor and then your

00:17:21,760 --> 00:17:26,000
secure world might also be able to do

00:17:23,520 --> 00:17:28,400
the same via secure channel

00:17:26,000 --> 00:17:29,919
and there are so this is a this is one

00:17:28,400 --> 00:17:31,760
of the solutions

00:17:29,919 --> 00:17:33,039
there are various other solutions where

00:17:31,760 --> 00:17:35,039
you could actually

00:17:33,039 --> 00:17:37,360
have each of these virtual machines talk

00:17:35,039 --> 00:17:39,440
directly to the system power controller

00:17:37,360 --> 00:17:40,720
but then there are security security

00:17:39,440 --> 00:17:43,280
implications there

00:17:40,720 --> 00:17:44,960
the cmi protocol provides you commands

00:17:43,280 --> 00:17:46,000
to set up your environment in such

00:17:44,960 --> 00:17:48,240
scenarios

00:17:46,000 --> 00:17:49,840
but this is important but we wanted to

00:17:48,240 --> 00:17:52,320
show this part because

00:17:49,840 --> 00:17:54,240
this one is something that requires some

00:17:52,320 --> 00:17:56,000
minimal hypervisor change

00:17:54,240 --> 00:17:58,320
and you would be able to use your

00:17:56,000 --> 00:18:00,559
standard power control path as is so you

00:17:58,320 --> 00:18:01,919
if you're using a device and the device

00:18:00,559 --> 00:18:04,640
in a bare metal system

00:18:01,919 --> 00:18:05,679
uses certain apis or certain certain

00:18:04,640 --> 00:18:08,240
power control

00:18:05,679 --> 00:18:09,440
framework uh aspects you do not have to

00:18:08,240 --> 00:18:11,360
modify them

00:18:09,440 --> 00:18:13,360
you can use them straight off the bat as

00:18:11,360 --> 00:18:14,160
they exist so you can really run that

00:18:13,360 --> 00:18:15,679
off the pad

00:18:14,160 --> 00:18:18,320
the moment you change your semi

00:18:15,679 --> 00:18:20,400
transport to what i o everything else

00:18:18,320 --> 00:18:22,640
looks the same for the virtual machine

00:18:20,400 --> 00:18:25,679
in question

00:18:22,640 --> 00:18:28,320
um and

00:18:25,679 --> 00:18:29,120
i think i have with this i would come at

00:18:28,320 --> 00:18:31,360
to the end

00:18:29,120 --> 00:18:33,200
of my presentation i try to keep it as

00:18:31,360 --> 00:18:35,679
short as short as possible

00:18:33,200 --> 00:18:37,919
uh there are a few useful links over

00:18:35,679 --> 00:18:40,840
here to the semi specification

00:18:37,919 --> 00:18:43,440
to the arm ffa specification to the sap

00:18:40,840 --> 00:18:45,760
firmware and if you want the water ios

00:18:43,440 --> 00:18:46,400
cmi device links there are some links to

00:18:45,760 --> 00:18:49,679
the

00:18:46,400 --> 00:18:51,679
um mailing list into which the smi what

00:18:49,679 --> 00:18:52,559
io device specification has been

00:18:51,679 --> 00:18:55,280
proposed

00:18:52,559 --> 00:18:57,520
and then obviously according the smi

00:18:55,280 --> 00:19:01,039
device id allocation palette as well

00:18:57,520 --> 00:19:04,080
that's there so at this point in time

00:19:01,039 --> 00:19:05,760
i like to end my presentation and we'll

00:19:04,080 --> 00:19:11,840
check if there are any questions for the

00:19:05,760 --> 00:19:11,840
last five minutes

00:19:22,840 --> 00:19:25,840
like

00:19:28,320 --> 00:19:32,640
okay so there's a question for the date

00:19:30,400 --> 00:19:35,840
for semi v3 being published

00:19:32,640 --> 00:19:39,200
so we are trying to get the beta out by

00:19:35,840 --> 00:19:40,799
the end of the month so you won't be

00:19:39,200 --> 00:19:42,480
able to search for the beta

00:19:40,799 --> 00:19:43,919
but it will be a publicly available

00:19:42,480 --> 00:19:46,400
specifications

00:19:43,919 --> 00:19:48,480
um so jonathan if you do require a link

00:19:46,400 --> 00:19:50,640
to the beta

00:19:48,480 --> 00:19:52,320
i i should be able to send you one if

00:19:50,640 --> 00:19:54,400
you drop me an email that shouldn't be

00:19:52,320 --> 00:19:57,440
an issue it will be a public beta

00:19:54,400 --> 00:20:00,320
and there will be i think rfc patches

00:19:57,440 --> 00:20:03,520
posted in the kernel against that

00:20:00,320 --> 00:20:05,440
uh then from the beta onwards to an

00:20:03,520 --> 00:20:07,600
actual

00:20:05,440 --> 00:20:08,559
final release it'll take another couple

00:20:07,600 --> 00:20:11,360
of months

00:20:08,559 --> 00:20:12,720
so in the worst case you're looking at

00:20:11,360 --> 00:20:15,799
an hdmi v3

00:20:12,720 --> 00:20:18,799
final version release by the end of the

00:20:15,799 --> 00:20:18,799

YouTube URL: https://www.youtube.com/watch?v=hrUDSjDjprE


