Title: LVC20 110 Skin temperature management with hierarchical constraints
Publication date: 2020-10-09
Playlist: Linaro Virtual Connect 2020
Description: 
	Due to the increasing complexity of SoCs, we're now seeing lots of thermal sensors on the die to quickly detect hot spots and allow the OS to take steps to mitigate these events. The Linux thermal framework provides mechanisms such as inputs for better scheduling, frequency throttling, idle injection and turning on fans to prevent the silicon from getting damaged from overheating. This is also called as junction temperature management.

The Linux thermal framework is also used for managing the skin temperature of a device - the temperature that users feel when they hold and use the device. However, this skin temperature management involves manual characterization of performance states for devices such as CPU and GPU to its effect on the skin temperature of the device.

So the framework is doing two distinct tasks: preventing silicon damage and preventing skin burns for users by capping the power of a device. We feel these tasks should be handled by different frameworks.

We're currently experimenting with the kernel's energy model to dynamically build a hierarchy of power constraints and allow the platform integrator to set limits for each power domain using the powercap framework. This will allow the kernel to manage the power consumption (and hence dissipation) budget of the various devices on the Soc more autonomously, leading to better performance at a given power budget instead of overcoming the primary goal of the thermal framework which is mitigate at the limits.

Attendees are expected to know a little bit about how the current thermal framework works but don't need to know all the technical details. We will cover the conceptual differences between the current and proposed models as an introduction in the talk
Captions: 
	00:00:01,680 --> 00:00:05,359
so my name is daniel escano i'm working

00:00:04,160 --> 00:00:08,400
for the

00:00:05,359 --> 00:00:12,719
kennel working group linaro um

00:00:08,400 --> 00:00:12,719
so this presentation is to

00:00:12,960 --> 00:00:20,560
to introduce a proposal to try to

00:00:16,960 --> 00:00:24,640
to comply with the skin temperature

00:00:20,560 --> 00:00:27,199
so before going in the details of the

00:00:24,640 --> 00:00:28,080
of the proposal i have to define some

00:00:27,199 --> 00:00:30,000
terms

00:00:28,080 --> 00:00:32,000
and explain what are the goal of the

00:00:30,000 --> 00:00:34,160
different um

00:00:32,000 --> 00:00:35,280
of the different frameworks and then i

00:00:34,160 --> 00:00:37,600
will give a

00:00:35,280 --> 00:00:38,640
brief description of the tamar framework

00:00:37,600 --> 00:00:42,079
and show that

00:00:38,640 --> 00:00:44,879
what kind of real usage we have today

00:00:42,079 --> 00:00:46,960
what are the limitations and what are

00:00:44,879 --> 00:00:50,800
what is supposed to solve the proposal

00:00:46,960 --> 00:00:53,360
and then um i will end up by some um

00:00:50,800 --> 00:00:55,920
something open to more to more work

00:00:53,360 --> 00:01:00,079
using this pro person

00:00:55,920 --> 00:01:01,359
so we can see today that so that this

00:01:00,079 --> 00:01:04,799
figure is to show

00:01:01,359 --> 00:01:08,080
what happens with the temperature uh on

00:01:04,799 --> 00:01:11,520
on some stock especially here we have a

00:01:08,080 --> 00:01:13,119
cpu so please consider that so it's for

00:01:11,520 --> 00:01:15,759
evaluation board so that's not

00:01:13,119 --> 00:01:16,240
um depending on the form factor the br

00:01:15,759 --> 00:01:18,880
might be

00:01:16,240 --> 00:01:20,799
very different but here we can see that

00:01:18,880 --> 00:01:22,479
we have a two generation between two

00:01:20,799 --> 00:01:23,280
socks the first one is the ikea the

00:01:22,479 --> 00:01:28,320
second one is

00:01:23,280 --> 00:01:29,680
960 and we see for the ikea 960 which is

00:01:28,320 --> 00:01:33,600
the green figure

00:01:29,680 --> 00:01:38,000
uh we have um um

00:01:33,600 --> 00:01:41,200
we we start a very

00:01:38,000 --> 00:01:42,320
compute empty sieve task and we can see

00:01:41,200 --> 00:01:45,600
that temperature

00:01:42,320 --> 00:01:46,479
is raising immediately because the

00:01:45,600 --> 00:01:48,880
frequency

00:01:46,479 --> 00:01:49,759
where the the hardware is able to to

00:01:48,880 --> 00:01:52,880
reach is

00:01:49,759 --> 00:01:56,399
are very high and then we have this

00:01:52,880 --> 00:02:00,159
saw teeth aspect of the the figure

00:01:56,399 --> 00:02:03,439
and this is when the system is

00:02:00,159 --> 00:02:04,719
considering the is detecting the the the

00:02:03,439 --> 00:02:07,119
temperature is too hot

00:02:04,719 --> 00:02:09,200
and then we begin to change the

00:02:07,119 --> 00:02:12,000
performance state of the cpu

00:02:09,200 --> 00:02:12,560
and we see that then the temperature

00:02:12,000 --> 00:02:14,879
drops

00:02:12,560 --> 00:02:15,840
and then it's as the temperature goes

00:02:14,879 --> 00:02:18,879
below

00:02:15,840 --> 00:02:20,319
the the swizzle then the temperature

00:02:18,879 --> 00:02:23,920
increase again and so on

00:02:20,319 --> 00:02:27,440
so we have this pseudo soon so

00:02:23,920 --> 00:02:29,920
tooth aspect of this figure so that's

00:02:27,440 --> 00:02:30,879
the the the purpose of showing this

00:02:29,920 --> 00:02:34,239
figure is showing that

00:02:30,879 --> 00:02:38,560
all the heating effect on on

00:02:34,239 --> 00:02:38,560
on the salt can be very very fast

00:02:40,000 --> 00:02:43,519
so we have in the terminology we have

00:02:42,879 --> 00:02:46,160
one term

00:02:43,519 --> 00:02:47,440
the term is the junction temperature so

00:02:46,160 --> 00:02:50,319
we have to understand that

00:02:47,440 --> 00:02:51,920
this junction temperature is to protect

00:02:50,319 --> 00:02:55,920
the silicone so we define

00:02:51,920 --> 00:02:58,319
a temperature so we have different uh

00:02:55,920 --> 00:02:59,840
layer of protection for the thermal we

00:02:58,319 --> 00:03:01,519
have the kernel side

00:02:59,840 --> 00:03:02,959
then we have the firmware side then we

00:03:01,519 --> 00:03:05,599
have the outer side

00:03:02,959 --> 00:03:07,280
and we prevent of course when we are

00:03:05,599 --> 00:03:08,720
reaching the firmware or when we are

00:03:07,280 --> 00:03:11,599
reaching the hardware

00:03:08,720 --> 00:03:13,440
usually the the critical is just shut

00:03:11,599 --> 00:03:13,760
down the system and we don't want to do

00:03:13,440 --> 00:03:16,720
that

00:03:13,760 --> 00:03:17,280
for the system because that we can lose

00:03:16,720 --> 00:03:20,480
um

00:03:17,280 --> 00:03:22,800
we can lose information we can

00:03:20,480 --> 00:03:23,840
break the system for any reason so it's

00:03:22,800 --> 00:03:27,280
bad things to

00:03:23,840 --> 00:03:28,720
cut the immediately the shut down the

00:03:27,280 --> 00:03:32,239
system

00:03:28,720 --> 00:03:33,360
so we try to under that first from the

00:03:32,239 --> 00:03:37,360
kind of side

00:03:33,360 --> 00:03:38,480
and from from that then we have this

00:03:37,360 --> 00:03:41,599
result temperature

00:03:38,480 --> 00:03:43,120
and the mitigation happens

00:03:41,599 --> 00:03:45,120
then we have the skin temperature the

00:03:43,120 --> 00:03:48,879
skin temperature is

00:03:45,120 --> 00:03:51,920
the resulting temperature

00:03:48,879 --> 00:03:53,519
on a specific place where it's

00:03:51,920 --> 00:03:55,680
it's a place where it's supposed to be

00:03:53,519 --> 00:03:58,959
in contact with your skin

00:03:55,680 --> 00:04:01,840
so if the the temperature is

00:03:58,959 --> 00:04:03,439
must the this temperature must not go

00:04:01,840 --> 00:04:06,560
beyond the 45 degree

00:04:03,439 --> 00:04:10,400
more or less because um

00:04:06,560 --> 00:04:13,760
if you have something

00:04:10,400 --> 00:04:17,440
close to your well on your skin

00:04:13,760 --> 00:04:20,400
with a temperature of beyond 50 degree

00:04:17,440 --> 00:04:21,359
more than 30 minutes it results in a

00:04:20,400 --> 00:04:25,680
first degree

00:04:21,359 --> 00:04:28,400
burn so for this reason

00:04:25,680 --> 00:04:29,440
we have there is a form factor and there

00:04:28,400 --> 00:04:32,800
is a

00:04:29,440 --> 00:04:36,080
uh a dissipation uh

00:04:32,800 --> 00:04:38,639
there is the the hardware is allowing to

00:04:36,080 --> 00:04:39,280
dissipate the temperature on the on the

00:04:38,639 --> 00:04:43,040
stock

00:04:39,280 --> 00:04:45,600
and that allows to have this

00:04:43,040 --> 00:04:47,919
skin temperature even if we have more

00:04:45,600 --> 00:04:53,280
eating source on the on the phone

00:04:47,919 --> 00:04:53,280
uh which are much much higher than 45

00:04:54,400 --> 00:04:58,720
so do we just skipped the terminal the

00:04:56,800 --> 00:05:02,000
tamil design power because it doesn't it

00:04:58,720 --> 00:05:02,000
does not have interest here

00:05:02,800 --> 00:05:08,160
so of course the success during the last

00:05:06,479 --> 00:05:11,520
years the

00:05:08,160 --> 00:05:12,479
the sock increase a lot in terms of

00:05:11,520 --> 00:05:14,320
density

00:05:12,479 --> 00:05:15,680
on the component with the component we

00:05:14,320 --> 00:05:17,280
have the on the board

00:05:15,680 --> 00:05:19,440
we have more and more component the

00:05:17,280 --> 00:05:20,080
intensity is increasing of this

00:05:19,440 --> 00:05:23,360
component

00:05:20,080 --> 00:05:24,080
and of and and of course the the source

00:05:23,360 --> 00:05:27,360
of heat

00:05:24,080 --> 00:05:30,320
are also increasing and we can find now

00:05:27,360 --> 00:05:31,199
npu we can find a lot of cpus they are

00:05:30,320 --> 00:05:34,160
going

00:05:31,199 --> 00:05:35,440
uh faster and faster the memory also is

00:05:34,160 --> 00:05:38,639
going very fast

00:05:35,440 --> 00:05:41,120
so this these are all sorts of um

00:05:38,639 --> 00:05:42,000
of of heat and of course we cannot have

00:05:41,120 --> 00:05:44,479
we cannot have

00:05:42,000 --> 00:05:46,080
all of them working at the full

00:05:44,479 --> 00:05:48,160
performance states

00:05:46,080 --> 00:05:49,120
at the same time and we have we need to

00:05:48,160 --> 00:05:51,039
have something

00:05:49,120 --> 00:05:53,039
to prevent that to mitigate to have

00:05:51,039 --> 00:05:56,400
acknowledged or how it behaved with the

00:05:53,039 --> 00:05:58,400
the the platform and to say okay

00:05:56,400 --> 00:06:00,639
now i know that this kind of profile

00:05:58,400 --> 00:06:02,240
will be using more this device than this

00:06:00,639 --> 00:06:04,479
device i will decrease the performance

00:06:02,240 --> 00:06:06,639
of this device instead of this device

00:06:04,479 --> 00:06:07,840
and so on and with that we ensure that

00:06:06,639 --> 00:06:10,240
we are still

00:06:07,840 --> 00:06:11,440
inside the poor consumption which is

00:06:10,240 --> 00:06:15,759
which

00:06:11,440 --> 00:06:19,440
won't um increase the temperature

00:06:15,759 --> 00:06:20,319
um of the increase the temperature

00:06:19,440 --> 00:06:25,600
reaching uh

00:06:20,319 --> 00:06:25,600
going up be beyond this skin temperature

00:06:26,400 --> 00:06:29,919
so we end up with some challenging use

00:06:28,720 --> 00:06:32,960
cases

00:06:29,919 --> 00:06:36,000
for example when you use virtual reality

00:06:32,960 --> 00:06:39,199
uh if you reach the point where

00:06:36,000 --> 00:06:41,680
you don't mitigate well you don't um

00:06:39,199 --> 00:06:42,960
ensure the skin temperature you don't uh

00:06:41,680 --> 00:06:43,600
you don't make sure that you're not

00:06:42,960 --> 00:06:45,680
you're not

00:06:43,600 --> 00:06:48,080
distributing the power the dissipation

00:06:45,680 --> 00:06:48,960
of the power the different devices by

00:06:48,080 --> 00:06:51,120
capping

00:06:48,960 --> 00:06:52,080
the performance of some devices instead

00:06:51,120 --> 00:06:54,639
of order

00:06:52,080 --> 00:06:56,080
you have you can reach a point one for

00:06:54,639 --> 00:06:58,080
where for example

00:06:56,080 --> 00:06:59,680
it is the thermal framework which is

00:06:58,080 --> 00:07:02,960
taking control

00:06:59,680 --> 00:07:04,400
of the mitigation and it is not taking

00:07:02,960 --> 00:07:06,560
care of the user experience

00:07:04,400 --> 00:07:08,960
it's just saving trying to save the the

00:07:06,560 --> 00:07:12,880
silicone so you will cap the

00:07:08,960 --> 00:07:17,440
the performances a lot it can result

00:07:12,880 --> 00:07:20,400
in frame dropping and if you have using

00:07:17,440 --> 00:07:22,240
virtual reality glasses then you can

00:07:20,400 --> 00:07:24,639
feel dizziness

00:07:22,240 --> 00:07:25,440
uh for example for the for the gaming

00:07:24,639 --> 00:07:27,840
for gaming

00:07:25,440 --> 00:07:29,599
you might have the cpu because um the

00:07:27,840 --> 00:07:32,800
cpu is uh

00:07:29,599 --> 00:07:34,479
the cpu opp is

00:07:32,800 --> 00:07:36,400
set by the scheduler and the scheduler

00:07:34,479 --> 00:07:39,919
is detecting you are

00:07:36,400 --> 00:07:41,280
below above a certain threshold then you

00:07:39,919 --> 00:07:43,520
will increase the opp

00:07:41,280 --> 00:07:44,960
but actually you don't need to have this

00:07:43,520 --> 00:07:47,759
opp

00:07:44,960 --> 00:07:49,440
because you can meet the deadline to do

00:07:47,759 --> 00:07:53,039
for the computation

00:07:49,440 --> 00:07:55,120
and by not uh but using this

00:07:53,039 --> 00:07:57,440
this obp actually you reach high

00:07:55,120 --> 00:07:59,919
temperature and you propagate also

00:07:57,440 --> 00:08:00,960
the temperature the heat to the to the

00:07:59,919 --> 00:08:03,840
gpu

00:08:00,960 --> 00:08:06,400
and can result also in the mitigation

00:08:03,840 --> 00:08:06,400
for nothing

00:08:06,639 --> 00:08:09,840
so we have yeah we have different

00:08:08,560 --> 00:08:11,919
examples here where

00:08:09,840 --> 00:08:13,759
where you you can you if you don't

00:08:11,919 --> 00:08:15,280
manage correctly

00:08:13,759 --> 00:08:17,039
the performances of the different

00:08:15,280 --> 00:08:19,599
devices you end up but

00:08:17,039 --> 00:08:20,400
by by having mitigation and mitigation

00:08:19,599 --> 00:08:22,560
means

00:08:20,400 --> 00:08:24,639
performance drop a lot i will show that

00:08:22,560 --> 00:08:28,720
right after

00:08:24,639 --> 00:08:32,080
so this is the a quick overview

00:08:28,720 --> 00:08:35,039
of the of the terminal framework so

00:08:32,080 --> 00:08:35,839
actually it's not very the figure i

00:08:35,039 --> 00:08:38,080
should have put

00:08:35,839 --> 00:08:39,680
the terminals on figure at the center

00:08:38,080 --> 00:08:42,800
the timer zone

00:08:39,680 --> 00:08:43,680
is the software component which is

00:08:42,800 --> 00:08:46,480
aggregating

00:08:43,680 --> 00:08:48,959
the governor the sensor and the cooling

00:08:46,480 --> 00:08:48,959
devices

00:08:49,200 --> 00:08:54,560
the tamazon are always

00:08:52,560 --> 00:08:56,560
basically i don't want to talk about uh

00:08:54,560 --> 00:08:58,080
some specific cases where we have a

00:08:56,560 --> 00:09:01,440
tooth amazon uh

00:08:58,080 --> 00:09:03,680
covered by one single cooling device

00:09:01,440 --> 00:09:05,519
but usually what we have is a one-to-one

00:09:03,680 --> 00:09:08,640
relationship

00:09:05,519 --> 00:09:09,440
so when you have a sensor temperature

00:09:08,640 --> 00:09:13,519
sensor

00:09:09,440 --> 00:09:15,760
you you can have up to 20 25 sensors on

00:09:13,519 --> 00:09:18,800
the on the stock

00:09:15,760 --> 00:09:21,360
each sensor is

00:09:18,800 --> 00:09:23,440
represented by your timer zone time

00:09:21,360 --> 00:09:26,880
amazon contains a set

00:09:23,440 --> 00:09:30,000
of temperatures result and when

00:09:26,880 --> 00:09:32,399
the temperature is going above this

00:09:30,000 --> 00:09:33,279
this result then the governor takes

00:09:32,399 --> 00:09:36,240
place

00:09:33,279 --> 00:09:37,200
and choose an action to do increase the

00:09:36,240 --> 00:09:39,360
the cooling effect

00:09:37,200 --> 00:09:41,120
so it will act on the cooling device

00:09:39,360 --> 00:09:43,680
asking for more cooling effect

00:09:41,120 --> 00:09:44,560
or is it will detect that the the time

00:09:43,680 --> 00:09:46,160
the the

00:09:44,560 --> 00:09:49,360
the temperature is decreasing the trend

00:09:46,160 --> 00:09:49,360
is decreasing then you will ask

00:09:49,519 --> 00:09:53,600
the cooling device to reduce the cooling

00:09:51,279 --> 00:09:53,600
effect

00:09:53,920 --> 00:09:57,360
there is no communication between the

00:09:55,760 --> 00:09:58,720
different thermal zone there is no

00:09:57,360 --> 00:09:59,519
communication between the different

00:09:58,720 --> 00:10:01,279
governors

00:09:59,519 --> 00:10:03,120
they are they are not communication

00:10:01,279 --> 00:10:06,160
between the different cooling devices

00:10:03,120 --> 00:10:07,680
they are not aware what's happening on

00:10:06,160 --> 00:10:10,880
the different places

00:10:07,680 --> 00:10:14,720
that means if you have one device eating

00:10:10,880 --> 00:10:18,000
a lot close to another sensor

00:10:14,720 --> 00:10:19,040
and even if the device of the of the

00:10:18,000 --> 00:10:22,160
second sensor

00:10:19,040 --> 00:10:25,040
is not in use then

00:10:22,160 --> 00:10:26,560
the heat propagated by the first device

00:10:25,040 --> 00:10:29,680
will

00:10:26,560 --> 00:10:32,240
can can pro um

00:10:29,680 --> 00:10:33,440
can trigger mitigation on the on the

00:10:32,240 --> 00:10:36,079
second one

00:10:33,440 --> 00:10:36,640
so there is no communication at all

00:10:36,079 --> 00:10:39,040
that's

00:10:36,640 --> 00:10:40,880
that's the reason why we need something

00:10:39,040 --> 00:10:42,560
smarter

00:10:40,880 --> 00:10:44,240
then for the cooling device we have two

00:10:42,560 --> 00:10:45,680
categories of cooling devices we have

00:10:44,240 --> 00:10:49,440
the active cooling device

00:10:45,680 --> 00:10:51,839
so these are cooling devices which need

00:10:49,440 --> 00:10:53,279
energy to cool down like a fan for

00:10:51,839 --> 00:10:56,240
example

00:10:53,279 --> 00:10:57,680
and you have the passing quality devices

00:10:56,240 --> 00:11:00,320
where the

00:10:57,680 --> 00:11:00,800
we reduce the power consumption so we

00:11:00,320 --> 00:11:04,240
reduce

00:11:00,800 --> 00:11:06,720
we we don't need energy to cool down

00:11:04,240 --> 00:11:08,880
and for that we have the gpu using death

00:11:06,720 --> 00:11:12,079
rack and cp and cpu using

00:11:08,880 --> 00:11:14,399
cpu freq so we reduce the opp when we

00:11:12,079 --> 00:11:16,560
are we have a 2i opp

00:11:14,399 --> 00:11:18,320
we reduced opp and then we have a

00:11:16,560 --> 00:11:20,720
specific case also for a cpu

00:11:18,320 --> 00:11:21,600
in case the cpu frequency cannot work or

00:11:20,720 --> 00:11:25,440
did or

00:11:21,600 --> 00:11:29,120
if the cpu is not the vfs avail

00:11:25,440 --> 00:11:32,240
capable then we can mitigate also with

00:11:29,120 --> 00:11:32,560
the idle injection by forcing the cpu to

00:11:32,240 --> 00:11:35,600
do

00:11:32,560 --> 00:11:38,560
nothing during some amount of time

00:11:35,600 --> 00:11:43,440
and that allows to the cpu to cool down

00:11:38,560 --> 00:11:47,279
during this moment

00:11:43,440 --> 00:11:47,839
so here we have um a figure the first

00:11:47,279 --> 00:11:50,959
figure

00:11:47,839 --> 00:11:53,680
on the top is showing the temperature

00:11:50,959 --> 00:11:54,160
um and the duration of the run so we run

00:11:53,680 --> 00:11:57,279
a com

00:11:54,160 --> 00:11:57,839
the same compute intensive task we had

00:11:57,279 --> 00:12:01,440
uh

00:11:57,839 --> 00:12:02,160
previously and the governor for the cpu

00:12:01,440 --> 00:12:05,440
freq

00:12:02,160 --> 00:12:09,519
is user space that means we set the opp

00:12:05,440 --> 00:12:13,200
we change manually wp we do a run

00:12:09,519 --> 00:12:16,560
and we set at the lowest rpp then

00:12:13,200 --> 00:12:19,680
when it finishes we set the second rpp

00:12:16,560 --> 00:12:20,320
we run again etc until we reach the last

00:12:19,680 --> 00:12:22,240
one

00:12:20,320 --> 00:12:23,440
and we can see that the first one is

00:12:22,240 --> 00:12:25,200
taking a long time

00:12:23,440 --> 00:12:26,880
but the temperature the temperature is

00:12:25,200 --> 00:12:30,240
not increasing a lot

00:12:26,880 --> 00:12:32,880
while the the more we are increasing the

00:12:30,240 --> 00:12:34,880
the the frequency the more the

00:12:32,880 --> 00:12:38,880
temperature is increasing

00:12:34,880 --> 00:12:41,360
and also the faster

00:12:38,880 --> 00:12:43,839
is the duration of the of the

00:12:41,360 --> 00:12:46,000
computation

00:12:43,839 --> 00:12:47,839
but when we reach the last one the

00:12:46,000 --> 00:12:50,959
highest pp

00:12:47,839 --> 00:12:54,720
we can see that the the

00:12:50,959 --> 00:12:58,720
duration of the run is

00:12:54,720 --> 00:13:01,760
as long as the lowest opp

00:12:58,720 --> 00:13:05,920
why because the system

00:13:01,760 --> 00:13:06,560
the cpu in this case is eating so much

00:13:05,920 --> 00:13:10,079
that

00:13:06,560 --> 00:13:13,279
it triggers a lot of transition to

00:13:10,079 --> 00:13:13,839
to reduce the power and in the figure

00:13:13,279 --> 00:13:17,279
below

00:13:13,839 --> 00:13:19,120
what we can see these are the transition

00:13:17,279 --> 00:13:20,399
so we see that the cooling state so that

00:13:19,120 --> 00:13:23,600
means we reach

00:13:20,399 --> 00:13:26,240
for the at the end we we are

00:13:23,600 --> 00:13:27,040
doing so many transition that we don't

00:13:26,240 --> 00:13:31,279
see

00:13:27,040 --> 00:13:34,560
the the the the lines we see just a

00:13:31,279 --> 00:13:37,760
red um a green square there

00:13:34,560 --> 00:13:40,560
a green rectangle

00:13:37,760 --> 00:13:41,600
and the cooling state means we are

00:13:40,560 --> 00:13:45,519
between

00:13:41,600 --> 00:13:48,800
two or three opp below the driest

00:13:45,519 --> 00:13:50,079
so here we are we drop a lot of

00:13:48,800 --> 00:13:52,079
performances

00:13:50,079 --> 00:13:53,360
we are very high in frequency for

00:13:52,079 --> 00:13:55,680
nothing

00:13:53,360 --> 00:13:57,199
and we are dropping losing all the

00:13:55,680 --> 00:14:00,959
performances in this case

00:13:57,199 --> 00:14:04,399
so it would have makes more sense to run

00:14:00,959 --> 00:14:08,079
the the same test the same application

00:14:04,399 --> 00:14:11,120
to opp below and the result

00:14:08,079 --> 00:14:11,120
would have been better

00:14:15,680 --> 00:14:22,560
so in order to

00:14:18,800 --> 00:14:25,600
uh prevent this situation the user space

00:14:22,560 --> 00:14:28,320
tries to reduce

00:14:25,600 --> 00:14:30,959
the the power consumption when the limit

00:14:28,320 --> 00:14:35,120
the power on the on the device

00:14:30,959 --> 00:14:38,160
by using what is exported in csfs

00:14:35,120 --> 00:14:40,480
and what is exporting csfs is the

00:14:38,160 --> 00:14:43,440
cooling state

00:14:40,480 --> 00:14:44,800
the cooling state of the cooling devices

00:14:43,440 --> 00:14:47,600
so there is an abuse

00:14:44,800 --> 00:14:48,880
of the user space which is changing this

00:14:47,600 --> 00:14:52,560
cooling state

00:14:48,880 --> 00:14:55,680
because it is exported and

00:14:52,560 --> 00:14:58,720
regardless any decision from the cannon

00:14:55,680 --> 00:15:01,680
so um

00:14:58,720 --> 00:15:04,240
the we have conflicting here conflicting

00:15:01,680 --> 00:15:04,240
decision

00:15:08,800 --> 00:15:16,560
i will just yeah so the user space

00:15:12,880 --> 00:15:19,040
demand will set

00:15:16,560 --> 00:15:20,320
some oppac state for this um

00:15:19,040 --> 00:15:22,160
[Music]

00:15:20,320 --> 00:15:24,399
for the schooling devices there is no

00:15:22,160 --> 00:15:26,639
knowledge of the power so

00:15:24,399 --> 00:15:28,160
it is actually doing like what is doing

00:15:26,639 --> 00:15:31,040
the thermal framework

00:15:28,160 --> 00:15:31,680
saying okay i know that this temperature

00:15:31,040 --> 00:15:34,160
uh

00:15:31,680 --> 00:15:35,839
is more or less this power then i will

00:15:34,160 --> 00:15:36,880
be waiting for this temp i will read

00:15:35,839 --> 00:15:39,759
this temperature

00:15:36,880 --> 00:15:41,519
and then i will change the the the

00:15:39,759 --> 00:15:42,399
performance state by using the cooling

00:15:41,519 --> 00:15:43,680
device

00:15:42,399 --> 00:15:45,920
and see what happens with the

00:15:43,680 --> 00:15:48,639
temperature

00:15:45,920 --> 00:15:49,199
so there is uh opaque values which which

00:15:48,639 --> 00:15:52,399
are

00:15:49,199 --> 00:15:52,880
the cooling device state and they are

00:15:52,399 --> 00:15:55,120
very

00:15:52,880 --> 00:15:56,560
platform dependent because some cooling

00:15:55,120 --> 00:15:59,440
devices

00:15:56,560 --> 00:15:59,839
um i i saw that some cooling devices are

00:15:59,440 --> 00:16:02,639
have

00:15:59,839 --> 00:16:05,680
up to 1 000 states like brightness

00:16:02,639 --> 00:16:08,800
screen they put that as a cooling device

00:16:05,680 --> 00:16:12,240
so they can act on the on the

00:16:08,800 --> 00:16:12,240
on the power of the devices

00:16:14,079 --> 00:16:21,360
so the proposal is to

00:16:18,240 --> 00:16:24,480
separate clearly by the

00:16:21,360 --> 00:16:25,839
by goal what is supposed to do the

00:16:24,480 --> 00:16:26,399
terminal management the terminal

00:16:25,839 --> 00:16:28,639
framework

00:16:26,399 --> 00:16:31,199
and what is doing the what we are doing

00:16:28,639 --> 00:16:35,440
when we are doing poor limitation

00:16:31,199 --> 00:16:38,800
so we say okay the kernel base

00:16:35,440 --> 00:16:41,839
logic will be handling

00:16:38,800 --> 00:16:42,639
and protect the silicone by managing the

00:16:41,839 --> 00:16:45,759
thermal

00:16:42,639 --> 00:16:48,160
junction okay and that will be up to the

00:16:45,759 --> 00:16:52,079
10 month framework to do that

00:16:48,160 --> 00:16:54,480
and the user space will use

00:16:52,079 --> 00:16:55,120
another app another interface which is

00:16:54,480 --> 00:16:58,480
the

00:16:55,120 --> 00:17:00,240
polka framework to set the power on the

00:16:58,480 --> 00:17:03,360
different devices in order to

00:17:00,240 --> 00:17:06,400
achieve this skin temperature

00:17:03,360 --> 00:17:09,760
so we have two different frameworks

00:17:06,400 --> 00:17:12,959
and separated by the the the main goal

00:17:09,760 --> 00:17:12,959
they have to uh to achieve

00:17:14,400 --> 00:17:18,799
so what is the polar capping framework

00:17:16,319 --> 00:17:22,079
the polar capping framework is um

00:17:18,799 --> 00:17:25,280
an empty shell is a is just

00:17:22,079 --> 00:17:29,120
an api through ccfs

00:17:25,280 --> 00:17:30,240
and it's up to someone to write the

00:17:29,120 --> 00:17:32,799
back-end driver

00:17:30,240 --> 00:17:34,880
to to plug and plug that on this

00:17:32,799 --> 00:17:38,240
framework

00:17:34,880 --> 00:17:39,840
so today we have just one back um one

00:17:38,240 --> 00:17:41,360
back-end driver which is the raffle

00:17:39,840 --> 00:17:44,840
register the wrapper

00:17:41,360 --> 00:17:46,240
register is a register to do energy

00:17:44,840 --> 00:17:50,400
imitation

00:17:46,240 --> 00:17:53,120
and also and it's also energy counter

00:17:50,400 --> 00:17:56,080
and by essence because the power cup is

00:17:53,120 --> 00:17:58,960
a csfs directory we can create

00:17:56,080 --> 00:18:00,720
the tree of directories and each

00:17:58,960 --> 00:18:04,000
directory which is

00:18:00,720 --> 00:18:04,640
representing one device has a set of

00:18:04,000 --> 00:18:08,480
files

00:18:04,640 --> 00:18:11,520
where we can read the power consumption

00:18:08,480 --> 00:18:12,000
write the power limitation and set some

00:18:11,520 --> 00:18:14,559
other

00:18:12,000 --> 00:18:15,600
options and because we have this

00:18:14,559 --> 00:18:18,799
hierarchy

00:18:15,600 --> 00:18:20,960
we can rely on that to create

00:18:18,799 --> 00:18:22,160
the the constraint the hierarchical

00:18:20,960 --> 00:18:25,760
constraint

00:18:22,160 --> 00:18:28,960
on this on this tree and

00:18:25,760 --> 00:18:30,480
there is a library also user space

00:18:28,960 --> 00:18:34,320
library allowing to

00:18:30,480 --> 00:18:38,400
directly act on this ccfs

00:18:34,320 --> 00:18:42,480
this ccfs directory structure

00:18:38,400 --> 00:18:43,600
so now let's imagine uh we want to

00:18:42,480 --> 00:18:47,280
represent that

00:18:43,600 --> 00:18:49,440
it does not really um it is not

00:18:47,280 --> 00:18:50,320
this representation does not represent

00:18:49,440 --> 00:18:52,320
necessarily

00:18:50,320 --> 00:18:55,039
the floor plan or different sensor but

00:18:52,320 --> 00:18:58,080
it's a way to represent the constraints

00:18:55,039 --> 00:19:01,280
we want to apply on the system

00:18:58,080 --> 00:19:04,240
so if we have here this

00:19:01,280 --> 00:19:04,799
this tree represented then we can put

00:19:04,240 --> 00:19:07,440
weights

00:19:04,799 --> 00:19:08,160
on this tree in order to distribute the

00:19:07,440 --> 00:19:10,960
energy

00:19:08,160 --> 00:19:12,160
budget if we decide to assign an energy

00:19:10,960 --> 00:19:17,120
budget

00:19:12,160 --> 00:19:17,120
at a higher level of the tree

00:19:19,840 --> 00:19:26,480
today we have the energy model of course

00:19:23,679 --> 00:19:28,160
i agree the energy model is not perfect

00:19:26,480 --> 00:19:30,480
it might be not the most accurate but

00:19:28,160 --> 00:19:34,720
it's not the only thing we have today

00:19:30,480 --> 00:19:36,640
and this this energy model allows to do

00:19:34,720 --> 00:19:38,559
an association between the performance

00:19:36,640 --> 00:19:40,640
state and the power consumption of this

00:19:38,559 --> 00:19:42,799
performance state

00:19:40,640 --> 00:19:44,559
thanks to that we should be able we are

00:19:42,799 --> 00:19:47,840
able well and we are

00:19:44,559 --> 00:19:51,360
we should not be we are able to create

00:19:47,840 --> 00:19:54,559
devices and export

00:19:51,360 --> 00:19:57,520
the poor consumption given the current

00:19:54,559 --> 00:20:00,640
performance state and the and the power

00:19:57,520 --> 00:20:04,080
associated to this performance data

00:20:00,640 --> 00:20:05,200
and also we are able to limit the power

00:20:04,080 --> 00:20:08,480
consumption

00:20:05,200 --> 00:20:11,840
because the the the framework the

00:20:08,480 --> 00:20:16,159
the the sap reflect framework allows

00:20:11,840 --> 00:20:16,159
to put constraints on the cpu freq

00:20:16,880 --> 00:20:24,320
and in this representation

00:20:20,559 --> 00:20:24,720
each nodes which are not devices are

00:20:24,320 --> 00:20:28,240
just

00:20:24,720 --> 00:20:31,280
virtual to aggregate the children and

00:20:28,240 --> 00:20:32,080
allows to pass the poor limitation to

00:20:31,280 --> 00:20:34,640
the children

00:20:32,080 --> 00:20:36,000
and aggregate the characteristic from

00:20:34,640 --> 00:20:39,039
the children

00:20:36,000 --> 00:20:40,640
thanks to that the user space doesn't

00:20:39,039 --> 00:20:43,760
have to

00:20:40,640 --> 00:20:46,080
act on the power here and there

00:20:43,760 --> 00:20:48,320
to change the the power of the different

00:20:46,080 --> 00:20:53,760
devices and add the canal they have

00:20:48,320 --> 00:20:53,760
available one single interfaces

00:20:54,000 --> 00:20:57,360
so if we take an example here for power

00:20:56,400 --> 00:20:59,200
distribution

00:20:57,360 --> 00:21:01,200
let's imagine we have here the weights

00:20:59,200 --> 00:21:01,679
we compute the weight given the maximum

00:21:01,200 --> 00:21:04,720
weight

00:21:01,679 --> 00:21:08,640
of the the maximum power consumer

00:21:04,720 --> 00:21:10,559
by the the most um the big cpu

00:21:08,640 --> 00:21:13,919
we have this weight and the sum of this

00:21:10,559 --> 00:21:17,039
weight is 1024 which is the

00:21:13,919 --> 00:21:20,480
the usually what we do in

00:21:17,039 --> 00:21:22,720
in the kernel to compute percentages

00:21:20,480 --> 00:21:24,679
and we decide to set a power limit for

00:21:22,720 --> 00:21:27,440
example to

00:21:24,679 --> 00:21:31,039
2800 milliwatts to that

00:21:27,440 --> 00:21:33,520
with the weight we distribute this power

00:21:31,039 --> 00:21:34,240
to the different children on the tree

00:21:33,520 --> 00:21:37,440
and we have

00:21:34,240 --> 00:21:40,960
a static limit in milliwatts

00:21:37,440 --> 00:21:40,960
for those devices

00:21:41,360 --> 00:21:47,760
then we can read what we are

00:21:44,720 --> 00:21:48,320
actually consuming and in the case for

00:21:47,760 --> 00:21:52,080
example

00:21:48,320 --> 00:21:55,760
here in this example the big cpu

00:21:52,080 --> 00:21:57,520
is not using all the power we

00:21:55,760 --> 00:21:59,520
all deport budget all the power we

00:21:57,520 --> 00:22:02,960
allocated so we have

00:21:59,520 --> 00:22:06,320
more than 1 000 milliwatts

00:22:02,960 --> 00:22:07,039
available and we can use this available

00:22:06,320 --> 00:22:10,080
power

00:22:07,039 --> 00:22:13,440
to the other to the siblings and stay

00:22:10,080 --> 00:22:16,799
always in this constraint we put on the

00:22:13,440 --> 00:22:19,600
upper node so we can

00:22:16,799 --> 00:22:20,320
dispatch that given the weight again to

00:22:19,600 --> 00:22:23,440
the other

00:22:20,320 --> 00:22:24,320
to the other sibling and that will

00:22:23,440 --> 00:22:28,400
result

00:22:24,320 --> 00:22:31,679
in again free power for the order

00:22:28,400 --> 00:22:34,799
and now let's imagine the the

00:22:31,679 --> 00:22:35,440
little want it to have more performance

00:22:34,799 --> 00:22:38,799
and then will

00:22:35,440 --> 00:22:41,600
increase in term of performance so

00:22:38,799 --> 00:22:44,000
the time the the power consumption will

00:22:41,600 --> 00:22:44,000
increase

00:22:44,559 --> 00:22:50,400
and now the big wants also

00:22:48,240 --> 00:22:51,600
to have more power and the performance

00:22:50,400 --> 00:22:54,559
increase

00:22:51,600 --> 00:22:55,919
then it takes more we are violating this

00:22:54,559 --> 00:22:59,280
constraint

00:22:55,919 --> 00:23:02,000
and now we have to do a big ass to take

00:22:59,280 --> 00:23:03,840
back the power it got to the other

00:23:02,000 --> 00:23:06,880
sibling

00:23:03,840 --> 00:23:08,720
then we go back to the dynamic limit so

00:23:06,880 --> 00:23:11,840
we set the dynamic limit and we

00:23:08,720 --> 00:23:14,320
see what is used and unused though so we

00:23:11,840 --> 00:23:18,080
see now the big is

00:23:14,320 --> 00:23:20,720
uh come back in um it's it is uh

00:23:18,080 --> 00:23:22,960
fulfilling the constraint and we still

00:23:20,720 --> 00:23:26,320
have 300

00:23:22,960 --> 00:23:27,440
so we can dispatch that we see there is

00:23:26,320 --> 00:23:31,200
00:23:27,440 --> 00:23:34,400
still free for memory and we

00:23:31,200 --> 00:23:36,320
give this 200 to the to the little again

00:23:34,400 --> 00:23:39,200
because you need more power head

00:23:36,320 --> 00:23:39,919
tien we are still violating we are we

00:23:39,200 --> 00:23:43,520
don't have

00:23:39,919 --> 00:23:44,799
free power so the little is um uh

00:23:43,520 --> 00:23:46,640
above the constraint beyond the

00:23:44,799 --> 00:23:48,080
constraints so we don't have the choice

00:23:46,640 --> 00:23:50,480
we limit

00:23:48,080 --> 00:23:52,159
the the power and we fulfill the

00:23:50,480 --> 00:23:54,240
constraint that is the algorithm to

00:23:52,159 --> 00:23:55,520
automatically balance the power across

00:23:54,240 --> 00:23:58,799
the different nodes

00:23:55,520 --> 00:24:05,679
by putting just a constraint on the top

00:23:58,799 --> 00:24:07,200
on top level

00:24:05,679 --> 00:24:09,200
okay you're almost at the end of the

00:24:07,200 --> 00:24:11,360
time yeah so we go to the conclusion

00:24:09,200 --> 00:24:14,480
directly

00:24:11,360 --> 00:24:17,440
um yes for reference there is a status

00:24:14,480 --> 00:24:19,279
of the current ongoing work

00:24:17,440 --> 00:24:21,120
and so as a conclusion of the

00:24:19,279 --> 00:24:22,880
presentation we are we see

00:24:21,120 --> 00:24:24,320
that we have one framework which is the

00:24:22,880 --> 00:24:26,720
term framework

00:24:24,320 --> 00:24:28,480
uh and it is abused by the different

00:24:26,720 --> 00:24:31,600
in-house solution we have

00:24:28,480 --> 00:24:32,799
here and there and the solutions are not

00:24:31,600 --> 00:24:36,000
observable

00:24:32,799 --> 00:24:37,679
and it's it is not the main goal of the

00:24:36,000 --> 00:24:39,440
thermal framework the main good main

00:24:37,679 --> 00:24:42,880
goal is to protect the silicone

00:24:39,440 --> 00:24:43,760
so we want to keep this going but we see

00:24:42,880 --> 00:24:45,520
that the

00:24:43,760 --> 00:24:47,440
different stock are getting more and

00:24:45,520 --> 00:24:51,360
more complex and we have

00:24:47,440 --> 00:24:54,559
to manage the power the eating effect of

00:24:51,360 --> 00:24:55,360
all these devices as a whole in order to

00:24:54,559 --> 00:24:59,120
ensure that

00:24:55,360 --> 00:25:02,640
we skip we keep this skin temperature

00:24:59,120 --> 00:25:02,640
and the proposal we

00:25:02,799 --> 00:25:06,720
the our proposal is to create a power

00:25:05,200 --> 00:25:08,960
pole cap framework

00:25:06,720 --> 00:25:12,320
based on the energy model but it can be

00:25:08,960 --> 00:25:14,640
extended to more things like the scmi

00:25:12,320 --> 00:25:15,520
in order to model the constraints we

00:25:14,640 --> 00:25:17,919
want to apply

00:25:15,520 --> 00:25:20,080
to the different devices but we still

00:25:17,919 --> 00:25:23,279
delegate the logic to the user space

00:25:20,080 --> 00:25:27,440
even if we can have a subset which is

00:25:23,279 --> 00:25:30,720
able to handle the power balancing

00:25:27,440 --> 00:25:33,919
and on the different nodes we

00:25:30,720 --> 00:25:36,000
provide one single unit making sense

00:25:33,919 --> 00:25:40,159
which is the what

00:25:36,000 --> 00:25:43,760
and i we i just skipped this section but

00:25:40,159 --> 00:25:46,400
the polar cap framework allows to create

00:25:43,760 --> 00:25:48,480
any number of constraints we want so

00:25:46,400 --> 00:25:50,480
this solution is extendable

00:25:48,480 --> 00:25:52,080
and we can change the semantic of the

00:25:50,480 --> 00:25:55,200
constraint like setting

00:25:52,080 --> 00:25:58,720
for example giving some

00:25:55,200 --> 00:26:00,720
room for the the power ovulation so

00:25:58,720 --> 00:26:02,400
before capping so that we allow some

00:26:00,720 --> 00:26:05,840
peak peak load

00:26:02,400 --> 00:26:08,720
and uh and without um

00:26:05,840 --> 00:26:09,600
doing the limitation okay so that was

00:26:08,720 --> 00:26:12,640
short

00:26:09,600 --> 00:26:15,200
finish thank you

00:26:12,640 --> 00:26:15,840
i'm available on the channel if you want

00:26:15,200 --> 00:26:18,880
to ask

00:26:15,840 --> 00:26:18,880

YouTube URL: https://www.youtube.com/watch?v=c0Oo8CotYYM


