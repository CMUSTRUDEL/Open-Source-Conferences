Title: LVC20-214 Arm Architecture 2020 Extensions
Publication date: 2020-09-21
Playlist: Linaro Virtual Connect 2020
Description: 
	Chat live with the speaker of LVC20-213 during the scheduled broadcast time here: https://linaroconnect.slack.com/archives/C01B48BGW10

DESCRIPTION
The Arm Architecture is continually evolving to meet the needs of our ecosystem partners. Arm, Linaro, and the wider ecosystem build on the foundations of the Architecture, creating a rich and varied range of products along with associated Firmware and Software, driving the technology of the future.

This talk will introduce the 2020 extensions to the A profile architecture, ahead of the release of the updated register and instruction set XML. It will discuss the software enablement that has been going on, and the future development needs of the wider ecosystem, to ensure that software is available when physical products are delivered.
Captions: 
	00:00:00,080 --> 00:00:03,360
oh uh my name is martin weiman i'm with

00:00:02,960 --> 00:00:06,319
arm

00:00:03,360 --> 00:00:07,919
and i'm the product manager for the a

00:00:06,319 --> 00:00:11,200
profile architecture

00:00:07,919 --> 00:00:12,960
uh this is my first lenovo connect so

00:00:11,200 --> 00:00:14,480
it's nice to be with you if only

00:00:12,960 --> 00:00:16,080
virtually

00:00:14,480 --> 00:00:18,080
what i plan to go through in this

00:00:16,080 --> 00:00:20,160
session is the

00:00:18,080 --> 00:00:22,880
changes and enhancements we're adding to

00:00:20,160 --> 00:00:26,080
the arm architecture in the a profile

00:00:22,880 --> 00:00:26,080
in 2020

00:00:29,199 --> 00:00:34,559
uh so a little bit of history before we

00:00:31,679 --> 00:00:37,360
jump into this year's extensions

00:00:34,559 --> 00:00:38,559
since the introduction of arm v8 quite a

00:00:37,360 --> 00:00:41,600
few years ago now

00:00:38,559 --> 00:00:43,760
we've maintained an annual dot

00:00:41,600 --> 00:00:46,320
x extension which we bring out every

00:00:43,760 --> 00:00:48,399
year and the idea of this is to continue

00:00:46,320 --> 00:00:51,360
evolving the architecture

00:00:48,399 --> 00:00:53,440
as we get used in more markets as we as

00:00:51,360 --> 00:00:54,879
computing itself evolves we find new

00:00:53,440 --> 00:00:55,600
problems and new things we want to

00:00:54,879 --> 00:00:57,520
tackle

00:00:55,600 --> 00:00:59,440
and so new features we want to put into

00:00:57,520 --> 00:01:01,760
the architecture

00:00:59,440 --> 00:01:04,239
so this is my first learner connect but

00:01:01,760 --> 00:01:06,159
my predecessor matthew grete and dan and

00:01:04,239 --> 00:01:08,080
before him david brash we've come to

00:01:06,159 --> 00:01:10,479
lanaro most years to talk about

00:01:08,080 --> 00:01:12,080
what we've added so to give you examples

00:01:10,479 --> 00:01:16,159
of things we've done in the past

00:01:12,080 --> 00:01:18,960
in 2014 as part of 8.1 we have the vhe

00:01:16,159 --> 00:01:21,520
that's virtualization host extensions to

00:01:18,960 --> 00:01:24,159
support hypervisors like kvm

00:01:21,520 --> 00:01:26,080
last year in fact it was nigel stevens

00:01:24,159 --> 00:01:28,960
who presented and we had things like

00:01:26,080 --> 00:01:30,400
the uh support for gems so generic

00:01:28,960 --> 00:01:33,680
matrix operations and b

00:01:30,400 --> 00:01:34,479
float 16. so we think this program is

00:01:33,680 --> 00:01:36,560
very important

00:01:34,479 --> 00:01:38,640
it allows us to continue evolving the

00:01:36,560 --> 00:01:40,880
architecture adding more features

00:01:38,640 --> 00:01:43,119
and we maintain this annual cadence to

00:01:40,880 --> 00:01:44,640
give predictability to the ecosystem to

00:01:43,119 --> 00:01:46,399
you guys so you know

00:01:44,640 --> 00:01:48,079
when things are going to land when we're

00:01:46,399 --> 00:01:49,840
going to provide things like register

00:01:48,079 --> 00:01:52,240
xml

00:01:49,840 --> 00:01:54,159
and that allows that to feed into

00:01:52,240 --> 00:01:56,640
downstream projects like compilers and

00:01:54,159 --> 00:01:58,560
kernels and so on

00:01:56,640 --> 00:02:01,439
so that's in previous years what are we

00:01:58,560 --> 00:02:03,600
adding in this year in 2020

00:02:01,439 --> 00:02:05,759
well no surprising for guessing that

00:02:03,600 --> 00:02:08,479
this year's extension is called 8.7

00:02:05,759 --> 00:02:10,239
where nothing not imaginative in when we

00:02:08,479 --> 00:02:13,280
increment the number

00:02:10,239 --> 00:02:16,160
and the highlights this year are

00:02:13,280 --> 00:02:19,680
expanding support for 52-bit addressing

00:02:16,160 --> 00:02:23,280
we have support for pci hot unplug

00:02:19,680 --> 00:02:26,879
some extra atomic operations changes to

00:02:23,280 --> 00:02:28,879
wfi and wfe to add a timeout option

00:02:26,879 --> 00:02:29,920
and improvements to pan that's

00:02:28,879 --> 00:02:33,599
privileged access

00:02:29,920 --> 00:02:35,200
never now in previous talks we've also

00:02:33,599 --> 00:02:38,319
introduced the idea of

00:02:35,200 --> 00:02:41,360
future architecture technologies or fat

00:02:38,319 --> 00:02:42,800
so this is as yet unreleased versions of

00:02:41,360 --> 00:02:45,840
the architecture but

00:02:42,800 --> 00:02:48,959
we use this program to give advanced

00:02:45,840 --> 00:02:50,720
access to features we will add in future

00:02:48,959 --> 00:02:53,040
versions and we're also

00:02:50,720 --> 00:02:54,959
this year announcing two features as

00:02:53,040 --> 00:02:57,440
part of that fact program

00:02:54,959 --> 00:03:00,000
branch record buffer and call stack

00:02:57,440 --> 00:03:00,000
recorder

00:03:00,480 --> 00:03:07,040
so if we start with the 8.7 features

00:03:04,640 --> 00:03:09,200
so the first of this year's features it

00:03:07,040 --> 00:03:12,000
relates to 52-bit addressing

00:03:09,200 --> 00:03:12,720
the original 8.0 architecture had

00:03:12,000 --> 00:03:15,760
support for

00:03:12,720 --> 00:03:17,680
48-bit virtual and physical addresses we

00:03:15,760 --> 00:03:21,120
expanded that to

00:03:17,680 --> 00:03:23,040
bits in arm 8.1

00:03:21,120 --> 00:03:24,239
but there was a limitation on that

00:03:23,040 --> 00:03:26,640
enhanced support

00:03:24,239 --> 00:03:28,480
specifically that you could only use it

00:03:26,640 --> 00:03:31,599
if you had a 64k

00:03:28,480 --> 00:03:34,239
translation granule that's fine for some

00:03:31,599 --> 00:03:34,799
operating systems and distributions but

00:03:34,239 --> 00:03:37,440
not all

00:03:34,799 --> 00:03:38,400
um notably things like android user 4k

00:03:37,440 --> 00:03:41,440
granule

00:03:38,400 --> 00:03:44,159
and therefore they were unable to access

00:03:41,440 --> 00:03:46,159
this feature we added um so as part of

00:03:44,159 --> 00:03:49,680
this year's extension 8.7

00:03:46,159 --> 00:03:51,920
we're going to expand uh access to the

00:03:49,680 --> 00:03:54,959
larger address spaces to the 4k

00:03:51,920 --> 00:03:56,480
and 16k granules um

00:03:54,959 --> 00:03:58,319
in that sense it's not particularly

00:03:56,480 --> 00:04:01,280
revolutionary this is a feature you

00:03:58,319 --> 00:04:03,439
probably already know how to use the

00:04:01,280 --> 00:04:05,760
architectural impacts are relatively

00:04:03,439 --> 00:04:07,920
low so for example you know we change

00:04:05,760 --> 00:04:09,439
the limits on the field that records the

00:04:07,920 --> 00:04:11,680
size of the address space

00:04:09,439 --> 00:04:12,799
however there's one thing to point out

00:04:11,680 --> 00:04:16,160
and that is

00:04:12,799 --> 00:04:16,799
in order to cover the extra address

00:04:16,160 --> 00:04:19,440
space

00:04:16,799 --> 00:04:20,160
with 4k granules we need an extra level

00:04:19,440 --> 00:04:22,400
of table

00:04:20,160 --> 00:04:23,280
so we go from a maximum of four levels

00:04:22,400 --> 00:04:25,840
to a maximum

00:04:23,280 --> 00:04:28,080
five as we already went from zero to

00:04:25,840 --> 00:04:29,040
three the new level is called slightly

00:04:28,080 --> 00:04:31,680
confusingly

00:04:29,040 --> 00:04:31,680
minus one

00:04:34,880 --> 00:04:38,800
the next feature we're going to

00:04:36,400 --> 00:04:41,919
introduce is relates to

00:04:38,800 --> 00:04:45,199
hot unplug of devices

00:04:41,919 --> 00:04:47,040
i've entitled the slide pcie hot unplug

00:04:45,199 --> 00:04:48,000
but it applies to other technologies as

00:04:47,040 --> 00:04:51,120
well

00:04:48,000 --> 00:04:54,560
so imagine a system where you have

00:04:51,120 --> 00:04:56,160
devices plugged in to your laptop

00:04:54,560 --> 00:04:57,919
such as the machine i'm using to make

00:04:56,160 --> 00:05:01,360
this recording on

00:04:57,919 --> 00:05:03,440
um if i unplug a device unexpectedly

00:05:01,360 --> 00:05:05,120
it's possible that that device was still

00:05:03,440 --> 00:05:06,639
being used that there's outstanding

00:05:05,120 --> 00:05:09,440
transactions to the device

00:05:06,639 --> 00:05:11,919
at the point i pulled the plug out let's

00:05:09,440 --> 00:05:14,160
find the bus technology support this so

00:05:11,919 --> 00:05:18,400
if we take the example of pcie

00:05:14,160 --> 00:05:19,600
it will return a default response after

00:05:18,400 --> 00:05:21,759
a timeout period

00:05:19,600 --> 00:05:23,520
that timeout is typically in the range

00:05:21,759 --> 00:05:25,360
of 50 milliseconds

00:05:23,520 --> 00:05:27,600
now on the human scale that's not very

00:05:25,360 --> 00:05:28,000
long at all but in a computing scale if

00:05:27,600 --> 00:05:30,400
you've got

00:05:28,000 --> 00:05:32,160
a two gigahertz processor that's an

00:05:30,400 --> 00:05:33,600
awful lot of cycles

00:05:32,160 --> 00:05:35,680
now there's not a huge amount we can do

00:05:33,600 --> 00:05:36,320
about this uh the application that's

00:05:35,680 --> 00:05:39,360
directly

00:05:36,320 --> 00:05:42,960
interacting with that device

00:05:39,360 --> 00:05:44,080
is going to be impacted because it has

00:05:42,960 --> 00:05:47,360
to wait for the timeout

00:05:44,080 --> 00:05:51,039
but what we do want to avoid is other

00:05:47,360 --> 00:05:54,240
unrelated threads being affected

00:05:51,039 --> 00:05:54,880
so example here is if i say unplug my

00:05:54,240 --> 00:05:57,199
usb

00:05:54,880 --> 00:05:58,720
keyboard that shouldn't affect anything

00:05:57,199 --> 00:06:00,479
that's not actively talking to that

00:05:58,720 --> 00:06:03,840
device at the moment i don't expect say

00:06:00,479 --> 00:06:06,720
a glitch in video playback

00:06:03,840 --> 00:06:07,680
why might that occur well here's an

00:06:06,720 --> 00:06:10,080
example

00:06:07,680 --> 00:06:11,680
so we have our two calls that the first

00:06:10,080 --> 00:06:13,199
core is directly

00:06:11,680 --> 00:06:14,960
is interacting with the device that's

00:06:13,199 --> 00:06:16,400
been unplugged and it's blocked on the

00:06:14,960 --> 00:06:18,160
timeout

00:06:16,400 --> 00:06:20,000
on another call we have a different

00:06:18,160 --> 00:06:22,000
unrelated thread

00:06:20,000 --> 00:06:25,680
executing and that thread is going to

00:06:22,000 --> 00:06:28,080
issue a trans uh tlb invalidator tlbi

00:06:25,680 --> 00:06:30,160
followed by a dsb now the way that works

00:06:28,080 --> 00:06:30,880
on arm is that will be broadcast of the

00:06:30,160 --> 00:06:33,919
fabric

00:06:30,880 --> 00:06:34,560
and the other core also has to perform

00:06:33,919 --> 00:06:36,800
the

00:06:34,560 --> 00:06:37,919
tlb and validate and we'll send a

00:06:36,800 --> 00:06:40,000
response back

00:06:37,919 --> 00:06:41,039
when it's not only done the invalidate

00:06:40,000 --> 00:06:43,600
but there are no

00:06:41,039 --> 00:06:45,360
trans transactions relying on that

00:06:43,600 --> 00:06:47,039
translation

00:06:45,360 --> 00:06:48,720
now in theory because this is an

00:06:47,039 --> 00:06:50,240
unrelated thread it should be able to do

00:06:48,720 --> 00:06:53,599
that pretty quickly

00:06:50,240 --> 00:06:55,520
but it's not using that memory the issue

00:06:53,599 --> 00:06:56,000
is that on some implementations they

00:06:55,520 --> 00:06:59,560
don't

00:06:56,000 --> 00:07:03,120
track which tlb entry a outstanding

00:06:59,560 --> 00:07:04,960
transaction belongs to so the way we

00:07:03,120 --> 00:07:06,479
they the way they deal with tlb

00:07:04,960 --> 00:07:08,240
validates is just to wait for

00:07:06,479 --> 00:07:09,520
all transactions to complete and that

00:07:08,240 --> 00:07:10,880
way you're safe

00:07:09,520 --> 00:07:12,720
the issue is that one of our

00:07:10,880 --> 00:07:14,319
transactions is now very slow because

00:07:12,720 --> 00:07:16,080
it's to an unplugged device

00:07:14,319 --> 00:07:17,919
and now both calls are waiting on the

00:07:16,080 --> 00:07:19,120
timeout and that could cause jitter in

00:07:17,919 --> 00:07:22,560
the infrared which we

00:07:19,120 --> 00:07:25,280
is the thing we wanted to avoid

00:07:22,560 --> 00:07:27,360
so what are we doing to fix this it's

00:07:25,280 --> 00:07:29,520
our adding a new attribute that you can

00:07:27,360 --> 00:07:30,960
assign to a region of address space it's

00:07:29,520 --> 00:07:33,360
called xs

00:07:30,960 --> 00:07:35,599
and in essence it tell it allows

00:07:33,360 --> 00:07:39,199
software to say whether regions

00:07:35,599 --> 00:07:44,240
are fast or slow what we mean by that is

00:07:39,199 --> 00:07:47,120
whether they could experience

00:07:44,240 --> 00:07:47,840
delay for example due to a timeout so

00:07:47,120 --> 00:07:51,440
we'd mark

00:07:47,840 --> 00:07:53,919
our pcie devices as xs equals one

00:07:51,440 --> 00:07:54,479
so potentially subject to these delays

00:07:53,919 --> 00:07:56,560
we'd mark

00:07:54,479 --> 00:07:58,319
other regions such as memory or on-chip

00:07:56,560 --> 00:08:01,360
devices that can't be unplugged

00:07:58,319 --> 00:08:04,000
that's xs zero so fast

00:08:01,360 --> 00:08:05,919
and now we don't have to track the

00:08:04,000 --> 00:08:08,080
entire translation entry but

00:08:05,919 --> 00:08:08,960
if we track whether a transaction is

00:08:08,080 --> 00:08:12,000
fast or slow

00:08:08,960 --> 00:08:14,080
when we get tlbi's in we can check

00:08:12,000 --> 00:08:15,360
the attribute of the tlbi against the

00:08:14,080 --> 00:08:16,319
attribute of the outstanding

00:08:15,360 --> 00:08:18,240
transactions

00:08:16,319 --> 00:08:20,080
it gives us a relatively cheap and

00:08:18,240 --> 00:08:21,199
effective way of seeing if there are

00:08:20,080 --> 00:08:23,840
outstanding

00:08:21,199 --> 00:08:25,599
accesses of the correct type and if not

00:08:23,840 --> 00:08:28,560
we can reply to the tlba

00:08:25,599 --> 00:08:30,160
tlbi quickly and thereby reduce the

00:08:28,560 --> 00:08:32,560
impact on other threats

00:08:30,160 --> 00:08:35,839
so it's a low-impact way of avoiding

00:08:32,560 --> 00:08:35,839
this kind of scenario

00:08:39,120 --> 00:08:42,959
sticking on the subject of things like

00:08:41,120 --> 00:08:44,880
pcie and accelerators

00:08:42,959 --> 00:08:47,360
uh another feature we are adding this

00:08:44,880 --> 00:08:49,120
year is 64 byte atomics

00:08:47,360 --> 00:08:51,120
um i'm getting so used to talking about

00:08:49,120 --> 00:08:51,440
64 bits that i do sometimes get that

00:08:51,120 --> 00:08:54,560
wrong

00:08:51,440 --> 00:08:55,040
apologies in advance but these are 64

00:08:54,560 --> 00:08:58,800
byte

00:08:55,040 --> 00:09:00,959
not bit atomics um they look like

00:08:58,800 --> 00:09:02,160
load and store instructions apart from

00:09:00,959 --> 00:09:05,440
obviously they take

00:09:02,160 --> 00:09:07,839
more data or load or store more data

00:09:05,440 --> 00:09:09,600
these operations are designed for

00:09:07,839 --> 00:09:12,959
talking to accelerators

00:09:09,600 --> 00:09:15,760
where often they work on the basis of

00:09:12,959 --> 00:09:18,080
a queue so you enqueue a work item or

00:09:15,760 --> 00:09:20,240
you dequeue a work item

00:09:18,080 --> 00:09:22,000
and some accelerators support the

00:09:20,240 --> 00:09:23,839
ability to report whether that

00:09:22,000 --> 00:09:25,040
enqueue operation succeeded that was

00:09:23,839 --> 00:09:28,000
space on the queue or

00:09:25,040 --> 00:09:29,760
failed there wasn't space so we provide

00:09:28,000 --> 00:09:33,200
three variants of the store instruction

00:09:29,760 --> 00:09:33,600
a simple 64 byte store a 64 byte store

00:09:33,200 --> 00:09:36,399
with

00:09:33,600 --> 00:09:38,560
a fail or return a bit like the way load

00:09:36,399 --> 00:09:40,959
and store exclusives work

00:09:38,560 --> 00:09:42,399
and a third variant which has the fail

00:09:40,959 --> 00:09:45,680
or succeed status

00:09:42,399 --> 00:09:47,760
but also replaces the bottom 32 bits

00:09:45,680 --> 00:09:51,360
of the written data with that from a

00:09:47,760 --> 00:09:53,600
register called ac data

00:09:51,360 --> 00:09:54,720
as mentioned there is also a load

00:09:53,600 --> 00:09:58,000
version of this

00:09:54,720 --> 00:09:59,680
instruction um which just returns 64

00:09:58,000 --> 00:10:01,519
bytes of data

00:09:59,680 --> 00:10:03,040
as mentioned they are intended for

00:10:01,519 --> 00:10:04,720
accelerators these aren't

00:10:03,040 --> 00:10:07,040
really for memory operations we don't

00:10:04,720 --> 00:10:09,279
expect you to do these to say ram

00:10:07,040 --> 00:10:10,240
and so part of the restriction on them

00:10:09,279 --> 00:10:12,320
is that you can

00:10:10,240 --> 00:10:18,160
only do them to our virtual addresses

00:10:12,320 --> 00:10:19,839
marked as non-casual

00:10:18,160 --> 00:10:22,320
another feature we're adding this year

00:10:19,839 --> 00:10:23,200
is variants of the wfe and wfi

00:10:22,320 --> 00:10:26,640
instruction

00:10:23,200 --> 00:10:27,440
uh they these variants now include a

00:10:26,640 --> 00:10:30,800
timeout

00:10:27,440 --> 00:10:32,000
so wpw5 for those of you who haven't

00:10:30,800 --> 00:10:34,399
come across them they put

00:10:32,000 --> 00:10:35,600
the core into standby so effectively

00:10:34,399 --> 00:10:38,320
clock gate

00:10:35,600 --> 00:10:40,480
is a relatively quick and simple way of

00:10:38,320 --> 00:10:42,240
getting in and out of a low power state

00:10:40,480 --> 00:10:43,680
they're typically used when waiting on a

00:10:42,240 --> 00:10:45,519
resource to become free

00:10:43,680 --> 00:10:47,680
if you think the weight is going to be

00:10:45,519 --> 00:10:50,880
relatively short

00:10:47,680 --> 00:10:53,519
one issue with them is that they

00:10:50,880 --> 00:10:54,000
have uh the amount of time you can be

00:10:53,519 --> 00:10:56,640
asleep

00:10:54,000 --> 00:10:57,120
is unbounded and that is there's wake up

00:10:56,640 --> 00:11:02,079
event

00:10:57,120 --> 00:11:05,680
an interrupt for wfe an event for wfe

00:11:02,079 --> 00:11:08,079
and until you get those will stay asleep

00:11:05,680 --> 00:11:09,440
um it's quite possible that you only

00:11:08,079 --> 00:11:11,040
want to sleep for a certain amount of

00:11:09,440 --> 00:11:12,720
time because you don't want to waste

00:11:11,040 --> 00:11:14,720
potential processing time and if the

00:11:12,720 --> 00:11:16,079
event doesn't happen early enough you'll

00:11:14,720 --> 00:11:18,399
yield to the scheduler and go do

00:11:16,079 --> 00:11:20,480
something else instead

00:11:18,399 --> 00:11:22,000
you can do that in today's architecture

00:11:20,480 --> 00:11:22,959
but that involves you setting up

00:11:22,000 --> 00:11:25,519
something like

00:11:22,959 --> 00:11:26,839
um the generic timer to set a periodic

00:11:25,519 --> 00:11:29,760
event that's

00:11:26,839 --> 00:11:31,920
relatively high overhead for what should

00:11:29,760 --> 00:11:34,000
be a cheap operation

00:11:31,920 --> 00:11:35,519
so to address this we're adding a new

00:11:34,000 --> 00:11:39,200
version of both instructions

00:11:35,519 --> 00:11:41,760
wfet wfit the t for timeout

00:11:39,200 --> 00:11:42,640
and they allow you to specify alongside

00:11:41,760 --> 00:11:45,519
the instruction

00:11:42,640 --> 00:11:47,120
a timeout and if the one of the regular

00:11:45,519 --> 00:11:49,440
wake up events has not occurred

00:11:47,120 --> 00:11:51,360
by the time the timeout relaxes then you

00:11:49,440 --> 00:11:53,279
wake up anyway so it's a way of putting

00:11:51,360 --> 00:11:54,800
a maximum time that you wish to be

00:11:53,279 --> 00:11:57,600
asleep for

00:11:54,800 --> 00:11:59,519
the way this is encoded is uh it's a

00:11:57,600 --> 00:12:00,079
value that's compared against the system

00:11:59,519 --> 00:12:02,320
counter

00:12:00,079 --> 00:12:04,079
so the standard time that is used for

00:12:02,320 --> 00:12:06,240
all the built-in timers

00:12:04,079 --> 00:12:07,760
we use the same thing and it's important

00:12:06,240 --> 00:12:09,839
to say it is time not

00:12:07,760 --> 00:12:12,720
cycles so if you're doing things like

00:12:09,839 --> 00:12:15,519
dvfs it's not going to change how long

00:12:12,720 --> 00:12:15,519
you'll sleep for

00:12:17,360 --> 00:12:21,440
the final one of the 8.7 extensions for

00:12:20,480 --> 00:12:24,639
00:12:21,440 --> 00:12:25,279
is um relates to pan this is another 8.1

00:12:24,639 --> 00:12:28,800
feature

00:12:25,279 --> 00:12:32,399
privileged access never and it's a way

00:12:28,800 --> 00:12:33,760
of preventing accidental referencing of

00:12:32,399 --> 00:12:38,079
user space data

00:12:33,760 --> 00:12:40,560
with kernel permissions so if i'm in

00:12:38,079 --> 00:12:42,480
exception level 1 el1 running kernel

00:12:40,560 --> 00:12:45,440
code which is privileged i should not

00:12:42,480 --> 00:12:46,000
be ordinarily accessing user space data

00:12:45,440 --> 00:12:47,680
or if i

00:12:46,000 --> 00:12:49,760
am i know i'm doing it and it should be

00:12:47,680 --> 00:12:51,040
deliberate so to avoid sort of

00:12:49,760 --> 00:12:53,440
accidental references

00:12:51,040 --> 00:12:55,440
if you're in a pan then if you use

00:12:53,440 --> 00:12:56,399
regular load and store instructions with

00:12:55,440 --> 00:13:00,079
kernel permissions

00:12:56,399 --> 00:13:00,079
to use the data you get a fault

00:13:00,320 --> 00:13:03,760
the way this was encoded was it looked

00:13:02,800 --> 00:13:06,560
at whether el

00:13:03,760 --> 00:13:07,120
zero had read permission data read

00:13:06,560 --> 00:13:10,800
permission

00:13:07,120 --> 00:13:12,880
in the ap bits um as um

00:13:10,800 --> 00:13:14,320
a security researcher pointed out and if

00:13:12,880 --> 00:13:16,320
you're interested in the background i've

00:13:14,320 --> 00:13:18,639
given a link to their blog

00:13:16,320 --> 00:13:20,000
there's a an issue with the way we did

00:13:18,639 --> 00:13:23,120
this which is

00:13:20,000 --> 00:13:23,600
uh if you have execute only memory that

00:13:23,120 --> 00:13:26,480
is

00:13:23,600 --> 00:13:28,079
in the l0 that's still el zero memory

00:13:26,480 --> 00:13:29,920
but it doesn't have the read permission

00:13:28,079 --> 00:13:31,600
it only has the execute permission

00:13:29,920 --> 00:13:33,600
because pan is tied to the read

00:13:31,600 --> 00:13:36,639
permission not the execute

00:13:33,600 --> 00:13:37,519
you could dereference executable el zero

00:13:36,639 --> 00:13:41,199
memory

00:13:37,519 --> 00:13:43,440
uh even with pan um enabled

00:13:41,199 --> 00:13:45,519
that's not desirable it also gets in the

00:13:43,440 --> 00:13:48,720
way of some other features

00:13:45,519 --> 00:13:51,760
for instance uh jits wanted to use

00:13:48,720 --> 00:13:54,800
execute only pages so to fix this

00:13:51,760 --> 00:13:56,240
we are adding a new mode bit in the

00:13:54,800 --> 00:13:58,000
system control registers

00:13:56,240 --> 00:13:59,600
which allow you to either have the

00:13:58,000 --> 00:14:02,399
traditional pan behavior

00:13:59,600 --> 00:14:05,519
or to also block access to user space

00:14:02,399 --> 00:14:05,519
execute only memory

00:14:09,199 --> 00:14:14,639
so those are the 8.1 features

00:14:12,480 --> 00:14:16,480
it's we cover quite a few different

00:14:14,639 --> 00:14:18,399
areas but i hope you

00:14:16,480 --> 00:14:20,160
find those interesting and we will be

00:14:18,399 --> 00:14:22,240
making register xml

00:14:20,160 --> 00:14:23,839
and instruction xml available in the

00:14:22,240 --> 00:14:26,000
near future should be going

00:14:23,839 --> 00:14:27,839
live on arm's developer site pretty much

00:14:26,000 --> 00:14:30,639
any time now

00:14:27,839 --> 00:14:31,600
um finally then for this slot we're

00:14:30,639 --> 00:14:33,760
going to

00:14:31,600 --> 00:14:34,800
look at some features we're adding as

00:14:33,760 --> 00:14:37,839
part of

00:14:34,800 --> 00:14:38,800
future architecture technologies so we

00:14:37,839 --> 00:14:40,959
actually announced

00:14:38,800 --> 00:14:42,079
the future architecture technologies

00:14:40,959 --> 00:14:45,279
program

00:14:42,079 --> 00:14:47,519
in the beginning of last year in 2019

00:14:45,279 --> 00:14:48,320
and it's a way of getting information

00:14:47,519 --> 00:14:49,839
out about

00:14:48,320 --> 00:14:51,760
versions of the architecture which are

00:14:49,839 --> 00:14:53,839
not yet released or announced

00:14:51,760 --> 00:14:54,880
but we want to get this information out

00:14:53,839 --> 00:14:56,639
to enable

00:14:54,880 --> 00:14:58,560
the ecosystem start looking at the

00:14:56,639 --> 00:15:00,560
technology start building support for

00:14:58,560 --> 00:15:02,720
them

00:15:00,560 --> 00:15:03,680
so there were two features which were

00:15:02,720 --> 00:15:06,800
adding to

00:15:03,680 --> 00:15:10,000
the already announced features so

00:15:06,800 --> 00:15:13,279
announced last year was sve2 and tme

00:15:10,000 --> 00:15:17,199
we're now adding brbe and csre

00:15:13,279 --> 00:15:19,040
to that list what are these for

00:15:17,199 --> 00:15:21,199
um well the sort of sub heading on the

00:15:19,040 --> 00:15:21,920
slide uh previous slides sort of gave it

00:15:21,199 --> 00:15:24,800
away which is

00:15:21,920 --> 00:15:26,639
it's about improved invisibility of how

00:15:24,800 --> 00:15:27,839
your code is running on an arm based

00:15:26,639 --> 00:15:31,279
system

00:15:27,839 --> 00:15:35,519
so we want to know what's hot

00:15:31,279 --> 00:15:38,320
in our code so we want to do things like

00:15:35,519 --> 00:15:39,759
heat grass but we want to be able to

00:15:38,320 --> 00:15:42,480
draw diagrams like this

00:15:39,759 --> 00:15:44,639
and then feed that information into auto

00:15:42,480 --> 00:15:48,959
fdo tools

00:15:44,639 --> 00:15:48,959
we also want to be able to

00:15:50,079 --> 00:15:54,639
analyze our code and produce things like

00:15:52,720 --> 00:15:57,600
call stacks and

00:15:54,639 --> 00:15:59,360
call tree analysis and we want to be

00:15:57,600 --> 00:16:02,480
able to do this in a way which

00:15:59,360 --> 00:16:05,120
is as low impact as possible so

00:16:02,480 --> 00:16:06,639
we don't can gather this information

00:16:05,120 --> 00:16:08,399
through things like instrumentation

00:16:06,639 --> 00:16:09,680
but that's relatively high impact we

00:16:08,399 --> 00:16:11,839
want to run our code

00:16:09,680 --> 00:16:14,800
normally and still get good visibility

00:16:11,839 --> 00:16:14,800
as to what's happening

00:16:15,199 --> 00:16:19,279
um which leads us to the two extensions

00:16:17,759 --> 00:16:22,320
we're going to introduce this year

00:16:19,279 --> 00:16:24,240
which are called csre and brbe

00:16:22,320 --> 00:16:25,600
so the first one is the call stack

00:16:24,240 --> 00:16:27,920
recorder

00:16:25,600 --> 00:16:28,639
again we have very imaginative names

00:16:27,920 --> 00:16:31,440
it's a

00:16:28,639 --> 00:16:32,639
extension that records the call stack so

00:16:31,440 --> 00:16:36,320
the objective for this

00:16:32,639 --> 00:16:37,040
is to produce a call stack automatically

00:16:36,320 --> 00:16:39,680
in hardware

00:16:37,040 --> 00:16:41,839
that can be collected easily and in a

00:16:39,680 --> 00:16:44,000
form that's easy to consume

00:16:41,839 --> 00:16:45,680
that's put into memory and can be

00:16:44,000 --> 00:16:48,720
therefore sampled on something like a

00:16:45,680 --> 00:16:48,720
periodic interrupt

00:16:48,839 --> 00:16:53,759
um if when enabled you

00:16:51,839 --> 00:16:56,399
allocate some memory for the call stat

00:16:53,759 --> 00:16:58,880
recorder and every time you do

00:16:56,399 --> 00:16:59,600
a something that looks like a function

00:16:58,880 --> 00:17:02,560
call

00:16:59,600 --> 00:17:03,440
it will push some information onto the

00:17:02,560 --> 00:17:06,720
call stack

00:17:03,440 --> 00:17:08,160
and when you do a return it will

00:17:06,720 --> 00:17:10,240
move that move the point of the call

00:17:08,160 --> 00:17:11,600
stack so you always have a live view of

00:17:10,240 --> 00:17:13,520
what is in memory

00:17:11,600 --> 00:17:15,120
with the usual traps available for

00:17:13,520 --> 00:17:16,640
things like virtualization

00:17:15,120 --> 00:17:18,319
and this can be controlled separately

00:17:16,640 --> 00:17:21,839
for different exception levels so you

00:17:18,319 --> 00:17:21,839
can record different things at once

00:17:22,880 --> 00:17:27,280
alongside that we also have the branch

00:17:25,919 --> 00:17:30,000
record buffer

00:17:27,280 --> 00:17:32,000
so the previous extension gave you a

00:17:30,000 --> 00:17:35,760
view on what your current call stack

00:17:32,000 --> 00:17:36,320
was this extension gives you a view of

00:17:35,760 --> 00:17:39,679
the last

00:17:36,320 --> 00:17:41,440
few branches so it's a way to capture a

00:17:39,679 --> 00:17:43,760
sequence of branches again in an

00:17:41,440 --> 00:17:46,400
easy to consume form and we think that

00:17:43,760 --> 00:17:48,400
this is useful for things like um

00:17:46,400 --> 00:17:50,480
feedback tools that use feedback

00:17:48,400 --> 00:17:53,280
analysis for example

00:17:50,480 --> 00:17:55,520
it needs to be low overhead which should

00:17:53,280 --> 00:17:57,440
impact the performance of the processor

00:17:55,520 --> 00:17:59,919
and it needs to be in a form that's easy

00:17:57,440 --> 00:18:00,480
to consume you have things like etm

00:17:59,919 --> 00:18:03,360
trace

00:18:00,480 --> 00:18:04,720
um today but the issue with that is it's

00:18:03,360 --> 00:18:06,400
in a format that's quite difficult to

00:18:04,720 --> 00:18:08,080
decode

00:18:06,400 --> 00:18:11,120
so we want something that's easier for

00:18:08,080 --> 00:18:12,960
tools to be able to analyze

00:18:11,120 --> 00:18:15,280
so the branch record buffer every time

00:18:12,960 --> 00:18:17,600
you do a branch it records the source

00:18:15,280 --> 00:18:18,960
va the target va and some information

00:18:17,600 --> 00:18:21,760
about the type of branch

00:18:18,960 --> 00:18:22,960
also an exception function call etc and

00:18:21,760 --> 00:18:26,080
it records these

00:18:22,960 --> 00:18:29,280
in registers so you get 32 records

00:18:26,080 --> 00:18:31,039
stored in 96 registers so unlike the

00:18:29,280 --> 00:18:32,559
previous extension this is into memory

00:18:31,039 --> 00:18:34,799
it's in registers

00:18:32,559 --> 00:18:36,799
and we again would sample that

00:18:34,799 --> 00:18:42,640
periodically and feed that into

00:18:36,799 --> 00:18:44,720
profiling or analysis tool so those are

00:18:42,640 --> 00:18:47,440
the uh extensions we're introducing in

00:18:44,720 --> 00:18:50,000
this year so it's part of the 2020

00:18:47,440 --> 00:18:52,000
updates to the architecture as i

00:18:50,000 --> 00:18:53,280
mentioned in passing earlier we will be

00:18:52,000 --> 00:18:56,559
making the

00:18:53,280 --> 00:18:58,400
register xml and instruction set xml

00:18:56,559 --> 00:19:00,640
are available on arm's website in the

00:18:58,400 --> 00:19:03,440
near future if it's not already there

00:19:00,640 --> 00:19:04,400
um if you this is the url if you want to

00:19:03,440 --> 00:19:06,160
go look at it

00:19:04,400 --> 00:19:08,640
at the time i took the screenshot it was

00:19:06,160 --> 00:19:10,640
still 8.6 rather than 807 but that

00:19:08,640 --> 00:19:12,880
should be updated fairly soon

00:19:10,640 --> 00:19:14,080
we also expect an updated architecture

00:19:12,880 --> 00:19:16,240
reference manual

00:19:14,080 --> 00:19:17,280
um first quarter next year hopefully in

00:19:16,240 --> 00:19:19,520
january

00:19:17,280 --> 00:19:21,120
and uh i hope you found it interesting

00:19:19,520 --> 00:19:23,280
and useful i will be online

00:19:21,120 --> 00:19:27,440
for a bit longer to take questions and i

00:19:23,280 --> 00:19:27,440

YouTube URL: https://www.youtube.com/watch?v=CSUohi1XY78


