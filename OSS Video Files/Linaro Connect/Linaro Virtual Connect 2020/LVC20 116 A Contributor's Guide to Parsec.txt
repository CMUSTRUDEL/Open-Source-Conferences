Title: LVC20 116 A Contributor's Guide to Parsec
Publication date: 2020-10-09
Playlist: Linaro Virtual Connect 2020
Description: 
	Guide to Parsec
Parsec is the Platform Abstraction for Security, an open-source initiative that aims to create simple, standardised, ergonomic software interfaces for interacting with hardware-backed security features on any platform in any programming language. Parsec has now been accepted by the Cloud Native Compute Foundation as a sandbox project, which makes this the ideal time to learn how to contribute. There is plenty to do! This developer-focused session will provide an overview of the Parsec architecture and its long-term vision, along with a guided tour of the code base, and some pointers for getting started.

For the presentation see: https://static.linaro.org/connect/lvc20/presentations/LVC20-116-0.pdf
Captions: 
	00:00:01,280 --> 00:00:05,520
okay uh well um hello

00:00:03,120 --> 00:00:07,440
everyone um welcome to this session on a

00:00:05,520 --> 00:00:09,599
contributor's guide to parsec

00:00:07,440 --> 00:00:11,120
uh it's great to be here at connect um

00:00:09,599 --> 00:00:13,200
i'm happy to be able to give you this

00:00:11,120 --> 00:00:16,480
uh introduction to pas second and not

00:00:13,200 --> 00:00:20,640
just an introduction but an invitation

00:00:16,480 --> 00:00:22,720
in fact to this open source initiative

00:00:20,640 --> 00:00:23,920
um i've just realized i'm not sharing my

00:00:22,720 --> 00:00:26,480
camera

00:00:23,920 --> 00:00:26,480
just a moment

00:00:27,920 --> 00:00:32,559
an invitation to this open source

00:00:29,439 --> 00:00:34,559
initiative which is at an exciting stage

00:00:32,559 --> 00:00:37,040
in its evolution i'm hoping we'll

00:00:34,559 --> 00:00:39,760
transfer some of that excitement to you

00:00:37,040 --> 00:00:39,760
in this session

00:00:41,360 --> 00:00:45,600
so let's introduce ourselves uh i'm paul

00:00:43,520 --> 00:00:48,079
howard and i'm joined by my colleague

00:00:45,600 --> 00:00:49,520
development we're both at arm both

00:00:48,079 --> 00:00:51,360
working on parsec

00:00:49,520 --> 00:00:52,559
you can see our email addresses github

00:00:51,360 --> 00:00:54,399
handles there

00:00:52,559 --> 00:00:55,920
and we're part of a broader community of

00:00:54,399 --> 00:00:57,760
parsec maintainers

00:00:55,920 --> 00:00:59,520
and collaborators both inside and

00:00:57,760 --> 00:01:01,359
outside of arm

00:00:59,520 --> 00:01:02,800
and we'll be introducing that community

00:01:01,359 --> 00:01:05,920
to you as

00:01:02,800 --> 00:01:08,479
as part of this talk okay

00:01:05,920 --> 00:01:10,400
moving on agenda the title of our talk

00:01:08,479 --> 00:01:12,479
is a contributor's guide to parsec so

00:01:10,400 --> 00:01:14,240
our main aim is to get you

00:01:12,479 --> 00:01:16,640
interested and enthused about

00:01:14,240 --> 00:01:18,320
contributing um but parsec

00:01:16,640 --> 00:01:20,799
might not be familiar to you so if it's

00:01:18,320 --> 00:01:23,200
not i'll begin with some scene setting

00:01:20,799 --> 00:01:25,200
we'll cover what parsec is the problem

00:01:23,200 --> 00:01:26,880
that it's trying to solve

00:01:25,200 --> 00:01:28,479
and we're going to spend some time also

00:01:26,880 --> 00:01:29,759
talking about the rust programming

00:01:28,479 --> 00:01:32,720
language which we're using

00:01:29,759 --> 00:01:34,240
in parsec we'll introduce rust quickly

00:01:32,720 --> 00:01:35,119
for those who aren't already familiar

00:01:34,240 --> 00:01:36,960
with it

00:01:35,119 --> 00:01:38,880
um we'll talk about why that language

00:01:36,960 --> 00:01:41,600
choice is important for parsec

00:01:38,880 --> 00:01:43,360
and for arm and then we'll talk about

00:01:41,600 --> 00:01:44,240
the opportunities that exist within

00:01:43,360 --> 00:01:46,799
parsec

00:01:44,240 --> 00:01:48,640
for getting involved and then we'll wrap

00:01:46,799 --> 00:01:51,200
up by giving you some links

00:01:48,640 --> 00:01:51,920
some pointers that you'll need to start

00:01:51,200 --> 00:01:54,960
that

00:01:51,920 --> 00:01:56,640
that journey towards becoming a member

00:01:54,960 --> 00:01:58,399
of this growing community

00:01:56,640 --> 00:02:00,399
um it is a short session it's quite a

00:01:58,399 --> 00:02:02,000
cram session uh we may have a few

00:02:00,399 --> 00:02:04,079
minutes at the end for questions

00:02:02,000 --> 00:02:07,119
um apologies in advance we might not get

00:02:04,079 --> 00:02:09,039
to questions that come in over live chat

00:02:07,119 --> 00:02:10,239
just because of how crammed the session

00:02:09,039 --> 00:02:11,520
is um

00:02:10,239 --> 00:02:13,640
but if you post your question on the

00:02:11,520 --> 00:02:14,879
conference slack channel so the the

00:02:13,640 --> 00:02:16,879
lvc2116

00:02:14,879 --> 00:02:20,319
channel um you and i will certainly get

00:02:16,879 --> 00:02:20,319
to it afterwards

00:02:20,560 --> 00:02:24,640
all right uh let's start with the why so

00:02:22,720 --> 00:02:27,200
why parsec

00:02:24,640 --> 00:02:28,080
um now first we need to we need to

00:02:27,200 --> 00:02:30,160
realize

00:02:28,080 --> 00:02:32,080
um that the world of edge compute is

00:02:30,160 --> 00:02:33,599
changing it's it's no longer just a

00:02:32,080 --> 00:02:36,000
world of gateways

00:02:33,599 --> 00:02:37,440
of protocol translation translation it's

00:02:36,000 --> 00:02:40,720
becoming a much richer

00:02:37,440 --> 00:02:41,840
a more compute capable world so it's a

00:02:40,720 --> 00:02:43,440
place where we want to

00:02:41,840 --> 00:02:45,519
execute workloads for things like

00:02:43,440 --> 00:02:47,440
machine learning sensor fusion

00:02:45,519 --> 00:02:49,760
um it really makes sense to do that kind

00:02:47,440 --> 00:02:51,040
of compute close to our iot devices

00:02:49,760 --> 00:02:53,040
geographically

00:02:51,040 --> 00:02:54,959
because that's where the data is so

00:02:53,040 --> 00:02:59,599
these kinds of workloads are migrating

00:02:54,959 --> 00:03:01,360
out from the central cloud to the edge

00:02:59,599 --> 00:03:03,440
now this creates a conflict and the

00:03:01,360 --> 00:03:05,840
conflict is between the need for those

00:03:03,440 --> 00:03:07,280
workloads to be easily deployed

00:03:05,840 --> 00:03:09,440
and the need for them to be highly

00:03:07,280 --> 00:03:11,680
secure so as we move from the managed

00:03:09,440 --> 00:03:14,720
data center to the edge of the network

00:03:11,680 --> 00:03:16,480
our threat landscape changes um so too

00:03:14,720 --> 00:03:18,239
does the diversity of platforms

00:03:16,480 --> 00:03:20,400
so we have different chip architectures

00:03:18,239 --> 00:03:21,840
prevalent different routes of trust

00:03:20,400 --> 00:03:23,200
different kinds of hardware for key

00:03:21,840 --> 00:03:25,440
storage

00:03:23,200 --> 00:03:27,440
and correspondingly different specs and

00:03:25,440 --> 00:03:28,799
apis that we need to comprehend and

00:03:27,440 --> 00:03:31,200
consume

00:03:28,799 --> 00:03:32,560
and code against to ensure the security

00:03:31,200 --> 00:03:35,840
of our private keys

00:03:32,560 --> 00:03:38,640
and hence of our workloads at the edge

00:03:35,840 --> 00:03:40,959
but for ease of deployment we want to

00:03:38,640 --> 00:03:42,640
retain that fluid cloud native delivery

00:03:40,959 --> 00:03:44,720
experience which means staying

00:03:42,640 --> 00:03:46,319
highly decoupled actually from those

00:03:44,720 --> 00:03:48,319
platform details

00:03:46,319 --> 00:03:50,000
um so we want the best protection for

00:03:48,319 --> 00:03:51,040
our confidential secrets but without

00:03:50,000 --> 00:03:53,360
coding in

00:03:51,040 --> 00:03:54,239
um all of that highly specialized

00:03:53,360 --> 00:03:56,720
knowledge

00:03:54,239 --> 00:03:59,360
um it's a bit of a paradox and it's a

00:03:56,720 --> 00:04:01,920
paradox that parsec aims to solve

00:03:59,360 --> 00:04:03,519
parsec gives us the platform abstraction

00:04:01,920 --> 00:04:06,720
for security

00:04:03,519 --> 00:04:09,519
it brings us this uniform compatibility

00:04:06,720 --> 00:04:10,879
across a diverse world of edge runs on

00:04:09,519 --> 00:04:12,640
any architecture

00:04:10,879 --> 00:04:14,720
can handle the details of hardware

00:04:12,640 --> 00:04:16,560
security whether that's provided by

00:04:14,720 --> 00:04:19,600
trusted platform modules

00:04:16,560 --> 00:04:21,120
hardware security modules trusted

00:04:19,600 --> 00:04:23,440
applications

00:04:21,120 --> 00:04:25,520
or other kinds of routes of trust and it

00:04:23,440 --> 00:04:27,040
provides a common api

00:04:25,520 --> 00:04:29,199
that can be consumed into any

00:04:27,040 --> 00:04:31,919
programming language nicely decoupled

00:04:29,199 --> 00:04:32,880
easily deployed in cloud native

00:04:31,919 --> 00:04:36,160
workloads

00:04:32,880 --> 00:04:36,880
so that's the what let's see how it does

00:04:36,160 --> 00:04:39,840
that

00:04:36,880 --> 00:04:41,840
but here's a layered model of parsec

00:04:39,840 --> 00:04:43,199
platform agnostic security begins with

00:04:41,840 --> 00:04:46,080
some kind of api

00:04:43,199 --> 00:04:48,720
and parsecs api is rooted in platform

00:04:46,080 --> 00:04:51,280
security architecture or psa

00:04:48,720 --> 00:04:52,479
the psa is a holistic security offering

00:04:51,280 --> 00:04:54,639
for iot

00:04:52,479 --> 00:04:57,440
and includes a suite of developer apis

00:04:54,639 --> 00:05:00,000
that are agnostic strongly specified

00:04:57,440 --> 00:05:01,520
algorithmically agile and perfectly

00:05:00,000 --> 00:05:03,520
suited to having different kinds of

00:05:01,520 --> 00:05:05,919
hardware back end

00:05:03,520 --> 00:05:06,880
now the psi crypto api offers functions

00:05:05,919 --> 00:05:09,919
for key storage

00:05:06,880 --> 00:05:11,600
and cryptography but it was designed for

00:05:09,919 --> 00:05:13,600
embedded programming

00:05:11,600 --> 00:05:14,639
in constrained single process

00:05:13,600 --> 00:05:17,039
environments

00:05:14,639 --> 00:05:18,720
so part of parsec's job is to transform

00:05:17,039 --> 00:05:21,120
this core api

00:05:18,720 --> 00:05:22,320
into a cloud-native developer experience

00:05:21,120 --> 00:05:25,600
in this rich

00:05:22,320 --> 00:05:28,479
application class world now it does this

00:05:25,600 --> 00:05:31,360
by creating a service the parsec service

00:05:28,479 --> 00:05:32,800
and this is a user space daemon that can

00:05:31,360 --> 00:05:34,160
be called by multiple client

00:05:32,800 --> 00:05:36,960
applications in a rich

00:05:34,160 --> 00:05:38,960
os environment and those applications

00:05:36,960 --> 00:05:41,520
needn't be written in c

00:05:38,960 --> 00:05:43,199
the parsec service re-expresses that api

00:05:41,520 --> 00:05:45,759
in a language neutral way

00:05:43,199 --> 00:05:46,320
using a wire protocol and parsec builds

00:05:45,759 --> 00:05:49,039
on this

00:05:46,320 --> 00:05:51,120
still further with client libraries

00:05:49,039 --> 00:05:52,960
which understand that wire protocol

00:05:51,120 --> 00:05:55,120
and then prevent a very convenient

00:05:52,960 --> 00:05:58,960
fluent coding surface

00:05:55,120 --> 00:05:58,960
to application developers

00:06:00,000 --> 00:06:04,240
and with that conceptual model in mind

00:06:02,400 --> 00:06:06,800
here's the service architecture here's

00:06:04,240 --> 00:06:08,319
how it looks and imagine that everything

00:06:06,800 --> 00:06:10,160
here is running on an edge node with a

00:06:08,319 --> 00:06:11,840
rich os

00:06:10,160 --> 00:06:14,319
you can see the parsec service there

00:06:11,840 --> 00:06:17,440
which represents the underlying hardware

00:06:14,319 --> 00:06:19,199
acts as a broker for access to it the

00:06:17,440 --> 00:06:19,759
parsec service is organized as a

00:06:19,199 --> 00:06:21,280
front-end

00:06:19,759 --> 00:06:22,880
back-end architecture where the

00:06:21,280 --> 00:06:25,520
front-end is a listener

00:06:22,880 --> 00:06:27,600
that provides a service endpoint and

00:06:25,520 --> 00:06:29,039
implements the ipc wire protocol that i

00:06:27,600 --> 00:06:31,199
talked about

00:06:29,039 --> 00:06:32,960
and this is where we receive api calls

00:06:31,199 --> 00:06:34,319
from clients

00:06:32,960 --> 00:06:36,560
and then in the middle we have some

00:06:34,319 --> 00:06:38,160
access control logic uh where we make

00:06:36,560 --> 00:06:40,080
sure that multiple clients have key

00:06:38,160 --> 00:06:40,960
stores that stay isolated from each

00:06:40,080 --> 00:06:43,440
other

00:06:40,960 --> 00:06:44,960
um and then back end modules which we

00:06:43,440 --> 00:06:47,319
call providers

00:06:44,960 --> 00:06:49,360
um is where we isolate all of that

00:06:47,319 --> 00:06:49,840
platform-specific knowledge so this is

00:06:49,360 --> 00:06:51,599
where

00:06:49,840 --> 00:06:52,960
we would have code that specifically

00:06:51,599 --> 00:06:56,639
knows how to talk to

00:06:52,960 --> 00:06:57,360
say a tpm an hsm or maybe services

00:06:56,639 --> 00:07:01,120
running

00:06:57,360 --> 00:07:02,960
in a t and then on the application side

00:07:01,120 --> 00:07:04,080
of the wire over on the left we have a

00:07:02,960 --> 00:07:06,720
client library

00:07:04,080 --> 00:07:08,479
which talks to the parsec wire protocol

00:07:06,720 --> 00:07:09,199
and then lastly what the application

00:07:08,479 --> 00:07:11,759
sees

00:07:09,199 --> 00:07:13,520
is precisely that convenience developer

00:07:11,759 --> 00:07:15,199
experience that we said we wanted

00:07:13,520 --> 00:07:17,440
so it's built around a standard set of

00:07:15,199 --> 00:07:20,240
psa primitives but then honed

00:07:17,440 --> 00:07:22,560
and refined to provide a fluent and

00:07:20,240 --> 00:07:25,360
simplified experience

00:07:22,560 --> 00:07:26,240
and that is the parsec vision an open

00:07:25,360 --> 00:07:28,080
initiative

00:07:26,240 --> 00:07:30,720
to provide convenient access to the

00:07:28,080 --> 00:07:32,960
secure facilities of any platform

00:07:30,720 --> 00:07:34,319
to multiple client workloads in any

00:07:32,960 --> 00:07:36,080
programming language

00:07:34,319 --> 00:07:38,240
so when we talk about contributing to

00:07:36,080 --> 00:07:42,080
parsec we're talking about contributing

00:07:38,240 --> 00:07:43,599
to this vision and let me at this point

00:07:42,080 --> 00:07:45,280
hand over to my co-presenter so i'll

00:07:43,599 --> 00:07:47,440
hand over to oog now

00:07:45,280 --> 00:07:49,039
he's going to talk a bit about rust

00:07:47,440 --> 00:07:53,039
which we're using extensively

00:07:49,039 --> 00:07:53,039
in the project so go for it

00:07:53,199 --> 00:07:59,039
thanks paul rust is a programming

00:07:56,240 --> 00:08:00,800
language that we choose for per sec

00:07:59,039 --> 00:08:02,400
we thought it was a perfect fit for

00:08:00,800 --> 00:08:03,680
parsec and is also a programming

00:08:02,400 --> 00:08:04,560
language that is really important for

00:08:03,680 --> 00:08:07,520
harm today

00:08:04,560 --> 00:08:08,479
let's see why so today harm is

00:08:07,520 --> 00:08:10,960
everywhere

00:08:08,479 --> 00:08:12,000
from deeply embedded systems running

00:08:10,960 --> 00:08:14,560
bare metal code

00:08:12,000 --> 00:08:15,919
consuming very low resources through

00:08:14,560 --> 00:08:18,800
application processors

00:08:15,919 --> 00:08:20,240
running for example linux even up to

00:08:18,800 --> 00:08:22,560
superior computers arm

00:08:20,240 --> 00:08:23,440
is everywhere and on those different

00:08:22,560 --> 00:08:27,840
domains

00:08:23,440 --> 00:08:27,840
safety and security is important

00:08:28,479 --> 00:08:33,279
a popular figure is the number

00:08:31,520 --> 00:08:34,640
of cves in the linux cell and more

00:08:33,279 --> 00:08:39,519
specifically the type

00:08:34,640 --> 00:08:42,959
of the cvs it was shown that in 2018

00:08:39,519 --> 00:08:44,640
70 of the cvs were due to memory safety

00:08:42,959 --> 00:08:46,720
bugs

00:08:44,640 --> 00:08:48,720
for example some of those like buffer

00:08:46,720 --> 00:08:51,920
overflow

00:08:48,720 --> 00:08:52,399
as new software appears code code basis

00:08:51,920 --> 00:08:54,800
gets

00:08:52,399 --> 00:08:55,760
bigger and bigger software gets more and

00:08:54,800 --> 00:08:58,480
more complex

00:08:55,760 --> 00:09:01,440
and this won't go down especially adding

00:08:58,480 --> 00:09:03,680
more and more parallelism to your code

00:09:01,440 --> 00:09:05,120
but making software safe and secure is a

00:09:03,680 --> 00:09:07,760
really hard problem

00:09:05,120 --> 00:09:09,279
it needs experience one needs to know

00:09:07,760 --> 00:09:11,680
when your code is safe and when

00:09:09,279 --> 00:09:12,320
it is not it needs discipline to put in

00:09:11,680 --> 00:09:15,600
place

00:09:12,320 --> 00:09:17,360
strong practices so that

00:09:15,600 --> 00:09:18,640
reviews are done to make sure that the

00:09:17,360 --> 00:09:21,519
code is safe

00:09:18,640 --> 00:09:22,640
and the appropriate tooling are used and

00:09:21,519 --> 00:09:25,279
money

00:09:22,640 --> 00:09:27,279
to train the engineers for those safety

00:09:25,279 --> 00:09:28,560
problems and also to buy the necessary

00:09:27,279 --> 00:09:30,480
tools

00:09:28,560 --> 00:09:32,480
arm is constantly seeking innovative

00:09:30,480 --> 00:09:35,040
ways to improve those things

00:09:32,480 --> 00:09:36,880
and for this specific domain rust sticks

00:09:35,040 --> 00:09:39,279
a lot of boxes

00:09:36,880 --> 00:09:41,360
it was especially for parsec a very good

00:09:39,279 --> 00:09:43,200
choice as per sec is

00:09:41,360 --> 00:09:45,760
deeply linked to security and that

00:09:43,200 --> 00:09:48,160
safety there is a big problem

00:09:45,760 --> 00:09:50,320
so let's see why russ takes a lot of

00:09:48,160 --> 00:09:53,440
those boxes

00:09:50,320 --> 00:09:56,399
on the next slide yeah thanks

00:09:53,440 --> 00:09:57,519
so for four principle reasons first one

00:09:56,399 --> 00:09:59,760
is safety

00:09:57,519 --> 00:10:01,760
rust has a rich type system with really

00:09:59,760 --> 00:10:04,720
strict and strong types

00:10:01,760 --> 00:10:05,120
it has specific features of ownership

00:10:04,720 --> 00:10:08,560
which

00:10:05,120 --> 00:10:11,120
eliminates at compile time so it's very

00:10:08,560 --> 00:10:14,399
specific because it's at compile time

00:10:11,120 --> 00:10:16,720
most data races due to

00:10:14,399 --> 00:10:17,519
so bugs due to threat safety and memory

00:10:16,720 --> 00:10:19,600
safety

00:10:17,519 --> 00:10:22,399
so all sorts of common cvs are

00:10:19,600 --> 00:10:25,040
eliminated at compile time

00:10:22,399 --> 00:10:26,640
in terms of performance rest offer

00:10:25,040 --> 00:10:30,320
native compilation

00:10:26,640 --> 00:10:32,959
no garbage collection no management time

00:10:30,320 --> 00:10:34,959
low cost abstraction and it can run on

00:10:32,959 --> 00:10:37,760
embedded and bare metal

00:10:34,959 --> 00:10:40,079
as rust has llvm as its back end any

00:10:37,760 --> 00:10:42,880
targets that can return llvm

00:10:40,079 --> 00:10:45,760
can easily be added to rest also it has

00:10:42,880 --> 00:10:48,640
a very nice interoperability with c

00:10:45,760 --> 00:10:49,920
for two main points it is really easy to

00:10:48,640 --> 00:10:52,720
call from rust a c

00:10:49,920 --> 00:10:54,240
api going through the the c4 and

00:10:52,720 --> 00:10:56,240
function interface

00:10:54,240 --> 00:10:58,240
and it is really easy to automatically

00:10:56,240 --> 00:11:02,240
generate rest api

00:10:58,240 --> 00:11:03,920
from a c header file in terms of tooling

00:11:02,240 --> 00:11:05,760
rust is known to have a very steep

00:11:03,920 --> 00:11:06,560
learning curve but the compiler helps

00:11:05,760 --> 00:11:09,360
you

00:11:06,560 --> 00:11:09,920
the message thrown by the compiler are

00:11:09,360 --> 00:11:12,560
friendly

00:11:09,920 --> 00:11:13,279
easy to understand most of the rest

00:11:12,560 --> 00:11:16,000
libraries have

00:11:13,279 --> 00:11:17,200
great documentation it has a very nice

00:11:16,000 --> 00:11:19,600
tool called cargo

00:11:17,200 --> 00:11:22,160
which is an integrated build run and

00:11:19,600 --> 00:11:23,920
test system

00:11:22,160 --> 00:11:25,519
it has an integrated package manager

00:11:23,920 --> 00:11:28,959
where people can upstream

00:11:25,519 --> 00:11:31,200
their rest libraries called crates

00:11:28,959 --> 00:11:32,959
and included in the tool chain that you

00:11:31,200 --> 00:11:34,000
download with rust there is a static

00:11:32,959 --> 00:11:37,120
analysis tool

00:11:34,000 --> 00:11:39,519
and a style formatting tools and lastly

00:11:37,120 --> 00:11:41,440
expressiveness rust is heavily

00:11:39,519 --> 00:11:43,600
influenced by other languages

00:11:41,440 --> 00:11:45,279
some of them from the functional

00:11:43,600 --> 00:11:47,120
programming languages area

00:11:45,279 --> 00:11:48,800
so it has features like iterators

00:11:47,120 --> 00:11:52,560
closures generators

00:11:48,800 --> 00:11:54,839
pattern matching destructoring and more

00:11:52,560 --> 00:11:56,160
that promotes readable and maintainable

00:11:54,839 --> 00:11:58,240
code

00:11:56,160 --> 00:11:59,839
another last point and with all the

00:11:58,240 --> 00:12:00,959
safety performance tooling and

00:11:59,839 --> 00:12:03,440
expensiveness

00:12:00,959 --> 00:12:04,399
it really makes rust the perfect

00:12:03,440 --> 00:12:06,480
language

00:12:04,399 --> 00:12:08,240
for safe open source code because it

00:12:06,480 --> 00:12:10,639
increased the general level

00:12:08,240 --> 00:12:12,959
of code quality than that anybody can

00:12:10,639 --> 00:12:12,959
produce

00:12:13,200 --> 00:12:16,560
so what is i'm doing to help the res

00:12:15,040 --> 00:12:19,279
community um

00:12:16,560 --> 00:12:20,639
if we check on on this slide the main

00:12:19,279 --> 00:12:22,079
thing that army is doing right now is

00:12:20,639 --> 00:12:25,200
helping to make

00:12:22,079 --> 00:12:27,279
ar-64 on linux a tier 1 rust target

00:12:25,200 --> 00:12:29,120
that is the highest level of support for

00:12:27,279 --> 00:12:32,000
a rust target

00:12:29,120 --> 00:12:34,560
rfc is open and you can check it out for

00:12:32,000 --> 00:12:36,320
for details

00:12:34,560 --> 00:12:38,639
arm is also having close collaboration

00:12:36,320 --> 00:12:40,240
with the rust core team so on this on

00:12:38,639 --> 00:12:43,279
the topic of having the

00:12:40,240 --> 00:12:45,120
ar-64 linux target

00:12:43,279 --> 00:12:46,560
there is a creation of a ci

00:12:45,120 --> 00:12:49,760
infrastructure that is running the russ

00:12:46,560 --> 00:12:51,920
compiler test directly on ar-64 silicon

00:12:49,760 --> 00:12:53,920
instead for example of being simulated

00:12:51,920 --> 00:12:56,160
on x86

00:12:53,920 --> 00:12:57,440
and specific tastes are being maintained

00:12:56,160 --> 00:12:59,040
and improving

00:12:57,440 --> 00:13:00,880
to improve the support of rust on ear

00:12:59,040 --> 00:13:02,720
64.

00:13:00,880 --> 00:13:04,240
we're also working on extending rust to

00:13:02,720 --> 00:13:07,600
use ar-64 advanced

00:13:04,240 --> 00:13:09,360
neon and scmd interesting and also to

00:13:07,600 --> 00:13:13,040
towards the support for on the item

00:13:09,360 --> 00:13:13,040
just done features in rest

00:13:13,120 --> 00:13:17,680
in parsec specifically we are helping

00:13:16,079 --> 00:13:19,200
the res community by publishing helpful

00:13:17,680 --> 00:13:20,880
creates and contributing

00:13:19,200 --> 00:13:22,800
so for example we published rust

00:13:20,880 --> 00:13:26,000
abstraction for

00:13:22,800 --> 00:13:28,160
a tpm api so to to communicate with the

00:13:26,000 --> 00:13:29,120
tpm with rest and for pac cryptographic

00:13:28,160 --> 00:13:32,639
apis

00:13:29,120 --> 00:13:35,839
we also contributed to pkcs11 crates

00:13:32,639 --> 00:13:36,959
crates providing asn 1 types and also

00:13:35,839 --> 00:13:38,720
binding

00:13:36,959 --> 00:13:40,639
which is a tool i'll talked about that

00:13:38,720 --> 00:13:42,959
automatically generates the the rest api

00:13:40,639 --> 00:13:44,959
from the cd file

00:13:42,959 --> 00:13:46,560
so really think that we really thought

00:13:44,959 --> 00:13:48,160
that that trust was was the perfect

00:13:46,560 --> 00:13:49,680
choice we're really happy of

00:13:48,160 --> 00:13:51,440
working with it so far and really look

00:13:49,680 --> 00:13:53,760
forward of contributing more

00:13:51,440 --> 00:13:57,120
with the rest community i'll let paul

00:13:53,760 --> 00:13:57,120
continue with the next slide

00:13:57,360 --> 00:14:00,560
thanks hugh and i'll hand back to you in

00:13:59,519 --> 00:14:02,720
just a second

00:14:00,560 --> 00:14:05,120
where he's going to talk about some

00:14:02,720 --> 00:14:06,240
contribution opportunities in parsec

00:14:05,120 --> 00:14:08,000
but first of all i just want to

00:14:06,240 --> 00:14:09,839
emphasize as a kind of prelude to that

00:14:08,000 --> 00:14:10,560
but parsec is really poised for growth

00:14:09,839 --> 00:14:13,040
right now

00:14:10,560 --> 00:14:14,560
it's at an ideal stage in its life cycle

00:14:13,040 --> 00:14:16,560
where there are opportunities not just

00:14:14,560 --> 00:14:17,600
to get involved but to influence future

00:14:16,560 --> 00:14:20,240
direction

00:14:17,600 --> 00:14:22,880
uh form special interest groups to take

00:14:20,240 --> 00:14:25,199
ownership of key pieces of that vision

00:14:22,880 --> 00:14:26,800
um and earlier this year we got accepted

00:14:25,199 --> 00:14:28,639
into the sandbox stage

00:14:26,800 --> 00:14:30,480
of cloud native compute foundation which

00:14:28,639 --> 00:14:32,320
was a great step forward

00:14:30,480 --> 00:14:34,399
so the project's fully public it follows

00:14:32,320 --> 00:14:36,880
the cncf's ip policy

00:14:34,399 --> 00:14:37,920
and its code of conduct um and it's

00:14:36,880 --> 00:14:40,880
starting to get used

00:14:37,920 --> 00:14:42,880
too so arms pelion device manager client

00:14:40,880 --> 00:14:44,320
for instance now has got an option to

00:14:42,880 --> 00:14:46,480
use parsec

00:14:44,320 --> 00:14:49,199
to manage the device identity key pair

00:14:46,480 --> 00:14:51,600
for registering to peleon cloud services

00:14:49,199 --> 00:14:53,920
and we're also working with red hat on a

00:14:51,600 --> 00:14:56,079
demo that's based on integrating uh dbus

00:14:53,920 --> 00:14:57,360
and network manager with parsec

00:14:56,079 --> 00:14:59,360
and that's something you can look out

00:14:57,360 --> 00:15:01,519
for at arm dev summit

00:14:59,360 --> 00:15:02,480
next month and with that i'm going to

00:15:01,519 --> 00:15:04,720
hand back to

00:15:02,480 --> 00:15:04,720
you

00:15:06,240 --> 00:15:12,560
thanks so in terms of

00:15:09,360 --> 00:15:14,000
contribution pathways we selected four

00:15:12,560 --> 00:15:15,920
specific areas

00:15:14,000 --> 00:15:18,240
where it would be possible for anyone to

00:15:15,920 --> 00:15:20,240
contribute but more than that

00:15:18,240 --> 00:15:22,959
to own the specific piece and help us

00:15:20,240 --> 00:15:24,880
maintaining them long term

00:15:22,959 --> 00:15:26,560
the first one is creating new hardware

00:15:24,880 --> 00:15:28,560
firmware integration

00:15:26,560 --> 00:15:30,000
so the way that parsec is currently

00:15:28,560 --> 00:15:32,320
communicating with the

00:15:30,000 --> 00:15:34,160
different crypto modules that we support

00:15:32,320 --> 00:15:36,399
is through provider modules

00:15:34,160 --> 00:15:37,600
so we currently have support for the tpm

00:15:36,399 --> 00:15:39,040
for pkcs 11

00:15:37,600 --> 00:15:41,120
and for the embed crypto software

00:15:39,040 --> 00:15:42,959
library but we would

00:15:41,120 --> 00:15:44,160
really like to add more support for

00:15:42,959 --> 00:15:47,440
other crypto modules

00:15:44,160 --> 00:15:51,600
such as custom secure elements cloud

00:15:47,440 --> 00:15:53,600
hsm or mva trusted world applications

00:15:51,600 --> 00:15:55,440
and for those specific modules we would

00:15:53,600 --> 00:15:58,000
welcome anyone to

00:15:55,440 --> 00:15:58,959
discuss with with them with us about how

00:15:58,000 --> 00:16:00,720
it will be possible to

00:15:58,959 --> 00:16:02,880
add them with the passive code base that

00:16:00,720 --> 00:16:06,160
would allow platforms having

00:16:02,880 --> 00:16:09,199
those modules to be able to run pasek

00:16:06,160 --> 00:16:11,360
the second contribution pathway

00:16:09,199 --> 00:16:14,399
is about addressing functional gap to

00:16:11,360 --> 00:16:17,680
enable use cases

00:16:14,399 --> 00:16:19,600
so when pasqua started the first use

00:16:17,680 --> 00:16:22,240
case that was implemented among

00:16:19,600 --> 00:16:25,440
the multiple providers that we support

00:16:22,240 --> 00:16:28,800
is for asymmetric signing and verifying

00:16:25,440 --> 00:16:32,800
where a key pair can be generated

00:16:28,800 --> 00:16:35,199
inside a tpm or inside hsm

00:16:32,800 --> 00:16:37,120
it can be used to sign a buffer and the

00:16:35,199 --> 00:16:41,199
publicly can be exported

00:16:37,120 --> 00:16:44,959
for someone else to verify the signature

00:16:41,199 --> 00:16:45,920
this was the first use case that pasek

00:16:44,959 --> 00:16:48,399
would be used for

00:16:45,920 --> 00:16:50,320
and we implemented those things first

00:16:48,399 --> 00:16:51,519
and mostly for asymmetric signing and

00:16:50,320 --> 00:16:54,480
waffling it was for

00:16:51,519 --> 00:16:56,079
the rsc algorithm but we would like to

00:16:54,480 --> 00:16:59,519
expand our coverage

00:16:56,079 --> 00:17:02,839
and ultimately to have almost

00:16:59,519 --> 00:17:05,439
all of the pac crypto operation

00:17:02,839 --> 00:17:06,959
implemented so that is

00:17:05,439 --> 00:17:08,720
for the one that we currently support

00:17:06,959 --> 00:17:12,799
adding more key types

00:17:08,720 --> 00:17:14,959
so for example as well as supporting

00:17:12,799 --> 00:17:16,480
rsa keys also supporting elliptic curve

00:17:14,959 --> 00:17:18,079
keys

00:17:16,480 --> 00:17:21,360
and also adding more operations for

00:17:18,079 --> 00:17:24,000
example supporting the mac operations

00:17:21,360 --> 00:17:26,160
and those for all of our providers so

00:17:24,000 --> 00:17:27,919
those are specific items

00:17:26,160 --> 00:17:29,919
which would be really easy for anyone to

00:17:27,919 --> 00:17:32,960
contribute and help us improving the

00:17:29,919 --> 00:17:34,720
the coverage the third

00:17:32,960 --> 00:17:36,559
contribution by the way is on the client

00:17:34,720 --> 00:17:40,160
side

00:17:36,559 --> 00:17:42,080
parsec is a pretty much a rest shop so

00:17:40,160 --> 00:17:43,440
when we started parsec the first client

00:17:42,080 --> 00:17:47,440
that we did was

00:17:43,440 --> 00:17:49,440
naturally the rest it allows you to

00:17:47,440 --> 00:17:51,039
to access all of the parsec operation

00:17:49,440 --> 00:17:53,360
with rust

00:17:51,039 --> 00:17:54,320
but without this great developer

00:17:53,360 --> 00:17:57,760
experience that were

00:17:54,320 --> 00:18:01,520
that was stolen without this idiomatic

00:17:57,760 --> 00:18:02,880
rust usage and similarly for

00:18:01,520 --> 00:18:05,120
all of the other clients that we would

00:18:02,880 --> 00:18:07,200
like to add in pasek a gowan c plus plus

00:18:05,120 --> 00:18:10,000
python or java clients

00:18:07,200 --> 00:18:11,520
we would like to have people that know

00:18:10,000 --> 00:18:13,520
this language and that know the the

00:18:11,520 --> 00:18:16,000
cryptographic library in this language

00:18:13,520 --> 00:18:16,960
in order to help us to build very nice

00:18:16,000 --> 00:18:19,840
and idiomatic

00:18:16,960 --> 00:18:22,080
client libraries in those languages so

00:18:19,840 --> 00:18:24,480
that is both for people that

00:18:22,080 --> 00:18:25,919
would like to build from scratch those

00:18:24,480 --> 00:18:28,880
libraries

00:18:25,919 --> 00:18:30,400
and for people that know specific famous

00:18:28,880 --> 00:18:33,440
cryptographic libraries

00:18:30,400 --> 00:18:35,440
in those language to perhaps build a

00:18:33,440 --> 00:18:36,320
parsec backend to this library so that

00:18:35,440 --> 00:18:39,039
it would be

00:18:36,320 --> 00:18:40,960
possible for a crypto library that was

00:18:39,039 --> 00:18:43,679
software only before

00:18:40,960 --> 00:18:45,039
to use parsec in order to for example

00:18:43,679 --> 00:18:49,200
store rsa key

00:18:45,039 --> 00:18:52,160
in in a tpm all that using barseq

00:18:49,200 --> 00:18:53,600
lastly the final contribution pathway

00:18:52,160 --> 00:18:57,440
we're looking at

00:18:53,600 --> 00:19:00,240
is about expanding deployment or reasons

00:18:57,440 --> 00:19:02,080
and first in terms of environment

00:19:00,240 --> 00:19:05,120
currently

00:19:02,080 --> 00:19:07,360
parsec and its clients are working

00:19:05,120 --> 00:19:10,320
on the same operating system on the same

00:19:07,360 --> 00:19:12,720
host where parsec clients are different

00:19:10,320 --> 00:19:14,400
unix processes community communicating

00:19:12,720 --> 00:19:17,760
to the service

00:19:14,400 --> 00:19:19,520
we would like to have more environments

00:19:17,760 --> 00:19:21,600
for them to be virtual machines or

00:19:19,520 --> 00:19:23,600
containers where

00:19:21,600 --> 00:19:24,960
different clients could be in different

00:19:23,600 --> 00:19:25,600
virtual machines or in different

00:19:24,960 --> 00:19:27,919
containers

00:19:25,600 --> 00:19:29,039
that would need some some work and some

00:19:27,919 --> 00:19:32,080
more design

00:19:29,039 --> 00:19:33,440
to make it work with the parsec service

00:19:32,080 --> 00:19:36,080
in terms of operating system we are

00:19:33,440 --> 00:19:38,320
currently only supporting

00:19:36,080 --> 00:19:39,520
linux but we like to add the support for

00:19:38,320 --> 00:19:42,720
windows and other

00:19:39,520 --> 00:19:45,200
real-time operating systems for

00:19:42,720 --> 00:19:45,760
orchestration and that has to do mainly

00:19:45,200 --> 00:19:48,880
with

00:19:45,760 --> 00:19:50,080
the identity provider pattern so the way

00:19:48,880 --> 00:19:54,320
that

00:19:50,080 --> 00:19:57,120
parsec can uh partitionate its keystore

00:19:54,320 --> 00:19:59,280
so that each clients can have access to

00:19:57,120 --> 00:20:02,799
only their keys and all the other ones

00:19:59,280 --> 00:20:05,520
is by giving to each client

00:20:02,799 --> 00:20:09,120
a specific identity a unique identity

00:20:05,520 --> 00:20:11,039
that is trusted by the perfect service

00:20:09,120 --> 00:20:12,159
you know in order to make this work for

00:20:11,039 --> 00:20:13,520
the different i've

00:20:12,159 --> 00:20:14,960
environments that you want to support so

00:20:13,520 --> 00:20:15,919
for different containers or different

00:20:14,960 --> 00:20:19,440
virtual machine

00:20:15,919 --> 00:20:21,840
there is some work needed in terms of

00:20:19,440 --> 00:20:22,880
how to set a specific identity for those

00:20:21,840 --> 00:20:26,000
different workload

00:20:22,880 --> 00:20:28,000
and how to manage and verify it and

00:20:26,000 --> 00:20:31,360
lastly the ecosystem

00:20:28,000 --> 00:20:34,960
the ultimate goal of parsec is

00:20:31,360 --> 00:20:37,679
is to be deployed in in the

00:20:34,960 --> 00:20:39,440
in the in the in all location possible

00:20:37,679 --> 00:20:42,240
so we like to identify

00:20:39,440 --> 00:20:43,280
use cases and integration points uh

00:20:42,240 --> 00:20:45,280
where we

00:20:43,280 --> 00:20:48,320
that we need to identify to to enable

00:20:45,280 --> 00:20:51,760
parsec on them

00:20:48,320 --> 00:20:55,039
so that's all for for the all possible

00:20:51,760 --> 00:20:56,799
contribution uh pathways

00:20:55,039 --> 00:20:58,880
if you're interested in in one of them

00:20:56,799 --> 00:21:01,120
and or you would like to know more about

00:20:58,880 --> 00:21:03,120
about parsec if you like to join the

00:21:01,120 --> 00:21:06,080
parsley community

00:21:03,120 --> 00:21:07,440
you can access all of our code of on all

00:21:06,080 --> 00:21:10,240
of our repositories at the

00:21:07,440 --> 00:21:10,640
parallax second organization which link

00:21:10,240 --> 00:21:13,120
is

00:21:10,640 --> 00:21:14,640
is written here you can also access our

00:21:13,120 --> 00:21:18,559
technical documentation

00:21:14,640 --> 00:21:21,120
on the pasek book to talk to us directly

00:21:18,559 --> 00:21:23,280
we are on the parsec slack channel on

00:21:21,120 --> 00:21:25,360
the docker community slack workspace

00:21:23,280 --> 00:21:26,720
and we are also holding meetings every

00:21:25,360 --> 00:21:30,240
other tuesday

00:21:26,720 --> 00:21:32,559
at 4 30 pm uk when you can

00:21:30,240 --> 00:21:33,440
directly talk to us or if you have a

00:21:32,559 --> 00:21:34,880
specific

00:21:33,440 --> 00:21:37,039
topic that you would like to address

00:21:34,880 --> 00:21:39,520
more in depth you can also come and

00:21:37,039 --> 00:21:41,360
we can discuss that thanks a lot for

00:21:39,520 --> 00:21:42,159
listening to me i hope i i got you

00:21:41,360 --> 00:21:44,799
interested and

00:21:42,159 --> 00:21:45,600
i'll give it back to paul to conclude

00:21:44,799 --> 00:21:48,000
fantastic

00:21:45,600 --> 00:21:49,039
um thanks hugh thanks everyone uh for

00:21:48,000 --> 00:21:51,360
listening so that's the end of our

00:21:49,039 --> 00:21:52,159
session and i hope we've succeeded uh in

00:21:51,360 --> 00:21:54,480
giving you

00:21:52,159 --> 00:21:55,280
a flavor of what parsec is what the

00:21:54,480 --> 00:21:58,080
contribution

00:21:55,280 --> 00:21:59,520
opportunities are and as oog says if

00:21:58,080 --> 00:22:01,760
you're interested you want to take it

00:21:59,520 --> 00:22:03,919
further do please come and join us

00:22:01,760 --> 00:22:05,600
on that slack or in our tuesday meetings

00:22:03,919 --> 00:22:07,360
we're going to make you very welcome

00:22:05,600 --> 00:22:09,600
um if you have immediate questions

00:22:07,360 --> 00:22:10,960
burning in your mind right now

00:22:09,600 --> 00:22:13,360
and you want to come and chat with you

00:22:10,960 --> 00:22:15,200
and me during the lenara conference

00:22:13,360 --> 00:22:20,080
there's also a channel

00:22:15,200 --> 00:22:22,080
on linaro connect slack lvc20-116

00:22:20,080 --> 00:22:23,440
we'll be hanging out there you can come

00:22:22,080 --> 00:22:25,840
and chat with us while the conference is

00:22:23,440 --> 00:22:26,960
open and we'd love to hear from you

00:22:25,840 --> 00:22:29,120
thanks for having us

00:22:26,960 --> 00:22:30,960
thank you christine and the organizers

00:22:29,120 --> 00:22:32,640
thanks to everyone for listening

00:22:30,960 --> 00:22:36,720
have a great day and a great rest of the

00:22:32,640 --> 00:22:36,720

YouTube URL: https://www.youtube.com/watch?v=GqiISmXO_78


