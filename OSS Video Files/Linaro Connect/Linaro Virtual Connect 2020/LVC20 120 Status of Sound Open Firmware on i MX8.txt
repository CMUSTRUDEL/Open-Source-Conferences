Title: LVC20 120 Status of Sound Open Firmware on i MX8
Publication date: 2020-10-09
Playlist: Linaro Virtual Connect 2020
Description: 
	Sound Open Firmware is an open source audio DSP firmware and SDK that provides audio firmware infrastructure and development tools for developers and software integrators that are interested in audio or signal processing on DSPs.

This presentation is about the status of enabling Sound Open Firmware on i.MX8 boards. This includes code for Application Processor which usually runs Linux kernel and code for DSP core which runs the firmware. First platform using Sound Open Firmware on ARM is NXP's i.MX8QXP.

For the presentation see: https://static.linaro.org/connect/lvc20/presentations/LVC20-120-0.pdf
Captions: 
	00:00:00,160 --> 00:00:03,120
hello everyone my name is daniel i work

00:00:02,879 --> 00:00:05,919
at

00:00:03,120 --> 00:00:05,919
nxp in

00:00:06,640 --> 00:00:13,120
on idatemx8 platforms enabling

00:00:09,760 --> 00:00:15,599
audio this presentation is about

00:00:13,120 --> 00:00:17,920
status of sound open firmware project on

00:00:15,599 --> 00:00:20,000
idodemx platforms

00:00:17,920 --> 00:00:20,960
and besides presenting the status one of

00:00:20,000 --> 00:00:24,320
them the

00:00:20,960 --> 00:00:28,080
goal of this presentation is to attract

00:00:24,320 --> 00:00:31,840
other arm board

00:00:28,080 --> 00:00:35,520
vendors to enable their uh dsp using an

00:00:31,840 --> 00:00:37,680
open source framework uh and um

00:00:35,520 --> 00:00:40,320
i think sound firmware would be a very

00:00:37,680 --> 00:00:40,320
good choice

00:00:40,480 --> 00:00:46,320
in this presentation i will um i will go

00:00:44,320 --> 00:00:48,000
on a short overview over the main

00:00:46,320 --> 00:00:50,320
component status

00:00:48,000 --> 00:00:52,160
and i will start with the tool chain

00:00:50,320 --> 00:00:55,600
then the linux driver part

00:00:52,160 --> 00:00:57,039
then the firmware part and the audio use

00:00:55,600 --> 00:00:59,199
cases enabled via

00:00:57,039 --> 00:01:01,680
audio pipelines and then i will talk a

00:00:59,199 --> 00:01:06,000
little bit about our effort on uh

00:01:01,680 --> 00:01:10,320
enhancing the the ci and

00:01:06,000 --> 00:01:13,280
for this we have used a qmu emulator

00:01:10,320 --> 00:01:13,920
but first uh let me tell you some things

00:01:13,280 --> 00:01:17,040
about

00:01:13,920 --> 00:01:20,479
sound open firmware uh and i will go

00:01:17,040 --> 00:01:22,560
through a little bit of uh the web pages

00:01:20,479 --> 00:01:24,439
uh the landing page for the sound open

00:01:22,560 --> 00:01:27,200
firmware is this one

00:01:24,439 --> 00:01:30,400
softproject.org the project was uh

00:01:27,200 --> 00:01:32,960
initially started by intel and the

00:01:30,400 --> 00:01:33,759
open source um and and the sound open

00:01:32,960 --> 00:01:36,079
firmware is a

00:01:33,759 --> 00:01:37,520
open source audio dsp firmware

00:01:36,079 --> 00:01:39,759
infrastructure

00:01:37,520 --> 00:01:41,280
this means everything from the firmware

00:01:39,759 --> 00:01:44,720
to the to the host

00:01:41,280 --> 00:01:47,920
code to the to the tooling

00:01:44,720 --> 00:01:48,560
and uh the main parts the core elements

00:01:47,920 --> 00:01:51,680
are here

00:01:48,560 --> 00:01:53,840
it's open source this is the one one key

00:01:51,680 --> 00:01:55,680
point

00:01:53,840 --> 00:01:57,680
it's a little bit unusual for the

00:01:55,680 --> 00:02:00,719
firmwares to be open source and

00:01:57,680 --> 00:02:02,320
intel had made a goal from uh open

00:02:00,719 --> 00:02:06,880
sourcing firmwares and

00:02:02,320 --> 00:02:11,200
the audio firmware is uh is one of them

00:02:06,880 --> 00:02:14,879
then it's modular uh this means that

00:02:11,200 --> 00:02:18,560
uh the goal of the firmware is to be uh

00:02:14,879 --> 00:02:21,200
easily portable on host platforms so far

00:02:18,560 --> 00:02:22,000
uh it is ported on intel platforms it

00:02:21,200 --> 00:02:25,200
x86

00:02:22,000 --> 00:02:27,440
architecture and on uh arm 64

00:02:25,200 --> 00:02:30,400
architecture that are uh that can be

00:02:27,440 --> 00:02:33,599
found on idatemx platforms

00:02:30,400 --> 00:02:35,120
um then it's platform and not agnostic

00:02:33,599 --> 00:02:37,840
the code is written

00:02:35,120 --> 00:02:39,840
with the idea in mind that it could be

00:02:37,840 --> 00:02:42,000
easily ported to another dsp

00:02:39,840 --> 00:02:44,480
architecture

00:02:42,000 --> 00:02:46,400
so far the dsp the dsp architecture

00:02:44,480 --> 00:02:50,080
comes from 10 silica

00:02:46,400 --> 00:02:54,319
and uh for both integration on intel and

00:02:50,080 --> 00:02:56,640
ida mx8 the architecture is hi-fi

00:02:54,319 --> 00:02:59,760
different different families from the

00:02:56,640 --> 00:02:59,760
hi-fi dsps

00:03:00,480 --> 00:03:08,000
now going to supported idotmx platforms

00:03:04,560 --> 00:03:11,040
um some some of you might be familiar

00:03:08,000 --> 00:03:14,159
with the idotmix8

00:03:11,040 --> 00:03:17,599
platforms we have the qm the qxp and the

00:03:14,159 --> 00:03:20,879
8mp hardware platforms which are out

00:03:17,599 --> 00:03:21,680
and all of them have a extensor hi-54

00:03:20,879 --> 00:03:24,959
processor

00:03:21,680 --> 00:03:25,680
the qm and qxp platforms uh are very

00:03:24,959 --> 00:03:29,360
similar

00:03:25,680 --> 00:03:31,680
in regard with the dsp integration so uh

00:03:29,360 --> 00:03:33,680
even the code for both firmware and the

00:03:31,680 --> 00:03:37,280
linux driver is in the

00:03:33,680 --> 00:03:40,560
it's grouped to to map this uh

00:03:37,280 --> 00:03:41,840
this closeness of of platforms uh hmp is

00:03:40,560 --> 00:03:45,280
a little bit different and

00:03:41,840 --> 00:03:48,799
and has its own uh its own

00:03:45,280 --> 00:03:52,239
source files also we have enabled

00:03:48,799 --> 00:03:55,840
the dsp emulation in qmu

00:03:52,239 --> 00:03:59,040
for all the above platforms

00:03:55,840 --> 00:04:03,120
only for the only for the dsp side

00:03:59,040 --> 00:04:05,519
uh for the uh host side uh idatemx8

00:04:03,120 --> 00:04:09,120
platforms do not have yet

00:04:05,519 --> 00:04:12,319
uh qmo support but we plan this

00:04:09,120 --> 00:04:14,319
uh in the future now let's talk

00:04:12,319 --> 00:04:16,639
a bit a little bit about the tool chain

00:04:14,319 --> 00:04:19,840
support uh well the first thing

00:04:16,639 --> 00:04:22,160
that uh you must do when you start uh

00:04:19,840 --> 00:04:22,960
porting sof on a new platform you need

00:04:22,160 --> 00:04:25,040
to enable

00:04:22,960 --> 00:04:26,400
uh and you need to have the tool chain

00:04:25,040 --> 00:04:28,400
tool chain ready

00:04:26,400 --> 00:04:30,000
and there are two versions here you can

00:04:28,400 --> 00:04:32,160
have you can build

00:04:30,000 --> 00:04:34,080
your open source tool chain use using

00:04:32,160 --> 00:04:36,800
crosstool new generation

00:04:34,080 --> 00:04:37,280
it already has extensive support so for

00:04:36,800 --> 00:04:40,880
us

00:04:37,280 --> 00:04:43,360
uh in enabling this tool chain only uh

00:04:40,880 --> 00:04:44,080
mean that we need to write some overlay

00:04:43,360 --> 00:04:46,800
files

00:04:44,080 --> 00:04:48,560
that describes the uh the dsp

00:04:46,800 --> 00:04:52,400
configuration

00:04:48,560 --> 00:04:55,440
this is already done it's on github

00:04:52,400 --> 00:04:57,759
there is another option that you may use

00:04:55,440 --> 00:04:59,840
the proprietary tool chain

00:04:57,759 --> 00:05:01,199
but for this you need to talk with

00:04:59,840 --> 00:05:04,560
tensile guy and pay

00:05:01,199 --> 00:05:07,520
uh the license for

00:05:04,560 --> 00:05:08,800
for it but for just enabling and

00:05:07,520 --> 00:05:12,800
evaluating the board

00:05:08,800 --> 00:05:12,800
the open source tool chain is enough

00:05:13,120 --> 00:05:20,320
then next let's talk about the

00:05:17,120 --> 00:05:22,560
sof linux driver and see what

00:05:20,320 --> 00:05:24,960
what changes are already accepted in the

00:05:22,560 --> 00:05:27,039
upstream kernel on the right side you

00:05:24,960 --> 00:05:30,400
can see

00:05:27,039 --> 00:05:33,440
the layers the software layers

00:05:30,400 --> 00:05:37,039
from alsa from

00:05:33,440 --> 00:05:39,440
audio subsystem and the linux kernel and

00:05:37,039 --> 00:05:41,600
when we try adding support for idolatry

00:05:39,440 --> 00:05:44,080
we notice that some common parts can

00:05:41,600 --> 00:05:46,639
help us some common parts need some

00:05:44,080 --> 00:05:51,199
small modification in order to allow

00:05:46,639 --> 00:05:53,440
uh to be run on idotmx8 and some parts

00:05:51,199 --> 00:05:55,199
were needed to be written from scratch

00:05:53,440 --> 00:05:55,919
so we'll start with the first layer this

00:05:55,199 --> 00:05:58,720
is the

00:05:55,919 --> 00:05:59,520
uh the machine driver we reused an

00:05:58,720 --> 00:06:02,720
existing

00:05:59,520 --> 00:06:04,319
uh generic driver with just small

00:06:02,720 --> 00:06:07,840
modification

00:06:04,319 --> 00:06:10,960
this driver is very um very useful and

00:06:07,840 --> 00:06:12,560
simple for beginning but

00:06:10,960 --> 00:06:15,039
maybe in the future if power

00:06:12,560 --> 00:06:17,530
configuration become more complex or

00:06:15,039 --> 00:06:19,280
if we need more features um

00:06:17,530 --> 00:06:22,240
[Music]

00:06:19,280 --> 00:06:23,759
first option is to adapt the simple card

00:06:22,240 --> 00:06:27,520
driver for that or

00:06:23,759 --> 00:06:30,639
just write our own machine driver

00:06:27,520 --> 00:06:33,840
the next part where we did some changes

00:06:30,639 --> 00:06:36,960
in is in the topology part

00:06:33,840 --> 00:06:40,080
where we only had to add support for

00:06:36,960 --> 00:06:40,560
uh nxp digital audio interfaces they are

00:06:40,080 --> 00:06:44,639
named

00:06:40,560 --> 00:06:45,199
sci and esai it really doesn't matter

00:06:44,639 --> 00:06:48,639
right

00:06:45,199 --> 00:06:52,639
now the naming but the most of our work

00:06:48,639 --> 00:06:55,280
was done here in the the lower layer

00:06:52,639 --> 00:06:56,240
where we need to enable the dsp platform

00:06:55,280 --> 00:06:59,280
driver

00:06:56,240 --> 00:07:02,720
here we started with the core changes

00:06:59,280 --> 00:07:06,240
where we need to adapt the sof

00:07:02,720 --> 00:07:10,080
layer which was intel centric and um

00:07:06,240 --> 00:07:12,160
it was oriented to acpi or pci

00:07:10,080 --> 00:07:14,000
the things that intel used and we need

00:07:12,160 --> 00:07:17,199
to have that adapt that to

00:07:14,000 --> 00:07:19,199
to device three uh this um

00:07:17,199 --> 00:07:21,599
this is already done i mean everything

00:07:19,199 --> 00:07:24,080
on this slide is already upstream

00:07:21,599 --> 00:07:25,360
in the linux kernel then next we need to

00:07:24,080 --> 00:07:29,120
do the

00:07:25,360 --> 00:07:31,520
ipc communication driver uh nxp

00:07:29,120 --> 00:07:33,440
has a special way of communicating

00:07:31,520 --> 00:07:34,000
between different cores so between the

00:07:33,440 --> 00:07:37,120
arm

00:07:34,000 --> 00:07:39,039
processor and uh dsp processor so we've

00:07:37,120 --> 00:07:42,000
written a driver which implemented

00:07:39,039 --> 00:07:43,599
the communication protocol uh then the

00:07:42,000 --> 00:07:47,039
next thing was to implement

00:07:43,599 --> 00:07:48,080
and to add uh similarly with how

00:07:47,039 --> 00:07:50,720
intelligent

00:07:48,080 --> 00:07:53,120
acpi platform driver or pci platform

00:07:50,720 --> 00:07:55,520
driver we added our device 3 platform

00:07:53,120 --> 00:07:55,520
driver

00:07:55,759 --> 00:08:00,000
for for contributors working on other

00:07:58,720 --> 00:08:03,440
platforms i think this

00:08:00,000 --> 00:08:06,560
will be um the place where they will

00:08:03,440 --> 00:08:08,479
need to uh to write their code for their

00:08:06,560 --> 00:08:13,120
arm 64 platforms

00:08:08,479 --> 00:08:15,919
and then uh lastly was to add the idotmx

00:08:13,120 --> 00:08:17,360
specific drivers for each architecture

00:08:15,919 --> 00:08:20,080
for each platform

00:08:17,360 --> 00:08:22,400
where um these drivers were taking care

00:08:20,080 --> 00:08:24,319
of allocating order resources

00:08:22,400 --> 00:08:27,280
uh in order for the arm core to

00:08:24,319 --> 00:08:29,360
communicate with the dsp

00:08:27,280 --> 00:08:30,800
so everything from here is already

00:08:29,360 --> 00:08:33,279
accepted

00:08:30,800 --> 00:08:35,120
and we will see in the next slide what

00:08:33,279 --> 00:08:38,320
what's the work in progress

00:08:35,120 --> 00:08:38,880
so for us in order to use the upstream

00:08:38,320 --> 00:08:43,519
kernel

00:08:38,880 --> 00:08:46,959
and just have the audio scenarios

00:08:43,519 --> 00:08:49,680
working i think the most important part

00:08:46,959 --> 00:08:53,279
and the next on our priority list is to

00:08:49,680 --> 00:08:57,279
add the device 3 file for the platforms

00:08:53,279 --> 00:09:00,720
which enable the uh the audio sound card

00:08:57,279 --> 00:09:03,600
we left this uh at the end

00:09:00,720 --> 00:09:05,200
because uh getting the correct interface

00:09:03,600 --> 00:09:08,320
is very very

00:09:05,200 --> 00:09:11,839
uh difficult and this

00:09:08,320 --> 00:09:15,519
because the device three are avi

00:09:11,839 --> 00:09:18,720
it will be very hard to do modifications

00:09:15,519 --> 00:09:22,320
or you will need to

00:09:18,720 --> 00:09:24,000
always maintain compatibility

00:09:22,320 --> 00:09:25,600
between these changes that you've done

00:09:24,000 --> 00:09:27,600
now and the next changes to the

00:09:25,600 --> 00:09:29,920
to the device three so we left this uh

00:09:27,600 --> 00:09:32,560
uh for the last part

00:09:29,920 --> 00:09:33,680
in order to uh make sure that we get the

00:09:32,560 --> 00:09:36,320
design correct

00:09:33,680 --> 00:09:37,600
we have sent patches for a review for

00:09:36,320 --> 00:09:39,600
the device three file

00:09:37,600 --> 00:09:42,160
we got some feedback and we were

00:09:39,600 --> 00:09:45,200
adapting the feedback now for

00:09:42,160 --> 00:09:47,200
for having this in another feature that

00:09:45,200 --> 00:09:51,839
we are working now is the power

00:09:47,200 --> 00:09:54,560
management part because

00:09:51,839 --> 00:09:55,600
we want to make our uh software running

00:09:54,560 --> 00:09:58,720
on itemx

00:09:55,600 --> 00:10:01,760
8 as efficient as possible then

00:09:58,720 --> 00:10:03,360
by the end of this year a major goal for

00:10:01,760 --> 00:10:06,000
us is to implement the compressed

00:10:03,360 --> 00:10:09,519
interface so that you will be able to

00:10:06,000 --> 00:10:11,360
for example render mp3 files to the dsp

00:10:09,519 --> 00:10:12,160
and the dsp will do the decoding and

00:10:11,360 --> 00:10:15,200
render the

00:10:12,160 --> 00:10:16,959
the pcm decoded frames to a codec so

00:10:15,200 --> 00:10:18,320
this will this is a very important

00:10:16,959 --> 00:10:20,399
feature for us and

00:10:18,320 --> 00:10:22,079
hopefully we will finish by the end of

00:10:20,399 --> 00:10:25,200
this year

00:10:22,079 --> 00:10:26,640
now let's see if if uh someone wants to

00:10:25,200 --> 00:10:29,600
send the patch

00:10:26,640 --> 00:10:30,240
for the for the linux driver let's see

00:10:29,600 --> 00:10:33,440
what's the

00:10:30,240 --> 00:10:36,240
what's the flow on the left side this

00:10:33,440 --> 00:10:36,959
this process is a little bit unusual for

00:10:36,240 --> 00:10:39,519
the

00:10:36,959 --> 00:10:40,880
for the kernel developers and we need to

00:10:39,519 --> 00:10:42,720
and we also

00:10:40,880 --> 00:10:45,279
uh needed to get accustomed with it when

00:10:42,720 --> 00:10:48,320
we started is that um

00:10:45,279 --> 00:10:50,959
the process takes place on github so the

00:10:48,320 --> 00:10:53,040
everything on the left side happens on

00:10:50,959 --> 00:10:54,800
github so someone sends a pull request

00:10:53,040 --> 00:10:58,160
on github

00:10:54,800 --> 00:11:01,519
and i think the the initial intel guys

00:10:58,160 --> 00:11:04,560
chose uh github uh one reason

00:11:01,519 --> 00:11:06,480
is that they integrated a continuous

00:11:04,560 --> 00:11:08,959
integration system so each

00:11:06,480 --> 00:11:10,000
each patch is tested with with a test

00:11:08,959 --> 00:11:12,959
suit

00:11:10,000 --> 00:11:14,160
um to see if it if it breaks something

00:11:12,959 --> 00:11:17,440
then after the review

00:11:14,160 --> 00:11:20,959
is done the the patch is pushed on

00:11:17,440 --> 00:11:23,440
sof on sof github 3

00:11:20,959 --> 00:11:24,959
on this branch and there is another

00:11:23,440 --> 00:11:28,800
branch which is always

00:11:24,959 --> 00:11:32,320
in sync with the uh with the audio

00:11:28,800 --> 00:11:34,560
audio tree and after the patches are

00:11:32,320 --> 00:11:35,839
cherry picked on the serie based branch

00:11:34,560 --> 00:11:38,240
then the normal

00:11:35,839 --> 00:11:39,920
process of sending patches to the linux

00:11:38,240 --> 00:11:42,880
kernel is done

00:11:39,920 --> 00:11:44,560
that is through email then the the

00:11:42,880 --> 00:11:47,360
patches are again

00:11:44,560 --> 00:11:48,399
again reviewed on alsa mailing list and

00:11:47,360 --> 00:11:51,200
then they are pushed

00:11:48,399 --> 00:11:52,399
upstream so this is the process we are

00:11:51,200 --> 00:11:54,959
following now

00:11:52,399 --> 00:11:57,200
usually because the first review is done

00:11:54,959 --> 00:11:58,160
very very well and with a lot of eyes

00:11:57,200 --> 00:12:00,959
looking

00:11:58,160 --> 00:12:03,680
then the second review here doesn't

00:12:00,959 --> 00:12:03,680
really find

00:12:04,000 --> 00:12:10,959
important issues we've seen cases when

00:12:08,240 --> 00:12:12,720
if a feature is controversial or the

00:12:10,959 --> 00:12:14,480
interface is harder to

00:12:12,720 --> 00:12:16,880
to get it right from the first time the

00:12:14,480 --> 00:12:18,079
patches are sent directly to the audio

00:12:16,880 --> 00:12:21,360
mailing list

00:12:18,079 --> 00:12:25,040
okay so this is the um development flow

00:12:21,360 --> 00:12:29,279
for the linux driver

00:12:25,040 --> 00:12:31,040
now we are going to see how the firmware

00:12:29,279 --> 00:12:33,440
how we are staying on the changes for

00:12:31,040 --> 00:12:36,560
the firmware the firmware is the code

00:12:33,440 --> 00:12:38,720
that runs on the dsp and an overview of

00:12:36,560 --> 00:12:41,040
the architecture of the dsps on the

00:12:38,720 --> 00:12:43,600
right side

00:12:41,040 --> 00:12:44,639
the this slide is very useful for people

00:12:43,600 --> 00:12:47,519
starting

00:12:44,639 --> 00:12:50,160
porting the sof firm or on their dsp

00:12:47,519 --> 00:12:51,760
because basically it says what changes

00:12:50,160 --> 00:12:53,440
needs to be done in order to have your

00:12:51,760 --> 00:12:56,639
usb working so

00:12:53,440 --> 00:12:58,480
one is the platform support uh

00:12:56,639 --> 00:12:59,839
by adding support for the interrupt

00:12:58,480 --> 00:13:02,800
clocks for the

00:12:59,839 --> 00:13:03,600
inter process communication in our uh

00:13:02,800 --> 00:13:06,560
case

00:13:03,600 --> 00:13:08,160
on nxp the ipc is run through a

00:13:06,560 --> 00:13:10,800
messaging unit

00:13:08,160 --> 00:13:11,920
plus a shared memory area then the

00:13:10,800 --> 00:13:14,560
memory map

00:13:11,920 --> 00:13:17,040
and one of the things that is very

00:13:14,560 --> 00:13:19,839
useful in the beginning is to have the

00:13:17,040 --> 00:13:21,279
logging enabled so that you can easily

00:13:19,839 --> 00:13:24,720
debug your changes

00:13:21,279 --> 00:13:27,839
and then for us

00:13:24,720 --> 00:13:30,079
in order to have something working

00:13:27,839 --> 00:13:31,839
we needed to implement the drivers there

00:13:30,079 --> 00:13:32,639
are drivers for the digital audio

00:13:31,839 --> 00:13:35,600
interfaces

00:13:32,639 --> 00:13:36,880
and the drivers for dma which pushed the

00:13:35,600 --> 00:13:39,120
data from

00:13:36,880 --> 00:13:39,120
from

00:13:40,160 --> 00:13:45,920
the input buffers to some some fifo's

00:13:43,600 --> 00:13:47,600
for the for the digital audio interfaces

00:13:45,920 --> 00:13:48,959
and then another driver that we needed

00:13:47,600 --> 00:13:51,920
to write was for the

00:13:48,959 --> 00:13:54,079
interrupt interrupt steer all these

00:13:51,920 --> 00:13:56,399
changes are already accepted

00:13:54,079 --> 00:13:57,519
and you will see on the next slide why

00:13:56,399 --> 00:14:00,720
the

00:13:57,519 --> 00:14:01,760
the the the process for us is easier on

00:14:00,720 --> 00:14:04,880
the firmware side

00:14:01,760 --> 00:14:08,000
than on the kernel side

00:14:04,880 --> 00:14:09,600
a few more things to mention here is

00:14:08,000 --> 00:14:13,600
what's the working process

00:14:09,600 --> 00:14:17,440
progress as i said we want to

00:14:13,600 --> 00:14:18,560
have the compress interface ready by the

00:14:17,440 --> 00:14:20,480
end of this year

00:14:18,560 --> 00:14:22,560
and we need on the firmware side we need

00:14:20,480 --> 00:14:25,040
this processor component

00:14:22,560 --> 00:14:25,760
uh we're still discussing about naming

00:14:25,040 --> 00:14:28,480
and

00:14:25,760 --> 00:14:30,000
how to design it this is this has the

00:14:28,480 --> 00:14:32,880
role as

00:14:30,000 --> 00:14:34,079
for for example decoding compressed

00:14:32,880 --> 00:14:36,000
frames

00:14:34,079 --> 00:14:37,680
then there are some additional drivers

00:14:36,000 --> 00:14:40,399
that one may

00:14:37,680 --> 00:14:42,480
want to implement for example this pdm

00:14:40,399 --> 00:14:44,639
driver is for microphones and can be

00:14:42,480 --> 00:14:47,920
used very useful when we will implement

00:14:44,639 --> 00:14:50,720
some voice activity detection scenario

00:14:47,920 --> 00:14:50,720
and of course

00:14:52,399 --> 00:14:57,440
clients are asking for post processing

00:14:54,880 --> 00:15:01,360
algorithms

00:14:57,440 --> 00:15:03,519
uh the flow for um the flow for firmware

00:15:01,360 --> 00:15:04,800
is a little bit simpler because the

00:15:03,519 --> 00:15:07,839
firmware is

00:15:04,800 --> 00:15:09,920
uh managed by by the community by the

00:15:07,839 --> 00:15:13,040
sound open firmware community

00:15:09,920 --> 00:15:16,320
it's done in the same way using

00:15:13,040 --> 00:15:19,519
a pull request on github then there are

00:15:16,320 --> 00:15:22,959
tests that are are run at each

00:15:19,519 --> 00:15:25,600
pull request and

00:15:22,959 --> 00:15:27,760
when everything is ready the patches are

00:15:25,600 --> 00:15:31,040
pushed to the master branch

00:15:27,760 --> 00:15:36,320
then we are we are following a release

00:15:31,040 --> 00:15:40,079
process similarly with the linux kernel

00:15:36,320 --> 00:15:40,480
because um you need to know that there

00:15:40,079 --> 00:15:42,880
is an

00:15:40,480 --> 00:15:43,519
api dependency between the kernel

00:15:42,880 --> 00:15:47,519
version

00:15:43,519 --> 00:15:51,360
and the uh and the firmware version

00:15:47,519 --> 00:15:53,519
so we are trying to do the releases uh

00:15:51,360 --> 00:15:56,240
to follow at least the cadence of the

00:15:53,519 --> 00:15:59,600
linux kernel releases we are not

00:15:56,240 --> 00:16:01,360
uh yet there

00:15:59,600 --> 00:16:03,759
but i think that would be the goal in

00:16:01,360 --> 00:16:05,920
the future and for idotimix we have

00:16:03,759 --> 00:16:08,000
created a special branch

00:16:05,920 --> 00:16:09,839
a step stable release branch where we

00:16:08,000 --> 00:16:12,880
push the changes for

00:16:09,839 --> 00:16:16,240
uh our stable release nxp

00:16:12,880 --> 00:16:18,720
releases one one kernel per year and we

00:16:16,240 --> 00:16:20,240
we choose the stable kernel and we also

00:16:18,720 --> 00:16:23,279
try to do this with the

00:16:20,240 --> 00:16:24,399
release for the for the firmware the

00:16:23,279 --> 00:16:27,600
current

00:16:24,399 --> 00:16:29,040
stable branch is imx stable version 1.5

00:16:27,600 --> 00:16:31,920
and we are

00:16:29,040 --> 00:16:33,759
back parting all the changes from master

00:16:31,920 --> 00:16:36,160
each time we do a change

00:16:33,759 --> 00:16:37,199
which is a bug fix on master we backport

00:16:36,160 --> 00:16:41,680
it to the stable

00:16:37,199 --> 00:16:44,800
version for the kernel next

00:16:41,680 --> 00:16:46,639
is about what are our supported audio

00:16:44,800 --> 00:16:50,480
pipelines so basically an

00:16:46,639 --> 00:16:54,639
audio scenario is defined by

00:16:50,480 --> 00:16:58,639
an audio pipeline um

00:16:54,639 --> 00:17:01,120
our the feature that works now as in

00:16:58,639 --> 00:17:03,040
as to demonstrate that our code works

00:17:01,120 --> 00:17:06,319
and the dsp is okay

00:17:03,040 --> 00:17:08,720
is we are able to to do pcm playback and

00:17:06,319 --> 00:17:11,919
capture with 48 kilohertz and

00:17:08,720 --> 00:17:15,760
stereo channels with the various

00:17:11,919 --> 00:17:18,000
bit sizes and for qxp

00:17:15,760 --> 00:17:19,439
and qm we have this scenario enabled

00:17:18,000 --> 00:17:22,160
with two codecs

00:17:19,439 --> 00:17:22,559
uh volson one and the cyrus logic one

00:17:22,160 --> 00:17:25,760
and

00:17:22,559 --> 00:17:27,199
uh 8mp only has one codec which is the

00:17:25,760 --> 00:17:30,960
volstone codec

00:17:27,199 --> 00:17:34,480
on the right side here is

00:17:30,960 --> 00:17:37,039
um how uh this is the graphical

00:17:34,480 --> 00:17:40,320
representation of a pipeline

00:17:37,039 --> 00:17:42,480
uh there is a host component uh

00:17:40,320 --> 00:17:43,360
at the the beginning of the playback

00:17:42,480 --> 00:17:45,840
pipeline and

00:17:43,360 --> 00:17:48,799
it ends with a digital audio interface

00:17:45,840 --> 00:17:51,600
component at the end of the pipeline

00:17:48,799 --> 00:17:52,880
um so these are the basic pipelines that

00:17:51,600 --> 00:17:56,240
we have

00:17:52,880 --> 00:17:59,280
customers can write their own pipelines

00:17:56,240 --> 00:18:01,120
by using already already implemented

00:17:59,280 --> 00:18:03,760
components

00:18:01,120 --> 00:18:05,200
in sof where they can write their own

00:18:03,760 --> 00:18:08,000
algorithm

00:18:05,200 --> 00:18:08,640
or component and create the specific

00:18:08,000 --> 00:18:12,240
pipeline

00:18:08,640 --> 00:18:12,240
and enable their scenario

00:18:13,600 --> 00:18:20,640
last part is uh the work we've done

00:18:17,760 --> 00:18:22,160
for enabled enabling the continuous

00:18:20,640 --> 00:18:25,760
integration

00:18:22,160 --> 00:18:27,039
um so for for idle time x8 we don't have

00:18:25,760 --> 00:18:29,919
on the whole side

00:18:27,039 --> 00:18:31,919
we don't have an emulation for the for

00:18:29,919 --> 00:18:34,720
the

00:18:31,919 --> 00:18:36,480
hydrothemic sports but this is planned

00:18:34,720 --> 00:18:39,760
for next year and we will start

00:18:36,480 --> 00:18:42,240
maybe with the 8 mp board

00:18:39,760 --> 00:18:44,320
what we have right now enabled in the

00:18:42,240 --> 00:18:48,080
travis ci on the github

00:18:44,320 --> 00:18:48,960
is the imx 8 dsp site so we have enabled

00:18:48,080 --> 00:18:52,000
the

00:18:48,960 --> 00:18:55,360
the dsp we have emulated the dsp

00:18:52,000 --> 00:18:59,039
with dummy peripherals the peripherals

00:18:55,360 --> 00:19:02,720
are not completely done but we can test

00:18:59,039 --> 00:19:05,760
if the boot is okay so each time um

00:19:02,720 --> 00:19:07,200
someone sends a patch the ci starts

00:19:05,760 --> 00:19:09,679
running and

00:19:07,200 --> 00:19:12,240
besides checking if the code compiles

00:19:09,679 --> 00:19:15,360
well it also checks if the code

00:19:12,240 --> 00:19:17,679
uh boots well it's if the dsp boots well

00:19:15,360 --> 00:19:19,120
the intel guys are more evolved on these

00:19:17,679 --> 00:19:22,160
in the sense that

00:19:19,120 --> 00:19:23,280
they have support in qmu for for host

00:19:22,160 --> 00:19:25,520
site too

00:19:23,280 --> 00:19:26,799
but they also have support for real

00:19:25,520 --> 00:19:29,600
hardware tests

00:19:26,799 --> 00:19:30,240
and they are already enabled we are uh

00:19:29,600 --> 00:19:33,039
we have this

00:19:30,240 --> 00:19:34,080
implant for the next year and let's hope

00:19:33,039 --> 00:19:36,320
that we will do

00:19:34,080 --> 00:19:37,440
them as soon as possible another

00:19:36,320 --> 00:19:41,200
interesting thing

00:19:37,440 --> 00:19:43,200
here is that based on the existing code

00:19:41,200 --> 00:19:46,400
we were able to implement

00:19:43,200 --> 00:19:47,760
uh the ipc fuzzer for the dsp in the

00:19:46,400 --> 00:19:51,120
sense that we can

00:19:47,760 --> 00:19:53,600
send different ipc commands and check if

00:19:51,120 --> 00:19:58,160
the dsp crashes this is very useful

00:19:53,600 --> 00:20:00,480
and it has exposed several bugs

00:19:58,160 --> 00:20:04,000
several bugs so far so this is

00:20:00,480 --> 00:20:07,440
everything that we have

00:20:04,000 --> 00:20:09,679
now let's see our planned use cases

00:20:07,440 --> 00:20:11,039
uh the audio uncompressed playback and

00:20:09,679 --> 00:20:13,919
record is already

00:20:11,039 --> 00:20:15,039
integrated so as you see as you seen we

00:20:13,919 --> 00:20:16,880
don't have

00:20:15,039 --> 00:20:19,760
because we don't have the device three

00:20:16,880 --> 00:20:21,760
files enabled in the upstream kernel you

00:20:19,760 --> 00:20:23,200
actually this feature is not available

00:20:21,760 --> 00:20:25,200
in the upstream kernel

00:20:23,200 --> 00:20:27,679
but it's available in the external

00:20:25,200 --> 00:20:30,000
release of nxp bsp

00:20:27,679 --> 00:20:31,120
so this is already integrated in the bsp

00:20:30,000 --> 00:20:34,080
release and

00:20:31,120 --> 00:20:35,200
anyone can can play with it and test it

00:20:34,080 --> 00:20:38,080
then our major

00:20:35,200 --> 00:20:40,159
feature that we want to uh to have it is

00:20:38,080 --> 00:20:42,480
the compressed playback and i think this

00:20:40,159 --> 00:20:42,480
is a

00:20:42,720 --> 00:20:49,520
major feature that will show the uh

00:20:46,159 --> 00:20:52,559
dsp capability capabilities

00:20:49,520 --> 00:20:54,640
uh then other things that um people can

00:20:52,559 --> 00:20:55,520
enable is for example voice activity

00:20:54,640 --> 00:20:58,799
detection

00:20:55,520 --> 00:21:00,880
the the entire infrastructure is there

00:20:58,799 --> 00:21:02,320
but someone needs to create topology

00:21:00,880 --> 00:21:06,400
file

00:21:02,320 --> 00:21:10,080
for this scenario also besides this

00:21:06,400 --> 00:21:10,080
there are also several other

00:21:10,400 --> 00:21:17,520
features that are available but in our

00:21:14,159 --> 00:21:19,919
in our release are not uh are not

00:21:17,520 --> 00:21:22,480
integrated so for example you can add a

00:21:19,919 --> 00:21:25,760
mixing algorithm or an equalizer

00:21:22,480 --> 00:21:27,760
uh or stuff like that um and

00:21:25,760 --> 00:21:29,600
for the next year because we received a

00:21:27,760 --> 00:21:31,600
lot of feedback from customers we want

00:21:29,600 --> 00:21:34,320
to implement a tuning tool

00:21:31,600 --> 00:21:36,240
uh actually there are some scripts

00:21:34,320 --> 00:21:38,000
implementing various tuning tools for

00:21:36,240 --> 00:21:38,559
components but we want to implement a

00:21:38,000 --> 00:21:42,000
generic

00:21:38,559 --> 00:21:45,280
tuning tool that can be uh easily used

00:21:42,000 --> 00:21:47,760
by the customers and maybe sometimes

00:21:45,280 --> 00:21:51,440
this tool will be in the form of a

00:21:47,760 --> 00:21:51,440
graphical user interface

00:21:51,760 --> 00:21:56,080
well as i'm uh i'm reaching the end of

00:21:54,400 --> 00:21:58,559
the presentation

00:21:56,080 --> 00:21:59,919
uh i want to talk about the challenges

00:21:58,559 --> 00:22:02,799
that we've met

00:21:59,919 --> 00:22:05,440
uh by doing this by uh this doing this

00:22:02,799 --> 00:22:08,720
enabling on the ideal clinics platforms

00:22:05,440 --> 00:22:12,559
and i'm pretty sure that other um other

00:22:08,720 --> 00:22:14,480
arm64 vendors will benefit from our work

00:22:12,559 --> 00:22:15,200
and will make their integration if they

00:22:14,480 --> 00:22:19,120
decide to

00:22:15,200 --> 00:22:21,679
solve uh more more easy

00:22:19,120 --> 00:22:22,400
the first the first challenge that we

00:22:21,679 --> 00:22:25,039
may

00:22:22,400 --> 00:22:26,320
met is that the although the sof was

00:22:25,039 --> 00:22:29,600
written with

00:22:26,320 --> 00:22:32,320
flexibility and portability in mind

00:22:29,600 --> 00:22:33,520
the driver was still intel centric

00:22:32,320 --> 00:22:36,559
because

00:22:33,520 --> 00:22:38,840
this is what the intel guys had

00:22:36,559 --> 00:22:40,240
they had their intel platforms based on

00:22:38,840 --> 00:22:42,720
acpi and

00:22:40,240 --> 00:22:44,320
um they've written the code in that way

00:22:42,720 --> 00:22:47,919
we we needed to understand

00:22:44,320 --> 00:22:50,640
the code and to make it uh

00:22:47,919 --> 00:22:52,640
also available for device three without

00:22:50,640 --> 00:22:54,000
interfering with their changes so we

00:22:52,640 --> 00:22:57,440
needed to do some generic

00:22:54,000 --> 00:23:00,960
changes then another another

00:22:57,440 --> 00:23:04,320
um big challenge for us

00:23:00,960 --> 00:23:06,840
is that on the qxp and the qm

00:23:04,320 --> 00:23:08,799
the resource management is not done on

00:23:06,840 --> 00:23:12,480
the

00:23:08,799 --> 00:23:15,600
arm a core but it's done on the m core

00:23:12,480 --> 00:23:17,200
by a separate software named system

00:23:15,600 --> 00:23:21,120
controller firmware

00:23:17,200 --> 00:23:24,159
and this for us took a lot of time on

00:23:21,120 --> 00:23:26,159
to decide on how to implement this uh

00:23:24,159 --> 00:23:29,280
because it's easier to communicate

00:23:26,159 --> 00:23:31,360
between the a core and the m core to

00:23:29,280 --> 00:23:32,480
to manage resources like for example

00:23:31,360 --> 00:23:34,880
clocks but

00:23:32,480 --> 00:23:36,559
it's harder a little bit harder to do

00:23:34,880 --> 00:23:38,880
the same thing from the dsp

00:23:36,559 --> 00:23:40,960
side so we decided for now that we do

00:23:38,880 --> 00:23:43,039
all the resource management from the a

00:23:40,960 --> 00:23:46,240
core

00:23:43,039 --> 00:23:46,960
then um another another this is a funny

00:23:46,240 --> 00:23:49,919
thing

00:23:46,960 --> 00:23:51,919
is that the topology files are not very

00:23:49,919 --> 00:23:53,360
easy to write because they are written

00:23:51,919 --> 00:23:57,440
in a macro language

00:23:53,360 --> 00:24:00,640
named m4 and

00:23:57,440 --> 00:24:03,840
you need to be very patient and to to

00:24:00,640 --> 00:24:04,640
in order to write one one kind of this

00:24:03,840 --> 00:24:08,080
file but

00:24:04,640 --> 00:24:11,360
uh in the end we managed to to have our

00:24:08,080 --> 00:24:14,559
files written uh another challenges

00:24:11,360 --> 00:24:17,919
we've met is on the loader side

00:24:14,559 --> 00:24:18,960
because the way our memory manage our

00:24:17,919 --> 00:24:22,880
memory map

00:24:18,960 --> 00:24:24,960
is is written in the intel side all the

00:24:22,880 --> 00:24:26,320
all the areas were contiguous for

00:24:24,960 --> 00:24:29,440
example the code

00:24:26,320 --> 00:24:31,679
was always in a contiguous area but on

00:24:29,440 --> 00:24:34,240
our side on nxp platforms

00:24:31,679 --> 00:24:37,200
this wasn't the case that we have

00:24:34,240 --> 00:24:39,039
separate regions from for the code

00:24:37,200 --> 00:24:40,240
and we need to do some changes and we

00:24:39,039 --> 00:24:42,960
adapted them and

00:24:40,240 --> 00:24:44,000
they now landed in the in the loader

00:24:42,960 --> 00:24:46,799
code

00:24:44,000 --> 00:24:47,279
another thing that we also managed to

00:24:46,799 --> 00:24:51,360
fix

00:24:47,279 --> 00:24:52,799
is that um exchanging data between the

00:24:51,360 --> 00:24:57,600
host processor

00:24:52,799 --> 00:25:00,960
uh bit arm or x864

00:24:57,600 --> 00:25:01,760
and the dsp is different so intel uses

00:25:00,960 --> 00:25:04,720
dma to

00:25:01,760 --> 00:25:06,559
to to move data between the the

00:25:04,720 --> 00:25:08,480
application processor which on their

00:25:06,559 --> 00:25:11,760
site is in x66

00:25:08,480 --> 00:25:14,480
64. and imx uses

00:25:11,760 --> 00:25:16,000
shared memory so we needed to in order

00:25:14,480 --> 00:25:17,919
to adapt our code

00:25:16,000 --> 00:25:19,279
for the existing infrastructure we

00:25:17,919 --> 00:25:21,919
needed to write a small

00:25:19,279 --> 00:25:22,400
dummy dma driver which emulates what the

00:25:21,919 --> 00:25:26,080
intel

00:25:22,400 --> 00:25:29,360
patintel does so i think that's

00:25:26,080 --> 00:25:30,480
all we still have time to take some

00:25:29,360 --> 00:25:33,520
questions here

00:25:30,480 --> 00:25:36,320
if if not we can discuss on the

00:25:33,520 --> 00:25:38,159
slack link and i will finish this

00:25:36,320 --> 00:25:42,080
presentation with the

00:25:38,159 --> 00:25:45,039
with the request for uh for people uh

00:25:42,080 --> 00:25:46,159
enabling dsps for other companies to

00:25:45,039 --> 00:25:50,400
have a look at this

00:25:46,159 --> 00:25:53,039
project and maybe see any value in

00:25:50,400 --> 00:25:54,480
uh enabling their dsp using this

00:25:53,039 --> 00:25:57,919
firmware

00:25:54,480 --> 00:25:59,520
we have found a lot a lot of benefits

00:25:57,919 --> 00:26:03,279
from using an open source

00:25:59,520 --> 00:26:06,400
firmware it wasn't easy um

00:26:03,279 --> 00:26:10,960
but i think it works the effort on

00:26:06,400 --> 00:26:13,760
on this opening the firmwares

00:26:10,960 --> 00:26:14,799
so i will have uh we still have four

00:26:13,760 --> 00:26:17,919
minutes to take

00:26:14,799 --> 00:26:20,159
questions and then i will stay for uh

00:26:17,919 --> 00:26:21,520
some more time on the slack slack

00:26:20,159 --> 00:26:26,960
channel

00:26:21,520 --> 00:26:26,960
uh which um which is here

00:26:34,640 --> 00:26:38,000
so we have a question from bill is the

00:26:37,279 --> 00:26:41,039
real audio

00:26:38,000 --> 00:26:41,039
interface fixed

00:26:42,480 --> 00:26:49,440
um so

00:26:45,760 --> 00:26:52,640
in our specific um

00:26:49,440 --> 00:26:55,360
in our specific uh iodine integration

00:26:52,640 --> 00:27:00,720
it's fixed

00:26:55,360 --> 00:27:04,080
and then um the control for that flow

00:27:00,720 --> 00:27:08,480
goes through firmware or goes around

00:27:04,080 --> 00:27:21,840
well it's fixed i'm not sure

00:27:08,480 --> 00:27:21,840
if this can go around

00:27:25,200 --> 00:27:29,440
uh so vinod asked a question about

00:27:27,840 --> 00:27:31,120
what's the status of the compressed

00:27:29,440 --> 00:27:34,399
audio support

00:27:31,120 --> 00:27:37,919
um yes the status is that

00:27:34,399 --> 00:27:40,960
um um some

00:27:37,919 --> 00:27:45,200
marching from intel already sent a first

00:27:40,960 --> 00:27:47,520
version of the page which um

00:27:45,200 --> 00:27:48,640
where we discussed the general direction

00:27:47,520 --> 00:27:52,480
of how to add

00:27:48,640 --> 00:27:56,000
the decoder

00:27:52,480 --> 00:28:03,840
i can send you later the

00:27:56,000 --> 00:28:03,840
the pull request link

00:28:09,919 --> 00:28:14,480
yes sure and

00:28:12,960 --> 00:28:16,880
vinod i think we will need your

00:28:14,480 --> 00:28:20,320
expertise on the linux

00:28:16,880 --> 00:28:31,840
kernel site for the for the compress

00:28:20,320 --> 00:28:31,840
compress api

00:28:55,760 --> 00:28:58,960
so another question from bill does sof

00:28:58,640 --> 00:29:03,200
has

00:28:58,960 --> 00:29:04,399
support for using dsp as a bump in the

00:29:03,200 --> 00:29:07,600
pipe

00:29:04,399 --> 00:29:11,440
so do you mean that

00:29:07,600 --> 00:29:15,279
uh yeah i understand your question

00:29:11,440 --> 00:29:18,399
not really the the flow is like this

00:29:15,279 --> 00:29:20,799
host dsp then the

00:29:18,399 --> 00:29:21,679
the result of the dsp is rendered to a

00:29:20,799 --> 00:29:24,799
codec

00:29:21,679 --> 00:29:28,320
but your scenario is very very useful

00:29:24,799 --> 00:29:31,200
and actually we have a use case in this

00:29:28,320 --> 00:29:31,200
in this way

00:29:33,440 --> 00:29:38,720
we can run the following pipeline in

00:29:36,240 --> 00:29:41,200
parallel we can run host to dsp

00:29:38,720 --> 00:29:42,159
some codec in parallel with something

00:29:41,200 --> 00:29:46,000
like

00:29:42,159 --> 00:29:51,039
codec dsp

00:29:46,000 --> 00:29:51,039
host for playback and for capture

00:29:51,520 --> 00:29:54,640
but your scenario indeed because for

00:29:53,679 --> 00:29:58,000
example

00:29:54,640 --> 00:29:58,320
some people want to offload the decoding

00:29:58,000 --> 00:30:01,120
of

00:29:58,320 --> 00:30:03,600
frames and they want to send compressed

00:30:01,120 --> 00:30:05,840
frame to the dsp and the dsp to send

00:30:03,600 --> 00:30:08,880
them back the uncompressed frame

00:30:05,840 --> 00:30:09,279
but in our u in our case for for now the

00:30:08,880 --> 00:30:12,559
the

00:30:09,279 --> 00:30:17,039
uncompressed frame will be rendered

00:30:12,559 --> 00:30:17,039
uh to a certain codec or

00:30:17,679 --> 00:30:23,840
any kind of this external element

00:30:28,080 --> 00:30:37,840
yeah you're welcome

00:30:43,440 --> 00:30:47,600
i think we are we are in time

00:30:48,720 --> 00:30:52,720
okay so another question from the node

00:30:51,120 --> 00:30:56,720
any plans to support

00:30:52,720 --> 00:30:59,039
remote proc interface for dsps

00:30:56,720 --> 00:30:59,840
um there were there were discussions

00:30:59,039 --> 00:31:03,279
about this

00:30:59,840 --> 00:31:05,840
and i think we

00:31:03,279 --> 00:31:06,640
we got to the conclusion that we should

00:31:05,840 --> 00:31:11,120
look at this

00:31:06,640 --> 00:31:11,120
but so far it it's not done

00:31:12,640 --> 00:31:17,279
oh okay yeah i understand yeah having

00:31:15,200 --> 00:31:20,559
remote proc will definitely

00:31:17,279 --> 00:31:23,919
use the porting on on different

00:31:20,559 --> 00:31:25,440
architectures or dsps but for now we use

00:31:23,919 --> 00:31:28,640
a custom protocol

00:31:25,440 --> 00:31:33,840
which i think can be changed

00:31:28,640 --> 00:31:33,840
yeah and did a very good question

00:32:07,279 --> 00:32:10,960
you're welcome and uh thank you everyone

00:32:10,080 --> 00:32:14,880
for joining

00:32:10,960 --> 00:32:19,760
i hope um i have sent a list

00:32:14,880 --> 00:32:22,960
very few um useful information

00:32:19,760 --> 00:32:24,000
and i hope you that in the future we'll

00:32:22,960 --> 00:32:27,279
see some

00:32:24,000 --> 00:32:29,840
uh full requests on the sof github from

00:32:27,279 --> 00:32:29,840

YouTube URL: https://www.youtube.com/watch?v=tSfLQSdpPuE


