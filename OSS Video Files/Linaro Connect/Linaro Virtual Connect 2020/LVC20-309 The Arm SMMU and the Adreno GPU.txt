Title: LVC20-309 The Arm SMMU and the Adreno GPU
Publication date: 2020-09-23
Playlist: Linaro Virtual Connect 2020
Description: 
	DESCRIPTION
The Qualcomm Adreno GPU pushes the boundaries of the ARM SMMUv2 architecture in new and interesting ways. This presentation will discuss some of the new proposed GPU specific features for the ARM SMMUv2 driver such as split pagetables and pagetable switching and future enhancements to improve the GPU/SMMU relationship.

Download the slides and watch the video here: https://connect.linaro.org/resources/lvc20/lvc20-309/
Captions: 
	00:00:00,160 --> 00:00:03,360
hello my name is jordan krauss and i'm

00:00:02,240 --> 00:00:06,080
here to give a

00:00:03,360 --> 00:00:08,160
short summary and update on uh some

00:00:06,080 --> 00:00:09,599
improvements we're making to the rms mmu

00:00:08,160 --> 00:00:11,599
v2 driver

00:00:09,599 --> 00:00:13,599
uh specifically to support the adreno

00:00:11,599 --> 00:00:17,039
gpu that is

00:00:13,599 --> 00:00:20,160
part of most of the qualcomm snapdragon

00:00:17,039 --> 00:00:21,520
socs um

00:00:20,160 --> 00:00:23,439
to start with we'll do a little bit of

00:00:21,520 --> 00:00:26,560
history so the the

00:00:23,439 --> 00:00:29,920
qualcomm the adreno gpu has always had

00:00:26,560 --> 00:00:32,800
an attached sm mu

00:00:29,920 --> 00:00:35,040
even in the very early days in the a2 xx

00:00:32,800 --> 00:00:36,239
uh there was what i call a proto smmu it

00:00:35,040 --> 00:00:38,800
was slot based

00:00:36,239 --> 00:00:40,160
it was okay wasn't great um but then

00:00:38,800 --> 00:00:42,879
when we moved to the a3

00:00:40,160 --> 00:00:43,760
xx generation which is kind of the start

00:00:42,879 --> 00:00:47,520
of the

00:00:43,760 --> 00:00:49,920
current um lineage of adreno gpus

00:00:47,520 --> 00:00:51,760
we started with a very customized

00:00:49,920 --> 00:00:54,719
version of the rms mmu

00:00:51,760 --> 00:00:55,600
we call it qcom immu and then slowly

00:00:54,719 --> 00:00:59,199
over time we

00:00:55,600 --> 00:01:01,600
evolved into um something it's it's

00:00:59,199 --> 00:01:03,120
it's similar to the mmu 500 it's a

00:01:01,600 --> 00:01:05,040
little bit customized but it's

00:01:03,120 --> 00:01:06,560
essentially an mmu 500 with a little bit

00:01:05,040 --> 00:01:08,640
of stuff glued on

00:01:06,560 --> 00:01:10,479
um the advantage of this is that you

00:01:08,640 --> 00:01:13,119
know as of

00:01:10,479 --> 00:01:14,479
when we transitioned to a5xx i guess

00:01:13,119 --> 00:01:17,280
that was three or four years

00:01:14,479 --> 00:01:19,200
five six years ago maybe um we were able

00:01:17,280 --> 00:01:21,680
to start using rms and memory driver

00:01:19,200 --> 00:01:23,600
um as as it was so we were able to start

00:01:21,680 --> 00:01:26,159
using the stock driver

00:01:23,600 --> 00:01:27,119
um which works out pretty well uh but

00:01:26,159 --> 00:01:30,560
there are a few

00:01:27,119 --> 00:01:32,880
quirks that the adreno gpu

00:01:30,560 --> 00:01:34,320
has and would like to take advantage of

00:01:32,880 --> 00:01:37,040
that

00:01:34,320 --> 00:01:39,600
are not generally something that other

00:01:37,040 --> 00:01:43,759
gpus or other

00:01:39,600 --> 00:01:45,920
clients have so most clients have a dma

00:01:43,759 --> 00:01:47,600
interface they usually have a one-to-one

00:01:45,920 --> 00:01:48,479
relationship between their virtual

00:01:47,600 --> 00:01:50,640
address space

00:01:48,479 --> 00:01:53,759
and the memory that they're allocating

00:01:50,640 --> 00:01:55,680
and for the most part they

00:01:53,759 --> 00:01:57,600
are very simple you create memory you

00:01:55,680 --> 00:02:01,520
map it into diamond view

00:01:57,600 --> 00:02:03,840
and go on forward with that the rms

00:02:01,520 --> 00:02:05,680
or the adreno gpu is a little bit

00:02:03,840 --> 00:02:07,200
different

00:02:05,680 --> 00:02:09,440
one of the biggest features that we want

00:02:07,200 --> 00:02:11,120
to provide for for the world

00:02:09,440 --> 00:02:13,120
are what we call per instance page

00:02:11,120 --> 00:02:14,080
tables and we've had for instance page

00:02:13,120 --> 00:02:16,560
tables or

00:02:14,080 --> 00:02:17,680
per process page tables as as they're

00:02:16,560 --> 00:02:19,920
often called

00:02:17,680 --> 00:02:20,800
um as part of the downstream drivers

00:02:19,920 --> 00:02:23,520
since

00:02:20,800 --> 00:02:24,720
a3 a3xxx days and the object here is

00:02:23,520 --> 00:02:26,319
very simple we want to

00:02:24,720 --> 00:02:28,720
provide individual virtual address

00:02:26,319 --> 00:02:31,840
spaces for different containers

00:02:28,720 --> 00:02:33,680
um the name changes a little bit i call

00:02:31,840 --> 00:02:34,640
it per instance but it's also called for

00:02:33,680 --> 00:02:36,720
process because

00:02:34,640 --> 00:02:38,720
this can be as granular as a context and

00:02:36,720 --> 00:02:41,760
as broad as a process

00:02:38,720 --> 00:02:43,519
so if you are able to track

00:02:41,760 --> 00:02:44,879
all the file descriptors and contacts

00:02:43,519 --> 00:02:46,080
that are part of a process you could

00:02:44,879 --> 00:02:48,400
switch

00:02:46,080 --> 00:02:50,879
the the page table for each process and

00:02:48,400 --> 00:02:55,840
have it available to multiple contacts

00:02:50,879 --> 00:02:57,599
um for upstream for ddrm

00:02:55,840 --> 00:02:59,040
we decided that the we're going to go

00:02:57,599 --> 00:03:00,319
with the file descriptor so a lot of

00:02:59,040 --> 00:03:02,159
this discussion will be on a file

00:03:00,319 --> 00:03:04,879
descriptive basis the reason why

00:03:02,159 --> 00:03:06,879
is that the memory was on the ndrm and

00:03:04,879 --> 00:03:11,360
in drm is already

00:03:06,879 --> 00:03:13,120
mostly uh file descriptor based you have

00:03:11,360 --> 00:03:14,640
to import to a specific file descriptor

00:03:13,120 --> 00:03:15,599
you have to export from a specific file

00:03:14,640 --> 00:03:18,239
descriptor

00:03:15,599 --> 00:03:18,879
so it was the best location for us to

00:03:18,239 --> 00:03:22,480
basically

00:03:18,879 --> 00:03:22,959
create a page table um without without a

00:03:22,480 --> 00:03:25,440
lot of

00:03:22,959 --> 00:03:27,280
a drama there has been some talk maybe

00:03:25,440 --> 00:03:28,720
taking it context based um

00:03:27,280 --> 00:03:30,480
which we could do we could do it on a

00:03:28,720 --> 00:03:33,040
per context basis but

00:03:30,480 --> 00:03:33,599
for the most part the idea is here is it

00:03:33,040 --> 00:03:36,000
can be

00:03:33,599 --> 00:03:37,440
anywhere kind of in that spectrum but

00:03:36,000 --> 00:03:39,200
when i talk about per instance page

00:03:37,440 --> 00:03:39,920
tables or even if i slip up and say per

00:03:39,200 --> 00:03:43,280
process

00:03:39,920 --> 00:03:45,440
i mean per file descriptor um

00:03:43,280 --> 00:03:46,319
so obviously there's an advantage to

00:03:45,440 --> 00:03:49,519
having things

00:03:46,319 --> 00:03:51,120
in a in a sandbox one process or one

00:03:49,519 --> 00:03:53,040
file descriptor can't corrupt the other

00:03:51,120 --> 00:03:55,680
one you can't read other people's

00:03:53,040 --> 00:03:56,480
things if you have a credit card and a

00:03:55,680 --> 00:03:58,480
shader

00:03:56,480 --> 00:03:59,599
you know credit card number and a shader

00:03:58,480 --> 00:04:01,120
drawn in one screen

00:03:59,599 --> 00:04:03,120
the other guy can't get it the other guy

00:04:01,120 --> 00:04:04,480
can't get critical information and

00:04:03,120 --> 00:04:06,000
more importantly the guy can't corrupt

00:04:04,480 --> 00:04:06,799
it he can't show you something that you

00:04:06,000 --> 00:04:09,680
shouldn't be seeing

00:04:06,799 --> 00:04:11,120
on the screen um but also as a bonus

00:04:09,680 --> 00:04:14,239
this allows for what

00:04:11,120 --> 00:04:15,439
we call coarse-grained sva or svm which

00:04:14,239 --> 00:04:17,120
basically means that we can

00:04:15,439 --> 00:04:19,359
allocate the same address on both the

00:04:17,120 --> 00:04:22,000
gpu and the cpu

00:04:19,359 --> 00:04:23,919
which is used by compute compute loves

00:04:22,000 --> 00:04:26,080
to do this but other people do it too

00:04:23,919 --> 00:04:27,199
um if we can't have the ability to

00:04:26,080 --> 00:04:29,680
provide a page table

00:04:27,199 --> 00:04:31,440
that says per instance or per process

00:04:29,680 --> 00:04:32,880
then we can't do sva because we have to

00:04:31,440 --> 00:04:35,360
be able to ensure

00:04:32,880 --> 00:04:36,880
that each process gets the the maximum

00:04:35,360 --> 00:04:38,240
amount of tax space they can get

00:04:36,880 --> 00:04:40,240
this is particularly important for

00:04:38,240 --> 00:04:43,600
32-bit but it also comes into

00:04:40,240 --> 00:04:46,240
into play for 64-bit so

00:04:43,600 --> 00:04:47,759
um the per instance page tables are

00:04:46,240 --> 00:04:48,560
triggered automatically in the gpu

00:04:47,759 --> 00:04:50,800
stream

00:04:48,560 --> 00:04:53,520
uh the command processor can can issue a

00:04:50,800 --> 00:04:56,160
special op code called smmu table update

00:04:53,520 --> 00:04:57,600
which will do all the nitty gritty of

00:04:56,160 --> 00:04:59,440
trying to switch over and we're going to

00:04:57,600 --> 00:05:00,240
go over that in a second about the exact

00:04:59,440 --> 00:05:02,160
process

00:05:00,240 --> 00:05:03,919
now this we didn't always have a nice

00:05:02,160 --> 00:05:06,639
little op code for it

00:05:03,919 --> 00:05:07,680
back on previous previous generations we

00:05:06,639 --> 00:05:11,680
had to do a lot more

00:05:07,680 --> 00:05:13,759
inside the code but luckily as a 5xx and

00:05:11,680 --> 00:05:15,759
our transition to the rms and mmuv2

00:05:13,759 --> 00:05:17,520
driver it's all pretty contained and so

00:05:15,759 --> 00:05:19,120
it's actually just a one or two

00:05:17,520 --> 00:05:22,479
d words in the command stream to make

00:05:19,120 --> 00:05:22,479
the to make the transition

00:05:22,800 --> 00:05:26,160
so here's a little bit of discussion

00:05:24,000 --> 00:05:27,680
about how the hardware works so the key

00:05:26,160 --> 00:05:30,080
here is is that the

00:05:27,680 --> 00:05:32,000
smmu for the adreno gpu is integrated

00:05:30,080 --> 00:05:34,320
with the adreno gpu it shares the same

00:05:32,000 --> 00:05:37,840
clocks it shares the same power

00:05:34,320 --> 00:05:39,759
and it's only for the adreno gpu so no

00:05:37,840 --> 00:05:42,160
there are two smmu's on it

00:05:39,759 --> 00:05:43,680
on a modern snapdragon soc but the other

00:05:42,160 --> 00:05:46,000
one is used by everyone else and this

00:05:43,680 --> 00:05:48,560
one is just used by the gpu

00:05:46,000 --> 00:05:49,840
so uh what happens is we start off we

00:05:48,560 --> 00:05:52,240
have the smu

00:05:49,840 --> 00:05:53,520
context banks and we're going to pick a

00:05:52,240 --> 00:05:56,080
context bank

00:05:53,520 --> 00:05:57,440
that is going to be used for the gpu and

00:05:56,080 --> 00:05:58,880
the reason why for this is going to

00:05:57,440 --> 00:06:00,319
become clear in a second but for the

00:05:58,880 --> 00:06:02,240
purpose of this discussion we're going

00:06:00,319 --> 00:06:04,000
to say that the sme gpu has gotten

00:06:02,240 --> 00:06:05,520
context bank 0.

00:06:04,000 --> 00:06:07,039
and we're going to set up two address

00:06:05,520 --> 00:06:07,680
spaces in the context bank zero we're

00:06:07,039 --> 00:06:10,800
going to set up

00:06:07,680 --> 00:06:13,600
tcpr0 and ttr1 this works a lot

00:06:10,800 --> 00:06:15,600
very similar to how as a cpu mmu works

00:06:13,600 --> 00:06:17,919
where you would have the kernel and the

00:06:15,600 --> 00:06:18,800
and the process having different address

00:06:17,919 --> 00:06:20,720
spaces

00:06:18,800 --> 00:06:22,240
uh this is essential because there are a

00:06:20,720 --> 00:06:25,680
lot of things in the gpu

00:06:22,240 --> 00:06:27,520
that do not that require a common

00:06:25,680 --> 00:06:29,600
global address such as the ring buffer

00:06:27,520 --> 00:06:30,960
or the location of the microcode

00:06:29,600 --> 00:06:33,440
and there's you know a handful of other

00:06:30,960 --> 00:06:37,600
things so we have to create

00:06:33,440 --> 00:06:40,400
an initial sms context with the ttpr0

00:06:37,600 --> 00:06:41,840
or pcbr1 sorry and then program it with

00:06:40,400 --> 00:06:43,840
all the things that we need to be able

00:06:41,840 --> 00:06:48,080
to actually run the gpu

00:06:43,840 --> 00:06:50,400
at a kernel level or at a global level

00:06:48,080 --> 00:06:52,319
the next step is in the hardware we have

00:06:50,400 --> 00:06:54,319
what's called an svmu aperture and so

00:06:52,319 --> 00:06:57,440
the aperture basically

00:06:54,319 --> 00:06:59,919
allows the gpu to see

00:06:57,440 --> 00:07:01,919
one of the context banks the reason why

00:06:59,919 --> 00:07:03,599
it's an aperture and it's limited to one

00:07:01,919 --> 00:07:06,639
context bank is that

00:07:03,599 --> 00:07:06,960
um generally there are other contexts

00:07:06,639 --> 00:07:08,800
that

00:07:06,960 --> 00:07:10,960
are running so we do have a secure

00:07:08,800 --> 00:07:12,319
context for those who do secure memory

00:07:10,960 --> 00:07:14,639
we also have a couple of other ones

00:07:12,319 --> 00:07:16,400
running some of our

00:07:14,639 --> 00:07:18,400
graphics management units on the newer

00:07:16,400 --> 00:07:20,880
processors and so

00:07:18,400 --> 00:07:23,039
we don't want there to be the

00:07:20,880 --> 00:07:24,000
possibility that the gpu could overstep

00:07:23,039 --> 00:07:25,759
its bounds

00:07:24,000 --> 00:07:28,080
um if it gets out there and it starts

00:07:25,759 --> 00:07:30,160
programming other smsu contexts or other

00:07:28,080 --> 00:07:31,520
smsu global registers

00:07:30,160 --> 00:07:33,599
you get yourself into a lot of trouble

00:07:31,520 --> 00:07:34,960
quickly so what we do is we create an

00:07:33,599 --> 00:07:36,319
aperture and we have to tie it to a

00:07:34,960 --> 00:07:38,720
context bank

00:07:36,319 --> 00:07:39,680
um because some of the contacts can be

00:07:38,720 --> 00:07:42,240
secure

00:07:39,680 --> 00:07:44,400
the smmu aperture is normally controlled

00:07:42,240 --> 00:07:46,319
by the secure memory in the

00:07:44,400 --> 00:07:48,800
um sorry not the secure memory but the

00:07:46,319 --> 00:07:49,840
secure trust zone so the secure world in

00:07:48,800 --> 00:07:51,840
the bootloader

00:07:49,840 --> 00:07:53,280
sets the aperture and then we can't

00:07:51,840 --> 00:07:56,240
necessarily change it

00:07:53,280 --> 00:07:57,759
uh there are some some some commands

00:07:56,240 --> 00:07:59,680
that we can use to change it

00:07:57,759 --> 00:08:01,199
but generally it stays at context bank

00:07:59,680 --> 00:08:03,360
zero and so we're kind of under the

00:08:01,199 --> 00:08:06,639
assumption that context being zero

00:08:03,360 --> 00:08:08,560
is what we want to use for the um

00:08:06,639 --> 00:08:10,240
for the for the smmu aperture so the

00:08:08,560 --> 00:08:12,000
estimated aperture is programmed

00:08:10,240 --> 00:08:14,000
into context being zero context bank

00:08:12,000 --> 00:08:17,039
zero is already set up for ttbr1

00:08:14,000 --> 00:08:18,160
we're ready to start switching um

00:08:17,039 --> 00:08:19,599
so what's going to happen is the command

00:08:18,160 --> 00:08:21,840
processor it's very simple actually the

00:08:19,599 --> 00:08:24,160
command processor is going to come along

00:08:21,840 --> 00:08:24,490
it's going to stop the buses it's going

00:08:24,160 --> 00:08:26,240
to

00:08:24,490 --> 00:08:29,440
[Music]

00:08:26,240 --> 00:08:31,840
stop all of this gpu activity and put

00:08:29,440 --> 00:08:33,360
itself into a into a into a situation

00:08:31,840 --> 00:08:35,360
where it can transition without

00:08:33,360 --> 00:08:37,760
accessing smmu

00:08:35,360 --> 00:08:39,680
then it's going to write the ttbr1 or

00:08:37,760 --> 00:08:42,000
sorry tcpr0 address so we're going to

00:08:39,680 --> 00:08:43,519
have a ttbr0 physical address that we've

00:08:42,000 --> 00:08:44,959
stored for the page table

00:08:43,519 --> 00:08:46,160
we're going to put it into the command

00:08:44,959 --> 00:08:48,080
stream the command stream is going to

00:08:46,160 --> 00:08:51,600
write that value into the

00:08:48,080 --> 00:08:56,000
ttbr0 register inside the smsu aperture

00:08:51,600 --> 00:08:57,200
which then will um program the tcpr0 in

00:08:56,000 --> 00:09:00,160
the context bank

00:08:57,200 --> 00:09:04,080
and it will resume the the execution now

00:09:00,160 --> 00:09:06,080
we have both the ttbr1 and httpr0

00:09:04,080 --> 00:09:07,680
instance in our context bank and the

00:09:06,080 --> 00:09:08,000
process can use the memory that it is

00:09:07,680 --> 00:09:11,040
mapped

00:09:08,000 --> 00:09:13,120
into the page table and operate normally

00:09:11,040 --> 00:09:15,279
and then the next time we need to switch

00:09:13,120 --> 00:09:16,160
the ttpr0 is taken out the new one is

00:09:15,279 --> 00:09:18,080
switched in

00:09:16,160 --> 00:09:19,839
this happens throughout you know until

00:09:18,080 --> 00:09:20,640
then until the until the instance is

00:09:19,839 --> 00:09:22,399
done

00:09:20,640 --> 00:09:24,880
so this is kind of how the hardware

00:09:22,399 --> 00:09:26,399
works it's it it sounds simple when we

00:09:24,880 --> 00:09:27,680
talked about it i mean behind the scenes

00:09:26,399 --> 00:09:29,360
i think the hardware is probably a

00:09:27,680 --> 00:09:31,839
little bit picky but

00:09:29,360 --> 00:09:32,959
um for us it's basically we have a setup

00:09:31,839 --> 00:09:35,839
context bank

00:09:32,959 --> 00:09:37,360
we program a new ttbr0 and then that

00:09:35,839 --> 00:09:39,519
gets used for the duration of the

00:09:37,360 --> 00:09:40,480
operation and then a new ttpr0 comes

00:09:39,519 --> 00:09:44,000
after that

00:09:40,480 --> 00:09:45,600
and so on and so forth uh

00:09:44,000 --> 00:09:47,279
so there are a few requirements from

00:09:45,600 --> 00:09:48,560
from the from the from the gpu side or

00:09:47,279 --> 00:09:51,040
at least from the kernel side

00:09:48,560 --> 00:09:52,880
to be able to do this as i mentioned we

00:09:51,040 --> 00:09:55,120
kind of need to fix context bank

00:09:52,880 --> 00:09:56,640
ideally it's context bank zero like i

00:09:55,120 --> 00:09:58,959
said there is support for switching it

00:09:56,640 --> 00:10:01,200
but that's not available on all targets

00:09:58,959 --> 00:10:02,720
so really if we can get context bank

00:10:01,200 --> 00:10:05,040
zero for the gpu

00:10:02,720 --> 00:10:05,760
instance then that is the best policy

00:10:05,040 --> 00:10:07,760
the next step

00:10:05,760 --> 00:10:09,920
is to have split page table support so

00:10:07,760 --> 00:10:12,160
the ttbr1 ttpr0

00:10:09,920 --> 00:10:14,000
this is critical because it allows us to

00:10:12,160 --> 00:10:16,720
be able to switch page tables

00:10:14,000 --> 00:10:18,240
without having to remap all of the

00:10:16,720 --> 00:10:20,480
global buffers

00:10:18,240 --> 00:10:22,399
bring buffer then microcode other things

00:10:20,480 --> 00:10:25,040
into every page table and have to try

00:10:22,399 --> 00:10:25,040
and manage that

00:10:25,440 --> 00:10:29,040
and then we do need to be able to figure

00:10:27,360 --> 00:10:30,800
out a way to share the page table

00:10:29,040 --> 00:10:31,440
configuration between the gpu driver and

00:10:30,800 --> 00:10:33,040
the smu

00:10:31,440 --> 00:10:34,720
driver because what's going to happen is

00:10:33,040 --> 00:10:36,720
the gpu driver

00:10:34,720 --> 00:10:37,920
is going to own the page tables that it

00:10:36,720 --> 00:10:40,959
creates so

00:10:37,920 --> 00:10:42,880
using io page table it's going to create

00:10:40,959 --> 00:10:44,720
the page tables the tcpr0 so it's going

00:10:42,880 --> 00:10:46,240
to be the owner of the page table it's

00:10:44,720 --> 00:10:47,040
going to map directly into the page

00:10:46,240 --> 00:10:47,920
table

00:10:47,040 --> 00:10:50,240
and it's going to have all the

00:10:47,920 --> 00:10:52,480
information it needs to be able to

00:10:50,240 --> 00:10:54,320
to switch the page table but in order to

00:10:52,480 --> 00:10:56,160
create a page table we need to figure

00:10:54,320 --> 00:11:00,640
out what the current configuration is

00:10:56,160 --> 00:11:02,880
so when the smu when the domain is

00:11:00,640 --> 00:11:03,920
first attached to the sme new driver it

00:11:02,880 --> 00:11:06,160
will go out

00:11:03,920 --> 00:11:07,519
it will create a tcpr1 instance in the

00:11:06,160 --> 00:11:08,560
context bank and we'll program the

00:11:07,519 --> 00:11:10,399
context bank

00:11:08,560 --> 00:11:12,240
we didn't know what was programmed

00:11:10,399 --> 00:11:13,760
because in order to get the

00:11:12,240 --> 00:11:15,760
page tables that match we need to be

00:11:13,760 --> 00:11:17,600
able to do that so we need to be able to

00:11:15,760 --> 00:11:18,800
grab the page table configuration from

00:11:17,600 --> 00:11:21,200
the smmu driver

00:11:18,800 --> 00:11:22,640
create our own page tables and then

00:11:21,200 --> 00:11:24,399
furthermore

00:11:22,640 --> 00:11:26,480
we need to be able to program or at

00:11:24,399 --> 00:11:29,279
least let the smmu driver know

00:11:26,480 --> 00:11:29,760
when we have the first http r0 available

00:11:29,279 --> 00:11:32,320
because

00:11:29,760 --> 00:11:34,480
if in the absence of a tchpr0 it's a

00:11:32,320 --> 00:11:37,760
really really bad idea to have

00:11:34,480 --> 00:11:39,440
uh the ttbr0s region active um

00:11:37,760 --> 00:11:41,120
it's really dangerous if it's programmed

00:11:39,440 --> 00:11:43,200
and no bad things can happen

00:11:41,120 --> 00:11:45,279
so when we first create the page table

00:11:43,200 --> 00:11:45,680
like the context we will go ahead and

00:11:45,279 --> 00:11:48,880
set

00:11:45,680 --> 00:11:50,720
ttpr1 enable for tdpr0 disable

00:11:48,880 --> 00:11:52,800
so then at some point the gpu needs to

00:11:50,720 --> 00:11:54,480
say hey i have an active context bank

00:11:52,800 --> 00:11:56,000
we're ready to go or an active

00:11:54,480 --> 00:11:57,680
page table we're ready to go and it

00:11:56,000 --> 00:12:01,519
needs to kick the smmu driver and say

00:11:57,680 --> 00:12:03,600
hey please enable dpr0

00:12:01,519 --> 00:12:04,959
so here's a little bit of a rundown of

00:12:03,600 --> 00:12:07,040
what the programming sequence is going

00:12:04,959 --> 00:12:09,440
to look like from between the rmsb

00:12:07,040 --> 00:12:10,800
driver and the drm msm driver

00:12:09,440 --> 00:12:12,800
so the first thing is we're going to

00:12:10,800 --> 00:12:14,800
attach the domain this is the normal

00:12:12,800 --> 00:12:16,320
process of an immune we're going to

00:12:14,800 --> 00:12:17,920
come up we're going to detect that we

00:12:16,320 --> 00:12:21,040
have an immune we're going to say okay

00:12:17,920 --> 00:12:24,720
please attach our device to the immune

00:12:21,040 --> 00:12:26,399
instance so in the rms memory driver

00:12:24,720 --> 00:12:28,639
it's going to be identified as we're

00:12:26,399 --> 00:12:30,160
going to have a compatible string inside

00:12:28,639 --> 00:12:33,360
of the

00:12:30,160 --> 00:12:34,720
dt that says we're in our adreno smu

00:12:33,360 --> 00:12:36,480
we're special

00:12:34,720 --> 00:12:38,000
and the rms driver is going to look at

00:12:36,480 --> 00:12:40,399
it and say okay this is

00:12:38,000 --> 00:12:41,680
sid 0 which is the stream id for the for

00:12:40,399 --> 00:12:44,160
the gpu

00:12:41,680 --> 00:12:45,519
uh we know that guy we're special um

00:12:44,160 --> 00:12:47,360
we're going to go ahead and force

00:12:45,519 --> 00:12:49,440
allocate context bank 0.

00:12:47,360 --> 00:12:51,360
all other domain all other context banks

00:12:49,440 --> 00:12:53,519
that get allocated will be allocated

00:12:51,360 --> 00:12:55,040
um from the from the bitmap but this one

00:12:53,519 --> 00:12:56,800
is the one that we know we especially

00:12:55,040 --> 00:12:58,240
only use context bank setup

00:12:56,800 --> 00:13:00,480
so we can guarantee that we always have

00:12:58,240 --> 00:13:02,160
a known context bank

00:13:00,480 --> 00:13:04,079
um then then it goes through the normal

00:13:02,160 --> 00:13:05,200
initialization process process for

00:13:04,079 --> 00:13:07,760
context banks

00:13:05,200 --> 00:13:09,920
it'll initialize everything set up the

00:13:07,760 --> 00:13:11,600
status set up the the format and then

00:13:09,920 --> 00:13:14,800
enable ttbr1

00:13:11,600 --> 00:13:17,120
with the page table that is owned by the

00:13:14,800 --> 00:13:19,040
rms mmu driver so when we create the

00:13:17,120 --> 00:13:22,480
global buffers we will program them

00:13:19,040 --> 00:13:25,040
into the rms mmu driver via immune

00:13:22,480 --> 00:13:26,320
map and it will all go through the rms

00:13:25,040 --> 00:13:28,000
menu drivers so at this point

00:13:26,320 --> 00:13:29,839
really nothing's very different except

00:13:28,000 --> 00:13:30,959
for we allocated context bank zero which

00:13:29,839 --> 00:13:33,120
is a little weird

00:13:30,959 --> 00:13:34,079
but instead of using tcpr0 we're using

00:13:33,120 --> 00:13:36,160
ttbr1

00:13:34,079 --> 00:13:38,800
from the rms and memory driver not much

00:13:36,160 --> 00:13:38,800
is going on here

00:13:38,880 --> 00:13:42,639
so then the next step is we come back

00:13:40,800 --> 00:13:44,800
into vrmmsm and it's time for us to

00:13:42,639 --> 00:13:46,880
create our first instance page table

00:13:44,800 --> 00:13:48,720
so the first step thing we so what we do

00:13:46,880 --> 00:13:50,480
is we get the page table configuration

00:13:48,720 --> 00:13:52,880
from the rms menu driver

00:13:50,480 --> 00:13:53,839
and this is done via a shared memory

00:13:52,880 --> 00:13:56,320
interface that

00:13:53,839 --> 00:13:56,880
is attached to the device so when we get

00:13:56,320 --> 00:13:58,880
the

00:13:56,880 --> 00:14:00,000
device data there's going to be a shared

00:13:58,880 --> 00:14:02,160
memory like a

00:14:00,000 --> 00:14:04,160
there's a structure that basically is a

00:14:02,160 --> 00:14:06,800
is a known private member between

00:14:04,160 --> 00:14:07,839
the adreno smmu implementation of our

00:14:06,800 --> 00:14:10,160
msmu

00:14:07,839 --> 00:14:11,120
and the drmemps msm so we can call a

00:14:10,160 --> 00:14:14,240
hook in there

00:14:11,120 --> 00:14:16,880
our met the adreno smmu will give us the

00:14:14,240 --> 00:14:17,839
configuration of the ttbr1 that just got

00:14:16,880 --> 00:14:20,160
programmed

00:14:17,839 --> 00:14:22,000
and then we can use that then to create

00:14:20,160 --> 00:14:24,320
a new i o page table using

00:14:22,000 --> 00:14:26,079
the i o page table library and that will

00:14:24,320 --> 00:14:28,240
give us a ttbr0

00:14:26,079 --> 00:14:29,680
or at least a page table with a physical

00:14:28,240 --> 00:14:30,959
address that we know

00:14:29,680 --> 00:14:32,320
and it will give it have the same

00:14:30,959 --> 00:14:34,639
configuration that's already been

00:14:32,320 --> 00:14:34,639
programmed

00:14:36,560 --> 00:14:39,680
then we're going to send that same

00:14:38,560 --> 00:14:42,240
configuration back

00:14:39,680 --> 00:14:44,079
into adreno smmu implementation and say

00:14:42,240 --> 00:14:46,639
please enable tcpr0

00:14:44,079 --> 00:14:48,000
so this will allow the ttpr 0 bit to be

00:14:46,639 --> 00:14:50,240
set we really don't want to be out there

00:14:48,000 --> 00:14:52,560
manipulating these registers on our own

00:14:50,240 --> 00:14:53,519
that's kind of a bad juju i know the gpu

00:14:52,560 --> 00:14:54,800
is going to do it but

00:14:53,519 --> 00:14:56,720
we don't want to be doing that inside

00:14:54,800 --> 00:14:58,880
the dm msm driver

00:14:56,720 --> 00:15:01,440
we want to keep the register programming

00:14:58,880 --> 00:15:03,199
all inside of the rms and the new driver

00:15:01,440 --> 00:15:05,120
uh so this is why we passed the same

00:15:03,199 --> 00:15:07,199
configuration back saying hey

00:15:05,120 --> 00:15:08,560
we've got this thing it's in ttpr0 would

00:15:07,199 --> 00:15:11,680
you please go ahead and enable

00:15:08,560 --> 00:15:15,680
ttbr0 for us and rms says great now

00:15:11,680 --> 00:15:17,760
our msmu is out of the picture um

00:15:15,680 --> 00:15:20,240
now we're going to do our normal process

00:15:17,760 --> 00:15:22,639
the process comes up it creates memory

00:15:20,240 --> 00:15:24,639
you know it maps the memory we map it

00:15:22,639 --> 00:15:26,959
back and forth back and forth all the

00:15:24,639 --> 00:15:28,720
you know just kind of a standard case of

00:15:26,959 --> 00:15:30,880
memory being created preparing to do a

00:15:28,720 --> 00:15:33,920
gpu operation

00:15:30,880 --> 00:15:34,160
um then when the pro when the instance

00:15:33,920 --> 00:15:37,199
is

00:15:34,160 --> 00:15:38,839
it goes on the gpu before we draw a

00:15:37,199 --> 00:15:41,199
do a submission for the for that

00:15:38,839 --> 00:15:42,800
instance uh a draw command or something

00:15:41,199 --> 00:15:43,680
else like that we will set the t to be

00:15:42,800 --> 00:15:46,480
our zero so we'll

00:15:43,680 --> 00:15:47,040
use the op code inside of the context

00:15:46,480 --> 00:15:48,480
pane or

00:15:47,040 --> 00:15:51,120
we'll use the op code inside of the

00:15:48,480 --> 00:15:52,880
command processor to set the ttbr that

00:15:51,120 --> 00:15:54,160
we got when we created the i o page

00:15:52,880 --> 00:15:56,720
table

00:15:54,160 --> 00:15:58,320
and set up all the registers and

00:15:56,720 --> 00:16:02,560
everything

00:15:58,320 --> 00:16:04,079
and go and we'll use that proceed

00:16:02,560 --> 00:16:06,160
do the operations and then when we're

00:16:04,079 --> 00:16:08,079
done with our memory we will unmap it

00:16:06,160 --> 00:16:10,079
inside of the i o page table

00:16:08,079 --> 00:16:12,079
the really the interest most interesting

00:16:10,079 --> 00:16:14,720
thing here is is that we will not be

00:16:12,079 --> 00:16:14,720
able to

00:16:15,680 --> 00:16:19,120
implicitly do a tlb flush from the io

00:16:17,839 --> 00:16:21,440
page table the reason why

00:16:19,120 --> 00:16:23,279
is because even if there is a way that

00:16:21,440 --> 00:16:23,920
we could get to the hooks to be able to

00:16:23,279 --> 00:16:25,839
do

00:16:23,920 --> 00:16:27,040
the tlb flush when we do it on map from

00:16:25,839 --> 00:16:28,880
now page table

00:16:27,040 --> 00:16:30,720
but we can't be sure that the power is

00:16:28,880 --> 00:16:32,160
enabled on the rms drive

00:16:30,720 --> 00:16:34,480
and what we don't want is we don't want

00:16:32,160 --> 00:16:37,440
the drm msm driver to be

00:16:34,480 --> 00:16:38,959
allocating and and managing clocks even

00:16:37,440 --> 00:16:40,639
though we kind of know the clocks

00:16:38,959 --> 00:16:41,360
because they're being used by the gpu

00:16:40,639 --> 00:16:43,040
itself

00:16:41,360 --> 00:16:44,399
we don't really want to break that

00:16:43,040 --> 00:16:46,959
barrier so

00:16:44,399 --> 00:16:48,399
when we do a tlb flush currently we're

00:16:46,959 --> 00:16:48,880
just going to use what i call the big

00:16:48,399 --> 00:16:51,199
hammer

00:16:48,880 --> 00:16:51,920
it's an ioma mu call it's an i'm an api

00:16:51,199 --> 00:16:54,959
call

00:16:51,920 --> 00:16:58,800
mmu tlb flush all and that will call

00:16:54,959 --> 00:17:01,600
into the um rms mmu domain

00:16:58,800 --> 00:17:02,240
and do a flush so it's a little bit

00:17:01,600 --> 00:17:03,920
hokey

00:17:02,240 --> 00:17:05,839
i guess you could say you know it's not

00:17:03,920 --> 00:17:06,799
as nice as having a more direct tlb

00:17:05,839 --> 00:17:09,839
flush

00:17:06,799 --> 00:17:11,760
um there are things we can do in the

00:17:09,839 --> 00:17:13,919
future there's uh we can construct

00:17:11,760 --> 00:17:16,319
basically a state machine to help us

00:17:13,919 --> 00:17:18,559
because every time we switch to tgbr0

00:17:16,319 --> 00:17:20,640
we implicitly do a tlb flush because

00:17:18,559 --> 00:17:23,600
obviously the new tlb is

00:17:20,640 --> 00:17:25,280
in effect the old one isn't um in theory

00:17:23,600 --> 00:17:26,959
it should be doing a tlb

00:17:25,280 --> 00:17:29,039
acid so it should be clearing by acid

00:17:26,959 --> 00:17:30,480
it's not it's a tlbi all

00:17:29,039 --> 00:17:32,080
so we can take advantage of that on

00:17:30,480 --> 00:17:33,360
current hardware to be able to just

00:17:32,080 --> 00:17:35,360
basically track

00:17:33,360 --> 00:17:37,760
memory know when it got flushed on the

00:17:35,360 --> 00:17:40,000
gpu and then just defer the frame

00:17:37,760 --> 00:17:41,360
um but that's you know there's a state

00:17:40,000 --> 00:17:42,480
machine there there's some complexity

00:17:41,360 --> 00:17:44,080
there so for now

00:17:42,480 --> 00:17:46,480
we're just using the big hammer every

00:17:44,080 --> 00:17:49,120
time we unmap we're flushing the tlb

00:17:46,480 --> 00:17:50,080
it's kind of sad but i think you know to

00:17:49,120 --> 00:17:53,600
get going

00:17:50,080 --> 00:17:56,240
it shouldn't be too terrible and

00:17:53,600 --> 00:17:56,720
we do this for every new process as long

00:17:56,240 --> 00:17:59,679
as the

00:17:56,720 --> 00:18:01,520
as long as there is an active process

00:17:59,679 --> 00:18:03,520
we're going to be creating new i o page

00:18:01,520 --> 00:18:04,480
tables we don't have to enable ttpr0

00:18:03,520 --> 00:18:06,559
every time

00:18:04,480 --> 00:18:09,039
as long as it's been enabled we can keep

00:18:06,559 --> 00:18:11,200
it we just keep creating things mapping

00:18:09,039 --> 00:18:12,880
go go go go and then finally when the

00:18:11,200 --> 00:18:15,200
last page table is freed

00:18:12,880 --> 00:18:17,440
and we don't have any any more things we

00:18:15,200 --> 00:18:20,400
will call with the no pointer back into

00:18:17,440 --> 00:18:21,679
ttp into the rms mini driver so we'll

00:18:20,400 --> 00:18:23,600
we'll call the same thing that enables

00:18:21,679 --> 00:18:25,440
ccpr0 with the null pointer

00:18:23,600 --> 00:18:26,559
that'll disable the ttpr0 so that we

00:18:25,440 --> 00:18:30,160
don't have to worry about there being a

00:18:26,559 --> 00:18:30,160
stale page table enough in the world

00:18:31,200 --> 00:18:34,240
so um

00:18:35,039 --> 00:18:40,240
this this is kind of

00:18:38,720 --> 00:18:42,640
this implementation has gone through

00:18:40,240 --> 00:18:43,600
some a lot of iterations uh we started

00:18:42,640 --> 00:18:45,600
off doing

00:18:43,600 --> 00:18:48,160
you know some sort of custom domain

00:18:45,600 --> 00:18:49,600
design uh we went into aux domains we've

00:18:48,160 --> 00:18:50,640
just been kind of going back and forth

00:18:49,600 --> 00:18:52,960
but eventually we

00:18:50,640 --> 00:18:55,280
all kind of agreed that this is pretty

00:18:52,960 --> 00:18:57,360
special for adreno smmu this is

00:18:55,280 --> 00:18:58,640
this is something that that really

00:18:57,360 --> 00:19:01,440
doesn't have a lot of interest

00:18:58,640 --> 00:19:02,880
other to other instances or other

00:19:01,440 --> 00:19:06,320
implementations of an arm

00:19:02,880 --> 00:19:07,760
of an rms mmu um so that's why we got

00:19:06,320 --> 00:19:09,760
into this situation where we started

00:19:07,760 --> 00:19:14,080
doing some more of this private memory

00:19:09,760 --> 00:19:15,919
so already in the rms mmu

00:19:14,080 --> 00:19:17,840
design there's the ability to create

00:19:15,919 --> 00:19:18,640
what they call implementation specific

00:19:17,840 --> 00:19:21,200
code

00:19:18,640 --> 00:19:22,720
so using compatible strings we can jump

00:19:21,200 --> 00:19:24,640
into things and that's how you can do

00:19:22,720 --> 00:19:26,160
workarounds or how you can do things for

00:19:24,640 --> 00:19:28,000
other processors

00:19:26,160 --> 00:19:29,440
um you know there's about qcom has a

00:19:28,000 --> 00:19:30,799
pretty big one um there's some other

00:19:29,440 --> 00:19:32,559
people have some too

00:19:30,799 --> 00:19:34,480
so we just kind of piggyback on that

00:19:32,559 --> 00:19:34,799
when you're creating a compatible string

00:19:34,480 --> 00:19:37,600
for

00:19:34,799 --> 00:19:38,000
for adreno smmu and it's kicking into an

00:19:37,600 --> 00:19:41,200
adreno

00:19:38,000 --> 00:19:41,520
smu implementation that is kind of i

00:19:41,200 --> 00:19:44,720
mean

00:19:41,520 --> 00:19:47,360
he uses it it kind of it's built on the

00:19:44,720 --> 00:19:48,320
the qcom implementation but because we

00:19:47,360 --> 00:19:49,919
kind of have different

00:19:48,320 --> 00:19:51,600
different parameters and everything we

00:19:49,919 --> 00:19:52,080
very pretty much quickly go our own path

00:19:51,600 --> 00:19:54,799
there's

00:19:52,080 --> 00:19:56,480
there's not a lot of share between the

00:19:54,799 --> 00:19:58,080
uh qcom implementation for the other

00:19:56,480 --> 00:19:59,679
smmu and ours

00:19:58,080 --> 00:20:01,440
uh some of the things we don't need some

00:19:59,679 --> 00:20:02,400
of them are workarounds we don't need so

00:20:01,440 --> 00:20:04,320
it's just kind of

00:20:02,400 --> 00:20:06,080
we just kind of slide off so it's q com

00:20:04,320 --> 00:20:07,600
it's in the cucumb file but it's it's in

00:20:06,080 --> 00:20:10,400
its own world

00:20:07,600 --> 00:20:13,120
um and then we had to create a new

00:20:10,400 --> 00:20:15,200
implementation hook inside of rms mmu

00:20:13,120 --> 00:20:16,640
for us to allocate the context bank so

00:20:15,200 --> 00:20:18,880
that's pretty simple if the function

00:20:16,640 --> 00:20:20,880
exists we call into it and then we do

00:20:18,880 --> 00:20:22,159
essentially the same thing that the the

00:20:20,880 --> 00:20:24,240
generic code does

00:20:22,159 --> 00:20:26,480
by looking up a bitmap in the in in a

00:20:24,240 --> 00:20:28,240
bitmap and finding an open page table

00:20:26,480 --> 00:20:30,559
or an open context bank the only

00:20:28,240 --> 00:20:32,880
difference being that if it is stream id

00:20:30,559 --> 00:20:35,760
0 then we know it's the gpu instance

00:20:32,880 --> 00:20:37,360
and we'll just return zero um then the

00:20:35,760 --> 00:20:38,720
next step would be to create a private

00:20:37,360 --> 00:20:40,400
interface so

00:20:38,720 --> 00:20:42,000
nearly everything else after this point

00:20:40,400 --> 00:20:44,640
will be through the private interface

00:20:42,000 --> 00:20:46,400
there won't be any i o meme domains

00:20:44,640 --> 00:20:48,799
attributes there won't be any sort of

00:20:46,400 --> 00:20:50,640
iom api calls so we had to set up a

00:20:48,799 --> 00:20:52,159
private interface for the gpu and the

00:20:50,640 --> 00:20:54,799
rms mmu

00:20:52,159 --> 00:20:55,919
and uh it was suggested that we do this

00:20:54,799 --> 00:20:58,000
as part of the device

00:20:55,919 --> 00:20:59,280
as part of the device truck so we we

00:20:58,000 --> 00:21:01,520
have access to the

00:20:59,280 --> 00:21:04,080
gpu device or the gpu platform device

00:21:01,520 --> 00:21:06,320
inside of the rms mmu when we attach it

00:21:04,080 --> 00:21:08,400
so then we're able to get the device

00:21:06,320 --> 00:21:10,640
data and then be able to cast it so that

00:21:08,400 --> 00:21:13,120
we can get to the rms and the new data

00:21:10,640 --> 00:21:14,880
and then our msmu data is a has a header

00:21:13,120 --> 00:21:16,159
file it's a shared header file

00:21:14,880 --> 00:21:17,679
there's a couple of function hooks in

00:21:16,159 --> 00:21:19,200
there one for us to get the current

00:21:17,679 --> 00:21:20,240
configuration one for us to set the

00:21:19,200 --> 00:21:21,760
configuration

00:21:20,240 --> 00:21:23,120
and i think we also have a cookie in

00:21:21,760 --> 00:21:24,000
there and some other things to be able

00:21:23,120 --> 00:21:26,640
to

00:21:24,000 --> 00:21:29,120
expand for the future so anytime the rms

00:21:26,640 --> 00:21:31,520
mmu driver is going to talk to it's

00:21:29,120 --> 00:21:33,280
the gpu or vice versa we'll end up using

00:21:31,520 --> 00:21:34,080
this instead of having to create you

00:21:33,280 --> 00:21:36,159
know a million

00:21:34,080 --> 00:21:37,440
domain attributes when we don't when we

00:21:36,159 --> 00:21:40,240
don't need them

00:21:37,440 --> 00:21:41,120
um then the next step would be to

00:21:40,240 --> 00:21:43,840
allocate

00:21:41,120 --> 00:21:45,760
and do split page tables inside of rms

00:21:43,840 --> 00:21:48,240
and mmu

00:21:45,760 --> 00:21:49,760
a long time ago will and robin will will

00:21:48,240 --> 00:21:51,600
deacon and robin murphy did a lot of the

00:21:49,760 --> 00:21:53,440
work to allow io page table to

00:21:51,600 --> 00:21:55,039
understand split page tables

00:21:53,440 --> 00:21:57,360
so we piggyback on that and it's

00:21:55,039 --> 00:21:59,440
basically just a matter of

00:21:57,360 --> 00:22:01,120
of configuring it so the the in the

00:21:59,440 --> 00:22:04,000
hardware that the the configuration for

00:22:01,120 --> 00:22:05,200
tdbr0 tv r1 are almost identical there's

00:22:04,000 --> 00:22:07,120
one

00:22:05,200 --> 00:22:08,880
really strange field that gets swizzled

00:22:07,120 --> 00:22:10,559
for some reason between the two

00:22:08,880 --> 00:22:12,640
but we can basically use the i o page

00:22:10,559 --> 00:22:14,400
table set up the correct tcr

00:22:12,640 --> 00:22:16,880
settings which is the register inside of

00:22:14,400 --> 00:22:19,120
the page table and program it

00:22:16,880 --> 00:22:21,360
um and then because we're a part of an

00:22:19,120 --> 00:22:25,600
arduino smu implementation

00:22:21,360 --> 00:22:27,120
the we set up tcbr1 by default forces 0

00:22:25,600 --> 00:22:29,440
and then that that automatically gets

00:22:27,120 --> 00:22:31,280
goes down into the into the generic code

00:22:29,440 --> 00:22:33,280
so it all just kind of works we we say

00:22:31,280 --> 00:22:34,880
we want it and they say okay fine we'll

00:22:33,280 --> 00:22:36,559
set it up for you

00:22:34,880 --> 00:22:38,880
um and then we needed to create the

00:22:36,559 --> 00:22:40,000
arduino smmu implementation itself so we

00:22:38,880 --> 00:22:41,760
need to

00:22:40,000 --> 00:22:43,679
create the hooks that we needed for the

00:22:41,760 --> 00:22:45,679
to interact with the rms and the driver

00:22:43,679 --> 00:22:48,240
we needed to do the sid matching

00:22:45,679 --> 00:22:49,840
and we need to do the um the private

00:22:48,240 --> 00:22:50,720
interface for the gpu and rms in the

00:22:49,840 --> 00:22:52,320
view

00:22:50,720 --> 00:22:54,080
and then finally the last the last

00:22:52,320 --> 00:22:56,640
bullet here is is basically

00:22:54,080 --> 00:22:57,760
the support we have for a6xx i skipped

00:22:56,640 --> 00:23:00,159
over a couple things

00:22:57,760 --> 00:23:01,919
um as is our want we like to to clean

00:23:00,159 --> 00:23:04,000
things up as we go along and do some

00:23:01,919 --> 00:23:05,440
other adjustments so the full series is

00:23:04,000 --> 00:23:07,120
listed at the bottom

00:23:05,440 --> 00:23:09,280
um i think it's actually been updated

00:23:07,120 --> 00:23:11,520
since uh it probably has been updated

00:23:09,280 --> 00:23:15,120
since this this has been recorded so

00:23:11,520 --> 00:23:17,039
um uh you can always

00:23:15,120 --> 00:23:18,240
check to see the latest version and

00:23:17,039 --> 00:23:20,799
hopefully um

00:23:18,240 --> 00:23:22,640
we'll see it merge soon uh it's gotten

00:23:20,799 --> 00:23:24,320
most of the reviews i think there's just

00:23:22,640 --> 00:23:26,480
a couple people need to sign off

00:23:24,320 --> 00:23:27,840
uh it's a big chunk of code but i i i

00:23:26,480 --> 00:23:30,159
feel really good about

00:23:27,840 --> 00:23:31,039
what we've done and the implementation

00:23:30,159 --> 00:23:34,080
we've gone for

00:23:31,039 --> 00:23:34,960
uh i've been trying to do this for for

00:23:34,080 --> 00:23:38,240
quite a while now

00:23:34,960 --> 00:23:39,679
um i feel strongly i think that this is

00:23:38,240 --> 00:23:41,520
even though the downstream driver has

00:23:39,679 --> 00:23:43,120
been doing it i i feel strongly that

00:23:41,520 --> 00:23:43,440
this is something that has an advantage

00:23:43,120 --> 00:23:47,600
for

00:23:43,440 --> 00:23:49,679
for for a lot of for the upstream gm

00:23:47,600 --> 00:23:51,279
gpu driver and all the other things and

00:23:49,679 --> 00:23:53,279
so um i'm

00:23:51,279 --> 00:23:56,400
excited to see it kind of come along uh

00:23:53,279 --> 00:23:58,080
but i i've noticed over time that

00:23:56,400 --> 00:23:59,919
it's been difficult to explain exactly

00:23:58,080 --> 00:24:01,679
what's going on in the gpu and exactly

00:23:59,919 --> 00:24:04,159
how everything fits together

00:24:01,679 --> 00:24:05,360
um so i'm glad to be able to provide a

00:24:04,159 --> 00:24:07,440
presentation to

00:24:05,360 --> 00:24:09,039
allow people to understand a little bit

00:24:07,440 --> 00:24:09,840
more about how it all kind of fits

00:24:09,039 --> 00:24:11,360
together

00:24:09,840 --> 00:24:12,559
and our intentions for doing this

00:24:11,360 --> 00:24:14,080
because this is kind of weird you know

00:24:12,559 --> 00:24:16,240
it's kind of this

00:24:14,080 --> 00:24:18,000
you know this this is this gray area

00:24:16,240 --> 00:24:20,640
between rms mmu and

00:24:18,000 --> 00:24:21,520
the gpu um so hopefully it was

00:24:20,640 --> 00:24:24,960
informative

00:24:21,520 --> 00:24:26,240
so uh finally we have some stretch goals

00:24:24,960 --> 00:24:29,440
for the future

00:24:26,240 --> 00:24:31,360
uh one of the other interesting quirks

00:24:29,440 --> 00:24:33,600
that the gpu has that others don't

00:24:31,360 --> 00:24:36,880
is that we have multiple things that are

00:24:33,600 --> 00:24:39,440
accessing the gpu at the same time

00:24:36,880 --> 00:24:41,600
and so um the gpu could be doing a

00:24:39,440 --> 00:24:43,360
shader and it could be accessing memory

00:24:41,600 --> 00:24:44,720
and we have the cp and it could be doing

00:24:43,360 --> 00:24:46,400
its own thing and it could be accessing

00:24:44,720 --> 00:24:47,600
memory so if the shader faults for some

00:24:46,400 --> 00:24:48,000
reason they're out of bounds or

00:24:47,600 --> 00:24:50,480
something

00:24:48,000 --> 00:24:51,279
like that if the current under the

00:24:50,480 --> 00:24:53,600
current default

00:24:51,279 --> 00:24:56,240
configuration of the smu we will

00:24:53,600 --> 00:24:58,880
terminate all pending operations

00:24:56,240 --> 00:25:01,120
um on a fault which basically is

00:24:58,880 --> 00:25:03,760
essentially death for the cp because

00:25:01,120 --> 00:25:04,240
if the shader falls that transaction is

00:25:03,760 --> 00:25:06,240
going to be

00:25:04,240 --> 00:25:07,919
going to get it's going to be terminated

00:25:06,240 --> 00:25:09,039
but then there's probably a command

00:25:07,919 --> 00:25:12,559
processor

00:25:09,039 --> 00:25:14,400
or a micro code uh lookup

00:25:12,559 --> 00:25:16,240
pending in the in in the bus because

00:25:14,400 --> 00:25:17,039
that's just kind of generally that's how

00:25:16,240 --> 00:25:19,039
it happens

00:25:17,039 --> 00:25:21,440
so if every transaction in the bus is

00:25:19,039 --> 00:25:23,360
terminated it basically is is a hang

00:25:21,440 --> 00:25:24,960
there's just no way to recover so if you

00:25:23,360 --> 00:25:26,720
if you want to be able to allow the

00:25:24,960 --> 00:25:29,360
shader to fall without really

00:25:26,720 --> 00:25:30,000
breaking the gpu we need to be able to

00:25:29,360 --> 00:25:32,720
allow

00:25:30,000 --> 00:25:33,679
um pending transactions to be retried on

00:25:32,720 --> 00:25:35,760
the fault

00:25:33,679 --> 00:25:38,320
uh so there's basically a there's a

00:25:35,760 --> 00:25:41,039
setting for that in the rms mmu driver

00:25:38,320 --> 00:25:42,400
but with our previous implementation so

00:25:41,039 --> 00:25:44,960
if we know where an rms

00:25:42,400 --> 00:25:46,080
adreno smg driver we can set that bit

00:25:44,960 --> 00:25:48,159
and we don't have to

00:25:46,080 --> 00:25:49,279
negotiate with the other arm clients to

00:25:48,159 --> 00:25:52,159
allow this

00:25:49,279 --> 00:25:53,760
um that'll also block this this whole

00:25:52,159 --> 00:25:55,919
interface will also provide us an

00:25:53,760 --> 00:25:57,279
opportunity to do expanded fault

00:25:55,919 --> 00:25:59,520
debugging so

00:25:57,279 --> 00:26:00,799
um on a fault maybe you want to say

00:25:59,520 --> 00:26:02,320
where it happened maybe you want to say

00:26:00,799 --> 00:26:03,440
well it was active at the time maybe you

00:26:02,320 --> 00:26:04,480
want to have the client

00:26:03,440 --> 00:26:06,480
you know something a little bit more

00:26:04,480 --> 00:26:08,559
than there was a page fault at this

00:26:06,480 --> 00:26:10,799
address and then have to assume

00:26:08,559 --> 00:26:11,760
and then uh there's also desire to be

00:26:10,799 --> 00:26:14,240
able to stall

00:26:11,760 --> 00:26:16,080
the gpu on a fault so basically stop the

00:26:14,240 --> 00:26:17,919
gpu where in its tracks

00:26:16,080 --> 00:26:19,360
when a page fault occurs which would

00:26:17,919 --> 00:26:20,320
force the dev core dump which would

00:26:19,360 --> 00:26:21,840
allow us to

00:26:20,320 --> 00:26:23,360
analyze the situation and try and

00:26:21,840 --> 00:26:24,000
determine whether where the page fault

00:26:23,360 --> 00:26:25,520
happened

00:26:24,000 --> 00:26:27,200
so these are stretch goals i think that

00:26:25,520 --> 00:26:27,919
once you have a private interface in

00:26:27,200 --> 00:26:30,159
place

00:26:27,919 --> 00:26:30,960
and you have everything uh that you need

00:26:30,159 --> 00:26:33,520
to do

00:26:30,960 --> 00:26:35,279
it's pretty simple to to expand on this

00:26:33,520 --> 00:26:36,640
and it's easy to expand on this without

00:26:35,279 --> 00:26:39,760
having to

00:26:36,640 --> 00:26:42,960
really modify a lot in the arm smmu

00:26:39,760 --> 00:26:45,440
generic code or in the immediate api

00:26:42,960 --> 00:26:46,960
so finally um lots of things there's

00:26:45,440 --> 00:26:48,240
been a lot of people over the time that

00:26:46,960 --> 00:26:51,360
have worked on this

00:26:48,240 --> 00:26:52,960
um there's some people that that worked

00:26:51,360 --> 00:26:53,760
on this the implementation from the

00:26:52,960 --> 00:26:55,679
beginning

00:26:53,760 --> 00:26:56,960
uh rob has been really helpful and

00:26:55,679 --> 00:26:57,600
instrumental in getting some of these

00:26:56,960 --> 00:26:59,600
going

00:26:57,600 --> 00:27:01,360
uh robin and will have been very patient

00:26:59,600 --> 00:27:03,919
with us over the years

00:27:01,360 --> 00:27:04,880
um and then i special shout out to

00:27:03,919 --> 00:27:06,960
bejorn who

00:27:04,880 --> 00:27:08,240
i kind of sidetracked one of the things

00:27:06,960 --> 00:27:09,760
he was working on

00:27:08,240 --> 00:27:11,039
um i think in the end we'll kind of

00:27:09,760 --> 00:27:12,320
everything will kind of come together

00:27:11,039 --> 00:27:14,159
but uh

00:27:12,320 --> 00:27:15,840
um there were some other people that

00:27:14,159 --> 00:27:17,679
were trying to do some things in the rms

00:27:15,840 --> 00:27:18,960
and the new driver to support

00:27:17,679 --> 00:27:20,399
some of the targets and i kind of

00:27:18,960 --> 00:27:22,240
derailed that but they've been very

00:27:20,399 --> 00:27:23,600
gracious in helping me out

00:27:22,240 --> 00:27:25,200
and then there's been lots of other

00:27:23,600 --> 00:27:25,840
people over the years that have looked

00:27:25,200 --> 00:27:28,799
in on this

00:27:25,840 --> 00:27:30,000
and uh given given us advice or given us

00:27:28,799 --> 00:27:33,360
given us inspiration

00:27:30,000 --> 00:27:38,960
so that's the presentation

00:27:33,360 --> 00:27:38,960

YouTube URL: https://www.youtube.com/watch?v=Az6d4UXzhg4


