Title: LVC20 102 Interrupt sub system in ARM boards using Xilinx Zynq Board
Publication date: 2020-10-09
Playlist: Linaro Virtual Connect 2020
Description: 
	Interrupt sub system in ARM boards
This session describes all layers in interrupt sub system starting from ARM Architecture (GIC), Interrupt sub system in Linux kernel , Interfacing of ARM arch. with Linux supported Interrupt sub system.

For the presentation see: https://static.linaro.org/connect/lvc20/other_files/LVC20-102-0.pptx
Captions: 
	00:00:00,399 --> 00:00:06,480
uh good afternoon uh this is satish

00:00:04,160 --> 00:00:08,559
uh today i am going to present the one

00:00:06,480 --> 00:00:10,240
of the session with respect to the

00:00:08,559 --> 00:00:12,960
linux kernel part of the interrupt

00:00:10,240 --> 00:00:14,799
subsystem in onboards using jailing

00:00:12,960 --> 00:00:18,160
board

00:00:14,799 --> 00:00:21,359
so this is basically we are trying to

00:00:18,160 --> 00:00:22,560
capture the one of the platform device

00:00:21,359 --> 00:00:24,480
module which is called interrupt

00:00:22,560 --> 00:00:26,560
system earlier we have discussed about

00:00:24,480 --> 00:00:29,199
the smp subsystem in the

00:00:26,560 --> 00:00:30,080
um with respect to the g board i think

00:00:29,199 --> 00:00:33,440
in the

00:00:30,080 --> 00:00:35,760
last year so i tried to capture now

00:00:33,440 --> 00:00:36,640
today the interrupts are system so part

00:00:35,760 --> 00:00:38,800
of that

00:00:36,640 --> 00:00:39,680
i'm just trying to capture a lot of

00:00:38,800 --> 00:00:41,920
slides

00:00:39,680 --> 00:00:44,079
uh part of that index part i've added

00:00:41,920 --> 00:00:45,920
the basics of interrupt handling linked

00:00:44,079 --> 00:00:47,840
up call flow in organic systems

00:00:45,920 --> 00:00:49,680
interrupt subsystem in linux kernel irq

00:00:47,840 --> 00:00:52,160
domain map in linux and the

00:00:49,680 --> 00:00:53,280
isr execution in on course and part of

00:00:52,160 --> 00:00:56,320
the summary and

00:00:53,280 --> 00:00:58,320
people so uh

00:00:56,320 --> 00:01:00,320
let's start from the interrupt handling

00:00:58,320 --> 00:01:02,719
in any embedded system or a basic

00:01:00,320 --> 00:01:03,440
device how it works so from a system

00:01:02,719 --> 00:01:06,720
point of view

00:01:03,440 --> 00:01:08,400
any peripheral device or any io device

00:01:06,720 --> 00:01:10,720
takes one interrupt line on the system

00:01:08,400 --> 00:01:13,680
bus to start the interrupt sequence

00:01:10,720 --> 00:01:15,360
so once the cpu is ready to handle and

00:01:13,680 --> 00:01:17,920
it's ready to acknowledge

00:01:15,360 --> 00:01:19,280
acknowledge that signal on the bus then

00:01:17,920 --> 00:01:21,600
yes once that

00:01:19,280 --> 00:01:22,880
interrupt vector number is ready then we

00:01:21,600 --> 00:01:24,560
can the cpu

00:01:22,880 --> 00:01:26,080
i mean like just take the removes the

00:01:24,560 --> 00:01:28,880
interpreter from the bus

00:01:26,080 --> 00:01:31,040
and saves it temporarily and cpu pushes

00:01:28,880 --> 00:01:32,720
the program counter and psw on the stack

00:01:31,040 --> 00:01:34,960
so this is all the basic one that

00:01:32,720 --> 00:01:36,159
everyone knows now once we are coming to

00:01:34,960 --> 00:01:39,280
the

00:01:36,159 --> 00:01:40,000
actual one uh anyway i have added one

00:01:39,280 --> 00:01:41,920
more slide for

00:01:40,000 --> 00:01:43,520
the basics of input handling instead of

00:01:41,920 --> 00:01:46,079
maskable non-muscle

00:01:43,520 --> 00:01:47,040
edge triggering level trigger interrupts

00:01:46,079 --> 00:01:48,799
and

00:01:47,040 --> 00:01:50,960
the mostly what we are going to use

00:01:48,799 --> 00:01:52,640
shade peripheral private peripheral and

00:01:50,960 --> 00:01:55,600
the software generating tips

00:01:52,640 --> 00:01:56,880
the last three we mostly see in our arm

00:01:55,600 --> 00:01:59,520
architecture right

00:01:56,880 --> 00:02:01,520
so because when we see that uh shade

00:01:59,520 --> 00:02:03,360
purple interrupts with respect to the

00:02:01,520 --> 00:02:05,680
device tree we can check out from the

00:02:03,360 --> 00:02:07,920
trm whatever the number we are providing

00:02:05,680 --> 00:02:10,399
that is a kind of plus 32 number it will

00:02:07,920 --> 00:02:13,599
come like whatever the actual irq

00:02:10,399 --> 00:02:15,599
plus 32 will be added to the spi and the

00:02:13,599 --> 00:02:17,040
private particular will be added as it

00:02:15,599 --> 00:02:18,319
is right

00:02:17,040 --> 00:02:20,239
so that is the difference that we can

00:02:18,319 --> 00:02:21,680
see between the shared peripheral and

00:02:20,239 --> 00:02:22,800
the private parameter and the software

00:02:21,680 --> 00:02:25,280
generate interrupt is the one

00:02:22,800 --> 00:02:26,319
that which is actually coming from the

00:02:25,280 --> 00:02:29,680
other side

00:02:26,319 --> 00:02:31,360
so now uh actually we are starting the

00:02:29,680 --> 00:02:33,680
actual interrupt call flow in the arm

00:02:31,360 --> 00:02:36,720
linux systems so i have given a diagram

00:02:33,680 --> 00:02:38,480
where i try to capture how the actual

00:02:36,720 --> 00:02:41,280
flow will start from the

00:02:38,480 --> 00:02:43,360
independent kernel to the dependent or

00:02:41,280 --> 00:02:43,840
the platform dependent kernel towards

00:02:43,360 --> 00:02:46,319
the

00:02:43,840 --> 00:02:48,239
arm cpu core so i have mentioned like

00:02:46,319 --> 00:02:49,680
one one external device any external

00:02:48,239 --> 00:02:52,879
device which is going to

00:02:49,680 --> 00:02:54,959
request an irq with the help of division

00:02:52,879 --> 00:02:55,920
underscore request rq or request thread

00:02:54,959 --> 00:02:57,360
irq whatever

00:02:55,920 --> 00:03:00,239
i mean to a request you will be

00:02:57,360 --> 00:03:02,879
internally calling request thread irq

00:03:00,239 --> 00:03:03,760
that will be going towards the hardware

00:03:02,879 --> 00:03:06,480
i have to chip

00:03:03,760 --> 00:03:07,440
we can say in this presentation i'm

00:03:06,480 --> 00:03:09,680
taking the

00:03:07,440 --> 00:03:11,840
example of zinc irq controller but

00:03:09,680 --> 00:03:15,519
anyway we can take any hardware irq

00:03:11,840 --> 00:03:17,040
it can be you just buy a lpc2138 board

00:03:15,519 --> 00:03:19,360
or some people uses

00:03:17,040 --> 00:03:21,040
regular gic only as an irq controller

00:03:19,360 --> 00:03:23,200
and part of that

00:03:21,040 --> 00:03:25,840
so this request irq will be going

00:03:23,200 --> 00:03:28,000
through our linux irq subsystem

00:03:25,840 --> 00:03:29,280
from that irq subsystem it will go to

00:03:28,000 --> 00:03:31,040
the linux

00:03:29,280 --> 00:03:32,799
irq domain mapping from there it will

00:03:31,040 --> 00:03:34,959
enter into the irq controller

00:03:32,799 --> 00:03:36,239
so that is the hardware irq controller

00:03:34,959 --> 00:03:39,280
that having a lot of

00:03:36,239 --> 00:03:40,879
pins actually if there's p0 to p7 pins

00:03:39,280 --> 00:03:42,480
there is a mixing of the pins will be

00:03:40,879 --> 00:03:45,599
presented

00:03:42,480 --> 00:03:46,000
one of the pin from the device so that

00:03:45,599 --> 00:03:49,120
device

00:03:46,000 --> 00:03:50,959
will be enable the pin either it is p0

00:03:49,120 --> 00:03:52,400
or to the p7 whatever the pin

00:03:50,959 --> 00:03:54,480
so correspondingly the interrupt

00:03:52,400 --> 00:03:56,480
generated by the irq controller

00:03:54,480 --> 00:03:57,519
the same interrupt pin will be

00:03:56,480 --> 00:04:00,159
propagated

00:03:57,519 --> 00:04:02,080
to the s4c part of that soc we are

00:04:00,159 --> 00:04:02,560
entering into the corresponding gpio

00:04:02,080 --> 00:04:04,239
port

00:04:02,560 --> 00:04:05,599
which will be connected to my interrupt

00:04:04,239 --> 00:04:08,799
controller so

00:04:05,599 --> 00:04:09,760
because the gac is connected to our arm

00:04:08,799 --> 00:04:12,640
core right because

00:04:09,760 --> 00:04:13,360
if we see that arm core we can see that

00:04:12,640 --> 00:04:14,879
there are two

00:04:13,360 --> 00:04:17,199
or four cores whatever the number of

00:04:14,879 --> 00:04:18,239
cores below that we have an mmu and one

00:04:17,199 --> 00:04:21,120
gic

00:04:18,239 --> 00:04:22,800
so this gpio irq will be loaded will be

00:04:21,120 --> 00:04:24,320
connected to the gac which is of our

00:04:22,800 --> 00:04:26,400
generic interrupt controller

00:04:24,320 --> 00:04:28,240
which is holding the vector table

00:04:26,400 --> 00:04:29,520
actually and that factor table holds the

00:04:28,240 --> 00:04:31,919
vector addresses

00:04:29,520 --> 00:04:32,720
which internally takes off actual irq

00:04:31,919 --> 00:04:35,199
handler

00:04:32,720 --> 00:04:36,880
so the same thing we will try to capture

00:04:35,199 --> 00:04:39,280
each part of this diagram

00:04:36,880 --> 00:04:40,080
what exactly this device and request iq

00:04:39,280 --> 00:04:42,960
contains

00:04:40,080 --> 00:04:45,520
and what this irk chip contains and the

00:04:42,960 --> 00:04:46,720
internally the house the gpio 5 irq or

00:04:45,520 --> 00:04:49,840
whatever it can be gpa

00:04:46,720 --> 00:04:52,560
4 which are the gpu port used

00:04:49,840 --> 00:04:53,759
and in between of course the actual

00:04:52,560 --> 00:04:56,320
interrupt mechanism

00:04:53,759 --> 00:04:57,120
from the gic and in between there is uh

00:04:56,320 --> 00:05:00,400
in the

00:04:57,120 --> 00:05:02,000
irq subsystem how the linux irq

00:05:00,400 --> 00:05:02,720
subsystem the actual function calls it

00:05:02,000 --> 00:05:05,360
maintains

00:05:02,720 --> 00:05:06,320
in the domain mapping so that that are

00:05:05,360 --> 00:05:08,160
in between

00:05:06,320 --> 00:05:11,840
the external device to the hardware irq

00:05:08,160 --> 00:05:15,520
controller so we are feeling a set of

00:05:11,840 --> 00:05:16,880
uh missing things because of not the

00:05:15,520 --> 00:05:18,639
actual presentation maybe we can

00:05:16,880 --> 00:05:19,600
showcase here i don't know you can see

00:05:18,639 --> 00:05:22,800
my

00:05:19,600 --> 00:05:25,919
mouse or not but yes my plan is like

00:05:22,800 --> 00:05:28,560
in between there is an irq a subsystem

00:05:25,919 --> 00:05:30,479
which is a part of holding set of

00:05:28,560 --> 00:05:31,360
structures which will load all the irq

00:05:30,479 --> 00:05:33,520
descriptors

00:05:31,360 --> 00:05:34,880
into the action and from there it will

00:05:33,520 --> 00:05:36,320
go to the domain map

00:05:34,880 --> 00:05:38,960
from there it will go to the irq

00:05:36,320 --> 00:05:42,400
controller right

00:05:38,960 --> 00:05:42,720
so now from the inter call flow the same

00:05:42,400 --> 00:05:45,680
one

00:05:42,720 --> 00:05:47,120
i'm continuing uh from the platform

00:05:45,680 --> 00:05:49,199
dependent kernel

00:05:47,120 --> 00:05:51,520
external device that means io device

00:05:49,199 --> 00:05:52,960
changes the level on the p5 pin

00:05:51,520 --> 00:05:54,400
making the zinc irq controller to

00:05:52,960 --> 00:05:56,560
generate the interrupt interrupt from

00:05:54,400 --> 00:05:57,440
the zinc irk is connected to the gpu for

00:05:56,560 --> 00:06:00,560
ip core

00:05:57,440 --> 00:06:03,039
inside of soc and it uses line 30 of the

00:06:00,560 --> 00:06:03,600
gpa 5 module to modify the cpu for the

00:06:03,039 --> 00:06:05,440
inter

00:06:03,600 --> 00:06:07,199
whatever whatever i have explained in

00:06:05,440 --> 00:06:09,039
the earlier

00:06:07,199 --> 00:06:10,960
diagram the same thing will be connected

00:06:09,039 --> 00:06:13,759
here and the gpao 5

00:06:10,960 --> 00:06:16,639
acts as input control and it's cascade

00:06:13,759 --> 00:06:19,039
to gac part of the actual arm code

00:06:16,639 --> 00:06:21,360
now we can see that actually how it is

00:06:19,039 --> 00:06:22,880
generating from the soc to the irq

00:06:21,360 --> 00:06:25,759
controller if you see that

00:06:22,880 --> 00:06:28,560
this is the input so this input can be

00:06:25,759 --> 00:06:31,520
either p0 pin or it can be p7 pin

00:06:28,560 --> 00:06:33,600
so there are set of inputs each device

00:06:31,520 --> 00:06:36,160
will be connected to one of these inputs

00:06:33,600 --> 00:06:38,000
so that will be connected from i to c

00:06:36,160 --> 00:06:39,840
and that i2c will rise that okay this

00:06:38,000 --> 00:06:43,759
particular pin has been

00:06:39,840 --> 00:06:46,080
coming from the irq and mapping to the

00:06:43,759 --> 00:06:48,240
other side of the i2c where we are able

00:06:46,080 --> 00:06:49,280
to generate that corresponding maxing in

00:06:48,240 --> 00:06:51,199
your identifying

00:06:49,280 --> 00:06:52,479
because we know that the number of irk

00:06:51,199 --> 00:06:53,919
is present on the hardware side are

00:06:52,479 --> 00:06:56,160
limited compared to the

00:06:53,919 --> 00:06:58,000
higher numbers generated on the linux

00:06:56,160 --> 00:07:03,680
kernel side so that will be

00:06:58,000 --> 00:07:06,080
made to this pin maximum okay

00:07:03,680 --> 00:07:07,440
now the same i have explained here the

00:07:06,080 --> 00:07:08,240
irq control will generate interrupt on

00:07:07,440 --> 00:07:10,240
the inter pin

00:07:08,240 --> 00:07:11,440
with the change of voltage levels on p0

00:07:10,240 --> 00:07:14,479
to p7 pins

00:07:11,440 --> 00:07:16,319
the driver can read the shadows of p0 to

00:07:14,479 --> 00:07:18,080
pc1 pins any one of that

00:07:16,319 --> 00:07:19,360
and it will generate the separate

00:07:18,080 --> 00:07:22,080
interrupt for each of

00:07:19,360 --> 00:07:23,520
p0 to p7 pins and this driver acts as an

00:07:22,080 --> 00:07:26,880
interrupt controller

00:07:23,520 --> 00:07:28,720
then now there's the dtc registration so

00:07:26,880 --> 00:07:30,880
here i'm trying to capture all these

00:07:28,720 --> 00:07:31,759
slides with respect to the platform

00:07:30,880 --> 00:07:33,280
dependent

00:07:31,759 --> 00:07:35,680
so once we go to the platform

00:07:33,280 --> 00:07:38,000
independent that's a different story how

00:07:35,680 --> 00:07:39,680
actually the irq subsystem which is

00:07:38,000 --> 00:07:40,560
common to everyone that will be coming

00:07:39,680 --> 00:07:43,599
into picture

00:07:40,560 --> 00:07:45,199
so from this platform dependent part yes

00:07:43,599 --> 00:07:47,120
the dtc file does

00:07:45,199 --> 00:07:49,440
the zinc irb controller are very

00:07:47,120 --> 00:07:51,599
specific to the zinc board right

00:07:49,440 --> 00:07:52,960
so part of the tdc registration we are

00:07:51,599 --> 00:07:54,639
mentioning here

00:07:52,960 --> 00:07:57,520
for the device this device is nothing

00:07:54,639 --> 00:08:00,240
but the external device which is exactly

00:07:57,520 --> 00:08:00,879
expecting the irq to be handled with

00:08:00,240 --> 00:08:03,680
this guy

00:08:00,879 --> 00:08:04,879
so that is being maintained with zinc ir

00:08:03,680 --> 00:08:07,120
controller or

00:08:04,879 --> 00:08:10,319
whatever the name of that uh from the

00:08:07,120 --> 00:08:13,680
dtsa we will add it in this dot ddc file

00:08:10,319 --> 00:08:14,240
the type of the sticker at the level

00:08:13,680 --> 00:08:17,280
taken

00:08:14,240 --> 00:08:18,639
most probably it is triggering only so

00:08:17,280 --> 00:08:20,479
the type of the interrupt we are

00:08:18,639 --> 00:08:23,599
mentioning in the dtc file

00:08:20,479 --> 00:08:26,560
with this we can say that

00:08:23,599 --> 00:08:27,440
uh the internal part of uh platform

00:08:26,560 --> 00:08:30,000
dependent

00:08:27,440 --> 00:08:31,680
and then when when come to the irq chip

00:08:30,000 --> 00:08:34,000
so when entropy is right

00:08:31,680 --> 00:08:35,360
raised cpu is input condensed in ga

00:08:34,000 --> 00:08:38,320
synthetic handler

00:08:35,360 --> 00:08:38,880
so once if there is any interrupt

00:08:38,320 --> 00:08:41,279
changes

00:08:38,880 --> 00:08:42,000
then the mod will change from the user

00:08:41,279 --> 00:08:44,880
mode to the

00:08:42,000 --> 00:08:46,080
svc mode are svc to mod to the user mode

00:08:44,880 --> 00:08:48,320
we can say that uh

00:08:46,080 --> 00:08:49,200
kernel mode internally it is supervisory

00:08:48,320 --> 00:08:51,360
mode we will

00:08:49,200 --> 00:08:52,959
see that how with the different types of

00:08:51,360 --> 00:08:54,800
modes the vector table

00:08:52,959 --> 00:08:56,080
and the enter dispatcher how it works

00:08:54,800 --> 00:08:58,399
inside the gac

00:08:56,080 --> 00:08:59,920
but yeah from the irq controller

00:08:58,399 --> 00:09:00,720
perspective hardware directory control

00:08:59,920 --> 00:09:02,640
perspective

00:09:00,720 --> 00:09:04,800
we have a generic functionalities which

00:09:02,640 --> 00:09:07,519
is of gac handle irq

00:09:04,800 --> 00:09:08,880
which will call handle domain irq and

00:09:07,519 --> 00:09:12,720
intern calls the

00:09:08,880 --> 00:09:12,720
generic handle irq

00:09:13,120 --> 00:09:16,720
okay and then now we will come to this

00:09:15,519 --> 00:09:20,800
plot

00:09:16,720 --> 00:09:22,800
from independent kernel so here

00:09:20,800 --> 00:09:24,399
in the very beginning like from the

00:09:22,800 --> 00:09:25,360
kernel starting point of view when the

00:09:24,399 --> 00:09:26,959
linux boots

00:09:25,360 --> 00:09:28,399
the start kernel function calls the

00:09:26,959 --> 00:09:30,720
early arc unit

00:09:28,399 --> 00:09:31,680
which will internally call the r pro

00:09:30,720 --> 00:09:34,800
banner cues

00:09:31,680 --> 00:09:37,279
which will allocate irq

00:09:34,800 --> 00:09:39,120
descriptor structure for each argus by

00:09:37,279 --> 00:09:39,839
calling the allocation of the descriptor

00:09:39,120 --> 00:09:42,240
function

00:09:39,839 --> 00:09:43,680
so this will be internally calling for

00:09:42,240 --> 00:09:47,279
number of irqs

00:09:43,680 --> 00:09:49,360
those areas each irq action will be

00:09:47,279 --> 00:09:50,480
internally generated that we can see

00:09:49,360 --> 00:09:52,640
because these are all

00:09:50,480 --> 00:09:53,600
platform independence means these are

00:09:52,640 --> 00:09:55,519
internally

00:09:53,600 --> 00:09:57,040
i mean these are basically the basic

00:09:55,519 --> 00:09:58,880
linux irq subsystem

00:09:57,040 --> 00:10:00,959
the earlier slides which we are talking

00:09:58,880 --> 00:10:02,720
about is the different platform

00:10:00,959 --> 00:10:04,640
dependent and this is of independent

00:10:02,720 --> 00:10:06,880
part so these are all common

00:10:04,640 --> 00:10:09,120
call sequence which we are going to see

00:10:06,880 --> 00:10:09,120
now

00:10:11,040 --> 00:10:15,120
now uh now from the interrupt subsystem

00:10:14,079 --> 00:10:17,279
in the linux kernel

00:10:15,120 --> 00:10:18,560
i have added one more slide here which

00:10:17,279 --> 00:10:20,800
is going to the

00:10:18,560 --> 00:10:22,079
set handle irq from the jailing center

00:10:20,800 --> 00:10:25,440
control of init

00:10:22,079 --> 00:10:27,760
will go to the set handle irq

00:10:25,440 --> 00:10:29,519
and if you are coming to here we can see

00:10:27,760 --> 00:10:31,680
that init main.c

00:10:29,519 --> 00:10:33,600
which is part of the first kernel from

00:10:31,680 --> 00:10:34,399
the start kernel it will go to the setup

00:10:33,600 --> 00:10:37,360
architecture

00:10:34,399 --> 00:10:39,680
which is part of arc or mmu dot c from

00:10:37,360 --> 00:10:43,279
there it will go to the paging in it

00:10:39,680 --> 00:10:45,279
paging in it function and

00:10:43,279 --> 00:10:46,640
from the placing in it if you go to the

00:10:45,279 --> 00:10:48,560
device maps in it

00:10:46,640 --> 00:10:50,399
and then it will go to the early trap in

00:10:48,560 --> 00:10:52,480
it okay

00:10:50,399 --> 00:10:54,560
so this is the basic uh call structure

00:10:52,480 --> 00:10:56,959
over there from the

00:10:54,560 --> 00:10:58,640
from the platform independent kernel and

00:10:56,959 --> 00:11:01,040
now let's come to this

00:10:58,640 --> 00:11:01,760
uh the actual structures been provided

00:11:01,040 --> 00:11:04,560
out there

00:11:01,760 --> 00:11:05,200
the irq descriptor the chip and the

00:11:04,560 --> 00:11:08,160
action

00:11:05,200 --> 00:11:09,440
so i just captured that structures which

00:11:08,160 --> 00:11:10,320
because these three are the main

00:11:09,440 --> 00:11:12,880
structures used

00:11:10,320 --> 00:11:14,720
in the irq subsystem of course there are

00:11:12,880 --> 00:11:18,000
other lot of stretches

00:11:14,720 --> 00:11:20,480
which i have not added here but yes

00:11:18,000 --> 00:11:21,519
there are uh the minimum uh the

00:11:20,480 --> 00:11:23,760
important structures

00:11:21,519 --> 00:11:25,680
are these three which will maintains the

00:11:23,760 --> 00:11:26,839
arc descriptor requires an area of

00:11:25,680 --> 00:11:30,000
higher

00:11:26,839 --> 00:11:30,959
descriptors and it will be calling irq

00:11:30,000 --> 00:11:33,760
chip and the

00:11:30,959 --> 00:11:34,800
action so this irq action will load for

00:11:33,760 --> 00:11:36,560
each

00:11:34,800 --> 00:11:39,200
handler function it will be added into

00:11:36,560 --> 00:11:42,000
the descriptor which are captured here

00:11:39,200 --> 00:11:43,360
so this is a irq chip which will be

00:11:42,000 --> 00:11:45,600
showcasing that

00:11:43,360 --> 00:11:47,279
start interrupt close interrupt enable

00:11:45,600 --> 00:11:49,360
enter prohibit interrupt and

00:11:47,279 --> 00:11:51,519
there are other functionalities provided

00:11:49,360 --> 00:11:55,040
by this irq chip

00:11:51,519 --> 00:11:57,279
and after this we can see that ir action

00:11:55,040 --> 00:11:58,160
this will be taking care of the actual

00:11:57,279 --> 00:11:59,839
handler

00:11:58,160 --> 00:12:02,320
which we are registering in the request

00:11:59,839 --> 00:12:03,680
iq which where the second document what

00:12:02,320 --> 00:12:06,079
we are giving the handler

00:12:03,680 --> 00:12:07,519
that handler will be taken care by this

00:12:06,079 --> 00:12:10,320
user registered handler

00:12:07,519 --> 00:12:11,279
user rigid handler which is of irq

00:12:10,320 --> 00:12:13,440
action

00:12:11,279 --> 00:12:14,480
structures first member we can see that

00:12:13,440 --> 00:12:16,800
irq handler

00:12:14,480 --> 00:12:18,240
underscore t handler that is actually

00:12:16,800 --> 00:12:21,200
the one coming from the

00:12:18,240 --> 00:12:22,639
request second argument so these three

00:12:21,200 --> 00:12:24,560
are the one thing and

00:12:22,639 --> 00:12:25,760
so this is the actual request which we

00:12:24,560 --> 00:12:27,519
usually see that

00:12:25,760 --> 00:12:30,560
any io device will be registered with

00:12:27,519 --> 00:12:33,600
this so this is the basic one

00:12:30,560 --> 00:12:35,279
so now i just captured a kind of a

00:12:33,600 --> 00:12:38,560
diagram next representation

00:12:35,279 --> 00:12:42,320
to showcase that descriptor is calling

00:12:38,560 --> 00:12:42,320
rq action and the irq chip

00:12:43,200 --> 00:12:47,200
and then now we will go to the next

00:12:44,959 --> 00:12:49,440
level of irq domain map

00:12:47,200 --> 00:12:50,480
so this domain basically is the

00:12:49,440 --> 00:12:53,279
mechanism

00:12:50,480 --> 00:12:54,959
to separate the local interrupt numbers

00:12:53,279 --> 00:12:56,079
all the hardware items from the linux

00:12:54,959 --> 00:12:59,279
irq numbers

00:12:56,079 --> 00:13:01,120
by using a set of functions again i have

00:12:59,279 --> 00:13:04,399
to analog descriptors in their

00:13:01,120 --> 00:13:05,279
free descriptors so this irk domain

00:13:04,399 --> 00:13:07,360
library adds

00:13:05,279 --> 00:13:09,600
mapping between hardware iq and irq

00:13:07,360 --> 00:13:12,480
numbers so we will see that how

00:13:09,600 --> 00:13:14,800
the call flow of this domain map irq

00:13:12,480 --> 00:13:14,800
domain

00:13:17,519 --> 00:13:22,160
so now if we can see this i have to

00:13:19,760 --> 00:13:24,320
domain map in linux so it will use

00:13:22,160 --> 00:13:25,519
a different type of domain mappings here

00:13:24,320 --> 00:13:27,839
there is one

00:13:25,519 --> 00:13:29,360
legacy map or the linear map or the tree

00:13:27,839 --> 00:13:31,680
map there is no map

00:13:29,360 --> 00:13:33,120
so basically we use legacy map or the

00:13:31,680 --> 00:13:36,480
linear map basically we use

00:13:33,120 --> 00:13:38,399
out of these domain mappings so

00:13:36,480 --> 00:13:40,720
this will be called with respect to

00:13:38,399 --> 00:13:41,680
these rq domain add of one of these

00:13:40,720 --> 00:13:43,839
functionalities

00:13:41,680 --> 00:13:44,800
which will call this the irq domain

00:13:43,839 --> 00:13:46,800
operations

00:13:44,800 --> 00:13:48,639
from there it will go to the create

00:13:46,800 --> 00:13:50,720
mapping so it will go to the actual

00:13:48,639 --> 00:13:52,639
controller if we are comparing this

00:13:50,720 --> 00:13:53,440
slide with the first slide which i was

00:13:52,639 --> 00:13:56,720
showcased

00:13:53,440 --> 00:13:59,519
from the device jam request rq to the

00:13:56,720 --> 00:14:01,519
gene controller in between these irq

00:13:59,519 --> 00:14:02,079
subsystems and the domain mapping will

00:14:01,519 --> 00:14:04,560
be done

00:14:02,079 --> 00:14:05,440
so this i have to create mapping will be

00:14:04,560 --> 00:14:08,639
creating a

00:14:05,440 --> 00:14:10,639
kind of each i could towards my

00:14:08,639 --> 00:14:12,240
hardware iq controller that's where

00:14:10,639 --> 00:14:13,680
regenerating for each pin the

00:14:12,240 --> 00:14:17,040
corresponding interrupt

00:14:13,680 --> 00:14:17,760
so that part i will show here the linear

00:14:17,040 --> 00:14:20,720
mapping part

00:14:17,760 --> 00:14:22,160
irq domain add linear and add tree and

00:14:20,720 --> 00:14:22,880
add number these are all the different

00:14:22,160 --> 00:14:26,079
type of

00:14:22,880 --> 00:14:27,519
mappings available in the subsystem so

00:14:26,079 --> 00:14:29,199
here

00:14:27,519 --> 00:14:31,360
the hierarchy of irq domain will be

00:14:29,199 --> 00:14:33,920
coming from the hello kyrq's

00:14:31,360 --> 00:14:35,440
activate irqs and the domain reacted rq

00:14:33,920 --> 00:14:37,839
and the three irqs

00:14:35,440 --> 00:14:39,199
so now if we can go to one of the

00:14:37,839 --> 00:14:41,199
example of the mapping

00:14:39,199 --> 00:14:43,760
where we are using the legacy mapping

00:14:41,199 --> 00:14:47,519
here it will do add legacy where

00:14:43,760 --> 00:14:50,720
it is calling the irq domain operations

00:14:47,519 --> 00:14:52,320
so here domain map and map

00:14:50,720 --> 00:14:53,839
we are calling one constant structure

00:14:52,320 --> 00:14:55,680
here structure

00:14:53,839 --> 00:14:57,279
domain with respect to irq domain

00:14:55,680 --> 00:14:59,360
operations so this

00:14:57,279 --> 00:15:00,639
legacy map provides a continuous range

00:14:59,360 --> 00:15:02,079
of higher q numbers

00:15:00,639 --> 00:15:04,320
has already been allocated for the

00:15:02,079 --> 00:15:06,160
controller and that the irq number can

00:15:04,320 --> 00:15:08,720
be calculated by adding a

00:15:06,160 --> 00:15:09,760
fixed offset to the hardware iq number

00:15:08,720 --> 00:15:12,160
and

00:15:09,760 --> 00:15:14,720
vice versa means like we can we can see

00:15:12,160 --> 00:15:17,440
that if we had if we had a kind of

00:15:14,720 --> 00:15:18,959
uh debugging with at the time of

00:15:17,440 --> 00:15:20,959
debugging we can check out

00:15:18,959 --> 00:15:22,800
these numbers how it has been generated

00:15:20,959 --> 00:15:24,480
actually because we can compare

00:15:22,800 --> 00:15:25,440
basically from the trm whatever the

00:15:24,480 --> 00:15:27,680
number is coming

00:15:25,440 --> 00:15:28,959
which is presented in the dtc and the

00:15:27,680 --> 00:15:32,000
number we can check out

00:15:28,959 --> 00:15:34,000
from the request whatever the

00:15:32,000 --> 00:15:36,320
return value from the request iq that

00:15:34,000 --> 00:15:38,079
number so in between these numbers are

00:15:36,320 --> 00:15:38,720
going to change based on this domain

00:15:38,079 --> 00:15:41,759
happening

00:15:38,720 --> 00:15:43,360
so can be compared like how it is being

00:15:41,759 --> 00:15:45,040
changed with respect to

00:15:43,360 --> 00:15:46,800
so that's where like actually the domain

00:15:45,040 --> 00:15:49,360
map is coming into picture

00:15:46,800 --> 00:15:50,399
so in that way we can uh check out those

00:15:49,360 --> 00:15:52,160
values actually

00:15:50,399 --> 00:15:54,880
that's that's what the last statement is

00:15:52,160 --> 00:15:58,240
talking about with respect to legacy now

00:15:54,880 --> 00:16:01,040
so now uh inside the isr execution in

00:15:58,240 --> 00:16:03,120
the arm course how exactly it is working

00:16:01,040 --> 00:16:04,240
so here we have a different modes user

00:16:03,120 --> 00:16:06,240
mode supervision

00:16:04,240 --> 00:16:08,399
we know that there are seven processor

00:16:06,240 --> 00:16:10,959
mods and how it's going to work

00:16:08,399 --> 00:16:13,839
so after that like we can say that uh

00:16:10,959 --> 00:16:16,079
the actual vector table in gic which is

00:16:13,839 --> 00:16:17,360
actually maintaining the restored vector

00:16:16,079 --> 00:16:19,920
undefined vector

00:16:17,360 --> 00:16:21,199
prefetch databar address exception irq

00:16:19,920 --> 00:16:23,920
and faq

00:16:21,199 --> 00:16:24,959
so and then uh so this will be actually

00:16:23,920 --> 00:16:27,120
talking about

00:16:24,959 --> 00:16:28,480
the change of the controller actually i

00:16:27,120 --> 00:16:30,720
can say that uh

00:16:28,480 --> 00:16:32,800
okay this is the dispatcher the below

00:16:30,720 --> 00:16:33,360
code village would when irp exception is

00:16:32,800 --> 00:16:36,160
right

00:16:33,360 --> 00:16:37,040
so we can see that if there is any

00:16:36,160 --> 00:16:39,199
exception

00:16:37,040 --> 00:16:42,480
so the interrupt is raised so we can see

00:16:39,199 --> 00:16:45,519
that actually the cpsr which is the

00:16:42,480 --> 00:16:46,000
0 to 31 bits will change that one of the

00:16:45,519 --> 00:16:48,800
bits

00:16:46,000 --> 00:16:51,199
to change the mode so that time the cpsr

00:16:48,800 --> 00:16:53,920
and the spss will come into picture and

00:16:51,199 --> 00:16:54,240
they will load the data into the spssr

00:16:53,920 --> 00:16:57,040
and

00:16:54,240 --> 00:16:58,880
it will load all these uh irq handlers

00:16:57,040 --> 00:17:01,120
address into the program counter

00:16:58,880 --> 00:17:02,800
and once it is done it will be loaded

00:17:01,120 --> 00:17:05,039
back with respect to link register

00:17:02,800 --> 00:17:06,160
that the old address so that's that's

00:17:05,039 --> 00:17:08,480
the normal way of

00:17:06,160 --> 00:17:09,360
hire execution but yes we are we can see

00:17:08,480 --> 00:17:10,959
here

00:17:09,360 --> 00:17:14,799
the interrupt dispatcher which is

00:17:10,959 --> 00:17:14,799
actually going to execute at the time of

00:17:15,360 --> 00:17:20,400
interrupt happens so this enter

00:17:18,319 --> 00:17:23,039
dispatcher will be loaded

00:17:20,400 --> 00:17:24,720
or can be taken care by by the help of

00:17:23,039 --> 00:17:28,480
this sequence i mean to say

00:17:24,720 --> 00:17:31,760
spsr irq r0 and lr2 are saved on the

00:17:28,480 --> 00:17:33,360
private r2 stack and there and then the

00:17:31,760 --> 00:17:35,679
original process mode that means the

00:17:33,360 --> 00:17:37,919
initial process whatever is running

00:17:35,679 --> 00:17:39,600
uh the transfer happens from the kernel

00:17:37,919 --> 00:17:40,720
mode to the user or user mode to the

00:17:39,600 --> 00:17:46,240
kernel mode

00:17:40,720 --> 00:17:48,640
so after that is the moves

00:17:46,240 --> 00:17:51,520
and then moves pc commander which loads

00:17:48,640 --> 00:17:52,960
spsl are going to gpsr and puts lr into

00:17:51,520 --> 00:17:55,039
pc so this is the one that

00:17:52,960 --> 00:17:56,960
at the end of the sequence it will be

00:17:55,039 --> 00:17:59,200
loaded because the lr holds the return

00:17:56,960 --> 00:18:02,000
value that will be loaded into pc

00:17:59,200 --> 00:18:03,280
to continue with the actual execution

00:18:02,000 --> 00:18:05,919
right

00:18:03,280 --> 00:18:06,559
so now this is actually irq handler we

00:18:05,919 --> 00:18:10,000
can see that

00:18:06,559 --> 00:18:12,320
the stack pointer will be loaded with r0

00:18:10,000 --> 00:18:14,080
and we know this bad address this

00:18:12,320 --> 00:18:16,880
actually this is a kind of

00:18:14,080 --> 00:18:18,880
uh the recently changed uh assembler

00:18:16,880 --> 00:18:22,480
code actually it is earlier

00:18:18,880 --> 00:18:25,039
i think 6bv so that be a bad

00:18:22,480 --> 00:18:26,400
ba dr is the decent assembler but yeah

00:18:25,039 --> 00:18:29,760
this is the macro

00:18:26,400 --> 00:18:31,919
irq handler we are using here uh

00:18:29,760 --> 00:18:32,799
part of this assemblative code assembly

00:18:31,919 --> 00:18:36,640
code

00:18:32,799 --> 00:18:40,840
so now coming to the summary of this

00:18:36,640 --> 00:18:43,039
so isis starting from the request ir

00:18:40,840 --> 00:18:44,799
queue

00:18:43,039 --> 00:18:47,520
request directly generated from the io

00:18:44,799 --> 00:18:49,520
device goes to the linux irb subsystem

00:18:47,520 --> 00:18:51,440
which is holding ir descriptor i have

00:18:49,520 --> 00:18:54,480
action and i have to chip

00:18:51,440 --> 00:18:57,840
so i have highlighted whatever that

00:18:54,480 --> 00:18:57,840
request is

00:19:03,360 --> 00:19:07,280
soc and then it is actually mapped to

00:19:06,480 --> 00:19:09,039
our

00:19:07,280 --> 00:19:10,960
generic interrupt controller part of the

00:19:09,039 --> 00:19:13,360
arm code so now even

00:19:10,960 --> 00:19:15,039
so this is the actual execution so i

00:19:13,360 --> 00:19:17,120
have captured the things

00:19:15,039 --> 00:19:18,640
which are in a minimal way but actually

00:19:17,120 --> 00:19:20,400
if we are seeing it

00:19:18,640 --> 00:19:21,919
there are a lot of functions coming from

00:19:20,400 --> 00:19:24,080
the irq chip i mean

00:19:21,919 --> 00:19:25,360
the hardware iq controller it can be

00:19:24,080 --> 00:19:27,679
zinc or some other

00:19:25,360 --> 00:19:28,480
uh platform vendors controller being

00:19:27,679 --> 00:19:30,160
been used

00:19:28,480 --> 00:19:32,640
like you know marvel uses the amda

00:19:30,160 --> 00:19:34,640
controllers i mean uh the kind of

00:19:32,640 --> 00:19:37,360
max seven three two five and all so a

00:19:34,640 --> 00:19:40,240
lot of controls available in the irq

00:19:37,360 --> 00:19:41,840
if you check the links kernel code so

00:19:40,240 --> 00:19:44,880
the thing is i just want to

00:19:41,840 --> 00:19:47,440
capture that in a minimal way which is

00:19:44,880 --> 00:19:48,320
gives the complete view but yes on a

00:19:47,440 --> 00:19:52,160
layout

00:19:48,320 --> 00:19:54,080
we can try to understand from the

00:19:52,160 --> 00:19:55,440
from the platform independent to the

00:19:54,080 --> 00:19:58,320
till to the lowest level

00:19:55,440 --> 00:19:58,960
so it will be capturing all the areas

00:19:58,320 --> 00:20:01,919
but yeah

00:19:58,960 --> 00:20:03,120
uh to the whatever the things that it is

00:20:01,919 --> 00:20:06,400
possible i try to

00:20:03,120 --> 00:20:08,400
capture in that minimal way right

00:20:06,400 --> 00:20:10,159
and coming to this whatever the things

00:20:08,400 --> 00:20:11,600
is i just followed this

00:20:10,159 --> 00:20:13,280
provisional line scanning architecture

00:20:11,600 --> 00:20:16,720
which is of uh

00:20:13,280 --> 00:20:18,240
the basic book uh kind of uh handles all

00:20:16,720 --> 00:20:21,280
the

00:20:18,240 --> 00:20:21,600
chapters part of the linux kernel and

00:20:21,280 --> 00:20:23,919
then

00:20:21,600 --> 00:20:24,720
generic irq handling and canola acumen

00:20:23,919 --> 00:20:27,919
some set of

00:20:24,720 --> 00:20:29,919
blocks uh i have been uh

00:20:27,919 --> 00:20:32,400
gone through and the gpio drivers which

00:20:29,919 --> 00:20:36,320
is internally taking care of

00:20:32,400 --> 00:20:39,520
these gpu drivers mapping so

00:20:36,320 --> 00:20:39,520

YouTube URL: https://www.youtube.com/watch?v=0OT_d8guDN0


