Title: New Zephyr features: LWM2M   FOTA Framework - SFO17-113
Publication date: 2017-09-29
Playlist: Linaro Connect San Francisco 2017
Description: 
	Session ID: SFO17-113
Session Name: New Zephyr features: LWM2M / FOTA Framework - SFO17-113
Speaker: Marti Bolivar - David Brown - Ricardo Salveti - Mike Scott

Track: LTD


★ Session Summary ★
Zephyr is changing at an alarming pace and we would like to provide some insights to a few of the areas we have been working.  MCUBOOT Secure bootloader integration, FOTA, DeviceTree and LWM2M enabling secure client to cloud capabilities
---------------------------------------------------
★ Resources ★
Event Page: http://connect.linaro.org/resource/sfo17/sfo17-113/
Presentation: 
Video: 
 ---------------------------------------------------

★ Event Details ★
Linaro Connect San Francisco 2017 (SFO17)
25-29 September 2017
Hyatt Regency San Francisco Airport

---------------------------------------------------
Keyword: 
'http://www.linaro.org'
'http://connect.linaro.org'
---------------------------------------------------
Follow us on Social Media
https://www.facebook.com/LinaroOrg
https://twitter.com/linaroorg
https://www.youtube.com/user/linaroorg?sub_confirmation=1
https://www.linkedin.com/company/1026961
Captions: 
	00:00:00,120 --> 00:00:04,060
[Music]

00:00:08,910 --> 00:00:12,320
[Music]

00:00:14,890 --> 00:00:19,910
I'll get ok so my name is Marty that's

00:00:19,520 --> 00:00:21,230
Michael

00:00:19,910 --> 00:00:23,210
we're from the lunar technologies

00:00:21,230 --> 00:00:24,800
division and we're gonna be talking

00:00:23,210 --> 00:00:28,700
about some zephyr related work that

00:00:24,800 --> 00:00:30,289
we've been doing for I do I guess I

00:00:28,700 --> 00:00:32,330
should say that I think one of the

00:00:30,289 --> 00:00:34,670
things that we think about what we do

00:00:32,330 --> 00:00:36,650
with an Ltd is that we try to create

00:00:34,670 --> 00:00:37,910
easy buttons for his effort you know we

00:00:36,650 --> 00:00:40,280
take a lot of the upstream work and we

00:00:37,910 --> 00:00:42,320
think about what additional

00:00:40,280 --> 00:00:44,570
infrastructure might be needed to make

00:00:42,320 --> 00:00:48,530
it easy to deploy in a more end-to-end

00:00:44,570 --> 00:00:50,630
scenario and this is a really fun thing

00:00:48,530 --> 00:00:51,860
to do when you're working with a project

00:00:50,630 --> 00:00:53,149
that's moving as quickly as that first

00:00:51,860 --> 00:00:55,820
so I collected some development

00:00:53,149 --> 00:00:58,489
statistics this morning the kind of the

00:00:55,820 --> 00:00:59,960
biggest one was 1.6 I think when the the

00:00:58,489 --> 00:01:01,219
you know kernel was defined but you can

00:00:59,960 --> 00:01:02,899
tell even though it's slowed down since

00:01:01,219 --> 00:01:05,840
then it's still like four times more

00:01:02,899 --> 00:01:09,009
changesets than in February so this is

00:01:05,840 --> 00:01:12,050
gone a lot more quickly than it used to

00:01:09,009 --> 00:01:13,789
at laughs Connect David gave his first

00:01:12,050 --> 00:01:15,170
talk about MCU boot which he already

00:01:13,789 --> 00:01:17,660
talked about so I won't belabor the

00:01:15,170 --> 00:01:20,180
point and we did a demo a keynote demo

00:01:17,660 --> 00:01:24,130
showing how we can do device update

00:01:20,180 --> 00:01:26,630
through the hawk bed update server and

00:01:24,130 --> 00:01:27,680
since then there was another keynote

00:01:26,630 --> 00:01:31,340
update this morning which you may have

00:01:27,680 --> 00:01:34,430
seen where we showed the all wlw m2m

00:01:31,340 --> 00:01:35,810
subsystem and I want to talk a little

00:01:34,430 --> 00:01:39,439
bit about we thought we also saw some

00:01:35,810 --> 00:01:41,180
Bluetooth mesh lights and Michael will

00:01:39,439 --> 00:01:43,189
talk about those but before then I want

00:01:41,180 --> 00:01:44,600
to talk a little bit about photo frame

00:01:43,189 --> 00:01:46,070
work which is an idea that I've kind of

00:01:44,600 --> 00:01:48,350
got bouncing around in my head for

00:01:46,070 --> 00:01:50,060
Zephyr and that I've been doing work

00:01:48,350 --> 00:01:55,070
with with a couple of other people in

00:01:50,060 --> 00:01:57,680
different companies and groups cool so

00:01:55,070 --> 00:01:59,090
this is my these are my desire Atum my

00:01:57,680 --> 00:02:00,770
personal desire otta and i want to

00:01:59,090 --> 00:02:03,079
present them to you as the others effort

00:02:00,770 --> 00:02:04,009
people that are here so that we can talk

00:02:03,079 --> 00:02:06,170
about them

00:02:04,009 --> 00:02:08,840
I the short version is that there should

00:02:06,170 --> 00:02:10,549
be an easy button it should be able to

00:02:08,840 --> 00:02:12,769
add support for MCU boot for either a

00:02:10,549 --> 00:02:14,450
new SOC or even if there's already SOC

00:02:12,769 --> 00:02:16,610
support women's effort to new board

00:02:14,450 --> 00:02:18,560
without having to go and get your pool

00:02:16,610 --> 00:02:20,120
request approved in mainline MCU boot

00:02:18,560 --> 00:02:22,730
and having the overhead of to review

00:02:20,120 --> 00:02:23,930
processes to deal with furthermore it

00:02:22,730 --> 00:02:26,330
should be possible to share system

00:02:23,930 --> 00:02:28,250
configuration related to the bootloader

00:02:26,330 --> 00:02:30,380
between the application and the Buhler

00:02:28,250 --> 00:02:32,420
itself one of the things that David

00:02:30,380 --> 00:02:34,310
talked about earlier was that MC boots

00:02:32,420 --> 00:02:37,280
job does not include getting the update

00:02:34,310 --> 00:02:39,230
so this means that the application has

00:02:37,280 --> 00:02:41,300
to know the exact same information about

00:02:39,230 --> 00:02:43,460
the flash layout that MC boot does and

00:02:41,300 --> 00:02:45,260
it has to know the same things that the

00:02:43,460 --> 00:02:48,380
bootloader does in order to you know

00:02:45,260 --> 00:02:50,390
safely write the update and while we're

00:02:48,380 --> 00:02:51,770
definitely way better than we used to be

00:02:50,390 --> 00:02:54,110
I think that there's a little bit of

00:02:51,770 --> 00:02:55,760
extra last mile work to do that I'd like

00:02:54,110 --> 00:02:57,740
to talk about that I think will get us

00:02:55,760 --> 00:02:59,630
into a really great place to start

00:02:57,740 --> 00:03:04,330
proceeding iteratively iteratively from

00:02:59,630 --> 00:03:07,370
there okay so this is a quick picture of

00:03:04,330 --> 00:03:09,320
life under MCU boot it lives that the

00:03:07,370 --> 00:03:10,520
this kind of a sort of arm cortex-m II

00:03:09,320 --> 00:03:13,100
picture and of course it's going to be

00:03:10,520 --> 00:03:15,950
different on Intel which MC but has been

00:03:13,100 --> 00:03:17,440
ported to but MCU boot the application

00:03:15,950 --> 00:03:20,540
image lives at the beginning of flash

00:03:17,440 --> 00:03:22,700
it's vector table is kind of the reset

00:03:20,540 --> 00:03:25,370
vector table and then you've got a

00:03:22,700 --> 00:03:26,990
couple of application images one is the

00:03:25,370 --> 00:03:28,820
main one and one is the update one and

00:03:26,990 --> 00:03:31,310
as David said I'm seeing but will either

00:03:28,820 --> 00:03:34,010
swap them out using this temporary

00:03:31,310 --> 00:03:36,950
partition labeled TMP or just with a

00:03:34,010 --> 00:03:39,080
simple overwrite in addition there's a

00:03:36,950 --> 00:03:40,489
little bit of an area where there's an

00:03:39,080 --> 00:03:42,140
MC boot header at the beginning of the

00:03:40,489 --> 00:03:44,450
application image and so the application

00:03:42,140 --> 00:03:48,620
inspector table and the rest of its code

00:03:44,450 --> 00:03:50,239
are a little bit offset furthermore this

00:03:48,620 --> 00:03:52,580
should not be assumed to take over the

00:03:50,239 --> 00:03:54,680
entire device you can have gaps in

00:03:52,580 --> 00:03:57,320
between words which I've shown in orange

00:03:54,680 --> 00:03:58,790
where neither the well the bootloader

00:03:57,320 --> 00:04:01,340
shouldn't touch it at all and the

00:03:58,790 --> 00:04:02,080
application should be able to play with

00:04:01,340 --> 00:04:06,050
it nicely

00:04:02,080 --> 00:04:08,150
so that's kind of the quick picture and

00:04:06,050 --> 00:04:09,980
then the other thing is that yet we've

00:04:08,150 --> 00:04:11,830
got sectors so these areas are actually

00:04:09,980 --> 00:04:14,330
made out of sectors of course and

00:04:11,830 --> 00:04:17,810
sectors may have varying sizes depending

00:04:14,330 --> 00:04:19,489
on the SOC and we might have you know

00:04:17,810 --> 00:04:21,019
weird things where I've seen SOC is

00:04:19,489 --> 00:04:22,100
where it gets bigger and then it gets

00:04:21,019 --> 00:04:24,470
smaller again and then it gets bigger

00:04:22,100 --> 00:04:27,590
again so this is something that you need

00:04:24,470 --> 00:04:28,910
to deal with in general when you're

00:04:27,590 --> 00:04:30,140
dealing with them see you but I'm trying

00:04:28,910 --> 00:04:32,990
to make it portable and trying to make

00:04:30,140 --> 00:04:35,090
it easy so that's one important thing

00:04:32,990 --> 00:04:36,050
that you need to think about another one

00:04:35,090 --> 00:04:38,690
is

00:04:36,050 --> 00:04:40,340
the right block size so you know you can

00:04:38,690 --> 00:04:42,020
typically read it like granularity you

00:04:40,340 --> 00:04:44,509
can erase of course only at sector

00:04:42,020 --> 00:04:47,000
granularity but there's various

00:04:44,509 --> 00:04:50,449
granularities for how much data you need

00:04:47,000 --> 00:04:52,400
to write to flash in one go and MCU but

00:04:50,449 --> 00:04:56,169
needs to know this and the applications

00:04:52,400 --> 00:04:59,300
that use it also need to know this so

00:04:56,169 --> 00:05:01,069
right now I think the big support issue

00:04:59,300 --> 00:05:04,370
that we've got an MCU boot and I've got

00:05:01,069 --> 00:05:06,470
some patches up both for Zephyr and for

00:05:04,370 --> 00:05:09,590
MCU boot that are attempting to address

00:05:06,470 --> 00:05:12,860
this is that we still have like one

00:05:09,590 --> 00:05:15,050
header file preferred Z for board that

00:05:12,860 --> 00:05:17,960
contains a lot of this information the

00:05:15,050 --> 00:05:19,940
the blue pictures up here which tell you

00:05:17,960 --> 00:05:22,849
you know how big are the image areas

00:05:19,940 --> 00:05:25,099
have moved to device tree but a lot of

00:05:22,849 --> 00:05:27,979
this other stuff is still something that

00:05:25,099 --> 00:05:30,469
you have to take care of with a target

00:05:27,979 --> 00:05:32,509
specific header which I see is a problem

00:05:30,469 --> 00:05:34,159
not only because it's a little bit

00:05:32,509 --> 00:05:36,229
tedious and error-prone and you end up

00:05:34,159 --> 00:05:38,599
repeating yourself a whole bunch but

00:05:36,229 --> 00:05:40,250
also because you know the application

00:05:38,599 --> 00:05:42,560
needs a copy of this and so you know

00:05:40,250 --> 00:05:44,509
we've we've done a couple of device

00:05:42,560 --> 00:05:46,400
update systems at this point with their

00:05:44,509 --> 00:05:48,380
different protocols and we don't have a

00:05:46,400 --> 00:05:50,419
much better solution than copy it into

00:05:48,380 --> 00:05:51,830
each application which isn't great and

00:05:50,419 --> 00:05:54,020
of course it's not great either when you

00:05:51,830 --> 00:05:55,520
want to change it right and so one very

00:05:54,020 --> 00:05:57,199
good reason why you might want to change

00:05:55,520 --> 00:05:59,630
your layout for example is that if

00:05:57,199 --> 00:06:01,789
you're under heavy development you want

00:05:59,630 --> 00:06:03,469
that scratch partition to be big because

00:06:01,789 --> 00:06:05,630
it gets overwritten a bunch of times if

00:06:03,469 --> 00:06:06,590
it's very small during a swap and you

00:06:05,630 --> 00:06:08,509
don't want to wear out your board

00:06:06,590 --> 00:06:09,860
whereas in production you don't expect

00:06:08,509 --> 00:06:11,180
that many updates so it's okay for it to

00:06:09,860 --> 00:06:12,949
be smaller so that your application can

00:06:11,180 --> 00:06:14,870
be bigger and there's little trade-offs

00:06:12,949 --> 00:06:17,060
like this that make having a centralized

00:06:14,870 --> 00:06:18,889
place to put this information a lot

00:06:17,060 --> 00:06:22,789
better for people that are gonna want to

00:06:18,889 --> 00:06:23,960
use this the other thing that I

00:06:22,789 --> 00:06:25,669
mentioned during one of my questions to

00:06:23,960 --> 00:06:27,409
David is that I think it's an issue that

00:06:25,669 --> 00:06:29,029
the the Zephyr flashing scripts right

00:06:27,409 --> 00:06:30,650
now aren't necessarily very partition

00:06:29,029 --> 00:06:33,259
aware and so it kind of makes it hard

00:06:30,650 --> 00:06:35,210
also for for build systems that want to

00:06:33,259 --> 00:06:37,190
know how to flash in debug in a

00:06:35,210 --> 00:06:39,620
convenient way that's portable say if

00:06:37,190 --> 00:06:41,419
you were trying to build a giant CI lab

00:06:39,620 --> 00:06:42,740
that wanted to test the same application

00:06:41,419 --> 00:06:45,080
on a bunch of different boards made by a

00:06:42,740 --> 00:06:47,120
bunch of different SOC vendors to do

00:06:45,080 --> 00:06:48,680
this in a clean way and to add make

00:06:47,120 --> 00:06:51,229
integration

00:06:48,680 --> 00:06:55,100
simple for CI as well as for the

00:06:51,229 --> 00:06:57,650
developers so this is kind of where I'd

00:06:55,100 --> 00:06:59,419
like to go with this where we've got a

00:06:57,650 --> 00:07:02,660
dividing line between Zephyr and MCU

00:06:59,419 --> 00:07:04,490
boot and a lot of this has already

00:07:02,660 --> 00:07:05,870
started to make it upstream but I just

00:07:04,490 --> 00:07:07,880
sort of wanted to talk about it here

00:07:05,870 --> 00:07:10,850
today as to why I see it as important

00:07:07,880 --> 00:07:13,729
for using MCU but within Zephyr where we

00:07:10,850 --> 00:07:15,350
move the partition and sector map as

00:07:13,729 --> 00:07:17,000
well as the right block size and any

00:07:15,350 --> 00:07:19,280
other information into the flash driver

00:07:17,000 --> 00:07:22,690
itself it can grab the information out

00:07:19,280 --> 00:07:25,000
of DTS which is nice and that makes the

00:07:22,690 --> 00:07:27,169
MCU boot hardware abstraction layer

00:07:25,000 --> 00:07:29,389
perfectly generic we don't need to

00:07:27,169 --> 00:07:32,030
change anything anymore and I've got

00:07:29,389 --> 00:07:33,590
this working on a series with three

00:07:32,030 --> 00:07:36,350
different SOC s with widely varying

00:07:33,590 --> 00:07:38,180
flash characteristics the other thing

00:07:36,350 --> 00:07:40,639
that I see being important which is

00:07:38,180 --> 00:07:42,740
starting to happen now is kind of having

00:07:40,639 --> 00:07:45,680
an MCU boot or DFU image manager

00:07:42,740 --> 00:07:47,810
subsystem within Zephyr that can not

00:07:45,680 --> 00:07:50,389
only build upon the flash driver but

00:07:47,810 --> 00:07:52,310
also help you do things like some of

00:07:50,389 --> 00:07:53,960
these longer-term goals that David was

00:07:52,310 --> 00:07:55,729
talking about for him so you boot like

00:07:53,960 --> 00:07:58,669
being able to communicate information

00:07:55,729 --> 00:08:00,639
from the bootloader to Zephyr maybe

00:07:58,669 --> 00:08:03,800
wanting to deal with multiple

00:08:00,639 --> 00:08:07,000
incompatible versions of MCU in a in a

00:08:03,800 --> 00:08:09,320
clean way within one sefar subsystem so

00:08:07,000 --> 00:08:11,060
while I do think that getting rid of

00:08:09,320 --> 00:08:12,530
that red ugly box that's still an MCU

00:08:11,060 --> 00:08:15,650
boot is kind of the minimum thing that

00:08:12,530 --> 00:08:16,789
we need and we can we can do that and I

00:08:15,650 --> 00:08:19,099
would love to talk about this further

00:08:16,789 --> 00:08:21,860
with any interested after maintainer I

00:08:19,099 --> 00:08:23,570
also see this this give you manager over

00:08:21,860 --> 00:08:26,840
here being a really important part of

00:08:23,570 --> 00:08:28,849
the story going forward so that's it for

00:08:26,840 --> 00:08:29,120
me and I'll leave it to Michael to talk

00:08:28,849 --> 00:08:38,020
about

00:08:29,120 --> 00:08:38,020
Elda beyond tab Thanks all right

00:08:38,260 --> 00:08:41,750
so my name is Michael Scott I'm an

00:08:40,520 --> 00:08:43,430
embedded engineer with the Lanaya

00:08:41,750 --> 00:08:45,110
technologies division we're gonna talk

00:08:43,430 --> 00:08:48,590
about lightweight machine the machine or

00:08:45,110 --> 00:08:52,910
LW m2m today this is a recent addition

00:08:48,590 --> 00:08:55,100
with stuffer 1.9 we had done some early

00:08:52,910 --> 00:08:57,830
on demos back in earlier versions with

00:08:55,100 --> 00:08:59,570
different varying combinations of TCP

00:08:57,830 --> 00:09:01,100
stacks we wanted to look at something

00:08:59,570 --> 00:09:02,480
that was more constrained something that

00:09:01,100 --> 00:09:04,580
was smaller I was able to run on smaller

00:09:02,480 --> 00:09:08,240
and profile devices and less memory less

00:09:04,580 --> 00:09:13,000
flash so let's talk about what lwm to

00:09:08,240 --> 00:09:15,950
him is just as a quick overview

00:09:13,000 --> 00:09:19,190
although m2m is based on the coop

00:09:15,950 --> 00:09:22,160
protocols co-op to say you to P is the

00:09:19,190 --> 00:09:23,960
UDP protocol it has a very small packet

00:09:22,160 --> 00:09:25,880
header it has no state to it you

00:09:23,960 --> 00:09:27,380
fire-and-forget you get a very quick act

00:09:25,880 --> 00:09:30,140
reply and there's nothing to it whereas

00:09:27,380 --> 00:09:31,700
TCP has sequences has state machines it

00:09:30,140 --> 00:09:33,410
has to follows a lot of logic when you

00:09:31,700 --> 00:09:35,810
get into that you you build a lot of

00:09:33,410 --> 00:09:37,550
code around that and to apply for

00:09:35,810 --> 00:09:41,030
constrained device you really want to

00:09:37,550 --> 00:09:44,020
stay as small as possible so with co-op

00:09:41,030 --> 00:09:46,640
you have kind of these resource based

00:09:44,020 --> 00:09:49,160
queries that you make using get put in

00:09:46,640 --> 00:09:53,090
post I may be getting ahead of myself a

00:09:49,160 --> 00:09:56,030
little bit but LW m2m makes the same use

00:09:53,090 --> 00:09:58,850
of those get put and post methods but

00:09:56,030 --> 00:10:02,980
correlates them into more of a rewrite

00:09:58,850 --> 00:10:07,340
create delete type methods and those are

00:10:02,980 --> 00:10:10,100
outlined in the Box there for lwm laying

00:10:07,340 --> 00:10:13,100
on top of that we have these core set of

00:10:10,100 --> 00:10:15,890
smart objects that the lwm temp system

00:10:13,100 --> 00:10:17,390
uses these are security based

00:10:15,890 --> 00:10:19,880
information there are a set of

00:10:17,390 --> 00:10:22,100
well-defined resources that are well

00:10:19,880 --> 00:10:23,990
documented so rather than the co-op

00:10:22,100 --> 00:10:26,560
approach of you designing your resource

00:10:23,990 --> 00:10:28,730
name and sort of using them these are

00:10:26,560 --> 00:10:30,380
actually put into the spec so that

00:10:28,730 --> 00:10:31,910
everybody knows what to expect how to

00:10:30,380 --> 00:10:33,740
query them what kind of response are

00:10:31,910 --> 00:10:35,840
going to get back and at the very top of

00:10:33,740 --> 00:10:38,090
that you can design your applications to

00:10:35,840 --> 00:10:40,070
make queries against those well-known

00:10:38,090 --> 00:10:42,880
objects and get well-known responses

00:10:40,070 --> 00:10:48,260
back so we're gonna move on

00:10:42,880 --> 00:10:50,950
so lwm the course back is 18 different

00:10:48,260 --> 00:10:53,740
objects it starts off with security and

00:10:50,950 --> 00:10:55,630
and server information there included in

00:10:53,740 --> 00:10:58,120
that is also some device information and

00:10:55,630 --> 00:11:00,160
fur where he goes on into access control

00:10:58,120 --> 00:11:01,720
model and some other things and later on

00:11:00,160 --> 00:11:03,490
I'm going to get into which portions of

00:11:01,720 --> 00:11:06,089
the original spec are implemented with

00:11:03,490 --> 00:11:09,010
version 1.9 and what we can expect later

00:11:06,089 --> 00:11:14,199
moving past the original 18 which are

00:11:09,010 --> 00:11:16,690
managed by the OMA the working group

00:11:14,199 --> 00:11:19,480
there is an IPS oh smart object layer

00:11:16,690 --> 00:11:20,949
which is comprised of probably hundreds

00:11:19,480 --> 00:11:24,130
of different definitions for objects

00:11:20,949 --> 00:11:26,170
they all belong in a registry that the

00:11:24,130 --> 00:11:27,880
Open Mobile Alliance has where you can

00:11:26,170 --> 00:11:30,190
define what the object is what the

00:11:27,880 --> 00:11:32,560
resources are what kind of a data

00:11:30,190 --> 00:11:35,290
element it follows and whether it's

00:11:32,560 --> 00:11:38,019
optional required readwrite it's all

00:11:35,290 --> 00:11:39,910
very well documented one example of say

00:11:38,019 --> 00:11:41,949
an IPS Oh object is the light control

00:11:39,910 --> 00:11:44,380
object which was done in our demo today

00:11:41,949 --> 00:11:46,899
this morning with the it was a wireless

00:11:44,380 --> 00:11:48,370
LED where you saw Tyler was sending a

00:11:46,899 --> 00:11:50,470
command it would turn the light on turn

00:11:48,370 --> 00:11:54,089
the light off what he was doing was he

00:11:50,470 --> 00:11:56,500
was using a right method against the on

00:11:54,089 --> 00:11:59,529
property or the on resource of the light

00:11:56,500 --> 00:12:03,430
control and so just use that as an

00:11:59,529 --> 00:12:04,930
example these are for more information

00:12:03,430 --> 00:12:06,160
on a lot of the details for these

00:12:04,930 --> 00:12:08,560
different objects you have to go to the

00:12:06,160 --> 00:12:11,199
OMA registry and it's just goes on and

00:12:08,560 --> 00:12:14,949
on this is an example of that light

00:12:11,199 --> 00:12:17,980
control object so the object ID for that

00:12:14,949 --> 00:12:20,380
would be 33 11 and that would be the

00:12:17,980 --> 00:12:22,959
first portion of what is the URI for how

00:12:20,380 --> 00:12:24,699
to read and write to that object each of

00:12:22,959 --> 00:12:27,130
these objects can have multiple

00:12:24,699 --> 00:12:30,100
instances in some cases you could have a

00:12:27,130 --> 00:12:32,949
dual lamp style light where it has

00:12:30,100 --> 00:12:35,980
instance 0 and instance 1 so the URI

00:12:32,949 --> 00:12:39,010
would be comprised of 3 3 1 1 / the

00:12:35,980 --> 00:12:41,350
instance number 0 1 / and the resource

00:12:39,010 --> 00:12:44,140
ID that's shown above here so we have

00:12:41,350 --> 00:12:47,410
on/off which is a read and write and

00:12:44,140 --> 00:12:49,569
it's a single and Ettore field that can

00:12:47,410 --> 00:12:51,670
be true or false and that was what Tyler

00:12:49,569 --> 00:12:54,880
was using we also have optional fields

00:12:51,670 --> 00:12:57,459
such as the dimmer which is integer and

00:12:54,880 --> 00:12:59,199
actually even more detailed in the spec

00:12:57,459 --> 00:13:03,279
tells you which only accepts a range

00:12:59,199 --> 00:13:04,840
from 0 to 100 but the spec is fairly

00:13:03,279 --> 00:13:06,220
detailed as how these objects are

00:13:04,840 --> 00:13:11,530
lean out and what they what you can

00:13:06,220 --> 00:13:13,540
expect I'm gonna burn through this

00:13:11,530 --> 00:13:15,940
pretty quickly what I wanted to get into

00:13:13,540 --> 00:13:17,860
was more of a you're here to learn about

00:13:15,940 --> 00:13:19,960
Altima m2m but also how it was

00:13:17,860 --> 00:13:21,670
implemented in his effort and so one of

00:13:19,960 --> 00:13:25,120
the approaches that I took when we

00:13:21,670 --> 00:13:27,550
implemented it the engine itself is

00:13:25,120 --> 00:13:29,050
fairly simple it has a very basic state

00:13:27,550 --> 00:13:31,330
machine where it makes a connection to a

00:13:29,050 --> 00:13:33,730
server and then it updates it every so

00:13:31,330 --> 00:13:35,770
often the problem with lwm is you see a

00:13:33,730 --> 00:13:38,020
lot of duplicated code in each one of

00:13:35,770 --> 00:13:41,200
these objects and they end up tending to

00:13:38,020 --> 00:13:43,030
just sprawl out and kind of add up over

00:13:41,200 --> 00:13:45,340
time because there are literally a lot

00:13:43,030 --> 00:13:46,930
of these objects so one of the goals was

00:13:45,340 --> 00:13:48,460
to abstract the engine enough that you

00:13:46,930 --> 00:13:50,740
can just define the objects in a very

00:13:48,460 --> 00:13:52,930
simple way so the object code is very

00:13:50,740 --> 00:13:55,240
small and that doesn't tend to add a

00:13:52,930 --> 00:13:57,880
whole lot of weight over time so this

00:13:55,240 --> 00:14:00,730
was an example of that light object then

00:13:57,880 --> 00:14:04,060
I showed you earlier so you can see how

00:14:00,730 --> 00:14:05,710
we have the on off dimmer on time and

00:14:04,060 --> 00:14:08,590
then if you look at the data definition

00:14:05,710 --> 00:14:10,690
this is actual code from Zephyr you have

00:14:08,590 --> 00:14:14,470
the light on off field it's a rewrite

00:14:10,690 --> 00:14:16,300
boolean limit yeah the dimmer ID on time

00:14:14,470 --> 00:14:17,980
accumulative and this is actually just

00:14:16,300 --> 00:14:20,770
the definition of the resource fields

00:14:17,980 --> 00:14:23,860
themselves so the other half of this is

00:14:20,770 --> 00:14:26,320
later when you create the object you

00:14:23,860 --> 00:14:29,260
actually get initialization of the

00:14:26,320 --> 00:14:32,860
resources themselves and so those two

00:14:29,260 --> 00:14:34,300
parts basically combine the full object

00:14:32,860 --> 00:14:35,560
definition in Zephyr and it's actually

00:14:34,300 --> 00:14:37,120
pretty simple once you get into it

00:14:35,560 --> 00:14:39,310
there's not a whole lot of code to make

00:14:37,120 --> 00:14:41,700
a new object which is where we need to

00:14:39,310 --> 00:14:41,700
go next

00:14:42,100 --> 00:14:48,550
so using Zephyr lwm time and a sample is

00:14:45,850 --> 00:14:51,250
actually hopefully easy we have a

00:14:48,550 --> 00:14:53,860
generic set of LW m2m engine setter

00:14:51,250 --> 00:14:56,830
getter methods you use the actual

00:14:53,860 --> 00:14:58,720
resource URI there first and you can set

00:14:56,830 --> 00:15:01,090
the value to whatever you'd like and it

00:14:58,720 --> 00:15:04,000
depends on whether it's a string or say

00:15:01,090 --> 00:15:06,730
a u8 obviously the only example I have

00:15:04,000 --> 00:15:08,440
up here is strings but what I'm doing

00:15:06,730 --> 00:15:10,540
right here is I'm initializing a set of

00:15:08,440 --> 00:15:13,330
device values based on the manufacturer

00:15:10,540 --> 00:15:15,430
model number and then when you're done

00:15:13,330 --> 00:15:17,770
initializing whichever objects you're

00:15:15,430 --> 00:15:20,320
using you literally start the

00:15:17,770 --> 00:15:21,520
it's a registration device client and it

00:15:20,320 --> 00:15:23,650
will start the state machine and

00:15:21,520 --> 00:15:27,790
continue from there what's neat about

00:15:23,650 --> 00:15:29,680
this is as you select these objects they

00:15:27,790 --> 00:15:32,770
register themselves with the engine and

00:15:29,680 --> 00:15:35,560
so there's really like three levels of

00:15:32,770 --> 00:15:37,870
initialization that happens here all of

00:15:35,560 --> 00:15:39,880
the objects are created they register

00:15:37,870 --> 00:15:42,070
themselves with the engine and then in

00:15:39,880 --> 00:15:43,690
your sample code you set the default

00:15:42,070 --> 00:15:46,300
values you set whether I'm creating

00:15:43,690 --> 00:15:49,630
instance zero instance one and then the

00:15:46,300 --> 00:15:51,250
client starts and then remotely whether

00:15:49,630 --> 00:15:54,850
or not you allow access to it you can

00:15:51,250 --> 00:15:57,160
create more instances or delete them so

00:15:54,850 --> 00:16:02,740
it's kind of a a little bit of

00:15:57,160 --> 00:16:04,360
separation there so the last thing I

00:16:02,740 --> 00:16:07,000
want to cover is how you can play with

00:16:04,360 --> 00:16:09,160
lwm TM today and if you're using real

00:16:07,000 --> 00:16:10,480
hardware I highly recommend you look

00:16:09,160 --> 00:16:12,970
into what the Lin are out sonic

00:16:10,480 --> 00:16:15,850
technologies division is working on this

00:16:12,970 --> 00:16:19,270
is a very easy to use build system where

00:16:15,850 --> 00:16:22,630
we've makin more like an easy button to

00:16:19,270 --> 00:16:24,310
build and deploy because using this on

00:16:22,630 --> 00:16:26,110
an actual device is complicated we're

00:16:24,310 --> 00:16:27,340
talking about maybe a ble device where

00:16:26,110 --> 00:16:28,930
you need to talk to a gateway and that

00:16:27,340 --> 00:16:30,730
gateway has to talk to cloud services

00:16:28,930 --> 00:16:33,460
and it all gets very complex very very

00:16:30,730 --> 00:16:35,380
quickly so what we have here in the

00:16:33,460 --> 00:16:37,450
slide is a URL to our documentation you

00:16:35,380 --> 00:16:39,820
can kind of read all about it if you

00:16:37,450 --> 00:16:41,950
would rather just run it on a local

00:16:39,820 --> 00:16:46,540
machine here's a very simple set of

00:16:41,950 --> 00:16:48,730
instructions you basically can download

00:16:46,540 --> 00:16:50,380
the latest version of the LeSean demo

00:16:48,730 --> 00:16:53,140
server you run it with a series of

00:16:50,380 --> 00:16:56,830
commands you can check out the Zephyr

00:16:53,140 --> 00:16:59,020
sources there's a pretty simple getting

00:16:56,830 --> 00:17:00,790
started guide there the interesting bit

00:16:59,020 --> 00:17:02,650
is you also have to follow the qmu

00:17:00,790 --> 00:17:03,820
networking set up because you're gonna

00:17:02,650 --> 00:17:06,070
run it locally you don't have a real

00:17:03,820 --> 00:17:09,400
network and literally it's one statement

00:17:06,070 --> 00:17:12,459
to open up the sample lwm TM client

00:17:09,400 --> 00:17:14,860
running in qmu that will then in turn

00:17:12,459 --> 00:17:17,140
connect to the LeSean server and you'll

00:17:14,860 --> 00:17:19,330
see the uri pop up right away and from

00:17:17,140 --> 00:17:20,950
there you can kind of do what Tyler was

00:17:19,330 --> 00:17:22,660
doing during the demo where he had all

00:17:20,950 --> 00:17:24,850
of the resources you can play with it

00:17:22,660 --> 00:17:27,720
really good a good feel for how the

00:17:24,850 --> 00:17:27,720
protocol works

00:17:29,090 --> 00:17:34,280
so let's talk about what's in today

00:17:30,940 --> 00:17:35,809
there's the basic El Demi attempt time

00:17:34,280 --> 00:17:37,460
engine that I had talked about which

00:17:35,809 --> 00:17:39,380
provides that level of distractions so

00:17:37,460 --> 00:17:40,670
we don't we duplicate all this code for

00:17:39,380 --> 00:17:44,450
all the objects as we're creating them

00:17:40,670 --> 00:17:47,840
the four basic objects security server

00:17:44,450 --> 00:17:49,640
device firmware are in there we have a

00:17:47,840 --> 00:17:51,770
basic state machine for the registration

00:17:49,640 --> 00:17:54,380
system so that it will update itself

00:17:51,770 --> 00:17:57,080
with a registered server as well as we

00:17:54,380 --> 00:17:59,390
support firmware update in both a push

00:17:57,080 --> 00:18:01,790
directly against the resource and a pull

00:17:59,390 --> 00:18:04,640
when you supply a URI it will pull that

00:18:01,790 --> 00:18:06,170
back coming in the future there's a lot

00:18:04,640 --> 00:18:09,500
of work to do and this is where the

00:18:06,170 --> 00:18:10,700
community can get involved we one of the

00:18:09,500 --> 00:18:13,070
big things is were migrating to a new

00:18:10,700 --> 00:18:15,280
co-op API it was talked about a little

00:18:13,070 --> 00:18:17,240
bit earlier during but Paul's talk

00:18:15,280 --> 00:18:19,490
Network buffers are interesting in

00:18:17,240 --> 00:18:22,400
zephir you don't get a contiguous buffer

00:18:19,490 --> 00:18:24,290
but currently the LW MTM system does

00:18:22,400 --> 00:18:26,090
expect it so the packet sizes are fairly

00:18:24,290 --> 00:18:28,460
large you'll notice that the buffer

00:18:26,090 --> 00:18:31,300
definition is around 384 pipes which is

00:18:28,460 --> 00:18:33,320
probably too large for most devices

00:18:31,300 --> 00:18:35,840
that's going to change with the new

00:18:33,320 --> 00:18:37,760
co-op API migration will have smaller

00:18:35,840 --> 00:18:40,730
buffers but you'll have to read them in

00:18:37,760 --> 00:18:43,870
non contiguous ways but we're going to

00:18:40,730 --> 00:18:46,130
take care of that hopefully soon there's

00:18:43,870 --> 00:18:48,970
ongoing support to add DTLS

00:18:46,130 --> 00:18:50,990
for the lwm engine as well as the

00:18:48,970 --> 00:18:54,440
bootstrapping portion of the

00:18:50,990 --> 00:18:56,300
registration client that uses that and

00:18:54,440 --> 00:18:57,800
then there's a lot of objects that that

00:18:56,300 --> 00:18:59,590
can be created now so we were talking

00:18:57,800 --> 00:19:03,380
about actuators we're talking about

00:18:59,590 --> 00:19:06,170
location access controls if you go out

00:19:03,380 --> 00:19:07,550
on the OMA registration you can see that

00:19:06,170 --> 00:19:08,660
there's a ton of other things out there

00:19:07,550 --> 00:19:11,030
and it should be pretty easy to

00:19:08,660 --> 00:19:12,320
implement new objects going forward and

00:19:11,030 --> 00:19:15,020
lastly I just want to talk about

00:19:12,320 --> 00:19:16,429
optimization you know it's a lot of code

00:19:15,020 --> 00:19:18,200
to get up there in a very quick amount

00:19:16,429 --> 00:19:20,270
of time so there's a lot of room to

00:19:18,200 --> 00:19:21,559
shrink these things we use a lot of

00:19:20,270 --> 00:19:23,390
assumptions when you first put it out

00:19:21,559 --> 00:19:24,800
there and I think the next round we're

00:19:23,390 --> 00:19:27,380
really going to try to shrink the

00:19:24,800 --> 00:19:29,690
footprint of the lwm Tim client so that

00:19:27,380 --> 00:19:33,170
it fits on a lot more devices and with

00:19:29,690 --> 00:19:35,890
that I think that's it

00:19:33,170 --> 00:19:35,890
any questions

00:19:39,049 --> 00:19:44,929
No

00:19:40,730 --> 00:19:44,929
all right thank you for your time

00:19:50,060 --> 00:19:55,030

YouTube URL: https://www.youtube.com/watch?v=VOv0-d5T99o


