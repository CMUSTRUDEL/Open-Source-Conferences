Title: Software is imperfect! ...so how to deal with it? - SFO17-114
Publication date: 2017-09-29
Playlist: Linaro Connect San Francisco 2017
Description: 
	Session ID: SFO17-114
Session Name: Software is imperfect! ...so how to deal with it? - SFO17-114
Speaker: Krzysztof Opasiak 
Track: LITE,LMG


★ Session Summary ★
Userspace software is imperfect and everyone knows it but most of people are afraid to talk openly about this. Usually problems start when people try to run this software for a long period of time. This problem already gave server guys a lot of sleepless nights. Nowadays also IoT and embedded Linux world is facing very the same problem. Unfortunately solutions known from server world usually cannot be directly applied here due to relatively high overhead. During this talk Krzysztof will discuss problems related to monitoring embedded Linux distribution. Firstly, available Kernel infrastructure for efficient resource usage monitoring will be presented. Then Krzysztof will try to identify what's missing and show how we could fill this gap using rlimit-events concept. Last part is going to be a discussion on a presented idea and experience sharing.
---------------------------------------------------
★ Resources ★
Event Page: http://connect.linaro.org/resource/sfo17/sfo17-114/
Presentation: 
Video: 
 ---------------------------------------------------

★ Event Details ★
Linaro Connect San Francisco 2017 (SFO17)
25-29 September 2017
Hyatt Regency San Francisco Airport

---------------------------------------------------
Keyword: 
'http://www.linaro.org'
'http://connect.linaro.org'
---------------------------------------------------
Follow us on Social Media
https://www.facebook.com/LinaroOrg
https://twitter.com/linaroorg
https://www.youtube.com/user/linaroorg?sub_confirmation=1
https://www.linkedin.com/company/1026961
Captions: 
	00:00:00,120 --> 00:00:04,060
[Music]

00:00:08,910 --> 00:00:12,320
[Music]

00:00:16,600 --> 00:00:23,240
good morning everyone my name is Pasha

00:00:20,090 --> 00:00:26,960
or some polish speakers Christopher

00:00:23,240 --> 00:00:29,779
Chris is good enough I did not use to

00:00:26,960 --> 00:00:33,980
use and microphone so I hope I want too

00:00:29,779 --> 00:00:36,800
much on you today I'd like to tell you a

00:00:33,980 --> 00:00:38,000
few words about our problems with

00:00:36,800 --> 00:00:41,059
imperfect software

00:00:38,000 --> 00:00:43,280
personally I think that there is no such

00:00:41,059 --> 00:00:45,620
thing like perfect software there is

00:00:43,280 --> 00:00:49,280
only a software in which develop

00:00:45,620 --> 00:00:58,040
developer boots as much network as is

00:00:49,280 --> 00:01:01,070
needed to get some certificate so what

00:00:58,040 --> 00:01:02,390
is the schedule for today first of all I

00:01:01,070 --> 00:01:05,360
would like to give you some brief

00:01:02,390 --> 00:01:08,690
introduction our problem then I will

00:01:05,360 --> 00:01:13,060
show you how we try to fix it using the

00:01:08,690 --> 00:01:16,909
outlet subsystem and then I will discuss

00:01:13,060 --> 00:01:18,710
POC of early events which is new

00:01:16,909 --> 00:01:21,469
functionality which we would like to add

00:01:18,710 --> 00:01:24,020
to the Linux kernel and in the end I

00:01:21,469 --> 00:01:26,840
hope you have some discussion feedback

00:01:24,020 --> 00:01:29,619
from you about patches about the general

00:01:26,840 --> 00:01:34,789
idea and how we could improve this or

00:01:29,619 --> 00:01:38,990
sending this to develop a node okay so

00:01:34,789 --> 00:01:42,859
we are all IT guys we are talking about

00:01:38,990 --> 00:01:45,320
software all the times so let's start

00:01:42,859 --> 00:01:49,929
this talk we're talking about something

00:01:45,320 --> 00:01:51,439
more pleasant let's talk about holidays

00:01:49,929 --> 00:01:55,729
holidays yeah

00:01:51,439 --> 00:01:59,540
we also like it ok so let's say that we

00:01:55,729 --> 00:02:03,860
have a friend a friend is called George

00:01:59,540 --> 00:02:07,880
and George is a really clever guy but he

00:02:03,860 --> 00:02:09,259
cannot count money and each time when

00:02:07,880 --> 00:02:13,730
girls holidays

00:02:09,259 --> 00:02:16,760
he takes a suitcase a suitcase is filled

00:02:13,730 --> 00:02:20,660
with money on the top and toilet paper

00:02:16,760 --> 00:02:23,870
in the boss and the rule is that if

00:02:20,660 --> 00:02:26,420
George has enough money on the top he

00:02:23,870 --> 00:02:27,530
pays for everything with money when he

00:02:26,420 --> 00:02:31,880
runs out of money

00:02:27,530 --> 00:02:35,180
he tries to pay with toilet paper so the

00:02:31,880 --> 00:02:38,450
question is if George going to go to

00:02:35,180 --> 00:02:42,940
jail on this holidays to which you are

00:02:38,450 --> 00:02:45,320
going together well it depends

00:02:42,940 --> 00:02:48,740
assuming that working a toilet paper

00:02:45,320 --> 00:02:53,989
like this one is legal or trying to pay

00:02:48,740 --> 00:02:57,370
with this is usual then if George tries

00:02:53,989 --> 00:03:01,010
to pay with toilet paper and get coach

00:02:57,370 --> 00:03:04,040
you don't go to jail if you won't get

00:03:01,010 --> 00:03:08,989
told or he doesn't pay with toilet paper

00:03:04,040 --> 00:03:12,410
he won't go to jail so what we can do to

00:03:08,989 --> 00:03:15,769
help George do not go to jail first of

00:03:12,410 --> 00:03:17,900
all you may teach George how to count

00:03:15,769 --> 00:03:20,690
mine this is the perfect solution

00:03:17,900 --> 00:03:23,870
because it's going to work not only for

00:03:20,690 --> 00:03:26,180
this holidays but for all holidays in

00:03:23,870 --> 00:03:28,430
the future so it's the best and the most

00:03:26,180 --> 00:03:31,070
preferable way but it's not always

00:03:28,430 --> 00:03:31,330
possible let's say that we cannot do

00:03:31,070 --> 00:03:36,110
this

00:03:31,330 --> 00:03:38,989
so what else we can do first of all we

00:03:36,110 --> 00:03:42,049
may try to connect George suitcase every

00:03:38,989 --> 00:03:43,250
n minutes but the problem here is that

00:03:42,049 --> 00:03:47,710
we have to

00:03:43,250 --> 00:03:51,440
choose the volume n which we don't know

00:03:47,710 --> 00:03:54,740
how big it should be it keeps us busy

00:03:51,440 --> 00:03:57,380
for all the time because every let's say

00:03:54,740 --> 00:03:59,720
ten minutes we have to check dirt show

00:03:57,380 --> 00:04:02,120
me your suitcase so show me your

00:03:59,720 --> 00:04:02,530
suitcase how many how much money do you

00:04:02,120 --> 00:04:07,940
have

00:04:02,530 --> 00:04:11,720
so it's let's say possible but not

00:04:07,940 --> 00:04:14,500
perfect another solution is install some

00:04:11,720 --> 00:04:18,410
kind of IOT hardware in the suitcase

00:04:14,500 --> 00:04:22,100
notify us when there is X Manuel's

00:04:18,410 --> 00:04:25,610
let's say that X is the value that

00:04:22,100 --> 00:04:27,950
George needs to get back to home so when

00:04:25,610 --> 00:04:31,190
we get some application we can go to

00:04:27,950 --> 00:04:36,380
George and say my friend it's time to go

00:04:31,190 --> 00:04:40,250
home and refill your suitcase in the

00:04:36,380 --> 00:04:42,680
award we use money as resources but

00:04:40,250 --> 00:04:45,860
let's go back to the software and to

00:04:42,680 --> 00:04:48,979
Eames in Linux we have generally two

00:04:45,860 --> 00:04:51,229
types of resources first of them are

00:04:48,979 --> 00:04:54,320
system-wide it means that they are

00:04:51,229 --> 00:04:57,860
shared between multiple processes it's

00:04:54,320 --> 00:05:01,550
like CPU because we have limited CPU

00:04:57,860 --> 00:05:04,790
time it's the memory IO and many other

00:05:01,550 --> 00:05:07,280
resources for most of them we've got C

00:05:04,790 --> 00:05:09,830
groups which can be used to control or

00:05:07,280 --> 00:05:12,770
even some of those C groups like memory

00:05:09,830 --> 00:05:16,700
signal may be used to get notification

00:05:12,770 --> 00:05:19,790
about the usage on the other hand we

00:05:16,700 --> 00:05:22,700
have purchased specific resources those

00:05:19,790 --> 00:05:27,200
are resources which are which refer only

00:05:22,700 --> 00:05:29,510
to one process like CPU time as you see

00:05:27,200 --> 00:05:32,000
the CPU time is here and here because

00:05:29,510 --> 00:05:34,250
you may name it the CPU time for a group

00:05:32,000 --> 00:05:37,580
of processes and for one particular

00:05:34,250 --> 00:05:41,060
process look at the stack size which is

00:05:37,580 --> 00:05:41,940
private for every process number of Open

00:05:41,060 --> 00:05:45,030
File industry

00:05:41,940 --> 00:05:47,820
cetera most of these resources is

00:05:45,030 --> 00:05:50,880
controlled using their limits if you'd

00:05:47,820 --> 00:05:54,920
like to know or alter it is just man set

00:05:50,880 --> 00:05:57,600
their limits and you will get more evil

00:05:54,920 --> 00:06:02,250
so let's try to code

00:05:57,600 --> 00:06:06,230
George behavior in C we have a simple

00:06:02,250 --> 00:06:10,400
function we just opens the path and

00:06:06,230 --> 00:06:14,220
write the data to that file descriptor

00:06:10,400 --> 00:06:17,730
what are the problems first of all we

00:06:14,220 --> 00:06:19,650
don't check the return value and the

00:06:17,730 --> 00:06:23,430
second one we are not closing the

00:06:19,650 --> 00:06:30,840
punishment so is this function going to

00:06:23,430 --> 00:06:33,750
work yes as long as part is valid and as

00:06:30,840 --> 00:06:36,930
long as we won't reach the number of the

00:06:33,750 --> 00:06:39,180
limit of open file descriptors so in

00:06:36,930 --> 00:06:43,650
perfect environment when we don't have

00:06:39,180 --> 00:06:45,300
limits this is going to work but if we

00:06:43,650 --> 00:06:47,880
have limit for a number of open file

00:06:45,300 --> 00:06:51,320
descriptor this function is going to

00:06:47,880 --> 00:06:51,320
lose the data silently

00:06:52,310 --> 00:06:59,120
so what we can do the perfect solution

00:06:55,880 --> 00:07:01,669
this is the same as Luke George just go

00:06:59,120 --> 00:07:04,490
there and fix your body it's your back

00:07:01,669 --> 00:07:06,560
dysfunction is wrong and shouldn't look

00:07:04,490 --> 00:07:09,050
like this you should always check the

00:07:06,560 --> 00:07:11,360
return value and you should always close

00:07:09,050 --> 00:07:13,910
the file descriptor after reason so

00:07:11,360 --> 00:07:15,410
that's the perfect solution but what we

00:07:13,910 --> 00:07:18,950
can do if we don't have the source code

00:07:15,410 --> 00:07:21,110
if we are running the binary goals if we

00:07:18,950 --> 00:07:23,240
are running some preparatory libraries

00:07:21,110 --> 00:07:25,730
if you are running some other property

00:07:23,240 --> 00:07:29,240
resource and we cannot do anything with

00:07:25,730 --> 00:07:32,840
this so we can try to use some

00:07:29,240 --> 00:07:38,660
monitoring solutions who is working here

00:07:32,840 --> 00:07:43,040
with servers no one okay so who knows

00:07:38,660 --> 00:07:46,430
what not just this also know okay so not

00:07:43,040 --> 00:07:50,320
just is a software for monitoring server

00:07:46,430 --> 00:07:53,840
farms you can monitor the resource usage

00:07:50,320 --> 00:07:57,140
the number of running processes CPU

00:07:53,840 --> 00:08:00,440
memory usage and basically basic let's

00:07:57,140 --> 00:08:01,310
say how it works is that every ten

00:08:00,440 --> 00:08:05,180
minutes

00:08:01,310 --> 00:08:07,460
it checks the resource usage so every 10

00:08:05,180 --> 00:08:10,940
minutes you check the memory usage every

00:08:07,460 --> 00:08:13,160
10 minute to check you usage etc so we

00:08:10,940 --> 00:08:16,160
have no idea what happens between those

00:08:13,160 --> 00:08:21,100
checks but you've got this check in a

00:08:16,160 --> 00:08:25,970
given point in time it's classical

00:08:21,100 --> 00:08:29,479
pulling on the resource usage it's good

00:08:25,970 --> 00:08:31,669
for servers because usually you server

00:08:29,479 --> 00:08:34,430
is connected to some power plants and

00:08:31,669 --> 00:08:38,719
you've got almost unlimited power you're

00:08:34,430 --> 00:08:42,740
just going to get a bigger view but if

00:08:38,719 --> 00:08:46,130
you are trying to do this for small IOT

00:08:42,740 --> 00:08:49,280
devices our consumption and waking up

00:08:46,130 --> 00:08:51,010
the platform every 10 minutes every one

00:08:49,280 --> 00:08:54,160
minute or it depends

00:08:51,010 --> 00:08:56,850
on the interval of your check this

00:08:54,160 --> 00:09:00,220
starts to become a problem

00:08:56,850 --> 00:09:05,440
moreover we have no idea what happens

00:09:00,220 --> 00:09:09,040
between check and with we notice that in

00:09:05,440 --> 00:09:11,649
IOT world we have a long periods when

00:09:09,040 --> 00:09:14,860
nothing is happening and then the user

00:09:11,649 --> 00:09:17,980
can backs the phone and it starts okay

00:09:14,860 --> 00:09:22,769
so now turn on lights here to turn on

00:09:17,980 --> 00:09:28,290
lives here so you cannot let's say

00:09:22,769 --> 00:09:31,540
predicts where the usage is going to be

00:09:28,290 --> 00:09:34,240
so another solution is to get the

00:09:31,540 --> 00:09:38,290
notification from Colonel when level is

00:09:34,240 --> 00:09:41,170
reached or even better to get the

00:09:38,290 --> 00:09:46,510
notification before the limit which is

00:09:41,170 --> 00:09:48,459
enforced for that process is reached so

00:09:46,510 --> 00:09:51,130
for those of you who doesn't know and

00:09:48,459 --> 00:09:53,829
the earliness are pores in research

00:09:51,130 --> 00:09:57,010
specific way it means that for example

00:09:53,829 --> 00:10:00,820
for limit of hope and file descriptor if

00:09:57,010 --> 00:10:04,540
we get to the limit you will get the -

00:10:00,820 --> 00:10:09,550
in file error from the open if you reach

00:10:04,540 --> 00:10:12,250
the limit of CPU you will just get CQ if

00:10:09,550 --> 00:10:15,130
you reach any other level you will get

00:10:12,250 --> 00:10:18,399
the resource specific notification there

00:10:15,130 --> 00:10:22,329
is no generic mechanism to get the

00:10:18,399 --> 00:10:25,779
notification that you cross the limit so

00:10:22,329 --> 00:10:28,690
what what we try to do is to use kernel

00:10:25,779 --> 00:10:33,130
outlet subsystem to get a notification

00:10:28,690 --> 00:10:35,949
about reaching winnings how does it work

00:10:33,130 --> 00:10:42,209
we tried this for limit of open files

00:10:35,949 --> 00:10:45,010
and we try to trace the moment when open

00:10:42,209 --> 00:10:48,250
returned the Empire Valley

00:10:45,010 --> 00:10:50,890
so you just set the ER limit to some

00:10:48,250 --> 00:10:54,310
reasonable value for example for simple

00:10:50,890 --> 00:10:57,820
application 200 open files should be

00:10:54,310 --> 00:11:01,149
perfectly enough and then you use out

00:10:57,820 --> 00:11:04,750
system so install a filter to get

00:11:01,149 --> 00:11:08,940
notification when out Cisco when open

00:11:04,750 --> 00:11:08,940
Cisco returns the inner file

00:11:09,029 --> 00:11:16,540
what are the problems with this solution

00:11:11,649 --> 00:11:19,199
to be honest this works it's fine if it

00:11:16,540 --> 00:11:22,870
works but there are a couple of problems

00:11:19,199 --> 00:11:26,529
first of all we get only the post factor

00:11:22,870 --> 00:11:28,540
notification it means that process

00:11:26,529 --> 00:11:31,660
already received disparar

00:11:28,540 --> 00:11:34,630
if there is a bug in ever path obviously

00:11:31,660 --> 00:11:36,310
if there is a piece of code like this

00:11:34,630 --> 00:11:38,230
one on the previous slide when you are

00:11:36,310 --> 00:11:41,020
trying to write the data without

00:11:38,230 --> 00:11:44,560
checking the return value this data is

00:11:41,020 --> 00:11:48,880
shown to us you cannot do anything with

00:11:44,560 --> 00:11:50,649
this error is returned in the service so

00:11:48,880 --> 00:11:53,529
if there is a bottle I can now pointer

00:11:50,649 --> 00:11:56,310
the reference in the error part you are

00:11:53,529 --> 00:11:59,529
going to trigger this

00:11:56,310 --> 00:12:03,370
moreover not resources are traceable

00:11:59,529 --> 00:12:06,640
for example CPU usage does not depend on

00:12:03,370 --> 00:12:10,589
a system so it's hard to trace it if you

00:12:06,640 --> 00:12:10,589
trace only the system assistance

00:12:11,410 --> 00:12:24,400
and the last and the very big problem is

00:12:17,430 --> 00:12:27,070
slow out is really slow to trace only

00:12:24,400 --> 00:12:29,920
the open so install only the single

00:12:27,070 --> 00:12:34,180
filter for open system and for one

00:12:29,920 --> 00:12:39,640
return value there is an overhead of 33

00:12:34,180 --> 00:12:42,130
percent for open for opening code file I

00:12:39,640 --> 00:12:45,760
mean by code while I mean the file which

00:12:42,130 --> 00:12:49,060
is not cached previously which is read

00:12:45,760 --> 00:12:53,800
from from the disk and for hog file or

00:12:49,060 --> 00:12:57,490
for biologists on tmpfs you get 45

00:12:53,800 --> 00:13:00,820
percent of overhead it means that your

00:12:57,490 --> 00:13:04,330
system is running almost 50 percent

00:13:00,820 --> 00:13:09,130
slower than without monitoring using

00:13:04,330 --> 00:13:11,800
outlets so that's why we are trying to

00:13:09,130 --> 00:13:15,190
develop alternative solution which will

00:13:11,800 --> 00:13:18,240
give us a notification about resource

00:13:15,190 --> 00:13:22,560
usage without such overhead

00:13:18,240 --> 00:13:25,510
so this is where early me even comes and

00:13:22,560 --> 00:13:29,520
this is the notification sent by Colonel

00:13:25,510 --> 00:13:33,220
when daemon process crosses the certain

00:13:29,520 --> 00:13:36,220
resource usage level for example if you

00:13:33,220 --> 00:13:38,260
install the filter port then open file

00:13:36,220 --> 00:13:40,990
descriptors you will get the

00:13:38,260 --> 00:13:44,440
notification when process crosses from 9

00:13:40,990 --> 00:13:47,080
to 10 and then when process crosses from

00:13:44,440 --> 00:13:51,550
10 to 9 so every time you cross the line

00:13:47,080 --> 00:13:54,130
you get the notification so resource are

00:13:51,550 --> 00:13:56,209
are the same like inner limits because

00:13:54,130 --> 00:13:58,470
this is process specific

00:13:56,209 --> 00:14:01,850
notification is sent by while

00:13:58,470 --> 00:14:04,620
descriptors because if you do this in in

00:14:01,850 --> 00:14:06,630
using party scripture you will get the

00:14:04,620 --> 00:14:09,839
automatic cleanup when you close the

00:14:06,630 --> 00:14:11,550
file descriptor you don't need to handle

00:14:09,839 --> 00:14:15,990
that process lifecycle we are gonna have

00:14:11,550 --> 00:14:19,589
to do without it and monitoring level

00:14:15,990 --> 00:14:22,470
can be smaller than the actual limit set

00:14:19,589 --> 00:14:26,279
or that resource it means that you may

00:14:22,470 --> 00:14:28,589
set the early need for let's say 100

00:14:26,279 --> 00:14:31,949
file descriptor and the notification

00:14:28,589 --> 00:14:34,529
level for half of this it means that

00:14:31,949 --> 00:14:37,350
after you get a notification you still

00:14:34,529 --> 00:14:42,470
have the time to do something with that

00:14:37,350 --> 00:14:42,470
service before it will lose the data a

00:14:42,529 --> 00:14:48,420
little bit similar concept just for your

00:14:45,149 --> 00:14:52,350
information has been submitted a year

00:14:48,420 --> 00:14:54,510
ago or even more - okay now but it has

00:14:52,350 --> 00:14:56,970
been rejected due to trash from users

00:14:54,510 --> 00:15:00,660
there was a comment from the community

00:14:56,970 --> 00:15:01,940
that stress points our external API are

00:15:00,660 --> 00:15:04,860
not acceptable

00:15:01,940 --> 00:15:08,040
so they rejected the patch and the outer

00:15:04,860 --> 00:15:12,959
didn't send any Peaks or anything that's

00:15:08,040 --> 00:15:16,440
why we took up this so the API to be

00:15:12,959 --> 00:15:19,230
honest I really don't like this part but

00:15:16,440 --> 00:15:22,260
I didn't came up with anything more more

00:15:19,230 --> 00:15:27,449
clever so to get the notification file

00:15:22,260 --> 00:15:29,630
descriptor which is used to monitor you

00:15:27,449 --> 00:15:32,790
have to send message by a Natalie and

00:15:29,630 --> 00:15:35,519
then you received a brand new file

00:15:32,790 --> 00:15:37,920
descriptor and you may install some

00:15:35,519 --> 00:15:42,360
notification level for specific vit

00:15:37,920 --> 00:15:46,829
and for the resource and the level you'd

00:15:42,360 --> 00:15:49,829
like to monitor you use this you solve

00:15:46,829 --> 00:15:52,589
this using diversity oh and then you may

00:15:49,829 --> 00:15:57,080
simply read on that file descriptor or

00:15:52,589 --> 00:15:59,490
you use all to get them

00:15:57,080 --> 00:16:02,310
inside the notification you will get

00:15:59,490 --> 00:16:05,520
information about the PID of process

00:16:02,310 --> 00:16:11,790
which crosses which across the resource

00:16:05,520 --> 00:16:15,120
and the new level because our limits are

00:16:11,790 --> 00:16:17,490
inherited by all the children by default

00:16:15,120 --> 00:16:20,550
the notification levels are also

00:16:17,490 --> 00:16:23,250
inherited it means that the process is

00:16:20,550 --> 00:16:24,420
sport then you will get using this file

00:16:23,250 --> 00:16:29,300
descriptor you will get the notification

00:16:24,420 --> 00:16:29,300
about this process and all its children

00:16:29,600 --> 00:16:35,910
so the design inside the kernel on the

00:16:33,600 --> 00:16:39,210
left side you have structures connected

00:16:35,910 --> 00:16:41,760
with the process multiple tasks tracks

00:16:39,210 --> 00:16:45,950
point to the same signals track which is

00:16:41,760 --> 00:16:48,930
shared between all tasks in the process

00:16:45,950 --> 00:16:51,360
here we've got the struct file which is

00:16:48,930 --> 00:16:53,310
connected to the monitoring by

00:16:51,360 --> 00:16:57,180
descriptor so this is the monitoring

00:16:53,310 --> 00:17:01,950
side and this is the subject side this

00:16:57,180 --> 00:17:06,060
is the context of waters and water is

00:17:01,950 --> 00:17:08,280
the information about the level when you

00:17:06,060 --> 00:17:12,600
need to send a notification the user

00:17:08,280 --> 00:17:15,990
space so every water resides on two

00:17:12,600 --> 00:17:19,410
lists one of them is inside signals

00:17:15,990 --> 00:17:23,370
track and the second one is inside water

00:17:19,410 --> 00:17:24,390
when you add new level you added here

00:17:23,370 --> 00:17:27,810
and here

00:17:24,390 --> 00:17:32,400
every time when resources allocated you

00:17:27,810 --> 00:17:36,080
iterate over this list and check if you

00:17:32,400 --> 00:17:39,440
have to trigger some sandwich

00:17:36,080 --> 00:17:42,019
what are the benefits first of all if

00:17:39,440 --> 00:17:44,539
you compare this to outfit you don't

00:17:42,019 --> 00:17:49,279
need to do any kind of filtering in the

00:17:44,539 --> 00:17:52,190
user space without the design you've got

00:17:49,279 --> 00:17:55,220
a single out daemon which resides in the

00:17:52,190 --> 00:17:59,960
user space and then it has to route the

00:17:55,220 --> 00:18:02,179
communication to different plugins well

00:17:59,960 --> 00:18:05,450
the problem is that you have to wake up

00:18:02,179 --> 00:18:08,389
the algae team on pass the message then

00:18:05,450 --> 00:18:11,149
use another form of IPC to pass the

00:18:08,389 --> 00:18:13,519
message to another demon then you have

00:18:11,149 --> 00:18:17,059
to wake up another demon and check their

00:18:13,519 --> 00:18:19,100
usage and then it may turn out that for

00:18:17,059 --> 00:18:22,730
example you are not interested in this

00:18:19,100 --> 00:18:24,789
particular process or you are not

00:18:22,730 --> 00:18:27,440
interested in this particular resource

00:18:24,789 --> 00:18:30,039
so you have to do all the filtering in

00:18:27,440 --> 00:18:34,429
the user space it's not so easy to

00:18:30,039 --> 00:18:36,169
create a suitable audit filter which

00:18:34,429 --> 00:18:38,440
will be inherited by the process

00:18:36,169 --> 00:18:42,019
children

00:18:38,440 --> 00:18:44,629
nextly you can have multiple monitors

00:18:42,019 --> 00:18:46,789
you can have only one out of daemon

00:18:44,629 --> 00:18:50,119
which will get all the messages about

00:18:46,789 --> 00:18:52,489
whole system and here you may have

00:18:50,119 --> 00:18:54,590
multiple monitors which monitor only

00:18:52,489 --> 00:18:57,080
part of the system so for example you

00:18:54,590 --> 00:19:00,049
may say that now I'm monitoring only

00:18:57,080 --> 00:19:02,929
those two processes and another instance

00:19:00,049 --> 00:19:06,019
is monitoring another treat processes or

00:19:02,929 --> 00:19:09,080
anything like this multiple levels of

00:19:06,019 --> 00:19:11,840
notifications are allowed so not only

00:19:09,080 --> 00:19:16,450
the Empire the moment of reaching the

00:19:11,840 --> 00:19:16,450
limit but also multiple steps in between

00:19:17,860 --> 00:19:25,240
we can prevent the data loss so we can

00:19:22,289 --> 00:19:28,299
catch situations like on the previous

00:19:25,240 --> 00:19:29,980
slide so we can do something because

00:19:28,299 --> 00:19:32,529
usually if you have some preparatory

00:19:29,980 --> 00:19:35,830
service it's able to be restarted

00:19:32,529 --> 00:19:39,460
cleanly but it's not able to handle its

00:19:35,830 --> 00:19:43,179
own box so when he reaches the limit you

00:19:39,460 --> 00:19:46,690
may send the signal the C user or C term

00:19:43,179 --> 00:19:50,340
and restart it to free the process

00:19:46,690 --> 00:19:53,320
specific resources in addition

00:19:50,340 --> 00:19:56,230
Nagios and the monitoring system which i

00:19:53,320 --> 00:19:59,110
mentioned has the possibility to install

00:19:56,230 --> 00:20:01,809
passive checks and passive check is a

00:19:59,110 --> 00:20:04,600
kind of check where you don't run the

00:20:01,809 --> 00:20:07,029
schedule wire with the pulley and you

00:20:04,600 --> 00:20:10,299
just simply wait for wait for the

00:20:07,029 --> 00:20:13,360
messages so for example instead running

00:20:10,299 --> 00:20:16,570
every ten-minute a check for the number

00:20:13,360 --> 00:20:18,549
of open file descriptor you may create a

00:20:16,570 --> 00:20:21,370
plugin which will just send a

00:20:18,549 --> 00:20:24,220
notification when particular level is

00:20:21,370 --> 00:20:29,500
reached not to mention that most of not

00:20:24,220 --> 00:20:32,440
just uses is just simply run the check

00:20:29,500 --> 00:20:36,850
every 10 minute and then do something if

00:20:32,440 --> 00:20:41,710
the check is let's say 5 or 10 so it is

00:20:36,850 --> 00:20:43,380
almost the same functionality there is

00:20:41,710 --> 00:20:46,679
no free lunch

00:20:43,380 --> 00:20:49,320
it's not free air limit events are not

00:20:46,679 --> 00:20:51,960
free but are relatively cheap if you

00:20:49,320 --> 00:20:55,200
compare them to outlets the measured

00:20:51,960 --> 00:20:57,240
overhead is if there is single waters

00:20:55,200 --> 00:21:03,840
there is only one percent or even less

00:20:57,240 --> 00:21:07,169
and for a single water there is five

00:21:03,840 --> 00:21:11,880
percent overhead for hopefully and only

00:21:07,169 --> 00:21:14,160
1.6 percent overhead for cold time so if

00:21:11,880 --> 00:21:16,860
you compare this to Aldi where you had

00:21:14,160 --> 00:21:22,590
two digit results then it's really

00:21:16,860 --> 00:21:25,890
really cheap so the current state is PLC

00:21:22,590 --> 00:21:29,210
ready I'm going to send this but say in

00:21:25,890 --> 00:21:33,450
next two weeks to the LPL after I fix

00:21:29,210 --> 00:21:36,030
all the let's say hacks and implement

00:21:33,450 --> 00:21:37,980
pool maybe I will try to implement this

00:21:36,030 --> 00:21:41,669
for other resources not only for five

00:21:37,980 --> 00:21:44,840
descriptors and I want to send this as

00:21:41,669 --> 00:21:46,890
soon as possible to get feedback and

00:21:44,840 --> 00:21:48,600
this is also the goal of this

00:21:46,890 --> 00:21:51,030
presentation to get to collect feedback

00:21:48,600 --> 00:21:55,590
from you because personally for example

00:21:51,030 --> 00:21:57,330
I hate this solution with net link to

00:21:55,590 --> 00:21:59,580
get this but I didn't came up with

00:21:57,330 --> 00:22:02,820
something more clever because using

00:21:59,580 --> 00:22:05,309
process pass is not so easy to open to

00:22:02,820 --> 00:22:06,929
get special kinda file descriptor it's

00:22:05,309 --> 00:22:10,380
not the way you should use the process

00:22:06,929 --> 00:22:14,280
pass so if not project pass then 10

00:22:10,380 --> 00:22:16,770
volts bill to all device it also doesn't

00:22:14,280 --> 00:22:19,040
make any sense so now it's time for

00:22:16,770 --> 00:22:23,200
discussion

00:22:19,040 --> 00:22:26,840
if you have any comments and the ideas

00:22:23,200 --> 00:22:30,650
is the general Easter idea fine doesn't

00:22:26,840 --> 00:22:35,210
look to be acceptable in upstream is the

00:22:30,650 --> 00:22:37,430
API fine maybe we do maybe we may think

00:22:35,210 --> 00:22:39,200
about something better than that link to

00:22:37,430 --> 00:22:43,870
get this notification part descriptor

00:22:39,200 --> 00:22:47,600
and the last question is the security

00:22:43,870 --> 00:22:50,810
what permissions necessary to install

00:22:47,600 --> 00:22:53,870
watch for particular process do you have

00:22:50,810 --> 00:22:56,690
to be rude or we have to have access

00:22:53,870 --> 00:22:59,120
rights or you need to have some specific

00:22:56,690 --> 00:23:02,420
capabilities what do you think what's

00:22:59,120 --> 00:23:05,140
your opinion on those I'm open for any

00:23:02,420 --> 00:23:05,140
comments

00:23:10,559 --> 00:23:18,970
for the scripture I think it should be

00:23:14,790 --> 00:23:22,120
restricted to would be a good idea and

00:23:18,970 --> 00:23:24,670
for I mean okay my question is why do

00:23:22,120 --> 00:23:30,610
you use I beseech you do something with

00:23:24,670 --> 00:23:33,280
sweet oh you don't use right well I

00:23:30,610 --> 00:23:37,570
didn't want to use the right I left it

00:23:33,280 --> 00:23:40,090
so let's say for a future because if you

00:23:37,570 --> 00:23:44,080
would like to make this interface let's

00:23:40,090 --> 00:23:47,230
say more flexible I think the eye of

00:23:44,080 --> 00:23:50,350
skill is the better right to make it

00:23:47,230 --> 00:23:53,790
more flexible now we are using it's not

00:23:50,350 --> 00:23:56,530
right if you are using read to get the

00:23:53,790 --> 00:23:59,140
notification then right which is the

00:23:56,530 --> 00:24:03,100
opposite information for installing

00:23:59,140 --> 00:24:07,780
filters or removing filters and I think

00:24:03,100 --> 00:24:09,910
more abuse is to use the iris skill we

00:24:07,780 --> 00:24:12,670
have at least two type of messages you

00:24:09,910 --> 00:24:15,460
want to send install a new notification

00:24:12,670 --> 00:24:21,100
like them or remove the notification

00:24:15,460 --> 00:24:24,040
level so you know that's let's say using

00:24:21,100 --> 00:24:26,710
the right using right for this if you

00:24:24,040 --> 00:24:31,179
use read to get okay the resource has

00:24:26,710 --> 00:24:34,330
been reached and using the right okay

00:24:31,179 --> 00:24:37,720
I'd like to monitor this resource I mean

00:24:34,330 --> 00:24:40,090
let's say I pulled up using I see on

00:24:37,720 --> 00:24:43,330
will be more oh because I saw a lot of

00:24:40,090 --> 00:24:46,559
usage of biosphere this way so that

00:24:43,330 --> 00:24:46,559
that's why I also

00:24:47,870 --> 00:24:52,039
of you I noted user point of view it's

00:24:50,960 --> 00:24:56,799
easier on your user

00:24:52,039 --> 00:25:00,140
remind me to write and use it users API

00:24:56,799 --> 00:25:05,590
okay okay thank you I will try to

00:25:00,140 --> 00:25:05,590
consider is any more comments

00:25:07,690 --> 00:25:11,670
some terminal developers here

00:25:14,490 --> 00:25:22,440
does the idea itself looks fine or are

00:25:18,279 --> 00:25:22,440
there some obvious box which I don't see

00:25:23,909 --> 00:25:27,299
my question

00:25:29,440 --> 00:25:36,090
so who we gonna submit this to I guess

00:25:32,200 --> 00:25:39,400
is the question who's the maintainer I

00:25:36,090 --> 00:25:42,070
didn't check because it's let's say the

00:25:39,400 --> 00:25:45,670
problem with everything is a stop every

00:25:42,070 --> 00:25:48,760
subsystem every limit holds the volume

00:25:45,670 --> 00:25:52,120
on its own right so the work is split

00:25:48,760 --> 00:25:55,570
between many different subsystems and as

00:25:52,120 --> 00:25:57,790
a I don't call myself a car lover I have

00:25:55,570 --> 00:25:59,560
been also at her own past and these

00:25:57,790 --> 00:26:01,420
types of matches that cover lots of

00:25:59,560 --> 00:26:04,450
subsystems they're notoriously difficult

00:26:01,420 --> 00:26:06,040
to get upstream yes I guess you got to

00:26:04,450 --> 00:26:08,890
get a bunch of people on the same page

00:26:06,040 --> 00:26:12,340
and a lot of times people anyway it's

00:26:08,890 --> 00:26:14,950
not it's like a tangential to their main

00:26:12,340 --> 00:26:17,740
work right the system work so then you

00:26:14,950 --> 00:26:19,360
don't get as much attention this anyway

00:26:17,740 --> 00:26:22,630
that's just a caveat I never have any

00:26:19,360 --> 00:26:24,250
solution yeah yeah I know it's that's

00:26:22,630 --> 00:26:26,980
why I'm doing this presentation because

00:26:24,250 --> 00:26:29,170
it's gonna be hard to get this inside

00:26:26,980 --> 00:26:31,660
the kernel there are a couple of obvious

00:26:29,170 --> 00:26:34,120
problems like for example for number of

00:26:31,660 --> 00:26:36,550
open pipe descriptors there is simply no

00:26:34,120 --> 00:26:38,890
counting of such things like number of

00:26:36,550 --> 00:26:41,500
open file descriptors there is just the

00:26:38,890 --> 00:26:45,220
bitmap and there is no function get

00:26:41,500 --> 00:26:48,460
number even and you cannot simply derive

00:26:45,220 --> 00:26:51,700
such a function because there is no

00:26:48,460 --> 00:26:54,820
looking for for this bitmap it just each

00:26:51,700 --> 00:26:56,610
of every operation is atomic and you

00:26:54,820 --> 00:26:59,650
don't have any spin lock or anything

00:26:56,610 --> 00:27:03,520
like this so there are a couple of major

00:26:59,650 --> 00:27:05,500
changes in different subsystems and it's

00:27:03,520 --> 00:27:12,330
going to be really hard and thankful to

00:27:05,500 --> 00:27:14,270
get this any more comments questions

00:27:12,330 --> 00:27:16,820
okay so

00:27:14,270 --> 00:27:19,040
thank you for your attention if you're

00:27:16,820 --> 00:27:21,920
interested than the cold is on my heat

00:27:19,040 --> 00:27:25,190
card also the tests the user space

00:27:21,920 --> 00:27:27,790
application feel free to grab it to send

00:27:25,190 --> 00:27:27,790
me some comments

00:27:29,790 --> 00:27:37,130
[Applause]

00:27:31,930 --> 00:27:37,130

YouTube URL: https://www.youtube.com/watch?v=Nc18N2lQvqs


