Title: Internet of Tiny Linux (IoTL): Episode IV - SFO17-100
Publication date: 2017-09-29
Playlist: Linaro Connect San Francisco 2017
Description: 
	Session ID: SFO17-100
Session Name: Internet of Tiny Linux (IoTL): Episode IV  - SFO17-100
Speaker: Nicolas Pitre
Track: LITE


★ Session Summary ★
This is a discussion on various methods, from low hanging fruits to more
daring approaches, being put forward to reduce the size of Linux kernel
and user space binaries to make them suitable for very small IoT
applications. Latest results in terms of effectiveness and upstream
acceptance will be discussed. Spoiler Alert: With luck, a tiny demo
might be thrown in!
---------------------------------------------------
★ Resources ★
Event Page: http://connect.linaro.org/resource/sfo17/sfo17-100/
Presentation: 
Video: 
 ---------------------------------------------------

★ Event Details ★
Linaro Connect San Francisco 2017 (SFO17)
25-29 September 2017
Hyatt Regency San Francisco Airport

---------------------------------------------------
Keyword: 
'http://www.linaro.org'
'http://connect.linaro.org'
---------------------------------------------------
Follow us on Social Media
https://www.facebook.com/LinaroOrg
https://twitter.com/linaroorg
https://www.youtube.com/user/linaroorg?sub_confirmation=1
https://www.linkedin.com/company/1026961
Captions: 
	00:00:00,120 --> 00:00:04,060
[Music]

00:00:08,910 --> 00:00:12,320
[Music]

00:00:13,780 --> 00:00:19,430
so my name is Nicola Pitts I've been

00:00:17,240 --> 00:00:24,140
working for Lyn arrow since the

00:00:19,430 --> 00:00:26,900
beginning for the last two years I've

00:00:24,140 --> 00:00:29,210
worked on this project trying to shrink

00:00:26,900 --> 00:00:34,670
the Linux kernel so it can be suitable

00:00:29,210 --> 00:00:36,650
for IOT purposes someone said in the

00:00:34,670 --> 00:00:39,590
previous presentation that Zephyr is

00:00:36,650 --> 00:00:43,129
there where Linux can go but my goal is

00:00:39,590 --> 00:00:50,510
to push Linux downwards where Zephyr is

00:00:43,129 --> 00:00:53,330
right now so as you probably know I am

00:00:50,510 --> 00:00:55,820
blind so if you have questions or

00:00:53,330 --> 00:00:59,600
remarks please don't raise your hand to

00:00:55,820 --> 00:01:10,490
just just speak up otherwise I won't

00:00:59,600 --> 00:01:13,270
notice you okay so slide number tree III

00:01:10,490 --> 00:01:15,590
do have only a half an hour for this

00:01:13,270 --> 00:01:17,510
material so I'll go fast because

00:01:15,590 --> 00:01:21,350
otherwise I could talk about it for more

00:01:17,510 --> 00:01:27,649
than an hour so slide number three

00:01:21,350 --> 00:01:30,439
IOT goals of course we want to have we

00:01:27,649 --> 00:01:32,570
have locus ubiquity and everything we

00:01:30,439 --> 00:01:38,359
can have for high OD purposes it has to

00:01:32,570 --> 00:01:43,369
be cheap as we secure so slides for

00:01:38,359 --> 00:01:46,340
solutions you already know all about

00:01:43,369 --> 00:01:49,189
this we have to avoid custom solutions

00:01:46,340 --> 00:01:55,189
work around common infrastructure and so

00:01:49,189 --> 00:02:00,229
on slide number five please so Linux is

00:01:55,189 --> 00:02:02,390
probably one of the best common piece of

00:02:00,229 --> 00:02:06,259
code out there so if we can leverage

00:02:02,390 --> 00:02:09,140
Linux for IT purposes we're going to

00:02:06,259 --> 00:02:12,460
have all the those nice features as -

00:02:09,140 --> 00:02:17,810
carries which is a lot of developers a

00:02:12,460 --> 00:02:22,240
good Network stack and Linux is already

00:02:17,810 --> 00:02:22,240
widely using - embedded setups and so on

00:02:22,510 --> 00:02:27,950
slide number six

00:02:25,250 --> 00:02:32,900
probably what Linux is it's big as

00:02:27,950 --> 00:02:36,420
people have noticed it can go it cannot

00:02:32,900 --> 00:02:41,490
work with systems with a really small

00:02:36,420 --> 00:02:46,290
memory it is tuned for very high-end

00:02:41,490 --> 00:02:53,700
systems and usually it scales up more

00:02:46,290 --> 00:02:58,980
than it scales down okay slice number

00:02:53,700 --> 00:03:03,210
seven there are automatic techniques to

00:02:58,980 --> 00:03:05,340
reduce the Linux kernel we can't have

00:03:03,210 --> 00:03:08,610
the linker discard the sections that are

00:03:05,340 --> 00:03:11,850
not being used we can use LTO which is a

00:03:08,610 --> 00:03:17,660
link time optimization that GC GC c

00:03:11,850 --> 00:03:21,030
provides or manual techniques with

00:03:17,660 --> 00:03:25,320
including more configuration options to

00:03:21,030 --> 00:03:27,540
remove pieces that are not used or we

00:03:25,320 --> 00:03:34,370
implement part of the code into a

00:03:27,540 --> 00:03:39,270
smaller format that's slide number eight

00:03:34,370 --> 00:03:40,980
this is an example of subsystem trimming

00:03:39,270 --> 00:03:45,300
that have been already implemented in

00:03:40,980 --> 00:03:52,350
the kernel so we can remove friend cake

00:03:45,300 --> 00:03:55,470
and remove NTP support and so on slice

00:03:52,350 --> 00:03:57,630
number nine so one of the thing I did

00:03:55,470 --> 00:04:00,180
since my last presentation is to

00:03:57,630 --> 00:04:02,520
introduce more options to remove some of

00:04:00,180 --> 00:04:06,270
the part of the kernel which is for

00:04:02,520 --> 00:04:08,700
example removing the POSIX timers most

00:04:06,270 --> 00:04:12,300
of the time in some embedded setups we

00:04:08,700 --> 00:04:15,360
don't have a need for the full speck of

00:04:12,300 --> 00:04:19,590
the POSIX timers so removing them it

00:04:15,360 --> 00:04:23,400
reduces the whole time subsystem and

00:04:19,590 --> 00:04:26,960
rejection of 28% which is not that bad

00:04:23,400 --> 00:04:33,270
for something that we don't use right

00:04:26,960 --> 00:04:36,110
this is available in kernel 4.10 slice

00:04:33,270 --> 00:04:36,110
number 10 please

00:04:36,760 --> 00:04:44,740
I also submitted some patches to remove

00:04:39,880 --> 00:04:50,530
the p i-- few taxes so if you don't need

00:04:44,740 --> 00:04:52,630
priority in inversions of parity in the

00:04:50,530 --> 00:04:57,760
recent support in your colonel if you

00:04:52,630 --> 00:04:59,740
don't have the real-time mutex support

00:04:57,760 --> 00:05:03,190
in your colonel you cannot have the api

00:04:59,740 --> 00:05:08,280
few taxes so now it's possible to have

00:05:03,190 --> 00:05:08,280
simple few texts without the api support

00:05:08,310 --> 00:05:17,470
it really provides a 51% size reduction

00:05:13,150 --> 00:05:23,230
on that piece of code this has been

00:05:17,470 --> 00:05:27,880
merged into the latest colonel slides

00:05:23,230 --> 00:05:30,270
numbered 11 another thing i worked on is

00:05:27,880 --> 00:05:33,010
to reduce the size of the scheduler i

00:05:30,270 --> 00:05:38,530
hinted about that last time I presented

00:05:33,010 --> 00:05:42,250
this it provides a really nice size

00:05:38,530 --> 00:05:44,260
reduction of the scheduler thing is the

00:05:42,250 --> 00:05:51,280
chances for those things to be merged

00:05:44,260 --> 00:05:55,810
upstream are very slim so I took another

00:05:51,280 --> 00:06:00,040
approach slide number 12 is to use the

00:05:55,810 --> 00:06:01,870
existing current scheduler code and

00:06:00,040 --> 00:06:04,720
remove part of it

00:06:01,870 --> 00:06:08,500
for example the deadlines class

00:06:04,720 --> 00:06:16,360
scheduler is rarely needed in embedded

00:06:08,500 --> 00:06:20,500
setups so I managed for the scheduler to

00:06:16,360 --> 00:06:24,490
be able to configure that part out it is

00:06:20,500 --> 00:06:26,530
more much less intrusive and the problem

00:06:24,490 --> 00:06:28,980
in year work has been merged already in

00:06:26,530 --> 00:06:28,980
the kernel

00:06:31,130 --> 00:06:40,370
slide number 13 same thing can be done

00:06:34,460 --> 00:06:42,860
for the real-time class so with those

00:06:40,370 --> 00:06:45,650
two things being combined we can have a

00:06:42,860 --> 00:06:50,480
nice reduction of the credit at the

00:06:45,650 --> 00:06:54,410
scheduler size it's not as small as the

00:06:50,480 --> 00:06:56,510
tiny scheduler implementation I did but

00:06:54,410 --> 00:06:57,530
the thing is if it can be merged

00:06:56,510 --> 00:06:59,780
upstream

00:06:57,530 --> 00:07:01,910
there's mode more chance that people

00:06:59,780 --> 00:07:11,030
will use it and maintaining that then if

00:07:01,910 --> 00:07:12,620
it's kept outside slide 14 even then had

00:07:11,030 --> 00:07:17,420
some problem with upstream maintainers

00:07:12,620 --> 00:07:23,210
right so basically what Ingo Molnar told

00:07:17,420 --> 00:07:25,610
me is if I cannot demonstrate this into

00:07:23,210 --> 00:07:30,020
a real product there is no point in

00:07:25,610 --> 00:07:35,800
merging all this into mainline which

00:07:30,020 --> 00:07:35,800
makes kind of sense of course so I

00:07:35,830 --> 00:07:42,110
decided that I need to have something

00:07:38,750 --> 00:07:44,840
that runs onto real Hardware real target

00:07:42,110 --> 00:07:51,500
hardware so slide 15

00:07:44,840 --> 00:07:58,280
I chose a target hardware platform which

00:07:51,500 --> 00:08:00,620
is the stm32f4 six line disco board it

00:07:58,280 --> 00:08:04,040
comes with it's it's a pretty beefy

00:08:00,620 --> 00:08:08,810
board already it has a lot of RAM and

00:08:04,040 --> 00:08:11,860
flash that can run Linux already so

00:08:08,810 --> 00:08:11,860
what's the point

00:08:16,520 --> 00:08:24,620
slide 16 the ultimate goal is to be able

00:08:21,120 --> 00:08:28,680
to run Linux on this single

00:08:24,620 --> 00:08:32,520
microcontroller alone it has a tiny

00:08:28,680 --> 00:08:38,760
amount of SRAM dwell built into the chip

00:08:32,520 --> 00:08:42,390
so if that can accommodate Linux then we

00:08:38,760 --> 00:08:52,529
could have a really nice target for this

00:08:42,390 --> 00:08:54,900
project slide 17 of course

00:08:52,529 --> 00:08:59,279
I needed to have a change of strategy

00:08:54,900 --> 00:09:03,300
here when we talk about shrinking the

00:08:59,279 --> 00:09:09,050
kernel most people think about this code

00:09:03,300 --> 00:09:13,589
size thing is this microcontroller has

00:09:09,050 --> 00:09:17,910
quite a large amount of flash memory but

00:09:13,589 --> 00:09:22,830
a tiny amount of RAM so the idea is to

00:09:17,910 --> 00:09:27,110
put as much code or read-only data into

00:09:22,830 --> 00:09:36,900
flash and focus on the reduction of

00:09:27,110 --> 00:09:43,370
readwrite data usage so to do this slide

00:09:36,900 --> 00:09:43,370
18 first thing kernel xip

00:09:43,610 --> 00:09:51,060
this is great because that work has

00:09:47,190 --> 00:09:56,089
already been done before the thing is

00:09:51,060 --> 00:09:59,130
that I added to it is to compress the

00:09:56,089 --> 00:10:01,800
data segment that is going to be copied

00:09:59,130 --> 00:10:05,839
into Ram anyway but store it compress

00:10:01,800 --> 00:10:08,820
into flash so the flash space is more

00:10:05,839 --> 00:10:16,710
there's more flash memory available for

00:10:08,820 --> 00:10:22,420
other things afterwards slea slide 19

00:10:16,710 --> 00:10:25,540
userspace xip if we want to reduce RAM

00:10:22,420 --> 00:10:30,820
usage we need to be concerned about user

00:10:25,540 --> 00:10:36,190
space as well so to be able to run user

00:10:30,820 --> 00:10:43,330
space from flash into an assist system

00:10:36,190 --> 00:10:47,110
with no MMU we have to look at some file

00:10:43,330 --> 00:10:50,500
format that are able to split the text

00:10:47,110 --> 00:10:53,620
segment and a data segment so that text

00:10:50,500 --> 00:10:59,110
segment can be run from flash and not be

00:10:53,620 --> 00:11:02,380
tied with the data segment so on the new

00:10:59,110 --> 00:11:05,800
MMU support for linux there are two file

00:11:02,380 --> 00:11:10,780
format that can be used the BFL T which

00:11:05,800 --> 00:11:13,530
is the legacy you see Linux format I've

00:11:10,780 --> 00:11:18,310
been that's been developed thing is it's

00:11:13,530 --> 00:11:22,630
pretty badly documented that the tools

00:11:18,310 --> 00:11:25,090
to deal with it are kind of hard to work

00:11:22,630 --> 00:11:29,680
with especially we want to have separate

00:11:25,090 --> 00:11:35,680
data and text segment the other file

00:11:29,680 --> 00:11:38,290
format is the FD pick for elf that

00:11:35,680 --> 00:11:40,960
format is really nice because it has

00:11:38,290 --> 00:11:44,830
been designed from the start to deal

00:11:40,960 --> 00:11:48,280
with separate text and data segments it

00:11:44,830 --> 00:11:52,270
can be processed with standard tools it

00:11:48,280 --> 00:11:57,910
can be inspected with binutils without

00:11:52,270 --> 00:12:00,700
any modifications so that's what I used

00:11:57,910 --> 00:12:02,620
and I really thank the SD guys who

00:12:00,700 --> 00:12:07,480
worked on this so I could use their

00:12:02,620 --> 00:12:10,350
patches and I just made them suitable

00:12:07,480 --> 00:12:12,940
for mainline out streaming so apparently

00:12:10,350 --> 00:12:19,680
this is going to be merged into mainline

00:12:12,940 --> 00:12:22,680
for the next merge window slide number

00:12:19,680 --> 00:12:22,680
00:12:23,600 --> 00:12:28,380
four user space excite me to be possible

00:12:26,460 --> 00:12:35,490
we need to have a special file system as

00:12:28,380 --> 00:12:37,920
well so I settled on the krampf because

00:12:35,490 --> 00:12:41,670
it's simple it uses very little memory

00:12:37,920 --> 00:12:44,160
and there used to be a patch set back in

00:12:41,670 --> 00:12:47,430
the days that made it possible to use a

00:12:44,160 --> 00:12:51,690
user space xip with it

00:12:47,430 --> 00:12:55,590
I dusted them off and ended up rewriting

00:12:51,690 --> 00:13:01,590
them because I wanted to spatulas to be

00:12:55,590 --> 00:13:05,070
up streamable so I made xip work with

00:13:01,590 --> 00:13:09,630
annual no mm you and mm you version of

00:13:05,070 --> 00:13:15,240
Linux if you use those patches okay

00:13:09,630 --> 00:13:19,620
slide 21 back to the kernel the kernel

00:13:15,240 --> 00:13:23,880
itself has some kind of memory footprint

00:13:19,620 --> 00:13:26,490
it's data segment is copied to RAM so we

00:13:23,880 --> 00:13:27,390
we need to look at it and reduce it as

00:13:26,490 --> 00:13:30,720
much as possible

00:13:27,390 --> 00:13:37,500
the default kernel I have it started

00:13:30,720 --> 00:13:47,490
with 80k for data usage and 54k of BSS

00:13:37,500 --> 00:13:50,460
usage so slide 22 I write a script to

00:13:47,490 --> 00:13:54,480
find out what those symbols were so the

00:13:50,460 --> 00:13:58,530
idea is to take the system that map file

00:13:54,480 --> 00:14:00,510
and just subtract once when the address

00:13:58,530 --> 00:14:04,320
of one symbol from the previous one to

00:14:00,510 --> 00:14:09,870
get this size a result of that is on

00:14:04,320 --> 00:14:13,500
slide 23 we can see that the biggest

00:14:09,870 --> 00:14:15,450
variable there is the log buffer which

00:14:13,500 --> 00:14:17,340
is the print key that's that's easy to

00:14:15,450 --> 00:14:23,010
reduce because there's already configure

00:14:17,340 --> 00:14:26,370
options to decide the size of this but

00:14:23,010 --> 00:14:29,040
there are other things like the the

00:14:26,370 --> 00:14:30,089
timer infrastructure the work hue and so

00:14:29,040 --> 00:14:37,309
on that

00:14:30,089 --> 00:14:37,309
taking more space if we look at slide 24

00:14:39,740 --> 00:14:47,249
there are things like the the thread

00:14:44,759 --> 00:14:51,569
size which is the size of the stack of

00:14:47,249 --> 00:14:55,170
every process in the kernel the first

00:14:51,569 --> 00:14:58,620
one is the init process it uses the BSS

00:14:55,170 --> 00:15:01,850
segment so if we we put only one page

00:14:58,620 --> 00:15:03,959
for each stack that reduces BSS and

00:15:01,850 --> 00:15:07,319
things afterward that we'll see later

00:15:03,959 --> 00:15:10,529
and various hash tables that have

00:15:07,319 --> 00:15:13,559
parameters to decide their sizes though

00:15:10,529 --> 00:15:19,050
those things are pretty arbitrary so we

00:15:13,559 --> 00:15:20,999
can modify those to put very small

00:15:19,050 --> 00:15:22,769
tables instead of big tables especially

00:15:20,999 --> 00:15:25,019
if we have little memory in the system

00:15:22,769 --> 00:15:35,759
we don't have we don't need to have big

00:15:25,019 --> 00:15:40,050
tables it's like 25 results I obtained

00:15:35,759 --> 00:15:46,199
witness simple tweaks a 28% reduction in

00:15:40,050 --> 00:15:54,470
the static footprint of the kernel which

00:15:46,199 --> 00:15:54,470
is pretty nice already okay

00:15:54,520 --> 00:16:04,730
slide 26 so let's boot these this thing

00:16:00,970 --> 00:16:09,650
first thing we can see is that the

00:16:04,730 --> 00:16:17,150
kernel is using 32 pages of RAM just to

00:16:09,650 --> 00:16:20,210
track memory pages in the system so of

00:16:17,150 --> 00:16:24,020
course I was using this a disco board

00:16:20,210 --> 00:16:27,320
which has 16 megabytes of RAM with that

00:16:24,020 --> 00:16:28,820
amount of RAM we of course require a big

00:16:27,320 --> 00:16:31,660
map Harry

00:16:28,820 --> 00:16:35,060
average is to represent all the memory

00:16:31,660 --> 00:16:36,980
so that that's easy to solve we just

00:16:35,060 --> 00:16:43,730
reduce the amount of memory that kernel

00:16:36,980 --> 00:16:53,780
can see there's another thing that is

00:16:43,730 --> 00:16:58,030
not tracked here and after some digging

00:16:53,780 --> 00:17:02,210
I rely I discovered that the

00:16:58,030 --> 00:17:07,220
unflattering device tree occupies

00:17:02,210 --> 00:17:10,880
something like 13 pages I didn't talk

00:17:07,220 --> 00:17:14,720
much to device 3 people yet but what the

00:17:10,880 --> 00:17:18,920
heck is in those 13 pages for a system

00:17:14,720 --> 00:17:21,680
that small if this data could be stored

00:17:18,920 --> 00:17:26,329
into flash instead of RAM because

00:17:21,680 --> 00:17:29,030
otherwise Ram is I will have to verify

00:17:26,329 --> 00:17:31,490
with with device tree people is this

00:17:29,030 --> 00:17:34,280
data being modified after boot or not if

00:17:31,490 --> 00:17:36,830
there's a way to store this into flash

00:17:34,280 --> 00:17:43,760
instead of RAM we're going to save space

00:17:36,830 --> 00:17:49,930
for further things here as well ok

00:17:43,760 --> 00:17:49,930
that's static Ram slide 27

00:17:50,640 --> 00:17:56,580
then there are some tweaks to reduce the

00:17:53,670 --> 00:18:02,960
dynamic memory allocation from the

00:17:56,580 --> 00:18:09,540
kernel for example the work you are

00:18:02,960 --> 00:18:14,670
allocating per CPU memory as well and

00:18:09,540 --> 00:18:17,400
there's the per CPU allocator we still

00:18:14,670 --> 00:18:22,260
have only one CPU of course but the pure

00:18:17,400 --> 00:18:25,830
CPU a locator is there I did some

00:18:22,260 --> 00:18:27,870
changes to do so it reserves only one

00:18:25,830 --> 00:18:32,820
page of memory instead of eight by

00:18:27,870 --> 00:18:36,320
default by reducing the amount of memory

00:18:32,820 --> 00:18:41,300
that the kernel can see the memo array

00:18:36,320 --> 00:18:41,300
shrinks from 32 page to only two pages

00:18:48,530 --> 00:18:57,710
slide 28 what about the in it calls it

00:18:54,350 --> 00:19:00,440
could be a good idea to track what each

00:18:57,710 --> 00:19:08,330
in his collar is using an internal

00:19:00,440 --> 00:19:11,870
amount of memory there so slide 29 we

00:19:08,330 --> 00:19:14,840
can see the list here of memory usage by

00:19:11,870 --> 00:19:22,580
page for each system calls do you see a

00:19:14,840 --> 00:19:25,400
flair there again it has the of' prefix

00:19:22,580 --> 00:19:28,570
i guess i have to talk to the same

00:19:25,400 --> 00:19:28,570
people once again

00:19:30,760 --> 00:19:40,640
slide 30 so from user space once it's

00:19:36,320 --> 00:19:42,860
booted we can inspect proc info and so

00:19:40,640 --> 00:19:48,020
on to see what the memory representation

00:19:42,860 --> 00:19:51,440
is one thing which is interesting here

00:19:48,020 --> 00:19:56,330
is that memory dedicated to user space

00:19:51,440 --> 00:19:59,570
is only 84 K and here I'm running a

00:19:56,330 --> 00:20:10,280
shell and the cat process that displays

00:19:59,570 --> 00:20:13,280
the the information there so slide 31 so

00:20:10,280 --> 00:20:17,090
that's about the memory distribution

00:20:13,280 --> 00:20:21,169
that I could figure out so far there's

00:20:17,090 --> 00:20:25,490
about 1 in 100 40k of device tree data

00:20:21,169 --> 00:20:29,690
there this is probably the biggest use

00:20:25,490 --> 00:20:32,179
memory user so far and things don't

00:20:29,690 --> 00:20:38,240
balance they are still memory that in I

00:20:32,179 --> 00:20:42,200
didn't manage to track so far but still

00:20:38,240 --> 00:20:44,330
if we think about this the the previous

00:20:42,200 --> 00:20:47,059
goal and I wanted to run Linux on to

00:20:44,330 --> 00:20:50,900
that microcontroller right now it is

00:20:47,059 --> 00:20:57,370
running into 800 K of RAM

00:20:50,900 --> 00:21:01,200
I would like to lower it this to maybe

00:20:57,370 --> 00:21:04,110
512 but I've been told by the SD

00:21:01,200 --> 00:21:06,270
some st guide that they do have a

00:21:04,110 --> 00:21:10,770
version of their microcontroller that

00:21:06,270 --> 00:21:12,570
has one megabyte of static ram in it so

00:21:10,770 --> 00:21:14,580
if we take that particular

00:21:12,570 --> 00:21:24,870
microcontroller the goal has been

00:21:14,580 --> 00:21:28,680
acheived already so slight 32 it's much

00:21:24,870 --> 00:21:36,690
easier to shrink data usage then code

00:21:28,680 --> 00:21:38,280
size that's one thing I realized so the

00:21:36,690 --> 00:21:42,060
solution that I have here is still

00:21:38,280 --> 00:21:45,810
incomplete there's some work to do need

00:21:42,060 --> 00:21:48,390
to find some strategies for device tree

00:21:45,810 --> 00:21:56,070
support maybe you see what's been done

00:21:48,390 --> 00:22:00,660
with the visor in zephyr and now if we

00:21:56,070 --> 00:22:04,470
have time do we have them eight minutes

00:22:00,660 --> 00:22:14,010
I do have a board I can show you can

00:22:04,470 --> 00:22:16,230
boot it in front of this crowd once

00:22:14,010 --> 00:22:18,560
again if someone could display this on

00:22:16,230 --> 00:22:18,560
the screen

00:22:23,960 --> 00:22:28,160
yes it's only a USB cable

00:22:37,440 --> 00:22:48,720
so that goes in the packet yeah its

00:22:41,850 --> 00:22:52,010
power and the CEO power here any USB

00:22:48,720 --> 00:22:55,800
song just this one okay

00:22:52,010 --> 00:23:00,540
okay I mean it mean it needs to be

00:22:55,800 --> 00:23:07,320
connected to a laptop like okay hang on

00:23:00,540 --> 00:23:21,810
to that bring it with you I mean the

00:23:07,320 --> 00:23:24,410
board so you have a terminal you made it

00:23:21,810 --> 00:23:24,410
emulator

00:23:44,700 --> 00:23:54,340
yeah it probably depends of where the

00:23:49,450 --> 00:23:56,050
memory I didn't track yet is for for

00:23:54,340 --> 00:23:59,800
example device tree is a big chunk of

00:23:56,050 --> 00:24:02,200
memory there is still some memory

00:23:59,800 --> 00:24:05,170
unaccounted for so I need to find out

00:24:02,200 --> 00:24:09,910
word where that is there's for example

00:24:05,170 --> 00:24:13,960
there's a long stream of very small BSS

00:24:09,910 --> 00:24:16,690
allocations from the kernel and while I

00:24:13,960 --> 00:24:22,870
was able to tweak those for the large

00:24:16,690 --> 00:24:24,790
hash table the the long stream of very

00:24:22,870 --> 00:24:27,580
small allocation like four bytes

00:24:24,790 --> 00:24:32,590
allocation all over the place those are

00:24:27,580 --> 00:24:36,760
much harder to to remove because it's a

00:24:32,590 --> 00:24:41,980
lot of things and one thing I noticed as

00:24:36,760 --> 00:24:47,470
well is that even though I am I used

00:24:41,980 --> 00:24:50,410
LTO to reduce the kernel size when once

00:24:47,470 --> 00:24:54,720
the kernel is that small at some point

00:24:50,410 --> 00:24:57,520
there is not much else to remove and

00:24:54,720 --> 00:25:00,700
even if the code is being optimized by

00:24:57,520 --> 00:25:04,330
LTO it doesn't reduce the amount of data

00:25:00,700 --> 00:25:06,790
usage that much so it's it's really

00:25:04,330 --> 00:25:13,660
about finding where the rest of the

00:25:06,790 --> 00:25:19,679
memory data in thank you but if

00:25:13,660 --> 00:25:24,340
eventually if we have Linux running into

00:25:19,679 --> 00:25:26,200
640 K of RAM someone said at some point

00:25:24,340 --> 00:25:29,040
that it would have to be enough for

00:25:26,200 --> 00:25:29,040
everybody right

00:26:01,720 --> 00:26:10,340
and most most of what I presented is in

00:26:05,480 --> 00:26:15,770
my tree most of it is destined to be

00:26:10,340 --> 00:26:20,600
submitted upstream there are some pretty

00:26:15,770 --> 00:26:23,030
nice hacks that I didn't publish like

00:26:20,600 --> 00:26:25,370
just over writing constants in the

00:26:23,030 --> 00:26:28,520
kernel that those are hard-coded at the

00:26:25,370 --> 00:26:51,980
moment they need to be selectable

00:26:28,520 --> 00:26:56,690
somehow well I think it's a question of

00:26:51,980 --> 00:26:59,120
awareness and right now most developers

00:26:56,690 --> 00:27:03,620
did they just don't care because they

00:26:59,120 --> 00:27:06,110
don't see the need so that's why too

00:27:03,620 --> 00:27:08,990
convinced the upstream maintainer zazz

00:27:06,110 --> 00:27:11,539
well I wanted to have a target that I

00:27:08,990 --> 00:27:15,110
can show that I can run Linux into that

00:27:11,539 --> 00:27:17,030
small amount of memory so at that point

00:27:15,110 --> 00:27:20,360
it becomes the awareness of the

00:27:17,030 --> 00:27:23,720
usefulness of this thing and afterwards

00:27:20,360 --> 00:27:27,760
we can have automatic scripts that will

00:27:23,720 --> 00:27:27,760
just look for size regressions

00:27:37,790 --> 00:27:47,400
yeah and if people find this useful and

00:27:44,030 --> 00:27:49,950
they can see value in this then

00:27:47,400 --> 00:27:52,640
eventually I won't be alone working on

00:27:49,950 --> 00:27:52,640
this and Pearl

00:28:02,700 --> 00:28:14,340
yeah it's it's straight busybox didn't

00:28:08,350 --> 00:28:14,340
modify it at all sorry

00:28:14,460 --> 00:28:26,250
115 200 and then then you need to press

00:28:21,820 --> 00:28:26,250
the reset button to reboot it

00:28:33,020 --> 00:28:39,760
do you got it so sorry I interpreted you

00:29:06,650 --> 00:29:11,780
so to answer your question about user

00:29:08,720 --> 00:29:16,040
space the only thing I did is to limit

00:29:11,780 --> 00:29:26,870
the stack size that will next allocates

00:29:16,040 --> 00:29:32,530
to user space processes because it's the

00:29:26,870 --> 00:29:32,530
I think it's you see Lipsy

00:29:37,800 --> 00:29:46,110
it is working so you have a shell you

00:29:41,460 --> 00:29:50,840
can do LS u-- UK one you can wonder room

00:29:46,110 --> 00:29:50,840
and just try it free

00:29:58,240 --> 00:30:04,580
one thing which is really funny is that

00:30:00,679 --> 00:30:06,440
the colonel will display some some sizes

00:30:04,580 --> 00:30:12,169
of every part of the colonel need boots

00:30:06,440 --> 00:30:16,900
and it rounds it the to the megabyte so

00:30:12,169 --> 00:30:16,900
some things are zero megabytes

00:30:24,150 --> 00:30:34,310
so he works yay

00:30:30,810 --> 00:30:34,310
any more questions

00:30:40,410 --> 00:30:43,910
I think we're done

00:30:45,560 --> 00:30:54,390
[Applause]

00:30:49,420 --> 00:30:54,390

YouTube URL: https://www.youtube.com/watch?v=mqkIMfYLiz4


