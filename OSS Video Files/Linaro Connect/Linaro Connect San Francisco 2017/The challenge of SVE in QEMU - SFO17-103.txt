Title: The challenge of SVE in QEMU - SFO17-103
Publication date: 2017-09-29
Playlist: Linaro Connect San Francisco 2017
Description: 
	Session ID: SFO17-103
Session Name: The challenge of SVE in QEMU - SFO17-103
Speaker: Alex Bennée
Track: Virtualization


★ Session Summary ★
ARM's Scalable Vector Extensions present an innovative way of scaling silicon performance without needing to constantly re-write your code. However for a system emulator like QEMU it presents a number of challenges. There are fairly routine problems like implementing the
necessary architecture pre-requisites of half-precision and complex numbers. There are more complex interactions where our recent work on multi-threaded execution interacts with the need to support SVE's memory model and atomicity requirements. Also making increasing use of SIMD instructions also hits one of QEMUs performance bottle-necks as the implementation of multiple-vector operations are several times slower than ""normal"" scalar integer instructions. As we also take instruction verification seriously we need to look at improving our testing tools that currently have naive assumptions about results of an individual instruction across various implementations. As you will see implementing SVE is more than just adding a few extra instructions.
---------------------------------------------------
★ Resources ★
Event Page: http://connect.linaro.org/resource/sfo17/sfo17-103/
Presentation: https://www.slideshare.net/linaroorg/the-challenge-of-sve-in-qemu-sfo17103
Video: 
 ---------------------------------------------------

★ Event Details ★
Linaro Connect San Francisco 2017 (SFO17)
25-29 September 2017
Hyatt Regency San Francisco Airport

---------------------------------------------------
Keyword: 
'http://www.linaro.org'
'http://connect.linaro.org'
---------------------------------------------------
Follow us on Social Media
https://www.facebook.com/LinaroOrg
https://twitter.com/linaroorg
https://www.youtube.com/user/linaroorg?sub_confirmation=1
https://www.linkedin.com/company/1026961
Captions: 
	00:00:00,120 --> 00:00:04,060
[Music]

00:00:08,910 --> 00:00:12,320
[Music]

00:00:14,780 --> 00:00:20,130
okay so this might be familiar to some

00:00:18,750 --> 00:00:23,910
in the room but let's just quickly

00:00:20,130 --> 00:00:27,270
review what sve years so the SV

00:00:23,910 --> 00:00:28,710
instruction set is classic instructions

00:00:27,270 --> 00:00:32,850
known as single instruction multiple

00:00:28,710 --> 00:00:34,380
data so these are instructions that

00:00:32,850 --> 00:00:36,780
include single operation

00:00:34,380 --> 00:00:38,989
which then is applied to multiple

00:00:36,780 --> 00:00:43,950
independent planes of a very large

00:00:38,989 --> 00:00:45,840
register so such sve builds on the

00:00:43,950 --> 00:00:48,269
technology but you've seen things like

00:00:45,840 --> 00:00:51,539
neons and advanced and a much wider

00:00:48,269 --> 00:00:55,859
vectors and do more operations at the

00:00:51,539 --> 00:00:57,359
time in fact the vector length of sve

00:00:55,859 --> 00:00:59,010
is dependent on the actual processor

00:00:57,359 --> 00:01:05,100
that you run on it

00:00:59,010 --> 00:01:08,370
the scaling parts sve like portable code

00:01:05,100 --> 00:01:10,050
that will run on any sba implementation

00:01:08,370 --> 00:01:14,180
regardless of the actual vector length

00:01:10,050 --> 00:01:17,550
that is implemented in the processor

00:01:14,180 --> 00:01:19,380
this means that your mobile system on a

00:01:17,550 --> 00:01:22,860
chip might implement the minimum vector

00:01:19,380 --> 00:01:25,229
length but if you run the same code on a

00:01:22,860 --> 00:01:27,630
high-performance computer with super

00:01:25,229 --> 00:01:28,740
wide vectors it would still run but

00:01:27,630 --> 00:01:30,600
you'll get the performance boost

00:01:28,740 --> 00:01:35,310
automatically they'll be able to do more

00:01:30,600 --> 00:01:37,590
operations at the time of course none of

00:01:35,310 --> 00:01:40,829
this is actually useful international

00:01:37,590 --> 00:01:42,689
code is vectorizable this is something

00:01:40,829 --> 00:01:44,850
that generally tends to be done by the

00:01:42,689 --> 00:01:47,369
compiler you have to be compiler

00:01:44,850 --> 00:01:52,560
although you might find some people

00:01:47,369 --> 00:01:54,810
write assembly by hat so let's look an

00:01:52,560 --> 00:01:58,020
example of what vectorize code looks

00:01:54,810 --> 00:01:59,969
like this is the classic c string copy

00:01:58,020 --> 00:02:02,850
I'm hoping everyone's reasonably

00:01:59,969 --> 00:02:04,619
familiar with what's going on here I've

00:02:02,850 --> 00:02:06,450
got two points is a destination source

00:02:04,619 --> 00:02:07,400
go through the source copying into the

00:02:06,450 --> 00:02:10,910
destination

00:02:07,400 --> 00:02:13,880
we hit our termination now everyone

00:02:10,910 --> 00:02:16,070
probably writes a bit of assembler does

00:02:13,880 --> 00:02:20,030
this naively by loading a part of the

00:02:16,070 --> 00:02:25,070
time into a register checking let's look

00:02:20,030 --> 00:02:27,170
at how this code looks in SBA so this is

00:02:25,070 --> 00:02:28,640
an example of a vectorized screen copy

00:02:27,170 --> 00:02:31,040
and don't worry about the details I'm

00:02:28,640 --> 00:02:33,220
going to go through it in detail so you

00:02:31,040 --> 00:02:37,400
don't need to take it all in the mouth

00:02:33,220 --> 00:02:40,010
let's go through it a chunk of time so

00:02:37,400 --> 00:02:41,570
the first thing to understand about sve

00:02:40,010 --> 00:02:44,120
is the use of these things called

00:02:41,570 --> 00:02:47,120
predicate registers a predicate register

00:02:44,120 --> 00:02:49,670
is a big field which controls which

00:02:47,120 --> 00:02:53,180
elements in the vector are going to be

00:02:49,670 --> 00:02:58,160
operated on by the instructor by the SPD

00:02:53,180 --> 00:03:00,830
instruction so yeah we're setting the PT

00:02:58,160 --> 00:03:02,810
register to register all true so what

00:03:00,830 --> 00:03:04,940
this means is any operations where we

00:03:02,810 --> 00:03:07,610
use the PT predicate we want to use

00:03:04,940 --> 00:03:15,470
every available Lane however many that

00:03:07,610 --> 00:03:17,209
might be of the net register so the

00:03:15,470 --> 00:03:19,300
first step of our screen copy is we need

00:03:17,209 --> 00:03:23,360
to load the terms of the source script

00:03:19,300 --> 00:03:25,670
and to one of net races as p2

00:03:23,360 --> 00:03:29,209
as we said before is not true we will

00:03:25,670 --> 00:03:33,620
load as many values as we can into the

00:03:29,209 --> 00:03:36,230
vector registers at 0 on default

00:03:33,620 --> 00:03:39,890
implementations the minimum size SPD

00:03:36,230 --> 00:03:42,830
veterus 16 bytes but it could be we're

00:03:39,890 --> 00:03:51,040
running with a 2048-bit vector register

00:03:42,830 --> 00:03:53,420
little copy 256 bytes at one time now

00:03:51,040 --> 00:03:55,310
reading all this data at once does

00:03:53,420 --> 00:03:57,890
actually present a couple of interesting

00:03:55,310 --> 00:04:00,830
problems one of which if your string

00:03:57,890 --> 00:04:02,180
happens to be at the end of the page you

00:04:00,830 --> 00:04:03,330
could be in the situation although your

00:04:02,180 --> 00:04:05,250
string days before

00:04:03,330 --> 00:04:09,570
the page you just read the whole bunch

00:04:05,250 --> 00:04:11,100
of extra data and possibly faulted SPD

00:04:09,570 --> 00:04:13,380
introduces this mechanism called the

00:04:11,100 --> 00:04:16,260
personal register that allows you to

00:04:13,380 --> 00:04:20,280
read the data into the vector register

00:04:16,260 --> 00:04:22,940
and know how many of those loads so

00:04:20,280 --> 00:04:24,510
that's all that this this RDF are

00:04:22,940 --> 00:04:26,880
structured this here

00:04:24,510 --> 00:04:30,360
it sets a new predicate register to be

00:04:26,880 --> 00:04:35,730
the total number of valid bytes which is

00:04:30,360 --> 00:04:37,470
read so the next thing we need to do is

00:04:35,730 --> 00:04:39,030
we need to protect our termination

00:04:37,470 --> 00:04:44,430
conditions so we need to test that the

00:04:39,030 --> 00:04:46,350
null byte so compare instruction much

00:04:44,430 --> 00:04:49,080
like you would do with a normal scaler

00:04:46,350 --> 00:04:51,570
especially comparing to the immediate

00:04:49,080 --> 00:04:53,940
value of zero but we're going to compare

00:04:51,570 --> 00:04:57,120
it across all the lanes of the vector

00:04:53,940 --> 00:04:58,620
register and in this case we're going to

00:04:57,120 --> 00:05:00,690
compare it for all the values that we've

00:04:58,620 --> 00:05:02,910
loaded in and it'll set another

00:05:00,690 --> 00:05:05,880
predicate register to show all the lanes

00:05:02,910 --> 00:05:07,560
which has been set to zero you'll see

00:05:05,880 --> 00:05:10,590
why this is important at the moment but

00:05:07,560 --> 00:05:13,340
if any of the vectors have matched a

00:05:10,590 --> 00:05:16,080
condition we'll set the appropriate

00:05:13,340 --> 00:05:17,850
flags and then we'll exit this loop here

00:05:16,080 --> 00:05:20,700
so we've tested for our termination

00:05:17,850 --> 00:05:26,100
condition and if we've reached it'll

00:05:20,700 --> 00:05:26,850
just fall through of course we're not

00:05:26,100 --> 00:05:28,650
done yet

00:05:26,850 --> 00:05:32,160
we still need to store the result back

00:05:28,650 --> 00:05:35,370
and into memory so there's two parts of

00:05:32,160 --> 00:05:38,340
this this is natural store we just store

00:05:35,370 --> 00:05:39,990
the entire contents to register to X

00:05:38,340 --> 00:05:41,550
here but we don't actually want to store

00:05:39,990 --> 00:05:44,460
everything we want to store everything

00:05:41,550 --> 00:05:48,480
up until the first zero that we detected

00:05:44,460 --> 00:05:51,150
as you don't write anything and that's

00:05:48,480 --> 00:05:54,000
what this break after instructions doing

00:05:51,150 --> 00:05:56,370
is all it's saying for the first first

00:05:54,000 --> 00:05:58,740
place that we saw a zero set and

00:05:56,370 --> 00:06:02,220
predicate register to include all those

00:05:58,740 --> 00:06:02,900
things but nothing so now we safely

00:06:02,220 --> 00:06:07,669
store

00:06:02,900 --> 00:06:10,970
remaining but finally there's only one

00:06:07,669 --> 00:06:11,330
thing we need to do before we go around

00:06:10,970 --> 00:06:13,490
again

00:06:11,330 --> 00:06:15,139
we need to increment our index rate so

00:06:13,490 --> 00:06:17,930
we set up index register at the top to

00:06:15,139 --> 00:06:20,259
zero and we're using it to index into

00:06:17,930 --> 00:06:24,110
these source and destination scripts

00:06:20,259 --> 00:06:26,270
again the impe instruction looks at the

00:06:24,110 --> 00:06:27,860
predicate register and increments it by

00:06:26,270 --> 00:06:30,680
the number of elements that are being

00:06:27,860 --> 00:06:33,470
selected so this piece of code have

00:06:30,680 --> 00:06:36,289
absolutely no knowledge of how big the

00:06:33,470 --> 00:06:39,169
vector register is it will run on any

00:06:36,289 --> 00:06:42,770
implementation and most likely copy the

00:06:39,169 --> 00:06:46,940
string as much as it can in each

00:06:42,770 --> 00:06:48,620
iteration so on a small small processor

00:06:46,940 --> 00:06:53,900
of doing lots of iterations and the big

00:06:48,620 --> 00:06:56,090
one it might just go through a box okay

00:06:53,900 --> 00:06:57,050
so why do we want to implement SB

00:06:56,090 --> 00:07:01,130
increment

00:06:57,050 --> 00:07:03,169
well number of reasons for starters we

00:07:01,130 --> 00:07:05,900
want to give developers early access to

00:07:03,169 --> 00:07:07,849
sba it's going to be some time before

00:07:05,900 --> 00:07:11,150
their silicon available we have to be

00:07:07,849 --> 00:07:13,099
enabled but the sooner people can start

00:07:11,150 --> 00:07:16,460
writing software and testing it the

00:07:13,099 --> 00:07:18,639
better Chrome users did open source

00:07:16,460 --> 00:07:21,139
solution so if you were flustered up but

00:07:18,639 --> 00:07:22,639
generally people tend to prefer running

00:07:21,139 --> 00:07:26,389
a fully open stack so there are benefits

00:07:22,639 --> 00:07:28,699
to having any for that also for

00:07:26,389 --> 00:07:30,229
academics and research institutions they

00:07:28,699 --> 00:07:32,659
might not have access to the proprietary

00:07:30,229 --> 00:07:34,909
models of the restrictions on the page

00:07:32,659 --> 00:07:39,650
might prohibit them from easily

00:07:34,909 --> 00:07:42,710
disseminating there were another reason

00:07:39,650 --> 00:07:44,520
queeny's faster than the model certainly

00:07:42,710 --> 00:07:46,349
if we're using Linux user anyway

00:07:44,520 --> 00:07:49,259
because you don't have the overhead of

00:07:46,349 --> 00:07:51,000
emulating the full system with an MMU

00:07:49,259 --> 00:07:53,849
and everything you can actually run

00:07:51,000 --> 00:07:55,919
quite quickly but even if you have to do

00:07:53,849 --> 00:07:59,340
a full system emulation and chrome you

00:07:55,919 --> 00:08:01,620
also has a multi-threaded ttg now so it

00:07:59,340 --> 00:08:04,110
can use multiple cores on a processor

00:08:01,620 --> 00:08:07,530
for the emulation again faster than the

00:08:04,110 --> 00:08:09,720
model and everyone since we used it for

00:08:07,530 --> 00:08:11,280
credit these are interesting

00:08:09,720 --> 00:08:24,030
instructions to implement and it pushes

00:08:11,280 --> 00:08:43,349
us to keep improving the generation I

00:08:24,030 --> 00:08:44,730
mean when you implement the Maxima so so

00:08:43,349 --> 00:08:47,510
the timing code generator is a

00:08:44,730 --> 00:08:50,370
just-in-time recompilation engine

00:08:47,510 --> 00:08:52,350
basically it operates uh basically

00:08:50,370 --> 00:08:55,589
operates on the basic block instructions

00:08:52,350 --> 00:08:57,390
at the time a big composes them into TC

00:08:55,589 --> 00:08:59,459
tops which is quite meters internal

00:08:57,390 --> 00:09:03,420
representation much like a compiler

00:08:59,459 --> 00:09:08,730
once it's run through the basic block it

00:09:03,420 --> 00:09:12,540
will do a basic optimization base so we

00:09:08,730 --> 00:09:15,420
do things like remove dead code sort of

00:09:12,540 --> 00:09:18,149
thing and then we go through the

00:09:15,420 --> 00:09:19,350
remaining TCG ups and for each TC to you

00:09:18,149 --> 00:09:21,300
up we have a decision to make

00:09:19,350 --> 00:09:23,730
we either generate some post

00:09:21,300 --> 00:09:27,870
instructions or we call a helper

00:09:23,730 --> 00:09:29,970
function so for most integer operations

00:09:27,870 --> 00:09:31,649
and logic operations flow control that

00:09:29,970 --> 00:09:35,459
sort of thing will generate post

00:09:31,649 --> 00:09:38,820
instructions we call helper functions

00:09:35,459 --> 00:09:40,700
for anything that we consider complex so

00:09:38,820 --> 00:09:43,460
examples of complex instruction

00:09:40,700 --> 00:09:45,260
include system instructions that access

00:09:43,460 --> 00:09:48,950
system registers or if you for example

00:09:45,260 --> 00:09:50,540
of manipulating the entries we also tend

00:09:48,950 --> 00:09:53,660
to general use helper functions for

00:09:50,540 --> 00:09:56,180
exception generation but importantly for

00:09:53,660 --> 00:09:58,280
our case all floating point operations

00:09:56,180 --> 00:10:02,240
tend to be implemented in the helper

00:09:58,280 --> 00:10:07,130
functions that's the best a bit more

00:10:02,240 --> 00:10:08,600
about that later so let's go through

00:10:07,130 --> 00:10:09,310
some of the challenges we need to

00:10:08,600 --> 00:10:12,950
address

00:10:09,310 --> 00:10:15,560
there are progressive features there's

00:10:12,950 --> 00:10:17,030
the use of a floating point library

00:10:15,560 --> 00:10:20,450
called software which we use quite

00:10:17,030 --> 00:10:22,580
heavily I mean the efficiency of our

00:10:20,450 --> 00:10:24,110
code generation and then finally I'll

00:10:22,580 --> 00:10:30,890
talk about some the Diagnostics and

00:10:24,110 --> 00:10:33,170
havoc approach testing so firstly there

00:10:30,890 --> 00:10:34,850
are a number of purposes although SV is

00:10:33,170 --> 00:10:39,680
an optional extension it doesn't mandate

00:10:34,850 --> 00:10:42,710
a base requirement of RB 8.2 so

00:10:39,680 --> 00:10:44,240
especially there's a whole chunk of half

00:10:42,710 --> 00:10:46,730
precision floating point which was added

00:10:44,240 --> 00:10:49,070
in 8.2 there were also a couple of

00:10:46,730 --> 00:10:53,060
additional advanced Cynthia instructions

00:10:49,070 --> 00:10:55,400
added in the 8.1 spec finally and also

00:10:53,060 --> 00:10:59,450
mandates we need to support the complex

00:10:55,400 --> 00:11:01,100
numbers of three so as to be properly

00:10:59,450 --> 00:11:06,770
inspected by and we need to make these

00:11:01,100 --> 00:11:10,850
instructions first now let's have a look

00:11:06,770 --> 00:11:14,870
at our use of software so first question

00:11:10,850 --> 00:11:17,120
you might ask is why indeed pretty much

00:11:14,870 --> 00:11:19,220
all of the back end supports back when

00:11:17,120 --> 00:11:22,220
you already have extensive floating

00:11:19,220 --> 00:11:25,930
point support inaudible but it turns out

00:11:22,220 --> 00:11:28,310
it's actually very hard to map the

00:11:25,930 --> 00:11:30,350
floating point behavior 1 instruction

00:11:28,310 --> 00:11:32,590
set to another even if the hardware of

00:11:30,350 --> 00:11:32,590
both

00:11:32,700 --> 00:11:36,420
you can find and that's because there's

00:11:34,170 --> 00:11:38,910
enough gaps and interpretation in the

00:11:36,420 --> 00:11:40,410
spec around things like how you feel

00:11:38,910 --> 00:11:43,920
with rounding and how you deal with

00:11:40,410 --> 00:11:47,280
exceptions that you run into problems so

00:11:43,920 --> 00:11:49,080
a long time ago when you decided to do

00:11:47,280 --> 00:11:52,650
or displacement point with the software

00:11:49,080 --> 00:11:56,250
libraries current credit code is based

00:11:52,650 --> 00:11:58,170
on softly to a yes

00:11:56,250 --> 00:11:59,700
suck it to a do to a licensing

00:11:58,170 --> 00:12:01,190
compatibility that was introduced later

00:11:59,700 --> 00:12:03,630
in the series

00:12:01,190 --> 00:12:05,550
but also premiums make quite a lot of

00:12:03,630 --> 00:12:09,390
heavy modifications to that library for

00:12:05,550 --> 00:12:11,280
its own purposes unfortunately because

00:12:09,390 --> 00:12:13,170
this light was quite old we're missing

00:12:11,280 --> 00:12:15,690
out on some of the later features so

00:12:13,170 --> 00:12:18,180
there is no support for our precision in

00:12:15,690 --> 00:12:20,160
the library as it stands and some of the

00:12:18,180 --> 00:12:24,030
later I took the lead features that

00:12:20,160 --> 00:12:25,830
extended browning modes and also the

00:12:24,030 --> 00:12:29,190
library is no longer being developed at

00:12:25,830 --> 00:12:32,760
this release so we need to options of

00:12:29,190 --> 00:12:37,160
how we're going to go forward so on is

00:12:32,760 --> 00:12:37,160
to migrate to stop play the three series

00:12:38,450 --> 00:12:42,390
development and has a whole bunch of

00:12:40,920 --> 00:12:44,900
additional features including math

00:12:42,390 --> 00:12:44,900
precision

00:12:44,930 --> 00:12:50,300
features unfortunately it's a complete

00:12:48,390 --> 00:12:59,250
rewrite so it's not a simple case

00:12:50,300 --> 00:13:00,690
playing we could look at migrates into

00:12:59,250 --> 00:13:02,910
another library that's a couple about

00:13:00,690 --> 00:13:05,190
but one for example I looked at is the

00:13:02,910 --> 00:13:06,920
Canadian multi precision grunting point

00:13:05,190 --> 00:13:08,580
with cramming library

00:13:06,920 --> 00:13:10,020
unfortunately this seems to be more

00:13:08,580 --> 00:13:12,000
designed for people doing the American

00:13:10,020 --> 00:13:14,640
analysis so it's not really set up for

00:13:12,000 --> 00:13:17,520
sort of abuse we're going to use for

00:13:14,640 --> 00:13:20,040
instruction innovation so that leaves us

00:13:17,520 --> 00:13:22,080
with the last option back port or

00:13:20,040 --> 00:13:25,440
reinvent features that we need on our

00:13:22,080 --> 00:13:27,059
existing to a code base and that looks

00:13:25,440 --> 00:13:29,519
like the option we're going to go

00:13:27,059 --> 00:13:33,209
at the moment unfortunately although

00:13:29,519 --> 00:13:37,019
softly the software authors are open to

00:13:33,209 --> 00:13:38,369
us providing packages and taking changes

00:13:37,019 --> 00:13:40,709
from the community they don't really set

00:13:38,369 --> 00:13:44,549
up for it one guy does the principles

00:13:40,709 --> 00:13:52,559
about that and you know it's not really

00:13:44,549 --> 00:13:56,459
suitable for us to base our music

00:13:52,559 --> 00:13:59,009
cogeneration and so as we've just seen

00:13:56,459 --> 00:14:02,699
all the floating-point operations are

00:13:59,009 --> 00:14:10,229
done with helpers because we need to use

00:14:02,699 --> 00:14:11,549
software to do calculations options just

00:14:10,229 --> 00:14:13,679
stuff to be done in generated code

00:14:11,549 --> 00:14:15,599
generally what we do is we break down

00:14:13,679 --> 00:14:18,119
the vector into its multiple elements

00:14:15,599 --> 00:14:22,199
and call a helper to process each

00:14:18,119 --> 00:14:23,549
element in turn there is a cost to this

00:14:22,199 --> 00:14:25,319
however because every time you call a

00:14:23,549 --> 00:14:27,719
help you still you need to create a C

00:14:25,319 --> 00:14:32,159
stack frame jump into the seat return

00:14:27,719 --> 00:14:34,349
from the C code and this is one of the

00:14:32,159 --> 00:14:35,189
reasons why Graham U is quite slow when

00:14:34,349 --> 00:14:37,289
you're doing anything that's

00:14:35,189 --> 00:14:38,429
particularly floating-point heavy you'll

00:14:37,289 --> 00:14:41,099
notice there is difference between

00:14:38,429 --> 00:14:47,459
booting a kernel and say for example

00:14:41,099 --> 00:14:49,979
running ffmpeg the WebRTC genie is

00:14:47,459 --> 00:14:52,529
currently limited to just it just

00:14:49,979 --> 00:14:58,379
understands the ideas of the 32-bit and

00:14:52,529 --> 00:15:01,039
64-bit operations and registers we've

00:14:58,379 --> 00:15:04,559
had previous attempts at expanding

00:15:01,039 --> 00:15:06,059
supporting Cindy instructions in the TTT

00:15:04,559 --> 00:15:08,489
but it tended to get quite messy because

00:15:06,059 --> 00:15:11,609
you need to add the set of operations

00:15:08,489 --> 00:15:14,809
for every single size of simply register

00:15:11,609 --> 00:15:17,969
that you need to deal with so the latest

00:15:14,809 --> 00:15:19,799
approach with having the latest attempts

00:15:17,969 --> 00:15:22,229
at this is we've actually come up with a

00:15:19,799 --> 00:15:26,699
way of having a size of the Gnostic way

00:15:22,229 --> 00:15:29,760
of representing vectors so we treat the

00:15:26,699 --> 00:15:32,970
vector the arbitrary size vector

00:15:29,760 --> 00:15:36,480
cogeneration point of view and then pull

00:15:32,970 --> 00:15:38,399
the help at once so you've got four

00:15:36,480 --> 00:15:41,149
lanes or 32 eventually you've got 16

00:15:38,399 --> 00:15:44,250
lanes and 32 bits will be the same code

00:15:41,149 --> 00:15:48,269
and without having to complicate the TCG

00:15:44,250 --> 00:15:50,550
more this doesn't leave us with scope

00:15:48,269 --> 00:15:55,860
also for generating code for some of the

00:15:50,550 --> 00:15:59,010
center operations as love let's have a

00:15:55,860 --> 00:16:01,290
quick talk about Diagnostics so although

00:15:59,010 --> 00:16:03,360
most develop that most users of chrome

00:16:01,290 --> 00:16:05,490
you don't enter too much into details

00:16:03,360 --> 00:16:06,959
about pennies doing it is usual sort of

00:16:05,490 --> 00:16:09,449
more advanced users and certainty for

00:16:06,959 --> 00:16:11,760
developers to be able to see both the

00:16:09,449 --> 00:16:14,880
guest code that we're running and the

00:16:11,760 --> 00:16:16,589
generated code that we've generated all

00:16:14,880 --> 00:16:18,690
the guest side things that are very good

00:16:16,589 --> 00:16:20,699
is a likelihood little vixen which I

00:16:18,690 --> 00:16:22,190
came from Harlan there's now a Leonora

00:16:20,699 --> 00:16:25,589
poster project

00:16:22,190 --> 00:16:27,779
but on the host disassembler side it's

00:16:25,589 --> 00:16:29,970
not so good the hostess assembler is

00:16:27,779 --> 00:16:32,550
currently based on the old fourth

00:16:29,970 --> 00:16:35,940
version of bidding tales from before

00:16:32,550 --> 00:16:37,589
they make that GPL v3 license change and

00:16:35,940 --> 00:16:40,079
as a result it doesn't recognize the

00:16:37,589 --> 00:16:42,569
whole serve the modern Cindy

00:16:40,079 --> 00:16:44,100
instructions that you expected so we're

00:16:42,569 --> 00:16:46,310
currently looking at the capstone engine

00:16:44,100 --> 00:16:48,180
which is a liberally licensed bsd

00:16:46,310 --> 00:16:50,480
library for their doing and this

00:16:48,180 --> 00:16:50,480
assignment

00:16:52,600 --> 00:16:58,510
I'd like to take a little bit of time to

00:16:54,700 --> 00:17:00,580
talk about testing so when we did the

00:16:58,510 --> 00:17:01,240
original jambe egg work we used a tool

00:17:00,580 --> 00:17:02,920
called Brizzy

00:17:01,240 --> 00:17:09,160
which stands for random instructions in

00:17:02,920 --> 00:17:10,930
userspace it's very worst by generating

00:17:09,160 --> 00:17:13,449
random instruction patterns and he

00:17:10,930 --> 00:17:15,790
record a trace on a reference piece of

00:17:13,449 --> 00:17:17,530
hardware look at what changes have been

00:17:15,790 --> 00:17:20,410
made to the registers and then you can

00:17:17,530 --> 00:17:22,570
compare that with your run and it was

00:17:20,410 --> 00:17:24,430
very helpful during our rd8 work it got

00:17:22,570 --> 00:17:25,660
an awful lot of corner cases which you

00:17:24,430 --> 00:17:30,460
wouldn't have necessarily come across

00:17:25,660 --> 00:17:31,930
just by manually testing to do that

00:17:30,460 --> 00:17:33,670
however we are going to make some needs

00:17:31,930 --> 00:17:36,640
make some changes to queries Linux user

00:17:33,670 --> 00:17:38,320
support because sve signal frames can be

00:17:36,640 --> 00:17:41,620
so large they're not generated

00:17:38,320 --> 00:17:44,080
automatically for signals there is now

00:17:41,620 --> 00:18:05,470
an optional extension to the signal

00:17:44,080 --> 00:18:09,970
frame support so the binary is a Linux

00:18:05,470 --> 00:18:12,670
user binary the data which is a

00:18:09,970 --> 00:18:14,910
instruction stream and then it runs each

00:18:12,670 --> 00:18:17,650
instruction and then after instruction

00:18:14,910 --> 00:18:20,080
saves the states in register file so you

00:18:17,650 --> 00:18:27,070
can compare with one run under query

00:18:20,080 --> 00:18:30,220
against a run and there is a if you look

00:18:27,070 --> 00:18:33,780
on the KTM forum website I did a talk on

00:18:30,220 --> 00:18:33,780
regime couple years ago so he

00:18:36,970 --> 00:18:43,610
so just summarize our status currently

00:18:41,090 --> 00:18:45,530
in progress with supporting or

00:18:43,610 --> 00:18:47,510
implementing floating-point precision

00:18:45,530 --> 00:18:50,750
floating point for our soft light

00:18:47,510 --> 00:18:53,780
library the variable main factors and

00:18:50,750 --> 00:18:56,870
CCD operations to speed things up to

00:18:53,780 --> 00:19:00,080
version 3 now as part of this reports

00:18:56,870 --> 00:19:02,510
have been reviewing doesn't directly

00:19:00,080 --> 00:19:05,060
affect us because because introducing a

00:19:02,510 --> 00:19:07,580
new API for accessing the SVD registers

00:19:05,060 --> 00:19:09,940
we thought we better chicken out a

00:19:07,580 --> 00:19:09,940
pencil

00:19:13,910 --> 00:19:18,980
we're currently going on on the 8.1

00:19:16,820 --> 00:19:26,390
advanced in the instructions and again

00:19:18,980 --> 00:19:28,930
to September mentions so that leaves us

00:19:26,390 --> 00:19:30,830
a fairly happy to do this to go through

00:19:28,930 --> 00:19:32,990
obviously we'd like to get rid of

00:19:30,830 --> 00:19:34,820
support very quickly because you need

00:19:32,990 --> 00:19:38,390
the testing and progressing the

00:19:34,820 --> 00:19:39,710
instructions and we've got to actually

00:19:38,390 --> 00:19:43,520
implement all the our precision floating

00:19:39,710 --> 00:19:45,520
point operations 48.2 complex numbers

00:19:43,520 --> 00:19:49,300
and then we've broken down

00:19:45,520 --> 00:19:52,760
yes be working to a number of separate

00:19:49,300 --> 00:19:55,790
silos of having predicates prussians and

00:19:52,760 --> 00:19:57,560
memories also just minor changes but the

00:19:55,790 --> 00:19:59,930
way sve hammers memory because you can

00:19:57,560 --> 00:20:03,890
deal with these faults occur halfway

00:19:59,930 --> 00:20:05,120
through a wide load then the local

00:20:03,890 --> 00:20:06,860
stores and then the calculations

00:20:05,120 --> 00:20:09,170
hopefully most of the calculation

00:20:06,860 --> 00:20:10,300
instructions will be able to reuse the

00:20:09,170 --> 00:20:11,920
existing

00:20:10,300 --> 00:20:15,520
helpless under our noon for the

00:20:11,920 --> 00:20:17,290
variable-length promo and then finally

00:20:15,520 --> 00:20:19,570
I've already mentioned the Linux user

00:20:17,290 --> 00:20:20,920
support for the SV step through the

00:20:19,570 --> 00:20:23,170
system emulation there are a few

00:20:20,920 --> 00:20:27,340
additional system registers that allow

00:20:23,170 --> 00:20:59,020
you to linear access to the vector

00:20:27,340 --> 00:21:02,500
registers from user space of some of the

00:20:59,020 --> 00:21:04,240
outsiders I should have mentioned our

00:21:02,500 --> 00:21:05,730
current usage of clips and there's a

00:21:04,240 --> 00:21:08,440
little out of date so we need to update

00:21:05,730 --> 00:21:10,180
hoping that the pixel would be for the

00:21:08,440 --> 00:21:12,490
Upstate the latest instructions but

00:21:10,180 --> 00:21:14,020
there are some in argument with Breen

00:21:12,490 --> 00:21:20,370
capstone in why don't we just use

00:21:14,020 --> 00:21:20,370
capstone for everything anymore

00:21:32,200 --> 00:21:37,370
there shouldn't be any major changes

00:21:35,060 --> 00:21:40,790
there's the representation of the SBE

00:21:37,370 --> 00:21:43,430
registers the GDP already has a way of

00:21:40,790 --> 00:21:59,960
declaring the so maybe a if you can't

00:21:43,430 --> 00:22:03,020
declare a super-wide so that's the most

00:21:59,960 --> 00:22:19,190
common way to run query but it's got

00:22:03,020 --> 00:22:21,470
cogeneration backends but most people

00:22:19,190 --> 00:22:25,930
tend to run it with the next 36 packets

00:22:21,470 --> 00:22:25,930
last but by far the most tested patent

00:22:26,170 --> 00:22:32,890
is I know there's work going on

00:22:29,320 --> 00:22:37,700
extending health various attributes

00:22:32,890 --> 00:22:41,660
around the SPD requirements for they

00:22:37,700 --> 00:22:43,670
been pullin this wrapper so I could you

00:22:41,660 --> 00:22:46,520
know we don't manam system it doesn't

00:22:43,670 --> 00:22:47,960
support SBE and just from user in that

00:22:46,520 --> 00:22:51,160
case

00:22:47,960 --> 00:22:51,160
[Music]

00:22:52,799 --> 00:23:02,679
rapper distinguish yeah because he could

00:23:00,580 --> 00:23:04,629
they're having allegedly they're editing

00:23:02,679 --> 00:23:30,129
on flag there's going to be an extension

00:23:04,629 --> 00:23:34,119
of the production but it might be fun

00:23:30,129 --> 00:23:40,600
too because a lot of people want to run

00:23:34,119 --> 00:23:43,499
on arm servers don't also have their own

00:23:40,600 --> 00:24:01,679
solution that attracts access to

00:23:43,499 --> 00:24:01,679
instructions which is what you want

00:24:10,890 --> 00:24:20,309
No yeah okay expert debate on how are

00:24:16,030 --> 00:24:23,559
you gonna test this because you said the

00:24:20,309 --> 00:24:25,690
execution thing was well we run this on

00:24:23,559 --> 00:24:27,549
harbor and dump the registers and we run

00:24:25,690 --> 00:24:32,950
this communion pepper answers or well

00:24:27,549 --> 00:24:35,650
you have no hardware so rely on open

00:24:32,950 --> 00:24:38,740
models or closed models and we torsion

00:24:35,650 --> 00:24:40,150
of the models we have at the moment our

00:24:38,740 --> 00:24:44,500
reference platform will be the model

00:24:40,150 --> 00:25:15,820
decidedly the arms nation so yeah you're

00:24:44,500 --> 00:25:17,860
right okay so certainly from the NARS

00:25:15,820 --> 00:25:21,610
point of view we have some tests in lab

00:25:17,860 --> 00:25:24,309
check the instruction emulation we've it

00:25:21,610 --> 00:25:28,540
hasn't progressed but none of this is

00:25:24,309 --> 00:25:32,830
built into Cremonese in the system it's

00:25:28,540 --> 00:25:35,340
been a long-running pain point that

00:25:32,830 --> 00:25:38,740
we've known about we got some plans to

00:25:35,340 --> 00:25:40,300
use the cross compiling support

00:25:38,740 --> 00:25:43,660
it's the build system to actually build

00:25:40,300 --> 00:25:47,040
the texts for the foreign architecture

00:25:43,660 --> 00:25:47,040
so we can then run them but that's not

00:25:48,720 --> 00:25:52,410
okay any more question

00:25:54,660 --> 00:25:58,130
well thank you very much

00:26:01,170 --> 00:26:06,130

YouTube URL: https://www.youtube.com/watch?v=fzxMD7uFfBY


