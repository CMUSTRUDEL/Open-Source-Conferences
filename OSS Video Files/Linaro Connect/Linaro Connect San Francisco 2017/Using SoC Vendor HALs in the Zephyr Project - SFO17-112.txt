Title: Using SoC Vendor HALs in the Zephyr Project - SFO17-112
Publication date: 2017-09-29
Playlist: Linaro Connect San Francisco 2017
Description: 
	Session ID: SFO17-112
Session Name: Using SoC Vendor HALs in the Zephyr Project - SFO17-112
Speaker: Maureen Helm
Track: LITE


★ Session Summary ★
The Zephyr OS is a small, scalable RTOS that supports a wide variety of SoCs, many of which have existing HALs provided by the SoC vendors, especially in the ARM Cortex-M world. These HALs provide peripheral register definitions and in many cases, include bare metal peripheral drivers. Rather than reinventing the wheel, the Zephyr Project decided to proactively reuse these vendor HALs whenever possible. This session will cover how and why the Zephyr Project uses SoC vendor HALs, what are the common problems, and how to address them.
---------------------------------------------------
★ Resources ★
Event Page: http://connect.linaro.org/resource/sfo17/sfo17-112/
Presentation: 
Video: 
 ---------------------------------------------------

★ Event Details ★
Linaro Connect San Francisco 2017 (SFO17)
25-29 September 2017
Hyatt Regency San Francisco Airport

---------------------------------------------------
Keyword: 
'http://www.linaro.org'
'http://connect.linaro.org'
---------------------------------------------------
Follow us on Social Media
https://www.facebook.com/LinaroOrg
https://twitter.com/linaroorg
https://www.youtube.com/user/linaroorg?sub_confirmation=1
https://www.linkedin.com/company/1026961
Captions: 
	00:00:00,120 --> 00:00:04,060
[Music]

00:00:08,910 --> 00:00:12,320
[Music]

00:00:13,820 --> 00:00:21,590
types of projects and so leveraging

00:00:17,690 --> 00:00:23,810
these howls elsewhere you know creates a

00:00:21,590 --> 00:00:26,900
greater maturity right they may have

00:00:23,810 --> 00:00:28,450
been exercised in different contexts and

00:00:26,900 --> 00:00:31,189
so we're not starting over from scratch

00:00:28,450 --> 00:00:32,300
and finally some of these you know are

00:00:31,189 --> 00:00:34,489
tosses excuse me

00:00:32,300 --> 00:00:36,140
Thunder howls at least from inexp you

00:00:34,489 --> 00:00:37,850
know actually go through QA testing

00:00:36,140 --> 00:00:40,790
before release them so we have some

00:00:37,850 --> 00:00:43,190
known sense of their quality before they

00:00:40,790 --> 00:00:46,850
actually go external and so the ultimate

00:00:43,190 --> 00:00:49,250
goal here is to simplify the process of

00:00:46,850 --> 00:00:50,750
adding new associative zeffer and adding

00:00:49,250 --> 00:00:55,760
new drivers to Zephyr that support those

00:00:50,750 --> 00:00:57,440
SOC s so naturally there are some

00:00:55,760 --> 00:00:59,480
trade-offs you know we'd be kidding

00:00:57,440 --> 00:01:01,100
ourselves if if we said you know

00:00:59,480 --> 00:01:03,320
everything would be perfect by using

00:01:01,100 --> 00:01:06,710
these these house so you know what what

00:01:03,320 --> 00:01:08,540
what are some of these trade-offs so

00:01:06,710 --> 00:01:10,070
previous slide I said you know the code

00:01:08,540 --> 00:01:11,840
is maintained elsewhere and there are

00:01:10,070 --> 00:01:14,990
some benefits to that but there also

00:01:11,840 --> 00:01:16,850
some trade-offs to that I think the most

00:01:14,990 --> 00:01:19,460
obvious one is you know if we find an

00:01:16,850 --> 00:01:23,409
issue if we find a bug it's a bit more

00:01:19,460 --> 00:01:26,270
difficult to upstream and fix that bug

00:01:23,409 --> 00:01:28,880
like I said generally the licenses are

00:01:26,270 --> 00:01:33,190
compatible with suffer but not always we

00:01:28,880 --> 00:01:35,570
have seen cases where a vendor how was

00:01:33,190 --> 00:01:37,850
it had a license that was new to Zephyr

00:01:35,570 --> 00:01:40,940
so we've become accustomed to use Apache

00:01:37,850 --> 00:01:43,250
we've become accustomed to use the BSD

00:01:40,940 --> 00:01:45,770
three clause but what happens when

00:01:43,250 --> 00:01:47,840
another license type comes in we had one

00:01:45,770 --> 00:01:50,000
I think that was a Z lib or some other

00:01:47,840 --> 00:01:52,100
type of license so we had to to figure

00:01:50,000 --> 00:01:53,360
out how are we gonna you know how could

00:01:52,100 --> 00:01:55,490
we make sure that that license was

00:01:53,360 --> 00:01:56,810
compatible and how could you know make

00:01:55,490 --> 00:01:59,360
sure that you know we didn't encounter

00:01:56,810 --> 00:02:03,890
any kind of IP problems by incorporating

00:01:59,360 --> 00:02:04,670
that into the tree and likewise you know

00:02:03,890 --> 00:02:07,369
when the code is used elsewhere

00:02:04,670 --> 00:02:09,379
sometimes those api's are a bit more

00:02:07,369 --> 00:02:11,390
tuned to one of those other ecosystems

00:02:09,379 --> 00:02:13,310
might be so they might not always be

00:02:11,390 --> 00:02:15,560
compatible we might have some issues

00:02:13,310 --> 00:02:18,500
where it just it's it doesn't quite fit

00:02:15,560 --> 00:02:21,260
together it could also be that there are

00:02:18,500 --> 00:02:23,510
some features that we need in terms of

00:02:21,260 --> 00:02:25,189
what the Zephyr interface is require but

00:02:23,510 --> 00:02:26,810
maybe aren't implemented at that lower

00:02:25,189 --> 00:02:28,700
level health so you know

00:02:26,810 --> 00:02:34,640
to look at those on a case-by-case basis

00:02:28,700 --> 00:02:36,830
and do what makes sense we already have

00:02:34,640 --> 00:02:39,080
quite a few different house already in

00:02:36,830 --> 00:02:42,830
use in the tree and XP is certainly not

00:02:39,080 --> 00:02:45,680
the only one this is a list of

00:02:42,830 --> 00:02:47,420
everything we're using today starting up

00:02:45,680 --> 00:02:50,030
I've got these in alphabetical order so

00:02:47,420 --> 00:02:52,190
starting from arm we have the Simpsons

00:02:50,030 --> 00:02:54,230
house which I'll talk a little bit more

00:02:52,190 --> 00:02:58,010
about next that are used by pretty much

00:02:54,230 --> 00:03:01,880
all of the arm vendors I build upon

00:02:58,010 --> 00:03:03,380
Simpsons we have at Mel's animal

00:03:01,880 --> 00:03:06,769
software framework used in the Sammy

00:03:03,380 --> 00:03:09,410
Sosa's entails using their cue MSI which

00:03:06,769 --> 00:03:10,640
is the cork microcontroller software

00:03:09,410 --> 00:03:12,110
interface I hope I got that acronym

00:03:10,640 --> 00:03:15,140
right

00:03:12,110 --> 00:03:19,190
Nordic has their MDK we have our MCU

00:03:15,140 --> 00:03:21,739
expresso SDK in the previous talk you

00:03:19,190 --> 00:03:23,299
heard or wanna talk about the the STM

00:03:21,739 --> 00:03:26,900
cube and how we're using that and zephyr

00:03:23,299 --> 00:03:31,430
and finally we do also have an sdk from

00:03:26,900 --> 00:03:32,840
TI for their simple link devices so

00:03:31,430 --> 00:03:35,390
they're kind of three levels of

00:03:32,840 --> 00:03:37,940
abstraction of how we can use those

00:03:35,390 --> 00:03:40,970
howls so starting kind of from the most

00:03:37,940 --> 00:03:43,720
abstract sense you know taking the the

00:03:40,970 --> 00:03:46,430
transactional high level drivers

00:03:43,720 --> 00:03:49,100
provided by the SOC vendors and so this

00:03:46,430 --> 00:03:52,100
is if the api's are compatible probably

00:03:49,100 --> 00:03:54,109
the simplest way to get a new driver

00:03:52,100 --> 00:03:56,810
supported and zephyr because most of the

00:03:54,109 --> 00:03:59,989
heavy lifting is done in the Hal driver

00:03:56,810 --> 00:04:03,500
itself and then within Zephyr we have

00:03:59,989 --> 00:04:06,980
very thin shim level drivers this is the

00:04:03,500 --> 00:04:09,560
approach that we've taken in the MCU X

00:04:06,980 --> 00:04:12,350
which is the kinetise and LPC devices

00:04:09,560 --> 00:04:15,019
from an XP as well as the the Intel q

00:04:12,350 --> 00:04:16,310
MSI driver so so those are kind of we've

00:04:15,019 --> 00:04:17,959
seen different vendors taking different

00:04:16,310 --> 00:04:19,910
approaches in terms of the levels of

00:04:17,959 --> 00:04:22,370
abstraction so the highest level

00:04:19,910 --> 00:04:26,840
transactional level we see in a you know

00:04:22,370 --> 00:04:28,520
two of these types of devices and then

00:04:26,840 --> 00:04:31,639
moving on to a slightly lower level of

00:04:28,520 --> 00:04:34,100
abstraction we see a low level will kind

00:04:31,639 --> 00:04:35,590
of stateless how type of driver which or

00:04:34,100 --> 00:04:38,719
one talked about in a bit more detail

00:04:35,590 --> 00:04:41,499
for the stm32 devices

00:04:38,719 --> 00:04:45,889
those have a slightly larger shim driver

00:04:41,499 --> 00:04:47,149
within Zephyr but have some abstraction

00:04:45,889 --> 00:04:50,569
that allowed them to be used across

00:04:47,149 --> 00:04:52,489
multiple devices and then finally if we

00:04:50,569 --> 00:04:56,299
take the sort of register definitions

00:04:52,489 --> 00:04:58,549
only from the house this is essentially

00:04:56,299 --> 00:05:01,069
a near-native zephyr driver it's not

00:04:58,549 --> 00:05:02,989
really any kind of procedural code that

00:05:01,069 --> 00:05:06,979
we're reusing but this is just taking

00:05:02,989 --> 00:05:10,909
the basically device header files that

00:05:06,979 --> 00:05:13,879
define all the register types and fields

00:05:10,909 --> 00:05:18,969
and this is the approach that we see in

00:05:13,879 --> 00:05:18,969
the Atmel and Nordic devices in Zephyr

00:05:20,110 --> 00:05:25,219
so a little bit about Simpson this is

00:05:22,969 --> 00:05:30,019
something that is used across all of the

00:05:25,219 --> 00:05:32,509
arm vendor soces just about so for those

00:05:30,019 --> 00:05:34,459
of you that aren't familiar Simpson is

00:05:32,509 --> 00:05:36,409
an acronym for the cortex

00:05:34,459 --> 00:05:39,229
microcontroller system interface

00:05:36,409 --> 00:05:41,719
standard it is a standard defined by arm

00:05:39,229 --> 00:05:43,849
and it's been pretty widely adopted by

00:05:41,719 --> 00:05:45,019
the different vendors it has several

00:05:43,849 --> 00:05:47,929
different components

00:05:45,019 --> 00:05:52,759
there's Simpsons core which we'll get to

00:05:47,929 --> 00:05:55,179
in a sec SVD DSP so the SVD is a system

00:05:52,759 --> 00:05:59,059
view description file something used by

00:05:55,179 --> 00:06:00,969
ITES and things like that to display you

00:05:59,059 --> 00:06:04,279
know and you're in your debugger

00:06:00,969 --> 00:06:06,219
peripheral value or excuse me register

00:06:04,279 --> 00:06:09,289
values while you're actually debugging

00:06:06,219 --> 00:06:11,839
CSP is a math library targeted at

00:06:09,289 --> 00:06:15,679
cortex-m devices and then driver

00:06:11,839 --> 00:06:18,919
interface is arms kind of view of one

00:06:15,679 --> 00:06:21,319
type of abstraction but for the purposes

00:06:18,919 --> 00:06:25,389
of Zephyr Simpson's core is the

00:06:21,319 --> 00:06:27,769
component that we're using it

00:06:25,389 --> 00:06:29,869
standardizes all the processor core

00:06:27,769 --> 00:06:33,409
accesses and peripheral definitions and

00:06:29,869 --> 00:06:36,249
so arm provides generic cortex-m header

00:06:33,409 --> 00:06:38,689
files and then the vendors like NXP

00:06:36,249 --> 00:06:40,639
build device header files on top of that

00:06:38,689 --> 00:06:42,589
and so when you put those together you

00:06:40,639 --> 00:06:46,969
get a full description of all the

00:06:42,589 --> 00:06:49,999
registers and the SOC within Zephyr the

00:06:46,969 --> 00:06:51,930
the kernel port uses the the symphysis

00:06:49,999 --> 00:06:55,680
turd typed air core

00:06:51,930 --> 00:06:58,800
accesses to talk to the N Vick in the

00:06:55,680 --> 00:07:01,289
SCB so any parts of Zephyr that talked

00:06:58,800 --> 00:07:05,039
to directly to the core registers in the

00:07:01,289 --> 00:07:07,530
C use sims's this is not quite true for

00:07:05,039 --> 00:07:11,250
for assembly level accesses but at least

00:07:07,530 --> 00:07:15,270
within the C realm we see Simpson being

00:07:11,250 --> 00:07:17,160
used and then the drivers base we see

00:07:15,270 --> 00:07:19,620
Zephyr drivers using sims's register

00:07:17,160 --> 00:07:27,090
accesses to talk to the peripheral

00:07:19,620 --> 00:07:28,620
registers so about MCU expresso SDK for

00:07:27,090 --> 00:07:30,930
those of you familiar in the tree or

00:07:28,620 --> 00:07:33,210
with Zephyr and and have been you know

00:07:30,930 --> 00:07:35,490
developing applications and and digging

00:07:33,210 --> 00:07:37,380
into the tree you'll see MCU X and a lot

00:07:35,490 --> 00:07:40,620
of different places and so I wanted to

00:07:37,380 --> 00:07:43,110
cover what MCU expresso is from an NX p

00:07:40,620 --> 00:07:45,180
vo and to you know make it clear what

00:07:43,110 --> 00:07:46,620
pieces of MCU Express so are we using an

00:07:45,180 --> 00:07:51,060
Zephyr and what other things are

00:07:46,620 --> 00:07:54,030
available beyond Zephyr so MC expresso

00:07:51,060 --> 00:07:57,659
is a common enablement that we do for

00:07:54,030 --> 00:08:01,590
all n XP cortex-m microcontrollers it's

00:07:57,659 --> 00:08:05,460
something we initially did for kinetise

00:08:01,590 --> 00:08:08,610
devices and then when n XP acquired

00:08:05,460 --> 00:08:11,909
freescale we then started to create the

00:08:08,610 --> 00:08:13,680
SDK for LPC devices as well so this

00:08:11,909 --> 00:08:15,000
consists of peripheral register

00:08:13,680 --> 00:08:17,580
definitions that are Simpson score

00:08:15,000 --> 00:08:19,620
compatible and what's kind of

00:08:17,580 --> 00:08:23,039
interesting about this I'm not sure if a

00:08:19,620 --> 00:08:24,630
lot of people know is that the the

00:08:23,039 --> 00:08:27,570
register definitions that are in sims's

00:08:24,630 --> 00:08:28,979
are actually generated from a common

00:08:27,570 --> 00:08:31,199
database that we use to generate

00:08:28,979 --> 00:08:32,550
hardware documentation so if you look at

00:08:31,199 --> 00:08:34,950
the reference manuals for the hardware

00:08:32,550 --> 00:08:36,510
that comes from the same source that we

00:08:34,950 --> 00:08:42,300
use to generate these sims's header

00:08:36,510 --> 00:08:44,430
files moving on to the bare metal

00:08:42,300 --> 00:08:48,450
peripheral drivers that are part of the

00:08:44,430 --> 00:08:51,480
SDK so we built I won't say the same but

00:08:48,450 --> 00:08:54,089
very similar api's across kinetise and

00:08:51,480 --> 00:08:56,540
LPC families so what that means is that

00:08:54,089 --> 00:09:00,390
we have quite a few different flavors of

00:08:56,540 --> 00:09:03,029
different protocol IPS so for example

00:09:00,390 --> 00:09:04,780
this a bit of an elf alphabet soup but

00:09:03,029 --> 00:09:08,680
you see urlp you are

00:09:04,780 --> 00:09:11,350
LPSC i what that means is that these are

00:09:08,680 --> 00:09:13,870
different UART IP blocks that we have on

00:09:11,350 --> 00:09:17,010
different kinetise devices and so we did

00:09:13,870 --> 00:09:20,260
in the MCU expresso SDK is to build

00:09:17,010 --> 00:09:22,120
similar api's across these and what that

00:09:20,260 --> 00:09:23,560
means for Zephyr is that then the next

00:09:22,120 --> 00:09:25,840
level shim is going to look pretty

00:09:23,560 --> 00:09:28,090
similar from one to the next and so it

00:09:25,840 --> 00:09:32,680
should make it easier you know once you

00:09:28,090 --> 00:09:39,030
see a UART shim for example moving to an

00:09:32,680 --> 00:09:41,110
LP you are an LPS LPS CI IP block

00:09:39,030 --> 00:09:43,860
creating shim drivers for those should

00:09:41,110 --> 00:09:43,860
be pretty straightforward

00:09:46,590 --> 00:09:52,180
some of the design philosophy on

00:09:49,210 --> 00:09:54,700
building these drivers is has some

00:09:52,180 --> 00:09:57,100
similarities to suffer in that we tried

00:09:54,700 --> 00:10:00,150
to minimize inter dependencies between

00:09:57,100 --> 00:10:02,830
drivers and so you'll see an independent

00:10:00,150 --> 00:10:04,840
ITC driver and independent clock driver

00:10:02,830 --> 00:10:06,340
and things like that and so one of the

00:10:04,840 --> 00:10:08,590
problems that we had in previous

00:10:06,340 --> 00:10:10,000
iterations of the SDK is that some of

00:10:08,590 --> 00:10:13,420
these had inter dependencies with each

00:10:10,000 --> 00:10:16,720
other and we tried to fix that in this

00:10:13,420 --> 00:10:18,339
current version of the SDK makes a lot

00:10:16,720 --> 00:10:21,480
easier to just take one piece without

00:10:18,339 --> 00:10:24,730
getting everything if you don't need it

00:10:21,480 --> 00:10:28,089
and then finally the SDK also comes with

00:10:24,730 --> 00:10:30,010
a pretty large number of example

00:10:28,089 --> 00:10:34,480
projects and the reason I bring that up

00:10:30,010 --> 00:10:39,339
here is that you know as we continue to

00:10:34,480 --> 00:10:40,720
build new api's or implement api's you

00:10:39,339 --> 00:10:44,050
know that haven't yet been implemented

00:10:40,720 --> 00:10:45,730
for kinetise or LPC parts if there isn't

00:10:44,050 --> 00:10:47,920
an example already in the zephyr tree

00:10:45,730 --> 00:10:51,610
there's another resource out there so

00:10:47,920 --> 00:10:53,500
these example projects aim to provide or

00:10:51,610 --> 00:11:01,540
demonstrate how to use these peripheral

00:10:53,500 --> 00:11:04,210
api's so the external folder this is

00:11:01,540 --> 00:11:07,120
where we store all the externally

00:11:04,210 --> 00:11:10,030
maintained source code in a zephyr

00:11:07,120 --> 00:11:12,220
so this is not exclusively the SOC

00:11:10,030 --> 00:11:14,260
vendor house but does include them so

00:11:12,220 --> 00:11:17,560
but there are other components as well

00:11:14,260 --> 00:11:18,600
such as embed TLS tiny fat FS and

00:11:17,560 --> 00:11:20,730
Sega RTT

00:11:18,600 --> 00:11:22,620
sure if that's a complete list but the

00:11:20,730 --> 00:11:24,449
point there is that it's not just house

00:11:22,620 --> 00:11:27,540
it's also other things so anytime we

00:11:24,449 --> 00:11:28,889
have we find a component out of the

00:11:27,540 --> 00:11:31,380
community that we think we can leverage

00:11:28,889 --> 00:11:33,480
and suffer that's the place to put it

00:11:31,380 --> 00:11:35,339
and that helps us to make the

00:11:33,480 --> 00:11:38,490
distinction between you know what is

00:11:35,339 --> 00:11:40,620
code that we excuse me develop natively

00:11:38,490 --> 00:11:46,410
for Zephyr and what is code that we're

00:11:40,620 --> 00:11:49,880
using as is so anything in the external

00:11:46,410 --> 00:11:52,350
folder we look as it needs to be

00:11:49,880 --> 00:11:55,199
compatible license or permissively

00:11:52,350 --> 00:11:58,860
licensed but not necessarily Apache -

00:11:55,199 --> 00:12:02,519
and I think most or many of them are BSD

00:11:58,860 --> 00:12:05,190
three clause that we have today like I

00:12:02,519 --> 00:12:08,130
said we try to import code into this

00:12:05,190 --> 00:12:10,290
folder as is without with minimal

00:12:08,130 --> 00:12:12,839
modification I realize that sometimes

00:12:10,290 --> 00:12:15,209
you know small tweaks are needed to make

00:12:12,839 --> 00:12:19,410
the code build without errors or you

00:12:15,209 --> 00:12:22,139
know rearrange things or you know just

00:12:19,410 --> 00:12:25,230
it's difficult to pull things as is

00:12:22,139 --> 00:12:28,800
without touching them at all but if you

00:12:25,230 --> 00:12:31,199
do need to touch it and we like to have

00:12:28,800 --> 00:12:33,060
separate commits so the maintainer can

00:12:31,199 --> 00:12:35,430
distinguish between what was the

00:12:33,060 --> 00:12:36,959
original code what it looked like and

00:12:35,430 --> 00:12:40,740
what did you change to make it work in

00:12:36,959 --> 00:12:42,899
Zephyr and lastly anything in the

00:12:40,740 --> 00:12:44,610
external folder is exempt from these

00:12:42,899 --> 00:12:49,160
effort coding style and so that's built

00:12:44,610 --> 00:12:51,779
into the check patch scripts as well so

00:12:49,160 --> 00:12:53,910
you know it's we wouldn't be able to

00:12:51,779 --> 00:12:56,699
enforce the Zephyr coding style on

00:12:53,910 --> 00:12:59,389
external components that we they import

00:12:56,699 --> 00:12:59,389
into the project

00:13:01,920 --> 00:13:05,579
just recently I think in the last week

00:13:04,709 --> 00:13:08,160
maybe two weeks

00:13:05,579 --> 00:13:12,300
the Zephyr Governing Board approved a

00:13:08,160 --> 00:13:14,610
new process to import components into

00:13:12,300 --> 00:13:17,220
the tree so you guys are probably the

00:13:14,610 --> 00:13:21,420
first to see this outside of the the

00:13:17,220 --> 00:13:22,949
core development group so there are a

00:13:21,420 --> 00:13:25,199
couple of different things or what the

00:13:22,949 --> 00:13:26,699
process looks like is so if you find a

00:13:25,199 --> 00:13:28,949
component that you're interested in

00:13:26,699 --> 00:13:31,030
importing into the tree the first thing

00:13:28,949 --> 00:13:33,910
is that we need some documentation

00:13:31,030 --> 00:13:36,370
what where did you get this code how

00:13:33,910 --> 00:13:38,830
does it maintain what's the license and

00:13:36,370 --> 00:13:43,090
so that needs to be documented in a

00:13:38,830 --> 00:13:45,670
readme and submitted to the TSC and so

00:13:43,090 --> 00:13:50,050
we can leverage the existing github pull

00:13:45,670 --> 00:13:53,380
request workflow to do this so the TSE

00:13:50,050 --> 00:13:56,890
divers will review the proposal and if

00:13:53,380 --> 00:13:58,240
they are if they approve it they'll

00:13:56,890 --> 00:14:01,990
forward it to the governing board for

00:13:58,240 --> 00:14:04,900
review so then the governing board they

00:14:01,990 --> 00:14:07,980
have two weeks to review the the

00:14:04,900 --> 00:14:12,370
proposal to import a new code component

00:14:07,980 --> 00:14:14,230
and if nobody raises any objections in

00:14:12,370 --> 00:14:17,530
that two-week period the software's

00:14:14,230 --> 00:14:21,060
accepted the readme is included and we

00:14:17,530 --> 00:14:24,010
can go ahead and merge that pull request

00:14:21,060 --> 00:14:27,400
if a member of the governing board does

00:14:24,010 --> 00:14:29,800
raise concerns then we they have to you

00:14:27,400 --> 00:14:37,240
know vote on that and decide if there's

00:14:29,800 --> 00:14:39,970
alternate actions so this is the kind of

00:14:37,240 --> 00:14:42,250
a list of information that we need to

00:14:39,970 --> 00:14:46,480
document a new code component before it

00:14:42,250 --> 00:14:47,890
can be imported into Zephyr this hasn't

00:14:46,480 --> 00:14:49,030
changed dramatically I think there are a

00:14:47,890 --> 00:14:53,410
couple of new things that get added

00:14:49,030 --> 00:14:56,710
recently so what's the origin why are we

00:14:53,410 --> 00:15:00,340
including it what are the dependencies

00:14:56,710 --> 00:15:02,860
what does it link to if you get that

00:15:00,340 --> 00:15:06,310
code from a git repository what's the

00:15:02,860 --> 00:15:10,300
commit Shah and then a link to the

00:15:06,310 --> 00:15:13,630
license so that's just a quick overview

00:15:10,300 --> 00:15:15,940
of you know how we're using vendor house

00:15:13,630 --> 00:15:19,690
why are we using vendor house and how do

00:15:15,940 --> 00:15:22,740
we get new ones into the tree that's all

00:15:19,690 --> 00:15:22,740
you have any questions

00:15:24,529 --> 00:15:27,519
yeah

00:15:35,690 --> 00:15:42,950
they didn't share that is honest still

00:15:40,310 --> 00:15:44,890
here do you want to cut can you comment

00:15:42,950 --> 00:15:47,330
on that

00:15:44,890 --> 00:15:50,320
what does look what criteria does the

00:15:47,330 --> 00:15:50,320
Governing Board use

00:16:45,450 --> 00:16:48,080
yes

00:16:56,350 --> 00:17:06,310
no a good question so the question was

00:17:02,230 --> 00:17:08,800
do we pull in the entire SDK for nxp and

00:17:06,310 --> 00:17:11,050
so the answer is no and the reason is

00:17:08,800 --> 00:17:14,430
that we we actually only distribute the

00:17:11,050 --> 00:17:18,370
SDK on a device by device basis and so

00:17:14,430 --> 00:17:19,870
typically what what will happen is you

00:17:18,370 --> 00:17:23,350
know somebody's interested in porting

00:17:19,870 --> 00:17:25,930
Zephyr to a new SOC then they would go

00:17:23,350 --> 00:17:29,290
and download the SDK and import the SDK

00:17:25,930 --> 00:17:32,230
for that OSIS SOC sometimes what will

00:17:29,290 --> 00:17:34,570
happen is the SDK like basically we have

00:17:32,230 --> 00:17:36,640
what we call super set devices and

00:17:34,570 --> 00:17:38,590
subset devices that may have the same

00:17:36,640 --> 00:17:40,960
group of SOC or same group of

00:17:38,590 --> 00:17:42,910
peripherals but a smaller memory

00:17:40,960 --> 00:17:45,340
footprint for example and those will be

00:17:42,910 --> 00:17:49,030
part of the same SDK and so what I've

00:17:45,340 --> 00:17:51,460
done is to try to when I when I pull an

00:17:49,030 --> 00:17:52,870
SDK from the MCU expressos website then

00:17:51,460 --> 00:17:56,140
that's what I'll go and import into

00:17:52,870 --> 00:18:05,440
Zephyr rather than there's no way to get

00:17:56,140 --> 00:18:08,260
an SDK for all of the associated take

00:18:05,440 --> 00:18:12,000
them as needed basis but without

00:18:08,260 --> 00:18:12,000
breaking up packages

00:18:17,760 --> 00:18:23,660
yes yes yes

00:18:30,120 --> 00:18:41,230
mm-hmm

00:18:32,610 --> 00:18:43,780
no no and yeah that that's one change

00:18:41,230 --> 00:18:46,930
that I made in Zephyr when I imported

00:18:43,780 --> 00:18:50,110
the SDK is is for those drivers those

00:18:46,930 --> 00:18:52,810
SOC drivers that I know are supported in

00:18:50,110 --> 00:18:54,340
multiple SOC s then I actually changed

00:18:52,810 --> 00:18:57,070
the directory structure a little bit so

00:18:54,340 --> 00:18:59,140
I have within the the Hal folder I have

00:18:57,070 --> 00:19:01,660
a drivers folder and then I also have an

00:18:59,140 --> 00:19:03,700
SOC folder and so for the drivers that

00:19:01,660 --> 00:19:05,530
are SOC specific that has some name cup

00:19:03,700 --> 00:19:07,390
naming conflicts like clocking for

00:19:05,530 --> 00:19:11,110
example is an example of a driver where

00:19:07,390 --> 00:19:14,410
I put that driver in the SOC folder in

00:19:11,110 --> 00:19:16,600
the how versus you know the UART driver

00:19:14,410 --> 00:19:19,300
which I know is supported on multiple

00:19:16,600 --> 00:19:21,250
SOC so I had to break it up a little bit

00:19:19,300 --> 00:19:23,970
but wherever possible I tried not the

00:19:21,250 --> 00:19:23,970
duplicate code

00:19:37,760 --> 00:19:46,789
it's the same code that the directory

00:19:41,100 --> 00:19:46,789
structure is a little bit different yeah

00:19:48,919 --> 00:19:53,460
no I don't think there's any problem

00:19:50,850 --> 00:19:56,730
with moving things around within reason

00:19:53,460 --> 00:20:00,419
you know like I said with the the the

00:19:56,730 --> 00:20:03,450
common drivers you know it did make a

00:20:00,419 --> 00:20:05,220
change to the way that we release it as

00:20:03,450 --> 00:20:07,429
an expedient change the content of the

00:20:05,220 --> 00:20:07,429
file

00:20:18,750 --> 00:20:24,630
yeah so I had an interesting suggestion

00:20:22,100 --> 00:20:28,380
recently which I think might be a good

00:20:24,630 --> 00:20:32,010
opportunity for a future work in that as

00:20:28,380 --> 00:20:33,900
it is today it's kind of a manual

00:20:32,010 --> 00:20:35,130
process to do that directory

00:20:33,900 --> 00:20:38,400
restructuring I mean it's not

00:20:35,130 --> 00:20:39,809
significant but I've done a few times so

00:20:38,400 --> 00:20:41,039
I'm familiar with it but for somebody

00:20:39,809 --> 00:20:44,010
new the project it might be a little

00:20:41,039 --> 00:20:46,230
more difficult and so the suggestion was

00:20:44,010 --> 00:20:48,030
made to just script it out and that's

00:20:46,230 --> 00:20:50,929
probably something I'll work on in the

00:20:48,030 --> 00:20:50,929
near future

00:20:55,570 --> 00:20:58,200
yeah

00:21:17,799 --> 00:21:22,119
um I think it will stay like that for

00:21:20,440 --> 00:21:24,850
quite some time I mean maybe as the

00:21:22,119 --> 00:21:26,379
project grows we might see you know they

00:21:24,850 --> 00:21:27,940
might have enough people working on the

00:21:26,379 --> 00:21:31,779
project that we could support more

00:21:27,940 --> 00:21:33,220
native drivers but as it is today we

00:21:31,779 --> 00:21:35,610
just we don't have the bandwidth to do

00:21:33,220 --> 00:21:35,610
that right now

00:21:39,360 --> 00:21:46,690
yeah you know if they're willing to

00:21:43,659 --> 00:21:48,669
maintain it you know it's a challenge

00:21:46,690 --> 00:21:50,940
when we've have so many different

00:21:48,669 --> 00:21:55,739
Association so many different drivers

00:21:50,940 --> 00:21:55,739
and we are still a pretty young project

00:23:31,509 --> 00:23:36,919
okay thank you yeah I mean that's not a

00:23:34,639 --> 00:23:40,539
scenario we've we've hit yet but you

00:23:36,919 --> 00:23:40,539
know you certainly had a few more years

00:23:58,750 --> 00:24:01,980
[Music]

00:24:17,150 --> 00:24:22,800
yeah I think the trick with the native

00:24:19,920 --> 00:24:24,540
drivers is is figuring out how to create

00:24:22,800 --> 00:24:28,740
a native driver that can be supported

00:24:24,540 --> 00:24:30,090
across a sociis there certainly you know

00:24:28,740 --> 00:24:32,100
you need that visibility to know what

00:24:30,090 --> 00:24:34,410
other SOC s would that driver apply to

00:24:32,100 --> 00:24:36,770
and then that's not necessarily an easy

00:24:34,410 --> 00:24:36,770
task

00:25:09,180 --> 00:25:18,840
a patch list for what's been modified in

00:25:11,760 --> 00:25:22,140
the how well and that's why I earlier

00:25:18,840 --> 00:25:24,180
that you know I like to see you know

00:25:22,140 --> 00:25:25,680
initial patch that imports the hell and

00:25:24,180 --> 00:25:27,570
then a secondary or however many

00:25:25,680 --> 00:25:29,730
additional patches on top of that so

00:25:27,570 --> 00:25:32,340
it's obvious what changes you had to

00:25:29,730 --> 00:25:35,280
make that there were a couple of small

00:25:32,340 --> 00:25:36,900
cases that I had to deal with you know

00:25:35,280 --> 00:25:39,240
with the MC expresso stuff I don't know

00:25:36,900 --> 00:25:42,360
you know you know how many changes you

00:25:39,240 --> 00:25:44,820
had to make to MQ for example but at

00:25:42,360 --> 00:25:46,650
least using it as a method to do that

00:25:44,820 --> 00:25:49,400
then I you know you can naturally look

00:25:46,650 --> 00:25:49,400
at the get history

00:26:11,320 --> 00:26:14,469
anything else

00:26:21,430 --> 00:26:27,500
right

00:26:23,870 --> 00:26:30,740
right no I mean you know the Atmel pal

00:26:27,500 --> 00:26:32,510
for example I mean we've had we don't

00:26:30,740 --> 00:26:34,159
have somebody from Atmel working on it

00:26:32,510 --> 00:26:37,100
there there has been a guy that that's

00:26:34,159 --> 00:26:40,340
kind of been taking that role outside of

00:26:37,100 --> 00:26:42,770
Atmel but we haven't I mean you don't

00:26:40,340 --> 00:26:46,120
have a whole lot of cases of that yet

00:26:42,770 --> 00:26:46,120
that's a good question

00:26:49,610 --> 00:26:52,860
[Music]

00:27:09,710 --> 00:27:16,990
we need more maintainer x' alright well

00:27:14,660 --> 00:27:21,780
thank you

00:27:16,990 --> 00:27:26,750
[Applause]

00:27:21,780 --> 00:27:26,750

YouTube URL: https://www.youtube.com/watch?v=hHcnw4xu_Mo


