Title: LCU14-100: Dalvik is Dead, Long Live Dalvik! OR Tuning ART
Publication date: 2014-09-15
Playlist: Linaro Connect USA 2014
Description: 
	LCU14-100: Dalvik is Dead, Long Live Dalvik! OR Tuning ART

---------------------------------------------------

Speaker: Stuart Monteith
Track: Android
Location: Grand Peninsula D, Hyatt Regency San Francisco Airport, Burlingame, CA, United States
---------------------------------------------------

★ Session Summary ★
The Dalvik virtual machine is the crucial part of Android responsible for executing platform independent code in Android apps.The upcoming L release of Android replaces ""Dalvik"" with a new implementation of the Dalvik virtual machine called the ""Android RunTime"" (ART). In this session you can learn about ART, Dalvik compatibility, and our experiences assisting with the 64bit porting efforts on AOSP.
---------------------------------------------------

★ Resources ★
Zerista: http://lcu14.zerista.com/event/member/137702
Google Event: 
Presentation: 
Video: 
Eatherpad: pad.linaro.org/p/lcu14-100

---------------------------------------------------

★ Event Details ★
Linaro Connect USA - #LCU14
September 15-19th, 2014
Hyatt Regency San Francisco Airport
---------------------------------------------------

&gt; http://www.linaro.org
&gt; http://connect.linaro.org
Captions: 
	00:01:44,500 --> 00:01:52,040
good morning everyone and I think it

00:01:49,490 --> 00:02:03,880
starts at ten has ten so we're already a

00:01:52,040 --> 00:02:07,910
funny little over yeah okay talk start

00:02:03,880 --> 00:02:11,300
ok good there morning everyone and this

00:02:07,910 --> 00:02:14,030
is my fresh lemonade and my name's Jim

00:02:11,300 --> 00:02:19,280
teeth I work in the systems and software

00:02:14,030 --> 00:02:24,200
grip and arm and that's as the tech lead

00:02:19,280 --> 00:02:26,930
for the art and the dalvik work we

00:02:24,200 --> 00:02:30,500
working there for two years and that's

00:02:26,930 --> 00:02:33,560
been mostly on the arm VA 64-bit support

00:02:30,500 --> 00:02:36,190
we've been doing for that work and this

00:02:33,560 --> 00:02:40,010
called dalvik is dead long live dalvik

00:02:36,190 --> 00:02:42,890
after commit that brian cowen with

00:02:40,010 --> 00:02:48,860
google did and their gin announcing the

00:02:42,890 --> 00:02:52,400
death of a phallic so word length if you

00:02:48,860 --> 00:02:56,450
take away from this is understand what

00:02:52,400 --> 00:03:00,340
dalvik is what changes were introduced

00:02:56,450 --> 00:03:04,340
by art and who aren't relates to dalvik

00:03:00,340 --> 00:03:07,280
how sexy for bet has changed the runtime

00:03:04,340 --> 00:03:09,980
and will do that to a quick introduction

00:03:07,280 --> 00:03:12,790
dalvik some of the work we dead on

00:03:09,980 --> 00:03:15,470
dalvik and although an introduction to

00:03:12,790 --> 00:03:16,600
what artisan highlight their furs from

00:03:15,470 --> 00:03:19,160
dalvik

00:03:16,600 --> 00:03:22,430
followed by some of our experiences on

00:03:19,160 --> 00:03:28,010
AOSP and hopefully some may questions

00:03:22,430 --> 00:03:30,650
and answers so now art is a rent

00:03:28,010 --> 00:03:33,260
climates replace talvik and so

00:03:30,650 --> 00:03:37,340
especially this grape are in terms of

00:03:33,260 --> 00:03:40,060
what dalvik was now if anyone's been

00:03:37,340 --> 00:03:43,580
licking it android for pastor usual

00:03:40,060 --> 00:03:45,650
recognized variants of this diagram and

00:03:43,580 --> 00:03:48,500
what got highlighted there as the

00:03:45,650 --> 00:03:52,580
position of the dalvik VM I'd

00:03:48,500 --> 00:03:55,850
characterize that as Android as being

00:03:52,580 --> 00:03:58,670
much of the android framework and so in

00:03:55,850 --> 00:04:01,250
order to do a poor of valve of Android

00:03:58,670 --> 00:04:06,350
you either on came to execute all of

00:04:01,250 --> 00:04:13,959
that code and this box here is what was

00:04:06,350 --> 00:04:17,510
replaced by art so what is dalvik know

00:04:13,959 --> 00:04:19,580
dalek as a virtual machine but it's not

00:04:17,510 --> 00:04:25,190
a virtual machine necessarily in terms

00:04:19,580 --> 00:04:26,780
that awake kvm or GMU and said it's what

00:04:25,190 --> 00:04:29,330
sometimes there is a management thing

00:04:26,780 --> 00:04:31,820
and the diagram there we see there is

00:04:29,330 --> 00:04:33,980
executing a baked goods but to the

00:04:31,820 --> 00:04:37,330
instruction set is just the techs are

00:04:33,980 --> 00:04:39,950
good for learning a language and then

00:04:37,330 --> 00:04:42,590
operates on nuclear codes and the

00:04:39,950 --> 00:04:44,780
changes its heat which is restore just

00:04:42,590 --> 00:04:47,270
working memory and part of the

00:04:44,780 --> 00:04:51,350
advantages of having managed rental is

00:04:47,270 --> 00:04:55,400
that you can support that language on

00:04:51,350 --> 00:04:57,700
any platform a session way and provide

00:04:55,400 --> 00:05:00,140
these features a high level so you have

00:04:57,700 --> 00:05:02,570
exception handling your object on

00:05:00,140 --> 00:05:05,930
goodness we've got references rather

00:05:02,570 --> 00:05:08,780
than pointer stays away from the VSS

00:05:05,930 --> 00:05:12,200
myself and you've got garbage collection

00:05:08,780 --> 00:05:13,720
to manage your memory and an idea of how

00:05:12,200 --> 00:05:16,400
to write programs can currently

00:05:13,720 --> 00:05:18,940
regardless of the CPU so all of this

00:05:16,400 --> 00:05:24,650
provides you with a certain amount of

00:05:18,940 --> 00:05:27,710
platform independence now when you're

00:05:24,650 --> 00:05:30,350
writing programs for dalvik odds are you

00:05:27,710 --> 00:05:33,110
using the Android development toolkit

00:05:30,350 --> 00:05:35,360
you won't see any of it well I actually

00:05:33,110 --> 00:05:38,060
happen is that the Java fails and get

00:05:35,360 --> 00:05:41,510
compelled to class fails and those class

00:05:38,060 --> 00:05:44,960
fails we converted into dot deck cells

00:05:41,510 --> 00:05:47,560
which are them packaging your apk and an

00:05:44,960 --> 00:05:50,390
application is installed on the system

00:05:47,560 --> 00:05:52,700
addex opt for sessions on top of that

00:05:50,390 --> 00:05:54,980
which makes it more efficient when it's

00:05:52,700 --> 00:05:56,510
actually running on the device but it

00:05:54,980 --> 00:05:59,570
doesn't substantially change the bay

00:05:56,510 --> 00:06:01,520
code that it's running on and and this

00:05:59,570 --> 00:06:06,650
will be important later mallika come to

00:06:01,520 --> 00:06:10,100
look at how aren't those things now over

00:06:06,650 --> 00:06:12,290
the years dalvik has changed somewhat

00:06:10,100 --> 00:06:15,260
but the devices it's running on have

00:06:12,290 --> 00:06:18,830
changed a lot now don't worry about

00:06:15,260 --> 00:06:22,220
where these numbers come from what's

00:06:18,830 --> 00:06:24,590
very important abuelita's over the sex

00:06:22,220 --> 00:06:28,190
years or so that android has been out

00:06:24,590 --> 00:06:32,150
there and cpus have gotten much more

00:06:28,190 --> 00:06:34,790
faster ram is increased by a fair amount

00:06:32,150 --> 00:06:41,600
and pixels that have to be moved around

00:06:34,790 --> 00:06:44,780
is massively increased as well so when

00:06:41,600 --> 00:06:47,300
doing this it's to look at the next

00:06:44,780 --> 00:06:48,980
slide you'll see the there have been

00:06:47,300 --> 00:06:52,250
some improvements in dialect to try and

00:06:48,980 --> 00:06:55,520
cope with it so i just insane compel was

00:06:52,250 --> 00:06:57,980
created renovated then I change the pain

00:06:55,520 --> 00:07:00,230
which I will explain and woody Theo

00:06:57,980 --> 00:07:02,060
later the garbage collection was made

00:07:00,230 --> 00:07:05,450
working current to try and reduce plays

00:07:02,060 --> 00:07:07,910
games and this may traumatic processing

00:07:05,450 --> 00:07:13,940
support was added to support more than

00:07:07,910 --> 00:07:15,230
one cpu you know i should mention what a

00:07:13,940 --> 00:07:17,090
tracing jet tears because this is

00:07:15,230 --> 00:07:19,730
something that's substantially changed

00:07:17,090 --> 00:07:24,680
with the earth there and we are trending

00:07:19,730 --> 00:07:27,440
I just insane compiler compels the decks

00:07:24,680 --> 00:07:29,960
baked goods to native good but it does

00:07:27,440 --> 00:07:32,780
that at renting this as your application

00:07:29,960 --> 00:07:35,660
is running and it tries to be selective

00:07:32,780 --> 00:07:37,790
about what is being Compellent so rather

00:07:35,660 --> 00:07:41,000
than compel everything it will only

00:07:37,790 --> 00:07:43,830
compel certain methods certain parts of

00:07:41,000 --> 00:07:46,080
methods that are executed heavily

00:07:43,830 --> 00:07:51,870
so only wersja guard you this hot good

00:07:46,080 --> 00:07:54,900
as compelled no dalvik was noted for

00:07:51,870 --> 00:07:58,080
having its efficient Baker interpreter

00:07:54,900 --> 00:08:01,400
and that was somewhat modified in order

00:07:58,080 --> 00:08:04,620
to support the just-in-time compilation

00:08:01,400 --> 00:08:06,870
so as it's executing beta code the well

00:08:04,620 --> 00:08:09,990
profile that and determine where the

00:08:06,870 --> 00:08:13,050
hotspots are and once it determines the

00:08:09,990 --> 00:08:15,570
spot is hot it will then dispatch it to

00:08:13,050 --> 00:08:18,270
a thread to then be compelled and that

00:08:15,570 --> 00:08:21,780
is named patch then to the into the

00:08:18,270 --> 00:08:25,700
execution of the program however the

00:08:21,780 --> 00:08:28,980
code that produced was not ideal and

00:08:25,700 --> 00:08:32,010
explain that later but even haven't done

00:08:28,980 --> 00:08:38,670
that there's about five times crackling

00:08:32,010 --> 00:08:44,220
interpreter was claimed so here we have

00:08:38,670 --> 00:08:49,140
a truth well this is a method and Dex

00:08:44,220 --> 00:08:51,900
they could so I'm going to explain how a

00:08:49,140 --> 00:08:55,950
program executes across this and how is

00:08:51,900 --> 00:08:58,350
then jetted now when we're entering the

00:08:55,950 --> 00:09:00,500
method here at race is pretty much made

00:08:58,350 --> 00:09:03,630
up of a linear sequence of instructions

00:09:00,500 --> 00:09:07,350
followed by a branch the conditional

00:09:03,630 --> 00:09:12,060
branch and here on one of the conditions

00:09:07,350 --> 00:09:14,310
there were perhaps on being forwards we

00:09:12,060 --> 00:09:16,290
meaning execute less section next where

00:09:14,310 --> 00:09:20,820
there's another one is linear sequence

00:09:16,290 --> 00:09:22,770
and compile and a conditional branch the

00:09:20,820 --> 00:09:26,340
bottom one is somewhere interesting and

00:09:22,770 --> 00:09:29,490
that rather than the trace ending in the

00:09:26,340 --> 00:09:31,620
go to the quarter is not confessional so

00:09:29,490 --> 00:09:34,800
that trace will incorporate the

00:09:31,620 --> 00:09:37,590
conditional branch after the go-to so

00:09:34,800 --> 00:09:40,140
this doesn't quite the compilation basic

00:09:37,590 --> 00:09:44,340
blocks but when your sequences they're

00:09:40,140 --> 00:09:48,030
hot now if we execute that's a second

00:09:44,340 --> 00:09:50,100
time that sequences then compelled and a

00:09:48,030 --> 00:09:53,460
nice time said I'm representing this as

00:09:50,100 --> 00:09:56,500
our treats this is a big piece of native

00:09:53,460 --> 00:10:00,350
coordinates compel them to now hush

00:09:56,500 --> 00:10:02,480
and say we're taking this branch to the

00:10:00,350 --> 00:10:04,190
bottom sequence of cords that will be

00:10:02,480 --> 00:10:07,100
the second sequence of cordless

00:10:04,190 --> 00:10:10,790
compelled and each of them returned to

00:10:07,100 --> 00:10:13,370
the interpreter and when all is said and

00:10:10,790 --> 00:10:15,860
done we may see this king of sequence

00:10:13,370 --> 00:10:17,779
where a number of different races are

00:10:15,860 --> 00:10:19,790
compelled and an order it doesn't

00:10:17,779 --> 00:10:22,130
correspond with the order of basic

00:10:19,790 --> 00:10:28,010
walked and the program and may take

00:10:22,130 --> 00:10:31,520
several iterations for us to happen one

00:10:28,010 --> 00:10:35,870
thing to observe is that there are two

00:10:31,520 --> 00:10:38,930
areas where bicoid number backward that

00:10:35,870 --> 00:10:43,690
the dress five is compelled is compelled

00:10:38,930 --> 00:10:47,060
twice as its present into treaties and

00:10:43,690 --> 00:10:48,980
that's one aspect there's also garbage

00:10:47,060 --> 00:10:52,370
collection which if you're not familiar

00:10:48,980 --> 00:10:54,650
with generally have see a thread stack

00:10:52,370 --> 00:10:56,620
we've got local variables and those

00:10:54,650 --> 00:11:00,740
local variables have references to

00:10:56,620 --> 00:11:05,450
object those objects can in turn

00:11:00,740 --> 00:11:09,589
reference other objects now rather than

00:11:05,450 --> 00:11:11,959
having reference counting which has the

00:11:09,589 --> 00:11:13,790
slight problem with them if you refer to

00:11:11,959 --> 00:11:17,589
yourself you'll tend to keep yourself

00:11:13,790 --> 00:11:21,680
live like an object here and use a

00:11:17,589 --> 00:11:25,459
number of mark and sweep so in S&M you

00:11:21,680 --> 00:11:29,120
wear dereferencing the F object from the

00:11:25,459 --> 00:11:32,410
sea object and so when we then marking

00:11:29,120 --> 00:11:37,040
when reference to the next we see that

00:11:32,410 --> 00:11:39,740
the r CA e and b would be marks f would

00:11:37,040 --> 00:11:41,930
not and B would not and so it comes to

00:11:39,740 --> 00:11:45,380
sweeping these objects away will then

00:11:41,930 --> 00:11:48,589
disappear and it's important to note

00:11:45,380 --> 00:11:53,450
that with references you always know

00:11:48,589 --> 00:11:56,180
what is referring to your object so I'm

00:11:53,450 --> 00:11:59,300
going to move on to know to the work

00:11:56,180 --> 00:12:04,339
that we did n arm when porting dalvik to

00:11:59,300 --> 00:12:08,090
gr 64 and much of what we that was done

00:12:04,339 --> 00:12:12,870
in some other form on our

00:12:08,090 --> 00:12:15,270
and then go into this so when we're

00:12:12,870 --> 00:12:18,060
doing less there was certain things that

00:12:15,270 --> 00:12:20,970
had to be done first I suggest you go to

00:12:18,060 --> 00:12:22,370
share bangs clock on Thursday where

00:12:20,970 --> 00:12:25,560
he'll be talking about how we went from

00:12:22,370 --> 00:12:27,630
the colonel to Bionic and the shell

00:12:25,560 --> 00:12:33,210
where was a user space shell for rainbow

00:12:27,630 --> 00:12:35,580
and there's lots of publicity on the way

00:12:33,210 --> 00:12:37,590
a boat speculating that you could just

00:12:35,580 --> 00:12:40,620
recompile Android and have it work on

00:12:37,590 --> 00:12:42,990
64-bit and for saying things like

00:12:40,620 --> 00:12:49,320
maintain the shield a breeze that's

00:12:42,990 --> 00:12:52,680
obviously not true now we are doing

00:12:49,320 --> 00:12:54,510
which we did this was slightly and not

00:12:52,680 --> 00:12:58,440
the theme is what was done for the

00:12:54,510 --> 00:13:01,010
native year of 64 as dalvik friends on

00:12:58,440 --> 00:13:03,840
the host machine and we could start

00:13:01,010 --> 00:13:06,210
converting the portable seen character

00:13:03,840 --> 00:13:10,470
the sexy for bed so make everything

00:13:06,210 --> 00:13:12,930
that's not platform specific and sexy

00:13:10,470 --> 00:13:16,589
for bed so that that involved changing

00:13:12,930 --> 00:13:18,060
how the interpreter work and checking

00:13:16,589 --> 00:13:21,150
garbage collection watch and for most

00:13:18,060 --> 00:13:24,030
parts of dead and Jane I was another

00:13:21,150 --> 00:13:27,000
area that acquired lots of changes use

00:13:24,030 --> 00:13:28,770
of space would be quite different one

00:13:27,000 --> 00:13:31,550
thing we experimented with was the

00:13:28,770 --> 00:13:34,140
concept of compressed references and

00:13:31,550 --> 00:13:38,130
this is where we can claw back some

00:13:34,140 --> 00:13:40,800
performance me otherwise lose if you've

00:13:38,130 --> 00:13:42,180
got Java you will tend to have lots of

00:13:40,800 --> 00:13:44,850
objects referring to lots of other

00:13:42,180 --> 00:13:47,870
objects and so becomes very reference

00:13:44,850 --> 00:13:51,120
heavy and because this is based there

00:13:47,870 --> 00:13:53,690
someone Java you don't know what a

00:13:51,120 --> 00:13:56,490
reference says so he can play with it

00:13:53,690 --> 00:13:59,190
and so we had a couple of ancient

00:13:56,490 --> 00:14:01,020
compared references where rather than

00:13:59,190 --> 00:14:02,520
having a sexy for a bit pointer between

00:14:01,020 --> 00:14:06,510
objects we could have a 30 to bed

00:14:02,520 --> 00:14:09,540
pointing and that would be invisible to

00:14:06,510 --> 00:14:12,510
the program and crossing the J'naii

00:14:09,540 --> 00:14:14,430
braintree it's also invisible and one of

00:14:12,510 --> 00:14:17,610
things also experimented this was chef

00:14:14,430 --> 00:14:19,920
need references so because of a certain

00:14:17,610 --> 00:14:21,209
alignment of objects we can gain an

00:14:19,920 --> 00:14:23,819
extra three bits

00:14:21,209 --> 00:14:27,629
and so I started to but pointers we can

00:14:23,819 --> 00:14:31,559
get about 30 gigs or dress speeds know

00:14:27,629 --> 00:14:33,209
my background as n servers and photo 2

00:14:31,559 --> 00:14:38,279
gigabytes probably sounds a bit much for

00:14:33,209 --> 00:14:40,319
mobile but we have experimented and once

00:14:38,279 --> 00:14:42,149
you've got a basic virtual machine

00:14:40,319 --> 00:14:45,660
working you also need the core libraries

00:14:42,149 --> 00:14:48,420
to work and Gavin needs to know what an

00:14:45,660 --> 00:14:50,610
object is what two three days until of

00:14:48,420 --> 00:14:53,420
that works so those needing to be some

00:14:50,610 --> 00:14:57,509
poor Qing what Claire and will gather is

00:14:53,420 --> 00:15:01,649
platform independent you well need to

00:14:57,509 --> 00:15:04,589
have the native codes converted to work

00:15:01,649 --> 00:15:08,189
too so very often what we found is that

00:15:04,589 --> 00:15:10,230
you would have a native component with

00:15:08,189 --> 00:15:12,990
some Java code and the Java code words

00:15:10,230 --> 00:15:17,069
stored a pointer to the needs of goods

00:15:12,990 --> 00:15:19,589
data structures unfortunately when this

00:15:17,069 --> 00:15:23,009
stuff was written all of these we're in

00:15:19,589 --> 00:15:24,899
Java integers so it was quite a bit of

00:15:23,009 --> 00:15:27,299
work to go through all of the core

00:15:24,899 --> 00:15:32,420
libraries to change them such as I

00:15:27,299 --> 00:15:35,220
pointed to a sexy for bed pointers and

00:15:32,420 --> 00:15:37,709
you're showing up there and as well as

00:15:35,220 --> 00:15:40,230
that was also the belt system Android

00:15:37,709 --> 00:15:42,869
itself at that point didn't know how to

00:15:40,230 --> 00:15:45,829
belt for our 64 bit so that was another

00:15:42,869 --> 00:15:48,240
piece of work that had to be done and

00:15:45,829 --> 00:15:51,240
once we heard all of that we could run

00:15:48,240 --> 00:15:59,279
our world on a 64-bit dalvik on the

00:15:51,240 --> 00:16:03,209
command line now those work that fall

00:15:59,279 --> 00:16:06,720
going from that no well there was a sexy

00:16:03,209 --> 00:16:09,179
for bed and portable seen temperature it

00:16:06,720 --> 00:16:11,490
was also the sexy for bed the arch sex

00:16:09,179 --> 00:16:14,100
before assembling temperature that

00:16:11,490 --> 00:16:17,490
they've which would be making and he was

00:16:14,100 --> 00:16:19,499
using our an interesting setup where I

00:16:17,490 --> 00:16:21,779
don't know if any of you have heard of a

00:16:19,499 --> 00:16:25,589
fix or before but it's an assembler

00:16:21,779 --> 00:16:28,259
simulator and des assembler for VR 64

00:16:25,589 --> 00:16:31,110
instructions and so what Dave was doing

00:16:28,259 --> 00:16:34,920
was I think perhaps him before I started

00:16:31,110 --> 00:16:37,620
was writing a sexy for bed

00:16:34,920 --> 00:16:43,889
the are sexy for assembler and running

00:16:37,620 --> 00:16:46,170
that in vexel on 32-bit arm so following

00:16:43,889 --> 00:16:48,380
on from Ventura DVM converted we could

00:16:46,170 --> 00:16:51,899
then start incorporating that work

00:16:48,380 --> 00:16:53,870
there's also work started to work learn

00:16:51,899 --> 00:16:57,510
to write the just-in-time compiler

00:16:53,870 --> 00:17:00,240
obviously ready platform-specific in my

00:16:57,510 --> 00:17:03,510
colleagues within a short for working on

00:17:00,240 --> 00:17:05,790
that and then it was a hard work to

00:17:03,510 --> 00:17:08,220
began which was converting the rest of

00:17:05,790 --> 00:17:11,939
the Android libraries to work one sexy

00:17:08,220 --> 00:17:14,929
for bet and this is obviously neo SP so

00:17:11,939 --> 00:17:18,329
the end result of that was we had ESP

00:17:14,929 --> 00:17:22,829
working on with only sexy for bed

00:17:18,329 --> 00:17:25,799
binaries and before that we had a

00:17:22,829 --> 00:17:28,860
November plane to 12 just dalvik runyuin

00:17:25,799 --> 00:17:33,210
landline and host than febri 2013 you

00:17:28,860 --> 00:17:38,850
had it running on models and then that

00:17:33,210 --> 00:17:41,700
was in July at USP working filling so

00:17:38,850 --> 00:17:46,880
this little story ends with dalvik is

00:17:41,700 --> 00:17:50,360
dead long live our come men october2013

00:17:46,880 --> 00:17:52,650
google announced android kitkat 4.4

00:17:50,360 --> 00:17:55,980
really high darts as an experiment for

00:17:52,650 --> 00:17:57,900
anything but worried that would the work

00:17:55,980 --> 00:18:00,990
would and what the work had light is

00:17:57,900 --> 00:18:03,240
done was actually the portugal vs PT

00:18:00,990 --> 00:18:05,820
sexy for bed and so for quite some time

00:18:03,240 --> 00:18:10,010
were doing well on top of dalvik and

00:18:05,820 --> 00:18:17,280
that was the basis of the port to Juneau

00:18:10,010 --> 00:18:20,730
so i'm going to talk about what our tez

00:18:17,280 --> 00:18:24,419
and this will be someone reference to

00:18:20,730 --> 00:18:26,610
what dalvik is and after that there will

00:18:24,419 --> 00:18:31,290
be some references and opportunity for

00:18:26,610 --> 00:18:35,580
questions so i said that was introduced

00:18:31,290 --> 00:18:39,720
in october 2013 and the first official

00:18:35,580 --> 00:18:41,760
release of it will be an android l and

00:18:39,720 --> 00:18:46,000
one of the goals of other goals for art

00:18:41,760 --> 00:18:48,430
were to have less lag better performance

00:18:46,000 --> 00:18:51,550
and to avoid having native developers

00:18:48,430 --> 00:18:54,790
have developers Orca rendering chamber

00:18:51,550 --> 00:18:56,830
rather just user they've been quite a

00:18:54,790 --> 00:18:58,990
lot of well quite some criticism if

00:18:56,830 --> 00:19:00,970
dalvik and that people are coming up

00:18:58,990 --> 00:19:02,920
with hacks to try and work frame some of

00:19:00,970 --> 00:19:05,650
the less desirable performance

00:19:02,920 --> 00:19:10,360
characteristics and I would characterize

00:19:05,650 --> 00:19:13,630
that is calling GC specifically certain

00:19:10,360 --> 00:19:16,000
times to Train hate lag or peeling

00:19:13,630 --> 00:19:18,070
objects to avoiding object allocation

00:19:16,000 --> 00:19:23,110
and ourselves not something went to

00:19:18,070 --> 00:19:25,840
directing the runtime and through 2014's

00:19:23,110 --> 00:19:29,560
work had been has been other guys buying

00:19:25,840 --> 00:19:34,750
by Google and an art also introduces

00:19:29,560 --> 00:19:37,030
saxi for base support ins Android so we

00:19:34,750 --> 00:19:38,980
were working quite closely with Google

00:19:37,030 --> 00:19:43,570
unless they've been doing the vast

00:19:38,980 --> 00:19:46,180
majority of the work to re-architect are

00:19:43,570 --> 00:19:49,900
to do sexy for a bit but we've managed

00:19:46,180 --> 00:19:52,450
to contribute the dalvik compiler

00:19:49,900 --> 00:19:54,610
components and colleague with here we've

00:19:52,450 --> 00:19:58,600
been working on on that for quite some

00:19:54,610 --> 00:20:01,360
time and working on the generic Impaler

00:19:58,600 --> 00:20:08,710
the glue doing some performance working

00:20:01,360 --> 00:20:11,070
and tweaks as well so some things in our

00:20:08,710 --> 00:20:14,260
or unchanged and something's needs

00:20:11,070 --> 00:20:19,120
emphasis which is that arts as a dalvik

00:20:14,260 --> 00:20:21,250
virtual machine previously dalvik was

00:20:19,120 --> 00:20:24,970
the name for the implementation and

00:20:21,250 --> 00:20:28,990
divert from machine but now and dalvik

00:20:24,970 --> 00:20:30,040
is also the name of the runtime both the

00:20:28,990 --> 00:20:34,080
name of the virtual machine that are

00:20:30,040 --> 00:20:36,430
implementing and I know the

00:20:34,080 --> 00:20:39,400
characteristics of a vector machine are

00:20:36,430 --> 00:20:41,760
still there there's garbage collection

00:20:39,400 --> 00:20:45,220
there's the notion of class loading

00:20:41,760 --> 00:20:47,440
object references and everything that

00:20:45,220 --> 00:20:49,500
I've mentioned before so in your lick

00:20:47,440 --> 00:20:51,610
thinking of our don't think of something

00:20:49,500 --> 00:20:57,340
substantially different from dalvik in

00:20:51,610 --> 00:20:57,700
terms of Abraham's operate to underline

00:20:57,340 --> 00:21:02,799
that

00:20:57,700 --> 00:21:06,490
is not translating Java into C or C++ it

00:21:02,799 --> 00:21:09,130
is something like that and native could

00:21:06,490 --> 00:21:10,870
does work has before there's a Jane I

00:21:09,130 --> 00:21:15,070
interface into that quad virtual would

00:21:10,870 --> 00:21:17,169
the binary so compelled for it and the

00:21:15,070 --> 00:21:20,110
collects ADT all with development tools

00:21:17,169 --> 00:21:22,870
are the same as is debugging you can

00:21:20,110 --> 00:21:26,340
sell run the dalvik VM command line on

00:21:22,870 --> 00:21:30,429
the David dalvik VM command still and

00:21:26,340 --> 00:21:36,580
that one char and as I go to nap process

00:21:30,429 --> 00:21:39,820
come on our as before and know what's

00:21:36,580 --> 00:21:42,880
changed in our I can I think I can

00:21:39,820 --> 00:21:46,210
actually capture this in a slave maybe

00:21:42,880 --> 00:21:47,649
talk to us and others you know I just

00:21:46,210 --> 00:21:49,960
from google with us today if you want to

00:21:47,649 --> 00:21:52,590
talk more about that but garbage

00:21:49,960 --> 00:21:54,429
collection has changed substantially and

00:21:52,590 --> 00:21:58,059
not lots of good work to make that

00:21:54,429 --> 00:22:01,330
pluggable which offers some interesting

00:21:58,059 --> 00:22:03,580
opportunities when thin protective

00:22:01,330 --> 00:22:06,700
curious about is with there are many

00:22:03,580 --> 00:22:11,289
many core arm processors her garbage

00:22:06,700 --> 00:22:13,480
collection will perform across lat the

00:22:11,289 --> 00:22:16,690
interpreter is no longer writing the

00:22:13,480 --> 00:22:18,490
same with C++ but the circumstances

00:22:16,690 --> 00:22:21,519
under which it should run them that will

00:22:18,490 --> 00:22:22,990
be different and the major change it's

00:22:21,519 --> 00:22:26,200
being done is the head of time

00:22:22,990 --> 00:22:28,269
compilation and I'll explain that a

00:22:26,200 --> 00:22:29,799
little bit more obviously sexy for by

00:22:28,269 --> 00:22:33,130
execution which were talking about and

00:22:29,799 --> 00:22:35,200
there's better diagnostics the GNA and

00:22:33,130 --> 00:22:39,730
two faces become we're straight to which

00:22:35,200 --> 00:22:41,950
well effects compatibility and there are

00:22:39,730 --> 00:22:44,679
some circumstances where dalvik was

00:22:41,950 --> 00:22:46,809
doing the wrong behavior and so support

00:22:44,679 --> 00:22:50,139
has been deprecated for those wrong

00:22:46,809 --> 00:22:52,419
things and otherwise bugs are to be

00:22:50,139 --> 00:22:56,769
raised and the very quick verification

00:22:52,419 --> 00:22:59,460
has changed as well also kind of into

00:22:56,769 --> 00:23:01,809
similar to each other all of that and

00:22:59,460 --> 00:23:06,549
one thing that's changed as a lifetime

00:23:01,809 --> 00:23:08,379
of the VN and before West dalvik when

00:23:06,549 --> 00:23:10,659
you're doing just insane compilation

00:23:08,379 --> 00:23:11,520
you're actually spending time doing that

00:23:10,659 --> 00:23:14,310
a trend

00:23:11,520 --> 00:23:16,860
this with the head of 10 compilation

00:23:14,310 --> 00:23:21,210
where your programs are compelled before

00:23:16,860 --> 00:23:22,800
you run that that has been that famous

00:23:21,210 --> 00:23:25,320
spend when you install program rather

00:23:22,800 --> 00:23:27,630
than you're running it another thing

00:23:25,320 --> 00:23:31,650
that's changed is that when your rent

00:23:27,630 --> 00:23:37,140
cream is initializing there's somewhat

00:23:31,650 --> 00:23:38,550
length of that now there's a failure me

00:23:37,140 --> 00:23:41,400
notice if you're looking and when they

00:23:38,550 --> 00:23:45,120
called Buddha are where part of the heap

00:23:41,400 --> 00:23:47,700
is actually stored on flash that's part

00:23:45,120 --> 00:23:49,710
of the bill to assess the flash of the

00:23:47,700 --> 00:23:53,520
boot that our players generally did not

00:23:49,710 --> 00:23:56,220
continues and as much of the heap that

00:23:53,520 --> 00:24:00,240
can be pre-initialized as there's been

00:23:56,220 --> 00:24:02,550
disabled and that's gonna break shall

00:24:00,240 --> 00:24:05,010
make about social basically that means

00:24:02,550 --> 00:24:07,290
that when you start up as I go to the

00:24:05,010 --> 00:24:10,470
first time things like java.lang.string

00:24:07,290 --> 00:24:11,400
java.lang.object and many parts of the

00:24:10,470 --> 00:24:13,260
framework could have been

00:24:11,400 --> 00:24:16,530
pre-initialized meaning that's where

00:24:13,260 --> 00:24:18,930
people have to wait for it and as I go

00:24:16,530 --> 00:24:23,160
almost where it closed before we going

00:24:18,930 --> 00:24:26,210
for that more detail and bender still

00:24:23,160 --> 00:24:26,210
works as before

00:24:32,070 --> 00:24:39,610
so threads have changed as well before

00:24:36,370 --> 00:24:42,730
there are separate stacks for the

00:24:39,610 --> 00:24:47,410
runtime and beneath of coit and that's

00:24:42,730 --> 00:24:49,630
been unified into one so having the vm

00:24:47,410 --> 00:24:52,750
interpretive compelling general frames

00:24:49,630 --> 00:24:56,530
or only things back and so you may see

00:24:52,750 --> 00:24:59,500
some differences there we've also i need

00:24:56,530 --> 00:25:02,830
some support for detecting stack

00:24:59,500 --> 00:25:04,810
overflows null pointer exceptions during

00:25:02,830 --> 00:25:07,090
wearing time rather than doing explicit

00:25:04,810 --> 00:25:09,370
checks they're handled through full hand

00:25:07,090 --> 00:25:14,380
wash and one of the things have done to

00:25:09,370 --> 00:25:17,530
improve the allocation of memory is the

00:25:14,380 --> 00:25:19,780
ability for thread to allocate memory on

00:25:17,530 --> 00:25:21,760
their own little build so they don't

00:25:19,780 --> 00:25:24,460
have to get a global heat block but just

00:25:21,760 --> 00:25:30,310
constrained in the past a quickly can

00:25:24,460 --> 00:25:34,810
allocate memory mentioned before garbage

00:25:30,310 --> 00:25:36,220
collection has changed quite a bit I'm

00:25:34,810 --> 00:25:38,380
seeing quite a bit well I'm actually

00:25:36,220 --> 00:25:40,690
well not mentioned before as they are as

00:25:38,380 --> 00:25:43,570
a almost completely new implementation

00:25:40,690 --> 00:25:46,350
will fare the dalvik VM so as a new

00:25:43,570 --> 00:25:48,700
implementation garbage collection and

00:25:46,350 --> 00:25:50,620
they've incorporated quite a number of

00:25:48,700 --> 00:25:55,660
different schemes for doing garbage

00:25:50,620 --> 00:25:58,450
collection so it's become more parallel

00:25:55,660 --> 00:26:00,640
where more threads are being used to do

00:25:58,450 --> 00:26:03,370
the work and it's concurrent as well

00:26:00,640 --> 00:26:06,760
where garbage collection occurs as

00:26:03,370 --> 00:26:08,920
you're executing the program we've also

00:26:06,760 --> 00:26:11,230
changed some things where for programs

00:26:08,920 --> 00:26:13,330
in the background that can do collection

00:26:11,230 --> 00:26:16,620
to a different algorithm which of the

00:26:13,330 --> 00:26:21,360
lashes plaintiff as more efficient and

00:26:16,620 --> 00:26:26,620
receive some of the algorithms there so

00:26:21,360 --> 00:26:29,080
arts including 64-bit support but was

00:26:26,620 --> 00:26:31,180
before we say worked read that and we

00:26:29,080 --> 00:26:33,910
didn't necessarily have legacy support

00:26:31,180 --> 00:26:35,890
from the beginning so we had I were a

00:26:33,910 --> 00:26:39,670
sexy for bed bailed on Authority

00:26:35,890 --> 00:26:43,690
bevelled and now there's a single belt

00:26:39,670 --> 00:26:45,730
for both now

00:26:43,690 --> 00:26:49,809
the impact of this is that you require

00:26:45,730 --> 00:26:51,639
32-bit and 64-bit fails and so there

00:26:49,809 --> 00:26:55,389
will be quite a bit of duplication on

00:26:51,639 --> 00:26:57,070
your machines and the diagram the right

00:26:55,389 --> 00:27:00,340
hand side you also see we've got two

00:26:57,070 --> 00:27:03,669
zygotes running these are tasks that

00:27:00,340 --> 00:27:05,769
wait to be told buying binder to launch

00:27:03,669 --> 00:27:07,210
an application for him and depending on

00:27:05,769 --> 00:27:10,799
how your application is installed and

00:27:07,210 --> 00:27:14,289
maybe go to a bet or sexy for bed and

00:27:10,799 --> 00:27:16,590
that is as before an Android only deaf

00:27:14,289 --> 00:27:19,480
and says that you have a choice of two

00:27:16,590 --> 00:27:26,919
it also means you can press references

00:27:19,480 --> 00:27:29,940
more efficiently and then wrapping up

00:27:26,919 --> 00:27:33,340
with and if bottom four gigabytes of RAM

00:27:29,940 --> 00:27:35,440
just now believe the heap is about 256

00:27:33,340 --> 00:27:38,950
megabytes so that's not going to be a

00:27:35,440 --> 00:27:41,740
problem for something and one of the

00:27:38,950 --> 00:27:44,980
things picked up from the ER sexy for

00:27:41,740 --> 00:27:47,620
architecture is the hard floor ABI so

00:27:44,980 --> 00:27:49,779
when Java methods of calling all each

00:27:47,620 --> 00:27:51,820
other methods the world pass Fulton

00:27:49,779 --> 00:27:55,419
point values and Fulton point registers

00:27:51,820 --> 00:27:58,210
and of course if you're running 64-bit

00:27:55,419 --> 00:28:01,149
native cords you have ability to Camille

00:27:58,210 --> 00:28:03,549
for a June a 64-bit libraries if your

00:28:01,149 --> 00:28:05,620
application site Tibbett libraries it

00:28:03,549 --> 00:28:10,419
will be launched by the sexy four bytes

00:28:05,620 --> 00:28:14,409
angle and renting and so the process

00:28:10,419 --> 00:28:17,289
were compelling for our as it is the

00:28:14,409 --> 00:28:18,970
same as before in left hand side so your

00:28:17,289 --> 00:28:21,789
developer all thick Java compel it to

00:28:18,970 --> 00:28:25,360
class fail and then generally add

00:28:21,789 --> 00:28:26,769
ex-felon new Kiki but when it comes to

00:28:25,360 --> 00:28:31,690
install the program rather than running

00:28:26,769 --> 00:28:34,600
dexhart the export is executed and that

00:28:31,690 --> 00:28:38,139
will generate need to throw it to the

00:28:34,600 --> 00:28:40,240
elf fail which will be put under the

00:28:38,139 --> 00:28:45,220
dalvik cache as before but under a

00:28:40,240 --> 00:28:47,769
platform specific directory and I did

00:28:45,220 --> 00:28:49,840
see a society to Burrell fail it will be

00:28:47,769 --> 00:28:53,070
our photo Bell famously out sexy for

00:28:49,840 --> 00:28:55,210
record them that you'll be interesting

00:28:53,070 --> 00:28:56,179
generally what you'll find is with these

00:28:55,210 --> 00:28:58,340
elf fails

00:28:56,179 --> 00:29:00,379
because they incorporate all the decks

00:28:58,340 --> 00:29:02,539
could there are at least the size of

00:29:00,379 --> 00:29:04,970
your decks fails but also continue

00:29:02,539 --> 00:29:08,590
native codes then typically you may be

00:29:04,970 --> 00:29:13,149
expecting to have about Tracy size of a

00:29:08,590 --> 00:29:13,149
vertex failures in your dalvik cache

00:29:14,230 --> 00:29:21,740
compilation has changed enormously they

00:29:19,129 --> 00:29:23,389
had the same compilation that have does

00:29:21,740 --> 00:29:27,470
have a compiler driver over as a choice

00:29:23,389 --> 00:29:29,840
of affair compilers the one you should

00:29:27,470 --> 00:29:32,389
take from here is the quick compiler

00:29:29,840 --> 00:29:37,309
which is what is inherited somewhat from

00:29:32,389 --> 00:29:39,799
dalvik and there's been work done to

00:29:37,309 --> 00:29:42,230
make it more platform independent so the

00:29:39,799 --> 00:29:45,499
code is far more shared between arm

00:29:42,230 --> 00:29:48,889
medtechs a physx and there are sexy for

00:29:45,499 --> 00:29:51,860
bit variants although mips64 is over

00:29:48,889 --> 00:29:53,720
working progress just now this ahead of

00:29:51,860 --> 00:29:55,909
time compilation is done it installed

00:29:53,720 --> 00:29:58,490
time so when you come to install your

00:29:55,909 --> 00:30:00,559
application when you don't want it from

00:29:58,490 --> 00:30:04,759
the Play Store it will go off and

00:30:00,559 --> 00:30:06,529
compile it and and the compromise

00:30:04,759 --> 00:30:08,179
explained to me those two have good

00:30:06,529 --> 00:30:13,909
quality they're good quality without

00:30:08,179 --> 00:30:15,919
taking too long to compare f it takes 21

00:30:13,909 --> 00:30:23,830
when you reinstall your firmware that

00:30:15,919 --> 00:30:30,409
would be steam is quite ornament so

00:30:23,830 --> 00:30:33,740
we're working on AOSP and open so when

00:30:30,409 --> 00:30:38,330
art came along and USP master about

00:30:33,740 --> 00:30:40,519
october november 2013 and Google

00:30:38,330 --> 00:30:43,070
expressed a desire to do this in the

00:30:40,519 --> 00:30:47,029
open and so we've been asked to push

00:30:43,070 --> 00:30:51,679
over patchi's and work option us peanuts

00:30:47,029 --> 00:30:54,470
that's what we did and it wasn't just as

00:30:51,679 --> 00:30:57,470
as obviously meps and in telling some of

00:30:54,470 --> 00:30:59,720
our partners were contributing and I

00:30:57,470 --> 00:31:01,490
think they're sexy for bed fortune Woods

00:30:59,720 --> 00:31:04,999
has been a bit of a proving ground for

00:31:01,490 --> 00:31:07,450
this approach and a palatal top seen mr.

00:31:04,999 --> 00:31:09,560
how well that went there

00:31:07,450 --> 00:31:11,990
these things we learned which was the

00:31:09,560 --> 00:31:14,210
ideas are a very nice and discuss but it

00:31:11,990 --> 00:31:16,190
is much better to have some good up

00:31:14,210 --> 00:31:19,370
there it gives people something to

00:31:16,190 --> 00:31:23,570
either agree where disagree or at least

00:31:19,370 --> 00:31:26,480
talk over and it's better to push your

00:31:23,570 --> 00:31:28,940
ideas out there so it's important to

00:31:26,480 --> 00:31:31,760
understand who's doing what there can be

00:31:28,940 --> 00:31:34,670
duplicated effort if you're not not not

00:31:31,760 --> 00:31:37,400
careful and so I'd suggest check into

00:31:34,670 --> 00:31:41,500
the various Google grips and Android

00:31:37,400 --> 00:31:44,450
platform is a good one to start with

00:31:41,500 --> 00:31:47,630
it's also important to check on just arm

00:31:44,450 --> 00:31:53,170
platforms check your builds on maps and

00:31:47,630 --> 00:31:56,480
x86 and fame Young yesterday very much

00:31:53,170 --> 00:32:01,460
being a good citizen is making sure

00:31:56,480 --> 00:32:03,590
everyone else is working too and this

00:32:01,460 --> 00:32:06,220
year is probably somewhat special and

00:32:03,590 --> 00:32:10,190
that the bells were very unstable

00:32:06,220 --> 00:32:12,650
changing the AOSP ecosystem to bail

00:32:10,190 --> 00:32:15,040
going sexy for bed changing

00:32:12,650 --> 00:32:17,450
fundamentally her artwork what not

00:32:15,040 --> 00:32:19,940
hopefully this will only be this when

00:32:17,450 --> 00:32:22,490
table it'll happen but it was frequently

00:32:19,940 --> 00:32:24,350
broken so you have to be careful about

00:32:22,490 --> 00:32:28,220
how you manage children repositories and

00:32:24,350 --> 00:32:30,980
in heads and you'll discover that

00:32:28,220 --> 00:32:34,490
Android is beg and the components many

00:32:30,980 --> 00:32:36,200
have many interdependencies so one of

00:32:34,490 --> 00:32:39,830
the things we did trials justice a key

00:32:36,200 --> 00:32:41,030
part of today to the Ted but some of the

00:32:39,830 --> 00:32:43,220
things that STEMI that is that are

00:32:41,030 --> 00:32:46,310
dependent lib core chef the pill webcore

00:32:43,220 --> 00:32:48,200
forward look for is quite fundamentally

00:32:46,310 --> 00:32:52,280
belt system so you have to build the

00:32:48,200 --> 00:32:53,600
Bell System forward and so you can get

00:32:52,280 --> 00:32:59,780
into knots if you're if you're not

00:32:53,600 --> 00:33:02,150
careful and the ESPYs Garrett as what

00:32:59,780 --> 00:33:07,040
you would be contributing to an ESB so

00:33:02,150 --> 00:33:09,110
it to note well we use it internally and

00:33:07,040 --> 00:33:11,780
it suggests that is a very good way of

00:33:09,110 --> 00:33:15,320
working with their work for being

00:33:11,780 --> 00:33:17,660
contributing patches up to a OSP we tend

00:33:15,320 --> 00:33:19,970
not to marriage until in Garrett but we

00:33:17,660 --> 00:33:22,640
may have too much me and so

00:33:19,970 --> 00:33:25,660
patches and airfare it disappear once

00:33:22,640 --> 00:33:30,440
they've been incorporated upstream and

00:33:25,660 --> 00:33:32,870
volume can be high when the bun Garrett

00:33:30,440 --> 00:33:36,530
so you can use the email features to

00:33:32,870 --> 00:33:38,420
receive emails and then filter anyone

00:33:36,530 --> 00:33:42,170
what particular thing you're interested

00:33:38,420 --> 00:33:44,330
in and certainly one thing's of strong

00:33:42,170 --> 00:33:48,590
encourages if you are working on our to

00:33:44,330 --> 00:33:49,760
use the the extensive unit test

00:33:48,590 --> 00:33:51,860
framework and if your fish you got

00:33:49,760 --> 00:33:57,860
patches it doesn't hurt to ask the rate

00:33:51,860 --> 00:34:02,110
of some tests as well so thank you very

00:33:57,860 --> 00:34:04,610
much for listening and there's some

00:34:02,110 --> 00:34:06,580
later sessions today I suggest that

00:34:04,610 --> 00:34:09,140
maybe interesting stuff the Lester's

00:34:06,580 --> 00:34:11,510
everything's done and of course I

00:34:09,140 --> 00:34:17,110
mentioned the 130 which so we got to

00:34:11,510 --> 00:34:17,110
this point so are there any questions

00:34:32,740 --> 00:34:37,240
test account with the head of time

00:34:35,110 --> 00:34:39,220
compiling it's there any additional

00:34:37,240 --> 00:34:41,169
optimization done at runtime when you

00:34:39,220 --> 00:34:49,720
encounter hot spots or office that

00:34:41,169 --> 00:34:51,100
basically the code you get so not to

00:34:49,720 --> 00:34:52,929
this point but a staff that owes all

00:34:51,100 --> 00:34:55,570
statically compelled their head the one

00:34:52,929 --> 00:35:01,920
thing the head or anything is there a

00:34:55,570 --> 00:35:01,920
plan to add that later what can I seen

00:35:02,250 --> 00:35:10,720
sure why not yes I understood this may

00:35:06,520 --> 00:35:13,300
be a jet and Angel birth well we'll see

00:35:10,720 --> 00:35:15,220
yeah I think one of the things is the

00:35:13,300 --> 00:35:18,400
people being told that jets are really

00:35:15,220 --> 00:35:20,560
awesome for years and years and years it

00:35:18,400 --> 00:35:22,660
was it's quite interesting seeing people

00:35:20,560 --> 00:35:23,980
say like Google has moved beyond jets

00:35:22,660 --> 00:35:25,570
and gone to ahead of time compilation

00:35:23,980 --> 00:35:29,290
also I didn't know ahead of time

00:35:25,570 --> 00:35:31,660
compilation exist before Jets mmm but um

00:35:29,290 --> 00:35:34,150
the thing with jet says you've got warm

00:35:31,660 --> 00:35:37,390
up issues you've got launch time issues

00:35:34,150 --> 00:35:39,280
and so on so what we're kind of focusing

00:35:37,390 --> 00:35:41,740
on is making sure that we have the best

00:35:39,280 --> 00:35:43,000
of both worlds so currently we're

00:35:41,740 --> 00:35:48,119
focusing on the head of time compilation

00:35:43,000 --> 00:35:48,119
of launched ambitions and so on thanks

00:35:55,210 --> 00:36:04,280
hello yeah so the hood heart what is

00:36:01,430 --> 00:36:07,490
expected gaining good time or the Dalek

00:36:04,280 --> 00:36:10,250
so you say what's expected gain good

00:36:07,490 --> 00:36:14,720
time good time again it's not something

00:36:10,250 --> 00:36:16,520
we've extensively measured part of the

00:36:14,720 --> 00:36:18,680
things we've had served on us compare

00:36:16,520 --> 00:36:20,840
recipes it exists just nervous now Rick

00:36:18,680 --> 00:36:25,690
versus where exhaust is now with our

00:36:20,840 --> 00:36:25,690
that's not something they've done a

00:36:28,810 --> 00:36:44,300
better I before the fact how much don't

00:36:34,640 --> 00:36:46,670
know so I okey I carom the numbers off

00:36:44,300 --> 00:36:48,020
the top i had that we we do continual

00:36:46,670 --> 00:36:50,690
regression testing to make sure the pre

00:36:48,020 --> 00:36:52,070
time doesn't address for the AL release

00:36:50,690 --> 00:36:54,260
we look at the book big time being about

00:36:52,070 --> 00:36:56,930
two-thirds of what it was in kick out

00:36:54,260 --> 00:36:59,980
but obviously that's on our devices now

00:36:56,930 --> 00:36:59,980
our balls and small

00:37:10,819 --> 00:37:17,190
so how can one contribute to art the gas

00:37:14,400 --> 00:37:20,369
part of unit disk development you think

00:37:17,190 --> 00:37:25,289
or how can one contribute to our

00:37:20,369 --> 00:37:28,619
development sorry I think I saw how can

00:37:25,289 --> 00:37:31,440
one contribute to art development like

00:37:28,619 --> 00:37:34,200
is it by writing unit tests or are there

00:37:31,440 --> 00:37:37,140
any like when we were working on dalvik

00:37:34,200 --> 00:37:40,410
there was lot of gaps for implementing

00:37:37,140 --> 00:37:42,569
dalvik optimizations and so on but with

00:37:40,410 --> 00:37:45,150
art looks like like a lot of

00:37:42,569 --> 00:37:48,479
implementation is already taken care do

00:37:45,150 --> 00:37:51,239
you see still see any gaps in art for in

00:37:48,479 --> 00:37:54,630
terms of optimizations or validation or

00:37:51,239 --> 00:37:57,920
something like that um where what kind

00:37:54,630 --> 00:38:02,210
of entering an optimization phase where

00:37:57,920 --> 00:38:04,619
we are kind of working for those gaps

00:38:02,210 --> 00:38:06,749
we're not really dealing with registers

00:38:04,619 --> 00:38:09,180
very well just now so that's what being

00:38:06,749 --> 00:38:12,150
done to try and allocate them more

00:38:09,180 --> 00:38:15,569
sensibly for spelling woven and we ought

00:38:12,150 --> 00:38:19,170
to there's been a fair amount of work

00:38:15,569 --> 00:38:22,200
done for having native implementations

00:38:19,170 --> 00:38:27,719
of Java would be like make sense like

00:38:22,200 --> 00:38:31,309
math libraries it's something this that

00:38:27,719 --> 00:38:31,309
we're so measuring a thing

00:38:39,269 --> 00:38:44,359
I guess the other thing that's on the

00:38:42,209 --> 00:38:48,269
horizon is the the optimizing compiler

00:38:44,359 --> 00:38:50,640
was kind of business it is it basically

00:38:48,269 --> 00:38:53,819
looks like the arm the VA's compiler

00:38:50,640 --> 00:38:56,069
this is the JavaScript v8 and the dark

00:38:53,819 --> 00:38:57,839
compiler and that's got a lot more

00:38:56,069 --> 00:39:02,369
aggressive optimization and wasn't a

00:38:57,839 --> 00:39:06,119
quick and violent yeah what if not not

00:39:02,369 --> 00:39:08,669
said as the there is s a pivot enslaved

00:39:06,119 --> 00:39:12,929
but there is work being done on an

00:39:08,669 --> 00:39:15,569
optimizing compiler and its very early

00:39:12,929 --> 00:39:19,589
stages just now and it may be something

00:39:15,569 --> 00:39:21,719
to be seen later on but I think we're

00:39:19,589 --> 00:39:32,339
just starting work on that and an arm

00:39:21,719 --> 00:39:35,189
and certainly the starting in Google but

00:39:32,339 --> 00:39:36,749
the hacking sessions chairman says I

00:39:35,189 --> 00:39:39,749
should mention the hacking sessions and

00:39:36,749 --> 00:39:42,529
we've got a couple of win over boards to

00:39:39,749 --> 00:39:42,529
have any general words

00:39:49,360 --> 00:39:56,170
hi notice that the heap size it's like a

00:39:53,460 --> 00:39:58,930
256 megabytes that does that mean that

00:39:56,170 --> 00:40:03,400
it's 64 bid enjoy will require more than

00:39:58,930 --> 00:40:06,970
one gigabyte memory to run a little

00:40:03,400 --> 00:40:11,920
warmer so that 256 megabytes eaters the

00:40:06,970 --> 00:40:14,200
heap when it quite what Android L will

00:40:11,920 --> 00:40:17,170
look like in terms of heat requirements

00:40:14,200 --> 00:40:22,570
by don't know we're very much looking at

00:40:17,170 --> 00:40:24,370
the rent Amon USP and I don't believe

00:40:22,570 --> 00:40:28,390
that we're acquiring one gigabyte is the

00:40:24,370 --> 00:40:31,870
goal was for 512 megabytes and art can

00:40:28,390 --> 00:40:36,340
be configured for small devices as well

00:40:31,870 --> 00:40:37,450
as large and we will never save you

00:40:36,340 --> 00:40:39,970
remember I'm seen these things I'm

00:40:37,450 --> 00:40:42,120
keeping an eye on Ian's face that quite

00:40:39,970 --> 00:40:42,120
right

00:40:49,140 --> 00:40:54,670
so we've been running out on you know

00:40:53,080 --> 00:40:58,240
things like wearables which have only

00:40:54,670 --> 00:41:03,280
got 128 megabytes of RAM us third the

00:40:58,240 --> 00:41:06,670
loan there's multiple and it's like the

00:41:03,280 --> 00:41:08,140
zygote model again so when you have

00:41:06,670 --> 00:41:10,510
ahead of time generated code if you've

00:41:08,140 --> 00:41:12,970
got to map it into memory so if you look

00:41:10,510 --> 00:41:14,590
at the virtual memory usage then with us

00:41:12,970 --> 00:41:18,040
you'll see that more virtual memory is

00:41:14,590 --> 00:41:20,140
being used them with dalvik however

00:41:18,040 --> 00:41:21,580
that's because we've mapped things into

00:41:20,140 --> 00:41:24,790
memory those things can be paged out

00:41:21,580 --> 00:41:26,350
again so if you look at PSS usage then

00:41:24,790 --> 00:41:28,750
you'll see that arts using more memory

00:41:26,350 --> 00:41:30,220
if you look at dirty pages then you'll

00:41:28,750 --> 00:41:32,800
see that art is using less memory than

00:41:30,220 --> 00:41:34,869
dalvik and actually in our longevity

00:41:32,800 --> 00:41:36,970
test and so my work finding that artists

00:41:34,869 --> 00:41:43,780
using less memory there's a lot with the

00:41:36,970 --> 00:41:47,020
memory requirements of Android for the

00:41:43,780 --> 00:41:48,550
64 bit then there's two zygotes and so

00:41:47,020 --> 00:41:56,020
that tends to increase the memory usage

00:41:48,550 --> 00:41:58,330
by about 100 magpies so if you if you

00:41:56,020 --> 00:42:01,410
have two zygotes then each side go ways

00:41:58,330 --> 00:42:01,410
met about 100 megabytes

00:42:08,250 --> 00:42:14,060
thank you

00:42:09,840 --> 00:42:14,060
and any other questions

00:42:18,599 --> 00:42:23,260
yep

00:42:20,480 --> 00:42:23,260

YouTube URL: https://www.youtube.com/watch?v=dR0FbB4uJC0


