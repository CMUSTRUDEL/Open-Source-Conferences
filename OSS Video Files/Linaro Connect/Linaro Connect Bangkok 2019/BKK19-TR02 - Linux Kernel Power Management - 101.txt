Title: BKK19-TR02 - Linux Kernel Power Management - 101
Publication date: 2019-04-11
Playlist: Linaro Connect Bangkok 2019
Description: 
	Abstract
A beginner overview of Linux Kernel Power and Thermal Management features. As done in previous two connects, this session will provide a brief overview of almost all major power management frameworks available today in Linux kernel. Additionally, this session also will aim to provide a brief introduction into Linux Kernel Thermal Management features.

Thara Gopinath / Engineer Linaro
Thara Gopinath is a Linux engineering working with Linaro since 2015 and her focus areas are kernel power and thermal management.
Captions: 
	00:00:05,450 --> 00:00:11,900
this is Linux kernel power management

00:00:08,120 --> 00:00:13,490
101 kind of training there was some of

00:00:11,900 --> 00:00:14,990
the concepts covered in this training

00:00:13,490 --> 00:00:17,960
was already covered in a training

00:00:14,990 --> 00:00:20,599
yesterday in more depth so some of it is

00:00:17,960 --> 00:00:22,900
just a repeat we somehow got the

00:00:20,599 --> 00:00:26,449
sessions reversed

00:00:22,900 --> 00:00:29,210
apart from that so this training is

00:00:26,449 --> 00:00:30,680
meant to be a peripheral view on lot of

00:00:29,210 --> 00:00:33,440
power management features that are

00:00:30,680 --> 00:00:35,480
available in Linux kernel today it

00:00:33,440 --> 00:00:38,570
doesn't deep dive into any of these

00:00:35,480 --> 00:00:40,940
frameworks and it is more from device

00:00:38,570 --> 00:00:43,000
driver or a device point of view on what

00:00:40,940 --> 00:00:53,420
device drivers should do to adapt to

00:00:43,000 --> 00:00:54,620
most of these frameworks okay so let's

00:00:53,420 --> 00:00:57,290
start with why do we need power

00:00:54,620 --> 00:00:59,750
management power management is needed in

00:00:57,290 --> 00:01:02,750
order to reduce energy consumption which

00:00:59,750 --> 00:01:04,400
in turn will reduce your cooling

00:01:02,750 --> 00:01:07,070
requirements which in turn will reduce

00:01:04,400 --> 00:01:08,690
heat heat dissipation which saves money

00:01:07,070 --> 00:01:10,670
which saves enviornmental

00:01:08,690 --> 00:01:14,090
impact of your system which improves

00:01:10,670 --> 00:01:16,250
system stability and in case of mobile

00:01:14,090 --> 00:01:19,250
devices or embedded devices it also

00:01:16,250 --> 00:01:20,960
gives better battery performance given

00:01:19,250 --> 00:01:22,909
all this work what is the goal of power

00:01:20,960 --> 00:01:25,280
management it is to consume as little

00:01:22,909 --> 00:01:27,229
power as possible in a given system

00:01:25,280 --> 00:01:31,070
State for a use case or for a

00:01:27,229 --> 00:01:32,990
configuration and as the associates of

00:01:31,070 --> 00:01:35,329
evolved and become more and more complex

00:01:32,990 --> 00:01:37,880
these solutions have also evolved in

00:01:35,329 --> 00:01:39,530
Linux kernel there are there are a bunch

00:01:37,880 --> 00:01:43,329
of frameworks today that existed in the

00:01:39,530 --> 00:01:43,329
kernel that deals with power management

00:01:44,049 --> 00:01:49,909
moving on power management in the kernel

00:01:46,729 --> 00:01:51,469
can be classified into two static power

00:01:49,909 --> 00:01:53,990
management versus dynamic power

00:01:51,469 --> 00:01:56,420
management so static power management is

00:01:53,990 --> 00:01:58,159
more like how to save power when a

00:01:56,420 --> 00:02:01,100
system has been inactive for long

00:01:58,159 --> 00:02:03,139
periods of time for example in case of

00:02:01,100 --> 00:02:05,090
laptop if the laptop has been idle for

00:02:03,139 --> 00:02:06,560
thirty minutes or an hour what to do

00:02:05,090 --> 00:02:09,170
with all the devices what to do with the

00:02:06,560 --> 00:02:13,489
entire system in order to maximize power

00:02:09,170 --> 00:02:16,069
saving in case of a phone it was

00:02:13,489 --> 00:02:19,129
probably pressing the power off button

00:02:16,069 --> 00:02:22,319
what what to do in that

00:02:19,129 --> 00:02:24,269
the status of the frameworks pertaining

00:02:22,319 --> 00:02:27,090
to static power management and Linux

00:02:24,269 --> 00:02:28,920
kernel is quite evolved they have been

00:02:27,090 --> 00:02:30,299
there for quite some time there are some

00:02:28,920 --> 00:02:32,519
maintenance activities still up

00:02:30,299 --> 00:02:34,799
happening on those frameworks but there

00:02:32,519 --> 00:02:38,310
is no major active development happening

00:02:34,799 --> 00:02:39,900
on those frameworks on the other hand

00:02:38,310 --> 00:02:42,150
there is a dynamic power management

00:02:39,900 --> 00:02:44,819
which deals with how to configure

00:02:42,150 --> 00:02:46,230
devices in the system when the system is

00:02:44,819 --> 00:02:49,579
in an active state when there is some

00:02:46,230 --> 00:02:52,290
use case running or when there are short

00:02:49,579 --> 00:02:56,159
pulses of inactivity between these use

00:02:52,290 --> 00:02:59,129
cases or tasks and the frameworks that

00:02:56,159 --> 00:03:00,959
deal with dynamic power management in

00:02:59,129 --> 00:03:03,209
the kernel the statement that they are

00:03:00,959 --> 00:03:05,579
still evolving as they as these systems

00:03:03,209 --> 00:03:08,010
evolve and as the complexities of the

00:03:05,579 --> 00:03:09,840
SOC sawal these frameworks are also

00:03:08,010 --> 00:03:11,459
evolving and adapting and there is quite

00:03:09,840 --> 00:03:21,359
a lot of churn happening on some of

00:03:11,459 --> 00:03:23,310
these frameworks so the static power

00:03:21,359 --> 00:03:25,109
management framework in generally in

00:03:23,310 --> 00:03:29,010
this in the Linux kernel it's known as

00:03:25,109 --> 00:03:31,799
suspend resume framework so like I

00:03:29,010 --> 00:03:35,040
mentioned it deals with what to do when

00:03:31,799 --> 00:03:37,019
the system has been inactive for a long

00:03:35,040 --> 00:03:39,629
period of time and typically the

00:03:37,019 --> 00:03:41,459
suspense is triggered on the system

00:03:39,629 --> 00:03:43,439
through a user activity like on the

00:03:41,459 --> 00:03:45,870
phone it is pressing of the button

00:03:43,439 --> 00:03:47,609
button so how it triggers when when

00:03:45,870 --> 00:03:50,099
there is a user activity you can write

00:03:47,609 --> 00:03:52,109
into this particular CFS files as power

00:03:50,099 --> 00:03:54,900
state and depending on the various

00:03:52,109 --> 00:03:56,579
values returned to it different actions

00:03:54,900 --> 00:04:00,930
are taken in the system in order to

00:03:56,579 --> 00:04:03,209
trigger the suspend framework in so

00:04:00,930 --> 00:04:05,790
there are various levels of suspend

00:04:03,209 --> 00:04:07,889
possible but generally for any kind of

00:04:05,790 --> 00:04:10,199
if a suspend framework is trigger the

00:04:07,889 --> 00:04:12,780
first things that gets done are freezing

00:04:10,199 --> 00:04:14,400
of the user space tasks suspending time

00:04:12,780 --> 00:04:17,509
keeping and putting most of the IO

00:04:14,400 --> 00:04:20,459
devices in low-power or deep idle States

00:04:17,509 --> 00:04:24,240
and then depending on the value that is

00:04:20,459 --> 00:04:26,669
written in to the CFS file various other

00:04:24,240 --> 00:04:28,560
decisions are taken so there is suspend

00:04:26,669 --> 00:04:30,110
to idle which is triggered by writing

00:04:28,560 --> 00:04:33,990
freeze into

00:04:30,110 --> 00:04:36,810
Sustaita so this is the suspense state

00:04:33,990 --> 00:04:38,760
probably with the minimal latency as in

00:04:36,810 --> 00:04:40,680
it takes the minimal amount of time to

00:04:38,760 --> 00:04:44,070
go into the state and probably to resume

00:04:40,680 --> 00:04:45,780
out of the state and in this state in

00:04:44,070 --> 00:04:49,440
addition to doing all the genrich's

00:04:45,780 --> 00:04:52,230
testa mall so puts all the CPUs into the

00:04:49,440 --> 00:04:56,610
deepest sea state possible cpu idle

00:04:52,230 --> 00:04:59,550
state possible there is power on suspend

00:04:56,610 --> 00:05:04,200
which is triggered by writing standby

00:04:59,550 --> 00:05:06,720
into this s FS file in this state in

00:05:04,200 --> 00:05:09,930
addition to doing all the generic steps

00:05:06,720 --> 00:05:13,200
all the non boot CPUs are awful taken

00:05:09,930 --> 00:05:17,100
offline and the boot cpu is put in the

00:05:13,200 --> 00:05:19,560
deepest idle state possible there is the

00:05:17,100 --> 00:05:22,800
net next suspend state that is possible

00:05:19,560 --> 00:05:30,600
as suspend to ram which is triggered by

00:05:22,800 --> 00:05:32,340
writing mem into this power state so in

00:05:30,600 --> 00:05:34,800
this state in addition to the gender

00:05:32,340 --> 00:05:38,450
except the internal memory of the system

00:05:34,800 --> 00:05:41,820
this ROM is put into self refresh the

00:05:38,450 --> 00:05:45,360
non boot CPUs are taken offline and the

00:05:41,820 --> 00:05:46,710
boot CPU is powered off and then there

00:05:45,360 --> 00:05:48,660
is this last possible stage which is

00:05:46,710 --> 00:05:50,669
called suspend to disk and it is

00:05:48,660 --> 00:05:53,070
triggered by writing disk into the

00:05:50,669 --> 00:05:55,760
surface file and it is commonly known as

00:05:53,070 --> 00:05:58,440
hibernate it is not so prevalent on the

00:05:55,760 --> 00:06:00,360
embedded devices or IOT devices it is

00:05:58,440 --> 00:06:04,440
more prevalent on desktop and laptop

00:06:00,360 --> 00:06:07,650
devices so in this case a snapshot of

00:06:04,440 --> 00:06:11,100
the system is saved into a persistent

00:06:07,650 --> 00:06:12,990
storage like a hard disk array emmc and

00:06:11,100 --> 00:06:14,790
then everything is shut down the system

00:06:12,990 --> 00:06:17,520
is powered down memories power down

00:06:14,790 --> 00:06:19,200
system is shut down the difference here

00:06:17,520 --> 00:06:24,410
is that when you wake up when you boot

00:06:19,200 --> 00:06:27,120
up at some point during the boot up the

00:06:24,410 --> 00:06:29,340
saved image is loaded back and the

00:06:27,120 --> 00:06:32,790
system starts running and from the point

00:06:29,340 --> 00:06:35,280
it got shut down from there is lot of

00:06:32,790 --> 00:06:37,979
complexity involved in it at the back

00:06:35,280 --> 00:06:40,580
end but this is what it does at the

00:06:37,979 --> 00:06:40,580
broad level

00:06:45,420 --> 00:06:52,830
okay so again so like I said so we'll go

00:06:50,760 --> 00:06:54,840
through it like depending on what device

00:06:52,830 --> 00:06:57,290
drivers are supposed to do and I don't

00:06:54,840 --> 00:07:00,330
know hey the slightest like this okay

00:06:57,290 --> 00:07:03,960
anyways so device drivers are supposed

00:07:00,330 --> 00:07:06,110
to register certain device hooks in

00:07:03,960 --> 00:07:09,750
order to trigger in order to be called

00:07:06,110 --> 00:07:14,460
during the system suspend and rescue the

00:07:09,750 --> 00:07:17,880
important ones here are the prepare to

00:07:14,460 --> 00:07:19,830
resume and the suspend so these gets

00:07:17,880 --> 00:07:21,540
these are the device specific hooks

00:07:19,830 --> 00:07:23,700
they're not platform specific works

00:07:21,540 --> 00:07:26,190
which can be which are defined as well

00:07:23,700 --> 00:07:27,990
so during the suspend sequence first a

00:07:26,190 --> 00:07:29,610
platform hooker skull which in turn will

00:07:27,990 --> 00:07:31,890
call all the device hooks that are

00:07:29,610 --> 00:07:34,050
registered and these device hooks are

00:07:31,890 --> 00:07:35,850
supposed to specify the steps that your

00:07:34,050 --> 00:07:38,190
particular device is supposed to take

00:07:35,850 --> 00:07:40,290
when you are shutting down the system

00:07:38,190 --> 00:07:50,070
and when you are assuming back the

00:07:40,290 --> 00:07:52,260
system now once the system is suspended

00:07:50,070 --> 00:07:55,200
haha how to wake up it's usually a user

00:07:52,260 --> 00:07:57,060
triggered activity like swipe on the

00:07:55,200 --> 00:07:59,340
touchscreen or a mouse event or

00:07:57,060 --> 00:08:02,280
something like that and in order to

00:07:59,340 --> 00:08:04,410
enable the wake up on your do if the

00:08:02,280 --> 00:08:05,940
device has a wake up it has this wakeup

00:08:04,410 --> 00:08:07,710
capable and it has a wake up source in

00:08:05,940 --> 00:08:09,990
order to enable it there are a few steps

00:08:07,710 --> 00:08:15,000
the device driver needs to do first is

00:08:09,990 --> 00:08:16,800
to let the p.m. framework know that the

00:08:15,000 --> 00:08:19,980
devices wakeup capable and that is

00:08:16,800 --> 00:08:22,590
through the device in it wakeup and then

00:08:19,980 --> 00:08:25,410
the next step is to enable that

00:08:22,590 --> 00:08:27,240
particular irq in the irq subsystem it's

00:08:25,410 --> 00:08:29,370
like telling the irq subsystem that I

00:08:27,240 --> 00:08:32,610
have a interrupts that'ss wake up

00:08:29,370 --> 00:08:34,290
capable so that is by enable irq wake

00:08:32,610 --> 00:08:36,870
and then there is a counterpart to it

00:08:34,290 --> 00:08:41,220
which is the disabled irq wake and once

00:08:36,870 --> 00:08:43,740
the wakeup occurs the device driver is

00:08:41,220 --> 00:08:46,080
supposed to notify the p.m. framework by

00:08:43,740 --> 00:08:47,910
a p.m. make up event that the wakeup has

00:08:46,080 --> 00:08:51,540
occurred and do whatever necessary steps

00:08:47,910 --> 00:08:53,340
need to be done apart from that these

00:08:51,540 --> 00:08:55,520
wake up's can also be enabled and

00:08:53,340 --> 00:08:57,680
disabled from the user space so there is

00:08:55,520 --> 00:08:59,570
every device has

00:08:57,680 --> 00:09:02,960
the surface entry associated with it

00:08:59,570 --> 00:09:04,820
under devices and under this node there

00:09:02,960 --> 00:09:07,220
is the prohibition to enable and disable

00:09:04,820 --> 00:09:10,610
the wake-up sources by a power wake up

00:09:07,220 --> 00:09:16,160
node so that is how you can enable and

00:09:10,610 --> 00:09:20,750
disable wake up from the user space yeah

00:09:16,160 --> 00:09:23,029
I think there is a mic somewhere does it

00:09:20,750 --> 00:09:25,070
apply for all the method you presented

00:09:23,029 --> 00:09:29,899
before I mean for free for the freeze

00:09:25,070 --> 00:09:33,260
method for the mem yes it does it does

00:09:29,899 --> 00:09:36,770
apply for freeze and mem and standby yes

00:09:33,260 --> 00:09:39,380
yes so if I freeze this method will be

00:09:36,770 --> 00:09:41,300
cold and so if you freeze yes if you

00:09:39,380 --> 00:09:44,240
have enabled I wake up on your device

00:09:41,300 --> 00:09:47,260
yes you have to enable it why are these

00:09:44,240 --> 00:09:47,260
steps yes

00:09:56,019 --> 00:10:05,559
oh not for suspended I suspend to

00:10:03,879 --> 00:10:10,449
discuss like shutting down the system

00:10:05,559 --> 00:10:12,040
yeah but yeah yeah definitely

00:10:10,449 --> 00:10:17,319
but for fries and mem and everything

00:10:12,040 --> 00:10:22,029
else yes so user space can actually

00:10:17,319 --> 00:10:25,689
disable all the devices from triggering

00:10:22,029 --> 00:10:28,089
a wake up using the surface notes user

00:10:25,689 --> 00:10:31,449
space can enable or disable the wake up

00:10:28,089 --> 00:10:33,489
so that that just tells the PM framework

00:10:31,449 --> 00:10:36,999
whether your devices wake up capable or

00:10:33,489 --> 00:10:39,429
not but then the devices internally once

00:10:36,999 --> 00:10:43,329
once this is once the command is

00:10:39,429 --> 00:10:44,980
triggered from the sisyphus the device

00:10:43,329 --> 00:10:46,989
driver has to run with a device driver

00:10:44,980 --> 00:10:48,670
has to say okay fine I'm going to go and

00:10:46,989 --> 00:10:52,410
enable or disable the particular

00:10:48,670 --> 00:10:52,410
interrupt in the interrupt framework

00:10:52,470 --> 00:10:56,189
okay yeah thank you

00:11:01,160 --> 00:11:04,700
yeah let's move

00:11:08,480 --> 00:11:13,730
yeah so we'll move on to dynamic power

00:11:11,630 --> 00:11:16,220
management so like I said it is use case

00:11:13,730 --> 00:11:17,810
based power management so the system is

00:11:16,220 --> 00:11:19,430
running some things there's a use case

00:11:17,810 --> 00:11:21,230
running there are some tasks running so

00:11:19,430 --> 00:11:23,480
how best to configure the system to

00:11:21,230 --> 00:11:27,050
achieve the maximum power savings

00:11:23,480 --> 00:11:28,930
possible there are a bunch of frameworks

00:11:27,050 --> 00:11:33,320
that deals with dynamic power management

00:11:28,930 --> 00:11:35,600
CPU frac Deverick OPP framework Gen PD

00:11:33,320 --> 00:11:37,340
framework runtime PM framework clock

00:11:35,600 --> 00:11:41,330
framework regulator framework Seville

00:11:37,340 --> 00:11:46,240
will probably do a peripheral review of

00:11:41,330 --> 00:11:46,240
some most of these frameworks at least

00:11:48,040 --> 00:11:57,590
okay so let's probe possibly start with

00:11:51,440 --> 00:11:59,420
this slide before the other slide so the

00:11:57,590 --> 00:12:01,160
dynamic power management can again be

00:11:59,420 --> 00:12:04,130
classified into active power management

00:12:01,160 --> 00:12:06,140
and idle power management so active

00:12:04,130 --> 00:12:08,090
power management is the device is

00:12:06,140 --> 00:12:10,280
actually being used in a use case so how

00:12:08,090 --> 00:12:12,650
and how best to configure the device in

00:12:10,280 --> 00:12:14,990
order to achieve the required

00:12:12,650 --> 00:12:18,950
performance with maximum power saving

00:12:14,990 --> 00:12:21,110
and then there is this concept of OPP or

00:12:18,950 --> 00:12:24,890
operating performance points there is

00:12:21,110 --> 00:12:26,690
nothing but a device can possibly

00:12:24,890 --> 00:12:28,670
operate at different frequencies and

00:12:26,690 --> 00:12:31,310
there can be different voltages

00:12:28,670 --> 00:12:33,680
associated with these frequencies so a

00:12:31,310 --> 00:12:35,720
pair of this frequency and voltage is

00:12:33,680 --> 00:12:38,150
called an operating performance point or

00:12:35,720 --> 00:12:40,100
OPP different Association a mitt

00:12:38,150 --> 00:12:44,960
differently but then in Linux kernel it

00:12:40,100 --> 00:12:48,460
is known as OPP so there can be multiple

00:12:44,960 --> 00:12:51,500
OPP 's associated with the device and

00:12:48,460 --> 00:12:53,750
these o peepees are usually defined in a

00:12:51,500 --> 00:12:56,120
device Streif on a per device basis so

00:12:53,750 --> 00:12:59,180
if you look at the DT entries for the

00:12:56,120 --> 00:13:03,410
devices that have different operating

00:12:59,180 --> 00:13:05,780
points you will see the OPP s-- defined

00:13:03,410 --> 00:13:08,630
in the device tree and this and the

00:13:05,780 --> 00:13:10,730
kernel has OPP framework which kind of

00:13:08,630 --> 00:13:12,890
deals with OPP s-- for various devices

00:13:10,730 --> 00:13:14,660
and this forms the backend for the

00:13:12,890 --> 00:13:17,900
active power management which is also

00:13:14,660 --> 00:13:20,560
called devfs or dynamic voltage and

00:13:17,900 --> 00:13:22,150
frequency scaling

00:13:20,560 --> 00:13:23,380
the dynamic voltage and so the idea

00:13:22,150 --> 00:13:28,570
behind dynamic voltage and frequency

00:13:23,380 --> 00:13:31,450
scaling is a device need not probably

00:13:28,570 --> 00:13:32,710
operate at the a device can operate at

00:13:31,450 --> 00:13:35,590
different frequencies and a device

00:13:32,710 --> 00:13:38,950
probably need not operate at the highest

00:13:35,590 --> 00:13:42,339
frequency always even when it is

00:13:38,950 --> 00:13:44,110
participating in our use case in order

00:13:42,339 --> 00:13:46,240
to meet the performance requirement it

00:13:44,110 --> 00:13:47,890
probably need not operate at the highest

00:13:46,240 --> 00:13:50,040
frequency it can operate at a lower

00:13:47,890 --> 00:13:53,020
frequency which in turn means that the

00:13:50,040 --> 00:13:57,540
voltage can also be lowered and which is

00:13:53,020 --> 00:13:57,540
what typically gives the power saving

00:13:58,170 --> 00:14:08,230
so the CPU Frek is the framework that

00:14:03,640 --> 00:14:10,600
deals with devfs for CPUs and the idea

00:14:08,230 --> 00:14:13,150
is to select the best opie piece for a

00:14:10,600 --> 00:14:15,310
CPU depending on based on constraints

00:14:13,150 --> 00:14:16,990
and requirements and the entity that

00:14:15,310 --> 00:14:19,779
provides these constraints and

00:14:16,990 --> 00:14:21,490
requirements as known as a governor the

00:14:19,779 --> 00:14:24,160
governor based on a set of criteria

00:14:21,490 --> 00:14:25,990
decides which OPP are operating

00:14:24,160 --> 00:14:29,770
performance point a CPU should be put

00:14:25,990 --> 00:14:35,200
into there are a bunch of Governors that

00:14:29,770 --> 00:14:37,839
already exist in the kernel today so

00:14:35,200 --> 00:14:40,930
there is a performance governor which

00:14:37,839 --> 00:14:42,760
always - mmm puts performance ahead and

00:14:40,930 --> 00:14:45,550
always chooses an OPP which gives the

00:14:42,760 --> 00:14:48,070
maximum performance there is power safe

00:14:45,550 --> 00:14:50,200
governor which puts whose criteria is

00:14:48,070 --> 00:14:53,620
saving power and always chooses an OPP

00:14:50,200 --> 00:14:55,270
that maximizes power saving apart from

00:14:53,620 --> 00:14:57,610
that there is user space governor which

00:14:55,270 --> 00:15:02,320
allows for OPP s to be dictated from the

00:14:57,610 --> 00:15:06,280
user space there is on demand governor

00:15:02,320 --> 00:15:07,750
breeches which was probably used as them

00:15:06,280 --> 00:15:12,459
which was the most commonly used

00:15:07,750 --> 00:15:16,959
governor till some years ago and the

00:15:12,459 --> 00:15:19,570
idea here there is to look at the load

00:15:16,959 --> 00:15:21,459
of a CPU for deciding the operating

00:15:19,570 --> 00:15:23,410
performance point of the CPU so

00:15:21,459 --> 00:15:25,300
depending on the load the OPP s are

00:15:23,410 --> 00:15:29,200
scaled up or scaled out in a stepwise

00:15:25,300 --> 00:15:32,980
fashion it also gives a lot of knobs to

00:15:29,200 --> 00:15:34,280
control how to step the OPP sup and step

00:15:32,980 --> 00:15:36,980
the opah piece down

00:15:34,280 --> 00:15:41,180
and how offered to look at the load and

00:15:36,980 --> 00:15:44,240
stuff like that finally there is shed

00:15:41,180 --> 00:15:46,040
util which is more recent development

00:15:44,240 --> 00:15:49,730
and shed utilize the governor today used

00:15:46,040 --> 00:15:51,140
in most of the ARM based systems at

00:15:49,730 --> 00:15:54,290
least we try to use it in most of the

00:15:51,140 --> 00:15:57,620
ARM based systems and the idea why it

00:15:54,290 --> 00:16:01,190
was developed was if cpu load is the

00:15:57,620 --> 00:16:03,080
criteria for dictating the opp of a cpu

00:16:01,190 --> 00:16:07,670
the best place to do that is probably

00:16:03,080 --> 00:16:09,890
the scheduler and then so scheduler

00:16:07,670 --> 00:16:11,780
shady Hotel considers the scheduler load

00:16:09,890 --> 00:16:16,850
and several other parameters and then

00:16:11,780 --> 00:16:19,340
chooses the OPP for a CPU regarding CPU

00:16:16,850 --> 00:16:22,880
fret driver every platform can define a

00:16:19,340 --> 00:16:25,460
driver for these foster the labeling CPU

00:16:22,880 --> 00:16:29,290
flag but most of the ARM based platforms

00:16:25,460 --> 00:16:36,470
today use the driver CPU frak - DT dot C

00:16:29,290 --> 00:16:38,780
to trigger the CPU frick and similar to

00:16:36,470 --> 00:16:43,370
CPU flag there is dev rack which is

00:16:38,780 --> 00:16:46,460
devfs for devices and which allows to

00:16:43,370 --> 00:16:48,080
select the best OPP for devices based on

00:16:46,460 --> 00:16:50,420
certain constraints and requirements

00:16:48,080 --> 00:16:52,550
that comes from again governor's and

00:16:50,420 --> 00:16:55,190
there are governor's again for Derek

00:16:52,550 --> 00:16:58,960
like on demand and performance and power

00:16:55,190 --> 00:17:02,530
C it's a very similar concept associated

00:16:58,960 --> 00:17:02,530
for devices

00:17:07,660 --> 00:17:14,740
okay we did this

00:17:17,000 --> 00:17:22,819
yes so moving on to the idle power

00:17:20,539 --> 00:17:24,939
management part of dynamic p.m. so here

00:17:22,819 --> 00:17:27,949
the like I mentioned the idling there is

00:17:24,939 --> 00:17:29,630
caters to periodic idling between tasks

00:17:27,949 --> 00:17:31,610
and the range of the idle period is

00:17:29,630 --> 00:17:33,860
probably milliseconds of microseconds

00:17:31,610 --> 00:17:35,659
rather than seconds and minutes so your

00:17:33,860 --> 00:17:38,330
use case is running a task is running on

00:17:35,659 --> 00:17:41,000
a CPU and there is in between short

00:17:38,330 --> 00:17:43,100
bursts of idle and what to do in these

00:17:41,000 --> 00:17:46,340
short bursts with the devices with the

00:17:43,100 --> 00:17:48,980
system in general and the frameworks the

00:17:46,340 --> 00:17:51,650
CPU idle deals with idling of CPUs and

00:17:48,980 --> 00:17:53,780
in order to deal with device idle there

00:17:51,650 --> 00:17:57,169
are frame the frameworks are runtime

00:17:53,780 --> 00:17:59,600
p.m. and Gen PD so we probably covered a

00:17:57,169 --> 00:18:01,940
bit of we probably covered a lot of

00:17:59,600 --> 00:18:04,940
runtime p.m. and generate power domain

00:18:01,940 --> 00:18:15,289
yesterday so I'll probably just run

00:18:04,940 --> 00:18:19,220
through it today so CPU idle were works

00:18:15,289 --> 00:18:22,549
on this concept of C state or CPU idle

00:18:19,220 --> 00:18:25,159
State it is a CPI term so there are

00:18:22,549 --> 00:18:28,549
different idle States possible for a CPU

00:18:25,159 --> 00:18:31,490
and the deeper or C status more is the

00:18:28,549 --> 00:18:33,559
power saving but more is also the but

00:18:31,490 --> 00:18:35,270
there is also a bigger latency

00:18:33,559 --> 00:18:37,870
associated with entering into that

00:18:35,270 --> 00:18:41,299
particular state and getting out of that

00:18:37,870 --> 00:18:45,740
particular state there can be multiple

00:18:41,299 --> 00:18:48,409
idle states associated with a CPU and

00:18:45,740 --> 00:18:50,480
these idle states are usually defined in

00:18:48,409 --> 00:18:55,100
the device tree so what you see there on

00:18:50,480 --> 00:18:58,520
the left is an idle state entry on the

00:18:55,100 --> 00:19:02,510
device from the device tree so each CPU

00:18:58,520 --> 00:19:05,000
can have multiple idle States associated

00:19:02,510 --> 00:19:08,390
with it the important entries to notice

00:19:05,000 --> 00:19:10,940
here are the entry latency exit latency

00:19:08,390 --> 00:19:14,330
and the minimum residency so entry

00:19:10,940 --> 00:19:16,490
latency is the latency involved in

00:19:14,330 --> 00:19:20,659
triggering or entering into that

00:19:16,490 --> 00:19:22,850
particular CPU idle state exit latency

00:19:20,659 --> 00:19:25,390
is probably the latency associated with

00:19:22,850 --> 00:19:29,460
coming out of that idle State and

00:19:25,390 --> 00:19:32,670
restarting regular functioning

00:19:29,460 --> 00:19:34,890
and now considering that there is a cost

00:19:32,670 --> 00:19:39,390
or a latency associated with entering

00:19:34,890 --> 00:19:41,970
and exiting out of sea State it probably

00:19:39,390 --> 00:19:45,750
doesn't make sense to enter a sea state

00:19:41,970 --> 00:19:47,430
unless you are sure that you can remain

00:19:45,750 --> 00:19:49,860
in that particular sea state for a

00:19:47,430 --> 00:19:52,050
certain duration of time and that

00:19:49,860 --> 00:20:00,690
duration is defined as the minimum

00:19:52,050 --> 00:20:03,600
residency again there are governors to

00:20:00,690 --> 00:20:05,400
chew on which decide how to choose these

00:20:03,600 --> 00:20:07,950
particular sea States we'll talk a bit

00:20:05,400 --> 00:20:11,190
about them in the next slide and they

00:20:07,950 --> 00:20:16,140
aid in choosing the CPU idle States for

00:20:11,190 --> 00:20:20,490
the CPUs and the every platform can

00:20:16,140 --> 00:20:22,890
specify a driver to aid with to define

00:20:20,490 --> 00:20:25,950
and to pull the CPU idle States from the

00:20:22,890 --> 00:20:29,040
device tree and to do all the

00:20:25,950 --> 00:20:31,500
bookkeeping work but then all the driver

00:20:29,040 --> 00:20:33,870
that is used on the arm devices to on

00:20:31,500 --> 00:20:47,580
most of the UM devices today as CPU idle

00:20:33,870 --> 00:20:49,980
- arm dot see yes latency dependent on

00:20:47,580 --> 00:20:54,240
the clocks of the CPU or the device

00:20:49,980 --> 00:21:03,110
whatever defining right so if you have

00:20:54,240 --> 00:21:03,110
like one gigahertz CPU currently seconds

00:21:06,260 --> 00:21:11,340
not just only it does not relate it to

00:21:08,940 --> 00:21:13,920
clock per se it is more related to what

00:21:11,340 --> 00:21:18,860
all needs to be done to get into that

00:21:13,920 --> 00:21:22,320
particular yes it is not just clock yes

00:21:18,860 --> 00:21:25,290
yeah it is not just clock it is not a

00:21:22,320 --> 00:21:27,720
lot of other parameters associated but

00:21:25,290 --> 00:21:35,000
its measured right I mean once you you

00:21:27,720 --> 00:21:35,000
define you yes yes that is yes yes

00:21:39,610 --> 00:21:44,660
so I'm wondering why the minimum

00:21:42,530 --> 00:21:47,780
residency can't be calculated just based

00:21:44,660 --> 00:21:49,880
on entry and exit latency so we know the

00:21:47,780 --> 00:21:51,560
entry latency you know the exit latency

00:21:49,880 --> 00:21:53,390
we know how much time it will take to

00:21:51,560 --> 00:21:55,490
get into LLC didn't come out of it

00:21:53,390 --> 00:22:04,070
can't we calculate the minimum residency

00:21:55,490 --> 00:22:06,980
out of it why because it's in it relies

00:22:04,070 --> 00:22:09,920
on the previous idle state it's a

00:22:06,980 --> 00:22:14,300
trade-off between the the cost to enter

00:22:09,920 --> 00:22:16,960
and exit the state and the cost of the

00:22:14,300 --> 00:22:21,410
authorizer state so it's an equation

00:22:16,960 --> 00:22:24,950
where you measure the time remaining in

00:22:21,410 --> 00:22:28,310
this state so I mean you you can be on

00:22:24,950 --> 00:22:30,680
the previous idle state and and consume

00:22:28,310 --> 00:22:35,180
more energy than this state there is a

00:22:30,680 --> 00:22:37,180
trade off so it's a figure what you have

00:22:35,180 --> 00:22:38,770
[Music]

00:22:37,180 --> 00:22:41,240
sorry

00:22:38,770 --> 00:22:44,540
yes you have to break-even point where

00:22:41,240 --> 00:22:48,050
you have the idle state of the previous

00:22:44,540 --> 00:22:58,940
state so you save less energy but you

00:22:48,050 --> 00:23:04,460
take less energy to enter so the the

00:22:58,940 --> 00:23:08,810
slope is lower than the other OPP and

00:23:04,460 --> 00:23:11,990
then the other OPP is as a cost which is

00:23:08,810 --> 00:23:15,320
higher but you save much more energy so

00:23:11,990 --> 00:23:19,190
the slope is even more flat so at the

00:23:15,320 --> 00:23:21,980
end both will reach a point when you

00:23:19,190 --> 00:23:27,920
have this point is the break-even and it

00:23:21,980 --> 00:23:30,830
eats the target residency it's you have

00:23:27,920 --> 00:23:38,720
to see the mat and it's in the wiki page

00:23:30,830 --> 00:23:41,930
of the poem no I think it took two days

00:23:38,720 --> 00:23:44,170
to compute a target residency for one

00:23:41,930 --> 00:23:44,170
state

00:23:57,410 --> 00:24:05,730
the minimum residency said the cpu idle

00:24:02,880 --> 00:24:08,310
driver uses it this residency the

00:24:05,730 --> 00:24:11,850
governor's uses residency to choose the

00:24:08,310 --> 00:24:14,370
next possible idle state it considers

00:24:11,850 --> 00:24:17,040
these values when when making that

00:24:14,370 --> 00:24:22,220
decision well I'll probably it's

00:24:17,040 --> 00:24:22,220
probably slide on what the governor's do

00:24:22,640 --> 00:24:28,500
it history is considered but there are

00:24:26,760 --> 00:24:30,600
other considerations like whether any

00:24:28,500 --> 00:24:32,700
device has placed a limitation saying

00:24:30,600 --> 00:24:37,400
that I need this latency requirement

00:24:32,700 --> 00:24:40,950
from the CPU like C and I also considers

00:24:37,400 --> 00:24:45,720
the next timer event and events like

00:24:40,950 --> 00:24:49,290
that before making that decision so like

00:24:45,720 --> 00:24:51,210
I said the entity that makes the M that

00:24:49,290 --> 00:24:54,630
has the algorithm that takes the

00:24:51,210 --> 00:24:56,550
decision on which C state to choose next

00:24:54,630 --> 00:24:58,410
is called a governor there are there is

00:24:56,550 --> 00:25:00,780
a menu governor there is ladder governor

00:24:58,410 --> 00:25:03,150
which is typically not used and there is

00:25:00,780 --> 00:25:06,240
this new governor that has been

00:25:03,150 --> 00:25:08,460
introduced in 5.1 called timer events

00:25:06,240 --> 00:25:11,760
oriented governor does developed by

00:25:08,460 --> 00:25:14,520
Intel I do but I don't think it does it

00:25:11,760 --> 00:25:18,300
is more exceed six based an ARM based

00:25:14,520 --> 00:25:27,390
Daniel have you tested that out have you

00:25:18,300 --> 00:25:30,750
tested tol turned on platform yes no and

00:25:27,390 --> 00:25:35,580
it actually does a lot of prediction but

00:25:30,750 --> 00:25:39,060
it's very it's using shallow shallow

00:25:35,580 --> 00:25:41,760
state so you have a big improvement in

00:25:39,060 --> 00:25:46,110
terms of performances but also you have

00:25:41,760 --> 00:25:50,280
an important energy drop so for mobile

00:25:46,110 --> 00:25:52,680
we I mean it's it's better for yes for

00:25:50,280 --> 00:25:55,330
desktop and server it's okay but for

00:25:52,680 --> 00:25:59,750
mobile it does not suite well

00:25:55,330 --> 00:26:01,190
makes sense so the frequently use so

00:25:59,750 --> 00:26:03,380
today the frequently used Governor on

00:26:01,190 --> 00:26:05,720
arm systems is called my new governor it

00:26:03,380 --> 00:26:07,730
chooses the sea state to enter based on

00:26:05,720 --> 00:26:10,580
a few criteria so the one is like I said

00:26:07,730 --> 00:26:13,100
the latency limitations so that there is

00:26:10,580 --> 00:26:15,770
this framework and kernel called quality

00:26:13,100 --> 00:26:18,980
of service framework that allows devices

00:26:15,770 --> 00:26:21,440
to stipulate that I need a particular

00:26:18,980 --> 00:26:24,410
performance or a particular I have a

00:26:21,440 --> 00:26:26,990
particular latency limitation on a CPU

00:26:24,410 --> 00:26:28,820
so it considers that and compares it

00:26:26,990 --> 00:26:31,310
with the exit time and the entry time

00:26:28,820 --> 00:26:34,610
and minimum residency before choosing a

00:26:31,310 --> 00:26:36,680
sea state the governor also considers

00:26:34,610 --> 00:26:40,880
the next predictable event which are

00:26:36,680 --> 00:26:45,890
typically timer events in the system the

00:26:40,880 --> 00:26:48,200
idea is that let I know that an event is

00:26:45,890 --> 00:26:50,690
going to occur after let's say at a

00:26:48,200 --> 00:26:53,090
certain duration there is no point in

00:26:50,690 --> 00:26:55,940
choosing an idle state whose minimum

00:26:53,090 --> 00:26:57,560
residency is more than that particular

00:26:55,940 --> 00:26:59,390
idle state because I'm anyway going to

00:26:57,560 --> 00:27:02,180
come out of it and whatever power-saving

00:26:59,390 --> 00:27:06,050
I get out of going into that idle state

00:27:02,180 --> 00:27:09,230
is kind of lost so hmm

00:27:06,050 --> 00:27:10,970
and then there is it considers the CPU

00:27:09,230 --> 00:27:13,550
load and there are some magic

00:27:10,970 --> 00:27:16,130
multipliers involved which kind of

00:27:13,550 --> 00:27:20,030
dictates that okay if the CPU load has

00:27:16,130 --> 00:27:24,700
been high previously choose a shallower

00:27:20,030 --> 00:27:28,910
sea state if the CPU load has been low

00:27:24,700 --> 00:27:33,380
previously choose a deeper sea state and

00:27:28,910 --> 00:27:35,090
there is so in order to improve those

00:27:33,380 --> 00:27:36,620
features there is something called irq

00:27:35,090 --> 00:27:40,490
prediction that is currently being

00:27:36,620 --> 00:27:44,150
developed where the idea is to instead

00:27:40,490 --> 00:27:46,850
of predicting the CPU load to predict

00:27:44,150 --> 00:27:48,380
the next interrupts event the next IO

00:27:46,850 --> 00:27:52,520
interrupts or the interrupts event from

00:27:48,380 --> 00:27:57,250
a device and to use that in order to

00:27:52,520 --> 00:27:57,250
maintains for to choose a sea state

00:28:01,590 --> 00:28:04,590
okay

00:28:09,200 --> 00:28:17,150
okay so moving on there is device ID a

00:28:15,050 --> 00:28:20,300
device ID oh so it's it's different from

00:28:17,150 --> 00:28:22,430
the device suspend that happened during

00:28:20,300 --> 00:28:25,340
static power management this is only a

00:28:22,430 --> 00:28:26,600
power device idle it is driven from the

00:28:25,340 --> 00:28:29,150
device driver

00:28:26,600 --> 00:28:32,180
the idea being the device driver is the

00:28:29,150 --> 00:28:34,400
best entity to know when to idle a

00:28:32,180 --> 00:28:37,010
device and when to make a device active

00:28:34,400 --> 00:28:41,570
it does not regard from user space like

00:28:37,010 --> 00:28:43,370
unlike suspend there is no but no

00:28:41,570 --> 00:28:44,870
dependency is taken care of except for

00:28:43,370 --> 00:28:46,940
the parent-child dependency that is

00:28:44,870 --> 00:28:48,620
existing in the device driver module or

00:28:46,940 --> 00:28:51,980
in the device tree that gets taken care

00:28:48,620 --> 00:28:55,190
of but nothing else and there is no user

00:28:51,980 --> 00:28:57,950
space fee screen you use a task freezing

00:28:55,190 --> 00:29:00,440
on time keeping freezing or any of that

00:28:57,950 --> 00:29:13,760
stuff it is just idling of a particular

00:29:00,440 --> 00:29:15,080
device and that's it yeah so so the

00:29:13,760 --> 00:29:16,490
framework that came one of the

00:29:15,080 --> 00:29:21,290
frameworks that caters to it is called

00:29:16,490 --> 00:29:23,600
run time p.m. framework so again we go

00:29:21,290 --> 00:29:25,730
back to that dev PM op structure that is

00:29:23,600 --> 00:29:28,010
that I showed you for suspend and the

00:29:25,730 --> 00:29:30,320
device driver or suppose the device

00:29:28,010 --> 00:29:33,530
drivers are supposed to register hooks

00:29:30,320 --> 00:29:36,860
that that needs to be that gets called

00:29:33,530 --> 00:29:40,310
when a device idle is triggered the main

00:29:36,860 --> 00:29:44,150
hooks are runtime suspend runtime resume

00:29:40,310 --> 00:29:47,210
and runtime idle and once that gets done

00:29:44,150 --> 00:29:50,570
whenever the device has to be active the

00:29:47,210 --> 00:29:52,760
device is supposed to trigger it by a PM

00:29:50,570 --> 00:29:54,980
runtime get which issues the command to

00:29:52,760 --> 00:29:58,880
the runtime PM framework and which in

00:29:54,980 --> 00:30:00,620
turn will call the runtime resume hook

00:29:58,880 --> 00:30:03,800
that has been registered by the device

00:30:00,620 --> 00:30:06,230
driver and in order to be idle the

00:30:03,800 --> 00:30:08,510
device is supposed to call runtime PM

00:30:06,230 --> 00:30:15,020
runtime put or preempted runtime put

00:30:08,510 --> 00:30:19,370
sync or PM runtime put auto suspend so

00:30:15,020 --> 00:30:22,130
the runtime PM framework internally uses

00:30:19,370 --> 00:30:22,730
a use count based mechanism it maintains

00:30:22,130 --> 00:30:27,679
are you

00:30:22,730 --> 00:30:29,780
counter on a per device basis and the

00:30:27,679 --> 00:30:32,240
idea is that when the u.s. count is zero

00:30:29,780 --> 00:30:34,100
it means that there are no more requests

00:30:32,240 --> 00:30:36,650
for the device to be active so I go

00:30:34,100 --> 00:30:38,420
ahead and call thee surely this is it's

00:30:36,650 --> 00:30:40,330
not run time suspend I go ahead and call

00:30:38,420 --> 00:30:42,890
the run time idle which in turn

00:30:40,330 --> 00:30:45,020
sometimes called the run time suspend to

00:30:42,890 --> 00:30:48,559
suspend the device but based on a

00:30:45,020 --> 00:30:50,720
certain criteria and once the run time

00:30:48,559 --> 00:30:53,150
suspend us called the device is supposed

00:30:50,720 --> 00:30:55,730
to populate their necessary context save

00:30:53,150 --> 00:30:59,809
and in enable wake-ups and all that in

00:30:55,730 --> 00:31:02,570
the run time suspend hooks and similarly

00:30:59,809 --> 00:31:04,520
when the use count becomes one it means

00:31:02,570 --> 00:31:08,000
that there was a request for the device

00:31:04,520 --> 00:31:09,770
to be active so trigger the runtime

00:31:08,000 --> 00:31:11,570
resume of the device which is supposed

00:31:09,770 --> 00:31:14,419
to restore context and do any other

00:31:11,570 --> 00:31:16,600
bookkeeping required to restore the

00:31:14,419 --> 00:31:16,600
device

00:31:27,580 --> 00:31:36,830
so moving on there is the generic power

00:31:32,150 --> 00:31:39,800
domain framework so in hardware devices

00:31:36,830 --> 00:31:44,930
can be grouped into power domains

00:31:39,800 --> 00:31:47,240
depending on devices that can be power

00:31:44,930 --> 00:31:50,060
gated together can be grouped into power

00:31:47,240 --> 00:31:51,950
domains and then in software the power

00:31:50,060 --> 00:31:53,740
generate power domain framework kind of

00:31:51,950 --> 00:31:58,910
gives a logical grouping for these

00:31:53,740 --> 00:32:01,070
devices it is based on runtime PM there

00:31:58,910 --> 00:32:04,790
is nothing per se that devices are

00:32:01,070 --> 00:32:08,060
supposed to do except hook into runtime

00:32:04,790 --> 00:32:11,710
PM properly using the other reducing

00:32:08,060 --> 00:32:13,910
these hooks that was mentioned before

00:32:11,710 --> 00:32:15,920
but on the other hand from a platform

00:32:13,910 --> 00:32:18,950
point of view the platform is supposed

00:32:15,920 --> 00:32:20,450
to define the power domains and from a

00:32:18,950 --> 00:32:23,690
device point of view the device is

00:32:20,450 --> 00:32:25,910
supposed to define which power domains

00:32:23,690 --> 00:32:28,640
it belong to in the device tree so that

00:32:25,910 --> 00:32:31,520
is what you see on the left so the first

00:32:28,640 --> 00:32:35,960
one is a power domain definition and the

00:32:31,520 --> 00:32:39,280
second block is a device subscribing to

00:32:35,960 --> 00:32:39,280
that particular power domain

00:32:45,750 --> 00:32:49,360
the generic question what about user

00:32:48,250 --> 00:32:52,060
space drivers

00:32:49,360 --> 00:32:56,170
is there someone framework to enable all

00:32:52,060 --> 00:33:06,730
this device driver p.m. for user space

00:32:56,170 --> 00:33:09,640
drivers audience because yeah I think

00:33:06,730 --> 00:33:11,260
modules can yeah

00:33:09,640 --> 00:33:32,230
like user space drivers do you want to

00:33:11,260 --> 00:33:49,840
do someone let's say unique button

00:33:32,230 --> 00:33:53,710
kernel modules can always what happens

00:33:49,840 --> 00:33:56,800
if a driver device which is part of the

00:33:53,710 --> 00:34:00,240
poorer domain as a driver that does not

00:33:56,800 --> 00:34:03,760
define the runtime p.m. callback does it

00:34:00,240 --> 00:34:10,720
stuck the touches make impossible to to

00:34:03,760 --> 00:34:12,460
go to suspend it it depends it really

00:34:10,720 --> 00:34:14,020
depends on what happens if that's if

00:34:12,460 --> 00:34:16,030
whether it's a standalone device and

00:34:14,020 --> 00:34:20,200
that like for example it says there are

00:34:16,030 --> 00:34:21,730
two devices and registered which belongs

00:34:20,200 --> 00:34:23,530
to a power domain in the hardware and

00:34:21,730 --> 00:34:25,210
one of them subscribes to one of them

00:34:23,530 --> 00:34:26,530
has to define the power domain and has

00:34:25,210 --> 00:34:29,200
done everything correct and there is a

00:34:26,530 --> 00:34:31,389
runtime framework for it and everything

00:34:29,200 --> 00:34:33,220
and the second one does not so it is

00:34:31,389 --> 00:34:37,270
quite possible that when the second one

00:34:33,220 --> 00:34:40,240
has requested for or is active the PM

00:34:37,270 --> 00:34:44,409
framework goes and puts the power domain

00:34:40,240 --> 00:34:47,010
into suspend returns shuts down the

00:34:44,409 --> 00:34:47,010
power domain

00:34:47,750 --> 00:34:52,310
it is it is again based on ref account

00:34:50,089 --> 00:35:04,220
so he the framework doesn't know there

00:34:52,310 --> 00:35:07,369
is a second ref count if if one of the

00:35:04,220 --> 00:35:19,430
driver if does not implement one time

00:35:07,369 --> 00:35:21,020
p.m. call yeah it is all get disabled if

00:35:19,430 --> 00:35:23,990
there is another device that has

00:35:21,020 --> 00:35:26,410
registered as a device in that power

00:35:23,990 --> 00:35:26,410
domain

00:35:50,940 --> 00:35:56,000
get everything okay yeah

00:36:00,030 --> 00:36:04,300
okay so again device drivers Percy

00:36:02,800 --> 00:36:07,060
doesn't have to do anything but then the

00:36:04,300 --> 00:36:10,180
platform has to register all the power

00:36:07,060 --> 00:36:11,680
domains that are present from pull it

00:36:10,180 --> 00:36:14,620
out of the device tree and register them

00:36:11,680 --> 00:36:18,220
using PM gen pd in it and a platform is

00:36:14,620 --> 00:36:20,470
supposed to define power of power and

00:36:18,220 --> 00:36:23,260
power on hooks in order to power off and

00:36:20,470 --> 00:36:25,540
power on a generic power domain and

00:36:23,260 --> 00:36:29,740
we'll talk about set performance state

00:36:25,540 --> 00:36:32,820
hook a little later so yeah so like I

00:36:29,740 --> 00:36:40,210
mentioned it's based on runtime PM and

00:36:32,820 --> 00:36:42,250
use you use counter so they are idea is

00:36:40,210 --> 00:36:44,680
when all the devices in a particular

00:36:42,250 --> 00:36:46,450
domain our runtime suspended the runtime

00:36:44,680 --> 00:36:48,880
framework knows that all the devices are

00:36:46,450 --> 00:36:51,340
suspended so he the framework in turn

00:36:48,880 --> 00:36:53,290
goes and triggers the generate power

00:36:51,340 --> 00:36:54,580
domain framework to power off that

00:36:53,290 --> 00:36:57,910
particular power domain

00:36:54,580 --> 00:37:00,310
similarly if a single device that is we

00:36:57,910 --> 00:37:04,560
in the power domain request to be

00:37:00,310 --> 00:37:07,300
runtime resumed the framework knows that

00:37:04,560 --> 00:37:10,060
the power domain also needs to be turned

00:37:07,300 --> 00:37:13,150
on and the frame runtime framework

00:37:10,060 --> 00:37:16,630
issues the command to turn on the power

00:37:13,150 --> 00:37:18,310
domain and these calls of into power on

00:37:16,630 --> 00:37:20,470
and power off comes into the platform

00:37:18,310 --> 00:37:22,510
specific power on and power off which

00:37:20,470 --> 00:37:24,340
was registered here and that is where

00:37:22,510 --> 00:37:25,900
the platform-specific code recites and

00:37:24,340 --> 00:37:27,790
whatever your platform needs to do to

00:37:25,900 --> 00:37:33,910
turn on and turn off the power power

00:37:27,790 --> 00:37:35,830
domi needs to be done there okay said

00:37:33,910 --> 00:37:37,840
this this is kind of confusing because

00:37:35,830 --> 00:37:39,640
this deal still at this point at all

00:37:37,840 --> 00:37:42,700
deals with idling of the power domains

00:37:39,640 --> 00:37:45,130
but apart from this a power domain even

00:37:42,700 --> 00:37:47,710
when active can have different levels of

00:37:45,130 --> 00:37:49,900
operation it could be different clock

00:37:47,710 --> 00:37:51,900
levels of operation where different

00:37:49,900 --> 00:37:54,820
frequencies in which it can run it and

00:37:51,900 --> 00:37:57,400
stuff like that so in order to deal with

00:37:54,820 --> 00:38:00,690
that there is something called def PM

00:37:57,400 --> 00:38:03,850
gen pd set performance state that allows

00:38:00,690 --> 00:38:07,120
performance state or a level at which

00:38:03,850 --> 00:38:10,780
the power domain has to perform have to

00:38:07,120 --> 00:38:11,920
be defined and that is what the set

00:38:10,780 --> 00:38:15,190
performance state

00:38:11,920 --> 00:38:17,200
in this hook that a platform and found

00:38:15,190 --> 00:38:22,869
that the platform-specific hook for it

00:38:17,200 --> 00:38:25,599
as they said performances state it's not

00:38:22,869 --> 00:38:27,819
really the idle idle / it's not idle

00:38:25,599 --> 00:38:30,910
power management it is small of an

00:38:27,819 --> 00:38:40,329
active power management feature but it

00:38:30,910 --> 00:38:42,190
is part of Gen PD module and also today

00:38:40,329 --> 00:38:46,710
I think it's a more recent development

00:38:42,190 --> 00:38:50,109
where gen PD governor's allow you to

00:38:46,710 --> 00:38:52,030
provide per device quality of service

00:38:50,109 --> 00:38:54,609
constraints or latency constraints which

00:38:52,030 --> 00:38:56,910
kind of rolls back into whether a power

00:38:54,609 --> 00:39:06,220
domain can actually be powered down or

00:38:56,910 --> 00:39:10,380
power should be kept on any questions

00:39:06,220 --> 00:39:10,380
before we move on to quality of services

00:39:15,610 --> 00:39:18,390
we don't

00:39:20,360 --> 00:39:27,140
is that okay okay so moving on quality

00:39:25,670 --> 00:39:35,990
of service I'll just skim through this

00:39:27,140 --> 00:39:38,690
and I don't know if it's no so the

00:39:35,990 --> 00:39:40,700
colonel allows for the colonel has a

00:39:38,690 --> 00:39:44,030
quality of service framework that allows

00:39:40,700 --> 00:39:46,210
for two classes of quality of services

00:39:44,030 --> 00:39:48,230
to be defined one a system-wide

00:39:46,210 --> 00:39:50,150
constraints and the other one is device

00:39:48,230 --> 00:39:54,050
specific constraint so the system-wide

00:39:50,150 --> 00:39:55,910
constraint is what so the system-wide

00:39:54,050 --> 00:39:58,100
constraints there are multiples of a few

00:39:55,910 --> 00:40:00,380
of them are CPU DMA latency constraint

00:39:58,100 --> 00:40:03,170
network latency constraint network

00:40:00,380 --> 00:40:05,090
throughput constraint etc the CPU DMA

00:40:03,170 --> 00:40:08,060
latency is the one that is widely used

00:40:05,090 --> 00:40:10,600
and it kind of goes back into the CPU

00:40:08,060 --> 00:40:13,340
feeds back into the menu governor in the

00:40:10,600 --> 00:40:15,170
cpu idle framework it is one of those

00:40:13,340 --> 00:40:17,930
parameters that allows them a new

00:40:15,170 --> 00:40:19,850
governor to choose the sea state so if a

00:40:17,930 --> 00:40:22,520
device has said that I need a particular

00:40:19,850 --> 00:40:25,190
latency from the CPU they may new garner

00:40:22,520 --> 00:40:30,790
picks it up and uses it to make the

00:40:25,190 --> 00:40:33,410
choice similarly there is this

00:40:30,790 --> 00:40:37,240
associated with the generic power domain

00:40:33,410 --> 00:40:41,060
framework there is device specific

00:40:37,240 --> 00:40:45,470
quality of service that can be specified

00:40:41,060 --> 00:40:49,990
which is def PM q io QoS resume latency

00:40:45,470 --> 00:40:49,990
and f PM QoS latency tolerance

00:40:52,440 --> 00:40:56,990
and when this ended up to like bus

00:40:54,060 --> 00:40:56,990
gambling or something

00:41:16,060 --> 00:41:28,240
do you want to do a talent management

00:41:18,990 --> 00:41:31,240
yeah yeah okay okay I thought a lot on

00:41:28,240 --> 00:41:33,760
how to organize this so again this is a

00:41:31,240 --> 00:41:36,339
little deviation from the generic format

00:41:33,760 --> 00:41:38,260
of the training it so device drivers and

00:41:36,339 --> 00:41:40,990
devices don't have to do anything much

00:41:38,260 --> 00:41:42,940
with thermal management generally unless

00:41:40,990 --> 00:41:45,490
you are a sensor driver or a cooling

00:41:42,940 --> 00:41:49,720
device driver but it's more from a

00:41:45,490 --> 00:41:52,630
system point of view so the thermal

00:41:49,720 --> 00:41:55,980
management frameworks it's can itself be

00:41:52,630 --> 00:41:59,470
divided into four the thermal zones

00:41:55,980 --> 00:42:04,810
thermal sensors the cooling devices and

00:41:59,470 --> 00:42:06,640
thermal governors so a thermal zone as

00:42:04,810 --> 00:42:09,400
far as the hardware is concerned it's a

00:42:06,640 --> 00:42:11,650
zone or an area or a device in an SOC

00:42:09,400 --> 00:42:17,109
that has a thermal constraint like a

00:42:11,650 --> 00:42:19,599
processor or a GPU so typically a zone

00:42:17,109 --> 00:42:22,240
will have sensors associated with it to

00:42:19,599 --> 00:42:24,520
sense the hot points and to report the

00:42:22,240 --> 00:42:26,950
temperature changes and it could also

00:42:24,520 --> 00:42:29,710
have active cooling cooling devices like

00:42:26,950 --> 00:42:32,770
a fan associated with it from the

00:42:29,710 --> 00:42:34,599
hardware point of view from how would

00:42:32,770 --> 00:42:38,859
this has got mapped into the Linux

00:42:34,599 --> 00:42:40,869
kernel software framework as a zone is

00:42:38,859 --> 00:42:43,210
represented as a device driver and it's

00:42:40,869 --> 00:42:46,089
treated as a manager for all the thermal

00:42:43,210 --> 00:42:50,020
activity pertaining to that zone so if

00:42:46,089 --> 00:42:52,210
you look at the picture here the thermal

00:42:50,020 --> 00:42:55,140
zone device driver is what interacts

00:42:52,210 --> 00:42:57,819
with each and every entity of the

00:42:55,140 --> 00:42:59,560
thermal zone like the sensor driver a

00:42:57,819 --> 00:43:01,900
thermal governor the cooling device

00:42:59,560 --> 00:43:05,890
driver and it kind of acts as a manager

00:43:01,900 --> 00:43:10,750
so it's a it's it's it can be considered

00:43:05,890 --> 00:43:12,130
as what you see can be considered as an

00:43:10,750 --> 00:43:15,000
entity that kind of passes messages

00:43:12,130 --> 00:43:18,510
between these various pieces of the

00:43:15,000 --> 00:43:18,510
thermal framework

00:43:21,990 --> 00:43:26,650
so then there are thermal sensors which

00:43:24,400 --> 00:43:28,600
are actual iTunes from a hardware point

00:43:26,650 --> 00:43:31,300
of view these are actual i2c a DC

00:43:28,600 --> 00:43:33,940
converters or bandgap devices that has

00:43:31,300 --> 00:43:36,940
the ability to sense the device hot

00:43:33,940 --> 00:43:39,040
points davell to sense interrupts I mean

00:43:36,940 --> 00:43:41,980
to sense temperatures and to issue

00:43:39,040 --> 00:43:45,370
interrupts to notify about the

00:43:41,980 --> 00:43:48,460
temperature changes and from a software

00:43:45,370 --> 00:43:50,530
point of view there is usually a device

00:43:48,460 --> 00:43:55,840
driver associated with each of these

00:43:50,530 --> 00:43:58,990
sensor devices and these device drivers

00:43:55,840 --> 00:44:02,260
often defines the trip points for these

00:43:58,990 --> 00:44:04,300
Hardware interrupts as in which each and

00:44:02,260 --> 00:44:12,400
it also divided and defines the range of

00:44:04,300 --> 00:44:14,440
temperature for these trip points then

00:44:12,400 --> 00:44:16,570
there are cooling devices which so once

00:44:14,440 --> 00:44:19,180
you have a thermal activity once the

00:44:16,570 --> 00:44:20,920
term devices already are a zone or a

00:44:19,180 --> 00:44:23,800
device or whatever it is is already

00:44:20,920 --> 00:44:25,900
heated up what to do so there are

00:44:23,800 --> 00:44:28,750
cooling devices that aids in power

00:44:25,900 --> 00:44:33,130
dissipation to control or limit the

00:44:28,750 --> 00:44:35,320
overheating of the device so there there

00:44:33,130 --> 00:44:37,960
can be Hardware cooling devices like

00:44:35,320 --> 00:44:39,790
fans which just sit there and work and

00:44:37,960 --> 00:44:42,340
like you don't have to do anything much

00:44:39,790 --> 00:44:44,950
other than just turning it on and there

00:44:42,340 --> 00:44:48,940
can be a bunch of things that can be

00:44:44,950 --> 00:44:50,730
done in the software to control to in

00:44:48,940 --> 00:44:53,320
order to aid the cooling of your device

00:44:50,730 --> 00:44:55,120
so in case of generic devices you can

00:44:53,320 --> 00:44:57,580
always restrict the device performance

00:44:55,120 --> 00:44:59,230
or restrict the device OPP you can

00:44:57,580 --> 00:45:01,510
always say that I will not allow the

00:44:59,230 --> 00:45:03,250
device to run at the highest OPP or the

00:45:01,510 --> 00:45:07,330
second highest to OPP I'll bring it down

00:45:03,250 --> 00:45:11,260
till the device cools in case of CPU it

00:45:07,330 --> 00:45:13,000
is called CPU free cooling device again

00:45:11,260 --> 00:45:15,970
in case of CPU overheating you can

00:45:13,000 --> 00:45:19,920
always decide to hot plug a few CPUs out

00:45:15,970 --> 00:45:23,380
of the system another mechanism is to

00:45:19,920 --> 00:45:27,400
forcibly idle a few CPUs inject idle

00:45:23,380 --> 00:45:30,430
cycles into a few CPU still the CPU is

00:45:27,400 --> 00:45:32,740
cooled down so these are all a few

00:45:30,430 --> 00:45:39,940
software cooling devices that aerial

00:45:32,740 --> 00:45:41,830
well in Linux kernel today and again

00:45:39,940 --> 00:45:43,690
there is a governor which is the entity

00:45:41,830 --> 00:45:46,750
it's only a software and it it's like an

00:45:43,690 --> 00:45:50,500
algorithm that manages all these devices

00:45:46,750 --> 00:45:53,770
it is an algorithm that chooses ok that

00:45:50,500 --> 00:45:55,990
kind of make takes the decision on what

00:45:53,770 --> 00:45:58,180
to do what cooling device to trigger and

00:45:55,990 --> 00:45:59,830
what to do when a particular when the

00:45:58,180 --> 00:46:01,330
temperature has either risen above a

00:45:59,830 --> 00:46:03,940
particular point or when a temperature

00:46:01,330 --> 00:46:09,850
has come down from that particular point

00:46:03,940 --> 00:46:11,920
so the the the governor are on the main

00:46:09,850 --> 00:46:20,130
line today is usually is usually

00:46:11,920 --> 00:46:24,190
stepwise governor which kind of tries to

00:46:20,130 --> 00:46:25,960
step up and step down the temperature

00:46:24,190 --> 00:46:28,960
which kind of tries to take a stepwise

00:46:25,960 --> 00:46:31,360
approach to temperature control and then

00:46:28,960 --> 00:46:33,340
there is there are governors that didn't

00:46:31,360 --> 00:46:35,260
consider power budget and performance

00:46:33,340 --> 00:46:37,090
requirements it's called I IPA which is

00:46:35,260 --> 00:46:39,340
commonly used in the and Android

00:46:37,090 --> 00:46:42,490
platform that can also be used as space

00:46:39,340 --> 00:46:44,290
governors which controls all this from

00:46:42,490 --> 00:46:52,830
the user space you can write policies

00:46:44,290 --> 00:46:57,130
for it from the user space so this

00:46:52,830 --> 00:46:59,530
presentation was originally like a few

00:46:57,130 --> 00:47:03,520
connects ago was derived from a

00:46:59,530 --> 00:47:05,619
presentation that Kevin helm entered at

00:47:03,520 --> 00:47:12,240
Bailey brace there's a link to the

00:47:05,619 --> 00:47:12,240
original presentation thank you

00:47:13,120 --> 00:47:17,980

YouTube URL: https://www.youtube.com/watch?v=lpzniFSLDqs


