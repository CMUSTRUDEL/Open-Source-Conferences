Title: BKK19-112 - Building the Linux kernel with Clang
Publication date: 2019-04-03
Playlist: Linaro Connect Bangkok 2019
Description: 
	Abstract
Linaro has been building on KernelCI to handle continuous integration of the Linux kernel with multiple different compilers and compiler versions. This is used for catching regressions upstream in the Linux kernel and LLVM code bases. This helps ensure that Android and ChromeOS can reliably ship LTS branches of the kernel built with Clang. Come learn more about building Linux kernels with Clang, and how Linaro is helping enable this work via KernelCI.

Nicholas Desaulniers / Software Engineer at Google
Nick Desaulniers is a software engineer at Google working on compiling the Linux Kernel with Clang (and LLVM).

Nick has previously worked on TensorFlowâ€™s Accelerated Linear Algebra (XLA) JIT compiler for Tensor Processing Units (TPUs), and the Linux kernel for the Nexus and Pixel phones while at Google.

Nick also hacked on open source projects like Firefox, Firefox OS, Emscripten, and Rust at Mozilla.

Contributing to Open Source software and an accessible Internet for all are some of the things that Nick is most passionate about.

Tri Vo / Software Engineer at Google
Captions: 
	00:00:05,490 --> 00:00:09,719
hi everyone my name's Nick I'm a

00:00:07,979 --> 00:00:12,719
software engineer at Google working on

00:00:09,719 --> 00:00:15,660
androids LLVM team my name is Chi I'm on

00:00:12,719 --> 00:00:17,520
the Android team also and we're here

00:00:15,660 --> 00:00:19,680
today to tell you a little bit about our

00:00:17,520 --> 00:00:22,500
work on building the Linux kernel with

00:00:19,680 --> 00:00:26,490
clang and working with Lennar towards

00:00:22,500 --> 00:00:30,810
towards of school so just a brief

00:00:26,490 --> 00:00:33,120
timeline of things so clang itself was

00:00:30,810 --> 00:00:36,359
was open source from Apple and I think

00:00:33,120 --> 00:00:38,550
2007 LLVM a little bit earlier than that

00:00:36,359 --> 00:00:40,350
the first kind of started trying to dig

00:00:38,550 --> 00:00:43,350
and find early records of of people

00:00:40,350 --> 00:00:45,510
chewing on this but the idea being the

00:00:43,350 --> 00:00:47,190
first known case I could find of someone

00:00:45,510 --> 00:00:49,200
trying to build the Linux kernel with

00:00:47,190 --> 00:00:51,390
clang someone filed a meta bug about

00:00:49,200 --> 00:00:54,270
this back in 2009 and a few other issues

00:00:51,390 --> 00:00:55,980
in elegans issue tracker in 2009 so

00:00:54,270 --> 00:00:58,410
people have been chewing on this for for

00:00:55,980 --> 00:01:00,690
about 10 years kind of thing I think I

00:00:58,410 --> 00:01:02,700
found a post on El vm's

00:01:00,690 --> 00:01:06,240
mailing list someone said like I got it

00:01:02,700 --> 00:01:09,479
to boot kind of thing 2011 there's a

00:01:06,240 --> 00:01:11,760
github team called the L ll project I

00:01:09,479 --> 00:01:15,840
think the first two L's are LLVM and

00:01:11,760 --> 00:01:18,900
then Linux project through 2012 to 2016

00:01:15,840 --> 00:01:20,790
there was a another group called the LOV

00:01:18,900 --> 00:01:23,220
M Linux project had an extensive set of

00:01:20,790 --> 00:01:26,610
kind of patches to the kernel when I

00:01:23,220 --> 00:01:29,369
started taking a look into this in 2016

00:01:26,610 --> 00:01:31,560
me and my former teammates Greg kind of

00:01:29,369 --> 00:01:35,759
dusted off some of these old LLVM Linux

00:01:31,560 --> 00:01:40,229
patches and and basically got our Google

00:01:35,759 --> 00:01:42,869
pixel one device booting and running

00:01:40,229 --> 00:01:44,430
with a with a clanging built kernel at

00:01:42,869 --> 00:01:47,009
the time I don't think we had up

00:01:44,430 --> 00:01:48,720
streamed anything this was like we just

00:01:47,009 --> 00:01:50,340
got it kind of working and it was right

00:01:48,720 --> 00:01:52,320
after the device shipped kind of things

00:01:50,340 --> 00:01:56,490
so our leadership and kind of advice is

00:01:52,320 --> 00:01:59,400
to try again for pixel two and get

00:01:56,490 --> 00:02:00,659
things like kind of well tested in in

00:01:59,400 --> 00:02:02,790
place and take measurements and these

00:02:00,659 --> 00:02:06,180
things and so we ended up shipping pixel

00:02:02,790 --> 00:02:12,200
2 and 2017 with a clang built kernel arm

00:02:06,180 --> 00:02:15,989
64 device same around the same same year

00:02:12,200 --> 00:02:18,359
my colleague matias on Chrome OS had

00:02:15,989 --> 00:02:19,080
sent these to essentially kind of patch

00:02:18,359 --> 00:02:21,780
sets that

00:02:19,080 --> 00:02:23,220
we're using in Chrome OS the idea being

00:02:21,780 --> 00:02:25,380
trying to minimize the amount of out of

00:02:23,220 --> 00:02:29,120
tree code that we had for building the

00:02:25,380 --> 00:02:31,950
colonel with clang 2018 Chrome OS

00:02:29,120 --> 00:02:34,830
started shipping clanging built kernels

00:02:31,950 --> 00:02:39,240
as their default for for all for for

00:02:34,830 --> 00:02:41,280
newer kernels for pixel three I think we

00:02:39,240 --> 00:02:43,290
ended up shipping pixel three with LTO

00:02:41,280 --> 00:02:44,880
builds of our kernel and something

00:02:43,290 --> 00:02:48,000
called control flow integrity analysis

00:02:44,880 --> 00:02:49,980
is kind of a security technique for

00:02:48,000 --> 00:02:52,520
defending against certain classes of

00:02:49,980 --> 00:02:54,870
kind of rap chains as my understanding

00:02:52,520 --> 00:02:59,150
2019 some of the things that we've been

00:02:54,870 --> 00:03:01,860
looking into are using LVM linker lld

00:02:59,150 --> 00:03:02,520
that that's good to go and turned on on

00:03:01,860 --> 00:03:05,030
a build

00:03:02,520 --> 00:03:08,880
it'll ship later this year and into vice

00:03:05,030 --> 00:03:11,310
LLVM AR i believe is ready to go i'm at

00:03:08,880 --> 00:03:12,840
least upstream mainline linux for all

00:03:11,310 --> 00:03:14,520
architectures i've tested it with is

00:03:12,840 --> 00:03:16,140
ready to go

00:03:14,520 --> 00:03:18,570
shadow call stack is another technology

00:03:16,140 --> 00:03:21,750
that is used for preventing yet another

00:03:18,570 --> 00:03:24,150
class of rock chain attacks that that's

00:03:21,750 --> 00:03:26,190
up and running as well so there's still

00:03:24,150 --> 00:03:27,900
some amount of work to do to kind of

00:03:26,190 --> 00:03:33,360
upstream some of these features as well

00:03:27,900 --> 00:03:35,910
into mainline linux so i always get this

00:03:33,360 --> 00:03:38,040
question like does it work and the

00:03:35,910 --> 00:03:40,019
answer is it's a little complicated

00:03:38,040 --> 00:03:42,269
because for the linux kernel you have

00:03:40,019 --> 00:03:44,130
many many different architectures and so

00:03:42,269 --> 00:03:46,769
the first kind of question is well can

00:03:44,130 --> 00:03:48,780
clank argot them or not so clang doesn't

00:03:46,769 --> 00:03:50,310
necessarily have a back-end that can

00:03:48,780 --> 00:03:52,890
target all these different architectures

00:03:50,310 --> 00:03:55,080
that the kernel does support I would say

00:03:52,890 --> 00:03:58,260
we're probably the farthest along with

00:03:55,080 --> 00:04:02,190
arm 64 thanks to help from a lot of

00:03:58,260 --> 00:04:03,810
folks at Lennar oh so an all yes config

00:04:02,190 --> 00:04:06,840
is pretty much done

00:04:03,810 --> 00:04:10,080
I think she just finished off the last

00:04:06,840 --> 00:04:13,200
remaining compiler error with there's

00:04:10,080 --> 00:04:14,940
still some bugs for novice yeah I was

00:04:13,200 --> 00:04:17,940
like we're sitting in the airport kind

00:04:14,940 --> 00:04:19,470
of thing and we get a zero day by email

00:04:17,940 --> 00:04:21,510
kind of thing we're like oh yeah oops

00:04:19,470 --> 00:04:25,940
he's ran config doesn't build whatever

00:04:21,510 --> 00:04:28,620
it's like a six line patch to fix it

00:04:25,940 --> 00:04:33,009
yeah it's like oh yeah we happens if you

00:04:28,620 --> 00:04:36,400
turn off modules okay arm v5 v6

00:04:33,009 --> 00:04:38,069
seven PowerPC thirty-two and PowerPC 64

00:04:36,400 --> 00:04:40,869
little-endian def configs

00:04:38,069 --> 00:04:42,039
build and boot for a lot of these

00:04:40,869 --> 00:04:43,839
architectures there's something called

00:04:42,039 --> 00:04:46,449
ran config it's like a coin flip of

00:04:43,839 --> 00:04:48,099
configs turned on and off I can't

00:04:46,449 --> 00:04:51,039
guarantee you that for any given one

00:04:48,099 --> 00:04:53,199
clang will just work but I think folks

00:04:51,039 --> 00:04:54,639
have done a lot of great work art in

00:04:53,199 --> 00:04:56,919
particular right didn't something like

00:04:54,639 --> 00:05:01,199
50-something ran config builds right and

00:04:56,919 --> 00:05:04,180
was able to find lots of issues and Wow

00:05:01,199 --> 00:05:06,069
okay just just just for the camera art

00:05:04,180 --> 00:05:10,479
city does a thousand ran config builds a

00:05:06,069 --> 00:05:12,069
day kind of thing so right so I think

00:05:10,479 --> 00:05:14,020
with ran config it's always like a game

00:05:12,069 --> 00:05:15,939
of whack Amole just because

00:05:14,020 --> 00:05:17,740
theoretically we still don't have entire

00:05:15,939 --> 00:05:20,499
coverage of every possible configuration

00:05:17,740 --> 00:05:22,120
but like for same configurations that

00:05:20,499 --> 00:05:23,199
you probably would use I think we're in

00:05:22,120 --> 00:05:25,479
good shape

00:05:23,199 --> 00:05:28,259
there's a something called config jump

00:05:25,479 --> 00:05:32,139
label is a kind of interesting

00:05:28,259 --> 00:05:35,259
technology used in the kernel for kind

00:05:32,139 --> 00:05:37,180
of changing branching dynamically at

00:05:35,259 --> 00:05:39,279
runtime so the kernel while it's booting

00:05:37,180 --> 00:05:41,409
will actually patch itself and insert

00:05:39,279 --> 00:05:42,789
either nap sleds or jumps and then like

00:05:41,409 --> 00:05:44,139
later on if you want to trace things

00:05:42,789 --> 00:05:46,800
that can kind of patch to these points

00:05:44,139 --> 00:05:49,269
is it's very very tricky and complicated

00:05:46,800 --> 00:05:51,339
x86 made it required for their

00:05:49,269 --> 00:05:55,779
architecture back in February of last

00:05:51,339 --> 00:05:57,789
year and so it's been a work in progress

00:05:55,779 --> 00:06:01,419
kind of implementing this in Incline in

00:05:57,789 --> 00:06:04,360
LLVM so I think the back end support of

00:06:01,419 --> 00:06:07,209
this landed in LLVM in the clang 8

00:06:04,360 --> 00:06:10,029
release but the front end to code I held

00:06:07,209 --> 00:06:12,339
it back because we basically needed to

00:06:10,029 --> 00:06:14,830
be able to inline Azzam go-to in the

00:06:12,339 --> 00:06:16,959
kernel and we still have some bugs with

00:06:14,830 --> 00:06:18,789
not patching the code correctly that

00:06:16,959 --> 00:06:21,550
like that's been my focus for the past

00:06:18,789 --> 00:06:23,259
two weeks is trying to debug that but we

00:06:21,550 --> 00:06:25,719
we have kind of basic cron jobs that

00:06:23,259 --> 00:06:28,330
that we run nightly just to catch any

00:06:25,719 --> 00:06:31,629
kind of breakages kind of looking at

00:06:28,330 --> 00:06:38,529
mainline linux links next and all the

00:06:31,629 --> 00:06:40,240
LTS branches so the idea is basically by

00:06:38,529 --> 00:06:41,949
by turning a very large code base

00:06:40,240 --> 00:06:44,620
against this compiler in a new compiler

00:06:41,949 --> 00:06:45,409
at this code base the hope is to try to

00:06:44,620 --> 00:06:48,169
improve

00:06:45,409 --> 00:06:50,539
both codebases right and I would say the

00:06:48,169 --> 00:06:52,099
Linux code base itself is a very unique

00:06:50,539 --> 00:06:53,989
code base compared to some of the other

00:06:52,099 --> 00:06:55,429
open-source code bases that that you

00:06:53,989 --> 00:06:57,979
might kind of throw at it and I would

00:06:55,429 --> 00:07:00,739
say Linux in general really stresses

00:06:57,979 --> 00:07:02,629
clang support for for inline assembly so

00:07:00,739 --> 00:07:05,089
there's kind of inline assembly where

00:07:02,629 --> 00:07:06,259
you just have you know a string and you

00:07:05,089 --> 00:07:08,089
know the compiler treats it as a black

00:07:06,259 --> 00:07:10,819
box just insert it into the object code

00:07:08,089 --> 00:07:13,999
you know at this point kind of thing but

00:07:10,819 --> 00:07:15,439
then there's extended inline assembly

00:07:13,999 --> 00:07:18,199
which has its own constraint language

00:07:15,439 --> 00:07:20,479
these constraints can be either generic

00:07:18,199 --> 00:07:21,829
or machine specific kind of thing I find

00:07:20,479 --> 00:07:23,089
like I always need the manual out

00:07:21,829 --> 00:07:26,419
whenever I'm like looking at it or

00:07:23,089 --> 00:07:27,979
trying to understand it so clang clang

00:07:26,419 --> 00:07:31,099
does have an integrated assembler as

00:07:27,979 --> 00:07:33,469
well so we find all kinds of missing

00:07:31,099 --> 00:07:36,589
missing features that clangs assembler

00:07:33,469 --> 00:07:39,499
doesn't understand particularly gasps

00:07:36,589 --> 00:07:40,729
the new assembler has kind of higher

00:07:39,499 --> 00:07:43,399
level pseudo instructions that are

00:07:40,729 --> 00:07:46,189
actually nice to use it's just when you

00:07:43,399 --> 00:07:47,539
write them I think if you then assemble

00:07:46,189 --> 00:07:50,149
the object file and disassemble it you

00:07:47,539 --> 00:07:52,219
get like a multiple instructions out of

00:07:50,149 --> 00:07:54,349
it so some of those are missing we found

00:07:52,219 --> 00:07:57,649
through trying to assemble the Linux

00:07:54,349 --> 00:08:00,169
kernel with a low VM a lot of the new C

00:07:57,649 --> 00:08:02,839
extensions I would say clang supports

00:08:00,169 --> 00:08:04,129
almost all of them the two that I can

00:08:02,839 --> 00:08:07,639
think of off the top of my head that

00:08:04,129 --> 00:08:10,490
aren't supported are inline functions

00:08:07,639 --> 00:08:14,719
which also are closures you can close

00:08:10,490 --> 00:08:18,789
over variables and outer scope are not

00:08:14,719 --> 00:08:20,269
supported in clang what yes yeah oh

00:08:18,789 --> 00:08:21,649
sorry sorry

00:08:20,269 --> 00:08:23,269
yeah nested functions yeah inline

00:08:21,649 --> 00:08:25,669
functions for sure are supported nested

00:08:23,269 --> 00:08:27,669
functions sorry is what I meant which

00:08:25,669 --> 00:08:31,039
can also be closures and then

00:08:27,669 --> 00:08:34,639
variable-length arrays in a structure so

00:08:31,039 --> 00:08:36,289
it is possible to declare an array you

00:08:34,639 --> 00:08:38,319
don't know the size until runtime you

00:08:36,289 --> 00:08:40,789
can put one of these in a structure

00:08:38,319 --> 00:08:41,719
hopefully at the end of it but if you

00:08:40,789 --> 00:08:43,610
put it in the middle of the structure

00:08:41,719 --> 00:08:45,829
that's like a good new to see extension

00:08:43,610 --> 00:08:47,000
that isn't implemented yet clang luckily

00:08:45,829 --> 00:08:49,069
the kernel doesn't make use of either of

00:08:47,000 --> 00:08:52,790
these and for the variable-length arrays

00:08:49,069 --> 00:08:56,360
instructs wvl a is turned on fluidics

00:08:52,790 --> 00:08:59,010
kernel I would say the the Linux kernel

00:08:56,360 --> 00:09:04,500
really stresses L

00:08:59,010 --> 00:09:07,230
support for linker scripts in in general

00:09:04,500 --> 00:09:09,000
I think embedded programming will will

00:09:07,230 --> 00:09:12,330
make heavier use of kind of linker

00:09:09,000 --> 00:09:14,730
scripts and advanced linker support then

00:09:12,330 --> 00:09:17,220
maybe more traditional application level

00:09:14,730 --> 00:09:18,780
programming we found that the Linux

00:09:17,220 --> 00:09:21,660
kernel boot time is very sensitive to

00:09:18,780 --> 00:09:23,820
kind of code size so you know ultimately

00:09:21,660 --> 00:09:26,040
we would like the code to be as fast as

00:09:23,820 --> 00:09:28,800
possible and we'd like the kernel to

00:09:26,040 --> 00:09:32,610
boot as fast as possible as well but you

00:09:28,800 --> 00:09:34,110
have this dichotomy sometimes of like if

00:09:32,610 --> 00:09:36,030
we just were to inline just a little bit

00:09:34,110 --> 00:09:38,310
more right we end up making the code

00:09:36,030 --> 00:09:40,080
larger and then like maybe it runs

00:09:38,310 --> 00:09:42,000
faster but doesn't like it boots slower

00:09:40,080 --> 00:09:44,850
kind of thing so you know that that's

00:09:42,000 --> 00:09:46,980
something that comes up off and and and

00:09:44,850 --> 00:09:48,960
I think the Lynx kernel was probably the

00:09:46,980 --> 00:09:51,930
largest open source seed codebase there

00:09:48,960 --> 00:09:55,080
is if someone knows one that's larger

00:09:51,930 --> 00:09:59,960
I'd be curious to know but but so I

00:09:55,080 --> 00:10:02,610
think like in it those are kind of

00:09:59,960 --> 00:10:06,170
different parts of the LLVM codebase

00:10:02,610 --> 00:10:06,170
that the Linux kernel really stresses

00:10:07,700 --> 00:10:13,230
all right so there are a number of

00:10:10,080 --> 00:10:17,940
things we changed out in LVM to to this

00:10:13,230 --> 00:10:20,960
to make this effort work so f no delete

00:10:17,940 --> 00:10:25,890
null pointer checks we added two clang

00:10:20,960 --> 00:10:28,170
so this isn't the category of things

00:10:25,890 --> 00:10:30,060
where compiler can detect

00:10:28,170 --> 00:10:31,590
undefined behavior or just behavior

00:10:30,060 --> 00:10:33,810
that's not necessarily in the standard

00:10:31,590 --> 00:10:36,420
and it might rip out null pointer checks

00:10:33,810 --> 00:10:39,960
out of the code and in the Linux kernel

00:10:36,420 --> 00:10:43,290
a lot of times the null pointer checks

00:10:39,960 --> 00:10:45,840
are really really required so we needed

00:10:43,290 --> 00:10:49,350
to add this flag and the ability to

00:10:45,840 --> 00:10:54,710
specify to tell the compiler that null

00:10:49,350 --> 00:10:59,340
pointer checks I really needed there so

00:10:54,710 --> 00:11:02,760
another thing we added to clang seven so

00:10:59,340 --> 00:11:06,540
in arm thirty-two you refer to general

00:11:02,760 --> 00:11:10,170
purpose registers by there are prefix so

00:11:06,540 --> 00:11:12,000
they're named are 0 1 2 3 etc and in arm

00:11:10,170 --> 00:11:15,899
00:11:12,000 --> 00:11:18,899
you prefix them with X and W for 64-bit

00:11:15,899 --> 00:11:22,050
and 32-bit respectively and the GNU

00:11:18,899 --> 00:11:25,740
assembler actually allows you to refer

00:11:22,050 --> 00:11:28,860
to register by let's say r9 in I'm 64

00:11:25,740 --> 00:11:30,810
code so the Linux code a lot of times

00:11:28,860 --> 00:11:34,589
actually refers to registers by their

00:11:30,810 --> 00:11:40,829
old 32 names so we we added support for

00:11:34,589 --> 00:11:44,519
the old I'm thirty-two names to clang so

00:11:40,829 --> 00:11:47,070
config armed 64 LLC Atomics this

00:11:44,519 --> 00:11:51,060
particular config actually relies on

00:11:47,070 --> 00:11:53,519
custom calling conventions for

00:11:51,060 --> 00:11:55,950
performance reasons so to actually

00:11:53,519 --> 00:11:59,790
support this conflict we added two flags

00:11:55,950 --> 00:12:02,970
to Clank a fixed flag allows us to

00:11:59,790 --> 00:12:06,269
reserve general-purpose registers and F

00:12:02,970 --> 00:12:08,130
calls a flat what it does is it

00:12:06,269 --> 00:12:13,079
specifies additional Kali saved

00:12:08,130 --> 00:12:18,060
registers so as Nick mentioned doesn't

00:12:13,079 --> 00:12:20,640
go to is a big ticket item for us the

00:12:18,060 --> 00:12:24,300
support for it and LVM is already merged

00:12:20,640 --> 00:12:27,930
and as we've already mentioned the front

00:12:24,300 --> 00:12:32,220
end is pending eta is clang nine is

00:12:27,930 --> 00:12:34,320
gonna have the support another thing

00:12:32,220 --> 00:12:37,970
that was merged into clang nine is

00:12:34,320 --> 00:12:42,860
support for GCC as in flag output so

00:12:37,970 --> 00:12:46,079
let's say you have an awesome block and

00:12:42,860 --> 00:12:49,709
you want to form an output that is based

00:12:46,079 --> 00:12:53,730
upon one of the flex registers that was

00:12:49,709 --> 00:12:58,940
formerly not possible to do in clang but

00:12:53,730 --> 00:13:02,630
we added output operands to as INBOX

00:12:58,940 --> 00:13:02,630
inclined to support that

00:13:08,130 --> 00:13:12,210
so there's nothing as far as I know

00:13:11,160 --> 00:13:15,029
there's nothing that's

00:13:12,210 --> 00:13:17,520
architecture-specific right now when I

00:13:15,029 --> 00:13:19,650
try to build an arm 64 colonel with like

00:13:17,520 --> 00:13:23,010
the front end support plus my inlining

00:13:19,650 --> 00:13:25,380
support I think I hit an issue related

00:13:23,010 --> 00:13:28,500
to what do we consider an integer

00:13:25,380 --> 00:13:30,150
constant expression so assuming we get

00:13:28,500 --> 00:13:31,650
that fixed as well in the claim 9

00:13:30,150 --> 00:13:33,540
release I don't think that there should

00:13:31,650 --> 00:13:35,430
be anything architecture-specific I

00:13:33,540 --> 00:13:37,380
think but that's more of like how is

00:13:35,430 --> 00:13:38,880
this construct being used in the Linux

00:13:37,380 --> 00:13:43,279
kernel otherwise there's nothing

00:13:38,880 --> 00:13:43,279
architecture specific about hasn't go to

00:13:47,120 --> 00:13:52,560
we've also made a number of changes in

00:13:49,800 --> 00:13:54,570
the Linux codebase so we recently added

00:13:52,560 --> 00:13:57,540
support for client implementation of G

00:13:54,570 --> 00:13:59,190
cough yeah as we mentioned earlier the

00:13:57,540 --> 00:14:01,230
thing just got nourished things are a

00:13:59,190 --> 00:14:04,650
little bit broken but hopefully the next

00:14:01,230 --> 00:14:08,100
merge window is gonna be in mainline so

00:14:04,650 --> 00:14:09,690
the advantage of building Linux with

00:14:08,100 --> 00:14:12,300
different compilers is that you get a

00:14:09,690 --> 00:14:14,700
larger coverage of warning checks and

00:14:12,300 --> 00:14:16,920
different static analysis tools so when

00:14:14,700 --> 00:14:18,930
we build Linux with clang we actually

00:14:16,920 --> 00:14:22,230
see a lot of warnings that are not

00:14:18,930 --> 00:14:31,140
caught in GCC and we try to fix all of

00:14:22,230 --> 00:14:33,150
those - all right let's I don't know if

00:14:31,140 --> 00:14:35,700
you guys can see this let's go through

00:14:33,150 --> 00:14:39,839
an example of one of the fun bugs we

00:14:35,700 --> 00:14:44,730
caught with clang warnings anyone can

00:14:39,839 --> 00:14:46,230
spot what's what might be wrong here let

00:14:44,730 --> 00:14:50,700
me see if I can turn off the lights over

00:14:46,230 --> 00:14:52,640
here the hint here is that W sometimes

00:14:50,700 --> 00:14:57,839
initialized flag this code as

00:14:52,640 --> 00:14:59,010
potentially not okay yeah it's probably

00:14:57,839 --> 00:15:02,130
gonna be pretty difficult for the

00:14:59,010 --> 00:15:04,170
audience to see but the idea is like

00:15:02,130 --> 00:15:07,140
trying to find use of uninitialized

00:15:04,170 --> 00:15:09,480
memory here so we have a pointer we

00:15:07,140 --> 00:15:13,860
declare we don't initialize it we have

00:15:09,480 --> 00:15:15,390
some conditional code that modifies this

00:15:13,860 --> 00:15:18,300
variable dialect

00:15:15,390 --> 00:15:21,000
afterwards we initialize the variable

00:15:18,300 --> 00:15:22,589
then we use the variable the issue here

00:15:21,000 --> 00:15:23,640
you can be forgiven if you didn't see it

00:15:22,589 --> 00:15:28,100
because I didn't see it the first time I

00:15:23,640 --> 00:15:28,100
saw the code that's a comma right there

00:15:28,730 --> 00:15:35,459
yes so the initialization of opcode

00:15:33,149 --> 00:15:38,850
variable is actually conditional it's

00:15:35,459 --> 00:15:42,390
within this if block so it's use here is

00:15:38,850 --> 00:15:44,430
undefined behavior so there's like we

00:15:42,390 --> 00:15:46,320
have a in our issue tracker

00:15:44,430 --> 00:15:48,209
you know big list of all these you can

00:15:46,320 --> 00:15:49,589
go through and check but I think that

00:15:48,209 --> 00:15:51,029
was one of the ones most recently that I

00:15:49,589 --> 00:15:52,620
thought was kind of interesting I

00:15:51,029 --> 00:16:00,360
actually didn't even know how that

00:15:52,620 --> 00:16:02,700
parsed yeah so the the whole effort of

00:16:00,360 --> 00:16:05,880
building Linux with clang it drives

00:16:02,700 --> 00:16:07,890
improvements on in both code bases git

00:16:05,880 --> 00:16:09,660
log will show you that there are more

00:16:07,890 --> 00:16:11,820
than a thousand commit messages that

00:16:09,660 --> 00:16:13,769
mention clang in the Linux kernel and

00:16:11,820 --> 00:16:15,779
more than a hundred of commits in the

00:16:13,769 --> 00:16:22,800
LLVM that are targeted targeted

00:16:15,779 --> 00:16:24,959
specifically at Linux alright so how do

00:16:22,800 --> 00:16:27,300
we prevent progressions and make sure

00:16:24,959 --> 00:16:28,050
that we continuously moving forward with

00:16:27,300 --> 00:16:31,519
this effort

00:16:28,050 --> 00:16:34,470
so this is where colonel CI comes in

00:16:31,519 --> 00:16:38,220
currently we have nightly builds of the

00:16:34,470 --> 00:16:41,329
Linux next branch and it's done in

00:16:38,220 --> 00:16:41,329
staging right now

00:16:50,040 --> 00:17:18,370
so your point is Linux next not updated

00:17:01,900 --> 00:17:23,410
on a 24-hour basis cool yeah thanks for

00:17:18,370 --> 00:17:25,180
the correction yeah so we're playing to

00:17:23,410 --> 00:17:27,040
move the the cia's of production as soon

00:17:25,180 --> 00:17:29,920
as possible and potentially to scale it

00:17:27,040 --> 00:17:33,070
to more branches other than Linux next

00:17:29,920 --> 00:17:39,660
and linearity see WG is also helping us

00:17:33,070 --> 00:17:44,170
with continuous testing well

00:17:39,660 --> 00:17:48,400
so whenever Linux X is updated we get

00:17:44,170 --> 00:17:51,580
build reports the CI sends us a pretty

00:17:48,400 --> 00:17:53,500
concise build report and contains all

00:17:51,580 --> 00:17:55,450
the necessary information that we might

00:17:53,500 --> 00:17:58,330
need for tracking in case there are

00:17:55,450 --> 00:18:01,810
problems so yeah it's probably too small

00:17:58,330 --> 00:18:05,290
for you guys to see but you will have

00:18:01,810 --> 00:18:09,370
the branch name the config name and all

00:18:05,290 --> 00:18:12,240
the errors that occurred during build so

00:18:09,370 --> 00:18:14,890
with this build report we can actually

00:18:12,240 --> 00:18:16,690
try things pretty quickly and we're

00:18:14,890 --> 00:18:19,120
notified pretty quickly as a matter of

00:18:16,690 --> 00:18:21,730
fact as soon as Linux next is updated

00:18:19,120 --> 00:18:24,490
and a lot of times the fixes are fairly

00:18:21,730 --> 00:18:26,830
simple so what this allows us to do is

00:18:24,490 --> 00:18:29,800
actually fix problems in Linux next

00:18:26,830 --> 00:18:33,030
before the hit main line and this has

00:18:29,800 --> 00:18:37,080
been a huge value add for us because

00:18:33,030 --> 00:18:37,080
things don't progressed as often

00:18:48,639 --> 00:19:07,849
okay so this particular bot builds with

00:18:53,570 --> 00:19:19,369
clang for us I don't know if we have

00:19:07,849 --> 00:19:22,690
statistics about that but max well there

00:19:19,369 --> 00:19:33,139
should should be every day right because

00:19:22,690 --> 00:19:35,899
yes matches emerged oh this is from the

00:19:33,139 --> 00:19:37,820
perspective of like building top of tree

00:19:35,899 --> 00:19:47,059
LLVM and compiling the Linux kernel with

00:19:37,820 --> 00:19:49,879
it yep yeah yeah I would say LLVM is is

00:19:47,059 --> 00:19:51,349
pretty noisy upstream development people

00:19:49,879 --> 00:19:54,320
tend to step on each other's toes I

00:19:51,349 --> 00:19:56,299
don't it it was quite a while until I

00:19:54,320 --> 00:19:58,309
was able to push a patch to LLVM without

00:19:56,299 --> 00:20:00,679
breaking like the windows build for

00:19:58,309 --> 00:20:07,849
instance it's tough there's a lot of

00:20:00,679 --> 00:20:12,049
build targets a lot of folks using it so

00:20:07,849 --> 00:20:14,029
kind of what's what's next I would say I

00:20:12,049 --> 00:20:16,129
was thinking of this project a lot of

00:20:14,029 --> 00:20:17,839
like you know get it building getting

00:20:16,129 --> 00:20:20,299
get it booting get it running get it

00:20:17,839 --> 00:20:21,559
running well kind of thing I would say I

00:20:20,299 --> 00:20:23,089
feel like we're pretty close to being

00:20:21,559 --> 00:20:25,549
done with the getting getting it

00:20:23,089 --> 00:20:28,190
building typically if it builds it will

00:20:25,549 --> 00:20:30,070
boot if it if it doesn't boot you know

00:20:28,190 --> 00:20:32,539
those are less fun bugs to try to fix

00:20:30,070 --> 00:20:34,009
kind of thing and then from there we're

00:20:32,539 --> 00:20:36,950
able to kind of focus on both building

00:20:34,009 --> 00:20:41,329
features like like the LTO and the

00:20:36,950 --> 00:20:42,979
kernel like shadow call stack like build

00:20:41,329 --> 00:20:45,200
additional features but then also start

00:20:42,979 --> 00:20:46,639
applying polish and start looking at you

00:20:45,200 --> 00:20:48,139
know what can we be doing better right

00:20:46,639 --> 00:20:50,629
so I would say kind of the next things

00:20:48,139 --> 00:20:51,330
on the radar that I can think of off the

00:20:50,629 --> 00:20:53,700
top of my head

00:20:51,330 --> 00:20:55,470
are like my personal goals are to finish

00:20:53,700 --> 00:20:56,970
off Azzam go to not have to worry about

00:20:55,470 --> 00:20:59,070
that anymore

00:20:56,970 --> 00:21:01,740
armed identified some interesting cases

00:20:59,070 --> 00:21:03,480
where clang doesn't aggressively sync

00:21:01,740 --> 00:21:07,980
the lifetime of variables in order to

00:21:03,480 --> 00:21:10,800
reuse stack slots I think that this may

00:21:07,980 --> 00:21:12,870
be an artifact of Clank being really

00:21:10,800 --> 00:21:17,190
well tested and used as a C++ compiler

00:21:12,870 --> 00:21:19,410
and the C++ style of declare things as

00:21:17,190 --> 00:21:23,640
late as possible near where they're used

00:21:19,410 --> 00:21:25,200
versus the kernel style c89 style of

00:21:23,640 --> 00:21:27,660
like declare things upfront that way you

00:21:25,200 --> 00:21:30,480
can kind of eyeball the stack usage in a

00:21:27,660 --> 00:21:33,210
given frame but then not aggressively

00:21:30,480 --> 00:21:35,490
synching the lifetime of variables or

00:21:33,210 --> 00:21:37,560
when you happen to inline to function

00:21:35,490 --> 00:21:40,800
calls into one stack frame you very

00:21:37,560 --> 00:21:42,360
clearly have delineated lifetimes of the

00:21:40,800 --> 00:21:44,940
local variables from those two child

00:21:42,360 --> 00:21:46,410
stack frames there are some cases where

00:21:44,940 --> 00:21:48,930
we have reduced warned

00:21:46,410 --> 00:21:51,300
we have warning false positives in in

00:21:48,930 --> 00:21:54,450
clang particularly the use of designated

00:21:51,300 --> 00:21:57,870
initializers on global variables is one

00:21:54,450 --> 00:22:01,800
issue and another one is encode that is

00:21:57,870 --> 00:22:06,030
dead code so just due to architectural

00:22:01,800 --> 00:22:08,100
differences in in GCC in LLVM and how

00:22:06,030 --> 00:22:10,530
inlining occurs or how often inlining

00:22:08,100 --> 00:22:13,460
occurs or when inlining occurs versus

00:22:10,530 --> 00:22:15,390
semantic analysis this can lead to cases

00:22:13,460 --> 00:22:17,220
where you might have like invalid

00:22:15,390 --> 00:22:19,230
assembly but it's okay because it's dead

00:22:17,220 --> 00:22:21,000
code and and clang is a little bit more

00:22:19,230 --> 00:22:23,460
aggressive about saying like hey know

00:22:21,000 --> 00:22:25,230
something's really wrong here and if

00:22:23,460 --> 00:22:27,120
it's dead code does it really matter

00:22:25,230 --> 00:22:30,930
kind of thing I think we can fix that up

00:22:27,120 --> 00:22:33,270
and then I think as far as looking at

00:22:30,930 --> 00:22:36,000
the set of LVM tools and using them as

00:22:33,270 --> 00:22:38,220
replacements for verb in utils I think

00:22:36,000 --> 00:22:40,440
the assembler support is going to be the

00:22:38,220 --> 00:22:42,810
longtail requires the most work I think

00:22:40,440 --> 00:22:45,180
I think we're really close with LLD for

00:22:42,810 --> 00:22:46,530
all architectures I'm not really worried

00:22:45,180 --> 00:22:48,450
right now about many of the other like

00:22:46,530 --> 00:22:50,580
abs dump pops copy all these ones that

00:22:48,450 --> 00:22:51,840
are used by the kernel the assembler I

00:22:50,580 --> 00:22:55,830
think there will be a fair amount of

00:22:51,840 --> 00:22:57,420
work but actually Len ro is as well kind

00:22:55,830 --> 00:23:01,380
of staffing up support for that which is

00:22:57,420 --> 00:23:03,180
which is really great if you're

00:23:01,380 --> 00:23:04,830
interested in trying it out we work

00:23:03,180 --> 00:23:06,630
entirely

00:23:04,830 --> 00:23:10,490
or mostly I guess not at github hang out

00:23:06,630 --> 00:23:14,550
on IRC we have a wiki and issue tracker

00:23:10,490 --> 00:23:17,010
feel free to file a bug against blocking

00:23:14,550 --> 00:23:19,230
the meta bug in lVN's issue tracker

00:23:17,010 --> 00:23:20,400
I always evangelize for God bolt if you

00:23:19,230 --> 00:23:22,890
haven't seen this before a compiler

00:23:20,400 --> 00:23:25,770
Explorer it's a really great way of kind

00:23:22,890 --> 00:23:27,540
of sharing a concise link of some seat

00:23:25,770 --> 00:23:29,850
code and some problematic code that was

00:23:27,540 --> 00:23:32,040
generated from any given compiler it's

00:23:29,850 --> 00:23:35,310
really excellent makes is like great and

00:23:32,040 --> 00:23:37,590
bug reports see reduces is one of my

00:23:35,310 --> 00:23:38,730
best friends for figuring out you know

00:23:37,590 --> 00:23:41,130
we have a whole translation unit

00:23:38,730 --> 00:23:42,510
something is wrong with it writing up a

00:23:41,130 --> 00:23:44,190
test case for figuring out what's

00:23:42,510 --> 00:23:46,530
important to figure out and then kind of

00:23:44,190 --> 00:23:48,300
minimizing it and then from there LLVM

00:23:46,530 --> 00:23:49,620
itself has another tool called bug point

00:23:48,300 --> 00:23:53,700
that can kind of further reduce things

00:23:49,620 --> 00:23:55,530
into elegan my are his nice bear is

00:23:53,700 --> 00:23:57,840
really nice for figuring out if you have

00:23:55,530 --> 00:23:59,820
like a make system that is very large

00:23:57,840 --> 00:24:02,070
sometimes you want to know like exactly

00:23:59,820 --> 00:24:04,920
what was passed to the compiler make

00:24:02,070 --> 00:24:06,540
equals v equals one is helpful bear is

00:24:04,920 --> 00:24:08,910
really helpful for dumping this as JSON

00:24:06,540 --> 00:24:12,380
then a lot of tools in LLVM land can

00:24:08,910 --> 00:24:15,000
just like read this indirectly and and

00:24:12,380 --> 00:24:17,580
kind of run whatever static analysis

00:24:15,000 --> 00:24:20,400
passes on exactly what was built and how

00:24:17,580 --> 00:24:22,290
it was built and the kernel itself k

00:24:20,400 --> 00:24:25,160
build will also dump these dot CMD files

00:24:22,290 --> 00:24:28,260
everywhere that has more information

00:24:25,160 --> 00:24:31,050
okay I'm gonna further evangelize God

00:24:28,260 --> 00:24:32,700
bold because yeah pretty nice I actually

00:24:31,050 --> 00:24:35,490
use it just for development largest bug

00:24:32,700 --> 00:24:37,500
reports because you can actually see how

00:24:35,490 --> 00:24:39,600
the compiler behaves of all the times

00:24:37,500 --> 00:24:41,760
without having to really compile stuff

00:24:39,600 --> 00:24:43,110
like locally yeah I think if you like

00:24:41,760 --> 00:24:44,700
rather than check out multiple different

00:24:43,110 --> 00:24:48,240
versions of different compilers yeah

00:24:44,700 --> 00:24:50,460
it's pretty helpful so thanks for

00:24:48,240 --> 00:24:53,220
everyone all of our contributors shout

00:24:50,460 --> 00:24:57,030
out to some of our contributors Joel

00:24:53,220 --> 00:24:59,280
Nathan sedap and a lot of folks on our

00:24:57,030 --> 00:25:01,320
side helping us kind of test this both

00:24:59,280 --> 00:25:04,470
from both the kernel perspective but

00:25:01,320 --> 00:25:06,540
also from the LOV M Linux side and kind

00:25:04,470 --> 00:25:08,970
of contributing upstream to both of

00:25:06,540 --> 00:25:11,010
those projects wouldn't be able to do it

00:25:08,970 --> 00:25:12,990
without you so thank you very much for

00:25:11,010 --> 00:25:16,700
attending our talk and we have I guess

00:25:12,990 --> 00:25:16,700
five minutes for questions thank you

00:25:24,130 --> 00:25:30,860
do you have a sense for efficiency of

00:25:28,370 --> 00:25:34,399
the compiler you know it's does it take

00:25:30,860 --> 00:25:37,370
approximately as long to build with GCC

00:25:34,399 --> 00:25:39,890
as with clang I know that the llt linker

00:25:37,370 --> 00:25:42,559
the the linker is faster in that world

00:25:39,890 --> 00:25:44,779
because it's more parallelized but you

00:25:42,559 --> 00:25:46,549
know just give a sense for like is it

00:25:44,779 --> 00:25:47,990
about the same degree of difficulty it

00:25:46,549 --> 00:25:49,549
is one do better than the other are you

00:25:47,990 --> 00:25:53,389
looking at the build system performance

00:25:49,549 --> 00:25:56,360
as a piece of your in general I think

00:25:53,389 --> 00:25:59,750
like build build performance is is

00:25:56,360 --> 00:26:01,519
something that I think Google overlooks

00:25:59,750 --> 00:26:03,380
a little bit just because of how

00:26:01,519 --> 00:26:04,880
distributed in general build systems are

00:26:03,380 --> 00:26:06,440
kind of thing I think it's it's

00:26:04,880 --> 00:26:08,570
something that that we know is

00:26:06,440 --> 00:26:10,850
definitely important and kind of from

00:26:08,570 --> 00:26:13,730
the top of like Linux kernel development

00:26:10,850 --> 00:26:16,220
we've we've heard like compiler compiler

00:26:13,730 --> 00:26:19,490
speed is important kind of thing I think

00:26:16,220 --> 00:26:21,019
I think there's more work to be done

00:26:19,490 --> 00:26:22,850
there I don't actually have measurements

00:26:21,019 --> 00:26:25,250
kind of thing I think most recently I

00:26:22,850 --> 00:26:26,389
was measuring LLD for instance right it

00:26:25,250 --> 00:26:28,429
was like kind of justifying it

00:26:26,389 --> 00:26:30,230
internally like can we turn this on is

00:26:28,429 --> 00:26:31,490
this good to do or not and like one of

00:26:30,230 --> 00:26:34,490
the things we were finding with lld

00:26:31,490 --> 00:26:37,490
Elias was we can cut an AR 64 all yes

00:26:34,490 --> 00:26:39,080
config link in half so I think one

00:26:37,490 --> 00:26:41,659
interesting thing that happened there is

00:26:39,080 --> 00:26:44,840
that the VM started out much faster than

00:26:41,659 --> 00:26:47,090
GCC and that led the GCC developers to

00:26:44,840 --> 00:26:49,130
work on performance so GCC got better

00:26:47,090 --> 00:26:51,559
but then at the same time a little um

00:26:49,130 --> 00:26:57,830
added more features and got slower so I

00:26:51,559 --> 00:26:59,299
think now they're about the same and I

00:26:57,830 --> 00:27:00,980
think like another thing is not just you

00:26:59,299 --> 00:27:02,899
know how fast did it compile but like

00:27:00,980 --> 00:27:04,370
how much memory did it use right because

00:27:02,899 --> 00:27:07,789
ultimately when you try to parallelize a

00:27:04,370 --> 00:27:09,950
build if you you know you have a many

00:27:07,789 --> 00:27:11,179
core box but not a lot of RAM eventually

00:27:09,950 --> 00:27:14,690
your compiled jobs can exhaust the

00:27:11,179 --> 00:27:19,159
amount of memory kind of thing so it's

00:27:14,690 --> 00:27:23,690
like thank you I had two questions first

00:27:19,159 --> 00:27:26,630
one I want to know what the performance

00:27:23,690 --> 00:27:29,090
e improvement for actual to have the

00:27:26,630 --> 00:27:29,960
number about that does this is the first

00:27:29,090 --> 00:27:34,190
one the same

00:27:29,960 --> 00:27:41,559
and why is that however text was a bug

00:27:34,190 --> 00:27:45,350
I was a CFI feature with the tool so

00:27:41,559 --> 00:27:47,840
regarding LTO I I don't I don't have any

00:27:45,350 --> 00:27:49,520
numbers kind of published or anything

00:27:47,840 --> 00:27:53,480
but I would say roughly kind of

00:27:49,520 --> 00:27:59,870
single-digit percentage point encampment

00:27:53,480 --> 00:28:01,549
and then for CF i-i-i i didn't do the

00:27:59,870 --> 00:28:04,039
work myself on it but i believe there

00:28:01,549 --> 00:28:05,240
were issues found particularly i think

00:28:04,039 --> 00:28:07,700
the major issues in the linux kernel

00:28:05,240 --> 00:28:09,140
that were found with CF i where

00:28:07,700 --> 00:28:11,120
differences in function signatures

00:28:09,140 --> 00:28:13,100
between translation units so for

00:28:11,120 --> 00:28:15,470
instance if you if you declare a

00:28:13,100 --> 00:28:17,179
function in a header and it's actually

00:28:15,470 --> 00:28:19,429
defined in a different translation unit

00:28:17,179 --> 00:28:22,100
but it's called from a yeah another

00:28:19,429 --> 00:28:23,480
translation unit and for some reason

00:28:22,100 --> 00:28:26,470
you're not you're not using that header

00:28:23,480 --> 00:28:28,970
to share the declaration of the function

00:28:26,470 --> 00:28:31,669
see if i was really really good at

00:28:28,970 --> 00:28:34,460
finding those kind of differences yes

00:28:31,669 --> 00:28:36,380
well so i think in order to get c fi

00:28:34,460 --> 00:28:39,799
building it required fixing a lot of

00:28:36,380 --> 00:28:41,630
those yes how many of those I believe

00:28:39,799 --> 00:28:43,850
the patches were sent upstream but I I

00:28:41,630 --> 00:28:47,000
could be wrong on that kind of thing and

00:28:43,850 --> 00:28:50,990
then it's meant to be a runtime like

00:28:47,000 --> 00:28:53,299
prevention of Rob chains so they're like

00:28:50,990 --> 00:28:55,610
unless someone is actively writing a rap

00:28:53,299 --> 00:28:57,500
chain against the kernel like I don't

00:28:55,610 --> 00:29:01,000
know how many attacks had stopped brah

00:28:57,500 --> 00:29:01,000
thank you thank you

00:29:06,710 --> 00:29:11,820
sure okay thank you very much everyone

00:29:09,360 --> 00:29:13,470
for your time and thank you be in the in

00:29:11,820 --> 00:29:14,580
the toolchain working group here if you

00:29:13,470 --> 00:29:17,080
want to chat or out in the hallway

00:29:14,580 --> 00:29:22,619
afterwards if you want to chat

00:29:17,080 --> 00:29:22,619

YouTube URL: https://www.youtube.com/watch?v=O83huiAzxhA


