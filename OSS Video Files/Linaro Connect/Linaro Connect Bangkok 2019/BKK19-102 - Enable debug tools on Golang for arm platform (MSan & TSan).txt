Title: BKK19-102 - Enable debug tools on Golang for arm platform (MSan & TSan)
Publication date: 2019-04-02
Playlist: Linaro Connect Bangkok 2019
Description: 
	Uninitialized memory can cause unpredict behavior and be hard to reproduce. Also Race conditions are among the most insidious and elusive programming errors. They typically cause erratic and mysterious failures, often long after the code has been deployed to production. Developers need to pay a lot of effort on testing and write code with care. Golang provides runtime tools for detecting those issues.

MemorySanitizer is a dynamic detector of uninitialized memory(UUM) in C and C++. The tool is based on compile time instrumentation and relies on bitprecise shadow memory at run-time. Shadow propagation technique is used to avoid false positive reports on copying of uninitialized memory. Also itâ€™s a part of LLVM trunk and implemented as an LLVM optimization pass.

ThreadSanitizer is a dynamic detector of data races, implemented by hybrid algorithm(based on happens-befor and locksets) and is a part of compiler-rt in LLVM.

In this presentation I will share
1, What are MemorySanitizer and ThreadSanitizer
2, The algorithms of the two detectors
3, The relationship between them and LLVM
4, How to port them into Golang on arm64
5, The example used in Golang

Fangming Fang / senior software engineer Arm
Work on Golang for enabling arm port, performance optimization etc.

All Resources: https://connect.linaro.org/resources/bkk19/sessions/

More info on Linaro:
https://www.linaro.org
Captions: 
	00:00:05,910 --> 00:00:12,809
turnin project is actually the campaign

00:00:09,570 --> 00:00:18,199
of foreign language so today I will

00:00:12,809 --> 00:00:20,420
introduce the to depart to us I enabled

00:00:18,199 --> 00:00:31,470
for our platform

00:00:20,420 --> 00:00:34,079
ok let's start this is my agenda it

00:00:31,470 --> 00:00:38,940
consists of two parts

00:00:34,079 --> 00:00:44,129
Tisa and amazon for each one of them i

00:00:38,940 --> 00:00:48,710
will introduce what is it and the

00:00:44,129 --> 00:00:53,719
algorithm implementing it and also ever

00:00:48,710 --> 00:00:58,969
introduced how to enable it and oh and

00:00:53,719 --> 00:00:58,969
finally I will give you simple demo

00:01:04,660 --> 00:01:15,730
as we know the use initialized memory is

00:01:10,570 --> 00:01:21,290
such issue that is very difficult to

00:01:15,730 --> 00:01:22,120
reproduce a metapod so actually memory

00:01:21,290 --> 00:01:25,880
sanitizer

00:01:22,120 --> 00:01:32,530
ensign for short is developed to adjust

00:01:25,880 --> 00:01:37,700
that issue him son is dynamic to us

00:01:32,530 --> 00:01:43,250
which detect the use of initialized

00:01:37,700 --> 00:01:48,550
memory in say this tool is reliance on

00:01:43,250 --> 00:01:54,100
the beat prices in memory and also

00:01:48,550 --> 00:01:58,700
relies on the shared memory propagation

00:01:54,100 --> 00:02:03,670
bit precisely memory means that M son

00:01:58,700 --> 00:02:07,090
can check initialized pits in bit fail

00:02:03,670 --> 00:02:11,210
state provocation technique where

00:02:07,090 --> 00:02:14,450
tolerate the coping initialized memory

00:02:11,210 --> 00:02:18,500
and also simple logic and arithmetic

00:02:14,450 --> 00:02:22,460
operation base it varied memory

00:02:18,500 --> 00:02:26,540
propagation technique M son can avoid

00:02:22,460 --> 00:02:31,370
the false positives report copying of an

00:02:26,540 --> 00:02:37,819
initialized memory ok

00:02:31,370 --> 00:02:41,780
share the memory as terrible as later

00:02:37,819 --> 00:02:45,140
sites you the application is located in

00:02:41,780 --> 00:02:48,110
the higher memory and the said memory is

00:02:45,140 --> 00:02:51,080
located in your memory

00:02:48,110 --> 00:02:56,000
they have one-to-one bitmap in

00:02:51,080 --> 00:02:58,640
relationship and it means that each one

00:02:56,000 --> 00:03:01,480
piece in jeddah memory stands for

00:02:58,640 --> 00:03:08,209
whether the corresponding application

00:03:01,480 --> 00:03:13,750
memory is initialized or not and one

00:03:08,209 --> 00:03:22,250
means initialized 0 means

00:03:13,750 --> 00:03:25,930
initialized also it's it's efficient to

00:03:22,250 --> 00:03:30,260
calculate the shadow memory address

00:03:25,930 --> 00:03:46,520
corresponding to application memory by

00:03:30,260 --> 00:03:52,870
using bitwise and operation see the

00:03:46,520 --> 00:03:56,480
propagation actually there are two kinds

00:03:52,870 --> 00:03:59,360
shaded propagation one is exact

00:03:56,480 --> 00:04:04,760
propagation and another is approximate

00:03:59,360 --> 00:04:09,190
propagation the basic shadow propagation

00:04:04,760 --> 00:04:13,970
was on the left side are all the exact

00:04:09,190 --> 00:04:20,060
propagation they are load operation

00:04:13,970 --> 00:04:26,419
store operation as well as some bitwise

00:04:20,060 --> 00:04:33,140
operation and it not always efficient to

00:04:26,419 --> 00:04:42,430
make exact propagation take the integer

00:04:33,140 --> 00:04:47,230
addition for example the law initialized

00:04:42,430 --> 00:04:51,040
pits in lower digit can affect a number

00:04:47,230 --> 00:04:55,370
of piece of the results due to the

00:04:51,040 --> 00:05:03,440
possible carry over so it is difficult

00:04:55,370 --> 00:05:08,360
to model integer addition behavior so we

00:05:03,440 --> 00:05:12,010
just use approximate propagation to

00:05:08,360 --> 00:05:15,830
model this behavior here we just use

00:05:12,010 --> 00:05:19,030
bitwise or operation to model integer

00:05:15,830 --> 00:05:19,030
addition behavior

00:05:21,050 --> 00:05:30,610
apart from addition operation the some

00:05:27,080 --> 00:05:35,530
other operation like a multiplication

00:05:30,610 --> 00:05:44,930
operation is also a person of

00:05:35,530 --> 00:05:49,430
approximate provocation okay

00:05:44,930 --> 00:05:50,900
what I talk about is the basic knowledge

00:05:49,430 --> 00:05:56,419
about innocent

00:05:50,900 --> 00:06:01,840
Alison next I will talk about the

00:05:56,419 --> 00:06:05,620
implementation I enabled in Sun Inco

00:06:01,840 --> 00:06:13,520
before that I will try to explain why

00:06:05,620 --> 00:06:20,060
co-lead the exam actually in son does

00:06:13,520 --> 00:06:24,289
not apply to pure go because the memory

00:06:20,060 --> 00:06:31,550
in pure miracle is all initialized

00:06:24,289 --> 00:06:35,479
but in go go can call a function by the

00:06:31,550 --> 00:06:39,080
way called psycho people can used C go

00:06:35,479 --> 00:06:41,090
to past memory back and forth between C

00:06:39,080 --> 00:06:46,430
and Anna go

00:06:41,090 --> 00:06:50,750
so if secret and initialized memory and

00:06:46,430 --> 00:06:56,300
passed it to go go fill it in retained

00:06:50,750 --> 00:06:59,990
back to C C code we're not beware of

00:06:56,300 --> 00:07:03,699
this initialization so the false

00:06:59,990 --> 00:07:08,470
positive report where will be reported

00:07:03,699 --> 00:07:13,520
so to avoid us to avoid this false

00:07:08,470 --> 00:07:16,930
positive reports made it to instrument

00:07:13,520 --> 00:07:16,930
EMSA and go

00:07:21,710 --> 00:07:32,389
this is M Sanford walk in go inside

00:07:28,130 --> 00:07:37,039
library at the button implements in some

00:07:32,389 --> 00:07:42,620
Ferguson and provide the basic utility

00:07:37,039 --> 00:07:47,780
function all the memory exists so long

00:07:42,620 --> 00:07:50,680
time intercepted by M son library where

00:07:47,780 --> 00:07:53,750
is this implementation with

00:07:50,680 --> 00:07:57,020
implementation of this framework the

00:07:53,750 --> 00:08:08,740
force positive caused by memory passed

00:07:57,020 --> 00:08:11,570
between C and go would not happen okay

00:08:08,740 --> 00:08:14,990
there are two special instrumentation

00:08:11,570 --> 00:08:18,860
I'd like to mention one is

00:08:14,990 --> 00:08:23,199
instrumentation or singular handle to

00:08:18,860 --> 00:08:27,970
chase the stake and print the warning

00:08:23,199 --> 00:08:32,870
venues are initialized memory occurs

00:08:27,970 --> 00:08:40,310
single Honora also should be intercepted

00:08:32,870 --> 00:08:46,040
by ensign library another is about a map

00:08:40,310 --> 00:08:50,630
when EMSA is enable the M Bob Cole will

00:08:46,040 --> 00:09:03,860
be intercepted and returning memory will

00:08:50,630 --> 00:09:11,620
be market Earth initialized okay choose

00:09:03,860 --> 00:09:17,089
a simple table for M Sun use in Co the

00:09:11,620 --> 00:09:22,640
code on the left side is C code and the

00:09:17,089 --> 00:09:29,630
code on the right side is co code the

00:09:22,640 --> 00:09:34,060
first line talk of the go code is to

00:09:29,630 --> 00:09:40,970
make array a which is initialized and

00:09:34,060 --> 00:09:47,290
then cobia called C function named F in

00:09:40,970 --> 00:09:51,520
this safe function it will malloc

00:09:47,290 --> 00:09:57,230
uninitialized memory and copy the

00:09:51,520 --> 00:10:03,339
initialized memory to array a this is to

00:09:57,230 --> 00:10:12,430
saying that function f where make the

00:10:03,339 --> 00:10:16,900
array a are initialized and then in code

00:10:12,430 --> 00:10:27,339
it will call it will initialized the

00:10:16,900 --> 00:10:29,120
first element of array a and then go

00:10:27,339 --> 00:10:33,290
code

00:10:29,120 --> 00:10:39,950
continue to call another say code named

00:10:33,290 --> 00:10:44,270
G in this function it will take code

00:10:39,950 --> 00:10:48,940
branch depending on the fifth element in

00:10:44,270 --> 00:10:52,400
array a which is an initialized so

00:10:48,940 --> 00:10:53,510
actually it exactly the use of

00:10:52,400 --> 00:11:01,250
initialized

00:10:53,510 --> 00:11:05,740
memory okay let's compare it in go the

00:11:01,250 --> 00:11:10,760
command line in blue choose the built

00:11:05,740 --> 00:11:11,910
command line the compiler of seen em son

00:11:10,760 --> 00:11:16,190
means

00:11:11,910 --> 00:11:25,380
no comparable instrument and Sun into

00:11:16,190 --> 00:11:38,300
application the screen shot maybe you

00:11:25,380 --> 00:11:44,910
can see South Korea the message in there

00:11:38,300 --> 00:11:48,450
is the reporting the world in that

00:11:44,910 --> 00:12:02,070
memories and the use of our initial nice

00:11:48,450 --> 00:12:04,400
the value here okay that that's what I

00:12:02,070 --> 00:12:08,540
talk for answer

00:12:04,400 --> 00:12:14,510
so next I will introduce another

00:12:08,540 --> 00:12:14,510
departures sanitizer

00:12:14,790 --> 00:12:23,850
so sanitizer tea Sam for short is

00:12:18,900 --> 00:12:28,460
developed to address the race issue that

00:12:23,850 --> 00:12:31,260
is is that two concurrent access to a

00:12:28,460 --> 00:12:35,190
location at least one of them for

00:12:31,260 --> 00:12:40,430
writing it is kind of Sweden parks and

00:12:35,190 --> 00:12:47,910
also it is hard to reproduce and depart

00:12:40,430 --> 00:12:57,380
teason is also a dynamic to us to detect

00:12:47,910 --> 00:13:02,970
a trace it is also a sub-project of vm

00:12:57,380 --> 00:13:06,180
in in the equation T Sun it were

00:13:02,970 --> 00:13:10,370
observed following events generated by

00:13:06,180 --> 00:13:15,210
running program memory exist even and

00:13:10,370 --> 00:13:18,780
synchronization event for memory access

00:13:15,210 --> 00:13:21,150
events it will recall the read events

00:13:18,780 --> 00:13:23,029
and write event for synchronization

00:13:21,150 --> 00:13:28,040
events

00:13:23,029 --> 00:13:40,310
Tisa Alison will record the local events

00:13:28,040 --> 00:13:43,339
not even happened before even Tisa used

00:13:40,310 --> 00:13:48,170
the equation called hybrid state machine

00:13:43,339 --> 00:13:51,740
to detect the race the equation includes

00:13:48,170 --> 00:13:56,420
two state machines why is global state

00:13:51,740 --> 00:13:58,279
machine this global state is used to

00:13:56,420 --> 00:14:00,800
record the information about

00:13:58,279 --> 00:14:05,149
synchronization event that have been

00:14:00,800 --> 00:14:07,940
observed before / ID state record the

00:14:05,149 --> 00:14:14,690
information about each memory location a

00:14:07,940 --> 00:14:18,170
running program Thyssen used these two

00:14:14,690 --> 00:14:32,180
state machines together to detect that

00:14:18,170 --> 00:14:37,100
race this is the design algorithm it

00:14:32,180 --> 00:14:41,930
seems complicated I'm not going to

00:14:37,100 --> 00:14:47,870
explain this algorithm 1 9 PI over 9 I

00:14:41,930 --> 00:14:49,449
just describe it briefly when memory

00:14:47,870 --> 00:14:53,569
exists even happens

00:14:49,449 --> 00:14:56,870
Kisame are scarce all the memory access

00:14:53,569 --> 00:15:01,310
events that happen happening to same

00:14:56,870 --> 00:15:04,250
memory before to see if there is any

00:15:01,310 --> 00:15:07,370
memory access event that has not

00:15:04,250 --> 00:15:13,399
happened before the nation ship against

00:15:07,370 --> 00:15:18,199
current one if there is one and one of

00:15:13,399 --> 00:15:25,459
them is for writing even that would be

00:15:18,199 --> 00:15:29,529
dead race that's what I wish and what's

00:15:25,459 --> 00:15:29,529
to say in this snide

00:15:32,630 --> 00:15:43,490
okay let's talk about what I what did I

00:15:38,370 --> 00:15:49,139
do in teason wantem library to enable

00:15:43,490 --> 00:15:53,010
Kissin I'm Kissin library as around

00:15:49,139 --> 00:15:59,600
Hanna beret is implemented in kampala RT

00:15:53,010 --> 00:16:03,540
which is also a sub-project air project

00:15:59,600 --> 00:16:10,800
because teason requires specific memory

00:16:03,540 --> 00:16:14,990
layout to enable Tisa algorithm and you

00:16:10,800 --> 00:16:19,130
know the memory layout is also are

00:16:14,990 --> 00:16:22,920
related so in order to support this and

00:16:19,130 --> 00:16:32,380
we shoot memory mapping code for arm in

00:16:22,920 --> 00:16:33,620
Tizen library so here I'm not going to

00:16:32,380 --> 00:16:36,389
[Music]

00:16:33,620 --> 00:16:43,440
talking about the implementation of the

00:16:36,389 --> 00:16:53,060
martin it's related and quite explicit

00:16:43,440 --> 00:16:59,370
to understand gisun library provides

00:16:53,060 --> 00:17:07,699
some api's that used to record all kinds

00:16:59,370 --> 00:17:07,699
of events - such as memory access events

00:17:08,329 --> 00:17:24,179
this this API has least on this list is

00:17:14,449 --> 00:17:30,150
the api's for memory access this it guys

00:17:24,179 --> 00:17:33,049
list here is related to atomic operation

00:17:30,150 --> 00:17:36,590
they are used to record the

00:17:33,049 --> 00:17:36,590
synchronization event

00:17:37,980 --> 00:17:52,320
okay this I will illustrate how kisum

00:17:45,400 --> 00:17:57,659
works it seems to what the M son does

00:17:52,320 --> 00:18:01,090
tis an long-term library the button

00:17:57,659 --> 00:18:04,240
implements tis an artisan and set of

00:18:01,090 --> 00:18:08,340
functions that are used to recall memory

00:18:04,240 --> 00:18:14,529
access event and synchronization events

00:18:08,340 --> 00:18:23,820
also Tisa random memory should detect

00:18:14,529 --> 00:18:23,820
the dead raised by even recording event

00:18:24,870 --> 00:18:33,789
all the other memory access even and

00:18:29,679 --> 00:18:38,620
synchronization event generated by the

00:18:33,789 --> 00:18:43,230
application are intercepted intercepted

00:18:38,620 --> 00:18:46,510
by artisan library with this framework

00:18:43,230 --> 00:18:51,659
the instrumented application Pattison

00:18:46,510 --> 00:18:51,659
can detect a trace during long time

00:18:54,870 --> 00:19:09,510
let's take a look at this a simple demo

00:18:58,510 --> 00:19:09,510
about ensign the main function were

00:19:09,600 --> 00:19:20,049
called star racer function star racer

00:19:15,340 --> 00:19:25,600
function will use gold laser to start at

00:19:20,049 --> 00:19:30,340
oten doten is something like sale but

00:19:25,600 --> 00:19:31,649
it's not a real real fear in those

00:19:30,340 --> 00:19:36,100
routine

00:19:31,649 --> 00:19:46,409
it will cause a stall function to write

00:19:36,100 --> 00:19:50,680
X ray is 42 in in the main function

00:19:46,409 --> 00:19:59,320
subsequently another store

00:19:50,680 --> 00:20:02,740
here well write X weighs 43 because this

00:19:59,320 --> 00:20:05,800
what event have no happen before

00:20:02,740 --> 00:20:10,450
relationship and also there is no knock

00:20:05,800 --> 00:20:31,180
to guarantee the other aid so that would

00:20:10,450 --> 00:20:36,390
be the race it's not near I the the

00:20:31,180 --> 00:20:42,430
screenshot shows that the compare the

00:20:36,390 --> 00:20:50,050
campaigner how to compile this code of

00:20:42,430 --> 00:20:54,130
the net aside it used an option race to

00:20:50,050 --> 00:20:56,500
compile this code it means that go

00:20:54,130 --> 00:21:03,250
compare their instrument this

00:20:56,500 --> 00:21:10,000
application ways T's T's on if we're on

00:21:03,250 --> 00:21:21,600
this panel generated by each term by to

00:21:10,000 --> 00:21:26,530
compile the race will be reported so

00:21:21,600 --> 00:21:35,640
this is a demo for somebody before how

00:21:26,530 --> 00:21:35,640
to use T's T's on in go okay

00:21:41,869 --> 00:21:52,019
make make summarised em son is a dynamic

00:21:48,450 --> 00:21:56,549
to us that he takes the use of are

00:21:52,019 --> 00:22:02,210
initialized memory the Tisa is also a

00:21:56,549 --> 00:22:02,210
dynamic tool that detects the data race

00:22:02,389 --> 00:22:12,059
using DoCoMo compiler to instrument aims

00:22:06,539 --> 00:22:17,249
and Tisa into application is just one

00:22:12,059 --> 00:22:20,429
use case obviously Tisa and in sun can

00:22:17,249 --> 00:22:23,299
be instrumented by another compiler if

00:22:20,429 --> 00:22:28,639
you in trouble

00:22:23,299 --> 00:23:04,259
debugging these two types issue hope my

00:22:28,639 --> 00:23:12,509
introduction be helpful okay yes yes it

00:23:04,259 --> 00:23:19,549
can because go compiler where is compile

00:23:12,509 --> 00:23:24,049
or go library by instrument

00:23:19,549 --> 00:23:31,950
corresponding design corresponding

00:23:24,049 --> 00:23:34,100
detect function into that library do you

00:23:31,950 --> 00:23:34,100
need

00:23:34,390 --> 00:23:39,110
and deed what do you actually need to do

00:23:37,040 --> 00:23:41,600
to turn on this sort of thing so if I

00:23:39,110 --> 00:23:43,340
just download go now what do I have to

00:23:41,600 --> 00:23:47,210
do do I have to build compiler RT do I

00:23:43,340 --> 00:23:53,030
have to point go various libraries yes

00:23:47,210 --> 00:24:01,450
you just need to download go and use it

00:23:53,030 --> 00:24:01,450
to compile an a go application yes yes

00:24:08,980 --> 00:24:16,790
what what is the runtime overhead of

00:24:11,840 --> 00:24:21,460
enabling these debugging tools what cost

00:24:16,790 --> 00:24:26,030
you pay in performance enabling these

00:24:21,460 --> 00:24:27,050
you mean the performance yes what's the

00:24:26,030 --> 00:24:40,190
performance overhead

00:24:27,050 --> 00:24:51,440
okay I it was was 20% slower than before

00:24:40,190 --> 00:24:56,810
i I didn't compare this result with that

00:24:51,440 --> 00:25:03,920
without use using this depart but I read

00:24:56,810 --> 00:25:06,470
from some paper it will be about 20

00:25:03,920 --> 00:25:15,410
percent slower ISM and that would be

00:25:06,470 --> 00:25:16,310
each for in Sun it's about 20% slower

00:25:15,410 --> 00:25:23,930
than before

00:25:16,310 --> 00:25:36,740
for Tizen it it's about 15 persons nor

00:25:23,930 --> 00:25:40,760
before yes yes EMSA is good designed as

00:25:36,740 --> 00:25:49,570
a signal to us

00:25:40,760 --> 00:25:57,169
I like the pink green do you know this

00:25:49,570 --> 00:26:00,850
that does dynamic tool to detail on the

00:25:57,169 --> 00:26:14,059
use of uninitialized memory but it is

00:26:00,850 --> 00:26:27,230
designed very could you go back to your

00:26:14,059 --> 00:26:30,919
first example for mm okay it was not

00:26:27,230 --> 00:26:35,690
clear to me when you call the goal make

00:26:30,919 --> 00:26:57,640
each 3210 the memory will be utilize it

00:26:35,690 --> 00:26:57,640
yes yes always do not call the functions

00:26:57,820 --> 00:27:04,100
the MS and won't accuse anything right

00:27:01,480 --> 00:27:08,090
it's just because you're calling C

00:27:04,100 --> 00:27:13,880
functions that instant is able to see an

00:27:08,090 --> 00:27:17,260
otherwise memory it's only because

00:27:13,880 --> 00:27:20,450
you're calling the the G function that

00:27:17,260 --> 00:27:27,169
it's actually seen normally in

00:27:20,450 --> 00:27:31,010
naturalized memory yes and you just use

00:27:27,169 --> 00:27:34,630
the C support the decline support for

00:27:31,010 --> 00:27:38,409
the friend Sam right yeah yeah

00:27:34,630 --> 00:27:38,980
we do not do anything special as I go

00:27:38,409 --> 00:27:53,559
itself

00:27:38,980 --> 00:27:59,460
yeah we have to implement some assembly

00:27:53,559 --> 00:28:05,490
code to port the design library in to go

00:27:59,460 --> 00:28:11,139
because go control everything everything

00:28:05,490 --> 00:28:13,000
like the assembly like other library or

00:28:11,139 --> 00:28:20,519
the genetic code

00:28:13,000 --> 00:28:28,830
so for each arc we have to implement the

00:28:20,519 --> 00:28:28,830
corresponding an API to Co I'm Sun ivory

00:28:31,889 --> 00:28:51,639
I use it that tweak to support multiple

00:28:36,610 --> 00:28:55,210
vmas add some overhead one option would

00:28:51,639 --> 00:28:58,690
be to just support 48 PMA and we'd use

00:28:55,210 --> 00:29:03,009
some overhead it will probably require

00:28:58,690 --> 00:29:07,059
change the way you calculate the shadow

00:29:03,009 --> 00:29:11,190
memory and yeah my question is how what

00:29:07,059 --> 00:29:18,240
gonna be needed to adapt go to a new

00:29:11,190 --> 00:29:23,080
shadow memory transformation actually in

00:29:18,240 --> 00:29:34,440
support 27

00:29:23,080 --> 00:29:36,779
virtual memory size know your 4747 for

00:29:34,440 --> 00:29:39,990
others

00:29:36,779 --> 00:29:43,410
temporary configuration for

00:29:39,990 --> 00:29:46,160
virtual memory size it does not support

00:29:43,410 --> 00:29:46,160
right now

00:29:55,880 --> 00:30:01,620
as all of this code landed in the

00:29:59,580 --> 00:30:06,740
upstream and being included in a release

00:30:01,620 --> 00:30:09,030
of go it happy really is dingo okay good

00:30:06,740 --> 00:30:10,559
congratulations and what what now you've

00:30:09,030 --> 00:30:15,770
done that what's the next thing that

00:30:10,559 --> 00:30:19,140
you're looking at or interested in sorry

00:30:15,770 --> 00:30:22,440
so it seems that this is concluded this

00:30:19,140 --> 00:30:24,809
piece of work is finished and and M San

00:30:22,440 --> 00:30:28,050
and T San now behave the same on arm as

00:30:24,809 --> 00:30:30,929
they do on Intel is that accurate yeah

00:30:28,050 --> 00:30:42,170
and so what are you going to do now what

00:30:30,929 --> 00:30:47,790
is the next task so I you mean what we

00:30:42,170 --> 00:30:49,740
do next for anxiety sir is it finished

00:30:47,790 --> 00:30:52,160
is a complete yes it's completed

00:30:49,740 --> 00:30:52,160
finished

00:31:02,590 --> 00:31:12,780
ok any question ok thank you all for

00:31:10,419 --> 00:31:15,940
coming again

00:31:12,780 --> 00:31:15,940

YouTube URL: https://www.youtube.com/watch?v=C79yV4fLxrA


