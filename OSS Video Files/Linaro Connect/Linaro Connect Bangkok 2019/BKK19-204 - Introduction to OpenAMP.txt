Title: BKK19-204 - Introduction to OpenAMP
Publication date: 2019-04-11
Playlist: Linaro Connect Bangkok 2019
Description: 
	Abstract
Open Asymmetric Multi-Processing (OpenAMP) provides an open source framework that allows operating systems to interact within a broad range of complex homogeneous and heterogeneous architectures and allows asymmetric multiprocessing applications to leverage parallelism offered by the multicore configuration.  This session will introduce the framework and how to use it.

Edward Mooring / Sr. Staff Engineer Xilinx
Captions: 
	00:00:07,860 --> 00:00:13,150
so it's trying to solve

00:00:09,830 --> 00:00:16,939
question when you have lots of different

00:00:13,150 --> 00:00:19,130
heterogeneous CPUs on an SOC or tightly

00:00:16,939 --> 00:00:21,980
bounded and you have multiple operating

00:00:19,130 --> 00:00:25,580
system environments how do you deal with

00:00:21,980 --> 00:00:27,039
that and hopefully we pretty soon we'll

00:00:25,580 --> 00:00:32,870
get some slides here here we go

00:00:27,039 --> 00:00:34,250
and so what we started to do was to do

00:00:32,870 --> 00:00:36,170
our own thing at tilings

00:00:34,250 --> 00:00:37,850
we come from stylings and then we

00:00:36,170 --> 00:00:41,360
realized that this is really not a

00:00:37,850 --> 00:00:45,320
secret sauce here how you send messages

00:00:41,360 --> 00:00:47,210
how you do lifecycle management start up

00:00:45,320 --> 00:00:49,220
something on another core and so on so

00:00:47,210 --> 00:00:50,720
forth configure that really should be

00:00:49,220 --> 00:00:52,970
something that's an industry standard

00:00:50,720 --> 00:00:55,489
yes what we did was that we looked

00:00:52,970 --> 00:00:56,750
around we saw some things out there in

00:00:55,489 --> 00:01:00,320
open source in Linux

00:00:56,750 --> 00:01:02,390
things like virtio remote proc RP

00:01:00,320 --> 00:01:05,330
message and we decided maybe we can be a

00:01:02,390 --> 00:01:07,460
little nod instead and try to enter some

00:01:05,330 --> 00:01:09,979
other companies to work with us on it

00:01:07,460 --> 00:01:13,240
and that's what open app is really all

00:01:09,979 --> 00:01:18,830
about and so currently we're working

00:01:13,240 --> 00:01:21,280
we're getting we're getting there let's

00:01:18,830 --> 00:01:21,280
say it is

00:01:26,100 --> 00:01:33,240
okay I can go to the next time so we've

00:01:30,479 --> 00:01:35,880
been working out for years and it

00:01:33,240 --> 00:01:39,000
started off as a working group within

00:01:35,880 --> 00:01:40,500
the multi-core Association and we've

00:01:39,000 --> 00:01:42,840
been working with a bunch of different

00:01:40,500 --> 00:01:50,750
companies and many of them are here like

00:01:42,840 --> 00:01:53,660
esta micro TI and XP when River micrium

00:01:50,750 --> 00:01:57,500
who else's been in there

00:01:53,660 --> 00:02:00,210
thread X Lenoir oh of course

00:01:57,500 --> 00:02:01,050
Qualcomm a little bit and so on so

00:02:00,210 --> 00:02:02,310
there's a bunch of different companies

00:02:01,050 --> 00:02:06,330
that been working on it

00:02:02,310 --> 00:02:09,570
and so this what we see here is one of

00:02:06,330 --> 00:02:12,450
our siding ships just as a demo how it

00:02:09,570 --> 00:02:14,760
works so we have a bunch of different

00:02:12,450 --> 00:02:17,700
course we have a cluster of a 50 threes

00:02:14,760 --> 00:02:19,709
so that's for typically running Linux

00:02:17,700 --> 00:02:22,560
sometimes with a hypervisor and then

00:02:19,709 --> 00:02:24,690
things on top of it and we have a bunch

00:02:22,560 --> 00:02:27,180
of our fives over here to go them

00:02:24,690 --> 00:02:30,000
quickly you run maybe something that's

00:02:27,180 --> 00:02:32,280
more real-time or something that needs

00:02:30,000 --> 00:02:34,799
to be safety certified on that one and

00:02:32,280 --> 00:02:36,360
then since we come from stylings we have

00:02:34,799 --> 00:02:38,310
what we call it programmable logic or

00:02:36,360 --> 00:02:40,709
the FPGA so in there you can have a

00:02:38,310 --> 00:02:42,810
bunch of other accelerators or course we

00:02:40,709 --> 00:02:44,940
have something called soft course called

00:02:42,810 --> 00:02:47,280
micro blaze so you can quite a few of

00:02:44,940 --> 00:02:49,890
those there as well so the question then

00:02:47,280 --> 00:02:52,200
is how do you deal with all that and

00:02:49,890 --> 00:02:54,360
it's not just the different various

00:02:52,200 --> 00:02:55,980
course that you have to deal with you

00:02:54,360 --> 00:02:59,880
also have all these different execution

00:02:55,980 --> 00:03:02,160
environments so for example on on the

00:02:59,880 --> 00:03:07,320
cortex a you have all this execution

00:03:02,160 --> 00:03:09,150
level from l0t l1 l2 and l3 right and so

00:03:07,320 --> 00:03:11,430
you have the user space the kernel space

00:03:09,150 --> 00:03:14,040
you have the hypervisor and the firmware

00:03:11,430 --> 00:03:17,790
and you have trust zones you have

00:03:14,040 --> 00:03:20,430
multiple security environment as well so

00:03:17,790 --> 00:03:21,560
the question then is if these guys want

00:03:20,430 --> 00:03:23,700
to talk to each other

00:03:21,560 --> 00:03:26,250
traditionally you come up with something

00:03:23,700 --> 00:03:28,350
ad hoc for each of them right then you

00:03:26,250 --> 00:03:30,930
have some shared memory and you have to

00:03:28,350 --> 00:03:32,880
configure it somehow so that you can see

00:03:30,930 --> 00:03:35,220
the same pages and then you do something

00:03:32,880 --> 00:03:40,070
ad hoc so we're trying to do is to

00:03:35,220 --> 00:03:40,070
standardize that at different levels

00:03:40,450 --> 00:03:46,640
so so basically asking these kind of

00:03:44,690 --> 00:03:48,830
questions how can you configure these

00:03:46,640 --> 00:03:50,810
kind of environments in the standard way

00:03:48,830 --> 00:03:52,490
how can you manage the life cycle

00:03:50,810 --> 00:03:54,290
meaning how can you start up something

00:03:52,490 --> 00:03:56,300
on another core I can you take it down

00:03:54,290 --> 00:03:58,700
health monitoring if something is

00:03:56,300 --> 00:04:00,950
happening how can you get get notified

00:03:58,700 --> 00:04:03,620
about that just contains how can you

00:04:00,950 --> 00:04:06,230
pass messages typically so far it's more

00:04:03,620 --> 00:04:08,030
control messages the data plane is

00:04:06,230 --> 00:04:11,209
typically in a different way but we're

00:04:08,030 --> 00:04:12,770
working on on being able to do zero copy

00:04:11,209 --> 00:04:15,980
and big bombers and stuff like that to

00:04:12,770 --> 00:04:17,870
be more efficient there how do you share

00:04:15,980 --> 00:04:21,890
resources let's say that they have a

00:04:17,870 --> 00:04:23,600
graphical device graphics card for

00:04:21,890 --> 00:04:25,280
example on the linux partition but then

00:04:23,600 --> 00:04:28,880
from your toast you want to access that

00:04:25,280 --> 00:04:32,810
how do you do that how do you simplify

00:04:28,880 --> 00:04:34,910
for autos vendors to port for different

00:04:32,810 --> 00:04:37,850
SOC so you have associate from stylings

00:04:34,910 --> 00:04:39,320
from SD micro and Ti and so on how can

00:04:37,850 --> 00:04:41,690
can we come up with an abstraction layer

00:04:39,320 --> 00:04:44,450
so that you can do the port ones basic

00:04:41,690 --> 00:04:47,030
and just do that abstraction layer so

00:04:44,450 --> 00:04:48,979
doing that and as I mentioned on top of

00:04:47,030 --> 00:04:50,240
the already existing products that's

00:04:48,979 --> 00:04:56,030
really what we're what we're all about

00:04:50,240 --> 00:04:57,650
but trying to to answer here and so

00:04:56,030 --> 00:04:59,810
there are a couple of sessions here so L

00:04:57,650 --> 00:05:03,260
is going to go into some of the details

00:04:59,810 --> 00:05:06,590
of what we're doing on the boat IO and

00:05:03,260 --> 00:05:08,419
the RP message and the remote probe when

00:05:06,590 --> 00:05:09,979
this coming later on to talk about lib

00:05:08,419 --> 00:05:12,950
metal so it's the lower level

00:05:09,979 --> 00:05:14,840
abstraction layer and we're also working

00:05:12,950 --> 00:05:16,610
on some other things on configuration

00:05:14,840 --> 00:05:18,800
with device trees and so we're not going

00:05:16,610 --> 00:05:21,140
to cover that here and there are a

00:05:18,800 --> 00:05:23,120
couple of other sessions tomorrow we

00:05:21,140 --> 00:05:25,729
have a meeting an open app meeting at 11

00:05:23,120 --> 00:05:27,130
o'clock so anyone who is interested can

00:05:25,729 --> 00:05:29,510
or

00:05:27,130 --> 00:05:35,090
invited to come and talk about that

00:05:29,510 --> 00:05:36,620
they're also on Thursday at 10:30 I'm

00:05:35,090 --> 00:05:38,480
doing a keynote where I will to talk a

00:05:36,620 --> 00:05:40,160
little bit about this but a little bit

00:05:38,480 --> 00:05:42,110
in a bigger bigger picture you cannot

00:05:40,160 --> 00:05:44,990
start there all right with that I'll

00:05:42,110 --> 00:05:50,840
give it over to earth to dive into the

00:05:44,990 --> 00:05:53,300
to the lower-level stuff thank you okay

00:05:50,840 --> 00:05:57,350
so fast executive summary of what we've

00:05:53,300 --> 00:05:59,330
done to open amps and open source

00:05:57,350 --> 00:06:01,340
framework and that's key for everything

00:05:59,330 --> 00:06:03,530
to interact with heterogeneous systems

00:06:01,340 --> 00:06:06,020
on a children heterogeneous meaning of

00:06:03,530 --> 00:06:09,790
course they've got you don't just have

00:06:06,020 --> 00:06:09,790
one kind of core you one two three

00:06:10,120 --> 00:06:14,710
facilitate use of resources for complex

00:06:13,550 --> 00:06:17,300
designs

00:06:14,710 --> 00:06:19,780
it's just both a standardization effort

00:06:17,300 --> 00:06:22,130
and an open-source project

00:06:19,780 --> 00:06:26,380
figure out what works then make that a

00:06:22,130 --> 00:06:30,650
standard do we get the other way Hertz

00:06:26,380 --> 00:06:33,020
we've been evolving it slowly so first

00:06:30,650 --> 00:06:35,660
the AP use master we've just got the RP

00:06:33,020 --> 00:06:37,250
you as master so instead of having

00:06:35,660 --> 00:06:40,010
everything run off the Linux you can now

00:06:37,250 --> 00:06:42,140
run it off the real time safe or safety

00:06:40,010 --> 00:06:46,220
certified course and that makes safety

00:06:42,140 --> 00:06:48,440
people happy but we're working on

00:06:46,220 --> 00:06:51,290
authentication and so forth and

00:06:48,440 --> 00:06:53,780
decryption for executables multiple

00:06:51,290 --> 00:06:57,050
types of memory coherency between

00:06:53,780 --> 00:06:59,740
systems all those fun things that happen

00:06:57,050 --> 00:07:02,120
about the low-level and then managing

00:06:59,740 --> 00:07:04,610
arbitrary executables begin to load

00:07:02,120 --> 00:07:06,370
anything into right now we can load

00:07:04,610 --> 00:07:11,260
anything into the RP you from the agent

00:07:06,370 --> 00:07:13,760
and then actually managing our own

00:07:11,260 --> 00:07:17,230
implementation so that we could we can

00:07:13,760 --> 00:07:17,230
be updated update ourselves on the fly

00:07:18,550 --> 00:07:22,120
a quick glossary because they threw a

00:07:20,110 --> 00:07:30,280
bunch of acronyms out there I'm sure

00:07:22,120 --> 00:07:34,199
most of you were give you a brief moment

00:07:30,280 --> 00:07:34,199
we get them in your heads

00:07:35,470 --> 00:07:41,550
so the heterogeneous architectures

00:07:37,840 --> 00:07:46,090
practically forced on the people by the

00:07:41,550 --> 00:07:47,110
complicated chips that Thomas was

00:07:46,090 --> 00:07:52,449
describing earlier

00:07:47,110 --> 00:07:55,870
you can't run Linux on cortex are you

00:07:52,449 --> 00:07:57,909
really can't run the same OS on the

00:07:55,870 --> 00:08:00,400
armors in the haze you certainly can't

00:07:57,909 --> 00:08:03,550
run a conventional symmetric

00:08:00,400 --> 00:08:08,919
multiprocessing GPUs are still

00:08:03,550 --> 00:08:10,840
abstracted out because they use a good

00:08:08,919 --> 00:08:12,970
candidate for Linux our views are a good

00:08:10,840 --> 00:08:18,520
candidate for an artists or safety

00:08:12,970 --> 00:08:24,849
certified system you could solve this on

00:08:18,520 --> 00:08:27,539
a machine with heterogeneous cores by

00:08:24,849 --> 00:08:30,340
either using a hypervisor or

00:08:27,539 --> 00:08:33,270
unsupervised am team but the safety

00:08:30,340 --> 00:08:38,770
folks won't like the unsupervised a.m. P

00:08:33,270 --> 00:08:40,810
so that's where we thats where we sit we

00:08:38,770 --> 00:08:43,029
have a heterogeneous architecture kind

00:08:40,810 --> 00:08:51,310
of forced on to us by the way the

00:08:43,029 --> 00:08:54,790
systems are architected so we've got the

00:08:51,310 --> 00:08:56,290
APU running some cores probably maybe if

00:08:54,790 --> 00:08:57,579
it's a hypervisor you get a mix like

00:08:56,290 --> 00:09:00,240
this otherwise that all having the

00:08:57,579 --> 00:09:02,800
Penguins off them and then you got a

00:09:00,240 --> 00:09:05,649
couple of other cores which could be the

00:09:02,800 --> 00:09:13,209
rpu which are the a5 type cores which

00:09:05,649 --> 00:09:17,030
could be running in lockstep or with a

00:09:13,209 --> 00:09:20,780
some form of limited a MP

00:09:17,030 --> 00:09:21,980
and and shared and partitioned memory

00:09:20,780 --> 00:09:25,670
with a very small shared regional

00:09:21,980 --> 00:09:28,310
support but then you got to talk between

00:09:25,670 --> 00:09:33,380
them and that's the weird isn't that

00:09:28,310 --> 00:09:36,440
that's the question so the interface is

00:09:33,380 --> 00:09:38,840
going to be very device specific it

00:09:36,440 --> 00:09:42,470
whatever works on it on st probably

00:09:38,840 --> 00:09:44,240
won't work on his ancient and the

00:09:42,470 --> 00:09:46,240
abstraction are more complicated because

00:09:44,240 --> 00:09:48,950
the underlying systems were complicated

00:09:46,240 --> 00:09:52,070
so it would be nice to have an openly

00:09:48,950 --> 00:09:54,260
documented framework we could use to at

00:09:52,070 --> 00:09:55,490
least rank the higher level software and

00:09:54,260 --> 00:10:02,600
when they have to write the lower level

00:09:55,490 --> 00:10:07,130
software once so these systems aren't

00:10:02,600 --> 00:10:08,690
that new and people are but people are

00:10:07,130 --> 00:10:11,630
trying to get closer access to the bare

00:10:08,690 --> 00:10:13,310
metal and be able to run not have to

00:10:11,630 --> 00:10:15,280
rewrite their entire application stack

00:10:13,310 --> 00:10:18,800
every time they make a hardware decision

00:10:15,280 --> 00:10:23,350
so linux first came up with RP message

00:10:18,800 --> 00:10:28,420
and remote product eight years ago

00:10:23,350 --> 00:10:31,130
remote processor relies the Linux

00:10:28,420 --> 00:10:35,360
provides a driver framework for Linux to

00:10:31,130 --> 00:10:38,590
manage remote this in not part of the

00:10:35,360 --> 00:10:41,480
same SMP flustered hardware and

00:10:38,590 --> 00:10:43,990
processor map messaging provides for a

00:10:41,480 --> 00:10:49,130
structured mechanism for communication

00:10:43,990 --> 00:10:50,660
it's I believe it's a little over 500

00:10:49,130 --> 00:10:54,050
bytes long I don't remember the exact

00:10:50,660 --> 00:10:55,460
number so it's short messages but it's a

00:10:54,050 --> 00:10:58,420
way of exchanging messages and

00:10:55,460 --> 00:10:58,420
describing endpoints

00:11:02,900 --> 00:11:12,589
so yeah 324 introduced 3.41

00:11:08,480 --> 00:11:18,820
two responsibilities management starting

00:11:12,589 --> 00:11:23,600
and stopping remote processors this

00:11:18,820 --> 00:11:25,520
framework was originally limited the

00:11:23,600 --> 00:11:28,279
Linux expect to be the master no

00:11:25,520 --> 00:11:30,050
surprise there and no framework provided

00:11:28,279 --> 00:11:35,779
for room for firmware on remote

00:11:30,050 --> 00:11:39,850
processors and that's where open A&P

00:11:35,779 --> 00:11:42,650
came in jumping a little out of order

00:11:39,850 --> 00:11:48,740
mental actions provided the first

00:11:42,650 --> 00:11:51,410
implementation in 2014 well I don't know

00:11:48,740 --> 00:11:53,690
exactly the timeline mentor provided it

00:11:51,410 --> 00:11:56,570
and then silence and mentor partnered

00:11:53,690 --> 00:11:59,120
partnered introduces it's a cleanroom

00:11:56,570 --> 00:12:01,490
implementation of the RP message

00:11:59,120 --> 00:12:07,640
remote proc framework under a state

00:12:01,490 --> 00:12:11,990
license and expands the scope so we can

00:12:07,640 --> 00:12:14,200
now run a master processor as on the RT

00:12:11,990 --> 00:12:14,200
you

00:12:18,390 --> 00:12:24,340
standardizes how how the OS is interact

00:12:21,480 --> 00:12:26,710
between the little between linux and so

00:12:24,340 --> 00:12:32,590
and whatever is on the Archos or bare

00:12:26,710 --> 00:12:34,480
metal lifecycle AP on these inter

00:12:32,590 --> 00:12:38,560
process communication shared memory

00:12:34,480 --> 00:12:40,330
control and it's under a certain limited

00:12:38,560 --> 00:12:43,660
set of guiding principles open source

00:12:40,330 --> 00:12:46,030
implementation prototyping an open

00:12:43,660 --> 00:12:50,500
source make sure it works before we

00:12:46,030 --> 00:12:53,020
standardize it and again in keeping with

00:12:50,500 --> 00:12:56,440
the licensing model and so forth

00:12:53,020 --> 00:12:58,870
business friendly so that everybody can

00:12:56,440 --> 00:13:07,330
build off this whether they're building

00:12:58,870 --> 00:13:11,020
a proprietary system or not it consists

00:13:07,330 --> 00:13:13,810
of kind of a multi-layered set of

00:13:11,020 --> 00:13:18,400
libraries there's the lifecycle

00:13:13,810 --> 00:13:20,860
management interpreted which controls

00:13:18,400 --> 00:13:22,060
the processors and even loading firmware

00:13:20,860 --> 00:13:25,060
which is one of the things that has

00:13:22,060 --> 00:13:28,060
taken a step forward from the lid from

00:13:25,060 --> 00:13:29,700
the original designs inter process

00:13:28,060 --> 00:13:33,360
communication

00:13:29,700 --> 00:13:37,060
proxy operations which is where we can

00:13:33,360 --> 00:13:40,180
from and this is typically from the

00:13:37,060 --> 00:13:43,480
Linux side to the arm to the Archos side

00:13:40,180 --> 00:13:49,840
we provide a proxy that allows

00:13:43,480 --> 00:13:52,210
effectively RPC from the real-time side

00:13:49,840 --> 00:13:54,640
to the Linux side for access to things

00:13:52,210 --> 00:13:57,580
like complex things like file systems or

00:13:54,640 --> 00:13:59,290
graphics cards that you really don't

00:13:57,580 --> 00:14:02,110
want to try to fit in if it's a

00:13:59,290 --> 00:14:08,110
reasonable size graphics driver into an

00:14:02,110 --> 00:14:11,590
a5 and then live metal which Wendy will

00:14:08,110 --> 00:14:13,390
talk more about which is a key

00:14:11,590 --> 00:14:18,210
abstraction layer in the whole thing

00:14:13,390 --> 00:14:24,330
because it provides a hardware and OS

00:14:18,210 --> 00:14:27,870
independent way mechanism for accessing

00:14:24,330 --> 00:14:31,860
resources and including things like like

00:14:27,870 --> 00:14:36,150
memory shared memory kinds software

00:14:31,860 --> 00:14:40,050
interrupts and then we're on going

00:14:36,150 --> 00:14:41,700
trying to decouple Wendy who knows more

00:14:40,050 --> 00:14:44,370
about this process where we are in the

00:14:41,700 --> 00:14:47,660
process we decouple the remote croc and

00:14:44,370 --> 00:14:50,070
our key message implementations to allow

00:14:47,660 --> 00:14:56,310
being able to select one or the other

00:14:50,070 --> 00:14:58,980
for constrained environments so Lin

00:14:56,310 --> 00:15:02,580
exampie knows no support for firmware in

00:14:58,980 --> 00:15:07,770
remote processors must run Linux the

00:15:02,580 --> 00:15:10,560
level device code not so much their user

00:15:07,770 --> 00:15:12,680
libraries so open and he is now user

00:15:10,560 --> 00:15:16,680
made libraries instead of the kernel and

00:15:12,680 --> 00:15:19,770
adds the support further the more

00:15:16,680 --> 00:15:21,960
constrained to west environments no

00:15:19,770 --> 00:15:23,790
longer needs to be linux based and with

00:15:21,960 --> 00:15:30,740
Lib metal provides an abstraction layer

00:15:23,790 --> 00:15:30,740
to the hardware that allows for

00:15:30,830 --> 00:15:34,590
portability of the more application

00:15:33,090 --> 00:15:35,700
layer specific code across the different

00:15:34,590 --> 00:15:38,270
prop of the different kinds of

00:15:35,700 --> 00:15:38,270
processors

00:15:43,290 --> 00:15:52,110
so remote Proctor bike the api's

00:15:47,300 --> 00:15:54,420
hardware configuration power on/off

00:15:52,110 --> 00:15:57,300
power off resource locating allocation

00:15:54,420 --> 00:15:59,610
so we can actually tell the remote what

00:15:57,300 --> 00:16:02,180
resources it has access to and configure

00:15:59,610 --> 00:16:02,180
it accordingly

00:16:12,180 --> 00:16:17,820
again there is a this is done over vert

00:16:15,510 --> 00:16:19,800
we can do this over Verdi oh so the

00:16:17,820 --> 00:16:23,130
messages are running as Verdi oh devices

00:16:19,800 --> 00:16:26,420
I don't know if I would suspect pretty

00:16:23,130 --> 00:16:29,510
much all of you are familiar with Verdi

00:16:26,420 --> 00:16:33,050
so it provides only the vendor agnostic

00:16:29,510 --> 00:16:35,760
forums of the messaging at this level

00:16:33,050 --> 00:16:42,990
remote Prok for device specific device

00:16:35,760 --> 00:16:45,090
handling and live metal for some stuff I

00:16:42,990 --> 00:16:49,860
know some of you are extremely familiar

00:16:45,090 --> 00:16:54,120
with Verdi oh it's a abstraction layer

00:16:49,860 --> 00:16:58,770
that provides for it originally was

00:16:54,120 --> 00:17:00,990
designed to get to allow Linux to Linux

00:16:58,770 --> 00:17:03,330
devices to efficiently access hypervisor

00:17:00,990 --> 00:17:07,490
resources but the concept is just

00:17:03,330 --> 00:17:10,410
extremely useful being able to provide a

00:17:07,490 --> 00:17:12,510
common device hardware abstraction layer

00:17:10,410 --> 00:17:16,290
for a whole variety of underlying

00:17:12,510 --> 00:17:21,959
interpretations and again it's a

00:17:16,290 --> 00:17:25,230
standard so you so if you did it for

00:17:21,959 --> 00:17:29,040
window if you did it for Windows it'll

00:17:25,230 --> 00:17:31,710
probably did avert I own device that

00:17:29,040 --> 00:17:32,940
Windows recognizes it might even be

00:17:31,710 --> 00:17:48,510
recognized by Linux without any

00:17:32,940 --> 00:17:49,950
modification but it's a fundamental

00:17:48,510 --> 00:17:52,140
piece of the overall open app

00:17:49,950 --> 00:17:55,230
architecture you take that away you've

00:17:52,140 --> 00:17:58,950
got some nice abstractions with nothing

00:17:55,230 --> 00:18:00,360
to talk to and I'm gonna be deliberately

00:17:58,950 --> 00:18:03,080
brief here because I'm gonna let Wendy

00:18:00,360 --> 00:18:03,080
talk more about

00:18:05,810 --> 00:18:12,540
you want me not for me to go out okay so

00:18:09,540 --> 00:18:14,610
yeah it's it can be done from Linux user

00:18:12,540 --> 00:18:16,980
space now with you FIO and vfi to

00:18:14,610 --> 00:18:21,570
support in the kernel works on our

00:18:16,980 --> 00:18:25,020
tosses where it's unbearable handles all

00:18:21,570 --> 00:18:31,640
of those ir irq and read and write from

00:18:25,020 --> 00:18:34,500
devices so the the primitives so this

00:18:31,640 --> 00:18:39,570
metal io writes probably just gonna wrap

00:18:34,500 --> 00:18:41,910
itself around to some calls to read but

00:18:39,570 --> 00:18:44,100
on bare metal it's probably just gonna

00:18:41,910 --> 00:18:50,100
directly access a register or three

00:18:44,100 --> 00:18:51,510
somewhere ir queues open close and then

00:18:50,100 --> 00:18:53,730
there's a set of shared memory things

00:18:51,510 --> 00:18:56,820
which is that which when he definitely

00:18:53,730 --> 00:19:00,210
knows more on write and synchronization

00:18:56,820 --> 00:19:02,130
primitives this you do need to

00:19:00,210 --> 00:19:06,630
synchronize we do need to synchronize

00:19:02,130 --> 00:19:11,790
between heterogeneous cores which is

00:19:06,630 --> 00:19:14,430
exciting remote RP message in Verdejo

00:19:11,790 --> 00:19:16,880
all you slid metal underneath to achieve

00:19:14,430 --> 00:19:16,880
their goals

00:19:27,670 --> 00:19:32,380
so remote products startup we've got it

00:19:30,730 --> 00:19:35,310
we've got a master running and the

00:19:32,380 --> 00:19:40,360
remote processes standby our power down

00:19:35,310 --> 00:19:42,780
load up some firmware the absolutely

00:19:40,360 --> 00:19:46,150
have abstractions for doing that so

00:19:42,780 --> 00:19:49,210
figuring it so you don't have to write

00:19:46,150 --> 00:19:50,650
the code every time to figure it out you

00:19:49,210 --> 00:19:58,210
get somebody like sighted eggs to write

00:19:50,650 --> 00:20:00,640
it for you once processor wait for an

00:19:58,210 --> 00:20:02,830
acknowledgment that is and then

00:20:00,640 --> 00:20:10,960
establish a communication channel for

00:20:02,830 --> 00:20:13,030
control using remote proc then there's a

00:20:10,960 --> 00:20:16,090
similar process on the way back down

00:20:13,030 --> 00:20:18,400
where you would use a remote Proctor

00:20:16,090 --> 00:20:20,860
tell it to quiesce and then wait for the

00:20:18,400 --> 00:20:24,270
message that it quiesce or a timeout and

00:20:20,860 --> 00:20:24,270
then actually powered out

00:20:29,330 --> 00:20:33,759
now who does now who gets all this magic

00:20:35,590 --> 00:20:41,830
well the vendor which either artists or

00:20:43,330 --> 00:20:48,289
the low-level courting for their

00:20:45,440 --> 00:20:52,009
specific platforms the lid metal

00:20:48,289 --> 00:20:54,110
interfaces and providing whatever magic

00:20:52,009 --> 00:20:57,379
constants need to be in device trees and

00:20:54,110 --> 00:20:58,970
things like that and then an application

00:20:57,379 --> 00:21:02,929
that includes a demonstration of the

00:20:58,970 --> 00:21:07,549
resource table a couple of basic

00:21:02,929 --> 00:21:14,629
applications the Linux RP message driver

00:21:07,549 --> 00:21:17,869
and kernel modules and things for just

00:21:14,629 --> 00:21:21,350
showing how to use this because of

00:21:17,869 --> 00:21:23,450
course the best the easiest way to get

00:21:21,350 --> 00:21:25,369
something work you just have something

00:21:23,450 --> 00:21:33,440
that works that does almost what you

00:21:25,369 --> 00:21:39,859
want status active evolving community

00:21:33,440 --> 00:21:42,169
project it's on github right now they're

00:21:39,859 --> 00:21:45,529
moving it's a it's still oh definitely a

00:21:42,169 --> 00:21:47,749
work in progress the well the source

00:21:45,529 --> 00:21:50,690
structures and protocol has been pretty

00:21:47,749 --> 00:21:56,690
is been pretty well stable with

00:21:50,690 --> 00:21:58,700
extensions yeah I piece the IPC

00:21:56,690 --> 00:22:00,649
mechanisms need performance improvements

00:21:58,700 --> 00:22:02,299
right now they're suitable for

00:22:00,649 --> 00:22:06,289
relatively low volume control plane

00:22:02,299 --> 00:22:11,239
traffic but people keep asking for

00:22:06,289 --> 00:22:17,619
can I put video over it commercially

00:22:11,239 --> 00:22:21,679
available on most on quite a few things

00:22:17,619 --> 00:22:24,999
open source Zephyr Linux free artist

00:22:21,679 --> 00:22:24,999
that we know of

00:22:26,920 --> 00:22:31,520
yeah still a lot of porting work to do

00:22:29,810 --> 00:22:39,560
if we want to get it universally want at

00:22:31,520 --> 00:22:42,740
universal domination support message

00:22:39,560 --> 00:22:46,280
passing final system versus the croc

00:22:42,740 --> 00:22:54,640
lock devices graphics again those are

00:22:46,280 --> 00:22:57,200
via remote be a ver do variety of

00:22:54,640 --> 00:23:00,620
environments kernel and user space are

00:22:57,200 --> 00:23:05,270
tossed Zephyr and bare metal several

00:23:00,620 --> 00:23:07,100
processor architectures secure and

00:23:05,270 --> 00:23:10,700
non-secure modes threads and processes

00:23:07,100 --> 00:23:12,800
where they're supported and virtualized

00:23:10,700 --> 00:23:20,330
guests and containers with the

00:23:12,800 --> 00:23:23,150
hypervisor you should be able to expose

00:23:20,330 --> 00:23:30,680
a guest to our key message via Verdi on

00:23:23,150 --> 00:23:32,630
a hypervisor it provides a soft a

00:23:30,680 --> 00:23:35,000
framework for access to these

00:23:32,630 --> 00:23:36,950
heterogeneous systems loading firmware

00:23:35,000 --> 00:23:42,410
communicating and basically running the

00:23:36,950 --> 00:23:45,170
system in a platform agnostic manner and

00:23:42,410 --> 00:23:48,640
that's where we are and I think I have

00:23:45,170 --> 00:23:48,640
about two minutes to answer questions

00:23:50,970 --> 00:23:53,720
yes sir

00:23:56,240 --> 00:24:02,990
is there possibility to use like DMA to

00:24:00,270 --> 00:24:02,990
copy/paste

00:24:05,120 --> 00:24:20,880
we are actively working on that are

00:24:18,180 --> 00:24:27,270
there any year was a performance penalty

00:24:20,880 --> 00:24:34,260
for boot time in ER when we put this

00:24:27,270 --> 00:24:37,500
Visser libraries in tutor autos for

00:24:34,260 --> 00:24:43,620
example additional interest a shim or

00:24:37,500 --> 00:24:48,060
something like that that's going to

00:24:43,620 --> 00:24:49,560
depend on the straw the boot is

00:24:48,060 --> 00:24:52,500
structured it because if it's waiting

00:24:49,560 --> 00:24:53,520
for if it has to wait for the RP message

00:24:52,500 --> 00:24:55,770
to come up there might be some

00:24:53,520 --> 00:24:58,080
additional delay if it doesn't have to

00:24:55,770 --> 00:24:59,880
wait to do its key functions then the

00:24:58,080 --> 00:25:02,370
delay then of course their delay be much

00:24:59,880 --> 00:25:05,310
less it's if we will introduce a little

00:25:02,370 --> 00:25:08,520
bit of delay because it's more code just

00:25:05,310 --> 00:25:11,010
to add to that so multiple way building

00:25:08,520 --> 00:25:13,170
one way is to have the firmware both

00:25:11,010 --> 00:25:14,940
both petitions basically and then you

00:25:13,170 --> 00:25:17,400
attach later on so that's something we

00:25:14,940 --> 00:25:18,960
have it and then it doesn't affect I

00:25:17,400 --> 00:25:21,390
might alter if you let something like

00:25:18,960 --> 00:25:24,630
you both whatever built everything or

00:25:21,390 --> 00:25:27,600
you can go and first say Linux and then

00:25:24,630 --> 00:25:28,680
from Linux you start the artists for

00:25:27,600 --> 00:25:30,600
example then of course it will take

00:25:28,680 --> 00:25:33,630
longer before the artists appear on it

00:25:30,600 --> 00:25:36,140
so it covers all those use cases okay

00:25:33,630 --> 00:25:36,140
thank you

00:25:37,840 --> 00:25:43,600
I don't see what else regarding

00:25:40,690 --> 00:25:58,600
networking is it oh I remember there's

00:25:43,600 --> 00:26:01,030
like a 512 by that's not really a use

00:25:58,600 --> 00:26:03,520
case it was designed we are looking at

00:26:01,030 --> 00:26:07,000
making the buffers more configurable but

00:26:03,520 --> 00:26:08,440
it's still not really you be running tin

00:26:07,000 --> 00:26:19,300
cans and string kind of network

00:26:08,440 --> 00:26:20,620
performance actually I know one auto

00:26:19,300 --> 00:26:22,000
offenders they so they've been using

00:26:20,620 --> 00:26:24,310
this but they have been adding some

00:26:22,000 --> 00:26:26,380
stuff today are you saying graphics card

00:26:24,310 --> 00:26:28,240
and so on so that they've gotten quite a

00:26:26,380 --> 00:26:30,010
bit of performance but what they do is

00:26:28,240 --> 00:26:31,660
that they pass over just a pointer to

00:26:30,010 --> 00:26:33,370
the memory where that where they have

00:26:31,660 --> 00:26:35,800
the big buffer so that's something we're

00:26:33,370 --> 00:26:37,840
looking at adding into into the code as

00:26:35,800 --> 00:26:40,170
well then we can get a bit better state

00:26:37,840 --> 00:26:40,170
of course

00:26:44,710 --> 00:26:50,380

YouTube URL: https://www.youtube.com/watch?v=j9GCOpB3C7M


