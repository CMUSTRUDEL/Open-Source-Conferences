Title: BKK19-PM01: PMWG: CPU Idle governor and irq prediction
Publication date: 2019-04-05
Playlist: Linaro Connect Bangkok 2019
Description: 
	CPU Idle governor and irq prediction
Captions: 
	00:00:05,960 --> 00:00:12,500
okay this a concession is about

00:00:08,700 --> 00:00:12,500
discussing sorry for being late

00:00:12,590 --> 00:00:20,890
it's an a concessions

00:00:15,610 --> 00:00:24,220
discussion after the presentation we had

00:00:20,890 --> 00:00:30,930
yesterday about treating the next event

00:00:24,220 --> 00:00:33,880
on the system and while we were doing

00:00:30,930 --> 00:00:37,469
implementing this solution we were

00:00:33,880 --> 00:00:41,379
facing some issues with the measurements

00:00:37,469 --> 00:00:49,990
the first the first one was the exit

00:00:41,379 --> 00:00:52,870
latencies so we saw with the exit

00:00:49,990 --> 00:00:56,380
latencies we saw when we we want to do

00:00:52,870 --> 00:00:59,800
statistics we measure intervals so the

00:00:56,380 --> 00:01:03,220
previous the current approach is to

00:00:59,800 --> 00:01:05,799
measure the duration between the moment

00:01:03,220 --> 00:01:09,759
when we enter either and the moment when

00:01:05,799 --> 00:01:14,290
we exit either the point of the

00:01:09,759 --> 00:01:17,890
measurement is to get a get local local

00:01:14,290 --> 00:01:22,270
clock and that can happen only when the

00:01:17,890 --> 00:01:24,520
CPU fully wake up from the sleep state

00:01:22,270 --> 00:01:26,440
that means there is a latency between

00:01:24,520 --> 00:01:29,620
the real moment when the heaven the

00:01:26,440 --> 00:01:32,770
effort our happen on the system and the

00:01:29,620 --> 00:01:38,890
moment when we can measure this value so

00:01:32,770 --> 00:01:45,909
we have the characteristic of the to

00:01:38,890 --> 00:01:49,000
exit the exit latencies yeah so we have

00:01:45,909 --> 00:01:51,580
to learn the characteristic of the other

00:01:49,000 --> 00:01:56,049
idols that we exit latencies this exit

00:01:51,580 --> 00:01:58,540
latency is not constant and that's

00:01:56,049 --> 00:02:01,450
especially true when we have a trust

00:01:58,540 --> 00:02:05,799
Rider state that means the first CPU

00:02:01,450 --> 00:02:08,549
waking up will have less latency which

00:02:05,799 --> 00:02:11,890
is higher than the other CPU and

00:02:08,549 --> 00:02:15,099
expecting if the orders of you are not

00:02:11,890 --> 00:02:17,680
waking up at the same time that tooth we

00:02:15,099 --> 00:02:20,739
are waiting for the first view to finish

00:02:17,680 --> 00:02:25,030
the accomplishment of the task of

00:02:20,739 --> 00:02:28,030
working out the cluster so that means we

00:02:25,030 --> 00:02:31,720
have a variable exist latency and this

00:02:28,030 --> 00:02:34,330
access latency is is not negligible it's

00:02:31,720 --> 00:02:38,790
a significant impact in the measurement

00:02:34,330 --> 00:02:41,920
because it can be up to 2 or 3

00:02:38,790 --> 00:02:44,800
millisecond so it's a lot because it's

00:02:41,920 --> 00:02:48,370
almost the size of the target residency

00:02:44,800 --> 00:02:51,250
that means when we measure the sleep

00:02:48,370 --> 00:02:53,050
duration we measure also do is eat at

00:02:51,250 --> 00:02:55,330
and see with this little the duration

00:02:53,050 --> 00:02:58,420
and when we try to do prediction on the

00:02:55,330 --> 00:03:01,420
next sleep duration we take into account

00:02:58,420 --> 00:03:04,480
this exit latency and then we think we

00:03:01,420 --> 00:03:07,720
can go in deep either states but we

00:03:04,480 --> 00:03:11,020
can't actually because we just assumed

00:03:07,720 --> 00:03:14,890
the sleep duration in addition with the

00:03:11,020 --> 00:03:20,190
wakeup latency so I don't know if one of

00:03:14,890 --> 00:03:23,890
you took into account this kind of

00:03:20,190 --> 00:03:28,060
change in the exit latency

00:03:23,890 --> 00:03:30,640
now what in the computation we retrieve

00:03:28,060 --> 00:03:35,050
the exit latency when we have the sleep

00:03:30,640 --> 00:03:36,879
duration but with the cluster state this

00:03:35,050 --> 00:03:41,260
exit and see depending of the OPP

00:03:36,879 --> 00:03:43,780
depending on the on the fact first CPU

00:03:41,260 --> 00:03:45,970
exiting the crystal state or not can be

00:03:43,780 --> 00:03:52,330
there can be a very very big difference

00:03:45,970 --> 00:03:57,519
so I had no idea to implement dynamic

00:03:52,330 --> 00:04:00,010
exit latencies so at runtime we try to

00:03:57,519 --> 00:04:03,849
change depending on the state the state

00:04:00,010 --> 00:04:06,420
of the cluster will change the the exit

00:04:03,849 --> 00:04:06,420
latency

00:04:11,380 --> 00:04:14,940
I know what will be the performance

00:04:18,989 --> 00:04:26,729
I mean you mean that when you wake up

00:04:23,030 --> 00:04:28,229
you want to notify the other CPU that

00:04:26,729 --> 00:04:31,560
they like to wake up at hancinema

00:04:28,229 --> 00:04:35,210
shorter because they will not be yeah

00:04:31,560 --> 00:04:38,190
but that's too late at this moment

00:04:35,210 --> 00:04:40,020
because if the other took the decision

00:04:38,190 --> 00:04:48,319
to go to the cluster state they already

00:04:40,020 --> 00:04:48,319
choose the idle state but when we exit

00:04:49,849 --> 00:04:58,349
when we are what we want what we want is

00:04:52,889 --> 00:05:02,789
to be as much accurate as possible when

00:04:58,349 --> 00:05:07,440
we measure the sleep duration so when we

00:05:02,789 --> 00:05:09,630
exit the cluster state we know that we

00:05:07,440 --> 00:05:11,340
are the first one exit in the cluster

00:05:09,630 --> 00:05:15,539
state so we know that the exit latency

00:05:11,340 --> 00:05:18,840
is iyer so we can subtract from the stip

00:05:15,539 --> 00:05:21,750
duration this exit latency and the other

00:05:18,840 --> 00:05:23,820
CPU working up which is not if it's not

00:05:21,750 --> 00:05:25,889
the first one exiting the cluster state

00:05:23,820 --> 00:05:28,440
we know that the exit latency in this

00:05:25,889 --> 00:05:36,860
case is shorter so we can retrieve this

00:05:28,440 --> 00:05:42,060
exit latency from the sleep duration yes

00:05:36,860 --> 00:05:48,210
yes I think it's if we do best efforts

00:05:42,060 --> 00:05:51,419
should be just based on scat domains and

00:05:48,210 --> 00:05:56,180
let the skid domains tell okay all

00:05:51,419 --> 00:05:56,180
domain is either something like that

00:05:59,090 --> 00:06:04,849
there isn't a parent's cat demand for

00:06:02,130 --> 00:06:04,849
the crystal

00:06:11,800 --> 00:06:48,039
yeah this is a critical section which

00:06:45,410 --> 00:06:50,990
mean that so what you're proposing

00:06:48,039 --> 00:06:55,430
should work for small systems like

00:06:50,990 --> 00:06:59,449
mobile phone what about server-side when

00:06:55,430 --> 00:07:03,680
you have 128 code can we have can we

00:06:59,449 --> 00:07:08,389
have cristal for one 100 states it has

00:07:03,680 --> 00:07:09,650
eight eight fing eight I think most of

00:07:08,389 --> 00:07:11,090
the big ones actually have very small

00:07:09,650 --> 00:07:13,520
clusters you typically have a lot of

00:07:11,090 --> 00:07:15,380
clusters but only two or four CPUs yes

00:07:13,520 --> 00:07:17,419
so you could have eight CPUs net just

00:07:15,380 --> 00:07:19,729
about as far as I can tell most of the

00:07:17,419 --> 00:07:21,669
big big systems have much smaller

00:07:19,729 --> 00:07:24,650
clusters okay

00:07:21,669 --> 00:07:27,020
so they are trying to make disappear the

00:07:24,650 --> 00:07:27,590
clusters and sing just being in the CPU

00:07:27,020 --> 00:07:29,560
bases

00:07:27,590 --> 00:07:32,419
I think it's mainly because of caching

00:07:29,560 --> 00:07:34,250
characteristics you want that it gets

00:07:32,419 --> 00:07:36,650
better if you mix the clusters a little

00:07:34,250 --> 00:07:38,509
smaller but not not just one CPU you

00:07:36,650 --> 00:07:40,810
could also have clusters of just one CPU

00:07:38,509 --> 00:07:44,180
but for some reason you don't get that

00:07:40,810 --> 00:07:48,759
okay so it's the most of them that I see

00:07:44,180 --> 00:07:48,759
I have two or four okay

00:07:51,740 --> 00:08:32,539
I mean okay I have a different worry

00:08:28,400 --> 00:08:37,729
yeah which is I can't tell how strongly

00:08:32,539 --> 00:08:40,370
correlated then the estimate would be

00:08:37,729 --> 00:08:42,620
when you go to sleep you know whether

00:08:40,370 --> 00:08:46,040
you are the only one in the cluster or

00:08:42,620 --> 00:08:47,959
not but that doesn't mean that you will

00:08:46,040 --> 00:08:50,300
be the last that the first one to wake

00:08:47,959 --> 00:08:53,060
up when the wakeup counts so if you have

00:08:50,300 --> 00:08:56,270
two CPUs in a cluster and they both go

00:08:53,060 --> 00:08:58,760
to sleep then one of them will see that

00:08:56,270 --> 00:09:00,350
it's there's still another CPU so it's

00:08:58,760 --> 00:09:02,690
not the last one the second one will see

00:09:00,350 --> 00:09:05,029
that it is the last one and so they they

00:09:02,690 --> 00:09:08,089
would see different expectations for the

00:09:05,029 --> 00:09:10,370
wakeup latency but then there's in the

00:09:08,089 --> 00:09:13,490
end the two two CPU example there might

00:09:10,370 --> 00:09:15,880
be zero correlation between who goes to

00:09:13,490 --> 00:09:19,490
sleep first and who wakes up first

00:09:15,880 --> 00:09:22,100
not sure how how good you can estimate

00:09:19,490 --> 00:09:24,550
that but you can you can estimate if you

00:09:22,100 --> 00:09:26,779
are the first one not when you wake up

00:09:24,550 --> 00:09:28,910
because what is interesting is you

00:09:26,779 --> 00:09:32,000
measure the idle duration so when when

00:09:28,910 --> 00:09:34,370
you exit what what you're interested in

00:09:32,000 --> 00:09:36,350
is the point where you you are

00:09:34,370 --> 00:09:38,750
effectively wake up when you receive the

00:09:36,350 --> 00:09:41,270
event and the point - there is a gap

00:09:38,750 --> 00:09:47,930
between the point when you are you you

00:09:41,270 --> 00:09:51,620
are wake up woken up and the point where

00:09:47,930 --> 00:09:54,290
you can measure so where the CPU can

00:09:51,620 --> 00:09:59,570
operate instruction to cool to do the

00:09:54,290 --> 00:10:01,490
local clock so this this gap is shorter

00:09:59,570 --> 00:10:03,080
if you are the first one you know that

00:10:01,490 --> 00:10:05,570
this the exit and see

00:10:03,080 --> 00:10:06,800
is iron because you are in across the

00:10:05,570 --> 00:10:10,160
state 'you know you are you are the

00:10:06,800 --> 00:10:11,870
first one right but how where does the

00:10:10,160 --> 00:10:13,490
information come from that lets you know

00:10:11,870 --> 00:10:15,380
whether you will be the first one to

00:10:13,490 --> 00:10:18,170
wake up or not because you don't have an

00:10:15,380 --> 00:10:20,330
estimate of whether the other cpu is

00:10:18,170 --> 00:10:22,459
going to be at sleep by the time when

00:10:20,330 --> 00:10:24,050
you wake up you know you can guess when

00:10:22,459 --> 00:10:25,880
you will wake up but i don't think we

00:10:24,050 --> 00:10:28,100
have a mechanism for guessing whether

00:10:25,880 --> 00:10:34,580
the other cpu will be asleep or running

00:10:28,100 --> 00:10:42,020
at the time yeah i think it's when your

00:10:34,580 --> 00:10:44,420
if count something like that we have

00:10:42,020 --> 00:10:46,100
also seen that when all the cpu are

00:10:44,420 --> 00:10:48,170
trying to wake up at the same time and

00:10:46,100 --> 00:10:50,060
the same thing yeah the first one is the

00:10:48,170 --> 00:10:51,770
one with the shortest wakeup latency

00:10:50,060 --> 00:10:54,649
because the other one has to wait for

00:10:51,770 --> 00:10:57,350
the for the first one to wake up and

00:10:54,649 --> 00:10:59,990
they will start their wakeup will be

00:10:57,350 --> 00:11:01,940
delayed so at the end if you're not in

00:10:59,990 --> 00:11:04,459
some case if you're not the first well

00:11:01,940 --> 00:11:06,890
you will have more at ansi/ieee will you

00:11:04,459 --> 00:11:09,350
under such situation I think we cannot

00:11:06,890 --> 00:11:11,360
handle the situation is that kind of a

00:11:09,350 --> 00:11:12,860
worst-case scenario as well so it's

00:11:11,360 --> 00:11:22,130
probably the case that you don't have to

00:11:12,860 --> 00:11:23,300
care about much there are some things

00:11:22,130 --> 00:11:25,910
that we do in the kernel where we wake

00:11:23,300 --> 00:11:28,730
them all up so there might be one CPU

00:11:25,910 --> 00:11:30,290
running in one cluster that wakes up all

00:11:28,730 --> 00:11:32,300
the other CPUs to call the function on

00:11:30,290 --> 00:11:34,220
all of them at the same time and then if

00:11:32,300 --> 00:11:36,470
all the other CPUs us asleep at the time

00:11:34,220 --> 00:11:44,570
it will wake up every single CPU in the

00:11:36,470 --> 00:11:45,980
other cluster at the same time that of

00:11:44,570 --> 00:11:48,760
course is workload dependent but it is

00:11:45,980 --> 00:11:48,760
something we do

00:11:48,930 --> 00:11:54,760
like the waiter process really do with

00:11:52,240 --> 00:11:57,850
that immediately when wake up frosty

00:11:54,760 --> 00:12:04,240
Beauty the thing here is that the world

00:11:57,850 --> 00:12:06,860
we want to find out this explains of the

00:12:04,240 --> 00:12:10,190
CP and we want to do that really

00:12:06,860 --> 00:12:29,690
SSL is possible in the wake of when you

00:12:10,190 --> 00:12:31,850
wake up I mean it's not a random kernel

00:12:29,690 --> 00:12:39,680
function that calls SMP call function

00:12:31,850 --> 00:12:40,910
with the argument of call every CPU well

00:12:39,680 --> 00:12:43,820
this assumes that there's something

00:12:40,910 --> 00:12:45,500
running on one CPU so once you've used

00:12:43,820 --> 00:12:47,030
not asleep but you might have two

00:12:45,500 --> 00:12:48,080
clusters and every CPU in the other

00:12:47,030 --> 00:12:50,750
clusters asleep

00:12:48,080 --> 00:12:52,490
so once you've you does something in the

00:12:50,750 --> 00:12:57,710
kernel that requires calling something

00:12:52,490 --> 00:13:00,350
on all the other CPUs like I yeah it

00:12:57,710 --> 00:13:02,480
depends on a v8 you probably don't need

00:13:00,350 --> 00:13:04,070
it for invalidation so on when all our

00:13:02,480 --> 00:13:05,540
CPUs we had to do it what he'll be

00:13:04,070 --> 00:13:07,790
invalidation for example that would be

00:13:05,540 --> 00:13:09,800
one thing that we would do quite

00:13:07,790 --> 00:13:15,160
frequently when process exits we might

00:13:09,800 --> 00:13:15,160
have to once I want to wake up let's say

00:13:18,740 --> 00:14:37,250
we see that the that we correlate with

00:14:35,000 --> 00:14:39,920
the second point of the question oh yeah

00:14:37,250 --> 00:14:42,800
the task wake up but I do believe that

00:14:39,920 --> 00:14:46,130
this situation where we we have to wake

00:14:42,800 --> 00:14:49,880
up all the tasks on the on the on the

00:14:46,130 --> 00:14:53,570
left under on the cycle when on the all

00:14:49,880 --> 00:14:57,230
the dynamic we have on a CPU that

00:14:53,570 --> 00:14:59,420
represents a small you a small situation

00:14:57,230 --> 00:15:03,350
when opening a few times regarding all

00:14:59,420 --> 00:15:05,870
the the rest of the situation so I think

00:15:03,350 --> 00:15:08,300
we can leave we can we live with that

00:15:05,870 --> 00:15:09,820
that's pretty nothing we can do about it

00:15:08,300 --> 00:15:13,250
either

00:15:09,820 --> 00:15:15,950
just the fact that some applications do

00:15:13,250 --> 00:15:20,660
this and this we have to deal with it

00:15:15,950 --> 00:15:22,670
but we can't estimate the same no but I

00:15:20,660 --> 00:15:25,340
still don't see the answer for what I

00:15:22,670 --> 00:15:27,840
asked earlier

00:15:25,340 --> 00:15:30,180
how do you figure out whether you will

00:15:27,840 --> 00:15:36,510
be the next CPU to the first if you to

00:15:30,180 --> 00:15:37,560
wake up because I the is this correlated

00:15:36,510 --> 00:15:43,380
to the knowledge of who goes to sleep

00:15:37,560 --> 00:15:58,020
first or not our that's right the

00:15:43,380 --> 00:16:17,190
knowledge of how long you expect what

00:15:58,020 --> 00:16:20,010
does the tell the others it's just in

00:16:17,190 --> 00:16:22,620
the per CPU context you love to know

00:16:20,010 --> 00:16:24,990
what let and see you have to choose if

00:16:22,620 --> 00:16:27,870
you are the first one if it's across the

00:16:24,990 --> 00:16:30,930
state if it's a CPU port on state you

00:16:27,870 --> 00:16:33,030
don't care about okay about others you

00:16:30,930 --> 00:16:34,890
just know that CPU there is no

00:16:33,030 --> 00:16:38,250
dependency on the idle state with other

00:16:34,890 --> 00:16:40,890
devices which is the CPUs and you say

00:16:38,250 --> 00:16:42,870
okay am i I know my exit latency is

00:16:40,890 --> 00:16:45,270
constant is the same is the same value

00:16:42,870 --> 00:16:47,820
and I don't have to care about where I

00:16:45,270 --> 00:16:49,620
am the first one or not when I am close

00:16:47,820 --> 00:16:51,240
to a other state and you wake up you

00:16:49,620 --> 00:16:53,580
have to say okay if I am the one the

00:16:51,240 --> 00:16:55,710
first one then my exit latency is this

00:16:53,580 --> 00:16:57,840
is this because you put that in your

00:16:55,710 --> 00:16:59,760
table if you are not the first one

00:16:57,840 --> 00:17:02,490
waking up ok to exit that and see then

00:16:59,760 --> 00:17:04,680
is the other basic cuttin see in my

00:17:02,490 --> 00:17:07,680
table because I'm not the first one the

00:17:04,680 --> 00:17:12,720
only the only information you need is am

00:17:07,680 --> 00:17:15,030
I the first one or not so this

00:17:12,720 --> 00:17:17,280
information is out to you disk so that's

00:17:15,030 --> 00:17:18,890
another yes that's another aspect of the

00:17:17,280 --> 00:17:23,839
program is how do you describe that

00:17:18,890 --> 00:17:26,910
because today we know that they don't

00:17:23,839 --> 00:17:30,120
are terrorists told us that they don't

00:17:26,910 --> 00:17:32,970
want us to die the poor domain with the

00:17:30,120 --> 00:17:36,270
cluster so usually what we did until

00:17:32,970 --> 00:17:37,350
today is to take the top topology and

00:17:36,270 --> 00:17:39,840
say

00:17:37,350 --> 00:17:42,090
we have addressed her and that support

00:17:39,840 --> 00:17:44,070
domain but they don't want that so we

00:17:42,090 --> 00:17:46,919
need a poorer domain to describe the

00:17:44,070 --> 00:17:49,559
cluster and we need an idle state to be

00:17:46,919 --> 00:17:53,190
tied with this description saying that

00:17:49,559 --> 00:17:55,230
this decider state will pour down all

00:17:53,190 --> 00:17:57,240
this poor domain and for an altered

00:17:55,230 --> 00:17:59,250
board when we have all these CPUs and we

00:17:57,240 --> 00:18:03,000
can put there a ref count saying we

00:17:59,250 --> 00:18:06,809
offer and CPUs on this poor domain and

00:18:03,000 --> 00:18:09,330
then you just you just do a test at the

00:18:06,809 --> 00:18:19,980
other wake in the wake up pass but we

00:18:09,330 --> 00:18:21,690
need a way to describe that yes but in

00:18:19,980 --> 00:18:25,110
this case that means that this solution

00:18:21,690 --> 00:18:29,730
only applies for platform with device

00:18:25,110 --> 00:18:31,890
device three importance so we cannot

00:18:29,730 --> 00:18:35,490
generalize that for the others that

00:18:31,890 --> 00:18:37,500
means we have to do this this you know I

00:18:35,490 --> 00:18:40,110
don't see the problem describing I mean

00:18:37,500 --> 00:18:41,850
that that may also be a problem but the

00:18:40,110 --> 00:18:45,330
the problem that I'm trying to figure

00:18:41,850 --> 00:18:48,929
out whether that's even possible is you

00:18:45,330 --> 00:18:51,299
let's assume this truster with four CPUs

00:18:48,929 --> 00:18:55,559
three of them are already asleep

00:18:51,299 --> 00:18:57,539
and you know that if you are the first

00:18:55,559 --> 00:19:02,520
one to wake up you will have this extra

00:18:57,539 --> 00:19:06,150
long latency but by the time you wake up

00:19:02,520 --> 00:19:06,960
how do you guess whether the other GPUs

00:19:06,150 --> 00:19:12,510
are still asleep

00:19:06,960 --> 00:19:15,090
or whether they will have woken up so in

00:19:12,510 --> 00:19:17,250
the class rattling serious I've been

00:19:15,090 --> 00:19:19,440
working with we know this because we

00:19:17,250 --> 00:19:20,789
need to know that off lost man and we

00:19:19,440 --> 00:19:23,250
also need to know that thoughts might

00:19:20,789 --> 00:19:27,000
look we also get to know what were the

00:19:23,250 --> 00:19:29,880
thoughts man because of that so because

00:19:27,000 --> 00:19:34,169
of a I mean it's its structure that's

00:19:29,880 --> 00:19:38,340
been blocked so it's it's a protected

00:19:34,169 --> 00:19:40,140
data so you know that in this platform

00:19:38,340 --> 00:19:43,289
coronated mode versus the always

00:19:40,140 --> 00:19:45,000
initiated mode in the PC right if you

00:19:43,289 --> 00:19:48,720
know about how our always initiated mode

00:19:45,000 --> 00:19:49,570
works it's it's a different way on how

00:19:48,720 --> 00:19:51,970
you

00:19:49,570 --> 00:19:54,399
how you how you provide the trust or

00:19:51,970 --> 00:19:56,049
idle states to the PCI reformer so you

00:19:54,399 --> 00:19:58,840
actually have to do that on the last man

00:19:56,049 --> 00:20:00,309
standing so that means that what we are

00:19:58,840 --> 00:20:02,679
doing to solve the problem is that we're

00:20:00,309 --> 00:20:06,549
using a young PD structure and put CPUs

00:20:02,679 --> 00:20:09,249
in that as a regular device in the

00:20:06,549 --> 00:20:13,749
domain service there is a look it's a

00:20:09,249 --> 00:20:32,129
spin lock where we have to yeah maintain

00:20:13,749 --> 00:20:32,129
this tape so it's it's being it's being

00:21:05,940 --> 00:21:13,570
in in the in in the film where the PSC I

00:21:10,299 --> 00:21:18,070
when you are the first one the orders of

00:21:13,570 --> 00:21:19,960
you will be blocked so if all if all the

00:21:18,070 --> 00:21:25,629
CPU wakes up more or less at the same

00:21:19,960 --> 00:21:28,269
time the first one has to do a list of

00:21:25,629 --> 00:21:32,349
operation and order daughter will be

00:21:28,269 --> 00:21:35,200
blocked done so when you exit the state

00:21:32,349 --> 00:21:39,549
and you you do best effort I mean we

00:21:35,200 --> 00:21:42,609
don't have to have something perfectly

00:21:39,549 --> 00:21:44,200
synchronized we try to do the we don't

00:21:42,609 --> 00:21:47,080
want to take lock and we don't know

00:21:44,200 --> 00:21:51,340
which I think if you have a ref counting

00:21:47,080 --> 00:21:58,340
is enough maybe I misunderstood what you

00:21:51,340 --> 00:22:00,230
okay what I mean is the only time when

00:21:58,340 --> 00:22:03,289
you need to know the exit latency is

00:22:00,230 --> 00:22:04,010
when you go to sleep right no no no when

00:22:03,289 --> 00:22:06,080
you wake up

00:22:04,010 --> 00:22:07,730
what you want is merger to adult

00:22:06,080 --> 00:22:31,340
duration how long they have been

00:22:07,730 --> 00:22:34,460
sleeping so you see here you need you

00:22:31,340 --> 00:22:37,250
have to reach the time the target

00:22:34,460 --> 00:22:41,149
residence in order to do to reach your

00:22:37,250 --> 00:22:45,769
breakeven okay so the interrupt waking

00:22:41,149 --> 00:22:49,130
up the logic is coming here but you

00:22:45,769 --> 00:22:50,690
measure when you wake up you have you

00:22:49,130 --> 00:22:53,539
have all the time when you wake up and

00:22:50,690 --> 00:22:55,730
then you can measure the time here so

00:22:53,539 --> 00:22:58,220
you will be measuring from there to

00:22:55,730 --> 00:23:02,539
there instead of measuring from there to

00:22:58,220 --> 00:23:07,730
there and it exactly this so we need to

00:23:02,539 --> 00:23:10,429
subtract this this this and because the

00:23:07,730 --> 00:23:14,179
exit latency are very eye on the on

00:23:10,429 --> 00:23:17,539
mobile it is not negligible on on the

00:23:14,179 --> 00:23:21,889
inter platform it's so microsecond and

00:23:17,539 --> 00:23:24,080
on on on the platform we have could be 1

00:23:21,889 --> 00:23:27,440
millisecond 2 millisecond 3 millisecond

00:23:24,080 --> 00:23:31,159
to wake up so it's a lot and and it's a

00:23:27,440 --> 00:23:36,049
lot because regarding that it could be

00:23:31,159 --> 00:23:39,620
as long as the target residency so when

00:23:36,049 --> 00:23:43,460
if you if we measure the entire sleep

00:23:39,620 --> 00:23:44,899
duration next time we can we could have

00:23:43,460 --> 00:23:47,690
been sleeping just that

00:23:44,899 --> 00:23:51,909
so not reach the target residency but as

00:23:47,690 --> 00:23:51,909
because of the exit latency we have this

00:23:52,690 --> 00:23:57,409
and then we go to sleep state the deep

00:23:55,460 --> 00:23:59,510
sleep state thinking that we so we have

00:23:57,409 --> 00:24:01,490
to subtract this so to be more accurate

00:23:59,510 --> 00:24:04,200
in the measurements so that's the idea

00:24:01,490 --> 00:24:06,840
of creating just maybe a VAR f

00:24:04,200 --> 00:24:09,510
and then the first one just really so

00:24:06,840 --> 00:24:11,070
okay so this is the description I think

00:24:09,510 --> 00:24:15,330
the problem we have is the description

00:24:11,070 --> 00:24:18,570
of that because this exit dynamic exit

00:24:15,330 --> 00:24:21,330
latency will be interest more platform

00:24:18,570 --> 00:24:32,399
will be interested in that not only not

00:24:21,330 --> 00:24:35,700
only us but we have to we have to change

00:24:32,399 --> 00:24:38,760
the general framework for that for a few

00:24:35,700 --> 00:24:40,769
latency we have to own to go to the

00:24:38,760 --> 00:25:12,529
order to change the structure of the

00:24:40,769 --> 00:25:12,529
general framework so that we impact yes

00:25:17,720 --> 00:25:22,730
yeah it's the ratio between the

00:25:19,950 --> 00:25:22,730
attention

00:25:43,730 --> 00:25:51,870
then you did some measurements with the

00:25:47,000 --> 00:25:55,650
platform the I key and with you we we

00:25:51,870 --> 00:26:00,720
can we were to see that on the exit

00:25:55,650 --> 00:26:03,060
latency with depending on the OPP the

00:26:00,720 --> 00:26:11,490
change of the exit latency can be

00:26:03,060 --> 00:26:30,350
significant up to 60% if I remember

00:26:11,490 --> 00:26:30,350
correctly from 2.4 or 2.7 to 1.7 so yeah

00:26:37,670 --> 00:26:43,620
wait PLL to lock you have to power up

00:26:41,580 --> 00:26:47,130
right so I think that for the longest

00:26:43,620 --> 00:26:50,640
the situation is that you have to power

00:26:47,130 --> 00:26:52,710
up Europe your voltage regulator so you

00:26:50,640 --> 00:26:54,510
have to wait the voltage to increase

00:26:52,710 --> 00:26:56,670
then you have to lock appeared and you

00:26:54,510 --> 00:26:59,940
have to wait for the PLL to lock then

00:26:56,670 --> 00:27:09,740
you can wake up the CPU and you have to

00:26:59,940 --> 00:27:21,990
re-enable the currents there is no AC

00:27:09,740 --> 00:27:25,530
involved in the passages that yeah so as

00:27:21,990 --> 00:27:28,200
we are trying to having some dynamic

00:27:25,530 --> 00:27:31,200
exit latency depending of the situation

00:27:28,200 --> 00:27:34,470
we should shouldn't we also take care of

00:27:31,200 --> 00:27:37,110
the OPP so when we wake up we look at

00:27:34,470 --> 00:27:38,970
the OPP what to pick what is the OPP and

00:27:37,110 --> 00:27:40,770
then we know that we are the first one

00:27:38,970 --> 00:27:42,510
or the last or not the first one and

00:27:40,770 --> 00:27:45,810
then we are at this OPP so we have this

00:27:42,510 --> 00:27:47,520
X platen see shall we fill this to be at

00:27:45,810 --> 00:27:58,680
use that

00:27:47,520 --> 00:28:01,740
my tricks of value yeah but for the OPP

00:27:58,680 --> 00:28:04,920
the impact on a Dayton see their

00:28:01,740 --> 00:28:09,780
Hawaiian issue that for example the CP

00:28:04,920 --> 00:28:14,970
was zero in into the idle state but the

00:28:09,780 --> 00:28:18,060
CPU one in a semi same clock Tommy so CP

00:28:14,970 --> 00:28:22,860
one were triggered the CPU frequency

00:28:18,060 --> 00:28:25,890
change so do you know that for the CPU

00:28:22,860 --> 00:28:28,260
zero the first part in the idle state

00:28:25,890 --> 00:28:31,890
and the second apart in idle state admit

00:28:28,260 --> 00:28:32,880
maybe have a different way good change

00:28:31,890 --> 00:28:39,080
in the meter

00:28:32,880 --> 00:28:41,880
yeah yeah I know but as we are with this

00:28:39,080 --> 00:28:45,030
concurrency between the we cannot handle

00:28:41,880 --> 00:28:47,850
all the concurrency so I assume that we

00:28:45,030 --> 00:28:50,760
have to live with that and accept that

00:28:47,850 --> 00:28:53,130
this situation when we have all the CP

00:28:50,760 --> 00:28:54,890
with nope at the same time are having a

00:28:53,130 --> 00:28:58,470
CPU change in the clock while we are

00:28:54,890 --> 00:29:02,760
waking up we can assume that these are

00:28:58,470 --> 00:29:05,880
small windows we can assume that ok it's

00:29:02,760 --> 00:29:09,650
part of the error but we try to reduce

00:29:05,880 --> 00:29:23,250
as much as possible the error margin

00:29:09,650 --> 00:29:31,410
when measuring that's yeah 20 OPP to let

00:29:23,250 --> 00:29:38,610
and see if you're the first in the does

00:29:31,410 --> 00:29:40,290
it worse another idea which may be

00:29:38,610 --> 00:29:41,940
completely insane but the the firmware

00:29:40,290 --> 00:29:44,010
doesn't have the correct time it knows

00:29:41,940 --> 00:29:47,880
exactly how long I slept right know if

00:29:44,010 --> 00:29:49,290
you called not know but it has one like

00:29:47,880 --> 00:29:52,200
it it does have all the knowledge about

00:29:49,290 --> 00:29:54,180
the hierarchy and yes but she cannot

00:29:52,200 --> 00:29:56,450
know exactly when you wake up no it

00:29:54,180 --> 00:29:56,450
doesn't

00:29:57,360 --> 00:30:04,350
because it's between its logic the logic

00:30:01,110 --> 00:30:08,190
is working up and then the femur as well

00:30:04,350 --> 00:30:10,050
as the firm that can only know when the

00:30:08,190 --> 00:30:14,910
phone were first get started that does

00:30:10,050 --> 00:30:24,240
some things but okay you have this clock

00:30:14,910 --> 00:30:29,390
event which obesity when you if you when

00:30:24,240 --> 00:30:29,390
you fall down so is that at reset

00:30:30,920 --> 00:30:34,710
anybody thought immediately when they

00:30:32,940 --> 00:30:36,690
wake up we can count the number of

00:30:34,710 --> 00:30:40,230
cycles if you have a way to come two

00:30:36,690 --> 00:30:42,150
noble psychoses to see people off maybe

00:30:40,230 --> 00:30:44,670
this can be the method in this case

00:30:42,150 --> 00:30:50,040
yourself you just have to read the the

00:30:44,670 --> 00:30:54,020
kunta and you will know a mini cycle you

00:30:50,040 --> 00:30:56,160
have seized the power up of your CPU

00:30:54,020 --> 00:30:57,480
that could be another way maybe that

00:30:56,160 --> 00:31:07,170
would be far more easier for you to

00:30:57,480 --> 00:31:10,230
endure so you will have to exact okay is

00:31:07,170 --> 00:31:14,840
it something could be a generic for the

00:31:10,230 --> 00:31:14,840
platforms not until I mean but for arm

00:31:20,270 --> 00:31:23,270
okay

00:31:27,540 --> 00:31:57,390
there because a couple for this so why

00:31:49,500 --> 00:32:00,480
you don't use why why not you yeah spend

00:31:57,390 --> 00:32:01,980
that nothing we also the performance the

00:32:00,480 --> 00:32:04,710
p.m. you can be used because I'm on

00:32:01,980 --> 00:32:08,070
either the club front of the team you

00:32:04,710 --> 00:32:13,410
store when the use of you is off so you

00:32:08,070 --> 00:32:19,559
will know exactly I mean each psycho we

00:32:13,410 --> 00:32:20,340
all wake up oh okay okay it's very

00:32:19,559 --> 00:32:22,320
expensive

00:32:20,340 --> 00:32:24,450
yeah the problem is that the PM you

00:32:22,320 --> 00:32:27,299
canto expensive if I said that there was

00:32:24,450 --> 00:32:30,330
a new condom which start to be available

00:32:27,299 --> 00:32:33,929
which are far less expensive

00:32:30,330 --> 00:32:39,410
I think the Cameo cotton may be much

00:32:33,929 --> 00:32:39,410
unless they can see that

00:32:40,530 --> 00:32:51,640
equal cut it with that will use the apt

00:32:45,640 --> 00:32:57,580
pass right there you are using this

00:32:51,640 --> 00:33:00,180
locale that something can be implemented

00:32:57,580 --> 00:33:09,070
in prototype for easily

00:33:00,180 --> 00:33:10,840
it's just what time is it something we

00:33:09,070 --> 00:33:15,460
can answer economy answer the question

00:33:10,840 --> 00:33:18,750
is a suitable solution more or less

00:33:15,460 --> 00:33:18,750
easily oh it's

00:33:55,080 --> 00:33:57,860
okay

00:34:26,149 --> 00:34:33,929
okay that's what I was thinking with

00:34:30,029 --> 00:34:36,029
doing it in the firmware of PSC I knows

00:34:33,929 --> 00:34:38,700
which information is reliable or not and

00:34:36,029 --> 00:34:42,289
it can make estimates then just

00:34:38,700 --> 00:34:45,899
returning a number of milliseconds then

00:34:42,289 --> 00:34:47,940
nanoseconds sorry from the interface

00:34:45,899 --> 00:34:49,919
that puts it to sleep by the time you

00:34:47,940 --> 00:34:51,839
wake up you could get a number of X so

00:34:49,919 --> 00:34:54,510
you could have a replacement interface

00:34:51,839 --> 00:34:57,599
or just instead of going to sleep and

00:34:54,510 --> 00:35:00,240
coming back go to sleep and return the

00:34:57,599 --> 00:35:04,140
number of the nanoseconds you have been

00:35:00,240 --> 00:35:05,940
asleep yeah like like a select main loop

00:35:04,140 --> 00:35:08,670
something like that with Diamonds you

00:35:05,940 --> 00:35:11,220
mean so when you exist tells you if you

00:35:08,670 --> 00:35:14,130
reach timeout or oh man all of this

00:35:11,220 --> 00:35:15,510
remains a that just change the at a new

00:35:14,130 --> 00:35:16,980
firmware the face does that does the

00:35:15,510 --> 00:35:19,099
same thing as before but returns a

00:35:16,980 --> 00:35:19,099
number

00:35:52,470 --> 00:36:01,090
okay to be investigating so you have

00:35:57,940 --> 00:36:10,150
another point so I would like to discuss

00:36:01,090 --> 00:36:12,400
is so we saw that for audio and video in

00:36:10,150 --> 00:36:18,130
the in the test photos who were not in

00:36:12,400 --> 00:36:20,620
the presentation yesterday I in order to

00:36:18,130 --> 00:36:25,900
do comparison to see how behaved the

00:36:20,620 --> 00:36:30,010
menu Governor I created others governors

00:36:25,900 --> 00:36:33,010
to compare with and one of them is the

00:36:30,010 --> 00:36:37,120
shallowest so this governor is just

00:36:33,010 --> 00:36:42,250
always choosing the Wi-Fi in idle state

00:36:37,120 --> 00:36:44,800
and we see that for this for this for

00:36:42,250 --> 00:36:51,250
this scenario which is audio and video

00:36:44,800 --> 00:36:57,040
we consume up to 8% even less energy for

00:36:51,250 --> 00:37:02,260
video and for audio we consume less just

00:36:57,040 --> 00:37:08,970
doing Wi-Fi so that means there's

00:37:02,260 --> 00:37:12,930
something happening here and when we do

00:37:08,970 --> 00:37:16,630
we look at the kind of the current

00:37:12,930 --> 00:37:19,390
crisis we took leave a fight and with

00:37:16,630 --> 00:37:21,910
the mana governor we see that we've to

00:37:19,390 --> 00:37:27,100
prefer fine the tasks are packed

00:37:21,910 --> 00:37:28,630
together while on the menu governor well

00:37:27,100 --> 00:37:31,150
of course there is a lot of

00:37:28,630 --> 00:37:33,370
misprediction because of the the task

00:37:31,150 --> 00:37:35,680
ordering and the dependence which in the

00:37:33,370 --> 00:37:38,740
task there are a lot of misprediction

00:37:35,680 --> 00:37:43,170
but when we use them to verify all the

00:37:38,740 --> 00:37:47,290
tasks apart together so when we are

00:37:43,170 --> 00:37:50,260
looking for a decision when we want to

00:37:47,290 --> 00:37:53,160
take a decision about the idle state how

00:37:50,260 --> 00:37:55,670
can we characterize this situation and

00:37:53,160 --> 00:37:59,959
take the debrief

00:37:55,670 --> 00:37:59,959
instead of trying to predict

00:38:18,770 --> 00:38:26,780
ya know I think that that is to think

00:38:22,590 --> 00:38:29,370
the first things that the menu in detail

00:38:26,780 --> 00:38:31,740
in the case of the menu governor what we

00:38:29,370 --> 00:38:37,320
are seeing is that because everything is

00:38:31,740 --> 00:38:39,690
packed so and it's a it's a synchronous

00:38:37,320 --> 00:38:42,870
wake up figure by the by the scheduler

00:38:39,690 --> 00:38:45,450
so when you wake up a task you put that

00:38:42,870 --> 00:38:50,400
on the CPU which is either whatever the

00:38:45,450 --> 00:38:52,440
state yeah but even that all the others

00:38:50,400 --> 00:38:54,630
if you were as you can see all the all

00:38:52,440 --> 00:38:57,180
the CPU were in dips in deep sea state

00:38:54,630 --> 00:39:01,530
so the first task wake up then it's not

00:38:57,180 --> 00:39:03,240
to wake up other other tasks so you will

00:39:01,530 --> 00:39:05,910
have to wake up from the cluster state

00:39:03,240 --> 00:39:07,230
but then if you don't have any things to

00:39:05,910 --> 00:39:11,820
do because there is no time I know I

00:39:07,230 --> 00:39:14,400
have you you will select the cluster for

00:39:11,820 --> 00:39:16,470
off state but in fact you will wake up

00:39:14,400 --> 00:39:19,470
in a few micro slow because you will be

00:39:16,470 --> 00:39:20,910
working wake up back by the other task I

00:39:19,470 --> 00:39:24,720
mean you have this pipeline of thread

00:39:20,910 --> 00:39:27,270
it's happening so let us wake up we kept

00:39:24,720 --> 00:39:29,850
another task you go to sleep because

00:39:27,270 --> 00:39:31,860
there is nothing running on the CPU you

00:39:29,850 --> 00:39:33,660
select the cluster but shortly after

00:39:31,860 --> 00:39:36,630
that the other task has finished so wake

00:39:33,660 --> 00:39:48,000
up back to spew the task you grab the

00:39:36,630 --> 00:39:50,150
target residency just an effect you need

00:39:48,000 --> 00:39:52,740
too many signal to wake up from cluster

00:39:50,150 --> 00:39:56,100
so it just wake up latency that you can

00:39:52,740 --> 00:39:59,550
see between and because of this latency

00:39:56,100 --> 00:40:01,560
between the tasks also the menu governor

00:39:59,550 --> 00:40:03,090
is doing this prediction and taking

00:40:01,560 --> 00:40:06,210
deeper staggered state and so on

00:40:03,090 --> 00:40:08,250
so and the result is when you could

00:40:06,210 --> 00:40:09,990
choose to verify and see that we have a

00:40:08,250 --> 00:40:13,350
person but the governor does not make

00:40:09,990 --> 00:40:17,880
any difference between the big and the

00:40:13,350 --> 00:40:22,050
little restore so when you have this CPU

00:40:17,880 --> 00:40:24,570
it's in Wi-Fi so that means to verify is

00:40:22,050 --> 00:40:27,570
for all the CPU so even in this

00:40:24,570 --> 00:40:29,430
we can save more energy because if we

00:40:27,570 --> 00:40:34,500
had the second crystalline cluster power

00:40:29,430 --> 00:40:37,860
down because he's not used then yeah so

00:40:34,500 --> 00:40:41,540
by doing that we are doing Wi-Fi for all

00:40:37,860 --> 00:40:44,820
the CPU we save eight percent of energy

00:40:41,540 --> 00:40:47,340
if we have this let's imagine that this

00:40:44,820 --> 00:40:49,290
task the yes because here there is a

00:40:47,340 --> 00:40:51,540
miss placement of the task with the yes

00:40:49,290 --> 00:40:53,520
so this task shouldn't be here

00:40:51,540 --> 00:40:55,290
there should be in the little cluster

00:40:53,520 --> 00:40:58,620
and all the bigger stores should be

00:40:55,290 --> 00:41:02,220
poured down so that means that we can we

00:40:58,620 --> 00:41:07,590
we can have a better potentially a

00:41:02,220 --> 00:41:11,880
better energy saving so you've been

00:41:07,590 --> 00:41:12,870
running this on a high key 8960 yes big

00:41:11,880 --> 00:41:16,140
knitter I think it will be interesting

00:41:12,870 --> 00:41:18,420
to run this kind of test on x86 platform

00:41:16,140 --> 00:41:21,440
as well to see if you get that kernel

00:41:18,420 --> 00:41:23,490
and what what behavior you get in that

00:41:21,440 --> 00:41:26,910
double promise you cannot measure

00:41:23,490 --> 00:41:31,140
anything because all you have energy

00:41:26,910 --> 00:41:33,990
counters on the entire platform but all

00:41:31,140 --> 00:41:34,550
the femur is overriding the decision you

00:41:33,990 --> 00:41:39,120
made

00:41:34,550 --> 00:41:42,210
so I already try that so it's you have

00:41:39,120 --> 00:41:44,310
to you can see this but from the energy

00:41:42,210 --> 00:41:46,710
point of view you won't see the

00:41:44,310 --> 00:41:49,500
difference because the femur is doing

00:41:46,710 --> 00:41:57,180
something thank you you wanted to say

00:41:49,500 --> 00:42:00,990
something so what you remind that there

00:41:57,180 --> 00:42:04,200
how was a machine that this used yes

00:42:00,990 --> 00:42:08,430
so the wake up pass is not yield Mina

00:42:04,200 --> 00:42:11,520
color the scheduler the capacity so I

00:42:08,430 --> 00:42:14,460
did I did a same test by dissipating

00:42:11,520 --> 00:42:17,910
this the yes in the canal and disabling

00:42:14,460 --> 00:42:20,700
cluster so running just in a single

00:42:17,910 --> 00:42:26,430
cluster without the yes and I have the

00:42:20,700 --> 00:42:28,770
same behavior so it's not involved in

00:42:26,430 --> 00:42:32,220
this in this in this scenario yes has a

00:42:28,770 --> 00:42:35,160
little impact I will do you know if

00:42:32,220 --> 00:42:37,970
there's I mean that the menu governor

00:42:35,160 --> 00:42:42,830
has a dozen complete

00:42:37,970 --> 00:42:46,940
to find out the next prediction yeah and

00:42:42,830 --> 00:42:49,160
in the this shallow governor thing there

00:42:46,940 --> 00:42:52,180
is no prediction at all no so it's a lot

00:42:49,160 --> 00:42:53,990
faster so how much that is that

00:42:52,180 --> 00:42:56,030
affecting this paper

00:42:53,990 --> 00:43:01,030
you mean the prediction the time to

00:42:56,030 --> 00:43:03,770
predict yes it's it's for more s 14

00:43:01,030 --> 00:43:06,050
microsecond so that differs for every

00:43:03,770 --> 00:43:08,990
CPU when you take that yes but I don't

00:43:06,050 --> 00:43:13,070
think it is significant I don't think it

00:43:08,990 --> 00:43:15,560
is significant and maybe there is maybe

00:43:13,070 --> 00:43:18,109
but at the first glance whatever is what

00:43:15,560 --> 00:43:19,970
I test it is not significant I think the

00:43:18,109 --> 00:43:21,619
program is the miss that means

00:43:19,970 --> 00:43:23,990
prediction here we are actually we are

00:43:21,619 --> 00:43:27,200
predicting we are badly predicting here

00:43:23,990 --> 00:43:29,090
and then we we are doing always in deep

00:43:27,200 --> 00:43:31,910
idle state and we break the target

00:43:29,090 --> 00:43:36,500
residency because the money governor is

00:43:31,910 --> 00:43:39,349
not is doing a soup with all these wake

00:43:36,500 --> 00:43:41,359
up sources is not able to identify now

00:43:39,349 --> 00:43:44,300
with the new governor we are writing

00:43:41,359 --> 00:43:47,030
based on the RQ next prediction we have

00:43:44,300 --> 00:43:49,310
we clearly identify the sources and the

00:43:47,030 --> 00:43:52,280
net the need risk ed is one of these

00:43:49,310 --> 00:43:57,589
sources we can discard if it's being

00:43:52,280 --> 00:44:00,410
very erratic my my expectation is how

00:43:57,589 --> 00:44:02,960
can we all can we detect that we have

00:44:00,410 --> 00:44:05,570
all a lot of tasks being interacting

00:44:02,960 --> 00:44:08,270
together singing together so in this

00:44:05,570 --> 00:44:10,550
case with so that the multimedia

00:44:08,270 --> 00:44:13,550
workload is ponying a lot of threads and

00:44:10,550 --> 00:44:15,410
this res are just singing together so

00:44:13,550 --> 00:44:17,960
they are doing a task and then they

00:44:15,410 --> 00:44:20,150
finish the task that unleash that

00:44:17,960 --> 00:44:24,470
release the other task in the pipeline

00:44:20,150 --> 00:44:27,380
doing the next process which is etcetera

00:44:24,470 --> 00:44:30,680
etcetera but by cascade all these tasks

00:44:27,380 --> 00:44:33,859
are tied together and when some I

00:44:30,680 --> 00:44:37,339
remember you told you talk about the

00:44:33,859 --> 00:44:39,030
sing sing sing sing thing in the

00:44:37,339 --> 00:44:42,229
scheduler

00:44:39,030 --> 00:44:42,229
[Music]

00:44:44,930 --> 00:44:53,910
you're able when you work up a task your

00:44:50,789 --> 00:44:55,710
way to say that it's a sink wake up so

00:44:53,910 --> 00:45:01,079
that you're waking up a task and you

00:44:55,710 --> 00:45:02,519
will yourself shortly sleep so but

00:45:01,079 --> 00:45:04,500
because it's I mean when you wake up

00:45:02,519 --> 00:45:06,150
something you're still running when the

00:45:04,500 --> 00:45:08,910
other thing is working it so if you are

00:45:06,150 --> 00:45:10,980
looking for an idle CPU will not stay on

00:45:08,910 --> 00:45:13,890
the same CPU because it's already busy

00:45:10,980 --> 00:45:16,710
and there is a way to say I'm going to

00:45:13,890 --> 00:45:20,420
sleep shortly so my CPU will be idle so

00:45:16,710 --> 00:45:22,920
you can stay on the CPU if you want but

00:45:20,420 --> 00:45:25,049
it's not really well used I mean it's

00:45:22,920 --> 00:45:29,130
mean that all the user space stuff and

00:45:25,049 --> 00:45:32,960
so on let's take advantage of this and

00:45:29,130 --> 00:45:38,279
it's quite difficult ok

00:45:32,960 --> 00:45:44,660
but this normally it's possible not well

00:45:38,279 --> 00:45:44,660
useless but possible ok

00:45:52,130 --> 00:46:02,490
it's it's just in your Antonis risk it

00:45:58,310 --> 00:46:04,140
so he's taking the timer and guessing if

00:46:02,490 --> 00:46:09,660
he's woke up before the timer that he

00:46:04,140 --> 00:46:12,180
should go take a shallow state but it's

00:46:09,660 --> 00:46:16,230
eristic there is no control at the end

00:46:12,180 --> 00:46:19,710
the result is it Peaks much more shallow

00:46:16,230 --> 00:46:22,410
state so the side effect is we see more

00:46:19,710 --> 00:46:25,350
or less the same the same thing than the

00:46:22,410 --> 00:46:28,680
shallowest here but it's just the

00:46:25,350 --> 00:46:37,710
question because his is taking shallow a

00:46:28,680 --> 00:46:44,160
state term but randomly the for the junk

00:46:37,710 --> 00:46:46,830
bench test this one he has something

00:46:44,160 --> 00:46:50,580
similar does this one so that means that

00:46:46,830 --> 00:46:53,930
I can have a lot of performances he has

00:46:50,580 --> 00:46:58,320
a better tread of performance energy

00:46:53,930 --> 00:47:00,180
than the mana governor but he actually

00:46:58,320 --> 00:47:03,030
does not have control of what's up

00:47:00,180 --> 00:47:06,480
what's happening it just choose idle

00:47:03,030 --> 00:47:08,550
state so for us for them for Rafa would

00:47:06,480 --> 00:47:12,390
we implemented that before a server side

00:47:08,550 --> 00:47:14,070
so I mean it's for them it's it's okay

00:47:12,390 --> 00:47:16,080
this kind of straight off they can leave

00:47:14,070 --> 00:47:19,410
you that it's they're happy with it I

00:47:16,080 --> 00:47:22,710
think we should also know that they also

00:47:19,410 --> 00:47:24,270
have a governor inside the formula and

00:47:22,710 --> 00:47:26,820
they are going on inside a few more in

00:47:24,270 --> 00:47:30,000
addition yes that means that I could

00:47:26,820 --> 00:47:33,710
mitigate the problem and that level in

00:47:30,000 --> 00:47:33,710
some way of the others of MAGIX

00:47:34,660 --> 00:47:49,150
yeah okay so here for this any other

00:47:45,350 --> 00:47:53,420
idea to characterize this situation of

00:47:49,150 --> 00:48:01,850
stress doing a lot of pipeline and

00:47:53,420 --> 00:48:04,720
parallel processing and main problem

00:48:01,850 --> 00:48:07,430
when you look up to pull this is that

00:48:04,720 --> 00:48:10,430
you should find a way to pack everything

00:48:07,430 --> 00:48:12,550
you are using all the CPU without any

00:48:10,430 --> 00:48:19,010
real good reason

00:48:12,550 --> 00:48:22,370
now here is the yessing and this this

00:48:19,010 --> 00:48:24,860
has already been reported and they don't

00:48:22,370 --> 00:48:31,640
want to change that I don't know why

00:48:24,860 --> 00:48:33,680
they decided to do so but this I'm

00:48:31,640 --> 00:48:38,720
interested in so shall we shall we

00:48:33,680 --> 00:48:42,050
create some kind of nested or interact

00:48:38,720 --> 00:48:44,390
interact interaction CPU between tasks

00:48:42,050 --> 00:48:56,770
in the eye of a task this task to kalach

00:48:44,390 --> 00:49:00,170
the other task is waiting for this look

00:48:56,770 --> 00:49:02,270
it's wait queue they're just waiting for

00:49:00,170 --> 00:49:04,010
an event it's not waiting forever but

00:49:02,270 --> 00:49:09,290
it's a lock they are locked by another

00:49:04,010 --> 00:49:11,470
another CPU I don't like when you say

00:49:09,290 --> 00:49:13,910
lock because there is no lock

00:49:11,470 --> 00:49:18,740
okay so let's say it's a way to for

00:49:13,910 --> 00:49:22,730
completion yeah so if we can find that

00:49:18,740 --> 00:49:25,220
the weight of compression or the CPU are

00:49:22,730 --> 00:49:26,000
using it shall we say okay there is an

00:49:25,220 --> 00:49:29,680
indirection

00:49:26,000 --> 00:49:29,680
I interaction

00:49:38,550 --> 00:49:42,310
because if we know that there is

00:49:40,450 --> 00:49:44,080
otherwise you put everything in a single

00:49:42,310 --> 00:49:45,850
and you say this your group should run

00:49:44,080 --> 00:49:52,390
on the same CPU and you are doing some

00:49:45,850 --> 00:49:56,110
cost scheduling instead of trying to

00:49:52,390 --> 00:49:57,880
detect why not just grouping see group

00:49:56,110 --> 00:50:01,210
it's a control group to say all these

00:49:57,880 --> 00:50:04,590
tasks share a property so you mean from

00:50:01,210 --> 00:50:07,780
user space we from a user with Android

00:50:04,590 --> 00:50:10,810
we detect the exoplayer thing and we

00:50:07,780 --> 00:50:14,200
just pack all the tasks on one CVO you

00:50:10,810 --> 00:50:18,040
can easily put all the thread a link to

00:50:14,200 --> 00:50:20,430
an app or process in the same zero yeah

00:50:18,040 --> 00:50:24,310
and then you can say I want all these

00:50:20,430 --> 00:50:27,480
tasks to run on the simple same CPU as

00:50:24,310 --> 00:50:27,480
much as possible

00:50:35,740 --> 00:50:41,809
- things that you would like to pack

00:50:38,119 --> 00:50:44,630
everything and the same yeah yeah so if

00:50:41,809 --> 00:50:47,539
you see here there are more or less they

00:50:44,630 --> 00:50:49,400
are tied together on one task finishing

00:50:47,539 --> 00:50:50,960
the thing that released other tasks

00:50:49,400 --> 00:50:51,380
which processing something release

00:50:50,960 --> 00:50:55,539
something

00:50:51,380 --> 00:50:55,539
the DUP DUP DUP Act

00:51:07,290 --> 00:51:18,060
why are you trying to create yes

00:51:26,090 --> 00:51:31,870
except that I'm not sure that some of

00:51:28,580 --> 00:51:35,650
this thread are not part of the program

00:51:31,870 --> 00:51:35,650
so another since

00:51:36,130 --> 00:51:43,290
if you want to scale this workout you

00:51:37,960 --> 00:51:43,290
might be under than upward at a basis

00:51:43,299 --> 00:51:45,839
yeah

00:51:48,610 --> 00:51:53,289
yeah

00:51:50,650 --> 00:51:56,680
so maybe maybe having some kind of

00:51:53,289 --> 00:52:00,339
multimedia cgroups when you put all the

00:51:56,680 --> 00:52:08,079
thread involved in the multi beer person

00:52:00,339 --> 00:52:09,519
you know that yeah but from the governor

00:52:08,079 --> 00:52:12,309
point of view what will be interesting

00:52:09,519 --> 00:52:17,950
we have this metric which is the need

00:52:12,309 --> 00:52:19,630
risk ed okay we measure the

00:52:17,950 --> 00:52:21,700
scatter a shoe instead of the idle

00:52:19,630 --> 00:52:24,700
duration with machado I need risque

00:52:21,700 --> 00:52:28,150
tradition the duration how long we have

00:52:24,700 --> 00:52:30,369
been running the Eiger task so being

00:52:28,150 --> 00:52:31,989
scheduled in and schedule out it's an

00:52:30,369 --> 00:52:34,119
interesting metric we need that for

00:52:31,989 --> 00:52:36,700
example because if we have a task which

00:52:34,119 --> 00:52:38,979
is running on a CPU and the CPU is

00:52:36,700 --> 00:52:41,349
working on MMC for example reading

00:52:38,979 --> 00:52:44,499
whatever and it wake up the other task

00:52:41,349 --> 00:52:47,200
if we are just basing our the prediction

00:52:44,499 --> 00:52:49,029
on the timers and interrupt dodeth

00:52:47,200 --> 00:52:51,219
that's though the CPU doesn't have any

00:52:49,029 --> 00:52:53,109
interrupts so we need to rely on this

00:52:51,219 --> 00:52:55,410
need to be sketching and parroted thing

00:52:53,109 --> 00:52:58,329
in order to predict the next wake up

00:52:55,410 --> 00:53:03,099
because we wake up at other CPU it's

00:52:58,329 --> 00:53:05,710
like the time of broadcasting so in the

00:53:03,099 --> 00:53:08,349
same way that when we have this

00:53:05,710 --> 00:53:09,910
situation we should be take a decision

00:53:08,349 --> 00:53:14,829
from the governor what should we do to

00:53:09,910 --> 00:53:17,650
verify our debugger state so we I want

00:53:14,829 --> 00:53:20,440
to detect there is a situation where all

00:53:17,650 --> 00:53:22,239
the tasks are they have interaction

00:53:20,440 --> 00:53:24,729
between tasks and so we don't want to

00:53:22,239 --> 00:53:28,239
introduce latency want the task are tied

00:53:24,729 --> 00:53:30,160
together they are working together we

00:53:28,239 --> 00:53:32,369
don't want to introduce latency in this

00:53:30,160 --> 00:53:32,369
case

00:53:35,850 --> 00:53:44,880
we have been taking the multimedia

00:53:38,860 --> 00:53:44,880
senior year for and USP

00:53:45,260 --> 00:53:49,120
well our vacations to Webster

00:53:49,880 --> 00:53:53,950
yeah what I'm going to do

00:53:54,570 --> 00:54:10,010
that could be in solution but it's not a

00:53:57,360 --> 00:54:14,760
generic solution for the governor yes

00:54:10,010 --> 00:54:18,150
yes I don't want to put heuristic in the

00:54:14,760 --> 00:54:20,100
governor I want to identify no that's

00:54:18,150 --> 00:54:24,630
happening this kind of workload is

00:54:20,100 --> 00:54:27,720
happening I want to do this this the

00:54:24,630 --> 00:54:30,330
problem is that in your case would you

00:54:27,720 --> 00:54:33,120
play back this sequence is quite shot I

00:54:30,330 --> 00:54:34,110
mean the the flip between the two tasks

00:54:33,120 --> 00:54:36,000
is quite short

00:54:34,110 --> 00:54:38,400
you cannot exactly the same scenario

00:54:36,000 --> 00:54:43,740
doesn't mechanism use for tasks running

00:54:38,400 --> 00:54:45,720
for several thousand of millisecond and

00:54:43,740 --> 00:54:47,670
if you only look at the wakeup sequence

00:54:45,720 --> 00:54:50,010
and the completion that would be exactly

00:54:47,670 --> 00:54:52,140
the same scenario only the time between

00:54:50,010 --> 00:54:54,590
each event will be different and in this

00:54:52,140 --> 00:54:59,460
case you don't want to wait in wo5 I

00:54:54,590 --> 00:55:01,140
agree yeah that's why that the Metro

00:54:59,460 --> 00:55:08,520
means that you will have the same event

00:55:01,140 --> 00:55:10,860
I mean so yeah so here we are we are on

00:55:08,520 --> 00:55:13,140
the other aspect of the prediction so we

00:55:10,860 --> 00:55:18,210
have been working on the next inter

00:55:13,140 --> 00:55:21,480
prediction which is part yeah stop it's

00:55:18,210 --> 00:55:23,760
part of the three sources of wake-ups

00:55:21,480 --> 00:55:28,500
without timer timer are predictable so

00:55:23,760 --> 00:55:32,310
it's okay the inter prediction it's the

00:55:28,500 --> 00:55:34,860
the prediction is almost done and then

00:55:32,310 --> 00:55:39,290
we have the third source of wake up is

00:55:34,860 --> 00:55:43,290
the nearest gate the IPRA scheduling and

00:55:39,290 --> 00:55:46,860
we have to to be we can it's there is

00:55:43,290 --> 00:55:50,520
nothing there which is periodic it's

00:55:46,860 --> 00:55:53,100
random so we have to do we have to

00:55:50,520 --> 00:55:55,140
characterize what's happening with the

00:55:53,100 --> 00:55:57,390
need risk at with the rescheduling in

00:55:55,140 --> 00:56:01,170
order to say I want this kind of state

00:55:57,390 --> 00:56:02,880
or this kind of date do need that so

00:56:01,170 --> 00:56:06,180
it's another part of the investigation

00:56:02,880 --> 00:56:07,390
in order to totally have control of

00:56:06,180 --> 00:56:09,970
what's happening

00:56:07,390 --> 00:56:13,030
in the wake up pass and take the right

00:56:09,970 --> 00:56:20,500
decision from this point okay so I think

00:56:13,030 --> 00:56:22,560
we need to think about that okay thank

00:56:20,500 --> 00:56:22,560

YouTube URL: https://www.youtube.com/watch?v=69HQYihj5zg


