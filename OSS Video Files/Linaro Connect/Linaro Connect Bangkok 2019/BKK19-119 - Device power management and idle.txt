Title: BKK19-119 - Device power management and idle
Publication date: 2019-04-11
Playlist: Linaro Connect Bangkok 2019
Description: 
	Abstract
It can be a rather complicated task to deploy optimized power management (PM) support in a driver in Linux. There are several PM frameworks and corresponding function callbacks available per device, which the driver developer needs detailed knowledge about. Particularly, when the goal is to reach the best energy efficient behavior.

Additionally, ARM SoCs in general, have quite sophisticated and fine grained methods to put parts of a silicon into a low power state, as to avoid wasting power when there are no active users of these parts. In Linux these parts are typically modeled as so called, PM domains.

During the session, we dive into some of the relevant PM frameworks for dealing with idle and explains the concepts behind them. We look into how to deploy support for system wide low power states, such as suspend to ram, suspend to idle and suspend to disk. We look at it, both from the PM domain and the driver point of view.

Moreover, to deploy fine grained PM support, the session gives some best practices of how to use runtime PM and the generic PM domain frameworks, as well as looks into how to implement support for called wakeup interrupts.

Ulf Hansson / Senior Kernel Engineer Linaro
Ulf has a very long experience of using Linux and has been contributing the Linux kernel development for many years by now. He maintains the MMC subsystem and the generic PM domain in the Linux kernel, but also spends lots of time reviewing various changes related to power management and to their corresponding frameworks.

Moreover, Ulf has a background in real-time and embedded systems. He also has an in-depth knowledge about flash memory technologies, such as NAND and NOR.

Ulf is working for Linaro and specializing in power management.
Captions: 
	00:00:05,700 --> 00:00:13,660
so my name is Wolfensohn I'm working in

00:00:09,639 --> 00:00:17,199
the power management team and this is

00:00:13,660 --> 00:00:21,190
supposed to be a training kind of

00:00:17,199 --> 00:00:26,169
session so and it's about device power

00:00:21,190 --> 00:00:29,009
management and idle so yeah it was

00:00:26,169 --> 00:00:29,009
questions anytime

00:00:30,060 --> 00:00:37,990
so in particular we don't want to waste

00:00:33,910 --> 00:00:41,110
energy when that for more lot of the

00:00:37,990 --> 00:00:45,910
platform is being idle that's the main

00:00:41,110 --> 00:00:50,920
thing behind this yeah what we want to

00:00:45,910 --> 00:00:54,280
achieve so I want to go through a couple

00:00:50,920 --> 00:00:57,220
of frameworks that helps out with this

00:00:54,280 --> 00:00:59,730
in the Linux kernel and I'm going to

00:00:57,220 --> 00:01:03,430
point out some some use cases and

00:00:59,730 --> 00:01:07,570
deployments and in particular also show

00:01:03,430 --> 00:01:10,630
a couple of good practices and tricks of

00:01:07,570 --> 00:01:15,280
how we can do this from this device

00:01:10,630 --> 00:01:18,600
power management point of view so as I

00:01:15,280 --> 00:01:23,130
said it's it's a training session so

00:01:18,600 --> 00:01:26,679
feel free to ask questions at any time I

00:01:23,130 --> 00:01:29,549
have around 20 slides so it's not that

00:01:26,679 --> 00:01:36,579
much so there is definitely room for for

00:01:29,549 --> 00:01:41,560
discussions and questions perhaps a

00:01:36,579 --> 00:01:44,380
quick reality check and who among in the

00:01:41,560 --> 00:01:49,780
audience here is external developers

00:01:44,380 --> 00:01:52,920
camel driver develops and who has been

00:01:49,780 --> 00:01:52,920
doing poor management

00:01:53,530 --> 00:02:01,479
okay okay let's let's move on and I said

00:01:59,380 --> 00:02:03,690
please interrupt if you want to ask you

00:02:01,479 --> 00:02:03,690
something

00:02:05,759 --> 00:02:12,670
there is one framework or one way of

00:02:08,470 --> 00:02:15,250
doing dealing with idle and that's just

00:02:12,670 --> 00:02:20,790
that's the system-wide way of doing the

00:02:15,250 --> 00:02:24,940
system-wide sleep so in this in this way

00:02:20,790 --> 00:02:27,640
the entire platform is going to some

00:02:24,940 --> 00:02:29,950
kind of a low-power state in in a

00:02:27,640 --> 00:02:33,130
controlled fashion so to say so the

00:02:29,950 --> 00:02:36,940
entire system is is entering a sleep

00:02:33,130 --> 00:02:39,340
state and this is this can be triggered

00:02:36,940 --> 00:02:43,540
from I mean to do two different ways

00:02:39,340 --> 00:02:48,280
either you have the use of space

00:02:43,540 --> 00:02:51,910
I think and it's like when you close the

00:02:48,280 --> 00:02:54,280
little laptop for example and that means

00:02:51,910 --> 00:02:57,510
that the kernel gets notified from from

00:02:54,280 --> 00:03:02,440
use of space as I don't want the system

00:02:57,510 --> 00:03:04,709
any more low-power state and for those

00:03:02,440 --> 00:03:06,850
for you that's been working on Android

00:03:04,709 --> 00:03:08,860
you know it's a little bit differently

00:03:06,850 --> 00:03:11,380
there so that's there's some more

00:03:08,860 --> 00:03:13,390
mechanism inside the kernel to do this

00:03:11,380 --> 00:03:15,370
and that's that feature is called or to

00:03:13,390 --> 00:03:17,880
sleep in in the kernel it's kind of a

00:03:15,370 --> 00:03:21,579
you can you can consider it like a

00:03:17,880 --> 00:03:23,950
deferred timeout that keeps elapsing and

00:03:21,579 --> 00:03:26,980
keeps crisp in schedule all the time and

00:03:23,950 --> 00:03:30,220
it checks if the system is is ready to

00:03:26,980 --> 00:03:32,829
go to idle state and if it's if there's

00:03:30,220 --> 00:03:36,280
no one preventing it it will go to to

00:03:32,829 --> 00:03:41,859
this system-wide sleep States and the

00:03:36,280 --> 00:03:42,720
way to prevent this is if it's via so

00:03:41,859 --> 00:03:45,370
called

00:03:42,720 --> 00:03:48,670
wakeup sources for wake locks as they

00:03:45,370 --> 00:03:53,500
also mentioned this and you can prevent

00:03:48,670 --> 00:03:58,060
it either by using in kernel api's or by

00:03:53,500 --> 00:03:59,739
using su surface interfaces so it's kind

00:03:58,060 --> 00:04:01,860
of - two different approaches of how to

00:03:59,739 --> 00:04:10,020
to go into

00:04:01,860 --> 00:04:12,570
or go into the states and there is

00:04:10,020 --> 00:04:15,000
different low-power states supported by

00:04:12,570 --> 00:04:18,030
the kernel and these are the this or the

00:04:15,000 --> 00:04:19,920
main four so to say and this has been to

00:04:18,030 --> 00:04:21,510
idle that's actually the newest one

00:04:19,920 --> 00:04:24,180
that's been introduced it's it's quite a

00:04:21,510 --> 00:04:27,390
while now but it's it's the newest one

00:04:24,180 --> 00:04:31,010
and there's a suspender bus stand by

00:04:27,390 --> 00:04:34,650
suspend to Rama suspend to disk and

00:04:31,010 --> 00:04:37,410
there is a lot of common parts of the of

00:04:34,650 --> 00:04:40,050
the flow how we went to these states but

00:04:37,410 --> 00:04:44,010
there is also quite difference of course

00:04:40,050 --> 00:04:46,620
and I think the most common part that

00:04:44,010 --> 00:04:48,930
people are we're always suspend to ram

00:04:46,620 --> 00:04:50,490
thing at least in the arm arm world I

00:04:48,930 --> 00:04:56,520
would say that's the most commonly used

00:04:50,490 --> 00:04:58,800
thing and yeah what what in what happens

00:04:56,520 --> 00:05:01,530
is it principle that the RAM is put in a

00:04:58,800 --> 00:05:04,770
self self refresh mode and everything

00:05:01,530 --> 00:05:07,050
else is being powered of as long as

00:05:04,770 --> 00:05:10,770
possible and the lowest postage as

00:05:07,050 --> 00:05:14,520
possible and in the suspend to disk you

00:05:10,770 --> 00:05:16,560
will you will create like an image of

00:05:14,520 --> 00:05:19,380
the current state of the system and

00:05:16,560 --> 00:05:22,620
store that image to disk in how off the

00:05:19,380 --> 00:05:24,300
system and when you do the yeah we power

00:05:22,620 --> 00:05:26,669
on the system again you will see that

00:05:24,300 --> 00:05:29,340
this is this image is there and you will

00:05:26,669 --> 00:05:31,110
start to use it to restore the state of

00:05:29,340 --> 00:05:33,030
the system so it means that you will

00:05:31,110 --> 00:05:37,110
store we will be able to boot not as

00:05:33,030 --> 00:05:40,110
much faster than a fresh boot that's

00:05:37,110 --> 00:05:42,510
just I think that's the important part

00:05:40,110 --> 00:05:45,150
when you consider this a low-power state

00:05:42,510 --> 00:05:48,210
suspend to idle is a very similar to

00:05:45,150 --> 00:05:51,450
suspend to Ram there's a different way

00:05:48,210 --> 00:05:53,490
how to dealing with with the CPUs but

00:05:51,450 --> 00:05:59,130
it's very very similar to suspend to

00:05:53,490 --> 00:06:01,520
wrap and that says when you do yeah and

00:05:59,130 --> 00:06:08,510
that transitions

00:06:01,520 --> 00:06:08,510
any questions yep

00:06:11,349 --> 00:06:15,479
and take my microphone

00:06:22,980 --> 00:06:39,780
okay okay you explain this kind of

00:06:30,120 --> 00:06:39,780
system wide sleep match to which part of

00:06:40,320 --> 00:06:51,780
power subsystem lien Colonel say which

00:06:46,330 --> 00:06:56,169
part of power subsystem in colonel

00:06:51,780 --> 00:07:00,130
implement this kind of system wide sleep

00:06:56,169 --> 00:07:01,419
functions yeah I'm coming to it in a

00:07:00,130 --> 00:07:03,280
couple of lives I'm going to show a

00:07:01,419 --> 00:07:06,070
little bit more but you can consider

00:07:03,280 --> 00:07:09,160
this like to two parts if we really want

00:07:06,070 --> 00:07:16,000
to simplify how it works there's this

00:07:09,160 --> 00:07:18,550
very we'll say Colonel Centrex side of

00:07:16,000 --> 00:07:21,010
it that's implemented in /cam of more or

00:07:18,550 --> 00:07:23,770
less and that's where we take care of

00:07:21,010 --> 00:07:26,650
these common activities like when you

00:07:23,770 --> 00:07:29,590
when you start going to an idle state

00:07:26,650 --> 00:07:31,539
you will have to freeze some tasks and

00:07:29,590 --> 00:07:35,770
you have to freeze on threads and you

00:07:31,539 --> 00:07:38,620
have to make sure you spaces it's not no

00:07:35,770 --> 00:07:40,690
more running and so forth those parties

00:07:38,620 --> 00:07:43,240
like the common part and then we have

00:07:40,690 --> 00:07:46,720
all the all the I would say like

00:07:43,240 --> 00:07:49,630
platform specific things and devices and

00:07:46,720 --> 00:07:52,810
that is going to that's that's taken

00:07:49,630 --> 00:07:54,700
care of by a we call it PM core I'm

00:07:52,810 --> 00:07:58,050
going to talk a little bit about the

00:07:54,700 --> 00:07:58,050
details of that in

00:08:05,330 --> 00:08:16,350
so the primarily difference is that in

00:08:10,680 --> 00:08:21,750
suspension this the core part is going

00:08:16,350 --> 00:08:25,410
to unplug all the CPUs except for the

00:08:21,750 --> 00:08:28,020
boot CPUs so if you know about yes

00:08:25,410 --> 00:08:31,410
so if you know about CPU hot plugging

00:08:28,020 --> 00:08:34,110
that is exactly what is being used there

00:08:31,410 --> 00:08:37,440
so your hot plug off of the CPU and the

00:08:34,110 --> 00:08:41,300
new idle the lost CP and you you're

00:08:37,440 --> 00:08:45,090
actually also calling as to see specific

00:08:41,300 --> 00:08:48,830
callbacks in that path in the suspend to

00:08:45,090 --> 00:08:54,320
idle you are relying on the CPU idle

00:08:48,830 --> 00:08:54,320
framework to put the CPUs in

00:09:06,810 --> 00:09:12,480
so I haven't done any method measurement

00:09:09,660 --> 00:09:15,480
on that but I can definitely imagine

00:09:12,480 --> 00:09:19,350
that there is a improvement in using

00:09:15,480 --> 00:09:22,680
suspend tidal because because of doing

00:09:19,350 --> 00:09:30,930
this or plugging these is can be quite

00:09:22,680 --> 00:09:32,910
costly so yeah so if you have got things

00:09:30,930 --> 00:09:38,340
right in your hair in your

00:09:32,910 --> 00:09:42,090
implementation for bombers assists in

00:09:38,340 --> 00:09:45,030
general I would say not every case it

00:09:42,090 --> 00:09:48,150
would mean that as spent going to going

00:09:45,030 --> 00:09:51,090
to using suspend idle should be able to

00:09:48,150 --> 00:09:51,540
reach the same power numbers as suspend

00:09:51,090 --> 00:09:53,580
to run

00:09:51,540 --> 00:09:57,090
if you got something if you get it right

00:09:53,580 --> 00:10:01,410
and you do it faster because if you have

00:09:57,090 --> 00:10:05,040
less light so that's the ideal scenario

00:10:01,410 --> 00:10:10,500
would be that you spent widely but I

00:10:05,040 --> 00:10:13,470
know that I mean there's a lot of don't

00:10:10,500 --> 00:10:18,660
use it yet probably because of its a

00:10:13,470 --> 00:10:19,980
ramp up time no you know these things so

00:10:18,660 --> 00:10:23,600
why would the two schemes have been

00:10:19,980 --> 00:10:29,190
invented specifically to provide or to

00:10:23,600 --> 00:10:32,340
to alleviate the deficiencies of suspend

00:10:29,190 --> 00:10:34,410
to idle or suspend to RAM like why would

00:10:32,340 --> 00:10:35,940
they because it seems like we're we're

00:10:34,410 --> 00:10:39,930
doing two things to do the exact same

00:10:35,940 --> 00:10:41,910
thing so it's a legacy so we stop we

00:10:39,930 --> 00:10:43,950
start to do is talk about doing suspend

00:10:41,910 --> 00:10:46,890
to RAM because we thought that was to be

00:10:43,950 --> 00:10:49,650
the way of dealing with it but then we

00:10:46,890 --> 00:10:52,440
learned and realized that we can do it

00:10:49,650 --> 00:10:55,220
even better event to suspend title so

00:10:52,440 --> 00:10:55,220
that's that's how Ellis

00:10:59,480 --> 00:11:09,390
yes same frameworks it's a lot of code

00:11:07,740 --> 00:11:12,740
that's being reused in this post it's

00:11:09,390 --> 00:11:18,660
just the way how you deal with the CPUs

00:11:12,740 --> 00:11:21,839
would it be useful to remove one one of

00:11:18,660 --> 00:11:23,580
the scheme because it go yeah I mean we

00:11:21,839 --> 00:11:27,180
probably want to use this pen to idle in

00:11:23,580 --> 00:11:29,100
the long run and the other part well I

00:11:27,180 --> 00:11:30,570
think it's that's going to take some

00:11:29,100 --> 00:11:32,790
time because we are relying on all

00:11:30,570 --> 00:11:35,520
vandals to to adapt to that and all

00:11:32,790 --> 00:11:38,250
lettuces and all platforms you can't do

00:11:35,520 --> 00:11:39,690
that for as long as even one suspender

00:11:38,250 --> 00:11:45,080
idle is not as good as

00:11:39,690 --> 00:11:45,080
suspender and that's going to take time

00:11:49,220 --> 00:12:00,839
ok moving on I think I was here right I

00:11:57,240 --> 00:12:02,720
was touching about this user space thing

00:12:00,839 --> 00:12:06,150
that how you how you trigger this and

00:12:02,720 --> 00:12:07,470
this is just a slide to show how it

00:12:06,150 --> 00:12:10,860
actually looks how does the surface

00:12:07,470 --> 00:12:15,620
knobs looks like so there is a power

00:12:10,860 --> 00:12:19,020
state knob and you do an echo to that

00:12:15,620 --> 00:12:21,330
knob and instructing the kernel or what

00:12:19,020 --> 00:12:24,060
state to go to and there is these

00:12:21,330 --> 00:12:25,770
different states there the thing I

00:12:24,060 --> 00:12:28,260
wanted to mention a little bit more

00:12:25,770 --> 00:12:29,430
about is the mem state because it's a

00:12:28,260 --> 00:12:34,980
little bit more tricky than the other

00:12:29,430 --> 00:12:37,310
one so mem itself is configurable so it

00:12:34,980 --> 00:12:42,660
depends on what you have set this other

00:12:37,310 --> 00:12:46,620
men sleep state to - what's that you

00:12:42,660 --> 00:12:52,770
will go to so you can use this different

00:12:46,620 --> 00:12:56,339
well these different states in that to

00:12:52,770 --> 00:12:59,270
decide what men should meet but it's

00:12:56,339 --> 00:12:59,270
it's quite neat

00:12:59,900 --> 00:13:06,430
for this internal system sleep state the

00:13:04,970 --> 00:13:10,400
old asleep I was talking about earlier

00:13:06,430 --> 00:13:12,680
there is a special state and that's like

00:13:10,400 --> 00:13:14,480
a configuration so if alters to sleep

00:13:12,680 --> 00:13:17,150
the triggers and says that I want to go

00:13:14,480 --> 00:13:26,150
to a low-power state this is the state

00:13:17,150 --> 00:13:29,810
that we are going to and there is quite

00:13:26,150 --> 00:13:33,950
some documentation about this available

00:13:29,810 --> 00:13:35,270
in the kernel so go ahead and look at

00:13:33,950 --> 00:13:38,180
that if you want to have some more

00:13:35,270 --> 00:13:39,920
details there but in general I would say

00:13:38,180 --> 00:13:42,170
that when it comes to device power

00:13:39,920 --> 00:13:44,390
management there is actually quite good

00:13:42,170 --> 00:13:47,630
so good good documentation in the kernel

00:13:44,390 --> 00:13:50,420
so if you just if you just have some

00:13:47,630 --> 00:14:01,910
energy to do to look around there is you

00:13:50,420 --> 00:14:05,150
will find something some decent I think

00:14:01,910 --> 00:14:07,790
as user what you need to know is what is

00:14:05,150 --> 00:14:11,660
the typical use case for a user space so

00:14:07,790 --> 00:14:13,730
what does Android do what will Debian

00:14:11,660 --> 00:14:15,610
server do for example what kind of

00:14:13,730 --> 00:14:18,320
things will it poke down in these files

00:14:15,610 --> 00:14:20,810
by virtue of that user space it's one

00:14:18,320 --> 00:14:22,790
thing if I have my busy box and just

00:14:20,810 --> 00:14:25,250
echo stuff into the device but what will

00:14:22,790 --> 00:14:26,350
the different common user lands do

00:14:25,250 --> 00:14:30,410
that's my question

00:14:26,350 --> 00:14:32,510
so that is I mean it's it's configurable

00:14:30,410 --> 00:14:37,630
if you look at like an Ubuntu desktop

00:14:32,510 --> 00:14:41,090
for example you have like it's like some

00:14:37,630 --> 00:14:45,730
some settings dialogues when you can

00:14:41,090 --> 00:14:48,440
actually decide when my laptop is going

00:14:45,730 --> 00:14:51,110
without power or how should I do and

00:14:48,440 --> 00:14:54,800
when I am having the power cord in and

00:14:51,110 --> 00:14:56,210
it's been idle for 30 minutes what do

00:14:54,800 --> 00:14:58,250
you want to do so it's kind of this kind

00:14:56,210 --> 00:15:00,500
of settings interface it's not actually

00:14:58,250 --> 00:15:02,930
mapping to these names that's that's why

00:15:00,500 --> 00:15:04,250
it makes a little bit confusing but it's

00:15:02,930 --> 00:15:07,750
kind of what's happening in the

00:15:04,250 --> 00:15:11,360
background do you know what Android does

00:15:07,750 --> 00:15:13,020
so Android is using outer sleep but that

00:15:11,360 --> 00:15:14,520
doesn't mean that does not

00:15:13,020 --> 00:15:17,280
tell you what state that means because

00:15:14,520 --> 00:15:19,020
all to sleep easiest systems and then

00:15:17,280 --> 00:15:21,780
it's up to the device what it has

00:15:19,020 --> 00:15:26,460
configured in that service file exactly

00:15:21,780 --> 00:15:52,400
they also sleep viola great and that

00:15:26,460 --> 00:15:55,490
will be a band or specific typical I

00:15:52,400 --> 00:16:03,630
mean there is a mapping to a CPR yeah

00:15:55,490 --> 00:16:05,760
yeah so so I I'm guessing for an arm

00:16:03,630 --> 00:16:10,680
platforms it's always almost always a

00:16:05,760 --> 00:16:13,290
commemorate that's how it should be yeah

00:16:10,680 --> 00:16:16,320
and then on the mem sleep state again

00:16:13,290 --> 00:16:17,610
it's probably suspend to ram for almost

00:16:16,320 --> 00:16:19,650
everything right now because people

00:16:17,610 --> 00:16:38,460
haven't converted over to suspend title

00:16:19,650 --> 00:16:40,260
yes hello yeah so from a CPA s0 and s1

00:16:38,460 --> 00:16:42,810
state you're trying to is there any

00:16:40,260 --> 00:16:44,520
plant in arm world to map them to

00:16:42,810 --> 00:16:49,200
something standard so that we can do

00:16:44,520 --> 00:16:51,570
more standardization of the states no I

00:16:49,200 --> 00:16:57,960
don't think so maybe there is but I

00:16:51,570 --> 00:17:01,080
don't know something called se mi okay

00:16:57,960 --> 00:17:06,270
but how to talk to a power controller

00:17:01,080 --> 00:17:08,370
directly in space it's it's not

00:17:06,270 --> 00:17:11,720
implemented right now but in the server

00:17:08,370 --> 00:17:11,720
space it's mostly for clients right now

00:17:12,890 --> 00:17:20,089
device system s is always for the system

00:17:16,620 --> 00:17:23,990
system I see devices systems everything

00:17:20,089 --> 00:17:23,990
even though even systems here

00:17:29,780 --> 00:17:38,400
yeah for all armed platform on 64-bit

00:17:35,780 --> 00:17:40,860
when for suspend to either right now we

00:17:38,400 --> 00:17:43,410
are reaching the deepest available sea

00:17:40,860 --> 00:17:46,440
state that the default configuration so

00:17:43,410 --> 00:17:49,110
suspend trader is available for all the

00:17:46,440 --> 00:17:54,920
on 64-bit by default and you will reach

00:17:49,110 --> 00:17:54,920
the deepest available yes yeah sea State

00:17:57,260 --> 00:18:03,780
no not for system to idle you don't care

00:18:00,540 --> 00:18:06,210
about no it's only look at the deepest

00:18:03,780 --> 00:18:08,400
sea state they don't they don't care the

00:18:06,210 --> 00:18:11,570
Q s letter the wakeup latency that is

00:18:08,400 --> 00:18:11,570
used is the max value

00:18:17,230 --> 00:18:25,510
okay so moving into some more details

00:18:21,420 --> 00:18:28,630
shin-chan hospital before so I was

00:18:25,510 --> 00:18:32,500
talking about this common common stuff

00:18:28,630 --> 00:18:35,230
where do the freezing of tasks and so

00:18:32,500 --> 00:18:38,830
forth but when it comes to the device

00:18:35,230 --> 00:18:40,540
power management thing so if you're a

00:18:38,830 --> 00:18:41,950
little bit familiar with the driver and

00:18:40,540 --> 00:18:44,470
the device mostly in the Linux kernel

00:18:41,950 --> 00:18:47,830
you know there's a lot of devices that's

00:18:44,470 --> 00:18:51,540
being created and maintained in the

00:18:47,830 --> 00:18:54,970
kernel and all of these devices is is

00:18:51,540 --> 00:18:59,170
added in a DPM list subside device power

00:18:54,970 --> 00:19:02,380
management list and when you do the

00:18:59,170 --> 00:19:05,620
suspend thing there is a bunch of

00:19:02,380 --> 00:19:10,600
callbacks that this P n core is going to

00:19:05,620 --> 00:19:12,760
be invoking per device and assuming that

00:19:10,600 --> 00:19:15,520
we have like these four devices it means

00:19:12,760 --> 00:19:17,890
that the prepare callbacks is going to

00:19:15,520 --> 00:19:22,210
be invoked for the for the I square C

00:19:17,890 --> 00:19:24,670
and spi uart MMC in in an order way and

00:19:22,210 --> 00:19:26,530
then when all the prepare callbacks has

00:19:24,670 --> 00:19:29,860
been invoked it moves on to the next

00:19:26,530 --> 00:19:32,950
level which is suspend and suspend light

00:19:29,860 --> 00:19:35,500
and so forth when everything has been

00:19:32,950 --> 00:19:37,750
when all devices in this day list and

00:19:35,500 --> 00:19:40,180
all this callbacks has been invoked the

00:19:37,750 --> 00:19:44,380
device power management thingy is

00:19:40,180 --> 00:19:47,560
completed so to say and then there are

00:19:44,380 --> 00:19:51,520
some final things to bring the system

00:19:47,560 --> 00:19:53,650
into the low post and then for some

00:19:51,520 --> 00:19:57,580
reason you're waking up the system again

00:19:53,650 --> 00:19:59,920
and there is like similar things that

00:19:57,580 --> 00:20:03,850
happens from a device power management

00:19:59,920 --> 00:20:07,260
point of view to resume the system as a

00:20:03,850 --> 00:20:07,260
set of are called I stop

00:20:09,419 --> 00:20:15,880
how it divided the operation into the

00:20:13,240 --> 00:20:20,590
different callback functions for example

00:20:15,880 --> 00:20:23,760
that prepares us spend later now knock

00:20:20,590 --> 00:20:26,950
you so what's a methodology we can

00:20:23,760 --> 00:20:29,950
divide our code in to the different

00:20:26,950 --> 00:20:31,960
Quebec function if I understand you

00:20:29,950 --> 00:20:34,450
correctly you're asking why these

00:20:31,960 --> 00:20:39,460
callbacks are so many and why those all

00:20:34,450 --> 00:20:43,120
exist right so again it's it's legacy

00:20:39,460 --> 00:20:45,240
reasons so if if we had to redesign this

00:20:43,120 --> 00:20:48,340
that would be probably one call back

00:20:45,240 --> 00:20:52,929
suspend and one call back with you and

00:20:48,340 --> 00:20:55,990
you will probably provide I mean device

00:20:52,929 --> 00:20:58,090
specific and idle state specific in a

00:20:55,990 --> 00:21:01,570
different way so this is something that

00:20:58,090 --> 00:21:04,240
has been growing and evolving over years

00:21:01,570 --> 00:21:07,450
and we've ended up with this and this is

00:21:04,240 --> 00:21:09,190
just a very minor subset of callbacks

00:21:07,450 --> 00:21:11,890
there is different callbacks for

00:21:09,190 --> 00:21:14,350
hibernation for example it's it's a

00:21:11,890 --> 00:21:18,399
complete mess but yeah so there's

00:21:14,350 --> 00:21:20,049
there's no work on I've been to a couple

00:21:18,399 --> 00:21:22,299
of conferences talking to this

00:21:20,049 --> 00:21:24,760
maintainer guys that's involved here and

00:21:22,299 --> 00:21:27,070
I think we are all in agreement that we

00:21:24,760 --> 00:21:30,010
want to change this we want to do it in

00:21:27,070 --> 00:21:34,059
a in a different way but it's it's not

00:21:30,010 --> 00:21:38,020
an easy task so maybe in the long run

00:21:34,059 --> 00:21:43,270
this will improve but this is what we

00:21:38,020 --> 00:21:46,090
have there's like I think there's like

00:21:43,270 --> 00:21:49,090
20 callbacks or something in just an era

00:21:46,090 --> 00:21:51,309
2 p.m. for the driver confusing I think

00:21:49,090 --> 00:21:53,080
from from an arm point of view and from

00:21:51,309 --> 00:21:55,510
suspend to RAM suspend idle point of

00:21:53,080 --> 00:21:58,240
view these eight are the one that's

00:21:55,510 --> 00:22:01,179
important and then there is I'm coming

00:21:58,240 --> 00:22:03,880
to different framework as well so as an

00:22:01,179 --> 00:22:07,860
additional two would say so we have 10

00:22:03,880 --> 00:22:07,860
that is important for us

00:22:08,549 --> 00:22:15,990
all right so moving on to the next next

00:22:13,210 --> 00:22:18,190
thing here that's that's the other

00:22:15,990 --> 00:22:23,740
framework that helps us dealing with

00:22:18,190 --> 00:22:25,809
idle and we don't always want to put the

00:22:23,740 --> 00:22:28,870
entire system into a low-power state

00:22:25,809 --> 00:22:33,190
there is part of a system devices in a

00:22:28,870 --> 00:22:38,649
system that is I mean powered on wasting

00:22:33,190 --> 00:22:41,080
power but not being used so it this

00:22:38,649 --> 00:22:44,710
framework is called one time PM provides

00:22:41,080 --> 00:22:47,799
you with with these features of actually

00:22:44,710 --> 00:22:51,330
powering off these devices independently

00:22:47,799 --> 00:22:54,730
from other devices on a running system

00:22:51,330 --> 00:22:57,070
so and to do that there is a bunch of

00:22:54,730 --> 00:22:59,529
helpers there I'm not going to explain

00:22:57,070 --> 00:23:02,669
them in details but there is reference

00:22:59,529 --> 00:23:05,049
counting available and there is

00:23:02,669 --> 00:23:09,510
asynchronous and synchronous interfaces

00:23:05,049 --> 00:23:12,429
to to power on and power of devices and

00:23:09,510 --> 00:23:14,559
in principle what you what you want to

00:23:12,429 --> 00:23:18,159
do in from a drivers assistant point of

00:23:14,559 --> 00:23:20,350
view that you may have a request coming

00:23:18,159 --> 00:23:22,480
in to your driver saying ah yeah you

00:23:20,350 --> 00:23:25,419
please serve me with this request to be

00:23:22,480 --> 00:23:26,919
able to serve me and so the caller with

00:23:25,419 --> 00:23:29,320
this request you need to power on your

00:23:26,919 --> 00:23:29,740
control or your device and then you do

00:23:29,320 --> 00:23:32,830
this

00:23:29,740 --> 00:23:36,429
resuming you do probably a payment and

00:23:32,830 --> 00:23:38,080
get sinky to resume your device or power

00:23:36,429 --> 00:23:39,880
on your device and then you deal with

00:23:38,080 --> 00:23:43,059
your request with them when you're done

00:23:39,880 --> 00:23:43,899
with that you will call a poot API say

00:23:43,059 --> 00:23:47,139
I'm fine

00:23:43,899 --> 00:23:52,840
just let it let my device go off now to

00:23:47,139 --> 00:23:54,850
save power and in quite quite many cases

00:23:52,840 --> 00:23:57,669
these requests tends to come in in

00:23:54,850 --> 00:24:00,190
boosts so you might get five requests in

00:23:57,669 --> 00:24:00,610
a row and of course if you power off a

00:24:00,190 --> 00:24:02,200
device

00:24:00,610 --> 00:24:04,029
it means that it will introduce a lace

00:24:02,200 --> 00:24:05,580
latency when there is new requests

00:24:04,029 --> 00:24:08,440
because you need to power on the device

00:24:05,580 --> 00:24:11,169
so instead of always doing powering off

00:24:08,440 --> 00:24:14,529
for each and every request you can add a

00:24:11,169 --> 00:24:16,840
little little delay or an idle period so

00:24:14,529 --> 00:24:19,029
to say before you actually power you

00:24:16,840 --> 00:24:21,429
powering off the device and that's this

00:24:19,029 --> 00:24:21,920
out to suspend things don't confuse it

00:24:21,429 --> 00:24:24,980
without

00:24:21,920 --> 00:24:26,390
people tend to do that and that's the

00:24:24,980 --> 00:24:28,520
system sleep stuff that we're talking

00:24:26,390 --> 00:24:32,360
about before so the outer suspend here

00:24:28,520 --> 00:24:35,180
is is an run time p.m. specific feature

00:24:32,360 --> 00:24:37,670
that allows you to specify this idle

00:24:35,180 --> 00:24:40,210
period and deal with this which very

00:24:37,670 --> 00:24:51,140
convenient if you have boosts forecast

00:24:40,210 --> 00:24:54,260
to avoid this latency right so apart

00:24:51,140 --> 00:24:57,890
from get sink and put are there any

00:24:54,260 --> 00:25:01,610
other any other features available in

00:24:57,890 --> 00:25:03,500
the kernel for device or toe suspending

00:25:01,610 --> 00:25:05,210
without that Auto suspend le which is

00:25:03,500 --> 00:25:07,190
anyway as a function of get sink and

00:25:05,210 --> 00:25:28,330
port is there any other third kind of

00:25:07,190 --> 00:25:32,420
mechanism today using delayed this

00:25:28,330 --> 00:25:45,500
should suit if it doesn't we need to

00:25:32,420 --> 00:25:54,460
expand it API to control some kind of

00:25:45,500 --> 00:25:57,140
dependency of the device runtime p.m.

00:25:54,460 --> 00:25:59,660
infrastructure code respects to things

00:25:57,140 --> 00:26:02,540
from dependency point of view one is

00:25:59,660 --> 00:26:04,820
this parent-child story so if you power

00:26:02,540 --> 00:26:07,790
on a child the parent will always be

00:26:04,820 --> 00:26:09,830
resumed one child is resumed but there

00:26:07,790 --> 00:26:12,830
is also something that's called device

00:26:09,830 --> 00:26:14,840
links and as that's a framework where

00:26:12,830 --> 00:26:17,540
you can specify functional dependencies

00:26:14,840 --> 00:26:20,990
between devices so if there is one

00:26:17,540 --> 00:26:22,700
device depending on another this one

00:26:20,990 --> 00:26:25,010
time p.m. infrastructure code will also

00:26:22,700 --> 00:26:27,200
make sure that my functional dependency

00:26:25,010 --> 00:26:29,490
devices also with you

00:26:27,200 --> 00:26:42,570
that's the same thing for this system

00:26:29,490 --> 00:26:46,549
sleep also being respected can you give

00:26:42,570 --> 00:26:48,929
an example of such a device dependency

00:26:46,549 --> 00:26:51,809
not bound I like like not the controller

00:26:48,929 --> 00:27:00,120
and a device but you like you know the

00:26:51,809 --> 00:27:02,730
other one Nuala kind a device having it

00:27:00,120 --> 00:27:05,820
needs to have a clock enabled to be able

00:27:02,730 --> 00:27:07,830
to run but that clock might be behind

00:27:05,820 --> 00:27:11,280
some I swear see your boss or something

00:27:07,830 --> 00:27:17,429
and to be able to run you need this ask

00:27:11,280 --> 00:27:19,799
for see device to be so so currently up

00:27:17,429 --> 00:27:23,309
streamed forget and get then put calls

00:27:19,799 --> 00:27:25,350
so whenever we pass a device which

00:27:23,309 --> 00:27:29,549
probably doesn't have run time p.m.

00:27:25,350 --> 00:27:31,380
enable if we call run time get or put

00:27:29,549 --> 00:27:34,770
you actually get an error code which is

00:27:31,380 --> 00:27:36,630
quite vague so the interpretation of

00:27:34,770 --> 00:27:38,490
that error code isn't like now probably

00:27:36,630 --> 00:27:42,000
it gets involved or something like that

00:27:38,490 --> 00:27:44,520
so do you I couldn't fix that or do you

00:27:42,000 --> 00:27:48,570
think that should go into the PM core

00:27:44,520 --> 00:27:51,059
because there's lots of wrappers to many

00:27:48,570 --> 00:27:53,640
drivers actually not just one at least

00:27:51,059 --> 00:27:56,970
32 instances in the kernel so do you

00:27:53,640 --> 00:27:59,400
think that makes sense to actually PM

00:27:56,970 --> 00:28:02,760
code written like e no support or some

00:27:59,400 --> 00:28:04,500
some yeah we could probably explore that

00:28:02,760 --> 00:28:06,330
I know there is a bunch of drivers that

00:28:04,500 --> 00:28:09,840
actually tries to deal with this error

00:28:06,330 --> 00:28:13,320
code properly but it's not it's not

00:28:09,840 --> 00:28:19,770
obvious of how to do that so it tends to

00:28:13,320 --> 00:28:22,020
be it's easy to get wrong that's what

00:28:19,770 --> 00:28:26,250
I'm saying yeah that's why I think lots

00:28:22,020 --> 00:28:27,539
of court has like yeah it's a good point

00:28:26,250 --> 00:28:31,380
it's something that we could look into

00:28:27,539 --> 00:28:32,970
to improve I'm not exactly sure how to

00:28:31,380 --> 00:28:39,270
do it

00:28:32,970 --> 00:28:41,340
okay so if I remember correctly the rent

00:28:39,270 --> 00:28:42,500
I'm get sink or rammed I can get cannot

00:28:41,340 --> 00:28:45,690
sleep right

00:28:42,500 --> 00:28:47,670
I'll eat can't sleep so it depends on

00:28:45,690 --> 00:28:51,620
how you have configured to run 10:00

00:28:47,670 --> 00:28:53,870
p.m. when you do the when you do the

00:28:51,620 --> 00:28:55,590
initialization of your run time p.m.

00:28:53,870 --> 00:28:57,510
deployments or say from them

00:28:55,590 --> 00:28:59,940
you call this pin one time enable for

00:28:57,510 --> 00:29:04,020
example yeah there is an API called p.m.

00:28:59,940 --> 00:29:06,120
on time i RQ safe and that instructs the

00:29:04,020 --> 00:29:10,830
run time p.m. core that this is a device

00:29:06,120 --> 00:29:15,680
which callbacks might be executed from

00:29:10,830 --> 00:29:15,680
atomic context you can do that

00:29:21,510 --> 00:29:28,910
okay I think we actually won't walk

00:29:23,910 --> 00:29:28,910
through this already but just to mention

00:29:54,330 --> 00:29:58,719
sorry yeah

00:29:56,129 --> 00:30:02,440
they resumed callback will be invoked

00:29:58,719 --> 00:30:04,839
and in that callback you do that power

00:30:02,440 --> 00:30:09,129
on of the device you do some work and

00:30:04,839 --> 00:30:11,679
then you delete and the rest suspend

00:30:09,129 --> 00:30:19,479
callback will be invoked power of the

00:30:11,679 --> 00:30:21,639
device yeah so this is the callback

00:30:19,479 --> 00:30:28,929
we've been talking about it's it's a bit

00:30:21,639 --> 00:30:34,779
messy but yeah anyway so these callbacks

00:30:28,929 --> 00:30:40,719
are all contained in a struct dev PM ops

00:30:34,779 --> 00:30:45,969
and just remember that for fall for a

00:30:40,719 --> 00:30:51,359
couple of slides going going head things

00:30:45,969 --> 00:30:51,359
can go a little bit more complicated so

00:30:51,539 --> 00:30:57,729
there's more complex topology there it's

00:30:54,940 --> 00:31:00,639
not like every device is completely

00:30:57,729 --> 00:31:04,200
independently independent from other

00:31:00,639 --> 00:31:09,009
devices some devices may actually share

00:31:04,200 --> 00:31:11,200
resources with other devices and for

00:31:09,009 --> 00:31:13,209
example here I've drawn a picture where

00:31:11,200 --> 00:31:16,950
there was a power rail that's being

00:31:13,209 --> 00:31:20,799
shared among a couple of i/o devices and

00:31:16,950 --> 00:31:23,109
to manage these kind of complex or

00:31:20,799 --> 00:31:26,079
topologies we have invented something

00:31:23,109 --> 00:31:29,950
that we call TM domains in the kernel

00:31:26,079 --> 00:31:33,419
and that is something that applies to

00:31:29,950 --> 00:31:38,259
both this system-wide scenarios and

00:31:33,419 --> 00:31:42,909
runtime PM's in artists and to deal with

00:31:38,259 --> 00:31:44,829
this you easily understand that we need

00:31:42,909 --> 00:31:48,279
some kind of higher here to represent

00:31:44,829 --> 00:31:53,320
this and that's what we have so in this

00:31:48,279 --> 00:31:54,999
truck device we have a set of of structs

00:31:53,320 --> 00:31:58,089
and there is something that's called

00:31:54,999 --> 00:32:00,849
driver of course that's I think we all

00:31:58,089 --> 00:32:03,460
know about that and the driver can have

00:32:00,849 --> 00:32:04,110
these def p.m. ops I was talking about

00:32:03,460 --> 00:32:09,240
all you

00:32:04,110 --> 00:32:12,720
but that can also be on a level above

00:32:09,240 --> 00:32:14,580
which is the bus and the highest

00:32:12,720 --> 00:32:17,309
hierarchy and the level is the TM domain

00:32:14,580 --> 00:32:20,580
it can also have this structure females

00:32:17,309 --> 00:32:22,529
so it's like a hierarchy of callbacks so

00:32:20,580 --> 00:32:24,269
it's not just one set of code but it's

00:32:22,529 --> 00:32:28,230
like a hierarchy of callbacks it's even

00:32:24,269 --> 00:32:31,289
more complicated than this so if you

00:32:28,230 --> 00:32:34,070
said we had like 40 callbacks that means

00:32:31,289 --> 00:32:39,809
like we actually have 100 and yeah a

00:32:34,070 --> 00:32:43,380
bunch of cowboys it's quite insane so

00:32:39,809 --> 00:32:46,470
one of these implementation of p.m.

00:32:43,380 --> 00:32:49,940
domains that I was talking about is a

00:32:46,470 --> 00:32:53,669
CPI I'm not going to go into details but

00:32:49,940 --> 00:32:57,269
I want to mention a few things here

00:32:53,669 --> 00:32:58,279
that's that's important for for first to

00:32:57,269 --> 00:33:01,649
know about that

00:32:58,279 --> 00:33:04,440
so the a CPI is like a firm were driven

00:33:01,649 --> 00:33:09,450
in the face of how to control power

00:33:04,440 --> 00:33:11,190
management and that's not I mean that's

00:33:09,450 --> 00:33:13,519
not that's not specific so to say but

00:33:11,190 --> 00:33:17,159
the thing is that specific is that it's

00:33:13,519 --> 00:33:21,649
almost everything is known by the former

00:33:17,159 --> 00:33:25,590
so it's so it's like a very centralized

00:33:21,649 --> 00:33:27,480
view of dealing with power management so

00:33:25,590 --> 00:33:30,899
to say and there's nothing bad with that

00:33:27,480 --> 00:33:32,549
but this is what we're using with being

00:33:30,899 --> 00:33:39,299
used on ecstasies a long time and

00:33:32,549 --> 00:33:41,279
unarmed servers and yeah so that's

00:33:39,299 --> 00:33:44,039
that's something that we can keep in

00:33:41,279 --> 00:33:46,289
mind when I move ahead and think about

00:33:44,039 --> 00:33:48,960
the other deployments of power lines

00:33:46,289 --> 00:33:51,450
which is completely have a different

00:33:48,960 --> 00:33:52,429
mindset of how they how we implement

00:33:51,450 --> 00:33:57,149
this

00:33:52,429 --> 00:33:58,649
so both ICP RPM domain obviously

00:33:57,149 --> 00:34:01,760
supports both one 10 p.m. and

00:33:58,649 --> 00:34:01,760
system-wide sleep

00:34:04,670 --> 00:34:13,260
this moves into the other deployment of

00:34:10,130 --> 00:34:19,080
power domains and that's the generic or

00:34:13,260 --> 00:34:20,520
domain Archaea Yin PD that's that's one

00:34:19,080 --> 00:34:22,740
of those infrastructure that me

00:34:20,520 --> 00:34:27,180
personally is maintaining in the kernel

00:34:22,740 --> 00:34:31,380
and it's its intent is to provide like a

00:34:27,180 --> 00:34:35,690
generic and flexible way of letting SOC

00:34:31,380 --> 00:34:42,230
in platforms implement this power lines

00:34:35,690 --> 00:34:45,510
and it gives a bunch of features and you

00:34:42,230 --> 00:34:48,150
can you can have like you and Nestor the

00:34:45,510 --> 00:34:49,950
nested way of describing these domains

00:34:48,150 --> 00:34:52,860
so you can have like a hierarchical way

00:34:49,950 --> 00:34:56,790
of having domains not only devices can

00:34:52,860 --> 00:35:07,380
be hard to pull also the domains and it

00:34:56,790 --> 00:35:13,320
allows you to to register provide or

00:35:07,380 --> 00:35:15,480
specific callback so to say so to deal

00:35:13,320 --> 00:35:17,400
with this power domains you can power on

00:35:15,480 --> 00:35:20,730
power remains you can power of all

00:35:17,400 --> 00:35:23,040
domains and and so forth so onion PD

00:35:20,730 --> 00:35:27,030
gives you give you this infrastructure

00:35:23,040 --> 00:35:33,990
code to register this platform specific

00:35:27,030 --> 00:35:37,170
providers so to say what it also does is

00:35:33,990 --> 00:35:41,280
that it helps to deal with this

00:35:37,170 --> 00:35:45,660
attaching thing so when when a device

00:35:41,280 --> 00:35:50,130
gets probed the kernel or a couple of

00:35:45,660 --> 00:35:53,460
different buses subsystems asked for ask

00:35:50,130 --> 00:35:55,860
for their devices to be attached to a

00:35:53,460 --> 00:35:57,690
potential power domain and that's what

00:35:55,860 --> 00:36:00,330
all this magic happens in the background

00:35:57,690 --> 00:36:02,850
that this this dev team office I was

00:36:00,330 --> 00:36:05,880
talking to go about all your is going to

00:36:02,850 --> 00:36:10,080
be hooked up to this team domain on that

00:36:05,880 --> 00:36:11,670
level so to say so that's kind of what

00:36:10,080 --> 00:36:14,280
happens in the background when a driver

00:36:11,670 --> 00:36:19,860
probes without the driver also

00:36:14,280 --> 00:36:23,670
having to care about it what it also

00:36:19,860 --> 00:36:28,560
supports is that you can have you can

00:36:23,670 --> 00:36:30,510
even have multiple devices having sorry

00:36:28,560 --> 00:36:32,910
a device can have even have multiple

00:36:30,510 --> 00:36:35,040
p.m. demands which is kind of a new

00:36:32,910 --> 00:36:37,350
thing I'm not going to touch that on

00:36:35,040 --> 00:36:41,840
this training it's something that

00:36:37,350 --> 00:36:43,980
dissolves separates lot of I think

00:36:41,840 --> 00:36:45,450
another thing that's also supported by

00:36:43,980 --> 00:36:48,110
MPD is something that we call

00:36:45,450 --> 00:36:51,300
performance tights which is related to

00:36:48,110 --> 00:36:54,630
devfs dynamic voltage frequency scaling

00:36:51,300 --> 00:37:05,250
but that is also a separate slot to talk

00:36:54,630 --> 00:37:06,870
about so some other time and certain

00:37:05,250 --> 00:37:09,030
domains might be where you have

00:37:06,870 --> 00:37:10,710
intermediate states where in their

00:37:09,030 --> 00:37:12,510
intermediate engine states so why you

00:37:10,710 --> 00:37:29,010
wanna know why you have others not been

00:37:12,510 --> 00:37:31,530
provided so it means that you can you

00:37:29,010 --> 00:37:33,990
can specify when you register your the

00:37:31,530 --> 00:37:36,480
MPD provider say that this is my

00:37:33,990 --> 00:37:44,130
provider and it has for off state or for

00:37:36,480 --> 00:37:47,430
idle States this is like what this is

00:37:44,130 --> 00:37:50,790
this supported in the MPD from a device

00:37:47,430 --> 00:37:54,000
3 point of view it's binding so are

00:37:50,790 --> 00:37:57,180
there and are free to be used so you can

00:37:54,000 --> 00:38:00,000
you can actually specify the PM domain

00:37:57,180 --> 00:38:01,710
topology here you can specify the PM

00:38:00,000 --> 00:38:04,680
domains and if you have a hierarchy

00:38:01,710 --> 00:38:06,780
there you can specify that and for each

00:38:04,680 --> 00:38:11,370
of the devices that you have device

00:38:06,780 --> 00:38:14,310
nodes you can instruct what domains

00:38:11,370 --> 00:38:16,740
these devices are going to be attached

00:38:14,310 --> 00:38:21,780
to so it's it's quite convenient and

00:38:16,740 --> 00:38:26,100
this is just a simple example

00:38:21,780 --> 00:38:27,360
there is a of course documentation for

00:38:26,100 --> 00:38:37,260
these bindings that you can have a look

00:38:27,360 --> 00:38:41,090
at I know a lot of examples is there

00:38:37,260 --> 00:38:55,350
some way to have like more than one

00:38:41,090 --> 00:38:57,570
parent one link yes all that is managed

00:38:55,350 --> 00:39:00,060
eternally by about your PD reference

00:38:57,570 --> 00:39:02,850
counting and all that stuff so for this

00:39:00,060 --> 00:39:04,950
case here for example it means that I

00:39:02,850 --> 00:39:07,590
mean if there is one of these devices

00:39:04,950 --> 00:39:10,620
that is active of course you cannot

00:39:07,590 --> 00:39:16,560
power off the domain and that's that's

00:39:10,620 --> 00:39:20,280
the whole thing what would be the state

00:39:16,560 --> 00:39:23,280
of the device then when we do a power of

00:39:20,280 --> 00:39:25,800
the mind down so would it in terms of

00:39:23,280 --> 00:39:28,920
device hierarchy would it actually tear

00:39:25,800 --> 00:39:31,590
down the device totally or so if we talk

00:39:28,920 --> 00:39:34,170
about the runtime PM case so let's go

00:39:31,590 --> 00:39:35,790
back so if we talked about the runtime

00:39:34,170 --> 00:39:38,790
PM case that means that all of these

00:39:35,790 --> 00:39:41,730
four devices may have may have different

00:39:38,790 --> 00:39:43,710
drivers of course and these drivers may

00:39:41,730 --> 00:39:45,810
have deployed runtime PM there's a lot

00:39:43,710 --> 00:39:51,870
of get input being done on these

00:39:45,810 --> 00:39:55,650
different devices yeah so when when any

00:39:51,870 --> 00:39:57,690
of these devices our runtime resumed it

00:39:55,650 --> 00:40:02,550
means that the power domain for all of

00:39:57,690 --> 00:40:06,390
these devices or orden when all of these

00:40:02,550 --> 00:40:08,640
devices goes off or exact all the last

00:40:06,390 --> 00:40:12,600
device goes off there is already three

00:40:08,640 --> 00:40:15,000
orphan the fourth also goes off MPD sees

00:40:12,600 --> 00:40:17,970
that now all my devices that has are

00:40:15,000 --> 00:40:21,180
attached to this domain of then I can

00:40:17,970 --> 00:40:23,820
power of entire domain yeah so what's

00:40:21,180 --> 00:40:26,220
all so vice versus happens when you do

00:40:23,820 --> 00:40:28,710
the power on of course so if there's no

00:40:26,220 --> 00:40:31,620
devices that's on I need the power on my

00:40:28,710 --> 00:40:33,420
power domain first so the device

00:40:31,620 --> 00:40:34,390
instance even in the power dome state

00:40:33,420 --> 00:40:41,080
will be

00:40:34,390 --> 00:40:44,620
there it just marked as as a inactive or

00:40:41,080 --> 00:40:46,720
what yes doesn't it make sense to tear

00:40:44,620 --> 00:40:50,410
it down because there's no power rail at

00:40:46,720 --> 00:40:54,790
all to tear down the device or the

00:40:50,410 --> 00:40:57,130
device itself so it's actually the

00:40:54,790 --> 00:41:01,110
opposite around so it's it's as good as

00:40:57,130 --> 00:41:01,110
remove the power from a device isn't it

00:41:01,980 --> 00:41:13,360
so we have that so no so we have let's

00:41:11,140 --> 00:41:20,680
say we have a use case wherein if you

00:41:13,360 --> 00:41:23,050
look at this large maybe it helps yes so

00:41:20,680 --> 00:41:24,580
what what we are trying to my I'm trying

00:41:23,050 --> 00:41:26,740
to understand is that we have a use case

00:41:24,580 --> 00:41:29,140
wherein they have a DSP and with their

00:41:26,740 --> 00:41:31,510
some processes running in the DSP and

00:41:29,140 --> 00:41:33,910
they could dynamically go down and come

00:41:31,510 --> 00:41:36,580
up right so I was thinking could we

00:41:33,910 --> 00:41:39,610
attach it to runtime I mean power

00:41:36,580 --> 00:41:42,010
domains and get it working or should we

00:41:39,610 --> 00:41:44,110
so should we really tear down the device

00:41:42,010 --> 00:41:49,180
when the power down happens on that

00:41:44,110 --> 00:41:50,860
remote side so if you have is it one

00:41:49,180 --> 00:41:53,250
device or it several device there

00:41:50,860 --> 00:41:56,500
multiple services actually so yeah so

00:41:53,250 --> 00:41:58,090
then you have to all you have to figure

00:41:56,500 --> 00:42:00,490
out if there are some dependency between

00:41:58,090 --> 00:42:03,100
the devices although some dependency

00:42:00,490 --> 00:42:05,650
from you know parent-child point of view

00:42:03,100 --> 00:42:08,710
other are there sharing some power

00:42:05,650 --> 00:42:11,050
resources so if they're sharing policies

00:42:08,710 --> 00:42:13,110
you should have a power domain I mean

00:42:11,050 --> 00:42:15,370
I'm not saying that they are sharing a

00:42:13,110 --> 00:42:17,500
o'clock or something that can be managed

00:42:15,370 --> 00:42:20,140
to the clock clock three but if they

00:42:17,500 --> 00:42:22,300
share like a power domain they're on the

00:42:20,140 --> 00:42:25,060
same islands are safe I have already for

00:42:22,300 --> 00:42:27,550
example that that's a good argument for

00:42:25,060 --> 00:42:30,460
having a power domain and if they're

00:42:27,550 --> 00:42:33,490
just parent-child just implement the the

00:42:30,460 --> 00:42:40,110
callbacks on the driver or the subsystem

00:42:33,490 --> 00:42:40,110
level that should be sufficient yeah

00:42:43,400 --> 00:42:49,890
so just wanted to mention a little bit

00:42:46,170 --> 00:42:55,440
about this governor I briefly mentioned

00:42:49,890 --> 00:42:59,250
before as well so when we do this power

00:42:55,440 --> 00:43:01,500
of in runtime of a device we obviously

00:42:59,250 --> 00:43:03,650
needs to resume its power on it when we

00:43:01,500 --> 00:43:06,750
are going to use it again and that

00:43:03,650 --> 00:43:09,480
introduces la latency like request

00:43:06,750 --> 00:43:13,110
latency panel and in some cases that's

00:43:09,480 --> 00:43:14,610
completely yeah it doesn't matter

00:43:13,110 --> 00:43:16,680
because that time to resume the device

00:43:14,610 --> 00:43:20,700
is so quick so it doesn't it doesn't

00:43:16,680 --> 00:43:22,800
care and but in case it's when it does

00:43:20,700 --> 00:43:25,800
matter there is three ways to mitigate

00:43:22,800 --> 00:43:27,660
this problem and I also already

00:43:25,800 --> 00:43:29,310
mentioned this all to suspend see where

00:43:27,660 --> 00:43:31,200
you can deal with both requests you

00:43:29,310 --> 00:43:34,560
don't have to do this up and down the

00:43:31,200 --> 00:43:37,650
code between every request but in the

00:43:34,560 --> 00:43:39,990
worst case scenario you have a yeah you

00:43:37,650 --> 00:43:41,940
cannot accept any latency at all and

00:43:39,990 --> 00:43:44,700
then you can just resume the device and

00:43:41,940 --> 00:43:47,820
keep it on until you're ready with your

00:43:44,700 --> 00:43:49,440
use case or whatever but there is also a

00:43:47,820 --> 00:43:52,290
third option that's a little bit more

00:43:49,440 --> 00:43:55,380
fine fine grained so to say more more

00:43:52,290 --> 00:43:58,500
flexible that is that for each these

00:43:55,380 --> 00:44:02,150
each of these PM domains you can attach

00:43:58,500 --> 00:44:05,940
governor to it and that governor

00:44:02,150 --> 00:44:08,640
monitors so called MP mqs latency

00:44:05,940 --> 00:44:12,930
constraints so for each device in the

00:44:08,640 --> 00:44:15,390
system there is a use of space use or a

00:44:12,930 --> 00:44:17,460
sous-chef interface for user space where

00:44:15,390 --> 00:44:19,920
we can specify these latency constraints

00:44:17,460 --> 00:44:24,630
and there is also in kernel api's to do

00:44:19,920 --> 00:44:27,720
this so when this device is going to is

00:44:24,630 --> 00:44:29,730
being requested to be powered off from

00:44:27,720 --> 00:44:31,920
the one-time p.m. point of view this

00:44:29,730 --> 00:44:34,800
governor is going to kick in and say

00:44:31,920 --> 00:44:36,960
that hmm there is actually a latency

00:44:34,800 --> 00:44:39,210
request set on this device I'm not going

00:44:36,960 --> 00:44:41,880
to allow it to be power of and so it

00:44:39,210 --> 00:44:45,180
just bails out and says that it's still

00:44:41,880 --> 00:44:47,420
on so that's that's the principle behind

00:44:45,180 --> 00:44:47,420
this

00:44:50,750 --> 00:45:00,150
what so so there is a there is two

00:44:58,349 --> 00:45:01,470
things here there is from from a run

00:45:00,150 --> 00:45:04,800
time p.m. point of view there is only

00:45:01,470 --> 00:45:08,150
one enough but from the power domain

00:45:04,800 --> 00:45:11,250
point of view as we do support multiple

00:45:08,150 --> 00:45:15,630
Idol states of the power main the

00:45:11,250 --> 00:45:17,910
governor is checking these latencies per

00:45:15,630 --> 00:45:20,130
Idol states of the power remain but that

00:45:17,910 --> 00:45:22,500
is it like in the second phase when all

00:45:20,130 --> 00:45:25,770
devices is going powered off can we

00:45:22,500 --> 00:45:28,079
power off the domain as well so that the

00:45:25,770 --> 00:45:31,070
government is taking that into

00:45:28,079 --> 00:45:31,070
consideration as well

00:45:35,090 --> 00:45:39,980
yeah so this is the this is the flow

00:45:37,670 --> 00:45:43,010
what happens if you have a power domain

00:45:39,980 --> 00:45:45,380
a young PD attached I think we have

00:45:43,010 --> 00:45:54,250
walked through this already so yes let

00:45:45,380 --> 00:45:59,360
me take it briefly now it's now having a

00:45:54,250 --> 00:46:02,660
MPD callback assigned and that means

00:45:59,360 --> 00:46:04,100
that this runt ampion core is going to

00:46:02,660 --> 00:46:06,200
look at the highest Orakei and find

00:46:04,100 --> 00:46:08,720
distance find his callback and invoke

00:46:06,200 --> 00:46:11,180
that one and then it's up to young Peter

00:46:08,720 --> 00:46:12,800
to do the right thing and if he needs to

00:46:11,180 --> 00:46:16,070
power on that mainly does that then

00:46:12,800 --> 00:46:18,890
Indian PD is actually looking below in

00:46:16,070 --> 00:46:21,830
the hierarchy and in most cases at least

00:46:18,890 --> 00:46:24,440
for the platform device cases there is

00:46:21,830 --> 00:46:30,680
no other runtime suspend callbacks

00:46:24,440 --> 00:46:32,840
assigned and it's optional of course but

00:46:30,680 --> 00:46:35,870
it's on only on the driver levels or as

00:46:32,840 --> 00:46:37,970
known the bus bus layer for some so that

00:46:35,870 --> 00:46:41,360
means that runtime p.m. will actually

00:46:37,970 --> 00:46:44,060
find a resume device on the on the

00:46:41,360 --> 00:46:45,500
driver part and invoke that which gives

00:46:44,060 --> 00:46:48,230
the driver of the option to do the

00:46:45,500 --> 00:46:53,980
driver specific stuff for example enable

00:46:48,230 --> 00:46:57,290
a clock or yeah we reconfigured the pins

00:46:53,980 --> 00:46:58,550
so that's that's the that's what's

00:46:57,290 --> 00:47:00,170
happening in the background when you

00:46:58,550 --> 00:47:04,370
call this pin one time get there was a

00:47:00,170 --> 00:47:06,350
whole flow of things that's happened do

00:47:04,370 --> 00:47:08,920
you have some use case where we have

00:47:06,350 --> 00:47:20,420
some chain pinnacle back and this

00:47:08,920 --> 00:47:23,210
registered bus so in in the bass case

00:47:20,420 --> 00:47:26,540
there is a bus clock that's being

00:47:23,210 --> 00:47:29,090
managed by the amber bus so that's

00:47:26,540 --> 00:47:32,540
that's one of those cases and in in that

00:47:29,090 --> 00:47:35,480
scenario it means that MPD is going to

00:47:32,540 --> 00:47:37,880
call that runtime resume callback if you

00:47:35,480 --> 00:47:41,390
if we're talking about resuming of the

00:47:37,880 --> 00:47:43,970
bus then it's up to the bus to continue

00:47:41,390 --> 00:47:48,010
calling the driver callback so there

00:47:43,970 --> 00:47:48,010
might be several layers are in between

00:47:50,259 --> 00:47:53,259
okay

00:47:55,570 --> 00:48:01,660
so a couple of words about wake-ups

00:47:58,920 --> 00:48:04,570
there is something that we call remote

00:48:01,660 --> 00:48:08,140
wakes ups and that is wake up's in

00:48:04,570 --> 00:48:13,480
regards to run time p.m. so when you go

00:48:08,140 --> 00:48:16,450
into this run time suspend state you

00:48:13,480 --> 00:48:18,360
might want to be able to wake up for

00:48:16,450 --> 00:48:20,830
some reasons when there is some

00:48:18,360 --> 00:48:26,020
something happy you know on the external

00:48:20,830 --> 00:48:27,670
bus or to say and so typical use case is

00:48:26,020 --> 00:48:30,520
that you might have a UART and you want

00:48:27,670 --> 00:48:33,970
to wake up and there's some hammering on

00:48:30,520 --> 00:48:35,680
the on the console for example and there

00:48:33,970 --> 00:48:38,380
is a whole bunch of different stuff

00:48:35,680 --> 00:48:41,860
that's you you might want to wake up

00:48:38,380 --> 00:48:44,140
there's Wi-Fi drivers using SDIO are

00:48:41,860 --> 00:48:46,810
accused for example suppose the thing

00:48:44,140 --> 00:48:50,770
here is that when it comes to what we

00:48:46,810 --> 00:48:52,840
remote wake up's those are always if you

00:48:50,770 --> 00:48:55,210
support them if your device and driver

00:48:52,840 --> 00:48:57,070
support them you shall always configure

00:48:55,210 --> 00:49:00,220
them when you go into runtime suspense

00:48:57,070 --> 00:49:04,390
tax that's what that's a that's a rule

00:49:00,220 --> 00:49:07,540
that you should remember and if you if

00:49:04,390 --> 00:49:09,460
you need these remote wake up's but your

00:49:07,540 --> 00:49:11,650
device is not capable of supporting them

00:49:09,460 --> 00:49:15,180
the only thing that you can do is to

00:49:11,650 --> 00:49:18,250
keep being month on receipt so it's a

00:49:15,180 --> 00:49:21,280
that's a limitation that we have and

00:49:18,250 --> 00:49:24,970
there's yeah it depends on nice to see

00:49:21,280 --> 00:49:31,750
how they have how they support this wake

00:49:24,970 --> 00:49:39,250
up's and so it's really good helper here

00:49:31,750 --> 00:49:41,530
to to achieve this wakeup thingy that's

00:49:39,250 --> 00:49:43,300
this dev p.m. CET dedicated way Carrick

00:49:41,530 --> 00:49:45,460
you I'm not going into the details

00:49:43,300 --> 00:49:48,610
behind that but the important thing is

00:49:45,460 --> 00:49:52,000
that it actually does most of the things

00:49:48,610 --> 00:49:56,800
that that you in general need to support

00:49:52,000 --> 00:49:59,470
this so if you're yeah you should look

00:49:56,800 --> 00:50:00,970
into that in details if you if you are

00:49:59,470 --> 00:50:03,180
going to implement support for not wake

00:50:00,970 --> 00:50:03,180
up's

00:50:07,250 --> 00:50:14,480
when it comes to system wake-ups it's a

00:50:10,849 --> 00:50:17,510
little bit more more to it than for

00:50:14,480 --> 00:50:19,760
remote backups so system Vegas is like

00:50:17,510 --> 00:50:21,500
typically later you have a button that

00:50:19,760 --> 00:50:24,589
you press you want to wake up the system

00:50:21,500 --> 00:50:27,890
and yeah the same thing is might be

00:50:24,589 --> 00:50:30,260
throughout the whole system is sleeping

00:50:27,890 --> 00:50:32,060
but you want to handle that the console

00:50:30,260 --> 00:50:36,170
we want to wake up the system is that

00:50:32,060 --> 00:50:37,819
that has typical system backups and yeah

00:50:36,170 --> 00:50:40,250
waiting alone I think we know about it's

00:50:37,819 --> 00:50:42,740
complicated thing but it's that's one of

00:50:40,250 --> 00:50:47,329
those things as well what you need to do

00:50:42,740 --> 00:50:49,310
to support that is that you have the

00:50:47,329 --> 00:50:50,950
driver needs to announce that it

00:50:49,310 --> 00:50:54,500
supports this kind of wake up's and

00:50:50,950 --> 00:50:57,140
that's that's the first thing that needs

00:50:54,500 --> 00:51:01,609
to happen as this device in it wake up

00:50:57,140 --> 00:51:05,240
thing and then there's actually there's

00:51:01,609 --> 00:51:07,099
actually a different mindset here saying

00:51:05,240 --> 00:51:09,619
that it's not really the driver that

00:51:07,099 --> 00:51:11,480
decides if I'm going to have this

00:51:09,619 --> 00:51:13,520
enabled when I go to this systems

00:51:11,480 --> 00:51:17,119
website that is to use the space

00:51:13,520 --> 00:51:18,829
decision so the drivers responsibility

00:51:17,119 --> 00:51:21,770
only to announce what it supports and

00:51:18,829 --> 00:51:26,960
use the space tells if I want it enabled

00:51:21,770 --> 00:51:32,780
or not so that's why there is this

00:51:26,960 --> 00:51:34,760
device may wake up interface which you

00:51:32,780 --> 00:51:38,660
typically should call from your system

00:51:34,760 --> 00:51:41,329
suspend callback and that gives you the

00:51:38,660 --> 00:51:49,670
information if if I should have the wake

00:51:41,329 --> 00:51:52,339
up neighbor for my device and then if it

00:51:49,670 --> 00:51:54,829
turns out that I need my wake up to be

00:51:52,339 --> 00:51:58,430
enabled in the nervous API is called

00:51:54,829 --> 00:52:02,450
enable argue wake to do this to inform

00:51:58,430 --> 00:52:05,380
the infrastructure about this and again

00:52:02,450 --> 00:52:05,380
it's actually

00:52:06,540 --> 00:52:10,200
this deaf p.m. set dedicate awake argue

00:52:08,550 --> 00:52:13,790
that helps a lot

00:52:10,200 --> 00:52:16,260
we're dealing with with this our IQ and

00:52:13,790 --> 00:52:19,589
for this particular case it means that

00:52:16,260 --> 00:52:25,310
this RQ there's a separate RQ handler

00:52:19,589 --> 00:52:28,069
and this PM Corps was talking about

00:52:25,310 --> 00:52:30,000
whole all these device callbacks

00:52:28,069 --> 00:52:32,730
actually deals with wake-ups

00:52:30,000 --> 00:52:34,020
automatically behind your backs at the

00:52:32,730 --> 00:52:36,800
previous slide why do you call them

00:52:34,020 --> 00:52:42,000
remote wake-ups because it's about

00:52:36,800 --> 00:52:43,530
runtime p.m. I have no idea why they

00:52:42,000 --> 00:52:45,750
called remote wake up someone have

00:52:43,530 --> 00:52:47,069
decided that is the terminology that we

00:52:45,750 --> 00:52:57,359
should be using so that's why I'm

00:52:47,069 --> 00:53:00,060
sticking to that previous one so let's

00:52:57,359 --> 00:53:05,640
say wake up online would wake up first

00:53:00,060 --> 00:53:07,290
the Phi or the Mac but on only then it

00:53:05,640 --> 00:53:08,640
will wake up the whole system if if

00:53:07,290 --> 00:53:12,930
needed right so you have like

00:53:08,640 --> 00:53:16,619
wake-on-lan is just like used here but

00:53:12,930 --> 00:53:20,520
then it propagates up to the system

00:53:16,619 --> 00:53:23,760
level right so this is about when the

00:53:20,520 --> 00:53:25,800
system is awake so the system is not

00:53:23,760 --> 00:53:28,380
sleeping here it's only device start off

00:53:25,800 --> 00:53:30,210
sleeping or part of the system asleep so

00:53:28,380 --> 00:53:34,440
only that part is going to be woken up

00:53:30,210 --> 00:53:37,490
if they're sleeping in the other part

00:53:34,440 --> 00:53:45,839
hairiest when the whole system asleep

00:53:37,490 --> 00:53:49,349
and the devices so yeah it's there is

00:53:45,839 --> 00:53:50,940
definitely terminology that can be

00:53:49,349 --> 00:53:53,520
approved about this but since this is

00:53:50,940 --> 00:53:55,619
the common terminology I doesn't want to

00:53:53,520 --> 00:54:00,440
change that now it's what it makes sense

00:53:55,619 --> 00:54:00,440
to to simplify this

00:54:02,430 --> 00:54:09,100
okay some words about the MPD in regards

00:54:05,620 --> 00:54:11,470
to this as well there is a there is a

00:54:09,100 --> 00:54:16,080
configuration flag that you can set for

00:54:11,470 --> 00:54:20,110
your your MPD provider which means that

00:54:16,080 --> 00:54:21,700
if there is any of the devices that in

00:54:20,110 --> 00:54:24,700
that is in your MPD

00:54:21,700 --> 00:54:29,050
that's attached to your MPD you were you

00:54:24,700 --> 00:54:32,320
may and that has wake-ups configured

00:54:29,050 --> 00:54:35,500
during system sleep you may need to have

00:54:32,320 --> 00:54:37,840
the power main to stay on because if you

00:54:35,500 --> 00:54:38,580
power off the domain you will lose the

00:54:37,840 --> 00:54:42,910
wake up

00:54:38,580 --> 00:54:46,630
so this active wake up flag health helps

00:54:42,910 --> 00:54:55,750
with that that's the main thing I wanted

00:54:46,630 --> 00:54:57,580
to to explain here and so for the

00:54:55,750 --> 00:55:00,100
scenario where you where you want this

00:54:57,580 --> 00:55:06,670
you you you add this flag and you do

00:55:00,100 --> 00:55:08,440
that app or MPD level and when you start

00:55:06,670 --> 00:55:11,130
looking into the details you will

00:55:08,440 --> 00:55:15,640
realize that there is limitations here

00:55:11,130 --> 00:55:21,100
for example depending on how you route

00:55:15,640 --> 00:55:23,200
your wake up you might you might want to

00:55:21,100 --> 00:55:26,830
have the wake up enabled but you don't

00:55:23,200 --> 00:55:29,950
require the power line to be on for some

00:55:26,830 --> 00:55:34,510
devices and for other if you need it and

00:55:29,950 --> 00:55:38,920
if you have have this kind of more

00:55:34,510 --> 00:55:41,140
complicated ways of yeah depending on

00:55:38,920 --> 00:55:42,910
how the sec looks like there is no way

00:55:41,140 --> 00:55:45,190
to do to deal with that in a fine Wayne

00:55:42,910 --> 00:55:48,700
Manor it's like all or nothing so why do

00:55:45,190 --> 00:55:53,170
we have this flag for all devices or no

00:55:48,700 --> 00:55:56,160
none devices so it's not really it's not

00:55:53,170 --> 00:55:56,160
really fun when enough

00:55:57,260 --> 00:56:14,960
any questions you set it for power

00:56:12,410 --> 00:56:18,320
domain yes not per device she said it

00:56:14,960 --> 00:56:21,500
for power but there may be several

00:56:18,320 --> 00:56:23,089
devices sharing the same power lines so

00:56:21,500 --> 00:56:32,630
it means that it applies for all devices

00:56:23,089 --> 00:56:34,940
that in the same power line right I have

00:56:32,630 --> 00:56:37,940
a couple of more slides but that's going

00:56:34,940 --> 00:56:41,329
to be for for different other training

00:56:37,940 --> 00:56:44,720
sessions I think else so what's the

00:56:41,329 --> 00:56:50,000
current state of how device state is

00:56:44,720 --> 00:56:51,890
managed when you are runtime so if you

00:56:50,000 --> 00:56:54,170
are n time suspended a device and then

00:56:51,890 --> 00:56:55,550
you try a system suspend are you going

00:56:54,170 --> 00:57:05,480
to resume that device and then put it

00:56:55,550 --> 00:57:08,450
back to suspend so just one minute

00:57:05,480 --> 00:57:10,609
briefly about this done so it's very

00:57:08,450 --> 00:57:13,000
common where you have where we are

00:57:10,609 --> 00:57:16,520
actually have the very similar states so

00:57:13,000 --> 00:57:20,859
during runtime suspend is very similar

00:57:16,520 --> 00:57:23,540
to doing system suspend for a device so

00:57:20,859 --> 00:57:25,790
historically there was no way to deal

00:57:23,540 --> 00:57:27,440
with this so what you did what you have

00:57:25,790 --> 00:57:29,569
to do when you do the suspend you have

00:57:27,440 --> 00:57:32,150
to actually had to do runtime resume the

00:57:29,569 --> 00:57:34,250
device and then you have to power off

00:57:32,150 --> 00:57:37,130
the device it's completely crazy

00:57:34,250 --> 00:57:40,490
so wasting time wasting energy and what

00:57:37,130 --> 00:57:43,060
not so we an event it is something that

00:57:40,490 --> 00:57:46,190
we call run time PM centric approach and

00:57:43,060 --> 00:57:48,349
in that path you'll take these kind of

00:57:46,190 --> 00:57:51,349
things into account and there's two

00:57:48,349 --> 00:57:55,250
helper functions that you should be

00:57:51,349 --> 00:57:57,530
aware of and that's called p.m. runtime

00:57:55,250 --> 00:58:01,849
for suspend and here on time force

00:57:57,530 --> 00:58:04,490
received and you can in principle what

00:58:01,849 --> 00:58:06,619
you do is that your system sleep

00:58:04,490 --> 00:58:10,430
callback the system suspend and resume

00:58:06,619 --> 00:58:10,670
callbacks either you just assign them to

00:58:10,430 --> 00:58:13,400
the

00:58:10,670 --> 00:58:15,830
helpers or you call them from your

00:58:13,400 --> 00:58:19,160
callbacks and within those callbacks

00:58:15,830 --> 00:58:21,500
we take into account if my if my device

00:58:19,160 --> 00:58:24,680
is already run time suspended and I'm

00:58:21,500 --> 00:58:26,510
done if it's not suspended yeah use the

00:58:24,680 --> 00:58:29,420
run time callbacks to invoke my

00:58:26,510 --> 00:58:32,000
callbacks to to suspend it and the

00:58:29,420 --> 00:58:36,980
likewise is for for the resume part so

00:58:32,000 --> 00:58:40,520
you are reusing code and you're also

00:58:36,980 --> 00:58:44,690
avoiding to resume devices when not

00:58:40,520 --> 00:58:46,250
needed so the good thing here is that we

00:58:44,690 --> 00:58:48,320
only had one minutes talk about this but

00:58:46,250 --> 00:58:50,110
there's 120 users of this in the column

00:58:48,320 --> 00:58:52,310
so there's plenty of good references

00:58:50,110 --> 00:58:53,660
this is something that you really should

00:58:52,310 --> 00:58:55,310
pay attention to when you do that

00:58:53,660 --> 00:59:03,650
appointment to your drivers it's really

00:58:55,310 --> 00:59:06,260
really important ok this is the same

00:59:03,650 --> 00:59:11,210
it's following the same semantics of

00:59:06,260 --> 00:59:13,550
just existing frameworks now this is

00:59:11,210 --> 00:59:17,690
this is following the the topics or the

00:59:13,550 --> 00:59:22,619
hierarchy thanks everybody

00:59:17,690 --> 00:59:22,619

YouTube URL: https://www.youtube.com/watch?v=LaFartS_dv0


