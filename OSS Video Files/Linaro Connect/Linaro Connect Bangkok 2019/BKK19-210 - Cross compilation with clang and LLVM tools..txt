Title: BKK19-210 - Cross compilation with clang and LLVM tools.
Publication date: 2019-04-11
Playlist: Linaro Connect Bangkok 2019
Description: 
	Abstract
Clang and the LLVM tools promise to be a drop in replacement for gcc and
support cross compilation out of the box. In practice trying to make this work
can be a frustrating experience, with little documentation or guidance
available.

This presentation will distil some of the experience gained by TCWG, covering:
- Clangs model of cross compilation and how it differs from gcc.
- Why there isnt a clang cross-compilation toolchain that I can download.
- Building a toolchain based on as many LLVM tools and libraries as possible.
- How to use clang when cross compiling with cmake.
- How some existing open source projects use clang tools targeting Arm
and AArch64.
- Common problems encountered when using clang as a substitute for gcc.

Peter Smith profile image
Peter Smith / Principal Engineer Arm
Peter is an Assignee to the Linaro Toolchain team (TCWG) working on LLVM based tools, specializing in Linkers. Prior to that he has many years of experience in the Arm Compiler Team.
Captions: 
	00:00:05,450 --> 00:00:10,010
hello everyone I'm here to talk to you

00:00:07,610 --> 00:00:12,590
about cross compilation with clang and

00:00:10,010 --> 00:00:14,480
the lrvm tools so a good have a bit of a

00:00:12,590 --> 00:00:17,540
word of warning to start with this is

00:00:14,480 --> 00:00:19,670
kind of it this isn't a high-level talk

00:00:17,540 --> 00:00:21,980
about what cross compilation is it's

00:00:19,670 --> 00:00:24,800
much more of a here's what I've learned

00:00:21,980 --> 00:00:26,900
from bitter experience over trying to

00:00:24,800 --> 00:00:29,000
get clang to do various things so

00:00:26,900 --> 00:00:31,250
there's probably a lot of detail on the

00:00:29,000 --> 00:00:33,080
slides not all of it I'm going to talk

00:00:31,250 --> 00:00:35,690
about I'll have to skip past a few bits

00:00:33,080 --> 00:00:38,059
if you do want anything me to go into

00:00:35,690 --> 00:00:39,890
any more detail then please just stop me

00:00:38,059 --> 00:00:42,080
I'll try and leave some time for

00:00:39,890 --> 00:00:43,100
questions at the end but if I do I'm

00:00:42,080 --> 00:00:45,710
going a bit too fast

00:00:43,100 --> 00:00:49,400
I apologize at that particular point

00:00:45,710 --> 00:00:51,379
okay so I'll just get cracking there's

00:00:49,400 --> 00:00:53,870
quite a lot of them things to go through

00:00:51,379 --> 00:00:56,330
here so the first bit I'm kind of

00:00:53,870 --> 00:00:57,860
assuming this is Lennar oh you'll be all

00:00:56,330 --> 00:00:59,629
very familiar about what cross

00:00:57,860 --> 00:01:01,430
compilation is and the chances are that

00:00:59,629 --> 00:01:03,190
you'll be using GCC so I'm going to go

00:01:01,430 --> 00:01:07,070
through the refresher very very quickly

00:01:03,190 --> 00:01:09,380
a little bit about what makes up a clang

00:01:07,070 --> 00:01:11,539
or LLVM tool chain because it's very

00:01:09,380 --> 00:01:13,640
different or slightly different to what

00:01:11,539 --> 00:01:15,560
you would expect to know GCC toolchain a

00:01:13,640 --> 00:01:20,180
little bit more about how you actually

00:01:15,560 --> 00:01:22,969
use or drive clangers across compiler my

00:01:20,180 --> 00:01:24,619
I guess might but the thing the build

00:01:22,969 --> 00:01:27,320
system I've used the most relation

00:01:24,619 --> 00:01:29,090
compilation is C make I found using

00:01:27,320 --> 00:01:31,729
clang and cross compilation they're a

00:01:29,090 --> 00:01:33,200
little bit challenging at times so I'm

00:01:31,729 --> 00:01:36,979
just going to give some hints and tips

00:01:33,200 --> 00:01:39,380
about how I got got that to work and

00:01:36,979 --> 00:01:40,999
some differences between GCC and clang

00:01:39,380 --> 00:01:43,670
but if you are porting some of your code

00:01:40,999 --> 00:01:45,170
some of the things to watch out for and

00:01:43,670 --> 00:01:46,969
then a final bit of sort of just the

00:01:45,170 --> 00:01:49,759
idea what would it actually take to make

00:01:46,969 --> 00:01:53,509
a LLVM tool chain in the same way that

00:01:49,759 --> 00:01:56,270
we have the the GCC toolchain for arm at

00:01:53,509 --> 00:01:58,219
the moment okay so very very basic

00:01:56,270 --> 00:01:59,960
definitions if I ever say the word host

00:01:58,219 --> 00:02:01,850
that's the sort of platform that you're

00:01:59,960 --> 00:02:03,740
compiling on so something that would

00:02:01,850 --> 00:02:05,509
typically be an x86 machine although

00:02:03,740 --> 00:02:07,909
nowadays with arm servers it might even

00:02:05,509 --> 00:02:08,360
be an out 64 machine arm machine these

00:02:07,909 --> 00:02:10,580
days

00:02:08,360 --> 00:02:13,370
target that's what you're taught

00:02:10,580 --> 00:02:15,200
compiling for so native it means to host

00:02:13,370 --> 00:02:16,970
it's the same as the target cross means

00:02:15,200 --> 00:02:19,220
that they are different okay

00:02:16,970 --> 00:02:21,380
very quickly for the motivation and

00:02:19,220 --> 00:02:23,600
obviously there's performance involved

00:02:21,380 --> 00:02:25,820
full surfers big large surface compiling

00:02:23,600 --> 00:02:27,950
down to a smaller target like arm and on

00:02:25,820 --> 00:02:31,010
a microcontroller you can't yet fit a C+

00:02:27,950 --> 00:02:34,760
C++ compiler on a BBC micro bit and

00:02:31,010 --> 00:02:38,120
though I'm sure somebody has tried okay

00:02:34,760 --> 00:02:39,500
so just a very very quick and slide

00:02:38,120 --> 00:02:40,790
about some of the challenges you might

00:02:39,500 --> 00:02:42,860
get when cross compilation that you

00:02:40,790 --> 00:02:44,350
might not think about so when you're

00:02:42,860 --> 00:02:47,450
coughs compiling for an embedded system

00:02:44,350 --> 00:02:49,490
typically you get everything compiled

00:02:47,450 --> 00:02:51,440
statically so all of your dependencies

00:02:49,490 --> 00:02:53,420
come with you if your cross compiling

00:02:51,440 --> 00:02:55,130
for Linux you have to make sure that if

00:02:53,420 --> 00:02:57,410
you're compiling against shared objects

00:02:55,130 --> 00:03:01,460
you've got to have the sort of them the

00:02:57,410 --> 00:03:03,440
same shared objects paths on your host

00:03:01,460 --> 00:03:05,960
side as you have on your cross side

00:03:03,440 --> 00:03:07,730
otherwise you're when you try and run

00:03:05,960 --> 00:03:08,960
your application on your target it won't

00:03:07,730 --> 00:03:12,440
be able to find your shared libraries

00:03:08,960 --> 00:03:14,990
okay right so away from this sort of

00:03:12,440 --> 00:03:15,590
very quick refresher and onto onto clang

00:03:14,990 --> 00:03:18,140
an LVN

00:03:15,590 --> 00:03:19,640
so this is just a little bit about what

00:03:18,140 --> 00:03:24,440
what you actually get in a and

00:03:19,640 --> 00:03:27,770
installation of clang okay so clang in I

00:03:24,440 --> 00:03:29,810
guess in contrast to GCC is a native

00:03:27,770 --> 00:03:32,330
cross compiler when you download the

00:03:29,810 --> 00:03:34,250
installation you get all of the targets

00:03:32,330 --> 00:03:36,020
there so you can cross compile for armed

00:03:34,250 --> 00:03:38,420
you can cross compile for MIPS that sort

00:03:36,020 --> 00:03:39,830
of thing or with a very quick change of

00:03:38,420 --> 00:03:41,600
flags now that's quite powerful

00:03:39,830 --> 00:03:42,830
certainly if you're a compiler developer

00:03:41,600 --> 00:03:45,830
wanting to see what things do

00:03:42,830 --> 00:03:47,330
differently on them on different

00:03:45,830 --> 00:03:49,550
architectures but it's also quite useful

00:03:47,330 --> 00:03:51,320
if you're wanting to come across compile

00:03:49,550 --> 00:03:54,560
to multiple architectures from the same

00:03:51,320 --> 00:03:56,900
same tool chain so clang does this by

00:03:54,560 --> 00:03:58,760
emulating the drivers of the sort of

00:03:56,900 --> 00:04:00,709
compilers it emulates so as well as

00:03:58,760 --> 00:04:04,610
being able to emulate the GCC driver it

00:04:00,709 --> 00:04:06,019
can also emulate the and windows MSV C

00:04:04,610 --> 00:04:08,390
compiler if you happen to be using it on

00:04:06,019 --> 00:04:10,160
that sort of environment now clang you

00:04:08,390 --> 00:04:11,720
can control this all via the target

00:04:10,160 --> 00:04:14,060
triple so I'll go into a bit more detail

00:04:11,720 --> 00:04:18,260
about what the target triple is and how

00:04:14,060 --> 00:04:21,769
you actually use it now I say clang tall

00:04:18,260 --> 00:04:24,280
chain it's any tool chain that you

00:04:21,769 --> 00:04:26,960
download is incomplete you need to

00:04:24,280 --> 00:04:29,120
supplement it by either libraries or

00:04:26,960 --> 00:04:30,250
includes that are in your own operating

00:04:29,120 --> 00:04:33,010
system or

00:04:30,250 --> 00:04:34,930
another toolchain okay this is a very

00:04:33,010 --> 00:04:38,170
that's been cropped slightly but erm

00:04:34,930 --> 00:04:39,280
it's probably not too important so this

00:04:38,170 --> 00:04:41,170
is the sort of the equivalents do you

00:04:39,280 --> 00:04:43,180
would have from a client all chained and

00:04:41,170 --> 00:04:45,430
agony toolchain so I've put the bits in

00:04:43,180 --> 00:04:47,530
white where there are pretty much direct

00:04:45,430 --> 00:04:52,330
equivalents I've put the bits in orange

00:04:47,530 --> 00:04:54,430
where those tools exist LLVM ir a la via

00:04:52,330 --> 00:04:55,720
mob dump but they're generally at the

00:04:54,430 --> 00:04:57,940
moment at least at the moment there are

00:04:55,720 --> 00:04:59,950
sort of developer tool status they're

00:04:57,940 --> 00:05:02,920
prompt they're sort of aimed mostly at

00:04:59,950 --> 00:05:05,530
testing LLVM they're not really aimed at

00:05:02,920 --> 00:05:07,750
friendly user interactions with with

00:05:05,530 --> 00:05:09,910
people who aren't developers but i think

00:05:07,750 --> 00:05:12,550
that's changing and hopefully within a

00:05:09,910 --> 00:05:15,040
year or so of work from the community

00:05:12,550 --> 00:05:16,870
then they'll be able to remove that

00:05:15,040 --> 00:05:18,340
orange bit there and the red bit at the

00:05:16,870 --> 00:05:20,500
bottom is the c library at the moment

00:05:18,340 --> 00:05:22,480
and there are no plans for the clang

00:05:20,500 --> 00:05:23,919
tool chain to have AC library it's

00:05:22,480 --> 00:05:25,900
pretty much agnostic on there and you

00:05:23,919 --> 00:05:28,990
have to fill that out with another bit

00:05:25,900 --> 00:05:30,640
of the tool chain okay so there's a

00:05:28,990 --> 00:05:32,500
little bit of detail I'm not going to go

00:05:30,640 --> 00:05:33,910
into this particular slide too much this

00:05:32,500 --> 00:05:36,790
is if you can refer back to it if you

00:05:33,910 --> 00:05:39,040
want to but you can select between

00:05:36,790 --> 00:05:42,820
various bits of these so when there's

00:05:39,040 --> 00:05:44,530
and a GCC equivalent and say you're

00:05:42,820 --> 00:05:46,540
compiling on Linux it'll assume well

00:05:44,530 --> 00:05:49,300
that's already there so why do I need to

00:05:46,540 --> 00:05:50,919
use the clang equivalent and so by

00:05:49,300 --> 00:05:52,270
default if you're using clang on a Linux

00:05:50,919 --> 00:05:55,210
system or is something that's been built

00:05:52,270 --> 00:05:58,840
for that it will use Lib GCC and Lib

00:05:55,210 --> 00:06:00,580
stood c++ rather than lrvm lib C++ that

00:05:58,840 --> 00:06:02,410
will obviously change if you're

00:06:00,580 --> 00:06:06,970
compiling up for an apple platform where

00:06:02,410 --> 00:06:09,190
those defaults will be reversed right so

00:06:06,970 --> 00:06:11,710
now onto actually using clang as a cross

00:06:09,190 --> 00:06:13,780
compiler it's the most important thing

00:06:11,710 --> 00:06:16,630
that you'll need to work out is the Yun

00:06:13,780 --> 00:06:22,690
target triple so whenever you see things

00:06:16,630 --> 00:06:24,729
like um - none - a ABI - Linux - EA bah

00:06:22,690 --> 00:06:27,100
F let's all broke down into this

00:06:24,729 --> 00:06:30,100
particular format here of an arch sbatch

00:06:27,100 --> 00:06:31,900
vendor OS environment now not all of

00:06:30,100 --> 00:06:34,419
these have to be set they get the values

00:06:31,900 --> 00:06:37,479
unknown if you leave them out and so for

00:06:34,419 --> 00:06:40,490
example vendor is very often left out if

00:06:37,479 --> 00:06:41,510
you're compiling for say Linux

00:06:40,490 --> 00:06:43,670
this is kind of where a lot of

00:06:41,510 --> 00:06:46,880
proprietary people who them I guess

00:06:43,670 --> 00:06:49,880
they've customized Klang will use vendor

00:06:46,880 --> 00:06:56,870
to then some will then say are these are

00:06:49,880 --> 00:06:58,370
my own custom things so the question was

00:06:56,870 --> 00:07:00,680
how does these triples relate to the

00:06:58,370 --> 00:07:05,930
glue triplets they're very similar so

00:07:00,680 --> 00:07:07,640
when I guess you would get I guess you

00:07:05,930 --> 00:07:10,220
could say this is kind of a superset of

00:07:07,640 --> 00:07:11,810
the triples that you would get on that

00:07:10,220 --> 00:07:14,240
although for my understanding from the

00:07:11,810 --> 00:07:18,640
way the canoe world works is that the

00:07:14,240 --> 00:07:21,230
triple is much more of a string that is

00:07:18,640 --> 00:07:25,390
sort of baked in when you build the

00:07:21,230 --> 00:07:29,300
compiler and so for example I think some

00:07:25,390 --> 00:07:31,100
Linda some kanuto chains use EAB IHF to

00:07:29,300 --> 00:07:32,960
mean the hard float versions some of

00:07:31,100 --> 00:07:35,150
them don't use that HF on the end and

00:07:32,960 --> 00:07:36,860
you have to use em float api plying

00:07:35,150 --> 00:07:39,140
pretty much sticks to well

00:07:36,860 --> 00:07:42,020
clang can't perfectly emulate that

00:07:39,140 --> 00:07:44,300
distinction it goes with the EAB nhf one

00:07:42,020 --> 00:07:46,190
at that point so I think the answer is

00:07:44,300 --> 00:07:47,090
is they're related but they're not quite

00:07:46,190 --> 00:07:49,310
the same

00:07:47,090 --> 00:07:52,400
so one problem that I've keep facing

00:07:49,310 --> 00:07:55,220
with the cross compiling the kernel is

00:07:52,400 --> 00:07:57,410
when the strings don't match because

00:07:55,220 --> 00:08:00,560
then playing does funny things yes so

00:07:57,410 --> 00:08:02,810
you have to have the the triple that you

00:08:00,560 --> 00:08:04,880
pass declaring has to really be the one

00:08:02,810 --> 00:08:06,590
that you have a new tool chain for if

00:08:04,880 --> 00:08:08,300
you want to rely on the multi yes

00:08:06,590 --> 00:08:10,250
definitely that's that's a very good

00:08:08,300 --> 00:08:13,550
piece of advice if you if you have got a

00:08:10,250 --> 00:08:14,120
names triple in the thing use that as

00:08:13,550 --> 00:08:16,190
much you can

00:08:14,120 --> 00:08:17,540
and so the one of the things I'm going

00:08:16,190 --> 00:08:20,630
to go go in a little bit later is that

00:08:17,540 --> 00:08:22,700
some of the options so this target

00:08:20,630 --> 00:08:24,980
triple is it's kind of the way clangs

00:08:22,700 --> 00:08:27,380
sort of set up it's got LLVM at the

00:08:24,980 --> 00:08:29,150
bottom and then our VM uses that target

00:08:27,380 --> 00:08:31,610
triple to do particular code generation

00:08:29,150 --> 00:08:34,640
but you don't lrvm is just an API you

00:08:31,610 --> 00:08:36,520
don't interact with it directly whereas

00:08:34,640 --> 00:08:39,320
clang is kind of the driver level so

00:08:36,520 --> 00:08:42,590
things like when you say - M float ABI

00:08:39,320 --> 00:08:44,900
equals or - M Archie calls these get

00:08:42,590 --> 00:08:47,210
sort of them consolidated and written

00:08:44,900 --> 00:08:49,220
written merged back into the triple so

00:08:47,210 --> 00:08:50,870
the triple LOV mcs may not be the one

00:08:49,220 --> 00:08:53,930
that you put in at the top with clang

00:08:50,870 --> 00:08:54,170
but yeah but a good advice is if you've

00:08:53,930 --> 00:08:56,300
got

00:08:54,170 --> 00:08:59,089
GCC with a particular sort of triple use

00:08:56,300 --> 00:09:02,450
that same one and then usually clashes

00:08:59,089 --> 00:09:05,269
if don't use it the you may end up with

00:09:02,450 --> 00:09:09,320
the fall back being the native binary so

00:09:05,269 --> 00:09:12,230
it ends up calling the x86 assembler to

00:09:09,320 --> 00:09:15,680
compile the assemble in an arm file

00:09:12,230 --> 00:09:17,209
because some some characters in the

00:09:15,680 --> 00:09:19,880
triple didn't match up with anything

00:09:17,209 --> 00:09:21,500
that it was looking for yeah it said the

00:09:19,880 --> 00:09:23,000
- the option is definitely your friend

00:09:21,500 --> 00:09:24,529
Hicks you can actually out what

00:09:23,000 --> 00:09:27,410
it's actually done not what you wanted

00:09:24,529 --> 00:09:29,240
it to do at that particular point right

00:09:27,410 --> 00:09:31,370
okay so an interesting bit for their

00:09:29,240 --> 00:09:34,399
face the sub arch where it's where you

00:09:31,370 --> 00:09:37,430
can say because if you say arm - none or

00:09:34,399 --> 00:09:39,860
anything arm - it'll assume the default

00:09:37,430 --> 00:09:44,000
for that particular area so if you say

00:09:39,860 --> 00:09:46,399
arm - new Linux - and the API you'll get

00:09:44,000 --> 00:09:51,829
arm 70 TM is your default CPU which a

00:09:46,399 --> 00:09:54,019
chances are you don't want so it's just

00:09:51,829 --> 00:09:55,459
an example of an arm the arm target

00:09:54,019 --> 00:09:58,670
triple how you particularly use it and

00:09:55,459 --> 00:10:01,490
so if you say v7r mv7 a then that's

00:09:58,670 --> 00:10:05,060
going to sort of select be the

00:10:01,490 --> 00:10:07,490
equivalent of - target equals arm - with

00:10:05,060 --> 00:10:09,829
- m arch equals an t7 a that type of

00:10:07,490 --> 00:10:14,630
thing but the mr.chen M CPU will take

00:10:09,829 --> 00:10:16,339
precedence their OS Linux Android nan so

00:10:14,630 --> 00:10:17,810
this is useful in selecting the driver

00:10:16,339 --> 00:10:19,910
that clang will use to interpret your

00:10:17,810 --> 00:10:21,380
command-line options and typically for

00:10:19,910 --> 00:10:24,769
this audience you'd probably be using

00:10:21,380 --> 00:10:26,449
Linux Android or non there are other

00:10:24,769 --> 00:10:29,180
what other ones success is things like

00:10:26,449 --> 00:10:31,850
future BSD that type of thing the

00:10:29,180 --> 00:10:34,610
environment is interesting in particular

00:10:31,850 --> 00:10:39,560
the difference between canoe ABI and go

00:10:34,610 --> 00:10:41,390
new a bi H F so it in clang and HF means

00:10:39,560 --> 00:10:44,360
hard float so that will sort of set up

00:10:41,390 --> 00:10:48,079
all the defaults for that so that map's

00:10:44,360 --> 00:10:50,750
quite well - I think the the way arms

00:10:48,079 --> 00:10:53,029
embed and Linares embed and Linux

00:10:50,750 --> 00:10:57,319
distributions of GCC have set themselves

00:10:53,029 --> 00:10:59,269
up okay there's just some examples that

00:10:57,319 --> 00:11:00,060
have went through that were way too much

00:10:59,269 --> 00:11:02,880
about that

00:11:00,060 --> 00:11:04,770
okay so what does that actually triple

00:11:02,880 --> 00:11:07,440
do in clang well one of the first things

00:11:04,770 --> 00:11:09,720
it does is it's it instantiates a tool

00:11:07,440 --> 00:11:13,110
chain class and that tool chain class

00:11:09,720 --> 00:11:15,480
basically governs what includes get set

00:11:13,110 --> 00:11:18,270
out what libraries get out and it's kind

00:11:15,480 --> 00:11:21,210
of the tour chain classes kind of it's a

00:11:18,270 --> 00:11:22,800
bunch of messy heuristics that plan uses

00:11:21,210 --> 00:11:24,690
to try and emulate the driver of

00:11:22,800 --> 00:11:28,200
whatever it's trying to do now these are

00:11:24,690 --> 00:11:29,730
hard-coded so there's not an awful lot

00:11:28,200 --> 00:11:31,950
of customization you can do in certain

00:11:29,730 --> 00:11:33,480
bids so generally if you're using

00:11:31,950 --> 00:11:36,450
something that's quite common

00:11:33,480 --> 00:11:38,190
say for example a Debian multi arch sort

00:11:36,450 --> 00:11:39,570
of layout of the compiler this works

00:11:38,190 --> 00:11:41,160
quite well because that's what it's been

00:11:39,570 --> 00:11:42,750
tested against but if you've got

00:11:41,160 --> 00:11:44,160
something that's non-standard or

00:11:42,750 --> 00:11:46,380
something that you've kind of made up

00:11:44,160 --> 00:11:47,970
you generally have to fight it a bit

00:11:46,380 --> 00:11:49,950
harder to actually get get the things

00:11:47,970 --> 00:11:51,060
working I've also find I'm telling you

00:11:49,950 --> 00:11:52,320
this now that there's a tall chain

00:11:51,060 --> 00:11:54,810
classes that I found the best way of

00:11:52,320 --> 00:11:56,670
working out what the compiler is doing

00:11:54,810 --> 00:11:58,350
is to go look in that tool chain class

00:11:56,670 --> 00:12:00,960
to try and work out what it's actually

00:11:58,350 --> 00:12:02,220
done now unfortunately because there's

00:12:00,960 --> 00:12:04,050
so many different options and this is

00:12:02,220 --> 00:12:06,840
all in code the number of possibilities

00:12:04,050 --> 00:12:08,220
mean this is almost undocumented all one

00:12:06,840 --> 00:12:09,720
of my girls from there so I thought oh

00:12:08,220 --> 00:12:11,520
I'll just write down the rules and put

00:12:09,720 --> 00:12:14,370
them on the slide and and I gave up on

00:12:11,520 --> 00:12:15,900
that idea very quickly and so I'd say

00:12:14,370 --> 00:12:18,510
that one of the best bits I think if

00:12:15,900 --> 00:12:21,330
things go wrong use of - V output - dump

00:12:18,510 --> 00:12:23,010
what clangs doing if that doesn't work

00:12:21,330 --> 00:12:26,850
go look in the tool chain class to work

00:12:23,010 --> 00:12:28,200
it out okay so here's just a so the idea

00:12:26,850 --> 00:12:30,960
of some of the things that clang will do

00:12:28,200 --> 00:12:32,490
when it's invoked you have clang itself

00:12:30,960 --> 00:12:38,190
which is the executive element you run

00:12:32,490 --> 00:12:40,020
and it will reinvent as either cc 130 c1

00:12:38,190 --> 00:12:42,540
AAS for the integrated assembler and

00:12:40,020 --> 00:12:45,540
obviously called the linker so I've got

00:12:42,540 --> 00:12:49,650
there on that slide some examples of how

00:12:45,540 --> 00:12:52,440
the options a differ between clang and

00:12:49,650 --> 00:12:54,570
the driver options so generally speaking

00:12:52,440 --> 00:12:56,130
you don't call those things yourself

00:12:54,570 --> 00:12:58,200
directly that's just the compilers

00:12:56,130 --> 00:13:00,780
internal language that it's going on

00:12:58,200 --> 00:13:03,870
there interestingly you might be able to

00:13:00,780 --> 00:13:08,520
see on the left side one with CC 1 the

00:13:03,870 --> 00:13:10,020
target features so I when I first saw

00:13:08,520 --> 00:13:11,700
those features I thought that was the

00:13:10,020 --> 00:13:14,339
entire set of features that clang was

00:13:11,700 --> 00:13:17,439
communicating but unfortunately

00:13:14,339 --> 00:13:19,660
LLVM can add defaults back in so it's

00:13:17,439 --> 00:13:21,399
difficult to know the exact set of what

00:13:19,660 --> 00:13:23,709
all the target features are in there

00:13:21,399 --> 00:13:25,480
this is kind of one of the difficulties

00:13:23,709 --> 00:13:28,779
that Klein has in its all its code

00:13:25,480 --> 00:13:30,489
generations done by LLVM and clang

00:13:28,779 --> 00:13:33,160
itself is built on top of that and it's

00:13:30,489 --> 00:13:36,100
kind of how the targets are described as

00:13:33,160 --> 00:13:37,569
kind of shared between the two it's sort

00:13:36,100 --> 00:13:40,720
of like clang needs no bits about the

00:13:37,569 --> 00:13:42,639
target so does LLVM but you know LLVM

00:13:40,720 --> 00:13:44,649
can't go back up to clang because cut

00:13:42,639 --> 00:13:48,129
lrvm can't assume the presence of clang

00:13:44,649 --> 00:13:51,129
so there's some duplication there okay

00:13:48,129 --> 00:13:53,170
so present this diagram here just a sort

00:13:51,129 --> 00:13:54,939
of them show some of the things that you

00:13:53,170 --> 00:13:56,980
might come across when you're trying to

00:13:54,939 --> 00:13:58,959
construct a tool chain so this is kind

00:13:56,980 --> 00:14:00,850
of how the clang installation as you

00:13:58,959 --> 00:14:03,759
would download it or build and install

00:14:00,850 --> 00:14:06,279
it is laid out so bin obviously contains

00:14:03,759 --> 00:14:08,619
clang all of the sort of them host tools

00:14:06,279 --> 00:14:11,589
and they tend to be native sorry they

00:14:08,619 --> 00:14:13,439
they are cross compilers by default you

00:14:11,589 --> 00:14:17,410
don't only have to worry about that and

00:14:13,439 --> 00:14:20,490
the include directories you've got c++

00:14:17,410 --> 00:14:23,230
and that will be Lib C++ that's the LLVM

00:14:20,490 --> 00:14:26,649
C++ library and then you have these

00:14:23,230 --> 00:14:28,240
clang clang - C LLVM lrvm - see that's

00:14:26,649 --> 00:14:30,699
if you're building a tool yourself

00:14:28,240 --> 00:14:32,949
that's based on and the LLVM libraries

00:14:30,699 --> 00:14:34,509
as a user just using climb as a compiler

00:14:32,949 --> 00:14:36,939
you don't need to worry about those

00:14:34,509 --> 00:14:38,799
those obviously will be host libraries

00:14:36,939 --> 00:14:41,499
so you can't use them for cross

00:14:38,799 --> 00:14:43,509
compilation and now the interesting one

00:14:41,499 --> 00:14:47,230
here as soon as we get to binaries we've

00:14:43,509 --> 00:14:49,269
got Lib and there we got lip C++ Lib C

00:14:47,230 --> 00:14:52,360
plus API I made a mistake that should be

00:14:49,269 --> 00:14:54,129
live on not live comp the glib comp is

00:14:52,360 --> 00:14:57,129
the GCC equivalent now those are not

00:14:54,129 --> 00:15:01,869
named spaced for any particular target

00:14:57,129 --> 00:15:05,379
so you can only have one I guess and one

00:15:01,869 --> 00:15:08,619
host one type either x86 arm or out 64

00:15:05,379 --> 00:15:11,290
in terms of the default installation at

00:15:08,619 --> 00:15:12,549
that particular point so typically what

00:15:11,290 --> 00:15:14,860
happens when you cross compiling is you

00:15:12,549 --> 00:15:18,519
tell clang to go look somewhere else for

00:15:14,860 --> 00:15:19,959
your cross compiled and libraries so in

00:15:18,519 --> 00:15:21,730
practice that's not too much of a

00:15:19,959 --> 00:15:24,309
problem but if you were thinking oh I

00:15:21,730 --> 00:15:26,529
can build a installation just by copying

00:15:24,309 --> 00:15:27,910
lots of bits into this directory and

00:15:26,529 --> 00:15:29,890
work for say arm

00:15:27,910 --> 00:15:30,970
out 64 at the same time you probably

00:15:29,890 --> 00:15:34,540
that's probably not going to work too

00:15:30,970 --> 00:15:36,700
well the Klan directory and there is

00:15:34,540 --> 00:15:39,070
quite useful that's kind of what what's

00:15:36,700 --> 00:15:40,570
called the resource directory and that's

00:15:39,070 --> 00:15:42,100
where you have the includes and

00:15:40,570 --> 00:15:44,230
libraries that are tied to the compiler

00:15:42,100 --> 00:15:46,240
itself so that's where things like

00:15:44,230 --> 00:15:49,540
internal things where the compiler is it

00:15:46,240 --> 00:15:52,630
sort of has got a ban well will those

00:15:49,540 --> 00:15:54,310
sort of an includes and libraries might

00:15:52,630 --> 00:15:56,140
take advantage of compiler specific

00:15:54,310 --> 00:15:58,240
things so you shouldn't expect to be

00:15:56,140 --> 00:16:00,970
able to compile them with other compiler

00:15:58,240 --> 00:16:03,490
so those things are in that particular

00:16:00,970 --> 00:16:06,520
directory and luckily for things like

00:16:03,490 --> 00:16:08,410
compiler RT and compiler RT is kind of

00:16:06,520 --> 00:16:10,840
like the Lib GCC equivalent that is

00:16:08,410 --> 00:16:13,210
names based for targets so on my

00:16:10,840 --> 00:16:17,590
installation I just download the NEX 86

00:16:13,210 --> 00:16:21,100
you'll see built-ins - x86 64 and you'll

00:16:17,590 --> 00:16:22,930
also notice Lib Linux so that's the sort

00:16:21,100 --> 00:16:25,270
of directory for the Linux sort of

00:16:22,930 --> 00:16:27,220
driver so there is a bear method if I

00:16:25,270 --> 00:16:30,400
didn't made a bare-metal talk it it

00:16:27,220 --> 00:16:34,270
would look in Lib bare-metal Lib clang

00:16:30,400 --> 00:16:38,440
RT built-ins - arm v6 m dot a type of

00:16:34,270 --> 00:16:42,130
thing ok ok so if you're actually gonna

00:16:38,440 --> 00:16:43,990
use one of these cross compilation and

00:16:42,130 --> 00:16:45,640
so well basically when I say a clang

00:16:43,990 --> 00:16:48,040
installation I mean you go to the

00:16:45,640 --> 00:16:49,510
website download style of young dog

00:16:48,040 --> 00:16:51,130
whatever I don't know whether that's the

00:16:49,510 --> 00:16:54,430
right URL but you can google for the

00:16:51,130 --> 00:16:56,170
right one and download the toolkit what

00:16:54,430 --> 00:16:59,590
do you actually get what can I use with

00:16:56,170 --> 00:17:01,690
that so all those tools are what you

00:16:59,590 --> 00:17:03,700
need the libraries probably will be for

00:17:01,690 --> 00:17:05,710
the hosts so you've got to be careful

00:17:03,700 --> 00:17:08,380
with that compiler RT will also be for

00:17:05,710 --> 00:17:10,240
the hosts so basically what happens is

00:17:08,380 --> 00:17:11,890
you have to basically point clangs

00:17:10,240 --> 00:17:14,080
somewhere else to get the libraries and

00:17:11,890 --> 00:17:17,080
includes that you need ok

00:17:14,080 --> 00:17:19,810
so typically what we'd be doing here in

00:17:17,080 --> 00:17:21,970
blows you'll be using a GCC cross

00:17:19,810 --> 00:17:24,880
compiler to supply the missing bits of

00:17:21,970 --> 00:17:26,980
the tool chain and this is where it

00:17:24,880 --> 00:17:31,240
finds this GCC is governed by two

00:17:26,980 --> 00:17:33,120
separate options if you're lucky you can

00:17:31,240 --> 00:17:35,430
get away with just this route

00:17:33,120 --> 00:17:38,350
unfortunately for the arm and Lennar o

00:17:35,430 --> 00:17:39,580
tools you need both GCC toolchain and

00:17:38,350 --> 00:17:41,590
sis route

00:17:39,580 --> 00:17:44,289
so what clang does

00:17:41,590 --> 00:17:48,129
as it looks for a particular directory

00:17:44,289 --> 00:17:50,529
structure in from the top of the paths

00:17:48,129 --> 00:17:52,690
that you give with GCC toolchain or sis

00:17:50,529 --> 00:17:54,309
route I mention that because it's

00:17:52,690 --> 00:17:57,309
sometimes quite frustrating when you say

00:17:54,309 --> 00:17:59,350
- - GCC toolchain equals this thing why

00:17:57,309 --> 00:18:00,970
is it not finding my includes or why is

00:17:59,350 --> 00:18:01,299
it not finding my libraries that sort of

00:18:00,970 --> 00:18:06,279
thing

00:18:01,299 --> 00:18:08,379
but it's looking for lib GCC GCC triple

00:18:06,279 --> 00:18:12,450
which would normally be armed - Linux -

00:18:08,379 --> 00:18:15,490
EAB IHF or whatever the GCC was compiled

00:18:12,450 --> 00:18:17,710
and then the major minor patch and it

00:18:15,490 --> 00:18:19,990
will try and find all of the various GCC

00:18:17,710 --> 00:18:21,429
installations in this in the in these

00:18:19,990 --> 00:18:23,409
various search paths and it will pick

00:18:21,429 --> 00:18:27,519
the highest one and assume that that's

00:18:23,409 --> 00:18:29,350
the one that you wanted it to use and so

00:18:27,519 --> 00:18:31,240
typically what I find for this one is

00:18:29,350 --> 00:18:35,110
that if you if you've got a Debian multi

00:18:31,240 --> 00:18:38,200
out setup with and you don't give it a

00:18:35,110 --> 00:18:41,350
sister out things generally just work

00:18:38,200 --> 00:18:44,230
because it will look in the GCC Cross

00:18:41,350 --> 00:18:45,970
GCC triple and that's the way the multi

00:18:44,230 --> 00:18:47,799
arch has got it all laid out and it will

00:18:45,970 --> 00:18:49,809
just work for you although there is a

00:18:47,799 --> 00:18:51,759
bit of a caveat about that later that

00:18:49,809 --> 00:18:54,249
I'll go onto there if you're using the

00:18:51,759 --> 00:18:58,149
arm and the narrow jewel turtle chains

00:18:54,249 --> 00:19:00,039
you need to set the GCC toolchain and

00:18:58,149 --> 00:19:01,600
the sister out so the reason you have to

00:19:00,039 --> 00:19:03,429
do both of them is that when you use you

00:19:01,600 --> 00:19:06,100
go to the sister it starts looking for

00:19:03,429 --> 00:19:08,559
celeste it starts looking for something

00:19:06,100 --> 00:19:12,999
relative to the USR directory and the

00:19:08,559 --> 00:19:15,039
way the arm and Lennar owain GCC cross

00:19:12,999 --> 00:19:19,299
compilers are laid out they don't have

00:19:15,039 --> 00:19:20,889
the the major minor triple thing in the

00:19:19,299 --> 00:19:22,330
location that cleansing clang is

00:19:20,889 --> 00:19:25,840
expecting it to be so you have to say

00:19:22,330 --> 00:19:28,450
GCC toolchain as well so here's an

00:19:25,840 --> 00:19:30,580
example on multi arch so this is just on

00:19:28,450 --> 00:19:32,740
my local machine just to explain how

00:19:30,580 --> 00:19:35,169
this thing works and what the - b option

00:19:32,740 --> 00:19:39,610
uses so all of the output there is from

00:19:35,169 --> 00:19:42,700
the - V and I've put him read there some

00:19:39,610 --> 00:19:45,009
a bit of a caveat because because when

00:19:42,700 --> 00:19:46,629
you and it will climb will always look

00:19:45,009 --> 00:19:48,490
for something include directories

00:19:46,629 --> 00:19:51,970
relative to the sister out so if your

00:19:48,490 --> 00:19:53,679
sister root is root then it will start

00:19:51,970 --> 00:19:55,280
looking at some directories that might

00:19:53,679 --> 00:19:57,140
include some host

00:19:55,280 --> 00:19:59,000
pedophiles so if you've got nothing in

00:19:57,140 --> 00:20:01,370
in those to read don't directory

00:19:59,000 --> 00:20:03,170
locations that's probably fine

00:20:01,370 --> 00:20:07,010
but if you've got some particular

00:20:03,170 --> 00:20:10,070
library that says if x86 then do this or

00:20:07,010 --> 00:20:12,710
if 32 or 64-bit do this you can run into

00:20:10,070 --> 00:20:14,210
some problems that way and the only way

00:20:12,710 --> 00:20:16,130
I know to get rid of those is to tell

00:20:14,210 --> 00:20:18,500
clang not to include any default

00:20:16,130 --> 00:20:20,320
includes at all anyway that just gives

00:20:18,500 --> 00:20:22,760
you an idea of where it's found the

00:20:20,320 --> 00:20:26,020
sounds of things there so a slightly

00:20:22,760 --> 00:20:28,850
more complicated one for going and

00:20:26,020 --> 00:20:30,860
satisfying the tour chain itself and I

00:20:28,850 --> 00:20:31,970
said well bother reading out and all of

00:20:30,860 --> 00:20:33,920
the things there but one things you'll

00:20:31,970 --> 00:20:37,010
notice that I've got no red lines there

00:20:33,920 --> 00:20:38,990
so it's definitely not picked up any

00:20:37,010 --> 00:20:43,040
chance of picking up a host and include

00:20:38,990 --> 00:20:45,850
all eye breather right so some of the

00:20:43,040 --> 00:20:48,590
limitations of cleanse driver so it

00:20:45,850 --> 00:20:50,360
clanged supports most of the options

00:20:48,590 --> 00:20:53,690
that you would expect from GCC but not

00:20:50,360 --> 00:20:56,720
all of them for linux applications this

00:20:53,690 --> 00:20:59,060
is typically not a problem for embedded

00:20:56,720 --> 00:21:00,800
systems it can be and so when the first

00:20:59,060 --> 00:21:02,660
thing is it's no support for specs files

00:21:00,800 --> 00:21:06,020
at all if you'd give clang a spec spell

00:21:02,660 --> 00:21:08,390
it will ignore it now clang has up

00:21:06,020 --> 00:21:09,800
configuration files that can be used to

00:21:08,390 --> 00:21:12,110
some kind of replacement for that I'll

00:21:09,800 --> 00:21:13,940
go into those a bit later no there's no

00:21:12,110 --> 00:21:16,730
support for Linux or bare metal multi

00:21:13,940 --> 00:21:18,830
live at the moment Android multi lip is

00:21:16,730 --> 00:21:22,760
available but at the moment there's no

00:21:18,830 --> 00:21:24,530
arm Multi lip and support now the

00:21:22,760 --> 00:21:27,200
heuristics to find a GC installation as

00:21:24,530 --> 00:21:30,740
I've just mentioned are complicated

00:21:27,200 --> 00:21:32,240
opaque and incomplete and whilst they

00:21:30,740 --> 00:21:34,060
can be improved I don't think they'll

00:21:32,240 --> 00:21:37,190
ever be perfect at that particular point

00:21:34,060 --> 00:21:40,990
and as I mentioned multi arch it's

00:21:37,190 --> 00:21:42,830
difficult to avoid hosts politically now

00:21:40,990 --> 00:21:43,940
the other thing that last thing I

00:21:42,830 --> 00:21:45,380
mentioned I'm probably gonna skip this

00:21:43,940 --> 00:21:47,870
particular bits I've been assuming it's

00:21:45,380 --> 00:21:52,850
and I know that um time is going to be

00:21:47,870 --> 00:21:55,100
tight here but if you're doing a GCC

00:21:52,850 --> 00:21:57,590
toolchain sis route to point it as a GCC

00:21:55,100 --> 00:21:59,750
installation it will naturally pick up

00:21:57,590 --> 00:22:02,150
lead libous stood at c++ which is the

00:21:59,750 --> 00:22:04,620
GCC implementation the c++ header and

00:22:02,150 --> 00:22:07,140
sorry and standard library

00:22:04,620 --> 00:22:08,610
when you if you want to use lip C++

00:22:07,140 --> 00:22:10,320
itself it's obviously going to be in a

00:22:08,610 --> 00:22:12,840
different directory structure relative

00:22:10,320 --> 00:22:15,390
to the clang installation not the GCC

00:22:12,840 --> 00:22:17,640
one so you have to specify the includes

00:22:15,390 --> 00:22:22,260
and libraries directly when you're using

00:22:17,640 --> 00:22:23,580
C++ okay so it's an additional and

00:22:22,260 --> 00:22:25,740
compilation option so this is some

00:22:23,580 --> 00:22:28,620
severe extra things that you can do to

00:22:25,740 --> 00:22:30,360
make things a bit easier so the first

00:22:28,620 --> 00:22:32,220
thing and this is really aimed at people

00:22:30,360 --> 00:22:34,320
doing embedded systems more than

00:22:32,220 --> 00:22:36,150
anything else is the clang configuration

00:22:34,320 --> 00:22:38,100
file so if you think of a configuration

00:22:36,150 --> 00:22:40,860
file is just basically a text file with

00:22:38,100 --> 00:22:42,720
all of with all of your configuration

00:22:40,860 --> 00:22:46,260
options to find all your headers and

00:22:42,720 --> 00:22:48,149
libraries so they're just really can

00:22:46,260 --> 00:22:50,370
command line options so there's not

00:22:48,149 --> 00:22:53,190
anything particularly magic about them

00:22:50,370 --> 00:22:54,690
but they can include other configuration

00:22:53,190 --> 00:22:57,000
files so you can in theory build these

00:22:54,690 --> 00:22:58,500
configuration files up in bits and have

00:22:57,000 --> 00:23:00,240
them include them and get them sort of

00:22:58,500 --> 00:23:03,090
as you know assembled together out of

00:23:00,240 --> 00:23:05,640
pieces now the other interesting bit is

00:23:03,090 --> 00:23:09,570
that clang will look for these in

00:23:05,640 --> 00:23:11,010
particular directories and probably not

00:23:09,570 --> 00:23:13,289
the one that you would expect which is

00:23:11,010 --> 00:23:14,760
the directory you're compiling for so I

00:23:13,289 --> 00:23:17,309
think the general idea is that somebody

00:23:14,760 --> 00:23:20,460
it's a provides a tool chain can provide

00:23:17,309 --> 00:23:22,559
these configuration files alongside plan

00:23:20,460 --> 00:23:23,730
for the typical use cases that the

00:23:22,559 --> 00:23:25,620
people who are going to use those to

00:23:23,730 --> 00:23:27,840
chain for which you can imagine could be

00:23:25,620 --> 00:23:29,730
quite useful for say an embedded tool

00:23:27,840 --> 00:23:31,950
chain where you've got various use cases

00:23:29,730 --> 00:23:34,549
for particular users have say new Lib

00:23:31,950 --> 00:23:37,649
new live Nano that that kind of thing

00:23:34,549 --> 00:23:39,570
and an interesting bit about how you

00:23:37,649 --> 00:23:42,120
would specify them is you can say dash

00:23:39,570 --> 00:23:45,559
dash config config file but you can also

00:23:42,120 --> 00:23:48,799
make a sim link to clang with the prefix

00:23:45,559 --> 00:23:52,620
including the the actual config file

00:23:48,799 --> 00:23:56,210
name- the CFG suffix at the end and

00:23:52,620 --> 00:23:58,950
clang will start or basically

00:23:56,210 --> 00:24:02,460
automatically look for the ARM v7 l dot

00:23:58,950 --> 00:24:04,200
CFG so you can kind of avoid users

00:24:02,460 --> 00:24:07,320
having to do that as long as you name

00:24:04,200 --> 00:24:09,310
your name your clang the right way that

00:24:07,320 --> 00:24:13,280
type of thing

00:24:09,310 --> 00:24:14,390
right okay so it's lip C++ compiler RT

00:24:13,280 --> 00:24:17,090
so I've been kind of assuming that

00:24:14,390 --> 00:24:20,420
everyone here has been using Lib GCC and

00:24:17,090 --> 00:24:22,180
if you want to use these for arm you're

00:24:20,420 --> 00:24:24,320
going to have to rebuild them for arm

00:24:22,180 --> 00:24:26,540
now I'm going to skip through the

00:24:24,320 --> 00:24:28,490
process here because I my guess is that

00:24:26,540 --> 00:24:30,320
that's probably not that interesting and

00:24:28,490 --> 00:24:32,450
I know the last the first time I did

00:24:30,320 --> 00:24:34,160
this presentation arm I run out of time

00:24:32,450 --> 00:24:37,430
so I'm gonna go through this very very

00:24:34,160 --> 00:24:39,380
quickly it's effectively you have to go

00:24:37,430 --> 00:24:41,300
through a series of steps building lib

00:24:39,380 --> 00:24:43,010
unwind then building leave Possible's

00:24:41,300 --> 00:24:47,270
ABI because that depends on Lib unwind

00:24:43,010 --> 00:24:50,030
lip C++ depends on lip C++ ABI Lib

00:24:47,270 --> 00:24:51,860
unwind so and then compiler RT depends

00:24:50,030 --> 00:24:53,630
on that so as long as you get everything

00:24:51,860 --> 00:24:55,550
in the right order and give all the

00:24:53,630 --> 00:24:58,460
right things to see make that's kind of

00:24:55,550 --> 00:25:01,340
how it's do how it's done in abstract in

00:24:58,460 --> 00:25:02,810
detail it's quite difficult and there's

00:25:01,340 --> 00:25:05,260
a lot of sort of fiddly options to get

00:25:02,810 --> 00:25:08,930
right but it is possible

00:25:05,260 --> 00:25:11,090
okay so here's just an example I made to

00:25:08,930 --> 00:25:14,210
show that you can use lip C++ compiler

00:25:11,090 --> 00:25:16,700
RT sanitizers it's in effect the ub s--

00:25:14,210 --> 00:25:18,410
an example that i've just modified to

00:25:16,700 --> 00:25:22,100
throw and catch an exception just so

00:25:18,410 --> 00:25:24,950
that i know live unwinds worked and run

00:25:22,100 --> 00:25:27,200
that on creme you you'll see the amount

00:25:24,950 --> 00:25:30,830
of options I've had to pass to clang to

00:25:27,200 --> 00:25:32,270
actually get the C++ to work typically

00:25:30,830 --> 00:25:34,010
means if you if you don't particularly

00:25:32,270 --> 00:25:36,200
care about whether it's Lib C pluses on

00:25:34,010 --> 00:25:38,660
lips good c++ and you can use lips good

00:25:36,200 --> 00:25:41,120
c++ my recommendation is just used that

00:25:38,660 --> 00:25:43,370
it'll be a lot simpler but yeah you can

00:25:41,120 --> 00:25:46,460
see there the bottom line it's and where

00:25:43,370 --> 00:25:49,880
the sanitizers pick pick that up that's

00:25:46,460 --> 00:25:51,800
just an example there okay so what I've

00:25:49,880 --> 00:25:56,360
been doing so far is really assuming

00:25:51,800 --> 00:25:58,430
Linux but in many ways what a lot of

00:25:56,360 --> 00:26:01,160
people looking for is not just that

00:25:58,430 --> 00:26:05,750
they're looking for how could I build a

00:26:01,160 --> 00:26:09,500
tool chain to say replace the GCC nan

00:26:05,750 --> 00:26:11,330
EAB I told chain and that's a bit more

00:26:09,500 --> 00:26:14,300
difficult because there's a lot there's

00:26:11,330 --> 00:26:17,450
with the Linux tool change there's

00:26:14,300 --> 00:26:20,070
something concrete that can be

00:26:17,450 --> 00:26:22,230
pretty much almost standard structure of

00:26:20,070 --> 00:26:24,269
healthy mg CC has laid out and what the

00:26:22,230 --> 00:26:25,710
libraries are whereas for embedded it's

00:26:24,269 --> 00:26:30,629
an it's basically a whole big mess

00:26:25,710 --> 00:26:32,429
you've kind of got and I guess two

00:26:30,629 --> 00:26:34,590
different C libraries in new Libby new

00:26:32,429 --> 00:26:38,490
lab Nano you've got whether you use and

00:26:34,590 --> 00:26:43,100
the semi hosting versions on mom semi

00:26:38,490 --> 00:26:45,539
hosting versions v6 visa so v6 and v7m

00:26:43,100 --> 00:26:48,990
that type of thing so it all gets very

00:26:45,539 --> 00:26:51,749
very complicated very quickly so

00:26:48,990 --> 00:26:53,759
whenever you say - - target equals armed

00:26:51,749 --> 00:26:57,090
nani ABI you're getting what's called

00:26:53,759 --> 00:26:59,039
the bare metal driver and in reality all

00:26:57,090 --> 00:27:03,269
that really does is set up the include

00:26:59,039 --> 00:27:05,549
paths for lib C++ so really you're not

00:27:03,269 --> 00:27:07,289
doing an awful lot with it with that

00:27:05,549 --> 00:27:11,009
particular one and you actually have to

00:27:07,289 --> 00:27:14,580
do a lot of the include and library

00:27:11,009 --> 00:27:17,580
directory paths at the same time and it

00:27:14,580 --> 00:27:21,269
will also default to L LD as the linker

00:27:17,580 --> 00:27:22,919
which for embedded systems can be a

00:27:21,269 --> 00:27:25,710
problem particularly for those with very

00:27:22,919 --> 00:27:28,499
complicated and linker scripts so if you

00:27:25,710 --> 00:27:29,999
are trying to use clang for embedded

00:27:28,499 --> 00:27:35,610
systems I've generally found the best

00:27:29,999 --> 00:27:37,950
way to do is to use GCC to start with

00:27:35,610 --> 00:27:39,539
and use its - the option to find the

00:27:37,950 --> 00:27:42,529
include and the library paths that it's

00:27:39,539 --> 00:27:45,450
that it's found and then use those to

00:27:42,529 --> 00:27:48,629
the clang to work out how it would all

00:27:45,450 --> 00:27:50,460
be picked out so that that's kind of the

00:27:48,629 --> 00:27:51,840
easiest way I found to actually use

00:27:50,460 --> 00:27:53,549
clang for compile for embedded systems

00:27:51,840 --> 00:27:55,980
now that obviously is not going to be

00:27:53,549 --> 00:27:57,419
very friendly for at all chain so what

00:27:55,980 --> 00:27:58,830
I'm going to suggest and I'll go back to

00:27:57,419 --> 00:28:02,210
this at the end of the talk is that an

00:27:58,830 --> 00:28:05,580
any particular vendor that tries to

00:28:02,210 --> 00:28:08,759
construct a tour chain for embedded

00:28:05,580 --> 00:28:10,799
systems they provide config files for

00:28:08,759 --> 00:28:15,360
the most common cases that can that can

00:28:10,799 --> 00:28:17,759
make that work so one of the things that

00:28:15,360 --> 00:28:19,379
you must do for embedded systems that's

00:28:17,759 --> 00:28:20,369
going to use compiler RT is you are

00:28:19,379 --> 00:28:23,220
going to have to cross compile that

00:28:20,369 --> 00:28:25,619
because there's no upstream binary that

00:28:23,220 --> 00:28:28,350
you can download to get v6 and v7 and v8

00:28:25,619 --> 00:28:29,799
and oceans of compiler RT now there is a

00:28:28,350 --> 00:28:32,289
guide available there

00:28:29,799 --> 00:28:33,730
to high level one that you can go to for

00:28:32,289 --> 00:28:36,759
there and you need to place those

00:28:33,730 --> 00:28:41,110
libraries into a Lib / bare metal

00:28:36,759 --> 00:28:45,129
directory for a client to find them so

00:28:41,110 --> 00:28:47,879
moving on to C make anyone who's had to

00:28:45,129 --> 00:28:51,279
use it can be quite frustrating at times

00:28:47,879 --> 00:28:54,489
so there are I think Auto Kampf has

00:28:51,279 --> 00:28:56,230
similar similar options for cross

00:28:54,489 --> 00:28:58,239
compiling unfortunate I don't know

00:28:56,230 --> 00:28:59,889
though something up my head so I've not

00:28:58,239 --> 00:29:02,019
gone into that a particular one one

00:28:59,889 --> 00:29:03,609
there so this is sort of hints and tips

00:29:02,019 --> 00:29:05,739
of people who want to use clang in a C

00:29:03,609 --> 00:29:09,129
main context so in the first thing that

00:29:05,739 --> 00:29:11,769
I've found that things go wrong is that

00:29:09,129 --> 00:29:15,460
C make has a try compile step and that

00:29:11,769 --> 00:29:17,139
try compile step will effectively say is

00:29:15,460 --> 00:29:20,379
my compiler same so it'll try and

00:29:17,139 --> 00:29:22,179
compile the C program and/or a C++

00:29:20,379 --> 00:29:23,769
program if you're using it and if that

00:29:22,179 --> 00:29:26,950
fails you won't get very far with the

00:29:23,769 --> 00:29:28,929
configuration so what I've found if

00:29:26,950 --> 00:29:32,109
you're compiling for say something like

00:29:28,929 --> 00:29:33,940
v6 m v7 n actually getting the linker to

00:29:32,109 --> 00:29:36,519
work in that context is quite difficult

00:29:33,940 --> 00:29:40,090
because you have to pass all of the

00:29:36,519 --> 00:29:41,950
includes and libraries libraries through

00:29:40,090 --> 00:29:44,440
so what I found the best way to do there

00:29:41,950 --> 00:29:46,239
is to use C make try compile target

00:29:44,440 --> 00:29:47,649
equals static library particularly if

00:29:46,239 --> 00:29:48,730
you're trying if for embedded systems

00:29:47,649 --> 00:29:50,980
you typically just want to build a

00:29:48,730 --> 00:29:52,210
library not a shared object so it

00:29:50,980 --> 00:29:54,489
doesn't really matter if you link it to

00:29:52,210 --> 00:29:56,289
some work at that particular point so

00:29:54,489 --> 00:29:59,859
you can just then stop at the compile

00:29:56,289 --> 00:30:02,080
stage and that can solve certainly made

00:29:59,859 --> 00:30:04,450
cross compiling compiler RT much much

00:30:02,080 --> 00:30:06,970
easier at that point so these various

00:30:04,450 --> 00:30:08,830
other C make options are a way of

00:30:06,970 --> 00:30:11,320
passing through things like the SIS

00:30:08,830 --> 00:30:14,320
route and the GCC toolchain directly

00:30:11,320 --> 00:30:17,139
through the clang and you can also set

00:30:14,320 --> 00:30:22,419
the targets that C make would use for

00:30:17,139 --> 00:30:23,859
its cross compilation support finally

00:30:22,419 --> 00:30:26,710
quite something that I've had to do

00:30:23,859 --> 00:30:29,019
quite recently when I was trying to use

00:30:26,710 --> 00:30:32,230
clang with this F air operating system

00:30:29,019 --> 00:30:34,450
and adapt Aquila points and lld didn't

00:30:32,230 --> 00:30:36,820
quite work for the linker script and so

00:30:34,450 --> 00:30:39,549
I needed to use and GCC is the linker

00:30:36,820 --> 00:30:41,440
driver and you ended up having to

00:30:39,549 --> 00:30:43,690
because the way C make works it will

00:30:41,440 --> 00:30:45,129
always use the compiler just a linker

00:30:43,690 --> 00:30:47,980
driver it won't invoke the linker

00:30:45,129 --> 00:30:51,490
directly so I ended up changing the C

00:30:47,980 --> 00:30:53,559
make link executive or the GCC now one

00:30:51,490 --> 00:30:56,950
caveat is when you you can change the

00:30:53,559 --> 00:30:58,539
compiler from clang to GCC and you don't

00:30:56,950 --> 00:31:00,669
need to worry about how the flags are

00:30:58,539 --> 00:31:02,649
passed but if you override the linker C

00:31:00,669 --> 00:31:04,929
make basically says well I have no idea

00:31:02,649 --> 00:31:07,269
how you actually plus the objects and

00:31:04,929 --> 00:31:08,830
the flags to the linker it's basically

00:31:07,269 --> 00:31:10,869
assuming you've got a completely custom

00:31:08,830 --> 00:31:12,609
linker so basically you need something

00:31:10,869 --> 00:31:15,100
like what I've got there which I pretty

00:31:12,609 --> 00:31:17,769
much adapted from the default C make one

00:31:15,100 --> 00:31:23,529
for GCC for how to pass the libraries

00:31:17,769 --> 00:31:25,509
and objects true ok so on to some of the

00:31:23,529 --> 00:31:26,980
differences that are found for GCC and

00:31:25,509 --> 00:31:28,840
I'm sure the audience who've had pre had

00:31:26,980 --> 00:31:31,149
a bit bit more more stories from say the

00:31:28,840 --> 00:31:35,169
Linux kernel can add plenty of these to

00:31:31,149 --> 00:31:36,399
this particular bit here so one of the

00:31:35,169 --> 00:31:38,590
first things you'll find when you're

00:31:36,399 --> 00:31:40,419
doing any kind of embedded system the

00:31:38,590 --> 00:31:43,659
chances are that you'll find somebody's

00:31:40,419 --> 00:31:45,519
written some assembly somewhere and this

00:31:43,659 --> 00:31:46,119
is where the clang integrated assembler

00:31:45,519 --> 00:31:50,519
comes in

00:31:46,119 --> 00:31:54,249
so clang by default builds an assembler

00:31:50,519 --> 00:31:55,359
as part of its sort of them well it has

00:31:54,249 --> 00:31:57,879
the ability to have an integrated

00:31:55,359 --> 00:32:02,789
assembler so it doesn't call out to

00:31:57,879 --> 00:32:06,929
something like a new is the syntax is

00:32:02,789 --> 00:32:12,039
I'd say clang is probably fussier than

00:32:06,929 --> 00:32:15,519
the new AAS in terms of its and support

00:32:12,039 --> 00:32:17,080
for arm assembly language if it's a bit

00:32:15,519 --> 00:32:19,809
you often find it will complain that

00:32:17,080 --> 00:32:23,200
you've not put a hash in or pound sign

00:32:19,809 --> 00:32:26,169
in the US English for things like some

00:32:23,200 --> 00:32:27,999
of the ldr commands where strictly

00:32:26,169 --> 00:32:30,879
speaking according to the spec that

00:32:27,999 --> 00:32:33,549
would be optional there's other problems

00:32:30,879 --> 00:32:35,019
with the dot W for what which is the

00:32:33,549 --> 00:32:37,090
wide instruction you would use for thumb

00:32:35,019 --> 00:32:38,619
to sometimes clang Horlicks say oh

00:32:37,090 --> 00:32:40,450
you're not allowed to use it on this

00:32:38,619 --> 00:32:45,489
instruction when the spec says yes you

00:32:40,450 --> 00:32:48,549
are so normally these things you can you

00:32:45,489 --> 00:32:50,230
can work around by making making them in

00:32:48,549 --> 00:32:53,740
a particular syntax that's except

00:32:50,230 --> 00:32:55,840
- both in UAS and clang but it's still

00:32:53,740 --> 00:32:57,640
ideally shouldn't happen and MIT and

00:32:55,840 --> 00:32:59,500
clang should support the full thing

00:32:57,640 --> 00:33:04,770
you'll notice that some pseudo

00:32:59,500 --> 00:33:07,990
instructions not accepted by clang and

00:33:04,770 --> 00:33:10,150
clang doesn't support alt macro no I've

00:33:07,990 --> 00:33:11,620
not actually run across anything that

00:33:10,150 --> 00:33:14,170
anyone's actually tried to compile and

00:33:11,620 --> 00:33:16,270
complained about this but alt macro is

00:33:14,170 --> 00:33:18,400
some additional macros some sort of

00:33:16,270 --> 00:33:21,040
support that's built into us but I think

00:33:18,400 --> 00:33:24,610
that's being used very spare sparsely at

00:33:21,040 --> 00:33:26,530
that particular point so yeah so in

00:33:24,610 --> 00:33:28,870
effect you'll often find lots of things

00:33:26,530 --> 00:33:30,250
that are not quite right and there isn't

00:33:28,870 --> 00:33:31,990
an ongoing effort to improve the

00:33:30,250 --> 00:33:35,860
assembler one of the things that may

00:33:31,990 --> 00:33:38,290
never be exactly the same is that the

00:33:35,860 --> 00:33:41,140
LLVM integrator December is a single

00:33:38,290 --> 00:33:44,350
pass so it will go through and it will

00:33:41,140 --> 00:33:47,890
patch up expressions so if you make an

00:33:44,350 --> 00:33:51,790
expression clang doesn't know tool very

00:33:47,890 --> 00:33:54,040
very late in assembly what that will

00:33:51,790 --> 00:33:56,830
evaluate to and then it'll then try and

00:33:54,040 --> 00:33:58,390
back patch that value so sometimes

00:33:56,830 --> 00:33:59,860
you'll find that an assembler needs to

00:33:58,390 --> 00:34:02,350
make a decision based on what that

00:33:59,860 --> 00:34:03,700
expression is and if it has no idea what

00:34:02,350 --> 00:34:05,260
that expression is going to be because

00:34:03,700 --> 00:34:07,420
it hasn't got to the label at the end

00:34:05,260 --> 00:34:11,410
yet it won't be able to evaluate the

00:34:07,420 --> 00:34:13,630
expression now in terms of what people

00:34:11,410 --> 00:34:15,400
write in day-to-day code that's

00:34:13,630 --> 00:34:16,570
generally not a problem but it's

00:34:15,400 --> 00:34:17,850
something that you might need to be

00:34:16,570 --> 00:34:20,380
aware from you've got very complicated

00:34:17,850 --> 00:34:23,170
relative expressions referring to labels

00:34:20,380 --> 00:34:25,600
in the future particular point and you

00:34:23,170 --> 00:34:29,080
can turn that off and go back to us if

00:34:25,600 --> 00:34:30,700
you need to okay so one of the things I

00:34:29,080 --> 00:34:33,310
noticed while there fear that may

00:34:30,700 --> 00:34:35,320
looking at South Ian may causes and self

00:34:33,310 --> 00:34:39,910
some problems is that clang war claimed

00:34:35,320 --> 00:34:41,740
to be GCC 4.2.1 now if all you

00:34:39,910 --> 00:34:45,580
everything that you need is supported by

00:34:41,740 --> 00:34:48,940
GCC 4.2.1 that's fine but if if you've

00:34:45,580 --> 00:34:51,700
got defines that say if your GCC but you

00:34:48,940 --> 00:34:54,130
need to be level greater than say five

00:34:51,700 --> 00:34:56,170
then you'll find that that define won't

00:34:54,130 --> 00:34:58,720
fire the clang now my understanding the

00:34:56,170 --> 00:35:00,370
reason for that is is that and the

00:34:58,720 --> 00:35:01,570
developers of the plan wanted to be very

00:35:00,370 --> 00:35:04,030
conservative

00:35:01,570 --> 00:35:06,550
as they don't support all of what later

00:35:04,030 --> 00:35:08,260
GCC's support so he wanted to pick a

00:35:06,550 --> 00:35:10,060
particularly old version where most

00:35:08,260 --> 00:35:12,160
almost all of the things were like to be

00:35:10,060 --> 00:35:14,460
supported but basically that's something

00:35:12,160 --> 00:35:17,470
to be wary for if you've got a young a

00:35:14,460 --> 00:35:19,900
code base with lots of if GCC greater

00:35:17,470 --> 00:35:21,730
than version you may need to go through

00:35:19,900 --> 00:35:26,170
and use the clang equivalents to make

00:35:21,730 --> 00:35:28,390
sure that those things fire it's likely

00:35:26,170 --> 00:35:30,040
to ever gonna change the the number like

00:35:28,390 --> 00:35:32,560
will it update to four point eight or

00:35:30,040 --> 00:35:34,390
something and my guess it made I think

00:35:32,560 --> 00:35:36,580
one of the things that was holding it

00:35:34,390 --> 00:35:38,440
back with us and go to support so it may

00:35:36,580 --> 00:35:40,450
be that if item go to support gets

00:35:38,440 --> 00:35:42,370
particularly and gets far enough along

00:35:40,450 --> 00:35:43,870
they'll be another push to do that or

00:35:42,370 --> 00:35:45,520
maybe someone will need to push and say

00:35:43,870 --> 00:35:47,860
hey can we move this up now this has

00:35:45,520 --> 00:35:51,610
gone but yeah I think that was one of

00:35:47,860 --> 00:35:52,660
the major things holding it back okay so

00:35:51,610 --> 00:35:55,870
some of the things that you may notice

00:35:52,660 --> 00:35:57,250
well just using lld so by default if

00:35:55,870 --> 00:35:59,020
you're using a laude force a Linux

00:35:57,250 --> 00:36:00,850
application you really shouldn't see any

00:35:59,020 --> 00:36:03,160
difference I probably say that the

00:36:00,850 --> 00:36:05,440
compatibility that lld has is probably

00:36:03,160 --> 00:36:08,560
better than gold does at the moment and

00:36:05,440 --> 00:36:12,030
forearm one of the interesting thing is

00:36:08,560 --> 00:36:15,040
that lld will default as a - z text and

00:36:12,030 --> 00:36:16,960
which means that no dynamic relocations

00:36:15,040 --> 00:36:18,760
are allowed in the text segment so only

00:36:16,960 --> 00:36:23,620
mention that is that some programs do

00:36:18,760 --> 00:36:25,000
have these and there and can uld be FD

00:36:23,620 --> 00:36:26,710
which is the canoe linker won't warn

00:36:25,000 --> 00:36:28,690
about them so you can sometimes get

00:36:26,710 --> 00:36:30,580
errors there typically you don't want

00:36:28,690 --> 00:36:31,870
dynamic relocation the text section it's

00:36:30,580 --> 00:36:34,240
usually a sign that something's wrong in

00:36:31,870 --> 00:36:37,450
the program so that's tended not to be a

00:36:34,240 --> 00:36:39,520
problem so far now for embedded systems

00:36:37,450 --> 00:36:41,850
one of the big restrictions that lld has

00:36:39,520 --> 00:36:44,740
is it's got very limited support for o

00:36:41,850 --> 00:36:48,550
magic and n magic and what those things

00:36:44,740 --> 00:36:50,050
do is basically turn off paging in the

00:36:48,550 --> 00:36:51,730
linker because obviously an embedded

00:36:50,050 --> 00:36:53,170
system you might not have an MMU you

00:36:51,730 --> 00:36:56,260
don't really want things to be four

00:36:53,170 --> 00:36:58,930
kilobyte aligned all over the place so

00:36:56,260 --> 00:37:01,180
LOD does have support the - capital n

00:36:58,930 --> 00:37:03,540
which is o magic what that does is it

00:37:01,180 --> 00:37:05,970
makes the text section writable and

00:37:03,540 --> 00:37:08,890
turns off paging

00:37:05,970 --> 00:37:13,390
GCC's at all it doesn't lld is turned

00:37:08,890 --> 00:37:15,460
off the turn off the make the text

00:37:13,390 --> 00:37:17,410
section writable but it doesn't do

00:37:15,460 --> 00:37:19,780
anything with a page size so what I find

00:37:17,410 --> 00:37:24,250
is that you can simulate that by setting

00:37:19,780 --> 00:37:26,520
the maximum page size to one so the

00:37:24,250 --> 00:37:29,350
program loader

00:37:26,520 --> 00:37:30,760
generation which is kind of so but when

00:37:29,350 --> 00:37:33,100
you write a linker script and you have

00:37:30,760 --> 00:37:34,870
the sections command the linker has to

00:37:33,100 --> 00:37:37,840
basically work out where the program

00:37:34,870 --> 00:37:40,060
segments are and the algorithm that lld

00:37:37,840 --> 00:37:42,490
does is not exactly the same as the one

00:37:40,060 --> 00:37:44,740
that and the canoe linker has so

00:37:42,490 --> 00:37:46,720
typically find if there are any problems

00:37:44,740 --> 00:37:48,580
there you can set that manually yourself

00:37:46,720 --> 00:37:53,050
with the MP headers linker script

00:37:48,580 --> 00:37:54,850
command and certainly the L LD linker

00:37:53,050 --> 00:37:56,290
script support is not perfect as anyone

00:37:54,850 --> 00:37:57,730
who's tried to use the Linux kernel

00:37:56,290 --> 00:37:59,950
worlds I've built a minutes ago that

00:37:57,730 --> 00:38:03,040
will tell you and their various things

00:37:59,950 --> 00:38:04,600
that think things that you would think

00:38:03,040 --> 00:38:07,510
no one's going to write that until

00:38:04,600 --> 00:38:10,720
somebody does unfortunately so things

00:38:07,510 --> 00:38:14,530
like change of symbol aliases don't

00:38:10,720 --> 00:38:17,280
always get referenced around just a link

00:38:14,530 --> 00:38:19,740
and makes only a single pass over these

00:38:17,280 --> 00:38:22,480
and there's some syntactic differences

00:38:19,740 --> 00:38:24,280
that will come through most of these can

00:38:22,480 --> 00:38:26,710
be fiddled around but I think I love the

00:38:24,280 --> 00:38:28,150
problem that comes is that and people

00:38:26,710 --> 00:38:30,820
typically don't write a linker scripts

00:38:28,150 --> 00:38:32,110
they write a program that generates a

00:38:30,820 --> 00:38:34,480
linker script from a bunch of hash

00:38:32,110 --> 00:38:37,750
defines and sometimes it's actually

00:38:34,480 --> 00:38:42,400
quite difficult to get to the bottom of

00:38:37,750 --> 00:38:44,500
where of all these problems I'll okay so

00:38:42,400 --> 00:38:46,420
I'm just going to close up now with some

00:38:44,500 --> 00:38:50,560
talk about what would it take to bake a

00:38:46,420 --> 00:38:52,480
clang and lrvm tool chain today so the

00:38:50,560 --> 00:38:53,980
first thing if you want to get that you

00:38:52,480 --> 00:38:56,290
know assuming you're a maintainer of a

00:38:53,980 --> 00:38:58,840
open-source project and you want to

00:38:56,290 --> 00:39:00,910
allow clang support so I guess in this

00:38:58,840 --> 00:39:03,160
kind of three different scenarios that

00:39:00,910 --> 00:39:04,630
you might go through to make that

00:39:03,160 --> 00:39:06,460
through so the first thing is really

00:39:04,630 --> 00:39:08,080
it's a documentation approach it's

00:39:06,460 --> 00:39:09,550
basically relying on the cross

00:39:08,080 --> 00:39:13,330
compilation options for your build

00:39:09,550 --> 00:39:15,640
system so chances are you're going to

00:39:13,330 --> 00:39:17,980
have to write down

00:39:15,640 --> 00:39:19,900
for the user which options they need to

00:39:17,980 --> 00:39:22,060
do to in order to feed clang through

00:39:19,900 --> 00:39:25,180
into that particularly if it gets but it

00:39:22,060 --> 00:39:26,790
gets complicated an interesting one that

00:39:25,180 --> 00:39:29,740
you've got to be careful of these

00:39:26,790 --> 00:39:31,960
programs that build executive balls that

00:39:29,740 --> 00:39:33,730
then build more artifacts to a use later

00:39:31,960 --> 00:39:36,610
in the program a good example of this is

00:39:33,730 --> 00:39:40,060
Al OPM's table Jan so when you build

00:39:36,610 --> 00:39:42,760
lrvm it builds this program called table

00:39:40,060 --> 00:39:44,860
gen which is an executive all that needs

00:39:42,760 --> 00:39:46,630
to run on the host that then generates a

00:39:44,860 --> 00:39:48,940
lot of C code that's used in a later

00:39:46,630 --> 00:39:50,920
build step so if you're cross compiling

00:39:48,940 --> 00:39:53,650
clang and turning telling it to build

00:39:50,920 --> 00:39:56,050
for arm it'll build lrvm table gen for

00:39:53,650 --> 00:39:58,690
arm which if it then tries to run on

00:39:56,050 --> 00:40:00,340
your x86 hosts it won't work so you then

00:39:58,690 --> 00:40:02,950
you basically have a separate build

00:40:00,340 --> 00:40:04,660
option to pass in the location of a host

00:40:02,950 --> 00:40:05,950
table gen that you can use in sense so

00:40:04,660 --> 00:40:07,390
if you've got anything like that in your

00:40:05,950 --> 00:40:09,340
project that's got any in self

00:40:07,390 --> 00:40:11,080
intermediate code generator you don't

00:40:09,340 --> 00:40:13,060
have to be very careful about making

00:40:11,080 --> 00:40:16,060
sure that gets compiled for the right

00:40:13,060 --> 00:40:17,920
toast next approach that things like

00:40:16,060 --> 00:40:19,630
Android NDK and Google Chrome have done

00:40:17,920 --> 00:40:21,280
it's basically supplied all the tool

00:40:19,630 --> 00:40:23,710
chains with you you know with the

00:40:21,280 --> 00:40:27,490
project itself typically only very large

00:40:23,710 --> 00:40:29,380
open-source projects can afford to do

00:40:27,490 --> 00:40:31,060
that because it effectively means you've

00:40:29,380 --> 00:40:34,180
got to have people maintaining that tool

00:40:31,060 --> 00:40:37,360
chain and again not many people can

00:40:34,180 --> 00:40:38,890
afford to afford that sort of luxury but

00:40:37,360 --> 00:40:40,990
in in effect there they've set up the

00:40:38,890 --> 00:40:44,080
libraries includes for that particular

00:40:40,990 --> 00:40:45,730
run tour chain and it just works

00:40:44,080 --> 00:40:48,160
automatically after the box when people

00:40:45,730 --> 00:40:50,290
compile and finally the way to customize

00:40:48,160 --> 00:40:52,510
clang is to say if you've got a

00:40:50,290 --> 00:40:54,160
completely unique environment you can

00:40:52,510 --> 00:40:56,320
basically build your own tool chain

00:40:54,160 --> 00:40:58,270
class for that so for example the future

00:40:56,320 --> 00:41:01,090
operating system does things quite

00:40:58,270 --> 00:41:03,370
differently to say Linux and they've got

00:41:01,090 --> 00:41:05,770
their own future tool chain class within

00:41:03,370 --> 00:41:07,510
clang that sorts all of that help for

00:41:05,770 --> 00:41:09,160
you and typically the more specialized

00:41:07,510 --> 00:41:11,230
your environment there the easier it is

00:41:09,160 --> 00:41:14,830
to write your own tool chain class for

00:41:11,230 --> 00:41:17,230
that so yeah

00:41:14,830 --> 00:41:19,180
luster last slide here is how could we

00:41:17,230 --> 00:41:21,970
assemble a clang tool chain today so

00:41:19,180 --> 00:41:23,710
there's two cases here there's a Linux

00:41:21,970 --> 00:41:26,860
tool chain which is kind of like

00:41:23,710 --> 00:41:28,280
equivalent to the manaro arm - Linux -

00:41:26,860 --> 00:41:30,380
can you ABI H

00:41:28,280 --> 00:41:32,000
and then there's a bare-metal tool chain

00:41:30,380 --> 00:41:35,210
which would be the equivalent to arm -

00:41:32,000 --> 00:41:36,890
nom ei bi and there and so those two

00:41:35,210 --> 00:41:39,260
things are quite different so I think

00:41:36,890 --> 00:41:41,990
the Linux tool chain we'd be fairly

00:41:39,260 --> 00:41:45,049
close there and in many ways it would

00:41:41,990 --> 00:41:47,059
just be a matter of copying clang into a

00:41:45,049 --> 00:41:49,460
you know into the similar directory

00:41:47,059 --> 00:41:52,789
structure that we have the GCC probably

00:41:49,460 --> 00:41:55,569
hard-code the SIS route in the clan

00:41:52,789 --> 00:41:58,309
build so that it picks up the GCC

00:41:55,569 --> 00:41:59,690
toolchain z' headers first say the c

00:41:58,309 --> 00:42:03,049
library that type of thing

00:41:59,690 --> 00:42:05,980
we've provide the target compiler RT

00:42:03,049 --> 00:42:08,960
libraries and whatever so I think that's

00:42:05,980 --> 00:42:11,119
eminently possible to do whether that

00:42:08,960 --> 00:42:14,210
would be necessary or not I don't really

00:42:11,119 --> 00:42:16,339
know but yes I think a Linux client or

00:42:14,210 --> 00:42:18,589
chain would across compiler tool chain

00:42:16,339 --> 00:42:20,470
will work quite well the bare metal one

00:42:18,589 --> 00:42:22,640
is a bit more difficult

00:42:20,470 --> 00:42:25,609
most likely the problem the problem here

00:42:22,640 --> 00:42:27,650
is multi Lib because you haven't got any

00:42:25,609 --> 00:42:30,440
multi live support or specs files so in

00:42:27,650 --> 00:42:33,980
effect what you would need is a set of

00:42:30,440 --> 00:42:36,950
configuration files that would cover the

00:42:33,980 --> 00:42:39,950
sort of subset of the cases that you

00:42:36,950 --> 00:42:43,430
think users would want so the one I've

00:42:39,950 --> 00:42:48,230
got their example arm v6n rd i'm on nano

00:42:43,430 --> 00:42:52,369
would select the d sort of them semi

00:42:48,230 --> 00:42:54,140
hosting new live nano for cortex v6 m

00:42:52,369 --> 00:42:55,789
and that would then pick up all the

00:42:54,140 --> 00:42:56,359
right libraries and includes for you at

00:42:55,789 --> 00:42:58,390
that point

00:42:56,359 --> 00:43:00,740
and you'd effectively be relying on

00:42:58,390 --> 00:43:03,140
customers to tweak that at that

00:43:00,740 --> 00:43:05,180
particular point and you'd probably

00:43:03,140 --> 00:43:06,740
still stick to canoe binutils to start

00:43:05,180 --> 00:43:09,589
with until l all these support for

00:43:06,740 --> 00:43:11,000
embedded systems can be improved and in

00:43:09,589 --> 00:43:12,289
the most cases if you're supplying any

00:43:11,000 --> 00:43:14,990
canoe libraries you probably need to

00:43:12,289 --> 00:43:18,289
compile them with GCC rather than clang

00:43:14,990 --> 00:43:20,809
itself so again it's doable but it would

00:43:18,289 --> 00:43:25,240
be messy at the moment without multi

00:43:20,809 --> 00:43:27,829
live support in clang ok I believe

00:43:25,240 --> 00:43:31,220
that's all I've got for in terms of

00:43:27,829 --> 00:43:33,109
that'sthat's info-dump over so if anyone

00:43:31,220 --> 00:43:34,880
wants to talk to me about any of that I

00:43:33,109 --> 00:43:36,820
can go through some of that and a bit a

00:43:34,880 --> 00:43:38,740
bit more slowly

00:43:36,820 --> 00:43:41,110
and go to any particular scenarios but

00:43:38,740 --> 00:43:44,250
if anyone's got any questions I'm happy

00:43:41,110 --> 00:43:44,250
to answer them

00:43:50,030 --> 00:44:00,080
yeah so does the C's route option for

00:43:56,660 --> 00:44:03,220
the llv Arang is it exactly the same as

00:44:00,080 --> 00:44:06,080
this is route option used in the C make

00:44:03,220 --> 00:44:07,730
to change make it pretty much the same

00:44:06,080 --> 00:44:10,760
thing I mean it's effectively saying

00:44:07,730 --> 00:44:12,800
look for the includes and library

00:44:10,760 --> 00:44:14,990
directions and binary things relative to

00:44:12,800 --> 00:44:17,180
that this route thing so yeah so if you

00:44:14,990 --> 00:44:20,060
say the C makes this route it will pass

00:44:17,180 --> 00:44:28,910
- - this route through to Flutie plan

00:44:20,060 --> 00:44:30,380
alright thank you okay so don't feel

00:44:28,910 --> 00:44:31,640
that you have to ask any questions and I

00:44:30,380 --> 00:44:34,070
have questions but I think that take

00:44:31,640 --> 00:44:35,810
takes it too far we have - okay okay

00:44:34,070 --> 00:44:38,510
well thank you very much for listening

00:44:35,810 --> 00:44:40,540
anyone and I say I hope you have a good

00:44:38,510 --> 00:44:44,989
rest of the connect

00:44:40,540 --> 00:44:44,989

YouTube URL: https://www.youtube.com/watch?v=D47hCV6wpxo


