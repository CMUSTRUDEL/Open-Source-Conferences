Title: Open Source Software Stack for Heterogenous embedded devices by Tomas Evensen (BKK19-400K2)
Publication date: 2019-04-11
Playlist: Linaro Connect Bangkok 2019
Description: 
	As heterogeneous embedded systems are getting more powerful and common place there are a number of complexities that come with creating the associated software stacks. This talk will cover some of these issues and discuss solutions, tying together topics such as heterogeneous HW (Xilinx Versal ACAP and Zynq MPSoC), use cases, OpenAMP, System Device Trees, Hypervisors, Cache coloring, Ultra96V2 and CCIX.

Presented by Tomas Evensen (CTO Embedded Software at Xilinx) at Linaro Connect Bangkok 2019.

Tomas Evensen is Chief Technology Officer, Embedded Software at Xilinx.
In this role he is responsible for the embedded software strategy for
Xilinx SoCs. Prior to joining Xilinx, Evensen was Chief
Technology Officer at Wind River for 7 years, as well as GM for the Wind
River Tools Division and VP of Engineering for the VxWorks operating system.
Before that he was the creator of the Diab Data C/C++ compilers.
Evensen received his MSEE at the Royal Institute of Technology in Stockholm, Sweden.


If you missed the world's leading Open Source on Arm event, Linaro Connect Bangkok 2019, then don't worry since it takes place every 6 months and you can join us for Linaro Connect San Diego 2019 this September. Find out more here: https://connect.linaro.org/register/
Captions: 
	00:00:00,030 --> 00:00:09,960
of it Evanson who's the CTO of embedded

00:00:02,700 --> 00:00:11,280
for Xilinx thank you so good morning so

00:00:09,960 --> 00:00:14,969
today I'm going to talk about

00:00:11,280 --> 00:00:17,670
heterogenous embedded systems so let's

00:00:14,969 --> 00:00:20,310
dive into it so this is I'm coming from

00:00:17,670 --> 00:00:23,160
stylings we're doing these associate are

00:00:20,310 --> 00:00:24,779
feeling massively hetra dinos so this is

00:00:23,160 --> 00:00:26,910
the next generation we're going to come

00:00:24,779 --> 00:00:28,560
out with and as you can see that lots of

00:00:26,910 --> 00:00:31,769
stuff is a little bit hard to read here

00:00:28,560 --> 00:00:34,050
but there are multiple CPU calsters

00:00:31,769 --> 00:00:37,050
there there's a 72s

00:00:34,050 --> 00:00:39,989
few are those typically people run Linux

00:00:37,050 --> 00:00:42,030
on that let's say we have our five so

00:00:39,989 --> 00:00:44,460
what we call the RPS real-time process

00:00:42,030 --> 00:00:45,570
units typically people run maybe

00:00:44,460 --> 00:00:47,879
something like these to be safety

00:00:45,570 --> 00:00:49,860
certified maybe it's real time they need

00:00:47,879 --> 00:00:52,620
to have a faster response time for

00:00:49,860 --> 00:00:55,800
external stimuli and so on we have on

00:00:52,620 --> 00:00:57,390
the left side we have AI engines so

00:00:55,800 --> 00:01:01,140
machine learning is coming all over the

00:00:57,390 --> 00:01:04,129
place right so basically DSP and IANS

00:01:01,140 --> 00:01:06,180
they can do multiply accelerate

00:01:04,129 --> 00:01:10,020
accumulate really really fast but also

00:01:06,180 --> 00:01:14,010
being able to to place and route the

00:01:10,020 --> 00:01:17,850
different data streams both through the

00:01:14,010 --> 00:01:19,110
math Indians the AI DSPs and to the FPGA

00:01:17,850 --> 00:01:22,409
fabric that are going to talk about

00:01:19,110 --> 00:01:24,509
right so it's not only the compute but

00:01:22,409 --> 00:01:26,700
it's also how do you route the traffic

00:01:24,509 --> 00:01:28,320
through all these things how do you have

00:01:26,700 --> 00:01:31,290
different levels of hierarchies and so

00:01:28,320 --> 00:01:34,439
on so and then in the middle there we

00:01:31,290 --> 00:01:37,200
have the more traditional FPGA or fabric

00:01:34,439 --> 00:01:39,810
or programmable logic as we also call it

00:01:37,200 --> 00:01:42,479
which is basically hardware that you can

00:01:39,810 --> 00:01:44,340
reconfigure out in the field you can

00:01:42,479 --> 00:01:46,159
reprogram the hardware basically all

00:01:44,340 --> 00:01:49,049
right so you have a device like this

00:01:46,159 --> 00:01:51,450
from a software point of view lots of

00:01:49,049 --> 00:01:53,490
issues coming up it's not one

00:01:51,450 --> 00:01:55,619
homogeneous system where you can run

00:01:53,490 --> 00:01:57,240
applications in the same way all over

00:01:55,619 --> 00:01:59,159
the place so I'm going to talk a little

00:01:57,240 --> 00:02:02,280
bit about the issues that are coming out

00:01:59,159 --> 00:02:04,439
do this and also some of the solutions

00:02:02,280 --> 00:02:07,619
that we working on to to fix those

00:02:04,439 --> 00:02:11,849
problems we're at first couple of words

00:02:07,619 --> 00:02:13,560
on FPGA is I think last year has a

00:02:11,849 --> 00:02:16,050
similar slide here but just

00:02:13,560 --> 00:02:17,910
really a quick recap on an FPGA year so

00:02:16,050 --> 00:02:20,160
in FPGA is one of those things that's

00:02:17,910 --> 00:02:21,900
different to whoever you ask because

00:02:20,160 --> 00:02:24,360
they can be used in so many different

00:02:21,900 --> 00:02:27,150
ways depending on on how we program it

00:02:24,360 --> 00:02:29,340
right so in the everyday you have

00:02:27,150 --> 00:02:32,400
something called the programmable logic

00:02:29,340 --> 00:02:34,110
the look-up tables so you imagine that

00:02:32,400 --> 00:02:36,600
those are the places where you can put

00:02:34,110 --> 00:02:38,489
in your nor gate your NAND gates at the

00:02:36,600 --> 00:02:40,410
really low level you can program your

00:02:38,489 --> 00:02:42,930
hallway right yeah

00:02:40,410 --> 00:02:45,180
but over the years we have added lots of

00:02:42,930 --> 00:02:47,880
more hardened blocks for example memory

00:02:45,180 --> 00:02:49,920
everyone needs to use memory it's very

00:02:47,880 --> 00:02:51,840
very expensive if you use those look-up

00:02:49,920 --> 00:02:54,570
tables and then and and or gates to

00:02:51,840 --> 00:02:57,450
create the memory so instead what you do

00:02:54,570 --> 00:02:58,739
is that we have multiple types of memory

00:02:57,450 --> 00:03:01,110
and there we have something called block

00:02:58,739 --> 00:03:04,709
Rams that multiple read and write ports

00:03:01,110 --> 00:03:06,600
to it as you can get really fast access

00:03:04,709 --> 00:03:08,130
to it we have something called al-karim

00:03:06,600 --> 00:03:10,800
this is a little bit bigger SRAM in

00:03:08,130 --> 00:03:13,260
there and so on so forth right yeah we

00:03:10,800 --> 00:03:15,030
also have hardened DSP blocks they are

00:03:13,260 --> 00:03:18,200
different than the DSP engines we're now

00:03:15,030 --> 00:03:21,570
introducing so these are fixed point

00:03:18,200 --> 00:03:23,579
multiply to emulate store put all over

00:03:21,570 --> 00:03:25,680
the day after day so that you have

00:03:23,579 --> 00:03:27,030
memory you have lookup tables around it

00:03:25,680 --> 00:03:29,010
so you can create this really

00:03:27,030 --> 00:03:32,390
interesting data paths whether it's

00:03:29,010 --> 00:03:35,310
video networking or what-have-you

00:03:32,390 --> 00:03:37,290
so the use cases for this some people

00:03:35,310 --> 00:03:40,530
they use the F it is just as glue logic

00:03:37,290 --> 00:03:42,630
you have a funky bus coming in and you

00:03:40,530 --> 00:03:44,430
need to convert some things into

00:03:42,630 --> 00:03:46,170
something that your CPU can read for

00:03:44,430 --> 00:03:48,090
example so a lot of people are using it

00:03:46,170 --> 00:03:51,030
just for global logic and maybe that's

00:03:48,090 --> 00:03:53,100
some of our smaller parts some people

00:03:51,030 --> 00:03:55,829
are using these two to really do

00:03:53,100 --> 00:03:58,049
massively parallel compute like you have

00:03:55,829 --> 00:03:59,820
an internal signal coming in at the base

00:03:58,049 --> 00:04:01,769
station and you need to do a lot of

00:03:59,820 --> 00:04:04,620
parallel processing on that before you

00:04:01,769 --> 00:04:07,950
can eventually translate tcp/ip packet

00:04:04,620 --> 00:04:12,420
right yeah some people are using our

00:04:07,950 --> 00:04:15,989
really big FPGA is for emulation you're

00:04:12,420 --> 00:04:17,760
designing a new ASIC and affiliation

00:04:15,989 --> 00:04:19,440
really good at a decent clock rates you

00:04:17,760 --> 00:04:21,690
can actually simulate your design and

00:04:19,440 --> 00:04:23,520
these are these really big chips and

00:04:21,690 --> 00:04:25,260
maybe have a bunch of those on the board

00:04:23,520 --> 00:04:25,570
and then a multiple of those ports and

00:04:25,260 --> 00:04:27,850
you can

00:04:25,570 --> 00:04:29,980
simulate a big big system very that at

00:04:27,850 --> 00:04:34,150
you know several hundred megahertz clock

00:04:29,980 --> 00:04:36,130
speed so how do you program this stuff

00:04:34,150 --> 00:04:37,720
well the easiest way for software guy is

00:04:36,130 --> 00:04:39,550
that if someone else already wrote the

00:04:37,720 --> 00:04:41,710
accelerator that you don't use and you

00:04:39,550 --> 00:04:44,110
just use a library but if you're not

00:04:41,710 --> 00:04:46,630
that lucky then either you can go in and

00:04:44,110 --> 00:04:49,060
program in RTL code so over there's this

00:04:46,630 --> 00:04:51,610
hardware design languages like VHDL and

00:04:49,060 --> 00:04:54,370
very long or something that we've been

00:04:51,610 --> 00:04:57,240
bringing out the last few years that at

00:04:54,370 --> 00:04:59,860
higher levels your program in C C++

00:04:57,240 --> 00:05:02,170
OpenCL and then we translate that to

00:04:59,860 --> 00:05:06,070
state machines is basically running in

00:05:02,170 --> 00:05:07,360
the FPGA this is especially powerful for

00:05:06,070 --> 00:05:09,460
things like when you do matrix

00:05:07,360 --> 00:05:11,620
multiplication right if you have a loop

00:05:09,460 --> 00:05:13,810
and then you can unroll that loop so you

00:05:11,620 --> 00:05:16,000
do 100 computation at the same time so

00:05:13,810 --> 00:05:18,490
every clock cycle you do 100 iterations

00:05:16,000 --> 00:05:20,200
of the loop for example right so if you

00:05:18,490 --> 00:05:23,850
write your code in the right way you can

00:05:20,200 --> 00:05:26,950
get a really parallel execution from it

00:05:23,850 --> 00:05:30,540
so that's the everyday it it's really

00:05:26,950 --> 00:05:33,010
fantastic in the sense I can do a lot of

00:05:30,540 --> 00:05:33,940
really specialized things and you can

00:05:33,010 --> 00:05:36,100
change that on the fly

00:05:33,940 --> 00:05:38,950
some people are putting FPGAs in the

00:05:36,100 --> 00:05:40,780
devices just as an insurance policy they

00:05:38,950 --> 00:05:43,720
know that they probably didn't get their

00:05:40,780 --> 00:05:45,820
design 100% correct so they want to be

00:05:43,720 --> 00:05:48,340
able to update that in the field later

00:05:45,820 --> 00:05:49,540
on so that sort of the global logic

00:05:48,340 --> 00:05:55,500
combined whether it's some other

00:05:49,540 --> 00:05:59,950
accelerated capabilities there alright

00:05:55,500 --> 00:06:01,960
so why do we see these heterogeneous

00:05:59,950 --> 00:06:04,150
systems coming up right there I think

00:06:01,960 --> 00:06:06,600
there's two main reasons and this are

00:06:04,150 --> 00:06:09,670
not going to everyone knows this that

00:06:06,600 --> 00:06:12,730
the old idea of using a CPU and then

00:06:09,670 --> 00:06:14,500
every year it will be faster it never

00:06:12,730 --> 00:06:16,780
used lower power and so on so forth

00:06:14,500 --> 00:06:20,440
those days are long gone right we all

00:06:16,780 --> 00:06:22,570
know that so instead we started to do

00:06:20,440 --> 00:06:23,470
multi-core but then we realized that

00:06:22,570 --> 00:06:25,120
it's hard to manage

00:06:23,470 --> 00:06:27,550
you can't just scale and have more and

00:06:25,120 --> 00:06:30,490
more cores of the same type so now

00:06:27,550 --> 00:06:32,590
really the solutions becoming using

00:06:30,490 --> 00:06:36,190
specialized accelerators specialized

00:06:32,590 --> 00:06:37,690
engines for the task at hand so that's

00:06:36,190 --> 00:06:38,380
really efficient from a hardware point

00:06:37,690 --> 00:06:39,940
of view

00:06:38,380 --> 00:06:41,320
but it can scripts up things from a

00:06:39,940 --> 00:06:42,760
software point of view because all these

00:06:41,320 --> 00:06:45,280
are programmed a little bit different

00:06:42,760 --> 00:06:47,590
you have to manage them and a lot of of

00:06:45,280 --> 00:06:48,820
those kind of software issues but we

00:06:47,590 --> 00:06:51,550
really have to go there because the

00:06:48,820 --> 00:06:53,110
workloads are continuing to go up

00:06:51,550 --> 00:06:55,540
especially now when you have things like

00:06:53,110 --> 00:06:58,240
machine learning which is really compute

00:06:55,540 --> 00:06:59,860
intensive so that's one one of the

00:06:58,240 --> 00:07:03,460
reasons another reason it's really more

00:06:59,860 --> 00:07:05,910
about integration so so the device is

00:07:03,460 --> 00:07:08,500
out there this is an industrial device

00:07:05,910 --> 00:07:11,170
maybe it used to be separate different

00:07:08,500 --> 00:07:12,610
boards maybe have one PLC board doing

00:07:11,170 --> 00:07:14,800
sort of running or app if you will

00:07:12,610 --> 00:07:19,030
connect into the server or nowadays to

00:07:14,800 --> 00:07:22,600
the cloud and you have maybe a control

00:07:19,030 --> 00:07:24,250
card in this case controlling a motor so

00:07:22,600 --> 00:07:26,800
that needs to be real-time something

00:07:24,250 --> 00:07:28,810
happens with motor and you need to get

00:07:26,800 --> 00:07:30,670
those signals back and react really

00:07:28,810 --> 00:07:32,200
really quickly so you can't have your

00:07:30,670 --> 00:07:33,100
processor suddenly wrong and do

00:07:32,200 --> 00:07:34,420
something else

00:07:33,100 --> 00:07:37,450
you need to be on top of things so

00:07:34,420 --> 00:07:39,580
that's that's the the short latency and

00:07:37,450 --> 00:07:41,380
deterministic behavior that you need

00:07:39,580 --> 00:07:44,050
from those kind of systems you might

00:07:41,380 --> 00:07:47,950
have another board that had handles

00:07:44,050 --> 00:07:49,390
safety issues a lot of safety issues are

00:07:47,950 --> 00:07:52,960
coming in lots of different industries

00:07:49,390 --> 00:07:55,090
opinion industrial automotive of course

00:07:52,960 --> 00:07:57,970
it's coming with two six two six two

00:07:55,090 --> 00:07:59,770
standard and safe this all about how do

00:07:57,970 --> 00:08:01,150
you protect the world from from the

00:07:59,770 --> 00:08:03,760
device you know you don't want to have

00:08:01,150 --> 00:08:05,350
code that solid doesn't work anymore so

00:08:03,760 --> 00:08:08,740
your brakes is not working for example

00:08:05,350 --> 00:08:11,020
and that's very expensive code it takes

00:08:08,740 --> 00:08:13,300
a lot of money to save the certified

00:08:11,020 --> 00:08:15,070
system so you don't necessarily want to

00:08:13,300 --> 00:08:17,550
have all your code safety certified

00:08:15,070 --> 00:08:19,360
because it's it gets way too expensive

00:08:17,550 --> 00:08:21,670
all right so now we have these three

00:08:19,360 --> 00:08:23,890
boards you want to save money you want

00:08:21,670 --> 00:08:25,750
to save power you put it all in one SOC

00:08:23,890 --> 00:08:27,630
but you still need to have this

00:08:25,750 --> 00:08:32,640
separation between general-purpose

00:08:27,630 --> 00:08:35,320
real-time and safety create some issues

00:08:32,640 --> 00:08:37,090
so if we look at one of the current

00:08:35,320 --> 00:08:39,940
devices that we're going you to use this

00:08:37,090 --> 00:08:44,470
as an example going forward so this is

00:08:39,940 --> 00:08:46,420
the distinct MP so it has for a 53 s so

00:08:44,470 --> 00:08:48,490
that's the ApS application processing

00:08:46,420 --> 00:08:52,210
unit we have

00:08:48,490 --> 00:08:53,950
to cortex or fives again typically

00:08:52,210 --> 00:08:57,760
people use that for safety or real-time

00:08:53,950 --> 00:08:59,950
and so on we have a platform manager

00:08:57,760 --> 00:09:03,640
that's a hard and microblaze that's a

00:08:59,950 --> 00:09:05,230
CPU coming from micro from tilings we

00:09:03,640 --> 00:09:07,420
have the programmable logic the FPGA

00:09:05,230 --> 00:09:09,880
fabric so there you can put in what we

00:09:07,420 --> 00:09:13,330
call soft course so we have this micro

00:09:09,880 --> 00:09:16,510
blaze now also from arm we have a cortex

00:09:13,330 --> 00:09:19,930
M 1 and M 3 course so there's a soft

00:09:16,510 --> 00:09:21,400
course so you can put in many tens or

00:09:19,930 --> 00:09:24,760
hundreds depending on the size of the

00:09:21,400 --> 00:09:27,990
device of those in there as well you

00:09:24,760 --> 00:09:27,990
have all these different environments

00:09:28,290 --> 00:09:33,610
you get first of all all the

00:09:31,540 --> 00:09:36,160
environments for each and every one of

00:09:33,610 --> 00:09:37,930
these course but then also some of the

00:09:36,160 --> 00:09:40,360
course they have different execution

00:09:37,930 --> 00:09:43,630
levels so take 350 trees for example

00:09:40,360 --> 00:09:46,000
they have l0 where you run your user

00:09:43,630 --> 00:09:48,130
application typically you have the yield

00:09:46,000 --> 00:09:50,110
one where you have Linux and the kernels

00:09:48,130 --> 00:09:52,540
you have the hypervisor if you have one

00:09:50,110 --> 00:09:54,790
that's at the l2 and your three there

00:09:52,540 --> 00:09:57,840
you have the firmware and on top of that

00:09:54,790 --> 00:10:01,600
you also have the trusted environment

00:09:57,840 --> 00:10:03,670
trust zone actually might have a trusted

00:10:01,600 --> 00:10:05,380
execution environment there of T or

00:10:03,670 --> 00:10:07,360
something like that so you have all

00:10:05,380 --> 00:10:09,220
these different environments where

00:10:07,360 --> 00:10:11,140
you're going to write your code you

00:10:09,220 --> 00:10:13,240
don't necessarily know where the code

00:10:11,140 --> 00:10:14,770
will end up so how do you write code

00:10:13,240 --> 00:10:18,160
that you can then put in all these

00:10:14,770 --> 00:10:19,990
different places so that that gets kind

00:10:18,160 --> 00:10:23,710
of tricky especially since the operating

00:10:19,990 --> 00:10:25,420
environment is different Linux these

00:10:23,710 --> 00:10:27,880
days I would say 80% of our customers

00:10:25,420 --> 00:10:31,630
are more than that are using Linux

00:10:27,880 --> 00:10:32,860
typically on the on the a course but

00:10:31,630 --> 00:10:35,980
then they have companion operating

00:10:32,860 --> 00:10:38,170
systems or bare metal and those are open

00:10:35,980 --> 00:10:41,170
source like free or toasts or or safer

00:10:38,170 --> 00:10:42,940
but very often proprietary vendors there

00:10:41,170 --> 00:10:47,440
are lots of them out there from Wind

00:10:42,940 --> 00:10:52,060
River and green hills and so on so forth

00:10:47,440 --> 00:10:53,800
so again in that ecosystem we have to

00:10:52,060 --> 00:10:56,860
make it easier for people to be able to

00:10:53,800 --> 00:11:01,000
put these things together to write code

00:10:56,860 --> 00:11:02,080
once to configure these things so how

00:11:01,000 --> 00:11:04,480
can we simplify this

00:11:02,080 --> 00:11:06,070
instead of the ad-hoc having a shared

00:11:04,480 --> 00:11:07,690
memory and we all come up with our own

00:11:06,070 --> 00:11:10,120
way it's kind of fun to write that code

00:11:07,690 --> 00:11:12,490
right in the processor interrupt and

00:11:10,120 --> 00:11:14,350
initiate page or something like that but

00:11:12,490 --> 00:11:17,260
why should everyone have to do that over

00:11:14,350 --> 00:11:18,850
and over again so the things that that

00:11:17,260 --> 00:11:20,800
you have to tackle an or how do you

00:11:18,850 --> 00:11:22,540
configure these systems how much of the

00:11:20,800 --> 00:11:24,070
physical memory goes to this core in

00:11:22,540 --> 00:11:27,100
this environment versus this which

00:11:24,070 --> 00:11:29,580
device hangs to Linux versus to free

00:11:27,100 --> 00:11:35,050
autos for example right how do you

00:11:29,580 --> 00:11:36,490
lifecycle manage this how do you if you

00:11:35,050 --> 00:11:38,620
want to start up something a new

00:11:36,490 --> 00:11:40,450
application on another core and maybe

00:11:38,620 --> 00:11:42,070
it's crashes you'd want to be able to

00:11:40,450 --> 00:11:44,350
detect that you want to be able to

00:11:42,070 --> 00:11:46,420
restart that to do that you actually

00:11:44,350 --> 00:11:48,760
have to know what devices belongs there

00:11:46,420 --> 00:11:50,230
you have to idle those buses you have to

00:11:48,760 --> 00:11:52,540
maybe reset the devices there a lot of

00:11:50,230 --> 00:11:55,330
things that needs to happen why should

00:11:52,540 --> 00:11:57,970
that be ad hoc for for every device from

00:11:55,330 --> 00:12:00,160
silence or if it's from other silicon

00:11:57,970 --> 00:12:03,730
vendors as well right how do you share

00:12:00,160 --> 00:12:06,370
resources to have a graphical card or a

00:12:03,730 --> 00:12:08,590
GPU and maybe Linux is is dealing with

00:12:06,370 --> 00:12:09,730
that but you do want to do some graphics

00:12:08,590 --> 00:12:13,510
from from vxworks

00:12:09,730 --> 00:12:15,580
how do you do that how for all these

00:12:13,510 --> 00:12:17,440
different operating systems how can we

00:12:15,580 --> 00:12:19,660
make it easier for them to port in all

00:12:17,440 --> 00:12:21,040
these different environments from all

00:12:19,660 --> 00:12:23,860
these different vendors

00:12:21,040 --> 00:12:28,060
yeah so we have created something we

00:12:23,860 --> 00:12:33,670
call open amp to try to solve some of

00:12:28,060 --> 00:12:35,920
the of these of these problems so the

00:12:33,670 --> 00:12:39,880
open amp initiative something we started

00:12:35,920 --> 00:12:41,830
about four years ago and we're really

00:12:39,880 --> 00:12:43,960
trying to drive standards through open

00:12:41,830 --> 00:12:48,100
source we find that that's the fastest

00:12:43,960 --> 00:12:51,910
way to to get synergy is to have example

00:12:48,100 --> 00:12:53,880
code out there right so it's really all

00:12:51,910 --> 00:12:57,190
about EMPs as a symmetric

00:12:53,880 --> 00:13:00,190
multiprocessing we are both looking at

00:12:57,190 --> 00:13:01,900
the standardization and just using a

00:13:00,190 --> 00:13:03,850
term barrier in the liberal way here

00:13:01,900 --> 00:13:06,100
because we're not really writing big

00:13:03,850 --> 00:13:09,460
standard specs we're more documenting

00:13:06,100 --> 00:13:11,770
the protocols of reusing like what I owe

00:13:09,460 --> 00:13:13,270
what different flags means what and so

00:13:11,770 --> 00:13:14,980
on so let me know that we're backwards

00:13:13,270 --> 00:13:18,760
and forwards compatible

00:13:14,980 --> 00:13:20,070
we add new features right so open amp

00:13:18,760 --> 00:13:22,750
and then we have a cleanroom

00:13:20,070 --> 00:13:24,550
implementation of things that's already

00:13:22,750 --> 00:13:27,790
existing in open source things like

00:13:24,550 --> 00:13:29,560
remote i/o remote proc or P message so

00:13:27,790 --> 00:13:32,110
those are existing in the Linux kernel

00:13:29,560 --> 00:13:33,699
you can't just take that code first of

00:13:32,110 --> 00:13:35,800
all it's entangled with the rest of of

00:13:33,699 --> 00:13:39,180
Linux a little bit but also you can take

00:13:35,800 --> 00:13:42,070
that GPL code and put into a VxWorks or

00:13:39,180 --> 00:13:44,620
Makram or toss so we have written this

00:13:42,070 --> 00:13:46,420
cleanroom implementation of those and

00:13:44,620 --> 00:13:48,610
that also means that instead of always

00:13:46,420 --> 00:13:50,529
having Linux as the master we now can

00:13:48,610 --> 00:13:53,470
have a small Otto's as the master

00:13:50,529 --> 00:13:55,959
storing up Linux or you can have 2mc use

00:13:53,470 --> 00:13:56,500
running orthosis and not have Linux at

00:13:55,959 --> 00:13:59,170
all

00:13:56,500 --> 00:14:01,180
soken amp'd currently doing these things

00:13:59,170 --> 00:14:03,010
to lifecycle messaging and these things

00:14:01,180 --> 00:14:06,639
we have a low level abstraction layer

00:14:03,010 --> 00:14:09,010
that obstructs like memory and in the

00:14:06,639 --> 00:14:11,110
process interrupts and things like that

00:14:09,010 --> 00:14:12,610
to make it easier to port your your

00:14:11,110 --> 00:14:16,449
operating systems on the different

00:14:12,610 --> 00:14:18,970
environments in the group right now a

00:14:16,449 --> 00:14:23,889
bunch of companies or sales I links we

00:14:18,970 --> 00:14:26,680
have t.i we have SD micro we have Mentor

00:14:23,889 --> 00:14:28,660
embedded Qualcomm Wind River micro mr.

00:14:26,680 --> 00:14:31,360
Wan this bunch of people some people are

00:14:28,660 --> 00:14:32,680
actively contributing code as you should

00:14:31,360 --> 00:14:34,959
with open source projects and a lot more

00:14:32,680 --> 00:14:37,089
people are using it and there's a bunch

00:14:34,959 --> 00:14:40,240
of companies using it they're not active

00:14:37,089 --> 00:14:42,339
in there in the discussions as well yeah

00:14:40,240 --> 00:14:45,819
so this is something that that we are

00:14:42,339 --> 00:14:48,430
working actively something we're just

00:14:45,819 --> 00:14:50,350
starting to talk about is trying to

00:14:48,430 --> 00:14:52,510
attack the configuration issue how do

00:14:50,350 --> 00:14:54,880
you configure as I mentioned what memory

00:14:52,510 --> 00:14:57,579
goes where so that's a new concept that

00:14:54,880 --> 00:14:59,079
we call system device trees that we just

00:14:57,579 --> 00:15:02,740
started so this is just more

00:14:59,079 --> 00:15:05,079
informational and the the question here

00:15:02,740 --> 00:15:08,199
is that you have a bunch of hardware

00:15:05,079 --> 00:15:10,360
that describes the SOC and the board and

00:15:08,199 --> 00:15:12,399
then you have this different domains

00:15:10,360 --> 00:15:14,709
yeah maybe Linux domain maybe have a

00:15:12,399 --> 00:15:18,569
trusted environment maybe have an or

00:15:14,709 --> 00:15:22,000
toast or somehow we need to communicate

00:15:18,569 --> 00:15:23,439
the memory hierarchies the buses which

00:15:22,000 --> 00:15:26,319
physical memory goes here and there

00:15:23,439 --> 00:15:28,110
which devices goes where right silence

00:15:26,319 --> 00:15:30,480
our hardware engineers they

00:15:28,110 --> 00:15:33,779
like everything to be really really

00:15:30,480 --> 00:15:36,990
programmable so you can reprogram a lot

00:15:33,779 --> 00:15:38,790
of different things like a device where

00:15:36,990 --> 00:15:41,519
where will it hang on will the tank to

00:15:38,790 --> 00:15:43,440
the or fives or to something else but we

00:15:41,519 --> 00:15:46,339
need to specify those things in our

00:15:43,440 --> 00:15:49,860
programmable logic we can add new neat

00:15:46,339 --> 00:15:52,560
network interfaces a lot of new things

00:15:49,860 --> 00:15:53,790
there we have to express those things so

00:15:52,560 --> 00:15:56,040
you choose to express it with device

00:15:53,790 --> 00:15:57,990
trees but we need to expand device trees

00:15:56,040 --> 00:16:01,050
from just looking at one address space

00:15:57,990 --> 00:16:02,880
to multiple address spaces and their

00:16:01,050 --> 00:16:05,700
mental model of this is that you have a

00:16:02,880 --> 00:16:07,980
description on the whole system you have

00:16:05,700 --> 00:16:09,390
done some input files but saying that

00:16:07,980 --> 00:16:12,870
well for Linux

00:16:09,390 --> 00:16:15,390
I need this address space these CPUs I

00:16:12,870 --> 00:16:18,899
need this much memory I need these

00:16:15,390 --> 00:16:21,329
devices or from the system device tree

00:16:18,899 --> 00:16:24,690
and create a regular standard device

00:16:21,329 --> 00:16:26,519
tree as they exist today for the Linux

00:16:24,690 --> 00:16:28,230
environment do the same for the bare

00:16:26,519 --> 00:16:30,180
metal environment for the free autos

00:16:28,230 --> 00:16:32,310
environment and then we working with our

00:16:30,180 --> 00:16:34,079
partners and internally we are going

00:16:32,310 --> 00:16:36,240
over that we're using device trees for

00:16:34,079 --> 00:16:38,670
our bare metal for all three autos and

00:16:36,240 --> 00:16:40,470
and so on so we're trying to make this a

00:16:38,670 --> 00:16:42,630
little bit of an industry standard which

00:16:40,470 --> 00:16:45,060
it's very early on so we see how we can

00:16:42,630 --> 00:16:47,670
do that if we're successful you can also

00:16:45,060 --> 00:16:49,290
use this to verify later on when you

00:16:47,670 --> 00:16:51,690
integrate all these different parts you

00:16:49,290 --> 00:16:54,120
can verify that the different petitions

00:16:51,690 --> 00:16:55,769
are not using the same memory space for

00:16:54,120 --> 00:16:57,600
example under stay of supposed to do

00:16:55,769 --> 00:16:59,730
because when you have these systems it's

00:16:57,600 --> 00:17:01,829
really easy to screw up and you know

00:16:59,730 --> 00:17:03,690
just get one address a little bit wrong

00:17:01,829 --> 00:17:04,949
and then both systems are going to the

00:17:03,690 --> 00:17:07,429
hammer on the same device for example

00:17:04,949 --> 00:17:07,429
right

00:17:09,909 --> 00:17:14,779
so let's talk about hypervisors so we

00:17:12,739 --> 00:17:17,389
would be talking about this in P systems

00:17:14,779 --> 00:17:19,669
where we have different processor types

00:17:17,389 --> 00:17:21,439
but really a lot of our customers what

00:17:19,669 --> 00:17:24,139
they want to do is - oh you have four

00:17:21,439 --> 00:17:26,269
853 is there I want to have an autozone

00:17:24,139 --> 00:17:28,339
that core and I want to have Linux on

00:17:26,269 --> 00:17:30,559
digit ofcourse and I was the safety

00:17:28,339 --> 00:17:34,190
certified maybe and things on another

00:17:30,559 --> 00:17:36,499
core well it's not that easier ITA 53 is

00:17:34,190 --> 00:17:38,330
a really bit more for an SMP system of

00:17:36,499 --> 00:17:41,570
course you can have a hypervisor on top

00:17:38,330 --> 00:17:42,190
of it so the use case is very very

00:17:41,570 --> 00:17:45,409
similar

00:17:42,190 --> 00:17:48,049
you typically pin the open system to a

00:17:45,409 --> 00:17:49,700
particular core so that's fine you can

00:17:48,049 --> 00:17:52,100
use open amp and the things that we have

00:17:49,700 --> 00:17:54,830
ported open amp to them so you can use

00:17:52,100 --> 00:17:57,230
that for for the messaging things like

00:17:54,830 --> 00:17:58,909
that in the future as we developed the

00:17:57,230 --> 00:18:00,950
system device trees that's perfect to

00:17:58,909 --> 00:18:03,859
use for hypervisors as well to allocate

00:18:00,950 --> 00:18:06,019
devices to the different partitions and

00:18:03,859 --> 00:18:09,980
the different domains in indocin speak

00:18:06,019 --> 00:18:12,499
there's one issue here which on the a53

00:18:09,980 --> 00:18:15,909
and AC empty tubes and those kind of

00:18:12,499 --> 00:18:19,639
cortex a-class processors is that the

00:18:15,909 --> 00:18:21,559
the level 2 cache is shared so that

00:18:19,639 --> 00:18:24,009
means that if you have something that's

00:18:21,559 --> 00:18:27,619
very time critical you have a real-time

00:18:24,009 --> 00:18:29,450
partition that really needs to have a

00:18:27,619 --> 00:18:31,399
deterministic response time for

00:18:29,450 --> 00:18:33,139
something well then you have Linux

00:18:31,399 --> 00:18:37,070
running over here maybe Linux is doing

00:18:33,139 --> 00:18:39,739
some mem copy the big blocks but that

00:18:37,070 --> 00:18:41,450
will learn impact your real-time

00:18:39,739 --> 00:18:43,940
petition because the level 2 cache

00:18:41,450 --> 00:18:45,619
unless you can run from internal memory

00:18:43,940 --> 00:18:48,019
and very often you can do that we have

00:18:45,619 --> 00:18:49,789
several types of on chip memories and

00:18:48,019 --> 00:18:52,489
things of that or if you run within the

00:18:49,789 --> 00:18:53,690
level 1 cache then you're fine but if

00:18:52,489 --> 00:18:55,340
you have a little bit of a bigger

00:18:53,690 --> 00:18:57,739
application then you have a problem it's

00:18:55,340 --> 00:18:59,299
not deterministic anymore so we'll be

00:18:57,739 --> 00:19:02,929
working together with some partners on a

00:18:59,299 --> 00:19:04,100
solution called cache coloring so not

00:19:02,929 --> 00:19:06,259
coming into the details of cache

00:19:04,100 --> 00:19:08,600
coloring but at the very high level what

00:19:06,259 --> 00:19:10,460
you're doing is that since the physical

00:19:08,600 --> 00:19:13,340
memory each address is mapped to a

00:19:10,460 --> 00:19:15,649
particular cache line so you can imagine

00:19:13,340 --> 00:19:17,929
looking at your memory in these blocks

00:19:15,649 --> 00:19:20,509
let's put code called colors of them

00:19:17,929 --> 00:19:22,700
that's repeating all over but let's say

00:19:20,509 --> 00:19:26,269
that we allocate

00:19:22,700 --> 00:19:28,460
to the autos petition physical memory

00:19:26,269 --> 00:19:30,830
that corresponds to one of these colors

00:19:28,460 --> 00:19:32,869
that say green and then we make sure

00:19:30,830 --> 00:19:36,249
that when we allocates the physical

00:19:32,869 --> 00:19:38,690
memory to Linux we avoid the green ports

00:19:36,249 --> 00:19:41,659
then we know that Linux is not going to

00:19:38,690 --> 00:19:43,159
hit those cache lines so that's what

00:19:41,659 --> 00:19:46,039
cache coloring at the very high level

00:19:43,159 --> 00:19:49,429
you can look it up in and it's kind of

00:19:46,039 --> 00:19:51,340
interesting so we have been implementing

00:19:49,429 --> 00:19:53,690
that in a hypervisor

00:19:51,340 --> 00:19:55,879
the first one we implemented this is in

00:19:53,690 --> 00:19:58,220
the jailhouse hypervisor been working

00:19:55,879 --> 00:20:00,320
with the University of Modena to do this

00:19:58,220 --> 00:20:02,119
and the result is really really

00:20:00,320 --> 00:20:04,580
encouraging so you can pretty much do

00:20:02,119 --> 00:20:07,279
whatever you want on these other cores

00:20:04,580 --> 00:20:09,169
running Linux and so on and the

00:20:07,279 --> 00:20:11,989
real-time response time is very

00:20:09,169 --> 00:20:14,690
deterministic on the core where you need

00:20:11,989 --> 00:20:16,909
that using cache covering a little bit

00:20:14,690 --> 00:20:19,249
of a kludge and hopefully in future arm

00:20:16,909 --> 00:20:21,080
course you have better ways of doing

00:20:19,249 --> 00:20:23,119
that with impairment and things like

00:20:21,080 --> 00:20:24,830
that but we live in a really pragmatic

00:20:23,119 --> 00:20:29,929
world to help to fix these kind of

00:20:24,830 --> 00:20:31,609
issues right okay so we've been talking

00:20:29,929 --> 00:20:33,409
about this help to deal assistance with

00:20:31,609 --> 00:20:35,359
a lot of compute power you might ask

00:20:33,409 --> 00:20:37,850
well those guys are probably very

00:20:35,359 --> 00:20:41,539
expensive you know can I use them in my

00:20:37,850 --> 00:20:45,230
system well so Avenue to section now

00:20:41,539 --> 00:20:46,999
introducing the ultra 96 version - so

00:20:45,230 --> 00:20:49,789
this is alternate the six board came

00:20:46,999 --> 00:20:52,369
about a year ago I think and this is the

00:20:49,789 --> 00:20:56,840
second version of it second release it's

00:20:52,369 --> 00:20:58,159
a 2 $49 board and it has the same

00:20:56,840 --> 00:20:59,859
process that we've been talking about

00:20:58,159 --> 00:21:02,299
it's really good for things like

00:20:59,859 --> 00:21:05,179
artificial intelligence embedded video

00:21:02,299 --> 00:21:08,210
those kind of things all right and it

00:21:05,179 --> 00:21:10,820
also is designed to be of the 96 port

00:21:08,210 --> 00:21:13,759
form factor and that means that the 96

00:21:10,820 --> 00:21:15,759
board code will run on it as well so you

00:21:13,759 --> 00:21:18,649
got that ecosystem over here as well

00:21:15,759 --> 00:21:21,649
yeah so that's going to be released in

00:21:18,649 --> 00:21:23,359
May and with that you get the board you

00:21:21,649 --> 00:21:26,119
get an SD card but you also get the

00:21:23,359 --> 00:21:28,999
license to our what we call the SD SOC

00:21:26,119 --> 00:21:32,059
tools where you can write your code in C

00:21:28,999 --> 00:21:34,220
C++ and it will translate that not only

00:21:32,059 --> 00:21:36,590
translate the code and put that into the

00:21:34,220 --> 00:21:39,440
FPGA but the rest of the code

00:21:36,590 --> 00:21:41,750
we'll do all the glue in between so you

00:21:39,440 --> 00:21:44,330
just call AC function and then we'll

00:21:41,750 --> 00:21:46,130
take over take care about the DMA

00:21:44,330 --> 00:21:49,460
transfers and all that stuff back and

00:21:46,130 --> 00:21:52,190
forth so that that will be available may

00:21:49,460 --> 00:21:56,330
the outer 96 first version is available

00:21:52,190 --> 00:22:01,010
today of course all right so we're

00:21:56,330 --> 00:22:04,039
talking about SOC home heterogeneous

00:22:01,010 --> 00:22:07,130
systems within one chip what about if

00:22:04,039 --> 00:22:11,000
you have multi chip solutions so what's

00:22:07,130 --> 00:22:12,289
the situation there and if the clicker

00:22:11,000 --> 00:22:14,510
works there we go

00:22:12,289 --> 00:22:17,149
so typically what you do then is that

00:22:14,510 --> 00:22:20,720
you have some kind of CPU cluster you

00:22:17,149 --> 00:22:23,539
talk over a bus like PCIe over to an

00:22:20,720 --> 00:22:25,730
accelerator right and that's well known

00:22:23,539 --> 00:22:29,390
way of doing things been working for for

00:22:25,730 --> 00:22:30,830
quite some time the programming paradigm

00:22:29,390 --> 00:22:33,289
there is really that you write the

00:22:30,830 --> 00:22:34,850
driver you set up some dmas you copy

00:22:33,289 --> 00:22:36,440
your data back and forth they have the

00:22:34,850 --> 00:22:39,200
accelerator working on it and get the

00:22:36,440 --> 00:22:40,909
data back and so on so the question is

00:22:39,200 --> 00:22:45,260
can we make this a little bit more

00:22:40,909 --> 00:22:47,630
similar to to this heterogeneous SOC

00:22:45,260 --> 00:22:49,940
course that we've been looking at before

00:22:47,630 --> 00:22:52,220
right and why would you do that well

00:22:49,940 --> 00:22:55,159
it's really because the accelerators are

00:22:52,220 --> 00:22:57,559
becoming much more more more smart they

00:22:55,159 --> 00:23:00,590
you want to program in a different way

00:22:57,559 --> 00:23:03,529
you want to have a shared memory for

00:23:00,590 --> 00:23:05,360
many use cases where the CPUs they

00:23:03,529 --> 00:23:07,460
populate the data there and then we can

00:23:05,360 --> 00:23:09,730
have an accelerator in parallel maybe

00:23:07,460 --> 00:23:12,620
doing search on that data or or

00:23:09,730 --> 00:23:15,860
manipulating smart memory whatever you

00:23:12,620 --> 00:23:18,799
have so suddenly you get this need for a

00:23:15,860 --> 00:23:20,360
Numa kind of like on memory so maybe the

00:23:18,799 --> 00:23:21,919
the access times are a little bit

00:23:20,360 --> 00:23:24,590
different but it should really look like

00:23:21,919 --> 00:23:27,350
one cache coherent memory block for the

00:23:24,590 --> 00:23:29,090
for the software on both sides then the

00:23:27,350 --> 00:23:32,299
programming model becomes much much

00:23:29,090 --> 00:23:35,240
easier so this is really what c6 is all

00:23:32,299 --> 00:23:38,630
about as it's really virtualized cache

00:23:35,240 --> 00:23:40,760
coherent accelerators it's based on top

00:23:38,630 --> 00:23:43,179
of the PCIe standards of things like

00:23:40,760 --> 00:23:46,610
discovery and all those things are

00:23:43,179 --> 00:23:48,620
compatible with that but you don't need

00:23:46,610 --> 00:23:49,250
to have the drivers to you program it

00:23:48,620 --> 00:23:54,110
more

00:23:49,250 --> 00:23:55,520
you do with with a more coupled system

00:23:54,110 --> 00:23:57,370
where where you have shared memory in

00:23:55,520 --> 00:24:03,830
between it which for a lot of use cases

00:23:57,370 --> 00:24:05,900
really really helps out all right so the

00:24:03,830 --> 00:24:08,900
c6 consortium I think this slide is a

00:24:05,900 --> 00:24:10,700
little bit dated it was 50 member I

00:24:08,900 --> 00:24:12,140
think it's more than 50 members now but

00:24:10,700 --> 00:24:14,600
it's really big consortium and the first

00:24:12,140 --> 00:24:16,760
devices coming out this year on the

00:24:14,600 --> 00:24:18,620
hardware side lots of people that then

00:24:16,760 --> 00:24:22,250
are supporting software stacks on top of

00:24:18,620 --> 00:24:24,590
it so this is really a new exciting way

00:24:22,250 --> 00:24:26,360
of doing accelerators they're connected

00:24:24,590 --> 00:24:28,640
to something else and the nice thing is

00:24:26,360 --> 00:24:31,159
that with the c6 standard you can also

00:24:28,640 --> 00:24:33,169
use so they have multiple dies that are

00:24:31,159 --> 00:24:37,190
connected really closely together and

00:24:33,169 --> 00:24:38,059
create those kind of systems as well all

00:24:37,190 --> 00:24:42,350
right

00:24:38,059 --> 00:24:43,909
that was my last slide time for a couple

00:24:42,350 --> 00:24:45,980
of questions sorry I think that we do

00:24:43,909 --> 00:24:48,280
anyone I think that was really

00:24:45,980 --> 00:24:51,380
fascinating and a great explanation

00:24:48,280 --> 00:24:55,130
for open EMP and also c6 anyone have a

00:24:51,380 --> 00:24:56,830
question there was a lot there know

00:24:55,130 --> 00:25:00,679
where everyone is

00:24:56,830 --> 00:25:02,690
mmm rinse coffee exactly alright so

00:25:00,679 --> 00:25:03,830
Tomas thank you so much for joining us

00:25:02,690 --> 00:25:06,190
and sharing that with us today we really

00:25:03,830 --> 00:25:09,490
appreciate it

00:25:06,190 --> 00:25:09,490

YouTube URL: https://www.youtube.com/watch?v=_N_YZCIxQY8


