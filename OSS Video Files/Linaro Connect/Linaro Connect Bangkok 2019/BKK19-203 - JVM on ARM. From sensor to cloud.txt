Title: BKK19-203 - JVM on ARM. From sensor to cloud
Publication date: 2019-04-03
Playlist: Linaro Connect Bangkok 2019
Description: 
	Abstract
A variety of Java virtual machines on ARM have been around for a long time. Nowadays, OpenJDK makes it easy and secure to receive and process data at all stages. Using modern expressive language Kotlin and Docker containers, we will program a simple, but secure gateway that controls a sensor. Well demonstrate further data processing in the cloud as BigData and then visualization for end user using JavaFX. We will discuss additional features such as deployment and provisioning and also how the new release model of the Java platform is connected to security.

Dmitry Chuyko / Performance Architect BellSoft
Dmitry Chuyko is a performance engineer at BellSoft, which is among the top 5 contributors to OpenJDK. Before joining BellSoft, Dmitry programmed in Java, and then worked on Hotspot JVM in Oracle. After all, previous experience with Java has shown that the most interesting problems in applications get their solutions in the base platform. Currently Dmitry mostly optimizes OpenJDK for ARM64, the company even implemented its own JEP 315 on Java 11 on this topic.
BellSoft releases and supports Liberica JDK -- a verified distribution of OpenJDK. Liberica is available in the form of binary assemblies, installers and container images for different operating systems and processors. Therefore, now the focus of attention is the work of various versions of Java in containers on ARM and x86.
Captions: 
	00:00:05,450 --> 00:00:13,290
admitted to occur

00:00:07,120 --> 00:00:18,360
well soft and we participate in armed

00:00:13,290 --> 00:00:22,540
Java work and we release our own jello

00:00:18,360 --> 00:00:26,230
so I'm the part of this work our Joe is

00:00:22,540 --> 00:00:30,340
a TCK verified open JDK binary which is

00:00:26,230 --> 00:00:33,850
called Liberec a JDK and basically the

00:00:30,340 --> 00:00:38,760
company is quite young but we have

00:00:33,850 --> 00:00:42,039
strong background in this space and

00:00:38,760 --> 00:00:46,629
still like latest statistics for the

00:00:42,039 --> 00:00:48,309
decay 12 Oracle dominates in

00:00:46,629 --> 00:00:50,920
contributions but still there are other

00:00:48,309 --> 00:00:55,449
companies like us like top 500 price

00:00:50,920 --> 00:01:00,969
contributors so what's about Java

00:00:55,449 --> 00:01:05,260
I think the Java is still good for any

00:01:00,969 --> 00:01:07,810
kind of application and it is widely

00:01:05,260 --> 00:01:12,130
used it's one of most popular languages

00:01:07,810 --> 00:01:18,010
and most popular platforms we have and

00:01:12,130 --> 00:01:23,800
it's good for both edge and cloud and

00:01:18,010 --> 00:01:27,450
has a wide of a very long history of

00:01:23,800 --> 00:01:30,660
what people do thief Java and nowadays

00:01:27,450 --> 00:01:35,520
there are interesting changes going on

00:01:30,660 --> 00:01:40,260
like there's a new release schedule and

00:01:35,520 --> 00:01:44,400
all work in open JDK space goes

00:01:40,260 --> 00:01:47,800
according to the schedule so we now have

00:01:44,400 --> 00:01:51,760
quite often the releases every six

00:01:47,800 --> 00:01:54,240
months some of them may be called

00:01:51,760 --> 00:01:57,100
long-term supported but still Oracle

00:01:54,240 --> 00:02:00,460
continues to develop only new releases

00:01:57,100 --> 00:02:03,400
and there is new licensing model where

00:02:00,460 --> 00:02:05,920
you cannot use Oracle Java in production

00:02:03,400 --> 00:02:08,769
for free you have to buy commercial

00:02:05,920 --> 00:02:11,769
support and you won't get free security

00:02:08,769 --> 00:02:16,410
updates we have to choose some binary

00:02:11,769 --> 00:02:19,020
provider but it's not

00:02:16,410 --> 00:02:24,590
you can get everything for free for long

00:02:19,020 --> 00:02:24,590
term you just need to think about that

00:02:24,860 --> 00:02:30,720
so what's good about Java also is that

00:02:28,020 --> 00:02:34,860
everything is specified and Java Virtual

00:02:30,720 --> 00:02:37,050
Machine there are multiple

00:02:34,860 --> 00:02:40,290
implementations according to the single

00:02:37,050 --> 00:02:42,720
same specification so you can use

00:02:40,290 --> 00:02:47,280
different virtual machine to the same

00:02:42,720 --> 00:02:49,050
byte code also Java language is a

00:02:47,280 --> 00:02:51,720
separate specification and you can use

00:02:49,050 --> 00:02:53,780
any other language that you'll be able

00:02:51,720 --> 00:03:01,709
to compiled to bytecode

00:02:53,780 --> 00:03:09,890
for your JVM and a very strong side of

00:03:01,709 --> 00:03:13,890
Java is security because you can control

00:03:09,890 --> 00:03:18,120
what permissions your code actually

00:03:13,890 --> 00:03:20,250
requires or that might be not your codes

00:03:18,120 --> 00:03:23,910
on third-party code but you still

00:03:20,250 --> 00:03:27,840
control it and you can use platform api

00:03:23,910 --> 00:03:31,130
s-- for security and authentication for

00:03:27,840 --> 00:03:35,220
a possible security so that's great for

00:03:31,130 --> 00:03:39,600
cryptography and of course we have echo

00:03:35,220 --> 00:03:44,310
system so javelin armed I will be

00:03:39,600 --> 00:03:47,910
specifically looking at open JDK is a

00:03:44,310 --> 00:03:51,440
very cool thing the history is not as

00:03:47,910 --> 00:03:58,920
long as excited 6 but still it's great

00:03:51,440 --> 00:04:03,239
we have the important topic here which

00:03:58,920 --> 00:04:06,000
is well it's easy to find a binary for

00:04:03,239 --> 00:04:08,610
x86 but it may be a bit much Iike to

00:04:06,000 --> 00:04:13,230
find a binary for arm or both server and

00:04:08,610 --> 00:04:14,880
embedded but it's possible and the

00:04:13,230 --> 00:04:17,660
second question here is where they get

00:04:14,880 --> 00:04:17,660
security updates

00:04:19,570 --> 00:04:25,150
you can use the barricade JDK of course

00:04:22,770 --> 00:04:27,970
you can get all the binders in different

00:04:25,150 --> 00:04:31,420
platforms both server and embedded if

00:04:27,970 --> 00:04:34,360
you use I assume that you use Linux

00:04:31,420 --> 00:04:37,030
because you're going to use Java here

00:04:34,360 --> 00:04:40,450
and well you can just download the

00:04:37,030 --> 00:04:44,800
binary or you can install it using your

00:04:40,450 --> 00:04:48,910
favorite package manager one of two or

00:04:44,800 --> 00:04:53,320
you can use docker container even on the

00:04:48,910 --> 00:04:59,530
embedded device there are also things

00:04:53,320 --> 00:05:01,710
like sdk man and possibly others expect

00:04:59,530 --> 00:05:01,710
it

00:05:02,100 --> 00:05:13,810
so what's what are extras there are some

00:05:06,250 --> 00:05:17,260
extras in embedded space for RM 32 there

00:05:13,810 --> 00:05:21,400
is a bundled device i/o library that

00:05:17,260 --> 00:05:26,080
allows you to work with sensors madam's

00:05:21,400 --> 00:05:28,690
and all the things and there's GUI

00:05:26,080 --> 00:05:32,560
library code open jfx which is basically

00:05:28,690 --> 00:05:36,730
an open source version of JavaFX so you

00:05:32,560 --> 00:05:40,210
can easily create gooeys even for not so

00:05:36,730 --> 00:05:43,300
powerful devices you don't need X you

00:05:40,210 --> 00:05:46,240
can just use frame buffer and it will

00:05:43,300 --> 00:05:51,430
work and for the cloud of course

00:05:46,240 --> 00:05:54,100
everything is there like new and not so

00:05:51,430 --> 00:05:58,260
near the garbage collectors JIT

00:05:54,100 --> 00:06:03,220
compilers everything will have channel 4

00:05:58,260 --> 00:06:06,070
so for small devices it's not true that

00:06:03,220 --> 00:06:10,330
Java is tremendously huge you can get

00:06:06,070 --> 00:06:15,690
nice tiny image for your runtime it will

00:06:10,330 --> 00:06:20,740
be like 17 megabytes that's pretty small

00:06:15,690 --> 00:06:22,870
if you include also things like not

00:06:20,740 --> 00:06:27,510
minimal the em but client vm it will be

00:06:22,870 --> 00:06:27,510
around 20 megabytes so it's still small

00:06:28,840 --> 00:06:36,520
for the cloud nowadays

00:06:31,930 --> 00:06:39,970
we'll use some containers most probably

00:06:36,520 --> 00:06:46,389
docker containers and there are based

00:06:39,970 --> 00:06:49,990
images regularly updated for that so you

00:06:46,389 --> 00:06:53,790
can use latest Java updates in your

00:06:49,990 --> 00:06:58,210
cloud very easily to build your own

00:06:53,790 --> 00:07:00,970
doctor images based on that of course

00:06:58,210 --> 00:07:04,240
job is not too unique it's just the

00:07:00,970 --> 00:07:09,060
program so you can run any version of

00:07:04,240 --> 00:07:12,310
Java in the container but since Java 8

00:07:09,060 --> 00:07:16,090
there are well since Java 8 updates and

00:07:12,310 --> 00:07:22,930
9 there are changes that make Java more

00:07:16,090 --> 00:07:26,979
container aware have token this but Java

00:07:22,930 --> 00:07:29,110
now sees all the limitations that I said

00:07:26,979 --> 00:07:33,580
at least most important limitation set

00:07:29,110 --> 00:07:41,440
in the container and Java tools work so

00:07:33,580 --> 00:07:45,190
they are now namespace aware so again

00:07:41,440 --> 00:07:51,300
you can get a pretty small image even in

00:07:45,190 --> 00:07:55,450
the cloud that will have old JIT

00:07:51,300 --> 00:07:59,950
compilers in it maybe I'm not sure about

00:07:55,450 --> 00:08:02,460
growl but probably yes or you can use it

00:07:59,950 --> 00:08:09,820
for development then you get a huge

00:08:02,460 --> 00:08:12,789
binary but still that's your choice and

00:08:09,820 --> 00:08:15,160
of course for both arm platforms

00:08:12,789 --> 00:08:21,850
supported an open JDK we release that

00:08:15,160 --> 00:08:26,490
binaries and that containers so I'm

00:08:21,850 --> 00:08:31,600
going to show small demo using all that

00:08:26,490 --> 00:08:36,959
will get some sensor data it will be

00:08:31,600 --> 00:08:36,959
temperature and all soft slab that was

00:08:37,620 --> 00:08:43,500
switched out yesterday it was funny and

00:08:41,190 --> 00:08:48,360
now it should work

00:08:43,500 --> 00:08:52,260
we'll use sampled gateway it basically

00:08:48,360 --> 00:08:58,980
can be like any device that translates

00:08:52,260 --> 00:09:02,880
and Java I'll use raspy but anyway to

00:08:58,980 --> 00:09:05,190
see the specific health specifications

00:09:02,880 --> 00:09:08,760
work daily use management or that

00:09:05,190 --> 00:09:11,130
gateway the some external system metal

00:09:08,760 --> 00:09:15,240
bieber's persist i will be stream

00:09:11,130 --> 00:09:20,490
streaming that data from gateway to

00:09:15,240 --> 00:09:23,480
cloud and then from cloud to some device

00:09:20,490 --> 00:09:27,500
that is basically a kiosk of the data

00:09:23,480 --> 00:09:32,130
from the data from cloud that may be

00:09:27,500 --> 00:09:39,420
processed and changed anything version

00:09:32,130 --> 00:09:43,950
of the original data in all that stages

00:09:39,420 --> 00:09:53,360
of course there is open JDK particularly

00:09:43,950 --> 00:09:56,690
the very key JDK so what we'll have for

00:09:53,360 --> 00:09:56,690
the device

00:10:00,959 --> 00:10:09,249
here's a management console and you see

00:10:05,709 --> 00:10:12,879
here's my device deployed the Somoza

00:10:09,249 --> 00:10:15,519
implementation basically modified Apache

00:10:12,879 --> 00:10:22,410
Felix or just Apache farik's with some

00:10:15,519 --> 00:10:28,059
bundles and settings and here are some

00:10:22,410 --> 00:10:31,329
specific bundles I have like Sherratt

00:10:28,059 --> 00:10:34,389
runtime for Cortland language because

00:10:31,329 --> 00:10:37,149
we've JVM you can use more than one

00:10:34,389 --> 00:10:40,209
language as I said and what's

00:10:37,149 --> 00:10:45,309
interesting about cotton is that yeah it

00:10:40,209 --> 00:10:49,679
allows sometimes newer features for

00:10:45,309 --> 00:10:49,679
older runtimes like you can use

00:10:49,709 --> 00:10:58,600
coroutines and some other language

00:10:52,689 --> 00:11:01,449
features on like Java 8 JVM and also you

00:10:58,600 --> 00:11:06,040
can share code between for example your

00:11:01,449 --> 00:11:07,540
real JVM applications in android because

00:11:06,040 --> 00:11:12,569
cotton is now a standard language for

00:11:07,540 --> 00:11:15,370
android development that may be useful

00:11:12,569 --> 00:11:18,249
so you can use basically any cotton

00:11:15,370 --> 00:11:22,179
libraries or almost any and here's the

00:11:18,249 --> 00:11:27,610
second bundle which I created not using

00:11:22,179 --> 00:11:32,850
any like both stuff just using my ID and

00:11:27,610 --> 00:11:32,850
that does actual work so what's inside

00:11:35,820 --> 00:11:44,640
it's a very simple application here's a

00:11:39,300 --> 00:11:49,350
bundle activator that just gets the

00:11:44,640 --> 00:11:51,480
temperature here I get in fact two

00:11:49,350 --> 00:11:55,250
temperatures temperature core and

00:11:51,480 --> 00:12:06,390
temperature from external sensor and

00:11:55,250 --> 00:12:09,630
then I stream that data to Kafka main

00:12:06,390 --> 00:12:12,030
parts of code are also on the slides so

00:12:09,630 --> 00:12:21,560
if you need to study it you can check it

00:12:12,030 --> 00:12:26,010
later so what this get temperature does

00:12:21,560 --> 00:12:28,590
it is a cotton implementation that were

00:12:26,010 --> 00:12:31,260
stiff this sensor it is the actual

00:12:28,590 --> 00:12:35,160
Hardware sensor and we just read three

00:12:31,260 --> 00:12:37,560
registers there so we mix Java in

00:12:35,160 --> 00:12:43,370
Cortland in the same application no

00:12:37,560 --> 00:12:47,220
problem but sometimes it allows us to

00:12:43,370 --> 00:12:50,190
write much less boilerplate here is not

00:12:47,220 --> 00:12:54,800
much but still less like no semicolons

00:12:50,190 --> 00:13:01,530
and things like that and the second

00:12:54,800 --> 00:13:07,170
temperature source is fairly simple so

00:13:01,530 --> 00:13:12,480
what goes next oh so we got the data

00:13:07,170 --> 00:13:14,130
from the sensor they have data sheet we

00:13:12,480 --> 00:13:17,580
have bundle activator we need to string

00:13:14,130 --> 00:13:21,600
this from Kafka to Kafka again will you

00:13:17,580 --> 00:13:24,300
Scotland for this particular purpose so

00:13:21,600 --> 00:13:25,770
we could use my simpler code just to

00:13:24,300 --> 00:13:34,470
read properties from property file

00:13:25,770 --> 00:13:40,040
anyway the Kafka client library is quite

00:13:34,470 --> 00:13:44,310
fat like 2.5 megabytes but you can

00:13:40,040 --> 00:13:46,760
manage relatively complex things very

00:13:44,310 --> 00:13:46,760
simple

00:13:47,570 --> 00:13:56,279
while here we just use properties that

00:13:53,670 --> 00:14:02,970
describe our topic will stream doubles

00:13:56,279 --> 00:14:08,699
and also timestamps we won't be harmful

00:14:02,970 --> 00:14:13,170
for device battery if it uses battery

00:14:08,699 --> 00:14:16,589
like we want do retries things like that

00:14:13,170 --> 00:14:20,220
so any scent will be instant it will

00:14:16,589 --> 00:14:25,230
fail out will succeed and by the way

00:14:20,220 --> 00:14:28,170
here in the activator we use like

00:14:25,230 --> 00:14:32,100
one-second scheduling it will be also

00:14:28,170 --> 00:14:36,329
good old Java internals use OS native

00:14:32,100 --> 00:14:39,930
threads so you just then you sleep to

00:14:36,329 --> 00:14:47,130
you sleep there won't be any hidden

00:14:39,930 --> 00:14:53,370
activity both for user threads for

00:14:47,130 --> 00:14:55,110
application and for Java Runtime what

00:14:53,370 --> 00:14:59,360
else is interesting here is that we

00:14:55,110 --> 00:15:03,410
might configure transport security

00:14:59,360 --> 00:15:06,839
encryption and also client based

00:15:03,410 --> 00:15:09,120
authentication on Kafka so who would

00:15:06,839 --> 00:15:10,139
like to secure such small device it

00:15:09,120 --> 00:15:12,720
could be done easily

00:15:10,139 --> 00:15:16,380
we just need to generate and deploy all

00:15:12,720 --> 00:15:20,459
the key stores and that's it and

00:15:16,380 --> 00:15:24,899
configure it using the properties and on

00:15:20,459 --> 00:15:31,220
broker we can also manage key store the

00:15:24,899 --> 00:15:31,220
keys for devices for these certificates

00:15:33,290 --> 00:15:37,370
so what goes on on Kafka

00:15:38,100 --> 00:15:46,050
here's a an instance cloud instance on

00:15:42,570 --> 00:15:56,580
packet so we probably heard of it

00:15:46,050 --> 00:16:07,460
it's gallium thunder X like let's check

00:15:56,580 --> 00:16:07,460
it like you see

00:16:10,580 --> 00:16:20,649
the Lords of memory and have to docker

00:16:16,760 --> 00:16:27,459
containers very simple Kafka set up if

00:16:20,649 --> 00:16:31,220
zookeeper and Kafka itself it's funny

00:16:27,459 --> 00:16:34,430
they are running for two days but if you

00:16:31,220 --> 00:16:37,310
want to use docker containers want to

00:16:34,430 --> 00:16:40,640
isolate that processes and they will

00:16:37,310 --> 00:16:44,060
fail or fail all the time just a funny

00:16:40,640 --> 00:16:52,339
fact that there may be useful in this

00:16:44,060 --> 00:16:55,940
sense so we've seen the bundle for our

00:16:52,339 --> 00:16:57,860
gateway we've seen the gateway is

00:16:55,940 --> 00:17:03,500
connected to some management system

00:16:57,860 --> 00:17:08,689
using just standards always child our

00:17:03,500 --> 00:17:13,000
data goes to Kafka to two topics let's

00:17:08,689 --> 00:17:16,100
check the topics just that's my machine

00:17:13,000 --> 00:17:18,380
so I can connect remotely from my laptop

00:17:16,100 --> 00:17:20,559
to the same Kafka cluster and see what's

00:17:18,380 --> 00:17:23,419
what's there

00:17:20,559 --> 00:17:27,880
so here are two topics called external

00:17:23,419 --> 00:17:27,880
and internal data values

00:17:33,610 --> 00:17:43,550
and next we're going to process the data

00:17:37,180 --> 00:17:46,150
on some client for that we can use germ

00:17:43,550 --> 00:17:49,430
effects and steal same character clients

00:17:46,150 --> 00:17:52,670
so have Kafka on that Kafka instance we

00:17:49,430 --> 00:17:55,780
might transform the data like make

00:17:52,670 --> 00:18:00,410
producers and consumers that will bounce

00:17:55,780 --> 00:18:01,780
the original data between topics modify

00:18:00,410 --> 00:18:05,300
them anyway

00:18:01,780 --> 00:18:07,310
anything that's is possible there we

00:18:05,300 --> 00:18:11,680
could also do some processing on the

00:18:07,310 --> 00:18:15,710
device like for example we could install

00:18:11,680 --> 00:18:19,490
flink right on the Gateway and process

00:18:15,710 --> 00:18:21,350
reprocess some data there like simple

00:18:19,490 --> 00:18:25,130
thing calculate an average of filtering

00:18:21,350 --> 00:18:29,750
it may be done right on the device also

00:18:25,130 --> 00:18:35,590
then we send data we might not use Kafka

00:18:29,750 --> 00:18:41,500
client we might use just MQTT and then

00:18:35,590 --> 00:18:41,500
MQTT bridge in the cloud for the Kafka

00:18:42,160 --> 00:18:52,160
so for our client application this kiosk

00:18:47,770 --> 00:18:56,840
will also wake up every second get the

00:18:52,160 --> 00:19:03,680
data and display them on the chart so

00:18:56,840 --> 00:19:06,040
here the see some consumer work I'll

00:19:03,680 --> 00:19:06,040
just

00:19:08,890 --> 00:19:20,110
I liked it it's consumer poll and our

00:19:17,170 --> 00:19:28,210
consumer is subscribed to that two

00:19:20,110 --> 00:19:31,570
topics here and we create our scene we

00:19:28,210 --> 00:19:34,470
just subscribe and then they stop we

00:19:31,570 --> 00:19:34,470
unsubscribe of course

00:19:35,340 --> 00:19:42,309
and that's it that's all the code for UI

00:19:37,929 --> 00:19:46,540
and for getting data from Kafka except

00:19:42,309 --> 00:19:52,720
again settings for Kafka which can be

00:19:46,540 --> 00:19:54,910
done separately here again we use same

00:19:52,720 --> 00:19:59,260
description for the topic and we could

00:19:54,910 --> 00:20:04,510
use of course security and in the same

00:19:59,260 --> 00:20:10,830
fashion as for the producer so will it

00:20:04,510 --> 00:20:15,370
work nicely I'll start that on my laptop

00:20:10,830 --> 00:20:17,110
but as well it it shows exactly the same

00:20:15,370 --> 00:20:22,030
screen exactly same result for example

00:20:17,110 --> 00:20:24,960
raspberry and other devices that's there

00:20:22,030 --> 00:20:24,960
is absolutely no difference

00:20:29,790 --> 00:20:37,920
so like for kiosk it could be a full

00:20:32,910 --> 00:20:42,180
screen right no acts required in my case

00:20:37,920 --> 00:20:47,340
it's probably expert on the device it

00:20:42,180 --> 00:20:49,550
might be not so no data right what's

00:20:47,340 --> 00:20:49,550
wrong

00:20:50,030 --> 00:21:04,890
here's a question to you yeah we need to

00:20:59,280 --> 00:21:09,500
start it so my bundle is stopped I can

00:21:04,890 --> 00:21:09,500
just started using that external system

00:21:10,790 --> 00:21:14,450
so what's there

00:21:17,790 --> 00:21:20,780
this is pretty cool

00:21:25,690 --> 00:21:32,870
so get all the charts all the animations

00:21:30,110 --> 00:21:37,000
of Java effects on the device the few

00:21:32,870 --> 00:21:37,000
lines of code that's very cool

00:21:43,630 --> 00:21:50,309
so what we've seen so far it's in device

00:21:47,169 --> 00:21:53,260
management get my code

00:21:50,309 --> 00:21:57,100
Kotlin that might be used both for

00:21:53,260 --> 00:22:00,820
gateway for the kiosk on the server we

00:21:57,100 --> 00:22:08,020
can use same Java libraries and coding

00:22:00,820 --> 00:22:13,990
libraries at all stages of our system we

00:22:08,020 --> 00:22:17,289
used Kafka easily everything was on arm

00:22:13,990 --> 00:22:19,659
except my kiosk demo but it also works

00:22:17,289 --> 00:22:27,400
and arm and shows exactly the same

00:22:19,659 --> 00:22:33,400
screen here's in Java effects sonar

00:22:27,400 --> 00:22:36,940
conclusions at Gateway at the client in

00:22:33,400 --> 00:22:43,740
the cloud it all was Liberec a JDK 11

00:22:36,940 --> 00:22:47,169
latest version so it's not like embedded

00:22:43,740 --> 00:22:50,770
applications for Java stopped at times

00:22:47,169 --> 00:22:55,440
of Java 8 now it's still possible to get

00:22:50,770 --> 00:22:58,539
the binary the latest security updates

00:22:55,440 --> 00:23:00,429
and if you get the binary from us you

00:22:58,539 --> 00:23:02,530
can redistribute it you can get it for

00:23:00,429 --> 00:23:07,659
free and you can also get commercial

00:23:02,530 --> 00:23:14,799
support which will provide like 24/7

00:23:07,659 --> 00:23:18,760
support that's it alright so everything

00:23:14,799 --> 00:23:20,789
works with arm and Java and data passes

00:23:18,760 --> 00:23:23,909
from sensor to cloud and back to kiosk

00:23:20,789 --> 00:23:23,909
thank you

00:23:24,650 --> 00:23:33,210
[Applause]

00:23:26,870 --> 00:23:38,460
that's all shows the size of Java and

00:23:33,210 --> 00:23:42,300
cloud for JDK 8 and JDK 11 so the size

00:23:38,460 --> 00:23:47,820
was 3 times more all right yeah a good

00:23:42,300 --> 00:23:51,560
question so here are containers for JDK

00:23:47,820 --> 00:23:56,280
8 and JDK 11 it's not the complete table

00:23:51,560 --> 00:24:00,380
if you like change 11 to 8 numbers will

00:23:56,280 --> 00:24:04,320
be close so it's JRE and JDK

00:24:00,380 --> 00:24:08,520
so yeah that's full JDK and for ya and

00:24:04,320 --> 00:24:10,680
for John 11 there's no more Jerry but

00:24:08,520 --> 00:24:13,910
there are there is an option to get

00:24:10,680 --> 00:24:17,700
slimmer runtime and slimmer container

00:24:13,910 --> 00:24:21,240
then you just build container so you get

00:24:17,700 --> 00:24:25,140
the base image and then build and it may

00:24:21,240 --> 00:24:28,380
be not small and rigidity 8 you don't

00:24:25,140 --> 00:24:30,870
have modules so modules we have module

00:24:28,380 --> 00:24:33,000
since JDK 9 and of course we have

00:24:30,870 --> 00:24:37,200
Angelica 11 and that allows us to

00:24:33,000 --> 00:24:43,410
produce such a small runtime even

00:24:37,200 --> 00:24:44,480
smaller than JDK 6 heinous so any more

00:24:43,410 --> 00:24:47,730
questions

00:24:44,480 --> 00:24:57,800
so the Kafka and zookeeper were running

00:24:47,730 --> 00:24:57,800
on Packard yeah thank you

00:24:58,460 --> 00:25:01,499

YouTube URL: https://www.youtube.com/watch?v=hTX_vJT6bDQ


