Title: BKK19-TR04 - Fantastic tracepoints and where to find them
Publication date: 2019-04-11
Playlist: Linaro Connect Bangkok 2019
Description: 
	Abstract
"I could talk to you all day kernel debugging. Really! In fact I, along with my colleague Leo, have spent are large portion of our time recently doing exactly that. However I dont have all day... I have just 25 minutes... and no slides."

In this session Daniel will demonstrate live a some of the ways to exploit both static and dynamic tracepoints to study kernel behaviour. Well start out using just the basic tools available in even tiny busybox distribution before expanding our toolkit very slightly by copying a couple of extra binaries onto the system under debug.

Daniel Thompson / Tech Lead - Support and Solutions Engineering Linaro
Currently working at Linaro where I am tech lead for the Support and Solutions Engineering team. This team provides a mixture of technical support (for developers), training and custom engineering services to Linaro members and our professional services customers. As part of my work at Linaro I have become a co-maintainer of the Linux kernel kgdb/kdb and backlight sub-systems. I am also heavily involved in the 96Boards activities at Linaro.
Captions: 
	00:00:05,450 --> 00:00:11,270
so the idea today is to not explain any

00:00:09,020 --> 00:00:14,150
of the theory behind how the stuff is

00:00:11,270 --> 00:00:16,640
working just what you can do with the

00:00:14,150 --> 00:00:19,520
trace points and how you might used to

00:00:16,640 --> 00:00:22,850
do them and we're going to focus

00:00:19,520 --> 00:00:26,210
primarily on having no tools meaning

00:00:22,850 --> 00:00:28,970
I've got LS I've got cat I've got less I

00:00:26,210 --> 00:00:30,320
haven't got high value tools which what

00:00:28,970 --> 00:00:31,279
I means is that everything I'm showing

00:00:30,320 --> 00:00:33,860
in the beginning part of the

00:00:31,279 --> 00:00:36,320
presentation will work in busybox toybox

00:00:33,860 --> 00:00:40,550
the smallest builder you can summon or

00:00:36,320 --> 00:00:43,370
on an Android system I'm going to start

00:00:40,550 --> 00:00:44,809
off by showing just a reminder for

00:00:43,370 --> 00:00:46,970
people if they are not familiar with it

00:00:44,809 --> 00:00:49,280
of the F tray system itself we're not

00:00:46,970 --> 00:00:50,540
going to talk about trace much but just

00:00:49,280 --> 00:00:52,729
to give you an example of what's

00:00:50,540 --> 00:00:55,549
happening in the tracing directory so we

00:00:52,729 --> 00:00:56,930
have a tracing directory here I'll draw

00:00:55,549 --> 00:00:58,729
your attention to the readme so there's

00:00:56,930 --> 00:01:01,070
about three key things you should

00:00:58,729 --> 00:01:03,290
remember when you go home one of them is

00:01:01,070 --> 00:01:05,780
the inside the tracing directory and

00:01:03,290 --> 00:01:09,320
debug if s is a file called readme which

00:01:05,780 --> 00:01:11,119
tells you how to use F trace so even on

00:01:09,320 --> 00:01:12,740
your Android system on its own you've

00:01:11,119 --> 00:01:14,299
even got enough of a manual to remember

00:01:12,740 --> 00:01:18,170
how to do the tracing without going to

00:01:14,299 --> 00:01:20,060
anywhere else and just as an example if

00:01:18,170 --> 00:01:21,740
people haven't seen it before we can

00:01:20,060 --> 00:01:23,869
sort of go to function and put it into

00:01:21,740 --> 00:01:26,000
current tracer and that will set the

00:01:23,869 --> 00:01:27,530
function tracer running and if I look in

00:01:26,000 --> 00:01:29,810
the trace file I can see tremendous

00:01:27,530 --> 00:01:34,280
output a lot of it is making my screen

00:01:29,810 --> 00:01:35,840
update in front of me that's the sort of

00:01:34,280 --> 00:01:37,640
quick idea that you can see I'm just

00:01:35,840 --> 00:01:40,130
echoing to and from files to turn things

00:01:37,640 --> 00:01:42,340
on and off and that's actually what

00:01:40,130 --> 00:01:45,259
we're going to do for F trace I was in a

00:01:42,340 --> 00:01:47,060
presentation with Stephen Rosa late last

00:01:45,259 --> 00:01:49,219
year where he called F trace boring

00:01:47,060 --> 00:01:52,009
because we've all seen it before

00:01:49,219 --> 00:01:53,210
and so while it is awesome if you

00:01:52,009 --> 00:01:57,649
haven't seen it before then please

00:01:53,210 --> 00:02:01,369
please find a way to play with it we can

00:01:57,649 --> 00:02:04,520
also turn tracing on off by sorry has to

00:02:01,369 --> 00:02:05,420
be an echo echoing zero to it and the

00:02:04,520 --> 00:02:06,469
other thing I was pointing out that I

00:02:05,420 --> 00:02:08,330
was reading from a file called trace

00:02:06,469 --> 00:02:10,100
before and reading from trace is

00:02:08,330 --> 00:02:11,930
non-destructive in the sense that if I

00:02:10,100 --> 00:02:13,220
keep reading from it I can keep seeing

00:02:11,930 --> 00:02:15,560
the same data over and over again

00:02:13,220 --> 00:02:17,480
there's also trace pipe which will

00:02:15,560 --> 00:02:19,010
consume the data as we look at it and

00:02:17,480 --> 00:02:21,110
for the rest of presentation

00:02:19,010 --> 00:02:22,790
I will be doing working with trace pipe

00:02:21,110 --> 00:02:24,980
and once it's finished updating my

00:02:22,790 --> 00:02:27,430
screen that will stop moving always know

00:02:24,980 --> 00:02:30,200
because I'm doing the tracer off here um

00:02:27,430 --> 00:02:32,150
and the final thing I'm gonna say as

00:02:30,200 --> 00:02:34,360
part of the kind of setup is that I am

00:02:32,150 --> 00:02:36,530
gonna put myself in a little macro

00:02:34,360 --> 00:02:38,780
because whenever you're doing a live

00:02:36,530 --> 00:02:40,760
demo with F trace you will turn

00:02:38,780 --> 00:02:43,040
something on and then forget that you've

00:02:40,760 --> 00:02:46,160
turned it on and then everything will go

00:02:43,040 --> 00:02:47,420
off the rails so I'm just going to debug

00:02:46,160 --> 00:02:48,920
directory in my macros and make sure

00:02:47,420 --> 00:02:51,739
even if run or directory it will still

00:02:48,920 --> 00:02:55,910
work I'm going to turn the tracer off

00:02:51,739 --> 00:02:58,129
while I do some work on it and I'm gonna

00:02:55,910 --> 00:03:00,470
then reset everything to kind of factory

00:02:58,129 --> 00:03:06,769
defaults which means setting the current

00:03:00,470 --> 00:03:10,910
tracer to no up I can turn off any

00:03:06,769 --> 00:03:12,170
events that are enabled so I will turn

00:03:10,910 --> 00:03:13,400
on events as we go through the tracing

00:03:12,170 --> 00:03:16,489
system that will turn them all off again

00:03:13,400 --> 00:03:18,140
in one big hit if I've got anything

00:03:16,489 --> 00:03:22,040
dynamic so I'm gonna clear anything

00:03:18,140 --> 00:03:23,720
dynamic of course make a spelling error

00:03:22,040 --> 00:03:24,859
here will look rather bad and now I'm

00:03:23,720 --> 00:03:29,840
gonna turn tracing back on because

00:03:24,859 --> 00:03:31,069
tracing is a he's off by default and

00:03:29,840 --> 00:03:33,139
then finally I'm going to clear out the

00:03:31,069 --> 00:03:34,819
trace buffer so it's not underway now

00:03:33,139 --> 00:03:37,819
when I took trace reset any point in

00:03:34,819 --> 00:03:39,049
roughly speaking with a few corners that

00:03:37,819 --> 00:03:40,700
I've cut to make that quicker for me to

00:03:39,049 --> 00:03:45,349
type that's going to take me back to a

00:03:40,700 --> 00:03:47,269
factory kind of default positions so

00:03:45,349 --> 00:03:50,180
fantastic trace points are my to find

00:03:47,269 --> 00:03:51,590
them the second take home and if I was

00:03:50,180 --> 00:03:54,200
running late the entire rest of the

00:03:51,590 --> 00:03:58,609
presentation if necessary is find event

00:03:54,200 --> 00:04:00,049
type D that is the set of fantastic

00:03:58,609 --> 00:04:01,459
static trace points in the kernel and

00:04:00,049 --> 00:04:02,599
exactly where to find them we're just

00:04:01,459 --> 00:04:04,549
looking in the events directory and

00:04:02,599 --> 00:04:05,959
looking for directories on this

00:04:04,549 --> 00:04:09,620
particular machine I think I've got

00:04:05,959 --> 00:04:11,480
about in the order of sort of sixteen

00:04:09,620 --> 00:04:14,769
hundred trace points my Intel laptop

00:04:11,480 --> 00:04:16,639
over there has closer to two thousand

00:04:14,769 --> 00:04:18,199
but that's because I'm running a slot II

00:04:16,639 --> 00:04:19,729
cut down kernel I'm on this machine to

00:04:18,199 --> 00:04:22,910
make it easy for me to build it

00:04:19,729 --> 00:04:24,500
frequently so you could all go home at

00:04:22,910 --> 00:04:29,150
this point but I have got a few more

00:04:24,500 --> 00:04:30,860
things to show if you're interested so

00:04:29,150 --> 00:04:32,510
I've had to try and pick examples that

00:04:30,860 --> 00:04:34,910
you will find intuitive

00:04:32,510 --> 00:04:36,740
so when I say these are fantastic trace

00:04:34,910 --> 00:04:37,940
points they are but they have been

00:04:36,740 --> 00:04:39,410
selected because they're ones that you

00:04:37,940 --> 00:04:40,760
ought to find fairly intuitive about

00:04:39,410 --> 00:04:42,500
what's happening on my machine as we

00:04:40,760 --> 00:04:44,150
look at them so I haven't gone deep into

00:04:42,500 --> 00:04:45,530
the bowels of the scheduler and other

00:04:44,150 --> 00:04:47,060
things that you can look at if your

00:04:45,530 --> 00:04:48,830
parent in you are interested in what's

00:04:47,060 --> 00:04:51,140
going on I've put things that should be

00:04:48,830 --> 00:04:54,200
intuitive so the first one I'm looking

00:04:51,140 --> 00:04:56,900
at is reg map so reg map is a register

00:04:54,200 --> 00:05:00,260
abstraction API and every time you

00:04:56,900 --> 00:05:03,950
access a register through the reg map in

00:05:00,260 --> 00:05:05,510
directions you get log messages so on

00:05:03,950 --> 00:05:06,770
this particular laptop the reason I've

00:05:05,510 --> 00:05:08,000
picked it is because it has some

00:05:06,770 --> 00:05:10,940
interesting things happening in the reg

00:05:08,000 --> 00:05:13,070
map it's more common in the arm world to

00:05:10,940 --> 00:05:16,220
be using web map because the drivers

00:05:13,070 --> 00:05:17,690
over to me a bit newer so in this

00:05:16,220 --> 00:05:21,460
particular thing I have these devices

00:05:17,690 --> 00:05:23,510
which are hooked up to you reg map I

00:05:21,460 --> 00:05:24,620
believe they particularly marry Mac

00:05:23,510 --> 00:05:28,660
because it allows you to get to the P

00:05:24,620 --> 00:05:32,810
Mick with a nice clean interface and

00:05:28,660 --> 00:05:34,910
there are files all over the events

00:05:32,810 --> 00:05:37,610
directory to turn things on in mass so

00:05:34,910 --> 00:05:39,590
if I go to the reg map folder enable in

00:05:37,610 --> 00:05:40,940
there then every reg map trace point

00:05:39,590 --> 00:05:42,920
will just have been turned on in one

00:05:40,940 --> 00:05:45,080
shot I want to look at trace pipe I'll

00:05:42,920 --> 00:05:47,630
start to see lots of readings coming in

00:05:45,080 --> 00:05:50,980
as my thermal sensors are read my

00:05:47,630 --> 00:05:53,060
battery levels read and other things

00:05:50,980 --> 00:05:54,970
however it's going to be busy I can't

00:05:53,060 --> 00:05:57,800
read it to every well so to try and

00:05:54,970 --> 00:05:59,240
reduce the volume just a little bit I'm

00:05:57,800 --> 00:06:02,330
going to do a kind of globbed

00:05:59,240 --> 00:06:05,510
match so they only get thermal sensors I

00:06:02,330 --> 00:06:07,070
don't get any only any other noise and I

00:06:05,510 --> 00:06:09,980
can write that into the reg Maps filter

00:06:07,070 --> 00:06:12,440
and then similarly all the register maps

00:06:09,980 --> 00:06:13,870
if they have a name property we'll be

00:06:12,440 --> 00:06:16,250
using it to filter out some of my

00:06:13,870 --> 00:06:19,300
details I can look at my trace pipe and

00:06:16,250 --> 00:06:21,560
now I can only see thermal information

00:06:19,300 --> 00:06:24,290
possibly I'm only looking at a single

00:06:21,560 --> 00:06:26,650
thing so I can tidy up some more I can

00:06:24,290 --> 00:06:28,910
put the address of the particular

00:06:26,650 --> 00:06:29,960
especially then it's a name but since

00:06:28,910 --> 00:06:32,260
the name is derived from the address

00:06:29,960 --> 00:06:34,670
that's the same thing and I can even

00:06:32,260 --> 00:06:40,850
track down by register as well I could

00:06:34,670 --> 00:06:44,090
say I'm only caring about the XE

00:06:40,850 --> 00:06:46,010
register and again I can now look at my

00:06:44,090 --> 00:06:48,260
trace pipe and now I'm getting just

00:06:46,010 --> 00:06:49,940
the single register access happening

00:06:48,260 --> 00:06:53,420
each time I can see the value coming

00:06:49,940 --> 00:06:55,310
back so I can use that to digest the

00:06:53,420 --> 00:06:56,900
filtering and prevent myself drowning

00:06:55,310 --> 00:07:01,190
information of course you can use grep

00:06:56,900 --> 00:07:02,780
to do these things as well but that's

00:07:01,190 --> 00:07:06,890
one of the the techniques as we can use

00:07:02,780 --> 00:07:08,210
to filter things so that's all we gonna

00:07:06,890 --> 00:07:10,310
do one that one reg map but that was a

00:07:08,210 --> 00:07:12,140
nice quick easy introduction we're gonna

00:07:10,310 --> 00:07:16,010
amp things up very slightly by looking

00:07:12,140 --> 00:07:19,160
at I to see now anybody doesn't know

00:07:16,010 --> 00:07:21,260
that a modern laptop the keyboard the

00:07:19,160 --> 00:07:24,350
mouse touchscreen will all be hooked up

00:07:21,260 --> 00:07:26,060
by ITC so you get loads of lovely i2c

00:07:24,350 --> 00:07:28,130
activity on machines like this which

00:07:26,060 --> 00:07:30,770
again makes it easy for you to intuit to

00:07:28,130 --> 00:07:33,260
what I'm doing so I can go in I can turn

00:07:30,770 --> 00:07:34,970
on the ITC logging so I actually see

00:07:33,260 --> 00:07:37,100
place points again I'm doing it on mass

00:07:34,970 --> 00:07:38,690
I could go into each individual

00:07:37,100 --> 00:07:42,230
directory and turn on only ones I'm

00:07:38,690 --> 00:07:43,550
interested in but if you're starting

00:07:42,230 --> 00:07:45,560
with the trace points you tend to put

00:07:43,550 --> 00:07:47,600
the whole set on look what you see in

00:07:45,560 --> 00:07:50,090
the logs and then start refining things

00:07:47,600 --> 00:07:52,340
based on what you're kind of getting

00:07:50,090 --> 00:07:57,200
used to what you need to know so what we

00:07:52,340 --> 00:07:59,930
see on this one okay obviously on this

00:07:57,200 --> 00:08:01,640
one is there for some reason something

00:07:59,930 --> 00:08:04,220
is hammering away all the time on this

00:08:01,640 --> 00:08:05,510
particular ITC device what I learned to

00:08:04,220 --> 00:08:07,160
my Intel laptop is that it has a

00:08:05,510 --> 00:08:08,780
capacitive sensor I never knew ahead

00:08:07,160 --> 00:08:10,910
because every time I touch my hands on

00:08:08,780 --> 00:08:12,560
the deck there was an ITC messages and

00:08:10,910 --> 00:08:13,910
not even when they go away again and I

00:08:12,560 --> 00:08:15,110
didn't even know had that feature and I

00:08:13,910 --> 00:08:15,800
still don't know how to exploit it for

00:08:15,110 --> 00:08:17,900
anything useful

00:08:15,800 --> 00:08:21,050
I suspect it's for thumb rejection but

00:08:17,900 --> 00:08:22,640
it doesn't reject with um everywhere but

00:08:21,050 --> 00:08:24,110
I can I can type the keyboard and we see

00:08:22,640 --> 00:08:25,970
an increase in activity so we know that

00:08:24,110 --> 00:08:27,830
whatever it is is polling it's polling

00:08:25,970 --> 00:08:28,940
ITC really hard and I think that's

00:08:27,830 --> 00:08:30,200
because there's actually fingerprint

00:08:28,940 --> 00:08:32,120
sensors and other things attached to the

00:08:30,200 --> 00:08:34,340
keyboard on this device I can waggle my

00:08:32,120 --> 00:08:36,229
trackpad I can waggle my I can touch my

00:08:34,340 --> 00:08:38,330
touchscreen if I keep away from the

00:08:36,229 --> 00:08:40,070
screen you can see these things come and

00:08:38,330 --> 00:08:42,229
go and I can trace on them

00:08:40,070 --> 00:08:44,600
and just as before if I want to look at

00:08:42,229 --> 00:08:47,900
a particular adapter number now in this

00:08:44,600 --> 00:08:49,940
case ITC 11 I'm not quite sure how to

00:08:47,900 --> 00:08:52,070
filter on that so if I want to make my

00:08:49,940 --> 00:08:55,910
life a little bit easier I can look at

00:08:52,070 --> 00:08:58,670
events ITC and I'm going to look at the

00:08:55,910 --> 00:08:59,390
ITC reply which is where we get the data

00:08:58,670 --> 00:09:01,010
from

00:08:59,390 --> 00:09:02,450
the we've just written the key but

00:09:01,010 --> 00:09:04,100
that's where the thing actually puts out

00:09:02,450 --> 00:09:06,410
the hex tub or the packet we've just

00:09:04,100 --> 00:09:10,370
received and I'm gonna find out what the

00:09:06,410 --> 00:09:12,530
format of the trace point is so this

00:09:10,370 --> 00:09:13,790
allows me to the panache of caps Arabic

00:09:12,530 --> 00:09:16,730
deferment it's allows me to look at the

00:09:13,790 --> 00:09:18,680
format of the trace point and I can see

00:09:16,730 --> 00:09:20,540
that I've got some parameters the top

00:09:18,680 --> 00:09:22,460
four called common something are all

00:09:20,540 --> 00:09:24,410
common to all trace points and then

00:09:22,460 --> 00:09:26,210
we've got arguments that specific to

00:09:24,410 --> 00:09:28,940
trace points so I can filter by adapter

00:09:26,210 --> 00:09:31,070
number I can filter by the ITC address

00:09:28,940 --> 00:09:32,630
I'm reading from in principle I can even

00:09:31,070 --> 00:09:34,730
filter by the data if I knew that the

00:09:32,630 --> 00:09:36,830
data was a particular form but this is

00:09:34,730 --> 00:09:38,570
how we can improve is when I just

00:09:36,830 --> 00:09:40,520
assumed it was reg because the print

00:09:38,570 --> 00:09:42,320
form I made it look like it was reg in

00:09:40,520 --> 00:09:43,550
this case the trace pipe doesn't make

00:09:42,320 --> 00:09:44,870
obvious of what all the parameters are

00:09:43,550 --> 00:09:46,610
called biking and looking up in the

00:09:44,870 --> 00:09:48,850
format and I can start filtering as I

00:09:46,610 --> 00:09:48,850
see fit

00:09:50,950 --> 00:09:56,660
Vicki buns in place there we go but I'm

00:09:55,460 --> 00:09:58,610
particular interesting is I saw that

00:09:56,660 --> 00:10:01,280
adapter 11 doing loads and loads of

00:09:58,610 --> 00:10:05,960
stuff and I'm curious as to why it's so

00:10:01,280 --> 00:10:07,970
busy so let's have a look at things a

00:10:05,960 --> 00:10:10,400
bit more deeply so I'm gonna try putting

00:10:07,970 --> 00:10:15,290
a stack trace which is focus of trigger

00:10:10,400 --> 00:10:18,830
that you can attach to trace points if

00:10:15,290 --> 00:10:20,570
you put the stack trace filter trigger

00:10:18,830 --> 00:10:22,730
on to the events so I'm going to I to

00:10:20,570 --> 00:10:24,020
CITC read which is the start of an ITC

00:10:22,730 --> 00:10:26,330
transaction I'm going to set it up as

00:10:24,020 --> 00:10:29,510
the trigger and now when I look at my

00:10:26,330 --> 00:10:31,160
trace pipe I will be getting the stack

00:10:29,510 --> 00:10:33,170
trace of where this thing originated

00:10:31,160 --> 00:10:34,520
from which is really great if I want to

00:10:33,170 --> 00:10:36,050
find out why it's hammering away I'm in

00:10:34,520 --> 00:10:37,970
this case it's clearly hammering away

00:10:36,050 --> 00:10:38,960
because I'm getting continual interrupts

00:10:37,970 --> 00:10:40,760
from the board so there's nothing in the

00:10:38,960 --> 00:10:41,930
software that we're doing wrong it is

00:10:40,760 --> 00:10:43,130
just hammering away because it's

00:10:41,930 --> 00:10:47,450
constantly getting bombarded by

00:10:43,130 --> 00:10:49,100
something from the keyboard so I want to

00:10:47,450 --> 00:10:51,230
be even deeper I can change the trigger

00:10:49,100 --> 00:10:54,260
system so I can remove the stack trace

00:10:51,230 --> 00:10:55,490
trigger we have the shriek in front and

00:10:54,260 --> 00:10:58,250
I can try looking at something called a

00:10:55,490 --> 00:10:59,720
histogram which is where we start

00:10:58,250 --> 00:11:02,150
gathering statistics about the trace

00:10:59,720 --> 00:11:04,100
event and you can control the keys that

00:11:02,150 --> 00:11:09,050
happening so I can say I want my keys to

00:11:04,100 --> 00:11:11,000
be the stack trace so if I get it will

00:11:09,050 --> 00:11:12,529
organize things by stack trace and I'd

00:11:11,000 --> 00:11:14,300
also like you to organize it by

00:11:12,529 --> 00:11:16,009
to number so that if we get different

00:11:14,300 --> 00:11:18,110
stack traces or activity on different

00:11:16,009 --> 00:11:25,370
adapters it will gather it all up into

00:11:18,110 --> 00:11:31,100
the histogram and weird over there thank

00:11:25,370 --> 00:11:33,129
you I'm from Devlin's we like the RS

00:11:31,100 --> 00:11:36,139
down in Devon

00:11:33,129 --> 00:11:37,999
so that doesn't go into trace buffer the

00:11:36,139 --> 00:11:40,160
triggers are actually going to cause the

00:11:37,999 --> 00:11:44,420
histogram to accumulate these triggers

00:11:40,160 --> 00:11:47,240
inside the ITC read directory where the

00:11:44,420 --> 00:11:49,069
histogram can be observed and if ever

00:11:47,240 --> 00:11:50,600
watched as you probably won't have watch

00:11:49,069 --> 00:11:52,220
if you're on a busy box system but watch

00:11:50,600 --> 00:11:53,930
allows me to observe the output of the

00:11:52,220 --> 00:11:55,819
system I've been very careful while I

00:11:53,930 --> 00:11:57,319
was talking to you not to touch the

00:11:55,819 --> 00:11:59,449
touch parts of my laptop so at the

00:11:57,319 --> 00:12:00,649
moment we're just seeing the data coming

00:11:59,449 --> 00:12:03,079
off the keyboard for whatever reason

00:12:00,649 --> 00:12:04,220
that is when I touch my trackpad as soon

00:12:03,079 --> 00:12:06,350
as watch updates the screen we can see

00:12:04,220 --> 00:12:07,879
the second stack trace and if I was

00:12:06,350 --> 00:12:10,160
really patient or you were really

00:12:07,879 --> 00:12:11,990
inattentive I could also wait for it to

00:12:10,160 --> 00:12:14,149
pull my battery but that I think only

00:12:11,990 --> 00:12:15,170
does that every couple of minutes so you

00:12:14,149 --> 00:12:16,339
would also see and that's the point

00:12:15,170 --> 00:12:17,600
where you see a different stack trace

00:12:16,339 --> 00:12:19,430
because the stack trace is going to the

00:12:17,600 --> 00:12:22,790
battery is very very it's about three

00:12:19,430 --> 00:12:24,079
times longer than these guys this is a

00:12:22,790 --> 00:12:26,029
great way to start singing solar system

00:12:24,079 --> 00:12:27,920
the histogram in particular is a

00:12:26,029 --> 00:12:29,149
fantastic way to start understanding why

00:12:27,920 --> 00:12:34,610
choice points have happened to

00:12:29,149 --> 00:12:37,189
particular moments so I kind of the

00:12:34,610 --> 00:12:40,550
third secret of fantastic trace points

00:12:37,189 --> 00:12:42,439
is that that are you aren't stuck with

00:12:40,550 --> 00:12:45,350
just the trace points that you started

00:12:42,439 --> 00:12:46,939
out with you also have access to dynamic

00:12:45,350 --> 00:12:48,860
trace points what could be attached

00:12:46,939 --> 00:12:51,829
almost anywhere in the kernel I say

00:12:48,860 --> 00:12:53,540
almost because the infrastructure needed

00:12:51,829 --> 00:12:56,059
to protein you to handle a trace point

00:12:53,540 --> 00:12:58,069
would re trigger the trace point so if

00:12:56,059 --> 00:12:59,600
you try and put traces on the tray

00:12:58,069 --> 00:13:01,069
system itself there was actually

00:12:59,600 --> 00:13:03,439
mechanisms to prevent that because it

00:13:01,069 --> 00:13:06,500
would just dive into its own circular

00:13:03,439 --> 00:13:08,480
recursive loop but other than that we

00:13:06,500 --> 00:13:10,759
have the capacity to attach these probes

00:13:08,480 --> 00:13:13,040
to more or less anywhere in the system

00:13:10,759 --> 00:13:15,230
and we'll start off by relying on the

00:13:13,040 --> 00:13:17,389
kernels own resources so I'm only using

00:13:15,230 --> 00:13:19,939
kale Sims at present to figure out what

00:13:17,389 --> 00:13:21,890
I'm doing and I'm still sticking to my

00:13:19,939 --> 00:13:24,110
my shell tools

00:13:21,890 --> 00:13:27,019
so I'm going to create a trace point to

00:13:24,110 --> 00:13:29,180
called the FS read and I'm going to

00:13:27,019 --> 00:13:30,950
attach it to a function called VFS to

00:13:29,180 --> 00:13:31,880
read I've removed the underscores at the

00:13:30,950 --> 00:13:34,070
beginning because I didn't like that

00:13:31,880 --> 00:13:40,790
very much and that will simply put a

00:13:34,070 --> 00:13:44,990
trace point upon a crepe trace point and

00:13:40,790 --> 00:13:47,260
apply it and it's created in a disabled

00:13:44,990 --> 00:13:47,260
to date

00:13:47,320 --> 00:13:53,540
so I have to go into events Kay probes

00:13:51,019 --> 00:13:55,670
and I can label all the K probes all one

00:13:53,540 --> 00:13:57,649
of them in one shot which I've now done

00:13:55,670 --> 00:14:00,589
and when I look at the trace pipe I'll

00:13:57,649 --> 00:14:02,209
start to see the FS read activity

00:14:00,589 --> 00:14:04,160
starting to come out as you would

00:14:02,209 --> 00:14:05,630
probably predict it is the cat that he's

00:14:04,160 --> 00:14:07,250
doing most of the read so I'm still

00:14:05,630 --> 00:14:09,560
simulating this with my own read of

00:14:07,250 --> 00:14:12,019
trace pipe there are ways you can filter

00:14:09,560 --> 00:14:12,769
out the activity that you're not

00:14:12,019 --> 00:14:13,579
interested in that you're

00:14:12,769 --> 00:14:15,290
self-stimulating

00:14:13,579 --> 00:14:17,440
but I've done this deliberately again

00:14:15,290 --> 00:14:20,000
I've picked the FS read because you can

00:14:17,440 --> 00:14:23,899
intuit what's happening when I type in

00:14:20,000 --> 00:14:25,850
what's happening inside these on this is

00:14:23,899 --> 00:14:28,550
not that exciting because I was also

00:14:25,850 --> 00:14:32,510
able to probe the observe my VFS reads

00:14:28,550 --> 00:14:35,860
with F trace already but I can also

00:14:32,510 --> 00:14:41,149
stick read probes on which I should do

00:14:35,860 --> 00:14:43,579
so I'm going to observe the vet Val and

00:14:41,149 --> 00:14:46,310
there's this special dollars thing to do

00:14:43,579 --> 00:14:47,720
pre can to particular activities you can

00:14:46,310 --> 00:14:50,060
actually put snap traces in this as well

00:14:47,720 --> 00:14:52,070
with the dollars and I'm going to pend

00:14:50,060 --> 00:14:53,329
it to K probe events and what appending

00:14:52,070 --> 00:14:55,100
to cape of events means it means I'm

00:14:53,329 --> 00:14:56,899
going to add it without removing the old

00:14:55,100 --> 00:14:58,339
one so you can either overwrite K probe

00:14:56,899 --> 00:15:00,620
events which removes all the dynamic

00:14:58,339 --> 00:15:02,300
traces in one shot or you can append

00:15:00,620 --> 00:15:04,610
which means my old trace point will

00:15:02,300 --> 00:15:06,920
continue to exist and I can see the new

00:15:04,610 --> 00:15:08,779
one as well so again I have to enable it

00:15:06,920 --> 00:15:10,579
and again when i trace part now i will

00:15:08,779 --> 00:15:12,500
now see twice as much activity because I

00:15:10,579 --> 00:15:16,699
can now see every time we return and

00:15:12,500 --> 00:15:18,320
what argument was returned at this part

00:15:16,699 --> 00:15:20,440
I'm going to disable all my events again

00:15:18,320 --> 00:15:23,300
because actually I'll do it wrong first

00:15:20,440 --> 00:15:27,320
so I found that the VFS read was rather

00:15:23,300 --> 00:15:28,699
unsatisfying because I can only see that

00:15:27,320 --> 00:15:30,290
it's being called I can't see it's doing

00:15:28,699 --> 00:15:32,839
anything so I'm going to try and do some

00:15:30,290 --> 00:15:35,030
machine level activity to find out a bit

00:15:32,839 --> 00:15:36,980
more about it so

00:15:35,030 --> 00:15:41,270
I'll type this and tell you what it

00:15:36,980 --> 00:15:44,500
means because it's in Reverse form so if

00:15:41,270 --> 00:15:47,300
you are aware of the ABI on arm systems

00:15:44,500 --> 00:15:48,650
then it's a risk system that parses

00:15:47,300 --> 00:15:51,500
argumentative registers so when you've

00:15:48,650 --> 00:15:53,870
attached to the VFS read function then

00:15:51,500 --> 00:15:55,460
x0 contains the first argument x 1

00:15:53,870 --> 00:15:58,280
contains the second argument and so on

00:15:55,460 --> 00:16:00,650
and so forth so I am using that

00:15:58,280 --> 00:16:04,640
knowledge to attach to the first

00:16:00,650 --> 00:16:07,580
argument and I am offsetting it at 21

00:16:04,640 --> 00:16:09,170
decimal 24 decimal and from that pointer

00:16:07,580 --> 00:16:12,440
I'm the differencing dereferencing that

00:16:09,170 --> 00:16:14,090
at 56 decimal you these are numbers I

00:16:12,440 --> 00:16:15,380
pre looked up you can look them up in

00:16:14,090 --> 00:16:17,750
gdb and there's a whole bunch of tools

00:16:15,380 --> 00:16:19,940
you can look up with but they are

00:16:17,750 --> 00:16:21,350
numbers that I have just pulled out in

00:16:19,940 --> 00:16:23,510
my hand in front of you now and we'll

00:16:21,350 --> 00:16:25,370
come back to that in a minute we can

00:16:23,510 --> 00:16:27,830
also do simpler things like look at x2

00:16:25,370 --> 00:16:31,700
which is a count so that's much easier

00:16:27,830 --> 00:16:34,280
to drag greater jag out x2 much easier

00:16:31,700 --> 00:16:35,780
to drag out because I can and I'm going

00:16:34,280 --> 00:16:37,900
to overwrite the caper events now so

00:16:35,780 --> 00:16:40,580
this is the only caper in the system and

00:16:37,900 --> 00:16:41,720
it's going to fail and the reason it's

00:16:40,580 --> 00:16:44,360
there is because I've left them enabled

00:16:41,720 --> 00:16:45,950
and when I said you get yourself tangled

00:16:44,360 --> 00:16:47,839
in knots doing live demos with F trace

00:16:45,950 --> 00:16:49,670
this is main reason because as soon as

00:16:47,839 --> 00:16:52,190
you try and manipulate the trace point

00:16:49,670 --> 00:16:54,230
they never work so I can go back in and

00:16:52,190 --> 00:16:56,150
I can just do a trace reset if I want or

00:16:54,230 --> 00:16:57,560
I could enable them specifically but

00:16:56,150 --> 00:16:58,130
because I've created trace reset to get

00:16:57,560 --> 00:17:00,500
me out of trouble

00:16:58,130 --> 00:17:02,450
that's what it's for so I can now put

00:17:00,500 --> 00:17:04,250
that in place and when I count the trace

00:17:02,450 --> 00:17:07,910
pipe now it should get bit more exciting

00:17:04,250 --> 00:17:09,920
because nothing cause I'd enable it

00:17:07,910 --> 00:17:13,550
sorry yes and so I go back to do the

00:17:09,920 --> 00:17:15,319
enable cat trace by and we can now see

00:17:13,550 --> 00:17:17,120
that we're reading a file called tracer

00:17:15,319 --> 00:17:18,410
pipe I mean I know your Dean unit but we

00:17:17,120 --> 00:17:20,540
can now observe that every time we do a

00:17:18,410 --> 00:17:22,550
various read we can see how big a buffer

00:17:20,540 --> 00:17:24,800
we were trying to fill what the name of

00:17:22,550 --> 00:17:27,650
the thing is within certain limits this

00:17:24,800 --> 00:17:29,510
is picking up a special short string

00:17:27,650 --> 00:17:30,800
inside the devii FS system and if you've

00:17:29,510 --> 00:17:33,590
got a really long file name it won't

00:17:30,800 --> 00:17:35,000
actually give you the right one but

00:17:33,590 --> 00:17:36,440
that's what we can do and we can do that

00:17:35,000 --> 00:17:37,910
for almost anywhere in the kernel and we

00:17:36,440 --> 00:17:38,480
can fish out these arguments we can give

00:17:37,910 --> 00:17:40,340
them names

00:17:38,480 --> 00:17:41,870
once we've given them names just as with

00:17:40,340 --> 00:17:44,330
the adapter number we can filter on them

00:17:41,870 --> 00:17:46,100
so not only can we we can combine these

00:17:44,330 --> 00:17:47,140
bricks together we can go and find an

00:17:46,100 --> 00:17:49,000
interesting function week

00:17:47,140 --> 00:17:50,440
extract interesting arguments we can

00:17:49,000 --> 00:17:52,150
filter those interesting arguments we

00:17:50,440 --> 00:17:53,500
can trigger on them to turn the trace on

00:17:52,150 --> 00:17:56,980
and off when particular interesting

00:17:53,500 --> 00:18:00,460
things are happening and however it was

00:17:56,980 --> 00:18:02,440
rather kind of sucky having to know that

00:18:00,460 --> 00:18:04,240
this particular thing is at fifty-six

00:18:02,440 --> 00:18:05,920
hex it's particularly sucky if you've

00:18:04,240 --> 00:18:07,720
got a structure layout randomization

00:18:05,920 --> 00:18:11,280
turned on because you have to look up

00:18:07,720 --> 00:18:11,280
every time you rebuild the kernel so

00:18:12,690 --> 00:18:17,410
we're going to stop using command-line

00:18:15,520 --> 00:18:18,550
tools this point we're going to step up

00:18:17,410 --> 00:18:20,160
not where we can use command line tools

00:18:18,550 --> 00:18:22,720
we're going to stop using the basic

00:18:20,160 --> 00:18:24,130
toolbox of less and great gap and cat

00:18:22,720 --> 00:18:27,100
and all the others we're going to go and

00:18:24,130 --> 00:18:30,700
use kind of purpose-built tools now are

00:18:27,100 --> 00:18:32,890
more able to look at this stuff so as

00:18:30,700 --> 00:18:34,780
you can look at a sub command of path so

00:18:32,890 --> 00:18:37,510
Perez a whole bunch of things it kind of

00:18:34,780 --> 00:18:39,970
cut its teeth is profiling tool but it

00:18:37,510 --> 00:18:41,350
has many other things and debug features

00:18:39,970 --> 00:18:43,780
bolted on to it now and one of these is

00:18:41,350 --> 00:18:46,480
probe which takes advantage of the fact

00:18:43,780 --> 00:18:50,680
that Perth is linked against libraries

00:18:46,480 --> 00:18:52,210
that can study dwarf information so I'm

00:18:50,680 --> 00:18:55,990
going to look I'd like to look at VFS

00:18:52,210 --> 00:18:57,700
read just as I did before and I'd like

00:18:55,990 --> 00:18:58,990
to put in a source level description of

00:18:57,700 --> 00:19:01,210
what I want to look so I'd like a thing

00:18:58,990 --> 00:19:03,220
called I name it's going to go to the

00:19:01,210 --> 00:19:05,920
argument called file i'll dereference it

00:19:03,220 --> 00:19:08,560
just as I would in C you can see I've

00:19:05,920 --> 00:19:11,020
got the dot there which is not going to

00:19:08,560 --> 00:19:15,300
cause an officer or every direct final

00:19:11,020 --> 00:19:15,300
finger operator taking us to the I name

00:19:15,780 --> 00:19:19,810
neither form is a string and I'd like

00:19:18,130 --> 00:19:21,160
camp to come in and I've just created

00:19:19,810 --> 00:19:24,160
captain count because I happen to know

00:19:21,160 --> 00:19:31,870
the local variables called camp and I

00:19:24,160 --> 00:19:36,250
forgot this at the pass history so that

00:19:31,870 --> 00:19:37,840
is now going to create the probe using

00:19:36,250 --> 00:19:41,740
the symbolic information now when we

00:19:37,840 --> 00:19:43,420
read it back we can actually see that

00:19:41,740 --> 00:19:46,420
it's the same probe you'll notice that

00:19:43,420 --> 00:19:48,070
it's picked text rather than the name of

00:19:46,420 --> 00:19:49,390
the function because it didn't use K all

00:19:48,070 --> 00:19:51,610
seems to find it it used the debug

00:19:49,390 --> 00:19:53,800
information well that also means is if

00:19:51,610 --> 00:19:55,570
you're using a minimized K or sims you

00:19:53,800 --> 00:19:57,130
can still use the debug information to

00:19:55,570 --> 00:19:58,390
chase now static functions and other

00:19:57,130 --> 00:20:00,600
bits that are spread into peculiar

00:19:58,390 --> 00:20:00,600
places

00:20:00,850 --> 00:20:06,040
you can also get a clue about how I

00:20:03,070 --> 00:20:07,240
discovered the numbers 56 and 24 I'm far

00:20:06,040 --> 00:20:09,460
too lazy to have sat there in

00:20:07,240 --> 00:20:10,840
calculating my hand I did do this in the

00:20:09,460 --> 00:20:14,590
opposite order to which I've presented

00:20:10,840 --> 00:20:16,000
it and once again I can enable the trace

00:20:14,590 --> 00:20:18,130
point it will do exactly the same thing

00:20:16,000 --> 00:20:19,870
except that this directory will no

00:20:18,130 --> 00:20:22,750
longer work because the default

00:20:19,870 --> 00:20:25,420
directory when you use K probes raw is

00:20:22,750 --> 00:20:28,390
different to the directory that perf

00:20:25,420 --> 00:20:29,740
probe selects so perf probes there is

00:20:28,390 --> 00:20:31,060
actually prefix you can choose or

00:20:29,740 --> 00:20:32,740
directories they appear in but the

00:20:31,060 --> 00:20:34,630
default directory the probe uses is

00:20:32,740 --> 00:20:36,850
actually different to the one that capo

00:20:34,630 --> 00:20:38,020
prevents uses once I've done that my

00:20:36,850 --> 00:20:43,900
trace pipe should look exactly the same

00:20:38,020 --> 00:20:45,790
as it ever did now cross to link arm and

00:20:43,900 --> 00:20:48,070
arm is coming but cross cooling is still

00:20:45,790 --> 00:20:50,110
effective life and perf probe is

00:20:48,070 --> 00:20:52,300
actually by default across tool it's not

00:20:50,110 --> 00:20:55,360
got any specific architecture burnt into

00:20:52,300 --> 00:20:57,040
it so if I was on a PC I could type

00:20:55,360 --> 00:20:58,720
earth probe and I could use the - Dion

00:20:57,040 --> 00:21:04,740
shell get from the history I could use

00:20:58,720 --> 00:21:07,030
the - D argument and it would pickle the

00:21:04,740 --> 00:21:11,770
little print to me the message I need to

00:21:07,030 --> 00:21:14,620
put myself into K probe events so I have

00:21:11,770 --> 00:21:16,270
it there and I can even this has been

00:21:14,620 --> 00:21:18,100
picked up by using some clever destroy

00:21:16,270 --> 00:21:20,200
knowledge of where D packages install my

00:21:18,100 --> 00:21:21,670
current kernel so I can provide it VM

00:21:20,200 --> 00:21:23,920
Linux and a path

00:21:21,670 --> 00:21:25,030
I shall type active of Dell but I can

00:21:23,920 --> 00:21:26,890
try it out so we're funding a cost of

00:21:25,030 --> 00:21:29,560
element I have to point it at my cross

00:21:26,890 --> 00:21:31,570
kernel I can do this on my big powerful

00:21:29,560 --> 00:21:33,100
machine and if I'm on a particularly on

00:21:31,570 --> 00:21:35,980
a system like Android where I haven't

00:21:33,100 --> 00:21:38,190
got lots of other tools I can just type

00:21:35,980 --> 00:21:41,170
this in copying it from thing to thing

00:21:38,190 --> 00:21:43,960
so it does work nicely with cost of

00:21:41,170 --> 00:21:46,120
element and they just to wrap things up

00:21:43,960 --> 00:21:48,610
I'm going to go for even more calorific

00:21:46,120 --> 00:21:51,910
cooling but it's still very small one

00:21:48,610 --> 00:21:55,750
I'm going to go for a BPF program called

00:21:51,910 --> 00:21:58,210
ply so ply is implementing an orc like

00:21:55,750 --> 00:22:03,730
mini language that allows you to attach

00:21:58,210 --> 00:22:04,540
BPF programs to trace points so I'm

00:22:03,730 --> 00:22:08,380
going to start off with a little

00:22:04,540 --> 00:22:10,210
one-liner it's odd because this is a one

00:22:08,380 --> 00:22:12,679
line I really quite like so it's saying

00:22:10,210 --> 00:22:14,779
ply run for five seconds that's the T

00:22:12,679 --> 00:22:17,509
five and run this particular program

00:22:14,779 --> 00:22:19,970
which will attach to a particular probe

00:22:17,509 --> 00:22:23,210
in this case k memcache our lock node so

00:22:19,970 --> 00:22:25,940
it's going to attach that function and

00:22:23,210 --> 00:22:30,740
then the magic on the side is that at is

00:22:25,940 --> 00:22:33,679
an anonymous dictionary which I would

00:22:30,740 --> 00:22:34,580
like to index by stack and every time

00:22:33,679 --> 00:22:36,320
this gets called

00:22:34,580 --> 00:22:38,179
I would like to accumulate one in a

00:22:36,320 --> 00:22:40,279
counter that's what all that translates

00:22:38,179 --> 00:22:42,499
to so I have an anonymous dictionary

00:22:40,279 --> 00:22:44,570
that is indexed by the stack trace of

00:22:42,499 --> 00:22:46,879
the node and I'm counting every time I

00:22:44,570 --> 00:22:49,190
run and I can run that and five seconds

00:22:46,879 --> 00:22:52,009
later it will tell me which cool sites

00:22:49,190 --> 00:22:55,149
are most active in calling K memcache a

00:22:52,009 --> 00:22:57,799
lot if you're really paying attention

00:22:55,149 --> 00:22:59,720
you'll notice that this is semantically

00:22:57,799 --> 00:23:01,549
pretty much the same information as we

00:22:59,720 --> 00:23:04,789
got out from histograms earlier in the

00:23:01,549 --> 00:23:05,929
demonstration so I think technically

00:23:04,789 --> 00:23:07,490
histograms are more efficient because

00:23:05,929 --> 00:23:09,980
you don't have to keep triggering the VM

00:23:07,490 --> 00:23:11,389
but I actually prefer this one because

00:23:09,980 --> 00:23:12,830
it just fits my brain better what's

00:23:11,389 --> 00:23:14,720
actually happening and I see what's

00:23:12,830 --> 00:23:16,100
happening more clearly and again if I

00:23:14,720 --> 00:23:18,679
want to do filtering I can do it in

00:23:16,100 --> 00:23:21,700
expressions inside ply so I've got

00:23:18,679 --> 00:23:23,690
access to the arguments of so the

00:23:21,700 --> 00:23:26,139
parameters of the trace point everything

00:23:23,690 --> 00:23:28,070
else so if I want to do complex

00:23:26,139 --> 00:23:30,889
expressions and modifications and

00:23:28,070 --> 00:23:33,259
deciding things I've got that option but

00:23:30,889 --> 00:23:34,340
to fully round out the demonstration I

00:23:33,259 --> 00:23:36,649
do want to show you something that you

00:23:34,340 --> 00:23:38,389
can't do with the tracing of Astroturf

00:23:36,649 --> 00:23:41,929
on its own I am gonna copy and paste

00:23:38,389 --> 00:23:47,679
this because it is quite long to make

00:23:41,929 --> 00:23:47,679
sure you won't change over here

00:23:52,560 --> 00:24:01,740
so I'm gonna drop this into the I think

00:23:58,660 --> 00:24:01,740
I've already got it out from before us

00:24:04,320 --> 00:24:09,880
not my day right and I should copy it

00:24:08,590 --> 00:24:13,420
one more time and then I shall explain

00:24:09,880 --> 00:24:24,160
what it does I was doing so well up to

00:24:13,420 --> 00:24:26,110
that point that's what is so big your

00:24:24,160 --> 00:24:28,240
pardon there we go that will now work so

00:24:26,110 --> 00:24:30,070
what this is it's three separate probes

00:24:28,240 --> 00:24:32,680
attached to three separate places

00:24:30,070 --> 00:24:35,650
the first probe is attached to the entry

00:24:32,680 --> 00:24:37,060
of km Kellogg knows and it's a hack and

00:24:35,650 --> 00:24:38,980
the reason is that at least because you

00:24:37,060 --> 00:24:41,260
can only get the stack trace on the

00:24:38,980 --> 00:24:43,270
entry you can't get a stack trace from a

00:24:41,260 --> 00:24:45,490
ret probe so from that beginning point

00:24:43,270 --> 00:24:47,380
there we are grabbing the stack and

00:24:45,490 --> 00:24:50,620
storing in our anonymous dictionary

00:24:47,380 --> 00:24:53,200
again using the constant 0 to store it

00:24:50,620 --> 00:24:56,860
and then when we return from that same

00:24:53,200 --> 00:24:59,620
function we fish it out of the zero

00:24:56,860 --> 00:25:04,390
point and use our return value which is

00:24:59,620 --> 00:25:06,160
the address we've just allocated that's

00:25:04,390 --> 00:25:08,110
we put I so in other words what we're

00:25:06,160 --> 00:25:10,450
doing is we're taking the address that

00:25:08,110 --> 00:25:12,280
we've allocated in a dictionary form and

00:25:10,450 --> 00:25:14,860
we are course storing the stack trace in

00:25:12,280 --> 00:25:17,440
that address and then on the other side

00:25:14,860 --> 00:25:20,410
when we free the device 3 the K probe

00:25:17,440 --> 00:25:22,000
sorry we freed from the cache we remove

00:25:20,410 --> 00:25:24,340
it from the dictionary or in other words

00:25:22,000 --> 00:25:27,640
we've now created a dynamic leak

00:25:24,340 --> 00:25:29,200
detector using EBP F and that applies to

00:25:27,640 --> 00:25:30,850
any type of resource so I've used K

00:25:29,200 --> 00:25:33,010
memcache a lock because I know that my

00:25:30,850 --> 00:25:34,300
laptop calls it constantly especially

00:25:33,010 --> 00:25:37,690
when it's on the network and talking to

00:25:34,300 --> 00:25:40,300
my other laptop to run the projector so

00:25:37,690 --> 00:25:42,340
I can now just run apply track lie

00:25:40,300 --> 00:25:44,800
it will run those things until I press

00:25:42,340 --> 00:25:46,240
control C when a report leaks it doesn't

00:25:44,800 --> 00:25:47,920
just report leaks of course it also

00:25:46,240 --> 00:25:50,920
reports things that are still in flight

00:25:47,920 --> 00:25:52,630
so it you have to take a little bit of

00:25:50,920 --> 00:25:54,160
care and in this case there is so much

00:25:52,630 --> 00:25:56,080
network activity happening that there is

00:25:54,160 --> 00:25:57,370
actually quite a lot of allocation if

00:25:56,080 --> 00:26:01,330
you run it without the network when I

00:25:57,370 --> 00:26:02,380
develop this demonstration you didn't

00:26:01,330 --> 00:26:04,860
see leaks very often

00:26:02,380 --> 00:26:06,940
you could occasion if you rushed it but

00:26:04,860 --> 00:26:10,270
there was a slightly sucky thing which

00:26:06,940 --> 00:26:12,750
is these addresses have come in decimal

00:26:10,270 --> 00:26:14,590
format and hex which is a shame

00:26:12,750 --> 00:26:16,090
apply is a very simple tool you

00:26:14,590 --> 00:26:18,100
genuinely could go in and change the way

00:26:16,090 --> 00:26:22,870
it prints those if you wish I tend to do

00:26:18,100 --> 00:26:26,320
a proce process to convert as needed but

00:26:22,870 --> 00:26:27,940
that's about it wrapping up my scripts

00:26:26,320 --> 00:26:29,500
that I've been cribbing notes from as

00:26:27,940 --> 00:26:32,260
I've been speaking I will make that the

00:26:29,500 --> 00:26:34,600
PDF available for this presentation so

00:26:32,260 --> 00:26:37,210
you can dig out all these concepts again

00:26:34,600 --> 00:26:38,860
later if you're interested and I think

00:26:37,210 --> 00:26:41,290
we have the free take home degree so you

00:26:38,860 --> 00:26:43,060
have to remember the readme file you

00:26:41,290 --> 00:26:45,430
have to remember that you can search for

00:26:43,060 --> 00:26:48,460
the static trace points with a find and

00:26:45,430 --> 00:26:50,320
I view the static trace points as advice

00:26:48,460 --> 00:26:52,120
for maintain Asst you know that's the

00:26:50,320 --> 00:26:53,680
expert person working on the server

00:26:52,120 --> 00:26:55,720
system telling me what is most

00:26:53,680 --> 00:26:57,160
interesting about that subsystem you

00:26:55,720 --> 00:26:58,540
know I didn't have mark brown come and

00:26:57,160 --> 00:26:59,980
explained to me that red map could show

00:26:58,540 --> 00:27:02,550
me how to read a register I just went

00:26:59,980 --> 00:27:05,680
into sorbs reg map directly excellent

00:27:02,550 --> 00:27:07,720
and that finally with the dynamic price

00:27:05,680 --> 00:27:09,490
points you can reach almost anywhere and

00:27:07,720 --> 00:27:12,040
do almost anything if you can figure out

00:27:09,490 --> 00:27:13,690
how to express it in hex or you can use

00:27:12,040 --> 00:27:17,050
the perf probe to express C and C

00:27:13,690 --> 00:27:19,590
properly and that's it thank you very

00:27:17,050 --> 00:27:19,590
very much indeed

00:27:21,290 --> 00:27:37,850
or greatly more thank you but what

00:27:24,090 --> 00:27:39,900
distinguishes so static trace points are

00:27:37,850 --> 00:27:41,850
effectively they look like functions in

00:27:39,900 --> 00:27:44,460
the C source code so so in the kernel

00:27:41,850 --> 00:27:47,190
source code there are macros that say I

00:27:44,460 --> 00:27:49,830
have a trace point I want to declare you

00:27:47,190 --> 00:27:53,550
text you lies it using this string it

00:27:49,830 --> 00:27:55,110
has this arguments and then that in

00:27:53,550 --> 00:27:57,300
addition to storing the metadata will

00:27:55,110 --> 00:27:59,730
also generate like a function stub so

00:27:57,300 --> 00:28:01,320
that when you call that function it puts

00:27:59,730 --> 00:28:04,140
it into the trades buffer so it's very

00:28:01,320 --> 00:28:06,150
efficient its direct I can't remember

00:28:04,140 --> 00:28:08,250
how it gates itself but I would thought

00:28:06,150 --> 00:28:12,179
it uses one of the static code mod type

00:28:08,250 --> 00:28:13,770
ways to gate itself on and off did I

00:28:12,179 --> 00:28:15,660
make trace points of breakpoints so

00:28:13,770 --> 00:28:18,000
underneath the coat these Masami in the

00:28:15,660 --> 00:28:19,890
audience here open so under the hood

00:28:18,000 --> 00:28:22,230
dynamic trace point puts a break point

00:28:19,890 --> 00:28:23,730
when the break point comes in it goes

00:28:22,230 --> 00:28:26,429
and looks up what address you've just

00:28:23,730 --> 00:28:28,290
hit finds it in a table uses that table

00:28:26,429 --> 00:28:29,700
to use the same data structure so

00:28:28,290 --> 00:28:31,080
underlying it once it is the trace

00:28:29,700 --> 00:28:32,190
system it looks the same but the

00:28:31,080 --> 00:28:33,960
mechanism that you've called into the

00:28:32,190 --> 00:28:34,980
trail system is different and then

00:28:33,960 --> 00:28:37,050
obviously have to single step the

00:28:34,980 --> 00:28:38,940
machine go through put the trace point

00:28:37,050 --> 00:28:40,410
back continue on your merry way so

00:28:38,940 --> 00:28:44,580
dynamic trace points are not as

00:28:40,410 --> 00:28:45,780
efficient but you've got to be people

00:28:44,580 --> 00:28:47,520
are able to do quite sophisticated

00:28:45,780 --> 00:28:49,950
performance sensitive network work

00:28:47,520 --> 00:28:54,630
despite the fact that we breakpoint

00:28:49,950 --> 00:28:56,610
misstep in the machine can you denial

00:28:54,630 --> 00:28:59,460
service your own boss so there were

00:28:56,610 --> 00:29:00,750
mechanism stronger vent it so many of

00:28:59,460 --> 00:29:03,210
the functions that are intrinsically

00:29:00,750 --> 00:29:05,070
used by trace are marked no trace and

00:29:03,210 --> 00:29:06,780
the kernel will prevent you from

00:29:05,070 --> 00:29:08,429
attempting to trace those functions and

00:29:06,780 --> 00:29:10,140
the intention that's to stop it doing a

00:29:08,429 --> 00:29:11,580
denial of service so that you can't have

00:29:10,140 --> 00:29:14,030
a trace point that triggers another

00:29:11,580 --> 00:29:14,030
trace point

00:29:17,960 --> 00:29:22,020
yeah if you've stuck it somewhere

00:29:19,920 --> 00:29:23,700
interrupts which was called sufficiently

00:29:22,020 --> 00:29:25,200
frequently I don't think there's

00:29:23,700 --> 00:29:27,240
anything that could prevent that

00:29:25,200 --> 00:29:29,160
ridiculously fast in truck for doing it

00:29:27,240 --> 00:29:30,300
but then that ridiculous custom truck

00:29:29,160 --> 00:29:31,590
was a bug in the first place and

00:29:30,300 --> 00:29:34,500
congratulations you found an O for

00:29:31,590 --> 00:29:35,790
frequent interaction notes it was

00:29:34,500 --> 00:30:04,890
probably hurting you before it's it's

00:29:35,790 --> 00:30:07,440
never any other really great way to

00:30:04,890 --> 00:30:09,390
drive service the box is to set TP print

00:30:07,440 --> 00:30:10,890
code which means the instead of using

00:30:09,390 --> 00:30:12,090
the efficient path sees does a print a

00:30:10,890 --> 00:30:15,440
for each straight point that will

00:30:12,090 --> 00:30:20,310
denial-of-service you almost immediately

00:30:15,440 --> 00:30:22,020
and yeah i put some thanks up so Steven

00:30:20,310 --> 00:30:23,100
Rosa who did a lot of the F trace work

00:30:22,020 --> 00:30:24,780
Masami who's one degree in the

00:30:23,100 --> 00:30:28,860
conference and wrote the only versions

00:30:24,780 --> 00:30:30,360
of Cape Rose I believe and Leo who has

00:30:28,860 --> 00:30:32,550
contributed a lot of my knowledge about

00:30:30,360 --> 00:30:34,530
how debuggers and the deep web

00:30:32,550 --> 00:30:36,630
technologies work I will add you've

00:30:34,530 --> 00:30:40,640
missed people but but they are the ones

00:30:36,630 --> 00:30:40,640
who release technology we're showing off

00:30:47,960 --> 00:30:52,740
I've put the the URL to apply which

00:30:51,450 --> 00:30:55,230
trees ability to search the other things

00:30:52,740 --> 00:30:57,870
is in museum in the PDF format so yeah

00:30:55,230 --> 00:31:00,510
and the warning about Perth is that

00:30:57,870 --> 00:31:01,830
Perth dynamically adapts to what

00:31:00,510 --> 00:31:03,870
libraries are doing and don't have in

00:31:01,830 --> 00:31:06,390
the system so if you don't have the

00:31:03,870 --> 00:31:08,340
dwarf dev files when you build Perth all

00:31:06,390 --> 00:31:10,500
those nice Perth propia features get

00:31:08,340 --> 00:31:12,720
automatically disabled so you do have to

00:31:10,500 --> 00:31:15,710
make sure you've got lots of development

00:31:12,720 --> 00:31:15,710
libraries when you build path

00:31:19,520 --> 00:31:23,179
excellent thank you very very much

00:31:23,310 --> 00:31:27,630

YouTube URL: https://www.youtube.com/watch?v=NNBnYJdyTwg


