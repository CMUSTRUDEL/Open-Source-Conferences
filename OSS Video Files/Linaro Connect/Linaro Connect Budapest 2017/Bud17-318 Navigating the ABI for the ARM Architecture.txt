Title: Bud17-318 Navigating the ABI for the ARM Architecture
Publication date: 2017-03-11
Playlist: Linaro Connect Budapest 2017
Description: 
	"Session ID: BUD17-318
Session Name: Navigating the ABI for the ARM Architecture - BUD17-318
Speaker: Peter Smith
Track: Toolchain


★ Session Summary ★
The ABI for a platform is defined by a multi-layered series of documents, with the ARM specific parts are largely defined by the ABI for the ARM architecture. This presentation will describe the structure of the ABI documentation and some of the design principles used in its construction.
 
This presentation is aimed at software developers wanting to understand how to find information about the ABI, what they can rely upon and what they can extend
---------------------------------------------------
★ Resources ★
Event Page: http://connect.linaro.org/resource/bud17/bud17-318/
Presentation: https://www.slideshare.net/linaroorg/bud17318-navigating-the-abi-for-the-arm-architecture
Video: https://youtu.be/shlvgwdI1vE
 ---------------------------------------------------

★ Event Details ★
Linaro Connect Budapest 2017 (BUD17)
6-10 March 2017
Corinthia Hotel, Budapest,
Erzsébet krt. 43-49,
1073 Hungary

---------------------------------------------------
Keyword: toolchain, ABI, ARM
http://www.linaro.org
http://connect.linaro.org
---------------------------------------------------
Follow us on Social Media
https://www.facebook.com/LinaroOrg
https://twitter.com/linaroorg
https://www.youtube.com/user/linaroorg?sub_confirmation=1
https://www.linkedin.com/company/1026961"
Captions: 
	00:00:00,130 --> 00:00:04,110
[Music]

00:00:10,370 --> 00:00:15,330
okay the doors have closed you're all

00:00:12,840 --> 00:00:20,100
locked in here now no escape from the

00:00:15,330 --> 00:00:22,140
API okay I better make a start so alone

00:00:20,100 --> 00:00:25,230
my name sir peter smith i'll be talking

00:00:22,140 --> 00:00:27,929
for hopefully about 50 minutes on the

00:00:25,230 --> 00:00:29,460
ABI i've noticed there's a lack of a

00:00:27,929 --> 00:00:31,830
clock in here so someone might have to

00:00:29,460 --> 00:00:33,930
give me a prod if i go on too much in

00:00:31,830 --> 00:00:37,110
any particular time or anything like

00:00:33,930 --> 00:00:41,670
that and yes that would be helpful

00:00:37,110 --> 00:00:43,410
thanks so best thing is if there's any

00:00:41,670 --> 00:00:45,180
questions at any point please stop me

00:00:43,410 --> 00:00:47,609
and i'll go and try and explain things

00:00:45,180 --> 00:00:48,690
as best i can and you'll be pleased to

00:00:47,609 --> 00:00:50,190
know i'm not going to be going through

00:00:48,690 --> 00:00:52,109
each of the individual doctor and

00:00:50,190 --> 00:00:53,730
documents in turn and reading lines of

00:00:52,109 --> 00:00:55,410
the mouths that's probably not a good

00:00:53,730 --> 00:00:57,809
use of everyone's time this is very much

00:00:55,410 --> 00:01:00,000
a sort of introduction to the ABI i

00:00:57,809 --> 00:01:02,250
think probably best go to my gender know

00:01:00,000 --> 00:01:03,840
how me explain things and so better here

00:01:02,250 --> 00:01:06,110
so basically what we're we're we're

00:01:03,840 --> 00:01:10,260
going to start from is where did the

00:01:06,110 --> 00:01:12,660
where did the ABI come from um didn't

00:01:10,260 --> 00:01:17,390
start off with maybe I sister davern

00:01:12,660 --> 00:01:19,770
developed in about year 2003 and a

00:01:17,390 --> 00:01:23,160
little bit about the history where arm

00:01:19,770 --> 00:01:24,750
was at that particular time then it's

00:01:23,160 --> 00:01:27,000
sort of a little bit about the structure

00:01:24,750 --> 00:01:29,310
of the ABI many of you have noticed it

00:01:27,000 --> 00:01:30,900
doesn't look like the a B is for many of

00:01:29,310 --> 00:01:33,450
the other processor architectures out

00:01:30,900 --> 00:01:34,770
there this gift give some of the reasons

00:01:33,450 --> 00:01:37,800
why it was structured the way it was

00:01:34,770 --> 00:01:40,410
structured and will then go on a little

00:01:37,800 --> 00:01:43,050
bit more about okay I as a user of the

00:01:40,410 --> 00:01:45,330
ABI rather than how it was designed what

00:01:43,050 --> 00:01:47,430
are my expectations of compatibility

00:01:45,330 --> 00:01:50,400
between say different object files

00:01:47,430 --> 00:01:53,040
different libraries on an arm system and

00:01:50,400 --> 00:01:55,020
then we'll finish very very quickly with

00:01:53,040 --> 00:01:57,120
a little bit about the 64-bit ABI and

00:01:55,020 --> 00:01:58,950
how it differs so most the time i'm here

00:01:57,120 --> 00:02:01,110
i'm going to be talking about the 32-bit

00:01:58,950 --> 00:02:03,720
api a lot of you'll notice does the

00:02:01,110 --> 00:02:06,120
64-bit apos much much smaller than the

00:02:03,720 --> 00:02:09,360
32-bit ABI and it's very much more

00:02:06,120 --> 00:02:13,349
traditional and so i'll go on to the

00:02:09,360 --> 00:02:15,000
reasons for that later on ok so a little

00:02:13,349 --> 00:02:17,700
bit about me or ghost is very very

00:02:15,000 --> 00:02:19,120
quickly so my backgrounds with the arm

00:02:17,700 --> 00:02:22,989
compiler the

00:02:19,120 --> 00:02:27,099
priori compiler toolchain from 2000 into

00:02:22,989 --> 00:02:28,599
2016 I've control the various names that

00:02:27,099 --> 00:02:30,430
the toolkit went through there but if

00:02:28,599 --> 00:02:34,420
any of you involved in the embedded

00:02:30,430 --> 00:02:36,430
systems area and views on CC then you

00:02:34,420 --> 00:02:40,360
probably know that sort of toolkit that

00:02:36,430 --> 00:02:42,340
I've been that come from my works mostly

00:02:40,360 --> 00:02:45,909
been in what we call the minor tools in

00:02:42,340 --> 00:02:48,909
our run in our team sometimes non

00:02:45,909 --> 00:02:51,220
compiler tools when specifically arm

00:02:48,909 --> 00:02:53,049
link our math and from else and i'm

00:02:51,220 --> 00:02:55,840
currently looking at and implementing

00:02:53,049 --> 00:02:59,079
our supporting lld as allen RM assignee

00:02:55,840 --> 00:03:01,930
at the moment so I haven't wasn't

00:02:59,079 --> 00:03:03,909
involved in drafting of the original ABI

00:03:01,930 --> 00:03:05,560
but I have been responsible for

00:03:03,909 --> 00:03:08,140
implementing a bit of it in the non

00:03:05,560 --> 00:03:10,750
compiler tools so that's mostly where my

00:03:08,140 --> 00:03:12,640
sins experience comes from also the

00:03:10,750 --> 00:03:14,739
linkers journey when ABI things start to

00:03:12,640 --> 00:03:16,420
collide and go wrong then you get blamed

00:03:14,739 --> 00:03:18,190
for when two things are particularly

00:03:16,420 --> 00:03:20,260
compatible and have to then go and find

00:03:18,190 --> 00:03:24,190
out what what what actually works out

00:03:20,260 --> 00:03:25,840
there ok so we'll start off with some

00:03:24,190 --> 00:03:28,120
definitions because there's a lot of

00:03:25,840 --> 00:03:29,169
acronyms that get thrown around here so

00:03:28,120 --> 00:03:31,150
it's not going to go into these any more

00:03:29,169 --> 00:03:32,680
detail i'm just going to go or even

00:03:31,150 --> 00:03:34,660
argue about whether these are the best

00:03:32,680 --> 00:03:37,450
definitions these are just the ones that

00:03:34,660 --> 00:03:40,239
I'm using so when ABI sounds very

00:03:37,450 --> 00:03:43,569
similar to API so just if anyone is not

00:03:40,239 --> 00:03:47,230
familiar with maybe I is API very much

00:03:43,569 --> 00:03:49,030
an interface source code level ABI now

00:03:47,230 --> 00:03:51,760
this is ABI in its traditional sense

00:03:49,030 --> 00:03:54,430
tends to mean an interface between an

00:03:51,760 --> 00:03:57,430
executive all shared library and the

00:03:54,430 --> 00:03:59,290
operating system that's slightly

00:03:57,430 --> 00:04:01,480
different to the are maybe I which we

00:03:59,290 --> 00:04:04,810
well whether whether this is actually an

00:04:01,480 --> 00:04:07,540
arm term or powerpc term I think I may

00:04:04,810 --> 00:04:10,419
have seen it been used before as an

00:04:07,540 --> 00:04:13,000
embedded application binary interface or

00:04:10,419 --> 00:04:16,180
EA bi this is why you'll often see the

00:04:13,000 --> 00:04:19,449
turn EAB I rather than a bi in that it's

00:04:16,180 --> 00:04:21,940
a interface between relocatable objects

00:04:19,449 --> 00:04:25,360
rather than interface just between

00:04:21,940 --> 00:04:31,210
shared objects execs balls and the and

00:04:25,360 --> 00:04:32,350
the OS x platform what arm tends to mean

00:04:31,210 --> 00:04:34,810
by that when it says

00:04:32,350 --> 00:04:39,220
platform it means something like linux

00:04:34,810 --> 00:04:41,560
bsd windows symbian it means a rich

00:04:39,220 --> 00:04:43,810
platform with quite a lot of facility

00:04:41,560 --> 00:04:47,250
features that's able to independently

00:04:43,810 --> 00:04:50,500
load applications itself you know and

00:04:47,250 --> 00:04:53,530
have a sort of rich set of speeches in

00:04:50,500 --> 00:04:55,510
itself so the idea verities if you were

00:04:53,530 --> 00:04:59,170
building an application executive all

00:04:55,510 --> 00:05:01,320
force a Linux your and you would have

00:04:59,170 --> 00:05:04,530
the expectation that the C library was a

00:05:01,320 --> 00:05:06,760
shared library on that system whereas

00:05:04,530 --> 00:05:10,000
going to bare metal which is our next

00:05:06,760 --> 00:05:13,840
the next definition is you would expect

00:05:10,000 --> 00:05:16,090
that to be a statically linked exact

00:05:13,840 --> 00:05:18,070
executive all if it has an operating

00:05:16,090 --> 00:05:19,510
system it will be an artist and that

00:05:18,070 --> 00:05:22,000
I'll toss will probably be statically

00:05:19,510 --> 00:05:25,750
linked as a library to the application

00:05:22,000 --> 00:05:28,270
so when we say bare metal we tend to

00:05:25,750 --> 00:05:31,360
mean something that isn't run on top of

00:05:28,270 --> 00:05:33,880
something like Linux or run BSD and it

00:05:31,360 --> 00:05:37,900
can or what may or may not have an

00:05:33,880 --> 00:05:41,050
artist if I say the word qoi means

00:05:37,900 --> 00:05:43,570
quality of implementation and that sort

00:05:41,050 --> 00:05:47,020
of means we're in the ABI there will be

00:05:43,570 --> 00:05:49,270
various standards where you you can say

00:05:47,020 --> 00:05:51,880
that you could conform to but there are

00:05:49,270 --> 00:05:54,070
bits where you can say it is a quality

00:05:51,880 --> 00:05:56,860
of implementation definition whether you

00:05:54,070 --> 00:05:59,440
do more than what the ABI prescribes and

00:05:56,860 --> 00:06:02,530
so as will come to later one of the

00:05:59,440 --> 00:06:05,440
goals of the ABI was to allow different

00:06:02,530 --> 00:06:09,340
toolchain vendors to have quality of

00:06:05,440 --> 00:06:10,900
implementation differentiation in that

00:06:09,340 --> 00:06:14,290
in their toolkit the idea of the API

00:06:10,900 --> 00:06:18,250
wasn't to stamp out sort of them vendors

00:06:14,290 --> 00:06:21,400
abilities to improve their tool kids ok

00:06:18,250 --> 00:06:22,570
so ok just a little bit about here what

00:06:21,400 --> 00:06:25,000
we're going to be talking about next few

00:06:22,570 --> 00:06:26,710
slides about what's maybe I will go

00:06:25,000 --> 00:06:28,720
through what does it what does maybe i

00:06:26,710 --> 00:06:31,780
define why do I need to care about it at

00:06:28,720 --> 00:06:33,580
all a little bit about arm in the 2000s

00:06:31,780 --> 00:06:36,190
which is where the ABI sort of was

00:06:33,580 --> 00:06:40,220
defined and a bit about the motivations

00:06:36,190 --> 00:06:42,290
and principles behind the ABI ok so

00:06:40,220 --> 00:06:44,060
here's some a little bit of at some

00:06:42,290 --> 00:06:46,400
points that I've put put down for what

00:06:44,060 --> 00:06:48,170
does maybe i define I've put bits in

00:06:46,400 --> 00:06:50,300
black as the sorts of things that you

00:06:48,170 --> 00:06:53,330
probably think you would have to do for

00:06:50,300 --> 00:06:55,670
a C and C++ API the bits and blue are

00:06:53,330 --> 00:06:57,950
kind of well are they part of the Navy I

00:06:55,670 --> 00:06:59,630
or not should that be something that arm

00:06:57,950 --> 00:07:02,110
should be writing down these documents

00:06:59,630 --> 00:07:04,220
about how these things should work and

00:07:02,110 --> 00:07:05,480
but typically what you'll be looking at

00:07:04,220 --> 00:07:06,920
is something that if you're going to

00:07:05,480 --> 00:07:09,740
call functions into a different object

00:07:06,920 --> 00:07:11,840
files they need to be able to know the

00:07:09,740 --> 00:07:13,880
stacked layout which parameters passed

00:07:11,840 --> 00:07:17,090
in registers what the sizes are the

00:07:13,880 --> 00:07:18,710
various things that you're passing if

00:07:17,090 --> 00:07:20,510
you're going to throw an exception from

00:07:18,710 --> 00:07:22,840
one object to another what's the

00:07:20,510 --> 00:07:25,310
exception format that type of thing and

00:07:22,840 --> 00:07:26,810
you know if you've been to to link two

00:07:25,310 --> 00:07:28,460
objects together are they the same

00:07:26,810 --> 00:07:30,790
object file formats these are sort of

00:07:28,460 --> 00:07:33,680
things that would come through there

00:07:30,790 --> 00:07:35,210
later on you've got things like compiler

00:07:33,680 --> 00:07:36,919
helper functions so to give you an

00:07:35,210 --> 00:07:39,260
example of a compiler health helper

00:07:36,919 --> 00:07:42,590
function that was not part of the ABI

00:07:39,260 --> 00:07:45,919
arm CC has a function called something

00:07:42,590 --> 00:07:48,410
like common switch 8 which is part of

00:07:45,919 --> 00:07:52,160
them part of an implementation of a

00:07:48,410 --> 00:07:55,040
switch statement and it was for stun in

00:07:52,160 --> 00:07:57,350
some cases it was better to have to save

00:07:55,040 --> 00:08:00,260
code size to call out to a function that

00:07:57,350 --> 00:08:02,330
would then interpret the table and that

00:08:00,260 --> 00:08:05,479
sort of thing is this a compiler helper

00:08:02,330 --> 00:08:07,600
function that you would need to have if

00:08:05,479 --> 00:08:10,040
you were to actually use the object file

00:08:07,600 --> 00:08:13,400
so one of the things that you go to when

00:08:10,040 --> 00:08:18,050
you look for an ABI to what degree can

00:08:13,400 --> 00:08:20,120
use them can you worm and standardize

00:08:18,050 --> 00:08:21,860
the sort of common set of compiler

00:08:20,120 --> 00:08:23,990
helper functions that get used across

00:08:21,860 --> 00:08:25,880
compilers so again that's inserted one

00:08:23,990 --> 00:08:28,729
of those things where should that be

00:08:25,880 --> 00:08:32,510
part of the ABI or not that's a sort of

00:08:28,729 --> 00:08:33,830
design decision for the API ok so why

00:08:32,510 --> 00:08:37,130
should I actually care about all of this

00:08:33,830 --> 00:08:39,169
now ideally you don't if you're a user

00:08:37,130 --> 00:08:41,000
of these tools everything should

00:08:39,169 --> 00:08:44,720
hopefully be extracted away from you and

00:08:41,000 --> 00:08:46,070
everything should just work if you

00:08:44,720 --> 00:08:48,530
certainly should need to care if you're

00:08:46,070 --> 00:08:50,089
implementing a development tool of any

00:08:48,530 --> 00:08:52,640
sort of thing or any sort of kind of

00:08:50,089 --> 00:08:53,170
code generation and certainly the sort

00:08:52,640 --> 00:08:54,940
of calling

00:08:53,170 --> 00:08:58,329
mentions if you're developing some kind

00:08:54,940 --> 00:09:00,940
of jet or other sort of them library

00:08:58,329 --> 00:09:03,610
based things it's also very useful if

00:09:00,940 --> 00:09:05,800
you're developing or distributing

00:09:03,610 --> 00:09:07,570
cross-platform binaries or cross

00:09:05,800 --> 00:09:11,170
toolchain binaries and you need to know

00:09:07,570 --> 00:09:14,680
what compatibility that you can expect

00:09:11,170 --> 00:09:16,360
and what happen and also how to track

00:09:14,680 --> 00:09:21,550
down what's gone wrong when it doesn't

00:09:16,360 --> 00:09:23,529
quite work as its expected okay so we're

00:09:21,550 --> 00:09:26,620
going from now okay what is an ABI to

00:09:23,529 --> 00:09:29,380
what were some of the motivations around

00:09:26,620 --> 00:09:34,360
the ABI when it first came through as I

00:09:29,380 --> 00:09:39,399
mentioned before in early 2003 the we

00:09:34,360 --> 00:09:42,610
didn't even have the eia 64 an ABI for

00:09:39,399 --> 00:09:46,079
C++ that was only just coming together

00:09:42,610 --> 00:09:48,730
at that time so there's a lot of

00:09:46,079 --> 00:09:51,579
standardization as it's all coming to

00:09:48,730 --> 00:09:53,019
fruition at this point so it there

00:09:51,579 --> 00:09:55,120
wasn't the sort of read readily

00:09:53,019 --> 00:09:57,399
available things to jump on at that

00:09:55,120 --> 00:10:00,730
particular point so what we have in the

00:09:57,399 --> 00:10:04,449
arm ecosystem was a huge number of tall

00:10:00,730 --> 00:10:06,760
chains and our houses one of the one of

00:10:04,449 --> 00:10:08,410
the guys back at an ad said they were

00:10:06,760 --> 00:10:11,649
upwards of 20 commercially available

00:10:08,410 --> 00:10:13,829
call chains for arm each of it which had

00:10:11,649 --> 00:10:17,350
slightly different implementations of

00:10:13,829 --> 00:10:19,000
the procedure called standard object

00:10:17,350 --> 00:10:23,440
news different object file formats

00:10:19,000 --> 00:10:25,329
different library formats and one of the

00:10:23,440 --> 00:10:28,600
main problems the ABI was this was

00:10:25,329 --> 00:10:31,209
designed to solve was okay as an artist

00:10:28,600 --> 00:10:32,680
bender you had to shift about 20

00:10:31,209 --> 00:10:34,329
different types of binary to be

00:10:32,680 --> 00:10:38,649
compatible with the 20 different types

00:10:34,329 --> 00:10:40,449
of developmental and that was a huge to

00:10:38,649 --> 00:10:42,610
the hindrance in the market at that

00:10:40,449 --> 00:10:44,550
particular point but it's also there are

00:10:42,610 --> 00:10:47,290
also differences in platforms as well

00:10:44,550 --> 00:10:50,410
the arm 11 family had only just been

00:10:47,290 --> 00:10:52,779
released and the arm 11 is kind of the

00:10:50,410 --> 00:10:54,880
first processor that could just about

00:10:52,779 --> 00:10:58,120
acceptable run linux I would think there

00:10:54,880 --> 00:11:00,579
have been there are some ships on the

00:10:58,120 --> 00:11:02,589
online sort of run Linux I don't know

00:11:00,579 --> 00:11:04,560
quite how successful you work all those

00:11:02,589 --> 00:11:07,150
efforts worth

00:11:04,560 --> 00:11:10,270
as it mentions on the bottom slide there

00:11:07,150 --> 00:11:12,550
the consumer electronics live live

00:11:10,270 --> 00:11:14,440
explore and more self which i think is

00:11:12,550 --> 00:11:16,720
now merged into one of the other looks

00:11:14,440 --> 00:11:21,190
of linux forums was only just starting

00:11:16,720 --> 00:11:23,230
up in june 2003 so linux was something

00:11:21,190 --> 00:11:26,040
that was taught us to be a strong future

00:11:23,230 --> 00:11:28,690
direction at this point but the actual

00:11:26,040 --> 00:11:32,710
dominant mobile operating system was

00:11:28,690 --> 00:11:36,010
actually symbian at that point and if

00:11:32,710 --> 00:11:37,840
you were you know pre iphone 2003 who is

00:11:36,010 --> 00:11:41,770
to say that symbian might not have been

00:11:37,840 --> 00:11:44,530
here today as that particular point so

00:11:41,770 --> 00:11:45,550
there's lots and lots of different and i

00:11:44,530 --> 00:11:47,230
guess you could say the whole market

00:11:45,550 --> 00:11:50,350
with much more fragmented than it is

00:11:47,230 --> 00:11:52,090
than it is today okay and here are some

00:11:50,350 --> 00:11:54,030
pictures of them it's a certain things

00:11:52,090 --> 00:11:56,920
that some devices back from a day

00:11:54,030 --> 00:12:00,370
including the nokia n-gage which i

00:11:56,920 --> 00:12:02,140
believe you held sideways and it had one

00:12:00,370 --> 00:12:03,850
of the first internet means as people

00:12:02,140 --> 00:12:08,950
walking around with south side talking

00:12:03,850 --> 00:12:11,890
and at arm off device ramp arm and their

00:12:08,950 --> 00:12:14,830
various sort of symbian and nokia s40

00:12:11,890 --> 00:12:16,839
feature phones and adapting a particular

00:12:14,830 --> 00:12:18,700
point and I thinking six even though I

00:12:16,839 --> 00:12:22,089
suppose you say a lot of arms revenue

00:12:18,700 --> 00:12:23,770
still comes from mobile but I think more

00:12:22,089 --> 00:12:27,640
of it came from mobile to mobile segment

00:12:23,770 --> 00:12:29,980
at that time than anything else okay so

00:12:27,640 --> 00:12:34,030
starting from that mess where do we go

00:12:29,980 --> 00:12:38,320
for with the ABI so and at that

00:12:34,030 --> 00:12:41,020
particular point in the ia 64 C++ ABI

00:12:38,320 --> 00:12:43,839
was recently available and implemented

00:12:41,020 --> 00:12:46,810
in GCC and the commercially available

00:12:43,839 --> 00:12:49,330
EDG front end which a lot of commercial

00:12:46,810 --> 00:12:52,390
compilers were using for their C++ front

00:12:49,330 --> 00:12:55,390
end so you had a point but jumping on

00:12:52,390 --> 00:12:57,400
point for c++ at that point where you

00:12:55,390 --> 00:12:59,380
could actually have a reasonable chance

00:12:57,400 --> 00:13:01,450
of compiling something on one C++

00:12:59,380 --> 00:13:04,210
compiler and being able to link it

00:13:01,450 --> 00:13:07,330
against an another object for that

00:13:04,210 --> 00:13:09,670
particular point linux was showing

00:13:07,330 --> 00:13:12,970
strong signs of being something big for

00:13:09,670 --> 00:13:14,950
the future and linux also had the

00:13:12,970 --> 00:13:16,240
advantage of coming coming with a lot of

00:13:14,950 --> 00:13:17,740
existing standards

00:13:16,240 --> 00:13:20,470
if you wanted to run on Linux you had to

00:13:17,740 --> 00:13:23,890
do with the Linux way so anything that

00:13:20,470 --> 00:13:28,480
we wrote into the ABI have support linux

00:13:23,890 --> 00:13:30,399
in some way and as i mentioned before we

00:13:28,480 --> 00:13:33,940
needed to support the idea of our top

00:13:30,399 --> 00:13:35,589
spenders needing to reduce the amount of

00:13:33,940 --> 00:13:39,450
binary packages that they have to shape

00:13:35,589 --> 00:13:44,320
and test whatever the idea here was to

00:13:39,450 --> 00:13:46,870
also encourage a market in binary

00:13:44,320 --> 00:13:48,490
objects now this sounds a bit weird me

00:13:46,870 --> 00:13:51,459
talking about this in a sort of open

00:13:48,490 --> 00:13:54,250
source type conference as it sort of

00:13:51,459 --> 00:13:58,060
turns out the market to binary binary

00:13:54,250 --> 00:14:00,279
packages didn't really come together and

00:13:58,060 --> 00:14:02,140
I think it's a lot of it's now the

00:14:00,279 --> 00:14:04,149
market is now in source level

00:14:02,140 --> 00:14:06,880
compatibility not binary compatibility

00:14:04,149 --> 00:14:10,300
but back in 2003 we couldn't predict

00:14:06,880 --> 00:14:13,779
couldn't have predicted that now notice

00:14:10,300 --> 00:14:17,080
the distinction here between enable

00:14:13,779 --> 00:14:18,580
independent binary packages now this

00:14:17,080 --> 00:14:20,920
doesn't necessarily mean that the goal

00:14:18,580 --> 00:14:23,170
was that I can take any object compile

00:14:20,920 --> 00:14:26,890
with any compiler and link it with any

00:14:23,170 --> 00:14:30,130
linker against any C library that was

00:14:26,890 --> 00:14:32,320
thought of as a pipe dream and it

00:14:30,130 --> 00:14:33,910
wouldnt in those in the university was

00:14:32,320 --> 00:14:35,380
it would have been too difficult to get

00:14:33,910 --> 00:14:37,839
everyone to agree on all of the

00:14:35,380 --> 00:14:38,649
standards and if we had we wouldn't we

00:14:37,839 --> 00:14:41,110
would have killed all of the

00:14:38,649 --> 00:14:43,540
differentiation in the market the idea

00:14:41,110 --> 00:14:46,930
is is that you would develop your binary

00:14:43,540 --> 00:14:50,589
package with an ABI compliant interface

00:14:46,930 --> 00:14:53,260
but behind the interface you were free

00:14:50,589 --> 00:14:55,720
to sort of use any sort of nasty tricks

00:14:53,260 --> 00:14:57,040
that you wanted as long as at the

00:14:55,720 --> 00:15:01,240
interface points you would then

00:14:57,040 --> 00:15:03,279
compliant with that particular point ok

00:15:01,240 --> 00:15:06,370
so here are the principles that I kind

00:15:03,279 --> 00:15:09,279
of went back through the sort of email

00:15:06,370 --> 00:15:10,990
trails to trying to find out from the

00:15:09,279 --> 00:15:11,740
original things I think we would

00:15:10,990 --> 00:15:13,360
probably have some of the original

00:15:11,740 --> 00:15:14,620
authors in the audience here who can

00:15:13,360 --> 00:15:17,680
correct me if I've got any of these

00:15:14,620 --> 00:15:19,959
wrong but some of the things that you've

00:15:17,680 --> 00:15:22,720
got to look for when you're reading the

00:15:19,959 --> 00:15:25,480
ABI first thing is that they don't stand

00:15:22,720 --> 00:15:26,470
alone they will refer out for the

00:15:25,480 --> 00:15:29,320
documents

00:15:26,470 --> 00:15:31,360
you have to interpret them with the

00:15:29,320 --> 00:15:34,210
architecture documents so the ABI was

00:15:31,360 --> 00:15:38,560
say what happens in every possible call

00:15:34,210 --> 00:15:40,330
in case if say for example you can work

00:15:38,560 --> 00:15:44,800
out what the correct one is by reading

00:15:40,330 --> 00:15:46,690
the arm arm it will build upon industry

00:15:44,800 --> 00:15:48,790
standards as much as possible there's

00:15:46,690 --> 00:15:50,440
absolutely no point in on developing its

00:15:48,790 --> 00:15:54,130
own standards when there are existing

00:15:50,440 --> 00:15:56,650
industry standard ones available one of

00:15:54,130 --> 00:15:59,410
the interesting point was that we were

00:15:56,650 --> 00:16:02,250
expecting platform owners where they

00:15:59,410 --> 00:16:07,030
said okay we've got this base level are

00:16:02,250 --> 00:16:10,780
defined ABI now arm can't define the ABI

00:16:07,030 --> 00:16:13,180
for every possible operating system that

00:16:10,780 --> 00:16:16,240
could be built but by any potential

00:16:13,180 --> 00:16:19,930
customer the idea was the arm with

00:16:16,240 --> 00:16:22,360
divine device well defined the neutral

00:16:19,930 --> 00:16:27,820
part that would common to all or offer

00:16:22,360 --> 00:16:31,270
various such as flavors of ABI for that

00:16:27,820 --> 00:16:33,220
then platform owners could then write

00:16:31,270 --> 00:16:35,380
their own documentation basically saying

00:16:33,220 --> 00:16:36,850
you must conform to the are maybe I and

00:16:35,380 --> 00:16:39,010
if you want to run your application on

00:16:36,850 --> 00:16:40,660
our platform you need to conform to this

00:16:39,010 --> 00:16:43,390
additional ABI which we will then

00:16:40,660 --> 00:16:45,430
publish ourselves as it's turned out

00:16:43,390 --> 00:16:46,960
platform owners are remarkably

00:16:45,430 --> 00:16:50,470
reluctance to write that type of

00:16:46,960 --> 00:16:52,630
documentation so a lot of it tends to be

00:16:50,470 --> 00:16:54,580
if it works it works or is defined by

00:16:52,630 --> 00:16:57,550
its implementation not necessarily by

00:16:54,580 --> 00:17:00,610
any particular document yes any

00:16:57,550 --> 00:17:05,890
questions so far there's a microphone

00:17:00,610 --> 00:17:10,150
here and what we can pass it around it's

00:17:05,890 --> 00:17:13,240
not I'll carry on ok so the conformance

00:17:10,150 --> 00:17:14,800
to the ABI is as follows what a lot of

00:17:13,240 --> 00:17:18,100
people in the compiler area will call be

00:17:14,800 --> 00:17:20,350
as if role in that if no obscure no

00:17:18,100 --> 00:17:22,660
observer can determine that you didn't

00:17:20,350 --> 00:17:25,000
conform then you didn't need to conform

00:17:22,660 --> 00:17:29,850
so and then that particular point with a

00:17:25,000 --> 00:17:33,730
little yes yes that type of thing and

00:17:29,850 --> 00:17:35,890
toolchain vendors even can differentiate

00:17:33,730 --> 00:17:37,850
accurate quality of implementation level

00:17:35,890 --> 00:17:40,010
even at

00:17:37,850 --> 00:17:42,740
imitates no NSA to extend into fakes

00:17:40,010 --> 00:17:45,260
that's like the published interface as

00:17:42,740 --> 00:17:48,080
the binary package basically one says

00:17:45,260 --> 00:17:50,390
well if a tool change can say oh I can I

00:17:48,080 --> 00:17:52,850
can work out that all of the objects are

00:17:50,390 --> 00:17:55,190
from the same platform therefore I can

00:17:52,850 --> 00:17:57,289
play all sorts of nasty tricks at length

00:17:55,190 --> 00:17:59,330
time because I know that all of the

00:17:57,289 --> 00:18:02,900
objects is from my tool chain then thats

00:17:59,330 --> 00:18:08,240
still allowed it's really the ideas that

00:18:02,900 --> 00:18:11,150
you've used if you want compatibility

00:18:08,240 --> 00:18:12,860
you produce this interface and but it's

00:18:11,150 --> 00:18:14,360
not to stop anyone from going above and

00:18:12,860 --> 00:18:18,049
beyond that if they've got a very clever

00:18:14,360 --> 00:18:22,460
tool chain okay and the final bit is

00:18:18,049 --> 00:18:27,860
where we had several existing tool

00:18:22,460 --> 00:18:30,049
chains with very strong views on certain

00:18:27,860 --> 00:18:32,659
options and there would be no way of

00:18:30,049 --> 00:18:35,080
getting consensus among them so in

00:18:32,659 --> 00:18:38,210
typical example of this adenine sighs

00:18:35,080 --> 00:18:39,799
some people were adamant that an enum

00:18:38,210 --> 00:18:42,710
should be the smallest possible size

00:18:39,799 --> 00:18:44,720
possible this is very strong in the

00:18:42,710 --> 00:18:47,090
embedded sort of space where you need

00:18:44,720 --> 00:18:50,530
small a proximal clothes design whereas

00:18:47,090 --> 00:18:52,580
in the linux area an enum is an end and

00:18:50,530 --> 00:18:54,169
there was no way you were going to get

00:18:52,580 --> 00:18:56,630
either one of those camps to change

00:18:54,169 --> 00:18:58,280
their existing behavior so when you have

00:18:56,630 --> 00:19:00,080
two camps that won't change their

00:18:58,280 --> 00:19:01,549
behavior you have to provide some kind

00:19:00,080 --> 00:19:04,250
of command line option to give a choice

00:19:01,549 --> 00:19:06,980
and then you have to then provide some

00:19:04,250 --> 00:19:09,500
kind of option for tools to detect the

00:19:06,980 --> 00:19:14,600
incompatibility and then diagnose errors

00:19:09,500 --> 00:19:16,700
because of that choice so we're out at

00:19:14,600 --> 00:19:18,559
the sort of motivation principals type

00:19:16,700 --> 00:19:22,340
thing we're now sort of on to how the

00:19:18,559 --> 00:19:25,010
documents are structured so this is half

00:19:22,340 --> 00:19:28,340
of the document half of a picture that's

00:19:25,010 --> 00:19:30,320
in one of the I guess you call it the

00:19:28,340 --> 00:19:33,650
introduction to the API document you can

00:19:30,320 --> 00:19:35,299
download from the arm website I've got

00:19:33,650 --> 00:19:36,830
the other half on the next slide when I

00:19:35,299 --> 00:19:39,470
put it all on one documented which is

00:19:36,830 --> 00:19:41,450
the best impossible to read this is the

00:19:39,470 --> 00:19:43,900
bottom half and it's explaining the sort

00:19:41,450 --> 00:19:49,210
of an contents

00:19:43,900 --> 00:19:51,370
of of the ABI and in terms of them the

00:19:49,210 --> 00:19:52,720
documents and the actual underlying

00:19:51,370 --> 00:19:55,510
standards of which they're based

00:19:52,720 --> 00:19:57,370
obviously that I say they're Scion if

00:19:55,510 --> 00:19:59,800
scientists not come out of Sion here

00:19:57,370 --> 00:20:04,330
it's come out as a very light green but

00:19:59,800 --> 00:20:07,360
anyhow the so this is what we would call

00:20:04,330 --> 00:20:09,430
the base platforms or based standards

00:20:07,360 --> 00:20:11,620
ABI I'll go into what the base platform

00:20:09,430 --> 00:20:14,800
avi is on the next one where that's

00:20:11,620 --> 00:20:17,020
where it interfaces with platforms so

00:20:14,800 --> 00:20:19,360
you have the simple thing as a al arm

00:20:17,020 --> 00:20:22,390
else builds across on generic health

00:20:19,360 --> 00:20:27,040
dwarf a dwarf built on top of the

00:20:22,390 --> 00:20:29,800
existing dwarf we have c++ ABI procedure

00:20:27,040 --> 00:20:34,630
called standard its arms own exceptions

00:20:29,800 --> 00:20:37,750
ABI a runtime I ABI and the run run time

00:20:34,630 --> 00:20:40,060
and Sela baby I a slightly different the

00:20:37,750 --> 00:20:43,300
runtime ABI includes things like a bi

00:20:40,060 --> 00:20:45,160
men copy that type of sync whereas the C

00:20:43,300 --> 00:20:49,450
library ABI is a bit higher level than

00:20:45,160 --> 00:20:51,790
that ok so at the top level this is

00:20:49,450 --> 00:20:54,310
where things get slightly interesting in

00:20:51,790 --> 00:20:58,900
the terms at the time the API was

00:20:54,310 --> 00:21:01,120
written we had probably four different

00:20:58,900 --> 00:21:03,930
types of operating system that were

00:21:01,120 --> 00:21:06,820
likely to run on top of the ABI now

00:21:03,930 --> 00:21:10,030
today you could probably bring that down

00:21:06,820 --> 00:21:13,150
too I'll let you guess which ones and

00:21:10,030 --> 00:21:15,400
but on the far left you have the bare

00:21:13,150 --> 00:21:17,680
metal art house that's where everything

00:21:15,400 --> 00:21:21,190
is statically linked you don't have any

00:21:17,680 --> 00:21:23,050
dynamic linking going on and so that's

00:21:21,190 --> 00:21:25,570
generally the simplest possible thing

00:21:23,050 --> 00:21:28,060
for interface to an operating system

00:21:25,570 --> 00:21:30,310
because the person defining all of those

00:21:28,060 --> 00:21:33,550
libraries in the artist is responsible

00:21:30,310 --> 00:21:38,020
for everything and hamas at the time

00:21:33,550 --> 00:21:42,490
wanted to go for and a shared library

00:21:38,020 --> 00:21:46,150
architecture but only using or not using

00:21:42,490 --> 00:21:48,840
an MMU so they had a multiple processes

00:21:46,150 --> 00:21:52,270
but would only use one address space and

00:21:48,840 --> 00:21:54,300
so that's one potential way you could

00:21:52,270 --> 00:22:00,190
write an operating

00:21:54,300 --> 00:22:01,420
symbian despite well Cindy I guess you

00:22:00,190 --> 00:22:05,440
could say followed a very much the

00:22:01,420 --> 00:22:07,570
microsoft way of doing dll's so if you

00:22:05,440 --> 00:22:12,880
look at the symbian dll they look very

00:22:07,570 --> 00:22:14,800
similar to microsoft p or cost dll so

00:22:12,880 --> 00:22:19,450
that's a sort of compared to a linux

00:22:14,800 --> 00:22:20,860
tile shared library the dll is in some

00:22:19,450 --> 00:22:23,410
ways more efficient it's more

00:22:20,860 --> 00:22:25,240
stripped-down but it there are

00:22:23,410 --> 00:22:27,610
compromises because it's stripped down

00:22:25,240 --> 00:22:29,200
and you have to do things like tell the

00:22:27,610 --> 00:22:31,180
compiler that you're importing with

00:22:29,200 --> 00:22:33,310
things like dll important in our legs

00:22:31,180 --> 00:22:35,590
bones whereas the linux shared library

00:22:33,310 --> 00:22:37,960
is very much down to i want to minimize

00:22:35,590 --> 00:22:39,310
the distinction between somebody using a

00:22:37,960 --> 00:22:40,990
shared library and using a static

00:22:39,310 --> 00:22:44,320
library and that's just two different

00:22:40,990 --> 00:22:47,170
design goals but one of the strange

00:22:44,320 --> 00:22:49,570
things at the time is we thought that we

00:22:47,170 --> 00:22:51,280
thought that the embedded market for arm

00:22:49,570 --> 00:22:53,710
was much more likely to go down the

00:22:51,280 --> 00:22:57,160
Symbian route because it was more

00:22:53,710 --> 00:23:00,570
efficient than the Linux route as things

00:22:57,160 --> 00:23:03,430
have turned out symbian is now gone

00:23:00,570 --> 00:23:05,800
partner palmas I think turned into doing

00:23:03,430 --> 00:23:08,620
some kind of web where the JavaScript

00:23:05,800 --> 00:23:10,750
basting then got bought out and we're

00:23:08,620 --> 00:23:13,270
kind of less now with the artists and

00:23:10,750 --> 00:23:15,280
we're left with linux and these sort of

00:23:13,270 --> 00:23:18,130
other ways of doing operating system

00:23:15,280 --> 00:23:20,470
like things have gone but the general

00:23:18,130 --> 00:23:22,390
idea at the API level was that we

00:23:20,470 --> 00:23:25,090
thought that if you could map your

00:23:22,390 --> 00:23:26,710
replicate your operating system dynamic

00:23:25,090 --> 00:23:30,940
loading type into one of those four

00:23:26,710 --> 00:23:33,520
families you could abstract at leading

00:23:30,940 --> 00:23:35,590
what the ABI needed to talk about down

00:23:33,520 --> 00:23:38,440
to supporting one of these four types

00:23:35,590 --> 00:23:40,900
and you would then have post-processing

00:23:38,440 --> 00:23:43,930
going on as a platform level which are

00:23:40,900 --> 00:23:45,730
going to later to map your ABI

00:23:43,930 --> 00:23:50,110
compliance objects into what your

00:23:45,730 --> 00:23:54,160
platform would expect ok this is just a

00:23:50,110 --> 00:23:57,010
very simple showing healthy and ABI

00:23:54,160 --> 00:23:59,770
would expect to be layered with the

00:23:57,010 --> 00:24:01,210
different types of standards at the

00:23:59,770 --> 00:24:04,570
bottom you and have the industry

00:24:01,210 --> 00:24:05,810
standard so arm else is built upon the

00:24:04,570 --> 00:24:08,390
generic

00:24:05,810 --> 00:24:15,980
I think tht is dancer to Linda's I stuns

00:24:08,390 --> 00:24:21,200
itself love it okay right my assumptions

00:24:15,980 --> 00:24:24,140
are dealing okay so I've got that wrong

00:24:21,200 --> 00:24:26,780
sorry about that and so yes the current

00:24:24,140 --> 00:24:28,280
home of the ABI is distilled let's go

00:24:26,780 --> 00:24:31,490
website although I don't know exactly

00:24:28,280 --> 00:24:37,130
what what's go is these days and only

00:24:31,490 --> 00:24:38,510
way out was a shell yes but it's still

00:24:37,130 --> 00:24:41,150
where you find the document if you want

00:24:38,510 --> 00:24:43,850
to go go for it so our mouth is what

00:24:41,150 --> 00:24:46,850
contains in else turns the processor

00:24:43,850 --> 00:24:49,610
specific so these are concepts specific

00:24:46,850 --> 00:24:51,860
to arms interpretation of else so things

00:24:49,610 --> 00:24:54,620
like all the relocation directives all

00:24:51,860 --> 00:24:59,150
the flags that live in the process of

00:24:54,620 --> 00:25:00,710
space the young platform specific

00:24:59,150 --> 00:25:04,810
documents these are things where you

00:25:00,710 --> 00:25:06,890
have concepts the stick to a platform

00:25:04,810 --> 00:25:11,120
implementation of elf so for example

00:25:06,890 --> 00:25:15,440
dynamic linking on Linux that's not an

00:25:11,120 --> 00:25:18,620
arm concept that is a Linux concept or

00:25:15,440 --> 00:25:23,840
system five our full concept to be

00:25:18,620 --> 00:25:28,150
precise i guess so beyond our mouth

00:25:23,840 --> 00:25:30,890
there is a sort of virtual document that

00:25:28,150 --> 00:25:32,780
represents the platform interpretation

00:25:30,890 --> 00:25:34,640
and rules on out and typically that

00:25:32,780 --> 00:25:38,540
that's written for an architecture in a

00:25:34,640 --> 00:25:40,370
system five are for professor

00:25:38,540 --> 00:25:44,930
supplements which doesn't actually exist

00:25:40,370 --> 00:25:45,860
for our couture forearm but i think it

00:25:44,930 --> 00:25:48,860
does for quite a lot of other

00:25:45,860 --> 00:25:52,880
architectures so really you can see the

00:25:48,860 --> 00:25:54,230
are maybe I as covering bits of what

00:25:52,880 --> 00:25:56,720
would normally go into the process

00:25:54,230 --> 00:25:59,750
specific supplement and other things as

00:25:56,720 --> 00:26:02,810
well because it's an embedded ABI okay

00:25:59,750 --> 00:26:06,260
so i'm not going to read all of that out

00:26:02,810 --> 00:26:08,000
it's basically just a list of going

00:26:06,260 --> 00:26:10,160
through of what the actual documents are

00:26:08,000 --> 00:26:13,600
what they do as i mentioned before

00:26:10,160 --> 00:26:16,880
generally the ABI for a particular run

00:26:13,600 --> 00:26:18,380
architecture will be in the form of a

00:26:16,880 --> 00:26:20,600
system five

00:26:18,380 --> 00:26:22,610
and process specific supplement that

00:26:20,600 --> 00:26:25,600
these sort of have been broken out into

00:26:22,610 --> 00:26:28,970
separate documents to the are maybe I

00:26:25,600 --> 00:26:30,740
okay so we're now going to move on from

00:26:28,970 --> 00:26:34,580
sort of the general structure to the API

00:26:30,740 --> 00:26:36,440
to relocatable object compatibility so

00:26:34,580 --> 00:26:38,900
I've now got another document copied

00:26:36,440 --> 00:26:41,270
from one of the API Docs and it's a bit

00:26:38,900 --> 00:26:42,860
complicated to understand so I'll be

00:26:41,270 --> 00:26:46,100
going through this a bit a bit more

00:26:42,860 --> 00:26:49,760
slowly so as I mentioned before there's

00:26:46,100 --> 00:26:52,940
no expectation that you can arbitrarily

00:26:49,760 --> 00:26:55,430
choose an object and compile it with any

00:26:52,940 --> 00:26:57,470
header linking with any linker against

00:26:55,430 --> 00:26:59,060
any possible see libraries there are

00:26:57,470 --> 00:27:02,060
some restrictions put in place and this

00:26:59,060 --> 00:27:04,400
is what this document tries to come

00:27:02,060 --> 00:27:07,400
through so looking looking here we have

00:27:04,400 --> 00:27:11,030
and you can see the difference in quotes

00:27:07,400 --> 00:27:12,740
between that and that and that the head

00:27:11,030 --> 00:27:15,500
of one is your applications library that

00:27:12,740 --> 00:27:18,650
will remain the same in both ways you

00:27:15,500 --> 00:27:21,710
have one compiler toolchain here another

00:27:18,650 --> 00:27:23,630
compiler toolchain here and at the

00:27:21,710 --> 00:27:25,940
bottom we have both of these compilers

00:27:23,630 --> 00:27:27,850
must conform to whatever platform you're

00:27:25,940 --> 00:27:31,040
intended to run your executive belong

00:27:27,850 --> 00:27:34,370
but the general idea is that if you're

00:27:31,040 --> 00:27:37,220
using compiler one you have to use the

00:27:34,370 --> 00:27:40,580
header files that come with this runtime

00:27:37,220 --> 00:27:42,320
libraries that are with compiler one so

00:27:40,580 --> 00:27:44,750
these are things like and even within

00:27:42,320 --> 00:27:48,140
the API and potentially standard

00:27:44,750 --> 00:27:49,610
libraries like the C library you may get

00:27:48,140 --> 00:27:53,270
differences in things like how they

00:27:49,610 --> 00:27:55,910
define varargs whatever so the idea of

00:27:53,270 --> 00:27:58,700
this was on CC you would use the MCC had

00:27:55,910 --> 00:28:02,300
a file that this was GCC reduced the GCC

00:27:58,700 --> 00:28:04,880
header file for example once you've

00:28:02,300 --> 00:28:07,400
compiled your object you both end up

00:28:04,880 --> 00:28:10,610
with an elf file now when I say here

00:28:07,400 --> 00:28:12,380
includes include private helpers if we

00:28:10,610 --> 00:28:15,530
go back to the example I gave before of

00:28:12,380 --> 00:28:17,930
the arms which ain't things that is not

00:28:15,530 --> 00:28:20,320
standardized it's an arm CC specific

00:28:17,930 --> 00:28:23,540
thing so you couldn't expect to say

00:28:20,320 --> 00:28:26,930
Lincoln well if the object didn't

00:28:23,540 --> 00:28:30,170
contain the implementation of switch aid

00:28:26,930 --> 00:28:31,570
then you would either have to supply a

00:28:30,170 --> 00:28:35,640
library containing

00:28:31,570 --> 00:28:38,250
definition of switch aid or have that

00:28:35,640 --> 00:28:40,510
included within the object some somehow

00:28:38,250 --> 00:28:43,090
otherwise if you then tried to link it

00:28:40,510 --> 00:28:46,060
with sagan uld against the canoe

00:28:43,090 --> 00:28:47,980
libraries then you would end up with

00:28:46,060 --> 00:28:51,160
that comments which ain't not being

00:28:47,980 --> 00:28:53,350
there so one principle is that if

00:28:51,160 --> 00:28:55,300
there's an if there's a compiler cystic

00:28:53,350 --> 00:28:58,510
healthy function that's not standardized

00:28:55,300 --> 00:29:01,630
then it has to be contained within its

00:28:58,510 --> 00:29:05,370
own object or you supply a separate

00:29:01,630 --> 00:29:07,810
compiler pedophile to go with the link

00:29:05,370 --> 00:29:09,250
so once we get down to here we're now at

00:29:07,810 --> 00:29:11,140
the linker stage so you could say that

00:29:09,250 --> 00:29:13,030
if this was the arm compiler tool chain

00:29:11,140 --> 00:29:15,940
on compiler five this would be armed

00:29:13,030 --> 00:29:18,430
link this was GCC you would end up with

00:29:15,940 --> 00:29:21,820
devgan uld or gold at this particular

00:29:18,430 --> 00:29:24,490
point and the idea here is that you then

00:29:21,820 --> 00:29:27,940
have to mix you both are not mix you

00:29:24,490 --> 00:29:30,280
have to match the linker with the

00:29:27,940 --> 00:29:32,130
platform libraries that you're going to

00:29:30,280 --> 00:29:34,480
be using this will be arms

00:29:32,130 --> 00:29:37,120
implementation binary libraries for the

00:29:34,480 --> 00:29:38,530
C library at which you use del vino el

00:29:37,120 --> 00:29:40,840
be the only thing you could

00:29:38,530 --> 00:29:43,360
realistically expect to work would be

00:29:40,840 --> 00:29:46,060
something like a new labels unit see you

00:29:43,360 --> 00:29:48,580
couldn't expect to take arms see library

00:29:46,060 --> 00:29:51,100
and put it on the command line with good

00:29:48,580 --> 00:29:53,650
news linker and expecting to work the

00:29:51,100 --> 00:29:56,920
idea basically is the same as the headed

00:29:53,650 --> 00:29:59,170
here and the libraries here is that tool

00:29:56,920 --> 00:30:02,860
came manufacturers are expected or

00:29:59,170 --> 00:30:05,410
allowed to collude between through here

00:30:02,860 --> 00:30:07,330
so arms linker would understand special

00:30:05,410 --> 00:30:10,330
things that are in the arm see libraries

00:30:07,330 --> 00:30:12,400
and could do special optimizations based

00:30:10,330 --> 00:30:15,370
on them and the ABI wanted to preserve

00:30:12,400 --> 00:30:17,500
the ability to auto manufacturers to be

00:30:15,370 --> 00:30:19,630
able to basically collude between their

00:30:17,500 --> 00:30:23,260
linker and libraries and compiler and

00:30:19,630 --> 00:30:26,140
headers so as we hear there's a bit to

00:30:23,260 --> 00:30:28,780
do here is a bi functions so these are

00:30:26,140 --> 00:30:30,250
the sort of compiler helper functions

00:30:28,780 --> 00:30:32,500
that are standardized across the

00:30:30,250 --> 00:30:34,720
architectures these are things like neon

00:30:32,500 --> 00:30:36,670
intrinsics that type of thing where you

00:30:34,720 --> 00:30:38,740
want something that a bit of source code

00:30:36,670 --> 00:30:41,830
written here kind of a realistic chance

00:30:38,740 --> 00:30:45,039
of running in both compilers

00:30:41,830 --> 00:30:46,210
and then there's the normalcy library

00:30:45,039 --> 00:30:48,399
which would expect the compiler

00:30:46,210 --> 00:30:55,360
conforming to c library to learn to

00:30:48,399 --> 00:30:57,519
define ok yeah so does that mean that

00:30:55,360 --> 00:31:00,250
you could potentially end up with as

00:30:57,519 --> 00:31:04,140
many copies of a private helper as you

00:31:00,250 --> 00:31:04,140
do objects in your final executable and

00:31:04,740 --> 00:31:11,049
generally no because the in else there's

00:31:08,110 --> 00:31:13,210
something called combat group so the

00:31:11,049 --> 00:31:16,029
Betty technology in the elf file that

00:31:13,210 --> 00:31:17,950
can allow the linker to compress all of

00:31:16,029 --> 00:31:20,409
that into one copy so each object would

00:31:17,950 --> 00:31:22,450
have its own own copy but the linker

00:31:20,409 --> 00:31:24,820
would select just one of them as the

00:31:22,450 --> 00:31:26,110
final image time so yeah it was that you

00:31:24,820 --> 00:31:29,740
would only end up with one in the idea

00:31:26,110 --> 00:31:32,830
and the final object okay so this is a

00:31:29,740 --> 00:31:34,330
little bit about a qoi area so one of

00:31:32,830 --> 00:31:37,269
the interesting things I mentioned early

00:31:34,330 --> 00:31:41,950
on about is enum size choice so you'll

00:31:37,269 --> 00:31:44,799
find that and GCC for linux will default

00:31:41,950 --> 00:31:48,220
to elem is in mcc for embedded will

00:31:44,799 --> 00:31:50,470
default to elem is enum is the smallest

00:31:48,220 --> 00:31:53,830
possible chart sighs no obviously if you

00:31:50,470 --> 00:31:57,000
have a an api function that takes me

00:31:53,830 --> 00:32:00,429
none if both of the compilers disagree

00:31:57,000 --> 00:32:04,389
you could end up with a problem when at

00:32:00,429 --> 00:32:07,330
runtime so there are things called build

00:32:04,389 --> 00:32:10,149
attributes that encode some of these api

00:32:07,330 --> 00:32:12,309
decisions in the object file and the

00:32:10,149 --> 00:32:15,059
linker is able to give you a warning

00:32:12,309 --> 00:32:17,950
such as skinny well these warnings when

00:32:15,059 --> 00:32:20,559
it detects that someone has compiled

00:32:17,950 --> 00:32:23,320
with enum isn't enum is short and you

00:32:20,559 --> 00:32:24,549
end up in the warning some some linkers

00:32:23,320 --> 00:32:27,220
may give you an error in that particular

00:32:24,549 --> 00:32:30,070
case but that's that one thing that you

00:32:27,220 --> 00:32:32,919
can look for is one of the side effects

00:32:30,070 --> 00:32:35,409
of having an API where there is choice

00:32:32,919 --> 00:32:39,279
is that you have to ride a mechanism to

00:32:35,409 --> 00:32:40,809
be able to detect errors but the ABI

00:32:39,279 --> 00:32:43,299
doesn't require you to detect errors

00:32:40,809 --> 00:32:45,010
this is a quality of implementation for

00:32:43,299 --> 00:32:48,700
particular tool sharing to be able to do

00:32:45,010 --> 00:32:50,500
things with the bills attributes ok so

00:32:48,700 --> 00:32:53,649
mentioned before about the base platform

00:32:50,500 --> 00:32:55,070
api and how the how this sort of them

00:32:53,649 --> 00:32:59,360
how this was expected

00:32:55,070 --> 00:33:01,730
to work so the bare metal case which is

00:32:59,360 --> 00:33:04,149
also with including our toes you would

00:33:01,730 --> 00:33:06,799
you would produce else from the compiler

00:33:04,149 --> 00:33:08,899
link it to reduce an elf executive or

00:33:06,799 --> 00:33:11,360
not typically in the bedded system you

00:33:08,899 --> 00:33:14,149
don't run an elf file directly you would

00:33:11,360 --> 00:33:16,549
then extract the bit the binary bits and

00:33:14,149 --> 00:33:18,860
either burn them to flash or wrong or

00:33:16,549 --> 00:33:21,289
what the heck's something something like

00:33:18,860 --> 00:33:24,500
that and that's completely outside the

00:33:21,289 --> 00:33:28,610
scope of the ABI similarly at the bottom

00:33:24,500 --> 00:33:30,559
for a Linux style application where

00:33:28,610 --> 00:33:33,379
you're going to be executing the elf

00:33:30,559 --> 00:33:35,960
file directly and you would just produce

00:33:33,379 --> 00:33:39,139
an elf and Link and produce a compatible

00:33:35,960 --> 00:33:43,039
file directly for the DLL like model or

00:33:39,139 --> 00:33:46,759
the palm aust like model and it's

00:33:43,039 --> 00:33:50,649
obvious that unless you are going to

00:33:46,759 --> 00:33:55,570
expect a linker to be able to produce

00:33:50,649 --> 00:33:58,820
dll microsoft PE costs as well for any

00:33:55,570 --> 00:34:01,340
custom file format that any sort of

00:33:58,820 --> 00:34:04,610
platform might have in symbionts case

00:34:01,340 --> 00:34:07,580
they had one called ether t2 which

00:34:04,610 --> 00:34:09,770
wasn't else all costs or whatever so it

00:34:07,580 --> 00:34:11,629
would be too much for burden on the

00:34:09,770 --> 00:34:14,089
world's toolchain manufacturers to make

00:34:11,629 --> 00:34:15,980
them all every link has support every

00:34:14,089 --> 00:34:18,800
possible object format that could

00:34:15,980 --> 00:34:22,659
potentially be done so what we did was

00:34:18,800 --> 00:34:25,730
they will ok will produce a superset of

00:34:22,659 --> 00:34:30,440
what can be done in an elf file called a

00:34:25,730 --> 00:34:32,679
base platform ABI xcr dll and this elf

00:34:30,440 --> 00:34:35,540
file containing us information that

00:34:32,679 --> 00:34:37,609
somebody like symbian could be right a

00:34:35,540 --> 00:34:40,040
translator program and then produce

00:34:37,609 --> 00:34:43,099
their own custom object file format so

00:34:40,040 --> 00:34:45,409
as far as I'm aware symbian are the only

00:34:43,099 --> 00:34:48,020
ones that ever did this there's a

00:34:45,409 --> 00:34:49,940
program called elf to e32 against

00:34:48,020 --> 00:34:52,879
indians now pretty much ancient history

00:34:49,940 --> 00:34:54,560
but this route here and was what we

00:34:52,879 --> 00:34:57,230
expected a lot of the embedded industry

00:34:54,560 --> 00:35:00,859
to go down we expect them to have a lot

00:34:57,230 --> 00:35:02,900
of their own custom object file formats

00:35:00,859 --> 00:35:04,460
for their platform but in the end it

00:35:02,900 --> 00:35:05,310
didn't materialize than most people just

00:35:04,460 --> 00:35:07,710
use Linux

00:35:05,310 --> 00:35:11,760
so that that's been a sort of a

00:35:07,710 --> 00:35:13,350
prediction that didn't come true okay so

00:35:11,760 --> 00:35:14,760
I've gone through multiples of general

00:35:13,350 --> 00:35:17,160
structure this is now just going to be

00:35:14,760 --> 00:35:19,230
small number of slides of how do i find

00:35:17,160 --> 00:35:22,620
this now maybe i could it's actually not

00:35:19,230 --> 00:35:25,670
as easy as it sounds to find so the

00:35:22,620 --> 00:35:28,740
easiest way to find this is to go to

00:35:25,670 --> 00:35:30,840
info sensors arm calm which is this

00:35:28,740 --> 00:35:34,110
particular website here there is another

00:35:30,840 --> 00:35:37,410
website called developers arm calm that

00:35:34,110 --> 00:35:39,180
you can find the ABI on when you do that

00:35:37,410 --> 00:35:41,760
you have to type it into the search box

00:35:39,180 --> 00:35:45,390
if there is an easy way a clickable way

00:35:41,760 --> 00:35:47,250
of getting to it but so this the info

00:35:45,390 --> 00:35:49,800
center current the easiest way if you

00:35:47,250 --> 00:35:51,930
just want to click on arm software

00:35:49,800 --> 00:35:54,630
development tools and then it's the

00:35:51,930 --> 00:35:56,580
second entry down of the ABI for the ARM

00:35:54,630 --> 00:36:01,680
architecture and you can get the PDF

00:35:56,580 --> 00:36:04,770
documents of them there ok so if you're

00:36:01,680 --> 00:36:08,790
a programmer in idea wells you shouldn't

00:36:04,770 --> 00:36:11,130
have to go to the ABI unless things

00:36:08,790 --> 00:36:14,220
aren't working as they're supposed to do

00:36:11,130 --> 00:36:16,560
so typically the API is a good point of

00:36:14,220 --> 00:36:18,930
core for diagnosing compatibility

00:36:16,560 --> 00:36:20,460
problems between us and you know this

00:36:18,930 --> 00:36:23,010
one you get those strange link errors

00:36:20,460 --> 00:36:25,020
and it will say object X has built out

00:36:23,010 --> 00:36:26,970
to be Y and it clashes with some other

00:36:25,020 --> 00:36:29,610
ones well the API can tell you what

00:36:26,970 --> 00:36:31,710
those those clashes are and then that

00:36:29,610 --> 00:36:33,930
gives you an opportunity to understand

00:36:31,710 --> 00:36:36,000
what's gone wrong certainly if you're

00:36:33,930 --> 00:36:37,710
trying to write assembly language and

00:36:36,000 --> 00:36:39,240
intubated to see you'll need to look at

00:36:37,710 --> 00:36:41,970
the API to find out what the procedure

00:36:39,240 --> 00:36:46,230
called standard is that type of thing

00:36:41,970 --> 00:36:48,450
the addenda in the router in the API for

00:36:46,230 --> 00:36:49,740
the ARM architecture is the what is a

00:36:48,450 --> 00:36:52,800
document that contains the doors

00:36:49,740 --> 00:36:57,810
attributes and information and for the

00:36:52,800 --> 00:37:00,600
procedure called standard ugly apts okay

00:36:57,810 --> 00:37:02,820
so some concluding thoughts about the

00:37:00,600 --> 00:37:07,050
ABI

00:37:02,820 --> 00:37:09,510
so the world looks very different now so

00:37:07,050 --> 00:37:10,950
it does today and it's certain that I

00:37:09,510 --> 00:37:14,460
think if I'm we're going to try and

00:37:10,950 --> 00:37:16,170
introduce the 32-bit ABI now it would

00:37:14,460 --> 00:37:19,230
probably look quite different to the one

00:37:16,170 --> 00:37:23,220
that we've got there's a large amount of

00:37:19,230 --> 00:37:26,570
consolidation that's occurred we've gone

00:37:23,220 --> 00:37:31,020
down to from 20 available tool chains

00:37:26,570 --> 00:37:33,840
probably to about five or maybe six and

00:37:31,020 --> 00:37:36,660
a lot of them and now well all of them

00:37:33,840 --> 00:37:39,840
are now compliant to the ABI in some

00:37:36,660 --> 00:37:42,840
form or another and GCC and climb a very

00:37:39,840 --> 00:37:47,660
much aimed at the sort of Linux sort of

00:37:42,840 --> 00:37:49,950
staff and ABI and there's also much more

00:37:47,660 --> 00:37:51,960
sharing going on the source code level

00:37:49,950 --> 00:37:54,030
than there is at the object code level

00:37:51,960 --> 00:37:57,960
so it's not really being a sort of

00:37:54,030 --> 00:38:00,690
market for companies selling header

00:37:57,960 --> 00:38:03,720
files and binary objects it seems to be

00:38:00,690 --> 00:38:07,130
the open source has killed a lot of that

00:38:03,720 --> 00:38:09,750
a lot of that market so now it's now

00:38:07,130 --> 00:38:12,270
companies release source code and the

00:38:09,750 --> 00:38:14,280
end you now build that source code with

00:38:12,270 --> 00:38:16,200
your own tool chain so this sort of

00:38:14,280 --> 00:38:19,080
everything sort of moved up a level for

00:38:16,200 --> 00:38:22,320
source code then it didn't stand back in

00:38:19,080 --> 00:38:23,940
sub year 2000 and the problems about

00:38:22,320 --> 00:38:25,770
offenders having to ship 20 different

00:38:23,940 --> 00:38:31,050
binary society different 2 chainz

00:38:25,770 --> 00:38:33,900
doesn't exist anymore so with that in

00:38:31,050 --> 00:38:38,280
mind we sort of comforts of structured

00:38:33,900 --> 00:38:40,980
the 64-bit API so at this point with a

00:38:38,280 --> 00:38:43,890
dacha opportunity to look at well there

00:38:40,980 --> 00:38:46,890
we just take the 32-bit avi and add 64

00:38:43,890 --> 00:38:49,650
bits to it or do we take a look at some

00:38:46,890 --> 00:38:51,630
of the decisions that we made sensitive

00:38:49,650 --> 00:38:54,720
to try and simplify things so you'll

00:38:51,630 --> 00:38:58,290
notice the c64 10 ABI very much smaller

00:38:54,720 --> 00:39:00,780
and it in many ways it says less than

00:38:58,290 --> 00:39:04,470
the first of a bi n is less prescriptive

00:39:00,780 --> 00:39:06,600
and a lot of that's borne out by the no

00:39:04,470 --> 00:39:09,180
matter what we write in the ABI we can't

00:39:06,600 --> 00:39:12,900
force toolchain vendors to conform too

00:39:09,180 --> 00:39:13,750
much as they jump on to sharing is

00:39:12,900 --> 00:39:15,820
tended to be

00:39:13,750 --> 00:39:18,310
not at the mixing and matching

00:39:15,820 --> 00:39:22,150
individual objects it tends to be I

00:39:18,310 --> 00:39:24,100
built a shared library with compiler X I

00:39:22,150 --> 00:39:27,340
build a whole library with compiler wine

00:39:24,100 --> 00:39:30,130
I don't tend to mix in any particular

00:39:27,340 --> 00:39:33,550
application so it makes much more sense

00:39:30,130 --> 00:39:35,740
for 64-bit API which is expected to run

00:39:33,550 --> 00:39:38,140
the software platform at the moment

00:39:35,740 --> 00:39:43,780
there's there's very little sort of bare

00:39:38,140 --> 00:39:46,660
metal use of 64 so we're really

00:39:43,780 --> 00:39:50,230
expecting these units of sharing to be

00:39:46,660 --> 00:39:53,380
at the Linux BSD type level than at the

00:39:50,230 --> 00:39:55,060
bottom and we also find that the number

00:39:53,380 --> 00:39:57,520
of developers writing applications for

00:39:55,060 --> 00:39:59,830
platform like Linux vastly outnumber the

00:39:57,520 --> 00:40:02,770
disease the deserve OS and bare metal

00:39:59,830 --> 00:40:04,030
developers for and they are 64 I don't

00:40:02,770 --> 00:40:06,970
think that's necessary in the case very

00:40:04,030 --> 00:40:09,850
much 32 but that just gives you an idea

00:40:06,970 --> 00:40:12,430
of why the ayats it could be for ABI is

00:40:09,850 --> 00:40:14,970
nowhere near in Vegas leave they are 621

00:40:12,430 --> 00:40:17,470
and we also find that because they be

00:40:14,970 --> 00:40:19,990
aren't they out 64 chips are so much

00:40:17,470 --> 00:40:22,930
more capable the base level we've not

00:40:19,990 --> 00:40:25,780
needed to do things like the custom a

00:40:22,930 --> 00:40:27,970
custom exception table format because we

00:40:25,780 --> 00:40:30,040
can just reuse the existing standards

00:40:27,970 --> 00:40:32,470
one as it is without worrying that it

00:40:30,040 --> 00:40:35,260
might be slightly less code size

00:40:32,470 --> 00:40:37,150
efficient and that gives the advantages

00:40:35,260 --> 00:40:39,070
of faster development tools because the

00:40:37,150 --> 00:40:41,260
closer we are to existing industry

00:40:39,070 --> 00:40:46,120
standards being young easier it is to

00:40:41,260 --> 00:40:49,210
implement ok so the concluding thoughts

00:40:46,120 --> 00:40:52,600
from this is that the so stupid abim

00:40:49,210 --> 00:40:54,670
embedded ABI and it's basically

00:40:52,600 --> 00:40:56,620
concentrating on the interoperability at

00:40:54,670 --> 00:40:59,310
the binary package level will not

00:40:56,620 --> 00:41:01,900
necessarily a mix and match of objects

00:40:59,310 --> 00:41:03,760
platforms can build their own standards

00:41:01,900 --> 00:41:06,280
on top of the ABI so if you are

00:41:03,760 --> 00:41:08,170
introducing a new platform you don't

00:41:06,280 --> 00:41:10,120
miss out and you need objects to do

00:41:08,170 --> 00:41:12,220
something the idea isn't that you go

00:41:10,120 --> 00:41:14,440
back to arm and say I need you to

00:41:12,220 --> 00:41:16,720
rewrite the ABI so that you introduce my

00:41:14,440 --> 00:41:18,490
the things to my platform the idea is

00:41:16,720 --> 00:41:20,740
that you write a platform standard

00:41:18,490 --> 00:41:24,130
document that says you want to run a my

00:41:20,740 --> 00:41:26,440
platform this is what you need to do at

00:41:24,130 --> 00:41:29,770
least at that sets up the position

00:41:26,440 --> 00:41:32,079
from arm on that particular point 64bit

00:41:29,770 --> 00:41:34,030
ABI is much more traditional and it's

00:41:32,079 --> 00:41:37,270
concentrating on platforms rather than

00:41:34,030 --> 00:41:39,490
bare metal ok this is a general

00:41:37,270 --> 00:41:41,560
references slide so if you do want to

00:41:39,490 --> 00:41:44,109
find out where to get these things from

00:41:41,560 --> 00:41:47,020
agents of general links to the various

00:41:44,109 --> 00:41:48,910
different documents again won't read no

00:41:47,020 --> 00:41:51,849
doubt that is there for anyone to look

00:41:48,910 --> 00:41:54,400
at if they want them okay that's that's

00:41:51,849 --> 00:41:56,950
all the material I had for here so i'll

00:41:54,400 --> 00:42:04,089
be happy to try and answer any questions

00:41:56,950 --> 00:42:10,420
that i can or you're desperate to get

00:42:04,089 --> 00:42:13,869
your lunch there's been no more

00:42:10,420 --> 00:42:16,250
questions then i can daddy too happy to

00:42:13,869 --> 00:42:21,570
leave it here

00:42:16,250 --> 00:42:26,539
[Applause]

00:42:21,570 --> 00:42:26,539

YouTube URL: https://www.youtube.com/watch?v=shlvgwdI1vE


