Title: BUD17-320 High resolution data plane timers
Publication date: 2017-03-11
Playlist: Linaro Connect Budapest 2017
Description: 
	"Session ID: BUD17-320
Session Name: High resolution data plane timers - BUD17-320
Speaker: Brian Brooks
Track: LNG


★ Session Summary ★
Exploration of how timers are used in mobile networks as well as proposals for achieving higher timer resolution in software implementations of timers in OpenDataPlane.
---------------------------------------------------
★ Resources ★
Event Page: http://connect.linaro.org/resource/bud17/bud17-320/
Presentation: https://www.slideshare.net/linaroorg/bud17320-high-resolution-data-plane-timers
Video: https://youtu.be/Jt9qRj4lNUQ
 ---------------------------------------------------

★ Event Details ★
Linaro Connect Budapest 2017 (BUD17)
6-10 March 2017
Corinthia Hotel, Budapest,
Erzsébet krt. 43-49,
1073 Hungary

---------------------------------------------------
Keyword: LNG, data-plane,ODP
http://www.linaro.org
http://connect.linaro.org
---------------------------------------------------
Follow us on Social Media
https://www.facebook.com/LinaroOrg
https://twitter.com/linaroorg
https://www.youtube.com/user/linaroorg?sub_confirmation=1
https://www.linkedin.com/company/1026961"
Captions: 
	00:00:00,130 --> 00:00:07,509
[Music]

00:00:10,370 --> 00:00:20,400
so just to talk about the agenda a

00:00:17,850 --> 00:00:22,949
little bit I want to give a brief

00:00:20,400 --> 00:00:26,789
background about what are the use cases

00:00:22,949 --> 00:00:31,890
for the high resolution timers and then

00:00:26,789 --> 00:00:34,890
I'll also talk about what a typical data

00:00:31,890 --> 00:00:36,690
plane application would look like I'm

00:00:34,890 --> 00:00:38,160
probably going to keep it charged

00:00:36,690 --> 00:00:40,649
because I see a lot of familiar faces

00:00:38,160 --> 00:00:45,539
who are already well aware of the data

00:00:40,649 --> 00:00:48,469
plane then we will talk about the

00:00:45,539 --> 00:00:51,030
current timer implementation in ODP and

00:00:48,469 --> 00:00:54,500
we'll look at what are all the factors

00:00:51,030 --> 00:00:59,340
that affect the timer resolution and

00:00:54,500 --> 00:01:02,160
then I will talk about the proposal or

00:00:59,340 --> 00:01:05,159
some of the experiments that arm has

00:01:02,160 --> 00:01:07,380
done with respect to how do we have a

00:01:05,159 --> 00:01:10,500
high resolution timer and then we'll

00:01:07,380 --> 00:01:17,400
look at some results and we'll have a

00:01:10,500 --> 00:01:20,700
Q&A on that ok so first about the use

00:01:17,400 --> 00:01:23,880
cases so there are a lot of use cases so

00:01:20,700 --> 00:01:26,070
I'll take a very simple use case of IP

00:01:23,880 --> 00:01:30,299
reassembly which probably everyone would

00:01:26,070 --> 00:01:32,759
understand so what we have in reassembly

00:01:30,299 --> 00:01:35,280
is we have a set of fragments that are

00:01:32,759 --> 00:01:39,720
coming in from the network and as soon

00:01:35,280 --> 00:01:43,560
as we get a fragment we would have to

00:01:39,720 --> 00:01:46,200
allocate a buffer and show that fragment

00:01:43,560 --> 00:01:50,009
in the buffer and now once we have all

00:01:46,200 --> 00:01:52,409
the fragments combats arrived from the

00:01:50,009 --> 00:01:53,970
network you know we have the packet

00:01:52,409 --> 00:01:56,970
reassembled and it's given to the

00:01:53,970 --> 00:01:59,850
application for processing

00:01:56,970 --> 00:02:02,490
but it might happen that the fragments

00:01:59,850 --> 00:02:05,370
are lost on the network so in that case

00:02:02,490 --> 00:02:08,520
the system has to go and free up its

00:02:05,370 --> 00:02:10,200
buffer so the other problem that if

00:02:08,520 --> 00:02:13,260
presence is how long are we going to

00:02:10,200 --> 00:02:14,610
wait for all the fragments to come in so

00:02:13,260 --> 00:02:17,640
that's where the timer comes into

00:02:14,610 --> 00:02:20,160
picture so as soon as a fragment company

00:02:17,640 --> 00:02:25,080
you say that hey I will allocate a

00:02:20,160 --> 00:02:27,390
buffer as well as start a timer and you

00:02:25,080 --> 00:02:30,300
know if all the fragments come in before

00:02:27,390 --> 00:02:33,030
the timer expires you know you are good

00:02:30,300 --> 00:02:35,459
otherwise the timer expires and you know

00:02:33,030 --> 00:02:36,660
you free of your resources so that's

00:02:35,459 --> 00:02:39,480
where the time has come into picture

00:02:36,660 --> 00:02:41,820
there are other use cases which I am NOT

00:02:39,480 --> 00:02:45,660
going to go into but the important point

00:02:41,820 --> 00:02:48,660
is that different use cases require

00:02:45,660 --> 00:02:50,430
different resolution for example

00:02:48,660 --> 00:02:53,520
reassembly would require probably in

00:02:50,430 --> 00:02:55,980
terms of millisecond but Mac scheduling

00:02:53,520 --> 00:02:57,390
might require in terms of you know tens

00:02:55,980 --> 00:03:01,380
of microseconds for hundreds of

00:02:57,390 --> 00:03:08,700
microseconds so ODP needs to support all

00:03:01,380 --> 00:03:12,180
these use cases ok so so what we have in

00:03:08,700 --> 00:03:16,260
the how does data plane application

00:03:12,180 --> 00:03:19,530
looks like in a multi-course system so

00:03:16,260 --> 00:03:21,150
what we have is a set of course which

00:03:19,530 --> 00:03:26,070
are reserved for the data plane

00:03:21,150 --> 00:03:27,810
processing these cause you know they put

00:03:26,070 --> 00:03:29,459
the package from the queue the package

00:03:27,810 --> 00:03:33,330
come in from the network and they get

00:03:29,459 --> 00:03:36,420
queued on the bay input queue and then

00:03:33,330 --> 00:03:38,670
we have a scheduler which runs various

00:03:36,420 --> 00:03:41,519
policies they you know round-robin are

00:03:38,670 --> 00:03:43,530
split priority and take the package from

00:03:41,519 --> 00:03:48,620
the queues and hands it over to the

00:03:43,530 --> 00:03:52,019
application to process the packet so

00:03:48,620 --> 00:03:55,440
then there's a control plane curve which

00:03:52,019 --> 00:03:57,590
typically you know runs routing

00:03:55,440 --> 00:04:01,230
protocols signaling protocols and

00:03:57,590 --> 00:04:03,120
configures the data plan course with

00:04:01,230 --> 00:04:05,630
various tables for example the

00:04:03,120 --> 00:04:05,630
forwarding table

00:04:06,230 --> 00:04:14,580
so now all this data plan course have to

00:04:10,349 --> 00:04:17,250
run timeless you know we have n number

00:04:14,580 --> 00:04:19,590
of course and you know all of them are

00:04:17,250 --> 00:04:24,300
running psychic processing algorithms

00:04:19,590 --> 00:04:26,630
and those algorithms require timers but

00:04:24,300 --> 00:04:30,930
what we have in the system typically is

00:04:26,630 --> 00:04:34,380
one clock source so from this single

00:04:30,930 --> 00:04:35,760
clock source we have to derive multiple

00:04:34,380 --> 00:04:39,240
timers that are required by this

00:04:35,760 --> 00:04:42,690
application so that's where the timer

00:04:39,240 --> 00:04:44,970
module comes into picture in the current

00:04:42,690 --> 00:04:49,830
implementation the timer module is

00:04:44,970 --> 00:04:52,440
running on the control plane code so the

00:04:49,830 --> 00:04:53,850
data plane course say that the

00:04:52,440 --> 00:04:56,400
application running on the data plan

00:04:53,850 --> 00:04:59,100
course say that it I want a time I want

00:04:56,400 --> 00:05:03,539
a timer for you know 10 milliseconds of

00:04:59,100 --> 00:05:07,260
you know 100 microseconds so it it calls

00:05:03,539 --> 00:05:10,770
the timer start API and the timer start

00:05:07,260 --> 00:05:12,450
API is going to put that data in a in a

00:05:10,770 --> 00:05:15,870
data structure saying that hey I need a

00:05:12,450 --> 00:05:17,910
timer for this much duration so that

00:05:15,870 --> 00:05:22,260
data structure is accessed by the timer

00:05:17,910 --> 00:05:26,310
train so the timer spread in turn what

00:05:22,260 --> 00:05:30,330
it does is it asked the operating system

00:05:26,310 --> 00:05:33,419
hey can you wake me up every certain

00:05:30,330 --> 00:05:36,090
duration let's say the timer cred has to

00:05:33,419 --> 00:05:40,229
support a resolution of 10 microseconds

00:05:36,090 --> 00:05:42,419
it says its operating system hey please

00:05:40,229 --> 00:05:45,330
wake me up every 10 microseconds and

00:05:42,419 --> 00:05:48,870
once it wakes up it goes through this

00:05:45,330 --> 00:05:52,229
list of the timers and see if any one of

00:05:48,870 --> 00:05:56,729
them has to be expired if it means to be

00:05:52,229 --> 00:06:01,280
expired it sends a message and puts it

00:05:56,729 --> 00:06:03,690
put back message on the cues input queue

00:06:01,280 --> 00:06:07,620
so again the scheduler comes in the

00:06:03,690 --> 00:06:09,630
picture it picks up that timeout message

00:06:07,620 --> 00:06:11,370
from the cubes and use it to the

00:06:09,630 --> 00:06:15,020
application saying that okay your timer

00:06:11,370 --> 00:06:19,810
has expired now so

00:06:15,020 --> 00:06:25,550
this is how a typical timer works in a

00:06:19,810 --> 00:06:28,810
data plane application so now where is

00:06:25,550 --> 00:06:31,729
the resolution coming into picture or

00:06:28,810 --> 00:06:36,699
what affects the resolution of the timer

00:06:31,729 --> 00:06:40,610
all right so we will look at some of the

00:06:36,699 --> 00:06:42,889
latencies that are involved here so

00:06:40,610 --> 00:06:45,319
first one is the latency in starting the

00:06:42,889 --> 00:06:47,240
timer so you know the data plane

00:06:45,319 --> 00:06:51,139
application is going to call this API to

00:06:47,240 --> 00:06:53,509
start a timer and that API has to take

00:06:51,139 --> 00:06:58,520
this timer and put it in a data

00:06:53,509 --> 00:07:01,240
structure but it is very some latency

00:06:58,520 --> 00:07:03,830
involved over there but that is not

00:07:01,240 --> 00:07:05,750
something that the application cannot

00:07:03,830 --> 00:07:07,430
handle it and the application can handle

00:07:05,750 --> 00:07:12,319
that so we are not really concerned

00:07:07,430 --> 00:07:14,930
about that latency the second latency

00:07:12,319 --> 00:07:19,280
that comes into picture is the delivery

00:07:14,930 --> 00:07:23,750
of the timer tick expiry to be timer

00:07:19,280 --> 00:07:29,360
clay so we have also is that he wake me

00:07:23,750 --> 00:07:32,180
up every certain eerie 10 microseconds

00:07:29,360 --> 00:07:34,130
for example so when it when the

00:07:32,180 --> 00:07:37,039
operating system decides that he has to

00:07:34,130 --> 00:07:40,460
wake up the timer module you know this

00:07:37,039 --> 00:07:41,840
sequence of things or a lot of software

00:07:40,460 --> 00:07:47,289
that it needs to go through and that

00:07:41,840 --> 00:07:50,449
adds to the latency the other latency is

00:07:47,289 --> 00:07:53,000
involved with the timer model itself it

00:07:50,449 --> 00:07:55,370
has got a list of timers that is it has

00:07:53,000 --> 00:07:57,169
stored in it data structure so it means

00:07:55,370 --> 00:07:59,900
to go through that data structure and

00:07:57,169 --> 00:08:05,900
see which timers have expired so that

00:07:59,900 --> 00:08:10,069
process adds to the latency so third

00:08:05,900 --> 00:08:15,020
latency is in delivering the time of

00:08:10,069 --> 00:08:18,110
event to the application so it has to mq

00:08:15,020 --> 00:08:20,270
the time of event to the queue then the

00:08:18,110 --> 00:08:21,889
scheduler comes into picture and it has

00:08:20,270 --> 00:08:23,500
to schedule that time of event to the

00:08:21,889 --> 00:08:28,120
application so this

00:08:23,500 --> 00:08:31,050
process I'd latency so the goal here is

00:08:28,120 --> 00:08:37,690
to make sure that all these Layton sees

00:08:31,050 --> 00:08:42,370
you know are reduced so just to put this

00:08:37,690 --> 00:08:44,890
in a in a perspective here the ideal

00:08:42,370 --> 00:08:47,470
behavior that we would want is the

00:08:44,890 --> 00:08:50,680
application starts a timer with certain

00:08:47,470 --> 00:08:53,190
time operation the timeout happens and

00:08:50,680 --> 00:08:56,170
application immediately receives the

00:08:53,190 --> 00:09:02,230
time of event this ideal behavior that

00:08:56,170 --> 00:09:05,380
we want but what actually we have is the

00:09:02,230 --> 00:09:08,080
application starts the timer there is a

00:09:05,380 --> 00:09:10,840
tick x 5ft of the 10 microseconds that

00:09:08,080 --> 00:09:13,480
we talked about it expires then after

00:09:10,840 --> 00:09:16,230
that the timer module has to go and

00:09:13,480 --> 00:09:19,990
process all the time a static has told

00:09:16,230 --> 00:09:23,170
so I'm sorry I think I stepped one step

00:09:19,990 --> 00:09:25,750
ahead so that timer expires the tick

00:09:23,170 --> 00:09:30,400
expiry has to be delivered to the timer

00:09:25,750 --> 00:09:35,920
module so that I am calling it here as

00:09:30,400 --> 00:09:37,960
t1 for our reference so once that's so

00:09:35,920 --> 00:09:40,450
the timer module receives the tick

00:09:37,960 --> 00:09:43,660
expiry and after that it has to go

00:09:40,450 --> 00:09:45,520
through its data structure to see what

00:09:43,660 --> 00:09:50,710
Alzheimer's need to be expired at that

00:09:45,520 --> 00:09:53,589
moment so that is the key to let and see

00:09:50,710 --> 00:09:55,930
that I am talking here and then once it

00:09:53,589 --> 00:09:58,630
is that certain timers have to be

00:09:55,930 --> 00:10:02,260
expired then it needs to be delivered to

00:09:58,630 --> 00:10:04,839
the application so that's the t3 that

00:10:02,260 --> 00:10:07,750
we're talking about so from the ideal

00:10:04,839 --> 00:10:11,650
behavior you know we have got all these

00:10:07,750 --> 00:10:15,760
latencies t1 t2 and t3 and for the

00:10:11,650 --> 00:10:19,000
timers to be high resolution the sum of

00:10:15,760 --> 00:10:23,350
t1 t2 and t3 has to be much much lower

00:10:19,000 --> 00:10:25,180
than the actual timeout value if this

00:10:23,350 --> 00:10:28,210
latency is higher than we are going to

00:10:25,180 --> 00:10:32,020
lose the that the resolution of the

00:10:28,210 --> 00:10:35,100
timer is going to be very low or very

00:10:32,020 --> 00:10:39,870
lower high however we look at it

00:10:35,100 --> 00:10:45,710
so for this exercise our goal has been

00:10:39,870 --> 00:10:49,290
to reduce the latency involved in p1

00:10:45,710 --> 00:10:52,710
that is for every tick expiry how much

00:10:49,290 --> 00:10:55,620
time are we going to take to notify the

00:10:52,710 --> 00:10:58,740
timer module itself so we are just

00:10:55,620 --> 00:11:01,830
focused on t1 today we are not focused

00:10:58,740 --> 00:11:07,650
on t2 and t3 we will do that at a later

00:11:01,830 --> 00:11:10,590
point so so I just want to take a look

00:11:07,650 --> 00:11:14,640
at how the t1 values look like today

00:11:10,590 --> 00:11:19,740
with the current implementation so what

00:11:14,640 --> 00:11:24,540
we have is this so what I have done here

00:11:19,740 --> 00:11:27,540
is I have taken I have been to

00:11:24,540 --> 00:11:29,880
experiments in the first experiment the

00:11:27,540 --> 00:11:33,450
control plane is running only the timer

00:11:29,880 --> 00:11:35,310
thread and in the second experiment we

00:11:33,450 --> 00:11:36,660
are running the timer thread plus

00:11:35,310 --> 00:11:39,390
something else because that's the

00:11:36,660 --> 00:11:41,010
typical use case on the control plane

00:11:39,390 --> 00:11:43,320
you just don't run the timer thread you

00:11:41,010 --> 00:11:46,410
have your routing protocols and things

00:11:43,320 --> 00:11:48,390
like that so we wanted to see running

00:11:46,410 --> 00:11:53,450
those applications how does it affect

00:11:48,390 --> 00:11:58,230
the timer Craig so if you see here the

00:11:53,450 --> 00:12:01,220
t1 value changes dramatically if I just

00:11:58,230 --> 00:12:06,240
run the timer thread we are taking like

00:12:01,220 --> 00:12:08,690
151 nanoseconds on an average to tell

00:12:06,240 --> 00:12:10,890
you where the stick expiry to the timer

00:12:08,690 --> 00:12:13,980
but if we start running some other

00:12:10,890 --> 00:12:18,270
application it goes up to 2,600 90

00:12:13,980 --> 00:12:23,640
seconds if not it's not only that it's

00:12:18,270 --> 00:12:26,180
the variance in that latency we want we

00:12:23,640 --> 00:12:30,660
want determinism we want to say that hey

00:12:26,180 --> 00:12:33,180
this t1 needs to be within 2269 a second

00:12:30,660 --> 00:12:36,320
for example but if we say that he is

00:12:33,180 --> 00:12:40,140
going to vary between 20 to 12,800

00:12:36,320 --> 00:12:43,350
nanoseconds that's a problem so we want

00:12:40,140 --> 00:12:45,860
determinism and we want t want to be as

00:12:43,350 --> 00:12:45,860
less as possible

00:12:46,649 --> 00:12:55,199
so the proposed changes look like this

00:12:51,180 --> 00:12:56,939
so we have the data plane course and you

00:12:55,199 --> 00:13:00,059
know they're doing the packet processing

00:12:56,939 --> 00:13:03,869
and then you know we have a single clock

00:13:00,059 --> 00:13:06,869
source and now we want timers the data

00:13:03,869 --> 00:13:09,360
plane still calls the timer start API

00:13:06,869 --> 00:13:13,559
switch rights to a common data structure

00:13:09,360 --> 00:13:17,339
but what we have done is we have moved

00:13:13,559 --> 00:13:21,230
the timer module from the control plane

00:13:17,339 --> 00:13:24,689
to the data plane the idea here is to

00:13:21,230 --> 00:13:28,009
give better control over t1 to the

00:13:24,689 --> 00:13:31,889
application and not be dependent on the

00:13:28,009 --> 00:13:36,179
ways to shed use the expiry events to

00:13:31,889 --> 00:13:39,769
the timer thread the other thing that we

00:13:36,179 --> 00:13:43,410
have done is instead of the timer

00:13:39,769 --> 00:13:46,170
waiting for an event from the oils it is

00:13:43,410 --> 00:13:51,809
going to pull the tix it is produced is

00:13:46,170 --> 00:13:54,959
going to pull the clock so once it sees

00:13:51,809 --> 00:13:57,480
that hey you know a tire I gotta take

00:13:54,959 --> 00:14:01,199
expiry it goes through its list of

00:13:57,480 --> 00:14:03,540
timers and going to expire them and put

00:14:01,199 --> 00:14:07,079
the timeout messages back onto the queue

00:14:03,540 --> 00:14:16,949
so the rest of the processing remains

00:14:07,079 --> 00:14:18,749
the same okay so yeah as I said we have

00:14:16,949 --> 00:14:22,350
moved the timer pressing to the data

00:14:18,749 --> 00:14:26,910
plan course then instead of waiting for

00:14:22,350 --> 00:14:31,230
the timer expiry event from the OS we

00:14:26,910 --> 00:14:34,740
are going to pull the timer we are going

00:14:31,230 --> 00:14:37,589
to pull for the timer take expiry and

00:14:34,740 --> 00:14:41,009
then the other advantage that we get is

00:14:37,589 --> 00:14:45,689
now we have multiple data plan course

00:14:41,009 --> 00:14:47,970
looking at the timer pool all the other

00:14:45,689 --> 00:14:51,799
set of timers that you have instead of

00:14:47,970 --> 00:14:51,799
just a single core looking at it

00:14:51,990 --> 00:14:58,200
so what it does is it also provides

00:14:55,620 --> 00:15:00,540
control over t1 for the application

00:14:58,200 --> 00:15:03,839
application can decide how frequently it

00:15:00,540 --> 00:15:09,450
wants to pull for the tick expiry

00:15:03,839 --> 00:15:14,730
depending on its requirement so with

00:15:09,450 --> 00:15:18,060
this we did some benchmarking so this is

00:15:14,730 --> 00:15:22,560
what we see so we have the data plan

00:15:18,060 --> 00:15:25,890
thread with one data plan thread and 127

00:15:22,560 --> 00:15:28,320
and then we have we have done again two

00:15:25,890 --> 00:15:33,029
sets of experiment in one experiment we

00:15:28,320 --> 00:15:36,200
have the data plane threads and we have

00:15:33,029 --> 00:15:39,000
data plane threads and then running some

00:15:36,200 --> 00:15:41,459
control plane application to show that

00:15:39,000 --> 00:15:44,610
it does not have any effect on the data

00:15:41,459 --> 00:15:52,380
plane course so what we see here is on

00:15:44,610 --> 00:15:56,579
an average we see a latency of 100

00:15:52,380 --> 00:16:00,000
nanoseconds but when we even when we run

00:15:56,579 --> 00:16:02,370
with other control plane processes it

00:16:00,000 --> 00:16:05,279
does not change change a lot it's

00:16:02,370 --> 00:16:07,550
probably because of memory i/o and all

00:16:05,279 --> 00:16:11,700
that we see a little bit of difference

00:16:07,550 --> 00:16:14,910
the other key thing is when we increase

00:16:11,700 --> 00:16:17,130
the number of data plan course the

00:16:14,910 --> 00:16:19,529
latency is coming down because now there

00:16:17,130 --> 00:16:24,270
are multiple codes that are looking at

00:16:19,529 --> 00:16:29,130
the timer that the timers that needs to

00:16:24,270 --> 00:16:32,520
be expired the other important thing is

00:16:29,130 --> 00:16:39,649
that if we look at this graph earlier we

00:16:32,520 --> 00:16:42,720
had the t1 which we read from 22,200 the

00:16:39,649 --> 00:16:45,899
nanosecond sorry totals and the nano

00:16:42,720 --> 00:16:50,279
seconds but now we have it for a period

00:16:45,899 --> 00:16:58,170
of 20 to 200 nanoseconds so the variance

00:16:50,279 --> 00:17:00,260
is lot less with this approach so yeah

00:16:58,170 --> 00:17:03,410
with this change we feel that

00:17:00,260 --> 00:17:06,140
application has got better control over

00:17:03,410 --> 00:17:09,810
the t1 latency

00:17:06,140 --> 00:17:14,270
and you know our future work obviously

00:17:09,810 --> 00:17:35,160
would look at how to reduce t2 and t3

00:17:14,270 --> 00:17:37,680
yeah yeah yeah yes yes that's one of the

00:17:35,160 --> 00:17:41,070
discussions we have had so if I could

00:17:37,680 --> 00:17:44,070
measure all this maybe I can try and

00:17:41,070 --> 00:17:56,190
expire the timer's early so that the

00:17:44,070 --> 00:18:00,030
application gets it as we have yes yes

00:17:56,190 --> 00:18:03,030
so yeah I'm you know right now that has

00:18:00,030 --> 00:18:06,510
been done to provide backward

00:18:03,030 --> 00:18:08,760
compatibility but I believe I feel that

00:18:06,510 --> 00:18:10,620
it needs to be pulled out so that it

00:18:08,760 --> 00:18:13,380
gives better control for the application

00:18:10,620 --> 00:18:16,950
as to how frequently it wants to look at

00:18:13,380 --> 00:18:21,260
the timer tick that's what is my feeling

00:18:16,950 --> 00:18:21,260
but it's a for further discussion

00:18:36,660 --> 00:18:42,640
yes yes it is it is going to affect the

00:18:39,640 --> 00:18:44,650
data plan performance but what are the

00:18:42,640 --> 00:18:46,920
alternatives so the alternative that we

00:18:44,650 --> 00:18:50,230
have looked at is the control plane and

00:18:46,920 --> 00:19:20,290
control plane also has got to do other

00:18:50,230 --> 00:19:22,360
work so yes let's let me yes connect yes

00:19:20,290 --> 00:19:24,370
I mean if there is a hardware block that

00:19:22,360 --> 00:19:27,310
implements timer it doesn't make sense

00:19:24,370 --> 00:19:31,390
to do this this is for a platform where

00:19:27,310 --> 00:19:44,970
we don't have hardware the timer's

00:19:31,390 --> 00:19:44,970
implemented in the hardware right yes

00:20:12,490 --> 00:20:18,380
yes I mean see that solution works under

00:20:16,370 --> 00:20:20,870
certain cases and it doesn't work kind

00:20:18,380 --> 00:20:23,150
of certain cases so if you have a system

00:20:20,870 --> 00:20:24,950
with few course right it doesn't

00:20:23,150 --> 00:20:27,440
probably make sense to reserve one core

00:20:24,950 --> 00:20:54,440
just for time of trade crossing all

00:20:27,440 --> 00:20:57,860
right yes exactly is not wonderful yes

00:20:54,440 --> 00:20:59,690
that's exactly what I my point was if my

00:20:57,860 --> 00:21:01,430
point is I don't think it should be part

00:20:59,690 --> 00:21:03,380
of the schedule call it should be

00:21:01,430 --> 00:21:05,780
outside of it so that there's better

00:21:03,380 --> 00:21:19,160
control for the application to do what

00:21:05,780 --> 00:21:21,880
it wants to do yes but I believe we are

00:21:19,160 --> 00:21:25,490
talking about the timer thread that

00:21:21,880 --> 00:21:27,230
processes all these timers correct are

00:21:25,490 --> 00:21:29,480
the time of functionality timer

00:21:27,230 --> 00:21:37,700
functions yes time of functionality that

00:21:29,480 --> 00:21:39,920
process all this no you you need to you

00:21:37,700 --> 00:21:42,680
need to call the scheduler to receive

00:21:39,920 --> 00:21:46,460
the timer time of events that are queued

00:21:42,680 --> 00:21:48,500
on the cues but the X the functionality

00:21:46,460 --> 00:21:51,200
of going through your list of timers and

00:21:48,500 --> 00:21:53,180
putting that event time of event into

00:21:51,200 --> 00:21:55,570
the queue need not be part of the

00:21:53,180 --> 00:21:55,570
scheduler

00:21:58,000 --> 00:22:16,210
yes yes yes it is the same effect but

00:22:17,320 --> 00:22:27,620
yeah yeah yes but if there is activity

00:22:23,870 --> 00:22:30,770
now you've got to go pull the at the

00:22:27,620 --> 00:22:34,370
timer tick all right so so as I said

00:22:30,770 --> 00:22:36,440
both of them are possible if you want

00:22:34,370 --> 00:22:39,230
flexibility for the application I

00:22:36,440 --> 00:22:50,320
believe it can be pulled out is what

00:22:39,230 --> 00:22:50,320
what I feel I'm sorry I didn't get that

00:23:05,100 --> 00:23:15,400
yes yes yes so from the timer

00:23:13,210 --> 00:23:17,380
perspective that does not matter to fall

00:23:15,400 --> 00:23:19,600
from the timer perspective what matters

00:23:17,380 --> 00:23:22,290
is give me a cue where I can put the

00:23:19,600 --> 00:23:22,290
time of the event

00:23:44,200 --> 00:23:50,180
yeah i mean i mean what i hear is there

00:23:47,660 --> 00:24:01,700
is the need of more flexibility is that

00:23:50,180 --> 00:24:03,320
right yes definitely yeah yes yes and I

00:24:01,700 --> 00:24:06,940
feel that flexibility providing

00:24:03,320 --> 00:24:06,940
flexibility is the way to go for that

00:24:38,029 --> 00:24:48,899
yeah yeah there are those use cases

00:24:46,169 --> 00:24:51,360
wherein you want to say give me a time

00:24:48,899 --> 00:24:53,369
out every 100 microseconds for example

00:24:51,360 --> 00:24:58,039
their case is very want to cancel

00:24:53,369 --> 00:24:58,039
because you know it was not required

00:25:17,789 --> 00:25:39,490
okay yes I I think what you are

00:25:36,610 --> 00:25:42,070
requesting for comes in the portion of

00:25:39,490 --> 00:25:44,950
the delivery where the time of the event

00:25:42,070 --> 00:25:46,990
is delivered right so if you say that

00:25:44,950 --> 00:25:52,570
hey I want this time out to be processed

00:25:46,990 --> 00:25:54,490
on code x yeah corrects and then you

00:25:52,570 --> 00:25:57,150
know you can have a cue that is pulled

00:25:54,490 --> 00:26:00,150
only by that are scheduled only for that

00:25:57,150 --> 00:26:00,150
cool

00:26:09,499 --> 00:26:17,340
yes so so if I look at where we want to

00:26:14,580 --> 00:26:21,899
do this perk or packet the timer

00:26:17,340 --> 00:26:23,549
processing I feel it more useful when

00:26:21,899 --> 00:26:25,259
you want to create the time of you when

00:26:23,549 --> 00:26:28,169
you when you want to create a timer from

00:26:25,259 --> 00:26:30,619
a code you would rather put it on the

00:26:28,169 --> 00:26:36,059
timer pool that belongs to that course

00:26:30,619 --> 00:26:39,239
so that your data access is restricted

00:26:36,059 --> 00:26:41,909
to that core but once the time of event

00:26:39,239 --> 00:26:43,710
happens you know it does not matter wave

00:26:41,909 --> 00:26:47,970
that gets processed from a timer

00:26:43,710 --> 00:26:53,100
perspective so if I had to give you some

00:26:47,970 --> 00:26:55,049
more details so the timer today are in a

00:26:53,100 --> 00:26:57,600
shared data structure that's accessed by

00:26:55,049 --> 00:26:59,899
all the course which means that there's

00:26:57,600 --> 00:26:59,899
lot of

00:27:25,529 --> 00:27:33,070
yeah yeah so I I think we kind of both

00:27:29,559 --> 00:27:36,340
of us are agreeing on a generic solution

00:27:33,070 --> 00:27:39,549
but solution is little bit more involved

00:27:36,340 --> 00:27:56,289
is what I am thank you sir yes I am

00:27:39,549 --> 00:27:58,929
agreeing with the idea yes right now no

00:27:56,289 --> 00:28:01,389
we don't have like a packet processing

00:27:58,929 --> 00:28:03,669
workload no we don't have that but it

00:28:01,389 --> 00:28:05,950
has some workload about collecting

00:28:03,669 --> 00:28:27,489
statistics and time stamps and things

00:28:05,950 --> 00:28:40,809
like that so yes yes yes I certain

00:28:27,489 --> 00:28:42,669
frequency yes yes so so one thing that

00:28:40,809 --> 00:28:45,340
we have to note here is that if a single

00:28:42,669 --> 00:28:48,009
threat all right the data plane threat

00:28:45,340 --> 00:28:50,470
is you know actually it's not getting

00:28:48,009 --> 00:28:52,450
scheduled out by the Oasis it has

00:28:50,470 --> 00:28:55,409
control over the complete code that's

00:28:52,450 --> 00:28:58,690
one thing and what we are saying here is

00:28:55,409 --> 00:29:01,029
the frequency at which the timer module

00:28:58,690 --> 00:29:03,940
runs is in the control of the

00:29:01,029 --> 00:29:07,330
application so the application can

00:29:03,940 --> 00:29:09,429
decide if it thinks that hey you know if

00:29:07,330 --> 00:29:11,590
I profess 10 packets I am going to

00:29:09,429 --> 00:29:15,029
introduce more latency in the timer then

00:29:11,590 --> 00:29:15,029
he can reduce that so

00:29:20,640 --> 00:29:27,640
yes yeah and I I feel there's more

00:29:25,050 --> 00:29:30,070
flexibility required in how the

00:29:27,640 --> 00:29:33,600
application can alternate between the

00:29:30,070 --> 00:30:11,309
packet proofing and the timer person

00:29:33,600 --> 00:30:11,309
victory yes yes yes

00:30:29,799 --> 00:30:35,539
yes so so busy ways I'm trying to say

00:30:32,990 --> 00:30:40,279
that now the time of pressing is in the

00:30:35,539 --> 00:30:42,620
applications control so application yeah

00:30:40,279 --> 00:30:44,720
application need not for 600 packets for

00:30:42,620 --> 00:30:46,309
example you can say that hey I will I'm

00:30:44,720 --> 00:31:03,440
going to look at the timer irritant

00:30:46,309 --> 00:31:05,899
packet yes yeah so so if the SOC has a

00:31:03,440 --> 00:31:08,029
hardware timer this does not have any

00:31:05,899 --> 00:31:11,590
effect on that the same API is are going

00:31:08,029 --> 00:31:11,590
to work for the hardware timer has one

00:31:46,210 --> 00:32:00,740
yes yeah then yes yes so it is about

00:31:59,179 --> 00:32:02,390
providing that control to the

00:32:00,740 --> 00:32:04,370
application in the in the current

00:32:02,390 --> 00:32:07,990
implementation we don't have a better

00:32:04,370 --> 00:32:07,990
control over that for the application

00:32:29,930 --> 00:32:35,940
yes and implement optimizations wherein

00:32:33,840 --> 00:32:38,820
if a particular does not have any timer

00:32:35,940 --> 00:32:42,000
then it will not spend a lot of time in

00:32:38,820 --> 00:32:48,570
there I feel that's a solution that we

00:32:42,000 --> 00:32:50,340
are looking at yes we're done unless

00:32:48,570 --> 00:32:55,040
there are any more questions from the

00:32:50,340 --> 00:32:55,040
audience thank you

00:32:56,020 --> 00:33:00,730

YouTube URL: https://www.youtube.com/watch?v=Jt9qRj4lNUQ


