Title: BUD17-315 Drone Mapping: Hyperscaling a service with Kubernetes on ARM
Publication date: 2017-03-11
Playlist: Linaro Connect Budapest 2017
Description: 
	"Session ID: BUD17-315
Session Name: Hyperscaling applications with Kubernetes on ARM - BUD17-315
Speaker: Tyler Baker
Track: LTD


★ Session Summary ★
Hyperscaling applications can be difficult, but Kubernetes removes much of the complexity. Learn how to take a simple web application, and create a highly available, horizontally scalable service with Kubernetes running on an ARM cluster.
---------------------------------------------------
★ Resources ★
Event Page: http://connect.linaro.org/resource/bud17/bud17-315/
Presentation: https://www.slideshare.net/linaroorg/bud17315-hyperscaling-applications-with-kubernetes-on-arm
Video: https://youtu.be/xmKn-bf8aa8
 ---------------------------------------------------

★ Event Details ★
Linaro Connect Budapest 2017 (BUD17)
6-10 March 2017
Corinthia Hotel, Budapest,
Erzsébet krt. 43-49,
1073 Hungary

---------------------------------------------------
Keyword: LTD, hyperscaling, ARM, kubernetes
http://www.linaro.org
http://connect.linaro.org
---------------------------------------------------
Follow us on Social Media
https://www.facebook.com/LinaroOrg
https://twitter.com/linaroorg
https://www.youtube.com/user/linaroorg?sub_confirmation=1
https://www.linkedin.com/company/1026961"
Captions: 
	00:00:00,240 --> 00:00:03,439
[Music]

00:00:09,730 --> 00:00:14,570
alright this session is going to be

00:00:11,719 --> 00:00:17,029
about throne mapping but not

00:00:14,570 --> 00:00:19,990
specifically about drone mapping about

00:00:17,029 --> 00:00:22,250
Piper scaling of service on arm so

00:00:19,990 --> 00:00:26,119
you'll kind of learn that this is kind

00:00:22,250 --> 00:00:28,279
of an end use case so Who am I principal

00:00:26,119 --> 00:00:31,040
software engineer work at linares in

00:00:28,279 --> 00:00:32,450
linares technology division and you

00:00:31,040 --> 00:00:34,040
might wonder why you saw me if you're

00:00:32,450 --> 00:00:35,899
doing an IOT demo and now I'm giving you

00:00:34,040 --> 00:00:37,190
a hyperscale talk because we work from

00:00:35,899 --> 00:00:40,910
basically the firmware level to the

00:00:37,190 --> 00:00:43,480
cloud so with full stack and then just

00:00:40,910 --> 00:00:45,860
kind of a little bit of why i chose

00:00:43,480 --> 00:00:47,990
drone mappings i've been piloting model

00:00:45,860 --> 00:00:49,580
aircraft like 2004 before they were ever

00:00:47,990 --> 00:00:52,579
called drone so I a really light

00:00:49,580 --> 00:00:53,780
aviation I'm you know not a pilot or

00:00:52,579 --> 00:00:55,670
anything like that but I like to fly RC

00:00:53,780 --> 00:00:57,740
aircraft and so this is kind of where

00:00:55,670 --> 00:01:00,110
you know my passion could intersect with

00:00:57,740 --> 00:01:03,170
my professional career so I fly

00:01:00,110 --> 00:01:05,449
fixed-wing aircraft quadcopters and then

00:01:03,170 --> 00:01:08,000
long-range fpv system so flying out 20

00:01:05,449 --> 00:01:09,890
miles away autopilot systems and I'm

00:01:08,000 --> 00:01:11,659
really at a 3d printed aircraft so

00:01:09,890 --> 00:01:13,670
that's just kind of my background of why

00:01:11,659 --> 00:01:15,920
I'm giving this session so i can put

00:01:13,670 --> 00:01:18,229
some context to what we're going to talk

00:01:15,920 --> 00:01:19,520
about next and at any point you guys

00:01:18,229 --> 00:01:21,409
have any questions or one at what

00:01:19,520 --> 00:01:24,290
specific go ahead just throw your hand

00:01:21,409 --> 00:01:26,450
up and we can address them there so

00:01:24,290 --> 00:01:28,250
what's the drone mapping service so a

00:01:26,450 --> 00:01:30,140
user is going to provide aerial images

00:01:28,250 --> 00:01:31,700
which are processed by its service that

00:01:30,140 --> 00:01:33,650
we're going to build its creates two

00:01:31,700 --> 00:01:35,690
dimensional geo-located ortho mosaic and

00:01:33,650 --> 00:01:37,310
also a three-dimensional point cloud and

00:01:35,690 --> 00:01:41,510
textured model and we're going to do

00:01:37,310 --> 00:01:43,850
this all with open source software so

00:01:41,510 --> 00:01:47,510
let's just get into a demo right away so

00:01:43,850 --> 00:01:49,670
this can be interesting so what is the

00:01:47,510 --> 00:01:51,860
end result going to look like this is

00:01:49,670 --> 00:01:53,360
our service opened roadmap and what we

00:01:51,860 --> 00:01:55,340
have today this is actually a really

00:01:53,360 --> 00:01:57,350
terrible stitch so I'm going to show you

00:01:55,340 --> 00:01:59,390
something different here we flew drone

00:01:57,350 --> 00:02:02,000
this morning and collected these images

00:01:59,390 --> 00:02:04,250
and we process a 1 gigabyte data set

00:02:02,000 --> 00:02:05,900
into a three-dimensional model and so

00:02:04,250 --> 00:02:08,629
you should be able to kind of rotate it

00:02:05,900 --> 00:02:11,060
here so you can see depth this is our

00:02:08,629 --> 00:02:12,709
hotel so this is kind of what we're

00:02:11,060 --> 00:02:14,599
going to build and if we go to the

00:02:12,709 --> 00:02:17,169
dashboard here we're going to add a new

00:02:14,599 --> 00:02:17,169
project

00:02:21,400 --> 00:02:29,020
create a project and we're going to

00:02:24,620 --> 00:02:31,280
upload some images for this project and

00:02:29,020 --> 00:02:32,480
just so we can keep it within the time

00:02:31,280 --> 00:02:34,370
frame of this presentation we're going

00:02:32,480 --> 00:02:35,900
to upload 40 aerial images and you can

00:02:34,370 --> 00:02:37,400
kind of see here from the preview these

00:02:35,900 --> 00:02:38,900
are top down aerial images and I'll go

00:02:37,400 --> 00:02:40,820
into that a little bit more but we're

00:02:38,900 --> 00:02:44,960
going to upload them now hopefully this

00:02:40,820 --> 00:02:51,970
goes quickly not going to too bad and

00:02:44,960 --> 00:02:53,930
then we're going to name this task and

00:02:51,970 --> 00:02:55,970
there's a whole bunch of processing

00:02:53,930 --> 00:02:57,550
options within opened row map and I'll

00:02:55,970 --> 00:03:00,860
get into the software components there's

00:02:57,550 --> 00:03:03,170
opencv open GV open sfm there's a ton of

00:03:00,860 --> 00:03:05,750
image processing computer vision

00:03:03,170 --> 00:03:08,510
libraries that are needed to run this

00:03:05,750 --> 00:03:11,660
this service and it all runs on arm 64

00:03:08,510 --> 00:03:20,690
so as well see here a moment so I just

00:03:11,660 --> 00:03:22,490
want to enable X 2 66 so we uploaded our

00:03:20,690 --> 00:03:23,780
40 images to the service and in a moment

00:03:22,490 --> 00:03:26,390
here it'll tell me is ready to start

00:03:23,780 --> 00:03:28,550
processing so now it's off to the races

00:03:26,390 --> 00:03:30,290
and what we'll see here it's uploading

00:03:28,550 --> 00:03:31,790
the images to the processing node and

00:03:30,290 --> 00:03:33,590
this is going to be a live output of the

00:03:31,790 --> 00:03:35,270
processing mode processing images what's

00:03:33,590 --> 00:03:37,160
going through each image and what's

00:03:35,270 --> 00:03:38,750
going to actually do is resize them

00:03:37,160 --> 00:03:40,160
because we don't want to be doing full

00:03:38,750 --> 00:03:42,800
size images it's going to take too long

00:03:40,160 --> 00:03:44,510
so we've actually set it to to resize

00:03:42,800 --> 00:03:45,590
images person and analyze them so it's

00:03:44,510 --> 00:03:47,540
going to pull the focal length out of

00:03:45,590 --> 00:03:51,250
the images it's going to pull the geo

00:03:47,540 --> 00:03:53,330
location data how to be from from X tip

00:03:51,250 --> 00:03:54,530
okay so while I was running we'll come

00:03:53,330 --> 00:03:56,180
back to that in a second but I'm gonna

00:03:54,530 --> 00:03:58,940
talk more about the service and how we

00:03:56,180 --> 00:04:02,840
built this thing so let's go back into

00:03:58,940 --> 00:04:04,790
percent mode alright so why don't we

00:04:02,840 --> 00:04:07,760
just map budapest with the drone right

00:04:04,790 --> 00:04:09,800
and that's what that first 3d model was

00:04:07,760 --> 00:04:12,050
from is this morning we flew a drone we

00:04:09,800 --> 00:04:13,910
captured 180 aerial images and we were

00:04:12,050 --> 00:04:15,530
able to generate a 1 gigabyte data set

00:04:13,910 --> 00:04:18,799
and process them with it in one hour and

00:04:15,530 --> 00:04:20,210
six minutes on arm 64 servers so what's

00:04:18,799 --> 00:04:21,830
very impressive about this is we're

00:04:20,210 --> 00:04:26,000
getting to the point now where I'm

00:04:21,830 --> 00:04:27,860
seeing almost speed parity with xeon and

00:04:26,000 --> 00:04:29,240
when it comes to processing images like

00:04:27,860 --> 00:04:30,980
this so that's very good news for the

00:04:29,240 --> 00:04:33,100
arm servers or just arm ecos

00:04:30,980 --> 00:04:35,990
in general so what was our flight plan

00:04:33,100 --> 00:04:38,540
basically tell the drone how much image

00:04:35,990 --> 00:04:40,760
overlap did you want and you know what

00:04:38,540 --> 00:04:42,620
area you want to dress to mop and then

00:04:40,760 --> 00:04:44,390
that ring in the middle of an orbit so

00:04:42,620 --> 00:04:46,160
when you're doing structures like our

00:04:44,390 --> 00:04:48,350
hotels and stuff you want more depth to

00:04:46,160 --> 00:04:50,720
the photo it helps to photograph a

00:04:48,350 --> 00:04:52,280
tree-like stitch together it's a little

00:04:50,720 --> 00:04:54,920
bit better so that we get a basically

00:04:52,280 --> 00:04:57,320
win over all those lines there and then

00:04:54,920 --> 00:05:00,680
we did a loop around the outside to kind

00:04:57,320 --> 00:05:02,390
of get the more context for the image

00:05:00,680 --> 00:05:04,340
processing and then on the left hand

00:05:02,390 --> 00:05:06,680
side here those are the points after

00:05:04,340 --> 00:05:07,850
they've been analyzed by the software to

00:05:06,680 --> 00:05:10,040
know exactly where those photos were

00:05:07,850 --> 00:05:11,420
taken in the air that makes sense so

00:05:10,040 --> 00:05:13,010
there's kind of geo locating the photos

00:05:11,420 --> 00:05:14,420
and that's what this will do is it'll

00:05:13,010 --> 00:05:16,190
basically try to lay out the photos

00:05:14,420 --> 00:05:17,600
where they were taken and find the

00:05:16,190 --> 00:05:21,890
common points with unstitched from that

00:05:17,600 --> 00:05:23,600
any questions good so what do the

00:05:21,890 --> 00:05:25,370
aerials look like these are sixty

00:05:23,600 --> 00:05:27,500
percent overlap aerials these were

00:05:25,370 --> 00:05:29,240
taking this morning so we're working

00:05:27,500 --> 00:05:30,470
with a live data set the data set we

00:05:29,240 --> 00:05:32,780
just started processing is something

00:05:30,470 --> 00:05:36,740
that I've done previously so it'll be

00:05:32,780 --> 00:05:38,540
different than this so let's talk a

00:05:36,740 --> 00:05:40,790
little bit about what Kuber Nettie's is

00:05:38,540 --> 00:05:43,010
because that's the orchestration

00:05:40,790 --> 00:05:45,620
framework working with so it's commonly

00:05:43,010 --> 00:05:47,000
referred to as k8 it was originally

00:05:45,620 --> 00:05:48,920
designed by google and i use it for a

00:05:47,000 --> 00:05:50,180
lot of their services and then they

00:05:48,920 --> 00:05:52,250
donated it because they realize that

00:05:50,180 --> 00:05:54,500
they're the only ones contributed as

00:05:52,250 --> 00:05:55,580
projects that it's going to die overtime

00:05:54,500 --> 00:05:57,500
or something else will come in and

00:05:55,580 --> 00:06:00,050
replace it so they gave it to the cloud

00:05:57,500 --> 00:06:01,670
native foundation and really it's just

00:06:00,050 --> 00:06:03,440
an open source platform for automated

00:06:01,670 --> 00:06:05,810
deployment scaling and operations of

00:06:03,440 --> 00:06:08,810
application development using containers

00:06:05,810 --> 00:06:11,840
so usually works with docker container

00:06:08,810 --> 00:06:13,460
tool although other container runtimes

00:06:11,840 --> 00:06:16,670
are supported and accordance between a

00:06:13,460 --> 00:06:20,480
wide number of clubs like nodes running

00:06:16,670 --> 00:06:23,030
docker so why did I choose Cooper

00:06:20,480 --> 00:06:24,770
Nettie's there's a few reasons so they

00:06:23,030 --> 00:06:25,760
have load balancers for services so you

00:06:24,770 --> 00:06:27,860
don't have to build those yourself

00:06:25,760 --> 00:06:30,290
because those can be complexed they

00:06:27,860 --> 00:06:32,210
create a virtual IP which other services

00:06:30,290 --> 00:06:33,620
used so the DNS names will map to the

00:06:32,210 --> 00:06:35,810
service name so when you do a service

00:06:33,620 --> 00:06:37,760
discovery all you have to know is I need

00:06:35,810 --> 00:06:39,170
a database service it'll return service

00:06:37,760 --> 00:06:40,520
names and then you can simply use them

00:06:39,170 --> 00:06:42,620
in your application that don't have to

00:06:40,520 --> 00:06:44,060
know you know what pork postgres is

00:06:42,620 --> 00:06:44,340
running on or anything like that you can

00:06:44,060 --> 00:06:47,460
get all

00:06:44,340 --> 00:06:49,590
that some of your load bouncers and then

00:06:47,460 --> 00:06:50,790
it routes traffic to the underlying pod

00:06:49,590 --> 00:06:53,850
for the actual containers that are

00:06:50,790 --> 00:06:55,470
running it allows us to deploy services

00:06:53,850 --> 00:06:57,210
and scale them out horizontally because

00:06:55,470 --> 00:06:58,350
behind a load balancer then the traffic

00:06:57,210 --> 00:07:01,710
can be routed through them and can be

00:06:58,350 --> 00:07:03,330
distributed between n number of pods the

00:07:01,710 --> 00:07:04,710
other two meet part is the autoscaler so

00:07:03,330 --> 00:07:06,479
this is horizontal scales when I talk

00:07:04,710 --> 00:07:08,760
about horizontal scale I mean the sheer

00:07:06,479 --> 00:07:09,930
number of nodes are pods that you run

00:07:08,760 --> 00:07:12,060
underneath the load balancer where

00:07:09,930 --> 00:07:13,919
vertical scale is typically you throw

00:07:12,060 --> 00:07:15,360
more resources at something and you

00:07:13,919 --> 00:07:16,860
scale it up because you have more cores

00:07:15,360 --> 00:07:18,630
and more memory so we're talking about

00:07:16,860 --> 00:07:20,250
being able to deal with more traffic

00:07:18,630 --> 00:07:22,440
when we talk about horizontal scale for

00:07:20,250 --> 00:07:24,900
the most part there's also health checks

00:07:22,440 --> 00:07:26,460
so we can build in our own custom health

00:07:24,900 --> 00:07:29,550
checks to make sure the services are

00:07:26,460 --> 00:07:31,740
performing properly and they have built

00:07:29,550 --> 00:07:33,360
in ones and you can create your own and

00:07:31,740 --> 00:07:35,970
expose an API within your container to

00:07:33,360 --> 00:07:38,760
do health checks there's a good storage

00:07:35,970 --> 00:07:41,970
abstraction so you can abstract NFS

00:07:38,760 --> 00:07:44,400
storage shares that s3 locker whatever

00:07:41,970 --> 00:07:45,600
you want but basically to the pod that's

00:07:44,400 --> 00:07:47,669
actually running it doesn't matter it's

00:07:45,600 --> 00:07:49,350
just another volume out and to burn of

00:07:47,669 --> 00:07:51,000
these deals with the actual talking to

00:07:49,350 --> 00:07:54,600
the larger storage service or the object

00:07:51,000 --> 00:07:57,060
based our storage systems I think this

00:07:54,600 --> 00:07:58,950
is the biggest ones pod networking so

00:07:57,060 --> 00:08:01,410
they provide different networking layers

00:07:58,950 --> 00:08:02,940
for Cooper Nettie's with soccer you can

00:08:01,410 --> 00:08:04,260
have different pod networks but really

00:08:02,940 --> 00:08:06,090
you're kind of using the doctor network

00:08:04,260 --> 00:08:08,370
with this other people can create

00:08:06,090 --> 00:08:09,840
essentially virtual routers that you can

00:08:08,370 --> 00:08:12,870
use with different services so we've

00:08:09,840 --> 00:08:14,370
does l2 l3 level networking and calico

00:08:12,870 --> 00:08:15,810
does l3 so there's a whole bunch that

00:08:14,370 --> 00:08:18,930
you could choose from based on your

00:08:15,810 --> 00:08:21,539
networking needs so I get this question

00:08:18,930 --> 00:08:22,889
a lot why not use docker swarm well dr.

00:08:21,539 --> 00:08:25,139
storms are really good orchestration

00:08:22,889 --> 00:08:26,729
system in his own right but it depends

00:08:25,139 --> 00:08:28,260
on what you care about so like the two

00:08:26,729 --> 00:08:31,130
big things up here for dr. swerve is

00:08:28,260 --> 00:08:33,750
multi network per container op networks

00:08:31,130 --> 00:08:35,310
and distributed volume storage right

00:08:33,750 --> 00:08:37,560
those things are kind of why you would

00:08:35,310 --> 00:08:40,229
use form now on the other side kuber

00:08:37,560 --> 00:08:42,000
Nettie's there's you know dynamic dns

00:08:40,229 --> 00:08:44,490
service there's the load balancers

00:08:42,000 --> 00:08:47,010
there's contain a replica failover I

00:08:44,490 --> 00:08:49,080
mean you get basically kind of more of

00:08:47,010 --> 00:08:50,820
the production level services you expect

00:08:49,080 --> 00:08:52,950
running running a highly scalable highly

00:08:50,820 --> 00:08:54,510
available web service so that's you can

00:08:52,950 --> 00:08:56,490
go to the slides and look at this you

00:08:54,510 --> 00:08:58,040
could carry some details but this is

00:08:56,490 --> 00:09:01,550
kind of why I've chosen proven

00:08:58,040 --> 00:09:05,269
swarm so let's talk about the big

00:09:01,550 --> 00:09:07,459
problem so Cooper Nettie's on arm 64 I'm

00:09:05,269 --> 00:09:09,019
not sure how many people have many have

00:09:07,459 --> 00:09:10,279
ever done this before I've never met

00:09:09,019 --> 00:09:11,360
anybody that has I'm sure there are

00:09:10,279 --> 00:09:13,519
people out there that may have played

00:09:11,360 --> 00:09:14,870
around with this so I kind of went down

00:09:13,519 --> 00:09:16,759
the road of seeing well what's it going

00:09:14,870 --> 00:09:18,800
to take to get Cooper Nettie's running

00:09:16,759 --> 00:09:22,040
on arm 64 and there's missing pieces to

00:09:18,800 --> 00:09:25,279
the puzzle so the biggest one was there

00:09:22,040 --> 00:09:27,019
was no arm 64 container for the pod

00:09:25,279 --> 00:09:28,459
networks and the way the pod networks

00:09:27,019 --> 00:09:30,769
work in Coober netezza they're actually

00:09:28,459 --> 00:09:32,509
containers so of course everybody builds

00:09:30,769 --> 00:09:34,819
their containers for the pod networks

00:09:32,509 --> 00:09:36,500
using x86 architecture so the first

00:09:34,819 --> 00:09:39,649
thing I had to do was figure out how to

00:09:36,500 --> 00:09:41,300
rebuild the pod networks for a or 64 so

00:09:39,649 --> 00:09:42,709
I've done that and I've contributed back

00:09:41,300 --> 00:09:46,100
that back to the weave project so you

00:09:42,709 --> 00:09:47,930
can actually pull a are 64 we pod works

00:09:46,100 --> 00:09:49,310
directly from we've now so that would

00:09:47,930 --> 00:09:50,449
need to be done with the other pod

00:09:49,310 --> 00:09:53,720
networks as well if you were interested

00:09:50,449 --> 00:09:55,339
in the running them so basically this is

00:09:53,720 --> 00:09:57,079
the command you run now and it'll pull

00:09:55,339 --> 00:09:58,699
in the weave container and bam all of a

00:09:57,079 --> 00:10:02,209
sudden you're routing packets on arm 64

00:09:58,699 --> 00:10:03,980
and if you're curious we've met pod and

00:10:02,209 --> 00:10:06,350
actually the daemon set so it's like the

00:10:03,980 --> 00:10:09,380
dns server dhcp server all of those are

00:10:06,350 --> 00:10:11,389
you know considered a dame instead they

00:10:09,380 --> 00:10:14,389
run on alpine linux that's what their

00:10:11,389 --> 00:10:16,430
containers are based on so let's talk

00:10:14,389 --> 00:10:17,779
about the cluster that i'm using so it's

00:10:16,430 --> 00:10:21,709
three physical nodes because that's all

00:10:17,779 --> 00:10:24,160
i have there are 16 arm 64 cores 32 gigs

00:10:21,709 --> 00:10:27,410
of system memory there's spinning disk

00:10:24,160 --> 00:10:28,610
upstream teanna corey efi with a CTI and

00:10:27,410 --> 00:10:30,440
then we're running the enterprise

00:10:28,610 --> 00:10:32,779
reference platform our latest one from

00:10:30,440 --> 00:10:35,420
16 12 which is the 49 kernel and I'm

00:10:32,779 --> 00:10:36,800
choosing to you sent off and then I've

00:10:35,420 --> 00:10:38,180
actually so they didn't have any sense

00:10:36,800 --> 00:10:39,589
off seven packages so I've gone ahead

00:10:38,180 --> 00:10:41,300
and packaged them and made them

00:10:39,589 --> 00:10:42,350
available I'm Ashley in process of

00:10:41,300 --> 00:10:45,350
talking with the goober Nettie scheme

00:10:42,350 --> 00:10:46,730
about enabling multi arch builds for

00:10:45,350 --> 00:10:50,329
sent off so that they can provide them

00:10:46,730 --> 00:10:51,980
through their the official repo so that

00:10:50,329 --> 00:10:53,449
i'm using cooper Nettie's v1 dot five

00:10:51,980 --> 00:10:55,130
which is the latest release version

00:10:53,449 --> 00:10:56,269
there's one not six are seeds out there

00:10:55,130 --> 00:10:58,790
if you're interested you could probably

00:10:56,269 --> 00:11:02,389
pick up my packaging steps and pull them

00:10:58,790 --> 00:11:03,889
in so for persistent storage just

00:11:02,389 --> 00:11:06,709
because it's easy i'm using NFS you

00:11:03,889 --> 00:11:08,720
could easily use set for s3 i just

00:11:06,709 --> 00:11:10,550
wanted to keep it simple I wouldn't

00:11:08,720 --> 00:11:11,360
remember recommend NFS for large-scale

00:11:10,550 --> 00:11:14,660
deployments obvious

00:11:11,360 --> 00:11:15,800
NFS is an infinitely scalable just don't

00:11:14,660 --> 00:11:17,089
do it if you're going to really do a

00:11:15,800 --> 00:11:19,970
production services you something else

00:11:17,089 --> 00:11:23,810
so step would be a good choice in my

00:11:19,970 --> 00:11:25,970
opinion using docker 1 dot 13 with

00:11:23,810 --> 00:11:28,190
overlay to storage drivers so I'm living

00:11:25,970 --> 00:11:30,380
on the edge there's been some issues but

00:11:28,190 --> 00:11:33,200
so far it's worked pretty well and I'm

00:11:30,380 --> 00:11:36,820
using the ITV support IP IP v6 support

00:11:33,200 --> 00:11:39,440
in docker with that same doctor set up

00:11:36,820 --> 00:11:41,779
so let's talk about the stack that we're

00:11:39,440 --> 00:11:44,839
going to run here so from the firmware

00:11:41,779 --> 00:11:46,700
and kernel level acpi UEFI reference

00:11:44,839 --> 00:11:48,380
platform turtle then we've got our

00:11:46,700 --> 00:11:50,720
distribution layer which is sent off

00:11:48,380 --> 00:11:52,790
using the enterprise reference platform

00:11:50,720 --> 00:11:54,709
and then we've got doctor and weave and

00:11:52,790 --> 00:11:56,720
Cooper daddy's on top of that and then

00:11:54,709 --> 00:11:58,790
were going to run postgres Django engine

00:11:56,720 --> 00:12:02,630
X on top of pretty standard Enterprise

00:11:58,790 --> 00:12:04,519
stack now why did I choose a drone

00:12:02,630 --> 00:12:07,579
mapping application I could have just

00:12:04,519 --> 00:12:09,740
done a simple jangle web app and you

00:12:07,579 --> 00:12:11,450
know it would have been the same well

00:12:09,740 --> 00:12:12,860
because it doesn't actually really show

00:12:11,450 --> 00:12:15,290
that what the hardware's capable of

00:12:12,860 --> 00:12:16,850
right we want something we're all you

00:12:15,290 --> 00:12:18,920
know low-level developers if it's not

00:12:16,850 --> 00:12:21,350
being built with GCC or llvm and it's

00:12:18,920 --> 00:12:24,560
not crushing cores and it's really not a

00:12:21,350 --> 00:12:26,660
real service so this open dro mapping

00:12:24,560 --> 00:12:28,220
has got all the web pieces to it but

00:12:26,660 --> 00:12:30,079
it's also got a processing aspect which

00:12:28,220 --> 00:12:31,940
i think is very important to look at too

00:12:30,079 --> 00:12:33,589
so what are we going to do how we're

00:12:31,940 --> 00:12:35,209
going to build a scalable service of

00:12:33,589 --> 00:12:37,190
cooper Nettie's on arm 64 well we have

00:12:35,209 --> 00:12:38,390
to have a load balanced HTTP front end

00:12:37,190 --> 00:12:40,160
so we're going to use engine X in

00:12:38,390 --> 00:12:41,540
containers we're going to one

00:12:40,160 --> 00:12:43,399
replication controller which is going to

00:12:41,540 --> 00:12:44,959
provide a virtual IP address so all the

00:12:43,399 --> 00:12:46,279
input traffic from users are going to go

00:12:44,959 --> 00:12:48,380
through that then there's going to be

00:12:46,279 --> 00:12:49,730
free replicas running behind it which

00:12:48,380 --> 00:12:51,949
students at the load balancers going to

00:12:49,730 --> 00:12:54,920
distribute those HTTP requests to either

00:12:51,949 --> 00:12:56,630
ngx containers that are running and then

00:12:54,920 --> 00:12:57,860
the pods are going to for traffic to the

00:12:56,630 --> 00:12:59,540
back-end service and the back-end

00:12:57,860 --> 00:13:01,220
service is written in Django and so

00:12:59,540 --> 00:13:04,550
we're using to unicorn there to support

00:13:01,220 --> 00:13:06,470
you eww wsgi protocol and so we're going

00:13:04,550 --> 00:13:07,550
to have again one replication controller

00:13:06,470 --> 00:13:09,320
which is going to deal with all those

00:13:07,550 --> 00:13:11,149
requests and then hand them down to the

00:13:09,320 --> 00:13:13,699
individual containers so I'll show you

00:13:11,149 --> 00:13:16,040
what this looks like in a moment and

00:13:13,699 --> 00:13:18,610
here is the crux of it I don't recommend

00:13:16,040 --> 00:13:21,020
you ever try to do this with postgres

00:13:18,610 --> 00:13:23,590
don't do it it's a bad idea so tell me

00:13:21,020 --> 00:13:25,780
right now but I'm using TG pool to from

00:13:23,590 --> 00:13:27,640
we're to basically broker between the

00:13:25,780 --> 00:13:29,970
client and server side to postgres so we

00:13:27,640 --> 00:13:32,200
can have a master replicas and

00:13:29,970 --> 00:13:33,760
essentially a slave replica and then

00:13:32,200 --> 00:13:36,640
you've got another container kind of

00:13:33,760 --> 00:13:38,470
brokering all that if you can at all use

00:13:36,640 --> 00:13:40,090
something that's hosted they take all

00:13:38,470 --> 00:13:41,860
the complexity away you just talk to the

00:13:40,090 --> 00:13:43,480
database everybody's happy if you have

00:13:41,860 --> 00:13:45,400
to maintain one of these things I'd

00:13:43,480 --> 00:13:47,380
recommend really understanding the

00:13:45,400 --> 00:13:50,890
underlying technology that this is

00:13:47,380 --> 00:13:52,960
providing so holy cow what does that

00:13:50,890 --> 00:13:55,180
look like so this is the user here that

00:13:52,960 --> 00:13:56,800
says you guys going to website and you

00:13:55,180 --> 00:13:59,140
go through a load balancer and this load

00:13:56,800 --> 00:14:01,060
balancers determining which pod hasn't

00:13:59,140 --> 00:14:03,130
you know service to request laughs and

00:14:01,060 --> 00:14:04,480
let's hand it off to that pod so what's

00:14:03,130 --> 00:14:06,190
going through engine X here now as you

00:14:04,480 --> 00:14:07,330
noticed well we've got here is the

00:14:06,190 --> 00:14:09,430
content delivery network we have to

00:14:07,330 --> 00:14:10,780
serve static assets from the back end

00:14:09,430 --> 00:14:12,580
it's typically they're generated there

00:14:10,780 --> 00:14:14,710
so our back ends when they start will

00:14:12,580 --> 00:14:16,270
copy their static assets houses content

00:14:14,710 --> 00:14:18,160
delivery network which is running on NFS

00:14:16,270 --> 00:14:19,930
which will give them well basically

00:14:18,160 --> 00:14:21,430
you'll do a volume amount to the engine

00:14:19,930 --> 00:14:24,970
deck spot so they can serve the latest

00:14:21,430 --> 00:14:26,440
static assets so then the index take the

00:14:24,970 --> 00:14:28,060
HTTP request and then they translate

00:14:26,440 --> 00:14:29,290
them USD and their pass them out of the

00:14:28,060 --> 00:14:31,330
back end which goes through another load

00:14:29,290 --> 00:14:34,030
balancer and then to our back-end

00:14:31,330 --> 00:14:35,680
services here now these scale out lines

00:14:34,030 --> 00:14:37,990
that i put here this is where you scale

00:14:35,680 --> 00:14:39,580
out so as load increases you just add

00:14:37,990 --> 00:14:41,350
more pods buying the load balancer and

00:14:39,580 --> 00:14:43,390
then you're essentially your service can

00:14:41,350 --> 00:14:45,670
deal with more traffic that's the idea

00:14:43,390 --> 00:14:48,370
so we can do that on the front end we

00:14:45,670 --> 00:14:49,750
can do that on the back end and goodness

00:14:48,370 --> 00:14:52,300
we don't ever want to do it back here

00:14:49,750 --> 00:14:54,460
but we can we've got PG pool which is

00:14:52,300 --> 00:14:56,710
coordinating master and slave replicas

00:14:54,460 --> 00:14:59,110
and they're behind their own load

00:14:56,710 --> 00:15:02,110
balancers respectively so this is just a

00:14:59,110 --> 00:15:03,790
web part now the processing nodes will

00:15:02,110 --> 00:15:07,000
talk directly to the back end via

00:15:03,790 --> 00:15:10,450
swagger API to pick up jobs and I'll

00:15:07,000 --> 00:15:13,540
talk about that next so they do the real

00:15:10,450 --> 00:15:15,880
work they thrash machines they bring

00:15:13,540 --> 00:15:17,710
xeon cores to the ground I mean this is

00:15:15,880 --> 00:15:20,260
some heavy lifting when we're processing

00:15:17,710 --> 00:15:22,270
all of this image imagery so they pull

00:15:20,260 --> 00:15:23,800
images they inspect it they compile they

00:15:22,270 --> 00:15:26,250
stitch and then the output the final

00:15:23,800 --> 00:15:29,230
product they do all of the real work

00:15:26,250 --> 00:15:30,550
they're not stateless though so the big

00:15:29,230 --> 00:15:32,380
thing is you're going to build a service

00:15:30,550 --> 00:15:34,180
on kuber Nettie's these are containers

00:15:32,380 --> 00:15:36,430
that don't really save their states so

00:15:34,180 --> 00:15:37,379
if they die and you try to restart them

00:15:36,430 --> 00:15:39,539
they don't know their states

00:15:37,379 --> 00:15:41,910
dublin scale that way so this is the

00:15:39,539 --> 00:15:45,119
part that you need to design something

00:15:41,910 --> 00:15:47,519
to orchestrate that so essentially

00:15:45,119 --> 00:15:49,559
something that measures lowes and then

00:15:47,519 --> 00:15:51,749
we'll bring on the processing nodes and

00:15:49,559 --> 00:15:53,489
things like that so this is the part

00:15:51,749 --> 00:15:54,959
that doesn't scale in the same way that

00:15:53,489 --> 00:15:56,579
the web front-end does well the good

00:15:54,959 --> 00:15:57,929
news is we can start a container and

00:15:56,579 --> 00:15:59,849
they can self register so it's

00:15:57,929 --> 00:16:01,889
essentially all it is is finding an open

00:15:59,849 --> 00:16:03,359
node starting the container and then

00:16:01,889 --> 00:16:09,899
that adds more processing power to your

00:16:03,359 --> 00:16:11,939
web service so yeah kuvan edited

00:16:09,899 --> 00:16:13,259
straightforward to create a highly

00:16:11,939 --> 00:16:14,999
scalable service for the most part

00:16:13,259 --> 00:16:17,399
especially with a jangle web application

00:16:14,999 --> 00:16:19,109
but again like I said you know we're

00:16:17,399 --> 00:16:20,789
really interested in doing some serious

00:16:19,109 --> 00:16:22,679
computation and I think that's where

00:16:20,789 --> 00:16:26,189
we're starting to see the arm 64 servers

00:16:22,679 --> 00:16:28,139
shine a little bit so again this project

00:16:26,189 --> 00:16:30,689
is all the developers on it have

00:16:28,139 --> 00:16:32,159
massively you know huge Xeon clusters

00:16:30,689 --> 00:16:34,529
that they run all this stuff on so when

00:16:32,159 --> 00:16:35,789
I came to work on the project they kind

00:16:34,529 --> 00:16:38,220
of were laughing the game was running

00:16:35,789 --> 00:16:40,049
this on a raspberry pi 2 and we've kind

00:16:38,220 --> 00:16:41,579
of compared computation times and we're

00:16:40,049 --> 00:16:44,249
about 15 minutes slower on the same data

00:16:41,579 --> 00:16:47,639
set so we're getting there it's looking

00:16:44,249 --> 00:16:49,079
really good so let's talk about the

00:16:47,639 --> 00:16:50,789
image processing suppose this is a big

00:16:49,079 --> 00:16:52,649
project there's a lot of things that

00:16:50,789 --> 00:16:54,809
need to run on arm 64 that weren't

00:16:52,649 --> 00:16:58,079
running so this is just a big list of

00:16:54,809 --> 00:16:59,909
all of the computer vision libraries and

00:16:58,079 --> 00:17:03,119
image processing libraries that are used

00:16:59,909 --> 00:17:06,089
so there's a whole bunch they really

00:17:03,119 --> 00:17:10,110
work the system well it's a good test to

00:17:06,089 --> 00:17:12,120
see how much of arms 64 is at parity

00:17:10,110 --> 00:17:14,459
essentially with packages and software

00:17:12,120 --> 00:17:17,339
versions with x86 and we've done a

00:17:14,459 --> 00:17:21,059
pretty good job so far any questions

00:17:17,339 --> 00:17:23,819
about this so far okay so good news i

00:17:21,059 --> 00:17:26,069
ported anything that wasn't working to

00:17:23,819 --> 00:17:27,509
run opened rome app on ARM processors

00:17:26,069 --> 00:17:29,070
and i'm up streaming them to those

00:17:27,509 --> 00:17:30,600
various projects that you saw there i

00:17:29,070 --> 00:17:32,370
think about seventy percent of them if

00:17:30,600 --> 00:17:35,580
they'd merged already so we're thirty

00:17:32,370 --> 00:17:37,289
percent left and you know when when this

00:17:35,580 --> 00:17:39,059
is all done by the end of march we're

00:17:37,289 --> 00:17:42,090
hoping it's going to land arm support of

00:17:39,059 --> 00:17:43,860
landon 0.3 release of opened road map

00:17:42,090 --> 00:17:46,919
now why is that important and why is

00:17:43,860 --> 00:17:49,440
this exciting to me personally being you

00:17:46,919 --> 00:17:50,700
know flying aircraft since 2004 arm

00:17:49,440 --> 00:17:52,320
cores have been in

00:17:50,700 --> 00:17:53,820
craft pretty much from the beginning

00:17:52,320 --> 00:17:56,610
with with flight controllers and I am

00:17:53,820 --> 00:17:57,810
used as such I think it's five years

00:17:56,610 --> 00:17:59,880
we're going to see drones that are so

00:17:57,810 --> 00:18:02,700
powerful that they can process imagery

00:17:59,880 --> 00:18:04,410
on board right so being able to have

00:18:02,700 --> 00:18:06,210
this running in a container on board as

00:18:04,410 --> 00:18:08,190
you're collecting images when the drone

00:18:06,210 --> 00:18:10,380
lands all of your stitching has been

00:18:08,190 --> 00:18:11,700
done is huge right i mean how cool is

00:18:10,380 --> 00:18:13,830
that so we're getting we're not there

00:18:11,700 --> 00:18:15,630
yet but i can see that will be there may

00:18:13,830 --> 00:18:17,580
be in five years so that's why i was

00:18:15,630 --> 00:18:19,050
very interested in doing this plus life

00:18:17,580 --> 00:18:21,360
i had the hardware at felt like it was

00:18:19,050 --> 00:18:26,160
my duty to to make sure cool stuff like

00:18:21,360 --> 00:18:27,840
this works on arm okay so let's just

00:18:26,160 --> 00:18:29,550
before you start going into how to

00:18:27,840 --> 00:18:33,090
update this thing let's just take a take

00:18:29,550 --> 00:18:34,680
a peek here okay this is only 15 minutes

00:18:33,090 --> 00:18:39,090
I don't know if I'm gonna be able to go

00:18:34,680 --> 00:18:40,470
the whole hour here guys okay so we got

00:18:39,090 --> 00:18:42,570
about five minutes left on this process

00:18:40,470 --> 00:18:44,640
they can kind of check in and see yeah

00:18:42,570 --> 00:18:45,990
so it's generating the google map tiles

00:18:44,640 --> 00:18:48,090
because you'll be able to actually see

00:18:45,990 --> 00:18:49,680
your 2d ortho mosaic geo-located on top

00:18:48,090 --> 00:18:51,330
of google maps so you can kind of see

00:18:49,680 --> 00:18:54,090
your resolution because it was captured

00:18:51,330 --> 00:18:57,090
by your drone overlaid on google maps

00:18:54,090 --> 00:19:00,180
which is me so well that's processing

00:18:57,090 --> 00:19:02,460
what do you why don't we updated so why

00:19:00,180 --> 00:19:04,410
don't we update our web frontend

00:19:02,460 --> 00:19:08,070
containers right and can we do this with

00:19:04,410 --> 00:19:13,110
one command yes you can so actually the

00:19:08,070 --> 00:19:17,460
wrong so we were running latest which

00:19:13,110 --> 00:19:19,640
was potentially actually let's go like

00:19:17,460 --> 00:19:19,640
this

00:19:23,610 --> 00:19:28,570
okay just so you can see we're actually

00:19:25,899 --> 00:19:30,490
running this on armed 64 and let's just

00:19:28,570 --> 00:19:32,889
see if we're loading up you can see the

00:19:30,490 --> 00:19:34,779
google map tile generation is actually

00:19:32,889 --> 00:19:36,549
running right here with 16 cores this

00:19:34,779 --> 00:19:39,340
one's only doing single thread at work

00:19:36,549 --> 00:19:47,889
at the moment so let's take a look at

00:19:39,340 --> 00:19:50,499
our cluster okay so these are the

00:19:47,889 --> 00:19:52,929
positive running right this is the

00:19:50,499 --> 00:19:59,649
actual containers that are running now

00:19:52,929 --> 00:20:01,960
if we say here's our services engine x

00:19:59,649 --> 00:20:05,769
PG pool web OD n which is the back end

00:20:01,960 --> 00:20:07,629
we've got our database services so

00:20:05,769 --> 00:20:08,740
that's kind of what everything looks

00:20:07,629 --> 00:20:10,240
like at this point now there's three

00:20:08,740 --> 00:20:12,190
notes so these services are spread

00:20:10,240 --> 00:20:14,499
across those three nodes based on the

00:20:12,190 --> 00:20:16,179
Cooper daddy's scheduler so let's say we

00:20:14,499 --> 00:20:20,679
want to update our engine X pods and

00:20:16,179 --> 00:20:22,659
essentially all it is i'll show you is

00:20:20,679 --> 00:20:24,940
this bit here so we're going to set a

00:20:22,659 --> 00:20:27,279
new image so container name it's the

00:20:24,940 --> 00:20:29,860
same container name but a new tag right

00:20:27,279 --> 00:20:31,960
so we've we've updated engine X we moved

00:20:29,860 --> 00:20:33,340
up a version maybe we've added some

00:20:31,960 --> 00:20:36,009
different optimizations or flags

00:20:33,340 --> 00:20:37,509
extensions right all you have to do is

00:20:36,009 --> 00:20:39,820
put a new tag in and we can roll an

00:20:37,509 --> 00:20:41,259
update to it so we don't want to do

00:20:39,820 --> 00:20:44,169
latest because they believe that's

00:20:41,259 --> 00:20:48,119
what's running now so there's a tag

00:20:44,169 --> 00:20:52,389
called update okay so now it's it

00:20:48,119 --> 00:20:55,119
essentially went and trying to okay so

00:20:52,389 --> 00:21:01,690
what it did there pycharm thank you very

00:20:55,119 --> 00:21:03,039
much ok so what how does this update

00:21:01,690 --> 00:21:04,600
work how did I just update a web service

00:21:03,039 --> 00:21:05,710
in real time without any downtime so

00:21:04,600 --> 00:21:08,139
let's just go check to make sure it's

00:21:05,710 --> 00:21:10,480
actually still up hey it still works

00:21:08,139 --> 00:21:12,159
great now we just slid in a new version

00:21:10,480 --> 00:21:13,600
of engine X in there and didn't have any

00:21:12,159 --> 00:21:17,710
downtime so let's take a look at the

00:21:13,600 --> 00:21:19,450
console output so roll out two of three

00:21:17,710 --> 00:21:21,519
new replicas has been updated so what it

00:21:19,450 --> 00:21:23,110
does is since behind a load balancer it

00:21:21,519 --> 00:21:25,119
can take down a container right now we

00:21:23,110 --> 00:21:27,850
still have two instances taking the HTTP

00:21:25,119 --> 00:21:29,379
traffic it brings up the new instance so

00:21:27,850 --> 00:21:31,240
now we have a new one new instance and

00:21:29,379 --> 00:21:32,200
to hold and then it takes them down one

00:21:31,240 --> 00:21:34,179
at a time in looks like

00:21:32,200 --> 00:21:36,700
so you never actually have any HTTP

00:21:34,179 --> 00:21:38,500
requests that are dropped and then you

00:21:36,700 --> 00:21:40,000
can kind of slowly roll in your service

00:21:38,500 --> 00:21:41,620
and then roll out your old services so

00:21:40,000 --> 00:21:43,779
that's actually what it did so now all

00:21:41,620 --> 00:21:46,269
of the engine X pods that are running

00:21:43,779 --> 00:21:51,399
the new version of engine X so I can

00:21:46,269 --> 00:21:52,510
actually go the other way now oops and

00:21:51,399 --> 00:21:59,220
go back to the version that I was

00:21:52,510 --> 00:22:04,840
running and we can watch it roll back

00:21:59,220 --> 00:22:07,029
well it's rolling back we're still

00:22:04,840 --> 00:22:10,750
serving web traffic so we can do the

00:22:07,029 --> 00:22:13,120
same thing on the back end as well there

00:22:10,750 --> 00:22:17,860
any questions on that is this just

00:22:13,120 --> 00:22:19,510
useful information yes okay so that's

00:22:17,860 --> 00:22:21,700
how you update a service and that's I

00:22:19,510 --> 00:22:24,159
think one of the key pieces of Cooper

00:22:21,700 --> 00:22:25,240
Nettie's and they offer an API or anthem

00:22:24,159 --> 00:22:28,210
a quebec and to present on get real

00:22:25,240 --> 00:22:30,220
quick it offers an API so you can do

00:22:28,210 --> 00:22:31,929
this and you can automate your roll ups

00:22:30,220 --> 00:22:33,370
and you can change your different

00:22:31,929 --> 00:22:35,080
services and you can do it without any

00:22:33,370 --> 00:22:37,299
service for disruption and that that's

00:22:35,080 --> 00:22:39,010
kind of a big big thing so how do you

00:22:37,299 --> 00:22:40,690
scale up a service well there's a couple

00:22:39,010 --> 00:22:42,490
different ways now I don't have enough

00:22:40,690 --> 00:22:43,950
nodes to do autoscaler but if you ever

00:22:42,490 --> 00:22:46,059
use like google compute engine

00:22:43,950 --> 00:22:47,740
essentially you can tell us you know

00:22:46,059 --> 00:22:49,600
there are different metrics that you

00:22:47,740 --> 00:22:51,100
look for so for like engine X you might

00:22:49,600 --> 00:22:53,380
be the number of requests are processed

00:22:51,100 --> 00:22:55,240
you can have a threshold which then will

00:22:53,380 --> 00:22:57,309
start to scale out the nodes and then

00:22:55,240 --> 00:22:59,799
what that means that you also need to

00:22:57,309 --> 00:23:01,630
add real hardware to your cluster if you

00:22:59,799 --> 00:23:03,100
scale your cluster out first and then

00:23:01,630 --> 00:23:04,330
you scale out your services so you can

00:23:03,100 --> 00:23:05,980
do all of that inside of Google compute

00:23:04,330 --> 00:23:08,289
engine however when you're running a

00:23:05,980 --> 00:23:10,019
bear a bear metal cluster unfortunately

00:23:08,289 --> 00:23:12,250
that's not something that you can do

00:23:10,019 --> 00:23:13,539
because it's real hardware and you have

00:23:12,250 --> 00:23:15,370
to control it and Google's got it all

00:23:13,539 --> 00:23:21,100
automated it's pretty neat let's just

00:23:15,370 --> 00:23:24,390
see where we are with this we're getting

00:23:21,100 --> 00:23:26,170
really close let's see if it's shipping

00:23:24,390 --> 00:23:27,760
because I want to show you guys a good

00:23:26,170 --> 00:23:36,360
okay so we'll just talk here for a

00:23:27,760 --> 00:23:36,360
little bit until this is done yeah yeah

00:23:47,700 --> 00:23:52,929
yes so that's good point so the question

00:23:50,679 --> 00:23:54,490
was I run dr and container locally it's

00:23:52,929 --> 00:23:55,809
simple for me to use what the overhead

00:23:54,490 --> 00:23:56,860
of running super Nettie's essentially

00:23:55,809 --> 00:23:57,790
and what do you have to learn so let's

00:23:56,860 --> 00:24:00,220
take a look at that that's a good

00:23:57,790 --> 00:24:02,080
question so for our deployments here

00:24:00,220 --> 00:24:03,460
I've got a couple different things so at

00:24:02,080 --> 00:24:05,260
the end of this I'm going to tear that

00:24:03,460 --> 00:24:06,910
service down and I'll redeploy it in a

00:24:05,260 --> 00:24:08,830
minute so you can kind of see how this

00:24:06,910 --> 00:24:12,910
all works but let's take a look at the

00:24:08,830 --> 00:24:14,620
back end pod actually so this is the

00:24:12,910 --> 00:24:16,420
game to understand a little bit you guys

00:24:14,620 --> 00:24:18,640
can see can you guys see not open little

00:24:16,420 --> 00:24:28,630
bigger a sec what do you think make it

00:24:18,640 --> 00:24:30,520
bigger okay okay so this is the help say

00:24:28,630 --> 00:24:33,850
no thank you okay so this is that this

00:24:30,520 --> 00:24:37,780
is the definition of a service in Cooper

00:24:33,850 --> 00:24:39,580
teddies and what probably you know makes

00:24:37,780 --> 00:24:41,050
sense to use this image name right if

00:24:39,580 --> 00:24:43,150
the doctor have the image name with

00:24:41,050 --> 00:24:44,679
colon then attack right but all the

00:24:43,150 --> 00:24:46,420
other stuff is formed right i mean this

00:24:44,679 --> 00:24:48,190
is all cooper Nettie's language on top

00:24:46,420 --> 00:24:49,840
of it so you can do JSON or gamble

00:24:48,190 --> 00:24:52,570
format i find the animals nicer because

00:24:49,840 --> 00:24:54,190
i can do things like comment up my debug

00:24:52,570 --> 00:24:56,620
commands and then switch them easily and

00:24:54,190 --> 00:24:58,809
then reapply them so essentially what it

00:24:56,620 --> 00:25:00,550
says is the page this is my name space

00:24:58,809 --> 00:25:02,470
and that's an interesting thing to talk

00:25:00,550 --> 00:25:04,510
about so another awesome thing about

00:25:02,470 --> 00:25:07,300
google ad age's you can create name

00:25:04,510 --> 00:25:09,070
spaces within Cooper dennys and any pod

00:25:07,300 --> 00:25:11,530
running in that namespace can resolve

00:25:09,070 --> 00:25:13,660
the DNS names of any of your other pods

00:25:11,530 --> 00:25:16,120
but they can't you know you can set

00:25:13,660 --> 00:25:18,010
different ways but by default they're

00:25:16,120 --> 00:25:20,500
isolated in their own instance so you

00:25:18,010 --> 00:25:21,910
can have like you know customer one and

00:25:20,500 --> 00:25:23,140
they have all their services running

00:25:21,910 --> 00:25:24,970
there you have customer to in another

00:25:23,140 --> 00:25:27,370
instance another namespace and they're

00:25:24,970 --> 00:25:29,800
isolated but you can also have them jump

00:25:27,370 --> 00:25:31,059
networks if you allow that so it depends

00:25:29,800 --> 00:25:33,040
on what you're using them for but it

00:25:31,059 --> 00:25:35,380
gives you a nice like microservers I

00:25:33,040 --> 00:25:35,830
isolation so I've got my name space I've

00:25:35,380 --> 00:25:37,929
made my

00:25:35,830 --> 00:25:40,899
app i told them a container to pull and

00:25:37,929 --> 00:25:43,120
the command block right here is like

00:25:40,899 --> 00:25:44,470
your command block and docker right you

00:25:43,120 --> 00:25:46,480
can tell it to override the command

00:25:44,470 --> 00:25:48,850
that's actually in the docker file so

00:25:46,480 --> 00:25:50,890
you can do different things and then

00:25:48,850 --> 00:25:53,200
your Forks here your container force so

00:25:50,890 --> 00:25:54,490
I i say i want you to open port 8000 for

00:25:53,200 --> 00:25:57,760
me because this is jay unicorn that's

00:25:54,490 --> 00:25:59,440
what it's serving on cluster first and

00:25:57,760 --> 00:26:01,899
no selector i can make it even brought

00:25:59,440 --> 00:26:05,019
on a specific note if I want to and then

00:26:01,899 --> 00:26:07,210
provide standard in TTYL and then the

00:26:05,019 --> 00:26:09,159
restart policy is if this node goes

00:26:07,210 --> 00:26:10,570
offline and the container dies is to

00:26:09,159 --> 00:26:12,429
always restart it so you can define

00:26:10,570 --> 00:26:15,100
these things like that so let's take a

00:26:12,429 --> 00:26:17,380
look at the deployment script because I

00:26:15,100 --> 00:26:19,299
think this shows them so basically all

00:26:17,380 --> 00:26:20,710
this stuff here is delete what's already

00:26:19,299 --> 00:26:22,019
running you're going to redeploy service

00:26:20,710 --> 00:26:26,289
I don't want that stuff hanging around

00:26:22,019 --> 00:26:29,440
then you create the next line here let

00:26:26,289 --> 00:26:32,380
me highlight it you create the service

00:26:29,440 --> 00:26:33,909
based on the ammo file right but that's

00:26:32,380 --> 00:26:36,159
not good enough actually sees me that

00:26:33,909 --> 00:26:37,779
that's the deployment the deployment is

00:26:36,159 --> 00:26:40,120
different than the service the service

00:26:37,779 --> 00:26:43,539
is here and what this tells the service

00:26:40,120 --> 00:26:46,539
to do is expose port 8000 of that back

00:26:43,539 --> 00:26:48,639
end as to the load balancer so when you

00:26:46,539 --> 00:26:50,710
make requests on port 8000 against the

00:26:48,639 --> 00:26:52,659
load balancer that's where it knows to

00:26:50,710 --> 00:26:55,090
get zeph port number now down here you

00:26:52,659 --> 00:26:57,039
can see I remapped it right so this is

00:26:55,090 --> 00:26:58,750
the web front-end that i'm using so I'd

00:26:57,039 --> 00:27:00,490
say the target towards what engine X is

00:26:58,750 --> 00:27:02,710
serving on port 80 but I want you to

00:27:00,490 --> 00:27:04,179
actually serve on port 8080 I want you

00:27:02,710 --> 00:27:06,039
to map it to an external IP address so

00:27:04,179 --> 00:27:07,720
this is how you basically forward your

00:27:06,039 --> 00:27:10,570
services outside of Cooper Nettie's

00:27:07,720 --> 00:27:12,850
network and then I have a port forward

00:27:10,570 --> 00:27:15,760
on my router if you notice whereas 80 81

00:27:12,850 --> 00:27:18,039
here that's actually being translated

00:27:15,760 --> 00:27:20,470
from the external IP of a cooper Neddy's

00:27:18,039 --> 00:27:22,539
node from 80 81 to 88 and then giving it

00:27:20,470 --> 00:27:25,870
right into engine X all that traffic is

00:27:22,539 --> 00:27:29,260
going there so you've got things like

00:27:25,870 --> 00:27:31,870
that so this is all different than what

00:27:29,260 --> 00:27:33,340
dr. provides it's more complex there's a

00:27:31,870 --> 00:27:35,289
whole bunch of stuff that you can do

00:27:33,340 --> 00:27:37,840
there's a they actually have a good

00:27:35,289 --> 00:27:39,519
documentation for it but its extensive

00:27:37,840 --> 00:27:42,070
so you can get you can find yourself

00:27:39,519 --> 00:27:43,659
lost in it very easily that's the

00:27:42,070 --> 00:27:47,260
downside of Hoover enemies unfortunately

00:27:43,659 --> 00:27:49,360
i will say so since version 1 dot 4

00:27:47,260 --> 00:27:51,940
they've made it incredibly easy

00:27:49,360 --> 00:27:53,679
set up Cooper Nettie did before let me

00:27:51,940 --> 00:28:08,350
see if I can just pull it up because

00:27:53,679 --> 00:28:09,820
it's ridiculous you know it'll have a

00:28:08,350 --> 00:28:12,130
link to the old one but essentially it

00:28:09,820 --> 00:28:13,750
was about three pages of how to set up

00:28:12,130 --> 00:28:15,549
coover Nettie's and how to talk to the

00:28:13,750 --> 00:28:17,200
pod networks and connect them and now

00:28:15,549 --> 00:28:19,480
there's literally there's four steps

00:28:17,200 --> 00:28:21,299
there's one of four so you get cube ATM

00:28:19,480 --> 00:28:23,650
which is packaged now forearm six before

00:28:21,299 --> 00:28:25,059
within sentences context I believe

00:28:23,650 --> 00:28:26,290
Debian already has a packaged up stream

00:28:25,059 --> 00:28:28,480
so you can do this on a debian machine

00:28:26,290 --> 00:28:30,790
right out of the box which is nice then

00:28:28,480 --> 00:28:33,640
basically install docker if you don't

00:28:30,790 --> 00:28:35,350
already have it installed and then you

00:28:33,640 --> 00:28:37,480
initialize your master which is like a

00:28:35,350 --> 00:28:39,580
single command now you just call in it

00:28:37,480 --> 00:28:41,799
that's your master and what that will do

00:28:39,580 --> 00:28:44,350
is actually dump you out a token so you

00:28:41,799 --> 00:28:46,780
can kind of see here it doesn't really

00:28:44,350 --> 00:28:48,610
show us but this is the joy so it'll

00:28:46,780 --> 00:28:51,309
give you a token at the end of that in

00:28:48,610 --> 00:28:52,600
its command and then you can just go to

00:28:51,309 --> 00:28:54,910
different nodes after you've installed

00:28:52,600 --> 00:28:56,620
docker and cube ATM on them and just

00:28:54,910 --> 00:28:58,720
join them to your cluster so it's very

00:28:56,620 --> 00:29:07,480
quick to actually join notes to your

00:28:58,720 --> 00:29:08,679
cluster now than it was before ok edits

00:29:07,480 --> 00:29:11,710
done ok so let's take a look at what

00:29:08,679 --> 00:29:15,790
this looks like so this is the point

00:29:11,710 --> 00:29:19,299
cloud right this isn't going to look

00:29:15,790 --> 00:29:22,030
very good cuz these just like pixels in

00:29:19,299 --> 00:29:24,010
space that it's located right and so

00:29:22,030 --> 00:29:25,360
this is kind of blob but this shows you

00:29:24,010 --> 00:29:27,040
that there's some terrain here it's

00:29:25,360 --> 00:29:28,870
stitch together so what we actually want

00:29:27,040 --> 00:29:30,250
to see is taking that point cloud and

00:29:28,870 --> 00:29:31,120
overlaying a texture on top of but

00:29:30,250 --> 00:29:33,640
that's where it's interesting that's

00:29:31,120 --> 00:29:36,820
where you get a real 3d map that looks

00:29:33,640 --> 00:29:38,679
like a photo and a lot of times what I

00:29:36,820 --> 00:29:41,380
know I have a quarry example here and

00:29:38,679 --> 00:29:42,970
the reason is that is because uh Cory so

00:29:41,380 --> 00:29:45,400
gravel quarries in the united states i'm

00:29:42,970 --> 00:29:47,440
sure all around the world have a problem

00:29:45,400 --> 00:29:49,600
and the problem is i've got all this

00:29:47,440 --> 00:29:51,360
gravel how do i tell a customer that

00:29:49,600 --> 00:29:53,530
once gravel from me how much i have

00:29:51,360 --> 00:29:55,090
because these guys are just like have

00:29:53,530 --> 00:29:56,620
huge machinery and they're moving stuff

00:29:55,090 --> 00:29:58,510
around their gigantic pile so what they

00:29:56,620 --> 00:30:01,809
used to do and maybe a lot of them still

00:29:58,510 --> 00:30:02,710
do is they have surveyors come out and

00:30:01,809 --> 00:30:04,960
do depth survey

00:30:02,710 --> 00:30:06,100
throughout the entire pile right and

00:30:04,960 --> 00:30:08,529
then they can calculate the volume

00:30:06,100 --> 00:30:09,850
volume s or the volume of a pile and

00:30:08,529 --> 00:30:12,340
then estimate how much gravel to have

00:30:09,850 --> 00:30:15,010
well they've realized that we can fly

00:30:12,340 --> 00:30:17,289
drones and we can fly their entire

00:30:15,010 --> 00:30:18,940
quarry in like 12 minutes and generate

00:30:17,289 --> 00:30:21,100
these 3d models which then we can

00:30:18,940 --> 00:30:23,649
highlight the pile and calculate the

00:30:21,100 --> 00:30:25,120
volume within a reasonable amount of

00:30:23,649 --> 00:30:26,470
tolerance so if we zoom in on this here

00:30:25,120 --> 00:30:29,860
you can kind of see so this is one of

00:30:26,470 --> 00:30:35,230
the piles here can I move it to the side

00:30:29,860 --> 00:30:36,789
and it's enough for you to know you

00:30:35,230 --> 00:30:38,950
could do a volume calculation on that we

00:30:36,789 --> 00:30:41,590
could isolate this piece right here and

00:30:38,950 --> 00:30:43,659
I mean you can see you basically now

00:30:41,590 --> 00:30:45,210
can't really tell from this this angle

00:30:43,659 --> 00:30:48,299
but this is underneath the image you

00:30:45,210 --> 00:30:50,590
could figure out how much volume that is

00:30:48,299 --> 00:30:52,690
based on a couple of things so that's

00:30:50,590 --> 00:30:54,760
what these guys do they use drones know

00:30:52,690 --> 00:30:56,470
how to measure it and why does that make

00:30:54,760 --> 00:30:58,090
their bottom end better because they can

00:30:56,470 --> 00:31:00,279
do it every day or every week and they

00:30:58,090 --> 00:31:01,899
know exactly how much raw material they

00:31:00,279 --> 00:31:03,490
have whereas before they would do it

00:31:01,899 --> 00:31:04,840
once a year and you know their books

00:31:03,490 --> 00:31:06,190
would be off so now they can kind of

00:31:04,840 --> 00:31:10,929
coordinate that a little bit better so

00:31:06,190 --> 00:31:14,470
that is this now there's one less trick

00:31:10,929 --> 00:31:15,640
I've got up my sleeve so scale up the

00:31:14,470 --> 00:31:20,039
service we didn't talk about that now if

00:31:15,640 --> 00:31:20,039
you look when i did this command here

00:31:21,750 --> 00:31:28,059
there it is okay somebody should have

00:31:26,110 --> 00:31:29,919
called me out on this this backends only

00:31:28,059 --> 00:31:33,640
running one replica I said there was

00:31:29,919 --> 00:31:35,679
three right so I lied to you sorry but

00:31:33,640 --> 00:31:37,210
we actually need to scale this up now so

00:31:35,679 --> 00:31:39,370
how do i scale it up how do I say okay

00:31:37,210 --> 00:31:40,990
instead of one instance of a back-end I

00:31:39,370 --> 00:31:43,929
need three and will it still work will

00:31:40,990 --> 00:31:45,100
the service still work what we do as we

00:31:43,929 --> 00:31:46,990
go into the definition violet I was

00:31:45,100 --> 00:31:49,960
showing you earlier and up here at the

00:31:46,990 --> 00:31:54,000
top there's replicas and I've got it set

00:31:49,960 --> 00:31:59,380
at one now so let's set it to three and

00:31:54,000 --> 00:32:01,450
now we just do a nifty a command here B

00:31:59,380 --> 00:32:03,159
apply command so anything to change on

00:32:01,450 --> 00:32:04,779
disk to that yam will file and you want

00:32:03,159 --> 00:32:06,159
to apply it to a running cluster all you

00:32:04,779 --> 00:32:12,039
have to do is referenced in the newly

00:32:06,159 --> 00:32:14,169
edited file so we say okay go do it and

00:32:12,039 --> 00:32:15,670
we look and now we heat that the

00:32:14,169 --> 00:32:17,290
containers are being created

00:32:15,670 --> 00:32:19,440
the two new back-end services behind the

00:32:17,290 --> 00:32:21,490
load balancer so doesn't matter if

00:32:19,440 --> 00:32:22,870
basically the load balancer will not

00:32:21,490 --> 00:32:24,850
route traffic to these things until

00:32:22,870 --> 00:32:26,740
they're running so you can essentially

00:32:24,850 --> 00:32:28,600
guarantee you're not going to disrupt

00:32:26,740 --> 00:32:30,520
your servers until the container starts

00:32:28,600 --> 00:32:32,020
right now that's the caveat I know I've

00:32:30,520 --> 00:32:33,820
seen people on the internet when they

00:32:32,020 --> 00:32:35,110
make containers they'll put a whole

00:32:33,820 --> 00:32:36,370
bunch of stuff and start script so

00:32:35,110 --> 00:32:38,620
that's the basically the command where

00:32:36,370 --> 00:32:40,390
it's got a whole files and you know do a

00:32:38,620 --> 00:32:42,160
bunch of you know computation before it

00:32:40,390 --> 00:32:45,370
actually starts running the problem with

00:32:42,160 --> 00:32:47,230
that is that that delay in time right

00:32:45,370 --> 00:32:48,640
your load balance you could be sending a

00:32:47,230 --> 00:32:50,830
traffic in your services of running so

00:32:48,640 --> 00:32:52,840
you get a disruption so it's very very

00:32:50,830 --> 00:32:54,850
critical that you design your containers

00:32:52,840 --> 00:32:56,590
when they start running they are

00:32:54,850 --> 00:32:58,060
actually running and there's no special

00:32:56,590 --> 00:33:00,040
magic that you have to do ahead of time

00:32:58,060 --> 00:33:04,060
that will make the service much much

00:33:00,040 --> 00:33:05,950
more robust okay so those nice and

00:33:04,060 --> 00:33:08,200
Tennessee here we've got three instances

00:33:05,950 --> 00:33:10,810
of the back end now and we've got our

00:33:08,200 --> 00:33:12,250
updated and genetic containers and still

00:33:10,810 --> 00:33:13,570
have all of our reps replicas and you

00:33:12,250 --> 00:33:14,920
can kind of see here how many times

00:33:13,570 --> 00:33:17,860
they've been restarted so like if I lose

00:33:14,920 --> 00:33:20,260
a node then what Cooper Nettie's will do

00:33:17,860 --> 00:33:22,030
is ok restart those nodes on a new node

00:33:20,260 --> 00:33:23,260
over here so they're all behind the load

00:33:22,030 --> 00:33:26,280
balancer so really you shouldn't

00:33:23,260 --> 00:33:33,420
actually see any service disruption

00:33:26,280 --> 00:33:35,830
superbad coaster works there we go so

00:33:33,420 --> 00:33:38,050
that is all I have I know it's been

00:33:35,830 --> 00:33:39,970
taken a little short on time here so

00:33:38,050 --> 00:33:41,740
thank you for coming i hope that was

00:33:39,970 --> 00:33:43,810
somewhat interesting i tried to you know

00:33:41,740 --> 00:33:45,640
bring in some other technology rather

00:33:43,810 --> 00:33:46,750
than just all software and have a talk

00:33:45,640 --> 00:33:47,950
about this but i think it makes it more

00:33:46,750 --> 00:33:53,670
interesting and more relevant to what

00:33:47,950 --> 00:33:53,670
we're doing is there any questions good

00:33:54,520 --> 00:34:02,580
but okay

00:34:29,990 --> 00:34:37,139
sure yeah so the question was why Ron

00:34:35,190 --> 00:34:38,310
arm what advantage did we get from that

00:34:37,139 --> 00:34:40,530
and then the second part of the question

00:34:38,310 --> 00:34:42,659
is is it energy efficient is a resource

00:34:40,530 --> 00:34:47,429
efficient to process the images on the

00:34:42,659 --> 00:34:49,080
drone well i would say it's i would say

00:34:47,429 --> 00:34:51,419
it's interesting to run on home because

00:34:49,080 --> 00:34:53,370
most of the drone equipment already runs

00:34:51,419 --> 00:34:54,810
on course now there's intel-based groans

00:34:53,370 --> 00:34:56,909
there's other architectures of red IMU

00:34:54,810 --> 00:34:58,380
software but for the most part is it's

00:34:56,909 --> 00:35:01,590
like the mobile ended mobile industry

00:34:58,380 --> 00:35:03,720
most of it runs on arm so that's why I

00:35:01,590 --> 00:35:04,920
thought it was interesting so right now

00:35:03,720 --> 00:35:06,330
you can't run this stuff yet on a

00:35:04,920 --> 00:35:08,670
Raspberry Pi there's too much memory

00:35:06,330 --> 00:35:10,200
usage right i mean you need an arm

00:35:08,670 --> 00:35:12,960
platform that has at least eight gigs of

00:35:10,200 --> 00:35:14,610
memory but i think that's coming right i

00:35:12,960 --> 00:35:16,260
think we're going to see handsets in the

00:35:14,610 --> 00:35:17,220
next two years shipping what they give

00:35:16,260 --> 00:35:18,690
the memory that's the whole reason we

00:35:17,220 --> 00:35:21,030
moved to 64 bit so we can address more

00:35:18,690 --> 00:35:24,540
memory right the second part is is it

00:35:21,030 --> 00:35:28,380
resource efficient to run the processing

00:35:24,540 --> 00:35:31,110
on my drum now looks like DJI phantom 4

00:35:28,380 --> 00:35:32,430
right they're doing so the way it's

00:35:31,110 --> 00:35:34,380
follow me you certainly stepped back a

00:35:32,430 --> 00:35:36,330
little bit on drone was that you had a

00:35:34,380 --> 00:35:37,560
GPS beacon that would talk to the drone

00:35:36,330 --> 00:35:39,210
and you'd walk around with it and the

00:35:37,560 --> 00:35:41,190
drone would follow your gps because and

00:35:39,210 --> 00:35:43,500
then bj i came out with a computer

00:35:41,190 --> 00:35:46,380
vision system that runs on board to

00:35:43,500 --> 00:35:47,970
actually select an object in space make

00:35:46,380 --> 00:35:50,040
a 3d model of it was fallen around it's

00:35:47,970 --> 00:35:52,200
called active track that you may have

00:35:50,040 --> 00:35:53,940
seen so their day end up saying well

00:35:52,200 --> 00:35:56,910
it's actually better to do the

00:35:53,940 --> 00:35:58,950
processing on board and that makes the

00:35:56,910 --> 00:36:01,470
digital experience better now when

00:35:58,950 --> 00:36:04,170
you're doing jobs where you're doing

00:36:01,470 --> 00:36:05,820
your mapping cory's for customers if you

00:36:04,170 --> 00:36:06,930
have to go take your images off-site and

00:36:05,820 --> 00:36:08,100
sometimes these quarters are quite

00:36:06,930 --> 00:36:10,500
remote you have no internet connection

00:36:08,100 --> 00:36:12,150
at all to process the imagery so you

00:36:10,500 --> 00:36:14,040
could do the volumetric calculation of

00:36:12,150 --> 00:36:15,270
their piles where you have to drive away

00:36:14,040 --> 00:36:16,770
you have to upload the images to

00:36:15,270 --> 00:36:18,450
something that's bigger you know sticker

00:36:16,770 --> 00:36:20,850
server to do these computations and then

00:36:18,450 --> 00:36:22,830
get the hubs of files and send them out

00:36:20,850 --> 00:36:25,380
to customers so I would argue that's

00:36:22,830 --> 00:36:27,090
being able to when the drone lands or

00:36:25,380 --> 00:36:28,560
shortly after the drone landing if you

00:36:27,090 --> 00:36:30,119
have all the imagery that you can share

00:36:28,560 --> 00:36:32,160
directly with the customer when

00:36:30,119 --> 00:36:34,529
and that's an advantage and that's my

00:36:32,160 --> 00:36:37,619
why you why you would use Arm the other

00:36:34,529 --> 00:36:38,759
thing is just have having talked with

00:36:37,619 --> 00:36:40,380
some of the quarry owners that's

00:36:38,759 --> 00:36:41,640
advantageous to them because they can

00:36:40,380 --> 00:36:44,430
they get a phone call from a customer

00:36:41,640 --> 00:36:46,619
saying i need to do 40 tons of asphalt i

00:36:44,430 --> 00:36:48,299
need this much gravel they have to wait

00:36:46,619 --> 00:36:49,740
for the drone operator go back process

00:36:48,299 --> 00:36:50,970
the images somewhere else and call them

00:36:49,740 --> 00:36:52,499
back and saying this is how much gravel

00:36:50,970 --> 00:36:54,599
you had he can know when that drone

00:36:52,499 --> 00:36:57,450
lands after 15-20 minutes like you just

00:36:54,599 --> 00:36:58,740
saw there what the pile is that he could

00:36:57,450 --> 00:36:59,819
call that customer backing case to get

00:36:58,740 --> 00:37:01,589
that sale so it's a competitive

00:36:59,819 --> 00:37:04,529
advantage almost if you can do that now

00:37:01,589 --> 00:37:05,970
is it officious probably not going to

00:37:04,529 --> 00:37:09,180
use more battery power right and

00:37:05,970 --> 00:37:10,740
batteries are I think where drones and

00:37:09,180 --> 00:37:13,380
really the rest of the industry needs to

00:37:10,740 --> 00:37:14,609
improve I mean I think Tess was making a

00:37:13,380 --> 00:37:17,700
heavy investment in the battery

00:37:14,609 --> 00:37:19,319
technology so I'm hoping over time that

00:37:17,700 --> 00:37:21,630
becomes less of an issue but that is

00:37:19,319 --> 00:37:22,950
where it is inefficient it's going to go

00:37:21,630 --> 00:37:24,749
through battery faster but the good news

00:37:22,950 --> 00:37:25,710
is most pleased roams now can fly for 30

00:37:24,749 --> 00:37:27,359
minutes so if you're talking about

00:37:25,710 --> 00:37:29,940
mapping something that takes 12 to 15

00:37:27,359 --> 00:37:31,740
minutes in my user entire battery to do

00:37:29,940 --> 00:37:34,589
that but in the end you can get your

00:37:31,740 --> 00:37:37,230
customer that data faster so that's kind

00:37:34,589 --> 00:37:38,730
of been my reasoning I i did also work

00:37:37,230 --> 00:37:40,470
on the enterprise reference platform so

00:37:38,730 --> 00:37:41,700
that was kind of like hey you know we're

00:37:40,470 --> 00:37:43,349
certainly see hardware now that's

00:37:41,700 --> 00:37:44,970
actually really good and fast and it

00:37:43,349 --> 00:37:47,400
actually does use less power than beyond

00:37:44,970 --> 00:37:49,079
and it's not that much slower so that's

00:37:47,400 --> 00:37:50,789
kind of why the geospatial engineers

00:37:49,079 --> 00:37:52,079
that could actually work on this project

00:37:50,789 --> 00:37:53,640
and I've been talking with them are

00:37:52,079 --> 00:37:55,019
excited about it because now there's

00:37:53,640 --> 00:37:57,839
another competitor in the market that

00:37:55,019 --> 00:37:59,130
you know it's lying around natively that

00:37:57,839 --> 00:38:01,259
that process applies in their droves

00:37:59,130 --> 00:38:02,430
they use today and that they can kind of

00:38:01,259 --> 00:38:03,960
see the future so it's nothing that's

00:38:02,430 --> 00:38:06,059
going to probably be used today but

00:38:03,960 --> 00:38:08,460
maybe five years from now it's something

00:38:06,059 --> 00:38:11,029
that's an interesting technology any

00:38:08,460 --> 00:38:11,029
other questions

00:38:14,510 --> 00:38:21,780
okay good question so everywhere in that

00:38:19,110 --> 00:38:23,580
code is you know SS the instruction sets

00:38:21,780 --> 00:38:25,260
by default right that's been the biggest

00:38:23,580 --> 00:38:26,730
same as a porting their stuff is that

00:38:25,260 --> 00:38:29,280
just you know getting it's compiling

00:38:26,730 --> 00:38:30,330
right with the right instruction set no

00:38:29,280 --> 00:38:31,890
one really when they were building those

00:38:30,330 --> 00:38:33,180
projects had thought about maybe other

00:38:31,890 --> 00:38:36,300
architectures want to build this so

00:38:33,180 --> 00:38:37,740
that's been a pain pointer size and

00:38:36,300 --> 00:38:39,390
things like that that's been a little

00:38:37,740 --> 00:38:40,530
bit of an issue but not too bad i mean

00:38:39,390 --> 00:38:43,760
there's only two projects that need to

00:38:40,530 --> 00:38:46,890
be fixed up you know in regards to that

00:38:43,760 --> 00:38:49,950
and most of it was stuff and they just

00:38:46,890 --> 00:38:51,300
work it was really nice being able to

00:38:49,950 --> 00:38:53,430
use so i think mostly containers are

00:38:51,300 --> 00:38:54,810
built on debian Jessie and just being

00:38:53,430 --> 00:38:56,160
able to enable backwards to get some of

00:38:54,810 --> 00:38:57,570
the newer software versions that they

00:38:56,160 --> 00:38:59,670
required in there was like really

00:38:57,570 --> 00:39:01,380
helpful so I mean a lot of this was

00:38:59,670 --> 00:39:03,030
standing on you know people that work on

00:39:01,380 --> 00:39:05,490
debian really that they had done a lot

00:39:03,030 --> 00:39:06,810
of work on arm 64 and so kind of proves

00:39:05,490 --> 00:39:11,580
that you know we're getting closer to

00:39:06,810 --> 00:39:19,350
x86 as far as package parody goes what's

00:39:11,580 --> 00:39:20,790
that that's correct yeah no that was we

00:39:19,350 --> 00:39:21,960
right i mean i was surprised i actually

00:39:20,790 --> 00:39:23,700
thought i was going to run into that

00:39:21,960 --> 00:39:26,750
right but it didn't in the popping it

00:39:23,700 --> 00:39:26,750
works great yes

00:39:31,100 --> 00:39:36,900
so not not one building the software no

00:39:34,050 --> 00:39:39,540
but I I do have an issue to sort out I

00:39:36,900 --> 00:39:40,860
can actually probably show you since we

00:39:39,540 --> 00:39:42,330
have a little time let's show you I've

00:39:40,860 --> 00:39:44,310
got another issue essentially where I

00:39:42,330 --> 00:39:47,550
think there's some memory memory

00:39:44,310 --> 00:39:48,960
corruption is happening and when so I

00:39:47,550 --> 00:39:50,190
didn't show you the 2d or the mosaics

00:39:48,960 --> 00:39:51,810
being overlaid on google maps because

00:39:50,190 --> 00:39:54,180
that's actually broken on arm at the

00:39:51,810 --> 00:39:57,270
moment and it's essentially spitting out

00:39:54,180 --> 00:39:59,490
that the the hex characters

00:39:57,270 --> 00:40:01,710
unrecognizable it's getting in a nod nod

00:39:59,490 --> 00:40:02,640
next character in in the buffer and it's

00:40:01,710 --> 00:40:05,280
complaining about it it's actually

00:40:02,640 --> 00:40:06,870
crashing so looks sure you guys how to

00:40:05,280 --> 00:40:10,260
introspect these containerships i think

00:40:06,870 --> 00:40:13,700
that's kind of interesting you put those

00:40:10,260 --> 00:40:13,700
down one second

00:40:35,810 --> 00:40:41,180
so let's get our paws and let's connect

00:40:38,030 --> 00:40:43,430
to one of the backend instances so

00:40:41,180 --> 00:40:45,380
doctor has this whole idea to of

00:40:43,430 --> 00:40:48,880
basically tailing the logs coming from

00:40:45,380 --> 00:40:48,880
the container which is super helpful

00:40:51,010 --> 00:40:55,970
because i have three back-end instance

00:40:53,300 --> 00:40:57,470
design actually need to monitor all

00:40:55,970 --> 00:40:59,240
three of them because when the crash

00:40:57,470 --> 00:41:01,730
happened the load balancer is going to

00:40:59,240 --> 00:41:03,260
hand the request off to the the right

00:41:01,730 --> 00:41:05,300
back end or the back end it chooses so

00:41:03,260 --> 00:41:18,500
we have to have both open actually all

00:41:05,300 --> 00:41:21,190
three open to actually see the error the

00:41:18,500 --> 00:41:21,190
other back end

00:41:40,490 --> 00:41:45,200
sorry I'm doing ssh tunneling here

00:41:50,599 --> 00:42:02,599
let's keep the last one okay so that's

00:42:00,769 --> 00:42:10,489
that's all over here so if we go and we

00:42:02,599 --> 00:42:14,059
open up a map of this bang that's where

00:42:10,489 --> 00:42:16,099
it usually happens yeah so so this one

00:42:14,059 --> 00:42:17,390
down here was the one that actually has

00:42:16,099 --> 00:42:19,549
intercepted that request from the load

00:42:17,390 --> 00:42:20,900
balancer and yet we have an invalid hex

00:42:19,549 --> 00:42:22,519
character so there's a back trace here

00:42:20,900 --> 00:42:25,640
and I have a feeling it's due to memory

00:42:22,519 --> 00:42:28,460
corruption it's actually using a uses

00:42:25,640 --> 00:42:30,799
the postgres post gif extension for

00:42:28,460 --> 00:42:32,869
postgres for the geospatial information

00:42:30,799 --> 00:42:35,599
and what's being handed down from the

00:42:32,869 --> 00:42:36,619
back end i think is corrupted corrupted

00:42:35,599 --> 00:42:38,450
characters that it's getting out of

00:42:36,619 --> 00:42:39,769
memory so that's one issue that is still

00:42:38,450 --> 00:42:41,269
pending that I need to sort out but yeah

00:42:39,769 --> 00:42:42,979
I do suspect that there's and

00:42:41,269 --> 00:42:44,239
potentially memory ordering issues or

00:42:42,979 --> 00:42:47,239
even memory corruption that's happening

00:42:44,239 --> 00:42:50,059
on fun arms it's sorted out just so you

00:42:47,239 --> 00:42:51,470
guys can see well you can kind of see

00:42:50,059 --> 00:42:53,630
this here I look so maybe some of you

00:42:51,470 --> 00:42:55,640
guys are actually on this website right

00:42:53,630 --> 00:42:57,499
now and looking at it this is a a live

00:42:55,640 --> 00:42:58,999
URL but if you go to my processing nodes

00:42:57,499 --> 00:43:02,029
and you click around here a little bit

00:42:58,999 --> 00:43:03,469
you can actually see that the different

00:43:02,029 --> 00:43:05,989
web works plus you're getting routed to

00:43:03,469 --> 00:43:10,369
the different backends and so we do a

00:43:05,989 --> 00:43:13,069
few more here look at the administration

00:43:10,369 --> 00:43:19,190
back and you go here and back to our

00:43:13,069 --> 00:43:21,140
dashboard once that loads we look at

00:43:19,190 --> 00:43:22,700
that again you could see that it's

00:43:21,140 --> 00:43:24,109
spreading it around you know the load

00:43:22,700 --> 00:43:25,309
balancer spreading those requests back

00:43:24,109 --> 00:43:26,779
and forth there's a different back-end

00:43:25,309 --> 00:43:28,430
and the same goes with the front end the

00:43:26,779 --> 00:43:30,890
front end load balancers doing the same

00:43:28,430 --> 00:43:33,079
thing with in genetics and the same kind

00:43:30,890 --> 00:43:35,119
of thing is happening with kind of

00:43:33,079 --> 00:43:37,279
beneath peachy pool as PG pool is asking

00:43:35,119 --> 00:43:41,769
for the master and replica data sets and

00:43:37,279 --> 00:43:41,769
making queries on it so yeah

00:43:52,920 --> 00:44:00,940
so I've got a graphic for you here so

00:43:59,080 --> 00:44:03,160
there's some things as warm as it to

00:44:00,940 --> 00:44:06,640
benetti's doesn't right I look at the

00:44:03,160 --> 00:44:09,400
dynamic dns service being huge right so

00:44:06,640 --> 00:44:11,350
it uses kind of like a sky dns container

00:44:09,400 --> 00:44:13,450
placement management system and the load

00:44:11,350 --> 00:44:15,850
balancers you'll get that from dr. swarm

00:44:13,450 --> 00:44:17,320
and building a scalable web service if

00:44:15,850 --> 00:44:19,630
you have to go below balancer yourself

00:44:17,320 --> 00:44:21,130
you know you can do it it's well known

00:44:19,630 --> 00:44:22,450
but that's just something extra that you

00:44:21,130 --> 00:44:25,540
have to do you get it for free in cooper

00:44:22,450 --> 00:44:28,119
Nettie's authentication providers ACL

00:44:25,540 --> 00:44:30,369
management but if you care about having

00:44:28,119 --> 00:44:31,840
multi-network per container you need to

00:44:30,369 --> 00:44:33,550
use swarm if you care about using ipv6

00:44:31,840 --> 00:44:35,470
inside your containers you need to use

00:44:33,550 --> 00:44:37,119
swarm now because actually this isn't

00:44:35,470 --> 00:44:40,270
listed on here but Hoover natives

00:44:37,119 --> 00:44:41,320
doesn't support containers with ipv6 so

00:44:40,270 --> 00:44:43,240
that's something that I've asked them

00:44:41,320 --> 00:44:45,460
for because I'm generally interested in

00:44:43,240 --> 00:44:47,350
the Internet of Things talking to the

00:44:45,460 --> 00:44:49,270
cloud and you know if you're talking

00:44:47,350 --> 00:44:50,980
about 6 billion devices right we're

00:44:49,270 --> 00:44:52,750
going to run an ipv4 Singh main staging

00:44:50,980 --> 00:44:54,730
very quickly and it's just not going to

00:44:52,750 --> 00:44:57,070
work so the cloud meets the natively

00:44:54,730 --> 00:44:58,000
talk I'd be t6 and that's where I see

00:44:57,070 --> 00:45:00,820
coover now he's lacking at the moment

00:44:58,000 --> 00:45:02,170
and essentially the what the crew

00:45:00,820 --> 00:45:04,840
bonetti scheme has said is a few of a

00:45:02,170 --> 00:45:07,060
bare-metal cluster like this is and you

00:45:04,840 --> 00:45:08,740
get ipv6 support working will take the

00:45:07,060 --> 00:45:11,500
patches but the problem is no cloud

00:45:08,740 --> 00:45:14,710
supporter cloud service at the moment

00:45:11,500 --> 00:45:16,600
supports ipv6 natively so they're kind

00:45:14,710 --> 00:45:18,520
of uninterested until somebody has an

00:45:16,600 --> 00:45:20,080
offering so I think it'll work will be

00:45:18,520 --> 00:45:22,390
on us to get that working on a bare

00:45:20,080 --> 00:45:24,580
metal cluster and then once the big

00:45:22,390 --> 00:45:26,500
company decides it it's time to stop

00:45:24,580 --> 00:45:29,190
ignoring ipv6 and they'll uh they'll

00:45:26,500 --> 00:45:29,190
have something to work with

00:45:38,950 --> 00:45:45,710
no we have shortcomings Padma works

00:45:42,609 --> 00:45:48,410
what's that okay so the question was

00:45:45,710 --> 00:45:51,310
with with context or with respect to

00:45:48,410 --> 00:45:54,470
Coober Nettie's and running on an arm

00:45:51,310 --> 00:45:56,450
versus maybe running on the x86

00:45:54,470 --> 00:45:58,849
architecture are we at parity and the

00:45:56,450 --> 00:46:01,220
answer is no so we can install Cooper

00:45:58,849 --> 00:46:03,770
Nettie's and we have one pod network to

00:46:01,220 --> 00:46:05,510
choose from which is we've because i use

00:46:03,770 --> 00:46:06,500
weave on x86 when i was setting up their

00:46:05,510 --> 00:46:09,890
mother cluster it seemed to work well

00:46:06,500 --> 00:46:12,980
but there if you go here actually you

00:46:09,890 --> 00:46:21,200
can see all the ones they offer and to

00:46:12,980 --> 00:46:26,270
my knowledge in a second yeah the ad on

00:46:21,200 --> 00:46:28,400
page here so all these things here work

00:46:26,270 --> 00:46:30,050
on Cooper Nettie's they offer different

00:46:28,400 --> 00:46:31,700
things there's different advantages

00:46:30,050 --> 00:46:33,829
there's different use cases that they

00:46:31,700 --> 00:46:36,050
fulfill and we've met the only one that

00:46:33,829 --> 00:46:37,400
works on arm 64 and I pretty sure none

00:46:36,050 --> 00:46:39,410
of them anybody else has been crazy

00:46:37,400 --> 00:46:41,270
enough to try them on arm just because

00:46:39,410 --> 00:46:43,190
they probably don't have the hardware

00:46:41,270 --> 00:46:44,450
right that could run Cooper Nettie's and

00:46:43,190 --> 00:46:45,770
do a good job but we're getting there I

00:46:44,450 --> 00:46:48,619
think we're getting closer to having

00:46:45,770 --> 00:46:51,220
something very compelling so I would say

00:46:48,619 --> 00:46:53,599
pod networking is where we're lacking

00:46:51,220 --> 00:46:55,099
everything else is pretty much on par

00:46:53,599 --> 00:46:56,390
but this is a big part of why you choose

00:46:55,099 --> 00:46:59,470
Cooper that is because you have all of

00:46:56,390 --> 00:46:59,470
these different options oh

00:47:12,160 --> 00:47:18,010
yeah I did actually in fact I had to

00:47:14,710 --> 00:47:19,270
they remove GCC intrinsic and just put

00:47:18,010 --> 00:47:21,280
it this hard coded everything right

00:47:19,270 --> 00:47:22,780
which I basically backed out a lot of

00:47:21,280 --> 00:47:26,020
the stuff uses fee make I don't know if

00:47:22,780 --> 00:47:27,609
you see make much but it's got a done

00:47:26,020 --> 00:47:29,589
way of detecting architectures which I

00:47:27,609 --> 00:47:31,539
don't think is very clean so I end up

00:47:29,589 --> 00:47:35,049
you know it's like this massive list of

00:47:31,539 --> 00:47:36,760
like is this amd64 I 386 you know it's

00:47:35,049 --> 00:47:39,160
like this huge list of basically am i

00:47:36,760 --> 00:47:41,500
running on x86 if I'm not then you know

00:47:39,160 --> 00:47:43,630
don't use that sassy to write those kind

00:47:41,500 --> 00:47:45,849
of thing so yeah some projects I did it

00:47:43,630 --> 00:47:47,579
uses see in physics on other projects

00:47:45,849 --> 00:47:49,839
like seemed a good stuff was just using

00:47:47,579 --> 00:47:54,960
their architecture detection and that

00:47:49,839 --> 00:47:57,069
they use the right flags from there no

00:47:54,960 --> 00:47:58,869
but you know once you get these things

00:47:57,069 --> 00:48:00,400
working you know it's fairly smooth it

00:47:58,869 --> 00:48:02,109
worked just like a grant it worked on

00:48:00,400 --> 00:48:03,520
x86 as far as them from cooper dead he

00:48:02,109 --> 00:48:05,789
stands line which I was really happy to

00:48:03,520 --> 00:48:07,869
see I'm glad I didn't you know find that

00:48:05,789 --> 00:48:09,190
you know something something nasty

00:48:07,869 --> 00:48:11,770
happens the interesting part though

00:48:09,190 --> 00:48:13,510
we've net uses IPC six to talk between

00:48:11,770 --> 00:48:16,900
containers so if you've got a broken

00:48:13,510 --> 00:48:19,150
ipv6 on your platform and you know about

00:48:16,900 --> 00:48:20,740
it it's not going to work I hope name

00:48:19,150 --> 00:48:22,180
any names but there are platforms out

00:48:20,740 --> 00:48:24,789
there that are I'm 64 that do not work

00:48:22,180 --> 00:48:26,349
properly with ipv6 and I can't run we've

00:48:24,789 --> 00:48:28,059
met on them so that's kind of why I had

00:48:26,349 --> 00:48:29,859
to have the club food that I did instead

00:48:28,059 --> 00:48:31,660
of running you know a whole bunch of

00:48:29,859 --> 00:48:33,490
different vendors arm 64 servers in

00:48:31,660 --> 00:48:35,200
there because there was no can I tv6

00:48:33,490 --> 00:48:36,520
support essentially what was happening

00:48:35,200 --> 00:48:39,069
it I don't know how how this is

00:48:36,520 --> 00:48:41,410
happening but we have duplicate ipv6

00:48:39,069 --> 00:48:42,549
addresses happening I have a feeling

00:48:41,410 --> 00:48:46,510
it's to do with duplicate MAC addresses

00:48:42,549 --> 00:48:51,670
so that's just my hunch so any other

00:48:46,510 --> 00:48:53,230
questions we do not do a performance

00:48:51,670 --> 00:48:55,900
benchmarking here at menara with our

00:48:53,230 --> 00:48:57,819
member platforms but you know it's all

00:48:55,900 --> 00:48:59,470
open source you've got a platform you

00:48:57,819 --> 00:49:01,599
want to see how it performs I've done my

00:48:59,470 --> 00:49:03,400
own research I don't want to present it

00:49:01,599 --> 00:49:05,349
as a house like it's fair to anybody to

00:49:03,400 --> 00:49:07,240
see but there's power savings running on

00:49:05,349 --> 00:49:08,410
arm 64 / z on especially when you run

00:49:07,240 --> 00:49:10,510
the same workload that that's why I like

00:49:08,410 --> 00:49:12,670
this project so much I can take the same

00:49:10,510 --> 00:49:14,710
dataset push it onto my Z on servers

00:49:12,670 --> 00:49:16,839
using the same KU vanetti set up the

00:49:14,710 --> 00:49:18,849
same containers right obviously both

00:49:16,839 --> 00:49:20,289
their different architectures and have

00:49:18,849 --> 00:49:23,500
an apples-to-apples comparison of the

00:49:20,289 --> 00:49:24,849
workload and I have basically current

00:49:23,500 --> 00:49:25,920
until a lot our monitors on either

00:49:24,849 --> 00:49:28,890
server and I

00:49:25,920 --> 00:49:30,089
tell you know how much power saving it

00:49:28,890 --> 00:49:32,549
is and then basically have a power

00:49:30,089 --> 00:49:34,859
savings time trade-off and kind of just

00:49:32,549 --> 00:49:36,690
understand where where that is but I

00:49:34,859 --> 00:49:38,790
will say it's looking really good for

00:49:36,690 --> 00:49:41,250
arm 6 p-4 right now we're not beating

00:49:38,790 --> 00:49:43,440
the you know incumbent architecture at

00:49:41,250 --> 00:49:47,420
this point but we're doing a lot better

00:49:43,440 --> 00:49:47,420
than we were maybe two years ago okay

00:49:50,000 --> 00:49:54,930
yeah I don't want to divulge any I'm

00:49:53,250 --> 00:50:00,150
kind of shielding what hardware i'm

00:49:54,930 --> 00:50:01,589
using stuff but just for my personal we

00:50:00,150 --> 00:50:03,960
on just don't take this it you know this

00:50:01,589 --> 00:50:06,809
is nothing professional here as far as

00:50:03,960 --> 00:50:10,549
it's not very scientific but the arm

00:50:06,809 --> 00:50:13,470
servers themselves have a higher idol

00:50:10,549 --> 00:50:15,780
current poll from the x86 servers do

00:50:13,470 --> 00:50:17,010
that could be due to they know somebody

00:50:15,780 --> 00:50:18,480
just said we're gonna turn the fans on

00:50:17,010 --> 00:50:21,450
to a hundred percent in this this rig

00:50:18,480 --> 00:50:23,130
and let them run and that's why beating

00:50:21,450 --> 00:50:24,720
of all the powers not necessarily a cpu

00:50:23,130 --> 00:50:28,049
needing that much power however when the

00:50:24,720 --> 00:50:30,299
workload starts it's a fraction of the

00:50:28,049 --> 00:50:33,089
current consumption of x86 when the same

00:50:30,299 --> 00:50:34,319
workloads running so it's kind of a

00:50:33,089 --> 00:50:36,089
weird conclusion to come with is that

00:50:34,319 --> 00:50:37,799
arm 64 servers at idle are using more

00:50:36,089 --> 00:50:39,420
power but when they're under load use

00:50:37,799 --> 00:50:43,020
far less i mean we're talking to ants

00:50:39,420 --> 00:50:45,630
lots power then they're at kt6 to z on

00:50:43,020 --> 00:50:47,220
servers that I've used so and you're

00:50:45,630 --> 00:50:56,250
talking about a 15 minute difference on

00:50:47,220 --> 00:50:59,010
a data set what's that yeah it's the

00:50:56,250 --> 00:51:00,780
same data set running on arm 64 versus

00:50:59,010 --> 00:51:12,740
be honest 15 minutes slower running on

00:51:00,780 --> 00:51:12,740
on 64 yeah total da da hey no 15 minutes

00:51:13,430 --> 00:51:20,460
ok so you want context so so on an hour

00:51:17,460 --> 00:51:24,930
so say say so it's a takes an hour on

00:51:20,460 --> 00:51:26,550
arm 64 it takes 45 minutes on beyond ok

00:51:24,930 --> 00:51:28,440
I just don't want to get you know I

00:51:26,550 --> 00:51:30,390
don't want to thank ya you know this

00:51:28,440 --> 00:51:32,490
much better and somebody wrote an

00:51:30,390 --> 00:51:33,870
article and it's you know could be

00:51:32,490 --> 00:51:35,010
misleading depending on the hardware so

00:51:33,870 --> 00:51:37,830
I don't want to go down that road but

00:51:35,010 --> 00:51:39,330
that gives you a basic idea so it's not

00:51:37,830 --> 00:51:42,080
that I'm acting wait 15 extra minutes

00:51:39,330 --> 00:51:44,100
and save some power I think that's

00:51:42,080 --> 00:51:47,840
pretty exciting and we should all be

00:51:44,100 --> 00:51:51,020
kind of excited about that any questions

00:51:47,840 --> 00:51:51,020
thank you

00:51:52,770 --> 00:51:57,739

YouTube URL: https://www.youtube.com/watch?v=xmKn-bf8aa8


