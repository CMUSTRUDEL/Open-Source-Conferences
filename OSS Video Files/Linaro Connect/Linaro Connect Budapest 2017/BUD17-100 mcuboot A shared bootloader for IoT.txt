Title: BUD17-100 mcuboot A shared bootloader for IoT
Publication date: 2017-03-11
Playlist: Linaro Connect Budapest 2017
Description: 
	"Session ID: BUD17-100
Session Name: mcuboot: A shared bootloader for IoT - BUD17-100
Speaker: David Brown
Track: LITE


★ Session Summary ★
An important base for security is the beginning of the boot process. It is necessary to be able to verify signatures before upgrading images. This session will discuss the mcuboot project, the efforts to port this to Zephyr, and the functionality available. It will include a small demo of its functionality.
---------------------------------------------------
★ Resources ★
Event Page: http://connect.linaro.org/resource/bud17/bud17-100/
Presentation: https://www.slideshare.net/linaroorg/bud17100-mcuboot-a-shared-bootloader-for-zephyr
Video: https://youtu.be/tv502SMhwYE
 ---------------------------------------------------

★ Event Details ★
Linaro Connect Budapest 2017 (BUD17)
6-10 March 2017
Corinthia Hotel, Budapest,
Erzsébet krt. 43-49,
1073 Hungary

---------------------------------------------------
Keyword: mcuboot, IoT, Zephyr, LITE, bootloader, David Brown
http://www.linaro.org
http://connect.linaro.org
---------------------------------------------------
Follow us on Social Media
https://www.facebook.com/LinaroOrg
https://twitter.com/linaroorg
https://www.youtube.com/user/linaroorg?sub_confirmation=1
https://www.linkedin.com/company/1026961"
Captions: 
	00:00:00,290 --> 00:00:09,450
[Music]

00:00:10,190 --> 00:00:18,720
hello everyone I don't know I don't

00:00:16,049 --> 00:00:21,119
think this does anything but it is

00:00:18,720 --> 00:00:24,119
working okay excellent so my name is

00:00:21,119 --> 00:00:27,720
David Brown and I'm going to talk a

00:00:24,119 --> 00:00:30,330
little bit about MCU booth today this is

00:00:27,720 --> 00:00:33,090
the bootloader for IOT I hope I have the

00:00:30,330 --> 00:00:35,360
right room think I see the people that

00:00:33,090 --> 00:00:37,680
were expecting to come expecting today

00:00:35,360 --> 00:00:40,200
so I just want to give a little

00:00:37,680 --> 00:00:41,579
background talk about some of the

00:00:40,200 --> 00:00:44,879
earlier work that was done in this

00:00:41,579 --> 00:00:46,920
respect what I did for the Zeph report

00:00:44,879 --> 00:00:50,930
get into a little bit of details about

00:00:46,920 --> 00:00:53,940
the specifics of the mg bootloader and

00:00:50,930 --> 00:00:57,270
go from there maybe you leave some time

00:00:53,940 --> 00:01:01,350
for questions and answers as far as

00:00:57,270 --> 00:01:04,850
background we hear the term IOT a lot I

00:01:01,350 --> 00:01:07,110
do run into different definitions for it

00:01:04,850 --> 00:01:09,720
you know people say oh Raspberry Pi

00:01:07,110 --> 00:01:11,909
that's IOT and that's not really what

00:01:09,720 --> 00:01:14,000
I'm thinking here at least for the topic

00:01:11,909 --> 00:01:16,250
of this talk we're talking about

00:01:14,000 --> 00:01:18,270
microcontrollers very small low-cost

00:01:16,250 --> 00:01:21,860
things that run it like a hundred

00:01:18,270 --> 00:01:25,350
megahertz have maybe a half Omega slash

00:01:21,860 --> 00:01:27,650
quarter Meg of RAM let me typically run

00:01:25,350 --> 00:01:32,820
some kind of custom operating system

00:01:27,650 --> 00:01:35,009
Zephyr minut any of the other hundred

00:01:32,820 --> 00:01:38,340
some of these little custom operating

00:01:35,009 --> 00:01:42,240
systems and the problem we're trying to

00:01:38,340 --> 00:01:44,399
address here has to do with security and

00:01:42,240 --> 00:01:46,020
filled upgradeability and if you saw the

00:01:44,399 --> 00:01:49,290
keynote this morning these were some of

00:01:46,020 --> 00:01:52,890
the key topics and it's going to go into

00:01:49,290 --> 00:01:55,409
how how are we addressing these problems

00:01:52,890 --> 00:01:58,020
for this environment what are some of

00:01:55,409 --> 00:02:00,930
the unique problems that happen because

00:01:58,020 --> 00:02:03,689
of the half a megabyte of flash and

00:02:00,930 --> 00:02:08,250
quarter megabytes of RAM and that's it

00:02:03,689 --> 00:02:11,489
for storage so what we started with

00:02:08,250 --> 00:02:13,410
there's a one of these a hundred or so

00:02:11,489 --> 00:02:16,320
embedded operating systems

00:02:13,410 --> 00:02:19,800
called minut and they have the

00:02:16,320 --> 00:02:22,860
bootloader they wrote you went to the

00:02:19,800 --> 00:02:24,600
last connect there was a demo of the

00:02:22,860 --> 00:02:26,940
upgrade process and it was actually done

00:02:24,600 --> 00:02:31,890
with the my new bootloader booting into

00:02:26,940 --> 00:02:34,680
Zephyr and this solves a big part of the

00:02:31,890 --> 00:02:38,790
upgrade problem namely we have an image

00:02:34,680 --> 00:02:41,100
and we want to reliably put it into

00:02:38,790 --> 00:02:42,960
flash this power fails while that's

00:02:41,100 --> 00:02:47,910
happening we can continue where we left

00:02:42,960 --> 00:02:50,340
off it also solves the problem of what

00:02:47,910 --> 00:02:52,770
if that image didn't work can we go back

00:02:50,340 --> 00:02:54,570
to the previous one and we'll get into

00:02:52,770 --> 00:03:00,410
some more details as to how that works

00:02:54,570 --> 00:03:04,290
in a minute so since the last connect

00:03:00,410 --> 00:03:08,100
I've done a port of this my new

00:03:04,290 --> 00:03:10,020
bootloader to Zephyr which is the the

00:03:08,100 --> 00:03:13,700
runtime operating system that the light

00:03:10,020 --> 00:03:16,830
group is kind of focusing on here and

00:03:13,700 --> 00:03:19,020
this isn't as hard as it might sound

00:03:16,830 --> 00:03:21,120
like it is the bootloader really doesn't

00:03:19,020 --> 00:03:23,760
use a lot of features of an operating

00:03:21,120 --> 00:03:26,459
system is one thread there's no

00:03:23,760 --> 00:03:29,190
messaging scheduling doesn't get any

00:03:26,459 --> 00:03:32,250
interrupts it basically needs a flash

00:03:29,190 --> 00:03:33,959
driver and some basic crypto services

00:03:32,250 --> 00:03:36,780
the crypto services are for verifying

00:03:33,959 --> 00:03:39,350
the signature we currently support

00:03:36,780 --> 00:03:47,010
either an RSA signature if these are all

00:03:39,350 --> 00:03:50,820
sha-256 RSA 2048 or it's an ecdsa with

00:03:47,010 --> 00:03:52,650
one of two curves and for those with

00:03:50,820 --> 00:03:54,360
some background in that they're both

00:03:52,650 --> 00:03:58,260
curves that are kind of considered week

00:03:54,360 --> 00:04:02,489
so there's future effort to bring in

00:03:58,260 --> 00:04:04,470
better curves for that so there were

00:04:02,489 --> 00:04:06,600
some minor changes to the Zephyr project

00:04:04,470 --> 00:04:08,880
needed for this closely having to do

00:04:06,600 --> 00:04:10,350
with the image header that the

00:04:08,880 --> 00:04:12,900
bootloader expects at the beginning of

00:04:10,350 --> 00:04:18,060
the image and that that's been merged

00:04:12,900 --> 00:04:20,340
and as a kind of plug that the demo

00:04:18,060 --> 00:04:22,410
friday will actually have this running

00:04:20,340 --> 00:04:26,130
on hardware showing all the different

00:04:22,410 --> 00:04:28,410
combinations of booting upgrading

00:04:26,130 --> 00:04:34,410
messing up images and show that it won't

00:04:28,410 --> 00:04:37,680
upgrade them that kind of thing so we're

00:04:34,410 --> 00:04:40,410
working with the minut the developers

00:04:37,680 --> 00:04:43,140
behind the my new team and the Zephyr

00:04:40,410 --> 00:04:46,110
project we agreed to make the bootloader

00:04:43,140 --> 00:04:48,210
itself its own project and that's where

00:04:46,110 --> 00:04:50,790
the name MCU boot came from because when

00:04:48,210 --> 00:04:53,940
you push code to github you have to call

00:04:50,790 --> 00:04:55,650
it something so that's the name we came

00:04:53,940 --> 00:04:59,730
up with I guess it's as good as any

00:04:55,650 --> 00:05:03,000
other and so it lives at that URL

00:04:59,730 --> 00:05:06,360
runtime co are kind of the primary

00:05:03,000 --> 00:05:10,050
developers behind the Apache my new

00:05:06,360 --> 00:05:13,890
project their runtime co is their

00:05:10,050 --> 00:05:17,100
community open source project and this

00:05:13,890 --> 00:05:19,590
is where this currently lives and as it

00:05:17,100 --> 00:05:22,470
stands right now the code can build for

00:05:19,590 --> 00:05:24,270
either minut or zephyr there is some

00:05:22,470 --> 00:05:25,590
interest from other a couple of their

00:05:24,270 --> 00:05:30,840
real-time operating systems to be able

00:05:25,590 --> 00:05:32,700
to use it as well and it will do pretty

00:05:30,840 --> 00:05:34,590
much anything that has this required

00:05:32,700 --> 00:05:42,350
header at the beginning of it which will

00:05:34,590 --> 00:05:44,820
go into in a minute the exam yes sorry

00:05:42,350 --> 00:05:48,120
the main challenge is to building this

00:05:44,820 --> 00:05:50,850
we're just the build environments behind

00:05:48,120 --> 00:05:53,880
minut and Zephyr are very different or

00:05:50,850 --> 00:05:57,510
yeah behind my Newton Zephyr minut uses

00:05:53,880 --> 00:06:00,270
its own tool called Newt it doesn't use

00:05:57,510 --> 00:06:01,940
make files there's yamel files that you

00:06:00,270 --> 00:06:04,110
sprinkle through the directories and it

00:06:01,940 --> 00:06:06,030
assembled that and it does all of make

00:06:04,110 --> 00:06:08,700
wear a zephyr is built more like the

00:06:06,030 --> 00:06:13,020
Linux kernel with K config files make

00:06:08,700 --> 00:06:15,030
files and some custom scripts so though

00:06:13,020 --> 00:06:17,370
it was a bit of an interesting challenge

00:06:15,030 --> 00:06:19,680
to get this to build in either of these

00:06:17,370 --> 00:06:22,800
environments be the end result is

00:06:19,680 --> 00:06:24,720
there's the ammo files in the tree that

00:06:22,800 --> 00:06:26,910
it can be pulled into a workspace and

00:06:24,720 --> 00:06:28,410
built as a my new project or if you have

00:06:26,910 --> 00:06:30,420
your environments that correctly you go

00:06:28,410 --> 00:06:34,350
in there and type make and it builds a

00:06:30,420 --> 00:06:36,210
builder for Zephyr well let me clarify

00:06:34,350 --> 00:06:39,570
that a little bit it builds a bootloader

00:06:36,210 --> 00:06:39,960
using Zephyr as the hardware support

00:06:39,570 --> 00:06:42,960
package

00:06:39,960 --> 00:06:45,930
the resulting bootloader will run an

00:06:42,960 --> 00:06:48,180
image built with any OS you want as long

00:06:45,930 --> 00:06:49,229
as it has that image header on it so

00:06:48,180 --> 00:06:51,509
it's one of the things I'm going to do

00:06:49,229 --> 00:06:54,030
with the demo is build the bootloader

00:06:51,509 --> 00:06:56,069
with minut and run a zephyr application

00:06:54,030 --> 00:06:58,740
and vice versa either all of the

00:06:56,069 --> 00:07:01,080
combinations work there's no knowledge

00:06:58,740 --> 00:07:04,500
of the OS for the bootloader that's

00:07:01,080 --> 00:07:08,310
running as far as a little bit of

00:07:04,500 --> 00:07:10,680
details we don't have a file system

00:07:08,310 --> 00:07:13,530
available the flash device is typically

00:07:10,680 --> 00:07:18,270
on the order of half a megabyte to a

00:07:13,530 --> 00:07:20,810
megabyte and so what we do is we divide

00:07:18,270 --> 00:07:24,300
the flash into these four regions or

00:07:20,810 --> 00:07:25,650
slots as they call them and the

00:07:24,300 --> 00:07:28,770
bootloader lives at the beginning and

00:07:25,650 --> 00:07:31,259
ideally that can be right protected so

00:07:28,770 --> 00:07:32,970
that you write the bootloader you put it

00:07:31,259 --> 00:07:34,949
there and then you mark it so that it

00:07:32,970 --> 00:07:38,280
can't you fuse it away so that it can't

00:07:34,949 --> 00:07:40,919
be changed and that's the first step of

00:07:38,280 --> 00:07:43,229
security is this boot loader that's

00:07:40,919 --> 00:07:46,320
going to verify the images there's two

00:07:43,229 --> 00:07:48,180
slot slot 0 is where the code lives you

00:07:46,320 --> 00:07:52,380
link your application of that address

00:07:48,180 --> 00:07:55,169
and it runs there and then slot 1 is

00:07:52,380 --> 00:07:57,990
where you place an upgrade when you want

00:07:55,169 --> 00:08:00,750
to move to the next image and so that

00:07:57,990 --> 00:08:03,539
image is linked to run in slot 0 but you

00:08:00,750 --> 00:08:06,870
write it in the second slot for the

00:08:03,539 --> 00:08:08,669
upgrade and then when the bootloader

00:08:06,870 --> 00:08:12,210
detects that an upgrade is needed it

00:08:08,669 --> 00:08:15,090
swaps the two images using this other

00:08:12,210 --> 00:08:17,099
partition called scratch and that's

00:08:15,090 --> 00:08:19,020
actually the complexity of it there's a

00:08:17,099 --> 00:08:22,199
trailer that lives at the end of the

00:08:19,020 --> 00:08:25,349
image that keeps track of all of the

00:08:22,199 --> 00:08:26,909
states the upgrade is in and I was

00:08:25,349 --> 00:08:28,949
simulating this and there's from a

00:08:26,909 --> 00:08:31,380
typical flash device about seven hundred

00:08:28,949 --> 00:08:34,320
steps that it goes through in the

00:08:31,380 --> 00:08:36,149
process of upgrading it and I use long

00:08:34,320 --> 00:08:39,240
jump and jump out of that simulate them

00:08:36,149 --> 00:08:43,409
all failing and able to verify that it

00:08:39,240 --> 00:08:48,340
works in those particular configurations

00:08:43,409 --> 00:08:50,810
and failure modes so

00:08:48,340 --> 00:08:53,120
within a slot you have an application

00:08:50,810 --> 00:08:57,560
that you wrote that's this thing called

00:08:53,120 --> 00:09:01,250
application and that's code in you know

00:08:57,560 --> 00:09:04,040
save takes effort starting at with a

00:09:01,250 --> 00:09:05,810
vector table at the beginning your code

00:09:04,040 --> 00:09:09,380
that lives in flash will be a piece its

00:09:05,810 --> 00:09:17,030
copy to ram possibly wasn't expecting to

00:09:09,380 --> 00:09:19,700
hear dogs I'm sure so the difference

00:09:17,030 --> 00:09:22,400
here is we have an image header that is

00:09:19,700 --> 00:09:26,990
prepended at the beginning of this the

00:09:22,400 --> 00:09:30,740
header has as a magic number some counts

00:09:26,990 --> 00:09:32,330
of the size of the image itself version

00:09:30,740 --> 00:09:33,890
information just a little bit of

00:09:32,330 --> 00:09:35,930
information about what's in the image

00:09:33,890 --> 00:09:38,860
itself one of the things in there is an

00:09:35,930 --> 00:09:42,980
offset of this these tlv s at the end

00:09:38,860 --> 00:09:47,720
Kelly is just a key value tag value

00:09:42,980 --> 00:09:50,660
thing and this is where the signature of

00:09:47,720 --> 00:09:55,010
the image goes so in a typical instance

00:09:50,660 --> 00:09:58,370
we'll do a shot 256 some use a private

00:09:55,010 --> 00:10:01,450
key to sign that and store the V sign

00:09:58,370 --> 00:10:03,980
the signature as one of these TL vs

00:10:01,450 --> 00:10:06,910
there's a gap and at the end of the

00:10:03,980 --> 00:10:10,610
image is this trailer written in a

00:10:06,910 --> 00:10:12,410
fairly annoying format because of the

00:10:10,610 --> 00:10:15,110
constraints that some of these flash

00:10:12,410 --> 00:10:17,750
devices have as to how you have to write

00:10:15,110 --> 00:10:19,490
to them so it has lots of gaps in it and

00:10:17,750 --> 00:10:22,730
it's in a weird order so that it can be

00:10:19,490 --> 00:10:24,110
written linearly from the beginning the

00:10:22,730 --> 00:10:27,350
important thing about this trailer is

00:10:24,110 --> 00:10:29,330
there's a thing at the beginning of it

00:10:27,350 --> 00:10:31,970
that's just 16 by magic number and

00:10:29,330 --> 00:10:34,940
that's what tells the bootloader is it

00:10:31,970 --> 00:10:37,400
sees that in slot one that you want to

00:10:34,940 --> 00:10:40,910
do an upgrade so once that thing is

00:10:37,400 --> 00:10:43,850
there on the next boot it will start

00:10:40,910 --> 00:10:47,150
swapping the two images to upgrade the

00:10:43,850 --> 00:10:49,190
other thing maybe I should go to the

00:10:47,150 --> 00:10:52,370
next slide since this describes what's

00:10:49,190 --> 00:10:57,200
going to happen so the bootloader checks

00:10:52,370 --> 00:10:59,540
both of the slops if the normal case is

00:10:57,200 --> 00:11:00,710
slot 0 boots there is a configuration as

00:10:59,540 --> 00:11:01,500
to whether you want to verify the

00:11:00,710 --> 00:11:04,890
signature on

00:11:01,500 --> 00:11:07,320
reboot in if that's set you have to have

00:11:04,890 --> 00:11:10,140
a that image has to be signed as well so

00:11:07,320 --> 00:11:13,170
that prevents attacks that modify the

00:11:10,140 --> 00:11:18,330
flash image and try booting the modified

00:11:13,170 --> 00:11:21,150
image so if the second image is marked

00:11:18,330 --> 00:11:25,550
with that magic number it then initiates

00:11:21,150 --> 00:11:28,710
this safe swap of the two images and

00:11:25,550 --> 00:11:31,530
there's a lot of complexity to that as I

00:11:28,710 --> 00:11:33,890
mentioned that if you lose power in the

00:11:31,530 --> 00:11:36,780
middle it detects where it was and

00:11:33,890 --> 00:11:40,530
continues where it left off so that you

00:11:36,780 --> 00:11:44,520
have the new image now in slot 0 and the

00:11:40,530 --> 00:11:46,260
upgraded image so it'll then the reboot

00:11:44,520 --> 00:11:47,730
and try booting this image actually

00:11:46,260 --> 00:11:53,870
doesn't reboot adjust boots into this

00:11:47,730 --> 00:11:57,180
new image in slot 0 and if it works

00:11:53,870 --> 00:11:59,340
things are fine there is a mechanism to

00:11:57,180 --> 00:12:02,670
try to detect that it didn't work and

00:11:59,340 --> 00:12:04,290
when you then reboot it will swap the

00:12:02,670 --> 00:12:08,070
images one more time to put the old

00:12:04,290 --> 00:12:09,510
image back there's some complexity we

00:12:08,070 --> 00:12:11,720
haven't quite figured out to this

00:12:09,510 --> 00:12:14,580
upgrade this verification of okay

00:12:11,720 --> 00:12:16,770
because there's certainly the

00:12:14,580 --> 00:12:19,260
possibility that the power fails while

00:12:16,770 --> 00:12:21,690
you're trying to test the image and so

00:12:19,260 --> 00:12:24,960
it's not completely certain what the

00:12:21,690 --> 00:12:27,870
best scenario is the end the minded

00:12:24,960 --> 00:12:30,210
people they described it as they do a

00:12:27,870 --> 00:12:33,300
small deployment with this feature

00:12:30,210 --> 00:12:35,430
enabled and then after they're done with

00:12:33,300 --> 00:12:38,040
that and that seems to that image seems

00:12:35,430 --> 00:12:39,900
to work for most people they then start

00:12:38,040 --> 00:12:42,390
deploying the image with this set to

00:12:39,900 --> 00:12:44,610
just always mark it as good and it does

00:12:42,390 --> 00:12:49,530
the swap and never goes back to the old

00:12:44,610 --> 00:12:52,050
one the important thing is the upgrade

00:12:49,530 --> 00:12:53,880
itself the bootloader is only doing the

00:12:52,050 --> 00:12:56,430
last step of the upgrade which is

00:12:53,880 --> 00:12:58,890
actually swapping the two images getting

00:12:56,430 --> 00:13:00,780
the upgrade into slot one is the

00:12:58,890 --> 00:13:03,540
responsibility usually of something in

00:13:00,780 --> 00:13:06,120
the application the demo that we saw

00:13:03,540 --> 00:13:08,820
this morning it while the system is

00:13:06,120 --> 00:13:11,520
running it's checking for an upgrade and

00:13:08,820 --> 00:13:13,980
will download the upgrade and populate

00:13:11,520 --> 00:13:14,950
slot one with it and then when that's

00:13:13,980 --> 00:13:18,100
present it

00:13:14,950 --> 00:13:19,960
reboot so that the upgrade happened we

00:13:18,100 --> 00:13:21,340
don't want to put any more complexity

00:13:19,960 --> 00:13:24,250
into the bootloader than is necessary

00:13:21,340 --> 00:13:27,850
because the bootloader is really hard to

00:13:24,250 --> 00:13:29,830
upgrade when you actually care about

00:13:27,850 --> 00:13:32,320
security it's actually impossible to

00:13:29,830 --> 00:13:34,480
upgrade because changing the bootloader

00:13:32,320 --> 00:13:38,770
bypasses the security checks that we

00:13:34,480 --> 00:13:42,540
have there any questions about that

00:13:38,770 --> 00:13:42,540
before I go on to the Zephyr part yes

00:13:46,800 --> 00:13:54,040
yeah I mean it's in an ideal world the

00:13:51,790 --> 00:13:56,290
bootloader is upgradable but only by the

00:13:54,040 --> 00:13:59,410
people that are intending to update it

00:13:56,290 --> 00:14:02,830
in reality that's really hard to

00:13:59,410 --> 00:14:06,150
implement to to be able to upgrade

00:14:02,830 --> 00:14:08,500
something but only allow since the code

00:14:06,150 --> 00:14:12,040
the only to really do that is to have

00:14:08,500 --> 00:14:13,360
code in a mask ROM in the chip and at

00:14:12,040 --> 00:14:15,610
this point that's what we're writing

00:14:13,360 --> 00:14:18,640
here is the code this is that first

00:14:15,610 --> 00:14:22,450
bootloader stage so the goal is to make

00:14:18,640 --> 00:14:23,860
this small and as simple as possible to

00:14:22,450 --> 00:14:26,530
reduce the chance that they're being

00:14:23,860 --> 00:14:28,660
bugs and problems with it because if you

00:14:26,530 --> 00:14:31,540
do if you allow the ability to upgrade

00:14:28,660 --> 00:14:33,460
the bootloader then it's possible for

00:14:31,540 --> 00:14:35,920
someone to replace it with say one that

00:14:33,460 --> 00:14:40,930
doesn't check the signature and allows

00:14:35,920 --> 00:14:43,210
anything to be upgraded so there's kind

00:14:40,930 --> 00:14:46,840
of a mishmash of what's what's there I

00:14:43,210 --> 00:14:49,660
think possibly a better solution a more

00:14:46,840 --> 00:14:53,950
ideal would be to you know get some of

00:14:49,660 --> 00:14:56,770
this functionality in the soc itself to

00:14:53,950 --> 00:14:58,240
where the we maybe have a second stage

00:14:56,770 --> 00:15:00,130
you know there's other ways of handling

00:14:58,240 --> 00:15:03,130
that but given the state we hire in

00:15:00,130 --> 00:15:05,500
right now the only real way to make this

00:15:03,130 --> 00:15:10,560
secure is to not allow the bootloader to

00:15:05,500 --> 00:15:10,560
be upgraded yes

00:15:21,250 --> 00:15:27,410
so the question was about the key then

00:15:25,040 --> 00:15:30,350
you're talking about the public key for

00:15:27,410 --> 00:15:33,560
the verification right now the keys are

00:15:30,350 --> 00:15:35,930
hard-coded in the bootloader and again

00:15:33,560 --> 00:15:39,530
some of that comes back to does a

00:15:35,930 --> 00:15:44,530
particular SOC provide ways of storing

00:15:39,530 --> 00:15:44,530
keys that are safe and secure and you

00:15:44,680 --> 00:15:50,720
know what can be done there this is the

00:15:47,570 --> 00:15:52,610
kind of general solution that we put one

00:15:50,720 --> 00:15:55,460
or more keys in the bootloader itself

00:15:52,610 --> 00:15:58,070
the idea is it has a table index by an

00:15:55,460 --> 00:16:01,070
integer and the signature itself

00:15:58,070 --> 00:16:03,500
references which key it was signed with

00:16:01,070 --> 00:16:06,470
and it just verifies it's certainly

00:16:03,500 --> 00:16:09,680
something there could be a lot better

00:16:06,470 --> 00:16:11,600
ways of doing things I don't haven't

00:16:09,680 --> 00:16:15,770
completely thought through how we can

00:16:11,600 --> 00:16:17,270
improve that and I knew anybody has any

00:16:15,770 --> 00:16:24,890
great ideas that would certainly be

00:16:17,270 --> 00:16:28,700
welcome yes that's a really good

00:16:24,890 --> 00:16:31,900
question so the motivation for that was

00:16:28,700 --> 00:16:34,760
to be able to revert the old image and

00:16:31,900 --> 00:16:36,800
I've actually made the same question to

00:16:34,760 --> 00:16:39,920
the people will be who wrote the code

00:16:36,800 --> 00:16:41,840
why do we provide that complex because

00:16:39,920 --> 00:16:45,130
the fairly complicated operation and

00:16:41,840 --> 00:16:48,160
what I was suggesting is that we have if

00:16:45,130 --> 00:16:51,590
we're not intending to be able to revert

00:16:48,160 --> 00:16:53,420
so let me ask there's two questions

00:16:51,590 --> 00:16:56,630
actually I think I'm going to answer so

00:16:53,420 --> 00:16:58,940
one is why do we not just overwrite the

00:16:56,630 --> 00:17:02,720
first image with the second image with

00:16:58,940 --> 00:17:05,589
something we can do safely but it it

00:17:02,720 --> 00:17:08,240
takes away your ability to revert and

00:17:05,589 --> 00:17:11,930
there's some motivation as to whether

00:17:08,240 --> 00:17:13,689
revert is a useful thing to do second

00:17:11,930 --> 00:17:16,130
question is why do we swap them at all

00:17:13,689 --> 00:17:18,350
it's certainly possible to build the

00:17:16,130 --> 00:17:21,530
application so that it could run in

00:17:18,350 --> 00:17:24,890
which slot you want it does constrain

00:17:21,530 --> 00:17:26,690
you then you can only up

00:17:24,890 --> 00:17:28,790
made between images where the low bit of

00:17:26,690 --> 00:17:31,220
the version number differs because you

00:17:28,790 --> 00:17:33,290
have to decide to build a given image

00:17:31,220 --> 00:17:35,330
you have to decide the link for slot 0

00:17:33,290 --> 00:17:40,580
or link for slot 1 because either not

00:17:35,330 --> 00:17:51,500
position independent or executable maybe

00:17:40,580 --> 00:17:57,260
I don't know how yet that does put a lot

00:17:51,500 --> 00:18:08,200
more complexity in the boot loader or do

00:17:57,260 --> 00:18:11,000
it over 400 when doing the upgrade it's

00:18:08,200 --> 00:18:29,510
right that's so that makes the signature

00:18:11,000 --> 00:18:32,380
verification challenging yes yes that's

00:18:29,510 --> 00:18:35,030
actually that would be wonderful I

00:18:32,380 --> 00:18:40,280
haven't encountered any of these MCS

00:18:35,030 --> 00:18:43,840
that have that capability it's a good

00:18:40,280 --> 00:18:43,840
ideas so one of the things

00:18:55,970 --> 00:19:00,560
and I would have to wonder i'm not sure

00:18:58,910 --> 00:19:04,880
what the performance implications are

00:19:00,560 --> 00:19:08,020
for that for the four because the mcs

00:19:04,880 --> 00:19:12,560
that we're using only support thumb and

00:19:08,020 --> 00:19:14,720
i don't i don't actually know what the I

00:19:12,560 --> 00:19:17,150
mean for one thing it would require the

00:19:14,720 --> 00:19:19,090
vector table be placed in ram instead of

00:19:17,150 --> 00:19:21,680
wrong because right now there's jump

00:19:19,090 --> 00:19:24,890
addresses in this vector table which

00:19:21,680 --> 00:19:25,970
lives in flash so and there's probably a

00:19:24,890 --> 00:19:28,970
lot of other things that would be

00:19:25,970 --> 00:19:31,120
affected by that too it's certainly not

00:19:28,970 --> 00:19:34,130
something that Zephyr supports right now

00:19:31,120 --> 00:19:38,420
but there's certain there are definitely

00:19:34,130 --> 00:19:40,070
ways to get around this I think well an

00:19:38,420 --> 00:19:42,110
area for improvement is to make the

00:19:40,070 --> 00:19:44,110
bootloader a little bit more flexible as

00:19:42,110 --> 00:19:47,000
far as its code in terms of what it does

00:19:44,110 --> 00:19:50,060
because as you said when even when they

00:19:47,000 --> 00:19:52,100
deploy they deploy a small number of

00:19:50,060 --> 00:19:53,930
them that are able to do this swapping

00:19:52,100 --> 00:19:57,290
and revert thing and then the rest are

00:19:53,930 --> 00:19:59,960
deployed with stomp the new image on it

00:19:57,290 --> 00:20:02,150
and forget about it never go back except

00:19:59,960 --> 00:20:05,030
that the implementation still swaps them

00:20:02,150 --> 00:20:07,160
when it does that and there's extra

00:20:05,030 --> 00:20:09,230
we're on the flash device when when

00:20:07,160 --> 00:20:11,950
doing that although typically you're not

00:20:09,230 --> 00:20:14,690
doing upgrades on the kind of numbers

00:20:11,950 --> 00:20:16,730
the thousands of cycles that you're

00:20:14,690 --> 00:20:19,840
hundreds of thousands you're typically

00:20:16,730 --> 00:20:19,840
able to get out of these devices

00:20:28,799 --> 00:20:37,149
so in a sense this doesn't that wouldn't

00:20:34,059 --> 00:20:40,119
be done here as far as how you come up

00:20:37,149 --> 00:20:42,190
with what goes in slot one that's up to

00:20:40,119 --> 00:20:44,649
the application that's running after the

00:20:42,190 --> 00:20:47,169
bootloader is done before it's rebooted

00:20:44,649 --> 00:20:50,289
the next time so it's certainly possible

00:20:47,169 --> 00:20:53,230
for that application to look at slot 0

00:20:50,289 --> 00:20:56,080
which is the current version read this

00:20:53,230 --> 00:20:59,019
Delta and generate the new image in slot

00:20:56,080 --> 00:21:01,749
1 and then reboot into the upgrade so

00:20:59,019 --> 00:21:05,619
there's nothing precluding doing a delta

00:21:01,749 --> 00:21:09,429
upgrade because the first image is still

00:21:05,619 --> 00:21:19,149
there still readable and that part of it

00:21:09,429 --> 00:21:20,590
is done outside of the bootloader yes

00:21:19,149 --> 00:21:34,960
the image of the new image goes in slot

00:21:20,590 --> 00:21:37,230
1 well so the thing is that the

00:21:34,960 --> 00:21:40,929
application of the Delta would be done

00:21:37,230 --> 00:21:44,470
the application before rebooting into

00:21:40,929 --> 00:21:46,419
the bootloader so the Delta would be it

00:21:44,470 --> 00:21:48,629
if you're going to do Delta's you

00:21:46,419 --> 00:21:53,879
probably allow space for a delta and

00:21:48,629 --> 00:21:57,279
then you would have so that that

00:21:53,879 --> 00:21:59,350
applying a delta is even more complexity

00:21:57,279 --> 00:22:00,940
than we have the swap image swapping and

00:21:59,350 --> 00:22:02,559
it's something we'd like to have that

00:22:00,940 --> 00:22:05,440
complexity not in this code that we

00:22:02,559 --> 00:22:09,100
can't ever upgrade so if we put it in

00:22:05,440 --> 00:22:10,809
the application then that can be

00:22:09,100 --> 00:22:12,639
improved with future versions and

00:22:10,809 --> 00:22:16,330
somebody can come up with a better Delta

00:22:12,639 --> 00:22:18,820
algorithm that kind of thing if you want

00:22:16,330 --> 00:22:20,529
we can talk more afterwards I think it

00:22:18,820 --> 00:22:24,700
might be best to these slots are really

00:22:20,529 --> 00:22:26,169
short so let me go on it because I just

00:22:24,700 --> 00:22:30,789
have a couple flights left as far as

00:22:26,169 --> 00:22:32,799
some of the things about Zephyr I had I

00:22:30,789 --> 00:22:34,269
pushed a can full of patches through his

00:22:32,799 --> 00:22:37,359
effort in order to make this boot loader

00:22:34,269 --> 00:22:39,970
possible with it the first one there's a

00:22:37,359 --> 00:22:40,669
thing called config flash base address

00:22:39,970 --> 00:22:42,590
which

00:22:40,669 --> 00:22:46,249
that's where it thinks the beginning of

00:22:42,590 --> 00:22:48,649
flashes and fortunately this is actually

00:22:46,249 --> 00:22:51,830
going away Zephyr has just moved to

00:22:48,649 --> 00:22:53,720
device tree and the device tree file

00:22:51,830 --> 00:22:56,619
defines the flash and a parameter in

00:22:53,720 --> 00:22:59,330
that file and will soon be getting an

00:22:56,619 --> 00:23:02,690
override file so that an application can

00:22:59,330 --> 00:23:04,039
say I'd like to be in slot 0 or I'm the

00:23:02,690 --> 00:23:06,950
bootloader I'd like to be at the

00:23:04,039 --> 00:23:08,450
beginning but as it stands right now if

00:23:06,950 --> 00:23:10,940
you use code right before that release

00:23:08,450 --> 00:23:14,149
you just set this config option to the

00:23:10,940 --> 00:23:27,109
address of slot 0 the other thing is you

00:23:14,149 --> 00:23:29,779
need room yeah let's make sure let's

00:23:27,109 --> 00:23:31,429
make sure we talk before it'd be the end

00:23:29,779 --> 00:23:33,950
no I think it's important to talk about

00:23:31,429 --> 00:23:35,919
because we want to try to come up with

00:23:33,950 --> 00:23:38,419
the correct implementation for this

00:23:35,919 --> 00:23:40,609
there's another thing called config text

00:23:38,419 --> 00:23:42,529
section offset which basically says yes

00:23:40,609 --> 00:23:44,809
the code lives at this address is the

00:23:42,529 --> 00:23:46,489
base of flash where does the vector

00:23:44,809 --> 00:23:50,539
table and the rest of code start in that

00:23:46,489 --> 00:23:53,210
so this can be set to a typical value

00:23:50,539 --> 00:23:55,759
might be 512 bytes it's a fairly small

00:23:53,210 --> 00:23:59,749
amount but this was not implemented for

00:23:55,759 --> 00:24:01,899
any of the cortex-m parts and I pushed

00:23:59,749 --> 00:24:04,879
an implementation of that through and

00:24:01,899 --> 00:24:06,350
then there was a handful of devices to

00:24:04,879 --> 00:24:07,909
assume the vector table is at the

00:24:06,350 --> 00:24:10,220
beginning of basically the vector table

00:24:07,909 --> 00:24:13,609
of the 0 and they never bothered

00:24:10,220 --> 00:24:15,759
initializing it so I had to put support

00:24:13,609 --> 00:24:19,129
in there to initialize the vector table

00:24:15,759 --> 00:24:21,470
in Zephyr the vector table is in flash

00:24:19,129 --> 00:24:24,200
so you have to set the table offset

00:24:21,470 --> 00:24:27,100
table register to it for minut they copy

00:24:24,200 --> 00:24:28,970
it to ram so it can be anywhere and

00:24:27,100 --> 00:24:31,100
there are there some funny

00:24:28,970 --> 00:24:33,980
device-specific alignment requirements

00:24:31,100 --> 00:24:38,899
that are interestingly documented in the

00:24:33,980 --> 00:24:41,749
arm documentation and a typical value

00:24:38,899 --> 00:24:43,429
might be anywhere between 128 and 512 it

00:24:41,749 --> 00:24:48,739
depends on the number of vectors your

00:24:43,429 --> 00:24:52,369
device has so as far as tooling goes how

00:24:48,739 --> 00:24:54,440
does this all come together the

00:24:52,369 --> 00:24:57,080
applications are just built as regular

00:24:54,440 --> 00:24:58,580
zephyr apps other than telling it you

00:24:57,080 --> 00:25:01,070
need to have this space for this image

00:24:58,580 --> 00:25:04,490
header and it goes after the business

00:25:01,070 --> 00:25:06,230
lot 0 address the bootloader itself is a

00:25:04,490 --> 00:25:08,840
regular Zephyr application that you

00:25:06,230 --> 00:25:10,429
build there's some work we're going to

00:25:08,840 --> 00:25:12,980
I'm going to try to remember to bring up

00:25:10,429 --> 00:25:15,409
to make the amount of Zephyr code

00:25:12,980 --> 00:25:19,700
brought in a lot smaller and see if we

00:25:15,409 --> 00:25:21,590
can make that happen so the public and

00:25:19,700 --> 00:25:23,679
private keys for development I have a

00:25:21,590 --> 00:25:25,820
set of keys embedded in the code

00:25:23,679 --> 00:25:27,470
obviously you don't want to use these in

00:25:25,820 --> 00:25:30,470
production because the private key is

00:25:27,470 --> 00:25:33,080
checked into a github repository but

00:25:30,470 --> 00:25:37,279
there's a pretty straightforward process

00:25:33,080 --> 00:25:39,379
for generating some new keys there's the

00:25:37,279 --> 00:25:40,519
my new project has this new tool that

00:25:39,379 --> 00:25:44,840
they use for their building and

00:25:40,519 --> 00:25:46,700
everything and I basically created a

00:25:44,840 --> 00:25:49,549
small application that uses that code as

00:25:46,700 --> 00:25:53,149
a library and provides a few things

00:25:49,549 --> 00:25:55,340
specific for what we need i wrote a key

00:25:53,149 --> 00:25:58,429
creation and some code that spits out

00:25:55,340 --> 00:26:00,740
the c code representation of the public

00:25:58,429 --> 00:26:02,929
key that you basically just cut and

00:26:00,740 --> 00:26:07,370
paste that into the source code to use

00:26:02,929 --> 00:26:09,860
your own key with it this also then this

00:26:07,370 --> 00:26:12,350
tool you can give it your private key

00:26:09,860 --> 00:26:14,210
and an image and set some other

00:26:12,350 --> 00:26:15,879
parameters and it will sign the image

00:26:14,210 --> 00:26:21,070
for you because it's kind of important

00:26:15,879 --> 00:26:27,279
and that's it for the presentation

00:26:21,070 --> 00:26:27,279
there's any questions more questions yes

00:26:31,509 --> 00:26:39,080
no so currently no there's no recovery

00:26:36,230 --> 00:26:43,129
mechanism um it's something we've talked

00:26:39,080 --> 00:26:45,200
about as far as at that point recovery

00:26:43,129 --> 00:26:48,080
essentially becomes another application

00:26:45,200 --> 00:26:50,179
that you put somewhere and if neither

00:26:48,080 --> 00:26:52,100
slot works you know how to jump to it

00:26:50,179 --> 00:26:54,919
it's not a lot of code to write from the

00:26:52,100 --> 00:26:56,480
boot loaders point of view it's a lot of

00:26:54,919 --> 00:26:59,509
code to write from the point of view of

00:26:56,480 --> 00:27:01,490
its recovery tool it also starts to

00:26:59,509 --> 00:27:05,299
depend a lot on your application because

00:27:01,490 --> 00:27:06,619
it needs to know how do we get the

00:27:05,299 --> 00:27:07,559
recovery image where does it come from

00:27:06,619 --> 00:27:11,639
what kind of

00:27:07,559 --> 00:27:14,029
working stack so it's not a problem

00:27:11,639 --> 00:27:24,960
that's not a problem we've addressed yet

00:27:14,029 --> 00:27:28,470
with that yes yes the this ok so the

00:27:24,960 --> 00:27:31,470
flash devices on all of the end views

00:27:28,470 --> 00:27:33,509
that I've encountered so far allow you

00:27:31,470 --> 00:27:35,370
to write to as long as it's a different

00:27:33,509 --> 00:27:41,159
sector than the one you're writing to

00:27:35,370 --> 00:27:44,399
they allow both operations to happen the

00:27:41,159 --> 00:27:46,789
Zephyr flash driver handles that I think

00:27:44,399 --> 00:27:50,129
a couple ones that I looked at it

00:27:46,789 --> 00:27:52,740
effectively masks interrupts and run the

00:27:50,129 --> 00:27:58,740
little coat out of RAM that that does

00:27:52,740 --> 00:28:00,659
the right to flash so that they do yeah

00:27:58,740 --> 00:28:02,070
but it's a really tiny piece of code

00:28:00,659 --> 00:28:04,080
that basically says wait till the flash

00:28:02,070 --> 00:28:06,929
operation is done and then and then come

00:28:04,080 --> 00:28:10,950
back but I think we're probably out of

00:28:06,929 --> 00:28:15,419
time I'm not sure the meetings are only

00:28:10,950 --> 00:28:16,550
30 minutes so I guess that's it thank

00:28:15,419 --> 00:28:22,210
you very much

00:28:16,550 --> 00:28:22,210
[Applause]

00:28:23,149 --> 00:28:25,210

YouTube URL: https://www.youtube.com/watch?v=tv502SMhwYE


