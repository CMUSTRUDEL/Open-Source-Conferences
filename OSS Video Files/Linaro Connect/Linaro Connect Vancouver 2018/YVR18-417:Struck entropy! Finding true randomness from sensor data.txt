Title: YVR18-417:Struck entropy! Finding true randomness from sensor data
Publication date: 2018-09-28
Playlist: Linaro Connect Vancouver 2018
Description: 
	Generating random numbers is essential to cryptography and providing a source of true randomness is an important feature for modern systems. The kernel provides a software implementation but this often lacks sufficient entropy at critical points (especially at boot), is not trusted by components such as OP-TEE and an equivalent rarely exists in the small RTOSes that power the IoT. An alternative is a hardware TRNG but what if you are working on a system without one?

This session is a case study describing our work to bring a hardware TRNG to Developerbox. This platform did not include a TRNG peripheral so we had to find an alternative. We wrote an OP-TEE static Trusted Application (TA) to collect entropy using thermal noise from the on-chip thermal sensors. The data we got required conditioning to eliminate bias but with simple conditioning we were able to generate sequences of numbers that pass suitable fitness tests. We will also look at how we optimized entropy collection using secure timer interrupt to avoid busy loops.
Captions: 
	00:00:02,110 --> 00:00:07,120
[Music]

00:00:08,269 --> 00:00:16,110
good afternoon thanks for joining this

00:00:11,010 --> 00:00:18,000
session so in today's talk we will go

00:00:16,110 --> 00:00:20,240
about our journey regarding how we

00:00:18,000 --> 00:00:23,789
reached a few random number generator

00:00:20,240 --> 00:00:26,460
using randomness from sensor data so as

00:00:23,789 --> 00:00:28,470
you might all know that since random

00:00:26,460 --> 00:00:30,840
numbers are considered as the basic

00:00:28,470 --> 00:00:33,420
building blocks for any modern crypto

00:00:30,840 --> 00:00:36,180
system and it is impossible to achieve

00:00:33,420 --> 00:00:39,630
reliable security without a true source

00:00:36,180 --> 00:00:42,660
for randomness so here I am

00:00:39,630 --> 00:00:45,540
Soumitra working as part of support and

00:00:42,660 --> 00:00:47,390
solutions team Lennar oh especially

00:00:45,540 --> 00:00:50,850
responsible for platform security

00:00:47,390 --> 00:00:53,700
activities like op the trusted firmware

00:00:50,850 --> 00:00:56,129
and boot loaders I also have along with

00:00:53,700 --> 00:01:03,180
me Daniel here who will complement me

00:00:56,129 --> 00:01:05,939
during this session if required so let's

00:01:03,180 --> 00:01:08,340
get started with the agenda for today so

00:01:05,939 --> 00:01:12,420
firstly I will briefly introduce you to

00:01:08,340 --> 00:01:14,939
developer box and then we will discuss

00:01:12,420 --> 00:01:17,009
about the optic port I hope everyone

00:01:14,939 --> 00:01:19,770
here in this room is familiar with opti

00:01:17,009 --> 00:01:22,289
if not come to me or any security

00:01:19,770 --> 00:01:24,240
working group member we will point you

00:01:22,289 --> 00:01:27,389
to whole bunch of material to read about

00:01:24,240 --> 00:01:30,029
opti and then moving forward we will

00:01:27,389 --> 00:01:31,829
discuss about the opti use case if

00:01:30,029 --> 00:01:35,459
random number generator is a feasible

00:01:31,829 --> 00:01:39,929
use case and then check if this random

00:01:35,459 --> 00:01:43,770
number generator which we implemented if

00:01:39,929 --> 00:01:46,020
it's truly random or not then we will

00:01:43,770 --> 00:01:49,770
come to the optimization technique which

00:01:46,020 --> 00:01:53,279
we used to improve the RNG collection

00:01:49,770 --> 00:01:57,509
rate lastly we will see the RNG use

00:01:53,279 --> 00:02:01,619
cases for developer box so moving

00:01:57,509 --> 00:02:04,499
forward so firstly this developer box as

00:02:01,619 --> 00:02:07,679
you can see it's a social neck sync

00:02:04,499 --> 00:02:11,549
racer as SUSE based 24 core SOC of

00:02:07,679 --> 00:02:14,160
cortex a53 it's major use cases are

00:02:11,549 --> 00:02:18,480
related to arm based

00:02:14,160 --> 00:02:20,730
software development apart from that IOT

00:02:18,480 --> 00:02:23,670
gateway edge computing and the low power

00:02:20,730 --> 00:02:26,700
consumption server so basically it's a

00:02:23,670 --> 00:02:31,350
high-end platform that are major use

00:02:26,700 --> 00:02:33,690
cases now coming on to the optic port as

00:02:31,350 --> 00:02:37,560
a starting point of development for this

00:02:33,690 --> 00:02:39,510
platform so here you could see normal

00:02:37,560 --> 00:02:40,920
world and the secure world I think most

00:02:39,510 --> 00:02:43,230
of you would be familiar with this

00:02:40,920 --> 00:02:47,580
picture with this kind of a picture so

00:02:43,230 --> 00:02:49,730
here are the optic components firstly in

00:02:47,580 --> 00:02:54,210
the normal world the client application

00:02:49,730 --> 00:02:56,010
optic client Linux T driver and on the

00:02:54,210 --> 00:02:57,930
now in the secure world side we have

00:02:56,010 --> 00:03:02,100
opti dispatcher in the trusted form via

00:02:57,930 --> 00:03:07,140
up tos and the trusted applications so

00:03:02,100 --> 00:03:09,480
here this numbering implies the booting

00:03:07,140 --> 00:03:10,910
sequence on developer box so starting

00:03:09,480 --> 00:03:13,650
with the SCP founder

00:03:10,910 --> 00:03:16,860
moving on to the trusted firmware then

00:03:13,650 --> 00:03:19,680
trusted from there loads of TOS after

00:03:16,860 --> 00:03:21,630
Optimus is done in it is done it returns

00:03:19,680 --> 00:03:24,390
back to the trusted firmware which are

00:03:21,630 --> 00:03:28,080
which passes further control to you fee

00:03:24,390 --> 00:03:32,100
edk to in the normal world which finally

00:03:28,080 --> 00:03:33,930
loads Linux and passes on the control so

00:03:32,100 --> 00:03:36,990
this is the complete picture foreign

00:03:33,930 --> 00:03:40,170
optic port now we have the optic port

00:03:36,990 --> 00:03:43,140
with us so we were looking for a use

00:03:40,170 --> 00:03:46,020
case for this OP T as you might know the

00:03:43,140 --> 00:03:47,880
traditional use cases like the DRM that

00:03:46,020 --> 00:03:50,940
doesn't seems to be fit on this

00:03:47,880 --> 00:03:53,420
developer box platform so what we found

00:03:50,940 --> 00:03:56,400
out that on developer box lacks a

00:03:53,420 --> 00:03:58,950
hardware based few random number

00:03:56,400 --> 00:04:02,670
generator so but kernel does provide

00:03:58,950 --> 00:04:04,680
some software implementation to fetch

00:04:02,670 --> 00:04:07,709
some randomness from inter interrupt

00:04:04,680 --> 00:04:10,740
timings but that has some following

00:04:07,709 --> 00:04:14,640
shortcomings like it lacks sufficient in

00:04:10,740 --> 00:04:17,340
trophy at boot especially at critical

00:04:14,640 --> 00:04:19,260
points and it's not rusted by components

00:04:17,340 --> 00:04:21,750
like opti I was running in the secure

00:04:19,260 --> 00:04:26,210
world and it's quite slow especially

00:04:21,750 --> 00:04:26,210
when there are fewer interrupts

00:04:27,500 --> 00:04:32,520
excluding developer box we found out

00:04:30,150 --> 00:04:35,159
that developer box provides seven on

00:04:32,520 --> 00:04:37,919
chip thermal sensors that are accessible

00:04:35,159 --> 00:04:40,050
from secure world only and their data

00:04:37,919 --> 00:04:42,990
sensing temperature from various group

00:04:40,050 --> 00:04:45,840
of score plasters so the question here

00:04:42,990 --> 00:04:49,949
arises if these thermal sensors provide

00:04:45,840 --> 00:04:53,819
us enough noise to be a to be to develop

00:04:49,949 --> 00:04:56,159
a true random number generator so this

00:04:53,819 --> 00:04:59,340
was the question we have so to find an

00:04:56,159 --> 00:05:02,759
answer to this we I just had a look over

00:04:59,340 --> 00:05:06,020
the randomness sources from a particular

00:05:02,759 --> 00:05:09,539
sensor so here during the measurement of

00:05:06,020 --> 00:05:11,969
in a particular sensor you have this

00:05:09,539 --> 00:05:15,449
measurement error being introduced here

00:05:11,969 --> 00:05:18,440
and this error being introduced during

00:05:15,449 --> 00:05:21,360
the ADC conversion so these two errors

00:05:18,440 --> 00:05:23,190
combining these two errors leads to the

00:05:21,360 --> 00:05:25,650
to the randomness in the least

00:05:23,190 --> 00:05:27,779
significant bits of the particular

00:05:25,650 --> 00:05:29,370
sensor output but having said that it

00:05:27,779 --> 00:05:33,060
depends on the precision of the

00:05:29,370 --> 00:05:35,370
measurement and the ADC conversion like

00:05:33,060 --> 00:05:38,159
how many bits are you using for this

00:05:35,370 --> 00:05:42,839
analog measurement and then for the

00:05:38,159 --> 00:05:46,110
digital conversion so this is the

00:05:42,839 --> 00:05:48,300
snapshot from thermal sensor a

00:05:46,110 --> 00:05:51,240
particular thermal thermal sensor on

00:05:48,300 --> 00:05:53,400
developer box so these are 10 samples I

00:05:51,240 --> 00:05:57,870
have pasted here in binary form these

00:05:53,400 --> 00:06:00,930
are taken every 2 milliseconds as the

00:05:57,870 --> 00:06:04,440
thermal sensor value refreshes every 2

00:06:00,930 --> 00:06:08,759
milliseconds so here you could see in

00:06:04,440 --> 00:06:12,599
the lower to lower two bits we see some

00:06:08,759 --> 00:06:14,490
data bits changing so this provided us

00:06:12,599 --> 00:06:21,330
some clue regarding this randomness

00:06:14,490 --> 00:06:24,029
presence in this thermal sensor so using

00:06:21,330 --> 00:06:26,580
so coming on to the RNG mechanism we

00:06:24,029 --> 00:06:30,569
used so as we saw the randomness before

00:06:26,580 --> 00:06:34,139
so as developer box has seven thermal

00:06:30,569 --> 00:06:36,569
sensors so we deserve we decided to

00:06:34,139 --> 00:06:39,779
collect this randomness from the lower

00:06:36,569 --> 00:06:41,269
order bits and to provide us energy byte

00:06:39,779 --> 00:06:45,110
stream

00:06:41,269 --> 00:06:48,719
now we have the RNG byte stream but

00:06:45,110 --> 00:06:53,699
suppose we have 20k data bits generated

00:06:48,719 --> 00:06:55,860
from this RNG so is this truly random so

00:06:53,699 --> 00:06:58,289
this is the main question that arise it

00:06:55,860 --> 00:07:02,969
and we are trying to find an answer at

00:06:58,289 --> 00:07:04,979
this point also so answer to this really

00:07:02,969 --> 00:07:08,249
depends on how much paranoia one has so

00:07:04,979 --> 00:07:13,739
there are a number of tests but one

00:07:08,249 --> 00:07:16,319
can't fully sure be is this data is

00:07:13,739 --> 00:07:19,229
truly random or not so in our case what

00:07:16,319 --> 00:07:23,099
we did is we collected approximately two

00:07:19,229 --> 00:07:26,610
point one gigabytes of data from thermal

00:07:23,099 --> 00:07:31,050
sensors so and use this RNG test this is

00:07:26,610 --> 00:07:34,019
a FIPS 140 RNG fitness test that are

00:07:31,050 --> 00:07:38,519
implemented by this yes I have put some

00:07:34,019 --> 00:07:40,829
links here so you could read it later so

00:07:38,519 --> 00:07:45,959
it's basically my hearing the randomness

00:07:40,829 --> 00:07:49,019
so called so so coming on to the

00:07:45,959 --> 00:07:53,099
algorithms which we use we started with

00:07:49,019 --> 00:07:57,919
this LSB only we use the LSB from every

00:07:53,099 --> 00:08:01,860
thermal sensor output as shown here so

00:07:57,919 --> 00:08:04,889
due to create a single byte we use two

00:08:01,860 --> 00:08:08,129
samples in getting seven bits from seven

00:08:04,889 --> 00:08:12,779
LS B's from one same sample and the 8

00:08:08,129 --> 00:08:16,439
LSB from the second sample so this

00:08:12,779 --> 00:08:18,239
provided us a byte stream of data so on

00:08:16,439 --> 00:08:21,869
this byte stream of data we ran this

00:08:18,239 --> 00:08:25,489
FIPS test so it showed the success ratio

00:08:21,869 --> 00:08:28,679
of two 0.13% so it was the first

00:08:25,489 --> 00:08:32,119
verification that this thermal sensor

00:08:28,679 --> 00:08:32,119
has some randomness in them

00:08:34,509 --> 00:08:43,180
this is let me show case you the how it

00:08:37,959 --> 00:08:45,190
looks like one second this missus the

00:08:43,180 --> 00:08:47,889
results how it looks like so these are

00:08:45,190 --> 00:08:51,759
the successes and these are the failures

00:08:47,889 --> 00:08:56,319
I have calculated the ratio yeah it's

00:08:51,759 --> 00:08:58,569
really bad we will come forward two

00:08:56,319 --> 00:09:00,759
percent is not what you want in a forum

00:08:58,569 --> 00:09:02,470
system but to have unconditioned

00:09:00,759 --> 00:09:09,970
sensitive and then give you deeper said

00:09:02,470 --> 00:09:12,459
is actually quite astonishing so I'm

00:09:09,970 --> 00:09:15,790
moving forward to the second algorithm

00:09:12,459 --> 00:09:18,639
and the LS people in the earlier

00:09:15,790 --> 00:09:21,610
algorithm which saw that we require two

00:09:18,639 --> 00:09:25,779
samples to formulate a bite so in this

00:09:21,610 --> 00:09:29,380
we try to optimize that we formulated

00:09:25,779 --> 00:09:34,300
the eight bit of the bite using the Czar

00:09:29,380 --> 00:09:38,800
of bit one so you have a one byte per

00:09:34,300 --> 00:09:40,779
sample now and over this byte stream

00:09:38,800 --> 00:09:44,130
will and again the flips test so it

00:09:40,779 --> 00:09:49,209
showed the results got further down so

00:09:44,130 --> 00:09:52,360
0.07% I so this shows that that bit one

00:09:49,209 --> 00:09:56,019
that has some bias in it systematic bias

00:09:52,360 --> 00:09:58,779
in it so now we will discuss about the

00:09:56,019 --> 00:10:03,370
whitening techniques which we used over

00:09:58,779 --> 00:10:06,160
this RNG raw data from the second

00:10:03,370 --> 00:10:10,300
approach so first first thing we did was

00:10:06,160 --> 00:10:14,339
we use the crc32 algo / for byte payload

00:10:10,300 --> 00:10:18,519
so that recall 32 : 32 bit whitening and

00:10:14,339 --> 00:10:20,860
secondly we did the crc32 algo / 5 byte

00:10:18,519 --> 00:10:24,730
payload so this was done to accommodate

00:10:20,860 --> 00:10:27,970
that bit one bias that was added in the

00:10:24,730 --> 00:10:29,540
previous slide and in to accommodate

00:10:27,970 --> 00:10:32,040
this paper

00:10:29,540 --> 00:10:34,380
so I might have missed the first slide

00:10:32,040 --> 00:10:35,830
but is this coffee exceeded or is this

00:10:34,380 --> 00:10:39,519
like magic

00:10:35,830 --> 00:10:43,180
it is basically the least significant

00:10:39,519 --> 00:10:45,519
bits that are being accumulated from the

00:10:43,180 --> 00:10:48,970
sensor data that is a sensor output you

00:10:45,519 --> 00:10:52,600
when you read a sensor output it formul

00:10:48,970 --> 00:10:56,769
it so basically that's yeah degrees

00:10:52,600 --> 00:10:59,050
celsium cool fifth degree celsius it's

00:10:56,769 --> 00:11:01,870
not a very high rate sensor but is it's

00:10:59,050 --> 00:11:07,560
in quarter degrees yeah it's a common

00:11:01,870 --> 00:11:10,480
sense ahem so the results of this

00:11:07,560 --> 00:11:14,730
whitening that that were very successful

00:11:10,480 --> 00:11:19,959
so we saw the fifth best success ratio

00:11:14,730 --> 00:11:22,540
99.9 percent I it was similar for both

00:11:19,959 --> 00:11:25,660
the approaches C RC / for bite off I

00:11:22,540 --> 00:11:29,230
bite this collection rate was 500 bytes

00:11:25,660 --> 00:11:31,450
per second we tried to distinguish

00:11:29,230 --> 00:11:34,660
between the CRC full bite and 5 bite

00:11:31,450 --> 00:11:36,519
using this die harder suit also but the

00:11:34,660 --> 00:11:39,940
results were ambiguous we were weren't

00:11:36,519 --> 00:11:43,240
able to discriminate so overall this

00:11:39,940 --> 00:11:47,260
provided a good testament to our RNG

00:11:43,240 --> 00:11:49,770
source that sensor data so moving

00:11:47,260 --> 00:11:52,959
forward comparing these results with the

00:11:49,770 --> 00:11:56,470
actual randomness like we used this

00:11:52,959 --> 00:12:00,070
random.org to collect two gigabytes of

00:11:56,470 --> 00:12:02,950
data and ran this flips test on that so

00:12:00,070 --> 00:12:05,200
we use this WIPs test as a standard

00:12:02,950 --> 00:12:09,610
measurement for everything so it also

00:12:05,200 --> 00:12:11,890
showed similar results 99.99 to

00:12:09,610 --> 00:12:15,040
percentile success ratio and moving

00:12:11,890 --> 00:12:17,829
forward I tried it with my Intel machine

00:12:15,040 --> 00:12:21,790
which uses this our design instruction

00:12:17,829 --> 00:12:24,490
to fetch entropy that also shows similar

00:12:21,790 --> 00:12:26,110
results but with the entropic election

00:12:24,490 --> 00:12:29,320
rate that is pretty high because it's

00:12:26,110 --> 00:12:32,790
hardware instruction and the Cascade

00:12:29,320 --> 00:12:32,790
PRNG would see

00:12:32,829 --> 00:12:42,110
not the true rainin imagine this is

00:12:35,560 --> 00:12:45,439
cascade PRNG so now coming on to the

00:12:42,110 --> 00:12:47,089
implementation as this sensor data that

00:12:45,439 --> 00:12:50,180
could be accessible from secure world

00:12:47,089 --> 00:12:54,560
only so what we did was he wrote this

00:12:50,180 --> 00:12:57,350
rng sudo ta that is part of up to us and

00:12:54,560 --> 00:12:59,139
it's initialized during obtain it and

00:12:57,350 --> 00:13:01,730
the normal world client interface

00:12:59,139 --> 00:13:06,290
remains the same as with the dynamic T

00:13:01,730 --> 00:13:09,079
and it provided provides this RNG

00:13:06,290 --> 00:13:14,089
service by this SMC interface to the T

00:13:09,079 --> 00:13:18,410
driver so this is at boot time only it's

00:13:14,089 --> 00:13:21,860
initialized and you could have this so

00:13:18,410 --> 00:13:24,829
no one issue which we faced with this

00:13:21,860 --> 00:13:27,949
RNG collection was the continuous busy

00:13:24,829 --> 00:13:31,550
looping the sensor value refreshes every

00:13:27,949 --> 00:13:33,379
two milliseconds and the maximum and

00:13:31,550 --> 00:13:35,990
data can be collected if we pull the

00:13:33,379 --> 00:13:38,449
sensors frequently but the real

00:13:35,990 --> 00:13:40,009
implementation that relied that until

00:13:38,449 --> 00:13:43,910
the data is generated you keep on

00:13:40,009 --> 00:13:46,189
cooling the sensors so that that leads

00:13:43,910 --> 00:13:49,309
to this multi millisecond restful of

00:13:46,189 --> 00:13:52,670
busy busy look so we try to address this

00:13:49,309 --> 00:13:56,990
issue using the secure timer interrupts

00:13:52,670 --> 00:13:59,809
and the pseudo ta of the pseudo ta that

00:13:56,990 --> 00:14:03,319
fires every two milliseconds and an

00:13:59,809 --> 00:14:05,480
entropy pool of 4k size it's

00:14:03,319 --> 00:14:08,720
functionalities like at each interrupt

00:14:05,480 --> 00:14:11,870
the pseudo TA formulates a bite from LS

00:14:08,720 --> 00:14:14,420
piece of thermal sensor and entropy pool

00:14:11,870 --> 00:14:17,449
is used to collect these bytes that is

00:14:14,420 --> 00:14:19,459
all done in the backend and unser pool

00:14:17,449 --> 00:14:23,209
is full on the interrupts are disabled

00:14:19,459 --> 00:14:25,550
with every Interop with every request

00:14:23,209 --> 00:14:27,230
these are enabled again so you could see

00:14:25,550 --> 00:14:29,180
you could say that when you have

00:14:27,230 --> 00:14:31,639
requested it provides you the available

00:14:29,180 --> 00:14:36,110
bytes and starts the interrupts in the

00:14:31,639 --> 00:14:39,860
backend so now coming on to the details

00:14:36,110 --> 00:14:42,620
of this SMC interface which we already

00:14:39,860 --> 00:14:44,990
talked about so here it could see this

00:14:42,620 --> 00:14:45,529
is a normal world rival and this is the

00:14:44,990 --> 00:14:48,680
sick

00:14:45,529 --> 00:14:51,079
rng service that is as a trusted

00:14:48,680 --> 00:14:53,060
application so on the normal world side

00:14:51,079 --> 00:14:56,959
we have this non secured shared memory

00:14:53,060 --> 00:15:00,410
that is 40 size and on the secure

00:14:56,959 --> 00:15:03,079
website this entropy pool now with the

00:15:00,410 --> 00:15:07,819
first command it opens a session with

00:15:03,079 --> 00:15:10,579
the rng tea and then you know say if it

00:15:07,819 --> 00:15:14,059
requests and bites off rng data and

00:15:10,579 --> 00:15:16,550
suppose if on the secure side we have a

00:15:14,059 --> 00:15:19,930
bytes of data which is less than

00:15:16,550 --> 00:15:23,360
requested so it returns a byte and

00:15:19,930 --> 00:15:26,600
enables timer f IQ to collect the

00:15:23,360 --> 00:15:28,610
entropy in the backend so in the

00:15:26,600 --> 00:15:31,370
meantime the normal world can do any

00:15:28,610 --> 00:15:34,550
useful work for this remaining time

00:15:31,370 --> 00:15:38,990
frame and request again to get after

00:15:34,550 --> 00:15:41,240
this particular time as it knows to get

00:15:38,990 --> 00:15:44,120
the remaining bytes so it returns the

00:15:41,240 --> 00:15:47,120
remaining bytes and this time our f IQ

00:15:44,120 --> 00:15:51,079
keeps on running until the entropy pool

00:15:47,120 --> 00:15:53,240
is full and it disabled then it closes

00:15:51,079 --> 00:15:57,199
this session with our engineer so this

00:15:53,240 --> 00:16:00,379
is how the SMC interface looks like so

00:15:57,199 --> 00:16:04,160
this design is a preliminary one so it

00:16:00,379 --> 00:16:08,209
may need some review to make it fully

00:16:04,160 --> 00:16:11,209
generic and also we are open that if

00:16:08,209 --> 00:16:13,160
there is any competing interfaces that

00:16:11,209 --> 00:16:19,160
which we are happy to review that also

00:16:13,160 --> 00:16:22,430
yeah you could say it's a fork a pool so

00:16:19,160 --> 00:16:28,579
2 milliseconds per byte so 4 into 2 that

00:16:22,430 --> 00:16:32,600
would be 8k milliseconds is there a

00:16:28,579 --> 00:16:36,079
global platform API for doing random

00:16:32,600 --> 00:16:41,360
number generation actually there is an

00:16:36,079 --> 00:16:43,970
internally yes ok yeah so do you think

00:16:41,360 --> 00:16:46,999
we could implement that API actually

00:16:43,970 --> 00:16:51,889
it's an internal API global platform

00:16:46,999 --> 00:16:54,500
internal API to fetch that parent us so

00:16:51,889 --> 00:16:56,829
this is the underline implementation we

00:16:54,500 --> 00:16:56,829
are trying

00:16:57,949 --> 00:17:04,860
so coming on to the use cases so this

00:17:01,920 --> 00:17:08,730
was the first one which we implemented

00:17:04,860 --> 00:17:10,980
so this is the via SMC interface this

00:17:08,730 --> 00:17:11,579
rng service also available to the tee

00:17:10,980 --> 00:17:14,880
driver

00:17:11,579 --> 00:17:17,789
so using this kernel internal tee

00:17:14,880 --> 00:17:20,269
interface that was posted by Jen's in

00:17:17,789 --> 00:17:24,839
the upstream so we emulated this

00:17:20,269 --> 00:17:28,519
hardware random device in the Linux to

00:17:24,839 --> 00:17:31,769
fetch this random numbers from this

00:17:28,519 --> 00:17:34,620
service and this rng daemon in the user

00:17:31,769 --> 00:17:37,639
space that fetches this entropy from

00:17:34,620 --> 00:17:40,799
this device and does this Phipps checks

00:17:37,639 --> 00:17:42,990
before adding entropy to the kernel

00:17:40,799 --> 00:17:45,120
entropy pools so this is the daemon

00:17:42,990 --> 00:17:47,490
which is running in the user space it

00:17:45,120 --> 00:17:52,980
keeps on fetching entropy and adding

00:17:47,490 --> 00:17:55,470
this and does this fits checks now these

00:17:52,980 --> 00:17:57,840
are the results for the RNG test on this

00:17:55,470 --> 00:18:01,110
kernel entropy pool as you could see

00:17:57,840 --> 00:18:04,230
these are 100% success ratio as the

00:18:01,110 --> 00:18:08,730
fifth checks has already been performed

00:18:04,230 --> 00:18:10,500
on this entropy pool but here you could

00:18:08,730 --> 00:18:13,019
see there is significant drop in the

00:18:10,500 --> 00:18:15,029
performance due to the kernel stack and

00:18:13,019 --> 00:18:17,580
the fifth checks that are already

00:18:15,029 --> 00:18:24,809
performed and they might be discarded

00:18:17,580 --> 00:18:29,340
entropy due to that moving to the next

00:18:24,809 --> 00:18:32,730
use case that is during boot in euphy so

00:18:29,340 --> 00:18:35,669
we we saw that there are use cases

00:18:32,730 --> 00:18:37,950
during you feel like TSL are and also

00:18:35,669 --> 00:18:41,340
the kernel entropy pool needs to be

00:18:37,950 --> 00:18:45,419
initialized during boot so we thought of

00:18:41,340 --> 00:18:49,080
writing and opti library in UEFI to use

00:18:45,419 --> 00:18:52,590
this same SMC interface and fetch this

00:18:49,080 --> 00:18:54,630
random seed and provide it as to the ksl

00:18:52,590 --> 00:18:57,659
of feature and also initialize this

00:18:54,630 --> 00:19:02,100
kernel entropy pose during boot though

00:18:57,659 --> 00:19:04,620
this or the second use case so the next

00:19:02,100 --> 00:19:07,950
steps to this thing as I already said

00:19:04,620 --> 00:19:08,830
that there are chances of this whitening

00:19:07,950 --> 00:19:12,340
algorithm

00:19:08,830 --> 00:19:15,250
to be improved or further to improve

00:19:12,340 --> 00:19:18,070
this RNG collection and work towards

00:19:15,250 --> 00:19:22,360
this generic orangey interface to secure

00:19:18,070 --> 00:19:25,299
world as there might be other platforms

00:19:22,360 --> 00:19:27,700
which have this fast and slow entropy

00:19:25,299 --> 00:19:31,210
pools and they may may or may not

00:19:27,700 --> 00:19:33,309
require this interrupts as it so we are

00:19:31,210 --> 00:19:36,039
working on this engine to make it there

00:19:33,309 --> 00:19:40,929
is a generic one and then upstream the

00:19:36,039 --> 00:19:52,269
striker and Linux so that's all from and

00:19:40,929 --> 00:19:54,399
any questions yeah yes so what the

00:19:52,269 --> 00:19:57,610
kernel does with the entropy pool is it

00:19:54,399 --> 00:20:01,750
also saves and restores it to disk

00:19:57,610 --> 00:20:04,659
typically at reboot actually kernel as

00:20:01,750 --> 00:20:08,110
entropy pool size and I don't remember

00:20:04,659 --> 00:20:11,049
the exact size so it it keeps on feeling

00:20:08,110 --> 00:20:14,470
that control people yeah I mean it feels

00:20:11,049 --> 00:20:18,580
that anthro people from interrupt this

00:20:14,470 --> 00:20:20,590
kind of stuff what you could do is like

00:20:18,580 --> 00:20:23,139
now I know that we just happen to know

00:20:20,590 --> 00:20:26,159
that yawns and those guys have

00:20:23,139 --> 00:20:33,130
implemented or p.m. be handling in

00:20:26,159 --> 00:20:35,590
compiled in ta in opti that means it can

00:20:33,130 --> 00:20:39,370
read rpm be before the system boots

00:20:35,590 --> 00:20:42,370
already in UEFI or you booboo so if you

00:20:39,370 --> 00:20:44,590
could store your entropy pool in or PMP

00:20:42,370 --> 00:20:46,840
that could read that up and be and also

00:20:44,590 --> 00:20:48,789
Linux could awesome back to the TA to

00:20:46,840 --> 00:20:51,279
write it in tortilla or PMP when you

00:20:48,789 --> 00:20:52,899
shall talk that looks a good use case I

00:20:51,279 --> 00:20:55,230
think we could accumulate this rather

00:20:52,899 --> 00:20:58,570
than this 4k entropy pool we could

00:20:55,230 --> 00:21:00,760
extend this to the secure storage in

00:20:58,570 --> 00:21:04,210
opti yeah you should definitely mix in

00:21:00,760 --> 00:21:05,980
that but just that's just applicable on

00:21:04,210 --> 00:21:08,679
the very first boot on the factory line

00:21:05,980 --> 00:21:12,460
or something well done you could better

00:21:08,679 --> 00:21:15,610
run through people from there yeah so

00:21:12,460 --> 00:21:21,310
the interfaces you use to

00:21:15,610 --> 00:21:23,320
in DTA work with the timer and when she

00:21:21,310 --> 00:21:27,010
interrupts that those are like standards

00:21:23,320 --> 00:21:29,380
up T or ta yeah interfaces yeah

00:21:27,010 --> 00:21:31,420
in not trusted OS has the secure

00:21:29,380 --> 00:21:35,230
interrupt interfaces that dark hole has

00:21:31,420 --> 00:21:38,440
fi cues they mentioned they ended this

00:21:35,230 --> 00:21:41,970
IR cues also that are foreign interrupts

00:21:38,440 --> 00:21:47,590
so this have interfaces for the self IQs

00:21:41,970 --> 00:21:50,290
I have a question mr. officer me so she

00:21:47,590 --> 00:21:51,970
fell does anybody have any significant

00:21:50,290 --> 00:21:54,160
experience of whitening in the audience

00:21:51,970 --> 00:21:57,670
because if you were really paying

00:21:54,160 --> 00:22:00,490
attention to our CRC algorithm the CRC

00:21:57,670 --> 00:22:03,220
is is too effective at whitening in the

00:22:00,490 --> 00:22:06,400
sense that submit just told you we had a

00:22:03,220 --> 00:22:09,400
biased high order bit and we ran through

00:22:06,400 --> 00:22:10,570
a 32 bit of 32 bit conversion and at

00:22:09,400 --> 00:22:14,050
that point we could no longer

00:22:10,570 --> 00:22:16,870
discriminate the output from true

00:22:14,050 --> 00:22:18,780
randomness in other words our defibs

00:22:16,870 --> 00:22:20,920
tests are not sophisticated enough to

00:22:18,780 --> 00:22:22,120
recognize that we've actually got a

00:22:20,920 --> 00:22:23,650
buyer slight buyers in Marseilles

00:22:22,120 --> 00:22:27,310
steamer values like some of them

00:22:23,650 --> 00:22:28,540
unreachable but it's not it's able to

00:22:27,310 --> 00:22:30,400
pass the fit so the reason we switched

00:22:28,540 --> 00:22:32,860
those five points is because we at least

00:22:30,400 --> 00:22:33,910
know that's not mathematically broken we

00:22:32,860 --> 00:22:35,320
know that the four byte one is

00:22:33,910 --> 00:22:37,120
mathematically broken so we switch to

00:22:35,320 --> 00:22:39,400
five rights but we still have this

00:22:37,120 --> 00:22:41,650
problem at the CRC algorithm is so good

00:22:39,400 --> 00:22:43,150
at the bit mixing that it's still able

00:22:41,650 --> 00:22:45,370
to deceive all the randomness checks

00:22:43,150 --> 00:22:47,020
with tests to be thrown at it so we kind

00:22:45,370 --> 00:22:50,500
of have to stop a work at this point

00:22:47,020 --> 00:22:53,020
unless we can find a way to do better

00:22:50,500 --> 00:22:57,550
proofs that the whitener is it's not

00:22:53,020 --> 00:22:59,500
tricking it well if you take a 32-bit

00:22:57,550 --> 00:23:01,600
value with the bias in it and map it to

00:22:59,500 --> 00:23:04,780
another 32-bit value you don't increase

00:23:01,600 --> 00:23:05,860
the entropy yet it's now passing all the

00:23:04,780 --> 00:23:10,990
fitness tests that it wasn't passing

00:23:05,860 --> 00:23:12,280
before so we were now struggling to to

00:23:10,990 --> 00:23:14,380
work out with a wish to five by six

00:23:12,280 --> 00:23:16,120
point seven bytes you know we know

00:23:14,380 --> 00:23:18,370
there's a boys in the four will buy

00:23:16,120 --> 00:23:21,120
version but we haven't found a test to

00:23:18,370 --> 00:23:21,120
detect the bias

00:23:22,140 --> 00:23:32,030
so anybody okay okay thank you

00:23:29,570 --> 00:23:37,039
[Applause]

00:23:32,030 --> 00:23:37,039

YouTube URL: https://www.youtube.com/watch?v=DCGaUsTsmpA


