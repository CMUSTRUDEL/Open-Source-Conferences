Title: YVR18-216:The end of time, 19 years to go
Publication date: 2018-09-28
Playlist: Linaro Connect Vancouver 2018
Description: 
	Software that uses a 32-bit integer to represent seconds since the Unix epoch of Jan 1 1970 is affected by that variable overflowing on Jan 19 2038, often in a catastrophic way. Aside from most 32-bit binaries that use timestamps, this includes file systems (e.g. ext3 or xfs), file formats (e.g. cpio, utmp, core dumps), network protocols (e.g. nfs) and even hardware (e.g. real-time clocks or SCSI adapters).

Work has been going on to avoid that overflow in the Linux kernel, with hundreds of patches reworking drivers, file systems and the user space interfaces including over 50 affected system calls.

With much of this activity getting done during 2018, it's time to give an update on what has been achieved in the kernel, what parts still remain to be solved, and how we will proceed to solve this in user space, and how to use the work in long-living product deployments.
Captions: 
	00:00:02,120 --> 00:00:07,130
[Music]

00:00:08,120 --> 00:00:13,620
hello and welcome to my presentation

00:00:09,809 --> 00:00:16,170
about the year 2038 problem

00:00:13,620 --> 00:00:18,150
my name is art Bergman I've been working

00:00:16,170 --> 00:00:21,720
on this with a couple of other folks for

00:00:18,150 --> 00:00:25,800
the past five years and I'm going to

00:00:21,720 --> 00:00:30,000
give you an update where we are so who

00:00:25,800 --> 00:00:33,120
of you hasn't heard about what the

00:00:30,000 --> 00:00:36,239
problem is about in detail so I have a I

00:00:33,120 --> 00:00:38,730
can give you some more background you'll

00:00:36,239 --> 00:00:43,140
know what it's about so on skip over

00:00:38,730 --> 00:00:45,780
this briefly so as you all know time T

00:00:43,140 --> 00:00:49,410
is the type that we have in UNIX and

00:00:45,780 --> 00:00:53,670
Linux and if it started to bit wide it

00:00:49,410 --> 00:00:56,010
will overflow and the fix that we're

00:00:53,670 --> 00:00:57,899
implementing basically everywhere is to

00:00:56,010 --> 00:01:01,969
make it 64-bit wide so it will not

00:00:57,899 --> 00:01:04,469
overflow until the end of the universe

00:01:01,969 --> 00:01:06,420
why do we still care about this that's

00:01:04,469 --> 00:01:09,149
the big question because a lot of people

00:01:06,420 --> 00:01:11,700
think well who cares about 32-bit

00:01:09,149 --> 00:01:14,179
anymore we're all making stupid hardware

00:01:11,700 --> 00:01:18,329
everybody's running third

00:01:14,179 --> 00:01:20,399
everybody's running 64-bit Connors on

00:01:18,329 --> 00:01:23,609
64-bit hardware these days that's all

00:01:20,399 --> 00:01:26,279
that people make but if you look at what

00:01:23,609 --> 00:01:29,039
we're currently maintaining like we have

00:01:26,279 --> 00:01:30,899
five times as many platforms that are

00:01:29,039 --> 00:01:34,380
32-bit in the kernel that are currently

00:01:30,899 --> 00:01:37,139
maintained and even the new platforms

00:01:34,380 --> 00:01:38,459
that were merging into the kernel as an

00:01:37,139 --> 00:01:43,349
enormous achievement Haina

00:01:38,459 --> 00:01:44,700
we I see that the number of new 32-bit

00:01:43,349 --> 00:01:46,560
platforms that are emerging into the

00:01:44,700 --> 00:01:49,229
kernel is twice as high as the number of

00:01:46,560 --> 00:01:50,999
64-bit kernels every single release and

00:01:49,229 --> 00:01:52,319
it's been like that for a number of

00:01:50,999 --> 00:01:54,989
years I don't expect that to change

00:01:52,319 --> 00:01:58,829
anytime soon so we're still adding many

00:01:54,989 --> 00:02:00,479
new 32-bit hardware platforms and then

00:01:58,829 --> 00:02:02,340
of course you might ask are those

00:02:00,479 --> 00:02:04,049
actually going to be around 20 years

00:02:02,340 --> 00:02:05,530
from now because a lot of hardware is

00:02:04,049 --> 00:02:07,960
not going to be around

00:02:05,530 --> 00:02:11,200
hardware as lifetime of two three four

00:02:07,960 --> 00:02:13,060
years before it's discarded but there

00:02:11,200 --> 00:02:15,700
are certain things like the Lego

00:02:13,060 --> 00:02:17,730
Mindstorms are I don't know I think this

00:02:15,700 --> 00:02:19,959
model is something like 10 years old

00:02:17,730 --> 00:02:24,970
kids will be playing with the same thing

00:02:19,959 --> 00:02:26,709
in 20 years because I have the the Legos

00:02:24,970 --> 00:02:28,800
that my kids have are 30 years old I'm

00:02:26,709 --> 00:02:30,790
still playing with it why shouldn't they

00:02:28,800 --> 00:02:32,500
another platform that we have in the

00:02:30,790 --> 00:02:35,520
kernel

00:02:32,500 --> 00:02:37,900
they leap here Industrial machines

00:02:35,520 --> 00:02:40,750
cranes and all those those have an

00:02:37,900 --> 00:02:45,220
incredibly long life and those are

00:02:40,750 --> 00:02:49,209
running 32-bit cronuts and cars we get

00:02:45,220 --> 00:02:53,170
an increasing number of cars running

00:02:49,209 --> 00:02:55,510
Linux somewhere and people keep driving

00:02:53,170 --> 00:02:56,650
them if they don't break a lot of people

00:02:55,510 --> 00:02:58,269
get rid of their cars after five years

00:02:56,650 --> 00:03:01,569
some people like to drive the same car

00:02:58,269 --> 00:03:03,610
for 20 years or 30 years and then some

00:03:01,569 --> 00:03:10,900
things last even longer and you might

00:03:03,610 --> 00:03:12,760
have some 18 bit machines in 2038 so

00:03:10,900 --> 00:03:15,790
what happens when you're building a

00:03:12,760 --> 00:03:18,489
deeply embedded industrial machine by

00:03:15,790 --> 00:03:22,000
the time something gets into customers

00:03:18,489 --> 00:03:25,390
hands when you buy a 20 million dollar

00:03:22,000 --> 00:03:27,280
wind turbine it might already be running

00:03:25,390 --> 00:03:28,720
a ten-year-old car nilin not that's not

00:03:27,280 --> 00:03:30,459
because people were doing anything wrong

00:03:28,720 --> 00:03:32,230
because they didn't know better it's

00:03:30,459 --> 00:03:34,000
just that it takes a long time to get

00:03:32,230 --> 00:03:36,190
things into production and then you

00:03:34,000 --> 00:03:39,730
don't change them as much and then you

00:03:36,190 --> 00:03:42,820
expect them to run for 20 years so in a

00:03:39,730 --> 00:03:44,829
certain sense there are already a lot of

00:03:42,820 --> 00:03:46,600
things in the field that we will have to

00:03:44,829 --> 00:03:48,370
deal with over the next 20 years that

00:03:46,600 --> 00:03:52,420
people are not planning to fix

00:03:48,370 --> 00:03:56,590
immediately and the sooner we can fix it

00:03:52,420 --> 00:03:58,709
the fewer problems there will be another

00:03:56,590 --> 00:04:02,200
completely different area of problems is

00:03:58,709 --> 00:04:03,340
32-bit user space running on modern

00:04:02,200 --> 00:04:05,290
machines that could be legacy

00:04:03,340 --> 00:04:06,609
applications where someone lost the

00:04:05,290 --> 00:04:09,299
source code the application is still

00:04:06,609 --> 00:04:15,250
doing mission-critical work it could be

00:04:09,299 --> 00:04:16,870
that you have a CPU with 64 bits and you

00:04:15,250 --> 00:04:18,340
don't have a lot of memory so you try to

00:04:16,870 --> 00:04:20,859
make as small as possible

00:04:18,340 --> 00:04:22,270
and running 32-bit code helps but then

00:04:20,859 --> 00:04:24,760
if you're running 32-bit user space you

00:04:22,270 --> 00:04:27,970
have exactly the same problems to deal

00:04:24,760 --> 00:04:29,830
with that we have on 32-bit whole

00:04:27,970 --> 00:04:34,090
systems with 2 bit kernels enter into

00:04:29,830 --> 00:04:37,180
good user space and there are some

00:04:34,090 --> 00:04:39,729
distros that just don't exist in 64-bit

00:04:37,180 --> 00:04:41,979
so for pa-risc for example everybody

00:04:39,729 --> 00:04:43,530
uses 32-bit user space other

00:04:41,979 --> 00:04:47,650
architectures have gone away from that

00:04:43,530 --> 00:04:53,530
raspbian still uses that and then one

00:04:47,650 --> 00:04:57,250
more thing is interfaces that are not

00:04:53,530 --> 00:05:01,870
depending on the CPU word size so we

00:04:57,250 --> 00:05:04,960
have PCI devices that have a register

00:05:01,870 --> 00:05:07,450
32-bit register to store timestamp into

00:05:04,960 --> 00:05:09,789
when you boot up start the driver you

00:05:07,450 --> 00:05:14,020
put a timestamp into the driver and then

00:05:09,789 --> 00:05:16,419
it records events in some internal

00:05:14,020 --> 00:05:18,490
storage with their timestamp and it will

00:05:16,419 --> 00:05:19,990
overflow if it's 32-bit wide and we

00:05:18,490 --> 00:05:23,979
still keep adding new drivers like this

00:05:19,990 --> 00:05:25,389
so yeah I have this example of PTP

00:05:23,979 --> 00:05:29,020
network driver that was recently added

00:05:25,389 --> 00:05:32,200
so we are now calling functions to get

00:05:29,020 --> 00:05:34,870
64-bit timestamps and we just truncate

00:05:32,200 --> 00:05:38,110
them to 32-bit in a lot of cases we're

00:05:34,870 --> 00:05:40,270
lucky in those that we can treat the

00:05:38,110 --> 00:05:44,650
numbers as unsigned integers unsigned

00:05:40,270 --> 00:05:48,160
integers if you store a number of

00:05:44,650 --> 00:05:51,039
seconds in them and 32-bit rather than

00:05:48,160 --> 00:05:54,580
having 68 years from the zero time we

00:05:51,039 --> 00:05:57,039
have a hundred and thirty six years so

00:05:54,580 --> 00:05:59,680
those are good until the year 2000 106

00:05:57,039 --> 00:06:02,710
unless someone has a bug in there and

00:05:59,680 --> 00:06:05,889
that's true for a lot of these things so

00:06:02,710 --> 00:06:07,840
real-time clocks there we found tons of

00:06:05,889 --> 00:06:09,789
different ones different interface

00:06:07,840 --> 00:06:14,370
different ways of storing the time but a

00:06:09,789 --> 00:06:18,190
lot of them will overflow in 2106

00:06:14,370 --> 00:06:21,430
and then file systems is a very

00:06:18,190 --> 00:06:26,469
important thing so except for example XT

00:06:21,430 --> 00:06:28,270
3 or xf s still do not have time stems

00:06:26,469 --> 00:06:30,260
wider than 32-bit and they are

00:06:28,270 --> 00:06:32,750
explicitly signed

00:06:30,260 --> 00:06:34,510
intentionally so they will overflow in

00:06:32,750 --> 00:06:37,880
00:06:34,510 --> 00:06:41,150
and we will not be able to make them

00:06:37,880 --> 00:06:45,320
unsigned so in case of XFS the solution

00:06:41,150 --> 00:06:48,170
is we have to add additional fields to

00:06:45,320 --> 00:06:50,390
store more bits per time stem and in

00:06:48,170 --> 00:06:52,520
case of xt3 there are answers to move to

00:06:50,390 --> 00:06:54,620
xt for which has fixed this but this

00:06:52,520 --> 00:06:58,150
since we have two copies of that time of

00:06:54,620 --> 00:07:02,480
the source code only the newer one

00:06:58,150 --> 00:07:04,100
implemented the new feature and then we

00:07:02,480 --> 00:07:04,730
have user space file formats and they're

00:07:04,100 --> 00:07:06,710
everywhere

00:07:04,730 --> 00:07:08,990
so these are just two examples that i've

00:07:06,710 --> 00:07:11,510
come across this cpio

00:07:08,990 --> 00:07:13,420
which we happen to use for inner drum of

00:07:11,510 --> 00:07:16,550
s and the kernel but it's also used for

00:07:13,420 --> 00:07:20,780
rpm for instance in method based Astros

00:07:16,550 --> 00:07:23,420
and we have the U TMP file format that

00:07:20,780 --> 00:07:27,260
is used by G Lib C to store information

00:07:23,420 --> 00:07:29,360
about who's logged in and those whose

00:07:27,260 --> 00:07:32,180
32-bit timestamps and I'm sure there

00:07:29,360 --> 00:07:35,930
will be others that we find as soon as

00:07:32,180 --> 00:07:38,090
we get there in user space and look at

00:07:35,930 --> 00:07:42,650
all the problems there so far my work

00:07:38,090 --> 00:07:45,710
has been on the kernel so when do we

00:07:42,650 --> 00:07:47,210
start I actually looked at this a number

00:07:45,710 --> 00:07:50,090
of years ago this is the first pitch

00:07:47,210 --> 00:07:53,900
that went into the kernel John over

00:07:50,090 --> 00:07:57,020
there made that in 2014 so that's been

00:07:53,900 --> 00:07:59,960
over four years ago that's when things

00:07:57,020 --> 00:08:02,150
really started rolling how we fix it in

00:07:59,960 --> 00:08:04,910
the kernel we introduced a 64-bit time

00:08:02,150 --> 00:08:07,520
type and started converting device

00:08:04,910 --> 00:08:13,460
drivers and anything inside of the

00:08:07,520 --> 00:08:16,490
kernel to eliminate the 32-bit types we

00:08:13,460 --> 00:08:19,640
have found most device drivers using

00:08:16,490 --> 00:08:22,940
those types literally hundreds of

00:08:19,640 --> 00:08:25,310
patches for device drivers have had good

00:08:22,940 --> 00:08:28,150
help from interns and through the

00:08:25,310 --> 00:08:31,730
outreach program we've used it as a

00:08:28,150 --> 00:08:33,760
startup task for getting new

00:08:31,730 --> 00:08:36,169
[Music]

00:08:33,760 --> 00:08:37,729
assignees unbothered in talena are also

00:08:36,169 --> 00:08:40,820
we get a lot of assignments that don't

00:08:37,729 --> 00:08:43,370
have exposure to the open source process

00:08:40,820 --> 00:08:44,899
so we use that as something where it

00:08:43,370 --> 00:08:46,910
could easily find the driver that is

00:08:44,899 --> 00:08:48,709
known to be broken that's obvious how to

00:08:46,910 --> 00:08:50,199
patch it and then you have to convince

00:08:48,709 --> 00:08:52,490
the maintainer to take a patch for it

00:08:50,199 --> 00:08:54,589
which happened to be a really good start

00:08:52,490 --> 00:08:56,600
at task but at the rate we're doing we

00:08:54,589 --> 00:08:58,279
were doing it we weren't actually making

00:08:56,600 --> 00:09:05,240
a lot of progress getting through the

00:08:58,279 --> 00:09:07,820
hundreds of drivers and then the car

00:09:05,240 --> 00:09:09,560
time timekeeping code that's the the one

00:09:07,820 --> 00:09:12,380
that John was most involved with that

00:09:09,560 --> 00:09:13,850
has actually been done mostly for a

00:09:12,380 --> 00:09:16,160
couple of years there's still some

00:09:13,850 --> 00:09:18,889
corner cases that we have to clean up

00:09:16,160 --> 00:09:21,529
after the last user of some interface is

00:09:18,889 --> 00:09:24,290
gone and the file system code is that's

00:09:21,529 --> 00:09:26,570
the one that I started working on I

00:09:24,290 --> 00:09:31,250
think it was around 2012 and I've posted

00:09:26,570 --> 00:09:34,459
Petrus in 2014 I handed it off to Deepa

00:09:31,250 --> 00:09:36,740
who was an intern throughout Ricci for

00:09:34,459 --> 00:09:39,190
me a couple of years ago and then she

00:09:36,740 --> 00:09:43,339
worked on that a couple of years ago and

00:09:39,190 --> 00:09:45,860
she finally got it into I think the 4.17

00:09:43,339 --> 00:09:49,220
release which is when Lina's merged

00:09:45,860 --> 00:09:52,670
those patches so it's really been six

00:09:49,220 --> 00:09:54,589
years working on on this patch set and

00:09:52,670 --> 00:10:00,079
then the system calls

00:09:54,589 --> 00:10:03,290
that's the Wow the other really big area

00:10:00,079 --> 00:10:05,209
aside from the file systems and we're in

00:10:03,290 --> 00:10:09,319
the process of completing that at the

00:10:05,209 --> 00:10:10,810
moment I'll get to that later so what do

00:10:09,319 --> 00:10:13,790
we do

00:10:10,810 --> 00:10:15,980
so anything that uses a time T in the

00:10:13,790 --> 00:10:18,110
kernel we try to find a better type for

00:10:15,980 --> 00:10:20,959
it the easiest conversion would always

00:10:18,110 --> 00:10:25,310
have been to use a 64-bit time 6040

00:10:20,959 --> 00:10:27,139
that's the one that Rana introduced but

00:10:25,310 --> 00:10:28,760
we also tried when we fixed those

00:10:27,139 --> 00:10:32,029
drivers we try to clean up the current

00:10:28,760 --> 00:10:35,720
and make it better in other ways for

00:10:32,029 --> 00:10:38,630
instance a lot of device drivers just

00:10:35,720 --> 00:10:40,850
used to get time of day function to get

00:10:38,630 --> 00:10:44,800
a microsecond

00:10:40,850 --> 00:10:50,089
see value representing the current time

00:10:44,800 --> 00:10:52,759
in terms of UTC and then taking like

00:10:50,089 --> 00:10:55,279
measuring elapse time with that is

00:10:52,759 --> 00:10:57,019
actually a really bad idea especially if

00:10:55,279 --> 00:10:58,370
you're trying to measure small amounts

00:10:57,019 --> 00:10:59,990
of time first of all you always have to

00:10:58,370 --> 00:11:02,149
convert nanoseconds which the current

00:10:59,990 --> 00:11:03,800
timekeeping code uses into microseconds

00:11:02,149 --> 00:11:08,089
if you're using and then you have to

00:11:03,800 --> 00:11:11,269
calculate the time well into a whole

00:11:08,089 --> 00:11:13,430
number of microseconds and then it

00:11:11,269 --> 00:11:16,759
changes if somebody calls set time of

00:11:13,430 --> 00:11:21,649
day or if you have the NTP protocol and

00:11:16,759 --> 00:11:23,660
use to update the the rate that time is

00:11:21,649 --> 00:11:26,290
moving it

00:11:23,660 --> 00:11:29,149
it could also jump and then you have

00:11:26,290 --> 00:11:33,069
something called leap seconds that most

00:11:29,149 --> 00:11:33,069
of all most of you probably heard about

00:11:35,019 --> 00:11:45,079
John has particular experience with that

00:11:39,490 --> 00:11:47,990
and the best way to deal with it is just

00:11:45,079 --> 00:11:49,819
not to use clock real time but use clock

00:11:47,990 --> 00:11:51,769
magnetronic one of the other time basis

00:11:49,819 --> 00:11:53,389
that are completely independent of the

00:11:51,769 --> 00:11:57,860
current time just starts counting when

00:11:53,389 --> 00:12:00,620
you boot the system and then keeps

00:11:57,860 --> 00:12:05,120
counting monotonically as the name says

00:12:00,620 --> 00:12:08,389
in nanoseconds so a lot of drivers where

00:12:05,120 --> 00:12:12,009
we changed the way from time T or time

00:12:08,389 --> 00:12:14,750
Val or time spec we ended up using

00:12:12,009 --> 00:12:17,829
monotonic time as well which fixed other

00:12:14,750 --> 00:12:17,829
problems in the process

00:12:19,740 --> 00:12:26,850
another area is the IO controls that's

00:12:23,490 --> 00:12:31,380
the interface between a device driver

00:12:26,850 --> 00:12:33,570
and user space these are commands like

00:12:31,380 --> 00:12:35,520
on the system call level you set you

00:12:33,570 --> 00:12:37,950
call the IO control system call you pass

00:12:35,520 --> 00:12:42,270
a command number pass an argument as a

00:12:37,950 --> 00:12:47,540
pointer usually the command number in

00:12:42,270 --> 00:12:54,060
most cases encodes the type of argument

00:12:47,540 --> 00:13:01,950
by taking the size of it so you have an

00:12:54,060 --> 00:13:04,290
i/o control command that is defined by a

00:13:01,950 --> 00:13:09,050
subsystem identifier a number for the

00:13:04,290 --> 00:13:13,440
command and the size of the argument and

00:13:09,050 --> 00:13:15,510
if we pass for instance a time spec the

00:13:13,440 --> 00:13:18,030
argument length may be either 8 bytes on

00:13:15,510 --> 00:13:21,120
the 32-bit system or 16 bytes on a

00:13:18,030 --> 00:13:23,010
64-bit system and if we fix user space

00:13:21,120 --> 00:13:31,320
to use the 64-bit time T then it will

00:13:23,010 --> 00:13:34,530
also be 16 bytes long so one patch that

00:13:31,320 --> 00:13:45,080
we merged I think this is one that Balan

00:13:34,530 --> 00:13:49,010
did this so instead of handling the

00:13:45,080 --> 00:13:52,860
instead of handling the native command

00:13:49,010 --> 00:13:55,020
we handle a two 32-bit command and a

00:13:52,860 --> 00:13:57,180
64-bit command in the i/o control

00:13:55,020 --> 00:14:02,840
function so the the device driver just

00:13:57,180 --> 00:14:02,840
knows about both formats and user space

00:14:03,320 --> 00:14:17,660
next so user space gets the command

00:14:09,360 --> 00:14:17,660
definition based on struct time Val and

00:14:19,340 --> 00:14:24,770
this is a different command number

00:14:21,950 --> 00:14:27,080
depending on the configuration of the c

00:14:24,770 --> 00:14:29,630
library because the time valve type is

00:14:27,080 --> 00:14:31,430
defined by the c library and when we

00:14:29,630 --> 00:14:33,860
change it to 64-bit we get a new command

00:14:31,430 --> 00:14:36,260
number so the device driver now gets

00:14:33,860 --> 00:14:37,880
changed to handle both the old command

00:14:36,260 --> 00:14:40,520
and the new command that means the

00:14:37,880 --> 00:14:42,500
device driver doesn't have to know which

00:14:40,520 --> 00:14:45,050
mode the user space is running it that's

00:14:42,500 --> 00:14:47,570
a very important concept that we don't

00:14:45,050 --> 00:14:50,300
have a new binary format the kernel

00:14:47,570 --> 00:14:53,500
treats binaries with a 64-bit time T

00:14:50,300 --> 00:14:56,360
exactly the same way as 32-bit time T

00:14:53,500 --> 00:14:58,160
except they use slightly different

00:14:56,360 --> 00:15:00,710
interfaces like a different command

00:14:58,160 --> 00:15:04,400
number file controls and this is the

00:15:00,710 --> 00:15:07,210
easy case so a harder case is the socket

00:15:04,400 --> 00:15:10,490
timestamp this is a patch that I just

00:15:07,210 --> 00:15:13,070
prepared for the current release and

00:15:10,490 --> 00:15:16,190
that I probably have to redo I'll get to

00:15:13,070 --> 00:15:18,620
that in a bit so here the command code

00:15:16,190 --> 00:15:20,750
is a really old command code that dates

00:15:18,620 --> 00:15:23,240
back to the time before we had those

00:15:20,750 --> 00:15:26,870
macros so the command code is exactly

00:15:23,240 --> 00:15:28,910
the same on old user space and a new

00:15:26,870 --> 00:15:33,430
user space independent of what the time

00:15:28,910 --> 00:15:39,290
type is the workaround that we did here

00:15:33,430 --> 00:15:45,800
makes this even more complicated so we

00:15:39,290 --> 00:15:50,150
redefine the macro depending on the size

00:15:45,800 --> 00:15:52,600
of struct I'm Val if it's 8 byte we use

00:15:50,150 --> 00:15:58,100
the old command code which is then

00:15:52,600 --> 00:16:00,980
redefined to be the old number if the

00:15:58,100 --> 00:16:03,080
size is something other than 8 byte

00:16:00,980 --> 00:16:07,360
which has to be 16 byte we use the new

00:16:03,080 --> 00:16:13,190
command code which is defined to be 2

00:16:07,360 --> 00:16:14,750
64-bit words long and then we can do the

00:16:13,190 --> 00:16:18,590
same trick in the device in the device

00:16:14,750 --> 00:16:21,260
driver and just handle both and it gets

00:16:18,590 --> 00:16:22,880
more complicated than that so if it's

00:16:21,260 --> 00:16:27,120
not an i/o control but it's a read

00:16:22,880 --> 00:16:29,250
command so the input subsystem

00:16:27,120 --> 00:16:32,430
you have a file descriptor for character

00:16:29,250 --> 00:16:35,010
device you read an input event like

00:16:32,430 --> 00:16:36,270
someone pressing the clicker someone

00:16:35,010 --> 00:16:38,250
pressing a button someone moving the

00:16:36,270 --> 00:16:39,720
mouse that's an input event each input

00:16:38,250 --> 00:16:45,529
event has a time stamp on it

00:16:39,720 --> 00:16:50,070
and this input event rabbit here it has

00:16:45,529 --> 00:16:51,210
the time valve in it traditionally so

00:16:50,070 --> 00:16:54,330
the input event structure is

00:16:51,210 --> 00:16:57,510
incompatible when you change to a new G

00:16:54,330 --> 00:17:00,180
Lipsy with a 64-bit time T you read a

00:16:57,510 --> 00:17:05,459
structure from the kernel you actually

00:17:00,180 --> 00:17:07,890
get less bytes than you expect so what

00:17:05,459 --> 00:17:10,470
we did here is we redefine the input

00:17:07,890 --> 00:17:13,829
event structure to only use time Val in

00:17:10,470 --> 00:17:17,000
the existing cases and if we have a

00:17:13,829 --> 00:17:20,550
gilepsy version that happens to use

00:17:17,000 --> 00:17:24,809
64-bit time T that's a macro we can test

00:17:20,550 --> 00:17:32,130
for then we redefine input event to use

00:17:24,809 --> 00:17:35,840
a 64-bit to use an explicit explicitly

00:17:32,130 --> 00:17:39,080
sized seconds and microseconds value

00:17:35,840 --> 00:17:41,309
that is the same size that it was before

00:17:39,080 --> 00:17:44,220
but we're not referencing time Val

00:17:41,309 --> 00:17:45,840
anymore so we're not using 64-bit times

00:17:44,220 --> 00:17:48,000
because we can't there will be a change

00:17:45,840 --> 00:17:51,030
in the binary interface but we're lucky

00:17:48,000 --> 00:17:53,790
because the timestamps are already in

00:17:51,030 --> 00:17:55,410
clock monotonic we don't need the

00:17:53,790 --> 00:17:57,059
extended range because clock monotonic

00:17:55,410 --> 00:18:00,090
as I said we have under conferred to six

00:17:57,059 --> 00:18:01,190
years after boot up and that's where we

00:18:00,090 --> 00:18:05,160
say that's enough

00:18:01,190 --> 00:18:07,230
we don't need 64-bit for that so this is

00:18:05,160 --> 00:18:09,559
a fairly ugly workaround it basically

00:18:07,230 --> 00:18:14,850
means that anything using this structure

00:18:09,559 --> 00:18:17,910
needs a code source change once you get

00:18:14,850 --> 00:18:21,240
the new header file the binary interface

00:18:17,910 --> 00:18:24,090
will remain compatible so any old

00:18:21,240 --> 00:18:27,870
binaries work and we know that there's

00:18:24,090 --> 00:18:30,179
only a few libraries that actually use

00:18:27,870 --> 00:18:33,360
this input event structure directly so

00:18:30,179 --> 00:18:36,060
usually you go through lip event and we

00:18:33,360 --> 00:18:37,620
only have to change lip event to

00:18:36,060 --> 00:18:38,740
understand the difference at all users

00:18:37,620 --> 00:18:43,149
of lip event

00:18:38,740 --> 00:18:46,990
do not have to be changed for this and

00:18:43,149 --> 00:18:50,039
it gets one level more complicated this

00:18:46,990 --> 00:18:52,029
is an example of a memory mapped

00:18:50,039 --> 00:18:54,399
structure that we have in the kernel

00:18:52,029 --> 00:19:01,240
with time stamps in it this is the one

00:18:54,399 --> 00:19:05,020
for audio timestamps the trick is very

00:19:01,240 --> 00:19:08,260
similar to what we did for the for the

00:19:05,020 --> 00:19:10,390
input event and this is not merged yet

00:19:08,260 --> 00:19:13,720
so the idea is that instead of using

00:19:10,390 --> 00:19:15,880
time spec we use a news sound monotonic

00:19:13,720 --> 00:19:17,559
timestamp we also have to change all

00:19:15,880 --> 00:19:21,159
users to use monotonic timestamps

00:19:17,559 --> 00:19:23,289
instead of real-time timestamps and then

00:19:21,159 --> 00:19:26,470
we can map this into user space again

00:19:23,289 --> 00:19:28,450
because otherwise you might have

00:19:26,470 --> 00:19:32,110
multiple users based processes mapping

00:19:28,450 --> 00:19:34,480
the same page into memory and trying to

00:19:32,110 --> 00:19:37,390
interpret the bytes in that buffer in

00:19:34,480 --> 00:19:40,450
different ways so this is the best we

00:19:37,390 --> 00:19:42,760
came up with we still have to discuss

00:19:40,450 --> 00:19:45,010
this further with the audio maintenance

00:19:42,760 --> 00:19:46,270
because they're different ideas like

00:19:45,010 --> 00:19:48,070
there there's possibly a different way

00:19:46,270 --> 00:19:52,390
of fixing this this is what we currently

00:19:48,070 --> 00:19:54,539
have this is what I said the virtual

00:19:52,390 --> 00:19:57,850
file system layer that's the work that

00:19:54,539 --> 00:19:59,919
Depot did most of the interesting parts

00:19:57,850 --> 00:20:02,500
of Dave Howells

00:19:59,919 --> 00:20:03,549
implemented the stat X system call which

00:20:02,500 --> 00:20:08,100
was very useful

00:20:03,549 --> 00:20:11,350
we have almost a dozen different

00:20:08,100 --> 00:20:13,630
implementations of the stat system call

00:20:11,350 --> 00:20:15,520
in the colonel with slightly different

00:20:13,630 --> 00:20:19,929
behavior we have else that F start we

00:20:15,520 --> 00:20:22,240
have old that new stat stat 64 and all

00:20:19,929 --> 00:20:24,480
permutations of those and the stat X

00:20:22,240 --> 00:20:27,070
system call is just a superset of the

00:20:24,480 --> 00:20:32,580
functionality and it always uses 64-bit

00:20:27,070 --> 00:20:39,549
timestamps so we're not changing gilepsy

00:20:32,580 --> 00:20:43,059
to call that X underneath and at least

00:20:39,549 --> 00:20:47,080
on new kernels and that can implement

00:20:43,059 --> 00:20:49,160
all the old stat variations that

00:20:47,080 --> 00:20:51,540
userspace uses

00:20:49,160 --> 00:20:56,040
and then we have to change all the file

00:20:51,540 --> 00:20:59,970
systems we have to like the the big

00:20:56,040 --> 00:21:04,320
change that we did was in 418 getting

00:20:59,970 --> 00:21:06,090
the virtual file system code changed but

00:21:04,320 --> 00:21:09,150
that meant that all the file systems

00:21:06,090 --> 00:21:11,700
still internally convert from 32-bit

00:21:09,150 --> 00:21:15,510
time T to 64-bit time T and we have to

00:21:11,700 --> 00:21:18,360
get rid of all those conversions this is

00:21:15,510 --> 00:21:20,669
something I did for 4.19 for almost all

00:21:18,360 --> 00:21:28,070
the file systems there's just three or

00:21:20,669 --> 00:21:28,070
four that are left with the system calls

00:21:28,340 --> 00:21:35,220
we had an interesting trick so basically

00:21:32,760 --> 00:21:37,950
we had identified around 50 system calls

00:21:35,220 --> 00:21:41,460
in the current kernel ABI

00:21:37,950 --> 00:21:44,910
that passed a time T in or out of the

00:21:41,460 --> 00:21:48,330
kernel and for each of them we have to

00:21:44,910 --> 00:21:50,700
have replacement a lot of these system

00:21:48,330 --> 00:21:53,460
calls already have a replacement so for

00:21:50,700 --> 00:21:55,530
example I mentioned the old stet system

00:21:53,460 --> 00:21:58,169
call and we already replaced it twice

00:21:55,530 --> 00:22:01,830
with new stat instead 64 so start 64 is

00:21:58,169 --> 00:22:04,730
2 and that's used and unlike the name

00:22:01,830 --> 00:22:10,710
suggests it still uses 32-bit timestamps

00:22:04,730 --> 00:22:12,929
and now we have stat X that means we can

00:22:10,710 --> 00:22:18,240
just ignore all the odds that were

00:22:12,929 --> 00:22:20,700
versions but for the ones that we do

00:22:18,240 --> 00:22:21,890
need to keep we now need to have two

00:22:20,700 --> 00:22:25,890
versions of them

00:22:21,890 --> 00:22:28,940
so for example for clock get time which

00:22:25,890 --> 00:22:32,730
is what you use to read the current time

00:22:28,940 --> 00:22:35,960
we need to keep clock at time we also

00:22:32,730 --> 00:22:39,630
need to have clock get I'm 64

00:22:35,960 --> 00:22:44,210
together in a different format and that

00:22:39,630 --> 00:22:44,210
means adding a lot of new entry points

00:22:45,590 --> 00:22:50,610
what we did instead is that we noticed

00:22:48,899 --> 00:22:53,669
that we already have two implementations

00:22:50,610 --> 00:22:57,149
of each of those there's one that is

00:22:53,669 --> 00:22:59,360
used as the native system call in each

00:22:57,149 --> 00:23:02,390
architecture and one that is used for

00:22:59,360 --> 00:23:06,390
compatibility with 32-bit user space

00:23:02,390 --> 00:23:09,720
running on 64-bit architectures so we're

00:23:06,390 --> 00:23:11,519
reusing the compact system calls so that

00:23:09,720 --> 00:23:14,000
we don't have to add a third version of

00:23:11,519 --> 00:23:17,010
each of those system calls

00:23:14,000 --> 00:23:21,960
originally this is one of the system

00:23:17,010 --> 00:23:24,539
calls in this set on a 32-bit system you

00:23:21,960 --> 00:23:26,840
have a function called sis futex which

00:23:24,539 --> 00:23:31,250
implements the futex system call on a

00:23:26,840 --> 00:23:34,139
64-bit system called system you have a

00:23:31,250 --> 00:23:36,269
system call by the same name with

00:23:34,139 --> 00:23:41,370
slightly different set of arguments

00:23:36,269 --> 00:23:43,860
because it uses a 64-bit time T and then

00:23:41,370 --> 00:23:48,120
we edit the compact version of that

00:23:43,860 --> 00:23:49,799
which you see has the same calling

00:23:48,120 --> 00:23:53,070
conventions as the native system called

00:23:49,799 --> 00:23:57,419
on a 32-bit system now we're adding the

00:23:53,070 --> 00:23:59,130
same compact system call to 32-bit

00:23:57,419 --> 00:24:03,480
systems and this is what we've been

00:23:59,130 --> 00:24:06,000
doing in 4.18 so about half the system

00:24:03,480 --> 00:24:08,549
calls that need this now we have a

00:24:06,000 --> 00:24:11,700
compact system call that you can enable

00:24:08,549 --> 00:24:13,610
on 32-bit systems and then something

00:24:11,700 --> 00:24:15,960
happened

00:24:13,610 --> 00:24:19,559
Christopher Harvick reviewed the patches

00:24:15,960 --> 00:24:21,480
and said well this is not a good idea

00:24:19,559 --> 00:24:23,399
because this is really confusing why do

00:24:21,480 --> 00:24:25,559
we have a compact system call on 32-bit

00:24:23,399 --> 00:24:27,659
when you don't have a compact layer you

00:24:25,559 --> 00:24:29,669
don't have a completely set up obviously

00:24:27,659 --> 00:24:32,340
a different set of binaries you just

00:24:29,669 --> 00:24:38,850
have another system call and that's

00:24:32,340 --> 00:24:45,570
where we renamed everything so instead

00:24:38,850 --> 00:24:47,210
of having a compact time speck in the

00:24:45,570 --> 00:24:49,740
compet futex

00:24:47,210 --> 00:24:53,130
system call we now have an old time

00:24:49,740 --> 00:24:57,860
speck 32 argument so I did a patch to

00:24:53,130 --> 00:24:57,860
change all of those data types

00:24:58,299 --> 00:25:05,570
to get rid of the company and then we we

00:25:03,529 --> 00:25:07,729
are going to rename the system calls

00:25:05,570 --> 00:25:11,239
the entry points so that the function

00:25:07,729 --> 00:25:13,999
name is just few texts I'm 32 and that

00:25:11,239 --> 00:25:20,539
will be the same name and 32 and 64-bit

00:25:13,999 --> 00:25:23,119
system calls other systems and once that

00:25:20,539 --> 00:25:27,049
is done we can change the system call

00:25:23,119 --> 00:25:31,519
tables so the the regular says few texts

00:25:27,049 --> 00:25:35,619
entry point refers to the 64-bit format

00:25:31,519 --> 00:25:39,799
and the subutex and 32 refers to the

00:25:35,619 --> 00:25:43,519
32-bit arguments and we do the exact

00:25:39,799 --> 00:25:44,749
same thing on 32 and 64-bit kernels and

00:25:43,519 --> 00:25:55,909
i think that's a very nice way of

00:25:44,749 --> 00:25:59,720
offending this right then there are the

00:25:55,909 --> 00:26:02,989
data types in user space so as I said we

00:25:59,720 --> 00:26:05,440
have time spec and time thou are typical

00:26:02,989 --> 00:26:05,440
structures

00:26:07,770 --> 00:26:18,480
in we introduced a new type Colonel time

00:26:13,140 --> 00:26:21,480
spec we just tend to use the colonel

00:26:18,480 --> 00:26:23,700
prefix in type identify us and currently

00:26:21,480 --> 00:26:26,970
had us so we don't conflict with the

00:26:23,700 --> 00:26:28,200
gilepsy types anymore like this is

00:26:26,970 --> 00:26:30,990
actually causing us a lot of problems

00:26:28,200 --> 00:26:31,559
that we have a time spec type defined in

00:26:30,990 --> 00:26:34,799
the colonel

00:26:31,559 --> 00:26:37,260
which is now different from in the in

00:26:34,799 --> 00:26:39,270
the exported user API had us that is

00:26:37,260 --> 00:26:41,549
different from the time spec definition

00:26:39,270 --> 00:26:44,340
in the gilepsy header so we're trying to

00:26:41,549 --> 00:26:46,500
get rid of the private types and there

00:26:44,340 --> 00:26:49,020
will be a there's there's a colonel time

00:26:46,500 --> 00:26:53,909
spec type in the colonel

00:26:49,020 --> 00:26:56,039
headers which use a 64 bit seconds and

00:26:53,909 --> 00:26:58,830
64 bit nanoseconds and that's what we

00:26:56,039 --> 00:27:04,039
use at the interface layer and this was

00:26:58,830 --> 00:27:07,110
something that Lynne owes really

00:27:04,039 --> 00:27:09,090
strongly argued for that we have a 64

00:27:07,110 --> 00:27:12,299
bit nanoseconds as well as 64 bit

00:27:09,090 --> 00:27:14,460
seconds because when you're copying a

00:27:12,299 --> 00:27:16,649
data structure from kernel space to user

00:27:14,460 --> 00:27:19,049
space you typically use a copy to user

00:27:16,649 --> 00:27:21,659
function which copies the entire 16

00:27:19,049 --> 00:27:26,220
bytes of that structure if we had made

00:27:21,659 --> 00:27:29,669
the nanoseconds long or explicitly

00:27:26,220 --> 00:27:30,990
32-bit which is totally enough to count

00:27:29,669 --> 00:27:34,470
the number of nanoseconds within a

00:27:30,990 --> 00:27:37,020
second we would have padding in there

00:27:34,470 --> 00:27:40,590
and copying that to user space means

00:27:37,020 --> 00:27:43,620
we're leaking data that is on the kernel

00:27:40,590 --> 00:27:46,080
stick that might be turned into an

00:27:43,620 --> 00:27:47,820
exploit from malicious user space by

00:27:46,080 --> 00:27:49,890
reading data that it should not have

00:27:47,820 --> 00:27:53,190
access to from the kernel such as the

00:27:49,890 --> 00:27:55,590
location of functions inside of the

00:27:53,190 --> 00:27:57,840
kernel if you can find the location

00:27:55,590 --> 00:28:00,510
inside of RAM that the current is I'd

00:27:57,840 --> 00:28:05,730
said that it allows you to do a number

00:28:00,510 --> 00:28:10,320
of other exploits later so using a data

00:28:05,730 --> 00:28:12,809
structure without padding helps avoid

00:28:10,320 --> 00:28:16,010
those exploits it also helps that we can

00:28:12,809 --> 00:28:19,330
share the implementation between the

00:28:16,010 --> 00:28:22,149
native 64-bit system call and

00:28:19,330 --> 00:28:24,100
the 32-bit user space running on a

00:28:22,149 --> 00:28:32,139
64-bit kernel which now has the exact

00:28:24,100 --> 00:28:33,970
same layout these are the it's all the

00:28:32,139 --> 00:28:38,440
system calls that we identified that

00:28:33,970 --> 00:28:42,100
already have a replacement a replacement

00:28:38,440 --> 00:28:45,720
that still uses 32-bit time T and we

00:28:42,100 --> 00:28:54,249
added replacements for most of these in

00:28:45,720 --> 00:28:56,739
4.18 or earlier so there are as a 4.18

00:28:54,249 --> 00:28:59,889
there are only four five system calls

00:28:56,739 --> 00:29:01,809
left that don't have replacement with

00:28:59,889 --> 00:29:06,159
64-bit time T yet

00:29:01,809 --> 00:29:09,220
and in 4.19 - most lags not just

00:29:06,159 --> 00:29:12,129
yesterday merged my patches for an

00:29:09,220 --> 00:29:17,200
additional three of them so that leaves

00:29:12,129 --> 00:29:19,419
us with a just try max and wait for this

00:29:17,200 --> 00:29:22,029
is similar set of system calls these are

00:29:19,419 --> 00:29:24,340
all the ones that we absolutely have to

00:29:22,029 --> 00:29:29,320
provide to user space because there's no

00:29:24,340 --> 00:29:31,570
other way of calling those and for each

00:29:29,320 --> 00:29:33,580
of those we have to have a direct

00:29:31,570 --> 00:29:36,609
replacement with a 64-bit argument and

00:29:33,580 --> 00:29:42,119
again about half of them we have fixed

00:29:36,609 --> 00:29:45,759
and 4.18 and another set of system calls

00:29:42,119 --> 00:29:48,340
is already merged or we have the patches

00:29:45,759 --> 00:29:51,220
I am in the process of integrating the

00:29:48,340 --> 00:29:53,350
patches from DPR for the second half of

00:29:51,220 --> 00:29:56,169
the red ones then we are left with a

00:29:53,350 --> 00:29:58,659
small set of system calls and the only

00:29:56,169 --> 00:30:01,059
one that we absolutely have to do is

00:29:58,659 --> 00:30:03,879
actually the clock at just try max clock

00:30:01,059 --> 00:30:06,340
address time all the other ones we might

00:30:03,879 --> 00:30:08,379
be able to implement on top of the

00:30:06,340 --> 00:30:11,259
32-bit argument because we're only

00:30:08,379 --> 00:30:14,200
passing relative times not absolute

00:30:11,259 --> 00:30:17,340
times so that would be a little bit ugly

00:30:14,200 --> 00:30:17,340
but it's totally doable

00:30:19,230 --> 00:30:27,250
one example where we have to come up

00:30:25,390 --> 00:30:31,210
with either conversion userspace or

00:30:27,250 --> 00:30:33,820
change the colonel is the guitar usage

00:30:31,210 --> 00:30:35,440
this uses the our usage data structure

00:30:33,820 --> 00:30:39,760
that's the same as in the wait for

00:30:35,440 --> 00:30:41,470
system call this starts with two times

00:30:39,760 --> 00:30:43,630
our members and this is actually the

00:30:41,470 --> 00:30:45,280
same structure layout across all the

00:30:43,630 --> 00:30:47,110
operating systems that have looked at

00:30:45,280 --> 00:30:52,120
that implements these system calls so if

00:30:47,110 --> 00:30:53,590
you look at any unix bsd even windows i

00:30:52,120 --> 00:30:57,670
think has an implementation of these

00:30:53,590 --> 00:31:00,690
system calls in some libraries and they

00:30:57,670 --> 00:31:04,180
all used the exact same structure layout

00:31:00,690 --> 00:31:07,240
and that means that we probably have

00:31:04,180 --> 00:31:09,010
user space code that has a copy of this

00:31:07,240 --> 00:31:13,480
data structure in their source file so

00:31:09,010 --> 00:31:15,370
even if you change the kernel had us we

00:31:13,480 --> 00:31:25,240
might get user space expecting the wrong

00:31:15,370 --> 00:31:30,280
data what we do here is again similar to

00:31:25,240 --> 00:31:32,290
what we did with the i/o controls we

00:31:30,280 --> 00:31:41,710
have a guitar usage time thirty-two

00:31:32,290 --> 00:31:45,120
system call and we changed the header so

00:31:41,710 --> 00:31:45,120
that if you are building an application

00:31:46,200 --> 00:31:54,040
that use the old types sorry that if

00:31:52,270 --> 00:31:57,730
you're building an application with

00:31:54,040 --> 00:31:59,440
64-bit time T you get the kernel old

00:31:57,730 --> 00:32:03,510
time doll type instead of the time doll

00:31:59,440 --> 00:32:03,510
type which is then 32-bit

00:32:04,400 --> 00:32:08,900
if you call this isn't call directly and

00:32:06,620 --> 00:32:10,340
gilepsy can call this and convert it

00:32:08,900 --> 00:32:16,220
into this structure which has a

00:32:10,340 --> 00:32:20,300
different layout and the other way to do

00:32:16,220 --> 00:32:23,240
it is to have the 64-bit version of that

00:32:20,300 --> 00:32:25,760
which is instead of using a time well we

00:32:23,240 --> 00:32:27,730
would use a kernel time spec that means

00:32:25,760 --> 00:32:31,150
we also get nanosecond resolution

00:32:27,730 --> 00:32:33,080
because all the interfaces that we

00:32:31,150 --> 00:32:34,520
introduced as replacements have

00:32:33,080 --> 00:32:37,370
nanosecond resolution I thought this

00:32:34,520 --> 00:32:40,070
would be nicer so that's the current

00:32:37,370 --> 00:32:43,520
plan and then we have to implement this

00:32:40,070 --> 00:32:47,990
on 32 and 64-bit architectures still

00:32:43,520 --> 00:32:49,670
using the same structure and then user

00:32:47,990 --> 00:32:52,490
space sometimes has to convert between

00:32:49,670 --> 00:32:57,530
nanoseconds and microseconds probably mg

00:32:52,490 --> 00:32:58,550
Lipsy this the time spec that I looked

00:32:57,530 --> 00:33:02,450
at earlier this is actually the

00:32:58,550 --> 00:33:05,600
definition as it would be used in G Lib

00:33:02,450 --> 00:33:09,380
C I didn't exactly copy it but this is

00:33:05,600 --> 00:33:12,500
roughly what it looks like I said that

00:33:09,380 --> 00:33:16,580
we in the kernel want to have a 64 bit

00:33:12,500 --> 00:33:19,700
nanoseconds value in user space we don't

00:33:16,580 --> 00:33:23,540
in user space we follow the C standard

00:33:19,700 --> 00:33:27,950
which says the TVN SEC member of time

00:33:23,540 --> 00:33:32,300
spec is of type long it suppose exits in

00:33:27,950 --> 00:33:34,790
c99 none of the C library maintain us

00:33:32,300 --> 00:33:36,980
wanted I divert from the standards

00:33:34,790 --> 00:33:40,550
because they implement the standards the

00:33:36,980 --> 00:33:43,070
whole point of a C library so we have to

00:33:40,550 --> 00:33:46,820
match the layout that the kernel

00:33:43,070 --> 00:33:48,370
provides and implement padding so if

00:33:46,820 --> 00:33:52,490
you're on a little endian architecture

00:33:48,370 --> 00:33:57,260
we have long we have 32-bit TVN SEC and

00:33:52,490 --> 00:33:59,390
on 32-bit we have 32-bit padding every

00:33:57,260 --> 00:34:02,059
one big onion we also have padding but

00:33:59,390 --> 00:34:04,280
instead of giving it a name we use an

00:34:02,059 --> 00:34:08,659
anonymous bit field the reason for that

00:34:04,280 --> 00:34:12,230
is that there's a lot of code that puts

00:34:08,659 --> 00:34:16,490
a time spec structure on the stack and

00:34:12,230 --> 00:34:17,090
initializes it by assigning

00:34:16,490 --> 00:34:19,070
something

00:34:17,090 --> 00:34:22,820
first member and something to the second

00:34:19,070 --> 00:34:24,830
number if we had the name petting field

00:34:22,820 --> 00:34:27,560
as the second member that would

00:34:24,830 --> 00:34:30,820
initialized the padding to the desired

00:34:27,560 --> 00:34:34,490
value and leave the nanoseconds as

00:34:30,820 --> 00:34:36,770
uninitialized we don't want that so this

00:34:34,490 --> 00:34:38,690
is probably what it will look like or

00:34:36,770 --> 00:34:46,310
something slightly more complicated than

00:34:38,690 --> 00:34:48,020
that right then we also have the time

00:34:46,310 --> 00:34:50,030
well and this is something that I only

00:34:48,020 --> 00:34:53,120
learned about last week unfortunately I

00:34:50,030 --> 00:34:58,780
was thought time law was easy because we

00:34:53,120 --> 00:35:05,900
define in the standards it's not using a

00:34:58,780 --> 00:35:12,290
long microseconds value it's using a su

00:35:05,900 --> 00:35:14,510
seconds t-type microseconds and this is

00:35:12,290 --> 00:35:17,360
defined by the kernel and I was assumed

00:35:14,510 --> 00:35:20,600
that what we defined in a sensible way

00:35:17,360 --> 00:35:24,040
but it's not there's one architecture

00:35:20,600 --> 00:35:27,830
which is sparc64 that defines it as

00:35:24,040 --> 00:35:28,760
32-bit for compatibility with even older

00:35:27,830 --> 00:35:31,730
operating systems

00:35:28,760 --> 00:35:38,570
I assume Santa wears possibly something

00:35:31,730 --> 00:35:44,350
else and that's why we now have in case

00:35:38,570 --> 00:35:46,490
of spark we have in 32-bit microseconds

00:35:44,350 --> 00:35:52,780
follow-up up heading and for everything

00:35:46,490 --> 00:35:56,900
else we have 64-bit microseconds and

00:35:52,780 --> 00:35:58,910
then we have to have the 32 and 64-bit

00:35:56,900 --> 00:36:01,850
version of that what it means for the

00:35:58,910 --> 00:36:04,970
colonel I had nicely implemented some

00:36:01,850 --> 00:36:08,870
functions that can write to either time

00:36:04,970 --> 00:36:11,840
Val or time spec and either 32 or 64-bit

00:36:08,870 --> 00:36:14,000
versions of it and run it either on

00:36:11,840 --> 00:36:17,360
32-bit or 64-bit architects and all look

00:36:14,000 --> 00:36:20,720
nice and now we have one more case

00:36:17,360 --> 00:36:23,000
because 64-bit spark time Val is

00:36:20,720 --> 00:36:24,780
different from all the others so I have

00:36:23,000 --> 00:36:33,090
to go back and rework some of my

00:36:24,780 --> 00:36:36,450
just then a little update on the sea

00:36:33,090 --> 00:36:39,140
library so we have to see libraries that

00:36:36,450 --> 00:36:41,850
have started looking into this problem

00:36:39,140 --> 00:36:44,910
once we change the kernel headers like

00:36:41,850 --> 00:36:47,580
once the API - between kernel and user

00:36:44,910 --> 00:36:50,400
space is defined we can actually get

00:36:47,580 --> 00:36:52,500
this into C libraries and dilip C of

00:36:50,400 --> 00:36:55,890
course is the most important one and we

00:36:52,500 --> 00:37:02,100
have a plan that is already a few years

00:36:55,890 --> 00:37:06,090
old that idea started working on and you

00:37:02,100 --> 00:37:09,900
can read it all at this URL what's

00:37:06,090 --> 00:37:13,740
interesting here is the C library will

00:37:09,900 --> 00:37:17,150
allow you to build an application either

00:37:13,740 --> 00:37:20,490
with 32-bit time T or 64-bit time T and

00:37:17,150 --> 00:37:23,400
it will run on old corners and new

00:37:20,490 --> 00:37:25,920
kernels so you get all the flexibility

00:37:23,400 --> 00:37:34,080
the one thing we don't allow there is to

00:37:25,920 --> 00:37:37,650
run the binary that was written with

00:37:34,080 --> 00:37:41,370
32-bit time T it may not run on a Conner

00:37:37,650 --> 00:37:44,070
that only has 64-bit time T because we

00:37:41,370 --> 00:37:47,970
explicitly disable compatibility support

00:37:44,070 --> 00:37:52,860
the idea of that is if you want to prove

00:37:47,970 --> 00:37:54,270
that your system works beyond 2038 you

00:37:52,860 --> 00:37:55,950
may want to disable all of the

00:37:54,270 --> 00:37:59,250
compatibility code that we put in for

00:37:55,950 --> 00:38:01,950
existing binaries because every time you

00:37:59,250 --> 00:38:03,780
have a compatibility interface there's a

00:38:01,950 --> 00:38:05,670
sum that could break if we remove them

00:38:03,780 --> 00:38:07,830
it breaks now instead of later and

00:38:05,670 --> 00:38:11,370
that's better but most people will have

00:38:07,830 --> 00:38:13,020
will have it enabled so everybody will

00:38:11,370 --> 00:38:19,020
still be able to run their 32-bit

00:38:13,020 --> 00:38:20,810
binaries until 2038 and Mosel that's

00:38:19,020 --> 00:38:23,460
completely different

00:38:20,810 --> 00:38:25,530
there's no compile time configuration of

00:38:23,460 --> 00:38:29,760
muzzle it's always the same ABI and the

00:38:25,530 --> 00:38:32,940
ABI at the moment uses the same time T

00:38:29,760 --> 00:38:35,180
that we've always had so we will have to

00:38:32,940 --> 00:38:37,579
have a new incompatible

00:38:35,180 --> 00:38:41,990
version of muzzle and I'm calling this

00:38:37,579 --> 00:38:43,910
to point X could be named something else

00:38:41,990 --> 00:38:48,010
but there will eventually be a version

00:38:43,910 --> 00:38:50,000
of muscle that has a 64-bit time T

00:38:48,010 --> 00:38:52,730
there's still an open question about

00:38:50,000 --> 00:38:55,640
whether that will or will not run on old

00:38:52,730 --> 00:38:57,710
kernels if you want one to run on all

00:38:55,640 --> 00:38:59,359
crunch there's a problem with device

00:38:57,710 --> 00:39:01,790
drivers and our controls and the memory

00:38:59,359 --> 00:39:03,500
met interface and all of that but there

00:39:01,790 --> 00:39:06,770
are some reasons for doing it so we'll

00:39:03,500 --> 00:39:09,710
we'll see the part that I did has a

00:39:06,770 --> 00:39:12,380
nifty F so at compile time for the seed

00:39:09,710 --> 00:39:14,660
library you pick whether you use 32-bit

00:39:12,380 --> 00:39:19,849
or 64-bit time T the version that will

00:39:14,660 --> 00:39:22,069
go into the official Mazal will probably

00:39:19,849 --> 00:39:24,250
completely get rid of the 32-bit time T

00:39:22,069 --> 00:39:27,619
that's that's at least my understanding

00:39:24,250 --> 00:39:29,089
and then further down the road once we

00:39:27,619 --> 00:39:32,329
have the kernel and we have the C

00:39:29,089 --> 00:39:36,319
library we can get finally start with

00:39:32,329 --> 00:39:38,119
the distributions because if you don't

00:39:36,319 --> 00:39:39,349
have the whole distribution all of this

00:39:38,119 --> 00:39:42,589
is meaningless if you have one

00:39:39,349 --> 00:39:46,250
application that stops working on the

00:39:42,589 --> 00:39:48,799
system that you want to run in 2038 you

00:39:46,250 --> 00:39:51,109
lose if it if it doesn't work so you

00:39:48,799 --> 00:39:55,880
have to rebuild everything that uses

00:39:51,109 --> 00:39:58,730
time in any form rebuild it against a

00:39:55,880 --> 00:40:00,530
new C library with 64-bit time enabled

00:39:58,730 --> 00:40:03,020
for the embedded distros that's very

00:40:00,530 --> 00:40:06,170
easy because they always rebuild

00:40:03,020 --> 00:40:08,440
everything from scratch so once we have

00:40:06,170 --> 00:40:11,180
patched openembedded

00:40:08,440 --> 00:40:14,299
then any open embedded user that enables

00:40:11,180 --> 00:40:20,599
this will get the whole user space using

00:40:14,299 --> 00:40:22,190
64-bit time T for Android it will be

00:40:20,599 --> 00:40:25,609
very interesting I have no idea what

00:40:22,190 --> 00:40:28,549
we're going to do because we have fixed

00:40:25,609 --> 00:40:32,740
API levels and you can write

00:40:28,549 --> 00:40:37,160
applications against a certain level and

00:40:32,740 --> 00:40:38,960
will run on all later levels but now we

00:40:37,160 --> 00:40:44,299
would basically have completely

00:40:38,960 --> 00:40:47,699
incompatible API so instead of an 32

00:40:44,299 --> 00:40:51,930
level I don't know 22 you would have

00:40:47,699 --> 00:40:53,789
armed 32 with 64-bit 20 level 22 which

00:40:51,930 --> 00:40:55,739
is incompatible with the old one I have

00:40:53,789 --> 00:40:58,079
no idea I don't think anybody has really

00:40:55,739 --> 00:41:00,749
thought this through for Android yet it

00:40:58,079 --> 00:41:03,660
is going to be a big problem if there

00:41:00,749 --> 00:41:06,329
are Android devices that want to run

00:41:03,660 --> 00:41:10,469
that long which I assume there will be

00:41:06,329 --> 00:41:12,930
but so far we haven't discussed it and

00:41:10,469 --> 00:41:15,779
now for 64-bit distros we still have to

00:41:12,930 --> 00:41:19,140
deal with all the hardware interfaces

00:41:15,779 --> 00:41:21,150
and file systems and file formats but we

00:41:19,140 --> 00:41:24,589
do not have to deal with rebuilding user

00:41:21,150 --> 00:41:29,369
space which is a big relief and then

00:41:24,589 --> 00:41:31,650
32-bit desktop distros these are the

00:41:29,369 --> 00:41:34,829
main ones that I could find that still

00:41:31,650 --> 00:41:45,650
support 32-bit user space in any kind of

00:41:34,829 --> 00:41:49,259
form and out of these we have to either

00:41:45,650 --> 00:41:52,009
stop using them within the next 19 years

00:41:49,259 --> 00:41:54,839
all we have to rebuild them completely

00:41:52,009 --> 00:41:58,199
most of them will probably just stop

00:41:54,839 --> 00:42:01,440
being used at all the ones that are the

00:41:58,199 --> 00:42:03,150
most likely to still be relevant in some

00:42:01,440 --> 00:42:04,949
form or another usually on an embedded

00:42:03,150 --> 00:42:07,709
system that happens to use a desktop

00:42:04,949 --> 00:42:10,949
distro because it it's what they and by

00:42:07,709 --> 00:42:13,920
the developers chose that will be armed

00:42:10,949 --> 00:42:17,549
32-bit or x86 32-bit all the other ones

00:42:13,920 --> 00:42:18,959
I assume will not make it so anybody who

00:42:17,549 --> 00:42:21,420
there are lots of people who have

00:42:18,959 --> 00:42:23,339
shipped these in the past but most of

00:42:21,420 --> 00:42:27,079
the developers have moved on to are more

00:42:23,339 --> 00:42:27,079
Exodus 6 or 64-bit systems

00:42:31,940 --> 00:42:39,380
this is the overall progress where I

00:42:36,350 --> 00:42:40,790
think we are at this moment these are

00:42:39,380 --> 00:42:44,780
the different areas that we talked about

00:42:40,790 --> 00:42:46,070
for device for device drivers we are

00:42:44,780 --> 00:42:48,080
pretty much done there still some

00:42:46,070 --> 00:42:49,910
drivers that need work the car timer

00:42:48,080 --> 00:42:53,410
handling is almost completely done we

00:42:49,910 --> 00:42:56,630
just have to but once we removed the

00:42:53,410 --> 00:42:58,820
last users of some old interfaces we can

00:42:56,630 --> 00:43:00,260
remove the compatibility code in the

00:42:58,820 --> 00:43:02,780
inside of the condor we still have

00:43:00,260 --> 00:43:07,730
system calls are progressing nicely as

00:43:02,780 --> 00:43:09,770
of 419 the driver interfaces into user

00:43:07,730 --> 00:43:12,470
space we still have a couple of them

00:43:09,770 --> 00:43:13,790
that we absolutely have to fix and we

00:43:12,470 --> 00:43:22,120
don't have the final patch together

00:43:13,790 --> 00:43:28,310
includes audio video for linux sockets

00:43:22,120 --> 00:43:30,140
and a few more file systems the big work

00:43:28,310 --> 00:43:32,570
has been done they are still a couple of

00:43:30,140 --> 00:43:33,980
files that we want to fix and there are

00:43:32,570 --> 00:43:36,710
some corner cases and some of the file

00:43:33,980 --> 00:43:39,290
systems like what happens if you set the

00:43:36,710 --> 00:43:41,300
time to a value that it's not supported

00:43:39,290 --> 00:43:43,400
by the file system currently we just

00:43:41,300 --> 00:43:44,780
wrap around you could barely end up with

00:43:43,400 --> 00:43:47,450
a random time that depends on the

00:43:44,780 --> 00:43:48,710
underlying file system because some

00:43:47,450 --> 00:43:52,160
anything could happen after the wrap

00:43:48,710 --> 00:43:54,230
around we need to change that so that if

00:43:52,160 --> 00:43:57,050
you set the time on the file system to a

00:43:54,230 --> 00:43:59,720
future date or a date in the distant

00:43:57,050 --> 00:44:03,830
past that it just truncates to the

00:43:59,720 --> 00:44:06,470
extreme values that we still support so

00:44:03,830 --> 00:44:10,400
we if if on an ext3 file system you set

00:44:06,470 --> 00:44:12,320
the time times the minute I know to 2040

00:44:10,400 --> 00:44:14,630
the result should be having the

00:44:12,320 --> 00:44:18,260
timestamp on 2038 all you should get an

00:44:14,630 --> 00:44:22,850
error but the current behavior of

00:44:18,260 --> 00:44:25,190
setting it to somewhere in 1904 it's

00:44:22,850 --> 00:44:28,940
just not acceptable then

00:44:25,190 --> 00:44:31,400
architecture-specific that's mostly the

00:44:28,940 --> 00:44:33,970
system called tables this is something

00:44:31,400 --> 00:44:38,360
that my colleague Phyllis has worked on

00:44:33,970 --> 00:44:40,640
we are going to change the layout of all

00:44:38,360 --> 00:44:44,020
the system called here is currently all

00:44:40,640 --> 00:44:45,670
of the older architectures like the ten

00:44:44,020 --> 00:44:47,980
the architectures that we still support

00:44:45,670 --> 00:44:49,420
in the Khurana each of them formats the

00:44:47,980 --> 00:44:53,470
system called table in a completely

00:44:49,420 --> 00:44:55,540
different way changing those tables in a

00:44:53,470 --> 00:44:57,370
controlled manner is very hard because

00:44:55,540 --> 00:44:58,720
you have to understand every single

00:44:57,370 --> 00:45:02,650
architecture at first

00:44:58,720 --> 00:45:05,470
so what Phoebus has been doing is trying

00:45:02,650 --> 00:45:07,270
to get a common format of how we

00:45:05,470 --> 00:45:09,340
describe the system called table in the

00:45:07,270 --> 00:45:12,280
kernel and then we can do the changes on

00:45:09,340 --> 00:45:13,600
top so those patches are not up stream

00:45:12,280 --> 00:45:16,090
yet but he's done a lot of work on it

00:45:13,600 --> 00:45:19,420
and then we have to see library and the

00:45:16,090 --> 00:45:22,480
distributions and this is all that I had

00:45:19,420 --> 00:45:25,480
and I hope you have some questions yes

00:45:22,480 --> 00:45:27,760
as anybody thought of updating POSIX or

00:45:25,480 --> 00:45:30,040
single UNIX Beck for this kind of work

00:45:27,760 --> 00:45:33,850
because obviously all the world isn't

00:45:30,040 --> 00:45:36,730
quite yet Linux in what way updating it

00:45:33,850 --> 00:45:40,720
well for example to deal with the new

00:45:36,730 --> 00:45:43,090
interfaces and you know the things that

00:45:40,720 --> 00:45:45,430
are exposed by the C library for example

00:45:43,090 --> 00:45:48,100
I don't think there's a need for that I

00:45:45,430 --> 00:45:52,120
haven't found anything that won't be

00:45:48,100 --> 00:45:53,500
compatible so the time spec was

00:45:52,120 --> 00:45:57,640
certainly something that came up in the

00:45:53,500 --> 00:45:59,530
past for the x32 ABI and we have solved

00:45:57,640 --> 00:46:01,660
this now by having a different

00:45:59,530 --> 00:46:04,000
definition of time spec in the kernel

00:46:01,660 --> 00:46:07,390
user space interface compared to the

00:46:04,000 --> 00:46:10,240
live C library to application interface

00:46:07,390 --> 00:46:12,550
so that we can get all the constraints

00:46:10,240 --> 00:46:15,580
right but with that I don't think we

00:46:12,550 --> 00:46:18,700
need to change the POSIX if something

00:46:15,580 --> 00:46:21,370
like cpio is specified for six then we

00:46:18,700 --> 00:46:23,560
may have to change that I think there's

00:46:21,370 --> 00:46:26,230
quite a few things like that were POSIX

00:46:23,560 --> 00:46:27,520
does have some relevance so yeah I'd

00:46:26,230 --> 00:46:29,890
expect there's gonna be some changes

00:46:27,520 --> 00:46:32,650
needed has anybody started talking about

00:46:29,890 --> 00:46:34,480
that yet I'm not aware of anything the

00:46:32,650 --> 00:46:36,460
other thing to consider is that most

00:46:34,480 --> 00:46:38,380
commercial most of the other UNIX

00:46:36,460 --> 00:46:44,620
implementations have already solved this

00:46:38,380 --> 00:46:46,150
so Mac OS BSD well they they're the only

00:46:44,620 --> 00:46:48,760
ones that are still available for 32-bit

00:46:46,150 --> 00:46:51,120
all the commercial UNIX are 64-bit only

00:46:48,760 --> 00:46:53,750
if they still exist

00:46:51,120 --> 00:46:56,180
so basically

00:46:53,750 --> 00:46:58,040
most others are ahead of us which is

00:46:56,180 --> 00:46:59,869
something they can do because they tend

00:46:58,040 --> 00:47:02,030
to have releases weather update the

00:46:59,869 --> 00:47:04,369
colonel and the sea library at the same

00:47:02,030 --> 00:47:06,140
time and all of user space so they just

00:47:04,369 --> 00:47:08,180
rebuild the world and then ship it as a

00:47:06,140 --> 00:47:10,790
product and that's something that we do

00:47:08,180 --> 00:47:13,910
not do so we change the kernel and we

00:47:10,790 --> 00:47:16,750
expect all past user space to work with

00:47:13,910 --> 00:47:18,980
the current kernel and gilepsy

00:47:16,750 --> 00:47:20,540
expected to work with a certain number

00:47:18,980 --> 00:47:23,330
of kernels in the past at every kernel

00:47:20,540 --> 00:47:25,190
in the future and also worked with all

00:47:23,330 --> 00:47:27,170
applications built against and all that

00:47:25,190 --> 00:47:29,359
G Lib C so we have a whole lot of issues

00:47:27,170 --> 00:47:34,700
that we get from the compatibility

00:47:29,359 --> 00:47:36,710
guarantees that we make but the POSIX

00:47:34,700 --> 00:47:39,170
should already describe what the other

00:47:36,710 --> 00:47:41,900
UNIX architectures the other UNIX

00:47:39,170 --> 00:47:49,450
implementations do and that I think

00:47:41,900 --> 00:47:53,599
works fine so the system call interface

00:47:49,450 --> 00:47:56,599
which like greed and IO control so you

00:47:53,599 --> 00:47:58,849
really find that what that means from

00:47:56,599 --> 00:48:01,849
user space side depending on how time

00:47:58,849 --> 00:48:05,180
spec is defined right well let me get

00:48:01,849 --> 00:48:11,330
back to this slide here so on Io control

00:48:05,180 --> 00:48:14,119
we can do it my question is how do you

00:48:11,330 --> 00:48:15,950
do that on kernel site so the krona

00:48:14,119 --> 00:48:17,210
like this this is the one that we had

00:48:15,950 --> 00:48:21,020
for the i/o control

00:48:17,210 --> 00:48:23,150
so since user space identifies the

00:48:21,020 --> 00:48:26,720
interface I meant the one with the

00:48:23,150 --> 00:48:29,660
structs in the and not the one maybe two

00:48:26,720 --> 00:48:32,510
or three slides forward so this was the

00:48:29,660 --> 00:48:34,339
easier one yeah that one that one is

00:48:32,510 --> 00:48:37,400
clear yeah so we pass a command number

00:48:34,339 --> 00:48:40,730
and user space by compiling with a

00:48:37,400 --> 00:48:42,530
certain type it automatically gets the

00:48:40,730 --> 00:48:44,869
right command number and the kernel just

00:48:42,530 --> 00:48:47,540
implements both commands so the kernel

00:48:44,869 --> 00:48:50,180
you can always pass the old the wrong

00:48:47,540 --> 00:48:53,180
command and you get the mentioned result

00:48:50,180 --> 00:48:54,980
for that so the kernel doesn't know what

00:48:53,180 --> 00:48:57,680
user space yeah yeah that's clear yeah

00:48:54,980 --> 00:48:59,960
but when it when there is destruct in

00:48:57,680 --> 00:49:03,349
the read yes it's like Oh read we

00:48:59,960 --> 00:49:05,599
basically lose that's there's there's no

00:49:03,349 --> 00:49:06,630
good way of solving the read so what we

00:49:05,599 --> 00:49:11,990
did here is the

00:49:06,630 --> 00:49:15,869
to redefine the structure yeah so that

00:49:11,990 --> 00:49:20,490
we do not use time well in the header

00:49:15,869 --> 00:49:23,069
file so if we rebuild the user space

00:49:20,490 --> 00:49:25,769
using a 64-bit time T we still get the

00:49:23,069 --> 00:49:28,410
old layout for the structure and user

00:49:25,769 --> 00:49:32,220
space has to change to not expect the

00:49:28,410 --> 00:49:34,230
time valve if you try to access this as

00:49:32,220 --> 00:49:35,819
a time value get a compilation error and

00:49:34,230 --> 00:49:37,349
that you know that you have to change

00:49:35,819 --> 00:49:39,960
your source code and we hope that this

00:49:37,349 --> 00:49:42,420
is only in two or three libraries that

00:49:39,960 --> 00:49:44,759
actually use this interface but this is

00:49:42,420 --> 00:49:47,039
one of the harder things and we don't

00:49:44,759 --> 00:49:49,259
have a good solution for this other than

00:49:47,039 --> 00:49:50,369
changing the user space source code but

00:49:49,259 --> 00:49:52,859
this is also true for a lot of other

00:49:50,369 --> 00:49:58,140
things so any any user space application

00:49:52,859 --> 00:50:00,569
that assumes that 32-bit is enough to

00:49:58,140 --> 00:50:04,950
store a timestamp will have to change as

00:50:00,569 --> 00:50:07,680
well yeah and that's at some certain

00:50:04,950 --> 00:50:09,089
future point in time where we can you

00:50:07,680 --> 00:50:11,250
certainly have to change a number of

00:50:09,089 --> 00:50:13,680
applications and any application using

00:50:11,250 --> 00:50:16,529
the interface like this may be affected

00:50:13,680 --> 00:50:18,900
by that too so of course that's why we

00:50:16,529 --> 00:50:20,970
need the 64 bit interfaces available as

00:50:18,900 --> 00:50:24,230
soon as possible so people can start

00:50:20,970 --> 00:50:24,230
converting key absolutely

00:50:33,910 --> 00:50:40,880
once we get once we get the colonel

00:50:37,510 --> 00:50:44,559
squared away we're gonna discover

00:50:40,880 --> 00:50:47,059
problems idiomatic to languages or to

00:50:44,559 --> 00:50:50,300
development platforms or whatnot yeah

00:50:47,059 --> 00:50:54,170
one that I'm aware of is a fairly old

00:50:50,300 --> 00:50:56,690
time interface and 32-bit PHP code where

00:50:54,170 --> 00:51:00,890
there's a function call that will fail

00:50:56,690 --> 00:51:03,230
on 32-bit systems when the time when the

00:51:00,890 --> 00:51:06,079
time wraps around do you have a sense

00:51:03,230 --> 00:51:10,550
for if someone were to want to put

00:51:06,079 --> 00:51:12,890
together a test suite for auditing code

00:51:10,550 --> 00:51:15,619
or for looking at code where you would

00:51:12,890 --> 00:51:18,410
even start now or is it too early to

00:51:15,619 --> 00:51:20,569
even start that audit process you can't

00:51:18,410 --> 00:51:22,339
really start before we have the seed

00:51:20,569 --> 00:51:24,800
library like if it if the same problem

00:51:22,339 --> 00:51:28,880
exists on 64-bit systems you can start

00:51:24,800 --> 00:51:31,160
now it depends on what you what exact

00:51:28,880 --> 00:51:32,900
set of applications you want to test I I

00:51:31,160 --> 00:51:36,920
don't know what test you would do but

00:51:32,900 --> 00:51:38,569
anything that uses the same code of 32

00:51:36,920 --> 00:51:41,030
and 64-bit architectures you can already

00:51:38,569 --> 00:51:44,200
test on 64-bit architectures by setting

00:51:41,030 --> 00:51:47,450
the time ahead and see what happens

00:51:44,200 --> 00:51:50,089
for testing on 32-bit architectures I

00:51:47,450 --> 00:51:53,180
only have this one prototype of mazel

00:51:50,089 --> 00:51:55,579
that we have tested it passes the LTP

00:51:53,180 --> 00:51:57,920
test suite and any application that you

00:51:55,579 --> 00:52:01,670
could link against mazu

00:51:57,920 --> 00:52:03,470
you could test with this in theory but

00:52:01,670 --> 00:52:07,190
it's also like this will still change

00:52:03,470 --> 00:52:08,540
this this has a an earlier version of

00:52:07,190 --> 00:52:10,940
the system call interface we've made

00:52:08,540 --> 00:52:14,720
some changes to the binary structures

00:52:10,940 --> 00:52:16,579
that we were adding so this is all still

00:52:14,720 --> 00:52:18,349
very early it would be much easier as

00:52:16,579 --> 00:52:20,960
soon as we have the system calls in

00:52:18,349 --> 00:52:23,859
place and we have a seed library that is

00:52:20,960 --> 00:52:27,200
close to what we will eventually get

00:52:23,859 --> 00:52:30,020
related to that you mentioned PHP the

00:52:27,200 --> 00:52:36,589
one that we've come across a while ago

00:52:30,020 --> 00:52:37,940
is Python so python has a binding for C

00:52:36,589 --> 00:52:42,730
libraries

00:52:37,940 --> 00:52:48,770
and the way this is written is that it

00:52:42,730 --> 00:52:50,569
assumes that the time structures are

00:52:48,770 --> 00:52:52,810
always using long so it is already

00:52:50,569 --> 00:52:57,050
broken on the x32

00:52:52,810 --> 00:53:03,260
target on x86 which fortunately nobody

00:52:57,050 --> 00:53:06,619
uses but they will run into big problems

00:53:03,260 --> 00:53:08,150
and I'm probably not going to work on

00:53:06,619 --> 00:53:10,520
those but whoever is going to work on

00:53:08,150 --> 00:53:14,119
Python converting Python will have to

00:53:10,520 --> 00:53:16,670
come up with clever way of dealing with

00:53:14,119 --> 00:53:18,170
us in general because we're changing one

00:53:16,670 --> 00:53:22,460
of the fundamental assumptions that's in

00:53:18,170 --> 00:53:26,119
all the native interfaces that Python

00:53:22,460 --> 00:53:28,970
uses to talk to libraries in to the

00:53:26,119 --> 00:53:35,030
kernel and I assume there will be more

00:53:28,970 --> 00:53:36,950
of those of course probably the biggest

00:53:35,030 --> 00:53:38,180
amount of work is going to be near at

00:53:36,950 --> 00:53:41,210
the end of the process there's going to

00:53:38,180 --> 00:53:42,920
be any number of on disk formats which

00:53:41,210 --> 00:53:44,810
you're going to be embedding tight you

00:53:42,920 --> 00:53:48,530
know date time and date stamps that we

00:53:44,810 --> 00:53:51,700
don't know about yet and you talked

00:53:48,530 --> 00:53:56,089
about file systems obviously the VFS

00:53:51,700 --> 00:53:57,800
layer you've changed I was curious about

00:53:56,089 --> 00:53:59,599
things you know like some of the old the

00:53:57,800 --> 00:54:07,240
I guess the standardized file system

00:53:59,599 --> 00:54:15,079
like i0 9660 is that clean for 64-bit so

00:54:07,240 --> 00:54:17,960
this one is 2038 clean i believe it well

00:54:15,079 --> 00:54:22,010
it uses a an 8-bit number to encode a

00:54:17,960 --> 00:54:27,670
year starting in 1980 so it will

00:54:22,010 --> 00:54:30,670
overflow in 2236

00:54:27,670 --> 00:54:30,670
cool

00:54:31,420 --> 00:54:36,799
and follow I have a list of all the file

00:54:34,099 --> 00:54:39,769
systems with an estimated expiration

00:54:36,799 --> 00:54:41,749
date yeah do you have that kind of

00:54:39,769 --> 00:54:44,529
information available gladly online no

00:54:41,749 --> 00:54:48,259
no in the past you given a link to that

00:54:44,529 --> 00:54:49,970
do you have say a link to any document

00:54:48,259 --> 00:54:54,440
about what you have saved the list of

00:54:49,970 --> 00:54:56,690
the file systems and I think I think the

00:54:54,440 --> 00:54:58,700
slides will be available I put the links

00:54:56,690 --> 00:55:01,640
into the slides in the verse that will

00:54:58,700 --> 00:55:04,069
be available for download awesome cuz I

00:55:01,640 --> 00:55:09,650
actually had a friend contact me last

00:55:04,069 --> 00:55:11,779
week he works for a supplier to a car

00:55:09,650 --> 00:55:14,089
manufacturer and they were already

00:55:11,779 --> 00:55:15,799
starting to ask the question so why

00:55:14,089 --> 00:55:18,410
can't we set the date past twenty thirty

00:55:15,799 --> 00:55:19,700
seven or the infotainment yet so it's

00:55:18,410 --> 00:55:22,849
good to see the people are starting to

00:55:19,700 --> 00:55:24,170
care about this good and early but

00:55:22,849 --> 00:55:27,019
obviously there's still a lot of work to

00:55:24,170 --> 00:55:28,910
be done yep no most of the documents

00:55:27,019 --> 00:55:31,490
we've written years ago so that might be

00:55:28,910 --> 00:55:35,480
slightly outdated information but those

00:55:31,490 --> 00:55:37,910
links are still very helpful I think and

00:55:35,480 --> 00:55:39,230
we're out of time so thank you very much

00:55:37,910 --> 00:55:42,350
for attending

00:55:39,230 --> 00:55:47,360
[Applause]

00:55:42,350 --> 00:55:47,360

YouTube URL: https://www.youtube.com/watch?v=XRj_OSXfoMQ


