Title: YVR18-305: The best from Ultra96 in the IoT and Embedded Vision Arena without being a FPGA Expert
Publication date: 2018-10-23
Playlist: Linaro Connect Vancouver 2018
Description: 
	The Ultra96 is unique among 96boards, as it combines ARM cores with programmable logic. To create the most efficient system a high level OS is needed such as Linux however, traditionally Linux developers know little about exploiting programmable logic. This session will introduce how programmers used to developing for embedded Linux can leverage programmable logic without the need to be a programmable logic experts. With a focus on the IoT and embedded Vision / ML

Speaker: Adam Taylor
Captions: 
	00:00:02,120 --> 00:00:07,130
[Music]

00:00:08,240 --> 00:00:11,640
right so we're starting we're starting

00:00:10,080 --> 00:00:13,110
slightly later apologies for that in the

00:00:11,640 --> 00:00:15,059
best best way that we all we had slight

00:00:13,110 --> 00:00:17,369
few technical issues so I'm going to I'm

00:00:15,059 --> 00:00:19,230
Adam Taylor and for the last few years

00:00:17,369 --> 00:00:22,980
I've been working predominantly with the

00:00:19,230 --> 00:00:24,119
zinc and the zinc MP sock and FPGAs I'll

00:00:22,980 --> 00:00:26,520
be writing about these on the mike rizzo

00:00:24,119 --> 00:00:27,900
chronicle so if you ever fancy getting

00:00:26,520 --> 00:00:38,700
to sleep one evening you can you can

00:00:27,900 --> 00:00:40,500
take you to these but now eventually so

00:00:38,700 --> 00:00:42,570
I think actually Dan might have talked a

00:00:40,500 --> 00:00:44,040
lot about they saw I'll briefly cover

00:00:42,570 --> 00:00:47,870
these ones so we can all get to the bar

00:00:44,040 --> 00:00:51,320
in time but further for those office

00:00:47,870 --> 00:00:51,320
slides here

00:00:55,489 --> 00:00:59,120
now it's okay I'll just press the

00:00:57,739 --> 00:01:01,070
buttons on the fingers easier than that

00:00:59,120 --> 00:01:02,449
way okay so for those unfamiliar with a

00:01:01,070 --> 00:01:04,699
year alter ninety-six Berg they've been

00:01:02,449 --> 00:01:06,409
a few or weak on the after net on the

00:01:04,699 --> 00:01:09,229
after next and there's some really great

00:01:06,409 --> 00:01:11,869
examples running on there it contains a

00:01:09,229 --> 00:01:15,290
heterogeneous sick sock which is the

00:01:11,869 --> 00:01:16,700
zinc MP sock Zed you free eg I want to

00:01:15,290 --> 00:01:18,500
talk about that a little bit more in a

00:01:16,700 --> 00:01:19,670
little while but initially it comes just

00:01:18,500 --> 00:01:21,649
to give you some context of what it is

00:01:19,670 --> 00:01:23,420
it contains two gigabyte of RAM we've

00:01:21,649 --> 00:01:25,310
got the SD card on there and obviously

00:01:23,420 --> 00:01:26,720
contains to the ninety-six board format

00:01:25,310 --> 00:01:28,820
into in terms of the consumer

00:01:26,720 --> 00:01:30,649
specification now generally when we

00:01:28,820 --> 00:01:32,090
develop these things to get the best use

00:01:30,649 --> 00:01:34,100
of the Wi-Fi and everything we want to

00:01:32,090 --> 00:01:35,539
be we're going to be using a petal annex

00:01:34,100 --> 00:01:37,610
type build on there so petal Linux is a

00:01:35,539 --> 00:01:39,500
bill that comes from Xilinx it allows us

00:01:37,610 --> 00:01:40,490
to to develop that flow but it's not

00:01:39,500 --> 00:01:42,229
actually it's not actually a

00:01:40,490 --> 00:01:44,509
distribution it's just a build chain

00:01:42,229 --> 00:01:45,590
that allows us to actually yeah to

00:01:44,509 --> 00:01:50,960
actually get a Linux whirring on our

00:01:45,590 --> 00:01:53,030
system so it's a little unique if

00:01:50,960 --> 00:01:55,310
there's ink MP so in that it contains a

00:01:53,030 --> 00:01:57,679
processing system and programmable logic

00:01:55,310 --> 00:01:59,210
now obviously in the you've probably had

00:01:57,679 --> 00:02:00,380
this told in the last session but in the

00:01:59,210 --> 00:02:03,320
processing system obviously we've got

00:02:00,380 --> 00:02:04,759
the quad core a fifty three processors

00:02:03,320 --> 00:02:06,979
we've got the r5 processors they're

00:02:04,759 --> 00:02:08,440
really really quite powerful and it's

00:02:06,979 --> 00:02:11,420
really quite useful for a lot of

00:02:08,440 --> 00:02:13,489
industrial internet of things embedded

00:02:11,420 --> 00:02:14,690
vision applications and we have

00:02:13,489 --> 00:02:15,980
obviously the programmable logic now

00:02:14,690 --> 00:02:17,930
programmable logic is really good for

00:02:15,980 --> 00:02:19,579
accelerating functions it gives us a

00:02:17,930 --> 00:02:20,870
really really good performance

00:02:19,579 --> 00:02:23,209
improvement but there's also some other

00:02:20,870 --> 00:02:25,220
good uses for it such as interface in

00:02:23,209 --> 00:02:26,989
which which we're going to look at and

00:02:25,220 --> 00:02:30,140
between the two obviously is as Dan

00:02:26,989 --> 00:02:31,820
alluded to actually we have a exciting

00:02:30,140 --> 00:02:33,860
to connect so we have master and slave

00:02:31,820 --> 00:02:34,790
interconnects for the ax I interface in

00:02:33,860 --> 00:02:36,920
both directions

00:02:34,790 --> 00:02:38,600
we have fabrics and clocks and then we

00:02:36,920 --> 00:02:40,940
have what I've currently called other

00:02:38,600 --> 00:02:43,459
down the bottom but we have obviously

00:02:40,940 --> 00:02:45,410
interrupts from the PS the plpl to the

00:02:43,459 --> 00:02:46,970
PS and also we have a lot of debugging

00:02:45,410 --> 00:02:48,560
interfaces that go between there such

00:02:46,970 --> 00:02:50,359
that we can if you want to because this

00:02:48,560 --> 00:02:51,650
is a obviously when you get to debug in

00:02:50,359 --> 00:02:54,470
your applications it can be quite

00:02:51,650 --> 00:02:55,880
complicated so you've got interaction

00:02:54,470 --> 00:02:57,590
going up in your program logic you've

00:02:55,880 --> 00:02:59,480
got interaction going off in your in

00:02:57,590 --> 00:03:02,030
your system on chip you hope your

00:02:59,480 --> 00:03:03,709
processor side of things and you can put

00:03:02,030 --> 00:03:05,090
integrated logic analyzers in there let

00:03:03,709 --> 00:03:06,410
the integrate a logic analyzer trigger

00:03:05,090 --> 00:03:07,519
and actually breakpoint and stop the

00:03:06,410 --> 00:03:08,660
software everyone in says you can

00:03:07,519 --> 00:03:09,140
actually see what the interaction is

00:03:08,660 --> 00:03:10,340
between the

00:03:09,140 --> 00:03:11,930
- or you can do it the other way you can

00:03:10,340 --> 00:03:13,370
hit the you can hit the software

00:03:11,930 --> 00:03:15,650
breakpoint and you can actually make it

00:03:13,370 --> 00:03:17,690
see what see what's going off with the

00:03:15,650 --> 00:03:21,080
logic analyzer so it's quite quite a

00:03:17,690 --> 00:03:22,130
useful an application so I'll flick

00:03:21,080 --> 00:03:23,630
through these slides quite quickly

00:03:22,130 --> 00:03:25,040
actually but we've got the obviously

00:03:23,630 --> 00:03:27,140
we've got the Armed Forces code got the

00:03:25,040 --> 00:03:28,910
mail we've got the a5 and we've got a

00:03:27,140 --> 00:03:31,010
lot of the a lot of connectivity

00:03:28,910 --> 00:03:32,540
interface as well which we can which are

00:03:31,010 --> 00:03:34,820
really flexible when we want to talk

00:03:32,540 --> 00:03:36,440
about breaking out sort of different

00:03:34,820 --> 00:03:38,300
kits that different standard so you can

00:03:36,440 --> 00:03:40,940
use a multiplex diode to bring out maybe

00:03:38,300 --> 00:03:44,980
an I squared C or a can or sunflower and

00:03:40,940 --> 00:03:48,080
you can configure this all via Vado

00:03:44,980 --> 00:03:49,580
now there's some lesser-known but quite

00:03:48,080 --> 00:03:51,830
useful subsystems and everybody else

00:03:49,580 --> 00:03:53,120
talks about the r5 and the and the apu

00:03:51,830 --> 00:03:55,250
but actually there's a configuration

00:03:53,120 --> 00:03:57,860
security unit in there which is also

00:03:55,250 --> 00:03:59,120
very useful if you want to do if you

00:03:57,860 --> 00:04:00,709
want to do cryptographic things if you

00:03:59,120 --> 00:04:03,020
want to do some secure security work you

00:04:00,709 --> 00:04:04,580
don't have to accelerate course into the

00:04:03,020 --> 00:04:07,130
programmable logic you can you can use

00:04:04,580 --> 00:04:09,050
these functions in the in the CSU and

00:04:07,130 --> 00:04:12,440
you can just DMA data at large chunks of

00:04:09,050 --> 00:04:14,570
data into all out of them via the ax I

00:04:12,440 --> 00:04:17,180
into connect from your APU or the RP you

00:04:14,570 --> 00:04:19,310
whether your whichever application needs

00:04:17,180 --> 00:04:20,720
to do it so it's quite a useful useful

00:04:19,310 --> 00:04:22,700
little applications of what I've mention

00:04:20,720 --> 00:04:24,380
it here but the first one is actually

00:04:22,700 --> 00:04:26,750
some I'm assuming that most people in

00:04:24,380 --> 00:04:28,130
this room software engineers are not too

00:04:26,750 --> 00:04:30,200
familiar with the exception of you guys

00:04:28,130 --> 00:04:31,850
over there and yourself there so you

00:04:30,200 --> 00:04:34,490
know most people are fairly unfamiliar

00:04:31,850 --> 00:04:36,229
with programmable logic so it really it

00:04:34,490 --> 00:04:38,320
begs the question of what is the benefit

00:04:36,229 --> 00:04:39,800
of programmable logic and it's really

00:04:38,320 --> 00:04:41,570
there's a number of applications

00:04:39,800 --> 00:04:44,630
actually for it so the first ones I

00:04:41,570 --> 00:04:46,610
mentioned with the 96 board format

00:04:44,630 --> 00:04:48,020
obviously we have the high speed

00:04:46,610 --> 00:04:49,880
connector and a low speed connector and

00:04:48,020 --> 00:04:51,320
they're connected to they're connected

00:04:49,880 --> 00:04:53,300
to elements of the design mostly to the

00:04:51,320 --> 00:04:55,580
programmable logic side of it and we

00:04:53,300 --> 00:04:57,680
want to really be able to have flexible

00:04:55,580 --> 00:04:59,240
interface in that and programmable logic

00:04:57,680 --> 00:05:00,530
gives us that pretty much with any if we

00:04:59,240 --> 00:05:01,700
put a fire on the board if we can get

00:05:00,530 --> 00:05:03,320
the right file in there we can get that

00:05:01,700 --> 00:05:06,229
we can get the programmable logic to do

00:05:03,320 --> 00:05:07,700
that interfacing so we get really any to

00:05:06,229 --> 00:05:09,050
any interfacing capability which is

00:05:07,700 --> 00:05:11,570
quite useful when we want to start

00:05:09,050 --> 00:05:13,520
working with maybe some bespoke or some

00:05:11,570 --> 00:05:14,780
legacy interfaces or we want to or we

00:05:13,520 --> 00:05:16,700
want to adding multiple types of

00:05:14,780 --> 00:05:20,610
interface when we're kind of limited

00:05:16,700 --> 00:05:22,889
with what was supported otherwise

00:05:20,610 --> 00:05:24,090
then of course there's always the the

00:05:22,889 --> 00:05:26,400
traditional approach which is the

00:05:24,090 --> 00:05:27,539
programmability the programmability the

00:05:26,400 --> 00:05:30,539
acceleration that comes when we

00:05:27,539 --> 00:05:32,009
accelerate something from the PS into

00:05:30,539 --> 00:05:33,960
the into the programmable logic and

00:05:32,009 --> 00:05:35,699
that's mainly because one of the key

00:05:33,960 --> 00:05:38,039
things we do is is we remove the

00:05:35,699 --> 00:05:40,110
bottleneck of the DVR so as opposed to

00:05:38,039 --> 00:05:41,939
actually having to transfer elements of

00:05:40,110 --> 00:05:44,159
process in between between the processor

00:05:41,939 --> 00:05:45,840
into the DVR and back out of it again so

00:05:44,159 --> 00:05:47,360
you're competing for resources actually

00:05:45,840 --> 00:05:49,110
it's running straight through the

00:05:47,360 --> 00:05:51,300
straight through the programmable logic

00:05:49,110 --> 00:05:52,919
so you've got a traditional pipeline

00:05:51,300 --> 00:05:54,300
that goes from the input all the way

00:05:52,919 --> 00:05:56,159
through to the output so it's much more

00:05:54,300 --> 00:05:59,879
much more deterministic much

00:05:56,159 --> 00:06:01,560
high-performance and it's just a lot

00:05:59,879 --> 00:06:06,000
better it will for the right application

00:06:01,560 --> 00:06:07,289
it's a lot better all you need to do is

00:06:06,000 --> 00:06:09,389
you think need to think about what we

00:06:07,289 --> 00:06:10,710
want to move from the PS to the PL so

00:06:09,389 --> 00:06:12,330
there's a range of things that are quite

00:06:10,710 --> 00:06:14,189
popular these days there's a number of

00:06:12,330 --> 00:06:15,689
verticals real you know the internet

00:06:14,189 --> 00:06:17,729
things in better vision machine learning

00:06:15,689 --> 00:06:18,840
actually what you what I tend to see

00:06:17,729 --> 00:06:20,099
really is an engineer on the ground

00:06:18,840 --> 00:06:21,479
working with a lot of customers is these

00:06:20,099 --> 00:06:24,120
things will kind of merging together

00:06:21,479 --> 00:06:28,770
into into one app into a number of

00:06:24,120 --> 00:06:30,539
applications anyway and if you start to

00:06:28,770 --> 00:06:31,800
start developing for programmable logic

00:06:30,539 --> 00:06:33,180
if you come from a software background

00:06:31,800 --> 00:06:35,370
it's quite it can be quite difficult

00:06:33,180 --> 00:06:37,050
you've got to understand the concept of

00:06:35,370 --> 00:06:38,940
clock domain crossing clocks

00:06:37,050 --> 00:06:41,520
processors you know when you look at

00:06:38,940 --> 00:06:44,400
your processors in your VHDL they all

00:06:41,520 --> 00:06:45,419
run at the same time they are like

00:06:44,400 --> 00:06:46,860
secure at the same time apart from

00:06:45,419 --> 00:06:48,719
contents within them which execute

00:06:46,860 --> 00:06:50,939
sequentially so it gets it gets to be

00:06:48,719 --> 00:06:52,860
quite a mind thing for if you come from

00:06:50,939 --> 00:06:55,319
a traditional software background so

00:06:52,860 --> 00:06:57,479
it's quite difficult to do that and take

00:06:55,319 --> 00:06:59,699
advantage of what's in the what's in the

00:06:57,479 --> 00:07:01,680
PLA and actually a lot of times when we

00:06:59,699 --> 00:07:02,969
develop embedded vision systems or

00:07:01,680 --> 00:07:05,159
machine learning systems you start out

00:07:02,969 --> 00:07:07,620
with a high level model in maybe MATLAB

00:07:05,159 --> 00:07:09,599
or C and actually there's a big gap then

00:07:07,620 --> 00:07:11,189
between what where your model finishes

00:07:09,599 --> 00:07:12,629
and where you start working with VHDL or

00:07:11,189 --> 00:07:14,699
Verilog and you have to kind of fill

00:07:12,629 --> 00:07:16,729
fill that in and and start working with

00:07:14,699 --> 00:07:16,729
it

00:07:16,909 --> 00:07:20,699
so I actually we start working with the

00:07:19,319 --> 00:07:22,560
ultra 96 one of the first things we can

00:07:20,699 --> 00:07:24,529
do is actually it's quite it's very

00:07:22,560 --> 00:07:27,870
simple if we use Vivaro

00:07:24,529 --> 00:07:30,000
we can use IP integrator so what you see

00:07:27,870 --> 00:07:31,949
up here in the in the box so it says in

00:07:30,000 --> 00:07:33,810
culture scale in it that defines a

00:07:31,949 --> 00:07:34,230
processing system so that's got contains

00:07:33,810 --> 00:07:37,800
the

00:07:34,230 --> 00:07:39,120
APU VR fives the multiplexed i/o so you

00:07:37,800 --> 00:07:40,920
can double click on Barden it opens a

00:07:39,120 --> 00:07:42,180
nice little GUI that you can you can

00:07:40,920 --> 00:07:44,160
configure that the interfaces between

00:07:42,180 --> 00:07:45,450
the processor system and the

00:07:44,160 --> 00:07:47,220
programmable logic that you want to

00:07:45,450 --> 00:07:47,910
enable so that's all hard silicon but

00:07:47,220 --> 00:07:50,580
what you're actually you're just

00:07:47,910 --> 00:07:51,930
enabling options that are in there and

00:07:50,580 --> 00:07:53,910
then everything else around it actually

00:07:51,930 --> 00:07:59,010
sits within the programmable logic the

00:07:53,910 --> 00:08:00,690
FPGA side now what's really quite good

00:07:59,010 --> 00:08:02,790
about this is actually Xilinx give a lot

00:08:00,690 --> 00:08:03,900
of IP so literally you can literally

00:08:02,790 --> 00:08:05,040
just start there and if you want to

00:08:03,900 --> 00:08:06,480
create an embedded vision system you can

00:08:05,040 --> 00:08:08,490
literally start there just pulling a pin

00:08:06,480 --> 00:08:09,900
and you can get a scent you can simply

00:08:08,490 --> 00:08:11,100
create an IP vision system without

00:08:09,900 --> 00:08:12,420
having to write any code of you and all

00:08:11,100 --> 00:08:14,190
you've got to do is drop these boxes in

00:08:12,420 --> 00:08:16,950
connect them up to the probe to the

00:08:14,190 --> 00:08:18,480
processing unit actually you can run the

00:08:16,950 --> 00:08:19,860
connection automation it will connect it

00:08:18,480 --> 00:08:21,720
all together for you automatically and

00:08:19,860 --> 00:08:23,940
then you just write some software that

00:08:21,720 --> 00:08:25,380
actually configures that in the chain so

00:08:23,940 --> 00:08:28,080
it enables certain elements tells it

00:08:25,380 --> 00:08:30,420
there the height the height the width

00:08:28,080 --> 00:08:32,160
astride and suchlike and it will just

00:08:30,420 --> 00:08:34,290
run through and kind of work but

00:08:32,160 --> 00:08:37,350
eventually you're going to want to

00:08:34,290 --> 00:08:38,729
create your own IP which is where which

00:08:37,350 --> 00:08:40,830
is where it comes in and we could write

00:08:38,729 --> 00:08:42,599
it in VHDL or Verilog actually it's a

00:08:40,830 --> 00:08:44,310
lot better idea to just go away write in

00:08:42,599 --> 00:08:46,230
for dates processing things that we want

00:08:44,310 --> 00:08:48,420
to put in our alternate side of things

00:08:46,230 --> 00:08:51,030
it's much better to go away and write it

00:08:48,420 --> 00:08:54,450
in HLS if we can so high level symphysis

00:08:51,030 --> 00:08:56,130
allows us to work with C C++ open CV and

00:08:54,450 --> 00:08:57,330
it is a subset of C so that there are

00:08:56,130 --> 00:08:59,010
certain things that you can't use high

00:08:57,330 --> 00:09:00,690
level synthesis for you can't put system

00:08:59,010 --> 00:09:02,700
calls in there or accelerate libraries

00:09:00,690 --> 00:09:05,490
or anything like that but but generally

00:09:02,700 --> 00:09:07,830
actually it's not too difficult to take

00:09:05,490 --> 00:09:09,030
some C think about it a little bit read

00:09:07,830 --> 00:09:10,620
the rules a little bit and then

00:09:09,030 --> 00:09:13,290
accelerate it and go away and create

00:09:10,620 --> 00:09:14,490
your own sub system for this you do need

00:09:13,290 --> 00:09:15,720
a little bit of awareness of what's

00:09:14,490 --> 00:09:17,100
going off in the hardware to get the

00:09:15,720 --> 00:09:18,810
best performance out of it but you need

00:09:17,100 --> 00:09:20,160
to work you need to work out sort of for

00:09:18,810 --> 00:09:21,390
a lot of loops that you might have in

00:09:20,160 --> 00:09:22,860
there for loops for instance you might

00:09:21,390 --> 00:09:26,040
want to enroll memories you might want

00:09:22,860 --> 00:09:29,820
to fracture that but it's quite it is

00:09:26,040 --> 00:09:31,920
quite straightforward and when we work

00:09:29,820 --> 00:09:33,720
with HLS it gives us a few gives us a

00:09:31,920 --> 00:09:35,760
few libraries that we can have that will

00:09:33,720 --> 00:09:36,810
be accelerated into the programmable

00:09:35,760 --> 00:09:39,450
logic as well so we have the math

00:09:36,810 --> 00:09:41,610
library we can pull anything in that we

00:09:39,450 --> 00:09:42,960
want from the standard Vivaro library as

00:09:41,610 --> 00:09:44,340
well so if you've got fir filters or

00:09:42,960 --> 00:09:46,350
FFTs or something that you want to do

00:09:44,340 --> 00:09:47,820
you can you can pull that for you we've

00:09:46,350 --> 00:09:48,960
got linear algebra library

00:09:47,820 --> 00:09:50,250
which are really quite useful an

00:09:48,960 --> 00:09:53,100
arbitrary precision as well which allows

00:09:50,250 --> 00:09:54,570
you to have random wits of boss it says

00:09:53,100 --> 00:09:55,650
you're not stuck with eight or sixteen

00:09:54,570 --> 00:09:57,420
you can be more efficient in your

00:09:55,650 --> 00:09:59,520
hardware implementation have five or

00:09:57,420 --> 00:10:00,990
three or two but for this application

00:09:59,520 --> 00:10:02,310
today what we're really interested in is

00:10:00,990 --> 00:10:03,990
the two down the bottom the revision

00:10:02,310 --> 00:10:06,680
acceleration stack which really ties in

00:10:03,990 --> 00:10:10,650
with what Dan was talking about in SD so

00:10:06,680 --> 00:10:12,030
the Vivaro hls libraries which are which

00:10:10,650 --> 00:10:14,400
are very similar in the gap that gives

00:10:12,030 --> 00:10:17,130
us the ability to work with sort of open

00:10:14,400 --> 00:10:18,600
CV type commands with slight changes to

00:10:17,130 --> 00:10:19,890
the namespace and a little bit

00:10:18,600 --> 00:10:21,570
functionality actually just quickly and

00:10:19,890 --> 00:10:25,590
easily implement embedded vision

00:10:21,570 --> 00:10:27,780
applications so before I actually show

00:10:25,590 --> 00:10:29,340
you a little example of that I thought

00:10:27,780 --> 00:10:32,730
I'd walk you through exactly a really

00:10:29,340 --> 00:10:34,200
simple example of what HLI says so hls

00:10:32,730 --> 00:10:35,940
essentially goes through free processes

00:10:34,200 --> 00:10:37,290
when when it runs through that when it

00:10:35,940 --> 00:10:39,780
runs through the since it was your

00:10:37,290 --> 00:10:42,060
symphysis the first one is it works out

00:10:39,780 --> 00:10:43,830
what operations to perform on what clock

00:10:42,060 --> 00:10:45,030
edge so actually it does the timing it

00:10:43,830 --> 00:10:47,280
works out what the sequence of events

00:10:45,030 --> 00:10:49,470
can be the second operation it goes

00:10:47,280 --> 00:10:51,180
through is it takes the what it's worked

00:10:49,470 --> 00:10:52,890
as a sequence of events he takes the

00:10:51,180 --> 00:10:54,300
operations that are going off then it

00:10:52,890 --> 00:10:56,190
attempts to bind it into the logic

00:10:54,300 --> 00:10:57,690
resources that are available in the

00:10:56,190 --> 00:10:59,850
programmable logic side so it looks for

00:10:57,690 --> 00:11:02,340
things like DSP elements memory elements

00:10:59,850 --> 00:11:04,560
or what goes into the configurable logic

00:11:02,340 --> 00:11:07,110
blocks and then actually the final stage

00:11:04,560 --> 00:11:08,580
is it does the control logic extraction

00:11:07,110 --> 00:11:09,870
so he's not not a huge amount in this

00:11:08,580 --> 00:11:11,610
example but it will actually then work

00:11:09,870 --> 00:11:13,200
out the column then pull out the control

00:11:11,610 --> 00:11:15,120
logic to get the function working

00:11:13,200 --> 00:11:16,650
working as you want it to so in this

00:11:15,120 --> 00:11:20,760
example it's very simple example it's

00:11:16,650 --> 00:11:22,650
got X a B and C as inputs it goes

00:11:20,760 --> 00:11:24,270
through the through the stages and it

00:11:22,650 --> 00:11:26,880
works out that the tool works out it can

00:11:24,270 --> 00:11:30,270
do a X and B in one clock cycle and then

00:11:26,880 --> 00:11:32,100
it can do the final one addition of C on

00:11:30,270 --> 00:11:34,110
the second clock cycle and then provide

00:11:32,100 --> 00:11:36,120
the result on the third one so it goes

00:11:34,110 --> 00:11:38,040
through go through the initial binding

00:11:36,120 --> 00:11:39,540
works out what operations are going off

00:11:38,040 --> 00:11:42,090
and then it works out that it can add

00:11:39,540 --> 00:11:43,560
the first one to a DSP 48 and the second

00:11:42,090 --> 00:11:44,700
one to a add sub module which probably

00:11:43,560 --> 00:11:46,290
doesn't mean too much to you but he's

00:11:44,700 --> 00:11:47,820
he's actually working out what it what

00:11:46,290 --> 00:11:53,460
can go into the programmable logic there

00:11:47,820 --> 00:11:56,160
and how it can be used and that sort of

00:11:53,460 --> 00:11:57,750
that level of functionality actually

00:11:56,160 --> 00:11:58,920
allows us then to go away and start

00:11:57,750 --> 00:12:00,330
working with some of these libraries so

00:11:58,920 --> 00:12:03,480
this is an example

00:12:00,330 --> 00:12:06,300
of a HLI Sameach processing application

00:12:03,480 --> 00:12:09,120
that runs through and in sort of ten

00:12:06,300 --> 00:12:11,130
lines of code you can run through and

00:12:09,120 --> 00:12:13,890
create a really simple syllable filter

00:12:11,130 --> 00:12:16,110
that uses HLS to actually implement and

00:12:13,890 --> 00:12:17,940
drops into the drops and IP core into

00:12:16,110 --> 00:12:20,640
your into your processing chain in

00:12:17,940 --> 00:12:22,950
Vivaro you click build and out comes the

00:12:20,640 --> 00:12:26,190
other side so it's really really quite

00:12:22,950 --> 00:12:28,530
simple it's using pretty similar

00:12:26,190 --> 00:12:29,850
commands to what you see in open CV the

00:12:28,530 --> 00:12:38,370
obviously the differences it's using the

00:12:29,850 --> 00:12:39,720
HLS namespace but that's so far in our

00:12:38,370 --> 00:12:40,680
application really we've talked about

00:12:39,720 --> 00:12:42,330
sort of you've got to build it with

00:12:40,680 --> 00:12:43,680
Vivaro you've got to create you and IP

00:12:42,330 --> 00:12:46,500
what we really want to do is be able to

00:12:43,680 --> 00:12:47,880
actually actually do some system level

00:12:46,500 --> 00:12:49,770
optimization and actually not really

00:12:47,880 --> 00:12:51,180
worry too much about what's in there not

00:12:49,770 --> 00:12:53,700
do that segmentation ourself but

00:12:51,180 --> 00:12:55,860
initially developed the algorithm all in

00:12:53,700 --> 00:12:58,830
our language of preference C C++ or

00:12:55,860 --> 00:13:01,230
OpenGL and then actually use the system

00:12:58,830 --> 00:13:02,930
optimizing compiler like SD sock to

00:13:01,230 --> 00:13:06,960
allow us to move functions between the

00:13:02,930 --> 00:13:08,580
hardware and the software with ease so

00:13:06,960 --> 00:13:10,710
SD suck allows us to do that we can move

00:13:08,580 --> 00:13:12,900
between works of the Zink the MPs and

00:13:10,710 --> 00:13:14,190
obviously works with microblaze and

00:13:12,900 --> 00:13:16,080
really what it means is we can spend the

00:13:14,190 --> 00:13:17,420
time where it's much easier to do so in

00:13:16,080 --> 00:13:19,860
true sense in C we can write

00:13:17,420 --> 00:13:20,940
applications faster we can test it

00:13:19,860 --> 00:13:22,170
faster but we might not get the

00:13:20,940 --> 00:13:23,520
functional performance we want if we're

00:13:22,170 --> 00:13:25,110
doing an image processing pipeline we

00:13:23,520 --> 00:13:27,330
might want 50 frames per second flowing

00:13:25,110 --> 00:13:28,620
through it when we write it all in C and

00:13:27,330 --> 00:13:30,720
we run it on the AP use you know we

00:13:28,620 --> 00:13:32,250
might not get that but we can it allows

00:13:30,720 --> 00:13:33,780
us to prove out the functionality of it

00:13:32,250 --> 00:13:35,730
very quickly and very easily and then we

00:13:33,780 --> 00:13:37,980
can take you we can then once we've got

00:13:35,730 --> 00:13:40,410
that functionality off we're fairly

00:13:37,980 --> 00:13:42,030
happy that the algorithms as we want

00:13:40,410 --> 00:13:43,230
them to be we can then do some

00:13:42,030 --> 00:13:44,250
performance we can analyze the

00:13:43,230 --> 00:13:46,590
bottlenecks and we can start

00:13:44,250 --> 00:13:49,110
accelerating them in from the running on

00:13:46,590 --> 00:13:52,470
the PS into the pl an SD sock allows us

00:13:49,110 --> 00:13:54,060
to do exactly that and so the

00:13:52,470 --> 00:13:55,980
performance goes up and a compile time

00:13:54,060 --> 00:13:58,500
go slightly up as well so you just have

00:13:55,980 --> 00:14:02,310
to go get a cup of tea or get a beer or

00:13:58,500 --> 00:14:04,140
something while it while it works so

00:14:02,310 --> 00:14:06,270
this is this is the this is the example

00:14:04,140 --> 00:14:08,160
step really init it just allows you to

00:14:06,270 --> 00:14:10,830
it shows you how you can iterate around

00:14:08,160 --> 00:14:12,420
from doing the system system profiling

00:14:10,830 --> 00:14:13,810
to actually working out what your

00:14:12,420 --> 00:14:16,089
acceleration functions are

00:14:13,810 --> 00:14:19,029
and moving them across into the into the

00:14:16,089 --> 00:14:20,170
programmable logic how it does this is

00:14:19,029 --> 00:14:22,269
actually really quite clever actually

00:14:20,170 --> 00:14:23,139
done might have talked about this a

00:14:22,269 --> 00:14:24,370
little bit but how it just is really

00:14:23,139 --> 00:14:26,230
quite clever so the first thing you do

00:14:24,370 --> 00:14:28,089
is actually calls the you've identified

00:14:26,230 --> 00:14:30,129
your functions that you want it will

00:14:28,089 --> 00:14:31,389
then it will call the Vivaro hli so it

00:14:30,129 --> 00:14:33,220
will call the tool that i was talking

00:14:31,389 --> 00:14:36,910
about previously the example i used for

00:14:33,220 --> 00:14:38,139
the sobel filter it will call that so it

00:14:36,910 --> 00:14:40,990
will call that tool that will go away it

00:14:38,139 --> 00:14:42,100
will create an IP block for you what it

00:14:40,990 --> 00:14:43,509
also does is at the same time it

00:14:42,100 --> 00:14:45,610
analyzes communication so what you

00:14:43,509 --> 00:14:47,769
really want to do is move big chunks of

00:14:45,610 --> 00:14:49,089
data between the PS and the pl you don't

00:14:47,769 --> 00:14:50,740
want to be sending in sort of ten bytes

00:14:49,089 --> 00:14:52,930
or sixteen bytes you want to be moving

00:14:50,740 --> 00:14:56,079
as much as you possibly can from the

00:14:52,930 --> 00:14:57,699
from the PS to the peel once it's

00:14:56,079 --> 00:14:59,800
analyzed like communication it works out

00:14:57,699 --> 00:15:01,120
how it's going to create essentially the

00:14:59,800 --> 00:15:02,199
communication interface that you need so

00:15:01,120 --> 00:15:03,970
it's going to put in there the DMA

00:15:02,199 --> 00:15:06,939
infrastructure the DMA engines that you

00:15:03,970 --> 00:15:08,230
need and and do that transfer for you

00:15:06,939 --> 00:15:10,240
and then it's good actually it's not

00:15:08,230 --> 00:15:11,649
actually generate a new software stub so

00:15:10,240 --> 00:15:13,120
where's your function where's your

00:15:11,649 --> 00:15:15,249
function that you've accelerated was

00:15:13,120 --> 00:15:16,660
actually performing the function SD sort

00:15:15,249 --> 00:15:19,149
what and it needs that function to

00:15:16,660 --> 00:15:21,160
actually now be there to drive the data

00:15:19,149 --> 00:15:22,569
on into the programmable logic and then

00:15:21,160 --> 00:15:25,000
pull it back out with the with the

00:15:22,569 --> 00:15:26,680
correct results so it updates it updates

00:15:25,000 --> 00:15:28,569
the software so plays it quite a quite a

00:15:26,680 --> 00:15:32,769
lot going on under the hood it's really

00:15:28,569 --> 00:15:33,579
really quite clever I'll skip this or

00:15:32,769 --> 00:15:35,559
actually now I'm not going to give this

00:15:33,579 --> 00:15:37,839
one so what what essentially it does is

00:15:35,559 --> 00:15:39,639
we can work use it with Linux we can use

00:15:37,839 --> 00:15:41,559
a bare metal and free artists what's

00:15:39,639 --> 00:15:43,389
really quite cool as you can do that you

00:15:41,559 --> 00:15:45,819
can use quim or if you've got quim you

00:15:43,389 --> 00:15:47,350
can remember up and want an RTL cure

00:15:45,819 --> 00:15:49,360
simulation between the two so as you can

00:15:47,350 --> 00:15:53,170
see the two actually actually working

00:15:49,360 --> 00:15:54,519
hand-in-hand and I think the later the

00:15:53,170 --> 00:15:57,670
loose version does have OpenCL

00:15:54,519 --> 00:16:00,670
what I did actually on my blog is fpga

00:15:57,670 --> 00:16:03,040
congress back this year i run a one day

00:16:00,670 --> 00:16:04,480
course on how you do SD so so all the

00:16:03,040 --> 00:16:06,339
slides actually if you go to my blog

00:16:04,480 --> 00:16:08,079
site from from that if you want more

00:16:06,339 --> 00:16:11,259
introduction now actually actually on

00:16:08,079 --> 00:16:13,389
there so how he does it

00:16:11,259 --> 00:16:14,439
i'm not going to step through all this

00:16:13,389 --> 00:16:15,759
but how it does it's quite it's quite

00:16:14,439 --> 00:16:17,620
exciting it's quite exciting obviously

00:16:15,759 --> 00:16:21,160
down the block in the yellow down there

00:16:17,620 --> 00:16:24,300
you've got your HLS IP component that

00:16:21,160 --> 00:16:27,339
you've accelerated the orange colored

00:16:24,300 --> 00:16:30,009
elements are blocks that have been put

00:16:27,339 --> 00:16:31,509
in as part of the the data communication

00:16:30,009 --> 00:16:34,149
path that's done from the communication

00:16:31,509 --> 00:16:36,100
analysis and then the green blocks are

00:16:34,149 --> 00:16:38,110
blocks that have been put in there as

00:16:36,100 --> 00:16:40,029
part of a software so it configures the

00:16:38,110 --> 00:16:43,569
DMA waits for it to be done cause the

00:16:40,029 --> 00:16:44,980
accelerator and such like that slide

00:16:43,569 --> 00:16:47,110
should be animated but I think he's gone

00:16:44,980 --> 00:17:03,100
slightly wrong in the Google the Google

00:16:47,110 --> 00:17:04,709
Drive that we that was seen here so I'm

00:17:03,100 --> 00:17:06,760
gonna wrap it up because we're kind of

00:17:04,709 --> 00:17:07,899
running a bit ahead but if you want to

00:17:06,760 --> 00:17:09,970
if you want to accelerate things

00:17:07,899 --> 00:17:10,929
obviously you come you need to think

00:17:09,970 --> 00:17:12,149
about what you can accelerate can't

00:17:10,929 --> 00:17:14,589
accelerate libraries and ice calls

00:17:12,149 --> 00:17:16,299
there's a law called arm doors law which

00:17:14,589 --> 00:17:17,470
is a really great exact really great

00:17:16,299 --> 00:17:19,000
thing to use if you want to work out

00:17:17,470 --> 00:17:19,839
what sort of benefit of acceleration

00:17:19,000 --> 00:17:22,649
you're going to get from moving

00:17:19,839 --> 00:17:24,760
something from the from the PS to the PL

00:17:22,649 --> 00:17:26,260
I've explained it a little bit more on

00:17:24,760 --> 00:17:27,370
that slide for any but I'm not read for

00:17:26,260 --> 00:17:28,960
it but is the hell and that's life

00:17:27,370 --> 00:17:32,740
anybody wants to read foon to work out

00:17:28,960 --> 00:17:34,000
what the actual equations are and but if

00:17:32,740 --> 00:17:35,710
you want to know more about this it's

00:17:34,000 --> 00:17:37,000
been quite rushed just we over run a bid

00:17:35,710 --> 00:17:38,620
and we've had a few technical problems

00:17:37,000 --> 00:17:39,880
but if you want to know more about how

00:17:38,620 --> 00:17:42,669
to use your tonight 16 some of these

00:17:39,880 --> 00:17:44,320
applications I've got a series of hacks

00:17:42,669 --> 00:17:46,179
to project showing how to use this to

00:17:44,320 --> 00:17:47,830
hack for how to do the simple things

00:17:46,179 --> 00:17:49,570
such as how to create the petal index

00:17:47,830 --> 00:17:51,970
barrier image from literally from

00:17:49,570 --> 00:17:54,490
nothing and building it all building it

00:17:51,970 --> 00:17:56,140
all the way up or to actually updating

00:17:54,490 --> 00:17:57,700
the paralytics image if you if you've

00:17:56,140 --> 00:17:59,080
done some builds there's a couple of

00:17:57,700 --> 00:18:01,419
examples on there so I mean some

00:17:59,080 --> 00:18:03,610
internet I Internet of Things examples

00:18:01,419 --> 00:18:05,440
and there's obviously a weekly my weekly

00:18:03,610 --> 00:18:08,289
blog that updates on how to use this

00:18:05,440 --> 00:18:11,440
what's really cool though is next when's

00:18:08,289 --> 00:18:13,299
Tuesday we've got a hello ultra 96

00:18:11,440 --> 00:18:16,330
getting started with a session so free

00:18:13,299 --> 00:18:18,429
free labs essentially going from nothing

00:18:16,330 --> 00:18:20,039
all the way through to sort of the bare

00:18:18,429 --> 00:18:22,179
metal approach all the way through to

00:18:20,039 --> 00:18:24,730
creating web apps and running web apps

00:18:22,179 --> 00:18:27,789
on the on the old 496 that's next

00:18:24,730 --> 00:18:28,870
Tuesday at 8 a.m. I think and it's gonna

00:18:27,789 --> 00:18:30,159
be really I think it's going to be

00:18:28,870 --> 00:18:31,330
really quite a good thing to actually do

00:18:30,159 --> 00:18:33,669
there's a lot of people registered for

00:18:31,330 --> 00:18:34,990
it so far so I'm quite looking forward

00:18:33,669 --> 00:18:36,780
to presenting that and it'll be a lot

00:18:34,990 --> 00:18:39,490
better than this session I promise you

00:18:36,780 --> 00:18:40,400
and with that guys I'll ask any L

00:18:39,490 --> 00:18:44,110
answered Train answer

00:18:40,400 --> 00:18:44,110
any questions of that you might have got

00:18:58,070 --> 00:19:01,560
you

00:18:58,930 --> 00:19:06,569
[Applause]

00:19:01,560 --> 00:19:06,569

YouTube URL: https://www.youtube.com/watch?v=36rOja0064c


