Title: YVR18-119:52 shades of VA (Virtual Address Space)
Publication date: 2019-05-09
Playlist: Linaro Connect Vancouver 2018
Description: 
	On 64-bit Arm kernels we currently support up to 48-bits of virtual address space. However, ARMv8.2-LVA introduces the capability to have 52-bit virtual addresses. In this talk I aim to briefly introduce this architectural feature and will then talk through the kernel work so far in exposing this to userspace.
Captions: 
	00:00:02,070 --> 00:00:07,080
[Music]

00:00:07,950 --> 00:00:14,650
it's 4:30 now and this is the last

00:00:11,530 --> 00:00:17,050
session of the day so I'll crack on and

00:00:14,650 --> 00:00:17,590
go through things so for those who don't

00:00:17,050 --> 00:00:20,230
know me

00:00:17,590 --> 00:00:22,390
hello my name is Steve Kappa I work with

00:00:20,230 --> 00:00:28,060
the enterprise software teams within our

00:00:22,390 --> 00:00:31,330
and this talk is about the kernel

00:00:28,060 --> 00:00:34,870
enablement of 52 bits of virtual address

00:00:31,330 --> 00:00:38,200
spaces and so I will begin the talk by

00:00:34,870 --> 00:00:41,170
introducing 52 bit virtual addresses and

00:00:38,200 --> 00:00:43,570
there now go through the aspects of the

00:00:41,170 --> 00:00:46,440
kernel work so far it's a sort of a

00:00:43,570 --> 00:00:49,600
status update

00:00:46,440 --> 00:00:53,380
so the architectural support for 52 bit

00:00:49,600 --> 00:00:55,600
virtual addresses is an extension that

00:00:53,380 --> 00:01:00,010
has been added after the main ARM

00:00:55,600 --> 00:01:03,399
architecture was thank you so the main

00:01:00,010 --> 00:01:05,860
ARM architecture started with 48 bits

00:01:03,399 --> 00:01:10,870
virtual addresses as the maximum size

00:01:05,860 --> 00:01:15,909
and 52 bits was added in arm 8.2 as an

00:01:10,870 --> 00:01:19,060
optional extension now 52 bits can only

00:01:15,909 --> 00:01:22,960
be utilized at the moment when one is

00:01:19,060 --> 00:01:28,120
running with a 64 kilobytes page size or

00:01:22,960 --> 00:01:30,040
granule and Intel have similar

00:01:28,120 --> 00:01:31,990
extensions to their virtual address

00:01:30,040 --> 00:01:35,680
space where they have I understand was

00:01:31,990 --> 00:01:38,680
at 56 bit and the way insulative this is

00:01:35,680 --> 00:01:43,390
by adding another level of translation

00:01:38,680 --> 00:01:46,570
now with arm we do not add a level of

00:01:43,390 --> 00:01:52,180
translation everyone segoe from 48 bits

00:01:46,570 --> 00:01:55,390
to 52 bit our first level our PG DS just

00:01:52,180 --> 00:01:58,360
gets a little bit bigger so the salient

00:01:55,390 --> 00:02:01,450
point for 52 bit virtual addresses which

00:01:58,360 --> 00:02:03,670
is for the kernel is we do not change

00:02:01,450 --> 00:02:05,500
the number of levels of translation we

00:02:03,670 --> 00:02:08,200
just make the first level a little bit

00:02:05,500 --> 00:02:11,860
bigger so this means the kernel support

00:02:08,200 --> 00:02:18,040
looks a little bit different to the

00:02:11,860 --> 00:02:21,730
in cell extensions for 56-bit so in

00:02:18,040 --> 00:02:24,940
Linux I simplify things with virtual

00:02:21,730 --> 00:02:28,600
addresses for Linux I consider virtual

00:02:24,940 --> 00:02:31,270
addresses within the kernel and I

00:02:28,600 --> 00:02:34,420
consider virtual addresses within

00:02:31,270 --> 00:02:39,010
applications and both of these can be

00:02:34,420 --> 00:02:41,580
extended to 52 bit so in the kernel the

00:02:39,010 --> 00:02:44,290
principle reason one would want 52 bits

00:02:41,580 --> 00:02:46,959
virtual addresses is to be able to

00:02:44,290 --> 00:02:49,510
address a significant amount of physical

00:02:46,959 --> 00:02:52,989
memory now one thing that is worth

00:02:49,510 --> 00:02:56,680
mentioning now is that in the kernel one

00:02:52,989 --> 00:03:00,130
can already address fifty-two physical

00:02:56,680 --> 00:03:04,450
bits so 52 bit physical address support

00:03:00,130 --> 00:03:07,030
is in the kernel for virtual addresses

00:03:04,450 --> 00:03:08,890
one would use this in the kernel if they

00:03:07,030 --> 00:03:11,110
had a large amounts of memory in

00:03:08,890 --> 00:03:14,110
different places and the direct linear

00:03:11,110 --> 00:03:16,750
mapping was very big so there's nothing

00:03:14,110 --> 00:03:19,840
in the kernel blocking physical

00:03:16,750 --> 00:03:22,180
addresses that are 52 bit if we wish to

00:03:19,840 --> 00:03:24,310
introduce 52 bit virtual address support

00:03:22,180 --> 00:03:27,610
to the kernel it is a little bit

00:03:24,310 --> 00:03:30,970
complicated because in the kernel we

00:03:27,610 --> 00:03:33,780
have a baked in assumptions about the

00:03:30,970 --> 00:03:36,790
number of virtual address bits being

00:03:33,780 --> 00:03:37,420
constant so in the kernel we have a VA

00:03:36,790 --> 00:03:42,250
bits

00:03:37,420 --> 00:03:44,530
constants and this determines how data

00:03:42,250 --> 00:03:47,620
is stored in the kernel to facilitate

00:03:44,530 --> 00:03:52,120
translation for whatever the VA bit says

00:03:47,620 --> 00:03:54,970
that now kernel is is quite hard to do

00:03:52,120 --> 00:03:56,530
we also have to consider user space and

00:03:54,970 --> 00:04:00,130
this actually might be more interesting

00:03:56,530 --> 00:04:02,769
for most of the audience so with user

00:04:00,130 --> 00:04:04,330
space again we may wish to just deal

00:04:02,769 --> 00:04:07,330
with a large amount of memory and the

00:04:04,330 --> 00:04:10,000
application user space virtual addresses

00:04:07,330 --> 00:04:13,140
are significantly easier to implement in

00:04:10,000 --> 00:04:16,000
the kernel because they do not require

00:04:13,140 --> 00:04:18,190
modifying a lot of the kernel structures

00:04:16,000 --> 00:04:22,120
it's a lot simpler the implementation as

00:04:18,190 --> 00:04:25,300
a consequence of this I have to patch

00:04:22,120 --> 00:04:26,919
series that deal with 52

00:04:25,300 --> 00:04:29,860
we have a patch series that deals with

00:04:26,919 --> 00:04:32,470
Colonel virtual addresses and we have an

00:04:29,860 --> 00:04:35,440
independent patch series which deals

00:04:32,470 --> 00:04:41,759
with user space 52 bit virtual address

00:04:35,440 --> 00:04:44,590
support so I'll start with colonel so I

00:04:41,759 --> 00:04:47,650
said before we have a few constants

00:04:44,590 --> 00:04:51,789
which are derived from the VA bits

00:04:47,650 --> 00:04:55,569
constant with Linux in general we wish

00:04:51,789 --> 00:04:58,509
to have a single kernel image that runs

00:04:55,569 --> 00:05:01,930
on multiple machines so we can't

00:04:58,509 --> 00:05:04,509
statically compiled 50 two-bit support

00:05:01,930 --> 00:05:07,150
for a kernel because it might run on an

00:05:04,509 --> 00:05:10,720
older system that doesn't have 52 bit

00:05:07,150 --> 00:05:15,490
support and so it won't work so the 52

00:05:10,720 --> 00:05:20,050
bit support needs to be dynamic at boot

00:05:15,490 --> 00:05:22,539
time when extending the kernel VA space

00:05:20,050 --> 00:05:25,060
size in the kernel we have to go along

00:05:22,539 --> 00:05:27,940
and D Const if I a few things so a few

00:05:25,060 --> 00:05:31,840
things that's a constant become variable

00:05:27,940 --> 00:05:33,909
and we also have to change the way we

00:05:31,840 --> 00:05:37,030
arrange the memory so I'm going to very

00:05:33,909 --> 00:05:38,830
briefly go through the D cons defying so

00:05:37,030 --> 00:05:40,810
the patches makes sense and I'm going to

00:05:38,830 --> 00:05:45,819
very briefly go through how we rearrange

00:05:40,810 --> 00:05:49,360
the memory for the kernel side so decon

00:05:45,819 --> 00:05:52,199
stuff eying at the moment in the kernel

00:05:49,360 --> 00:05:56,139
we just have a single VA bits constant

00:05:52,199 --> 00:05:57,900
now if our virtual address size is

00:05:56,139 --> 00:06:02,319
determined at boot time it can no longer

00:05:57,900 --> 00:06:05,800
just be one constant so in the current

00:06:02,319 --> 00:06:08,620
patch series that I have we have a

00:06:05,800 --> 00:06:11,440
maximum number of VA bits as a constant

00:06:08,620 --> 00:06:13,900
we have the minimum number of VA bits as

00:06:11,440 --> 00:06:16,479
a constant and we have the actual number

00:06:13,900 --> 00:06:19,690
of Eve a bits as a variable and this

00:06:16,479 --> 00:06:22,120
actually significantly minimizes the

00:06:19,690 --> 00:06:24,699
disruptions of the rest of the kernel so

00:06:22,120 --> 00:06:27,069
data structures can use a constant which

00:06:24,699 --> 00:06:30,130
is the maximum when we're doing things

00:06:27,069 --> 00:06:32,409
like efi memory mapping we do the worst

00:06:30,130 --> 00:06:33,569
case scenario for distance using the

00:06:32,409 --> 00:06:36,839
minimum

00:06:33,569 --> 00:06:39,270
and the actual we use where we actually

00:06:36,839 --> 00:06:44,240
need to know how many VA bits we have at

00:06:39,270 --> 00:06:49,740
runtime I'm going to quickly go through

00:06:44,240 --> 00:06:52,649
the kernel memory map so on Linux the

00:06:49,740 --> 00:06:54,179
kernel memory map is undocumented

00:06:52,649 --> 00:06:56,580
because it's subject to change

00:06:54,179 --> 00:07:00,209
I'm putting the kernel memory map up

00:06:56,580 --> 00:07:03,360
here so you just show how the 52 bit

00:07:00,209 --> 00:07:06,569
support changes things in the kernel so

00:07:03,360 --> 00:07:09,749
the important points that I'd like to

00:07:06,569 --> 00:07:12,569
convey in this slide with the virtual

00:07:09,749 --> 00:07:14,550
address memory map in the kernel half of

00:07:12,569 --> 00:07:16,889
the memory space in the kernel is

00:07:14,550 --> 00:07:19,709
dedicated to the direct linear map and

00:07:16,889 --> 00:07:22,459
this is used by the kernel to address

00:07:19,709 --> 00:07:26,490
all the physical memory in the system

00:07:22,459 --> 00:07:28,889
the rest the other half of the virtual

00:07:26,490 --> 00:07:30,990
address map is split up for everything

00:07:28,889 --> 00:07:34,409
else so we have the direct linear map

00:07:30,990 --> 00:07:37,529
and everything else now with this

00:07:34,409 --> 00:07:41,399
particular diagram if we change from 48

00:07:37,529 --> 00:07:45,749
bits to 52 bits all these addresses here

00:07:41,399 --> 00:07:49,529
will move about now in the kernel it's

00:07:45,749 --> 00:07:51,180
not advisable to try and move the text

00:07:49,529 --> 00:07:53,879
segments and all the function addresses

00:07:51,180 --> 00:07:56,159
around when running with a different

00:07:53,879 --> 00:07:58,860
virtual address size so if we can keep

00:07:56,159 --> 00:08:00,990
those constant it actually make life a

00:07:58,860 --> 00:08:04,379
lot easier for the code and make the

00:08:00,990 --> 00:08:08,879
patches a lot less invasive so what I

00:08:04,379 --> 00:08:11,959
decided to do was to swap so the direct

00:08:08,879 --> 00:08:15,539
linear map now in the 48 bit case

00:08:11,959 --> 00:08:17,309
occupies the lower addresses and

00:08:15,539 --> 00:08:20,459
everything else occupies the higher

00:08:17,309 --> 00:08:24,209
addresses the advantage of doing this is

00:08:20,459 --> 00:08:28,289
when we switch to 52 bits all these bits

00:08:24,209 --> 00:08:30,930
in gray at the bottom match up so we can

00:08:28,289 --> 00:08:35,219
boots and 52 bit with very little change

00:08:30,930 --> 00:08:37,349
and the K Sun region we route that at

00:08:35,219 --> 00:08:39,870
the bottom and it just expands upwards

00:08:37,349 --> 00:08:42,029
in this diagram the important point here

00:08:39,870 --> 00:08:44,760
is the direct linear map is now

00:08:42,029 --> 00:08:46,139
significantly bigger and this is what we

00:08:44,760 --> 00:08:47,370
want this is a whole reason we want the

00:08:46,139 --> 00:08:49,040
00:08:47,370 --> 00:08:51,720
is to have a bigger direct linear map

00:08:49,040 --> 00:08:53,940
one negative aspects with this

00:08:51,720 --> 00:08:57,120
particular approach is that we have a

00:08:53,940 --> 00:08:59,250
gap here now in this diagram this gap

00:08:57,120 --> 00:09:01,260
doesn't look very big but in real life

00:08:59,250 --> 00:09:04,950
this gap is five times bigger than all

00:09:01,260 --> 00:09:07,430
that so there's room for finessing this

00:09:04,950 --> 00:09:09,750
option but the basic principle of

00:09:07,430 --> 00:09:13,770
flipping the address space round and

00:09:09,750 --> 00:09:22,350
growing it upwards in this diagram is is

00:09:13,770 --> 00:09:27,030
the approach we're taking so I'll talk

00:09:22,350 --> 00:09:30,690
now about 52 bits user space virtual

00:09:27,030 --> 00:09:33,900
addresses now as I said before to

00:09:30,690 --> 00:09:35,540
implement 52 bit user space addresses in

00:09:33,900 --> 00:09:38,370
the kernel it's significantly easier

00:09:35,540 --> 00:09:41,040
because unarmed we have separate

00:09:38,370 --> 00:09:44,720
translation regimes for user space and

00:09:41,040 --> 00:09:48,390
kernel so we can just tweak a register

00:09:44,720 --> 00:09:52,620
make sure everything's big enough and do

00:09:48,390 --> 00:09:55,080
things safely so the user space patches

00:09:52,620 --> 00:09:56,760
for this are quite simple the

00:09:55,080 --> 00:09:59,100
interesting thing that I'd like to go

00:09:56,760 --> 00:10:03,450
through which probably is of use to

00:09:59,100 --> 00:10:08,220
everyone here is how user space virtual

00:10:03,450 --> 00:10:11,420
addresses are advertised so as I said

00:10:08,220 --> 00:10:15,870
before when arm version 8 was introduced

00:10:11,420 --> 00:10:19,440
the assumption was that 48 bits was the

00:10:15,870 --> 00:10:22,230
maximum virtual address size there is

00:10:19,440 --> 00:10:26,880
unfortunately software that makes use of

00:10:22,230 --> 00:10:29,760
that assumption so when we extend the

00:10:26,880 --> 00:10:31,590
virtual address by size 252 bit we have

00:10:29,760 --> 00:10:34,920
to maintain compatibility with the

00:10:31,590 --> 00:10:37,290
legacy software so the way we maintain

00:10:34,920 --> 00:10:41,400
compatibility of the legacy software is

00:10:37,290 --> 00:10:44,760
to allow newer software to provide a

00:10:41,400 --> 00:10:48,150
hint to the kernel saying please give me

00:10:44,760 --> 00:10:51,360
a 52 bit virtual address instead of just

00:10:48,150 --> 00:10:54,120
a 48-bit virtual address and the idea is

00:10:51,360 --> 00:10:57,300
this hint is only employed by software

00:10:54,120 --> 00:10:59,459
that knows about it and the rest of the

00:10:57,300 --> 00:11:03,899
software just

00:10:59,459 --> 00:11:07,829
restricted back to 48 bass so what we do

00:11:03,899 --> 00:11:11,970
is with the kernel patches with the EM

00:11:07,829 --> 00:11:14,999
map Cisco there is an address hint and

00:11:11,970 --> 00:11:19,050
parameter most people just put zero in

00:11:14,999 --> 00:11:22,559
there as a hint but if one were to put a

00:11:19,050 --> 00:11:26,369
hint in there with the top bits here as

00:11:22,559 --> 00:11:29,220
non zero then the memory allocator will

00:11:26,369 --> 00:11:31,529
give a much bigger range back to the

00:11:29,220 --> 00:11:34,499
user space and this is currently being

00:11:31,529 --> 00:11:37,769
reviewed John suggested a tweak to this

00:11:34,499 --> 00:11:41,519
but this particular scheme of hinting

00:11:37,769 --> 00:11:45,300
for a high address is employed currently

00:11:41,519 --> 00:11:49,800
by x86 and PowerPC so it's quite likely

00:11:45,300 --> 00:11:53,069
the way we do things so just to clarify

00:11:49,800 --> 00:11:55,470
as well when we fire up a Linux process

00:11:53,069 --> 00:11:58,050
we get things like shared objects

00:11:55,470 --> 00:11:59,759
executable segments and everything they

00:11:58,050 --> 00:12:04,079
get em mapped by the Linux loader

00:11:59,759 --> 00:12:06,600
automatically with 52 bit support they

00:12:04,079 --> 00:12:08,660
get mapped in the exact same place so

00:12:06,600 --> 00:12:12,509
there's no perceivable difference

00:12:08,660 --> 00:12:15,209
similarly the stack and V DSO and

00:12:12,509 --> 00:12:17,970
everything else it all just looks like a

00:12:15,209 --> 00:12:22,079
48-bit system so we try our best to

00:12:17,970 --> 00:12:25,049
maintain compatibility with 52 bit so

00:12:22,079 --> 00:12:29,339
just to summarize again what I said if

00:12:25,049 --> 00:12:31,860
we are writing software and we are

00:12:29,339 --> 00:12:34,649
controlling the source of our pointers

00:12:31,860 --> 00:12:37,889
so we perform memory allocation with M

00:12:34,649 --> 00:12:40,230
map or malloc or whatever then it's

00:12:37,889 --> 00:12:45,029
maintain compatibility with 52 bit

00:12:40,230 --> 00:12:48,329
support should be okay the time to worry

00:12:45,029 --> 00:12:50,639
about 52 bit support is if we are

00:12:48,329 --> 00:12:54,600
accepting pointers from somewhere else

00:12:50,639 --> 00:12:57,360
so rewriting a library and we are making

00:12:54,600 --> 00:13:00,569
assumptions about our virtual addresses

00:12:57,360 --> 00:13:02,699
being 48 bits then we might have a bad

00:13:00,569 --> 00:13:07,410
time with a 52 bit support

00:13:02,699 --> 00:13:09,480
similarly on x86 with 56 bit support and

00:13:07,410 --> 00:13:11,970
other architecture as well so

00:13:09,480 --> 00:13:15,120
this particular point is of more

00:13:11,970 --> 00:13:18,029
interest to people who write shits and

00:13:15,120 --> 00:13:22,560
people who write instrumentation tools

00:13:18,029 --> 00:13:25,800
that's employ points are tagging if one

00:13:22,560 --> 00:13:27,510
employees points are tagging they should

00:13:25,800 --> 00:13:31,050
be careful with the 52 bit support

00:13:27,510 --> 00:13:36,930
basically but mostly everything else

00:13:31,050 --> 00:13:40,740
should function as normal so the current

00:13:36,930 --> 00:13:43,649
status of the 52 bit support we have as

00:13:40,740 --> 00:13:47,399
I mentioned before a patch set for the

00:13:43,649 --> 00:13:50,610
kernel space 52 bits and a patch set for

00:13:47,399 --> 00:13:52,889
user space 52 bits now if one is

00:13:50,610 --> 00:13:56,310
interested in testing their software for

00:13:52,889 --> 00:13:58,589
52 bit compatibility they just need to

00:13:56,310 --> 00:14:02,959
take the second patch set and run it in

00:13:58,589 --> 00:14:02,959
a suitable platform that has the support

00:14:04,220 --> 00:14:11,070
and that is everything from my side is a

00:14:08,370 --> 00:14:15,470
very quick update for 52 bit I'm happy

00:14:11,070 --> 00:14:15,470
to take any questions on the microphone

00:14:19,130 --> 00:14:23,910
so I worked with more core

00:14:21,660 --> 00:14:26,760
implementation for a leave huge TLB just

00:14:23,910 --> 00:14:29,160
for oh no I just fix it not that I'd

00:14:26,760 --> 00:14:31,079
created it but my question is is this

00:14:29,160 --> 00:14:34,649
going to break it because it implements

00:14:31,079 --> 00:14:36,209
its own or more core for my walk so do

00:14:34,649 --> 00:14:38,569
you see that you have to have a new

00:14:36,209 --> 00:14:41,310
wrapper for my walk right calling mmm

00:14:38,569 --> 00:14:44,010
with the right flag I mean to have their

00:14:41,310 --> 00:14:46,740
new address space yeah so the any

00:14:44,010 --> 00:14:50,250
extensions to more core as long as they

00:14:46,740 --> 00:14:54,300
don't provide a high address in the end

00:14:50,250 --> 00:14:55,589
map parameter which I don't can't think

00:14:54,300 --> 00:14:57,149
of any reason why they would unless

00:14:55,589 --> 00:15:04,529
someone's put minus one in or something

00:14:57,149 --> 00:15:07,889
which they shouldn't do anyway without

00:15:04,529 --> 00:15:11,100
memory map like this break if you'll

00:15:07,889 --> 00:15:12,839
grow the rip the heap without a map with

00:15:11,100 --> 00:15:14,910
earth break oh yeah yeah yeah

00:15:12,839 --> 00:15:18,360
is there a problem so let's break we

00:15:14,910 --> 00:15:20,610
just gave this standard 48 okay it's

00:15:18,360 --> 00:15:22,300
literally the only code path the changes

00:15:20,610 --> 00:15:25,480
is the implement

00:15:22,300 --> 00:15:34,180
Asian it looks for the address and then

00:15:25,480 --> 00:15:37,300
yeah can we go back a last slide yep

00:15:34,180 --> 00:15:38,020
so when you talk about to test the use

00:15:37,300 --> 00:15:44,050
of space

00:15:38,020 --> 00:15:46,600
52 piece so we just a margin the total

00:15:44,050 --> 00:15:49,720
of five matches were only the first one

00:15:46,600 --> 00:15:52,120
patch so it's testing user space we just

00:15:49,720 --> 00:15:55,840
need these five patches that were posted

00:15:52,120 --> 00:15:58,540
I think several weeks ago and a system

00:15:55,840 --> 00:16:01,600
or a model that provides our mate points

00:15:58,540 --> 00:16:08,980
to support okay so what the five patches

00:16:01,600 --> 00:16:13,810
are needed right just this Hey asking

00:16:08,980 --> 00:16:22,180
for a friend with em switched into 52

00:16:13,810 --> 00:16:28,420
bit allocations based on size what size

00:16:22,180 --> 00:16:30,880
hints address basically John masters

00:16:28,420 --> 00:16:33,340
found a book that we're gonna fix

00:16:30,880 --> 00:16:35,770
whereby what you could do is you could

00:16:33,340 --> 00:16:37,870
provide a low address and a really big

00:16:35,770 --> 00:16:40,420
size yeah and then you get an allocation

00:16:37,870 --> 00:16:43,060
that goes to the full 52 bit and that's

00:16:40,420 --> 00:16:46,000
wrong so that's being changed to

00:16:43,060 --> 00:16:48,790
maintain full compatibility with the 48

00:16:46,000 --> 00:16:50,500
bit case so what'll happen is if one

00:16:48,790 --> 00:16:53,170
asks for something that's too big to fit

00:16:50,500 --> 00:16:55,390
in the 48 bit range but they have an

00:16:53,170 --> 00:16:57,250
address hint within the 48 bit range

00:16:55,390 --> 00:16:58,870
then their map will tell them to go away

00:16:57,250 --> 00:17:00,160
with an error message which is what it

00:16:58,870 --> 00:17:02,170
does currently so that's just a

00:17:00,160 --> 00:17:03,250
maintaining compatibility I'm sure my

00:17:02,170 --> 00:17:06,150
friend will rest easy

00:17:03,250 --> 00:17:06,150
thank you yeah

00:17:11,960 --> 00:17:18,840
so a couple of bits in your diagram had

00:17:14,640 --> 00:17:23,280
51 bit things yeah yes because it's half

00:17:18,840 --> 00:17:26,070
452 so this is this is 48 bits this is

00:17:23,280 --> 00:17:29,160
half of the 48 bit range this is 52 bits

00:17:26,070 --> 00:17:32,640
this is half of the 52 bit range and the

00:17:29,160 --> 00:17:34,890
hidden things at 51 : 48 yeah so the

00:17:32,640 --> 00:17:38,100
hints address so if you provide an nmap

00:17:34,890 --> 00:17:41,340
address which is too big to fit it's

00:17:38,100 --> 00:17:52,410
just like here or upwards then it'll

00:17:41,340 --> 00:17:57,210
assume that you want a 52 bit you can go

00:17:52,410 --> 00:17:59,130
to the last like this so that's not a

00:17:57,210 --> 00:18:00,780
question of clarification speaking on

00:17:59,130 --> 00:18:05,130
behalf of the are maintainer

00:18:00,780 --> 00:18:08,640
so at the moment we see no specific use

00:18:05,130 --> 00:18:11,340
case for merging the first batch set so

00:18:08,640 --> 00:18:15,000
we are not going to merge this into

00:18:11,340 --> 00:18:18,210
mainline kernel unless we hear some

00:18:15,000 --> 00:18:21,780
concrete use cases for systems that

00:18:18,210 --> 00:18:24,630
needs to have 32-bit kernel virtual

00:18:21,780 --> 00:18:27,360
addressing support what will progress

00:18:24,630 --> 00:18:29,730
instead is the second set of patches

00:18:27,360 --> 00:18:32,310
from Steve so the are maintained URLs

00:18:29,730 --> 00:18:35,100
are very much keen in merging the second

00:18:32,310 --> 00:18:37,860
set of patches so if you do have a use

00:18:35,100 --> 00:18:40,560
case for a system that make use of 82

00:18:37,860 --> 00:18:43,680
bit virtual address in support in the

00:18:40,560 --> 00:18:46,320
kernel please reach out to me to Steve

00:18:43,680 --> 00:18:49,890
or on list if you have public

00:18:46,320 --> 00:18:54,080
information so that we can make a case

00:18:49,890 --> 00:18:54,080
for progressing the first set of patches

00:18:54,210 --> 00:19:01,929
thank you

00:18:56,760 --> 00:19:02,620
so everything guys okay thank you the

00:19:01,929 --> 00:19:07,140
attention

00:19:02,620 --> 00:19:12,149
[Applause]

00:19:07,140 --> 00:19:12,149

YouTube URL: https://www.youtube.com/watch?v=rrH7XqdE0RY


