Title: YVR18-108:Trusted Firmware for M, technical deep dive
Publication date: 2019-05-09
Playlist: Linaro Connect Vancouver 2018
Description: 
	Trusted Firmware M is an open source implementation of Platform Security Architecture(PSA) for ARM M profile processors. It was publicly launched in Linaro Connect HKG18. 
It offers-
 Trusted Boot – providing protection against malicious code injection on the device and secure firmware update
 Security isolation levels in the run-time – scope limiting system’s security critical resources and reducing the trusted code base
 Secure services – secure end points of the system providing service to other secure partitions and non-secure entities

This is an interactive session to deep dive into different technical aspects of TF-M and how these aspects bind to a connected device’s security model. An example use-case will also be presented to showcase how different components of the system firmware come together.
Captions: 
	00:00:02,070 --> 00:00:07,080
[Music]

00:00:08,849 --> 00:00:16,210
okay we'll get started hi everyone my

00:00:13,210 --> 00:00:17,830
name is Josh Tosh in part of the open

00:00:16,210 --> 00:00:21,280
source software group with an arm and

00:00:17,830 --> 00:00:26,890
eye tech lead the DFM project with

00:00:21,280 --> 00:00:29,080
enough today we are going to talk about

00:00:26,890 --> 00:00:31,930
some introductory level details about

00:00:29,080 --> 00:00:36,250
the PSA and some architectural details

00:00:31,930 --> 00:00:37,900
about the trusted former M project after

00:00:36,250 --> 00:00:40,660
which we'll walk through some of the

00:00:37,900 --> 00:00:41,860
secure service designs and time

00:00:40,660 --> 00:00:44,380
permitting we'll walk through some of

00:00:41,860 --> 00:00:48,130
the use case scenarios to see how it all

00:00:44,380 --> 00:00:49,900
fits together and then some conversation

00:00:48,130 --> 00:00:52,510
about how you can contribute to this

00:00:49,900 --> 00:00:53,950
project I would like to make it a very

00:00:52,510 --> 00:00:55,270
interactive session so if you have a

00:00:53,950 --> 00:00:57,340
question or if you want to make point

00:00:55,270 --> 00:01:02,220
please stop me at any point you feel

00:00:57,340 --> 00:01:02,220
like all right let's get started

00:01:04,950 --> 00:01:14,290
PSA PSA was launched sometime in the end

00:01:09,820 --> 00:01:17,220
of 2017 from the technical standpoint it

00:01:14,290 --> 00:01:19,000
has three main aspects first is

00:01:17,220 --> 00:01:20,710
understanding what we are trying to

00:01:19,000 --> 00:01:25,320
solve understanding the threats that

00:01:20,710 --> 00:01:27,460
exist for the corrected devices in space

00:01:25,320 --> 00:01:30,400
analyzing the problems that we can solve

00:01:27,460 --> 00:01:32,400
and that we should be solving and that

00:01:30,400 --> 00:01:35,320
leads to the second stage the

00:01:32,400 --> 00:01:38,920
architecture based on our understanding

00:01:35,320 --> 00:01:44,110
of the problems that are security issues

00:01:38,920 --> 00:01:45,369
that exist or may come up in future we

00:01:44,110 --> 00:01:47,409
are trying to create a set of

00:01:45,369 --> 00:01:49,270
architectural specifications that will

00:01:47,409 --> 00:01:52,689
govern how the software should operate

00:01:49,270 --> 00:01:55,119
and to support the software architecture

00:01:52,689 --> 00:01:57,549
you need to have some hardware backing

00:01:55,119 --> 00:02:00,479
some some hardware features that will

00:01:57,549 --> 00:02:04,439
allow the specified architecture and

00:02:00,479 --> 00:02:08,289
that's gone by the hardware requirements

00:02:04,439 --> 00:02:12,430
you will be seeing specifications about

00:02:08,289 --> 00:02:13,719
the mandated mandated hardware features

00:02:12,430 --> 00:02:16,359
what kind of keys you should have what

00:02:13,719 --> 00:02:18,189
kind of peripherals you should have to

00:02:16,359 --> 00:02:20,140
support the different

00:02:18,189 --> 00:02:22,500
compartmentalization that we want to put

00:02:20,140 --> 00:02:25,780
in the whole system

00:02:22,500 --> 00:02:27,849
and finally the architecture leads to

00:02:25,780 --> 00:02:30,430
implementation which is what we are

00:02:27,849 --> 00:02:35,370
going to talk about in more in in the

00:02:30,430 --> 00:02:37,689
today's presentation the TFM project

00:02:35,370 --> 00:02:40,000
before we get into the details of the

00:02:37,689 --> 00:02:43,780
DFM project there are some underlying

00:02:40,000 --> 00:02:46,239
principles which basically which come

00:02:43,780 --> 00:02:50,260
across for most of the use case scenario

00:02:46,239 --> 00:02:53,019
for most of the use cases we want to

00:02:50,260 --> 00:02:55,840
develop for the connected devices first

00:02:53,019 --> 00:02:57,700
being the secure boot we want to make

00:02:55,840 --> 00:03:01,599
sure that the software that runs on a

00:02:57,700 --> 00:03:03,969
device is not tampered with it is what

00:03:01,599 --> 00:03:07,239
it claims to be and that is ensured by

00:03:03,969 --> 00:03:09,010
the trusted boot part of the system so

00:03:07,239 --> 00:03:11,019
that's one of the underlying principles

00:03:09,010 --> 00:03:15,819
that is required for any connected

00:03:11,019 --> 00:03:19,030
device the second part is non mutable

00:03:15,819 --> 00:03:21,549
device identity non mutable and secret

00:03:19,030 --> 00:03:23,919
device identity so that everything that

00:03:21,549 --> 00:03:28,000
happens on a system can be tied to a

00:03:23,919 --> 00:03:29,739
specific device and the third aspect the

00:03:28,000 --> 00:03:32,620
third underlying principle for most of

00:03:29,739 --> 00:03:34,870
the use cases is update ability we

00:03:32,620 --> 00:03:37,989
understand that the software is always

00:03:34,870 --> 00:03:41,189
or most of time has issues and the the

00:03:37,989 --> 00:03:43,840
way the devolution of threats in the

00:03:41,189 --> 00:03:45,280
that exists for connected devices the

00:03:43,840 --> 00:03:48,400
software also need to you all it need to

00:03:45,280 --> 00:03:50,109
change it need to fix and for that we

00:03:48,400 --> 00:03:52,780
need to be able to update the software

00:03:50,109 --> 00:03:57,669
that is running on a device securely and

00:03:52,780 --> 00:03:59,639
remotely and lastly any transaction that

00:03:57,669 --> 00:04:01,889
happens on the device or any

00:03:59,639 --> 00:04:04,629
communication that happens on the device

00:04:01,889 --> 00:04:08,500
should be authenticated through

00:04:04,629 --> 00:04:10,720
cryptographic certificates so these are

00:04:08,500 --> 00:04:12,849
the four basic principles which I think

00:04:10,720 --> 00:04:15,479
apply to most of the use cases that

00:04:12,849 --> 00:04:15,479
we'll have in

00:04:20,299 --> 00:04:28,590
DFM TFM is an open-source implementation

00:04:24,180 --> 00:04:31,260
of PSA it is targeted for cortex-m

00:04:28,590 --> 00:04:35,580
devices currently we have support for

00:04:31,260 --> 00:04:38,100
cortex on v8 M architecture will be

00:04:35,580 --> 00:04:42,240
adding support for other M architectures

00:04:38,100 --> 00:04:46,050
as well going ahead it if you look at

00:04:42,240 --> 00:04:48,300
block this block the left hand side that

00:04:46,050 --> 00:04:50,190
represents the classical system where

00:04:48,300 --> 00:04:52,169
you have a jeweler running on the on the

00:04:50,190 --> 00:04:54,690
device which is assisted by some

00:04:52,169 --> 00:04:57,990
software libraries your tcp/ip stacks

00:04:54,690 --> 00:05:00,240
your mathematics libraries and then on

00:04:57,990 --> 00:05:02,640
top of it all you have the system form

00:05:00,240 --> 00:05:05,040
where the application so that's the

00:05:02,640 --> 00:05:07,890
classical view on the right hand side

00:05:05,040 --> 00:05:10,460
you see the right hand side represents

00:05:07,890 --> 00:05:12,690
what we have what we have in the DFM the

00:05:10,460 --> 00:05:14,850
most of the software that implement in

00:05:12,690 --> 00:05:20,160
DFM is represented on the right hand

00:05:14,850 --> 00:05:23,390
side the underlying principle for the

00:05:20,160 --> 00:05:26,040
architecture definition from the TFM is

00:05:23,390 --> 00:05:28,500
principle of least privilege what that

00:05:26,040 --> 00:05:31,169
means the software need to be broken

00:05:28,500 --> 00:05:33,630
down into the small pieces and the each

00:05:31,169 --> 00:05:36,600
small piece should be given just enough

00:05:33,630 --> 00:05:41,880
privilege just enough access to let it

00:05:36,600 --> 00:05:44,460
do its job we will get into the details

00:05:41,880 --> 00:05:47,940
of the different blocks in the rest of

00:05:44,460 --> 00:05:51,660
this presentation but let's have a quick

00:05:47,940 --> 00:05:53,960
look at what we what we see here on the

00:05:51,660 --> 00:05:58,050
bottom right side you see the bootloader

00:05:53,960 --> 00:06:00,840
bootloader is responsible for securing

00:05:58,050 --> 00:06:02,729
the software that executes on device

00:06:00,840 --> 00:06:05,430
making sure that the software is not

00:06:02,729 --> 00:06:10,740
tampered with it's not rolled back it's

00:06:05,430 --> 00:06:13,350
not altered in any fashion it also

00:06:10,740 --> 00:06:15,539
participates in the firmware update

00:06:13,350 --> 00:06:18,110
process time permitting we'll go through

00:06:15,539 --> 00:06:21,990
the update process as well and see how

00:06:18,110 --> 00:06:24,040
bootloader what kind of duties boot

00:06:21,990 --> 00:06:28,660
order performs in that

00:06:24,040 --> 00:06:31,030
of update operation thirdly it collects

00:06:28,660 --> 00:06:33,850
attestation information at the station

00:06:31,030 --> 00:06:35,620
data for a specific device what that

00:06:33,850 --> 00:06:39,250
means that again I'll cover in one of

00:06:35,620 --> 00:06:42,970
the later slides so if you look at the

00:06:39,250 --> 00:06:45,400
the other block on on the bottom the TFM

00:06:42,970 --> 00:06:47,710
framework this is the runtime framework

00:06:45,400 --> 00:06:50,440
which provides the compartmentalization

00:06:47,710 --> 00:06:53,950
for the rest of the systems this is the

00:06:50,440 --> 00:06:56,140
system it provides the in each layer so

00:06:53,950 --> 00:06:58,930
it does initialization of the secure

00:06:56,140 --> 00:07:00,190
peripherals it creates sandboxes for the

00:06:58,930 --> 00:07:02,230
rest of the system so if you have

00:07:00,190 --> 00:07:04,000
different cells running on the system

00:07:02,230 --> 00:07:08,740
you they will be running in its own

00:07:04,000 --> 00:07:12,700
their own isolated domains it also

00:07:08,740 --> 00:07:15,970
provides facilities to handle interrupts

00:07:12,700 --> 00:07:17,980
securely and then some mechanisms do

00:07:15,970 --> 00:07:21,040
crash handling and recovery from crash

00:07:17,980 --> 00:07:23,470
and once it has done the initialization

00:07:21,040 --> 00:07:25,810
of its own and the initialization of the

00:07:23,470 --> 00:07:28,900
partitions that are running on top of

00:07:25,810 --> 00:07:31,150
the framework it passes on the control

00:07:28,900 --> 00:07:33,130
to the non secure side and from then on

00:07:31,150 --> 00:07:35,740
all of the transactions are initiated by

00:07:33,130 --> 00:07:38,500
the non secure callers so non secure

00:07:35,740 --> 00:07:41,370
side of the software can make calls into

00:07:38,500 --> 00:07:44,590
the secure side and so on and so forth

00:07:41,370 --> 00:07:48,100
before I go ahead is there a need to

00:07:44,590 --> 00:07:49,780
look at the details of on via temp

00:07:48,100 --> 00:07:52,720
architecture or the talkee to assume

00:07:49,780 --> 00:07:56,920
that we all fairly understand how we a

00:07:52,720 --> 00:07:57,460
time architecture operates okay I take

00:07:56,920 --> 00:08:00,550
that as a yes

00:07:57,460 --> 00:08:08,580
and I assume that you are all experts on

00:08:00,550 --> 00:08:08,580
via M already right

00:08:09,560 --> 00:08:14,820
this is a different representation of

00:08:12,780 --> 00:08:17,400
the same block same picture we saw in

00:08:14,820 --> 00:08:19,199
the earlier slide this is more of a

00:08:17,400 --> 00:08:21,770
functional representation and how the

00:08:19,199 --> 00:08:25,500
system is divided into different

00:08:21,770 --> 00:08:26,040
building blocks and why they are colored

00:08:25,500 --> 00:08:30,419
differently

00:08:26,040 --> 00:08:32,010
there is a reason differently if you

00:08:30,419 --> 00:08:34,349
look at the bottom there are yellow

00:08:32,010 --> 00:08:37,469
boxes they are the hardware blocks of

00:08:34,349 --> 00:08:38,729
the system they represent the bare

00:08:37,469 --> 00:08:43,010
minimum that you need to have on a

00:08:38,729 --> 00:08:47,460
system to secure the device to basically

00:08:43,010 --> 00:08:49,560
do - so that's again going by some sort

00:08:47,460 --> 00:08:52,830
of compliance some sort of specification

00:08:49,560 --> 00:08:54,660
and that's called TBSA the TBSA

00:08:52,830 --> 00:08:56,810
specification says that these are the

00:08:54,660 --> 00:08:58,620
minimum set of hardware and the

00:08:56,810 --> 00:09:00,839
hardware's that you need to have on our

00:08:58,620 --> 00:09:03,150
device and these are the characteristic

00:09:00,839 --> 00:09:06,230
of these devices that you must have for

00:09:03,150 --> 00:09:08,880
the device to be a DBA compliant device

00:09:06,230 --> 00:09:12,300
all of the access to the DBA component

00:09:08,880 --> 00:09:14,640
is done through the TBS a hal api so

00:09:12,300 --> 00:09:16,290
this is again a lightweight hal that

00:09:14,640 --> 00:09:19,260
provides a unified access to the

00:09:16,290 --> 00:09:23,550
platform unified access to the hardware

00:09:19,260 --> 00:09:27,330
the underlying hardware the boxes above

00:09:23,550 --> 00:09:28,920
the hell api the you have the boot order

00:09:27,330 --> 00:09:31,080
box and the framework we'll talk about

00:09:28,920 --> 00:09:35,490
the these two boxes in a bit more detail

00:09:31,080 --> 00:09:39,480
the blue boxes in the middle they

00:09:35,490 --> 00:09:41,490
represent trusted services so there is a

00:09:39,480 --> 00:09:44,520
concept of trusted services and secure

00:09:41,490 --> 00:09:50,070
services the trusted services they

00:09:44,520 --> 00:09:52,650
represent they represent a bit more what

00:09:50,070 --> 00:09:56,730
they what they actually do is they have

00:09:52,650 --> 00:09:59,010
access to the device devices route of

00:09:56,730 --> 00:10:01,290
trust so in a sense that they control

00:09:59,010 --> 00:10:04,500
they they control the overall security

00:10:01,290 --> 00:10:06,450
of the system so if there is a bug in

00:10:04,500 --> 00:10:09,209
one of the blue boxes it essentially

00:10:06,450 --> 00:10:12,510
leaks some really serious security

00:10:09,209 --> 00:10:15,029
information about the device and for

00:10:12,510 --> 00:10:17,220
that reason they need to be thoroughly

00:10:15,029 --> 00:10:21,209
vetted

00:10:17,220 --> 00:10:21,689
thoroughly analyzed from security

00:10:21,209 --> 00:10:23,639
threats

00:10:21,689 --> 00:10:24,720
having said that all of the blocks on

00:10:23,639 --> 00:10:26,100
the right hand side need to be

00:10:24,720 --> 00:10:30,660
thoroughly reviewed and thoroughly

00:10:26,100 --> 00:10:32,819
vetted more so the blue box is the key

00:10:30,660 --> 00:10:34,529
point here is blue boxes provide

00:10:32,819 --> 00:10:36,709
services to a very limited set of

00:10:34,529 --> 00:10:39,629
entities they are not general purpose

00:10:36,709 --> 00:10:42,389
entity in general purpose services that

00:10:39,629 --> 00:10:44,480
can be called from rest of the system

00:10:42,389 --> 00:10:46,980
they provide a very specific

00:10:44,480 --> 00:10:48,750
functionality and that functionality is

00:10:46,980 --> 00:10:54,449
limited to a very limited set of

00:10:48,750 --> 00:10:56,550
entities just on the secure side and so

00:10:54,449 --> 00:10:58,860
those the delimited set of entities

00:10:56,550 --> 00:11:02,100
would be one of the green box as you see

00:10:58,860 --> 00:11:04,860
on the top the green boxes they

00:11:02,100 --> 00:11:07,410
represent the generic secure side

00:11:04,860 --> 00:11:09,629
endpoints that can be called from the

00:11:07,410 --> 00:11:10,829
non secure side as well and they can be

00:11:09,629 --> 00:11:12,800
called from the non secure side they can

00:11:10,829 --> 00:11:16,500
be called from other being green boxes

00:11:12,800 --> 00:11:20,220
so there's a layered approach to the

00:11:16,500 --> 00:11:22,170
overall architecture the as I said it

00:11:20,220 --> 00:11:25,680
operates on the principle of least

00:11:22,170 --> 00:11:27,120
privilege the the software components

00:11:25,680 --> 00:11:29,579
which require access to the root of

00:11:27,120 --> 00:11:31,139
trust they are sandbox as one of the

00:11:29,579 --> 00:11:41,149
blue boxes and the rest of the system is

00:11:31,139 --> 00:11:41,149
built on the top as green boxes yeah

00:11:47,980 --> 00:11:57,620
so if you can yes regarding the hardware

00:11:54,860 --> 00:11:58,940
access mm-hmm so on the low layer in

00:11:57,620 --> 00:12:02,990
this model there will be accessed

00:11:58,940 --> 00:12:05,000
insecure privilege domain if the yeren

00:12:02,990 --> 00:12:08,570
green needs for instance to use any

00:12:05,000 --> 00:12:09,980
other accelerator oh yeah yes I have an

00:12:08,570 --> 00:12:16,250
answer to that in one of the later

00:12:09,980 --> 00:12:19,790
slides the answer is yes and no some of

00:12:16,250 --> 00:12:21,770
the blue blue box appears which are

00:12:19,790 --> 00:12:24,980
exposed by the TBC health will be

00:12:21,770 --> 00:12:27,590
accessible only to the blue boxes above

00:12:24,980 --> 00:12:30,860
them but there are cases and there are

00:12:27,590 --> 00:12:43,130
ways they can be exposed directly to the

00:12:30,860 --> 00:12:45,590
green boxes I'll come to that in so I'm

00:12:43,130 --> 00:12:47,150
going to pick each book all the

00:12:45,590 --> 00:12:50,090
different blocks is one by one and try

00:12:47,150 --> 00:12:55,490
to explain how how they behave and what

00:12:50,090 --> 00:12:58,370
their responsibility is and let's let's

00:12:55,490 --> 00:13:00,380
start with the TFM core framework this

00:12:58,370 --> 00:13:03,820
is the boilerplate for the runtime

00:13:00,380 --> 00:13:07,130
software and it provides the sort of

00:13:03,820 --> 00:13:09,290
environment for running the non secure

00:13:07,130 --> 00:13:12,740
sized software running the secure side

00:13:09,290 --> 00:13:15,380
services and it creates the isolation

00:13:12,740 --> 00:13:18,440
profiles so based on what you define at

00:13:15,380 --> 00:13:23,090
the compile time the the framework will

00:13:18,440 --> 00:13:24,670
generate a database database of what

00:13:23,090 --> 00:13:27,980
different partitions here in system

00:13:24,670 --> 00:13:29,440
which one of these is secure partition

00:13:27,980 --> 00:13:32,930
and which one is trusted partition

00:13:29,440 --> 00:13:36,020
create the hardware profiles for the

00:13:32,930 --> 00:13:39,350
database which is generated and enforce

00:13:36,020 --> 00:13:40,970
the the isolation profile which we have

00:13:39,350 --> 00:13:44,030
defined in the software using the

00:13:40,970 --> 00:13:48,050
hardware features so that's one of the

00:13:44,030 --> 00:13:50,990
main functionalities of the blue box in

00:13:48,050 --> 00:13:52,850
the bottom it also provides a way of

00:13:50,990 --> 00:13:55,670
communicating between different entities

00:13:52,850 --> 00:13:57,980
so now that we have sandbox the

00:13:55,670 --> 00:14:00,050
different blocks here different software

00:13:57,980 --> 00:14:00,620
entities they need a secure way of

00:14:00,050 --> 00:14:03,890
talking

00:14:00,620 --> 00:14:10,490
to each other and that is provided by

00:14:03,890 --> 00:14:18,830
the framework in form of IPC all right

00:14:10,490 --> 00:14:20,570
so so that was a brief idea about what

00:14:18,830 --> 00:14:23,420
the framework is that the framework does

00:14:20,570 --> 00:14:25,310
I'm going to cover some of the changes

00:14:23,420 --> 00:14:26,690
we have done in the recent past and some

00:14:25,310 --> 00:14:28,970
of the interesting details in fact

00:14:26,690 --> 00:14:32,420
because they're too many to cover in one

00:14:28,970 --> 00:14:34,730
hour slot what are the important changes

00:14:32,420 --> 00:14:36,890
we have done is transition from the non

00:14:34,730 --> 00:14:38,420
secure world to the secure world in the

00:14:36,890 --> 00:14:41,090
earlier implementation the transition

00:14:38,420 --> 00:14:43,460
was done in the handler mode so what

00:14:41,090 --> 00:14:45,530
that means if non secure side wants to

00:14:43,460 --> 00:14:48,080
make a call to the secure side it first

00:14:45,530 --> 00:14:50,330
need to raise a SVC so that it can get

00:14:48,080 --> 00:14:52,520
in the handler mode and from the handler

00:14:50,330 --> 00:14:55,130
mode it can do the transition to the

00:14:52,520 --> 00:14:58,730
secure side now this has couple of

00:14:55,130 --> 00:15:00,620
problems first is it blocks all of the

00:14:58,730 --> 00:15:03,470
non secure world in most of the

00:15:00,620 --> 00:15:05,720
scenarios the SVC handling on the non

00:15:03,470 --> 00:15:07,670
secure side will run at a higher

00:15:05,720 --> 00:15:10,300
privilege than the most of the

00:15:07,670 --> 00:15:13,070
interrupts in the system what that means

00:15:10,300 --> 00:15:14,840
as long as the call is active to the

00:15:13,070 --> 00:15:16,460
secure world non secure side cannot

00:15:14,840 --> 00:15:18,710
share you it cannot do it cannot share

00:15:16,460 --> 00:15:20,270
anything else in the system it can

00:15:18,710 --> 00:15:23,690
probably not even handle it interrupts

00:15:20,270 --> 00:15:26,630
and so which means real time nests of

00:15:23,690 --> 00:15:29,930
the real timeless of the non secure side

00:15:26,630 --> 00:15:32,720
is kind of lost by making the transition

00:15:29,930 --> 00:15:34,580
insecure world transition to the secure

00:15:32,720 --> 00:15:36,440
world in the third mode we solve that

00:15:34,580 --> 00:15:39,890
problem now the transition happens in

00:15:36,440 --> 00:15:42,260
the third mode so ideally if you have

00:15:39,890 --> 00:15:45,080
interrupts which are which have priority

00:15:42,260 --> 00:15:47,600
defined properly they can pre end secure

00:15:45,080 --> 00:15:50,540
side service execution and then you are

00:15:47,600 --> 00:15:55,510
back to having the real time list in the

00:15:50,540 --> 00:15:59,150
non secure side the second problem is

00:15:55,510 --> 00:16:02,000
the venire code now when your code the

00:15:59,150 --> 00:16:03,920
venire code is the gateway function that

00:16:02,000 --> 00:16:06,110
kind of allows transition from the non

00:16:03,920 --> 00:16:08,150
secure side to the secure side and the

00:16:06,110 --> 00:16:10,400
Gateway code in the earlier

00:16:08,150 --> 00:16:12,800
implementation was run in the handler

00:16:10,400 --> 00:16:13,640
mode the problem is if there is a bug in

00:16:12,800 --> 00:16:15,650
the handler

00:16:13,640 --> 00:16:17,030
in the linear code and if you are to

00:16:15,650 --> 00:16:18,500
many various even in the system it

00:16:17,030 --> 00:16:20,390
becomes a little difficult to wet them

00:16:18,500 --> 00:16:22,790
all so if you have a bug in the venire

00:16:20,390 --> 00:16:24,230
code that kind of exposes the whole

00:16:22,790 --> 00:16:26,060
system because the venire code is being

00:16:24,230 --> 00:16:28,640
run in the privileged mode and it has

00:16:26,060 --> 00:16:30,970
access to the whole system so one buffer

00:16:28,640 --> 00:16:34,190
overflow and all of the security is lost

00:16:30,970 --> 00:16:37,160
so doing the transition in the handler

00:16:34,190 --> 00:16:39,590
modes sorry in the third mode solves

00:16:37,160 --> 00:16:42,680
that problem as well the venire code is

00:16:39,590 --> 00:16:44,720
now executed in the third mode non

00:16:42,680 --> 00:16:48,290
privileged mode which means even if

00:16:44,720 --> 00:16:51,380
there is a bug the bug the effect of

00:16:48,290 --> 00:16:55,100
that bug is limited to that venire code

00:16:51,380 --> 00:16:57,470
implementation the second thing we have

00:16:55,100 --> 00:17:00,050
implemented is a manifest base service

00:16:57,470 --> 00:17:02,560
definition is partially done what this

00:17:00,050 --> 00:17:02,560
means is

00:17:07,449 --> 00:17:11,949
so I think what I would like to hear a

00:17:09,970 --> 00:17:13,690
little bit more about that what happens

00:17:11,949 --> 00:17:18,010
now when it crosses the boundary in the

00:17:13,690 --> 00:17:21,310
threat mode so when it crosses the

00:17:18,010 --> 00:17:23,010
boundary it it is so let's say on

00:17:21,310 --> 00:17:25,480
non-secure side you have applications

00:17:23,010 --> 00:17:29,080
application is running in the thread

00:17:25,480 --> 00:17:30,820
mode now it doesn't need to get into the

00:17:29,080 --> 00:17:33,220
SVC handle mode on the non secure side

00:17:30,820 --> 00:17:34,900
it just makes a venir call directly to

00:17:33,220 --> 00:17:37,150
the whatever veneers you are defined in

00:17:34,900 --> 00:17:40,810
the system the thread can directly make

00:17:37,150 --> 00:17:43,660
a call to the veneer the veneer

00:17:40,810 --> 00:17:47,070
basically is still running in the thread

00:17:43,660 --> 00:17:50,470
mode it does some sort of some some

00:17:47,070 --> 00:17:53,260
verification of the call and if the call

00:17:50,470 --> 00:17:55,810
is okay then it will raise another SVC

00:17:53,260 --> 00:17:58,570
on the secure side that will take the

00:17:55,810 --> 00:18:00,880
control to the department manager on the

00:17:58,570 --> 00:18:03,820
secure side the partition manager on the

00:18:00,880 --> 00:18:06,960
secure side will now decide what that

00:18:03,820 --> 00:18:10,150
call is meant to do where that is

00:18:06,960 --> 00:18:12,370
intended to be terminated at so the call

00:18:10,150 --> 00:18:14,070
is essentially targeted the call call

00:18:12,370 --> 00:18:16,690
must be targeted to a specific service

00:18:14,070 --> 00:18:19,780
the SPM which is now running in the hand

00:18:16,690 --> 00:18:22,510
and the handle mode will surely call

00:18:19,780 --> 00:18:25,480
service in again in the thread mode and

00:18:22,510 --> 00:18:27,340
that's where the call will land in the

00:18:25,480 --> 00:18:28,410
service does what it's supposed to do it

00:18:27,340 --> 00:18:32,620
finishes the job

00:18:28,410 --> 00:18:35,020
Tellis tells it back to the framework by

00:18:32,620 --> 00:18:36,790
raising another SVC saying that yeah I'm

00:18:35,020 --> 00:18:41,050
done whatever you requested me to do

00:18:36,790 --> 00:18:43,450
it's finished the SPM which is again

00:18:41,050 --> 00:18:45,040
running in the handler mode does cleanup

00:18:43,450 --> 00:18:47,890
is verifies that whatever the service is

00:18:45,040 --> 00:18:52,450
saying is true then replies back to the

00:18:47,890 --> 00:18:57,400
non secure caller in the thread mode is

00:18:52,450 --> 00:18:59,770
that what you were asking okay okay yeah

00:18:57,400 --> 00:19:02,530
the right so second thing is manifest

00:18:59,770 --> 00:19:05,620
based service partition division what

00:19:02,530 --> 00:19:10,930
this means is you can define a partition

00:19:05,620 --> 00:19:13,300
a service in using a manifest soil which

00:19:10,930 --> 00:19:15,850
is written in general format who IML

00:19:13,300 --> 00:19:17,680
from format this is not completely

00:19:15,850 --> 00:19:21,790
implemented there are certain parts

00:19:17,680 --> 00:19:23,830
which are still hard-coded in the in the

00:19:21,790 --> 00:19:25,330
in the code but going ahead it will be

00:19:23,830 --> 00:19:27,490
cleaned up and essentially when you want

00:19:25,330 --> 00:19:30,790
to define a service you write your C

00:19:27,490 --> 00:19:32,260
code you basically expose this service

00:19:30,790 --> 00:19:35,050
to the rest of the system using the

00:19:32,260 --> 00:19:36,670
manifest file and the build system will

00:19:35,050 --> 00:19:39,540
automatically automatically take care of

00:19:36,670 --> 00:19:42,670
generating the whole data structures and

00:19:39,540 --> 00:19:48,160
pulling in the service in the in the

00:19:42,670 --> 00:19:49,780
right way the third thing that we have

00:19:48,160 --> 00:19:54,040
third major things that we implemented

00:19:49,780 --> 00:19:59,470
from the last time we spoke is IPC IPC

00:19:54,040 --> 00:20:02,650
is the PS a defined way of communication

00:19:59,470 --> 00:20:07,090
between different entities that is up

00:20:02,650 --> 00:20:09,040
streamed now we had the full GCC support

00:20:07,090 --> 00:20:12,130
now for all of the platforms that are

00:20:09,040 --> 00:20:16,680
there in the codebase they can become

00:20:12,130 --> 00:20:21,400
void compiled using a MCC or using GCC

00:20:16,680 --> 00:20:23,560
so yeah that's this completed we have

00:20:21,400 --> 00:20:27,700
done some improvements to the halo

00:20:23,560 --> 00:20:32,430
abstraction and then we now have support

00:20:27,700 --> 00:20:32,430
for v8 and Midland and baseline process

00:20:33,300 --> 00:20:40,210
some details about the IPC IPC it

00:20:37,450 --> 00:20:43,690
provides secure way of communication

00:20:40,210 --> 00:20:46,360
between different entities these

00:20:43,690 --> 00:20:48,070
entities could be secured to secure into

00:20:46,360 --> 00:20:52,420
entities trying to talk to each other or

00:20:48,070 --> 00:20:54,700
a NSPE entity the non secure identity

00:20:52,420 --> 00:20:57,100
trying to talk to a secure identity and

00:20:54,700 --> 00:21:01,000
the IPC ensures that the communication

00:20:57,100 --> 00:21:03,250
itself is secured and any misformed

00:21:01,000 --> 00:21:08,590
requests from one side doesn't lead into

00:21:03,250 --> 00:21:11,070
the overall system vulnerability if you

00:21:08,590 --> 00:21:14,790
have to visualize how a service would be

00:21:11,070 --> 00:21:17,890
run how service looks like in IPC mode

00:21:14,790 --> 00:21:20,920
it is it is like a daemon running in a

00:21:17,890 --> 00:21:24,100
while loop and the calls from the client

00:21:20,920 --> 00:21:25,580
are passed on as a message to that demon

00:21:24,100 --> 00:21:27,980
so demons running is

00:21:25,580 --> 00:21:30,950
for some messages when a request from

00:21:27,980 --> 00:21:34,970
the client comes in the the request is

00:21:30,950 --> 00:21:36,889
is composed as a message to the targeted

00:21:34,970 --> 00:21:40,700
partition the targeted partition

00:21:36,889 --> 00:21:42,470
basically receives that message tries it

00:21:40,700 --> 00:21:44,539
interprets that message and does

00:21:42,470 --> 00:21:49,509
whatever is required whatever the call

00:21:44,539 --> 00:21:49,509
was made for and then it replies back

00:21:50,499 --> 00:21:56,809
this also means the interrupt handling

00:21:54,200 --> 00:21:58,700
will the interfering part of the

00:21:56,809 --> 00:22:02,049
partition will be synchronous to the

00:21:58,700 --> 00:22:05,450
execution of the partition or service

00:22:02,049 --> 00:22:08,119
the the service is running in a while 1

00:22:05,450 --> 00:22:10,869
loop if inter comes in that inter is

00:22:08,119 --> 00:22:14,629
again passed on as a message to the

00:22:10,869 --> 00:22:16,549
partition it's out of the service and so

00:22:14,629 --> 00:22:18,919
it becomes a kind of synchronous to the

00:22:16,549 --> 00:22:21,350
flow of the service and what that means

00:22:18,919 --> 00:22:24,980
you don't have reentrant see in the in

00:22:21,350 --> 00:22:27,320
the partition code all of the calls all

00:22:24,980 --> 00:22:30,850
of the API is implemented in the IPC are

00:22:27,320 --> 00:22:30,850
blocking calls so yeah

00:22:32,110 --> 00:22:38,649
yeah open app for the IPC is is this

00:22:35,710 --> 00:22:41,019
based on open app or is it a DC this is

00:22:38,649 --> 00:22:46,330
slightly so I think the confusion term

00:22:41,019 --> 00:22:48,309
here is IPC the open amp thought is is

00:22:46,330 --> 00:22:50,620
about standardizing communication

00:22:48,309 --> 00:22:54,610
between two different CPUs or two

00:22:50,620 --> 00:22:57,549
different heterogeneous systems a a plus

00:22:54,610 --> 00:22:58,960
M or maybe even two M devices this is

00:22:57,549 --> 00:23:01,750
slightly different this is slightly more

00:22:58,960 --> 00:23:05,139
abstracted so if let's for example if

00:23:01,750 --> 00:23:08,049
you have a PS a compliant system which

00:23:05,139 --> 00:23:09,789
implements IPC you could have open amp

00:23:08,049 --> 00:23:13,120
implementation and on top of that you'll

00:23:09,789 --> 00:23:14,830
have this PSA IPC so it's the physical

00:23:13,120 --> 00:23:17,080
transport layer is implemented by the

00:23:14,830 --> 00:23:19,809
will be implemented by the open amp and

00:23:17,080 --> 00:23:23,490
then you have another layer on top of it

00:23:19,809 --> 00:23:23,490
which is the BSA IPC

00:23:30,090 --> 00:23:32,690
but

00:23:33,440 --> 00:23:36,010
yeah

00:23:43,270 --> 00:23:49,130
what I'm saying

00:23:45,820 --> 00:23:51,350
services in the secure world that are

00:23:49,130 --> 00:23:54,560
really really long take a really long

00:23:51,350 --> 00:23:58,310
time like primarily test for our sake

00:23:54,560 --> 00:24:00,860
yeah he's what is going on to make sure

00:23:58,310 --> 00:24:02,860
that the non-secure world isn't

00:24:00,860 --> 00:24:06,200
completely blocked for multiple seconds

00:24:02,860 --> 00:24:09,170
so they're two parts to this question

00:24:06,200 --> 00:24:11,000
again what is what happens to the caller

00:24:09,170 --> 00:24:13,520
itself so if you have a task on the

00:24:11,000 --> 00:24:15,140
non-secure side which made the call that

00:24:13,520 --> 00:24:17,930
task is blocked it can't do anything

00:24:15,140 --> 00:24:19,940
else for that that duration of the call

00:24:17,930 --> 00:24:22,310
but the rest of the system is not

00:24:19,940 --> 00:24:25,610
blocked it can still share other threads

00:24:22,310 --> 00:24:28,340
on the system it can do other activities

00:24:25,610 --> 00:24:32,690
that it need to do the other aspect is

00:24:28,340 --> 00:24:35,060
the service side the service side is not

00:24:32,690 --> 00:24:37,790
required to process all the requests

00:24:35,060 --> 00:24:40,210
serially so for example if you have if

00:24:37,790 --> 00:24:44,930
you are doing a crypto operation and

00:24:40,210 --> 00:24:47,060
after initial has housekeeping if a

00:24:44,930 --> 00:24:49,310
crypto accelerator is triggered to do

00:24:47,060 --> 00:24:51,830
the actual job the service is not

00:24:49,310 --> 00:24:54,530
mandated to know finish the old tasks

00:24:51,830 --> 00:24:56,570
before picking on the next one so a

00:24:54,530 --> 00:24:58,130
service implement implementer can still

00:24:56,570 --> 00:25:01,130
decide to pick multiple requests at the

00:24:58,130 --> 00:25:03,230
same time one after the other based on

00:25:01,130 --> 00:25:08,170
its hardware capabilities and the

00:25:03,230 --> 00:25:08,170
software capabilities yeah

00:25:08,990 --> 00:25:14,179
but some of these security

00:25:11,129 --> 00:25:18,869
considerations about the IPC all of the

00:25:14,179 --> 00:25:22,529
API is the cause on the let me rephrase

00:25:18,869 --> 00:25:26,360
that the transactions between different

00:25:22,529 --> 00:25:28,710
entities is based on I of X I of ik is a

00:25:26,360 --> 00:25:32,940
structure which is disappointed and

00:25:28,710 --> 00:25:35,610
length which I get so basically the

00:25:32,940 --> 00:25:37,200
framework the the TFM framework it cares

00:25:35,610 --> 00:25:39,600
about the buffer that you are passing

00:25:37,200 --> 00:25:42,119
and how big that buffer is what that

00:25:39,600 --> 00:25:45,149
content is is not interpreted by the

00:25:42,119 --> 00:25:46,950
framework that is the agreement between

00:25:45,149 --> 00:25:51,389
the two endpoints and that that are

00:25:46,950 --> 00:25:53,369
trying to talk to each other so allowing

00:25:51,389 --> 00:25:56,879
having the communication based on I work

00:25:53,369 --> 00:25:59,700
it allows all transactions to be vetted

00:25:56,879 --> 00:26:01,830
by the framework so a caller cannot

00:25:59,700 --> 00:26:03,960
pretend to own a memory that it doesn't

00:26:01,830 --> 00:26:05,909
have access to so if the framework room

00:26:03,960 --> 00:26:07,860
will make sure that the I of X that are

00:26:05,909 --> 00:26:09,840
being passed to the other side they

00:26:07,860 --> 00:26:12,779
belong to the caller and they are

00:26:09,840 --> 00:26:17,039
sanitized and if not then the call will

00:26:12,779 --> 00:26:19,499
not go ahead after that the well the

00:26:17,039 --> 00:26:21,480
validation have happens after the awake

00:26:19,499 --> 00:26:24,090
sir integrity protected what that means

00:26:21,480 --> 00:26:28,499
is they are essentially copied into the

00:26:24,090 --> 00:26:30,559
secure domain into the code so this is

00:26:28,499 --> 00:26:33,809
to play and talk to attacks where you

00:26:30,559 --> 00:26:35,879
the after after modification after

00:26:33,809 --> 00:26:39,299
authentication know after verification

00:26:35,879 --> 00:26:40,919
of the IO X if the malicious entity goes

00:26:39,299 --> 00:26:43,860
and changed the content of the buffers

00:26:40,919 --> 00:26:45,990
the rest of the framework and the call

00:26:43,860 --> 00:26:50,940
service is protected against those

00:26:45,990 --> 00:26:53,639
malicious changes in the background but

00:26:50,940 --> 00:26:55,559
other thing is all of the accesses to

00:26:53,639 --> 00:27:00,149
the client

00:26:55,559 --> 00:27:02,100
memory is API based the the server

00:27:00,149 --> 00:27:05,610
cannot the service cannot directly

00:27:02,100 --> 00:27:07,320
access the client memory and any read or

00:27:05,610 --> 00:27:11,549
write to the client memory is through

00:27:07,320 --> 00:27:13,759
API and API is again streaming like API

00:27:11,549 --> 00:27:16,220
so they can't read the same client

00:27:13,759 --> 00:27:20,840
memory location twice

00:27:16,220 --> 00:27:24,200
and finally all of the accesses to the

00:27:20,840 --> 00:27:28,100
peripherals are done through MMI regions

00:27:24,200 --> 00:27:29,929
so any any partition any service that

00:27:28,100 --> 00:27:31,250
want to make an access to a peripheral

00:27:29,929 --> 00:27:34,940
it doesn't need to go through the

00:27:31,250 --> 00:27:38,179
privileged code to make that access each

00:27:34,940 --> 00:27:41,269
each service can have its own pocket of

00:27:38,179 --> 00:27:44,000
a memory map regions and those pockets

00:27:41,269 --> 00:27:47,509
basically represents the peripherals

00:27:44,000 --> 00:27:49,940
they own what that means is even if a

00:27:47,509 --> 00:27:54,129
service is running in the non privileged

00:27:49,940 --> 00:28:01,789
mode it can still access and manipulate

00:27:54,129 --> 00:28:05,179
different peripherals so this was a

00:28:01,789 --> 00:28:07,940
brief introduction to IPC and some of

00:28:05,179 --> 00:28:09,919
the features in tomorrow's talk I will

00:28:07,940 --> 00:28:12,320
try to see if if there's a need to get

00:28:09,919 --> 00:28:14,750
into bit more detail on the framework

00:28:12,320 --> 00:28:16,700
aspects so if you have questions we will

00:28:14,750 --> 00:28:19,669
have some more time again tomorrow to

00:28:16,700 --> 00:28:21,559
talk about the framework let's say I

00:28:19,669 --> 00:28:23,720
could look at the some of the services

00:28:21,559 --> 00:28:30,919
that are implemented so far in DFM and

00:28:23,720 --> 00:28:33,830
how they are architected excuse me first

00:28:30,919 --> 00:28:35,620
one is krypter service the underlying

00:28:33,830 --> 00:28:38,149
principle behind crippled service is

00:28:35,620 --> 00:28:41,419
limiting this scope of cryptographic

00:28:38,149 --> 00:28:43,009
keys in the system a device could have

00:28:41,419 --> 00:28:44,779
multiple keys and you don't want that

00:28:43,009 --> 00:28:47,509
key to be visible to the whole system

00:28:44,779 --> 00:28:50,299
you you might want to be able to make

00:28:47,509 --> 00:28:52,610
use of use of it from the whole system

00:28:50,299 --> 00:28:55,129
but the keys that key itself should not

00:28:52,610 --> 00:28:58,850
be exposed because that exposes a bigger

00:28:55,129 --> 00:29:00,679
threat to the overall system and that I

00:28:58,850 --> 00:29:02,389
could not be just limited to the device

00:29:00,679 --> 00:29:05,000
it could mean if the if you have a cross

00:29:02,389 --> 00:29:07,990
key that class key could mean attack on

00:29:05,000 --> 00:29:10,190
the the other side of the infrastructure

00:29:07,990 --> 00:29:13,370
so the the underlying principle is

00:29:10,190 --> 00:29:15,080
hiding the keys from the system and at

00:29:13,370 --> 00:29:18,679
the same time making sure that the

00:29:15,080 --> 00:29:20,509
system can make use of these keys then

00:29:18,679 --> 00:29:23,419
again it's a multi-layered question it's

00:29:20,509 --> 00:29:26,450
a multi-layered problem not all keys are

00:29:23,419 --> 00:29:29,539
same in the system if you look at the

00:29:26,450 --> 00:29:30,050
bottom of this picture the yellow boxes

00:29:29,539 --> 00:29:33,020
represent

00:29:30,050 --> 00:29:36,440
hardware keys and these hundred keys

00:29:33,020 --> 00:29:38,480
could be coming from different different

00:29:36,440 --> 00:29:40,760
different entities in the supply chain

00:29:38,480 --> 00:29:42,350
there could be some keys coming from the

00:29:40,760 --> 00:29:44,810
chip manufacturers piece coming from the

00:29:42,350 --> 00:29:47,660
device manufacturer keys could coming

00:29:44,810 --> 00:29:50,330
from a third party and they all don't

00:29:47,660 --> 00:29:53,120
share the same same level of trust with

00:29:50,330 --> 00:29:56,090
each other so it is required to make

00:29:53,120 --> 00:29:58,340
sure that the accesses to the the

00:29:56,090 --> 00:29:59,900
hardware keys is limited and they cannot

00:29:58,340 --> 00:30:03,490
be they should not be able to see in

00:29:59,900 --> 00:30:07,280
from most of the system at the same time

00:30:03,490 --> 00:30:09,770
they should not be even usable by all of

00:30:07,280 --> 00:30:13,700
the system if you're talking about a

00:30:09,770 --> 00:30:15,440
chip manufacturers key if a software and

00:30:13,700 --> 00:30:18,050
he wants to make use of the chip

00:30:15,440 --> 00:30:21,290
manufacturing manufacturers key it has

00:30:18,050 --> 00:30:24,980
to prove that it is authorized entity to

00:30:21,290 --> 00:30:27,230
make use of that that key so that's why

00:30:24,980 --> 00:30:29,780
you see so as I said is is a

00:30:27,230 --> 00:30:31,610
multi-layered problem now when you move

00:30:29,780 --> 00:30:33,830
away from the hardware keys there it

00:30:31,610 --> 00:30:38,540
will be software keys based on use case

00:30:33,830 --> 00:30:41,690
that will be stored in flash through

00:30:38,540 --> 00:30:43,310
secure storage they have a different

00:30:41,690 --> 00:30:44,980
level of security requirements and

00:30:43,310 --> 00:30:48,650
different level of visibility

00:30:44,980 --> 00:30:51,380
requirements that's why the crypto

00:30:48,650 --> 00:30:56,900
service is intended to be split into the

00:30:51,380 --> 00:30:59,810
blue box and the green box blue box in

00:30:56,900 --> 00:31:01,700
the in the middle basically represents

00:30:59,810 --> 00:31:04,820
the part which handles the hardware keys

00:31:01,700 --> 00:31:08,480
and abstracts the uses of the hardware

00:31:04,820 --> 00:31:09,650
key so it can it can vet who is making a

00:31:08,480 --> 00:31:11,660
call and who is make trying to make

00:31:09,650 --> 00:31:13,070
access to the hardware keys and make

00:31:11,660 --> 00:31:14,380
sure that it doesn't fall into the wrong

00:31:13,070 --> 00:31:17,480
hands

00:31:14,380 --> 00:31:20,150
it also provides abstraction on top of

00:31:17,480 --> 00:31:23,150
the hardware accelerators so if you have

00:31:20,150 --> 00:31:27,400
harder accelerators which can offload

00:31:23,150 --> 00:31:32,060
the cryptographic load from the CPU to a

00:31:27,400 --> 00:31:34,420
accelerator this abstracts that that

00:31:32,060 --> 00:31:36,770
thought so the higher level of the

00:31:34,420 --> 00:31:37,570
software doesn't need to change based on

00:31:36,770 --> 00:31:42,279
what we

00:31:37,570 --> 00:31:46,229
in a typical silicon the green box on

00:31:42,279 --> 00:31:48,759
top and again the blue box is again

00:31:46,229 --> 00:31:51,100
limit the access to the blue box or

00:31:48,759 --> 00:31:52,960
calls to the blue box are limited to a

00:31:51,100 --> 00:31:56,080
very specific entities on the secure

00:31:52,960 --> 00:31:58,659
side just to make sure that the keys are

00:31:56,080 --> 00:32:01,179
the hardware keys are not being usable

00:31:58,659 --> 00:32:05,169
by they're not they cannot be used by

00:32:01,179 --> 00:32:07,749
emulation factors the green box this

00:32:05,169 --> 00:32:11,049
provides the user facing API is that can

00:32:07,749 --> 00:32:12,940
be used by rest of the systems the

00:32:11,049 --> 00:32:14,619
reserve system will includes the non

00:32:12,940 --> 00:32:17,320
secure side so a non secure side can

00:32:14,619 --> 00:32:19,539
make a call to secure side and that that

00:32:17,320 --> 00:32:20,889
call will land into the green box the

00:32:19,539 --> 00:32:23,259
green box will decide what to do with

00:32:20,889 --> 00:32:27,669
that request for the cryptographic

00:32:23,259 --> 00:32:32,440
operation and basically act on that

00:32:27,669 --> 00:32:34,599
request the green box can be called by

00:32:32,440 --> 00:32:38,649
other green boxes as well on the secure

00:32:34,599 --> 00:32:42,549
side so this is a very high-level view

00:32:38,649 --> 00:32:44,379
of what key FM's Crippler service will

00:32:42,549 --> 00:32:47,529
look like we have a primitive implement

00:32:44,379 --> 00:32:51,720
implementation in the upstream but this

00:32:47,529 --> 00:32:51,720
is this is the final picture

00:32:54,440 --> 00:33:02,330
the crypto service is complemented by

00:32:57,270 --> 00:33:04,500
secure storage secure storage provides a

00:33:02,330 --> 00:33:07,160
confidentiality integrity and

00:33:04,500 --> 00:33:12,270
authenticity protected way of storing

00:33:07,160 --> 00:33:15,750
systems security critical assets it

00:33:12,270 --> 00:33:17,190
makes sure that the whatever is whatever

00:33:15,750 --> 00:33:19,050
it makes sure's is that even if the

00:33:17,190 --> 00:33:21,870
underlying physical medium the physical

00:33:19,050 --> 00:33:25,350
storage medium is not secured using

00:33:21,870 --> 00:33:28,980
cryptography the the the plaintext

00:33:25,350 --> 00:33:31,800
visibility of keys and the cryptographic

00:33:28,980 --> 00:33:37,110
assets is limited again to the secure

00:33:31,800 --> 00:33:40,140
side software entities the secure

00:33:37,110 --> 00:33:42,420
storage is tied as I said it uses

00:33:40,140 --> 00:33:44,070
cryptography to do the confidentiality

00:33:42,420 --> 00:33:48,810
integrity and authenticity into

00:33:44,070 --> 00:33:52,530
production and and it uses a yes GCM to

00:33:48,810 --> 00:33:54,570
perform that operation and the a is GCM

00:33:52,530 --> 00:33:58,110
operation again is tied to a hardware

00:33:54,570 --> 00:33:59,910
unique key derived key so that if you

00:33:58,110 --> 00:34:01,440
plug in plug out the secure service from

00:33:59,910 --> 00:34:03,450
one device and try to plug in into

00:34:01,440 --> 00:34:05,970
another device it will not work because

00:34:03,450 --> 00:34:08,190
it is signed to a unique key for that

00:34:05,970 --> 00:34:10,400
device signed and encrypted using a

00:34:08,190 --> 00:34:12,780
unique key on that device and that

00:34:10,400 --> 00:34:17,250
unique key will be different on a

00:34:12,780 --> 00:34:20,340
different device the secure storage

00:34:17,250 --> 00:34:24,690
again leverages on the blue box of the

00:34:20,340 --> 00:34:27,870
crypto service so remember I said in the

00:34:24,690 --> 00:34:30,570
in the I said in the in this slide that

00:34:27,870 --> 00:34:33,330
the blue blue box is limited to very few

00:34:30,570 --> 00:34:35,160
entities this is the other entity which

00:34:33,330 --> 00:34:38,430
can make use of the blue box of the

00:34:35,160 --> 00:34:42,420
creeper service there are two reasons of

00:34:38,430 --> 00:34:44,760
that the the the secure service service

00:34:42,420 --> 00:34:47,250
needs to make use of hardware unique key

00:34:44,760 --> 00:34:50,880
so the blue box provides an abstraction

00:34:47,250 --> 00:34:53,400
a and a key derivation tree for hardware

00:34:50,880 --> 00:34:56,160
unique key so it makes sure that the

00:34:53,400 --> 00:34:58,830
hardware the secure storage is given its

00:34:56,160 --> 00:35:01,170
own derived key and it maintains a key

00:34:58,830 --> 00:35:03,090
hierarchy so that two entities on a

00:35:01,170 --> 00:35:05,790
system which wants to make use of order

00:35:03,090 --> 00:35:08,160
unique key do not end up having

00:35:05,790 --> 00:35:11,430
same key or do not end up being able to

00:35:08,160 --> 00:35:14,400
derive the same key maliciously so

00:35:11,430 --> 00:35:18,060
that's the reason one the reason to if

00:35:14,400 --> 00:35:20,880
the green box here makes call to the

00:35:18,060 --> 00:35:23,070
green box on the green box of the crypto

00:35:20,880 --> 00:35:26,190
service there is a cyclic dependency

00:35:23,070 --> 00:35:29,940
here the crypto service needs to make

00:35:26,190 --> 00:35:31,830
use of secure storage to access the

00:35:29,940 --> 00:35:34,080
assets which are stored in the secure

00:35:31,830 --> 00:35:36,750
storage at the same time secure storage

00:35:34,080 --> 00:35:39,060
needs to make acts and make need to make

00:35:36,750 --> 00:35:41,850
use of crypto service to decrypt the

00:35:39,060 --> 00:35:43,560
content and the flavor doesn't allow

00:35:41,850 --> 00:35:46,890
this kind of cyclic dependency because

00:35:43,560 --> 00:35:49,200
the calls are blocking so having this

00:35:46,890 --> 00:35:51,950
blue blocks also solves a cyclic

00:35:49,200 --> 00:35:51,950
dependency problem

00:35:56,880 --> 00:36:03,730
there's another important aspect to

00:36:00,119 --> 00:36:06,039
secure storage we have implemented file

00:36:03,730 --> 00:36:08,079
system so this is a file system which is

00:36:06,039 --> 00:36:10,539
highly optimized for embedded

00:36:08,079 --> 00:36:14,619
applications and which does it does a

00:36:10,539 --> 00:36:17,619
very specific job at the same time the

00:36:14,619 --> 00:36:20,920
file system is abstracted so there are

00:36:17,619 --> 00:36:22,599
clear interfaces define and if a use

00:36:20,920 --> 00:36:25,270
case required a bit more sophisticated

00:36:22,599 --> 00:36:29,260
file system and the systems requirement

00:36:25,270 --> 00:36:30,789
are a bit more divergent then a

00:36:29,260 --> 00:36:33,160
different file system can be plugged in

00:36:30,789 --> 00:36:41,319
while still making use of the rest of

00:36:33,160 --> 00:36:45,400
the security of the storage solution the

00:36:41,319 --> 00:36:48,160
third service audit log audit log

00:36:45,400 --> 00:36:51,460
provides protection against repudiation

00:36:48,160 --> 00:36:54,970
attacks what this means is if let's say

00:36:51,460 --> 00:36:58,359
a this is a point-of-sale device which

00:36:54,970 --> 00:37:00,339
handles financial transactions and some

00:36:58,359 --> 00:37:02,430
financial transaction was initiated by

00:37:00,339 --> 00:37:05,140
an entity and later on that entity

00:37:02,430 --> 00:37:07,299
declines that it even ever tried to make

00:37:05,140 --> 00:37:09,460
that transaction now

00:37:07,299 --> 00:37:12,670
horrid log makes sure that the system's

00:37:09,460 --> 00:37:14,980
security critical events are logged so

00:37:12,670 --> 00:37:17,740
that the original initiator of the

00:37:14,980 --> 00:37:19,450
request cannot deny it and it's logged

00:37:17,740 --> 00:37:22,059
in a way that that is integrity

00:37:19,450 --> 00:37:24,819
protected and confidential and what's in

00:37:22,059 --> 00:37:26,650
the city protected so entity which made

00:37:24,819 --> 00:37:29,760
a call cannot deny later on that it made

00:37:26,650 --> 00:37:29,760
the call in the first place

00:37:29,819 --> 00:37:34,990
what is log is not defined by the audit

00:37:32,829 --> 00:37:37,180
log this is the highly used case

00:37:34,990 --> 00:37:40,000
dependent the use case developer has to

00:37:37,180 --> 00:37:42,490
decide what is the security key security

00:37:40,000 --> 00:37:44,200
critical event of the system and need to

00:37:42,490 --> 00:37:48,849
decide what to be what should be locked

00:37:44,200 --> 00:37:51,250
what shouldn't be locked the audit log

00:37:48,849 --> 00:37:53,559
service also provides a secure retrieval

00:37:51,250 --> 00:37:57,220
of the audit logs so that it can be

00:37:53,559 --> 00:37:59,170
securely transported to the a server

00:37:57,220 --> 00:38:02,200
which can analyze these logs and make

00:37:59,170 --> 00:38:06,590
some can do some analysis or some new

00:38:02,200 --> 00:38:13,580
posts do some post-mortem based on the

00:38:06,590 --> 00:38:16,340
content of the module okay so we are in

00:38:13,580 --> 00:38:18,980
quite late on the schedule let's see if

00:38:16,340 --> 00:38:22,250
you can I'm going to skip the bootloader

00:38:18,980 --> 00:38:25,220
part we can cover some of this tomorrow

00:38:22,250 --> 00:38:29,510
if there is a specific interest but for

00:38:25,220 --> 00:38:33,590
today I'm going to skip this and it's

00:38:29,510 --> 00:38:35,750
just in the interest of time I have few

00:38:33,590 --> 00:38:39,230
use case scenarios let's see how many we

00:38:35,750 --> 00:38:41,840
can cover and if you have a specific

00:38:39,230 --> 00:38:44,570
question on the rest of the use cases we

00:38:41,840 --> 00:38:50,480
can talk afterwards as well the first is

00:38:44,570 --> 00:38:51,980
run time device provisioning what run

00:38:50,480 --> 00:38:58,760
time device determining is meant to do

00:38:51,980 --> 00:39:00,830
is provide a secure way of provision the

00:38:58,760 --> 00:39:02,480
device what this means is if you have

00:39:00,830 --> 00:39:04,940
certain contents stored in the secure

00:39:02,480 --> 00:39:09,170
storage you should be able to securely

00:39:04,940 --> 00:39:10,700
update them over-the-air through through

00:39:09,170 --> 00:39:14,780
some commands from the from the server

00:39:10,700 --> 00:39:16,610
and any malicious actor in between

00:39:14,780 --> 00:39:21,350
should not be able to tamper with the

00:39:16,610 --> 00:39:24,650
whole transaction so typical flow could

00:39:21,350 --> 00:39:27,560
be a provisioning request constant

00:39:24,650 --> 00:39:29,660
server says that I want to provision new

00:39:27,560 --> 00:39:31,700
assets on the device the sets could be

00:39:29,660 --> 00:39:34,160
your PSK TLS keys could be your

00:39:31,700 --> 00:39:37,040
provisioning keys or it could be any

00:39:34,160 --> 00:39:40,100
other use cases specific asset on the

00:39:37,040 --> 00:39:41,990
device so service and sends a command to

00:39:40,100 --> 00:39:44,270
the provisioning client on the non

00:39:41,990 --> 00:39:46,070
secure side the provisioning client

00:39:44,270 --> 00:39:48,050
tells to the provisioning service on the

00:39:46,070 --> 00:39:50,390
secure side hey there is a request for

00:39:48,050 --> 00:39:52,580
provisioning what should I do the

00:39:50,390 --> 00:39:55,490
provisioning service said it replies

00:39:52,580 --> 00:39:58,820
back with a with a challenge it says

00:39:55,490 --> 00:40:00,680
that Harris here is a token if you want

00:39:58,820 --> 00:40:02,660
to send me a provisioning command next

00:40:00,680 --> 00:40:05,240
time or will provide provisioning blob

00:40:02,660 --> 00:40:08,750
next time you better sign the blog with

00:40:05,240 --> 00:40:10,610
this challenge the protein client will

00:40:08,750 --> 00:40:14,880
take the challenge and pass it on to the

00:40:10,610 --> 00:40:17,910
cloud cloud we'll take the challenge now

00:40:14,880 --> 00:40:20,700
get the block get the the provisioning

00:40:17,910 --> 00:40:22,950
blog which will include the the

00:40:20,700 --> 00:40:25,650
provisioning keys and all the data that

00:40:22,950 --> 00:40:27,630
need to provision in some format and

00:40:25,650 --> 00:40:30,150
take the challenge sign it together and

00:40:27,630 --> 00:40:33,060
keep it together and pass it back to the

00:40:30,150 --> 00:40:34,770
provisioning client provisioning client

00:40:33,060 --> 00:40:36,320
passes on the same blood blob to the

00:40:34,770 --> 00:40:38,940
provisioning service on the secure side

00:40:36,320 --> 00:40:41,250
secure side provide the performs

00:40:38,940 --> 00:40:45,000
authentication check and it has a

00:40:41,250 --> 00:40:46,500
reference to the old challenge it can

00:40:45,000 --> 00:40:48,510
compare the challenge and it can perform

00:40:46,500 --> 00:40:50,490
the authentication on the block and it

00:40:48,510 --> 00:40:54,660
all matches is good it goes ahead and

00:40:50,490 --> 00:40:58,130
updates the content of the secure

00:40:54,660 --> 00:40:58,130
storage with the new assets

00:41:07,210 --> 00:41:10,770
I'm going to skip this one as well

00:41:15,260 --> 00:41:19,280
at the station I promise to talk about I

00:41:17,119 --> 00:41:21,349
stood at the station a bit in the

00:41:19,280 --> 00:41:25,609
earlier slide so I'll try to cover this

00:41:21,349 --> 00:41:30,859
as as quickly as possible at the station

00:41:25,609 --> 00:41:32,359
is a way of passing on devices devices

00:41:30,859 --> 00:41:35,450
specific information back to the server

00:41:32,359 --> 00:41:38,680
and providing some critical information

00:41:35,450 --> 00:41:41,240
about the device to the remote entity

00:41:38,680 --> 00:41:43,369
what this information could mean could

00:41:41,240 --> 00:41:45,530
include is the boots signature of the

00:41:43,369 --> 00:41:48,710
device how much time it took to boot

00:41:45,530 --> 00:41:51,140
arms time what was the image signature

00:41:48,710 --> 00:41:53,960
that is being done on the device

00:41:51,140 --> 00:41:56,059
what is the device's identity what is

00:41:53,960 --> 00:41:58,940
its geographical location and it could

00:41:56,059 --> 00:42:04,309
be any other vendor defined at the

00:41:58,940 --> 00:42:06,710
station data did this helps in assessing

00:42:04,309 --> 00:42:08,680
the device's sanity and assessing what's

00:42:06,710 --> 00:42:11,240
running on the device and assessing that

00:42:08,680 --> 00:42:14,260
whether it is compromised or not and if

00:42:11,240 --> 00:42:16,700
the device is compromised and these

00:42:14,260 --> 00:42:18,890
attestation data will tell to the remote

00:42:16,700 --> 00:42:21,020
entity that there's something has gone

00:42:18,890 --> 00:42:23,089
wrong do take some corrective actions

00:42:21,020 --> 00:42:25,960
and that's for the remote entity to

00:42:23,089 --> 00:42:25,960
decide what to do next

00:42:29,109 --> 00:42:37,990
it's fairly similar flow as the earlier

00:42:33,559 --> 00:42:41,720
one the the cloud sends cloud makes a

00:42:37,990 --> 00:42:42,950
makes a request for our test station he

00:42:41,720 --> 00:42:46,040
said that cannon can you send the

00:42:42,950 --> 00:42:48,160
decision data back to me it again comes

00:42:46,040 --> 00:42:50,839
to the client on the non-secure side it

00:42:48,160 --> 00:42:52,849
it declined passes on the request to the

00:42:50,839 --> 00:42:55,190
secure side it also passes on the

00:42:52,849 --> 00:42:58,700
challenge that server would have given

00:42:55,190 --> 00:43:01,160
to the decision client the attestation

00:42:58,700 --> 00:43:02,990
service would have collected the data in

00:43:01,160 --> 00:43:06,140
advance some of the data it may collect

00:43:02,990 --> 00:43:08,990
on the run time based on when there's it

00:43:06,140 --> 00:43:12,740
when this own specification about the

00:43:08,990 --> 00:43:14,720
attestation data the attestation service

00:43:12,740 --> 00:43:17,359
will collect all this data the

00:43:14,720 --> 00:43:19,069
attestation data combine the attestation

00:43:17,359 --> 00:43:21,230
data with the challenge that came from

00:43:19,069 --> 00:43:24,050
the server sign it together

00:43:21,230 --> 00:43:26,390
encrypt it together and pass it back to

00:43:24,050 --> 00:43:29,180
the server and the server can now

00:43:26,390 --> 00:43:33,320
basically authenticate the blob and

00:43:29,180 --> 00:43:34,730
decrypt and it doesn't always have to

00:43:33,320 --> 00:43:36,800
have to be encrypted but it must be

00:43:34,730 --> 00:43:39,530
signed it must be authentic integrity

00:43:36,800 --> 00:43:41,990
protected so the server decides whether

00:43:39,530 --> 00:43:43,820
the data is compromised or not if the

00:43:41,990 --> 00:43:46,340
data is not compromised then it will go

00:43:43,820 --> 00:43:48,770
on and evaluate what's the content and

00:43:46,340 --> 00:43:51,140
Beyond based on that basis it can take

00:43:48,770 --> 00:44:00,560
the next corrective action or whatever

00:43:51,140 --> 00:44:05,240
you need to do so how are we doing it is

00:44:00,560 --> 00:44:06,890
time we have ten minutes left so this is

00:44:05,240 --> 00:44:09,770
slide about how you can get involved in

00:44:06,890 --> 00:44:11,630
this project there's a lot of

00:44:09,770 --> 00:44:14,390
documentation in the interested firmware

00:44:11,630 --> 00:44:17,000
dot on a website you can talk to us we

00:44:14,390 --> 00:44:19,280
are I will be sitting in the light

00:44:17,000 --> 00:44:23,860
hacking room most of times so if you

00:44:19,280 --> 00:44:23,860
wanted this is something I'll be there

00:44:25,240 --> 00:44:31,760
and if you're a serial meeting you can

00:44:28,430 --> 00:44:36,070
schedule the meeting as well a very

00:44:31,760 --> 00:44:36,070
quick look at what is coming up next

00:44:36,580 --> 00:44:42,200
the current IPC implementation is still

00:44:39,920 --> 00:44:44,660
in the inner feature branch in our code

00:44:42,200 --> 00:44:46,880
base at some point it will be merged

00:44:44,660 --> 00:44:48,800
back into the master branch and all of

00:44:46,880 --> 00:44:52,340
the existing services will also support

00:44:48,800 --> 00:44:55,190
the IPC model of the communication then

00:44:52,340 --> 00:44:57,980
there is prototyping work going on for

00:44:55,190 --> 00:45:00,350
the secure side interrupt handling we

00:44:57,980 --> 00:45:04,160
don't the current codebase doesn't allow

00:45:00,350 --> 00:45:05,360
secure interrupt handling yet I think in

00:45:04,160 --> 00:45:09,500
next quarter we should be able to see

00:45:05,360 --> 00:45:11,570
some implementation there then there is

00:45:09,500 --> 00:45:15,170
a she ruling aspect of the DSM the

00:45:11,570 --> 00:45:17,660
current implementation allows single

00:45:15,170 --> 00:45:19,370
call to the secure side and that again

00:45:17,660 --> 00:45:21,380
is the blocking call it will it cannot

00:45:19,370 --> 00:45:26,630
come back until it finishes the whole

00:45:21,380 --> 00:45:29,330
thing so yeah what this means if there

00:45:26,630 --> 00:45:31,430
is a transaction being triggered on a

00:45:29,330 --> 00:45:33,050
secured Hardware let's say if you are

00:45:31,430 --> 00:45:34,430
trying to do some crypto operation and

00:45:33,050 --> 00:45:38,089
the crypto operation is actually being

00:45:34,430 --> 00:45:40,010
done by crypto accelerator the CPU is 3

00:45:38,089 --> 00:45:44,000
so CPU can do something useful

00:45:40,010 --> 00:45:46,309
currently it cannot go back but if you

00:45:44,000 --> 00:45:48,710
introduce some scheduler features the

00:45:46,309 --> 00:45:55,430
CPU can cycles can be reused to perform

00:45:48,710 --> 00:45:57,050
another non secure side operation then

00:45:55,430 --> 00:45:59,839
there are enhancements plant for

00:45:57,050 --> 00:46:02,390
insecure service crypto service which

00:45:59,839 --> 00:46:07,280
includes the handling of asymmetric

00:46:02,390 --> 00:46:10,130
cryptography and yeah that's and the

00:46:07,280 --> 00:46:12,170
general evolution of other services the

00:46:10,130 --> 00:46:13,849
attestation service is kind of being

00:46:12,170 --> 00:46:15,950
designed right now you should be able to

00:46:13,849 --> 00:46:19,339
see some level of details in the next

00:46:15,950 --> 00:46:22,790
quarter then the definition of

00:46:19,339 --> 00:46:24,170
provisioning service and is going on we

00:46:22,790 --> 00:46:29,869
should again be able to share some

00:46:24,170 --> 00:46:32,030
details next quarter or in q1 there is a

00:46:29,869 --> 00:46:35,809
standardization work going on about the

00:46:32,030 --> 00:46:37,309
TBA Halicki eyes so to ensure that to

00:46:35,809 --> 00:46:39,859
ensure that the migration from one

00:46:37,309 --> 00:46:43,309
platform to another platform is as

00:46:39,859 --> 00:46:47,150
painless as possible and then we are

00:46:43,309 --> 00:46:49,329
also creating thread models for the

00:46:47,150 --> 00:46:51,559
different aspects of the TFM software

00:46:49,329 --> 00:46:53,480
they will also start appearing in the

00:46:51,559 --> 00:46:56,650
TSM code base or in the trusted from

00:46:53,480 --> 00:46:56,650
where website

00:46:58,590 --> 00:47:03,340
last few minutes was some more questions

00:47:01,050 --> 00:47:05,590
we have two more actually three more

00:47:03,340 --> 00:47:09,220
sessions planned there's one boss

00:47:05,590 --> 00:47:11,440
session about the IT security that again

00:47:09,220 --> 00:47:13,930
is a very open session I don't have a

00:47:11,440 --> 00:47:15,820
lot of slides for that I'm hoping that

00:47:13,930 --> 00:47:17,770
we'll have more dialogue and it will be

00:47:15,820 --> 00:47:19,300
more discussion during session rather

00:47:17,770 --> 00:47:22,930
than me trying to present some flies

00:47:19,300 --> 00:47:26,140
slides then there is a generic project

00:47:22,930 --> 00:47:28,840
update the trusted from where the

00:47:26,140 --> 00:47:32,730
project update and there are some other

00:47:28,840 --> 00:47:32,730
sessions around trusted from where CI

00:47:32,910 --> 00:47:36,080
[Music]

00:47:40,020 --> 00:47:47,100
sorry how's the software and the secure

00:47:45,210 --> 00:47:48,390
privilege domain updated or is that

00:47:47,100 --> 00:47:52,280
something that's done that's a really

00:47:48,390 --> 00:47:54,540
trust one-time flash very good question

00:47:52,280 --> 00:48:02,970
let me see if I can navigate to the

00:47:54,540 --> 00:48:06,000
right yeah all right so this has this

00:48:02,970 --> 00:48:08,130
has come multiple aspects there is a non

00:48:06,000 --> 00:48:10,800
secure side aspect which can interact

00:48:08,130 --> 00:48:15,690
with the server to fetch the updated

00:48:10,800 --> 00:48:18,420
blob on the device now it could be it's

00:48:15,690 --> 00:48:20,850
possible to just the fish the new

00:48:18,420 --> 00:48:23,370
firmware from the cloud put it on the

00:48:20,850 --> 00:48:24,720
flash directly in a different slot and

00:48:23,370 --> 00:48:27,150
let the boot order decide whether it's

00:48:24,720 --> 00:48:30,270
valid valid from there or not that's one

00:48:27,150 --> 00:48:32,640
option but that can open a lot of attack

00:48:30,270 --> 00:48:35,040
vectors and it may wear out the flash

00:48:32,640 --> 00:48:36,600
and if let's say some malicious actor is

00:48:35,040 --> 00:48:39,510
able to manipulate the null secure

00:48:36,600 --> 00:48:41,610
update client to write to the flash that

00:48:39,510 --> 00:48:43,680
basically essentially you're wearing out

00:48:41,610 --> 00:48:46,550
the flash and that could be a potential

00:48:43,680 --> 00:48:49,050
attack vector so the update line

00:48:46,550 --> 00:48:52,650
downloads the firmware make sure makes

00:48:49,050 --> 00:48:54,030
sure that it is it's a signature

00:48:52,650 --> 00:48:55,980
it's a cryptographic signature is

00:48:54,030 --> 00:48:59,790
alright it is matching with what it says

00:48:55,980 --> 00:49:04,140
and then only it programs the binary

00:48:59,790 --> 00:49:06,960
block into the flash and the signature

00:49:04,140 --> 00:49:08,250
check part is done by the secure side of

00:49:06,960 --> 00:49:11,190
the software the creeper service that I

00:49:08,250 --> 00:49:12,390
mentioned so that that's the bit that's

00:49:11,190 --> 00:49:16,260
where the job of the update client

00:49:12,390 --> 00:49:17,880
finishes but so far the image is just

00:49:16,260 --> 00:49:20,910
sitting in a flash is still not being

00:49:17,880 --> 00:49:23,760
used once the image is downloaded it

00:49:20,910 --> 00:49:26,460
will trigger a reboot of the system so

00:49:23,760 --> 00:49:28,650
when the boot order comes in play it

00:49:26,460 --> 00:49:30,390
sees there's a new image let's do

00:49:28,650 --> 00:49:32,970
something with it now it will perform

00:49:30,390 --> 00:49:35,450
also of checks on that image again it'll

00:49:32,970 --> 00:49:38,640
see if it has been rolled back image a

00:49:35,450 --> 00:49:42,870
is it old image that was used in the

00:49:38,640 --> 00:49:45,900
past or is it actually properly secured

00:49:42,870 --> 00:49:47,790
new image it does all sort of checks and

00:49:45,900 --> 00:49:48,600
if it passes then it swaps the images

00:49:47,790 --> 00:49:51,120
the

00:49:48,600 --> 00:49:55,020
image is basically soft with the new

00:49:51,120 --> 00:49:58,470
image and then that kind of marks the

00:49:55,020 --> 00:50:00,450
completion of the update process there's

00:49:58,470 --> 00:50:03,600
another aspect to it let's say the new

00:50:00,450 --> 00:50:03,780
image is has some problems you could

00:50:03,600 --> 00:50:06,510
have

00:50:03,780 --> 00:50:10,380
very devices specific problems and that

00:50:06,510 --> 00:50:15,570
may mean that former image if it has not

00:50:10,380 --> 00:50:17,520
been tested properly on the side it may

00:50:15,570 --> 00:50:19,320
not work on certain devices what so

00:50:17,520 --> 00:50:23,640
there is a feature in the bootloader

00:50:19,320 --> 00:50:25,410
which allows you to say yeah he was just

00:50:23,640 --> 00:50:28,290
fine in the runtime so when the firmware

00:50:25,410 --> 00:50:31,050
is booted up you can do some you can

00:50:28,290 --> 00:50:33,120
perform some built-in tests to say to

00:50:31,050 --> 00:50:35,730
check if the new image is booting fine

00:50:33,120 --> 00:50:40,200
or not that's it some flag on the device

00:50:35,730 --> 00:50:43,710
and that's when the whole boot update

00:50:40,200 --> 00:50:45,830
operation is considered completed thank

00:50:43,710 --> 00:50:45,830
you

00:50:58,250 --> 00:51:05,359
I actually just on the you mentioned

00:51:02,869 --> 00:51:09,250
earlier about this glue API between two

00:51:05,359 --> 00:51:13,220
the crypto service okay I was wondering

00:51:09,250 --> 00:51:16,070
is this just an internal TFM thing to

00:51:13,220 --> 00:51:18,859
provide you know api between the various

00:51:16,070 --> 00:51:21,260
services provided by the TFM project or

00:51:18,859 --> 00:51:36,560
is it a more open api that other

00:51:21,260 --> 00:51:39,470
services right so I guess you're talking

00:51:36,560 --> 00:51:41,810
about the DFM crypto glue API this is

00:51:39,470 --> 00:51:43,430
again on top of the IPC so here all

00:51:41,810 --> 00:51:46,460
following the IPC model of the

00:51:43,430 --> 00:51:49,580
communication this will have IPC

00:51:46,460 --> 00:51:52,640
underneath and then there'll be C C

00:51:49,580 --> 00:51:54,230
libraries built on top of the IPC so the

00:51:52,640 --> 00:51:58,910
communication method method is still the

00:51:54,230 --> 00:52:00,440
standard communication method which is

00:51:58,910 --> 00:52:03,619
used for communication communicating

00:52:00,440 --> 00:52:07,570
between two different blobs on the

00:52:03,619 --> 00:52:10,940
secure side what glue API means here is

00:52:07,570 --> 00:52:16,190
some sort of CSE file abstraction on top

00:52:10,940 --> 00:52:18,440
of that bare IPC yeah I was just

00:52:16,190 --> 00:52:20,510
wondering if you know when when there's

00:52:18,440 --> 00:52:22,460
a new version of TFM can it are you free

00:52:20,510 --> 00:52:24,320
to just change those API as you like

00:52:22,460 --> 00:52:27,320
because it's all part of the TFM project

00:52:24,320 --> 00:52:30,410
or do you need to maintain potentially

00:52:27,320 --> 00:52:34,570
to other services not provided by the TM

00:52:30,410 --> 00:52:36,800
project at this point I don't see a

00:52:34,570 --> 00:52:38,900
problem I don't see a very complex

00:52:36,800 --> 00:52:42,290
problem there because it still as I said

00:52:38,900 --> 00:52:46,130
it's all TFM the the part that impacts

00:52:42,290 --> 00:52:48,470
to the rest of the ecosystem is the TBC

00:52:46,130 --> 00:52:50,830
holidays and basically the blue box

00:52:48,470 --> 00:52:55,849
might have some time up with a specific

00:52:50,830 --> 00:52:59,359
platform but the crypto glue API is as a

00:52:55,849 --> 00:53:02,080
series is more TFM internal however it

00:52:59,359 --> 00:53:05,410
will evolve as any any software does

00:53:02,080 --> 00:53:05,410
okay thanks

00:53:13,780 --> 00:53:17,280
okay last two minutes

00:53:22,480 --> 00:53:28,720
so regarding the reserved date of

00:53:25,420 --> 00:53:33,010
software so the last light we you

00:53:28,720 --> 00:53:36,099
imagine only to update software process

00:53:33,010 --> 00:53:41,500
settlement or including the spam can be

00:53:36,099 --> 00:53:43,119
updated yeah yes so wait let me try to

00:53:41,500 --> 00:53:45,190
get to a bigger picture sorry I don't

00:53:43,119 --> 00:53:47,550
have my laptop here so I really need to

00:53:45,190 --> 00:53:47,550
click

00:53:50,460 --> 00:53:57,750
yeah so in this hey everything is

00:53:54,210 --> 00:53:58,559
updatable whatever you see on the in

00:53:57,750 --> 00:54:01,319
this whole picture

00:53:58,559 --> 00:54:04,530
everything is applicable there is a

00:54:01,319 --> 00:54:07,770
debatable part which is bootloader so if

00:54:04,530 --> 00:54:12,000
you if you split the bootloader part

00:54:07,770 --> 00:54:16,500
into to the the silly the rom code and

00:54:12,000 --> 00:54:20,040
the updatable part of the then the boot

00:54:16,500 --> 00:54:22,980
boot array itself is updatable because

00:54:20,040 --> 00:54:24,480
there is another fallback in the rom but

00:54:22,980 --> 00:54:27,780
there's another topology possible where

00:54:24,480 --> 00:54:31,859
you say boot or a simple enough last

00:54:27,780 --> 00:54:33,270
word famous large words and and we we

00:54:31,859 --> 00:54:35,579
say that yeah it is good enough i mean

00:54:33,270 --> 00:54:38,579
better the bootloader code is going in

00:54:35,579 --> 00:54:42,740
the silicon in which case only the rest

00:54:38,579 --> 00:54:42,740
of the software is going to be updated

00:54:45,190 --> 00:54:52,300
but on this earth date so it means

00:54:49,390 --> 00:54:56,660
currently on the MCU to do there is no

00:54:52,300 --> 00:54:59,960
encrypted part so you imagine that in

00:54:56,660 --> 00:55:04,100
the day there is no sings hidden on the

00:54:59,960 --> 00:55:06,790
software received no it would be like it

00:55:04,100 --> 00:55:10,790
would be I mean on the update part

00:55:06,790 --> 00:55:13,390
received by the target everything is in

00:55:10,790 --> 00:55:18,290
Korea or its application will decrypt

00:55:13,390 --> 00:55:19,910
before in studying you are you talking

00:55:18,290 --> 00:55:25,370
about the case where the bootloader

00:55:19,910 --> 00:55:27,710
itself is updatable so the the a bit

00:55:25,370 --> 00:55:30,170
find it it doesn't have to decrypt it

00:55:27,710 --> 00:55:32,570
only it doesn't even have to do

00:55:30,170 --> 00:55:35,090
integrity check in theory it can just

00:55:32,570 --> 00:55:37,430
download whatever his service is is

00:55:35,090 --> 00:55:39,620
being sent by the server and dumped into

00:55:37,430 --> 00:55:42,220
the flash but as I said then it has some

00:55:39,620 --> 00:55:46,070
attack vectors so it is nicer to

00:55:42,220 --> 00:55:49,400
validate the image in the update client

00:55:46,070 --> 00:55:52,640
by using crypto service before dumping

00:55:49,400 --> 00:55:54,350
it into the flash and that's that's all

00:55:52,640 --> 00:55:57,500
literally the update client need to do

00:55:54,350 --> 00:55:59,690
at that point you reset the device boot

00:55:57,500 --> 00:56:02,810
order comes into play he sees that there

00:55:59,690 --> 00:56:06,190
is a new image in the in the flash and

00:56:02,810 --> 00:56:11,210
that's where it's going to decrypt and

00:56:06,190 --> 00:56:14,890
basically in DVD check again the

00:56:11,210 --> 00:56:14,890
firmware and program it again

00:56:20,450 --> 00:56:27,270
okay thank you everyone I think we have

00:56:25,650 --> 00:56:29,430
another session tomorrow so if you have

00:56:27,270 --> 00:56:30,860
more questions we can talk to mama thank

00:56:29,430 --> 00:56:35,040
you

00:56:30,860 --> 00:56:40,050
[Applause]

00:56:35,040 --> 00:56:40,050

YouTube URL: https://www.youtube.com/watch?v=WW0k3cKuEkU


