Title: YVR18-508: System Firmware and Device Firmware Updates using UEFI Capsules
Publication date: 2018-10-23
Playlist: Linaro Connect Vancouver 2018
Description: 
	Firmware is responsible for low-level platform initialisation, establishing root-of-trust, and loading the operating system (OS). Signed UEFI Capsules define an OS-agnostic process for verified firmware updates, utilising the root-of-trust established by firmware. The open source FmpDevicePkg in TianoCore provides a simple method to update system firmware images and device firmware images using UEFI Capsules and the Firmware Management Protocol (FMP).\n\nThis session describes the EFI Development Kit II (EDK II) capsule implementation, implementing FMP using FmpDevicePkg, creating Signed UEFI Capsules using open source tools, and an update workflow based on the Linux Vendor Firmware Service (fwupd.org).
Captions: 
	00:00:02,110 --> 00:00:07,120
[Music]

00:00:08,190 --> 00:00:13,900
hello everybody my name is Michael

00:00:10,059 --> 00:00:16,599
Kinney I'm with Intel and I've been

00:00:13,900 --> 00:00:20,349
involved in UEFI firmware from since

00:00:16,599 --> 00:00:23,259
about 1999 and am one of the edk to

00:00:20,349 --> 00:00:25,480
maintain errs and kubarz on the channel

00:00:23,259 --> 00:00:29,769
core insight the open source

00:00:25,480 --> 00:00:31,720
implementation of UEFI and in the past

00:00:29,769 --> 00:00:33,430
year or the most of this year I've been

00:00:31,720 --> 00:00:35,739
really focused on some of the capsule

00:00:33,430 --> 00:00:37,059
update elements and making big

00:00:35,739 --> 00:00:39,039
improvements to that so today I'm going

00:00:37,059 --> 00:00:41,010
to talk to you about those improvements

00:00:39,039 --> 00:00:44,559
we've made in the edk to implementation

00:00:41,010 --> 00:00:47,379
to use UEFI capsules to update not only

00:00:44,559 --> 00:00:49,719
system firmware but platforms composed

00:00:47,379 --> 00:00:51,850
of many other devices subsystems that

00:00:49,719 --> 00:00:52,899
may also have fermer loads in them that

00:00:51,850 --> 00:00:55,300
you want to be able to update those

00:00:52,899 --> 00:00:56,890
independently of your system firmware or

00:00:55,300 --> 00:00:59,320
even potentially update your system

00:00:56,890 --> 00:01:01,469
firmware and as a set of individual

00:00:59,320 --> 00:01:03,309
components as well so that's some of the

00:01:01,469 --> 00:01:04,180
things we've been working on this year

00:01:03,309 --> 00:01:06,479
so we'll go through some of those

00:01:04,180 --> 00:01:06,479
details

00:01:12,530 --> 00:01:17,720
so the first thing is one of the things

00:01:15,800 --> 00:01:20,030
we're also wanting to stress with some

00:01:17,720 --> 00:01:22,729
of our capsule update work for firmware

00:01:20,030 --> 00:01:25,100
is to make use of push servers for

00:01:22,729 --> 00:01:27,560
getting the firmware content out into

00:01:25,100 --> 00:01:29,330
the target systems so in this case we've

00:01:27,560 --> 00:01:31,310
been looking at the linux vendor

00:01:29,330 --> 00:01:33,380
firmware service as one of the ways to

00:01:31,310 --> 00:01:35,240
distribute promote content the

00:01:33,380 --> 00:01:37,340
development process we go through here

00:01:35,240 --> 00:01:40,490
as we start with the work we do one

00:01:37,340 --> 00:01:42,500
firmware whether it's for UEFI form or

00:01:40,490 --> 00:01:45,710
other firmware payloads that are in your

00:01:42,500 --> 00:01:47,360
platform you have to generate a UEFI

00:01:45,710 --> 00:01:49,759
capsule that contains that firmware

00:01:47,360 --> 00:01:51,619
payload once you've got a what you think

00:01:49,759 --> 00:01:53,810
is a good capsule with a validated set

00:01:51,619 --> 00:01:55,250
of firmware content you would then go

00:01:53,810 --> 00:01:57,649
through step two which is to publish

00:01:55,250 --> 00:02:00,680
that UA by capsule to a service like L

00:01:57,649 --> 00:02:02,690
DFS and then from that service it would

00:02:00,680 --> 00:02:05,270
then be distributed down to the set of

00:02:02,690 --> 00:02:07,850
target systems that support that UEFI

00:02:05,270 --> 00:02:09,590
capsule and those ufi capsules will then

00:02:07,850 --> 00:02:11,720
be processed on that set of target

00:02:09,590 --> 00:02:15,350
platforms to update the firmware for

00:02:11,720 --> 00:02:17,600
that component so for the talk today

00:02:15,350 --> 00:02:19,549
we're mostly focused on what does it

00:02:17,600 --> 00:02:20,840
mean to process those capsules so I'll

00:02:19,549 --> 00:02:22,250
go through some of those details and

00:02:20,840 --> 00:02:25,670
what does it take to actually implement

00:02:22,250 --> 00:02:28,519
in your UEFI firmware side the support

00:02:25,670 --> 00:02:30,910
needed to actually do that processing

00:02:28,519 --> 00:02:33,680
and update a newer boomer storage device

00:02:30,910 --> 00:02:35,660
40 or firmer payload and then we'll also

00:02:33,680 --> 00:02:36,799
talk briefly about the council

00:02:35,660 --> 00:02:38,750
generation side and some of the

00:02:36,799 --> 00:02:41,140
improvements we've made on that aspect

00:02:38,750 --> 00:02:41,140
as well

00:02:43,270 --> 00:02:47,770
so looking at this picture which is one

00:02:46,390 --> 00:02:50,110
of the standard pictures from the

00:02:47,770 --> 00:02:52,390
platform initialization specification

00:02:50,110 --> 00:02:53,770
about how a system boots and the various

00:02:52,390 --> 00:02:55,300
phases and we'll go over this as far as

00:02:53,770 --> 00:02:56,770
what it means when we're processing a

00:02:55,300 --> 00:03:00,910
capsule through these various boot

00:02:56,770 --> 00:03:02,860
phases of edk to firmware starts the

00:03:00,910 --> 00:03:04,870
security phase and then the PEI phase

00:03:02,860 --> 00:03:07,150
where basic platform initialization

00:03:04,870 --> 00:03:09,370
occurs silicon and initialization occurs

00:03:07,150 --> 00:03:11,200
then on to the dixie environment whose

00:03:09,370 --> 00:03:14,020
job is to produce the standard set of

00:03:11,200 --> 00:03:15,910
UEFI services and also provide some of

00:03:14,020 --> 00:03:18,790
the i/o subsystems for booting your

00:03:15,910 --> 00:03:20,230
platform going into a boot manager from

00:03:18,790 --> 00:03:22,240
there you can do things like run some

00:03:20,230 --> 00:03:24,070
Diagnostics test the shell but you can

00:03:22,240 --> 00:03:25,900
also more importantly run your

00:03:24,070 --> 00:03:27,520
bootloader for your operating system and

00:03:25,900 --> 00:03:29,140
then get up into the run time we were

00:03:27,520 --> 00:03:31,870
actually booting an operating system and

00:03:29,140 --> 00:03:33,220
able to run some applications so if we

00:03:31,870 --> 00:03:37,000
look at this same picture from the

00:03:33,220 --> 00:03:38,770
perspective capsule update there's a

00:03:37,000 --> 00:03:40,480
number of things that happen the first

00:03:38,770 --> 00:03:41,680
one is we're doing a normal boot and we

00:03:40,480 --> 00:03:43,260
get all the way up into the operating

00:03:41,680 --> 00:03:45,640
system from the end users perspective

00:03:43,260 --> 00:03:47,950
and from there they'll be running some

00:03:45,640 --> 00:03:50,830
service that may ping something like the

00:03:47,950 --> 00:03:53,890
LV FS server for do you have updates for

00:03:50,830 --> 00:03:55,960
my platform and if it finds any up there

00:03:53,890 --> 00:03:58,180
the LV FS server will send those down to

00:03:55,960 --> 00:04:00,010
the target platform and what happens at

00:03:58,180 --> 00:04:02,440
while the OS is running is those set of

00:04:00,010 --> 00:04:04,540
capsules are saved temporarily off to

00:04:02,440 --> 00:04:06,580
the side and what's the number of

00:04:04,540 --> 00:04:08,740
capsules have been downloaded maybe one

00:04:06,580 --> 00:04:10,930
maybe more eventually there'll be a

00:04:08,740 --> 00:04:13,060
reset system that occurs and then I'll

00:04:10,930 --> 00:04:15,070
do a normal boot again in that normal

00:04:13,060 --> 00:04:17,290
boot it'll only come up to the part

00:04:15,070 --> 00:04:20,230
where the bootloader runs the bootloader

00:04:17,290 --> 00:04:22,120
will run and it will look at the set of

00:04:20,230 --> 00:04:24,310
capsules that may have potentially been

00:04:22,120 --> 00:04:26,410
saved to the disk at OS run time on the

00:04:24,310 --> 00:04:28,030
previous boot if there are capsules

00:04:26,410 --> 00:04:29,950
there it'll go through each one of those

00:04:28,030 --> 00:04:32,050
and we'll call the UEFI service called

00:04:29,950 --> 00:04:34,000
update capsule that'll say in the

00:04:32,050 --> 00:04:37,300
capsule input stage the capsule in

00:04:34,000 --> 00:04:39,010
memory in most cases and then after all

00:04:37,300 --> 00:04:40,810
those capsules have been processed in

00:04:39,010 --> 00:04:42,670
stage and memory through the update

00:04:40,810 --> 00:04:45,640
capsule service it'll do a reset system

00:04:42,670 --> 00:04:47,800
the platform knows capsules have now

00:04:45,640 --> 00:04:49,720
been staged memory and it will boot in a

00:04:47,800 --> 00:04:51,520
special mode called boot on flash update

00:04:49,720 --> 00:04:52,770
so the platform knows that there's

00:04:51,520 --> 00:04:54,900
capsules queued there

00:04:52,770 --> 00:04:56,280
it'll come up through the Pei Peis and

00:04:54,900 --> 00:04:58,259
one of the interesting aspects of

00:04:56,280 --> 00:05:01,319
capsules in the update capsule service

00:04:58,259 --> 00:05:03,960
is that if you're running at OS runtime

00:05:01,319 --> 00:05:05,400
with capsule update the pages physical

00:05:03,960 --> 00:05:07,889
pages associated accounts that can be

00:05:05,400 --> 00:05:10,409
scattered all over memory and as a

00:05:07,889 --> 00:05:12,780
result when we get to the Pei Peis we

00:05:10,409 --> 00:05:14,699
need to bring the platform firmware up

00:05:12,780 --> 00:05:16,680
we tend to need some linear chunks of

00:05:14,699 --> 00:05:18,120
memory in order to complete the platform

00:05:16,680 --> 00:05:20,639
initialization so we have to walk

00:05:18,120 --> 00:05:22,800
through a scatter gather list provided

00:05:20,639 --> 00:05:24,240
with the capsules to coalesce the memory

00:05:22,800 --> 00:05:25,860
associate the capsule so though the

00:05:24,240 --> 00:05:27,930
capsules are in a linear chunk of memory

00:05:25,860 --> 00:05:29,220
and then that frees up memory so it's

00:05:27,930 --> 00:05:30,389
not checkerboarded so we have enough

00:05:29,220 --> 00:05:33,270
memory to complete the view to the

00:05:30,389 --> 00:05:35,460
platform so we have those Cole left

00:05:33,270 --> 00:05:38,000
capsules come up on that boot and flash

00:05:35,460 --> 00:05:42,599
update path and we get up to the

00:05:38,000 --> 00:05:46,139
processing of capsules in the Dixie

00:05:42,599 --> 00:05:47,400
phase there right before what's called

00:05:46,139 --> 00:05:50,190
in to Dixie it's all actually

00:05:47,400 --> 00:05:52,800
implemented in the in the BBS module

00:05:50,190 --> 00:05:55,020
just before you get to the end of Dixie

00:05:52,800 --> 00:05:57,000
and we process capsules we know where

00:05:55,020 --> 00:05:58,919
moon on flash update there may be a list

00:05:57,000 --> 00:06:01,800
of capsules we process each one of those

00:05:58,919 --> 00:06:03,659
and that's where a capsule has a grid

00:06:01,800 --> 00:06:06,120
associated with it that uniquely

00:06:03,659 --> 00:06:08,159
identifies the device to be updated and

00:06:06,120 --> 00:06:10,889
it can do a match between that capsule

00:06:08,159 --> 00:06:12,990
and a former management protocol that's

00:06:10,889 --> 00:06:14,520
present in the system if it finds that

00:06:12,990 --> 00:06:15,960
match it forwards the cap to that

00:06:14,520 --> 00:06:18,900
capsule to the former management

00:06:15,960 --> 00:06:21,990
protocol and that's where the capsule is

00:06:18,900 --> 00:06:23,789
processed and potentially a flash device

00:06:21,990 --> 00:06:26,610
or firmware storage devices updated

00:06:23,789 --> 00:06:28,169
based upon the capsule contents if many

00:06:26,610 --> 00:06:30,000
capsules are sent through at a single

00:06:28,169 --> 00:06:31,830
boot then all of those capsules are

00:06:30,000 --> 00:06:33,539
processed many different subsystems are

00:06:31,830 --> 00:06:36,150
updated and in the end they're all

00:06:33,539 --> 00:06:38,039
completed and it resets the system again

00:06:36,150 --> 00:06:39,300
and then it comes up through a normal

00:06:38,039 --> 00:06:42,060
boot now now

00:06:39,300 --> 00:06:43,979
those new firmware images gets all the

00:06:42,060 --> 00:06:45,780
way up into the OS runtime and once

00:06:43,979 --> 00:06:48,539
again now we're running at a point where

00:06:45,780 --> 00:06:50,759
something like lb FS related services

00:06:48,539 --> 00:06:53,699
can then verify where the capsules it

00:06:50,759 --> 00:06:56,009
staged on the top line actually you know

00:06:53,699 --> 00:06:57,750
there when we got done with that whole

00:06:56,009 --> 00:06:59,580
capsule update process there's a special

00:06:57,750 --> 00:07:02,789
table called the efi system resource

00:06:59,580 --> 00:07:04,620
table which advertises the set of

00:07:02,789 --> 00:07:06,539
updatable components and their versions

00:07:04,620 --> 00:07:08,370
in and if an update was performed it

00:07:06,539 --> 00:07:10,740
provides status on that update wasn't

00:07:08,370 --> 00:07:12,780
successful did it fail did it update to

00:07:10,740 --> 00:07:15,000
the road version that was expected so

00:07:12,780 --> 00:07:16,770
the OS agent can then verify that it

00:07:15,000 --> 00:07:18,569
actually occurred correctly and if there

00:07:16,770 --> 00:07:21,330
were issues they can have remediation

00:07:18,569 --> 00:07:23,190
paths that are handled from the OS agent

00:07:21,330 --> 00:07:24,810
side to see if it needs to retry a

00:07:23,190 --> 00:07:26,849
capsule if there was a failure or if

00:07:24,810 --> 00:07:29,069
everything's good it can then go on and

00:07:26,849 --> 00:07:31,020
do normal you know OS activities and

00:07:29,069 --> 00:07:32,759
wait for some future time when more

00:07:31,020 --> 00:07:35,490
updates are may be available from the

00:07:32,759 --> 00:07:37,469
LTFS service so that's the the basic

00:07:35,490 --> 00:07:39,419
flow that the next so the talk is really

00:07:37,469 --> 00:07:41,159
about that process ufi capsules and what

00:07:39,419 --> 00:07:43,080
happens what do you have to actually do

00:07:41,159 --> 00:07:46,229
in your code that you implement in the

00:07:43,080 --> 00:07:48,000
UEFI firmware in ATK 2 to actually write

00:07:46,229 --> 00:07:51,889
to your flash device and update it in a

00:07:48,000 --> 00:07:51,889
secure safe robust manner

00:07:53,800 --> 00:07:58,990
so here's where that set image call

00:07:56,680 --> 00:08:01,389
there in number one is what happens when

00:07:58,990 --> 00:08:03,190
we process a single UEFI capsule we have

00:08:01,389 --> 00:08:04,870
the youth by capsule image in memory

00:08:03,190 --> 00:08:07,979
it's been coalesced back in the PGI

00:08:04,870 --> 00:08:11,620
phase so it's all in a linear buffer

00:08:07,979 --> 00:08:13,270
call into the FMP driver which is

00:08:11,620 --> 00:08:14,860
producing the firmware management

00:08:13,270 --> 00:08:18,039
protocol and we call the set image

00:08:14,860 --> 00:08:21,280
service with that with that you ate my

00:08:18,039 --> 00:08:23,050
capsule being passed in the FMP driver

00:08:21,280 --> 00:08:25,270
in the firmware management protocol it's

00:08:23,050 --> 00:08:29,289
responsibility is to authenticate that

00:08:25,270 --> 00:08:30,849
capsule if the capsule is corrupted in

00:08:29,289 --> 00:08:32,349
any way it doesn't look like a UEFI

00:08:30,849 --> 00:08:34,630
capsule header it doesn't have the

00:08:32,349 --> 00:08:36,550
proper FMP header or if it actually does

00:08:34,630 --> 00:08:39,490
the signature verification based upon a

00:08:36,550 --> 00:08:41,229
set of public keys that it has if that

00:08:39,490 --> 00:08:43,209
auth fails all those things are going to

00:08:41,229 --> 00:08:44,829
cause the capsule to be rejected it's

00:08:43,209 --> 00:08:46,690
really important that you only apply

00:08:44,829 --> 00:08:49,120
capsules to a platform or a device that

00:08:46,690 --> 00:08:50,800
it actually applies to so we do a number

00:08:49,120 --> 00:08:53,290
of extra checks all through here to make

00:08:50,800 --> 00:08:55,600
sure it's really correct if it passes

00:08:53,290 --> 00:08:57,490
all of those checks we then know that we

00:08:55,600 --> 00:08:59,440
have a valid payload in memory that's

00:08:57,490 --> 00:09:01,300
been authenticated and we can send that

00:08:59,440 --> 00:09:02,980
on to the the one function that's

00:09:01,300 --> 00:09:05,230
actually going to write that payload

00:09:02,980 --> 00:09:07,329
into the firmware storage device so

00:09:05,230 --> 00:09:09,880
that's step three to do the update and

00:09:07,329 --> 00:09:12,820
whether or not you're in a boon on flash

00:09:09,880 --> 00:09:15,540
update path or a normal boot path every

00:09:12,820 --> 00:09:18,700
single boot the FFP driver when it runs

00:09:15,540 --> 00:09:20,770
advertises a grid into the ESR key table

00:09:18,700 --> 00:09:23,770
so we always have an inventory of the

00:09:20,770 --> 00:09:26,260
updatable components advertised on up

00:09:23,770 --> 00:09:29,020
into the operating system environment on

00:09:26,260 --> 00:09:31,690
the platform and that same ESR Kiewit is

00:09:29,020 --> 00:09:33,459
the one that was also used to match the

00:09:31,690 --> 00:09:35,380
capsule with the specific driver

00:09:33,459 --> 00:09:37,839
instance we're calling the right FMP

00:09:35,380 --> 00:09:39,700
protocol so that one which you'll see

00:09:37,839 --> 00:09:41,880
through the presentation travels through

00:09:39,700 --> 00:09:41,880
the

00:09:44,950 --> 00:09:51,220
so I said of my work this year has been

00:09:47,510 --> 00:09:53,690
mostly about making big improvements to

00:09:51,220 --> 00:09:55,940
simplify what it takes to actually

00:09:53,690 --> 00:09:57,860
implement support for that that last

00:09:55,940 --> 00:09:59,570
action of processing a capsule and

00:09:57,860 --> 00:10:02,420
updating your firmware storage device

00:09:59,570 --> 00:10:04,550
with the new capsule contents capsules

00:10:02,420 --> 00:10:07,190
are not new support for capsules in the

00:10:04,550 --> 00:10:09,710
UDK - is not new it's been there since

00:10:07,190 --> 00:10:12,020
UDK 2017 with a fairly good

00:10:09,710 --> 00:10:13,760
implementation but what's happened in

00:10:12,020 --> 00:10:16,190
August of this year we had a needy k2

00:10:13,760 --> 00:10:19,130
stable tag that was dropped on the piano

00:10:16,190 --> 00:10:21,470
for edk - repository and it contains a

00:10:19,130 --> 00:10:24,560
number of feature improvements to the

00:10:21,470 --> 00:10:26,779
way that capsule update occurs first of

00:10:24,560 --> 00:10:29,300
all the there's now a standalone tool

00:10:26,779 --> 00:10:30,980
for generating capsules it used to be

00:10:29,300 --> 00:10:33,050
completely integrated inside of the UDK

00:10:30,980 --> 00:10:34,310
to build environment which meant if you

00:10:33,050 --> 00:10:35,600
were trying to do a capsule for

00:10:34,310 --> 00:10:38,110
something that had nothing to do with

00:10:35,600 --> 00:10:40,430
edk - you still had to use the edk to

00:10:38,110 --> 00:10:42,470
build environment and all of its syntax

00:10:40,430 --> 00:10:44,420
for setting that up in order to build a

00:10:42,470 --> 00:10:46,700
capsule for it non ebk - former

00:10:44,420 --> 00:10:48,170
components that was a bit clumsy now we

00:10:46,700 --> 00:10:50,870
have standalone tools whether or not

00:10:48,170 --> 00:10:52,760
you're doing edk - based a firm reload

00:10:50,870 --> 00:10:54,260
or an on indicate to you from load you

00:10:52,760 --> 00:10:56,380
now have a standalone Python script that

00:10:54,260 --> 00:10:58,490
can help build those capsules for you

00:10:56,380 --> 00:11:00,080
the other thing is that the previous

00:10:58,490 --> 00:11:02,120
implementations were really focused on

00:11:00,080 --> 00:11:04,280
monolithic updates send me one capsule

00:11:02,120 --> 00:11:06,290
per platform and it'll update all the

00:11:04,280 --> 00:11:08,570
front work devices in the entire

00:11:06,290 --> 00:11:10,130
platform this new one is about really

00:11:08,570 --> 00:11:12,740
you know supporting and trying to

00:11:10,130 --> 00:11:14,540
encourage the use of component update if

00:11:12,740 --> 00:11:15,830
you have independent subsystems in a

00:11:14,540 --> 00:11:16,550
platform you want to update them

00:11:15,830 --> 00:11:18,740
independently

00:11:16,550 --> 00:11:21,310
now we have full support for that and it

00:11:18,740 --> 00:11:23,600
was really designed with that you spent

00:11:21,310 --> 00:11:25,250
the other thing that we found is that we

00:11:23,600 --> 00:11:28,430
had some requests from customers to

00:11:25,250 --> 00:11:30,830
support multiple keys per capsule so

00:11:28,430 --> 00:11:32,630
they have uses where use cases where

00:11:30,830 --> 00:11:34,250
maybe during validation formal

00:11:32,630 --> 00:11:36,320
validation they want to use one key for

00:11:34,250 --> 00:11:38,420
former validation and a different key

00:11:36,320 --> 00:11:39,980
for actual formal release so the

00:11:38,420 --> 00:11:41,570
contents of the same but they just have

00:11:39,980 --> 00:11:43,640
one extra different signing action they

00:11:41,570 --> 00:11:45,500
do between those two so the single key

00:11:43,640 --> 00:11:47,600
limitation was actually problematic and

00:11:45,500 --> 00:11:49,340
so we've extended it to support as many

00:11:47,600 --> 00:11:52,130
keys as you as you need for your

00:11:49,340 --> 00:11:53,750
environment on your platform the other

00:11:52,130 --> 00:11:55,310
thing that wasn't there by default was

00:11:53,750 --> 00:11:57,680
some of the pre checks you want to do

00:11:55,310 --> 00:11:59,540
before you apply a capsule is your

00:11:57,680 --> 00:12:01,340
platform in healthy enough to actually

00:11:59,540 --> 00:12:02,840
support doing a capsule update right now

00:12:01,340 --> 00:12:05,240
such that the capsule update came

00:12:02,840 --> 00:12:08,770
complete without issues is your battery

00:12:05,240 --> 00:12:08,770
in a good state are you going to power

00:12:09,100 --> 00:12:13,700
any of those pre checks fail maybe you

00:12:12,200 --> 00:12:15,620
don't want to do the capsule now you

00:12:13,700 --> 00:12:17,330
know reject it and come back later once

00:12:15,620 --> 00:12:20,600
your system has the right attributes to

00:12:17,330 --> 00:12:23,320
support a capsule and some of the other

00:12:20,600 --> 00:12:26,620
things we we've added is there's a

00:12:23,320 --> 00:12:30,050
consistent user experience now when

00:12:26,620 --> 00:12:31,610
capsule is being updated and the flash

00:12:30,050 --> 00:12:33,290
device is actually our firmware storage

00:12:31,610 --> 00:12:35,120
device is actually being updated it

00:12:33,290 --> 00:12:37,460
presents a nice screen that is

00:12:35,120 --> 00:12:39,110
consistent and but there's also options

00:12:37,460 --> 00:12:41,000
if you have a different platform that

00:12:39,110 --> 00:12:43,190
can't support like a graphical console

00:12:41,000 --> 00:12:45,620
or text console you can customize that

00:12:43,190 --> 00:12:48,260
with your own kind of progress indicator

00:12:45,620 --> 00:12:51,080
to the the end user before that required

00:12:48,260 --> 00:12:52,700
a platform specific implementation now

00:12:51,080 --> 00:12:55,040
we have a standard way to snap in those

00:12:52,700 --> 00:12:55,649
the standard ways of showing the user

00:12:55,040 --> 00:12:57,499
that there's a

00:12:55,649 --> 00:13:00,180
former update going on in the platform

00:12:57,499 --> 00:13:01,529
and the probably the biggest one is

00:13:00,180 --> 00:13:03,119
really about on the firmer management

00:13:01,529 --> 00:13:05,040
protocol itself you had to do a complete

00:13:03,119 --> 00:13:07,050
implementation of that whole protocol

00:13:05,040 --> 00:13:09,059
we've now simplified that whole process

00:13:07,050 --> 00:13:10,769
down to give us some data values

00:13:09,059 --> 00:13:13,350
associated with your firmware update and

00:13:10,769 --> 00:13:14,579
implement a small library and we've

00:13:13,350 --> 00:13:16,589
taken care of all the rest of the code

00:13:14,579 --> 00:13:18,540
for you so your amount of work you have

00:13:16,589 --> 00:13:20,670
to do to implement firmware update for

00:13:18,540 --> 00:13:23,610
an individual device or component is now

00:13:20,670 --> 00:13:25,740
much much less some of the things we've

00:13:23,610 --> 00:13:27,740
we've moved into some built-in features

00:13:25,740 --> 00:13:31,350
or things around a test key detection

00:13:27,740 --> 00:13:33,449
watchdog timer is built-in in addition

00:13:31,350 --> 00:13:36,540
we've simplified the publication of that

00:13:33,449 --> 00:13:38,670
ESR tea table with the inventory of

00:13:36,540 --> 00:13:40,740
updatable components there was some

00:13:38,670 --> 00:13:42,509
history here of ESR tea was actually

00:13:40,740 --> 00:13:44,939
defined before the firmware management

00:13:42,509 --> 00:13:46,740
protocol was added to the UEFI specs so

00:13:44,939 --> 00:13:49,829
it had some legacy ways to put entries

00:13:46,740 --> 00:13:51,660
into the SRP table now that solid ating

00:13:49,829 --> 00:13:53,790
all firmware updates over the former

00:13:51,660 --> 00:13:55,230
management protocol those legacy methods

00:13:53,790 --> 00:13:56,670
don't make sense anymore so we've been

00:13:55,230 --> 00:13:58,860
able to reduce a little code a little

00:13:56,670 --> 00:14:04,699
boot time by stripping out some of those

00:13:58,860 --> 00:14:06,959
those old features so I mentioned the

00:14:04,699 --> 00:14:09,149
you know firmware update indicators

00:14:06,959 --> 00:14:11,670
there's two built-in libraries that we

00:14:09,149 --> 00:14:13,649
have if you have a GOP graphics output

00:14:11,670 --> 00:14:15,569
protocol in your platform and you want

00:14:13,649 --> 00:14:17,639
to do a graphical console then you'll

00:14:15,569 --> 00:14:19,319
get a picture like the left where you

00:14:17,639 --> 00:14:21,809
can have your system logo that shows up

00:14:19,319 --> 00:14:23,399
somewhere on the display underneath it

00:14:21,809 --> 00:14:24,629
as a firmware update is occurring

00:14:23,399 --> 00:14:26,550
there'll be a progress bar that's

00:14:24,629 --> 00:14:29,009
rendered and as the progress indicator

00:14:26,550 --> 00:14:31,319
is updated from 0 to 100% it'll actually

00:14:29,009 --> 00:14:33,059
show a colored bar and you can customize

00:14:31,319 --> 00:14:35,879
the color of that bar for each one of

00:14:33,059 --> 00:14:38,790
your devices in addition there is a

00:14:35,879 --> 00:14:41,600
specification from Microsoft and public

00:14:38,790 --> 00:14:43,340
one about a user experience map

00:14:41,600 --> 00:14:45,860
and what they mean by that is it's an

00:14:43,340 --> 00:14:47,810
opportunity for the operating system

00:14:45,860 --> 00:14:50,450
agent that sending capsules down to send

00:14:47,810 --> 00:14:52,970
one additional capsule that contains a

00:14:50,450 --> 00:14:54,860
bitmap and that can get drawn at the

00:14:52,970 --> 00:14:56,600
bottom of the display and it can say

00:14:54,860 --> 00:14:58,820
something like you know please wait your

00:14:56,600 --> 00:15:01,280
system is updating some firmware right

00:14:58,820 --> 00:15:03,110
now don't turn the power off but they

00:15:01,280 --> 00:15:04,760
can also do that in a localized language

00:15:03,110 --> 00:15:07,430
because the operating system knows what

00:15:04,760 --> 00:15:09,140
look how s is installed for and they can

00:15:07,430 --> 00:15:11,420
now send down a generic bitmap that gets

00:15:09,140 --> 00:15:14,210
displayed at the bottom of the screen

00:15:11,420 --> 00:15:15,770
and then the picture on the right is if

00:15:14,210 --> 00:15:17,510
you only have a text console there's a

00:15:15,770 --> 00:15:20,690
basic implementation of the same

00:15:17,510 --> 00:15:22,730
progress bar concept and it uses some

00:15:20,690 --> 00:15:25,040
colors if possible based upon the 16

00:15:22,730 --> 00:15:27,680
foreground colors that are available in

00:15:25,040 --> 00:15:29,300
a PC Enzi like text console you can show

00:15:27,680 --> 00:15:31,550
progress of different components being

00:15:29,300 --> 00:15:32,720
updated and as I mentioned before if you

00:15:31,550 --> 00:15:34,730
have a device that doesn't have either

00:15:32,720 --> 00:15:36,800
one of these consoles maybe something

00:15:34,730 --> 00:15:39,170
like an LED beacon can be flashed

00:15:36,800 --> 00:15:41,990
appropriately or some audio Qatada tones

00:15:39,170 --> 00:15:44,480
you can do a custom version of the

00:15:41,990 --> 00:15:45,830
display update progress live to indicate

00:15:44,480 --> 00:15:48,230
to the user that and updates occurring

00:15:45,830 --> 00:15:50,060
even for something like a small LCD you

00:15:48,230 --> 00:15:51,830
know panel or something like that could

00:15:50,060 --> 00:15:55,300
maybe have some indicators on that that

00:15:51,830 --> 00:15:55,300
you do as a custom implementation

00:15:56,370 --> 00:16:00,550
so I mentioned that we we simplified

00:15:58,750 --> 00:16:02,560
what it takes to implement the firmware

00:16:00,550 --> 00:16:06,040
management protocol all the boxes in

00:16:02,560 --> 00:16:08,649
blue are code that's in the edk to that

00:16:06,040 --> 00:16:10,810
you should just use as is no changes so

00:16:08,649 --> 00:16:12,430
we have a wrapper driver for the

00:16:10,810 --> 00:16:14,560
producing the firmer management protocol

00:16:12,430 --> 00:16:16,060
it takes care of the authentication of

00:16:14,560 --> 00:16:18,490
the ufi capsule for you you don't have

00:16:16,060 --> 00:16:19,810
to write any code to do that and the

00:16:18,490 --> 00:16:22,509
only two things that you do have to

00:16:19,810 --> 00:16:25,540
provide are potentially the platform

00:16:22,509 --> 00:16:27,579
vendor specific library that does the

00:16:25,540 --> 00:16:30,130
system environment pre checks is the

00:16:27,579 --> 00:16:32,500
battery thermal system good for a

00:16:30,130 --> 00:16:35,019
firmware update and the other one is the

00:16:32,500 --> 00:16:37,630
FMP device lib and that's the one that

00:16:35,019 --> 00:16:39,610
each device vendor that has a separate

00:16:37,630 --> 00:16:41,079
firmware storage device that's the set

00:16:39,610 --> 00:16:42,639
of api is they'll go implement to

00:16:41,079 --> 00:16:44,980
actually do the update to the storage

00:16:42,639 --> 00:16:50,410
device with the value of the already

00:16:44,980 --> 00:16:53,290
validated payload and i won't spend a

00:16:50,410 --> 00:16:54,910
lot of time on these the slides will be

00:16:53,290 --> 00:16:57,970
available but this is the idea I said

00:16:54,910 --> 00:16:59,350
there's two ways that you provide some

00:16:57,970 --> 00:17:01,180
information about your firmware update

00:16:59,350 --> 00:17:02,470
one is through a set of data values and

00:17:01,180 --> 00:17:05,289
we call this the platform configuration

00:17:02,470 --> 00:17:07,480
database is the e dk2 nomenclature for

00:17:05,289 --> 00:17:09,640
providing some data values for

00:17:07,480 --> 00:17:12,640
configuration so you can provide some

00:17:09,640 --> 00:17:15,010
information about your grid that you're

00:17:12,640 --> 00:17:16,270
using for your device that's the unique

00:17:15,010 --> 00:17:19,059
identifier for your device that's

00:17:16,270 --> 00:17:21,939
updatable along with the name of your

00:17:19,059 --> 00:17:23,289
device a Unicode string so it can be

00:17:21,939 --> 00:17:26,929
named correctly

00:17:23,289 --> 00:17:30,049
protocol as well as when do you want to

00:17:26,929 --> 00:17:31,520
lock your flash device down typically

00:17:30,049 --> 00:17:33,559
that's at the end of Dixie but a

00:17:31,520 --> 00:17:35,030
platform may choose to a different lock

00:17:33,559 --> 00:17:37,520
point for all their former storage

00:17:35,030 --> 00:17:39,559
devices if you're army to watchdog how

00:17:37,520 --> 00:17:41,510
many seconds does the watchdog get rearm

00:17:39,559 --> 00:17:43,909
each time a progress update occurs on

00:17:41,510 --> 00:17:46,010
the progress bar and then finally the

00:17:43,909 --> 00:17:48,020
most important one is really this one

00:17:46,010 --> 00:17:49,669
right here which is what are your set of

00:17:48,020 --> 00:17:51,830
public keys that you're using to

00:17:49,669 --> 00:17:54,140
validate your capsule so you provide

00:17:51,830 --> 00:17:55,610
those and a PCD as well so once again no

00:17:54,140 --> 00:17:57,950
code to write you just provide a data

00:17:55,610 --> 00:17:59,570
value with your certificate in there and

00:17:57,950 --> 00:18:01,130
we actually have a tool that if you're

00:17:59,570 --> 00:18:02,659
using something like the open SSL

00:18:01,130 --> 00:18:04,820
command-line tools to create your

00:18:02,659 --> 00:18:06,890
certificates we have a simple tool you

00:18:04,820 --> 00:18:08,539
can use to convert that binary file or

00:18:06,890 --> 00:18:11,179
set of binary files if you're doing

00:18:08,539 --> 00:18:13,070
multiple keys into a PCD statement that

00:18:11,179 --> 00:18:16,850
you just baked include into your DSC

00:18:13,070 --> 00:18:19,250
file and so no no cut or paste or errors

00:18:16,850 --> 00:18:22,730
that can occur in that developer process

00:18:19,250 --> 00:18:24,230
and then the last one is if you want to

00:18:22,730 --> 00:18:26,539
disable test key detection there's a

00:18:24,230 --> 00:18:28,190
simple way to do that as well test key

00:18:26,539 --> 00:18:29,720
detections on by default then you can

00:18:28,190 --> 00:18:33,919
disable it if you want to save some boot

00:18:29,720 --> 00:18:36,380
time if you're doing the platform

00:18:33,919 --> 00:18:38,659
specific work around power thermal and

00:18:36,380 --> 00:18:40,340
environment the this is the one library

00:18:38,659 --> 00:18:42,320
class you'd implement there's three API

00:18:40,340 --> 00:18:44,179
surround system checks there's two

00:18:42,320 --> 00:18:46,070
additional API is there that's really

00:18:44,179 --> 00:18:48,730
around a service mode or manufacturing

00:18:46,070 --> 00:18:51,289
mode so if you want to have a way to

00:18:48,730 --> 00:18:53,990
prevent your flash devices from being

00:18:51,289 --> 00:18:57,110
blocked or allow an older version of

00:18:53,990 --> 00:18:59,270
firmware to run you can basically put

00:18:57,110 --> 00:19:01,340
some hardware specific platform specific

00:18:59,270 --> 00:19:02,750
checks in to say I'm at I know I'm in a

00:19:01,340 --> 00:19:04,730
service center or I know I'm on the

00:19:02,750 --> 00:19:06,890
manufacturing line and I can allow some

00:19:04,730 --> 00:19:10,159
different policies to occur by default

00:19:06,890 --> 00:19:11,419
these are implemented as false and false

00:19:10,159 --> 00:19:13,370
it's like no I'm not in those

00:19:11,419 --> 00:19:15,770
environments you know I'm actually out

00:19:13,370 --> 00:19:19,360
in the end user of state and do not

00:19:15,770 --> 00:19:19,360
leave the the flash devices

00:19:22,110 --> 00:19:26,320
and this is the most important this is

00:19:25,179 --> 00:19:29,260
the set of api's you have to implement

00:19:26,320 --> 00:19:30,580
per device the ones with the bold

00:19:29,260 --> 00:19:32,350
italics they're about the currently

00:19:30,580 --> 00:19:34,540
stored firmware image

00:19:32,350 --> 00:19:36,309
most of these ApS are really small and

00:19:34,540 --> 00:19:39,160
simple diplomat just a couple lines of

00:19:36,309 --> 00:19:41,050
code our preference and to make it

00:19:39,160 --> 00:19:42,580
easier it's better if you layout your

00:19:41,050 --> 00:19:44,380
payload that gets stored in the flash

00:19:42,580 --> 00:19:46,420
device such that you could always

00:19:44,380 --> 00:19:48,850
extract out of the storage firmware

00:19:46,420 --> 00:19:52,210
image things like it's version it's

00:19:48,850 --> 00:19:53,559
version string and and that kind of

00:19:52,210 --> 00:19:55,120
information also be able to extract the

00:19:53,559 --> 00:19:58,179
image out pull the image out of the

00:19:55,120 --> 00:19:59,530
firmer device itself the one API that is

00:19:58,179 --> 00:20:01,690
the most is the biggest the most

00:19:59,530 --> 00:20:04,960
complicated is this one final one that

00:20:01,690 --> 00:20:07,270
is the FMP device set image that's the

00:20:04,960 --> 00:20:09,820
one where you'll actually write to the

00:20:07,270 --> 00:20:11,860
firmware storage device and you're

00:20:09,820 --> 00:20:14,200
passed in a progress API that you're

00:20:11,860 --> 00:20:15,610
asked to periodically call between a

00:20:14,200 --> 00:20:17,530
value of zero and a hundred percent as

00:20:15,610 --> 00:20:20,080
you work through your update of your

00:20:17,530 --> 00:20:21,970
firmware storage device and so that you

00:20:20,080 --> 00:20:24,880
can get that progress indicator updated

00:20:21,970 --> 00:20:26,740
on the display so it's typically a race

00:20:24,880 --> 00:20:28,420
a block of flash right the next block of

00:20:26,740 --> 00:20:30,040
flash and then update the progress to

00:20:28,420 --> 00:20:31,660
the approximate percentage that you've

00:20:30,040 --> 00:20:33,280
gone through your flash device for that

00:20:31,660 --> 00:20:35,620
firmware component that you're updating

00:20:33,280 --> 00:20:39,000
and that's where the majority of works

00:20:35,620 --> 00:20:39,000
done in this this library

00:20:40,220 --> 00:20:44,809
there's a couple of use cases now around

00:20:43,279 --> 00:20:46,460
when you have multiple updatable

00:20:44,809 --> 00:20:48,950
components in a platform here is your

00:20:46,460 --> 00:20:50,570
system firmware you've got multiple FMP

00:20:48,950 --> 00:20:53,059
drivers so this is showing four

00:20:50,570 --> 00:20:54,950
updatable components in the platform you

00:20:53,059 --> 00:20:56,629
have an ESR tea table with four entries

00:20:54,950 --> 00:20:58,460
so that advertises up to the operating

00:20:56,629 --> 00:21:01,039
system there's four available components

00:20:58,460 --> 00:21:03,620
and importantly here is really around

00:21:01,039 --> 00:21:05,269
the key management you get a choice to

00:21:03,620 --> 00:21:07,129
where you store your keys you can store

00:21:05,269 --> 00:21:10,100
them within the driver itself because

00:21:07,129 --> 00:21:11,929
it's a PCD element you can choose the

00:21:10,100 --> 00:21:13,970
patchwork module type it's inside of the

00:21:11,929 --> 00:21:15,889
driver or if you want to put it inside

00:21:13,970 --> 00:21:17,929
of some vital product data area that's a

00:21:15,889 --> 00:21:19,549
protected area of your flash you can

00:21:17,929 --> 00:21:21,049
choose to store there as well if you

00:21:19,549 --> 00:21:24,470
want to have shared keys amongst

00:21:21,049 --> 00:21:26,809
multiple updatable components so a full

00:21:24,470 --> 00:21:29,419
platform that has full control over all

00:21:26,809 --> 00:21:31,610
of their updatable components and signs

00:21:29,419 --> 00:21:33,500
them all the same key may choose the

00:21:31,610 --> 00:21:34,610
vital product data area if you're

00:21:33,500 --> 00:21:36,500
integrating components from other

00:21:34,610 --> 00:21:38,330
parties you may be choosing the the

00:21:36,500 --> 00:21:39,559
picture of the items on the right where

00:21:38,330 --> 00:21:41,750
the keys are actually inside of the

00:21:39,559 --> 00:21:45,259
driver themselves it all depends on who

00:21:41,750 --> 00:21:48,409
signs the key who you validates now we

00:21:45,259 --> 00:21:49,700
get to third parties here's an example

00:21:48,409 --> 00:21:52,009
where if you have a third party vendor

00:21:49,700 --> 00:21:54,190
that's producing a device that has

00:21:52,009 --> 00:21:56,840
firmer up pramana that can be updated

00:21:54,190 --> 00:21:58,580
they reproduce the firmware driver an

00:21:56,840 --> 00:22:02,990
FMP driver that you can integrate into

00:21:58,580 --> 00:22:04,100
your system firmware as is and one of

00:22:02,990 --> 00:22:06,529
the things you might want to do is

00:22:04,100 --> 00:22:08,240
actually replace the keys that are there

00:22:06,529 --> 00:22:11,419
from the third party with your system

00:22:08,240 --> 00:22:13,309
keys because you don't want to allow the

00:22:11,419 --> 00:22:15,080
third party to provide produce a new

00:22:13,309 --> 00:22:16,549
capsule that automatically gets

00:22:15,080 --> 00:22:19,100
installed on your platform without you

00:22:16,549 --> 00:22:20,990
doing some verification first so by

00:22:19,100 --> 00:22:22,789
replacing the keys with your system keys

00:22:20,990 --> 00:22:24,950
what you're saying is I'm not letting

00:22:22,789 --> 00:22:27,379
that third party into my platform by

00:22:24,950 --> 00:22:29,720
default I'm gonna validate first and if

00:22:27,379 --> 00:22:31,399
I validate their new capsule I will be

00:22:29,720 --> 00:22:33,200
signed their capsule and then I will

00:22:31,399 --> 00:22:35,690
publish a new capsule available from my

00:22:33,200 --> 00:22:38,060
platform signed with my keys such that

00:22:35,690 --> 00:22:40,220
then my end-users will get that that

00:22:38,060 --> 00:22:42,890
more update so that's one model where

00:22:40,220 --> 00:22:45,320
the system vendor has full control over

00:22:42,890 --> 00:22:48,200
every firmware update to every component

00:22:45,320 --> 00:22:51,320
in their platform there's a another

00:22:48,200 --> 00:22:53,420
model here where if we keep the

00:22:51,320 --> 00:22:56,690
third-party keys there that's the mode

00:22:53,420 --> 00:22:59,090
where if a third-party that produces the

00:22:56,690 --> 00:23:01,370
new capsule and publishes it on LV FS as

00:22:59,090 --> 00:23:03,650
an example then all the platforms that

00:23:01,370 --> 00:23:05,750
have that device in their system that's

00:23:03,650 --> 00:23:08,300
signed with that third-party key that's

00:23:05,750 --> 00:23:10,070
advertised with that same grid they'll

00:23:08,300 --> 00:23:12,170
start receiving that update that that

00:23:10,070 --> 00:23:13,940
third party produced so that's a second

00:23:12,170 --> 00:23:19,250
model that a platform vendor can choose

00:23:13,940 --> 00:23:20,690
to take advantage of and another mode

00:23:19,250 --> 00:23:22,160
that's available is if you have an

00:23:20,690 --> 00:23:24,260
existing device driver you've already

00:23:22,160 --> 00:23:26,570
implemented or another vendors

00:23:24,260 --> 00:23:29,120
implemented and it does have firmware

00:23:26,570 --> 00:23:31,130
update as a possibility but they haven't

00:23:29,120 --> 00:23:32,960
implemented it yet there's a way to use

00:23:31,130 --> 00:23:35,210
the exact same code that I showed as a

00:23:32,960 --> 00:23:37,430
separate module and just link it in as a

00:23:35,210 --> 00:23:39,650
library into your existing device driver

00:23:37,430 --> 00:23:41,720
it's actually the exact same code for

00:23:39,650 --> 00:23:43,520
for us in ATK too it's two different

00:23:41,720 --> 00:23:45,620
IMF's one that's advertised it's a

00:23:43,520 --> 00:23:47,420
library one that's as a module but they

00:23:45,620 --> 00:23:49,370
function identically and you do the same

00:23:47,420 --> 00:23:51,470
work you set the PC DS in the scope of

00:23:49,370 --> 00:23:54,380
that module you write your one library

00:23:51,470 --> 00:23:58,090
that FMP device live and that will just

00:23:54,380 --> 00:23:58,090
fold in and and work for you

00:23:58,830 --> 00:24:04,380
so in summary the UDK - it supports this

00:24:02,010 --> 00:24:07,020
new set of capsule features that really

00:24:04,380 --> 00:24:09,210
simplifies the the what it takes to

00:24:07,020 --> 00:24:11,370
implement from a management protocol for

00:24:09,210 --> 00:24:13,110
devices and really trying to encourage

00:24:11,370 --> 00:24:15,150
this idea of supporting not just

00:24:13,110 --> 00:24:17,670
monolithic update for platforms as most

00:24:15,150 --> 00:24:20,370
are today but let's work on you know

00:24:17,670 --> 00:24:23,460
sweating it out multiple updates

00:24:20,370 --> 00:24:25,230
different a big for each component added

00:24:23,460 --> 00:24:27,450
support for multiple authentication keys

00:24:25,230 --> 00:24:29,160
added the support for pre checks to make

00:24:27,450 --> 00:24:31,680
sure the system is compatible with doing

00:24:29,160 --> 00:24:33,600
a firmware update right now that more

00:24:31,680 --> 00:24:34,950
consistent user experience wallet

00:24:33,600 --> 00:24:39,930
firmware update is occurring with the

00:24:34,950 --> 00:24:42,780
progress bars and the support for the

00:24:39,930 --> 00:24:44,520
test key detection and simplified es RT

00:24:42,780 --> 00:24:47,010
table based only on the former

00:24:44,520 --> 00:24:49,200
management protocol we have the new tool

00:24:47,010 --> 00:24:50,790
called generate capsule dot py which is

00:24:49,200 --> 00:24:52,860
a way that independent of the edk to

00:24:50,790 --> 00:24:54,570
build system you can build capsules for

00:24:52,860 --> 00:24:58,410
any kind of component whether they're

00:24:54,570 --> 00:24:59,880
edk - based or not and you know the one

00:24:58,410 --> 00:25:02,400
of the methods we have for publishing

00:24:59,880 --> 00:25:03,810
and distributing UEFI capsules is to go

00:25:02,400 --> 00:25:05,910
through things like the winning spend or

00:25:03,810 --> 00:25:08,070
firmware services for those platforms

00:25:05,910 --> 00:25:10,500
that have that firmware update manager

00:25:08,070 --> 00:25:12,540
service able to run or the gnome

00:25:10,500 --> 00:25:14,730
software able to run on that target they

00:25:12,540 --> 00:25:16,950
could then see those updates on the LB

00:25:14,730 --> 00:25:20,700
FS server and automatically download and

00:25:16,950 --> 00:25:24,630
install so the call to action here is

00:25:20,700 --> 00:25:28,050
you know go implement using the new FMP

00:25:24,630 --> 00:25:30,120
device package as described here do it

00:25:28,050 --> 00:25:32,190
for your system firmware and if you have

00:25:30,120 --> 00:25:33,960
other places in your platform go started

00:25:32,190 --> 00:25:36,240
lamenting those SMP drivers or work with

00:25:33,960 --> 00:25:38,700
those third-party vendors to have them

00:25:36,240 --> 00:25:41,520
help work on the FMP drivers for their

00:25:38,700 --> 00:25:44,220
devices take advantage of the features I

00:25:41,520 --> 00:25:46,590
listed here and take advantage of the

00:25:44,220 --> 00:25:50,430
the LD FS as a way to distribute your

00:25:46,590 --> 00:25:51,960
your capsules and write feedback and

00:25:50,430 --> 00:25:53,520
contribute to both the Elvia best

00:25:51,960 --> 00:25:56,670
project and to the

00:25:53,520 --> 00:25:58,620
that tiyanak or a TK to the kind of our

00:25:56,670 --> 00:26:01,560
future work that we're looking at past

00:25:58,620 --> 00:26:03,720
this is this scope of effort is really

00:26:01,560 --> 00:26:06,240
focused on your platform your system

00:26:03,720 --> 00:26:07,800
firmware and integrated devices when you

00:26:06,240 --> 00:26:09,540
get to things like adding car it's like

00:26:07,800 --> 00:26:11,820
PCI adding card so do we confirm or

00:26:09,540 --> 00:26:13,680
update to those or to other kinds of

00:26:11,820 --> 00:26:16,590
devices outside that that's some of the

00:26:13,680 --> 00:26:17,790
work items that were still looking at to

00:26:16,590 --> 00:26:19,200
make though that that as simple as

00:26:17,790 --> 00:26:20,880
possible as well so that's some of the

00:26:19,200 --> 00:26:22,860
areas that we like to collaborate with

00:26:20,880 --> 00:26:25,920
the community on on getting those those

00:26:22,860 --> 00:26:38,760
problems solved as well so that's the in

00:26:25,920 --> 00:26:39,930
the presentation on for questions I was

00:26:38,760 --> 00:26:41,640
just saying I think you're out of time

00:26:39,930 --> 00:26:43,020
so we should have time for a quick

00:26:41,640 --> 00:26:46,490
question but then we should give the

00:26:43,020 --> 00:26:46,490
floor to humble too

00:26:52,100 --> 00:26:59,660
and we update compared with Windows and

00:26:56,090 --> 00:27:02,060
Linux system and the Linux will

00:26:59,660 --> 00:27:07,250
automatically do the update own it

00:27:02,060 --> 00:27:09,770
manually initiate so with the the Elvia

00:27:07,250 --> 00:27:11,660
best project it will automatically send

00:27:09,770 --> 00:27:13,940
it down and automatically do the updates

00:27:11,660 --> 00:27:17,300
it has that capability so really the

00:27:13,940 --> 00:27:20,300
team windows update on for Microsoft

00:27:17,300 --> 00:27:22,160
operating systems and lvf s for window

00:27:20,300 --> 00:27:24,800
for Linux systems they're kind of peers

00:27:22,160 --> 00:27:26,570
they work the same way and there's

00:27:24,800 --> 00:27:28,970
actually been some great work by the lvf

00:27:26,570 --> 00:27:32,180
s team to make it so that it's possible

00:27:28,970 --> 00:27:35,210
to build a capsule content that you can

00:27:32,180 --> 00:27:37,250
send to the Linux portal for signing and

00:27:35,210 --> 00:27:39,350
distribution through LD FS and sit in

00:27:37,250 --> 00:27:41,750
that exact same capsule no changes to

00:27:39,350 --> 00:27:42,920
the to the windows one so that's so

00:27:41,750 --> 00:27:44,650
they've got some great work to make sure

00:27:42,920 --> 00:27:46,790
that they're compatible so from the

00:27:44,650 --> 00:27:49,100
vendor's perspective that's creating the

00:27:46,790 --> 00:27:52,330
council's they do the work once and then

00:27:49,100 --> 00:27:52,330
just publish do two portals

00:27:57,690 --> 00:28:01,889
I think I looked at the capsule stuff

00:28:00,509 --> 00:28:04,080
and one thing I thought I saw missing

00:28:01,889 --> 00:28:06,269
was so the capsules have versioning

00:28:04,080 --> 00:28:08,490
information major minor versioning so

00:28:06,269 --> 00:28:11,309
that if I'm doing a system firmware

00:28:08,490 --> 00:28:12,629
update I can tag that and say you know I

00:28:11,309 --> 00:28:16,409
want to know what it is and then

00:28:12,629 --> 00:28:19,259
secondly when a copy such as a capsule

00:28:16,409 --> 00:28:21,570
to the boot partition that you guys

00:28:19,259 --> 00:28:24,899
talked about in your spec can I make

00:28:21,570 --> 00:28:28,220
sure that the the file name includes the

00:28:24,899 --> 00:28:28,220
version number or something

00:28:29,299 --> 00:28:35,340
so yes the es RT table and capsules all

00:28:32,879 --> 00:28:36,659
have 32-bit version values in them they

00:28:35,340 --> 00:28:38,639
also have lowest supported version

00:28:36,659 --> 00:28:40,769
values to have like security boundaries

00:28:38,639 --> 00:28:43,879
you can't go below so that that's all in

00:28:40,769 --> 00:28:47,129
there and as far as the format on disk

00:28:43,879 --> 00:28:49,529
for UEFI capsule update using up a

00:28:47,129 --> 00:28:51,809
capsule service there's no disk file

00:28:49,529 --> 00:28:54,029
associated with it there is a feature in

00:28:51,809 --> 00:28:56,539
the ua by spec called you ate my capsule

00:28:54,029 --> 00:28:56,539
on disk

00:29:05,210 --> 00:29:13,199
[Applause]

00:29:08,190 --> 00:29:13,199

YouTube URL: https://www.youtube.com/watch?v=TJPoE7Uo0zo


