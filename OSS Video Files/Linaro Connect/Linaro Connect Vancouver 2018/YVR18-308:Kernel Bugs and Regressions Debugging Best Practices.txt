Title: YVR18-308:Kernel Bugs and Regressions Debugging Best Practices
Publication date: 2018-10-16
Playlist: Linaro Connect Vancouver 2018
Description: 
	This demo will be based on real work done for real bug cases. It will show some of my best practices in putting together an environment ready for bug resolution: Quick virtual machine cloning, containers, dev boxes, Debian packaging, debug symbols, kernel cross compilation and automation, crash dump generation on different boards,  kdump analysis for both arm32 & arm64, and how to interpret a stack trace and quickly identify possible root cause of the issue.
Captions: 
	00:00:02,160 --> 00:00:07,170
[Music]

00:00:08,000 --> 00:00:15,150
this presentation has borne has been

00:00:11,910 --> 00:00:17,880
born as need for me to explain some of

00:00:15,150 --> 00:00:21,090
the tools I was using to do Berg's

00:00:17,880 --> 00:00:23,820
investigation to my team and they

00:00:21,090 --> 00:00:27,450
thought it could be useful to have a

00:00:23,820 --> 00:00:29,250
broader audience and then well I'm I'm

00:00:27,450 --> 00:00:31,380
gonna be targeting them but I think it's

00:00:29,250 --> 00:00:33,809
gonna be useful for all of them for all

00:00:31,380 --> 00:00:36,210
of you I think the beginning might be

00:00:33,809 --> 00:00:37,800
useful for moves like senior kernel

00:00:36,210 --> 00:00:39,780
developers just because it's tooling

00:00:37,800 --> 00:00:43,460
only it's not talking about code itself

00:00:39,780 --> 00:00:47,129
and the second part will be a real case

00:00:43,460 --> 00:00:49,530
then it's something useful you know for

00:00:47,129 --> 00:00:51,269
people that want to dig into crash dump

00:00:49,530 --> 00:00:55,710
analysis or something like it that might

00:00:51,269 --> 00:00:57,149
like you know things that I've done so

00:00:55,710 --> 00:00:59,609
first I'll be talking about the

00:00:57,149 --> 00:01:02,280
environment I'm using at home and I just

00:00:59,609 --> 00:01:03,960
told my wife not to you know go to my

00:01:02,280 --> 00:01:07,170
office right now because I'm connected

00:01:03,960 --> 00:01:10,320
there and then I'm gonna be talking

00:01:07,170 --> 00:01:12,270
about a clip see how I use Eclipse you

00:01:10,320 --> 00:01:12,660
to do kernel development yeah I know I

00:01:12,270 --> 00:01:15,990
know

00:01:12,660 --> 00:01:19,610
and then the debugging a real case and

00:01:15,990 --> 00:01:22,380
what was done and how I achieved results

00:01:19,610 --> 00:01:24,360
so you know if you were interested in

00:01:22,380 --> 00:01:29,040
doing something similar you have at

00:01:24,360 --> 00:01:31,530
least a north so I'm new at Lynn arrow

00:01:29,040 --> 00:01:35,040
so I thought presenting myself I came

00:01:31,530 --> 00:01:37,680
from canonical and before IBM where I

00:01:35,040 --> 00:01:40,170
was working with mainframes for so for

00:01:37,680 --> 00:01:42,240
me it's a big change because I was

00:01:40,170 --> 00:01:45,330
dealing with the new technologies coming

00:01:42,240 --> 00:01:48,750
out of test 390 especially integrating

00:01:45,330 --> 00:01:50,880
as 390 with KVM on x86 boxes and now and

00:01:48,750 --> 00:01:54,660
then coming into a banded world has been

00:01:50,880 --> 00:02:00,030
a good challenge so it's been really

00:01:54,660 --> 00:02:03,210
nice working with this okay so go into

00:02:00,030 --> 00:02:05,580
the environment this idea was born at

00:02:03,210 --> 00:02:07,290
when I was working in sustaining

00:02:05,580 --> 00:02:10,229
engineering just because when dealing

00:02:07,290 --> 00:02:12,689
with bugs in user land or Colonel I was

00:02:10,229 --> 00:02:14,069
responsible for back porting them to all

00:02:12,689 --> 00:02:17,910
supported versions

00:02:14,069 --> 00:02:19,709
and this included a real deep need on

00:02:17,910 --> 00:02:22,230
having all the environments ready right

00:02:19,709 --> 00:02:24,690
away you know so let's say I had for

00:02:22,230 --> 00:02:27,060
example a multipath bug you know I had

00:02:24,690 --> 00:02:28,680
to beg port the fix or let's say the up

00:02:27,060 --> 00:02:30,750
string didn't have the fix so I had to

00:02:28,680 --> 00:02:34,380
work upstream provide the fix up string

00:02:30,750 --> 00:02:37,350
then take that patch get I was working

00:02:34,380 --> 00:02:40,019
for Ubuntu of course so I had to provide

00:02:37,350 --> 00:02:41,580
fix a store for xeno and then Kjersti

00:02:40,019 --> 00:02:43,080
let's say and then I have to have all

00:02:41,580 --> 00:02:45,599
the environments ready so you know

00:02:43,080 --> 00:02:47,400
upstream was accepting it I would have

00:02:45,599 --> 00:02:49,769
to make sure that bin seat had the fix

00:02:47,400 --> 00:02:51,480
after Debian had the fix and then it was

00:02:49,769 --> 00:02:53,310
accepted there I would have to make sure

00:02:51,480 --> 00:02:55,560
that it was merged into the Punto

00:02:53,310 --> 00:02:58,140
packages first for a senior way to

00:02:55,560 --> 00:03:00,780
accept before xeno all the packages were

00:02:58,140 --> 00:03:04,049
generated and then back ported to trusty

00:03:00,780 --> 00:03:06,150
and so on so it required having a

00:03:04,049 --> 00:03:08,190
functional environment because I was

00:03:06,150 --> 00:03:11,220
dealing with like let's say in parallel

00:03:08,190 --> 00:03:13,049
15 bugs so for each of those bugs I

00:03:11,220 --> 00:03:14,880
would have to back port several fixes

00:03:13,049 --> 00:03:17,069
for several architectures for several

00:03:14,880 --> 00:03:19,560
distributions and that required some

00:03:17,069 --> 00:03:22,350
kind of organization and that's how I

00:03:19,560 --> 00:03:24,959
came up with this work directory that

00:03:22,350 --> 00:03:27,720
I'm using right now which is part of the

00:03:24,959 --> 00:03:30,900
first first half of them present at the

00:03:27,720 --> 00:03:33,090
presentation so if you go to dizzy well

00:03:30,900 --> 00:03:35,329
you don't have to go it now but use as a

00:03:33,090 --> 00:03:40,640
reference I'll be I'll be talking you

00:03:35,329 --> 00:03:43,620
will find you oops

00:03:40,640 --> 00:03:46,530
so you'll find basically disorganization

00:03:43,620 --> 00:03:48,450
I just described you go source trees for

00:03:46,530 --> 00:03:50,250
user land to source trees like G leap

00:03:48,450 --> 00:03:53,880
see multipath all the things that you

00:03:50,250 --> 00:03:56,819
know my require a fix Lib huge TLB now

00:03:53,880 --> 00:04:00,450
that I'm working LTP all the tests all

00:03:56,819 --> 00:04:02,100
the source codes are they're being

00:04:00,450 --> 00:04:05,609
organized in a way that you can move to

00:04:02,100 --> 00:04:10,650
generate the packages for arm h-f arm 64

00:04:05,609 --> 00:04:14,310
I know which I'm gonna be sure so first

00:04:10,650 --> 00:04:16,109
things that I learned when I so I wasn't

00:04:14,310 --> 00:04:19,340
working with cross compiling itself

00:04:16,109 --> 00:04:21,570
because I mostly use doing x86 work and

00:04:19,340 --> 00:04:24,630
one of the things that I learned so far

00:04:21,570 --> 00:04:26,580
is that using containers for with ki mu

00:04:24,630 --> 00:04:29,819
user static was a pretty good

00:04:26,580 --> 00:04:31,289
thing to be done because I when I

00:04:29,819 --> 00:04:33,419
started and in other I didn't have any

00:04:31,289 --> 00:04:36,780
board at home and I had I was working on

00:04:33,419 --> 00:04:41,340
x86 environment so I started doing all

00:04:36,780 --> 00:04:47,879
the Lexi containers doing with arm hf

00:04:41,340 --> 00:04:50,250
and arm 64 so you can see here so this

00:04:47,879 --> 00:04:52,139
work directory I'm basically sharing my

00:04:50,250 --> 00:04:53,879
shared mounting it with all the

00:04:52,139 --> 00:04:56,490
containers that I have of course and

00:04:53,879 --> 00:04:58,500
then let's say I have a source code that

00:04:56,490 --> 00:05:01,349
I want to fix and I want to test for arm

00:04:58,500 --> 00:05:03,960
HF and arm 64 this chair directory is

00:05:01,349 --> 00:05:10,099
basically shared among all my containers

00:05:03,960 --> 00:05:15,449
inside the same machine right what else

00:05:10,099 --> 00:05:17,550
so why not to use chroot right and the

00:05:15,449 --> 00:05:19,440
problem with chroot was the package into

00:05:17,550 --> 00:05:21,900
dependency so sometimes I wanted to

00:05:19,440 --> 00:05:23,819
generate a debian package for RHS for

00:05:21,900 --> 00:05:26,580
example for wafer cross compiling things

00:05:23,819 --> 00:05:28,139
get more difficult because you have all

00:05:26,580 --> 00:05:29,909
the packages in Debian for example you

00:05:28,139 --> 00:05:32,069
have all the package interdependencies

00:05:29,909 --> 00:05:35,669
right so having a name a different name

00:05:32,069 --> 00:05:37,650
space is needed right for you to deal

00:05:35,669 --> 00:05:41,219
with all the packages and also for

00:05:37,650 --> 00:05:43,919
example dealing with containers with

00:05:41,219 --> 00:05:46,860
system D system D requires a different

00:05:43,919 --> 00:05:49,409
name space for you to upgrade a userland

00:05:46,860 --> 00:05:51,509
capable of you know generating a new

00:05:49,409 --> 00:05:53,969
package and new dependencies in between

00:05:51,509 --> 00:05:59,430
those packages I'm gonna be showing this

00:05:53,969 --> 00:06:01,979
soon this is like two reads for anyone

00:05:59,430 --> 00:06:03,839
that would like to start working with

00:06:01,979 --> 00:06:08,129
Debian packages this is like mandatory

00:06:03,839 --> 00:06:11,069
and then that's why I put their URLs

00:06:08,129 --> 00:06:13,069
there and it explains all they needed

00:06:11,069 --> 00:06:16,680
you know

00:06:13,069 --> 00:06:18,629
packaging files for you to generate the

00:06:16,680 --> 00:06:21,620
packages and this work the rhetoric that

00:06:18,629 --> 00:06:26,099
I have I have like a vanilla sauce of

00:06:21,620 --> 00:06:29,250
packages so for example if you want to

00:06:26,099 --> 00:06:31,469
generate the latest ki mu packages right

00:06:29,250 --> 00:06:33,779
out of upstream then you would download

00:06:31,469 --> 00:06:35,909
the latest ki mu from debian get the

00:06:33,779 --> 00:06:38,490
Debian directory there and then generate

00:06:35,909 --> 00:06:40,720
use it the Debian director in this new

00:06:38,490 --> 00:06:43,210
source this new tree from web stream

00:06:40,720 --> 00:06:45,310
and generates like upstream packages and

00:06:43,210 --> 00:06:47,620
it would fail because you know the rules

00:06:45,310 --> 00:06:49,420
for the Debian package has been changed

00:06:47,620 --> 00:06:51,850
the source code changed a bit and also

00:06:49,420 --> 00:06:53,680
what I did was I created some vanilla

00:06:51,850 --> 00:07:00,790
Debian directories to generate those

00:06:53,680 --> 00:07:04,450
packages for me and yeah so let me show

00:07:00,790 --> 00:07:06,700
what's at that table let me show it

00:07:04,450 --> 00:07:09,750
because it's cooler when we do it

00:07:06,700 --> 00:07:09,750
instead of talking right

00:07:20,770 --> 00:07:25,910
so here's basically the dev box and

00:07:24,110 --> 00:07:28,160
workstation that I'm using at home right

00:07:25,910 --> 00:07:29,900
and I'm gonna show the directory and I'm

00:07:28,160 --> 00:07:32,810
gonna show a simple thing as you know

00:07:29,900 --> 00:07:34,820
just generate a package that is already

00:07:32,810 --> 00:07:36,800
there being updated with background

00:07:34,820 --> 00:07:46,460
scripts and bringing me the source tree

00:07:36,800 --> 00:07:48,169
changes every every day and so on so for

00:07:46,460 --> 00:07:49,820
example here I have the tree directory

00:07:48,169 --> 00:07:52,730
user land source tree is being updated

00:07:49,820 --> 00:07:58,370
all the time right and then some of them

00:07:52,730 --> 00:08:00,169
like LTP contains a directory like

00:07:58,370 --> 00:08:02,510
Debian director right this Debian

00:08:00,169 --> 00:08:05,750
directories being maintained as part of

00:08:02,510 --> 00:08:07,400
this all this tree you know and it

00:08:05,750 --> 00:08:09,440
doesn't have anything to do with the

00:08:07,400 --> 00:08:11,690
Debian package for LTP itself it's just

00:08:09,440 --> 00:08:14,030
something mine so every this tree is

00:08:11,690 --> 00:08:16,370
being updated updated and then this

00:08:14,030 --> 00:08:18,860
Debian the structure is generating the

00:08:16,370 --> 00:08:22,040
packages automatically for me which I'll

00:08:18,860 --> 00:08:25,580
show soon and then for me is as simple

00:08:22,040 --> 00:08:27,410
as just like this is FTP from now you

00:08:25,580 --> 00:08:29,300
know this tree is updated and if I want

00:08:27,410 --> 00:08:32,390
to generate a package for a any

00:08:29,300 --> 00:08:34,510
architecture I would just generate it

00:08:32,390 --> 00:08:34,510
back

00:08:55,290 --> 00:09:00,520
so basically all my boards and all my

00:08:58,180 --> 00:09:02,230
all my machines all my servers my build

00:09:00,520 --> 00:09:04,750
machine home that has the same structure

00:09:02,230 --> 00:09:06,910
all the source codes are being shared

00:09:04,750 --> 00:09:09,870
among them and I can generate a package

00:09:06,910 --> 00:09:09,870
for any structure

00:09:19,990 --> 00:09:25,100
let's say it's gonna generate the LGP

00:09:22,430 --> 00:09:27,590
binary package and provide me in a

00:09:25,100 --> 00:09:30,350
certain directory and what I mean with

00:09:27,590 --> 00:09:32,120
that and why it is important to me like

00:09:30,350 --> 00:09:35,000
I said you know I'm dealing with 15

00:09:32,120 --> 00:09:39,170
different books different of different

00:09:35,000 --> 00:09:42,490
packages and all so this is important to

00:09:39,170 --> 00:09:45,380
me because on his show I'm generating

00:09:42,490 --> 00:09:48,950
packages from case of tests and LTP and

00:09:45,380 --> 00:09:51,920
Lib huge TLB every day every time the

00:09:48,950 --> 00:09:53,930
tree changes and this is something that

00:09:51,920 --> 00:09:56,120
I'm preparing it's already in a

00:09:53,930 --> 00:09:59,320
repository right so let's say for

00:09:56,120 --> 00:10:02,450
example LTP just changed has had pushed

00:09:59,320 --> 00:10:06,440
few commits the packages are being

00:10:02,450 --> 00:10:08,270
generated for x86 amd64 arm hf arm 64

00:10:06,440 --> 00:10:11,840
right and then I have this red pose so

00:10:08,270 --> 00:10:14,660
let's say the l k FG provided me oh we

00:10:11,840 --> 00:10:17,240
have a broken we have a regression right

00:10:14,660 --> 00:10:19,760
and the aggression rep happened in I

00:10:17,240 --> 00:10:22,280
don't know mmm barrier then I would say

00:10:19,760 --> 00:10:24,020
let's go for the memory test and see

00:10:22,280 --> 00:10:26,510
what's going what's what happened right

00:10:24,020 --> 00:10:29,210
so I can test the LTP from today from

00:10:26,510 --> 00:10:31,700
yesterday and see was out it be broken

00:10:29,210 --> 00:10:33,740
or was the test broken or was something

00:10:31,700 --> 00:10:35,840
in the tree itself right so then I can

00:10:33,740 --> 00:10:41,920
do to follow investigations and that's

00:10:35,840 --> 00:10:41,920
how it's being done if you go to this

00:10:43,750 --> 00:10:54,350
here so you have all the architectures

00:10:49,760 --> 00:10:56,120
for example armed amd64 and k self tests

00:10:54,350 --> 00:10:58,940
and then all the case of tests being

00:10:56,120 --> 00:11:01,510
built since some days ago and the

00:10:58,940 --> 00:11:05,720
packages are being generated in AB or

00:11:01,510 --> 00:11:08,390
dot T X Z and then I have like a mini

00:11:05,720 --> 00:11:10,340
gateway converting the packages so for

00:11:08,390 --> 00:11:12,680
example LTP I'm generating a debian

00:11:10,340 --> 00:11:14,990
package and it converts into RPM and it

00:11:12,680 --> 00:11:17,510
converts to a tar.gz if you want to just

00:11:14,990 --> 00:11:19,880
uncompress it and it's doing this

00:11:17,510 --> 00:11:20,690
because we also test all the builds in

00:11:19,880 --> 00:11:22,700
openembedded

00:11:20,690 --> 00:11:24,140
right so opening whether it can use RPM

00:11:22,700 --> 00:11:26,480
to install the packet for example and

00:11:24,140 --> 00:11:29,120
I'm using Debian and one of the things

00:11:26,480 --> 00:11:30,920
that I realize is that's pretty good

00:11:29,120 --> 00:11:33,740
having different environments for the

00:11:30,920 --> 00:11:35,630
this problems because whenever we see

00:11:33,740 --> 00:11:39,620
problems happening for example in our

00:11:35,630 --> 00:11:41,300
boards with opening batted sometimes I

00:11:39,620 --> 00:11:41,960
test in Debian and it doesn't happen

00:11:41,300 --> 00:11:43,610
right away

00:11:41,960 --> 00:11:45,140
just because sometimes I'm using a

00:11:43,610 --> 00:11:46,850
different kernel configuration or

00:11:45,140 --> 00:11:49,130
sometimes I'm using different leaps each

00:11:46,850 --> 00:11:51,290
this is pretty common so for example lib

00:11:49,130 --> 00:11:53,890
huge TOB one of the bugs that I just had

00:11:51,290 --> 00:11:57,440
was exactly about that you know Lipsy

00:11:53,890 --> 00:12:00,280
implemented a cache for shrinking heap

00:11:57,440 --> 00:12:02,780
you know and the new tea leaf C

00:12:00,280 --> 00:12:05,570
basically made the Lib hitch their beef

00:12:02,780 --> 00:12:07,460
to fail and I realized that this was

00:12:05,570 --> 00:12:09,380
failing in my environment but in another

00:12:07,460 --> 00:12:12,740
environment it wasn't because the Lib C

00:12:09,380 --> 00:12:24,520
was older so generating two new Lipsey

00:12:12,740 --> 00:12:28,150
here read me so having tell eg Lipsy

00:12:24,520 --> 00:12:30,920
generated here of course gypsy had has

00:12:28,150 --> 00:12:33,110
hard-coded preloader thing but you can

00:12:30,920 --> 00:12:35,900
always force the preloader to use

00:12:33,110 --> 00:12:38,210
another JDBC and test it so having

00:12:35,900 --> 00:12:40,880
different versions of Lipsy you know

00:12:38,210 --> 00:12:42,760
every day every month for me is

00:12:40,880 --> 00:12:45,530
important because of the test so I can

00:12:42,760 --> 00:12:47,270
bisect it without having to generate the

00:12:45,530 --> 00:12:49,400
binary every time I know I can't just

00:12:47,270 --> 00:12:51,920
like do a last month was last month

00:12:49,400 --> 00:12:54,080
working no oh it was was last week

00:12:51,920 --> 00:12:56,420
working oh it was last week working so

00:12:54,080 --> 00:12:58,880
it's faster for me all right and since

00:12:56,420 --> 00:13:00,890
I'm we are testing in now kfj different

00:12:58,880 --> 00:13:04,960
architectures it's important to have for

00:13:00,890 --> 00:13:04,960
all of them so let's move on

00:13:10,010 --> 00:13:15,810
okay so I also created some scripts so

00:13:13,350 --> 00:13:17,600
like I said you know having virtual

00:13:15,810 --> 00:13:20,340
machines is pretty important and having

00:13:17,600 --> 00:13:22,110
containers it's pretty important so some

00:13:20,340 --> 00:13:25,530
of these scripts are basically cloning

00:13:22,110 --> 00:13:29,040
KVM guests for all architectures that

00:13:25,530 --> 00:13:31,440
I'm playing with arm and x86 and then I

00:13:29,040 --> 00:13:33,690
can basically clone fastly a virtual

00:13:31,440 --> 00:13:35,220
machine it changes the hostname and it

00:13:33,690 --> 00:13:36,810
sets all the environment inside the

00:13:35,220 --> 00:13:38,940
virtual machine already and how does it

00:13:36,810 --> 00:13:40,590
work directory inside the virtual

00:13:38,940 --> 00:13:42,290
machine so I can play with the same

00:13:40,590 --> 00:13:45,450
source codes I was playing without

00:13:42,290 --> 00:13:47,430
outside it and one of the first things

00:13:45,450 --> 00:13:50,070
so all those packages are being

00:13:47,430 --> 00:13:52,170
generated in containers sharing the same

00:13:50,070 --> 00:13:54,960
structure so we have basically Chrome

00:13:52,170 --> 00:13:58,070
cron jobs running and compiling that you

00:13:54,960 --> 00:14:00,300
know the same source the same tree and

00:13:58,070 --> 00:14:02,370
it's two machines that I have at home

00:14:00,300 --> 00:14:07,350
and are compiling all the time so if

00:14:02,370 --> 00:14:09,420
they realize the get describe changed it

00:14:07,350 --> 00:14:11,520
will compile and generate a new package

00:14:09,420 --> 00:14:12,870
it's the same thing here but the thing

00:14:11,520 --> 00:14:15,390
here is that

00:14:12,870 --> 00:14:17,010
KVM is used for reproducing books not

00:14:15,390 --> 00:14:20,340
only for compiling the package so

00:14:17,010 --> 00:14:23,010
whenever I get a bug a problem in lkf T

00:14:20,340 --> 00:14:25,440
results I have to clone the environment

00:14:23,010 --> 00:14:27,090
to have that ready for me to you know

00:14:25,440 --> 00:14:29,580
reproduce the issue and see what's going

00:14:27,090 --> 00:14:32,700
on and here is where resent where enters

00:14:29,580 --> 00:14:35,220
the KVM which sometimes can work

00:14:32,700 --> 00:14:37,470
sometimes don't because I need a board

00:14:35,220 --> 00:14:41,670
for example if it's a problem with the

00:14:37,470 --> 00:14:43,980
board itself and and also to generate

00:14:41,670 --> 00:14:46,500
new kernels so this instructor has also

00:14:43,980 --> 00:14:48,480
like some scripts sure I was saying

00:14:46,500 --> 00:14:50,040
about compiling a self tests and I

00:14:48,480 --> 00:14:51,900
created like a script that does

00:14:50,040 --> 00:14:54,420
everything she was saying automatically

00:14:51,900 --> 00:14:56,760
and generates Debian packages for a case

00:14:54,420 --> 00:14:59,160
of tests and you don't have to do much I

00:14:56,760 --> 00:15:01,640
have to like make it better and it's not

00:14:59,160 --> 00:15:03,870
rocket science you can go to that work

00:15:01,640 --> 00:15:06,770
directory source code that I told you

00:15:03,870 --> 00:15:06,770
you will see the script

00:15:15,509 --> 00:15:20,499
so basically the Butte script has the

00:15:18,279 --> 00:15:22,329
mainline stable and stable RC those

00:15:20,499 --> 00:15:24,699
threes are being updated so every time

00:15:22,329 --> 00:15:27,160
Gregg pushes something into stable RC

00:15:24,699 --> 00:15:30,040
this tree is updated that I can generate

00:15:27,160 --> 00:15:32,619
a packet or I can for example tell the

00:15:30,040 --> 00:15:34,809
Butte script to generate the Colonel

00:15:32,619 --> 00:15:37,509
Debian package for a specific version

00:15:34,809 --> 00:15:39,550
and it generates for me and then my

00:15:37,509 --> 00:15:41,920
scripts will get this debian package and

00:15:39,550 --> 00:15:44,649
whilst all wind of the container that is

00:15:41,920 --> 00:15:46,709
being cloned right so for example and

00:15:44,649 --> 00:15:49,959
this has already started using wonders

00:15:46,709 --> 00:15:51,579
years ago so Anders has already started

00:15:49,959 --> 00:15:53,529
using those groups and changing and

00:15:51,579 --> 00:15:54,970
copying some of these things he liked it

00:15:53,529 --> 00:16:01,720
and put into it because everybody

00:15:54,970 --> 00:16:03,579
creates their own scripts right so this

00:16:01,720 --> 00:16:05,800
is something that I have to prepare

00:16:03,579 --> 00:16:07,839
better you know but it's basically like

00:16:05,800 --> 00:16:10,749
are you get clean the tree before

00:16:07,839 --> 00:16:13,179
generating are you doing a kernel config

00:16:10,749 --> 00:16:15,490
and the kernel configuration rating the

00:16:13,179 --> 00:16:17,829
all the macro config files for you to

00:16:15,490 --> 00:16:20,139
because since I'm using Eclipse II I

00:16:17,829 --> 00:16:22,480
need the config files to be the macros

00:16:20,139 --> 00:16:24,459
to be offset so Eclipse it does the

00:16:22,480 --> 00:16:26,529
indexing using all the defines and

00:16:24,459 --> 00:16:29,170
everything and then are you using the

00:16:26,529 --> 00:16:30,970
run FS to generate kernel binaries and

00:16:29,170 --> 00:16:33,009
then if you are what's the size of the

00:16:30,970 --> 00:16:36,790
ROM FS and then you just basically do a

00:16:33,009 --> 00:16:38,679
build mainline - master Butte mainline -

00:16:36,790 --> 00:16:40,509
stable and it will build the tree for

00:16:38,679 --> 00:16:43,209
you generate the Debian packages and put

00:16:40,509 --> 00:16:45,009
in a specific directory then you get the

00:16:43,209 --> 00:16:47,470
Debian packages and install in the

00:16:45,009 --> 00:16:49,679
container image right so it's easy as

00:16:47,470 --> 00:16:49,679
this

00:17:07,240 --> 00:17:13,810
so I just cloned a machine it's based on

00:17:10,310 --> 00:17:16,220
Kiko image right I was using ZFS in the

00:17:13,810 --> 00:17:17,390
underlay but the problem with ZFS is

00:17:16,220 --> 00:17:21,050
that whenever you use copy-on-write

00:17:17,390 --> 00:17:23,150
files like the Kiko files on on ZFS

00:17:21,050 --> 00:17:25,550
since it's a queue on top of Kiko it's

00:17:23,150 --> 00:17:28,580
gonna be a performance issue sometimes

00:17:25,550 --> 00:17:30,140
so now I'm only dealing with Kiko images

00:17:28,580 --> 00:17:36,260
and all these snapshots are just you

00:17:30,140 --> 00:17:38,300
know snapshots on-call images so

00:17:36,260 --> 00:17:40,550
basically I just cloned the machine and

00:17:38,300 --> 00:17:44,480
now I can reproduce the problems that

00:17:40,550 --> 00:17:46,880
you know so what I would do I would do

00:17:44,480 --> 00:17:49,280
for example I would download the latest

00:17:46,880 --> 00:17:51,820
OTP right so what I would do it

00:17:49,280 --> 00:17:51,820
something like this

00:18:21,230 --> 00:18:26,269
so I just cloned a structure and I have

00:18:23,960 --> 00:18:28,519
a script this helper script that will go

00:18:26,269 --> 00:18:30,470
to that URL having all the packages and

00:18:28,519 --> 00:18:32,330
I will download the latest out EP I

00:18:30,470 --> 00:18:34,580
don't know which one is you know it

00:18:32,330 --> 00:18:37,580
could be generated like 15 minutes ago

00:18:34,580 --> 00:18:41,080
or yesterday but I'll get the latest LTP

00:18:37,580 --> 00:18:41,080
binary for this environment

00:18:47,830 --> 00:18:52,690
and I can choose the packet formats oops

00:18:54,850 --> 00:19:08,450
forgot that browser so it's downloading

00:19:06,110 --> 00:19:10,220
the latest debian package I just

00:19:08,450 --> 00:19:12,440
installed the debian package and I would

00:19:10,220 --> 00:19:14,300
run the test right so let's say for

00:19:12,440 --> 00:19:16,310
example one of the examples I'm gonna be

00:19:14,300 --> 00:19:19,400
showing the bug that I'll be talking

00:19:16,310 --> 00:19:22,250
about is on phone notify 0-7 test and

00:19:19,400 --> 00:19:24,470
then the lkf t just assume that that

00:19:22,250 --> 00:19:26,420
this test is broken I would get out ap

00:19:24,470 --> 00:19:28,910
install and I have environment to run it

00:19:26,420 --> 00:19:31,130
on a specific kernel right but I have to

00:19:28,910 --> 00:19:33,440
install the specific kernel and imagine

00:19:31,130 --> 00:19:38,260
if I want to bisect I have to script it

00:19:33,440 --> 00:19:40,850
right because my my job at Lee Naru I

00:19:38,260 --> 00:19:42,620
depend on the okay FG but I have to do

00:19:40,850 --> 00:19:45,620
all my own scripts right I would have to

00:19:42,620 --> 00:19:47,750
bisect something to find war was broken

00:19:45,620 --> 00:19:49,730
and sometimes I cannot only use the lava

00:19:47,750 --> 00:19:51,650
for example I would have to do something

00:19:49,730 --> 00:19:54,350
by hand but this has to be something

00:19:51,650 --> 00:19:56,300
scriptable right so what I've done here

00:19:54,350 --> 00:19:58,790
is that let's say I want install a new

00:19:56,300 --> 00:20:01,610
kernel into this virtual machine and I

00:19:58,790 --> 00:20:03,950
made the kyouko image to be accessible

00:20:01,610 --> 00:20:06,050
through containers so my virtual machine

00:20:03,950 --> 00:20:08,060
can be a container or a virtual machine

00:20:06,050 --> 00:20:11,170
it's just like if I shut down I can

00:20:08,060 --> 00:20:11,170
start it as a container

00:20:33,430 --> 00:20:38,680
so now the same machine that I was

00:20:36,160 --> 00:20:40,780
running under KVM I'm on there under

00:20:38,680 --> 00:20:43,780
Alexi it's the same machine right and

00:20:40,780 --> 00:20:45,940
then I can do whatever I want

00:20:43,780 --> 00:20:48,190
inside a container environment well why

00:20:45,940 --> 00:20:50,920
is this important sometimes you generate

00:20:48,190 --> 00:20:53,500
a cairn Odom right and you want to run

00:20:50,920 --> 00:20:55,240
crash on it and running inside KTM won't

00:20:53,500 --> 00:20:56,890
be good because of memory restrictions

00:20:55,240 --> 00:20:58,630
right and then inside the container I

00:20:56,890 --> 00:21:01,210
would have the same memory as the host

00:20:58,630 --> 00:21:04,270
to work with so it's much better and

00:21:01,210 --> 00:21:06,340
then now I'm gonna install it so this is

00:21:04,270 --> 00:21:08,170
just a shell right but I've made some

00:21:06,340 --> 00:21:10,390
wrappers that I could install things

00:21:08,170 --> 00:21:12,160
inside the machine without having to

00:21:10,390 --> 00:21:14,230
boot it inside it's gone

00:21:12,160 --> 00:21:16,210
if you ever see lib gas fish for example

00:21:14,230 --> 00:21:19,090
lib gas fish does something similar I

00:21:16,210 --> 00:21:22,290
use it sometimes and it does so when

00:21:19,090 --> 00:21:22,290
it's going to install the kernel

00:22:04,710 --> 00:22:10,200
so now like for example let's see if it

00:22:07,710 --> 00:22:12,090
works I'm going to install the Debian

00:22:10,200 --> 00:22:14,129
packages that were generated by that

00:22:12,090 --> 00:22:16,169
structure inside this virtual machine

00:22:14,129 --> 00:22:18,899
and just just one command it will mount

00:22:16,169 --> 00:22:21,350
it as a container install the container

00:22:18,899 --> 00:22:24,749
inside the virtual machine and exit from

00:22:21,350 --> 00:22:27,269
inside the container and exit so next

00:22:24,749 --> 00:22:29,070
time I will boot inside KVM the kernel

00:22:27,269 --> 00:22:31,110
is already installed it was just one

00:22:29,070 --> 00:22:32,970
comment and that is important for me for

00:22:31,110 --> 00:22:34,619
bisection for example I can generate I

00:22:32,970 --> 00:22:36,539
can script something to generate the

00:22:34,619 --> 00:22:39,149
package and saw the virtual machine do

00:22:36,539 --> 00:22:41,669
the test see if it were get out to do it

00:22:39,149 --> 00:22:43,769
again and get out and so and so so

00:22:41,669 --> 00:22:45,929
that's why I have all this structure and

00:22:43,769 --> 00:22:47,789
the way it's created like this is just

00:22:45,929 --> 00:22:50,730
when one book so imagine like right now

00:22:47,789 --> 00:22:54,080
my pipeline my queue pipeline of bugs is

00:22:50,730 --> 00:22:56,909
like maybe 25 books I have right now so

00:22:54,080 --> 00:22:59,249
imagine doing this for every single bug

00:22:56,909 --> 00:23:00,809
to you know to discover an issue that is

00:22:59,249 --> 00:23:09,740
going on so that's why this is structure

00:23:00,809 --> 00:23:11,820
was created okay let's move on and then

00:23:09,740 --> 00:23:13,559
this is the environment that I'm

00:23:11,820 --> 00:23:15,509
accessing you know all the boards and

00:23:13,559 --> 00:23:19,440
all my machines and one of the things

00:23:15,509 --> 00:23:22,259
that I wanted to share is just a cork is

00:23:19,440 --> 00:23:25,200
your friend so I wasn't I wasn't very

00:23:22,259 --> 00:23:27,360
you know enthusiastic of having boards

00:23:25,200 --> 00:23:29,309
and where I'm gonna put because the

00:23:27,360 --> 00:23:31,499
cable is heavier than the board if you

00:23:29,309 --> 00:23:33,299
so if you want to organize is really no

00:23:31,499 --> 00:23:35,039
difficult fergan I seen several boards

00:23:33,299 --> 00:23:37,049
and all so what I did was I prepared an

00:23:35,039 --> 00:23:39,330
environment with cork and I put all the

00:23:37,049 --> 00:23:44,279
boards there so this is basically the

00:23:39,330 --> 00:23:46,980
environment I'm accessing and then some

00:23:44,279 --> 00:23:49,320
of the the lessons learned from from

00:23:46,980 --> 00:23:52,350
what I just did it was having that they

00:23:49,320 --> 00:23:55,950
been installed in SD card so I can you

00:23:52,350 --> 00:23:58,950
know recover the SD cards whenever there

00:23:55,950 --> 00:24:03,179
are issues with it and I'm using usually

00:23:58,950 --> 00:24:05,809
the MMC internal MCS just as a swap

00:24:03,179 --> 00:24:10,710
space for for the environment you know

00:24:05,809 --> 00:24:15,509
and here's something then asked me for

00:24:10,710 --> 00:24:17,900
so basically using Eclipse for all this

00:24:15,509 --> 00:24:23,850
you know kernel

00:24:17,900 --> 00:24:26,790
navigation and in the books so here is

00:24:23,850 --> 00:24:29,010
that I've been using ving for my entire

00:24:26,790 --> 00:24:33,030
life but after dealing with so many

00:24:29,010 --> 00:24:35,280
books so simultaneously I had to have

00:24:33,030 --> 00:24:37,800
something that would provide me a faster

00:24:35,280 --> 00:24:39,840
navigation and I've tried everything

00:24:37,800 --> 00:24:42,630
that you can imagine so I know all the

00:24:39,840 --> 00:24:44,700
you know plug-ins for things all the

00:24:42,630 --> 00:24:47,070
managers or plugins all the plugins and

00:24:44,700 --> 00:24:50,610
all and I came up with Eclipse II

00:24:47,070 --> 00:24:53,160
helping me a lot in fast navigation so

00:24:50,610 --> 00:24:55,920
what happens is that whenever so since

00:24:53,160 --> 00:24:58,230
I'm not an engineer for developing new

00:24:55,920 --> 00:25:00,870
code and I'm basically navigating on

00:24:58,230 --> 00:25:02,460
code that I've never saw or if I saw I

00:25:00,870 --> 00:25:05,880
saw because of another book that I have

00:25:02,460 --> 00:25:07,740
played with the things that Eclipse you

00:25:05,880 --> 00:25:10,500
provide me and I can show here is

00:25:07,740 --> 00:25:12,270
something you know fast for me to fast

00:25:10,500 --> 00:25:13,980
learn and see where is the problem and

00:25:12,270 --> 00:25:17,360
provides it engineer responsible for

00:25:13,980 --> 00:25:21,630
fixing or sometimes make a quick fix and

00:25:17,360 --> 00:25:25,200
so I remember what I wanted to show so

00:25:21,630 --> 00:25:28,170
fast navigation through the files just

00:25:25,200 --> 00:25:29,880
you know hard keys and it has all index

00:25:28,170 --> 00:25:32,000
all the fire so in colonel is pretty

00:25:29,880 --> 00:25:34,500
good you know like for example you wanna

00:25:32,000 --> 00:25:36,660
intel underscore i do you know interest

00:25:34,500 --> 00:25:38,670
contour i do it opens a firewall and I

00:25:36,660 --> 00:25:41,070
mean Intel I do for example source code

00:25:38,670 --> 00:25:53,120
or you know it's pretty fast for finding

00:25:41,070 --> 00:25:55,590
so what else so searching for C code

00:25:53,120 --> 00:25:57,570
definitions or declarations or all

00:25:55,590 --> 00:26:00,090
occurrences for functions for example

00:25:57,570 --> 00:26:02,160
it's just like C scope but it's a C

00:26:00,090 --> 00:26:05,880
scope in a graphical way and a faster

00:26:02,160 --> 00:26:09,690
way in you know it's easier for you if

00:26:05,880 --> 00:26:12,990
when you get you know usage a good usage

00:26:09,690 --> 00:26:14,460
of it and then it has a file search and

00:26:12,990 --> 00:26:16,020
the first search is pretty fast because

00:26:14,460 --> 00:26:17,250
it's based on index the only problem is

00:26:16,020 --> 00:26:19,560
that whenever you have an eclipse

00:26:17,250 --> 00:26:21,390
instance you have to create the index

00:26:19,560 --> 00:26:24,420
and index takes like forever for you to

00:26:21,390 --> 00:26:26,670
curate so having the source code for the

00:26:24,420 --> 00:26:31,050
kernel for example inside us as DJ's

00:26:26,670 --> 00:26:33,810
first does my buttes or has six SSDs

00:26:31,050 --> 00:26:35,580
in parallel just so I can cash things

00:26:33,810 --> 00:26:39,090
fast you know because every time the

00:26:35,580 --> 00:26:41,400
trees updated I have to cash out all the

00:26:39,090 --> 00:26:44,190
kernel tree so I can fastly navigate

00:26:41,400 --> 00:26:46,320
through it and then another thing that I

00:26:44,190 --> 00:26:49,200
like is having the outline of functions

00:26:46,320 --> 00:26:50,910
and the coherer are key and this is the

00:26:49,200 --> 00:26:54,630
most important part for it when you have

00:26:50,910 --> 00:26:56,850
books for I basically have to define I

00:26:54,630 --> 00:26:58,740
have to find every every time I have to

00:26:56,850 --> 00:27:00,960
find who is calling this function you

00:26:58,740 --> 00:27:02,790
know and who is calling this who is

00:27:00,960 --> 00:27:03,870
using this variable is this a global

00:27:02,790 --> 00:27:06,830
variable or not

00:27:03,870 --> 00:27:09,750
who is calling this function things that

00:27:06,830 --> 00:27:11,760
seems like oh you know I could use Veen

00:27:09,750 --> 00:27:13,680
yes you could if you were developing the

00:27:11,760 --> 00:27:16,260
code if you are not you know I have

00:27:13,680 --> 00:27:18,810
never ever seen your code in my entire

00:27:16,260 --> 00:27:21,510
life I have to realize if you are using

00:27:18,810 --> 00:27:23,310
that lock you know or not and who is

00:27:21,510 --> 00:27:25,560
using the lock and what is causing the

00:27:23,310 --> 00:27:28,980
deadlock for example so I have to find

00:27:25,560 --> 00:27:31,290
easier ways to navigate through it other

00:27:28,980 --> 00:27:34,710
things that help me a lot on bug solving

00:27:31,290 --> 00:27:36,510
is having the get history you know in

00:27:34,710 --> 00:27:39,330
the source code so for example sometimes

00:27:36,510 --> 00:27:41,400
I found the issue directly into the code

00:27:39,330 --> 00:27:43,290
and I I tell it Clips it to show the

00:27:41,400 --> 00:27:45,480
history and here is the change for

00:27:43,290 --> 00:27:47,450
example and then I can see exact come it

00:27:45,480 --> 00:27:51,180
that caused that change and if it's not

00:27:47,450 --> 00:27:53,730
enough I can basically tell it to show

00:27:51,180 --> 00:27:55,500
me inside the get history only the file

00:27:53,730 --> 00:27:57,810
that I'm playing with and then it shows

00:27:55,500 --> 00:28:00,270
me exact wrenches where this change came

00:27:57,810 --> 00:28:03,960
from and if it's part of a patch set or

00:28:00,270 --> 00:28:05,880
not who created when and then I even

00:28:03,960 --> 00:28:07,530
have like for example here when it opens

00:28:05,880 --> 00:28:10,170
several fires I can click in the file

00:28:07,530 --> 00:28:13,020
and I can tell compare the file for me

00:28:10,170 --> 00:28:16,380
with the latest version or compare the

00:28:13,020 --> 00:28:20,360
file with the subsequent version of this

00:28:16,380 --> 00:28:20,360
change you know so I can see exact

00:28:20,720 --> 00:28:28,260
street view but it's not it's not so

00:28:24,840 --> 00:28:30,180
having like a good IDE for I wouldn't

00:28:28,260 --> 00:28:33,570
say for developing you know if I was

00:28:30,180 --> 00:28:36,360
just developing I would use Emacs Veeam

00:28:33,570 --> 00:28:39,120
whatever but you know doing this several

00:28:36,360 --> 00:28:42,360
times in a day and having to learn the

00:28:39,120 --> 00:28:44,630
source code in one day like this for

00:28:42,360 --> 00:28:44,630
example

00:28:44,649 --> 00:28:53,200
this is something I've done with

00:28:47,179 --> 00:28:53,200
multipath so dizzy

00:29:05,720 --> 00:29:11,900
free in a version that was already

00:29:09,310 --> 00:29:15,050
changed by lots of patches because of

00:29:11,900 --> 00:29:20,120
different distro so for you to see that

00:29:15,050 --> 00:29:22,880
the size of the problem right and this

00:29:20,120 --> 00:29:26,540
is when one day following the code and

00:29:22,880 --> 00:29:28,670
then suddenly the opes there was the one

00:29:26,540 --> 00:29:30,980
use after free so it's not something

00:29:28,670 --> 00:29:33,620
trivial if you would if I would do it

00:29:30,980 --> 00:29:36,530
like a ving type of navigation trying oh

00:29:33,620 --> 00:29:37,310
where was it you know and it's really

00:29:36,530 --> 00:29:39,860
complicated

00:29:37,310 --> 00:29:51,410
so that was the the main idea of showing

00:29:39,860 --> 00:29:54,230
us so debugging this is part where the

00:29:51,410 --> 00:29:57,200
kernel developers like senior might get

00:29:54,230 --> 00:29:58,670
bored but it's sometimes you can you

00:29:57,200 --> 00:30:02,930
know see something that I'm doing maybe

00:29:58,670 --> 00:30:05,510
and and get some idea so different than

00:30:02,930 --> 00:30:07,790
developing sometimes when you are

00:30:05,510 --> 00:30:09,650
debugging you have to have the big

00:30:07,790 --> 00:30:11,390
picture right so one of the things that

00:30:09,650 --> 00:30:13,820
I have in my head all the time is how

00:30:11,390 --> 00:30:16,160
the stacks are being arranged how they

00:30:13,820 --> 00:30:20,350
are being executed what are what is

00:30:16,160 --> 00:30:23,360
happening on each CPU you know and then

00:30:20,350 --> 00:30:26,210
the big picture of every subsystem and

00:30:23,360 --> 00:30:28,040
kernel so for example every time I work

00:30:26,210 --> 00:30:31,160
with a different sustaining engineering

00:30:28,040 --> 00:30:34,520
team and I have to tell them how to get

00:30:31,160 --> 00:30:37,040
into kernel debugging faster I would say

00:30:34,520 --> 00:30:39,950
that instead of going deep into books

00:30:37,040 --> 00:30:42,230
like for example no I don't know

00:30:39,950 --> 00:30:44,330
Linux internals go for the understanding

00:30:42,230 --> 00:30:46,820
Linux kernel like Robert love books

00:30:44,330 --> 00:30:49,550
which is like you know he's a book of

00:30:46,820 --> 00:30:54,290
major topics that make you see the

00:30:49,550 --> 00:30:56,450
entire system faster so what I did here

00:30:54,290 --> 00:31:02,170
in those lights is just the foundations

00:30:56,450 --> 00:31:02,170
for us to have thank you like a singer

00:31:02,560 --> 00:31:10,880
thank you so this is just like the

00:31:08,300 --> 00:31:13,100
foundations of every kernel subsystem

00:31:10,880 --> 00:31:14,870
for us to have a big picture when we are

00:31:13,100 --> 00:31:19,340
doing investigations and I'm gonna be

00:31:14,870 --> 00:31:19,730
talking about problem with sleep aboe

00:31:19,340 --> 00:31:22,490
are

00:31:19,730 --> 00:31:25,820
see you locking mechanism out coming out

00:31:22,490 --> 00:31:28,040
of the file system notify code which is

00:31:25,820 --> 00:31:29,900
just one of the bugs that we do it was

00:31:28,040 --> 00:31:32,450
just one you know and I wanted to show

00:31:29,900 --> 00:31:37,820
an example of how this how this is put

00:31:32,450 --> 00:31:40,040
together so first things first you know

00:31:37,820 --> 00:31:42,410
you have to have in mind that all tasks

00:31:40,040 --> 00:31:44,240
that so running in the kernel have

00:31:42,410 --> 00:31:47,000
multiple states that could be inside the

00:31:44,240 --> 00:31:50,630
CPU were out they could be waiting for

00:31:47,000 --> 00:31:52,790
for example my specific situation coming

00:31:50,630 --> 00:31:54,530
out of let's say you just wrote to a

00:31:52,790 --> 00:31:56,330
block device block the voice went to

00:31:54,530 --> 00:31:58,610
turn transport layer transport layers

00:31:56,330 --> 00:32:00,290
waiting for you know some packets to

00:31:58,610 --> 00:32:02,000
arrive through is Kiersey you know

00:32:00,290 --> 00:32:03,470
something like it and then you are

00:32:02,000 --> 00:32:06,140
waiting for that you have to have this

00:32:03,470 --> 00:32:07,970
picture in mind so what where is my test

00:32:06,140 --> 00:32:10,550
right now my task is waiting for our

00:32:07,970 --> 00:32:12,830
condition and then after the condition

00:32:10,550 --> 00:32:15,470
is attended it's gonna be scheduled into

00:32:12,830 --> 00:32:17,330
a CPU rank you the recipe you run here

00:32:15,470 --> 00:32:19,160
would get this task and put inside the

00:32:17,330 --> 00:32:21,560
CPU and when it does it can be

00:32:19,160 --> 00:32:22,190
preemptable or not by our inner handler

00:32:21,560 --> 00:32:24,680
or not

00:32:22,190 --> 00:32:26,810
you know it's different than just coding

00:32:24,680 --> 00:32:28,880
it's just like you have to keep and

00:32:26,810 --> 00:32:32,030
every time you deal with a new different

00:32:28,880 --> 00:32:34,930
bug this big picture gets bigger and

00:32:32,030 --> 00:32:39,290
bigger and bigger right

00:32:34,930 --> 00:32:41,420
so for example this text see the how

00:32:39,290 --> 00:32:44,750
these stacks are arranged in kernel you

00:32:41,420 --> 00:32:47,150
know like one stack one user userland

00:32:44,750 --> 00:32:50,030
stack per task and then whenever you

00:32:47,150 --> 00:32:52,100
join the kernel kernel stack for that

00:32:50,030 --> 00:32:53,450
particular task and then whenever you

00:32:52,100 --> 00:32:55,640
have an intergroup the handler

00:32:53,450 --> 00:32:58,010
interrupted the execution of the task

00:32:55,640 --> 00:33:00,620
that you were investigation you have the

00:32:58,010 --> 00:33:07,610
interrupt and the hoop task for that

00:33:00,620 --> 00:33:09,440
particular CPU you know and one of the

00:33:07,610 --> 00:33:11,630
things that I judge important is knowing

00:33:09,440 --> 00:33:14,060
the big picture for finding things in

00:33:11,630 --> 00:33:17,030
Kadem for example you know so how would

00:33:14,060 --> 00:33:21,380
I see a specific flag for a specific

00:33:17,030 --> 00:33:23,870
task being you know executed and where

00:33:21,380 --> 00:33:26,360
is this task structure that tells me

00:33:23,870 --> 00:33:28,910
exactly everything about the task that

00:33:26,360 --> 00:33:31,160
is running and how can I locate it you

00:33:28,910 --> 00:33:32,090
know so it's usually when you are

00:33:31,160 --> 00:33:33,620
opening a kernel

00:33:32,090 --> 00:33:35,419
up and you're just opening the source

00:33:33,620 --> 00:33:37,070
code you're looking for global variables

00:33:35,419 --> 00:33:39,110
because the global variables are in

00:33:37,070 --> 00:33:41,360
spots there you can find them right and

00:33:39,110 --> 00:33:43,520
after finding the global variables

00:33:41,360 --> 00:33:45,350
you're always looking for linking lists

00:33:43,520 --> 00:33:47,840
because then you can find pointers that

00:33:45,350 --> 00:33:48,650
will take you to somewhere it's

00:33:47,840 --> 00:33:51,529
important

00:33:48,650 --> 00:33:53,450
crash to this lots of things for you

00:33:51,529 --> 00:33:55,580
automatically like for example reading

00:33:53,450 --> 00:33:57,590
all the tasks are you all the task is

00:33:55,580 --> 00:34:00,020
shirts and giving you pointers for this

00:33:57,590 --> 00:34:03,620
but sometimes like I'm gonna show if

00:34:00,020 --> 00:34:05,419
time allows you don't have this

00:34:03,620 --> 00:34:07,429
automated and then you have to read the

00:34:05,419 --> 00:34:14,440
code and then navigate through all those

00:34:07,429 --> 00:34:17,210
pointers right so this was an example

00:34:14,440 --> 00:34:22,099
another example is how the memory works

00:34:17,210 --> 00:34:24,740
and then the memory basically having a

00:34:22,099 --> 00:34:26,750
concept of how the virtual memory of a

00:34:24,740 --> 00:34:29,480
test that is being executed is a wrench

00:34:26,750 --> 00:34:31,849
right and having the concept where is a

00:34:29,480 --> 00:34:33,470
text segment in the you know lower part

00:34:31,849 --> 00:34:35,179
and have this stack being arranged

00:34:33,470 --> 00:34:38,419
around the top and it's groups go

00:34:35,179 --> 00:34:41,119
growing on frames depending on the

00:34:38,419 --> 00:34:43,550
execution where you are and then things

00:34:41,119 --> 00:34:45,679
like for shared libraries how are they

00:34:43,550 --> 00:34:48,230
loaded you know if you are calling for

00:34:45,679 --> 00:34:50,510
example memory malloc and how my lock

00:34:48,230 --> 00:34:52,730
works how my luck is getting the memory

00:34:50,510 --> 00:34:55,190
you know to grow with the heap of the

00:34:52,730 --> 00:34:56,899
process there you are into and this is

00:34:55,190 --> 00:34:58,070
particularly important because when

00:34:56,899 --> 00:35:00,230
you're dealing with bugs

00:34:58,070 --> 00:35:01,940
those if you don't have those concepts

00:35:00,230 --> 00:35:04,670
for example let's say you're playing

00:35:01,940 --> 00:35:06,470
with huge TOB right you're you're

00:35:04,670 --> 00:35:08,380
playing with huge pages right but you're

00:35:06,470 --> 00:35:11,359
you're playing with a leap here be

00:35:08,380 --> 00:35:13,490
library leave huge TOB library by

00:35:11,359 --> 00:35:15,710
basically hijacks all the calls to my

00:35:13,490 --> 00:35:18,170
lock that would go to in toteal ipsy and

00:35:15,710 --> 00:35:20,990
if we implements the more core function

00:35:18,170 --> 00:35:22,849
that is part of the jeely bc and it's a

00:35:20,990 --> 00:35:25,190
function that calls the kernel and gets

00:35:22,849 --> 00:35:27,080
more memory for your heap let's say if

00:35:25,190 --> 00:35:28,849
you don't understand this and you're

00:35:27,080 --> 00:35:32,089
using the Lib HT a bit you don't know

00:35:28,849 --> 00:35:33,950
where to look you know so that's the big

00:35:32,089 --> 00:35:36,230
picture you have to have in mind as well

00:35:33,950 --> 00:35:38,960
and that's why I put those lights even

00:35:36,230 --> 00:35:40,460
if you know sometimes you're not seeing

00:35:38,960 --> 00:35:42,410
it now but that you have it as a

00:35:40,460 --> 00:35:44,990
reference that what is the exact

00:35:42,410 --> 00:35:45,950
foundations for the book solving another

00:35:44,990 --> 00:35:48,890
important part

00:35:45,950 --> 00:35:51,460
the mmm structure and the VMA concept so

00:35:48,890 --> 00:35:54,740
every time you know you ask for a memory

00:35:51,460 --> 00:35:57,800
for the kernel it gets you a continuous

00:35:54,740 --> 00:36:01,250
VM AE area you know and it tries to

00:35:57,800 --> 00:36:04,339
expand that VM a area for you and if

00:36:01,250 --> 00:36:07,310
it's not it's not possible because it's

00:36:04,339 --> 00:36:09,730
a different security mechanism it's a

00:36:07,310 --> 00:36:13,220
different protection it's a different

00:36:09,730 --> 00:36:16,369
than it will get another VM a and this

00:36:13,220 --> 00:36:18,440
vmas are linked you know certain things

00:36:16,369 --> 00:36:21,290
that you have to have in mind for the

00:36:18,440 --> 00:36:24,109
Kadem analysis

00:36:21,290 --> 00:36:27,290
another thing is on the file system so

00:36:24,109 --> 00:36:29,210
see I'm passing so I went from the the

00:36:27,290 --> 00:36:31,460
processes and then the virtual memory

00:36:29,210 --> 00:36:33,650
how to stack work you know and now we're

00:36:31,460 --> 00:36:36,380
doing the filesystem part so the

00:36:33,650 --> 00:36:38,420
filesystem how to whenever you have file

00:36:36,380 --> 00:36:40,849
descriptors open for that particular

00:36:38,420 --> 00:36:42,770
test that is running and then we have

00:36:40,849 --> 00:36:44,570
like the Daintree cache Bettany so

00:36:42,770 --> 00:36:46,579
whenever you try to open a file the

00:36:44,570 --> 00:36:48,440
kernel will get the entries for you and

00:36:46,579 --> 00:36:50,930
it's gonna cash the den trick you know

00:36:48,440 --> 00:36:52,730
the entries for you trying to solve all

00:36:50,930 --> 00:36:54,410
the paths and after that we'll find I

00:36:52,730 --> 00:36:55,940
know the responsible for the file would

00:36:54,410 --> 00:36:59,030
get the file for you and there is

00:36:55,940 --> 00:37:00,980
abstract for the file district is gonna

00:36:59,030 --> 00:37:03,349
be given to the file descriptor and if I

00:37:00,980 --> 00:37:08,540
descriptor it is part of the task so you

00:37:03,349 --> 00:37:12,260
have to have this in mind right another

00:37:08,540 --> 00:37:14,150
thing we've seen like some presentations

00:37:12,260 --> 00:37:16,130
about a ioke right you have to have in

00:37:14,150 --> 00:37:18,010
mind also that there are four types of

00:37:16,130 --> 00:37:21,200
i/o basic right synchronous asynchronous

00:37:18,010 --> 00:37:23,960
buffered and unbuffered so are you using

00:37:21,200 --> 00:37:26,150
page caching you know for this task or

00:37:23,960 --> 00:37:30,589
you're not using or dealing directly is

00:37:26,150 --> 00:37:32,990
it aligned with the memory or not and so

00:37:30,589 --> 00:37:35,480
on so in here I'm just showing you know

00:37:32,990 --> 00:37:37,220
like how would be to look up a file name

00:37:35,480 --> 00:37:40,160
and then the dentary cache would be

00:37:37,220 --> 00:37:41,650
created and then there are other things

00:37:40,160 --> 00:37:44,150
that you have to have in mind for

00:37:41,650 --> 00:37:46,220
whenever the kernel is allocating memory

00:37:44,150 --> 00:37:49,400
how the kernel is allocating memory is

00:37:46,220 --> 00:37:51,920
it using just allocating a page or the

00:37:49,400 --> 00:37:56,000
kernel is allocating a slab object what

00:37:51,920 --> 00:37:59,150
is a slab object okay and then after it

00:37:56,000 --> 00:38:00,160
if done it for you you will have the

00:37:59,150 --> 00:38:01,960
file

00:38:00,160 --> 00:38:03,670
written to the page cash who is

00:38:01,960 --> 00:38:05,140
responsible for committing the page cash

00:38:03,670 --> 00:38:07,390
you know which Colonel traders

00:38:05,140 --> 00:38:09,579
responsible for commit and why is this

00:38:07,390 --> 00:38:10,869
part of a big picture because when you

00:38:09,579 --> 00:38:14,109
have a bug you don't know where the

00:38:10,869 --> 00:38:16,569
problem is you simply don't know where

00:38:14,109 --> 00:38:18,940
the problem is you have some tips on

00:38:16,569 --> 00:38:20,680
what is happening but if you don't have

00:38:18,940 --> 00:38:25,960
the big picture you won't discover where

00:38:20,680 --> 00:38:34,030
the problem is network I think you got

00:38:25,960 --> 00:38:36,369
the idea they scatter and then finally

00:38:34,030 --> 00:38:38,410
some of the messages that we usually get

00:38:36,369 --> 00:38:41,799
out of the testing right so they're

00:38:38,410 --> 00:38:47,910
stacked races or things like so let's

00:38:41,799 --> 00:38:50,380
get one of the problems and it's usually

00:38:47,910 --> 00:38:51,190
so for example this was one of the book

00:38:50,380 --> 00:38:53,410
that we got

00:38:51,190 --> 00:38:56,109
Curnow basically telling us that there

00:38:53,410 --> 00:38:59,260
was a possible win first lock you know

00:38:56,109 --> 00:39:01,900
and in next and is this something I have

00:38:59,260 --> 00:39:03,099
to report to the upstream so is this

00:39:01,900 --> 00:39:03,460
something that I have to report right

00:39:03,099 --> 00:39:06,849
away

00:39:03,460 --> 00:39:08,740
is the the person in charge you know

00:39:06,849 --> 00:39:11,200
would the person the engineer in charge

00:39:08,740 --> 00:39:14,940
like to see this type of information and

00:39:11,200 --> 00:39:18,900
then it's basically sometimes we cannot

00:39:14,940 --> 00:39:22,359
trust what kernel is telling so this was

00:39:18,900 --> 00:39:23,980
detector the the are the deadlock

00:39:22,359 --> 00:39:25,770
detector of the kernel giving an

00:39:23,980 --> 00:39:29,170
information that after it ran that test

00:39:25,770 --> 00:39:31,809
it could have found a double lock

00:39:29,170 --> 00:39:34,240
problem on the lock the lock ordering

00:39:31,809 --> 00:39:36,700
problem right and then you're basically

00:39:34,240 --> 00:39:39,160
it basically describes if you locked it

00:39:36,700 --> 00:39:41,109
in a different order in multiple CPUs

00:39:39,160 --> 00:39:43,750
you caused a deadlock in between them

00:39:41,109 --> 00:39:45,609
right but then instead of have imagine

00:39:43,750 --> 00:39:47,650
if I would have to generate a dump and

00:39:45,609 --> 00:39:49,359
investigate every time something like

00:39:47,650 --> 00:39:51,490
this happens then it's like super

00:39:49,359 --> 00:39:53,980
impossible to provide a quick feedback

00:39:51,490 --> 00:39:56,200
to web-streaming right so one of the

00:39:53,980 --> 00:39:58,059
things is you have to go and analyze a

00:39:56,200 --> 00:39:58,510
stack trace and see if it's feasible or

00:39:58,059 --> 00:40:00,490
not

00:39:58,510 --> 00:40:03,039
when analyzing this a stack trace for

00:40:00,490 --> 00:40:05,740
example it's simply to know that this

00:40:03,039 --> 00:40:08,430
head here I would open eclipse see this

00:40:05,740 --> 00:40:11,859
head this heads a per CPU variable so

00:40:08,430 --> 00:40:13,700
like if it's a Percy people this doesn't

00:40:11,859 --> 00:40:16,400
make any sense because every

00:40:13,700 --> 00:40:18,800
CPU will have a different variable even

00:40:16,400 --> 00:40:21,650
being the same variable name the

00:40:18,800 --> 00:40:24,500
pointers are pointing to per CPU area so

00:40:21,650 --> 00:40:27,130
it's not to see two variables so this

00:40:24,500 --> 00:40:32,980
condition could have happen never happen

00:40:27,130 --> 00:40:32,980
so it's a false positive the other one

00:40:38,799 --> 00:40:49,309
so the other one was Hanks right this is

00:40:45,319 --> 00:40:51,920
an everyday thing so you're you were

00:40:49,309 --> 00:40:54,890
talking about having the test that broke

00:40:51,920 --> 00:40:57,380
the all day run right and it broke

00:40:54,890 --> 00:40:59,150
because it calls let's say a deadlock or

00:40:57,380 --> 00:41:01,460
a softlock up or something and the

00:40:59,150 --> 00:41:04,400
colonel and then suddenly that colonel

00:41:01,460 --> 00:41:07,970
was broken for other tests this is what

00:41:04,400 --> 00:41:11,450
we would be seen right the RC u detector

00:41:07,970 --> 00:41:13,819
for the for that particular scheduler on

00:41:11,450 --> 00:41:18,710
that particular CPU would accuse that

00:41:13,819 --> 00:41:22,400
the task is locked up so the task has

00:41:18,710 --> 00:41:26,240
been to be scheduled or being scattered

00:41:22,400 --> 00:41:28,430
in the cpu in the exact same place every

00:41:26,240 --> 00:41:30,769
time right and then we have to

00:41:28,430 --> 00:41:34,309
understand why is it the schedule though

00:41:30,769 --> 00:41:36,170
it's waiting for a completion and what

00:41:34,309 --> 00:41:38,960
is this completion this completion is

00:41:36,170 --> 00:41:41,240
coming from a fire system functional

00:41:38,960 --> 00:41:43,190
fire system not v function and then

00:41:41,240 --> 00:41:45,019
would be our job to understand what is

00:41:43,190 --> 00:41:48,349
going on and to provide upstream well

00:41:45,019 --> 00:41:51,230
hey you know you just caused a race

00:41:48,349 --> 00:41:53,599
condition here because of that it I

00:41:51,230 --> 00:41:54,769
don't know so like I'm gonna show in the

00:41:53,599 --> 00:41:56,599
next light I don't know if our system

00:41:54,769 --> 00:41:59,359
not fire and I don't want to know

00:41:56,599 --> 00:42:01,579
because it's not it's not our core

00:41:59,359 --> 00:42:03,710
business right our core business is to

00:42:01,579 --> 00:42:07,489
understand those type of situations and

00:42:03,710 --> 00:42:10,549
then to explain to whoever use that

00:42:07,489 --> 00:42:12,730
interface how they broke it if they

00:42:10,549 --> 00:42:12,730
broke

00:42:16,470 --> 00:42:21,990
and sometimes for example in these two

00:42:18,810 --> 00:42:24,359
examples I'm not gonna open just so to

00:42:21,990 --> 00:42:26,520
spare time but those two examples is

00:42:24,359 --> 00:42:29,280
different stack traces for the same

00:42:26,520 --> 00:42:32,310
purpose this was a rag map area for the

00:42:29,280 --> 00:42:33,930
high keyboard and one was ups and the

00:42:32,310 --> 00:42:36,180
other one was something else just

00:42:33,930 --> 00:42:38,339
because the pointer was pointing to

00:42:36,180 --> 00:42:40,470
something that didn't have the registers

00:42:38,339 --> 00:42:49,140
mapped and exploded then the stack

00:42:40,470 --> 00:42:53,099
traces were different so and this is an

00:42:49,140 --> 00:42:56,700
example of putting Oliver that I blinked

00:42:53,099 --> 00:43:02,609
until now all together right so it's

00:42:56,700 --> 00:43:05,359
basically one bug brought to us by L kfg

00:43:02,609 --> 00:43:09,329
output saying there is an issue with

00:43:05,359 --> 00:43:12,920
file system rectify on kernel 4.9 and

00:43:09,329 --> 00:43:15,210
4.4 you know architectures and then our

00:43:12,920 --> 00:43:17,369
responsibility would be to understand

00:43:15,210 --> 00:43:19,890
what is this problem is it fixable or

00:43:17,369 --> 00:43:22,109
not for that particular kernel versions

00:43:19,890 --> 00:43:24,810
and should I warn up strings really tell

00:43:22,109 --> 00:43:28,109
Gregg hey Greg this is broken you know

00:43:24,810 --> 00:43:30,480
in 4/4 do you want someone to fix or

00:43:28,109 --> 00:43:35,640
let's fix together what should we do or

00:43:30,480 --> 00:43:37,109
it's unfixable like in this case so

00:43:35,640 --> 00:43:40,380
putting everything together I was

00:43:37,109 --> 00:43:42,569
basically generating the kernel like I

00:43:40,380 --> 00:43:44,940
said you know using those tools that I

00:43:42,569 --> 00:43:47,010
mentioned before it's like I need this a

00:43:44,940 --> 00:43:49,050
specific kernel version for this test

00:43:47,010 --> 00:43:51,990
because sometimes I have the bug open

00:43:49,050 --> 00:43:54,839
like in January and I don't and this the

00:43:51,990 --> 00:43:57,750
test was merit marked as skipped in

00:43:54,839 --> 00:43:59,490
January right but then the development

00:43:57,750 --> 00:44:01,319
continued so I want to go back and

00:43:59,490 --> 00:44:03,480
generate that kernel for me so that's

00:44:01,319 --> 00:44:06,990
what I'm doing here generated the Debian

00:44:03,480 --> 00:44:08,460
kernel and doing all the installations

00:44:06,990 --> 00:44:10,319
that I showed in the beginning you know

00:44:08,460 --> 00:44:13,380
in the virtual machine and generating

00:44:10,319 --> 00:44:15,780
and installing the kernel installing

00:44:13,380 --> 00:44:17,640
crash and then here it's the container

00:44:15,780 --> 00:44:19,800
right so inside the container I'm

00:44:17,640 --> 00:44:21,630
basically installing the crash - and the

00:44:19,800 --> 00:44:25,140
debug symbols for the kernel

00:44:21,630 --> 00:44:27,420
so that building the script the kernel

00:44:25,140 --> 00:44:29,310
building script is generating also the

00:44:27,420 --> 00:44:29,700
dwarf symbols for the kernel that I'm

00:44:29,310 --> 00:44:32,310
going to

00:44:29,700 --> 00:44:35,430
analyzing so that I have the dbg sings

00:44:32,310 --> 00:44:44,340
for a package for for for opening inside

00:44:35,430 --> 00:44:48,780
the crash and then I open mmm where is

00:44:44,340 --> 00:44:52,050
it ok so then I basically install LTP

00:44:48,780 --> 00:44:54,330
inside the KVM I have a container ready

00:44:52,050 --> 00:44:55,710
with the crash and debug symbols for

00:44:54,330 --> 00:44:58,230
that kernel but now it's time to

00:44:55,710 --> 00:45:02,400
generate the kernel right generate the

00:44:58,230 --> 00:45:04,770
Kadem right so basically I ran so here

00:45:02,400 --> 00:45:08,610
I'm making sure that kdump is working

00:45:04,770 --> 00:45:10,890
right inside KVM and here is a trick so

00:45:08,610 --> 00:45:13,020
every that's the problem with having

00:45:10,890 --> 00:45:15,570
boards different boards and different

00:45:13,020 --> 00:45:17,730
boot loaders and so if you are dealing

00:45:15,570 --> 00:45:19,830
with this server architecture all the

00:45:17,730 --> 00:45:21,840
Kay dumps are beautiful and they work

00:45:19,830 --> 00:45:23,430
every time and also in different boards

00:45:21,840 --> 00:45:25,470
we have different loaders and different

00:45:23,430 --> 00:45:27,870
options and I had so many problems

00:45:25,470 --> 00:45:29,670
generating K dumps in different boards

00:45:27,870 --> 00:45:32,940
for a different type of works you know

00:45:29,670 --> 00:45:36,000
so here for example I'm showing how a

00:45:32,940 --> 00:45:39,660
crash would be okay dump would be ready

00:45:36,000 --> 00:45:42,870
inside the KPM and then if you crash the

00:45:39,660 --> 00:45:45,120
system it would K Zack a new kernel and

00:45:42,870 --> 00:45:46,890
generate the K dump for me right but

00:45:45,120 --> 00:45:50,190
this is not what happened in the

00:45:46,890 --> 00:45:53,550
beginning so I had to that's do the good

00:45:50,190 --> 00:45:56,190
on of working with ki mu Kim you can

00:45:53,550 --> 00:45:59,370
generate an elf image of the guest for

00:45:56,190 --> 00:46:02,190
you without you have to have the K dump

00:45:59,370 --> 00:46:04,620
for example so I could have the K dump

00:46:02,190 --> 00:46:07,140
like I'm doing here you know the virtual

00:46:04,620 --> 00:46:09,420
machine is reserving some part of the

00:46:07,140 --> 00:46:11,130
memory to have the K Zack and the second

00:46:09,420 --> 00:46:13,830
kernel will boot and generate okayed

00:46:11,130 --> 00:46:15,600
them for me or you could have just the

00:46:13,830 --> 00:46:17,700
virtual machine running and in the host

00:46:15,600 --> 00:46:19,920
you could generate the dump from the

00:46:17,700 --> 00:46:22,680
first command for example fish and save

00:46:19,920 --> 00:46:27,690
save image for me and then I would have

00:46:22,680 --> 00:46:29,670
the image to be analyzed here for

00:46:27,690 --> 00:46:31,440
example you can set all those options to

00:46:29,670 --> 00:46:33,390
panic depending on the errors that are

00:46:31,440 --> 00:46:36,380
happening so seeing some reproducing

00:46:33,390 --> 00:46:38,580
something that came out of LK ft

00:46:36,380 --> 00:46:40,680
basically setting everything to one it

00:46:38,580 --> 00:46:43,110
would panic the kind of whatever happens

00:46:40,680 --> 00:46:43,500
like if it's a bug it's not if it's a

00:46:43,110 --> 00:46:46,920
known

00:46:43,500 --> 00:46:49,230
am i or not and then I'm getting the LTP

00:46:46,920 --> 00:46:50,940
and running the LTP right and then I'm

00:46:49,230 --> 00:46:53,790
causing the problem that I saw inside

00:46:50,940 --> 00:46:57,900
the lkf g1 just one run this is just

00:46:53,790 --> 00:46:59,670
this is a one day to day work we do like

00:46:57,900 --> 00:47:03,120
I'm doing this they don't know it's like

00:46:59,670 --> 00:47:04,860
five six times seven times a week so

00:47:03,120 --> 00:47:06,840
that's why this environment has to you

00:47:04,860 --> 00:47:09,510
know to be like that and then I

00:47:06,840 --> 00:47:14,040
reproduce this it's basically caused

00:47:09,510 --> 00:47:16,800
some tasks to be blocked right and then

00:47:14,040 --> 00:47:18,660
I in this first run I wasn't generating

00:47:16,800 --> 00:47:21,150
any kernel done for this failure and

00:47:18,660 --> 00:47:26,970
then suddenly I just failed and these

00:47:21,150 --> 00:47:29,310
tasks are in and in this state so you

00:47:26,970 --> 00:47:31,650
cannot kill those if you try to queue

00:47:29,310 --> 00:47:34,140
Curnow cannot dislikes are total those

00:47:31,650 --> 00:47:36,570
tests are totally blocked and if you go

00:47:34,140 --> 00:47:38,730
to the amount to the main process of

00:47:36,570 --> 00:47:40,860
these tasks you're basically catching

00:47:38,730 --> 00:47:43,590
they stack to see what is going on right

00:47:40,860 --> 00:47:45,450
so when when you are debugging there are

00:47:43,590 --> 00:47:47,340
multiple ways of debugging right one is

00:47:45,450 --> 00:47:50,310
the post-mortem analysis which is this

00:47:47,340 --> 00:47:52,590
one it's basically just getting stack

00:47:50,310 --> 00:47:55,140
traces and the kernel dump and analyzing

00:47:52,590 --> 00:47:57,600
it the other way is tracing right so you

00:47:55,140 --> 00:47:59,790
usually trace something that doesn't

00:47:57,600 --> 00:48:02,790
have the effect so whenever the problem

00:47:59,790 --> 00:48:04,800
happened you see a side effect of it but

00:48:02,790 --> 00:48:06,350
you don't you cannot see how it happened

00:48:04,800 --> 00:48:12,540
so you have to trace a calf trace

00:48:06,350 --> 00:48:14,790
systemtap no profile or perf and then in

00:48:12,540 --> 00:48:16,710
this condition is different so this is a

00:48:14,790 --> 00:48:18,870
deadlock and then I can see a

00:48:16,710 --> 00:48:21,990
post-mortem and see the stack traces and

00:48:18,870 --> 00:48:25,560
see what is going on and then I

00:48:21,990 --> 00:48:27,930
generated I generated automatic

00:48:25,560 --> 00:48:29,670
automatic kernel dump from from this

00:48:27,930 --> 00:48:32,130
situation and the kernel generated a

00:48:29,670 --> 00:48:36,180
kernel done for me when this happened I

00:48:32,130 --> 00:48:38,940
have the dump I open the dump D mask and

00:48:36,180 --> 00:48:41,790
this is where things start to get cool

00:48:38,940 --> 00:48:45,030
right because I have the stack trace

00:48:41,790 --> 00:48:47,670
from a task that has been blocked more

00:48:45,030 --> 00:48:51,450
than 120 seconds what does that mean the

00:48:47,670 --> 00:48:53,760
task is in the exact same stack so the

00:48:51,450 --> 00:48:55,890
kernel has identified that this stack is

00:48:53,760 --> 00:48:56,730
pretty much the same for the past two

00:48:55,890 --> 00:48:59,609
minutes

00:48:56,730 --> 00:49:03,960
in computer timing it's like huge time

00:48:59,609 --> 00:49:05,910
amount of time right so why am why are

00:49:03,960 --> 00:49:07,829
we blocked here so we are basically

00:49:05,910 --> 00:49:10,020
calling it schedule which means that

00:49:07,829 --> 00:49:13,140
it's not a hard lockup I'm not spinning

00:49:10,020 --> 00:49:15,390
on a CPU this task is waiting for

00:49:13,140 --> 00:49:18,450
something it doesn't happen it goes away

00:49:15,390 --> 00:49:21,180
and it gets out of the scheduled queue

00:49:18,450 --> 00:49:23,430
and then it gets in your schedule again

00:49:21,180 --> 00:49:25,020
in the CPU checks for that condition and

00:49:23,430 --> 00:49:29,130
so on it's all right

00:49:25,020 --> 00:49:32,790
and then the here is where the gmask

00:49:29,130 --> 00:49:35,849
messages can play tricks on us right why

00:49:32,790 --> 00:49:38,490
because this is the regular stack trace

00:49:35,849 --> 00:49:40,710
of a machine that has dumped and it

00:49:38,490 --> 00:49:42,660
called an ohm askable winter grouped and

00:49:40,710 --> 00:49:46,500
this interrupt has been attended by all

00:49:42,660 --> 00:49:49,950
the CPUs by the handler and generated a

00:49:46,500 --> 00:49:53,089
stack traces for us and this is a this

00:49:49,950 --> 00:49:55,020
is for example if someone is

00:49:53,089 --> 00:49:56,880
investigating something I don't have in

00:49:55,020 --> 00:49:59,040
the concept that the kernel has crashed

00:49:56,880 --> 00:50:01,500
because of something else you would see

00:49:59,040 --> 00:50:04,500
things like Forex two-way peaks and apip

00:50:01,500 --> 00:50:06,869
ice so it's basically the kernel talking

00:50:04,500 --> 00:50:09,569
one CPU to one other sending callbacks

00:50:06,869 --> 00:50:12,240
for the CPUs to execute something but

00:50:09,569 --> 00:50:14,970
this is all part of the K dump it's all

00:50:12,240 --> 00:50:16,950
part of you know the crash itself and

00:50:14,970 --> 00:50:22,560
it's not the in fact that we are looking

00:50:16,950 --> 00:50:31,230
for in this particular book so to make

00:50:22,560 --> 00:50:37,470
things faster basically for for this

00:50:31,230 --> 00:50:40,380
test that it was so for this particular

00:50:37,470 --> 00:50:42,450
task for notify all the tasks that were

00:50:40,380 --> 00:50:46,530
blocked I had three different stack

00:50:42,450 --> 00:50:49,500
traces right and then all those tasks

00:50:46,530 --> 00:50:51,480
here have the same stack trace and then

00:50:49,500 --> 00:50:55,260
I have two different two other different

00:50:51,480 --> 00:50:56,880
stack traces and then some if you don't

00:50:55,260 --> 00:50:59,550
have the source code of the test that

00:50:56,880 --> 00:51:00,930
generated is error you have to do

00:50:59,550 --> 00:51:03,990
reverse engineering and try to

00:51:00,930 --> 00:51:06,450
understand what is going on right so for

00:51:03,990 --> 00:51:08,520
example do wait it's likely the main

00:51:06,450 --> 00:51:11,369
proxy is waiting for the child's to exit

00:51:08,520 --> 00:51:13,980
that's you know

00:51:11,369 --> 00:51:16,200
and then here wait for competition for

00:51:13,980 --> 00:51:18,210
completion I don't know what is going on

00:51:16,200 --> 00:51:19,800
but I know that this is not good right

00:51:18,210 --> 00:51:20,880
because it's waiting for something to

00:51:19,800 --> 00:51:26,190
finish that it hadn't

00:51:20,880 --> 00:51:30,210
and then here also handle we event and

00:51:26,190 --> 00:51:33,740
all those tests are blocked so my first

00:51:30,210 --> 00:51:36,840
line of thoughts were is this a problem

00:51:33,740 --> 00:51:38,400
causing the wait for completion not to

00:51:36,840 --> 00:51:44,100
work for example and then I have to

00:51:38,400 --> 00:51:47,130
investigate right so to a bit to

00:51:44,100 --> 00:51:50,330
show we usually whenever we're seeking

00:51:47,130 --> 00:51:51,510
for Colonel dumps we we don't have the

00:51:50,330 --> 00:51:53,850
userland

00:51:51,510 --> 00:51:55,980
source code you know it's not common for

00:51:53,850 --> 00:51:57,780
us to have but in this case we do so

00:51:55,980 --> 00:52:00,840
let's cheat a bit just to understand

00:51:57,780 --> 00:52:04,560
what was going on so basically this test

00:52:00,840 --> 00:52:07,290
was causing the was basically open fires

00:52:04,560 --> 00:52:10,260
and causing access to those files right

00:52:07,290 --> 00:52:12,390
the way file system notify works it's it

00:52:10,260 --> 00:52:16,290
subscribes those files to a notification

00:52:12,390 --> 00:52:19,500
system and what happens is whenever you

00:52:16,290 --> 00:52:22,080
cause an access to that fire whit asks

00:52:19,500 --> 00:52:23,730
userland so you basically go through the

00:52:22,080 --> 00:52:26,369
virtual file system to the kernel and

00:52:23,730 --> 00:52:29,460
then it sees who is the one responsible

00:52:26,369 --> 00:52:32,940
for causing for telling me if it access

00:52:29,460 --> 00:52:34,590
is permitted or not it's a user land so

00:52:32,940 --> 00:52:36,780
it goes to user land back again and

00:52:34,590 --> 00:52:38,580
something user land provides access yes

00:52:36,780 --> 00:52:41,010
or no and then it goes back to the

00:52:38,580 --> 00:52:42,720
kernel and it tells the first task you

00:52:41,010 --> 00:52:44,810
were allowed or not to access just

00:52:42,720 --> 00:52:47,700
because then you can have a daemon

00:52:44,810 --> 00:52:50,119
allowing or denying access to a file and

00:52:47,700 --> 00:52:53,400
that's what this interface is all about

00:52:50,119 --> 00:52:56,220
for you know like antivirus and stuff

00:52:53,400 --> 00:52:58,609
and things like that so as me as a

00:52:56,220 --> 00:53:01,800
sustaining engineer or type of

00:52:58,609 --> 00:53:05,100
validation engineer I don't have to know

00:53:01,800 --> 00:53:07,290
exactly how far notify works so I have

00:53:05,100 --> 00:53:10,250
to seek for the pointers that cause this

00:53:07,290 --> 00:53:10,250
particular error

00:53:20,019 --> 00:53:27,980
and the pointer is here not to get like

00:53:24,980 --> 00:53:29,930
super deep because without if you want

00:53:27,980 --> 00:53:33,650
to go deeper you can see the OSA slides

00:53:29,930 --> 00:53:35,779
are self explaining and so for example

00:53:33,650 --> 00:53:37,970
there is the who's who watched the nach

00:53:35,779 --> 00:53:41,210
if there is a PI here if you click it

00:53:37,970 --> 00:53:43,249
and it's linked to the under today to

00:53:41,210 --> 00:53:45,680
others lights that are related to this

00:53:43,249 --> 00:53:47,299
particular information so it's easy for

00:53:45,680 --> 00:53:49,789
you to navigate to those lights if you

00:53:47,299 --> 00:53:52,759
want to go deeper into the analysis here

00:53:49,789 --> 00:53:55,759
but the main idea when you are debugging

00:53:52,759 --> 00:53:58,069
things like this is to understand what

00:53:55,759 --> 00:54:01,369
was going on so I get a stack trace I

00:53:58,069 --> 00:54:04,160
get you know I was waiting for

00:54:01,369 --> 00:54:07,609
completion I understand who was waiting

00:54:04,160 --> 00:54:10,400
for this completion for me and then I

00:54:07,609 --> 00:54:14,299
see oh it was the file system notify and

00:54:10,400 --> 00:54:16,430
then I had an s RCU you know which is a

00:54:14,299 --> 00:54:17,960
synchronization mechanism and then I

00:54:16,430 --> 00:54:20,420
have to understand a little bit further

00:54:17,960 --> 00:54:24,319
about the synchronization mechanism and

00:54:20,420 --> 00:54:27,259
who was using this index so this

00:54:24,319 --> 00:54:29,630
particular SRC you and an interface that

00:54:27,259 --> 00:54:31,579
was using was this one you know those

00:54:29,630 --> 00:54:34,489
two functions and those two functions I

00:54:31,579 --> 00:54:36,859
had in my stack so great so I have I

00:54:34,489 --> 00:54:38,390
might have a race condition in between

00:54:36,859 --> 00:54:41,930
them I don't know no I have to

00:54:38,390 --> 00:54:46,660
investigate unfortunately things are not

00:54:41,930 --> 00:54:52,089
like super easy alright so I have to go

00:54:46,660 --> 00:54:55,069
really deep into some stuff let me see

00:54:52,089 --> 00:54:57,529
so basically the RCU mechanism is a

00:54:55,069 --> 00:55:00,890
synchronization mechanism right and it's

00:54:57,529 --> 00:55:04,249
it's a read cop update so basic whenever

00:55:00,890 --> 00:55:06,230
you change things you don't block the

00:55:04,249 --> 00:55:08,329
readers that's the main idea of the

00:55:06,230 --> 00:55:11,230
synchronization mechanism really simple

00:55:08,329 --> 00:55:11,230
and then

00:55:13,769 --> 00:55:20,949
and then I have to I had to find other

00:55:17,789 --> 00:55:23,439
tasks because it's not only the user

00:55:20,949 --> 00:55:26,589
user LAN test that I'm investigating who

00:55:23,439 --> 00:55:28,479
else was using the the same as RSU

00:55:26,589 --> 00:55:31,329
synchronization mechanism and I saw

00:55:28,479 --> 00:55:33,729
there was also a kernel thread versus

00:55:31,329 --> 00:55:35,709
and notify marking and this kernel

00:55:33,729 --> 00:55:37,839
thread was waiting for a completion so

00:55:35,709 --> 00:55:41,169
there were two tasks waiting for a

00:55:37,839 --> 00:55:43,509
completion and that it's telling me

00:55:41,169 --> 00:55:47,169
something where to go and how to find

00:55:43,509 --> 00:55:51,849
things not to get too deep into this

00:55:47,169 --> 00:55:55,659
because like it's if someone once I can

00:55:51,849 --> 00:55:59,579
do it like in private but then I had to

00:55:55,659 --> 00:56:04,479
understand how the SRU SRC you my

00:55:59,579 --> 00:56:07,359
internals worked and then the basic idea

00:56:04,479 --> 00:56:09,729
was regular tasks for notify a stuck

00:56:07,359 --> 00:56:13,509
right and then I have a kernel thread

00:56:09,729 --> 00:56:16,299
for notify Marc is also a stuck both are

00:56:13,509 --> 00:56:18,309
waiting for completions and both are

00:56:16,299 --> 00:56:24,130
coming from the synchronization as our

00:56:18,309 --> 00:56:26,529
SRC you synchronization on RC u so this

00:56:24,130 --> 00:56:29,169
is the situation and then understanding

00:56:26,529 --> 00:56:32,229
how our senior works I knew exactly that

00:56:29,169 --> 00:56:34,749
if this happened before it would have

00:56:32,229 --> 00:56:37,329
triggered a graceful period for the RC

00:56:34,749 --> 00:56:39,939
a-- and if it happened before it will

00:56:37,329 --> 00:56:43,059
have its own triggered its own graceful

00:56:39,939 --> 00:56:45,369
period for the RC a-- so this is just

00:56:43,059 --> 00:56:48,609
like the facts that i was observing

00:56:45,369 --> 00:56:51,249
right and then the idea on when you were

00:56:48,609 --> 00:56:53,619
debugging is to make hypotheses and to

00:56:51,249 --> 00:56:57,089
save the hi pot to solve the hypothesis

00:56:53,619 --> 00:57:01,209
right so the hypothesis here were

00:56:57,089 --> 00:57:05,289
basically do i have a problem on SRC you

00:57:01,209 --> 00:57:07,900
internals this that's the part where i

00:57:05,289 --> 00:57:10,299
don't like because this was the this is

00:57:07,900 --> 00:57:12,939
the harder path but sometimes we as

00:57:10,299 --> 00:57:17,859
engineers prefer their heart just

00:57:12,939 --> 00:57:20,949
because it's cooler and then you know so

00:57:17,859 --> 00:57:23,140
this was i seeked for the wrong path

00:57:20,949 --> 00:57:25,119
here because I wanted to understand

00:57:23,140 --> 00:57:26,890
better for the SRU I shouldn't have done

00:57:25,119 --> 00:57:29,620
that what I did

00:57:26,890 --> 00:57:32,650
and then this is basically trying to

00:57:29,620 --> 00:57:34,600
find a problem inside the

00:57:32,650 --> 00:57:37,660
synchronization mechanism what would be

00:57:34,600 --> 00:57:40,030
a problem like a memory barrier let's

00:57:37,660 --> 00:57:41,830
say for example all the synchronization

00:57:40,030 --> 00:57:43,720
primitive all the synchronization

00:57:41,830 --> 00:57:46,660
mechanisms are based on primitives right

00:57:43,720 --> 00:57:48,690
so like in atomic atomic instructions

00:57:46,660 --> 00:57:51,430
and since we're dealing with arm

00:57:48,690 --> 00:57:54,790
sometimes the code was developed in x86

00:57:51,430 --> 00:57:57,120
you know and this primitive he hasn't

00:57:54,790 --> 00:57:59,260
followed something that the engineer

00:57:57,120 --> 00:58:01,690
thought when developing the other

00:57:59,260 --> 00:58:03,340
architecture like a lack of a memory

00:58:01,690 --> 00:58:06,040
barrier or something that could have

00:58:03,340 --> 00:58:09,700
caused the I SARS you not to be atomic

00:58:06,040 --> 00:58:11,590
in the part it should have right so this

00:58:09,700 --> 00:58:14,710
was the first line of investigation the

00:58:11,590 --> 00:58:18,400
second line was is the color for the

00:58:14,710 --> 00:58:21,070
synchronization just know it did it make

00:58:18,400 --> 00:58:25,830
a mistake only which is super easier

00:58:21,070 --> 00:58:25,830
right but I chose the first one just

00:58:26,040 --> 00:58:31,590
because of his personal history that's

00:58:28,690 --> 00:58:33,790
something that when we are debugging

00:58:31,590 --> 00:58:35,350
usually whenever you were doing

00:58:33,790 --> 00:58:37,330
diagnosis you take in consideration

00:58:35,350 --> 00:58:39,220
things that are Ural you lived in the

00:58:37,330 --> 00:58:41,680
past and unnecessary what the problem

00:58:39,220 --> 00:58:45,550
was and I lived in the past problems

00:58:41,680 --> 00:58:48,190
with RC use and VSIP virtual CPUs and

00:58:45,550 --> 00:58:49,960
environment or environments so that's

00:58:48,190 --> 00:58:52,120
why I chose this path first and it

00:58:49,960 --> 00:58:57,580
wasn't the right path that's what I

00:58:52,120 --> 00:58:59,320
wanted to show I'm not sure I'm gonna

00:58:57,580 --> 00:59:02,410
have like follow super deep into the

00:58:59,320 --> 00:59:06,450
analysis if someone wants let me know

00:59:02,410 --> 00:59:11,440
and then we can do it in parallel right

00:59:06,450 --> 00:59:15,160
this is all the analysis on how to find

00:59:11,440 --> 00:59:18,370
the completion right that means so

00:59:15,160 --> 00:59:20,020
basically when you are debugging even if

00:59:18,370 --> 00:59:22,300
you want don't understand the code you

00:59:20,020 --> 00:59:24,250
were into like I didn't for the FS

00:59:22,300 --> 00:59:26,830
naught Phi I knew the primitives and I

00:59:24,250 --> 00:59:28,750
knew that the synchronization as you was

00:59:26,830 --> 00:59:32,920
being called by this tomb functions here

00:59:28,750 --> 00:59:36,490
so here was one key right and then is

00:59:32,920 --> 00:59:39,040
this synchronization for the same as RC

00:59:36,490 --> 00:59:40,569
you yes it is for the filesystem not for

00:59:39,040 --> 00:59:42,969
Marcus RT

00:59:40,569 --> 00:59:45,640
so this is something that is telling me

00:59:42,969 --> 00:59:49,569
how to how to investigate this the other

00:59:45,640 --> 00:59:52,390
thing was like a clip see right so who

00:59:49,569 --> 00:59:54,640
is calling the synchronization as I see

00:59:52,390 --> 00:59:57,459
you all the functions that are calling

00:59:54,640 --> 00:59:58,749
it so file system that if I describe

00:59:57,459 --> 01:00:01,089
this try group

00:59:58,749 --> 01:00:04,059
fire system at five mark destroy which

01:00:01,089 --> 01:00:06,910
is the two tasks that I had in the stack

01:00:04,059 --> 01:00:10,779
trace of that particular test that was

01:00:06,910 --> 01:00:13,269
running right and then so this is group

01:00:10,779 --> 01:00:15,369
1 and this is group 2 this would give me

01:00:13,269 --> 01:00:17,109
a problem inside the kernel so this

01:00:15,369 --> 01:00:19,650
would tell me hey I have a race

01:00:17,109 --> 01:00:22,869
condition in between these two cows

01:00:19,650 --> 01:00:25,239
because the synchronization mechanism

01:00:22,869 --> 01:00:27,669
doesn't work like it should and here

01:00:25,239 --> 01:00:30,549
would be the second part it would be the

01:00:27,669 --> 01:00:34,359
who where who the code that used this

01:00:30,549 --> 01:00:36,999
synchronization did a mistake right so

01:00:34,359 --> 01:00:40,650
first part second part to make things

01:00:36,999 --> 01:00:43,539
easier for you guys to follow and

01:00:40,650 --> 01:00:55,659
because the time has already passed a

01:00:43,539 --> 01:00:59,409
lot I miss you so basically I found a

01:00:55,659 --> 01:01:02,949
word Q in the code I realized who was

01:00:59,409 --> 01:01:06,219
using the that work you I entered the

01:01:02,949 --> 01:01:09,099
SRC you code to see who was working

01:01:06,219 --> 01:01:12,159
there work you and how and then I went

01:01:09,099 --> 01:01:14,079
for the callbacks that were scheduled

01:01:12,159 --> 01:01:16,630
for it all the CPUs to see if the

01:01:14,079 --> 01:01:18,609
callbacks were there and I saw the

01:01:16,630 --> 01:01:21,989
pointers inside the Kadem for the

01:01:18,609 --> 01:01:27,549
callbacks and I realized that they were

01:01:21,989 --> 01:01:29,979
about to be run after it was just one GC

01:01:27,549 --> 01:01:32,949
so my kernel dumps showed me that after

01:01:29,979 --> 01:01:36,729
one jiffy that it happened it would have

01:01:32,949 --> 01:01:39,909
called the callback responsible for the

01:01:36,729 --> 01:01:42,789
synchronization as our CEO right but it

01:01:39,909 --> 01:01:45,219
wouldn't haven't finished that task that

01:01:42,789 --> 01:01:48,130
was blocked right so this is a huge

01:01:45,219 --> 01:01:51,119
study let's move on to the second part

01:01:48,130 --> 01:01:51,119
which is the easier part

01:01:54,880 --> 01:02:03,950
and the second part was basically that

01:02:00,290 --> 01:02:06,800
that remember when I said that the the

01:02:03,950 --> 01:02:08,330
file system notify code was asking so

01:02:06,800 --> 01:02:11,120
you were in user land you would ask

01:02:08,330 --> 01:02:14,360
Colonel about the notification the

01:02:11,120 --> 01:02:15,950
colonel would ask another task inside

01:02:14,360 --> 01:02:18,800
the user land say hey am I allowed to

01:02:15,950 --> 01:02:21,890
ask access this file or not this user

01:02:18,800 --> 01:02:26,510
land would reply that LTP test was

01:02:21,890 --> 01:02:30,200
making 95% of replies to happen but 5%

01:02:26,510 --> 01:02:33,710
of replies not to happen so those 5%

01:02:30,200 --> 01:02:36,580
caused the fire the the tasks to be

01:02:33,710 --> 01:02:39,890
blocked waiting for that response and

01:02:36,580 --> 01:02:42,770
when you shut down the system there was

01:02:39,890 --> 01:02:48,350
another call that caused the race

01:02:42,770 --> 01:02:50,990
condition that was it so that required

01:02:48,350 --> 01:02:58,670
all those investigation and then the

01:02:50,990 --> 01:03:01,010
summary of that was basically this this

01:02:58,670 --> 01:03:05,060
is the summary description and then I

01:03:01,010 --> 01:03:07,670
found a kernel a discussion based on

01:03:05,060 --> 01:03:10,940
this because I knew exactly where to

01:03:07,670 --> 01:03:13,040
find because this this after you learn

01:03:10,940 --> 01:03:15,170
out the research and you find the

01:03:13,040 --> 01:03:17,540
discussion upstream it looks like home

01:03:15,170 --> 01:03:19,220
and how did I didn't I Google wit you

01:03:17,540 --> 01:03:21,020
know it was so easy there was a tribe

01:03:19,220 --> 01:03:23,420
discussion but I didn't know what the

01:03:21,020 --> 01:03:26,270
problem was to Google for right

01:03:23,420 --> 01:03:29,420
I found the discussion I made a back

01:03:26,270 --> 01:03:32,960
port it's 35 patches and then I provided

01:03:29,420 --> 01:03:36,850
a suggestion to Greg Greg said oh this

01:03:32,960 --> 01:03:40,040
is too intrusive let's not do it move on

01:03:36,850 --> 01:03:43,040
but that's how it works right so let's

01:03:40,040 --> 01:03:45,770
say for example Red Hat or Susie or

01:03:43,040 --> 01:03:48,620
canonical once let's fix this interface

01:03:45,770 --> 01:03:50,600
for the kernel 4.9 the patch set is

01:03:48,620 --> 01:03:52,910
there all the discussion is there the

01:03:50,600 --> 01:03:54,980
explanations are there and I learned

01:03:52,910 --> 01:03:58,310
that this particular interface is broken

01:03:54,980 --> 01:04:00,320
4 4 4 & 4 9 and then we skipped the test

01:03:58,310 --> 01:04:03,800
for this particular test and this is

01:04:00,320 --> 01:04:05,260
just one of 15,000 tests that we are

01:04:03,800 --> 01:04:09,680
doing

01:04:05,260 --> 01:04:12,890
okay I'm not gonna extend more this is

01:04:09,680 --> 01:04:17,180
the list of the patches and it's just

01:04:12,890 --> 01:04:19,670
one case okay I hope you liked it and it

01:04:17,180 --> 01:04:24,530
wasn't too deep or anything thank you

01:04:19,670 --> 01:04:31,510
hi do you have any questions no

01:04:24,530 --> 01:04:36,590
questions do you have any questions

01:04:31,510 --> 01:04:38,450
maybe so if you want to play with these

01:04:36,590 --> 01:04:40,580
scripts let me know I can guide you

01:04:38,450 --> 01:04:43,150
through the URLs and how to find the

01:04:40,580 --> 01:04:46,150
scripts and replace the environment okay

01:04:43,150 --> 01:04:46,150
Cheers

01:04:46,880 --> 01:04:51,880

YouTube URL: https://www.youtube.com/watch?v=5EBQsCHIy6c


