Title: YVR18-509: Redox OS - a Rust microkernel on Arm
Publication date: 2018-10-23
Playlist: Linaro Connect Vancouver 2018
Description: 
	For more information about Linaro Connect please visit: https://connect.linaro.org
Full session details and the presentation can be found at https://connect.linaro.org/resources/yvr18/yvr18-509/


Rust is a modern systems programming language that runs blazingly fast, prevents segfaults, and guarantees thread safety. Redox is a Unix-like Operating System written in Rust, aiming to bring the innovations of Rust to a modern microkernel and full set of applications. In this presentation we present the history, intent and design of Redox OS. We will discuss the benefit of using Rust for writing an OS, Redoxâ€™s security model and finally an overview of the work done for porting Redox to Arm.
Captions: 
	00:00:02,120 --> 00:00:07,130
[Music]

00:00:08,360 --> 00:00:13,710
yeah thanks for coming for this talk

00:00:10,500 --> 00:00:16,410
this is a joint talk between me and

00:00:13,710 --> 00:00:19,680
Jeremy solo we're going to be talking

00:00:16,410 --> 00:00:21,570
about the Russ language and the

00:00:19,680 --> 00:00:24,600
implementation of a microkernel stack

00:00:21,570 --> 00:00:26,010
called redox which is Jeremy's maybe the

00:00:24,600 --> 00:00:27,420
way we're going to do this and I'm

00:00:26,010 --> 00:00:29,490
conscious that we don't have a lot of

00:00:27,420 --> 00:00:32,070
time for it the way we're gonna do it is

00:00:29,490 --> 00:00:33,270
I'll do a bit of a background and then

00:00:32,070 --> 00:00:34,559
I'll hand over to Jeremy we'll talk

00:00:33,270 --> 00:00:37,530
about the design and the philosophy of

00:00:34,559 --> 00:00:38,880
redox and then at the end I'll come back

00:00:37,530 --> 00:00:41,790
and talk about some of the work that's

00:00:38,880 --> 00:00:44,910
happened with arm as in redox for arm

00:00:41,790 --> 00:00:46,920
right so yeah so I'm Robin don dava I

00:00:44,910 --> 00:00:48,480
work for arm at Cambridge I'm in the

00:00:46,920 --> 00:00:51,329
systems of the architecture team I'm

00:00:48,480 --> 00:00:52,770
responsible for the safety track the

00:00:51,329 --> 00:00:54,600
charter of this track is to promote the

00:00:52,770 --> 00:00:56,789
take of our IP in safety critical

00:00:54,600 --> 00:01:00,780
domains using open source software as a

00:00:56,789 --> 00:01:02,879
medium the areas I look at internally

00:01:00,780 --> 00:01:04,649
within arm we keep thinking about system

00:01:02,879 --> 00:01:06,329
architecture designs with safety

00:01:04,649 --> 00:01:08,700
extensions so I'm a part of those

00:01:06,329 --> 00:01:10,859
discussions if you've been coming to the

00:01:08,700 --> 00:01:13,319
linear connects for the automotive buffs

00:01:10,859 --> 00:01:15,659
in previous connects I run the around

00:01:13,319 --> 00:01:17,609
above and what I've been trying to tell

00:01:15,659 --> 00:01:19,139
people is that in the safety critical

00:01:17,609 --> 00:01:21,509
domain all the proprietary operating

00:01:19,139 --> 00:01:23,819
systems or micro kernels so micro

00:01:21,509 --> 00:01:26,939
kernels have properties that are safety

00:01:23,819 --> 00:01:28,560
friendly and that's an area of intense

00:01:26,939 --> 00:01:32,880
investigation in the system software

00:01:28,560 --> 00:01:35,490
architecture team particularly found a

00:01:32,880 --> 00:01:36,959
formally verified micro kernels there's

00:01:35,490 --> 00:01:38,310
a lot of work we do with particular

00:01:36,959 --> 00:01:39,899
open-source communities in this space

00:01:38,310 --> 00:01:42,419
and also the University of Cambridge

00:01:39,899 --> 00:01:43,770
I believe that family verified micro

00:01:42,419 --> 00:01:45,389
kernels although not perfect

00:01:43,770 --> 00:01:48,450
significantly raised the power when it

00:01:45,389 --> 00:01:50,219
comes to removing human-in-the-loop test

00:01:48,450 --> 00:01:55,289
validation cycles right and have more

00:01:50,219 --> 00:01:56,880
machine checkable correctness I'm I'm

00:01:55,289 --> 00:01:58,499
working with the AUTOSAR consortium

00:01:56,880 --> 00:02:01,049
AUTOSAR is a consortium that's designed

00:01:58,499 --> 00:02:03,689
to produce interface specifications that

00:02:01,049 --> 00:02:06,359
allow different bits of software to work

00:02:03,689 --> 00:02:07,829
together on cars I first heard of Russ

00:02:06,359 --> 00:02:11,250
the language actually in a discussion

00:02:07,829 --> 00:02:13,079
around AUTOSAR now this talk is actually

00:02:11,250 --> 00:02:13,870
about the last bullet point safety theme

00:02:13,079 --> 00:02:16,480
language is run

00:02:13,870 --> 00:02:18,250
and dueling through this week you might

00:02:16,480 --> 00:02:20,349
have heard that arm has been introducing

00:02:18,250 --> 00:02:22,629
architecture architectural extensions

00:02:20,349 --> 00:02:24,849
for safe secure operation of software

00:02:22,629 --> 00:02:28,420
that's for the large part designed to

00:02:24,849 --> 00:02:30,250
get legacy software running now I would

00:02:28,420 --> 00:02:32,110
like to see what if you start with a

00:02:30,250 --> 00:02:34,269
clean slate for new software and there's

00:02:32,110 --> 00:02:37,030
a lot of new software being written even

00:02:34,269 --> 00:02:38,500
now how can that benefit from some of

00:02:37,030 --> 00:02:40,150
the new languages and the runtimes and

00:02:38,500 --> 00:02:43,150
dueling's which are safety things such

00:02:40,150 --> 00:02:44,680
as rust so I started thinking about okay

00:02:43,150 --> 00:02:46,420
micro kernels on the ARM architecture

00:02:44,680 --> 00:02:48,700
that's on my plate I need to try and

00:02:46,420 --> 00:02:51,129
explore that space and learn more but

00:02:48,700 --> 00:02:52,420
then I said let's also consider the rust

00:02:51,129 --> 00:02:53,980
language and find out whether the

00:02:52,420 --> 00:02:56,739
language has the support it needs for

00:02:53,980 --> 00:02:58,480
running well on arm in the different

00:02:56,739 --> 00:03:01,090
processor profiles cortex I'm cortex are

00:02:58,480 --> 00:03:02,980
and cortex a there are thought like

00:03:01,090 --> 00:03:04,510
since I am doing the micro kernel

00:03:02,980 --> 00:03:05,859
investigations and since I am looking

00:03:04,510 --> 00:03:08,859
and trust the safety language why don't

00:03:05,859 --> 00:03:10,959
I convolve the two and reason about how

00:03:08,859 --> 00:03:14,349
much how good is that from a safety

00:03:10,959 --> 00:03:16,810
standpoint how better is that but then I

00:03:14,349 --> 00:03:18,069
thought the one the one really nice way

00:03:16,810 --> 00:03:19,720
of doing it would be to actually write a

00:03:18,069 --> 00:03:23,109
micro kernel in restraint so that became

00:03:19,720 --> 00:03:25,510
a bit of a focus area now why would I

00:03:23,109 --> 00:03:27,280
want to do that because when I first

00:03:25,510 --> 00:03:29,769
read the the kind of the kool-aid

00:03:27,280 --> 00:03:31,810
description of rust I I didn't believe

00:03:29,769 --> 00:03:33,489
it so I wanted to test the claim that

00:03:31,810 --> 00:03:35,980
rust is a capable systems programming

00:03:33,489 --> 00:03:37,150
language which means that I should be

00:03:35,980 --> 00:03:38,620
able to use it to write bootloaders

00:03:37,150 --> 00:03:40,660
kernels drivers all of that kind of

00:03:38,620 --> 00:03:41,709
stuff but most importantly I wanted to

00:03:40,660 --> 00:03:43,329
do this so that I could have that

00:03:41,709 --> 00:03:44,919
sandbox I needed for my architectural

00:03:43,329 --> 00:03:47,199
explorations in the systems of the

00:03:44,919 --> 00:03:49,030
architecture team which required me to

00:03:47,199 --> 00:03:51,310
have a microkernel so I began writing

00:03:49,030 --> 00:03:53,650
one but thankfully I hadn't gone too far

00:03:51,310 --> 00:03:57,099
when I found redox OS thanks to the Ross

00:03:53,650 --> 00:03:58,540
community that's Jeremy's baby and I'll

00:03:57,099 --> 00:04:00,129
let him speak about it but I think it's

00:03:58,540 --> 00:04:01,629
a little unfair to actually jump into a

00:04:00,129 --> 00:04:03,310
discussion about a microkernel written

00:04:01,629 --> 00:04:04,449
in a new language without actually

00:04:03,310 --> 00:04:06,970
talking about the language a little bit

00:04:04,449 --> 00:04:09,190
now this is hard what I really wanted to

00:04:06,970 --> 00:04:10,720
do was describe the properties that make

00:04:09,190 --> 00:04:13,060
Ross safe and that requires a lot of

00:04:10,720 --> 00:04:16,239
example source code and walking through

00:04:13,060 --> 00:04:18,639
the examples we can't do that in this

00:04:16,239 --> 00:04:20,530
session maybe in a follow up connect we

00:04:18,639 --> 00:04:22,599
can give that more justice so I have

00:04:20,530 --> 00:04:24,410
some xt slides over here that'll give

00:04:22,599 --> 00:04:26,030
you some key words and some

00:04:24,410 --> 00:04:27,650
some guidelines that you can use to

00:04:26,030 --> 00:04:28,970
actually learn about rust in your own

00:04:27,650 --> 00:04:30,950
journey with rust if you choose to go

00:04:28,970 --> 00:04:32,420
down that path so this is what this is

00:04:30,950 --> 00:04:34,010
the blurb on rust languor torgue

00:04:32,420 --> 00:04:35,540
rust is an open-source systems

00:04:34,010 --> 00:04:37,580
programming language that runs blazingly

00:04:35,540 --> 00:04:38,330
fast prevent seg faults and guarantees

00:04:37,580 --> 00:04:41,060
thread safety

00:04:38,330 --> 00:04:43,370
that's the absolutely essential hello

00:04:41,060 --> 00:04:46,880
world globe over there it's a curly

00:04:43,370 --> 00:04:48,290
brace language so mutability right now

00:04:46,880 --> 00:04:51,050
this is the bit that was surprising for

00:04:48,290 --> 00:04:53,030
me and it is also a very essential part

00:04:51,050 --> 00:04:55,400
of the language all data in rust is

00:04:53,030 --> 00:04:57,200
immutable by default right what that

00:04:55,400 --> 00:04:59,570
means is in this example I'm declaring a

00:04:57,200 --> 00:05:01,820
variable called var of type unsigned 32

00:04:59,570 --> 00:05:03,650
in rust you have the name of the way the

00:05:01,820 --> 00:05:05,150
variable first and then the type okay I

00:05:03,650 --> 00:05:06,950
initialize it with zero and then I

00:05:05,150 --> 00:05:09,230
attempt to increment it the compiler

00:05:06,950 --> 00:05:10,640
ranges you can't do that because you

00:05:09,230 --> 00:05:12,410
forgot to declare that variable is

00:05:10,640 --> 00:05:13,940
mutable to start off with now why is

00:05:12,410 --> 00:05:16,480
this a big deal because if you look at

00:05:13,940 --> 00:05:18,590
the CVEs you'll find that a lot of

00:05:16,480 --> 00:05:20,120
concurrent software has problems because

00:05:18,590 --> 00:05:22,490
programmers won't disciplined enough

00:05:20,120 --> 00:05:24,590
about figuring out what shared mutable

00:05:22,490 --> 00:05:27,680
state needs to be shared concurrently

00:05:24,590 --> 00:05:29,150
right in many cases a lot of data that

00:05:27,680 --> 00:05:31,910
does not need to be shared but it's

00:05:29,150 --> 00:05:33,290
exposed because they didn't have didn't

00:05:31,910 --> 00:05:35,330
use Const because why would you all

00:05:33,290 --> 00:05:37,810
right like rust is forcing you to do

00:05:35,330 --> 00:05:40,310
that small thing makes a big difference

00:05:37,810 --> 00:05:42,260
ownership now this is the bedrock upon

00:05:40,310 --> 00:05:45,020
which the entire safety plane rust works

00:05:42,260 --> 00:05:49,280
right there is a notion of ownership

00:05:45,020 --> 00:05:50,750
that's tied to function scopes right you

00:05:49,280 --> 00:05:53,090
have mutable types and you move with

00:05:50,750 --> 00:05:55,730
immutable types you can only have a

00:05:53,090 --> 00:05:57,200
mutable type used in one scope right

00:05:55,730 --> 00:05:58,760
this is the bit that's really hard to

00:05:57,200 --> 00:06:00,500
explain without diagram of its some

00:05:58,760 --> 00:06:01,880
source coding so if there's a function

00:06:00,500 --> 00:06:04,400
and within that function you declare a

00:06:01,880 --> 00:06:06,470
variable that function scope is the

00:06:04,400 --> 00:06:08,120
owner of that variable if you decide to

00:06:06,470 --> 00:06:10,400
make a function call or you decide to

00:06:08,120 --> 00:06:12,170
pass that from that data item as an

00:06:10,400 --> 00:06:13,940
argument to that function call you're

00:06:12,170 --> 00:06:17,000
relinquishing ownership from the calling

00:06:13,940 --> 00:06:18,620
scope to the Kuril scope right at from

00:06:17,000 --> 00:06:20,210
that point onwards if I carry on in my

00:06:18,620 --> 00:06:21,500
scope and terminate nothing happens

00:06:20,210 --> 00:06:23,570
because I'm not the owner of the data

00:06:21,500 --> 00:06:25,700
that was allocated for this this

00:06:23,570 --> 00:06:27,740
particular data item however the

00:06:25,700 --> 00:06:30,230
function that was called since it is the

00:06:27,740 --> 00:06:31,850
owner once its scope ends a rust will

00:06:30,230 --> 00:06:33,320
intervene and actually do automatic the

00:06:31,850 --> 00:06:35,240
allocation of the reserved memory right

00:06:33,320 --> 00:06:38,180
so that happens automatically you can

00:06:35,240 --> 00:06:40,070
have mutable types only in one scope at

00:06:38,180 --> 00:06:41,479
any point in time immutable types you

00:06:40,070 --> 00:06:45,289
can have across multiple scopes because

00:06:41,479 --> 00:06:46,580
that's okay right now you you don't

00:06:45,289 --> 00:06:48,440
always want to copy data back and forth

00:06:46,580 --> 00:06:50,930
so you need a pointer like a reference

00:06:48,440 --> 00:06:52,820
scheme so you have references you can

00:06:50,930 --> 00:06:55,430
pass a reference to a data object into

00:06:52,820 --> 00:06:58,190
another scope but references also have

00:06:55,430 --> 00:07:00,470
mutability and immutability as a concept

00:06:58,190 --> 00:07:02,720
and the same rules apply you can't

00:07:00,470 --> 00:07:05,930
really have more than one mutable

00:07:02,720 --> 00:07:07,789
reference across multiple scopes this

00:07:05,930 --> 00:07:09,410
may sound complicated but actually it's

00:07:07,789 --> 00:07:12,440
blended very well into the language

00:07:09,410 --> 00:07:13,729
right the critical thing is these rules

00:07:12,440 --> 00:07:16,940
are checked by the compiler for you

00:07:13,729 --> 00:07:19,099
right and these rules apply even in

00:07:16,940 --> 00:07:20,720
truly concurrent executions where you

00:07:19,099 --> 00:07:23,449
have threads if you have threads and

00:07:20,720 --> 00:07:25,009
you're talking about the entry point of

00:07:23,449 --> 00:07:26,660
the thread being passed some data or the

00:07:25,009 --> 00:07:28,370
thread making an access to global State

00:07:26,660 --> 00:07:30,430
the same rules apply and it's checked at

00:07:28,370 --> 00:07:32,720
compile time which i think is very cool

00:07:30,430 --> 00:07:35,120
thanks to this you have none of these

00:07:32,720 --> 00:07:37,729
typical classes of errors you don't have

00:07:35,120 --> 00:07:39,800
use after three used before

00:07:37,729 --> 00:07:42,580
initialization null pointer dereference

00:07:39,800 --> 00:07:45,710
double free trusts semantics and syntax

00:07:42,580 --> 00:07:49,250
for cyou to actually service each and

00:07:45,710 --> 00:07:52,250
every expected return type return value

00:07:49,250 --> 00:07:53,720
from a function you can't say that the

00:07:52,250 --> 00:07:55,580
classic programming problem is that oh

00:07:53,720 --> 00:07:58,039
this is the result I expect from this

00:07:55,580 --> 00:08:00,199
function so I'll I'll check for that

00:07:58,039 --> 00:08:02,810
return value and act on it but I forget

00:08:00,199 --> 00:08:03,979
to figure to service and the error

00:08:02,810 --> 00:08:05,780
condition that came back from that

00:08:03,979 --> 00:08:06,289
function potentially you can't do that

00:08:05,780 --> 00:08:09,770
in rust

00:08:06,289 --> 00:08:11,750
it's a compile time error you even have

00:08:09,770 --> 00:08:14,570
at runtime if you over subscribe a

00:08:11,750 --> 00:08:15,979
buffer that's a panic initially I

00:08:14,570 --> 00:08:17,810
thought why can't you just deal with

00:08:15,979 --> 00:08:18,889
that at compile time that's harder to do

00:08:17,810 --> 00:08:20,630
and that has performance implications

00:08:18,889 --> 00:08:23,210
will do it at runtime so why is it

00:08:20,630 --> 00:08:24,830
better than C or C++ because in those

00:08:23,210 --> 00:08:26,630
cases if you over subscribe a buffer

00:08:24,830 --> 00:08:28,250
something bad will happen because you

00:08:26,630 --> 00:08:30,470
overrode the stack and you'll never know

00:08:28,250 --> 00:08:32,060
unless you actually hit it right rust

00:08:30,470 --> 00:08:33,909
will consistently give you a panic at

00:08:32,060 --> 00:08:38,719
that point in time which is way more

00:08:33,909 --> 00:08:40,550
consistent type with clarity simple

00:08:38,719 --> 00:08:42,380
thing I personally in my professional

00:08:40,550 --> 00:08:44,420
career have been hit with written by

00:08:42,380 --> 00:08:45,980
this one CC 99

00:08:44,420 --> 00:08:48,589
they are ambiguous they don't really

00:08:45,980 --> 00:08:50,329
tell you what is the type width for some

00:08:48,589 --> 00:08:52,000
of the types Long's in particular are

00:08:50,329 --> 00:08:54,280
the 32 bit 64 bit on the operating

00:08:52,000 --> 00:08:56,200
architecture don't know the type names

00:08:54,280 --> 00:09:00,910
and rust encode the type size no

00:08:56,200 --> 00:09:02,710
arguments very clear threads are a

00:09:00,910 --> 00:09:05,230
first-class language item unlike C or

00:09:02,710 --> 00:09:08,250
C++ in C++ this case you need to resort

00:09:05,230 --> 00:09:10,600
to boost or with C you need to resort to

00:09:08,250 --> 00:09:13,720
some P threads implementation that you

00:09:10,600 --> 00:09:15,400
call into there's a thread keyword and

00:09:13,720 --> 00:09:16,600
there is a thread library part of the

00:09:15,400 --> 00:09:19,030
standard library threads are a

00:09:16,600 --> 00:09:21,490
first-class item this is a very simple

00:09:19,030 --> 00:09:23,830
example where there is a mutable key

00:09:21,490 --> 00:09:26,620
point on mute mutable a vector called

00:09:23,830 --> 00:09:29,350
children it's empty I use it to store

00:09:26,620 --> 00:09:30,790
the handles that I get from spawning

00:09:29,350 --> 00:09:33,460
threads that's the standard way of

00:09:30,790 --> 00:09:36,040
spawning threads stood thread spawn you

00:09:33,460 --> 00:09:37,780
give it a closure a closure is like the

00:09:36,040 --> 00:09:40,720
entry point of the function you want a

00:09:37,780 --> 00:09:42,370
thread to execute and once the threads

00:09:40,720 --> 00:09:44,770
have been spawned you just iterate over

00:09:42,370 --> 00:09:48,480
the children vector and join them up

00:09:44,770 --> 00:09:48,480
this is a contrived simple example right

00:09:53,070 --> 00:10:01,390
yes yes yes so a very rich standard

00:09:59,200 --> 00:10:04,540
library all of the stuff that I would I

00:10:01,390 --> 00:10:06,640
would associate with kind of interpreted

00:10:04,540 --> 00:10:08,589
languages like Python and Ruby right so

00:10:06,640 --> 00:10:11,350
all of those things are actually part of

00:10:08,589 --> 00:10:13,330
a system programming language is a

00:10:11,350 --> 00:10:15,490
compiled language right which is quite

00:10:13,330 --> 00:10:17,410
refreshing in my opinion mapsets linked

00:10:15,490 --> 00:10:19,540
lists dictionaries all their platform

00:10:17,410 --> 00:10:21,790
abstraction sockets tcp threads shared

00:10:19,540 --> 00:10:23,830
memory types and the really cool bits

00:10:21,790 --> 00:10:25,690
are the functional language bits like

00:10:23,830 --> 00:10:29,860
closures iterators generators pattern

00:10:25,690 --> 00:10:31,300
matching idiomatic rust code uses a lot

00:10:29,860 --> 00:10:34,050
of the functional properties it just

00:10:31,300 --> 00:10:36,310
makes for cleaner code in my opinion

00:10:34,050 --> 00:10:37,930
this is another really good one right so

00:10:36,310 --> 00:10:40,150
you can't forget to take a look for

00:10:37,930 --> 00:10:42,480
mutable shared state because the data

00:10:40,150 --> 00:10:44,440
that you intend accessing with

00:10:42,480 --> 00:10:47,350
synchronization primitive is owned by

00:10:44,440 --> 00:10:48,550
the synchronization perimeter if you

00:10:47,350 --> 00:10:50,650
forget to use the synchronization

00:10:48,550 --> 00:10:52,720
primitive the compiler won't compile a

00:10:50,650 --> 00:10:55,240
program right that's it simple

00:10:52,720 --> 00:10:58,150
straightforward yet another way to

00:10:55,240 --> 00:11:00,070
prevent bugs now of course if you want

00:10:58,150 --> 00:11:02,050
intentionally to violate the safeguards

00:11:00,070 --> 00:11:03,430
provided by the compiler so a lot of the

00:11:02,050 --> 00:11:04,320
times you need to do that you have a

00:11:03,430 --> 00:11:06,510
take

00:11:04,320 --> 00:11:08,430
there is a unsafe keyboard announcing

00:11:06,510 --> 00:11:09,810
block you put your code inside an unsafe

00:11:08,430 --> 00:11:12,990
block the compiler won't do all of its

00:11:09,810 --> 00:11:14,399
magic if you're doing operating system

00:11:12,990 --> 00:11:16,170
development and you want to write to a

00:11:14,399 --> 00:11:17,910
system control register you want to use

00:11:16,170 --> 00:11:20,610
inline assembly that's an example of an

00:11:17,910 --> 00:11:22,649
unsafe operation you put it inside a man

00:11:20,610 --> 00:11:24,120
safe block the first thought that came

00:11:22,649 --> 00:11:25,529
into my mind was oh my god now have to

00:11:24,120 --> 00:11:27,390
write unsafe or like most of my

00:11:25,529 --> 00:11:28,470
operating system for back-end for a

00:11:27,390 --> 00:11:31,620
particular architecture is going to be

00:11:28,470 --> 00:11:33,600
unsafe code but really this is all about

00:11:31,620 --> 00:11:35,370
labeling clearly to the compiler the

00:11:33,600 --> 00:11:37,709
bits that are quite likely to be the

00:11:35,370 --> 00:11:39,570
root of problems and that means it makes

00:11:37,709 --> 00:11:46,320
a static analyzers job really

00:11:39,570 --> 00:11:49,580
straightforward atomic types Atomics are

00:11:46,320 --> 00:11:52,110
supported by the language they form the

00:11:49,580 --> 00:11:53,459
basically the building blocks for

00:11:52,110 --> 00:11:56,610
communication between threads and

00:11:53,459 --> 00:11:58,050
concurrent types like C++ 11 you have

00:11:56,610 --> 00:11:59,820
the ability to express the desired

00:11:58,050 --> 00:12:01,830
memory consistency for store loads in

00:11:59,820 --> 00:12:04,050
stores to Atomics which is also kind of

00:12:01,830 --> 00:12:06,480
cool russ doesn't claim to have a

00:12:04,050 --> 00:12:08,880
perfect story over here it rides on top

00:12:06,480 --> 00:12:12,690
of the memory consistency architecture

00:12:08,880 --> 00:12:15,149
and expectations that LLVM has right so

00:12:12,690 --> 00:12:17,850
it's ass correct as LLVM does it that's

00:12:15,149 --> 00:12:20,459
about it Marc's looking at me I'm going

00:12:17,850 --> 00:12:21,720
to ignore him now but we can come back

00:12:20,459 --> 00:12:23,700
to this over here basically there's a

00:12:21,720 --> 00:12:25,680
variable that's declared as an atomic

00:12:23,700 --> 00:12:27,990
new size it's wrapped up and treated as

00:12:25,680 --> 00:12:29,430
a spin lock and you're trying to do a

00:12:27,990 --> 00:12:31,500
store operation to claim the spin lock

00:12:29,430 --> 00:12:33,270
or in this case clear you can specify

00:12:31,500 --> 00:12:37,529
the the kind of ordering you want for

00:12:33,270 --> 00:12:38,850
this again for when you're writing

00:12:37,529 --> 00:12:40,260
operating system code when you want to

00:12:38,850 --> 00:12:45,510
do like a schedule or something of this

00:12:40,260 --> 00:12:46,529
sort concurrent rust programs do tend to

00:12:45,510 --> 00:12:48,600
be faster than the C and C++

00:12:46,529 --> 00:12:51,180
counterparts this is because of the

00:12:48,600 --> 00:12:52,709
compile time checks the ownership checks

00:12:51,180 --> 00:12:54,180
they remove a lot of the boilerplate

00:12:52,709 --> 00:12:56,120
that you traditionally have that

00:12:54,180 --> 00:12:58,980
concurrent programs where you have to

00:12:56,120 --> 00:13:01,440
explicitly test for correctness is a

00:12:58,980 --> 00:13:03,779
pointer valid or not do I have the right

00:13:01,440 --> 00:13:05,430
lock etc etc since that is gone

00:13:03,779 --> 00:13:07,079
you end up having faster programs and

00:13:05,430 --> 00:13:08,880
this is just a contrived example I put

00:13:07,079 --> 00:13:11,550
over here but this is a really nice

00:13:08,880 --> 00:13:13,199
program called rip crap which I use try

00:13:11,550 --> 00:13:16,090
it you won't go back to crap it's super

00:13:13,199 --> 00:13:17,980
fast and the codes very clean too

00:13:16,090 --> 00:13:20,560
so now I'm gonna hand over to Jeremy

00:13:17,980 --> 00:13:24,550
who's gonna tell us about three dogs yep

00:13:20,560 --> 00:13:26,560
so Robin set up the language but I'd

00:13:24,550 --> 00:13:30,240
like to set up the other foundations of

00:13:26,560 --> 00:13:33,250
redox beyond rust we also have UNIX

00:13:30,240 --> 00:13:35,560
Canoe Linux some other projects that

00:13:33,250 --> 00:13:37,480
were really interesting then I'm going

00:13:35,560 --> 00:13:39,010
to go into redox at the high level and

00:13:37,480 --> 00:13:41,620
then we're gonna specify the roadmap

00:13:39,010 --> 00:13:44,320
what kind of community model we have the

00:13:41,620 --> 00:13:45,940
microkernel user space and I'm gonna go

00:13:44,320 --> 00:13:47,890
through an example driver now it's gonna

00:13:45,940 --> 00:13:53,140
show a live demo but I probably won't be

00:13:47,890 --> 00:13:54,790
able to do that because of time I'll

00:13:53,140 --> 00:13:57,820
have to use it okay that's fine

00:13:54,790 --> 00:13:59,710
so UNIX the name derives from multics

00:13:57,820 --> 00:14:02,500
which is an earlier multitasking

00:13:59,710 --> 00:14:06,130
operating system UNIX is multi-user and

00:14:02,500 --> 00:14:09,640
multitasking development began in 1969

00:14:06,130 --> 00:14:12,190
it has UNIX philosophy which covers many

00:14:09,640 --> 00:14:14,380
different things but modular philosophy

00:14:12,190 --> 00:14:17,410
is one of those things so do one thing

00:14:14,380 --> 00:14:20,650
and do it well this comes back for redux

00:14:17,410 --> 00:14:23,010
in in very strong force has a simple

00:14:20,650 --> 00:14:26,650
file system with the unified namespace

00:14:23,010 --> 00:14:28,990
it has simple file system it has simple

00:14:26,650 --> 00:14:31,930
system calls most of which are based on

00:14:28,990 --> 00:14:34,390
file system calls everything is a file

00:14:31,930 --> 00:14:36,820
to the kernel and all of the calls are

00:14:34,390 --> 00:14:38,560
related to file handles has a powerful

00:14:36,820 --> 00:14:41,050
shell where most programs can be

00:14:38,560 --> 00:14:43,330
scripted and it was a pioneer in

00:14:41,050 --> 00:14:45,400
portable operating systems it was

00:14:43,330 --> 00:14:47,980
written in C so it was able to be ported

00:14:45,400 --> 00:14:51,250
to many different platforms in many ways

00:14:47,980 --> 00:14:53,320
it's divine it was the starting point

00:14:51,250 --> 00:14:56,080
for many of the operating systems we see

00:14:53,320 --> 00:14:57,880
today including Windows which utilizes

00:14:56,080 --> 00:15:01,870
the C programming language that was

00:14:57,880 --> 00:15:04,480
actually invented for use in UNIX the

00:15:01,870 --> 00:15:07,410
Creator is 75 years old and has the most

00:15:04,480 --> 00:15:10,270
majestic beard you could ever ever find

00:15:07,410 --> 00:15:12,270
gheh knew the name originally meant

00:15:10,270 --> 00:15:15,880
nothing it's the name of the animal

00:15:12,270 --> 00:15:18,970
capitalized but Richard Stallman came up

00:15:15,880 --> 00:15:21,970
with a backronym good news not Unix well

00:15:18,970 --> 00:15:23,630
canoe is Unix canoe is a free software

00:15:21,970 --> 00:15:26,720
implementation of the

00:15:23,630 --> 00:15:31,100
unikz components it was developed by the

00:15:26,720 --> 00:15:33,560
Free Software Foundation in 1984 they

00:15:31,100 --> 00:15:35,420
wrote most of it in C and they also

00:15:33,560 --> 00:15:37,130
developed critical free software

00:15:35,420 --> 00:15:41,480
licenses when they were developing canoe

00:15:37,130 --> 00:15:43,730
such as the GPL they developed a

00:15:41,480 --> 00:15:47,930
microkernel called canoe heard that has

00:15:43,730 --> 00:15:49,430
gone almost nowhere and they they also

00:15:47,930 --> 00:15:51,980
developed a very large number of

00:15:49,430 --> 00:15:54,290
projects we're talking GCC been you

00:15:51,980 --> 00:15:57,980
delay or you Dalls things that are very

00:15:54,290 --> 00:16:01,190
common across across all free software

00:15:57,980 --> 00:16:04,190
operating systems usually canoe is

00:16:01,190 --> 00:16:07,960
paired with Linux the Creator is 65

00:16:04,190 --> 00:16:11,840
years old and has a pretty okay beard

00:16:07,960 --> 00:16:13,640
now Linux everyone here of course knows

00:16:11,840 --> 00:16:15,680
Linux because arm and Linux go

00:16:13,640 --> 00:16:18,770
hand-in-hand everywhere they go they go

00:16:15,680 --> 00:16:21,830
together they go they go to mobile they

00:16:18,770 --> 00:16:24,890
go to embedded they go to IOT wherever

00:16:21,830 --> 00:16:27,410
Linux is arm is as well

00:16:24,890 --> 00:16:31,730
Linux was created by Linus Torvalds in

00:16:27,410 --> 00:16:33,890
1991 the name comes from his name mixed

00:16:31,730 --> 00:16:37,010
with UNIX which originally he thought

00:16:33,890 --> 00:16:39,650
was too egotistical when he uploaded it

00:16:37,010 --> 00:16:41,840
for distribution the person running the

00:16:39,650 --> 00:16:43,340
server renamed it from what he had

00:16:41,840 --> 00:16:48,950
originally wanted to use which was

00:16:43,340 --> 00:16:51,860
freaks fre ax to Linux which i think is

00:16:48,950 --> 00:16:54,050
a much better name it's written in C it

00:16:51,860 --> 00:16:56,450
is a free unix-like kernel

00:16:54,050 --> 00:16:59,720
implementation it's the de facto kernel

00:16:56,450 --> 00:17:02,180
for new user space and it has completely

00:16:59,720 --> 00:17:04,910
dominated all computing markets except

00:17:02,180 --> 00:17:08,209
for the desktop now which is something

00:17:04,910 --> 00:17:11,150
we're working on the Creator is 48 years

00:17:08,209 --> 00:17:14,660
old and has a pretty appalling beard

00:17:11,150 --> 00:17:16,790
compared to the last two people now

00:17:14,660 --> 00:17:20,600
honorable mentions some of these are

00:17:16,790 --> 00:17:23,089
actually more influential to redux in

00:17:20,600 --> 00:17:25,970
the past three but the past three are

00:17:23,089 --> 00:17:29,330
much bigger projects so I'd like to go

00:17:25,970 --> 00:17:31,700
through FreeBSD capsicum was an

00:17:29,330 --> 00:17:35,060
important reference for our capabilities

00:17:31,700 --> 00:17:37,550
based design MINIX 3 was also another

00:17:35,060 --> 00:17:39,770
important reference they have kernel

00:17:37,550 --> 00:17:41,960
facilitate memory-mapped IPC which is

00:17:39,770 --> 00:17:43,760
something we utilize as well they have a

00:17:41,960 --> 00:17:45,710
reincarnation server that we're thinking

00:17:43,760 --> 00:17:50,330
about implementing on our owns on our

00:17:45,710 --> 00:17:52,520
own to restart failed drivers net bsd

00:17:50,330 --> 00:17:55,580
has a package management system that

00:17:52,520 --> 00:17:58,040
that we used as our base for our own

00:17:55,580 --> 00:18:00,590
package management system and they also

00:17:58,040 --> 00:18:03,950
had this idea of a rump kernel which

00:18:00,590 --> 00:18:05,390
would facilitate user space drivers that

00:18:03,950 --> 00:18:07,400
could then be recompiled for a

00:18:05,390 --> 00:18:11,270
monolithic kernel and could actually be

00:18:07,400 --> 00:18:14,060
ported between kernels plan nine is one

00:18:11,270 --> 00:18:16,790
of the biggest influences it's listed

00:18:14,060 --> 00:18:19,190
almost last but what plan nine had was a

00:18:16,790 --> 00:18:21,050
unified namespace where you could find

00:18:19,190 --> 00:18:23,690
everything including networking which

00:18:21,050 --> 00:18:26,030
was something that Linux and and BSD and

00:18:23,690 --> 00:18:29,120
other operating systems continued to do

00:18:26,030 --> 00:18:30,650
through separate system calls plan 9

00:18:29,120 --> 00:18:32,900
started to do through the unified

00:18:30,650 --> 00:18:35,690
namespace which is something that then

00:18:32,900 --> 00:18:38,570
influenced our design and then smart OS

00:18:35,690 --> 00:18:40,330
they have a concept of zones that really

00:18:38,570 --> 00:18:43,060
went into what we wanted to do with

00:18:40,330 --> 00:18:47,000
namespaces which I'll talk about later

00:18:43,060 --> 00:18:50,480
ok so after going through that let me go

00:18:47,000 --> 00:18:54,350
through all the 200 300 400 different

00:18:50,480 --> 00:18:57,200
UNIX things have shown up if I were to

00:18:54,350 --> 00:18:59,030
show this in full scale I believe I

00:18:57,200 --> 00:19:00,920
would require probably two dozen

00:18:59,030 --> 00:19:04,310
projectors wrapping around the whole

00:19:00,920 --> 00:19:05,690
room the point is that there is a large

00:19:04,310 --> 00:19:08,660
amount of content out there to pull

00:19:05,690 --> 00:19:11,000
ideas from and there is a very rich

00:19:08,660 --> 00:19:13,850
history of UNIX and unix-like operating

00:19:11,000 --> 00:19:16,640
systems and that all leads to what we

00:19:13,850 --> 00:19:17,410
have today which is the person standing

00:19:16,640 --> 00:19:21,740
in front of you

00:19:17,410 --> 00:19:23,240
redox so that was a very long-winded

00:19:21,740 --> 00:19:25,810
thing and I'm probably gonna have to

00:19:23,240 --> 00:19:25,810
drink some water

00:19:28,000 --> 00:19:33,910
what is redox so the name comes from the

00:19:31,910 --> 00:19:37,100
chemical reaction reduction oxidation

00:19:33,910 --> 00:19:40,010
rust is a redox reaction and it kind of

00:19:37,100 --> 00:19:43,030
sounds like UNIX development began in

00:19:40,010 --> 00:19:45,470
2015 I was originally wanting to do

00:19:43,030 --> 00:19:47,390
anything in rust because I just learned

00:19:45,470 --> 00:19:48,690
about the language and what I found was

00:19:47,390 --> 00:19:51,990
a lack of

00:19:48,690 --> 00:19:54,510
of things at a kernel level so I started

00:19:51,990 --> 00:19:57,750
writing what was originally a monolithic

00:19:54,510 --> 00:19:59,550
kernel and then I realized hey you know

00:19:57,750 --> 00:20:01,350
what would be really easy would be

00:19:59,550 --> 00:20:05,790
cutting out pieces from this kernel and

00:20:01,350 --> 00:20:08,610
moving them into user space so from

00:20:05,790 --> 00:20:10,560
there it grew and it's an MIT licensed

00:20:08,610 --> 00:20:13,260
it

00:20:10,560 --> 00:20:17,520
the majority of components in redox are

00:20:13,260 --> 00:20:19,170
MIT licensed summer GPL those are

00:20:17,520 --> 00:20:22,050
usually things that we've ported things

00:20:19,170 --> 00:20:24,630
from canoe things like that it utilizes

00:20:22,050 --> 00:20:27,630
a microkernel all drivers and services

00:20:24,630 --> 00:20:29,810
are in user space it when we say

00:20:27,630 --> 00:20:32,580
everything is a file we really mean it

00:20:29,810 --> 00:20:35,250
it keeps UNIX system calls but it

00:20:32,580 --> 00:20:38,010
reduces the set significantly so what

00:20:35,250 --> 00:20:40,050
that means is that in redox the majority

00:20:38,010 --> 00:20:42,420
of operations go through file system

00:20:40,050 --> 00:20:45,810
calls like open read write seek and

00:20:42,420 --> 00:20:48,600
closed and we also have memory mapping

00:20:45,810 --> 00:20:51,350
to improve performance we use rust

00:20:48,600 --> 00:20:54,200
throughout the entire project to reduce

00:20:51,350 --> 00:20:56,940
vulnerabilities and improve reliability

00:20:54,200 --> 00:20:59,210
we have a rust rewrite of most UNIX

00:20:56,940 --> 00:21:02,780
components and we provide a complete

00:20:59,210 --> 00:21:08,270
POSIX compatible C library for for

00:21:02,780 --> 00:21:12,420
legacy applications and I'm 26 years old

00:21:08,270 --> 00:21:14,970
so what is our roadmap well initially I

00:21:12,420 --> 00:21:18,200
wanted to replace what was running on my

00:21:14,970 --> 00:21:21,750
own laptop and and start running redox

00:21:18,200 --> 00:21:23,430
that hasn't gone very well but we'll see

00:21:21,750 --> 00:21:25,620
if and we'll see where that goes the

00:21:23,430 --> 00:21:27,990
desktop is a really hard target because

00:21:25,620 --> 00:21:30,180
you think about hundreds of different

00:21:27,990 --> 00:21:33,240
peripherals and many of them require

00:21:30,180 --> 00:21:37,620
custom drivers so we set our sights for

00:21:33,240 --> 00:21:39,450
a much more practical target which was

00:21:37,620 --> 00:21:42,600
embedded systems that's our current

00:21:39,450 --> 00:21:45,570
focus what we believe that we can do is

00:21:42,600 --> 00:21:48,240
is have a really world-class operating

00:21:45,570 --> 00:21:50,280
system for IOT for embedded devices and

00:21:48,240 --> 00:21:52,230
for servers and we believe we can do

00:21:50,280 --> 00:21:55,320
that through a set of very simple steps

00:21:52,230 --> 00:21:58,740
we improve the current drivers we

00:21:55,320 --> 00:22:01,050
implement more drivers we develop an

00:21:58,740 --> 00:22:02,160
opt-in watchdog for programs which will

00:22:01,050 --> 00:22:05,190
be able to implement the

00:22:02,160 --> 00:22:08,250
MINIX reincarnation server and we

00:22:05,190 --> 00:22:09,990
improve SMP scheduling and after we do

00:22:08,250 --> 00:22:14,400
that we have pretty much all that's

00:22:09,990 --> 00:22:17,850
required the redox Community Development

00:22:14,400 --> 00:22:19,770
is done entirely on git lab a real-time

00:22:17,850 --> 00:22:22,290
discussion is done on our chat server or

00:22:19,770 --> 00:22:24,000
Madame au server other discussion we

00:22:22,290 --> 00:22:27,960
have a forum across those three

00:22:24,000 --> 00:22:30,360
different platforms we have a we use the

00:22:27,960 --> 00:22:32,100
rest code of conduct we have a

00:22:30,360 --> 00:22:33,750
contributing guide for people who want

00:22:32,100 --> 00:22:35,280
to contribute and all of that

00:22:33,750 --> 00:22:41,850
information can be found on the website

00:22:35,280 --> 00:22:43,590
redox - OS org okay finally geez

00:22:41,850 --> 00:22:46,470
I wanted to get to the meat and this is

00:22:43,590 --> 00:22:49,560
what I really wanted to show you so the

00:22:46,470 --> 00:22:51,330
the critical element of redox I believe

00:22:49,560 --> 00:22:54,090
the thing that expresses its personality

00:22:51,330 --> 00:22:56,700
most is the microkernel the microkernel

00:22:54,090 --> 00:22:59,100
is written in rust it has very high

00:22:56,700 --> 00:23:01,050
reliability and some of that comes from

00:22:59,100 --> 00:23:03,990
rust some of that comes from the reality

00:23:01,050 --> 00:23:05,910
of being a microkernel writing in and

00:23:03,990 --> 00:23:09,090
rust allows us to do some compile time

00:23:05,910 --> 00:23:11,100
verification not to the level that s el4

00:23:09,090 --> 00:23:13,520
has but we do have a kernel that

00:23:11,100 --> 00:23:16,460
implements more things than SEO for has

00:23:13,520 --> 00:23:19,290
so it is a little bit larger as well it

00:23:16,460 --> 00:23:21,240
introduces a concept of kernel or user

00:23:19,290 --> 00:23:23,760
space implement file systems called

00:23:21,240 --> 00:23:26,490
schemes so what this means is that you

00:23:23,760 --> 00:23:31,320
have file systems like the network file

00:23:26,490 --> 00:23:35,340
system and the that's interesting the

00:23:31,320 --> 00:23:37,170
network file system TCP UDP implemented

00:23:35,340 --> 00:23:38,790
by one application then we have a disk

00:23:37,170 --> 00:23:41,880
driver that might implement a file

00:23:38,790 --> 00:23:45,090
system actually present a disk or a set

00:23:41,880 --> 00:23:46,710
of disks we have a file system driver

00:23:45,090 --> 00:23:48,570
that presents what you would

00:23:46,710 --> 00:23:51,630
traditionally think of as a file system

00:23:48,570 --> 00:23:53,550
and we have things for IPC that are also

00:23:51,630 --> 00:23:55,350
done through the file system memory

00:23:53,550 --> 00:23:57,120
mapping is done through the file system

00:23:55,350 --> 00:23:59,280
IR queues are handled through the file

00:23:57,120 --> 00:24:01,980
system everything goes through the

00:23:59,280 --> 00:24:04,170
unified file system and because of this

00:24:01,980 --> 00:24:05,610
we limit system calls to only those

00:24:04,170 --> 00:24:08,010
required to interact with the file

00:24:05,610 --> 00:24:10,380
system and some additional ones for

00:24:08,010 --> 00:24:12,960
managing processes so we have open

00:24:10,380 --> 00:24:16,080
readwrite close we have memory mapping

00:24:12,960 --> 00:24:20,039
and what this allows us to do is

00:24:16,080 --> 00:24:23,549
construct a very concise security model

00:24:20,039 --> 00:24:26,990
around a user space we provide

00:24:23,549 --> 00:24:29,610
primitives for drivers those are also

00:24:26,990 --> 00:24:30,960
those things like physical memory access

00:24:29,610 --> 00:24:33,690
and interrupt handling those are also

00:24:30,960 --> 00:24:35,850
done through the file system we support

00:24:33,690 --> 00:24:38,880
containerization through namespaces so

00:24:35,850 --> 00:24:40,559
because every operation is done through

00:24:38,880 --> 00:24:42,809
the file system the only thing you have

00:24:40,559 --> 00:24:45,720
to do to do OS level virtualization is

00:24:42,809 --> 00:24:49,169
to filter the calls that application can

00:24:45,720 --> 00:24:51,000
make into that unified namespace so if

00:24:49,169 --> 00:24:53,580
you want to write a firewall the only

00:24:51,000 --> 00:24:56,210
thing you have to do is intercept the

00:24:53,580 --> 00:24:59,039
the calls going out from an application

00:24:56,210 --> 00:25:02,460
drop the system calls with an error like

00:24:59,039 --> 00:25:05,909
a access or a perm that you don't want

00:25:02,460 --> 00:25:07,889
to reach the the network and pass

00:25:05,909 --> 00:25:10,559
through the ones that you do allow this

00:25:07,889 --> 00:25:12,570
allows to routes for example in jails

00:25:10,559 --> 00:25:14,309
which are other operating system

00:25:12,570 --> 00:25:17,840
concepts to be built on top of

00:25:14,309 --> 00:25:20,039
namespaces very quickly and easily

00:25:17,840 --> 00:25:22,769
processes can also enter a capability

00:25:20,039 --> 00:25:26,549
mode by entering the null namespace what

00:25:22,769 --> 00:25:29,100
this means is that the system disallows

00:25:26,549 --> 00:25:31,309
that process from accessing any of the

00:25:29,100 --> 00:25:35,519
namespace that it hasn't already opened

00:25:31,309 --> 00:25:38,039
this this prevents a process from

00:25:35,519 --> 00:25:43,200
gaining capabilities that it did not

00:25:38,039 --> 00:25:45,840
have at lunch the kernel is 20,000 lines

00:25:43,200 --> 00:25:48,500
of code which is large in comparison to

00:25:45,840 --> 00:25:50,610
other micro kernels but we believe that

00:25:48,500 --> 00:25:54,120
5000 of it could be moved into user

00:25:50,610 --> 00:25:56,970
space that's a CPI code and additional

00:25:54,120 --> 00:25:59,100
code might also move into user space it

00:25:56,970 --> 00:26:00,899
may already be feature complete this is

00:25:59,100 --> 00:26:03,990
contingent on what we find as we

00:26:00,899 --> 00:26:06,510
investigate as we port more applications

00:26:03,990 --> 00:26:09,630
things like that it does appear to be

00:26:06,510 --> 00:26:12,389
feature complete this is what we can get

00:26:09,630 --> 00:26:14,720
today so we have disk drivers file

00:26:12,389 --> 00:26:17,909
systems network drivers network stack

00:26:14,720 --> 00:26:19,470
graphics drivers graphics stack pretty

00:26:17,909 --> 00:26:21,720
much everything else you would expect

00:26:19,470 --> 00:26:23,130
from an operating system it's not as

00:26:21,720 --> 00:26:26,220
mature as what you would find with the

00:26:23,130 --> 00:26:28,620
Lynx desktop environment but it does

00:26:26,220 --> 00:26:30,029
demonstrate the power of the microkernel

00:26:28,620 --> 00:26:32,849
and the ability to employ

00:26:30,029 --> 00:26:34,139
a user space and give you an idea of

00:26:32,849 --> 00:26:36,840
what could be implemented in the future

00:26:34,139 --> 00:26:39,389
so here we have an example of running a

00:26:36,840 --> 00:26:41,279
graphical environment we have I like the

00:26:39,389 --> 00:26:43,769
background so much that I only launched

00:26:41,279 --> 00:26:45,929
one thing which was stupid but there's a

00:26:43,769 --> 00:26:47,789
calculator running we have things like

00:26:45,929 --> 00:26:51,509
that we have a simple browser called net

00:26:47,789 --> 00:26:53,309
surf that uses SDL actually - for

00:26:51,509 --> 00:26:57,269
graphics output we haven't ported

00:26:53,309 --> 00:27:00,269
toolkits like GT K + + + QT but those

00:26:57,269 --> 00:27:01,590
will come eventually how does this look

00:27:00,269 --> 00:27:04,499
at a systems level

00:27:01,590 --> 00:27:06,929
well the redock this is a little hard to

00:27:04,499 --> 00:27:09,450
see at the top we have the redox kernel

00:27:06,929 --> 00:27:12,539
the redox kernel creates some of its own

00:27:09,450 --> 00:27:14,849
schemes over here it launches the anit

00:27:12,539 --> 00:27:18,299
process and it loads a number of user

00:27:14,849 --> 00:27:21,509
space binaries from the anit filesystem

00:27:18,299 --> 00:27:23,999
so the majority of these things are done

00:27:21,509 --> 00:27:26,789
in user space then the initial

00:27:23,999 --> 00:27:29,519
filesystem loads the disk drivers and

00:27:26,789 --> 00:27:33,149
filesystem driver after that it jumps

00:27:29,519 --> 00:27:36,450
into loading drivers from the filesystem

00:27:33,149 --> 00:27:41,729
those drivers include things like random

00:27:36,450 --> 00:27:43,950
numbers PT wise audio and USB and

00:27:41,729 --> 00:27:47,039
networking then the network stack is

00:27:43,950 --> 00:27:49,919
loaded and then finally we have this

00:27:47,039 --> 00:27:53,759
which is the graphical environment being

00:27:49,919 --> 00:27:55,739
loaded so now I'm going to go through an

00:27:53,759 --> 00:27:58,409
example driver and this is extremely

00:27:55,739 --> 00:28:02,009
technical but at the same time I think

00:27:58,409 --> 00:28:04,529
it has some kind of readable elegance to

00:28:02,009 --> 00:28:14,290
it provided that you already know a

00:28:04,529 --> 00:28:16,920
little bit about rust just click it yep

00:28:14,290 --> 00:28:16,920
yep

00:28:23,250 --> 00:28:28,679
so we have a number of boilerplate items

00:28:25,679 --> 00:28:32,039
that we have to go through at the top we

00:28:28,679 --> 00:28:34,380
have some imports but here's the real

00:28:32,039 --> 00:28:36,980
meet the entry point of in rust is the

00:28:34,380 --> 00:28:40,200
main function it can return a result

00:28:36,980 --> 00:28:43,289
which may come from a failure of one of

00:28:40,200 --> 00:28:45,990
these calls the first thing we do is we

00:28:43,289 --> 00:28:47,850
we create a new file system by actually

00:28:45,990 --> 00:28:50,549
creating a file inside of what's called

00:28:47,850 --> 00:28:53,100
the route scheme the route scheme is an

00:28:50,549 --> 00:28:54,299
index of all of the file systems so if

00:28:53,100 --> 00:28:55,980
you want to create a new one it makes

00:28:54,299 --> 00:28:57,750
sense you create a file inside of the

00:28:55,980 --> 00:29:00,059
route scheme and then you start reading

00:28:57,750 --> 00:29:03,120
system calls from that file and writing

00:29:00,059 --> 00:29:06,510
responses to it next we're gonna start

00:29:03,120 --> 00:29:10,309
reading our queues we read from the

00:29:06,510 --> 00:29:13,159
keyboard irq on x86 which is number one

00:29:10,309 --> 00:29:15,780
we set these files up as non-blocking

00:29:13,159 --> 00:29:18,270
we're going to create an event queue

00:29:15,780 --> 00:29:20,220
which is opening from the event scheme

00:29:18,270 --> 00:29:21,780
and then after we've opened all the

00:29:20,220 --> 00:29:24,659
files we want we're going to enter into

00:29:21,780 --> 00:29:28,549
the null namespace so this disallows

00:29:24,659 --> 00:29:31,110
this program from opening any more files

00:29:28,549 --> 00:29:33,030
now we add those two files that we

00:29:31,110 --> 00:29:36,120
created for the scheme and irq to the

00:29:33,030 --> 00:29:37,320
event queue we set up a scheme handler

00:29:36,120 --> 00:29:40,830
that we'll talk about later

00:29:37,320 --> 00:29:43,440
and we create a list of blocked system

00:29:40,830 --> 00:29:45,419
calls these are calls from other

00:29:43,440 --> 00:29:50,190
processes that we have not returned a

00:29:45,419 --> 00:29:51,840
request to yet so this is is you have an

00:29:50,190 --> 00:29:54,960
option of doing asynchronous or

00:29:51,840 --> 00:29:59,070
synchronous i/o using the scheme

00:29:54,960 --> 00:30:01,260
interface now we loop on events every

00:29:59,070 --> 00:30:03,510
time we get an event if it came from the

00:30:01,260 --> 00:30:05,039
scheme we're going to read a packet from

00:30:03,510 --> 00:30:07,919
the scheme and that packet is going to

00:30:05,039 --> 00:30:11,480
include information about what system

00:30:07,919 --> 00:30:17,039
call was executed by the process on your

00:30:11,480 --> 00:30:18,870
file system and if it was an irq file

00:30:17,039 --> 00:30:21,570
that we had to read we're going to read

00:30:18,870 --> 00:30:23,580
in our queue counter and if we created

00:30:21,570 --> 00:30:25,500
if we cause that irq we're going to

00:30:23,580 --> 00:30:28,020
acknowledge the our queue this allows

00:30:25,500 --> 00:30:29,760
multiple drivers to share an irq which

00:30:28,020 --> 00:30:33,059
is important an important part of the

00:30:29,760 --> 00:30:35,340
system and then for every remaining

00:30:33,059 --> 00:30:36,280
blocked packet we're going to continue

00:30:35,340 --> 00:30:38,470
to loop on

00:30:36,280 --> 00:30:42,250
whether or not those blocked packets can

00:30:38,470 --> 00:30:45,250
be unblocked so this is all done in in

00:30:42,250 --> 00:30:47,140
the the logic for blocking and

00:30:45,250 --> 00:30:51,700
unblocking is all done inside of the

00:30:47,140 --> 00:30:59,890
scheme so I'm gonna go up one directory

00:30:51,700 --> 00:31:05,130
and check that out so we have a trait in

00:30:59,890 --> 00:31:07,600
in rust a trait is kind of similar to

00:31:05,130 --> 00:31:10,660
well it's a list of functions that you

00:31:07,600 --> 00:31:12,970
have to implement for a specific type so

00:31:10,660 --> 00:31:14,950
here we have to implement open we're

00:31:12,970 --> 00:31:18,100
going to allow any path to come in to

00:31:14,950 --> 00:31:19,870
open and for every every call to open

00:31:18,100 --> 00:31:22,360
recreate a new file handle and return

00:31:19,870 --> 00:31:24,640
its identifier that identifier will then

00:31:22,360 --> 00:31:27,490
be used in the future calls to the file

00:31:24,640 --> 00:31:29,650
system this file system is extremely

00:31:27,490 --> 00:31:32,950
simple it only implements one system

00:31:29,650 --> 00:31:36,580
call read so every time a process

00:31:32,950 --> 00:31:38,320
attempts to read if the number of irqs

00:31:36,580 --> 00:31:40,570
that we have received has increased

00:31:38,320 --> 00:31:42,550
since the creation of the handle we're

00:31:40,570 --> 00:31:46,150
going to write a hash to that file

00:31:42,550 --> 00:31:48,670
descriptor and this is you you'll notice

00:31:46,150 --> 00:31:52,570
that this looks very similar to the read

00:31:48,670 --> 00:31:54,520
function in C you have a file identifier

00:31:52,570 --> 00:31:56,620
and you have some buffer that you're

00:31:54,520 --> 00:31:59,050
going to write the information into this

00:31:56,620 --> 00:32:01,330
is by design we wanted to have a very

00:31:59,050 --> 00:32:05,710
high level interface even though we're

00:32:01,330 --> 00:32:07,870
creating a microkernel and finally we

00:32:05,710 --> 00:32:11,050
have implementations for F sync and

00:32:07,870 --> 00:32:13,540
closed a sync is a no op in this scheme

00:32:11,050 --> 00:32:15,700
and close is something that removes the

00:32:13,540 --> 00:32:20,470
handle so at this point I was going to

00:32:15,700 --> 00:32:23,710
demonstrate the the scheme in reality

00:32:20,470 --> 00:32:26,730
but it's not possible to do that with my

00:32:23,710 --> 00:32:26,730
laptop at the moment

00:32:29,140 --> 00:32:36,610
I think you just have to hit the X up

00:32:33,340 --> 00:32:38,820
there in the corner if you go up to the

00:32:36,610 --> 00:32:38,820
top

00:32:44,930 --> 00:32:52,010
30 minutes of closing applications was

00:32:47,640 --> 00:32:52,010
all we required to have things ready

00:33:03,179 --> 00:33:11,929
slide suck google.com yeah let's go view

00:33:12,000 --> 00:33:14,990
that's the right one

00:33:17,220 --> 00:33:20,120
I'm sorry

00:33:28,929 --> 00:33:31,589
okay

00:33:38,119 --> 00:33:45,510
all right really what's coming home with

00:33:43,099 --> 00:33:49,440
your system

00:33:45,510 --> 00:33:52,519
yeah turns out disabling the graphics

00:33:49,440 --> 00:33:56,970
card on your laptop is not a good idea

00:33:52,519 --> 00:33:59,250
yep all right so Redux runs on real

00:33:56,970 --> 00:34:01,380
hardware I was gonna create a better

00:33:59,250 --> 00:34:04,440
picture than this having all the system

00:34:01,380 --> 00:34:07,980
76 line up running redox but I didn't

00:34:04,440 --> 00:34:10,940
have time what we support is graphics

00:34:07,980 --> 00:34:13,260
through through EFI or through the BIOS

00:34:10,940 --> 00:34:16,139
this gives us a frame buffer that's

00:34:13,260 --> 00:34:17,639
typically native resolution we support

00:34:16,139 --> 00:34:20,520
networking through a number of different

00:34:17,639 --> 00:34:23,190
devices through the e 1000 and and

00:34:20,520 --> 00:34:26,730
Realtek 81-68 and and a number of other

00:34:23,190 --> 00:34:30,540
devices that are fairly common and we

00:34:26,730 --> 00:34:32,490
support audio through Intel HD HD a so

00:34:30,540 --> 00:34:35,460
this allows us to present a pretty

00:34:32,490 --> 00:34:38,899
complete user space for a desktop

00:34:35,460 --> 00:34:41,820
environment on most systems and a a

00:34:38,899 --> 00:34:44,730
pretty complete user space for most

00:34:41,820 --> 00:34:46,109
systems that are virtualized because we

00:34:44,730 --> 00:34:49,290
have support for all the hardware in

00:34:46,109 --> 00:34:50,550
common virtual machines so after running

00:34:49,290 --> 00:34:53,490
through this I'm going to hand it back

00:34:50,550 --> 00:34:56,790
to back to Robin for the rest of his

00:34:53,490 --> 00:34:59,720
presentation thanks I hope this is the

00:34:56,790 --> 00:35:02,130
right slide tech will know soon enough

00:34:59,720 --> 00:35:04,710
yeah so as I said I started trying to

00:35:02,130 --> 00:35:08,640
figure out how to put this into my

00:35:04,710 --> 00:35:10,589
environment on arm as it stands today

00:35:08,640 --> 00:35:13,470
targets at 64 execution state

00:35:10,589 --> 00:35:15,089
exclusively there are three platform

00:35:13,470 --> 00:35:16,650
targets that are being developed in

00:35:15,089 --> 00:35:18,839
parallel the core work is happening on

00:35:16,650 --> 00:35:21,300
the frame you grab me system a at 64

00:35:18,839 --> 00:35:23,040
with the word machine we have students

00:35:21,300 --> 00:35:24,569
who are using a high key 620 and a high

00:35:23,040 --> 00:35:27,710
key 960 power to actually do the

00:35:24,569 --> 00:35:30,030
follow-up work bringing up on silicon so

00:35:27,710 --> 00:35:32,069
just wanted to provide a very quick view

00:35:30,030 --> 00:35:34,920
on how I kind of went ahead with the

00:35:32,069 --> 00:35:37,650
sporting exercise it took me about like

00:35:34,920 --> 00:35:39,180
up this is done my spare time so I spent

00:35:37,650 --> 00:35:41,550
like about two months just learning the

00:35:39,180 --> 00:35:44,520
vocabulary speaking to the rust and the

00:35:41,550 --> 00:35:47,069
redox guys and then I published a

00:35:44,520 --> 00:35:49,109
document on the on the gate lab on the

00:35:47,069 --> 00:35:50,940
redox or a skate lab one of which was my

00:35:49,109 --> 00:35:53,010
take on the sequence I wanted to follow

00:35:50,940 --> 00:35:54,660
to do to actually go ahead with the port

00:35:53,010 --> 00:35:57,420
so that's supporting the core redox

00:35:54,660 --> 00:35:58,740
kernel to arm in at 64 outline and after

00:35:57,420 --> 00:36:00,150
a while I followed it up with a compare

00:35:58,740 --> 00:36:02,670
in document which is working with the

00:36:00,150 --> 00:36:04,800
ah-64 portal redox that tries to

00:36:02,670 --> 00:36:07,470
describe how to get to the current state

00:36:04,800 --> 00:36:08,880
of play it's fairly involving I should

00:36:07,470 --> 00:36:10,830
add at this point because you have to

00:36:08,880 --> 00:36:13,260
get the compiler tool chains you have to

00:36:10,830 --> 00:36:15,180
create the boot flow and this is one

00:36:13,260 --> 00:36:17,240
area where I could do with more help

00:36:15,180 --> 00:36:21,960
over time to try and make it simple

00:36:17,240 --> 00:36:24,000
so the first thing I needed was the rust

00:36:21,960 --> 00:36:27,240
compiler and LLVM did not have support

00:36:24,000 --> 00:36:29,460
for a new OS triplet for at 64 redock so

00:36:27,240 --> 00:36:31,680
I had to add support for that triplet I

00:36:29,460 --> 00:36:33,980
then run into a problem because you have

00:36:31,680 --> 00:36:37,110
a thread local decorator and redox and

00:36:33,980 --> 00:36:39,750
in rust actually and redox uses thread

00:36:37,110 --> 00:36:42,210
locals for per CPU data objects in the

00:36:39,750 --> 00:36:43,980
kernel side but I could not get a VM to

00:36:42,210 --> 00:36:46,530
emit the right instruction it always

00:36:43,980 --> 00:36:50,160
emitted DPI dr underscore al zero

00:36:46,530 --> 00:36:52,770
references whereas for the kernel an EDL

00:36:50,160 --> 00:36:54,300
one I have to figure out how to do that

00:36:52,770 --> 00:36:57,480
I got some help from the community for

00:36:54,300 --> 00:36:59,100
that and that works now just a simple

00:36:57,480 --> 00:37:00,950
triplet supposed to be noodles once you

00:36:59,100 --> 00:37:03,810
get your head around binutils

00:37:00,950 --> 00:37:06,240
system call venues for AR 64 in new Lib

00:37:03,810 --> 00:37:08,280
when I was working with this there was

00:37:06,240 --> 00:37:11,450
no real Ipsy I mean it was kind of in

00:37:08,280 --> 00:37:14,340
progress real Ipsy is the C library that

00:37:11,450 --> 00:37:16,380
Jeremy and company have produced which

00:37:14,340 --> 00:37:18,270
is written in rust so I'm going to move

00:37:16,380 --> 00:37:23,100
away from new Lib to real epsy at some

00:37:18,270 --> 00:37:25,130
point then I hit a bug with gdb somehow

00:37:23,100 --> 00:37:27,300
gdb just stopped supporting debugging

00:37:25,130 --> 00:37:29,100
basically kernel code anything that has

00:37:27,300 --> 00:37:32,940
virtual addresses that are in the TTP

00:37:29,100 --> 00:37:34,920
our bond range but again Lonardo help to

00:37:32,940 --> 00:37:35,570
that I reported the problems been fixed

00:37:34,920 --> 00:37:39,600
now

00:37:35,570 --> 00:37:41,130
so my debug flow is basically for the

00:37:39,600 --> 00:37:44,190
core work it's all on chromium so I'm

00:37:41,130 --> 00:37:46,560
using Chrome you happily has like a word

00:37:44,190 --> 00:37:50,100
machine kind of target like Remy Oh harm

00:37:46,560 --> 00:37:53,940
64 def config I modified the build Lou

00:37:50,100 --> 00:37:56,430
and redox to actually give me an a at 64

00:37:53,940 --> 00:37:58,050
build there are some dependent libraries

00:37:56,430 --> 00:38:03,930
that had to be modified to introduce AR

00:37:58,050 --> 00:38:06,630
64 in Linus and bits etc ultimately I

00:38:03,930 --> 00:38:10,160
use you boot as the BIOS for Remy system

00:38:06,630 --> 00:38:12,440
at 64 I use TFTP and kernel

00:38:10,160 --> 00:38:15,550
script you boot scripts to actually

00:38:12,440 --> 00:38:18,350
fetch a file system and launch the girl

00:38:15,550 --> 00:38:21,020
and after the gme bugs were resolved

00:38:18,350 --> 00:38:22,820
like what kind of debug the kernel using

00:38:21,020 --> 00:38:25,070
gdb and grammys gdb stop

00:38:22,820 --> 00:38:26,690
so reporting the kernel itself I did

00:38:25,070 --> 00:38:29,930
some early unit code which does pretty

00:38:26,690 --> 00:38:31,310
classic stuff il-2 2 l1 handoff should

00:38:29,930 --> 00:38:33,620
that be required

00:38:31,310 --> 00:38:35,030
I needed a diagnostic UART so early page

00:38:33,620 --> 00:38:36,860
table setup for that and also for

00:38:35,030 --> 00:38:40,850
mapping in the kernel itself on Sammy

00:38:36,860 --> 00:38:42,740
was enabled I rely on DT be exclusively

00:38:40,850 --> 00:38:47,000
device freeze this might change because

00:38:42,740 --> 00:38:48,650
redox does have EFI support basically

00:38:47,000 --> 00:38:50,450
the device tree is provided by you boot

00:38:48,650 --> 00:38:53,450
and relate to the kernel I create some

00:38:50,450 --> 00:38:55,100
mappings for that there's a specific

00:38:53,450 --> 00:38:57,950
kernel code that I then start writing

00:38:55,100 --> 00:39:01,090
page tables descriptors access control

00:38:57,950 --> 00:39:03,350
through those tables and descriptors and

00:39:01,090 --> 00:39:05,920
I'd heard of recursive paging a while

00:39:03,350 --> 00:39:08,030
back I remember bugging mark about that

00:39:05,920 --> 00:39:09,800
somebody else was trying to do recursive

00:39:08,030 --> 00:39:11,420
paging only at 64 I thought here's my

00:39:09,800 --> 00:39:13,130
chance to see whether I can try to use

00:39:11,420 --> 00:39:15,110
it it's different

00:39:13,130 --> 00:39:16,850
I know Joelle asked me to he's here he's

00:39:15,110 --> 00:39:18,140
not you know okay general from Google

00:39:16,850 --> 00:39:19,430
wanted to know more about it don't have

00:39:18,140 --> 00:39:21,020
time for that now but even come and

00:39:19,430 --> 00:39:22,820
speak to me then it was context

00:39:21,020 --> 00:39:24,140
management code elf parsing loading

00:39:22,820 --> 00:39:25,760
logic was already available in the

00:39:24,140 --> 00:39:28,430
generic bits I just had to do some

00:39:25,760 --> 00:39:30,380
modifications for at 64 and then the

00:39:28,430 --> 00:39:33,080
meat of the fork clone exact context

00:39:30,380 --> 00:39:34,610
switching signal dispatch creating init

00:39:33,080 --> 00:39:36,560
context and launching that and then the

00:39:34,610 --> 00:39:41,810
syscall exception entry decode dispatch

00:39:36,560 --> 00:39:44,120
stuff some in kernel driver stubs to

00:39:41,810 --> 00:39:47,330
support timers diagnostic you arts and

00:39:44,120 --> 00:39:49,510
geek v2 user space drivers they had a

00:39:47,330 --> 00:39:51,800
PCI driver already in redox so I just

00:39:49,510 --> 00:39:53,630
took that and made it work with a very

00:39:51,800 --> 00:39:55,460
simple creamy OE cam model so it's not

00:39:53,630 --> 00:39:57,230
really a very fleshed out PCI driver

00:39:55,460 --> 00:40:00,230
it's actually not a driver at all it's

00:39:57,230 --> 00:40:02,870
just some accessor but then I got the

00:40:00,230 --> 00:40:06,110
HCI driver in redox to actually work

00:40:02,870 --> 00:40:08,690
with creme use it's a control obits and

00:40:06,110 --> 00:40:12,770
that way I have SATA disk access for the

00:40:08,690 --> 00:40:17,390
root filesystem and it's redox ifs

00:40:12,770 --> 00:40:18,920
which is filesystem the redox has so I'm

00:40:17,390 --> 00:40:21,260
currently bringing up multi user login

00:40:18,920 --> 00:40:23,500
and shell single users kind of working

00:40:21,260 --> 00:40:24,850
and after that

00:40:23,500 --> 00:40:26,410
I've done some hacks with device trees

00:40:24,850 --> 00:40:30,460
but one member of the community is it a

00:40:26,410 --> 00:40:32,320
scheme like how schemes the way Jeremy

00:40:30,460 --> 00:40:33,850
described them a device tree scheme

00:40:32,320 --> 00:40:35,560
would make my job a lot easier

00:40:33,850 --> 00:40:39,370
I'll just convert all the drivers to use

00:40:35,560 --> 00:40:41,530
this scheme I can just ask it for do ask

00:40:39,370 --> 00:40:43,360
it use some semantic expressions to get

00:40:41,530 --> 00:40:46,900
information about any drivers device

00:40:43,360 --> 00:40:49,180
trade data that I needed frame buffer

00:40:46,900 --> 00:40:51,700
driver are very simple at the CREM you

00:40:49,180 --> 00:40:53,140
level but we do have an open item which

00:40:51,700 --> 00:40:54,910
is an intel frame of a driver for

00:40:53,140 --> 00:40:57,640
someone to do I'll see how I can

00:40:54,910 --> 00:40:59,560
leverage some of that work Heike 620 99

00:40:57,640 --> 00:41:01,450
60 bringing up is happening in parallel

00:40:59,560 --> 00:41:04,180
slower than I'd like but it is happening

00:41:01,450 --> 00:41:05,590
and I mean to do a big documentation

00:41:04,180 --> 00:41:08,950
update on gate lab because the current

00:41:05,590 --> 00:41:11,140
documentation is about a month old SMP

00:41:08,950 --> 00:41:14,230
support SMP support mechanics are there

00:41:11,140 --> 00:41:16,000
in redox but there are some problems

00:41:14,230 --> 00:41:18,490
with that and they definitely haven't

00:41:16,000 --> 00:41:20,440
been enabled on a on a at 64 so I'll try

00:41:18,490 --> 00:41:22,660
and work on that in my spare time and

00:41:20,440 --> 00:41:24,760
then there's parity that'll get me at

00:41:22,660 --> 00:41:31,270
parity with the x86 64 port basically

00:41:24,760 --> 00:41:33,660
right so that's it so we have five

00:41:31,270 --> 00:41:33,660
minutes for questions

00:41:40,150 --> 00:41:49,540
I have two questions the first one that

00:41:46,360 --> 00:41:53,050
your survey is the niacin series what

00:41:49,540 --> 00:41:56,110
are the nice ins MIT okay so also we

00:41:53,050 --> 00:41:58,960
need to follow up with the MIT yeah okay

00:41:56,110 --> 00:42:02,050
the second question that actually now I

00:41:58,960 --> 00:42:04,750
can see that almost the memory modern in

00:42:02,050 --> 00:42:08,560
the related of details seems and I can

00:42:04,750 --> 00:42:10,540
need to hide into the compiler right

00:42:08,560 --> 00:42:14,130
because there have many many the memory

00:42:10,540 --> 00:42:16,960
really the operations seem like to be

00:42:14,130 --> 00:42:29,160
controlled by the compiler for example

00:42:16,960 --> 00:42:29,160
aerarium so but you don't have to use it

00:42:30,930 --> 00:42:37,780
is that they have some optimization for

00:42:34,210 --> 00:42:42,670
example for the memory optimization for

00:42:37,780 --> 00:42:45,760
example speed no really not a quest only

00:42:42,670 --> 00:42:48,850
nice was such kind of the memory mode

00:42:45,760 --> 00:42:52,950
only related the shooting compiler aware

00:42:48,850 --> 00:42:55,300
that or a lot and so basically rust is

00:42:52,950 --> 00:42:55,480
explicitly at this point in time coupled

00:42:55,300 --> 00:42:59,440
with

00:42:55,480 --> 00:43:02,950
LLVM LLVM supports different target

00:42:59,440 --> 00:43:04,210
packets different architectures just

00:43:02,950 --> 00:43:06,430
like any other compiler there is a

00:43:04,210 --> 00:43:08,140
there's an expectation in terms of the

00:43:06,430 --> 00:43:12,670
memory model and LLVM has an expectation

00:43:08,140 --> 00:43:15,190
for me at 64 yeah I mean if you if you

00:43:12,670 --> 00:43:16,990
if you want to use the Atomics and if

00:43:15,190 --> 00:43:20,230
you want to use the Atomics using the

00:43:16,990 --> 00:43:22,840
kind of high level rust primitives for

00:43:20,230 --> 00:43:24,190
expressing the consistency LLVM will

00:43:22,840 --> 00:43:26,500
translate that into the appropriate

00:43:24,190 --> 00:43:28,660
thing for you at 64 but you don't have

00:43:26,500 --> 00:43:31,240
to use that I mean if you have very

00:43:28,660 --> 00:43:33,430
specific concerns you can just use

00:43:31,240 --> 00:43:35,140
unsafe blocks with inline assembly to

00:43:33,430 --> 00:43:37,560
use the barriers of choice that kind of

00:43:35,140 --> 00:43:37,560
stuff right

00:43:42,550 --> 00:43:50,440
yes as as you say but all drivers on

00:43:46,750 --> 00:43:52,420
printed in userspace so if you need if

00:43:50,440 --> 00:43:53,170
you have a platform at needs real-time

00:43:52,420 --> 00:43:55,720
guarantees

00:43:53,170 --> 00:43:57,520
how can you enforce it if it's in

00:43:55,720 --> 00:44:00,310
userspace because you have latency I

00:43:57,520 --> 00:44:02,380
guess between switching a different

00:44:00,310 --> 00:44:04,090
exception level etc this is something

00:44:02,380 --> 00:44:05,980
that we were thinking about working on

00:44:04,090 --> 00:44:08,680
with the watchdog timer and that would

00:44:05,980 --> 00:44:11,560
be the ability to specify exactly when a

00:44:08,680 --> 00:44:12,880
when a driver would have to respond or

00:44:11,560 --> 00:44:15,460
else it would break the rules of the

00:44:12,880 --> 00:44:17,620
system and potentially be restarted yeah

00:44:15,460 --> 00:44:20,500
so getting into the real-time space we

00:44:17,620 --> 00:44:22,570
will probably probably involve some

00:44:20,500 --> 00:44:24,580
rules around what user space can do and

00:44:22,570 --> 00:44:27,730
may involve a separate spin of the

00:44:24,580 --> 00:44:31,540
kernel for real-time okay

00:44:27,730 --> 00:44:33,250
additionally what kind of scheduling

00:44:31,540 --> 00:44:37,780
policies do you support right down

00:44:33,250 --> 00:44:41,560
microcode currently for SP particularly

00:44:37,780 --> 00:44:43,690
its naive and its round-robin so working

00:44:41,560 --> 00:44:46,300
on the SP scheduler is one of our

00:44:43,690 --> 00:44:51,370
highest priorities at this point okay

00:44:46,300 --> 00:44:54,430
and last question whether right now use

00:44:51,370 --> 00:44:58,330
it as a normal voice is very in the

00:44:54,430 --> 00:45:01,000
future a possibility of in making the

00:44:58,330 --> 00:45:04,990
microkernel being can use a hypervisor

00:45:01,000 --> 00:45:07,300
in the future this is this is something

00:45:04,990 --> 00:45:10,720
that's up for debate and the answers

00:45:07,300 --> 00:45:13,090
probably so right now we we support a

00:45:10,720 --> 00:45:15,310
level of OS level virtualization that I

00:45:13,090 --> 00:45:17,260
I strongly believe that most

00:45:15,310 --> 00:45:20,550
applications would not need to use a

00:45:17,260 --> 00:45:23,560
hypervisor with the current redox model

00:45:20,550 --> 00:45:26,310
but I do believe it would be possible to

00:45:23,560 --> 00:45:26,310
support that yes

00:45:32,920 --> 00:45:38,050
they're just two things only Atomics

00:45:35,500 --> 00:45:40,510
front earlier you Robin mentioned that

00:45:38,050 --> 00:45:43,420
the rest language follows whatever LLVM

00:45:40,510 --> 00:45:44,980
happens to implement so what semantics

00:45:43,420 --> 00:45:46,410
is that targeting is that targeting like

00:45:44,980 --> 00:45:51,340
the c11

00:45:46,410 --> 00:45:53,260
yeah it's similar to similar so is there

00:45:51,340 --> 00:45:54,490
a well-defined semantics for those Ross

00:45:53,260 --> 00:45:55,390
primitives or is that something that's

00:45:54,490 --> 00:46:09,970
not settled yet

00:45:55,390 --> 00:46:16,000
they're well-defined whatever is the the

00:46:09,970 --> 00:46:18,610
guarantees that GCC and company like

00:46:16,000 --> 00:46:21,190
that have in LLVM has emulated that and

00:46:18,610 --> 00:46:23,020
that's what is exported to rust but I

00:46:21,190 --> 00:46:24,940
must confess this is not an area that

00:46:23,020 --> 00:46:27,340
I've actually dwelt upon a lot right and

00:46:24,940 --> 00:46:28,840
I'd actually like to get some insights

00:46:27,340 --> 00:46:30,070
from you because you understand the

00:46:28,840 --> 00:46:33,700
atomic space really well it's a

00:46:30,070 --> 00:46:35,590
discussion I'll take offline one of the

00:46:33,700 --> 00:46:37,840
other things we find at least in Linux

00:46:35,590 --> 00:46:39,130
kernel is really the painful area that

00:46:37,840 --> 00:46:41,200
language doesn't give us any help with

00:46:39,130 --> 00:46:44,830
is all sorts of asynchronous behaviors

00:46:41,200 --> 00:46:46,540
from the CPU like TLB fetches a cache

00:46:44,830 --> 00:46:49,000
prefetching eviction and so on yeah is

00:46:46,540 --> 00:46:50,950
that any attempt in redox eraser and

00:46:49,000 --> 00:46:52,690
rust to try and model that kind of thing

00:46:50,950 --> 00:46:55,840
from a resource ownership point of view

00:46:52,690 --> 00:46:57,550
absolutely so our page table is done at

00:46:55,840 --> 00:47:00,340
a pretty high level in terms of it

00:46:57,550 --> 00:47:02,740
abstraction robin implemented it on arm

00:47:00,340 --> 00:47:04,690
and he may have some comments on paging

00:47:02,740 --> 00:47:06,910
in the reacts colonel yeah well paging

00:47:04,690 --> 00:47:09,640
is fine but when it comes to the kind of

00:47:06,910 --> 00:47:11,020
micro architecture little hazards and

00:47:09,640 --> 00:47:12,880
that he's talking about we simply

00:47:11,020 --> 00:47:14,890
haven't had a chance to explore the

00:47:12,880 --> 00:47:16,900
problem space with three dogs yeah and I

00:47:14,890 --> 00:47:19,780
had a chat about this and I did tell him

00:47:16,900 --> 00:47:20,890
he'll be dragons because he has tried to

00:47:19,780 --> 00:47:23,620
come up with a high level abstraction

00:47:20,890 --> 00:47:25,570
for the kind of TLB and cache

00:47:23,620 --> 00:47:27,850
maintenance required when you're doing

00:47:25,570 --> 00:47:30,430
things like tearing it on page table etc

00:47:27,850 --> 00:47:31,870
etc it may work but will only really

00:47:30,430 --> 00:47:33,400
know once we get the sale you can bring

00:47:31,870 --> 00:47:35,650
up going that's when the dragons will

00:47:33,400 --> 00:47:37,750
come yeah and getting the scheduler a

00:47:35,650 --> 00:47:40,270
little bit better for SMP would help a

00:47:37,750 --> 00:47:42,160
lot too is a lot of those TLB shoot down

00:47:40,270 --> 00:47:46,000
scenarios really only happened

00:47:42,160 --> 00:47:47,260
when you have a second processor we find

00:47:46,000 --> 00:47:49,210
that look to these actually happen on a

00:47:47,260 --> 00:47:53,920
single processor well and because of

00:47:49,210 --> 00:47:55,930
those issues for sure okay yeah yeah I

00:47:53,920 --> 00:47:57,160
think so they can bring up as though I'm

00:47:55,930 --> 00:48:00,190
reading for that actually because I

00:47:57,160 --> 00:48:01,869
think that'll that'll mean we'll have to

00:48:00,190 --> 00:48:04,950
rethink a fair number of things around

00:48:01,869 --> 00:48:06,910
these some of these assumptions but yeah

00:48:04,950 --> 00:48:08,740
you mentioned running under the Quinn

00:48:06,910 --> 00:48:10,900
you so if you run under Quinn you in TCG

00:48:08,740 --> 00:48:19,180
mode or chrome you in actual virtualized

00:48:10,900 --> 00:48:24,010
k vm k vm for x86 and g4 not 64 yeah yes

00:48:19,180 --> 00:48:26,250
yes yes that's part of the plan anything

00:48:24,010 --> 00:48:26,250
else

00:48:27,480 --> 00:48:34,720
another question that I saw this right

00:48:30,460 --> 00:48:38,859
that's that the don't handle from the

00:48:34,720 --> 00:48:40,690
exception narrow to to exception one so

00:48:38,859 --> 00:48:42,460
this means that the quraan your space of

00:48:40,690 --> 00:48:47,049
actually running in the year two and

00:48:42,460 --> 00:48:48,970
your space to run a year one I didn't

00:48:47,049 --> 00:48:50,829
want to assume that the bootloader

00:48:48,970 --> 00:48:52,660
environment has put me at real one

00:48:50,829 --> 00:48:55,710
I just wanted to ensure that I can

00:48:52,660 --> 00:48:55,710
that's it really

00:48:59,020 --> 00:49:06,560
okay cool thank you sorry yeah question

00:49:04,520 --> 00:49:09,620
for your statement of another Rasta

00:49:06,560 --> 00:49:11,720
language I saw you'll say that you could

00:49:09,620 --> 00:49:14,990
make the Ross application of faster than

00:49:11,720 --> 00:49:19,070
C he's actually much much for that

00:49:14,990 --> 00:49:22,070
there's a clarification so concurrent

00:49:19,070 --> 00:49:23,360
Russ programs are almost certainly fast

00:49:22,070 --> 00:49:26,150
in the sea and there is a very good

00:49:23,360 --> 00:49:29,060
example of this which is rip grep which

00:49:26,150 --> 00:49:31,400
he mentions in the slides rip grep is

00:49:29,060 --> 00:49:34,130
able to beat out silver searcher and

00:49:31,400 --> 00:49:37,160
canoe grep and a lot of other text

00:49:34,130 --> 00:49:39,110
searching algorithms programs even

00:49:37,160 --> 00:49:42,440
though it uses the same searching rules

00:49:39,110 --> 00:49:44,750
so it uses it you can use pcre which

00:49:42,440 --> 00:49:47,720
those other programs use to search

00:49:44,750 --> 00:49:49,790
through it rip rep outperforms all of

00:49:47,720 --> 00:49:53,960
them and the way it does that is by

00:49:49,790 --> 00:49:55,610
having concurrency but also having what

00:49:53,960 --> 00:49:58,010
Russ developers have described as

00:49:55,610 --> 00:50:00,470
fearless concurrency where you're able

00:49:58,010 --> 00:50:02,990
to do certain things without having to

00:50:00,470 --> 00:50:07,580
worry about the possibility of deadlocks

00:50:02,990 --> 00:50:10,370
and and and data races provided that you

00:50:07,580 --> 00:50:13,220
follow the safe programming standard I

00:50:10,370 --> 00:50:15,230
see so what it'd be a master with the

00:50:13,220 --> 00:50:18,470
raster programming language standard

00:50:15,230 --> 00:50:22,100
that there might be a ye he avoid the

00:50:18,470 --> 00:50:24,350
log a lot of cases right oh I see right

00:50:22,100 --> 00:50:26,270
yeah that's not good so theoretically of

00:50:24,350 --> 00:50:28,970
course the C program could have could

00:50:26,270 --> 00:50:32,120
reach that same level of performance but

00:50:28,970 --> 00:50:34,160
in a practical sense it's difficult for

00:50:32,120 --> 00:50:37,220
a programmer to express that without

00:50:34,160 --> 00:50:40,040
about being afraid of of things crashing

00:50:37,220 --> 00:50:42,350
yeah oh by the way I think you guys now

00:50:40,040 --> 00:50:45,080
support the Huawei heike then I say they

00:50:42,350 --> 00:50:49,130
born that's right yeah sometime tomorrow

00:50:45,080 --> 00:50:51,770
night actually yeah sure did you say be

00:50:49,130 --> 00:50:54,440
supported well we're working on it I

00:50:51,770 --> 00:50:56,630
mean over promise and under deliver

00:50:54,440 --> 00:50:58,010
right work is underway

00:50:56,630 --> 00:51:00,080
there's a student who's trying to bring

00:50:58,010 --> 00:51:03,260
up the stuff that we're doing on

00:51:00,080 --> 00:51:06,020
simulators on right Heike 960 and I

00:51:03,260 --> 00:51:07,790
could 620 but to set expectations we're

00:51:06,020 --> 00:51:11,800
still a far way off from being a parity

00:51:07,790 --> 00:51:11,800
on what he's done with x86 64 on

00:51:15,410 --> 00:51:20,460
yeah well economists are you can start

00:51:18,060 --> 00:51:22,380
some micro benchmark I think we're shows

00:51:20,460 --> 00:51:24,810
up like yeah yeah that'd be interesting

00:51:22,380 --> 00:51:26,130
so we have some tooling internally a

00:51:24,810 --> 00:51:28,290
down where we do a benchmark

00:51:26,130 --> 00:51:30,660
benchmarking of this sort and I'm very

00:51:28,290 --> 00:51:32,610
keen on seeing how the numbers stack up

00:51:30,660 --> 00:51:36,560
with some synthetic benchmarks at least

00:51:32,610 --> 00:51:36,560
between x86 64 now

00:51:37,870 --> 00:51:44,370
[Applause]

00:51:39,370 --> 00:51:44,370

YouTube URL: https://www.youtube.com/watch?v=G4VlHzyKZeE


