Title: YVR18-416:Using perf On Arm platforms
Publication date: 2018-09-28
Playlist: Linaro Connect Vancouver 2018
Description: 
	Perf is a powerful tool for profiling and debugging for Linux kernel. In addition to being the main window into the performance counters, it also provides support for different backends including both software and hardware tracing.

In this session we will offer an introduction for perf support for the Arm platform, with particular focus on the how perf can exploit the PMU hardware counters and Coresight hardware features. We will reinforce this with practical examples of tracing and profiling using the perf tool on 96boards Hikey boards.
Captions: 
	00:00:02,110 --> 00:00:07,120
[Music]

00:00:09,630 --> 00:00:16,379
in this session we will talk about the

00:00:12,180 --> 00:00:19,220
using perv on platforms how many are yen

00:00:16,379 --> 00:00:22,410
this materials in what color with my

00:00:19,220 --> 00:00:24,449
leader Daniel Thompson we are working

00:00:22,410 --> 00:00:27,869
for the nano support and a solution

00:00:24,449 --> 00:00:30,029
engineering team so this is introduction

00:00:27,869 --> 00:00:32,489
for this session so properly the

00:00:30,029 --> 00:00:34,470
performance analysis tools for Linux it

00:00:32,489 --> 00:00:36,960
covers the hardware feature and then the

00:00:34,470 --> 00:00:38,579
software's feature for performance

00:00:36,960 --> 00:00:39,239
performance profiling with a high

00:00:38,579 --> 00:00:41,610
efficiency

00:00:39,239 --> 00:00:43,530
so in this testing we were first going

00:00:41,610 --> 00:00:44,280
to consider the fundamental mechanism

00:00:43,530 --> 00:00:45,989
for perv

00:00:44,280 --> 00:00:48,480
then Co so different the usage it

00:00:45,989 --> 00:00:51,960
delivered by many for the armory native

00:00:48,480 --> 00:00:55,110
the features so we were concluded this

00:00:51,960 --> 00:00:57,539
session but it discussing an example so

00:00:55,110 --> 00:01:02,370
in this session we were to finish it the

00:00:57,539 --> 00:01:04,649
material in 15 minutes so that's not so

00:01:02,370 --> 00:01:07,380
we can see that in this session we were

00:01:04,649 --> 00:01:10,200
divided into three parts so first part

00:01:07,380 --> 00:01:13,229
is many focus on the statistical for

00:01:10,200 --> 00:01:15,179
finding ARM arm platforms so you to

00:01:13,229 --> 00:01:17,310
address the fundamental mechanism and

00:01:15,179 --> 00:01:19,560
also to address for the profiling with

00:01:17,310 --> 00:01:22,529
the timer and the PMU so this is just

00:01:19,560 --> 00:01:24,569
the very physical usage II for the for

00:01:22,529 --> 00:01:27,599
the for the perf then the second part

00:01:24,569 --> 00:01:29,399
many want you a chance for the perfect

00:01:27,599 --> 00:01:31,409
with the cheating tools the second part

00:01:29,399 --> 00:01:34,259
the third parties for the debugging

00:01:31,409 --> 00:01:36,450
stories so let's see the first part so

00:01:34,259 --> 00:01:39,899
what's the perf the profit is a powerful

00:01:36,450 --> 00:01:42,060
profiling tools so primarily it plots

00:01:39,899 --> 00:01:43,729
the CPU performance counters but also

00:01:42,060 --> 00:01:46,319
can gather information from another

00:01:43,729 --> 00:01:49,109
source like at a higher resolution timer

00:01:46,319 --> 00:01:52,469
and therefore the software the twist

00:01:49,109 --> 00:01:54,899
twist point and the dynamic probes so

00:01:52,469 --> 00:01:56,999
another thing that in the perf actually

00:01:54,899 --> 00:01:59,579
the family of of useful to use

00:01:56,999 --> 00:02:01,829
collectively in a single battery so we

00:01:59,579 --> 00:02:04,619
can see that the ECAM probe is profiling

00:02:01,829 --> 00:02:07,380
to to gather statistic information and a

00:02:04,619 --> 00:02:09,269
reporter results so these well can see

00:02:07,380 --> 00:02:10,370
that on the right side there have many

00:02:09,269 --> 00:02:13,590
Sepulcher

00:02:10,370 --> 00:02:16,680
subcommands provided by the perv

00:02:13,590 --> 00:02:18,239
so it also provided the profanity and

00:02:16,680 --> 00:02:20,400
the tracing the different the command

00:02:18,239 --> 00:02:23,430
also also there have it in averted the

00:02:20,400 --> 00:02:26,209
report the subcommander so you can

00:02:23,430 --> 00:02:28,890
output a result with different divisions

00:02:26,209 --> 00:02:30,569
perfer also can act l rapper for the

00:02:28,890 --> 00:02:33,120
apple trees and the EBP fo we are to

00:02:30,569 --> 00:02:36,300
address for the f trees but the EBP fo

00:02:33,120 --> 00:02:37,890
actually is a very complex topic so in

00:02:36,300 --> 00:02:41,610
this session we will not talk about the

00:02:37,890 --> 00:02:43,860
EPF so profit also included benchmark

00:02:41,610 --> 00:02:46,980
issues for memory and for the schedule

00:02:43,860 --> 00:02:49,830
name scheduling performance testing so

00:02:46,980 --> 00:02:54,690
this white provided the supper come on

00:02:49,830 --> 00:02:56,250
the per bench so when we use the FIR for

00:02:54,690 --> 00:02:59,400
the first thing that we needed based on

00:02:56,250 --> 00:03:01,650
the profiling event so purpose oppose

00:02:59,400 --> 00:03:05,250
different kind of the profiling event

00:03:01,650 --> 00:03:08,310
especially for the statistical profiling

00:03:05,250 --> 00:03:10,830
and the performance monitoring so at the

00:03:08,310 --> 00:03:13,799
most basic end of that a timer can be

00:03:10,830 --> 00:03:15,360
used to pure radically to sample the

00:03:13,799 --> 00:03:16,680
piece of manual but it also can be

00:03:15,360 --> 00:03:19,920
triggered by the other hardware

00:03:16,680 --> 00:03:26,549
human-like the acacia T cache this event

00:03:19,920 --> 00:03:29,840
branch and for the branch and for the

00:03:26,549 --> 00:03:31,190
freedom prediction these kind of

00:03:29,840 --> 00:03:34,290
statistics

00:03:31,190 --> 00:03:36,660
so perfer also can rely on the hardware

00:03:34,290 --> 00:03:40,440
break point for the profaning so for

00:03:36,660 --> 00:03:43,260
example our x86 the platform we can you

00:03:40,440 --> 00:03:45,930
can use the hardware pick pointed to

00:03:43,260 --> 00:03:47,780
profile for memory access for example to

00:03:45,930 --> 00:03:50,700
profile for the specific of the dresser

00:03:47,780 --> 00:03:54,569
accessing but this is absent on our

00:03:50,700 --> 00:03:56,190
platform perf also suppose the software

00:03:54,569 --> 00:03:59,489
pieces the event for example we can use

00:03:56,190 --> 00:04:02,220
every stress event to do the software

00:03:59,489 --> 00:04:04,049
you enter statistics and also negative

00:04:02,220 --> 00:04:06,090
context switching and the for every

00:04:04,049 --> 00:04:08,310
street point so on Wester that we can

00:04:06,090 --> 00:04:10,440
see this example that if we want to get

00:04:08,310 --> 00:04:13,079
to know what's the events are available

00:04:10,440 --> 00:04:15,870
on your platform you can use the perf

00:04:13,079 --> 00:04:17,400
list based cups of command so it were

00:04:15,870 --> 00:04:19,440
too nice the water harder element

00:04:17,400 --> 00:04:21,900
software event and a breakpoint and the

00:04:19,440 --> 00:04:25,620
trees point such kind of the event that

00:04:21,900 --> 00:04:27,240
can be supported on your platform when

00:04:25,620 --> 00:04:29,699
you use the perfume until actually there

00:04:27,240 --> 00:04:32,099
two modes can be used so first of all

00:04:29,699 --> 00:04:34,259
that you the based on the free run and

00:04:32,099 --> 00:04:36,389
second model based on the sampling based

00:04:34,259 --> 00:04:39,300
profiling so we can see that the for the

00:04:36,389 --> 00:04:41,039
perp for the free run either to counter

00:04:39,300 --> 00:04:45,870
the psychos or the cache miss or the

00:04:41,039 --> 00:04:48,300
branch misprediction so um we can say on

00:04:45,870 --> 00:04:51,000
the address that here you the diagram

00:04:48,300 --> 00:04:52,680
doing the for free right actually doing

00:04:51,000 --> 00:04:55,650
the profiling they have no any events

00:04:52,680 --> 00:04:57,569
triggered by the profanity just at the

00:04:55,650 --> 00:05:00,710
end and it will read the statistics the

00:04:57,569 --> 00:05:03,770
information when finished the profiling

00:05:00,710 --> 00:05:06,599
another one is that you need to

00:05:03,770 --> 00:05:08,849
interrupt after specific number of

00:05:06,599 --> 00:05:11,370
samples so these were to trigger the

00:05:08,849 --> 00:05:13,650
interrupt at this time point so you can

00:05:11,370 --> 00:05:16,380
capture the context information so

00:05:13,650 --> 00:05:18,210
you're this way to give the profiling so

00:05:16,380 --> 00:05:20,490
there had nothing needed to aware that

00:05:18,210 --> 00:05:23,370
the different profiler may have

00:05:20,490 --> 00:05:25,500
different endeavors overhead so for

00:05:23,370 --> 00:05:27,599
example the father statistical profiling

00:05:25,500 --> 00:05:29,460
profiler has no overhead but for the

00:05:27,599 --> 00:05:31,919
chasing profiler because it'll wear

00:05:29,460 --> 00:05:33,180
continues into editor she's even that

00:05:31,919 --> 00:05:38,159
you live in buffer so it'll worry

00:05:33,180 --> 00:05:41,070
introduce more overhead this is the

00:05:38,159 --> 00:05:43,650
interface that for the different the

00:05:41,070 --> 00:05:45,810
Waccamaw commode so what's the

00:05:43,650 --> 00:05:49,699
difference used by the your space and

00:05:45,810 --> 00:05:52,949
and color space so this is example that

00:05:49,699 --> 00:05:57,030
the use your space program you need to

00:05:52,949 --> 00:06:00,270
use the system call perf human open to

00:05:57,030 --> 00:06:05,039
open the event and the unity of control

00:06:00,270 --> 00:06:06,900
to set the blocking mode so when you

00:06:05,039 --> 00:06:08,370
know read that on the counter it were to

00:06:06,900 --> 00:06:11,069
written back at the current addressed

00:06:08,370 --> 00:06:13,949
manual for the counters so you this way

00:06:11,069 --> 00:06:17,340
it can't you support for the curve state

00:06:13,949 --> 00:06:19,440
this command mode so if there have the

00:06:17,340 --> 00:06:22,229
sample counter generating events during

00:06:19,440 --> 00:06:25,860
the event aware be say we in the rim

00:06:22,229 --> 00:06:28,530
buffer so this rebar will be accessed by

00:06:25,860 --> 00:06:31,169
the us-based you the man map method so

00:06:28,530 --> 00:06:33,360
finally the she's data where be saved in

00:06:31,169 --> 00:06:35,610
the perfect or Dana this fire so you

00:06:33,360 --> 00:06:37,860
only this measure the way are being used

00:06:35,610 --> 00:06:40,630
by the perf recall this type of command

00:06:37,860 --> 00:06:45,060
so this can this can be

00:06:40,630 --> 00:06:47,140
two different the UCD model by the perv

00:06:45,060 --> 00:06:52,390
when we use the counter actually they

00:06:47,140 --> 00:06:55,390
have the control the chasing scope for

00:06:52,390 --> 00:06:57,460
for the counters so there have one

00:06:55,390 --> 00:07:00,580
physical constant concept when we read

00:06:57,460 --> 00:07:02,830
the color documentation that a perfect

00:07:00,580 --> 00:07:05,200
lighting the counters as a contact group

00:07:02,830 --> 00:07:08,470
so that means that a counter group can

00:07:05,200 --> 00:07:10,810
you schedule the tutor CPU as a you need

00:07:08,470 --> 00:07:14,410
so it'll be enabled or disabled at the

00:07:10,810 --> 00:07:16,900
same time on one CPU so the when news of

00:07:14,410 --> 00:07:19,840
the members counters can be meaningful

00:07:16,900 --> 00:07:22,840
compared editor and divided so can get a

00:07:19,840 --> 00:07:25,660
ratio and the percentage value so

00:07:22,840 --> 00:07:27,700
perfectly winter can be system-wide so

00:07:25,660 --> 00:07:28,330
means that we can enable the human to

00:07:27,700 --> 00:07:30,970
four-cross

00:07:28,330 --> 00:07:32,920
all the CPU for all time but also can be

00:07:30,970 --> 00:07:36,400
attached to the best PCP or to the

00:07:32,920 --> 00:07:42,370
specific task so it can provide for the

00:07:36,400 --> 00:07:43,780
per CPU wise or per task wise so on the

00:07:42,370 --> 00:07:47,020
right side we can see that a basic

00:07:43,780 --> 00:07:49,540
example that for example if we enable

00:07:47,020 --> 00:07:51,190
the even the system while that means the

00:07:49,540 --> 00:07:53,350
all the CPU for all tasks were being

00:07:51,190 --> 00:07:55,810
able for the event but if we just not

00:07:53,350 --> 00:07:57,670
import for the CPU side that means that

00:07:55,810 --> 00:07:59,850
the only the tasks on the CPU running

00:07:57,670 --> 00:08:02,680
where we can't continue for the event

00:07:59,850 --> 00:08:07,150
for the thread wise means that when that

00:08:02,680 --> 00:08:09,670
has migrated for example from CPU 0 0 to

00:08:07,150 --> 00:08:12,550
CPU 1 you can see that the event on the

00:08:09,670 --> 00:08:14,920
CPU 0 where be disabled and on the CPU 1

00:08:12,550 --> 00:08:16,540
they even though we're being involved so

00:08:14,920 --> 00:08:19,960
there have another thing that actually

00:08:16,540 --> 00:08:22,180
the perfuming that can be restricted to

00:08:19,960 --> 00:08:24,460
the time of an the CPU in different the

00:08:22,180 --> 00:08:28,870
user mode for them in user mode to color

00:08:24,460 --> 00:08:31,630
mode or the haploid mode so here is one

00:08:28,870 --> 00:08:32,979
example if we you use the cosider you

00:08:31,630 --> 00:08:36,430
will be very familiar with the

00:08:32,979 --> 00:08:38,830
instruction in that we the hair have the

00:08:36,430 --> 00:08:40,900
specifier you means that this just to

00:08:38,830 --> 00:08:43,180
choose for the for example does use user

00:08:40,900 --> 00:08:48,420
mode pursue admins and this is the task

00:08:43,180 --> 00:08:48,420
of wise purse right wise the tree seen

00:08:48,630 --> 00:08:54,230
peering that when we get to the trees

00:08:51,220 --> 00:08:57,710
data we can use the perfect report

00:08:54,230 --> 00:09:00,470
to investigate the data in the poverty

00:08:57,710 --> 00:09:02,390
line where you need to include the

00:09:00,470 --> 00:09:05,630
chicer configuration information and

00:09:02,390 --> 00:09:07,760
also include the sample data and the we

00:09:05,630 --> 00:09:11,840
also needed to connect with the TS or

00:09:07,760 --> 00:09:12,860
dynamic shared object for analysis so

00:09:11,840 --> 00:09:15,200
all the rest of that we can see that

00:09:12,860 --> 00:09:17,630
this is a typical example for output

00:09:15,200 --> 00:09:19,400
format for the perv so there have a

00:09:17,630 --> 00:09:21,320
sample what's the sample if you use of

00:09:19,400 --> 00:09:24,080
clearing the cache miss and what's the

00:09:21,320 --> 00:09:27,050
sample count so there have many that

00:09:24,080 --> 00:09:30,110
count has been captured by the by the

00:09:27,050 --> 00:09:32,870
profiling so they are here you just that

00:09:30,110 --> 00:09:35,450
the workload percentage introduced by

00:09:32,870 --> 00:09:38,480
which program command which share the

00:09:35,450 --> 00:09:41,930
object and which is simple this can be

00:09:38,480 --> 00:09:43,670
easily find at a function name so TSO

00:09:41,930 --> 00:09:47,240
actually is very important and in the

00:09:43,670 --> 00:09:49,790
purple is that Eaton where be referred

00:09:47,240 --> 00:09:52,310
by the perf the fire by the Builder ID

00:09:49,790 --> 00:09:56,120
and the DSO will be casually in the

00:09:52,310 --> 00:09:59,300
folder total yeah debug so tobogganing

00:09:56,120 --> 00:10:01,880
also plays in the user home folder and

00:09:59,300 --> 00:10:05,210
the dig can be acquired by perf

00:10:01,880 --> 00:10:08,270
archiving this command so we only use

00:10:05,210 --> 00:10:10,400
this method that can generate a tar file

00:10:08,270 --> 00:10:13,460
so this can be used by another platform

00:10:10,400 --> 00:10:17,240
for the cross of alas or lattices so for

00:10:13,460 --> 00:10:19,280
example that we can do the profile on

00:10:17,240 --> 00:10:22,520
the target boat and then we can copy the

00:10:19,280 --> 00:10:26,990
tougher to the host PC to your analysis

00:10:22,520 --> 00:10:30,020
there have another output format is used

00:10:26,990 --> 00:10:31,640
the perf I rotate this command so perfer

00:10:30,020 --> 00:10:34,070
annotate the maps of the profiling

00:10:31,640 --> 00:10:35,990
information to the source code so if the

00:10:34,070 --> 00:10:38,300
displace the source code along side with

00:10:35,990 --> 00:10:40,970
the examinee code if the object fire has

00:10:38,300 --> 00:10:43,310
the tip debug symbols so this example

00:10:40,970 --> 00:10:45,530
data you can see that there have United

00:10:43,310 --> 00:10:49,280
the company code and also have the

00:10:45,530 --> 00:10:52,580
source code so if that there have

00:10:49,280 --> 00:10:54,440
without the debug symbols then the word

00:10:52,580 --> 00:10:56,060
to display the assembly so the

00:10:54,440 --> 00:10:57,890
Disciplinary information actually is

00:10:56,060 --> 00:10:59,900
where stood forward so we can see that

00:10:57,890 --> 00:11:03,140
we can use need to connect with the this

00:10:59,900 --> 00:11:06,380
is a walk load the percentage to connect

00:11:03,140 --> 00:11:08,030
with which code anion introduced for the

00:11:06,380 --> 00:11:11,660
for the base

00:11:08,030 --> 00:11:13,700
overhead so this may be nothing you just

00:11:11,660 --> 00:11:15,920
the code nine maybe it just a function

00:11:13,700 --> 00:11:17,690
so when you use the cursor to move

00:11:15,920 --> 00:11:18,560
through this function you can press the

00:11:17,690 --> 00:11:20,300
Enter

00:11:18,560 --> 00:11:23,030
so you can deep through this function

00:11:20,300 --> 00:11:26,600
which part of the function introduced

00:11:23,030 --> 00:11:29,300
overhead if you you can use the Q press

00:11:26,600 --> 00:11:31,160
Q to jump to the upper function here how

00:11:29,300 --> 00:11:33,740
another I think you're useful

00:11:31,160 --> 00:11:35,900
information that actually we can switch

00:11:33,740 --> 00:11:39,350
from an app or report context to the

00:11:35,900 --> 00:11:46,400
proof allotted theta context if we use

00:11:39,350 --> 00:11:48,080
the press press a so this is another

00:11:46,400 --> 00:11:50,120
matter that you ought to put the tree

00:11:48,080 --> 00:11:52,010
state arigato we can know that a the

00:11:50,120 --> 00:11:55,250
first two to measure that just that you

00:11:52,010 --> 00:11:57,020
print out the statistic information but

00:11:55,250 --> 00:11:59,630
here is just that you print out of the

00:11:57,020 --> 00:12:01,400
motive hair that she's data so perfect

00:11:59,630 --> 00:12:04,010
squib we can use a separate command per

00:12:01,400 --> 00:12:06,230
script so it'll really input fire with

00:12:04,010 --> 00:12:08,930
display that deter the trace of the

00:12:06,230 --> 00:12:11,270
workload and we can specify what we

00:12:08,930 --> 00:12:13,970
should feel don't need to be displayed

00:12:11,270 --> 00:12:17,270
of freedom for the CPU or even an IP or

00:12:13,970 --> 00:12:19,610
time so furthermore that another advance

00:12:17,270 --> 00:12:23,120
the usage e we can you're the perfect

00:12:19,610 --> 00:12:24,680
script that you do the post process with

00:12:23,120 --> 00:12:28,130
the Python or Perl script

00:12:24,680 --> 00:12:30,110
so this you this way we can break it and

00:12:28,130 --> 00:12:32,720
the extractor use of a machine with a

00:12:30,110 --> 00:12:35,150
row per stream so this is a quick

00:12:32,720 --> 00:12:38,030
example that we can stratify with the -

00:12:35,150 --> 00:12:39,950
s with a Python script name so in the

00:12:38,030 --> 00:12:41,390
pencil scribbling we can write a

00:12:39,950 --> 00:12:43,310
callback function for the system

00:12:41,390 --> 00:12:45,410
ecosystem in inter

00:12:43,310 --> 00:12:48,080
so you here will just let you print to

00:12:45,410 --> 00:12:50,470
relate the information but also can

00:12:48,080 --> 00:12:53,690
write the Python script the program to

00:12:50,470 --> 00:12:59,570
aggregate the information the

00:12:53,690 --> 00:13:02,180
for this event so actually when first

00:12:59,570 --> 00:13:06,110
time when we access the perf

00:13:02,180 --> 00:13:09,020
the first usage EU profile with timer so

00:13:06,110 --> 00:13:10,970
the really that perf included support

00:13:09,020 --> 00:13:13,750
for the timer based profiling we're the

00:13:10,970 --> 00:13:16,160
hydrogen ocean timers so it's very

00:13:13,750 --> 00:13:19,400
intuitive with you understand how the

00:13:16,160 --> 00:13:21,170
code consume the times so you only want

00:13:19,400 --> 00:13:25,519
to know which part the code comes

00:13:21,170 --> 00:13:28,070
how much is the time so provided the

00:13:25,519 --> 00:13:30,649
tube time paste the profiler wine sniff

00:13:28,070 --> 00:13:32,839
o'clock and another is the task clock so

00:13:30,649 --> 00:13:36,560
sip o'clock actually is based on or

00:13:32,839 --> 00:13:38,269
clock so it take a regular interview and

00:13:36,560 --> 00:13:40,490
I really need you with you the war time

00:13:38,269 --> 00:13:43,279
so task log actually the sample for

00:13:40,490 --> 00:13:45,949
special tasks run time on the rest of

00:13:43,279 --> 00:13:48,290
that actually there have to use ampoules

00:13:45,949 --> 00:13:51,110
wine paste on the cpu clock you're the

00:13:48,290 --> 00:13:53,120
perfect op profitably the seminary the

00:13:51,110 --> 00:13:57,199
command with the top commander we only

00:13:53,120 --> 00:13:59,420
in the Linux color linear system so in a

00:13:57,199 --> 00:14:02,180
way to display the which the program on

00:13:59,420 --> 00:14:04,820
which they are so related with for the

00:14:02,180 --> 00:14:07,310
profiling data and another is for the

00:14:04,820 --> 00:14:09,230
task clock we can record the event and

00:14:07,310 --> 00:14:11,899
finally to you're the perfect report

00:14:09,230 --> 00:14:15,110
that you do profiling so here I one

00:14:11,899 --> 00:14:19,010
thing that you we select the sampling

00:14:15,110 --> 00:14:20,300
frequency is 99 hurts so the reading

00:14:19,010 --> 00:14:23,810
that that you for the sampling frequency

00:14:20,300 --> 00:14:25,880
is the same at the repeating event

00:14:23,810 --> 00:14:28,610
within the profile code that means that

00:14:25,880 --> 00:14:30,019
it's very easy to miss need because that

00:14:28,610 --> 00:14:32,180
agent Rapala we are always a fit about

00:14:30,019 --> 00:14:35,089
almost the same beat over the code

00:14:32,180 --> 00:14:39,140
source code so we need to deal a brainy

00:14:35,089 --> 00:14:43,070
to select one frequency is not multiple

00:14:39,140 --> 00:14:45,829
of ten no matter for power of two so the

00:14:43,070 --> 00:14:49,399
this can be given more chance that that

00:14:45,829 --> 00:14:54,019
even can be hated for different the

00:14:49,399 --> 00:15:01,370
event in the source code this quick

00:14:54,019 --> 00:15:03,980
review for the arm p.m. you so notice

00:15:01,370 --> 00:15:06,170
that modern CPUs provide the performance

00:15:03,980 --> 00:15:09,560
monitor you need to count the CPU cycle

00:15:06,170 --> 00:15:14,870
but also cache cache and branch even for

00:15:09,560 --> 00:15:16,670
profiling so P mu is very useful for the

00:15:14,870 --> 00:15:17,870
observe the performance and the cam

00:15:16,670 --> 00:15:19,790
monitor right down to the CPU

00:15:17,870 --> 00:15:23,060
microarchitectures

00:15:19,790 --> 00:15:25,310
networks so on the rest of the that this

00:15:23,060 --> 00:15:28,279
is one example that they I have two CPUs

00:15:25,310 --> 00:15:31,399
there our CPU we have its corresponding

00:15:28,279 --> 00:15:33,319
the PMU logic so Erik hear me we have

00:15:31,399 --> 00:15:34,980
the cycle counter and also have the

00:15:33,319 --> 00:15:37,320
other different

00:15:34,980 --> 00:15:39,690
counter this can be used for for example

00:15:37,320 --> 00:15:43,500
this interaction branch or catchment

00:15:39,690 --> 00:15:46,199
related contents so I repair me where to

00:15:43,500 --> 00:15:49,170
collect one specific interrupt single or

00:15:46,199 --> 00:15:55,050
to the CPU this map might be or SPI or

00:15:49,170 --> 00:15:57,660
people IP over sorry PPI so we can

00:15:55,050 --> 00:16:00,120
enable the multiple the emu human you

00:15:57,660 --> 00:16:02,220
want perfect command but this is just

00:16:00,120 --> 00:16:04,050
the former sips software side we can

00:16:02,220 --> 00:16:05,730
sell support a medical but for the

00:16:04,050 --> 00:16:09,079
hardware side the data you've had in the

00:16:05,730 --> 00:16:13,560
limitation for example that say 53

00:16:09,079 --> 00:16:18,139
supports maximum to 60 went +1 and cycle

00:16:13,560 --> 00:16:21,480
or counters so this means that we can

00:16:18,139 --> 00:16:26,070
enable maximum to this kind discount

00:16:21,480 --> 00:16:28,110
numbers event at the same time if we

00:16:26,070 --> 00:16:31,079
will review the per for the emu driver

00:16:28,110 --> 00:16:33,899
actually is pretty simple so actually

00:16:31,079 --> 00:16:36,240
it's just the cable the PMO's driver sim

00:16:33,899 --> 00:16:38,790
simple in the color side and the

00:16:36,240 --> 00:16:41,459
complexity is leave the inner your space

00:16:38,790 --> 00:16:44,040
so the you will review the code that the

00:16:41,459 --> 00:16:49,829
purview space program is very welcome

00:16:44,040 --> 00:16:52,139
complex then your color space here is

00:16:49,829 --> 00:16:54,569
that if we want to profile with the PME

00:16:52,139 --> 00:16:57,180
or your anyway where to use the standard

00:16:54,569 --> 00:17:00,690
given the name for instruction cache and

00:16:57,180 --> 00:17:03,300
branch related hardware unit up refining

00:17:00,690 --> 00:17:05,309
the example is that we can you the cache

00:17:03,300 --> 00:17:08,610
reference and the cache miss for the

00:17:05,309 --> 00:17:10,799
profaning the purple also provided this

00:17:08,610 --> 00:17:14,010
is automatically it were to do the

00:17:10,799 --> 00:17:16,679
automatically the comparison between the

00:17:14,010 --> 00:17:18,780
matrix with the standard the event name

00:17:16,679 --> 00:17:21,720
for example here is that it will compare

00:17:18,780 --> 00:17:23,760
with the cache misses to the kashi

00:17:21,720 --> 00:17:28,390
reference so we can use to get to know

00:17:23,760 --> 00:17:30,049
the cache miss say missing percentage

00:17:28,390 --> 00:17:35,490
[Music]

00:17:30,049 --> 00:17:38,600
but the standard unit the name cannot

00:17:35,490 --> 00:17:42,270
cover all the harder we're aware of

00:17:38,600 --> 00:17:44,820
available the you provided event by the

00:17:42,270 --> 00:17:47,429
PMU so this means neither we need to use

00:17:44,820 --> 00:17:48,350
the raw mode to explore more the harder

00:17:47,429 --> 00:17:51,529
element

00:17:48,350 --> 00:17:55,100
so for example down on the c53 we can

00:17:51,529 --> 00:17:58,700
use row ID number 0 3 for L 1 data cache

00:17:55,100 --> 00:18:01,580
we feel and therefore for our 1 data

00:17:58,700 --> 00:18:04,250
cache access actually this command is a

00:18:01,580 --> 00:18:06,950
parity with will you understand that the

00:18:04,250 --> 00:18:08,570
human name but the difference is that if

00:18:06,950 --> 00:18:12,620
we understand that the human name it

00:18:08,570 --> 00:18:15,740
will do some comparison for this then

00:18:12,620 --> 00:18:18,580
that even but for this is all made a row

00:18:15,740 --> 00:18:21,649
mode is where not do the comparison here

00:18:18,580 --> 00:18:25,250
Newton not about another thing that our

00:18:21,649 --> 00:18:27,980
different platform the cache profiling

00:18:25,250 --> 00:18:30,200
may be referred to different the cache

00:18:27,980 --> 00:18:31,970
level on platform we journey is

00:18:30,200 --> 00:18:34,429
reference to the l1 cache level

00:18:31,970 --> 00:18:39,169
profiling but on some platform and maybe

00:18:34,429 --> 00:18:41,870
it's provide another cache levels so

00:18:39,169 --> 00:18:43,970
they should not and I think that if we

00:18:41,870 --> 00:18:46,159
wanted to profile our to catch enough

00:18:43,970 --> 00:18:49,370
profiling actually we need to do the

00:18:46,159 --> 00:18:52,070
aggregate for the CPU share the same one

00:18:49,370 --> 00:18:55,340
l2 cache so this means that or maybe

00:18:52,070 --> 00:18:59,000
need to do some manual accounting for

00:18:55,340 --> 00:19:01,129
this kind for l2 cache profile just want

00:18:59,000 --> 00:19:04,009
to color clarify that actually we read

00:19:01,129 --> 00:19:07,960
the out you can see the profound data

00:19:04,009 --> 00:19:11,179
actually is rid of all the l2 cache

00:19:07,960 --> 00:19:13,970
statistics for or share that this l2

00:19:11,179 --> 00:19:15,830
cache but you might be missed some

00:19:13,970 --> 00:19:19,100
information when you're preventing on

00:19:15,830 --> 00:19:22,549
this best fit CPU so you need to account

00:19:19,100 --> 00:19:25,700
for all the CPUs share this similar to

00:19:22,549 --> 00:19:28,970
cache this is one example that to you

00:19:25,700 --> 00:19:32,570
the PMU for profiling hotspot so it's

00:19:28,970 --> 00:19:35,509
quite simple just you for example we can

00:19:32,570 --> 00:19:38,419
use the top this command that you find a

00:19:35,509 --> 00:19:41,779
which program consume more CPU bandwidth

00:19:38,419 --> 00:19:43,870
than expected so this just want to

00:19:41,779 --> 00:19:45,799
narrow down if you told you this

00:19:43,870 --> 00:19:47,659
commander you just let you the global

00:19:45,799 --> 00:19:50,240
message that you do profile also very

00:19:47,659 --> 00:19:52,639
okay so this case I want to narrow down

00:19:50,240 --> 00:19:56,720
there have one program with the PID

00:19:52,639 --> 00:19:59,059
number is 582 and the first stage in 2.3

00:19:56,720 --> 00:20:01,549
so seems not very high but you for

00:19:59,059 --> 00:20:01,970
compare this in program consider this is

00:20:01,549 --> 00:20:04,790
a very

00:20:01,970 --> 00:20:07,730
small program so this is very high a

00:20:04,790 --> 00:20:10,930
percentage so we can use the perfect

00:20:07,730 --> 00:20:15,940
record your the CPU cycle and attach the

00:20:10,930 --> 00:20:19,730
process ID then we can do sleep for the

00:20:15,940 --> 00:20:21,500
20 seconds so miss data where do nothing

00:20:19,730 --> 00:20:25,280
for this command but just to capture

00:20:21,500 --> 00:20:27,980
information during the next 20 seconds

00:20:25,280 --> 00:20:30,080
so here I was in that you only we can

00:20:27,980 --> 00:20:33,710
use the CPU cycle and we also can use

00:20:30,080 --> 00:20:35,900
the timers so why were you this psycho

00:20:33,710 --> 00:20:38,900
sleep because that is more accurate when

00:20:35,900 --> 00:20:41,030
the CPU frequency scheduling if you

00:20:38,900 --> 00:20:43,940
stick your finger in scheduling if you

00:20:41,030 --> 00:20:46,700
timer actually you cannot refer reflect

00:20:43,940 --> 00:20:48,470
they have the CPU frequency but you feel

00:20:46,700 --> 00:20:52,190
the CPU cycle this event that you can

00:20:48,470 --> 00:20:55,940
reflect as the more CPU cycles consumed

00:20:52,190 --> 00:20:59,690
by the program so fine and later you can

00:20:55,940 --> 00:21:01,430
see that you can generate a report read

00:20:59,690 --> 00:21:04,010
straight forward either have overhead

00:21:01,430 --> 00:21:06,050
the percentage and can quicken it you

00:21:04,010 --> 00:21:09,560
look located which command which he

00:21:06,050 --> 00:21:14,480
share the object and the symbol to

00:21:09,560 --> 00:21:18,260
introduce overhead so this first part so

00:21:14,480 --> 00:21:21,230
second part is wanted to address the

00:21:18,260 --> 00:21:23,270
perf with treason tools so actually the

00:21:21,230 --> 00:21:26,060
first acute use is related with the

00:21:23,270 --> 00:21:28,330
shuttle where treason to and the third

00:21:26,060 --> 00:21:34,760
part is related with the co site

00:21:28,330 --> 00:21:37,370
hardware related the chasing so for the

00:21:34,760 --> 00:21:42,380
perfect with the work with the tree of

00:21:37,370 --> 00:21:46,400
trees actually it have to walk in mode

00:21:42,380 --> 00:21:49,820
the first one walking mode is the you at

00:21:46,400 --> 00:21:51,890
the rapper for the app trees so it can

00:21:49,820 --> 00:21:55,730
enable the function of function graph

00:21:51,890 --> 00:21:57,290
tracer and for the function trees so we

00:21:55,730 --> 00:21:59,240
can see this the first commander data

00:21:57,290 --> 00:22:02,480
just with your enable the function trees

00:21:59,240 --> 00:22:06,800
and also it can specify which function

00:22:02,480 --> 00:22:09,740
where we traced so but the result will

00:22:06,800 --> 00:22:12,570
be outputted by the reader reroute just

00:22:09,740 --> 00:22:17,140
read the real result from the

00:22:12,570 --> 00:22:20,230
she sought to put the fire entry the

00:22:17,140 --> 00:22:21,760
second mode you can rely on the menu

00:22:20,230 --> 00:22:24,850
above the trees point and the dudas

00:22:21,760 --> 00:22:26,590
death mystics for the treatment so this

00:22:24,850 --> 00:22:28,600
is the second master that we can see

00:22:26,590 --> 00:22:31,600
that just that you you'll record and

00:22:28,600 --> 00:22:34,960
Spotify the even the name so here is to

00:22:31,600 --> 00:22:38,710
specify in the team memory subsystem and

00:22:34,960 --> 00:22:41,230
user came ma'am look this event there

00:22:38,710 --> 00:22:43,750
have another model more advanced that

00:22:41,230 --> 00:22:46,870
you use the bed that perv for the

00:22:43,750 --> 00:22:49,570
actresses can you the purse get this

00:22:46,870 --> 00:22:51,970
wanted to do the more scheduled in

00:22:49,570 --> 00:22:55,000
latency for based on the a virtuous

00:22:51,970 --> 00:22:56,350
event but it is a record so we just can

00:22:55,000 --> 00:22:58,900
simple need you for example you the

00:22:56,350 --> 00:23:01,570
Purvis get record for one second and

00:22:58,900 --> 00:23:03,070
you're the purposive scared they didn't

00:23:01,570 --> 00:23:05,919
see either word you utter put the

00:23:03,070 --> 00:23:08,140
schedule schedule in latency so you can

00:23:05,919 --> 00:23:10,929
see that they were to output the runtime

00:23:08,140 --> 00:23:13,390
for the panic program and a switch

00:23:10,929 --> 00:23:15,309
context which counting and for the

00:23:13,390 --> 00:23:18,010
average is scheduled in latency this is

00:23:15,309 --> 00:23:20,440
maximum scheduled agency that's why that

00:23:18,010 --> 00:23:25,200
at which time point introduced for the

00:23:20,440 --> 00:23:25,200
schedule Nathan Maxim schedule intensive

00:23:25,620 --> 00:23:29,940
for the average is actually the were

00:23:27,669 --> 00:23:33,549
straightforward for the problem is

00:23:29,940 --> 00:23:35,650
macadam or a bit complex so we probably

00:23:33,549 --> 00:23:38,580
probably is dynamically even tracing in

00:23:35,650 --> 00:23:42,549
color on the new space app is

00:23:38,580 --> 00:23:44,890
irrespective inning superb probe can be

00:23:42,549 --> 00:23:48,520
a dealer or removal on the fly

00:23:44,890 --> 00:23:51,400
so actually we also if we read the color

00:23:48,520 --> 00:23:54,340
document it suggested you can use the

00:23:51,400 --> 00:23:56,559
fj's sis effort effort note you are able

00:23:54,340 --> 00:23:58,840
to probe but the difficulty saying that

00:23:56,559 --> 00:24:03,220
you don't know which source code online

00:23:58,840 --> 00:24:03,700
is available to a neighbor that is his

00:24:03,220 --> 00:24:07,630
point

00:24:03,700 --> 00:24:09,940
so you'd prefer to use more coming in to

00:24:07,630 --> 00:24:12,220
enable the probes without disassembling

00:24:09,940 --> 00:24:14,350
and another thing that you can use in

00:24:12,220 --> 00:24:16,780
the connect the tracing with with source

00:24:14,350 --> 00:24:19,059
code for analysis so we can see this is

00:24:16,780 --> 00:24:22,179
one example that evil you're the perv

00:24:19,059 --> 00:24:27,120
probe attached - 9 it can display their

00:24:22,179 --> 00:24:30,549
have for one function which the

00:24:27,120 --> 00:24:34,840
relative offset code 9 is available for

00:24:30,549 --> 00:24:39,940
the chasing so here either were to list

00:24:34,840 --> 00:24:42,880
for example 0 1 2 5 this relative of

00:24:39,940 --> 00:24:48,220
outside can be used for the imported

00:24:42,880 --> 00:24:52,390
probe after that we also can need can

00:24:48,220 --> 00:24:54,850
use the perf probe that data whereas to

00:24:52,390 --> 00:24:58,389
tell available variables at a given

00:24:54,850 --> 00:25:02,289
point so the means that when we specify

00:24:58,389 --> 00:25:05,139
for example here is specify upset

00:25:02,289 --> 00:25:09,250
eight means that this is a relative of

00:25:05,139 --> 00:25:11,260
site 8 coda 9 then use this command in

00:25:09,250 --> 00:25:14,950
where to tell us that there have three

00:25:11,260 --> 00:25:18,880
available scan variables can be traced

00:25:14,950 --> 00:25:23,710
so finally we can use the proof problem

00:25:18,880 --> 00:25:26,289
that I add to aid enable one probe with

00:25:23,710 --> 00:25:29,100
for a function name with the relative

00:25:26,289 --> 00:25:31,630
offset number and we can specify which

00:25:29,100 --> 00:25:33,940
variable information we can collect it

00:25:31,630 --> 00:25:36,970
so you do we use this way you the more

00:25:33,940 --> 00:25:39,370
dominant if you use to you this way you

00:25:36,970 --> 00:25:43,360
need to be sampling and that you read

00:25:39,370 --> 00:25:48,850
the code and start the problem from CFS

00:25:43,360 --> 00:25:51,789
note so the first two-parter is related

00:25:48,850 --> 00:25:53,679
with the software cheating so from there

00:25:51,789 --> 00:25:57,250
and then we can say this ability with

00:25:53,679 --> 00:25:59,289
hardware cheating so cos a cos theta is

00:25:57,250 --> 00:26:02,440
the hardware IP which can choose program

00:25:59,289 --> 00:26:04,269
and that can facilitate the hardware

00:26:02,440 --> 00:26:08,440
assistive tracing and pro funny

00:26:04,269 --> 00:26:11,260
so actually two years ago that masu give

00:26:08,440 --> 00:26:14,279
well detailed presentation at a

00:26:11,260 --> 00:26:16,510
collector for the hardware assisted

00:26:14,279 --> 00:26:20,080
tracing and profiling with the co site

00:26:16,510 --> 00:26:23,049
in this right so if you 20 need you can

00:26:20,080 --> 00:26:25,090
see that so the basic idea is that to

00:26:23,049 --> 00:26:28,299
integrate the cost I do with the per

00:26:25,090 --> 00:26:31,899
framework into the pro framework so cos

00:26:28,299 --> 00:26:35,679
theta need to register ATM embedded the

00:26:31,899 --> 00:26:38,320
trees maka'ala are the PR event so into

00:26:35,679 --> 00:26:39,440
the perf call so when we use the perfect

00:26:38,320 --> 00:26:42,559
command

00:26:39,440 --> 00:26:45,769
we need to specify the sink or sink to

00:26:42,559 --> 00:26:48,500
indicate where you recorded so the eww

00:26:45,769 --> 00:26:52,610
that for example in a system they have q

00:26:48,500 --> 00:26:54,529
CPUs every sip you have its ppm so EPM

00:26:52,610 --> 00:26:56,389
aware to generate that recent data the

00:26:54,529 --> 00:26:59,929
trend data where to gather the

00:26:56,389 --> 00:27:03,049
information from the step funnel then to

00:26:59,929 --> 00:27:07,730
the ETF or to ETR so if you have the

00:27:03,049 --> 00:27:10,789
eligible Ram ETL have can be routed for

00:27:07,730 --> 00:27:14,600
example to the Eastern no pass or to the

00:27:10,789 --> 00:27:16,610
memory country memory so we can specify

00:27:14,600 --> 00:27:18,769
where we gather it in for me

00:27:16,610 --> 00:27:20,629
which isn't data for example in this

00:27:18,769 --> 00:27:24,159
command we can see that in where to

00:27:20,629 --> 00:27:26,929
gather the cheese data from the EPR

00:27:24,159 --> 00:27:28,759
felony then we can give you the proper

00:27:26,929 --> 00:27:30,980
record command there in the word to

00:27:28,759 --> 00:27:34,009
gather the tree's data we need to use

00:27:30,980 --> 00:27:37,100
the proper report this command Q out for

00:27:34,009 --> 00:27:39,139
the result when reporting results we

00:27:37,100 --> 00:27:42,200
need to rely on the open CST these

00:27:39,139 --> 00:27:44,000
memories so open 13 average maybe to be

00:27:42,200 --> 00:27:48,110
mink and open perf building for the cost

00:27:44,000 --> 00:27:50,330
at the trees in decoding here have acute

00:27:48,110 --> 00:27:52,970
limitations for the co site profiling

00:27:50,330 --> 00:27:55,220
why is introduced by by if you use the

00:27:52,970 --> 00:28:00,759
perf option another actually isn't

00:27:55,220 --> 00:28:03,799
caused by the code in implementation so

00:28:00,759 --> 00:28:06,679
the first thing initially that the Casa

00:28:03,799 --> 00:28:09,230
DPM support limitation for tracing with

00:28:06,679 --> 00:28:11,840
the prof option for example use the - K

00:28:09,230 --> 00:28:14,600
or - you can specify only for color

00:28:11,840 --> 00:28:16,940
space or your space tracing I'll specify

00:28:14,600 --> 00:28:19,580
with the optional touch the filter can

00:28:16,940 --> 00:28:23,049
specify tracing address range so we can

00:28:19,580 --> 00:28:26,240
see this is the example that we can only

00:28:23,049 --> 00:28:29,419
entity in the color space treaty and we

00:28:26,240 --> 00:28:32,629
can specify which of the colors address

00:28:29,419 --> 00:28:36,559
range just be used for tracing so other

00:28:32,629 --> 00:28:39,610
trees data where we feel fitted their

00:28:36,559 --> 00:28:42,769
have another limitation actually is not

00:28:39,610 --> 00:28:45,379
introduced by the perv - but it just an

00:28:42,769 --> 00:28:49,070
introduced by our server for the

00:28:45,379 --> 00:28:51,230
implementation so this will because that

00:28:49,070 --> 00:28:53,360
counting the UTM are only supported

00:28:51,230 --> 00:28:55,580
first right wise

00:28:53,360 --> 00:28:58,880
so this way that we can you anyway see

00:28:55,580 --> 00:29:02,780
what for Co site away where to add an

00:28:58,880 --> 00:29:04,940
option purse right this so with this

00:29:02,780 --> 00:29:06,799
mode that when it statically scheduled

00:29:04,940 --> 00:29:09,409
on the CPU then the UTM we're being able

00:29:06,799 --> 00:29:12,710
but after the tasks are scheduled out

00:29:09,409 --> 00:29:17,360
then the CPU e TM will be disabled

00:29:12,710 --> 00:29:20,539
it's disabled and so actually there have

00:29:17,360 --> 00:29:23,059
one working progress that we need to

00:29:20,539 --> 00:29:27,580
support for CPU why that she's twisting

00:29:23,059 --> 00:29:30,440
arrows this is is working by masu so

00:29:27,580 --> 00:29:32,120
counting that if we wanted here able the

00:29:30,440 --> 00:29:34,850
CPU either chasing then how another

00:29:32,120 --> 00:29:37,429
method is that we can use the CFS know

00:29:34,850 --> 00:29:39,080
that you manually enable that if you

00:29:37,429 --> 00:29:42,980
have interesting you can see that in the

00:29:39,080 --> 00:29:45,860
colored document so but this slide on to

00:29:42,980 --> 00:29:51,890
address because it out of scope also

00:29:45,860 --> 00:29:54,919
perf so here is that we can dig a bit

00:29:51,890 --> 00:30:02,030
more for how to decode in the cost at

00:29:54,919 --> 00:30:04,400
risk data with open CSD so there have

00:30:02,030 --> 00:30:06,679
one big difference compared to the other

00:30:04,400 --> 00:30:09,350
general care media device is that the

00:30:06,679 --> 00:30:11,799
cassette which is output to the compress

00:30:09,350 --> 00:30:14,210
the data so it cannot directly to

00:30:11,799 --> 00:30:17,150
generate the sample based the structure

00:30:14,210 --> 00:30:20,870
so this way we can see that on a perfect

00:30:17,150 --> 00:30:22,909
data if we get the cosine theta

00:30:20,870 --> 00:30:25,760
actually this concept crystallized

00:30:22,909 --> 00:30:28,610
compress it also includes the cassette

00:30:25,760 --> 00:30:31,549
and metadata this is for the tree search

00:30:28,610 --> 00:30:33,230
configuration informations so it'll run

00:30:31,549 --> 00:30:35,150
time actually just that you'll capture

00:30:33,230 --> 00:30:38,570
this data and see we in the perfect fire

00:30:35,150 --> 00:30:40,669
so when we reported the Cosette Cosette

00:30:38,570 --> 00:30:44,120
the trees data we were to use the open

00:30:40,669 --> 00:30:47,360
CSTE so it'll were to decode the trees

00:30:44,120 --> 00:30:50,780
data to every package so this package

00:30:47,360 --> 00:30:53,390
we're finally to generate the synthesize

00:30:50,780 --> 00:30:56,030
the samples so this simple scissors that

00:30:53,390 --> 00:30:58,520
samples where to output you add the

00:30:56,030 --> 00:31:00,289
branch sample so we can see that adapt

00:30:58,520 --> 00:31:02,590
for the branch example it will have the

00:31:00,289 --> 00:31:05,030
branch end address and the start address

00:31:02,590 --> 00:31:06,600
so you this way that we can see it's a

00:31:05,030 --> 00:31:14,340
very straightforward or profile

00:31:06,600 --> 00:31:16,679
with cottage cheese data so for for

00:31:14,340 --> 00:31:18,080
example for an the user actually I don't

00:31:16,679 --> 00:31:20,940
know that there have many that

00:31:18,080 --> 00:31:24,210
depressing or decoding in the perf but

00:31:20,940 --> 00:31:27,720
I'd use a normal mode with the cassette

00:31:24,210 --> 00:31:31,320
with for as a normal p.m. you device for

00:31:27,720 --> 00:31:33,600
the cassette so felony Daniel Defoe with

00:31:31,320 --> 00:31:37,110
the perf report and the perfect script

00:31:33,600 --> 00:31:38,850
this command so you know easy example

00:31:37,110 --> 00:31:41,340
that we just in your perfect record

00:31:38,850 --> 00:31:44,549
command that you enable the twist data

00:31:41,340 --> 00:31:46,770
and you're the perfect report to output

00:31:44,549 --> 00:31:54,600
the workload introduced by the different

00:31:46,770 --> 00:31:58,280
of the symbols okay so clearly another

00:31:54,600 --> 00:32:02,580
thing that we can get you know is that

00:31:58,280 --> 00:32:05,610
if we use the perf script we also can

00:32:02,580 --> 00:32:08,190
post the process for cozia to chase data

00:32:05,610 --> 00:32:09,840
so that means that the perfect script

00:32:08,190 --> 00:32:13,440
can Center the cursor at the sample

00:32:09,840 --> 00:32:16,740
stream to the patient script so here you

00:32:13,440 --> 00:32:18,720
can sample that this is in for the perf

00:32:16,740 --> 00:32:21,419
decoding either were to decode the

00:32:18,720 --> 00:32:23,909
package and generate the branches

00:32:21,419 --> 00:32:26,100
samples the purchased samples where be

00:32:23,909 --> 00:32:29,250
sent out into the pipe can be sent to

00:32:26,100 --> 00:32:31,950
the Python script so the passive script

00:32:29,250 --> 00:32:33,900
can get you know I read the branch and

00:32:31,950 --> 00:32:36,929
the address and the next data address

00:32:33,900 --> 00:32:40,020
and the peasant script can collect with

00:32:36,929 --> 00:32:44,820
object down command and with the VM

00:32:40,020 --> 00:32:47,730
Linux such kind of we fire with the

00:32:44,820 --> 00:32:49,770
simple simply bugging symbols so finally

00:32:47,730 --> 00:32:52,620
we can use this way to do the T State

00:32:49,770 --> 00:32:55,740
emblem so felony can't get to know the

00:32:52,620 --> 00:32:58,620
readable program flow actually this

00:32:55,740 --> 00:33:00,450
which came from the different the the

00:32:58,620 --> 00:33:03,330
Creator the continuous the interaction

00:33:00,450 --> 00:33:07,320
between the branch instructions so

00:33:03,330 --> 00:33:10,500
capture the the deter the flow okay so

00:33:07,320 --> 00:33:13,559
this two party just that you access the

00:33:10,500 --> 00:33:15,270
coset related the tracing data so the

00:33:13,559 --> 00:33:18,490
third party is the one to talk about a

00:33:15,270 --> 00:33:21,790
1d bug in story and the DeBellis story

00:33:18,490 --> 00:33:25,240
Jenny connected with the co site related

00:33:21,790 --> 00:33:30,430
tracing with the purse so the country

00:33:25,240 --> 00:33:34,120
that the slurry that the periphery works

00:33:30,430 --> 00:33:35,590
with a compiler for optimization so the

00:33:34,120 --> 00:33:37,690
question that I want to optimize the

00:33:35,590 --> 00:33:41,200
performance for my program and

00:33:37,690 --> 00:33:44,320
especially for some small piece code for

00:33:41,200 --> 00:33:45,940
algorithm does they have some advanced

00:33:44,320 --> 00:33:50,650
the method for performance of the

00:33:45,940 --> 00:33:54,040
Malaysian on platform so one note is

00:33:50,650 --> 00:33:56,770
that the algorithm the code might have

00:33:54,040 --> 00:33:59,080
complex logic so it has many branch

00:33:56,770 --> 00:34:02,410
instructions and dependence when you get

00:33:59,080 --> 00:34:04,210
execution compiler is good at the

00:34:02,410 --> 00:34:06,970
instruction scheduling and recall

00:34:04,210 --> 00:34:09,430
ordering at the compilation time so it

00:34:06,970 --> 00:34:11,920
can provide the option to show three

00:34:09,430 --> 00:34:14,350
four steps to optimization but the

00:34:11,920 --> 00:34:18,280
comparator is absent you know the

00:34:14,350 --> 00:34:21,280
program execution runtime information so

00:34:18,280 --> 00:34:24,520
perf profanity that can be used and

00:34:21,280 --> 00:34:27,040
feedback for the better compiler so this

00:34:24,520 --> 00:34:31,420
can be used for his prom what once the

00:34:27,040 --> 00:34:33,400
opening my finishing method so in this

00:34:31,420 --> 00:34:36,040
example with you the bubble sort

00:34:33,400 --> 00:34:38,620
I don't want to spend much time for this

00:34:36,040 --> 00:34:42,370
because I just copy the code from the

00:34:38,620 --> 00:34:48,090
GCC wiki page for this code so it adjust

00:34:42,370 --> 00:34:50,920
to the pub assorting 437 the IP elements

00:34:48,090 --> 00:34:53,740
so first of all optimization which can

00:34:50,920 --> 00:34:55,630
check with the static optimization so

00:34:53,740 --> 00:34:57,970
with the compiler flag attached or three

00:34:55,630 --> 00:35:01,020
so you we can see that live without an

00:34:57,970 --> 00:35:07,360
optimization this program will take

00:35:01,020 --> 00:35:10,800
about 30,000 35 seconds to finish the

00:35:07,360 --> 00:35:13,840
sorting but after we add the

00:35:10,800 --> 00:35:18,300
optimization optimization flag or three

00:35:13,840 --> 00:35:22,980
we can say that it were to take about

00:35:18,300 --> 00:35:25,690
6.6 second to finish the execution so

00:35:22,980 --> 00:35:28,390
but compiler actually provide more

00:35:25,690 --> 00:35:31,730
advanced optimization method is based on

00:35:28,390 --> 00:35:34,430
the after all feedback

00:35:31,730 --> 00:35:36,920
the optimization so the basically the

00:35:34,430 --> 00:35:39,950
methodology for the FDA is that at first

00:35:36,920 --> 00:35:43,070
it were to build I instrumental

00:35:39,950 --> 00:35:45,020
diversity and the of the program for

00:35:43,070 --> 00:35:48,050
profiling so we can say that it won't

00:35:45,020 --> 00:35:50,030
build the compiler a compilation the

00:35:48,050 --> 00:35:52,700
program we need to specify profile

00:35:50,030 --> 00:35:55,880
generate so it were to generate a one

00:35:52,700 --> 00:35:58,160
into many the version battery so we ran

00:35:55,880 --> 00:36:02,000
this battery and we can connect the

00:35:58,160 --> 00:36:04,730
execution profile profile so felony we

00:36:02,000 --> 00:36:07,339
can get a one fair name the sort G C D a

00:36:04,730 --> 00:36:09,230
so this fair will be as the training

00:36:07,339 --> 00:36:11,869
data for the compiler so compiler can

00:36:09,230 --> 00:36:14,450
use this state training data to generate

00:36:11,869 --> 00:36:17,060
optimize the battery so finally we can

00:36:14,450 --> 00:36:22,280
see these are one generated optimize

00:36:17,060 --> 00:36:26,270
battery where take 26.6 about the second

00:36:22,280 --> 00:36:30,589
to finish the execution so after all

00:36:26,270 --> 00:36:33,829
there should come in for the app do is

00:36:30,589 --> 00:36:36,109
that after you need instrumentation

00:36:33,829 --> 00:36:37,579
build and run with performance we can

00:36:36,109 --> 00:36:41,390
see that actually the instrument

00:36:37,579 --> 00:36:48,500
performance is much worse than before

00:36:41,390 --> 00:36:50,510
that 30 35 second so that's that this is

00:36:48,500 --> 00:36:54,770
difficult for applying in the production

00:36:50,510 --> 00:36:57,050
so alternate alternate evening the

00:36:54,770 --> 00:36:59,869
compiler can rely on the profiling data

00:36:57,050 --> 00:37:03,050
at the runtime and feedback so this can

00:36:59,869 --> 00:37:05,569
avoid the instrumentation build so this

00:37:03,050 --> 00:37:07,790
is why we have an auto a few although a

00:37:05,569 --> 00:37:10,190
few a stand for the automatic feedback

00:37:07,790 --> 00:37:13,040
directive optimization so actually this

00:37:10,190 --> 00:37:14,930
is introduced by the Google so the idea

00:37:13,040 --> 00:37:17,630
is that it want to synchronize the

00:37:14,930 --> 00:37:20,510
deployment of FTO by using the sample of

00:37:17,630 --> 00:37:22,339
hardware performance monitor so finally

00:37:20,510 --> 00:37:24,980
we can see that the working flow you

00:37:22,339 --> 00:37:26,780
change it like we first we need you the

00:37:24,980 --> 00:37:31,339
perf do the profiling and gather

00:37:26,780 --> 00:37:33,619
profaning data and we can use the Google

00:37:31,339 --> 00:37:36,290
provided a command to come on

00:37:33,619 --> 00:37:39,079
to convert the profanity that you check

00:37:36,290 --> 00:37:41,210
our formatted date data this data can be

00:37:39,079 --> 00:37:44,200
used at the training data and finally we

00:37:41,210 --> 00:37:45,950
can repeal the pylori so generate the

00:37:44,200 --> 00:37:50,180
optimize of the battery

00:37:45,950 --> 00:37:52,309
so this this is used by the auto I've

00:37:50,180 --> 00:37:56,619
deal with no overhead because it don't

00:37:52,309 --> 00:38:01,299
introduce the instrumented battery but

00:37:56,619 --> 00:38:05,750
this have different the usage case um

00:38:01,299 --> 00:38:10,040
x86 platform and arm platform the reason

00:38:05,750 --> 00:38:15,109
that if we wanted to use the auto FD a--

00:38:10,040 --> 00:38:18,500
with perv we cannot only use the your

00:38:15,109 --> 00:38:20,809
the statute studies statistical

00:38:18,500 --> 00:38:23,900
profiling because the statistical

00:38:20,809 --> 00:38:27,230
profile just help identify a particular

00:38:23,900 --> 00:38:30,190
code block is both like but either had

00:38:27,230 --> 00:38:33,260
no idea what are the coder past

00:38:30,190 --> 00:38:35,240
execution to cause the PATA Negra so

00:38:33,260 --> 00:38:38,599
this is why the perf record the provider

00:38:35,240 --> 00:38:41,210
another option that's be for someone in

00:38:38,599 --> 00:38:44,210
the branch stack to knock the continuous

00:38:41,210 --> 00:38:47,089
in the branches so you this way we can

00:38:44,210 --> 00:38:50,410
get to know how the hot spot of the code

00:38:47,089 --> 00:38:53,240
that you run from which the code passed

00:38:50,410 --> 00:38:56,089
this feature is supported by for example

00:38:53,240 --> 00:38:59,089
on the x86 the platform your the master

00:38:56,089 --> 00:39:02,119
branch records with harbor feature so we

00:38:59,089 --> 00:39:04,790
can use the command first layer the - be

00:39:02,119 --> 00:39:07,940
for the peripheral record to capture the

00:39:04,790 --> 00:39:10,520
treason beta and then your the created g

00:39:07,940 --> 00:39:13,520
call to convert it to the training data

00:39:10,520 --> 00:39:16,430
but on platforms of the am/pm you learn

00:39:13,520 --> 00:39:19,250
to provide such kind of the features so

00:39:16,430 --> 00:39:22,579
it cannot to provide that the branches

00:39:19,250 --> 00:39:24,740
take some pony so this way we can see

00:39:22,579 --> 00:39:28,819
that actually you in arm PM you driver

00:39:24,740 --> 00:39:31,040
it returns a failure if we pass the that

00:39:28,819 --> 00:39:36,140
speed option for the nasa branch it

00:39:31,040 --> 00:39:38,960
records but we can remain on the course

00:39:36,140 --> 00:39:43,069
ID the trees data for these these kind

00:39:38,960 --> 00:39:45,950
of features so the the here the

00:39:43,069 --> 00:39:48,319
methodology that the package can be

00:39:45,950 --> 00:39:51,619
converted to the branches samples and

00:39:48,319 --> 00:39:54,829
then we can use the periphery check list

00:39:51,619 --> 00:39:57,180
of a command to generate synthesize

00:39:54,829 --> 00:39:59,760
other types the

00:39:57,180 --> 00:40:02,910
samples so here we can see that we can

00:39:59,760 --> 00:40:08,369
inject in generated in traction samples

00:40:02,910 --> 00:40:10,109
with a specific Lambo interview with

00:40:08,369 --> 00:40:15,300
option test data i trace

00:40:10,109 --> 00:40:18,569
so here the this end means that how many

00:40:15,300 --> 00:40:22,680
the instruction interviews where to

00:40:18,569 --> 00:40:25,470
inject one instruction sample we also

00:40:22,680 --> 00:40:30,030
can injector for the nasa branch is the

00:40:25,470 --> 00:40:33,270
example so here we need to specify a IR

00:40:30,030 --> 00:40:36,079
and the specified this and not means of

00:40:33,270 --> 00:40:40,500
the instruction interview this means the

00:40:36,079 --> 00:40:42,660
stack the branches there cadets so for

00:40:40,500 --> 00:40:46,339
example here specifies 60 means that

00:40:42,660 --> 00:40:48,630
they have continuous 16 branch

00:40:46,339 --> 00:40:56,099
instruction where we record for this

00:40:48,630 --> 00:40:59,640
deck so this is the after we use the co

00:40:56,099 --> 00:41:02,010
site for auto F do this is step the ter

00:40:59,640 --> 00:41:04,579
steps for the for this so first of all

00:41:02,010 --> 00:41:08,400
data we can use the capture the cassette

00:41:04,579 --> 00:41:11,579
sample program so here we need we can

00:41:08,400 --> 00:41:14,780
specify your the purpose record just

00:41:11,579 --> 00:41:18,359
attach that programming to one specific

00:41:14,780 --> 00:41:22,859
CPU the second step that we use the

00:41:18,359 --> 00:41:25,049
perfect to count cube you you the

00:41:22,859 --> 00:41:27,569
original the perfect data to the

00:41:25,049 --> 00:41:30,660
injected data with the samples so here

00:41:27,569 --> 00:41:34,260
we specify we need to generate the

00:41:30,660 --> 00:41:39,270
synthesize the branches stack samples

00:41:34,260 --> 00:41:41,339
with 64 branches take naps so send third

00:41:39,270 --> 00:41:43,020
step with that we needed to convert to

00:41:41,339 --> 00:41:46,140
the property that you that you call for

00:41:43,020 --> 00:41:48,540
meta training data so here we need to

00:41:46,140 --> 00:41:51,470
you to create Kiko they are output that

00:41:48,540 --> 00:41:55,710
you the sort to cover this training data

00:41:51,470 --> 00:41:59,430
so this not step that we need to specify

00:41:55,710 --> 00:42:01,559
that there we have the Chico at the

00:41:59,430 --> 00:42:02,490
training data and review the compiled

00:42:01,559 --> 00:42:04,859
binary

00:42:02,490 --> 00:42:07,440
so finally we were to get out the

00:42:04,859 --> 00:42:08,000
generator or the optimize the Valerie

00:42:07,440 --> 00:42:16,250
and the

00:42:08,000 --> 00:42:19,280
right so but when I ready to finish this

00:42:16,250 --> 00:42:22,190
trial actually that exchanges that

00:42:19,280 --> 00:42:24,230
information with the magnet so they

00:42:22,190 --> 00:42:27,290
actually have more advanced the UCT for

00:42:24,230 --> 00:42:31,490
auto a video with the cosines so suggest

00:42:27,290 --> 00:42:34,609
that you you have interesting you can

00:42:31,490 --> 00:42:36,680
reveal mad niches the session in this

00:42:34,609 --> 00:42:38,690
connect for hardware treason and in

00:42:36,680 --> 00:42:41,030
excuse technicals and the future

00:42:38,690 --> 00:42:44,900
directions it were introduced and more

00:42:41,030 --> 00:42:47,359
advanced profile profiling techniques

00:42:44,900 --> 00:42:50,210
based on the course site so the

00:42:47,359 --> 00:42:52,609
basically the idea is the same with the

00:42:50,210 --> 00:42:57,290
slightly master I've but the even more

00:42:52,609 --> 00:42:59,420
advanced the feature naming straw be so

00:42:57,290 --> 00:43:03,140
you know with a muchness twist data with

00:42:59,420 --> 00:43:07,400
a better result so this is the one

00:43:03,140 --> 00:43:10,730
information in here wanted to deliver so

00:43:07,400 --> 00:43:13,670
also as I have been finished so I think

00:43:10,730 --> 00:43:16,089
we have several minutes so you have some

00:43:13,670 --> 00:43:16,089
fashion

00:43:20,760 --> 00:43:25,470
okay thank you guys and you have any

00:43:23,490 --> 00:43:27,870
other questions or following questions

00:43:25,470 --> 00:43:30,240
also suggest that you can send a

00:43:27,870 --> 00:43:33,120
question to the support daughter near ro

00:43:30,240 --> 00:43:35,550
dah dah dah G so we have learned life's

00:43:33,120 --> 00:43:38,520
a lifetime warranty for these chimneys

00:43:35,550 --> 00:43:41,310
right as you and before with Imogene

00:43:38,520 --> 00:43:42,490
yeah okay thank you

00:43:41,310 --> 00:43:46,100
Thanks

00:43:42,490 --> 00:43:51,100
[Applause]

00:43:46,100 --> 00:43:51,100

YouTube URL: https://www.youtube.com/watch?v=xV4UHWLH_7Y


