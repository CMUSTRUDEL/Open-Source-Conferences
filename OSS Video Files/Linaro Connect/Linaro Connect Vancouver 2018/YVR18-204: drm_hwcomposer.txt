Title: YVR18-204: drm_hwcomposer
Publication date: 2019-05-09
Playlist: Linaro Connect Vancouver 2018
Description: 
	This talk will cover some background and history on the Android graphics stack and the HardwareComposer HAL, then talk about recent work done with the drm_hwcomposer implementation. It will also cover efforts going forward, opportunities for collaboration and recommendations for vendors.
Captions: 
	00:00:02,230 --> 00:00:07,240
[Music]

00:00:09,150 --> 00:00:12,579
so basically in Android

00:00:11,349 --> 00:00:14,349
everything you see on the screen every

00:00:12,579 --> 00:00:15,789
little button every text they're all

00:00:14,349 --> 00:00:18,700
layers and layers and layers of button

00:00:15,789 --> 00:00:22,030
buffers and all of these buffers need to

00:00:18,700 --> 00:00:23,620
be kind of combined together into a what

00:00:22,030 --> 00:00:25,450
you see on the screen and that is called

00:00:23,620 --> 00:00:28,480
compositing normally we think of this as

00:00:25,450 --> 00:00:29,740
being done by the GPU and so you have

00:00:28,480 --> 00:00:31,600
all of these different buffers and then

00:00:29,740 --> 00:00:33,940
the GPU kind of squishes them all into

00:00:31,600 --> 00:00:37,719
one frame and then sends it out to the

00:00:33,940 --> 00:00:39,249
display but really on you know mobile

00:00:37,719 --> 00:00:41,199
devices as well as even just app

00:00:39,249 --> 00:00:42,370
Hardware now there's a display

00:00:41,199 --> 00:00:44,109
controller that sits in front of that

00:00:42,370 --> 00:00:46,749
that can do some fairly simple graphic

00:00:44,109 --> 00:00:48,550
operations and that includes doing

00:00:46,749 --> 00:00:50,350
things like compositing and this is

00:00:48,550 --> 00:00:53,409
really nice because for a limited set of

00:00:50,350 --> 00:00:56,109
buffers we're able to push these out and

00:00:53,409 --> 00:00:57,879
have the display do the compositing and

00:00:56,109 --> 00:00:59,710
that basically allows the GPU to either

00:00:57,879 --> 00:01:02,139
be left off to save power or we could

00:00:59,710 --> 00:01:06,430
you know let it be busy filling buffers

00:01:02,139 --> 00:01:08,170
with things to draw now usually we have

00:01:06,430 --> 00:01:11,020
more than that small set of buffers that

00:01:08,170 --> 00:01:13,080
the display controller can just row so

00:01:11,020 --> 00:01:16,240
we still need to have the GPU

00:01:13,080 --> 00:01:17,650
compositing some and kind of pushing the

00:01:16,240 --> 00:01:20,530
results of that to the display as well

00:01:17,650 --> 00:01:22,540
and so really this deciding you know

00:01:20,530 --> 00:01:23,800
which layers are going to go to which

00:01:22,540 --> 00:01:25,120
planes in the display and which are

00:01:23,800 --> 00:01:28,110
going to be squished down by the GPU

00:01:25,120 --> 00:01:30,400
this is the job of the hardware composer

00:01:28,110 --> 00:01:33,460
so now I'm gonna try to cover a bit of

00:01:30,400 --> 00:01:35,080
history and background originally in

00:01:33,460 --> 00:01:36,430
Android we had the frame buffer device T

00:01:35,080 --> 00:01:38,470
this was part of the kind of the grout

00:01:36,430 --> 00:01:39,700
code and was just a simple act simple

00:01:38,470 --> 00:01:41,950
way to access to the frame buffer device

00:01:39,700 --> 00:01:43,450
it provided just a simple post hook in

00:01:41,950 --> 00:01:46,960
order to push that free buffer to the

00:01:43,450 --> 00:01:48,850
display then you know with Ice Cream

00:01:46,960 --> 00:01:53,290
Sandwich a number of different vendors

00:01:48,850 --> 00:01:55,780
had done their own things and years to

00:01:53,290 --> 00:01:57,880
accelerate things and so the Android

00:01:55,780 --> 00:02:00,670
developers needed a Hal to kind of

00:01:57,880 --> 00:02:02,530
abstract away those differences and so

00:02:00,670 --> 00:02:04,270
basically they created the hardwood

00:02:02,530 --> 00:02:06,730
composer one inner for how that

00:02:04,270 --> 00:02:08,770
basically allowed them to kind of

00:02:06,730 --> 00:02:10,390
abstract overlays and 2d bleeders it was

00:02:08,770 --> 00:02:12,100
pretty simple had you know three

00:02:10,390 --> 00:02:13,930
interfaces just to prepare to which

00:02:12,100 --> 00:02:15,849
basically allows you to configure things

00:02:13,930 --> 00:02:17,260
that would do the draw and then vsync

00:02:15,849 --> 00:02:22,239
basically a callback when the draw was

00:02:17,260 --> 00:02:24,670
done with jellybeans they introduced the

00:02:22,239 --> 00:02:27,219
Android sync framework this is a little

00:02:24,670 --> 00:02:30,790
more complicated basically allows kind

00:02:27,219 --> 00:02:32,230
of this way of kind of tracking the

00:02:30,790 --> 00:02:34,409
ownership of various buffers as they

00:02:32,230 --> 00:02:37,510
move through the graphics stack

00:02:34,409 --> 00:02:40,269
basically allows you to enable some

00:02:37,510 --> 00:02:42,879
layer of some amount of parallelization

00:02:40,269 --> 00:02:45,760
as having multiple devices work on the

00:02:42,879 --> 00:02:47,019
same buffers and to me that's kind of

00:02:45,760 --> 00:02:48,549
conceptually similar to condition

00:02:47,019 --> 00:02:52,329
variables but they're able to be nested

00:02:48,549 --> 00:02:53,560
somewhat so trying to kind of go over

00:02:52,329 --> 00:02:56,200
kind of why this is needed

00:02:53,560 --> 00:02:59,109
the original just Singer buffering kind

00:02:56,200 --> 00:03:00,790
of a simple case where people would draw

00:02:59,109 --> 00:03:03,579
into a buffer and then display that

00:03:00,790 --> 00:03:04,810
buffer ideally on the vsync but quite

00:03:03,579 --> 00:03:06,730
often you'd end up the coot-tha case

00:03:04,810 --> 00:03:08,409
without any control GPUs drawing into

00:03:06,730 --> 00:03:10,750
the buffer at the same time that it's

00:03:08,409 --> 00:03:12,700
being displayed and this creates tearing

00:03:10,750 --> 00:03:13,959
which I'm sure everyone's seen at some

00:03:12,700 --> 00:03:15,939
point where you have basically two

00:03:13,959 --> 00:03:19,690
frames that are being displayed at the

00:03:15,939 --> 00:03:21,250
same time on the screen the canonical

00:03:19,690 --> 00:03:22,540
solution of this is to use double

00:03:21,250 --> 00:03:24,099
buffering basically you just have two

00:03:22,540 --> 00:03:25,479
buffers and you have the GPU right into

00:03:24,099 --> 00:03:26,919
one buffer and the other buffer being

00:03:25,479 --> 00:03:28,690
displayed and then on the vsync you just

00:03:26,919 --> 00:03:33,189
switch the pointers and you can go in

00:03:28,690 --> 00:03:34,299
like that without any tearing but again

00:03:33,189 --> 00:03:35,769
when we were talking about having those

00:03:34,299 --> 00:03:37,000
layers and layers of buffers it's

00:03:35,769 --> 00:03:39,970
actually more complicated we're dealing

00:03:37,000 --> 00:03:41,379
with buffer sets and so the GPU is going

00:03:39,970 --> 00:03:42,699
to be writing into a set of buffers and

00:03:41,379 --> 00:03:44,349
then we have a set of buffers that we

00:03:42,699 --> 00:03:45,939
need to display and so really there's

00:03:44,349 --> 00:03:47,859
another step in this where we have to

00:03:45,939 --> 00:03:49,569
kind of set up how those buffers are

00:03:47,859 --> 00:03:51,669
going to be composited in the display

00:03:49,569 --> 00:03:52,959
controller and so now we basically have

00:03:51,669 --> 00:03:54,250
three stages that we have to deal with

00:03:52,959 --> 00:03:58,269
and we want to be able to keep all of

00:03:54,250 --> 00:04:00,939
these busy so kind of the simple next

00:03:58,269 --> 00:04:02,709
step there would be triple buffering and

00:04:00,939 --> 00:04:04,959
so this keeps every stage in the

00:04:02,709 --> 00:04:06,699
pipeline busy but it has the downside

00:04:04,959 --> 00:04:08,439
that we you know are basically

00:04:06,699 --> 00:04:12,099
increasing the amount of latency that

00:04:08,439 --> 00:04:15,400
you have things like touch events by 16

00:04:12,099 --> 00:04:18,789
milliseconds so that could be a big

00:04:15,400 --> 00:04:21,250
negative for interactivity so a little

00:04:18,789 --> 00:04:24,430
dance there ideally what we want to be

00:04:21,250 --> 00:04:26,440
able to do is have the GPU being able to

00:04:24,430 --> 00:04:27,860
draw into the buffers at the same time

00:04:26,440 --> 00:04:29,509
that we're setting up how those BA

00:04:27,860 --> 00:04:32,509
are gonna be composited in the display

00:04:29,509 --> 00:04:35,180
controller and that way we can you know

00:04:32,509 --> 00:04:38,060
basically still only have two buffers

00:04:35,180 --> 00:04:41,509
minimal latency but to keep everything

00:04:38,060 --> 00:04:44,750
busy and this in order to do this we

00:04:41,509 --> 00:04:46,699
need to have some way of knowing win

00:04:44,750 --> 00:04:49,159
both the GPU and the display setup are

00:04:46,699 --> 00:04:52,389
finished with their work and this is

00:04:49,159 --> 00:04:54,800
what the Android sync kind of provides

00:04:52,389 --> 00:04:56,360
these timelines these sync timelines are

00:04:54,800 --> 00:04:58,520
basically per device so the top one

00:04:56,360 --> 00:05:00,529
might be something for the GPU in the

00:04:58,520 --> 00:05:02,300
bottom one let's say is for the display

00:05:00,529 --> 00:05:04,460
controller and you're basically able to

00:05:02,300 --> 00:05:07,009
just kind of mark points in time when

00:05:04,460 --> 00:05:08,180
certain work would be done and so for

00:05:07,009 --> 00:05:09,979
example you could set a sync point

00:05:08,180 --> 00:05:11,719
that's on to which might be when you

00:05:09,979 --> 00:05:14,240
know the GPU is done drawing into a set

00:05:11,719 --> 00:05:15,979
of buffers and then the display

00:05:14,240 --> 00:05:21,139
controller at time H it's going to be

00:05:15,979 --> 00:05:23,419
finished with its configuring the

00:05:21,139 --> 00:05:25,129
buffers are ready to display and that

00:05:23,419 --> 00:05:26,509
point the nice thing with these sync

00:05:25,129 --> 00:05:29,330
points is that they can be wrapped up in

00:05:26,509 --> 00:05:30,979
a sync fence and once all of the sync

00:05:29,330 --> 00:05:32,659
points inside of that fence have fired

00:05:30,979 --> 00:05:36,099
that same fence will fire it and we know

00:05:32,659 --> 00:05:39,560
that we can push it out to the display

00:05:36,099 --> 00:05:41,539
so the next step in in sort of the

00:05:39,560 --> 00:05:42,919
Android graphics history was the atomic

00:05:41,539 --> 00:05:45,529
display framework that showed up with

00:05:42,919 --> 00:05:47,719
lollipop this is really nice because it

00:05:45,529 --> 00:05:48,729
allowed kind of a way of providing sort

00:05:47,719 --> 00:05:50,539
of all-or-nothing

00:05:48,729 --> 00:05:53,870
configuration changes to the display

00:05:50,539 --> 00:05:55,219
controller you know it avoids tearing

00:05:53,870 --> 00:05:56,599
and glitches but kind of more

00:05:55,219 --> 00:05:58,099
importantly also avoids getting into bad

00:05:56,599 --> 00:06:00,139
Hardware States because sometimes you

00:05:58,099 --> 00:06:02,089
can walk up Hardware if you set up the

00:06:00,139 --> 00:06:03,349
wrong things often when you have a

00:06:02,089 --> 00:06:05,029
number of these planes that you're going

00:06:03,349 --> 00:06:06,650
through configuring if you get through

00:06:05,029 --> 00:06:07,969
all down to the last one and then you

00:06:06,650 --> 00:06:09,349
find some error that you know the

00:06:07,969 --> 00:06:11,629
controller can actually display that

00:06:09,349 --> 00:06:13,580
backing all of that state out is really

00:06:11,629 --> 00:06:15,620
complicated and so this basically

00:06:13,580 --> 00:06:18,349
provided infrastructure for that kind of

00:06:15,620 --> 00:06:19,639
management of that state changes the

00:06:18,349 --> 00:06:21,229
other cool part with this is that it was

00:06:19,639 --> 00:06:24,319
tied to the saint's point so they could

00:06:21,229 --> 00:06:27,199
basically pass in a sync fence with the

00:06:24,319 --> 00:06:29,360
display settings and then once that

00:06:27,199 --> 00:06:31,490
fence had fired they had known that

00:06:29,360 --> 00:06:35,659
everything was done on those buffers and

00:06:31,490 --> 00:06:36,770
they could be displayed so to kind of go

00:06:35,659 --> 00:06:38,750
through an illustration of how this

00:06:36,770 --> 00:06:40,720
might be useful here's kind of a

00:06:38,750 --> 00:06:42,550
standard Android home screen

00:06:40,720 --> 00:06:44,590
and we've got you know for simple lairs

00:06:42,550 --> 00:06:46,510
status bar launching UI navigation bar

00:06:44,590 --> 00:06:49,750
and a background layer all of these are

00:06:46,510 --> 00:06:50,830
32 but awful blend buffers the only one

00:06:49,750 --> 00:06:52,720
that's maybe interested is the

00:06:50,830 --> 00:06:54,700
background layer which might be a fairly

00:06:52,720 --> 00:06:58,570
large buffer that we're doing a viewport

00:06:54,700 --> 00:07:02,140
crop on and we have some friend that

00:06:58,570 --> 00:07:04,630
calls in on some sort of secure video

00:07:02,140 --> 00:07:05,710
chat tool and we've got basically two

00:07:04,630 --> 00:07:08,110
more layers we have to deal with we've

00:07:05,710 --> 00:07:10,090
got some you know alpha blended UI that

00:07:08,110 --> 00:07:11,170
we need to kind of put on top and then

00:07:10,090 --> 00:07:13,810
we also have the picture-in-picture

00:07:11,170 --> 00:07:16,060
video which might be a secure buffer and

00:07:13,810 --> 00:07:18,040
a different format and so now we have

00:07:16,060 --> 00:07:20,020
more layers than we can really display

00:07:18,040 --> 00:07:23,530
at one time in the display controller

00:07:20,020 --> 00:07:24,970
and so we want to find some way to solve

00:07:23,530 --> 00:07:27,130
this and so we need to kind of squish

00:07:24,970 --> 00:07:30,310
the bottom set of layers down and the

00:07:27,130 --> 00:07:31,570
GPU and then we can push this out to the

00:07:30,310 --> 00:07:33,880
display now when we look at what

00:07:31,570 --> 00:07:35,800
actually changed there we went from the

00:07:33,880 --> 00:07:37,150
status bar launcher navigation bar and

00:07:35,800 --> 00:07:38,710
background layer to the

00:07:37,150 --> 00:07:40,210
picture-in-picture UI the

00:07:38,710 --> 00:07:43,390
picture-in-picture the status bar and

00:07:40,210 --> 00:07:44,920
the GPU squished scene and ignoring you

00:07:43,390 --> 00:07:46,270
know because obviously the x and y's of

00:07:44,920 --> 00:07:47,350
each of these buffers and the sizes are

00:07:46,270 --> 00:07:48,790
gonna be slightly different so that's

00:07:47,350 --> 00:07:50,740
kind of a change that would be constant

00:07:48,790 --> 00:07:52,060
across the B's but if you look at kind

00:07:50,740 --> 00:07:54,340
of just the the format's that we're

00:07:52,060 --> 00:07:55,810
dealing with and the other display

00:07:54,340 --> 00:07:56,830
properties that we have to be changed

00:07:55,810 --> 00:07:58,210
you've got you know sort of the status

00:07:56,830 --> 00:07:59,560
part of the picture and picture UI it's

00:07:58,210 --> 00:08:01,780
mostly the same so just the excess of

00:07:59,560 --> 00:08:04,510
misers your interchange the launcher UI

00:08:01,780 --> 00:08:07,990
we went from basically a 32-bit RGB a

00:08:04,510 --> 00:08:09,340
buffer to a secured buffer so we had to

00:08:07,990 --> 00:08:11,680
switch in secure mode we also have to

00:08:09,340 --> 00:08:14,770
set to you know why UV mode because it's

00:08:11,680 --> 00:08:16,060
in a different format the navigation bar

00:08:14,770 --> 00:08:18,220
in the status bar basically the same

00:08:16,060 --> 00:08:20,169
just X's and Y's change and then on the

00:08:18,220 --> 00:08:22,960
last one we went from basically a

00:08:20,169 --> 00:08:24,910
viewport cropped to GPU squished scene

00:08:22,960 --> 00:08:27,460
and so we need to change that buffer

00:08:24,910 --> 00:08:29,530
crop and so you could imagine that if we

00:08:27,460 --> 00:08:31,360
were trying to make this transition you

00:08:29,530 --> 00:08:32,830
know between frames we need to make

00:08:31,360 --> 00:08:34,419
everything happen all at once or

00:08:32,830 --> 00:08:36,010
something odd happened so we've got

00:08:34,419 --> 00:08:37,840
through basically everything except for

00:08:36,010 --> 00:08:40,090
the last thing you might run into kind

00:08:37,840 --> 00:08:42,280
of a glitch for a frame where that crop

00:08:40,090 --> 00:08:44,740
property was still on the screen and so

00:08:42,280 --> 00:08:47,140
it kind of scale or probably redraw in a

00:08:44,740 --> 00:08:49,630
different way so that's not what we want

00:08:47,140 --> 00:08:52,290
that's really kind of what the ADF

00:08:49,630 --> 00:08:52,290
provided

00:08:52,750 --> 00:08:59,990
with nougat basically the harder

00:08:56,450 --> 00:09:01,430
composure - how was introduced this

00:08:59,990 --> 00:09:02,840
basically shows just kind of how complex

00:09:01,430 --> 00:09:04,940
the heart of composure had gotten over

00:09:02,840 --> 00:09:07,130
the time so it's now 43 methods rather

00:09:04,940 --> 00:09:09,560
than three so it's gotten to be kind of

00:09:07,130 --> 00:09:12,140
a lot of complicated code the other

00:09:09,560 --> 00:09:13,850
change here that was notable was that

00:09:12,140 --> 00:09:15,350
moved to non speculum emceeing this is

00:09:13,850 --> 00:09:17,390
pretty subtle but basically instead of

00:09:15,350 --> 00:09:18,230
this fences signaling that the contents

00:09:17,390 --> 00:09:19,880
no longer needed

00:09:18,230 --> 00:09:23,600
it was signaling if the content had been

00:09:19,880 --> 00:09:25,430
displayed and then there's additional

00:09:23,600 --> 00:09:29,420
support for multiple display displays in

00:09:25,430 --> 00:09:32,390
the hardware - so outside of the Android

00:09:29,420 --> 00:09:33,110
world stuff was also changing in the

00:09:32,390 --> 00:09:37,880
kernel community

00:09:33,110 --> 00:09:39,860
so in 4.6 DRM fences landed in a lot of

00:09:37,880 --> 00:09:41,720
ways this is sort of just bizarro

00:09:39,860 --> 00:09:44,150
Android sync it's the concepts are very

00:09:41,720 --> 00:09:45,350
similar but you know the names are

00:09:44,150 --> 00:09:46,880
different and they're just close enough

00:09:45,350 --> 00:09:49,090
to be really confusing so instead of

00:09:46,880 --> 00:09:52,310
sync points we have fences instead of

00:09:49,090 --> 00:09:54,500
sync fences we have sync files and then

00:09:52,310 --> 00:09:57,050
we instead of timelines we have contexts

00:09:54,500 --> 00:10:01,760
but conceptually it's basically very

00:09:57,050 --> 00:10:03,800
similar and then in 410 the atomic kms

00:10:01,760 --> 00:10:07,490
and erm code landed thanks to Robert

00:10:03,800 --> 00:10:08,870
Clark and lots of others and at a high

00:10:07,490 --> 00:10:10,880
level this is very similar to androids

00:10:08,870 --> 00:10:12,890
ATF but it's actually properly upstream

00:10:10,880 --> 00:10:14,600
which is really nice it allows for that

00:10:12,890 --> 00:10:17,540
all-or-nothing setting of display

00:10:14,600 --> 00:10:20,690
settings and signals with DRM fences

00:10:17,540 --> 00:10:22,940
instead of Android sync points and this

00:10:20,690 --> 00:10:25,310
landed in 410 but Marissa wall back

00:10:22,940 --> 00:10:29,390
ported it to Android 4 9 so it's usable

00:10:25,310 --> 00:10:32,480
for devices using 4 9 and that gets us

00:10:29,390 --> 00:10:35,150
to the DRM hardware composer all right

00:10:32,480 --> 00:10:36,890
so the DRM hardware composer was a

00:10:35,150 --> 00:10:40,400
project that was done by the chrome OS

00:10:36,890 --> 00:10:43,190
team it was implemented for the pixel C

00:10:40,400 --> 00:10:45,080
device and it uses the DRM and kms

00:10:43,190 --> 00:10:48,740
interfaces it was a hard one composer

00:10:45,080 --> 00:10:50,750
implementation they did prototype a

00:10:48,740 --> 00:10:52,640
hardware composer - implementation that

00:10:50,750 --> 00:10:53,960
did utilize the atomic kms interfaces

00:10:52,640 --> 00:10:57,080
but that wasn't anything that actually

00:10:53,960 --> 00:10:58,160
shipped on a device my understanding

00:10:57,080 --> 00:11:00,830
after a kind of a little bit of idle

00:10:58,160 --> 00:11:02,750
time a Robert Foss and Robert Rob

00:11:00,830 --> 00:11:05,000
herring in the community kind of picked

00:11:02,750 --> 00:11:07,790
this up and started working on it to get

00:11:05,000 --> 00:11:09,770
to work on various dev boards and so

00:11:07,790 --> 00:11:12,710
they've got minutes to get it working on

00:11:09,770 --> 00:11:14,510
qmu with Virgil the DB for 10 the DB 820

00:11:12,710 --> 00:11:17,570
it's been gotten to work on the

00:11:14,510 --> 00:11:19,160
Raspberry Pi 3 and we've also got

00:11:17,570 --> 00:11:20,810
working on high key and high key 960

00:11:19,160 --> 00:11:22,100
actually as of last week the dear M

00:11:20,810 --> 00:11:25,250
harbour composers the default for

00:11:22,100 --> 00:11:26,960
criminals 414 above and if you want to

00:11:25,250 --> 00:11:29,210
find out more you can go check out the

00:11:26,960 --> 00:11:31,430
get lab project there and see we've got

00:11:29,210 --> 00:11:35,300
kind of a small group of folks who are

00:11:31,430 --> 00:11:36,890
working on it so as far as the goals for

00:11:35,300 --> 00:11:39,590
the DRM harbour composer Tom to some

00:11:36,890 --> 00:11:42,440
extent just to validate the atomic DRM

00:11:39,590 --> 00:11:44,960
kms is functionally equivalent to ATF

00:11:42,440 --> 00:11:47,180
for Android uses as part of the goal

00:11:44,960 --> 00:11:49,700
there another nice thing is that with

00:11:47,180 --> 00:11:54,770
these dev boards we don't have huge

00:11:49,700 --> 00:11:56,480
teams kind of behind us to develop to

00:11:54,770 --> 00:11:58,280
get things working and so quite often

00:11:56,480 --> 00:12:00,110
the easiest solution with graphics is

00:11:58,280 --> 00:12:01,460
you enable the frame buffer device and

00:12:00,110 --> 00:12:01,970
let surface spin or just kind of handle

00:12:01,460 --> 00:12:04,640
it

00:12:01,970 --> 00:12:06,140
but that really is pretty passe in the

00:12:04,640 --> 00:12:10,070
upstream community they really want

00:12:06,140 --> 00:12:13,640
folks to be using DRM of kms interfaces

00:12:10,070 --> 00:12:15,770
and so this basically provides a working

00:12:13,640 --> 00:12:18,170
hardware composer that uses DRM and kms

00:12:15,770 --> 00:12:20,210
that's kind of mostly works by default

00:12:18,170 --> 00:12:21,680
there's a minimal amount of system

00:12:20,210 --> 00:12:24,080
specific code that you might need to

00:12:21,680 --> 00:12:25,760
write this is an important reporters and

00:12:24,080 --> 00:12:28,940
then the planner that helps make sure

00:12:25,760 --> 00:12:32,950
that it can display things for or can it

00:12:28,940 --> 00:12:35,990
can order the layers on your drm driver

00:12:32,950 --> 00:12:37,880
and then basically it allows the systems

00:12:35,990 --> 00:12:40,640
to share kind of those rests of this

00:12:37,880 --> 00:12:42,380
kind of very complicated logic and then

00:12:40,640 --> 00:12:44,690
another goal here is also to help

00:12:42,380 --> 00:12:48,740
motivate vendors to start moving to DRM

00:12:44,690 --> 00:12:50,570
and kms display solutions as far as the

00:12:48,740 --> 00:12:53,600
current limitations so obviously it

00:12:50,570 --> 00:12:57,920
requires 410 or newer or in android you

00:12:53,600 --> 00:12:59,420
can use android 49 there's some of the

00:12:57,920 --> 00:13:00,620
code that had been done for the pixel

00:12:59,420 --> 00:13:03,200
see you either is kind of a fancy prix

00:13:00,620 --> 00:13:05,210
compositor work it was fairly Nvidia

00:13:03,200 --> 00:13:08,390
specific and it was really only for the

00:13:05,210 --> 00:13:09,830
pixel see and since that's no longer an

00:13:08,390 --> 00:13:11,790
active device that had been since

00:13:09,830 --> 00:13:14,130
dropped

00:13:11,790 --> 00:13:15,570
we also have the case where a lot of the

00:13:14,130 --> 00:13:17,610
devices that we have got it up and

00:13:15,570 --> 00:13:20,699
running on are fairly rudimentary I

00:13:17,610 --> 00:13:22,050
guess compared to devices that ship the

00:13:20,699 --> 00:13:23,760
Heike devices for example will only

00:13:22,050 --> 00:13:25,709
really support a single plane so there's

00:13:23,760 --> 00:13:30,240
not really much device compositing being

00:13:25,709 --> 00:13:33,089
done and another issue kind of is that

00:13:30,240 --> 00:13:35,040
the importer and the planner code are

00:13:33,089 --> 00:13:36,449
actually tightly tied to the growler

00:13:35,040 --> 00:13:38,100
compliant a ssin so this makes it a

00:13:36,449 --> 00:13:39,449
little fragile in some cases because

00:13:38,100 --> 00:13:41,970
changes that happen to this external

00:13:39,449 --> 00:13:43,949
project can you know break or the the

00:13:41,970 --> 00:13:45,810
drm harder composer so we have to kind

00:13:43,949 --> 00:13:48,410
of keep things tightly aligned with

00:13:45,810 --> 00:13:51,089
those external brolic implementations

00:13:48,410 --> 00:13:52,139
and overall the coab probably needs a

00:13:51,089 --> 00:13:55,410
fair amount of cleanup and

00:13:52,139 --> 00:13:58,589
generalization as well as far as the to

00:13:55,410 --> 00:14:00,389
do probably I think there's kind of some

00:13:58,589 --> 00:14:02,370
major cleanup is needed and validated

00:14:00,389 --> 00:14:05,550
and planned logic I've taken a couple

00:14:02,370 --> 00:14:07,589
swings at this but not successfully but

00:14:05,550 --> 00:14:08,730
I hope to keep on working on that it

00:14:07,589 --> 00:14:10,889
would be really nice there was a lot of

00:14:08,730 --> 00:14:13,170
cool optimizations that were done for

00:14:10,889 --> 00:14:14,339
the pixel see device I'm not sure if

00:14:13,170 --> 00:14:16,380
they actually shipped her there just at

00:14:14,339 --> 00:14:17,880
the prototyping stage but they were able

00:14:16,380 --> 00:14:20,010
to do optimizations around squishing

00:14:17,880 --> 00:14:21,959
layers that weren't changing to trying

00:14:20,010 --> 00:14:26,880
to further do power savings to avoid

00:14:21,959 --> 00:14:28,199
waking up the GPU we also need write

00:14:26,880 --> 00:14:29,730
back support some of the folks that arm

00:14:28,199 --> 00:14:31,440
had actually submitted code to do this

00:14:29,730 --> 00:14:33,269
I'm not sure if it's actually been

00:14:31,440 --> 00:14:34,889
enabled on real Hardware just in

00:14:33,269 --> 00:14:37,740
emulation but it's something that you

00:14:34,889 --> 00:14:41,519
know definitely want to see validated on

00:14:37,740 --> 00:14:43,500
other Hardware and generalized and then

00:14:41,519 --> 00:14:47,459
just kind of in general we need wider

00:14:43,500 --> 00:14:48,510
support for more advanced Hardware while

00:14:47,459 --> 00:14:49,800
I'm talking about the DRAM hardware

00:14:48,510 --> 00:14:51,209
composer I also wanted to you know

00:14:49,800 --> 00:14:53,310
mentioned the Lib DRM and Mesa 3d

00:14:51,209 --> 00:14:55,980
projects these are all freedesktop.org

00:14:53,310 --> 00:14:57,449
projects if you wanted to have an open

00:14:55,980 --> 00:14:58,949
graphic stack these are the ones that

00:14:57,449 --> 00:15:01,500
you would probably need

00:14:58,949 --> 00:15:03,750
they've all been recently updated in the

00:15:01,500 --> 00:15:06,480
AOSP tree to be closer to the upstream

00:15:03,750 --> 00:15:07,949
branches and we've been doing a fair

00:15:06,480 --> 00:15:11,250
amount of work trying to upstream many

00:15:07,949 --> 00:15:13,110
AOSP changes in order to keep asp is

00:15:11,250 --> 00:15:14,730
closely aligned with upstream as

00:15:13,110 --> 00:15:16,170
possible I think this is really

00:15:14,730 --> 00:15:18,810
important because I really want to be

00:15:16,170 --> 00:15:21,029
able to regularly test the upstream

00:15:18,810 --> 00:15:22,199
branches in Android this is sort of

00:15:21,029 --> 00:15:23,579
similar to the work that we do with the

00:15:22,199 --> 00:15:24,990
upstream kernel community where we

00:15:23,579 --> 00:15:25,139
really want to be able to test the apps

00:15:24,990 --> 00:15:27,480
tree

00:15:25,139 --> 00:15:29,459
colonel to catch issues and that helps

00:15:27,480 --> 00:15:32,249
you know create confidence when we move

00:15:29,459 --> 00:15:33,689
to newer kernels and the reason why this

00:15:32,249 --> 00:15:35,730
is important is in the past there whose

00:15:33,689 --> 00:15:39,329
projects had been used on other shipping

00:15:35,730 --> 00:15:41,129
devices but once a device ships you know

00:15:39,329 --> 00:15:43,319
Google developers tend to get fairly

00:15:41,129 --> 00:15:45,839
conservative about changes and so we

00:15:43,319 --> 00:15:47,220
don't want to you know we don't want to

00:15:45,839 --> 00:15:49,829
end up having to lock down those

00:15:47,220 --> 00:15:51,839
projects on an older version because the

00:15:49,829 --> 00:15:54,959
potential risk and moving forward might

00:15:51,839 --> 00:15:56,129
break devices in the field and so I want

00:15:54,959 --> 00:15:58,109
to make sure that we're able to kind of

00:15:56,129 --> 00:16:00,869
stay current and stay on top of the tip

00:15:58,109 --> 00:16:03,899
of those master branches upstream so

00:16:00,869 --> 00:16:05,429
that we can do a lot of testing and make

00:16:03,899 --> 00:16:09,179
it so that we are confident that we can

00:16:05,429 --> 00:16:10,619
move forward without breaking devices so

00:16:09,179 --> 00:16:15,119
this is where we get into the hand wavey

00:16:10,619 --> 00:16:18,359
possible futures space so Google has

00:16:15,119 --> 00:16:21,720
deprecated ADF from an upstream

00:16:18,359 --> 00:16:23,480
perspective you know the atomic kms and

00:16:21,720 --> 00:16:26,040
DRM is really the only way to go

00:16:23,480 --> 00:16:29,429
unfortunately many vendors still utilize

00:16:26,040 --> 00:16:33,989
their own legacy FB dev devices or

00:16:29,429 --> 00:16:36,119
drivers and a little bit of a pain now

00:16:33,989 --> 00:16:38,189
the vendors who are doing that they may

00:16:36,119 --> 00:16:40,499
have good reason you know it may be that

00:16:38,189 --> 00:16:42,299
the atomic kms and DRM interfaces have

00:16:40,499 --> 00:16:46,079
some functional limit folks aren't aware

00:16:42,299 --> 00:16:47,610
of but you know we need to basically

00:16:46,079 --> 00:16:49,470
find those and address those and in

00:16:47,610 --> 00:16:52,889
order for that to happen we need vendors

00:16:49,470 --> 00:16:54,619
to start getting involved one of the

00:16:52,889 --> 00:16:59,879
cool things that happened recently was

00:16:54,619 --> 00:17:01,199
you know Shawn Palmer sawal and Luca who

00:16:59,879 --> 00:17:03,809
are developers at Google kind of

00:17:01,199 --> 00:17:05,279
published this document that's linked

00:17:03,809 --> 00:17:07,319
here that kind of covers some of the

00:17:05,279 --> 00:17:09,059
prototyping they're doing on some of the

00:17:07,319 --> 00:17:11,519
next-gen Harvard composer and gromek

00:17:09,059 --> 00:17:13,470
interfaces and they're planning to do

00:17:11,519 --> 00:17:16,260
this prototyping inside of the DRM

00:17:13,470 --> 00:17:17,579
hardware composer code and so it's a

00:17:16,260 --> 00:17:19,519
really interesting document definitely

00:17:17,579 --> 00:17:22,439
big you should check it out

00:17:19,519 --> 00:17:24,990
gonna try to kind of describe my sense

00:17:22,439 --> 00:17:26,100
of it at the moment so when you look at

00:17:24,990 --> 00:17:29,460
kind of the classic hardware composer

00:17:26,100 --> 00:17:30,960
design we've got this case where the way

00:17:29,460 --> 00:17:32,760
it's supposed to work is that surface

00:17:30,960 --> 00:17:34,379
flinger passes you know some number of

00:17:32,760 --> 00:17:36,240
layers say six or something like that to

00:17:34,379 --> 00:17:37,440
the hardware composer the hardware

00:17:36,240 --> 00:17:38,370
composer then talks to the display

00:17:37,440 --> 00:17:39,900
driver

00:17:38,370 --> 00:17:42,000
comes back and says no no I can only do

00:17:39,900 --> 00:17:44,610
four and so then service layer will

00:17:42,000 --> 00:17:45,930
composite that down to just four layers

00:17:44,610 --> 00:17:47,220
and pass that through and then the

00:17:45,930 --> 00:17:49,530
hardware composer will pass that display

00:17:47,220 --> 00:17:53,190
driver and that's so sort of how it's

00:17:49,530 --> 00:17:54,809
supposed to work in practice what tends

00:17:53,190 --> 00:17:56,580
to happen is the hardware composer that

00:17:54,809 --> 00:17:58,470
is written for a specific device

00:17:56,580 --> 00:18:00,300
well it's designed for a specific

00:17:58,470 --> 00:18:03,120
display controller that's on specific

00:18:00,300 --> 00:18:05,070
SOC which also has a specific GPU and

00:18:03,120 --> 00:18:06,780
that GPU has you know the properties

00:18:05,070 --> 00:18:08,280
that the vendors know about that they

00:18:06,780 --> 00:18:10,290
can say okay well we can actually write

00:18:08,280 --> 00:18:12,480
a compositor that's faster than the

00:18:10,290 --> 00:18:14,550
default one so we're just gonna plug

00:18:12,480 --> 00:18:15,630
that in inside of our composer so the

00:18:14,550 --> 00:18:17,850
Harvard composer it becomes kind of this

00:18:15,630 --> 00:18:19,559
very large blob of complicated code and

00:18:17,850 --> 00:18:21,330
so when service slinger says here's six

00:18:19,559 --> 00:18:23,220
layers can you draw that it says yep

00:18:21,330 --> 00:18:24,960
thumbs up I can do that you say okay

00:18:23,220 --> 00:18:26,820
well here's 18 layers yep I can do that

00:18:24,960 --> 00:18:27,800
and so you could just you know it

00:18:26,820 --> 00:18:32,250
doesn't really kind of follow the

00:18:27,800 --> 00:18:36,090
original protocol and so when we looked

00:18:32,250 --> 00:18:37,950
at the DRM harder composer initially it

00:18:36,090 --> 00:18:39,870
had a very similar behavior so basically

00:18:37,950 --> 00:18:40,890
had this you know when we see the green

00:18:39,870 --> 00:18:43,290
I don't know if this is showing up very

00:18:40,890 --> 00:18:44,880
well in this but the orange stuff is all

00:18:43,290 --> 00:18:47,460
device specific and the greens supposed

00:18:44,880 --> 00:18:49,470
to be all generic and so you had this

00:18:47,460 --> 00:18:51,440
generic code that has a little bit of

00:18:49,470 --> 00:18:54,090
device specific code for the planner and

00:18:51,440 --> 00:18:56,880
then also it had this pre compositor

00:18:54,090 --> 00:18:58,260
that was fairly Nvidia specific but it

00:18:56,880 --> 00:18:59,640
followed sort of that same thing where

00:18:58,260 --> 00:19:01,559
it says here's six layers of the players

00:18:59,640 --> 00:19:03,240
planner checks out with a drm driver to

00:19:01,559 --> 00:19:04,380
see how many it really can do but

00:19:03,240 --> 00:19:05,880
whatever it tells us life service

00:19:04,380 --> 00:19:08,040
failure I can do it and squish it down

00:19:05,880 --> 00:19:09,300
to the number it needs the problem with

00:19:08,040 --> 00:19:11,600
that of course is that that pre composer

00:19:09,300 --> 00:19:14,280
was Nvidia specific we couldn't use that

00:19:11,600 --> 00:19:16,559
nobody was using it and so basically got

00:19:14,280 --> 00:19:19,320
dropped and so this is currently kind of

00:19:16,559 --> 00:19:24,480
how the DRM hardware composer looks at

00:19:19,320 --> 00:19:25,830
the moment there's not a lot of you know

00:19:24,480 --> 00:19:28,320
device specific code in it obviously

00:19:25,830 --> 00:19:29,700
it's fairly generic and so if you look

00:19:28,320 --> 00:19:31,170
at the planning document that they

00:19:29,700 --> 00:19:33,660
pushed out I'm gonna push this over a

00:19:31,170 --> 00:19:36,120
little bit there's sort of this thought

00:19:33,660 --> 00:19:37,679
of maybe you know surface flinger and

00:19:36,120 --> 00:19:41,040
the hardware composer can kind of become

00:19:37,679 --> 00:19:43,200
a larger blob and basically just that

00:19:41,040 --> 00:19:45,230
device specific stuff could be kind of

00:19:43,200 --> 00:19:48,240
popped out in some sort of pluggable way

00:19:45,230 --> 00:19:50,440
and basically would be able to do the

00:19:48,240 --> 00:19:52,120
negotiation and composite as it needs

00:19:50,440 --> 00:19:54,670
and then push that out to the drm driver

00:19:52,120 --> 00:19:56,170
directly and actually in the document

00:19:54,670 --> 00:19:57,670
they even talked about having different

00:19:56,170 --> 00:19:59,710
stages in the pipeline so that you might

00:19:57,670 --> 00:20:03,250
be able to have device specific planner

00:19:59,710 --> 00:20:04,900
stage device specific GPU compositor and

00:20:03,250 --> 00:20:07,000
and and being able to have surface layer

00:20:04,900 --> 00:20:09,460
kind of manage those and the drm drivers

00:20:07,000 --> 00:20:12,400
directly and so this would be kind of an

00:20:09,460 --> 00:20:15,070
interesting approach but it is fairly

00:20:12,400 --> 00:20:17,350
different than what we have currently so

00:20:15,070 --> 00:20:19,420
it's it's interesting to see how this

00:20:17,350 --> 00:20:21,790
goes definitely check out the document

00:20:19,420 --> 00:20:26,650
and it's open I think two comments so

00:20:21,790 --> 00:20:29,050
you can add your own feedback so

00:20:26,650 --> 00:20:31,930
suggestions out of all this stop using

00:20:29,050 --> 00:20:34,600
FB dev migrate to the DRM kms drivers

00:20:31,930 --> 00:20:36,640
please definitely please try to work

00:20:34,600 --> 00:20:38,440
with the community to get this the DRM

00:20:36,640 --> 00:20:41,350
infrastructure expanded in order to

00:20:38,440 --> 00:20:42,700
support whatever needs you have you know

00:20:41,350 --> 00:20:44,740
I definitely recommend sending your

00:20:42,700 --> 00:20:46,030
developers to xdc unfortunately it's

00:20:44,740 --> 00:20:47,200
next week so you're probably not gonna

00:20:46,030 --> 00:20:50,500
make it this year but next year

00:20:47,200 --> 00:20:53,080
definitely send display developers to

00:20:50,500 --> 00:20:55,210
XTC that's kind of the best place to

00:20:53,080 --> 00:20:57,280
really interact with the graphics

00:20:55,210 --> 00:20:58,560
community and definitely upstream those

00:20:57,280 --> 00:21:01,240
DRM drivers

00:20:58,560 --> 00:21:02,710
so here's credits previous talks and

00:21:01,240 --> 00:21:04,090
slides that people have given that we're

00:21:02,710 --> 00:21:06,880
very similar and kind of I used to

00:21:04,090 --> 00:21:09,040
generate these extra thanks to Sean Paul

00:21:06,880 --> 00:21:10,720
who's been very helpful in maintaining

00:21:09,040 --> 00:21:12,670
the DRM harder a composer and walking me

00:21:10,720 --> 00:21:14,950
through a lot of the changes so I think

00:21:12,670 --> 00:21:22,270
that's it and I've got three minutes for

00:21:14,950 --> 00:21:24,540
questions all right well thank you so

00:21:22,270 --> 00:21:24,540
much

00:21:25,200 --> 00:21:27,520
you

00:21:25,350 --> 00:21:32,520
[Applause]

00:21:27,520 --> 00:21:32,520

YouTube URL: https://www.youtube.com/watch?v=AVlRVElJNsY


