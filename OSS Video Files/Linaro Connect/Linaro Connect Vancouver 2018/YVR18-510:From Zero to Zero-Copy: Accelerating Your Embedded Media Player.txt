Title: YVR18-510:From Zero to Zero-Copy: Accelerating Your Embedded Media Player
Publication date: 2018-10-22
Playlist: Linaro Connect Vancouver 2018
Description: 
	In this presentation you will learn how to accelerate your embedded multimedia application using Video 4 Linux 2, the Linux DRM subsystem, and OpenGLES. Zero-copy is a method that describes using exactly zero memory copy operations thus saving memory bandwidth. Saving memory is needed in a world where 4K HEVC is becoming more prevalent.

The focus of using these methods is to move away from proprietary graphics and video decode and using open source solutions instead. These open source solutions are available for many embedded chipsets out today and can help you streamline your application development for use on multiple platforms.

This presentation will also cover a brief overview of current support for open source graphics and video decoding on various platforms.

This information is critical for developers working on applications that currently use proprietary graphics methods.
Captions: 
	00:00:02,110 --> 00:00:07,120
[Music]

00:00:08,120 --> 00:00:14,430
I'm super excited to be here today to

00:00:10,680 --> 00:00:15,929
present this for you guys I guess they

00:00:14,430 --> 00:00:18,060
don't get a lot of external

00:00:15,929 --> 00:00:20,640
presentations at Lenoir Oh Connect so

00:00:18,060 --> 00:00:22,470
I'm an external presenter which is is

00:00:20,640 --> 00:00:23,880
cool it's not only my first time

00:00:22,470 --> 00:00:26,039
presenting at Leonora connect it's my

00:00:23,880 --> 00:00:28,080
first time being at Lonardo connect so

00:00:26,039 --> 00:00:29,480
I'm super happy about that

00:00:28,080 --> 00:00:34,010
[Music]

00:00:29,480 --> 00:00:37,880
so get going this is my presentation

00:00:34,010 --> 00:00:45,059
from zero to zero copy and how you can

00:00:37,880 --> 00:00:46,469
improve your video player so not a lot

00:00:45,059 --> 00:00:48,390
of people know who I am

00:00:46,469 --> 00:00:51,030
I'm very welcome to have people come and

00:00:48,390 --> 00:00:56,370
talk to me after my name is Lucas Susac

00:00:51,030 --> 00:00:58,710
I am actually living in BC and I work on

00:00:56,370 --> 00:01:01,350
this kind of like in my spare time I'm

00:00:58,710 --> 00:01:07,619
actually a control systems engineer by

00:01:01,350 --> 00:01:09,810
by schooling so yeah so this is kind of

00:01:07,619 --> 00:01:12,029
where we're gonna go through today this

00:01:09,810 --> 00:01:14,159
is kind of just meant for people

00:01:12,029 --> 00:01:16,950
reviewing the slides but well it will go

00:01:14,159 --> 00:01:20,159
through it quickly so what is zero copy

00:01:16,950 --> 00:01:24,689
and what does it mean in terms of video

00:01:20,159 --> 00:01:27,959
playback and video rendering so ideally

00:01:24,689 --> 00:01:29,459
we want to be able to take some data put

00:01:27,959 --> 00:01:32,490
it in a buffer and leave it in that

00:01:29,459 --> 00:01:35,520
buffer until it's used and done and we

00:01:32,490 --> 00:01:38,340
can clear it we don't want to copy data

00:01:35,520 --> 00:01:41,249
around copying is expensive especially

00:01:38,340 --> 00:01:44,999
on embedded devices that we use today

00:01:41,249 --> 00:01:49,739
and especially now in upcoming times

00:01:44,999 --> 00:01:53,399
when 4k video and h.265 is as prevalent

00:01:49,739 --> 00:01:55,349
and it's going to be tons of data that

00:01:53,399 --> 00:01:58,349
we need to move on these little devices

00:01:55,349 --> 00:02:01,889
that have very weak CPUs and very weak

00:01:58,349 --> 00:02:09,409
GPUs and have very specialized hardware

00:02:01,889 --> 00:02:09,409
for for video decoding and rendering so

00:02:09,580 --> 00:02:17,450
so we need to basically streamline the

00:02:13,280 --> 00:02:20,240
process to be able to decode a video

00:02:17,450 --> 00:02:22,910
frame put it in a buffer display it

00:02:20,240 --> 00:02:26,810
remove it and that and then it's done

00:02:22,910 --> 00:02:29,660
so I'm going to talk about how we do

00:02:26,810 --> 00:02:34,010
this how currently it's done and and

00:02:29,660 --> 00:02:36,430
where it's going with that so it's used

00:02:34,010 --> 00:02:40,460
already in a lot of proprietary methods

00:02:36,430 --> 00:02:44,360
but using these proprietary methods it's

00:02:40,460 --> 00:02:46,220
got all all these issues where you can

00:02:44,360 --> 00:02:47,120
actually you a lot of the times you

00:02:46,220 --> 00:02:50,240
don't actually know what's going on

00:02:47,120 --> 00:02:53,630
internally there may be bugs it's hard

00:02:50,240 --> 00:02:56,890
to fix things these are just some

00:02:53,630 --> 00:02:59,510
examples there's there's a lot more but

00:02:56,890 --> 00:03:02,210
one of the ones that we deal with a lot

00:02:59,510 --> 00:03:04,670
is an logic and there there video

00:03:02,210 --> 00:03:08,060
decoding library is locked to the kernel

00:03:04,670 --> 00:03:11,440
3.14 which is quite old by today's

00:03:08,060 --> 00:03:15,920
standards so it it is very difficult to

00:03:11,440 --> 00:03:18,080
use that and it becomes a problem where

00:03:15,920 --> 00:03:20,300
you have maintenance on code and it's

00:03:18,080 --> 00:03:23,150
very vendor specific it's very hard to

00:03:20,300 --> 00:03:28,160
deal with if someone that knows it is

00:03:23,150 --> 00:03:30,200
leaving then you might be pooped because

00:03:28,160 --> 00:03:35,600
now no one knows how to maintain that or

00:03:30,200 --> 00:03:38,570
how it's even used so where are we going

00:03:35,600 --> 00:03:41,420
and so we're looking at a lot of open

00:03:38,570 --> 00:03:44,170
source solutions for this and pretty

00:03:41,420 --> 00:03:48,230
much everything here is ready today and

00:03:44,170 --> 00:03:50,150
so these are kind of the things needed

00:03:48,230 --> 00:03:54,740
or the requirements needed in order to

00:03:50,150 --> 00:03:58,520
have your app or board have a zero copy

00:03:54,740 --> 00:04:01,400
pipeline and so a video for Linux to

00:03:58,520 --> 00:04:05,180
driver is needed which is actually very

00:04:01,400 --> 00:04:08,270
common nowadays there's a lot of

00:04:05,180 --> 00:04:12,170
movement in the Linux kernel for v4l to

00:04:08,270 --> 00:04:14,120
stuff and so we're really happy to see

00:04:12,170 --> 00:04:15,380
that there's a lot of support I'll be

00:04:14,120 --> 00:04:17,120
going over some of the support for

00:04:15,380 --> 00:04:19,299
different various boards a little bit

00:04:17,120 --> 00:04:19,299
later

00:04:20,810 --> 00:04:25,920
there is still a little bit of influx in

00:04:23,220 --> 00:04:28,470
the in the v4 l2 subsystem with some

00:04:25,920 --> 00:04:31,710
stuff right now but hopefully that will

00:04:28,470 --> 00:04:33,450
get merged pretty soon it's dealing with

00:04:31,710 --> 00:04:35,340
the request API it kind of just changes

00:04:33,450 --> 00:04:40,490
some stuff about how it actually works

00:04:35,340 --> 00:04:43,950
but so and then the next two are aren't

00:04:40,490 --> 00:04:48,660
exclusive if you wanted to you could

00:04:43,950 --> 00:04:51,390
completely write your app using just the

00:04:48,660 --> 00:04:55,770
drm driver if you don't have need for GL

00:04:51,390 --> 00:04:56,790
at all and there it's a really good

00:04:55,770 --> 00:04:59,070
method but there are some limitations

00:04:56,790 --> 00:05:02,250
and it depends on your app because a lot

00:04:59,070 --> 00:05:04,080
of times your app may be a GL app and it

00:05:02,250 --> 00:05:08,460
may have overlays that you need to use

00:05:04,080 --> 00:05:11,700
with the video and whatnot so we are

00:05:08,460 --> 00:05:16,350
using these together and so with with

00:05:11,700 --> 00:05:18,090
OpenGL ES 2.0 there are some extensions

00:05:16,350 --> 00:05:22,470
that are needed in order to to be able

00:05:18,090 --> 00:05:28,140
to to use this this pipeline but they

00:05:22,470 --> 00:05:30,860
are pretty common and even with the

00:05:28,140 --> 00:05:33,000
hardware that uses Mally

00:05:30,860 --> 00:05:36,690
typically these extensions are in there

00:05:33,000 --> 00:05:40,430
so that's what I mean by a lot of it is

00:05:36,690 --> 00:05:43,580
already in place and we can use it so

00:05:40,430 --> 00:05:47,340
this is kind of how it's gonna work for

00:05:43,580 --> 00:05:50,900
us so there's some different stuff you

00:05:47,340 --> 00:05:54,360
can do and you can implement a v4 l2

00:05:50,900 --> 00:05:56,340
abstraction in your app directly and I

00:05:54,360 --> 00:05:59,400
actually tried this before and it was

00:05:56,340 --> 00:06:01,260
kind of a disaster but that's when I

00:05:59,400 --> 00:06:04,950
turned to doing some of the stuff with

00:06:01,260 --> 00:06:09,420
ffmpeg so GStreamer has full support for

00:06:04,950 --> 00:06:10,950
v4 l - using the various types so in v4

00:06:09,420 --> 00:06:15,030
l tool and there is three different

00:06:10,950 --> 00:06:17,610
types of buffers you can use one where

00:06:15,030 --> 00:06:19,320
it just met Maps its own memory one

00:06:17,610 --> 00:06:20,960
where you can point it to memory and

00:06:19,320 --> 00:06:26,130
then one where you can actually import

00:06:20,960 --> 00:06:27,990
DMA buffers into it and with ffmpeg

00:06:26,130 --> 00:06:29,129
we are still kind of catching up a

00:06:27,990 --> 00:06:31,889
little bit

00:06:29,129 --> 00:06:34,559
and I still have some patches that are

00:06:31,889 --> 00:06:38,129
in review on the mailing list to

00:06:34,559 --> 00:06:40,619
implement what we need to be able to do

00:06:38,129 --> 00:06:42,689
zero copy and it's working a little bit

00:06:40,619 --> 00:06:46,319
different than how some people would

00:06:42,689 --> 00:06:52,289
expect it but it does work and so we're

00:06:46,319 --> 00:06:54,330
basically taking letting v4l to allocate

00:06:52,289 --> 00:06:58,529
the memory for us and then we are able

00:06:54,330 --> 00:07:02,969
to use some v4l to calls to export that

00:06:58,529 --> 00:07:06,300
that memory address and use that so what

00:07:02,969 --> 00:07:09,269
happens here in a very basic term is

00:07:06,300 --> 00:07:12,300
that we have our compressed video frame

00:07:09,269 --> 00:07:19,050
and pushed push it through the decoder

00:07:12,300 --> 00:07:22,110
and in ffmpeg we then request from v4l

00:07:19,050 --> 00:07:23,579
tooth that to export that buffer and it

00:07:22,110 --> 00:07:25,709
and it just hands us a file descriptor

00:07:23,579 --> 00:07:29,519
so we take that file to scripture and

00:07:25,709 --> 00:07:30,809
put it in this little wrapper and that

00:07:29,519 --> 00:07:32,519
file descriptor is just pointing out the

00:07:30,809 --> 00:07:34,279
decoded frame and that and that decoded

00:07:32,519 --> 00:07:37,259
frame can just sit in its memory place

00:07:34,279 --> 00:07:41,639
memory space and stay there until we

00:07:37,259 --> 00:07:44,490
don't need it anymore and it's a very

00:07:41,639 --> 00:07:47,119
basic overview but that's more or less

00:07:44,490 --> 00:07:52,379
how it works and how it'll work on

00:07:47,119 --> 00:07:56,849
GStreamer and stuff as well so so this

00:07:52,379 --> 00:08:01,050
is now how do we actually take that

00:07:56,849 --> 00:08:05,129
buffer and display it so if you're if

00:08:01,050 --> 00:08:05,819
your app doesn't use GL you can do it in

00:08:05,129 --> 00:08:10,379
this method

00:08:05,819 --> 00:08:12,659
so you're we're able to utilize some of

00:08:10,379 --> 00:08:18,169
the specialized hardware on embedded

00:08:12,659 --> 00:08:21,149
boards that are able to handle y UV

00:08:18,169 --> 00:08:25,589
video formats and display them directly

00:08:21,149 --> 00:08:27,449
on the hardware and so it is a

00:08:25,589 --> 00:08:29,879
requirement that the drm driver does

00:08:27,449 --> 00:08:33,110
support this but support is really good

00:08:29,879 --> 00:08:39,990
currently in the in the linux kernel and

00:08:33,110 --> 00:08:42,810
so what we actually do is from the file

00:08:39,990 --> 00:08:45,570
descriptor of the video frame we

00:08:42,810 --> 00:08:48,780
basically import that convert it to a

00:08:45,570 --> 00:08:53,880
handle add a frame buffer and then add

00:08:48,780 --> 00:08:59,760
that add that frame buffer to your your

00:08:53,880 --> 00:09:02,880
your DRM loop so we are in encode e we

00:08:59,760 --> 00:09:06,720
are actually using a atomic mode setting

00:09:02,880 --> 00:09:12,330
for this and it is very interesting with

00:09:06,720 --> 00:09:14,850
some of the stuff we can do so yeah and

00:09:12,330 --> 00:09:17,130
then this is just a kind of an overview

00:09:14,850 --> 00:09:18,990
of how how it looks so with your DRM

00:09:17,130 --> 00:09:23,310
flames some devices will have

00:09:18,990 --> 00:09:27,360
specialized planes that are able to have

00:09:23,310 --> 00:09:30,030
the y UV formats and then there's some

00:09:27,360 --> 00:09:32,100
that may be RGB only so you have to

00:09:30,030 --> 00:09:36,090
watch out for that when with your app so

00:09:32,100 --> 00:09:39,000
in Kodi we run the GUI completely

00:09:36,090 --> 00:09:41,370
typically on overlay planes but as long

00:09:39,000 --> 00:09:45,320
as the plane can handle RGB formats it's

00:09:41,370 --> 00:09:48,420
fine and then any video formats are

00:09:45,320 --> 00:09:50,160
typically on a primary plane or if as

00:09:48,420 --> 00:09:52,740
long as the plane can handle y UV

00:09:50,160 --> 00:09:57,450
formats and it'll always be like that

00:09:52,740 --> 00:10:00,060
and so when you have video playback

00:09:57,450 --> 00:10:02,900
basically we can completely disable the

00:10:00,060 --> 00:10:09,320
overlay plane and have really great

00:10:02,900 --> 00:10:09,320
throughput for for the video pipeline

00:10:10,580 --> 00:10:17,970
there are some caveats with this though

00:10:14,100 --> 00:10:20,970
where yeah you it depends on your drm

00:10:17,970 --> 00:10:22,470
driver support and the only instance I

00:10:20,970 --> 00:10:25,500
know of is with imx6 where there's

00:10:22,470 --> 00:10:28,530
actually no scaler built into the

00:10:25,500 --> 00:10:30,270
display pipeline chain there is a scaler

00:10:28,530 --> 00:10:32,850
built onto the board but it's not used

00:10:30,270 --> 00:10:35,040
in there so mmm that becomes a problem

00:10:32,850 --> 00:10:37,380
when you can't actually upsize or

00:10:35,040 --> 00:10:42,900
downsize your video frame to the actual

00:10:37,380 --> 00:10:45,810
output of your resolution so and then we

00:10:42,900 --> 00:10:48,510
actually have the GL ES and the e GL

00:10:45,810 --> 00:10:49,770
import which does a very similar thing

00:10:48,510 --> 00:10:51,390
where we take the file descriptor but

00:10:49,770 --> 00:10:55,230
we're actually importing it into e GL

00:10:51,390 --> 00:10:57,450
and and displaying it from there

00:10:55,230 --> 00:10:59,280
there's some good stuff with that and if

00:10:57,450 --> 00:11:00,960
you have advanced shaders or other

00:10:59,280 --> 00:11:04,830
things you can you can play with it that

00:11:00,960 --> 00:11:10,020
way it is a little bit more costly in

00:11:04,830 --> 00:11:13,530
terms of performance but that's just

00:11:10,020 --> 00:11:15,240
bending on the GPU on your embedded

00:11:13,530 --> 00:11:16,830
board that you're using and typically

00:11:15,240 --> 00:11:19,140
they're not very powerful so you'll

00:11:16,830 --> 00:11:21,780
you'll tend to struggle with this and

00:11:19,140 --> 00:11:23,820
that's a big part about doing direct or

00:11:21,780 --> 00:11:29,070
plane stuff where you can actually skip

00:11:23,820 --> 00:11:31,170
the GPU completely so I just wanted to

00:11:29,070 --> 00:11:35,040
talk a little bit about the Mallee stuff

00:11:31,170 --> 00:11:36,660
and because although we have these all

00:11:35,040 --> 00:11:38,100
these great open-source solutions and

00:11:36,660 --> 00:11:41,640
stuff unfortunately we are still stuck

00:11:38,100 --> 00:11:46,140
with a Mallee blob that is used on some

00:11:41,640 --> 00:11:50,220
boards for four and malie is for those

00:11:46,140 --> 00:11:53,640
that don't know is the basically OpenGL

00:11:50,220 --> 00:11:58,050
driver user space library that interacts

00:11:53,640 --> 00:12:02,010
with a kernel driver and it's licensed

00:11:58,050 --> 00:12:03,330
from arm to use on different boards but

00:12:02,010 --> 00:12:06,510
there's just a lot of problems with this

00:12:03,330 --> 00:12:09,150
because it's licensed per manufacturer

00:12:06,510 --> 00:12:11,730
and then even then they have to pay a

00:12:09,150 --> 00:12:14,130
licensing fee to get different versions

00:12:11,730 --> 00:12:16,290
of library so some companies may only

00:12:14,130 --> 00:12:18,360
want to support x11 but some might want

00:12:16,290 --> 00:12:23,580
to support Wayland or vice or vice versa

00:12:18,360 --> 00:12:28,220
and we basically need a library that

00:12:23,580 --> 00:12:31,110
will support GBM to do this and GBM is

00:12:28,220 --> 00:12:35,340
what we're using to be able to create

00:12:31,110 --> 00:12:37,560
rendering surfaces and now it's not a

00:12:35,340 --> 00:12:41,160
hard requirement because you might be

00:12:37,560 --> 00:12:44,640
able to do it with kernel dumb buffers

00:12:41,160 --> 00:12:47,370
but I've never actually tried and I and

00:12:44,640 --> 00:12:52,820
I've heard that it can be sometimes very

00:12:47,370 --> 00:12:55,610
problematic to have your ejl context and

00:12:52,820 --> 00:13:00,210
using surfaces with dumb buffers so

00:12:55,610 --> 00:13:02,430
we're sticking with GBM for now and yeah

00:13:00,210 --> 00:13:05,580
so it's it's just difficult to fix any

00:13:02,430 --> 00:13:07,310
bugs that happen and if if you do find

00:13:05,580 --> 00:13:08,689
something or need something changed or

00:13:07,310 --> 00:13:10,910
need a different version the library

00:13:08,689 --> 00:13:14,209
because it's it's can be locked to the

00:13:10,910 --> 00:13:16,519
kernel driver version you have to go

00:13:14,209 --> 00:13:18,439
through your vendor to get a new library

00:13:16,519 --> 00:13:21,980
and even then you're probably just gonna

00:13:18,439 --> 00:13:23,629
be out of luck cuz yeah and so with this

00:13:21,980 --> 00:13:25,610
there is some open source efforts

00:13:23,629 --> 00:13:28,550
underway for the Lima and pan Frost

00:13:25,610 --> 00:13:30,290
drivers which has had some good success

00:13:28,550 --> 00:13:32,709
in the last little while last I know

00:13:30,290 --> 00:13:36,649
that Lima driver can now run kms cube

00:13:32,709 --> 00:13:39,290
which is a good start so where it's not

00:13:36,649 --> 00:13:41,809
quite ready to be able to be in use for

00:13:39,290 --> 00:13:43,490
us but hopefully in the near future

00:13:41,809 --> 00:13:44,709
because that would be really nice to

00:13:43,490 --> 00:13:48,559
have that

00:13:44,709 --> 00:13:51,139
so now just some board specific stuff

00:13:48,559 --> 00:13:53,839
I'll run through I think there's five or

00:13:51,139 --> 00:13:55,399
six different SOC s here and like their

00:13:53,839 --> 00:13:59,899
varying wet layers the support that we

00:13:55,399 --> 00:14:02,620
have for them so with all winner a lot

00:13:59,899 --> 00:14:05,899
of people probably seen the recent

00:14:02,620 --> 00:14:09,230
fundraiser that they did with boot Lynn

00:14:05,899 --> 00:14:11,420
to do that v4l to driver for all winter

00:14:09,230 --> 00:14:14,149
hardware and that is basically done now

00:14:11,420 --> 00:14:17,509
they are still waiting on that request

00:14:14,149 --> 00:14:20,959
ABI JPI to be merged but that should be

00:14:17,509 --> 00:14:23,930
hopefully any day I believe and then we

00:14:20,959 --> 00:14:28,370
can support that they do use malli

00:14:23,930 --> 00:14:30,410
typically for on all winter hardware but

00:14:28,370 --> 00:14:34,930
otherwise everything is pretty upstream

00:14:30,410 --> 00:14:38,209
in the mainline kernel for that so and

00:14:34,930 --> 00:14:41,089
AM logic which has kind of been an

00:14:38,209 --> 00:14:44,059
interesting story over the last year or

00:14:41,089 --> 00:14:46,009
so we're working really close with some

00:14:44,059 --> 00:14:49,730
of these guys these two guys from Bay

00:14:46,009 --> 00:14:52,519
Libra on on this stuff and a v4l two

00:14:49,730 --> 00:14:56,149
driver has emerged in the last three or

00:14:52,519 --> 00:14:58,519
four months they think to support to be

00:14:56,149 --> 00:15:01,339
able to support forum logic and it's

00:14:58,519 --> 00:15:03,589
working well it's working really well so

00:15:01,339 --> 00:15:07,399
we have some AM logic hardware running

00:15:03,589 --> 00:15:11,389
on mainline kernel with a couple of just

00:15:07,399 --> 00:15:15,279
cities out has stream patches and are

00:15:11,389 --> 00:15:15,279
able to do everything we need so

00:15:15,930 --> 00:15:20,790
it's really exciting because yeah and

00:15:18,360 --> 00:15:24,000
logic was locked to 3.14 for the longest

00:15:20,790 --> 00:15:25,529
time and they decided to drop support

00:15:24,000 --> 00:15:29,100
for a lot of their hardware and some of

00:15:25,529 --> 00:15:32,160
their newer kernels so yeah

00:15:29,100 --> 00:15:35,670
and so Broadcom and Raspberry Pi for

00:15:32,160 --> 00:15:37,589
those people that know it is that same

00:15:35,670 --> 00:15:39,150
same thing there's actually a v4 l2

00:15:37,589 --> 00:15:42,210
driver that is emerged in the last I

00:15:39,150 --> 00:15:45,510
think six months or so and it's working

00:15:42,210 --> 00:15:48,990
really well and unfortunately it's still

00:15:45,510 --> 00:15:51,089
in the Raspberry Pi kernel repository so

00:15:48,990 --> 00:15:55,230
it's not something that's mainline

00:15:51,089 --> 00:15:57,690
I believe the author of it who it works

00:15:55,230 --> 00:15:59,850
at the Raspberry Pi foundation will be

00:15:57,690 --> 00:16:01,800
trying to get it upstream which is

00:15:59,850 --> 00:16:06,779
really good I just I don't know of any

00:16:01,800 --> 00:16:09,720
timelines or that so currently in my

00:16:06,779 --> 00:16:13,200
testing I've been using 4.1 for because

00:16:09,720 --> 00:16:16,740
that's the raspberry PI's LTS kernel

00:16:13,200 --> 00:16:19,350
that they're using so and unfortunately

00:16:16,740 --> 00:16:24,810
the Raspberry Pi the VC for open-source

00:16:19,350 --> 00:16:27,390
driver doesn't support y UV format

00:16:24,810 --> 00:16:30,690
imports in the in the GL driver so you

00:16:27,390 --> 00:16:34,200
have to use direct to plain rendering

00:16:30,690 --> 00:16:36,540
for that and not that that's an issue it

00:16:34,200 --> 00:16:44,240
works great but it's just kind of one of

00:16:36,540 --> 00:16:47,400
those things and NXP hardware so imx6

00:16:44,240 --> 00:16:49,380
that's it has really improved a lot in

00:16:47,400 --> 00:16:52,920
the last little while so with all the

00:16:49,380 --> 00:16:55,970
guys doing working on Etna veve we have

00:16:52,920 --> 00:17:00,870
really great support for this now and

00:16:55,970 --> 00:17:02,100
there is some some downsides it just

00:17:00,870 --> 00:17:03,810
depends on the hardware you have but

00:17:02,100 --> 00:17:08,040
hopefully they'll be able to get some

00:17:03,810 --> 00:17:13,470
optimizations in for GC mm hardware

00:17:08,040 --> 00:17:17,939
which is imx6 Q and a less and GC 3000

00:17:13,470 --> 00:17:22,709
is Q plus and which has great

00:17:17,939 --> 00:17:25,350
performance so you can do both methods

00:17:22,709 --> 00:17:26,860
rendering methods with imx6 however like

00:17:25,350 --> 00:17:29,290
I said before the

00:17:26,860 --> 00:17:33,429
driver does lack a scaler built into the

00:17:29,290 --> 00:17:37,090
chain so yeah well you might have issues

00:17:33,429 --> 00:17:38,650
with that and I did too and there

00:17:37,090 --> 00:17:41,410
there's some other issues where you have

00:17:38,650 --> 00:17:43,450
to when changing video formats for the

00:17:41,410 --> 00:17:46,299
plane you have to initiate a mode set

00:17:43,450 --> 00:17:48,520
and and it has to do some heavy lifting

00:17:46,299 --> 00:17:52,809
internally so there's some issues there

00:17:48,520 --> 00:17:55,360
but it is possible and the the v4l to

00:17:52,809 --> 00:17:57,040
code a driver that is for imx6 has

00:17:55,360 --> 00:18:01,929
existed for quite a while in the

00:17:57,040 --> 00:18:03,640
upstream kernel but it's there's some

00:18:01,929 --> 00:18:10,000
more patches coming in to really kind of

00:18:03,640 --> 00:18:11,710
optimize it as well and qualcomm support

00:18:10,000 --> 00:18:13,510
here is great everything's in the

00:18:11,710 --> 00:18:19,450
mainline kernel is for the dragon board

00:18:13,510 --> 00:18:21,850
fort 410 and it's been it's been in

00:18:19,450 --> 00:18:23,290
there for probably a year now I think

00:18:21,850 --> 00:18:25,480
I've been running on the mainline kernel

00:18:23,290 --> 00:18:29,730
and it works really well you can use

00:18:25,480 --> 00:18:29,730
either forms of rendering for it and

00:18:31,110 --> 00:18:39,340
yeah not much more to say for that I

00:18:35,400 --> 00:18:41,320
have a oh by the way I have a demo of

00:18:39,340 --> 00:18:42,250
all this hardware in the demo room

00:18:41,320 --> 00:18:43,450
downstairs too

00:18:42,250 --> 00:18:45,130
so if people are actually interested in

00:18:43,450 --> 00:18:45,640
like seeing stuff running on certain

00:18:45,130 --> 00:18:49,059
hardware

00:18:45,640 --> 00:18:51,910
I do have instances of everything and

00:18:49,059 --> 00:18:54,370
even with imx6 I have a quad plus and a

00:18:51,910 --> 00:18:56,679
quad device so we can see how that the

00:18:54,370 --> 00:18:58,299
actual stuff is working there and then

00:18:56,679 --> 00:19:01,000
there's a whole bunch of other vendors I

00:18:58,299 --> 00:19:04,450
do have some rock ship stuff as well

00:19:01,000 --> 00:19:07,059
and Rockchip is hopefully going to catch

00:19:04,450 --> 00:19:08,740
up a little bit there because as far as

00:19:07,059 --> 00:19:11,230
I know that chrome Chrome OS team and

00:19:08,740 --> 00:19:13,419
stuff is really pushing for a v4 l 2

00:19:11,230 --> 00:19:17,200
driver from them and I believe there is

00:19:13,419 --> 00:19:20,710
stuff started but I don't know much more

00:19:17,200 --> 00:19:22,270
than that and renesis has a v4 l2 driver

00:19:20,710 --> 00:19:23,650
and stuff too but I just don't have

00:19:22,270 --> 00:19:25,840
hardware for that so I don't know much

00:19:23,650 --> 00:19:29,020
about it and then just some others too

00:19:25,840 --> 00:19:34,390
so that's where we're kind of at

00:19:29,020 --> 00:19:36,910
currently and this is just some

00:19:34,390 --> 00:19:38,500
information about where to get stuff if

00:19:36,910 --> 00:19:39,680
people are interested in how we did this

00:19:38,500 --> 00:19:42,770
or their interests

00:19:39,680 --> 00:19:46,910
seeing the actual implementation of it

00:19:42,770 --> 00:19:49,100
and they want to review some code and

00:19:46,910 --> 00:19:52,130
see how we actually wrote it these are

00:19:49,100 --> 00:19:54,110
some good links there to the actual tree

00:19:52,130 --> 00:19:59,270
for Cody and how we are actually doing

00:19:54,110 --> 00:20:01,790
this and that's my presentation so if

00:19:59,270 --> 00:20:03,440
anyone has any questions about this I'd

00:20:01,790 --> 00:20:07,010
be happy to answer them

00:20:03,440 --> 00:20:08,750
I will also be down in the demo room so

00:20:07,010 --> 00:20:17,930
you can ask me for a few hours if

00:20:08,750 --> 00:20:26,300
anything comes up but yeah do we have a

00:20:17,930 --> 00:20:29,150
mic here so you did mention about the

00:20:26,300 --> 00:20:31,940
two parts the director plain rendering

00:20:29,150 --> 00:20:34,100
and the opengl path yep so comparing the

00:20:31,940 --> 00:20:35,990
relative plain rendering if you adopt

00:20:34,100 --> 00:20:38,300
opengl path you do agree that there is

00:20:35,990 --> 00:20:40,580
an extra face of copying when the

00:20:38,300 --> 00:20:43,700
decoder buffer is rendered and then

00:20:40,580 --> 00:20:45,920
wrapped for the DRAM pipeline so sorry

00:20:43,700 --> 00:20:48,320
just one more time no in the director

00:20:45,920 --> 00:20:49,910
plain path yeah open the decoded buffer

00:20:48,320 --> 00:20:52,340
FD will be directly given to the DRAM

00:20:49,910 --> 00:20:53,750
manager yeah okay so you'll be yep but

00:20:52,340 --> 00:20:56,000
if you have to adapt the OpenGL path

00:20:53,750 --> 00:20:59,240
that is next office of copying involved

00:20:56,000 --> 00:21:00,950
by the GPU there so yeah if the GPU has

00:20:59,240 --> 00:21:03,100
to access the memory but this is the

00:21:00,950 --> 00:21:05,630
best possible path that we can have

00:21:03,100 --> 00:21:08,960
where you're actually importing the DMA

00:21:05,630 --> 00:21:10,310
buffer into egl itself I don't have a

00:21:08,960 --> 00:21:12,350
good knowledge of what is actually

00:21:10,310 --> 00:21:14,630
happening in the background there and it

00:21:12,350 --> 00:21:17,780
may vary hardware the hardware and

00:21:14,630 --> 00:21:19,730
driver to driver but their performance

00:21:17,780 --> 00:21:22,610
is still really good and I can I can

00:21:19,730 --> 00:21:24,140
show that later on in the demo and stuff

00:21:22,610 --> 00:21:26,240
as well because we can switch back and

00:21:24,140 --> 00:21:28,580
forth between the two versions if you're

00:21:26,240 --> 00:21:30,200
curious okay my question was you know

00:21:28,580 --> 00:21:31,520
the zero copy I thought that is the

00:21:30,200 --> 00:21:36,410
price we are paying for getting the

00:21:31,520 --> 00:21:41,690
shared support yeah so it's a good point

00:21:36,410 --> 00:21:45,490
but it's uh it's the only way you can do

00:21:41,690 --> 00:21:46,660
it if you are constricted that way so

00:21:45,490 --> 00:21:51,250
the

00:21:46,660 --> 00:21:53,740
the the video buffer is still being in

00:21:51,250 --> 00:21:55,300
its singles place in memory

00:21:53,740 --> 00:21:57,580
we're just referencing it from the file

00:21:55,300 --> 00:22:00,700
descriptor so yeah if there has to be

00:21:57,580 --> 00:22:03,390
some sort of internal copying with the

00:22:00,700 --> 00:22:06,580
GPU or depending on how the GPU works

00:22:03,390 --> 00:22:11,560
with internal bleeding to change it from

00:22:06,580 --> 00:22:14,290
Y UV to an RGB format that is dependent

00:22:11,560 --> 00:22:21,580
on that but yeah it is a good point

00:22:14,290 --> 00:22:27,910
though to bring up so thank you anyone

00:22:21,580 --> 00:22:32,560
else going so I've heard rumors that arm

00:22:27,910 --> 00:22:37,450
is now releasing a generic Mali blob if

00:22:32,560 --> 00:22:39,040
you looked at that yet not not too much

00:22:37,450 --> 00:22:43,120
I actually try and avoid malli as much

00:22:39,040 --> 00:22:45,700
as possible but it will be nice if that

00:22:43,120 --> 00:22:49,420
is the case and it's licensed to its

00:22:45,700 --> 00:22:51,730
licenses more open because a lot of the

00:22:49,420 --> 00:22:53,350
malli blobs are very similar it's just

00:22:51,730 --> 00:22:55,000
they're licensed to their hardware even

00:22:53,350 --> 00:22:57,430
though they'll work exhaust Platt it

00:22:55,000 --> 00:22:59,710
allows for redistribution and from the

00:22:57,430 --> 00:23:03,060
people I talked to at arm it also works

00:22:59,710 --> 00:23:06,010
cross fender if you have a reason enough

00:23:03,060 --> 00:23:07,890
kernel driver I just haven't had time to

00:23:06,010 --> 00:23:12,340
look at it and I think they even include

00:23:07,890 --> 00:23:14,410
a Wayland version with with mini GBM

00:23:12,340 --> 00:23:16,840
good yeah I mean it would be really

00:23:14,410 --> 00:23:19,930
great it still has its issues with malli

00:23:16,840 --> 00:23:21,100
where it's closed you don't actually

00:23:19,930 --> 00:23:25,960
know what's going on if you need to fix

00:23:21,100 --> 00:23:28,420
bugs etc but yes it will be easier and

00:23:25,960 --> 00:23:30,820
depending on the SOC vendor because some

00:23:28,420 --> 00:23:33,160
are better than others at being able to

00:23:30,820 --> 00:23:36,160
give you a new version of malli library

00:23:33,160 --> 00:23:38,830
so yeah but we've had it in the past

00:23:36,160 --> 00:23:42,070
where we didn't actually have a malli

00:23:38,830 --> 00:23:44,200
library for am logic or something at the

00:23:42,070 --> 00:23:46,870
time and so we actually had to use an

00:23:44,200 --> 00:23:48,720
app Rockchip version to be able to test

00:23:46,870 --> 00:23:52,300
it and it works fine it's just the

00:23:48,720 --> 00:23:54,140
licensing was very explicit that it can

00:23:52,300 --> 00:23:56,870
only be used in

00:23:54,140 --> 00:23:59,090
on its hardware for distribution

00:23:56,870 --> 00:24:08,559
purposes so but it was good for testing

00:23:59,090 --> 00:24:08,559
so thank you yes well good

00:24:08,710 --> 00:24:18,010
mm-hmm I so the question was if I'd have

00:24:13,429 --> 00:24:22,250
done anything with IMX 8 and yes and no

00:24:18,010 --> 00:24:24,290
because I do have an IM x8 board I just

00:24:22,250 --> 00:24:26,059
have their their developer board and I'm

00:24:24,290 --> 00:24:31,160
actually very excited to do stuff with

00:24:26,059 --> 00:24:33,350
it but but there's just not much going

00:24:31,160 --> 00:24:35,059
on at the moment a lot of the guys that

00:24:33,350 --> 00:24:37,880
are working on Hatton Aviv and will be

00:24:35,059 --> 00:24:39,770
doing I mx8 stuff are still kind of tied

00:24:37,880 --> 00:24:43,520
up getting some of the stuff in for imx6

00:24:39,770 --> 00:24:44,960
into Mesa and into the kernel but as far

00:24:43,520 --> 00:24:48,320
as I know they do have some stuff for

00:24:44,960 --> 00:24:50,660
IMX 8 and hopefully we'll see that in

00:24:48,320 --> 00:24:52,970
the next six months or so at least to

00:24:50,660 --> 00:24:58,010
get something running but with IMX 8

00:24:52,970 --> 00:25:00,410
also it the video decoder is a different

00:24:58,010 --> 00:25:02,960
IP than what's used on imx6 so it'll

00:25:00,410 --> 00:25:07,220
require a complete and a new driver for

00:25:02,960 --> 00:25:08,660
that and apparently documentation is

00:25:07,220 --> 00:25:10,910
there and everything it's just the work

00:25:08,660 --> 00:25:14,540
has to be done so eventually hopefully

00:25:10,910 --> 00:25:17,360
and because I look forward to mx8 with

00:25:14,540 --> 00:25:21,760
4k video and h.265 and everything as

00:25:17,360 --> 00:25:21,760
well so yep thank you

00:25:24,470 --> 00:25:32,640
cool thanks so much guys

00:25:28,830 --> 00:25:37,649
[Applause]

00:25:32,640 --> 00:25:37,649

YouTube URL: https://www.youtube.com/watch?v=H1YLEXVFNfw


