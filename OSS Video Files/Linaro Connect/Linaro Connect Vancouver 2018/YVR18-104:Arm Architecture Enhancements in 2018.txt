Title: YVR18-104:Arm Architecture Enhancements in 2018
Publication date: 2019-05-09
Playlist: Linaro Connect Vancouver 2018
Description: 
	The Arm Architecture is continually evolving as new features and enhancements are developed to meet market demand. Arm, Linaro, and the wider ecosystem build on the foundations of the Architecture, creating a rich and varied range of products along with associated Firmware and Software, driving the technology of the future.

This presentation will include details of the iterative functionality Arm has been developing in 2018.  It will discuss the software enablement that has been going on, and the future development needs of the wider ecosystem, to ensure that software is available when physical products are delivered.
Captions: 
	00:00:02,070 --> 00:00:07,080
[Music]

00:00:08,460 --> 00:00:14,559
good afternoon my name is Matt Breton

00:00:11,590 --> 00:00:17,410
tan I'm the product manager for the

00:00:14,559 --> 00:00:19,960
architecture Assam which means that I'm

00:00:17,410 --> 00:00:21,640
able alleged need to talk about our

00:00:19,960 --> 00:00:24,100
market Ettrick improvements and

00:00:21,640 --> 00:00:25,510
enhancements I've done in 2018 the too

00:00:24,100 --> 00:00:30,010
long didn't read version that this

00:00:25,510 --> 00:00:32,470
presentation is I'm eight point five so

00:00:30,010 --> 00:00:36,190
yes Who am I as I said I'm putting on

00:00:32,470 --> 00:00:38,980
her arm my history is that I've been

00:00:36,190 --> 00:00:41,320
armed now 14 odd years I started out in

00:00:38,980 --> 00:00:42,940
compiler engineering I had a long

00:00:41,320 --> 00:00:45,820
history with the Naro I let the tool

00:00:42,940 --> 00:00:50,500
chain working group for 18 months a

00:00:45,820 --> 00:00:51,820
couple of years ago and so yes then

00:00:50,500 --> 00:00:54,550
coming here it's nice to be back

00:00:51,820 --> 00:00:56,200
connect has changed and not changed at

00:00:54,550 --> 00:01:00,730
the same time nice to see so many faiths

00:00:56,200 --> 00:01:01,600
familiar faces and why am I here well it

00:01:00,730 --> 00:01:03,730
says on the screen

00:01:01,600 --> 00:01:05,700
talk about ARM architecture developments

00:01:03,730 --> 00:01:07,690
in 2018 I want to talk about motivation

00:01:05,700 --> 00:01:09,820
we're here to talk about software

00:01:07,690 --> 00:01:11,260
enablement we're not saying we've got

00:01:09,820 --> 00:01:13,600
hardware for these hardware is still

00:01:11,260 --> 00:01:15,790
three to five years away but we need to

00:01:13,600 --> 00:01:18,310
have the software enabled and software

00:01:15,790 --> 00:01:21,580
stuff stacks available for when the

00:01:18,310 --> 00:01:25,720
hardware's um made available and devices

00:01:21,580 --> 00:01:27,670
are available so we have the arm a

00:01:25,720 --> 00:01:29,860
profile architecture is which is what

00:01:27,670 --> 00:01:32,020
I'm talking about today this is arm V

00:01:29,860 --> 00:01:34,600
8.0 you know the main thing we added

00:01:32,020 --> 00:01:38,830
there was the 64-bit architecture and

00:01:34,600 --> 00:01:40,869
crypto is the other big new future and

00:01:38,830 --> 00:01:43,810
since then we have continuously improved

00:01:40,869 --> 00:01:45,820
it 8.1 came along at the eight years of

00:01:43,810 --> 00:01:48,130
virtualization host extensions support

00:01:45,820 --> 00:01:52,240
for or improved support for type 2

00:01:48,130 --> 00:01:54,850
hypervisors Atomics support for further

00:01:52,240 --> 00:01:58,930
support atomic operations over and above

00:01:54,850 --> 00:02:02,070
what was in 8.08 point to answer as

00:01:58,930 --> 00:02:04,240
reliability availability serviceability

00:02:02,070 --> 00:02:07,909
statistical profile name it's just debug

00:02:04,240 --> 00:02:10,369
feature half a station floating-point

00:02:07,909 --> 00:02:12,890
we then came up and we've already heard

00:02:10,369 --> 00:02:15,800
mentioned today of sve from Fujitsu

00:02:12,890 --> 00:02:21,020
'he's a 64 f of X so I believe the core

00:02:15,800 --> 00:02:24,709
name that George showed sve scalable

00:02:21,020 --> 00:02:26,239
vector extension and then eight point

00:02:24,709 --> 00:02:29,030
three point authentication which I will

00:02:26,239 --> 00:02:34,850
actually come back to in a bit I'll CPC

00:02:29,030 --> 00:02:36,620
which is another load store memory

00:02:34,850 --> 00:02:41,230
consistency list of virtualization

00:02:36,620 --> 00:02:43,850
support an eight point for last year

00:02:41,230 --> 00:02:45,700
though the crypto instructions secure

00:02:43,850 --> 00:02:48,730
el2 allowing a hypervisor type

00:02:45,700 --> 00:02:52,700
functionality on the secure side and

00:02:48,730 --> 00:02:54,590
some tightening and formalization at the

00:02:52,700 --> 00:02:57,140
our memory model and we've been doing

00:02:54,590 --> 00:02:59,630
this incremental a year after year these

00:02:57,140 --> 00:03:00,860
are this isn't everything there's many

00:02:59,630 --> 00:03:03,590
more features added to the ARM

00:03:00,860 --> 00:03:05,780
architecture I think I counted up to 90

00:03:03,590 --> 00:03:08,420
when I was running through trying to

00:03:05,780 --> 00:03:09,890
pull them all together that they're all

00:03:08,420 --> 00:03:12,079
small increments and this is what we're

00:03:09,890 --> 00:03:14,660
doing this year yet more small

00:03:12,079 --> 00:03:16,820
increments seeing what's the need of the

00:03:14,660 --> 00:03:18,739
ecosystem where the markets are taking

00:03:16,820 --> 00:03:20,450
us and working with what our partners

00:03:18,739 --> 00:03:24,380
including the Naro and then are as

00:03:20,450 --> 00:03:27,920
members require so here's an overview of

00:03:24,380 --> 00:03:31,820
our eight point five features this still

00:03:27,920 --> 00:03:34,700
isn't a complete list there's you know

00:03:31,820 --> 00:03:37,160
it'd be good to three sites list

00:03:34,700 --> 00:03:40,370
everything but these are the ones I'm

00:03:37,160 --> 00:03:42,350
gonna be talking about today starts with

00:03:40,370 --> 00:03:45,530
memory tagging extensions branch target

00:03:42,350 --> 00:03:47,450
identifiers and going through as we go

00:03:45,530 --> 00:03:50,930
and some of these are very small

00:03:47,450 --> 00:03:53,650
additions as we'll see and some are more

00:03:50,930 --> 00:04:00,620
larger they've all been worked through

00:03:53,650 --> 00:04:04,459
with the ecosystem so one of the main

00:04:00,620 --> 00:04:08,390
topics of 2018 has been security and

00:04:04,459 --> 00:04:11,750
spectrum meltdown but actually that's

00:04:08,390 --> 00:04:13,130
not the only security spectrum meltdown

00:04:11,750 --> 00:04:15,680
aren't the only security issues we're

00:04:13,130 --> 00:04:17,840
facing today and before we start talking

00:04:15,680 --> 00:04:19,549
about some security features I want to

00:04:17,840 --> 00:04:20,220
just make sure we've all agreed some

00:04:19,549 --> 00:04:22,170
definition

00:04:20,220 --> 00:04:24,510
what I'm going to talk about that the

00:04:22,170 --> 00:04:28,500
vulnerability is the open door that

00:04:24,510 --> 00:04:30,720
allows an attacker in and an exploitive

00:04:28,500 --> 00:04:34,680
occurs when an attacker takes advantage

00:04:30,720 --> 00:04:38,190
of a vulnerability and it turns out that

00:04:34,680 --> 00:04:41,990
2018 is the 30th anniversary of the

00:04:38,190 --> 00:04:46,350
Morris worm which was one of the first

00:04:41,990 --> 00:04:49,680
worms that gained notoriety and that

00:04:46,350 --> 00:04:52,050
made use of buffer overflows and here we

00:04:49,680 --> 00:04:54,930
are 30 years later and you look at the

00:04:52,050 --> 00:04:58,200
CDE database and a substantial number of

00:04:54,930 --> 00:05:01,290
issues are still buffer overflows and

00:04:58,200 --> 00:05:03,060
use after free so we think spectrum

00:05:01,290 --> 00:05:04,470
meltdown is all 2018 is all new but

00:05:03,060 --> 00:05:06,480
actually we're still suffering and

00:05:04,470 --> 00:05:12,000
dealing with issues that were first

00:05:06,480 --> 00:05:15,660
identified 30 years ago and excuse me

00:05:12,000 --> 00:05:17,250
buffer if over those are when you access

00:05:15,660 --> 00:05:22,260
memory running out past the end of an

00:05:17,250 --> 00:05:24,419
allocation so in the diagram of memory

00:05:22,260 --> 00:05:27,419
on the right if you're trying to if you

00:05:24,419 --> 00:05:29,990
had your buffer from 8,000 to 9,000 and

00:05:27,419 --> 00:05:33,450
for some reason you tried to access

00:05:29,990 --> 00:05:36,330
9,500 that's a buffer overrun and we're

00:05:33,450 --> 00:05:38,310
also talking about use after free which

00:05:36,330 --> 00:05:40,260
is accessing freed memory through a

00:05:38,310 --> 00:05:42,419
stale old stale pointer a pointer that

00:05:40,260 --> 00:05:45,090
exists even though you to memory even

00:05:42,419 --> 00:05:47,430
though you freed it many many

00:05:45,090 --> 00:05:51,750
vulnerabilities in the CVE database are

00:05:47,430 --> 00:05:57,330
caused by this these functions these

00:05:51,750 --> 00:05:58,830
vulnerability types so forearm 8.5 we're

00:05:57,330 --> 00:06:01,890
introducing something called memory

00:05:58,830 --> 00:06:04,740
tagging extension and then we tagging

00:06:01,890 --> 00:06:08,040
probabilistically detects memory safety

00:06:04,740 --> 00:06:11,160
vulnerabilities so it enables you just

00:06:08,040 --> 00:06:14,250
update your software before the defenses

00:06:11,160 --> 00:06:17,700
are tested so you can detect issues such

00:06:14,250 --> 00:06:20,340
as you saw free and buffer overflows in

00:06:17,700 --> 00:06:23,850
the lab when you're developing or in the

00:06:20,340 --> 00:06:26,790
field when users are using your code

00:06:23,850 --> 00:06:28,229
because we see a lot of issues aren't

00:06:26,790 --> 00:06:30,240
detectable in that because you don't

00:06:28,229 --> 00:06:32,849
have enough inputs you don't have enough

00:06:30,240 --> 00:06:33,729
stimuluses to your software it takes a

00:06:32,849 --> 00:06:35,439
lot

00:06:33,729 --> 00:06:40,360
different stimuluses to find all the

00:06:35,439 --> 00:06:42,550
issues so how does this work when memory

00:06:40,360 --> 00:06:45,849
is allocated or freed it is given the

00:06:42,550 --> 00:06:47,229
tag on the left here all the memory

00:06:45,849 --> 00:06:49,569
allocations have been given the tag

00:06:47,229 --> 00:06:52,449
we're using color also to help identify

00:06:49,569 --> 00:06:56,529
the tags so the blue area has been

00:06:52,449 --> 00:07:01,150
tagged for and all accesses to memory

00:06:56,529 --> 00:07:03,520
must be made with the same tag on the on

00:07:01,150 --> 00:07:05,889
the pointer as that the memory has been

00:07:03,520 --> 00:07:10,210
tagged with this standard a lock and key

00:07:05,889 --> 00:07:14,080
scheme so for example here are two good

00:07:10,210 --> 00:07:19,149
accesses the access to our eight to

00:07:14,080 --> 00:07:22,330
eight is made with the blue four key and

00:07:19,149 --> 00:07:26,710
that gets allowed through and the oxo 70

00:07:22,330 --> 00:07:30,339
gets through oxo seven up to nine ten

00:07:26,710 --> 00:07:31,960
ninety ten is allowed through because

00:07:30,339 --> 00:07:37,479
they're using the same key that the lock

00:07:31,960 --> 00:07:40,689
has this access a buffer overflow isn't

00:07:37,479 --> 00:07:45,459
allowed because the key of oxo six

00:07:40,689 --> 00:07:49,360
doesn't match the look of for and if we

00:07:45,459 --> 00:07:51,999
then go in free memory as we free the

00:07:49,360 --> 00:07:54,669
memory we changed that look so the stale

00:07:51,999 --> 00:07:56,709
now stale pointer would fail if we try

00:07:54,669 --> 00:07:59,999
and use that to access that memory so we

00:07:56,709 --> 00:07:59,999
detect the use after free

00:08:05,930 --> 00:08:11,630
so what's the use of this how do we use

00:08:08,210 --> 00:08:15,880
it so we believe tag checking can be

00:08:11,630 --> 00:08:18,860
introduced incremental e deploying

00:08:15,880 --> 00:08:20,960
memory allocator so your malach your je

00:08:18,860 --> 00:08:24,110
a lock whatever your Lipsey's memory

00:08:20,960 --> 00:08:26,750
allocator is updating that to understand

00:08:24,110 --> 00:08:31,430
NCE and then just deploying that on your

00:08:26,750 --> 00:08:36,669
system will give you guards of your heap

00:08:31,430 --> 00:08:39,589
allocations stat and buffer overflows

00:08:36,669 --> 00:08:41,570
require a saree stack and global

00:08:39,589 --> 00:08:44,060
checking requires you to upgrade your

00:08:41,570 --> 00:08:46,570
compiler and we have working on

00:08:44,060 --> 00:08:49,130
compilers and will be up streaming those

00:08:46,570 --> 00:08:50,480
at some point and romana can talk

00:08:49,130 --> 00:08:52,760
further about that and we'll be talking

00:08:50,480 --> 00:08:55,100
in the tool chain working group about

00:08:52,760 --> 00:08:59,660
plans for that as we go through this

00:08:55,100 --> 00:09:01,310
week and this has been aimed and the

00:08:59,660 --> 00:09:02,900
priority here for us is on checking

00:09:01,310 --> 00:09:06,980
memory allocations in the set unsafe

00:09:02,900 --> 00:09:10,640
languages such as C and C++ yes there

00:09:06,980 --> 00:09:13,339
are languages that give memory safety or

00:09:10,640 --> 00:09:15,800
attempt to give memory safety but we

00:09:13,339 --> 00:09:18,680
still see a large usage of C and C++ and

00:09:15,800 --> 00:09:23,120
that's the locations we're trying to aim

00:09:18,680 --> 00:09:26,300
for and you can view empty as on device

00:09:23,120 --> 00:09:30,020
hardware acceleration tools such as the

00:09:26,300 --> 00:09:34,760
excellent address sanitizer if you talk

00:09:30,020 --> 00:09:36,170
to various people doing large-scale

00:09:34,760 --> 00:09:38,089
software developments they could say

00:09:36,170 --> 00:09:40,040
their run address sanitizer on their

00:09:38,089 --> 00:09:45,410
codebase and their systems and they'll

00:09:40,040 --> 00:09:48,380
be finding bugs every week and this

00:09:45,410 --> 00:09:50,240
helps us find those bugs quicker because

00:09:48,380 --> 00:09:53,540
address sanitizer is very difficult to

00:09:50,240 --> 00:09:57,860
patrol in the field address sanitizer

00:09:53,540 --> 00:10:01,370
has a many X times 3 for X times at

00:09:57,860 --> 00:10:03,950
least overhead empty memory tagging has

00:10:01,370 --> 00:10:06,290
a lower overhead so it can be used in

00:10:03,950 --> 00:10:08,900
production environments as I said

00:10:06,290 --> 00:10:10,089
earlier it is probabilistic but if

00:10:08,900 --> 00:10:13,850
you're deploying it in large-scale

00:10:10,089 --> 00:10:15,370
deployments the probabilities tend to

00:10:13,850 --> 00:10:17,000
that you're going to find these issues

00:10:15,370 --> 00:10:18,559
you're going to find your

00:10:17,000 --> 00:10:20,299
vulnerabilities

00:10:18,559 --> 00:10:23,449
and finding your vulnerabilities before

00:10:20,299 --> 00:10:26,739
they get attacked means that you don't

00:10:23,449 --> 00:10:28,819
get attacked you get to fix early and

00:10:26,739 --> 00:10:30,949
ultimately as we all know finding and

00:10:28,819 --> 00:10:33,319
fixing vulnerabilities and software

00:10:30,949 --> 00:10:35,749
issues that earlier you can fix them the

00:10:33,319 --> 00:10:39,339
cheaper it is in terms of effort and

00:10:35,749 --> 00:10:41,809
cost to fix those issues rather than

00:10:39,339 --> 00:10:46,779
fixing having to fix them when they

00:10:41,809 --> 00:10:51,429
become a full-scale attack vector and

00:10:46,779 --> 00:10:51,429
being used to be it as an attack vector

00:10:53,499 --> 00:11:00,889
so memory tagging is all about detecting

00:10:57,979 --> 00:11:03,949
vulnerabilities and trying to help stop

00:11:00,889 --> 00:11:06,499
allowing an attacker in but an attacker

00:11:03,949 --> 00:11:09,249
is let's assume an attacker is going to

00:11:06,499 --> 00:11:15,709
be able to find a way in what can we do

00:11:09,249 --> 00:11:17,989
to help prevent that attacker having an

00:11:15,709 --> 00:11:24,739
exploit having a large surface of

00:11:17,989 --> 00:11:27,399
exploits available so in 8.3 we

00:11:24,739 --> 00:11:30,470
introduced pointer authentication

00:11:27,399 --> 00:11:32,419
pointer authentication one of its uses

00:11:30,470 --> 00:11:37,309
is is a strong defense against robbed

00:11:32,419 --> 00:11:41,679
tax return or into programming rot works

00:11:37,309 --> 00:11:45,439
by an attacker get it gaining access to

00:11:41,679 --> 00:11:47,029
your saw to your code and using gadgets

00:11:45,439 --> 00:11:49,279
in those code and the return and

00:11:47,029 --> 00:11:52,789
corrupting your return address so that

00:11:49,279 --> 00:11:54,769
it can chain bits of code together to do

00:11:52,789 --> 00:11:58,569
what the attacker wants not what you

00:11:54,769 --> 00:12:03,439
originally intended the code to do

00:11:58,569 --> 00:12:06,769
pointer authentication enables you that

00:12:03,439 --> 00:12:09,019
when you enter a function you sign you

00:12:06,769 --> 00:12:10,819
add a point or authentication part to

00:12:09,019 --> 00:12:12,589
your link register you sign your link

00:12:10,819 --> 00:12:15,829
register and when you return from that

00:12:12,589 --> 00:12:18,829
function you authenticate the address

00:12:15,829 --> 00:12:21,079
you're returning to and if you if the

00:12:18,829 --> 00:12:24,439
authentication fails you get an

00:12:21,079 --> 00:12:26,269
exception so that it prevents someone

00:12:24,439 --> 00:12:28,749
jumping halfway into your function and

00:12:26,269 --> 00:12:32,240
using the wrong return address and

00:12:28,749 --> 00:12:36,589
therefore reduces the

00:12:32,240 --> 00:12:40,220
oriented programming surface and that

00:12:36,589 --> 00:12:43,149
was introduced in 8.3 in 8.5 we're

00:12:40,220 --> 00:12:46,100
introducing a complementary technology

00:12:43,149 --> 00:12:49,220
called branch target identifier and

00:12:46,100 --> 00:12:52,100
these are aimed at reducing the viable

00:12:49,220 --> 00:12:56,630
jump oriented programming gadgets job

00:12:52,100 --> 00:12:59,360
gadgets and the way this works is that

00:12:56,630 --> 00:13:02,959
as you see there's a under good there's

00:12:59,360 --> 00:13:04,490
a BTI instruction we mark pages

00:13:02,959 --> 00:13:08,209
containing BTI

00:13:04,490 --> 00:13:11,089
and then indirect branches can only

00:13:08,209 --> 00:13:14,320
branch to the locations which we've

00:13:11,089 --> 00:13:17,480
identified as accepting as being good

00:13:14,320 --> 00:13:19,940
locations for indirect branches by the

00:13:17,480 --> 00:13:22,940
BTI instructions so this green line is

00:13:19,940 --> 00:13:25,940
good because the BL rx0 is going through

00:13:22,940 --> 00:13:30,410
a b TI the C stands for cool so it's a

00:13:25,940 --> 00:13:34,370
cool a BLR and that's fine that this

00:13:30,410 --> 00:13:36,890
would cause an exception because you're

00:13:34,370 --> 00:13:38,540
branching to move instruction in a b TI

00:13:36,890 --> 00:13:41,089
page and a move instruction isn't a

00:13:38,540 --> 00:13:44,899
beauty our instruction and of course a

00:13:41,089 --> 00:13:48,290
fault we don't do this on the ret

00:13:44,899 --> 00:13:48,890
branches direct branches are to a fixed

00:13:48,290 --> 00:13:51,140
location

00:13:48,890 --> 00:13:58,040
it's the indirect branches where this

00:13:51,140 --> 00:14:00,470
needs to be protected so we see branch

00:13:58,040 --> 00:14:02,899
authentication a pointer authentication

00:14:00,470 --> 00:14:06,020
and branch target identifies as working

00:14:02,899 --> 00:14:08,899
together so we did some research

00:14:06,020 --> 00:14:10,700
internally and there's external reset

00:14:08,899 --> 00:14:13,880
that's been external research that's

00:14:10,700 --> 00:14:17,270
been done as well by other groups that

00:14:13,880 --> 00:14:20,480
returns from the results and basically

00:14:17,270 --> 00:14:21,920
we see that while pack and BT I don't

00:14:20,480 --> 00:14:24,350
get rid of all the gadgets that are

00:14:21,920 --> 00:14:26,300
possible and make a significant

00:14:24,350 --> 00:14:29,300
reduction this is looking at a bun

00:14:26,300 --> 00:14:31,850
through 1404 s gzip C and the gadgets in

00:14:29,300 --> 00:14:33,860
there G Lib C being a prime target for

00:14:31,850 --> 00:14:38,720
people to attack because of some of the

00:14:33,860 --> 00:14:41,329
things it can do and we see a massive

00:14:38,720 --> 00:14:43,400
reduction and also what we see is that

00:14:41,329 --> 00:14:45,500
the length of gadgets increases and as

00:14:43,400 --> 00:14:47,630
the length the gadget increases that

00:14:45,500 --> 00:14:49,310
catch it we'll be doing more and you'll

00:14:47,630 --> 00:14:53,750
be doing things that an attacker doesn't

00:14:49,310 --> 00:14:55,640
necessarily isn't able to control it

00:14:53,750 --> 00:14:57,620
makes the gadgets less stable which is

00:14:55,640 --> 00:15:00,830
why we've restricted this table to the

00:14:57,620 --> 00:15:02,060
gadgets of lesson 10 instructions and

00:15:00,830 --> 00:15:04,880
many of the remaining gadgets are

00:15:02,060 --> 00:15:06,440
actually hold functions so you're

00:15:04,880 --> 00:15:08,360
actually executing whole functions and

00:15:06,440 --> 00:15:11,990
those become Cadets which they were

00:15:08,360 --> 00:15:16,090
anyway and as I said this is arm data

00:15:11,990 --> 00:15:19,430
what's interesting excuse me oh the job

00:15:16,090 --> 00:15:22,100
with PAC bTW I reduced to 11

00:15:19,430 --> 00:15:23,900
gadgets invest we did some

00:15:22,100 --> 00:15:25,550
investigations at those and only two of

00:15:23,900 --> 00:15:28,430
those are what to call dispatch of

00:15:25,550 --> 00:15:34,010
gadgets which is what an attacker would

00:15:28,430 --> 00:15:37,300
use to control his attack and dispatch

00:15:34,010 --> 00:15:40,820
to other gadgets to execute his attack

00:15:37,300 --> 00:15:43,130
and one of those by changing the

00:15:40,820 --> 00:15:45,380
compile-time options to stop allowing

00:15:43,130 --> 00:15:47,750
jump threading it stopped being a

00:15:45,380 --> 00:15:49,400
dispatcher gadget and the other one you

00:15:47,750 --> 00:15:51,980
could go and look at your source code

00:15:49,400 --> 00:15:55,880
and make an effort to rewrite and that

00:15:51,980 --> 00:15:57,470
was topic being a dispatcher and yes

00:15:55,880 --> 00:15:59,960
there's still many of them intervention

00:15:57,470 --> 00:16:01,880
required but when it becomes two gadgets

00:15:59,960 --> 00:16:04,100
that you need to look at or 11 gadgets

00:16:01,880 --> 00:16:06,290
that's manageable whereas when you're

00:16:04,100 --> 00:16:08,690
looking at nearly 6,000 gadgets that's

00:16:06,290 --> 00:16:09,530
an awful lot and you can't go and catch

00:16:08,690 --> 00:16:12,680
every issue

00:16:09,530 --> 00:16:15,200
so again pointer authentication branch

00:16:12,680 --> 00:16:18,339
target identifiers reducing the

00:16:15,200 --> 00:16:18,339
exploitable surface

00:16:22,630 --> 00:16:31,420
that's right one thing I would say here

00:16:25,259 --> 00:16:33,220
and the deployments release is that the

00:16:31,420 --> 00:16:35,829
instructions for what we've talked about

00:16:33,220 --> 00:16:38,079
are all in the no op space so actually

00:16:35,829 --> 00:16:40,269
you could write code or compile code

00:16:38,079 --> 00:16:41,440
today with compilers that support point

00:16:40,269 --> 00:16:44,470
authentication and when it's available

00:16:41,440 --> 00:16:46,870
branch target identifiers and the code

00:16:44,470 --> 00:16:51,250
will run on of the 8.0 machine of the

00:16:46,870 --> 00:16:52,690
8.2 machine oh and the instructions

00:16:51,250 --> 00:16:55,930
would act as no ops II won't get any

00:16:52,690 --> 00:16:59,170
seed security but the code will run and

00:16:55,930 --> 00:17:01,569
act as it should run then once 8.5

00:16:59,170 --> 00:17:04,679
machines are available and devices are

00:17:01,569 --> 00:17:09,789
available that same code would start

00:17:04,679 --> 00:17:11,289
executing those security parts and you

00:17:09,789 --> 00:17:13,120
will get the protections from pointer

00:17:11,289 --> 00:17:19,929
authentication and branch target

00:17:13,120 --> 00:17:21,549
identifies excuse me so the question was

00:17:19,929 --> 00:17:26,770
do we have those instructions for 32-bit

00:17:21,549 --> 00:17:29,429
the answer is no I think no I was just

00:17:26,770 --> 00:17:29,429
checking with Ramana

00:17:33,220 --> 00:17:42,139
so those were two of the larger features

00:17:37,820 --> 00:17:48,080
from writing enhancements moving on to a

00:17:42,139 --> 00:17:51,830
selection of smaller features and

00:17:48,080 --> 00:17:56,419
enhancements sorts with random number

00:17:51,830 --> 00:17:57,710
generation instructions what I like is

00:17:56,419 --> 00:17:59,450
that you say it's a random number

00:17:57,710 --> 00:18:01,940
generator he's got a true random number

00:17:59,450 --> 00:18:03,169
generator a deterministic one you know

00:18:01,940 --> 00:18:05,779
the things and then there's this

00:18:03,169 --> 00:18:08,960
alphabet spaghetti of standards that

00:18:05,779 --> 00:18:12,919
it's got to comply with but basically

00:18:08,960 --> 00:18:17,559
it's a random number generator provided

00:18:12,919 --> 00:18:17,559
by a couple of instructions from the CPU

00:18:19,899 --> 00:18:26,320
another security related topic of this

00:18:23,539 --> 00:18:28,850
one's actually related to meltdown as

00:18:26,320 --> 00:18:34,220
I'm sure many people in this room are

00:18:28,850 --> 00:18:37,480
aware the way we have been protecting

00:18:34,220 --> 00:18:41,899
against meltdown has been through kpti

00:18:37,480 --> 00:18:43,519
kind of page table isolation and this is

00:18:41,899 --> 00:18:48,889
all well and good except that it

00:18:43,519 --> 00:18:53,779
prevents access from user space to the

00:18:48,889 --> 00:18:56,269
SP and self hosted trace buffers and you

00:18:53,779 --> 00:19:00,590
wanted to do trace and SP that's a bit

00:18:56,269 --> 00:19:06,830
of a problem so we've added in 8.5

00:19:00,590 --> 00:19:08,990
support to say that l0 can't access the

00:19:06,830 --> 00:19:10,580
TTP l1 space and give a translation

00:19:08,990 --> 00:19:12,490
fault and it gives a translation fault

00:19:10,580 --> 00:19:15,440
when it tries to do that and that

00:19:12,490 --> 00:19:18,649
enables us not sneak a PTI because then

00:19:15,440 --> 00:19:19,909
your access to the trying to access your

00:19:18,649 --> 00:19:21,980
kernel address mapping and then it's

00:19:19,909 --> 00:19:23,330
kind of address map always faults in a

00:19:21,980 --> 00:19:25,009
constant time it doesn't matter where

00:19:23,330 --> 00:19:28,690
that page was actually mapped in or not

00:19:25,009 --> 00:19:31,639
there's a constant time fault which is

00:19:28,690 --> 00:19:35,259
what meltdown was making use of the fact

00:19:31,639 --> 00:19:35,259
that that fault wasn't a constant time

00:19:38,360 --> 00:19:42,120
moving on again as I said

00:19:40,490 --> 00:19:47,580
eight-point-five is full of many

00:19:42,120 --> 00:19:50,730
different features some are larger some

00:19:47,580 --> 00:19:52,440
smaller this one is about jits and when

00:19:50,730 --> 00:19:55,140
you're optimizing code that is already

00:19:52,440 --> 00:19:56,580
running and technically the behavior

00:19:55,140 --> 00:19:58,950
acts now has been undefined in the ARM

00:19:56,580 --> 00:20:00,870
architecture except that all CPUs have

00:19:58,950 --> 00:20:02,880
done the right thing as we're about to

00:20:00,870 --> 00:20:08,580
say what the right thing is and we're

00:20:02,880 --> 00:20:11,610
just now defining that right thing so

00:20:08,580 --> 00:20:13,590
what we're trying to do is that an

00:20:11,610 --> 00:20:16,169
executing processor will run this code

00:20:13,590 --> 00:20:17,700
path repeatedly and your JIT will see

00:20:16,169 --> 00:20:19,799
that that's hot and decide that it wants

00:20:17,700 --> 00:20:21,809
to optimize that code and it wants to

00:20:19,799 --> 00:20:25,169
optimize it running in another thread on

00:20:21,809 --> 00:20:27,000
another processor whilst you're still

00:20:25,169 --> 00:20:29,970
running your code so that you don't see

00:20:27,000 --> 00:20:32,340
any stoppages your code doesn't stop

00:20:29,970 --> 00:20:34,710
running whilst you're still optimizing

00:20:32,340 --> 00:20:36,659
so you have this code and the first

00:20:34,710 --> 00:20:39,360
thing you do then is the modifying

00:20:36,659 --> 00:20:41,250
processor will compile and write a new

00:20:39,360 --> 00:20:43,139
routine optimized routine in memory and

00:20:41,250 --> 00:20:46,440
flush the cache at the end of that

00:20:43,139 --> 00:20:48,169
routine it will put a branch back to the

00:20:46,440 --> 00:20:53,480
end the original code where it wants to

00:20:48,169 --> 00:20:56,389
reenter the code sequence then the

00:20:53,480 --> 00:20:59,519
modifying processor will write a branch

00:20:56,389 --> 00:21:06,059
to that new optimized routine in memory

00:20:59,519 --> 00:21:07,860
and flush the cache so that once the

00:21:06,059 --> 00:21:09,659
original prose the executing processor

00:21:07,860 --> 00:21:11,909
notices that flush and picks up the

00:21:09,659 --> 00:21:14,250
change in memory this is the sequence

00:21:11,909 --> 00:21:18,049
you should get that you go to that new

00:21:14,250 --> 00:21:24,090
memory and run the new optimized routine

00:21:18,049 --> 00:21:27,659
so the point is is that we have now made

00:21:24,090 --> 00:21:31,019
sure that 1 and 2 are ordered so that

00:21:27,659 --> 00:21:33,120
once you've written if you've written

00:21:31,019 --> 00:21:34,980
and flushed your code flushed the code

00:21:33,120 --> 00:21:37,440
out and then you write the branch and

00:21:34,980 --> 00:21:39,809
flush that out you can guarantee that

00:21:37,440 --> 00:21:41,070
you will get the new code when you do

00:21:39,809 --> 00:21:43,440
that branch

00:21:41,070 --> 00:21:46,049
and now this isn't a problem on any

00:21:43,440 --> 00:21:49,279
previous Court and this is this we said

00:21:46,049 --> 00:21:52,220
needs to be true of any new cpu produced

00:21:49,279 --> 00:21:54,090
that this is behavior we've all been

00:21:52,220 --> 00:21:56,820
expecting to work him to behave like

00:21:54,090 --> 00:21:58,500
this but actually there was corner cases

00:21:56,820 --> 00:21:59,820
in the ARM architecture where

00:21:58,500 --> 00:22:03,000
technically it could be an undefined

00:21:59,820 --> 00:22:05,639
behavior and so we've cleared that up

00:22:03,000 --> 00:22:09,019
and tidy that up to make sure this works

00:22:05,639 --> 00:22:09,019
as people expect

00:22:15,170 --> 00:22:18,560
has already been discussions this

00:22:17,990 --> 00:22:20,090
morning

00:22:18,560 --> 00:22:25,190
moving on yet again to yet another

00:22:20,090 --> 00:22:29,510
completely different topic about porting

00:22:25,190 --> 00:22:31,960
and running code and making sure code

00:22:29,510 --> 00:22:34,040
runs in multiple architectures and

00:22:31,960 --> 00:22:35,480
different architectures handle

00:22:34,040 --> 00:22:38,630
conversions from floating-point to

00:22:35,480 --> 00:22:40,130
integer differently for the numbers that

00:22:38,630 --> 00:22:44,740
are out of range you can't represent in

00:22:40,130 --> 00:22:46,760
an integer they're not a numbers and

00:22:44,740 --> 00:22:49,040
normally this difference isn't very

00:22:46,760 --> 00:22:50,210
important because we're handling numbers

00:22:49,040 --> 00:22:52,580
that are in range and we can represent

00:22:50,210 --> 00:22:54,470
and that matters but that's easy that

00:22:52,580 --> 00:22:56,030
everyone agrees on how to do that it's

00:22:54,470 --> 00:23:01,100
the extremities where people have

00:22:56,030 --> 00:23:03,070
differences and um but there are cases

00:23:01,100 --> 00:23:05,060
where this difference in behavior

00:23:03,070 --> 00:23:08,300
produces the difference in behavior of

00:23:05,060 --> 00:23:09,530
programs and that's not what you want if

00:23:08,300 --> 00:23:13,190
you're porting your code from one

00:23:09,530 --> 00:23:17,420
architecture to another so again 8.5 as

00:23:13,190 --> 00:23:21,320
a couple of instructions to provide that

00:23:17,420 --> 00:23:23,960
alternate behavior on arm to enable you

00:23:21,320 --> 00:23:29,150
to port your code and expect the same

00:23:23,960 --> 00:23:36,770
behavior if that bit of code matters for

00:23:29,150 --> 00:23:39,970
you moving on added various

00:23:36,770 --> 00:23:43,580
virtualization efficiency improvements

00:23:39,970 --> 00:23:45,920
so some of the coarse-grained el2 traps

00:23:43,580 --> 00:23:51,050
have been split up into multiple trap

00:23:45,920 --> 00:23:52,520
groups basically taking feedback from

00:23:51,050 --> 00:23:55,280
the community about how often they were

00:23:52,520 --> 00:24:00,680
trapping to yell to when I had when

00:23:55,280 --> 00:24:06,050
various cash registers or caches I cache

00:24:00,680 --> 00:24:07,160
instructions were executed and producing

00:24:06,050 --> 00:24:08,690
the number of traps that are needed

00:24:07,160 --> 00:24:12,230
speeding up your virtualization

00:24:08,690 --> 00:24:13,940
environment so we've got now as it says

00:24:12,230 --> 00:24:16,180
separately l2 traps for these various

00:24:13,940 --> 00:24:16,180
things

00:24:21,220 --> 00:24:27,409
content synchronization on exception

00:24:24,529 --> 00:24:30,020
entry and exit so when you take a

00:24:27,409 --> 00:24:32,240
service call or hypervisor call whatever

00:24:30,020 --> 00:24:34,610
and you go up an exception level you

00:24:32,240 --> 00:24:36,350
enter an exception level that's a

00:24:34,610 --> 00:24:38,539
context synchronization event that means

00:24:36,350 --> 00:24:42,380
there is things a flash registers are

00:24:38,539 --> 00:24:43,880
updated go and read the Arman glossary

00:24:42,380 --> 00:24:46,520
for exactly what happens there's a lot

00:24:43,880 --> 00:24:47,960
of things that happens but actually the

00:24:46,520 --> 00:24:49,880
feedback we got was that for some

00:24:47,960 --> 00:24:52,390
environments this is unnecessary you

00:24:49,880 --> 00:24:55,460
don't always need to do a complete

00:24:52,390 --> 00:24:57,500
context synchronization on entry to

00:24:55,460 --> 00:25:01,580
let's say a hypervisor that's just there

00:24:57,500 --> 00:25:06,289
to do a lightweight management of your

00:25:01,580 --> 00:25:07,820
system so the eight-point-five adds the

00:25:06,289 --> 00:25:10,120
ability for you to control whether you

00:25:07,820 --> 00:25:12,740
want to do a full context

00:25:10,120 --> 00:25:14,330
synchronization or or not all you don't

00:25:12,740 --> 00:25:17,570
want to do a Content synchronization on

00:25:14,330 --> 00:25:20,450
the exception entry and if you don't do

00:25:17,570 --> 00:25:23,899
one then it's up to you to make sure you

00:25:20,450 --> 00:25:27,980
put in the appropriate barriers within

00:25:23,899 --> 00:25:30,710
your exception handling code to make

00:25:27,980 --> 00:25:33,799
sure that if you do need things to have

00:25:30,710 --> 00:25:35,779
been synchronized that they are now for

00:25:33,799 --> 00:25:37,669
Linux this isn't going to be used

00:25:35,779 --> 00:25:39,110
because then it's these full context

00:25:37,669 --> 00:25:42,490
synchronization because of how it's

00:25:39,110 --> 00:25:44,990
designed but this is for other

00:25:42,490 --> 00:25:47,840
environments where we've had

00:25:44,990 --> 00:25:51,590
conversations with other operating

00:25:47,840 --> 00:25:54,100
system vendors and operating system

00:25:51,590 --> 00:25:54,100
designers

00:25:57,130 --> 00:26:04,120
and finally cash clean 2.80 persistence

00:26:01,090 --> 00:26:06,580
so if you have a system involving

00:26:04,120 --> 00:26:08,679
persistent memory it has this concept of

00:26:06,580 --> 00:26:12,970
a point of persistence when persistence

00:26:08,679 --> 00:26:14,500
when is the data actually persistent

00:26:12,970 --> 00:26:18,039
when is it gonna last beyond a power

00:26:14,500 --> 00:26:21,309
cycle and in old the 8.2 we actually

00:26:18,039 --> 00:26:24,929
introduced an instruction to do a data

00:26:21,309 --> 00:26:27,970
cache clean to that point of persistence

00:26:24,929 --> 00:26:30,909
but we've noticed them talking to the

00:26:27,970 --> 00:26:32,530
industry the storage industry that

00:26:30,909 --> 00:26:34,500
they've moved forward to actually

00:26:32,530 --> 00:26:38,919
identify two points in persistence

00:26:34,500 --> 00:26:41,409
there's the point persistence which is

00:26:38,919 --> 00:26:42,640
basically the point at which actually

00:26:41,409 --> 00:26:44,380
memory might not be completely

00:26:42,640 --> 00:26:46,900
persistent but there's enough energy

00:26:44,380 --> 00:26:49,929
left in the system if you pull the plug

00:26:46,900 --> 00:26:52,809
out that remaining energy will push all

00:26:49,929 --> 00:26:55,270
that data to the point of into your

00:26:52,809 --> 00:26:57,460
persistent memory and then there's the

00:26:55,270 --> 00:26:59,830
point of deep persistence or actually

00:26:57,460 --> 00:27:02,260
even that energy that's remaining in the

00:26:59,830 --> 00:27:03,970
system after you pull the plug out even

00:27:02,260 --> 00:27:05,530
that could fail and the data is

00:27:03,970 --> 00:27:10,929
persistence that's when it's really in

00:27:05,530 --> 00:27:12,760
your persistent memory 8.5 introduces a

00:27:10,929 --> 00:27:15,570
cache clean to this point of deep

00:27:12,760 --> 00:27:15,570
persistence

00:27:18,659 --> 00:27:25,539
and you know that's just been a very

00:27:22,179 --> 00:27:28,750
Whistlestop tour through the a profile

00:27:25,539 --> 00:27:30,610
architecture this is 8.4 there's three

00:27:28,750 --> 00:27:32,980
of the big things or what I thought with

00:27:30,610 --> 00:27:35,169
the big things for 8.5 as you see

00:27:32,980 --> 00:27:40,750
there's a lot of other little things as

00:27:35,169 --> 00:27:44,200
well we are working and will be pushing

00:27:40,750 --> 00:27:46,779
binutils patches upstream in the future

00:27:44,200 --> 00:27:47,889
we're working on lips on lips see

00:27:46,779 --> 00:27:50,830
changes we're working with the community

00:27:47,889 --> 00:27:54,370
on those will be updating their AVM and

00:27:50,830 --> 00:27:57,279
GCC and then its kernel as we move

00:27:54,370 --> 00:27:58,899
forward and what I am pleased to

00:27:57,279 --> 00:28:04,720
announce is that this screenshot is out

00:27:58,899 --> 00:28:07,000
of date so if you want to go and look at

00:28:04,720 --> 00:28:09,490
the instructions that we've added in the

00:28:07,000 --> 00:28:11,440
system registers we've added you can go

00:28:09,490 --> 00:28:15,519
on through our developer website today

00:28:11,440 --> 00:28:16,720
and go and download these it's I'm

00:28:15,519 --> 00:28:19,659
really pleased with this is the first

00:28:16,720 --> 00:28:21,429
time we've been able to say the the

00:28:19,659 --> 00:28:23,019
instructions and the system register

00:28:21,429 --> 00:28:26,070
descriptions are available on the same

00:28:23,019 --> 00:28:28,990
day that we announced the architecture

00:28:26,070 --> 00:28:30,960
it's not the full ARM arm the full arm

00:28:28,990 --> 00:28:34,649
arm is probably six months away still

00:28:30,960 --> 00:28:36,880
but that's got to go through more

00:28:34,649 --> 00:28:38,860
iterations there's a lot more work

00:28:36,880 --> 00:28:44,200
that's involved in putting together the

00:28:38,860 --> 00:28:48,010
full text for the ARM arm so what I hope

00:28:44,200 --> 00:28:50,679
I've shown is that we're adding useful

00:28:48,010 --> 00:28:53,769
bits the motivation these four bits to

00:28:50,679 --> 00:28:55,389
the architecture to move us forward to

00:28:53,769 --> 00:28:58,179
meet changing market requirements

00:28:55,389 --> 00:29:00,850
Security's being that big issue through

00:28:58,179 --> 00:29:02,740
the year it was taking that seriously

00:29:00,850 --> 00:29:04,600
and it's not just spectrum meltdown but

00:29:02,740 --> 00:29:07,779
it's also the issues that have been with

00:29:04,600 --> 00:29:10,419
us the 30-plus years and moving forward

00:29:07,779 --> 00:29:12,639
and other little things in the ARM

00:29:10,419 --> 00:29:16,389
architecture that are just needed to

00:29:12,639 --> 00:29:19,260
keep support for the ecosystem and

00:29:16,389 --> 00:29:22,559
provide support that the ecosystem needs

00:29:19,260 --> 00:29:27,039
so with that thank you very much and

00:29:22,559 --> 00:29:28,240
allow any questions so um Ramona that

00:29:27,039 --> 00:29:29,830
there's only one Michael it stood in the

00:29:28,240 --> 00:29:31,120
front so if Ramona would stand up and

00:29:29,830 --> 00:29:33,430
hold the mic

00:29:31,120 --> 00:29:36,640
if you come and talk to Ramona here he

00:29:33,430 --> 00:29:40,000
passed on to you the mic so the old

00:29:36,640 --> 00:29:43,030
Ramona will do the running grants back

00:29:40,000 --> 00:29:47,350
can you give approximate time lines when

00:29:43,030 --> 00:29:50,140
hardware is going to show up with the

00:29:47,350 --> 00:29:53,730
new version provisions so hardware

00:29:50,140 --> 00:29:55,660
generally takes three to five years so

00:29:53,730 --> 00:29:57,760
then this is why we're talking today

00:29:55,660 --> 00:30:02,920
about software enablement to make sure

00:29:57,760 --> 00:30:04,990
the software is ready their CPUs will

00:30:02,920 --> 00:30:06,130
take a couple of years and then you've

00:30:04,990 --> 00:30:09,340
got a year after that

00:30:06,130 --> 00:30:11,260
I can't talk about our CPU roadmap today

00:30:09,340 --> 00:30:17,890
and I certainly can't talk about what

00:30:11,260 --> 00:30:21,280
people will build because yeah a bunch

00:30:17,890 --> 00:30:24,010
of questions well just to pick two SMC

00:30:21,280 --> 00:30:25,420
calls from l0 or that couldn't be

00:30:24,010 --> 00:30:27,460
something area to look handsome

00:30:25,420 --> 00:30:29,800
and for the run of the random number

00:30:27,460 --> 00:30:31,630
generator you guys have some sort of way

00:30:29,800 --> 00:30:36,730
of doing one time checking to make sure

00:30:31,630 --> 00:30:38,020
that the any entropy sources and things

00:30:36,730 --> 00:30:40,540
like that are actually you have not

00:30:38,020 --> 00:30:45,010
failed to get the roundness until is

00:30:40,540 --> 00:30:47,740
cryptographically safe okay so SMC calls

00:30:45,010 --> 00:30:50,050
I talk to you after I'm you haven't got

00:30:47,740 --> 00:30:51,220
them in the architectural I don't think

00:30:50,050 --> 00:30:53,500
there's a plant there's not currently a

00:30:51,220 --> 00:30:54,610
plan to add them but I'm happy to talk

00:30:53,500 --> 00:30:57,730
to you offline is what you see in the

00:30:54,610 --> 00:31:04,000
use cases and why I'd want that so let

00:30:57,730 --> 00:31:06,460
me try and get back to the right side so

00:31:04,000 --> 00:31:07,930
the way this works is you've got the

00:31:06,460 --> 00:31:11,380
true random number generator providing

00:31:07,930 --> 00:31:13,060
entropy and then your deterministic

00:31:11,380 --> 00:31:16,750
random number generator that you can

00:31:13,060 --> 00:31:19,420
then reseed your Dr Ng from your trng

00:31:16,750 --> 00:31:22,060
and part of what you get there is you

00:31:19,420 --> 00:31:23,350
get result which says actually go away

00:31:22,060 --> 00:31:26,800
and come back later because I haven't

00:31:23,350 --> 00:31:29,860
quite enough entropy right you have to

00:31:26,800 --> 00:31:33,280
go go away and do something else because

00:31:29,860 --> 00:31:34,570
I've not got enough entropy and then it

00:31:33,280 --> 00:31:38,770
waits for that and then you come back

00:31:34,570 --> 00:31:41,130
you try again so over that sorry

00:31:38,770 --> 00:31:43,559
so with

00:31:41,130 --> 00:31:44,220
the fixes that we had for spectrum

00:31:43,559 --> 00:31:46,860
meltdown

00:31:44,220 --> 00:31:49,080
they were basically vulnerabilities they

00:31:46,860 --> 00:31:51,090
came out of speculative execution yet

00:31:49,080 --> 00:31:53,400
which at the heart of it is adding a lot

00:31:51,090 --> 00:31:54,990
of complexity to assist them to aid

00:31:53,400 --> 00:31:57,120
performance yep so there was a

00:31:54,990 --> 00:32:00,059
complexity source that added yep

00:31:57,120 --> 00:32:02,370
performance obviously a lot of these

00:32:00,059 --> 00:32:05,280
features are adding security iPAQ BTI

00:32:02,370 --> 00:32:07,470
yeah but it's still adding a lot of

00:32:05,280 --> 00:32:09,600
complexity like a lot of these features

00:32:07,470 --> 00:32:11,820
add complexity and the complexity in

00:32:09,600 --> 00:32:13,440
itself becomes an attack surface like

00:32:11,820 --> 00:32:14,940
where's the corollary toward that all

00:32:13,440 --> 00:32:17,820
these architectural features that get

00:32:14,940 --> 00:32:20,039
added where you ramp up the testing and

00:32:17,820 --> 00:32:21,630
kind of the combinatorial testing and

00:32:20,039 --> 00:32:23,460
all these features together in a system

00:32:21,630 --> 00:32:27,360
and go actually we haven't created some

00:32:23,460 --> 00:32:29,520
monster new attack service because kind

00:32:27,360 --> 00:32:35,000
of security by simplicity seems an

00:32:29,520 --> 00:32:35,000
easier path than security by layer cake

00:32:36,230 --> 00:32:46,020
so yes you can go back to simplicity my

00:32:43,799 --> 00:32:47,490
argument be you can take out all your if

00:32:46,020 --> 00:32:48,929
you really want to you can take out all

00:32:47,490 --> 00:32:52,559
those performance enhancements and go

00:32:48,929 --> 00:32:55,740
back to the 1980s if you really wanted

00:32:52,559 --> 00:32:57,780
to but yes it does our complexity so we

00:32:55,740 --> 00:33:02,760
do have so we do a lot of testing

00:32:57,780 --> 00:33:04,679
internally so arm CPU teams when they're

00:33:02,760 --> 00:33:06,299
building CPUs do an extreme amount of

00:33:04,679 --> 00:33:09,690
testing there's a mix of formal and

00:33:06,299 --> 00:33:11,010
directed tests and other things we do

00:33:09,690 --> 00:33:13,500
have a compliance suite on the

00:33:11,010 --> 00:33:17,669
architecture to test that and we do look

00:33:13,500 --> 00:33:18,539
at how the different bits interact I was

00:33:17,669 --> 00:33:21,210
going to say something else about

00:33:18,539 --> 00:33:22,440
software testing that goes in there but

00:33:21,210 --> 00:33:25,830
I can't remember what I was going to say

00:33:22,440 --> 00:33:29,030
now so I won't because have you got

00:33:25,830 --> 00:33:29,030
something to say Ramona yes

00:33:29,830 --> 00:33:38,390
so I mean sorry so these are these are

00:33:36,110 --> 00:33:41,900
medications for different forms of

00:33:38,390 --> 00:33:43,580
attacks so yes you're right that if you

00:33:41,900 --> 00:33:45,799
combine them you could be creating

00:33:43,580 --> 00:33:48,980
theoretically a new attack surface but

00:33:45,799 --> 00:33:51,169
to some extent it's a bit of a reactive

00:33:48,980 --> 00:33:53,570
game this this in some sense is going

00:33:51,169 --> 00:33:55,370
after the Morris warm as my side earlier

00:33:53,570 --> 00:33:56,960
it's providing the basic level of

00:33:55,370 --> 00:33:59,330
security we've got to take care of

00:33:56,960 --> 00:34:00,919
buffer overflows we've got to take of

00:33:59,330 --> 00:34:03,169
usually take care of users after freeze

00:34:00,919 --> 00:34:06,440
and things like that and if you don't

00:34:03,169 --> 00:34:08,960
fix that what's the point in going after

00:34:06,440 --> 00:34:11,929
looking at Spector and meltdown we need

00:34:08,960 --> 00:34:13,970
to first fix the basics cut down the

00:34:11,929 --> 00:34:15,710
attack surfaces where we can and then

00:34:13,970 --> 00:34:17,240
look at the next thing it is an

00:34:15,710 --> 00:34:19,970
incremental process there's no magic

00:34:17,240 --> 00:34:23,000
bullet here in my personal opinion so I

00:34:19,970 --> 00:34:24,530
have meant was gonna say now so MTE you

00:34:23,000 --> 00:34:25,940
can view it so to crowdsource in

00:34:24,530 --> 00:34:28,820
debugging it's about sea parking on a

00:34:25,940 --> 00:34:31,310
large scale and running that and finding

00:34:28,820 --> 00:34:33,139
those vulnerabilities earlier it's about

00:34:31,310 --> 00:34:37,570
detection so in theory that should be a

00:34:33,139 --> 00:34:40,520
increases surface that really is a help

00:34:37,570 --> 00:34:42,020
but also so armed you might have heard

00:34:40,520 --> 00:34:43,639
us talk about platform security

00:34:42,020 --> 00:34:46,250
architecture certainly in the EM profile

00:34:43,639 --> 00:34:49,070
space and the deeply embedded space and

00:34:46,250 --> 00:34:50,899
that's all about things like threat

00:34:49,070 --> 00:34:53,690
models and working out what's hacci all

00:34:50,899 --> 00:34:56,149
my threats and actually bringing that

00:34:53,690 --> 00:34:59,330
sort of rigor to the whole system would

00:34:56,149 --> 00:35:01,580
be it's something we're working on and

00:34:59,330 --> 00:35:04,160
that's not necessarily in architecture

00:35:01,580 --> 00:35:05,990
as in his instructions bits in

00:35:04,160 --> 00:35:10,760
architecture is in how do you think

00:35:05,990 --> 00:35:14,390
about your design mr. masters since

00:35:10,760 --> 00:35:16,580
you've got the mic restitute by the way

00:35:14,390 --> 00:35:19,730
sorry nice to tease by the way oh yeah

00:35:16,580 --> 00:35:22,010
yeah well I I ran back from my run cuz I

00:35:19,730 --> 00:35:24,050
didn't want to miss you figure I'll

00:35:22,010 --> 00:35:26,090
shower later um so sorry I smell wrong

00:35:24,050 --> 00:35:28,820
but you're the only one who has to smell

00:35:26,090 --> 00:35:31,930
me sir anyway so I had one observation

00:35:28,820 --> 00:35:35,000
in one question so one observation that

00:35:31,930 --> 00:35:37,010
just came to me a few minutes ago is a

00:35:35,000 --> 00:35:37,430
lot of people think we're going to turn

00:35:37,010 --> 00:35:39,670
off

00:35:37,430 --> 00:35:42,609
pti it's a temporary thing

00:35:39,670 --> 00:35:43,660
and we're gonna get rid of it over time

00:35:42,609 --> 00:35:45,250
certainly I hear that from all the

00:35:43,660 --> 00:35:47,530
architecture companies where they've had

00:35:45,250 --> 00:35:49,540
to implement it and I've been going

00:35:47,530 --> 00:35:51,520
around behind the scenes saying I think

00:35:49,540 --> 00:35:53,230
PTI should live for a long time we can

00:35:51,520 --> 00:35:56,440
talk about it offline but I just want

00:35:53,230 --> 00:35:58,270
people to think there's another answer

00:35:56,440 --> 00:36:00,609
than just it's a short-term hack we

00:35:58,270 --> 00:36:04,150
should get rid of PTI I think there will

00:36:00,609 --> 00:36:06,190
always be address space D randomization

00:36:04,150 --> 00:36:08,290
attacks or other meltdown type attacks

00:36:06,190 --> 00:36:09,819
found and we should not you can answer

00:36:08,290 --> 00:36:12,309
in a minute we can follow up I've got an

00:36:09,819 --> 00:36:14,260
actual question and that is around the

00:36:12,309 --> 00:36:19,210
memory tagging yep

00:36:14,260 --> 00:36:21,280
so what we need to do with any of these

00:36:19,210 --> 00:36:22,839
new technologies that involve doing mass

00:36:21,280 --> 00:36:24,280
rebuilds or I mean you've heard this

00:36:22,839 --> 00:36:26,410
from me before yes not a new statement

00:36:24,280 --> 00:36:28,420
from me but I'm just raising it here if

00:36:26,410 --> 00:36:31,569
there's something that's a many year

00:36:28,420 --> 00:36:34,960
journey those of us in the distro world

00:36:31,569 --> 00:36:36,670
we have to get in now we have to work on

00:36:34,960 --> 00:36:39,460
models and we have to get this enabled

00:36:36,670 --> 00:36:42,730
especially those of us who live in is

00:36:39,460 --> 00:36:43,990
this being recorded yes okay especially

00:36:42,730 --> 00:36:45,940
those of us who live in the wonderful

00:36:43,990 --> 00:36:47,589
world of enterprise distros that are

00:36:45,940 --> 00:36:51,040
amazing and great and very fast-moving

00:36:47,589 --> 00:36:53,260
and very proactive and engaged and all

00:36:51,040 --> 00:36:55,960
the right buzzwords not at all slow

00:36:53,260 --> 00:36:59,500
moving in any sense where there's a long

00:36:55,960 --> 00:37:00,849
tail but if there were then it would

00:36:59,500 --> 00:37:02,890
take us a very long time to get these

00:37:00,849 --> 00:37:05,140
technologies in so you know just just

00:37:02,890 --> 00:37:07,180
plugging saying when we have to do a big

00:37:05,140 --> 00:37:09,640
lift let's all do that now rather than

00:37:07,180 --> 00:37:11,140
wait five years for the hardware but

00:37:09,640 --> 00:37:12,490
that's why they're out I'm not right

00:37:11,140 --> 00:37:15,250
yeah yeah I'm saying let's engage with

00:37:12,490 --> 00:37:17,020
you now yeah yeah it is about making

00:37:15,250 --> 00:37:18,640
sure you and also that's why we try and

00:37:17,020 --> 00:37:21,579
push the support into the upstream tools

00:37:18,640 --> 00:37:25,859
as quickly as possible given the

00:37:21,579 --> 00:37:25,859
timelines and the resources we have so

00:37:27,810 --> 00:37:37,810
okay yeah sorry the the el0 sorry easier

00:37:35,740 --> 00:37:39,670
PD Xing are effectively a hardware

00:37:37,810 --> 00:37:41,680
implementation of page table isolation

00:37:39,670 --> 00:37:44,200
the thing that may go will be the

00:37:41,680 --> 00:37:46,000
software implementation and therefore

00:37:44,200 --> 00:37:48,520
like as the slides mentioned this

00:37:46,000 --> 00:37:49,930
enables SP to be used in cases which are

00:37:48,520 --> 00:37:52,720
currently incompatible with the software

00:37:49,930 --> 00:37:56,980
PTR implementation and should allow for

00:37:52,720 --> 00:37:58,690
lower overhead that's this is why we

00:37:56,980 --> 00:38:02,340
have engineers who know more than me in

00:37:58,690 --> 00:38:05,290
the room so I was wondering if the Dr Ng

00:38:02,340 --> 00:38:08,800
can be seeded from anything other than

00:38:05,290 --> 00:38:12,510
the built-in trng because you may trust

00:38:08,800 --> 00:38:18,490
it and not trust true entropy

00:38:12,510 --> 00:38:22,360
instructions so the Dr Ng can only be

00:38:18,490 --> 00:38:24,700
seated from the trng I would argue that

00:38:22,360 --> 00:38:28,750
most you might trust it it's about what

00:38:24,700 --> 00:38:30,190
the CPU trusts as well now what the DRG

00:38:28,750 --> 00:38:32,920
is deterministic so you can validate

00:38:30,190 --> 00:38:38,800
that that's what you expect and for trng

00:38:32,920 --> 00:38:40,390
that's not the case that is actually a

00:38:38,800 --> 00:38:43,420
problem that intro was facing so they

00:38:40,390 --> 00:38:45,040
have the exact same thing and a lot of

00:38:43,420 --> 00:38:48,460
people do not trust into this

00:38:45,040 --> 00:38:51,090
implementation of the true random number

00:38:48,460 --> 00:38:54,280
generator of the seed that goes into the

00:38:51,090 --> 00:38:56,080
random generator even they they say of

00:38:54,280 --> 00:38:57,640
course that it is absolutely safe and

00:38:56,080 --> 00:38:59,890
there's certainly no backdoor put in

00:38:57,640 --> 00:39:02,740
there by anybody there are some people

00:38:59,890 --> 00:39:05,080
that do not believe them and the same

00:39:02,740 --> 00:39:07,000
thing could potentially apply to anybody

00:39:05,080 --> 00:39:08,440
who implements all of your chips even if

00:39:07,000 --> 00:39:10,930
you know that your implementation is

00:39:08,440 --> 00:39:13,360
correct somebody could have a sort the

00:39:10,930 --> 00:39:16,750
the license for the core and put in

00:39:13,360 --> 00:39:19,000
different implementation and might get

00:39:16,750 --> 00:39:21,700
an incentive from their local government

00:39:19,000 --> 00:39:24,280
to put in certain predictable random

00:39:21,700 --> 00:39:26,190
numbers so at the moment there is

00:39:24,280 --> 00:39:34,259
nothing for that in 8.5

00:39:26,190 --> 00:39:34,259
sorry any more questions

00:39:43,509 --> 00:39:48,280
any more questions nope cool thank you

00:39:47,180 --> 00:39:51,800
very much

00:39:48,280 --> 00:39:56,809
[Applause]

00:39:51,800 --> 00:39:56,809

YouTube URL: https://www.youtube.com/watch?v=IbisEjzoxTY


