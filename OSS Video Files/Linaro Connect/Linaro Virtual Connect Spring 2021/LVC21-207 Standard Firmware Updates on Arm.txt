Title: LVC21-207 Standard Firmware Updates on Arm
Publication date: 2021-04-15
Playlist: Linaro Virtual Connect Spring 2021
Description: 
	Devices require up-to-date FW to be secure. A standardized way to update FW is lacking in the Arm ecosystem.

Having a standard method to perform FW updates benefits the Arm ecosystem -- SoC vendors and OEMs do not need to re-invent basic update functionality, OS vendors have a well understood and device agnostic manner of deploying FW updates. This contributes to more secure and functional Arm-based products.

We aim to standardize the way an OS orchestrates a FW update. To that end we leverage the exiting UEFI UpdateCapsule abstraction, extending it to enable:
-  FW images to be stored-at-rest on TrustZone controlled Flash;
-  Reliable A/B update procedure.
The standardization has the additional aim of not overly constraining devices, allowing vendors to differentiate, as needed, on FW update aspects that are not visible to the OS.

This talk will cover the FW update flow in detail and provide an overview of the prototype we have created as an initial investigation into this topic.
Captions: 
	00:00:02,480 --> 00:00:05,600
hi everyone

00:00:03,280 --> 00:00:07,680
my name is jose and today i'm going to

00:00:05,600 --> 00:00:10,800
talk about our current firmware

00:00:07,680 --> 00:00:11,200
update design so this has been a joint

00:00:10,800 --> 00:00:12,960
work

00:00:11,200 --> 00:00:15,599
between arm and the ledge team from

00:00:12,960 --> 00:00:16,080
linaro and i also wanted to point out

00:00:15,599 --> 00:00:17,600
that

00:00:16,080 --> 00:00:19,680
uh we're going to talk about firmware

00:00:17,600 --> 00:00:22,720
update but that's entirely focused on

00:00:19,680 --> 00:00:22,720
a-class devices

00:00:22,800 --> 00:00:26,720
so there's a lot going on when we're

00:00:24,560 --> 00:00:29,359
talking about firmware delivery

00:00:26,720 --> 00:00:30,000
and we start off by someone having to

00:00:29,359 --> 00:00:32,480
write the

00:00:30,000 --> 00:00:33,440
the firmware this is the job of many

00:00:32,480 --> 00:00:35,760
different teams

00:00:33,440 --> 00:00:38,399
then the the firmware images are signed

00:00:35,760 --> 00:00:40,079
and bundled together in the package

00:00:38,399 --> 00:00:43,040
the package gets uploaded into some

00:00:40,079 --> 00:00:45,200
server or to some cloud service

00:00:43,040 --> 00:00:46,320
and eventually sees its way onto your

00:00:45,200 --> 00:00:48,640
device

00:00:46,320 --> 00:00:50,559
and at this point it's the job of the os

00:00:48,640 --> 00:00:52,960
within your device to find a way

00:00:50,559 --> 00:00:54,800
to deliver and install the different

00:00:52,960 --> 00:00:55,600
images that it receives from the package

00:00:54,800 --> 00:00:58,000
and

00:00:55,600 --> 00:01:00,000
this is really what today's present

00:00:58,000 --> 00:01:03,199
presentation is going to focus on

00:01:00,000 --> 00:01:04,320
really this last mile of the firmware uh

00:01:03,199 --> 00:01:06,720
delivery

00:01:04,320 --> 00:01:08,000
and it's also what we're focusing on on

00:01:06,720 --> 00:01:13,760
our

00:01:08,000 --> 00:01:15,680
firmware updates projects

00:01:13,760 --> 00:01:16,960
so i'd like to start off with just some

00:01:15,680 --> 00:01:19,920
minor clarification

00:01:16,960 --> 00:01:21,439
in the terminology we all know that uefi

00:01:19,920 --> 00:01:24,880
is an industry standard that

00:01:21,439 --> 00:01:28,479
it defines an api and and a group

00:01:24,880 --> 00:01:29,040
of data structures and that there are

00:01:28,479 --> 00:01:31,360
many

00:01:29,040 --> 00:01:34,079
uefi implementations so it's not just

00:01:31,360 --> 00:01:37,280
edk to us sometimes we we tend to assume

00:01:34,079 --> 00:01:38,400
uh u-boot is also an example of a uefi

00:01:37,280 --> 00:01:40,799
implementation so

00:01:38,400 --> 00:01:42,799
during this presentation whenever i i

00:01:40,799 --> 00:01:44,880
mentioned the term uefi implementation

00:01:42,799 --> 00:01:49,119
i'm actually referring to both

00:01:44,880 --> 00:01:49,119
ubuds or to edk2

00:01:52,320 --> 00:01:56,479
so let's start off with the technical

00:01:54,159 --> 00:02:00,079
aspects i'd like to point out initially

00:01:56,479 --> 00:02:01,840
that um we're supporting uh diverse or

00:02:00,079 --> 00:02:03,040
at least recognizing a diverse set of

00:02:01,840 --> 00:02:05,920
platform designs

00:02:03,040 --> 00:02:08,800
with respect to which entity owns the

00:02:05,920 --> 00:02:11,920
flash where the images are stored

00:02:08,800 --> 00:02:13,680
so we see these two uh distinct platform

00:02:11,920 --> 00:02:16,480
designs number one and number two

00:02:13,680 --> 00:02:18,160
in platform number one the normal world

00:02:16,480 --> 00:02:20,080
controls the flash

00:02:18,160 --> 00:02:22,239
this requires more resets because we

00:02:20,080 --> 00:02:24,879
need to ensure that the normal firmware

00:02:22,239 --> 00:02:25,599
is execute executing in isolation and

00:02:24,879 --> 00:02:27,840
has whole

00:02:25,599 --> 00:02:28,959
ownership of the flash when it's writing

00:02:27,840 --> 00:02:32,640
the images

00:02:28,959 --> 00:02:32,640
when it's updating the firmware images

00:02:32,959 --> 00:02:38,879
but we will never fully isolate

00:02:36,080 --> 00:02:40,800
the firmware storage from the os so aim

00:02:38,879 --> 00:02:42,959
malicious or compromised os

00:02:40,800 --> 00:02:44,640
will always be able to access the

00:02:42,959 --> 00:02:47,680
firmware storage and

00:02:44,640 --> 00:02:49,680
either thrust the images or try to

00:02:47,680 --> 00:02:53,760
override some of the images with

00:02:49,680 --> 00:02:56,560
some some some compromised images

00:02:53,760 --> 00:02:58,159
and a counterpart to this is platform

00:02:56,560 --> 00:02:59,840
number two

00:02:58,159 --> 00:03:02,159
so in platform number two we're seeing

00:02:59,840 --> 00:03:05,440
this as an emerging trend is

00:03:02,159 --> 00:03:08,080
by no means the the default

00:03:05,440 --> 00:03:09,280
but we're seeing this picking up as a

00:03:08,080 --> 00:03:11,920
design

00:03:09,280 --> 00:03:13,200
in the ecosystem so what this design has

00:03:11,920 --> 00:03:16,319
in particular is

00:03:13,200 --> 00:03:17,360
the the flash where the firmware images

00:03:16,319 --> 00:03:20,879
are stored in

00:03:17,360 --> 00:03:23,280
is owned by the secure volts

00:03:20,879 --> 00:03:25,120
so in this case the normal world os

00:03:23,280 --> 00:03:27,360
receives the the firmware package

00:03:25,120 --> 00:03:29,760
it unpacks the images and needs to

00:03:27,360 --> 00:03:31,280
transfer those over to the secure world

00:03:29,760 --> 00:03:32,879
and then the entity in the secure world

00:03:31,280 --> 00:03:34,159
which we term the update agent is

00:03:32,879 --> 00:03:37,920
responsible for

00:03:34,159 --> 00:03:40,879
writing the different images in flash

00:03:37,920 --> 00:03:42,879
at their correct offset so this platform

00:03:40,879 --> 00:03:44,879
model with respect to the firmware plate

00:03:42,879 --> 00:03:47,360
just requires a single reset

00:03:44,879 --> 00:03:48,959
for us to do the entire update while the

00:03:47,360 --> 00:03:50,959
images are being transferred to the

00:03:48,959 --> 00:03:53,200
secure world and written to flash

00:03:50,959 --> 00:03:54,080
the os can continue on executing on the

00:03:53,200 --> 00:03:56,959
other cores

00:03:54,080 --> 00:03:58,799
so we're minimizing system down time and

00:03:56,959 --> 00:04:02,640
because we're isolating

00:03:58,799 --> 00:04:04,879
the flash where the images are stored

00:04:02,640 --> 00:04:06,080
from the normal world os we're

00:04:04,879 --> 00:04:09,360
mitigating against

00:04:06,080 --> 00:04:09,760
a set of attacks which we wouldn't be

00:04:09,360 --> 00:04:12,400
able

00:04:09,760 --> 00:04:13,120
to with platform number one so platform

00:04:12,400 --> 00:04:15,840
number tweet

00:04:13,120 --> 00:04:17,359
is both more secure and minimizes system

00:04:15,840 --> 00:04:20,479
downtime

00:04:17,359 --> 00:04:23,840
and it's really the focus of our work

00:04:20,479 --> 00:04:26,479
so our work is really to enable

00:04:23,840 --> 00:04:28,080
platform number two and for us to enable

00:04:26,479 --> 00:04:31,280
firmware updates on platform

00:04:28,080 --> 00:04:31,280
platform number two design

00:04:31,600 --> 00:04:35,120
some of you must be thinking by now that

00:04:33,759 --> 00:04:37,919
there already exists

00:04:35,120 --> 00:04:42,000
a firmware update standard and that's

00:04:37,919 --> 00:04:44,560
true it's the uefi update capsule

00:04:42,000 --> 00:04:45,360
we're not really doing anything uh

00:04:44,560 --> 00:04:47,360
different from

00:04:45,360 --> 00:04:48,720
update capsule which really in a

00:04:47,360 --> 00:04:50,800
nutshell just building on top

00:04:48,720 --> 00:04:52,639
of what uefi update capsule already

00:04:50,800 --> 00:04:54,720
defines

00:04:52,639 --> 00:04:55,759
so that's mostly because it's a well

00:04:54,720 --> 00:04:57,680
understood model

00:04:55,759 --> 00:05:00,080
widely tested the os is already

00:04:57,680 --> 00:05:03,199
interfaced with it and there's

00:05:00,080 --> 00:05:06,320
quite a lot of body of codes that

00:05:03,199 --> 00:05:10,400
knows how to interact with it

00:05:06,320 --> 00:05:12,000
so we're not reinventing the wheel here

00:05:10,400 --> 00:05:14,880
we are just going to add the missing

00:05:12,000 --> 00:05:17,280
bits um that

00:05:14,880 --> 00:05:20,240
to enable the platform number two design

00:05:17,280 --> 00:05:20,240
from the previous slide

00:05:20,800 --> 00:05:23,840
so the update capsule abstraction is

00:05:22,400 --> 00:05:26,479
going to govern the interaction between

00:05:23,840 --> 00:05:28,240
the os and normal firmware

00:05:26,479 --> 00:05:30,000
but in the platform number two we are

00:05:28,240 --> 00:05:32,800
going to require

00:05:30,000 --> 00:05:34,560
some glue that bridges the gap between

00:05:32,800 --> 00:05:36,560
the normal world firmware and the update

00:05:34,560 --> 00:05:38,080
agent over in the secure world

00:05:36,560 --> 00:05:40,160
so that's the first thing that we're

00:05:38,080 --> 00:05:41,039
standardizing it's this firmware update

00:05:40,160 --> 00:05:42,960
api

00:05:41,039 --> 00:05:44,400
that's used by the normal firmware to

00:05:42,960 --> 00:05:48,320
communicate the images

00:05:44,400 --> 00:05:50,800
over to the secure world the second

00:05:48,320 --> 00:05:52,240
bits that we're standardizing is the

00:05:50,800 --> 00:05:55,680
usage of the a b

00:05:52,240 --> 00:05:57,600
model so the different firmware images

00:05:55,680 --> 00:06:01,280
in your system are going to have

00:05:57,600 --> 00:06:02,960
uh more than one instance

00:06:01,280 --> 00:06:05,199
and the different instances of these

00:06:02,960 --> 00:06:06,000
images are going to be grouped together

00:06:05,199 --> 00:06:07,919
into

00:06:06,000 --> 00:06:09,360
the entities that are generally called

00:06:07,919 --> 00:06:10,479
as banks so you're going to have for

00:06:09,360 --> 00:06:14,639
instance the bank a

00:06:10,479 --> 00:06:18,400
and the bank b the if we are to provide

00:06:14,639 --> 00:06:21,120
a layout for your firmware

00:06:18,400 --> 00:06:23,120
storage based on the gpt the gpt doesn't

00:06:21,120 --> 00:06:27,840
really have out-of-the-box support for a

00:06:23,120 --> 00:06:30,639
and b partitions or a and b banks

00:06:27,840 --> 00:06:31,440
we are introducing a data structure that

00:06:30,639 --> 00:06:34,639
extends

00:06:31,440 --> 00:06:36,400
the gpt slightly um

00:06:34,639 --> 00:06:37,840
and that allows us to create this

00:06:36,400 --> 00:06:40,400
abstraction of the a and the b

00:06:37,840 --> 00:06:41,680
banks so that's the second bits that

00:06:40,400 --> 00:06:44,880
we're introducing

00:06:41,680 --> 00:06:46,080
in our standardization efforts so let's

00:06:44,880 --> 00:06:47,680
take a step back and look at the

00:06:46,080 --> 00:06:49,280
different agents that are present in the

00:06:47,680 --> 00:06:50,880
system implementing the firmware update

00:06:49,280 --> 00:06:53,280
procedure

00:06:50,880 --> 00:06:54,800
we have the os the normworld firmware

00:06:53,280 --> 00:06:58,160
listed here as ubuntu

00:06:54,800 --> 00:06:59,759
ddk2 the update agent which is

00:06:58,160 --> 00:07:02,080
the entity that writes the firmware

00:06:59,759 --> 00:07:05,280
images to flash

00:07:02,080 --> 00:07:07,919
and the platform would go so

00:07:05,280 --> 00:07:09,280
the os and the normal firmware are going

00:07:07,919 --> 00:07:12,639
to communicate using

00:07:09,280 --> 00:07:15,280
the uefi update capsule interface

00:07:12,639 --> 00:07:16,319
the os passes on the capsule to the

00:07:15,280 --> 00:07:18,560
normal firmware

00:07:16,319 --> 00:07:20,160
and the normal firmware will in turn

00:07:18,560 --> 00:07:23,199
create the srt table

00:07:20,160 --> 00:07:24,800
so so that the os is able to discover

00:07:23,199 --> 00:07:27,759
the different firmware images in the

00:07:24,800 --> 00:07:30,319
system and their versions

00:07:27,759 --> 00:07:31,919
so the normal firmware is going to

00:07:30,319 --> 00:07:34,800
communicate with the update agent

00:07:31,919 --> 00:07:36,720
by sending the firmware images using the

00:07:34,800 --> 00:07:38,560
firmware api

00:07:36,720 --> 00:07:40,479
that we're standardizing and this

00:07:38,560 --> 00:07:41,440
firmware update api builds on top of a

00:07:40,479 --> 00:07:44,800
shared buffer

00:07:41,440 --> 00:07:47,919
and a synchronous event

00:07:44,800 --> 00:07:49,840
the update agents will in turn

00:07:47,919 --> 00:07:51,520
send over the state of different

00:07:49,840 --> 00:07:55,759
firmware images in the system

00:07:51,520 --> 00:07:58,879
to the normal world firmware and because

00:07:55,759 --> 00:08:02,639
we said that we want to

00:07:58,879 --> 00:08:06,000
support the ib model for

00:08:02,639 --> 00:08:08,000
robustness sake so

00:08:06,000 --> 00:08:09,919
when the update agent is writing the

00:08:08,000 --> 00:08:11,680
different firmware images in flash

00:08:09,919 --> 00:08:12,960
it doesn't always write them at the same

00:08:11,680 --> 00:08:15,599
offset

00:08:12,960 --> 00:08:16,800
if we're updating bank a the images are

00:08:15,599 --> 00:08:19,919
going to be

00:08:16,800 --> 00:08:21,440
written in the offsets of the images in

00:08:19,919 --> 00:08:23,840
bank a but if we're

00:08:21,440 --> 00:08:25,759
updating the images in bank b the

00:08:23,840 --> 00:08:28,400
offsets at which we write the images are

00:08:25,759 --> 00:08:31,039
going to be entirely different

00:08:28,400 --> 00:08:32,719
the platform boot code needs to

00:08:31,039 --> 00:08:35,680
understand whether we're booting

00:08:32,719 --> 00:08:36,399
from bank a or bank b in order to

00:08:35,680 --> 00:08:38,240
discover

00:08:36,399 --> 00:08:40,880
what are the offsets that it needs to

00:08:38,240 --> 00:08:44,320
fetch the different images from

00:08:40,880 --> 00:08:46,399
so we said that the gpt does not

00:08:44,320 --> 00:08:47,600
easily provide out of the box support

00:08:46,399 --> 00:08:50,720
for a and b

00:08:47,600 --> 00:08:53,360
banks and we also said that

00:08:50,720 --> 00:08:54,000
we decided to introduce a data structure

00:08:53,360 --> 00:08:56,399
that creates

00:08:54,000 --> 00:08:58,800
this bank abstraction that's the

00:08:56,399 --> 00:09:01,360
firmware update method item

00:08:58,800 --> 00:09:03,040
so this data structure is written by the

00:09:01,360 --> 00:09:06,160
update agent in flash

00:09:03,040 --> 00:09:07,920
as a partition in the gpt and the

00:09:06,160 --> 00:09:08,800
platform boot code is going to inspect

00:09:07,920 --> 00:09:10,880
the information

00:09:08,800 --> 00:09:12,640
in the firmware update metadata during

00:09:10,880 --> 00:09:14,480
boot time to discover

00:09:12,640 --> 00:09:16,800
which of the banks it needs to boot the

00:09:14,480 --> 00:09:19,680
platform with

00:09:16,800 --> 00:09:20,480
now let's leave the robustness aspects

00:09:19,680 --> 00:09:23,120
aside

00:09:20,480 --> 00:09:24,320
and let's focus on how does the flash

00:09:23,120 --> 00:09:26,160
actually look like

00:09:24,320 --> 00:09:27,440
to the update agent it looks like

00:09:26,160 --> 00:09:29,040
regular flash

00:09:27,440 --> 00:09:31,519
you are going to have many different

00:09:29,040 --> 00:09:34,000
images at different offsets

00:09:31,519 --> 00:09:35,760
the update agency is always going to be

00:09:34,000 --> 00:09:36,000
able to access the entire flash it's

00:09:35,760 --> 00:09:38,320
going

00:09:36,000 --> 00:09:40,080
to see the different image types that

00:09:38,320 --> 00:09:43,200
belong to different banks

00:09:40,080 --> 00:09:45,839
in this slide we see here

00:09:43,200 --> 00:09:46,720
for instance one bank showed that with

00:09:45,839 --> 00:09:49,760
the images

00:09:46,720 --> 00:09:54,240
in light green the other bank

00:09:49,760 --> 00:09:56,160
bank b as the images in light gray

00:09:54,240 --> 00:09:57,519
so the update agent is going to see all

00:09:56,160 --> 00:10:00,240
of this

00:09:57,519 --> 00:10:01,040
but it exposes to the normal world a

00:10:00,240 --> 00:10:02,800
different

00:10:01,040 --> 00:10:04,560
view so the normal world isn't really

00:10:02,800 --> 00:10:08,240
going to see the entire flash

00:10:04,560 --> 00:10:11,360
what it sees is a set of files

00:10:08,240 --> 00:10:11,760
and each file is going to be named by

00:10:11,360 --> 00:10:15,040
the

00:10:11,760 --> 00:10:17,600
firmware image type uuid

00:10:15,040 --> 00:10:20,000
so for instance the edk two images will

00:10:17,600 --> 00:10:21,760
have a specific uid

00:10:20,000 --> 00:10:23,120
and the tfa image are going to have a

00:10:21,760 --> 00:10:24,880
different uuid

00:10:23,120 --> 00:10:26,640
and this uuid or the file name is going

00:10:24,880 --> 00:10:30,079
to be the same whether we're

00:10:26,640 --> 00:10:31,440
looking at bank a or bank b at any point

00:10:30,079 --> 00:10:33,839
in time

00:10:31,440 --> 00:10:35,040
the update agent exposes via the

00:10:33,839 --> 00:10:38,399
firmware update api

00:10:35,040 --> 00:10:40,160
this file abstraction and the files that

00:10:38,399 --> 00:10:43,440
the normal world is able to see

00:10:40,160 --> 00:10:44,399
via this interface are the files that

00:10:43,440 --> 00:10:47,600
are in the

00:10:44,399 --> 00:10:48,160
bank that's being updated so the other

00:10:47,600 --> 00:10:51,600
banks

00:10:48,160 --> 00:10:55,839
in the system are not are not observable

00:10:51,600 --> 00:10:55,839
from the normal world's viewpoints

00:10:56,399 --> 00:10:59,440
so all the files here are going to have

00:10:58,959 --> 00:11:02,720
a

00:10:59,440 --> 00:11:06,480
specific representation in flash

00:11:02,720 --> 00:11:09,839
apart from this very particular

00:11:06,480 --> 00:11:11,839
file that we represent here in orange

00:11:09,839 --> 00:11:13,519
which is the firmware directory the

00:11:11,839 --> 00:11:16,640
firmware directory

00:11:13,519 --> 00:11:18,399
is not necessarily the information

00:11:16,640 --> 00:11:20,640
that's used to construct the firmware

00:11:18,399 --> 00:11:24,160
directory does not directly come

00:11:20,640 --> 00:11:26,320
from flash it's

00:11:24,160 --> 00:11:27,839
it's kind of a fake file created by the

00:11:26,320 --> 00:11:29,839
update agents

00:11:27,839 --> 00:11:32,079
that transmits the information about the

00:11:29,839 --> 00:11:33,920
different images that are present in

00:11:32,079 --> 00:11:35,360
flash and their uids

00:11:33,920 --> 00:11:37,519
and the permissions with which the

00:11:35,360 --> 00:11:38,160
normal worlds can access the different

00:11:37,519 --> 00:11:43,839
files in

00:11:38,160 --> 00:11:43,839
in flash

00:11:44,000 --> 00:11:49,440
the primitives on the firmware update

00:11:45,519 --> 00:11:51,920
api are listed in the column on the left

00:11:49,440 --> 00:11:54,160
and on the right we have the state

00:11:51,920 --> 00:11:57,040
machine that we use to model the system

00:11:54,160 --> 00:11:58,880
we have three states the regular staging

00:11:57,040 --> 00:12:01,600
and trial

00:11:58,880 --> 00:12:03,920
your platform is going to be operating

00:12:01,600 --> 00:12:06,959
mostly out of the regular state

00:12:03,920 --> 00:12:08,800
we will only go to the staging and the

00:12:06,959 --> 00:12:12,079
trial state whenever we perform

00:12:08,800 --> 00:12:14,800
firmware updates so

00:12:12,079 --> 00:12:16,480
once we receive a package firmware

00:12:14,800 --> 00:12:19,920
images to install

00:12:16,480 --> 00:12:21,680
your platform needs to call um firmware

00:12:19,920 --> 00:12:23,600
update begin staging to transition to

00:12:21,680 --> 00:12:25,839
the staging state and only when in the

00:12:23,600 --> 00:12:28,240
staging state

00:12:25,839 --> 00:12:29,279
will the normal firmware be able to

00:12:28,240 --> 00:12:33,279
write

00:12:29,279 --> 00:12:33,279
new images into flash

00:12:34,000 --> 00:12:37,680
so after when when we are in the staging

00:12:37,200 --> 00:12:39,519
state

00:12:37,680 --> 00:12:41,760
then we need to open the different files

00:12:39,519 --> 00:12:42,639
by invoking the firmware update open

00:12:41,760 --> 00:12:45,519
call

00:12:42,639 --> 00:12:47,440
after which the normal firmware needs to

00:12:45,519 --> 00:12:51,440
invoke firmware update right stream

00:12:47,440 --> 00:12:53,440
consecutively to transfer the full image

00:12:51,440 --> 00:12:55,600
and once the image is transferred to the

00:12:53,440 --> 00:12:58,639
secure world then we need to call

00:12:55,600 --> 00:13:00,959
firmware update close

00:12:58,639 --> 00:13:03,200
after all the images are transferred

00:13:00,959 --> 00:13:04,639
normal firmware terminates the staging

00:13:03,200 --> 00:13:07,680
state by calling

00:13:04,639 --> 00:13:10,320
firmware update and staging

00:13:07,680 --> 00:13:11,839
and once we call this function the

00:13:10,320 --> 00:13:13,279
system is going to transition to the

00:13:11,839 --> 00:13:15,360
trial state

00:13:13,279 --> 00:13:17,920
and the trial state is characterized by

00:13:15,360 --> 00:13:22,880
all of the images that we just

00:13:17,920 --> 00:13:26,160
installed being in an unaccepted state

00:13:22,880 --> 00:13:29,120
and the trial that will only end when

00:13:26,160 --> 00:13:31,680
all of the images have been accepted

00:13:29,120 --> 00:13:33,200
to accept images the normal firmware can

00:13:31,680 --> 00:13:36,240
invoke firmware update except

00:13:33,200 --> 00:13:39,360
image and passing the uuid of the image

00:13:36,240 --> 00:13:39,360
that it wants to accept

00:13:39,760 --> 00:13:43,360
so once all the images have been

00:13:41,600 --> 00:13:45,040
accepted we are going to transition to

00:13:43,360 --> 00:13:48,720
the regular state

00:13:45,040 --> 00:13:52,160
and a further aspect of this is

00:13:48,720 --> 00:13:54,639
if we want to increment the value of the

00:13:52,160 --> 00:13:56,399
anti-rollback counters we will not do so

00:13:54,639 --> 00:13:58,880
during the trial state

00:13:56,399 --> 00:14:00,399
and the reason for this is we don't want

00:13:58,880 --> 00:14:01,600
to rush

00:14:00,399 --> 00:14:03,279
incrementing the value of the

00:14:01,600 --> 00:14:04,240
anti-rollback counters because this

00:14:03,279 --> 00:14:05,920
would prevent us

00:14:04,240 --> 00:14:08,639
from having a fallback path to a

00:14:05,920 --> 00:14:11,680
previously working bank

00:14:08,639 --> 00:14:14,399
so we will wait until we verify that all

00:14:11,680 --> 00:14:17,120
the images are working correctly

00:14:14,399 --> 00:14:18,399
before we increment the anti-roll by

00:14:17,120 --> 00:14:21,600
counters and

00:14:18,399 --> 00:14:23,839
we we only really verify that all images

00:14:21,600 --> 00:14:27,440
uh are working correctly once we

00:14:23,839 --> 00:14:29,760
transition to the new regular state

00:14:27,440 --> 00:14:32,000
so if anything goes wrong in the trial

00:14:29,760 --> 00:14:33,040
state if the new images fail to boot the

00:14:32,000 --> 00:14:35,600
system we will

00:14:33,040 --> 00:14:37,279
always have a fallback path to the

00:14:35,600 --> 00:14:40,560
previously working bank

00:14:37,279 --> 00:14:42,399
in this case bank a

00:14:40,560 --> 00:14:44,000
likewise if something went wrong during

00:14:42,399 --> 00:14:45,839
the staging state

00:14:44,000 --> 00:14:47,040
as we were transferring the images over

00:14:45,839 --> 00:14:49,279
to the secure world

00:14:47,040 --> 00:14:50,399
we will always have a fallback path to

00:14:49,279 --> 00:14:52,480
the bank

00:14:50,399 --> 00:14:59,839
from which we are currently running the

00:14:52,480 --> 00:14:59,839
platform from

00:14:59,920 --> 00:15:03,760
so now i just wanted to quickly go

00:15:02,160 --> 00:15:06,399
through the end-to-ends

00:15:03,760 --> 00:15:07,040
firmware update flow starting from the

00:15:06,399 --> 00:15:08,959
os

00:15:07,040 --> 00:15:10,320
because this is an os triggered from one

00:15:08,959 --> 00:15:12,399
update and and

00:15:10,320 --> 00:15:14,320
we we will just quickly see all the

00:15:12,399 --> 00:15:17,600
steps that are involved

00:15:14,320 --> 00:15:20,800
so initially the os uh

00:15:17,600 --> 00:15:22,720
reads the esrt table from the firmware

00:15:20,800 --> 00:15:25,360
and it discovers the different images in

00:15:22,720 --> 00:15:27,839
the system and their versions

00:15:25,360 --> 00:15:29,040
and then the os identifies whether it

00:15:27,839 --> 00:15:32,000
has

00:15:29,040 --> 00:15:32,560
a firmware package that can be used to

00:15:32,000 --> 00:15:34,959
to

00:15:32,560 --> 00:15:37,279
to updates the the images in the device

00:15:34,959 --> 00:15:40,800
and if it has one then it passes it over

00:15:37,279 --> 00:15:43,199
to the update capsule runtime service

00:15:40,800 --> 00:15:44,079
then when the normal firmware receives

00:15:43,199 --> 00:15:46,399
the

00:15:44,079 --> 00:15:48,079
update capsule call it's going to

00:15:46,399 --> 00:15:49,600
transfer the different images

00:15:48,079 --> 00:15:52,399
over to the secure world using the

00:15:49,600 --> 00:15:54,800
firmware update api

00:15:52,399 --> 00:15:56,720
and as we transfer the different images

00:15:54,800 --> 00:15:59,759
over to the secure wall the update agent

00:15:56,720 --> 00:16:00,480
goes and writes them into flash and when

00:15:59,759 --> 00:16:02,160
this process

00:16:00,480 --> 00:16:03,839
completes we're back in the normal

00:16:02,160 --> 00:16:05,680
firmware

00:16:03,839 --> 00:16:07,440
at which point we can either trigger a

00:16:05,680 --> 00:16:11,040
system resets

00:16:07,440 --> 00:16:11,759
or we can return to the os and us then

00:16:11,040 --> 00:16:15,519
needs to

00:16:11,759 --> 00:16:15,519
explicitly call a system reset

00:16:15,759 --> 00:16:19,839
so at this point in time the new images

00:16:17,600 --> 00:16:21,759
have been installed and written to flash

00:16:19,839 --> 00:16:25,519
and we're prepared to put the system

00:16:21,759 --> 00:16:25,519
using the newly installed images

00:16:27,680 --> 00:16:31,839
so the system is going to start booting

00:16:30,240 --> 00:16:34,079
with the newly installed images

00:16:31,839 --> 00:16:37,040
and as we manage to boot the platform up

00:16:34,079 --> 00:16:39,759
until the normal firmware

00:16:37,040 --> 00:16:41,199
we need to signal to the update agent

00:16:39,759 --> 00:16:42,880
that all of the images seem to be

00:16:41,199 --> 00:16:45,150
working correctly

00:16:42,880 --> 00:16:46,639
and then

00:16:45,150 --> 00:16:48,480
[Music]

00:16:46,639 --> 00:16:49,759
the update agent is going to mark all of

00:16:48,480 --> 00:16:51,839
the images

00:16:49,759 --> 00:16:53,120
in the metadata because it's in the

00:16:51,839 --> 00:16:55,839
metadata that we

00:16:53,120 --> 00:16:57,440
track the acceptance state of the

00:16:55,839 --> 00:16:59,279
different images

00:16:57,440 --> 00:17:01,519
and as we return to the normal world

00:16:59,279 --> 00:17:05,360
firmware then we will

00:17:01,519 --> 00:17:08,880
boot the os and again the os during its

00:17:05,360 --> 00:17:10,959
bootloader phase it's going to inspect

00:17:08,880 --> 00:17:12,720
the srt table and verify that

00:17:10,959 --> 00:17:14,160
the firmware images were correctly

00:17:12,720 --> 00:17:19,839
updated and are now

00:17:14,160 --> 00:17:19,839
at the their new version

00:17:20,079 --> 00:17:23,120
so the standardization effort that i've

00:17:21,839 --> 00:17:24,799
been talking about during this

00:17:23,120 --> 00:17:27,760
presentation is really

00:17:24,799 --> 00:17:28,319
embodied in this spec which we've

00:17:27,760 --> 00:17:31,360
currently

00:17:28,319 --> 00:17:33,760
published at an alpha quality so

00:17:31,360 --> 00:17:35,360
it's not yet the final release we're

00:17:33,760 --> 00:17:37,679
still iterating on it

00:17:35,360 --> 00:17:38,559
uh but it describes the the api and the

00:17:37,679 --> 00:17:41,120
metadata

00:17:38,559 --> 00:17:41,919
and and it has some other guidelines

00:17:41,120 --> 00:17:43,600
around it

00:17:41,919 --> 00:17:46,400
but it's mostly covering the interaction

00:17:43,600 --> 00:17:48,240
between the normal firmware and

00:17:46,400 --> 00:17:50,000
the update agent over in the secure

00:17:48,240 --> 00:17:52,960
world

00:17:50,000 --> 00:17:53,520
for the end-to-end flow we're working on

00:17:52,960 --> 00:17:55,600
a

00:17:53,520 --> 00:17:56,559
end-to-end design document that focuses

00:17:55,600 --> 00:17:58,840
on uefi

00:17:56,559 --> 00:18:02,400
and how the update capsule

00:17:58,840 --> 00:18:05,280
implementation uses the tools provided

00:18:02,400 --> 00:18:07,200
in this specification but this uefi

00:18:05,280 --> 00:18:11,440
end-to-end document is still

00:18:07,200 --> 00:18:11,440
under development it's not yet published

00:18:11,840 --> 00:18:16,240
but using what we've been describing

00:18:14,720 --> 00:18:18,720
here and mostly have been

00:18:16,240 --> 00:18:20,320
standardizing this first document we've

00:18:18,720 --> 00:18:23,360
created a prototype

00:18:20,320 --> 00:18:26,400
on the qemu platform

00:18:23,360 --> 00:18:28,240
there we've written the update agents

00:18:26,400 --> 00:18:30,240
or the prototype version of the update

00:18:28,240 --> 00:18:32,320
agent in the standalone mm which runs on

00:18:30,240 --> 00:18:34,480
top of opti

00:18:32,320 --> 00:18:36,160
and for the normal world firmware we've

00:18:34,480 --> 00:18:37,919
used u-boots

00:18:36,160 --> 00:18:39,679
so the u-boot implements the update

00:18:37,919 --> 00:18:42,160
capsule that communicates with the

00:18:39,679 --> 00:18:43,840
update agent over in the standalone

00:18:42,160 --> 00:18:46,000
and of course for the boot code we've

00:18:43,840 --> 00:18:50,559
used dfas

00:18:46,000 --> 00:18:52,080
bl2 so some aspects of this prototype

00:18:50,559 --> 00:18:52,559
we've started up streaming them to you

00:18:52,080 --> 00:18:56,880
boots

00:18:52,559 --> 00:19:00,400
so we're taking the steps to pro

00:18:56,880 --> 00:19:01,280
productize the prototype itself but yeah

00:19:00,400 --> 00:19:04,080
this is yet

00:19:01,280 --> 00:19:06,480
very much just an investigation at this

00:19:04,080 --> 00:19:06,480
stage

00:19:07,280 --> 00:19:12,400
so here i'm listing both a link to the

00:19:09,919 --> 00:19:16,240
current prototype and also to the alpha

00:19:12,400 --> 00:19:16,240
release of the specification

00:19:16,640 --> 00:19:20,480
and i i'd really just like to finalize

00:19:19,120 --> 00:19:24,559
the presentation with

00:19:20,480 --> 00:19:27,280
this plea or i i really wanted to stress

00:19:24,559 --> 00:19:28,240
that the specification is only released

00:19:27,280 --> 00:19:30,799
at alpha

00:19:28,240 --> 00:19:32,400
so this is not the final release we're

00:19:30,799 --> 00:19:34,960
taking feedback

00:19:32,400 --> 00:19:35,840
and it's really important that we

00:19:34,960 --> 00:19:38,640
recognize

00:19:35,840 --> 00:19:40,400
that this is a community efforts so what

00:19:38,640 --> 00:19:44,080
we're standardizing here is going to

00:19:40,400 --> 00:19:45,760
benefit all of us and it's important

00:19:44,080 --> 00:19:47,600
that we take

00:19:45,760 --> 00:19:49,679
uh the input from everyone that's

00:19:47,600 --> 00:19:53,200
interested in this functionality so

00:19:49,679 --> 00:19:55,679
i invite you and to to go and

00:19:53,200 --> 00:19:57,120
look at the current specification and

00:19:55,679 --> 00:20:00,720
provide us with

00:19:57,120 --> 00:20:02,559
comments or or your own view on

00:20:00,720 --> 00:20:04,480
which functionality is lacking whether

00:20:02,559 --> 00:20:06,880
we're overly specifying

00:20:04,480 --> 00:20:08,080
the functionality it would be really

00:20:06,880 --> 00:20:09,840
great to hear from you

00:20:08,080 --> 00:20:11,120
so here's my email if you have any

00:20:09,840 --> 00:20:14,600
comments or

00:20:11,120 --> 00:20:17,600
or suggestions please do send me an

00:20:14,600 --> 00:20:17,600

YouTube URL: https://www.youtube.com/watch?v=syEKZE4t1t0


