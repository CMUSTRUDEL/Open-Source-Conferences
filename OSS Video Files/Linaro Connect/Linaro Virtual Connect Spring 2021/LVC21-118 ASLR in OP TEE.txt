Title: LVC21-118 ASLR in OP TEE
Publication date: 2021-04-15
Playlist: Linaro Virtual Connect Spring 2021
Description: 
	Address Space Layout Randomization (ASLR) affects both how the OP-TEE OS is initialized and how Trusted Applications (TAs) are loaded. This session will cover both cases.
Captions: 
	00:00:00,960 --> 00:00:05,359
hi and welcome to my presentation on

00:00:03,360 --> 00:00:07,200
aslr in opt

00:00:05,359 --> 00:00:09,599
i'm janice wiklandor from lenora

00:00:07,200 --> 00:00:12,880
security working group

00:00:09,599 --> 00:00:14,320
i'm also an opt-in maintainer i've been

00:00:12,880 --> 00:00:17,920
involved in opti since

00:00:14,320 --> 00:00:17,920
the start of the project

00:00:18,080 --> 00:00:22,000
agenda we'll start with the short

00:00:21,119 --> 00:00:24,960
introduction of

00:00:22,000 --> 00:00:25,840
what aslr is followed by what this means

00:00:24,960 --> 00:00:28,960
for optical

00:00:25,840 --> 00:00:29,679
which executes in privileged mode with

00:00:28,960 --> 00:00:31,439
that done

00:00:29,679 --> 00:00:34,320
we'll cover aslr for trusted

00:00:31,439 --> 00:00:35,920
applications on tas

00:00:34,320 --> 00:00:38,880
at the end of this presentation we will

00:00:35,920 --> 00:00:38,880
have time for questions

00:00:43,120 --> 00:00:48,960
what is aslr address based layout

00:00:46,719 --> 00:00:51,840
randomization is a security technique

00:00:48,960 --> 00:00:53,120
which involves randomly positioning

00:00:51,840 --> 00:00:56,079
different memory

00:00:53,120 --> 00:00:57,280
area areas each time an application is

00:00:56,079 --> 00:00:59,280
loaded

00:00:57,280 --> 00:01:00,960
this makes it harder to succeed with

00:00:59,280 --> 00:01:02,559
attacks which relies on

00:01:00,960 --> 00:01:05,519
knowing the address in memory of a

00:01:02,559 --> 00:01:07,520
certain component for example a function

00:01:05,519 --> 00:01:09,040
if you have a buffer overrun that causes

00:01:07,520 --> 00:01:11,600
a returning function

00:01:09,040 --> 00:01:12,960
to jump to a different address it's

00:01:11,600 --> 00:01:14,960
harder to exploit that

00:01:12,960 --> 00:01:18,080
if the address of a certain function

00:01:14,960 --> 00:01:18,080
isn't known in advance

00:01:18,880 --> 00:01:23,200
so the main objective of aslr is to make

00:01:22,479 --> 00:01:25,560
it harder

00:01:23,200 --> 00:01:27,119
to exploit the memory corruption

00:01:25,560 --> 00:01:29,680
vulnerability

00:01:27,119 --> 00:01:30,479
aslr is of course not a full protection

00:01:29,680 --> 00:01:33,119
against such

00:01:30,479 --> 00:01:36,159
attacks but it makes it harder for them

00:01:33,119 --> 00:01:36,159
for them to succeed

00:01:36,400 --> 00:01:42,320
in opti we have two kinds of asl are

00:01:39,600 --> 00:01:43,280
one for tas which corresponds to what

00:01:42,320 --> 00:01:46,000
one may find

00:01:43,280 --> 00:01:48,079
finding for instance linux user space

00:01:46,000 --> 00:01:51,840
the other is for opticor itself

00:01:48,079 --> 00:01:54,640
this corresponds to for instance aslr in

00:01:51,840 --> 00:01:55,119
the linux kernel we are avoiding to use

00:01:54,640 --> 00:01:57,759
the name

00:01:55,119 --> 00:01:59,759
kernel for opticor since it would then

00:01:57,759 --> 00:02:00,880
be so easily confused with the linux

00:01:59,759 --> 00:02:03,920
kernel

00:02:00,880 --> 00:02:07,200
so we call both features aslr with

00:02:03,920 --> 00:02:09,520
ta or core added if needed

00:02:07,200 --> 00:02:12,640
aslr has been supported in opti since

00:02:09,520 --> 00:02:12,640
version 3.8

00:02:16,800 --> 00:02:22,480
asl are for optical overview

00:02:20,720 --> 00:02:24,000
the binary is still linked against the

00:02:22,480 --> 00:02:26,160
same address as the

00:02:24,000 --> 00:02:28,080
physical load address the binary is also

00:02:26,160 --> 00:02:30,640
loaded at the same physical address

00:02:28,080 --> 00:02:32,239
as previously the difference comes later

00:02:30,640 --> 00:02:34,879
when the dutching memory mapping is

00:02:32,239 --> 00:02:34,879
established

00:02:35,760 --> 00:02:39,760
in the example here based on qmo we have

00:02:38,720 --> 00:02:42,319
opti loaded

00:02:39,760 --> 00:02:43,680
at the usual physical address with mmu

00:02:42,319 --> 00:02:46,400
still off

00:02:43,680 --> 00:02:48,239
thus some device also at the physical

00:02:46,400 --> 00:02:50,160
address defined in the emulator to

00:02:48,239 --> 00:02:53,760
illustrate how device mappings

00:02:50,160 --> 00:02:53,760
are assigned virtual addresses

00:02:54,879 --> 00:02:59,360
if the mmu is enabled with asl or

00:02:57,920 --> 00:03:01,360
disabled we'll keep

00:02:59,360 --> 00:03:02,879
keeping the same address for the memory

00:03:01,360 --> 00:03:05,519
we are executing from

00:03:02,879 --> 00:03:08,319
but the device mapping is moved to use

00:03:05,519 --> 00:03:10,319
the next available voucher address

00:03:08,319 --> 00:03:12,080
this makes better use of the virtual

00:03:10,319 --> 00:03:15,040
address space since we avoid having

00:03:12,080 --> 00:03:15,040
scattered mappings

00:03:16,239 --> 00:03:20,959
with aslr enable we get a completely

00:03:18,879 --> 00:03:22,879
different virtual memory map

00:03:20,959 --> 00:03:24,000
with nothing in common with the physical

00:03:22,879 --> 00:03:25,920
memory map

00:03:24,000 --> 00:03:27,760
depending on the address used for the

00:03:25,920 --> 00:03:30,159
memory device

00:03:27,760 --> 00:03:31,360
the memory device mappings may use an

00:03:30,159 --> 00:03:34,239
address just before

00:03:31,360 --> 00:03:34,720
or after the memory this technique was

00:03:34,239 --> 00:03:37,840
used

00:03:34,720 --> 00:03:40,879
even before aslr to allow allow

00:03:37,840 --> 00:03:42,239
loading of t into memory at very high or

00:03:40,879 --> 00:03:45,120
low addresses

00:03:42,239 --> 00:03:46,159
a nice bonus for aslr is that the useful

00:03:45,120 --> 00:03:49,440
address range

00:03:46,159 --> 00:03:49,440
range is maximized

00:03:53,439 --> 00:04:00,239
random seed the random seed is used to

00:03:57,680 --> 00:04:01,200
select a random base address this seed

00:04:00,239 --> 00:04:04,239
is needed

00:04:01,200 --> 00:04:06,400
really early when initializing opti so

00:04:04,239 --> 00:04:07,920
some platforms might not be able to re

00:04:06,400 --> 00:04:11,280
produce this inside of

00:04:07,920 --> 00:04:13,120
itself instead we may need to rely on

00:04:11,280 --> 00:04:15,760
the bootloader to supply it

00:04:13,120 --> 00:04:16,479
in case a device 3 is provided to opti

00:04:15,760 --> 00:04:19,199
when booting

00:04:16,479 --> 00:04:20,000
it could be provided in the node secure

00:04:19,199 --> 00:04:24,080
chosen

00:04:20,000 --> 00:04:27,360
from the property kasl or seed

00:04:24,080 --> 00:04:30,320
this is analogous with how a seed for

00:04:27,360 --> 00:04:31,440
kislr is probably provided to the linux

00:04:30,320 --> 00:04:34,160
kernel

00:04:31,440 --> 00:04:35,840
in opti we have a default implementation

00:04:34,160 --> 00:04:39,280
in a weak function

00:04:35,840 --> 00:04:42,560
get aslr seed to extract

00:04:39,280 --> 00:04:45,040
the seed from a divisory blob in case a

00:04:42,560 --> 00:04:47,199
device reblog isn't provided to update

00:04:45,040 --> 00:04:49,040
the default implementation return 0

00:04:47,199 --> 00:04:51,919
instead

00:04:49,040 --> 00:04:56,720
this will disable asl or opticore but it

00:04:51,919 --> 00:04:58,880
can still be useful for development

00:04:56,720 --> 00:04:59,919
a platform can override the default

00:04:58,880 --> 00:05:03,440
implementation of

00:04:59,919 --> 00:05:05,759
get asl or seed for example

00:05:03,440 --> 00:05:07,840
if the bootloader supplies the seed in a

00:05:05,759 --> 00:05:10,080
different platform specific way

00:05:07,840 --> 00:05:11,360
or if it's possible to use a simple

00:05:10,080 --> 00:05:13,280
driver to interact

00:05:11,360 --> 00:05:15,919
directly with some hardware device at

00:05:13,280 --> 00:05:15,919
this stage

00:05:16,080 --> 00:05:20,800
with qmr it's the emulator itself which

00:05:19,120 --> 00:05:25,840
is providing kaslr

00:05:20,800 --> 00:05:25,840
seed in secure chosen

00:05:30,320 --> 00:05:34,320
building the binary is compiled and

00:05:33,840 --> 00:05:36,720
linked

00:05:34,320 --> 00:05:37,360
as a position independent binary to

00:05:36,720 --> 00:05:40,800
prepare

00:05:37,360 --> 00:05:44,160
for relocation a well-behaving binary

00:05:40,800 --> 00:05:46,639
only has relative relocations so so we

00:05:44,160 --> 00:05:49,120
only need to accept that kind

00:05:46,639 --> 00:05:50,840
relocation entries have a generic format

00:05:49,120 --> 00:05:53,280
in order to support all kinds of

00:05:50,840 --> 00:05:56,160
relocations relative relocations

00:05:53,280 --> 00:05:57,440
are a special case so a format tailored

00:05:56,160 --> 00:06:00,720
to this kind of

00:05:57,440 --> 00:06:04,000
relocations only can be more compact

00:06:00,720 --> 00:06:04,000
and easier to process

00:06:05,440 --> 00:06:11,919
compare using an array of l64

00:06:09,280 --> 00:06:12,479
relay structs with a plain array of

00:06:11,919 --> 00:06:15,600
urine

00:06:12,479 --> 00:06:17,600
32s in this case we can reduce

00:06:15,600 --> 00:06:18,639
the size of the relocation data from

00:06:17,600 --> 00:06:22,000
around

00:06:18,639 --> 00:06:24,400
18 kilobyte to three kilobyte

00:06:22,000 --> 00:06:25,199
in case we are using the pager we will

00:06:24,400 --> 00:06:27,600
still need

00:06:25,199 --> 00:06:28,960
most of the relocations even after the

00:06:27,600 --> 00:06:32,840
initial boot

00:06:28,960 --> 00:06:35,840
so this saving is actually quite

00:06:32,840 --> 00:06:38,560
significant

00:06:35,840 --> 00:06:39,759
we have a script that extracts the

00:06:38,560 --> 00:06:42,319
relocation entries

00:06:39,759 --> 00:06:44,479
from the elf and converts them into an

00:06:42,319 --> 00:06:47,039
array of u and 32s

00:06:44,479 --> 00:06:48,080
this array is then appended to the t

00:06:47,039 --> 00:06:50,639
binary this

00:06:48,080 --> 00:06:51,680
simplifies the assembly code involved

00:06:50,639 --> 00:06:54,479
when doing

00:06:51,680 --> 00:06:56,479
the relocation since there will be no no

00:06:54,479 --> 00:07:00,800
room for inconsistencies

00:06:56,479 --> 00:07:00,800
or unexpected kinds of relocation

00:07:01,759 --> 00:07:04,880
getting a build arrow while the script

00:07:03,759 --> 00:07:07,840
is converting the

00:07:04,880 --> 00:07:08,560
relocations is preferable over a runtime

00:07:07,840 --> 00:07:11,759
error

00:07:08,560 --> 00:07:13,440
during early boot when even debug prints

00:07:11,759 --> 00:07:17,840
may not be available to help

00:07:13,440 --> 00:07:17,840
diagnosing the problem

00:07:21,840 --> 00:07:26,479
relocate the binary is still linked

00:07:25,680 --> 00:07:28,800
against the

00:07:26,479 --> 00:07:31,280
load address this is needed since we are

00:07:28,800 --> 00:07:33,360
starting to execute with mmu disabled

00:07:31,280 --> 00:07:34,880
and we need c code to build the

00:07:33,360 --> 00:07:38,720
translation tables

00:07:34,880 --> 00:07:41,360
needed before the mmu can be enabled

00:07:38,720 --> 00:07:42,880
once the translation tables are built we

00:07:41,360 --> 00:07:46,160
can relocate the binary

00:07:42,880 --> 00:07:46,160
and enable the mmu

00:07:47,840 --> 00:07:52,319
relocating the binary is just a matter

00:07:50,240 --> 00:07:54,160
of identifying each word in

00:07:52,319 --> 00:07:56,560
memory and increasing them with a load

00:07:54,160 --> 00:07:58,960
offset

00:07:56,560 --> 00:08:02,639
where they offset is the new address to

00:07:58,960 --> 00:08:04,879
use minus the link address

00:08:02,639 --> 00:08:06,560
the code doing the relocation is in

00:08:04,879 --> 00:08:10,720
principle as simple as

00:08:06,560 --> 00:08:11,280
the code shown here but it's implemented

00:08:10,720 --> 00:08:13,599
in an

00:08:11,280 --> 00:08:14,720
in assembly instead to make sure that

00:08:13,599 --> 00:08:17,120
the code itself

00:08:14,720 --> 00:08:18,400
doesn't contain any address that may

00:08:17,120 --> 00:08:21,520
need to be

00:08:18,400 --> 00:08:22,000
relocated even if this c code would be

00:08:21,520 --> 00:08:24,319
safe

00:08:22,000 --> 00:08:25,520
with one compiler another compiler may

00:08:24,319 --> 00:08:28,639
generate code

00:08:25,520 --> 00:08:29,280
with unexpected dependencies so in this

00:08:28,639 --> 00:08:31,440
case

00:08:29,280 --> 00:08:34,479
it's easier to implement the function in

00:08:31,440 --> 00:08:41,839
assembly even if we must do it twice

00:08:34,479 --> 00:08:41,839
once for 32-bit once or 64-bit

00:08:44,080 --> 00:08:50,640
mappings a mapping is

00:08:47,360 --> 00:08:52,880
created based on the seed we are

00:08:50,640 --> 00:08:55,279
executing in the binary so we need to

00:08:52,880 --> 00:08:56,480
keep a small part of the binary identity

00:08:55,279 --> 00:08:58,480
mapped

00:08:56,480 --> 00:09:00,399
this is because the code enabling the

00:08:58,480 --> 00:09:03,440
mmu is executing from

00:09:00,399 --> 00:09:06,480
physical memory the identity map is

00:09:03,440 --> 00:09:08,880
needed also after the primary mmu

00:09:06,480 --> 00:09:11,839
a primary cpu has enabled the mmu since

00:09:08,880 --> 00:09:15,120
the secondary cpus may

00:09:11,839 --> 00:09:17,760
needs to enable the mmu also relying on

00:09:15,120 --> 00:09:20,720
identity mapped memory

00:09:17,760 --> 00:09:21,040
depending on how cpu is later or turned

00:09:20,720 --> 00:09:24,320
on

00:09:21,040 --> 00:09:26,480
off and on again we may need to be able

00:09:24,320 --> 00:09:27,920
to enable the mmu after we have booted

00:09:26,480 --> 00:09:31,920
all

00:09:27,920 --> 00:09:34,839
cpus the identity mapped address range

00:09:31,920 --> 00:09:37,839
is usually quite small only one or two

00:09:34,839 --> 00:09:37,839
pages

00:09:38,480 --> 00:09:43,279
in this example you can see that without

00:09:40,880 --> 00:09:44,560
aslr we normally have two ranges for

00:09:43,279 --> 00:09:47,120
mappings

00:09:44,560 --> 00:09:47,760
one for memory to execute of the core

00:09:47,120 --> 00:09:51,839
from

00:09:47,760 --> 00:09:51,839
and one range for devices

00:09:52,959 --> 00:09:58,800
with aslr enabled we get three ranges

00:09:56,720 --> 00:09:59,839
one of the identity map which by

00:09:58,800 --> 00:10:02,160
definition is

00:09:59,839 --> 00:10:03,519
at the same address as the physical

00:10:02,160 --> 00:10:06,640
address

00:10:03,519 --> 00:10:07,360
the other two ranges are kept next to

00:10:06,640 --> 00:10:11,519
each other

00:10:07,360 --> 00:10:11,519
but anywhere in the virtual memory range

00:10:15,920 --> 00:10:21,519
possible locations a virtual address is

00:10:19,839 --> 00:10:24,320
selected as a multiple of

00:10:21,519 --> 00:10:26,000
4 kilobyte as that is the smallest unit

00:10:24,320 --> 00:10:28,160
we can map

00:10:26,000 --> 00:10:29,040
the entire virtual memory range can be

00:10:28,160 --> 00:10:31,600
used with a

00:10:29,040 --> 00:10:32,800
few exceptions like the page at average

00:10:31,600 --> 00:10:36,399
zero or

00:10:32,800 --> 00:10:38,800
overlapping the identity map on a

00:10:36,399 --> 00:10:42,320
four gig virtual memory range this gives

00:10:38,800 --> 00:10:42,320
almost 20 random bits

00:10:43,200 --> 00:10:46,880
if i generate if i a generated position

00:10:45,920 --> 00:10:49,519
cannot be used

00:10:46,880 --> 00:10:50,640
a new position is generated instead of

00:10:49,519 --> 00:10:53,120
trying to shift the

00:10:50,640 --> 00:10:54,640
position slightly this is needed because

00:10:53,120 --> 00:10:56,720
we would otherwise make certain

00:10:54,640 --> 00:10:59,839
addresses more likely

00:10:56,720 --> 00:11:02,399
for example at the beginning and the end

00:10:59,839 --> 00:11:04,959
of the educational address range

00:11:02,399 --> 00:11:06,480
we do we do want to make the used

00:11:04,959 --> 00:11:09,760
address as hard to guess

00:11:06,480 --> 00:11:09,760
or predict as possible

00:11:10,160 --> 00:11:15,440
to generate a new position we

00:11:13,279 --> 00:11:17,040
flip a couple of the most significant

00:11:15,440 --> 00:11:19,040
bits in the address

00:11:17,040 --> 00:11:20,800
this should try another position that is

00:11:19,040 --> 00:11:23,920
different enough from the previous

00:11:20,800 --> 00:11:26,079
that it might work after three failed

00:11:23,920 --> 00:11:28,720
positions we will give up and run with

00:11:26,079 --> 00:11:29,839
asl are disabled but this shouldn't be

00:11:28,720 --> 00:11:31,600
very likely since

00:11:29,839 --> 00:11:33,200
there are only three things that can

00:11:31,600 --> 00:11:37,440
conflict with the mappings

00:11:33,200 --> 00:11:37,440
the beginning the end and the identity

00:11:40,839 --> 00:11:45,440
map

00:11:43,120 --> 00:11:46,800
translation tables long descriptor

00:11:45,440 --> 00:11:49,600
format

00:11:46,800 --> 00:11:50,399
multiple cpus can be active in of t at

00:11:49,600 --> 00:11:53,040
the same time

00:11:50,399 --> 00:11:54,839
handling different tas so different cpus

00:11:53,040 --> 00:11:56,639
must be able to use different memory

00:11:54,839 --> 00:11:58,800
mappings but they

00:11:56,639 --> 00:12:01,200
also have to share the common mappings

00:11:58,800 --> 00:12:03,760
like the of the os code and data

00:12:01,200 --> 00:12:07,279
this has led to this design with one

00:12:03,760 --> 00:12:09,519
level one table for each cpu

00:12:07,279 --> 00:12:11,279
one or two of the level one entries

00:12:09,519 --> 00:12:13,279
points to final grade

00:12:11,279 --> 00:12:14,399
tables for the global mappings for

00:12:13,279 --> 00:12:17,440
privileged

00:12:14,399 --> 00:12:19,760
for for the privileged mappings with the

00:12:17,440 --> 00:12:22,240
aslr enabled we often

00:12:19,760 --> 00:12:22,959
depending on the seed have two level 1

00:12:22,240 --> 00:12:26,399
entries

00:12:22,959 --> 00:12:28,320
in use with one taking care of the

00:12:26,399 --> 00:12:29,760
identity mapping and the other the rest

00:12:28,320 --> 00:12:32,240
of the privileged

00:12:29,760 --> 00:12:32,240
mappings

00:12:33,760 --> 00:12:37,120
one of the unused level 1 entries is

00:12:36,079 --> 00:12:40,160
selected for

00:12:37,120 --> 00:12:42,240
user mappings these mappings will be

00:12:40,160 --> 00:12:43,600
not global that is they are used

00:12:42,240 --> 00:12:46,800
together with a specific

00:12:43,600 --> 00:12:50,160
address space identifier asid

00:12:46,800 --> 00:12:52,880
unique for each ta

00:12:50,160 --> 00:12:54,800
each di will normally only be mapped in

00:12:52,880 --> 00:12:56,959
one cpu at a time

00:12:54,800 --> 00:12:58,800
but the architecture would commit more

00:12:56,959 --> 00:13:01,120
than one cpu if that would ever be

00:12:58,800 --> 00:13:01,120
needed

00:13:01,360 --> 00:13:07,279
level one entries span one gig each

00:13:04,639 --> 00:13:08,560
the level 2 entries 2 makes and finally

00:13:07,279 --> 00:13:13,279
the level 3 entries

00:13:08,560 --> 00:13:16,720
maps each in video individual 4k page

00:13:13,279 --> 00:13:19,279
in this example the first level 1 entry

00:13:16,720 --> 00:13:20,320
is used for the identity map with a

00:13:19,279 --> 00:13:22,480
single entries

00:13:20,320 --> 00:13:23,839
in the corresponding level 2 table which

00:13:22,480 --> 00:13:27,200
in turn points

00:13:23,839 --> 00:13:29,440
to a level 3 table with typically

00:13:27,200 --> 00:13:34,639
one or two entries depending on the

00:13:29,440 --> 00:13:36,800
amount of needed identity mappings

00:13:34,639 --> 00:13:38,399
the second level one entry entry number

00:13:36,800 --> 00:13:41,199
one is used

00:13:38,399 --> 00:13:42,399
for the relocated privileged part of

00:13:41,199 --> 00:13:44,800
opti

00:13:42,399 --> 00:13:45,839
these mappings are also global since

00:13:44,800 --> 00:13:49,839
they are shared with

00:13:45,839 --> 00:13:49,839
biology views

00:13:49,920 --> 00:13:53,920
the third entry is used for not global

00:13:52,480 --> 00:13:56,639
user mode mappings

00:13:53,920 --> 00:13:57,279
this means that the first two entries in

00:13:56,639 --> 00:13:59,680
all

00:13:57,279 --> 00:14:01,199
the plus cpu level 1 tables will have

00:13:59,680 --> 00:14:04,240
identical data

00:14:01,199 --> 00:14:06,320
the third entry entry number number two

00:14:04,240 --> 00:14:07,440
will be changed as needed when different

00:14:06,320 --> 00:14:10,639
tas are mapped

00:14:07,440 --> 00:14:10,639
on a particular cpu

00:14:15,120 --> 00:14:21,040
ta loading tas has for historical

00:14:18,399 --> 00:14:25,440
reasons always been compiled and linked

00:14:21,040 --> 00:14:25,440
as position independent executables

00:14:26,880 --> 00:14:30,320
as you may recall from the previous

00:14:28,959 --> 00:14:33,120
slide of the core

00:14:30,320 --> 00:14:36,480
selects a suitable virtual address range

00:14:33,120 --> 00:14:36,480
for tas at due time

00:14:37,360 --> 00:14:45,440
tas are linked against address 0 and are

00:14:40,800 --> 00:14:48,639
loaded with ldl the elf loader in oct

00:14:45,440 --> 00:14:50,079
ldl relocates the ta to the address

00:14:48,639 --> 00:14:52,800
where it was loaded

00:14:50,079 --> 00:14:53,360
before being entered for the first time

00:14:52,800 --> 00:14:55,680
so this

00:14:53,360 --> 00:14:56,639
process is a bit easier compared to of

00:14:55,680 --> 00:14:59,839
the core which

00:14:56,639 --> 00:15:02,959
must relocate itself the ldl

00:14:59,839 --> 00:15:05,839
is executing use on the toe too

00:15:02,959 --> 00:15:07,360
sharing the aerospace with the ta so ldl

00:15:05,839 --> 00:15:10,320
needs to relocate too

00:15:07,360 --> 00:15:10,320
that's taken care of

00:15:10,560 --> 00:15:15,360
taken care of by the ldf startup code

00:15:12,880 --> 00:15:18,480
before the main routine is entered

00:15:15,360 --> 00:15:18,800
ldl could be can could be compared with

00:15:18,480 --> 00:15:27,839
how

00:15:18,800 --> 00:15:27,839
ldsa works in linux user space

00:15:27,920 --> 00:15:33,600
aslr for tas the size of addos range

00:15:31,440 --> 00:15:35,279
is limited by how many translation

00:15:33,600 --> 00:15:37,920
tables are available

00:15:35,279 --> 00:15:40,000
for user mode mappings translation

00:15:37,920 --> 00:15:42,079
tables are allocated to cover the

00:15:40,000 --> 00:15:44,320
lowest possible ta address to the

00:15:42,079 --> 00:15:46,240
highest mapped address

00:15:44,320 --> 00:15:48,240
translation tables are allocated for

00:15:46,240 --> 00:15:51,519
holes in the ti mappings too so

00:15:48,240 --> 00:15:51,519
yes room for improvement

00:15:52,000 --> 00:15:58,160
address randomization is handled by ldl

00:15:55,279 --> 00:15:59,680
with help from apis provided by opt the

00:15:58,160 --> 00:16:01,920
load address is

00:15:59,680 --> 00:16:03,519
randomized for each elf being loaded not

00:16:01,920 --> 00:16:05,839
only tas or else

00:16:03,519 --> 00:16:06,839
there are dynamically loaded libraries

00:16:05,839 --> 00:16:09,839
and objects

00:16:06,839 --> 00:16:09,839
too

00:16:11,040 --> 00:16:22,320
thank you for listening now we have time

00:16:13,279 --> 00:16:22,320

YouTube URL: https://www.youtube.com/watch?v=6osRk-dgFBI


