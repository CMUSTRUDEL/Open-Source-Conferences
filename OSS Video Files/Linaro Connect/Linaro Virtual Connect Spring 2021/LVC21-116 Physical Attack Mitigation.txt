Title: LVC21-116 Physical Attack Mitigation
Publication date: 2021-04-15
Playlist: Linaro Virtual Connect Spring 2021
Description: 
	Give an overview of physical attacks and how can they be applied to compromise system security (bypass secure boot or the configuration of memory isolation hardware elements). Introduce software countermeasures against physical attacks to mitigate them. Show in practice how these countermeasures are implemented in MCUboot project and TF-M runtime. Talk about the challenges and solutions of implementing these countermeasures in open-source projects. Introduce a QEMU based test environment which meant to simulate the effects of physical attacks on software execution.
Captions: 
	00:00:00,080 --> 00:00:06,240
can get armed in the op

00:00:03,199 --> 00:00:08,880
okay hello everybody

00:00:06,240 --> 00:00:10,400
i hope you can hear me i am tomas bam

00:00:08,880 --> 00:00:11,200
working at arm in the open source

00:00:10,400 --> 00:00:14,160
software group

00:00:11,200 --> 00:00:15,599
and here is my colleague as well hi i am

00:00:14,160 --> 00:00:16,800
rave coles i also work in the open

00:00:15,599 --> 00:00:17,359
source software group on the trusted

00:00:16,800 --> 00:00:20,800
firmware m

00:00:17,359 --> 00:00:22,640
project in the last four years i have

00:00:20,800 --> 00:00:23,119
been working on a trusted firmware m

00:00:22,640 --> 00:00:25,119
project

00:00:23,119 --> 00:00:26,480
one of my focus area was the secure

00:00:25,119 --> 00:00:28,640
bootloaders

00:00:26,480 --> 00:00:30,160
along these years i have recognized the

00:00:28,640 --> 00:00:32,160
fact that not only the software

00:00:30,160 --> 00:00:33,760
vulnerability is the only way how a

00:00:32,160 --> 00:00:35,920
system can be hacked

00:00:33,760 --> 00:00:38,079
the security of a system even without

00:00:35,920 --> 00:00:39,680
exploitable software but can be defeated

00:00:38,079 --> 00:00:41,680
by physical attacks

00:00:39,680 --> 00:00:43,520
today we are going to talk about the

00:00:41,680 --> 00:00:44,800
physical attacks corresponding software

00:00:43,520 --> 00:00:46,640
mitigation techniques

00:00:44,800 --> 00:00:50,079
and what have been improved in our

00:00:46,640 --> 00:00:50,079
project regarding this topic

00:00:52,719 --> 00:00:57,199
the short agenda for today first a quick

00:00:55,520 --> 00:00:59,600
overview of the physical attacks

00:00:57,199 --> 00:01:01,680
what are these how to perform them the

00:00:59,600 --> 00:01:02,960
effects on the code execution

00:01:01,680 --> 00:01:04,879
then the generic overview of the

00:01:02,960 --> 00:01:06,799
software counter measures how can the

00:01:04,879 --> 00:01:08,720
code be written in a va to be more

00:01:06,799 --> 00:01:10,720
robust again physical attacks

00:01:08,720 --> 00:01:12,960
then we are going to talk about the mcu

00:01:10,720 --> 00:01:14,640
boot and tfm projects what enhancements

00:01:12,960 --> 00:01:16,479
was implemented in these

00:01:14,640 --> 00:01:18,320
finally we are going to introduce an

00:01:16,479 --> 00:01:22,479
in-house developed fault injection test

00:01:18,320 --> 00:01:22,479
environment based on the qma emulator

00:01:24,560 --> 00:01:28,240
a physical attack is when an attacker

00:01:26,479 --> 00:01:29,680
deliberately changes the expected

00:01:28,240 --> 00:01:31,840
behavior of a circuit

00:01:29,680 --> 00:01:33,840
to achieve this the device is moved out

00:01:31,840 --> 00:01:35,840
from its tested and proved operational

00:01:33,840 --> 00:01:36,400
conditions to force the hardware to a

00:01:35,840 --> 00:01:38,720
stage

00:01:36,400 --> 00:01:40,079
where might random hazards appear there

00:01:38,720 --> 00:01:42,240
are many ways to do so

00:01:40,079 --> 00:01:44,399
the chip can be heated up or even cool

00:01:42,240 --> 00:01:46,560
down over the tested temperature range

00:01:44,399 --> 00:01:48,640
the stability and accuracy of the input

00:01:46,560 --> 00:01:49,280
signals like over supply and clock

00:01:48,640 --> 00:01:51,439
signals

00:01:49,280 --> 00:01:53,600
can be changed easily with an external

00:01:51,439 --> 00:01:55,920
device connected to the input pins

00:01:53,600 --> 00:01:57,759
more advanced attack could be to shoot

00:01:55,920 --> 00:02:00,320
the surface of the chip either with an

00:01:57,759 --> 00:02:02,719
electromagnetic pulse or a laser beam

00:02:00,320 --> 00:02:04,799
all these attacks have different effects

00:02:02,719 --> 00:02:05,600
on the right hand side there is a figure

00:02:04,799 --> 00:02:07,840
to explain

00:02:05,600 --> 00:02:09,920
the change on a circuit level how can

00:02:07,840 --> 00:02:11,360
affect the microarchitectural behavior

00:02:09,920 --> 00:02:12,879
of the chip

00:02:11,360 --> 00:02:15,040
for example it can affect the

00:02:12,879 --> 00:02:15,680
instruction fetch or decode the data

00:02:15,040 --> 00:02:17,680
fetch or

00:02:15,680 --> 00:02:20,480
store or might change the content of a

00:02:17,680 --> 00:02:22,560
register as a result of these changes

00:02:20,480 --> 00:02:23,840
the code execution will be changed at

00:02:22,560 --> 00:02:26,000
the highest level

00:02:23,840 --> 00:02:27,040
and actually this is the ultimate goal

00:02:26,000 --> 00:02:28,959
of the attacker

00:02:27,040 --> 00:02:30,800
he wants to derail the expected

00:02:28,959 --> 00:02:32,879
execution of the code to

00:02:30,800 --> 00:02:34,640
some unknown random direction which

00:02:32,879 --> 00:02:37,840
might be beneficial for him

00:02:34,640 --> 00:02:37,840
to break in a system

00:02:37,920 --> 00:02:41,519
as i said the physical attacks cause a

00:02:39,840 --> 00:02:43,760
random fault in the hardware

00:02:41,519 --> 00:02:45,200
but actually happens strongly depends on

00:02:43,760 --> 00:02:47,440
the actual hardware

00:02:45,200 --> 00:02:49,519
so from the attacker point of view the

00:02:47,440 --> 00:02:51,040
execution of the physical attack is a

00:02:49,519 --> 00:02:53,519
try and fail loop

00:02:51,040 --> 00:02:55,920
until in some cases the attacker finally

00:02:53,519 --> 00:02:59,040
finds the right parameters of the attack

00:02:55,920 --> 00:03:00,640
like the type location timing which at

00:02:59,040 --> 00:03:04,000
the end make the attack

00:03:00,640 --> 00:03:06,080
successful now let's talk about

00:03:04,000 --> 00:03:07,760
what kind of faults are observable on

00:03:06,080 --> 00:03:09,760
the code execution level

00:03:07,760 --> 00:03:12,000
the most common ones are the instruction

00:03:09,760 --> 00:03:14,319
skip and the register correction

00:03:12,000 --> 00:03:15,519
instruction skip means that few machine

00:03:14,319 --> 00:03:17,840
instructions is not

00:03:15,519 --> 00:03:18,640
executed by the core which normally

00:03:17,840 --> 00:03:20,560
should be

00:03:18,640 --> 00:03:22,879
it can cause that variable is not

00:03:20,560 --> 00:03:24,879
updated or a function is not called

00:03:22,879 --> 00:03:26,720
or in case of conditional check the

00:03:24,879 --> 00:03:28,400
wrong branch is taken

00:03:26,720 --> 00:03:29,840
another frequent fall type is the

00:03:28,400 --> 00:03:31,920
register corruption

00:03:29,840 --> 00:03:33,280
this means that the value of register

00:03:31,920 --> 00:03:36,159
change in a random way

00:03:33,280 --> 00:03:37,920
a single or multiple bits flip it can

00:03:36,159 --> 00:03:38,879
have various effects on the code

00:03:37,920 --> 00:03:41,120
execution

00:03:38,879 --> 00:03:44,000
like branching to a different address or

00:03:41,120 --> 00:03:46,239
read or store data to modify addresses

00:03:44,000 --> 00:03:47,599
but even the function core parameters

00:03:46,239 --> 00:03:50,640
including the input and

00:03:47,599 --> 00:03:52,560
output once can be tempered since these

00:03:50,640 --> 00:03:54,080
are passed through registers

00:03:52,560 --> 00:03:55,680
the implemented software counter

00:03:54,080 --> 00:04:01,840
measures and the test

00:03:55,680 --> 00:04:01,840
environment are also focusing on these

00:04:12,840 --> 00:04:15,840
sorry

00:04:19,359 --> 00:04:22,960
a software counter measure are meant to

00:04:21,120 --> 00:04:24,800
make the code more resistant to the

00:04:22,960 --> 00:04:27,120
effects of the physical attack

00:04:24,800 --> 00:04:29,120
the goal is to not fix the effect of the

00:04:27,120 --> 00:04:30,080
attack instead just recognize that

00:04:29,120 --> 00:04:32,160
something

00:04:30,080 --> 00:04:33,120
unusual happened in the control or the

00:04:32,160 --> 00:04:35,280
data flow

00:04:33,120 --> 00:04:37,280
if such a situation is recognized then

00:04:35,280 --> 00:04:38,160
the software must take an appropriate

00:04:37,280 --> 00:04:40,479
action

00:04:38,160 --> 00:04:41,360
usually to hang up the code execution

00:04:40,479 --> 00:04:43,600
and go to some

00:04:41,360 --> 00:04:45,680
error handling routine like an infinite

00:04:43,600 --> 00:04:48,160
loop reset the device or even

00:04:45,680 --> 00:04:49,919
clear device secrets of course the

00:04:48,160 --> 00:04:51,919
software counter measures is not the

00:04:49,919 --> 00:04:53,520
only way to protect against physical

00:04:51,919 --> 00:04:55,520
attacks

00:04:53,520 --> 00:04:57,199
there are dedicated hardware components

00:04:55,520 --> 00:04:59,280
that serve the same goal

00:04:57,199 --> 00:05:01,280
the best approach is the combination of

00:04:59,280 --> 00:05:03,199
these the hardware and software content

00:05:01,280 --> 00:05:04,960
measures and applying both

00:05:03,199 --> 00:05:06,720
but even in this case they are not

00:05:04,960 --> 00:05:08,400
providing full protection

00:05:06,720 --> 00:05:10,000
just significantly decrease the

00:05:08,400 --> 00:05:12,400
probability of successful

00:05:10,000 --> 00:05:12,400
attack

00:05:15,919 --> 00:05:19,680
so far we have covered what is the

00:05:17,840 --> 00:05:20,160
physical attacks now let's see what can

00:05:19,680 --> 00:05:22,960
be done

00:05:20,160 --> 00:05:25,360
in the code to protect against them

00:05:22,960 --> 00:05:26,880
general advice is to pick up constants

00:05:25,360 --> 00:05:28,960
for returning values which have a

00:05:26,880 --> 00:05:30,479
complex bit button and have a big

00:05:28,960 --> 00:05:32,720
hamming distance between

00:05:30,479 --> 00:05:34,560
them to make it harder to change from

00:05:32,720 --> 00:05:35,759
one valid value to another with a bit

00:05:34,560 --> 00:05:37,600
flip

00:05:35,759 --> 00:05:39,680
some of the counter measures are built

00:05:37,600 --> 00:05:41,520
on some constraints of the attack

00:05:39,680 --> 00:05:42,720
the timing of a single attack can be

00:05:41,520 --> 00:05:45,039
accurately set

00:05:42,720 --> 00:05:47,600
but time to attack precisely which are

00:05:45,039 --> 00:05:49,440
very close to each other in time is hard

00:05:47,600 --> 00:05:50,880
there is a high probability that one of

00:05:49,440 --> 00:05:53,520
the attack will fail

00:05:50,880 --> 00:05:55,840
so making important operations redundant

00:05:53,520 --> 00:05:57,919
helps to recognize the attack

00:05:55,840 --> 00:06:00,319
double checks serves extracted this

00:05:57,919 --> 00:06:02,160
purpose important condition checks could

00:06:00,319 --> 00:06:04,880
be a good target for an attacker

00:06:02,160 --> 00:06:06,800
in order to recognize an ongoing attack

00:06:04,880 --> 00:06:08,479
it is recommended to duplicate the

00:06:06,800 --> 00:06:10,960
important combination checks

00:06:08,479 --> 00:06:12,319
in mind the variables as well which hold

00:06:10,960 --> 00:06:14,479
critical data

00:06:12,319 --> 00:06:16,319
in case of inconsistency the software

00:06:14,479 --> 00:06:18,319
can act accordingly

00:06:16,319 --> 00:06:20,160
another effect of a physical attack can

00:06:18,319 --> 00:06:22,479
be an early exit from a loop

00:06:20,160 --> 00:06:24,800
operation without completing it in a

00:06:22,479 --> 00:06:26,560
cryptographic algorithm this can weaken

00:06:24,800 --> 00:06:28,000
the strength of a crypto encryption or

00:06:26,560 --> 00:06:30,240
digital signature

00:06:28,000 --> 00:06:31,919
in the end this weakening can be used to

00:06:30,240 --> 00:06:34,400
review the secret key

00:06:31,919 --> 00:06:36,160
so a good practice is to check the value

00:06:34,400 --> 00:06:36,720
of the loop counter at the end of the

00:06:36,160 --> 00:06:39,120
loop

00:06:36,720 --> 00:06:42,240
against its expected value to make sure

00:06:39,120 --> 00:06:44,479
that the loop is really completed

00:06:42,240 --> 00:06:46,880
the flow monitor is meant to recognize

00:06:44,479 --> 00:06:49,120
an inexpected turn in the control flow

00:06:46,880 --> 00:06:51,280
for example a function call is skipped

00:06:49,120 --> 00:06:53,759
as a result of an instruction skip

00:06:51,280 --> 00:06:54,720
the flow monitor is a global variable

00:06:53,759 --> 00:06:56,800
whose value is

00:06:54,720 --> 00:06:58,560
adjusted time to time as a program

00:06:56,800 --> 00:07:01,280
execution is progressing

00:06:58,560 --> 00:07:03,360
and it is checked against an expected

00:07:01,280 --> 00:07:04,800
value if it is not matching then the

00:07:03,360 --> 00:07:08,800
control flow was not

00:07:04,800 --> 00:07:12,080
correct for more details i recommend

00:07:08,800 --> 00:07:12,080
checking the links in the slide

00:07:13,919 --> 00:07:17,759
there are there are many resources

00:07:15,840 --> 00:07:20,240
available on the internet about how to

00:07:17,759 --> 00:07:22,639
perform a physical attack

00:07:20,240 --> 00:07:24,720
explaining the exact steps and necessary

00:07:22,639 --> 00:07:25,599
devices to make it possible to replicate

00:07:24,720 --> 00:07:27,840
the attack

00:07:25,599 --> 00:07:30,800
offensive devices can be built for a low

00:07:27,840 --> 00:07:32,479
cost but even there are commercial tools

00:07:30,800 --> 00:07:34,240
that are meant to perform physical

00:07:32,479 --> 00:07:36,400
attacks these are delivered in a

00:07:34,240 --> 00:07:38,960
software framework to make the execution

00:07:36,400 --> 00:07:41,039
of the attack faster and easier

00:07:38,960 --> 00:07:42,800
however on the protection side there is

00:07:41,039 --> 00:07:45,039
less free content mainly just

00:07:42,800 --> 00:07:46,800
research papers of course there are

00:07:45,039 --> 00:07:47,520
certified products again physical

00:07:46,800 --> 00:07:49,440
attacks

00:07:47,520 --> 00:07:52,000
but these are commercial products and

00:07:49,440 --> 00:07:54,000
contain proprietary code

00:07:52,000 --> 00:07:55,039
before we started the implementation we

00:07:54,000 --> 00:07:57,039
have done a research

00:07:55,039 --> 00:07:58,479
to find an open source implementation

00:07:57,039 --> 00:08:00,400
that could be reused

00:07:58,479 --> 00:08:02,000
there was one project but it was not

00:08:00,400 --> 00:08:04,240
major enough to use

00:08:02,000 --> 00:08:05,840
so we decided to make an open source

00:08:04,240 --> 00:08:08,720
implementation in pure c

00:08:05,840 --> 00:08:10,879
to make it free and portable of course

00:08:08,720 --> 00:08:12,639
the protection on the sql level doesn't

00:08:10,879 --> 00:08:14,160
provide any guarantee that is really

00:08:12,639 --> 00:08:16,000
working in practice

00:08:14,160 --> 00:08:17,520
actually the compiled code that is

00:08:16,000 --> 00:08:19,520
really matters and it

00:08:17,520 --> 00:08:21,599
depends on many things like the cpu

00:08:19,520 --> 00:08:22,800
architecture the compiler the level of

00:08:21,599 --> 00:08:24,720
optimization

00:08:22,800 --> 00:08:26,879
so always the combined code must be

00:08:24,720 --> 00:08:27,840
verified with visual inspection and with

00:08:26,879 --> 00:08:30,000
testing

00:08:27,840 --> 00:08:31,680
that is why we also developed a fault

00:08:30,000 --> 00:08:33,680
injection test environment

00:08:31,680 --> 00:08:37,519
that can simulate the most common faults

00:08:33,680 --> 00:08:37,519
like instruction skip and register

00:08:38,839 --> 00:08:43,680
corruption

00:08:40,399 --> 00:08:43,680
there are many resources

00:08:44,800 --> 00:08:47,920
the trusted firmware m project has two

00:08:46,640 --> 00:08:50,000
major part

00:08:47,920 --> 00:08:51,519
one is the secure runtime environment

00:08:50,000 --> 00:08:52,720
and the other one is the secure boot

00:08:51,519 --> 00:08:54,959
process

00:08:52,720 --> 00:08:56,399
the default secure bootloader in tfm is

00:08:54,959 --> 00:08:58,160
the mcu boot

00:08:56,399 --> 00:09:00,000
if an attacker managed to bypass the

00:08:58,160 --> 00:09:02,080
secure boot process

00:09:00,000 --> 00:09:03,760
that he can execute an arbitrary code on

00:09:02,080 --> 00:09:05,519
the highest privilege level

00:09:03,760 --> 00:09:07,440
this can lead to still the device

00:09:05,519 --> 00:09:10,160
secrets like cryptographic keys

00:09:07,440 --> 00:09:12,240
credentials sensitive user data so the

00:09:10,160 --> 00:09:13,040
bootloader is a target that promises a

00:09:12,240 --> 00:09:15,519
big profit

00:09:13,040 --> 00:09:17,519
if the attack is successful another

00:09:15,519 --> 00:09:17,839
property of the bootloader which makes

00:09:17,519 --> 00:09:20,080
it

00:09:17,839 --> 00:09:22,080
attractive for an attacker that it has a

00:09:20,080 --> 00:09:24,880
time deterministic behavior

00:09:22,080 --> 00:09:26,320
it has a constant time execution and all

00:09:24,880 --> 00:09:28,399
the operation happens

00:09:26,320 --> 00:09:30,160
exactly the same time so there is a

00:09:28,399 --> 00:09:31,680
plenty of time to improve the attack

00:09:30,160 --> 00:09:33,200
vector

00:09:31,680 --> 00:09:35,200
at the bottom of the slide there is a

00:09:33,200 --> 00:09:36,959
small code snippet from mc wood

00:09:35,200 --> 00:09:38,880
if you are not considering the physical

00:09:36,959 --> 00:09:40,720
attacks then this is perfectly fine

00:09:38,880 --> 00:09:42,480
but for unfold injection comes to the

00:09:40,720 --> 00:09:43,360
picture then there are many vulnerable

00:09:42,480 --> 00:09:45,120
parts

00:09:43,360 --> 00:09:47,120
instructions keep could lead that the

00:09:45,120 --> 00:09:48,000
main verification function is not called

00:09:47,120 --> 00:09:49,680
at all

00:09:48,000 --> 00:09:51,760
other option is that with register

00:09:49,680 --> 00:09:54,240
corruption the verification function's

00:09:51,760 --> 00:09:56,480
return value is getting modified

00:09:54,240 --> 00:09:58,880
even execution is trapped in an infinite

00:09:56,480 --> 00:10:01,120
loop attacker can try to break out

00:09:58,880 --> 00:10:02,959
and continue the booting this can be

00:10:01,120 --> 00:10:04,560
done with instruction skip because the

00:10:02,959 --> 00:10:05,279
infinite loop is a single branch

00:10:04,560 --> 00:10:08,399
instruction

00:10:05,279 --> 00:10:08,399
to its own address

00:10:11,120 --> 00:10:15,200
mcu boot is a secure bootloader for

00:10:13,200 --> 00:10:17,440
32-bit microcontrollers

00:10:15,200 --> 00:10:19,440
supports many digital signatures types

00:10:17,440 --> 00:10:20,959
and also encrypted images

00:10:19,440 --> 00:10:23,360
on this figure you can see its

00:10:20,959 --> 00:10:24,399
architecture there is a generic boot and

00:10:23,360 --> 00:10:26,880
update logic

00:10:24,399 --> 00:10:29,120
which defines an abstraction layer to

00:10:26,880 --> 00:10:31,200
hide the device specific details

00:10:29,120 --> 00:10:33,279
the crypto operations are provided by

00:10:31,200 --> 00:10:34,880
external crypto libraries which are also

00:10:33,279 --> 00:10:36,640
accessed through an abstraction layer

00:10:34,880 --> 00:10:38,480
from the generic boot logic

00:10:36,640 --> 00:10:40,480
we have focused on the generic boot

00:10:38,480 --> 00:10:43,279
logic in terms of physical attacks

00:10:40,480 --> 00:10:44,480
we inspected and hardened the code flow

00:10:43,279 --> 00:10:46,160
which

00:10:44,480 --> 00:10:47,600
which are crucial from the device

00:10:46,160 --> 00:10:49,360
security point of view

00:10:47,600 --> 00:10:51,360
this means that we have looked for

00:10:49,360 --> 00:10:53,360
sections of the code but an injected

00:10:51,360 --> 00:10:56,160
fold in the code execution

00:10:53,360 --> 00:10:58,240
could lead to bypass the secure process

00:10:56,160 --> 00:11:00,240
and booting successfully an image with

00:10:58,240 --> 00:11:01,920
an invalid signature

00:11:00,240 --> 00:11:03,519
but we have not touched the crypto

00:11:01,920 --> 00:11:05,920
libraries since they are

00:11:03,519 --> 00:11:07,680
independent projects from mcu would so

00:11:05,920 --> 00:11:09,440
the crypto libraries still can have

00:11:07,680 --> 00:11:11,200
vulnerable sections of code from

00:11:09,440 --> 00:11:13,279
physical attack point of view

00:11:11,200 --> 00:11:14,399
the level of provided protection by the

00:11:13,279 --> 00:11:15,440
crypto library

00:11:14,399 --> 00:11:17,600
needs to be checked with the

00:11:15,440 --> 00:11:19,839
corresponding project so

00:11:17,600 --> 00:11:22,000
just a heads up that these enhancements

00:11:19,839 --> 00:11:28,640
are not extending the entire bootloader

00:11:22,000 --> 00:11:30,800
software stack

00:11:28,640 --> 00:11:33,040
on this figure you can see the main boot

00:11:30,800 --> 00:11:34,959
flow in the middle with yellow

00:11:33,040 --> 00:11:36,320
there is the generic boot logic which

00:11:34,959 --> 00:11:39,120
was in our focus

00:11:36,320 --> 00:11:41,040
our goal was to net entirely river items

00:11:39,120 --> 00:11:43,440
you would code instead just provide a

00:11:41,040 --> 00:11:44,480
library which can be optionally enabled

00:11:43,440 --> 00:11:46,640
at compile time

00:11:44,480 --> 00:11:47,839
and in this way make the boot flow more

00:11:46,640 --> 00:11:50,160
more robust

00:11:47,839 --> 00:11:51,279
we wanted to preserve the original code

00:11:50,160 --> 00:11:53,440
as much as we can

00:11:51,279 --> 00:11:55,440
because not all the product requires

00:11:53,440 --> 00:11:57,600
protection against physical attacks

00:11:55,440 --> 00:11:58,880
it depends on the threat model of the

00:11:57,600 --> 00:12:00,480
device

00:11:58,880 --> 00:12:02,560
we achieved this approach with

00:12:00,480 --> 00:12:04,800
implementing the previously mentioned

00:12:02,560 --> 00:12:06,720
counter measures in a way that they are

00:12:04,800 --> 00:12:08,480
wrapping around the crucial function

00:12:06,720 --> 00:12:11,680
calls and condition checks

00:12:08,480 --> 00:12:13,519
to make possible that the side effect of

00:12:11,680 --> 00:12:15,279
physical attack are noticeable

00:12:13,519 --> 00:12:17,920
and the software can go to an error

00:12:15,279 --> 00:12:20,320
handling routine this tiny wrapper layer

00:12:17,920 --> 00:12:20,959
is represented by the orange boxes

00:12:20,320 --> 00:12:25,839
around

00:12:20,959 --> 00:12:25,839
the yellow ones

00:12:27,920 --> 00:12:31,680
so the second half of the talk is

00:12:29,600 --> 00:12:34,079
roughly about what we produced

00:12:31,680 --> 00:12:34,880
um so this is put into roughly four

00:12:34,079 --> 00:12:36,959
categories

00:12:34,880 --> 00:12:38,079
firstly we have the library which is a

00:12:36,959 --> 00:12:39,680
generic implementation

00:12:38,079 --> 00:12:41,760
of the countermeasures that tamash

00:12:39,680 --> 00:12:43,600
mentioned earlier there's no novel

00:12:41,760 --> 00:12:46,160
countermeasures in here we're just doing

00:12:43,600 --> 00:12:48,880
sort of nice implementations of the

00:12:46,160 --> 00:12:48,880
standard ones

00:12:48,959 --> 00:12:52,320
and then the second thing we produced

00:12:51,519 --> 00:12:54,399
was a

00:12:52,320 --> 00:12:55,760
verification tool so this allows us to

00:12:54,399 --> 00:12:56,320
actually verify that the counter

00:12:55,760 --> 00:12:59,440
measures

00:12:56,320 --> 00:13:02,959
are correct and then the last two things

00:12:59,440 --> 00:13:04,079
are we then so these two the library and

00:13:02,959 --> 00:13:07,040
the tool have been

00:13:04,079 --> 00:13:07,360
upstream to mcu boots um the tool is now

00:13:07,040 --> 00:13:10,800
run

00:13:07,360 --> 00:13:13,760
in the mcu boot ci and then the

00:13:10,800 --> 00:13:14,560
last two things are to apply this work

00:13:13,760 --> 00:13:17,440
to tfm

00:13:14,560 --> 00:13:19,040
so the application cfm is the same

00:13:17,440 --> 00:13:20,880
library just um

00:13:19,040 --> 00:13:22,399
used in tfm and then we have another

00:13:20,880 --> 00:13:25,519
version of the tool

00:13:22,399 --> 00:13:28,000
that was used for testing tfm uh

00:13:25,519 --> 00:13:28,000
next slide

00:13:30,639 --> 00:13:34,000
so the counter measures in mcu boot are

00:13:33,040 --> 00:13:35,279
as i said before just

00:13:34,000 --> 00:13:37,760
the certain counter measures you can see

00:13:35,279 --> 00:13:39,360
them listed at the bottom um

00:13:37,760 --> 00:13:41,360
one of the things that we really wanted

00:13:39,360 --> 00:13:44,079
to focus on here was integration

00:13:41,360 --> 00:13:45,040
the ease of integration so one of the

00:13:44,079 --> 00:13:48,079
key priorities

00:13:45,040 --> 00:13:49,839
for mcu boot was size it's

00:13:48,079 --> 00:13:52,079
used in rom a lot of time you don't have

00:13:49,839 --> 00:13:53,279
much space so we've split the counter

00:13:52,079 --> 00:13:54,480
measures into multiple different

00:13:53,279 --> 00:13:56,880
profiles

00:13:54,480 --> 00:13:58,320
so this means the person integrating it

00:13:56,880 --> 00:14:00,320
can pick how much protection that they

00:13:58,320 --> 00:14:02,800
want

00:14:00,320 --> 00:14:03,760
because uh some of these things like the

00:14:02,800 --> 00:14:06,000
double checks

00:14:03,760 --> 00:14:07,199
are literally doubling the size of code

00:14:06,000 --> 00:14:08,720
that you're producing

00:14:07,199 --> 00:14:10,399
at least for the checks so they have

00:14:08,720 --> 00:14:13,120
quite a big impact on

00:14:10,399 --> 00:14:13,519
code size and a slightly smaller impact

00:14:13,120 --> 00:14:15,839
on

00:14:13,519 --> 00:14:17,440
performance so the profiles are a good

00:14:15,839 --> 00:14:18,959
way of um

00:14:17,440 --> 00:14:21,360
splitting things up so that we've got

00:14:18,959 --> 00:14:21,360
minimal

00:14:21,680 --> 00:14:26,480
so that people can choose the amount of

00:14:24,399 --> 00:14:29,040
protection they wanted

00:14:26,480 --> 00:14:29,040
next slide

00:14:29,680 --> 00:14:33,760
so because this was going into an open

00:14:32,240 --> 00:14:35,600
source project we have

00:14:33,760 --> 00:14:37,199
more limitations than most of the other

00:14:35,600 --> 00:14:38,880
implementations of this

00:14:37,199 --> 00:14:40,480
so a lot of the time when you're

00:14:38,880 --> 00:14:41,680
producing a product that is hardened

00:14:40,480 --> 00:14:44,320
against fault injection

00:14:41,680 --> 00:14:45,680
um a lot of the mitigations will be done

00:14:44,320 --> 00:14:48,800
in assembly

00:14:45,680 --> 00:14:52,560
or alternatively they'll be done in c

00:14:48,800 --> 00:14:54,560
but because the actual mitigations

00:14:52,560 --> 00:14:56,000
are as a result of what assembly gets

00:14:54,560 --> 00:14:57,680
executed you still care about the

00:14:56,000 --> 00:15:00,399
generated assembly

00:14:57,680 --> 00:15:01,839
so they will mandate that a particular

00:15:00,399 --> 00:15:03,600
compiler has to be used on when a

00:15:01,839 --> 00:15:06,399
compiler version has to be used

00:15:03,600 --> 00:15:07,440
um and we can't really do that um

00:15:06,399 --> 00:15:08,959
because it's open source

00:15:07,440 --> 00:15:10,560
we don't know what compilers people are

00:15:08,959 --> 00:15:11,920
going to use we don't know what compiler

00:15:10,560 --> 00:15:13,360
versions people use we actually don't

00:15:11,920 --> 00:15:13,920
know what isa is going to be compiled

00:15:13,360 --> 00:15:17,040
into

00:15:13,920 --> 00:15:19,760
um so we had to write everything in c

00:15:17,040 --> 00:15:21,600
um which does come with some downsides

00:15:19,760 --> 00:15:23,680
the main one being that it's

00:15:21,600 --> 00:15:25,279
quite hard to check that you're actually

00:15:23,680 --> 00:15:27,360
producing correct um

00:15:25,279 --> 00:15:28,560
counter measures because you don't know

00:15:27,360 --> 00:15:28,959
what the compiler will produce from the

00:15:28,560 --> 00:15:31,120
c

00:15:28,959 --> 00:15:32,800
um you can do reasonably well with this

00:15:31,120 --> 00:15:36,399
by messing with the c

00:15:32,800 --> 00:15:38,000
cement by messing with um

00:15:36,399 --> 00:15:40,320
some of the features of the c language

00:15:38,000 --> 00:15:42,079
like volatile to prevent compilers

00:15:40,320 --> 00:15:43,680
to basically force compilers to do what

00:15:42,079 --> 00:15:44,560
you want because volatile prevents

00:15:43,680 --> 00:15:46,800
optimization

00:15:44,560 --> 00:15:48,959
um and allows you to get away with a lot

00:15:46,800 --> 00:15:49,360
of things that otherwise would be marked

00:15:48,959 --> 00:15:54,240
as

00:15:49,360 --> 00:15:57,600
obvious duplicates of dead code um

00:15:54,240 --> 00:15:59,279
so c uh gives us

00:15:57,600 --> 00:16:01,440
a bunch of benefits the other one is

00:15:59,279 --> 00:16:04,160
that it's really easy to integrate with

00:16:01,440 --> 00:16:06,320
so um what we basically produced was a

00:16:04,160 --> 00:16:08,720
couple of drop-in replacement macros

00:16:06,320 --> 00:16:10,079
so you all the vulnerable areas will

00:16:08,720 --> 00:16:10,959
just have a macro that you can replace

00:16:10,079 --> 00:16:13,600
your code with

00:16:10,959 --> 00:16:14,880
um that sort of wraps around it um and

00:16:13,600 --> 00:16:18,399
this means that the effort to actually

00:16:14,880 --> 00:16:18,399
integrate the library is very minimal

00:16:18,720 --> 00:16:23,759
and the other thing we did for

00:16:21,759 --> 00:16:25,519
portability again was put lots of effort

00:16:23,759 --> 00:16:26,959
into minimizing the code size so we've

00:16:25,519 --> 00:16:28,560
got all these profiles and they are

00:16:26,959 --> 00:16:29,360
implemented with macros so you can just

00:16:28,560 --> 00:16:31,519
toggle off

00:16:29,360 --> 00:16:33,040
all of the the account measures if you

00:16:31,519 --> 00:16:33,360
want and you'll be left with effectively

00:16:33,040 --> 00:16:35,360
the

00:16:33,360 --> 00:16:36,720
the same code as the original all of the

00:16:35,360 --> 00:16:39,920
the types will be restored to

00:16:36,720 --> 00:16:42,079
standard and all of the um uh

00:16:39,920 --> 00:16:43,199
the conditions will go back to how you'd

00:16:42,079 --> 00:16:45,759
expect them to be

00:16:43,199 --> 00:16:45,759
next slide

00:16:46,560 --> 00:16:50,639
so on the left you can see there's the

00:16:48,079 --> 00:16:52,800
original mcubic code and on the bottom

00:16:50,639 --> 00:16:54,800
left you can see that there's the um

00:16:52,800 --> 00:16:56,000
the harden code so you see there's a few

00:16:54,800 --> 00:16:58,000
things here there's um

00:16:56,000 --> 00:16:59,440
fh call is our wrapper around function

00:16:58,000 --> 00:17:01,759
calls which does some

00:16:59,440 --> 00:17:03,839
set up at the start and teardown at the

00:17:01,759 --> 00:17:06,959
end which is basically this the

00:17:03,839 --> 00:17:08,880
the um flow control the uh state

00:17:06,959 --> 00:17:10,720
monitoring that tamash mentioned so it

00:17:08,880 --> 00:17:12,079
saves the state at the start and then

00:17:10,720 --> 00:17:13,600
checks that the state is the expected

00:17:12,079 --> 00:17:15,360
one at the end so that checks that the

00:17:13,600 --> 00:17:17,760
function actually gets called

00:17:15,360 --> 00:17:18,880
um we've got some labeling in there as

00:17:17,760 --> 00:17:20,079
well for the testing tool i'll talk

00:17:18,880 --> 00:17:22,319
about in a second

00:17:20,079 --> 00:17:24,079
we've got an updated equality function

00:17:22,319 --> 00:17:26,400
which um

00:17:24,079 --> 00:17:28,480
this is used with uh the double checks

00:17:26,400 --> 00:17:31,280
so it will run the equality test twice

00:17:28,480 --> 00:17:32,559
and if you have a the other thing we've

00:17:31,280 --> 00:17:34,640
got is um

00:17:32,559 --> 00:17:36,320
doubled variables so each variable

00:17:34,640 --> 00:17:38,320
becomes a tuple with um

00:17:36,320 --> 00:17:39,360
the original value and then the masked

00:17:38,320 --> 00:17:40,880
value which is

00:17:39,360 --> 00:17:43,440
derived from the original value by

00:17:40,880 --> 00:17:44,720
xoring it with a mask

00:17:43,440 --> 00:17:47,039
and then we can check that the original

00:17:44,720 --> 00:17:48,480
values and the masked values are

00:17:47,039 --> 00:17:50,000
xored between each other so we can check

00:17:48,480 --> 00:17:51,200
the integrity of a single variable and

00:17:50,000 --> 00:17:52,559
then we can also

00:17:51,200 --> 00:17:54,400
do this double check by checking the

00:17:52,559 --> 00:17:56,400
mask values the same as the original

00:17:54,400 --> 00:17:58,240
values which gives us a double check for

00:17:56,400 --> 00:17:59,520
everything

00:17:58,240 --> 00:18:01,280
and the other thing we've got his fh

00:17:59,520 --> 00:18:02,000
panic which i haven't expanded but this

00:18:01,280 --> 00:18:04,240
is uh

00:18:02,000 --> 00:18:05,440
a slightly harder boot failure loop so

00:18:04,240 --> 00:18:07,520
it just contains a

00:18:05,440 --> 00:18:09,600
very large amount of um branch

00:18:07,520 --> 00:18:10,799
instructions so it's harder to skip out

00:18:09,600 --> 00:18:11,919
of the loop because you'll just be

00:18:10,799 --> 00:18:13,440
returned to the start

00:18:11,919 --> 00:18:15,200
i think there's about nine branch

00:18:13,440 --> 00:18:17,679
instructions in that

00:18:15,200 --> 00:18:17,679
next slide

00:18:19,360 --> 00:18:22,400
so the counter mission performance

00:18:20,720 --> 00:18:24,080
actually turned out to be quite good um

00:18:22,400 --> 00:18:25,280
the profiles help with minimizing code

00:18:24,080 --> 00:18:28,720
size but even at the top end

00:18:25,280 --> 00:18:30,240
it's 2.6 k so that's not a huge amount

00:18:28,720 --> 00:18:31,360
for hardening the whole bootloader

00:18:30,240 --> 00:18:34,080
compared to the rest of it

00:18:31,360 --> 00:18:36,080
um and then at the lower end it was what

00:18:34,080 --> 00:18:38,720
250 bytes with it disables

00:18:36,080 --> 00:18:39,280
so that's really quite reasonable and i

00:18:38,720 --> 00:18:40,400
think

00:18:39,280 --> 00:18:42,320
that really helped with getting it

00:18:40,400 --> 00:18:44,320
merged into the project because

00:18:42,320 --> 00:18:45,840
no one could complain that we were

00:18:44,320 --> 00:18:47,840
vastly increasing the code size for

00:18:45,840 --> 00:18:49,440
questionable benefits

00:18:47,840 --> 00:18:51,200
and the actual performance of the the

00:18:49,440 --> 00:18:52,400
thing this was these results were

00:18:51,200 --> 00:18:53,760
generated with the tool which again i'll

00:18:52,400 --> 00:18:56,320
talk about in a second but

00:18:53,760 --> 00:18:57,120
the performance is really quite good um

00:18:56,320 --> 00:19:00,559
it looks like

00:18:57,120 --> 00:19:02,799
we've we have the the

00:19:00,559 --> 00:19:03,679
count measures do work and their

00:19:02,799 --> 00:19:05,919
profiles all

00:19:03,679 --> 00:19:06,720
provide more protection than the other

00:19:05,919 --> 00:19:09,280
one

00:19:06,720 --> 00:19:10,799
so it's it does look like this has

00:19:09,280 --> 00:19:13,679
basically been a success

00:19:10,799 --> 00:19:13,679
uh next slide

00:19:14,960 --> 00:19:19,600
so the testing tool the main the

00:19:18,000 --> 00:19:21,200
important thing that we spotted here was

00:19:19,600 --> 00:19:22,720
that all of the faults that we were

00:19:21,200 --> 00:19:24,160
looking at could be modeled using a

00:19:22,720 --> 00:19:28,080
stand debugger

00:19:24,160 --> 00:19:29,679
so you can do skip faults by

00:19:28,080 --> 00:19:31,440
incrementing the program counter and you

00:19:29,679 --> 00:19:32,480
can set registers of random values and

00:19:31,440 --> 00:19:33,919
once we knew that

00:19:32,480 --> 00:19:35,200
it was very easy to build this tool

00:19:33,919 --> 00:19:37,360
because effectively we're just getting a

00:19:35,200 --> 00:19:38,559
platform you can run in ci which was qmu

00:19:37,360 --> 00:19:39,919
in this case

00:19:38,559 --> 00:19:42,320
and then we just have the script which

00:19:39,919 --> 00:19:45,200
controlled the debugger and then would

00:19:42,320 --> 00:19:45,520
um run faults using that and we'd sort

00:19:45,200 --> 00:19:47,120
of

00:19:45,520 --> 00:19:48,799
defaults on areas that we suspect

00:19:47,120 --> 00:19:51,120
defaults would be

00:19:48,799 --> 00:19:52,240
would where suspected that faults would

00:19:51,120 --> 00:19:54,160
cause problems as

00:19:52,240 --> 00:19:55,919
labeled by the um the countermeasures

00:19:54,160 --> 00:19:58,000
code um

00:19:55,919 --> 00:19:59,440
and the trick here was that we could

00:19:58,000 --> 00:20:00,799
really easily evaluate whether a fault

00:19:59,440 --> 00:20:01,360
it succeeded or not because we would

00:20:00,799 --> 00:20:04,159
just give

00:20:01,360 --> 00:20:05,600
msu button a valid image and if we if

00:20:04,159 --> 00:20:06,559
the invalid image booted then we knew

00:20:05,600 --> 00:20:11,440
that our fault had

00:20:06,559 --> 00:20:11,440
successfully um successfully

00:20:11,600 --> 00:20:16,960
bypassed the protection um next slide

00:20:18,480 --> 00:20:22,080
so the second thing to do was to

00:20:20,799 --> 00:20:24,159
implement these countermeasures in the

00:20:22,080 --> 00:20:26,320
tfm runtime this is ongoing

00:20:24,159 --> 00:20:28,240
um but it's using all the same libraries

00:20:26,320 --> 00:20:29,840
or the same code the only tricky bit is

00:20:28,240 --> 00:20:31,280
that the tfm runtime is slightly larger

00:20:29,840 --> 00:20:32,480
so it takes a little bit more time to go

00:20:31,280 --> 00:20:33,200
and replace all these calls with their

00:20:32,480 --> 00:20:37,280
vouch call

00:20:33,200 --> 00:20:38,400
etc um but at the moment it's doing

00:20:37,280 --> 00:20:39,280
reasonably well and the generic

00:20:38,400 --> 00:20:42,480
implementation is

00:20:39,280 --> 00:20:45,360
is holding up so that's nice that

00:20:42,480 --> 00:20:46,880
um basically our it does look like our

00:20:45,360 --> 00:20:48,960
thing is usable in multiple contacts

00:20:46,880 --> 00:20:50,320
which is one of the aims is to provide

00:20:48,960 --> 00:20:51,760
something that you can is basically an

00:20:50,320 --> 00:20:53,360
off-the-shelf solution that you can just

00:20:51,760 --> 00:20:55,440
pull out and put in a project and it

00:20:53,360 --> 00:20:58,559
will provide some protection

00:20:55,440 --> 00:21:00,320
um next slide so

00:20:58,559 --> 00:21:02,080
what the main challenge with porting it

00:21:00,320 --> 00:21:03,760
to tfm actually was the testing tool

00:21:02,080 --> 00:21:05,679
because in mcu boot we had this really

00:21:03,760 --> 00:21:06,799
nice way of telling if a fault has

00:21:05,679 --> 00:21:08,799
succeeded

00:21:06,799 --> 00:21:10,400
and in tfm it's much harder so we had to

00:21:08,799 --> 00:21:12,480
rewrite the tool and make it a lot more

00:21:10,400 --> 00:21:14,799
complex and the main aim was basically

00:21:12,480 --> 00:21:16,720
to allow it to scan memory because the

00:21:14,799 --> 00:21:17,679
um the isolation hardware used to

00:21:16,720 --> 00:21:20,480
protect

00:21:17,679 --> 00:21:22,000
secure side we can see all the the

00:21:20,480 --> 00:21:23,200
configuration of that in memory so we

00:21:22,000 --> 00:21:26,400
can

00:21:23,200 --> 00:21:27,120
we we have the debugger um run through

00:21:26,400 --> 00:21:28,559
the program

00:21:27,120 --> 00:21:30,080
first to start with to check what all

00:21:28,559 --> 00:21:31,919
the values of the memory should be to

00:21:30,080 --> 00:21:33,200
assess at points and then we will

00:21:31,919 --> 00:21:35,360
trigger faults and then we'll compare

00:21:33,200 --> 00:21:38,080
these against the expected values

00:21:35,360 --> 00:21:39,600
um and it turns out that's that solves

00:21:38,080 --> 00:21:41,200
our problem in terms of trying to work

00:21:39,600 --> 00:21:42,559
out what our fault is it's we've got to

00:21:41,200 --> 00:21:44,799
be a bit conservative here and

00:21:42,559 --> 00:21:46,000
say that any change the isolation set up

00:21:44,799 --> 00:21:48,080
is a

00:21:46,000 --> 00:21:49,600
failure of our council measures but um

00:21:48,080 --> 00:21:50,000
when most of them actually would just

00:21:49,600 --> 00:21:53,200
cause

00:21:50,000 --> 00:21:55,679
the system to be inoperable but better

00:21:53,200 --> 00:21:57,440
safe than sorry

00:21:55,679 --> 00:21:59,039
and this also while we were doing this

00:21:57,440 --> 00:22:00,320
this required doing a lot of rewriting

00:21:59,039 --> 00:22:02,559
the tools so we've got lots of nice

00:22:00,320 --> 00:22:05,039
features including a much better python

00:22:02,559 --> 00:22:07,200
layer to write tests in

00:22:05,039 --> 00:22:09,280
we've got secure safe loading support

00:22:07,200 --> 00:22:11,919
which meant that we could

00:22:09,280 --> 00:22:13,280
restore the state of the code so we

00:22:11,919 --> 00:22:14,880
could then skip backwards and we could

00:22:13,280 --> 00:22:15,679
run lots more tests because that was our

00:22:14,880 --> 00:22:18,880
main limiting

00:22:15,679 --> 00:22:20,480
factor is that you can run it's

00:22:18,880 --> 00:22:22,240
it's the more test you can run the

00:22:20,480 --> 00:22:23,600
better your coverage is but it was just

00:22:22,240 --> 00:22:26,400
taking quite a while to run the tests

00:22:23,600 --> 00:22:27,520
which has now got a lot better um

00:22:26,400 --> 00:22:29,440
and then we've got some quite nice

00:22:27,520 --> 00:22:32,480
machine possible outputs in

00:22:29,440 --> 00:22:34,480
jason and

00:22:32,480 --> 00:22:36,559
yeah i think that is roughly everything

00:22:34,480 --> 00:22:40,159
that we we implemented

00:22:36,559 --> 00:22:42,799
um next slide

00:22:40,159 --> 00:22:44,400
yeah so so far we only relied on our

00:22:42,799 --> 00:22:45,600
simulator environment to test the

00:22:44,400 --> 00:22:47,919
implementation but

00:22:45,600 --> 00:22:49,840
it is in our interest to get external

00:22:47,919 --> 00:22:50,960
feedback as well from experts in this

00:22:49,840 --> 00:22:52,960
area

00:22:50,960 --> 00:22:54,880
so recently arm has started an

00:22:52,960 --> 00:22:57,280
internship whose goal is to do an

00:22:54,880 --> 00:22:58,960
external verification of the hard nmc

00:22:57,280 --> 00:23:00,720
boot code and this is done in a

00:22:58,960 --> 00:23:03,600
collaboration with arm and

00:23:00,720 --> 00:23:05,520
sorbon university uh during this

00:23:03,600 --> 00:23:07,440
internship the testing will be done in a

00:23:05,520 --> 00:23:09,440
different simulator environment and

00:23:07,440 --> 00:23:11,360
based on the progress might on a real

00:23:09,440 --> 00:23:13,520
hardware test bench

00:23:11,360 --> 00:23:15,679
the the result of the validation could

00:23:13,520 --> 00:23:18,880
be used to enhance further the quote

00:23:15,679 --> 00:23:21,360
quality and make mcwood more secure

00:23:18,880 --> 00:23:22,080
the result is going to be available in

00:23:21,360 --> 00:23:25,440
the

00:23:22,080 --> 00:23:25,440
third quarter of this year

00:23:30,799 --> 00:23:33,919
and this is our last slide we are just

00:23:32,559 --> 00:23:35,200
collected all the links from the

00:23:33,919 --> 00:23:38,000
presentation

00:23:35,200 --> 00:23:39,040
so thanks for your attention and time

00:23:38,000 --> 00:23:40,480
and i think we have

00:23:39,040 --> 00:23:43,679
[Music]

00:23:40,480 --> 00:23:43,679
one minute for the questions

00:23:44,640 --> 00:23:48,320
yeah um so we can quickly go through um

00:23:47,039 --> 00:23:49,520
there's a question about whether it's

00:23:48,320 --> 00:23:52,400
possible to inform from

00:23:49,520 --> 00:23:53,440
instrument compilers to add checks this

00:23:52,400 --> 00:23:54,559
is something that lots of people are

00:23:53,440 --> 00:23:56,159
looking into

00:23:54,559 --> 00:23:57,919
because it's a much easier way of doing

00:23:56,159 --> 00:23:59,679
it than the c but

00:23:57,919 --> 00:24:01,120
at the moment i don't believe anyone has

00:23:59,679 --> 00:24:03,600
actually produced any

00:24:01,120 --> 00:24:05,039
um usable compiler there's lots of

00:24:03,600 --> 00:24:07,039
research going on with universities but

00:24:05,039 --> 00:24:10,640
no one has produced anything um

00:24:07,039 --> 00:24:12,080
sort of that has been upstreamed yet um

00:24:10,640 --> 00:24:14,400
unfortunately because it would be a lot

00:24:12,080 --> 00:24:17,200
easier if we could do this

00:24:14,400 --> 00:24:18,400
um in the compiler i'm not sure we're

00:24:17,200 --> 00:24:19,760
gonna get to the rest of questions we'll

00:24:18,400 --> 00:24:21,440
go and answer them

00:24:19,760 --> 00:24:23,440
in chat later but from the end of the

00:24:21,440 --> 00:24:26,720
session yeah

00:24:23,440 --> 00:24:29,279
yeah it's a good idea okay

00:24:26,720 --> 00:24:31,120
thank you very much for your attention

00:24:29,279 --> 00:24:33,600
thanks ray from thomas for your

00:24:31,120 --> 00:24:35,120
interesting session and we look thanks

00:24:33,600 --> 00:24:47,840
for those who attended and we look

00:24:35,120 --> 00:24:47,840
forward to further interactions

00:24:51,360 --> 00:24:53,440

YouTube URL: https://www.youtube.com/watch?v=7eI2j6m0JCU


