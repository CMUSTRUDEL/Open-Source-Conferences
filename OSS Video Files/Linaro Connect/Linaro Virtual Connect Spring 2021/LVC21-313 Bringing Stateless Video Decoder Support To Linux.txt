Title: LVC21-313 Bringing Stateless Video Decoder Support To Linux
Publication date: 2021-04-15
Playlist: Linaro Virtual Connect Spring 2021
Description: 
	Under development for many years, support for video CODEC accelerators in Linux gained significant traction in 2020. A formal specification was merged into the Linux Media subsystem in v5.5, allowing for blob free hardware accelerated decoding on popular platforms such as Allwinner, NXP i.MX8, Microchip SAMA5, and Rockchip. In addition, H.264 V4L2 controls were destaged in v5.11, and the remaining CODEC controls will be coming soon to mainline.

In this talk, we will take a deep dive into stateless video decoder support for Linux, including an overview of the decoding process using hardware accelerators, a look at the user space API and how it's used within multimedia frameworks, and how this all works with modern GPU accelerators. Lastly, this presentation would not be complete without discussing the effort to bring native support in FFMPEG and GStreamer, and its major role in the development of the new Open Source drivers.
Captions: 
	00:00:05,180 --> 00:00:08,320
[Music]

00:00:07,680 --> 00:00:10,400
hello

00:00:08,320 --> 00:00:11,360
welcome to lean arrow virtual connect

00:00:10,400 --> 00:00:14,400
00:00:11,360 --> 00:00:15,679
i'm nikolaj freyn i'm principal engineer

00:00:14,400 --> 00:00:17,680
at collabra

00:00:15,679 --> 00:00:19,600
i've been working at collabra for over

00:00:17,680 --> 00:00:22,320
11 years

00:00:19,600 --> 00:00:24,080
i'm specialized in multimedia core

00:00:22,320 --> 00:00:26,560
gstreamer developer

00:00:24,080 --> 00:00:28,480
but these days i'm working a lot with

00:00:26,560 --> 00:00:30,320
kernel engineers in order to bring

00:00:28,480 --> 00:00:32,880
forward codec support

00:00:30,320 --> 00:00:34,480
into the linux kernel especially the

00:00:32,880 --> 00:00:38,160
stateless

00:00:34,480 --> 00:00:40,879
hardware support the story

00:00:38,160 --> 00:00:44,000
of codec and linux starts a long time

00:00:40,879 --> 00:00:46,320
ago in 2011 so in 2011

00:00:44,000 --> 00:00:47,200
it was the launch of the first

00:00:46,320 --> 00:00:49,840
generation of

00:00:47,200 --> 00:00:52,079
arm chromebook by google which was

00:00:49,840 --> 00:00:54,719
partnering with samsung

00:00:52,079 --> 00:00:55,440
and they were actually sporting an

00:00:54,719 --> 00:00:58,960
exynos

00:00:55,440 --> 00:01:02,079
5 soc and they managed to

00:00:58,960 --> 00:01:05,280
implement using v4l api

00:01:02,079 --> 00:01:09,439
a new way actually the the

00:01:05,280 --> 00:01:09,439
their codec support the mfc codec

00:01:10,080 --> 00:01:14,400
later on in 2014 uh some folks actually

00:01:13,840 --> 00:01:18,400
reverse

00:01:14,400 --> 00:01:21,759
engineered the imx 6 and 51

00:01:18,400 --> 00:01:25,200
series of codec which was actually

00:01:21,759 --> 00:01:27,600
running the coda chip coda refers to the

00:01:25,200 --> 00:01:31,680
brand name from chips and media's

00:01:27,600 --> 00:01:34,560
design so what's a stateful

00:01:31,680 --> 00:01:36,479
decoder because we can't speak about

00:01:34,560 --> 00:01:38,320
stateless decoder without mentioning

00:01:36,479 --> 00:01:41,520
stateful decoder

00:01:38,320 --> 00:01:44,079
is and this is a general idea because uh

00:01:41,520 --> 00:01:45,920
hardware can vary a lot but in general

00:01:44,079 --> 00:01:49,000
it's composed of a

00:01:45,920 --> 00:01:52,799
processor and one or multiple

00:01:49,000 --> 00:01:53,520
accelerators and the way it works is

00:01:52,799 --> 00:01:57,040
that you will

00:01:53,520 --> 00:01:59,439
input some bitstream into the hardware

00:01:57,040 --> 00:02:01,119
the hardware will do all the processing

00:01:59,439 --> 00:02:03,600
parsing

00:02:01,119 --> 00:02:05,600
entropy decoding or anything that is

00:02:03,600 --> 00:02:08,080
needed for that specific codec and will

00:02:05,600 --> 00:02:10,560
produce frames in the right order at the

00:02:08,080 --> 00:02:10,560
output

00:02:10,800 --> 00:02:14,959
so in linux the way we integrate all

00:02:13,840 --> 00:02:18,160
this

00:02:14,959 --> 00:02:21,440
is that we have a typical

00:02:18,160 --> 00:02:22,000
v4l video device and this video device

00:02:21,440 --> 00:02:25,040
unlike the

00:02:22,000 --> 00:02:25,360
other have two cues so there's an output

00:02:25,040 --> 00:02:28,000
q

00:02:25,360 --> 00:02:28,560
and a capture cube now bear in mind this

00:02:28,000 --> 00:02:31,200
is

00:02:28,560 --> 00:02:31,760
historical naming the output q is the

00:02:31,200 --> 00:02:34,080
actual

00:02:31,760 --> 00:02:35,200
input that's where the the bit stream

00:02:34,080 --> 00:02:37,280
comes in

00:02:35,200 --> 00:02:38,319
and the capture queue is the output of

00:02:37,280 --> 00:02:40,879
the decoder

00:02:38,319 --> 00:02:43,440
and that's where the raw frames are

00:02:40,879 --> 00:02:43,440
produced

00:02:43,840 --> 00:02:49,840
the stateful decoders are very simple

00:02:47,360 --> 00:02:51,760
you don't need much codec specific

00:02:49,840 --> 00:02:53,280
knowledge in user space in order to

00:02:51,760 --> 00:02:56,720
drive such a

00:02:53,280 --> 00:03:00,560
such a hardware so it's rather simple

00:02:56,720 --> 00:03:03,519
but uh i mean for open source purists it

00:03:00,560 --> 00:03:05,720
very often comes with a firmware and

00:03:03,519 --> 00:03:09,200
firmwares are

00:03:05,720 --> 00:03:11,440
99.999 a closed source

00:03:09,200 --> 00:03:12,560
for various reasons they might contain

00:03:11,440 --> 00:03:15,440
source code from

00:03:12,560 --> 00:03:16,959
third parties the architecture the

00:03:15,440 --> 00:03:19,120
processor architecture might be

00:03:16,959 --> 00:03:21,840
totally custom and there might not be

00:03:19,120 --> 00:03:24,400
any compiler actually available for that

00:03:21,840 --> 00:03:25,680
the other downside of a stateful decoder

00:03:24,400 --> 00:03:28,879
is it can be

00:03:25,680 --> 00:03:31,440
much harder to multiplex because some of

00:03:28,879 --> 00:03:33,599
the firmware might have limitation like

00:03:31,440 --> 00:03:34,959
two streams or three streams totally

00:03:33,599 --> 00:03:36,959
arbitrary

00:03:34,959 --> 00:03:39,599
and it doesn't correlate to the size of

00:03:36,959 --> 00:03:39,599
the streams

00:03:40,159 --> 00:03:45,280
oops now

00:03:45,440 --> 00:03:51,360
in 2015 google was

00:03:48,879 --> 00:03:52,720
creating the second generation of

00:03:51,360 --> 00:03:55,200
chromebook device

00:03:52,720 --> 00:03:57,599
and that's where they started working

00:03:55,200 --> 00:04:00,480
with rockchip and rachip was

00:03:57,599 --> 00:04:01,200
was running actually a vpu that was

00:04:00,480 --> 00:04:03,920
stateless

00:04:01,200 --> 00:04:04,959
stateless meaning that the hardware

00:04:03,920 --> 00:04:07,280
didn't

00:04:04,959 --> 00:04:09,040
keep a state of the streams that are

00:04:07,280 --> 00:04:10,799
being decoded so you have to

00:04:09,040 --> 00:04:12,720
program everything we'll see more

00:04:10,799 --> 00:04:16,160
details later

00:04:12,720 --> 00:04:20,079
so what google did is that they created

00:04:16,160 --> 00:04:22,000
a new way of using v4l specifically for

00:04:20,079 --> 00:04:23,120
these hardware but it was under

00:04:22,000 --> 00:04:28,000
downstream kernel

00:04:23,120 --> 00:04:30,960
in 2015

00:04:28,000 --> 00:04:31,680
now what's a stateless decoder hardware

00:04:30,960 --> 00:04:34,560
look like

00:04:31,680 --> 00:04:35,360
well basically the hardware is composed

00:04:34,560 --> 00:04:38,800
of

00:04:35,360 --> 00:04:39,759
acceleration function which could be a

00:04:38,800 --> 00:04:43,759
single function

00:04:39,759 --> 00:04:46,320
per frame a function per slice

00:04:43,759 --> 00:04:47,520
or it could actually be a function that

00:04:46,320 --> 00:04:49,600
speaks to a

00:04:47,520 --> 00:04:50,800
processor that will drive some

00:04:49,600 --> 00:04:53,440
accelerators

00:04:50,800 --> 00:04:55,199
we'll see later and in order to drive

00:04:53,440 --> 00:04:57,440
this hardware you have to pass

00:04:55,199 --> 00:04:59,759
all the information for decoding that

00:04:57,440 --> 00:05:01,759
specific frame so all the references

00:04:59,759 --> 00:05:04,240
needed to decode that frame

00:05:01,759 --> 00:05:05,199
you have to pass a bit stream of course

00:05:04,240 --> 00:05:07,600
well only the

00:05:05,199 --> 00:05:09,120
only the part that you're not passing as

00:05:07,600 --> 00:05:11,199
parameters so you have to

00:05:09,120 --> 00:05:13,520
pass all the parameters that are the

00:05:11,199 --> 00:05:15,199
context into which we are decoding

00:05:13,520 --> 00:05:17,440
and then the picture will be produced in

00:05:15,199 --> 00:05:20,240
the order you are actually

00:05:17,440 --> 00:05:22,080
decoding them so it's up to user space

00:05:20,240 --> 00:05:26,080
to reorder

00:05:22,080 --> 00:05:28,160
now on the v4 l2 side

00:05:26,080 --> 00:05:29,520
it's a bit the same design so there's

00:05:28,160 --> 00:05:31,360
still a video

00:05:29,520 --> 00:05:32,800
a video node with the output and the

00:05:31,360 --> 00:05:34,960
capture queue but

00:05:32,800 --> 00:05:37,199
there's a lot more controls and those

00:05:34,960 --> 00:05:38,000
controls are mandatory they are the

00:05:37,199 --> 00:05:41,600
parameters

00:05:38,000 --> 00:05:44,400
that are needed to decode now

00:05:41,600 --> 00:05:47,199
passing control was not enough because

00:05:44,400 --> 00:05:49,919
v4l is based on a queue so you need to

00:05:47,199 --> 00:05:51,039
strictly correlate which control goes

00:05:49,919 --> 00:05:54,320
with which

00:05:51,039 --> 00:05:57,360
bitstream buffers so we

00:05:54,320 --> 00:05:59,840
it was introduced the the request api

00:05:57,360 --> 00:06:00,720
so the request is an object in the file

00:05:59,840 --> 00:06:02,960
descriptor

00:06:00,720 --> 00:06:04,319
and you can attach control values to

00:06:02,960 --> 00:06:07,440
that request

00:06:04,319 --> 00:06:08,000
and you can also associate your buffers

00:06:07,440 --> 00:06:10,479
that you're

00:06:08,000 --> 00:06:13,039
queuing with a request in a way that the

00:06:10,479 --> 00:06:15,840
driver can retrieve all the parameters

00:06:13,039 --> 00:06:16,560
for a specific bit stream to be decoded

00:06:15,840 --> 00:06:20,800
all together

00:06:16,560 --> 00:06:24,000
atomically inside the queue

00:06:20,800 --> 00:06:27,759
this request was implemented in

00:06:24,000 --> 00:06:29,840
the media controller layer and

00:06:27,759 --> 00:06:32,000
that layer was added for future

00:06:29,840 --> 00:06:33,280
enhancement to use actually request with

00:06:32,000 --> 00:06:36,560
cameras and other

00:06:33,280 --> 00:06:38,639
systems and we took benefit

00:06:36,560 --> 00:06:41,120
actually of the the presence of a media

00:06:38,639 --> 00:06:44,240
controller to expose a topology and the

00:06:41,120 --> 00:06:47,039
topology replaces the old way

00:06:44,240 --> 00:06:48,080
of figuring out if this drive what this

00:06:47,039 --> 00:06:49,919
driver is about

00:06:48,080 --> 00:06:51,360
so previously to figure out that the

00:06:49,919 --> 00:06:55,120
driver was a decoder

00:06:51,360 --> 00:06:56,639
we would list the the input format to

00:06:55,120 --> 00:07:00,080
all be encoded format

00:06:56,639 --> 00:07:02,400
and then the the output format to all be

00:07:00,080 --> 00:07:04,160
raw format and that would be a decoder

00:07:02,400 --> 00:07:06,720
right it's a guess that we were

00:07:04,160 --> 00:07:07,680
we would be making with the topology you

00:07:06,720 --> 00:07:09,919
can actually

00:07:07,680 --> 00:07:11,120
see in the topology that you have the

00:07:09,919 --> 00:07:14,880
same node twice

00:07:11,120 --> 00:07:15,360
so it's m2m repeat repeated in a simple

00:07:14,880 --> 00:07:16,720
graph

00:07:15,360 --> 00:07:18,880
and in the middle of the graph you will

00:07:16,720 --> 00:07:21,680
find a decoding function so it's much

00:07:18,880 --> 00:07:21,680
more explicit

00:07:22,880 --> 00:07:30,319
now the process of decoding with

00:07:26,160 --> 00:07:32,960
v4l is slightly changed so

00:07:30,319 --> 00:07:33,840
the first step for stateless decoder is

00:07:32,960 --> 00:07:37,360
to allocate

00:07:33,840 --> 00:07:40,639
a request which is a file descriptor

00:07:37,360 --> 00:07:44,560
then you're going to set

00:07:40,639 --> 00:07:46,080
all the parameters and while setting

00:07:44,560 --> 00:07:47,599
those parameters you're going to set

00:07:46,080 --> 00:07:49,919
them for that request so

00:07:47,599 --> 00:07:51,360
you're going to store the parameters for

00:07:49,919 --> 00:07:54,080
the decoding

00:07:51,360 --> 00:07:54,879
of a frame or a slice into that request

00:07:54,080 --> 00:07:58,240
and then you'll

00:07:54,879 --> 00:08:01,440
cue a buffer for that request

00:07:58,240 --> 00:08:04,639
and finally you will cue the request and

00:08:01,440 --> 00:08:05,759
instead of waiting on the driver file

00:08:04,639 --> 00:08:08,960
descriptor

00:08:05,759 --> 00:08:09,840
for job to be completed you can actually

00:08:08,960 --> 00:08:12,479
wait on

00:08:09,840 --> 00:08:13,360
the request file descriptor with the

00:08:12,479 --> 00:08:16,479
benefit that

00:08:13,360 --> 00:08:18,319
if there's reordering uh taking place

00:08:16,479 --> 00:08:20,080
you can actually and and

00:08:18,319 --> 00:08:22,240
your frame that you want to display is

00:08:20,080 --> 00:08:22,639
the fifth in the queue you can actually

00:08:22,240 --> 00:08:24,960
wait

00:08:22,639 --> 00:08:26,000
only for that frame instead of waiting

00:08:24,960 --> 00:08:29,599
five times so there's

00:08:26,000 --> 00:08:32,640
a bit of a gain there now

00:08:29,599 --> 00:08:35,919
history continue in 2016

00:08:32,640 --> 00:08:37,440
the media tech vpu support was added

00:08:35,919 --> 00:08:41,200
mainline it was

00:08:37,440 --> 00:08:42,719
stateful and today state less support

00:08:41,200 --> 00:08:44,880
because they changed their

00:08:42,719 --> 00:08:48,640
firmware actually to be stateless and

00:08:44,880 --> 00:08:48,640
stateless support is being added

00:08:53,200 --> 00:08:57,839
and yeah not much more on the stateless

00:08:56,880 --> 00:09:01,920
side again

00:08:57,839 --> 00:09:04,000
in 2017 qualcomm venice support

00:09:01,920 --> 00:09:06,720
their own review was added with

00:09:04,000 --> 00:09:09,839
multitude of formats

00:09:06,720 --> 00:09:10,959
but on the stateless side upstream was

00:09:09,839 --> 00:09:14,000
pretty much stalled

00:09:10,959 --> 00:09:17,440
so there was a lot of issues

00:09:14,000 --> 00:09:20,880
uh well one was about

00:09:17,440 --> 00:09:23,680
naming so folks didn't agree if the api

00:09:20,880 --> 00:09:25,839
should be request api or job api

00:09:23,680 --> 00:09:28,560
and that went quite a couple of back and

00:09:25,839 --> 00:09:32,160
forth and that took a couple of months

00:09:28,560 --> 00:09:34,959
to decide but generally speaking

00:09:32,160 --> 00:09:35,600
the linux media community have had very

00:09:34,959 --> 00:09:38,720
low

00:09:35,600 --> 00:09:41,680
understanding of the codec actually

00:09:38,720 --> 00:09:42,320
and the mechanism behind the codex and

00:09:41,680 --> 00:09:44,720
we

00:09:42,320 --> 00:09:48,160
we had to train ourselves in order to

00:09:44,720 --> 00:09:51,519
properly review and finalize this work

00:09:48,160 --> 00:09:53,760
also most contributors uh had a very

00:09:51,519 --> 00:09:55,200
narrow view they only had one hardware

00:09:53,760 --> 00:09:56,720
to play with so they didn't know if

00:09:55,200 --> 00:09:59,040
their design was

00:09:56,720 --> 00:10:00,640
hardware specific or if it was going to

00:09:59,040 --> 00:10:02,880
work for multiple hardware

00:10:00,640 --> 00:10:05,839
because in v4l we're trying to make it

00:10:02,880 --> 00:10:05,839
make things generic

00:10:06,240 --> 00:10:09,360
and at the end of all this there was no

00:10:08,079 --> 00:10:12,640
specification

00:10:09,360 --> 00:10:14,000
not even for state state full decoders

00:10:12,640 --> 00:10:15,839
there was no specification no

00:10:14,000 --> 00:10:18,079
documentation of

00:10:15,839 --> 00:10:20,240
how driver should behave so there was a

00:10:18,079 --> 00:10:24,079
lot of differences between driver

00:10:20,240 --> 00:10:27,200
and incompatibilities between driver

00:10:24,079 --> 00:10:30,399
now things started moving again in 2018

00:10:27,200 --> 00:10:33,440
butlin managed to secure a kickstarter

00:10:30,399 --> 00:10:36,000
to finance actually the development of

00:10:33,440 --> 00:10:38,959
vcu support of decoder support on all

00:10:36,000 --> 00:10:38,959
winner chipset

00:10:39,600 --> 00:10:43,680
with their effort their request api was

00:10:42,160 --> 00:10:46,480
finalized

00:10:43,680 --> 00:10:48,240
they managed to land mpeg-2 support as a

00:10:46,480 --> 00:10:52,399
staging

00:10:48,240 --> 00:10:55,279
codex api into into linux for

00:10:52,399 --> 00:10:57,040
we and the sidras driver citrus is the

00:10:55,279 --> 00:11:01,839
name of the driver for all winner

00:10:57,040 --> 00:11:04,000
chipset they were working on h.264

00:11:01,839 --> 00:11:05,680
uh and they actually had to deal with

00:11:04,000 --> 00:11:08,880
the fact that it's slightly different it

00:11:05,680 --> 00:11:11,120
works per slice instead of per frame

00:11:08,880 --> 00:11:13,600
and at that time they were aiming for a

00:11:11,120 --> 00:11:14,320
va api driver to be compatible with what

00:11:13,600 --> 00:11:17,440
they do

00:11:14,320 --> 00:11:17,440
on the gpu side

00:11:18,399 --> 00:11:21,440
uh yeah the the crowdfunding had a lot

00:11:20,560 --> 00:11:25,279
of momentum

00:11:21,440 --> 00:11:27,200
they managed to get formal spec

00:11:25,279 --> 00:11:28,720
at the same time there was formal spec

00:11:27,200 --> 00:11:29,600
being finalized for the stateful

00:11:28,720 --> 00:11:32,320
decoders

00:11:29,600 --> 00:11:34,480
they managed to get formal uh spec for

00:11:32,320 --> 00:11:36,560
the stateless decoders

00:11:34,480 --> 00:11:38,800
to be merged so that was the core

00:11:36,560 --> 00:11:42,000
principle of a stateless decoder

00:11:38,800 --> 00:11:44,480
and then they they made more actually

00:11:42,000 --> 00:11:45,360
staging so unstable unexposed to the

00:11:44,480 --> 00:11:50,880
kernel headers

00:11:45,360 --> 00:11:50,880
api for h.264 vp8 hevc

00:11:51,360 --> 00:11:54,399
at the same time at collabora we managed

00:11:53,440 --> 00:11:57,440
to upstream

00:11:54,399 --> 00:12:00,480
the rk32 support with

00:11:57,440 --> 00:12:03,040
mbagg h.264 and vp8

00:12:00,480 --> 00:12:04,000
again all the codec api was unstable in

00:12:03,040 --> 00:12:07,600
staging

00:12:04,000 --> 00:12:10,800
back then in 2020

00:12:07,600 --> 00:12:13,600
things start moving a little bit more so

00:12:10,800 --> 00:12:14,320
on the gstreamer side we went ahead and

00:12:13,600 --> 00:12:17,600
implemented

00:12:14,320 --> 00:12:22,000
native support for the codec so we

00:12:17,600 --> 00:12:25,040
didn't need to use the va driver anymore

00:12:22,000 --> 00:12:27,680
and that gave us a lot more flexibility

00:12:25,040 --> 00:12:29,760
and allowed us actually to support some

00:12:27,680 --> 00:12:33,200
hardware specificities

00:12:29,760 --> 00:12:35,920
uh that wouldn't be possible through va

00:12:33,200 --> 00:12:36,720
and would have required uh some

00:12:35,920 --> 00:12:38,720
sub-optimal

00:12:36,720 --> 00:12:41,600
actually a thing to happen in the driver

00:12:38,720 --> 00:12:44,240
in the v8 driver

00:12:41,600 --> 00:12:45,839
so in parallel to that liberolec team

00:12:44,240 --> 00:12:47,760
actually was

00:12:45,839 --> 00:12:49,839
was doing the same in ffmpeg and they're

00:12:47,760 --> 00:12:53,120
still doing the same they're maintaining

00:12:49,839 --> 00:12:56,720
a native v4l request support

00:12:53,120 --> 00:12:59,920
for decoders there so

00:12:56,720 --> 00:13:00,959
in the end uh bootlen actually at the

00:12:59,920 --> 00:13:03,040
end of all this

00:13:00,959 --> 00:13:05,519
we wanted to demo this at the embedded

00:13:03,040 --> 00:13:06,000
world conference 2020 but it was

00:13:05,519 --> 00:13:09,200
cancelled

00:13:06,000 --> 00:13:11,360
due to the pandemic uh and butlin

00:13:09,200 --> 00:13:13,279
actually

00:13:11,360 --> 00:13:15,440
reached the end of the their their

00:13:13,279 --> 00:13:16,560
kickstarter i mean it was a success

00:13:15,440 --> 00:13:18,720
let's admit it

00:13:16,560 --> 00:13:20,079
but that was the end for them and they

00:13:18,720 --> 00:13:22,639
decided they would not

00:13:20,079 --> 00:13:24,639
maintain the va request driver anymore

00:13:22,639 --> 00:13:25,440
which made sense because we had native

00:13:24,639 --> 00:13:30,240
support

00:13:25,440 --> 00:13:31,839
in chromium ffmpeg and gstreamer

00:13:30,240 --> 00:13:34,160
now things didn't stop for us at

00:13:31,839 --> 00:13:36,880
collabora in 2021

00:13:34,160 --> 00:13:37,440
even though it's it's far from done yet

00:13:36,880 --> 00:13:40,399
uh

00:13:37,440 --> 00:13:41,440
we've been focusing on finalizing all

00:13:40,399 --> 00:13:45,680
these apis

00:13:41,440 --> 00:13:48,639
so in 5.11

00:13:45,680 --> 00:13:49,920
h.264 support was finally stable and

00:13:48,639 --> 00:13:53,040
exposed through the

00:13:49,920 --> 00:13:53,440
kernel headers so no more api change no

00:13:53,040 --> 00:13:56,000
more

00:13:53,440 --> 00:13:56,800
copying of headers from the internals of

00:13:56,000 --> 00:14:00,000
the

00:13:56,800 --> 00:14:01,920
of the kernel to make it work vp8

00:14:00,000 --> 00:14:03,680
has been accepted stable and should be

00:14:01,920 --> 00:14:06,079
in 513

00:14:03,680 --> 00:14:07,600
and we are actively working on

00:14:06,079 --> 00:14:11,360
stabilized stabilizing

00:14:07,600 --> 00:14:14,800
vp9 mpeg2 and hevc

00:14:11,360 --> 00:14:16,720
support one of the key

00:14:14,800 --> 00:14:17,920
thing that we change in our workflow is

00:14:16,720 --> 00:14:22,079
that we introduced

00:14:17,920 --> 00:14:24,160
a usage of fluster fluster is a

00:14:22,079 --> 00:14:26,320
very small actually test harness from

00:14:24,160 --> 00:14:29,279
fluendo

00:14:26,320 --> 00:14:30,320
that will run various conformance tests

00:14:29,279 --> 00:14:34,639
it currently support

00:14:30,320 --> 00:14:37,920
h.264 hevc and vp8 and vp9

00:14:34,639 --> 00:14:40,240
conformance test and that even though

00:14:37,920 --> 00:14:42,079
our codecs are not fully passing those

00:14:40,240 --> 00:14:44,880
tests that gives us a

00:14:42,079 --> 00:14:45,760
very very good insight on possible

00:14:44,880 --> 00:14:49,279
regression

00:14:45,760 --> 00:14:50,639
and on the quality of the codex as for

00:14:49,279 --> 00:14:53,839
encoder support there

00:14:50,639 --> 00:14:56,320
has been a bit of discussion but this

00:14:53,839 --> 00:14:58,880
is quite on hold encoders is a big

00:14:56,320 --> 00:15:01,680
subject so it will have to be dealt

00:14:58,880 --> 00:15:02,079
separately now what does it serve all

00:15:01,680 --> 00:15:05,680
this

00:15:02,079 --> 00:15:08,480
well it serves of course

00:15:05,680 --> 00:15:08,959
chromebooks to make them more mainline

00:15:08,480 --> 00:15:11,920
more

00:15:08,959 --> 00:15:14,079
generic linux running device it helps

00:15:11,920 --> 00:15:14,639
vendor because now they have an api to

00:15:14,079 --> 00:15:17,920
implement

00:15:14,639 --> 00:15:19,519
when they want to support this but it

00:15:17,920 --> 00:15:23,760
also helps the community

00:15:19,519 --> 00:15:26,639
notably the mnt reform which is a imx8m

00:15:23,760 --> 00:15:28,560
based laptop which has a hand roll very

00:15:26,639 --> 00:15:32,040
silicon decoder

00:15:28,560 --> 00:15:33,279
the pine book the pine book pro which is

00:15:32,040 --> 00:15:36,720
rk3399

00:15:33,279 --> 00:15:39,279
the pine phone which is a null winner

00:15:36,720 --> 00:15:42,880
with citrus the libra and prism and so

00:15:39,279 --> 00:15:46,160
on and so on there's many sbcs tv boxes

00:15:42,880 --> 00:15:49,040
and everything and

00:15:46,160 --> 00:15:50,160
and this is it it helps getting better

00:15:49,040 --> 00:15:53,360
codec support

00:15:50,160 --> 00:15:56,399
and these codecs are also very flexible

00:15:53,360 --> 00:15:59,199
now let's go for a little demo

00:15:56,399 --> 00:16:00,639
i've booted a board from libra computer

00:15:59,199 --> 00:16:04,800
called the tritium

00:16:00,639 --> 00:16:09,600
it's actually running a an all winner h3

00:16:04,800 --> 00:16:12,959
and we'll be demoing g-streamer

00:16:09,600 --> 00:16:15,360
codec on that so let me first

00:16:12,959 --> 00:16:15,360
log in

00:16:17,600 --> 00:16:24,880
so this is running the latest kernel so

00:16:21,600 --> 00:16:28,079
rc one so we're going to demo

00:16:24,880 --> 00:16:31,759
the stable h264 support

00:16:28,079 --> 00:16:32,560
in the linux kernel and uh to do so i'm

00:16:31,759 --> 00:16:36,399
gonna use

00:16:32,560 --> 00:16:39,120
a g streamer so let's load the latest

00:16:36,399 --> 00:16:41,600
streamer because you need gstreamer from

00:16:39,120 --> 00:16:41,600
master

00:16:42,959 --> 00:16:46,720
so that little command actually loads

00:16:45,440 --> 00:16:49,120
the environment

00:16:46,720 --> 00:16:50,959
in order to after this rumor has been

00:16:49,120 --> 00:16:52,000
built to run the code in place without

00:16:50,959 --> 00:16:54,800
having to

00:16:52,000 --> 00:16:54,800
to install it

00:16:55,120 --> 00:17:00,720
that's it and then let's try gst play

00:17:03,839 --> 00:17:06,240
whoops

00:17:06,959 --> 00:17:09,600
gst

00:17:10,959 --> 00:17:15,679
voila so we're going to do g to use gst

00:17:14,160 --> 00:17:16,160
play which is a small command line

00:17:15,679 --> 00:17:19,439
player

00:17:16,160 --> 00:17:20,959
in gstreamer and i'm using play bin 3

00:17:19,439 --> 00:17:23,600
hopefully it's going to be the default

00:17:20,959 --> 00:17:23,600
in the future

00:17:23,679 --> 00:17:30,480
uh as as we we rely

00:17:27,360 --> 00:17:32,320
on on playband3 for to

00:17:30,480 --> 00:17:33,679
to fix actually format negotiation it's

00:17:32,320 --> 00:17:39,520
a detail

00:17:33,679 --> 00:17:39,520
and let's play some big bug bunny

00:17:40,320 --> 00:17:48,240
underscore of course

00:17:44,960 --> 00:17:51,520
and let's remove this

00:17:48,240 --> 00:17:53,520
you don't need that voila and i'm using

00:17:51,520 --> 00:17:56,240
kms sync so it's going to be

00:17:53,520 --> 00:17:58,720
straight to the display hardware

00:17:56,240 --> 00:17:58,720
playback

00:17:59,600 --> 00:18:06,480
there we go it's negotiating voila

00:18:02,799 --> 00:18:09,760
so now we're playing big bug bunny

00:18:06,480 --> 00:18:13,120
the usual movie uh seek is of course

00:18:09,760 --> 00:18:16,160
supported so you can move in your stream

00:18:13,120 --> 00:18:19,360
you can pause you can see you can pause

00:18:16,160 --> 00:18:21,760
that's not an issue uh

00:18:19,360 --> 00:18:23,919
i haven't implemented reverse playback

00:18:21,760 --> 00:18:26,840
yet that's in my to-do

00:18:23,919 --> 00:18:28,720
but that should also work with stateless

00:18:26,840 --> 00:18:32,480
codex

00:18:28,720 --> 00:18:35,120
hey voila so thanks for watching

00:18:32,480 --> 00:18:36,799
i'll be around this is pre-recorded

00:18:35,120 --> 00:18:38,960
session but i'll be around

00:18:36,799 --> 00:18:40,000
for a couple of minutes to take your

00:18:38,960 --> 00:18:42,880
questions

00:18:40,000 --> 00:18:44,160
and try to answer them thank you very

00:18:42,880 --> 00:18:57,840
much for attending

00:18:44,160 --> 00:18:57,840
have a good conference

00:19:01,080 --> 00:19:08,000
[Music]

00:19:16,559 --> 00:19:18,640

YouTube URL: https://www.youtube.com/watch?v=nQ9c--ByZfI


