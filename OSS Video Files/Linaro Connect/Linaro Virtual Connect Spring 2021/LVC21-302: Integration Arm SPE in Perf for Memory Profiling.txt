Title: LVC21-302: Integration Arm SPE in Perf for Memory Profiling
Publication date: 2021-04-15
Playlist: Linaro Virtual Connect Spring 2021
Description: 
	This is a brief introduction for what's the current status for integration Arm SPE into Perf tool, and will demonstrate examples for using Perf tool for memory profiling on Arm platform. It will summarize the known issues and what's the next step.
Captions: 
	00:00:01,839 --> 00:00:05,759
hello everyone

00:00:03,040 --> 00:00:07,120
thank you for coming in this session we

00:00:05,759 --> 00:00:09,920
will discuss about

00:00:07,120 --> 00:00:11,200
integration mspe imperf for memory

00:00:09,920 --> 00:00:14,080
profiling

00:00:11,200 --> 00:00:15,040
i am neo yen working for nilaro support

00:00:14,080 --> 00:00:19,279
and the solution

00:00:15,040 --> 00:00:22,480
engineering team first of all

00:00:19,279 --> 00:00:26,080
give some introduction for mspe

00:00:22,480 --> 00:00:27,439
rmsb stands for statistical profiling

00:00:26,080 --> 00:00:31,039
extension

00:00:27,439 --> 00:00:35,040
which is defined in arm v8 application

00:00:31,039 --> 00:00:38,239
architecture in this

00:00:35,040 --> 00:00:42,840
menu is defined start from

00:00:38,239 --> 00:00:46,480
v 8.2 to support i mean

00:00:42,840 --> 00:00:49,600
spe msp provides a hardware based

00:00:46,480 --> 00:00:50,960
sampling for cpus the operations for

00:00:49,600 --> 00:00:54,239
example it can

00:00:50,960 --> 00:00:55,039
record the operations for branch memory

00:00:54,239 --> 00:00:58,399
exception

00:00:55,039 --> 00:01:00,719
sve it also can capture the

00:00:58,399 --> 00:01:03,680
associated information for performing

00:01:00,719 --> 00:01:07,280
like the pc venue data stress

00:01:03,680 --> 00:01:09,760
even the type time step to avoid

00:01:07,280 --> 00:01:11,200
permanent overhead caused by the

00:01:09,760 --> 00:01:14,479
hardware tracing

00:01:11,200 --> 00:01:16,880
rmsp use statistic approach so

00:01:14,479 --> 00:01:18,560
for example it can specify the interview

00:01:16,880 --> 00:01:22,960
or the random interview

00:01:18,560 --> 00:01:27,200
for recording and it can use the filter

00:01:22,960 --> 00:01:29,600
to specify the tracing criteria

00:01:27,200 --> 00:01:31,280
this session gives introduction for

00:01:29,600 --> 00:01:35,439
linux support for msp

00:01:31,280 --> 00:01:36,640
with prof2 so today's agenda we divide

00:01:35,439 --> 00:01:39,600
into three parts

00:01:36,640 --> 00:01:40,000
the first part we will explain why we

00:01:39,600 --> 00:01:42,479
need

00:01:40,000 --> 00:01:43,200
rmsb the second part we will quickly go

00:01:42,479 --> 00:01:45,920
through

00:01:43,200 --> 00:01:47,040
rmsb hardware mechanism the third part

00:01:45,920 --> 00:01:49,920
we were to

00:01:47,040 --> 00:01:52,560
update the seaters for integration msp

00:01:49,920 --> 00:01:52,560
with perth

00:01:52,720 --> 00:01:58,000
let's first see first thing to see what

00:01:55,520 --> 00:02:01,680
is mist from the standard pmu

00:01:58,000 --> 00:02:03,200
event if we use the pmu event for memory

00:02:01,680 --> 00:02:06,159
profiling

00:02:03,200 --> 00:02:07,680
we can use the cache references or cache

00:02:06,159 --> 00:02:10,239
misses

00:02:07,680 --> 00:02:12,319
this kind of the event can help us to

00:02:10,239 --> 00:02:13,680
quickly need to look at which code piece

00:02:12,319 --> 00:02:16,319
is hotspot

00:02:13,680 --> 00:02:16,959
for memory operation so for example on

00:02:16,319 --> 00:02:19,840
the right side

00:02:16,959 --> 00:02:20,879
we can see that it can use the perf

00:02:19,840 --> 00:02:24,239
annotation

00:02:20,879 --> 00:02:28,560
method to connect the source code

00:02:24,239 --> 00:02:32,319
with the memory accessing so we can know

00:02:28,560 --> 00:02:33,440
which code piece uh have is hotspot for

00:02:32,319 --> 00:02:36,560
memory

00:02:33,440 --> 00:02:38,239
but it cannot still provide the further

00:02:36,560 --> 00:02:40,560
more information

00:02:38,239 --> 00:02:42,560
for the memory accessing for example

00:02:40,560 --> 00:02:45,599
which catch net mode

00:02:42,560 --> 00:02:48,840
if we have any accessing for remote

00:02:45,599 --> 00:02:50,480
nodes or if there have any trb

00:02:48,840 --> 00:02:53,360
operations so this

00:02:50,480 --> 00:02:54,160
will be very hard for the developer to

00:02:53,360 --> 00:02:56,720
optimize

00:02:54,160 --> 00:02:56,720
the memory

00:02:59,280 --> 00:03:07,040
on x86 it have provides

00:03:04,239 --> 00:03:07,280
actual the hardware events memory nodes

00:03:07,040 --> 00:03:10,080
and

00:03:07,280 --> 00:03:12,319
memory stores for the memory profiling

00:03:10,080 --> 00:03:14,959
so this is why the in the profile 2

00:03:12,319 --> 00:03:18,319
it provides a perf memory code and proof

00:03:14,959 --> 00:03:22,239
memory port for the memory profiling

00:03:18,319 --> 00:03:25,440
for the mem records it can spotify the

00:03:22,239 --> 00:03:26,239
event node or store you can either use

00:03:25,440 --> 00:03:29,599
the underlying

00:03:26,239 --> 00:03:31,760
hardware event for the memory profiling

00:03:29,599 --> 00:03:33,840
but here the problem is that for amp

00:03:31,760 --> 00:03:36,400
platform is that

00:03:33,840 --> 00:03:37,760
um cpu standard support this kind of

00:03:36,400 --> 00:03:40,480
hardware memory event

00:03:37,760 --> 00:03:42,080
so this is why we want to explore mspe

00:03:40,480 --> 00:03:46,400
for memory profiling on

00:03:42,080 --> 00:03:49,519
platforms so let's uh

00:03:46,400 --> 00:03:51,200
quickly go through the rms pe hardware

00:03:49,519 --> 00:03:53,760
mechanism

00:03:51,200 --> 00:03:55,040
rmsp divide into four stages in the

00:03:53,760 --> 00:03:58,799
first stage it

00:03:55,040 --> 00:04:01,120
is samples population it will do

00:03:58,799 --> 00:04:02,159
based on the specified exception level

00:04:01,120 --> 00:04:05,360
and the inter

00:04:02,159 --> 00:04:06,000
view for the sample when the sample is

00:04:05,360 --> 00:04:08,640
taken

00:04:06,000 --> 00:04:09,280
it will to gather information for the pc

00:04:08,640 --> 00:04:13,040
value

00:04:09,280 --> 00:04:15,439
for events type timing

00:04:13,040 --> 00:04:16,959
data address for the physical address

00:04:15,439 --> 00:04:19,600
and the virtual address

00:04:16,959 --> 00:04:20,799
and for the operation type in the filter

00:04:19,600 --> 00:04:24,479
it can to fill

00:04:20,799 --> 00:04:27,280
out the in interested

00:04:24,479 --> 00:04:28,160
the operations so it's based on the

00:04:27,280 --> 00:04:30,800
operation type

00:04:28,160 --> 00:04:31,600
even the type and the latency finally

00:04:30,800 --> 00:04:34,720
the

00:04:31,600 --> 00:04:37,280
record will be saved in the buffer with

00:04:34,720 --> 00:04:37,280
the package

00:04:37,520 --> 00:04:44,160
here want to give out a direct

00:04:41,040 --> 00:04:46,479
directive view for the package

00:04:44,160 --> 00:04:47,440
formats we can use the perfect report

00:04:46,479 --> 00:04:50,639
dash

00:04:47,440 --> 00:04:52,560
capital d to download the raw data

00:04:50,639 --> 00:04:54,000
it can give out for example the address

00:04:52,560 --> 00:04:56,800
package

00:04:54,000 --> 00:04:57,360
address package unit give out the three

00:04:56,800 --> 00:04:59,919
different

00:04:57,360 --> 00:05:00,960
address one in the pc venue means that

00:04:59,919 --> 00:05:04,080
which the

00:05:00,960 --> 00:05:07,039
code is running and it give out to the

00:05:04,080 --> 00:05:07,919
virtual data address and the physical

00:05:07,039 --> 00:05:11,440
address

00:05:07,919 --> 00:05:14,000
the information so this will be very

00:05:11,440 --> 00:05:15,600
friendly for memory profiling the

00:05:14,000 --> 00:05:16,400
counter packet that it will give out to

00:05:15,600 --> 00:05:19,039
the like the

00:05:16,400 --> 00:05:19,680
latency even the packet here it will

00:05:19,039 --> 00:05:21,919
give out

00:05:19,680 --> 00:05:23,440
the information for the memory hierarchy

00:05:21,919 --> 00:05:26,960
for example it were to give out

00:05:23,440 --> 00:05:29,680
the l1 cache or the next level cache

00:05:26,960 --> 00:05:31,840
and trb and the remote access the

00:05:29,680 --> 00:05:34,080
information

00:05:31,840 --> 00:05:35,840
operation type packet is where to give

00:05:34,080 --> 00:05:37,759
out the

00:05:35,840 --> 00:05:39,440
memory for example the memory operation

00:05:37,759 --> 00:05:42,720
is the store or

00:05:39,440 --> 00:05:44,000
note the padding package is where to for

00:05:42,720 --> 00:05:48,320
the alignment

00:05:44,000 --> 00:05:48,320
context package here will give out the

00:05:48,880 --> 00:05:52,880
piece right or process context related

00:05:51,680 --> 00:05:55,520
information

00:05:52,880 --> 00:05:56,720
time step package it worked to give out

00:05:55,520 --> 00:05:59,759
the time step

00:05:56,720 --> 00:06:02,720
coming from the arm architecture arm

00:05:59,759 --> 00:06:04,560
occu timer the counter as we know that

00:06:02,720 --> 00:06:08,319
the nini's color also use the arm

00:06:04,560 --> 00:06:10,240
up timer counter so we can

00:06:08,319 --> 00:06:12,080
based on the time step to do the

00:06:10,240 --> 00:06:14,319
correlation between the

00:06:12,080 --> 00:06:15,600
speed trace data with the ninth colors

00:06:14,319 --> 00:06:18,400
the software

00:06:15,600 --> 00:06:19,520
the twist data so this can give more

00:06:18,400 --> 00:06:22,479
extension

00:06:19,520 --> 00:06:24,479
for the profiling the national package

00:06:22,479 --> 00:06:27,919
is data source package

00:06:24,479 --> 00:06:30,160
data suspect is not standard format

00:06:27,919 --> 00:06:30,960
it's implementation dependent this means

00:06:30,160 --> 00:06:34,400
that

00:06:30,960 --> 00:06:36,960
different soc vendors can define its own

00:06:34,400 --> 00:06:37,520
data source format so this one part

00:06:36,960 --> 00:06:41,520
actually

00:06:37,520 --> 00:06:45,600
now we have a lot implemented we need to

00:06:41,520 --> 00:06:48,960
we can extend this later based on the

00:06:45,600 --> 00:06:53,120
soc support

00:06:48,960 --> 00:06:55,520
so let's see current status for uh

00:06:53,120 --> 00:06:57,440
the perf2 support for msb the first

00:06:55,520 --> 00:06:59,840
thing we need to enable prof memory

00:06:57,440 --> 00:07:03,039
events for msb

00:06:59,840 --> 00:07:06,400
because that

00:07:03,039 --> 00:07:09,599
we have no the so here we need to bind

00:07:06,400 --> 00:07:13,919
msp hardware unt with the mem

00:07:09,599 --> 00:07:17,199
perf memory memory to the even the type

00:07:13,919 --> 00:07:20,560
so for the nodes uh type even the type

00:07:17,199 --> 00:07:22,400
we need to bind for the msp with enable

00:07:20,560 --> 00:07:25,039
the filter for loading

00:07:22,400 --> 00:07:26,560
node operations for store here we use

00:07:25,039 --> 00:07:29,520
the reversed

00:07:26,560 --> 00:07:31,759
operation configuration it enables the

00:07:29,520 --> 00:07:33,120
store filter and disabled filter for

00:07:31,759 --> 00:07:34,880
nodes

00:07:33,120 --> 00:07:36,639
if we enable for the node and store

00:07:34,880 --> 00:07:37,919
operation here we need to enable the

00:07:36,639 --> 00:07:40,800
filter for both

00:07:37,919 --> 00:07:41,520
node and store if we in the command if

00:07:40,800 --> 00:07:44,720
it did

00:07:41,520 --> 00:07:45,599
it down the spice specify anything even

00:07:44,720 --> 00:07:48,639
the type

00:07:45,599 --> 00:07:51,840
by default it also needs to invoke both

00:07:48,639 --> 00:07:54,560
node and store operations

00:07:51,840 --> 00:07:56,000
after we cap we enable the event and we

00:07:54,560 --> 00:07:58,639
can capture the tricks data

00:07:56,000 --> 00:07:59,280
then we need to report the tricks data

00:07:58,639 --> 00:08:02,400
so

00:07:59,280 --> 00:08:05,199
here we need to based on the

00:08:02,400 --> 00:08:06,160
rmsp the trace data to do the decoding

00:08:05,199 --> 00:08:10,720
for the package

00:08:06,160 --> 00:08:13,280
and to synthesize the memory samples

00:08:10,720 --> 00:08:14,240
based on the package so in the memory

00:08:13,280 --> 00:08:16,319
samples you

00:08:14,240 --> 00:08:17,280
need to provide for example the event

00:08:16,319 --> 00:08:20,800
type id

00:08:17,280 --> 00:08:25,120
pid physical address

00:08:20,800 --> 00:08:28,240
virtual address and another important

00:08:25,120 --> 00:08:31,520
seeing you the data source data source

00:08:28,240 --> 00:08:34,800
is defined in the profile 2

00:08:31,520 --> 00:08:37,839
the format is the format is not same

00:08:34,800 --> 00:08:42,399
we cannot directly to use the

00:08:37,839 --> 00:08:45,279
mspe the the information we need to map

00:08:42,399 --> 00:08:46,240
the msp the information to the data

00:08:45,279 --> 00:08:49,680
source formats

00:08:46,240 --> 00:08:50,240
defined in the proper tool as i know

00:08:49,680 --> 00:08:53,200
that

00:08:50,240 --> 00:08:55,000
the data source format is quite a

00:08:53,200 --> 00:08:58,160
binding to

00:08:55,000 --> 00:09:02,320
x86 the uh

00:08:58,160 --> 00:09:05,440
memory uh uh tracing data

00:09:02,320 --> 00:09:06,399
for the from a data source for mats so

00:09:05,440 --> 00:09:08,640
here when you

00:09:06,399 --> 00:09:10,000
they have great gap with msp when

00:09:08,640 --> 00:09:12,080
youtube converts

00:09:10,000 --> 00:09:13,839
so we can see in this code in the

00:09:12,080 --> 00:09:15,600
midnight color we need to set the

00:09:13,839 --> 00:09:18,000
operation type

00:09:15,600 --> 00:09:18,640
also need to set the memory hierarchy

00:09:18,000 --> 00:09:21,760
level

00:09:18,640 --> 00:09:25,040
for example if it's a nest level cache

00:09:21,760 --> 00:09:27,760
event then we can set for the l3

00:09:25,040 --> 00:09:29,120
cache this is follow up the convention

00:09:27,760 --> 00:09:32,399
with the x

00:09:29,120 --> 00:09:35,519
86 if they have low error

00:09:32,399 --> 00:09:38,480
less level cache the event

00:09:35,519 --> 00:09:39,120
information then we can set for the l1

00:09:38,480 --> 00:09:42,240
cache

00:09:39,120 --> 00:09:43,279
related information we also need to set

00:09:42,240 --> 00:09:46,560
the cache is hit

00:09:43,279 --> 00:09:50,399
or miss remote access and also set

00:09:46,560 --> 00:09:52,640
for the trp you review the information

00:09:50,399 --> 00:09:54,399
so based on this information we can

00:09:52,640 --> 00:09:56,800
quickly need to get out

00:09:54,399 --> 00:09:58,080
get out some of the perfect report

00:09:56,800 --> 00:10:01,760
memory reports

00:09:58,080 --> 00:10:03,519
it can output the memory attribution so

00:10:01,760 --> 00:10:07,519
for example here it can

00:10:03,519 --> 00:10:10,800
give out the overhead introduced by

00:10:07,519 --> 00:10:14,160
one data address then

00:10:10,800 --> 00:10:16,959
where to give out for the data address

00:10:14,160 --> 00:10:17,279
what's the memory access tab and which

00:10:16,959 --> 00:10:20,800
is

00:10:17,279 --> 00:10:24,320
pthread to cause the

00:10:20,800 --> 00:10:28,160
overheads and the for the

00:10:24,320 --> 00:10:33,040
data simple here it also can give out

00:10:28,160 --> 00:10:35,760
which data structure uh introduce the

00:10:33,040 --> 00:10:37,440
data structure and offsite introduce the

00:10:35,760 --> 00:10:42,240
overhead

00:10:37,440 --> 00:10:44,720
so this is very directly to review the

00:10:42,240 --> 00:10:46,320
memory access introduced for the global

00:10:44,720 --> 00:10:49,680
data structure

00:10:46,320 --> 00:10:53,040
we also can see if they have some of the

00:10:49,680 --> 00:10:57,040
uh only have the

00:10:53,040 --> 00:11:00,240
address but they don't have display the

00:10:57,040 --> 00:11:03,120
data simple for this case that the data

00:11:00,240 --> 00:11:06,160
is allocated dynamic from the buffer

00:11:03,120 --> 00:11:09,920
so we need to use connect with other

00:11:06,160 --> 00:11:15,440
pmu events to locate

00:11:09,920 --> 00:11:19,440
the data structure

00:11:15,440 --> 00:11:22,079
so perfect2 also provides another

00:11:19,440 --> 00:11:23,680
supper command is perfect c2c purpose

00:11:22,079 --> 00:11:26,800
c2c

00:11:23,680 --> 00:11:28,079
stands for cache to cache it want to

00:11:26,800 --> 00:11:30,720
capture the

00:11:28,079 --> 00:11:32,160
cache for sharing scenario for example

00:11:30,720 --> 00:11:35,680
they have two threads

00:11:32,160 --> 00:11:39,680
two threads run on different cpus

00:11:35,680 --> 00:11:41,839
one thread read the data

00:11:39,680 --> 00:11:44,480
in one cache line and another thread

00:11:41,839 --> 00:11:49,440
write the data in the same cache line

00:11:44,480 --> 00:11:49,440
so in this case if these two threads

00:11:50,000 --> 00:11:56,560
execute at the same time then it will to

00:11:53,680 --> 00:11:57,200
introduce the cache concurrency on the

00:11:56,560 --> 00:12:00,320
fabric

00:11:57,200 --> 00:12:03,519
so it where to introduce the sloping

00:12:00,320 --> 00:12:07,200
operations and where to cause the

00:12:03,519 --> 00:12:09,760
cpus pipeline uh the efficiency and

00:12:07,200 --> 00:12:11,440
the performance downgrading so professor

00:12:09,760 --> 00:12:14,720
ducey wanted to capture

00:12:11,440 --> 00:12:18,399
which catchy line has been for shared

00:12:14,720 --> 00:12:22,480
by multiple stride on

00:12:18,399 --> 00:12:26,560
x86 platform is based on the

00:12:22,480 --> 00:12:29,600
memory event the htm

00:12:26,560 --> 00:12:33,200
text so this is a hardware tag

00:12:29,600 --> 00:12:37,600
can directly to indicate that which

00:12:33,200 --> 00:12:40,880
memory access for a

00:12:37,600 --> 00:12:44,000
a modified copy in the cache

00:12:40,880 --> 00:12:46,800
so this even the create hditm

00:12:44,000 --> 00:12:47,519
tag means that they have the force

00:12:46,800 --> 00:12:50,839
sharing

00:12:47,519 --> 00:12:54,240
so it's very directive to use the

00:12:50,839 --> 00:12:58,959
hitm tag so they have two views

00:12:54,240 --> 00:13:02,160
the two tables one table is based on the

00:12:58,959 --> 00:13:04,160
cache line to organize so we can see

00:13:02,160 --> 00:13:06,959
here have one cache line

00:13:04,160 --> 00:13:07,760
then based on it water you to introduce

00:13:06,959 --> 00:13:11,680
the

00:13:07,760 --> 00:13:14,720
uh htm and the

00:13:11,680 --> 00:13:15,839
the following film fields is the

00:13:14,720 --> 00:13:19,600
breakdown for

00:13:15,839 --> 00:13:23,279
different operations

00:13:19,600 --> 00:13:26,639
if we press d it can divide

00:13:23,279 --> 00:13:29,279
it can give out the distribution table

00:13:26,639 --> 00:13:30,240
so here it is based on the single the

00:13:29,279 --> 00:13:32,399
cache line

00:13:30,240 --> 00:13:34,320
it's going to give um i'll give out more

00:13:32,399 --> 00:13:39,120
detailed information for

00:13:34,320 --> 00:13:42,160
htm and for store references

00:13:39,120 --> 00:13:46,399
for the different the

00:13:42,160 --> 00:13:51,680
source code 9. so

00:13:46,399 --> 00:13:55,120
this this is usage for on x86

00:13:51,680 --> 00:13:58,560
but for professor qc with mspe

00:13:55,120 --> 00:14:02,800
it give out empty the result

00:13:58,560 --> 00:14:06,480
the reason is that msp does support hitm

00:14:02,800 --> 00:14:10,560
attack for this reason

00:14:06,480 --> 00:14:12,320
we did this experiment for perfect c2c

00:14:10,560 --> 00:14:16,720
to extend it

00:14:12,320 --> 00:14:19,920
the operation with the dashido

00:14:16,720 --> 00:14:23,279
c d o here means that we don't want to

00:14:19,920 --> 00:14:26,480
rely on the h i t m the tag

00:14:23,279 --> 00:14:27,040
for the sorting or the profiling we want

00:14:26,480 --> 00:14:30,079
to

00:14:27,040 --> 00:14:33,360
display the date

00:14:30,079 --> 00:14:36,639
samples based on the all

00:14:33,360 --> 00:14:39,760
uh node heat operations

00:14:36,639 --> 00:14:44,720
so means that all the uh

00:14:39,760 --> 00:14:48,639
rate in any the cash level we will be

00:14:44,720 --> 00:14:52,959
sorted will be sorted so the basic idea

00:14:48,639 --> 00:14:56,079
is that we want you this way to display

00:14:52,959 --> 00:14:57,519
all the node and store operations for

00:14:56,079 --> 00:15:00,639
the multi-threading

00:14:57,519 --> 00:15:02,720
if there have some strides to use

00:15:00,639 --> 00:15:05,600
node height and the same thread you

00:15:02,720 --> 00:15:09,519
store for the sim caching

00:15:05,600 --> 00:15:12,800
then we can see the in the

00:15:09,519 --> 00:15:13,920
in the table there must be some one

00:15:12,800 --> 00:15:18,639
cache line

00:15:13,920 --> 00:15:20,880
be accessed by the multiple slides it is

00:15:18,639 --> 00:15:22,320
by the multiple slide so this can give

00:15:20,880 --> 00:15:25,199
us the hint

00:15:22,320 --> 00:15:25,519
that it's possible that the cache line

00:15:25,199 --> 00:15:28,959
had

00:15:25,519 --> 00:15:32,399
been force shared so we can see

00:15:28,959 --> 00:15:36,000
after change we can see it display

00:15:32,399 --> 00:15:39,600
the cache lines and the order

00:15:36,000 --> 00:15:42,880
by the node rate

00:15:39,600 --> 00:15:42,880
the statistic

00:15:45,360 --> 00:15:49,120
in the distribution the table we

00:15:48,320 --> 00:15:51,680
expected

00:15:49,120 --> 00:15:52,720
that it were to display the node

00:15:51,680 --> 00:15:56,000
references

00:15:52,720 --> 00:15:57,440
and the store references and come from

00:15:56,000 --> 00:16:00,639
different

00:15:57,440 --> 00:16:03,839
threads so basically this

00:16:00,639 --> 00:16:07,839
gives us the idea what we want to do but

00:16:03,839 --> 00:16:11,120
here the issue is that for the store

00:16:07,839 --> 00:16:12,720
mspe doesn't give out any memory

00:16:11,120 --> 00:16:14,800
hierarchy information

00:16:12,720 --> 00:16:16,079
this is because that we found that in

00:16:14,800 --> 00:16:18,480
its packet

00:16:16,079 --> 00:16:20,639
it doesn't give any information for this

00:16:18,480 --> 00:16:24,079
so we can see there have no samples

00:16:20,639 --> 00:16:26,240
for stored references this is also the

00:16:24,079 --> 00:16:28,800
reason that we found this

00:16:26,240 --> 00:16:28,800
hardware

00:16:30,160 --> 00:16:36,000
issue so the patch set is hold on have

00:16:34,079 --> 00:16:39,680
not been merged into the midnight

00:16:36,000 --> 00:16:43,759
color so give some quick

00:16:39,680 --> 00:16:44,079
recap rmsp has been enabled with prof2

00:16:43,759 --> 00:16:47,360
with

00:16:44,079 --> 00:16:49,519
for below support command profile record

00:16:47,360 --> 00:16:53,040
perfect report per

00:16:49,519 --> 00:16:56,720
perform memory code perform memory port

00:16:53,040 --> 00:16:59,920
for rmspe now

00:16:56,720 --> 00:17:03,120
prof c2c has not yet supported for msp

00:16:59,920 --> 00:17:06,880
on binance the patch set has been

00:17:03,120 --> 00:17:09,199
sent out for the public review but

00:17:06,880 --> 00:17:10,000
because just now we mentioned the

00:17:09,199 --> 00:17:13,520
hardware

00:17:10,000 --> 00:17:15,280
store references issue so the publicity

00:17:13,520 --> 00:17:18,319
you see patch set has

00:17:15,280 --> 00:17:19,679
not hold on had not been merged in

00:17:18,319 --> 00:17:23,439
minneapolis

00:17:19,679 --> 00:17:26,160
another thing that for the pid tracing

00:17:23,439 --> 00:17:27,280
not only support the root name space for

00:17:26,160 --> 00:17:30,320
msbe

00:17:27,280 --> 00:17:31,520
the reason is that rmsp used context idr

00:17:30,320 --> 00:17:35,679
year 1 er2

00:17:31,520 --> 00:17:39,760
for pid tracing this is the system

00:17:35,679 --> 00:17:39,760
wide the register so

00:17:39,840 --> 00:17:45,679
we cannot unique the root the name

00:17:43,200 --> 00:17:47,440
space the pid information for non-root

00:17:45,679 --> 00:17:50,559
name space

00:17:47,440 --> 00:17:53,840
so for this reason for

00:17:50,559 --> 00:17:56,640
the simple solution now we just

00:17:53,840 --> 00:17:59,200
only can support the root name space we

00:17:56,640 --> 00:18:01,600
don't we cannot support this for the

00:17:59,200 --> 00:18:04,640
nine route name space the tracing for

00:18:01,600 --> 00:18:04,640
the pid

00:18:05,200 --> 00:18:11,679
okay at the last i'd like to

00:18:08,320 --> 00:18:14,960
appreciate uh for er grant hojin

00:18:11,679 --> 00:18:16,799
james mike williams

00:18:14,960 --> 00:18:18,320
for the development and for the

00:18:16,799 --> 00:18:21,200
suggestion

00:18:18,320 --> 00:18:21,200
for the development

00:18:22,720 --> 00:18:29,840
okay also thank you for coming for this

00:18:26,840 --> 00:18:29,840

YouTube URL: https://www.youtube.com/watch?v=VJbLqKoKWzQ


