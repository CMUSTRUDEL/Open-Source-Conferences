Title: LVC21-219 Enabling Collaborative Processor Performance Control CPPC on Arm Platforms
Publication date: 2021-04-15
Playlist: Linaro Virtual Connect Spring 2021
Description: 
	Collaborative Processor Performance Control (CPPC) defined in the ACPI spec describes a mechanism for the OS to manage the performance of the processor core on a contiguous and abstract performance scale.

This talk focuses on enabling CPPC support on Arm architecture based platforms that support architected Activity Monitor Unit (AMU). Key takeaways for audience include introduction of SCMI Fastchannels, AMU counters, AMU interfaced as a Function Fixed Hardware (FFH), using fastchannel as the communication medium with platform firmware for requesting desired performance and using the AMU counter values to calculate the CPU operating frequency. An implementation of CPPC allows OS to request the firmware for the desired performance level and allows monitoring of the CPU performance. The OS request to firmware involves the use of non-secure SCMI FastChannel (a memory mapped channel between the OS and platform firmware). The monitoring of the CPU performance involves the use of architected AMU counters (the CPU frequency counter and the constant frequency counter of the AMU).

This session discuss all the aspects related to enabling CPPC support on an Arm platform and uses Armâ€™s Neoverse Reference Design (RD) platform as an example.
Captions: 
	00:00:03,199 --> 00:00:06,879
welcome everyone

00:00:04,960 --> 00:00:08,559
this is a discussion on collaborative

00:00:06,879 --> 00:00:12,480
browser performance control

00:00:08,559 --> 00:00:14,559
or cppc as applied to arm platform

00:00:12,480 --> 00:00:16,320
cppc is a mechanism for os to

00:00:14,559 --> 00:00:19,600
collaborate with platform firmware

00:00:16,320 --> 00:00:22,400
to manage the performance of a processor

00:00:19,600 --> 00:00:23,119
this discussion focus on army 8.4 system

00:00:22,400 --> 00:00:27,119
onwards

00:00:23,119 --> 00:00:29,519
which has the architected amu counters

00:00:27,119 --> 00:00:30,720
a quick introduction about myself i am

00:00:29,519 --> 00:00:32,320
pranav madu

00:00:30,720 --> 00:00:33,920
software engineer in the open source

00:00:32,320 --> 00:00:35,920
group at arm

00:00:33,920 --> 00:00:37,600
my major focus has been on enabling

00:00:35,920 --> 00:00:40,879
power management functionality

00:00:37,600 --> 00:00:40,879
for neos platforms

00:00:42,079 --> 00:00:45,440
in the next 20 minutes i'll be talking

00:00:44,239 --> 00:00:48,480
about cppc

00:00:45,440 --> 00:00:51,039
as applied to arm platforms for

00:00:48,480 --> 00:00:53,360
controlling the processor performance

00:00:51,039 --> 00:00:55,039
this discussion also gives an overview

00:00:53,360 --> 00:00:57,920
of the activity monitoring

00:00:55,039 --> 00:00:59,680
extension or the amu extension and the

00:00:57,920 --> 00:01:01,760
cmi first channel

00:00:59,680 --> 00:01:04,640
which are the two components required in

00:01:01,760 --> 00:01:08,159
achieving the cppc functionality

00:01:04,640 --> 00:01:11,119
and at the last part the discussion

00:01:08,159 --> 00:01:13,040
is about how to monitor and control the

00:01:11,119 --> 00:01:15,520
cpu performance using linux

00:01:13,040 --> 00:01:15,520
entries

00:01:17,759 --> 00:01:22,320
so cppc is a mechanism for the os to

00:01:20,799 --> 00:01:24,000
manage the performance of a processor

00:01:22,320 --> 00:01:27,200
core on a contiguous and

00:01:24,000 --> 00:01:29,680
abstract performance scale cppc is

00:01:27,200 --> 00:01:31,680
required for power management as well as

00:01:29,680 --> 00:01:34,320
for thermal management

00:01:31,680 --> 00:01:34,799
for example control system running at

00:01:34,320 --> 00:01:37,439
its

00:01:34,799 --> 00:01:39,040
maximum throttle and the cpu load is

00:01:37,439 --> 00:01:41,360
also very less

00:01:39,040 --> 00:01:42,799
in that case there is no point in

00:01:41,360 --> 00:01:45,600
running the cpu at the highest

00:01:42,799 --> 00:01:48,720
performance as the load is very less

00:01:45,600 --> 00:01:50,320
so in that situation it is recommended

00:01:48,720 --> 00:01:52,240
to reduce the cpu

00:01:50,320 --> 00:01:55,040
frequency or cpu performance to a lower

00:01:52,240 --> 00:01:58,640
value for saving power

00:01:55,040 --> 00:02:02,079
and another scenario is where the system

00:01:58,640 --> 00:02:04,479
runs above the allowed thermal range

00:02:02,079 --> 00:02:06,479
so in that condition also using the

00:02:04,479 --> 00:02:09,039
passive thermal management

00:02:06,479 --> 00:02:10,640
it is recommended to bring the cpu to a

00:02:09,039 --> 00:02:14,879
lower frequency

00:02:10,640 --> 00:02:14,879
for uh reducing the system temperature

00:02:15,599 --> 00:02:22,959
so how cppc works cppc

00:02:19,360 --> 00:02:24,000
for cppc the os request the platform

00:02:22,959 --> 00:02:26,879
firmware

00:02:24,000 --> 00:02:28,879
the required performance over some

00:02:26,879 --> 00:02:31,599
platform communication

00:02:28,879 --> 00:02:33,120
mechanism so the os will request the

00:02:31,599 --> 00:02:34,400
required performance to the platform

00:02:33,120 --> 00:02:36,319
firmware

00:02:34,400 --> 00:02:38,560
and the platform firmware will update

00:02:36,319 --> 00:02:40,640
the cpu frequency and voltage

00:02:38,560 --> 00:02:44,640
if the performance level requested by

00:02:40,640 --> 00:02:44,640
the os is supported in the platform

00:02:44,879 --> 00:02:51,040
the acp cpg specification has put four

00:02:48,000 --> 00:02:53,360
threshold in the cpu performance scale

00:02:51,040 --> 00:02:55,120
among this the highest performance is

00:02:53,360 --> 00:02:56,640
the highest level of performance a

00:02:55,120 --> 00:02:59,920
processor can achieve

00:02:56,640 --> 00:03:01,040
or the highest frequency and voltage

00:02:59,920 --> 00:03:03,280
is referred to as the highest

00:03:01,040 --> 00:03:04,879
performance the

00:03:03,280 --> 00:03:06,720
nominal performance is the highest

00:03:04,879 --> 00:03:08,159
sustained performance a processor can

00:03:06,720 --> 00:03:10,959
deliver

00:03:08,159 --> 00:03:11,519
and it is not recommended to keep any

00:03:10,959 --> 00:03:13,120
processor

00:03:11,519 --> 00:03:15,599
above this nominal performance for

00:03:13,120 --> 00:03:17,360
longer as it may result in

00:03:15,599 --> 00:03:19,840
thermal instabilities or trade-off

00:03:17,360 --> 00:03:21,519
inefficiency

00:03:19,840 --> 00:03:23,440
the lost non-linear performance is a

00:03:21,519 --> 00:03:26,000
loss performance level at which

00:03:23,440 --> 00:03:27,840
non-linear power savings are achieved

00:03:26,000 --> 00:03:32,480
keeping a processor below this

00:03:27,840 --> 00:03:35,760
level results in efficiency finality

00:03:32,480 --> 00:03:36,560
and the last threshold is the loss

00:03:35,760 --> 00:03:38,400
performance

00:03:36,560 --> 00:03:41,120
and which is the absolute lowest

00:03:38,400 --> 00:03:44,159
performance level a processor can

00:03:41,120 --> 00:03:44,480
achieve it is all it is not recommended

00:03:44,159 --> 00:03:46,720
to

00:03:44,480 --> 00:03:48,400
put the processor in loss performance

00:03:46,720 --> 00:03:51,760
but in some scenarios

00:03:48,400 --> 00:03:55,360
for this making the system

00:03:51,760 --> 00:03:59,519
or bringing the system back to normal

00:03:55,360 --> 00:04:02,000
or allowed thermal range

00:03:59,519 --> 00:04:05,120
it may be required to bring the cpu to

00:04:02,000 --> 00:04:05,120
this lowest performance

00:04:05,599 --> 00:04:10,239
and also between these thresholds for

00:04:08,400 --> 00:04:12,159
example between the nominal performance

00:04:10,239 --> 00:04:15,519
and the lost non-linear performance

00:04:12,159 --> 00:04:20,320
there can be no one

00:04:15,519 --> 00:04:20,320
or more than performance level and

00:04:23,840 --> 00:04:28,240
and the cppc framework implemented in

00:04:26,880 --> 00:04:30,400
arm platforms has

00:04:28,240 --> 00:04:31,600
two parts one is a performance

00:04:30,400 --> 00:04:33,360
monitoring part

00:04:31,600 --> 00:04:35,520
and the second is the performance

00:04:33,360 --> 00:04:38,960
controlling part

00:04:35,520 --> 00:04:41,919
on the performance monitoring part

00:04:38,960 --> 00:04:43,520
it uses the activity monitor or amu

00:04:41,919 --> 00:04:46,240
registers

00:04:43,520 --> 00:04:46,800
to obtain the cpu performance or using

00:04:46,240 --> 00:04:49,120
the

00:04:46,800 --> 00:04:51,040
ama register values the os will

00:04:49,120 --> 00:04:54,400
calculate the

00:04:51,040 --> 00:04:57,280
operating frequency on the next half

00:04:54,400 --> 00:04:58,000
performance controlling on performance

00:04:57,280 --> 00:05:00,560
controlling

00:04:58,000 --> 00:05:03,120
the os will request the desired

00:05:00,560 --> 00:05:06,639
performance to the platform firmware

00:05:03,120 --> 00:05:10,000
or fast channel or the sma fast channel

00:05:06,639 --> 00:05:13,039
and on receiving the performance change

00:05:10,000 --> 00:05:16,000
request the platform framework

00:05:13,039 --> 00:05:17,840
will check whether the requested

00:05:16,000 --> 00:05:19,840
performance level is supported

00:05:17,840 --> 00:05:20,880
if the level is supported then the

00:05:19,840 --> 00:05:23,919
platform framework

00:05:20,880 --> 00:05:25,840
uses the dvfs framework to update the

00:05:23,919 --> 00:05:30,080
frequency and voltage of the

00:05:25,840 --> 00:05:32,639
respective core as discussed in the

00:05:30,080 --> 00:05:33,840
previous slides the activity monitor

00:05:32,639 --> 00:05:37,360
unit or the

00:05:33,840 --> 00:05:40,560
amu registers are used in car in

00:05:37,360 --> 00:05:43,919
monitoring the processor performance so

00:05:40,560 --> 00:05:45,039
yeah the am extension is an optional

00:05:43,919 --> 00:05:49,440
extension which is

00:05:45,039 --> 00:05:53,120
introduced in the um 8.4 architecture

00:05:49,440 --> 00:05:54,880
the amu consists of a group of 64-bit

00:05:53,120 --> 00:05:57,360
even counters

00:05:54,880 --> 00:05:59,759
which are classified into two groups the

00:05:57,360 --> 00:06:02,080
architect and even counter

00:05:59,759 --> 00:06:03,360
or the group zero counters and the

00:06:02,080 --> 00:06:06,479
oscillator even counter

00:06:03,360 --> 00:06:09,280
or the group one counters

00:06:06,479 --> 00:06:10,880
so each of this architecture even

00:06:09,280 --> 00:06:11,680
counter or the auxiliary even counter

00:06:10,880 --> 00:06:15,440
each of

00:06:11,680 --> 00:06:18,479
these are 64 64 bit even counters

00:06:15,440 --> 00:06:20,479
and there is one control register

00:06:18,479 --> 00:06:23,280
for controlling each of these registers

00:06:20,479 --> 00:06:23,280
independently

00:06:23,360 --> 00:06:26,400
the events counted by the architect even

00:06:25,520 --> 00:06:29,199
counters are

00:06:26,400 --> 00:06:30,639
fixed and architecturally defined and

00:06:29,199 --> 00:06:32,840
even counted by the

00:06:30,639 --> 00:06:34,160
auxiliary encounter may be fixed or

00:06:32,840 --> 00:06:37,759
programmable

00:06:34,160 --> 00:06:41,199
it's a purely implementation defined for

00:06:37,759 --> 00:06:43,919
m v1 mev1 has

00:06:41,199 --> 00:06:47,120
four architecture event counters and 16

00:06:43,919 --> 00:06:47,120
auxiliary event counters

00:06:47,199 --> 00:06:50,560
for the performance monitoring the

00:06:49,039 --> 00:06:53,120
architecture and even counters

00:06:50,560 --> 00:06:54,880
used are the performance frequency

00:06:53,120 --> 00:06:57,280
counter and the constant frequency

00:06:54,880 --> 00:06:57,280
counter

00:06:57,759 --> 00:07:02,880
on monitoring the performance so

00:07:01,120 --> 00:07:04,479
in this slide the browser frequency

00:07:02,880 --> 00:07:06,479
counter is also referred as

00:07:04,479 --> 00:07:07,840
delivered performance counter and the

00:07:06,479 --> 00:07:10,319
constant frequency counter is referred

00:07:07,840 --> 00:07:14,479
as a reference performance counter

00:07:10,319 --> 00:07:14,479
so yeah in calculating the

00:07:15,680 --> 00:07:18,800
delivered performance or deliver or the

00:07:18,160 --> 00:07:22,160
current of

00:07:18,800 --> 00:07:23,199
frequency of the cpu so the reference

00:07:22,160 --> 00:07:25,919
performance counter

00:07:23,199 --> 00:07:26,560
as well as the constant frequency

00:07:25,919 --> 00:07:29,520
counter

00:07:26,560 --> 00:07:30,160
are sorry the reference frequency

00:07:29,520 --> 00:07:32,400
counter

00:07:30,160 --> 00:07:33,360
and the processor frequency counter are

00:07:32,400 --> 00:07:36,479
red

00:07:33,360 --> 00:07:40,000
and which are kept as set one reading

00:07:36,479 --> 00:07:40,319
and uh after the set one wait for some

00:07:40,000 --> 00:07:44,240
time

00:07:40,319 --> 00:07:45,520
say for some two microseconds so after

00:07:44,240 --> 00:07:47,919
the delay

00:07:45,520 --> 00:07:50,400
again read the processor frequency and

00:07:47,919 --> 00:07:52,639
the constant frequency counters

00:07:50,400 --> 00:07:54,080
and now there are two sets of reading

00:07:52,639 --> 00:07:55,919
based on these two sets

00:07:54,080 --> 00:07:57,599
calculate the delta between these two

00:07:55,919 --> 00:08:00,800
sets

00:07:57,599 --> 00:08:02,319
and using this uh the delivered

00:08:00,800 --> 00:08:05,199
performance can be calculated

00:08:02,319 --> 00:08:07,919
as reference performance into delta

00:08:05,199 --> 00:08:09,680
delivered divided by delta reference

00:08:07,919 --> 00:08:11,520
so in this calculation the reference

00:08:09,680 --> 00:08:13,520
performance is known

00:08:11,520 --> 00:08:14,960
and the delta delivered and delta

00:08:13,520 --> 00:08:18,800
reference will be

00:08:14,960 --> 00:08:20,400
obtained from the amu counter values

00:08:18,800 --> 00:08:22,319
so once a delivered performance is

00:08:20,400 --> 00:08:23,280
available which can be converted into

00:08:22,319 --> 00:08:26,960
frequency

00:08:23,280 --> 00:08:29,919
and can be sent to the os

00:08:26,960 --> 00:08:31,280
one thing to be noted is that the amu

00:08:29,919 --> 00:08:34,560
counters

00:08:31,280 --> 00:08:35,440
will not increment or will not increment

00:08:34,560 --> 00:08:38,839
the count

00:08:35,440 --> 00:08:41,839
when the respective core is in wfi or

00:08:38,839 --> 00:08:41,839
wfe

00:08:44,399 --> 00:08:48,880
the amu registers are implemented system

00:08:48,160 --> 00:08:51,680
registers

00:08:48,880 --> 00:08:53,600
which are not memory mapped so the

00:08:51,680 --> 00:08:56,320
recommended method in accessing

00:08:53,600 --> 00:08:57,680
such platform specific register is the

00:08:56,320 --> 00:09:00,000
fixed hardware or

00:08:57,680 --> 00:09:03,440
fixed feature hardware interface as

00:09:00,000 --> 00:09:06,480
recommended by the acp specification

00:09:03,440 --> 00:09:08,080
so yeah in this case the delivered

00:09:06,480 --> 00:09:10,720
performance counter

00:09:08,080 --> 00:09:11,839
is having the fixed handle address of

00:09:10,720 --> 00:09:14,959
zero

00:09:11,839 --> 00:09:17,519
and the reference performance counter is

00:09:14,959 --> 00:09:17,519
having the

00:09:18,000 --> 00:09:24,480
fx hardware address of one and the

00:09:21,680 --> 00:09:25,440
kernel has a support for handling this

00:09:24,480 --> 00:09:27,920
or the

00:09:25,440 --> 00:09:29,440
or the mainline kernel has a support for

00:09:27,920 --> 00:09:31,200
handling the

00:09:29,440 --> 00:09:33,279
delivered performance address as well as

00:09:31,200 --> 00:09:37,839
the reference performance address

00:09:33,279 --> 00:09:37,839
in the fx hardware address space

00:09:39,760 --> 00:09:47,279
so for the cppc functionality

00:09:44,560 --> 00:09:49,040
so the second half or the controlling of

00:09:47,279 --> 00:09:52,080
the processor performance

00:09:49,040 --> 00:09:54,000
the scma fast channel is used as the

00:09:52,080 --> 00:09:56,080
communication medium between the os and

00:09:54,000 --> 00:09:58,560
the platform firmware

00:09:56,080 --> 00:09:59,519
so first channel is a memory map region

00:09:58,560 --> 00:10:01,040
shared between the

00:09:59,519 --> 00:10:02,560
application browser and the platform

00:10:01,040 --> 00:10:05,760
firmware

00:10:02,560 --> 00:10:09,040
so yeah and also for controlling the

00:10:05,760 --> 00:10:11,120
performance of each core independently

00:10:09,040 --> 00:10:14,000
it is uh recommended to have one fast

00:10:11,120 --> 00:10:14,000
channel per core

00:10:14,079 --> 00:10:18,000
and a single first channel supports four

00:10:16,160 --> 00:10:20,720
protocols the performance limit

00:10:18,000 --> 00:10:21,440
set performance limit get performance

00:10:20,720 --> 00:10:24,079
level set

00:10:21,440 --> 00:10:25,120
and performance level get the

00:10:24,079 --> 00:10:28,800
performance level

00:10:25,120 --> 00:10:30,480
set protocol is the protocol used by os

00:10:28,800 --> 00:10:34,320
for requesting the desired performance

00:10:30,480 --> 00:10:34,320
to the platform firmware

00:10:36,320 --> 00:10:40,480
on controlling the processor performance

00:10:38,399 --> 00:10:45,600
the platform firmware

00:10:40,480 --> 00:10:47,920
will configure the timer to generate

00:10:45,600 --> 00:10:49,680
and event or generator alarm

00:10:47,920 --> 00:10:52,800
periodically for the smf

00:10:49,680 --> 00:10:54,720
driver on boot for say for some four

00:10:52,800 --> 00:10:58,480
millisecond every four millisecond

00:10:54,720 --> 00:11:00,959
the timer timer subsystem will

00:10:58,480 --> 00:11:02,480
generate an event for the sma buff

00:11:00,959 --> 00:11:05,600
driver

00:11:02,480 --> 00:11:08,079
so one boot complete or at the run time

00:11:05,600 --> 00:11:08,880
the linux based os or whatever os is

00:11:08,079 --> 00:11:11,120
running

00:11:08,880 --> 00:11:12,800
the os will request the performance

00:11:11,120 --> 00:11:16,320
level to the platform firmware

00:11:12,800 --> 00:11:18,560
or hdmi first channel so

00:11:16,320 --> 00:11:19,839
yeah or the os will write to that shared

00:11:18,560 --> 00:11:23,839
memory and

00:11:19,839 --> 00:11:26,079
whenever the timer event is generated

00:11:23,839 --> 00:11:26,880
the smf module will read the first

00:11:26,079 --> 00:11:30,880
channel

00:11:26,880 --> 00:11:32,640
and if there's any value update or the

00:11:30,880 --> 00:11:37,120
if the value got changed

00:11:32,640 --> 00:11:41,279
then it will inform the dvfs module and

00:11:37,120 --> 00:11:42,880
the dvfs module will configure the

00:11:41,279 --> 00:11:45,200
operating frequency as well as the

00:11:42,880 --> 00:11:47,120
voltage of the ap core

00:11:45,200 --> 00:11:50,640
if the performance requested by the os

00:11:47,120 --> 00:11:50,640
is supported in the platform

00:11:52,000 --> 00:11:55,279
the previous slides are discussed about

00:11:53,680 --> 00:11:57,279
cppc overview

00:11:55,279 --> 00:11:59,120
the components involved in monitoring

00:11:57,279 --> 00:12:02,399
and controlling the performance

00:11:59,120 --> 00:12:04,480
for arm based platforms moving ahead to

00:12:02,399 --> 00:12:07,279
the software implementation

00:12:04,480 --> 00:12:08,000
the cpc control method under the cpu

00:12:07,279 --> 00:12:11,279
object

00:12:08,000 --> 00:12:13,360
should specify the below fields

00:12:11,279 --> 00:12:14,720
that is from the highest performance

00:12:13,360 --> 00:12:18,639
till the nominal frequency

00:12:14,720 --> 00:12:22,560
these many fields should be exposed as

00:12:18,639 --> 00:12:24,560
or should be specified as integer values

00:12:22,560 --> 00:12:27,440
and the delivered performance counter

00:12:24,560 --> 00:12:30,480
and the reference performance counter

00:12:27,440 --> 00:12:33,760
should be implemented as this

00:12:30,480 --> 00:12:36,480
fixed hardware or feature fixed hardware

00:12:33,760 --> 00:12:38,399
and the performance level set register

00:12:36,480 --> 00:12:40,959
or the first channel

00:12:38,399 --> 00:12:42,000
first channel register or the first

00:12:40,959 --> 00:12:44,720
channel

00:12:42,000 --> 00:12:46,480
protocol should be implemented as a

00:12:44,720 --> 00:12:48,959
system memory

00:12:46,480 --> 00:12:50,959
so these are the required fields for the

00:12:48,959 --> 00:12:53,680
acp cpc package

00:12:50,959 --> 00:12:54,560
so other than the cpc package it is also

00:12:53,680 --> 00:12:56,880
required to

00:12:54,560 --> 00:12:58,560
declare the underscore psd or pstate

00:12:56,880 --> 00:13:00,959
dependency control method

00:12:58,560 --> 00:13:01,760
also under the also under each of the

00:13:00,959 --> 00:13:04,160
cpu

00:13:01,760 --> 00:13:04,160
object

00:13:05,040 --> 00:13:11,360
uh also uh on

00:13:08,399 --> 00:13:13,279
on making the performance scale platform

00:13:11,360 --> 00:13:17,040
must use the same performance scale

00:13:13,279 --> 00:13:17,040
for all processor in the system

00:13:17,200 --> 00:13:23,440
for example uh big little

00:13:20,639 --> 00:13:24,079
system the big cpu will run at a higher

00:13:23,440 --> 00:13:27,360
frequency

00:13:24,079 --> 00:13:28,320
and the little ones are lower in such a

00:13:27,360 --> 00:13:30,399
system

00:13:28,320 --> 00:13:31,680
any two processors running at the same

00:13:30,399 --> 00:13:33,680
performance level

00:13:31,680 --> 00:13:36,079
should finish the same workload in

00:13:33,680 --> 00:13:38,959
approximately same time

00:13:36,079 --> 00:13:39,760
so yeah this is why it is recommended to

00:13:38,959 --> 00:13:41,360
choose

00:13:39,760 --> 00:13:44,560
same performance scale for all the

00:13:41,360 --> 00:13:44,560
processes in the system

00:13:46,800 --> 00:13:50,720
and the performance granularity should

00:13:48,720 --> 00:13:53,360
also be chosen such that

00:13:50,720 --> 00:13:55,839
the reference performance is an integer

00:13:53,360 --> 00:13:59,440
uh consider the example below

00:13:55,839 --> 00:14:01,839
so here in the system the

00:13:59,440 --> 00:14:02,639
reference performance is 100 megahertz

00:14:01,839 --> 00:14:06,320
and the

00:14:02,639 --> 00:14:07,760
granularity chosen is 20 megahertz

00:14:06,320 --> 00:14:09,920
so it will give the reference

00:14:07,760 --> 00:14:14,480
performance as 5

00:14:09,920 --> 00:14:17,040
so it is a not it is not

00:14:14,480 --> 00:14:19,120
it is not recommended to choose the

00:14:17,040 --> 00:14:21,600
granularity as 30 megahertz

00:14:19,120 --> 00:14:23,519
because in a 100 megahertz system with a

00:14:21,600 --> 00:14:25,920
granularity of 30 megahertz

00:14:23,519 --> 00:14:27,360
the reference performance will be 3.33

00:14:25,920 --> 00:14:30,000
which is a floating point

00:14:27,360 --> 00:14:30,880
which is not recommended so care should

00:14:30,000 --> 00:14:33,120
be taken in

00:14:30,880 --> 00:14:34,720
fixing the reference performance or the

00:14:33,120 --> 00:14:37,440
or choosing the performance scale

00:14:34,720 --> 00:14:37,440
granularity

00:14:39,760 --> 00:14:43,760
and also the highest performance and the

00:14:42,639 --> 00:14:47,120
nominal performance

00:14:43,760 --> 00:14:50,639
should be exposed as

00:14:47,120 --> 00:14:50,639
integer values and the

00:14:50,880 --> 00:14:54,560
desired performance register as well as

00:14:52,720 --> 00:14:56,480
the

00:14:54,560 --> 00:14:59,920
sorry the desired performance is exposed

00:14:56,480 --> 00:15:01,519
as a system memory and the

00:14:59,920 --> 00:15:03,600
reference performance counter and the

00:15:01,519 --> 00:15:07,440
delivered performance counter are

00:15:03,600 --> 00:15:07,440
configured as the fixed hardware

00:15:10,399 --> 00:15:16,639
now on the dvfs configuration

00:15:13,600 --> 00:15:19,440
uh the dvfs configuration at the

00:15:16,639 --> 00:15:21,279
platform firmware side

00:15:19,440 --> 00:15:23,839
should also map each of the performance

00:15:21,279 --> 00:15:27,920
level supported with the respective

00:15:23,839 --> 00:15:30,720
frequency and the voltage level so

00:15:27,920 --> 00:15:31,199
yeah this is the performance level or

00:15:30,720 --> 00:15:34,560
the

00:15:31,199 --> 00:15:37,519
performance value in the

00:15:34,560 --> 00:15:38,480
in the scale which is chosen and the

00:15:37,519 --> 00:15:40,320
corresponding

00:15:38,480 --> 00:15:42,240
frequency mapping and the voltage

00:15:40,320 --> 00:15:44,240
mapping for the respective performance

00:15:42,240 --> 00:15:46,720
level should also be mapped in the dvfs

00:15:44,240 --> 00:15:46,720
framework

00:15:50,720 --> 00:15:56,000
this slide is specific for nearby's

00:15:54,079 --> 00:15:59,600
reference design

00:15:56,000 --> 00:16:00,320
so this uh the software components

00:15:59,600 --> 00:16:02,880
involved for

00:16:00,320 --> 00:16:04,399
nearby's reference design are the boot

00:16:02,880 --> 00:16:07,440
time components are

00:16:04,399 --> 00:16:08,959
in the platform firmware side the

00:16:07,440 --> 00:16:09,360
platform framework need to initialize

00:16:08,959 --> 00:16:12,160
the

00:16:09,360 --> 00:16:12,959
psu or the power source unit then the

00:16:12,160 --> 00:16:15,839
dvfs

00:16:12,959 --> 00:16:18,720
dynamic voltage frequency scaling system

00:16:15,839 --> 00:16:21,199
and the semi drivers on boot

00:16:18,720 --> 00:16:22,560
and also at boot the platform firmware

00:16:21,199 --> 00:16:25,600
need to

00:16:22,560 --> 00:16:27,279
configure the timer to generate an alarm

00:16:25,600 --> 00:16:29,040
for uh polling the first channel at

00:16:27,279 --> 00:16:30,160
regular intervals say some four

00:16:29,040 --> 00:16:33,279
milliseconds or

00:16:30,160 --> 00:16:35,360
whatever is the whatever is the proper

00:16:33,279 --> 00:16:38,399
value

00:16:35,360 --> 00:16:39,519
from pressured firmware the trusted

00:16:38,399 --> 00:16:43,680
firmware should

00:16:39,519 --> 00:16:44,639
enable the amu amu registers or the ama

00:16:43,680 --> 00:16:49,199
counters

00:16:44,639 --> 00:16:49,199
and also the treasure framework need to

00:16:49,680 --> 00:16:54,800
you need to make the am registers

00:16:51,519 --> 00:16:57,920
accessible to the non secure os

00:16:54,800 --> 00:16:57,920
and the runtime part

00:16:58,000 --> 00:17:03,360
on the runtime the platform firmware the

00:17:01,120 --> 00:17:04,240
sma driver should poll the fast channel

00:17:03,360 --> 00:17:06,079
periodically

00:17:04,240 --> 00:17:07,439
based on the alarm generated by the

00:17:06,079 --> 00:17:10,160
timer module

00:17:07,439 --> 00:17:10,559
and generate and based on that it need

00:17:10,160 --> 00:17:13,600
to

00:17:10,559 --> 00:17:16,959
the same a perf module need to generate

00:17:13,600 --> 00:17:19,439
events for the dvfs module

00:17:16,959 --> 00:17:21,199
and on the uefa part the ufi part

00:17:19,439 --> 00:17:23,039
measures the majority of the changes are

00:17:21,199 --> 00:17:26,559
there in the acpi

00:17:23,039 --> 00:17:29,760
especially in the cpc control method so

00:17:26,559 --> 00:17:31,440
in the cpc control method a cpc control

00:17:29,760 --> 00:17:32,080
method should provide the fast channel

00:17:31,440 --> 00:17:34,640
address

00:17:32,080 --> 00:17:37,280
as well as the amu register address as

00:17:34,640 --> 00:17:41,760
fixed hardware or feature fixed hardware

00:17:37,280 --> 00:17:45,520
for the os and also in the

00:17:41,760 --> 00:17:48,960
uefi or in the acpa table the

00:17:45,520 --> 00:17:51,360
psd or the pasted dependency

00:17:48,960 --> 00:17:54,400
control method should also be declared

00:17:51,360 --> 00:17:54,400
under each of the code

00:17:55,520 --> 00:17:58,799
on linux part it is majorly on the

00:17:57,919 --> 00:18:01,200
governor and

00:17:58,799 --> 00:18:02,720
the cppc driver which evaluates the

00:18:01,200 --> 00:18:05,840
undercore

00:18:02,720 --> 00:18:08,160
the cpc control method and

00:18:05,840 --> 00:18:09,840
yeah the kernel need to monitor and

00:18:08,160 --> 00:18:12,840
scale the performance accordingly based

00:18:09,840 --> 00:18:15,840
on the entries provided in the acpa

00:18:12,840 --> 00:18:15,840
table

00:18:17,280 --> 00:18:21,360
so for a linux system uh unix by default

00:18:20,480 --> 00:18:25,520
booth with the

00:18:21,360 --> 00:18:25,520
schedule governor and

00:18:25,679 --> 00:18:31,919
on boot time there will be more load

00:18:28,799 --> 00:18:33,919
more load at the cpu and the

00:18:31,919 --> 00:18:35,360
kernel requests the platform to switch

00:18:33,919 --> 00:18:37,919
to normal performance

00:18:35,360 --> 00:18:39,120
as normal performance is the sustained

00:18:37,919 --> 00:18:40,799
performance or the gate

00:18:39,120 --> 00:18:42,640
or the highest sustained performance a

00:18:40,799 --> 00:18:45,039
cpu can run at

00:18:42,640 --> 00:18:47,520
so the schedule governor will request

00:18:45,039 --> 00:18:50,720
for nominal performance

00:18:47,520 --> 00:18:52,799
and once boot complete uh the

00:18:50,720 --> 00:18:54,160
cpu load will be less and the schedule

00:18:52,799 --> 00:18:57,520
governor will

00:18:54,160 --> 00:18:58,720
request the platform to switch the cpu

00:18:57,520 --> 00:19:01,039
to

00:18:58,720 --> 00:19:03,520
lowest non-linear performance so yeah

00:19:01,039 --> 00:19:06,400
that's about the schedule governor

00:19:03,520 --> 00:19:09,039
and for uh evaluating the cpu frequency

00:19:06,400 --> 00:19:12,480
and the performance and related stuffs

00:19:09,039 --> 00:19:15,919
the c surface entry for cpc is available

00:19:12,480 --> 00:19:19,120
at this path in the linux surface

00:19:15,919 --> 00:19:22,160
so this x so here x

00:19:19,120 --> 00:19:24,480
x can be 0 to n

00:19:22,160 --> 00:19:25,600
so for example in a system with eight

00:19:24,480 --> 00:19:29,360
cpu

00:19:25,600 --> 00:19:33,600
uh the x can vary from zero to seven

00:19:29,360 --> 00:19:37,120
uh yeah and here i look into the

00:19:33,600 --> 00:19:40,400
uh policy zero so let's uh

00:19:37,120 --> 00:19:42,400
take an example cpu zero

00:19:40,400 --> 00:19:43,440
so on reading the scaling available

00:19:42,400 --> 00:19:46,480
governors

00:19:43,440 --> 00:19:49,200
will give the available governors or

00:19:46,480 --> 00:19:51,919
the governor supported by the driver oh

00:19:49,200 --> 00:19:54,000
sorry the driver supported by the kernel

00:19:51,919 --> 00:19:55,120
in this case the drivers supported are

00:19:54,000 --> 00:19:57,679
on demand

00:19:55,120 --> 00:19:58,960
user space performance and scheduled

00:19:57,679 --> 00:20:02,720
governance

00:19:58,960 --> 00:20:05,360
and on reading the scaling governor will

00:20:02,720 --> 00:20:06,159
display the governor which is currently

00:20:05,360 --> 00:20:09,039
in use

00:20:06,159 --> 00:20:09,679
in this case it is a schedule governor

00:20:09,039 --> 00:20:12,799
and on

00:20:09,679 --> 00:20:14,400
reading the cpu info curve frequent or

00:20:12,799 --> 00:20:16,159
cpu info current frequency this

00:20:14,400 --> 00:20:19,280
particular cfs entry

00:20:16,159 --> 00:20:21,760
the driver or the

00:20:19,280 --> 00:20:22,400
canal driver will read the ama registers

00:20:21,760 --> 00:20:24,159
and

00:20:22,400 --> 00:20:25,919
calculate the current operating

00:20:24,159 --> 00:20:29,120
frequency of the

00:20:25,919 --> 00:20:32,240
cpu and it will be displayed

00:20:29,120 --> 00:20:35,520
this is about the schedule governor so

00:20:32,240 --> 00:20:37,039
now on the configuring part so if

00:20:35,520 --> 00:20:39,280
it is required to configure the cpu

00:20:37,039 --> 00:20:42,400
frequency so

00:20:39,280 --> 00:20:43,919
go to uh write user space governor into

00:20:42,400 --> 00:20:46,159
the scaling governor

00:20:43,919 --> 00:20:47,440
so that the scaling governor will be

00:20:46,159 --> 00:20:48,960
updated to the user space governor

00:20:47,440 --> 00:20:51,840
instead of shed duty

00:20:48,960 --> 00:20:52,640
and now read the cpu current frequency

00:20:51,840 --> 00:20:55,600
currently it is

00:20:52,640 --> 00:20:57,360
somewhere around 1.3 gigahertz now write

00:20:55,600 --> 00:20:58,159
the desired performance to scaling set

00:20:57,360 --> 00:21:00,720
speed

00:20:58,159 --> 00:21:01,760
and again read back the cpu current

00:21:00,720 --> 00:21:05,440
frequency

00:21:01,760 --> 00:21:08,880
which will give the water frequency set

00:21:05,440 --> 00:21:08,880
to the scaling set speed

00:21:10,960 --> 00:21:15,679
yeah on further reading

00:21:14,080 --> 00:21:18,720
on the topics discussed in this

00:21:15,679 --> 00:21:23,039
discussion it is recommended to

00:21:18,720 --> 00:21:23,039
go through these documents

00:21:25,120 --> 00:21:31,840

YouTube URL: https://www.youtube.com/watch?v=I6OJobYDJFc


