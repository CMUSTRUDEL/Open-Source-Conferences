Title: LVC21-108 Devicetree State of the Union Four Perspectives
Publication date: 2021-04-15
Playlist: Linaro Virtual Connect Spring 2021
Description: 
	Devicetree remains an important part of the boot architecture for many ARM SOCs.  

This session will look at Devicetree from 4 different perspectives: Devicetree for EBBR and SystemReady IR, System Devicetree, Devicetree for RTOS, and a customer perspective of consuming Devicetree based systems. 

Each perspective will give a 5 minute update including what has been accomplished, what is being worked on now, and what is expected to be done in the next 6 to 12 months.
Captions: 
	00:00:03,360 --> 00:00:07,120
hello

00:00:04,960 --> 00:00:08,080
i'm bill mills with linaro we're going

00:00:07,120 --> 00:00:11,120
to talk about

00:00:08,080 --> 00:00:13,280
device tree uh from four different

00:00:11,120 --> 00:00:15,599
perspectives today

00:00:13,280 --> 00:00:18,240
with four different speakers so first

00:00:15,599 --> 00:00:20,800
off andre kolodny is going to talk about

00:00:18,240 --> 00:00:23,199
uh system device tree and context why is

00:00:20,800 --> 00:00:25,680
it important why do we need it

00:00:23,199 --> 00:00:26,640
then stephanos the stubalini is going to

00:00:25,680 --> 00:00:29,679
talk about

00:00:26,640 --> 00:00:32,559
what is device system device tree uh

00:00:29,679 --> 00:00:34,800
what's current and future activities

00:00:32,559 --> 00:00:39,200
kumar gala is going to talk about

00:00:34,800 --> 00:00:40,640
um zephyr and rtos and device tree usage

00:00:39,200 --> 00:00:42,840
in those

00:00:40,640 --> 00:00:44,239
and then finally i'm going to talk about

00:00:42,840 --> 00:00:48,719
standard

00:00:44,239 --> 00:00:48,719
device tree in standardized linux boot

00:00:49,920 --> 00:00:56,320
so what is device tree device tree

00:00:53,280 --> 00:00:57,199
is a pure data structure that describes

00:00:56,320 --> 00:01:00,800
the soc

00:00:57,199 --> 00:01:02,640
and the board hardware it's been used in

00:01:00,800 --> 00:01:04,559
the linux kernel for a long time it

00:01:02,640 --> 00:01:07,920
started on the power pc

00:01:04,559 --> 00:01:09,760
but arm's been using it since 2011.

00:01:07,920 --> 00:01:10,960
it's supported by a lot of different

00:01:09,760 --> 00:01:12,640
architectures

00:01:10,960 --> 00:01:14,560
and there's a lot of different software

00:01:12,640 --> 00:01:15,920
projects that have picked it up and are

00:01:14,560 --> 00:01:19,119
using it

00:01:15,920 --> 00:01:22,000
and still in use today so what is

00:01:19,119 --> 00:01:23,600
system device tree system device tree is

00:01:22,000 --> 00:01:27,119
a newer concept

00:01:23,600 --> 00:01:29,840
that takes device tree and extends its

00:01:27,119 --> 00:01:31,920
perspective so it can describe bigger

00:01:29,840 --> 00:01:34,560
parts of the system

00:01:31,920 --> 00:01:36,880
describe the point of view from multiple

00:01:34,560 --> 00:01:40,000
independent cpus

00:01:36,880 --> 00:01:41,439
independent os components so that you

00:01:40,000 --> 00:01:44,000
can really get the whole system

00:01:41,439 --> 00:01:44,000
perspective

00:01:44,240 --> 00:01:51,040
one valid question to ask is why use

00:01:47,280 --> 00:01:55,040
device tree today many people know that

00:01:51,040 --> 00:01:56,479
arm servers are using acpi so if acpi

00:01:55,040 --> 00:01:59,280
meets your needs by all means

00:01:56,479 --> 00:02:01,200
use it but we believe that there's a

00:01:59,280 --> 00:02:01,840
number of use cases around embedded

00:02:01,200 --> 00:02:05,439
systems

00:02:01,840 --> 00:02:09,759
where acpi is not necessarily a good fit

00:02:05,439 --> 00:02:12,480
and device tree can fill that need

00:02:09,759 --> 00:02:14,480
device tree is more flexible and nimble

00:02:12,480 --> 00:02:16,080
which is both a blessing and a curse as

00:02:14,480 --> 00:02:18,959
we can talk about later

00:02:16,080 --> 00:02:21,120
but um so there's still a role for

00:02:18,959 --> 00:02:24,959
device tree to play

00:02:21,120 --> 00:02:26,400
even if you envision acpi being used

00:02:24,959 --> 00:02:28,879
we believe that there's a role for

00:02:26,400 --> 00:02:30,560
system device tree regardless

00:02:28,879 --> 00:02:32,720
um and then there's a number of

00:02:30,560 --> 00:02:36,080
standardizing activities around

00:02:32,720 --> 00:02:39,599
device tree arms system ready standards

00:02:36,080 --> 00:02:42,239
has a flavor called ir iot ready

00:02:39,599 --> 00:02:43,680
that's device tree based in the embedded

00:02:42,239 --> 00:02:47,040
base boot requirements

00:02:43,680 --> 00:02:48,080
effort has um been underway for a couple

00:02:47,040 --> 00:02:51,840
of years now

00:02:48,080 --> 00:02:51,840
and are standardizing this

00:02:58,879 --> 00:03:04,400
uh it is a small turtle boat

00:03:02,000 --> 00:03:07,200
robot run in roth 2 and it shows a quite

00:03:04,400 --> 00:03:10,159
complicated example of the mix critical

00:03:07,200 --> 00:03:11,200
uh safety system so turtlebot has a

00:03:10,159 --> 00:03:13,040
lidar

00:03:11,200 --> 00:03:15,599
ultrasonic sensor for the environment

00:03:13,040 --> 00:03:18,080
sense and it has some control algorithm

00:03:15,599 --> 00:03:20,640
running which produces an output to the

00:03:18,080 --> 00:03:22,879
actuators and the wireless connection

00:03:20,640 --> 00:03:22,879
uh

00:03:23,680 --> 00:03:29,840
so here you can see a dashboard and

00:03:27,040 --> 00:03:32,000
on the dashboard you can see that we

00:03:29,840 --> 00:03:34,480
have deployed four operating systems

00:03:32,000 --> 00:03:36,640
so you have two instances of the

00:03:34,480 --> 00:03:38,560
real-time operating system then behind

00:03:36,640 --> 00:03:40,959
that you have behind this screen

00:03:38,560 --> 00:03:43,040
you have another instance and uh and

00:03:40,959 --> 00:03:46,959
then you have a linux running

00:03:43,040 --> 00:03:49,920
uh which serves as the gateway to the

00:03:46,959 --> 00:03:50,239
uh to the outside world plus underneath

00:03:49,920 --> 00:03:52,640
of

00:03:50,239 --> 00:03:55,840
of all these guest operating systems a

00:03:52,640 --> 00:03:58,400
real-time hyperversion

00:03:55,840 --> 00:03:59,439
next slide shows a detailed architecture

00:03:58,400 --> 00:04:03,280
diagram

00:03:59,439 --> 00:04:05,760
a system contains of arm soc with four

00:04:03,280 --> 00:04:05,760
cores

00:04:05,840 --> 00:04:09,840
you can think of raspberry pi 4 or

00:04:08,799 --> 00:04:12,840
similar board

00:04:09,840 --> 00:04:14,159
with various peripherals you see uart

00:04:12,840 --> 00:04:16,959
gpios

00:04:14,159 --> 00:04:18,479
usb where wider sensor and motor control

00:04:16,959 --> 00:04:22,000
port are connected

00:04:18,479 --> 00:04:24,240
sd card wi-fi

00:04:22,000 --> 00:04:26,240
and you see that the guest operating

00:04:24,240 --> 00:04:29,600
systems they are mapped to cores

00:04:26,240 --> 00:04:32,880
not equally so two uh

00:04:29,600 --> 00:04:36,639
os is run on one core uh then

00:04:32,880 --> 00:04:39,680
uh one os running on the two cores

00:04:36,639 --> 00:04:42,000
and uh another one os runs on on the

00:04:39,680 --> 00:04:46,160
separate core

00:04:42,000 --> 00:04:47,840
and this so different peripherals are

00:04:46,160 --> 00:04:51,199
exposed to the

00:04:47,840 --> 00:04:55,040
uh cores via hypervisor and besides that

00:04:51,199 --> 00:04:58,320
you also have a way of communication

00:04:55,040 --> 00:05:01,120
between guest operating systems where

00:04:58,320 --> 00:05:03,600
virtual network interfaces needs to be

00:05:01,120 --> 00:05:03,600
created

00:05:04,479 --> 00:05:06,800
and

00:05:08,000 --> 00:05:11,680
and this actually produces big

00:05:10,960 --> 00:05:14,880
challenges

00:05:11,680 --> 00:05:17,039
to describe and to configure such so

00:05:14,880 --> 00:05:18,639
system configuration and spread it via

00:05:17,039 --> 00:05:21,280
different instances

00:05:18,639 --> 00:05:22,880
it's a hypervisor real-time operating

00:05:21,280 --> 00:05:26,240
system linux so

00:05:22,880 --> 00:05:29,280
you need to configure cpu amount of ram

00:05:26,240 --> 00:05:31,039
network peripherals configuration

00:05:29,280 --> 00:05:33,919
formats on each

00:05:31,039 --> 00:05:36,000
operating systems are not compatible you

00:05:33,919 --> 00:05:39,199
have for instance proprietary device 3

00:05:36,000 --> 00:05:40,320
for the hypervisor uh vxbox device three

00:05:39,199 --> 00:05:43,759
on their tosses

00:05:40,320 --> 00:05:45,840
and uh uh it's it's a

00:05:43,759 --> 00:05:48,000
car accident that this real-time

00:05:45,840 --> 00:05:51,039
operating system has device three

00:05:48,000 --> 00:05:52,320
so other operating systems does not even

00:05:51,039 --> 00:05:54,639
have device 3

00:05:52,320 --> 00:05:58,720
and values are hard coded so on the

00:05:54,639 --> 00:06:01,039
linux you have a standard linux device 3

00:05:58,720 --> 00:06:02,319
and it costs like a difficulties to

00:06:01,039 --> 00:06:05,520
check

00:06:02,319 --> 00:06:07,919
the whole system for consistency to

00:06:05,520 --> 00:06:09,600
modify the configuration if

00:06:07,919 --> 00:06:13,120
modifications are needed

00:06:09,600 --> 00:06:16,880
are needed you need to define values in

00:06:13,120 --> 00:06:20,240
different places and i have

00:06:16,880 --> 00:06:21,440
given an example of smp system but you

00:06:20,240 --> 00:06:24,960
have also amp

00:06:21,440 --> 00:06:27,759
systems uh where for instance you have

00:06:24,960 --> 00:06:28,240
r5 and you need to configure uh such a

00:06:27,759 --> 00:06:30,720
system

00:06:28,240 --> 00:06:31,440
so as you can see it's a quite difficult

00:06:30,720 --> 00:06:34,479
and

00:06:31,440 --> 00:06:36,720
error prone and next speaker as

00:06:34,479 --> 00:06:40,319
next speakers will explain how lenara

00:06:36,720 --> 00:06:40,319
wants to address this challenge

00:06:42,720 --> 00:06:48,319
hi i'm stefano stabilini and i'm the

00:06:44,960 --> 00:06:50,960
virtualization tech lead at stylings

00:06:48,319 --> 00:06:53,759
system device 3 addresses these points

00:06:50,960 --> 00:06:55,280
by expanding on the device specification

00:06:53,759 --> 00:06:58,160
that's used to describe

00:06:55,280 --> 00:06:59,360
hardware for one operating system system

00:06:58,160 --> 00:07:01,440
device 3 describe

00:06:59,360 --> 00:07:03,680
a whole soc for multiple operating

00:07:01,440 --> 00:07:06,800
systems so it can describe

00:07:03,680 --> 00:07:07,440
an soc with two or more cpu clusters for

00:07:06,800 --> 00:07:09,919
instance

00:07:07,440 --> 00:07:10,720
a cortex-a cluster where a rich os like

00:07:09,919 --> 00:07:13,280
linux run

00:07:10,720 --> 00:07:14,240
and a cortex-r cluster where anatos is

00:07:13,280 --> 00:07:16,479
running

00:07:14,240 --> 00:07:18,319
it does so by introducing cpu cluster

00:07:16,479 --> 00:07:20,720
nodes and you can see an example

00:07:18,319 --> 00:07:22,960
on the top right side of the slide

00:07:20,720 --> 00:07:24,800
system divisory can also describe

00:07:22,960 --> 00:07:26,720
differences in address mapping for the

00:07:24,800 --> 00:07:28,560
cpu clusters and you can see

00:07:26,720 --> 00:07:31,120
how it is done with the address map

00:07:28,560 --> 00:07:33,039
property again on the slide

00:07:31,120 --> 00:07:34,880
different analysis mapping can be such

00:07:33,039 --> 00:07:36,960
as a device is visible

00:07:34,880 --> 00:07:38,720
only from one cluster and not the other

00:07:36,960 --> 00:07:39,440
or a device is visible at different

00:07:38,720 --> 00:07:42,240
addresses

00:07:39,440 --> 00:07:44,080
as the different clusters the other

00:07:42,240 --> 00:07:47,840
major area where system devices

00:07:44,080 --> 00:07:49,919
help is the whole amp configuration of

00:07:47,840 --> 00:07:52,240
the system

00:07:49,919 --> 00:07:54,000
software what is running where which

00:07:52,240 --> 00:07:57,120
execution level

00:07:54,000 --> 00:07:59,360
it does so by introducing the concept of

00:07:57,120 --> 00:08:01,120
execution domains and you can see an

00:07:59,360 --> 00:08:02,960
execution domain on the bottom right

00:08:01,120 --> 00:08:05,919
side of the slide

00:08:02,960 --> 00:08:07,759
an execution domain is a collection of

00:08:05,919 --> 00:08:10,000
hardware resources necessary

00:08:07,759 --> 00:08:12,319
necessary to run a software component

00:08:10,000 --> 00:08:13,120
such as an operating system so it

00:08:12,319 --> 00:08:15,680
includes

00:08:13,120 --> 00:08:17,440
uh the cpus where the software is

00:08:15,680 --> 00:08:18,160
running on and secure the execution

00:08:17,440 --> 00:08:20,879
level

00:08:18,160 --> 00:08:22,240
it includes memory areas that are needed

00:08:20,879 --> 00:08:24,960
by the domain

00:08:22,240 --> 00:08:26,479
and as well as a list of devices that

00:08:24,960 --> 00:08:29,680
are uniquely accessible

00:08:26,479 --> 00:08:31,599
by that domain in this example the

00:08:29,680 --> 00:08:33,839
canvas controller

00:08:31,599 --> 00:08:35,279
finally another important piece of the

00:08:33,839 --> 00:08:39,519
system device 3

00:08:35,279 --> 00:08:42,000
world is locker lottery is a python 2

00:08:39,519 --> 00:08:42,640
that takes a system device as input and

00:08:42,000 --> 00:08:45,279
generate

00:08:42,640 --> 00:08:47,200
multiple traditional device trees output

00:08:45,279 --> 00:08:49,279
one for each execution domain

00:08:47,200 --> 00:08:50,240
so the system advisor is input and you

00:08:49,279 --> 00:08:52,080
get as output

00:08:50,240 --> 00:08:54,000
a traditional devices that you can give

00:08:52,080 --> 00:08:56,640
to linux unmodified and then

00:08:54,000 --> 00:08:57,279
linux can boot or zapier or 10 or any

00:08:56,640 --> 00:09:01,279
other

00:08:57,279 --> 00:09:02,000
os's i'm going to spend a few words on a

00:09:01,279 --> 00:09:04,640
newer

00:09:02,000 --> 00:09:06,399
development on that's remote proc

00:09:04,640 --> 00:09:09,200
support and system devices

00:09:06,399 --> 00:09:10,720
remote proc is a communication and life

00:09:09,200 --> 00:09:13,040
cycle management protocol

00:09:10,720 --> 00:09:15,760
so linux typically uses remote proc to

00:09:13,040 --> 00:09:17,519
boot up and communicate with a remote uh

00:09:15,760 --> 00:09:21,360
co-processor like

00:09:17,519 --> 00:09:23,120
like a two-court exam or an or an r5

00:09:21,360 --> 00:09:25,360
you can see the traditional way of

00:09:23,120 --> 00:09:26,480
describing a remote pro connection here

00:09:25,360 --> 00:09:30,000
on this slide

00:09:26,480 --> 00:09:30,959
and it's not very intuitive uh it's very

00:09:30,000 --> 00:09:34,000
informative but

00:09:30,959 --> 00:09:35,120
it's not for humans really too easy to

00:09:34,000 --> 00:09:36,800
understand

00:09:35,120 --> 00:09:38,320
as opposed to the system devices

00:09:36,800 --> 00:09:39,040
description that you said you can see

00:09:38,320 --> 00:09:40,959
here

00:09:39,040 --> 00:09:42,800
thanks to the system level view with

00:09:40,959 --> 00:09:45,120
multiple execution domain

00:09:42,800 --> 00:09:46,959
uh one domain with linux and the cortex

00:09:45,120 --> 00:09:50,399
says another domain with

00:09:46,959 --> 00:09:50,800
zephyr on the cortex sars it becomes

00:09:50,399 --> 00:09:52,480
very

00:09:50,800 --> 00:09:53,920
much more natural and intuitive to

00:09:52,480 --> 00:09:58,160
describe the mock proc

00:09:53,920 --> 00:10:00,720
in this example in fact it only takes um

00:09:58,160 --> 00:10:01,760
resources uniquely assigned describes to

00:10:00,720 --> 00:10:05,120
the access list

00:10:01,760 --> 00:10:07,519
like the ipi mailbox to the cortex-a

00:10:05,120 --> 00:10:08,160
domain and some resources that are

00:10:07,519 --> 00:10:09,760
shared and

00:10:08,160 --> 00:10:11,920
you can see the resource group on the

00:10:09,760 --> 00:10:14,560
top right sides of the slide

00:10:11,920 --> 00:10:17,279
including four memory regions and the

00:10:14,560 --> 00:10:20,600
tcm that's a little special sram region

00:10:17,279 --> 00:10:23,760
the resource group is shared between the

00:10:20,600 --> 00:10:25,600
8563 domain and they are five domain

00:10:23,760 --> 00:10:27,760
that's all it takes plus a couple of

00:10:25,600 --> 00:10:30,079
flags to specify a remote proc

00:10:27,760 --> 00:10:32,160
connection at the system devices level

00:10:30,079 --> 00:10:33,839
sharing of resources and uniquely

00:10:32,160 --> 00:10:36,079
assigned resources

00:10:33,839 --> 00:10:37,680
then locker can take these as input and

00:10:36,079 --> 00:10:39,680
generate the traditional

00:10:37,680 --> 00:10:41,040
remote property license output as

00:10:39,680 --> 00:10:44,720
understood by linux

00:10:41,040 --> 00:10:46,079
and other os's i uploaded a full system

00:10:44,720 --> 00:10:48,480
device tree example online

00:10:46,079 --> 00:10:49,120
you can check out a full description of

00:10:48,480 --> 00:10:53,040
the client

00:10:49,120 --> 00:10:54,959
board plus multiple domains um

00:10:53,040 --> 00:10:57,040
and in the next six to twelve months

00:10:54,959 --> 00:10:59,120
what we're looking at is introducing bus

00:10:57,040 --> 00:11:00,480
firewall support in system device tree

00:10:59,120 --> 00:11:03,120
bus firewalls are these little

00:11:00,480 --> 00:11:05,600
components that can

00:11:03,120 --> 00:11:07,200
block them a transaction on an soc level

00:11:05,600 --> 00:11:09,760
and therefore they can be used to

00:11:07,200 --> 00:11:11,839
protect domains from other domains

00:11:09,760 --> 00:11:13,839
we're also looking at hypervisor

00:11:11,839 --> 00:11:16,000
bindings since the very beginning

00:11:13,839 --> 00:11:17,360
domains were meant to be not just amp

00:11:16,000 --> 00:11:19,760
domains but also

00:11:17,360 --> 00:11:21,440
hypervisor virtual machines especially

00:11:19,760 --> 00:11:24,240
static hypervisors

00:11:21,440 --> 00:11:26,000
and finally yamo we want to be able to

00:11:24,240 --> 00:11:28,399
describe execution domains

00:11:26,000 --> 00:11:29,360
in a simpler way more intuitive using

00:11:28,399 --> 00:11:31,040
ammo still

00:11:29,360 --> 00:11:33,040
corresponding to the device

00:11:31,040 --> 00:11:35,360
redescription you have seen on these

00:11:33,040 --> 00:11:35,360
lives

00:11:39,279 --> 00:11:43,279
hello there i'm kumar again the

00:11:40,800 --> 00:11:44,399
technical lead for the lenaro iot and

00:11:43,279 --> 00:11:45,519
embedded group

00:11:44,399 --> 00:11:46,800
i was going to talk a little bit about

00:11:45,519 --> 00:11:48,320
some of the work we've done over the

00:11:46,800 --> 00:11:50,240
last few years around

00:11:48,320 --> 00:11:52,320
use of device tree on our tosses and

00:11:50,240 --> 00:11:56,160
specifically zephyr

00:11:52,320 --> 00:11:58,160
so in the mcu space in our top space

00:11:56,160 --> 00:11:59,600
we have some of the same type of issues

00:11:58,160 --> 00:12:01,360
and problems that you would see in a

00:11:59,600 --> 00:12:02,959
general purpose processor or general

00:12:01,360 --> 00:12:04,800
purpose os

00:12:02,959 --> 00:12:07,040
even in the microcontroller space so

00:12:04,800 --> 00:12:09,920
wanting to have the ability to describe

00:12:07,040 --> 00:12:11,440
systems in a vendor-neutral way having

00:12:09,920 --> 00:12:13,120
something that conveys hardware

00:12:11,440 --> 00:12:15,360
configuration to different

00:12:13,120 --> 00:12:17,040
software environments so between an rtos

00:12:15,360 --> 00:12:19,120
and maybe middleware

00:12:17,040 --> 00:12:21,040
and then having very similar type of

00:12:19,120 --> 00:12:23,279
hardware systems of

00:12:21,040 --> 00:12:25,200
asymmetric so we have you know mcus that

00:12:23,279 --> 00:12:27,120
have multiple cores of different types

00:12:25,200 --> 00:12:28,160
of having things like trusted execution

00:12:27,120 --> 00:12:29,920
environments

00:12:28,160 --> 00:12:32,079
um and even having as it's been

00:12:29,920 --> 00:12:32,800
mentioned earlier heterogeneous systems

00:12:32,079 --> 00:12:36,000
where we have

00:12:32,800 --> 00:12:37,440
you know mcus embedded in larger socs uh

00:12:36,000 --> 00:12:38,079
and so forth so device tree is a very

00:12:37,440 --> 00:12:39,680
natural

00:12:38,079 --> 00:12:42,480
uh concept to utilize in this

00:12:39,680 --> 00:12:43,360
environment what's distinct or unique to

00:12:42,480 --> 00:12:45,680
the environment is

00:12:43,360 --> 00:12:47,360
is the footprint concern and so the

00:12:45,680 --> 00:12:49,279
classical kind of use of

00:12:47,360 --> 00:12:51,519
using device tree at runtime having a

00:12:49,279 --> 00:12:54,079
blob having code to parse that blob

00:12:51,519 --> 00:12:54,639
it doesn't really fit the mcu's case

00:12:54,079 --> 00:12:57,040
because of

00:12:54,639 --> 00:13:00,320
footprint concerns to give a quick

00:12:57,040 --> 00:13:02,639
example the bbc micro bit has 256k of

00:13:00,320 --> 00:13:03,920
flash 64k of memory

00:13:02,639 --> 00:13:05,519
and you can kind of see the numbers here

00:13:03,920 --> 00:13:06,000
where that just you end up using a lot

00:13:05,519 --> 00:13:07,760
of your

00:13:06,000 --> 00:13:10,240
resource just for device tree if you're

00:13:07,760 --> 00:13:12,000
using the classical sort of model

00:13:10,240 --> 00:13:13,440
so instead what we looked at in it was

00:13:12,000 --> 00:13:14,800
to use device tree as a common

00:13:13,440 --> 00:13:16,880
representation

00:13:14,800 --> 00:13:18,880
and and then do code generation out of

00:13:16,880 --> 00:13:20,399
that

00:13:18,880 --> 00:13:22,079
so to talk a little bit about the code

00:13:20,399 --> 00:13:23,600
generation we've done in zephyr over the

00:13:22,079 --> 00:13:25,519
years it's definitely

00:13:23,600 --> 00:13:28,480
uh improved and changed since we

00:13:25,519 --> 00:13:30,399
introduced it back in 2017.

00:13:28,480 --> 00:13:32,639
we've always kind of tried to support

00:13:30,399 --> 00:13:35,040
multiple uh portability with the

00:13:32,639 --> 00:13:37,680
the code set and generation tooling so

00:13:35,040 --> 00:13:38,880
we utilize python as as the base of that

00:13:37,680 --> 00:13:41,360
tooling

00:13:38,880 --> 00:13:43,279
and we've tried to keep what is the set

00:13:41,360 --> 00:13:45,760
of scripts and tools that we bring here

00:13:43,279 --> 00:13:47,360
um not be zephyr specific so that we can

00:13:45,760 --> 00:13:48,079
pull them out in the future and that's

00:13:47,360 --> 00:13:50,240
something we're

00:13:48,079 --> 00:13:52,000
looking at doing uh and i'll talk about

00:13:50,240 --> 00:13:53,680
in a second

00:13:52,000 --> 00:13:55,279
so the the tooling is kind of broken

00:13:53,680 --> 00:13:59,120
into three pieces what we have

00:13:55,279 --> 00:14:01,519
first is a pure uh dts parser

00:13:59,120 --> 00:14:03,199
that kind of just gives a python view of

00:14:01,519 --> 00:14:04,639
a dts file

00:14:03,199 --> 00:14:06,480
then we have a script that takes that

00:14:04,639 --> 00:14:07,760
sort of data representation and gives

00:14:06,480 --> 00:14:10,880
sort of a more

00:14:07,760 --> 00:14:12,800
uh device model view so it understands

00:14:10,880 --> 00:14:14,480
things like registers and interrupts and

00:14:12,800 --> 00:14:16,399
clocks and so it gives you a bit more

00:14:14,480 --> 00:14:17,920
structure to that data

00:14:16,399 --> 00:14:19,839
and then finally we have the script that

00:14:17,920 --> 00:14:22,240
sort of takes that view and actually

00:14:19,839 --> 00:14:25,120
generates out a set of defines

00:14:22,240 --> 00:14:26,959
that can be used and here's just a very

00:14:25,120 --> 00:14:29,600
simple example where we have

00:14:26,959 --> 00:14:30,000
a uart node a register address and size

00:14:29,600 --> 00:14:32,320
for that

00:14:30,000 --> 00:14:33,519
node and then kind of an example of the

00:14:32,320 --> 00:14:35,680
macros

00:14:33,519 --> 00:14:37,600
language that we kind of have that we

00:14:35,680 --> 00:14:39,279
can use to extract that data from the

00:14:37,600 --> 00:14:41,120
set of defines and so we have a way of

00:14:39,279 --> 00:14:43,839
referencing the node so in this example

00:14:41,120 --> 00:14:46,160
we're using the node label

00:14:43,839 --> 00:14:47,519
and then we're asking for the reg adder

00:14:46,160 --> 00:14:50,639
and there's a much more rich

00:14:47,519 --> 00:14:53,040
uh set of macros and so forth um

00:14:50,639 --> 00:14:54,320
that you'll get some pointers to here

00:14:53,040 --> 00:14:56,800
and so this just gives a quick

00:14:54,320 --> 00:14:58,000
graphical view of sort of how the

00:14:56,800 --> 00:15:01,120
tooling works and so forth

00:14:58,000 --> 00:15:02,079
so we have sort of our source files for

00:15:01,120 --> 00:15:04,079
the dts

00:15:02,079 --> 00:15:06,079
we have a set of bindings that are today

00:15:04,079 --> 00:15:08,720
zephyr specific that we intend to

00:15:06,079 --> 00:15:10,079
work towards trying to unify with some

00:15:08,720 --> 00:15:11,680
of the work that's going in the linux

00:15:10,079 --> 00:15:13,680
bindings

00:15:11,680 --> 00:15:15,680
those kind of our input to the tools to

00:15:13,680 --> 00:15:17,040
understand the structure of everything

00:15:15,680 --> 00:15:18,240
and the the set of scripts that i

00:15:17,040 --> 00:15:20,160
mentioned and then out from those

00:15:18,240 --> 00:15:22,240
scripts we get a set of defines

00:15:20,160 --> 00:15:24,320
um and then there's these macros that

00:15:22,240 --> 00:15:26,079
you can sort of work with those defines

00:15:24,320 --> 00:15:27,839
to give an interface and compare

00:15:26,079 --> 00:15:30,160
pointers here to that you can look in

00:15:27,839 --> 00:15:32,399
more detail

00:15:30,160 --> 00:15:34,240
so what are we up to next so we're kind

00:15:32,399 --> 00:15:34,639
of moving from being able to describes

00:15:34,240 --> 00:15:37,360
uh

00:15:34,639 --> 00:15:37,920
sort of traditional mcus of a single

00:15:37,360 --> 00:15:40,320
core

00:15:37,920 --> 00:15:42,079
mcu that's standalone stand-alone and

00:15:40,320 --> 00:15:42,399
one software environment to kind of want

00:15:42,079 --> 00:15:44,160
to

00:15:42,399 --> 00:15:45,759
take advantage of the system device tree

00:15:44,160 --> 00:15:46,800
work that's been talked about and

00:15:45,759 --> 00:15:49,920
extending that

00:15:46,800 --> 00:15:51,519
uh into the mcu space and looking around

00:15:49,920 --> 00:15:53,199
uh trusted firmware in the trusted

00:15:51,519 --> 00:15:55,199
execution environment is kind of one of

00:15:53,199 --> 00:15:57,759
the first use cases we're thinking about

00:15:55,199 --> 00:15:59,279
looking at with system device tree in

00:15:57,759 --> 00:16:00,880
addition to that kind of stephano

00:15:59,279 --> 00:16:02,720
mentioned that there's the work going on

00:16:00,880 --> 00:16:04,320
around the bindings for system device

00:16:02,720 --> 00:16:04,800
tree and so we want to kind of make sure

00:16:04,320 --> 00:16:06,959
that

00:16:04,800 --> 00:16:08,160
the mcu use cases and the way mcu

00:16:06,959 --> 00:16:11,519
hardware uh

00:16:08,160 --> 00:16:13,680
is is managed in that binding definition

00:16:11,519 --> 00:16:15,920
and working with a group there

00:16:13,680 --> 00:16:18,160
we're also working looking to work with

00:16:15,920 --> 00:16:20,079
the loper tool which is what is the

00:16:18,160 --> 00:16:22,000
sort of tool today around system device

00:16:20,079 --> 00:16:24,480
tree and how we can glue

00:16:22,000 --> 00:16:26,639
some of the work we've done uh today

00:16:24,480 --> 00:16:28,560
pull some of that out of zephyr

00:16:26,639 --> 00:16:29,759
and have a bit more common base to build

00:16:28,560 --> 00:16:32,079
these tools around

00:16:29,759 --> 00:16:33,600
and work for going forward and then

00:16:32,079 --> 00:16:36,000
finally kind of towards that trusted

00:16:33,600 --> 00:16:38,560
firmware of really showing an example

00:16:36,000 --> 00:16:39,279
of real heart of how this would work for

00:16:38,560 --> 00:16:41,600
a real

00:16:39,279 --> 00:16:41,600
system

00:16:46,000 --> 00:16:50,639
all right so let's talk about device

00:16:48,880 --> 00:16:53,680
tree in standardizing

00:16:50,639 --> 00:16:56,320
linux and other os boot so we talked

00:16:53,680 --> 00:16:57,440
about ebbr and system ready ir in the in

00:16:56,320 --> 00:16:58,959
the introduction

00:16:57,440 --> 00:17:01,920
but this is really an effort to

00:16:58,959 --> 00:17:04,559
standardize the boot flow

00:17:01,920 --> 00:17:06,799
for higher level operating systems

00:17:04,559 --> 00:17:07,839
provide a clean delineation between the

00:17:06,799 --> 00:17:10,400
firmware

00:17:07,839 --> 00:17:13,919
and the os layer whether it be the os

00:17:10,400 --> 00:17:13,919
kernel or a hypervisor

00:17:15,280 --> 00:17:19,520
the embedded systems today still the

00:17:17,760 --> 00:17:23,520
boot flow is very mixed

00:17:19,520 --> 00:17:26,959
um very messed up very inconsistent

00:17:23,520 --> 00:17:29,679
i should say and it varies quite a bit

00:17:26,959 --> 00:17:31,360
uh despite the previous efforts to

00:17:29,679 --> 00:17:33,440
standardize this

00:17:31,360 --> 00:17:36,160
and at the same time we're getting new

00:17:33,440 --> 00:17:38,799
requirements so we want to standardize

00:17:36,160 --> 00:17:41,360
the methodology for doing secure boot

00:17:38,799 --> 00:17:44,080
make it distro compatible

00:17:41,360 --> 00:17:45,600
and when we do that the dtb data neat

00:17:44,080 --> 00:17:47,520
the signature of that

00:17:45,600 --> 00:17:49,440
needs to be verified by somebody in this

00:17:47,520 --> 00:17:51,440
in the boot flow

00:17:49,440 --> 00:17:53,840
likewise if you're doing measured boot

00:17:51,440 --> 00:17:56,400
the dtb data needs to be measured into a

00:17:53,840 --> 00:17:56,400
pcr

00:17:56,640 --> 00:18:00,080
so one of the aspects of the dtb boot

00:17:59,679 --> 00:18:02,320
flow

00:18:00,080 --> 00:18:03,520
one of the debatable aspects is who owns

00:18:02,320 --> 00:18:05,200
the dtp

00:18:03,520 --> 00:18:06,559
should it be the firmware or should it

00:18:05,200 --> 00:18:10,160
be the os

00:18:06,559 --> 00:18:13,280
um there are pluses and minuses to both

00:18:10,160 --> 00:18:16,160
models they you

00:18:13,280 --> 00:18:18,799
the os is sort of the current model but

00:18:16,160 --> 00:18:22,080
the firmware kind of makes more sense

00:18:18,799 --> 00:18:24,240
uh so what we're trying to do is

00:18:22,080 --> 00:18:25,840
do a hybrid model where the firmware

00:18:24,240 --> 00:18:28,320
always provides a dtp

00:18:25,840 --> 00:18:29,679
and and as time goes by we will get

00:18:28,320 --> 00:18:32,480
better at

00:18:29,679 --> 00:18:33,600
making that uh work out of the box more

00:18:32,480 --> 00:18:35,679
often

00:18:33,600 --> 00:18:37,600
but at the same time the os has the

00:18:35,679 --> 00:18:37,919
capability when it knows the hardware

00:18:37,600 --> 00:18:40,080
and

00:18:37,919 --> 00:18:41,039
thinks it knows better can override that

00:18:40,080 --> 00:18:42,799
dtb

00:18:41,039 --> 00:18:46,640
and all the hooks to make that work

00:18:42,799 --> 00:18:49,200
properly are in the architecture

00:18:46,640 --> 00:18:51,200
so the current activity is is basically

00:18:49,200 --> 00:18:53,600
three things

00:18:51,200 --> 00:18:54,480
so varesh kumar is working in the

00:18:53,600 --> 00:18:57,520
upstream

00:18:54,480 --> 00:18:59,280
kernel to allow

00:18:57,520 --> 00:19:01,760
to do the work in the make file and

00:18:59,280 --> 00:19:04,960
other things so that we can have

00:19:01,760 --> 00:19:07,760
overlay source files

00:19:04,960 --> 00:19:10,400
in the upstream kernel up to this point

00:19:07,760 --> 00:19:12,559
there's really been no upstream place

00:19:10,400 --> 00:19:14,240
for overlay source files now these

00:19:12,559 --> 00:19:15,600
overlays are still applied by the

00:19:14,240 --> 00:19:18,640
bootloader

00:19:15,600 --> 00:19:22,960
applying those at kernel runtime is is

00:19:18,640 --> 00:19:26,320
still something for later

00:19:22,960 --> 00:19:26,880
the second thing we're doing um heinrich

00:19:26,320 --> 00:19:30,240
shukart

00:19:26,880 --> 00:19:33,760
has done great work in defining a api

00:19:30,240 --> 00:19:34,559
a uefi based api that can reside in the

00:19:33,760 --> 00:19:36,880
firmware

00:19:34,559 --> 00:19:39,440
that the os boot managers can call when

00:19:36,880 --> 00:19:41,280
they do want to override the dtb

00:19:39,440 --> 00:19:43,120
and then the firmware can then fix up

00:19:41,280 --> 00:19:45,600
mac addresses serial numbers and things

00:19:43,120 --> 00:19:47,679
like that

00:19:45,600 --> 00:19:48,799
thirdly we're working on a proof of

00:19:47,679 --> 00:19:52,640
concept

00:19:48,799 --> 00:19:53,919
so that it's qemu based but we're doing

00:19:52,640 --> 00:19:56,080
it in a way that can be

00:19:53,919 --> 00:19:57,919
hopefully replicated on real hardware

00:19:56,080 --> 00:20:00,799
that really shows the dtb

00:19:57,919 --> 00:20:02,880
coming from the firmware in a real

00:20:00,799 --> 00:20:06,320
system with grub in the path

00:20:02,880 --> 00:20:07,760
um having the dtb independently

00:20:06,320 --> 00:20:10,880
updatable

00:20:07,760 --> 00:20:12,640
and prove that all that works

00:20:10,880 --> 00:20:14,799
so what we're trying to do in the next

00:20:12,640 --> 00:20:18,720
six to 12 months

00:20:14,799 --> 00:20:19,520
is we want to finish that work with the

00:20:18,720 --> 00:20:22,640
f

00:20:19,520 --> 00:20:26,080
grub being able to do firmware fix up

00:20:22,640 --> 00:20:27,360
we want to start doing dtb abi stability

00:20:26,080 --> 00:20:30,000
where we test

00:20:27,360 --> 00:20:31,600
the very latest kernel against dtbs from

00:20:30,000 --> 00:20:34,960
one or two years ago

00:20:31,600 --> 00:20:36,640
and so we start detecting immediately

00:20:34,960 --> 00:20:37,600
when changes are made to the upstream

00:20:36,640 --> 00:20:40,480
kernel that will

00:20:37,600 --> 00:20:43,520
break dtb abi compatibility we'll start

00:20:40,480 --> 00:20:46,640
small and build on that

00:20:43,520 --> 00:20:48,559
there's been effort there was a previous

00:20:46,640 --> 00:20:49,440
effort to try to get everybody to put

00:20:48,559 --> 00:20:52,000
all the

00:20:49,440 --> 00:20:53,760
device resource in one place that's kind

00:20:52,000 --> 00:20:56,320
of been rejected by the

00:20:53,760 --> 00:20:57,679
community at least for now and so what

00:20:56,320 --> 00:21:01,280
we want to do is provide

00:20:57,679 --> 00:21:02,799
tooling to the project maintainers so

00:21:01,280 --> 00:21:05,520
they can detect

00:21:02,799 --> 00:21:06,480
when their project is out of sync with

00:21:05,520 --> 00:21:09,520
other projects

00:21:06,480 --> 00:21:11,760
that they may consider more upstream

00:21:09,520 --> 00:21:13,600
so this is an honor system it's it's a

00:21:11,760 --> 00:21:15,679
tool that the project maintainers can

00:21:13,600 --> 00:21:17,440
use to help them know

00:21:15,679 --> 00:21:19,679
and then finally we're working on

00:21:17,440 --> 00:21:22,320
defining the dtb

00:21:19,679 --> 00:21:23,679
file and memory format enhancements

00:21:22,320 --> 00:21:24,880
there's been a lot of enhancements

00:21:23,679 --> 00:21:28,640
suggested over

00:21:24,880 --> 00:21:31,039
over the years not all of them will be

00:21:28,640 --> 00:21:32,720
make it in but we really are hoping to

00:21:31,039 --> 00:21:36,880
have a

00:21:32,720 --> 00:21:36,880
plan of record for the next format

00:21:40,480 --> 00:21:44,480
all right so i hope that you agree that

00:21:43,120 --> 00:21:48,320
there's a lot of stuff

00:21:44,480 --> 00:21:51,360
exciting stuff going on with device tree

00:21:48,320 --> 00:21:53,440
both innovation and standardization

00:21:51,360 --> 00:21:54,720
we're not taking any questions in this

00:21:53,440 --> 00:21:56,480
session

00:21:54,720 --> 00:21:58,480
but there is a bird of feather session

00:21:56,480 --> 00:22:00,960
immediately following this

00:21:58,480 --> 00:22:01,760
and so we look forward to taking your

00:22:00,960 --> 00:22:04,640
questions

00:22:01,760 --> 00:22:06,760
during that bird of a feather we'd all

00:22:04,640 --> 00:22:09,760
like to thank you for your attention

00:22:06,760 --> 00:22:09,760

YouTube URL: https://www.youtube.com/watch?v=N1NUbjVHb_U


