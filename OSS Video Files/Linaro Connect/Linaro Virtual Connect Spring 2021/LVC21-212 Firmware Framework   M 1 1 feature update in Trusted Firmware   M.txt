Title: LVC21-212 Firmware Framework   M 1 1 feature update in Trusted Firmware   M
Publication date: 2021-04-15
Playlist: Linaro Virtual Connect Spring 2021
Description: 
	Trusted Firmware - M (TFM) supports the Firmware Framework - M (FF-M) 1.0 features to demonstrates the usage of PSA compliance secure software. The collected usage feedbacks showcases important points users care about, such as the interrupt usage, calling efficiency and conceptual items clarification.

FF-M is updating to 1.1 to address the feedbacks, including an updated interrupt handling model, improved calling efficiency by simplifying both client API and service implementation model, clearer clarification on isolation boundaries, rules and domains. TFM would update to represent these changes in the specification.

This topic describes the FF-M 1.1 features update plan and technical pre-design inside TFM. The goal of this update is to provide a better user experience while implementing a PSA compliance system with TFM.
Captions: 
	00:00:05,920 --> 00:00:10,960
hi everyone

00:00:07,600 --> 00:00:13,679
uh this is came from arm china

00:00:10,960 --> 00:00:14,960
uh to introduce something some update

00:00:13,679 --> 00:00:19,359
what happened inside the

00:00:14,960 --> 00:00:22,240
tfm trust the formula m to follow the

00:00:19,359 --> 00:00:22,880
updated in the specification firmware

00:00:22,240 --> 00:00:25,039
framework

00:00:22,880 --> 00:00:25,039
m

00:00:26,000 --> 00:00:29,439
so let's recall something about the

00:00:28,560 --> 00:00:32,960
firmware

00:00:29,439 --> 00:00:36,480
m firmware framework m is a

00:00:32,960 --> 00:00:38,160
specification it's one of their psa

00:00:36,480 --> 00:00:40,559
this is the platform security

00:00:38,160 --> 00:00:44,160
architecture

00:00:40,559 --> 00:00:48,480
the psa specification families

00:00:44,160 --> 00:00:50,719
and provides a provides a

00:00:48,480 --> 00:00:52,239
sterilizer interface and programming

00:00:50,719 --> 00:00:56,719
environment for their

00:00:52,239 --> 00:00:59,199
secure applications on cortex-m devices

00:00:56,719 --> 00:01:02,079
tfm provides a reference implementation

00:00:59,199 --> 00:01:05,680
of this standard specification

00:01:02,079 --> 00:01:10,000
and the feedback for the existing

00:01:05,680 --> 00:01:13,280
implementation of tfm which is a ffm

00:01:10,000 --> 00:01:15,040
a one point database shows that there

00:01:13,280 --> 00:01:18,320
are some challenges

00:01:15,040 --> 00:01:19,920
if we are adapting their existing

00:01:18,320 --> 00:01:23,040
implementation

00:01:19,920 --> 00:01:26,400
on our simplest system so

00:01:23,040 --> 00:01:29,680
their specifications get updated to

00:01:26,400 --> 00:01:31,360
trace their challenges

00:01:29,680 --> 00:01:33,280
and the tfm as a reference

00:01:31,360 --> 00:01:40,799
implementation needs to be

00:01:33,280 --> 00:01:44,560
updated to follow the spectrum update

00:01:40,799 --> 00:01:48,720
the object many happens on below points

00:01:44,560 --> 00:01:50,000
the first one is a introduce our secure

00:01:48,720 --> 00:01:53,600
function model into the

00:01:50,000 --> 00:01:57,040
implementation and because in the

00:01:53,600 --> 00:01:58,000
firmware pharmacm we want we one point

00:01:57,040 --> 00:02:01,439
the other vision

00:01:58,000 --> 00:02:01,439
there's only rpc model

00:02:01,520 --> 00:02:09,119
uh inside the uh secure

00:02:05,840 --> 00:02:10,160
environment so this involves some

00:02:09,119 --> 00:02:12,640
overheads

00:02:10,160 --> 00:02:14,160
for the calling because they are rpc

00:02:12,640 --> 00:02:16,080
which is their inter-process

00:02:14,160 --> 00:02:18,160
communication

00:02:16,080 --> 00:02:19,280
these are the recorded there keep

00:02:18,160 --> 00:02:22,560
pulling for the

00:02:19,280 --> 00:02:23,599
signals it is signal driven every every

00:02:22,560 --> 00:02:26,480
partition

00:02:23,599 --> 00:02:28,160
partition is a service state to provide

00:02:26,480 --> 00:02:30,400
a bandwidth

00:02:28,160 --> 00:02:32,400
go to its own thread and keep pulling

00:02:30,400 --> 00:02:35,120
for their signals and handling that

00:02:32,400 --> 00:02:37,840
there's a similar handling logic in

00:02:35,120 --> 00:02:37,840
every partition

00:02:38,720 --> 00:02:43,599
and this is the overhead and the

00:02:42,000 --> 00:02:45,120
position involves the schedule there

00:02:43,599 --> 00:02:47,680
because they are

00:02:45,120 --> 00:02:48,480
we got a threes so we need a scheduler

00:02:47,680 --> 00:02:51,760
the children

00:02:48,480 --> 00:02:54,319
schedule cause some other cycles while

00:02:51,760 --> 00:02:57,840
executing

00:02:54,319 --> 00:03:00,000
so we need we

00:02:57,840 --> 00:03:00,879
need to involve introduce the sql

00:03:00,000 --> 00:03:03,680
function modeling to the

00:03:00,879 --> 00:03:05,920
implementation the sql function model

00:03:03,680 --> 00:03:07,280
and mentioning the firmware framework oe

00:03:05,920 --> 00:03:09,760
1.1

00:03:07,280 --> 00:03:11,519
simplifies the spm implementation inside

00:03:09,760 --> 00:03:13,599
stftfm

00:03:11,519 --> 00:03:16,159
and to make the service accessing more

00:03:13,599 --> 00:03:18,640
like a function call into a library

00:03:16,159 --> 00:03:19,200
it saves the cost spent on the rpc long

00:03:18,640 --> 00:03:22,800
time

00:03:19,200 --> 00:03:26,799
logic also the memory mapped eyewear

00:03:22,800 --> 00:03:29,760
accessing is possible to access their

00:03:26,799 --> 00:03:34,720
client memory directly in a service this

00:03:29,760 --> 00:03:37,040
is quite useful for their simpler system

00:03:34,720 --> 00:03:39,519
and also we earned we were involved they

00:03:37,040 --> 00:03:42,560
are stellar solution services

00:03:39,519 --> 00:03:45,360
uh because the uh one point data is uh

00:03:42,560 --> 00:03:48,159
the other servicing model is a

00:03:45,360 --> 00:03:50,560
connection based we need to uh

00:03:48,159 --> 00:03:52,000
grab a connection before accessing any

00:03:50,560 --> 00:03:53,840
services

00:03:52,000 --> 00:03:55,680
but there are services like it's just

00:03:53,840 --> 00:03:59,200
one shot or simple enough or

00:03:55,680 --> 00:04:01,519
or does not uh it does not need to

00:03:59,200 --> 00:04:03,920
maintain our connection and maintain the

00:04:01,519 --> 00:04:07,360
status

00:04:03,920 --> 00:04:08,319
so we instilled this feature to address

00:04:07,360 --> 00:04:10,720
their

00:04:08,319 --> 00:04:12,879
losing very simple services or some

00:04:10,720 --> 00:04:15,120
direct services

00:04:12,879 --> 00:04:17,359
and the interrupt handling in the one

00:04:15,120 --> 00:04:20,560
point there though

00:04:17,359 --> 00:04:22,160
it's a signal based mechanism uh for the

00:04:20,560 --> 00:04:24,080
interrupt handling when the incor

00:04:22,160 --> 00:04:26,720
encrypt has come

00:04:24,080 --> 00:04:28,080
uh the spm will convert link chapter

00:04:26,720 --> 00:04:31,360
handling into a signal and

00:04:28,080 --> 00:04:34,000
deliver that to the straight because the

00:04:31,360 --> 00:04:34,960
and there we lack the interrupter

00:04:34,000 --> 00:04:37,840
control apis

00:04:34,960 --> 00:04:38,800
inside in the uh one point the other

00:04:37,840 --> 00:04:41,040
region because

00:04:38,800 --> 00:04:42,080
if at one point where the other vision

00:04:41,040 --> 00:04:45,120
assumes that

00:04:42,080 --> 00:04:48,400
the peripheral mmorio interface can

00:04:45,120 --> 00:04:51,199
provide enough control and

00:04:48,400 --> 00:04:52,639
to the interrupt and there also are some

00:04:51,199 --> 00:04:55,199
other improvements and

00:04:52,639 --> 00:04:57,840
compatibility things updating this

00:04:55,199 --> 00:04:57,840
specification

00:04:59,280 --> 00:05:03,039
so here we go they are go through the

00:05:01,280 --> 00:05:05,039
items one by one first is the sql

00:05:03,039 --> 00:05:06,080
function implementation to the left side

00:05:05,039 --> 00:05:10,080
is the

00:05:06,080 --> 00:05:12,720
1.0 rpc based uh

00:05:10,080 --> 00:05:14,639
implementation so we would involve the

00:05:12,720 --> 00:05:15,680
sql function based implementation into

00:05:14,639 --> 00:05:19,440
jfm

00:05:15,680 --> 00:05:22,160
so the the blue columns here are the

00:05:19,440 --> 00:05:22,160
interfaces

00:05:23,600 --> 00:05:30,960
and the sap manager interfaces right

00:05:27,600 --> 00:05:31,759
so the service has to be accessed by the

00:05:30,960 --> 00:05:34,800
uh

00:05:31,759 --> 00:05:37,440
by the uh specification defined api so

00:05:34,800 --> 00:05:38,639
so the svm got a good chance to control

00:05:37,440 --> 00:05:42,560
their

00:05:38,639 --> 00:05:43,840
api and do some uh necessary jobs for

00:05:42,560 --> 00:05:47,520
their services

00:05:43,840 --> 00:05:49,520
for example the primary validation

00:05:47,520 --> 00:05:50,880
or the some policy service accessing

00:05:49,520 --> 00:05:53,199
policy registration

00:05:50,880 --> 00:05:55,280
before delivering a call to into the

00:05:53,199 --> 00:05:58,080
services

00:05:55,280 --> 00:05:58,880
so that's the reason why we still need a

00:05:58,080 --> 00:06:02,880
cspm

00:05:58,880 --> 00:06:02,880
in the sql function model

00:06:03,759 --> 00:06:07,360
and here's the necessary manifesto

00:06:05,520 --> 00:06:10,400
changes for the partitions

00:06:07,360 --> 00:06:12,080
we got a new keyword model to indicate

00:06:10,400 --> 00:06:16,240
which kind of partition

00:06:12,080 --> 00:06:19,600
and it is it can be rpc or sfm

00:06:16,240 --> 00:06:21,840
and we changed the intro point for the

00:06:19,600 --> 00:06:24,319
entry point keyboard for

00:06:21,840 --> 00:06:26,960
the partitions bits depends on the

00:06:24,319 --> 00:06:26,960
partition type

00:06:27,120 --> 00:06:31,360
if there is a if it is rpc position it

00:06:29,440 --> 00:06:34,560
is the key what is the intro point

00:06:31,360 --> 00:06:35,680
it is the main point of the threat so we

00:06:34,560 --> 00:06:39,199
can do necessary

00:06:35,680 --> 00:06:41,440
initialization in that uh enter and

00:06:39,199 --> 00:06:43,120
uh keep a pulling for signals and if the

00:06:41,440 --> 00:06:46,000
model is as i know as a

00:06:43,120 --> 00:06:46,560
sfn then the keyboard isn't trying it it

00:06:46,000 --> 00:06:49,440
provides

00:06:46,560 --> 00:06:51,360
a function to let the partition got a

00:06:49,440 --> 00:06:54,160
chance to initialize

00:06:51,360 --> 00:06:54,400
some internal data structures and all

00:06:54,160 --> 00:06:56,000
the

00:06:54,400 --> 00:06:57,840
services has to be converted into

00:06:56,000 --> 00:06:59,360
callback functions

00:06:57,840 --> 00:07:02,240
the callback function is the permit for

00:06:59,360 --> 00:07:03,280
the callback function steer is the

00:07:02,240 --> 00:07:05,599
message

00:07:03,280 --> 00:07:06,880
still the message because we want to

00:07:05,599 --> 00:07:09,520
make the

00:07:06,880 --> 00:07:10,240
partition migration easier from a pc

00:07:09,520 --> 00:07:12,960
mode to the

00:07:10,240 --> 00:07:12,960
sfm mode

00:07:14,000 --> 00:07:18,800
so this path shows a conceptual

00:07:16,400 --> 00:07:21,199
conceptual boundaries and call types

00:07:18,800 --> 00:07:22,639
what would happen between the clients

00:07:21,199 --> 00:07:26,000
and the services

00:07:22,639 --> 00:07:30,000
so if there if this uh target service

00:07:26,000 --> 00:07:32,400
go to uh got its own stackpot stack then

00:07:30,000 --> 00:07:34,319
with the call need to switch the stock

00:07:32,400 --> 00:07:36,160
and if there are target services that

00:07:34,319 --> 00:07:36,800
rely on the caller to provide a stack

00:07:36,160 --> 00:07:38,400
which means that

00:07:36,800 --> 00:07:40,240
there's no boundary between the client

00:07:38,400 --> 00:07:44,400
and the service then we just

00:07:40,240 --> 00:07:46,160
do a plain function call and if their

00:07:44,400 --> 00:07:47,919
core needs to cross their security

00:07:46,160 --> 00:07:51,599
boundary for example

00:07:47,919 --> 00:07:54,080
uh unprovided a router uh services want

00:07:51,599 --> 00:07:57,440
to access their

00:07:54,080 --> 00:07:59,360
access are privileged prelude means that

00:07:57,440 --> 00:08:02,000
psa little trust

00:07:59,360 --> 00:08:03,440
services needs to cross this corporate

00:08:02,000 --> 00:08:06,879
nation with the help of the

00:08:03,440 --> 00:08:06,879
supervisor call to do that

00:08:08,960 --> 00:08:12,319
and after the sequel function model is

00:08:11,120 --> 00:08:14,000
getting involved

00:08:12,319 --> 00:08:15,520
a hybrid model is still possible which

00:08:14,000 --> 00:08:18,879
means that this uh

00:08:15,520 --> 00:08:21,440
system still could support both types of

00:08:18,879 --> 00:08:21,440
partitions

00:08:22,479 --> 00:08:28,400
and the uh yeah here i describe

00:08:25,520 --> 00:08:30,639
them into two main blocks so this this

00:08:28,400 --> 00:08:32,640
block one and block two can be uh

00:08:30,639 --> 00:08:34,080
provided individually by the

00:08:32,640 --> 00:08:36,479
implementation

00:08:34,080 --> 00:08:38,240
uh and players can just implement the

00:08:36,479 --> 00:08:41,120
secure function model

00:08:38,240 --> 00:08:43,360
uh so that the uh the horses mode would

00:08:41,120 --> 00:08:45,839
be quite a simple

00:08:43,360 --> 00:08:47,040
and it is good for the simplest system

00:08:45,839 --> 00:08:49,440
and the the two

00:08:47,040 --> 00:08:50,640
is the legacy uh ipc mod implementation

00:08:49,440 --> 00:08:54,480
what do we have now

00:08:50,640 --> 00:08:56,240
we have now yeah so yeah the hybrid

00:08:54,480 --> 00:09:00,240
model provided possibility to uh

00:08:56,240 --> 00:09:00,240
let them work together inside the system

00:09:01,040 --> 00:09:04,800
then the memory mapped io it is optional

00:09:03,440 --> 00:09:08,399
feature because there are

00:09:04,800 --> 00:09:10,399
it needs to be reviewed before involving

00:09:08,399 --> 00:09:13,360
into the system because direct accessing

00:09:10,399 --> 00:09:18,080
the client memory address error

00:09:13,360 --> 00:09:20,480
may bring some security concerns

00:09:18,080 --> 00:09:21,200
so the basic idea is that we provide a

00:09:20,480 --> 00:09:24,080
mechanism

00:09:21,200 --> 00:09:24,560
that we can map the client address into

00:09:24,080 --> 00:09:27,920
the

00:09:24,560 --> 00:09:28,240
service memory space so that a service

00:09:27,920 --> 00:09:31,040
can

00:09:28,240 --> 00:09:32,080
access the client to memory directly

00:09:31,040 --> 00:09:35,040
without a

00:09:32,080 --> 00:09:37,519
locking or looking a local buffer and

00:09:35,040 --> 00:09:38,640
use ps3 lite to copy the client content

00:09:37,519 --> 00:09:42,560
into local buffer

00:09:38,640 --> 00:09:45,839
so this will save some excursion circles

00:09:42,560 --> 00:09:47,519
on memory movement so there are some

00:09:45,839 --> 00:09:50,800
details described in this page

00:09:47,519 --> 00:09:54,000
so we can just we can go through them

00:09:50,800 --> 00:09:54,000
later offline

00:09:55,040 --> 00:10:00,959
so the memory mapper ioc the

00:09:56,880 --> 00:10:04,480
implementation involves their four apis

00:10:00,959 --> 00:10:07,920
into their system and then there's a

00:10:04,480 --> 00:10:11,120
switch to indicate if this feature is uh

00:10:07,920 --> 00:10:12,640
available or not in the system so that

00:10:11,120 --> 00:10:17,440
partition can decide

00:10:12,640 --> 00:10:20,640
if it in the build time to know if it

00:10:17,440 --> 00:10:22,959
can implement

00:10:20,640 --> 00:10:25,680
implemented this service based on this

00:10:22,959 --> 00:10:25,680
these apis

00:10:27,920 --> 00:10:32,880
here's the ideal proposals for the mmi

00:10:31,040 --> 00:10:36,160
work of functionalities

00:10:32,880 --> 00:10:38,720
uh because for example it has not

00:10:36,160 --> 00:10:40,320
recommended inside our ipc based

00:10:38,720 --> 00:10:42,880
partition because our pc

00:10:40,320 --> 00:10:44,079
that the go or rpc provides enough

00:10:42,880 --> 00:10:47,200
isolation

00:10:44,079 --> 00:10:49,760
so it does not uh recommended in their

00:10:47,200 --> 00:10:51,519
rpc partition but for the sfa function

00:10:49,760 --> 00:10:52,240
it is a conditionally unload if the

00:10:51,519 --> 00:10:54,160
system is

00:10:52,240 --> 00:10:57,519
simple enough and it does not have

00:10:54,160 --> 00:10:57,519
various streams really uh

00:10:58,000 --> 00:11:02,560
system features what uh there's two but

00:11:00,959 --> 00:11:05,200
they are security consideration then it

00:11:02,560 --> 00:11:05,200
is all loaded

00:11:06,800 --> 00:11:11,920
okay then here comes the another another

00:11:09,200 --> 00:11:13,760
part to simplify the client side

00:11:11,920 --> 00:11:15,760
uh as we mentioned before the others

00:11:13,760 --> 00:11:18,560
there are services that uh it's

00:11:15,760 --> 00:11:19,360
quite same point just just one shot

00:11:18,560 --> 00:11:21,600
simple enough

00:11:19,360 --> 00:11:22,880
and oh it does not need to maintain our

00:11:21,600 --> 00:11:26,320
connection state

00:11:22,880 --> 00:11:29,120
it's a certain status service then it

00:11:26,320 --> 00:11:31,200
does not need to connect to a locator

00:11:29,120 --> 00:11:34,000
handle every time

00:11:31,200 --> 00:11:34,800
so on one point there though we just we

00:11:34,000 --> 00:11:37,120
just can

00:11:34,800 --> 00:11:38,959
we can do the accessory service in two

00:11:37,120 --> 00:11:40,399
ways with a is that we save a hana

00:11:38,959 --> 00:11:42,240
somewhere

00:11:40,399 --> 00:11:43,839
and access the service with let's save

00:11:42,240 --> 00:11:46,000
the handle every time

00:11:43,839 --> 00:11:47,040
the b is we all we connect to the

00:11:46,000 --> 00:11:50,399
service every time

00:11:47,040 --> 00:11:53,800
and call into it and then close it

00:11:50,399 --> 00:11:55,040
so both method looks not

00:11:53,800 --> 00:11:58,160
[Music]

00:11:55,040 --> 00:12:01,600
good enough right so here uh

00:11:58,160 --> 00:12:02,639
so in the 1.1 we involve the staircase

00:12:01,600 --> 00:12:05,120
load services

00:12:02,639 --> 00:12:06,959
so these services will have a predefined

00:12:05,120 --> 00:12:10,160
stat aesthetically defined

00:12:06,959 --> 00:12:13,440
a handle to let the client to access

00:12:10,160 --> 00:12:16,639
into that so if you are

00:12:13,440 --> 00:12:17,839
mentioning our service with a keyword

00:12:16,639 --> 00:12:21,680
status handle

00:12:17,839 --> 00:12:23,519
then it will generate a static defined

00:12:21,680 --> 00:12:25,279
handle value for declines in your header

00:12:23,519 --> 00:12:27,040
file so the header file who the client

00:12:25,279 --> 00:12:28,560
just can access that service with this

00:12:27,040 --> 00:12:30,240
deck handle

00:12:28,560 --> 00:12:32,560
the region checking and policy

00:12:30,240 --> 00:12:35,519
dependency checking for the services

00:12:32,560 --> 00:12:36,800
would still be performed while the ps

00:12:35,519 --> 00:12:39,839
core is happening

00:12:36,800 --> 00:12:39,839
so no worry about that

00:12:42,240 --> 00:12:45,600
there's still lots with handling

00:12:44,160 --> 00:12:48,720
implementation inside the

00:12:45,600 --> 00:12:52,880
spm it's uh it's quite

00:12:48,720 --> 00:12:54,639
straight so the the connection based

00:12:52,880 --> 00:12:56,160
connection handles would be maintained

00:12:54,639 --> 00:12:58,000
inside a module in

00:12:56,160 --> 00:12:59,839
we would all look at the memory for that

00:12:58,000 --> 00:13:03,120
to maintain the connections

00:12:59,839 --> 00:13:05,680
for these these are third list service

00:13:03,120 --> 00:13:06,720
root service handlers we just find the

00:13:05,680 --> 00:13:10,399
value

00:13:06,720 --> 00:13:14,320
and find the target service from the

00:13:10,399 --> 00:13:15,839
value based on the value and then just

00:13:14,320 --> 00:13:20,399
deliver the message and record

00:13:15,839 --> 00:13:22,560
requesting to that service

00:13:20,399 --> 00:13:24,160
and the next thing is about the

00:13:22,560 --> 00:13:24,959
peripheral support it's mainly about the

00:13:24,160 --> 00:13:27,920
interrupt

00:13:24,959 --> 00:13:28,240
so the reason we have uh i just i just

00:13:27,920 --> 00:13:31,440
just

00:13:28,240 --> 00:13:32,160
asked i had uh talked at the beginning

00:13:31,440 --> 00:13:35,760
so

00:13:32,160 --> 00:13:38,399
we at one point data api with the

00:13:35,760 --> 00:13:38,800
uh introduced a very simple design so it

00:13:38,399 --> 00:13:41,440
just

00:13:38,800 --> 00:13:43,199
uses a threaded signal-based encrypted

00:13:41,440 --> 00:13:44,959
handling for the partitions

00:13:43,199 --> 00:13:46,240
and the lack of the encrypted counter

00:13:44,959 --> 00:13:49,760
apis

00:13:46,240 --> 00:13:50,399
so we uh in one point one we involved

00:13:49,760 --> 00:13:51,839
two things

00:13:50,399 --> 00:13:54,880
the first thing is that encrypted

00:13:51,839 --> 00:13:56,560
control apis the second thing is the art

00:13:54,880 --> 00:13:58,560
uh we provide a check we provide a

00:13:56,560 --> 00:14:00,880
chance that the sql partition could uh

00:13:58,560 --> 00:14:02,639
handle the encrypted in a boundary time

00:14:00,880 --> 00:14:06,480
very quickly but with

00:14:02,639 --> 00:14:06,480
limited api calls

00:14:08,480 --> 00:14:13,760
this is the diagram so the most left

00:14:11,920 --> 00:14:16,959
side is the

00:14:13,760 --> 00:14:18,000
implementation we have now uh in the 1.1

00:14:16,959 --> 00:14:20,320
region we still

00:14:18,000 --> 00:14:21,279
support this this implementation because

00:14:20,320 --> 00:14:24,160
some are

00:14:21,279 --> 00:14:24,880
some partition may just have a very

00:14:24,160 --> 00:14:26,560
relaxed

00:14:24,880 --> 00:14:28,959
interrupt handling it does not care

00:14:26,560 --> 00:14:30,720
about the boundary time

00:14:28,959 --> 00:14:33,760
so you can it still can wait for the

00:14:30,720 --> 00:14:37,120
signal to handle interrupt

00:14:33,760 --> 00:14:38,880
and uh yeah so indeed in one point one

00:14:37,120 --> 00:14:40,880
we provided encrypted control api so

00:14:38,880 --> 00:14:44,560
compared to one point there the laser

00:14:40,880 --> 00:14:46,800
to us several interpreter control api

00:14:44,560 --> 00:14:48,639
but still can this partition still can

00:14:46,800 --> 00:14:52,399
handle the encrypted with signal

00:14:48,639 --> 00:14:54,959
and the middle is uh their position

00:14:52,399 --> 00:14:56,000
has provided a callback callback the

00:14:54,959 --> 00:14:58,480
interrupt handling

00:14:56,000 --> 00:14:59,279
functions so when the internet interrupt

00:14:58,480 --> 00:15:01,519
has uh

00:14:59,279 --> 00:15:02,560
tracked the svm would according to the

00:15:01,519 --> 00:15:04,639
partition and

00:15:02,560 --> 00:15:06,880
encrypted handling to let the partition

00:15:04,639 --> 00:15:09,519
handle the impact immediately

00:15:06,880 --> 00:15:10,160
and the patient can decide if he need it

00:15:09,519 --> 00:15:12,079
needs to

00:15:10,160 --> 00:15:13,760
deliver the signal to their partition

00:15:12,079 --> 00:15:16,079
threat or not

00:15:13,760 --> 00:15:18,000
so the right side is a complicated

00:15:16,079 --> 00:15:21,199
complete most complicated case

00:15:18,000 --> 00:15:22,240
the partition desired caller frh which

00:15:21,199 --> 00:15:24,399
is their first leveling

00:15:22,240 --> 00:15:25,279
handling and decided to deliver signal

00:15:24,399 --> 00:15:27,839
to the

00:15:25,279 --> 00:15:29,759
thread which is which is this uh second

00:15:27,839 --> 00:15:32,800
level interrupt handling

00:15:29,759 --> 00:15:33,759
so yeah so the thread can finally go to

00:15:32,800 --> 00:15:37,839
a signal

00:15:33,759 --> 00:15:40,639
for it yeah

00:15:37,839 --> 00:15:42,560
so when we involve the institute is

00:15:40,639 --> 00:15:44,480
interrupting to their secure world then

00:15:42,560 --> 00:15:45,199
there are one thing need to need to be

00:15:44,480 --> 00:15:48,079
discussed

00:15:45,199 --> 00:15:48,399
is about the secure idling processing

00:15:48,079 --> 00:15:52,240
and

00:15:48,399 --> 00:15:55,440
their skill internal handling

00:15:52,240 --> 00:15:58,399
because especially on the trust

00:15:55,440 --> 00:15:59,040
zone based implementation uh there will

00:15:58,399 --> 00:16:01,040
be cases

00:15:59,040 --> 00:16:02,560
that all their secure executions are

00:16:01,040 --> 00:16:04,959
waiting for are

00:16:02,560 --> 00:16:07,600
ready for the interrupts so their

00:16:04,959 --> 00:16:09,759
excursion can be idle

00:16:07,600 --> 00:16:11,199
then it is time to decide if we need to

00:16:09,759 --> 00:16:12,480
deliver the excursion back to the

00:16:11,199 --> 00:16:16,639
non-square to let them

00:16:12,480 --> 00:16:19,279
have their chance to execute

00:16:16,639 --> 00:16:19,920
so here there here covers two two types

00:16:19,279 --> 00:16:22,000
of

00:16:19,920 --> 00:16:24,240
points the first point is that if uh if

00:16:22,000 --> 00:16:27,440
our interpreter is handle

00:16:24,240 --> 00:16:28,880
securing type com and it preempts a

00:16:27,440 --> 00:16:32,000
non-secure execution

00:16:28,880 --> 00:16:35,040
we just uh finish the fire execution and

00:16:32,000 --> 00:16:35,680
we don't schedule within the schedule in

00:16:35,040 --> 00:16:38,480
their

00:16:35,680 --> 00:16:39,360
secure side because we are not sure what

00:16:38,480 --> 00:16:41,040
kind of their

00:16:39,360 --> 00:16:43,279
environment that we have implemented in

00:16:41,040 --> 00:16:44,079
the nascar side so we deliver the excuse

00:16:43,279 --> 00:16:47,839
back and let

00:16:44,079 --> 00:16:50,000
the non-school side continue to execute

00:16:47,839 --> 00:16:52,720
and when they're there all the skill

00:16:50,000 --> 00:16:56,320
excursion are waiting for

00:16:52,720 --> 00:16:59,440
for the interrupts we got uh two uh

00:16:56,320 --> 00:17:00,000
two uh possibilities to handle the idle

00:16:59,440 --> 00:17:02,959
status

00:17:00,000 --> 00:17:04,240
the first thing is that we call our wfi

00:17:02,959 --> 00:17:08,480
to go into the idle state

00:17:04,240 --> 00:17:10,400
in some of their chorus rate

00:17:08,480 --> 00:17:11,839
uh this is the easiest case so that the

00:17:10,400 --> 00:17:13,919
system will be going idle and

00:17:11,839 --> 00:17:15,760
the system will be wake up again by the

00:17:13,919 --> 00:17:16,319
interrupts including the non-screen

00:17:15,760 --> 00:17:18,720
traps

00:17:16,319 --> 00:17:19,919
if the non-screen side called somewhere

00:17:18,720 --> 00:17:23,039
cystic or something

00:17:19,919 --> 00:17:24,880
it can wake the system up and set you

00:17:23,039 --> 00:17:26,400
back to its own state

00:17:24,880 --> 00:17:28,880
another thing is that we provide some

00:17:26,400 --> 00:17:30,080
callback to let the knowledge go our

00:17:28,880 --> 00:17:32,320
side handle the

00:17:30,080 --> 00:17:34,559
secure audio status to decide where to

00:17:32,320 --> 00:17:34,559
go

00:17:36,480 --> 00:17:43,440
so here is our tour

00:17:40,320 --> 00:17:43,440
function prototype to

00:17:43,600 --> 00:17:47,440
describe the what's the function a copy

00:17:46,880 --> 00:17:50,080
function would

00:17:47,440 --> 00:17:51,760
what would they like the nonsense i need

00:17:50,080 --> 00:17:53,280
to register our idle

00:17:51,760 --> 00:17:54,880
callback function to this reward and

00:17:53,280 --> 00:17:57,039
secure what it would call back

00:17:54,880 --> 00:17:58,160
call them back while all the skill

00:17:57,039 --> 00:18:00,960
excursions are

00:17:58,160 --> 00:18:01,520
waiting for the crops so ideally the

00:18:00,960 --> 00:18:04,559
quarterbacks

00:18:01,520 --> 00:18:07,840
bound to each nazi threat if the nazi

00:18:04,559 --> 00:18:09,120
side got uh for example pagoda very

00:18:07,840 --> 00:18:12,080
strong isolation

00:18:09,120 --> 00:18:14,080
uh they need to bond they call back to

00:18:12,080 --> 00:18:18,400
each nazi strait

00:18:14,080 --> 00:18:22,640
and who needs to access the surfaces

00:18:18,400 --> 00:18:22,640
yeah that's the ideal case

00:18:22,720 --> 00:18:29,760
so let's the three main points and any

00:18:26,240 --> 00:18:32,640
some other tiny objects optics here

00:18:29,760 --> 00:18:33,200
happening inside the 1.1 region space

00:18:32,640 --> 00:18:36,080
fraction

00:18:33,200 --> 00:18:38,320
and the implementation is the division

00:18:36,080 --> 00:18:40,720
of the definition of root surfaces

00:18:38,320 --> 00:18:42,960
we need to update this region if we

00:18:40,720 --> 00:18:44,320
decided to upgrade their partition or

00:18:42,960 --> 00:18:48,000
the service into our

00:18:44,320 --> 00:18:49,520
one into 1.1 compatible

00:18:48,000 --> 00:18:51,760
and there are some correct cloud

00:18:49,520 --> 00:18:54,960
refractions or the lures of the psa

00:18:51,760 --> 00:18:57,679
services yeah and now psl

00:18:54,960 --> 00:18:58,320
switch there's no magnitude boundaries

00:18:57,679 --> 00:19:01,039
between the

00:18:58,320 --> 00:19:01,360
psa loader service are components but if

00:19:01,039 --> 00:19:02,960
we

00:19:01,360 --> 00:19:06,320
uh someone if the implementation

00:19:02,960 --> 00:19:08,559
provided one it has a plus

00:19:06,320 --> 00:19:10,640
and we will relax the memory access

00:19:08,559 --> 00:19:13,120
lures for their constant date

00:19:10,640 --> 00:19:15,200
in one point the other we required that

00:19:13,120 --> 00:19:15,440
their read-only date and the code should

00:19:15,200 --> 00:19:18,000
be

00:19:15,440 --> 00:19:21,520
isolated and which is not friendly for

00:19:18,000 --> 00:19:24,720
their simple system because they got a

00:19:21,520 --> 00:19:27,039
limited resource limited mpu for example

00:19:24,720 --> 00:19:29,360
so here we provide a lure to explain

00:19:27,039 --> 00:19:32,960
that we are relaxed there

00:19:29,360 --> 00:19:36,080
and lewis yeah and some other

00:19:32,960 --> 00:19:39,760
other tiny things going to buy update

00:19:36,080 --> 00:19:42,400
and the psa and the tfm implementation

00:19:39,760 --> 00:19:42,400
will cover that

00:19:42,880 --> 00:19:47,120
so this is the last page so the ff 1.1

00:19:46,559 --> 00:19:51,120
document

00:19:47,120 --> 00:19:52,799
update can be found here and the design

00:19:51,120 --> 00:19:54,799
just if we want to involve the

00:19:52,799 --> 00:19:56,400
achievement development and just

00:19:54,799 --> 00:19:59,760
discuss something about tfm you can

00:19:56,400 --> 00:20:03,200
register the mailing list of tfm

00:19:59,760 --> 00:20:06,000
or you can join their tfm technical

00:20:03,200 --> 00:20:08,000
form it's a bi-weekly meeting online we

00:20:06,000 --> 00:20:11,919
can talk something there

00:20:08,000 --> 00:20:21,120
okay so this is the last page

00:20:11,919 --> 00:20:23,200
so thank you

00:20:21,120 --> 00:20:35,840
let him switch the public channel c for

00:20:23,200 --> 00:20:35,840
any questions

00:20:41,120 --> 00:20:44,640
okay thank you so much ken

00:20:45,679 --> 00:20:49,360
i can't see any questions at the moment

00:20:47,919 --> 00:20:50,080
are you happy to stay on here a couple

00:20:49,360 --> 00:20:54,559
of more minutes

00:20:50,080 --> 00:20:56,799
just in case any questions come in yeah

00:20:54,559 --> 00:20:56,799
okay

00:20:57,919 --> 00:21:03,840
great sounds good

00:22:35,600 --> 00:22:39,200
okay well in that case uh thank you so

00:22:38,000 --> 00:22:42,400
much ken

00:22:39,200 --> 00:22:43,919
i will end the session now and if anyone

00:22:42,400 --> 00:22:45,280
has any questions

00:22:43,919 --> 00:22:47,120
if you think of anything after the

00:22:45,280 --> 00:22:50,159
session feel free to

00:22:47,120 --> 00:22:55,840
uh reach out to ken directly

00:22:50,159 --> 00:22:55,840

YouTube URL: https://www.youtube.com/watch?v=cxXJMG4f8dw


