Title: LVC21-309 SVE & SVE2 in LLVM
Publication date: 2021-04-15
Playlist: Linaro Virtual Connect Spring 2021
Description: 
	This session will cover:
•  A brief reminder of SVE and SVE2, and the challenges and opportunities they present for compilers
•  The status of SVE and SVE2 support in LLVM today (for both LLVM 12 and ToT)
•  Examples of use of C intrinsics (the Arm C Language Extension for SVE/SVE2) and various forms of autovectorization
•  Pointers to further resources
•  Our planned roadmap and how to get involved
Captions: 
	00:00:00,480 --> 00:00:06,160
hello my name is will i work for

00:00:03,679 --> 00:00:08,240
arm as part of the development solutions

00:00:06,160 --> 00:00:11,519
group compilers team

00:00:08,240 --> 00:00:14,960
and i'm going to talk about the status

00:00:11,519 --> 00:00:16,800
of sv and sv2 in llvm

00:00:14,960 --> 00:00:19,199
and have a look at some code examples

00:00:16,800 --> 00:00:20,240
that show what the compiler does with a

00:00:19,199 --> 00:00:23,519
piece of source code

00:00:20,240 --> 00:00:25,039
and how um how we've had to modify the

00:00:23,519 --> 00:00:28,960
compiler to support

00:00:25,039 --> 00:00:31,519
what sve is capable of okay so

00:00:28,960 --> 00:00:33,040
um there's a link here that if you

00:00:31,519 --> 00:00:34,239
follow you should be able to download

00:00:33,040 --> 00:00:36,160
the slides

00:00:34,239 --> 00:00:37,280
which will be useful later on because

00:00:36,160 --> 00:00:40,079
there's some other

00:00:37,280 --> 00:00:41,200
urls that um that you can follow and

00:00:40,079 --> 00:00:43,360
kind of play along

00:00:41,200 --> 00:00:44,480
while i go through some of the examples

00:00:43,360 --> 00:00:45,280
because we're going to be using an

00:00:44,480 --> 00:00:49,760
online tool

00:00:45,280 --> 00:00:51,520
called compiler explorer or godbolt and

00:00:49,760 --> 00:00:53,600
it's it's possible to follow those links

00:00:51,520 --> 00:00:56,800
and and see exactly the

00:00:53,600 --> 00:01:00,719
the code that i'm looking at

00:00:56,800 --> 00:01:03,680
okay so um briefly i'm going to

00:01:00,719 --> 00:01:04,640
introduce sve i'm going to assume that

00:01:03,680 --> 00:01:07,360
most people

00:01:04,640 --> 00:01:08,720
have tuned into this thread will be

00:01:07,360 --> 00:01:11,119
aware of sve but

00:01:08,720 --> 00:01:12,640
in case you're not the most important

00:01:11,119 --> 00:01:15,520
concept is that

00:01:12,640 --> 00:01:17,840
it is a vector architecture and that the

00:01:15,520 --> 00:01:20,880
architecture does not specify

00:01:17,840 --> 00:01:24,560
how wide those vectors are so they're

00:01:20,880 --> 00:01:28,400
they they're some multiple of 128 bits

00:01:24,560 --> 00:01:31,840
between 128 and 2048 and the

00:01:28,400 --> 00:01:32,880
um the implementation of sve gets to

00:01:31,840 --> 00:01:34,560
choose

00:01:32,880 --> 00:01:36,640
what's something what's an appropriate

00:01:34,560 --> 00:01:39,759
vector width would be for

00:01:36,640 --> 00:01:41,600
for their chip but the instructions are

00:01:39,759 --> 00:01:44,799
the same regardless of what

00:01:41,600 --> 00:01:45,680
has been chosen and there's a link here

00:01:44,799 --> 00:01:48,240
to

00:01:45,680 --> 00:01:48,720
much more in-depth information about sve

00:01:48,240 --> 00:01:50,479
so

00:01:48,720 --> 00:01:52,799
please follow that if you want to know

00:01:50,479 --> 00:01:55,119
more also i mentioned

00:01:52,799 --> 00:01:55,840
something called the acle which is the

00:01:55,119 --> 00:01:58,719
arm c

00:01:55,840 --> 00:02:00,079
language extensions which are a way of

00:01:58,719 --> 00:02:02,079
writing

00:02:00,079 --> 00:02:04,799
something similar to assembly code but

00:02:02,079 --> 00:02:06,399
in a more maintainable way

00:02:04,799 --> 00:02:08,239
i'm again i'm not going to talk about

00:02:06,399 --> 00:02:11,039
those in detail here except

00:02:08,239 --> 00:02:12,640
to talk about the status of them in llvm

00:02:11,039 --> 00:02:16,160
today

00:02:12,640 --> 00:02:17,680
so so here's where we are right now um

00:02:16,160 --> 00:02:19,440
since llvm9 we've had assembly and

00:02:17,680 --> 00:02:22,800
disassembly support since

00:02:19,440 --> 00:02:23,280
m11 we've had acle supports but that's

00:02:22,800 --> 00:02:26,720
been

00:02:23,280 --> 00:02:29,120
much improved with llvm12 which

00:02:26,720 --> 00:02:31,360
as i record this is very close to being

00:02:29,120 --> 00:02:32,319
released so i suspect by the time you

00:02:31,360 --> 00:02:35,200
see this

00:02:32,319 --> 00:02:36,640
lvm12 will have been released and it

00:02:35,200 --> 00:02:38,239
contains

00:02:36,640 --> 00:02:40,000
uh some significant improvements for the

00:02:38,239 --> 00:02:42,959
acle um

00:02:40,000 --> 00:02:43,519
as well as uh kind of proof of concept

00:02:42,959 --> 00:02:46,640
support

00:02:43,519 --> 00:02:47,360
for auto vectorization using sve i'm

00:02:46,640 --> 00:02:50,239
going to

00:02:47,360 --> 00:02:52,239
dive into what i mean by that as part of

00:02:50,239 --> 00:02:56,080
this talk

00:02:52,239 --> 00:02:58,000
so um this slide talks to where i love

00:02:56,080 --> 00:02:59,680
m12 is today and there's three sort of

00:02:58,000 --> 00:03:02,800
strands to

00:02:59,680 --> 00:03:05,519
enabling lvm for sve one is

00:03:02,800 --> 00:03:07,840
making sure you can do it safely for any

00:03:05,519 --> 00:03:10,959
code that a user gives you

00:03:07,840 --> 00:03:13,760
the second is to be able to use

00:03:10,959 --> 00:03:15,040
sv's features to vectorize as much code

00:03:13,760 --> 00:03:18,720
as possible

00:03:15,040 --> 00:03:20,959
and the third one is to generate

00:03:18,720 --> 00:03:21,760
the most efficient code possible

00:03:20,959 --> 00:03:24,879
ultimately the

00:03:21,760 --> 00:03:26,480
highest code quality that you can for a

00:03:24,879 --> 00:03:28,720
given vectorized loop

00:03:26,480 --> 00:03:30,959
and within lvm12 this is very much a

00:03:28,720 --> 00:03:33,360
proof of concept stage

00:03:30,959 --> 00:03:35,040
it is not universally safe so we don't

00:03:33,360 --> 00:03:36,959
enable it all the time you have to

00:03:35,040 --> 00:03:38,879
add a source primer which we will see

00:03:36,959 --> 00:03:41,280
shortly um

00:03:38,879 --> 00:03:42,640
our aim was to vectorize at least one

00:03:41,280 --> 00:03:45,599
loop end to end

00:03:42,640 --> 00:03:46,879
and as you'll see we've we've done that

00:03:45,599 --> 00:03:48,799
and there's no

00:03:46,879 --> 00:03:51,200
we didn't set ourselves any goals about

00:03:48,799 --> 00:03:52,799
code quality so there are definitely

00:03:51,200 --> 00:03:54,319
um there are definitely improvements

00:03:52,799 --> 00:03:57,439
that could be made about which

00:03:54,319 --> 00:03:58,720
instructions the compiler chooses to use

00:03:57,439 --> 00:04:00,480
then we'll come back to this slide at

00:03:58,720 --> 00:04:03,920
the end to talk about where we hope to

00:04:00,480 --> 00:04:06,000
get to for eleven thirteen and fourteen

00:04:03,920 --> 00:04:07,599
so the i'm going to spend most of my

00:04:06,000 --> 00:04:08,400
time looking through some of these

00:04:07,599 --> 00:04:11,519
examples

00:04:08,400 --> 00:04:13,200
um so i won't go into detail yet

00:04:11,519 --> 00:04:16,639
what these are we'll just jump straight

00:04:13,200 --> 00:04:18,479
in i just wanted to point out that the

00:04:16,639 --> 00:04:19,919
the set of examples i'm showing here are

00:04:18,479 --> 00:04:22,400
very much not um

00:04:19,919 --> 00:04:23,919
exhaustive of the kind of code that a

00:04:22,400 --> 00:04:26,639
compiler sees

00:04:23,919 --> 00:04:27,600
and there's some examples here of other

00:04:26,639 --> 00:04:31,120
topics

00:04:27,600 --> 00:04:33,840
that still need doing um but we

00:04:31,120 --> 00:04:34,400
we won't have time on the school to to

00:04:33,840 --> 00:04:36,479
uh

00:04:34,400 --> 00:04:39,440
to go through all of that so let's skip

00:04:36,479 --> 00:04:43,840
forward to our first example

00:04:39,440 --> 00:04:46,160
so if we follow the uh the link here

00:04:43,840 --> 00:04:48,160
and and hopefully the the real me will

00:04:46,160 --> 00:04:48,880
be with you right now and available on

00:04:48,160 --> 00:04:51,520
the chat so

00:04:48,880 --> 00:04:52,479
um unless i've been run over by a bus or

00:04:51,520 --> 00:04:55,840
something in the last

00:04:52,479 --> 00:04:57,040
two weeks then i should be pasting links

00:04:55,840 --> 00:05:00,080
to this

00:04:57,040 --> 00:05:00,080
so if we follow this link

00:05:00,160 --> 00:05:03,280
then you can see this is compiler

00:05:01,840 --> 00:05:06,320
explorer so

00:05:03,280 --> 00:05:07,680
this is a public website where you can

00:05:06,320 --> 00:05:10,479
put in some source code

00:05:07,680 --> 00:05:12,560
and have it compile with a range of

00:05:10,479 --> 00:05:14,800
compilers

00:05:12,560 --> 00:05:16,800
using some flags and it will show you

00:05:14,800 --> 00:05:18,479
the outputs and show you any errors that

00:05:16,800 --> 00:05:21,600
have been output

00:05:18,479 --> 00:05:22,320
so here we have a function that has a

00:05:21,600 --> 00:05:26,000
loop

00:05:22,320 --> 00:05:27,199
that multiplies uh the values in in two

00:05:26,000 --> 00:05:29,039
arrays together

00:05:27,199 --> 00:05:30,479
and stores the results into a third

00:05:29,039 --> 00:05:33,759
array

00:05:30,479 --> 00:05:37,199
and we've chosen to compile it using

00:05:33,759 --> 00:05:40,320
the top of trunk um

00:05:37,199 --> 00:05:41,680
llvm so clang is the the llvmc c plus

00:05:40,320 --> 00:05:45,120
plus compiler

00:05:41,680 --> 00:05:48,400
and uh this gets updated by by

00:05:45,120 --> 00:05:48,720
the godbolt site uh multiple times a day

00:05:48,400 --> 00:05:53,039
so

00:05:48,720 --> 00:05:55,600
it should be very up to date um

00:05:53,039 --> 00:05:56,800
we've given some flags that ask the

00:05:55,600 --> 00:06:00,479
compiler to

00:05:56,800 --> 00:06:05,360
optimize fairly aggressively ask it to

00:06:00,479 --> 00:06:08,800
optimize for neoverse v1 which is

00:06:05,360 --> 00:06:11,600
the first cpu designed by

00:06:08,800 --> 00:06:12,560
arm ourselves that implements sve

00:06:11,600 --> 00:06:16,639
there's also the

00:06:12,560 --> 00:06:19,360
the fujitsu a64 fx cpu made by fujitsu

00:06:16,639 --> 00:06:20,080
uh that implements sve but this is the

00:06:19,360 --> 00:06:23,759
the first

00:06:20,080 --> 00:06:25,759
arm design that has sve in it

00:06:23,759 --> 00:06:28,080
and we've also given another flag here

00:06:25,759 --> 00:06:31,120
that asks the compilers to generate some

00:06:28,080 --> 00:06:34,160
diagnostic outputs about

00:06:31,120 --> 00:06:37,120
loop optimizations so

00:06:34,160 --> 00:06:37,759
um what we can see here is the outputs

00:06:37,120 --> 00:06:40,479
and

00:06:37,759 --> 00:06:42,160
here we have some uh some some setup

00:06:40,479 --> 00:06:44,160
code at the start of the loop

00:06:42,160 --> 00:06:45,360
then we have a vectorized loop itself

00:06:44,160 --> 00:06:47,840
and then we have

00:06:45,360 --> 00:06:49,680
uh some some other code at the end we've

00:06:47,840 --> 00:06:50,319
got a scalar tail and some other bits

00:06:49,680 --> 00:06:52,479
and pieces

00:06:50,319 --> 00:06:54,240
that i'm not going to go into today and

00:06:52,479 --> 00:06:56,479
the first thing we want to do

00:06:54,240 --> 00:06:58,000
so this is example one by the way first

00:06:56,479 --> 00:07:00,000
thing we want to do as we get towards

00:06:58,000 --> 00:07:00,720
example two is to simplify the outputs

00:07:00,000 --> 00:07:02,479
code

00:07:00,720 --> 00:07:04,880
and we're going to play a few tricks to

00:07:02,479 --> 00:07:05,599
do that first of all this setup code

00:07:04,880 --> 00:07:09,360
here

00:07:05,599 --> 00:07:12,000
is not is only necessary because

00:07:09,360 --> 00:07:13,759
the compiler doesn't know if these three

00:07:12,000 --> 00:07:15,599
pointers overlap with each other

00:07:13,759 --> 00:07:17,520
or are close to each other and so it has

00:07:15,599 --> 00:07:20,560
to do some runtime checks

00:07:17,520 --> 00:07:24,319
so we're going to add a restrict

00:07:20,560 --> 00:07:25,360
keyword here um which tells the compiler

00:07:24,319 --> 00:07:27,520
that they don't have a lap

00:07:25,360 --> 00:07:30,560
and so so that that reduces the amount

00:07:27,520 --> 00:07:32,639
of the setup code needed and

00:07:30,560 --> 00:07:34,479
uh then also we can see if we look at

00:07:32,639 --> 00:07:37,120
the diagnostic happens

00:07:34,479 --> 00:07:38,560
that the the compiler is doing something

00:07:37,120 --> 00:07:42,240
called interleaving

00:07:38,560 --> 00:07:44,319
um which makes sense it may it

00:07:42,240 --> 00:07:45,759
it's a it's a good thing for for code

00:07:44,319 --> 00:07:47,919
quality but it makes

00:07:45,759 --> 00:07:49,280
this code more complicated so what we're

00:07:47,919 --> 00:07:52,080
going to do

00:07:49,280 --> 00:07:53,520
is add a pragma that that clang supports

00:07:52,080 --> 00:07:58,319
to disable that

00:07:53,520 --> 00:08:01,520
so we're going to say bag macline loop

00:07:58,319 --> 00:08:05,360
that will say interleave

00:08:01,520 --> 00:08:13,840
disable and we'll also while we're here

00:08:05,360 --> 00:08:13,840
disable unrolling

00:08:23,120 --> 00:08:28,560
okay we're good so now what we see is a

00:08:26,319 --> 00:08:30,080
significantly simpler vectorized loop

00:08:28,560 --> 00:08:32,479
this is neon code

00:08:30,080 --> 00:08:33,599
and it's do it's loading two values

00:08:32,479 --> 00:08:36,240
multiplying them together

00:08:33,599 --> 00:08:37,200
and storing out the results so now we're

00:08:36,240 --> 00:08:41,839
going to

00:08:37,200 --> 00:08:41,839
enable sve and

00:08:41,919 --> 00:08:46,320
one of the things the compiler has to do

00:08:44,240 --> 00:08:48,320
is decide

00:08:46,320 --> 00:08:49,519
what's what's called the vectorization

00:08:48,320 --> 00:08:53,200
width which

00:08:49,519 --> 00:08:56,000
is how many elements

00:08:53,200 --> 00:08:56,959
can fit inside of a vector on the target

00:08:56,000 --> 00:08:58,720
that you're looking at

00:08:56,959 --> 00:09:00,560
so if we if we look at the slides for a

00:08:58,720 --> 00:09:04,399
moment then

00:09:00,560 --> 00:09:05,440
um you can see that neon has 128 bit

00:09:04,399 --> 00:09:07,279
vectors

00:09:05,440 --> 00:09:09,040
and so since we're working with double

00:09:07,279 --> 00:09:11,920
precision elements

00:09:09,040 --> 00:09:12,560
you can fit two 64-bits double precision

00:09:11,920 --> 00:09:14,800
elements

00:09:12,560 --> 00:09:16,480
in each vector and so it does two

00:09:14,800 --> 00:09:18,320
elements at once

00:09:16,480 --> 00:09:19,600
and that's what this two refers to here

00:09:18,320 --> 00:09:22,880
it's vectorization width

00:09:19,600 --> 00:09:24,480
two now the uh what's called the cost

00:09:22,880 --> 00:09:26,560
model in the compiler can't

00:09:24,480 --> 00:09:28,240
reason about that for sve that's

00:09:26,560 --> 00:09:30,480
something that's a work in progress but

00:09:28,240 --> 00:09:32,160
it's not there yet so what we have to do

00:09:30,480 --> 00:09:34,800
is tell the compiler

00:09:32,160 --> 00:09:37,120
to use a vectorization width and since

00:09:34,800 --> 00:09:39,839
we we know um it happens to be

00:09:37,120 --> 00:09:40,320
that a suitable vectorization width is

00:09:39,839 --> 00:09:43,440
is

00:09:40,320 --> 00:09:47,279
scalable too so we're going to say clang

00:09:43,440 --> 00:09:51,360
loop that prize with

00:09:47,279 --> 00:09:54,240
two comma scalable

00:09:51,360 --> 00:09:54,959
then what this says is that i want to

00:09:54,240 --> 00:09:59,360
have

00:09:54,959 --> 00:10:02,320
some unknown multiple of 128 bits

00:09:59,360 --> 00:10:03,680
of vector this is this is shown here

00:10:02,320 --> 00:10:06,079
it's successfully done it

00:10:03,680 --> 00:10:07,040
this v scale times two means it's used

00:10:06,079 --> 00:10:10,399
sve

00:10:07,040 --> 00:10:12,800
scalable also vectorization and

00:10:10,399 --> 00:10:14,000
we can interpret that with we i can show

00:10:12,800 --> 00:10:17,120
it in the diagram

00:10:14,000 --> 00:10:18,720
us as looking like this so

00:10:17,120 --> 00:10:20,800
we don't know what the vector width is

00:10:18,720 --> 00:10:23,279
but if we imagine it was executing on a

00:10:20,800 --> 00:10:26,800
256 bit implementation

00:10:23,279 --> 00:10:29,760
then v scale would be equal to two so

00:10:26,800 --> 00:10:31,360
it is two lots of the 128 bits which is

00:10:29,760 --> 00:10:34,399
the minimum size

00:10:31,360 --> 00:10:38,240
and so we would operate on

00:10:34,399 --> 00:10:38,240
four double precision

00:10:38,800 --> 00:10:45,360
values at once per vector iteration

00:10:42,800 --> 00:10:46,640
and this this is exactly what would this

00:10:45,360 --> 00:10:50,000
is exactly what would happen

00:10:46,640 --> 00:10:53,040
on a neovas v1 based processor because

00:10:50,000 --> 00:10:56,160
uh it has 256 bit

00:10:53,040 --> 00:10:59,600
sve vectors okay

00:10:56,160 --> 00:11:02,880
so we can see the setup code again

00:10:59,600 --> 00:11:03,920
and then we we have a load here which is

00:11:02,880 --> 00:11:08,079
loading

00:11:03,920 --> 00:11:09,440
um i think that will be b1

00:11:08,079 --> 00:11:11,680
and then another load here that's

00:11:09,440 --> 00:11:12,959
loading c1

00:11:11,680 --> 00:11:15,680
and then they're multiplied together

00:11:12,959 --> 00:11:18,000
here and they're stored out

00:11:15,680 --> 00:11:19,760
and that same code will execute on any

00:11:18,000 --> 00:11:21,839
sve implementation

00:11:19,760 --> 00:11:23,279
and on a small implementation it might

00:11:21,839 --> 00:11:26,000
only load two values

00:11:23,279 --> 00:11:26,399
on a wider implementation it might load

00:11:26,000 --> 00:11:28,880
four

00:11:26,399 --> 00:11:30,399
or eight and by doing so then each

00:11:28,880 --> 00:11:31,920
vector loop the wider implementation

00:11:30,399 --> 00:11:34,640
will get through more work

00:11:31,920 --> 00:11:35,519
and so it will execute the vector

00:11:34,640 --> 00:11:38,160
iterations

00:11:35,519 --> 00:11:38,560
fewer times and so that's the advantage

00:11:38,160 --> 00:11:41,680
you get

00:11:38,560 --> 00:11:45,040
of having wider

00:11:41,680 --> 00:11:47,360
okay so we can see so

00:11:45,040 --> 00:11:48,399
our goal for llvm12 was through a vector

00:11:47,360 --> 00:11:51,279
as one loop and so

00:11:48,399 --> 00:11:52,560
we've successfully done that um but it

00:11:51,279 --> 00:11:54,639
turns out the team

00:11:52,560 --> 00:11:55,680
excelled themselves and managed to do

00:11:54,639 --> 00:11:57,760
more than that

00:11:55,680 --> 00:11:59,040
so i'm going to explore some some other

00:11:57,760 --> 00:12:01,920
things that the

00:11:59,040 --> 00:12:04,079
compiler can do today the first of them

00:12:01,920 --> 00:12:07,120
in an interesting one for sve

00:12:04,079 --> 00:12:07,839
is the ability to access non-contiguous

00:12:07,120 --> 00:12:10,959
data

00:12:07,839 --> 00:12:13,519
so in this example the arrays a b and c

00:12:10,959 --> 00:12:14,320
are are contiguous in memory but

00:12:13,519 --> 00:12:15,920
sometimes

00:12:14,320 --> 00:12:17,839
you have loops where they're not so

00:12:15,920 --> 00:12:20,550
let's invent one of those

00:12:17,839 --> 00:12:22,160
so let's give ourselves say

00:12:20,550 --> 00:12:25,600
[Music]

00:12:22,160 --> 00:12:28,480
another array that contains some indices

00:12:25,600 --> 00:12:29,120
that we're going to use to access erase

00:12:28,480 --> 00:12:33,120
c

00:12:29,120 --> 00:12:35,920
say um and then so instead of direct

00:12:33,120 --> 00:12:37,680
of accessing c using i directly we're

00:12:35,920 --> 00:12:41,680
going to use

00:12:37,680 --> 00:12:43,279
indices i so this is no longer

00:12:41,680 --> 00:12:46,800
conspicuous this is now

00:12:43,279 --> 00:12:48,800
accessing some some elements within c

00:12:46,800 --> 00:12:50,959
but in some random order order that we

00:12:48,800 --> 00:12:55,440
don't know that was passed in

00:12:50,959 --> 00:12:57,839
in this indices argument and we can see

00:12:55,440 --> 00:12:59,360
the number one the compiler successfully

00:12:57,839 --> 00:13:01,360
does it and number two

00:12:59,360 --> 00:13:02,880
you can see the indices array being

00:13:01,360 --> 00:13:06,800
loaded here

00:13:02,880 --> 00:13:08,000
and then it's used as an off a vector of

00:13:06,800 --> 00:13:11,200
offset

00:13:08,000 --> 00:13:14,399
into a this load instruction

00:13:11,200 --> 00:13:15,839
which will load a vector's worth of

00:13:14,399 --> 00:13:18,560
values of c

00:13:15,839 --> 00:13:19,279
in in one load so this is this is this

00:13:18,560 --> 00:13:22,160
is called a

00:13:19,279 --> 00:13:23,519
a gather load and sve has support for

00:13:22,160 --> 00:13:25,600
both gather loads

00:13:23,519 --> 00:13:27,519
and the store equivalents which you call

00:13:25,600 --> 00:13:29,279
scatter stores

00:13:27,519 --> 00:13:30,720
and that's really useful for some forms

00:13:29,279 --> 00:13:34,560
of vectorization where

00:13:30,720 --> 00:13:37,920
you're not accessing um uh

00:13:34,560 --> 00:13:39,920
contiguous data in memory okay

00:13:37,920 --> 00:13:41,839
so that was that was example four if

00:13:39,920 --> 00:13:44,320
you're following along on the slides

00:13:41,839 --> 00:13:44,959
now we're going to show a different

00:13:44,320 --> 00:13:47,839
example

00:13:44,959 --> 00:13:48,480
by getting rid of this and putting the

00:13:47,839 --> 00:13:51,920
value four

00:13:48,480 --> 00:13:51,920
instead now

00:13:52,079 --> 00:13:55,839
this superficially looks kind of simple

00:13:54,800 --> 00:13:57,440
right so you're just

00:13:55,839 --> 00:14:00,000
loading b you're adding four to it

00:13:57,440 --> 00:14:03,440
you're storing it in a but it's actually

00:14:00,000 --> 00:14:05,839
subtly difficult for the compiler to

00:14:03,440 --> 00:14:07,440
represent this in its what's called its

00:14:05,839 --> 00:14:09,120
intermediate representation

00:14:07,440 --> 00:14:10,959
because what you need when you're

00:14:09,120 --> 00:14:12,880
vectorizing is not just one four you

00:14:10,959 --> 00:14:15,199
need a four in every lane

00:14:12,880 --> 00:14:16,959
of your vector and you don't know how

00:14:15,199 --> 00:14:19,920
many lanes your vector has

00:14:16,959 --> 00:14:21,279
and the way that llvm has traditionally

00:14:19,920 --> 00:14:23,600
done this relies

00:14:21,279 --> 00:14:24,480
on knowing what the vector width is so

00:14:23,600 --> 00:14:27,440
we've had to

00:14:24,480 --> 00:14:28,399
add some supports within the the yellow

00:14:27,440 --> 00:14:31,440
vmir

00:14:28,399 --> 00:14:33,600
to do this and we have and it works

00:14:31,440 --> 00:14:35,360
and the the outputs is actually quite

00:14:33,600 --> 00:14:38,079
simple it has a

00:14:35,360 --> 00:14:38,800
a floating point move of the value four

00:14:38,079 --> 00:14:42,160
into

00:14:38,800 --> 00:14:46,079
every element of a vector and then

00:14:42,160 --> 00:14:49,120
this is used in the multiply here

00:14:46,079 --> 00:14:51,120
okay then uh there's another example

00:14:49,120 --> 00:14:52,959
in the slides which i'm going to skip

00:14:51,120 --> 00:14:56,240
over which is pretty similar

00:14:52,959 --> 00:15:00,079
it's um instead of using a constant

00:14:56,240 --> 00:15:03,199
you you load from exactly one element

00:15:00,079 --> 00:15:04,240
of of one of the arrays which is

00:15:03,199 --> 00:15:05,920
certainly different from an

00:15:04,240 --> 00:15:07,120
implementation point of view but follows

00:15:05,920 --> 00:15:09,360
the same principle

00:15:07,120 --> 00:15:10,720
of the previous example so we'll just

00:15:09,360 --> 00:15:14,399
keep going i think

00:15:10,720 --> 00:15:18,480
so we'll put this back to ci and we will

00:15:14,399 --> 00:15:21,680
add a conditional so one of the

00:15:18,480 --> 00:15:23,199
other features of sve is the ability to

00:15:21,680 --> 00:15:26,880
conditionally execute

00:15:23,199 --> 00:15:29,440
code when vectorizing so if we add a

00:15:26,880 --> 00:15:30,240
an if statement into the for loop you

00:15:29,440 --> 00:15:33,600
can say if

00:15:30,240 --> 00:15:36,560
let's say bi greater than zero

00:15:33,600 --> 00:15:37,839
then do some work otherwise don't bother

00:15:36,560 --> 00:15:42,160
doing any work

00:15:37,839 --> 00:15:46,959
um so what the compiler has to do here

00:15:42,160 --> 00:15:48,959
is do a load of

00:15:46,959 --> 00:15:51,040
let's see where's the load there it is

00:15:48,959 --> 00:15:53,519
there's a load of b

00:15:51,040 --> 00:15:56,160
so it gets a vector of values of b then

00:15:53,519 --> 00:15:59,199
it does a vector comparison

00:15:56,160 --> 00:16:01,279
of that against

00:15:59,199 --> 00:16:02,959
an array that's been pre-filled with the

00:16:01,279 --> 00:16:06,720
value zero

00:16:02,959 --> 00:16:08,240
and then that is used to set

00:16:06,720 --> 00:16:10,000
what's called a predicate register which

00:16:08,240 --> 00:16:12,240
is a different kind of vector register

00:16:10,000 --> 00:16:14,639
where you have a single flag per lane

00:16:12,240 --> 00:16:15,839
that says this lane is active or

00:16:14,639 --> 00:16:17,920
inactive

00:16:15,839 --> 00:16:19,279
depending on on the value of this

00:16:17,920 --> 00:16:23,759
comparison

00:16:19,279 --> 00:16:26,880
and then you use that predicate register

00:16:23,759 --> 00:16:29,360
to lo to decide whether or not on

00:16:26,880 --> 00:16:30,800
on a lane by lane basis to load the

00:16:29,360 --> 00:16:32,880
value in c

00:16:30,800 --> 00:16:35,199
to do the multiply and then to store out

00:16:32,880 --> 00:16:38,959
the result

00:16:35,199 --> 00:16:42,240
so you can see in the slides

00:16:38,959 --> 00:16:43,600
um we if we choose to to imagine that

00:16:42,240 --> 00:16:46,720
the b2

00:16:43,600 --> 00:16:48,959
is less than or equal to zero then that

00:16:46,720 --> 00:16:51,519
predicate will be false for that lane

00:16:48,959 --> 00:16:52,639
and that work will not be done for this

00:16:51,519 --> 00:16:54,720
lane of

00:16:52,639 --> 00:16:56,639
of execution but it will be done for all

00:16:54,720 --> 00:16:59,440
the others which is what you need it

00:16:56,639 --> 00:17:01,920
is so that it does the same thing as the

00:16:59,440 --> 00:17:05,360
original scalar loop

00:17:01,920 --> 00:17:08,559
okay so that was example seven

00:17:05,360 --> 00:17:10,079
uh on to slightly more complex example

00:17:08,559 --> 00:17:11,760
so i'm going to look at a thing called

00:17:10,079 --> 00:17:13,120
reductions so

00:17:11,760 --> 00:17:14,959
what we'll do is we're going to change

00:17:13,120 --> 00:17:18,160
the signature of this function

00:17:14,959 --> 00:17:21,520
to return a double and we will

00:17:18,160 --> 00:17:24,640
give ourselves a variable so double

00:17:21,520 --> 00:17:26,890
red equals

00:17:24,640 --> 00:17:28,240
say that and

00:17:26,890 --> 00:17:30,640
[Music]

00:17:28,240 --> 00:17:33,840
let's um let's get rid of the

00:17:30,640 --> 00:17:33,840
conditional for now

00:17:34,160 --> 00:17:41,280
and we will say that instead of

00:17:37,360 --> 00:17:45,360
assigning to a i will say that rares

00:17:41,280 --> 00:17:48,960
plus equals this result and then

00:17:45,360 --> 00:17:48,960
we will return

00:17:49,039 --> 00:17:54,799
so what happens here is

00:17:52,480 --> 00:17:56,320
um it goes through the b and c arrays

00:17:54,799 --> 00:17:59,120
multiplies them together

00:17:56,320 --> 00:18:00,000
keeps a running total and returns that

00:17:59,120 --> 00:18:03,919
running turtle at the

00:18:00,000 --> 00:18:04,480
end now um the most efficient way of

00:18:03,919 --> 00:18:06,960
doing this

00:18:04,480 --> 00:18:08,160
on most implementations of vets or

00:18:06,960 --> 00:18:10,880
architectures

00:18:08,160 --> 00:18:11,360
is to try to keep within the same lane

00:18:10,880 --> 00:18:13,280
as

00:18:11,360 --> 00:18:15,840
for as long as you can for as much of

00:18:13,280 --> 00:18:19,760
the loop as you can because

00:18:15,840 --> 00:18:22,240
uh typically if you had to

00:18:19,760 --> 00:18:23,039
sum across all the lanes inside of your

00:18:22,240 --> 00:18:24,400
loop that's

00:18:23,039 --> 00:18:26,320
that's typically a fairly expensive

00:18:24,400 --> 00:18:28,640
operation because it crosses lanes

00:18:26,320 --> 00:18:30,080
so what the compiler does is it

00:18:28,640 --> 00:18:33,200
generates

00:18:30,080 --> 00:18:36,400
code that that loads

00:18:33,200 --> 00:18:39,200
the values of b and c

00:18:36,400 --> 00:18:39,520
and then uses this instruction here

00:18:39,200 --> 00:18:43,919
called

00:18:39,520 --> 00:18:46,960
um floating point multiply accumulate

00:18:43,919 --> 00:18:50,000
where it takes the values of b and c

00:18:46,960 --> 00:18:52,080
multiplies them together and adds them

00:18:50,000 --> 00:18:55,280
on a lane by lane basis

00:18:52,080 --> 00:18:58,720
into an accumulator

00:18:55,280 --> 00:19:02,400
so we can see a diagram of this here so

00:18:58,720 --> 00:19:04,160
it it will store

00:19:02,400 --> 00:19:06,240
the results of that floating point

00:19:04,160 --> 00:19:08,880
multiplying and accumulate

00:19:06,240 --> 00:19:10,480
as partial results in some number of

00:19:08,880 --> 00:19:11,520
lanes depending on how wide your vector

00:19:10,480 --> 00:19:14,559
width is

00:19:11,520 --> 00:19:16,080
and it will repeat this operation uh for

00:19:14,559 --> 00:19:17,440
as many times as it needs to to get

00:19:16,080 --> 00:19:20,480
through all of the

00:19:17,440 --> 00:19:23,280
elements of the original arrays and then

00:19:20,480 --> 00:19:24,080
after the loop is completed it will take

00:19:23,280 --> 00:19:26,559
this partial

00:19:24,080 --> 00:19:28,240
result and collapse it down by adding

00:19:26,559 --> 00:19:30,080
all of its elements together

00:19:28,240 --> 00:19:31,520
into a single scalar result which is

00:19:30,080 --> 00:19:34,880
then returned

00:19:31,520 --> 00:19:38,160
and so you can see that this this

00:19:34,880 --> 00:19:41,280
this vector zero

00:19:38,160 --> 00:19:43,200
is the is the partial sum and there's

00:19:41,280 --> 00:19:46,640
another new instruction called a

00:19:43,200 --> 00:19:49,840
f and v which takes all of the elements

00:19:46,640 --> 00:19:53,039
in zero and adds them all together and

00:19:49,840 --> 00:19:53,679
and stores that to a scalar register

00:19:53,039 --> 00:19:57,039
which you

00:19:53,679 --> 00:20:00,240
you then return okay um

00:19:57,039 --> 00:20:00,960
so those are the main examples i wanted

00:20:00,240 --> 00:20:02,400
to go through

00:20:00,960 --> 00:20:04,159
i also wanted to show an example that

00:20:02,400 --> 00:20:06,080
didn't work because

00:20:04,159 --> 00:20:07,760
i don't want to give the impression that

00:20:06,080 --> 00:20:08,799
this is complete and that everything

00:20:07,760 --> 00:20:10,720
works fine

00:20:08,799 --> 00:20:13,039
and it's surprisingly easy to do that if

00:20:10,720 --> 00:20:14,880
you change this one so instead of

00:20:13,039 --> 00:20:18,240
multiplying by ci

00:20:14,880 --> 00:20:20,559
just change it to i then

00:20:18,240 --> 00:20:21,919
what that means conceptually within the

00:20:20,559 --> 00:20:26,000
compiler is

00:20:21,919 --> 00:20:27,760
um you you need to take the value of i

00:20:26,000 --> 00:20:29,440
which you know in in the first time

00:20:27,760 --> 00:20:31,280
round might be you know zero one two

00:20:29,440 --> 00:20:34,720
three four five however many

00:20:31,280 --> 00:20:37,120
elements you have and set up an array

00:20:34,720 --> 00:20:39,120
that contains those values

00:20:37,120 --> 00:20:41,120
now the sve architecture has

00:20:39,120 --> 00:20:44,480
instructions that allow you to do this

00:20:41,120 --> 00:20:46,880
efficiently but

00:20:44,480 --> 00:20:48,880
it's it's something that's not easily

00:20:46,880 --> 00:20:51,200
represented in llvm's ir

00:20:48,880 --> 00:20:52,559
and so it's taken quite a lot of work to

00:20:51,200 --> 00:20:53,440
get it to the point where it can

00:20:52,559 --> 00:20:55,360
understand that

00:20:53,440 --> 00:20:57,120
which we have now done and you can see

00:20:55,360 --> 00:20:58,559
that here because you can see the

00:20:57,120 --> 00:21:00,400
diagnostic output saying that it's

00:20:58,559 --> 00:21:02,480
successfully vectorized

00:21:00,400 --> 00:21:04,080
and it would be possible to look at the

00:21:02,480 --> 00:21:04,720
the vectorized ir and see that it

00:21:04,080 --> 00:21:07,760
happens

00:21:04,720 --> 00:21:10,080
but what we haven't completed yet

00:21:07,760 --> 00:21:11,200
at the time i'm recording this is the

00:21:10,080 --> 00:21:14,000
work that

00:21:11,200 --> 00:21:14,720
allows the compiler to then code

00:21:14,000 --> 00:21:17,919
generate that

00:21:14,720 --> 00:21:19,039
to sve assembly now that is in flight at

00:21:17,919 --> 00:21:20,720
the moment it's possible

00:21:19,039 --> 00:21:22,240
if you're following along that you'll

00:21:20,720 --> 00:21:24,159
see this work

00:21:22,240 --> 00:21:26,240
but it didn't two weeks ago when i

00:21:24,159 --> 00:21:30,240
recorded this

00:21:26,240 --> 00:21:31,679
okay so those are all the examples that

00:21:30,240 --> 00:21:35,440
i had

00:21:31,679 --> 00:21:38,480
um so just briefly

00:21:35,440 --> 00:21:41,200
this is where we're going so um

00:21:38,480 --> 00:21:42,799
llvm12 is is very much sort of a proof

00:21:41,200 --> 00:21:46,240
of concept stage

00:21:42,799 --> 00:21:47,039
by llvm13 i'm expecting it to be safe

00:21:46,240 --> 00:21:50,080
for

00:21:47,039 --> 00:21:52,960
a reasonably large set of um

00:21:50,080 --> 00:21:54,640
workloads and to have a flag that

00:21:52,960 --> 00:21:56,240
switches it on by default so you don't

00:21:54,640 --> 00:21:59,440
need this pragma anymore

00:21:56,240 --> 00:22:01,200
and that'll be great because uh linaro

00:21:59,440 --> 00:22:03,120
um one of the teams within the narrow

00:22:01,200 --> 00:22:03,840
are setting a build bot to defend this

00:22:03,120 --> 00:22:08,159
stuff in

00:22:03,840 --> 00:22:10,799
in upstream lrvm i also expect us to

00:22:08,159 --> 00:22:12,960
continue to become more capable in terms

00:22:10,799 --> 00:22:15,200
of our ability to vectorize

00:22:12,960 --> 00:22:16,080
i we've already surpassed this number

00:22:15,200 --> 00:22:19,840
actually so

00:22:16,080 --> 00:22:22,080
i we've got a set of loops called tsvc

00:22:19,840 --> 00:22:25,600
and a good compiler should be able to

00:22:22,080 --> 00:22:27,840
vectorize about 100 of them with sve

00:22:25,600 --> 00:22:29,120
we tried to get one for lvm12 we

00:22:27,840 --> 00:22:32,799
actually got 32

00:22:29,120 --> 00:22:34,400
we've passed 50 already so we we're

00:22:32,799 --> 00:22:36,400
getting along quite nicely on the

00:22:34,400 --> 00:22:38,080
capability front and then in terms of

00:22:36,400 --> 00:22:40,880
code quality we've started

00:22:38,080 --> 00:22:41,840
work here cleaning things up and we will

00:22:40,880 --> 00:22:44,080
continue to do that

00:22:41,840 --> 00:22:46,240
over the next couple of releases by the

00:22:44,080 --> 00:22:48,640
time we get to lem14

00:22:46,240 --> 00:22:50,320
i'm expecting this to start to be at the

00:22:48,640 --> 00:22:53,360
point where it actually

00:22:50,320 --> 00:22:55,120
might be usable for end users and by the

00:22:53,360 --> 00:22:58,400
time we get to lvm15

00:22:55,120 --> 00:23:00,000
i expect it to be on by default for sve

00:22:58,400 --> 00:23:01,679
and sv2 targets

00:23:00,000 --> 00:23:03,520
and to be providing a really good

00:23:01,679 --> 00:23:06,159
benefit

00:23:03,520 --> 00:23:07,360
okay that's all i had if i have time

00:23:06,159 --> 00:23:09,880
i'll have some questions now

00:23:07,360 --> 00:23:12,880
otherwise thank you very much for

00:23:09,880 --> 00:23:12,880

YouTube URL: https://www.youtube.com/watch?v=v6NmKOkQ2LE


