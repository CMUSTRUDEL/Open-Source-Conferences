Title: LVC21-308 Essential ARM Cortex M Debugging with GDB
Publication date: 2021-04-15
Playlist: Linaro Virtual Connect Spring 2021
Description: 
	Key tools and techniques used to debug ARM Cortex M firmware using GDB, including writing your own tools with GDB's built-in python interpreter.
Captions: 
	00:00:00,799 --> 00:00:03,600
welcome and thanks for joining me on

00:00:02,320 --> 00:00:06,960
this talk on

00:00:03,600 --> 00:00:08,320
debugging arm cortex-m systems with gdb

00:00:06,960 --> 00:00:11,120
some of the things we'll be looking over

00:00:08,320 --> 00:00:13,120
you can see in this overview

00:00:11,120 --> 00:00:15,040
and we'll start from sort of the basics

00:00:13,120 --> 00:00:17,520
and dig into more arm specific

00:00:15,040 --> 00:00:19,119
things towards the end so before we get

00:00:17,520 --> 00:00:22,560
started let's just have a quick look at

00:00:19,119 --> 00:00:24,000
the program that we'll be debugging here

00:00:22,560 --> 00:00:25,519
it's a really simple program that just

00:00:24,000 --> 00:00:26,480
does some printf output there's a

00:00:25,519 --> 00:00:29,359
counter

00:00:26,480 --> 00:00:30,000
and there's a divide by zero arrow error

00:00:29,359 --> 00:00:33,280
that'll throw an

00:00:30,000 --> 00:00:35,200
exception that we can try to debug later

00:00:33,280 --> 00:00:37,920
i'm using zephyr rtos to build the

00:00:35,200 --> 00:00:39,719
application here and pi ocd to flash it

00:00:37,920 --> 00:00:42,239
onto the

00:00:39,719 --> 00:00:43,200
lpc55s69 board but you can use anything

00:00:42,239 --> 00:00:44,960
it's a really simple

00:00:43,200 --> 00:00:46,480
c program and any utility that will

00:00:44,960 --> 00:00:50,320
flash

00:00:46,480 --> 00:00:52,800
the target development board is fine

00:00:50,320 --> 00:00:54,719
so here you can see the the l file

00:00:52,800 --> 00:00:56,239
that's generated

00:00:54,719 --> 00:00:58,079
we'll just erase the chip to make sure

00:00:56,239 --> 00:01:00,480
there's nothing else on there

00:00:58,079 --> 00:01:03,840
and then we'll go ahead and flash the

00:01:00,480 --> 00:01:03,840
the l file that we just built

00:01:05,920 --> 00:01:09,600
so now that we have our firmware that

00:01:07,280 --> 00:01:11,280
we've built and flashed to the device

00:01:09,600 --> 00:01:13,040
we can actually start some debugging and

00:01:11,280 --> 00:01:16,640
to do that we first need to connect

00:01:13,040 --> 00:01:18,560
to the device so let's go ahead and

00:01:16,640 --> 00:01:21,360
start up by ocd server which we can do

00:01:18,560 --> 00:01:23,439
with the pi ocd gdb server command

00:01:21,360 --> 00:01:25,520
and that'll start the server up for us

00:01:23,439 --> 00:01:27,040
with the target we specify

00:01:25,520 --> 00:01:28,600
and once that starts up you can see the

00:01:27,040 --> 00:01:33,360
port here is

00:01:28,600 --> 00:01:34,960
3333 for the gdp server on core 0.

00:01:33,360 --> 00:01:38,000
if we wanted to do that with the j-link

00:01:34,960 --> 00:01:39,759
tools we can run j-link gdb server

00:01:38,000 --> 00:01:41,680
passing it in a few parameters like

00:01:39,759 --> 00:01:44,240
using swd for the interface

00:01:41,680 --> 00:01:45,759
the connection speed at four kilohertz

00:01:44,240 --> 00:01:47,360
using the usb interface and we have to

00:01:45,759 --> 00:01:49,920
pass in the device name

00:01:47,360 --> 00:01:50,880
and that'll start up gdp servers server

00:01:49,920 --> 00:01:52,720
for us as well

00:01:50,880 --> 00:01:54,119
in this case however you want to note

00:01:52,720 --> 00:01:58,640
the port numbers

00:01:54,119 --> 00:02:00,560
2331 which is different than pi ocd

00:01:58,640 --> 00:02:01,759
so gdb server is half of what we need

00:02:00,560 --> 00:02:03,360
and that's the part that will actually

00:02:01,759 --> 00:02:04,799
physically connect to your development

00:02:03,360 --> 00:02:06,840
board with a debugger

00:02:04,799 --> 00:02:08,160
the other part that we need is a gdp

00:02:06,840 --> 00:02:09,920
client

00:02:08,160 --> 00:02:11,599
and that client will then connect to the

00:02:09,920 --> 00:02:13,599
server usually using

00:02:11,599 --> 00:02:15,200
tcp sockets and you can do that locally

00:02:13,599 --> 00:02:15,920
or remotely which is actually one of the

00:02:15,200 --> 00:02:19,040
advantages

00:02:15,920 --> 00:02:21,440
of gdb that you're able to debug boards

00:02:19,040 --> 00:02:22,640
remotely as well so let's start up our

00:02:21,440 --> 00:02:25,760
gdp client here

00:02:22,640 --> 00:02:27,280
and um we'll pass that in the l file

00:02:25,760 --> 00:02:28,480
that we're going to be debugging because

00:02:27,280 --> 00:02:29,360
that's where all of the symbol

00:02:28,480 --> 00:02:31,360
information

00:02:29,360 --> 00:02:33,440
will be contained and we'll tell it that

00:02:31,360 --> 00:02:35,840
we want to connect to port 3333 because

00:02:33,440 --> 00:02:38,800
we're using the pi ocd gtp server in

00:02:35,840 --> 00:02:38,800
this particular case

00:02:38,959 --> 00:02:42,720
so now that our gdp client is connected

00:02:40,800 --> 00:02:44,400
to our gdb server let's get the device

00:02:42,720 --> 00:02:46,400
into a known state

00:02:44,400 --> 00:02:48,080
and that's going to mean resetting it

00:02:46,400 --> 00:02:50,400
halting the device

00:02:48,080 --> 00:02:52,239
and breaking it into one point um just

00:02:50,400 --> 00:02:54,319
so we can start our codex

00:02:52,239 --> 00:02:55,440
execution and debugging session with the

00:02:54,319 --> 00:02:57,840
clean slate

00:02:55,440 --> 00:02:59,840
so here we've reset the device we're

00:02:57,840 --> 00:03:01,599
going to set a breakpoint on main

00:02:59,840 --> 00:03:03,200
the function main and then we're going

00:03:01,599 --> 00:03:04,400
to tell it to keep running and

00:03:03,200 --> 00:03:07,840
you can see here we've hit the break

00:03:04,400 --> 00:03:07,840
point that we just set in main

00:03:08,239 --> 00:03:12,560
so gdb exposes all of the classic sort

00:03:10,560 --> 00:03:13,920
of navigation things you'd expect in any

00:03:12,560 --> 00:03:16,800
debugger

00:03:13,920 --> 00:03:18,080
step into step over you can run to a

00:03:16,800 --> 00:03:21,200
certain number of lines

00:03:18,080 --> 00:03:22,959
you can run to a specific location in

00:03:21,200 --> 00:03:24,799
source code

00:03:22,959 --> 00:03:26,879
so just to see how that works let's open

00:03:24,799 --> 00:03:28,080
up the serial port on our on our device

00:03:26,879 --> 00:03:30,000
just so we can get some printf

00:03:28,080 --> 00:03:32,319
output so i'm just using minicom and

00:03:30,000 --> 00:03:34,080
i'll connect to the serial port here

00:03:32,319 --> 00:03:36,239
and then in another terminal we can

00:03:34,080 --> 00:03:37,440
switch back to our gdb session and we're

00:03:36,239 --> 00:03:39,519
still at our break point

00:03:37,440 --> 00:03:41,440
so let's just run n for the next code to

00:03:39,519 --> 00:03:43,680
sort of step over that line

00:03:41,440 --> 00:03:46,159
and there we can see our printf output

00:03:43,680 --> 00:03:46,799
as we've stepped over that line running

00:03:46,159 --> 00:03:49,920
from

00:03:46,799 --> 00:03:51,040
down to line 11 now so there's a number

00:03:49,920 --> 00:03:53,920
of variations of these

00:03:51,040 --> 00:03:55,360
step next continue intel commands

00:03:53,920 --> 00:03:57,360
something to point out with gdb though

00:03:55,360 --> 00:03:58,319
is that most common commands also have

00:03:57,360 --> 00:04:00,720
shortcuts

00:03:58,319 --> 00:04:01,360
so in this particular case we've listed

00:04:00,720 --> 00:04:03,840
c

00:04:01,360 --> 00:04:05,200
continue so you can either type c or the

00:04:03,840 --> 00:04:07,439
full continue command

00:04:05,200 --> 00:04:09,519
and both are identical but throughout

00:04:07,439 --> 00:04:10,239
this presentation we've sort of given

00:04:09,519 --> 00:04:12,480
the shortcut

00:04:10,239 --> 00:04:14,400
and the full form notation for a lot of

00:04:12,480 --> 00:04:17,199
the most common gdb commands

00:04:14,400 --> 00:04:18,320
and once you're familiar with with gdb

00:04:17,199 --> 00:04:21,759
those shortcuts

00:04:18,320 --> 00:04:21,759
should become second nature

00:04:21,919 --> 00:04:25,840
so that brings us to break points and

00:04:24,320 --> 00:04:27,600
breakpoints are really the workhorse

00:04:25,840 --> 00:04:29,280
obviously of any debugging session it

00:04:27,600 --> 00:04:30,560
allows you to set a precise place in

00:04:29,280 --> 00:04:34,000
your code

00:04:30,560 --> 00:04:35,919
where execution will stop automatically

00:04:34,000 --> 00:04:38,400
and gdb actually has a lot of quite

00:04:35,919 --> 00:04:40,880
powerful additional

00:04:38,400 --> 00:04:43,199
break point commands and options that we

00:04:40,880 --> 00:04:45,040
can set fairly rich conditions

00:04:43,199 --> 00:04:46,560
upon which to cause a breakpoint not

00:04:45,040 --> 00:04:49,680
necessarily the first time you hit

00:04:46,560 --> 00:04:50,320
the break point but you can ignore say

00:04:49,680 --> 00:04:52,639
the first

00:04:50,320 --> 00:04:54,320
20 instances of a specific breakpoint as

00:04:52,639 --> 00:04:56,479
you can see in one of the commands here

00:04:54,320 --> 00:04:57,600
ignore 220 which means ignore break

00:04:56,479 --> 00:05:00,160
point number two

00:04:57,600 --> 00:05:01,440
the first 20 times that we hit it so for

00:05:00,160 --> 00:05:04,000
some very specific

00:05:01,440 --> 00:05:04,960
errors that maybe only reproduce

00:05:04,000 --> 00:05:07,840
themselves uh

00:05:04,960 --> 00:05:08,960
in in in given conditions gdb can

00:05:07,840 --> 00:05:11,840
actually be quite efficient

00:05:08,960 --> 00:05:14,160
to just to sort of quickly hit those

00:05:11,840 --> 00:05:15,680
problematic points

00:05:14,160 --> 00:05:17,280
so let's have a look at how that works

00:05:15,680 --> 00:05:18,800
in practice we previously set a

00:05:17,280 --> 00:05:20,320
breakpoint so we can type info

00:05:18,800 --> 00:05:21,759
breakpoints to see a list of our

00:05:20,320 --> 00:05:23,680
our breakpoints and there's only one

00:05:21,759 --> 00:05:26,080
defined which we set at main

00:05:23,680 --> 00:05:28,240
so let's delete that let's just get rid

00:05:26,080 --> 00:05:29,759
of delete number one

00:05:28,240 --> 00:05:31,759
check the info breakpoints again we can

00:05:29,759 --> 00:05:35,440
see that we've got none of them now

00:05:31,759 --> 00:05:38,000
so let's set a new breakpoint in main.c

00:05:35,440 --> 00:05:39,120
and you can specify line 14 for example

00:05:38,000 --> 00:05:41,120
of that file

00:05:39,120 --> 00:05:43,360
so we've got a new breakpoint c to

00:05:41,120 --> 00:05:45,039
continue and we'll continue execution

00:05:43,360 --> 00:05:47,919
and there we fit a new breakpoint

00:05:45,039 --> 00:05:49,919
checking our serial output again here we

00:05:47,919 --> 00:05:52,240
can see that this print statement hasn't

00:05:49,919 --> 00:05:53,440
been run yet so n for next we'll step

00:05:52,240 --> 00:05:54,160
over that and now we should see that

00:05:53,440 --> 00:05:57,520
print

00:05:54,160 --> 00:05:59,120
f output and there it is um

00:05:57,520 --> 00:06:01,199
so you can see that the the break points

00:05:59,120 --> 00:06:03,520
are obviously functioning like we expect

00:06:01,199 --> 00:06:05,199
so info break points again will show us

00:06:03,520 --> 00:06:06,800
that that break point that we've just

00:06:05,199 --> 00:06:08,080
set we can get rid of it if we want

00:06:06,800 --> 00:06:10,319
because there are a limited number of

00:06:08,080 --> 00:06:11,840
hardware breakpoints available

00:06:10,319 --> 00:06:13,440
gdb also supports something called

00:06:11,840 --> 00:06:15,120
conditional breakpoints

00:06:13,440 --> 00:06:16,960
so let's have a look here let's set a

00:06:15,120 --> 00:06:20,240
breakpoint in main.c

00:06:16,960 --> 00:06:22,479
on line 12. only if the variable i

00:06:20,240 --> 00:06:24,160
is greater than 20. so we can see our

00:06:22,479 --> 00:06:26,160
breakpoint is set let's see what

00:06:24,160 --> 00:06:27,600
details we get so stop only if i is

00:06:26,160 --> 00:06:29,520
greater than 20. so

00:06:27,600 --> 00:06:31,600
now we'll want to continue we hit our

00:06:29,520 --> 00:06:31,840
breakpoint and let's check the value of

00:06:31,600 --> 00:06:33,520
i

00:06:31,840 --> 00:06:34,880
just to make sure that that works i

00:06:33,520 --> 00:06:36,880
equals 21.

00:06:34,880 --> 00:06:38,720
that's already quite powerful but let's

00:06:36,880 --> 00:06:40,160
say we only want to hit a breakpoint

00:06:38,720 --> 00:06:42,080
after a certain number of times like

00:06:40,160 --> 00:06:42,880
after 20 times so let's get rid of this

00:06:42,080 --> 00:06:44,639
old break point

00:06:42,880 --> 00:06:46,400
typing for breakpoints we've got nothing

00:06:44,639 --> 00:06:48,240
left here now

00:06:46,400 --> 00:06:49,840
let's set a new breakpoint again on on

00:06:48,240 --> 00:06:52,960
line 12.

00:06:49,840 --> 00:06:54,560
um oh sorry b forever uh

00:06:52,960 --> 00:06:56,160
break point so there's our break point

00:06:54,560 --> 00:06:57,599
let's see what it says we've got just a

00:06:56,160 --> 00:06:58,720
normal breakpoint see and we're going to

00:06:57,599 --> 00:07:01,680
say ignore

00:06:58,720 --> 00:07:02,960
number five the first 20 times that that

00:07:01,680 --> 00:07:07,440
breakpoint fires

00:07:02,960 --> 00:07:08,720
so enter um now let's uh let's continue

00:07:07,440 --> 00:07:11,520
and we've hit that breakpoint let's

00:07:08,720 --> 00:07:13,199
check the value of i so 42.

00:07:11,520 --> 00:07:14,479
so you'll definitely want to familiarize

00:07:13,199 --> 00:07:15,440
yourself with a lot of these commands

00:07:14,479 --> 00:07:18,479
because there'll be some of the most

00:07:15,440 --> 00:07:20,800
common ones that you'll be using

00:07:18,479 --> 00:07:22,479
so that brings us to watch points now

00:07:20,800 --> 00:07:24,160
watch points are a much more powerful

00:07:22,479 --> 00:07:25,039
version of breakpoints because they will

00:07:24,160 --> 00:07:26,639
evaluate

00:07:25,039 --> 00:07:28,800
a certain number of conditions or they

00:07:26,639 --> 00:07:32,240
will watch and tell a specific variable

00:07:28,800 --> 00:07:33,680
for example is changed or accessed

00:07:32,240 --> 00:07:36,000
now that can be very powerful for

00:07:33,680 --> 00:07:37,599
example for waiting for a specific

00:07:36,000 --> 00:07:39,280
stack address or something to to be

00:07:37,599 --> 00:07:42,319
changed or exceeded

00:07:39,280 --> 00:07:43,840
the fallback or sort of the drawback of

00:07:42,319 --> 00:07:45,440
watchpoints however is that they're

00:07:43,840 --> 00:07:47,919
extremely slow

00:07:45,440 --> 00:07:49,520
so basically every instruction needs to

00:07:47,919 --> 00:07:51,039
be analyzed by the debugger

00:07:49,520 --> 00:07:52,960
when you set a watch point so they're

00:07:51,039 --> 00:07:55,039
extremely powerful but they're not

00:07:52,960 --> 00:07:57,360
terribly efficient so you need to

00:07:55,039 --> 00:07:58,879
sort of weigh your your your your

00:07:57,360 --> 00:07:59,759
options when you're choosing between a

00:07:58,879 --> 00:08:01,599
break point

00:07:59,759 --> 00:08:03,520
and a watch point for certain kinds of

00:08:01,599 --> 00:08:05,599
problems however watch points

00:08:03,520 --> 00:08:06,639
will definitely give you a lot more

00:08:05,599 --> 00:08:09,599
control over

00:08:06,639 --> 00:08:11,759
the debug experience so let's see how

00:08:09,599 --> 00:08:13,039
this works in in practice

00:08:11,759 --> 00:08:15,360
so let's check if we have any current

00:08:13,039 --> 00:08:16,879
break points we do so we'll get rid of

00:08:15,360 --> 00:08:19,520
the old ones

00:08:16,879 --> 00:08:21,599
and now we're going to set a new watch

00:08:19,520 --> 00:08:24,639
point on the variable i

00:08:21,599 --> 00:08:26,400
so continue and you can see as soon as i

00:08:24,639 --> 00:08:28,160
is changed we we hit

00:08:26,400 --> 00:08:31,120
the watch point or the break point with

00:08:28,160 --> 00:08:31,120
the old and new value

00:08:31,360 --> 00:08:34,800
so let's uh let's get rid of that one

00:08:33,519 --> 00:08:36,640
and try something different then let's

00:08:34,800 --> 00:08:40,479
say we want to watch the variable i

00:08:36,640 --> 00:08:41,919
only if i is greater than 50

00:08:40,479 --> 00:08:44,720
and you can put quite rich conditions

00:08:41,919 --> 00:08:47,519
here with watch points in particular

00:08:44,720 --> 00:08:48,080
and see we've hit that again now watch

00:08:47,519 --> 00:08:49,519
points

00:08:48,080 --> 00:08:52,000
are quite powerful because you can also

00:08:49,519 --> 00:08:54,480
look inside for example maybe structs or

00:08:52,000 --> 00:08:56,080
arrays of objects at very specific

00:08:54,480 --> 00:08:57,920
items or you can look at a register

00:08:56,080 --> 00:08:59,360
value by pointing to a specific memory

00:08:57,920 --> 00:09:01,200
address

00:08:59,360 --> 00:09:02,800
and generally these these can really

00:09:01,200 --> 00:09:06,480
help you trying to

00:09:02,800 --> 00:09:08,320
to sort out memory access problems or to

00:09:06,480 --> 00:09:10,399
know at least when some some value is

00:09:08,320 --> 00:09:11,839
being changed in memory

00:09:10,399 --> 00:09:13,519
so what about when we want to know

00:09:11,839 --> 00:09:14,480
something about our system state that

00:09:13,519 --> 00:09:16,160
can be the

00:09:14,480 --> 00:09:18,160
arguments passed into our function the

00:09:16,160 --> 00:09:20,399
current state of variables local

00:09:18,160 --> 00:09:22,000
local or global uh the state of the

00:09:20,399 --> 00:09:23,839
system the core registers on

00:09:22,000 --> 00:09:25,040
our cortex-m system that's where the

00:09:23,839 --> 00:09:26,800
info command

00:09:25,040 --> 00:09:28,240
comes in and it's quite useful and you

00:09:26,800 --> 00:09:30,480
can list all of these things

00:09:28,240 --> 00:09:32,800
by typing in for locals info variables

00:09:30,480 --> 00:09:34,080
info args info registers

00:09:32,800 --> 00:09:36,320
and this is the same command we've been

00:09:34,080 --> 00:09:37,440
using to check in break points and watch

00:09:36,320 --> 00:09:39,360
points as well

00:09:37,440 --> 00:09:41,120
so this is something that can be quite

00:09:39,360 --> 00:09:42,080
useful just to know once you hit a

00:09:41,120 --> 00:09:43,920
breakpoint

00:09:42,080 --> 00:09:45,839
exactly what's going on in your system

00:09:43,920 --> 00:09:47,519
at that particular moment and what the

00:09:45,839 --> 00:09:49,279
what the state of all of the variables

00:09:47,519 --> 00:09:50,640
are at that given moment

00:09:49,279 --> 00:09:52,480
so let's have a look at how this works

00:09:50,640 --> 00:09:53,680
in practice we can have info locals to

00:09:52,480 --> 00:09:56,000
get our local variables

00:09:53,680 --> 00:09:56,720
info variables to get a list of all of

00:09:56,000 --> 00:09:58,640
our variables

00:09:56,720 --> 00:10:00,000
info args which will be the function

00:09:58,640 --> 00:10:01,519
arguments we don't have any in this

00:10:00,000 --> 00:10:03,360
particular case but

00:10:01,519 --> 00:10:07,040
and infor registers which will show us

00:10:03,360 --> 00:10:08,880
the the cortex-m core registers

00:10:07,040 --> 00:10:10,480
so knowing the device state is important

00:10:08,880 --> 00:10:12,880
but something that's also critical

00:10:10,480 --> 00:10:13,839
when debugging is to know how we got to

00:10:12,880 --> 00:10:15,680
where we did

00:10:13,839 --> 00:10:17,360
and this is where things like stack

00:10:15,680 --> 00:10:20,560
backtrace can come into

00:10:17,360 --> 00:10:21,519
into play so backtrace bt is the

00:10:20,560 --> 00:10:23,279
shortcut

00:10:21,519 --> 00:10:24,880
that will basically show you it will

00:10:23,279 --> 00:10:26,399
roll back the stack frames

00:10:24,880 --> 00:10:28,560
so that you can see the progression of

00:10:26,399 --> 00:10:30,959
branches and execution in your code

00:10:28,560 --> 00:10:31,680
to know where you were before you ended

00:10:30,959 --> 00:10:33,519
up in a certain

00:10:31,680 --> 00:10:34,880
in the current place where you've set a

00:10:33,519 --> 00:10:36,800
break point or where you've stopped

00:10:34,880 --> 00:10:38,399
program execution

00:10:36,800 --> 00:10:40,880
so let's see how that works so here we

00:10:38,399 --> 00:10:42,000
can type bt for backtrace and we've only

00:10:40,880 --> 00:10:43,440
got main because

00:10:42,000 --> 00:10:45,120
we're at the start of our program we

00:10:43,440 --> 00:10:46,560
haven't branched to any other functions

00:10:45,120 --> 00:10:48,399
yet

00:10:46,560 --> 00:10:50,880
so but let's reset our device to get it

00:10:48,399 --> 00:10:53,040
into a known state so monitor reset halt

00:10:50,880 --> 00:10:54,480
we'll set a temporary breakpoint on main

00:10:53,040 --> 00:10:56,480
so it'll delete

00:10:54,480 --> 00:10:59,200
itself as soon as it gets hit once we'll

00:10:56,480 --> 00:11:01,440
continue so now we're in a clean state

00:10:59,200 --> 00:11:03,120
so let's step into this print k command

00:11:01,440 --> 00:11:04,959
with the s so now that we've stepped

00:11:03,120 --> 00:11:06,240
into the print k function

00:11:04,959 --> 00:11:08,079
now we can do back trace again and we

00:11:06,240 --> 00:11:09,519
can see there's a progression from main

00:11:08,079 --> 00:11:12,640
to print k

00:11:09,519 --> 00:11:14,240
in the stack frames so you can see sort

00:11:12,640 --> 00:11:15,519
of the the the code floor

00:11:14,240 --> 00:11:17,279
the code flow as we've hit our

00:11:15,519 --> 00:11:19,120
breakpoint so let's just step forward a

00:11:17,279 --> 00:11:21,519
few lines of code and then we'll set a

00:11:19,120 --> 00:11:24,160
new breakpoint uh back in main

00:11:21,519 --> 00:11:26,480
um just to to go back to a known place

00:11:24,160 --> 00:11:29,600
so breakpoint main.c

00:11:26,480 --> 00:11:30,959
and line 14. so we'll continue we'll hit

00:11:29,600 --> 00:11:32,320
our break point and now we can look

00:11:30,959 --> 00:11:33,920
again at the back trace so we can see

00:11:32,320 --> 00:11:35,279
there's only main so the stack frame has

00:11:33,920 --> 00:11:37,760
basically gone back

00:11:35,279 --> 00:11:39,120
to main so what about displaying

00:11:37,760 --> 00:11:41,200
variables that's where

00:11:39,120 --> 00:11:42,959
printing comes into play and we can use

00:11:41,200 --> 00:11:46,320
the print command

00:11:42,959 --> 00:11:48,160
for fairly rich display of variables or

00:11:46,320 --> 00:11:49,600
manipulation of variables or we can even

00:11:48,160 --> 00:11:51,760
perform

00:11:49,600 --> 00:11:53,920
sort of calculations on the specific

00:11:51,760 --> 00:11:56,240
variables or memory addresses

00:11:53,920 --> 00:11:58,480
or display arrays of data in in a

00:11:56,240 --> 00:12:00,639
variety of formats

00:11:58,480 --> 00:12:02,320
so let's see how that works in practice

00:12:00,639 --> 00:12:03,440
so let's just print variable i we've

00:12:02,320 --> 00:12:05,279
seen this before

00:12:03,440 --> 00:12:07,040
but let's print it now in hexadecimal

00:12:05,279 --> 00:12:10,240
with the x

00:12:07,040 --> 00:12:13,839
code or we can print it say

00:12:10,240 --> 00:12:17,360
the the the program counter variable

00:12:13,839 --> 00:12:18,880
where dollars is a notation to display

00:12:17,360 --> 00:12:22,160
or access or manipulate

00:12:18,880 --> 00:12:23,440
a named register value so i would

00:12:22,160 --> 00:12:24,480
encourage you to play around with the

00:12:23,440 --> 00:12:26,160
the print function

00:12:24,480 --> 00:12:27,600
just to familiarize yourself with it and

00:12:26,160 --> 00:12:30,160
how you can display the

00:12:27,600 --> 00:12:32,880
values associated with specific

00:12:30,160 --> 00:12:34,480
variables or addresses etc

00:12:32,880 --> 00:12:36,399
complementary to the print command is

00:12:34,480 --> 00:12:39,279
the examine command

00:12:36,399 --> 00:12:41,040
x which you can use to examine memory so

00:12:39,279 --> 00:12:44,079
you can show the address of a variable

00:12:41,040 --> 00:12:46,160
by by putting x and your variable name

00:12:44,079 --> 00:12:47,279
or you can examine the contents of of

00:12:46,160 --> 00:12:48,399
memory

00:12:47,279 --> 00:12:50,560
and there's some overlap between

00:12:48,399 --> 00:12:51,760
printing and and the print in the

00:12:50,560 --> 00:12:53,279
examine commands

00:12:51,760 --> 00:12:54,399
but they're they're they're generally

00:12:53,279 --> 00:12:55,760
quite complimentary and i would

00:12:54,399 --> 00:12:56,720
encourage you to play around with both

00:12:55,760 --> 00:12:58,880
the print

00:12:56,720 --> 00:13:00,079
the p and the x command just so you

00:12:58,880 --> 00:13:01,279
properly understand some of the

00:13:00,079 --> 00:13:03,120
differences between those

00:13:01,279 --> 00:13:05,360
between them so whereas one deals more

00:13:03,120 --> 00:13:06,240
with say the content maybe and the other

00:13:05,360 --> 00:13:08,639
might

00:13:06,240 --> 00:13:11,120
is useful to determine the address of

00:13:08,639 --> 00:13:12,639
where something is stored for example

00:13:11,120 --> 00:13:14,880
the two commands also give you very

00:13:12,639 --> 00:13:15,440
different ways maybe to to display the

00:13:14,880 --> 00:13:17,440
data

00:13:15,440 --> 00:13:18,880
so examine can also be used to print the

00:13:17,440 --> 00:13:22,880
contents of memory

00:13:18,880 --> 00:13:24,639
but it has a sort of a richer

00:13:22,880 --> 00:13:26,560
display capability you can display

00:13:24,639 --> 00:13:28,399
instructions or you can you can format

00:13:26,560 --> 00:13:30,160
things maybe with a bit more

00:13:28,399 --> 00:13:32,079
control and precision than the print

00:13:30,160 --> 00:13:33,839
command is able to offer

00:13:32,079 --> 00:13:35,200
gdb is also able to interact with the

00:13:33,839 --> 00:13:36,880
source code our c

00:13:35,200 --> 00:13:38,720
source code or whatever using something

00:13:36,880 --> 00:13:39,040
like the list command so that will give

00:13:38,720 --> 00:13:40,560
us

00:13:39,040 --> 00:13:42,480
by default the ten lines around our

00:13:40,560 --> 00:13:44,399
current location we can also list

00:13:42,480 --> 00:13:45,839
specific source like main.c the main

00:13:44,399 --> 00:13:47,199
function

00:13:45,839 --> 00:13:49,120
and this can be quite powerful in a

00:13:47,199 --> 00:13:50,720
sense because rather than just the c

00:13:49,120 --> 00:13:52,480
files you can actually access the

00:13:50,720 --> 00:13:52,959
disassembly of a function like main so

00:13:52,480 --> 00:13:57,279
you can see

00:13:52,959 --> 00:13:59,120
here the the assembly source code

00:13:57,279 --> 00:14:00,399
in terms of dealing with source code gdb

00:13:59,120 --> 00:14:02,000
has a find command

00:14:00,399 --> 00:14:03,680
which is extremely powerful and you can

00:14:02,000 --> 00:14:06,000
use it to scan a specific

00:14:03,680 --> 00:14:08,079
address range for a pattern or for a

00:14:06,000 --> 00:14:10,800
known value and this could be extremely

00:14:08,079 --> 00:14:12,480
um powerful when you're you're looking

00:14:10,800 --> 00:14:14,480
for a specific instance of something or

00:14:12,480 --> 00:14:17,199
maybe you want to check for example your

00:14:14,480 --> 00:14:18,639
your stack space or your stack memory if

00:14:17,199 --> 00:14:19,680
you've pre-filled that with a known

00:14:18,639 --> 00:14:22,560
value

00:14:19,680 --> 00:14:24,399
then you can check during program

00:14:22,560 --> 00:14:25,839
execution you can scan for that pattern

00:14:24,399 --> 00:14:27,360
using the find command

00:14:25,839 --> 00:14:29,279
and you can very quickly verify if

00:14:27,360 --> 00:14:31,680
you've had maybe a stack overflow or you

00:14:29,279 --> 00:14:33,600
can check your stack watermark levels

00:14:31,680 --> 00:14:35,600
so you can know for example up to

00:14:33,600 --> 00:14:38,000
exactly what point

00:14:35,600 --> 00:14:38,800
the the stack has been used by your

00:14:38,000 --> 00:14:40,880
application

00:14:38,800 --> 00:14:43,120
so maybe you can use this for example to

00:14:40,880 --> 00:14:45,440
claim back some some stack memory

00:14:43,120 --> 00:14:47,199
if you determine that you've defined a

00:14:45,440 --> 00:14:48,720
lot more stack memory than than you need

00:14:47,199 --> 00:14:50,000
in practice

00:14:48,720 --> 00:14:51,920
you can use it for many other things

00:14:50,000 --> 00:14:53,040
such as looking for for patterns like a

00:14:51,920 --> 00:14:55,360
string

00:14:53,040 --> 00:14:56,320
to find out where that that's that's

00:14:55,360 --> 00:14:58,480
stored in

00:14:56,320 --> 00:14:59,839
in in the image there's obviously other

00:14:58,480 --> 00:15:00,560
ways to do that as well but this is i

00:14:59,839 --> 00:15:02,000
think what

00:15:00,560 --> 00:15:04,240
a command that not a lot of people are

00:15:02,000 --> 00:15:05,839
aware of um that can save you a lot of

00:15:04,240 --> 00:15:06,639
time and and it's it's definitely well

00:15:05,839 --> 00:15:08,000
worth

00:15:06,639 --> 00:15:10,480
learning how to use it and playing

00:15:08,000 --> 00:15:11,680
around with it something else that gdp

00:15:10,480 --> 00:15:13,040
can do well that

00:15:11,680 --> 00:15:15,440
i don't think a lot of people are aware

00:15:13,040 --> 00:15:16,800
of and this isn't a common requirement

00:15:15,440 --> 00:15:18,720
but sometimes you have to deal with

00:15:16,800 --> 00:15:19,920
multiple l files when you're debugging a

00:15:18,720 --> 00:15:21,199
complex system maybe you have a

00:15:19,920 --> 00:15:24,079
bootloader

00:15:21,199 --> 00:15:24,959
a secure l file and a non-secure rail

00:15:24,079 --> 00:15:26,480
file

00:15:24,959 --> 00:15:28,320
such as with the project like trusted

00:15:26,480 --> 00:15:30,399
firmware m

00:15:28,320 --> 00:15:31,920
generally most debugging systems will

00:15:30,399 --> 00:15:34,639
only allow you to debug

00:15:31,920 --> 00:15:35,440
one file at a time and that's true also

00:15:34,639 --> 00:15:37,600
gdb

00:15:35,440 --> 00:15:38,720
but gdp does have a command called

00:15:37,600 --> 00:15:40,240
symbol file

00:15:38,720 --> 00:15:41,759
which will allow you to sort of

00:15:40,240 --> 00:15:44,800
dynamically switch the l

00:15:41,759 --> 00:15:45,120
file that is currently being used by gdb

00:15:44,800 --> 00:15:47,040
that

00:15:45,120 --> 00:15:48,399
is used for symbol lookup and and just

00:15:47,040 --> 00:15:50,399
to to to check

00:15:48,399 --> 00:15:52,800
associate variable names with addresses

00:15:50,399 --> 00:15:54,320
etc so

00:15:52,800 --> 00:15:56,399
this is something that that can that can

00:15:54,320 --> 00:15:59,440
definitely be a lifesaver if you're

00:15:56,399 --> 00:16:01,759
debugging say a a trusted firmware m

00:15:59,440 --> 00:16:03,199
project and you're stepping from the

00:16:01,759 --> 00:16:05,199
non-secure

00:16:03,199 --> 00:16:07,360
zone into the secure zone which will be

00:16:05,199 --> 00:16:10,639
generally two different l files

00:16:07,360 --> 00:16:12,320
um so you can continue to debug across

00:16:10,639 --> 00:16:14,000
those boundaries or maybe when you step

00:16:12,320 --> 00:16:14,399
into the bootloader for example which is

00:16:14,000 --> 00:16:15,920
a

00:16:14,399 --> 00:16:17,519
perhaps a separate build and also a

00:16:15,920 --> 00:16:19,199
separate l file

00:16:17,519 --> 00:16:20,720
um so if you're not familiar with it

00:16:19,199 --> 00:16:24,160
then that

00:16:20,720 --> 00:16:24,560
that command can definitely uh make your

00:16:24,160 --> 00:16:27,839
d

00:16:24,560 --> 00:16:29,040
your debugging life a bit easier so now

00:16:27,839 --> 00:16:30,880
that we've given sort of the basic

00:16:29,040 --> 00:16:32,560
theory and common commands let's look at

00:16:30,880 --> 00:16:34,160
some practical examples

00:16:32,560 --> 00:16:35,600
of how to debug sort of one or two

00:16:34,160 --> 00:16:37,120
really common problems

00:16:35,600 --> 00:16:39,920
that you'll encounter with cortex-m

00:16:37,120 --> 00:16:42,720
systems when you're you're debugging

00:16:39,920 --> 00:16:43,680
a common one is isr stack rollback so

00:16:42,720 --> 00:16:45,440
this is where you

00:16:43,680 --> 00:16:46,959
enter your interrupt handler and maybe

00:16:45,440 --> 00:16:50,399
that's a hard fault handler

00:16:46,959 --> 00:16:52,480
or a usage fault handler or something

00:16:50,399 --> 00:16:54,079
and basically the the system processor

00:16:52,480 --> 00:16:56,000
changes state so that what's in the

00:16:54,079 --> 00:16:58,160
current stack frame that you access

00:16:56,000 --> 00:16:59,440
doesn't represent where you were just

00:16:58,160 --> 00:17:01,440
one frame ago

00:16:59,440 --> 00:17:03,199
but you want to step back one frame to

00:17:01,440 --> 00:17:05,600
understand how did i end up

00:17:03,199 --> 00:17:07,520
in this fault hander handler so that's

00:17:05,600 --> 00:17:10,160
where isr stack rollback

00:17:07,520 --> 00:17:10,959
comes into play and it's a very common

00:17:10,160 --> 00:17:12,400
operation

00:17:10,959 --> 00:17:14,880
that you're going to need to do and it

00:17:12,400 --> 00:17:16,559
requires a bit of manual calculation

00:17:14,880 --> 00:17:18,079
generally and we'll show you a way at

00:17:16,559 --> 00:17:19,199
the end of this talk how we can speed

00:17:18,079 --> 00:17:22,079
that process up

00:17:19,199 --> 00:17:24,000
but first let's explain how with gdb we

00:17:22,079 --> 00:17:25,280
would perform an isr stack rollback

00:17:24,000 --> 00:17:26,880
manually

00:17:25,280 --> 00:17:28,799
so let's see how this works in practice

00:17:26,880 --> 00:17:30,640
we'll first put our device into a known

00:17:28,799 --> 00:17:32,880
state so monitor reset halt

00:17:30,640 --> 00:17:34,400
set a temporary break point on main

00:17:32,880 --> 00:17:36,480
continue

00:17:34,400 --> 00:17:38,080
so step into one or two lines of code

00:17:36,480 --> 00:17:40,160
here and if you remember we put an

00:17:38,080 --> 00:17:43,919
intentional divide by zero error

00:17:40,160 --> 00:17:45,600
code into our rc file

00:17:43,919 --> 00:17:47,919
so let's just continue run to the end

00:17:45,600 --> 00:17:50,799
and we should hit the hard fault handler

00:17:47,919 --> 00:17:52,799
and um there it is so all of this red

00:17:50,799 --> 00:17:53,840
code is actually zephyr's debug handler

00:17:52,799 --> 00:17:55,200
it's kind of cheating

00:17:53,840 --> 00:17:57,039
because we can actually see the address

00:17:55,200 --> 00:17:58,160
where the error came from but we're just

00:17:57,039 --> 00:17:59,440
going to ignore that for now

00:17:58,160 --> 00:18:01,520
and pretend we don't have that

00:17:59,440 --> 00:18:03,679
information and try to figure it out for

00:18:01,520 --> 00:18:06,320
ourselves in gd using only gdp

00:18:03,679 --> 00:18:07,520
so control c stops execution and we can

00:18:06,320 --> 00:18:09,600
see where we've stopped

00:18:07,520 --> 00:18:10,720
um and so let's check the system

00:18:09,600 --> 00:18:12,720
registers

00:18:10,720 --> 00:18:14,720
and you want to look specifically at the

00:18:12,720 --> 00:18:16,960
lr register

00:18:14,720 --> 00:18:18,080
so because that's going to tell us

00:18:16,960 --> 00:18:19,200
whether we want to look at the main

00:18:18,080 --> 00:18:23,039
stack pointer

00:18:19,200 --> 00:18:25,679
or the uh the the psp

00:18:23,039 --> 00:18:28,720
so based on the the bit number two in

00:18:25,679 --> 00:18:31,039
this which is one in this case then

00:18:28,720 --> 00:18:32,559
we know um depending on whether it's a

00:18:31,039 --> 00:18:34,960
one or zero but since it's a one

00:18:32,559 --> 00:18:37,039
that means that we we need to be looking

00:18:34,960 --> 00:18:40,640
at the the psp

00:18:37,039 --> 00:18:42,480
so let's just print the the contents of

00:18:40,640 --> 00:18:45,440
the psp

00:18:42,480 --> 00:18:46,799
register so just dollars uh dollars psp

00:18:45,440 --> 00:18:50,000
oh sorry let's print the

00:18:46,799 --> 00:18:52,559
the the first eight words at the psp

00:18:50,000 --> 00:18:53,360
and so this gives us our previous stack

00:18:52,559 --> 00:18:56,720
frame

00:18:53,360 --> 00:18:59,760
um from from the the psp and we want

00:18:56,720 --> 00:19:03,440
the seventh entry in this which is the

00:18:59,760 --> 00:19:05,200
um peripheral the program counter um

00:19:03,440 --> 00:19:07,039
where we were before we entered the hard

00:19:05,200 --> 00:19:08,720
fault so if we list the source code for

00:19:07,039 --> 00:19:12,240
that we can see exactly the

00:19:08,720 --> 00:19:12,240
the line where our error occurred

00:19:13,200 --> 00:19:16,240
let's say it's not obvious though what

00:19:14,799 --> 00:19:17,520
the cause of our error is

00:19:16,240 --> 00:19:19,280
that's where we can look at the some

00:19:17,520 --> 00:19:22,480
fault identification

00:19:19,280 --> 00:19:24,000
status registers which exist on the

00:19:22,480 --> 00:19:25,919
cortex m so the three main ones

00:19:24,000 --> 00:19:27,520
are listed here are the three three the

00:19:25,919 --> 00:19:29,600
most useful ones we should start with

00:19:27,520 --> 00:19:30,480
the system handler control and state

00:19:29,600 --> 00:19:32,960
register

00:19:30,480 --> 00:19:35,120
and that will tell you what kind of of

00:19:32,960 --> 00:19:36,960
interrupt we have memphis bus fault hard

00:19:35,120 --> 00:19:38,320
fault or usage fault

00:19:36,960 --> 00:19:40,799
and then based on that you can look at

00:19:38,320 --> 00:19:41,520
the hfsr if it's a hard fault register

00:19:40,799 --> 00:19:44,400
or for any

00:19:41,520 --> 00:19:46,400
the other types the cfsr and the cfsr

00:19:44,400 --> 00:19:49,679
contains basically

00:19:46,400 --> 00:19:52,080
the sort of sub register values for

00:19:49,679 --> 00:19:53,280
usage faults bus faults or memory

00:19:52,080 --> 00:19:55,440
management faults

00:19:53,280 --> 00:19:56,799
depending on which which error you

00:19:55,440 --> 00:19:59,840
identified earlier with the

00:19:56,799 --> 00:20:01,520
um shcsr so you'll want to look at the

00:19:59,840 --> 00:20:02,640
sort of one one subset of this register

00:20:01,520 --> 00:20:04,400
and then that will tell you

00:20:02,640 --> 00:20:06,720
for example is just a divide by zero

00:20:04,400 --> 00:20:08,640
unaligned access error

00:20:06,720 --> 00:20:10,320
whatever the case might be so that will

00:20:08,640 --> 00:20:12,799
help you understand exactly

00:20:10,320 --> 00:20:14,320
why you ended up in this heart fan

00:20:12,799 --> 00:20:17,600
haltfan

00:20:14,320 --> 00:20:19,280
fault handler if it isn't obvious

00:20:17,600 --> 00:20:21,600
based on the specific line of source

00:20:19,280 --> 00:20:22,799
code so let's look at an example of how

00:20:21,600 --> 00:20:23,840
this works in the real world so

00:20:22,799 --> 00:20:26,799
basically we would want to

00:20:23,840 --> 00:20:27,679
print in hexadecimal or maybe in binary

00:20:26,799 --> 00:20:30,640
the sc

00:20:27,679 --> 00:20:32,000
shcsr value and in this case by looking

00:20:30,640 --> 00:20:34,240
at the the output of

00:20:32,000 --> 00:20:35,440
that register read we can tell that this

00:20:34,240 --> 00:20:37,120
is a usage fault

00:20:35,440 --> 00:20:39,919
so based on that then we're going to

00:20:37,120 --> 00:20:42,559
look at cfsr bits 16 to 31

00:20:39,919 --> 00:20:43,360
which are the usage fault status

00:20:42,559 --> 00:20:44,880
register

00:20:43,360 --> 00:20:46,400
and that's going to tell us that this is

00:20:44,880 --> 00:20:48,559
a divide by zero arrow

00:20:46,400 --> 00:20:50,320
error so let's see that in gdb just to

00:20:48,559 --> 00:20:53,120
see how it works there

00:20:50,320 --> 00:20:54,400
i'm going to switch to jlink gdb server

00:20:53,120 --> 00:20:56,080
to read these registers just because

00:20:54,400 --> 00:20:57,520
there seems to be an issue with pi ocd

00:20:56,080 --> 00:20:59,360
at least the version i'm using

00:20:57,520 --> 00:21:00,799
accessing them so let's start up j-link

00:20:59,360 --> 00:21:02,559
gdp server first

00:21:00,799 --> 00:21:05,600
and then we'll access those uh those

00:21:02,559 --> 00:21:08,080
registers from from a gdp session there

00:21:05,600 --> 00:21:08,799
so here we are in our gdb session um

00:21:08,080 --> 00:21:10,559
using the

00:21:08,799 --> 00:21:11,840
j-link gdb server so let's just clear

00:21:10,559 --> 00:21:14,480
the screen here

00:21:11,840 --> 00:21:16,080
and let's check the sh csr just printing

00:21:14,480 --> 00:21:18,159
it in hexadecimal

00:21:16,080 --> 00:21:19,120
pointing to the the correct memory

00:21:18,159 --> 00:21:20,640
address

00:21:19,120 --> 00:21:23,120
and we can see that since bit three is

00:21:20,640 --> 00:21:24,720
one here this is a usage fault

00:21:23,120 --> 00:21:27,520
and then we can continue to check the

00:21:24,720 --> 00:21:28,240
ufsr and other registers to understand

00:21:27,520 --> 00:21:30,320
that more

00:21:28,240 --> 00:21:31,679
deeply so that brings us to the

00:21:30,320 --> 00:21:33,600
interesting question of how can we

00:21:31,679 --> 00:21:37,360
automate some of these steps

00:21:33,600 --> 00:21:39,520
and recent versions of gdb have

00:21:37,360 --> 00:21:41,360
integration with python so you can

00:21:39,520 --> 00:21:42,320
actually write your own scripts and

00:21:41,360 --> 00:21:44,480
functions

00:21:42,320 --> 00:21:45,679
directly in python and this can be very

00:21:44,480 --> 00:21:47,919
powerful especially

00:21:45,679 --> 00:21:49,760
if you're you need to parse specific

00:21:47,919 --> 00:21:51,679
bits or combine different values and you

00:21:49,760 --> 00:21:53,840
can write very rich

00:21:51,679 --> 00:21:55,280
helper functions basically things that

00:21:53,840 --> 00:21:56,960
you would not easily be able to do in a

00:21:55,280 --> 00:21:58,559
graphical ide

00:21:56,960 --> 00:22:00,159
and i really think this is one of the

00:21:58,559 --> 00:22:02,880
one of the most powerful

00:22:00,159 --> 00:22:04,559
features that the gdp exposes to you i'm

00:22:02,880 --> 00:22:07,600
trying to debug these these

00:22:04,559 --> 00:22:09,120
complex problems on deeply embedded

00:22:07,600 --> 00:22:10,559
systems

00:22:09,120 --> 00:22:12,320
we don't we don't have the time really

00:22:10,559 --> 00:22:14,080
to go into this in a lot of detail

00:22:12,320 --> 00:22:15,760
but hopefully this will at least sort of

00:22:14,080 --> 00:22:17,039
scratch the surface and you can really

00:22:15,760 --> 00:22:19,600
dig into it i guess for

00:22:17,039 --> 00:22:21,280
extra credit not every version of gdb

00:22:19,600 --> 00:22:23,280
supports python so make sure you're

00:22:21,280 --> 00:22:25,840
using one that does before you try to

00:22:23,280 --> 00:22:27,520
use any of these samples so to start

00:22:25,840 --> 00:22:29,600
with let's look at the absolute minimum

00:22:27,520 --> 00:22:30,480
possible gdb user command and this is

00:22:29,600 --> 00:22:31,919
basically

00:22:30,480 --> 00:22:34,080
a command that you'll implement that you

00:22:31,919 --> 00:22:36,480
can run inside the gdp client

00:22:34,080 --> 00:22:37,600
when you're debugging and so there's

00:22:36,480 --> 00:22:40,400
just a few lines of code that are

00:22:37,600 --> 00:22:42,240
required and you can link you can follow

00:22:40,400 --> 00:22:43,679
the bitly link here to see a gist where

00:22:42,240 --> 00:22:45,919
i published

00:22:43,679 --> 00:22:47,679
this minimal example and basically this

00:22:45,919 --> 00:22:50,720
is what what you're going to need to do

00:22:47,679 --> 00:22:51,280
to to to implement your own command

00:22:50,720 --> 00:22:53,440
handler

00:22:51,280 --> 00:22:54,559
so have a look at that source code and

00:22:53,440 --> 00:22:56,480
then you can

00:22:54,559 --> 00:22:57,600
see how are we how do you load those

00:22:56,480 --> 00:22:59,039
scripts

00:22:57,600 --> 00:23:01,039
and we do that with the the source

00:22:59,039 --> 00:23:01,679
command pointing to the specific python

00:23:01,039 --> 00:23:02,960
file

00:23:01,679 --> 00:23:05,679
so let's see how that works in practice

00:23:02,960 --> 00:23:06,640
we put source projects just where i have

00:23:05,679 --> 00:23:10,000
my file slash

00:23:06,640 --> 00:23:12,400
gdb slash scripts slash minimal

00:23:10,000 --> 00:23:13,919
dot pi and that's going to load my

00:23:12,400 --> 00:23:16,799
python function then we can run it

00:23:13,919 --> 00:23:18,720
so let's just type minimal and that'll

00:23:16,799 --> 00:23:20,559
show me my program counter

00:23:18,720 --> 00:23:22,720
now unfortunately we're out of time but

00:23:20,559 --> 00:23:26,080
i put together a more complex

00:23:22,720 --> 00:23:28,240
and interesting python example

00:23:26,080 --> 00:23:29,520
called fault handler that basically ties

00:23:28,240 --> 00:23:30,480
together a lot of what we've seen in

00:23:29,520 --> 00:23:32,559
this in

00:23:30,480 --> 00:23:34,000
in this talk including isr stack

00:23:32,559 --> 00:23:35,600
rollbacks checking where you are in the

00:23:34,000 --> 00:23:37,039
source code etc

00:23:35,600 --> 00:23:38,960
so have a look at the source code you

00:23:37,039 --> 00:23:43,200
can see the link

00:23:38,960 --> 00:23:46,159
to bitly here and

00:23:43,200 --> 00:23:47,919
load that script and i think you you can

00:23:46,159 --> 00:23:49,679
you can take that as a starting point to

00:23:47,919 --> 00:23:51,279
to make fairly complex um

00:23:49,679 --> 00:23:52,960
sort of debugging scripts yourself and i

00:23:51,279 --> 00:23:55,760
hope you found this useful

00:23:52,960 --> 00:23:57,279
uh i i hope that you'll you'll give gdb

00:23:55,760 --> 00:23:58,400
a look if it's new to you or you'll give

00:23:57,279 --> 00:24:01,760
it another look

00:23:58,400 --> 00:24:02,640
if you're used to graphical ides and um

00:24:01,760 --> 00:24:05,520
yeah

00:24:02,640 --> 00:24:08,080
let us know in the in sort of the rest

00:24:05,520 --> 00:24:09,440
of linear connect or or offline

00:24:08,080 --> 00:24:11,440
um if you find some interesting

00:24:09,440 --> 00:24:12,799
functionality that maybe it'll turn into

00:24:11,440 --> 00:24:14,640
another talk at the next one i'll

00:24:12,799 --> 00:24:16,320
connect so thanks for your time thanks

00:24:14,640 --> 00:24:17,200
for your participation and i hope this

00:24:16,320 --> 00:24:20,320
has been a

00:24:17,200 --> 00:24:25,760
an interesting use of your 25 minutes

00:24:20,320 --> 00:24:25,760

YouTube URL: https://www.youtube.com/watch?v=QQcp8CPjkoY


