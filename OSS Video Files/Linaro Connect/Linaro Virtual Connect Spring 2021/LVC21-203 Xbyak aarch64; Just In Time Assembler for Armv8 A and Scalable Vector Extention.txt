Title: LVC21-203 Xbyak aarch64; Just In Time Assembler for Armv8 A and Scalable Vector Extention
Publication date: 2021-04-15
Playlist: Linaro Virtual Connect Spring 2021
Description: 
	We have developed Xbyak_aarch64, a just-in-time (JIT) assembler for Armv8-A. JIT assembler can generate executable code dynamically depending on the runtime environment (available instruction set, cache size, runtime parameters, etc.), so it can be used for applications that want to tune the performance to the extreme. As an example of the success of Xbyak_aarch64, the Arm CPU-based supercomputer Fugaku achieved the world's best performance in Deep Learning training process among CPU-based high performance systems last year (https://www.fujitsu.com/global/about/resources/news/press-releases/2020/1119-02.html). Xbyak_aarch64 is available as an OSS source on github.com/fujitsu/xbyak_aarch64. Anyone can use it and participate in its development.
Captions: 
	00:00:05,359 --> 00:00:09,599
thank you for

00:00:06,240 --> 00:00:12,799
attending my session i'll introduce

00:00:09,599 --> 00:00:16,480
kybak arc64 just in time

00:00:12,799 --> 00:00:20,880
assembler for a mv8a

00:00:16,480 --> 00:00:20,880
and scalable vector extension

00:00:21,199 --> 00:00:27,279
my name is kentaro kawakami i'm working

00:00:24,640 --> 00:00:29,920
for fujitsu level japan

00:00:27,279 --> 00:00:31,760
i'm working on research and development

00:00:29,920 --> 00:00:34,559
of ai software

00:00:31,760 --> 00:00:36,880
running on the supercomputer fugac for

00:00:34,559 --> 00:00:39,280
the last two years

00:00:36,880 --> 00:00:40,399
hugaku is the world's first

00:00:39,280 --> 00:00:45,840
supercomputer

00:00:40,399 --> 00:00:45,840
which uses the arm instruction set cpu

00:00:47,200 --> 00:00:54,000
here is the table of contents

00:00:50,719 --> 00:00:57,600
firstly i'll introduce what's its

00:00:54,000 --> 00:00:59,440
kayak arc 64 what is a just-in-time

00:00:57,600 --> 00:01:02,800
assembler

00:00:59,440 --> 00:01:05,040
and i'll show you some sample programs

00:01:02,800 --> 00:01:08,240
of kaiba kayak

00:01:05,040 --> 00:01:12,159
secondly i'll show you the requirement

00:01:08,240 --> 00:01:12,960
for using kaiba kayak thirdly i'll

00:01:12,159 --> 00:01:17,119
explain

00:01:12,960 --> 00:01:20,720
how to write programs with kaibab arc

00:01:17,119 --> 00:01:23,920
and then i'll discuss how to debug

00:01:20,720 --> 00:01:27,840
kybeek programs lastly

00:01:23,920 --> 00:01:27,840
i'll summarize this talk

00:01:28,000 --> 00:01:33,360
what is kayak ax64

00:01:35,360 --> 00:01:42,240
kaiba kayak is a just in time assembler

00:01:38,880 --> 00:01:46,000
for arm instruction set which is

00:01:42,240 --> 00:01:48,479
written in standard c plus plus

00:01:46,000 --> 00:01:50,399
the just in time assembler can generate

00:01:48,479 --> 00:01:53,520
machine instruction sequence

00:01:50,399 --> 00:01:56,640
at runtime the generated

00:01:53,520 --> 00:01:57,520
mass instruction sequence can be used as

00:01:56,640 --> 00:02:00,560
a function

00:01:57,520 --> 00:02:03,600
from your program

00:02:00,560 --> 00:02:07,600
the first jit assembler was developed

00:02:03,600 --> 00:02:11,599
for intel cpu by sigel missionary of

00:02:07,600 --> 00:02:15,040
cyborg level japan based on the

00:02:11,599 --> 00:02:15,760
concept of the original kaibiak kaibaku

00:02:15,040 --> 00:02:22,000
ayak

00:02:15,760 --> 00:02:25,200
is developed for arm instruction set

00:02:22,000 --> 00:02:29,040
this page shows the minimal sample code

00:02:25,200 --> 00:02:32,640
which uses kaibaku ayaki the red

00:02:29,040 --> 00:02:36,160
board takes stands for kyber k functions

00:02:32,640 --> 00:02:39,760
classes and instances

00:02:36,160 --> 00:02:43,440
if you want to use kyber credit include

00:02:39,760 --> 00:02:44,000
the header file and define your own

00:02:43,440 --> 00:02:47,360
class

00:02:44,000 --> 00:02:50,319
in hurricane called generator class and

00:02:47,360 --> 00:02:52,720
implement instruction sequence you want

00:02:50,319 --> 00:02:52,720
to do

00:02:53,280 --> 00:02:57,519
if you make an instance of your code

00:02:55,840 --> 00:02:59,519
generator class

00:02:57,519 --> 00:03:00,560
the machine instruction sequence you

00:02:59,519 --> 00:03:04,720
defined are

00:03:00,560 --> 00:03:07,680
written in memory at runtime

00:03:04,720 --> 00:03:08,480
the getcode function returns the entry

00:03:07,680 --> 00:03:11,840
address

00:03:08,480 --> 00:03:15,200
of generated instruction sequence so

00:03:11,840 --> 00:03:19,040
the variable f can be used

00:03:15,200 --> 00:03:20,159
as a function pointer your program can

00:03:19,040 --> 00:03:23,120
freely call it

00:03:20,159 --> 00:03:23,120
as a function

00:03:25,519 --> 00:03:29,840
in the constructor function of this this

00:03:28,720 --> 00:03:33,519
sample

00:03:29,840 --> 00:03:36,640
there are the add function and

00:03:33,519 --> 00:03:38,560
red function we call

00:03:36,640 --> 00:03:40,720
these functions as the mnemonic

00:03:38,560 --> 00:03:43,599
functions

00:03:40,720 --> 00:03:43,920
the function name is one of the mnemonic

00:03:43,599 --> 00:03:47,280
of

00:03:43,920 --> 00:03:49,599
our instruction set each function writes

00:03:47,280 --> 00:03:52,080
a single machine code

00:03:49,599 --> 00:03:53,439
on the memory corresponding to the

00:03:52,080 --> 00:03:56,640
function name

00:03:53,439 --> 00:04:00,239
such as at sub

00:03:56,640 --> 00:04:04,080
route register store register return

00:04:00,239 --> 00:04:06,480
and so on and the

00:04:04,080 --> 00:04:09,280
functions arguments indicates the

00:04:06,480 --> 00:04:13,120
instruction operands

00:04:09,280 --> 00:04:16,320
here double 0 and w1 stands for

00:04:13,120 --> 00:04:19,359
32-bit general purpose registers on

00:04:16,320 --> 00:04:19,359
a cpu

00:04:23,919 --> 00:04:30,960
an instruction set includes about 1000

00:04:27,600 --> 00:04:35,199
mnemonics and each mnemonic can be

00:04:30,960 --> 00:04:38,479
followed by various types of operands

00:04:35,199 --> 00:04:40,960
for example the mnemonic ad can be

00:04:38,479 --> 00:04:42,400
combined with 32-bit general purpose

00:04:40,960 --> 00:04:45,440
registers

00:04:42,400 --> 00:04:48,880
64 bits general purpose registers

00:04:45,440 --> 00:04:52,320
hmd registers and sve

00:04:48,880 --> 00:04:56,880
registers the mnemonic function of

00:04:52,320 --> 00:05:00,560
kyber creak supports all of them

00:04:56,880 --> 00:05:03,360
we can generate any machine codes using

00:05:00,560 --> 00:05:05,919
all the instructions supported by arm

00:05:03,360 --> 00:05:05,919
cpu

00:05:08,000 --> 00:05:13,919
i think the gta assembler has

00:05:11,039 --> 00:05:14,800
two major advantages compared to the

00:05:13,919 --> 00:05:19,039
existing

00:05:14,800 --> 00:05:22,479
assembler the first advantage is that

00:05:19,039 --> 00:05:25,759
jit assembler make it easier to write

00:05:22,479 --> 00:05:28,720
instruction level code since

00:05:25,759 --> 00:05:29,840
skype reach is implemented in c plus

00:05:28,720 --> 00:05:32,479
plus

00:05:29,840 --> 00:05:33,120
we can write our instruction level code

00:05:32,479 --> 00:05:35,759
in c

00:05:33,120 --> 00:05:35,759
plus plus

00:05:36,160 --> 00:05:43,039
the left side sample has two c

00:05:39,199 --> 00:05:47,680
plus plus lines these two lines generate

00:05:43,039 --> 00:05:51,840
15 fmla machine instructions

00:05:47,680 --> 00:05:53,600
but if we use the existing assembler or

00:05:51,840 --> 00:05:58,639
inline assembler

00:05:53,600 --> 00:06:02,319
we have to write 15 lines at least

00:05:58,639 --> 00:06:05,280
not only the for loop but we can combine

00:06:02,319 --> 00:06:06,000
other c plus plus syntax to construct

00:06:05,280 --> 00:06:09,440
machine code

00:06:06,000 --> 00:06:09,440
sequence efficiently

00:06:09,759 --> 00:06:14,880
the right side shows the dynamical

00:06:12,560 --> 00:06:17,919
instruction selection

00:06:14,880 --> 00:06:22,160
here we consider division

00:06:17,919 --> 00:06:22,160
r1 over the pattern

00:06:22,479 --> 00:06:29,280
the r1 register has the dividend

00:06:26,000 --> 00:06:32,880
number and the parameter is the

00:06:29,280 --> 00:06:36,800
divisor as you know if the divisor is

00:06:32,880 --> 00:06:39,360
power of 2 we can use logical shift to

00:06:36,800 --> 00:06:40,960
write instruction instead of division

00:06:39,360 --> 00:06:43,680
instruction

00:06:40,960 --> 00:06:46,639
and it's preferable in terms of

00:06:43,680 --> 00:06:46,639
execution ratings

00:06:47,280 --> 00:06:53,039
if the param is a runtime parameter

00:06:50,800 --> 00:06:55,440
the compiler can't decide it's a

00:06:53,039 --> 00:06:58,400
parameter it's power over 2

00:06:55,440 --> 00:07:01,120
so that the compilers always select the

00:06:58,400 --> 00:07:03,840
division instruction

00:07:01,120 --> 00:07:04,639
but jits can check the most preferable

00:07:03,840 --> 00:07:08,720
instruction

00:07:04,639 --> 00:07:12,319
considering runtime conditions

00:07:08,720 --> 00:07:14,720
this page only shows the simple example

00:07:12,319 --> 00:07:15,599
but we can dynamically optimize our

00:07:14,720 --> 00:07:18,800
machine code

00:07:15,599 --> 00:07:18,800
in many other ways

00:07:21,120 --> 00:07:27,520
here is a simple performance comparison

00:07:24,479 --> 00:07:28,479
as an example i choose reduction

00:07:27,520 --> 00:07:32,000
operation

00:07:28,479 --> 00:07:36,479
where the data in an array of size

00:07:32,000 --> 00:07:39,759
n is accumulated to the variable s

00:07:36,479 --> 00:07:42,880
the execution time of the reference code

00:07:39,759 --> 00:07:46,080
is 23.24

00:07:42,880 --> 00:07:47,120
seconds of course we can tune the

00:07:46,080 --> 00:07:50,160
reference code

00:07:47,120 --> 00:07:52,160
with the pragma or impeachment to use

00:07:50,160 --> 00:07:56,280
cmd instructions

00:07:52,160 --> 00:07:59,199
in this case the time is reduced to

00:07:56,280 --> 00:08:02,319
6.3 seconds

00:07:59,199 --> 00:08:04,319
but we but if we use

00:08:02,319 --> 00:08:06,240
kyber crack to generate the

00:08:04,319 --> 00:08:09,280
international instruction sequence

00:08:06,240 --> 00:08:12,479
to use all the vector registers

00:08:09,280 --> 00:08:14,080
and optimize the instruction order the

00:08:12,479 --> 00:08:18,000
execution time becomes

00:08:14,080 --> 00:08:22,400
zero point four five so kybeck arc

00:08:18,000 --> 00:08:24,879
achieves very good calculation speed

00:08:22,400 --> 00:08:25,680
by the way we have to consider the

00:08:24,879 --> 00:08:27,840
overhead

00:08:25,680 --> 00:08:30,160
to generate the machine code sequence

00:08:27,840 --> 00:08:33,919
dynamically

00:08:30,160 --> 00:08:37,760
it depends on the code size we generate

00:08:33,919 --> 00:08:40,560
the overhead is about 1 milliseconds

00:08:37,760 --> 00:08:42,800
so the jit assembler is useful in

00:08:40,560 --> 00:08:46,880
applications

00:08:42,800 --> 00:08:50,399
which is which creates code

00:08:46,880 --> 00:08:55,120
jit code once and it's used

00:08:50,399 --> 00:08:58,000
many times

00:08:55,120 --> 00:08:58,720
and next i'll show you the environment

00:08:58,000 --> 00:09:02,560
where

00:08:58,720 --> 00:09:02,560
kaiba kayak can operate

00:09:03,920 --> 00:09:07,120
this space shows the main development

00:09:06,080 --> 00:09:10,720
target of

00:09:07,120 --> 00:09:12,720
kaiba kayak we developed kyber kayak for

00:09:10,720 --> 00:09:16,800
the supercomputer fugak

00:09:12,720 --> 00:09:20,640
and its derivative systems fx 1000

00:09:16,800 --> 00:09:24,160
and 700s these system

00:09:20,640 --> 00:09:26,160
use fujitsu a64 fx cpu

00:09:24,160 --> 00:09:27,360
which is designed for high performance

00:09:26,160 --> 00:09:30,800
computing and

00:09:27,360 --> 00:09:31,760
comprises with the rv8a activechat

00:09:30,800 --> 00:09:36,160
profile

00:09:31,760 --> 00:09:38,880
and the scalable vector extension

00:09:36,160 --> 00:09:40,080
since kayak is written in standard c

00:09:38,880 --> 00:09:43,360
plus plus

00:09:40,080 --> 00:09:46,480
we can use various c plus plus compilers

00:09:43,360 --> 00:09:51,839
such as fujitsu c plus plus compiler

00:09:46,480 --> 00:09:51,839
gcc and error vm

00:09:56,399 --> 00:10:04,160
and not only a64fx but

00:09:59,680 --> 00:10:06,720
i've tried kaibaker on other platforms

00:10:04,160 --> 00:10:08,800
this table shows the proven working

00:10:06,720 --> 00:10:13,279
configurations

00:10:08,800 --> 00:10:18,079
kyber kr can run on cpu emulator qm

00:10:13,279 --> 00:10:21,519
april m1 mac and raspberry pi

00:10:18,079 --> 00:10:24,240
one dnl is one of the applications

00:10:21,519 --> 00:10:26,560
that uses all the functionality of

00:10:24,240 --> 00:10:30,000
kaivia kayak

00:10:26,560 --> 00:10:31,360
we confirmed one dna works correctly on

00:10:30,000 --> 00:10:35,120
these platforms

00:10:31,360 --> 00:10:38,320
so we can say kyber kayak works well

00:10:35,120 --> 00:10:38,320
on this platform

00:10:40,959 --> 00:10:47,839
now i'll explain how to write code with

00:10:44,320 --> 00:10:47,839
kyber crack

00:10:49,680 --> 00:10:53,839
the prototype declaration of mnemonic

00:10:52,320 --> 00:10:57,200
functions are rested

00:10:53,839 --> 00:11:01,519
in kyber kxd4 mnemonic def

00:10:57,200 --> 00:11:02,640
dot hetero5 the usage is samples of

00:11:01,519 --> 00:11:05,440
mnemonic functions

00:11:02,640 --> 00:11:06,079
are written in the files of the mnemonic

00:11:05,440 --> 00:11:09,519
syntax

00:11:06,079 --> 00:11:12,079
directly if you want to know

00:11:09,519 --> 00:11:14,160
how to use the mnemonic function of a

00:11:12,079 --> 00:11:18,000
particular instruction

00:11:14,160 --> 00:11:18,000
you can graph these files

00:11:19,839 --> 00:11:26,320
kaiba kayak defines double bridge

00:11:23,200 --> 00:11:29,440
and x-rays classes for

00:11:26,320 --> 00:11:31,040
32-bit and 64-bit general purpose

00:11:29,440 --> 00:11:35,200
registers

00:11:31,040 --> 00:11:37,600
and kaibaker cuts the instances of these

00:11:35,200 --> 00:11:40,640
register classes

00:11:37,600 --> 00:11:41,519
of course you can freely define register

00:11:40,640 --> 00:11:45,680
instances

00:11:41,519 --> 00:11:48,399
like the sample a of this page

00:11:45,680 --> 00:11:49,360
the generated code will be the same

00:11:48,399 --> 00:11:52,560
regardless

00:11:49,360 --> 00:11:52,880
of which register instance you use like

00:11:52,560 --> 00:11:56,399
the

00:11:52,880 --> 00:11:58,959
sample b

00:11:56,399 --> 00:11:59,680
register instances can be made on the

00:11:58,959 --> 00:12:03,120
fly

00:11:59,680 --> 00:12:03,120
like the sample c

00:12:03,519 --> 00:12:10,399
kyber kayak also defined the classes

00:12:07,040 --> 00:12:15,200
for 128-bit simple registers

00:12:10,399 --> 00:12:18,959
sve registers and predicate registers

00:12:15,200 --> 00:12:21,200
please refer the readme file of kayak ar

00:12:18,959 --> 00:12:21,200
key

00:12:23,360 --> 00:12:26,639
this page shows the general purpose

00:12:25,360 --> 00:12:29,040
register usage

00:12:26,639 --> 00:12:31,680
in the procedure called standards for

00:12:29,040 --> 00:12:34,399
the arm architecture

00:12:31,680 --> 00:12:35,519
if you want to pass parameters to your

00:12:34,399 --> 00:12:38,240
gt code

00:12:35,519 --> 00:12:40,000
and receive a return value from the

00:12:38,240 --> 00:12:43,120
dictated code

00:12:40,000 --> 00:12:46,720
you can construct instruction sequences

00:12:43,120 --> 00:12:50,240
that complies with this standard

00:12:46,720 --> 00:12:54,160
for example if you want to pass

00:12:50,240 --> 00:12:57,200
two 32-bit data to the gtd code

00:12:54,160 --> 00:12:59,440
you can assume that the data is stored

00:12:57,200 --> 00:13:01,760
in the double zero and double r1

00:12:59,440 --> 00:13:04,880
registers

00:13:01,760 --> 00:13:05,440
if you want to receive a single 32-bit

00:13:04,880 --> 00:13:08,480
data

00:13:05,440 --> 00:13:13,440
from the agitate code you can set

00:13:08,480 --> 00:13:13,440
return value in the w0 register

00:13:13,519 --> 00:13:20,639
these methods are the same as

00:13:16,560 --> 00:13:23,440
the assembly code the more complex

00:13:20,639 --> 00:13:24,959
cases are described in the standards

00:13:23,440 --> 00:13:27,519
please divide the

00:13:24,959 --> 00:13:27,519
document

00:13:29,600 --> 00:13:32,800
if you want to many general purpose

00:13:31,920 --> 00:13:35,279
registers

00:13:32,800 --> 00:13:37,680
in your adjective code you can also

00:13:35,279 --> 00:13:41,040
compare the standards

00:13:37,680 --> 00:13:44,800
the standard specifies that the 9th

00:13:41,040 --> 00:13:48,639
and 9th to 15th register can be used

00:13:44,800 --> 00:13:53,600
freely and that 19 to

00:13:48,639 --> 00:13:53,600
28 registers should be preserved

00:13:55,440 --> 00:14:02,320
therefore you can save the 19th

00:13:58,800 --> 00:14:04,880
to 28th register onto the stack memory

00:14:02,320 --> 00:14:05,360
at the beginning of your agitate code

00:14:04,880 --> 00:14:08,079
and

00:14:05,360 --> 00:14:10,399
restore them at the end of your updated

00:14:08,079 --> 00:14:10,399
code

00:14:13,040 --> 00:14:17,440
of course kybeek supports the branch

00:14:16,240 --> 00:14:20,959
instructions and

00:14:17,440 --> 00:14:21,920
jump levels if you want to make jump

00:14:20,959 --> 00:14:25,600
levels

00:14:21,920 --> 00:14:29,199
please use the double glass if you use

00:14:25,600 --> 00:14:32,639
the l function the jt code address is

00:14:29,199 --> 00:14:33,839
set to the level instance and it can be

00:14:32,639 --> 00:14:38,000
used as an

00:14:33,839 --> 00:14:38,000
operand of the branch instructions

00:14:41,120 --> 00:14:47,760
we can use static table data in gt code

00:14:44,639 --> 00:14:50,240
like this example the

00:14:47,760 --> 00:14:50,959
move instructions set the table entry

00:14:50,240 --> 00:14:54,079
address

00:14:50,959 --> 00:14:56,639
to the x1 register

00:14:54,079 --> 00:14:59,199
the add instruction calculates the table

00:14:56,639 --> 00:15:02,800
element address and set it to the

00:14:59,199 --> 00:15:06,079
x1 register the

00:15:02,800 --> 00:15:09,680
ltr instruction loads the table element

00:15:06,079 --> 00:15:13,120
from the memory and set it to the

00:15:09,680 --> 00:15:16,480
32-bit double double zero register

00:15:13,120 --> 00:15:21,279
so on this example output the

00:15:16,480 --> 00:15:21,279
second element of the table 0x

00:15:25,279 --> 00:15:32,720
we can also generate table dynamically

00:15:28,480 --> 00:15:35,759
and read it the dd function

00:15:32,720 --> 00:15:38,399
writes a single 32-bit value to that

00:15:35,759 --> 00:15:41,199
digit code memory

00:15:38,399 --> 00:15:42,240
and its entry address can be set to a

00:15:41,199 --> 00:15:47,279
register

00:15:42,240 --> 00:15:50,000
by using a label and the adr instruction

00:15:47,279 --> 00:15:51,680
and this example also outputs the second

00:15:50,000 --> 00:15:56,160
element of the table

00:15:51,680 --> 00:15:56,160
so output becomes 0x

00:16:00,160 --> 00:16:07,519
there are a few points to keep in mind

00:16:04,160 --> 00:16:10,800
when using kyber crack

00:16:07,519 --> 00:16:14,320
the first point is kaiba kayak can

00:16:10,800 --> 00:16:19,120
output the instructions and that can be

00:16:14,320 --> 00:16:22,160
executed on the cpu running kyber crack

00:16:19,120 --> 00:16:25,519
for example some cpus

00:16:22,160 --> 00:16:29,279
may not support special instructions

00:16:25,519 --> 00:16:33,040
such as the cryptographic atomic

00:16:29,279 --> 00:16:36,800
and sap instructions

00:16:33,040 --> 00:16:39,920
but kybeck react running on us epu

00:16:36,800 --> 00:16:41,120
can output all machine code of the arm

00:16:39,920 --> 00:16:44,720
instruction set

00:16:41,120 --> 00:16:47,440
including the instructions

00:16:44,720 --> 00:16:48,720
if not supported instructions are

00:16:47,440 --> 00:16:51,440
executed

00:16:48,720 --> 00:16:52,720
the exception of illegal instruction is

00:16:51,440 --> 00:16:57,120
raises

00:16:52,720 --> 00:17:05,600
so please check your cpu capability

00:16:57,120 --> 00:17:09,919
and choose the mnemonic functions

00:17:05,600 --> 00:17:13,439
and the second point is that kyber kayak

00:17:09,919 --> 00:17:13,839
doesn't validate every argument but to

00:17:13,439 --> 00:17:17,679
the

00:17:13,839 --> 00:17:21,600
mnemonic functions for example

00:17:17,679 --> 00:17:25,120
the f move instruction which moves

00:17:21,600 --> 00:17:27,919
a floating value to a register

00:17:25,120 --> 00:17:28,880
this instruction is followed by a

00:17:27,919 --> 00:17:32,240
floating point

00:17:28,880 --> 00:17:35,760
constant there is

00:17:32,240 --> 00:17:39,200
the restriction of the constant value

00:17:35,760 --> 00:17:42,559
that can be specified as operand of

00:17:39,200 --> 00:17:42,559
f move instruction

00:17:44,880 --> 00:17:53,919
if you use a value that can be specified

00:17:49,120 --> 00:17:56,400
how kyberg arc behaves is undefined

00:17:53,919 --> 00:17:58,960
so please be careful to specify the

00:17:56,400 --> 00:18:01,840
correct value

00:17:58,960 --> 00:18:03,440
the operand validation is our future

00:18:01,840 --> 00:18:06,720
work

00:18:03,440 --> 00:18:08,400
some case uh kaibaker checks the operand

00:18:06,720 --> 00:18:11,600
correctness but

00:18:08,400 --> 00:18:16,799
in other case kaivec he

00:18:11,600 --> 00:18:16,799
doesn't check the correct correctness

00:18:19,600 --> 00:18:33,039
next i will discuss debugging methods

00:18:29,520 --> 00:18:34,080
at the moment there is no efficient way

00:18:33,039 --> 00:18:37,520
to debug

00:18:34,080 --> 00:18:41,760
gt code so basically

00:18:37,520 --> 00:18:44,799
it's the same as debugging assembly code

00:18:41,760 --> 00:18:48,559
i often use gdb with

00:18:44,799 --> 00:18:52,160
asm layout the jt codes can be dumped

00:18:48,559 --> 00:18:57,840
as a texas drive so it's also

00:18:52,160 --> 00:18:57,840
helpful to debugging

00:18:58,559 --> 00:19:01,840
if you want to debug the gt code on the

00:19:00,960 --> 00:19:05,440
gdb

00:19:01,840 --> 00:19:07,760
a please set a breakpoint to the address

00:19:05,440 --> 00:19:12,400
of the function pointer f

00:19:07,760 --> 00:19:12,400
because before it's called

00:19:14,559 --> 00:19:22,840
and preset layouts to asm

00:19:18,559 --> 00:19:26,000
and continue to continue the program

00:19:22,840 --> 00:19:29,840
execution then the program breaks

00:19:26,000 --> 00:19:33,200
at the start point of jitted code

00:19:29,840 --> 00:19:36,720
once the program breaks you can step

00:19:33,200 --> 00:19:41,120
into the gt code and instruction level

00:19:36,720 --> 00:19:41,120
with gtbs si command

00:19:46,640 --> 00:19:51,600
and you can also convert the adjective

00:19:49,600 --> 00:19:55,520
code to a text file

00:19:51,600 --> 00:19:59,520
to read it first

00:19:55,520 --> 00:20:02,880
write out judgeted code as a binary file

00:19:59,520 --> 00:20:06,880
then disassemble it using the object

00:20:02,880 --> 00:20:10,559
dump command then you can get

00:20:06,880 --> 00:20:10,559
this disassembled code

00:20:12,640 --> 00:20:16,480
let me summarize this talk

00:20:18,720 --> 00:20:24,400
i introduced kyber kx6 default

00:20:21,919 --> 00:20:26,799
that's just just in time assembler for

00:20:24,400 --> 00:20:29,840
um instruction sets

00:20:26,799 --> 00:20:32,240
kaibaker can dynamically generate

00:20:29,840 --> 00:20:33,520
optimized code considering runtime

00:20:32,240 --> 00:20:36,320
parameters

00:20:33,520 --> 00:20:37,120
and make it easier than the existing

00:20:36,320 --> 00:20:39,840
assembler

00:20:37,120 --> 00:20:42,559
to implement optimized code at the

00:20:39,840 --> 00:20:46,320
instruction level

00:20:42,559 --> 00:20:48,320
kyber gal64 is mainly developed to

00:20:46,320 --> 00:20:51,200
implement the deep learning processing

00:20:48,320 --> 00:20:54,159
software on the supercomputer fugac

00:20:51,200 --> 00:20:55,200
but it can be expected to work with the

00:20:54,159 --> 00:21:00,000
variety

00:20:55,200 --> 00:21:03,200
of software for v8a architecture systems

00:21:00,000 --> 00:21:06,400
kyber kayak is being developed

00:21:03,200 --> 00:21:09,520
as an open source software i hope that

00:21:06,400 --> 00:21:10,640
many people will use skype react on

00:21:09,520 --> 00:21:13,200
various

00:21:10,640 --> 00:21:15,600
platforms and participate in its

00:21:13,200 --> 00:21:18,559
development

00:21:15,600 --> 00:21:20,400
questions about reports pro requests and

00:21:18,559 --> 00:21:23,840
so on

00:21:20,400 --> 00:21:24,320
on github are very welcome so please

00:21:23,840 --> 00:21:30,159
check

00:21:24,320 --> 00:21:33,679
our github account

00:21:30,159 --> 00:21:37,600
and i thank shigeru omizunari

00:21:33,679 --> 00:21:40,720
he's a developer of the original kaibak

00:21:37,600 --> 00:21:44,720
he contributed helpful advice to

00:21:40,720 --> 00:21:47,919
kaibiake ax64 and brush up

00:21:44,720 --> 00:21:47,919
our source codes

00:21:53,760 --> 00:22:02,400
here is the reference list

00:21:58,799 --> 00:22:06,159
project our tech blog

00:22:02,400 --> 00:22:12,080
if you have an interested

00:22:06,159 --> 00:22:15,919
in our software

00:22:12,080 --> 00:22:27,840
thank you for checking my session

00:22:15,919 --> 00:22:27,840
that's all

00:22:29,520 --> 00:22:36,480

YouTube URL: https://www.youtube.com/watch?v=vBAsp2Mmqdw


