Title: LVC21-214 Booting linux on Arm’s CCIX enabled Quad Chiplet Reference Design platform
Publication date: 2021-04-15
Playlist: Linaro Virtual Connect Spring 2021
Description: 
	Chiplets are being increasingly used to build multi-chip platforms in order to increase the core count and the compute capacity on a package. Arm’s Neoverse Reference Design implementation provides guidelines to build a quad-chiplet package in which identical compute subsystems are connected through a high speed cache coherent CCIX link.

This talk focuses on the software design for an Arm architecture based CCIX enabled quad-chip platform using open source components such as Arm’s SCP-Firmware, Trusted Firmware, EDK2 and Linux. Various aspects of such a system including design that uses single flash to boot firmware on all four chips, performing cross chip coherent CCIX link setup, multi-chip interrupt routing and power management across the chips are presented. It also talks about the NUMA configuration and multi-chip SMP Linux boot sequence using the standard PSCI/SCMI interface. Details about availability of upstream software that can be reused on Arm based multiple-chip platforms are also presented.
Captions: 
	00:00:00,320 --> 00:00:04,240
hello everyone uh thanks a lot for

00:00:02,399 --> 00:00:06,560
joining this uh presentation

00:00:04,240 --> 00:00:08,240
my name is uh vijayanran subramaniam i'm

00:00:06,560 --> 00:00:10,080
a senior software engineer

00:00:08,240 --> 00:00:11,840
working at arm open source software

00:00:10,080 --> 00:00:13,679
group uh in this

00:00:11,840 --> 00:00:15,839
presentation we are going to discuss

00:00:13,679 --> 00:00:18,960
about the booting linux on an

00:00:15,839 --> 00:00:21,439
arm c6 enable the quad chip that uh

00:00:18,960 --> 00:00:21,439
platform

00:00:22,400 --> 00:00:26,080
so the agenda of this uh presentation is

00:00:24,480 --> 00:00:27,760
to discuss what is the multi-chip

00:00:26,080 --> 00:00:30,240
platform and the important software

00:00:27,760 --> 00:00:32,800
aspects of a multi-put

00:00:30,240 --> 00:00:35,200
to try this discussion we will take

00:00:32,800 --> 00:00:36,480
reference server platform as an example

00:00:35,200 --> 00:00:38,239
but the flow discussed in this

00:00:36,480 --> 00:00:40,960
presentation should be applicable for

00:00:38,239 --> 00:00:43,120
any arm based multi-chip platform as

00:00:40,960 --> 00:00:43,120
well

00:00:43,200 --> 00:00:46,239
we will begin with understanding of uh

00:00:45,120 --> 00:00:48,480
singles would flow

00:00:46,239 --> 00:00:50,160
and we will extend uh uh into a

00:00:48,480 --> 00:00:52,000
multichip workflow

00:00:50,160 --> 00:00:53,680
finally we will briefly see the acpa

00:00:52,000 --> 00:00:54,640
tables which are used to describe the

00:00:53,680 --> 00:00:59,840
voltage

00:00:54,640 --> 00:00:59,840
topology to the operating system

00:01:01,359 --> 00:01:05,040
so in the recent days the functionality

00:01:03,840 --> 00:01:07,680
and performance of

00:01:05,040 --> 00:01:08,799
any system on chip is increasing ever

00:01:07,680 --> 00:01:11,439
the number of

00:01:08,799 --> 00:01:13,520
cores on a chip also is also increasing

00:01:11,439 --> 00:01:14,240
and there are different custom ips being

00:01:13,520 --> 00:01:17,200
included in

00:01:14,240 --> 00:01:19,520
uh on a chip to accelerate uh or to

00:01:17,200 --> 00:01:21,520
serve a specific workload

00:01:19,520 --> 00:01:24,080
this results in an increased tie size

00:01:21,520 --> 00:01:27,439
and as the tie size increases

00:01:24,080 --> 00:01:29,520
there is a risk of reduced yield one

00:01:27,439 --> 00:01:30,960
simple error or one single error in any

00:01:29,520 --> 00:01:32,159
part of the die could rule out the

00:01:30,960 --> 00:01:35,200
entire chip

00:01:32,159 --> 00:01:35,600
which could cost a lot let's say we want

00:01:35,200 --> 00:01:38,720
to

00:01:35,600 --> 00:01:41,439
build a chip with 256 cores the current

00:01:38,720 --> 00:01:43,040
manufacturing process might not help or

00:01:41,439 --> 00:01:45,920
even if it helps

00:01:43,040 --> 00:01:48,960
the yield might be very low and the cost

00:01:45,920 --> 00:01:51,119
of the manufacturing could be very high

00:01:48,960 --> 00:01:53,280
one of the solutions to overcome this

00:01:51,119 --> 00:01:56,240
problem is to build a chiplet

00:01:53,280 --> 00:01:58,399
base system or a socket based system

00:01:56,240 --> 00:01:59,439
where multiple socks are packaged in a

00:01:58,399 --> 00:02:02,159
single die

00:01:59,439 --> 00:02:03,280
and joint using a coherent link in case

00:02:02,159 --> 00:02:06,240
of a

00:02:03,280 --> 00:02:07,520
chipper based platform or multiple chips

00:02:06,240 --> 00:02:09,200
are connected through a high-speed

00:02:07,520 --> 00:02:10,720
physical link in case of socket-based

00:02:09,200 --> 00:02:12,959
system

00:02:10,720 --> 00:02:14,720
uh triplet uh can be homogeneous

00:02:12,959 --> 00:02:16,080
platform where identical chips are

00:02:14,720 --> 00:02:19,040
packaged

00:02:16,080 --> 00:02:21,040
um in a single die are a heterogeneous

00:02:19,040 --> 00:02:24,640
platform like shown in this figure

00:02:21,040 --> 00:02:27,840
where identical chips along with the

00:02:24,640 --> 00:02:31,519
custom accelerator is also packaged

00:02:27,840 --> 00:02:36,720
within a single tie itself to properly

00:02:31,519 --> 00:02:38,640
tailor to a specific workload

00:02:36,720 --> 00:02:40,720
so this presentation is centered around

00:02:38,640 --> 00:02:43,680
the platform built around arm-based

00:02:40,720 --> 00:02:44,400
ips arm has neo-reference design

00:02:43,680 --> 00:02:46,959
platform

00:02:44,400 --> 00:02:48,239
which is a collection of arm ips with

00:02:46,959 --> 00:02:50,239
neo-cpu

00:02:48,239 --> 00:02:52,640
to build a server-based platform

00:02:50,239 --> 00:02:54,319
targeting cloud infrastructure and edge

00:02:52,640 --> 00:02:56,400
computing

00:02:54,319 --> 00:02:58,480
we'll use seniors rd platform as an

00:02:56,400 --> 00:03:00,239
example to drive this discussion

00:02:58,480 --> 00:03:01,840
but as i mentioned the boot flow

00:03:00,239 --> 00:03:02,720
discussed in this presentation should be

00:03:01,840 --> 00:03:04,640
applicable

00:03:02,720 --> 00:03:06,159
to other arm-based multi-chair platform

00:03:04,640 --> 00:03:08,480
as well

00:03:06,159 --> 00:03:09,680
so now what is the neos reference design

00:03:08,480 --> 00:03:12,000
platform

00:03:09,680 --> 00:03:12,879
so as a name suggests it's a complete

00:03:12,000 --> 00:03:14,800
reference uh

00:03:12,879 --> 00:03:17,360
design with a with a collection of

00:03:14,800 --> 00:03:20,239
documentation fixed virtual platform

00:03:17,360 --> 00:03:21,120
and a software stack to support uh

00:03:20,239 --> 00:03:23,519
development

00:03:21,120 --> 00:03:25,120
modification and to build a server based

00:03:23,519 --> 00:03:26,959
platform

00:03:25,120 --> 00:03:29,920
the key component in the nearest rd

00:03:26,959 --> 00:03:32,239
platform includes a nearest cpu

00:03:29,920 --> 00:03:33,519
manageability control processor system

00:03:32,239 --> 00:03:36,159
control processor

00:03:33,519 --> 00:03:36,720
a high speed coherent interconnect which

00:03:36,159 --> 00:03:39,200
is

00:03:36,720 --> 00:03:41,040
based on a coherent mesh network

00:03:39,200 --> 00:03:43,360
eyepiece

00:03:41,040 --> 00:03:45,680
a memory controller either it can be arm

00:03:43,360 --> 00:03:50,480
based or a third party memory controller

00:03:45,680 --> 00:03:50,480
io ip and a pcie ip

00:03:50,640 --> 00:03:58,799
sap and mcp are based on cortex and cpus

00:03:54,720 --> 00:04:01,120
sap is responsible for power management

00:03:58,799 --> 00:04:04,159
for the ap course uh in interconnect

00:04:01,120 --> 00:04:06,159
setup and memory controller setup

00:04:04,159 --> 00:04:08,000
mcp is responsible for communicating

00:04:06,159 --> 00:04:11,760
with the baseboard management controller

00:04:08,000 --> 00:04:14,239
otherwise popularly known as pmc

00:04:11,760 --> 00:04:16,000
the software stack includes sap from a

00:04:14,239 --> 00:04:17,280
trusted firmware for application code

00:04:16,000 --> 00:04:19,680
process

00:04:17,280 --> 00:04:20,720
tiana core cdk2 implementation of ufa as

00:04:19,680 --> 00:04:24,000
a bootloader

00:04:20,720 --> 00:04:26,000
grub 2 as a voice loader and the neovo's

00:04:24,000 --> 00:04:28,000
rd platform supports all major version

00:04:26,000 --> 00:04:33,040
of linux distribution including

00:04:28,000 --> 00:04:33,040
red at federal server uber and tvn

00:04:35,120 --> 00:04:38,320
so before jumping into the details of

00:04:36,880 --> 00:04:40,720
the multi-chip platform and

00:04:38,320 --> 00:04:42,160
the boot flow in the multi-platform

00:04:40,720 --> 00:04:44,000
let's discuss the boot flow

00:04:42,160 --> 00:04:46,880
in the single chip platform the boot

00:04:44,000 --> 00:04:48,880
flow between single chip and multi-chip

00:04:46,880 --> 00:04:50,960
platform remains mostly the same and the

00:04:48,880 --> 00:04:54,000
key difference between these two will be

00:04:50,960 --> 00:04:56,400
discussed in the subsequent slide

00:04:54,000 --> 00:04:57,199
so it all starts with a nor flash which

00:04:56,400 --> 00:05:00,240
packages

00:04:57,199 --> 00:05:03,360
uh the required images for the boot rom

00:05:00,240 --> 00:05:05,440
in each processor to load um

00:05:03,360 --> 00:05:07,840
to load the runtime firmware as shown in

00:05:05,440 --> 00:05:12,080
the flash it contains the runtime

00:05:07,840 --> 00:05:12,080
from for all the cpus in the system

00:05:12,560 --> 00:05:15,600
during the reset scp and mcp will power

00:05:15,280 --> 00:05:18,080
on

00:05:15,600 --> 00:05:18,720
and execute the boot rom cord bootrom

00:05:18,080 --> 00:05:20,479
code

00:05:18,720 --> 00:05:22,840
which will load the respective runtime

00:05:20,479 --> 00:05:25,520
firmware stage from the not

00:05:22,840 --> 00:05:28,400
flash

00:05:25,520 --> 00:05:30,240
so once the loading is complete the

00:05:28,400 --> 00:05:31,680
transfer will get

00:05:30,240 --> 00:05:35,280
the execution will get transferred to

00:05:31,680 --> 00:05:37,919
the sap ncp runtime firmware

00:05:35,280 --> 00:05:40,080
scp ram code will initialize the high

00:05:37,919 --> 00:05:41,840
speed interconnect memory controller

00:05:40,080 --> 00:05:44,080
power policy unit for application

00:05:41,840 --> 00:05:46,240
processor course

00:05:44,080 --> 00:05:48,560
once these initialization are complete

00:05:46,240 --> 00:05:51,120
it will turn on the primary core

00:05:48,560 --> 00:05:53,280
typically cpu 0 on the system which will

00:05:51,120 --> 00:05:56,639
start executing the ap rom code

00:05:53,280 --> 00:05:59,199
so ap chrome code is a bl one it is

00:05:56,639 --> 00:06:00,720
named as bl bootloader stage one uh it

00:05:59,199 --> 00:06:02,000
will verify the signature of the next

00:06:00,720 --> 00:06:05,600
stage bl2

00:06:02,000 --> 00:06:08,160
and it will load the bl2 stage

00:06:05,600 --> 00:06:09,840
from the non-flash into the secure sram

00:06:08,160 --> 00:06:12,000
for the execution

00:06:09,840 --> 00:06:13,840
the transfer will get the execution will

00:06:12,000 --> 00:06:17,440
get transferred to bl2

00:06:13,840 --> 00:06:18,160
uh bl2 being executed at the secure el1

00:06:17,440 --> 00:06:20,080
run

00:06:18,160 --> 00:06:22,720
is responsible for authenticating and

00:06:20,080 --> 00:06:26,080
loading the next bootloader stages

00:06:22,720 --> 00:06:28,560
uh it will authenticate and load uh bl31

00:06:26,080 --> 00:06:30,319
which is the el3 runtime firmware

00:06:28,560 --> 00:06:32,160
optionally the l32

00:06:30,319 --> 00:06:33,680
which is the ufi manageability mode

00:06:32,160 --> 00:06:36,240
software uh

00:06:33,680 --> 00:06:38,240
which typically will be used in case of

00:06:36,240 --> 00:06:40,639
a secure boot

00:06:38,240 --> 00:06:43,199
in case of efa secure boot is enabled

00:06:40,639 --> 00:06:47,600
and finally it will load the bl 33 stage

00:06:43,199 --> 00:06:49,039
which in case of rd platform is efi

00:06:47,600 --> 00:06:50,560
once the image load is complete the

00:06:49,039 --> 00:06:53,280
execution will get transferred to the

00:06:50,560 --> 00:06:57,520
bl31 which is executing on a dram

00:06:53,280 --> 00:06:59,280
uh region so bl31 being our el3 runtime

00:06:57,520 --> 00:06:59,840
firmware is responsible for setting up

00:06:59,280 --> 00:07:02,080
the geek

00:06:59,840 --> 00:07:04,880
distributor and redistributor and also

00:07:02,080 --> 00:07:07,840
the acma channel

00:07:04,880 --> 00:07:09,840
a cmi is a system control and management

00:07:07,840 --> 00:07:10,479
interface is the arm specification on

00:07:09,840 --> 00:07:12,960
how

00:07:10,479 --> 00:07:13,919
how message passing between apico and

00:07:12,960 --> 00:07:15,919
scpg

00:07:13,919 --> 00:07:17,599
sap code should happen in case of a

00:07:15,919 --> 00:07:20,000
system where

00:07:17,599 --> 00:07:22,960
the application core or management is

00:07:20,000 --> 00:07:22,960
done by the sap

00:07:23,360 --> 00:07:28,319
geek and sme initialization are

00:07:26,160 --> 00:07:30,560
important in case of multi-sub system

00:07:28,319 --> 00:07:33,520
and this will be discussed uh in the

00:07:30,560 --> 00:07:33,520
subsequent slides

00:07:34,240 --> 00:07:40,400
and once the bl uh 331 stage completes

00:07:38,240 --> 00:07:41,680
its initiation the transfer of execution

00:07:40,400 --> 00:07:44,960
will happen to

00:07:41,680 --> 00:07:45,840
uh bl 33 and it will complete all its

00:07:44,960 --> 00:07:49,039
stage

00:07:45,840 --> 00:07:51,440
and it will uh load the actual operating

00:07:49,039 --> 00:07:51,440
system

00:07:53,759 --> 00:07:57,360
rd platform not only implements a single

00:07:56,479 --> 00:07:59,599
chip

00:07:57,360 --> 00:08:01,520
platform but also extends its

00:07:59,599 --> 00:08:03,440
implementation to a multitude variant as

00:08:01,520 --> 00:08:05,520
well

00:08:03,440 --> 00:08:07,360
it currently supports uh dual chip and

00:08:05,520 --> 00:08:09,520
quad chip variants

00:08:07,360 --> 00:08:11,199
uh let's begin the discussion with uh

00:08:09,520 --> 00:08:13,120
diversity platform and let's try to

00:08:11,199 --> 00:08:15,759
understand what makes

00:08:13,120 --> 00:08:17,120
it uh it's a dual chip platform

00:08:15,759 --> 00:08:19,440
individually these two

00:08:17,120 --> 00:08:21,840
are a single chip platform and both are

00:08:19,440 --> 00:08:23,919
opaque to each other in terms of

00:08:21,840 --> 00:08:25,280
memory and peripherals on the other

00:08:23,919 --> 00:08:28,000
chips

00:08:25,280 --> 00:08:30,319
so what need what is needed to make uh

00:08:28,000 --> 00:08:33,760
it as a dealership platform is for each

00:08:30,319 --> 00:08:36,880
chip to access each other chips memory

00:08:33,760 --> 00:08:38,399
uh in a coherent fashion it also need to

00:08:36,880 --> 00:08:42,240
access the peripherals on the

00:08:38,399 --> 00:08:43,760
other chip as well if this is enabled on

00:08:42,240 --> 00:08:46,959
the on platform by ec6

00:08:43,760 --> 00:08:48,399
link on other architecture it could be

00:08:46,959 --> 00:08:50,880
other protocol depending upon the

00:08:48,399 --> 00:08:52,959
interconnect use

00:08:50,880 --> 00:08:54,640
the same idea can be extended to a card

00:08:52,959 --> 00:08:57,680
shiplet as well

00:08:54,640 --> 00:08:58,640
where um if there are four chips

00:08:57,680 --> 00:09:02,640
available

00:08:58,640 --> 00:09:05,680
uh it would require a total of six uh

00:09:02,640 --> 00:09:06,560
6x links to create this n crossing

00:09:05,680 --> 00:09:09,040
connection

00:09:06,560 --> 00:09:11,200
to allow each ship to access each other

00:09:09,040 --> 00:09:11,200
check

00:09:11,680 --> 00:09:15,279
ccx is a high speed coherent

00:09:13,920 --> 00:09:18,000
interconnect protocol

00:09:15,279 --> 00:09:18,880
which enables coherent access transfer

00:09:18,000 --> 00:09:21,440
of

00:09:18,880 --> 00:09:22,160
transfer of kick interrupts dbm message

00:09:21,440 --> 00:09:25,279
passing and

00:09:22,160 --> 00:09:28,640
exclusives across each

00:09:25,279 --> 00:09:33,360
ccx is uh developed for

00:09:28,640 --> 00:09:34,880
to allow a multi-chip operation and for

00:09:33,360 --> 00:09:37,839
accelerator operation with the coherent

00:09:34,880 --> 00:09:37,839
memory access

00:09:38,800 --> 00:09:43,760
now let's see how multi-c boot flow uh

00:09:42,080 --> 00:09:45,600
differ differs from the single chip boot

00:09:43,760 --> 00:09:48,480
flow and how the memory map will look in

00:09:45,600 --> 00:09:51,680
case of a multi-platform

00:09:48,480 --> 00:09:52,320
a similar to single chip boot uh at the

00:09:51,680 --> 00:09:54,320
reset

00:09:52,320 --> 00:09:55,920
scp on each ship will initialize the

00:09:54,320 --> 00:09:59,360
interconnect memory

00:09:55,920 --> 00:10:02,560
and and the ppus on its

00:09:59,360 --> 00:10:04,240
own chip and the scp

00:10:02,560 --> 00:10:05,920
detects that the platform has a

00:10:04,240 --> 00:10:08,640
multi-chip mode enable

00:10:05,920 --> 00:10:09,920
by reading the system id registers it

00:10:08,640 --> 00:10:13,120
will

00:10:09,920 --> 00:10:16,480
begin the setup of this

00:10:13,120 --> 00:10:18,399
coherent link tip 0

00:10:16,480 --> 00:10:19,920
for example will begin by bringing up

00:10:18,399 --> 00:10:23,040
the current link between

00:10:19,920 --> 00:10:26,079
chip 0 and chip 1. so at the beginning

00:10:23,040 --> 00:10:29,519
uh chip 0 will have only the local

00:10:26,079 --> 00:10:32,079
memory view in case of rd platform the

00:10:29,519 --> 00:10:33,279
each ship will have a memory size of 0

00:10:32,079 --> 00:10:35,519
to 4 db

00:10:33,279 --> 00:10:37,360
and for the remote chips it will be

00:10:35,519 --> 00:10:39,600
offsetted by 4 tb

00:10:37,360 --> 00:10:41,600
so which means that chip on a memory

00:10:39,600 --> 00:10:46,480
space of 4 tv to 8 db

00:10:41,600 --> 00:10:49,680
chip 2 will have 80 to 12 db and so on

00:10:46,480 --> 00:10:53,040
so once the c6 link is established

00:10:49,680 --> 00:10:53,839
chip 0 will have a full view of chip 1

00:10:53,040 --> 00:10:57,920
memory

00:10:53,839 --> 00:10:59,040
as well the same process will get

00:10:57,920 --> 00:11:01,040
repeated for

00:10:59,040 --> 00:11:03,760
establishing the c6 link to other chips

00:11:01,040 --> 00:11:06,480
as well once sip 0 establish the link

00:11:03,760 --> 00:11:07,600
between chip 0 and chip 2 chip 0 and

00:11:06,480 --> 00:11:09,600
chip 3

00:11:07,600 --> 00:11:12,000
it will have the complete memory view of

00:11:09,600 --> 00:11:13,839
other successful

00:11:12,000 --> 00:11:15,839
now the same process will be repeated by

00:11:13,839 --> 00:11:19,120
other chips to bring up

00:11:15,839 --> 00:11:21,279
the c6 link and once the c6 links are

00:11:19,120 --> 00:11:22,480
established a single view of memory will

00:11:21,279 --> 00:11:24,959
be applicable

00:11:22,480 --> 00:11:25,760
uh for all the chips ranging from 0 to

00:11:24,959 --> 00:11:29,440
16 db

00:11:25,760 --> 00:11:29,839
in case of a quad chip finally like we

00:11:29,440 --> 00:11:31,680
have

00:11:29,839 --> 00:11:34,880
seen in the single chip boot flow the

00:11:31,680 --> 00:11:37,279
primary chips scp will turn on the cpu 0

00:11:34,880 --> 00:11:39,200
which will go on to boot uh its

00:11:37,279 --> 00:11:43,760
bootloader stages pl 3

00:11:39,200 --> 00:11:45,600
pl 1 bl2 and bl3 bl31 bootloader status

00:11:43,760 --> 00:11:47,600
the important point to note here is that

00:11:45,600 --> 00:11:49,360
the scp on the other chips will go on to

00:11:47,600 --> 00:11:51,600
idle stage

00:11:49,360 --> 00:11:52,800
idle state it won't turn on any cores on

00:11:51,600 --> 00:11:56,800
its own chip

00:11:52,800 --> 00:11:59,440
at this point

00:11:56,800 --> 00:12:01,519
like we discussed earlier vl31 is

00:11:59,440 --> 00:12:03,360
responsible for initializing the genetic

00:12:01,519 --> 00:12:06,240
interrupt controller

00:12:03,360 --> 00:12:07,440
so in this slide we will see how the

00:12:06,240 --> 00:12:09,360
distributor and geek

00:12:07,440 --> 00:12:11,120
redistributor works in case of a single

00:12:09,360 --> 00:12:13,519
chip platform

00:12:11,120 --> 00:12:14,880
which will help the help the

00:12:13,519 --> 00:12:19,120
understanding of

00:12:14,880 --> 00:12:22,560
geek's role in a multi-chip system

00:12:19,120 --> 00:12:24,560
vik mainly handles three main types of

00:12:22,560 --> 00:12:26,880
interrupts namely private peripheral

00:12:24,560 --> 00:12:29,680
interrupt software generated interrupt

00:12:26,880 --> 00:12:31,680
add the peripheral interrupt ppis as the

00:12:29,680 --> 00:12:34,000
name suggests are private to the cpu

00:12:31,680 --> 00:12:34,720
uh so gt will not play any role in

00:12:34,000 --> 00:12:38,800
handling

00:12:34,720 --> 00:12:41,360
under ppi interrupts sdis are generated

00:12:38,800 --> 00:12:43,440
by cpu which targets other cpu with the

00:12:41,360 --> 00:12:46,880
mpidr value

00:12:43,440 --> 00:12:50,160
so for example sdi from cpu one

00:12:46,880 --> 00:12:52,959
if it targets cpu3 will reach a qt

00:12:50,160 --> 00:12:54,079
and based on the target mpidr value qt

00:12:52,959 --> 00:12:56,000
will transfer

00:12:54,079 --> 00:12:58,000
uh transfer to the corresponding

00:12:56,000 --> 00:13:00,639
redistributor in this example

00:12:58,000 --> 00:13:01,440
dt will transfer this sga to the

00:13:00,639 --> 00:13:06,000
redistributor

00:13:01,440 --> 00:13:08,000
on the cpu3 similarly spis are also

00:13:06,000 --> 00:13:10,160
shared among the cpus geekte is

00:13:08,000 --> 00:13:12,800
responsible for forwarding the sps to a

00:13:10,160 --> 00:13:15,920
specific redistributor

00:13:12,800 --> 00:13:16,560
now in case of a multi-chip scenario sti

00:13:15,920 --> 00:13:19,680
from

00:13:16,560 --> 00:13:24,480
a chip 0 cpu can target

00:13:19,680 --> 00:13:27,680
a cpu on chip 2 or chip 3 and so on

00:13:24,480 --> 00:13:29,360
and similarly the svi on a generator

00:13:27,680 --> 00:13:32,480
from the chip 0 can

00:13:29,360 --> 00:13:35,760
can be handled by a cpu

00:13:32,480 --> 00:13:37,519
on other chip as well so the quick t

00:13:35,760 --> 00:13:39,360
from all the zip has to talk to each

00:13:37,519 --> 00:13:42,959
other and work in sync

00:13:39,360 --> 00:13:42,959
in case of a multi-chip operation

00:13:43,760 --> 00:13:48,480
from big 600 onwards support for

00:13:46,240 --> 00:13:51,199
multi-chip has been enabled

00:13:48,480 --> 00:13:54,480
to the ip itself to allow multiple chips

00:13:51,199 --> 00:13:58,240
to exchange the messages and interrupts

00:13:54,480 --> 00:14:00,480
so let's see how the initial

00:13:58,240 --> 00:14:02,160
how bl31 initialize the git in case of a

00:14:00,480 --> 00:14:04,959
multi-sub scenario

00:14:02,160 --> 00:14:05,600
so bl31 will detect the platform

00:14:04,959 --> 00:14:07,279
supports

00:14:05,600 --> 00:14:10,399
multi-ship operation by reading the

00:14:07,279 --> 00:14:13,360
system id registers

00:14:10,399 --> 00:14:13,760
and it will start with the programming

00:14:13,360 --> 00:14:16,800
of

00:14:13,760 --> 00:14:17,920
qt on the primary chip by writing to the

00:14:16,800 --> 00:14:20,399
mmio region

00:14:17,920 --> 00:14:21,199
on the in the primary chip so what it

00:14:20,399 --> 00:14:23,760
will program

00:14:21,199 --> 00:14:24,639
is that it will begin by programming the

00:14:23,760 --> 00:14:27,839
ids

00:14:24,639 --> 00:14:30,959
or addresses of the remote chip

00:14:27,839 --> 00:14:34,560
gig distributor so

00:14:30,959 --> 00:14:37,920
it will also set up the routing table uh

00:14:34,560 --> 00:14:41,279
for the spi so what this uh table

00:14:37,920 --> 00:14:43,279
tells uh is that the range of what what

00:14:41,279 --> 00:14:46,959
are all the range of spi

00:14:43,279 --> 00:14:50,079
ids each ship has to handle so if

00:14:46,959 --> 00:14:52,079
spi is generated

00:14:50,079 --> 00:14:53,279
it will be routed to the corresponding

00:14:52,079 --> 00:14:56,800
chip by looking at this

00:14:53,279 --> 00:15:00,240
table for example in this example

00:14:56,800 --> 00:15:01,120
uh spiders 32 to 255 is handled by each

00:15:00,240 --> 00:15:05,279
of zero

00:15:01,120 --> 00:15:08,639
and sp id is 512 to 959

00:15:05,279 --> 00:15:08,639
will be handled by each one

00:15:09,839 --> 00:15:13,839
finally it will enable geektee for

00:15:12,399 --> 00:15:16,959
multi-chip operation

00:15:13,839 --> 00:15:17,680
once this operation is enabled it will

00:15:16,959 --> 00:15:20,480
make

00:15:17,680 --> 00:15:23,040
gitti on the primary chip will make a

00:15:20,480 --> 00:15:26,399
connection to the remote

00:15:23,040 --> 00:15:29,199
remote chip's kitty with the help of

00:15:26,399 --> 00:15:31,519
the ids or the address it includes mma

00:15:29,199 --> 00:15:31,519
space

00:15:31,680 --> 00:15:37,199
so once the uh connection is established

00:15:34,800 --> 00:15:38,000
all the kitty will work in in a

00:15:37,199 --> 00:15:42,160
synchronized

00:15:38,000 --> 00:15:45,519
fashion so any rights to any of this

00:15:42,160 --> 00:15:46,480
dmmao region will get get reflected to

00:15:45,519 --> 00:15:50,160
all kick

00:15:46,480 --> 00:15:51,199
distributor so from this point it's

00:15:50,160 --> 00:15:54,399
suffice to say

00:15:51,199 --> 00:15:56,800
that all the qt will act as a one single

00:15:54,399 --> 00:15:56,800
entity

00:15:58,880 --> 00:16:04,160
an example uh kick

00:16:01,920 --> 00:16:06,839
d initially is for initialization for

00:16:04,160 --> 00:16:09,839
what's your party platform is linked

00:16:06,839 --> 00:16:09,839
here

00:16:11,440 --> 00:16:14,639
so another important aspect of a

00:16:13,120 --> 00:16:18,399
monitorship boot is a

00:16:14,639 --> 00:16:21,839
smi channel in acceleration by pl31

00:16:18,399 --> 00:16:23,600
so like we discussed semi is a standard

00:16:21,839 --> 00:16:24,160
published by arm to standardize this

00:16:23,600 --> 00:16:27,600
message

00:16:24,160 --> 00:16:30,560
communication between ap core and sap

00:16:27,600 --> 00:16:32,000
on a system with sap being responsible

00:16:30,560 --> 00:16:33,920
for system control

00:16:32,000 --> 00:16:37,199
such as turning on the cpu or turning

00:16:33,920 --> 00:16:39,199
off the cpu scaling up the frequency and

00:16:37,199 --> 00:16:41,920
so on

00:16:39,199 --> 00:16:43,600
so during the sap boot scp on each ship

00:16:41,920 --> 00:16:46,720
will zero out the messaging region on

00:16:43,600 --> 00:16:46,720
its own address space

00:16:47,920 --> 00:16:53,600
so there will be four sma message

00:16:50,480 --> 00:16:57,120
regions in case of a quad chip system

00:16:53,600 --> 00:17:00,000
since bl31 is running on the cpu

00:16:57,120 --> 00:17:00,800
of chip zero it can initialize its

00:17:00,000 --> 00:17:03,759
message

00:17:00,800 --> 00:17:05,600
uh region on its own chip now there is

00:17:03,759 --> 00:17:07,760
only one copy of pl31

00:17:05,600 --> 00:17:08,720
running on this entire system and there

00:17:07,760 --> 00:17:11,439
are no ap

00:17:08,720 --> 00:17:12,160
core running on this other chip so there

00:17:11,439 --> 00:17:14,559
won't be

00:17:12,160 --> 00:17:15,600
any separate copy of bl31 running on the

00:17:14,559 --> 00:17:18,400
other chip

00:17:15,600 --> 00:17:19,039
so that it can initialize its own chip

00:17:18,400 --> 00:17:21,919
so what

00:17:19,039 --> 00:17:23,679
bl 31 will do at this point is that it

00:17:21,919 --> 00:17:26,799
will take advantage of the

00:17:23,679 --> 00:17:29,679
coherent ccx link to initialize the

00:17:26,799 --> 00:17:31,520
region on the other chips now like we

00:17:29,679 --> 00:17:32,720
discussed once the ccx link is

00:17:31,520 --> 00:17:34,960
established

00:17:32,720 --> 00:17:38,720
chip 0 will have complete view of the

00:17:34,960 --> 00:17:38,720
other chip's memory as well

00:17:39,919 --> 00:17:45,679
now bl31 will do that it will take up

00:17:43,280 --> 00:17:49,440
advantage of the coherent c6 link to

00:17:45,679 --> 00:17:49,440
initialize the region on the other chips

00:17:53,360 --> 00:17:58,960
so it will start initializing the

00:17:56,720 --> 00:18:00,240
scma regions on all the other three

00:17:58,960 --> 00:18:01,919
chips as well

00:18:00,240 --> 00:18:04,400
so what this tells us is that

00:18:01,919 --> 00:18:04,799
effectively effectively the el3 running

00:18:04,400 --> 00:18:07,520
from

00:18:04,799 --> 00:18:10,000
running on the primary core will be able

00:18:07,520 --> 00:18:13,520
to share the sma messages with the

00:18:10,000 --> 00:18:14,080
remote ships scp without any involvement

00:18:13,520 --> 00:18:17,280
of the

00:18:14,080 --> 00:18:20,320
ap codes on the remote chip itself

00:18:17,280 --> 00:18:22,559
this is enabled through this ccx

00:18:20,320 --> 00:18:22,559
inc

00:18:24,480 --> 00:18:30,720
now the stage is set for the os to load

00:18:27,600 --> 00:18:32,720
on this multichip system so bl31 will

00:18:30,720 --> 00:18:34,960
complete its job and it will transfer

00:18:32,720 --> 00:18:38,000
transition to a runtime

00:18:34,960 --> 00:18:40,080
firmware stage and it will transfer its

00:18:38,000 --> 00:18:42,880
execution to the ufi

00:18:40,080 --> 00:18:44,240
so efi in turn will complete all its

00:18:42,880 --> 00:18:47,440
stages such as txc

00:18:44,240 --> 00:18:48,960
vds and it will finally load the linux

00:18:47,440 --> 00:18:51,039
os

00:18:48,960 --> 00:18:52,320
so efi is also responsible for sharing

00:18:51,039 --> 00:18:54,080
the acpi tables

00:18:52,320 --> 00:18:56,000
to describe the system topology to the

00:18:54,080 --> 00:18:58,640
operating system we will see that

00:18:56,000 --> 00:19:00,960
briefly in the next slides

00:18:58,640 --> 00:19:02,400
so once the os boots it will read the

00:19:00,960 --> 00:19:05,840
immediate table

00:19:02,400 --> 00:19:07,120
and will start doing a psci calls to the

00:19:05,840 --> 00:19:10,720
runtime firmware

00:19:07,120 --> 00:19:14,000
in order to turn on the secondary course

00:19:10,720 --> 00:19:16,559
so for the local chip it

00:19:14,000 --> 00:19:17,120
the process is same as the single chip

00:19:16,559 --> 00:19:19,360
system

00:19:17,120 --> 00:19:20,799
where runtime firmware will use the semi

00:19:19,360 --> 00:19:24,320
shared region

00:19:20,799 --> 00:19:24,640
to do sma calls to the scp to turn on

00:19:24,320 --> 00:19:28,480
the

00:19:24,640 --> 00:19:28,480
secondary cores on the local chip

00:19:29,600 --> 00:19:35,840
so sap will turn on the cpu one and

00:19:33,840 --> 00:19:38,880
the linux context will start running on

00:19:35,840 --> 00:19:41,039
the cpu one

00:19:38,880 --> 00:19:42,400
so as and when the secondary core comes

00:19:41,039 --> 00:19:43,200
up the linux context will start

00:19:42,400 --> 00:19:46,720
executing

00:19:43,200 --> 00:19:49,360
in the secondary cpus as well

00:19:46,720 --> 00:19:52,080
now when the linux makes the psa call to

00:19:49,360 --> 00:19:55,919
turn on the cpu4

00:19:52,080 --> 00:19:59,120
is which is the cpu zero on the chip one

00:19:55,919 --> 00:20:01,440
bl-31 will realize that cpu

00:19:59,120 --> 00:20:03,039
resides on the cpu one by reading the

00:20:01,440 --> 00:20:06,000
mpadr value

00:20:03,039 --> 00:20:07,120
and it will make a cma call on the

00:20:06,000 --> 00:20:10,720
shared memory region

00:20:07,120 --> 00:20:10,720
in the chip 1 address space

00:20:11,039 --> 00:20:15,840
so this will allow the sap on the chip 1

00:20:13,760 --> 00:20:20,159
to turn on the cpu 4

00:20:15,840 --> 00:20:22,159
on its ship since the coherent uh

00:20:20,159 --> 00:20:23,360
link has been established and it's a

00:20:22,159 --> 00:20:26,559
coherent memory

00:20:23,360 --> 00:20:28,960
the cpu4 will come up and the linux will

00:20:26,559 --> 00:20:32,480
start executing on the cpu for us

00:20:28,960 --> 00:20:36,000
cpu for uh also courtesy of

00:20:32,480 --> 00:20:38,720
the ccx link and the process will

00:20:36,000 --> 00:20:39,280
repeat it for other cpus on the chip one

00:20:38,720 --> 00:20:42,080
and

00:20:39,280 --> 00:20:44,400
the same process will get repeated for

00:20:42,080 --> 00:20:47,679
all the cpus on the other

00:20:44,400 --> 00:20:51,200
chips as well to unchip three

00:20:47,679 --> 00:20:54,240
now all the 16 cpus will be turned on

00:20:51,200 --> 00:20:54,720
and the linux will index context will

00:20:54,240 --> 00:20:57,120
run

00:20:54,720 --> 00:20:58,400
on all this uh cpu in the coherent

00:20:57,120 --> 00:21:02,240
fashion profession

00:20:58,400 --> 00:21:05,440
so e the linux running on each cpu

00:21:02,240 --> 00:21:08,080
will be able to have a complete view of

00:21:05,440 --> 00:21:11,679
memory and mmao space

00:21:08,080 --> 00:21:16,799
so this complete the boot of linux

00:21:11,679 --> 00:21:18,880
on a multi-subsystem

00:21:16,799 --> 00:21:21,600
so before concluding let's let's talk

00:21:18,880 --> 00:21:22,240
briefly about the acpa tables used to

00:21:21,600 --> 00:21:24,400
describe

00:21:22,240 --> 00:21:25,919
the system topology to the operating

00:21:24,400 --> 00:21:28,240
system so that

00:21:25,919 --> 00:21:28,960
the os can optimize its processor

00:21:28,240 --> 00:21:31,840
location

00:21:28,960 --> 00:21:31,840
and memory accesses

00:21:32,960 --> 00:21:39,280
mrit table is used to describe the cpu

00:21:36,400 --> 00:21:41,679
information along with the gt and git

00:21:39,280 --> 00:21:44,320
card base addresses

00:21:41,679 --> 00:21:46,880
the cpu information are described with

00:21:44,320 --> 00:21:49,360
the mpidr value

00:21:46,880 --> 00:21:50,240
which will have the affinity information

00:21:49,360 --> 00:21:54,720
including the chip

00:21:50,240 --> 00:21:54,720
id cluster id and core ids

00:21:55,039 --> 00:22:00,799
the second table is sra table

00:21:58,640 --> 00:22:02,480
it describes the memory and processor

00:22:00,799 --> 00:22:05,360
affinity

00:22:02,480 --> 00:22:06,000
in the example we discussed each chip's

00:22:05,360 --> 00:22:09,440
memory

00:22:06,000 --> 00:22:10,000
and cpu are assigned with the proximity

00:22:09,440 --> 00:22:12,480
id

00:22:10,000 --> 00:22:13,039
for example chip and chip zeros memory

00:22:12,480 --> 00:22:17,039
and chip

00:22:13,039 --> 00:22:18,240
uh zeros cpus are assigned as proximity

00:22:17,039 --> 00:22:21,280
zero

00:22:18,240 --> 00:22:22,960
and chip one's uh memory and

00:22:21,280 --> 00:22:26,960
chip one cpus are assigned with

00:22:22,960 --> 00:22:29,520
approximately one

00:22:26,960 --> 00:22:31,120
the next table is hmat table it is used

00:22:29,520 --> 00:22:32,880
to describe the cache

00:22:31,120 --> 00:22:34,720
information and mainly the latency

00:22:32,880 --> 00:22:36,720
values between each approximately

00:22:34,720 --> 00:22:38,880
domains

00:22:36,720 --> 00:22:40,559
the numbers are used here are arbitrary

00:22:38,880 --> 00:22:41,840
values and it varies based on the

00:22:40,559 --> 00:22:44,400
platform

00:22:41,840 --> 00:22:45,600
so in this example we can see that

00:22:44,400 --> 00:22:49,440
latency

00:22:45,600 --> 00:22:53,360
between its own proximity is low

00:22:49,440 --> 00:22:56,320
while the latency across the proximity

00:22:53,360 --> 00:22:58,559
is the double the time so between the

00:22:56,320 --> 00:22:59,520
proximity is 10 nanoseconds soil across

00:22:58,559 --> 00:23:02,480
the proximity is

00:22:59,520 --> 00:23:02,480
20 nanoseconds

00:23:03,280 --> 00:23:09,840
as usual the example to this acpa tables

00:23:06,320 --> 00:23:09,840
are linked here

00:23:10,400 --> 00:23:15,760
so this this slide shows how

00:23:13,840 --> 00:23:17,600
the hdpa tables looks in terms of the

00:23:15,760 --> 00:23:20,880
code you can see

00:23:17,600 --> 00:23:23,360
that immediate table has

00:23:20,880 --> 00:23:24,320
the various cpu information for each

00:23:23,360 --> 00:23:28,960
chip

00:23:24,320 --> 00:23:28,960
uh geek redistributor base addresses

00:23:29,200 --> 00:23:34,480
the extra table has a memory affinity

00:23:31,840 --> 00:23:37,679
and processor of limited information

00:23:34,480 --> 00:23:39,679
while the my table has an matrix

00:23:37,679 --> 00:23:42,880
of the latency information across

00:23:39,679 --> 00:23:42,880
various proximity domain

00:23:43,360 --> 00:23:48,960
so that uh concludes this presentation

00:23:46,640 --> 00:23:50,240
uh to briefly summarize we have seen

00:23:48,960 --> 00:23:52,480
what is a chiplet flat

00:23:50,240 --> 00:23:53,440
platform and the boot flow for a

00:23:52,480 --> 00:23:56,240
multichip is

00:23:53,440 --> 00:23:57,919
discussed on the nearest rd platform

00:23:56,240 --> 00:24:00,480
here are some of the useful links

00:23:57,919 --> 00:24:01,440
about neos reference design platform and

00:24:00,480 --> 00:24:04,480
the last

00:24:01,440 --> 00:24:09,279
link is to develop a documentation on

00:24:04,480 --> 00:24:09,279
how to sync and use the software stack

00:24:10,000 --> 00:24:13,279
and thanks a lot for joining this

00:24:11,440 --> 00:24:16,559
presentation hope you

00:24:13,279 --> 00:24:16,559

YouTube URL: https://www.youtube.com/watch?v=-nLXThb756E


