Title: LVC21-110 µTVM Introduction and Project Update
Publication date: 2021-04-15
Playlist: Linaro Virtual Connect Spring 2021
Description: 
	Join us for an introduction to the µTVM project, which is an AI Deep Learning Compiler specifically for high performance inference on Arm Cortex-M Microcontroller hardware. Learn about the state of the project as well as some simple demos to get you started.
Captions: 
	00:00:04,720 --> 00:00:08,240
hi everyone

00:00:05,600 --> 00:00:09,679
and welcome to the session on microtvm

00:00:08,240 --> 00:00:12,559
so just a quick introduce

00:00:09,679 --> 00:00:13,679
ourselves uh my name is tom gall i'm one

00:00:12,559 --> 00:00:17,119
of the members of the

00:00:13,679 --> 00:00:19,199
the ai team and with me is gustavo

00:00:17,119 --> 00:00:21,840
gustavo you want to do a quick intro

00:00:19,199 --> 00:00:24,400
hi i work with tom uh with a tv and

00:00:21,840 --> 00:00:27,279
micro tvm project

00:00:24,400 --> 00:00:27,760
thanks for attending us all right so

00:00:27,279 --> 00:00:30,480
let's

00:00:27,760 --> 00:00:32,000
let's get going so if you would uh go

00:00:30,480 --> 00:00:35,200
ahead and advance the slides

00:00:32,000 --> 00:00:36,239
gustavo to yeah so what we're going to

00:00:35,200 --> 00:00:37,600
do is we're going to start out and we're

00:00:36,239 --> 00:00:41,200
going to talk about what is

00:00:37,600 --> 00:00:42,640
the tvm project in general and

00:00:41,200 --> 00:00:44,239
then as we kind of go through the

00:00:42,640 --> 00:00:46,000
succeeding slides we'll get into

00:00:44,239 --> 00:00:47,360
talking about micro tvm in particular

00:00:46,000 --> 00:00:50,879
which is about

00:00:47,360 --> 00:00:54,160
tvm for microcontrollers so in general

00:00:50,879 --> 00:00:57,440
the tvm is a machine learning framework

00:00:54,160 --> 00:01:00,000
and it's an agnostic compiler stack so

00:00:57,440 --> 00:01:01,680
it has the ability to target cpus gpus

00:01:00,000 --> 00:01:02,719
npus all sorts of different kinds of

00:01:01,680 --> 00:01:04,559
offload

00:01:02,719 --> 00:01:06,000
as well as do some amount of

00:01:04,559 --> 00:01:07,520
heterogeneous

00:01:06,000 --> 00:01:09,920
capabilities between those types of

00:01:07,520 --> 00:01:11,200
devices some of the key things that's

00:01:09,920 --> 00:01:12,960
really important about the particular

00:01:11,200 --> 00:01:14,720
project is it's an apache project which

00:01:12,960 --> 00:01:17,600
means it has all of the

00:01:14,720 --> 00:01:18,159
apache um you know style process around

00:01:17,600 --> 00:01:20,560
it is

00:01:18,159 --> 00:01:21,920
including governance most importantly it

00:01:20,560 --> 00:01:24,640
is under an apache

00:01:21,920 --> 00:01:25,840
version 2 license so it is open source

00:01:24,640 --> 00:01:27,840
you know by one of the strictest

00:01:25,840 --> 00:01:31,040
definitions of what open source is

00:01:27,840 --> 00:01:33,840
uh you go to tvm.apache.org those

00:01:31,040 --> 00:01:35,439
will bring up a number of informational

00:01:33,840 --> 00:01:37,119
pages about the project everything from

00:01:35,439 --> 00:01:37,759
documentation to how to get the source

00:01:37,119 --> 00:01:42,079
code

00:01:37,759 --> 00:01:44,479
to the yearly conference that we have

00:01:42,079 --> 00:01:46,240
and so one of the things that we find

00:01:44,479 --> 00:01:48,000
most exciting about the tvm project in

00:01:46,240 --> 00:01:51,520
general is it supports a

00:01:48,000 --> 00:01:52,880
wide range of hardware so this includes

00:01:51,520 --> 00:01:55,280
you know hardware from the very very

00:01:52,880 --> 00:01:57,520
large to the very very small

00:01:55,280 --> 00:01:58,880
and so as a result of that we've you

00:01:57,520 --> 00:01:59,520
know we've been putting time and effort

00:01:58,880 --> 00:02:01,759
into it

00:01:59,520 --> 00:02:03,040
and we think it is an important part of

00:02:01,759 --> 00:02:05,520
the arm ecosystem

00:02:03,040 --> 00:02:06,640
go ahead gustavo next next slide so

00:02:05,520 --> 00:02:08,640
let's talk a little bit about

00:02:06,640 --> 00:02:09,920
you know what is the tvm architecture

00:02:08,640 --> 00:02:13,440
and what does it kind of look like

00:02:09,920 --> 00:02:16,400
so at the very upper left-hand corner

00:02:13,440 --> 00:02:18,000
what uh tvm has the ability is to

00:02:16,400 --> 00:02:19,599
consume models from a variety of

00:02:18,000 --> 00:02:21,120
different machine language frameworks so

00:02:19,599 --> 00:02:22,080
this is you know your pie torches your

00:02:21,120 --> 00:02:25,200
tensorflows

00:02:22,080 --> 00:02:26,800
keras mxnet you know a whole wide

00:02:25,200 --> 00:02:30,239
variety of frameworks

00:02:26,800 --> 00:02:33,280
and then as it consumes those models it

00:02:30,239 --> 00:02:35,120
will go and transform it into a number

00:02:33,280 --> 00:02:36,800
of different irs that are available to

00:02:35,120 --> 00:02:39,360
it so uh

00:02:36,800 --> 00:02:40,959
you know the you know the route into

00:02:39,360 --> 00:02:43,840
these ars

00:02:40,959 --> 00:02:45,840
is really all about you know taking what

00:02:43,840 --> 00:02:48,160
will be the internal op codes

00:02:45,840 --> 00:02:49,599
from a framework such as tensorflow and

00:02:48,160 --> 00:02:51,599
then transforming into something

00:02:49,599 --> 00:02:54,080
that would be you know more closer to

00:02:51,599 --> 00:02:56,959
what will be um

00:02:54,080 --> 00:02:57,440
optimizable for the compiler stack so

00:02:56,959 --> 00:03:00,640
then

00:02:57,440 --> 00:03:02,640
lower as we lower ourselves we will go

00:03:00,640 --> 00:03:04,800
and look across the optimization space

00:03:02,640 --> 00:03:05,519
for how can we combine op codes how can

00:03:04,800 --> 00:03:08,000
we

00:03:05,519 --> 00:03:08,560
rearrange nodes how can we potentially

00:03:08,000 --> 00:03:11,200
trim

00:03:08,560 --> 00:03:13,280
nodes from the framework and end up with

00:03:11,200 --> 00:03:14,319
a more optimized experience and then so

00:03:13,280 --> 00:03:17,680
as you could of course

00:03:14,319 --> 00:03:20,000
get to the lowest level of the the

00:03:17,680 --> 00:03:21,519
slide you'll see that you know we will

00:03:20,000 --> 00:03:22,800
then get to a point where we need to now

00:03:21,519 --> 00:03:25,680
target real hardware

00:03:22,800 --> 00:03:28,239
so via llvm we may be targeting an armed

00:03:25,680 --> 00:03:31,920
cpu such as an arm64 fx

00:03:28,239 --> 00:03:32,879
we may be targeting a gpu on fpga or

00:03:31,920 --> 00:03:35,519
what have you

00:03:32,879 --> 00:03:37,040
and then on the very right hand side is

00:03:35,519 --> 00:03:37,519
something which is a very important

00:03:37,040 --> 00:03:40,239
piece

00:03:37,519 --> 00:03:41,440
of tvm where it has a concept called

00:03:40,239 --> 00:03:44,319
auto tvm

00:03:41,440 --> 00:03:45,599
where it can take feedback with each

00:03:44,319 --> 00:03:48,959
succeeding step

00:03:45,599 --> 00:03:53,120
and end up with a higher performing

00:03:48,959 --> 00:03:55,439
model where by trying different paths

00:03:53,120 --> 00:03:57,120
it can see oh okay well if i reach nodes

00:03:55,439 --> 00:03:59,200
in this particular way

00:03:57,120 --> 00:04:00,879
i get five percent better so i'll choose

00:03:59,200 --> 00:04:03,280
that path and

00:04:00,879 --> 00:04:05,040
it's through the magic audio tvm that we

00:04:03,280 --> 00:04:07,360
are able to do this feedback

00:04:05,040 --> 00:04:08,959
um you use this feedback to then end up

00:04:07,360 --> 00:04:11,680
with a better performing model

00:04:08,959 --> 00:04:11,680
next slide please

00:04:12,879 --> 00:04:16,880
so that's all great fine and dandy um

00:04:15,599 --> 00:04:19,919
you know we've talked about

00:04:16,880 --> 00:04:21,759
um things when it comes to uh arm

00:04:19,919 --> 00:04:22,960
hardware and cortex a devices but let's

00:04:21,759 --> 00:04:26,160
talk about cortex

00:04:22,960 --> 00:04:28,080
class m devices and so this

00:04:26,160 --> 00:04:29,520
that's the world of microcontrollers and

00:04:28,080 --> 00:04:32,840
of course here we have a

00:04:29,520 --> 00:04:34,000
an st discovery board so this is the the

00:04:32,840 --> 00:04:36,560
00:04:34,000 --> 00:04:39,600
which micro tvm actually runs on today

00:04:36,560 --> 00:04:39,600
so uh next slide

00:04:40,000 --> 00:04:43,040
um so this will be the last slide that i

00:04:42,479 --> 00:04:44,639
talked about

00:04:43,040 --> 00:04:46,880
um before i hand things over because

00:04:44,639 --> 00:04:47,759
just dabo and so we really want to kind

00:04:46,880 --> 00:04:49,280
of get into

00:04:47,759 --> 00:04:50,479
is you know when it comes to

00:04:49,280 --> 00:04:52,720
microcontrollers and you can do

00:04:50,479 --> 00:04:53,840
inferencing on a microcontroller

00:04:52,720 --> 00:04:55,360
how do you do that you know what are

00:04:53,840 --> 00:04:57,280
some of the issues that we're trying to

00:04:55,360 --> 00:05:00,320
wrestle with as we're implementing

00:04:57,280 --> 00:05:01,199
micro tvm so one of which is we need to

00:05:00,320 --> 00:05:04,320
be able to

00:05:01,199 --> 00:05:06,400
ingest models from a wide variety of ai

00:05:04,320 --> 00:05:08,080
frameworks just like tvm does today

00:05:06,400 --> 00:05:10,000
so you ought to be able to import it you

00:05:08,080 --> 00:05:12,320
know a tensorflow lite model you ought

00:05:10,000 --> 00:05:14,479
to be able to work with a pi torch model

00:05:12,320 --> 00:05:15,840
so on so forth the problem though is

00:05:14,479 --> 00:05:17,520
when you have all these different kinds

00:05:15,840 --> 00:05:20,400
of models and frameworks

00:05:17,520 --> 00:05:22,160
you end up with a cartesian product of

00:05:20,400 --> 00:05:23,759
models frameworks and hardware that you

00:05:22,160 --> 00:05:26,160
ultimately need to target

00:05:23,759 --> 00:05:28,080
and i would even add in there you have

00:05:26,160 --> 00:05:29,360
also a set of real-time operating

00:05:28,080 --> 00:05:29,759
systems that you might want to be

00:05:29,360 --> 00:05:31,280
running

00:05:29,759 --> 00:05:33,440
on your microcontroller at the same time

00:05:31,280 --> 00:05:37,199
that you're doing inferencing

00:05:33,440 --> 00:05:39,360
so that said we also

00:05:37,199 --> 00:05:40,800
when it comes to optimizations for

00:05:39,360 --> 00:05:42,880
running a model on a mic

00:05:40,800 --> 00:05:44,639
controller have a wider variety of

00:05:42,880 --> 00:05:46,639
characteristics that we need to be

00:05:44,639 --> 00:05:49,440
tuning for it's not just make the

00:05:46,639 --> 00:05:50,880
you know the model run faster but we

00:05:49,440 --> 00:05:53,520
also have to be thinking in terms

00:05:50,880 --> 00:05:54,160
of the work the working set size i.e how

00:05:53,520 --> 00:05:56,560
much memory

00:05:54,160 --> 00:05:57,600
are you fitting into as well as power

00:05:56,560 --> 00:05:59,199
consumption

00:05:57,600 --> 00:06:00,720
you know when you're in a world of pen

00:05:59,199 --> 00:06:02,160
like batteries and such

00:06:00,720 --> 00:06:04,560
you need to be thinking about these

00:06:02,160 --> 00:06:06,560
things then likewise offload

00:06:04,560 --> 00:06:08,080
is very important in this world as well

00:06:06,560 --> 00:06:08,639
so we're not talking about just doing

00:06:08,080 --> 00:06:11,199
things

00:06:08,639 --> 00:06:12,800
on a cpu although you know certainly in

00:06:11,199 --> 00:06:14,720
the microcontroller world you may only

00:06:12,800 --> 00:06:17,120
have a cpu there you may not have an npu

00:06:14,720 --> 00:06:19,440
you may not have a dsp

00:06:17,120 --> 00:06:21,039
so these are things that the framework

00:06:19,440 --> 00:06:24,240
and microtv in particular

00:06:21,039 --> 00:06:27,039
needs to be able to handle gracefully

00:06:24,240 --> 00:06:29,199
also in the case of microcontrollers

00:06:27,039 --> 00:06:31,840
another way of making a model smaller

00:06:29,199 --> 00:06:33,840
and being able to fit into a better

00:06:31,840 --> 00:06:34,960
working set size is quantization so this

00:06:33,840 --> 00:06:36,560
is when you're working with eight bit

00:06:34,960 --> 00:06:38,080
data types or four bit data types or

00:06:36,560 --> 00:06:39,280
even something smaller than that

00:06:38,080 --> 00:06:41,759
and so through pruning and

00:06:39,280 --> 00:06:45,199
decimalization we need to retain you

00:06:41,759 --> 00:06:45,199
know a reasonable sign of accuracy

00:06:46,400 --> 00:06:49,759
so you know all of this kind of said you

00:06:48,720 --> 00:06:51,680
know you have a really

00:06:49,759 --> 00:06:53,280
interesting set of issues which are

00:06:51,680 --> 00:06:53,919
really unique to the microcontroller

00:06:53,280 --> 00:06:56,240
world

00:06:53,919 --> 00:06:57,440
that micro tv in particular needs to be

00:06:56,240 --> 00:07:00,240
able to handle

00:06:57,440 --> 00:07:01,520
um and lastly you know and probably most

00:07:00,240 --> 00:07:02,800
importantly is you need to be able to

00:07:01,520 --> 00:07:05,440
deploy at scale

00:07:02,800 --> 00:07:06,240
across potential family of devices as

00:07:05,440 --> 00:07:08,160
opposed to just

00:07:06,240 --> 00:07:09,520
one particular device with you know one

00:07:08,160 --> 00:07:11,759
particular type of

00:07:09,520 --> 00:07:13,199
microcontroller on it and so as a result

00:07:11,759 --> 00:07:14,400
we want tools to be able to handle this

00:07:13,199 --> 00:07:15,919
too

00:07:14,400 --> 00:07:19,840
so let's move ahead to the next slide

00:07:15,919 --> 00:07:19,840
and i'll turn things over to gustavo

00:07:23,759 --> 00:07:28,560
um one of the nice things about the tvm

00:07:27,840 --> 00:07:32,319
as

00:07:28,560 --> 00:07:35,759
tom mentioned is that

00:07:32,319 --> 00:07:40,560
tvm can target micro controllers

00:07:35,759 --> 00:07:40,560
and uh for that uh specific um

00:07:41,680 --> 00:07:47,039
runtime there is a minimum run time

00:07:44,400 --> 00:07:50,479
which leverages the tvm framework

00:07:47,039 --> 00:07:54,720
and uh which implements an rpc server

00:07:50,479 --> 00:07:58,319
and also is able to run on top of a

00:07:54,720 --> 00:08:01,360
zephyr or any other r toss

00:07:58,319 --> 00:08:04,960
uh or and also our tossless

00:08:01,360 --> 00:08:06,400
uh in um without any um

00:08:04,960 --> 00:08:09,840
[Music]

00:08:06,400 --> 00:08:13,199
uh are our toss uh under

00:08:09,840 --> 00:08:13,680
it um and it's written in c and c plus

00:08:13,199 --> 00:08:17,120
plus

00:08:13,680 --> 00:08:21,599
and uh has got lots of python bindings

00:08:17,120 --> 00:08:24,960
uh so the user can use uh python apis to

00:08:21,599 --> 00:08:26,160
generate uh final firmware images ready

00:08:24,960 --> 00:08:29,120
to be flashed

00:08:26,160 --> 00:08:31,759
and get uh micro tv i'm running on the

00:08:29,120 --> 00:08:32,560
targets and the micro tvm is a work in

00:08:31,759 --> 00:08:35,919
progress so

00:08:32,560 --> 00:08:40,399
it has been a lot of work recently and

00:08:35,919 --> 00:08:43,760
currently on on that front um

00:08:40,399 --> 00:08:45,120
the uh the um the typical work uh

00:08:43,760 --> 00:08:48,160
development workflow on

00:08:45,120 --> 00:08:51,519
tv and also and also on micro tvm

00:08:48,160 --> 00:08:54,720
is that we it takes as a input

00:08:51,519 --> 00:08:58,399
any uh uh format uh

00:08:54,720 --> 00:09:01,760
is exported by uh ai frameworks like

00:08:58,399 --> 00:09:04,800
pytorch uh tensorflow uh

00:09:01,760 --> 00:09:08,640
tensorflow lite format um and

00:09:04,800 --> 00:09:11,120
it loads it um in into a python

00:09:08,640 --> 00:09:12,000
object and then tvm parses it and

00:09:11,120 --> 00:09:14,640
generates a

00:09:12,000 --> 00:09:16,640
intermediate uh representation and then

00:09:14,640 --> 00:09:20,480
it uses a llvm

00:09:16,640 --> 00:09:25,279
api internally to convert given a target

00:09:20,480 --> 00:09:27,839
to uh that intermediate intermediate uh

00:09:25,279 --> 00:09:28,720
representation which is called relay ir

00:09:27,839 --> 00:09:32,240
and tvm

00:09:28,720 --> 00:09:34,880
uh to a final uh to to

00:09:32,240 --> 00:09:35,600
see sources for instance uh and then

00:09:34,880 --> 00:09:39,040
once we

00:09:35,600 --> 00:09:39,680
we've got uh dc sources uh where one can

00:09:39,040 --> 00:09:44,000
use

00:09:39,680 --> 00:09:46,720
um any um normal to chain for a target

00:09:44,000 --> 00:09:49,200
to uh compile uh finally the c source

00:09:46,720 --> 00:09:49,680
generated by tvm into a native code to

00:09:49,200 --> 00:09:52,880
run

00:09:49,680 --> 00:09:55,680
on the board um

00:09:52,880 --> 00:09:57,360
so um we've been uh working since the

00:09:55,680 --> 00:10:01,519
beginning of this year with a couple

00:09:57,360 --> 00:10:05,120
of um targets

00:10:01,519 --> 00:10:07,920
armed targets and experimenting and uh

00:10:05,120 --> 00:10:09,600
micro tvm on top of those target targets

00:10:07,920 --> 00:10:13,040
uh using uh primarily

00:10:09,600 --> 00:10:16,320
uh zephyr rtos and uh from uh from a

00:10:13,040 --> 00:10:17,680
zephyr's perspective it the microtubules

00:10:16,320 --> 00:10:20,959
is just an application for

00:10:17,680 --> 00:10:24,399
zephyr and uh in doing that we have

00:10:20,959 --> 00:10:26,880
um successfully run

00:10:24,399 --> 00:10:27,440
micro tv on nuclear boards which has a

00:10:26,880 --> 00:10:30,800
cortex

00:10:27,440 --> 00:10:34,000
m seven uh based uh mcu

00:10:30,800 --> 00:10:38,079
and also we successfully successfully

00:10:34,000 --> 00:10:38,880
uh run um micro tvm on disco board which

00:10:38,079 --> 00:10:41,760
has got

00:10:38,880 --> 00:10:42,560
this very same uh mcu as the nuclear

00:10:41,760 --> 00:10:45,600
board but with

00:10:42,560 --> 00:10:46,399
some additional peripherals and the lcd

00:10:45,600 --> 00:10:50,079
so the

00:10:46,399 --> 00:10:51,279
memory map is memory layout is a little

00:10:50,079 --> 00:10:54,720
bit different

00:10:51,279 --> 00:10:57,120
um and the most uh recently we

00:10:54,720 --> 00:10:58,079
were able to successfully run my micro

00:10:57,120 --> 00:11:01,600
gvm on the

00:10:58,079 --> 00:11:04,320
mps to n5 en 521 board uh which

00:11:01,600 --> 00:11:05,760
is uh picture number three and this is a

00:11:04,320 --> 00:11:08,560
quite interesting board because

00:11:05,760 --> 00:11:09,519
this is actually a fpg board and uh you

00:11:08,560 --> 00:11:15,040
one can download

00:11:09,519 --> 00:11:18,320
uh a standard uh fpga image from arm

00:11:15,040 --> 00:11:20,720
and flash into that board and it will

00:11:18,320 --> 00:11:22,000
uh provide exactly the same uh a

00:11:20,720 --> 00:11:25,200
specification found

00:11:22,000 --> 00:11:25,839
in aen 521 application notes the a n

00:11:25,200 --> 00:11:28,640
stands for

00:11:25,839 --> 00:11:30,320
application notes and it's it specifies

00:11:28,640 --> 00:11:33,360
all the memory regions

00:11:30,320 --> 00:11:36,800
uh in in in devices that follow that

00:11:33,360 --> 00:11:40,240
specification uh we have uh patches

00:11:36,800 --> 00:11:40,959
uh some patches go to zephyr and other

00:11:40,240 --> 00:11:44,399
patches go

00:11:40,959 --> 00:11:45,680
to micro tvm itself to enable micro gvm

00:11:44,399 --> 00:11:48,720
run on those on that

00:11:45,680 --> 00:11:51,920
mps2 board and looking ahead we

00:11:48,720 --> 00:11:56,160
are um um looking at the uh

00:11:51,920 --> 00:12:00,160
mps3 en 5 5 47

00:11:56,160 --> 00:12:03,279
board which is which has a cortex m55

00:12:00,160 --> 00:12:06,120
based uh mcu and is that word is quite

00:12:03,279 --> 00:12:10,079
interesting because it has got a ethos

00:12:06,120 --> 00:12:14,079
u55 mpu and so we can offload

00:12:10,079 --> 00:12:17,120
um the um offload some operations

00:12:14,079 --> 00:12:19,600
uh to be executed um

00:12:17,120 --> 00:12:20,880
in uh and delegate that to be executed

00:12:19,600 --> 00:12:24,399
in in the npu

00:12:20,880 --> 00:12:24,399
not so not on

00:12:25,200 --> 00:12:31,440
mcu um some of the

00:12:28,320 --> 00:12:34,959
uh there are a current work from

00:12:31,440 --> 00:12:36,240
the embedded uh folks uh at linaro to

00:12:34,959 --> 00:12:38,720
enable zaful run

00:12:36,240 --> 00:12:39,519
on the mps3 uh there is a pull request

00:12:38,720 --> 00:12:42,480
for that

00:12:39,519 --> 00:12:44,880
uh but we couldn't uh we don't have uh

00:12:42,480 --> 00:12:46,639
support on pmu however there is the ftp

00:12:44,880 --> 00:12:49,680
from army which is a fixed

00:12:46,639 --> 00:12:53,279
um fixed um

00:12:49,680 --> 00:12:54,240
vfp i'm sorry virtual fixed platform

00:12:53,279 --> 00:12:57,440
which is the

00:12:54,240 --> 00:12:59,200
emulator from arm which one can use

00:12:57,440 --> 00:13:02,079
instead of qmu to run and

00:12:59,200 --> 00:13:04,880
experiment micro micro tvm on top of

00:13:02,079 --> 00:13:08,240
mks3 boards

00:13:04,880 --> 00:13:12,000
so um another thing

00:13:08,240 --> 00:13:14,880
which is um uh interesting uh is that

00:13:12,000 --> 00:13:17,200
tvm comes with a tool called the cbmc

00:13:14,880 --> 00:13:20,480
which is a common line interface tool

00:13:17,200 --> 00:13:21,200
and uh it has two main use cases uh one

00:13:20,480 --> 00:13:24,320
of the first

00:13:21,200 --> 00:13:26,240
uh use cases to use development workflow

00:13:24,320 --> 00:13:29,519
uh so it allows uh one

00:13:26,240 --> 00:13:32,839
to uh split the compile uh

00:13:29,519 --> 00:13:35,920
and run for instance uh or debugging

00:13:32,839 --> 00:13:39,120
stages uh on microtvm uh

00:13:35,920 --> 00:13:40,639
using my tvmc without having for

00:13:39,120 --> 00:13:43,760
instance to run

00:13:40,639 --> 00:13:47,279
through all the stages of the workflow

00:13:43,760 --> 00:13:49,680
uh at once so you can use you can

00:13:47,279 --> 00:13:51,360
for instance just run the model and

00:13:49,680 --> 00:13:52,560
start debugging it instead of having to

00:13:51,360 --> 00:13:55,199
compile a model

00:13:52,560 --> 00:13:55,600
and flash it and run it all over again

00:13:55,199 --> 00:13:59,600
uh

00:13:55,600 --> 00:14:02,240
as if one would do uh using the python

00:13:59,600 --> 00:14:02,800
apis and the other use case is that a

00:14:02,240 --> 00:14:06,240
micro

00:14:02,800 --> 00:14:08,560
micro tvmc can be can generate uh uh

00:14:06,240 --> 00:14:09,279
just the sea sources for instance and it

00:14:08,560 --> 00:14:12,959
can be

00:14:09,279 --> 00:14:16,000
ready uh readily uh be picked up by

00:14:12,959 --> 00:14:19,199
another project and uh be used to inside

00:14:16,000 --> 00:14:22,320
make files uh for instance so this is

00:14:19,199 --> 00:14:24,079
the main two um use cases uh for

00:14:22,320 --> 00:14:27,360
microtubulemc however

00:14:24,079 --> 00:14:30,079
uh currently uh my tvmc only

00:14:27,360 --> 00:14:32,399
doesn't support uh micro tvm target so

00:14:30,079 --> 00:14:35,600
we have proposed an rfc

00:14:32,399 --> 00:14:38,240
toward that uh micro uh

00:14:35,600 --> 00:14:39,279
support for micro and uh microcontroller

00:14:38,240 --> 00:14:42,959
units uh

00:14:39,279 --> 00:14:46,320
on tvmc um uh on doing that

00:14:42,959 --> 00:14:48,639
uh we didn't realize that some uh

00:14:46,320 --> 00:14:50,399
refactor was necessary to accommodate

00:14:48,639 --> 00:14:53,600
the changes necessary to

00:14:50,399 --> 00:14:57,120
enable the micro tvm targets on tvmc

00:14:53,600 --> 00:15:00,639
and uh so the community proposed to uh

00:14:57,120 --> 00:15:01,920
two new rfcs which is the model library

00:15:00,639 --> 00:15:05,760
format in the api

00:15:01,920 --> 00:15:09,760
project um in in the project api

00:15:05,760 --> 00:15:12,800
uh rfc and uh the idea is that the

00:15:09,760 --> 00:15:16,480
the flow stages that generate artifacts

00:15:12,800 --> 00:15:19,440
like c sources or compiled objects

00:15:16,480 --> 00:15:21,040
we use the model library format to store

00:15:19,440 --> 00:15:23,120
uh the artifacts and

00:15:21,040 --> 00:15:25,120
on the other hand the project api will

00:15:23,120 --> 00:15:26,000
allow better integration with various

00:15:25,120 --> 00:15:28,480
are tosses

00:15:26,000 --> 00:15:29,120
not just zephyr because currently zephyr

00:15:28,480 --> 00:15:32,639
is

00:15:29,120 --> 00:15:35,839
kind of too tight coupled to the

00:15:32,639 --> 00:15:39,360
micro tvm code and in doing that

00:15:35,839 --> 00:15:42,240
uh we are proposing in that rfc

00:15:39,360 --> 00:15:44,639
uh a new uh context code micro which

00:15:42,240 --> 00:15:48,160
will support the workflow for micro

00:15:44,639 --> 00:15:52,240
uh tvm targets and uh uh the

00:15:48,160 --> 00:15:54,720
the the lines in in in blue are just uh

00:15:52,240 --> 00:15:56,160
an example of workflow a typical

00:15:54,720 --> 00:15:59,680
workflow that one

00:15:56,160 --> 00:16:01,360
uh will uh follow when using tbmc with

00:15:59,680 --> 00:16:03,680
micro tvm targets

00:16:01,360 --> 00:16:04,560
and so you we are proposing like for

00:16:03,680 --> 00:16:06,839
instance a

00:16:04,560 --> 00:16:08,079
micro create project where you can

00:16:06,839 --> 00:16:11,040
specify uh

00:16:08,079 --> 00:16:11,680
zephyr backhand or embed backhand and so

00:16:11,040 --> 00:16:15,440
on

00:16:11,680 --> 00:16:16,320
uh we are um proposing a micro build

00:16:15,440 --> 00:16:19,040
which will

00:16:16,320 --> 00:16:20,959
uh comment which will uh get this

00:16:19,040 --> 00:16:23,199
resource and generate the firmware

00:16:20,959 --> 00:16:24,160
and uh we are also proposing a micro

00:16:23,199 --> 00:16:27,279
flash which will

00:16:24,160 --> 00:16:28,720
effectively flash the generator firmware

00:16:27,279 --> 00:16:31,519
into the target

00:16:28,720 --> 00:16:32,399
board and finally micro run because uh

00:16:31,519 --> 00:16:35,839
the run for

00:16:32,399 --> 00:16:38,079
micro targets has some some uh

00:16:35,839 --> 00:16:40,079
specific steps like open connection with

00:16:38,079 --> 00:16:42,959
serial ports and so on

00:16:40,079 --> 00:16:42,959
so um

00:16:43,759 --> 00:16:49,040
this is um um i just would like to

00:16:47,199 --> 00:16:50,560
to mention uh three main components

00:16:49,040 --> 00:16:53,360
about the

00:16:50,560 --> 00:16:54,959
firmware which is flashed in which is

00:16:53,360 --> 00:16:56,800
generated by tvmc

00:16:54,959 --> 00:16:59,199
and which will be flashed into the

00:16:56,800 --> 00:17:00,079
device and it has two uh three main

00:16:59,199 --> 00:17:03,279
components

00:17:00,079 --> 00:17:04,240
with which is uh the first one is is the

00:17:03,279 --> 00:17:07,280
code that

00:17:04,240 --> 00:17:08,959
um is necessary to initialize all the

00:17:07,280 --> 00:17:12,079
device and preferrals on

00:17:08,959 --> 00:17:13,039
and uh it has code for the library such

00:17:12,079 --> 00:17:16,880
as a

00:17:13,039 --> 00:17:21,199
time control and vendor uh code specific

00:17:16,880 --> 00:17:25,360
uh for uh performance of operations

00:17:21,199 --> 00:17:28,160
um which will be related to to the model

00:17:25,360 --> 00:17:30,400
uh the second thing about the runtime

00:17:28,160 --> 00:17:33,840
the micro tvm runtime is that uh

00:17:30,400 --> 00:17:36,960
it is miserable three miss misra c

00:17:33,840 --> 00:17:39,600
uh compliant which um

00:17:36,960 --> 00:17:40,640
and it has a uh rpc server as i

00:17:39,600 --> 00:17:42,720
mentioned before

00:17:40,640 --> 00:17:44,160
uh to allows interaction with the host

00:17:42,720 --> 00:17:46,320
so host can command

00:17:44,160 --> 00:17:48,320
which operations are necessary to be

00:17:46,320 --> 00:17:51,840
executed at the target site

00:17:48,320 --> 00:17:55,520
um to run the graph or to run the model

00:17:51,840 --> 00:17:58,240
and get grab and um um

00:17:55,520 --> 00:17:59,039
uh result and get the final result from

00:17:58,240 --> 00:18:02,000
the execute

00:17:59,039 --> 00:18:02,320
execution of the the model in the target

00:18:02,000 --> 00:18:05,280
and

00:18:02,320 --> 00:18:05,840
uh that runtime also has uh ability to

00:18:05,280 --> 00:18:09,200
uh

00:18:05,840 --> 00:18:10,400
uh have set sessions uh and each session

00:18:09,200 --> 00:18:13,679
is open to

00:18:10,400 --> 00:18:14,320
uh when uh the host uh established

00:18:13,679 --> 00:18:16,960
connections

00:18:14,320 --> 00:18:18,720
with the rpc server to request an

00:18:16,960 --> 00:18:22,000
execution of an operation

00:18:18,720 --> 00:18:24,080
and finally the the third part of the

00:18:22,000 --> 00:18:25,120
binary contains the compiled tv and

00:18:24,080 --> 00:18:28,240
operations

00:18:25,120 --> 00:18:31,600
the node from the graph of the model

00:18:28,240 --> 00:18:32,400
which is uh generated specific by each

00:18:31,600 --> 00:18:34,799
model

00:18:32,400 --> 00:18:36,960
and uh also uh there are some

00:18:34,799 --> 00:18:40,320
interesting uh things that we can

00:18:36,960 --> 00:18:43,039
uh do uh with uh the operations like

00:18:40,320 --> 00:18:44,240
uh the term at compile time where the

00:18:43,039 --> 00:18:47,600
operation code

00:18:44,240 --> 00:18:48,720
will land in the target device and this

00:18:47,600 --> 00:18:50,960
is important because

00:18:48,720 --> 00:18:52,240
depending on the board the run memory is

00:18:50,960 --> 00:18:54,080
not

00:18:52,240 --> 00:18:56,000
is mapped to different devices and some

00:18:54,080 --> 00:18:59,039
of the device might be quite

00:18:56,000 --> 00:19:02,400
slow so we can change that and

00:18:59,039 --> 00:19:05,840
put the operation code in a faster run

00:19:02,400 --> 00:19:09,039
for execution so uh for

00:19:05,840 --> 00:19:10,240
uh anybody interested in looking at

00:19:09,039 --> 00:19:13,520
micro tvm

00:19:10,240 --> 00:19:16,799
i recommend looking at that script

00:19:13,520 --> 00:19:20,400
which is an example of how to load um

00:19:16,799 --> 00:19:25,280
a compile and run a model

00:19:20,400 --> 00:19:28,960
a tensorflow mod transfer flow like

00:19:25,280 --> 00:19:33,360
model for predicting a scene

00:19:28,960 --> 00:19:36,160
function and it is found in the repo

00:19:33,360 --> 00:19:38,559
in tutorials slash micro slash micro

00:19:36,160 --> 00:19:42,000
underline tf light dot pi

00:19:38,559 --> 00:19:45,600
and uh the the thing i i would like

00:19:42,000 --> 00:19:47,440
uh to to to i just would like to

00:19:45,600 --> 00:19:49,280
walk through the main parts of that

00:19:47,440 --> 00:19:50,240
script uh which is precisely the

00:19:49,280 --> 00:19:52,160
workflow we have

00:19:50,240 --> 00:19:53,440
discussed in the in the previous

00:19:52,160 --> 00:19:56,000
previous slide

00:19:53,440 --> 00:19:56,799
which is uh the first we we load the etf

00:19:56,000 --> 00:19:59,360
file

00:19:56,799 --> 00:19:59,919
uh and then we have the python model

00:19:59,360 --> 00:20:03,440
object

00:19:59,919 --> 00:20:07,520
and then we convert it to a relay

00:20:03,440 --> 00:20:10,880
uh ir and the weights

00:20:07,520 --> 00:20:13,440
and then we specify a target a board

00:20:10,880 --> 00:20:15,360
and then we request cvm to generate the

00:20:13,440 --> 00:20:18,559
sources for

00:20:15,360 --> 00:20:21,919
that relay ir and

00:20:18,559 --> 00:20:25,360
it uses a well vm api for that and uh

00:20:21,919 --> 00:20:28,960
then the result um uh

00:20:25,360 --> 00:20:31,520
is that we after specifying

00:20:28,960 --> 00:20:32,799
the target uh and compiling the

00:20:31,520 --> 00:20:35,200
compiling the ir

00:20:32,799 --> 00:20:36,880
we have three main outputs which is the

00:20:35,200 --> 00:20:39,600
json file with the

00:20:36,880 --> 00:20:41,440
which represents the execution of the

00:20:39,600 --> 00:20:44,159
model we have compiled

00:20:41,440 --> 00:20:45,280
um this is source with the operations

00:20:44,159 --> 00:20:48,000
and the model

00:20:45,280 --> 00:20:48,480
parameters for each layer of the model

00:20:48,000 --> 00:20:52,159
so

00:20:48,480 --> 00:20:54,799
um after that we have everything to

00:20:52,159 --> 00:20:55,520
call uh like zephyr uh the zephyr

00:20:54,799 --> 00:20:58,720
backhand

00:20:55,520 --> 00:21:01,120
uh uh and specify a compiler

00:20:58,720 --> 00:21:02,000
for that and in that case we are

00:21:01,120 --> 00:21:05,039
basically

00:21:02,000 --> 00:21:08,720
using zephyr's sdk to chain to convert

00:21:05,039 --> 00:21:12,240
the final c sources generated from ir

00:21:08,720 --> 00:21:13,520
to native code and once we do that we

00:21:12,240 --> 00:21:16,400
have a firmware

00:21:13,520 --> 00:21:17,120
ready to be flashed we open a session

00:21:16,400 --> 00:21:21,120
and uh

00:21:17,120 --> 00:21:21,120
when you open a session uh the

00:21:21,280 --> 00:21:27,440
micro tvm libraries will just

00:21:24,320 --> 00:21:30,480
flash the firmware and open a session

00:21:27,440 --> 00:21:33,440
and we define the input

00:21:30,480 --> 00:21:33,840
like in that case it's an angle uh for

00:21:33,440 --> 00:21:37,120
the

00:21:33,840 --> 00:21:40,960
the model and we run it and we grab

00:21:37,120 --> 00:21:44,080
uh the result of the execution

00:21:40,960 --> 00:21:46,640
so um that's what i had to

00:21:44,080 --> 00:21:48,159
talk uh some about uh someone quick in

00:21:46,640 --> 00:21:50,720
introducing up update

00:21:48,159 --> 00:21:51,760
about uh microtvm and in the following

00:21:50,720 --> 00:21:54,880
dislikes are quite

00:21:51,760 --> 00:21:57,840
uh interesting and uh helpful

00:21:54,880 --> 00:21:59,840
uh information about the roadmaps for

00:21:57,840 --> 00:22:02,960
tvn and micro tvm

00:21:59,840 --> 00:22:06,080
and um also we have uh tommy square

00:22:02,960 --> 00:22:08,720
is is the coordinator of the project and

00:22:06,080 --> 00:22:09,520
we have a slight channel so feel free to

00:22:08,720 --> 00:22:14,960
to join us

00:22:09,520 --> 00:22:14,960
and ask more about tv and michael tvm

00:22:15,360 --> 00:22:19,120
that's it from my side um tom do you

00:22:18,400 --> 00:22:22,320
have any

00:22:19,120 --> 00:22:24,080
additional comments yeah i think given

00:22:22,320 --> 00:22:25,919
uh we have about two minutes left in the

00:22:24,080 --> 00:22:40,640
session let's pause for questions so

00:22:25,919 --> 00:22:44,799
does anyone have any questions

00:22:40,640 --> 00:22:48,240
objections or suggestions or

00:22:44,799 --> 00:22:50,240
like don't do don't do that guys or

00:22:48,240 --> 00:22:51,760
whatever well we'll certainly be around

00:22:50,240 --> 00:22:54,799
through um

00:22:51,760 --> 00:22:56,400
all of connect and be happy to

00:22:54,799 --> 00:22:58,240
you know entertain any questions sir

00:22:56,400 --> 00:22:59,600
they come to you later or

00:22:58,240 --> 00:23:09,840
you know send us an email we're always

00:22:59,600 --> 00:23:09,840
happy to chat

00:23:16,960 --> 00:23:21,600
oh there we go um so we have one

00:23:19,360 --> 00:23:23,200
question is do tvm and micro microtvm

00:23:21,600 --> 00:23:25,280
build from one code base or is it

00:23:23,200 --> 00:23:27,760
semi-detached project

00:23:25,280 --> 00:23:31,200
they are all in the same get tree so

00:23:27,760 --> 00:23:31,200
essentially it is one code base

00:23:48,840 --> 00:23:51,840
this

00:23:58,400 --> 00:24:01,840
okay any other questions if not i think

00:24:00,559 --> 00:24:02,960
we

00:24:01,840 --> 00:24:05,840
probably can go ahead and end the

00:24:02,960 --> 00:24:05,840
session

00:24:09,120 --> 00:24:12,240
all right well thanks everyone for for

00:24:10,559 --> 00:24:14,000
being here today we appreciate having

00:24:12,240 --> 00:24:19,840
this opportunity to present to you on

00:24:14,000 --> 00:24:19,840
micro tvm

00:24:29,200 --> 00:24:31,279

YouTube URL: https://www.youtube.com/watch?v=dRfOaJF3Coc


