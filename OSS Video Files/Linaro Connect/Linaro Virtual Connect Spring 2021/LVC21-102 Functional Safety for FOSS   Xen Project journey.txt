Title: LVC21-102 Functional Safety for FOSS   Xen Project journey
Publication date: 2021-04-15
Playlist: Linaro Virtual Connect Spring 2021
Description: 
	The use of FOSS for safety-critical domains is considered highly interesting by industries such as automotive, as it enables a shorter time-to-market and lower development costs for generic components. However, formal functional safety requirements are very hard to implement, and it was never done before for mainline of generic FOSS projects, which were initially created without safety in mind. 

In this talk I will cover Linux Foundation's Xen Project developments for Automotive industry, our community approach for Functional Safety requirements compliance and our progress so far.
Captions: 
	00:00:00,080 --> 00:00:07,279
my name is out of kiev

00:00:03,600 --> 00:00:07,919
from ipam my name is bertrand marquis

00:00:07,279 --> 00:00:11,040
i'm from

00:00:07,919 --> 00:00:11,360
arm i'm stefano stabellini and i work

00:00:11,040 --> 00:00:13,840
for

00:00:11,360 --> 00:00:15,599
exciting's today we'll talk about

00:00:13,840 --> 00:00:18,880
functional safety for generic

00:00:15,599 --> 00:00:22,560
open source projects on as an example

00:00:18,880 --> 00:00:25,920
um i'll start quickly with background uh

00:00:22,560 --> 00:00:28,000
so what is a functional safety overall

00:00:25,920 --> 00:00:29,439
functional safety in general if you go

00:00:28,000 --> 00:00:30,000
through all of the definitions of it

00:00:29,439 --> 00:00:33,200
it's a

00:00:30,000 --> 00:00:35,440
absence of unreasonable risks uh

00:00:33,200 --> 00:00:36,800
for both internal external hazards like

00:00:35,440 --> 00:00:39,200
potential source of harm

00:00:36,800 --> 00:00:41,040
that can cause malfunction behavior of a

00:00:39,200 --> 00:00:41,520
system so that outputs are not going to

00:00:41,040 --> 00:00:44,559
be

00:00:41,520 --> 00:00:47,920
same as expected depending on

00:00:44,559 --> 00:00:51,920
on their inputs and all of that

00:00:47,920 --> 00:00:53,760
very complex definition is regulated by

00:00:51,920 --> 00:00:55,039
different standards across the industry

00:00:53,760 --> 00:00:57,680
so regulated

00:00:55,039 --> 00:00:59,600
by different standards like 61508 is a

00:00:57,680 --> 00:01:02,079
very generic umbrella standard

00:00:59,600 --> 00:01:03,440
for all of the industries and saying

00:01:02,079 --> 00:01:05,760
some definitions

00:01:03,440 --> 00:01:06,560
with uh iso 262 for example his

00:01:05,760 --> 00:01:07,920
application of

00:01:06,560 --> 00:01:10,479
functional safety regulations for

00:01:07,920 --> 00:01:13,040
automotive and misra is

00:01:10,479 --> 00:01:13,760
a very generic coding guidelines and

00:01:13,040 --> 00:01:15,439
rules

00:01:13,760 --> 00:01:17,439
for automotive industry that existed

00:01:15,439 --> 00:01:20,479
even before the previously appeared

00:01:17,439 --> 00:01:20,880
at creating some deterministic behavior

00:01:20,479 --> 00:01:23,759
for

00:01:20,880 --> 00:01:25,600
in defensive programming techniques and

00:01:23,759 --> 00:01:27,759
these regulations usually demand

00:01:25,600 --> 00:01:29,040
that product safety requirements are

00:01:27,759 --> 00:01:30,479
fully defined

00:01:29,040 --> 00:01:32,799
and the product team is able to

00:01:30,479 --> 00:01:35,119
demonstrate that these requirements are

00:01:32,799 --> 00:01:36,079
implemented properly on every level of

00:01:35,119 --> 00:01:39,119
the

00:01:36,079 --> 00:01:40,880
software design and the requirements

00:01:39,119 --> 00:01:42,159
architecture here in design and testing

00:01:40,880 --> 00:01:45,600
they all comply to

00:01:42,159 --> 00:01:46,799
best practices defined by the standard

00:01:45,600 --> 00:01:48,720
regulations

00:01:46,799 --> 00:01:50,159
and development process complex

00:01:48,720 --> 00:01:52,079
regulations with regulations

00:01:50,159 --> 00:01:53,759
and all of the processes are strictly

00:01:52,079 --> 00:01:56,960
followed so it's all about

00:01:53,759 --> 00:02:00,000
following very narrow narrowly set

00:01:56,960 --> 00:02:02,240
definitions with all that can actually

00:02:00,000 --> 00:02:04,799
generate fosa project be used for

00:02:02,240 --> 00:02:06,159
functional safety there are lots of gaps

00:02:04,799 --> 00:02:08,479
like um

00:02:06,159 --> 00:02:10,239
traditionally full force projects lack

00:02:08,479 --> 00:02:11,920
determinism and fall processing and

00:02:10,239 --> 00:02:13,920
there are not much defensive development

00:02:11,920 --> 00:02:16,319
put in place although this is changing

00:02:13,920 --> 00:02:17,040
recently certain engineering practices

00:02:16,319 --> 00:02:18,720
like create

00:02:17,040 --> 00:02:20,720
maintaining very well defined

00:02:18,720 --> 00:02:23,520
documentation is not very

00:02:20,720 --> 00:02:25,440
uh used in false projects although pre

00:02:23,520 --> 00:02:27,920
improves on in some of them

00:02:25,440 --> 00:02:29,760
and strictly following the engineering

00:02:27,920 --> 00:02:32,239
process except probably the commit

00:02:29,760 --> 00:02:34,800
is also not very well followed and of

00:02:32,239 --> 00:02:37,920
course open source project not

00:02:34,800 --> 00:02:41,280
often use non-free tools infrastructure

00:02:37,920 --> 00:02:42,720
and uh expertise so with that

00:02:41,280 --> 00:02:44,959
there might be significant changes in

00:02:42,720 --> 00:02:46,640
how false projects work and manage if

00:02:44,959 --> 00:02:49,360
they want to be applied for foosa

00:02:46,640 --> 00:02:50,319
and until recently by industry it was

00:02:49,360 --> 00:02:52,480
assumed that

00:02:50,319 --> 00:02:54,319
these kind of not not not can be

00:02:52,480 --> 00:02:56,640
compliance or force cannot be used in

00:02:54,319 --> 00:02:58,959
functional safety

00:02:56,640 --> 00:02:59,760
well at some projects we we think that

00:02:58,959 --> 00:03:01,440
is possible

00:02:59,760 --> 00:03:02,800
and they're of course the catch so it's

00:03:01,440 --> 00:03:03,680
extremely hard to follow all the

00:03:02,800 --> 00:03:05,120
requirements

00:03:03,680 --> 00:03:07,040
and actually tailoring of these

00:03:05,120 --> 00:03:08,480
requirements is possible a lot in

00:03:07,040 --> 00:03:10,480
practice so that's what

00:03:08,480 --> 00:03:12,239
what we want to do of course the more

00:03:10,480 --> 00:03:14,159
you tailor the higher the risk that

00:03:12,239 --> 00:03:16,239
safety cases will not pass

00:03:14,159 --> 00:03:17,840
so the the cost will be higher and

00:03:16,239 --> 00:03:18,480
tailoring also means that you need to

00:03:17,840 --> 00:03:20,319
fund

00:03:18,480 --> 00:03:21,840
a specialist consultancy for assessing

00:03:20,319 --> 00:03:22,640
company that will help you passing

00:03:21,840 --> 00:03:24,879
through the

00:03:22,640 --> 00:03:26,080
gates of certification and in the end

00:03:24,879 --> 00:03:27,360
verification of a product will

00:03:26,080 --> 00:03:28,400
demonstrate that everything has been

00:03:27,360 --> 00:03:30,720
done correctly

00:03:28,400 --> 00:03:32,239
or with the help of the specialists

00:03:30,720 --> 00:03:33,599
you'll be able to argue that everything

00:03:32,239 --> 00:03:36,400
is done

00:03:33,599 --> 00:03:37,120
as good as it can be within specific

00:03:36,400 --> 00:03:39,440
standard

00:03:37,120 --> 00:03:40,400
increase so all of that can be done

00:03:39,440 --> 00:03:42,720
basically only

00:03:40,400 --> 00:03:44,000
if assessors are actively involved in

00:03:42,720 --> 00:03:46,560
development process

00:03:44,000 --> 00:03:47,760
which is traditionally not the true for

00:03:46,560 --> 00:03:50,000
false projects

00:03:47,760 --> 00:03:51,599
so for existing projects like zen what

00:03:50,000 --> 00:03:54,319
we need to do we need to rework

00:03:51,599 --> 00:03:55,680
somewhat code base to pro very well

00:03:54,319 --> 00:03:57,040
defined have very well-defined

00:03:55,680 --> 00:03:59,360
interfaces modularity

00:03:57,040 --> 00:04:00,080
reduce complexity improve determinism

00:03:59,360 --> 00:04:01,840
add

00:04:00,080 --> 00:04:03,360
full processing and improve fault

00:04:01,840 --> 00:04:04,879
tolerance in general

00:04:03,360 --> 00:04:06,080
we need to add all of the missing

00:04:04,879 --> 00:04:07,760
documentation artifacts like

00:04:06,080 --> 00:04:09,840
specification testing

00:04:07,760 --> 00:04:11,200
we need to have full traceability

00:04:09,840 --> 00:04:13,599
between

00:04:11,200 --> 00:04:14,720
test cases between code between

00:04:13,599 --> 00:04:16,959
documents

00:04:14,720 --> 00:04:18,799
which is also very hard to implement a

00:04:16,959 --> 00:04:21,600
strictly defined development process

00:04:18,799 --> 00:04:23,280
or explain existing development process

00:04:21,600 --> 00:04:25,840
find gaps and define the

00:04:23,280 --> 00:04:27,440
and close these gaps and after all of

00:04:25,840 --> 00:04:30,000
that is done we need to ensure the

00:04:27,440 --> 00:04:34,160
safety process rigorously

00:04:30,000 --> 00:04:35,759
and the approach we took is um

00:04:34,160 --> 00:04:37,199
we analyzed the previous work that has

00:04:35,759 --> 00:04:40,080
been done in zen

00:04:37,199 --> 00:04:42,560
actually zen was already certified

00:04:40,080 --> 00:04:43,840
sometimes for aerospace for deal 178

00:04:42,560 --> 00:04:46,400
standard dlc

00:04:43,840 --> 00:04:47,840
level and the effort as we learned it

00:04:46,400 --> 00:04:49,360
from a company that did it

00:04:47,840 --> 00:04:51,520
was like five to 15 million years

00:04:49,360 --> 00:04:53,040
depending on the code base

00:04:51,520 --> 00:04:54,560
and that was needed for one off

00:04:53,040 --> 00:04:56,080
certification that was not done for

00:04:54,560 --> 00:04:59,120
mainline for mainstream that was done

00:04:56,080 --> 00:05:01,759
for safety by safety trained engineers

00:04:59,120 --> 00:05:03,919
and the effort actually heavy depends on

00:05:01,759 --> 00:05:05,759
the code size so if you look at zen

00:05:03,919 --> 00:05:07,440
like more than half of zen code is

00:05:05,759 --> 00:05:10,560
actually x86 part and

00:05:07,440 --> 00:05:11,520
only like 25 is a common code in around

00:05:10,560 --> 00:05:14,240
00:05:11,520 --> 00:05:15,280
is arm implementation so makes total

00:05:14,240 --> 00:05:17,360
total sense to

00:05:15,280 --> 00:05:18,800
minimize the code base that we want to

00:05:17,360 --> 00:05:20,800
certify that's what we

00:05:18,800 --> 00:05:22,479
also plan to do comparing to what

00:05:20,800 --> 00:05:26,639
community does an average

00:05:22,479 --> 00:05:29,600
average here uh of uh zen contributions

00:05:26,639 --> 00:05:31,360
is the safety certification like it was

00:05:29,600 --> 00:05:34,400
done before it's it's not it's not

00:05:31,360 --> 00:05:35,919
not too bad like we had 30 many years i

00:05:34,400 --> 00:05:40,080
think it was 19

00:05:35,919 --> 00:05:41,120
and 2019 uh a year and it is much higher

00:05:40,080 --> 00:05:43,120
than can be

00:05:41,120 --> 00:05:44,720
needed for minimal zandy so if you just

00:05:43,120 --> 00:05:47,039
throw out the x86

00:05:44,720 --> 00:05:47,840
keep only common and arm code we get

00:05:47,039 --> 00:05:52,880
around

00:05:47,840 --> 00:05:55,199
50 000 lines of code that is that is

00:05:52,880 --> 00:05:56,319
with the five many years uh that's a

00:05:55,199 --> 00:05:59,440
month one year

00:05:56,319 --> 00:06:02,000
estimation but if we even if you do that

00:05:59,440 --> 00:06:03,520
sorry if you even if you do that can

00:06:02,000 --> 00:06:06,000
functional safety be

00:06:03,520 --> 00:06:06,639
maintained in in somewhat adopted foss

00:06:06,000 --> 00:06:09,600
model

00:06:06,639 --> 00:06:11,440
to understand that and go into that we

00:06:09,600 --> 00:06:14,400
created a special interest group

00:06:11,440 --> 00:06:16,400
in zen project um we understood it's

00:06:14,400 --> 00:06:17,120
it's a going to be a long-term community

00:06:16,400 --> 00:06:21,039
work

00:06:17,120 --> 00:06:21,600
so with leaders for this work being

00:06:21,039 --> 00:06:24,400
armed

00:06:21,600 --> 00:06:25,440
e-palm and xilinx like where three of us

00:06:24,400 --> 00:06:27,360
are coming from

00:06:25,440 --> 00:06:29,759
we have assessors on board like mira

00:06:27,360 --> 00:06:32,400
tooth and exita so they help us and some

00:06:29,759 --> 00:06:35,199
assessors from arm as well

00:06:32,400 --> 00:06:36,720
then project leadership team helps us uh

00:06:35,199 --> 00:06:37,919
and the gate steward from linux

00:06:36,720 --> 00:06:39,840
foundation

00:06:37,919 --> 00:06:41,520
works with that was as observer because

00:06:39,840 --> 00:06:42,880
there are other linux foundation

00:06:41,520 --> 00:06:44,639
products going on that are

00:06:42,880 --> 00:06:46,080
related to functional safety and of

00:06:44,639 --> 00:06:47,840
course we do have some industry

00:06:46,080 --> 00:06:50,000
representatives

00:06:47,840 --> 00:06:52,720
who would what would like to use them

00:06:50,000 --> 00:06:55,039
for the safety applications

00:06:52,720 --> 00:06:56,080
so we've made some high-level agreements

00:06:55,039 --> 00:06:57,919
so there must be

00:06:56,080 --> 00:07:00,319
a very clear benefit for the

00:06:57,919 --> 00:07:02,319
non-functional safety community of san

00:07:00,319 --> 00:07:04,160
so that's why we need to have some split

00:07:02,319 --> 00:07:05,039
development model with an open source

00:07:04,160 --> 00:07:07,199
and close

00:07:05,039 --> 00:07:09,840
and close part i'll talk about that

00:07:07,199 --> 00:07:11,840
later there shall be no uncertainty

00:07:09,840 --> 00:07:13,680
on why some changes are needed like for

00:07:11,840 --> 00:07:15,039
example misra changes

00:07:13,680 --> 00:07:16,880
why they're pushed and why they're

00:07:15,039 --> 00:07:17,840
needed and how the community can benefit

00:07:16,880 --> 00:07:21,440
from that

00:07:17,840 --> 00:07:24,319
we don't want to change a lot the

00:07:21,440 --> 00:07:25,680
or at all the open development workflow

00:07:24,319 --> 00:07:27,280
and everything should be

00:07:25,680 --> 00:07:29,520
shall remain good-centric and there

00:07:27,280 --> 00:07:31,520
shall be no fork or parallel universe

00:07:29,520 --> 00:07:34,080
and resource on the source part

00:07:31,520 --> 00:07:35,520
anything that we do for safety shall be

00:07:34,080 --> 00:07:37,039
done only if there is an agreement

00:07:35,520 --> 00:07:39,199
to implement all the changes in the

00:07:37,039 --> 00:07:41,440
common code so we cannot do it ourself

00:07:39,199 --> 00:07:42,720
there must be a community alignment if

00:07:41,440 --> 00:07:46,000
we want to proceed with

00:07:42,720 --> 00:07:46,800
any kind of changes so as you probably

00:07:46,000 --> 00:07:48,879
can imagine

00:07:46,800 --> 00:07:50,560
there must be an accountability for the

00:07:48,879 --> 00:07:52,000
for the safety case so we agree that

00:07:50,560 --> 00:07:53,199
accountability will not go for a

00:07:52,000 --> 00:07:55,120
community community cannot be

00:07:53,199 --> 00:07:56,879
accountable for the

00:07:55,120 --> 00:07:58,879
safety compliance of the project so

00:07:56,879 --> 00:08:00,800
there must be commercial vendors

00:07:58,879 --> 00:08:02,080
so that's why we probably may have a

00:08:00,800 --> 00:08:04,240
split development

00:08:02,080 --> 00:08:05,199
model when commercial vendors use a

00:08:04,240 --> 00:08:08,240
baseline

00:08:05,199 --> 00:08:11,680
to to sell that act as a

00:08:08,240 --> 00:08:12,240
accountable part and there must be maybe

00:08:11,680 --> 00:08:13,919
some

00:08:12,240 --> 00:08:15,440
reference text from different companies

00:08:13,919 --> 00:08:18,319
for safety use cases

00:08:15,440 --> 00:08:19,919
we partner with other safety projects in

00:08:18,319 --> 00:08:21,919
linux foundation for example with

00:08:19,919 --> 00:08:25,520
elizabeth

00:08:21,919 --> 00:08:28,240
we look through the processes and so on

00:08:25,520 --> 00:08:30,319
and with the fear we that we'll cover

00:08:28,240 --> 00:08:33,519
later on we talk about documentation

00:08:30,319 --> 00:08:35,519
and how to uh establish a whole process

00:08:33,519 --> 00:08:37,120
for the for the uh for the safety and

00:08:35,519 --> 00:08:40,080
open source

00:08:37,120 --> 00:08:40,479
and we define the forex scope we decided

00:08:40,080 --> 00:08:43,839
to

00:08:40,479 --> 00:08:45,600
now proceed with the uh isotope safety

00:08:43,839 --> 00:08:46,080
element out of context so that means

00:08:45,600 --> 00:08:48,320
that

00:08:46,080 --> 00:08:49,920
zen itself is not a product but can be

00:08:48,320 --> 00:08:53,440
applied as a part of a

00:08:49,920 --> 00:08:55,440
some safety regulated product and

00:08:53,440 --> 00:08:57,120
the level of safety we plan to address

00:08:55,440 --> 00:08:58,640
is acelbe it's not

00:08:57,120 --> 00:09:00,160
not the lowest but not the highest of

00:08:58,640 --> 00:09:03,200
course level and

00:09:00,160 --> 00:09:04,160
uh our work scope is to identify and

00:09:03,200 --> 00:09:06,800
eliminate gaps

00:09:04,160 --> 00:09:08,000
in requirements and documentation in

00:09:06,800 --> 00:09:10,000
validation verification

00:09:08,000 --> 00:09:11,760
or testing otherwise establish

00:09:10,000 --> 00:09:13,920
infrastructure for maintenance of

00:09:11,760 --> 00:09:16,320
documenting and trade tracing

00:09:13,920 --> 00:09:16,959
and testing the documents implement full

00:09:16,320 --> 00:09:18,480
processing

00:09:16,959 --> 00:09:20,080
or let's say improve the fault

00:09:18,480 --> 00:09:22,320
processing and improve the deterministic

00:09:20,080 --> 00:09:24,080
behavior of them

00:09:22,320 --> 00:09:26,959
maybe add some defensive programming

00:09:24,080 --> 00:09:28,959
like probably applying mister and so on

00:09:26,959 --> 00:09:30,640
not everywhere to reduce culture and we

00:09:28,959 --> 00:09:32,800
will have to waste against some of the

00:09:30,640 --> 00:09:35,600
of these that are not applicable we need

00:09:32,800 --> 00:09:38,720
to support a safety certified

00:09:35,600 --> 00:09:40,880
tools like for example compiler and have

00:09:38,720 --> 00:09:42,480
safety management processes and tools in

00:09:40,880 --> 00:09:44,800
place to ensure that we

00:09:42,480 --> 00:09:45,839
we keep on with the safety process

00:09:44,800 --> 00:09:48,839
demanded by the

00:09:45,839 --> 00:09:50,240
regulations so now to requirements and

00:09:48,839 --> 00:09:52,640
documentation

00:09:50,240 --> 00:09:54,720
so a big part of the certification

00:09:52,640 --> 00:09:57,839
process is to write requirements

00:09:54,720 --> 00:09:59,519
next so how do we develop

00:09:57,839 --> 00:10:01,279
we do follow without knowing it part of

00:09:59,519 --> 00:10:02,800
the v model we start from an idea or a

00:10:01,279 --> 00:10:04,560
need this is more or less an high level

00:10:02,800 --> 00:10:06,240
requirement than we could

00:10:04,560 --> 00:10:08,079
then we push our code to a versioning

00:10:06,240 --> 00:10:10,160
system like git we have to

00:10:08,079 --> 00:10:12,079
explain it in a commit message this is a

00:10:10,160 --> 00:10:14,160
very light low-level design

00:10:12,079 --> 00:10:15,360
then we use what we did or we write some

00:10:14,160 --> 00:10:17,839
test validated

00:10:15,360 --> 00:10:19,040
all these steps are part of the v-model

00:10:17,839 --> 00:10:20,959
next

00:10:19,040 --> 00:10:22,240
the v-model is the same with some more

00:10:20,959 --> 00:10:24,320
steps first

00:10:22,240 --> 00:10:25,920
is high-level specification using only

00:10:24,320 --> 00:10:27,120
those someone should be able to develop

00:10:25,920 --> 00:10:29,920
acceptance tests

00:10:27,120 --> 00:10:30,480
then the system specification which goes

00:10:29,920 --> 00:10:33,200
a bit

00:10:30,480 --> 00:10:34,079
more a bit more in details than high

00:10:33,200 --> 00:10:36,160
level design

00:10:34,079 --> 00:10:38,160
than low level design and final

00:10:36,160 --> 00:10:40,240
reporting so we have three groups

00:10:38,160 --> 00:10:42,320
the code requirements at different

00:10:40,240 --> 00:10:44,320
levels and different types of tests

00:10:42,320 --> 00:10:45,360
each of these might be done by different

00:10:44,320 --> 00:10:47,440
people from

00:10:45,360 --> 00:10:50,000
experience far more time is spent on the

00:10:47,440 --> 00:10:51,360
requirements and tests than on coding

00:10:50,000 --> 00:10:53,040
this is where the major costs of

00:10:51,360 --> 00:10:56,720
certification are

00:10:53,040 --> 00:10:58,399
so what is a requirement a requirement

00:10:56,720 --> 00:11:00,240
is something describing a single

00:10:58,399 --> 00:11:02,959
function or feature that is

00:11:00,240 --> 00:11:03,760
testable measurable and expressed in a

00:11:02,959 --> 00:11:06,000
clear way

00:11:03,760 --> 00:11:07,680
let's see some examples so then shall

00:11:06,000 --> 00:11:08,320
never crash it's very clear not

00:11:07,680 --> 00:11:11,279
ambiguous

00:11:08,320 --> 00:11:12,959
but it is impossible to test xen charge

00:11:11,279 --> 00:11:16,160
support up to 64 cores

00:11:12,959 --> 00:11:18,959
easy to test that 1 2 and up to 64 cores

00:11:16,160 --> 00:11:21,200
are supported but not 65 way too

00:11:18,959 --> 00:11:22,800
expensive is clear and not obvious

00:11:21,200 --> 00:11:24,720
the way of expression though is not

00:11:22,800 --> 00:11:25,440
really documentation but the information

00:11:24,720 --> 00:11:28,560
is there

00:11:25,440 --> 00:11:31,200
exams support up to 64 card because is

00:11:28,560 --> 00:11:33,279
what you would expect as documentation

00:11:31,200 --> 00:11:34,240
but if we choose some clear wording we

00:11:33,279 --> 00:11:39,120
could in fact

00:11:34,240 --> 00:11:39,120
write a requirement this way next

00:11:39,279 --> 00:11:43,279
one of the big part of the certification

00:11:41,279 --> 00:11:45,040
is linking the goal is to be able to go

00:11:43,279 --> 00:11:45,839
from one element to all other elements

00:11:45,040 --> 00:11:47,200
related to it

00:11:45,839 --> 00:11:49,040
from the code to the test from a

00:11:47,200 --> 00:11:51,120
requirement to the code or the design

00:11:49,040 --> 00:11:53,360
it's it is a very complex and time

00:11:51,120 --> 00:11:55,839
consuming task to create those links

00:11:53,360 --> 00:11:57,839
the next work is very dense as not all

00:11:55,839 --> 00:11:58,800
relations are one to one but many times

00:11:57,839 --> 00:12:01,040
want to end

00:11:58,800 --> 00:12:02,880
this is also the first one checked by

00:12:01,040 --> 00:12:03,920
any certification authority they take

00:12:02,880 --> 00:12:06,000
examples

00:12:03,920 --> 00:12:07,600
and check the root and the consistency

00:12:06,000 --> 00:12:09,040
they are very good to know where to eat

00:12:07,600 --> 00:12:11,440
to find issues

00:12:09,040 --> 00:12:12,160
next so where to put requirements

00:12:11,440 --> 00:12:14,079
usually you

00:12:12,160 --> 00:12:16,240
use a proprietary software like doors

00:12:14,079 --> 00:12:19,440
from ibm to store them it's a kind of

00:12:16,240 --> 00:12:21,279
3d excel tables with links

00:12:19,440 --> 00:12:23,120
those kind of product would be very hard

00:12:21,279 --> 00:12:24,160
to use in an open source project they

00:12:23,120 --> 00:12:26,240
are expensive

00:12:24,160 --> 00:12:27,760
they require some strong knowledge and

00:12:26,240 --> 00:12:29,200
developers would not maintain the

00:12:27,760 --> 00:12:31,440
database when developing

00:12:29,200 --> 00:12:33,040
so we took a strategy compatible with

00:12:31,440 --> 00:12:34,720
git and mailing list instead

00:12:33,040 --> 00:12:36,160
high level requirements will be stored

00:12:34,720 --> 00:12:37,920
in a text file or table

00:12:36,160 --> 00:12:39,920
and the rest will be stored directly in

00:12:37,920 --> 00:12:41,760
the code we will use the oxygen to

00:12:39,920 --> 00:12:44,800
extract the requirements this will allow

00:12:41,760 --> 00:12:47,120
easier maintenance by developers

00:12:44,800 --> 00:12:47,120
next

00:12:47,920 --> 00:12:52,720
so part of our work is done with the

00:12:52,000 --> 00:12:54,480
fair project

00:12:52,720 --> 00:12:56,480
so the fear project has already done

00:12:54,480 --> 00:12:58,079
some investigation and did a proof of

00:12:56,480 --> 00:12:59,920
concept using the oxygen

00:12:58,079 --> 00:13:01,519
we would like to use the same strategy

00:12:59,920 --> 00:13:02,880
and tools on this project we have

00:13:01,519 --> 00:13:04,880
regular sync with

00:13:02,880 --> 00:13:06,800
the security we will move exam

00:13:04,880 --> 00:13:08,079
documentation to used oxygen this is an

00:13:06,800 --> 00:13:09,279
opportunity to improve exam

00:13:08,079 --> 00:13:11,440
documentation

00:13:09,279 --> 00:13:12,320
and is a preparation for the requirement

00:13:11,440 --> 00:13:14,880
extraction

00:13:12,320 --> 00:13:15,600
and we also started to write some some

00:13:14,880 --> 00:13:18,000
requirements

00:13:15,600 --> 00:13:20,320
to agree on the terminology and also to

00:13:18,000 --> 00:13:23,920
have some examples to develop the

00:13:20,320 --> 00:13:26,959
oxygen toolings okay finally

00:13:23,920 --> 00:13:29,360
yeah and misra c mr c is a

00:13:26,959 --> 00:13:30,000
is a set of guidelines to write safe

00:13:29,360 --> 00:13:33,519
software

00:13:30,000 --> 00:13:35,680
in the c language there are it's divided

00:13:33,519 --> 00:13:38,000
into rules and directives

00:13:35,680 --> 00:13:39,680
uh rules are things that can be checked

00:13:38,000 --> 00:13:42,240
just looking at the source code

00:13:39,680 --> 00:13:44,079
while directives are a bit more up to

00:13:42,240 --> 00:13:46,839
interpretation and they involved also

00:13:44,079 --> 00:13:48,000
analysis of documentation and the whole

00:13:46,839 --> 00:13:49,680
process

00:13:48,000 --> 00:13:51,920
rules and directive together they are

00:13:49,680 --> 00:13:54,240
divided into three groups that are

00:13:51,920 --> 00:13:55,519
three categories mandatory required and

00:13:54,240 --> 00:13:58,160
advisory

00:13:55,519 --> 00:14:00,079
mandatory are rules and directives that

00:13:58,160 --> 00:14:02,320
have to be complied with

00:14:00,079 --> 00:14:03,279
required a router directive that has to

00:14:02,320 --> 00:14:06,560
be complied with

00:14:03,279 --> 00:14:08,480
unless there is a deviation advisory are

00:14:06,560 --> 00:14:10,160
less formal and they're more good

00:14:08,480 --> 00:14:13,360
practice rules

00:14:10,160 --> 00:14:16,399
so what is a deviation

00:14:13,360 --> 00:14:17,920
normally a misracy rule is written this

00:14:16,399 --> 00:14:20,240
way so they explain an issue

00:14:17,920 --> 00:14:23,519
a problem and then they explain also how

00:14:20,240 --> 00:14:25,360
to address it by writing safe software

00:14:23,519 --> 00:14:26,720
a deviation could be something like an

00:14:25,360 --> 00:14:28,480
explanation on why

00:14:26,720 --> 00:14:31,199
on your software the problem cannot

00:14:28,480 --> 00:14:33,600
occur due to the nature of the software

00:14:31,199 --> 00:14:35,279
or an explanation on why you you use a

00:14:33,600 --> 00:14:36,399
different solution in your software

00:14:35,279 --> 00:14:38,720
because maybe

00:14:36,399 --> 00:14:40,399
due to the specific details there is a

00:14:38,720 --> 00:14:43,279
better solution

00:14:40,399 --> 00:14:44,959
but they are not common and but most

00:14:43,279 --> 00:14:46,880
projects do in safety there have at

00:14:44,959 --> 00:14:49,120
least one or two

00:14:46,880 --> 00:14:51,199
because rules and directives are so many

00:14:49,120 --> 00:14:51,600
it's difficult to analyze them by hand

00:14:51,199 --> 00:14:54,000
or

00:14:51,600 --> 00:14:55,040
you know just with your own pair of eyes

00:14:54,000 --> 00:14:57,360
and that's why

00:14:55,040 --> 00:14:59,279
most projects use a static code analyzer

00:14:57,360 --> 00:15:01,120
it's very important to integrate into

00:14:59,279 --> 00:15:05,680
your own ci loop and your own

00:15:01,120 --> 00:15:05,680
build and test and commit infrastructure

00:15:05,920 --> 00:15:11,839
in then we have already run a stadium

00:15:08,880 --> 00:15:14,560
feasibility of doing miseracy compliance

00:15:11,839 --> 00:15:16,079
the latest one was done by resyltec and

00:15:14,560 --> 00:15:17,440
the result is that is definitely

00:15:16,079 --> 00:15:19,760
feasible

00:15:17,440 --> 00:15:21,680
and if you look at the diagrams below

00:15:19,760 --> 00:15:23,360
all the top violation actually the four

00:15:21,680 --> 00:15:25,680
or five top violations

00:15:23,360 --> 00:15:26,560
are all false positives so if you take

00:15:25,680 --> 00:15:28,079
those out

00:15:26,560 --> 00:15:29,600
the remaining violations are actually

00:15:28,079 --> 00:15:32,160
not that many uh

00:15:29,600 --> 00:15:35,440
so it's it's not that far from miserable

00:15:32,160 --> 00:15:38,320
c compatibility already the code base

00:15:35,440 --> 00:15:38,720
so what we are doing now is to look at

00:15:38,320 --> 00:15:40,480
uh

00:15:38,720 --> 00:15:42,399
the set of rules and directives that

00:15:40,480 --> 00:15:44,720
make sense for them

00:15:42,399 --> 00:15:46,800
and for each of them figure out what is

00:15:44,720 --> 00:15:48,959
the best possible way to check

00:15:46,800 --> 00:15:50,399
them automatically using a misracist

00:15:48,959 --> 00:15:53,120
checker it could be

00:15:50,399 --> 00:15:55,279
a one-minute misreset checker or the

00:15:53,120 --> 00:15:57,360
other or it could even be gcc

00:15:55,279 --> 00:15:59,519
and most importantly we are looking at

00:15:57,360 --> 00:16:00,160
uh integrating these miso seed checkers

00:15:59,519 --> 00:16:02,240
into the

00:16:00,160 --> 00:16:03,279
exam project processes so that they run

00:16:02,240 --> 00:16:05,920
automatically

00:16:03,279 --> 00:16:07,600
before commit ideally as part of our

00:16:05,920 --> 00:16:10,880
existing gitlab ci

00:16:07,600 --> 00:16:12,880
infrastructure i wanted to show you a

00:16:10,880 --> 00:16:14,320
couple of examples to give you an idea

00:16:12,880 --> 00:16:17,440
on what the miser c

00:16:14,320 --> 00:16:20,480
rules look like on the example you see

00:16:17,440 --> 00:16:22,320
one rule and an example that says you

00:16:20,480 --> 00:16:24,959
basically need to have uh

00:16:22,320 --> 00:16:26,560
brackets around single like single line

00:16:24,959 --> 00:16:29,440
statements in your if and

00:16:26,560 --> 00:16:31,040
else uh statements and the reason is if

00:16:29,440 --> 00:16:32,720
you look at the example flag one

00:16:31,040 --> 00:16:35,839
and flag two action and one in action

00:16:32,720 --> 00:16:39,440
two there is that is confusing

00:16:35,839 --> 00:16:40,399
if you go back to the slides so the real

00:16:39,440 --> 00:16:42,560
problem is

00:16:40,399 --> 00:16:45,199
sometimes without brackets indentation

00:16:42,560 --> 00:16:47,440
can actually hide bugs

00:16:45,199 --> 00:16:49,279
it's very easy to miss so miserable c is

00:16:47,440 --> 00:16:51,040
telling us to always have brackets

00:16:49,279 --> 00:16:52,320
around single line statements which is a

00:16:51,040 --> 00:16:54,880
good suggestion

00:16:52,320 --> 00:16:55,360
now in zen we have an existing codebase

00:16:54,880 --> 00:16:58,240
and we have

00:16:55,360 --> 00:16:59,839
quite a few examples of the of single

00:16:58,240 --> 00:17:01,759
line statement with our brackets

00:16:59,839 --> 00:17:03,680
so one option is to add the bracket

00:17:01,759 --> 00:17:06,400
maybe another option to explore

00:17:03,680 --> 00:17:07,919
is to use gcc now a modern version of

00:17:06,400 --> 00:17:10,799
gcc you can actually check

00:17:07,919 --> 00:17:12,160
for these misleading situations with the

00:17:10,799 --> 00:17:15,839
w

00:17:12,160 --> 00:17:18,160
capital w misleading indentation warning

00:17:15,839 --> 00:17:19,600
so then my actually address exactly the

00:17:18,160 --> 00:17:22,880
situation mr c

00:17:19,600 --> 00:17:25,679
is worried about a different example uh

00:17:22,880 --> 00:17:26,480
is the one we see here uh on on in the

00:17:25,679 --> 00:17:29,600
browser

00:17:26,480 --> 00:17:32,400
is about id length so older

00:17:29,600 --> 00:17:33,600
compilers will truncate ids variable

00:17:32,400 --> 00:17:36,960
names or

00:17:33,600 --> 00:17:38,799
function names and what you would

00:17:36,960 --> 00:17:40,960
what to end up is you will end up

00:17:38,799 --> 00:17:42,480
calling the wrong function or using the

00:17:40,960 --> 00:17:45,520
wrong variable by mistake

00:17:42,480 --> 00:17:47,280
so obviously this is pretty bad so this

00:17:45,520 --> 00:17:49,679
is definitely a serious issue

00:17:47,280 --> 00:17:52,320
so one way going back to the slides to

00:17:49,679 --> 00:17:53,120
uh addresses is to mandate c99

00:17:52,320 --> 00:17:55,760
compliance

00:17:53,120 --> 00:17:58,080
uh c99 mandates that the compiler needs

00:17:55,760 --> 00:17:59,039
to support at least 31 characters to be

00:17:58,080 --> 00:18:02,080
significant

00:17:59,039 --> 00:18:04,960
so if you use a c99 compiler

00:18:02,080 --> 00:18:05,679
and all your ids are not longer than 31

00:18:04,960 --> 00:18:08,320
characters

00:18:05,679 --> 00:18:08,320
you are good

00:18:10,160 --> 00:18:14,720
a few words for certifiable zen

00:18:11,840 --> 00:18:16,640
configurations um of course then itself

00:18:14,720 --> 00:18:17,760
relies on some other tools beyond then

00:18:16,640 --> 00:18:20,320
traditionally

00:18:17,760 --> 00:18:21,679
when zen boots it has a domain zero that

00:18:20,320 --> 00:18:23,760
boosts other domains

00:18:21,679 --> 00:18:25,440
and dom zero is built on linux kernel it

00:18:23,760 --> 00:18:27,200
contains all of the hardware and power

00:18:25,440 --> 00:18:28,080
visualized back-ends and other domains

00:18:27,200 --> 00:18:30,320
use these

00:18:28,080 --> 00:18:31,200
back-ends to talk to the cargo driver so

00:18:30,320 --> 00:18:33,120
basically

00:18:31,200 --> 00:18:34,799
first of all it's very hard to certify

00:18:33,120 --> 00:18:37,200
if if possible at all

00:18:34,799 --> 00:18:38,880
and because zom0 is a single point of

00:18:37,200 --> 00:18:41,200
table for both hardware

00:18:38,880 --> 00:18:42,080
and linux itself is i mean the kernel

00:18:41,200 --> 00:18:44,880
itself is

00:18:42,080 --> 00:18:46,320
pretty hard to certify again if possible

00:18:44,880 --> 00:18:47,679
so with that one of the approach to

00:18:46,320 --> 00:18:50,960
solve that is to put

00:18:47,679 --> 00:18:52,880
rtos into the uh domain 0k

00:18:50,960 --> 00:18:54,240
like so-called thin domain 0 and remove

00:18:52,880 --> 00:18:56,240
all the all of the hardware except

00:18:54,240 --> 00:18:57,360
probably some force related to other

00:18:56,240 --> 00:19:00,160
domains so when

00:18:57,360 --> 00:19:01,039
uh domains are crashing or restarting or

00:19:00,160 --> 00:19:04,080
whatsoever

00:19:01,039 --> 00:19:05,760
they do not break each other and dome

00:19:04,080 --> 00:19:07,840
zero is very thin it has

00:19:05,760 --> 00:19:09,440
potentially can have a certifiable

00:19:07,840 --> 00:19:10,160
real-time rating system managing

00:19:09,440 --> 00:19:11,520
everything

00:19:10,160 --> 00:19:14,320
everything else so it's like one

00:19:11,520 --> 00:19:16,320
approach another approach is to use dot

00:19:14,320 --> 00:19:17,840
zero less the zero leds was created to

00:19:16,320 --> 00:19:20,160
shorten boot times

00:19:17,840 --> 00:19:22,080
and the idea is to load all the amps i

00:19:20,160 --> 00:19:23,840
mean more than one vm at least at boot

00:19:22,080 --> 00:19:26,559
time directly from the bootloader

00:19:23,840 --> 00:19:27,440
and then to put them in parallel that

00:19:26,559 --> 00:19:29,760
means

00:19:27,440 --> 00:19:31,440
all i mean other other domains like the

00:19:29,760 --> 00:19:33,280
mu one and two in the picture

00:19:31,440 --> 00:19:34,960
don't actually need them zero to start

00:19:33,280 --> 00:19:37,200
at all so from zero is

00:19:34,960 --> 00:19:38,799
optional but if it's optional you may be

00:19:37,200 --> 00:19:41,360
taking it take it away

00:19:38,799 --> 00:19:42,559
so nodum zero means there is no dom zero

00:19:41,360 --> 00:19:45,120
to safety certify

00:19:42,559 --> 00:19:46,720
so also born for speeding up the boot

00:19:45,120 --> 00:19:48,320
time and doing parallel boot

00:19:46,720 --> 00:19:50,960
is actually a technique that can be used

00:19:48,320 --> 00:19:54,000
to get rid of them zero

00:19:50,960 --> 00:19:54,960
yeah so um another thing is actually

00:19:54,000 --> 00:19:58,160
determinism

00:19:54,960 --> 00:20:00,240
um in zen there is at least one arm

00:19:58,160 --> 00:20:01,919
that's not true for x86 but at least

00:20:00,240 --> 00:20:03,520
then on arm there are some hyper calls

00:20:01,919 --> 00:20:05,360
that are very long running

00:20:03,520 --> 00:20:06,559
like for memory partitioning for example

00:20:05,360 --> 00:20:08,159
latency can be uh

00:20:06,559 --> 00:20:10,320
up to two milliseconds because hyper

00:20:08,159 --> 00:20:13,120
calls are non-interruptible

00:20:10,320 --> 00:20:14,159
and we've we did a poc using the fear

00:20:13,120 --> 00:20:16,640
with a very

00:20:14,159 --> 00:20:18,799
very basic uh real-time scheduler

00:20:16,640 --> 00:20:21,280
configuration that's publicly available

00:20:18,799 --> 00:20:24,240
in mailing list and with uh with the

00:20:21,280 --> 00:20:25,440
implementing uh preemption we've managed

00:20:24,240 --> 00:20:28,240
to get the

00:20:25,440 --> 00:20:29,280
uh 600 nanoseconds that on renaissance

00:20:28,240 --> 00:20:32,159
our card

00:20:29,280 --> 00:20:32,960
platform 600 nanoseconds deviation and

00:20:32,159 --> 00:20:36,240
mean

00:20:32,960 --> 00:20:39,440
uh interrupt time uh

00:20:36,240 --> 00:20:41,039
up to eight microseconds so that's just

00:20:39,440 --> 00:20:43,440
the research that we've done so

00:20:41,039 --> 00:20:45,840
in in future what we need to do is work

00:20:43,440 --> 00:20:47,840
on latency of the hyper calls

00:20:45,840 --> 00:20:49,600
probably by introducing preemption for

00:20:47,840 --> 00:20:52,640
generic high proposal or

00:20:49,600 --> 00:20:53,520
moving them into separate vm that will

00:20:52,640 --> 00:20:56,960
that will take the

00:20:53,520 --> 00:21:00,640
take care of the um zen's

00:20:56,960 --> 00:21:02,000
internal housekeeping another source of

00:21:00,640 --> 00:21:05,039
potential interference

00:21:02,000 --> 00:21:05,840
uh for interrupt latency and real-time

00:21:05,039 --> 00:21:08,640
workloads

00:21:05,840 --> 00:21:09,600
is a shared shoe cache so what happens

00:21:08,640 --> 00:21:11,679
is thanks to

00:21:09,600 --> 00:21:14,880
i mean due to the share that you cash

00:21:11,679 --> 00:21:17,520
memory accesses can be a lot slower

00:21:14,880 --> 00:21:19,200
than than usual and even causing

00:21:17,520 --> 00:21:20,080
misdeadline for your real-time

00:21:19,200 --> 00:21:22,559
application

00:21:20,080 --> 00:21:24,559
and that solution is cache coloring that

00:21:22,559 --> 00:21:25,440
thanks to a smart allocation technique

00:21:24,559 --> 00:21:27,440
of memory

00:21:25,440 --> 00:21:29,120
uh in the hypervisor you end up

00:21:27,440 --> 00:21:30,240
splitting the actual cache into

00:21:29,120 --> 00:21:32,000
different subsets

00:21:30,240 --> 00:21:33,520
and giving a different subset of cache

00:21:32,000 --> 00:21:35,760
lines to different vms

00:21:33,520 --> 00:21:36,640
that way there can be no cache

00:21:35,760 --> 00:21:38,320
interference

00:21:36,640 --> 00:21:41,360
because there are no shared cache lines

00:21:38,320 --> 00:21:43,840
anymore and the result is you have a lot

00:21:41,360 --> 00:21:45,360
lower rq latency more importantly you

00:21:43,840 --> 00:21:47,520
have a lot more deterministic

00:21:45,360 --> 00:21:48,080
accu-latency very little variations in

00:21:47,520 --> 00:21:50,080
times

00:21:48,080 --> 00:21:52,960
and also a lot more deterministic

00:21:50,080 --> 00:21:54,720
execution times in general

00:21:52,960 --> 00:21:56,799
and this is the end of our presentation

00:21:54,720 --> 00:21:59,840
so thank you for attending and let us

00:21:56,799 --> 00:21:59,840
know if you have any questions

00:22:05,280 --> 00:22:08,960
so stefano there was one question

00:22:07,039 --> 00:22:11,120
related to the tools we are currently

00:22:08,960 --> 00:22:13,679
using for mr checking

00:22:11,120 --> 00:22:16,240
i see do the compiler used to in the

00:22:13,679 --> 00:22:18,159
project also have to be safety certified

00:22:16,240 --> 00:22:19,360
i answer to that in fact they do not

00:22:18,159 --> 00:22:21,039
always need that depends on the

00:22:19,360 --> 00:22:22,640
certification level and standard that

00:22:21,039 --> 00:22:26,000
you want to use

00:22:22,640 --> 00:22:27,440
but in the ies level yes you would need

00:22:26,000 --> 00:22:29,679
a certified compiler

00:22:27,440 --> 00:22:31,360
but right now yeah we are doing some

00:22:29,679 --> 00:22:31,919
tests with arm certified compiler for

00:22:31,360 --> 00:22:34,159
example

00:22:31,919 --> 00:22:34,960
certified compiler based on clang and we

00:22:34,159 --> 00:22:38,000
do support

00:22:34,960 --> 00:22:39,200
compiling that it's not yet upstream but

00:22:38,000 --> 00:22:42,480
it is possible

00:22:39,200 --> 00:22:45,200
there are some tweaks needed yeah but we

00:22:42,480 --> 00:22:45,200
are working on it

00:22:45,280 --> 00:22:49,200
and that means that checkers there is a

00:22:47,760 --> 00:22:51,600
number that we are looking at

00:22:49,200 --> 00:22:55,120
uh so there are a number of we are

00:22:51,600 --> 00:22:56,960
collaborating some of these companies uh

00:22:55,120 --> 00:22:58,480
among the proprietary there are at least

00:22:56,960 --> 00:23:01,200
alpha dots and that we

00:22:58,480 --> 00:23:03,760
we regularly check uh there are also a

00:23:01,200 --> 00:23:07,840
couple that are open source like the

00:23:03,760 --> 00:23:09,919
cpp check is an open source com checker

00:23:07,840 --> 00:23:12,000
and gcc itself has a lot of check

00:23:09,919 --> 00:23:12,880
nowadays that can be used for some of

00:23:12,000 --> 00:23:16,159
the rules

00:23:12,880 --> 00:23:16,159
also it's not obviously

00:23:17,360 --> 00:23:20,799
regarding the oxygen so we are working

00:23:19,280 --> 00:23:22,240
on this with your project there is

00:23:20,799 --> 00:23:25,120
nothing upstream yes

00:23:22,240 --> 00:23:26,960
yet um there should be some things

00:23:25,120 --> 00:23:28,720
coming in the next month

00:23:26,960 --> 00:23:31,919
uh but yeah we have some proof of

00:23:28,720 --> 00:23:34,960
concept and the zephyr project has some

00:23:31,919 --> 00:23:38,880
evolved proof of concept to link

00:23:34,960 --> 00:23:40,960
tests to requirements

00:23:38,880 --> 00:23:42,559
i can address the topic of rtds we

00:23:40,960 --> 00:23:45,360
actually the test that

00:23:42,559 --> 00:23:47,600
we are doing on preemption and

00:23:45,360 --> 00:23:48,640
everything that is based on using rtds

00:23:47,600 --> 00:23:50,559
scheduler

00:23:48,640 --> 00:23:51,760
it is marked as experimental in the code

00:23:50,559 --> 00:23:55,120
base indeed

00:23:51,760 --> 00:23:55,679
uh but you know just polishing that and

00:23:55,120 --> 00:23:58,559
uh

00:23:55,679 --> 00:23:59,760
ensuring uh time proper time accounting

00:23:58,559 --> 00:24:01,520
and uh

00:23:59,760 --> 00:24:03,440
eliminating all of the gaps like like i

00:24:01,520 --> 00:24:06,640
mentioned with the hyper calls

00:24:03,440 --> 00:24:08,960
would would go into into like supported

00:24:06,640 --> 00:24:11,840
for for the rfds as well so yeah that's

00:24:08,960 --> 00:24:11,840
that's being worked on

00:24:12,159 --> 00:24:15,440
and yeah to to your point we actually

00:24:14,640 --> 00:24:17,679
targeting

00:24:15,440 --> 00:24:18,640
mixed criticality systems exactly that's

00:24:17,679 --> 00:24:21,919
the right

00:24:18,640 --> 00:24:25,360
why we need that yeah yeah i

00:24:21,919 --> 00:24:26,960
think we are out of time yeah

00:24:25,360 --> 00:24:28,720
we'd like to thank our presenters

00:24:26,960 --> 00:24:30,080
especially for their time i'm sure they

00:24:28,720 --> 00:24:31,840
would be available to continue

00:24:30,080 --> 00:24:33,279
answering any questions in the chat for

00:24:31,840 --> 00:24:35,360
a few minutes and

00:24:33,279 --> 00:24:37,919
those of you who participated and asked

00:24:35,360 --> 00:24:43,120
questions thank you very much

00:24:37,919 --> 00:24:43,120

YouTube URL: https://www.youtube.com/watch?v=a5CV9YBwmbw


