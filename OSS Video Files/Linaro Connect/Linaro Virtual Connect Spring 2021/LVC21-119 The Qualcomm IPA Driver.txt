Title: LVC21-119 The Qualcomm IPA Driver
Publication date: 2021-04-15
Playlist: Linaro Virtual Connect Spring 2021
Description: 
	The Qualcomm IPA (IP Accelerator) is a component in Qualcomm SoCs that provides wireless internet access to an application processor using a modem.  Qualcomm has a "downstream" IPA driver for Linux, but for certain upstream-based environments, downstream code is not acceptable.

There is now a driver for the IPA in the upstream Linux kernel, derived from--but now very different from--the downstream code.  What started as about 45,000 lines of code was simplified, cleaned, refactored, and evolved into the 14,000 line driver that eventually was accepted upstream.  The driver continues to undergo additional development, now supporting multiple generations of IPA hardware on three distinct SoCs.

This talk presents "the story" of the IPA upstream driver.  There will be a short overview of the role the IPA plays in this system.  followed by some discussion of the evolution of the code from its "simplified" starting point to its upstream implementation.  Other challenges were encountered along the way, and although this delayed its acceptance, it provided additional time for improvement.

The code underwent many small transformations to make it adhere to Linux coding standards and design conventions.  Beyond that, some changes had to (or could) be made simply because upstream and downstream code have different requirements.  Several examples of these will be presented.

The talk will finish with a statement on the current status and a general roadmap for the ongoing development of the upstream IPA driver.
Captions: 
	00:00:06,319 --> 00:00:11,280
uh hello

00:00:08,400 --> 00:00:13,759
my name is alex elder and i am going to

00:00:11,280 --> 00:00:14,880
be talking today about the qualcomm ipa

00:00:13,759 --> 00:00:16,240
driver

00:00:14,880 --> 00:00:18,080
i work for linaro and i've been with

00:00:16,240 --> 00:00:21,039
lenaro for about eight years

00:00:18,080 --> 00:00:22,000
and the last three years or so i've been

00:00:21,039 --> 00:00:24,800
working on this

00:00:22,000 --> 00:00:25,519
project to get the driver for the

00:00:24,800 --> 00:00:27,920
qualcomm

00:00:25,519 --> 00:00:30,240
ipa hardware accepted to the upstream

00:00:27,920 --> 00:00:32,320
linux kernel

00:00:30,240 --> 00:00:35,120
so today i'm going to talk a little bit

00:00:32,320 --> 00:00:36,640
about the that experience

00:00:35,120 --> 00:00:39,040
so i'm going to start a little bit with

00:00:36,640 --> 00:00:41,760
a brief overview of what ipa

00:00:39,040 --> 00:00:42,239
is and then a little bit of talk about

00:00:41,760 --> 00:00:44,800
what

00:00:42,239 --> 00:00:47,200
um what was required in order to get

00:00:44,800 --> 00:00:49,680
this project done

00:00:47,200 --> 00:00:51,520
at each at different stages along the

00:00:49,680 --> 00:00:52,559
way there were some different set of

00:00:51,520 --> 00:00:55,360
challenges that

00:00:52,559 --> 00:00:57,039
that i faced and so i'll talk a little

00:00:55,360 --> 00:00:58,719
bit about

00:00:57,039 --> 00:01:00,399
each of those sets of challenges at each

00:00:58,719 --> 00:01:03,039
time and then i'll

00:01:00,399 --> 00:01:04,479
um hopefully i'll present a few things

00:01:03,039 --> 00:01:05,519
that i think i've learned along the way

00:01:04,479 --> 00:01:08,159
that

00:01:05,519 --> 00:01:08,799
hopefully are good insights or things

00:01:08,159 --> 00:01:13,040
that people

00:01:08,799 --> 00:01:16,560
can that are valuable take away

00:01:13,040 --> 00:01:16,880
so two two other things i'll mention one

00:01:16,560 --> 00:01:19,920
is

00:01:16,880 --> 00:01:22,799
that um i do expect kind of a basic

00:01:19,920 --> 00:01:25,840
understanding of of what it means to get

00:01:22,799 --> 00:01:28,240
code upstream in the linux kernel

00:01:25,840 --> 00:01:29,680
if if you don't have that basic

00:01:28,240 --> 00:01:31,280
understanding i think there's some other

00:01:29,680 --> 00:01:32,799
sessions to talk a little bit more about

00:01:31,280 --> 00:01:34,960
that this week

00:01:32,799 --> 00:01:35,920
on the second thing is that i have too

00:01:34,960 --> 00:01:38,320
many slides

00:01:35,920 --> 00:01:40,000
and so i'm going to be moving through

00:01:38,320 --> 00:01:41,520
these somewhat briskly i may not

00:01:40,000 --> 00:01:43,119
have time for questions at the end but

00:01:41,520 --> 00:01:46,159
if i do i will take them

00:01:43,119 --> 00:01:47,840
otherwise i'm open to to answer any

00:01:46,159 --> 00:01:50,399
questions people have sort of separate

00:01:47,840 --> 00:01:50,399
from the talk

00:01:50,799 --> 00:01:56,880
so ipa ipa stands for the internet

00:01:54,159 --> 00:01:57,759
protocol accelerator and or ip

00:01:56,880 --> 00:02:00,079
accelerator

00:01:57,759 --> 00:02:01,680
and it's a separate it's a component

00:02:00,079 --> 00:02:05,759
within qualcomm

00:02:01,680 --> 00:02:05,759
system on a chip devices

00:02:06,079 --> 00:02:09,440
it sits between the main processor the

00:02:08,319 --> 00:02:12,560
ap

00:02:09,440 --> 00:02:15,120
and a modem um and

00:02:12,560 --> 00:02:16,720
it basically carries data between the ap

00:02:15,120 --> 00:02:19,520
and the modem

00:02:16,720 --> 00:02:23,840
and it's able to provide the ap access

00:02:19,520 --> 00:02:23,840
to cellular data networks

00:02:25,200 --> 00:02:32,319
so it um

00:02:28,400 --> 00:02:34,879
the ipa the ipa is presented to

00:02:32,319 --> 00:02:36,000
the main processor as a network device

00:02:34,879 --> 00:02:39,200
no different than

00:02:36,000 --> 00:02:41,519
like an ethernet and um

00:02:39,200 --> 00:02:43,360
and it's capable of doing some things so

00:02:41,519 --> 00:02:45,040
that the main processor doesn't have to

00:02:43,360 --> 00:02:46,720
it does check some off loads

00:02:45,040 --> 00:02:48,319
it also does a thing called packard

00:02:46,720 --> 00:02:51,599
packet aggregation

00:02:48,319 --> 00:02:53,440
in which packets received for example

00:02:51,599 --> 00:02:55,680
can be collected and then

00:02:53,440 --> 00:02:57,440
provided as a group to the ap so that it

00:02:55,680 --> 00:02:59,840
doesn't have to

00:02:57,440 --> 00:03:02,840
handle interrupts as frequently as it

00:02:59,840 --> 00:03:06,000
might otherwise have to

00:03:02,840 --> 00:03:06,879
um it's also capable of doing some more

00:03:06,000 --> 00:03:10,239
advanced

00:03:06,879 --> 00:03:11,440
um processing of of packets as they flow

00:03:10,239 --> 00:03:14,640
through the chip

00:03:11,440 --> 00:03:16,720
um they can do filtering ip filtering

00:03:14,640 --> 00:03:19,599
i've say ipa filtering on my

00:03:16,720 --> 00:03:21,920
router but i've got ipa on i mean on my

00:03:19,599 --> 00:03:24,480
slide but i've got ipa on the mind it

00:03:21,920 --> 00:03:25,120
uh it's able to do filtering and routing

00:03:24,480 --> 00:03:28,640
and also

00:03:25,120 --> 00:03:32,000
nat translation um these things

00:03:28,640 --> 00:03:35,120
are uh they're they're available

00:03:32,000 --> 00:03:38,319
by uh and supported by ipa supported by

00:03:35,120 --> 00:03:41,360
the um qualcomm software for

00:03:38,319 --> 00:03:44,000
um running ipa but the support is not

00:03:41,360 --> 00:03:44,000
upstream yet

00:03:44,239 --> 00:03:48,720
it's also well so the thing that um that

00:03:47,280 --> 00:03:52,000
these capabilities

00:03:48,720 --> 00:03:55,040
allow is that the uh the it allows

00:03:52,000 --> 00:03:55,760
um the ipa can operate completely

00:03:55,040 --> 00:03:58,560
independent

00:03:55,760 --> 00:04:00,000
of the main processors the main ap what

00:03:58,560 --> 00:04:03,439
that means is you could have for

00:04:00,000 --> 00:04:03,920
example a wi-fi hotspot implemented

00:04:03,439 --> 00:04:08,000
where

00:04:03,920 --> 00:04:10,560
your the soc is able to

00:04:08,000 --> 00:04:11,439
provide data access to the internet to

00:04:10,560 --> 00:04:14,480
the wi-fi

00:04:11,439 --> 00:04:16,160
from the cellular data network

00:04:14,480 --> 00:04:17,840
and the ap can go to sleep in that

00:04:16,160 --> 00:04:20,160
process and in the process you

00:04:17,840 --> 00:04:21,040
um you save a lot of power by not having

00:04:20,160 --> 00:04:24,720
the big

00:04:21,040 --> 00:04:26,080
high energy ap operational this also is

00:04:24,720 --> 00:04:27,600
not supported upstream

00:04:26,080 --> 00:04:30,320
um i'd love to get it supported but

00:04:27,600 --> 00:04:30,320
right now it's not

00:04:30,479 --> 00:04:34,000
so the problem um qualcomm as i

00:04:32,639 --> 00:04:36,479
mentioned has their own code that

00:04:34,000 --> 00:04:39,199
supports their hardware including ipa

00:04:36,479 --> 00:04:40,000
um it's open source code uh they call it

00:04:39,199 --> 00:04:42,080
downstream

00:04:40,000 --> 00:04:43,600
it's it's it's used internally but it's

00:04:42,080 --> 00:04:45,919
really public and it's available on the

00:04:43,600 --> 00:04:49,360
code aurora forum website

00:04:45,919 --> 00:04:49,759
um they support they use this software

00:04:49,360 --> 00:04:52,639
for

00:04:49,759 --> 00:04:54,720
um to support android android and other

00:04:52,639 --> 00:04:58,240
linux based environments

00:04:54,720 --> 00:05:01,199
windows i think is also supported

00:04:58,240 --> 00:05:01,759
but they wanted to also support chrome

00:05:01,199 --> 00:05:04,400
os

00:05:01,759 --> 00:05:05,600
and chrome os is not the same as android

00:05:04,400 --> 00:05:08,320
or others where

00:05:05,600 --> 00:05:09,280
chrome os requires their software to be

00:05:08,320 --> 00:05:11,919
actually

00:05:09,280 --> 00:05:13,440
upstream and for so for hardware drivers

00:05:11,919 --> 00:05:17,520
it needs to be in the upstream

00:05:13,440 --> 00:05:19,440
linux kernel um and so

00:05:17,520 --> 00:05:21,280
qualcomm had a problem they needed they

00:05:19,440 --> 00:05:22,720
had their downstream code but it was not

00:05:21,280 --> 00:05:23,680
in the upstream kernel and needed to get

00:05:22,720 --> 00:05:27,600
it there

00:05:23,680 --> 00:05:30,400
so um the objective was to upstream the

00:05:27,600 --> 00:05:30,400
ipa driver

00:05:31,360 --> 00:05:35,440
so early on when they learned or when

00:05:33,280 --> 00:05:38,160
they decided they wanted to do this they

00:05:35,440 --> 00:05:38,800
um they got the input from arn bergman

00:05:38,160 --> 00:05:42,320
who is the

00:05:38,800 --> 00:05:45,199
um upstream arm soc maintainer

00:05:42,320 --> 00:05:45,680
and he looked through their driver and

00:05:45,199 --> 00:05:49,759
his

00:05:45,680 --> 00:05:52,479
assessment was that it was in bat it was

00:05:49,759 --> 00:05:53,520
way too complex much too complicated to

00:05:52,479 --> 00:05:56,720
be accepted in the

00:05:53,520 --> 00:05:58,240
in this state it was in and so qualcomm

00:05:56,720 --> 00:06:02,160
responded by

00:05:58,240 --> 00:06:04,240
um initiating their own uh project to

00:06:02,160 --> 00:06:06,000
transform what they had into a much

00:06:04,240 --> 00:06:09,280
reduced functionality driver

00:06:06,000 --> 00:06:11,680
so it they did not support um filtering

00:06:09,280 --> 00:06:12,319
and routing and nat and they only

00:06:11,680 --> 00:06:14,720
supported

00:06:12,319 --> 00:06:15,840
the quote embedded network connection to

00:06:14,720 --> 00:06:18,800
the ap

00:06:15,840 --> 00:06:21,360
that was um was the requirement for

00:06:18,800 --> 00:06:24,080
using it like on a chromebook

00:06:21,360 --> 00:06:24,800
um and in the process they they started

00:06:24,080 --> 00:06:26,240
with

00:06:24,800 --> 00:06:27,520
i don't know how big it was exactly but

00:06:26,240 --> 00:06:29,120
it was over a hundred thousand lines of

00:06:27,520 --> 00:06:29,680
code and i think they reduced it down to

00:06:29,120 --> 00:06:32,639
closer

00:06:29,680 --> 00:06:34,400
like forty five thousand and so the

00:06:32,639 --> 00:06:37,120
result was ipa light

00:06:34,400 --> 00:06:38,160
and it provided the basic operational um

00:06:37,120 --> 00:06:40,800
features

00:06:38,160 --> 00:06:41,680
uh they knew it would work on their

00:06:40,800 --> 00:06:43,120
internal i mean

00:06:41,680 --> 00:06:44,880
they were able to test it with real

00:06:43,120 --> 00:06:47,600
hardware and

00:06:44,880 --> 00:06:48,720
um importantly for them it was a subset

00:06:47,600 --> 00:06:51,360
of their

00:06:48,720 --> 00:06:52,639
their downstream driver and that was

00:06:51,360 --> 00:06:56,000
important because

00:06:52,639 --> 00:06:57,039
they um they wanted they were hoping

00:06:56,000 --> 00:07:00,319
that the

00:06:57,039 --> 00:07:02,319
upstream driver would just be sort of a

00:07:00,319 --> 00:07:03,759
close relative to the downstream so that

00:07:02,319 --> 00:07:05,440
they wouldn't have wouldn't have to

00:07:03,759 --> 00:07:10,639
maintain two distinct

00:07:05,440 --> 00:07:10,639
source trees so um

00:07:10,800 --> 00:07:15,680
so their hope was then that they could

00:07:13,840 --> 00:07:17,199
just adjust their downstream code as

00:07:15,680 --> 00:07:20,479
they needed in order to

00:07:17,199 --> 00:07:22,000
get it to to be upstreamable

00:07:20,479 --> 00:07:24,800
and then once it was upstream they

00:07:22,000 --> 00:07:27,039
wanted to enhance the ipa

00:07:24,800 --> 00:07:29,759
light code back again to add back the

00:07:27,039 --> 00:07:33,599
functionality that was upstream

00:07:29,759 --> 00:07:35,680
they qualcomm was very optimistic

00:07:33,599 --> 00:07:37,759
because they really had considerably

00:07:35,680 --> 00:07:40,639
reduced the functionality and size

00:07:37,759 --> 00:07:42,720
of the downstream ipa driver in ipa

00:07:40,639 --> 00:07:44,879
light

00:07:42,720 --> 00:07:47,360
and again they hoped it would be

00:07:44,879 --> 00:07:48,000
accepted without a lot of major changes

00:07:47,360 --> 00:07:50,560
and they

00:07:48,000 --> 00:07:52,560
their time frame was really they were

00:07:50,560 --> 00:07:55,440
thinking it might be a matter of months

00:07:52,560 --> 00:07:55,440
to get it accepted

00:07:56,840 --> 00:08:02,240
um

00:07:58,160 --> 00:08:02,240
the reality was different um

00:08:02,400 --> 00:08:07,680
ipa light was not acceptable for

00:08:06,160 --> 00:08:10,800
upstream i mean it was

00:08:07,680 --> 00:08:14,000
it was considerably smaller

00:08:10,800 --> 00:08:16,000
um it was it it did include

00:08:14,000 --> 00:08:18,879
some good design it wasn't that it was

00:08:16,000 --> 00:08:21,599
bad it simply was not in a state that

00:08:18,879 --> 00:08:24,240
would be able to be accepted upstream

00:08:21,599 --> 00:08:26,000
um two things i tried to get to get

00:08:24,240 --> 00:08:28,400
across was that in order for something

00:08:26,000 --> 00:08:29,039
to get upstream number one you need

00:08:28,400 --> 00:08:31,599
someone

00:08:29,039 --> 00:08:32,880
to review the code and if it was a

00:08:31,599 --> 00:08:35,120
gigantic driver

00:08:32,880 --> 00:08:36,399
or something that had sort of a funny

00:08:35,120 --> 00:08:38,399
look to it in other words

00:08:36,399 --> 00:08:40,240
didn't really follow some of the

00:08:38,399 --> 00:08:42,399
conventions um

00:08:40,240 --> 00:08:43,839
or did some conventions or did some

00:08:42,399 --> 00:08:44,959
practices and patterns that were

00:08:43,839 --> 00:08:47,279
different from what

00:08:44,959 --> 00:08:48,399
otherwise is normal in the upstream code

00:08:47,279 --> 00:08:49,600
people won't review it

00:08:48,399 --> 00:08:51,519
and if you don't get it reviewed it

00:08:49,600 --> 00:08:52,800
won't get accepted

00:08:51,519 --> 00:08:54,080
but so number one you have to get

00:08:52,800 --> 00:08:55,040
someone to look at it and the second

00:08:54,080 --> 00:08:56,640
thing is we need to

00:08:55,040 --> 00:08:58,080
get it to be accepted and so that's

00:08:56,640 --> 00:09:00,480
another thing but that's sort of another

00:08:58,080 --> 00:09:00,480
hurdle

00:09:00,560 --> 00:09:04,959
so reducing functionality was very

00:09:02,640 --> 00:09:05,680
important the ipa light code did remove

00:09:04,959 --> 00:09:08,240
a lot of

00:09:05,680 --> 00:09:10,959
high level complexity and it did reduce

00:09:08,240 --> 00:09:10,959
the code size

00:09:11,440 --> 00:09:14,640
but the reality was that more would have

00:09:13,760 --> 00:09:16,399
to change

00:09:14,640 --> 00:09:18,080
and there were sort of two classes of

00:09:16,399 --> 00:09:19,440
change and i'm going to talk about each

00:09:18,080 --> 00:09:21,519
of each next first of all there's

00:09:19,440 --> 00:09:23,839
superficial changes

00:09:21,519 --> 00:09:25,440
um i mean there's there's a lot there

00:09:23,839 --> 00:09:26,640
were a lot of superficial problems in

00:09:25,440 --> 00:09:29,440
the code and they're little

00:09:26,640 --> 00:09:30,720
silly things like the coding style i

00:09:29,440 --> 00:09:33,120
mean some of them are more than just

00:09:30,720 --> 00:09:36,640
silly but for example large functions

00:09:33,120 --> 00:09:37,519
and um which are just you know upstream

00:09:36,640 --> 00:09:39,120
doesn't really like

00:09:37,519 --> 00:09:41,040
large functions it's better to have a

00:09:39,120 --> 00:09:44,000
small function that

00:09:41,040 --> 00:09:45,519
um encapsulates uh basic functionality

00:09:44,000 --> 00:09:47,040
some way that's easier to review and

00:09:45,519 --> 00:09:49,279
easier to understand

00:09:47,040 --> 00:09:50,399
um there were things like inconsistent

00:09:49,279 --> 00:09:52,399
indentation

00:09:50,399 --> 00:09:53,519
i might have had my tab stop set wrong

00:09:52,399 --> 00:09:57,440
but regardless

00:09:53,519 --> 00:10:00,800
it needs to be sort of it looked funny

00:09:57,440 --> 00:10:04,000
um there were very long symbol names um

00:10:00,800 --> 00:10:05,680
there were camel case symbols

00:10:04,000 --> 00:10:07,760
other things like that a bigger thing

00:10:05,680 --> 00:10:08,000
was really duplicated code there's a lot

00:10:07,760 --> 00:10:09,600
of

00:10:08,000 --> 00:10:11,120
chunks of code where it's like the same

00:10:09,600 --> 00:10:14,000
function was duplicated twice

00:10:11,120 --> 00:10:15,839
and it could have been refactored to be

00:10:14,000 --> 00:10:17,120
a single function with maybe options or

00:10:15,839 --> 00:10:20,240
parameters

00:10:17,120 --> 00:10:21,120
so that needed to be done there was dead

00:10:20,240 --> 00:10:23,279
code

00:10:21,120 --> 00:10:25,200
and i'll characterize that in two

00:10:23,279 --> 00:10:27,279
there's two types one was that when they

00:10:25,200 --> 00:10:28,000
reduced the functionality of ipa to ip

00:10:27,279 --> 00:10:30,000
lite

00:10:28,000 --> 00:10:31,440
they got rid of for example filtering

00:10:30,000 --> 00:10:33,600
routing those things

00:10:31,440 --> 00:10:36,160
and there existed some other code that

00:10:33,600 --> 00:10:37,040
was related to that but not used anymore

00:10:36,160 --> 00:10:39,600
at least not for

00:10:37,040 --> 00:10:40,640
the for ipa light so there was that kind

00:10:39,600 --> 00:10:42,000
of dead code

00:10:40,640 --> 00:10:43,760
there's another kind of dead code which

00:10:42,000 --> 00:10:47,680
related to platforms that

00:10:43,760 --> 00:10:49,440
are no longer supported and

00:10:47,680 --> 00:10:51,200
so for example an older version of the

00:10:49,440 --> 00:10:52,240
hardware is no longer even supported in

00:10:51,200 --> 00:10:54,480
the downstream

00:10:52,240 --> 00:10:56,640
but certainly for our purposes we were

00:10:54,480 --> 00:10:59,760
targeting a single platform

00:10:56,640 --> 00:11:01,519
and so it supported platforms that were

00:10:59,760 --> 00:11:03,040
either no longer supported or were not

00:11:01,519 --> 00:11:04,079
going to be supported by the upstream

00:11:03,040 --> 00:11:06,800
driver

00:11:04,079 --> 00:11:07,279
so that was also a kind of dip code and

00:11:06,800 --> 00:11:09,040
then

00:11:07,279 --> 00:11:11,040
another one i'll mention is excessive

00:11:09,040 --> 00:11:12,480
use of if def i don't remember exactly

00:11:11,040 --> 00:11:13,920
what was what was there but

00:11:12,480 --> 00:11:15,600
i know that their rift haves and if

00:11:13,920 --> 00:11:16,640
deaths are frowned upon you really want

00:11:15,600 --> 00:11:20,640
to minimize those

00:11:16,640 --> 00:11:20,959
if you can um there were design problems

00:11:20,640 --> 00:11:23,040
too

00:11:20,959 --> 00:11:24,240
not really superficial but one of them

00:11:23,040 --> 00:11:25,760
the first one here is really

00:11:24,240 --> 00:11:27,600
kind of a hardware design thing and it

00:11:25,760 --> 00:11:29,360
really is not i wasn't going to address

00:11:27,600 --> 00:11:30,880
it with the software but basically the

00:11:29,360 --> 00:11:34,320
ipa hardware

00:11:30,880 --> 00:11:37,760
has a single queue feeding the ap

00:11:34,320 --> 00:11:39,839
and um and a lot of the more modern high

00:11:37,760 --> 00:11:41,360
performance network interfaces tend to

00:11:39,839 --> 00:11:43,920
have multiple cues and they're

00:11:41,360 --> 00:11:46,240
able to do some uh improve their

00:11:43,920 --> 00:11:49,279
performance by using multiple queues and

00:11:46,240 --> 00:11:50,639
and splitting traffic across them but

00:11:49,279 --> 00:11:51,680
there are a few other things i'll

00:11:50,639 --> 00:11:54,880
mention nappy

00:11:51,680 --> 00:11:57,680
is the new new is

00:11:54,880 --> 00:11:58,959
15 years old it's the api for handling

00:11:57,680 --> 00:12:02,399
interrupts for network

00:11:58,959 --> 00:12:06,000
devices and um basically

00:12:02,399 --> 00:12:09,279
i think it was armed that no new

00:12:06,000 --> 00:12:10,000
network device driver or rather all new

00:12:09,279 --> 00:12:11,920
network device

00:12:10,000 --> 00:12:13,760
drivers should use nappy and really

00:12:11,920 --> 00:12:15,200
their nappy is just a generalization of

00:12:13,760 --> 00:12:17,920
internet handling and it really

00:12:15,200 --> 00:12:18,800
it really just should be used everywhere

00:12:17,920 --> 00:12:22,959
um

00:12:18,800 --> 00:12:25,200
they use work cues for certain things um

00:12:22,959 --> 00:12:26,720
it seemed as though sometimes there were

00:12:25,200 --> 00:12:28,000
they weren't entirely sure whether

00:12:26,720 --> 00:12:30,079
things would have to be

00:12:28,000 --> 00:12:32,079
done in interrupt context or not and so

00:12:30,079 --> 00:12:36,079
a work queue would be used

00:12:32,079 --> 00:12:37,440
um that it was that was a design

00:12:36,079 --> 00:12:39,440
problem that needed to be reworked a

00:12:37,440 --> 00:12:42,240
little bit um

00:12:39,440 --> 00:12:43,920
abusive the device tree i call it abuse

00:12:42,240 --> 00:12:47,440
but basically what they did is

00:12:43,920 --> 00:12:49,120
um they they tend to use uh device tree

00:12:47,440 --> 00:12:51,839
in their downstream code

00:12:49,120 --> 00:12:53,519
as a place to put various configuration

00:12:51,839 --> 00:12:56,959
options and i understand that

00:12:53,519 --> 00:12:59,440
that that doing that

00:12:56,959 --> 00:13:01,200
actually it's actually seems like a nice

00:12:59,440 --> 00:13:02,000
convenient way of expressing some things

00:13:01,200 --> 00:13:03,519
like that

00:13:02,000 --> 00:13:05,279
but upstream that's not acceptable

00:13:03,519 --> 00:13:06,959
upstream you really need to do

00:13:05,279 --> 00:13:09,760
just things that are harder related and

00:13:06,959 --> 00:13:11,839
even those things you should i mean

00:13:09,760 --> 00:13:14,240
it needs to be reasonable and you need

00:13:11,839 --> 00:13:16,880
to satisfy the upstream maintainer

00:13:14,240 --> 00:13:17,839
and i knew that some of the things that

00:13:16,880 --> 00:13:19,200
were there were not going to be

00:13:17,839 --> 00:13:21,839
acceptable

00:13:19,200 --> 00:13:22,880
they used iotal interface for some of

00:13:21,839 --> 00:13:24,720
their network

00:13:22,880 --> 00:13:25,920
uh control functions and that was not

00:13:24,720 --> 00:13:28,000
going to be acceptable

00:13:25,920 --> 00:13:28,959
and finally they had a hardware

00:13:28,000 --> 00:13:30,639
abstraction layer

00:13:28,959 --> 00:13:32,959
and this actually was i think a pretty

00:13:30,639 --> 00:13:36,240
good piece of technology that they have

00:13:32,959 --> 00:13:38,240
that simplified and generalized

00:13:36,240 --> 00:13:39,600
normalize the interface they use for

00:13:38,240 --> 00:13:41,120
accessing certain

00:13:39,600 --> 00:13:42,720
pieces for different versions of the

00:13:41,120 --> 00:13:46,720
hardware

00:13:42,720 --> 00:13:47,760
but um i was told by many people that

00:13:46,720 --> 00:13:50,880
people

00:13:47,760 --> 00:13:51,680
reviewers would be skeptical of of using

00:13:50,880 --> 00:13:54,160
a

00:13:51,680 --> 00:13:54,720
hardware abstraction layer so basically

00:13:54,160 --> 00:13:57,839
that

00:13:54,720 --> 00:13:59,680
had to be had to go it may be that we'll

00:13:57,839 --> 00:14:01,839
have to add it back again in order to

00:13:59,680 --> 00:14:04,560
add

00:14:01,839 --> 00:14:07,600
functionality back at some future date

00:14:04,560 --> 00:14:10,880
but we will have to see on that

00:14:07,600 --> 00:14:13,040
so the plan was um basically what

00:14:10,880 --> 00:14:15,360
what qualcomm would hope which is to

00:14:13,040 --> 00:14:18,399
start with the ipa like driver

00:14:15,360 --> 00:14:21,120
modify it iteratively and

00:14:18,399 --> 00:14:23,040
evolve it toward upstream ready and then

00:14:21,120 --> 00:14:24,959
post it for upstream review as soon as

00:14:23,040 --> 00:14:27,120
it was reasonable

00:14:24,959 --> 00:14:28,800
and i agreed to that qualcomm agreed to

00:14:27,120 --> 00:14:30,000
that i think everybody was in agreement

00:14:28,800 --> 00:14:34,639
but the only difference was

00:14:30,000 --> 00:14:38,399
that upstream ready and reasonable were

00:14:34,639 --> 00:14:38,399
were subject to interpretation so

00:14:38,959 --> 00:14:41,760
so challenges

00:14:42,399 --> 00:14:47,040
so the first phase i will talk about is

00:14:45,440 --> 00:14:47,760
when we i first started working on the

00:14:47,040 --> 00:14:49,680
driver

00:14:47,760 --> 00:14:51,040
and one of the biggest i mean it was

00:14:49,680 --> 00:14:52,880
just a practical challenge one of the

00:14:51,040 --> 00:14:54,240
biggest challenges was that the code was

00:14:52,880 --> 00:14:57,040
only available

00:14:54,240 --> 00:14:58,880
inside the qualcomm firewall and in

00:14:57,040 --> 00:15:01,519
order to access it the only way i could

00:14:58,880 --> 00:15:04,079
do so was through a windows laptop

00:15:01,519 --> 00:15:04,720
and for a linux kernel developer working

00:15:04,079 --> 00:15:06,399
through a

00:15:04,720 --> 00:15:08,399
windows laptop through a firewall is

00:15:06,399 --> 00:15:10,880
just kind of an unnatural

00:15:08,399 --> 00:15:12,639
way of doing work it's not that it

00:15:10,880 --> 00:15:16,079
wasn't possible it just made it

00:15:12,639 --> 00:15:19,199
more challenging so um

00:15:16,079 --> 00:15:21,519
the next challenge was that um

00:15:19,199 --> 00:15:23,519
there was no real at least initially

00:15:21,519 --> 00:15:26,160
there was no hardware available to do

00:15:23,519 --> 00:15:29,440
tests on the code that was being

00:15:26,160 --> 00:15:31,360
developed and evolved and iterated so

00:15:29,440 --> 00:15:33,040
again it didn't make it impossible to do

00:15:31,360 --> 00:15:35,040
development but it made it

00:15:33,040 --> 00:15:36,720
so that i mean for me what it made me do

00:15:35,040 --> 00:15:39,040
is be extremely careful with

00:15:36,720 --> 00:15:40,959
every change that i made and you know

00:15:39,040 --> 00:15:43,040
review it very carefully

00:15:40,959 --> 00:15:44,639
more so than i might have if i had had

00:15:43,040 --> 00:15:46,079
the hardware to do a test on

00:15:44,639 --> 00:15:47,680
because then i could do a quick test and

00:15:46,079 --> 00:15:49,279
if it worked then it'd be fine and i'd

00:15:47,680 --> 00:15:50,079
move on and if it didn't work i'd fix it

00:15:49,279 --> 00:15:52,720
didn't

00:15:50,079 --> 00:15:54,160
wait till it worked so that was that was

00:15:52,720 --> 00:15:56,000
a challenge

00:15:54,160 --> 00:15:57,759
the biggest challenge and i think

00:15:56,000 --> 00:15:58,160
personally for me the hardest challenge

00:15:57,759 --> 00:16:00,560
was

00:15:58,160 --> 00:16:01,440
actually because of the schedule the

00:16:00,560 --> 00:16:05,759
unrealistic

00:16:01,440 --> 00:16:08,160
schedule expectation um qualcomm had

00:16:05,759 --> 00:16:09,680
their schedule and their order of months

00:16:08,160 --> 00:16:11,120
but actually it could have been six

00:16:09,680 --> 00:16:14,800
months

00:16:11,120 --> 00:16:16,399
regardless it was um

00:16:14,800 --> 00:16:17,680
not realistic to get the work done that

00:16:16,399 --> 00:16:18,320
really needed to be done in order for

00:16:17,680 --> 00:16:20,560
the code to

00:16:18,320 --> 00:16:21,759
reach a point at which is acceptable to

00:16:20,560 --> 00:16:24,560
be

00:16:21,759 --> 00:16:25,920
reviewed and accepted upstream and i

00:16:24,560 --> 00:16:28,720
wasn't gonna send

00:16:25,920 --> 00:16:30,160
code out that i knew was not ready for

00:16:28,720 --> 00:16:32,639
review because

00:16:30,160 --> 00:16:34,399
um you know i could be ridiculed for it

00:16:32,639 --> 00:16:34,720
and there's a certain reputation there

00:16:34,399 --> 00:16:38,000
with

00:16:34,720 --> 00:16:40,320
uh if you are a developer um

00:16:38,000 --> 00:16:41,279
doing good work is something that uh

00:16:40,320 --> 00:16:43,600
benefits you

00:16:41,279 --> 00:16:45,759
in future work so i wasn't i didn't want

00:16:43,600 --> 00:16:49,120
to do that so there was conflict there

00:16:45,759 --> 00:16:52,320
and it was uh it was it was tough

00:16:49,120 --> 00:16:54,240
it was a real challenge early on um

00:16:52,320 --> 00:16:56,079
i'll just mention that i think had i

00:16:54,240 --> 00:16:57,199
reset expectations a little bit better

00:16:56,079 --> 00:16:59,680
early on it might have

00:16:57,199 --> 00:17:00,959
improved things but the reality is i

00:16:59,680 --> 00:17:01,920
think if i would have said it's going to

00:17:00,959 --> 00:17:03,199
be more than a year

00:17:01,920 --> 00:17:04,880
it wouldn't have been acceptable and

00:17:03,199 --> 00:17:06,480
that wouldn't have been received very

00:17:04,880 --> 00:17:08,240
well

00:17:06,480 --> 00:17:11,600
the next stage of development was i

00:17:08,240 --> 00:17:12,640
posted um in november of 2018 for review

00:17:11,600 --> 00:17:15,679
the first

00:17:12,640 --> 00:17:17,120
version of the code and that was posted

00:17:15,679 --> 00:17:19,839
as an rfc

00:17:17,120 --> 00:17:20,319
and um at that time i got a a lot of

00:17:19,839 --> 00:17:22,880
good

00:17:20,319 --> 00:17:24,799
feedback actually i think the main

00:17:22,880 --> 00:17:27,760
reviewer was arne bergman again

00:17:24,799 --> 00:17:30,640
and i mean i i can't thank arnd enough

00:17:27,760 --> 00:17:33,679
for his involvement in this project

00:17:30,640 --> 00:17:35,200
he um so some of the re some of the

00:17:33,679 --> 00:17:37,280
feedback i got is don't use global

00:17:35,200 --> 00:17:40,240
variables don't use this register hal

00:17:37,280 --> 00:17:41,520
if possible um i mentioned that before

00:17:40,240 --> 00:17:45,360
use bql

00:17:41,520 --> 00:17:47,039
um and look at the caudal and rse 8289

00:17:45,360 --> 00:17:50,240
which is just basically

00:17:47,039 --> 00:17:54,400
a generic way that the network stack

00:17:50,240 --> 00:17:56,480
manages the flow of packets

00:17:54,400 --> 00:17:58,320
to to try to make sure that we don't

00:17:56,480 --> 00:17:58,880
drop packets or push things and have too

00:17:58,320 --> 00:18:00,559
much

00:17:58,880 --> 00:18:04,240
push too much data toward the network

00:18:00,559 --> 00:18:07,919
hardware that can cue it and therefore

00:18:04,240 --> 00:18:10,400
delay delivery of things um

00:18:07,919 --> 00:18:11,919
avoid additional cueing avoid excessive

00:18:10,400 --> 00:18:13,919
locking

00:18:11,919 --> 00:18:16,000
one of the things uh that was there was

00:18:13,919 --> 00:18:18,080
a wrapper that sort of

00:18:16,000 --> 00:18:20,320
provided a nice simple interface around

00:18:18,080 --> 00:18:21,919
doing a dma allocation

00:18:20,320 --> 00:18:25,200
well they said don't do that just use

00:18:21,919 --> 00:18:26,799
the dma allocation code

00:18:25,200 --> 00:18:29,760
there was a comment about avoiding

00:18:26,799 --> 00:18:32,799
indirect function calls because of

00:18:29,760 --> 00:18:36,559
spectre the spectre problem and how we

00:18:32,799 --> 00:18:39,280
have to address um address that

00:18:36,559 --> 00:18:40,000
and don't use i octal and don't use bug

00:18:39,280 --> 00:18:42,480
so

00:18:40,000 --> 00:18:44,400
these were i i say their challenges

00:18:42,480 --> 00:18:45,919
basically this was feedback but what it

00:18:44,400 --> 00:18:47,600
meant was there's a whole bunch of work

00:18:45,919 --> 00:18:49,200
left to do even after

00:18:47,600 --> 00:18:50,880
all the work that i had done leading up

00:18:49,200 --> 00:18:52,799
to november 2018

00:18:50,880 --> 00:18:56,240
there was still this kind of work to do

00:18:52,799 --> 00:18:58,240
um and as i said i posted as an rfc

00:18:56,240 --> 00:18:59,840
because i kind of knew there was more

00:18:58,240 --> 00:19:02,559
work to do

00:18:59,840 --> 00:19:02,960
now in may of 2019 six months later or

00:19:02,559 --> 00:19:05,600
so

00:19:02,960 --> 00:19:07,919
i posted a real version of the code

00:19:05,600 --> 00:19:11,679
which i thought was close enough to

00:19:07,919 --> 00:19:14,880
um to be ready for review upstream

00:19:11,679 --> 00:19:16,160
and um what happened then was

00:19:14,880 --> 00:19:17,679
unfortunate

00:19:16,160 --> 00:19:19,360
right about that same time there was

00:19:17,679 --> 00:19:21,440
someone else from intel who

00:19:19,360 --> 00:19:22,799
had was also trying to post upstream

00:19:21,440 --> 00:19:25,039
support for a modem

00:19:22,799 --> 00:19:26,000
from intel and they found that there was

00:19:25,039 --> 00:19:29,200
not a common

00:19:26,000 --> 00:19:30,400
um universal way of representing a modem

00:19:29,200 --> 00:19:33,200
in the kernel

00:19:30,400 --> 00:19:35,120
and so he wanted to do a generic

00:19:33,200 --> 00:19:36,960
framework that might be able to do that

00:19:35,120 --> 00:19:38,559
in a generic way to handle all vendors

00:19:36,960 --> 00:19:41,760
and all motives

00:19:38,559 --> 00:19:42,320
and that was not super well defined and

00:19:41,760 --> 00:19:45,440
it took

00:19:42,320 --> 00:19:48,400
it literally took months after work

00:19:45,440 --> 00:19:50,480
of me working with the one or two other

00:19:48,400 --> 00:19:52,480
people to try to define what it is

00:19:50,480 --> 00:19:54,240
i offered to be the first implementer

00:19:52,480 --> 00:19:55,360
the first one to actually use this new

00:19:54,240 --> 00:19:58,559
framework

00:19:55,360 --> 00:20:00,320
um and in the end

00:19:58,559 --> 00:20:02,080
well i'll go i'll tell you what happened

00:20:00,320 --> 00:20:03,520
at the end but anyway so we talked about

00:20:02,080 --> 00:20:04,720
and talked about it and not much came of

00:20:03,520 --> 00:20:07,039
it it became to my

00:20:04,720 --> 00:20:09,679
in my view it came sort of a difficult

00:20:07,039 --> 00:20:11,760
to even achieve

00:20:09,679 --> 00:20:13,280
second thing was that there is this well

00:20:11,760 --> 00:20:16,080
qualcomm has a layering

00:20:13,280 --> 00:20:17,039
of two two drivers that implement their

00:20:16,080 --> 00:20:18,799
um

00:20:17,039 --> 00:20:20,159
their network functionality there's this

00:20:18,799 --> 00:20:23,120
rm net layer over

00:20:20,159 --> 00:20:26,080
ipa and there were questions about why

00:20:23,120 --> 00:20:26,080
that was necessary

00:20:26,559 --> 00:20:30,559
so the next set of challenges occurred

00:20:29,280 --> 00:20:32,400
after they were accepted

00:20:30,559 --> 00:20:34,000
after the code was finally accepted i

00:20:32,400 --> 00:20:35,520
addressed all these things

00:20:34,000 --> 00:20:37,760
but one of the things i did was when i

00:20:35,520 --> 00:20:40,640
posted this last series i said

00:20:37,760 --> 00:20:41,360
i would like it accepted with no when uh

00:20:40,640 --> 00:20:44,960
wireless

00:20:41,360 --> 00:20:47,360
when framework and no are a net driver

00:20:44,960 --> 00:20:48,000
so no changes to the way that the arm

00:20:47,360 --> 00:20:51,600
net driver

00:20:48,000 --> 00:20:51,600
layers things on top of ipa

00:20:52,320 --> 00:20:57,679
and and actually after

00:20:55,600 --> 00:20:59,520
just a very little bit of discussion

00:20:57,679 --> 00:21:02,960
david miller accepted it

00:20:59,520 --> 00:21:05,200
and it was kind of surprising to me

00:21:02,960 --> 00:21:06,320
but this code is very different from

00:21:05,200 --> 00:21:09,919
what i started with

00:21:06,320 --> 00:21:11,360
um it's it's very different from ipa

00:21:09,919 --> 00:21:12,320
light and therefore very different from

00:21:11,360 --> 00:21:15,360
the ipa

00:21:12,320 --> 00:21:17,120
downstream code the full driver

00:21:15,360 --> 00:21:19,600
and so there are two code bases after

00:21:17,120 --> 00:21:21,840
all which qualcomm wanted to avoid

00:21:19,600 --> 00:21:24,880
um but i maintain one of them and so

00:21:21,840 --> 00:21:28,080
maybe that's a little bit of a

00:21:24,880 --> 00:21:29,919
silver lining i don't know um but

00:21:28,080 --> 00:21:32,159
another challenge now is that the

00:21:29,919 --> 00:21:35,360
downstream code has continued to evolve

00:21:32,159 --> 00:21:37,360
independent of the upstream code and so

00:21:35,360 --> 00:21:38,400
the some of it is no longer familiar to

00:21:37,360 --> 00:21:40,240
me

00:21:38,400 --> 00:21:41,760
as i read it so it's harder to read and

00:21:40,240 --> 00:21:42,960
translate into what needs to be done

00:21:41,760 --> 00:21:46,799
upstream if i'm going to do

00:21:42,960 --> 00:21:48,400
the same thing and similarly bug fixes

00:21:46,799 --> 00:21:50,799
in the downstream code aren't likely to

00:21:48,400 --> 00:21:53,760
be shared with me for the upstream code

00:21:50,799 --> 00:21:53,760
and vice versa

00:21:54,400 --> 00:21:57,520
so a few insights

00:21:57,600 --> 00:22:03,039
the the biggest thing i think is well

00:22:00,400 --> 00:22:04,720
there one insight is that code quality

00:22:03,039 --> 00:22:06,880
is different between upstream and

00:22:04,720 --> 00:22:07,600
downstream the requirements for code

00:22:06,880 --> 00:22:09,600
quality

00:22:07,600 --> 00:22:11,679
upstream quality is it i mean if it's

00:22:09,600 --> 00:22:14,320
not upstream quality then

00:22:11,679 --> 00:22:15,919
it's not going to be accepted um it

00:22:14,320 --> 00:22:17,600
should be tested it should work

00:22:15,919 --> 00:22:19,919
it's expected to work basically but it

00:22:17,600 --> 00:22:21,760
has to be of high quality regardless of

00:22:19,919 --> 00:22:24,000
how long it takes to get there

00:22:21,760 --> 00:22:25,919
meanwhile downstream has to meet their

00:22:24,000 --> 00:22:27,520
schedule they have to meet it and the

00:22:25,919 --> 00:22:29,760
code doesn't have to be beautiful

00:22:27,520 --> 00:22:31,200
it doesn't mean it's ugly but it doesn't

00:22:29,760 --> 00:22:34,159
the main thing is that it has to pass

00:22:31,200 --> 00:22:36,720
the test and be done on time

00:22:34,159 --> 00:22:38,559
um software lifetime so the upstream

00:22:36,720 --> 00:22:42,159
kernel continuously moves forward

00:22:38,559 --> 00:22:43,760
and um and with every release we have

00:22:42,159 --> 00:22:46,720
new versions of the code

00:22:43,760 --> 00:22:48,720
surrounding each driver whereas for

00:22:46,720 --> 00:22:50,400
downstream they will freeze a relief for

00:22:48,720 --> 00:22:52,320
a platform and at that point they'll

00:22:50,400 --> 00:22:53,760
pretty much iterate on just that release

00:22:52,320 --> 00:22:54,240
and then when they go to a new platform

00:22:53,760 --> 00:22:56,559
they can

00:22:54,240 --> 00:22:59,120
start fresh with the brand new release

00:22:56,559 --> 00:23:03,200
so that's a difference

00:22:59,120 --> 00:23:05,280
um another thing is that for downstream

00:23:03,200 --> 00:23:06,960
they can they can when they start a new

00:23:05,280 --> 00:23:08,080
project on a new hardware they can just

00:23:06,960 --> 00:23:09,679
say all right

00:23:08,080 --> 00:23:11,520
we're done supporting the old hardware

00:23:09,679 --> 00:23:14,400
they've got their frozen release

00:23:11,520 --> 00:23:16,159
whereas upstream basically every release

00:23:14,400 --> 00:23:16,480
has to support all the old stuff and the

00:23:16,159 --> 00:23:20,880
new

00:23:16,480 --> 00:23:23,840
stuff two minutes um the thing is that

00:23:20,880 --> 00:23:24,400
another thing is that the upstream

00:23:23,840 --> 00:23:26,720
kernel

00:23:24,400 --> 00:23:29,760
is a single unit and any developer can

00:23:26,720 --> 00:23:31,760
touch any part of the kernel

00:23:29,760 --> 00:23:33,760
what that means is that i can write a

00:23:31,760 --> 00:23:35,039
function and i can look at all colors of

00:23:33,760 --> 00:23:36,159
that function and make sure that they

00:23:35,039 --> 00:23:39,840
will never pass

00:23:36,159 --> 00:23:42,720
garbage to me to as arguments um

00:23:39,840 --> 00:23:44,080
but downstream they may partition

00:23:42,720 --> 00:23:45,360
different teams to work on different

00:23:44,080 --> 00:23:48,320
parts of the kernel

00:23:45,360 --> 00:23:50,159
and um and as a result it's going to be

00:23:48,320 --> 00:23:52,559
important for them to have each

00:23:50,159 --> 00:23:54,480
each one is going to have a stable

00:23:52,559 --> 00:23:54,880
interface presented to the other so that

00:23:54,480 --> 00:23:56,480
they

00:23:54,880 --> 00:23:59,039
their other teams can work without

00:23:56,480 --> 00:23:59,039
disruption

00:23:59,279 --> 00:24:03,600
and then finally upstream code generally

00:24:01,840 --> 00:24:04,799
assumes working hardware and downstream

00:24:03,600 --> 00:24:06,480
code

00:24:04,799 --> 00:24:07,919
assumes working hardware but it can also

00:24:06,480 --> 00:24:10,159
be used for hardware bring up and for

00:24:07,919 --> 00:24:11,919
brand new hardware it might be

00:24:10,159 --> 00:24:13,679
that things don't work the way they're

00:24:11,919 --> 00:24:15,039
supposed to and so the downstream code

00:24:13,679 --> 00:24:16,720
will probably have to

00:24:15,039 --> 00:24:19,760
have some certain tests for things that

00:24:16,720 --> 00:24:22,080
are never likely to occur

00:24:19,760 --> 00:24:24,240
similarly debug output might be very

00:24:22,080 --> 00:24:26,000
useful downstream to get things

00:24:24,240 --> 00:24:28,400
get problems diagnosed early while

00:24:26,000 --> 00:24:31,120
bringing up hardware

00:24:28,400 --> 00:24:32,080
but it's overkill for upstream and the

00:24:31,120 --> 00:24:34,640
development process

00:24:32,080 --> 00:24:36,960
for downstream for upstream is fairly

00:24:34,640 --> 00:24:37,360
well defined but for downstream qualcomm

00:24:36,960 --> 00:24:40,960
has

00:24:37,360 --> 00:24:45,679
other code bases than linux and so they

00:24:40,960 --> 00:24:48,320
they have to support different things so

00:24:45,679 --> 00:24:48,720
right now two platforms are supported

00:24:48,320 --> 00:24:51,440
one

00:24:48,720 --> 00:24:52,960
is about to be supported and a fourth is

00:24:51,440 --> 00:24:54,159
going to be supported very soon i'm in

00:24:52,960 --> 00:24:56,400
the process of getting

00:24:54,159 --> 00:24:58,159
code to support new hardware upstream

00:24:56,400 --> 00:25:00,400
right now

00:24:58,159 --> 00:25:01,679
um we use the code to access the

00:25:00,400 --> 00:25:04,720
cellular modem on that

00:25:01,679 --> 00:25:06,480
arm64 based laptop and it works

00:25:04,720 --> 00:25:08,320
um there's still a little work to do on

00:25:06,480 --> 00:25:09,120
user space integration but it basically

00:25:08,320 --> 00:25:10,799
works

00:25:09,120 --> 00:25:12,960
and we'll be making that a little bit

00:25:10,799 --> 00:25:15,520
more available soon

00:25:12,960 --> 00:25:17,440
in the coming year um i expect to be

00:25:15,520 --> 00:25:18,640
doing performance tuning and hopefully

00:25:17,440 --> 00:25:21,440
adding support for some of the more

00:25:18,640 --> 00:25:21,440
advanced features

00:25:22,080 --> 00:25:28,400
and summary is the driver's upstream

00:25:25,279 --> 00:25:31,840
it wasn't easy but it got there

00:25:28,400 --> 00:25:33,039
a quick note is that

00:25:31,840 --> 00:25:34,480
if you're going to get want to get

00:25:33,039 --> 00:25:35,679
something upstream it has to start out

00:25:34,480 --> 00:25:38,000
by at least looking

00:25:35,679 --> 00:25:39,760
like upstream code which is a very vague

00:25:38,000 --> 00:25:41,520
statement but basically

00:25:39,760 --> 00:25:43,039
little superficial things are going to

00:25:41,520 --> 00:25:45,760
prevent you from getting things

00:25:43,039 --> 00:25:47,919
accepted so you got to get rid of the

00:25:45,760 --> 00:25:50,640
superficial things and then

00:25:47,919 --> 00:25:51,039
once the superficial problems are gone

00:25:50,640 --> 00:25:53,120
um

00:25:51,039 --> 00:25:54,080
the design issues will be found people

00:25:53,120 --> 00:25:57,120
will people

00:25:54,080 --> 00:25:58,320
do do careful review of upstream code so

00:25:57,120 --> 00:26:02,880
they you should expect

00:25:58,320 --> 00:26:04,320
that um reviewers will ask for changes

00:26:02,880 --> 00:26:06,000
and then the biggest thing is that

00:26:04,320 --> 00:26:06,799
downstream and upstream have different

00:26:06,000 --> 00:26:10,159
requirements

00:26:06,799 --> 00:26:13,120
and i think that um it's no

00:26:10,159 --> 00:26:15,279
wonder that it takes work to adapt

00:26:13,120 --> 00:26:17,919
downstream code to upstream code because

00:26:15,279 --> 00:26:19,200
you know they they both have to function

00:26:17,919 --> 00:26:22,880
but they don't have

00:26:19,200 --> 00:26:24,480
the same requirements

00:26:22,880 --> 00:26:26,799
so i got some quick acknowledgements i'm

00:26:24,480 --> 00:26:28,799
not going to mention them but they're

00:26:26,799 --> 00:26:30,480
i got a lot of help along the way from

00:26:28,799 --> 00:26:31,440
all of these people and i just really

00:26:30,480 --> 00:26:35,039
appreciate them

00:26:31,440 --> 00:26:37,600
and um at the last slide i have um

00:26:35,039 --> 00:26:38,480
a couple of references most of them are

00:26:37,600 --> 00:26:41,760
just posts

00:26:38,480 --> 00:26:43,360
not to the upstream posts but that's it

00:26:41,760 --> 00:26:45,520
and that's what i have i'm a little bit

00:26:43,360 --> 00:26:48,559
over but but i didn't go

00:26:45,520 --> 00:26:50,000
way over and i finished my slides so i

00:26:48,559 --> 00:26:51,520
don't think there's really any time for

00:26:50,000 --> 00:26:55,279
questions but i guess what i'd like to

00:26:51,520 --> 00:26:55,279
do i'll look on chat really quick

00:26:55,840 --> 00:27:00,960
there's a delay five minutes okay

00:26:58,960 --> 00:27:02,480
anyway so i think that's it and i

00:27:00,960 --> 00:27:07,840
appreciate everyone for

00:27:02,480 --> 00:27:07,840
attending today

00:27:18,840 --> 00:27:21,840

YouTube URL: https://www.youtube.com/watch?v=we6pEgcEtYQ


