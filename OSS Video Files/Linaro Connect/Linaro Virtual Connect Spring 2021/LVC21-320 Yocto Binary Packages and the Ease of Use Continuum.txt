Title: LVC21-320 Yocto Binary Packages and the Ease of Use Continuum
Publication date: 2021-04-15
Playlist: Linaro Virtual Connect Spring 2021
Description: 
	When discussing an OpenEmbedded derived distribution, it is common to hear things like "I don't want to take the time build from source", "We don't need that level of control and optimization", "We just need to boot and demo" or "Can I create and deploy that with a Dockerfile ?". These type of questions and concerns are valid, but are addressed by the latest  dvancements in the Yocto project ecosystem.

As projects evolve, so do their requirements and use cases. Questions may become: "How do I rebuild a package?", "How can someone develop applications against my image/distribution?", "How can I integrate 3rd party packages?", "How do I go to production and support?" or "How can I deploy updates and new applications?".

This means that the flexibility of the build environment becomes important as do the outputs of that environment. This talk will discuss how although OpenEmbedded was traditionally source based, it can produce a number of binary outputs. Those outputs can be used to create landing points on the ease of use continuum between well known alternatives such as alpine through Debian, as well as provide a path from demo to production to wide scale cloud deployment.

It will also include examples of how these binary outputs can be used in traditional package feed/update mechanisms, as well as in new environments such as Dockerfile builds or cloud-native base images.

Finally, how Xilinx may leverage these capabilities to enhance the accessibility and platform integration will be discussed.
Captions: 
	00:00:04,240 --> 00:00:07,520
hi

00:00:04,640 --> 00:00:08,240
um my name is bruce ashfield um and i

00:00:07,520 --> 00:00:12,080
work for

00:00:08,240 --> 00:00:14,000
xilinx and i'm mark kelly i also work

00:00:12,080 --> 00:00:14,559
for xilinx and i work in the octoproject

00:00:14,000 --> 00:00:17,039
group

00:00:14,559 --> 00:00:18,720
and we're going to be doing a

00:00:17,039 --> 00:00:21,439
presentation and talking to you about

00:00:18,720 --> 00:00:22,320
uh the octo project uh and binary

00:00:21,439 --> 00:00:26,560
packages

00:00:22,320 --> 00:00:26,560
and the ease of use uh continuum

00:00:26,800 --> 00:00:30,320
what that really means is we're going to

00:00:29,519 --> 00:00:32,559
try to

00:00:30,320 --> 00:00:34,960
introduce some topics so we'll do a

00:00:32,559 --> 00:00:37,280
quick overview just to do a level set

00:00:34,960 --> 00:00:39,760
sort of a summary of the use case of

00:00:37,280 --> 00:00:42,320
binary builds and outputs of a

00:00:39,760 --> 00:00:44,079
embedded system talk about some of the

00:00:42,320 --> 00:00:47,280
technology that underpins us

00:00:44,079 --> 00:00:49,680
in the yoga project and then hit on some

00:00:47,280 --> 00:00:51,039
uh like example binary outputs and some

00:00:49,680 --> 00:00:54,079
future work so

00:00:51,039 --> 00:00:56,719
by the end of this our goals are that

00:00:54,079 --> 00:00:57,520
you know everybody will understand that

00:00:56,719 --> 00:00:59,520
yocto

00:00:57,520 --> 00:01:01,039
project builds are more than source only

00:00:59,520 --> 00:01:03,039
and what they can produce

00:01:01,039 --> 00:01:04,080
um we'll have introduced some of the

00:01:03,039 --> 00:01:05,760
concepts for

00:01:04,080 --> 00:01:07,760
binary plumbing and infrastructure

00:01:05,760 --> 00:01:09,520
because they are full

00:01:07,760 --> 00:01:11,520
two hour presentations on their own so

00:01:09,520 --> 00:01:13,040
we just want to give people information

00:01:11,520 --> 00:01:15,840
on what they can look for

00:01:13,040 --> 00:01:17,040
and also hopefully dispel some of maybe

00:01:15,840 --> 00:01:20,159
myths or

00:01:17,040 --> 00:01:20,720
thoughts that the octo project and ease

00:01:20,159 --> 00:01:26,320
of use

00:01:20,720 --> 00:01:28,000
are mutually exclusive so

00:01:26,320 --> 00:01:29,360
some of the i've already said them a few

00:01:28,000 --> 00:01:30,079
times but some of the things that we're

00:01:29,360 --> 00:01:31,600
going to be

00:01:30,079 --> 00:01:32,799
you know the the concepts that we're

00:01:31,600 --> 00:01:33,200
talking about is you know what do we

00:01:32,799 --> 00:01:35,680
mean

00:01:33,200 --> 00:01:37,119
by uh binary artifacts and ease of use

00:01:35,680 --> 00:01:39,119
because those are the two most important

00:01:37,119 --> 00:01:41,759
things in this presentation

00:01:39,119 --> 00:01:43,119
um the loose definition that we're using

00:01:41,759 --> 00:01:45,759
for binary

00:01:43,119 --> 00:01:46,880
artifacts is that they are outputs from

00:01:45,759 --> 00:01:48,479
a defined build

00:01:46,880 --> 00:01:50,479
that can be used or installed on a

00:01:48,479 --> 00:01:52,079
running target or to construct a target

00:01:50,479 --> 00:01:54,479
image

00:01:52,079 --> 00:01:55,680
and inside of that the big thing is also

00:01:54,479 --> 00:01:58,240
the architecture

00:01:55,680 --> 00:01:59,920
and the optimization of the of those

00:01:58,240 --> 00:02:01,119
binaries are defined by the build

00:01:59,920 --> 00:02:03,119
parameters

00:02:01,119 --> 00:02:04,960
and that impacts your level of

00:02:03,119 --> 00:02:05,920
reusability so that's what we that's

00:02:04,960 --> 00:02:08,800
what we call a

00:02:05,920 --> 00:02:10,080
a binary artifact and arm platforms in

00:02:08,800 --> 00:02:11,360
particular have

00:02:10,080 --> 00:02:13,760
unique challenges and different

00:02:11,360 --> 00:02:17,520
challenges such that you know we have

00:02:13,760 --> 00:02:20,400
all um a wider variety of instructions

00:02:17,520 --> 00:02:22,400
and optimization techniques um and they

00:02:20,400 --> 00:02:24,720
vary greatly between platforms and this

00:02:22,400 --> 00:02:26,000
conflicts with the actual ease-of-use

00:02:24,720 --> 00:02:28,319
thing that we want to talk about

00:02:26,000 --> 00:02:29,280
because that conflicts with the desire

00:02:28,319 --> 00:02:31,760
to run

00:02:29,280 --> 00:02:32,800
um sort of common universal generic

00:02:31,760 --> 00:02:36,000
off-the-shelf

00:02:32,800 --> 00:02:37,440
binaries and by ease of use

00:02:36,000 --> 00:02:39,680
uh because we're talking about a number

00:02:37,440 --> 00:02:42,560
of different uh use cases

00:02:39,680 --> 00:02:43,120
what you depending on where you are um

00:02:42,560 --> 00:02:44,640
we

00:02:43,120 --> 00:02:46,560
defined it as you know it's sort of

00:02:44,640 --> 00:02:49,440
obvious and clear

00:02:46,560 --> 00:02:51,200
how to complete the initial steps

00:02:49,440 --> 00:02:51,840
towards a goal so you know how to get

00:02:51,200 --> 00:02:53,840
started

00:02:51,840 --> 00:02:56,319
and it makes sense and it works as you

00:02:53,840 --> 00:02:56,319
expect

00:02:57,040 --> 00:03:02,720
so some of the common

00:03:00,239 --> 00:03:04,000
questions and comments that we get about

00:03:02,720 --> 00:03:06,239
the octa project

00:03:04,000 --> 00:03:07,920
and either binaries or ease of use you

00:03:06,239 --> 00:03:10,319
know these are a few that i've collected

00:03:07,920 --> 00:03:11,599
and there's probably hundreds more but

00:03:10,319 --> 00:03:13,760
you know we get the question you know

00:03:11,599 --> 00:03:16,239
are binary packages supported

00:03:13,760 --> 00:03:18,080
you know or or do i have to start

00:03:16,239 --> 00:03:19,200
building from source uh

00:03:18,080 --> 00:03:20,560
and i should say i don't plan on

00:03:19,200 --> 00:03:21,280
answering any of these questions in this

00:03:20,560 --> 00:03:22,400
slide

00:03:21,280 --> 00:03:24,080
hopefully by the end of this

00:03:22,400 --> 00:03:25,440
presentation these are the kind of

00:03:24,080 --> 00:03:26,720
questions that will be

00:03:25,440 --> 00:03:27,920
um you'll know where to look for the

00:03:26,720 --> 00:03:28,959
answers or we'll have answered them

00:03:27,920 --> 00:03:31,599
directly

00:03:28,959 --> 00:03:32,159
um the other you know things is like you

00:03:31,599 --> 00:03:34,239
know

00:03:32,159 --> 00:03:35,280
you know what about these binary outputs

00:03:34,239 --> 00:03:37,040
okay great you can

00:03:35,280 --> 00:03:38,400
you can do binary outputs from the

00:03:37,040 --> 00:03:39,920
octave project it's like you know are

00:03:38,400 --> 00:03:43,120
they compatible with

00:03:39,920 --> 00:03:45,200
third-party packages meaning a rpm or a

00:03:43,120 --> 00:03:47,200
dev that i've pulled from

00:03:45,200 --> 00:03:48,319
the internet from distro x rather

00:03:47,200 --> 00:03:50,319
compatible you know

00:03:48,319 --> 00:03:51,360
the answer is no they're not because

00:03:50,319 --> 00:03:52,720
they're built slightly

00:03:51,360 --> 00:03:54,640
the the dependencies and different

00:03:52,720 --> 00:03:55,920
things are different but you know are

00:03:54,640 --> 00:03:59,040
they fully optimized

00:03:55,920 --> 00:03:59,599
for platform x or software stack y and

00:03:59,040 --> 00:04:01,760
then

00:03:59,599 --> 00:04:03,040
you know what is behind those binary

00:04:01,760 --> 00:04:05,680
artifacts you know

00:04:03,040 --> 00:04:06,720
it's it's oe core and the ecosystem

00:04:05,680 --> 00:04:08,959
metadata but

00:04:06,720 --> 00:04:10,239
it's not magic it's visible you can find

00:04:08,959 --> 00:04:12,560
it and it's all

00:04:10,239 --> 00:04:14,480
uh you know fully self-documenting you

00:04:12,560 --> 00:04:15,439
know but it's not the sources of other

00:04:14,480 --> 00:04:18,560
distributions

00:04:15,439 --> 00:04:20,720
or base binary packages of

00:04:18,560 --> 00:04:22,160
of those distros so we're talking about

00:04:20,720 --> 00:04:24,240
open embedded core

00:04:22,160 --> 00:04:25,280
and the ecosystem that makes up the octa

00:04:24,240 --> 00:04:27,919
project

00:04:25,280 --> 00:04:28,320
is what is behind those binary effects

00:04:27,919 --> 00:04:31,120
you know

00:04:28,320 --> 00:04:33,520
can i act you know dnf update my target

00:04:31,120 --> 00:04:36,560
you absolutely can

00:04:33,520 --> 00:04:37,520
with some conditions which we'll get

00:04:36,560 --> 00:04:39,280
into later

00:04:37,520 --> 00:04:40,639
can i do a docker build meaning can i

00:04:39,280 --> 00:04:41,360
use it as a base to construct a

00:04:40,639 --> 00:04:44,080
container

00:04:41,360 --> 00:04:45,120
the answer is again yes you can with

00:04:44,080 --> 00:04:47,680
some

00:04:45,120 --> 00:04:49,040
caveats and then the the you know the

00:04:47,680 --> 00:04:50,240
other question we always get is you know

00:04:49,040 --> 00:04:53,440
why would i use the

00:04:50,240 --> 00:04:54,800
octa project binary artifacts versus the

00:04:53,440 --> 00:04:57,120
ones from distro

00:04:54,800 --> 00:04:58,560
x you know name your favorite distro

00:04:57,120 --> 00:04:59,919
embedded or not here

00:04:58,560 --> 00:05:02,800
and we'll show how some of the

00:04:59,919 --> 00:05:04,639
advantages of the octo project

00:05:02,800 --> 00:05:06,400
should lead you to being able to figure

00:05:04,639 --> 00:05:08,080
out when you should use yoga project

00:05:06,400 --> 00:05:11,120
binary outputs versus

00:05:08,080 --> 00:05:13,840
other options so

00:05:11,120 --> 00:05:14,720
one of the things that i tried to

00:05:13,840 --> 00:05:17,440
capture

00:05:14,720 --> 00:05:17,919
uh maybe not so well is you know that

00:05:17,440 --> 00:05:19,680
that

00:05:17,919 --> 00:05:21,120
definition of you know something that's

00:05:19,680 --> 00:05:23,840
i didn't want to say easy but

00:05:21,120 --> 00:05:25,919
we have easier and harder and whether

00:05:23,840 --> 00:05:28,160
it's binary or source

00:05:25,919 --> 00:05:29,680
and then the the point of view of it

00:05:28,160 --> 00:05:31,680
depends on what you're trying to do

00:05:29,680 --> 00:05:34,639
depends on whether you're a developer

00:05:31,680 --> 00:05:36,720
whether you're a user or an application

00:05:34,639 --> 00:05:37,759
uh user or developer and then production

00:05:36,720 --> 00:05:38,880
meaning you're a company that's

00:05:37,759 --> 00:05:42,160
producing a

00:05:38,880 --> 00:05:43,600
platform so i won't go through all these

00:05:42,160 --> 00:05:45,600
but we're just trying to show that you

00:05:43,600 --> 00:05:47,440
know for example if you are doing

00:05:45,600 --> 00:05:49,520
a container build it might be harder

00:05:47,440 --> 00:05:51,280
from source and easier

00:05:49,520 --> 00:05:53,600
uh if you're using binaries or if you

00:05:51,280 --> 00:05:55,280
want to use universal packages

00:05:53,600 --> 00:05:57,280
that's hard with binaries because of the

00:05:55,280 --> 00:05:58,720
optimization levels but it might be

00:05:57,280 --> 00:06:00,080
easier with source because you get to

00:05:58,720 --> 00:06:01,759
pick your tuning

00:06:00,080 --> 00:06:03,600
um and that varies though these are just

00:06:01,759 --> 00:06:05,759
a few of the categories i picked

00:06:03,600 --> 00:06:07,600
um you know that you know license

00:06:05,759 --> 00:06:09,600
compliant is

00:06:07,600 --> 00:06:11,039
easier with source and maybe a little

00:06:09,600 --> 00:06:12,800
bit harder with binaries because it's

00:06:11,039 --> 00:06:15,039
two separate packages and

00:06:12,800 --> 00:06:16,960
the build and the delivery is disjoint

00:06:15,039 --> 00:06:18,800
um so that you know that's all i

00:06:16,960 --> 00:06:20,319
i want to show is that that it's a it's

00:06:18,800 --> 00:06:22,080
a two or three or four dimensional

00:06:20,319 --> 00:06:24,880
matrix for the definition of

00:06:22,080 --> 00:06:26,400
easier or harder complexity or not

00:06:24,880 --> 00:06:27,120
whether you're using uh binders or

00:06:26,400 --> 00:06:28,400
sources

00:06:27,120 --> 00:06:30,240
and this is meant to be sort of a

00:06:28,400 --> 00:06:30,800
sliding scale meaning you can be fully

00:06:30,240 --> 00:06:32,880
binary

00:06:30,800 --> 00:06:34,560
to be fully sourced and then there's all

00:06:32,880 --> 00:06:37,600
these shades of gray

00:06:34,560 --> 00:06:40,720
in the middle and

00:06:37,600 --> 00:06:44,000
i am now going to throw to mark so

00:06:40,720 --> 00:06:45,360
he can talk about um some of the details

00:06:44,000 --> 00:06:47,520
and some of the other parts of the

00:06:45,360 --> 00:06:48,639
system that are behind

00:06:47,520 --> 00:06:51,120
building binaries and binary

00:06:48,639 --> 00:06:54,160
distributions

00:06:51,120 --> 00:06:56,960
yeah so really that last set of slides

00:06:54,160 --> 00:06:57,360
moves into the next one which is really

00:06:56,960 --> 00:06:59,199
when

00:06:57,360 --> 00:07:00,240
when do you want to reuse components

00:06:59,199 --> 00:07:01,520
when you want to use a binary

00:07:00,240 --> 00:07:03,120
distribution

00:07:01,520 --> 00:07:04,639
and i think the traditional use case has

00:07:03,120 --> 00:07:05,759
really been that i t application

00:07:04,639 --> 00:07:07,440
developer which is

00:07:05,759 --> 00:07:08,960
in this scale on the left and that's a

00:07:07,440 --> 00:07:11,680
very obvious case

00:07:08,960 --> 00:07:13,919
one install one configuration go ahead

00:07:11,680 --> 00:07:15,440
and deploy in multiple places

00:07:13,919 --> 00:07:16,800
but quickly you get into the point and

00:07:15,440 --> 00:07:18,080
you want to start customizing some of

00:07:16,800 --> 00:07:20,160
the customizations are

00:07:18,080 --> 00:07:21,840
are configuration based and for things

00:07:20,160 --> 00:07:23,440
like configurations it becomes actually

00:07:21,840 --> 00:07:24,639
quite simple to customize

00:07:23,440 --> 00:07:26,560
but as you start to talk about

00:07:24,639 --> 00:07:28,080
customizing applications customizing

00:07:26,560 --> 00:07:29,520
operating system components you quickly

00:07:28,080 --> 00:07:31,360
get to the point where you really

00:07:29,520 --> 00:07:32,639
you're starting to to struggle to reuse

00:07:31,360 --> 00:07:34,479
components

00:07:32,639 --> 00:07:35,840
and so while you can reuse some of the

00:07:34,479 --> 00:07:38,080
system you may not be able to reuse the

00:07:35,840 --> 00:07:40,479
whole thing on a traditional embedded

00:07:38,080 --> 00:07:42,479
or sorry traditional workstation system

00:07:40,479 --> 00:07:44,240
um as soon as you start customizing

00:07:42,479 --> 00:07:45,599
beyond configuration you quickly get

00:07:44,240 --> 00:07:46,479
into the case where you no longer have

00:07:45,599 --> 00:07:48,639
support

00:07:46,479 --> 00:07:50,479
and so that's a key thing where the octa

00:07:48,639 --> 00:07:52,960
project can come into place

00:07:50,479 --> 00:07:52,960
next slide

00:07:55,039 --> 00:07:58,160
so when we talk about binary effects

00:07:56,960 --> 00:08:01,599
within the octa project

00:07:58,160 --> 00:08:04,639
uh realm we're really talking about uh

00:08:01,599 --> 00:08:07,120
what we call uh

00:08:04,639 --> 00:08:08,720
various outputs really so we've got uh

00:08:07,120 --> 00:08:10,080
build appliances which are basically

00:08:08,720 --> 00:08:11,840
containers that allow

00:08:10,080 --> 00:08:13,360
us to reuse the octopus project to build

00:08:11,840 --> 00:08:15,199
the octa project

00:08:13,360 --> 00:08:17,759
um various build tools that can be used

00:08:15,199 --> 00:08:20,160
for sdks or even document older hosts

00:08:17,759 --> 00:08:21,120
um specific tool chains that can be used

00:08:20,160 --> 00:08:22,879
or reused

00:08:21,120 --> 00:08:24,479
for other purposes and of course the

00:08:22,879 --> 00:08:25,840
machine artifacts which is what most

00:08:24,479 --> 00:08:28,080
people think about when they talk about

00:08:25,840 --> 00:08:29,680
binary artifacts

00:08:28,080 --> 00:08:31,759
the key is that all these things are

00:08:29,680 --> 00:08:34,159
really designed for a total reuse

00:08:31,759 --> 00:08:35,200
of the system with customization when

00:08:34,159 --> 00:08:36,719
the when the

00:08:35,200 --> 00:08:38,240
operating system developer wants to

00:08:36,719 --> 00:08:40,640
customize it

00:08:38,240 --> 00:08:42,399
so what's key here is that within the

00:08:40,640 --> 00:08:43,279
scope of the octa project they do not

00:08:42,399 --> 00:08:45,200
currently have

00:08:43,279 --> 00:08:47,040
a reference binary feed from many of

00:08:45,200 --> 00:08:48,560
these items they have examples for the

00:08:47,040 --> 00:08:50,640
build appliance or they have examples

00:08:48,560 --> 00:08:51,920
for the sdks or they have examples for

00:08:50,640 --> 00:08:53,440
the machine artifacts

00:08:51,920 --> 00:08:55,680
but that's what they are is they're just

00:08:53,440 --> 00:08:57,120
examples they're not actually a reusable

00:08:55,680 --> 00:08:58,959
base or foundation that you can then

00:08:57,120 --> 00:09:00,640
embrace and extend for your own

00:08:58,959 --> 00:09:03,120
components

00:09:00,640 --> 00:09:03,120
next slide

00:09:05,600 --> 00:09:10,320
so let's get into what the actual um

00:09:08,480 --> 00:09:11,760
yokta project artifacts are that you

00:09:10,320 --> 00:09:13,680
have to be aware of in order to

00:09:11,760 --> 00:09:14,800
make the determination on on what you

00:09:13,680 --> 00:09:16,880
want to do

00:09:14,800 --> 00:09:18,480
so with the build configuration that's

00:09:16,880 --> 00:09:20,959
one of the actual key points

00:09:18,480 --> 00:09:22,160
it's because the octa project is

00:09:20,959 --> 00:09:23,839
configurable

00:09:22,160 --> 00:09:26,720
what was the actual configuration what

00:09:23,839 --> 00:09:28,640
layers what components what artifacts

00:09:26,720 --> 00:09:30,080
on the source code side actually make up

00:09:28,640 --> 00:09:31,920
your your system

00:09:30,080 --> 00:09:33,519
and then finally what what other

00:09:31,920 --> 00:09:35,680
configuration settings

00:09:33,519 --> 00:09:37,360
did you use if you have these you can

00:09:35,680 --> 00:09:39,040
then share it to somebody else and they

00:09:37,360 --> 00:09:40,480
can always reproduce your source code

00:09:39,040 --> 00:09:42,320
and so that's again part of the

00:09:40,480 --> 00:09:44,959
foundation the octa project

00:09:42,320 --> 00:09:46,480
we then get into actual build artifacts

00:09:44,959 --> 00:09:48,640
um from the build effects

00:09:46,480 --> 00:09:49,680
some of these are internal to the system

00:09:48,640 --> 00:09:52,959
others of them may be

00:09:49,680 --> 00:09:54,320
maybe user visible so shared state

00:09:52,959 --> 00:09:57,120
is something that's basically an

00:09:54,320 --> 00:09:59,680
internal artifact that happens to be

00:09:57,120 --> 00:10:01,440
a cache of the building components that

00:09:59,680 --> 00:10:04,160
can be shared with others

00:10:01,440 --> 00:10:05,839
there's also some other optimization

00:10:04,160 --> 00:10:07,200
components like the hash equivalency

00:10:05,839 --> 00:10:10,240
this says that hey

00:10:07,200 --> 00:10:12,800
if i make a change to package xyz

00:10:10,240 --> 00:10:14,320
um that change didn't actually affect

00:10:12,800 --> 00:10:16,000
the output in a way that

00:10:14,320 --> 00:10:18,000
other packages downstream would need to

00:10:16,000 --> 00:10:20,560
recompile and so this is what aids us

00:10:18,000 --> 00:10:21,839
on being able to re reconfigure on a

00:10:20,560 --> 00:10:23,839
source code level

00:10:21,839 --> 00:10:25,279
without having to rebuild everything

00:10:23,839 --> 00:10:27,120
from source code

00:10:25,279 --> 00:10:28,959
and then there's also the pr service so

00:10:27,120 --> 00:10:30,560
the pr stands for package revision

00:10:28,959 --> 00:10:32,000
and so whenever you make a change to the

00:10:30,560 --> 00:10:34,800
configuration or

00:10:32,000 --> 00:10:36,399
something else of how a package a recipe

00:10:34,800 --> 00:10:37,920
is configured

00:10:36,399 --> 00:10:39,600
you need to have a way for your

00:10:37,920 --> 00:10:40,079
downstream binary users to be able to

00:10:39,600 --> 00:10:41,839
upgrade

00:10:40,079 --> 00:10:43,200
automatically and so the pr service

00:10:41,839 --> 00:10:44,640
handles this for you so that you don't

00:10:43,200 --> 00:10:46,320
have to remember to change the magic

00:10:44,640 --> 00:10:48,399
value and increment it and

00:10:46,320 --> 00:10:49,839
everything else package feeds are

00:10:48,399 --> 00:10:52,800
another obvious binary

00:10:49,839 --> 00:10:53,200
distribution these are based on standard

00:10:52,800 --> 00:10:55,200
both

00:10:53,200 --> 00:10:57,040
open source uh standard workstation

00:10:55,200 --> 00:10:57,839
style feeds such as debian and rpm

00:10:57,040 --> 00:10:59,279
format

00:10:57,839 --> 00:11:01,519
and then there's also an embedded format

00:10:59,279 --> 00:11:03,839
called ipk um

00:11:01,519 --> 00:11:04,560
so the octa project does not

00:11:03,839 --> 00:11:06,720
discriminate

00:11:04,560 --> 00:11:08,959
one format over another uh all the

00:11:06,720 --> 00:11:10,880
formats are relatively speaking equal

00:11:08,959 --> 00:11:12,000
and so when you pick one it's what do

00:11:10,880 --> 00:11:15,040
you need for

00:11:12,000 --> 00:11:16,880
your your system of choice

00:11:15,040 --> 00:11:19,200
the octa project then also can build the

00:11:16,880 --> 00:11:21,279
non-operating system components

00:11:19,200 --> 00:11:23,519
um so when i talk about non-operating

00:11:21,279 --> 00:11:27,040
system i'm typically talking about

00:11:23,519 --> 00:11:29,279
the items of your system that run before

00:11:27,040 --> 00:11:30,320
the linux kernel and so this would be

00:11:29,279 --> 00:11:31,839
your bootloaders

00:11:30,320 --> 00:11:34,320
um this would include being able to

00:11:31,839 --> 00:11:35,440
build or modify your dtbs to generate

00:11:34,320 --> 00:11:37,120
your system

00:11:35,440 --> 00:11:38,640
uh various firmwares that may be

00:11:37,120 --> 00:11:40,959
required in order to boot your

00:11:38,640 --> 00:11:43,680
your system for stage boot loaders i

00:11:40,959 --> 00:11:46,079
don't know things like that

00:11:43,680 --> 00:11:47,920
and then finally the octa project uh

00:11:46,079 --> 00:11:48,640
will produce an image and so we'll put

00:11:47,920 --> 00:11:50,399
together

00:11:48,640 --> 00:11:52,000
these packages that came from the build

00:11:50,399 --> 00:11:53,040
artifacts that came from the build

00:11:52,000 --> 00:11:54,800
configuration

00:11:53,040 --> 00:11:56,720
and construct an image and this image

00:11:54,800 --> 00:11:57,600
then can be loaded sound to an sd card

00:11:56,720 --> 00:12:01,760
and actually

00:11:57,600 --> 00:12:04,240
execute by doing this there really isn't

00:12:01,760 --> 00:12:05,920
that traditional workstation installer

00:12:04,240 --> 00:12:07,440
behavior that you would see on a debian

00:12:05,920 --> 00:12:08,800
or a red hat system

00:12:07,440 --> 00:12:10,079
but you have a starting point but then

00:12:08,800 --> 00:12:12,079
at that point you can then use the

00:12:10,079 --> 00:12:13,519
package management to augment and make

00:12:12,079 --> 00:12:16,320
changes to

00:12:13,519 --> 00:12:18,000
and package pre-built images are just

00:12:16,320 --> 00:12:19,680
one artifact of this but we can also do

00:12:18,000 --> 00:12:20,639
other kinds of images such as oci

00:12:19,680 --> 00:12:22,959
containers

00:12:20,639 --> 00:12:24,320
and so with a container i may not need

00:12:22,959 --> 00:12:25,839
the linux kernel

00:12:24,320 --> 00:12:27,839
but i'm going to need all the same

00:12:25,839 --> 00:12:30,800
application support i'm going to need to

00:12:27,839 --> 00:12:32,320
have different configurations different

00:12:30,800 --> 00:12:33,760
collections of software

00:12:32,320 --> 00:12:35,360
and i can do it from a common source

00:12:33,760 --> 00:12:37,440
code base and sometimes i can even do it

00:12:35,360 --> 00:12:38,800
from a common binary base

00:12:37,440 --> 00:12:40,959
but when we're talking about containers

00:12:38,800 --> 00:12:42,720
you may have a different configuration

00:12:40,959 --> 00:12:44,959
than you did for a more traditional

00:12:42,720 --> 00:12:46,880
linux system and so this is where we

00:12:44,959 --> 00:12:48,880
have the flexibility to do both

00:12:46,880 --> 00:12:50,160
which is quite important from the user's

00:12:48,880 --> 00:12:53,839
perspective

00:12:50,160 --> 00:12:55,519
next slide um as xilinx gets involved in

00:12:53,839 --> 00:12:57,279
this we have started to create our own

00:12:55,519 --> 00:12:58,480
binary distribution based on the octave

00:12:57,279 --> 00:13:00,320
project and of course we're starting

00:12:58,480 --> 00:13:02,000
with the source code because there isn't

00:13:00,320 --> 00:13:04,160
currently the octoproject binary

00:13:02,000 --> 00:13:05,760
distribution to embrace and extend

00:13:04,160 --> 00:13:07,519
and so when we do our own binary

00:13:05,760 --> 00:13:10,639
distribution what we're doing is

00:13:07,519 --> 00:13:13,440
following along the same lines we're um

00:13:10,639 --> 00:13:15,040
building up a very specific um build

00:13:13,440 --> 00:13:16,639
system configuration we have some

00:13:15,040 --> 00:13:18,079
scripts that we generated so that we're

00:13:16,639 --> 00:13:21,200
sure that we're building this

00:13:18,079 --> 00:13:22,000
the build in a prescribed order along

00:13:21,200 --> 00:13:24,000
those lines then

00:13:22,000 --> 00:13:25,040
we produce those intermediate artifacts

00:13:24,000 --> 00:13:27,279
the shared state

00:13:25,040 --> 00:13:28,880
the pr service the hash equivalency and

00:13:27,279 --> 00:13:30,639
then we make those available to our

00:13:28,880 --> 00:13:33,279
downstream customers

00:13:30,639 --> 00:13:35,120
we also will be generating dtbs file

00:13:33,279 --> 00:13:36,639
system and images i'm generable tool

00:13:35,120 --> 00:13:38,800
called wic

00:13:36,639 --> 00:13:40,800
as well as other components which become

00:13:38,800 --> 00:13:41,920
either intermediate artifacts or

00:13:40,800 --> 00:13:44,959
potentially

00:13:41,920 --> 00:13:45,920
final artifacts and then all this is

00:13:44,959 --> 00:13:48,480
really to give

00:13:45,920 --> 00:13:49,680
our application developers a quick place

00:13:48,480 --> 00:13:51,199
to get started

00:13:49,680 --> 00:13:52,720
in other words instead of building an

00:13:51,199 --> 00:13:54,320
operating system source code we want to

00:13:52,720 --> 00:13:56,160
give them an sd card image which is

00:13:54,320 --> 00:13:57,839
built from our binary artifacts

00:13:56,160 --> 00:13:59,199
and so then they can load that sd card

00:13:57,839 --> 00:14:00,639
image into the device

00:13:59,199 --> 00:14:02,399
boot up and then if they need some

00:14:00,639 --> 00:14:03,680
additional software they can use the dnf

00:14:02,399 --> 00:14:05,680
system to actually

00:14:03,680 --> 00:14:06,800
install that additional software from

00:14:05,680 --> 00:14:08,160
packages

00:14:06,800 --> 00:14:10,079
but along those same lines those

00:14:08,160 --> 00:14:12,399
developers may want to create an

00:14:10,079 --> 00:14:13,839
application to run on their device and

00:14:12,399 --> 00:14:17,360
so for those who provide an

00:14:13,839 --> 00:14:20,320
e-sdk which stands for extended sdk

00:14:17,360 --> 00:14:22,000
and the extended sdk is really a copy of

00:14:20,320 --> 00:14:23,760
the octa project build system plus the

00:14:22,000 --> 00:14:25,360
ability to build an application

00:14:23,760 --> 00:14:26,880
and the advantage of the octa project

00:14:25,360 --> 00:14:27,440
build system is that it allows you to

00:14:26,880 --> 00:14:30,639
build

00:14:27,440 --> 00:14:32,399
new sd card images as well as change

00:14:30,639 --> 00:14:34,000
in minor tweaks but change some of the

00:14:32,399 --> 00:14:36,240
configurations of the components

00:14:34,000 --> 00:14:38,240
so that you can actually optimize enable

00:14:36,240 --> 00:14:39,440
features disable features you don't want

00:14:38,240 --> 00:14:41,120
things like that

00:14:39,440 --> 00:14:43,120
and that allows our developers to create

00:14:41,120 --> 00:14:45,279
a new image and then of course we have

00:14:43,120 --> 00:14:48,000
the traditional sdk which is really the

00:14:45,279 --> 00:14:49,760
the cross compiler and and provides them

00:14:48,000 --> 00:14:52,000
the ability to just to build and

00:14:49,760 --> 00:14:53,360
build applications but what we find most

00:14:52,000 --> 00:14:54,480
of the time is that an application

00:14:53,360 --> 00:14:56,959
developer

00:14:54,480 --> 00:14:58,560
is savvy enough to actually want to

00:14:56,959 --> 00:15:01,199
install more software or

00:14:58,560 --> 00:15:02,240
slightly tweak a couple of the libraries

00:15:01,199 --> 00:15:03,600
that they're working with

00:15:02,240 --> 00:15:05,519
but they don't want to be an operating

00:15:03,600 --> 00:15:06,240
system developer and so that's why we we

00:15:05,519 --> 00:15:07,680
make

00:15:06,240 --> 00:15:12,639
all of these components available to

00:15:07,680 --> 00:15:15,519
them next slide

00:15:12,639 --> 00:15:17,839
and so really what this does is it um

00:15:15,519 --> 00:15:21,760
brings us to this use case evolution

00:15:17,839 --> 00:15:23,920
how do we perceive systems being used

00:15:21,760 --> 00:15:25,440
how do we want to see these systems

00:15:23,920 --> 00:15:26,480
and so the number one thing that we need

00:15:25,440 --> 00:15:28,639
to be able to do with a binary

00:15:26,480 --> 00:15:30,240
distribution is we've got to hide the

00:15:28,639 --> 00:15:32,720
learning and complexity curve

00:15:30,240 --> 00:15:34,480
until the user needs it and so going

00:15:32,720 --> 00:15:36,399
back to the previous slide the key thing

00:15:34,480 --> 00:15:37,680
here is give them an sd card so they can

00:15:36,399 --> 00:15:39,600
just boot them box up

00:15:37,680 --> 00:15:41,120
and start right away start hacking on

00:15:39,600 --> 00:15:42,800
things figure things out

00:15:41,120 --> 00:15:45,680
when they need to get to that first step

00:15:42,800 --> 00:15:47,440
of oh i need to extend or modify

00:15:45,680 --> 00:15:49,680
what was already there now they can jump

00:15:47,440 --> 00:15:51,600
into that esdk and start that path and

00:15:49,680 --> 00:15:53,199
that journey towards modification

00:15:51,600 --> 00:15:54,800
so eventually they may get to the point

00:15:53,199 --> 00:15:56,320
no i really want to customize the whole

00:15:54,800 --> 00:15:58,000
thing i want to change optimization

00:15:56,320 --> 00:15:59,519
levels of software everything else

00:15:58,000 --> 00:16:02,000
and that's when they can do the full

00:15:59,519 --> 00:16:03,519
build from source but they have the

00:16:02,000 --> 00:16:06,000
starting point of the configuration of

00:16:03,519 --> 00:16:08,399
the binary distribution to go off of

00:16:06,000 --> 00:16:10,079
the other thing that is evolving in the

00:16:08,399 --> 00:16:11,440
system as i mentioned before the octo

00:16:10,079 --> 00:16:13,600
project can build

00:16:11,440 --> 00:16:15,279
um components that exist before the

00:16:13,600 --> 00:16:16,000
linux kernel boot loaders things like

00:16:15,279 --> 00:16:17,519
that

00:16:16,000 --> 00:16:19,360
but it's more than just boot loaders

00:16:17,519 --> 00:16:20,959
it's also capable of building systems

00:16:19,360 --> 00:16:22,720
for heterogeneous components

00:16:20,959 --> 00:16:24,079
firmware is the obvious one that i've

00:16:22,720 --> 00:16:27,040
already spoken to

00:16:24,079 --> 00:16:27,600
but mcus are another very uh common

00:16:27,040 --> 00:16:31,040
behavior

00:16:27,600 --> 00:16:31,680
so if um some case in sonic's parts we

00:16:31,040 --> 00:16:35,519
have both

00:16:31,680 --> 00:16:38,959
same a53 and cortex r5 on the same die

00:16:35,519 --> 00:16:41,040
and so they may build first stage boot

00:16:38,959 --> 00:16:43,199
loaders for the cortex a53

00:16:41,040 --> 00:16:45,440
but they may also build some mcu

00:16:43,199 --> 00:16:46,480
software for their cortex's r5 and

00:16:45,440 --> 00:16:49,040
they're going to want to do that

00:16:46,480 --> 00:16:50,480
oftentimes in a single build single

00:16:49,040 --> 00:16:52,480
build configuration

00:16:50,480 --> 00:16:54,160
but the output becomes heterogeneous

00:16:52,480 --> 00:16:55,040
this can be extended further into

00:16:54,160 --> 00:16:57,199
heterogeneous

00:16:55,040 --> 00:16:59,120
systems where it's not just on the same

00:16:57,199 --> 00:17:00,079
die but it's actually multiple cards in

00:16:59,120 --> 00:17:02,000
a chassis

00:17:00,079 --> 00:17:04,079
or multiple chassis in a rack or

00:17:02,000 --> 00:17:06,319
multiple racks in a data center

00:17:04,079 --> 00:17:07,839
something like that and the octa project

00:17:06,319 --> 00:17:10,559
has that ability to scale

00:17:07,839 --> 00:17:11,839
up to whatever heterogeneous system that

00:17:10,559 --> 00:17:15,039
you need

00:17:11,839 --> 00:17:15,679
i'm going to pass it off to bruce yeah

00:17:15,039 --> 00:17:17,679
and

00:17:15,679 --> 00:17:19,919
so like mark's been saying that you know

00:17:17,679 --> 00:17:22,400
we're saying that we're seeing that

00:17:19,919 --> 00:17:24,400
both at the yocta project level and at

00:17:22,400 --> 00:17:26,959
the xilinx

00:17:24,400 --> 00:17:27,760
level that use cases have evolved

00:17:26,959 --> 00:17:30,640
through

00:17:27,760 --> 00:17:32,080
here's an image dump it on if you need

00:17:30,640 --> 00:17:33,200
to ever change it you're going to dump

00:17:32,080 --> 00:17:34,240
that image again and you're going to

00:17:33,200 --> 00:17:35,840
reboot the

00:17:34,240 --> 00:17:38,080
the system right so we're talking about

00:17:35,840 --> 00:17:39,200
more than just images for flashing so

00:17:38,080 --> 00:17:41,760
they might be

00:17:39,200 --> 00:17:44,080
uh containers they could be the

00:17:41,760 --> 00:17:44,480
generation of binary deltas for over the

00:17:44,080 --> 00:17:46,960
year

00:17:44,480 --> 00:17:48,120
in field updates we want those all to be

00:17:46,960 --> 00:17:49,600
based on the same

00:17:48,120 --> 00:17:51,600
[Music]

00:17:49,600 --> 00:17:52,640
source and hopefully not always going

00:17:51,600 --> 00:17:54,480
all the way back to the source they're

00:17:52,640 --> 00:17:55,600
based on sort of the binary outputs as

00:17:54,480 --> 00:17:57,840
an intermediate step

00:17:55,600 --> 00:17:59,280
so that's to enable us to do deep

00:17:57,840 --> 00:18:01,520
software stocks like

00:17:59,280 --> 00:18:02,960
you know kubernetes k3s all the

00:18:01,520 --> 00:18:05,039
different uh flavors uh

00:18:02,960 --> 00:18:06,080
cube edge you name it something that's

00:18:05,039 --> 00:18:07,840
uh more embedded

00:18:06,080 --> 00:18:09,520
or just to generate you know small you

00:18:07,840 --> 00:18:10,320
know just a microservice whether it's

00:18:09,520 --> 00:18:12,880
delivered with

00:18:10,320 --> 00:18:15,280
kubernetes or not and that we're seeing

00:18:12,880 --> 00:18:17,600
more blended edge in enterprise

00:18:15,280 --> 00:18:18,960
features you know more than just a

00:18:17,600 --> 00:18:20,559
package installer

00:18:18,960 --> 00:18:22,559
or more than just an operating system

00:18:20,559 --> 00:18:24,080
installer sort of you know we want

00:18:22,559 --> 00:18:26,080
uh situations where we can do

00:18:24,080 --> 00:18:27,280
accelerated containers where we can do

00:18:26,080 --> 00:18:30,000
safe and secure

00:18:27,280 --> 00:18:31,679
containers where you know there's a

00:18:30,000 --> 00:18:32,880
project that xylem says called run x

00:18:31,679 --> 00:18:35,360
where we can do

00:18:32,880 --> 00:18:36,960
um zen-backed containers in a

00:18:35,360 --> 00:18:38,400
heterogeneous system and make them safe

00:18:36,960 --> 00:18:40,400
and secure

00:18:38,400 --> 00:18:42,320
and we want to be able to produce that

00:18:40,400 --> 00:18:44,559
from the same uh

00:18:42,320 --> 00:18:45,679
binaries and sources you know small low

00:18:44,559 --> 00:18:47,760
foot run time so you have

00:18:45,679 --> 00:18:49,039
you need to be able to optimize um and

00:18:47,760 --> 00:18:50,480
then i mentioned you know maintenance

00:18:49,039 --> 00:18:52,240
and in-service upgrades you need to be

00:18:50,480 --> 00:18:55,440
able to underpin this with the same

00:18:52,240 --> 00:18:56,960
technology and along

00:18:55,440 --> 00:18:59,440
the lines of where we started on this

00:18:56,960 --> 00:19:03,679
slide about hiding the learning curve

00:18:59,440 --> 00:19:06,240
um the use case mobility is key meaning

00:19:03,679 --> 00:19:07,120
you start at one just an image to boot

00:19:06,240 --> 00:19:08,960
and then you've

00:19:07,120 --> 00:19:10,799
also need to do over-the-air updates or

00:19:08,960 --> 00:19:12,720
you need to deploy containers

00:19:10,799 --> 00:19:14,240
or you need to have application

00:19:12,720 --> 00:19:15,760
developers or or

00:19:14,240 --> 00:19:17,280
different parts of your of your

00:19:15,760 --> 00:19:20,799
organization that there is

00:19:17,280 --> 00:19:22,960
a way a defined and structured way

00:19:20,799 --> 00:19:24,000
to move you know to change use cases

00:19:22,960 --> 00:19:26,000
without needing to throw

00:19:24,000 --> 00:19:27,840
away your build system change from some

00:19:26,000 --> 00:19:28,640
binaries to a completely different build

00:19:27,840 --> 00:19:30,720
process

00:19:28,640 --> 00:19:32,640
there should be a defined way to to do

00:19:30,720 --> 00:19:34,640
it all and

00:19:32,640 --> 00:19:36,640
we're saying that the yakta project

00:19:34,640 --> 00:19:39,760
either has or will have

00:19:36,640 --> 00:19:43,360
structured ways to do that

00:19:39,760 --> 00:19:45,200
so beyond sort of my last more technical

00:19:43,360 --> 00:19:47,120
point is beyond just

00:19:45,200 --> 00:19:49,039
straight up binary packages you know

00:19:47,120 --> 00:19:51,760
rpms ipks devs

00:19:49,039 --> 00:19:53,760
you know what should you be considering

00:19:51,760 --> 00:19:56,400
when you're talking about

00:19:53,760 --> 00:19:57,120
ease of use and binary packages and a

00:19:56,400 --> 00:20:01,440
target

00:19:57,120 --> 00:20:03,200
so a big thing that you should be

00:20:01,440 --> 00:20:05,120
is becoming more common is to worry

00:20:03,200 --> 00:20:07,919
about reproducibility

00:20:05,120 --> 00:20:08,799
can you build those same binaries on two

00:20:07,919 --> 00:20:10,720
different build

00:20:08,799 --> 00:20:12,400
platforms and have them be exactly the

00:20:10,720 --> 00:20:14,240
same and provably the same

00:20:12,400 --> 00:20:16,120
and that's a core youtube project

00:20:14,240 --> 00:20:17,919
capability and if you look at

00:20:16,120 --> 00:20:20,080
reproduciblebuilds.org you'll see the

00:20:17,919 --> 00:20:22,159
registration of what it can do

00:20:20,080 --> 00:20:23,360
licensing again it's a core capability

00:20:22,159 --> 00:20:26,240
you need to be worried about this

00:20:23,360 --> 00:20:27,760
you can't just throw a binaries well you

00:20:26,240 --> 00:20:29,520
can but you shouldn't

00:20:27,760 --> 00:20:31,039
without knowing how the licensing goes

00:20:29,520 --> 00:20:33,440
along with the binaries again

00:20:31,039 --> 00:20:35,200
core capability of the octa project is

00:20:33,440 --> 00:20:38,640
there a way to customize those

00:20:35,200 --> 00:20:40,159
those packages um in a standard

00:20:38,640 --> 00:20:42,400
structured way

00:20:40,159 --> 00:20:43,919
will you get support from the ecosystem

00:20:42,400 --> 00:20:45,679
if you modify

00:20:43,919 --> 00:20:47,600
if you need to embrace and extend those

00:20:45,679 --> 00:20:49,520
binaries you know if or not

00:20:47,600 --> 00:20:52,000
is there a way to get support from the

00:20:49,520 --> 00:20:54,000
the more than just binary packages

00:20:52,000 --> 00:20:55,760
can you extend it to the platform level

00:20:54,000 --> 00:20:56,400
can you define a whole new platform new

00:20:55,760 --> 00:20:59,520
bsp

00:20:56,400 --> 00:21:01,520
new non-os things can you do that

00:20:59,520 --> 00:21:02,720
um you need to be able to worry about

00:21:01,520 --> 00:21:04,720
both application

00:21:02,720 --> 00:21:06,080
and system developers and some of the

00:21:04,720 --> 00:21:07,280
things that we've talked about whether

00:21:06,080 --> 00:21:09,440
it be esdk

00:21:07,280 --> 00:21:12,240
the build system the point is the octa

00:21:09,440 --> 00:21:15,039
project and open embedded can do that

00:21:12,240 --> 00:21:17,200
and also is there a defined process for

00:21:15,039 --> 00:21:20,320
support maintenance and updates

00:21:17,200 --> 00:21:22,000
you don't want to the days of

00:21:20,320 --> 00:21:23,919
building an image flashing and never

00:21:22,000 --> 00:21:26,799
touching it for 20 years are pretty much

00:21:23,919 --> 00:21:30,559
gone in most systems so you need to have

00:21:26,799 --> 00:21:33,440
be thinking of that beyond packages

00:21:30,559 --> 00:21:35,200
um and the point we're trying to make

00:21:33,440 --> 00:21:37,200
from this is that when you add

00:21:35,200 --> 00:21:38,320
many of those capabilities or things to

00:21:37,200 --> 00:21:41,280
consider

00:21:38,320 --> 00:21:42,559
to a traditional you know enterprise or

00:21:41,280 --> 00:21:45,039
other distro

00:21:42,559 --> 00:21:45,919
you end up either doing it ad hoc or

00:21:45,039 --> 00:21:47,600
you're you're

00:21:45,919 --> 00:21:49,200
redoing scripting or you're doing

00:21:47,600 --> 00:21:51,200
something um

00:21:49,200 --> 00:21:52,880
that's very custom to how you need to do

00:21:51,200 --> 00:21:54,960
it and it can be less structured than

00:21:52,880 --> 00:21:56,559
the yocto project

00:21:54,960 --> 00:21:58,159
and once you've had to do that all of a

00:21:56,559 --> 00:22:00,480
sudden these these you know

00:21:58,159 --> 00:22:02,400
the octa project is complex or whatever

00:22:00,480 --> 00:22:03,840
you that people may

00:22:02,400 --> 00:22:05,280
think uh we're saying that the

00:22:03,840 --> 00:22:06,799
complexity and the learning curves are

00:22:05,280 --> 00:22:08,799
very similar between

00:22:06,799 --> 00:22:10,880
um where you started from just grabbing

00:22:08,799 --> 00:22:12,400
these binaries to these use cases and if

00:22:10,880 --> 00:22:14,480
you would have started with

00:22:12,400 --> 00:22:16,799
the octa project to do something very

00:22:14,480 --> 00:22:16,799
similar

00:22:18,640 --> 00:22:22,000
so there is we've hinted a few times

00:22:21,440 --> 00:22:24,799
there's

00:22:22,000 --> 00:22:25,520
we're not this presentation wasn't about

00:22:24,799 --> 00:22:29,679
things

00:22:25,520 --> 00:22:33,120
only things that exist or

00:22:29,679 --> 00:22:35,840
um are completely out of the box or

00:22:33,120 --> 00:22:36,720
are scriptable it's about you know what

00:22:35,840 --> 00:22:38,480
is there

00:22:36,720 --> 00:22:40,400
what the plumbing is and how you can put

00:22:38,480 --> 00:22:42,720
it together to do these

00:22:40,400 --> 00:22:44,240
produce these various different binary

00:22:42,720 --> 00:22:48,080
artifacts

00:22:44,240 --> 00:22:49,840
there's still more to do there's always

00:22:48,080 --> 00:22:52,000
things that we can do to make it easier

00:22:49,840 --> 00:22:53,360
for people to get started for developers

00:22:52,000 --> 00:22:55,440
to get started

00:22:53,360 --> 00:22:56,960
for different sort of roles in an

00:22:55,440 --> 00:22:58,960
organization to get started so

00:22:56,960 --> 00:23:00,320
some of the future work and the things

00:22:58,960 --> 00:23:03,600
that we we see are

00:23:00,320 --> 00:23:06,400
on that front as well as doing

00:23:03,600 --> 00:23:08,400
potentially some sort of core reference

00:23:06,400 --> 00:23:10,000
distribution because not everybody needs

00:23:08,400 --> 00:23:12,320
to be building

00:23:10,000 --> 00:23:13,760
grep and less you know is there a way

00:23:12,320 --> 00:23:17,039
that we can do

00:23:13,760 --> 00:23:20,400
sort of a core decently optimized

00:23:17,039 --> 00:23:23,520
binary package feed that can be

00:23:20,400 --> 00:23:25,520
expressed embraced and extended

00:23:23,520 --> 00:23:27,360
by the the consumers the downstream

00:23:25,520 --> 00:23:31,039
consumers of the octa project

00:23:27,360 --> 00:23:34,159
also you know more pre-built images

00:23:31,039 --> 00:23:35,760
um more and again like i talked about i

00:23:34,159 --> 00:23:36,000
do a lot of virtualization and container

00:23:35,760 --> 00:23:38,320
things

00:23:36,000 --> 00:23:39,120
for the project so near and dear to my

00:23:38,320 --> 00:23:42,320
heart is more

00:23:39,120 --> 00:23:44,400
sort of you know docker hub if you will

00:23:42,320 --> 00:23:46,720
based reference container so that you

00:23:44,400 --> 00:23:50,159
don't you can reach for something

00:23:46,720 --> 00:23:52,799
um as a in a docker build kind of

00:23:50,159 --> 00:23:53,600
scenario that is based on all of those

00:23:52,799 --> 00:23:55,679
great things from the

00:23:53,600 --> 00:23:57,440
octo project but that you don't have to

00:23:55,679 --> 00:23:58,159
start there but you know that you can

00:23:57,440 --> 00:23:59,520
get there

00:23:58,159 --> 00:24:01,520
to reproduce that reference based

00:23:59,520 --> 00:24:03,360
container so you can get started quickly

00:24:01,520 --> 00:24:05,440
but that those base containers are there

00:24:03,360 --> 00:24:08,400
such that you can simply

00:24:05,440 --> 00:24:12,000
include them add more packages and again

00:24:08,400 --> 00:24:14,240
more embracing and extending

00:24:12,000 --> 00:24:15,600
and uh you know that's it for our

00:24:14,240 --> 00:24:17,120
presentation mark i don't know if you

00:24:15,600 --> 00:24:19,440
had anything you wanted to add before we

00:24:17,120 --> 00:24:21,360
go to questions but uh

00:24:19,440 --> 00:24:22,720
the only thing i'll add is the embrace

00:24:21,360 --> 00:24:23,679
and extend is really what we're trying

00:24:22,720 --> 00:24:26,159
to get to

00:24:23,679 --> 00:24:27,279
we think that uh having a reference

00:24:26,159 --> 00:24:28,960
distribution

00:24:27,279 --> 00:24:31,120
uh from the octa project would then

00:24:28,960 --> 00:24:34,240
allow us and others to be able to

00:24:31,120 --> 00:24:35,840
start with a good known starting point

00:24:34,240 --> 00:24:37,360
and then add the things that we're good

00:24:35,840 --> 00:24:39,840
at add our own

00:24:37,360 --> 00:24:40,960
um in our case silicon parts uh to the

00:24:39,840 --> 00:24:42,640
to the environment

00:24:40,960 --> 00:24:44,240
have other application developers put

00:24:42,640 --> 00:24:46,400
their own optimizations in

00:24:44,240 --> 00:24:47,760
or operating system vendors optimize for

00:24:46,400 --> 00:24:51,760
certain certain

00:24:47,760 --> 00:24:53,600
activities certain workflows all these

00:24:51,760 --> 00:24:55,440
things so that's really the place in the

00:24:53,600 --> 00:24:58,400
future that we need

00:24:55,440 --> 00:25:00,080
help is to get this reference

00:24:58,400 --> 00:25:02,720
distribution off the ground so that it

00:25:00,080 --> 00:25:03,760
can be reused

00:25:02,720 --> 00:25:05,840
all right thank you everybody for

00:25:03,760 --> 00:25:14,480
listening and we will

00:25:05,840 --> 00:25:14,480

YouTube URL: https://www.youtube.com/watch?v=tR-4gq-pHew


