Title: HKG18-301 - Dramatically Accelerate 96Board Software via an FPGA with Integrated Processors
Publication date: 2019-05-09
Playlist: Linaro Connect Hong Kong 2018
Description: 
	"Session ID: HKG18-301
Session Name: HKG18-301 - Dramatically Accelerate 96Board Software via an FPGA with Integrated Processors
Speaker: Glenn Steiner
Track: LITE


★ Session Summary ★
Key Takeaways: 

With the drive to increase integration, reduce system costs, accelerate performance, and enhance reliability, software developers are discovering the processor they would like to target is simply not fast enough.  This session will help you the system architect or software developer understand how you can architect and develop software on an FPGA integrated processor, and accelerate software code via FPGA accelerators.

Abstract: 
As a software developer, in order to meet system level performance requirements, you may have realized that your next software project will be targeting a processor inside of an FPGA.  How will this impact your development process and what benefits might you gain with this tight integration of processor and FPGA?  Starting from the basics of what FPGAs are (in terms of software programming), this session will provide a simple to understand primer of what modern FPGAs with embedded processors can do.  We will wrap up with examples of how high level synthesis tools can move software to programmable logic hardware enabling dramatic software acceleration.


---------------------------------------------------
★ Resources ★
Event Page: http://connect.linaro.org/resource/hkg18/hkg18-301/
Presentation: http://connect.linaro.org.s3.amazonaws.com/hkg18/presentations/hkg18-301.pdf
Video: http://connect.linaro.org.s3.amazonaws.com/hkg18/videos/hkg18-301.mp4
 ---------------------------------------------------
★ Event Details ★
Linaro Connect Hong Kong 2018 (HKG18)
19-23 March 2018 
Regal Airport Hotel Hong Kong

---------------------------------------------------
Keyword: LITE
'http://www.linaro.org'
'http://connect.linaro.org'
---------------------------------------------------
Follow us on Social Media
https://www.facebook.com/LinaroOrg
https://www.youtube.com/user/linaroorg?sub_confirmation=1
https://www.linkedin.com/company/1026961"
Captions: 
	00:00:04,530 --> 00:00:06,590
you

00:00:14,540 --> 00:00:22,800
well thank you everyone for showing up

00:00:18,360 --> 00:00:26,160
today we just had great presentation on

00:00:22,800 --> 00:00:28,110
96 boards and some of the offerings that

00:00:26,160 --> 00:00:29,660
are available and I'd like to have an

00:00:28,110 --> 00:00:32,070
opportunity to talk a little bit about

00:00:29,660 --> 00:00:34,170
what we have in terms of the ultra

00:00:32,070 --> 00:00:35,850
ninety-six board earlier this morning

00:00:34,170 --> 00:00:38,910
there was series of sessions in this

00:00:35,850 --> 00:00:41,790
room on artificial intelligence and also

00:00:38,910 --> 00:00:44,520
addressed that a little bit and then we

00:00:41,790 --> 00:00:46,859
had Tomas give a keynote this morning

00:00:44,520 --> 00:00:48,390
and you'll actually see that he and I

00:00:46,859 --> 00:00:49,820
kind of think alike because our deck

00:00:48,390 --> 00:00:52,350
could slide dicks are somewhat similar

00:00:49,820 --> 00:00:54,089
but I have a little bit longer time than

00:00:52,350 --> 00:00:55,999
he did so I'll be diving into a couple

00:00:54,089 --> 00:01:01,640
of topics a little bit further than

00:00:55,999 --> 00:01:04,350
Tomas had an opportunity to cover so

00:01:01,640 --> 00:01:05,610
we'll like to tell you a little bit

00:01:04,350 --> 00:01:08,310
about what field-programmable gate

00:01:05,610 --> 00:01:11,280
arrays are their value proposition why

00:01:08,310 --> 00:01:13,020
you should bother using them I'm curious

00:01:11,280 --> 00:01:14,159
are they hardware engineers in this room

00:01:13,020 --> 00:01:16,500
there's no point am I asking about

00:01:14,159 --> 00:01:18,690
software engineers there's a couple of

00:01:16,500 --> 00:01:19,350
eiling's guys one guy another guy raised

00:01:18,690 --> 00:01:22,560
his ham

00:01:19,350 --> 00:01:24,480
okay so traditionally FPGAs have been a

00:01:22,560 --> 00:01:26,370
hardware thing and now we're trying to

00:01:24,480 --> 00:01:29,670
make them and we are actually making

00:01:26,370 --> 00:01:32,040
them a software thing and so I'd like to

00:01:29,670 --> 00:01:33,120
kind of tell you why there can be useful

00:01:32,040 --> 00:01:34,950
for you

00:01:33,120 --> 00:01:38,790
we'll go into the concept of

00:01:34,950 --> 00:01:41,160
heterogenous all programmable devices so

00:01:38,790 --> 00:01:44,040
we take the hel concept header genius a

00:01:41,160 --> 00:01:47,070
little bit further than what you may be

00:01:44,040 --> 00:01:49,800
used to then we'll go into how do you go

00:01:47,070 --> 00:01:53,010
about creating code for it do you have

00:01:49,800 --> 00:01:55,110
to fear anything then I'll talk a little

00:01:53,010 --> 00:01:57,720
bit more about the ultra 96 development

00:01:55,110 --> 00:01:59,520
platform will go into our software

00:01:57,720 --> 00:02:01,560
acceleration design example a little

00:01:59,520 --> 00:02:03,240
more detailed than Tomas had an

00:02:01,560 --> 00:02:07,620
opportunity to cover this morning and

00:02:03,240 --> 00:02:08,940
then wrap up and incidentally tomorrow

00:02:07,620 --> 00:02:10,800
at 11:00 a.m.

00:02:08,940 --> 00:02:13,530
magnum I actually have another

00:02:10,800 --> 00:02:15,959
presentation goes into even more detail

00:02:13,530 --> 00:02:22,560
about the implementation of neural

00:02:15,959 --> 00:02:24,420
networks on our devices so inevitably

00:02:22,560 --> 00:02:25,880
always have to start out with marketing

00:02:24,420 --> 00:02:28,700
slider to

00:02:25,880 --> 00:02:30,380
I think as designers especially if

00:02:28,700 --> 00:02:32,810
you're an embedded system designer

00:02:30,380 --> 00:02:37,310
you're constantly challenged you can't

00:02:32,810 --> 00:02:40,670
challenge with how do I get this

00:02:37,310 --> 00:02:42,710
particular design implementation running

00:02:40,670 --> 00:02:43,640
in this system how can I make sure it's

00:02:42,710 --> 00:02:46,940
fast enough

00:02:43,640 --> 00:02:48,830
meet my power goals and of course fit

00:02:46,940 --> 00:02:53,030
into a smaller box and be more

00:02:48,830 --> 00:02:57,260
cost-effective there we are constantly

00:02:53,030 --> 00:03:00,080
being pushed to be creative and at the

00:02:57,260 --> 00:03:02,240
same time how do we've heard some

00:03:00,080 --> 00:03:04,100
sessions about security and reliability

00:03:02,240 --> 00:03:06,800
how can I make sure that I protect

00:03:04,100 --> 00:03:08,900
what's on my device how can I protect my

00:03:06,800 --> 00:03:12,560
intellectual property and how can I make

00:03:08,900 --> 00:03:14,570
sure it's not hacked and with the work

00:03:12,560 --> 00:03:17,210
that silence has been doing for many

00:03:14,570 --> 00:03:19,400
years we've kind of tackled all these

00:03:17,210 --> 00:03:21,620
areas you can see that we've gone into

00:03:19,400 --> 00:03:23,500
many different markets all the way from

00:03:21,620 --> 00:03:26,510
powering the Internet infrastructure

00:03:23,500 --> 00:03:29,240
wireless audio video cloud and data

00:03:26,510 --> 00:03:31,850
centers industrial automotive markets

00:03:29,240 --> 00:03:33,980
we've pretty much done it all with our

00:03:31,850 --> 00:03:38,360
devices through our customers and

00:03:33,980 --> 00:03:41,150
partners and we are now looking at even

00:03:38,360 --> 00:03:43,460
moving it broader most you probably have

00:03:41,150 --> 00:03:46,610
not heard of Xilinx before me this event

00:03:43,460 --> 00:03:50,660
and that's because we've generally been

00:03:46,610 --> 00:03:54,590
sitting out there on the edge of and

00:03:50,660 --> 00:03:55,880
into the infrastructure and we believe

00:03:54,590 --> 00:03:58,880
that we're going to be moving more and

00:03:55,880 --> 00:04:00,650
more towards the edge into this Internet

00:03:58,880 --> 00:04:02,930
of Things and that's part of the reason

00:04:00,650 --> 00:04:06,980
we have the ultra 96 board that we've

00:04:02,930 --> 00:04:09,050
introduced at this event so what is a

00:04:06,980 --> 00:04:13,430
field programmable gate array well I

00:04:09,050 --> 00:04:14,930
went to the authority Wikipedia and it

00:04:13,430 --> 00:04:16,459
says a field programmable gate array is

00:04:14,930 --> 00:04:18,410
an integrated circuit designed to be

00:04:16,459 --> 00:04:20,930
configured by the customer or designer

00:04:18,410 --> 00:04:23,900
after manufacturing hence field

00:04:20,930 --> 00:04:27,920
programmable so the best way to put it

00:04:23,900 --> 00:04:29,480
is if you were to look at years ago your

00:04:27,920 --> 00:04:30,920
hardware engineer your hardware engineer

00:04:29,480 --> 00:04:32,630
went into a catalog he selected a whole

00:04:30,920 --> 00:04:34,400
bunch of chips he taped those chips

00:04:32,630 --> 00:04:37,370
wired of them up on a schematic laid it

00:04:34,400 --> 00:04:38,720
out on a board and hopefully it worked

00:04:37,370 --> 00:04:41,819
the first time

00:04:38,720 --> 00:04:43,169
and if you went to him and said hey can

00:04:41,819 --> 00:04:45,060
you go charge change that hardware

00:04:43,169 --> 00:04:47,280
design he look at you and go up no

00:04:45,060 --> 00:04:49,949
problem three months I'll have it done

00:04:47,280 --> 00:04:53,150
for you so something that was

00:04:49,949 --> 00:04:55,560
challenging difficult time consuming

00:04:53,150 --> 00:04:58,889
what the field programmable gate array

00:04:55,560 --> 00:05:00,690
does for hardware is what you and all of

00:04:58,889 --> 00:05:02,910
us have been used to for many years in

00:05:00,690 --> 00:05:05,669
terms of software in other words we

00:05:02,910 --> 00:05:07,560
create some code we download it we run

00:05:05,669 --> 00:05:09,810
it we see if it works and we go and

00:05:07,560 --> 00:05:12,780
debug it and then it makes some code

00:05:09,810 --> 00:05:14,580
fixes and do it again and with an F

00:05:12,780 --> 00:05:18,479
field programmable gate array you can do

00:05:14,580 --> 00:05:20,370
exactly that type of thing now as you

00:05:18,479 --> 00:05:23,280
heard earlier if you're at the keynote

00:05:20,370 --> 00:05:27,060
what is inside of it well we talked a

00:05:23,280 --> 00:05:29,909
lot about configurable logic blocks and

00:05:27,060 --> 00:05:32,610
a configurable logic block in its

00:05:29,909 --> 00:05:36,300
simplest form can take on some very

00:05:32,610 --> 00:05:39,840
simple logic configurations it can be a

00:05:36,300 --> 00:05:41,699
NAND gate and or gate or an inverter as

00:05:39,840 --> 00:05:44,330
a digital designer you learn at the very

00:05:41,699 --> 00:05:46,919
beginning those are basic functions

00:05:44,330 --> 00:05:48,840
however these because they're

00:05:46,919 --> 00:05:50,940
configurable and our devices happen to

00:05:48,840 --> 00:05:52,800
have six inputs they can take any launch

00:05:50,940 --> 00:05:56,729
a combination of those six inputs and

00:05:52,800 --> 00:05:58,229
generate an output now if you were to a

00:05:56,729 --> 00:05:59,820
digital designer you'd learn over the

00:05:58,229 --> 00:06:01,199
years that hey if you take enough of

00:05:59,820 --> 00:06:03,180
those configure lists you can generate a

00:06:01,199 --> 00:06:05,159
flip-flop once you have a flip-flop you

00:06:03,180 --> 00:06:08,250
have memory storage element and you can

00:06:05,159 --> 00:06:09,630
keep expanding from there cool okay so

00:06:08,250 --> 00:06:14,639
we've got these logic gates the other

00:06:09,630 --> 00:06:17,370
piece of magic is that we lay down large

00:06:14,639 --> 00:06:21,960
rays of wires that are horizontal and

00:06:17,370 --> 00:06:24,240
vertical and which are basically traffic

00:06:21,960 --> 00:06:26,280
lanes to move the digital signals around

00:06:24,240 --> 00:06:28,080
and so we have what's known as

00:06:26,280 --> 00:06:30,210
configurable interconnect in other words

00:06:28,080 --> 00:06:32,520
we can take the output of any logic gate

00:06:30,210 --> 00:06:36,139
and connect it to the input or multiple

00:06:32,520 --> 00:06:38,520
inputs of any other logic gate and be

00:06:36,139 --> 00:06:43,259
biological extension then we can create

00:06:38,520 --> 00:06:44,849
any arbitrary logic design now obviously

00:06:43,259 --> 00:06:47,430
you have to get information on and off

00:06:44,849 --> 00:06:50,330
your chip and so we have input pins and

00:06:47,430 --> 00:06:50,330
we have output pins

00:06:50,339 --> 00:06:56,770
and as you heard Tomas indicate over the

00:06:53,740 --> 00:06:58,330
years we discovered hey well yes we can

00:06:56,770 --> 00:07:00,129
create lots of flip-flops but that's

00:06:58,330 --> 00:07:02,529
very costly and logic so let's add some

00:07:00,129 --> 00:07:04,029
block ram then we discovered a lot of

00:07:02,529 --> 00:07:05,740
customers we're doing digital signal

00:07:04,029 --> 00:07:09,759
processing functions so we added with

00:07:05,740 --> 00:07:12,369
DSP blocks and then somebody looked at

00:07:09,759 --> 00:07:14,259
one of our devices and said you know

00:07:12,369 --> 00:07:16,869
you've got enough logic there I can

00:07:14,259 --> 00:07:18,399
implement a state machine cool and then

00:07:16,869 --> 00:07:20,649
somebody else said you got enough logic

00:07:18,399 --> 00:07:21,969
there and that Nate latest-generation I

00:07:20,649 --> 00:07:24,909
can name the land a small

00:07:21,969 --> 00:07:27,339
microcontroller and so over the years

00:07:24,909 --> 00:07:29,379
silence actually invented a

00:07:27,339 --> 00:07:32,139
microcontroller we call it the micro

00:07:29,379 --> 00:07:34,539
blaze it's a soft processor that is just

00:07:32,139 --> 00:07:36,309
configured now you think hey that's

00:07:34,539 --> 00:07:37,779
probably pretty primitive but if you

00:07:36,309 --> 00:07:39,399
start looking at today's latest

00:07:37,779 --> 00:07:40,719
generation of micro blaze it has

00:07:39,399 --> 00:07:42,849
something you know as things like a

00:07:40,719 --> 00:07:44,279
memory management unit you can boot and

00:07:42,849 --> 00:07:46,599
run Linux

00:07:44,279 --> 00:07:48,909
all right just kind of gives you the

00:07:46,599 --> 00:07:52,240
feel of what can be done with all this

00:07:48,909 --> 00:07:56,469
logic now of course if you think about

00:07:52,240 --> 00:07:57,879
it inherently using all that logic to

00:07:56,469 --> 00:08:00,939
build things like a micro blaze

00:07:57,879 --> 00:08:02,620
processor consumes a lot of logic so

00:08:00,939 --> 00:08:03,879
over the years we said you know what

00:08:02,620 --> 00:08:07,149
let's just start hardening other

00:08:03,879 --> 00:08:10,059
elements and you heard it the original

00:08:07,149 --> 00:08:14,279
keynote that originally we started with

00:08:10,059 --> 00:08:18,249
PowerPC then we saw the light and we

00:08:14,279 --> 00:08:20,529
implemented the ARM architecture start

00:08:18,249 --> 00:08:23,649
out with ARM Cortex a9 now we're up to

00:08:20,529 --> 00:08:26,529
the arm cortex a53 as our application

00:08:23,649 --> 00:08:30,519
processor so we've been building this

00:08:26,529 --> 00:08:34,779
ongoing infrastructure in our devices to

00:08:30,519 --> 00:08:37,240
the point of where a lot of us start

00:08:34,779 --> 00:08:39,550
thinking more of it being a processor

00:08:37,240 --> 00:08:42,639
with a little bit of programmable logic

00:08:39,550 --> 00:08:45,850
rather than a programmable logic with a

00:08:42,639 --> 00:08:48,459
little bit of a processor in there and

00:08:45,850 --> 00:08:50,740
so I kind of jumped ahead early hardware

00:08:48,459 --> 00:08:52,540
engineers basically we had a little bit

00:08:50,740 --> 00:08:57,160
of logic there so all we could do is

00:08:52,540 --> 00:09:00,850
implement patches for designs do simple

00:08:57,160 --> 00:09:03,529
state machines we actually over time our

00:09:00,850 --> 00:09:05,480
devices got so many gates in them and so

00:09:03,529 --> 00:09:07,189
my logic cells we actually had companies

00:09:05,480 --> 00:09:11,329
come in and say you know what I want to

00:09:07,189 --> 00:09:13,790
go build an ASIC but I gotta get right

00:09:11,329 --> 00:09:17,170
the first time so how about I go and use

00:09:13,790 --> 00:09:19,790
your field programmable gate array to

00:09:17,170 --> 00:09:21,769
implement my ASIC design obviously it's

00:09:19,790 --> 00:09:24,319
going to run slow but at least logically

00:09:21,769 --> 00:09:28,129
I know it's going to be correct and oh

00:09:24,319 --> 00:09:31,040
by the way Xilinx we tend to eat our own

00:09:28,129 --> 00:09:32,930
dog food so we actually build these

00:09:31,040 --> 00:09:35,240
giant boards with some of our latest

00:09:32,930 --> 00:09:37,249
chips and last generation we actually

00:09:35,240 --> 00:09:39,800
put six of our largest devices on the

00:09:37,249 --> 00:09:43,370
board and we implemented in one of our

00:09:39,800 --> 00:09:45,620
devices the ARM Cortex 853 the whole

00:09:43,370 --> 00:09:48,110
four of them and another one of our

00:09:45,620 --> 00:09:49,339
devices we had the AR 5s and platform

00:09:48,110 --> 00:09:52,670
management unit another one the

00:09:49,339 --> 00:09:54,800
interconnect and peripherals and another

00:09:52,670 --> 00:09:56,839
one for some strange reason we just had

00:09:54,800 --> 00:09:59,439
the DDR memory controller but the point

00:09:56,839 --> 00:10:03,949
is is that we implemented a complete

00:09:59,439 --> 00:10:06,889
chip within our devices prior to going

00:10:03,949 --> 00:10:08,870
to Silicon and we actually took out and

00:10:06,889 --> 00:10:12,379
fielded a hundred of these boards into a

00:10:08,870 --> 00:10:14,629
board form we actually ran code good in

00:10:12,379 --> 00:10:18,040
Linux and things like that so that we

00:10:14,629 --> 00:10:20,839
could actually test all of the silicon

00:10:18,040 --> 00:10:22,759
prior to actually going out and fabbing

00:10:20,839 --> 00:10:25,040
it why because fabbing silicon is

00:10:22,759 --> 00:10:28,550
million multi-million dollar proposition

00:10:25,040 --> 00:10:33,949
these days so again I got ahead of

00:10:28,550 --> 00:10:35,870
myself we've we have customers and

00:10:33,949 --> 00:10:38,300
partners that do a lot of bridging you

00:10:35,870 --> 00:10:39,559
heard a presentation earlier where they

00:10:38,300 --> 00:10:41,209
were talking about their own custom

00:10:39,559 --> 00:10:43,790
chips and had an FPGA in the middle

00:10:41,209 --> 00:10:45,290
basically moving the data back and forth

00:10:43,790 --> 00:10:48,050
and bridging it between all their

00:10:45,290 --> 00:10:50,120
devices digital signal processing

00:10:48,050 --> 00:10:53,629
functions and again complete embedded

00:10:50,120 --> 00:10:55,819
processing systems one of my favorite

00:10:53,629 --> 00:10:59,509
topics over the years has been

00:10:55,819 --> 00:11:03,319
acceleration of software this has been

00:10:59,509 --> 00:11:06,019
something of great need as we are moving

00:11:03,319 --> 00:11:09,259
forward you heard from Tomas earlier

00:11:06,019 --> 00:11:11,629
about the fact that basically processing

00:11:09,259 --> 00:11:13,819
performance clock speed is leveled out

00:11:11,629 --> 00:11:15,679
so people go to multi-core and

00:11:13,819 --> 00:11:18,230
multi-core is really great but even

00:11:15,679 --> 00:11:20,750
there you start hitting some challenge

00:11:18,230 --> 00:11:24,620
typically it's been rebandage us being

00:11:20,750 --> 00:11:27,140
able move the data back and forth and if

00:11:24,620 --> 00:11:29,870
you can create a custom compute engine

00:11:27,140 --> 00:11:36,950
inside that program of logic then you're

00:11:29,870 --> 00:11:39,230
able to overcome Moore's law so takes us

00:11:36,950 --> 00:11:41,780
to the next topic the whole concept of

00:11:39,230 --> 00:11:43,730
heterogeneous and diversity in other

00:11:41,780 --> 00:11:49,640
words getting the right processing

00:11:43,730 --> 00:11:52,370
function on a right processing element

00:11:49,640 --> 00:11:54,470
doing the right job and so if you look

00:11:52,370 --> 00:11:56,420
at our devices these days we have

00:11:54,470 --> 00:11:59,260
application processors for our

00:11:56,420 --> 00:12:03,440
general-purpose computing running Linux

00:11:59,260 --> 00:12:06,710
doing user interface doing complex logic

00:12:03,440 --> 00:12:10,820
or decision-making handling all of the

00:12:06,710 --> 00:12:12,470
i/o functions Ethernet USB typical sorts

00:12:10,820 --> 00:12:14,810
of iOS that you're doing with a

00:12:12,470 --> 00:12:18,610
general-purpose computer we have a

00:12:14,810 --> 00:12:22,970
graphics processor our mali-400

00:12:18,610 --> 00:12:27,410
real-time processors any of you actually

00:12:22,970 --> 00:12:29,570
do any real-time processing okay not in

00:12:27,410 --> 00:12:31,970
this group so when I show up at a trade

00:12:29,570 --> 00:12:34,340
show such as embedded world industrial

00:12:31,970 --> 00:12:36,380
and automotive and the guys that are out

00:12:34,340 --> 00:12:38,300
there every single one of them is doing

00:12:36,380 --> 00:12:39,980
real-time what's so important about

00:12:38,300 --> 00:12:43,790
real-time well the important thing is

00:12:39,980 --> 00:12:45,560
that if you get an interrupt you need to

00:12:43,790 --> 00:12:48,950
be able to respond to that interrupts

00:12:45,560 --> 00:12:50,990
with extremely low latency and do it in

00:12:48,950 --> 00:12:53,060
a deterministic manner in other words be

00:12:50,990 --> 00:12:54,470
able to say absolutely positively I'm

00:12:53,060 --> 00:12:57,920
gonna respond to that interrupts in

00:12:54,470 --> 00:12:59,960
under a millisecond or two I can't wait

00:12:57,920 --> 00:13:05,030
around for an operating system in which

00:12:59,960 --> 00:13:06,530
may be doing a page switch waiting for

00:13:05,030 --> 00:13:08,420
it to kind of catch up with that page

00:13:06,530 --> 00:13:11,450
switch word then it can finally go and

00:13:08,420 --> 00:13:14,690
service and interrupt and oh by the way

00:13:11,450 --> 00:13:17,180
our 5s as you heard earlier they can be

00:13:14,690 --> 00:13:23,230
run in lockstep anyone know why the

00:13:17,180 --> 00:13:23,230
value of lock stepping to processors yes

00:13:25,900 --> 00:13:31,610
exactly so you got two processors then

00:13:29,750 --> 00:13:34,160
running together you compare the output

00:13:31,610 --> 00:13:36,110
of the two processors if they disagree

00:13:34,160 --> 00:13:39,530
because one of them took a hop skip and

00:13:36,110 --> 00:13:41,960
a jump and that can happen then you can

00:13:39,530 --> 00:13:44,470
say aha I've got a system level error

00:13:41,960 --> 00:13:47,030
and you can do what is known as failsafe

00:13:44,470 --> 00:13:49,880
you know the original stop operation

00:13:47,030 --> 00:13:52,220
immediately rather than go on and do

00:13:49,880 --> 00:13:54,110
something incorrectly like hit the

00:13:52,220 --> 00:13:58,670
brakes on a car inadvertently when it's

00:13:54,110 --> 00:14:02,630
not intended we have something called a

00:13:58,670 --> 00:14:04,670
platform management unit there we put

00:14:02,630 --> 00:14:06,290
some of our most critical code we have

00:14:04,670 --> 00:14:07,820
our power management code that runs

00:14:06,290 --> 00:14:09,950
there we have a small scheduler that

00:14:07,820 --> 00:14:11,450
runs there we have some other code that

00:14:09,950 --> 00:14:13,580
can run there that's a whole other

00:14:11,450 --> 00:14:16,970
presentation I'd love to talk about some

00:14:13,580 --> 00:14:19,820
time but what's also interesting is this

00:14:16,970 --> 00:14:22,400
is a triple redundant processor triple

00:14:19,820 --> 00:14:25,340
redundant and that means you can put

00:14:22,400 --> 00:14:29,420
your most critical code on that

00:14:25,340 --> 00:14:32,180
processor and it means what's the value

00:14:29,420 --> 00:14:39,050
of triple redundancy why why is it

00:14:32,180 --> 00:14:44,950
better than double redundancy make a

00:14:39,050 --> 00:14:44,950
wild guess I'm sorry

00:14:45,790 --> 00:14:52,760
well okay you're almost right you can

00:14:48,410 --> 00:14:55,160
feel yeah you fail majority yes so

00:14:52,760 --> 00:14:57,830
basically with triple redundancy you get

00:14:55,160 --> 00:14:59,510
all three the vote if one of them has an

00:14:57,830 --> 00:15:01,550
error he gets out voted and you throw

00:14:59,510 --> 00:15:04,070
his decision out and you can continue

00:15:01,550 --> 00:15:06,800
operation for a while with just the two

00:15:04,070 --> 00:15:08,720
cores eventually you do have to bring

00:15:06,800 --> 00:15:11,150
that third core back online get all

00:15:08,720 --> 00:15:13,520
three in sync but again for functional

00:15:11,150 --> 00:15:16,430
safety applications extremely important

00:15:13,520 --> 00:15:20,660
when we're talking automotive industrial

00:15:16,430 --> 00:15:22,340
control avionics any place where you can

00:15:20,660 --> 00:15:25,640
have something that's basically can't

00:15:22,340 --> 00:15:28,330
fail because human life is at risk it's

00:15:25,640 --> 00:15:30,860
important to have this type of thing

00:15:28,330 --> 00:15:33,950
we also have a configuration security

00:15:30,860 --> 00:15:39,260
unit we have been working with security

00:15:33,950 --> 00:15:41,720
applications for many many years and we

00:15:39,260 --> 00:15:44,570
have a whole team dedicated to security

00:15:41,720 --> 00:15:48,470
you want to we want to make sure that

00:15:44,570 --> 00:15:50,920
any code or what we call a bitstream in

00:15:48,470 --> 00:15:53,720
other words hardware configuration is

00:15:50,920 --> 00:15:55,310
the correct code and hardware

00:15:53,720 --> 00:15:57,830
configuration that's going into the

00:15:55,310 --> 00:16:01,670
device so we can authenticate we can

00:15:57,830 --> 00:16:05,240
decrypt that code we can read it to make

00:16:01,670 --> 00:16:07,370
sure that again somebody doesn't in you

00:16:05,240 --> 00:16:12,530
know easily steal your code so you can

00:16:07,370 --> 00:16:14,360
keep it encrypted and depending on your

00:16:12,530 --> 00:16:16,280
application we actually have some

00:16:14,360 --> 00:16:18,770
customers that retain critical code

00:16:16,280 --> 00:16:19,940
segments entirely within our device so

00:16:18,770 --> 00:16:25,010
we have something called on-chip memory

00:16:19,940 --> 00:16:28,700
so that the processor can critical code

00:16:25,010 --> 00:16:30,790
on chip never having the possibility

00:16:28,700 --> 00:16:33,050
that it can be snooped or attacked

00:16:30,790 --> 00:16:36,020
externally because you have this access

00:16:33,050 --> 00:16:39,560
to external DDR memory incidentally that

00:16:36,020 --> 00:16:41,690
processor is also triple redundant and

00:16:39,560 --> 00:16:46,220
then of course we have this program of

00:16:41,690 --> 00:16:48,950
logic typically used for additional

00:16:46,220 --> 00:16:50,570
peripherals high-speed data processing

00:16:48,950 --> 00:16:53,570
and software acceleration which I'll

00:16:50,570 --> 00:16:56,660
talk a little bit more about now quickly

00:16:53,570 --> 00:16:57,790
about custom peripherals how many of you

00:16:56,660 --> 00:17:00,880
gone and

00:16:57,790 --> 00:17:02,440
out and bought a you know ASIC ship with

00:17:00,880 --> 00:17:04,750
an embedded processor and a whole

00:17:02,440 --> 00:17:08,070
collection peripherals only to discover

00:17:04,750 --> 00:17:11,050
you're missing a couple key peripherals

00:17:08,070 --> 00:17:13,090
okay you all are software guys so you

00:17:11,050 --> 00:17:14,740
probably was the hardware guy that was

00:17:13,090 --> 00:17:16,840
kind of stuck with that if you probably

00:17:14,740 --> 00:17:18,760
have seen it go on okay and the hardware

00:17:16,840 --> 00:17:21,280
guy then has to go out and buy a special

00:17:18,760 --> 00:17:23,860
chip and attach it to your processor for

00:17:21,280 --> 00:17:25,150
that additional peripheral with the

00:17:23,860 --> 00:17:26,950
field programmable gate array or

00:17:25,150 --> 00:17:28,870
programmable logic you have this

00:17:26,950 --> 00:17:33,010
opportunity to simply say you know what

00:17:28,870 --> 00:17:37,540
I got two on-board ethernet chips but I

00:17:33,010 --> 00:17:40,330
need four and Xilinx we say no problem

00:17:37,540 --> 00:17:43,180
because we have softer Ethernet chips or

00:17:40,330 --> 00:17:44,410
that you can just instantiate into the

00:17:43,180 --> 00:17:46,510
programmer logixx literally

00:17:44,410 --> 00:17:49,000
drag-and-drop with our tools have it

00:17:46,510 --> 00:17:51,160
cooked up the processor drivers are

00:17:49,000 --> 00:17:53,410
automatically added to your system for

00:17:51,160 --> 00:17:55,540
those peripherals and voila you now have

00:17:53,410 --> 00:18:01,230
four ethernet macs that you can use in

00:17:55,540 --> 00:18:04,240
your system so kind of summarizing

00:18:01,230 --> 00:18:06,100
advantages so first we have a

00:18:04,240 --> 00:18:08,530
performance advantage we have the

00:18:06,100 --> 00:18:11,380
ability to accelerate software we have

00:18:08,530 --> 00:18:13,390
performance advantage because of the

00:18:11,380 --> 00:18:15,730
ability to have tight integration

00:18:13,390 --> 00:18:17,800
between the processing system and the

00:18:15,730 --> 00:18:20,230
program of logic we have thousands of

00:18:17,800 --> 00:18:21,970
wires that run from the processing

00:18:20,230 --> 00:18:24,340
system to the program of logic a lot of

00:18:21,970 --> 00:18:28,210
it's on the AXI buses a lot of it's for

00:18:24,340 --> 00:18:29,410
other control type functions and so this

00:18:28,210 --> 00:18:31,090
means you don't have to all go off chip

00:18:29,410 --> 00:18:32,860
as you probably know as soon as you go

00:18:31,090 --> 00:18:35,470
off chip you inherently have delays

00:18:32,860 --> 00:18:37,480
which can be very costly for in terms of

00:18:35,470 --> 00:18:39,700
overall system performance we have a

00:18:37,480 --> 00:18:41,860
power advantage again by tight

00:18:39,700 --> 00:18:45,360
integration you don't have to burn power

00:18:41,860 --> 00:18:49,120
on things like PCI Express interfaces

00:18:45,360 --> 00:18:50,980
unnecessarily as you may know PCI

00:18:49,120 --> 00:18:57,070
Express high-speed serial transceivers

00:18:50,980 --> 00:18:59,590
very power-hungry devices and then as

00:18:57,070 --> 00:19:03,400
you will see well if the dramatic types

00:18:59,590 --> 00:19:05,230
of acceleration we get because we have

00:19:03,400 --> 00:19:08,110
implemented custom hardware on the

00:19:05,230 --> 00:19:10,700
device we don't have all of the overhead

00:19:08,110 --> 00:19:12,860
of a general-purpose processor the

00:19:10,700 --> 00:19:14,240
effect is we generally have significant

00:19:12,860 --> 00:19:16,340
power savings compared to a

00:19:14,240 --> 00:19:18,230
general-purpose processor and of course

00:19:16,340 --> 00:19:22,910
as you've heard me talk about infinite

00:19:18,230 --> 00:19:25,220
amount of flexibility time to market you

00:19:22,910 --> 00:19:28,010
already heard me allude to earlier about

00:19:25,220 --> 00:19:30,620
the hardware engineer hey now he can go

00:19:28,010 --> 00:19:33,610
and fix something immediately in the

00:19:30,620 --> 00:19:36,410
device the ability to go and

00:19:33,610 --> 00:19:38,570
post-production in the field do a field

00:19:36,410 --> 00:19:41,330
upgrade is easily on the hardware as you

00:19:38,570 --> 00:19:44,570
can do on the software the ability to

00:19:41,330 --> 00:19:47,000
take a single platform and using

00:19:44,570 --> 00:19:48,920
different products simply by different

00:19:47,000 --> 00:19:56,830
configurations of software and the

00:19:48,920 --> 00:19:59,420
program logic for your hardware so again

00:19:56,830 --> 00:20:01,280
we have I think a lot of software

00:19:59,420 --> 00:20:05,240
developers in here and I think it's an

00:20:01,280 --> 00:20:06,980
interesting experience for those of us

00:20:05,240 --> 00:20:08,560
that have been involved in high-level

00:20:06,980 --> 00:20:11,240
operating systems and applications

00:20:08,560 --> 00:20:12,470
residing on those operating systems to

00:20:11,240 --> 00:20:16,130
address some of the real world

00:20:12,470 --> 00:20:19,010
challenges of communication and you know

00:20:16,130 --> 00:20:21,140
this is a typical classic thing and

00:20:19,010 --> 00:20:23,830
here's an industrial example robotics

00:20:21,140 --> 00:20:28,100
application real-time control of a motor

00:20:23,830 --> 00:20:30,830
and you have to be able to respond and

00:20:28,100 --> 00:20:32,630
control that motor down to millisecond

00:20:30,830 --> 00:20:35,810
levels I think even some folks are doing

00:20:32,630 --> 00:20:40,190
hundreds of microseconds for motor

00:20:35,810 --> 00:20:42,050
control and you can't do that with an

00:20:40,190 --> 00:20:44,930
operating system such as Linux even with

00:20:42,050 --> 00:20:46,910
the real-time extensions and so this is

00:20:44,930 --> 00:20:49,820
why it's really nice to be able to have

00:20:46,910 --> 00:20:52,480
you know your general-purpose processor

00:20:49,820 --> 00:20:55,550
and your real-time processor as

00:20:52,480 --> 00:20:58,840
independent elements and the artists

00:20:55,550 --> 00:21:02,510
running on that real-time processor

00:20:58,840 --> 00:21:07,270
again deterministic and low latency

00:21:02,510 --> 00:21:07,270
access for your real-time processing

00:21:10,260 --> 00:21:19,840
so taking a look at the high level what

00:21:15,640 --> 00:21:22,150
we have in the zinc ultra scale plus we

00:21:19,840 --> 00:21:24,700
have a different variety of different

00:21:22,150 --> 00:21:27,190
families we start out with dual core 850

00:21:24,700 --> 00:21:31,210
threes and with our eg devices we go to

00:21:27,190 --> 00:21:33,040
quad-core 853 s you're pretty much all

00:21:31,210 --> 00:21:34,570
used to them by now because it's

00:21:33,040 --> 00:21:37,540
typically what we have in our cell

00:21:34,570 --> 00:21:42,250
phones today run symmetric

00:21:37,540 --> 00:21:44,320
multiprocessing you know Linux we have a

00:21:42,250 --> 00:21:47,250
family what we call the embedded vision

00:21:44,320 --> 00:21:54,460
devices so we actually have integrated

00:21:47,250 --> 00:22:00,030
video codecs we support up to 4k P 60 or

00:21:54,460 --> 00:22:03,250
even 8k p 15 variable you know formats

00:22:00,030 --> 00:22:10,980
h.264 265 anybody doing vision

00:22:03,250 --> 00:22:10,980
compression decompression nope okay

00:22:12,660 --> 00:22:18,700
again the 853 s you're familiar with

00:22:16,450 --> 00:22:23,620
them we do operate up to 1.5 gigahertz

00:22:18,700 --> 00:22:27,190
on the a 53 s the are 5s we operate up

00:22:23,620 --> 00:22:31,600
to 600 megahertz Mali graphics units the

00:22:27,190 --> 00:22:34,870
Mali 400 so it's you know reasonable 2d

00:22:31,600 --> 00:22:36,180
3d graphics processor I talked about the

00:22:34,870 --> 00:22:39,910
codecs

00:22:36,180 --> 00:22:42,730
we support ddr3 ddr4 and low-power ter

00:22:39,910 --> 00:22:46,600
memory systems we do platform management

00:22:42,730 --> 00:22:50,640
now this is a place where I always kind

00:22:46,600 --> 00:22:54,580
of get up and I apologize a little bit

00:22:50,640 --> 00:22:58,810
being from an FPGA company we always

00:22:54,580 --> 00:23:00,580
think in terms of watts tens of watts

00:22:58,810 --> 00:23:05,920
we haven't some devices that consume

00:23:00,580 --> 00:23:08,230
over a hundred watts and so we live in a

00:23:05,920 --> 00:23:11,680
different world when it comes to power

00:23:08,230 --> 00:23:14,890
we majority of our devices are designed

00:23:11,680 --> 00:23:17,130
to operate off of AC power we do have

00:23:14,890 --> 00:23:19,990
many customers that do battery-powered

00:23:17,130 --> 00:23:22,420
applications but I will call them these

00:23:19,990 --> 00:23:23,640
are kind of man portable types of things

00:23:22,420 --> 00:23:28,210
medical in

00:23:23,640 --> 00:23:30,370
large tablets etc so we have the full

00:23:28,210 --> 00:23:33,610
ability to do the things you're used to

00:23:30,370 --> 00:23:36,250
like being able to take a 53's offline

00:23:33,610 --> 00:23:40,420
turn off their power islands we have

00:23:36,250 --> 00:23:42,400
independent power domains for our a 53s

00:23:40,420 --> 00:23:45,220
versus the r5 so we can do things like

00:23:42,400 --> 00:23:47,560
turn off the full power domain with the

00:23:45,220 --> 00:23:50,500
a 53 s continue operation in our 5s we

00:23:47,560 --> 00:23:52,930
can even go down to just having the

00:23:50,500 --> 00:23:54,460
platform management you name running but

00:23:52,930 --> 00:23:55,990
if you would ask me hey what's your

00:23:54,460 --> 00:23:57,970
lowest power consumption what

00:23:55,990 --> 00:24:03,040
everything's idle I'll go and say and I

00:23:57,970 --> 00:24:04,420
will proudly say 35 milliwatts III do

00:24:03,040 --> 00:24:06,190
acknowledge that is a completely

00:24:04,420 --> 00:24:08,290
different world than let's say what the

00:24:06,190 --> 00:24:11,080
cell phone or the true tablet world is

00:24:08,290 --> 00:24:15,580
used to but for many of our customers

00:24:11,080 --> 00:24:18,310
that are used to and needing really high

00:24:15,580 --> 00:24:20,470
performance data management and movement

00:24:18,310 --> 00:24:24,100
these are wonderful things that we

00:24:20,470 --> 00:24:25,720
cannot do offer I talked a lot a little

00:24:24,100 --> 00:24:29,740
bit about our configuration of security

00:24:25,720 --> 00:24:32,710
unit and of course FPGA acceleration and

00:24:29,740 --> 00:24:36,040
then within our device in the main

00:24:32,710 --> 00:24:39,840
processing system we support PCI Express

00:24:36,040 --> 00:24:42,280
Gen 2 we have qubit USB gen 3

00:24:39,840 --> 00:24:44,790
DisplayPort interface for the graphics

00:24:42,280 --> 00:24:50,950
processing unit people ask what about

00:24:44,790 --> 00:24:59,770
HDMI answer is programmable logic H any

00:24:50,950 --> 00:25:03,630
HDMI standard you want we support so

00:24:59,770 --> 00:25:07,030
again advantages of this type of device

00:25:03,630 --> 00:25:09,880
rapidly implemented designs test both

00:25:07,030 --> 00:25:11,980
your hardware and software accommodate

00:25:09,880 --> 00:25:14,260
your manager coming to you saying guess

00:25:11,980 --> 00:25:15,670
what competition just introduced that

00:25:14,260 --> 00:25:19,390
new feature and you got to put in your

00:25:15,670 --> 00:25:22,960
device on while I'm done tomorrow you

00:25:19,390 --> 00:25:25,450
can do it the whole concept of field

00:25:22,960 --> 00:25:28,090
upgrade ability we have customers that

00:25:25,450 --> 00:25:30,580
go and remotely update their devices

00:25:28,090 --> 00:25:34,690
both the hardware and software via the

00:25:30,580 --> 00:25:36,820
internet you can span multiple

00:25:34,690 --> 00:25:38,590
generations with a platform

00:25:36,820 --> 00:25:41,410
because you're able to upgrade both the

00:25:38,590 --> 00:25:43,510
software and the hardware dynamic

00:25:41,410 --> 00:25:45,310
partial reconfiguration I old boy a

00:25:43,510 --> 00:25:48,400
whole nother topic love to talk to you

00:25:45,310 --> 00:25:50,650
about an hour on this one but this is

00:25:48,400 --> 00:25:52,810
something that's totally radical for the

00:25:50,650 --> 00:25:56,980
hardware world you as a software

00:25:52,810 --> 00:25:59,170
engineer or an NGO so what okay

00:25:56,980 --> 00:26:01,180
software world we have been used to it

00:25:59,170 --> 00:26:05,860
for years and years the ability to go

00:26:01,180 --> 00:26:08,830
and run an application and swap it out

00:26:05,860 --> 00:26:10,600
and run another application because we

00:26:08,830 --> 00:26:12,940
didn't have enough memory and we have no

00:26:10,600 --> 00:26:16,330
virtual memory so we're used to the

00:26:12,940 --> 00:26:18,130
ecole concept of having as limited

00:26:16,330 --> 00:26:22,810
amount of memory and swapping things in

00:26:18,130 --> 00:26:25,780
and out hardware we can now do that so

00:26:22,810 --> 00:26:28,180
that you can do things like my favorite

00:26:25,780 --> 00:26:33,220
example is an infotainment system on a

00:26:28,180 --> 00:26:35,440
car well you might be doing a video so

00:26:33,220 --> 00:26:38,320
why not put in all the you know video

00:26:35,440 --> 00:26:40,720
pathway into our programmable logic to

00:26:38,320 --> 00:26:44,680
watch a video and that may be different

00:26:40,720 --> 00:26:47,770
than what you might have for an audio

00:26:44,680 --> 00:26:50,170
pathway or it might be different than

00:26:47,770 --> 00:26:52,150
using that same head to display the

00:26:50,170 --> 00:26:55,240
video from your rear-view camera when

00:26:52,150 --> 00:27:00,280
you're backing up your car and you go

00:26:55,240 --> 00:27:03,580
well that's really cool but so what why

00:27:00,280 --> 00:27:05,590
don't I just buy a bigger device and

00:27:03,580 --> 00:27:07,180
it's ilex we're more than happy to tell

00:27:05,590 --> 00:27:10,060
you that bigger device and it will cost

00:27:07,180 --> 00:27:11,560
you more so what our customers like is

00:27:10,060 --> 00:27:14,140
hey they can use one of our smaller

00:27:11,560 --> 00:27:16,630
devices save some money save some power

00:27:14,140 --> 00:27:21,010
by simply swapping in and out hardware

00:27:16,630 --> 00:27:24,880
designs and of course one of the

00:27:21,010 --> 00:27:27,720
challenges if you are a embedded

00:27:24,880 --> 00:27:30,040
designer software and hardware is

00:27:27,720 --> 00:27:34,300
debugging the hardware and software at

00:27:30,040 --> 00:27:36,310
the same time I'm sure you guys some of

00:27:34,300 --> 00:27:38,380
you have at least had that a wonderful

00:27:36,310 --> 00:27:40,000
occasion where the hardware engineer

00:27:38,380 --> 00:27:42,040
comes to you and says here's my hardware

00:27:40,000 --> 00:27:43,570
design it's all working and you as a

00:27:42,040 --> 00:27:45,940
software engineer go right to all the

00:27:43,570 --> 00:27:49,400
drivers and code and try to drive that

00:27:45,940 --> 00:27:51,230
hardware and go it's not working

00:27:49,400 --> 00:27:52,760
our engineer goes it's correct you know

00:27:51,230 --> 00:27:54,800
the usual thing we even go through in

00:27:52,760 --> 00:27:59,080
the software world with two software

00:27:54,800 --> 00:28:02,270
engineers so we have the ability to

00:27:59,080 --> 00:28:04,940
simultaneously look at code and look at

00:28:02,270 --> 00:28:07,010
hardware and see exactly what's going on

00:28:04,940 --> 00:28:08,900
if you do a write from code to the

00:28:07,010 --> 00:28:10,610
hardware we can show you exactly what's

00:28:08,900 --> 00:28:12,770
going on inside the hardware in the

00:28:10,610 --> 00:28:14,120
program of logic to demonstrate it's

00:28:12,770 --> 00:28:19,910
doing what it's doing supposed to be

00:28:14,120 --> 00:28:22,580
doing or not all right now that I've got

00:28:19,910 --> 00:28:24,620
you fully intimidated about what can be

00:28:22,580 --> 00:28:27,550
done with their devices let's look at

00:28:24,620 --> 00:28:29,480
how one goes about using them so

00:28:27,550 --> 00:28:32,990
software development flow the whole

00:28:29,480 --> 00:28:35,450
purpose this design or the slide is to

00:28:32,990 --> 00:28:37,490
really say the software flow is no

00:28:35,450 --> 00:28:40,150
different than what you are used to

00:28:37,490 --> 00:28:43,010
today in terms of software development

00:28:40,150 --> 00:28:45,320
you basically start out with a hardware

00:28:43,010 --> 00:28:48,560
platform it says here's all the hardware

00:28:45,320 --> 00:28:50,600
that you in your system and then our

00:28:48,560 --> 00:28:51,830
tools who create the software platform

00:28:50,600 --> 00:28:53,660
brings in all the correct software

00:28:51,830 --> 00:28:56,150
drivers associated with the hardware

00:28:53,660 --> 00:28:59,000
that's in the system generate libraries

00:28:56,150 --> 00:29:01,490
you then create your code you can pilot

00:28:59,000 --> 00:29:04,100
your linkage you debug it exactly the

00:29:01,490 --> 00:29:05,840
same manner that you'd have been doing

00:29:04,100 --> 00:29:08,630
for years and years

00:29:05,840 --> 00:29:10,220
it's a JTAG cable which I'm sure many of

00:29:08,630 --> 00:29:15,260
you have been using if you're targeting

00:29:10,220 --> 00:29:17,450
embedded processing system you can in

00:29:15,260 --> 00:29:19,900
terms of debug you can do the usual

00:29:17,450 --> 00:29:22,190
single step through code set breakpoints

00:29:19,900 --> 00:29:24,740
third-party tools allow you to do trace

00:29:22,190 --> 00:29:26,690
capabilities you can profile yourself

00:29:24,740 --> 00:29:28,430
draw applications figure out where your

00:29:26,690 --> 00:29:31,190
critical code segments are hand

00:29:28,430 --> 00:29:34,130
optimized if need be

00:29:31,190 --> 00:29:37,010
we have an eclipse based IDE development

00:29:34,130 --> 00:29:40,370
environment it's Windows or Linux hosted

00:29:37,010 --> 00:29:41,960
and you can use the GUI but if you start

00:29:40,370 --> 00:29:43,640
automating the process there's also

00:29:41,960 --> 00:29:48,230
command-line interface so it can be all

00:29:43,640 --> 00:29:49,520
scripted and we provide everything you

00:29:48,230 --> 00:29:51,260
need to board bring up for more

00:29:49,520 --> 00:29:52,880
development bare metal application

00:29:51,260 --> 00:29:54,650
develop a Linux application development

00:29:52,880 --> 00:29:59,170
performance optimization and system

00:29:54,650 --> 00:30:01,760
deployment a lot of words there

00:29:59,170 --> 00:30:03,049
incidentally when you get the Electra 96

00:30:01,760 --> 00:30:09,700
you get access to all

00:30:03,049 --> 00:30:14,499
our tools to do this runtime software

00:30:09,700 --> 00:30:16,639
this is kind of a who's who's list of

00:30:14,499 --> 00:30:19,700
all the os's

00:30:16,639 --> 00:30:25,580
I think a lot of us are very much Linux

00:30:19,700 --> 00:30:28,100
focused here but we support both Linux

00:30:25,580 --> 00:30:29,749
as provided from Xilinx we'd like to

00:30:28,100 --> 00:30:32,899
call it petti Linux but it's just the

00:30:29,749 --> 00:30:35,809
standard Linux build we use the Yocto

00:30:32,899 --> 00:30:38,690
flow to go and implement the Linux

00:30:35,809 --> 00:30:42,950
system but you can see we've got

00:30:38,690 --> 00:30:47,389
third-party partners Android bare metal

00:30:42,950 --> 00:30:50,389
free our toss if you're into security or

00:30:47,389 --> 00:30:57,320
high reliability applications Greenhills

00:30:50,389 --> 00:31:00,769
integrity when River VxWorks you'll

00:30:57,320 --> 00:31:04,429
notice you know the entire list runs on

00:31:00,769 --> 00:31:06,739
the application processor our our 5s

00:31:04,429 --> 00:31:09,999
generally you know run things like bare

00:31:06,739 --> 00:31:13,399
metal free our toss and then any other

00:31:09,999 --> 00:31:15,950
artists that are you know focus for

00:31:13,399 --> 00:31:16,999
real-time applications and then the last

00:31:15,950 --> 00:31:19,970
column you'll see it's labeled

00:31:16,999 --> 00:31:25,070
microplace now remember I mentioned

00:31:19,970 --> 00:31:27,220
microblaze has a soft processor we have

00:31:25,070 --> 00:31:30,169
so much experience with the microblaze

00:31:27,220 --> 00:31:32,359
so when we went and implemented a triple

00:31:30,169 --> 00:31:39,909
redundant processor guess what processor

00:31:32,359 --> 00:31:43,460
we used obvious answer microblaze now

00:31:39,909 --> 00:31:47,739
just to show you how experienced we are

00:31:43,460 --> 00:31:50,409
we have triple redundant micro glazes in

00:31:47,739 --> 00:31:52,989
military applications high reliability

00:31:50,409 --> 00:31:56,960
applications and satellite applications

00:31:52,989 --> 00:32:00,340
we have a lot of experience with putting

00:31:56,960 --> 00:32:00,340
together own processors

00:32:04,090 --> 00:32:14,770
I'm clicker and of course we do support

00:32:08,650 --> 00:32:17,020
hypervisor currently we are supporting

00:32:14,770 --> 00:32:19,480
the Xen hypervisor we are working with

00:32:17,020 --> 00:32:22,179
third party but it does mean you can run

00:32:19,480 --> 00:32:24,640
multiple operating systems on the

00:32:22,179 --> 00:32:28,870
application 853 processors

00:32:24,640 --> 00:32:30,909
a little bit more about the ultra 96

00:32:28,870 --> 00:32:32,830
development platform you heard a fair

00:32:30,909 --> 00:32:35,080
amount of it this morning so I'll

00:32:32,830 --> 00:32:38,919
quickly go through key elements you know

00:32:35,080 --> 00:32:42,940
is Lennar o 96 ports consumer edition so

00:32:38,919 --> 00:32:46,390
it's a small very small form-factor

00:32:42,940 --> 00:32:49,299
credit card size do you want to give a

00:32:46,390 --> 00:32:52,270
blatant plug for Avnet because they are

00:32:49,299 --> 00:32:55,090
distributor for the ultra 96 they are

00:32:52,270 --> 00:33:00,630
rolling these out gem the latest date

00:32:55,090 --> 00:33:00,630
for delivery put you on the spot

00:33:01,770 --> 00:33:10,539
sometime in April read that as by the

00:33:04,570 --> 00:33:11,890
end of April and so it will be available

00:33:10,539 --> 00:33:15,309
through them they're going to be

00:33:11,890 --> 00:33:16,830
providing different bundles for

00:33:15,309 --> 00:33:20,860
availability

00:33:16,830 --> 00:33:22,270
it has our zu3 device well what that

00:33:20,860 --> 00:33:25,270
really means is it's got the same

00:33:22,270 --> 00:33:27,700
processing system as the majority of our

00:33:25,270 --> 00:33:29,710
devices it just means it's one of our

00:33:27,700 --> 00:33:33,520
physically smaller devices in terms of

00:33:29,710 --> 00:33:36,750
the device unfortunately we always show

00:33:33,520 --> 00:33:39,909
pictures of the top of the board

00:33:36,750 --> 00:33:43,179
and so our zinc device is hiding right

00:33:39,909 --> 00:33:44,549
here where all the pads are on the

00:33:43,179 --> 00:33:46,809
bottom side of the board and

00:33:44,549 --> 00:33:48,309
unfortunately you can't even see it

00:33:46,809 --> 00:33:51,490
because we have this little wonderful

00:33:48,309 --> 00:33:57,159
fan mounted heatsink to blow air on it

00:33:51,490 --> 00:33:59,289
to bride cooling and you can see the

00:33:57,159 --> 00:34:01,600
entire collection of peripherals there

00:33:59,289 --> 00:34:03,880
we do support the standard high speed

00:34:01,600 --> 00:34:08,980
connector and the standard low speed

00:34:03,880 --> 00:34:10,929
connector and a listing of ports I'm

00:34:08,980 --> 00:34:14,080
going to pause here any questions about

00:34:10,929 --> 00:34:15,679
the ultra 96 characteristics I'll talk a

00:34:14,080 --> 00:34:23,649
little bit about software available

00:34:15,679 --> 00:34:25,849
next slide okay if you speak up I repeat

00:34:23,649 --> 00:34:28,220
all of the question is do we have

00:34:25,849 --> 00:34:30,109
Ethernet on the board the board has a

00:34:28,220 --> 00:34:32,899
wireless interface we do not have a

00:34:30,109 --> 00:34:34,550
director Ethernet connection at - saying

00:34:32,899 --> 00:34:38,059
that's not actually a requirement in the

00:34:34,550 --> 00:34:42,159
ninety six boards format one can do a

00:34:38,059 --> 00:34:42,159
USB Ethernet dongle

00:34:50,530 --> 00:34:54,250
thank you for that clarification

00:34:58,000 --> 00:35:09,109
question says heatsink is it include yes

00:35:00,740 --> 00:35:11,319
it's included mezzanine cards you'll

00:35:09,109 --> 00:35:14,660
work with the standard mezzanine cards

00:35:11,319 --> 00:35:18,500
you'll see we like to invite you to our

00:35:14,660 --> 00:35:21,109
demo table on Friday at I guess there's

00:35:18,500 --> 00:35:22,819
a noon to 2:00 and we're gonna have a

00:35:21,109 --> 00:35:24,829
series of these boards set up for you to

00:35:22,819 --> 00:35:28,940
play with with the mezzanine card will

00:35:24,829 --> 00:35:31,160
have the Grove mezzanine card on there

00:35:28,940 --> 00:35:33,010
we have pre-configured software so you

00:35:31,160 --> 00:35:40,790
can actually create code edit the code

00:35:33,010 --> 00:35:43,130
see things flash buzz etc and so this is

00:35:40,790 --> 00:35:47,390
also available as part of one of the

00:35:43,130 --> 00:35:49,700
bundles that we're looking at again just

00:35:47,390 --> 00:35:53,059
quick way for you to get started and

00:35:49,700 --> 00:35:55,220
then we're going to provide a card image

00:35:53,059 --> 00:35:57,470
this is to give you a really quick out

00:35:55,220 --> 00:35:58,910
of box opportunity to play with the

00:35:57,470 --> 00:36:02,500
board and this is what you'll be able to

00:35:58,910 --> 00:36:05,780
play with on Friday so that includes the

00:36:02,500 --> 00:36:08,450
you know Linux kernel version 4.9

00:36:05,780 --> 00:36:09,950
supports the ultra 96 which means all

00:36:08,450 --> 00:36:12,319
those hardened peripherals that I showed

00:36:09,950 --> 00:36:14,869
you on earlier slide the malla graphics

00:36:12,319 --> 00:36:17,240
support we boots up to the Enlightenment

00:36:14,869 --> 00:36:19,809
desktop it actually serves up a webpage

00:36:17,240 --> 00:36:25,220
similar to what I showing up here and

00:36:19,809 --> 00:36:27,550
you can hook up a keyboard and a display

00:36:25,220 --> 00:36:30,580
just as I currently have and we

00:36:27,550 --> 00:36:31,690
begin demonstrating our wirelessly you

00:36:30,580 --> 00:36:34,570
can actually just connect to it

00:36:31,690 --> 00:36:38,200
wirelessly and on tablet access these

00:36:34,570 --> 00:36:40,090
web pages and you can go and run any of

00:36:38,200 --> 00:36:43,000
the sample applications we have on there

00:36:40,090 --> 00:36:45,550
you can use then go in and click on any

00:36:43,000 --> 00:36:48,730
of the applications open up the code

00:36:45,550 --> 00:36:50,650
edit the code via an HTML editor click a

00:36:48,730 --> 00:36:53,740
single button and it will automatically

00:36:50,650 --> 00:37:00,400
recompile the code and begin execution

00:36:53,740 --> 00:37:11,050
of the code moving on software

00:37:00,400 --> 00:37:15,430
acceleration question yes the question

00:37:11,050 --> 00:37:19,000
is Malik drivers I'm going to have to

00:37:15,430 --> 00:37:20,620
defer that one I do believe we have some

00:37:19,000 --> 00:37:33,760
of the same challenges you've heard

00:37:20,620 --> 00:37:35,830
earlier in the earlier session so how do

00:37:33,760 --> 00:37:37,960
you go about taking your code and

00:37:35,830 --> 00:37:39,820
turning into Hardware so you heard a

00:37:37,960 --> 00:37:41,500
little bit earlier about from Tomas so

00:37:39,820 --> 00:37:44,290
I'll go and kind of describe the flow in

00:37:41,500 --> 00:37:45,760
a similar manner first the most

00:37:44,290 --> 00:37:48,160
important things you have to sit there

00:37:45,760 --> 00:37:51,970
and profile your code find your critical

00:37:48,160 --> 00:37:54,010
code segments I can tell you that if you

00:37:51,970 --> 00:37:57,150
have a general-purpose application and

00:37:54,010 --> 00:37:58,840
my worst-case example is a text editor

00:37:57,150 --> 00:38:00,730
you're not going to be able to

00:37:58,840 --> 00:38:02,950
accelerate a text editor there's no

00:38:00,730 --> 00:38:07,420
critical code segments as far as I know

00:38:02,950 --> 00:38:09,760
of in a text editor but if you are doing

00:38:07,420 --> 00:38:11,290
an embedded application usually what's

00:38:09,760 --> 00:38:12,970
happening is you're bringing in a whole

00:38:11,290 --> 00:38:16,270
bunch of data you're going crunch on

00:38:12,970 --> 00:38:20,070
that data and then making some decisions

00:38:16,270 --> 00:38:23,110
on the end result of that data and that

00:38:20,070 --> 00:38:26,170
means that your code usually ends up

00:38:23,110 --> 00:38:28,630
being critical in a couple functions and

00:38:26,170 --> 00:38:32,950
so you identify those time-consuming

00:38:28,630 --> 00:38:35,620
functions you then use our SD SOC tool

00:38:32,950 --> 00:38:37,700
and you say here's a function I want you

00:38:35,620 --> 00:38:41,090
to go and take that function and convert

00:38:37,700 --> 00:38:43,370
to hardware and on your PC it will then

00:38:41,090 --> 00:38:44,750
go and convert it over hardware and then

00:38:43,370 --> 00:38:48,110
start giving you estimates it'll

00:38:44,750 --> 00:38:50,600
actually tell you this is how long we

00:38:48,110 --> 00:38:54,020
think it will take to actually execute

00:38:50,600 --> 00:38:56,270
that code and you can go okay out of the

00:38:54,020 --> 00:38:58,070
box I was lucky and it's running end

00:38:56,270 --> 00:39:01,280
times faster and that's fast enough for

00:38:58,070 --> 00:39:03,920
me now kind of truth in advertising

00:39:01,280 --> 00:39:05,960
I wish it were truly that easy to say

00:39:03,920 --> 00:39:08,480
yes we will always accelerate your code

00:39:05,960 --> 00:39:10,040
a hundred times but the answer is its

00:39:08,480 --> 00:39:12,860
code dependent

00:39:10,040 --> 00:39:15,410
you know frequently you will look at the

00:39:12,860 --> 00:39:17,300
code and you go you know what I want to

00:39:15,410 --> 00:39:19,970
be able to accelerate it by paralyzing

00:39:17,300 --> 00:39:22,550
it in some form so what is paralyzing

00:39:19,970 --> 00:39:25,160
mean well paralyzing means things like

00:39:22,550 --> 00:39:27,650
okay I'm looping through this thing four

00:39:25,160 --> 00:39:30,560
times and I'm doing calculations on for

00:39:27,650 --> 00:39:32,420
independent array elements in software I

00:39:30,560 --> 00:39:34,550
do it sequentially what if I could do

00:39:32,420 --> 00:39:38,030
all four of them in parallel and so you

00:39:34,550 --> 00:39:42,080
can then tell the tool unroll this for

00:39:38,030 --> 00:39:44,350
loop and it will instantiate four

00:39:42,080 --> 00:39:47,150
parallel paths doing the hardware

00:39:44,350 --> 00:39:50,210
calculation simultaneously so suddenly

00:39:47,150 --> 00:39:52,610
you get four times faster we also allow

00:39:50,210 --> 00:39:54,440
you to do pipelining what pipelining

00:39:52,610 --> 00:39:56,780
means is if you have a lot of code and

00:39:54,440 --> 00:39:58,190
you just do operation here and then you

00:39:56,780 --> 00:39:59,540
do another operation on the same data

00:39:58,190 --> 00:40:01,820
and then another operation another

00:39:59,540 --> 00:40:04,850
operation software you're used to doing

00:40:01,820 --> 00:40:08,450
that in serial manner but in hardware we

00:40:04,850 --> 00:40:10,160
can go and say go crunch on the first

00:40:08,450 --> 00:40:12,080
piece of data move it down let the

00:40:10,160 --> 00:40:13,970
second inch and go crunch on this first

00:40:12,080 --> 00:40:16,160
PETA it's the data meanwhile the first

00:40:13,970 --> 00:40:18,230
engine is going crunch on the second

00:40:16,160 --> 00:40:20,930
piece of data and you just pipeline it

00:40:18,230 --> 00:40:23,720
and you can instantiate a number of

00:40:20,930 --> 00:40:27,890
pipeline stages as you do that again

00:40:23,720 --> 00:40:29,960
you're accelerating your code once you

00:40:27,890 --> 00:40:31,910
have gone through that exercise you can

00:40:29,960 --> 00:40:34,190
then say okay make it into actual

00:40:31,910 --> 00:40:36,110
Hardware put it into the board and what

00:40:34,190 --> 00:40:39,020
it will do is it will instantiate the

00:40:36,110 --> 00:40:42,020
hardware as you heard earlier attach DMA

00:40:39,020 --> 00:40:44,210
engines and basically allow the data to

00:40:42,020 --> 00:40:46,100
move automatically from DDR memory to

00:40:44,210 --> 00:40:49,280
the accelerator and back to DDR memory

00:40:46,100 --> 00:40:50,840
and is from you for you as a software

00:40:49,280 --> 00:40:52,580
user well

00:40:50,840 --> 00:40:55,880
important thing is it takes that

00:40:52,580 --> 00:40:57,640
function call here keeps it the same but

00:40:55,880 --> 00:41:00,140
it removes all the software you had and

00:40:57,640 --> 00:41:01,940
instantiates the hardware calls and the

00:41:00,140 --> 00:41:04,460
pointers to the dar memory and the

00:41:01,940 --> 00:41:07,760
accelerators so it becomes transparent

00:41:04,460 --> 00:41:13,640
to you that you've actually replaced the

00:41:07,760 --> 00:41:17,930
software with hardware you download it

00:41:13,640 --> 00:41:21,830
and you run it so what are typical types

00:41:17,930 --> 00:41:24,500
of acceleration and generally my

00:41:21,830 --> 00:41:27,020
experience is that in the real world for

00:41:24,500 --> 00:41:29,750
most applications you'll get roughly a

00:41:27,020 --> 00:41:30,680
ten times acceleration and that can be

00:41:29,750 --> 00:41:35,990
huge

00:41:30,680 --> 00:41:40,340
my favorite example is that back

00:41:35,990 --> 00:41:44,030
projection algorithm ok there we got an

00:41:40,340 --> 00:41:46,910
eight times acceleration and you go ok

00:41:44,030 --> 00:41:48,200
well eight times acceleration that's not

00:41:46,910 --> 00:41:50,330
too shabby

00:41:48,200 --> 00:41:52,520
and oh by the way we tend to concur it

00:41:50,330 --> 00:41:55,010
against the processor we have so we have

00:41:52,520 --> 00:41:57,800
a 1/2 gigahertz processor so I 1/2

00:41:55,010 --> 00:42:03,050
gigahertz processor is appearing as if

00:41:57,800 --> 00:42:06,020
it's 8 times 15 what's 60 gigahertz

00:42:03,050 --> 00:42:10,760
processor ok obviously you can't buy

00:42:06,020 --> 00:42:14,420
that you can buy a multi-core that might

00:42:10,760 --> 00:42:16,190
start approaching that performance how

00:42:14,420 --> 00:42:20,770
many watts will that multi-core

00:42:16,190 --> 00:42:23,990
processor run ok over 100 watts probably

00:42:20,770 --> 00:42:28,430
meanwhile there we're consuming just a

00:42:23,990 --> 00:42:30,260
couple watts 16 K fast Fourier transform

00:42:28,430 --> 00:42:34,310
used in signal processing 10 times

00:42:30,260 --> 00:42:37,340
acceleration optical flow typically used

00:42:34,310 --> 00:42:40,070
in recognition applications looking for

00:42:37,340 --> 00:42:42,560
mu movement so here's optical flow

00:42:40,070 --> 00:42:44,090
that's yours truly and all I was doing

00:42:42,560 --> 00:42:45,740
was taking a picture myself and oh by

00:42:44,090 --> 00:42:47,480
the way moved ever so slightly when I

00:42:45,740 --> 00:42:53,630
took the picture so you can see my

00:42:47,480 --> 00:42:56,390
outline I'm sorry and there we got 25

00:42:53,630 --> 00:42:57,710
times acceleration stereo local block

00:42:56,390 --> 00:43:02,240
matching in other words we're actually

00:42:57,710 --> 00:43:04,730
looking for objects and their depth with

00:43:02,240 --> 00:43:07,490
the stereo camera 25 times 6

00:43:04,730 --> 00:43:10,310
raishin 2d video optical filter 30 times

00:43:07,490 --> 00:43:11,870
acceleration and then this whole neural

00:43:10,310 --> 00:43:13,670
network thing you heard about this

00:43:11,870 --> 00:43:17,570
morning eight thousand six hundred times

00:43:13,670 --> 00:43:21,860
faster okay so why that huge jump of

00:43:17,570 --> 00:43:26,750
eight thousand six hundred times and a

00:43:21,860 --> 00:43:29,660
couple pieces of magic the first of

00:43:26,750 --> 00:43:33,170
which is no networks happen to be very

00:43:29,660 --> 00:43:38,020
well organized repetitive processing

00:43:33,170 --> 00:43:41,990
functions and they tend to be large and

00:43:38,020 --> 00:43:44,770
so you're able to have a massive amount

00:43:41,990 --> 00:43:47,630
of computations and oh by the way they

00:43:44,770 --> 00:43:49,700
occur if you look at a neural network

00:43:47,630 --> 00:43:52,940
you'll see these diagrams that show you

00:43:49,700 --> 00:43:55,390
2d arrays and then they're just kind of

00:43:52,940 --> 00:43:58,000
stacked so you're talking about

00:43:55,390 --> 00:44:00,140
processing that it's done both in

00:43:58,000 --> 00:44:03,100
vertical and horizontal because

00:44:00,140 --> 00:44:03,100
frequently we're doing image processing

00:44:04,300 --> 00:44:09,560
simultaneously and then we're going to

00:44:06,410 --> 00:44:12,470
be doing multiple of these one after

00:44:09,560 --> 00:44:14,420
another of these planes of processing so

00:44:12,470 --> 00:44:16,850
it's a massive amount of computation

00:44:14,420 --> 00:44:18,530
it's all done locally it means that you

00:44:16,850 --> 00:44:21,440
can move this data very efficiently and

00:44:18,530 --> 00:44:26,270
effectively within the programmable

00:44:21,440 --> 00:44:30,170
logic and then a little bit of truth of

00:44:26,270 --> 00:44:31,940
advertising binary neural network please

00:44:30,170 --> 00:44:33,920
do it ten my presentation tomorrow I'll

00:44:31,940 --> 00:44:35,950
talk a little bit more about it but it

00:44:33,920 --> 00:44:39,290
means that we're doing the processing

00:44:35,950 --> 00:44:43,040
single bit type operations happen to be

00:44:39,290 --> 00:44:47,780
extremely efficient with our look-up

00:44:43,040 --> 00:44:49,940
tables and a little more truth in

00:44:47,780 --> 00:44:51,830
advertising if you look at embedded

00:44:49,940 --> 00:44:55,430
processors they're good at processing

00:44:51,830 --> 00:44:58,400
8-bits 16-bits thirty two-bit operations

00:44:55,430 --> 00:45:00,260
you ask it to do binary you can do

00:44:58,400 --> 00:45:01,940
binary operations but you're always

00:45:00,260 --> 00:45:03,560
having to add mask instructions

00:45:01,940 --> 00:45:05,960
afterwards after you dub binary

00:45:03,560 --> 00:45:09,460
operation so they're not real efficient

00:45:05,960 --> 00:45:09,460
at doing binary operations

00:45:14,650 --> 00:45:26,120
so yes question the question is do we

00:45:24,530 --> 00:45:31,820
have any networking workload

00:45:26,120 --> 00:45:36,140
accelerators we have a whole division

00:45:31,820 --> 00:45:38,300
and teams supported for data center

00:45:36,140 --> 00:45:42,110
operations and we do have customers that

00:45:38,300 --> 00:45:47,060
do network acceleration and accelerators

00:45:42,110 --> 00:45:50,140
using our I our devices some of the what

00:45:47,060 --> 00:45:52,670
a lot of those types of accelerators are

00:45:50,140 --> 00:45:59,750
typically done by third party partners

00:45:52,670 --> 00:46:02,090
or by the individual companies Tomas

00:45:59,750 --> 00:46:05,450
covered the neural network example

00:46:02,090 --> 00:46:08,330
earlier I just wanted to kind of add a

00:46:05,450 --> 00:46:14,980
few things so first you know couple

00:46:08,330 --> 00:46:19,850
pieces of trivia you know your engine is

00:46:14,980 --> 00:46:22,160
only as good as your training and so if

00:46:19,850 --> 00:46:27,200
you have a large data set life is really

00:46:22,160 --> 00:46:29,120
good in addition we actually start out

00:46:27,200 --> 00:46:30,260
with this German roadside database it

00:46:29,120 --> 00:46:32,090
happens to be kind of one of those

00:46:30,260 --> 00:46:33,020
standards in the industry especially if

00:46:32,090 --> 00:46:35,660
you're looking at automotive

00:46:33,020 --> 00:46:38,330
applications they're actually about a

00:46:35,660 --> 00:46:41,420
thousand images in that database we

00:46:38,330 --> 00:46:44,780
actually then went and rotated them plus

00:46:41,420 --> 00:46:46,910
or minus seven degrees and then we

00:46:44,780 --> 00:46:50,180
actually sized them up and down I think

00:46:46,910 --> 00:46:53,570
was plus or minus also seven percent the

00:46:50,180 --> 00:46:57,620
reason being is that neural networks are

00:46:53,570 --> 00:46:59,480
tend to be fairly picky about hey I see

00:46:57,620 --> 00:47:00,910
this image and if it's not exactly that

00:46:59,480 --> 00:47:03,590
same way then I'm going to increase the

00:47:00,910 --> 00:47:05,930
probably deuce the probability that I've

00:47:03,590 --> 00:47:09,140
got a match so if you add a little bit

00:47:05,930 --> 00:47:11,480
of error and in this case just by

00:47:09,140 --> 00:47:15,860
rotation and sizing it means you

00:47:11,480 --> 00:47:18,740
increase the recognition rate another

00:47:15,860 --> 00:47:20,240
fun one was there 43 road signs so

00:47:18,740 --> 00:47:23,030
originally all the training was done on

00:47:20,240 --> 00:47:25,010
the road signs and neural networks

00:47:23,030 --> 00:47:28,369
worked just like the human mind

00:47:25,010 --> 00:47:29,960
and so it did a great job as long as

00:47:28,369 --> 00:47:34,730
there was a scene with a road sign in it

00:47:29,960 --> 00:47:36,560
if there was scene with no road sign do

00:47:34,730 --> 00:47:38,240
you know how when we look out in the

00:47:36,560 --> 00:47:41,510
world and we look at it some random

00:47:38,240 --> 00:47:44,589
pattern and inevitably our mind will

00:47:41,510 --> 00:47:45,740
find a face two eyes nose and a mouth

00:47:44,589 --> 00:47:47,270
okay

00:47:45,740 --> 00:47:49,839
that's because we've kind of been

00:47:47,270 --> 00:47:53,720
trained to recognize faces

00:47:49,839 --> 00:47:56,000
well neural network if while it knows it

00:47:53,720 --> 00:47:59,540
signs it's going to find an assign in a

00:47:56,000 --> 00:48:01,579
scene where there's no sign and so we

00:47:59,540 --> 00:48:03,440
quickly discovered that it was

00:48:01,579 --> 00:48:07,190
constantly finding signs where there

00:48:03,440 --> 00:48:09,589
were none and so what we did was we went

00:48:07,190 --> 00:48:13,099
out and just took all these scenes and

00:48:09,589 --> 00:48:14,450
took the backgrounds and we reran the

00:48:13,099 --> 00:48:17,109
training set with all these different

00:48:14,450 --> 00:48:20,420
backgrounds didn't completely eliminate

00:48:17,109 --> 00:48:22,250
the false recognition but dramatically

00:48:20,420 --> 00:48:24,670
reduced it so just kind of piece of

00:48:22,250 --> 00:48:24,670
trivia

00:48:34,189 --> 00:48:44,789
performance results you're gonna see two

00:48:39,779 --> 00:48:48,209
sets in numbers and so you see the

00:48:44,789 --> 00:48:50,069
number up here and the whole 19,000

00:48:48,209 --> 00:48:54,569
times acceleration in this example

00:48:50,069 --> 00:48:57,049
19,000 times acceleration and then on

00:48:54,569 --> 00:48:58,349
the ultra 96 you'll see slightly lower

00:48:57,049 --> 00:49:00,180
okay

00:48:58,349 --> 00:49:01,979
well we have different size devices and

00:49:00,180 --> 00:49:04,259
the original implementation was done on

00:49:01,979 --> 00:49:05,969
one of our larger devices and one arm

00:49:04,259 --> 00:49:08,519
one of our larger devices we were able

00:49:05,969 --> 00:49:11,099
to clock it a little bit faster than we

00:49:08,519 --> 00:49:13,319
were able to do on the ultra 96 has to

00:49:11,099 --> 00:49:14,849
do with the fact on the ultra 96 being a

00:49:13,319 --> 00:49:20,519
smaller device we completely filled it

00:49:14,849 --> 00:49:23,459
up with the neural network software also

00:49:20,519 --> 00:49:27,959
like to point out in software when we

00:49:23,459 --> 00:49:30,920
ran it on the 853 eye we can do what we

00:49:27,959 --> 00:49:34,819
call tiles 2.1 seven tiles per second

00:49:30,920 --> 00:49:37,199
versus the hardware accelerated and then

00:49:34,819 --> 00:49:39,179
finally in terms of techniques there are

00:49:37,199 --> 00:49:42,719
different types of neural network

00:49:39,179 --> 00:49:46,069
engines there's a class of engines and

00:49:42,719 --> 00:49:50,420
so for example you saw on the keynote

00:49:46,069 --> 00:49:53,849
the ability to recognize human beings

00:49:50,420 --> 00:49:57,509
anywhere in a scene and that particular

00:49:53,849 --> 00:50:01,289
engine is able to do a single capture

00:49:57,509 --> 00:50:04,109
you only look once Yolo of anit of a

00:50:01,289 --> 00:50:07,859
scene and do a recognition other engines

00:50:04,109 --> 00:50:09,869
such as this particular CNN is designed

00:50:07,859 --> 00:50:11,849
to give it an image and it will come and

00:50:09,869 --> 00:50:13,799
say yes there's a sign there and this is

00:50:11,849 --> 00:50:15,929
what I think it is and oh by the way

00:50:13,799 --> 00:50:18,359
that's image you give it has to be 32 by

00:50:15,929 --> 00:50:21,329
32 so you have to go through this

00:50:18,359 --> 00:50:24,299
process of tiling so we start out with a

00:50:21,329 --> 00:50:26,309
large image and we create two tiles one

00:50:24,299 --> 00:50:30,239
left hand side one right hand side and

00:50:26,309 --> 00:50:32,849
we say is there sign there and then we

00:50:30,239 --> 00:50:35,339
go and keep cutting smaller and smaller

00:50:32,849 --> 00:50:37,380
tiles into the scene and that's why when

00:50:35,339 --> 00:50:39,179
you look at the recognition you will

00:50:37,380 --> 00:50:41,009
actually see in this example all the

00:50:39,179 --> 00:50:42,269
blocks are the same but when I was

00:50:41,009 --> 00:50:44,759
running you'd actually see different

00:50:42,269 --> 00:50:45,310
sized green blocks because those are

00:50:44,759 --> 00:50:47,860
actual

00:50:45,310 --> 00:50:52,240
miles and this is one of the difficult

00:50:47,860 --> 00:50:56,080
things to compare some folks are when

00:50:52,240 --> 00:50:59,650
they provide their number of images per

00:50:56,080 --> 00:51:01,390
second they are using this number which

00:50:59,650 --> 00:51:03,040
is the one week ten to site because

00:51:01,390 --> 00:51:06,310
everyone else does and says hey I'm

00:51:03,040 --> 00:51:08,380
processing 19,000 images per second

00:51:06,310 --> 00:51:11,230
in reality though frequently you have to

00:51:08,380 --> 00:51:13,960
go and tile across a scene and in this

00:51:11,230 --> 00:51:16,300
example when we do that with 320 tiles

00:51:13,960 --> 00:51:19,420
we're running at 94 frames per second or

00:51:16,300 --> 00:51:24,010
equivalent actually if you can switch

00:51:19,420 --> 00:51:28,170
over to the actual example you could

00:51:24,010 --> 00:51:28,170
switch over the HDMI monitor please

00:51:28,740 --> 00:51:34,200
could you switch over the HDMI monitor

00:51:31,600 --> 00:51:34,200
thank you

00:51:42,290 --> 00:51:46,460
there we go all right so you saw it

00:51:44,840 --> 00:51:48,860
earlier things you know just kind of

00:51:46,460 --> 00:51:53,290
interesting to point out is you'll see

00:51:48,860 --> 00:51:55,640
you will see different sized tiles also

00:51:53,290 --> 00:51:58,190
another thing you have to watch out for

00:51:55,640 --> 00:52:00,380
is a lot of times people will cite

00:51:58,190 --> 00:52:03,110
numbers they'll go and say I trained on

00:52:00,380 --> 00:52:04,880
a thousand images and then when I go

00:52:03,110 --> 00:52:08,420
back to my neural network engine I'm

00:52:04,880 --> 00:52:10,520
getting 97% accuracy and you go okay

00:52:08,420 --> 00:52:13,450
cool what's the data set you use oh use

00:52:10,520 --> 00:52:16,910
the thousand images that I trained on

00:52:13,450 --> 00:52:18,320
okay so that's not exactly fair well we

00:52:16,910 --> 00:52:20,780
actually did was we trained on the

00:52:18,320 --> 00:52:23,570
German side and wrote a data road side

00:52:20,780 --> 00:52:27,560
database and then we had somebody go out

00:52:23,570 --> 00:52:31,910
and take hundreds of pictures and that's

00:52:27,560 --> 00:52:33,920
what you're seeing in these scenes and

00:52:31,910 --> 00:52:38,480
then let's see let me just kind of pause

00:52:33,920 --> 00:52:43,250
this take a look at some of the

00:52:38,480 --> 00:52:46,340
interesting parts and so it looks like

00:52:43,250 --> 00:52:49,370
here we had a lot of success but again

00:52:46,340 --> 00:52:51,680
what you'll see is okay I recognize a

00:52:49,370 --> 00:52:54,470
particular sign it's passed by on the

00:52:51,680 --> 00:52:56,330
right 90% probability it's correct oh by

00:52:54,470 --> 00:53:00,650
the way could have been a roundabout

00:52:56,330 --> 00:53:03,700
sign okay here we basically came back

00:53:00,650 --> 00:53:05,870
and said everything else is less than 1%

00:53:03,700 --> 00:53:06,620
occasionally we'll get some interesting

00:53:05,870 --> 00:53:08,240
results

00:53:06,620 --> 00:53:11,770
let me just single step through if we

00:53:08,240 --> 00:53:11,770
can get a couple of the fun ones

00:53:24,270 --> 00:53:32,350
okay and here you can see okay here's

00:53:28,570 --> 00:53:33,460
one that came pretty challenging 60

00:53:32,350 --> 00:53:35,260
kilometers per hour

00:53:33,460 --> 00:53:38,770
we got it correct but only 17 percent

00:53:35,260 --> 00:53:41,470
probability for whatever the reason give

00:53:38,770 --> 00:53:43,870
way was 18 percent bicycle crossing

00:53:41,470 --> 00:53:45,850
ahead three percent so a lot of this

00:53:43,870 --> 00:53:48,670
also has to do with training fair

00:53:45,850 --> 00:53:50,350
probability that that 60 kilometer sign

00:53:48,670 --> 00:53:56,760
maybe there were fewer samples in the

00:53:50,350 --> 00:54:00,970
database to be trained on all right

00:53:56,760 --> 00:54:02,830
wrapping up we got a late start so

00:54:00,970 --> 00:54:07,740
whoever if someone has next session I

00:54:02,830 --> 00:54:12,310
apologize so couple things

00:54:07,740 --> 00:54:16,090
and again blatant pitch for Xilinx we've

00:54:12,310 --> 00:54:18,550
been at it for a while we provide all

00:54:16,090 --> 00:54:21,850
the layers in the stack to help you get

00:54:18,550 --> 00:54:23,830
started you know we start with silicon

00:54:21,850 --> 00:54:27,640
we have these development kits the

00:54:23,830 --> 00:54:29,530
manaro ultra 96 board is just one

00:54:27,640 --> 00:54:31,090
example of development kits we have

00:54:29,530 --> 00:54:32,680
software development tools we have

00:54:31,090 --> 00:54:34,660
hardware development tools we have the

00:54:32,680 --> 00:54:37,360
operating systems that go on top of it

00:54:34,660 --> 00:54:39,460
we have reference designs are the

00:54:37,360 --> 00:54:40,660
incidentally the demo that I've just

00:54:39,460 --> 00:54:42,010
showed you it's going to be one of the

00:54:40,660 --> 00:54:44,530
first reference designs that we're

00:54:42,010 --> 00:54:47,050
publishing and then you can take all

00:54:44,530 --> 00:54:54,370
that pick it apart and then create your

00:54:47,050 --> 00:54:57,220
own designs again please do come by our

00:54:54,370 --> 00:55:01,960
table on Friday we'd love to have you

00:54:57,220 --> 00:55:03,460
submit a design example Craig go ahead

00:55:01,960 --> 00:55:06,790
and stand up Craig is running the

00:55:03,460 --> 00:55:08,980
contest here you can also corner him and

00:55:06,790 --> 00:55:11,410
start talking about your design examples

00:55:08,980 --> 00:55:13,600
and maybe brainstorming or feel free to

00:55:11,410 --> 00:55:15,280
brainstorm with me and yeah we can kind

00:55:13,600 --> 00:55:17,320
of tell you what we have and you'll kind

00:55:15,280 --> 00:55:18,730
of help you give some constraints so you

00:55:17,320 --> 00:55:22,720
might be more successful in your

00:55:18,730 --> 00:55:25,300
proposal but create a proposal we're

00:55:22,720 --> 00:55:30,160
gonna give you out what 30 of these

00:55:25,300 --> 00:55:31,870
sports and it's interesting I'm sorry

00:55:30,160 --> 00:55:35,860
we've got 25 of these boards giving out

00:55:31,870 --> 00:55:38,170
and I apologize Craig I've got an old

00:55:35,860 --> 00:55:44,200
slide in my deck for some reason

00:55:38,170 --> 00:55:46,150
and anyways we've got gift cards we'll

00:55:44,200 --> 00:55:48,400
be giving and we'd like to see if we

00:55:46,150 --> 00:55:50,680
make this a fun thing and oh by the one

00:55:48,400 --> 00:55:52,390
way the guy that's number one where

00:55:50,680 --> 00:55:54,039
you're gonna get pressed from Xilinx

00:55:52,390 --> 00:55:56,109
will publish you and we're going to

00:55:54,039 --> 00:55:58,180
invite you to our developers forum we

00:55:56,109 --> 00:55:59,410
have these coming up next year they'll

00:55:58,180 --> 00:56:04,809
be in three different worldwide

00:55:59,410 --> 00:56:06,519
locations so bottom line if your

00:56:04,809 --> 00:56:09,490
software developer I'd like to kind of

00:56:06,519 --> 00:56:11,230
just reassure you that you will be able

00:56:09,490 --> 00:56:12,900
to develop your software in kind of a

00:56:11,230 --> 00:56:16,890
development environment you're used to

00:56:12,900 --> 00:56:18,069
that you can do this on chip you know

00:56:16,890 --> 00:56:19,809
debugging

00:56:18,069 --> 00:56:22,000
we've got extensive libraries in IP

00:56:19,809 --> 00:56:24,730
we've got the tools for creating that

00:56:22,000 --> 00:56:26,920
software moving it over to hardware you

00:56:24,730 --> 00:56:30,730
heard about SD SOC and the free license

00:56:26,920 --> 00:56:33,010
that will give you for one year and

00:56:30,730 --> 00:56:34,750
we've got we have pre-built reference

00:56:33,010 --> 00:56:40,019
designs that will be available with the

00:56:34,750 --> 00:56:40,019
board okay couple minutes for questions

00:56:40,950 --> 00:56:43,950
yes

00:56:54,940 --> 00:57:02,210
okay so the question was you know today

00:56:59,120 --> 00:57:06,500
how does the FPGA compare to neural

00:57:02,210 --> 00:57:07,970
processing units it's to be honest and

00:57:06,500 --> 00:57:09,680
in my mind right now

00:57:07,970 --> 00:57:12,350
we are in kind of the wild wild west

00:57:09,680 --> 00:57:15,440
when it comes to you know neural

00:57:12,350 --> 00:57:17,300
processing engines there's a whole bunch

00:57:15,440 --> 00:57:20,930
of these technologies are coming in

00:57:17,300 --> 00:57:23,090
people with good ideas on how to go and

00:57:20,930 --> 00:57:27,290
implement you know these neural

00:57:23,090 --> 00:57:29,180
processing engines and you have their

00:57:27,290 --> 00:57:34,100
general-purpose processors there's no

00:57:29,180 --> 00:57:36,500
doubt in my mind that you know a FPGA

00:57:34,100 --> 00:57:38,510
device can create far more

00:57:36,500 --> 00:57:40,370
cost-effective power effective

00:57:38,510 --> 00:57:43,580
acceleration compared to a

00:57:40,370 --> 00:57:46,970
general-purpose processor inevitably I

00:57:43,580 --> 00:57:50,090
get the question about you know GPUs GP

00:57:46,970 --> 00:57:51,620
GPUs how do we compare and then I invite

00:57:50,090 --> 00:57:53,930
you to go out and take a look at some of

00:57:51,620 --> 00:57:57,260
the industry literature Tomas had one of

00:57:53,930 --> 00:57:59,840
the slides and the answer is that there

00:57:57,260 --> 00:58:02,150
are different scenarios where we come

00:57:59,840 --> 00:58:04,910
ahead there are some scenarios where GP

00:58:02,150 --> 00:58:07,250
GPUs can come ahead but what we really

00:58:04,910 --> 00:58:10,010
believe is that we offer far greater

00:58:07,250 --> 00:58:12,440
flexibility and when you look at neural

00:58:10,010 --> 00:58:14,510
networks you ask people okay what's the

00:58:12,440 --> 00:58:16,760
network topology I should be using for

00:58:14,510 --> 00:58:19,970
my application their response is going

00:58:16,760 --> 00:58:22,190
to be it depends and it's a black art

00:58:19,970 --> 00:58:25,400
and you need to experiment a lot and

00:58:22,190 --> 00:58:27,230
this is where programmable logic really

00:58:25,400 --> 00:58:29,540
helps you come ahead because you can

00:58:27,230 --> 00:58:33,110
create any architecture you want in that

00:58:29,540 --> 00:58:35,240
implementation okay I think we've taken

00:58:33,110 --> 00:58:38,860
our time run a little bit past we got a

00:58:35,240 --> 00:58:38,860
late start thank you very much

00:58:39,759 --> 00:58:41,819
you

00:58:49,280 --> 00:58:51,340

YouTube URL: https://www.youtube.com/watch?v=ZYXubMrgTfU


