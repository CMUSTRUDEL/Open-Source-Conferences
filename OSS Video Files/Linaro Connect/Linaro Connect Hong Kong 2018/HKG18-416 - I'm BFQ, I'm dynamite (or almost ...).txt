Title: HKG18-416 - I'm BFQ, I'm dynamite (or almost ...)
Publication date: 2019-05-09
Playlist: Linaro Connect Hong Kong 2018
Description: 
	Session ID: HKG18-416
Session Name: HKG18-416 - I'm BFQ, I'm dynamite (or almost ...)
Speaker: Paolo Valente
Track: Kernel


★ Session Summary ★
BFQ has greatly improved over the last months.  Now it handles I/O at
up to 400+ KIOPS with commodity CPUs, and extends its close-to-optimal
responsiveness guarantees on any single-queue storage medium, from
eMMC to fast SSDs.  In this presentation we show these improvements,
and:
- show how the work 'around' BFQ also influenced the benchmarking
arena: from the consolidation of a responsiveness (application
start-up time) test in the Phoronix benchmark suite, to the entry of
the same test in the MMtests suite;
- prove the good match between BFQ and the new blk-mq support in mmc
(Ulf&Linus work), with demos and graphs;
- provide an update on the status of the proposal of BFQ as the
default I/O scheduler for all single-queue storage;
- list the next important challenges for letting BFQ enter the
server&cloud world too.
---------------------------------------------------
★ Resources ★
Event Page: http://connect.linaro.org/resource/hkg18/hkg18-416/
Presentation: http://connect.linaro.org.s3.amazonaws.com/hkg18/presentations/hkg18-416.pdf
Video: http://connect.linaro.org.s3.amazonaws.com/hkg18/videos/hkg18-416.mp4
 ---------------------------------------------------
★ Event Details ★
Linaro Connect Hong Kong 2018 (HKG18)
19-23 March 2018 
Regal Airport Hotel Hong Kong

---------------------------------------------------
Keyword: Kernel
'http://www.linaro.org'
'http://connect.linaro.org'
---------------------------------------------------
Follow us on Social Media
https://www.facebook.com/LinaroOrg
https://www.youtube.com/user/linaroorg?sub_confirmation=1
https://www.linkedin.com/company/1026961
Captions: 
	00:00:04,370 --> 00:00:06,430
you

00:00:16,920 --> 00:00:25,119
this presentation with a humble title

00:00:20,830 --> 00:00:28,060
started actually this is a wordplay with

00:00:25,119 --> 00:00:30,040
this is a homophone wordplay but

00:00:28,060 --> 00:00:32,050
according to the feedback that I

00:00:30,040 --> 00:00:34,540
received it was not so successful

00:00:32,050 --> 00:00:37,090
because I think that nobody got it

00:00:34,540 --> 00:00:42,370
it's a book lady that less of a popular

00:00:37,090 --> 00:00:46,860
song of heavy metal group but yeah so if

00:00:42,370 --> 00:00:54,250
I remember and tell you the song the end

00:00:46,860 --> 00:00:57,940
the presentation of this presentation is

00:00:54,250 --> 00:01:01,589
mainly reporting back on what has been

00:00:57,940 --> 00:01:01,589
done in the last month

00:01:01,860 --> 00:01:09,220
and then I'll show you a demo just to

00:01:07,150 --> 00:01:12,430
give you an example what if you can do

00:01:09,220 --> 00:01:18,360
now the next thing is the disdain is

00:01:12,430 --> 00:01:22,479
finally with the MMC substa subsystem

00:01:18,360 --> 00:01:26,820
supporting rocketship so again we are

00:01:22,479 --> 00:01:31,359
tasked with block thank you and MMC and

00:01:26,820 --> 00:01:34,810
then I will finish by sharing with you

00:01:31,359 --> 00:01:37,360
what I would like to do as next steps so

00:01:34,810 --> 00:01:39,940
as you have seen this present

00:01:37,360 --> 00:01:43,270
is about an i/o scheduler so just to

00:01:39,940 --> 00:01:45,970
make sure that we are all on the same

00:01:43,270 --> 00:01:49,530
page just spend a few words about our

00:01:45,970 --> 00:01:53,220
schedule is someone know them so

00:01:49,530 --> 00:01:55,780
designers gathered our components that

00:01:53,220 --> 00:01:58,180
decide the order in which I know

00:01:55,780 --> 00:02:01,330
requests are to be set by eBay in a

00:01:58,180 --> 00:02:03,790
storage device in particular they do

00:02:01,330 --> 00:02:07,150
this job in case there are several

00:02:03,790 --> 00:02:09,759
processes competing for the same storage

00:02:07,150 --> 00:02:12,550
device and in that case it's about the

00:02:09,759 --> 00:02:16,720
same role as a traffic policeman on a

00:02:12,550 --> 00:02:21,280
crossroads so this job is rather

00:02:16,720 --> 00:02:24,880
important why because it is necessary to

00:02:21,280 --> 00:02:27,700
achieve several relevant goals and what

00:02:24,880 --> 00:02:31,090
this glossy is reaching a high altitude

00:02:27,700 --> 00:02:34,360
you need to control the service order of

00:02:31,090 --> 00:02:36,480
requests because storage device are the

00:02:34,360 --> 00:02:39,760
truth of storage devices is very

00:02:36,480 --> 00:02:42,549
sensitive with respect to the service

00:02:39,760 --> 00:02:45,519
order of i/o requests another important

00:02:42,549 --> 00:02:49,239
goal is guaranteeing a low latency to

00:02:45,519 --> 00:02:51,850
the tasks that to be accomplished need I

00:02:49,239 --> 00:02:56,370
hope for example reading the frames of a

00:02:51,850 --> 00:03:00,010
video in important class of tasks is our

00:02:56,370 --> 00:03:02,560
interactive tasks for example starting

00:03:00,010 --> 00:03:06,549
an application reading a file and so on

00:03:02,560 --> 00:03:10,510
in this case if you guarantee a low

00:03:06,549 --> 00:03:12,549
latency to interactive tasks in a system

00:03:10,510 --> 00:03:15,070
then you are guaranteeing a high

00:03:12,549 --> 00:03:17,440
responsiveness to applications to

00:03:15,070 --> 00:03:21,640
services to whatever in the end

00:03:17,440 --> 00:03:23,920
assistance in the terminology of typical

00:03:21,640 --> 00:03:28,209
technology of the mobile computing this

00:03:23,920 --> 00:03:29,930
is for the guaranteeing they say

00:03:28,209 --> 00:03:32,519
guarantee

00:03:29,930 --> 00:03:34,650
the equivalent of Delta high response

00:03:32,519 --> 00:03:41,819
let's get a look at that other

00:03:34,650 --> 00:03:45,150
technology but in my work on bfq and to

00:03:41,819 --> 00:03:49,200
the same dis presentation I used as a

00:03:45,150 --> 00:03:50,730
reference for responsiveness the startup

00:03:49,200 --> 00:03:53,760
time of applications

00:03:50,730 --> 00:03:55,530
so starting application is evidently an

00:03:53,760 --> 00:03:57,959
important example of an interactive

00:03:55,530 --> 00:04:00,780
tasks measuring the standard time of an

00:03:57,959 --> 00:04:03,540
application is evidently a good measure

00:04:00,780 --> 00:04:07,200
of responsiveness and it also gives us

00:04:03,540 --> 00:04:12,140
an idea of the latency that we can

00:04:07,200 --> 00:04:15,030
guarantee to any constable generic okay

00:04:12,140 --> 00:04:17,459
this schedulers have also other goals

00:04:15,030 --> 00:04:21,500
but this sort of scope for this

00:04:17,459 --> 00:04:24,660
presentation and finally these

00:04:21,500 --> 00:04:27,539
components in a little layer in the

00:04:24,660 --> 00:04:32,910
other step the alias Technol comes in

00:04:27,539 --> 00:04:36,780
two flavors the legacy and the new multi

00:04:32,910 --> 00:04:46,050
cue blob layer look at you these sets of

00:04:36,780 --> 00:04:49,710
schedulers available in particular bsq

00:04:46,050 --> 00:04:52,669
is not available in the legacy block

00:04:49,710 --> 00:04:56,340
layer you can have it on me out of trip

00:04:52,669 --> 00:05:01,500
while fortunately it has been added into

00:04:56,340 --> 00:05:04,680
the new block engine ok so first part of

00:05:01,500 --> 00:05:08,250
this presentation what has been done we

00:05:04,680 --> 00:05:13,590
have improved beauty we have made it

00:05:08,250 --> 00:05:16,979
faster and made it more effective in

00:05:13,590 --> 00:05:19,889
terms of guaranteeing low latency and at

00:05:16,979 --> 00:05:23,940
the same time guarantee a heightened

00:05:19,889 --> 00:05:26,880
activation details how much work the

00:05:23,940 --> 00:05:29,970
effort has been I tried to evaluate it

00:05:26,880 --> 00:05:35,010
around 18 verse one month

00:05:29,970 --> 00:05:40,380
spread over 12 persons 12 people and me

00:05:35,010 --> 00:05:42,960
plus 11 11 students each of them has

00:05:40,380 --> 00:05:45,210
really worked at a listen as altered or

00:05:42,960 --> 00:05:47,550
at least signed it was one of the

00:05:45,210 --> 00:05:51,330
contributions that were not publicly

00:05:47,550 --> 00:05:59,490
available whether these contributions as

00:05:51,330 --> 00:06:01,979
for 37 new commits and filed this and 14

00:05:59,490 --> 00:06:06,210
signed by people in this task force and

00:06:01,979 --> 00:06:09,479
authorized by me okay and then really a

00:06:06,210 --> 00:06:11,460
ton of to meet for the development

00:06:09,479 --> 00:06:13,710
branch of PHP which is the branch where

00:06:11,460 --> 00:06:17,690
we do the actual work then from the

00:06:13,710 --> 00:06:20,340
branch will beat the commands to submit

00:06:17,690 --> 00:06:26,270
also this case 16 of this committee

00:06:20,340 --> 00:06:30,030
authored by several good young students

00:06:26,270 --> 00:06:32,729
but we already have additional to miss

00:06:30,030 --> 00:06:35,250
14 commits are under test so we just

00:06:32,729 --> 00:06:37,650
need to finish testing that and then

00:06:35,250 --> 00:06:43,260
they are ready to be to be

00:06:37,650 --> 00:06:46,919
meet and I already have 418 patches that

00:06:43,260 --> 00:06:49,350
I sketched or designed to work on them

00:06:46,919 --> 00:06:54,050
when it is time to finally we are the

00:06:49,350 --> 00:06:56,760
good point in improving the interface of

00:06:54,050 --> 00:07:00,320
C groups for the annual controller

00:06:56,760 --> 00:07:03,780
because there there is a problem there

00:07:00,320 --> 00:07:06,389
the new controller provides the so

00:07:03,780 --> 00:07:09,419
called proportional share policy you can

00:07:06,389 --> 00:07:12,720
assign weights to try the group 20 group

00:07:09,419 --> 00:07:14,610
and the group will receive a fraction of

00:07:12,720 --> 00:07:18,240
the throughput proportional to its

00:07:14,610 --> 00:07:22,919
weight but it doesn't work because it

00:07:18,240 --> 00:07:26,430
was only with CSU the it's wired around

00:07:22,919 --> 00:07:28,770
the city while schedule yeah so this is

00:07:26,430 --> 00:07:31,729
the problem we are unified interface in

00:07:28,770 --> 00:07:34,610
such a way that you can seamlessly

00:07:31,729 --> 00:07:37,710
activate the proportional share policy

00:07:34,610 --> 00:07:40,130
whatever the underlying scheduler feeds

00:07:37,710 --> 00:07:42,750
and this is actually providing other

00:07:40,130 --> 00:07:46,400
benefits for the interface but we will

00:07:42,750 --> 00:07:51,840
see when we iranian we will submit

00:07:46,400 --> 00:07:56,280
commits changing the interface okay we

00:07:51,840 --> 00:07:59,490
also contributed to the benchmarking

00:07:56,280 --> 00:08:02,130
area in demotic area we are now at the

00:07:59,490 --> 00:08:04,979
third version of a new test for the FIR

00:08:02,130 --> 00:08:09,599
onyx the bet retreated responsiveness

00:08:04,979 --> 00:08:13,710
test but now we have the same test also

00:08:09,599 --> 00:08:14,880
in the mm test suite this is basically

00:08:13,710 --> 00:08:17,789
because of you

00:08:14,880 --> 00:08:20,340
a viewer feel that with the feedback you

00:08:17,789 --> 00:08:23,760
gave me about four ensuite that rang

00:08:20,340 --> 00:08:27,419
some bells and I decided to to look for

00:08:23,760 --> 00:08:32,890
other many other Suites other people

00:08:27,419 --> 00:08:36,610
that had somehow more credit yes

00:08:32,890 --> 00:08:40,209
okay fortunately we made it and we are

00:08:36,610 --> 00:08:42,039
just finalizing the post-processing with

00:08:40,209 --> 00:08:44,350
the results but they already tried the

00:08:42,039 --> 00:08:52,810
testing but they didn't like the results

00:08:44,350 --> 00:08:55,089
again this tests live in the s bedrock

00:08:52,810 --> 00:09:00,399
Street which is the main street that I'm

00:08:55,089 --> 00:09:06,070
using for testing and also for this base

00:09:00,399 --> 00:09:11,829
suite we have now a new interesting

00:09:06,070 --> 00:09:13,930
future it can now briefly the idea of an

00:09:11,829 --> 00:09:16,120
application because to measure

00:09:13,930 --> 00:09:18,510
responsiveness we measure the startup

00:09:16,120 --> 00:09:23,620
time of applications but in some cases

00:09:18,510 --> 00:09:26,589
it's hard to automatically start certain

00:09:23,620 --> 00:09:29,589
application especially X publications so

00:09:26,589 --> 00:09:32,019
with this new feature it can replay of

00:09:29,589 --> 00:09:33,760
that application without actually

00:09:32,019 --> 00:09:36,130
starting the application this can be

00:09:33,760 --> 00:09:41,800
rather helpful on systems where it is

00:09:36,130 --> 00:09:50,550
tricky to add those applications ok that

00:09:41,800 --> 00:09:58,870
in general really a lot of commits means

00:09:50,550 --> 00:10:01,750
surviving ok what did we improve with

00:09:58,870 --> 00:10:05,890
all these contributions well we took the

00:10:01,750 --> 00:10:12,160
efficiency we made a few faster and here

00:10:05,890 --> 00:10:14,380
does some example I mean this Q is an

00:10:12,160 --> 00:10:17,710
accurate on your schedule so it is

00:10:14,380 --> 00:10:21,280
to make non-trivial decisions when it is

00:10:17,710 --> 00:10:23,290
time to decide the service order this

00:10:21,280 --> 00:10:26,860
implies that it has to take several

00:10:23,290 --> 00:10:30,730
steps which means that it takes time so

00:10:26,860 --> 00:10:33,670
we shorten at this time and so we

00:10:30,730 --> 00:10:37,390
increase the number of i/os that can be

00:10:33,670 --> 00:10:40,240
processes when you have pfq a scheduler

00:10:37,390 --> 00:10:44,080
for example on an intel i7 we are now at

00:10:40,240 --> 00:10:47,290
around four hundred kilowatts and on the

00:10:44,080 --> 00:11:13,660
processor of the healthy board then we

00:10:47,290 --> 00:11:17,140
reach the it's just that to sell and

00:11:13,660 --> 00:11:21,930
your requests at a given speed a you

00:11:17,140 --> 00:11:25,890
must execute all the code needed to

00:11:21,930 --> 00:11:28,120
process each of those requests in time

00:11:25,890 --> 00:11:31,680
okay you

00:11:28,120 --> 00:11:35,020
I mean requests just don't flow from

00:11:31,680 --> 00:11:37,420
processes to device they are processed

00:11:35,020 --> 00:11:41,020
it in the i/o step and the other spec

00:11:37,420 --> 00:11:42,760
must be fast enough to comply with the

00:11:41,020 --> 00:11:45,550
rate at which you want to sell the

00:11:42,760 --> 00:11:48,970
requests every single request must be

00:11:45,550 --> 00:11:51,220
processing so you can sustain a certain

00:11:48,970 --> 00:11:57,720
number of ayaats if you are fast enough

00:11:51,220 --> 00:11:59,800
in processing requests okay

00:11:57,720 --> 00:12:02,260
sustainable because there's there's

00:11:59,800 --> 00:12:04,060
another semantically sustainable that's

00:12:02,260 --> 00:12:08,560
a state building material like

00:12:04,060 --> 00:12:11,260
environmental existing yes and not

00:12:08,560 --> 00:12:14,530
sustainable s so hence the confusion

00:12:11,260 --> 00:12:21,850
yeah it'll probably it's their support

00:12:14,530 --> 00:12:23,950
yeah it's just that you don't go faster

00:12:21,850 --> 00:12:28,620
than four rather key layout if you

00:12:23,950 --> 00:12:32,860
attach the for example no block model

00:12:28,620 --> 00:12:34,630
yeah yeah and that's the maximum speed

00:12:32,860 --> 00:12:37,450
you reach just because the CPU is the

00:12:34,630 --> 00:12:40,240
bottom and it doesn't okay

00:12:37,450 --> 00:12:41,920
the other question I had a a difference

00:12:40,240 --> 00:12:52,330
between factors are you - kruseman on

00:12:41,920 --> 00:12:57,120
Intel and is there any reason for is it

00:12:52,330 --> 00:13:01,300
just because we didn't have accurate

00:12:57,120 --> 00:13:03,930
measures for the Intel so 50 were just

00:13:01,300 --> 00:13:07,450
conservative so that is a mixture of

00:13:03,930 --> 00:13:09,310
actual improvement and improvement in

00:13:07,450 --> 00:13:13,120
the measurement because it's not that

00:13:09,310 --> 00:13:17,650
easy to measure that number is we had to

00:13:13,120 --> 00:13:20,260
write a dedicated text also this reason

00:13:17,650 --> 00:13:23,650
that we also made that wet spot speed s

00:13:20,260 --> 00:13:27,160
io speed something made by another

00:13:23,650 --> 00:13:30,220
student of mine and yes it was you to to

00:13:27,160 --> 00:13:34,090
measure of that and now using that speed

00:13:30,220 --> 00:13:36,700
we could precisely measure what we the

00:13:34,090 --> 00:13:39,280
actual so I don't really know how was

00:13:36,700 --> 00:13:47,110
before but for sure now I can do that

00:13:39,280 --> 00:13:49,600
it's 400 then we improve also the true

00:13:47,110 --> 00:13:53,790
boots that can be a shield by the fu

00:13:49,600 --> 00:13:56,460
this is by improving the service order

00:13:53,790 --> 00:13:58,080
request in us in a particular case we

00:13:56,460 --> 00:14:01,140
had problem in this particular case

00:13:58,080 --> 00:14:03,960
righto video on flesh storage without

00:14:01,140 --> 00:14:06,870
internet you which means the storage of

00:14:03,960 --> 00:14:09,420
directly board and yeah we saw that this

00:14:06,870 --> 00:14:11,970
problem and now we we are went from

00:14:09,420 --> 00:14:14,190
seven megabytes per second to more than

00:14:11,970 --> 00:14:18,390
15 megabytes per sec which is the peak

00:14:14,190 --> 00:14:24,630
rate as for responsiveness

00:14:18,390 --> 00:14:26,730
we removed several nasty outliers they

00:14:24,630 --> 00:14:31,380
were I mean occasional but they were

00:14:26,730 --> 00:14:33,420
very nasty and so for example with

00:14:31,380 --> 00:14:35,640
LibreOffice writer and some heavy

00:14:33,420 --> 00:14:38,060
workloads in the background on certain

00:14:35,640 --> 00:14:40,800
devices like the Play Store SSB

00:14:38,060 --> 00:14:44,400
occasionally liberal his brother took

00:14:40,800 --> 00:14:47,430
like 45 seconds to start to the spanning

00:14:44,400 --> 00:14:49,730
infinite and we solve the problem now

00:14:47,430 --> 00:14:53,610
the time is just one second

00:14:49,730 --> 00:14:56,670
against about 14 seconds with any of the

00:14:53,610 --> 00:14:59,940
other iOS gamers we had another player

00:14:56,670 --> 00:15:04,320
that somehow was triggered in on the

00:14:59,940 --> 00:15:06,900
father s SP and it's almost more than

00:15:04,320 --> 00:15:08,910
double to the start time we removed that

00:15:06,900 --> 00:15:11,580
to another around three seconds against

00:15:08,910 --> 00:15:15,090
20 seconds with Alaska and other pieces

00:15:11,580 --> 00:15:17,010
but I don't want to volume because this

00:15:15,090 --> 00:15:19,830
is the end of another supporters view

00:15:17,010 --> 00:15:23,100
survive to this part of boring numbers

00:15:19,830 --> 00:15:25,350
here the reward which is this disdain

00:15:23,100 --> 00:15:28,950
which probably is a little bit less

00:15:25,350 --> 00:15:31,230
boring they notice numbers and some

00:15:28,950 --> 00:15:35,370
drugs but they are only some extra

00:15:31,230 --> 00:15:37,830
slides I showed them only on the

00:15:35,370 --> 00:15:40,230
mountain I guess it would be such a

00:15:37,830 --> 00:15:42,670
demand so just to credit limbs for

00:15:40,230 --> 00:15:47,680
running the test from each

00:15:42,670 --> 00:15:55,660
this resulted in obtained so the demo is

00:15:47,680 --> 00:16:00,070
with the Heike and the application it's

00:15:55,660 --> 00:16:03,070
like in Daniel and the scandal 4.16 that

00:16:00,070 --> 00:16:05,410
was the release candidate to the most

00:16:03,070 --> 00:16:08,950
recent release when I did this method

00:16:05,410 --> 00:16:11,530
shown in the video the application for

00:16:08,950 --> 00:16:15,490
which I measured the start time was

00:16:11,530 --> 00:16:16,960
extended actually replay that your

00:16:15,490 --> 00:16:19,570
courage step because I had problem with

00:16:16,960 --> 00:16:24,670
the expeller with that release candidate

00:16:19,570 --> 00:16:28,960
and so we will start extend first

00:16:24,670 --> 00:16:32,380
without any i/o in the background just

00:16:28,960 --> 00:16:34,060
to see how long it takes and then we

00:16:32,380 --> 00:16:37,030
will repeat this test with some of you

00:16:34,060 --> 00:16:39,190
in the background so to start this is

00:16:37,030 --> 00:16:42,760
one of the speeds in the s benchmark

00:16:39,190 --> 00:16:45,790
suite so will repeat this twice with no

00:16:42,760 --> 00:16:51,250
background the workload and the start

00:16:45,790 --> 00:16:54,700
time should be not 0.3 seconds of course

00:16:51,250 --> 00:16:58,330
we call caches because we want actual IO

00:16:54,700 --> 00:17:01,360
now we repeat this but we will put in

00:16:58,330 --> 00:17:04,600
the background Wi-Fi read and 1 5 right

00:17:01,360 --> 00:17:06,880
so basically if I copy know as IO

00:17:04,600 --> 00:17:09,070
scheduler but the results that you are

00:17:06,880 --> 00:17:11,590
about to see at the same with any of the

00:17:09,070 --> 00:17:14,380
other schedulers we will do this only

00:17:11,590 --> 00:17:17,170
once so what we the one right at

00:17:14,380 --> 00:17:18,430
sequential and you are about to discover

00:17:17,170 --> 00:17:21,280
why

00:17:18,430 --> 00:17:27,450
once because you can go take a coffee

00:17:21,280 --> 00:17:30,250
because just what stuff why because the

00:17:27,450 --> 00:17:34,270
an event the background is sequential

00:17:30,250 --> 00:17:37,690
ingredie which is the perfect idea to

00:17:34,270 --> 00:17:39,940
get the peak rate for this reason this

00:17:37,690 --> 00:17:43,300
is the a note that both the higher spec

00:17:39,940 --> 00:17:45,310
and the logic inside the device do love

00:17:43,300 --> 00:17:46,810
they love the spec for you because it

00:17:45,310 --> 00:17:50,050
gives you the peak rate so they

00:17:46,810 --> 00:17:54,370
privilege this a yob with respect to the

00:17:50,050 --> 00:17:59,950
mostly random i/o to spartax them that's

00:17:54,370 --> 00:18:00,700
why that stops when something gets to

00:17:59,950 --> 00:18:05,380
say

00:18:00,700 --> 00:18:09,100
yeah no it's almost article and this is

00:18:05,380 --> 00:18:12,310
what you get a lot of it I mean infinite

00:18:09,100 --> 00:18:15,670
now we're if it is test but with a much

00:18:12,310 --> 00:18:19,450
heavier workload five readers and five

00:18:15,670 --> 00:18:23,020
writers but this time we will let me ask

00:18:19,450 --> 00:18:25,500
you handle the area and we will repeat

00:18:23,020 --> 00:18:30,820
this a few times to check variability

00:18:25,500 --> 00:18:39,280
three times five readers five riders but

00:18:30,820 --> 00:18:45,190
this time esq is a useful and on average

00:18:39,280 --> 00:18:48,070
it should be zero to change these are

00:18:45,190 --> 00:18:56,010
the current this is the current

00:18:48,070 --> 00:18:56,010
performance okay

00:18:58,160 --> 00:19:03,710
first it isn't completely obvious but

00:19:00,890 --> 00:19:05,870
having five three dozen five writers is

00:19:03,710 --> 00:19:08,780
a case that is worse than having one

00:19:05,870 --> 00:19:11,390
read and one right yeah but it's just

00:19:08,780 --> 00:19:13,300
that every experimental II I've seen

00:19:11,390 --> 00:19:16,130
that it's killer

00:19:13,300 --> 00:19:20,870
if you did this the fabulous by

00:19:16,130 --> 00:19:24,790
practicing longer than yes basically it

00:19:20,870 --> 00:19:28,480
will go on forever it goes on forever

00:19:24,790 --> 00:19:28,480
there is a reason for that

00:19:28,630 --> 00:19:38,210
okay so be a few seems to be much better

00:19:35,660 --> 00:19:42,170
than those other scale in terms of

00:19:38,210 --> 00:19:44,890
responsiveness and I didn't show it that

00:19:42,170 --> 00:19:48,080
bulimia they have those extras lies it's

00:19:44,890 --> 00:19:49,580
about the same terms of truth so it has

00:19:48,080 --> 00:19:52,040
about the same performance the other

00:19:49,580 --> 00:19:55,010
skater in terms of truth so in the end

00:19:52,040 --> 00:19:58,150
is much better still it is not the

00:19:55,010 --> 00:20:02,710
default is here the default is deadline

00:19:58,150 --> 00:20:06,820
this makes sense on very fast devices

00:20:02,710 --> 00:20:14,960
because deadline is very lightweight

00:20:06,820 --> 00:20:18,880
it's almost nothing so the sustainable

00:20:14,960 --> 00:20:23,090
through good in the case is higher but

00:20:18,880 --> 00:20:27,170
for I mean there are also devices that

00:20:23,090 --> 00:20:31,190
are not super fast like all single Q

00:20:27,170 --> 00:20:34,740
storage so for single storage a few does

00:20:31,190 --> 00:20:39,210
seem a much better option what if you

00:20:34,740 --> 00:20:42,059
tests ran so far so the idea is to

00:20:39,210 --> 00:20:43,980
propose it as the new before together

00:20:42,059 --> 00:20:47,600
but we are still waiting and still

00:20:43,980 --> 00:20:51,390
waiting for a few more test results

00:20:47,600 --> 00:20:56,820
faster storage faster flash-based

00:20:51,390 --> 00:21:00,390
storage and then some third-party tests

00:20:56,820 --> 00:21:05,460
just weather better ground to boost this

00:21:00,390 --> 00:21:11,160
so this is the near future as for the

00:21:05,460 --> 00:21:15,570
midterm these are the challenges that I

00:21:11,160 --> 00:21:19,710
have in mind the purpose of the last

00:21:15,570 --> 00:21:22,640
year of work was to me be a few become

00:21:19,710 --> 00:21:25,530
much faster and much more effective

00:21:22,640 --> 00:21:29,460
actually as I showed you we seem to have

00:21:25,530 --> 00:21:32,760
succeeded but this is not yet enough if

00:21:29,460 --> 00:21:36,600
we want to move to a different context

00:21:32,760 --> 00:21:40,530
that is the enterprise context because

00:21:36,600 --> 00:21:45,960
in that case enterprise storage is even

00:21:40,530 --> 00:21:53,900
faster and even more sensitive to the

00:21:45,960 --> 00:21:56,220
order of the requests because storage

00:21:53,900 --> 00:22:02,070
this enterprise knowledge is more

00:21:56,220 --> 00:22:05,040
paladin and it has multiple kills so we

00:22:02,070 --> 00:22:08,010
have the same two barriers as before as

00:22:05,040 --> 00:22:11,550
this last here efficiency and

00:22:08,010 --> 00:22:15,210
effectiveness but now they are just much

00:22:11,550 --> 00:22:18,960
higher because we need I think at least

00:22:15,210 --> 00:22:24,450
1 million ops to comply with very fast

00:22:18,960 --> 00:22:27,870
storage or the magnitude and as for

00:22:24,450 --> 00:22:31,890
effectiveness the barrier is high end

00:22:27,870 --> 00:22:34,750
task because this highly parallel

00:22:31,890 --> 00:22:37,600
storage is very sensitive

00:22:34,750 --> 00:22:40,180
to the state of the because it needs all

00:22:37,600 --> 00:22:47,340
the kills to be constantly known ending

00:22:40,180 --> 00:22:51,280
to reach the bitrate but if you keep

00:22:47,340 --> 00:22:55,090
disk use non empty then the devices

00:22:51,280 --> 00:22:56,860
several requests to choose from to

00:22:55,090 --> 00:23:02,320
choose what is the next requester cell

00:22:56,860 --> 00:23:04,570
and it does change the order of this the

00:23:02,320 --> 00:23:08,020
service this request with respect to the

00:23:04,570 --> 00:23:10,840
order in which you dispatch the request

00:23:08,020 --> 00:23:16,990
in case things that respected to change

00:23:10,840 --> 00:23:20,320
it it does change it so now the

00:23:16,990 --> 00:23:24,480
challenge is rather hard how can you

00:23:20,320 --> 00:23:27,280
still guarantee and low latency to tasks

00:23:24,480 --> 00:23:30,190
you need to control your to guarantee

00:23:27,280 --> 00:23:33,130
related how can you still guarantee a

00:23:30,190 --> 00:23:37,750
low latency and at the same time keep

00:23:33,130 --> 00:23:42,370
those views non-empty well and better so

00:23:37,750 --> 00:23:44,920
you lose control continue this this is

00:23:42,370 --> 00:23:47,710
the challenge and this is what I would

00:23:44,920 --> 00:23:50,890
like to face in case the dinner will be

00:23:47,710 --> 00:23:54,240
happy to support the continuation of

00:23:50,890 --> 00:23:54,240
this war game this is all

00:23:55,000 --> 00:23:59,990
isn't this the reason why people

00:23:57,110 --> 00:24:03,290
invented open chat versus T that's it

00:23:59,990 --> 00:24:06,710
they have no control over the device so

00:24:03,290 --> 00:24:11,230
we just get open channel instead of it

00:24:06,710 --> 00:24:14,860
yeah so we would be able to use our

00:24:11,230 --> 00:24:19,130
algorithm access data get like a nice

00:24:14,860 --> 00:24:20,960
control that's dancing so I don't know

00:24:19,130 --> 00:24:25,700
if the future belongs to open channel

00:24:20,960 --> 00:24:28,610
actually and this free thinking devices

00:24:25,700 --> 00:24:32,030
go away because the operating system

00:24:28,610 --> 00:24:34,510
simply can't it but the industry will

00:24:32,030 --> 00:24:34,510
decide of course

00:24:41,549 --> 00:24:46,840
it sounds like what we need is follow

00:24:44,470 --> 00:24:49,929
those enterprises keys to permit the

00:24:46,840 --> 00:24:52,120
same kind of delay control that we have

00:24:49,929 --> 00:24:54,280
electronic hardware we have multiple

00:24:52,120 --> 00:24:56,890
cubes the hitting some of the same

00:24:54,280 --> 00:24:59,559
problems the operating system can

00:24:56,890 --> 00:25:04,299
schedule packets door into the network

00:24:59,559 --> 00:25:07,870
and it does so very efficiently nowadays

00:25:04,299 --> 00:25:09,190
we can use the tremors but then when

00:25:07,870 --> 00:25:11,080
there's multiple queues from the network

00:25:09,190 --> 00:25:15,490
the network hospital has to make sure

00:25:11,080 --> 00:25:18,250
that it treats all queues in the right

00:25:15,490 --> 00:25:21,429
way that get the maximum throughput but

00:25:18,250 --> 00:25:23,710
you also get ya know big delays in any

00:25:21,429 --> 00:25:25,330
other because the scenes that there's

00:25:23,710 --> 00:25:27,490
absolutely no difference before the

00:25:25,330 --> 00:25:32,110
storage does here yeah the problem is

00:25:27,490 --> 00:25:34,929
that because of network cache the truth

00:25:32,110 --> 00:25:40,120
is not that sensitive respect the order

00:25:34,929 --> 00:25:42,789
in which packets are just but anyway I

00:25:40,120 --> 00:25:44,650
try to make this a little bit more

00:25:42,789 --> 00:25:48,610
dramatic but I really have a prototype

00:25:44,650 --> 00:26:01,630
it seems to work I found it trick yeah

00:25:48,610 --> 00:26:03,909
but I can tell you before I mean can I

00:26:01,630 --> 00:26:06,280
see they have the right to change the

00:26:03,909 --> 00:26:08,980
order of their requests that's how they

00:26:06,280 --> 00:26:11,289
were there black boxes and they don't

00:26:08,980 --> 00:26:13,120
promise that they will respect they they

00:26:11,289 --> 00:26:15,669
behave in a way that matches the

00:26:13,120 --> 00:26:20,409
specification but it is yes the way that

00:26:15,669 --> 00:26:24,070
guarantees the lowest latency because

00:26:20,409 --> 00:26:26,049
the main goal is truth so now it's not

00:26:24,070 --> 00:26:29,110
please this enterprise storage arrays

00:26:26,049 --> 00:26:32,840
are extremely sensitive to latency and

00:26:29,110 --> 00:26:36,139
that is there that the goal is just that

00:26:32,840 --> 00:26:40,009
we'll make mess up the implementation of

00:26:36,139 --> 00:26:42,620
it because yeah but they they all try to

00:26:40,009 --> 00:26:45,019
have the extreme low latency on e-cig

00:26:42,620 --> 00:26:48,860
yeah but it's a different in type of

00:26:45,019 --> 00:26:51,730
latency yeah this this is about tasks

00:26:48,860 --> 00:26:51,730
this is what matters

00:27:02,170 --> 00:27:05,219
[Music]

00:27:09,590 --> 00:27:12,780
[Music]

00:27:13,179 --> 00:27:22,700
okay try to set this very briefly the

00:27:18,379 --> 00:27:26,929
idea is as follows we have two selves

00:27:22,700 --> 00:27:30,190
one process at a time okay it gives a

00:27:26,929 --> 00:27:33,440
time slot to ever it's actually a budget

00:27:30,190 --> 00:27:36,440
but let's say this is just time so there

00:27:33,440 --> 00:27:38,990
is one slot for each process during that

00:27:36,440 --> 00:27:41,450
slot we have few guarantees to that

00:27:38,990 --> 00:27:47,200
process that only that process will is

00:27:41,450 --> 00:27:51,679
so if that process is not fast enough to

00:27:47,200 --> 00:27:54,529
mean to feed the device and keep the

00:27:51,679 --> 00:27:57,440
queues of the device full at least non

00:27:54,529 --> 00:28:00,649
empty it will just happen that that

00:27:57,440 --> 00:28:02,659
process remains without your requests in

00:28:00,649 --> 00:28:05,869
some time intervals because the device

00:28:02,659 --> 00:28:09,470
is very fast and the device will remain

00:28:05,869 --> 00:28:13,730
without requests to in this horse that's

00:28:09,470 --> 00:28:16,100
where you lose truth so what I made this

00:28:13,730 --> 00:28:19,100
a prototype that during those holes just

00:28:16,100 --> 00:28:22,419
injects some requests from other

00:28:19,100 --> 00:28:25,249
processes in a controlled way

00:28:22,419 --> 00:28:27,080
believe me the truth goes up immediately

00:28:25,249 --> 00:28:29,960
it's very impressive because it's read

00:28:27,080 --> 00:28:34,399
try to switch it on and off the total

00:28:29,960 --> 00:28:36,649
goes up but the process under service

00:28:34,399 --> 00:28:38,800
inside this is not affected because the

00:28:36,649 --> 00:28:43,100
ever simple

00:28:38,800 --> 00:28:46,160
I am I mean it's every it's not I tried

00:28:43,100 --> 00:28:50,120
to inject a little bit more eye material

00:28:46,160 --> 00:28:52,700
by just checking this causes the true

00:28:50,120 --> 00:28:55,730
boot of that process to go down so if I

00:28:52,700 --> 00:28:58,460
am injecting too much I reduce the

00:28:55,730 --> 00:29:01,850
amount of injection if I can inject more

00:28:58,460 --> 00:29:03,860
I go on a feedback loop it's not stable

00:29:01,850 --> 00:29:05,660
but when you look at your boots you

00:29:03,860 --> 00:29:08,510
never look at it back in that time

00:29:05,660 --> 00:29:11,060
window 20 microseconds look at you would

00:29:08,510 --> 00:29:43,460
like in at least 100 milliseconds which

00:29:11,060 --> 00:29:47,780
is so it seems to that's basically this

00:29:43,460 --> 00:29:54,290
problem for me it's now impossible where

00:29:47,780 --> 00:29:57,290
you put asking I mean I there are some

00:29:54,290 --> 00:30:00,590
improvements in bsq and they did improve

00:29:57,290 --> 00:30:03,530
the good time but then it was decided

00:30:00,590 --> 00:30:06,080
that you have only dead line input and

00:30:03,530 --> 00:30:10,840
you can have be purely through you tell

00:30:06,080 --> 00:30:10,840
rules or by setting it manually so you

00:30:13,330 --> 00:30:21,890
yes you have seen improvements we can

00:30:17,810 --> 00:30:25,670
yes we can make the customization

00:30:21,890 --> 00:30:28,590
mysterious heads in information I mean

00:30:25,670 --> 00:30:31,290
it's not faster than the other

00:30:28,590 --> 00:30:34,200
schedulers I managed to heavy test

00:30:31,290 --> 00:30:36,720
fastest there just because the only

00:30:34,200 --> 00:30:39,060
thing that you need to do during boot is

00:30:36,720 --> 00:30:39,750
just to pass several requests as fast as

00:30:39,060 --> 00:30:41,310
possible

00:30:39,750 --> 00:30:43,380
you don't need any special control

00:30:41,310 --> 00:30:45,930
because you have a certain amount of

00:30:43,380 --> 00:30:48,840
video - - and you are done when all data

00:30:45,930 --> 00:30:50,850
your is finished so you just to be this

00:30:48,840 --> 00:30:53,160
aus fastest possible device you'll have

00:30:50,850 --> 00:30:56,250
improvements on rotational devices by

00:30:53,160 --> 00:30:58,980
this this is not foreign

00:30:56,250 --> 00:31:30,330
I mean flash storage just well just

00:30:58,980 --> 00:31:32,480
matters just you get my somebody thank

00:31:30,330 --> 00:31:32,480
you

00:31:42,460 --> 00:31:44,520

YouTube URL: https://www.youtube.com/watch?v=FPtbiZtIflU


