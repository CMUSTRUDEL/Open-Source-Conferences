Title: HKG18-505 - QEMU in UEFI
Publication date: 2019-05-09
Playlist: Linaro Connect Hong Kong 2018
Description: 
	"Session ID: HKG18-505
Session Name: HKG18-505 - QEMU in UEFI
Speaker: Alexander Graf
Track: LEG


★ Session Summary ★
UEFI is a firmware specification created by Intel with portability in mind. The UEFI way of doing that was to provide special UEFI byte code (EBC). Unfortunately nobody really cared so compiler, firmware support and providers of EBC option roms ceased and basically every UEFI option rom today contains native x86(_64) machine code.

If you now want to plug a PCIe card into your shiny ARM server, that means even though firmware would be compatible it still can't execute the option rom. Until you add QEMU to the mix.

Join me in exploring the depth of UEFI binary interfaces, marshalling between different architecture's function call ABIs on the fly and learn how to integrate all of this into a working firmware, running on real hardware, driving a real PCIe adapter.
---------------------------------------------------
★ Resources ★
Event Page: http://connect.linaro.org/resource/hkg18/hkg18-505/
Presentation: http://connect.linaro.org.s3.amazonaws.com/hkg18/presentations/hkg18-505.pdf
Video: http://connect.linaro.org.s3.amazonaws.com/hkg18/videos/hkg18-505.mp4
 ---------------------------------------------------
★ Event Details ★
Linaro Connect Hong Kong 2018 (HKG18)
19-23 March 2018 
Regal Airport Hotel Hong Kong

---------------------------------------------------
Keyword: LEG
'http://www.linaro.org'
'http://connect.linaro.org'
---------------------------------------------------
Follow us on Social Media
https://www.facebook.com/LinaroOrg
https://www.youtube.com/user/linaroorg?sub_confirmation=1
https://www.linkedin.com/company/1026961"
Captions: 
	00:00:04,360 --> 00:00:06,420
you

00:00:14,430 --> 00:00:19,360
good morning and welcome to the amazing

00:00:16,810 --> 00:00:23,560
presentation about CUNY running an UEFI

00:00:19,360 --> 00:00:26,110
who knows what cues who knows what you a

00:00:23,560 --> 00:00:30,430
bias this is respect to the right

00:00:26,110 --> 00:00:32,890
audience perfect so Who am I I'm Alex

00:00:30,430 --> 00:00:34,960
birth I am officially Acadian Kimmy

00:00:32,890 --> 00:00:39,399
developer but I also do a lot of all

00:00:34,960 --> 00:00:42,760
things this might have hurt i my whole

00:00:39,399 --> 00:00:44,350
cube me Acadian background is on a lot

00:00:42,760 --> 00:00:46,210
of fancy things like running massive

00:00:44,350 --> 00:00:48,610
virtualization like what's the first one

00:00:46,210 --> 00:00:50,800
to actually do that on unnamed II CPUs

00:00:48,610 --> 00:00:54,940
back in the day I did the server class

00:00:50,800 --> 00:00:57,490
for PC KVN port and I'm also the you

00:00:54,940 --> 00:00:59,310
would you if I mean to now where you can

00:00:57,490 --> 00:01:01,829
based upon you if applications in you

00:00:59,310 --> 00:01:04,390
sorry about that one

00:01:01,829 --> 00:01:06,220
essentially it's always the basic

00:01:04,390 --> 00:01:11,950
pattern is if people think it's weird

00:01:06,220 --> 00:01:13,600
it's me so what's our problem so you

00:01:11,950 --> 00:01:15,130
mentioned you have two systems one is an

00:01:13,600 --> 00:01:19,030
arm server one is an exit ecig server

00:01:15,130 --> 00:01:22,330
and now you want to plug in a graphics

00:01:19,030 --> 00:01:24,580
card entry and you start them up and

00:01:22,330 --> 00:01:26,920
what happens on on your amazing

00:01:24,580 --> 00:01:28,090
Exedy six sir but you obviously see an

00:01:26,920 --> 00:01:29,890
operating system booting up and

00:01:28,090 --> 00:01:30,430
everything looks and feels the way it

00:01:29,890 --> 00:01:33,400
should

00:01:30,430 --> 00:01:35,080
where's on your own server you just

00:01:33,400 --> 00:01:36,610
don't see anything it screen stays black

00:01:35,080 --> 00:01:41,170
because that graphics card never gets

00:01:36,610 --> 00:01:43,119
initialized why is that that is because

00:01:41,170 --> 00:01:46,720
the graphics card actually contains the

00:01:43,119 --> 00:01:48,490
driver for initializing the graphics for

00:01:46,720 --> 00:01:50,549
the making use of the graphics card on

00:01:48,490 --> 00:01:52,600
itself and that driver is usually

00:01:50,549 --> 00:01:55,630
comic-con usually comes along with the

00:01:52,600 --> 00:02:01,299
graphics card as xv6 binary code and we

00:01:55,630 --> 00:02:03,570
just can't run that a long way so the

00:02:01,299 --> 00:02:06,750
while back in Budapest

00:02:03,570 --> 00:02:09,099
are the knee sets out together and we

00:02:06,750 --> 00:02:11,650
brainstorm for a while and try to figure

00:02:09,099 --> 00:02:13,629
out whether they a safe solution to that

00:02:11,650 --> 00:02:16,030
and we eventually came up with exactly

00:02:13,629 --> 00:02:18,340
that one as an interim step to make

00:02:16,030 --> 00:02:20,769
people to enable people to actually run

00:02:18,340 --> 00:02:22,650
that xv6 code on their own systems but

00:02:20,769 --> 00:02:24,990
why is that an issue in the first place

00:02:22,650 --> 00:02:28,060
so

00:02:24,990 --> 00:02:29,830
if we look at the difference between arm

00:02:28,060 --> 00:02:33,940
and X's this is a nutshell and really

00:02:29,830 --> 00:02:34,840
high level so if you know more than if

00:02:33,940 --> 00:02:36,160
you already know the difference we

00:02:34,840 --> 00:02:38,380
actually six in our we can all go slides

00:02:36,160 --> 00:02:41,740
but this is if you don't that's really

00:02:38,380 --> 00:02:45,430
easy overview of what why they are

00:02:41,740 --> 00:02:46,750
incompatible so imagine you usually have

00:02:45,430 --> 00:02:48,940
registers register or something where

00:02:46,750 --> 00:02:51,400
you store values in and if you even look

00:02:48,940 --> 00:02:52,780
back from the 10,000 feet one of you if

00:02:51,400 --> 00:02:54,430
you look at the difference between exit

00:02:52,780 --> 00:02:57,940
e6 register sanam register so you can

00:02:54,430 --> 00:03:00,010
already spot this right you don't have

00:02:57,940 --> 00:03:01,840
the exact same number of registers like

00:03:00,010 --> 00:03:04,180
all differently thinks are just slightly

00:03:01,840 --> 00:03:06,580
different even on that level say you

00:03:04,180 --> 00:03:09,550
want to copy something I value from one

00:03:06,580 --> 00:03:12,190
register to another if you look at the

00:03:09,550 --> 00:03:15,850
way this works in binary code itself

00:03:12,190 --> 00:03:17,680
they're called an op codes um then if

00:03:15,850 --> 00:03:19,180
you want to copy something from one

00:03:17,680 --> 00:03:19,780
register to another from X 0 to X 1

00:03:19,180 --> 00:03:21,810
tomorrow

00:03:19,780 --> 00:03:24,520
it looks like this over here is the

00:03:21,810 --> 00:03:27,880
encoding that the CPU actually reach

00:03:24,520 --> 00:03:30,340
this is a hex value where the neck city

00:03:27,880 --> 00:03:32,290
sleeps you essentially get that they

00:03:30,340 --> 00:03:34,330
don't look anywhere you like right you

00:03:32,290 --> 00:03:36,010
can't just go and say oh well it's just

00:03:34,330 --> 00:03:38,769
a different language let me try to to

00:03:36,010 --> 00:03:41,709
map one on the other that's really hard

00:03:38,769 --> 00:03:44,230
to do but that's exactly what Kim Yuna's

00:03:41,709 --> 00:03:47,980
so Hume you essentially gives you a a

00:03:44,230 --> 00:03:51,220
nice way of taking one CPU language and

00:03:47,980 --> 00:03:56,470
converting it into another CPU language

00:03:51,220 --> 00:03:58,090
in a nutshell so what is QE Kim you has

00:03:56,470 --> 00:04:01,239
a couple of different modes you me

00:03:58,090 --> 00:04:03,730
obviously you know commune you just set

00:04:01,239 --> 00:04:05,769
some emulates your machine your your

00:04:03,730 --> 00:04:10,900
computer but what part of it does it

00:04:05,769 --> 00:04:13,269
annually so we usually have a couple of

00:04:10,900 --> 00:04:14,739
different layers you have your hardware

00:04:13,269 --> 00:04:16,239
you have your operating system and then

00:04:14,739 --> 00:04:18,820
you have software running on top of the

00:04:16,239 --> 00:04:21,850
operating system in the most common and

00:04:18,820 --> 00:04:25,360
most well-known use case Hume you

00:04:21,850 --> 00:04:30,550
emulates it's full systems which means

00:04:25,360 --> 00:04:31,620
you put all of these pieces into the

00:04:30,550 --> 00:04:34,320
matrix

00:04:31,620 --> 00:04:36,090
so you you may call them virtual you I

00:04:34,320 --> 00:04:37,740
mean like your hardware you make off all

00:04:36,090 --> 00:04:40,080
components of your heart but yet your

00:04:37,740 --> 00:04:42,990
your IDE controller you emulate your

00:04:40,080 --> 00:04:44,610
whatever your your CPU you emulate your

00:04:42,990 --> 00:04:46,170
operating system that basically runs on

00:04:44,610 --> 00:04:47,310
that CPU because you're made in the CPU

00:04:46,170 --> 00:04:49,440
and because of that you're also

00:04:47,310 --> 00:04:51,740
emulating the user space applications

00:04:49,440 --> 00:04:53,970
that run on top of that operating system

00:04:51,740 --> 00:04:58,610
give me is another mode called Linux

00:04:53,970 --> 00:05:01,830
user emulation which essentially

00:04:58,610 --> 00:05:03,630
provides a bit of glue between the user

00:05:01,830 --> 00:05:05,370
space interface and the kernel interface

00:05:03,630 --> 00:05:08,280
and the translation layer to convert

00:05:05,370 --> 00:05:10,320
between the two that you can run say

00:05:08,280 --> 00:05:12,960
exit e6 application alarm or on an

00:05:10,320 --> 00:05:14,370
occasional exit 6 that's on the

00:05:12,960 --> 00:05:17,040
application layer those are the two

00:05:14,370 --> 00:05:20,370
modes that are in the queue tree today

00:05:17,040 --> 00:05:21,750
you can just grab them in Houston but

00:05:20,370 --> 00:05:27,210
what we are trying to do is we really

00:05:21,750 --> 00:05:29,130
want to just run UEFI code emulated but

00:05:27,210 --> 00:05:30,720
where does that fit in those layers so

00:05:29,130 --> 00:05:32,070
you have the hot menu office punch one

00:05:30,720 --> 00:05:35,310
on vo harpus if you don't want any at

00:05:32,070 --> 00:05:37,740
that one but we do want to hit some

00:05:35,310 --> 00:05:39,390
chunk off whatever UEFI is but who

00:05:37,740 --> 00:05:42,720
actually knows how you if I works

00:05:39,390 --> 00:05:43,140
internally that's the answer I wanted to

00:05:42,720 --> 00:05:47,280
hear

00:05:43,140 --> 00:05:51,600
perfect so what is UEFI you if I

00:05:47,280 --> 00:05:55,200
basically is the thing that initializes

00:05:51,600 --> 00:05:58,680
your hardware sometimes not always and

00:05:55,200 --> 00:06:00,990
then allows a generic boot framework to

00:05:58,680 --> 00:06:04,080
boot from it so imagine you have a

00:06:00,990 --> 00:06:07,170
computer and the computer has hardware

00:06:04,080 --> 00:06:10,290
testers like a storage device or say a

00:06:07,170 --> 00:06:13,410
graphics card or a some network

00:06:10,290 --> 00:06:15,330
connectivity or some cd-rom any any

00:06:13,410 --> 00:06:17,250
hardware any connectivity to the outside

00:06:15,330 --> 00:06:21,570
world that is available you a vibe

00:06:17,250 --> 00:06:23,460
provides has drivers for those and then

00:06:21,570 --> 00:06:25,400
provides a generic interface that

00:06:23,460 --> 00:06:27,800
everybody can use and yet

00:06:25,400 --> 00:06:31,009
for potential use to access these

00:06:27,800 --> 00:06:31,759
devices so say for example you want to

00:06:31,009 --> 00:06:34,310
run grub

00:06:31,759 --> 00:06:35,930
this is the grub bastard thing disclose

00:06:34,310 --> 00:06:39,020
that on last year's pasta

00:06:35,930 --> 00:06:40,850
so they laugh year before last year's so

00:06:39,020 --> 00:06:43,130
you want to run grab and you can

00:06:40,850 --> 00:06:46,280
basically load grub from the disk that

00:06:43,130 --> 00:06:50,990
way and then have grew up actually talk

00:06:46,280 --> 00:06:56,389
to the disk and load for example Linux

00:06:50,990 --> 00:06:58,010
from that disk and execute Linux and

00:06:56,389 --> 00:07:02,800
what usually happens is that once you

00:06:58,010 --> 00:07:04,940
and that's that you basically have a

00:07:02,800 --> 00:07:07,520
switch from what we call boot time

00:07:04,940 --> 00:07:10,699
services to runtime services where most

00:07:07,520 --> 00:07:12,830
of UEFI disappears all those drivers

00:07:10,699 --> 00:07:14,900
they just gets thrown away and you're

00:07:12,830 --> 00:07:18,590
only stuck you'll need the only

00:07:14,900 --> 00:07:20,690
remaining part you have are the drivers

00:07:18,590 --> 00:07:26,210
chunks of it so really small stuff that

00:07:20,690 --> 00:07:26,780
allow you to access hardware from while

00:07:26,210 --> 00:07:31,820
running

00:07:26,780 --> 00:07:34,599
while the nose is running so let's take

00:07:31,820 --> 00:07:39,530
one step deeper down into how UEFI works

00:07:34,599 --> 00:07:41,720
so when you have this driver yes I

00:07:39,530 --> 00:07:43,340
mentioned I have a disk driver what the

00:07:41,720 --> 00:07:45,620
district does first is when it gets

00:07:43,340 --> 00:07:49,159
loaded it needs to register itself with

00:07:45,620 --> 00:07:52,849
the whole infrastructure so it does that

00:07:49,159 --> 00:07:55,460
by calling a global service and into

00:07:52,849 --> 00:07:58,750
that global service it passes a struct

00:07:55,460 --> 00:08:02,260
that contains function pointers and and

00:07:58,750 --> 00:08:05,800
just normal properties on the fields

00:08:02,260 --> 00:08:08,710
random numbers basic

00:08:05,800 --> 00:08:10,240
that whole that all the contents of that

00:08:08,710 --> 00:08:12,520
basically gets stored in a global

00:08:10,240 --> 00:08:15,520
context so that you can later on make

00:08:12,520 --> 00:08:17,229
use of it and then when you have a card

00:08:15,520 --> 00:08:23,620
plugging in something that can make use

00:08:17,229 --> 00:08:25,750
of that driver the the card the PCI

00:08:23,620 --> 00:08:27,639
driver for example registers a handle

00:08:25,750 --> 00:08:29,710
for that card in the global context

00:08:27,639 --> 00:08:32,589
again and then the UEFI framework

00:08:29,710 --> 00:08:35,620
goes in and tries to match whether the

00:08:32,589 --> 00:08:37,089
new card is so it's a supportable by the

00:08:35,620 --> 00:08:40,329
driver that was just registered before

00:08:37,089 --> 00:08:43,659
so make sense so for a complete example

00:08:40,329 --> 00:08:46,660
say you have an HDI controller driver

00:08:43,659 --> 00:08:48,070
and an HDI PCI device then your first

00:08:46,660 --> 00:08:51,760
purchase of the HDI controller

00:08:48,070 --> 00:08:54,760
driver and then the PCI driver comes in

00:08:51,760 --> 00:08:57,370
and created a device entity for the H

00:08:54,760 --> 00:09:00,760
type PCI device and then those two just

00:08:57,370 --> 00:09:02,320
get linked together basically when they

00:09:00,760 --> 00:09:05,019
get linked together what happens is she

00:09:02,320 --> 00:09:06,550
busy just call started the function

00:09:05,019 --> 00:09:08,260
pointer again that was passed in earlier

00:09:06,550 --> 00:09:10,450
by the driver which means you back in

00:09:08,260 --> 00:09:12,959
the driver now which can then do things

00:09:10,450 --> 00:09:16,240
on top of that disk that you just

00:09:12,959 --> 00:09:18,700
illuminated for example it can go in and

00:09:16,240 --> 00:09:20,529
install another protocol for example a

00:09:18,700 --> 00:09:24,040
block protocol so you can read and write

00:09:20,529 --> 00:09:27,450
data from that disk which again is a

00:09:24,040 --> 00:09:32,620
struct that has random fields and

00:09:27,450 --> 00:09:35,350
function pointers do you remember how

00:09:32,620 --> 00:09:36,730
the old struct looked like that at

00:09:35,350 --> 00:09:38,620
function pointers in the beginning and

00:09:36,730 --> 00:09:40,060
then fields that one has fields

00:09:38,620 --> 00:09:42,010
somewhere and random functions under

00:09:40,060 --> 00:09:43,720
somewhere you have no idea what each

00:09:42,010 --> 00:09:48,640
field means unless you know exactly what

00:09:43,720 --> 00:09:54,010
the product called us so does them thank

00:09:48,640 --> 00:09:56,199
god can go in and say well I would like

00:09:54,010 --> 00:09:58,990
to read some data so let me go and find

00:09:56,199 --> 00:10:01,089
that block device driver the pop-up

00:09:58,990 --> 00:10:04,690
device protocol so they call Jeanine you

00:10:01,089 --> 00:10:11,790
advise each let me go and just read some

00:10:04,690 --> 00:10:11,790
data from that you if I back device and

00:10:13,369 --> 00:10:18,689
with some data from the Joey buyback

00:10:15,479 --> 00:10:20,189
device and I can essentially read any

00:10:18,689 --> 00:10:20,759
data from Bob that's that's exactly the

00:10:20,189 --> 00:10:25,679
right back

00:10:20,759 --> 00:10:27,869
flows and works now if we want to put

00:10:25,679 --> 00:10:31,759
that driver into a virtual environment

00:10:27,869 --> 00:10:34,319
the problem we have is that our

00:10:31,759 --> 00:10:39,649
structures obviously look different

00:10:34,319 --> 00:10:42,689
between architectures right so imagine

00:10:39,649 --> 00:10:46,949
you have your your structure that

00:10:42,689 --> 00:10:49,199
registers for the block protocol and you

00:10:46,949 --> 00:10:53,059
look at just the hex dump of what all

00:10:49,199 --> 00:10:55,889
the contents of often this is in memory

00:10:53,059 --> 00:10:58,289
then you see the you 64 the revision

00:10:55,889 --> 00:11:00,539
that's just up here it's a 1 in

00:10:58,289 --> 00:11:02,489
little-endian then you see a pointer

00:11:00,539 --> 00:11:04,499
then you see couple other pointers and

00:11:02,489 --> 00:11:11,399
that's the way that could be presented

00:11:04,499 --> 00:11:13,979
in memory the really nice thing we found

00:11:11,399 --> 00:11:16,589
out basically what is that that

00:11:13,979 --> 00:11:20,699
structures actually thanks to api

00:11:16,589 --> 00:11:27,209
compatibility the same between AF 64 in

00:11:20,699 --> 00:11:29,429
x86 64 so we are both little endian we

00:11:27,209 --> 00:11:31,559
both align the same way everything

00:11:29,429 --> 00:11:35,879
basically looks the same on in this

00:11:31,559 --> 00:11:36,419
lecture now imagine a structure like

00:11:35,879 --> 00:11:39,359
that

00:11:36,419 --> 00:11:41,189
right where you have a 32-bit number and

00:11:39,359 --> 00:11:45,409
then a 64-bit value which basically is

00:11:41,189 --> 00:11:49,470
appointment the x86 api defines that

00:11:45,409 --> 00:11:51,509
when you have 64-bit values in a struct

00:11:49,470 --> 00:11:55,769
they need to be naturally aligned which

00:11:51,509 --> 00:12:00,539
means you need to start a 64-bit value

00:11:55,769 --> 00:12:02,009
at a 64-bit boundaries so what happens

00:12:00,539 --> 00:12:04,229
is that you basically get padding in

00:12:02,009 --> 00:12:05,819
your structure right these values

00:12:04,229 --> 00:12:07,679
basically just told me anything you have

00:12:05,819 --> 00:12:11,009
your 1 year and then you have the

00:12:07,679 --> 00:12:14,519
pointer exactly 64-bit after the initial

00:12:11,009 --> 00:12:15,539
value well the good thing is the unless

00:12:14,519 --> 00:12:18,419
we're actually pretty smart when you

00:12:15,539 --> 00:12:20,459
find the API you do the same thing they

00:12:18,419 --> 00:12:21,929
are fully compatible like in the

00:12:20,459 --> 00:12:23,789
alignment and the way they look and

00:12:21,929 --> 00:12:25,949
memory everything looks exactly the same

00:12:23,789 --> 00:12:29,009
so all the structures all the data

00:12:25,949 --> 00:12:31,559
pieces of the effects of your driver

00:12:29,009 --> 00:12:32,609
that would one in xv6 or an arm are just

00:12:31,559 --> 00:12:35,429
completely interchangeable

00:12:32,609 --> 00:12:45,299
each of them have the exact same view on

00:12:35,429 --> 00:12:47,069
what is represented menu yes so question

00:12:45,299 --> 00:12:49,679
is is it the same for different in unis

00:12:47,069 --> 00:12:56,100
you if I specifies it has to be the

00:12:49,679 --> 00:12:58,970
venue so that follow myself well it does

00:12:56,100 --> 00:12:58,970
for those architectures

00:13:06,549 --> 00:13:13,189
so now imagine what imagine we would put

00:13:11,089 --> 00:13:15,999
our structure into something that is

00:13:13,189 --> 00:13:22,480
virtually to enjoy an emulator context

00:13:15,999 --> 00:13:25,910
how would an armed binary go in and call

00:13:22,480 --> 00:13:28,549
that x86 function I mean if we just

00:13:25,910 --> 00:13:30,019
basically take those functions function

00:13:28,549 --> 00:13:31,939
pointers so you mentioned we could just

00:13:30,019 --> 00:13:34,369
execute the registration routine from

00:13:31,939 --> 00:13:37,639
our actually system and it registered

00:13:34,369 --> 00:13:39,379
those structures how would we be able to

00:13:37,639 --> 00:13:43,489
tell that the code that we're actually

00:13:39,379 --> 00:13:45,259
trying to execute is x86 code in alarm

00:13:43,489 --> 00:13:46,549
code and just executed as on footage so

00:13:45,259 --> 00:13:52,489
it's very different you saw that earlier

00:13:46,549 --> 00:13:54,559
from the way 86 photos so for that we

00:13:52,489 --> 00:13:56,929
need to dive into into how function

00:13:54,559 --> 00:13:59,089
calls actually work so imagine you have

00:13:56,929 --> 00:14:02,149
this function call they're just the read

00:13:59,089 --> 00:14:05,329
function again but that does is you

00:14:02,149 --> 00:14:07,339
basically on your X on your arm system

00:14:05,329 --> 00:14:09,559
you have a couple of registers that I

00:14:07,339 --> 00:14:11,929
had used for register passing up or for

00:14:09,559 --> 00:14:13,790
argument passing and what you what the C

00:14:11,929 --> 00:14:17,629
compiler does is a cheap it takes all

00:14:13,790 --> 00:14:19,129
the arguments you have in Europe in your

00:14:17,629 --> 00:14:23,689
function call it puts them into

00:14:19,129 --> 00:14:25,939
different different registers to so that

00:14:23,689 --> 00:14:27,559
the called function can then fetch them

00:14:25,939 --> 00:14:29,269
from that Bell norm and is this again

00:14:27,559 --> 00:14:32,929
that's essentially what the calling API

00:14:29,269 --> 00:14:35,449
needs what happens then is you also

00:14:32,929 --> 00:14:39,649
write something on the stack

00:14:35,449 --> 00:14:40,339
namely the return point not every time

00:14:39,649 --> 00:14:42,079
when there's nothing there there's

00:14:40,339 --> 00:14:43,639
something on the stack quicker way you

00:14:42,079 --> 00:14:45,439
put something on this your overflow

00:14:43,639 --> 00:14:48,290
registers a mistake if you need to and

00:14:45,439 --> 00:14:54,499
you put your frame on this thing and

00:14:48,290 --> 00:14:57,639
then you essentially call you change you

00:14:54,499 --> 00:14:58,850
change the program counter with the

00:14:57,639 --> 00:15:01,339
reads

00:14:58,850 --> 00:15:02,000
function pointer so you just jump in

00:15:01,339 --> 00:15:05,420
there

00:15:02,000 --> 00:15:07,910
it's also changed the link register now

00:15:05,420 --> 00:15:10,220
if that code is exodus six code you

00:15:07,910 --> 00:15:15,200
would basically end up executing in

00:15:10,220 --> 00:15:20,480
Bella's machine the trick we came up

00:15:15,200 --> 00:15:24,320
with it's no executor who is fed up no

00:15:20,480 --> 00:15:26,570
execute anything crowd awesome

00:15:24,320 --> 00:15:30,320
so my executors a security mechanism

00:15:26,570 --> 00:15:32,540
it's we abusing it but it's it is in its

00:15:30,320 --> 00:15:36,620
original form a security mechanism that

00:15:32,540 --> 00:15:41,330
really gets used to declare that regions

00:15:36,620 --> 00:15:43,160
usually would be readable writable and

00:15:41,330 --> 00:15:46,190
executable but there's a no execute

00:15:43,160 --> 00:15:49,640
feature you can say well I have the

00:15:46,190 --> 00:15:52,820
special region here but yeah you can

00:15:49,640 --> 00:15:54,380
really like that but do not execute any

00:15:52,820 --> 00:15:57,260
code if there is any code execution

00:15:54,380 --> 00:15:59,530
inside that range throw an exception

00:15:57,260 --> 00:16:01,880
tell me that something went wrong

00:15:59,530 --> 00:16:04,670
usually you use this for state

00:16:01,880 --> 00:16:08,030
protection and data protection so if you

00:16:04,670 --> 00:16:09,530
have a user space binary and you want to

00:16:08,030 --> 00:16:12,140
make sure that a buffer overflow on the

00:16:09,530 --> 00:16:14,089
stack doesn't result in a in code

00:16:12,140 --> 00:16:17,810
execution because somebody could just

00:16:14,089 --> 00:16:19,400
write random data on your stack which

00:16:17,810 --> 00:16:21,890
could be of course which again could be

00:16:19,400 --> 00:16:23,510
executed and you declare a you stack as

00:16:21,890 --> 00:16:28,850
my executor that people don't jump into

00:16:23,510 --> 00:16:31,400
in just one code we can use the exact

00:16:28,850 --> 00:16:35,600
same feature to declare all x86 code as

00:16:31,400 --> 00:16:39,589
not not executable which means if we now

00:16:35,600 --> 00:16:42,650
have our program counter programs to be

00:16:39,589 --> 00:16:45,290
x86 code instead of executing invalid

00:16:42,650 --> 00:16:47,510
machine code we end up getting an

00:16:45,290 --> 00:16:50,630
exception all exceptions are nice

00:16:47,510 --> 00:16:52,850
because now we have control and in that

00:16:50,630 --> 00:16:56,089
control we can just pass things into our

00:16:52,850 --> 00:16:59,240
emulation later what does the emulation

00:16:56,089 --> 00:17:02,380
they have to do well turns out x86 also

00:16:59,240 --> 00:17:02,380
has a function called API

00:17:02,949 --> 00:17:09,350
and that means we need to now go in and

00:17:06,799 --> 00:17:12,799
met all of those values that we put into

00:17:09,350 --> 00:17:15,649
our arm registers into our virtual xe6

00:17:12,799 --> 00:17:19,069
registers they function ABI looks a bit

00:17:15,649 --> 00:17:25,009
different but you basically get the same

00:17:19,069 --> 00:17:26,959
same thing and you also need to overflow

00:17:25,009 --> 00:17:28,399
things on the stack and on xv6 on the

00:17:26,959 --> 00:17:30,860
stack you also need to put the return

00:17:28,399 --> 00:17:34,759
part on well you just put a cannery that

00:17:30,860 --> 00:17:35,870
says when you return to that to the

00:17:34,759 --> 00:17:37,580
video caller

00:17:35,870 --> 00:17:45,080
you don't be returned to the call you

00:17:37,580 --> 00:17:47,360
return to the emulation exit so we

00:17:45,080 --> 00:17:50,840
basically just go in modify our stacks

00:17:47,360 --> 00:17:54,139
go run it and now we are in actually six

00:17:50,840 --> 00:17:59,299
context so we chunk on we execute our

00:17:54,139 --> 00:18:01,759
whatever code no hd6 ue5 code until we

00:17:59,299 --> 00:18:03,950
end up hitting a function call that gets

00:18:01,759 --> 00:18:06,970
suspect into harm right so what would we

00:18:03,950 --> 00:18:09,590
do there well how do we know that even

00:18:06,970 --> 00:18:11,690
the answers very simple we always do

00:18:09,590 --> 00:18:13,700
know because we know where our X is a

00:18:11,690 --> 00:18:15,799
score lies and we just simply assume

00:18:13,700 --> 00:18:18,529
that every code outside our own xt6 code

00:18:15,799 --> 00:18:21,259
always has to be onkled because if it's

00:18:18,529 --> 00:18:23,539
not and we call that code using an arm

00:18:21,259 --> 00:18:25,759
function called ABI and it just happens

00:18:23,539 --> 00:18:28,730
to be MIPS code instead the MIPS image

00:18:25,759 --> 00:18:32,539
that would kick in and do the same

00:18:28,730 --> 00:18:34,220
motion again so what we do is we realize

00:18:32,539 --> 00:18:36,230
oh that's a function call going to arm

00:18:34,220 --> 00:18:38,389
code so it's outside our range of

00:18:36,230 --> 00:18:39,110
handled x86 code so we marshal

00:18:38,389 --> 00:18:41,539
everything back

00:18:39,110 --> 00:18:43,129
we take our registers you have the exact

00:18:41,539 --> 00:18:47,720
same thing just in Reverse you basically

00:18:43,129 --> 00:18:49,820
take all of your values from your x86

00:18:47,720 --> 00:18:52,669
virtual environment and put them all

00:18:49,820 --> 00:18:54,320
back into registers on the arm

00:18:52,669 --> 00:19:00,580
environment so you marshal all the

00:18:54,320 --> 00:19:00,580
function called API back and move

00:19:01,220 --> 00:19:04,430
make sense

00:19:05,299 --> 00:19:10,190
so not like wager that's this best

00:19:07,580 --> 00:19:16,419
multi-contour um so what what that means

00:19:10,190 --> 00:19:22,100
is you can essentially call have an arm

00:19:16,419 --> 00:19:26,090
drop binary calling into x86 network

00:19:22,100 --> 00:19:33,460
functions calling into the X on UEFI

00:19:26,090 --> 00:19:33,460
core to say allocate memory so you get

00:19:34,570 --> 00:19:42,110
emulation on function call boundaries

00:19:38,049 --> 00:19:44,120
you don't have the boundary of contracts

00:19:42,110 --> 00:19:45,740
assisted responses to emulation you

00:19:44,120 --> 00:19:47,150
don't have the userspace emulation

00:19:45,740 --> 00:19:51,770
boundaries syscalls

00:19:47,150 --> 00:19:56,240
this is on function calls now the big

00:19:51,770 --> 00:19:58,490
question is does work yes it does this

00:19:56,240 --> 00:20:01,669
is me in front of a seattle system

00:19:58,490 --> 00:20:06,650
showing graph displaying stuff on the

00:20:01,669 --> 00:20:08,750
monitor using a a meeting in this case

00:20:06,650 --> 00:20:10,820
in the option one that was really just

00:20:08,750 --> 00:20:13,490
on the contact locked in the card we did

00:20:10,820 --> 00:20:16,370
it up and it just worked if you've done

00:20:13,490 --> 00:20:20,000
any other sink racer demos they all ran

00:20:16,370 --> 00:20:21,820
that code every time you plug in the GPU

00:20:20,000 --> 00:20:24,230
there it's always it's always running

00:20:21,820 --> 00:20:30,049
through the emulation and just happens

00:20:24,230 --> 00:20:31,880
to work now why why did I choose qu well

00:20:30,049 --> 00:20:34,130
you saw the initial slide that I hadn't

00:20:31,880 --> 00:20:37,280
know the coppice but there are more

00:20:34,130 --> 00:20:40,510
reasons like he has a couple a couple of

00:20:37,280 --> 00:20:44,120
of very nice open eyes it's written in C

00:20:40,510 --> 00:20:45,890
which is very important I was looking at

00:20:44,120 --> 00:20:47,870
box as an alternative and box is written

00:20:45,890 --> 00:20:50,000
in C++ and I really don't want to have

00:20:47,870 --> 00:20:54,350
C++ code and exception handling in my

00:20:50,000 --> 00:20:56,510
film record it's very isolated so the

00:20:54,350 --> 00:20:59,059
tiny code generator that is part of qmu

00:20:56,510 --> 00:21:00,770
this was originally made for a

00:20:59,059 --> 00:21:03,500
completely different project was made

00:21:00,770 --> 00:21:05,540
for AC compiler that basically compiled

00:21:03,500 --> 00:21:08,030
colonel on gouda so your bootloader

00:21:05,540 --> 00:21:09,890
which is call into the compiler a bunch

00:21:08,030 --> 00:21:16,430
of sauce coated with compiled economy

00:21:09,890 --> 00:21:19,430
Gouda honey tiny code compiling the it

00:21:16,430 --> 00:21:24,230
is LGPL so every every piece of code and

00:21:19,430 --> 00:21:26,660
there's LGPL which means you are very

00:21:24,230 --> 00:21:28,840
likely to get into licensing issues very

00:21:26,660 --> 00:21:31,970
unlikely to get into licensing issues

00:21:28,840 --> 00:21:35,330
modern qmu is is GPL but other images

00:21:31,970 --> 00:21:37,130
also obviously GPL for 32-bit x86 very

00:21:35,330 --> 00:21:40,810
easy to find emulators out there for

00:21:37,130 --> 00:21:43,370
64-bit x86 it's close to impossible

00:21:40,810 --> 00:21:47,980
another question I always get is why

00:21:43,370 --> 00:21:53,510
don't you just use EB C so what is EB C

00:21:47,980 --> 00:21:55,120
EB C is was an idea from Intel back in

00:21:53,510 --> 00:21:59,270
the day when I 10th you more thought

00:21:55,120 --> 00:22:01,250
that they needed to have a single option

00:21:59,270 --> 00:22:03,470
wrong and basically a single binary in

00:22:01,250 --> 00:22:05,180
the doctrine to run on all of their

00:22:03,470 --> 00:22:07,520
platforms on there actually six platform

00:22:05,180 --> 00:22:10,250
and on I tenure and later on as well on

00:22:07,520 --> 00:22:16,000
XP 664 so what you're getting is you're

00:22:10,250 --> 00:22:16,000
getting byte code but essentially is

00:22:16,150 --> 00:22:21,620
Fitness agnostic so you can have the

00:22:19,190 --> 00:22:24,290
same byte code running on 32-bit and on

00:22:21,620 --> 00:22:29,480
64-bit platforms and it does all the

00:22:24,290 --> 00:22:32,330
structure petting in such magically that

00:22:29,480 --> 00:22:34,850
one was shipped in option roms until

00:22:32,330 --> 00:22:38,600
they run 2005 note I can tell modern

00:22:34,850 --> 00:22:41,750
cars simply don't have it the problems

00:22:38,600 --> 00:22:43,610
with EB C is that the compiler these

00:22:41,750 --> 00:22:45,920
days is commedia unsupported in chose

00:22:43,610 --> 00:22:47,720
not care about eb c anymore because they

00:22:45,920 --> 00:22:51,010
don't have Atheneum so why would they

00:22:47,720 --> 00:22:53,840
bother its

00:22:51,010 --> 00:22:55,640
microsoft refuses to sign eb c code

00:22:53,840 --> 00:22:57,370
which means if you put eb c code into

00:22:55,640 --> 00:23:01,650
your optional and you want to do secure

00:22:57,370 --> 00:23:05,059
tough luck not good sign they've

00:23:01,650 --> 00:23:08,760
and we'll Microsoft hand you the x86

00:23:05,059 --> 00:23:10,440
signing key for your arm systems so next

00:23:08,760 --> 00:23:12,419
question is below will Microsoft hand

00:23:10,440 --> 00:23:13,529
you the x86 signing key for your arm

00:23:12,419 --> 00:23:16,650
systems I don't know but it's definitely

00:23:13,529 --> 00:23:18,750
at least you only have one one entity

00:23:16,650 --> 00:23:20,940
that you need to convince at one given

00:23:18,750 --> 00:23:22,529
point in time not 50 to have used a

00:23:20,940 --> 00:23:23,850
different key if you wanted to not use

00:23:22,529 --> 00:23:27,570
the Microsoft key to sign you ate the

00:23:23,850 --> 00:23:31,860
zeeco my point is that it's there's no

00:23:27,570 --> 00:23:33,419
real benefit in that point but I don't

00:23:31,860 --> 00:23:35,460
need no need to has benefit because you

00:23:33,419 --> 00:23:37,919
still have the problem but you don't

00:23:35,460 --> 00:23:42,090
have anyone agreeing but your origami

00:23:37,919 --> 00:23:46,520
site is it not just an x86 signed option

00:23:42,090 --> 00:23:46,520
Ron and those keys the public keys are

00:23:46,669 --> 00:23:51,960
not a problem well what's the problem

00:23:49,409 --> 00:23:54,059
with taking the existing Microsoft x86

00:23:51,960 --> 00:23:55,320
keys and putting them into that exit

00:23:54,059 --> 00:23:57,840
ease into the arm

00:23:55,320 --> 00:24:01,409
the problem is astok is the guarantee

00:23:57,840 --> 00:24:03,870
that when Microsoft check systems are

00:24:01,409 --> 00:24:07,340
they going to use the same keys from

00:24:03,870 --> 00:24:07,340
their farm systems

00:24:10,930 --> 00:24:15,050
why don't you keep going yeah that's a

00:24:13,670 --> 00:24:16,940
side conversation yes that's that's

00:24:15,050 --> 00:24:18,530
officer that the signing part later on

00:24:16,940 --> 00:24:20,930
but I don't I really don't see because

00:24:18,530 --> 00:24:23,390
she really yeah whatever you do you're

00:24:20,930 --> 00:24:26,930
not worse off using emulation in that

00:24:23,390 --> 00:24:30,470
case if you have bucks say for example

00:24:26,930 --> 00:24:32,900
we found to be nice one on video so the

00:24:30,470 --> 00:24:36,530
Nvidia graphics driver at least the one

00:24:32,900 --> 00:24:38,620
we looked at has a part where it

00:24:36,530 --> 00:24:42,410
basically has a function that tries to

00:24:38,620 --> 00:24:45,980
return a pointer to a common okay a

00:24:42,410 --> 00:24:48,080
state a PCI device specific struck so it

00:24:45,980 --> 00:24:51,470
loops through a list of well of known

00:24:48,080 --> 00:24:55,250
graphics card PCI IDs and then returns

00:24:51,470 --> 00:24:57,170
the pointer when it finds them and where

00:24:55,250 --> 00:24:59,000
it doesn't find any in the list which it

00:24:57,170 --> 00:25:03,490
doesn't for every other card in your

00:24:59,000 --> 00:25:05,780
system because it's only your only your

00:25:03,490 --> 00:25:08,270
graphics card actually has the known

00:25:05,780 --> 00:25:11,300
Society then it basically returns null

00:25:08,270 --> 00:25:12,620
which means now you have your call that

00:25:11,300 --> 00:25:14,120
would need to check whether three-ton

00:25:12,620 --> 00:25:16,700
values not what they forgot about that

00:25:14,120 --> 00:25:18,470
so it just dereference that null pointer

00:25:16,700 --> 00:25:20,030
which is a really bad idea when you have

00:25:18,470 --> 00:25:23,630
a system that does not have any memory

00:25:20,030 --> 00:25:26,180
and address you so these spots will be

00:25:23,630 --> 00:25:29,540
the exact same if you compile them as EB

00:25:26,180 --> 00:25:31,400
C code as native code is it doesn't

00:25:29,540 --> 00:25:33,650
matter what type of code you have if you

00:25:31,400 --> 00:25:35,240
have a bug in there but makes it not

00:25:33,650 --> 00:25:36,500
follow the normal specification but

00:25:35,240 --> 00:25:39,200
takes assumption of a platform-specific

00:25:36,500 --> 00:25:42,170
or not I saw specific they will still

00:25:39,200 --> 00:25:44,000
break the same way and since nobody's

00:25:42,170 --> 00:25:46,040
doing ABC today you would have to

00:25:44,000 --> 00:25:48,020
convince anybody to then port into e BC

00:25:46,040 --> 00:25:51,410
but they would still want to support the

00:25:48,020 --> 00:25:52,670
x86 64 option runs as native code

00:25:51,410 --> 00:25:55,220
because they're faster and better and

00:25:52,670 --> 00:25:58,610
more amazing so you would still have to

00:25:55,220 --> 00:26:00,140
option roms in there one for x86 and one

00:25:58,610 --> 00:26:01,970
for arms you didn't actually written

00:26:00,140 --> 00:26:05,330
anything because really really really

00:26:01,970 --> 00:26:07,430
what you should do is run native code so

00:26:05,330 --> 00:26:09,800
instead of convincing people to use byte

00:26:07,430 --> 00:26:10,200
code to interpret things just convinced

00:26:09,800 --> 00:26:15,870
into you

00:26:10,200 --> 00:26:17,430
g-good but for native code we obviously

00:26:15,870 --> 00:26:19,530
always want to run native code whenever

00:26:17,430 --> 00:26:22,110
we can but sometimes you happen to have

00:26:19,530 --> 00:26:24,450
a cup a network card or a PCI any other

00:26:22,110 --> 00:26:26,460
entities a high card in yourself but

00:26:24,450 --> 00:26:29,370
just is not the right SKU it does not

00:26:26,460 --> 00:26:33,000
happen to have arm option ones in there

00:26:29,370 --> 00:26:35,310
so using the emulation you can at least

00:26:33,000 --> 00:26:39,360
see if that happens to make the adapter

00:26:35,310 --> 00:26:44,670
work so you're enabling devices that

00:26:39,360 --> 00:26:45,990
simply wouldn't work otherwise so now

00:26:44,670 --> 00:26:47,160
that you're so hyped up about the whole

00:26:45,990 --> 00:26:49,650
emulation thing and you really want to

00:26:47,160 --> 00:26:53,310
try it out how did you use it but the

00:26:49,650 --> 00:26:56,040
easiest way to use it is to go on on

00:26:53,310 --> 00:26:58,260
Hart's github page where he hosts all

00:26:56,040 --> 00:27:01,620
the things and run these few simple

00:26:58,260 --> 00:27:04,050
instructions in the region that get

00:27:01,620 --> 00:27:05,700
people basically is just checking out

00:27:04,050 --> 00:27:07,650
eating issue and building it with an

00:27:05,700 --> 00:27:09,930
additional option or alt option with an

00:27:07,650 --> 00:27:13,530
additional optional module which is the

00:27:09,930 --> 00:27:17,130
Xmas examiner module in that as a result

00:27:13,530 --> 00:27:22,730
gives you an e DK 2 version for qmu that

00:27:17,130 --> 00:27:26,810
contains the x86 option ROM emulation

00:27:22,730 --> 00:27:26,810
which I can show you

00:27:29,120 --> 00:27:35,350
you're cheating a little bit on the

00:27:31,040 --> 00:27:35,350
makeup presentation first man thank you

00:27:42,930 --> 00:27:48,970
because

00:27:44,500 --> 00:27:51,000
can you beat this no well can you beat

00:27:48,970 --> 00:27:51,000
this

00:27:53,570 --> 00:28:05,450
all right so this is running an e DK 2

00:28:03,289 --> 00:28:07,220
version that does not have the Exodus

00:28:05,450 --> 00:28:13,879
examiner down there what I'm doing oh I

00:28:07,220 --> 00:28:16,639
said I was missing on slide the demo

00:28:13,879 --> 00:28:19,970
setup so what we're doing is we're

00:28:16,639 --> 00:28:24,580
running an arm virtual machine and cue

00:28:19,970 --> 00:28:27,619
new that runs our arm UEFI binary

00:28:24,580 --> 00:28:30,320
indicator and in that virtual machine we

00:28:27,619 --> 00:28:33,340
plug in a we 1000 adapter because Kimmy

00:28:30,320 --> 00:28:37,429
can just a minute and really well but

00:28:33,340 --> 00:28:39,169
that X is that e 1000 network adapter by

00:28:37,429 --> 00:28:40,580
default obviously as an exit exit is

00:28:39,169 --> 00:28:43,279
exception on since that's what even

00:28:40,580 --> 00:28:45,169
thousand cards have the whole thing came

00:28:43,279 --> 00:28:48,470
from from each other from the first

00:28:45,169 --> 00:28:49,879
place so usually you wouldn't be able to

00:28:48,470 --> 00:28:54,769
see any network code and that's

00:28:49,879 --> 00:28:58,899
basically what I'm showing there so here

00:28:54,769 --> 00:29:02,090
you can see that while we do see our

00:28:58,899 --> 00:29:04,929
even thousands network adapter in our

00:29:02,090 --> 00:29:04,929
PCI numeration

00:29:10,040 --> 00:29:14,180
you do not see any network adapter

00:29:12,110 --> 00:29:16,100
discovered by UEFI because there's

00:29:14,180 --> 00:29:24,470
simply no driver for that decide after

00:29:16,100 --> 00:29:26,720
that you if I can execute so if we now

00:29:24,470 --> 00:29:30,770
use the binary that contains our exit e6

00:29:26,720 --> 00:29:34,730
emulation we can run the exact same

00:29:30,770 --> 00:29:37,300
environment but now you can see that

00:29:34,730 --> 00:29:40,760
actually you starts peak see over ipv4

00:29:37,300 --> 00:29:43,360
so it says covering our graph that is

00:29:40,760 --> 00:29:45,890
stored on there which is an arm bar

00:29:43,360 --> 00:29:48,470
which shows us a nice installation

00:29:45,890 --> 00:29:55,460
screen and we can keep rolling this is

00:29:48,470 --> 00:29:59,090
calling into x86 x86 option 1 handling

00:29:55,460 --> 00:30:02,170
the e1000 adapter running in queue on

00:29:59,090 --> 00:30:08,470
sec system but that's a different story

00:30:02,170 --> 00:30:08,470
this is emulation emulation but it works

00:30:18,570 --> 00:30:25,560
all right crescents grant so the because

00:30:23,640 --> 00:30:27,690
there's there's always conscience with

00:30:25,560 --> 00:30:33,290
what's going to emulation do you want

00:30:27,690 --> 00:30:36,390
have a microphone on top of it

00:30:33,290 --> 00:30:38,520
where are the corner cases so you know

00:30:36,390 --> 00:30:41,160
I'm a big supporter of the the approach

00:30:38,520 --> 00:30:44,520
and doing things in this way to just for

00:30:41,160 --> 00:30:46,980
enablement there's always going to be a

00:30:44,520 --> 00:30:48,090
little bit of know what where are the

00:30:46,980 --> 00:30:50,490
problems that you see where are the

00:30:48,090 --> 00:30:54,320
corner cases that we need to be watching

00:30:50,490 --> 00:30:56,550
out for if trying to run x86 option roms

00:30:54,320 --> 00:30:58,670
actually pretty simple so that's that's

00:30:56,550 --> 00:31:01,500
the bucket agree I was talking about on

00:30:58,670 --> 00:31:04,170
that there's more to Exodus 6 than the

00:31:01,500 --> 00:31:06,720
ISO so there are a couple of assumptions

00:31:04,170 --> 00:31:11,130
you can make a nice v6 that do not apply

00:31:06,720 --> 00:31:13,200
on every arm system and if your code

00:31:11,130 --> 00:31:15,750
happens to take these assumptions it

00:31:13,200 --> 00:31:18,450
will grade it will make a native code as

00:31:15,750 --> 00:31:20,880
well but if you're doing a native option

00:31:18,450 --> 00:31:22,680
rum you also have a native grade process

00:31:20,880 --> 00:31:24,270
after they're optional buildings people

00:31:22,680 --> 00:31:26,040
who plug it into real an service and

00:31:24,270 --> 00:31:27,780
realize that the code is broken whereas

00:31:26,040 --> 00:31:29,570
before they just didn't since they

00:31:27,780 --> 00:31:36,300
didn't plug them in on the drawn service

00:31:29,570 --> 00:31:38,340
all right yeah so I can answer that so

00:31:36,300 --> 00:31:40,440
these are all PCI drivers by definition

00:31:38,340 --> 00:31:41,970
right because Turkish an option okay and

00:31:40,440 --> 00:31:44,970
what you see in the Intel systems is

00:31:41,970 --> 00:31:47,730
that they well basically they don't use

00:31:44,970 --> 00:31:49,470
the PCI protocols correctly so on the

00:31:47,730 --> 00:31:51,740
next a six system you can just malloc

00:31:49,470 --> 00:31:54,600
something take the CPU address which is

00:31:51,740 --> 00:31:56,130
virtual equals physical on you if ISO

00:31:54,600 --> 00:31:59,760
and you take that that was you just

00:31:56,130 --> 00:32:02,820
program it in to be me registers this

00:31:59,760 --> 00:32:06,970
works just fine you don't need to on map

00:32:02,820 --> 00:32:08,799
shai that's another thing so there's

00:32:06,970 --> 00:32:11,230
always maybe at zero which means you've

00:32:08,799 --> 00:32:13,720
been the reference I'll point this but

00:32:11,230 --> 00:32:16,600
it also means none if these drivers

00:32:13,720 --> 00:32:18,720
bother to enable 64-bit to be ma right

00:32:16,600 --> 00:32:22,779
so I'm going to see it the overdrive

00:32:18,720 --> 00:32:24,220
there's things that don't work because

00:32:22,779 --> 00:32:26,409
the hardware does support it but the

00:32:24,220 --> 00:32:30,690
driver doesn't bother because you don't

00:32:26,409 --> 00:32:30,690
need to need to on the PC platform right

00:32:31,169 --> 00:32:39,100
another question on x86 on the arms for

00:32:35,710 --> 00:32:42,669
option roms that end up now having

00:32:39,100 --> 00:32:45,370
runtime services components are those

00:32:42,669 --> 00:32:50,950
supported or are there any doesn't

00:32:45,370 --> 00:32:54,029
matter the easy answer is no and and the

00:32:50,950 --> 00:32:56,020
actual even more verbose answer is our

00:32:54,029 --> 00:33:00,640
framework essentially makes sure they

00:32:56,020 --> 00:33:03,010
don't load so that you don't by accident

00:33:00,640 --> 00:33:05,080
happen to have a one term service that

00:33:03,010 --> 00:33:06,700
really contains exit e6 code that your

00:33:05,080 --> 00:33:08,770
kernel not tries to need a text right

00:33:06,700 --> 00:33:11,500
are there any cases that you've all of

00:33:08,770 --> 00:33:13,600
where that is a problem of not being

00:33:11,500 --> 00:33:15,520
able to do the runtime services code I'm

00:33:13,600 --> 00:33:21,130
fairly sure if you want to run Windows

00:33:15,520 --> 00:33:23,669
10 on your system and you have a network

00:33:21,130 --> 00:33:26,860
adapter that is not supported by Windows

00:33:23,669 --> 00:33:28,240
but relies on the fact that it is Saddam

00:33:26,860 --> 00:33:30,429
of the driver from the internet first

00:33:28,240 --> 00:33:31,990
which means it needs to access the

00:33:30,429 --> 00:33:36,640
endless driver using runtime services

00:33:31,990 --> 00:33:38,649
right that will not work right in the

00:33:36,640 --> 00:33:42,159
Linux world I don't know of any case

00:33:38,649 --> 00:33:44,620
where we would actually provide a

00:33:42,159 --> 00:33:47,860
one-time service but we've made use of a

00:33:44,620 --> 00:33:49,419
one-time service driver as that that is

00:33:47,860 --> 00:33:51,809
that would be implement by X is exported

00:33:49,419 --> 00:33:51,809
right

00:33:51,820 --> 00:33:54,669
and he's not yet maybe someones couple

00:33:53,679 --> 00:33:56,830
some somebody started writing and

00:33:54,669 --> 00:33:59,019
destroyed or Somalia today it doesn't

00:33:56,830 --> 00:34:02,100
exist okay I'm done asking questions

00:33:59,019 --> 00:34:02,100
anyone else

00:34:04,200 --> 00:34:10,649
you handle uh calling function pointers

00:34:08,379 --> 00:34:15,190
that have arguments passed on the stack

00:34:10,649 --> 00:34:17,260
well yes you know we can just assume

00:34:15,190 --> 00:34:19,419
there are always at least sixteen

00:34:17,260 --> 00:34:22,149
arguments that we may have to handle and

00:34:19,419 --> 00:34:24,190
just handle them I mean if we overrun if

00:34:22,149 --> 00:34:26,800
you over beat the stack from to the back

00:34:24,190 --> 00:34:27,550
we know we are always weaselly deep into

00:34:26,800 --> 00:34:29,829
the calling chain

00:34:27,550 --> 00:34:35,050
whatever happens so reading a couple

00:34:29,829 --> 00:34:42,429
values beyond our return stack part just

00:34:35,050 --> 00:34:45,760
not an issue okay so obviously

00:34:42,429 --> 00:34:47,079
performance here I'd assume isn't you

00:34:45,760 --> 00:34:49,329
know it's not normally going to be a

00:34:47,079 --> 00:34:52,000
priority but how awesome is this close

00:34:49,329 --> 00:34:54,579
to native wow this is actually a JIT

00:34:52,000 --> 00:34:57,010
running this is not in jeopardy code

00:34:54,579 --> 00:35:00,460
this is not slow this is an actual good

00:34:57,010 --> 00:35:03,550
JIT executing an x86 code which also

00:35:00,460 --> 00:35:06,240
does not do a lot so that x86 code

00:35:03,550 --> 00:35:08,829
doesn't have to handle a lot of pieces

00:35:06,240 --> 00:35:11,650
because it's calling a lot of UEFI

00:35:08,829 --> 00:35:13,720
functions around it to do things like

00:35:11,650 --> 00:35:16,030
men's set even because that was born

00:35:13,720 --> 00:35:17,950
back in the EBC days when PC was so

00:35:16,030 --> 00:35:20,680
people still have those calls in their

00:35:17,950 --> 00:35:22,390
function or sometimes can even denim you

00:35:20,680 --> 00:35:25,319
know email memset is not slower through

00:35:22,390 --> 00:35:28,990
the emulation because it's fully didn't

00:35:25,319 --> 00:35:31,470
how feasible is it to port this into you

00:35:28,990 --> 00:35:31,470
boot as well

00:35:32,400 --> 00:35:39,880
poor thing that particular part into you

00:35:35,049 --> 00:35:41,380
Buddhist is the problem is that your

00:35:39,880 --> 00:35:43,720
drivers are going to call a lot of

00:35:41,380 --> 00:35:48,099
interfaces that are just not in

00:35:43,720 --> 00:35:51,460
committed at all I mean if you the first

00:35:48,099 --> 00:35:53,799
step to having that would be to make and

00:35:51,460 --> 00:35:56,710
native traveler say take IPCC compiled

00:35:53,799 --> 00:35:58,029
at farm and then try to make that one

00:35:56,710 --> 00:35:59,589
work on you at first

00:35:58,029 --> 00:36:02,009
and if that works you can try the next

00:35:59,589 --> 00:36:02,009
in succession

00:36:06,299 --> 00:36:16,619
I'm on that I'm surprised one question

00:36:08,729 --> 00:36:20,999
did not come up is this upstream the

00:36:16,619 --> 00:36:22,949
answers pretty simple we actually at

00:36:20,999 --> 00:36:24,929
first them one of the edk to maintain

00:36:22,949 --> 00:36:27,689
has said well just submit the code is

00:36:24,929 --> 00:36:30,059
fine so the only blocking thing is

00:36:27,689 --> 00:36:32,880
somebody having time to actually push it

00:36:30,059 --> 00:36:34,619
essentially passed on to me so I didn't

00:36:32,880 --> 00:36:36,599
get around to do it until now but their

00:36:34,619 --> 00:36:39,529
codes the basic code the framework will

00:36:36,599 --> 00:36:42,119
be upstream sooner or later and the

00:36:39,529 --> 00:36:42,569
emulation package will hopefully go into

00:36:42,119 --> 00:36:47,479
Leafs

00:36:42,569 --> 00:36:49,739
non non license compliance package

00:36:47,479 --> 00:36:55,859
service so what's that what's the

00:36:49,739 --> 00:36:57,569
implications for summer shipping well I

00:36:55,859 --> 00:36:59,279
don't think they'll DPL is the

00:36:57,569 --> 00:37:04,589
interesting one for someone tripping

00:36:59,279 --> 00:37:06,059
over I don't think it's the LGPL think

00:37:04,589 --> 00:37:08,489
that's the problem for someone tripping

00:37:06,059 --> 00:37:10,439
framework I think it's the oh look we're

00:37:08,489 --> 00:37:12,089
shipping firmware that's emulating x86

00:37:10,439 --> 00:37:16,380
that's going to get their legal

00:37:12,089 --> 00:37:19,199
department really what up well the only

00:37:16,380 --> 00:37:20,999
the only reason that the LDP elements

00:37:19,199 --> 00:37:22,739
cannot go in the main repository is

00:37:20,999 --> 00:37:25,589
basically that there's a blanket rule

00:37:22,739 --> 00:37:28,769
that everything in here is is BSD

00:37:25,589 --> 00:37:30,119
compliant or else all of the legal

00:37:28,769 --> 00:37:31,709
departments of all the companies

00:37:30,119 --> 00:37:32,789
involved in indicate your development

00:37:31,709 --> 00:37:35,390
need to go back and make the new

00:37:32,789 --> 00:37:42,499
agreement that that's just not happening

00:37:35,390 --> 00:37:45,569
yeah legally it should be completely

00:37:42,499 --> 00:37:46,769
fine to emulate xu6 code and thanks to

00:37:45,569 --> 00:37:50,539
Microsoft actually have a really good

00:37:46,769 --> 00:37:53,939
case of somebody paving the path for us

00:37:50,539 --> 00:37:57,479
so if they don't get sued I'm not saying

00:37:53,939 --> 00:38:00,630
it couldn't happen I'm saying but all

00:37:57,479 --> 00:38:03,359
I'm saying is that you're using the word

00:38:00,630 --> 00:38:08,219
should in communications with a legal

00:38:03,359 --> 00:38:11,099
department put it differently pet these

00:38:08,219 --> 00:38:12,900
peasants the patents that indeed has in

00:38:11,099 --> 00:38:15,420
that case because that's actually 664

00:38:12,900 --> 00:38:18,839
only they do care about the Pens that

00:38:15,420 --> 00:38:24,209
AMD has only applied to secretary and

00:38:18,839 --> 00:38:27,719
not to software if you can convince them

00:38:24,209 --> 00:38:31,439
unhappy can can it be compiled above it

00:38:27,719 --> 00:38:35,559
run time as a module yes it actually is

00:38:31,439 --> 00:38:38,440
so it could be just plop down into yeah

00:38:35,559 --> 00:38:40,329
yes be if you if you have the emulator

00:38:38,440 --> 00:38:41,799
framework available I mean that's the

00:38:40,329 --> 00:38:45,609
hard part but you need to have the core

00:38:41,799 --> 00:38:47,890
parts available are this onion if you

00:38:45,609 --> 00:38:49,990
still need to have all parts of a little

00:38:47,890 --> 00:38:51,970
the whole framework around it to be able

00:38:49,990 --> 00:38:53,859
to plug it in and then you still will

00:38:51,970 --> 00:38:55,900
not actually rerun the optional

00:38:53,859 --> 00:38:58,000
enumeration so everything that was

00:38:55,900 --> 00:39:01,210
plugged in will not get executed because

00:38:58,000 --> 00:39:03,369
your point in time of inserting the

00:39:01,210 --> 00:39:07,059
emulator will be after the optional

00:39:03,369 --> 00:39:09,160
integration but I mean but holy can be

00:39:07,059 --> 00:39:12,490
worked around yeah because I could see

00:39:09,160 --> 00:39:16,000
that I could see that being valuable

00:39:12,490 --> 00:39:18,759
from a deployment perspective to not

00:39:16,000 --> 00:39:20,740
check the actual emulation but to have

00:39:18,759 --> 00:39:23,890
the framework set up in such a way that

00:39:20,740 --> 00:39:27,789
it can be put down at runtime either in

00:39:23,890 --> 00:39:30,759
a firm or addition origin some mechanism

00:39:27,789 --> 00:39:35,019
and then you do the rerun for deployment

00:39:30,759 --> 00:39:36,640
that would be interesting after the way

00:39:35,019 --> 00:39:38,170
it's Kurt implement implement that the

00:39:36,640 --> 00:39:40,509
sub just doesn't actually work so you

00:39:38,170 --> 00:39:41,859
can you have like the like you have the

00:39:40,509 --> 00:39:43,779
boots options you have to drive for

00:39:41,859 --> 00:39:45,759
options and efi which some things in our

00:39:43,779 --> 00:39:49,089
lab love is a strategy for attracting

00:39:45,759 --> 00:39:54,039
inspectional good options so that would

00:39:49,089 --> 00:39:56,710
be the natural place to put it but I

00:39:54,039 --> 00:39:59,890
mean because you fiber because you're

00:39:56,710 --> 00:40:04,300
such a big bag of little modules that

00:39:59,890 --> 00:40:06,790
gets dispatched using some fuzzy logic

00:40:04,300 --> 00:40:08,350
so there are some some defects it's what

00:40:06,790 --> 00:40:09,820
they called FX's and some that picture

00:40:08,350 --> 00:40:14,230
so we have your right architectural

00:40:09,820 --> 00:40:17,290
protocols installed before you can

00:40:14,230 --> 00:40:23,680
actually start using this model this

00:40:17,290 --> 00:40:25,420
module but the way BCI possibly

00:40:23,680 --> 00:40:27,640
liberated because that's when it goes

00:40:25,420 --> 00:40:30,430
over the option roms and try to decide

00:40:27,640 --> 00:40:34,180
that uses something I can support either

00:40:30,430 --> 00:40:36,130
natively or fighting the real laser that

00:40:34,180 --> 00:40:38,680
perhaps before the entry light situation

00:40:36,130 --> 00:40:43,590
that doesn't work and it requires some

00:40:38,680 --> 00:40:46,450
non-trivial plumbing on top of loops and

00:40:43,590 --> 00:40:48,910
so it's technically it's not an issue

00:40:46,450 --> 00:40:50,620
but we have to sell it to me to the

00:40:48,910 --> 00:40:52,150
projects and preventive sugar cream if

00:40:50,620 --> 00:40:55,810
you sell it to the project that this is

00:40:52,150 --> 00:40:59,310
actually changes and should be taking to

00:40:55,810 --> 00:40:59,310
accommodate solution relation

00:41:06,100 --> 00:41:12,140
how many different of tell rooms have

00:41:08,810 --> 00:41:13,760
been tried with this emulator we try to

00:41:12,140 --> 00:41:17,780
be a graphics cards with writing the

00:41:13,760 --> 00:41:21,890
graphics cards and we tried the IPC ones

00:41:17,780 --> 00:41:25,880
I also tried and connectives for inside

00:41:21,890 --> 00:41:27,350
of a KVM virtual machine I wasn't it

00:41:25,880 --> 00:41:29,240
didn't work but I wasn't really sure

00:41:27,350 --> 00:41:32,180
with that's because of my device passed

00:41:29,240 --> 00:41:33,590
through or because things were just

00:41:32,180 --> 00:41:35,450
playing broken I don't know what that

00:41:33,590 --> 00:41:36,770
was IPC as well so I don't see why that

00:41:35,450 --> 00:41:38,960
would work I think it really was

00:41:36,770 --> 00:41:42,170
emulation issues or a bunch of other

00:41:38,960 --> 00:41:44,480
station by magicians um you're more than

00:41:42,170 --> 00:41:47,270
happy to more than happy to see you or

00:41:44,480 --> 00:41:51,500
anyone else try it more products and if

00:41:47,270 --> 00:41:53,480
you see box we're happy to fix them yes

00:41:51,500 --> 00:41:57,100
doo doo doo if I pop over there isn't it

00:41:53,480 --> 00:41:57,100
next week yeah take it along

00:42:01,880 --> 00:42:08,470
all right any more questions well then

00:42:05,720 --> 00:42:08,470
thanks a lot

00:42:18,520 --> 00:42:20,580

YouTube URL: https://www.youtube.com/watch?v=ICP_3_-CYSQ


