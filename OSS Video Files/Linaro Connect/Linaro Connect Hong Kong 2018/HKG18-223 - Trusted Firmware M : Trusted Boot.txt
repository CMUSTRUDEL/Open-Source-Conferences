Title: HKG18-223 - Trusted Firmware M : Trusted Boot
Publication date: 2019-05-09
Playlist: Linaro Connect Hong Kong 2018
Description: 
	Session ID: HKG18-223
Session Name: HKG18-223 - Trusted Firmware M : Trusted Boot
Speaker: Tamas Ban
Track: LITE


★ Session Summary ★
 An overview of the trusted boot concept and firmware update on the ARMv8-M based platform and how MCUBoot acts as a BL2 bootloader for TF-M.

Trusted Firmware M

In October 2017, Arm announced the vision of Platform Security Architecture (PSA) - a common framework to allow everyone in the IoT ecosystem to move forward with stronger, scalable security and greater confidence. There are three key stages to the Platform Security Architecture: Analysis, Architecture and Implementation which are described at https://developer.arm.com/products/architecture/platform-security-architecture.

_Trusted Firmware M, i.e. TF-M, is the Arm project to provide an open source reference implementation firmware that will conform to the PSA specification for M-Class devices. Early access to TF-M was released in December 2017 and it is being made public during Linaro Connect. The implementation should be considered a prototype until the PSA specifications reach release state and the code aligns._
---------------------------------------------------
★ Resources ★
Event Page: http://connect.linaro.org/resource/hkg18/hkg18-223/
Presentation: http://connect.linaro.org.s3.amazonaws.com/hkg18/presentations/hkg18-223.pdf
Video: http://connect.linaro.org.s3.amazonaws.com/hkg18/videos/hkg18-223.mp4
 ---------------------------------------------------
★ Event Details ★
Linaro Connect Hong Kong 2018 (HKG18)
19-23 March 2018 
Regal Airport Hotel Hong Kong

---------------------------------------------------
Keyword: LITE
'http://www.linaro.org'
'http://connect.linaro.org'
---------------------------------------------------
Follow us on Social Media
https://www.facebook.com/LinaroOrg
https://www.youtube.com/user/linaroorg?sub_confirmation=1
https://www.linkedin.com/company/1026961
Captions: 
	00:00:04,370 --> 00:00:06,430
you

00:00:14,469 --> 00:00:25,689
okay hello everybody good afternoon my

00:00:20,029 --> 00:00:29,660
name is Tom hutchman I am working at art

00:00:25,689 --> 00:00:33,160
I am working in the last year TfL

00:00:29,660 --> 00:00:36,739
project my focus area host trusted

00:00:33,160 --> 00:00:39,710
trusted to interpret today I will give

00:00:36,739 --> 00:00:45,110
you a presentation about what we did in

00:00:39,710 --> 00:00:48,230
last about on this field this is the

00:00:45,110 --> 00:00:49,850
short agenda of my presentation today at

00:00:48,230 --> 00:00:52,250
the beginning there will be a few

00:00:49,850 --> 00:00:55,070
introductions slide about what is

00:00:52,250 --> 00:00:58,070
trusted environment but is secure boot

00:00:55,070 --> 00:01:02,030
but its responsibility how does it work

00:00:58,070 --> 00:01:05,020
the basics then I will talk about which

00:01:02,030 --> 00:01:08,360
boot folder we are using in the project

00:01:05,020 --> 00:01:11,869
we will go into details how does it work

00:01:08,360 --> 00:01:14,240
why is it secure secure which crypto

00:01:11,869 --> 00:01:19,340
survey crypto libraries this accused so

00:01:14,240 --> 00:01:21,470
on there will be a slide about how the

00:01:19,340 --> 00:01:24,260
firmware upgrade happens and i/o devices

00:01:21,470 --> 00:01:27,229
or how should it happen there will be

00:01:24,260 --> 00:01:29,720
some alternative solutions to do the

00:01:27,229 --> 00:01:31,580
image upgrade on the device itself and

00:01:29,720 --> 00:01:34,520
there will be some other alternative

00:01:31,580 --> 00:01:39,580
solution what can you do with the crypto

00:01:34,520 --> 00:01:39,580
if it is too heavy wait for your device

00:01:39,640 --> 00:01:46,010
at the end there will be a Q&A session

00:01:42,530 --> 00:01:47,840
but is very free to interrupt me anytime

00:01:46,010 --> 00:01:52,850
I can ask percussion during my

00:01:47,840 --> 00:01:53,750
presentation okay so first of all some

00:01:52,850 --> 00:01:56,510
interaction

00:01:53,750 --> 00:01:58,820
what is the trusted environment let me

00:01:56,510 --> 00:02:02,240
say it's something is trust trees what

00:01:58,820 --> 00:02:05,900
does it really mean if you have a device

00:02:02,240 --> 00:02:09,170
maker and probably or definitely you

00:02:05,900 --> 00:02:12,650
store some data on your device and not

00:02:09,170 --> 00:02:15,319
only the code these data can be valuable

00:02:12,650 --> 00:02:18,230
for you it can have several reasons why

00:02:15,319 --> 00:02:21,439
it's valuable it can be sensitive user

00:02:18,230 --> 00:02:25,280
data it can be certificates of crypto

00:02:21,439 --> 00:02:25,490
keys or even itself the code itself can

00:02:25,280 --> 00:02:27,740
be

00:02:25,490 --> 00:02:29,990
you ever for you because you don't find

00:02:27,740 --> 00:02:31,580
that compatible

00:02:29,990 --> 00:02:36,860
access to your code and

00:02:31,580 --> 00:02:39,560
reverse-engineered if you use lose your

00:02:36,860 --> 00:02:42,950
data then you lose money or use a

00:02:39,560 --> 00:02:46,070
reputation most of ours is not a good

00:02:42,950 --> 00:02:49,120
scenario for your company so you want

00:02:46,070 --> 00:02:50,830
the way that you want to ensure that

00:02:49,120 --> 00:02:53,900
[Music]

00:02:50,830 --> 00:02:57,280
malicious actor cannot access your data

00:02:53,900 --> 00:03:00,260
cannot expose it from your device and

00:02:57,280 --> 00:03:02,690
this is the main goal of a trusted and

00:03:00,260 --> 00:03:07,090
trusted environment trusted environment

00:03:02,690 --> 00:03:11,000
is something which is a combination of

00:03:07,090 --> 00:03:14,110
good secure boot some hardware

00:03:11,000 --> 00:03:17,330
capabilities and secure runtime further

00:03:14,110 --> 00:03:19,580
if you have all these details together

00:03:17,330 --> 00:03:23,750
and working fine that you can be sure

00:03:19,580 --> 00:03:28,850
that your secrets must be will be kept

00:03:23,750 --> 00:03:32,150
in secret in the device if any one of

00:03:28,850 --> 00:03:34,010
these files for example boot or hardware

00:03:32,150 --> 00:03:35,660
is not capable to something that

00:03:34,010 --> 00:03:37,820
probably that you have a security hole

00:03:35,660 --> 00:03:40,460
in your system which can be exploited

00:03:37,820 --> 00:03:46,100
and your data can be extracted from the

00:03:40,460 --> 00:03:48,290
system PC platform Satori security

00:03:46,100 --> 00:03:51,740
architecture are addressing these

00:03:48,290 --> 00:03:54,290
aspects of the trusted environment one

00:03:51,740 --> 00:03:57,560
by one and give some recommendations how

00:03:54,290 --> 00:04:02,720
you implement something in in order to

00:03:57,560 --> 00:04:05,090
achieve trusted environment in this

00:04:02,720 --> 00:04:09,020
presentation I will more focus on the

00:04:05,090 --> 00:04:12,470
trusted boot okay what is trusted boot

00:04:09,020 --> 00:04:15,200
why we need it and how does it work boot

00:04:12,470 --> 00:04:20,270
loader is a piece of code which just

00:04:15,200 --> 00:04:22,940
executed as soon as the CPU is released

00:04:20,270 --> 00:04:27,440
from the reset this is the first line of

00:04:22,940 --> 00:04:30,680
code which runs on the device it has

00:04:27,440 --> 00:04:32,900
many goals like hardware in it

00:04:30,680 --> 00:04:35,990
initialization but in a trusting

00:04:32,900 --> 00:04:37,070
environment the main goal is to verify

00:04:35,990 --> 00:04:39,920
the integrity

00:04:37,070 --> 00:04:42,380
and alternative of the other software

00:04:39,920 --> 00:04:47,480
components which are going to be run

00:04:42,380 --> 00:04:50,360
later on the system as soon as hence as

00:04:47,480 --> 00:04:53,270
soon as the bootloader are done with

00:04:50,360 --> 00:04:57,320
this authentication it is the execution

00:04:53,270 --> 00:04:59,480
for other software and never returns why

00:04:57,320 --> 00:05:02,200
we need it because refunds that only

00:04:59,480 --> 00:05:07,040
authenticated software run on the device

00:05:02,200 --> 00:05:10,490
which is trusted and won't extract our

00:05:07,040 --> 00:05:15,280
data for somebody who has no rights to

00:05:10,490 --> 00:05:20,060
access it how can it achieve this goal

00:05:15,280 --> 00:05:22,850
this goal is achievable that you have

00:05:20,060 --> 00:05:25,790
trusted anchor in the device trusted

00:05:22,850 --> 00:05:29,240
anchor means immutable code immutable

00:05:25,790 --> 00:05:35,000
data immutable code mr. boot loader

00:05:29,240 --> 00:05:37,550
itself then building your architecture

00:05:35,000 --> 00:05:41,960
the base of this immutable data you can

00:05:37,550 --> 00:05:44,120
use certain crypto algorithm to ensure

00:05:41,960 --> 00:05:47,480
that only authenticated code will run on

00:05:44,120 --> 00:05:56,390
your system and its integrity is also

00:05:47,480 --> 00:05:57,380
correct okay this bootloader design is

00:05:56,390 --> 00:06:01,040
is not a new thing

00:05:57,380 --> 00:06:04,190
there are many boot loaders on the field

00:06:01,040 --> 00:06:07,510
it has devices has actually several

00:06:04,190 --> 00:06:10,880
bootloader during the boot process but

00:06:07,510 --> 00:06:13,780
n+ devices are different compared to the

00:06:10,880 --> 00:06:17,420
a-class devices this is a comparison

00:06:13,780 --> 00:06:19,610
about what are the device constraint in

00:06:17,420 --> 00:06:22,310
the m-class devices this is on the right

00:06:19,610 --> 00:06:24,740
side and on the left side you have see

00:06:22,310 --> 00:06:27,320
some high level requirement towards the

00:06:24,740 --> 00:06:32,540
bootloader what capability should it

00:06:27,320 --> 00:06:34,820
help the main constraints are that the

00:06:32,540 --> 00:06:38,210
code usually stored in the internal on

00:06:34,820 --> 00:06:40,700
chip flash and its size it's limited in

00:06:38,210 --> 00:06:44,940
most cases the size is less than one

00:06:40,700 --> 00:06:48,470
megabyte so you need all the code

00:06:44,940 --> 00:06:51,300
bootloader must fit this one back bite

00:06:48,470 --> 00:06:56,100
the wrong which is usage for the data

00:06:51,300 --> 00:07:00,330
it's even smaller to 256 kilobyte it's

00:06:56,100 --> 00:07:02,090
quite a maximum in the most cases it

00:07:00,330 --> 00:07:05,670
might have some cryptographic

00:07:02,090 --> 00:07:09,930
accelerator Harper in your system but

00:07:05,670 --> 00:07:11,760
might need but it might don't have so in

00:07:09,930 --> 00:07:14,820
some cases everything must be solved

00:07:11,760 --> 00:07:17,910
crypto library in other cases there can

00:07:14,820 --> 00:07:22,080
be some coprocessor the computing power

00:07:17,910 --> 00:07:24,570
is lower than the Akers devices a clock

00:07:22,080 --> 00:07:27,150
rate is lower there is no instruction

00:07:24,570 --> 00:07:31,820
crash but there is no data cache or in

00:07:27,150 --> 00:07:35,520
most cases and the pipeline is simpler

00:07:31,820 --> 00:07:38,760
compared to a class devices and of

00:07:35,520 --> 00:07:41,130
course can happen some such a similar

00:07:38,760 --> 00:07:43,650
situation when your battery is drained

00:07:41,130 --> 00:07:47,310
and there is a powerful a failure in the

00:07:43,650 --> 00:07:50,780
middle of some important operation you

00:07:47,310 --> 00:07:53,640
need to be prepared for this situation

00:07:50,780 --> 00:07:57,360
on the left there are the high level

00:07:53,640 --> 00:08:00,840
requirement you need to support software

00:07:57,360 --> 00:08:04,620
upgrade because this is one of the most

00:08:00,840 --> 00:08:07,050
important aspect to be secure if you

00:08:04,620 --> 00:08:09,270
have security of one operating in your

00:08:07,050 --> 00:08:11,580
software you can fix it but without

00:08:09,270 --> 00:08:15,450
social a bread you cannot deploy on your

00:08:11,580 --> 00:08:17,090
device you need probably support chain

00:08:15,450 --> 00:08:19,530
of trust to ensure that only

00:08:17,090 --> 00:08:22,890
authenticated code run on your system

00:08:19,530 --> 00:08:26,790
and for this reason you need a lot of

00:08:22,890 --> 00:08:30,720
cryptography algorithm these

00:08:26,790 --> 00:08:33,570
cryptography operates usually online

00:08:30,720 --> 00:08:35,400
with the A+ devices so on one side the

00:08:33,570 --> 00:08:37,410
right a high level requirement which is

00:08:35,400 --> 00:08:39,630
quite similar to the a-class devices and

00:08:37,410 --> 00:08:42,390
on the other side you have the device

00:08:39,630 --> 00:08:48,900
constraint so you have some more secure

00:08:42,390 --> 00:08:51,740
device these facts leads to that we must

00:08:48,900 --> 00:08:54,630
boost bootloader which address

00:08:51,740 --> 00:08:55,810
specifically time class devices so it's

00:08:54,630 --> 00:08:59,129
designed to run

00:08:55,810 --> 00:09:03,639
and clothes devices in the tff project

00:08:59,129 --> 00:09:05,939
we use the MCU wood which is a open

00:09:03,639 --> 00:09:11,139
source project covered by the line arrow

00:09:05,939 --> 00:09:15,639
which is designed for m-class devices it

00:09:11,139 --> 00:09:18,339
has a low memory footprint it's running

00:09:15,639 --> 00:09:19,540
from the flash so it's case execution in

00:09:18,339 --> 00:09:23,259
place

00:09:19,540 --> 00:09:25,420
it's but the main reason why we use and

00:09:23,259 --> 00:09:28,059
see you good because it's a major

00:09:25,420 --> 00:09:33,160
product it's already supports all the

00:09:28,059 --> 00:09:35,680
required cryptographic always like a

00:09:33,160 --> 00:09:39,160
symmetric al gore

00:09:35,680 --> 00:09:42,749
origin authentication there is LC and

00:09:39,160 --> 00:09:46,209
elliptic curve cryptography built-in and

00:09:42,749 --> 00:09:50,759
there are the hash calculation for the

00:09:46,209 --> 00:09:50,759
integrity verification

00:09:53,620 --> 00:10:01,629
the design is reliable in a sense that

00:09:57,670 --> 00:10:10,420
it is prepared to handle before over

00:10:01,629 --> 00:10:12,790
failure scenarios as well last year and

00:10:10,420 --> 00:10:16,569
that don't laughs here we have all first

00:10:12,790 --> 00:10:21,610
TFM release and as part of this release

00:10:16,569 --> 00:10:24,759
we are using MC would support order last

00:10:21,610 --> 00:10:32,019
year we are mainly focusing room on that

00:10:24,759 --> 00:10:36,639
that we must hold and see you would to

00:10:32,019 --> 00:10:40,569
fit to the TF my project by default

00:10:36,639 --> 00:10:43,179
MC would can compile as artists

00:10:40,569 --> 00:10:47,379
application it's supported by Zafir

00:10:43,179 --> 00:10:50,170
minut and other artists as well but it

00:10:47,379 --> 00:10:53,679
means that we have dependencies to words

00:10:50,170 --> 00:10:56,410
and artists and we want to avoid missing

00:10:53,679 --> 00:10:59,379
the TFM project for that reason we

00:10:56,410 --> 00:11:03,089
created a version of MC boot which is OS

00:10:59,379 --> 00:11:06,639
agnostic and this version is using IFM

00:11:03,089 --> 00:11:08,889
in the current implementation

00:11:06,639 --> 00:11:15,220
we are supporting you see as an

00:11:08,889 --> 00:11:19,449
asymmetric algorithm combined the build

00:11:15,220 --> 00:11:21,430
process with you would be good so in all

00:11:19,449 --> 00:11:24,670
the other times you would can

00:11:21,430 --> 00:11:25,959
authenticate software it's neat to than

00:11:24,670 --> 00:11:29,709
some preparation

00:11:25,959 --> 00:11:32,079
it needs to put some header before the

00:11:29,709 --> 00:11:34,689
binary and we need to connect it some

00:11:32,079 --> 00:11:37,180
other fields at the end but I will cover

00:11:34,689 --> 00:11:40,300
it later during the build process there

00:11:37,180 --> 00:11:44,290
are some clips which do this job so at

00:11:40,300 --> 00:11:48,160
the end when you build a TEFL project

00:11:44,290 --> 00:11:51,399
you have secured binary the more secure

00:11:48,160 --> 00:11:53,439
binary you have the bootloader and the

00:11:51,399 --> 00:11:55,930
secure and non-secure binary is prepared

00:11:53,439 --> 00:11:58,839
in a way that you it will it can be

00:11:55,930 --> 00:12:03,360
directly downloaded to the device and as

00:11:58,839 --> 00:12:03,360
you would can you verify and vote it

00:12:13,050 --> 00:12:16,379
it's copy

00:12:20,820 --> 00:12:29,470
okay this line is about some basic how

00:12:24,010 --> 00:12:32,290
change of transporting works on the left

00:12:29,470 --> 00:12:35,200
side you can see the orange box which is

00:12:32,290 --> 00:12:37,420
then in the EDR work we have an

00:12:35,200 --> 00:12:40,270
immutable bootloader and some immutable

00:12:37,420 --> 00:12:43,870
data datum is can be a hash of

00:12:40,270 --> 00:12:48,070
cryptographic key or can be the key

00:12:43,870 --> 00:12:53,620
itself because it's immutable this is by

00:12:48,070 --> 00:12:56,590
default implicit trustable and you can

00:12:53,620 --> 00:13:01,570
derive every other software component

00:12:56,590 --> 00:13:05,520
from this anchor so you are using a

00:13:01,570 --> 00:13:10,210
symmetric key cryptography to ensure the

00:13:05,520 --> 00:13:13,090
origin of the other images you built in

00:13:10,210 --> 00:13:16,450
the public key in your device it can be

00:13:13,090 --> 00:13:18,730
done as part of the code boot code or it

00:13:16,450 --> 00:13:20,890
can be put in some other hardware

00:13:18,730 --> 00:13:23,140
components like an anti programmable

00:13:20,890 --> 00:13:29,500
memory it depends on the device

00:13:23,140 --> 00:13:32,410
capability the under part of the private

00:13:29,500 --> 00:13:32,950
key must be kept far away from the

00:13:32,410 --> 00:13:35,410
device

00:13:32,950 --> 00:13:41,410
it must be stored somewhere in a secure

00:13:35,410 --> 00:13:44,230
server if you want to deploy next stage

00:13:41,410 --> 00:13:47,230
software on the device you make sure

00:13:44,230 --> 00:13:49,960
that use the private key to create

00:13:47,230 --> 00:13:53,110
digital signature during the period

00:13:49,960 --> 00:13:56,740
process and you send that image to the

00:13:53,110 --> 00:13:59,290
firmware in some way then your immutable

00:13:56,740 --> 00:14:02,050
boot boot loader can use the public key

00:13:59,290 --> 00:14:03,400
to get decrypt that digital signature

00:14:02,050 --> 00:14:07,210
and if it fits

00:14:03,400 --> 00:14:09,100
then it allowed to run the new image the

00:14:07,210 --> 00:14:14,110
new image which can be an other

00:14:09,100 --> 00:14:17,940
bootloader the br-2 can all all you can

00:14:14,110 --> 00:14:22,270
only can clean contain some further keys

00:14:17,940 --> 00:14:25,960
these are again public keys these keys

00:14:22,270 --> 00:14:28,120
are used to authenticate software

00:14:25,960 --> 00:14:30,970
components in the next stage and the

00:14:28,120 --> 00:14:33,370
next stage can be your secure

00:14:30,970 --> 00:14:35,530
and your night non-secure code at the

00:14:33,370 --> 00:14:39,390
end in the secure and non-secure cool

00:14:35,530 --> 00:14:47,500
code will be your runtime environment

00:14:39,390 --> 00:14:50,350
why we need one year - this is not a

00:14:47,500 --> 00:14:53,310
mandatory requirement this is just a

00:14:50,350 --> 00:14:57,280
recommendation to do it in in this way

00:14:53,310 --> 00:15:00,070
if you lose your K but not to lose you

00:14:57,280 --> 00:15:03,340
okay but somebody can get access your

00:15:00,070 --> 00:15:06,010
private key then you lose your device

00:15:03,340 --> 00:15:09,760
basically because then everybody can

00:15:06,010 --> 00:15:12,760
generate an image of it which will be

00:15:09,760 --> 00:15:14,410
fit on the authentication and they can

00:15:12,760 --> 00:15:18,400
deploy some arbitrary code on your

00:15:14,410 --> 00:15:21,520
device and you don't find that therefore

00:15:18,400 --> 00:15:25,810
it's a good advice that for a keeper

00:15:21,520 --> 00:15:27,550
must be used for only one purpose the

00:15:25,810 --> 00:15:30,720
route of test part be clean it's only

00:15:27,550 --> 00:15:33,490
verify used to verify the br-2 image

00:15:30,720 --> 00:15:36,340
ba-bong cannot be updated because it's

00:15:33,490 --> 00:15:40,090
immutable and probably you won't you

00:15:36,340 --> 00:15:44,470
will update br-2 only relocation on your

00:15:40,090 --> 00:15:47,910
device but it's expected that secure and

00:15:44,470 --> 00:15:51,730
more secure code will get more updates

00:15:47,910 --> 00:15:56,200
therefore you will use more the public

00:15:51,730 --> 00:16:01,720
keys which are incorporated in the pr2

00:15:56,200 --> 00:16:06,010
image if you lose those keys then the

00:16:01,720 --> 00:16:07,870
attacker can deploy a new secure

00:16:06,010 --> 00:16:10,890
function but if you realize that

00:16:07,870 --> 00:16:10,890
somebody stole your

00:16:15,780 --> 00:16:25,920
yeah no not yet so if you realize that

00:16:22,680 --> 00:16:28,590
somebody stole your keys then you can

00:16:25,920 --> 00:16:31,440
update the br-2 image and you can deploy

00:16:28,590 --> 00:16:34,530
new keys on the device and when you do

00:16:31,440 --> 00:16:37,950
that then the attacker lose the

00:16:34,530 --> 00:16:43,890
capability to deploy arbitrary code on

00:16:37,950 --> 00:16:48,000
your device okay in this figure there is

00:16:43,890 --> 00:16:50,610
two part at the top there is a figure

00:16:48,000 --> 00:16:55,380
which is very similar to the previous

00:16:50,610 --> 00:16:59,850
one you have the immutable immutable

00:16:55,380 --> 00:17:02,970
code via to bootloader secure image

00:16:59,850 --> 00:17:04,470
non-secure image the difference is here

00:17:02,970 --> 00:17:07,530
that you know the sexual image is

00:17:04,470 --> 00:17:12,569
verified no sexual image but this is

00:17:07,530 --> 00:17:15,540
just kind of implementation on the

00:17:12,569 --> 00:17:17,880
bottom there is the situation how the

00:17:15,540 --> 00:17:21,720
booting is currently working at EF our

00:17:17,880 --> 00:17:23,910
project we have no Bonnie bootloader

00:17:21,720 --> 00:17:26,430
implementation at this stage this is

00:17:23,910 --> 00:17:28,920
under discussions that do we need it

00:17:26,430 --> 00:17:32,850
will be do it later so we haven't

00:17:28,920 --> 00:17:33,660
decided yet we are using MCU boot as a

00:17:32,850 --> 00:17:41,250
beer too

00:17:33,660 --> 00:17:45,240
and the main difference is here that we

00:17:41,250 --> 00:17:48,090
are not signing the secure and annoy

00:17:45,240 --> 00:17:49,590
sexual image separately instead we are

00:17:48,090 --> 00:17:53,850
combining the secure and non-secure

00:17:49,590 --> 00:18:00,030
image into one big binary blob which

00:17:53,850 --> 00:18:03,810
gets signature together we had to verify

00:18:00,030 --> 00:18:06,480
this combined binary blob the integrity

00:18:03,810 --> 00:18:11,600
and authenticity and then it will start

00:18:06,480 --> 00:18:14,610
the secure code which will do some

00:18:11,600 --> 00:18:17,400
runtime software environment

00:18:14,610 --> 00:18:21,630
initialization and pass the execution to

00:18:17,400 --> 00:18:24,350
the non-security but here I'm sorry but

00:18:21,630 --> 00:18:27,150
here we don't need any further

00:18:24,350 --> 00:18:28,030
authentication because it is done by the

00:18:27,150 --> 00:18:40,480
bootloader

00:18:28,030 --> 00:18:44,980
at the beginning any question okay if

00:18:40,480 --> 00:18:51,090
know that I go go on the next few style

00:18:44,980 --> 00:18:54,070
will be about how Nancy would works okay

00:18:51,090 --> 00:18:56,950
on the right side we have a memory map

00:18:54,070 --> 00:19:00,790
this is static memory upon and class

00:18:56,950 --> 00:19:04,510
devices the bootloader at the beginning

00:19:00,790 --> 00:19:08,980
of the flash this is because the core

00:19:04,510 --> 00:19:13,060
starts to execute code which is a zero

00:19:08,980 --> 00:19:15,940
memory address after the bootloader

00:19:13,060 --> 00:19:18,850
we have two memory partition we have

00:19:15,940 --> 00:19:23,820
memory partition to 0 and we have memory

00:19:18,850 --> 00:19:27,190
partition 1 this is for the active image

00:19:23,820 --> 00:19:30,400
so you can have an active image which

00:19:27,190 --> 00:19:34,930
size is smaller than even have for the

00:19:30,400 --> 00:19:37,780
flash and this image is splitted four to

00:19:34,930 --> 00:19:39,640
two part at least you have the secure

00:19:37,780 --> 00:19:43,780
forever here and you have the non secure

00:19:39,640 --> 00:19:47,140
formerly the code must be linked that it

00:19:43,780 --> 00:19:49,390
can run from this ammo range so it is

00:19:47,140 --> 00:19:54,370
execution in place it is a position

00:19:49,390 --> 00:20:00,540
dependent code I mentioned that the

00:19:54,370 --> 00:20:04,090
image must get some header and other

00:20:00,540 --> 00:20:06,970
preparation to be able to authenticate

00:20:04,090 --> 00:20:09,730
it by the bootloader that's the reason

00:20:06,970 --> 00:20:12,730
why the header is at the beginning of

00:20:09,730 --> 00:20:17,050
the second format and we have te

00:20:12,730 --> 00:20:20,110
timeline value fields at the back at the

00:20:17,050 --> 00:20:23,010
end here are the hash value and here are

00:20:20,110 --> 00:20:26,320
the digital signature which is about

00:20:23,010 --> 00:20:29,290
this part the header the secure part and

00:20:26,320 --> 00:20:31,960
the nor secure part at the end of the

00:20:29,290 --> 00:20:35,320
active image and there is a trailer

00:20:31,960 --> 00:20:39,670
which is used for federal purposes but I

00:20:35,320 --> 00:20:40,470
will cover it later ok so your active

00:20:39,670 --> 00:20:42,990
image is only

00:20:40,470 --> 00:20:45,990
from this memory space you want to do an

00:20:42,990 --> 00:20:48,059
upgrade you have an upgrade grant which

00:20:45,990 --> 00:20:50,669
will download the new software and it

00:20:48,059 --> 00:20:53,789
must place to somewhere we have a

00:20:50,669 --> 00:20:57,870
secondary memory slot which is the equal

00:20:53,789 --> 00:21:05,039
size with the first one and new image

00:20:57,870 --> 00:21:09,419
will go to this place here okay on the

00:21:05,039 --> 00:21:11,850
other side of the slide you can see in

00:21:09,419 --> 00:21:14,789
high level how temps you would works how

00:21:11,850 --> 00:21:18,270
it does the upgrade the main thing is

00:21:14,789 --> 00:21:21,059
that your news software can't run from

00:21:18,270 --> 00:21:24,690
this memory address range because it was

00:21:21,059 --> 00:21:26,760
linked to the first slot so if you try

00:21:24,690 --> 00:21:31,159
to run it from here it will crash

00:21:26,760 --> 00:21:35,730
immediately so you need needham

00:21:31,159 --> 00:21:38,549
operation when you swap these two memory

00:21:35,730 --> 00:21:42,659
content and this is done wider and see

00:21:38,549 --> 00:21:47,940
boot after it released from preset it

00:21:42,659 --> 00:21:51,720
ours the memory content in our case

00:21:47,940 --> 00:21:55,020
there is no there is that was no for

00:21:51,720 --> 00:21:57,510
over failure before so we have a clear

00:21:55,020 --> 00:21:59,970
situation that we have a new image in

00:21:57,510 --> 00:22:02,100
the slot 1 this is realized by the

00:21:59,970 --> 00:22:05,640
bootloader because there is a magic

00:22:02,100 --> 00:22:07,740
value at the end of the manual partition

00:22:05,640 --> 00:22:11,460
if it is realized that there is a new

00:22:07,740 --> 00:22:14,789
software it starts to authenticated in

00:22:11,460 --> 00:22:19,650
case of successful authentication it

00:22:14,789 --> 00:22:22,740
will do the swapping I will have a slide

00:22:19,650 --> 00:22:27,809
theater how the shopping words after the

00:22:22,740 --> 00:22:32,700
swapping the new image was copied to the

00:22:27,809 --> 00:22:36,659
active memory area and actually it can

00:22:32,700 --> 00:22:41,179
be started by them stupid as soon as the

00:22:36,659 --> 00:22:41,179
execution let the new software

00:22:43,570 --> 00:22:52,460
again this night is about how this

00:22:46,010 --> 00:22:55,370
whopping verse verse it's divided in two

00:22:52,460 --> 00:22:59,210
rounds so it means that only a small

00:22:55,370 --> 00:23:05,600
portion of the memory area is copied at

00:22:59,210 --> 00:23:07,940
once the previous slide there is third

00:23:05,600 --> 00:23:10,640
memory partition which was not mentioned

00:23:07,940 --> 00:23:14,780
before this is the scratch area the

00:23:10,640 --> 00:23:18,200
scratch is used as a temporary storage

00:23:14,780 --> 00:23:24,530
place during the image swapping okay I

00:23:18,200 --> 00:23:27,920
have a motion here so MC would start the

00:23:24,530 --> 00:23:31,190
swapping at the end of the memory

00:23:27,920 --> 00:23:34,520
partitions so you can see here that in

00:23:31,190 --> 00:23:38,090
the active image area we already have

00:23:34,520 --> 00:23:41,000
the new image but only some part of it

00:23:38,090 --> 00:23:43,490
the last pieces are still the word

00:23:41,000 --> 00:23:48,230
software and the other side is now

00:23:43,490 --> 00:23:50,840
opposite on the new slot one partition

00:23:48,230 --> 00:23:54,230
we have the old image but there aren't

00:23:50,840 --> 00:23:58,630
the last bits here okay so the first

00:23:54,230 --> 00:23:58,630
step is to erase a scratch

00:23:59,170 --> 00:24:08,950
copy the slot one content to the speech

00:24:03,230 --> 00:24:15,110
area save some status information that

00:24:08,950 --> 00:24:20,090
about the progress of the swapping risk

00:24:15,110 --> 00:24:25,540
slot man copy that content of slotted 0

00:24:20,090 --> 00:24:34,370
to the slot 1 again do some

00:24:25,540 --> 00:24:36,610
swap status saving areas copy and it's

00:24:34,370 --> 00:24:36,610
done

00:24:37,480 --> 00:24:43,340
it is designed to be over failure that

00:24:40,910 --> 00:24:46,330
was the reason we that during this

00:24:43,340 --> 00:24:51,350
mapping we save some status information

00:24:46,330 --> 00:24:55,040
at the end of the active memory area if

00:24:51,350 --> 00:24:57,290
any face that we have a over failure and

00:24:55,040 --> 00:24:59,870
after the power comes back and see wood

00:24:57,290 --> 00:25:01,790
can recover what was the actual progress

00:24:59,870 --> 00:25:03,650
of the previous swapping and it can

00:25:01,790 --> 00:25:05,510
finish it it doesn't matter how many

00:25:03,650 --> 00:25:15,020
times we have the over failure during

00:25:05,510 --> 00:25:19,190
the swapping okay this is a slide about

00:25:15,020 --> 00:25:22,250
how we get the new soft firm because MCO

00:25:19,190 --> 00:25:24,590
boot is not involved that download the

00:25:22,250 --> 00:25:31,059
new software from a server or download

00:25:24,590 --> 00:25:36,850
new software through any interface yeah

00:25:31,059 --> 00:25:43,309
about quick question the does the scheme

00:25:36,850 --> 00:25:47,570
to rollback if the new image fell to

00:25:43,309 --> 00:25:50,120
start there will be a slide after it

00:25:47,570 --> 00:25:52,820
okay yeah III ask for that question at

00:25:50,120 --> 00:25:56,720
that time okay one more question in the

00:25:52,820 --> 00:26:00,880
layout of the flash partition did you

00:25:56,720 --> 00:26:04,940
miss another partition for data because

00:26:00,880 --> 00:26:08,960
conceivably it was stored data and no

00:26:04,940 --> 00:26:11,210
actually this partition is the flesh so

00:26:08,960 --> 00:26:14,570
you have a code which is the read-only

00:26:11,210 --> 00:26:16,910
code in the read white coat as well so

00:26:14,570 --> 00:26:19,460
after the image is started it will copy

00:26:16,910 --> 00:26:23,960
the readwrite data from the room to the

00:26:19,460 --> 00:26:26,210
ROM from the previous image you your

00:26:23,960 --> 00:26:30,350
updating right there's the old firmware

00:26:26,210 --> 00:26:33,530
the new firmware right yes after the new

00:26:30,350 --> 00:26:40,700
image starts the new image will copy no

00:26:33,530 --> 00:26:45,280
Bonnie okay so here by your update

00:26:40,700 --> 00:26:48,070
client downloads the new image to them

00:26:45,280 --> 00:26:50,440
to the flesh then you have the read-only

00:26:48,070 --> 00:26:54,340
code here and you have the read/write

00:26:50,440 --> 00:26:56,230
data here yeah but there might be

00:26:54,340 --> 00:26:59,530
persistent data and persistent left on

00:26:56,230 --> 00:27:01,030
your app that's what I meant yes he said

00:26:59,530 --> 00:27:03,160
yeah yeah that's a strap yeah at that

00:27:01,030 --> 00:27:05,140
part yeah positive that that must be a

00:27:03,160 --> 00:27:11,100
separate partition guy okay just

00:27:05,140 --> 00:27:14,860
conflict okay so back to this land

00:27:11,100 --> 00:27:17,860
okay so downloading the new software is

00:27:14,860 --> 00:27:21,700
not not the responsibility of the MCU

00:27:17,860 --> 00:27:24,430
boot so you need an update client which

00:27:21,700 --> 00:27:26,830
is part of the Orlan type firmware which

00:27:24,430 --> 00:27:29,170
has the capability through some

00:27:26,830 --> 00:27:32,320
interface wireless or wired interface

00:27:29,170 --> 00:27:36,100
download somewhere and somehow the new

00:27:32,320 --> 00:27:39,490
software this is here we have a server

00:27:36,100 --> 00:27:42,040
somewhere which send a notification to

00:27:39,490 --> 00:27:44,260
the updates behind that hey we have a

00:27:42,040 --> 00:27:47,770
new firmware for you we download the new

00:27:44,260 --> 00:27:50,700
firmware after we got the new firmware

00:27:47,770 --> 00:27:54,340
this must be authenticated before

00:27:50,700 --> 00:27:56,140
writing it to the flesh the reason

00:27:54,340 --> 00:27:57,970
because it's a good idea tote and to get

00:27:56,140 --> 00:28:01,240
before to write writing it to the

00:27:57,970 --> 00:28:03,790
fashion because you can might be get

00:28:01,240 --> 00:28:07,900
some arbitrary code from somewhere else

00:28:03,790 --> 00:28:11,710
and which can be denial of service

00:28:07,900 --> 00:28:14,650
attack as well done yet client

00:28:11,710 --> 00:28:16,990
functionality can be split between in

00:28:14,650 --> 00:28:19,750
the secure and the more secure world the

00:28:16,990 --> 00:28:21,880
non secure part of the update client is

00:28:19,750 --> 00:28:27,010
responsible to downloading the software

00:28:21,880 --> 00:28:29,440
and the secure function secure trusted

00:28:27,010 --> 00:28:31,690
up this function is responsible to do

00:28:29,440 --> 00:28:34,150
the authentication of the downloaded

00:28:31,690 --> 00:28:37,000
move further image after the

00:28:34,150 --> 00:28:40,660
authentication was done with success we

00:28:37,000 --> 00:28:42,610
write the code to the slot 1 memory

00:28:40,660 --> 00:28:46,000
partition which is for the new code and

00:28:42,610 --> 00:28:49,450
then the update client can restore the

00:28:46,000 --> 00:28:53,560
whole system after reset the bootloader

00:28:49,450 --> 00:28:56,050
will run so again as I showed you how it

00:28:53,560 --> 00:28:58,750
realize that we have something in the

00:28:56,050 --> 00:29:00,910
slot 1 it will change the con

00:28:58,750 --> 00:29:06,010
or the slot one and this load - and

00:29:00,910 --> 00:29:08,260
within ETS thought the slot 0 and after

00:29:06,010 --> 00:29:15,430
that your new code will run on the

00:29:08,260 --> 00:29:19,470
device ok so there was a question about

00:29:15,430 --> 00:29:22,500
what happens if you win which will fail

00:29:19,470 --> 00:29:28,060
actually it can happen so if you have a

00:29:22,500 --> 00:29:32,190
complicated device and your test cases

00:29:28,060 --> 00:29:35,260
the test coverage is not big enough that

00:29:32,190 --> 00:29:38,260
check every case is that there is a

00:29:35,260 --> 00:29:42,040
probability that when you do the update

00:29:38,260 --> 00:29:43,600
the new firmware image via crash for

00:29:42,040 --> 00:29:47,050
that reason there is a fallback

00:29:43,600 --> 00:29:49,480
Mahoney's muting the MCU would but the

00:29:47,050 --> 00:29:52,720
main point is here that you need

00:29:49,480 --> 00:29:56,950
something to be getting cell fast in

00:29:52,720 --> 00:30:00,100
your firmware because it might be really

00:29:56,950 --> 00:30:03,040
a crash which is obvious that it doesn't

00:30:00,100 --> 00:30:06,880
work but it might be can be a hidden bug

00:30:03,040 --> 00:30:09,760
in your system which only effects some

00:30:06,880 --> 00:30:14,320
part of your code it can run but it

00:30:09,760 --> 00:30:17,770
doesn't work as you expected so this

00:30:14,320 --> 00:30:20,650
buting self-test must verify the image

00:30:17,770 --> 00:30:22,930
or at least it must verify that we have

00:30:20,650 --> 00:30:25,240
a network of an activity towards the

00:30:22,930 --> 00:30:27,730
server if we realize that it doesn't

00:30:25,240 --> 00:30:30,940
work as expected we can still download a

00:30:27,730 --> 00:30:34,840
new software if this building stealth

00:30:30,940 --> 00:30:37,540
test was passed then we can mark a

00:30:34,840 --> 00:30:39,910
special field in the flesh

00:30:37,540 --> 00:30:42,760
which indicates that the image was

00:30:39,910 --> 00:30:47,620
verified and now it is a persistent run

00:30:42,760 --> 00:30:50,530
mode if for any reason this passed this

00:30:47,620 --> 00:30:57,180
test doesn't passed then we have the

00:30:50,530 --> 00:30:57,180
possibility to reset the device here

00:30:57,450 --> 00:31:03,670
here we have the software upgrade we

00:31:00,610 --> 00:31:06,910
have the old image new image do the

00:31:03,670 --> 00:31:11,420
reboot we do the upgrade and now he we

00:31:06,910 --> 00:31:13,730
doing the test if the test was ok then

00:31:11,420 --> 00:31:16,100
nothing change we can feel in the flesh

00:31:13,730 --> 00:31:18,500
that this image okay it's um correct

00:31:16,100 --> 00:31:20,600
incorrectly and if we have some rule

00:31:18,500 --> 00:31:22,880
that protection in the system then we

00:31:20,600 --> 00:31:25,370
set the rollback count of Saroja back

00:31:22,880 --> 00:31:30,050
counter to the new value only at this

00:31:25,370 --> 00:31:32,840
stage if the test was not work then we

00:31:30,050 --> 00:31:35,690
reboot the system and see you go checks

00:31:32,840 --> 00:31:41,950
the special flag in the flash memory and

00:31:35,690 --> 00:31:45,500
because it haven't been set due to the

00:31:41,950 --> 00:31:48,950
test failure it will revert back to the

00:31:45,500 --> 00:31:59,780
old image to the active memory partition

00:31:48,950 --> 00:32:11,090
and it will run it again after swear to

00:31:59,780 --> 00:32:21,500
the tunnel there and a petition in

00:32:11,090 --> 00:32:23,600
report and to a sim scene so David Brown

00:32:21,500 --> 00:32:25,280
from Iran represented a threat model

00:32:23,600 --> 00:32:28,250
which which actually wears out the

00:32:25,280 --> 00:32:30,290
device by just doing that and when he

00:32:28,250 --> 00:32:31,550
said that is very difficult problem to

00:32:30,290 --> 00:32:35,770
fix like he didn't have any

00:32:31,550 --> 00:32:35,770
recommendation for out that can be fixed

00:32:48,730 --> 00:32:54,740
sure this can be covered by the runtime

00:32:51,320 --> 00:32:56,540
for if you have communication channel

00:32:54,740 --> 00:32:58,880
between them you can realize that there

00:32:56,540 --> 00:33:03,860
is a problem with your further then you

00:32:58,880 --> 00:33:06,200
can activate code which clear that

00:33:03,860 --> 00:33:11,090
special fact you can reset the device

00:33:06,200 --> 00:33:16,940
and or even more you can fix the bug and

00:33:11,090 --> 00:33:19,770
do another upgrade just an interesting

00:33:16,940 --> 00:33:22,100
tidbit of information the runtime aisle

00:33:19,770 --> 00:33:26,280
people that actually develop this code

00:33:22,100 --> 00:33:28,140
they don't generally use this they will

00:33:26,280 --> 00:33:31,410
deploy a system with the rollback

00:33:28,140 --> 00:33:34,560
enabled um maybe a dozen or a hundred

00:33:31,410 --> 00:33:37,860
devices it's kind of a beta test and

00:33:34,560 --> 00:33:39,750
then the main deployment doesn't enable

00:33:37,860 --> 00:33:41,760
the rollback and the devices just boot

00:33:39,750 --> 00:33:45,000
or they don't work at all

00:33:41,760 --> 00:33:47,070
there's also risk when you do this if

00:33:45,000 --> 00:33:49,980
the power fails is a bad time then it

00:33:47,070 --> 00:33:55,980
doesn't roll back unnecessarily so it's

00:33:49,980 --> 00:33:57,570
it's complicated and I think at that

00:33:55,980 --> 00:34:00,120
point we will again mention that it's

00:33:57,570 --> 00:34:07,110
possible to contribute a different boot

00:34:00,120 --> 00:34:16,399
or a mechanism here any question about

00:34:07,110 --> 00:34:16,399
this slide okay here are some

00:34:23,000 --> 00:34:28,230
implementations

00:34:25,560 --> 00:34:29,700
secure boot so I believe it's using the

00:34:28,230 --> 00:34:37,409
secure storage right now for the

00:34:29,700 --> 00:34:38,850
authentication but before it puts into

00:34:37,409 --> 00:34:44,780
the flash it does an authentication

00:34:38,850 --> 00:34:47,730
write it down do the authentication but

00:34:44,780 --> 00:34:51,240
actually the upgrade client function it

00:34:47,730 --> 00:34:53,669
doesn't implement it yet so we have no a

00:34:51,240 --> 00:34:57,180
secure service which are doing the

00:34:53,669 --> 00:34:59,070
upgrade client so the starting point

00:34:57,180 --> 00:35:02,600
that you have a situation when both

00:34:59,070 --> 00:35:02,600
image is in the flesh

00:35:13,470 --> 00:35:18,369
so I think what's specific to mention is

00:35:16,630 --> 00:35:21,220
that basically what we have tried this

00:35:18,369 --> 00:35:23,950
that we can tap basically we can

00:35:21,220 --> 00:35:25,779
abstract out the downloading part of the

00:35:23,950 --> 00:35:29,289
firmware and do the prototyping of rest

00:35:25,779 --> 00:35:31,900
and enable facility where where when a

00:35:29,289 --> 00:35:34,000
client is available then these hooks can

00:35:31,900 --> 00:35:45,460
be utilized by that client in creating

00:35:34,000 --> 00:35:47,829
the picture so the image which you have

00:35:45,460 --> 00:35:49,510
downloaded from the you know from the

00:35:47,829 --> 00:35:51,430
server you think that it is already

00:35:49,510 --> 00:35:58,269
authenticated yeah at this stage of the

00:35:51,430 --> 00:36:01,900
implementation this life is about some

00:35:58,269 --> 00:36:05,730
device constrain the header size

00:36:01,900 --> 00:36:09,549
actually is is quite small it's only 30

00:36:05,730 --> 00:36:13,059
140 million bytes but it must be placed

00:36:09,549 --> 00:36:15,730
at the beginning of the image and there

00:36:13,059 --> 00:36:18,400
are some certain memory alignment then

00:36:15,730 --> 00:36:21,309
after the header your image is starting

00:36:18,400 --> 00:36:23,559
and the vector table is there you need

00:36:21,309 --> 00:36:26,769
to set the vector table offset register

00:36:23,559 --> 00:36:30,000
to this certain address but the vector

00:36:26,769 --> 00:36:32,259
table register cannot be set to any

00:36:30,000 --> 00:36:36,359
address in the memory address space

00:36:32,259 --> 00:36:42,099
there are some device specific alignment

00:36:36,359 --> 00:36:44,890
so it at least must be these values

00:36:42,099 --> 00:36:50,460
aligned so after the header there is a

00:36:44,890 --> 00:36:56,170
gap and only after the image is started

00:36:50,460 --> 00:36:58,720
on other constraint is that the two

00:36:56,170 --> 00:37:02,799
slots does not one and the slots view

00:36:58,720 --> 00:37:06,250
must be equal sized and the underlying

00:37:02,799 --> 00:37:09,579
flash layout must be the same there are

00:37:06,250 --> 00:37:12,640
some flesh which has a homogeneous flash

00:37:09,579 --> 00:37:14,410
layout where in that case this is not an

00:37:12,640 --> 00:37:16,810
issue but there are some flash where

00:37:14,410 --> 00:37:18,790
there is inhomogeneous flash layout

00:37:16,810 --> 00:37:24,100
in that cases you must be aware that the

00:37:18,790 --> 00:37:28,000
freshly it must be the same the spread

00:37:24,100 --> 00:37:31,630
size the scratch area must be at least

00:37:28,000 --> 00:37:36,760
as big than your biggest irritable unit

00:37:31,630 --> 00:37:39,580
on the flesh and you must consider that

00:37:36,760 --> 00:37:43,330
how many upgrade would be possible

00:37:39,580 --> 00:37:45,910
during the device life life cycle if for

00:37:43,330 --> 00:37:49,810
any reason you want to upgrade every

00:37:45,910 --> 00:37:53,440
week then you probably need to take care

00:37:49,810 --> 00:37:56,080
about the flash wear out and you might

00:37:53,440 --> 00:38:00,130
be better to choose a bigger scratch

00:37:56,080 --> 00:38:04,150
size because in that case it not used so

00:38:00,130 --> 00:38:10,150
frequently and you can you can make a

00:38:04,150 --> 00:38:13,510
longer lifetime of your device the image

00:38:10,150 --> 00:38:16,600
size cannot be as big as the flesh area

00:38:13,510 --> 00:38:19,240
which is allocated for is it we need

00:38:16,600 --> 00:38:23,380
space for the header you need space from

00:38:19,240 --> 00:38:27,310
the image hash value digital signature

00:38:23,380 --> 00:38:31,900
we need space for swap status

00:38:27,310 --> 00:38:34,390
information so let's say it's around 90

00:38:31,900 --> 00:38:36,910
percentage of the flash area can be used

00:38:34,390 --> 00:38:43,300
for language and the rest must be

00:38:36,910 --> 00:38:46,360
allocated for additional data currently

00:38:43,300 --> 00:38:49,020
in our version there is no recovery

00:38:46,360 --> 00:38:51,670
option it means that if for any reason

00:38:49,020 --> 00:38:55,030
the alternate occasion of both images

00:38:51,670 --> 00:38:59,680
Fairs than the MCU boot won't start

00:38:55,030 --> 00:39:03,100
anything and there is no option to use a

00:38:59,680 --> 00:39:06,580
serial serial interface to download some

00:39:03,100 --> 00:39:09,340
recovery image or so on I know that the

00:39:06,580 --> 00:39:14,500
original C boot implementation has got

00:39:09,340 --> 00:39:23,830
this feature recently but we copied the

00:39:14,500 --> 00:39:28,530
code before this was implemented ok this

00:39:23,830 --> 00:39:32,020
line is about a few threads which can be

00:39:28,530 --> 00:39:34,410
against an i/o device and which is more

00:39:32,020 --> 00:39:39,640
specific on the software upgrade and

00:39:34,410 --> 00:39:42,280
booting process a thread can be that a

00:39:39,640 --> 00:39:44,860
malicious actor tries to send some

00:39:42,280 --> 00:39:50,440
arbitrary code to your device in order

00:39:44,860 --> 00:39:53,200
to access secrets on your device the

00:39:50,440 --> 00:39:55,900
mitigation can be to use sign further

00:39:53,200 --> 00:39:58,720
images in that way you can be sure that

00:39:55,900 --> 00:40:01,720
only the code which is coming from your

00:39:58,720 --> 00:40:03,940
server will run on the device and this

00:40:01,720 --> 00:40:08,530
is implemented correctly and she would

00:40:03,940 --> 00:40:12,460
choose it use the LSA algorithm another

00:40:08,530 --> 00:40:14,230
threat can be at somebody know that

00:40:12,460 --> 00:40:16,660
there is a vulnerability in your water

00:40:14,230 --> 00:40:19,930
software version and try to downgrade

00:40:16,660 --> 00:40:22,150
your device to this version because he

00:40:19,930 --> 00:40:24,220
has already made at a corrector with

00:40:22,150 --> 00:40:27,430
which he easily can access to the data a

00:40:24,220 --> 00:40:32,050
mitigation can be to use monotonic

00:40:27,430 --> 00:40:34,960
counter in your device which is the

00:40:32,050 --> 00:40:37,420
image also has the value and use stores

00:40:34,960 --> 00:40:39,850
invert value in the device and you

00:40:37,420 --> 00:40:43,830
compare those values and if the value is

00:40:39,850 --> 00:40:50,200
less in the image which is stored in the

00:40:43,830 --> 00:40:53,460
device you won't let run those further

00:40:50,200 --> 00:40:57,280
currently we have no implementation

00:40:53,460 --> 00:41:03,480
against this attack but we are plan to

00:40:57,280 --> 00:41:06,400
address this issue third can be to

00:41:03,480 --> 00:41:14,380
install a persistent memory on your

00:41:06,400 --> 00:41:17,200
device this can be discovered by an

00:41:14,380 --> 00:41:22,360
immutable good good which is the one

00:41:17,200 --> 00:41:25,120
image our target platforms are not not

00:41:22,360 --> 00:41:25,869
designed to have some immutable code on

00:41:25,120 --> 00:41:28,650
it so

00:41:25,869 --> 00:41:31,089
even there is no flesh on their ps2

00:41:28,650 --> 00:41:33,219
development world there is only called

00:41:31,089 --> 00:41:39,009
us from so this is currently not an

00:41:33,219 --> 00:41:42,160
option for us okay it can be that

00:41:39,009 --> 00:41:45,309
somebody tries to send an image which

00:41:42,160 --> 00:41:48,009
has a bug in it and he wants that your

00:41:45,309 --> 00:41:52,059
device will fail it's kind of a denial

00:41:48,009 --> 00:41:55,410
denial of service attack if you have a

00:41:52,059 --> 00:41:57,969
backup image on your device and you can

00:41:55,410 --> 00:42:00,819
recognize that the new image doesn't

00:41:57,969 --> 00:42:03,400
work properly then you can still do a

00:42:00,819 --> 00:42:06,219
reverse and run the stable version on

00:42:03,400 --> 00:42:12,099
your device currently this feature is

00:42:06,219 --> 00:42:15,969
implemented in absolute it can be that

00:42:12,099 --> 00:42:18,039
an attacker can access to the private

00:42:15,969 --> 00:42:20,619
key if you can access to the private key

00:42:18,039 --> 00:42:23,140
you can generate any you can generate a

00:42:20,619 --> 00:42:25,089
proper signature which will pass on the

00:42:23,140 --> 00:42:28,989
authentication and he can deploy a

00:42:25,089 --> 00:42:31,779
software on your device for this reason

00:42:28,989 --> 00:42:34,239
it's good advice that you must ensure

00:42:31,779 --> 00:42:37,390
that you can replace the keys in the

00:42:34,239 --> 00:42:40,599
device if you recognize that somebody

00:42:37,390 --> 00:42:44,049
stole your key then immediately you need

00:42:40,599 --> 00:42:46,479
to install a new public key on the

00:42:44,049 --> 00:42:49,509
device and the corresponding private key

00:42:46,479 --> 00:42:53,799
can be used to sign the new formers and

00:42:49,509 --> 00:42:59,950
the old private key won't work any

00:42:53,799 --> 00:43:04,119
further we wants to implement this key

00:42:59,950 --> 00:43:11,410
recovery vocation and key deployment in

00:43:04,119 --> 00:43:15,400
near future okay I mentioned that MC

00:43:11,410 --> 00:43:19,569
would do the image swapping actually

00:43:15,400 --> 00:43:22,390
this is quite a complicated logic in in

00:43:19,569 --> 00:43:26,289
the code and the biggest part of the

00:43:22,390 --> 00:43:29,739
code beside the crypto library is image

00:43:26,289 --> 00:43:34,839
opinion if your device is a constraint

00:43:29,739 --> 00:43:37,590
one that you might be avoid that so you

00:43:34,839 --> 00:43:40,860
want to achieve that

00:43:37,590 --> 00:43:46,050
minimalist code size on your device so

00:43:40,860 --> 00:43:48,720
here is some alternative solution when

00:43:46,050 --> 00:43:51,570
you can avoid to do the image swapping

00:43:48,720 --> 00:43:57,810
you can compile a position independent

00:43:51,570 --> 00:43:59,790
code which means that any position from

00:43:57,810 --> 00:44:04,680
the flash you can download your software

00:43:59,790 --> 00:44:06,600
and will run it because in a position

00:44:04,680 --> 00:44:08,160
dependent cone you have absolute

00:44:06,600 --> 00:44:09,960
addresses when you have a branch in

00:44:08,160 --> 00:44:12,120
instruction there is an absolute address

00:44:09,960 --> 00:44:14,550
where to Blanche if you have a position

00:44:12,120 --> 00:44:16,620
independent code there is no absolute

00:44:14,550 --> 00:44:21,900
addresses in the code instead you have

00:44:16,620 --> 00:44:24,420
relative addresses from the PC so in

00:44:21,900 --> 00:44:26,550
this case you can compile the new image

00:44:24,420 --> 00:44:28,980
you can run it you can download it to

00:44:26,550 --> 00:44:34,260
them it's not one memory area and you

00:44:28,980 --> 00:44:37,350
can start it immediately known you don't

00:44:34,260 --> 00:44:40,380
need to do the swapping in this case the

00:44:37,350 --> 00:44:43,380
upgrade client must know that which is

00:44:40,380 --> 00:44:46,010
the currently active area and it must

00:44:43,380 --> 00:44:49,020
write the new image to the other area

00:44:46,010 --> 00:44:50,760
but there are penalties when you are

00:44:49,020 --> 00:44:56,580
combining a position independent code

00:44:50,760 --> 00:44:58,650
your code will be bigger might be some

00:44:56,580 --> 00:45:01,350
libraries can be combined to be position

00:44:58,650 --> 00:45:03,330
independent and so on but I have a

00:45:01,350 --> 00:45:06,150
separate slide the position independent

00:45:03,330 --> 00:45:11,160
code because recently we did some

00:45:06,150 --> 00:45:13,980
experiment on it another way to avoid

00:45:11,160 --> 00:45:18,740
the image swapping can be doing image

00:45:13,980 --> 00:45:21,720
good I mean dual image that you

00:45:18,740 --> 00:45:24,600
real-time you build to finally one

00:45:21,720 --> 00:45:27,960
binary from the folder slot one memory

00:45:24,600 --> 00:45:31,830
area and vampire foot slot zero memory

00:45:27,960 --> 00:45:36,840
area and in this case you have still the

00:45:31,830 --> 00:45:38,940
position dependent code the difference

00:45:36,840 --> 00:45:43,110
is that is linked to different memory

00:45:38,940 --> 00:45:46,630
areas here your update client must be

00:45:43,110 --> 00:45:49,710
clever enough that you need to be

00:45:46,630 --> 00:45:54,849
you recognize which is the active memory

00:45:49,710 --> 00:45:57,880
area and he downloads the other binary

00:45:54,849 --> 00:46:00,099
from the server and the other binary

00:45:57,880 --> 00:46:04,680
will be placed to their currently

00:46:00,099 --> 00:46:07,479
inactive memory area and this is

00:46:04,680 --> 00:46:13,989
swapping from boot boot which is the

00:46:07,479 --> 00:46:18,099
active and inactive memory area other

00:46:13,989 --> 00:46:20,349
alternative solutions can be that if you

00:46:18,099 --> 00:46:23,849
have enough RAM space then it doesn't

00:46:20,349 --> 00:46:27,210
need to run your software from flash

00:46:23,849 --> 00:46:31,599
running from the ROM is even better it's

00:46:27,210 --> 00:46:34,869
it's faster you can create position

00:46:31,599 --> 00:46:37,989
position dependent code and in this case

00:46:34,869 --> 00:46:40,239
you are using the flash just storage

00:46:37,989 --> 00:46:45,910
place and the bootloader do the

00:46:40,239 --> 00:46:51,960
authentication loads the binary to the

00:46:45,910 --> 00:46:57,460
ROM and start it from there other

00:46:51,960 --> 00:47:00,039
solution can be but as I mentioned there

00:46:57,460 --> 00:47:03,749
is no enough RAM in the EM plus devices

00:47:00,039 --> 00:47:06,160
usually there is less rum than flesh

00:47:03,749 --> 00:47:08,880
this is works well with the a-class

00:47:06,160 --> 00:47:12,579
devices but doesn't work for the Empress

00:47:08,880 --> 00:47:18,119
another solution can be to have of chips

00:47:12,579 --> 00:47:21,239
or storage on your PCB and this Asli of

00:47:18,119 --> 00:47:23,680
of cheap storage can be used as a

00:47:21,239 --> 00:47:26,710
storage device your update client

00:47:23,680 --> 00:47:28,660
downloads the new image and instead

00:47:26,710 --> 00:47:30,999
putting it to the internal flash it's

00:47:28,660 --> 00:47:33,509
always copied to the external storage

00:47:30,999 --> 00:47:36,450
and the bootloader during the boot

00:47:33,509 --> 00:47:39,789
authenticate the image loaded from off

00:47:36,450 --> 00:47:46,319
cheap storage to the own ship internal

00:47:39,789 --> 00:47:50,109
flash and executed but it has risk

00:47:46,319 --> 00:47:54,339
because might be you need to store your

00:47:50,109 --> 00:47:56,369
firmware in an encrypted form or might

00:47:54,339 --> 00:47:56,369
be

00:47:59,079 --> 00:48:06,829
under alternative solution can be that

00:48:02,240 --> 00:48:08,750
over right I guess David was referring

00:48:06,829 --> 00:48:10,869
to the overwrite feature when he

00:48:08,750 --> 00:48:14,210
mentioned that the runtime owl I will

00:48:10,869 --> 00:48:17,690
company doesn't really use the fallback

00:48:14,210 --> 00:48:20,329
Mahoney's so if your device is simple

00:48:17,690 --> 00:48:22,490
enough then you can test all the best

00:48:20,329 --> 00:48:25,520
cases and all the scenarios and you are

00:48:22,490 --> 00:48:28,010
self confident enough that this code

00:48:25,520 --> 00:48:31,339
will be okay on any devices on the field

00:48:28,010 --> 00:48:33,829
then you can do that during the NC would

00:48:31,339 --> 00:48:38,810
compile time you can apply a switch

00:48:33,829 --> 00:48:41,720
which turn on the swapping and it will

00:48:38,810 --> 00:48:44,300
turn turn off the stop slapping and turn

00:48:41,720 --> 00:48:46,640
on functionality which will copy the

00:48:44,300 --> 00:48:49,880
content of the slot 1 to the slot 0

00:48:46,640 --> 00:48:57,530
memory address and do do the image

00:48:49,880 --> 00:49:01,819
upgrade in this way okay this slide is

00:48:57,530 --> 00:49:05,210
about the position independent code we

00:49:01,819 --> 00:49:08,240
did some experiment on this field so

00:49:05,210 --> 00:49:12,170
what we did we try to compile the NC

00:49:08,240 --> 00:49:17,030
boot to be position independent and test

00:49:12,170 --> 00:49:21,410
it that can it really run from any space

00:49:17,030 --> 00:49:29,000
from the memory we can do that but there

00:49:21,410 --> 00:49:31,819
was some some issues around it might be

00:49:29,000 --> 00:49:34,970
the most important thing is that the

00:49:31,819 --> 00:49:38,780
binary will be I would say much bigger

00:49:34,970 --> 00:49:43,579
so in this size the 9 kilobyte of

00:49:38,780 --> 00:49:47,720
increase it's a significant and it was

00:49:43,579 --> 00:49:51,560
quite interesting that not really the

00:49:47,720 --> 00:49:55,220
code of the crypto library or the code

00:49:51,560 --> 00:49:58,579
of the bootloader itself will be bigger

00:49:55,220 --> 00:50:02,060
than the compiler for some reason pull

00:49:58,579 --> 00:50:04,490
in more see library functionalities it's

00:50:02,060 --> 00:50:07,280
still under investigation but the reason

00:50:04,490 --> 00:50:09,930
because those like those functionalities

00:50:07,280 --> 00:50:12,820
was put in

00:50:09,930 --> 00:50:16,180
there are some limitations around when

00:50:12,820 --> 00:50:19,380
you try to compile a code to be position

00:50:16,180 --> 00:50:24,720
independent it cannot contain any

00:50:19,380 --> 00:50:27,660
constant pointer you will get I did this

00:50:24,720 --> 00:50:30,610
experiment with our si lang compiler

00:50:27,660 --> 00:50:33,100
might be other compilers behaves in a

00:50:30,610 --> 00:50:35,830
different way but Adam Zealand has these

00:50:33,100 --> 00:50:39,820
limitations if you want to compile a

00:50:35,830 --> 00:50:43,210
secure secure binary there is a special

00:50:39,820 --> 00:50:46,030
compiler FAQ which must be applied but

00:50:43,210 --> 00:50:50,070
this compiler flag is doesn't compatible

00:50:46,030 --> 00:50:55,900
with corresponding position independent

00:50:50,070 --> 00:50:58,750
flag so actually your secure binary one

00:50:55,900 --> 00:51:02,470
vehicle can be compiled to be position

00:50:58,750 --> 00:51:04,990
independent and there are some other

00:51:02,470 --> 00:51:09,910
libraries I try to replace the standard

00:51:04,990 --> 00:51:12,880
c library to my crib my ID was that okay

00:51:09,910 --> 00:51:15,430
here i have a huge increase replace the

00:51:12,880 --> 00:51:18,040
library and might be i can avoid this

00:51:15,430 --> 00:51:20,170
big increase here but it turned out for

00:51:18,040 --> 00:51:23,170
example that my credit library cannot be

00:51:20,170 --> 00:51:27,480
compiled as a position independent or

00:51:23,170 --> 00:51:27,480
you need to change the libraries of

00:51:31,080 --> 00:51:39,270
okay is the names quick question around

00:51:33,600 --> 00:51:43,890
position independent code or do you plan

00:51:39,270 --> 00:51:50,010
to support bugs eventually optional

00:51:43,890 --> 00:52:00,800
config it's under discussion community

00:51:50,010 --> 00:52:04,830
can decide okay yeah okay

00:52:00,800 --> 00:52:11,460
might be idea skip this slide and god

00:52:04,830 --> 00:52:13,290
this light a symmetric cryptography can

00:52:11,460 --> 00:52:16,710
be time-consuming so if you have a

00:52:13,290 --> 00:52:19,590
device when it's really important that

00:52:16,710 --> 00:52:22,140
the boot time must be very short

00:52:19,590 --> 00:52:25,350
then the symmetric cryptography is not

00:52:22,140 --> 00:52:28,230
the best solution because it takes time

00:52:25,350 --> 00:52:30,660
especially in a constrained device so

00:52:28,230 --> 00:52:32,550
you can do some tricks and I want it

00:52:30,660 --> 00:52:35,790
the one trick can be to replace the

00:52:32,550 --> 00:52:38,310
symmetric to replace the a symmetric

00:52:35,790 --> 00:52:40,860
cryptography to symmetric key from the

00:52:38,310 --> 00:52:43,890
photography or even to ash calculation

00:52:40,860 --> 00:52:47,370
this can be done to use the HVAC or the

00:52:43,890 --> 00:52:50,100
CMAC solution this works in a way that

00:52:47,370 --> 00:52:53,100
your upgrade client downloads the image

00:52:50,100 --> 00:52:59,040
which still have the digital signature

00:52:53,100 --> 00:53:02,750
it use RSA or ECC to verify the image

00:52:59,040 --> 00:53:06,270
and if the verification was fast than it

00:53:02,750 --> 00:53:09,540
generated a new digital signature but

00:53:06,270 --> 00:53:13,560
those new digital signature is not a

00:53:09,540 --> 00:53:18,140
symmetric crypto base this is H Mac or C

00:53:13,560 --> 00:53:21,300
Mac message authentication code but you

00:53:18,140 --> 00:53:22,800
must be sure you can be sure that the

00:53:21,300 --> 00:53:25,110
image is correct because you

00:53:22,800 --> 00:53:29,670
authenticate it you create a new

00:53:25,110 --> 00:53:32,160
signature and you store both the image

00:53:29,670 --> 00:53:34,920
and the new signature in the flash your

00:53:32,160 --> 00:53:38,040
boot order can realize that okay I have

00:53:34,920 --> 00:53:41,130
an additional tier V value at the end of

00:53:38,040 --> 00:53:44,930
the image which is a HM Accorsi Mac

00:53:41,130 --> 00:53:49,109
this is depends on the

00:53:44,930 --> 00:53:51,180
implementation and can verify that one

00:53:49,109 --> 00:53:52,500
using hash racing asymmetric

00:53:51,180 --> 00:53:54,450
cryptography which is less

00:53:52,500 --> 00:53:58,320
time-consuming than the symmetric

00:53:54,450 --> 00:54:01,440
version other solution can be to speed

00:53:58,320 --> 00:54:05,280
up like in cryptography to use crypto

00:54:01,440 --> 00:54:10,170
hardware accelerator arm has on our IP

00:54:05,280 --> 00:54:14,400
crypto cell to 1/6 which two one two

00:54:10,170 --> 00:54:18,210
three one two sorry which is a specially

00:54:14,400 --> 00:54:23,910
designed for M plus devices so it has no

00:54:18,210 --> 00:54:25,800
footprint they actually deliver it with

00:54:23,910 --> 00:54:28,490
two library there is a booth library

00:54:25,800 --> 00:54:31,369
there is a long time runtime library

00:54:28,490 --> 00:54:34,140
boot library can be used during

00:54:31,369 --> 00:54:36,540
bootloader it can do the signature

00:54:34,140 --> 00:54:38,880
verification and it can offload the

00:54:36,540 --> 00:54:42,210
times time consuming part of the

00:54:38,880 --> 00:54:45,540
symmetric calculation phone software two

00:54:42,210 --> 00:54:46,740
dedicated Hardware engine it supports

00:54:45,540 --> 00:54:50,700
both the symmetric and asymmetric

00:54:46,740 --> 00:54:56,160
cryptography algorithm as well it also

00:54:50,700 --> 00:54:58,380
contains some nice hardware features the

00:54:56,160 --> 00:55:01,800
reason one-time programmable memory you

00:54:58,380 --> 00:55:04,170
can publish under your crypto keys and

00:55:01,800 --> 00:55:11,990
you can provision there are four back

00:55:04,170 --> 00:55:16,230
counters and so on this is the plans

00:55:11,990 --> 00:55:18,270
they are quite aligned with one slide

00:55:16,230 --> 00:55:21,630
before where there was about the threads

00:55:18,270 --> 00:55:24,980
so we want to support down to row back

00:55:21,630 --> 00:55:27,960
protection as part of the BSA compliance

00:55:24,980 --> 00:55:31,380
we want to create an interface between

00:55:27,960 --> 00:55:34,190
the border and runtime forever this is

00:55:31,380 --> 00:55:37,710
need for some features which is

00:55:34,190 --> 00:55:40,530
recommended but the PSA for example at

00:55:37,710 --> 00:55:42,359
the station when your device need to

00:55:40,530 --> 00:55:45,810
prove the identity to virtual remote

00:55:42,359 --> 00:55:47,640
server it's done a way that it's test

00:55:45,810 --> 00:55:50,180
the server the hash values and the

00:55:47,640 --> 00:55:52,380
cryptographic signatures of the device

00:55:50,180 --> 00:55:53,720
bootloader has a knowledge and the

00:55:52,380 --> 00:55:58,070
passive to the

00:55:53,720 --> 00:56:02,750
further we want to support chain of

00:55:58,070 --> 00:56:05,810
trust and key revocation also this is an

00:56:02,750 --> 00:56:07,910
ongoing how to make bootloader update

00:56:05,810 --> 00:56:10,460
the world this is where the position in

00:56:07,910 --> 00:56:13,849
the camp independent code is count and

00:56:10,460 --> 00:56:16,430
we want to add support to crypto

00:56:13,849 --> 00:56:19,700
Hardware because currently and the TLS

00:56:16,430 --> 00:56:23,960
is uses a crypto library but if you have

00:56:19,700 --> 00:56:25,310
a have a hardware which has this crypto

00:56:23,960 --> 00:56:31,430
accelerator

00:56:25,310 --> 00:56:34,160
you can switch build build build time

00:56:31,430 --> 00:56:39,680
switch to use the hardware instead of

00:56:34,160 --> 00:56:42,760
the software solution okay this is the

00:56:39,680 --> 00:56:47,180
slide from the previous presentation

00:56:42,760 --> 00:56:49,970
here you've found the source code team

00:56:47,180 --> 00:56:53,090
members we are here there will be an

00:56:49,970 --> 00:56:56,260
open session tomorrow afternoon if you

00:56:53,090 --> 00:57:02,150
have any question please go there and

00:56:56,260 --> 00:57:05,060
basically that's it any question have

00:57:02,150 --> 00:57:07,790
two questions earlier you were saying we

00:57:05,060 --> 00:57:11,650
try to implement how to revoke the keys

00:57:07,790 --> 00:57:14,240
if this private key is compromised I

00:57:11,650 --> 00:57:16,550
didn't quite understand it just simply

00:57:14,240 --> 00:57:20,330
means be the ability to update the po2

00:57:16,550 --> 00:57:21,890
or it's something different from that if

00:57:20,330 --> 00:57:24,200
you have a system where you have beer

00:57:21,890 --> 00:57:27,440
bong and beer - you can do it in that

00:57:24,200 --> 00:57:31,220
way that update the beard in our system

00:57:27,440 --> 00:57:33,589
we have only one beer - there is no beer

00:57:31,220 --> 00:57:38,450
one so we need to find another solution

00:57:33,589 --> 00:57:42,170
to do the key revocation so no no no

00:57:38,450 --> 00:57:45,470
detail solutions today yeah no not yet

00:57:42,170 --> 00:57:47,540
okay the second one is the we're talking

00:57:45,470 --> 00:57:48,560
about multiple plans to not to do the

00:57:47,540 --> 00:57:51,530
swapping right

00:57:48,560 --> 00:57:53,390
have you considered yet another

00:57:51,530 --> 00:57:57,440
alternative where basically you keep the

00:57:53,390 --> 00:57:59,599
update client as an image itself where

00:57:57,440 --> 00:58:02,119
you can always revert to that client to

00:57:59,599 --> 00:58:04,640
do the update so in case you fail one

00:58:02,119 --> 00:58:05,380
you can goes back to the update client

00:58:04,640 --> 00:58:08,560
in

00:58:05,380 --> 00:58:15,550
H and then to update the previous one to

00:58:08,560 --> 00:58:18,160
do the rollback so one of the problems

00:58:15,550 --> 00:58:21,100
in this space is executing place from

00:58:18,160 --> 00:58:25,330
flash that's third boundary you're

00:58:21,100 --> 00:58:26,620
talking about either update client is

00:58:25,330 --> 00:58:29,020
part of the binary itself or it's

00:58:26,620 --> 00:58:32,320
another binary in which case that itself

00:58:29,020 --> 00:58:42,130
is is part of the same equation we can

00:58:32,320 --> 00:58:46,330
talk to off the line yeah okay yep so my

00:58:42,130 --> 00:58:50,020
question is you you call it a method for

00:58:46,330 --> 00:58:54,400
ATF verifying your bootloader and a

00:58:50,020 --> 00:58:57,520
bunch of I guess keys and stuff like

00:58:54,400 --> 00:59:01,810
that because with it is that a standard

00:58:57,520 --> 00:59:04,360
that you're pushing in in the ATF space

00:59:01,810 --> 00:59:08,530
here and is it something that should

00:59:04,360 --> 00:59:12,480
then be replicated and say arm v7 which

00:59:08,530 --> 00:59:12,480
is something they might be interested in

00:59:12,780 --> 00:59:20,590
chain of Trustees recommendation by by

00:59:16,440 --> 00:59:28,420
BSA so you can put your specific version

00:59:20,590 --> 00:59:29,920
is that standards compliant so I think

00:59:28,420 --> 00:59:32,200
one of the one of the earlier

00:59:29,920 --> 00:59:35,560
presentations we've covered that these

00:59:32,200 --> 00:59:37,630
this just affirm that M is supposed to

00:59:35,560 --> 00:59:41,530
be the reference implementation of v8

00:59:37,630 --> 00:59:44,770
PSA so everything that is here should

00:59:41,530 --> 00:59:46,210
fall within PSA umbrella and there is a

00:59:44,770 --> 00:59:48,400
bootloader part of the specification

00:59:46,210 --> 00:59:52,780
which we'll cover but it gets

00:59:48,400 --> 00:59:56,530
implemented here what it gets

00:59:52,780 --> 00:59:59,050
implemented here by our current team but

00:59:56,530 --> 01:00:01,270
it may be that that people who are using

00:59:59,050 --> 01:00:02,920
it actually like for example you said

01:00:01,270 --> 01:00:04,990
you have it you have may have different

01:00:02,920 --> 01:00:07,150
requirements that is why it's an open

01:00:04,990 --> 01:00:08,860
source project so it may be that people

01:00:07,150 --> 01:00:11,710
actually say well we need different

01:00:08,860 --> 01:00:13,930
mechanism for doing this and hence it

01:00:11,710 --> 01:00:15,550
gets may be implemented and brought into

01:00:13,930 --> 01:00:17,290
the specification it's just

01:00:15,550 --> 01:00:20,890
if you guys have already done the work

01:00:17,290 --> 01:00:34,510
to figure out how to sign stuff and you

01:00:20,890 --> 01:00:36,430
have tools for that you know even that

01:00:34,510 --> 01:00:38,560
so basically you're talking about the

01:00:36,430 --> 01:00:40,720
standardization so even that is a

01:00:38,560 --> 01:00:41,170
mechanism at the moment so that's what

01:00:40,720 --> 01:00:43,090
I'm saying

01:00:41,170 --> 01:00:45,220
basically whether that's standardize or

01:00:43,090 --> 01:00:46,810
not is a slightly different cushion and

01:00:45,220 --> 01:00:48,430
see what is a mechanism and maybe there

01:00:46,810 --> 01:00:50,860
are others and platform security

01:00:48,430 --> 01:00:54,160
architecture might include that or might

01:00:50,860 --> 01:01:00,580
say that's not okay but that's very

01:00:54,160 --> 01:01:02,680
confusing for me so if you're interested

01:01:00,580 --> 01:01:04,870
in a standard there's an IETF working

01:01:02,680 --> 01:01:07,390
group called suit the software update

01:01:04,870 --> 01:01:10,780
for IOT that is developing a standard

01:01:07,390 --> 01:01:12,580
for this but that's an IETF working

01:01:10,780 --> 01:01:18,520
group were quite a ways away from that

01:01:12,580 --> 01:01:20,110
turning into a standard so I'm just a

01:01:18,520 --> 01:01:25,300
ferment for a you're talking or

01:01:20,110 --> 01:01:26,830
returning so so for EM yes there is that

01:01:25,300 --> 01:01:28,510
group but here at least in this

01:01:26,830 --> 01:01:32,200
discussion we are constraining ourself

01:01:28,510 --> 01:01:34,840
to ESA spec so at least our presentation

01:01:32,200 --> 01:01:36,450
conforms towards TSA as a set of

01:01:34,840 --> 01:01:39,970
specification so the only recommendation

01:01:36,450 --> 01:01:43,240
we can give is if you have a specific

01:01:39,970 --> 01:01:47,290
requirement it is better if it's raised

01:01:43,240 --> 01:01:48,580
to arm wire the TSA program and that it

01:01:47,290 --> 01:01:51,940
gets standardized and gets implemented

01:01:48,580 --> 01:01:53,530
in TFM as a mechanism or it gets copied

01:01:51,940 --> 01:01:56,050
are acquired from another place but

01:01:53,530 --> 01:01:57,730
eventually what you want is a is an

01:01:56,050 --> 01:02:01,590
implementation which actually conforms

01:01:57,730 --> 01:02:01,590
to a standard that you want to confirm

01:02:07,109 --> 01:02:11,900
and in theory should be fine right

01:02:09,869 --> 01:02:16,680
because it's already standardized for

01:02:11,900 --> 01:02:18,630
TFN right so also we as this has been

01:02:16,680 --> 01:02:19,920
dissident code today so we have it we

01:02:18,630 --> 01:02:24,119
are at the beginning so it's not stand

01:02:19,920 --> 01:02:26,519
right yet so if you copy today there is

01:02:24,119 --> 01:02:37,109
no sunrise the intention is for it to be

01:02:26,519 --> 01:02:40,190
standardized other question if no then

01:02:37,109 --> 01:02:40,190
thank you very much

01:02:40,360 --> 01:02:43,780
[Applause]

01:02:49,730 --> 01:02:51,790

YouTube URL: https://www.youtube.com/watch?v=B4kRZoKgN_g


