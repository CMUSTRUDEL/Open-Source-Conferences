Title: HKG18-222 - Trusted Firmware M : Secure Storage
Publication date: 2019-05-09
Playlist: Linaro Connect Hong Kong 2018
Description: 
	Session ID: HKG18-222
Session Name: HKG18-222 - Trusted Firmware M : Secure Storage
Speaker: Ashutosh Singh
Track: LITE


★ Session Summary ★
Introduction to secure storage concepts and design in TF-M. Some of the design choices and their rationale, and real use-cases to showcase how secure storage fits in the overall system. A sneak-peek into what is next.

Trusted Firmware M

In October 2017, Arm announced the vision of Platform Security Architecture (PSA) - a common framework to allow everyone in the IoT ecosystem to move forward with stronger, scalable security and greater confidence. There are three key stages to the Platform Security Architecture: Analysis, Architecture and Implementation which are described at https://developer.arm.com/products/architecture/platform-security-architecture.

_Trusted Firmware M, i.e. TF-M, is the Arm project to provide an open source reference implementation firmware that will conform to the PSA specification for M-Class devices. Early access to TF-M was released in December 2017 and it is being made public during Linaro Connect. The implementation should be considered a prototype until the PSA specifications reach release state and the code aligns._
---------------------------------------------------
★ Resources ★
Event Page: http://connect.linaro.org/resource/hkg18/hkg18-222/
Presentation: http://connect.linaro.org.s3.amazonaws.com/hkg18/presentations/hkg18-222.pdf
Video: http://connect.linaro.org.s3.amazonaws.com/hkg18/videos/hkg18-222.mp4
 ---------------------------------------------------
★ Event Details ★
Linaro Connect Hong Kong 2018 (HKG18)
19-23 March 2018 
Regal Airport Hotel Hong Kong

---------------------------------------------------
Keyword: LITE
'http://www.linaro.org'
'http://connect.linaro.org'
---------------------------------------------------
Follow us on Social Media
https://www.facebook.com/LinaroOrg
https://www.youtube.com/user/linaroorg?sub_confirmation=1
https://www.linkedin.com/company/1026961
Captions: 
	00:00:04,530 --> 00:00:06,590
you

00:00:15,520 --> 00:00:23,020
right hi Ron my name is Arash I am part

00:00:20,119 --> 00:00:25,490
of the open source software with UNAM

00:00:23,020 --> 00:00:26,930
today I'm going to talk about the secure

00:00:25,490 --> 00:00:28,730
storage solution that we have

00:00:26,930 --> 00:00:34,040
implemented interested from where corn

00:00:28,730 --> 00:00:35,780
and profile this is a layout of what we

00:00:34,040 --> 00:00:36,830
are going to talk about let's skip the

00:00:35,780 --> 00:00:39,140
introduction because we have already

00:00:36,830 --> 00:00:41,000
done that twice

00:00:39,140 --> 00:00:44,290
there will be brief introduction of what

00:00:41,000 --> 00:00:46,850
service means it was in the TSM context

00:00:44,290 --> 00:00:50,659
then we'll do a deep dive into some of

00:00:46,850 --> 00:00:52,670
the design aspects of secure storage and

00:00:50,659 --> 00:00:55,460
then we'll do a walk-through through an

00:00:52,670 --> 00:00:59,080
example use case to showcase how it all

00:00:55,460 --> 00:01:02,479
fits together in a consistent and

00:00:59,080 --> 00:01:04,909
finally we'll we'll have a quick look at

00:01:02,479 --> 00:01:10,549
what future might look like for secure

00:01:04,909 --> 00:01:16,760
storage I'll skip this bit you've

00:01:10,549 --> 00:01:19,730
already seen this so what is saracen in

00:01:16,760 --> 00:01:22,580
the DFM context it is the secure

00:01:19,730 --> 00:01:25,130
endpoint of the whole system it can

00:01:22,580 --> 00:01:26,810
provide services that could be

00:01:25,130 --> 00:01:29,960
cryptographic service it could be still

00:01:26,810 --> 00:01:33,380
a service or a vendor specific service

00:01:29,960 --> 00:01:35,150
and these services can be filtered on

00:01:33,380 --> 00:01:36,710
the basis of some sort of policy

00:01:35,150 --> 00:01:39,560
management or some sort of user

00:01:36,710 --> 00:01:41,930
authentication these services depending

00:01:39,560 --> 00:01:44,060
upon the isolation profile these

00:01:41,930 --> 00:01:47,270
services can be sandboxed in a way that

00:01:44,060 --> 00:01:49,190
they don't have to really trust and in a

00:01:47,270 --> 00:01:53,150
multi vendor scenario they could be come

00:01:49,190 --> 00:01:56,120
from different suppliers altogether in

00:01:53,150 --> 00:02:00,110
theory they can resources can support

00:01:56,120 --> 00:02:01,820
multiple contexts independent service

00:02:00,110 --> 00:02:08,509
independent context with different

00:02:01,820 --> 00:02:10,250
clients and they can be a service can be

00:02:08,509 --> 00:02:14,590
invoked either from the secure side as

00:02:10,250 --> 00:02:14,590
well or from a non secure point

00:02:18,830 --> 00:02:25,080
correcta devices have secrets this could

00:02:21,990 --> 00:02:28,200
be your route of Russkies it could be he

00:02:25,080 --> 00:02:30,440
that you use for DLS communication or it

00:02:28,200 --> 00:02:33,000
could be a provisioning key or a feature

00:02:30,440 --> 00:02:35,850
certificate that allows you to enable or

00:02:33,000 --> 00:02:39,360
disable features on a device in the

00:02:35,850 --> 00:02:40,980
runtime these verses are very very

00:02:39,360 --> 00:02:44,520
critical for the security of the system

00:02:40,980 --> 00:02:47,340
and for the operability of the system so

00:02:44,520 --> 00:02:51,420
they need to be protected in a way that

00:02:47,340 --> 00:02:53,580
a malicious axis is is denied and no one

00:02:51,420 --> 00:02:55,800
is able to change these assets so they

00:02:53,580 --> 00:02:57,840
should be if it has been tampered with

00:02:55,800 --> 00:03:01,080
at least we should be able to detect it

00:02:57,840 --> 00:03:03,750
and it should be reliable because the

00:03:01,080 --> 00:03:07,440
these resources are critical for the

00:03:03,750 --> 00:03:09,270
device's operation the storage mechanism

00:03:07,440 --> 00:03:11,700
should be in this should be done in such

00:03:09,270 --> 00:03:18,270
a way that it is safe against power

00:03:11,700 --> 00:03:21,750
failures this triad might be familiar to

00:03:18,270 --> 00:03:26,070
most of us the CI a confidentiality

00:03:21,750 --> 00:03:27,900
integrity and availability the

00:03:26,070 --> 00:03:31,320
assistance that we want to store need to

00:03:27,900 --> 00:03:36,510
be stored in a way that is not available

00:03:31,320 --> 00:03:38,340
to be seen by malicious actors and it

00:03:36,510 --> 00:03:40,830
should be not terrible which is

00:03:38,340 --> 00:03:43,470
integrated production and this both of

00:03:40,830 --> 00:03:47,820
this is achieved through a a ad based

00:03:43,470 --> 00:03:50,610
encryption policy all of the accesses to

00:03:47,820 --> 00:03:53,460
the secure storage or controlled by a

00:03:50,610 --> 00:03:56,250
policy manager so any request that comes

00:03:53,460 --> 00:03:58,770
in just first gets checked through the

00:03:56,250 --> 00:04:01,350
policy manager it decides whether to

00:03:58,770 --> 00:04:03,780
allow the caller the required access or

00:04:01,350 --> 00:04:07,140
not and then it goes on through the file

00:04:03,780 --> 00:04:13,530
system to action to do the actual access

00:04:07,140 --> 00:04:15,900
to complete the access request we have

00:04:13,530 --> 00:04:18,720
redefined the secure storage design has

00:04:15,900 --> 00:04:20,250
redefined the access of granularity in a

00:04:18,720 --> 00:04:23,040
typical file system we have read and

00:04:20,250 --> 00:04:25,259
write operation in secure storage we

00:04:23,040 --> 00:04:27,030
have introduced a new

00:04:25,259 --> 00:04:29,550
access the granularity which is

00:04:27,030 --> 00:04:33,990
reference and talk about this in more

00:04:29,550 --> 00:04:35,850
detail in one of the later slides the

00:04:33,990 --> 00:04:40,830
last aspect of this design is

00:04:35,850 --> 00:04:43,490
availability which is if device has a

00:04:40,830 --> 00:04:47,430
power failure or there has been some

00:04:43,490 --> 00:04:49,259
unscheduled or event the update and if

00:04:47,430 --> 00:04:52,229
there is update of operation going on

00:04:49,259 --> 00:04:54,509
that should not have a braking effect on

00:04:52,229 --> 00:04:57,180
the device so it should be able to fall

00:04:54,509 --> 00:04:59,130
back to the earlier content or it has

00:04:57,180 --> 00:05:01,440
new content it can't be a mix of old and

00:04:59,130 --> 00:05:03,949
new and because that can render the

00:05:01,440 --> 00:05:07,260
device completely useless

00:05:03,949 --> 00:05:09,510
so the secure storage solution makes

00:05:07,260 --> 00:05:13,710
sure that all of the update operations

00:05:09,510 --> 00:05:20,130
are atomic and yes as I said is either

00:05:13,710 --> 00:05:21,840
new or old not in between they should

00:05:20,130 --> 00:05:26,310
answer your question all of our

00:05:21,840 --> 00:05:28,979
solutions are scalable in a way that we

00:05:26,310 --> 00:05:31,530
realize that the array of devices is

00:05:28,979 --> 00:05:32,789
quite huge the devices can have very

00:05:31,530 --> 00:05:36,180
different kind of hardware and software

00:05:32,789 --> 00:05:39,000
resources and any solution that you make

00:05:36,180 --> 00:05:40,590
should be highly customizable so that is

00:05:39,000 --> 00:05:42,419
one of the design principles that we

00:05:40,590 --> 00:05:44,840
have used across different software

00:05:42,419 --> 00:05:44,840
components

00:05:47,860 --> 00:05:54,639
this is a very high level system view of

00:05:51,310 --> 00:06:01,270
the security component and how it fits

00:05:54,639 --> 00:06:03,150
into the overall system on the very top

00:06:01,270 --> 00:06:06,370
you can see the access policy management

00:06:03,150 --> 00:06:09,090
this is driven by a policy database for

00:06:06,370 --> 00:06:13,180
now it is a compile-time database and

00:06:09,090 --> 00:06:17,259
the this policy database which is again

00:06:13,180 --> 00:06:21,639
defined by the device maker that governs

00:06:17,259 --> 00:06:24,340
who can access what the next part is to

00:06:21,639 --> 00:06:27,550
a graphic pointing that's the layer

00:06:24,340 --> 00:06:30,159
which provides the secrecy the C&I part

00:06:27,550 --> 00:06:34,030
of DCI in the confidentiality and

00:06:30,159 --> 00:06:36,729
integrity part and it operates on the

00:06:34,030 --> 00:06:41,289
basis of its UK directly Hardware unique

00:06:36,729 --> 00:06:43,090
key and you can see this is overlapping

00:06:41,289 --> 00:06:45,370
between the crypto function and the

00:06:43,090 --> 00:06:48,099
secure service function because the

00:06:45,370 --> 00:06:50,530
whole management of the h UK key

00:06:48,099 --> 00:06:55,960
derivation is the responsibility of the

00:06:50,530 --> 00:07:00,219
crypto secure partition the next part is

00:06:55,960 --> 00:07:02,860
the filesystem this we have written it

00:07:00,219 --> 00:07:05,770
in a custom file system which is highly

00:07:02,860 --> 00:07:07,419
customized for embedded applications but

00:07:05,770 --> 00:07:09,969
it is possible to plug in a different

00:07:07,419 --> 00:07:12,819
file system and you could just replace

00:07:09,969 --> 00:07:15,880
and put or it could in fact be a proxy

00:07:12,819 --> 00:07:17,259
it doesn't need to be a file system the

00:07:15,880 --> 00:07:19,330
actual file system could be in a

00:07:17,259 --> 00:07:23,169
different partition or it could be

00:07:19,330 --> 00:07:26,740
sitting somewhere else which means not

00:07:23,169 --> 00:07:30,360
secure world and the last layer this

00:07:26,740 --> 00:07:30,360
this sorry

00:07:30,750 --> 00:07:36,480
the last lair this represents the assets

00:07:33,570 --> 00:07:39,300
which are actually stored by the secured

00:07:36,480 --> 00:07:41,430
storage it has a very tight coupling

00:07:39,300 --> 00:07:45,000
with the crypto function because all of

00:07:41,430 --> 00:07:48,740
the cryptographic operations are meant

00:07:45,000 --> 00:07:48,740
to be performed by the critical service

00:07:48,770 --> 00:07:56,010
then this orange bit we have the secure

00:07:53,760 --> 00:07:59,070
storage design has abstracted all these

00:07:56,010 --> 00:08:02,340
functionality in a sea carnival function

00:07:59,070 --> 00:08:05,040
so non secure side can just invoke these

00:08:02,340 --> 00:08:06,900
C functions and the rest of the

00:08:05,040 --> 00:08:15,900
mechanism is completely transparent to

00:08:06,900 --> 00:08:19,890
the caller we may not first released in

00:08:15,900 --> 00:08:23,220
December last year and this is what the

00:08:19,890 --> 00:08:26,640
secure storage had at that time it has a

00:08:23,220 --> 00:08:29,490
policy based access mechanism the policy

00:08:26,640 --> 00:08:32,070
table is compiled in at some point we

00:08:29,490 --> 00:08:36,300
would want to make it a provisioning

00:08:32,070 --> 00:08:38,490
step for now it is compiled in the whole

00:08:36,300 --> 00:08:40,500
of the secure storage operation is based

00:08:38,490 --> 00:08:42,900
on a single key we will talk about this

00:08:40,500 --> 00:08:46,620
in some more detail in one of the later

00:08:42,900 --> 00:08:49,110
slides the file system provides atomic

00:08:46,620 --> 00:08:52,020
access which means it's resistant to for

00:08:49,110 --> 00:08:55,560
power failures in no circumstance you

00:08:52,020 --> 00:08:57,690
will have a garbled asset in the storage

00:08:55,560 --> 00:09:00,660
so this doesn't prevent against the

00:08:57,690 --> 00:09:03,690
malicious access if your secure storage

00:09:00,660 --> 00:09:06,900
device the physical device itself is

00:09:03,690 --> 00:09:10,470
accessible from the non secure side it

00:09:06,900 --> 00:09:13,200
can't protect against a non security

00:09:10,470 --> 00:09:15,450
just going on rampage and destroying all

00:09:13,200 --> 00:09:18,570
of the assets what it does ensure is

00:09:15,450 --> 00:09:20,280
that none of the assets get exposed so

00:09:18,570 --> 00:09:22,880
you don't you never see the exits in

00:09:20,280 --> 00:09:26,190
plaintext from the non secure side and

00:09:22,880 --> 00:09:29,190
it's non mutable so non secure cannot

00:09:26,190 --> 00:09:31,470
provision a different key and claim it

00:09:29,190 --> 00:09:34,770
to be the actual key for the first

00:09:31,470 --> 00:09:37,340
service and of course we are a custom

00:09:34,770 --> 00:09:37,340
file system

00:09:38,710 --> 00:09:44,420
let's look at the some of the details of

00:09:41,620 --> 00:09:51,860
design details of the individual parts

00:09:44,420 --> 00:09:54,620
of secure Suresh the policy manager is a

00:09:51,860 --> 00:09:56,690
gatekeeper for only accesses so every

00:09:54,620 --> 00:09:59,630
access to secure storage has to go

00:09:56,690 --> 00:10:02,360
through the policy manager and based on

00:09:59,630 --> 00:10:06,740
database it decides who gets to access

00:10:02,360 --> 00:10:09,410
what it is also placeholder for future

00:10:06,740 --> 00:10:12,710
actions if we decide to do a lifecycle

00:10:09,410 --> 00:10:15,140
management because some of these assets

00:10:12,710 --> 00:10:18,260
could be ephemeral they may have a

00:10:15,140 --> 00:10:21,560
limited life cycle and they they might

00:10:18,260 --> 00:10:24,590
be expected to die after some time so if

00:10:21,560 --> 00:10:26,060
you choose to implement lifecycle

00:10:24,590 --> 00:10:30,220
management this is a placeholder for

00:10:26,060 --> 00:10:33,940
that and then secure asset management so

00:10:30,220 --> 00:10:38,740
the assets that we store some of these

00:10:33,940 --> 00:10:42,170
assets which could be cryptographic keys

00:10:38,740 --> 00:10:44,210
they have very tight association with

00:10:42,170 --> 00:10:48,010
the algorithm itself and they have very

00:10:44,210 --> 00:10:50,720
tight restrictions in the sense that

00:10:48,010 --> 00:10:52,820
what in what circumstances they can be

00:10:50,720 --> 00:10:54,170
used what is the requirement on the IV

00:10:52,820 --> 00:10:55,430
and those things are quite quite

00:10:54,170 --> 00:10:58,940
actually controlled by the algorithm

00:10:55,430 --> 00:11:00,980
itself so it might be required to put

00:10:58,940 --> 00:11:04,100
some sort of mechanism in these secured

00:11:00,980 --> 00:11:11,180
storage itself to guard against

00:11:04,100 --> 00:11:12,950
crypto weakness attacks this supposed to

00:11:11,180 --> 00:11:14,780
different use cases the first one is

00:11:12,950 --> 00:11:20,120
direct access is like any other file

00:11:14,780 --> 00:11:22,910
system and the policy table has entries

00:11:20,120 --> 00:11:25,070
for those callers and it decides to find

00:11:22,910 --> 00:11:26,540
near interact is okay or it says no

00:11:25,070 --> 00:11:28,220
you're not allowed to do it alleviated

00:11:26,540 --> 00:11:32,750
right so that's like a typical file

00:11:28,220 --> 00:11:37,220
system the interesting bit is the

00:11:32,750 --> 00:11:41,300
referenced access in this case the

00:11:37,220 --> 00:11:43,610
caller which is app one it never gets to

00:11:41,300 --> 00:11:46,550
see the content in the plaintext

00:11:43,610 --> 00:11:48,140
if you are talking about a key and if F

00:11:46,550 --> 00:11:50,450
one only has a reference

00:11:48,140 --> 00:11:54,830
this it never gets to see the actual

00:11:50,450 --> 00:11:57,440
content of that key which is here the

00:11:54,830 --> 00:12:02,420
way it can use that key is through

00:11:57,440 --> 00:12:05,150
differed or through yeah so it needs to

00:12:02,420 --> 00:12:07,700
make a request to another service which

00:12:05,150 --> 00:12:12,490
can make a read request on the behalf of

00:12:07,700 --> 00:12:15,950
this app one so the example would be

00:12:12,490 --> 00:12:18,830
upon makes a request to this service

00:12:15,950 --> 00:12:22,850
saying that I want to encrypt this block

00:12:18,830 --> 00:12:25,190
of data using this key I don't know what

00:12:22,850 --> 00:12:28,100
that key is but I have a reference which

00:12:25,190 --> 00:12:32,240
is the UUID using that reference could

00:12:28,100 --> 00:12:36,500
you do a encryption for me goes this

00:12:32,240 --> 00:12:39,920
takes that request in then it forwards

00:12:36,500 --> 00:12:42,620
the request for reading the key the

00:12:39,920 --> 00:12:44,390
secure storage now secure solution knows

00:12:42,620 --> 00:12:46,880
that the request is actually coming from

00:12:44,390 --> 00:12:50,660
the crypto but it's on the behalf of

00:12:46,880 --> 00:12:51,400
have one so it doesn't look up in in the

00:12:50,660 --> 00:12:55,100
lookup table

00:12:51,400 --> 00:12:58,280
it does look up for reference access for

00:12:55,100 --> 00:12:59,810
add one and see if the app bonus is

00:12:58,280 --> 00:13:03,050
actually allowed to make that access to

00:12:59,810 --> 00:13:06,740
the referenced access to the key one or

00:13:03,050 --> 00:13:09,140
not and if it is then the key is read by

00:13:06,740 --> 00:13:10,460
the crypto service the crypto service

00:13:09,140 --> 00:13:12,980
performs whatever cryptographic

00:13:10,460 --> 00:13:16,280
cooperation is required and then it

00:13:12,980 --> 00:13:17,990
returns back to the app one which

00:13:16,280 --> 00:13:20,720
started the virtue of event in the first

00:13:17,990 --> 00:13:24,350
place the key part is the key never

00:13:20,720 --> 00:13:26,840
leaves this cryptographic key never

00:13:24,350 --> 00:13:29,720
leaves crypto service is always not

00:13:26,840 --> 00:13:31,610
visible to the application here at the

00:13:29,720 --> 00:13:35,000
same time application was able to make

00:13:31,610 --> 00:13:41,180
use of that resource without actually

00:13:35,000 --> 00:13:44,090
having to directly access it reference

00:13:41,180 --> 00:13:48,380
read reference access is only allowed

00:13:44,090 --> 00:13:54,860
for Adid kind of requests you can't do a

00:13:48,380 --> 00:13:56,780
write on the caller could be in this

00:13:54,860 --> 00:13:58,970
case the caller could be a secured

00:13:56,780 --> 00:13:59,840
partition itself or it could be a non

00:13:58,970 --> 00:14:02,880
security

00:13:59,840 --> 00:14:05,660
depends on the system use case so if a

00:14:02,880 --> 00:14:08,760
secured location is dinner on this side

00:14:05,660 --> 00:14:11,280
it will have to follow the same path to

00:14:08,760 --> 00:14:21,180
get access to the difference access to

00:14:11,280 --> 00:14:26,910
the mission key differentiate between

00:14:21,180 --> 00:14:29,220
different non secure colors or yeah so

00:14:26,910 --> 00:14:31,890
that's a bit loaded question

00:14:29,220 --> 00:14:33,930
one one thing is differentiating between

00:14:31,890 --> 00:14:36,270
the different tasks on the non secure

00:14:33,930 --> 00:14:38,100
side yeah that's slightly easy thing to

00:14:36,270 --> 00:14:41,700
handle because you can say that when a

00:14:38,100 --> 00:14:44,490
request comes in a task ID is associated

00:14:41,700 --> 00:14:46,770
with the request itself so that's how it

00:14:44,490 --> 00:14:49,770
is intimated right now whenever a non

00:14:46,770 --> 00:14:52,950
secure entity makes a request we append

00:14:49,770 --> 00:14:56,040
the the underlying API appends the task

00:14:52,950 --> 00:14:58,350
ID and the lookup is based on the task

00:14:56,040 --> 00:15:02,550
ID that is appended in the request

00:14:58,350 --> 00:15:05,250
itself but when you talk about a non

00:15:02,550 --> 00:15:08,430
secure entity that is not necessarily a

00:15:05,250 --> 00:15:11,820
task it could be a remote entity as well

00:15:08,430 --> 00:15:14,430
so it could be a server trying to talk

00:15:11,820 --> 00:15:17,280
to the device and trying to access

00:15:14,430 --> 00:15:18,980
certain resources or trying to provision

00:15:17,280 --> 00:15:22,590
certain resources on the device that

00:15:18,980 --> 00:15:26,070
gets more complicated because the same

00:15:22,590 --> 00:15:28,860
task could be doing could be acting on

00:15:26,070 --> 00:15:31,970
behalf of multiple servers so there you

00:15:28,860 --> 00:15:34,590
could implement a password-based

00:15:31,970 --> 00:15:36,540
authentication dopant so if you have the

00:15:34,590 --> 00:15:39,540
password you get access to the file if

00:15:36,540 --> 00:15:41,520
you don't you don't but we don't have it

00:15:39,540 --> 00:15:44,330
yet it's basically those things that are

00:15:41,520 --> 00:15:44,330
being debated right now

00:15:46,980 --> 00:15:53,639
a quick look at how the file system is

00:15:49,740 --> 00:15:56,370
almost the secure solution file system

00:15:53,639 --> 00:15:59,399
requires a set of continuous blocks to

00:15:56,370 --> 00:16:01,079
be earmarked for its operation we can

00:15:59,399 --> 00:16:03,320
look at this picture the first two

00:16:01,079 --> 00:16:06,810
blocks are marked as metadata blocks

00:16:03,320 --> 00:16:09,089
everything else is data block if you

00:16:06,810 --> 00:16:11,880
look closer one of these blocks is

00:16:09,089 --> 00:16:15,570
scratchy metadata block and one of the

00:16:11,880 --> 00:16:17,790
data blocks is slash data block I'll

00:16:15,570 --> 00:16:23,760
cover this why we need this you know one

00:16:17,790 --> 00:16:26,610
of the data slides this is a bit more

00:16:23,760 --> 00:16:33,959
detailed look at how the flash file

00:16:26,610 --> 00:16:37,470
system is organized so the metadata

00:16:33,959 --> 00:16:39,779
block it has a metadata header that has

00:16:37,470 --> 00:16:42,180
the authentication parameters for the

00:16:39,779 --> 00:16:46,430
whole metadata block well not the whole

00:16:42,180 --> 00:16:50,190
block metadata information and it has

00:16:46,430 --> 00:16:52,680
certain mechanisms to allow this is this

00:16:50,190 --> 00:16:54,240
header is also used for atomic update

00:16:52,680 --> 00:16:57,269
operation and explain that in one of the

00:16:54,240 --> 00:17:01,110
later slides the next part of the

00:16:57,269 --> 00:17:03,480
metadata is the rock metadata where we

00:17:01,110 --> 00:17:06,410
store information about each block how

00:17:03,480 --> 00:17:09,240
much of free space is available in every

00:17:06,410 --> 00:17:11,370
physical data block and how does the

00:17:09,240 --> 00:17:15,209
mapping from logical block to physical

00:17:11,370 --> 00:17:18,510
block actually happens the next part is

00:17:15,209 --> 00:17:20,760
object metadata this is where you had

00:17:18,510 --> 00:17:22,350
the information about each asset and

00:17:20,760 --> 00:17:26,280
that could be key or hash or whatever

00:17:22,350 --> 00:17:28,650
and this this distance you where a

00:17:26,280 --> 00:17:31,080
certain object object 0 in this case

00:17:28,650 --> 00:17:32,790
where that object is actually stored in

00:17:31,080 --> 00:17:35,929
the physical memory in the face below

00:17:32,790 --> 00:17:38,400
flash and what are its security

00:17:35,929 --> 00:17:44,150
parameters which is initialization

00:17:38,400 --> 00:17:47,010
vector and the authentication code value

00:17:44,150 --> 00:17:49,679
and it's possible that you could have a

00:17:47,010 --> 00:17:54,870
actual object data actually stored in

00:17:49,679 --> 00:17:56,680
the metadata block and this is just a

00:17:54,870 --> 00:17:58,750
placeholder because

00:17:56,680 --> 00:18:01,740
if it is not aligned on that boundary

00:17:58,750 --> 00:18:04,720
then you could have a 20 user space

00:18:01,740 --> 00:18:08,200
the data blocks they essentially just

00:18:04,720 --> 00:18:09,880
store the objects they there's no other

00:18:08,200 --> 00:18:14,820
intelligence in the data block itself

00:18:09,880 --> 00:18:17,320
all it has is a array of random bytes

00:18:14,820 --> 00:18:21,540
the actual information about what those

00:18:17,320 --> 00:18:21,540
random bytes me is it the metadata block

00:18:21,840 --> 00:18:27,720
so is there something that I guess that

00:18:24,430 --> 00:18:31,390
we invented or is this like an existing

00:18:27,720 --> 00:18:34,929
so yeah this is this something I mean

00:18:31,390 --> 00:18:37,660
invented and there are there reasons to

00:18:34,929 --> 00:18:39,309
why we invented as I said one of the

00:18:37,660 --> 00:18:42,730
requirements we set for ourselves is

00:18:39,309 --> 00:18:44,679
scalability and the file systems that we

00:18:42,730 --> 00:18:47,950
looked at we couldn't find it right

00:18:44,679 --> 00:18:50,650
match to it so the option of putting

00:18:47,950 --> 00:18:52,929
something else is there if you were to

00:18:50,650 --> 00:18:55,150
put another file system it's possible to

00:18:52,929 --> 00:18:57,670
do it but at the same time you wanted to

00:18:55,150 --> 00:19:01,360
draw in a solution that seem reasonable

00:18:57,670 --> 00:19:04,600
to implement and which is customized

00:19:01,360 --> 00:19:06,760
doodle customizable enough to scale up

00:19:04,600 --> 00:19:09,630
and down the memory footprint and the

00:19:06,760 --> 00:19:09,630
performance footprint

00:19:11,429 --> 00:19:17,929
is unconstrained venitian because

00:19:19,960 --> 00:19:26,410
the benefit is that we have a very good

00:19:24,820 --> 00:19:28,990
knowledge about what we want to store

00:19:26,410 --> 00:19:30,940
here in this in the data blocks we know

00:19:28,990 --> 00:19:32,650
what need to be stored that the the

00:19:30,940 --> 00:19:35,890
properties of objects that we understood

00:19:32,650 --> 00:19:37,780
is quite clear the assets the key sizes

00:19:35,890 --> 00:19:42,760
are known this unknown the certificate

00:19:37,780 --> 00:19:44,830
sizer size is unknown and by leveraging

00:19:42,760 --> 00:19:47,920
on that knowledge we can generate a very

00:19:44,830 --> 00:19:49,750
efficient flash layout we can define the

00:19:47,920 --> 00:19:52,390
flash layer that the compile time itself

00:19:49,750 --> 00:19:55,210
saying that no I don't need to create a

00:19:52,390 --> 00:19:57,670
runtime metadata block i define at the

00:19:55,210 --> 00:19:59,320
compile time might I define my sense at

00:19:57,670 --> 00:20:02,680
the compile time based on that price

00:19:59,320 --> 00:20:06,010
tactically can put each object in a more

00:20:02,680 --> 00:20:08,310
efficient way and it could be reject

00:20:06,010 --> 00:20:12,580
slightly so that it fits much more nicer

00:20:08,310 --> 00:20:17,080
which was not possible with any existing

00:20:12,580 --> 00:20:19,600
file system without a lot of jumping

00:20:17,080 --> 00:20:23,200
through hoops so constraint device can

00:20:19,600 --> 00:20:25,780
actually have only limited uses which

00:20:23,200 --> 00:20:28,690
will mean that it needs to store only

00:20:25,780 --> 00:20:31,060
two certificates ever so so so that you

00:20:28,690 --> 00:20:34,690
could actually cut down the full for

00:20:31,060 --> 00:20:37,930
flash requirements and because we you

00:20:34,690 --> 00:20:40,450
know need didn't worry about where up

00:20:37,930 --> 00:20:43,390
we're leveling we're leveling like on

00:20:40,450 --> 00:20:45,040
the flash or dinner so most of these

00:20:43,390 --> 00:20:46,810
things are handled by the flash

00:20:45,040 --> 00:20:47,830
technology itself if you're talking

00:20:46,810 --> 00:20:50,800
about the one one of the flash

00:20:47,830 --> 00:20:54,280
technologies but do we have left enough

00:20:50,800 --> 00:20:55,960
placeholders and in the design to

00:20:54,280 --> 00:21:00,120
implement that if you really want to do

00:20:55,960 --> 00:21:00,120
the very early and we management

00:21:03,630 --> 00:21:09,700
yeah so as I said the motivation is

00:21:06,490 --> 00:21:12,990
basically to have the ability to

00:21:09,700 --> 00:21:15,700
customize to a extent where we actually

00:21:12,990 --> 00:21:17,410
where it cannot go beyond that it's just

00:21:15,700 --> 00:21:22,210
that this is the minimum you can have in

00:21:17,410 --> 00:21:24,400
the system and so how do you know the

00:21:22,210 --> 00:21:26,860
predetermined size you said it because

00:21:24,400 --> 00:21:29,230
in a constant device if you are talking

00:21:26,860 --> 00:21:31,090
about IOT devices you know what kind of

00:21:29,230 --> 00:21:33,190
assets you want to store if the use

00:21:31,090 --> 00:21:34,690
cases are limited if you want to have a

00:21:33,190 --> 00:21:36,340
secure communication you know how many

00:21:34,690 --> 00:21:38,230
certificates and keys you need for the

00:21:36,340 --> 00:21:40,210
secure communication if you are do

00:21:38,230 --> 00:21:42,970
provisioning you know what is required

00:21:40,210 --> 00:21:45,580
for the provisioning use case if you

00:21:42,970 --> 00:21:46,720
want to do some content protection you

00:21:45,580 --> 00:21:48,490
know what the content production

00:21:46,720 --> 00:21:51,040
requires in terms of certificates and

00:21:48,490 --> 00:21:54,820
keys and the use cases that you want to

00:21:51,040 --> 00:21:56,830
support on that device it is limited so

00:21:54,820 --> 00:21:58,390
if you know that these these five

00:21:56,830 --> 00:22:00,610
different use cases I need to support on

00:21:58,390 --> 00:22:04,360
device you need to know the storage

00:22:00,610 --> 00:22:06,340
requirement there and having that

00:22:04,360 --> 00:22:08,560
knowledge is is actually quite at what

00:22:06,340 --> 00:22:11,910
is the big advantage because you can

00:22:08,560 --> 00:22:11,910
optimize a lot of things there

00:22:18,110 --> 00:22:23,149
so do you live at a time I cannot go

00:22:21,230 --> 00:22:26,809
through all the flows so I have picked

00:22:23,149 --> 00:22:31,090
few interesting flows the the code flows

00:22:26,809 --> 00:22:31,090
which may be of interest to most of us

00:22:32,440 --> 00:22:37,190
first is the key derivation in the

00:22:35,600 --> 00:22:42,110
current implementation it is a very

00:22:37,190 --> 00:22:45,110
simplistic key derivation pattern take

00:22:42,110 --> 00:22:47,840
the harder unique key mix it with a key

00:22:45,110 --> 00:22:49,510
derivation label throw it to a KDF and

00:22:47,840 --> 00:22:52,519
you know about the secure storage key

00:22:49,510 --> 00:22:56,029
this has a lot of scope for improvement

00:22:52,519 --> 00:22:58,519
this has a lot of scope for getting

00:22:56,029 --> 00:23:01,940
wouldn't want and that's one of the

00:22:58,519 --> 00:23:04,639
slides we'll go through contribution is

00:23:01,940 --> 00:23:08,210
the battery yeah yes yeah so if you have

00:23:04,639 --> 00:23:17,149
ideas about how to make it better more

00:23:08,210 --> 00:23:18,740
advanced please do contribute yeah the

00:23:17,149 --> 00:23:20,779
implementation is actually stopped

00:23:18,740 --> 00:23:27,860
because we don't have any hardware unity

00:23:20,779 --> 00:23:29,720
in but the the whole design is based on

00:23:27,860 --> 00:23:32,809
this assumption that you could have a

00:23:29,720 --> 00:23:34,639
hardware unique key and you could just

00:23:32,809 --> 00:23:37,250
derive a key from there and use that for

00:23:34,639 --> 00:23:39,620
the secure service operation the reason

00:23:37,250 --> 00:23:41,269
you need to have a harder unique key so

00:23:39,620 --> 00:23:42,769
that you cannot take out this storage

00:23:41,269 --> 00:23:45,529
device from what device plug it into

00:23:42,769 --> 00:23:48,799
another device and suddenly you your

00:23:45,529 --> 00:23:50,630
other device is acting as the other

00:23:48,799 --> 00:23:54,850
device so basically gray market

00:23:50,630 --> 00:23:54,850
protection against gray market

00:24:04,120 --> 00:24:11,840
so cortex is the IP about DHEA is not

00:24:08,870 --> 00:24:15,530
really tied to the CPU when you design a

00:24:11,840 --> 00:24:18,890
system it needs to provide a non mutable

00:24:15,530 --> 00:24:21,789
identity identity which is completely

00:24:18,890 --> 00:24:26,049
not changeable by the software or

00:24:21,789 --> 00:24:28,549
through any other attack vectors and

00:24:26,049 --> 00:24:29,929
James I think has some other well yeah I

00:24:28,549 --> 00:24:31,370
was just gonna say yeah if you think

00:24:29,929 --> 00:24:33,320
like in mobile phone to all the chips

00:24:31,370 --> 00:24:35,030
have a unique serial number which is put

00:24:33,320 --> 00:24:37,640
in on the manufacturing process which is

00:24:35,030 --> 00:24:39,860
a actual Hardware unique key but of

00:24:37,640 --> 00:24:42,799
course our development chips that we use

00:24:39,860 --> 00:24:44,419
generic development chips don't have the

00:24:42,799 --> 00:24:49,669
same level of security that you put into

00:24:44,419 --> 00:24:53,510
real production chips the score plucks

00:24:49,669 --> 00:24:56,120
m23 and up thus if his requirement to

00:24:53,510 --> 00:25:00,260
have such a only kill for every

00:24:56,120 --> 00:25:02,059
implementation yeah it's gonna say

00:25:00,260 --> 00:25:04,460
that's a system requirement that

00:25:02,059 --> 00:25:08,510
actually is covered by the TBS a the

00:25:04,460 --> 00:25:11,780
arms standard architecture for producing

00:25:08,510 --> 00:25:14,000
secure systems it's nothing to do with

00:25:11,780 --> 00:25:18,140
the CPU specifically arm in a serial

00:25:14,000 --> 00:25:20,450
number is is but into the Shepherd as

00:25:18,140 --> 00:25:24,799
they're different mechanism in the

00:25:20,450 --> 00:25:27,080
production cycle but so you can produce

00:25:24,799 --> 00:25:29,990
chips without hardware unique key but if

00:25:27,080 --> 00:25:34,299
you want good security at the level that

00:25:29,990 --> 00:25:36,890
the mobile phone operators expect then

00:25:34,299 --> 00:25:43,809
any production devices would put one in

00:25:36,890 --> 00:25:43,809
that it is not mandated by cortex

00:25:49,940 --> 00:25:56,940
yeah I mean cystic is now mandatory for

00:25:54,149 --> 00:25:59,820
all cortex-m for example but have a

00:25:56,940 --> 00:26:02,850
unique identifier not yet that's

00:25:59,820 --> 00:26:07,200
completely independent from the system

00:26:02,850 --> 00:26:08,999
yes it's like any other peripheral in

00:26:07,200 --> 00:26:11,340
the system except for the fact that this

00:26:08,999 --> 00:26:15,230
has to be non mutable for the threat

00:26:11,340 --> 00:26:15,230
vectors you want to predict there it is

00:26:20,060 --> 00:26:25,180
quick I'm not good I'm no excreta

00:26:23,090 --> 00:26:28,010
experts this is just a quick

00:26:25,180 --> 00:26:30,170
introduction to what he actually means

00:26:28,010 --> 00:26:34,310
because we use this concept in the

00:26:30,170 --> 00:26:36,350
design in the ad you have authenticated

00:26:34,310 --> 00:26:38,510
data which is authenticated but not in

00:26:36,350 --> 00:26:41,330
cryptid you have the data that need to

00:26:38,510 --> 00:26:45,380
be encrypted as well then you need to

00:26:41,330 --> 00:26:47,390
feed in a IV value and a key to bind it

00:26:45,380 --> 00:26:50,060
all together the outcome would be

00:26:47,390 --> 00:26:55,190
authentic agent at the encrypted data

00:26:50,060 --> 00:26:58,430
and the reverse authenticated decryption

00:26:55,190 --> 00:26:59,020
where you feel in the data which is same

00:26:58,430 --> 00:27:03,020
as this one

00:26:59,020 --> 00:27:05,780
because it is basically plaintext the

00:27:03,020 --> 00:27:09,860
tag which was generated here the IV

00:27:05,780 --> 00:27:12,620
value is same as this step the encrypted

00:27:09,860 --> 00:27:16,970
data and the key and on the other side

00:27:12,620 --> 00:27:19,010
of the ad logic you have the result of

00:27:16,970 --> 00:27:21,470
the authentication and if that is a

00:27:19,010 --> 00:27:25,250
successful authentication you have the

00:27:21,470 --> 00:27:28,640
data in context as well so if you

00:27:25,250 --> 00:27:34,520
superimpose the secure storage design on

00:27:28,640 --> 00:27:37,700
that same favor the wherever a write

00:27:34,520 --> 00:27:41,030
request comes in for writing any object

00:27:37,700 --> 00:27:43,040
you have the object metadata which

00:27:41,030 --> 00:27:47,270
includes where the object is stored in

00:27:43,040 --> 00:27:51,620
the file system its size and some other

00:27:47,270 --> 00:27:54,200
attributions the content of data itself

00:27:51,620 --> 00:27:57,560
the content of the object itself that

00:27:54,200 --> 00:28:00,710
you want to actually store the IV and

00:27:57,560 --> 00:28:03,830
the key other side you get the

00:28:00,710 --> 00:28:06,610
authentication tag this gets stored in

00:28:03,830 --> 00:28:11,230
the metadata of the object again and

00:28:06,610 --> 00:28:13,700
this gets stored in the data block

00:28:11,230 --> 00:28:15,890
we'll talk about this in in some more

00:28:13,700 --> 00:28:19,910
slides so I think it will become much

00:28:15,890 --> 00:28:22,730
more clear afterwards and the reverse

00:28:19,910 --> 00:28:24,560
for decrypting an object this is also

00:28:22,730 --> 00:28:26,690
the read flow when you're reading an

00:28:24,560 --> 00:28:31,180
object this is the flow that it goes

00:28:26,690 --> 00:28:33,910
through you read the design reads the

00:28:31,180 --> 00:28:36,430
a Mac value and 5e value and the

00:28:33,910 --> 00:28:38,620
metadata associated with the object this

00:28:36,430 --> 00:28:40,390
is all the in terms of the file system

00:28:38,620 --> 00:28:43,800
this is all part of the metadata of the

00:28:40,390 --> 00:28:48,190
file system without data of the file

00:28:43,800 --> 00:28:50,650
this comes from the data block it all

00:28:48,190 --> 00:28:53,190
gets fed into the AES engine for

00:28:50,650 --> 00:28:56,470
authentication authenticated decryption

00:28:53,190 --> 00:28:57,970
and then it tells the engine tells

00:28:56,470 --> 00:29:01,090
whether the authentication passed or not

00:28:57,970 --> 00:29:03,820
and if it did pass then the decrypted

00:29:01,090 --> 00:29:05,440
data in the plaintext and then that

00:29:03,820 --> 00:29:07,540
plaintext data is passed on to the

00:29:05,440 --> 00:29:09,960
caller who requested for the real in the

00:29:07,540 --> 00:29:09,960
first place

00:29:13,760 --> 00:29:20,539
in the boot time this system relies on

00:29:17,769 --> 00:29:22,820
authenticating the metadata block it's

00:29:20,539 --> 00:29:25,429
assumed that if metadata is not tampered

00:29:22,820 --> 00:29:27,590
with it should be okay to go ahead with

00:29:25,429 --> 00:29:29,120
the rest of the system it is still

00:29:27,590 --> 00:29:31,610
possible that the rest of the data

00:29:29,120 --> 00:29:33,950
blocks are mangled or they're tampered

00:29:31,610 --> 00:29:35,899
with but at the good time it doesn't

00:29:33,950 --> 00:29:38,510
care so much about the innocent data it

00:29:35,899 --> 00:29:43,519
just authenticates was there in the

00:29:38,510 --> 00:29:45,889
metadata block which is Mac and IV or

00:29:43,519 --> 00:29:48,500
and this Mac and IV is is stored in the

00:29:45,889 --> 00:29:54,019
metadata headed itself not we are not

00:29:48,500 --> 00:29:56,860
talking about the object ibn this is

00:29:54,019 --> 00:30:00,019
back an IV for the metadata block whole

00:29:56,860 --> 00:30:02,419
data block which is followed by the

00:30:00,019 --> 00:30:05,090
metadata error and the block metadata

00:30:02,419 --> 00:30:08,809
the object metadata and it all gets

00:30:05,090 --> 00:30:11,330
Marshall to get it together with an SSD

00:30:08,809 --> 00:30:13,940
key is fed into the ASD same engine and

00:30:11,330 --> 00:30:16,340
then we get a result whether telling

00:30:13,940 --> 00:30:19,399
whether it's actually authentication has

00:30:16,340 --> 00:30:22,970
actually passed or failed based on that

00:30:19,399 --> 00:30:25,690
a system design can take a different

00:30:22,970 --> 00:30:25,690
route while

00:30:35,780 --> 00:30:43,500
so if is the metadata is tampered with

00:30:39,740 --> 00:30:46,250
this authentication will fail this

00:30:43,500 --> 00:30:50,420
authenticated location process will fail

00:30:46,250 --> 00:30:54,540
because no one else has this key so is

00:30:50,420 --> 00:30:57,660
impossible to generate a pattern of Mac

00:30:54,540 --> 00:31:01,800
and Ivy and the rest of the data which

00:30:57,660 --> 00:31:04,700
matches in the various engine is that

00:31:01,800 --> 00:31:07,080
what you are asking or something else

00:31:04,700 --> 00:31:10,910
okay then there's another aspect which

00:31:07,080 --> 00:31:10,910
is their role but I will talk about that

00:31:14,540 --> 00:31:22,050
yes so I have another and psg sim has a

00:31:19,620 --> 00:31:24,780
weakness where if you use the same IV

00:31:22,050 --> 00:31:27,450
and key combination for one more than

00:31:24,780 --> 00:31:30,780
one data blocks and I guess that's what

00:31:27,450 --> 00:31:32,520
your thirst knows yeah so that comes as

00:31:30,780 --> 00:31:34,740
a package when we do the rollback

00:31:32,520 --> 00:31:36,960
prediction this design doesn't have the

00:31:34,740 --> 00:31:40,080
rollback prediction yet we are doing the

00:31:36,960 --> 00:31:43,400
prototyping for it and it will get

00:31:40,080 --> 00:31:43,400
obscene at some point

00:31:46,540 --> 00:31:54,900
this is a simplified view of how a right

00:31:50,290 --> 00:31:58,870
flow looks like because this has the

00:31:54,900 --> 00:32:01,179
atomic operation built-in then I'd

00:31:58,870 --> 00:32:04,330
request consent the content gets

00:32:01,179 --> 00:32:06,280
encrypted the encrypted content gets

00:32:04,330 --> 00:32:07,990
written to the scratch data block

00:32:06,280 --> 00:32:09,820
remember we talked about this crash data

00:32:07,990 --> 00:32:12,610
block this is where it comes in the

00:32:09,820 --> 00:32:16,120
picture so the new content goes to this

00:32:12,610 --> 00:32:19,090
crash data block the new metadata goes

00:32:16,120 --> 00:32:21,760
to this scratch metadata block once

00:32:19,090 --> 00:32:25,419
these two are programmed the new mac

00:32:21,760 --> 00:32:27,940
value the new authentication type for

00:32:25,419 --> 00:32:32,559
the metadata block gets generated and

00:32:27,940 --> 00:32:35,169
gets programmed the metadata header has

00:32:32,559 --> 00:32:37,059
another thing called swap count which

00:32:35,169 --> 00:32:42,190
basically is this increment encountered

00:32:37,059 --> 00:32:44,410
and and it's authenticated value so in

00:32:42,190 --> 00:32:48,370
case the power failure happened after

00:32:44,410 --> 00:32:50,830
updating this this content it can

00:32:48,370 --> 00:32:53,230
recover back all that recovery happens

00:32:50,830 --> 00:32:56,830
and explained that was I walk through

00:32:53,230 --> 00:33:01,030
the complete flow so the mirror reader

00:32:56,830 --> 00:33:04,059
gets programmed in this block then the

00:33:01,030 --> 00:33:07,230
metadata header gets calculated and

00:33:04,059 --> 00:33:10,570
programmed in this scratch metadata book

00:33:07,230 --> 00:33:13,450
after that the current meta data block

00:33:10,570 --> 00:33:17,950
gets erased these crash metadata blocks

00:33:13,450 --> 00:33:20,530
becomes the active one and then the the

00:33:17,950 --> 00:33:23,530
current data block where the old content

00:33:20,530 --> 00:33:26,580
might have lived gets erased and that's

00:33:23,530 --> 00:33:26,580
when the whole cycle gets finished

00:33:29,080 --> 00:33:38,320
not simplified view it's essentially the

00:33:34,750 --> 00:33:41,890
same flow but it also explains what goes

00:33:38,320 --> 00:33:45,370
where the this was the first step the

00:33:41,890 --> 00:33:48,580
right request came in then the content

00:33:45,370 --> 00:33:52,290
got inflicted the outcome encryption is

00:33:48,580 --> 00:33:55,120
the encrypted object data and the

00:33:52,290 --> 00:33:59,260
authentication parameters which are IV

00:33:55,120 --> 00:34:02,250
and the Mac value say so the first thing

00:33:59,260 --> 00:34:06,670
that gets programmed is the this part

00:34:02,250 --> 00:34:11,140
then the scratch meta block kiss program

00:34:06,670 --> 00:34:13,540
with the object metadata the swap

00:34:11,140 --> 00:34:22,960
counter gets incremented which is part

00:34:13,540 --> 00:34:25,810
of the metadata block header then the so

00:34:22,960 --> 00:34:27,880
the sub Coty's is a slow down here then

00:34:25,810 --> 00:34:30,640
after that we calculate the Mac value

00:34:27,880 --> 00:34:33,970
for the whole block from this to this

00:34:30,640 --> 00:34:38,169
the the Mac value for this new content

00:34:33,970 --> 00:34:42,370
is generated and programmed here after

00:34:38,169 --> 00:34:44,230
this step and then we erase the active

00:34:42,370 --> 00:34:48,580
metadata block here is the active data

00:34:44,230 --> 00:34:52,060
block and it's done now in any of these

00:34:48,580 --> 00:34:53,730
steps if the power failure happens let's

00:34:52,060 --> 00:34:57,520
say the pot fail happened at this point

00:34:53,730 --> 00:34:59,950
at the boot time then b2 metadata blocks

00:34:57,520 --> 00:35:02,890
which may look like valid metadata

00:34:59,950 --> 00:35:04,960
blocks but if the power failure happened

00:35:02,890 --> 00:35:07,330
here there is no Mac to authenticate

00:35:04,960 --> 00:35:09,520
against so whatever value is stored in

00:35:07,330 --> 00:35:11,770
that block will fail against the

00:35:09,520 --> 00:35:15,490
authentication so in that case it will

00:35:11,770 --> 00:35:18,040
it can still go back to the this metal

00:35:15,490 --> 00:35:20,530
block and this is still refers to the

00:35:18,040 --> 00:35:26,140
valid content because we have not yet

00:35:20,530 --> 00:35:28,450
erased this active data block so 0.1 is

00:35:26,140 --> 00:35:32,860
sure that if policy that happens it goes

00:35:28,450 --> 00:35:36,190
back to the eve old content if a power

00:35:32,860 --> 00:35:38,680
failure happens at this point when the

00:35:36,190 --> 00:35:39,200
Mac values actually programmed in this

00:35:38,680 --> 00:35:42,050
fashion

00:35:39,200 --> 00:35:44,540
later block but we will not erased the

00:35:42,050 --> 00:35:46,730
active metadata block at the boot time

00:35:44,540 --> 00:35:49,730
there are two blocks which look alike

00:35:46,730 --> 00:35:53,740
valid metadata blocks they will pass the

00:35:49,730 --> 00:35:58,940
authentication so they both look like

00:35:53,740 --> 00:36:00,950
valid content this where this swap

00:35:58,940 --> 00:36:03,290
counter comes in the picture whichever

00:36:00,950 --> 00:36:06,890
is the newest value is basically the

00:36:03,290 --> 00:36:10,430
latest stuff it is greatest value and

00:36:06,890 --> 00:36:13,880
that is made as the active block that is

00:36:10,430 --> 00:36:19,670
considered as the active block the other

00:36:13,880 --> 00:36:21,710
block gets erased and block this data

00:36:19,670 --> 00:36:25,550
block also gets calculated and gets

00:36:21,710 --> 00:36:29,600
erased so we made the design safe at

00:36:25,550 --> 00:36:33,350
this point after this point is basically

00:36:29,600 --> 00:36:35,660
from this point on us is in a way the

00:36:33,350 --> 00:36:38,240
right operation is complete because the

00:36:35,660 --> 00:36:39,710
other metadata block is not visible from

00:36:38,240 --> 00:36:43,760
that point if so if the power failure

00:36:39,710 --> 00:36:46,640
happens the boot sequence will recognize

00:36:43,760 --> 00:36:49,010
that there is just one data block with a

00:36:46,640 --> 00:36:55,040
data block which is valid and that's

00:36:49,010 --> 00:36:56,990
gets treated as and in the good time it

00:36:55,040 --> 00:36:59,020
ensures that the all these scratch

00:36:56,990 --> 00:37:01,280
blocks are arranged just to be sure

00:36:59,020 --> 00:37:04,610
because it's possible that a power

00:37:01,280 --> 00:37:06,800
failure happen at this at this point in

00:37:04,610 --> 00:37:09,260
which case the metadata block has been

00:37:06,800 --> 00:37:12,530
erased but the data block is still has

00:37:09,260 --> 00:37:14,330
valid content which may be violation of

00:37:12,530 --> 00:37:16,400
some security principles because if some

00:37:14,330 --> 00:37:19,970
content is deleted is probably should be

00:37:16,400 --> 00:37:20,810
diluted in the search device as well so

00:37:19,970 --> 00:37:23,360
just to be sure

00:37:20,810 --> 00:37:27,490
in the boot time both the metadata both

00:37:23,360 --> 00:37:27,490
these fresh blocks get erased again

00:37:30,940 --> 00:37:36,220
so that is all I had in terms of the

00:37:33,640 --> 00:37:45,099
floors let's see how we're doing against

00:37:36,220 --> 00:37:50,440
time yeah so this is the list of api's

00:37:45,099 --> 00:37:53,410
to make access to the secure storage the

00:37:50,440 --> 00:37:56,589
first few pairs are quite filesystem

00:37:53,410 --> 00:38:00,460
like actually all of them are qualified

00:37:56,589 --> 00:38:04,000
quite fuzzy like you if object exists

00:38:00,460 --> 00:38:07,480
exists and the colin has permissions to

00:38:04,000 --> 00:38:09,880
make any request read and write a

00:38:07,480 --> 00:38:11,859
request to that object you get a handle

00:38:09,880 --> 00:38:14,410
and that handle allows you to do the

00:38:11,859 --> 00:38:17,890
further operation to get attributes or

00:38:14,410 --> 00:38:22,859
to be able to Android or do a delete of

00:38:17,890 --> 00:38:22,859
the file

00:38:26,010 --> 00:38:32,260
yes so in the in this design the in this

00:38:30,220 --> 00:38:35,920
file system design is assumed that the

00:38:32,260 --> 00:38:38,220
file system is actually secure storage

00:38:35,920 --> 00:38:41,920
device is actually accessible from the

00:38:38,220 --> 00:38:44,680
secure side but as I explained in the

00:38:41,920 --> 00:38:47,800
first second slide you could as a plug

00:38:44,680 --> 00:38:50,020
in a proxy and that proxy could take

00:38:47,800 --> 00:38:52,450
offload the whole file system operation

00:38:50,020 --> 00:38:54,369
from the ACK Suresh you could have a

00:38:52,450 --> 00:38:58,300
back-end that takes care of the actual

00:38:54,369 --> 00:39:00,130
storage yeah so these appears remain

00:38:58,300 --> 00:39:03,730
this these are the user facing appears

00:39:00,130 --> 00:39:06,579
and this they don't change based on what

00:39:03,730 --> 00:39:09,960
you have underlying hardware what kind

00:39:06,579 --> 00:39:15,550
of topologies we have in your system

00:39:09,960 --> 00:39:19,000
that is transparent to the the circuit

00:39:15,550 --> 00:39:22,390
so this API will do all everything in

00:39:19,000 --> 00:39:35,980
the background and how that is done the

00:39:22,390 --> 00:39:38,349
user does everything is what latency and

00:39:35,980 --> 00:39:41,980
the performance penalty added if I go is

00:39:38,349 --> 00:39:43,480
from secure we have not done a very

00:39:41,980 --> 00:39:46,599
detailed measurement but in this case

00:39:43,480 --> 00:39:48,430
that is not so important because the

00:39:46,599 --> 00:39:52,740
things that we are talking about the

00:39:48,430 --> 00:39:55,569
keys they're not going to be read every

00:39:52,740 --> 00:39:58,869
second it's like if you are doing a TLS

00:39:55,569 --> 00:40:02,050
operation the key is read once when the

00:39:58,869 --> 00:40:04,180
TLS on the non secure side makes a

00:40:02,050 --> 00:40:07,270
connection with the crypto crypto now

00:40:04,180 --> 00:40:09,490
has the key in its own ramp and that

00:40:07,270 --> 00:40:12,040
read operation is done every subsequent

00:40:09,490 --> 00:40:14,079
crypto operation is basically operating

00:40:12,040 --> 00:40:17,500
on the local content which is already a

00:40:14,079 --> 00:40:21,460
service so the runtime performance is

00:40:17,500 --> 00:40:23,700
not that critical from the design point

00:40:21,460 --> 00:40:23,700
of view

00:40:24,120 --> 00:40:29,610
sometimes because then it affects your

00:40:26,550 --> 00:40:31,290
system design you will design which data

00:40:29,610 --> 00:40:39,960
will go to the secret story you will

00:40:31,290 --> 00:40:42,480
have a clear that so in this case you

00:40:39,960 --> 00:40:44,760
write but in this case it was quite

00:40:42,480 --> 00:40:47,820
clear it's called dis between security

00:40:44,760 --> 00:40:50,490
and performance the security of is if

00:40:47,820 --> 00:40:53,880
anything that you want to store has any

00:40:50,490 --> 00:40:56,100
security attribution then no matter what

00:40:53,880 --> 00:40:57,810
the cost is it has to go I live in a

00:40:56,100 --> 00:41:02,400
place where it is safe enough secure

00:40:57,810 --> 00:41:04,530
enough is this morning in a separate

00:41:02,400 --> 00:41:06,270
partition on secure side here and can

00:41:04,530 --> 00:41:08,310
you put it like in a trusted partition

00:41:06,270 --> 00:41:10,470
and isolated from Nava petitions on

00:41:08,310 --> 00:41:12,570
secure site so secure designed it's a

00:41:10,470 --> 00:41:14,430
secure storage designer serf doesn't

00:41:12,570 --> 00:41:17,760
care whether it is part of the trusted

00:41:14,430 --> 00:41:20,130
code base or it's different partition so

00:41:17,760 --> 00:41:23,610
if you have the high level of isolation

00:41:20,130 --> 00:41:26,460
in the SPM it can happily live in a

00:41:23,610 --> 00:41:28,650
completely isolated enrollment as long

00:41:26,460 --> 00:41:31,680
as it's harder a requirement cement so

00:41:28,650 --> 00:41:33,930
if it is directly operating on the flash

00:41:31,680 --> 00:41:36,510
then you can need to be able to access

00:41:33,930 --> 00:41:38,220
the flash device but if there is a proxy

00:41:36,510 --> 00:41:41,840
then it doesn't even care about the

00:41:38,220 --> 00:41:41,840
hardware accessibility

00:41:45,940 --> 00:41:52,640
so in your API that there's no size of

00:41:49,609 --> 00:41:56,990
the reads and writes just handle data

00:41:52,640 --> 00:42:00,170
this kind of hidden boy this yeah so

00:41:56,990 --> 00:42:02,390
this has this part of the structure is

00:42:00,170 --> 00:42:05,119
is like the I awake structure which has

00:42:02,390 --> 00:42:06,410
the details about the size but we have

00:42:05,119 --> 00:42:08,359
to keep in mind the assets we are

00:42:06,410 --> 00:42:13,280
talking about have very fixed properties

00:42:08,359 --> 00:42:14,869
so we are thinking about restricting the

00:42:13,280 --> 00:42:17,000
implementation in a way that you can't

00:42:14,869 --> 00:42:19,339
do partial read and partial right

00:42:17,000 --> 00:42:24,830
because if there's no meaning of the

00:42:19,339 --> 00:42:27,290
impartial read of the key that's an

00:42:24,830 --> 00:42:29,000
option what I'm saying is that having

00:42:27,290 --> 00:42:31,220
this kind of solution allows you to do

00:42:29,000 --> 00:42:34,060
these kind of optimizations we don't

00:42:31,220 --> 00:42:39,800
have it yet but having this in place

00:42:34,060 --> 00:42:43,550
sets up for the future improvements so

00:42:39,800 --> 00:42:47,030
was this API how the reference axis

00:42:43,550 --> 00:42:50,060
titles yeah so very good question the

00:42:47,030 --> 00:42:52,910
reference axis and reference axis never

00:42:50,060 --> 00:42:55,339
goes through that even secure solidify

00:42:52,910 --> 00:42:58,460
at all it will be through another

00:42:55,339 --> 00:43:02,510
service ATI so you you will in effect

00:42:58,460 --> 00:43:05,270
will be calling TFM crypto encrypt it

00:43:02,510 --> 00:43:07,790
uses something so no security and that

00:43:05,270 --> 00:43:12,710
will use the crypto service in turn will

00:43:07,790 --> 00:43:15,020
invoke one of these appears so but this

00:43:12,710 --> 00:43:18,020
reference idea

00:43:15,020 --> 00:43:20,810
the squilsh requested it goes only to

00:43:18,020 --> 00:43:22,760
creep top crypto is an example but you

00:43:20,810 --> 00:43:28,460
can implement another service which is

00:43:22,760 --> 00:43:33,040
allowed to do reference axis on the ID

00:43:28,460 --> 00:43:37,010
of the original ruffler it gets passed

00:43:33,040 --> 00:43:39,830
yes so there are two aspects to it in

00:43:37,010 --> 00:43:41,760
the current isolation current solution

00:43:39,830 --> 00:43:44,610
where we have only one

00:43:41,760 --> 00:43:47,220
only level one isolation the ID is

00:43:44,610 --> 00:43:48,660
passed by the crypto service itself if

00:43:47,220 --> 00:43:52,920
crypto services is the one which is

00:43:48,660 --> 00:43:54,960
doing the referenced access but in we

00:43:52,920 --> 00:43:56,940
are thinking about solutions where it

00:43:54,960 --> 00:43:58,590
can be translated from the critical

00:43:56,940 --> 00:44:03,060
service because all the information is

00:43:58,590 --> 00:44:05,310
available in the trusted code base we

00:44:03,060 --> 00:44:08,400
know which non-security made the call we

00:44:05,310 --> 00:44:11,460
know which secured partition invoke the

00:44:08,400 --> 00:44:13,110
referenced access so all that

00:44:11,460 --> 00:44:16,710
information doesn't need to be actually

00:44:13,110 --> 00:44:21,030
passed on through the API and it's all

00:44:16,710 --> 00:44:23,210
basically the framework can give you all

00:44:21,030 --> 00:44:23,210
this information

00:44:28,130 --> 00:44:37,800
okay so for two questions for your

00:44:32,690 --> 00:44:40,590
perviness say for Rhett operation so to

00:44:37,800 --> 00:44:45,210
have any in the size limitation for

00:44:40,590 --> 00:44:47,780
active or dead block on that scratch to

00:44:45,210 --> 00:44:52,560
the block and the second question is

00:44:47,780 --> 00:44:54,270
where your API to finish the write

00:44:52,560 --> 00:44:58,590
operation do you have any consideration

00:44:54,270 --> 00:45:01,740
consideration to spread the last

00:44:58,590 --> 00:45:04,500
extremis widely into the Hauer um see

00:45:01,740 --> 00:45:09,570
what learn them is what must be the

00:45:04,500 --> 00:45:19,320
adjacent land set for us I am not sure

00:45:09,570 --> 00:45:23,520
if quite I quite got the question okay

00:45:19,320 --> 00:45:26,369
so yes that's lasted a slightly

00:45:23,520 --> 00:45:29,070
different way this question the block

00:45:26,369 --> 00:45:32,760
sizes are usually in the range of four

00:45:29,070 --> 00:45:35,369
k8k 16k and the assets that you want to

00:45:32,760 --> 00:45:38,700
store or in the either they're less than

00:45:35,369 --> 00:45:42,840
4 K or if you're talking about a is keys

00:45:38,700 --> 00:45:49,500
they're multiple of that in fact you did

00:45:42,840 --> 00:45:53,700
power something 16 bytes or 32 byte key

00:45:49,500 --> 00:45:57,869
sake sizes so in effect you can store

00:45:53,700 --> 00:46:02,430
any of the assets realistically in one

00:45:57,869 --> 00:46:07,880
block if your block size is at middle 4

00:46:02,430 --> 00:46:07,880
K so that

00:46:14,740 --> 00:46:22,730
yeah so you know it's and said this is

00:46:19,849 --> 00:46:25,790
designed to get at a very specific need

00:46:22,730 --> 00:46:28,460
the what kind of facets we understood is

00:46:25,790 --> 00:46:31,280
is very deterministic they have a

00:46:28,460 --> 00:46:33,859
certain property in terms of their size

00:46:31,280 --> 00:46:37,640
and in terms of what kind of accesses

00:46:33,859 --> 00:46:39,980
they need to be provided there is a case

00:46:37,640 --> 00:46:42,380
where if you want to store a set which

00:46:39,980 --> 00:46:44,420
is larger than one block the current

00:46:42,380 --> 00:46:46,099
design doesn't allow fragmentation so if

00:46:44,420 --> 00:46:46,520
you have object which is larger than one

00:46:46,099 --> 00:46:49,390
block

00:46:46,520 --> 00:46:52,460
it can't be spread across two blocks and

00:46:49,390 --> 00:46:55,069
because it is it will break the power

00:46:52,460 --> 00:46:56,960
failure safe operation but the solution

00:46:55,069 --> 00:46:59,660
for that is that you've basically Club

00:46:56,960 --> 00:47:03,380
two blocks and treat that as one block

00:46:59,660 --> 00:47:06,280
and that can handle if the block size is

00:47:03,380 --> 00:47:09,520
forget now you can store 4k maximum

00:47:06,280 --> 00:47:09,520
object size

00:47:16,290 --> 00:47:22,290
if it is more than the way yeah but it's

00:47:19,880 --> 00:47:23,790
wasting the rest of the space but if the

00:47:22,290 --> 00:47:27,390
list of the space will be used for

00:47:23,790 --> 00:47:29,670
storing smaller objects see what you're

00:47:27,390 --> 00:47:34,860
deciding at that point is what is your

00:47:29,670 --> 00:47:40,260
one arrays sighs do you have a

00:47:34,860 --> 00:47:44,220
configuration to put one that one page

00:47:40,260 --> 00:47:48,090
into the high-end address and Ilana page

00:47:44,220 --> 00:47:52,680
to the low-energy s to separate them

00:47:48,090 --> 00:47:57,060
what else the the adjacent purchase may

00:47:52,680 --> 00:47:58,770
be wore out by accident

00:47:57,060 --> 00:48:02,520
so I guess you're talking about the very

00:47:58,770 --> 00:48:04,740
early that is probably not such a severe

00:48:02,520 --> 00:48:07,110
problem here because most of the things

00:48:04,740 --> 00:48:09,060
that need to be stored they will be

00:48:07,110 --> 00:48:12,990
provisioned at the provisioning time so

00:48:09,060 --> 00:48:16,070
you're talking about once in maybe few

00:48:12,990 --> 00:48:18,930
days or once in I don't know a few years

00:48:16,070 --> 00:48:20,700
depending upon what kind of update

00:48:18,930 --> 00:48:23,130
operation you want to perform but it's

00:48:20,700 --> 00:48:24,780
not a general-purpose store where you

00:48:23,130 --> 00:48:30,810
are doing thousands of reads and writes

00:48:24,780 --> 00:48:33,240
every second so plus some of the modern

00:48:30,810 --> 00:48:35,370
flash storage devices do the word living

00:48:33,240 --> 00:48:37,880
inside itself so it's basically

00:48:35,370 --> 00:48:40,200
transferred from the programming model

00:48:37,880 --> 00:48:42,620
it's possible to hook in that kind of

00:48:40,200 --> 00:48:45,240
mechanism where you rotate the blocks

00:48:42,620 --> 00:48:46,950
but the current inflamation

00:48:45,240 --> 00:48:49,020
implementation doesn't have that it's

00:48:46,950 --> 00:48:51,870
basically is possible to extend this

00:48:49,020 --> 00:48:54,510
design to take care of we're loading all

00:48:51,870 --> 00:48:58,460
sort of right hooks are there was sort

00:48:54,510 --> 00:48:58,460
of placeholders are there in the design

00:49:00,059 --> 00:49:11,140
yes yes there's contribution well it's

00:49:08,769 --> 00:49:12,970
just a stupid question it's about the

00:49:11,140 --> 00:49:15,249
documentation where do you plan to put

00:49:12,970 --> 00:49:17,200
the documentation on these api's and on

00:49:15,249 --> 00:49:22,390
other API is of the several frameworks

00:49:17,200 --> 00:49:24,700
it's so yes the documentation is in

00:49:22,390 --> 00:49:26,289
review right now it should get up seen

00:49:24,700 --> 00:49:30,970
sometime soon in the different project

00:49:26,289 --> 00:49:33,670
itself we do this offline I just have

00:49:30,970 --> 00:49:34,869
another question about the the you you

00:49:33,670 --> 00:49:37,390
talk about these things being updated

00:49:34,869 --> 00:49:40,150
infrequently what about something like a

00:49:37,390 --> 00:49:42,190
TLS session keyed if you wanted that

00:49:40,150 --> 00:49:43,299
participer sister cross power that would

00:49:42,190 --> 00:49:45,670
be something that would not be updated

00:49:43,299 --> 00:49:47,619
fairly regularly so DNS session keys

00:49:45,670 --> 00:49:50,109
don't need to be actually stored if you

00:49:47,619 --> 00:49:52,269
are talking about the pre authenticated

00:49:50,109 --> 00:49:54,489
sessions that's the one that need to be

00:49:52,269 --> 00:49:57,099
stored but pre authenticated sessions

00:49:54,489 --> 00:49:59,140
don't require they don't for my

00:49:57,099 --> 00:50:01,420
understanding of the TLS they are not

00:49:59,140 --> 00:50:03,369
that frequent so you could have the SKS

00:50:01,420 --> 00:50:07,690
third ones and probably that will allow

00:50:03,369 --> 00:50:10,119
you to the to do the communication 104

00:50:07,690 --> 00:50:12,180
days and then you talk about the non

00:50:10,119 --> 00:50:17,109
preauth indicated their taylor sessions

00:50:12,180 --> 00:50:18,849
all of the keys and certificates are

00:50:17,109 --> 00:50:22,900
ephemeral so they don't need to go into

00:50:18,849 --> 00:50:29,470
flash they can just and no I wear the

00:50:22,900 --> 00:50:33,779
device it's part of again if you find a

00:50:29,470 --> 00:50:33,779
use case here looking for contributions

00:50:38,770 --> 00:50:49,840
yes notice the time it takes to do these

00:50:48,100 --> 00:50:53,080
operations is quite depends upon the

00:50:49,840 --> 00:50:55,090
average you have a hydrogen then the

00:50:53,080 --> 00:50:59,670
architecture itself is quite optimized

00:50:55,090 --> 00:50:59,670
to do security reductions

00:51:01,990 --> 00:51:11,040
okay any last question okay that case

00:51:21,500 --> 00:51:23,560

YouTube URL: https://www.youtube.com/watch?v=5B553r5UipU


