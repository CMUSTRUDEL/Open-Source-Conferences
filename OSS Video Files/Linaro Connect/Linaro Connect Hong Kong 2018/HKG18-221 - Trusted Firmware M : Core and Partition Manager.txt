Title: HKG18-221 - Trusted Firmware M : Core and Partition Manager
Publication date: 2019-05-09
Playlist: Linaro Connect Hong Kong 2018
Description: 
	Session ID: HKG18-221
Session Name: HKG18-221 - Trusted Firmware M : Core and Partition Manager
Speaker: Miklos Balint
Track: LITE


★ Session Summary ★
An overview of the Trusted Firmware M project with an in depth presentation of TF-M core and Secure Partition Manager for a Cortex-M33-based platform. This talk also includes a brief section on TrustZone for ARMv8-M.

_Trusted Firmware M

In October 2017, Arm announced the vision of Platform Security Architecture (PSA) - a common framework to allow everyone in the IoT ecosystem to move forward with stronger, scalable security and greater confidence. There are three key stages to the Platform Security Architecture: Analysis, Architecture and Implementation which are described at https://developer.arm.com/products/architecture/platform-security-architecture.

Trusted Firmware M, i.e. TF-M, is the Arm project to provide an open source reference implementation firmware that will conform to the PSA specification for M-Class devices. Early access to TF-M was released in December 2017 and it is being made public during Linaro Connect. The implementation should be considered a prototype until the PSA specifications reach release state and the code aligns._
---------------------------------------------------
★ Resources ★
Event Page: http://connect.linaro.org/resource/hkg18/hkg18-221/
Presentation: http://connect.linaro.org.s3.amazonaws.com/hkg18/presentations/hkg18-221.pdf
Video: http://connect.linaro.org.s3.amazonaws.com/hkg18/videos/hkg18-221.mp4
 ---------------------------------------------------
★ Event Details ★
Linaro Connect Hong Kong 2018 (HKG18)
19-23 March 2018 
Regal Airport Hotel Hong Kong

---------------------------------------------------
Keyword: LITE
'http://www.linaro.org'
'http://connect.linaro.org'
---------------------------------------------------
Follow us on Social Media
https://www.facebook.com/LinaroOrg
https://www.youtube.com/user/linaroorg?sub_confirmation=1
https://www.linkedin.com/company/1026961
Captions: 
	00:00:04,370 --> 00:00:06,430
you

00:00:14,400 --> 00:00:21,720
hi everyone my name is mukesh Valiant

00:00:17,869 --> 00:00:28,560
I'm part of the trusted firmware M

00:00:21,720 --> 00:00:32,309
project and I will be talking about the

00:00:28,560 --> 00:00:35,940
core and partition manager components

00:00:32,309 --> 00:00:39,270
within that in details after some

00:00:35,940 --> 00:00:42,720
overview and and and some specifics of

00:00:39,270 --> 00:00:52,850
the platform we are targeting with with

00:00:42,720 --> 00:00:55,739
the first iteration of this project so

00:00:52,850 --> 00:01:02,370
as I mentioned I will do a quick

00:00:55,739 --> 00:01:05,729
overview of the project itself James did

00:01:02,370 --> 00:01:10,740
a good overview of trusted firmware

00:01:05,729 --> 00:01:13,710
before lunch and we are just building on

00:01:10,740 --> 00:01:16,649
top of that so I won't be giving you a

00:01:13,710 --> 00:01:18,959
another overview of BSA which is the

00:01:16,649 --> 00:01:23,610
foundation but I will just give you a

00:01:18,959 --> 00:01:27,209
quick overview I will explain for the

00:01:23,610 --> 00:01:30,899
uninitiated the fundamentals of trust

00:01:27,209 --> 00:01:34,849
zone forearm V item the reason for that

00:01:30,899 --> 00:01:38,910
is our primary tired target is create AM

00:01:34,849 --> 00:01:42,599
architecture and after that I will go

00:01:38,910 --> 00:01:45,179
into details of the core and partition

00:01:42,599 --> 00:01:45,780
manager components within transit

00:01:45,179 --> 00:01:55,590
vampire

00:01:45,780 --> 00:01:59,489
um so overview VSA were had a public

00:01:55,590 --> 00:02:02,099
launch late last year and engineering

00:01:59,489 --> 00:02:07,580
work of course started earlier on that

00:02:02,099 --> 00:02:11,130
and PSA is a set of specs and

00:02:07,580 --> 00:02:14,580
implementation the implementation is

00:02:11,130 --> 00:02:18,480
planning a reference implementation for

00:02:14,580 --> 00:02:22,250
PSA is planned to be trusted firmware M

00:02:18,480 --> 00:02:22,250
or DFM in short

00:02:22,590 --> 00:02:31,329
as again referring back to James

00:02:26,319 --> 00:02:35,890
James's presentation it's a it's an

00:02:31,329 --> 00:02:39,760
evolution I will try to highlight where

00:02:35,890 --> 00:02:47,940
we are and where we are going with that

00:02:39,760 --> 00:02:50,530
this year so PSA and TFM PSA is an

00:02:47,940 --> 00:02:53,260
architecture definition addressing

00:02:50,530 --> 00:02:54,190
security requirements for a range of

00:02:53,260 --> 00:02:58,209
platforms

00:02:54,190 --> 00:03:01,690
it is a platform independent definition

00:02:58,209 --> 00:03:06,900
it it focuses on the security

00:03:01,690 --> 00:03:09,489
requirements and there are no

00:03:06,900 --> 00:03:15,150
implementation details it allows for

00:03:09,489 --> 00:03:19,290
various implementations and of course it

00:03:15,150 --> 00:03:24,269
it's the aim is for it to be generic

00:03:19,290 --> 00:03:27,250
across all arm architectures eventually

00:03:24,269 --> 00:03:31,690
it's at the start of that road and and

00:03:27,250 --> 00:03:36,599
the first the first iteration focuses on

00:03:31,690 --> 00:03:40,629
m-class due to very various reasons and

00:03:36,599 --> 00:03:45,180
we are aiming to provide a reference

00:03:40,629 --> 00:03:49,660
implementation of PSA for m+ CPUs

00:03:45,180 --> 00:03:55,150
because none currently exists in that

00:03:49,660 --> 00:03:59,699
space we are covering BSA specification

00:03:55,150 --> 00:04:02,790
requirements the goal is for to focus on

00:03:59,699 --> 00:04:07,480
details and to provide a usable

00:04:02,790 --> 00:04:11,859
implementation the first iteration is

00:04:07,480 --> 00:04:15,310
PSA level 1 isolation I will explain

00:04:11,859 --> 00:04:17,859
what that means in particular but it

00:04:15,310 --> 00:04:24,039
means a simple isolation of the secure

00:04:17,859 --> 00:04:27,190
and non-secure domains and we set the

00:04:24,039 --> 00:04:28,689
scope for an arm via Tom mainline and

00:04:27,190 --> 00:04:33,339
baseline implement

00:04:28,689 --> 00:04:35,529
for trusted firm param of course there's

00:04:33,339 --> 00:04:38,559
an incremental support for higher

00:04:35,529 --> 00:04:43,529
isolation profiles and long-term plan

00:04:38,559 --> 00:04:49,989
for addressing other course as well so

00:04:43,529 --> 00:04:52,029
TFM framework DFM framework is it

00:04:49,989 --> 00:04:55,749
includes a lot of things it includes

00:04:52,029 --> 00:04:59,739
secure boot loader it includes a secure

00:04:55,749 --> 00:05:02,589
system initialization it includes a

00:04:59,739 --> 00:05:05,570
partition manager that manages secure

00:05:02,589 --> 00:05:07,860
partitions and a non secure partition

00:05:05,570 --> 00:05:11,259
[Music]

00:05:07,860 --> 00:05:16,269
the intention is for it to contain some

00:05:11,259 --> 00:05:20,349
root of trust services and functions non

00:05:16,269 --> 00:05:22,869
secure api's built environment destitute

00:05:20,349 --> 00:05:27,249
and a host of other things that will

00:05:22,869 --> 00:05:34,089
make life easier so it is a framework

00:05:27,249 --> 00:05:37,629
that encompasses a lot of things but of

00:05:34,089 --> 00:05:41,649
course as any project we have to start

00:05:37,629 --> 00:05:43,679
somewhere and we couldn't take on the

00:05:41,649 --> 00:05:48,279
whole of PSA the whole architecture

00:05:43,679 --> 00:05:50,619
enough for in one go because that's two

00:05:48,279 --> 00:05:53,050
largest cope and it's actually a scope

00:05:50,619 --> 00:05:55,899
that's still evolving and it will always

00:05:53,050 --> 00:06:02,439
be evolving because that's how security

00:05:55,899 --> 00:06:04,569
is so we made some very stringent

00:06:02,439 --> 00:06:08,800
restrictions in the first prototype

00:06:04,569 --> 00:06:12,129
round just to have something working and

00:06:08,800 --> 00:06:15,219
the first restriction was that we made

00:06:12,129 --> 00:06:19,209
the secure processing the environment

00:06:15,219 --> 00:06:23,079
non reentrant which practically means

00:06:19,209 --> 00:06:24,909
that one secure function is being

00:06:23,079 --> 00:06:28,360
serviced at a time so there is no

00:06:24,909 --> 00:06:33,610
preemption within the secure processing

00:06:28,360 --> 00:06:37,659
environment initially we are also

00:06:33,610 --> 00:06:39,080
deprioritize a D prioritizing all non

00:06:37,659 --> 00:06:41,990
secure functionality

00:06:39,080 --> 00:06:50,030
while executing a secure function and

00:06:41,990 --> 00:06:51,800
this is to limit the scope of of attack

00:06:50,030 --> 00:06:54,199
vectors that we the threat model

00:06:51,800 --> 00:06:57,250
basically to limit the threat model

00:06:54,199 --> 00:07:01,219
space that that we have to investigate

00:06:57,250 --> 00:07:05,629
we are of course working on on loosening

00:07:01,219 --> 00:07:08,419
that requirement was a it's it's a it's

00:07:05,629 --> 00:07:12,800
a this was a first assumption that we

00:07:08,419 --> 00:07:16,550
made another constraint that we made is

00:07:12,800 --> 00:07:21,199
that a secure partition which is

00:07:16,550 --> 00:07:25,099
described in PS a as a as a standalone

00:07:21,199 --> 00:07:28,909
execution thread we actually defined it

00:07:25,099 --> 00:07:32,199
as a set of secure functions a library

00:07:28,909 --> 00:07:36,800
of secure functions that don't have a

00:07:32,199 --> 00:07:39,139
state as such and and and it's not

00:07:36,800 --> 00:07:41,300
threaded in the classical sense you

00:07:39,139 --> 00:07:46,520
don't have the be infinite loop and and

00:07:41,300 --> 00:07:49,039
and such things as a first target we

00:07:46,520 --> 00:07:53,719
don't have sandboxing within the

00:07:49,039 --> 00:07:56,779
security execution environment and which

00:07:53,719 --> 00:08:03,020
is equivalent to PSA level 1 isolation

00:07:56,779 --> 00:08:09,620
and one specific target that we said was

00:08:03,020 --> 00:08:13,940
that we have to make DFM non secure OS

00:08:09,620 --> 00:08:17,089
agnostic which means that we don't want

00:08:13,940 --> 00:08:22,509
to set expectations on what's running on

00:08:17,089 --> 00:08:25,509
the non secure side we want that to be

00:08:22,509 --> 00:08:28,969
customer specific application specific

00:08:25,509 --> 00:08:35,269
requirement specific it can be bare

00:08:28,969 --> 00:08:38,479
metal it can be an artist and we we have

00:08:35,269 --> 00:08:42,260
of course investigated several specifics

00:08:38,479 --> 00:08:47,660
but the framework itself is aiming to be

00:08:42,260 --> 00:08:49,900
agnostic we are focusing on v8 and why

00:08:47,660 --> 00:08:52,540
because it has a goo

00:08:49,900 --> 00:08:57,370
set of security features and we wanted

00:08:52,540 --> 00:09:00,130
to trial all of those and and provide a

00:08:57,370 --> 00:09:05,520
reference implementation for trust zone

00:09:00,130 --> 00:09:09,550
for PA time which is also waiting to be

00:09:05,520 --> 00:09:11,800
used in such a scenario in a

00:09:09,550 --> 00:09:16,600
comprehensive solution and we are trying

00:09:11,800 --> 00:09:20,880
to do that yes as I mentioned we want a

00:09:16,600 --> 00:09:23,200
whole working solution which includes

00:09:20,880 --> 00:09:27,100
reference implementation a reference

00:09:23,200 --> 00:09:30,310
secure service a secure partition a

00:09:27,100 --> 00:09:37,120
secure storage solution which has a non

00:09:30,310 --> 00:09:40,150
secure processing environment API and we

00:09:37,120 --> 00:09:43,480
also have a bootloader implementation

00:09:40,150 --> 00:09:46,210
which roughly corresponds to via - in

00:09:43,480 --> 00:09:49,050
the a-class devices in the a-class

00:09:46,210 --> 00:09:52,180
trusted firmware solution

00:09:49,050 --> 00:09:56,650
these last two items will be discussed

00:09:52,180 --> 00:10:01,420
in their separate sessions later so an

00:09:56,650 --> 00:10:05,320
overview of trust zone for v8 am I'm

00:10:01,420 --> 00:10:08,290
doing this with the assumption that most

00:10:05,320 --> 00:10:10,330
people are if they are familiar we trust

00:10:08,290 --> 00:10:14,020
them they are familiar we trust them for

00:10:10,330 --> 00:10:16,390
a class and and perhaps not so much for

00:10:14,020 --> 00:10:20,380
EM class so it's good to have an

00:10:16,390 --> 00:10:23,680
overview on v8 I'm architecture includes

00:10:20,380 --> 00:10:28,270
an optional security extension it's

00:10:23,680 --> 00:10:30,730
branded as trust zone for VA time it's a

00:10:28,270 --> 00:10:34,390
similar concept it's it has a similar

00:10:30,730 --> 00:10:39,520
purpose as trust zone for a class but

00:10:34,390 --> 00:10:44,160
due to the specifics and and and

00:10:39,520 --> 00:10:48,100
differences in AM class versus a class

00:10:44,160 --> 00:10:50,740
the there happens to be some differences

00:10:48,100 --> 00:10:52,810
in in the way it's implemented in in in

00:10:50,740 --> 00:10:55,330
the way it's adjusted to the hardware

00:10:52,810 --> 00:10:57,940
specifics but the goal is the same to

00:10:55,330 --> 00:11:01,990
provide secure software that is highly

00:10:57,940 --> 00:11:04,330
trusted secure software has

00:11:01,990 --> 00:11:06,760
access to more hardware resources system

00:11:04,330 --> 00:11:12,450
resources and it is protected from

00:11:06,760 --> 00:11:16,620
access from untrusted code and and and

00:11:12,450 --> 00:11:25,390
memory and and execution state are

00:11:16,620 --> 00:11:28,839
isolated so the VA time security

00:11:25,390 --> 00:11:31,000
extension provides two security domains

00:11:28,839 --> 00:11:40,600
for the code to run in secure and

00:11:31,000 --> 00:11:43,649
non-secure and hardware so it's very

00:11:40,600 --> 00:11:46,899
important to understand that hardware

00:11:43,649 --> 00:11:49,540
isolation is the foundation of trusted

00:11:46,899 --> 00:11:54,880
firmware a city yes it has to be the

00:11:49,540 --> 00:11:57,880
foundation of any isolation model the

00:11:54,880 --> 00:12:03,010
debugger can be blocked from accessing a

00:11:57,880 --> 00:12:07,690
secure state hardware accesses have to

00:12:03,010 --> 00:12:10,720
be controlled in security state and we

00:12:07,690 --> 00:12:14,079
have to duplicate resources so that the

00:12:10,720 --> 00:12:16,750
non secure environment doesn't feel

00:12:14,079 --> 00:12:22,300
restricted from a generic use case point

00:12:16,750 --> 00:12:26,970
of view and the baseline for that is the

00:12:22,300 --> 00:12:30,130
arm v7m which has to execution states

00:12:26,970 --> 00:12:33,010
application code is run in thread mode

00:12:30,130 --> 00:12:34,899
and there's an exec exception code which

00:12:33,010 --> 00:12:40,510
is run in handler mode

00:12:34,899 --> 00:12:43,270
there can be two stacks used and this

00:12:40,510 --> 00:12:46,779
has to be extended force to provide

00:12:43,270 --> 00:12:51,940
security model and so v8 m introduced

00:12:46,779 --> 00:12:55,060
new states basically mirroring both

00:12:51,940 --> 00:12:59,820
execution states in a non secure and a

00:12:55,060 --> 00:13:02,020
secure version so now we have four

00:12:59,820 --> 00:13:04,270
possible execution states

00:13:02,020 --> 00:13:06,550
non secure thread mode non secure

00:13:04,270 --> 00:13:11,470
handler mode and sack your thread mode

00:13:06,550 --> 00:13:13,470
secure handler mode and B stack pointer

00:13:11,470 --> 00:13:17,250
can be any of you

00:13:13,470 --> 00:13:21,360
we'll stack pointers so so we can have

00:13:17,250 --> 00:13:27,990
for concurrent contacts running on the

00:13:21,360 --> 00:13:30,180
CPU in addition to these new States

00:13:27,990 --> 00:13:36,840
introduced there are some resources

00:13:30,180 --> 00:13:39,630
duplicated to allow for context

00:13:36,840 --> 00:13:41,690
switching between state switching

00:13:39,630 --> 00:13:44,400
between secure and non-secure so

00:13:41,690 --> 00:13:47,490
dedicated resources are provided like

00:13:44,400 --> 00:13:49,380
memory protection units are are banked

00:13:47,490 --> 00:13:52,770
between the two states there's a non

00:13:49,380 --> 00:13:57,540
secure MPU and a secure ramp you they

00:13:52,770 --> 00:14:02,310
have their own Cystic and of course the

00:13:57,540 --> 00:14:04,680
secure domain can configure whether a

00:14:02,310 --> 00:14:10,800
particular interrupt is associated with

00:14:04,680 --> 00:14:15,300
secure state or non secure state coding

00:14:10,800 --> 00:14:20,580
between security states was designed to

00:14:15,300 --> 00:14:22,830
be low latency low overhead you know

00:14:20,580 --> 00:14:26,190
this is different from a class because

00:14:22,830 --> 00:14:29,250
in a class security state switching is

00:14:26,190 --> 00:14:34,200
always associated with exception levels

00:14:29,250 --> 00:14:36,930
and and and exception handling here it

00:14:34,200 --> 00:14:39,210
was made easier designed to be easier in

00:14:36,930 --> 00:14:43,800
Hardware with simple function calls

00:14:39,210 --> 00:14:47,400
either in the init read mode directly or

00:14:43,800 --> 00:14:51,390
in exception mode a simple function

00:14:47,400 --> 00:14:54,720
called from non secure handler mode

00:14:51,390 --> 00:14:59,430
would result in under specific

00:14:54,720 --> 00:15:02,940
circumstances executing in secure

00:14:59,430 --> 00:15:07,020
handler mode of course several

00:15:02,940 --> 00:15:10,710
restrictions apply to make the

00:15:07,020 --> 00:15:13,050
transition safe and secure so only a

00:15:10,710 --> 00:15:18,240
subset of the secure code is callable

00:15:13,050 --> 00:15:21,960
from non secure there are specific there

00:15:18,240 --> 00:15:25,830
is one specific instruction in the CPU

00:15:21,960 --> 00:15:28,350
that's a secure gateway instruction and

00:15:25,830 --> 00:15:33,420
the only entry point permitted to be

00:15:28,350 --> 00:15:35,460
code from non-secure and another

00:15:33,420 --> 00:15:37,710
important aspect is that the non-secure

00:15:35,460 --> 00:15:40,710
code does not need to be aware that it's

00:15:37,710 --> 00:15:42,870
calling a secured function so it can be

00:15:40,710 --> 00:15:49,830
wholly transparent from the non secure

00:15:42,870 --> 00:15:54,710
application point of view it's very

00:15:49,830 --> 00:15:58,460
important to note that while in a class

00:15:54,710 --> 00:16:01,050
there is a memory management unit

00:15:58,460 --> 00:16:04,560
virtual memory address spaces can be

00:16:01,050 --> 00:16:08,700
defined there is no MMU in am class we

00:16:04,560 --> 00:16:13,260
have a only a memory protection unit so

00:16:08,700 --> 00:16:16,110
basically all security definitions are

00:16:13,260 --> 00:16:19,350
mapped to the address space we have a

00:16:16,110 --> 00:16:23,430
satyr dress space and every memory

00:16:19,350 --> 00:16:26,400
address can be associated with one of

00:16:23,430 --> 00:16:30,300
three possible attributes either non

00:16:26,400 --> 00:16:37,410
secure or secure at me within secure it

00:16:30,300 --> 00:16:40,140
can be non secure callable so every code

00:16:37,410 --> 00:16:43,220
from the non secure domain has to land

00:16:40,140 --> 00:16:48,030
in non secure codable secure memory

00:16:43,220 --> 00:16:51,330
address and from then it can branch into

00:16:48,030 --> 00:16:58,550
secure memory while the return path is

00:16:51,330 --> 00:17:03,450
simpler the whole memory is divided into

00:16:58,550 --> 00:17:07,440
secure and non-secure ranges so every

00:17:03,450 --> 00:17:10,350
memory address has one of the attributes

00:17:07,440 --> 00:17:15,660
either secure non secure callable secure

00:17:10,350 --> 00:17:20,610
or non secure attribute and there are

00:17:15,660 --> 00:17:22,800
two components in the one component in

00:17:20,610 --> 00:17:25,770
the core and one component outside the

00:17:22,800 --> 00:17:32,940
core which define

00:17:25,770 --> 00:17:36,300
and the deep memory address associations

00:17:32,940 --> 00:17:41,840
and always there are two components

00:17:36,300 --> 00:17:41,840
always the strictest attribute applies

00:17:42,170 --> 00:17:50,070
of course the security attributes have

00:17:46,650 --> 00:17:52,380
to be extended to the whole system we

00:17:50,070 --> 00:17:55,620
want to be able to control multiple

00:17:52,380 --> 00:17:59,250
masters some might not be security of

00:17:55,620 --> 00:18:02,520
our trust zone also includes system IP

00:17:59,250 --> 00:18:05,460
to handle those kinds of scenarios but I

00:18:02,520 --> 00:18:11,130
won't go into details of each and every

00:18:05,460 --> 00:18:13,620
one of those and for example there is a

00:18:11,130 --> 00:18:19,400
reference implementation in the calling

00:18:13,620 --> 00:18:21,930
SSE 200 sub system where all of these

00:18:19,400 --> 00:18:29,370
master side and slave side trust zone

00:18:21,930 --> 00:18:39,470
components can be observed are there any

00:18:29,370 --> 00:18:39,470
questions - VA time security extension

00:18:40,400 --> 00:18:49,160
ok then we can come back to that at the

00:18:44,850 --> 00:18:55,010
end if needed but then I will proceed

00:18:49,160 --> 00:18:58,010
so about TFM core and partition manager

00:18:55,010 --> 00:18:58,010
so

00:19:00,600 --> 00:19:08,670
this diagram shows an overview of the

00:19:04,860 --> 00:19:11,010
runtime environment intra the way we

00:19:08,670 --> 00:19:13,890
modeled it entrusted firmware this is

00:19:11,010 --> 00:19:18,990
trusted firmware M this is highly

00:19:13,890 --> 00:19:21,860
similar to the PSA definition we have we

00:19:18,990 --> 00:19:26,790
have our own matching names

00:19:21,860 --> 00:19:28,440
and-and-and-and-and components of course

00:19:26,790 --> 00:19:31,410
the bootloader is not included because

00:19:28,440 --> 00:19:36,270
this is the runtime view of the system

00:19:31,410 --> 00:19:38,910
and and TFM cord has several features

00:19:36,270 --> 00:19:42,750
basic features that it has to provide a

00:19:38,910 --> 00:19:47,670
secure system in it secure function call

00:19:42,750 --> 00:19:52,190
routing so so it has to be involved in

00:19:47,670 --> 00:19:55,980
the transition from non secure to secure

00:19:52,190 --> 00:20:00,440
domain and it has a partition manager

00:19:55,980 --> 00:20:03,330
which governs isolation between

00:20:00,440 --> 00:20:07,440
partitions both the non secure partition

00:20:03,330 --> 00:20:11,190
and the secure partitions potentially so

00:20:07,440 --> 00:20:17,460
we are enforcing isolation as well there

00:20:11,190 --> 00:20:20,250
are some components which will be

00:20:17,460 --> 00:20:22,830
planned to be part of the f-m core but

00:20:20,250 --> 00:20:25,490
are not ready yet so it as I mentioned

00:20:22,830 --> 00:20:25,490
it's a work in progress

00:20:25,910 --> 00:20:33,000
scheduling between secure partitions

00:20:29,540 --> 00:20:35,220
secure isolation for for for higher

00:20:33,000 --> 00:20:38,420
levels of isolation when secure

00:20:35,220 --> 00:20:41,940
partitions are isolated from one another

00:20:38,420 --> 00:20:46,380
crash handling drivers irq handling

00:20:41,940 --> 00:20:49,020
there's a host of functions that are in

00:20:46,380 --> 00:20:51,840
the works or or or need to be in the

00:20:49,020 --> 00:20:56,880
works and and which will be are planned

00:20:51,840 --> 00:21:00,600
to be implemented later so let's go

00:20:56,880 --> 00:21:09,420
through an example use case so that I

00:21:00,600 --> 00:21:13,360
can showcase how DFM defines a secure

00:21:09,420 --> 00:21:15,580
handling routing and and it's a quite

00:21:13,360 --> 00:21:17,080
simple use case let's say we have a

00:21:15,580 --> 00:21:19,540
sense or we have an application

00:21:17,080 --> 00:21:23,260
monitoring that sense or and it once

00:21:19,540 --> 00:21:26,380
it's uses an IP stack to send the sensor

00:21:23,260 --> 00:21:30,120
data over an encrypted Channel TLS

00:21:26,380 --> 00:21:35,020
connection to a remote server

00:21:30,120 --> 00:21:40,090
now of course TLS provides encryption of

00:21:35,020 --> 00:21:44,230
the IP stream it uses a secure crypto

00:21:40,090 --> 00:21:46,420
service to to provide encryption and

00:21:44,230 --> 00:21:50,080
decryption of the communication channel

00:21:46,420 --> 00:21:53,950
and that is because we want to use a

00:21:50,080 --> 00:21:56,350
secret we want to use credentials stored

00:21:53,950 --> 00:21:58,630
in the secure domain for that

00:21:56,350 --> 00:22:00,550
communication and we don't we want to

00:21:58,630 --> 00:22:06,010
provide all the security attributes

00:22:00,550 --> 00:22:10,360
needed for such a channel and so what

00:22:06,010 --> 00:22:12,880
happens and we go grab gradually step by

00:22:10,360 --> 00:22:16,179
step through all of the isolation

00:22:12,880 --> 00:22:20,250
boundaries in the system so we have a

00:22:16,179 --> 00:22:24,130
non secure thread calling the sense or

00:22:20,250 --> 00:22:28,380
it wants to and we have a non secure

00:22:24,130 --> 00:22:31,480
thread one initiating the IP

00:22:28,380 --> 00:22:36,429
communication so it wants to call crypto

00:22:31,480 --> 00:22:39,309
service to encode packet for example it

00:22:36,429 --> 00:22:44,350
has to call the non secure OS and within

00:22:39,309 --> 00:22:48,370
that the TFM library which is in no

00:22:44,350 --> 00:22:52,240
secure Handler mode which provides a

00:22:48,370 --> 00:22:55,540
lock for the non secure side this is to

00:22:52,240 --> 00:23:02,500
ensure what I mentioned previously that

00:22:55,540 --> 00:23:06,040
we are only serving a single request for

00:23:02,500 --> 00:23:09,190
a secure function at a time so so these

00:23:06,040 --> 00:23:13,450
two locks provide a one at a time

00:23:09,190 --> 00:23:16,360
service for for non secure requests the

00:23:13,450 --> 00:23:20,289
DFM library on the non secure side cause

00:23:16,360 --> 00:23:23,830
a secure privileged handler that

00:23:20,289 --> 00:23:26,769
locks a non-blocking lock it saves the

00:23:23,830 --> 00:23:29,740
non-secure context of course it performs

00:23:26,769 --> 00:23:34,840
a sanity check on the request so it

00:23:29,740 --> 00:23:38,980
checks the the validity of the request

00:23:34,840 --> 00:23:41,230
it sets up secure partition context it

00:23:38,980 --> 00:23:49,289
disables non secure processing

00:23:41,230 --> 00:23:54,480
environment and then it executes a

00:23:49,289 --> 00:23:57,039
secure partition secure function in a

00:23:54,480 --> 00:24:01,210
privileged around privileged thread

00:23:57,039 --> 00:24:03,850
depending on the isolation level so

00:24:01,210 --> 00:24:08,470
eventually the crypto operation is

00:24:03,850 --> 00:24:11,559
performed on the return path it's quite

00:24:08,470 --> 00:24:19,320
simple the crypto service fields the

00:24:11,559 --> 00:24:25,990
return buffer will be encoded IP packet

00:24:19,320 --> 00:24:27,789
it returns to the TFM core component in

00:24:25,990 --> 00:24:31,210
secure handler mode

00:24:27,789 --> 00:24:34,059
which saves the secure partition context

00:24:31,210 --> 00:24:37,440
for the crypto service it restores the

00:24:34,059 --> 00:24:40,149
non secure context unlocks the lock and

00:24:37,440 --> 00:24:43,000
enables the non secure processing

00:24:40,149 --> 00:24:47,860
environment and of course going all the

00:24:43,000 --> 00:24:52,330
way back we unwind everything until the

00:24:47,860 --> 00:24:57,340
non secure thread can then send by its

00:24:52,330 --> 00:24:59,700
IP stack the message to the remote

00:24:57,340 --> 00:24:59,700
server

00:25:01,080 --> 00:25:10,389
now the how more details of the how we

00:25:05,769 --> 00:25:13,179
do the isolation between the components

00:25:10,389 --> 00:25:16,840
this is what I've talked about before

00:25:13,179 --> 00:25:19,929
these are the this is the memory layout

00:25:16,840 --> 00:25:22,990
or address space layout provided by v8n

00:25:19,929 --> 00:25:30,710
and we are utilizing this as a baseline

00:25:22,990 --> 00:25:37,559
for for defining the various

00:25:30,710 --> 00:25:42,120
address spaces that TFM is using and so

00:25:37,559 --> 00:25:45,600
for a PSA level one isolation this is an

00:25:42,120 --> 00:25:47,610
example address space layout you don't

00:25:45,600 --> 00:25:51,299
need to me read everything on the right

00:25:47,610 --> 00:25:56,309
side I just wanted to highlight that we

00:25:51,299 --> 00:25:58,860
have a a non-secure address space we

00:25:56,309 --> 00:26:05,070
have a secure address space with some

00:25:58,860 --> 00:26:08,340
non secure callable ranges and then of

00:26:05,070 --> 00:26:12,149
course in the india data segment on in

00:26:08,340 --> 00:26:16,440
in an ashram we have also no secure and

00:26:12,149 --> 00:26:21,149
secure what we also need to control is

00:26:16,440 --> 00:26:22,769
peripheral access so again non secure

00:26:21,149 --> 00:26:27,690
and secure peripherals need to be

00:26:22,769 --> 00:26:31,320
predefined and and DFM core has to set

00:26:27,690 --> 00:26:36,149
up the right access policies for

00:26:31,320 --> 00:26:41,850
peripherals as well so partition manager

00:26:36,149 --> 00:26:43,620
has to create and maintain a database of

00:26:41,850 --> 00:26:46,710
all the secure partitions that we're

00:26:43,620 --> 00:26:50,250
supporting in a particular system it has

00:26:46,710 --> 00:26:53,669
to setup the isolation boundaries in

00:26:50,250 --> 00:26:57,740
this case a single isolation boundary

00:26:53,669 --> 00:27:01,889
with between non secure and secure

00:26:57,740 --> 00:27:04,500
address space ranges it has to prepare

00:27:01,889 --> 00:27:09,659
the the execution context for a secure

00:27:04,500 --> 00:27:12,330
partition during a function call and in

00:27:09,659 --> 00:27:18,149
case of asynchronous events which we

00:27:12,330 --> 00:27:21,659
don't support yet but are we don't have

00:27:18,149 --> 00:27:25,139
support released for those yet but we

00:27:21,659 --> 00:27:27,059
are it's a work in progress in case of

00:27:25,139 --> 00:27:32,090
asynchronous events in the system we

00:27:27,059 --> 00:27:34,490
have to keep track of states of various

00:27:32,090 --> 00:27:37,580
components various partitions in this

00:27:34,490 --> 00:27:41,480
system and of course partition manager

00:27:37,580 --> 00:27:45,890
relies on v8 and trust zone components

00:27:41,480 --> 00:27:53,780
to provide the isolation within the

00:27:45,890 --> 00:27:56,450
address space now if we so PS a

00:27:53,780 --> 00:28:01,660
discusses multiple isolation profiles

00:27:56,450 --> 00:28:05,240
ice isolation levels and we have to be

00:28:01,660 --> 00:28:08,960
aware of this and TFM has to provide a

00:28:05,240 --> 00:28:15,290
solution for each of them eventually so

00:28:08,960 --> 00:28:19,040
level one has a use case in case of

00:28:15,290 --> 00:28:21,890
low-cost hardware with all the

00:28:19,040 --> 00:28:24,730
components within the secure part secure

00:28:21,890 --> 00:28:29,150
domain the secure processing environment

00:28:24,730 --> 00:28:33,980
having mutual trust this is true for

00:28:29,150 --> 00:28:40,490
quite many use cases but not all use

00:28:33,980 --> 00:28:43,520
cases so for example as again as James

00:28:40,490 --> 00:28:44,179
mentioned in his presentation before

00:28:43,520 --> 00:28:47,030
lunch

00:28:44,179 --> 00:28:50,150
there could be third-party vendors that

00:28:47,030 --> 00:28:52,550
we want to use secure partitions from

00:28:50,150 --> 00:28:55,580
which provide some secure functions but

00:28:52,550 --> 00:28:59,929
we don't want them to have unrestricted

00:28:55,580 --> 00:29:05,000
access to root of trust services and of

00:28:59,929 --> 00:29:08,770
course our core TFM we want to have an

00:29:05,000 --> 00:29:12,200
additional isolation boundary that is

00:29:08,770 --> 00:29:15,080
PSA level 2 isolation where root of

00:29:12,200 --> 00:29:16,910
trust is separated from all of the

00:29:15,080 --> 00:29:20,179
secure partitions within the secure

00:29:16,910 --> 00:29:23,300
processing environment it's important to

00:29:20,179 --> 00:29:26,120
note that this is still a limited

00:29:23,300 --> 00:29:31,730
isolation because secure partitions are

00:29:26,120 --> 00:29:35,270
not separated from one another if we go

00:29:31,730 --> 00:29:39,890
one step further level 3 provides more

00:29:35,270 --> 00:29:41,379
robustness in which case all secure

00:29:39,890 --> 00:29:47,499
partitions are

00:29:41,379 --> 00:29:51,829
isolated from one another and except for

00:29:47,499 --> 00:30:02,869
potentially some root of trust services

00:29:51,829 --> 00:30:06,709
which make up the trusted compute so how

00:30:02,869 --> 00:30:11,989
does that map to our address base

00:30:06,709 --> 00:30:17,179
isolation I've already shown you that in

00:30:11,989 --> 00:30:19,789
the case of level 1 isolation this is an

00:30:17,179 --> 00:30:22,489
example memory layout that trusted

00:30:19,789 --> 00:30:25,579
firmware M and forces on the system

00:30:22,489 --> 00:30:30,919
which the partition manager uses to

00:30:25,579 --> 00:30:34,009
create isolation boundaries now if we

00:30:30,919 --> 00:30:38,659
want to have level 2 or level 3

00:30:34,009 --> 00:30:42,499
isolation we have to utilize trust zone

00:30:38,659 --> 00:30:45,229
but we have to use the secure MPU as

00:30:42,499 --> 00:30:49,489
well the memory protection unit in the

00:30:45,229 --> 00:30:52,509
secure domain and in that case the

00:30:49,489 --> 00:30:52,509
picture gets a bit complicated

00:30:57,850 --> 00:31:05,489
in this case there is a finer much finer

00:31:02,499 --> 00:31:09,609
granularity of access control required

00:31:05,489 --> 00:31:14,739
because we have several permission types

00:31:09,609 --> 00:31:17,350
we have the TFM core components internal

00:31:14,739 --> 00:31:18,850
components which are trusted they are

00:31:17,350 --> 00:31:23,820
derived from the root of trust

00:31:18,850 --> 00:31:27,539
bootloader so those are privileged

00:31:23,820 --> 00:31:31,359
trusted secure components there are some

00:31:27,539 --> 00:31:36,399
there's an unprivileged secure code

00:31:31,359 --> 00:31:39,249
which is basically the secure partition

00:31:36,399 --> 00:31:41,739
resources which are not to be shared in

00:31:39,249 --> 00:31:45,369
level 3 they are not to be shared with

00:31:41,739 --> 00:31:48,909
other secure partitions either and there

00:31:45,369 --> 00:31:51,580
are some shared and privileged resources

00:31:48,909 --> 00:31:56,070
which are accessible to all secure codes

00:31:51,580 --> 00:31:56,070
so there's a host of different

00:31:57,570 --> 00:32:03,190
configurations that need to be addressed

00:32:00,669 --> 00:32:06,700
and and and which need to be controlled

00:32:03,190 --> 00:32:12,849
by the secure partition manager and due

00:32:06,700 --> 00:32:17,190
to the complexity of this problem it's

00:32:12,849 --> 00:32:20,109
much harder to verify the security

00:32:17,190 --> 00:32:25,059
attributes of the partition manager in

00:32:20,109 --> 00:32:27,399
level 2 or level 3 isolation so as I

00:32:25,059 --> 00:32:32,259
mentioned this is why it's working

00:32:27,399 --> 00:32:37,899
progress we do have a prototype which

00:32:32,259 --> 00:32:39,759
works under certain circumstances but

00:32:37,899 --> 00:32:43,599
but there's a lot of work that needs to

00:32:39,759 --> 00:32:48,999
be put into that to provide a reliable

00:32:43,599 --> 00:32:53,159
and and and truly secure solution for

00:32:48,999 --> 00:32:56,830
for for a high level of isolation so

00:32:53,159 --> 00:32:59,909
what are the plans for TSM core and and

00:32:56,830 --> 00:33:04,029
the partition manager as I mentioned

00:32:59,909 --> 00:33:07,899
preemption by the non secure environment

00:33:04,029 --> 00:33:11,789
is quite a critical expectation which

00:33:07,899 --> 00:33:16,840
should be there for most use case

00:33:11,789 --> 00:33:19,630
it's as simple as being responsive to an

00:33:16,840 --> 00:33:21,850
unsecured low-latency requirement

00:33:19,630 --> 00:33:24,580
interrupts in the system which we are

00:33:21,850 --> 00:33:26,799
currently not prepared to handle secure

00:33:24,580 --> 00:33:29,950
irq handling which is an asynchronous

00:33:26,799 --> 00:33:36,700
event handling on the secure side that's

00:33:29,950 --> 00:33:39,429
another feature that is the quad that

00:33:36,700 --> 00:33:42,150
can be quite common if especially if we

00:33:39,429 --> 00:33:45,730
are relying on hardware secure hardware

00:33:42,150 --> 00:33:51,850
accelerators right like a crypto engine

00:33:45,730 --> 00:33:56,679
or or any other secure peripheral but

00:33:51,850 --> 00:34:03,070
that's already smaller auto still large

00:33:56,679 --> 00:34:06,220
subset of use cases we are looking at or

00:34:03,070 --> 00:34:12,879
all of the api's currently provided by

00:34:06,220 --> 00:34:16,480
TFM again as already mentioned earlier

00:34:12,879 --> 00:34:20,800
by James DFM is not colored currently

00:34:16,480 --> 00:34:25,379
DSA compliant in all its api's so we

00:34:20,800 --> 00:34:25,379
have we are looking at all the possible

00:34:25,800 --> 00:34:34,149
API solutions that could work for both

00:34:30,010 --> 00:34:38,040
low-end devices and can scale up to to

00:34:34,149 --> 00:34:43,510
higher resource devices with a lot of

00:34:38,040 --> 00:34:46,599
lot more stringent threat models so we

00:34:43,510 --> 00:34:51,960
have to look at all the api's and see if

00:34:46,599 --> 00:34:58,150
they scale and and how we can use the

00:34:51,960 --> 00:35:01,900
PSA definitions for those api's and yes

00:34:58,150 --> 00:35:05,200
so PSA alignment is a big roadmap item

00:35:01,900 --> 00:35:10,770
for this year we want to provide all the

00:35:05,200 --> 00:35:15,310
isolation profiles defined in PSA and

00:35:10,770 --> 00:35:18,880
there are plans to see how we can turn

00:35:15,310 --> 00:35:21,040
our library of secure functions which

00:35:18,880 --> 00:35:22,550
are which is how we currently define

00:35:21,040 --> 00:35:26,000
secure partitions

00:35:22,550 --> 00:35:28,730
and and look at the feasibility of

00:35:26,000 --> 00:35:32,330
turning them into execution threads

00:35:28,730 --> 00:35:35,840
which quite likely suit a high soar

00:35:32,330 --> 00:35:37,550
higher isolation profile better but we

00:35:35,840 --> 00:35:47,540
we are looking at all of these options

00:35:37,550 --> 00:35:50,300
at the moment so any questions on that

00:35:47,540 --> 00:35:54,320
or maybe I will just take a summary and

00:35:50,300 --> 00:35:57,710
then we can go to questions what we have

00:35:54,320 --> 00:36:00,190
right now we have PSA level one

00:35:57,710 --> 00:36:05,570
isolation in the first release of the

00:36:00,190 --> 00:36:08,930
software we have a framework for

00:36:05,570 --> 00:36:11,630
integrating secure services secure

00:36:08,930 --> 00:36:13,790
partitions we have a second stage boot

00:36:11,630 --> 00:36:16,490
loader and a sucker secure storage

00:36:13,790 --> 00:36:19,600
service which will be discussed in

00:36:16,490 --> 00:36:26,890
separate sessions we have a build system

00:36:19,600 --> 00:36:30,680
we have documentation we do have example

00:36:26,890 --> 00:36:31,780
ports of integrations with no Sakura

00:36:30,680 --> 00:36:35,540
asses

00:36:31,780 --> 00:36:38,510
RTX and bad OS free our toes and

00:36:35,540 --> 00:36:43,970
actually for Friday we are planning to

00:36:38,510 --> 00:36:46,850
demo Saphir integration as well so we

00:36:43,970 --> 00:36:50,630
have various demos we have some

00:36:46,850 --> 00:36:54,590
testitude available and we are looking

00:36:50,630 --> 00:36:59,660
for partner engagement at this stage all

00:36:54,590 --> 00:37:05,260
of the code with the documentation with

00:36:59,660 --> 00:37:12,400
the beerd system with the test suits

00:37:05,260 --> 00:37:15,709
available to the public right now

00:37:12,400 --> 00:37:20,420
just a few words about initial target

00:37:15,709 --> 00:37:25,400
support we are supporting cortex-m 33

00:37:20,420 --> 00:37:29,180
and and 23 based systems which exist as

00:37:25,400 --> 00:37:33,079
vga fpga implementations on mps two

00:37:29,180 --> 00:37:36,739
boards as well as fast models of these

00:37:33,079 --> 00:37:40,279
very same mps two systems so we have

00:37:36,739 --> 00:37:45,410
those working right now with with with

00:37:40,279 --> 00:37:48,369
all the reference code we have and so

00:37:45,410 --> 00:37:52,209
high-level plans for all of the project

00:37:48,369 --> 00:37:57,319
align with PSA specifications provide

00:37:52,209 --> 00:38:04,209
standardized api's for as many secure

00:37:57,319 --> 00:38:06,739
features as we can to follow PSA

00:38:04,209 --> 00:38:10,369
specification for secure partition

00:38:06,739 --> 00:38:14,839
manager and for IPC mechanism described

00:38:10,369 --> 00:38:16,880
in PSA for initialization boot and

00:38:14,839 --> 00:38:23,109
firmware upgrade which is also a very

00:38:16,880 --> 00:38:28,219
important aspect and a host of build

00:38:23,109 --> 00:38:31,219
configurations for the entire system we

00:38:28,219 --> 00:38:34,699
are planning to support as many arm

00:38:31,219 --> 00:38:36,680
reference platforms as we can we are

00:38:34,699 --> 00:38:41,739
planning to support the mosket as chip

00:38:36,680 --> 00:38:47,089
it's actually at the prototyping stage I

00:38:41,739 --> 00:38:51,099
as I mentioned we do support the SSS

00:38:47,089 --> 00:38:54,319
c200 fpga for MPS to and the

00:38:51,099 --> 00:38:59,660
corresponding fvp the first fast model

00:38:54,319 --> 00:39:03,999
for that and of course various system IP

00:38:59,660 --> 00:39:07,069
is the crypto cell the crypto island and

00:39:03,999 --> 00:39:10,299
what we are looking for is as i

00:39:07,069 --> 00:39:14,839
mentioned again partner SOC support

00:39:10,299 --> 00:39:19,249
software integrations for oasis artosis

00:39:14,839 --> 00:39:22,809
on the non secure side sakura a sees the

00:39:19,249 --> 00:39:25,640
whole project is public in open source

00:39:22,809 --> 00:39:30,349
so please get involved this is the main

00:39:25,640 --> 00:39:34,640
message we have the code base on trusted

00:39:30,349 --> 00:39:39,949
firmware org we have a team at this

00:39:34,640 --> 00:39:46,430
leonardo connect with abhishek Ashutosh

00:39:39,949 --> 00:39:48,979
tomash and myself and you can get get in

00:39:46,430 --> 00:39:51,739
touch with us after the presentations

00:39:48,979 --> 00:39:55,509
this afternoon in the light hacking room

00:39:51,739 --> 00:39:59,209
dedicated time slot on Wednesday and

00:39:55,509 --> 00:40:02,269
schedule a meeting impassible get in

00:39:59,209 --> 00:40:05,349
touch and for any more information you

00:40:02,269 --> 00:40:05,349
can go to developer.android.com

00:40:18,240 --> 00:40:27,970
just a second we'll get the mic so he

00:40:24,849 --> 00:40:30,369
can test it so you know first slides we

00:40:27,970 --> 00:40:33,880
ever mentioned it is the master criminal

00:40:30,369 --> 00:40:36,000
oh yes the acoustic so how about for the

00:40:33,880 --> 00:40:42,309
sacral areas it is a steel

00:40:36,000 --> 00:40:53,369
exactly oh yes acoustic or not so secure

00:40:42,309 --> 00:40:53,369
OS is if we consider a secure OS

00:40:55,349 --> 00:41:05,530
Abhishek so yeah

00:41:03,250 --> 00:41:09,040
it's slightly different from the a class

00:41:05,530 --> 00:41:10,349
where you have independent trusted

00:41:09,040 --> 00:41:13,569
operating systems

00:41:10,349 --> 00:41:15,460
our plan is Floyd complete execution

00:41:13,569 --> 00:41:18,940
environment where you don't need a

00:41:15,460 --> 00:41:22,150
different trusted operating system the

00:41:18,940 --> 00:41:24,730
just McClure's presented in effect is

00:41:22,150 --> 00:41:27,280
the trusted execution in the moment not

00:41:24,730 --> 00:41:30,280
maybe not fully functional operating

00:41:27,280 --> 00:41:31,960
system but it in effect provides all the

00:41:30,280 --> 00:41:35,040
facilities you need for developing

00:41:31,960 --> 00:41:35,040
secure applications

00:41:39,030 --> 00:41:47,200
so his memory map is the same in secure

00:41:43,030 --> 00:41:49,839
and non-secure mode like GPIO address of

00:41:47,200 --> 00:41:56,579
your chat area of book would be the same

00:41:49,839 --> 00:41:59,319
okay change in time so as I mentioned

00:41:56,579 --> 00:42:03,700
earlier let me go back to one of the

00:41:59,319 --> 00:42:09,329
slides with with the memory map as

00:42:03,700 --> 00:42:15,190
defined for VA time so the configuration

00:42:09,329 --> 00:42:18,190
for the address space has a static

00:42:15,190 --> 00:42:25,510
component which is defined at

00:42:18,190 --> 00:42:28,500
implementation time CP MCU so RTL

00:42:25,510 --> 00:42:31,510
definition contains an initial

00:42:28,500 --> 00:42:34,540
separation between some secure and

00:42:31,510 --> 00:42:40,920
non-secure address ranges and that can

00:42:34,540 --> 00:42:44,380
be configured further with the software

00:42:40,920 --> 00:42:47,859
configurable security attribution unit

00:42:44,380 --> 00:42:51,609
as for the specific address of

00:42:47,859 --> 00:42:54,430
peripherals as it's an implementation

00:42:51,609 --> 00:42:58,960
defined characteristic of the hard

00:42:54,430 --> 00:43:02,680
hardware but it makes all sense to have

00:42:58,960 --> 00:43:10,170
a secure and non-secure alias for the

00:43:02,680 --> 00:43:14,980
same peripheral and in that case if the

00:43:10,170 --> 00:43:18,670
there is a so if there is no need for

00:43:14,980 --> 00:43:21,190
the secure trusted firmware to configure

00:43:18,670 --> 00:43:23,920
it secure because it's a peripheral that

00:43:21,190 --> 00:43:27,250
is not used for security purposes then

00:43:23,920 --> 00:43:29,800
it will just enable the non secure code

00:43:27,250 --> 00:43:36,550
to access the non secure alias for the

00:43:29,800 --> 00:43:38,200
peripheral so so it can change because

00:43:36,550 --> 00:43:41,349
of the less

00:43:38,200 --> 00:43:43,359
I'm sorry it can change addresses can

00:43:41,349 --> 00:43:46,990
change and secure and non-secure mode

00:43:43,359 --> 00:43:49,720
because of the laces yeah so it's it's

00:43:46,990 --> 00:43:52,780
going to be different for for the secure

00:43:49,720 --> 00:43:55,980
and non-secure it it has to be different

00:43:52,780 --> 00:43:59,260
because because all of this mapping is

00:43:55,980 --> 00:44:01,599
ideally static if we want to change it

00:43:59,260 --> 00:44:05,740
in runtime that will be a lot of

00:44:01,599 --> 00:44:08,800
overhead so we are trying to avoid that

00:44:05,740 --> 00:44:11,260
and and this is for examples something

00:44:08,800 --> 00:44:15,339
that we encountered on the get-go when

00:44:11,260 --> 00:44:17,890
when porting v7m Zafir implementation on

00:44:15,339 --> 00:44:19,930
v8 and platform that all the addresses

00:44:17,890 --> 00:44:23,260
had to be set correctly to the non

00:44:19,930 --> 00:44:27,690
secure areas of the peripherals the

00:44:23,260 --> 00:44:27,690
default peripherals for the subsystem

00:44:34,230 --> 00:44:40,180
one of the IPC progenation is I doubt

00:44:37,500 --> 00:44:43,750
that defines the static configuration of

00:44:40,180 --> 00:44:45,910
the memory so it sets a very minimal set

00:44:43,750 --> 00:44:48,490
of memory carbons security requirements

00:44:45,910 --> 00:44:50,530
on the memory from that point this

00:44:48,490 --> 00:44:52,390
security attribution can only up it

00:44:50,530 --> 00:44:53,109
can't go down so if something is marked

00:44:52,390 --> 00:44:56,440
as secure only

00:44:53,109 --> 00:45:00,329
it cannot be re-enabled as non secure

00:44:56,440 --> 00:45:00,329
access it can only be secured

00:45:02,750 --> 00:45:07,580
one device there are two parts one

00:45:04,640 --> 00:45:11,090
security one no security waters to

00:45:07,580 --> 00:45:22,510
change the oil finished parts you have

00:45:11,090 --> 00:45:22,510
to reboot your system there is so so

00:45:22,930 --> 00:45:31,940
basically the way this should be thought

00:45:27,470 --> 00:45:35,510
about the way I think about it is from

00:45:31,940 --> 00:45:38,480
the non secure OS perspective it has a

00:45:35,510 --> 00:45:46,400
restricted but static view of the system

00:45:38,480 --> 00:45:49,010
so we would define so the OE OE am vent

00:45:46,400 --> 00:45:53,359
or for example if if they want to

00:45:49,010 --> 00:46:00,890
deliver their product with a trusted

00:45:53,359 --> 00:46:02,690
firmware M root of trust system they

00:46:00,890 --> 00:46:06,050
would define what a non secure

00:46:02,690 --> 00:46:08,990
application can access statically so so

00:46:06,050 --> 00:46:11,240
that the non secure OS and the non

00:46:08,990 --> 00:46:14,660
secure application as a whole would have

00:46:11,240 --> 00:46:17,990
a set of peripherals at predefined non

00:46:14,660 --> 00:46:19,970
secure locations in the system so it's

00:46:17,990 --> 00:46:23,990
it's not a matter of restarting the

00:46:19,970 --> 00:46:26,060
system or or or or it's a static

00:46:23,990 --> 00:46:30,099
configuration defined by the OEM

00:46:26,060 --> 00:46:34,160
typically if you change some

00:46:30,099 --> 00:46:37,190
applications with some provision some

00:46:34,160 --> 00:46:39,500
applications previously used in security

00:46:37,190 --> 00:46:42,470
mode now we want to shift it to to nonce

00:46:39,500 --> 00:46:44,510
non secure mode that means we need to do

00:46:42,470 --> 00:46:47,119
some reconfiguration right

00:46:44,510 --> 00:46:51,140
that means this kind of recovery journey

00:46:47,119 --> 00:46:54,080
has to be based on you reboot your your

00:46:51,140 --> 00:46:56,240
Hardware you reboot your device yeah

00:46:54,080 --> 00:47:00,050
yeah if we don't change that everything

00:46:56,240 --> 00:47:02,180
was static right oh yeah I guess that's

00:47:00,050 --> 00:47:06,859
the point I get it form your protection

00:47:02,180 --> 00:47:09,410
yeah yeah pretty much so but again it's

00:47:06,859 --> 00:47:12,020
it's a matter of how you look at it and

00:47:09,410 --> 00:47:13,960
what the use case is because now there

00:47:12,020 --> 00:47:18,069
can be a use case where you

00:47:13,960 --> 00:47:21,940
so you are allowed to from the trusted

00:47:18,069 --> 00:47:25,869
firm they're dynamically reconfigure to

00:47:21,940 --> 00:47:28,770
memory map supported memory map but in

00:47:25,869 --> 00:47:33,339
an embedded application it's I would say

00:47:28,770 --> 00:47:36,280
an unlikely or not typical scenario we

00:47:33,339 --> 00:47:40,930
are running the code from flash static

00:47:36,280 --> 00:47:44,190
components in the flash so if you do for

00:47:40,930 --> 00:47:47,980
example an upgrade and the new firmware

00:47:44,190 --> 00:47:49,780
would have a different memory layout you

00:47:47,980 --> 00:47:52,089
would anyway restart the system with the

00:47:49,780 --> 00:47:58,630
new configuration okay guns thank you

00:47:52,089 --> 00:48:01,960
pretty much in in terms of maintaining

00:47:58,630 --> 00:48:03,940
the route of trust are you going to

00:48:01,960 --> 00:48:07,150
provide just callbacks and leave that to

00:48:03,940 --> 00:48:09,990
to the vendors to to provide the

00:48:07,150 --> 00:48:12,040
mechanisms of key management and and

00:48:09,990 --> 00:48:17,730
authentication or is that going to be

00:48:12,040 --> 00:48:17,730
part of the trusted firm or model itself

00:48:18,720 --> 00:48:24,880
so that's slightly different from the

00:48:21,549 --> 00:48:26,980
framework the one of the root of trust

00:48:24,880 --> 00:48:29,740
services you need is the bootloader the

00:48:26,980 --> 00:48:31,930
secure boot that is handled by the

00:48:29,740 --> 00:48:34,480
secure boot the br-2 that we lost

00:48:31,930 --> 00:48:37,390
mission then we talked about the runtime

00:48:34,480 --> 00:48:39,609
root of trust services for that you need

00:48:37,390 --> 00:48:42,069
services that can plug in into this

00:48:39,609 --> 00:48:44,170
framework nor the framework itself so

00:48:42,069 --> 00:48:47,170
this is like crypto and secure storage

00:48:44,170 --> 00:48:50,290
will provide you the root of trust in

00:48:47,170 --> 00:48:53,319
the runtime so the answer is trusted

00:48:50,290 --> 00:48:55,059
firmware M will have something but this

00:48:53,319 --> 00:48:58,869
particular is about the firmware

00:48:55,059 --> 00:49:01,299
framework so if your answer is about the

00:48:58,869 --> 00:49:03,220
root of trust attestation services once

00:49:01,299 --> 00:49:04,690
PSA actually specifies what are the

00:49:03,220 --> 00:49:07,140
requirements they would be implemented

00:49:04,690 --> 00:49:09,190
interested firmware M the only

00:49:07,140 --> 00:49:12,609
abstractions will be about vendor

00:49:09,190 --> 00:49:14,559
specific hardware so if you have a

00:49:12,609 --> 00:49:15,599
crypto accelerator Hardware at some

00:49:14,559 --> 00:49:17,309
point the line has

00:49:15,599 --> 00:49:19,289
to be drawn about where the where the

00:49:17,309 --> 00:49:21,869
try very specific took it to hardware

00:49:19,289 --> 00:49:26,479
but the software part of that service

00:49:21,869 --> 00:49:26,479
will be implemented in the project

00:49:31,220 --> 00:49:39,569
questions are do you want to take some

00:49:35,940 --> 00:49:42,089
function which was provide by your trust

00:49:39,569 --> 00:49:44,839
for where well the reason I mentioned

00:49:42,089 --> 00:49:48,150
this question is because I see some are

00:49:44,839 --> 00:49:50,849
videos from YouTube to break some Google

00:49:48,150 --> 00:49:53,369
Earth is kind of another kind of trust

00:49:50,849 --> 00:49:55,950
fund where and as a cleared pay exam of

00:49:53,369 --> 00:49:58,559
features in Intel platform it's not

00:49:55,950 --> 00:50:00,329
necessary for firmware level and it's a

00:49:58,559 --> 00:50:03,599
Google one get rid of all of our

00:50:00,329 --> 00:50:06,930
necessary features that's already Adeste

00:50:03,599 --> 00:50:12,150
in the UEFI so I'm not sure whether you

00:50:06,930 --> 00:50:15,150
have this canned up for momentum in the

00:50:12,150 --> 00:50:17,910
future to get rid of some returning a

00:50:15,150 --> 00:50:20,569
function in firmware layer and to make

00:50:17,910 --> 00:50:25,739
that firmware something put a loader

00:50:20,569 --> 00:50:28,589
extremely efficient and move some more

00:50:25,739 --> 00:50:30,900
complex function from familiar to

00:50:28,589 --> 00:50:35,579
opposite Slayer awesome holla where to

00:50:30,900 --> 00:50:39,839
make it more efficient so I would say

00:50:35,579 --> 00:50:43,380
that that that we will have to wait and

00:50:39,839 --> 00:50:46,499
see what the use cases will be provide

00:50:43,380 --> 00:50:48,200
what use cases will be provided we are

00:50:46,499 --> 00:50:52,380
providing a reference implementation

00:50:48,200 --> 00:50:55,170
where we are trying to set the watermark

00:50:52,380 --> 00:50:58,589
to the right level of what the framework

00:50:55,170 --> 00:51:02,279
provides and what we are planning to

00:50:58,589 --> 00:51:05,369
have a planning to be hooked into it but

00:51:02,279 --> 00:51:08,700
we wanted to scale we wanted to scale

00:51:05,369 --> 00:51:11,700
down to to low footprint highly

00:51:08,700 --> 00:51:14,579
efficient framework where all of the

00:51:11,700 --> 00:51:17,039
additional secure partitions all of the

00:51:14,579 --> 00:51:19,559
functionality is plugged in by the band

00:51:17,039 --> 00:51:22,950
or itself the silicon partner or whoever

00:51:19,559 --> 00:51:26,130
wants to use the framework and bit one

00:51:22,950 --> 00:51:27,040
we want to still provide the reference

00:51:26,130 --> 00:51:29,350
implementation

00:51:27,040 --> 00:51:31,510
to all the additional secure partitions

00:51:29,350 --> 00:51:33,550
some some reference trusted partitions

00:51:31,510 --> 00:51:35,860
for example as we now have the secure

00:51:33,550 --> 00:51:38,830
storage implementation which is one

00:51:35,860 --> 00:51:43,090
possible implementation but we already

00:51:38,830 --> 00:51:45,190
have a user defines so so even currently

00:51:43,090 --> 00:51:48,040
the trusted format at Build time you can

00:51:45,190 --> 00:51:50,770
specify what is it that you would like

00:51:48,040 --> 00:51:53,050
in the final bill then you can take out

00:51:50,770 --> 00:51:54,130
some recent services and I think if

00:51:53,050 --> 00:51:56,650
you're talking about whether the

00:51:54,130 --> 00:51:58,780
framework provides that model or not the

00:51:56,650 --> 00:52:01,090
build will provide the model so you you

00:51:58,780 --> 00:52:03,700
configure what the final build outcome

00:52:01,090 --> 00:52:06,090
you want you take the services if you're

00:52:03,700 --> 00:52:09,160
adding your own services from elsewhere

00:52:06,090 --> 00:52:10,840
that's that at that point you're taking

00:52:09,160 --> 00:52:12,880
a custom build out and you're building

00:52:10,840 --> 00:52:17,520
in some other environment outside mr.

00:52:12,880 --> 00:52:21,970
Foreman yeah so this is this is very

00:52:17,520 --> 00:52:25,330
specific I think tu-22m m-class and and

00:52:21,970 --> 00:52:29,370
and the trusted firmware am solution and

00:52:25,330 --> 00:52:33,030
in general the the embedded

00:52:29,370 --> 00:52:35,790
microcontroller solutions that it's all

00:52:33,030 --> 00:52:38,170
statically defined at linked time

00:52:35,790 --> 00:52:41,530
what-what-what-what the system provides

00:52:38,170 --> 00:52:43,570
and and and what additional layers you

00:52:41,530 --> 00:52:46,480
would have to add on top of that asset

00:52:43,570 --> 00:52:49,540
alert raaah libraries for example or the

00:52:46,480 --> 00:52:50,950
non secure application I got it my last

00:52:49,540 --> 00:52:53,500
question well but all of this

00:52:50,950 --> 00:52:57,400
presentation you depicted here as all

00:52:53,500 --> 00:53:00,100
info on platform right souling for ad if

00:52:57,400 --> 00:53:01,060
I mean other platform APIs it's not

00:53:00,100 --> 00:53:05,170
available

00:53:01,060 --> 00:53:08,680
there are Intel or PC all of the rest of

00:53:05,170 --> 00:53:11,260
that phone this so this implementation

00:53:08,680 --> 00:53:14,410
actually implements lots of bits of

00:53:11,260 --> 00:53:18,490
software which have the dependency of

00:53:14,410 --> 00:53:22,330
hardware's in specific layers we focus

00:53:18,490 --> 00:53:24,310
on to start with our BRM systems beyond

00:53:22,330 --> 00:53:28,090
that there are more different arm

00:53:24,310 --> 00:53:29,800
m-class processors and if someone else

00:53:28,090 --> 00:53:31,720
would want to use the bits of software

00:53:29,800 --> 00:53:35,450
anything else I don't think there's a

00:53:31,720 --> 00:53:39,700
restriction we are focusing on

00:53:35,450 --> 00:53:39,700
Gaga specifc that's where I would put it

00:53:51,040 --> 00:53:57,530
the codes is it BSD license you can use

00:53:55,490 --> 00:53:59,569
it any way you want them in any kind of

00:53:57,530 --> 00:54:02,079
system I mean we would encourage that

00:53:59,569 --> 00:54:12,349
because that takes the PSA standards

00:54:02,079 --> 00:54:14,420
elsewhere that would be even better so

00:54:12,349 --> 00:54:16,220
we have a question there okay since you

00:54:14,420 --> 00:54:18,410
mentioned a lesson is possible how do

00:54:16,220 --> 00:54:21,319
you make sure same region is not allowed

00:54:18,410 --> 00:54:24,619
for both secured and unsecured and what

00:54:21,319 --> 00:54:29,140
happens how does the system behave if

00:54:24,619 --> 00:54:29,140
the same region is Alaska constantly

00:54:31,480 --> 00:54:41,930
this is a 32 bit physical memory layout

00:54:36,920 --> 00:54:44,569
and and since since the address is so so

00:54:41,930 --> 00:54:49,010
there's a single hardware Association

00:54:44,569 --> 00:54:52,579
it's basically in in a in a single

00:54:49,010 --> 00:54:54,140
master scenario it's that's not possible

00:54:52,579 --> 00:54:57,319
because because the the hardware

00:54:54,140 --> 00:54:59,599
component doesn't allow for to be honest

00:54:57,319 --> 00:55:02,119
if there's a memory it can be accessed

00:54:59,599 --> 00:55:05,450
from both sides at different aliases in

00:55:02,119 --> 00:55:06,829
that shared memory so so if you have if

00:55:05,450 --> 00:55:08,990
you need shared memory you're gonna have

00:55:06,829 --> 00:55:11,119
to map it on both sides but if it's a

00:55:08,990 --> 00:55:13,430
peripheral which has States in the

00:55:11,119 --> 00:55:15,079
driver somewhere you don't want to map

00:55:13,430 --> 00:55:18,230
it to both sides that's where trusted

00:55:15,079 --> 00:55:20,329
former em top-level definition will

00:55:18,230 --> 00:55:23,510
ensure that it only goes to one side was

00:55:20,329 --> 00:55:24,920
when you build it that's my that's my

00:55:23,510 --> 00:55:28,150
question how do you make sure that that

00:55:24,920 --> 00:55:28,150
is not being shared

00:55:34,220 --> 00:55:39,180
that's the level of granularity which we

00:55:37,350 --> 00:55:42,810
need to consider properly before we are

00:55:39,180 --> 00:55:44,840
now bitwise convert is very difficult to

00:55:42,810 --> 00:55:47,190
implement in the space because the

00:55:44,840 --> 00:55:51,540
address space actually is accessed by

00:55:47,190 --> 00:55:53,130
32-bit values but for peripherals so in

00:55:51,540 --> 00:55:55,410
case of peripherals there are problems

00:55:53,130 --> 00:55:57,480
if you map it to both sides right so you

00:55:55,410 --> 00:55:58,740
don't you the question is not that the

00:55:57,480 --> 00:56:01,080
question is how do you ensure that

00:55:58,740 --> 00:56:03,060
that's the purpose of secure firmware so

00:56:01,080 --> 00:56:05,880
your secure farmer is the only one which

00:56:03,060 --> 00:56:07,200
can configure the system components so

00:56:05,880 --> 00:56:10,080
non-secure cannot change what's being

00:56:07,200 --> 00:56:11,790
set up so once you once you are secure

00:56:10,080 --> 00:56:14,220
former has decided that something is not

00:56:11,790 --> 00:56:16,050
mapped to non secure non secure can't

00:56:14,220 --> 00:56:19,200
access now if you seek your firmware has

00:56:16,050 --> 00:56:20,520
got bugs or features which are mapping

00:56:19,200 --> 00:56:22,950
it in a way that it's gonna break the

00:56:20,520 --> 00:56:25,410
system that that's a problem not not

00:56:22,950 --> 00:56:26,760
basically of that that's the problem

00:56:25,410 --> 00:56:29,250
which is we are trying to address by

00:56:26,760 --> 00:56:30,990
putting software infrastructure that

00:56:29,250 --> 00:56:32,610
prevents as much as possible but if

00:56:30,990 --> 00:56:34,290
someone goes and fix that and says we

00:56:32,610 --> 00:56:37,310
got a map with both sides you're

00:56:34,290 --> 00:56:40,530
effectively on your own

00:56:37,310 --> 00:56:44,970
ok I think that's the last question we

00:56:40,530 --> 00:56:45,960
had time for I'm I would gladly ask your

00:56:44,970 --> 00:56:48,690
questions later

00:56:45,960 --> 00:56:51,480
sorry but we have to set up the for the

00:56:48,690 --> 00:56:54,080
next presentation which is also in the

00:56:51,480 --> 00:56:54,080
same topic

00:57:03,750 --> 00:57:05,810

YouTube URL: https://www.youtube.com/watch?v=G4qNuank0WU


