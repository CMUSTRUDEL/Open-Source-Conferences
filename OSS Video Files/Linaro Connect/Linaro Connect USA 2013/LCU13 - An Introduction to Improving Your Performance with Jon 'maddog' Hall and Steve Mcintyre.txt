Title: LCU13 - An Introduction to Improving Your Performance with Jon 'maddog' Hall and Steve Mcintyre
Publication date: 2014-04-30
Playlist: Linaro Connect USA 2013
Description: 
	Jon and Steve talking about a performance contest for ARM64 architecture and GNU Linux operating system, sponsored by Linaro
Captions: 
	00:00:00,000 --> 00:00:02,030
I

00:00:05,910 --> 00:00:11,850
hello my name is John Mad Dog call and

00:00:08,920 --> 00:00:15,940
I'm the president of Linux international

00:00:11,850 --> 00:00:18,310
I'm Steve MacIntyre I'm an engineer for

00:00:15,940 --> 00:00:20,949
working for arm and I'm seconded until

00:00:18,310 --> 00:00:23,770
an hour and we're here today to talk

00:00:20,949 --> 00:00:27,730
about a performance contest which linaro

00:00:23,770 --> 00:00:30,430
is sponsoring basically working with the

00:00:27,730 --> 00:00:33,730
arm 64 architecture and the canoe Linux

00:00:30,430 --> 00:00:37,469
operating system many many years ago

00:00:33,730 --> 00:00:40,899
when computers were a lot smaller in

00:00:37,469 --> 00:00:44,050
logical size and a lot slower and a lot

00:00:40,899 --> 00:00:46,569
more expensive people had multiple ways

00:00:44,050 --> 00:00:49,719
of programming either in a high-level

00:00:46,569 --> 00:00:52,749
language like Fortran or cobol we're sea

00:00:49,719 --> 00:00:56,050
or in what we call a low-level language

00:00:52,749 --> 00:00:58,229
such as assembly language the assembly

00:00:56,050 --> 00:01:00,789
language was specific to a particular

00:00:58,229 --> 00:01:04,120
processor and sometimes a particular

00:01:00,789 --> 00:01:06,400
processor family and therefore when you

00:01:04,120 --> 00:01:08,229
want to take the code that you'd written

00:01:06,400 --> 00:01:11,110
in the assembly language to another

00:01:08,229 --> 00:01:13,720
machine it was very very difficult and

00:01:11,110 --> 00:01:16,750
you were happy you typically had to

00:01:13,720 --> 00:01:18,910
rewrite the entire code over again for

00:01:16,750 --> 00:01:22,030
the new machine with a high-level

00:01:18,910 --> 00:01:24,130
language you typically could recompile

00:01:22,030 --> 00:01:29,290
the program when you took it to another

00:01:24,130 --> 00:01:31,980
system in people still use assembly

00:01:29,290 --> 00:01:35,200
language in working with machines

00:01:31,980 --> 00:01:37,630
relatively recently because it is also

00:01:35,200 --> 00:01:40,150
very efficient and if you're very good

00:01:37,630 --> 00:01:41,980
at writing the assembly language you

00:01:40,150 --> 00:01:44,610
might be able to get a significant

00:01:41,980 --> 00:01:49,630
improvement in the speed of particular

00:01:44,610 --> 00:01:52,240
processes however over time compilers

00:01:49,630 --> 00:01:54,550
have gotten better and better the

00:01:52,240 --> 00:01:56,920
memories are larger we don't need to

00:01:54,550 --> 00:02:01,720
worry as much about the amount of space

00:01:56,920 --> 00:02:03,970
we use the cores of the CPUs are multi

00:02:01,720 --> 00:02:07,120
core so did you have two or three or

00:02:03,970 --> 00:02:08,679
four cpus on particular chip and you

00:02:07,120 --> 00:02:10,490
might want to be able to use all of them

00:02:08,679 --> 00:02:14,570
instead of just one

00:02:10,490 --> 00:02:16,580
and all of these things lend to moving

00:02:14,570 --> 00:02:19,600
away from the use of assembly language

00:02:16,580 --> 00:02:23,990
except in very very specific cases and

00:02:19,600 --> 00:02:26,720
moving towards high level compilers so

00:02:23,990 --> 00:02:29,980
recently arm is bringing out a new chip

00:02:26,720 --> 00:02:32,240
a 64-bit version of their system and

00:02:29,980 --> 00:02:35,810
they realized that there was a lot of

00:02:32,240 --> 00:02:39,440
code inside of canoe Linux which has

00:02:35,810 --> 00:02:42,260
assembly language in it and Steve did a

00:02:39,440 --> 00:02:45,350
study of this code and found out that

00:02:42,260 --> 00:02:47,090
there were over 1,400 different modules

00:02:45,350 --> 00:02:50,270
that had assembly language in it and

00:02:47,090 --> 00:02:52,430
that these would have to be changed to

00:02:50,270 --> 00:02:56,810
allow it to run efficiently when an arm

00:02:52,430 --> 00:02:59,300
64 computer so with a bunch of other

00:02:56,810 --> 00:03:03,020
people he went through the code and did

00:02:59,300 --> 00:03:06,650
some analysis of the code and said well

00:03:03,020 --> 00:03:08,300
yes we could just port this code we

00:03:06,650 --> 00:03:12,170
could make it so that it would work on

00:03:08,300 --> 00:03:14,600
the arm 64 but we believe that a better

00:03:12,170 --> 00:03:17,930
thing would be to evaluate the code and

00:03:14,600 --> 00:03:20,120
say could we do it better could we

00:03:17,930 --> 00:03:22,430
change can we do it in a high-level

00:03:20,120 --> 00:03:26,620
language and eliminate the assembly code

00:03:22,430 --> 00:03:29,060
for every type of architecture could we

00:03:26,620 --> 00:03:31,700
make it so that we can have what are

00:03:29,060 --> 00:03:34,220
called intrinsic that would do the same

00:03:31,700 --> 00:03:38,030
thing but you would not have to worry

00:03:34,220 --> 00:03:41,030
about putting it in the future so we

00:03:38,030 --> 00:03:43,700
decided to create a contest which is not

00:03:41,030 --> 00:03:47,090
only about porting the code and making

00:03:43,700 --> 00:03:49,640
it work well on an arm 64 processor but

00:03:47,090 --> 00:03:52,940
also looking at the basic underlying

00:03:49,640 --> 00:03:56,270
code to see if we can make it faster and

00:03:52,940 --> 00:03:59,420
better for all of gondor linux and for

00:03:56,270 --> 00:04:02,090
all of the different architectures so

00:03:59,420 --> 00:04:04,760
Steve I'm going to ask you a few

00:04:02,090 --> 00:04:06,640
questions because it did lead your paper

00:04:04,760 --> 00:04:10,370
there and it was very impressed by it

00:04:06,640 --> 00:04:12,890
okay end off when you when you started

00:04:10,370 --> 00:04:15,320
looking through these modules and things

00:04:12,890 --> 00:04:18,859
what was the first thing you found out

00:04:15,320 --> 00:04:21,169
about it um well

00:04:18,859 --> 00:04:25,340
yes playing exactly how we started with

00:04:21,169 --> 00:04:28,490
we basically did an analysis of all

00:04:25,340 --> 00:04:32,090
packages in the abundant Linux

00:04:28,490 --> 00:04:33,919
distribution and in fedora to see what

00:04:32,090 --> 00:04:35,840
looked like it might contain assembly to

00:04:33,919 --> 00:04:38,419
start with so that was where we came up

00:04:35,840 --> 00:04:40,610
with this this number of 1,400 packages

00:04:38,419 --> 00:04:42,979
in the end and that was just a very

00:04:40,610 --> 00:04:44,870
simple quick and dirty scan using the

00:04:42,979 --> 00:04:48,740
obvious tools grep and you know things

00:04:44,870 --> 00:04:50,210
like that what we found was in fact

00:04:48,740 --> 00:04:51,979
there's quite a lot of packages that

00:04:50,210 --> 00:04:54,080
look like they might contain assembly

00:04:51,979 --> 00:04:56,419
but actually they're false positives so

00:04:54,080 --> 00:05:00,080
that's easy easy to pick out thankfully

00:04:56,419 --> 00:05:02,240
it reduces our target space what we then

00:05:00,080 --> 00:05:06,409
found was that there's basically there's

00:05:02,240 --> 00:05:08,930
a few categories of I guess reasons why

00:05:06,409 --> 00:05:11,960
people you know have been using assembly

00:05:08,930 --> 00:05:13,180
in the code typically it's old coat

00:05:11,960 --> 00:05:15,949
that's been around for a very long time

00:05:13,180 --> 00:05:18,259
sometimes it's it's because people think

00:05:15,949 --> 00:05:20,659
it's faster some people sometimes it's

00:05:18,259 --> 00:05:22,310
because people need low level access to

00:05:20,659 --> 00:05:23,839
their hardware that isn't available

00:05:22,310 --> 00:05:28,250
through any normal high level

00:05:23,839 --> 00:05:31,639
programming languages and so I actually

00:05:28,250 --> 00:05:36,469
actually set these out into a variety of

00:05:31,639 --> 00:05:39,919
I think i came up with six yes six so

00:05:36,469 --> 00:05:42,830
the most common ones were for things

00:05:39,919 --> 00:05:45,379
like white swapping for bitwise

00:05:42,830 --> 00:05:47,900
operations places where people were

00:05:45,379 --> 00:05:49,759
doing really really simple operations

00:05:47,900 --> 00:05:52,520
that to be honest these days a compiler

00:05:49,759 --> 00:05:54,439
will do much better than even if you've

00:05:52,520 --> 00:05:56,659
gone and spent weeks doing your your

00:05:54,439 --> 00:05:58,550
hand optimized code you might have beat

00:05:56,659 --> 00:06:00,439
the compiler ten years ago but these

00:05:58,550 --> 00:06:02,029
days a good compiler will recognize it

00:06:00,439 --> 00:06:03,680
and we'll be able to substitute

00:06:02,029 --> 00:06:07,819
something that's probably better than

00:06:03,680 --> 00:06:09,379
what you did we then have as I said

00:06:07,819 --> 00:06:11,330
mentioned things like low-level hardware

00:06:09,379 --> 00:06:13,490
access people wanting to know which

00:06:11,330 --> 00:06:15,409
particular flavor of CPU they're wanting

00:06:13,490 --> 00:06:17,569
on although for most things it shouldn't

00:06:15,409 --> 00:06:20,750
really matter anymore you know if your

00:06:17,569 --> 00:06:23,360
coded good and in those cases again it

00:06:20,750 --> 00:06:25,039
would be awesome if there was a more

00:06:23,360 --> 00:06:25,610
generic if there was library code why

00:06:25,039 --> 00:06:27,889
you say when

00:06:25,610 --> 00:06:32,120
trinsic to be able to find out this

00:06:27,889 --> 00:06:34,580
information people wanting to get access

00:06:32,120 --> 00:06:36,620
to timestamp counters if they wanted

00:06:34,580 --> 00:06:39,229
which are great if you want to do very

00:06:36,620 --> 00:06:41,180
very detailed analysis and profiling of

00:06:39,229 --> 00:06:44,449
you of your code performance normally

00:06:41,180 --> 00:06:51,139
but actually in normal day-to-day use do

00:06:44,449 --> 00:06:54,050
really cares there's Cindy so single

00:06:51,139 --> 00:06:55,909
instruction multiple data places where

00:06:54,050 --> 00:06:58,939
people are using lots of this would be

00:06:55,909 --> 00:07:01,370
in multimedia code obviously whether

00:06:58,939 --> 00:07:03,379
they want to be able to use the latest

00:07:01,370 --> 00:07:06,110
greatest hardware that's available on

00:07:03,379 --> 00:07:10,759
modern intel on powerpc everybody else

00:07:06,110 --> 00:07:12,319
everybody's CPUs now to be able to get

00:07:10,759 --> 00:07:15,379
the best performance for doing large

00:07:12,319 --> 00:07:16,669
amounts of data manipulation again there

00:07:15,379 --> 00:07:19,400
are better ways than doing that in

00:07:16,669 --> 00:07:21,800
assembly there were already intrinsic is

00:07:19,400 --> 00:07:25,099
available in the compilers to be able to

00:07:21,800 --> 00:07:27,770
do this but ten years ago there might

00:07:25,099 --> 00:07:29,539
not be it's it's it's basically it's the

00:07:27,770 --> 00:07:31,550
same thing that keeps on coming up over

00:07:29,539 --> 00:07:34,129
and over in lots of these cases there

00:07:31,550 --> 00:07:35,690
are better ways of doing it now that

00:07:34,129 --> 00:07:38,000
people may not may not have actually

00:07:35,690 --> 00:07:39,949
been able to find years ago they're even

00:07:38,000 --> 00:07:42,409
I know that my own personal experience

00:07:39,949 --> 00:07:45,050
that there are flags on the canoe c

00:07:42,409 --> 00:07:48,020
compiler there weren't there you know

00:07:45,050 --> 00:07:50,779
ten years exactly yes and let you know

00:07:48,020 --> 00:07:52,909
bullet cost is also the experts who work

00:07:50,779 --> 00:07:54,620
on the compilers you know i've been

00:07:52,909 --> 00:07:56,960
working on these things you know the

00:07:54,620 --> 00:07:59,389
toolchain guys haven't just been SAT

00:07:56,960 --> 00:08:01,219
around you know watching the world go by

00:07:59,389 --> 00:08:03,710
you know these are exactly the places

00:08:01,219 --> 00:08:05,719
worth the really really scarily

00:08:03,710 --> 00:08:07,520
intelligent people have been we know

00:08:05,719 --> 00:08:10,610
working hard on this to try and improve

00:08:07,520 --> 00:08:11,629
the state the state of the world we

00:08:10,610 --> 00:08:16,099
should be making the most of what

00:08:11,629 --> 00:08:18,650
they've done right so what we what we're

00:08:16,099 --> 00:08:20,870
trying to do with us is we're trying to

00:08:18,650 --> 00:08:23,870
allow the community to work together

00:08:20,870 --> 00:08:26,659
both the upstream maintain errs who are

00:08:23,870 --> 00:08:28,909
maintaining the code with also people

00:08:26,659 --> 00:08:31,939
who would be very interested in learning

00:08:28,909 --> 00:08:34,729
more about optimization techniques more

00:08:31,939 --> 00:08:35,510
about how to write uh you know what the

00:08:34,729 --> 00:08:37,850
code is doing in

00:08:35,510 --> 00:08:41,180
how to use the compilers in a better way

00:08:37,850 --> 00:08:44,480
and if it is determined that the best

00:08:41,180 --> 00:08:46,430
way of doing this is to write the code

00:08:44,480 --> 00:08:48,680
again in assembler but that's fine too

00:08:46,430 --> 00:08:50,570
but we would like to see some

00:08:48,680 --> 00:08:53,090
performance improvement come out of this

00:08:50,570 --> 00:08:56,020
and to clean up a lot of this code and

00:08:53,090 --> 00:08:59,120
make it better and perhaps more portable

00:08:56,020 --> 00:09:02,090
so we actually have two parts to the

00:08:59,120 --> 00:09:05,570
project one project one part of it is

00:09:02,090 --> 00:09:07,820
strictly porting the code to arm 64

00:09:05,570 --> 00:09:10,100
making sure that it works when arm 64

00:09:07,820 --> 00:09:13,340
and if that's what people want to do

00:09:10,100 --> 00:09:14,780
then they will submit their code to the

00:09:13,340 --> 00:09:17,210
upstream developer the upstream

00:09:14,780 --> 00:09:19,910
developer will prove it and it will go

00:09:17,210 --> 00:09:22,040
into the code base at that point the

00:09:19,910 --> 00:09:25,790
person who did the work will have go

00:09:22,040 --> 00:09:28,640
into a contest drawling to be able to

00:09:25,790 --> 00:09:30,680
come to a Connect meeting or get some

00:09:28,640 --> 00:09:32,450
other type of prize and this will be

00:09:30,680 --> 00:09:35,990
done in the official rules stated

00:09:32,450 --> 00:09:38,600
official rules the second part is the

00:09:35,990 --> 00:09:41,210
performance part where we will have a

00:09:38,600 --> 00:09:43,940
contest to see who gets the greatest

00:09:41,210 --> 00:09:46,250
improvement in performance of the

00:09:43,940 --> 00:09:49,340
modules which they work on and this

00:09:46,250 --> 00:09:52,220
might be done by you know using more of

00:09:49,340 --> 00:09:54,440
the of the options of the compiler to

00:09:52,220 --> 00:09:56,120
make the compiler do the job better it

00:09:54,440 --> 00:09:58,840
may be something like replacing the

00:09:56,120 --> 00:10:01,850
algorithm with a more modern algorithm

00:09:58,840 --> 00:10:04,160
but what we don't want is we don't want

00:10:01,850 --> 00:10:07,610
any performance improvement to be at the

00:10:04,160 --> 00:10:09,110
detriment of some other architecture so

00:10:07,610 --> 00:10:11,090
we don't want people going as they oh I

00:10:09,110 --> 00:10:12,980
know I could do this great an arm but

00:10:11,090 --> 00:10:14,510
whenever we write the code is going to

00:10:12,980 --> 00:10:17,060
make Intel of terrible we don't want

00:10:14,510 --> 00:10:19,130
that we want this to improve the

00:10:17,060 --> 00:10:21,950
performance of canoe Linux across the

00:10:19,130 --> 00:10:25,250
board and we feel that this is a good

00:10:21,950 --> 00:10:27,260
thing for the canoe Linux community and

00:10:25,250 --> 00:10:29,720
we feel that it's something that can

00:10:27,260 --> 00:10:32,560
continue on into the future even after

00:10:29,720 --> 00:10:35,420
all the code is working when I'm 64

00:10:32,560 --> 00:10:38,210
there are many interesting pieces of

00:10:35,420 --> 00:10:40,700
hardware which are coming down field

00:10:38,210 --> 00:10:43,760
programmable gate arrays digital signal

00:10:40,700 --> 00:10:46,670
processing chips and we feel that these

00:10:43,760 --> 00:10:47,340
could be used to increase the

00:10:46,670 --> 00:10:49,920
performance

00:10:47,340 --> 00:10:52,260
the new linux systems dramatically if

00:10:49,920 --> 00:10:54,690
people really understood what they did

00:10:52,260 --> 00:10:57,810
and how to use them and particularly

00:10:54,690 --> 00:11:00,810
turn them over to high level languages

00:10:57,810 --> 00:11:04,110
which are completely developed to take

00:11:00,810 --> 00:11:07,260
advantage of these types of chips so

00:11:04,110 --> 00:11:11,160
this is the arm and linaro performance

00:11:07,260 --> 00:11:13,350
contest and we encourage you to take a

00:11:11,160 --> 00:11:15,660
look at this to read the rules and

00:11:13,350 --> 00:11:18,660
decide whether you wanted to participate

00:11:15,660 --> 00:11:20,400
in this weather you be a university or

00:11:18,660 --> 00:11:23,520
university student or professional

00:11:20,400 --> 00:11:27,180
programmer or whether it be an amateur

00:11:23,520 --> 00:11:30,380
programmer to be able to learn about

00:11:27,180 --> 00:11:33,060
this and to develop a portfolio of work

00:11:30,380 --> 00:11:35,700
that you have done because it's open

00:11:33,060 --> 00:11:39,210
source that you can show to prospective

00:11:35,700 --> 00:11:41,400
employers so there's a lot of reasons to

00:11:39,210 --> 00:11:43,380
participate in this particular contest

00:11:41,400 --> 00:11:46,610
and we hope to see you working with it

00:11:43,380 --> 00:11:46,610
thank you very much

00:11:52,209 --> 00:11:54,269

YouTube URL: https://www.youtube.com/watch?v=Lo1dBB3tke8


