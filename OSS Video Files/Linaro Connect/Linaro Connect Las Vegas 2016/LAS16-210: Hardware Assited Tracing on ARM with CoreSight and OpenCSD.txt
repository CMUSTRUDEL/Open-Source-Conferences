Title: LAS16-210: Hardware Assited Tracing on ARM with CoreSight and OpenCSD
Publication date: 2016-09-30
Playlist: Linaro Connect Las Vegas 2016
Description: 
	LAS16-210: Hardware Assisted Tracing on ARM with CoreSight and OpenCSD
Speakers: Mathieu Poirier
Date: September 27, 2016

★ Session Description ★
The CoreSight framework available in the Linux kernel has recently been integrated with the standard Perf trace system, making HW assisted tracing on ARM systems accessible to developers working on a wide spectrum of products. This presentation will start by giving a brief overview of the CoreSight technology itself before presenting the current solution, from trace collection in kernel space to off system trace decoding. To help with the latter part the Open CoreSight Decoding Library (openCSD) is introduced. OpenCSD is an open source library assisting with the decoding of collected trace data. We will see how it is used with the existing perf tools to provide an end-to-end solution for CoreSight trace decoding. The presentation will conclude with trace acquisition and decoding scenarios, along with tips on how to interpret trace information rendered by the perf tools.

★ Resources ★
Etherpad: pad.linaro.org/p/las16-210
Presentations & Videos: http://connect.linaro.org/resource/las16/las16-210/

★ Event Details ★
Linaro Connect Las Vegas 2016 – #LAS16
September 26-30, 2016
http://www.linaro.org
http://connect.linaro.org
Captions: 
	00:00:07,099 --> 00:00:11,099
right today we'll be talking about

00:00:09,090 --> 00:00:14,549
Hardware ease hardware-assisted tracing

00:00:11,099 --> 00:00:19,230
on arm SOC s using course site and the

00:00:14,549 --> 00:00:21,330
open coresight decoding library so the

00:00:19,230 --> 00:00:23,670
goal of the presentation today is not to

00:00:21,330 --> 00:00:26,460
show you exactly how things work under

00:00:23,670 --> 00:00:28,410
the hood but to give an overview of the

00:00:26,460 --> 00:00:31,619
an to end solution from trace

00:00:28,410 --> 00:00:33,570
acquisition to trace decoding with that

00:00:31,619 --> 00:00:35,940
the hope is that when you start working

00:00:33,570 --> 00:00:38,100
on course site on your own platform you

00:00:35,940 --> 00:00:41,790
will have an idea of of the terms that

00:00:38,100 --> 00:00:44,250
are involved and how a good overview of

00:00:41,790 --> 00:00:46,170
what the technology looks like so that

00:00:44,250 --> 00:00:47,640
way hopefully I will be easier to

00:00:46,170 --> 00:00:51,270
connect the dots because there's a lot

00:00:47,640 --> 00:00:54,690
of things to get right in order to do

00:00:51,270 --> 00:00:58,140
Trace acquisition with coresight so here

00:00:54,690 --> 00:01:00,719
today will mostly cover the integration

00:00:58,140 --> 00:01:02,789
that we have done with the the perf core

00:01:00,719 --> 00:01:04,890
so this is something that's been gone on

00:01:02,789 --> 00:01:10,409
going for a little while now and we have

00:01:04,890 --> 00:01:12,150
finished that earlier in the year so now

00:01:10,409 --> 00:01:14,360
as I said the the goal is to get you

00:01:12,150 --> 00:01:17,009
started quickly on your own platform

00:01:14,360 --> 00:01:18,750
with course site so we'll start with a

00:01:17,009 --> 00:01:20,909
brief overview of what the technology is

00:01:18,750 --> 00:01:23,189
from there we'll look at what is

00:01:20,909 --> 00:01:25,340
required to get coresight going on an

00:01:23,189 --> 00:01:29,670
SOC so there's a few things to look for

00:01:25,340 --> 00:01:31,650
in order for things to to work for you

00:01:29,670 --> 00:01:33,869
from there we'll introduce the open

00:01:31,650 --> 00:01:35,640
course I decoding library and it will

00:01:33,869 --> 00:01:42,450
end the presentation with trace

00:01:35,640 --> 00:01:45,210
acquisition and decoding scenarios so if

00:01:42,450 --> 00:01:46,829
you're looking online for a definition

00:01:45,210 --> 00:01:48,600
of what coresight is it's very likely

00:01:46,829 --> 00:01:50,970
that you're going to get lost there's a

00:01:48,600 --> 00:01:53,430
lot of material related to course site

00:01:50,970 --> 00:01:55,649
course site is basically the name given

00:01:53,430 --> 00:01:59,189
to an umbrella technology that covers

00:01:55,649 --> 00:02:02,280
all of the tracing needs of an SOC so

00:01:59,189 --> 00:02:03,360
everything from Hardware cyst is tracing

00:02:02,280 --> 00:02:06,390
something that we are concerned with

00:02:03,360 --> 00:02:10,560
here but you'll also find debugging with

00:02:06,390 --> 00:02:13,260
jtags all the way to a user space ide so

00:02:10,560 --> 00:02:14,849
what we want to concentrate on here

00:02:13,260 --> 00:02:19,200
ro is the specific part where

00:02:14,849 --> 00:02:21,689
hardware-assisted Tracy is concerned so

00:02:19,200 --> 00:02:24,599
the idea is to trace everything that a

00:02:21,689 --> 00:02:26,299
CPU is doing without impacting the

00:02:24,599 --> 00:02:32,430
processing that is happening on that

00:02:26,299 --> 00:02:34,620
that CPU there's no external hardware

00:02:32,430 --> 00:02:37,950
that is required to get that going so it

00:02:34,620 --> 00:02:41,310
basically gives you the power of a jtag

00:02:37,950 --> 00:02:44,189
without needing the external hardware

00:02:41,310 --> 00:02:45,780
dependencies so we've been working on

00:02:44,189 --> 00:02:48,000
this for a little while now we have been

00:02:45,780 --> 00:02:49,739
able to produce a set of drivers there's

00:02:48,000 --> 00:02:52,769
a framework that glues everything

00:02:49,739 --> 00:02:54,989
together and as I mentioned everything

00:02:52,769 --> 00:02:56,940
has been integrated with perf and all of

00:02:54,989 --> 00:02:58,829
the work that we have done that is

00:02:56,940 --> 00:03:02,190
related to the colonel side of the

00:02:58,829 --> 00:03:09,840
solution is found under drivers hardware

00:03:02,190 --> 00:03:13,049
tracing course site so hardware-assisted

00:03:09,840 --> 00:03:15,090
tracing works by coupling an IP block a

00:03:13,049 --> 00:03:17,790
course site IP block all an embedded

00:03:15,090 --> 00:03:20,730
trace macrocell so we coupled that with

00:03:17,790 --> 00:03:23,480
a cpu there's usually a one-to-one

00:03:20,730 --> 00:03:28,379
mapping between a macrocell and cpu and

00:03:23,480 --> 00:03:30,510
once configured there's no involvement

00:03:28,379 --> 00:03:33,359
that is required on behalf of the cpu

00:03:30,510 --> 00:03:35,160
wall traces are being collected as such

00:03:33,359 --> 00:03:42,810
we're not impacting the processing that

00:03:35,160 --> 00:03:45,359
is done on the unit itself so the idea

00:03:42,810 --> 00:03:47,340
here is we're saying no impact but when

00:03:45,359 --> 00:03:50,220
we're talking about a tray session one

00:03:47,340 --> 00:03:52,650
has to be mindful of the course site

00:03:50,220 --> 00:03:55,590
topology and the tray session that is

00:03:52,650 --> 00:03:56,970
currently ongoing for example if we're

00:03:55,590 --> 00:03:59,250
looking at a trace scenario that

00:03:56,970 --> 00:04:03,000
involves a lot of DMA transfers that we

00:03:59,250 --> 00:04:07,049
want to be careful to not select a sink

00:04:03,000 --> 00:04:10,109
that sends trace data from the course

00:04:07,049 --> 00:04:12,000
site framework to memory using DMA that

00:04:10,109 --> 00:04:13,829
way we would there would be contention

00:04:12,000 --> 00:04:17,370
on the bus and we would obviously impact

00:04:13,829 --> 00:04:19,470
processing so when doing looking at

00:04:17,370 --> 00:04:21,060
trade scenarios with course site one has

00:04:19,470 --> 00:04:22,979
to be mindful of what we're doing so

00:04:21,060 --> 00:04:24,690
what that scenario is and how we're

00:04:22,979 --> 00:04:26,940
handling the trace data that are then

00:04:24,690 --> 00:04:27,600
picked up in the sink buffer so there's

00:04:26,940 --> 00:04:30,480
always a way

00:04:27,600 --> 00:04:39,170
do not impact the processing units on on

00:04:30,480 --> 00:04:41,700
the CPU so this is a simple yet fairly

00:04:39,170 --> 00:04:44,550
representative depiction of what a

00:04:41,700 --> 00:04:47,490
coresight system is so on the far right

00:04:44,550 --> 00:04:51,030
we have the CPU cores and each CPU core

00:04:47,490 --> 00:04:53,520
is coupled with an e TM tracer the

00:04:51,030 --> 00:04:55,380
colors represent the different IDs that

00:04:53,520 --> 00:04:58,230
the tracers will be imitating packets

00:04:55,380 --> 00:05:01,410
with so once packet end up in a tray

00:04:58,230 --> 00:05:03,630
sync they're all enter wine everything's

00:05:01,410 --> 00:05:06,690
mixed up and we're using the trace IDs

00:05:03,630 --> 00:05:08,820
found in the packets in order to split

00:05:06,690 --> 00:05:11,370
the traces coming from different CPUs

00:05:08,820 --> 00:05:14,850
and that is then processed by the open

00:05:11,370 --> 00:05:16,260
coresight decoding library so fairly

00:05:14,850 --> 00:05:18,930
simple representation of what a

00:05:16,260 --> 00:05:23,840
coresight system is and yet accurate

00:05:18,930 --> 00:05:38,730
enough to give you a good representation

00:05:23,840 --> 00:05:43,110
yes what oh yeah yes you have two

00:05:38,730 --> 00:05:45,660
dimensions it so where is the time on so

00:05:43,110 --> 00:05:48,930
what where's the wet you have two

00:05:45,660 --> 00:05:53,880
dimension here you have a horizontal and

00:05:48,930 --> 00:05:56,700
vertical in the square box there's this

00:05:53,880 --> 00:05:59,250
here yes where is the time there's no

00:05:56,700 --> 00:06:01,980
time the squares represents a sink that

00:05:59,250 --> 00:06:03,840
accumulates the trace packets and the

00:06:01,980 --> 00:06:06,960
trace packets are all mixed up in the

00:06:03,840 --> 00:06:08,520
sink right because there's own typically

00:06:06,960 --> 00:06:09,960
right now in course site system it

00:06:08,520 --> 00:06:11,850
doesn't have to be this way but all the

00:06:09,960 --> 00:06:15,750
hardware is wired in such a way of that

00:06:11,850 --> 00:06:17,220
there's one sink for portray session so

00:06:15,750 --> 00:06:19,260
all the packets that are generated by

00:06:17,220 --> 00:06:21,510
the tracers end up in the same sink and

00:06:19,260 --> 00:06:23,070
using a trace IDs were able to

00:06:21,510 --> 00:06:25,880
differentiate the packets coming from

00:06:23,070 --> 00:06:25,880
different processors

00:06:30,880 --> 00:06:36,440
if you are looking for Coors Light

00:06:34,400 --> 00:06:38,570
online and throughout the documentation

00:06:36,440 --> 00:06:42,170
you will stumble a term called program

00:06:38,570 --> 00:06:45,440
flow trace so that's the name given to

00:06:42,170 --> 00:06:48,470
the format that of the trade stream

00:06:45,440 --> 00:06:51,200
generated by the tracers the idea here

00:06:48,470 --> 00:06:52,790
is simple so instead of recording all of

00:06:51,200 --> 00:06:55,060
the instructions that are executed by a

00:06:52,790 --> 00:06:59,240
cpu and produce a massive amount of data

00:06:55,060 --> 00:07:01,070
we simply record waypoints and waypoints

00:06:59,240 --> 00:07:03,490
are anything that makes an instruction

00:07:01,070 --> 00:07:06,310
pointer move from one address to another

00:07:03,490 --> 00:07:09,050
so that interrupts the flow of execution

00:07:06,310 --> 00:07:10,970
so if we have a range of instruction

00:07:09,050 --> 00:07:12,470
that starts here that goes there we

00:07:10,970 --> 00:07:14,420
don't have to record everything in

00:07:12,470 --> 00:07:16,190
between all we have to do is record

00:07:14,420 --> 00:07:17,480
where it starts and where the

00:07:16,190 --> 00:07:20,540
instruction pointer might have gone

00:07:17,480 --> 00:07:23,570
someplace else so with that we're saving

00:07:20,540 --> 00:07:26,180
a huge amount of space and we're able to

00:07:23,570 --> 00:07:29,600
collect as much data as possible so this

00:07:26,180 --> 00:07:31,460
is generated by the hardware and as I

00:07:29,600 --> 00:07:33,460
mentioned and will record waypoints so

00:07:31,460 --> 00:07:35,960
everything that moves the CPU around

00:07:33,460 --> 00:07:38,480
examples would be return instructions

00:07:35,960 --> 00:07:41,960
exceptions and some conditional branch

00:07:38,480 --> 00:07:44,000
instructions so we give those to the

00:07:41,960 --> 00:07:47,540
open CSD library that will see later in

00:07:44,000 --> 00:07:50,180
the session and we get back executed

00:07:47,540 --> 00:07:53,270
instruction ranges so ranges that the

00:07:50,180 --> 00:07:56,630
CPU has executed using the original

00:07:53,270 --> 00:08:00,350
program image we are able to make the

00:07:56,630 --> 00:08:02,810
ranges map and pick out the path that a

00:08:00,350 --> 00:08:04,580
CPU has taken through the code so we'll

00:08:02,810 --> 00:08:11,690
give you an example of exactly that

00:08:04,580 --> 00:08:15,950
later in the session so on a course site

00:08:11,690 --> 00:08:19,400
system so all of the components that are

00:08:15,950 --> 00:08:21,320
described in the reference manual are

00:08:19,400 --> 00:08:23,600
supported by the drivers that we have

00:08:21,320 --> 00:08:25,190
set out we also have a framework that

00:08:23,600 --> 00:08:27,560
links and connects everything together

00:08:25,190 --> 00:08:30,500
to make sure that there's an end to end

00:08:27,560 --> 00:08:33,590
pat between source and sink of the

00:08:30,500 --> 00:08:36,500
traces the only exceptions to that will

00:08:33,590 --> 00:08:38,270
be CTI so across trigger interface that

00:08:36,500 --> 00:08:40,370
Mike will start working on later this

00:08:38,270 --> 00:08:41,750
year that's an IP block that allows the

00:08:40,370 --> 00:08:44,870
synchronization

00:08:41,750 --> 00:08:48,110
of the course site blocks or devices in

00:08:44,870 --> 00:08:50,450
the system and there's itm so I TM is a

00:08:48,110 --> 00:08:52,850
predecessor of the tracers that we

00:08:50,450 --> 00:08:56,870
currently support if you end up having

00:08:52,850 --> 00:08:59,870
an IT em in your system I suggest to

00:08:56,870 --> 00:09:01,700
take start from the drivers that we have

00:08:59,870 --> 00:09:04,340
skim out everything that is not

00:09:01,700 --> 00:09:08,210
important and pretty easily you should

00:09:04,340 --> 00:09:10,850
have support for itm so I TM is a skim

00:09:08,210 --> 00:09:12,200
down version of the full-blown tracer

00:09:10,850 --> 00:09:14,690
it's an earlier generation of the

00:09:12,200 --> 00:09:17,660
full-blown tracer that we have that we

00:09:14,690 --> 00:09:21,050
currently support talking about support

00:09:17,660 --> 00:09:23,990
right now upstream we cover 32-bit and

00:09:21,050 --> 00:09:28,820
64-bit so between V expressed ec2 and

00:09:23,990 --> 00:09:30,950
Juneau we are covering a lot of the use

00:09:28,820 --> 00:09:35,000
cases or the topology that one would

00:09:30,950 --> 00:09:37,490
find on SOC s on the market so if you

00:09:35,000 --> 00:09:39,890
have an SOC simply look at the examples

00:09:37,490 --> 00:09:41,900
that we have provided for TC 2 and

00:09:39,890 --> 00:09:43,970
Juneau and with that you should have

00:09:41,900 --> 00:09:46,420
enough information to pick out how to

00:09:43,970 --> 00:09:49,010
organize things on your own system

00:09:46,420 --> 00:09:53,060
because everything is is different on

00:09:49,010 --> 00:09:55,280
every SOC all of the configuration has

00:09:53,060 --> 00:09:57,680
been pushed to the device tree so you

00:09:55,280 --> 00:10:03,080
list the coresight devices in the device

00:09:57,680 --> 00:10:07,670
tree along with the topology of the

00:10:03,080 --> 00:10:10,130
blocks on your specific system and with

00:10:07,670 --> 00:10:12,290
that if things like I've winds things

00:10:10,130 --> 00:10:13,760
have compile properly that's all that

00:10:12,290 --> 00:10:16,940
should be required to get the whole

00:10:13,760 --> 00:10:20,270
thing going so at a proper device tree

00:10:16,940 --> 00:10:26,480
and correct addresses things should just

00:10:20,270 --> 00:10:29,570
work as usual the devil is always in the

00:10:26,480 --> 00:10:31,100
details and coresight is no exception so

00:10:29,570 --> 00:10:34,010
you will have to keep in mind clocks and

00:10:31,100 --> 00:10:37,940
power management so of course I devices

00:10:34,010 --> 00:10:39,560
are always found on the amber bus so the

00:10:37,940 --> 00:10:42,170
Amba clock has to be listed in the

00:10:39,560 --> 00:10:44,839
device tree and manageable using the

00:10:42,170 --> 00:10:47,450
common clock API if you have that the

00:10:44,839 --> 00:10:49,070
the course I drivers will do the right

00:10:47,450 --> 00:10:51,500
thing with the clock enable it and

00:10:49,070 --> 00:10:52,730
disable it when it needs to use it so

00:10:51,500 --> 00:10:55,490
that part of the business should be

00:10:52,730 --> 00:10:58,640
fairly straightforward if as I said

00:10:55,490 --> 00:11:02,000
and you're a PB clock is is handled by

00:10:58,640 --> 00:11:04,570
the common clock API something through

00:11:02,000 --> 00:11:07,640
here to handle is the power domain

00:11:04,570 --> 00:11:09,800
simply because the blocks will be split

00:11:07,640 --> 00:11:11,750
in more than one power domain so

00:11:09,800 --> 00:11:14,720
everything that is not a tracer so we're

00:11:11,750 --> 00:11:17,000
talking about a funnel a replicator and

00:11:14,720 --> 00:11:20,240
all of the sinks those will typically be

00:11:17,000 --> 00:11:22,550
found in the debug power domain and all

00:11:20,240 --> 00:11:25,940
of the tree the the tracers the etm

00:11:22,550 --> 00:11:27,800
macrocell those will be sharing the same

00:11:25,940 --> 00:11:31,010
power domain that the CPUs they are

00:11:27,800 --> 00:11:34,790
coupled with so typically you'll have

00:11:31,010 --> 00:11:37,040
the tracers sharing the same power

00:11:34,790 --> 00:11:39,740
domain or the cluster power domain that

00:11:37,040 --> 00:11:41,930
the CPUs are also sharing and that is a

00:11:39,740 --> 00:11:45,080
problem simply because when cpu idle

00:11:41,930 --> 00:11:50,630
decides to put a tracer or a cpu to

00:11:45,080 --> 00:11:52,580
sleep power to that that paranoia might

00:11:50,630 --> 00:11:54,770
be switched off and everything that was

00:11:52,580 --> 00:11:57,709
happening as well in that power domain

00:11:54,770 --> 00:11:59,540
also goes away so everything all the

00:11:57,709 --> 00:12:04,040
configuration that we have trace data

00:11:59,540 --> 00:12:05,630
all that is lost so currently upstream

00:12:04,040 --> 00:12:08,510
there's no solution to synchronize

00:12:05,630 --> 00:12:12,350
operations in a power domain that is

00:12:08,510 --> 00:12:15,020
shared between a device and a cpu Linda

00:12:12,350 --> 00:12:17,180
is working on that she should have a

00:12:15,020 --> 00:12:19,730
solution very quickly but until that

00:12:17,180 --> 00:12:21,620
happens there's simply no other way to

00:12:19,730 --> 00:12:24,560
deal with this other than introducing

00:12:21,620 --> 00:12:26,540
your own synchronization mechanism now

00:12:24,560 --> 00:12:28,820
in that area i decided not to do

00:12:26,540 --> 00:12:31,040
anything for both reference platform i

00:12:28,820 --> 00:12:33,980
thought it was better to not do anything

00:12:31,040 --> 00:12:35,930
and see simply disable cpu idle when

00:12:33,980 --> 00:12:38,270
playing with course site that introduced

00:12:35,930 --> 00:12:40,790
a synchronization mechanism that is

00:12:38,270 --> 00:12:42,829
specific to ds2 platform then you would

00:12:40,790 --> 00:12:44,810
have to understand those take those away

00:12:42,829 --> 00:12:46,209
and introduced as your own so I just

00:12:44,810 --> 00:12:49,760
decided to leave things as they are

00:12:46,209 --> 00:12:54,410
disabled cpu idle and wait for the real

00:12:49,760 --> 00:12:56,089
solution to to be available so i

00:12:54,410 --> 00:12:58,250
definitely recommend that when you do

00:12:56,089 --> 00:13:00,079
start playing with coresight disabled

00:12:58,250 --> 00:13:03,260
cpu idle that will save you a lot of

00:13:00,079 --> 00:13:04,579
grief that way we'll get you going with

00:13:03,260 --> 00:13:06,770
the technology you'll understand how

00:13:04,579 --> 00:13:09,440
things work and once you're fairly

00:13:06,770 --> 00:13:11,360
stable and acquainted with the

00:13:09,440 --> 00:13:14,840
you can start thinking about how to

00:13:11,360 --> 00:13:17,210
synchronize operations in the power

00:13:14,840 --> 00:13:22,310
domain that is shared between the course

00:13:17,210 --> 00:13:24,020
site block and CPUs okay so let's say

00:13:22,310 --> 00:13:25,880
that we have either found a

00:13:24,020 --> 00:13:28,580
synchronization mechanism or we have

00:13:25,880 --> 00:13:31,520
disabled cpu idle everything works well

00:13:28,580 --> 00:13:33,200
in a device three the system boot all of

00:13:31,520 --> 00:13:36,980
the tracers will tell you that they are

00:13:33,200 --> 00:13:39,560
alive by printing out the successful

00:13:36,980 --> 00:13:43,100
initialization and the versions that

00:13:39,560 --> 00:13:45,530
they are so the top portion of the slide

00:13:43,100 --> 00:13:48,230
represents Juno booting so on Juno there

00:13:45,530 --> 00:13:52,960
are six CPUs all as the CPUs are fitted

00:13:48,230 --> 00:13:56,090
with me TM for tracer the bottom part is

00:13:52,960 --> 00:13:58,820
all of the devices that have been found

00:13:56,090 --> 00:14:01,370
at boot time are listed under the course

00:13:58,820 --> 00:14:03,590
ID block under sis FS so if you don't

00:14:01,370 --> 00:14:05,060
have access to the device three or you

00:14:03,590 --> 00:14:07,040
don't know or don't remember the

00:14:05,060 --> 00:14:09,020
addresses or how you name your devices

00:14:07,040 --> 00:14:12,170
simply look at the devices that were

00:14:09,020 --> 00:14:14,060
discovered under sis FS and you should

00:14:12,170 --> 00:14:18,190
be set so that doesn't go away it's

00:14:14,060 --> 00:14:18,190
always present its static in the system

00:14:21,040 --> 00:14:25,850
so now that we had drivers and a

00:14:23,780 --> 00:14:28,400
framework we recognize pretty quickly

00:14:25,850 --> 00:14:30,020
that configuring coresight was very

00:14:28,400 --> 00:14:32,570
difficult so there are dozens of

00:14:30,020 --> 00:14:36,410
registers to get right just for even the

00:14:32,570 --> 00:14:40,040
most simple session so integrating with

00:14:36,410 --> 00:14:41,780
something like perf was desirable

00:14:40,040 --> 00:14:44,750
because perf is already geared toward

00:14:41,780 --> 00:14:49,220
tracing its ubiquitous people know about

00:14:44,750 --> 00:14:51,530
it and it hides a lot of complexity that

00:14:49,220 --> 00:14:54,680
people shouldn't be dealing with or just

00:14:51,530 --> 00:14:56,540
to get harder tourism going so we hide a

00:14:54,680 --> 00:14:58,700
lot of the complexity behind perf and

00:14:56,540 --> 00:15:02,000
whatever is not handled by perf we

00:14:58,700 --> 00:15:05,420
simply push to open CSD and that way

00:15:02,000 --> 00:15:07,370
there's very little i can't say

00:15:05,420 --> 00:15:09,200
knowledge but there's very little that

00:15:07,370 --> 00:15:12,980
people need to know in order to quickly

00:15:09,200 --> 00:15:15,500
get started with quartzite how we did

00:15:12,980 --> 00:15:17,240
this so when we're talking about perf

00:15:15,500 --> 00:15:19,070
there's this concept of performance

00:15:17,240 --> 00:15:21,920
management unit or monitoring unit i

00:15:19,070 --> 00:15:23,180
should say so what we did is represent

00:15:21,920 --> 00:15:26,870
or tracers as

00:15:23,180 --> 00:15:28,280
p mu to the perf core from there perf is

00:15:26,870 --> 00:15:30,680
simply not aware that it's using

00:15:28,280 --> 00:15:32,780
coresight it's like any other tracer you

00:15:30,680 --> 00:15:34,940
hide the functionality or the hardware

00:15:32,780 --> 00:15:36,710
specific bits behind interfaces of

00:15:34,940 --> 00:15:40,640
refined an operation structure and the

00:15:36,710 --> 00:15:43,280
perf core just works seamlessly that

00:15:40,640 --> 00:15:45,920
also allows us to control very tightly

00:15:43,280 --> 00:15:48,620
when the tracers will start and stop

00:15:45,920 --> 00:15:50,840
tracing that way you're not impacting by

00:15:48,620 --> 00:15:52,910
all of the background noise that is also

00:15:50,840 --> 00:15:55,010
happening in the system at the same time

00:15:52,910 --> 00:15:57,260
you're only picking up the traces that

00:15:55,010 --> 00:16:01,330
pertain to that specific session or

00:15:57,260 --> 00:16:04,310
process that you're that you're tracing

00:16:01,330 --> 00:16:07,250
so there's no interaction that is

00:16:04,310 --> 00:16:09,740
required from the users to get that

00:16:07,250 --> 00:16:11,960
process going so when the course I

00:16:09,740 --> 00:16:15,050
framework gets initialized at boot time

00:16:11,960 --> 00:16:16,910
it will simply register this new PM you

00:16:15,050 --> 00:16:18,980
with the perf core and from there

00:16:16,910 --> 00:16:22,640
everything is available using the perf

00:16:18,980 --> 00:16:24,380
tool on the command line CSE TM is

00:16:22,640 --> 00:16:28,030
denene that we have given to that you PM

00:16:24,380 --> 00:16:30,890
you and this is lista B'Elanna system

00:16:28,030 --> 00:16:32,090
with all of the rest of the events so

00:16:30,890 --> 00:16:35,780
all of the events that have been

00:16:32,090 --> 00:16:38,180
configured on at compile time in the

00:16:35,780 --> 00:16:42,890
kernel are found under cyst bus

00:16:38,180 --> 00:16:44,900
eventsource devices so you also find

00:16:42,890 --> 00:16:47,300
there as I mentioned because it's

00:16:44,900 --> 00:16:50,600
registers seamlessly by the core at boot

00:16:47,300 --> 00:16:53,450
time the cs and the score event and in

00:16:50,600 --> 00:16:57,140
there all of the typical entries for a

00:16:53,450 --> 00:16:59,540
PM you along with a symbolic link for

00:16:57,140 --> 00:17:03,080
each of the CPUs that you have in the

00:16:59,540 --> 00:17:04,580
system we did this because from a perf

00:17:03,080 --> 00:17:08,660
tool point of view there's no way to

00:17:04,580 --> 00:17:11,990
correlate a cpu with a tracer that way

00:17:08,660 --> 00:17:14,030
what a symbolic link we simply no the

00:17:11,990 --> 00:17:15,560
cpu we are working with we look at the

00:17:14,030 --> 00:17:19,930
symbolic link and right there we have

00:17:15,560 --> 00:17:19,930
the configure bowls for tracer

00:17:22,910 --> 00:17:26,870
so with that we've pretty much covered

00:17:24,590 --> 00:17:28,790
all of the colonel side of the solution

00:17:26,870 --> 00:17:30,680
there's not a whole lot of material

00:17:28,790 --> 00:17:33,980
there but everything is in like like has

00:17:30,680 --> 00:17:35,600
its functionality with this we

00:17:33,980 --> 00:17:38,110
introduced the open course decoding

00:17:35,600 --> 00:17:42,800
library so that's a joint effort between

00:17:38,110 --> 00:17:46,520
arm texas instrument and linaro to

00:17:42,800 --> 00:17:48,830
basically bring the capability to decode

00:17:46,520 --> 00:17:52,100
any coresight traces generated by the

00:17:48,830 --> 00:17:54,920
framework by with a standalone library

00:17:52,100 --> 00:17:58,010
so open CSD doesn't need anything to

00:17:54,920 --> 00:18:01,820
work it just works by itself all right

00:17:58,010 --> 00:18:05,780
it's on github it's public right now the

00:18:01,820 --> 00:18:09,680
the format's that we support our ATM v3

00:18:05,780 --> 00:18:11,660
ATM before PTM and there's also support

00:18:09,680 --> 00:18:14,980
for the me p protocol which is the

00:18:11,660 --> 00:18:18,740
output that we get from the SDM

00:18:14,980 --> 00:18:20,780
coresight block that too as i mentioned

00:18:18,740 --> 00:18:22,670
earlier has been integrated with perf so

00:18:20,780 --> 00:18:25,400
if you want to get going quickly or have

00:18:22,670 --> 00:18:29,630
a example of how this can be integrated

00:18:25,400 --> 00:18:32,740
into your own tracing solution simply

00:18:29,630 --> 00:18:35,510
look at what we've done and you'll have

00:18:32,740 --> 00:18:38,720
you'll get an example of how things can

00:18:35,510 --> 00:18:41,300
be done if you want an in-depth

00:18:38,720 --> 00:18:43,790
presentation or information on how the

00:18:41,300 --> 00:18:46,310
library works mike has written a very

00:18:43,790 --> 00:18:49,250
good blog post earlier this summer on

00:18:46,310 --> 00:18:53,090
the narrow score duck blog so the link

00:18:49,250 --> 00:18:55,190
is there that will get you a lot of

00:18:53,090 --> 00:18:59,390
information on how the internal of the

00:18:55,190 --> 00:19:01,790
library works and it should get you a

00:18:59,390 --> 00:19:06,620
good point as I mentioned if you want to

00:19:01,790 --> 00:19:08,960
rule out your own decoding solution okay

00:19:06,620 --> 00:19:10,340
so we have drivers we have a framework

00:19:08,960 --> 00:19:12,530
that connects the whole thing together

00:19:10,340 --> 00:19:16,120
everything has been integrated with perf

00:19:12,530 --> 00:19:18,590
we also have a library to decode traces

00:19:16,120 --> 00:19:22,280
we basically have everything we need to

00:19:18,590 --> 00:19:24,110
start doing our trade sessions so

00:19:22,280 --> 00:19:27,770
putting it together is not really hard

00:19:24,110 --> 00:19:29,320
there's just a few steps to follow what

00:19:27,770 --> 00:19:31,760
we know only need to get things right

00:19:29,320 --> 00:19:35,990
the first thing to do is to start with

00:19:31,760 --> 00:19:36,410
the open CSD library on github please

00:19:35,990 --> 00:19:37,940
stick with

00:19:36,410 --> 00:19:40,430
master branch that's where we have our

00:19:37,940 --> 00:19:42,230
code nowadays all of this stable

00:19:40,430 --> 00:19:45,550
revisions are tagged so that works

00:19:42,230 --> 00:19:49,190
exactly like the mainline kernel and

00:19:45,550 --> 00:19:51,590
there's also a how-to there we put a lot

00:19:49,190 --> 00:19:54,080
of time and effort and how to read to

00:19:51,590 --> 00:19:55,430
how to it explains how to compile

00:19:54,080 --> 00:19:58,370
everything how to put everything

00:19:55,430 --> 00:20:02,620
together it also gives you extensive

00:19:58,370 --> 00:20:07,280
information on how to use the technology

00:20:02,620 --> 00:20:09,830
by giving you examples for that specific

00:20:07,280 --> 00:20:12,080
colonel revision so I emphasize on

00:20:09,830 --> 00:20:14,420
Colonel revision because the perf tools

00:20:12,080 --> 00:20:16,130
are not all upstream and if you're

00:20:14,420 --> 00:20:17,690
looking at the amount of patches that

00:20:16,130 --> 00:20:19,090
are going into perf tool with every

00:20:17,690 --> 00:20:21,620
kernel revision it's just it's

00:20:19,090 --> 00:20:24,950
astonishing so last time I checked was

00:20:21,620 --> 00:20:26,870
800 patches so with that because our as

00:20:24,950 --> 00:20:29,000
I mentioned our code is not all upstream

00:20:26,870 --> 00:20:31,370
the solution kind of moves in user space

00:20:29,000 --> 00:20:34,370
based on the things the churn that is

00:20:31,370 --> 00:20:37,180
going in so each kernel revision weary

00:20:34,370 --> 00:20:39,980
base the patches we make sure that

00:20:37,180 --> 00:20:41,930
things are working maybe adjust a few

00:20:39,980 --> 00:20:44,810
things along the way so that's why right

00:20:41,930 --> 00:20:48,290
now we still keep colonel revision along

00:20:44,810 --> 00:20:51,650
with the versions of the open CSD

00:20:48,290 --> 00:20:54,080
library so this is just temporary we

00:20:51,650 --> 00:20:55,790
will be dealing with this the process

00:20:54,080 --> 00:20:58,100
has already started it's just a matter

00:20:55,790 --> 00:21:03,620
of time before everything is upstream

00:20:58,100 --> 00:21:06,290
and available ok so you download the

00:21:03,620 --> 00:21:09,290
revision of the library latest and

00:21:06,290 --> 00:21:11,660
greatest simply follow the how-to I'm

00:21:09,290 --> 00:21:13,370
explaining this slide here because it's

00:21:11,660 --> 00:21:17,360
easy to miss a lot of people have missed

00:21:13,370 --> 00:21:19,520
it so because perf or the the open CSD

00:21:17,360 --> 00:21:22,040
library is standalone we need to tell

00:21:19,520 --> 00:21:24,560
the perf tools where to find the the

00:21:22,040 --> 00:21:27,350
capability to deal with course I traces

00:21:24,560 --> 00:21:31,030
and we do that by compiling the library

00:21:27,350 --> 00:21:33,860
and using an environment variable so CS

00:21:31,030 --> 00:21:37,280
trace on the score path that points to

00:21:33,860 --> 00:21:41,360
where the SOS are so with that if

00:21:37,280 --> 00:21:44,660
everything the the perf tools linking

00:21:41,360 --> 00:21:46,520
script will look for the SOS link the

00:21:44,660 --> 00:21:48,890
functionality and everything works

00:21:46,520 --> 00:21:50,269
properly you will end up with what we

00:21:48,890 --> 00:21:53,419
see at the bottom this

00:21:50,269 --> 00:21:55,549
CS e TM decoder if something is wrong or

00:21:53,419 --> 00:21:57,379
you're not using the open CSD library

00:21:55,549 --> 00:21:59,359
you'll end up with the stubs and

00:21:57,379 --> 00:22:01,820
obviously you can't decode anything with

00:21:59,359 --> 00:22:03,499
that but the perf tools the compilation

00:22:01,820 --> 00:22:05,889
of the perf tool will still be

00:22:03,499 --> 00:22:08,719
successful so again when you are

00:22:05,889 --> 00:22:11,149
integrating with the open CSD library

00:22:08,719 --> 00:22:13,820
when compiling the perf tools always

00:22:11,149 --> 00:22:16,029
make sure that you hits CSC TM decoder

00:22:13,820 --> 00:22:21,309
that will be a proof that you got the

00:22:16,029 --> 00:22:21,309
required capability to decode the traces

00:22:21,969 --> 00:22:28,419
so because we have integrated with the

00:22:24,829 --> 00:22:31,489
pmu framework so using that from the

00:22:28,419 --> 00:22:34,700
proof tools is like using any other

00:22:31,489 --> 00:22:37,159
tracer so the top line perf perfect

00:22:34,700 --> 00:22:40,039
chord dash e the name of the event the

00:22:37,159 --> 00:22:43,190
specifics for that session and how you

00:22:40,039 --> 00:22:45,649
want to trace the process on that for

00:22:43,190 --> 00:22:48,320
that specific session so when we're

00:22:45,649 --> 00:22:52,059
looking at the most simple form for

00:22:48,320 --> 00:22:54,919
course light so perfect chord e CS e TM

00:22:52,059 --> 00:22:57,919
the name of this sink where we want to

00:22:54,919 --> 00:23:00,409
see the trace data go to and the

00:22:57,919 --> 00:23:04,009
specifics for the process again I

00:23:00,409 --> 00:23:07,129
emphasize on the course I've devices on

00:23:04,009 --> 00:23:09,019
the system are on there sis FS so simply

00:23:07,129 --> 00:23:12,649
take a name from there put it into the

00:23:09,019 --> 00:23:15,139
configuration area and from there perf

00:23:12,649 --> 00:23:17,059
and the core framework will do all the

00:23:15,139 --> 00:23:18,739
configuration along with the linking

00:23:17,059 --> 00:23:21,289
between the course I've devices that are

00:23:18,739 --> 00:23:29,239
required for a trade session to go

00:23:21,289 --> 00:23:31,399
smoothly when we're talking about

00:23:29,239 --> 00:23:34,339
hardware-assisted tracing course like no

00:23:31,399 --> 00:23:36,649
exception there's a huge amount of data

00:23:34,339 --> 00:23:38,779
that it gets collected so it's important

00:23:36,649 --> 00:23:43,179
to skim out the portion that we're not

00:23:38,779 --> 00:23:45,429
interested a really zero in on what's is

00:23:43,179 --> 00:23:48,139
relevant for that specific session

00:23:45,429 --> 00:23:51,409
there's a few ways of doing this the

00:23:48,139 --> 00:23:54,979
first that we'll be looking at is using

00:23:51,409 --> 00:23:58,249
the mechanism that the perf core gives

00:23:54,979 --> 00:24:01,369
us so by adding a you or a que at the

00:23:58,249 --> 00:24:03,690
end of specific options for each event

00:24:01,369 --> 00:24:06,509
we're able to I

00:24:03,690 --> 00:24:08,549
too late races that specific area so if

00:24:06,509 --> 00:24:10,559
we add a you we're using traces we're

00:24:08,549 --> 00:24:12,870
getting traces only in user space if we

00:24:10,559 --> 00:24:14,970
have a k we're only getting Colonel

00:24:12,870 --> 00:24:18,080
spaces alright if you're not doing

00:24:14,970 --> 00:24:21,600
anything then the whole thing is traced

00:24:18,080 --> 00:24:23,419
even with that we recognize that we

00:24:21,600 --> 00:24:26,039
still had way too much information and

00:24:23,419 --> 00:24:29,309
decided to introduce the notion of

00:24:26,039 --> 00:24:31,769
filters so filters on perf is already

00:24:29,309 --> 00:24:34,110
available for trace point events the

00:24:31,769 --> 00:24:37,879
scheme was simply enhanced to

00:24:34,110 --> 00:24:40,320
accommodate filters for Hardware tracers

00:24:37,879 --> 00:24:42,600
there's two types that we've introduced

00:24:40,320 --> 00:24:46,559
address range filters and start top

00:24:42,600 --> 00:24:51,539
filters so the first example here

00:24:46,559 --> 00:24:53,879
address range filters basically add the

00:24:51,539 --> 00:24:57,509
dash dash filter so that's a perfect and

00:24:53,879 --> 00:24:59,669
after that you specify the filter that

00:24:57,509 --> 00:25:02,250
you want to use so in this case here the

00:24:59,669 --> 00:25:04,110
keyword filter was added so that was not

00:25:02,250 --> 00:25:05,580
my favorite choice I would have liked to

00:25:04,110 --> 00:25:08,190
have range but when you're working

00:25:05,580 --> 00:25:11,490
upstream you can't have your way all the

00:25:08,190 --> 00:25:13,500
time so filter it is you specify where

00:25:11,490 --> 00:25:17,340
you want to start from and then how many

00:25:13,500 --> 00:25:19,440
bite to to trace so using the K option

00:25:17,340 --> 00:25:21,720
the address that you will have there is

00:25:19,440 --> 00:25:23,460
specifically are its pickly something

00:25:21,720 --> 00:25:25,850
that you would find in the system dot

00:25:23,460 --> 00:25:28,500
map file when the colonel gets generated

00:25:25,850 --> 00:25:30,480
so in user space it's a little bit

00:25:28,500 --> 00:25:32,519
different so again we have our dash dash

00:25:30,480 --> 00:25:34,679
filter we're using an address for filter

00:25:32,519 --> 00:25:39,379
so we're having the the filter keyword

00:25:34,679 --> 00:25:42,090
so the 0 70 to see here is a relocatable

00:25:39,379 --> 00:25:44,850
that you would typically find on the

00:25:42,090 --> 00:25:46,259
output of object dump alright so that's

00:25:44,850 --> 00:25:48,870
the offset from the beginning of the

00:25:46,259 --> 00:25:51,919
binary again how many bytes want to

00:25:48,870 --> 00:25:55,679
start you want to trace for and we add

00:25:51,919 --> 00:25:59,070
the complete pass to the library on the

00:25:55,679 --> 00:26:01,529
system library or binary so well that is

00:25:59,070 --> 00:26:04,169
used is correlated with the information

00:26:01,529 --> 00:26:06,090
that we get in the perf data file that

00:26:04,169 --> 00:26:11,039
pertains to the mapping of the events in

00:26:06,090 --> 00:26:12,690
memory ok so when we're dealing with

00:26:11,039 --> 00:26:14,940
address range filter if we have

00:26:12,690 --> 00:26:16,710
obviously our range so it starts here it

00:26:14,940 --> 00:26:17,200
stops there but if the instruction

00:26:16,710 --> 00:26:19,210
pointer

00:26:17,200 --> 00:26:21,279
happens to move out of that range to go

00:26:19,210 --> 00:26:23,250
do something else where everything that

00:26:21,279 --> 00:26:25,899
happened elsewhere will not be traced

00:26:23,250 --> 00:26:28,059
tracing will resume when the instruction

00:26:25,899 --> 00:26:30,789
pointer comes back into the range that

00:26:28,059 --> 00:26:34,480
was specified so that's for the address

00:26:30,789 --> 00:26:36,039
range filtering we're looking at start

00:26:34,480 --> 00:26:39,940
and stop filtering if we take our

00:26:36,039 --> 00:26:43,899
example again everything that the traces

00:26:39,940 --> 00:26:45,309
will be generated when you start when

00:26:43,899 --> 00:26:47,309
the instruction pointer is equal to the

00:26:45,309 --> 00:26:50,649
start address and we'll stop when

00:26:47,309 --> 00:26:52,120
obviously equal to the stop address so

00:26:50,649 --> 00:26:53,860
everything that happened in between

00:26:52,120 --> 00:26:56,649
whether it's in that function or not

00:26:53,860 --> 00:26:58,480
gets traced as well so there's a lot

00:26:56,649 --> 00:27:00,279
it's a lot more inclusive but also has

00:26:58,480 --> 00:27:04,149
the potential to generate a lot of

00:27:00,279 --> 00:27:06,010
information so by combining or by

00:27:04,149 --> 00:27:09,100
refining a tray session with these two

00:27:06,010 --> 00:27:10,690
filters it's fairly easy to go down to

00:27:09,100 --> 00:27:12,880
the portion of the code that you're

00:27:10,690 --> 00:27:14,500
really interested in so here we have

00:27:12,880 --> 00:27:15,970
again our dash dash filter the

00:27:14,500 --> 00:27:17,440
specification of the filter is a little

00:27:15,970 --> 00:27:19,600
bit different we have the start and stop

00:27:17,440 --> 00:27:21,519
so that's fairly obvious what I'd like

00:27:19,600 --> 00:27:23,710
to bring attention to is the bottom

00:27:21,519 --> 00:27:26,260
example where have decided to start

00:27:23,710 --> 00:27:29,139
tracing in one library and stopped

00:27:26,260 --> 00:27:31,299
racing in a different binary so that's

00:27:29,139 --> 00:27:33,880
on purpose right it's just to show how

00:27:31,299 --> 00:27:36,669
flexible this scheme is right there's no

00:27:33,880 --> 00:27:38,950
real restriction on the address or the

00:27:36,669 --> 00:27:42,370
range that you can trace if the address

00:27:38,950 --> 00:27:47,549
exist and the binary is available in a

00:27:42,370 --> 00:27:49,690
system you can trace it the only

00:27:47,549 --> 00:27:52,029
limitation that we have with address

00:27:49,690 --> 00:27:54,010
filters is that we cannot use address

00:27:52,029 --> 00:27:56,440
range filtering and start/stop filters

00:27:54,010 --> 00:27:58,630
in the same session we've decided to

00:27:56,440 --> 00:28:01,690
keep that separately for now okay and

00:27:58,630 --> 00:28:03,970
there's also the amount of address

00:28:01,690 --> 00:28:07,690
comparators that are implemented on that

00:28:03,970 --> 00:28:09,549
specific SOC so address comparators the

00:28:07,690 --> 00:28:12,909
amount of address comparators will give

00:28:09,549 --> 00:28:14,950
you how many filters you can use for

00:28:12,909 --> 00:28:16,630
that specific trade session so at one

00:28:14,950 --> 00:28:18,159
point if everything goes well you're

00:28:16,630 --> 00:28:19,870
tracing and then the next straight

00:28:18,159 --> 00:28:21,669
session you decided to add a filter and

00:28:19,870 --> 00:28:23,230
you get an error that means that you've

00:28:21,669 --> 00:28:26,700
exhausted the amount of filters that the

00:28:23,230 --> 00:28:26,700
hardware is capable of supporting

00:28:29,000 --> 00:28:35,340
okay so let's start looking at the

00:28:32,880 --> 00:28:37,350
decoding part of the business so

00:28:35,340 --> 00:28:39,659
everything is working with perf we have

00:28:37,350 --> 00:28:41,789
a trace session because we are using the

00:28:39,659 --> 00:28:44,190
per frame work all of the trace data

00:28:41,789 --> 00:28:46,320
along with all of the events that happen

00:28:44,190 --> 00:28:49,320
during a session will end up in the perv

00:28:46,320 --> 00:28:53,700
beta file so this is nothing new we've

00:28:49,320 --> 00:28:56,610
added samples to the data that were

00:28:53,700 --> 00:28:59,460
collected by listing the packets that

00:28:56,610 --> 00:29:01,200
were gathered during the session so if

00:28:59,460 --> 00:29:02,580
you are starting with course I you want

00:29:01,200 --> 00:29:04,950
to know if something happened during

00:29:02,580 --> 00:29:07,260
that trace session simply dump the

00:29:04,950 --> 00:29:09,090
content of the birth beta file and in

00:29:07,260 --> 00:29:10,890
there at the very bottom you'll see all

00:29:09,090 --> 00:29:13,710
of the packets that were generated for

00:29:10,890 --> 00:29:15,630
that session now packets themself don't

00:29:13,710 --> 00:29:16,950
give you much in terms of what happened

00:29:15,630 --> 00:29:19,080
it just tells you that something has

00:29:16,950 --> 00:29:21,210
happened it's a good debugging tool to

00:29:19,080 --> 00:29:27,230
tell whether something is alive or

00:29:21,210 --> 00:29:30,029
coresight is alive on your system so

00:29:27,230 --> 00:29:32,039
from here on will explode will go over

00:29:30,029 --> 00:29:34,529
the rest of the material using this very

00:29:32,039 --> 00:29:36,450
simple example so what we'll do is we'll

00:29:34,529 --> 00:29:38,909
have a little main that calls a function

00:29:36,450 --> 00:29:40,679
in the library somewhere and that

00:29:38,909 --> 00:29:43,289
function simply I traits over a

00:29:40,679 --> 00:29:46,169
parameter and returns the value that it

00:29:43,289 --> 00:29:48,360
has added so the idea here is that we

00:29:46,169 --> 00:29:51,419
have a main we're tracing the main but

00:29:48,360 --> 00:29:54,570
we only gather statistics and trace data

00:29:51,419 --> 00:29:57,929
for what's happening in the library on

00:29:54,570 --> 00:30:00,000
the system so very simple and yet fairly

00:29:57,929 --> 00:30:05,250
close to what people might want to do in

00:30:00,000 --> 00:30:07,620
terms of tracing and user space so the

00:30:05,250 --> 00:30:10,130
first thing is to get a handle on our

00:30:07,620 --> 00:30:13,500
library called object dump on it and

00:30:10,130 --> 00:30:15,360
look for coresight test one so we take

00:30:13,500 --> 00:30:18,350
that address how many bytes you want to

00:30:15,360 --> 00:30:22,500
start from one you want to trace for and

00:30:18,350 --> 00:30:24,539
you feed that into our command line so

00:30:22,500 --> 00:30:27,270
the middle of the screen there we have

00:30:24,539 --> 00:30:30,799
the same call that we've had that we've

00:30:27,270 --> 00:30:34,620
seen earlier in a session and we are

00:30:30,799 --> 00:30:37,140
asking Perth to record everything in the

00:30:34,620 --> 00:30:39,690
library in the process mean on all of

00:30:37,140 --> 00:30:41,970
the CPUs that the scheduler decides to

00:30:39,690 --> 00:30:44,280
put that process for that session

00:30:41,970 --> 00:30:46,140
so perf will go about doing its business

00:30:44,280 --> 00:30:49,200
it will do the configuration it will

00:30:46,140 --> 00:30:52,320
also start tracing when the process gets

00:30:49,200 --> 00:30:55,650
scheduled by the system and in the end

00:30:52,320 --> 00:30:57,330
you will end up with a trace data in the

00:30:55,650 --> 00:31:02,280
perfect OPP datafile and here we have

00:30:57,330 --> 00:31:04,560
collected about 8k of trace data now

00:31:02,280 --> 00:31:06,690
it's possible to do trace data or to

00:31:04,560 --> 00:31:08,940
decode the trace data on the system but

00:31:06,690 --> 00:31:10,380
typically what people will do is package

00:31:08,940 --> 00:31:14,420
everything that was collecting during

00:31:10,380 --> 00:31:17,580
that session feed that on to a host

00:31:14,420 --> 00:31:20,810
elsewhere and do to trace decoding there

00:31:17,580 --> 00:31:24,720
which is what we'll be doing here so

00:31:20,810 --> 00:31:27,300
obviously perfect data is important for

00:31:24,720 --> 00:31:30,000
trace decompression but also the dot

00:31:27,300 --> 00:31:33,630
debug directory so why did that debug

00:31:30,000 --> 00:31:36,720
directly what did that do in there is

00:31:33,630 --> 00:31:39,480
all of the libraries and binaries that

00:31:36,720 --> 00:31:42,420
were involved in the tray session so

00:31:39,480 --> 00:31:44,970
this is inherent to perf this is one of

00:31:42,420 --> 00:31:48,420
the advantages of using perf so we don't

00:31:44,970 --> 00:31:49,920
have to guess all of the binaries or

00:31:48,420 --> 00:31:52,170
libraries that were involved in this

00:31:49,920 --> 00:31:54,480
session everything is collected for us

00:31:52,170 --> 00:31:56,580
by perf the only thing you have to do is

00:31:54,480 --> 00:31:58,410
harvested up the bug director you

00:31:56,580 --> 00:32:00,710
package that with the trace data and

00:31:58,410 --> 00:32:05,730
you're all set you'll be able to do the

00:32:00,710 --> 00:32:07,440
decompression off the target so here we

00:32:05,730 --> 00:32:09,150
have our kernel symbol so that's the

00:32:07,440 --> 00:32:12,440
exact same thing that you would find in

00:32:09,150 --> 00:32:15,570
the system map file you have the VDS oh

00:32:12,440 --> 00:32:20,400
the main was involved we have the loader

00:32:15,570 --> 00:32:23,100
obviously lipsy and on top on the the

00:32:20,400 --> 00:32:25,860
right side the lib test okay so all of

00:32:23,100 --> 00:32:29,910
this is gathered by purse so you don't

00:32:25,860 --> 00:32:31,770
have to do anything else there so when

00:32:29,910 --> 00:32:34,950
we're off system the first thing to do

00:32:31,770 --> 00:32:39,090
once we've extracted our trace bundle is

00:32:34,950 --> 00:32:41,730
to usually call the perf report so perf

00:32:39,090 --> 00:32:44,310
report will give you a flame graph of

00:32:41,730 --> 00:32:49,680
the hot spot that were hit during the

00:32:44,310 --> 00:32:54,150
trace session now perf report is already

00:32:49,680 --> 00:32:55,470
included into the the perf tools and

00:32:54,150 --> 00:32:59,130
it's highly

00:32:55,470 --> 00:33:01,710
generic as such it will give you or it

00:32:59,130 --> 00:33:03,600
will do the report based on the the

00:33:01,710 --> 00:33:05,159
start of the address range it doesn't

00:33:03,600 --> 00:33:07,080
tell you anything about what happened in

00:33:05,159 --> 00:33:11,100
that range or where that range ended

00:33:07,080 --> 00:33:12,539
right so for that we need to look at we

00:33:11,100 --> 00:33:14,610
need to the compressed races further

00:33:12,539 --> 00:33:16,950
well trace report is a good place to

00:33:14,610 --> 00:33:18,990
start but it's only giving us a portion

00:33:16,950 --> 00:33:26,070
of what really happened during the

00:33:18,990 --> 00:33:29,400
session for that perf script is the next

00:33:26,070 --> 00:33:31,110
step up so in its simplest form / script

00:33:29,400 --> 00:33:34,169
will give us the ranges though were

00:33:31,110 --> 00:33:37,260
executed by a cpu so the address in blue

00:33:34,169 --> 00:33:39,539
are the relocatable addresses that we

00:33:37,260 --> 00:33:41,490
have seen in the object dump output

00:33:39,539 --> 00:33:43,289
earlier so if you look at these

00:33:41,490 --> 00:33:45,690
addresses and you follow the assembly

00:33:43,289 --> 00:33:49,470
language that we've had you'll see

00:33:45,690 --> 00:33:53,460
exactly how that loop was added or was

00:33:49,470 --> 00:33:56,610
done in the function the left part of

00:33:53,460 --> 00:34:00,390
the address is where the library was

00:33:56,610 --> 00:34:04,400
mapped in memory by the loader at

00:34:00,390 --> 00:34:08,129
runtime and this is given to us by the

00:34:04,400 --> 00:34:09,690
Ricker the perf the M map to record that

00:34:08,129 --> 00:34:14,580
are embedded in the perf thought data

00:34:09,690 --> 00:34:17,129
file so using the name of the binary we

00:34:14,580 --> 00:34:19,200
are able to get the address we add the

00:34:17,129 --> 00:34:22,020
two together and we have the exact

00:34:19,200 --> 00:34:24,960
address in memory where that instruction

00:34:22,020 --> 00:34:27,570
the instructions were executed so

00:34:24,960 --> 00:34:30,629
everything a whole lot of that is

00:34:27,570 --> 00:34:33,050
handled automatically by perf all that

00:34:30,629 --> 00:34:39,210
information is there we simply have to

00:34:33,050 --> 00:34:41,339
to use it so when we're talking about

00:34:39,210 --> 00:34:43,260
trace decompression and perf in general

00:34:41,339 --> 00:34:46,889
the real power comes from the scripting

00:34:43,260 --> 00:34:50,310
capability that it gives you so with the

00:34:46,889 --> 00:34:52,109
purse scrip ends where perf is involved

00:34:50,310 --> 00:34:53,940
if you want to have more information or

00:34:52,109 --> 00:34:56,129
you want to go into more details into

00:34:53,940 --> 00:34:57,270
what happened into this session you're

00:34:56,129 --> 00:34:59,490
you're definitely going to have to do

00:34:57,270 --> 00:35:03,510
some scripting we've provided two

00:34:59,490 --> 00:35:06,119
scripts one script that dumpster ranges

00:35:03,510 --> 00:35:07,830
in the more from user-friendly way like

00:35:06,119 --> 00:35:08,490
we have at the bottom here so we see

00:35:07,830 --> 00:35:10,619
that the

00:35:08,490 --> 00:35:15,090
range exactly the range that were

00:35:10,619 --> 00:35:17,580
executed and we also produced the

00:35:15,090 --> 00:35:19,440
assembly range so another D assembly

00:35:17,580 --> 00:35:21,420
script that gives all of the assembler

00:35:19,440 --> 00:35:24,600
instructions that were executed during

00:35:21,420 --> 00:35:27,869
the trace session so I'm listing how the

00:35:24,600 --> 00:35:31,320
the how I'm calling the scripts simply

00:35:27,869 --> 00:35:35,160
because the mechanism to doing that with

00:35:31,320 --> 00:35:43,110
perf is a bit as a bit murky so that's

00:35:35,160 --> 00:35:44,550
the range script so that the assembly

00:35:43,110 --> 00:35:48,650
script is really where we see the power

00:35:44,550 --> 00:35:51,900
of of course site and trace decoding so

00:35:48,650 --> 00:35:54,990
for each range we have the output so

00:35:51,900 --> 00:35:57,720
where the this was executed from on the

00:35:54,990 --> 00:36:00,450
cpu and all is the assembly code that

00:35:57,720 --> 00:36:02,790
was executed the next range and so on

00:36:00,450 --> 00:36:04,560
for the entire all of the packets or all

00:36:02,790 --> 00:36:07,020
of the ranges that were collected during

00:36:04,560 --> 00:36:09,690
a trace session this is the output of

00:36:07,020 --> 00:36:12,570
the D assemble script that is also

00:36:09,690 --> 00:36:15,000
available on github it also shows how

00:36:12,570 --> 00:36:17,430
much information you can go you can get

00:36:15,000 --> 00:36:20,760
out by scripting and that the assembly

00:36:17,430 --> 00:36:24,270
script was programmed by tour in about

00:36:20,760 --> 00:36:27,359
two hours over lunch in a workshop week

00:36:24,270 --> 00:36:29,430
that we had earlier this winter so by

00:36:27,359 --> 00:36:32,040
not investing a whole lot you can get a

00:36:29,430 --> 00:36:34,350
lot of information out of the trace data

00:36:32,040 --> 00:36:41,910
that are synthesized by the per frame

00:36:34,350 --> 00:36:44,010
work okay so obviously because I only

00:36:41,910 --> 00:36:46,550
have 15 minutes here there's a whole lot

00:36:44,010 --> 00:36:51,570
of things that I'm not talking about

00:36:46,550 --> 00:36:53,880
I've only showed example that are in

00:36:51,570 --> 00:36:56,160
user space if you want to use kernel

00:36:53,880 --> 00:36:58,830
space obviously it's impossible but be

00:36:56,160 --> 00:37:01,410
mindful that the vm linux is not carried

00:36:58,830 --> 00:37:03,480
in a dot debug directory so you will

00:37:01,410 --> 00:37:06,260
have to package that with the trace data

00:37:03,480 --> 00:37:09,450
that you're taking off system okay

00:37:06,260 --> 00:37:12,990
there's also a snapshot mode as inherent

00:37:09,450 --> 00:37:15,420
to the perf so that is to trace over

00:37:12,990 --> 00:37:16,770
very long periods of time and look for

00:37:15,420 --> 00:37:19,050
glitches so if you have one point you

00:37:16,770 --> 00:37:22,350
have a glist you simply send a an event

00:37:19,050 --> 00:37:24,060
and you will get all of the dump

00:37:22,350 --> 00:37:26,940
for the extent of the size of that

00:37:24,060 --> 00:37:28,290
buffer but that's those are details I

00:37:26,940 --> 00:37:30,150
mean if you're interested in to snap

00:37:28,290 --> 00:37:32,400
shot mode things are documented properly

00:37:30,150 --> 00:37:34,410
simply use them so this is to highlight

00:37:32,400 --> 00:37:37,320
that yes there is a snapshot mode and

00:37:34,410 --> 00:37:39,570
it's been implemented and supported by

00:37:37,320 --> 00:37:41,520
design everything that I've shown today

00:37:39,570 --> 00:37:44,670
in terms of how the command line works

00:37:41,520 --> 00:37:46,410
is available on Intel PT right so if

00:37:44,670 --> 00:37:49,290
someone gets familiar with traces on

00:37:46,410 --> 00:37:50,700
either platform it's easy to go from one

00:37:49,290 --> 00:37:53,400
side to the other you don't have to

00:37:50,700 --> 00:37:55,800
reinvent trace collection or or how

00:37:53,400 --> 00:38:00,570
you're handling trace data everything is

00:37:55,800 --> 00:38:05,190
seamless in both platforms everything

00:38:00,570 --> 00:38:07,650
that the solution that we have on

00:38:05,190 --> 00:38:10,140
coresight is heavily dependent on sis FS

00:38:07,650 --> 00:38:11,880
so if you are rolling out your own trace

00:38:10,140 --> 00:38:16,230
solution you will have to interact with

00:38:11,880 --> 00:38:18,120
sis FS a lot so if that's the case

00:38:16,230 --> 00:38:20,040
simply look at the examples that we have

00:38:18,120 --> 00:38:22,650
provided and that should get you going

00:38:20,040 --> 00:38:25,590
pretty quickly and as I mentioned we are

00:38:22,650 --> 00:38:28,530
feverishly trying to finish up streaming

00:38:25,590 --> 00:38:30,750
the solution there's only a small

00:38:28,530 --> 00:38:33,150
portion of the users based tools that

00:38:30,750 --> 00:38:35,100
have to be up streamed everything that

00:38:33,150 --> 00:38:37,470
is not upstream is found on github I

00:38:35,100 --> 00:38:41,310
rebase the patches with every stable

00:38:37,470 --> 00:38:46,950
revision and make sure that for that

00:38:41,310 --> 00:38:48,810
revision things still work ok and yeah

00:38:46,950 --> 00:38:50,850
as noted earlier today across trigger

00:38:48,810 --> 00:38:52,500
interface driver should be coming up

00:38:50,850 --> 00:38:57,270
shortly it's just a matter of time

00:38:52,500 --> 00:38:59,580
before it happens so this is a team that

00:38:57,270 --> 00:39:02,370
has been working with me on course site

00:38:59,580 --> 00:39:05,670
over the last a little while an

00:39:02,370 --> 00:39:07,680
Mike and myself are here all week if you

00:39:05,670 --> 00:39:09,360
have any questions by all mean stop us

00:39:07,680 --> 00:39:13,980
in the corridors and we'll be happy to

00:39:09,360 --> 00:39:16,590
help you to the extent of that we can

00:39:13,980 --> 00:39:19,730
and now it's enough for me it's now time

00:39:16,590 --> 00:39:19,730
for you to ask questions

00:39:28,360 --> 00:39:35,060
I'd go Kepler questions FS right and

00:39:32,200 --> 00:39:37,910
so's a bit surprised that there aren't

00:39:35,060 --> 00:39:40,490
any 96 boards being enabled as they're

00:39:37,910 --> 00:39:43,340
there a reason to get like more people

00:39:40,490 --> 00:39:47,690
using their so we good we get to have

00:39:43,340 --> 00:39:50,750
like high key or dragon board enabled so

00:39:47,690 --> 00:39:57,830
the art art the initial intention was to

00:39:50,750 --> 00:39:59,840
use the 96 board products but first for

00:39:57,830 --> 00:40:01,460
some reason for for different reason it

00:39:59,840 --> 00:40:04,310
didn't happen whether the silicone was

00:40:01,460 --> 00:40:07,640
not ready or the code was not ready and

00:40:04,310 --> 00:40:09,710
we had to settle for platforms that were

00:40:07,640 --> 00:40:12,770
already available so that was our

00:40:09,710 --> 00:40:15,740
original intention it did not happen but

00:40:12,770 --> 00:40:17,660
nowadays if someone's interested they

00:40:15,740 --> 00:40:19,970
can always try as I mentioned the clocks

00:40:17,660 --> 00:40:22,580
and the power domain are was a problem

00:40:19,970 --> 00:40:25,670
when working upstream it's always a

00:40:22,580 --> 00:40:27,410
matter of getting those you know the

00:40:25,670 --> 00:40:29,840
code for though to support that upstream

00:40:27,410 --> 00:40:34,610
properly and then coresight will just

00:40:29,840 --> 00:40:38,300
work and what does the CT only support

00:40:34,610 --> 00:40:42,440
we bring in terms of features CTI is a

00:40:38,300 --> 00:40:44,990
way for IP blocks to synchronize them

00:40:42,440 --> 00:40:47,480
solve so if a but if a buffer gets full

00:40:44,990 --> 00:40:49,370
and we have a cgi driver that's why I

00:40:47,480 --> 00:40:53,030
properly can tell the tracer is to stop

00:40:49,370 --> 00:40:55,820
sending information okay without

00:40:53,030 --> 00:40:58,220
intervention right otherwise you would

00:40:55,820 --> 00:41:01,640
overflow your buffer which is what's

00:40:58,220 --> 00:41:05,210
happening right now yeah so in those

00:41:01,640 --> 00:41:07,100
situations you lose you only eat in the

00:41:05,210 --> 00:41:11,690
buffer you will get the latest range

00:41:07,100 --> 00:41:13,520
data so you will only lose the farthest

00:41:11,690 --> 00:41:16,790
portion of the trays data that might not

00:41:13,520 --> 00:41:22,690
that were inviting not released relevant

00:41:16,790 --> 00:41:22,690
to the case being traced okay

00:41:23,230 --> 00:41:29,650
no question so the open CSD can it be

00:41:26,770 --> 00:41:32,050
used independent of perv for example I

00:41:29,650 --> 00:41:33,340
am storing the all the same to put a

00:41:32,050 --> 00:41:36,240
saying you have to get the microphone

00:41:33,340 --> 00:41:39,760
closer to your mouth huh okay better

00:41:36,240 --> 00:41:43,810
okay the open CSD library can it be used

00:41:39,760 --> 00:41:46,000
without using perv oh absolutely so like

00:41:43,810 --> 00:41:48,310
CSD is a standalone product okay right

00:41:46,000 --> 00:41:51,160
we've integrated with perf simply to

00:41:48,310 --> 00:41:53,590
show to give an example of the

00:41:51,160 --> 00:41:55,960
integration of the library into an

00:41:53,590 --> 00:41:57,400
end-to-end solution so you just need to

00:41:55,960 --> 00:41:59,650
get the data from the sink and then

00:41:57,400 --> 00:42:01,630
provided to open CSD and get that thing

00:41:59,650 --> 00:42:04,420
out exactly you just find you just have

00:42:01,630 --> 00:42:07,510
to find a way to feed the packets to the

00:42:04,420 --> 00:42:09,850
library and you know the library is not

00:42:07,510 --> 00:42:11,920
even aware that it's part of perf look

00:42:09,850 --> 00:42:14,890
or that's being linked with perf there's

00:42:11,920 --> 00:42:17,680
a set of CA p is that you can linked

00:42:14,890 --> 00:42:19,270
against and from there you're just using

00:42:17,680 --> 00:42:27,130
the functionality provided by the

00:42:19,270 --> 00:42:29,710
library thank you is some course I in

00:42:27,130 --> 00:42:36,730
any way connected with gdb and can it

00:42:29,710 --> 00:42:41,320
work with GDB GDB yes not yet does their

00:42:36,730 --> 00:42:47,530
plans or me omair would you like to

00:42:41,320 --> 00:42:54,130
answer there was initially a plan but

00:42:47,530 --> 00:42:58,930
still it's not somewhere you know in

00:42:54,130 --> 00:43:03,310
discussion even so I don't know if in

00:42:58,930 --> 00:43:07,990
future maybe but at least there is talk

00:43:03,310 --> 00:43:12,190
about it to enable gdb and LD be to use

00:43:07,990 --> 00:43:14,350
it but still there was initially the

00:43:12,190 --> 00:43:19,660
lack of hardware was one of the problem

00:43:14,350 --> 00:43:22,660
but i don't know if gdp has planned i

00:43:19,660 --> 00:43:27,040
cater towards a 10db and they still

00:43:22,660 --> 00:43:31,290
don't have a plan yeah it's in the work

00:43:27,040 --> 00:43:35,140
various states of but just not there yet

00:43:31,290 --> 00:43:36,369
also to what the events can you trigger

00:43:35,140 --> 00:43:38,829
a trace on

00:43:36,369 --> 00:43:41,230
in other words I know that you have you

00:43:38,829 --> 00:43:44,319
mentioned events but I didn't see what

00:43:41,230 --> 00:43:49,420
do you mean by what event for instance

00:43:44,319 --> 00:43:52,119
read writes interrupts there's also this

00:43:49,420 --> 00:43:55,749
thing does not work with events it's

00:43:52,119 --> 00:43:57,099
works work with addresses alright so you

00:43:55,749 --> 00:43:58,990
have any if you have an interruption

00:43:57,099 --> 00:44:00,509
that you're interested in simply look up

00:43:58,990 --> 00:44:04,170
the address of the interrupt routine

00:44:00,509 --> 00:44:08,259
feed that to the perf command line and

00:44:04,170 --> 00:44:14,230
whenever the instruction pointer hits

00:44:08,259 --> 00:44:16,329
that address traces will be generated so

00:44:14,230 --> 00:44:18,490
there's no it's not an event based

00:44:16,329 --> 00:44:20,859
mechanism like like you would get for

00:44:18,490 --> 00:44:24,430
interruptions for instance everything

00:44:20,859 --> 00:44:26,650
works with an address scheme and an

00:44:24,430 --> 00:44:29,099
explicit start of the recording of the

00:44:26,650 --> 00:44:29,099
trace data

00:44:38,140 --> 00:44:44,210
so do you find that it's difficult to

00:44:40,790 --> 00:44:47,390
keep up for instance when the the perf

00:44:44,210 --> 00:44:49,910
is is trying to pull data out of the

00:44:47,390 --> 00:44:52,760
trace buffer and you're running

00:44:49,910 --> 00:44:55,490
something on another core that's running

00:44:52,760 --> 00:44:57,760
at speed at what point will you

00:44:55,490 --> 00:45:00,380
basically no longer be able to keep up

00:44:57,760 --> 00:45:01,790
that's obviously platform dependent it's

00:45:00,380 --> 00:45:03,530
based on the use case that you're

00:45:01,790 --> 00:45:05,060
working with how you know fastest cpu

00:45:03,530 --> 00:45:08,360
they're going and things like that I

00:45:05,060 --> 00:45:11,300
haven't been able to bust it I haven't

00:45:08,360 --> 00:45:13,250
been able to bust a solution so I found

00:45:11,300 --> 00:45:15,260
that it's a zero copy mechanism

00:45:13,250 --> 00:45:17,780
basically there's no copy between what

00:45:15,260 --> 00:45:22,160
the trace data collected in the kernel

00:45:17,780 --> 00:45:24,380
and the rendering and user space so perf

00:45:22,160 --> 00:45:26,630
will give you an M map buffer and that

00:45:24,380 --> 00:45:29,660
buffer is shared between user and kernel

00:45:26,630 --> 00:45:33,490
space the only problem is the processing

00:45:29,660 --> 00:45:36,110
of the indexes in that wing buffer and

00:45:33,490 --> 00:45:40,460
as i mentioned i haven't been able to

00:45:36,110 --> 00:45:43,430
bust it on the hardware on the juno yes

00:45:40,460 --> 00:45:47,270
right I it's just that I don't have the

00:45:43,430 --> 00:45:48,650
right test cases the right load to do

00:45:47,270 --> 00:45:52,400
that I'm pretty sure that if someone

00:45:48,650 --> 00:45:55,130
would real test scenarios on a heavily

00:45:52,400 --> 00:45:58,160
loaded system that one given the right

00:45:55,130 --> 00:46:00,980
conditions will be able to get to the

00:45:58,160 --> 00:46:06,740
end of that when that happening when

00:46:00,980 --> 00:46:08,990
that happens basically the the setup of

00:46:06,740 --> 00:46:12,710
the tracers in the perf core will fail

00:46:08,990 --> 00:46:15,770
and when that fails that the the thread

00:46:12,710 --> 00:46:19,100
will simply put back into the queue so

00:46:15,770 --> 00:46:20,600
you're not losing that processing it's

00:46:19,100 --> 00:46:24,550
been implemented that way for

00:46:20,600 --> 00:46:26,960
specifically something like that so

00:46:24,550 --> 00:46:28,730
scheduler will do its sting something

00:46:26,960 --> 00:46:31,010
will happen in the system processing

00:46:28,730 --> 00:46:32,780
will go on and then at one point that

00:46:31,010 --> 00:46:34,940
process will be up again so will be

00:46:32,780 --> 00:46:39,320
placed on the cpu before it's being

00:46:34,940 --> 00:46:41,120
placed on the cpu the tracers will be

00:46:39,320 --> 00:46:43,160
set up and part of that setup is looking

00:46:41,120 --> 00:46:46,040
if the user space had time to consume

00:46:43,160 --> 00:46:48,530
the data that was last written if you're

00:46:46,040 --> 00:46:50,960
expiring the daily the buffer so we're

00:46:48,530 --> 00:46:53,150
going back to our condition so to set up

00:46:50,960 --> 00:46:55,369
fails that process goes back into a

00:46:53,150 --> 00:46:57,800
queue so you're not waste you're not

00:46:55,369 --> 00:46:59,660
losing the data that the set up the the

00:46:57,800 --> 00:47:02,900
processing that is associated with that

00:46:59,660 --> 00:47:05,150
time slot does not get wasted it will

00:47:02,900 --> 00:47:08,839
simply be put back into the queue the

00:47:05,150 --> 00:47:09,830
same way that your process happens that

00:47:08,839 --> 00:47:12,740
the same way that happens with your

00:47:09,830 --> 00:47:23,080
process on a heavily loaded system plain

00:47:12,740 --> 00:47:27,190
and simple have you played a tool with

00:47:23,080 --> 00:47:30,589
using the course site with an external

00:47:27,190 --> 00:47:34,030
debug agent like jtag I never open HDD

00:47:30,589 --> 00:47:39,530
supports some versions of like that etm

00:47:34,030 --> 00:47:42,080
just wondering if you to battle so the

00:47:39,530 --> 00:47:44,359
there are solutions out there that will

00:47:42,080 --> 00:47:48,200
set up coresight using an external

00:47:44,359 --> 00:47:53,020
interface we simply haven't integrated

00:47:48,200 --> 00:47:56,000
with that and we don't there's no

00:47:53,020 --> 00:47:58,400
there's no integration with or there's

00:47:56,000 --> 00:48:00,410
no plan to integrate or synchronize i

00:47:58,400 --> 00:48:03,380
should say with an external tool it's

00:48:00,410 --> 00:48:04,849
one or the other basically yeah because

00:48:03,380 --> 00:48:06,920
you can otherwise you can learn

00:48:04,849 --> 00:48:09,800
event-based it working somebody knife

00:48:06,920 --> 00:48:13,220
you can have GD be set breakpoints that

00:48:09,800 --> 00:48:21,950
when ya hit sets up tracer no you go

00:48:13,220 --> 00:48:24,560
crazy here can you provide a little more

00:48:21,950 --> 00:48:29,119
detail on the MIT interface that you you

00:48:24,560 --> 00:48:34,400
mentioned well the maple protocol is

00:48:29,119 --> 00:48:36,619
generated by the SDM block and that

00:48:34,400 --> 00:48:44,089
Burkle is supported by the open course I

00:48:36,619 --> 00:48:45,530
decoding library so there's no I don't

00:48:44,089 --> 00:48:47,270
have the specific spoil that because

00:48:45,530 --> 00:48:49,820
it's part of the decoding protocol of

00:48:47,270 --> 00:48:52,550
the library if there's anything very

00:48:49,820 --> 00:48:53,980
specific that you'd like to see if its

00:48:52,550 --> 00:48:56,240
support or not I would definitely ask

00:48:53,980 --> 00:48:59,720
mike is definitely the better person to

00:48:56,240 --> 00:49:00,530
to answer that now if you have I don't

00:48:59,720 --> 00:49:01,880
know if you have a specific question

00:49:00,530 --> 00:49:13,000
about

00:49:01,880 --> 00:49:13,000
I talked to Mike he's

00:49:18,330 --> 00:49:24,480
alright I guess it's time for lunch as I

00:49:21,090 --> 00:49:26,040
said we're all week if you have any

00:49:24,480 --> 00:49:32,480
questions come and find us we'll be

00:49:26,040 --> 00:49:32,480
happy to help you have a good day

00:49:39,960 --> 00:49:42,020

YouTube URL: https://www.youtube.com/watch?v=wBM6Ejf0aFs


