Title: LAS16-104: MyNewt technical Overview
Publication date: 2016-09-30
Playlist: Linaro Connect Las Vegas 2016
Description: 
	LAS16-104: MyNewt technical overview
Speakers:
Date: September 26, 2016

★ Session Description ★
James Pace & Sterling Hughes (Runtime.io) Apache Mynewt is a community-driven, permissively licensed open source initiative for constrained, embedded devices and applications. The emergence of the IoT is proving that anything that can be connected will be. Many of these devices—wristbands and wearables, lightbulbs and locks–must be operated for long periods of time, but are constrained in terms of power, memory, and storage. Apache Mynewt addresses these constraints while remaining hardware agnostic. Apache Mynewt includes the world’s first controller-level open source Bluetooth Low Energy for microcontrollers. Apache Mynewt has 4 main goals: A foundational RTOS and embedded middleware such as boot loaders, file systems / TLV storage, time-series data support; rich instrumentation and logging infrastructure; Solid networking protocol stacks for secure, efficient communications with constrained devices; Simple image and configuration management and instrumentation for ongoing diagnostics, whether at the workbench or in mass deployment; Modularity and easy composability to build an optimized image. This presentation will help developers up and down the stack understand the requirements and challenges of embedded development environments. For embedded developers–whether they are using common maker environments like Arduino or mature product-oriented tools–a fresh approach to permissively licensed open source tools will be presented.

★ Resources ★
Etherpad: pad.linaro.org/p/las16-104
Presentations & Videos: http://connect.linaro.org/resource/las16/las16-104/

★ Event Details ★
Linaro Connect Las Vegas 2016 – #LAS16
September 26-30, 2016
http://www.linaro.org
http://connect.linaro.org
Captions: 
	00:00:08,690 --> 00:00:14,790
all right so it's 4:15 and I think I'm

00:00:12,570 --> 00:00:17,580
gonna get started even though there's a

00:00:14,790 --> 00:00:20,609
fair number of people still milling in

00:00:17,580 --> 00:00:23,490
the hallways just because I probably

00:00:20,609 --> 00:00:26,840
made too many slides so one or two

00:00:23,490 --> 00:00:26,840
minutes and I'll get started

00:00:44,309 --> 00:00:49,449
well hi I'm sterling everyone and I'm

00:00:47,949 --> 00:00:52,180
here to talk about a packing my new

00:00:49,449 --> 00:00:53,739
which is probably the smallest of the

00:00:52,180 --> 00:00:55,870
operating system efforts that have been

00:00:53,739 --> 00:00:57,420
presented today but I'll give you a

00:00:55,870 --> 00:01:00,430
little bit of an overview of our project

00:00:57,420 --> 00:01:02,350
very similar to both zephyr and embed

00:01:00,430 --> 00:01:04,839
we're an operating system that's

00:01:02,350 --> 00:01:07,840
targeting cortex-m and kind of that

00:01:04,839 --> 00:01:09,850
class of processors so we are agnostic

00:01:07,840 --> 00:01:11,920
of MCU architecture we want to work on

00:01:09,850 --> 00:01:14,470
Intel we want to work on MIPS but if you

00:01:11,920 --> 00:01:15,910
kind of think about the applicable space

00:01:14,470 --> 00:01:18,220
for our operating system it's really

00:01:15,910 --> 00:01:21,009
cortex M's and that's where we've spent

00:01:18,220 --> 00:01:23,410
a lot of our early time so anywhere from

00:01:21,009 --> 00:01:26,440
an M 0 to an m7 is really our target

00:01:23,410 --> 00:01:27,729
architecture and kind of the during the

00:01:26,440 --> 00:01:29,800
talk I'll just talk a little bit about

00:01:27,729 --> 00:01:32,170
what the motivations behind Apache minut

00:01:29,800 --> 00:01:35,259
work why we decided to start yet another

00:01:32,170 --> 00:01:37,240
operating system effort and kind of what

00:01:35,259 --> 00:01:38,590
our philosophy behind it is right

00:01:37,240 --> 00:01:41,470
because I think we all of the operating

00:01:38,590 --> 00:01:44,229
systems up here today really do kind of

00:01:41,470 --> 00:01:45,820
have good end goals but maybe different

00:01:44,229 --> 00:01:47,560
things that they're optimizing for so

00:01:45,820 --> 00:01:49,479
I'll talk a little bit about what Apache

00:01:47,560 --> 00:01:53,590
minut is really focused on getting right

00:01:49,479 --> 00:01:55,570
first recognizing that we all have kind

00:01:53,590 --> 00:02:00,670
of expansive roadmaps towards the end of

00:01:55,570 --> 00:02:02,680
it all so my background is at was from a

00:02:00,670 --> 00:02:04,450
company called Silver Spring Networks at

00:02:02,680 --> 00:02:06,189
Silver Spring Networks we did networked

00:02:04,450 --> 00:02:07,780
power meters networked streetlights and

00:02:06,189 --> 00:02:12,310
kind of some of the first smart city

00:02:07,780 --> 00:02:14,560
networks so we deployed 23 million ipv6

00:02:12,310 --> 00:02:17,530
connected devices and it was my job to

00:02:14,560 --> 00:02:18,940
manage the firmware team that developed

00:02:17,530 --> 00:02:21,549
the software that ran on those devices

00:02:18,940 --> 00:02:23,980
but the NASA also ran upgrades of those

00:02:21,549 --> 00:02:26,200
devices on customer metrics so we had a

00:02:23,980 --> 00:02:28,150
service level agreements where when we

00:02:26,200 --> 00:02:30,220
upgraded devices we couldn't brick them

00:02:28,150 --> 00:02:33,160
we had devices that lived in the field

00:02:30,220 --> 00:02:34,720
for 10 to 15 years where we would

00:02:33,160 --> 00:02:37,989
constantly have to provide software

00:02:34,720 --> 00:02:40,090
updates to those devices and we had you

00:02:37,989 --> 00:02:42,310
know 50 60 different revisions of

00:02:40,090 --> 00:02:44,370
hardware and manufacturing options and

00:02:42,310 --> 00:02:47,049
all of those things out in the field

00:02:44,370 --> 00:02:48,910
while we couldn't go and brick 23

00:02:47,049 --> 00:02:50,540
million devices yet we still had a

00:02:48,910 --> 00:02:54,379
release software to run on those

00:02:50,540 --> 00:02:56,900
Isis and so summer spring was kind of

00:02:54,379 --> 00:02:58,879
this work was done in 2004 right and at

00:02:56,900 --> 00:03:00,469
that time there was a lot of there

00:02:58,879 --> 00:03:02,659
wasn't a lot of uniformity in this space

00:03:00,469 --> 00:03:04,879
both on the hardware side so if you

00:03:02,659 --> 00:03:08,510
looked at the chipsets we used it was an

00:03:04,879 --> 00:03:11,409
atmega 128 that we put a full I pieced a

00:03:08,510 --> 00:03:15,019
con and a full mesh networking stack

00:03:11,409 --> 00:03:17,540
external radios we had 2.4 and 900 so we

00:03:15,019 --> 00:03:19,849
had 2 radios we had an external flash

00:03:17,540 --> 00:03:22,159
chip an external RAM chip eventually and

00:03:19,849 --> 00:03:25,340
so the board was a whole bunch of chips

00:03:22,159 --> 00:03:28,310
that weren't really you know coordinated

00:03:25,340 --> 00:03:30,400
in any fashion and as as time went by

00:03:28,310 --> 00:03:32,569
Silver Springs hardware architecture

00:03:30,400 --> 00:03:34,220
evolved and things got more integrated

00:03:32,569 --> 00:03:35,750
and smaller and like you see today

00:03:34,220 --> 00:03:39,319
there's a whole bunch of system on chips

00:03:35,750 --> 00:03:42,919
the new ti chip as an example has a 802

00:03:39,319 --> 00:03:46,010
15 for radio in sub gigahertz and a 2.4

00:03:42,919 --> 00:03:47,900
and Bluetooth all in a single chip

00:03:46,010 --> 00:03:50,299
design with a processor with memory and

00:03:47,900 --> 00:03:51,349
flash to remin operating system so we

00:03:50,299 --> 00:03:54,319
saw hardware getting a lot more

00:03:51,349 --> 00:03:56,629
integrated in these endpoints but we had

00:03:54,319 --> 00:03:59,389
kind of built our own operating system

00:03:56,629 --> 00:04:01,579
stack as a company right so when we

00:03:59,389 --> 00:04:04,430
started out we used you cost from McCrea

00:04:01,579 --> 00:04:06,139
and you know we modified it because you

00:04:04,430 --> 00:04:08,629
know the scheduler was a big array and

00:04:06,139 --> 00:04:11,690
we wanted to have a asleep list in a run

00:04:08,629 --> 00:04:13,549
list we built our own memories about the

00:04:11,690 --> 00:04:15,620
interfaces we build our own boot loaders

00:04:13,549 --> 00:04:17,090
our own flash file system we built

00:04:15,620 --> 00:04:18,680
everything that you would typically

00:04:17,090 --> 00:04:20,900
think of if you thought of Linux and an

00:04:18,680 --> 00:04:22,849
operating system that what didn't really

00:04:20,900 --> 00:04:26,419
exist in the space we were targeting and

00:04:22,849 --> 00:04:28,880
so of course we did that on a very tight

00:04:26,419 --> 00:04:30,979
time schedule and our boss didn't care

00:04:28,880 --> 00:04:32,570
about the you know beauty of it what was

00:04:30,979 --> 00:04:35,210
the first thing you get rid of it

00:04:32,570 --> 00:04:37,880
security right like and so we had this

00:04:35,210 --> 00:04:40,760
very rudimentary operating system that

00:04:37,880 --> 00:04:42,530
over time we evolved and we had to live

00:04:40,760 --> 00:04:44,910
with the mistakes we made in developing

00:04:42,530 --> 00:04:46,290
that operating system for a very long

00:04:44,910 --> 00:04:48,780
once you've written the write-protect

00:04:46,290 --> 00:04:50,580
Ariel flash it's really hard to drop

00:04:48,780 --> 00:04:53,340
compatibility or something if you've

00:04:50,580 --> 00:04:55,500
messed the format up and so there are

00:04:53,340 --> 00:04:57,120
all of these this kind of pain that we

00:04:55,500 --> 00:04:58,020
built and it's a little bit like you

00:04:57,120 --> 00:04:59,790
know you build this house of cards

00:04:58,020 --> 00:05:02,310
because you have to build a connected

00:04:59,790 --> 00:05:04,140
lock or connected wearable or some sort

00:05:02,310 --> 00:05:06,210
of connected product but you then have

00:05:04,140 --> 00:05:08,910
to build the entire stack up yourself

00:05:06,210 --> 00:05:11,370
and then you have to scale that and you

00:05:08,910 --> 00:05:13,440
have a massive amount of resources spent

00:05:11,370 --> 00:05:15,480
in scaling operating system

00:05:13,440 --> 00:05:18,060
functionality which isn't really your

00:05:15,480 --> 00:05:19,560
core expertise as a product company and

00:05:18,060 --> 00:05:20,880
we certainly found that silver for me I

00:05:19,560 --> 00:05:22,800
think was a teammate and eventually if

00:05:20,880 --> 00:05:25,560
1520 people just on the core

00:05:22,800 --> 00:05:27,390
infrastructure even with that resource

00:05:25,560 --> 00:05:28,220
spend our compilers were years out of

00:05:27,390 --> 00:05:30,780
date

00:05:28,220 --> 00:05:33,300
you know we you know we found a bug in

00:05:30,780 --> 00:05:35,730
this one compiler and it worked and we

00:05:33,300 --> 00:05:37,410
forgot what the bug was that we found so

00:05:35,730 --> 00:05:39,330
we were deathly afraid of upgrading in

00:05:37,410 --> 00:05:40,620
case we ran into it and there were all

00:05:39,330 --> 00:05:43,020
these things where you just had a very

00:05:40,620 --> 00:05:44,640
old tool chain because it wasn't really

00:05:43,020 --> 00:05:46,620
our core expertise to maintain that tool

00:05:44,640 --> 00:05:48,720
chain and really that's what open source

00:05:46,620 --> 00:05:51,180
is really good at right having these

00:05:48,720 --> 00:05:53,550
platform technologies that cross a cut

00:05:51,180 --> 00:05:55,020
across things and actually outsource in

00:05:53,550 --> 00:05:57,030
the maintenance to a commute a broader

00:05:55,020 --> 00:06:00,390
community of people who share the same

00:05:57,030 --> 00:06:02,820
problems that you have so is a

00:06:00,390 --> 00:06:05,610
pre-emptive real-time operating system

00:06:02,820 --> 00:06:07,410
for cortex-m environments but it's

00:06:05,610 --> 00:06:10,020
really about providing the whole stack

00:06:07,410 --> 00:06:12,810
for somebody to develop a product so

00:06:10,020 --> 00:06:14,700
this means at the base level it comes

00:06:12,810 --> 00:06:16,740
with a boot loader that boot loader

00:06:14,700 --> 00:06:18,330
works on all of the software on all of

00:06:16,740 --> 00:06:22,020
the hardware platforms that we support

00:06:18,330 --> 00:06:23,730
it has support for security so all

00:06:22,020 --> 00:06:26,400
images that are uploaded to the device

00:06:23,730 --> 00:06:30,510
are signed sha-256 with an art either

00:06:26,400 --> 00:06:33,060
RSA or ECC DSA in the bootloader we've

00:06:30,510 --> 00:06:34,620
we've also gotten to the point on the

00:06:33,060 --> 00:06:37,100
chips we support we support the various

00:06:34,620 --> 00:06:41,640
options for linking these images so on

00:06:37,100 --> 00:06:44,010
higher-end host processors we dual bank

00:06:41,640 --> 00:06:46,290
images on the lower end processors like

00:06:44,010 --> 00:06:48,390
a Nordic will actually support in place

00:06:46,290 --> 00:06:50,730
upgrade where we separate the operating

00:06:48,390 --> 00:06:53,940
system and kernel and we upgrade them in

00:06:50,730 --> 00:06:56,130
sequence a file flash file system so

00:06:53,940 --> 00:06:58,050
multiple flash access mechanisms as you

00:06:56,130 --> 00:06:59,940
know on these kind of small platforms

00:06:58,050 --> 00:07:02,610
a filesystem sometimes takes up way too

00:06:59,940 --> 00:07:05,069
much memory so we have things like flash

00:07:02,610 --> 00:07:07,139
configuration variables circular buffers

00:07:05,069 --> 00:07:09,000
that allow you to write data to flash in

00:07:07,139 --> 00:07:10,650
a standard format but we handle things

00:07:09,000 --> 00:07:12,539
like see are seeing and encrypting that

00:07:10,650 --> 00:07:14,879
data and tying that into our

00:07:12,539 --> 00:07:18,870
configuration system so kind of a base

00:07:14,879 --> 00:07:20,610
level we've built that secure on top of

00:07:18,870 --> 00:07:22,699
that we have the OS and the hardware

00:07:20,610 --> 00:07:25,110
abstraction layer so the OS is a

00:07:22,699 --> 00:07:27,720
standard pre-emptive multitasking our

00:07:25,110 --> 00:07:31,020
toss there is literally no magic in it

00:07:27,720 --> 00:07:33,509
um but when we looked at to build

00:07:31,020 --> 00:07:34,860
something what we saw was it's not that

00:07:33,509 --> 00:07:36,810
hard to build build a real-time kernel

00:07:34,860 --> 00:07:37,889
it's actually I think we spent two weeks

00:07:36,810 --> 00:07:41,610
on it

00:07:37,889 --> 00:07:43,169
maybe three in terms of testing but what

00:07:41,610 --> 00:07:45,780
you miss and a lot of the kernels that

00:07:43,169 --> 00:07:48,780
are out there isn't or at least a lot of

00:07:45,780 --> 00:07:50,520
the open source kernels is support for

00:07:48,780 --> 00:07:52,860
debug ability and support for things

00:07:50,520 --> 00:07:55,409
like unified buffer schemes so a lot of

00:07:52,860 --> 00:07:57,840
what we did was tie together debugging

00:07:55,409 --> 00:07:59,580
interfaces into our own kernel so we

00:07:57,840 --> 00:08:02,370
have stack guard and stack checking we

00:07:59,580 --> 00:08:06,779
have all of our memory pools actually

00:08:02,370 --> 00:08:09,000
count freeze and Alex we built a sanity

00:08:06,779 --> 00:08:10,830
task that ties into the watchdog and

00:08:09,000 --> 00:08:13,139
keeps the operating system up so it's

00:08:10,830 --> 00:08:15,120
really been about focusing on making the

00:08:13,139 --> 00:08:17,969
kernel very very easy to debug and tying

00:08:15,120 --> 00:08:19,560
in to the rest of our system there's a

00:08:17,969 --> 00:08:22,110
hardware abstraction layer so we've done

00:08:19,560 --> 00:08:24,719
kind of a dual approach here where for

00:08:22,110 --> 00:08:27,240
every MCU we support we support the how

00:08:24,719 --> 00:08:30,330
the how is based processor level

00:08:27,240 --> 00:08:32,490
features so spy I squared see you are

00:08:30,330 --> 00:08:34,649
all of those things the Hal runs

00:08:32,490 --> 00:08:37,289
completely independent to the operating

00:08:34,649 --> 00:08:38,820
system itself so you can put the Hal in

00:08:37,289 --> 00:08:40,709
the bootloader as an example and so if

00:08:38,820 --> 00:08:42,060
you add serial boot support you can

00:08:40,709 --> 00:08:45,029
still leverage the hell without

00:08:42,060 --> 00:08:46,860
requiring the operating system and it's

00:08:45,029 --> 00:08:48,750
really targeted at just the things that

00:08:46,860 --> 00:08:51,300
are common across MCU so we don't bother

00:08:48,750 --> 00:08:52,829
with for example a DC's we don't yeah

00:08:51,300 --> 00:08:55,620
they're really really complicated and

00:08:52,829 --> 00:08:56,940
they're really specific to MCU vendor on

00:08:55,620 --> 00:08:59,010
top of the how what we've done is

00:08:56,940 --> 00:09:00,660
layered our drivers infrastructure so

00:08:59,010 --> 00:09:03,510
for kind of standard things you can use

00:09:00,660 --> 00:09:06,449
the how so if you're talking to slash

00:09:03,510 --> 00:09:08,790
chips for example that's a driver that

00:09:06,449 --> 00:09:10,980
then talks through the how spy interface

00:09:08,790 --> 00:09:11,750
or could talk natively to the processor

00:09:10,980 --> 00:09:13,920
or any other

00:09:11,750 --> 00:09:16,170
so we have a driver's interface on top

00:09:13,920 --> 00:09:18,329
of that that's where we tie in all of

00:09:16,170 --> 00:09:21,089
our power management so it's a ticklish

00:09:18,329 --> 00:09:25,320
are toss with sleep support on top of

00:09:21,089 --> 00:09:27,240
that stats and logging infrastructure is

00:09:25,320 --> 00:09:28,769
kind of one of the most unloved things

00:09:27,240 --> 00:09:30,779
we've seen in men the kernels out there

00:09:28,769 --> 00:09:32,490
and actually one of the most important

00:09:30,779 --> 00:09:34,649
things right so we've spent a lot of

00:09:32,490 --> 00:09:36,899
time really focusing on if you have a

00:09:34,649 --> 00:09:39,089
product out there how can you go and how

00:09:36,899 --> 00:09:41,430
can you debug that product right how can

00:09:39,089 --> 00:09:43,500
you add scale see issues that are in the

00:09:41,430 --> 00:09:46,380
field you know we've had issues in

00:09:43,500 --> 00:09:48,750
previous lifetimes of products that for

00:09:46,380 --> 00:09:50,579
example the radio performance was worse

00:09:48,750 --> 00:09:53,220
on a specific version of that product

00:09:50,579 --> 00:09:56,130
because traces were at buried low enough

00:09:53,220 --> 00:09:59,790
when talking to the flash and so radial

00:09:56,130 --> 00:10:01,560
performance was 20 DB less just on the

00:09:59,790 --> 00:10:03,630
specific SKU of the specific

00:10:01,560 --> 00:10:05,519
manufacturing product and only when we

00:10:03,630 --> 00:10:07,350
read from flash and that had a large

00:10:05,519 --> 00:10:08,970
impact on network performance if you

00:10:07,350 --> 00:10:11,070
don't have those statistics and that

00:10:08,970 --> 00:10:12,510
logging throughout your code and that

00:10:11,070 --> 00:10:14,970
isn't done in a way that's code and

00:10:12,510 --> 00:10:16,380
memory efficient and and configurable it

00:10:14,970 --> 00:10:19,470
allows you to not count certain

00:10:16,380 --> 00:10:21,630
statistics or to compile out statistic

00:10:19,470 --> 00:10:23,610
names even production images if you

00:10:21,630 --> 00:10:25,230
don't have that inherit then it's really

00:10:23,610 --> 00:10:31,740
hard to debug these products out in the

00:10:25,230 --> 00:10:34,140
field and then where we really kind of

00:10:31,740 --> 00:10:35,940
tie in again to providing something

00:10:34,140 --> 00:10:38,220
that's differentiated is in the

00:10:35,940 --> 00:10:40,709
networking stacks themselves and

00:10:38,220 --> 00:10:43,199
specifically our focus and our expertise

00:10:40,709 --> 00:10:45,149
is in the wireless networking stacks so

00:10:43,199 --> 00:10:46,440
we think you know there's a lot of work

00:10:45,149 --> 00:10:49,589
that needs to be done to improve

00:10:46,440 --> 00:10:52,019
embedded IP stacks as an example and

00:10:49,589 --> 00:10:54,209
we're gonna probably just glide on other

00:10:52,019 --> 00:10:57,870
people's work there we in a gray tell

00:10:54,209 --> 00:11:00,329
whip we like out well it's kind of fully

00:10:57,870 --> 00:11:02,610
complete has ipv6 support has ipv4

00:11:00,329 --> 00:11:04,649
support but where we think there's a lot

00:11:02,610 --> 00:11:06,240
of opportunity for improvement is in how

00:11:04,649 --> 00:11:08,579
you manage the wireless side of these

00:11:06,240 --> 00:11:10,290
stacks and that also ties into a lot of

00:11:08,579 --> 00:11:12,029
the problems we see on these

00:11:10,290 --> 00:11:14,930
microcontrollers where the wireless

00:11:12,029 --> 00:11:17,310
portions of those stacks are precompiled

00:11:14,930 --> 00:11:19,260
binaries that are completely opaque to

00:11:17,310 --> 00:11:22,940
the user and so it's our goal to make

00:11:19,260 --> 00:11:26,030
those wireless stacks completely open

00:11:22,940 --> 00:11:28,840
so in terms of context and this is the

00:11:26,030 --> 00:11:30,920
community driven pitch I'll jump over it

00:11:28,840 --> 00:11:34,520
because I know people talk about it a

00:11:30,920 --> 00:11:36,290
little too much but just a quick note on

00:11:34,520 --> 00:11:37,670
where we chose to build this effort we

00:11:36,290 --> 00:11:39,980
chose to build it in the Apache Software

00:11:37,670 --> 00:11:41,210
Foundation so for those of you who don't

00:11:39,980 --> 00:11:44,150
know what the Apache Software Foundation

00:11:41,210 --> 00:11:46,040
is it's the foundation behind a lot of

00:11:44,150 --> 00:11:50,450
the web infrastructure that came out so

00:11:46,040 --> 00:11:52,820
it started in 1994 Jeff can correct me

00:11:50,450 --> 00:11:55,790
there if I missed it but was officially

00:11:52,820 --> 00:11:57,830
incorporated in 1999 and the idea was at

00:11:55,790 --> 00:12:00,500
the time everybody was building their

00:11:57,830 --> 00:12:02,390
own web server and so wouldn't it be

00:12:00,500 --> 00:12:04,190
better for interoperability on the

00:12:02,390 --> 00:12:06,260
internet if there was a common

00:12:04,190 --> 00:12:07,730
open-source web server and so that

00:12:06,260 --> 00:12:09,440
became the Apache web server which is

00:12:07,730 --> 00:12:12,920
the number one web server that everybody

00:12:09,440 --> 00:12:14,420
runs based upon the principles of the

00:12:12,920 --> 00:12:17,030
developers who did that they decided to

00:12:14,420 --> 00:12:19,100
create a non-profit foundation that

00:12:17,030 --> 00:12:21,350
helped other people run community driven

00:12:19,100 --> 00:12:24,890
open source efforts so what community

00:12:21,350 --> 00:12:26,660
driven means is that it's Merritt Mayer

00:12:24,890 --> 00:12:28,370
Craddock and you don't have to pay

00:12:26,660 --> 00:12:30,020
anything to have control over the

00:12:28,370 --> 00:12:32,330
project so it's completely free to

00:12:30,020 --> 00:12:35,630
contribute you can come to our website

00:12:32,330 --> 00:12:37,160
download our code and submit patches but

00:12:35,630 --> 00:12:39,650
the other side of that is it's also

00:12:37,160 --> 00:12:42,380
self-governing by the contributors so no

00:12:39,650 --> 00:12:44,750
one no corporation owns the effort or

00:12:42,380 --> 00:12:46,070
has any control over the effort it's the

00:12:44,750 --> 00:12:48,110
individuals who contribute to the

00:12:46,070 --> 00:12:49,460
project so the way you become a

00:12:48,110 --> 00:12:51,590
contributor and the way you get a vote

00:12:49,460 --> 00:12:54,860
in the direction of our project is you

00:12:51,590 --> 00:12:56,900
submit patches if you submit patches you

00:12:54,860 --> 00:12:58,970
will become a committer and if you're a

00:12:56,900 --> 00:13:01,240
committer you vote on the strategic

00:12:58,970 --> 00:13:03,650
decisions in the project and your vote

00:13:01,240 --> 00:13:05,930
counts just as much as if I'm I vote or

00:13:03,650 --> 00:13:08,990
any of the other committees votes and so

00:13:05,930 --> 00:13:11,960
it's really the idea is a project of

00:13:08,990 --> 00:13:13,190
individuals and contributors and you

00:13:11,960 --> 00:13:15,110
know you look at some of the largest

00:13:13,190 --> 00:13:17,300
pieces of infrastructure hadoop most of

00:13:15,110 --> 00:13:19,880
the big data stuff the Apache web server

00:13:17,300 --> 00:13:22,010
they've all been built this way and the

00:13:19,880 --> 00:13:24,140
reason that this works is it is it's not

00:13:22,010 --> 00:13:25,580
a temporary alliance of people it's

00:13:24,140 --> 00:13:27,140
individual contributors who are

00:13:25,580 --> 00:13:33,209
passionate about the project who carry

00:13:27,140 --> 00:13:34,259
it forward so I'm gonna just kind of

00:13:33,209 --> 00:13:35,550
a little bit by the way feel free to

00:13:34,259 --> 00:13:38,579
interrupt if you have questions or

00:13:35,550 --> 00:13:43,529
comments but about some of the features

00:13:38,579 --> 00:13:44,970
of the Apache minut system may be our

00:13:43,529 --> 00:13:47,040
major feature but it is something that

00:13:44,970 --> 00:13:48,209
under underpins everything else we've

00:13:47,040 --> 00:13:53,339
developed so I'm going to go a little

00:13:48,209 --> 00:13:55,110
bit more into it so that ties everything

00:13:53,339 --> 00:13:57,540
together as we've built our own build

00:13:55,110 --> 00:13:59,819
and package management system so very

00:13:57,540 --> 00:14:02,490
similar to Java that was in bed for a

00:13:59,819 --> 00:14:03,990
while our thought is if you're going to

00:14:02,490 --> 00:14:06,569
go and develop and manage these large

00:14:03,990 --> 00:14:08,999
projects you want to have a stable core

00:14:06,569 --> 00:14:10,470
operating system and then you want to be

00:14:08,999 --> 00:14:12,149
able to redistribute third-party

00:14:10,470 --> 00:14:14,220
libraries and link them all together and

00:14:12,149 --> 00:14:17,339
you want to be able to manage that and

00:14:14,220 --> 00:14:18,809
that becomes very complex so a typical

00:14:17,339 --> 00:14:22,050
use case for this was that Silver Spring

00:14:18,809 --> 00:14:24,389
networks where we had meters

00:14:22,050 --> 00:14:26,850
streetlights about 20 30 different

00:14:24,389 --> 00:14:28,470
Hardware SKUs but we had a unified

00:14:26,850 --> 00:14:30,179
operating system that we had built and

00:14:28,470 --> 00:14:31,889
you see this with a lot of people we

00:14:30,179 --> 00:14:34,379
wanted to maintain our code base in

00:14:31,889 --> 00:14:35,850
parallel for these that have

00:14:34,379 --> 00:14:37,439
customizations for each of the different

00:14:35,850 --> 00:14:38,610
products we develop so we wanted to have

00:14:37,439 --> 00:14:39,959
slightly different things for the

00:14:38,610 --> 00:14:42,209
streetlights than we did for the meters

00:14:39,959 --> 00:14:44,309
and so what we have is a core operating

00:14:42,209 --> 00:14:46,529
system component and then individual

00:14:44,309 --> 00:14:48,149
code bases based upon that and so nud

00:14:46,529 --> 00:14:50,309
allows you to do that and it allows you

00:14:48,149 --> 00:14:51,839
to compose your operating system picking

00:14:50,309 --> 00:14:53,970
only the pieces you want for a given

00:14:51,839 --> 00:14:57,179
project but still maintaining separate

00:14:53,970 --> 00:14:58,589
code bases and the other thing that neut

00:14:57,179 --> 00:15:00,600
does for us is so that's the package

00:14:58,589 --> 00:15:02,549
management side we've then tied build

00:15:00,600 --> 00:15:03,779
into that so that when you take your

00:15:02,549 --> 00:15:06,029
development environment you go to

00:15:03,779 --> 00:15:09,600
production you can use the same tool to

00:15:06,029 --> 00:15:11,220
do both of those so as an example if you

00:15:09,600 --> 00:15:13,350
compile your operating system and you

00:15:11,220 --> 00:15:15,329
compile your application with new you

00:15:13,350 --> 00:15:17,790
can then take that same code base that

00:15:15,329 --> 00:15:19,379
you could load it on a debugger and you

00:15:17,790 --> 00:15:21,689
can automatically create a flash image

00:15:19,379 --> 00:15:23,939
with for that and you can automatically

00:15:21,689 --> 00:15:25,410
create form or upload images so it's the

00:15:23,939 --> 00:15:28,559
same build tool that takes you from

00:15:25,410 --> 00:15:30,749
debug to production the build two will

00:15:28,559 --> 00:15:32,910
automatically science images for you it

00:15:30,749 --> 00:15:34,459
also maintains all of the symbol

00:15:32,910 --> 00:15:37,559
information and all of the get history

00:15:34,459 --> 00:15:41,160
for every build that you have so you

00:15:37,559 --> 00:15:43,980
have the entire history of that product

00:15:41,160 --> 00:15:44,920
through build artifacts as well as debug

00:15:43,980 --> 00:15:47,109
and production

00:15:44,920 --> 00:15:48,609
so when you go and you upgrade images in

00:15:47,109 --> 00:15:51,220
the field all of that's automatically

00:15:48,609 --> 00:15:53,619
saved for you so the idea is to help you

00:15:51,220 --> 00:15:55,139
maintain large code bases and to help

00:15:53,619 --> 00:16:00,759
you to move from the bug to production

00:15:55,139 --> 00:16:04,449
in one seamless way few other highlights

00:16:00,759 --> 00:16:05,529
all right so one of the core elements of

00:16:04,449 --> 00:16:08,379
the operating system that we've

00:16:05,529 --> 00:16:15,790
developed is cross-platform support we

00:16:08,379 --> 00:16:17,470
have said it was not the job of the

00:16:15,790 --> 00:16:19,720
operating system and it was outsourced a

00:16:17,470 --> 00:16:21,489
little bit but you know how do you come

00:16:19,720 --> 00:16:23,709
up with a very good how that you can

00:16:21,489 --> 00:16:26,169
implement reliably across platforms and

00:16:23,709 --> 00:16:28,629
how do you do that in a way that's very

00:16:26,169 --> 00:16:30,429
efficient for product developers right

00:16:28,629 --> 00:16:32,109
so how do you abstract a spy' interface

00:16:30,429 --> 00:16:33,939
you don't want it to be too high level

00:16:32,109 --> 00:16:36,850
you want to be able to run it how do you

00:16:33,939 --> 00:16:39,040
abstract a UART interface do you use DMA

00:16:36,850 --> 00:16:41,019
how does the DMA look different across

00:16:39,040 --> 00:16:42,970
all of these platforms so we've done a

00:16:41,019 --> 00:16:45,699
lot of work in really getting a how

00:16:42,970 --> 00:16:49,059
that's both efficient and portable

00:16:45,699 --> 00:16:50,709
across multiple platforms on the

00:16:49,059 --> 00:16:53,589
building package management system here

00:16:50,709 --> 00:16:56,290
which ties into how we layout code so as

00:16:53,589 --> 00:16:58,839
an example on every build that we create

00:16:56,290 --> 00:17:00,459
there's both an application that the two

00:16:58,839 --> 00:17:02,499
targets in the build are the application

00:17:00,459 --> 00:17:03,939
and the board Support Package the build

00:17:02,499 --> 00:17:07,029
and package management tool itself

00:17:03,939 --> 00:17:09,159
understands dependencies so the the

00:17:07,029 --> 00:17:11,500
board Support Package typically relies

00:17:09,159 --> 00:17:13,720
on an MCU Support Package which is a

00:17:11,500 --> 00:17:16,000
full implementation of the how for that

00:17:13,720 --> 00:17:17,919
board Support Package we've built-in

00:17:16,000 --> 00:17:19,659
capabilities in all of that so that we

00:17:17,919 --> 00:17:23,439
can really develop a system that works

00:17:19,659 --> 00:17:24,789
across platforms and of course there's

00:17:23,439 --> 00:17:26,970
all the little details that we don't

00:17:24,789 --> 00:17:26,970
have

00:17:38,100 --> 00:17:42,610
so those are kind of some of the key

00:17:40,330 --> 00:17:43,990
areas for the operating system that

00:17:42,610 --> 00:17:46,300
where we've really split put in a lot of

00:17:43,990 --> 00:17:48,970
thought to getting these api's tied down

00:17:46,300 --> 00:17:51,340
right to dig a little deeper into one of

00:17:48,970 --> 00:17:53,050
them so just to take security as an

00:17:51,340 --> 00:17:55,180
example of one of the areas where we

00:17:53,050 --> 00:17:56,400
thought so we've we've we've gone all

00:17:55,180 --> 00:17:58,270
the way through the product lifecycle

00:17:56,400 --> 00:18:00,820
starting from provisioning

00:17:58,270 --> 00:18:03,250
so as an example most chips that you'll

00:18:00,820 --> 00:18:05,770
look in the arm-based world will have

00:18:03,250 --> 00:18:07,660
some probably intel as well they have

00:18:05,770 --> 00:18:10,120
some unique identifiers that comes from

00:18:07,660 --> 00:18:11,650
silicon if not in order to do device

00:18:10,120 --> 00:18:13,870
provisioning within a manufacturing

00:18:11,650 --> 00:18:16,060
environment you need to have a unique

00:18:13,870 --> 00:18:17,920
identifier for that device so that when

00:18:16,060 --> 00:18:19,750
you develop a management system in the

00:18:17,920 --> 00:18:22,270
cloud you can actually come and

00:18:19,750 --> 00:18:24,130
understand what that device is doing so

00:18:22,270 --> 00:18:26,200
we have api's in our board support

00:18:24,130 --> 00:18:28,510
packages and in our MCU support packages

00:18:26,200 --> 00:18:30,100
that actually provide a that allow you

00:18:28,510 --> 00:18:32,470
to hook into the silicon's unique

00:18:30,100 --> 00:18:35,980
ability to provide you a unique ID

00:18:32,470 --> 00:18:38,680
we support generating a private key from

00:18:35,980 --> 00:18:41,080
that information and passing the public

00:18:38,680 --> 00:18:44,140
component out to a manufacturing station

00:18:41,080 --> 00:18:46,390
so that when a device comes and tries to

00:18:44,140 --> 00:18:48,190
get on the network all of that is tied

00:18:46,390 --> 00:18:49,810
together and that's built into the API

00:18:48,190 --> 00:18:52,300
as we've built because provisioning is

00:18:49,810 --> 00:18:57,160
key to pretty much anybody who's do with

00:18:52,300 --> 00:18:59,050
developing an IOT connected product the

00:18:57,160 --> 00:19:02,320
bootloader does not have an unsecured

00:18:59,050 --> 00:19:05,890
option so every image that you download

00:19:02,320 --> 00:19:08,410
to a device is secure it just uses a

00:19:05,890 --> 00:19:11,290
development key when you're generating

00:19:08,410 --> 00:19:13,480
the image so if you use nuke to manage

00:19:11,290 --> 00:19:15,100
your product you are already using a

00:19:13,480 --> 00:19:19,840
secure bootloader there's no secure

00:19:15,100 --> 00:19:22,780
bootloader option we support all of the

00:19:19,840 --> 00:19:24,910
communication security protocols so we

00:19:22,780 --> 00:19:28,320
have DTLS support but we also support

00:19:24,910 --> 00:19:31,930
all of bluetooth security communication

00:19:28,320 --> 00:19:34,810
there is AB spray tional I'll call that

00:19:31,930 --> 00:19:36,610
out we definitely believe in having role

00:19:34,810 --> 00:19:40,260
based access control security for all of

00:19:36,610 --> 00:19:40,260
our management that has not been

00:19:40,529 --> 00:19:45,610
one of the things that's always a pain

00:19:42,960 --> 00:19:47,679
early on nobody encrypts data on flash

00:19:45,610 --> 00:19:49,299
and then when you go and you actually

00:19:47,679 --> 00:19:50,649
deploy a product and you start to have

00:19:49,299 --> 00:19:53,080
to sell to government or you start to

00:19:50,649 --> 00:19:56,200
have privacy concerns almost everybody

00:19:53,080 --> 00:19:58,779
wants to encrypt data on flash and so we

00:19:56,200 --> 00:20:00,340
have options in our flash file system as

00:19:58,779 --> 00:20:02,500
well as our circular buffering

00:20:00,340 --> 00:20:04,450
mechanisms and config mechanisms to

00:20:02,500 --> 00:20:06,789
support encrypted storage of data and

00:20:04,450 --> 00:20:08,200
that's all built into the system for you

00:20:06,789 --> 00:20:10,179
so if you start out and you don't want

00:20:08,200 --> 00:20:13,600
to use it and then you want to switch to

00:20:10,179 --> 00:20:16,809
it it's a seamless transition and then

00:20:13,600 --> 00:20:18,370
we are ppm and smartcard aware so if we

00:20:16,809 --> 00:20:19,809
want to come up and validate some data

00:20:18,370 --> 00:20:23,860
we want to sign that that's all

00:20:19,809 --> 00:20:26,380
abstracted from a connectivity layer a

00:20:23,860 --> 00:20:28,899
patching my new has kind of we've made

00:20:26,380 --> 00:20:31,389
some we as runs caveat this with run

00:20:28,899 --> 00:20:33,309
times of you because roadmaps are really

00:20:31,389 --> 00:20:35,649
they're about the community I can't

00:20:33,309 --> 00:20:37,330
speak for the Apache my new project but

00:20:35,649 --> 00:20:40,210
I can speak for what run time is working

00:20:37,330 --> 00:20:42,000
on in Apache my new and transports we

00:20:40,210 --> 00:20:44,169
started with we're Bluetooth and Wi-Fi

00:20:42,000 --> 00:20:46,299
we took we think there's gonna be a lot

00:20:44,169 --> 00:20:48,760
of transports and wireless transports

00:20:46,299 --> 00:20:50,169
are gonna dictate IOT deployments but we

00:20:48,760 --> 00:20:51,940
started with Bluetooth and Wi-Fi because

00:20:50,169 --> 00:20:53,919
there were standards and they had

00:20:51,940 --> 00:20:55,870
interoperability processes around them

00:20:53,919 --> 00:20:57,880
that were way more robust than anything

00:20:55,870 --> 00:21:00,130
else we saw so when you look at

00:20:57,880 --> 00:21:01,809
Bluetooth it truly is interoperable

00:21:00,130 --> 00:21:03,760
across chip vendors and the same applies

00:21:01,809 --> 00:21:06,130
to Wi-Fi whereas if you look at some of

00:21:03,760 --> 00:21:07,750
the low-power wide area standards that

00:21:06,130 --> 00:21:09,340
are out there today you don't really

00:21:07,750 --> 00:21:11,289
have that interoperability framework

00:21:09,340 --> 00:21:13,240
there so well we think they're gonna be

00:21:11,289 --> 00:21:17,470
really interesting and exciting we

00:21:13,240 --> 00:21:19,899
didn't focus on them first we support

00:21:17,470 --> 00:21:21,820
both a host and a controller so we go

00:21:19,899 --> 00:21:23,830
down and we we completely so the first

00:21:21,820 --> 00:21:26,260
chip we supported was the Nordic NRF 52

00:21:23,830 --> 00:21:28,120
we completely replaced the soft device

00:21:26,260 --> 00:21:29,409
on that chip and provide all of the

00:21:28,120 --> 00:21:31,029
functionality that you would get with

00:21:29,409 --> 00:21:33,010
the soft device but we do that in

00:21:31,029 --> 00:21:37,269
affordable fashion so you can easily

00:21:33,010 --> 00:21:40,000
move to from a Nordic chipset to a an XP

00:21:37,269 --> 00:21:42,100
chipset as an example and when you move

00:21:40,000 --> 00:21:43,299
none of your eyes have to change

00:21:42,100 --> 00:21:44,679
you don't have to re-implement your

00:21:43,299 --> 00:21:46,030
Bluetooth stack you don't have to

00:21:44,679 --> 00:21:49,950
re-implement your software upgrade

00:21:46,030 --> 00:21:49,950
mechanisms all of that comes in my new

00:21:52,890 --> 00:21:58,809
currently run oh I see so the idea is to

00:21:56,470 --> 00:22:04,330
run we were on how I see natively on top

00:21:58,809 --> 00:22:06,280
of basically on top of gap management

00:22:04,330 --> 00:22:07,990
protocol using oh I see

00:22:06,280 --> 00:22:09,400
we chose oh I see because it was a

00:22:07,990 --> 00:22:13,539
standard protocol and it was

00:22:09,400 --> 00:22:17,470
surprisingly saying JSON encoded data or

00:22:13,539 --> 00:22:18,750
C bore you have the same framework for

00:22:17,470 --> 00:22:25,539
both management and application

00:22:18,750 --> 00:22:27,669
communication first chips that we

00:22:25,539 --> 00:22:34,360
support is the wig 1500 but we're

00:22:27,669 --> 00:22:36,429
continuing to evolve our support so

00:22:34,360 --> 00:22:41,169
right now the last release we had was

00:22:36,429 --> 00:22:44,669
0.9 we are mid octave October we are

00:22:41,169 --> 00:22:44,669
launching with our one dot o release

00:22:45,360 --> 00:22:50,950
release what that means to us is full

00:22:47,679 --> 00:22:52,750
Wi-Fi support API stability and we've

00:22:50,950 --> 00:22:55,990
already been running minut in production

00:22:52,750 --> 00:22:58,360
with customers for about six months now

00:22:55,990 --> 00:22:59,860
so we've hacked you no wonder that all

00:22:58,360 --> 00:23:02,500
of the operating systems are fairly

00:22:59,860 --> 00:23:04,210
nascent in this space but we feel pretty

00:23:02,500 --> 00:23:06,730
confident given that we've had six

00:23:04,210 --> 00:23:08,500
months of production on the operating

00:23:06,730 --> 00:23:12,580
system and a whole bunch of API testing

00:23:08,500 --> 00:23:14,320
that well beyond that we are committed

00:23:12,580 --> 00:23:16,330
to supporting bluetooth we think it's I

00:23:14,320 --> 00:23:22,750
think most people up here really like

00:23:16,330 --> 00:23:25,539
bluetooth we really like Bluetooth 25.0

00:23:22,750 --> 00:23:28,120
really what's exciting to me about 5.0

00:23:25,539 --> 00:23:30,280
is the fact that so the challenge with

00:23:28,120 --> 00:23:31,289
Bluetooth today is the small packet

00:23:30,280 --> 00:23:34,750
sizes

00:23:31,289 --> 00:23:36,309
specifically both in connections so it's

00:23:34,750 --> 00:23:38,140
27 bytes in a connection but it's

00:23:36,309 --> 00:23:40,570
specifically advertising packets which

00:23:38,140 --> 00:23:42,100
are essential to developing a mesh so

00:23:40,570 --> 00:23:44,679
when you have small advertising packets

00:23:42,100 --> 00:23:46,659
23 pi packets you can actually broadcast

00:23:44,679 --> 00:23:48,460
out routing information or anything

00:23:46,659 --> 00:23:52,210
without having a connection to a device

00:23:48,460 --> 00:23:52,830
with Bluetooth 5 advertising packets are

00:23:52,210 --> 00:23:54,120
moving from

00:23:52,830 --> 00:23:56,279
twenty twenty three or twenty seven

00:23:54,120 --> 00:23:58,350
bytes all the way up to two hundred and

00:23:56,279 --> 00:24:02,480
ninety bytes which then allows you to

00:23:58,350 --> 00:24:02,480
really run mesh on top of Bluetooth five

00:24:02,809 --> 00:24:07,409
we plan on supporting a lot of the low

00:24:05,039 --> 00:24:09,360
power white area standards so Laura is

00:24:07,409 --> 00:24:11,490
one of them but we're looking at also

00:24:09,360 --> 00:24:13,260
other sub gigahertz mesh technologies

00:24:11,490 --> 00:24:15,679
and we think that's an area where good

00:24:13,260 --> 00:24:18,450
Wireless stack support can really help

00:24:15,679 --> 00:24:20,669
and then there's of course all of the

00:24:18,450 --> 00:24:23,789
new 3gpp stuff I think most notably

00:24:20,669 --> 00:24:26,130
there is env IOT which a lot of the cell

00:24:23,789 --> 00:24:27,840
carriers are starting to deploy and then

00:24:26,130 --> 00:24:29,549
Vig is essentially for those who don't

00:24:27,840 --> 00:24:32,970
know it it's Laura and licensed spectrum

00:24:29,549 --> 00:24:35,760
and a lot of the problems with Laura in

00:24:32,970 --> 00:24:37,470
real deployments is that you know it's

00:24:35,760 --> 00:24:39,809
great to have a star architecture for

00:24:37,470 --> 00:24:42,000
our battery-powered devices because you

00:24:39,809 --> 00:24:43,950
can transmit really far and they know

00:24:42,000 --> 00:24:45,960
what channel to be on but if you do that

00:24:43,950 --> 00:24:48,299
in an unlicensed spectrum there's a very

00:24:45,960 --> 00:24:50,789
high noise floor so as you have other

00:24:48,299 --> 00:24:53,669
deployments around you sub gigahertz

00:24:50,789 --> 00:24:55,289
doesn't work as well for them whereas at

00:24:53,669 --> 00:24:58,049
mesh architecture works a lot better and

00:24:55,289 --> 00:24:59,669
unlicensed so having n vo IOT and

00:24:58,049 --> 00:25:01,500
license we think is a really interesting

00:24:59,669 --> 00:25:03,570
technology because it'll be great for

00:25:01,500 --> 00:25:07,320
things like that battery-powered devices

00:25:03,570 --> 00:25:08,639
that need long areas to go over so just

00:25:07,320 --> 00:25:10,529
a few highlights from the networking

00:25:08,639 --> 00:25:11,880
stack so I think the first TAC if you're

00:25:10,529 --> 00:25:13,080
gonna go and look at our effort and want

00:25:11,880 --> 00:25:14,220
to judge the code I think the first

00:25:13,080 --> 00:25:16,500
stack to look at is our Bluetooth

00:25:14,220 --> 00:25:18,720
networking stack we have pretty good

00:25:16,500 --> 00:25:20,519
performance results with it so we

00:25:18,720 --> 00:25:22,919
support our central and peripheral modes

00:25:20,519 --> 00:25:25,470
for Bluetooth we also support up to 32

00:25:22,919 --> 00:25:27,330
simultaneous connections and this is

00:25:25,470 --> 00:25:29,100
really an area where having good

00:25:27,330 --> 00:25:30,570
wireless stack support unlocks new

00:25:29,100 --> 00:25:32,669
applications so the first people to

00:25:30,570 --> 00:25:35,190
adopt our OS when it was you know barely

00:25:32,669 --> 00:25:36,990
working and constantly changing were

00:25:35,190 --> 00:25:39,269
locked people right so when you're

00:25:36,990 --> 00:25:40,710
developing smart locks what you want to

00:25:39,269 --> 00:25:43,409
do is you want to be able to scan for

00:25:40,710 --> 00:25:44,700
phones that are coming near a door right

00:25:43,409 --> 00:25:46,679
you want to be able to see those phones

00:25:44,700 --> 00:25:48,389
and see whether they're near enough to

00:25:46,679 --> 00:25:50,880
you that you should unlock the door and

00:25:48,389 --> 00:25:52,559
whether their phone you care about the

00:25:50,880 --> 00:25:54,690
Nordics stack that was shipped I think

00:25:52,559 --> 00:25:56,090
was three connections in in central mode

00:25:54,690 --> 00:25:58,909
and one connection in peripheral

00:25:56,090 --> 00:26:00,830
which meant that you were severely

00:25:58,909 --> 00:26:03,499
limited and how many devices you could

00:26:00,830 --> 00:26:05,119
connect to but and it this wasn't

00:26:03,499 --> 00:26:07,249
because Nordic was bad at writing

00:26:05,119 --> 00:26:09,649
drivers it was because they shipped a

00:26:07,249 --> 00:26:12,289
precompiled binary that had to work for

00:26:09,649 --> 00:26:15,559
all of their users right so you couldn't

00:26:12,289 --> 00:26:17,090
just if you made 32 connections you'd

00:26:15,559 --> 00:26:18,799
have to use all of that memory and

00:26:17,090 --> 00:26:22,070
somebody who's developing a small

00:26:18,799 --> 00:26:25,399
peripheral doesn't care about having to

00:26:22,070 --> 00:26:27,469
go and connect 230 devices but somebody

00:26:25,399 --> 00:26:30,019
who's connecting to a lock really does

00:26:27,469 --> 00:26:37,789
care and so having an open source option

00:26:30,019 --> 00:26:39,169
there allows people to then control as

00:26:37,789 --> 00:26:40,999
well as host only in controller only

00:26:39,169 --> 00:26:44,019
mode so another very common place where

00:26:40,999 --> 00:26:47,210
users in blue Z actually the Intel folks

00:26:44,019 --> 00:26:49,009
went and poured it my new to have

00:26:47,210 --> 00:26:54,830
support a controller only implementation

00:26:49,009 --> 00:26:56,450
and so we're run frequently and then

00:26:54,830 --> 00:26:58,700
just the kind of another thing there is

00:26:56,450 --> 00:27:01,309
because our stack is configurable it's

00:26:58,700 --> 00:27:03,649
about 40% less code than the soft device

00:27:01,309 --> 00:27:05,629
when you run it in for a lonely mode

00:27:03,649 --> 00:27:07,519
because we don't need the central rolls

00:27:05,629 --> 00:27:09,200
and we don't need to enable all of this

00:27:07,519 --> 00:27:11,119
functionality so it gives you fine gate

00:27:09,200 --> 00:27:12,859
grained control over what features you

00:27:11,119 --> 00:27:15,950
run on the device

00:27:12,859 --> 00:27:18,859
we've recently gone ahead and then added

00:27:15,950 --> 00:27:20,629
Wi-Fi support to my new so this is using

00:27:18,859 --> 00:27:23,539
El whip and then the underlying wireless

00:27:20,629 --> 00:27:25,969
support we have a abstracted interface

00:27:23,539 --> 00:27:27,769
to Wi-Fi supplicants currently it's with

00:27:25,969 --> 00:27:29,509
the wink 1500 we're looking to add

00:27:27,769 --> 00:27:31,190
additional support

00:27:29,509 --> 00:27:33,499
I think run time we're pretty excited

00:27:31,190 --> 00:27:35,960
about broad comms chips and then some of

00:27:33,499 --> 00:27:38,989
the media tech stuff that is combo

00:27:35,960 --> 00:27:40,479
so both Bluetooth and Wi-Fi but the idea

00:27:38,989 --> 00:27:43,489
is to abstract all of the supplicant

00:27:40,479 --> 00:27:45,559
interfaces this is if people here are

00:27:43,489 --> 00:27:47,119
more familiar with Linux Linux there's a

00:27:45,559 --> 00:27:49,460
lot more mode so the supplicant can

00:27:47,119 --> 00:27:51,710
actually be soft in most of the MCU

00:27:49,460 --> 00:27:55,779
environments the supplicant comes in a

00:27:51,710 --> 00:27:55,779
vendor sdk that's on a separate chip 7

00:27:56,259 --> 00:28:02,889
implemental supplicant we've integrated

00:27:58,600 --> 00:28:05,409
there and we're looking than others in

00:28:02,889 --> 00:28:07,149
terms of hardware support the kind of

00:28:05,409 --> 00:28:08,950
these were the first three platforms

00:28:07,149 --> 00:28:10,929
that we really decided to develop our

00:28:08,950 --> 00:28:13,119
operating system so the first use case

00:28:10,929 --> 00:28:15,940
we looked at was really developing it

00:28:13,119 --> 00:28:17,799
for the Nordic NRF 51 and 52 right and

00:28:15,940 --> 00:28:19,600
at least in my mind and I think other

00:28:17,799 --> 00:28:21,249
people's mind it was really how do we

00:28:19,600 --> 00:28:22,960
develop an open source often ice

00:28:21,249 --> 00:28:25,239
replacement right because the real

00:28:22,960 --> 00:28:26,529
business value of taking this operating

00:28:25,239 --> 00:28:28,450
system when you start to talk to people

00:28:26,529 --> 00:28:33,129
kind of outside of the engineering world

00:28:28,450 --> 00:28:34,629
is that you can now have a a single

00:28:33,129 --> 00:28:36,850
operating system that can run on

00:28:34,629 --> 00:28:38,710
multiple chipsets and you can really

00:28:36,850 --> 00:28:41,889
then look at price performance between

00:28:38,710 --> 00:28:44,980
the various chip vendors in terms of the

00:28:41,889 --> 00:28:47,289
operating system and so our thought was

00:28:44,980 --> 00:28:49,029
let's develop a real kind of replacement

00:28:47,289 --> 00:28:51,850
for the soft device and so we targeted

00:28:49,029 --> 00:28:53,139
the Nordic platform to do that but at

00:28:51,850 --> 00:28:54,669
the same time when you're developing an

00:28:53,139 --> 00:28:56,470
operating system you really need to have

00:28:54,669 --> 00:28:58,559
support multiple platforms and able to

00:28:56,470 --> 00:29:00,850
in order to make things like you're how

00:28:58,559 --> 00:29:03,519
because if we had just supported Nordic

00:29:00,850 --> 00:29:08,799
we would never have seen all of the

00:29:03,519 --> 00:29:11,529
intricacies of the ADC platforms so we

00:29:08,799 --> 00:29:12,940
supported those three platforms we've

00:29:11,529 --> 00:29:15,100
seen a lot of usage on the SD micro

00:29:12,940 --> 00:29:18,730
platforms they're very popular for Wi-Fi

00:29:15,100 --> 00:29:21,429
they also are a very popular chip to go

00:29:18,730 --> 00:29:23,649
and do DSP offload on them so we see a

00:29:21,429 --> 00:29:25,539
lot of people who use the Nordic chip as

00:29:23,649 --> 00:29:28,269
a host processor and then when they have

00:29:25,539 --> 00:29:30,190
to do some sort of DSP or data

00:29:28,269 --> 00:29:32,739
processing they'll wake up an SD micro

00:29:30,190 --> 00:29:34,389
chip and then the at the metal Sam GCM

00:29:32,739 --> 00:29:37,330
l20 ones are very popular at maker

00:29:34,389 --> 00:29:44,169
platforms the sam'l 20 ones have

00:29:37,330 --> 00:29:45,940
fantastic low-power support post 1.0

00:29:44,169 --> 00:29:48,519
we're really going to spend a lot more

00:29:45,940 --> 00:29:50,109
effort broadening this out you know when

00:29:48,519 --> 00:29:53,159
you're Hal and your driver interfaces

00:29:50,109 --> 00:29:55,450
and your DSPs are frequently changing

00:29:53,159 --> 00:29:58,629
supporting a lot of platforms is very

00:29:55,450 --> 00:30:01,109
difficult now that we with with our 1.0

00:29:58,629 --> 00:30:03,909
release we're targeting API stability

00:30:01,109 --> 00:30:05,730
once we have API stability of the core

00:30:03,909 --> 00:30:08,309
that's when we're going to really

00:30:05,730 --> 00:30:10,980
kind of expand and spend a lot of effort

00:30:08,309 --> 00:30:13,500
expanding this support so kind of post

00:30:10,980 --> 00:30:16,950
one dotto a lot of our efforts are gonna

00:30:13,500 --> 00:30:18,659
be focused on improving the IP support

00:30:16,950 --> 00:30:20,940
that's in there and improving the number

00:30:18,659 --> 00:30:23,519
of platforms we support so kind of

00:30:20,940 --> 00:30:25,649
that's the next six to twelve months is

00:30:23,519 --> 00:30:27,600
really rounding out platform support but

00:30:25,649 --> 00:30:29,460
at launch we support all of these we

00:30:27,600 --> 00:30:31,500
support the full set of how drivers IP

00:30:29,460 --> 00:30:33,440
stack Bluetooth stack on all of these

00:30:31,500 --> 00:30:38,659
platforms software upgrade boot loaders

00:30:33,440 --> 00:30:41,130
it's all available I guess I'm running

00:30:38,659 --> 00:30:44,399
short on time but for more information

00:30:41,130 --> 00:30:48,240
my new at Apache org come talk to me and

00:30:44,399 --> 00:30:50,039
say hi development list we're looking

00:30:48,240 --> 00:30:52,889
for contributors everybody's welcome

00:30:50,039 --> 00:30:54,570
if the roadmap I presented here doesn't

00:30:52,889 --> 00:30:57,059
appeal to you and you want to add

00:30:54,570 --> 00:30:58,590
something just join the dev list and

00:30:57,059 --> 00:31:01,169
we're more than happy to take

00:30:58,590 --> 00:31:01,799
contributions and add people to the

00:31:01,169 --> 00:31:04,460
project

00:31:01,799 --> 00:31:04,460
so we're really

00:31:17,240 --> 00:31:19,300

YouTube URL: https://www.youtube.com/watch?v=5KhnjE7zYx4


