Title: LAS16-TR06: Remoteproc & rpmsg development
Publication date: 2016-09-30
Playlist: Linaro Connect Las Vegas 2016
Description: 
	LAS16-TR06: Remoteproc & rpmsg development
Speakers: Bjorn Andersson
Date: September 28, 2016

★ Session Description ★
Today the remoteproc & rpmsg code available in mainline serves as a base for numerous out-of-tree implementations, ranging from bug fixes to larger feature additions. As we’re discussing how to bring these additions towards mainline a common set of topics shows up between the various trees. This talk serves to give an insight into these discussions, ongoing work and connect people with interest in these subsystems.

★ Resources ★
Etherpad: pad.linaro.org/p/las16-tr06
Presentations & Videos: http://connect.linaro.org/resource/las16/las16-tr06/
★ Event Details ★
Linaro Connect Las Vegas 2016 – #LAS16
September 26-30, 2016
http://www.linaro.org
http://connect.linaro.org
Captions: 
	00:00:13,910 --> 00:00:29,010
the RP message and hardware spinlock so

00:00:25,170 --> 00:00:31,550
remote Brook it's a framework for

00:00:29,010 --> 00:00:40,379
controlling the lifecycle of

00:00:31,550 --> 00:00:44,520
coprocessors the processor loading

00:00:40,379 --> 00:00:47,730
former booting shutting them down what

00:00:44,520 --> 00:00:50,399
differs from for example you have normal

00:00:47,730 --> 00:00:53,070
device with some firmer is that

00:00:50,399 --> 00:01:07,650
generally the hardware doesn't have a

00:00:53,070 --> 00:01:11,180
function itself so we have a core and

00:01:07,650 --> 00:01:11,180
then we have remote probe drivers

00:01:16,850 --> 00:01:24,810
realloc structs and some context and we

00:01:22,590 --> 00:01:28,880
add that to the core and where the

00:01:24,810 --> 00:01:28,880
driver is done we delete it which

00:01:30,259 --> 00:01:40,409
references the operations back that have

00:01:36,930 --> 00:01:44,970
have two operations of importance one is

00:01:40,409 --> 00:01:47,369
start that one stop so when someone or

00:01:44,970 --> 00:01:52,500
something is trying to boot tells us to

00:01:47,369 --> 00:01:56,790
boot it will do resource allocation and

00:01:52,500 --> 00:01:59,610
then it would call start someone tells

00:01:56,790 --> 00:02:04,130
us that we don't stop and then the core

00:01:59,610 --> 00:02:07,069
will tear tear down those resources and

00:02:04,130 --> 00:02:12,410
currently there's a separated separate

00:02:07,069 --> 00:02:12,410
struct for firmware parsing

00:02:12,730 --> 00:02:25,180
default environment supports an elf elf

00:02:17,440 --> 00:02:30,480
format so in the elf file

00:02:25,180 --> 00:02:35,860
we have a research table describing the

00:02:30,480 --> 00:02:39,030
the resources needed by the former when

00:02:35,860 --> 00:02:45,760
it's loaded so we have memory core parts

00:02:39,030 --> 00:02:50,640
where firmware is loaded the data but it

00:02:45,760 --> 00:02:55,660
could be other things as well we have

00:02:50,640 --> 00:02:57,959
traced buffers that's for a specific use

00:02:55,660 --> 00:03:02,470
case there were specific things we have

00:02:57,959 --> 00:03:08,220
ver tire devices which is used for

00:03:02,470 --> 00:03:12,099
communicating with the running processor

00:03:08,220 --> 00:03:14,859
and that's so the the vertel devices

00:03:12,099 --> 00:03:19,889
will then be it could be network

00:03:14,859 --> 00:03:19,889
interfaces hero interfaces or RP message

00:03:24,389 --> 00:03:34,359
so the core the elf loader and the core

00:03:31,530 --> 00:03:38,220
in collaboration loads this research

00:03:34,359 --> 00:03:44,620
table sets up all these resources and

00:03:38,220 --> 00:03:48,430
then it called start in your driver one

00:03:44,620 --> 00:03:52,680
of the things we have here is that up

00:03:48,430 --> 00:03:55,450
until now it's been fine with just just

00:03:52,680 --> 00:04:02,530
listing what kind of memory regions in

00:03:55,450 --> 00:04:05,260
size that we need your allocation

00:04:02,530 --> 00:04:09,959
limitations for example if you need need

00:04:05,260 --> 00:04:15,669
allocation to end up in a certain area a

00:04:09,959 --> 00:04:17,109
specific position so there the research

00:04:15,669 --> 00:04:24,039
table have the information but the

00:04:17,109 --> 00:04:26,410
implementation but the allocation of

00:04:24,039 --> 00:04:28,960
both the memory cards delivered

00:04:26,410 --> 00:04:32,320
or the B rings associated were

00:04:28,960 --> 00:04:34,990
terrorizes are done in in the context of

00:04:32,320 --> 00:04:39,250
their remote put driver so we have some

00:04:34,990 --> 00:04:49,510
control of it but there are definitely

00:04:39,250 --> 00:04:52,230
some cases where people need more so the

00:04:49,510 --> 00:04:52,230
only going

00:04:56,040 --> 00:05:04,150
traditionally the model has been that

00:04:59,400 --> 00:05:08,470
either you have registered and you have

00:05:04,150 --> 00:05:10,510
some sort of third party driver with a

00:05:08,470 --> 00:05:13,060
reference to your remote property and it

00:05:10,510 --> 00:05:21,510
will tell you to tell it to boot and to

00:05:13,060 --> 00:05:23,770
shut down all there is devices

00:05:21,510 --> 00:05:33,580
associated with the remote profit that

00:05:23,770 --> 00:05:34,960
would trigger so one of the problems

00:05:33,580 --> 00:05:37,210
with how this have been implemented is

00:05:34,960 --> 00:05:40,290
that as soon as we found over tire

00:05:37,210 --> 00:05:42,850
advice we would register that with the

00:05:40,290 --> 00:05:44,830
device in the resource table we will

00:05:42,850 --> 00:05:47,770
register that with the tire framework

00:05:44,830 --> 00:05:50,440
which would go out and try to find the

00:05:47,770 --> 00:05:52,990
backing storage for the communication

00:05:50,440 --> 00:05:56,860
channels which would trigger a boot of

00:05:52,990 --> 00:05:59,440
the remote proc so in the event and you

00:05:56,860 --> 00:06:09,720
would list several devices in your

00:05:59,440 --> 00:06:12,730
resource table fully parsed so we might

00:06:09,720 --> 00:06:23,760
memory regions we definitely haven't

00:06:12,730 --> 00:06:28,150
allocated all the memory for there were

00:06:23,760 --> 00:06:31,890
some requests for being able to to have

00:06:28,150 --> 00:06:31,890
this third port controlling thingy

00:06:36,819 --> 00:06:41,180
mind could think up for example if you

00:06:39,050 --> 00:06:46,669
have a controller and then your your

00:06:41,180 --> 00:06:53,240
firmware exposes serial debug you don't

00:06:46,669 --> 00:06:56,629
want that to control you want this so I

00:06:53,240 --> 00:07:02,270
introduced a property on the remote

00:06:56,629 --> 00:07:04,430
private drivers instead that you can if

00:07:02,270 --> 00:07:13,909
you're expecting to be controlled by a

00:07:04,430 --> 00:07:20,620
client or if and that means that the

00:07:13,909 --> 00:07:20,620
behavior of the put no longer is tied to

00:07:27,460 --> 00:07:38,599
and a side effect that that simplifies

00:07:31,190 --> 00:07:40,250
because previously we had once we found

00:07:38,599 --> 00:07:42,529
that the firm we were there we would

00:07:40,250 --> 00:07:46,069
trigger the initialization of Burt IO

00:07:42,529 --> 00:07:47,659
devices which would then take a second

00:07:46,069 --> 00:07:55,940
pass at the research table and allocate

00:07:47,659 --> 00:07:58,279
all the resources so now it's no it's

00:07:55,940 --> 00:08:00,650
much easier when we decide to boot we

00:07:58,279 --> 00:08:04,029
parse the resource table once and we set

00:08:00,650 --> 00:08:04,029
everything up there we start

00:08:07,540 --> 00:08:13,030
yeah maybe I should say that they're

00:08:11,110 --> 00:08:15,640
thought about feature is currently in

00:08:13,030 --> 00:08:22,510
Linux next and I was I'm intending to

00:08:15,640 --> 00:08:24,730
add that before that line to find some

00:08:22,510 --> 00:08:33,790
issues with it so I have a few bug fixes

00:08:24,730 --> 00:08:36,550
that needs to be in place before then we

00:08:33,790 --> 00:08:40,150
have the next step ongoing thing which

00:08:36,550 --> 00:08:43,330
is in the case that the resource table

00:08:40,150 --> 00:08:47,380
have a list of carve-outs for example

00:08:43,330 --> 00:08:51,760
and we want to be able to control where

00:08:47,380 --> 00:08:58,180
in physical RAM those ends up we need a

00:08:51,760 --> 00:09:06,580
mechanism to amend the information in

00:08:58,180 --> 00:09:16,980
the resource table in my cases I have in

00:09:06,580 --> 00:09:16,980
device tree so it allows us to control

00:09:21,000 --> 00:09:25,590
it's d-mail coherent

00:09:26,820 --> 00:09:49,000
yes that's in the case when you have an

00:09:33,340 --> 00:09:53,410
eye we need the merging part especially

00:09:49,000 --> 00:09:56,050
for the resource table when it's it's

00:09:53,410 --> 00:09:58,650
used both for the former to communicate

00:09:56,050 --> 00:10:00,970
what can resources you need as well as

00:09:58,650 --> 00:10:03,880
for the kernel to communicate where

00:10:00,970 --> 00:10:18,370
those resources ended up in RAM to the

00:10:03,880 --> 00:10:28,120
firmware this would be a way to the

00:10:18,370 --> 00:10:32,820
various proposals we can

00:10:28,120 --> 00:10:32,820
programmatically allocate resources

00:11:01,860 --> 00:11:10,050
this having a safe guy allows for for

00:11:08,370 --> 00:11:13,610
the use case when we don't have a

00:11:10,050 --> 00:11:15,990
resource table in the program so

00:11:13,610 --> 00:11:18,209
especially like in the Qualcomm case

00:11:15,990 --> 00:11:21,089
where I'm where my drivers coming from

00:11:18,209 --> 00:11:34,290
we we have a fixed memory region that is

00:11:21,089 --> 00:11:36,149
for the course communication mechanism

00:11:34,290 --> 00:11:41,250
so I don't have to encode that in my

00:11:36,149 --> 00:11:46,290
driver there are there were some other

00:11:41,250 --> 00:11:47,910
cases where we have resource table data

00:11:46,290 --> 00:11:57,420
structures describing the same

00:11:47,910 --> 00:12:06,000
deformation the core infrastructure

00:11:57,420 --> 00:12:08,240
without relying in these cases the

00:12:06,000 --> 00:12:11,519
solution we have today is that we can

00:12:08,240 --> 00:12:13,529
load for more operations struct we can

00:12:11,519 --> 00:12:18,540
overload the load function and we can

00:12:13,529 --> 00:12:22,430
programmatically build up that of

00:12:18,540 --> 00:12:36,440
information and pasta to the core but

00:12:22,430 --> 00:12:36,440
that's on disk structure its resources

00:12:43,150 --> 00:12:55,450
and yeah so this is mainly for car lots

00:12:48,110 --> 00:12:55,450
one would I mean trace buffers would be

00:12:58,150 --> 00:13:04,670
the rings is complicated for the fact

00:13:01,820 --> 00:13:07,490
that in most cases we would need a

00:13:04,670 --> 00:13:15,230
mechanism to communicate their placement

00:13:07,490 --> 00:13:17,710
to the other side so yeah we need some

00:13:15,230 --> 00:13:20,150
sort mechanism to communicate that so

00:13:17,710 --> 00:13:23,690
first and foremost I would like this

00:13:20,150 --> 00:13:25,400
that I can reuse the carve-out logic in

00:13:23,690 --> 00:13:27,730
the core in the case that's what we

00:13:25,400 --> 00:13:27,730
don't have

00:13:33,890 --> 00:13:43,670
so the next thing that came up this

00:13:39,320 --> 00:13:47,600
discussion was we wanted to be able want

00:13:43,670 --> 00:13:50,570
the possibility to direct Verdi or

00:13:47,600 --> 00:13:53,480
buffers into certain memory regions for

00:13:50,570 --> 00:14:03,230
example device Ram so we want to be able

00:13:53,480 --> 00:14:06,279
to hire a map so looking at how the

00:14:03,230 --> 00:14:09,320
Corps handles things today there is a

00:14:06,279 --> 00:14:14,950
structure that holds the information

00:14:09,320 --> 00:14:17,750
related to karma which is fairly generic

00:14:14,950 --> 00:14:21,079
if we treat that as a generic just

00:14:17,750 --> 00:14:27,920
memory segment and we rely on previously

00:14:21,079 --> 00:14:31,130
introduced merging mechanisms then we

00:14:27,920 --> 00:14:32,390
would we would allow this API to

00:14:31,130 --> 00:14:35,930
register

00:14:32,390 --> 00:14:39,410
I will map regions or carve-outs or any

00:14:35,930 --> 00:14:42,130
specific type and when the research

00:14:39,410 --> 00:14:46,160
table is merged it would be the same

00:14:42,130 --> 00:14:48,410
data structure so in this the suggestion

00:14:46,160 --> 00:14:50,690
here is that we instead of operating on

00:14:48,410 --> 00:14:52,370
the resource table we parse the research

00:14:50,690 --> 00:14:59,480
table into something some generic data

00:14:52,370 --> 00:15:03,130
structure and operate on that different

00:14:59,480 --> 00:15:03,130
types of memory that same data structure

00:15:09,130 --> 00:15:14,240
if we do it like that

00:15:11,440 --> 00:15:17,120
the merging mechanism we could use that

00:15:14,240 --> 00:15:19,490
so that when the be wings are the b-wing

00:15:17,120 --> 00:15:22,360
memory is allocated if we fall back back

00:15:19,490 --> 00:15:26,269
to this generic data structure because

00:15:22,360 --> 00:15:26,959
we have the mechanism to to use

00:15:26,269 --> 00:15:29,660
carve-outs

00:15:26,959 --> 00:15:34,120
or we can use the course carve out

00:15:29,660 --> 00:15:34,120
mechanisms for backing the wings

00:15:42,139 --> 00:15:52,430
so the only concern we have then is if

00:15:49,019 --> 00:15:54,660
if the remote prescribers uses this API

00:15:52,430 --> 00:15:56,699
during its probe for example we will

00:15:54,660 --> 00:16:02,699
allocate all the resources at that time

00:15:56,699 --> 00:16:05,370
even the system so I made a prototype

00:16:02,699 --> 00:16:08,540
where I build this data structure but I

00:16:05,370 --> 00:16:08,540
don't actually do that

00:16:42,670 --> 00:16:45,360
yeah

00:18:22,920 --> 00:18:32,290
so they're the proposed patch was that

00:18:28,180 --> 00:18:33,310
the core good when allocating earrings

00:18:32,290 --> 00:18:35,560
or carve-outs

00:18:33,310 --> 00:18:50,020
first tried to call into the remote

00:18:35,560 --> 00:18:52,750
driver and see rather complex rather if

00:18:50,020 --> 00:18:56,980
we have a couple of carve outs a couple

00:18:52,750 --> 00:19:00,450
of earrings the driver would probably

00:18:56,980 --> 00:19:00,450
more or less having a switch statement

00:19:08,070 --> 00:19:13,720
so I think it's cleaner to pre-allocate

00:19:11,500 --> 00:19:15,850
in order to register those resources

00:19:13,720 --> 00:19:24,270
beforehand and then have the core match

00:19:15,850 --> 00:19:24,270
them with the previous suggestions

00:19:41,390 --> 00:20:44,059
yes sir soon as the remote driver starts

00:19:47,450 --> 00:20:44,059
resources between the two

00:21:47,320 --> 00:21:54,770
yes in the cases when we when we have we

00:21:51,110 --> 00:21:56,630
want the specific physical placement the

00:21:54,770 --> 00:22:09,140
question is what that means and if it

00:21:56,630 --> 00:22:10,970
means for example I think that having

00:22:09,140 --> 00:22:23,870
this callback from the core into the

00:22:10,970 --> 00:22:26,090
driver that's yes it's optional for each

00:22:23,870 --> 00:22:28,130
driver to have that but it's not

00:22:26,090 --> 00:22:30,290
optional for me to maintain all the code

00:22:28,130 --> 00:22:32,680
that will be duplicated between the

00:22:30,290 --> 00:22:32,680
drivers

00:23:03,780 --> 00:23:17,290
if we here but if we if we match the

00:23:15,250 --> 00:23:20,710
bering allocation on a full tour about

00:23:17,290 --> 00:23:23,200
allocation so we don't like the trace

00:23:20,710 --> 00:23:24,670
allocations they can just be there that

00:23:23,200 --> 00:23:44,080
could be a partial snippet inside a car

00:23:24,670 --> 00:23:48,010
but but if we match it to be a full the

00:23:44,080 --> 00:23:53,680
question here is also how static is this

00:23:48,010 --> 00:23:57,970
use case I mean when I build my device

00:23:53,680 --> 00:24:00,960
do I know exactly where that firm where

00:23:57,970 --> 00:24:06,930
what kind of resources that former has

00:24:00,960 --> 00:24:09,790
but and if I don't know that how can i

00:24:06,930 --> 00:24:12,570
how can I assist it in allocating these

00:24:09,790 --> 00:24:12,570
memory regions

00:25:11,919 --> 00:25:29,539
but if in all these cases that would be

00:25:16,029 --> 00:25:31,880
at the time when you file or whatever at

00:25:29,539 --> 00:25:37,970
that point I presume that each remote

00:25:31,880 --> 00:25:41,960
prop would get its available resources

00:25:37,970 --> 00:25:43,490
like how much memory does this thing is

00:25:41,960 --> 00:25:46,940
how much memory is this thing allowed to

00:25:43,490 --> 00:25:49,490
use for this particular remote program I

00:25:46,940 --> 00:25:53,860
want you to use these particular device

00:25:49,490 --> 00:25:53,860
memory regions or is that completely

00:26:28,429 --> 00:27:25,009
so one is using resources so it's not

00:27:53,809 --> 00:27:56,959
wondering if

00:28:26,550 --> 00:28:34,440
so I think whatever do you think we need

00:28:31,500 --> 00:28:38,390
to discuss the dynamic case but I think

00:28:34,440 --> 00:28:38,390
we need more stuff to get that in place

00:29:02,929 --> 00:29:06,169
yes it's

00:29:06,280 --> 00:29:12,460
I mean you could think of a setup where

00:29:09,760 --> 00:29:15,400
if I have my TI board I would have

00:29:12,460 --> 00:29:17,440
certain certain resources available

00:29:15,400 --> 00:29:20,280
certain memory regions available and I

00:29:17,440 --> 00:29:20,280
have to write my

00:30:38,150 --> 00:30:53,780
yes the question is how much quartz is

00:30:50,360 --> 00:30:56,000
fine because we can but for b-wings we

00:30:53,780 --> 00:30:58,550
we don't have any real identifiers so we

00:30:56,000 --> 00:31:01,030
can't say the driver can't say here is

00:30:58,550 --> 00:31:01,030
the memory

00:31:16,360 --> 00:31:33,220
I yes so for the free use case is

00:31:23,289 --> 00:31:34,149
supported in the kernel today we work

00:31:33,220 --> 00:32:05,049
just fine

00:31:34,149 --> 00:32:18,639
beyond that somehow so I think if we saw

00:32:05,049 --> 00:32:24,639
the soft static case I think this will

00:32:18,639 --> 00:32:27,059
work when so when the driver knows what

00:32:24,639 --> 00:32:27,059
the firm

00:32:45,309 --> 00:32:53,289
the other thing that in the workings is

00:32:53,350 --> 00:32:59,830
so at the places where we do where we

00:32:56,840 --> 00:33:19,639
register and register birth dial devices

00:32:59,830 --> 00:33:21,529
in the platforms so and there are there

00:33:19,639 --> 00:33:24,139
are some other cases where for example

00:33:21,529 --> 00:33:27,409
you have a different Linux driver that

00:33:24,139 --> 00:33:37,250
you that exposes some functionality from

00:33:27,409 --> 00:33:40,909
the firmware and we want that to be we

00:33:37,250 --> 00:33:46,490
have a need to be able to model thing is

00:33:40,909 --> 00:33:54,649
that running state of the problem so

00:33:46,490 --> 00:34:05,149
instead of having a slightly more

00:33:54,649 --> 00:34:09,290
generalized or maybe even platform

00:34:05,149 --> 00:34:13,580
drivers that once the former comes up we

00:34:09,290 --> 00:34:22,639
we probe that register what's the

00:34:13,580 --> 00:34:30,379
terminals down we register it the

00:34:22,639 --> 00:34:33,250
questions should should the core deal

00:34:30,379 --> 00:34:36,379
with some of these standard types

00:34:33,250 --> 00:34:48,050
helper function the core to say my

00:34:36,379 --> 00:34:52,210
device driver do the rest for me I think

00:34:48,050 --> 00:34:52,210
there would be corner cases I'll post

00:34:52,240 --> 00:34:55,480
the drive

00:34:55,500 --> 00:35:04,430
these devices and there would be protein

00:34:58,980 --> 00:35:04,430
removed that's yes

00:35:58,780 --> 00:36:05,690
but do you have do you have your ice

00:36:03,770 --> 00:36:08,570
Percy do you do ask receive

00:36:05,690 --> 00:36:10,670
communication where the record does it

00:36:08,570 --> 00:36:14,170
implement especially communication with

00:36:10,670 --> 00:36:14,170
there with some devices

00:36:30,130 --> 00:37:51,259
so there is a chance that that might

00:37:48,440 --> 00:38:04,549
crash we might need to restart it and

00:37:51,259 --> 00:38:07,640
the restart will be crashed and it shuts

00:38:04,549 --> 00:38:12,229
it down probably want to be able to

00:38:07,640 --> 00:38:13,339
extract some core don't memory and then

00:38:12,229 --> 00:38:16,660
we want to start it again

00:38:13,339 --> 00:38:16,660
and if we model them

00:39:14,329 --> 00:39:19,829
so I haven't seen a use case yet for

00:39:18,450 --> 00:39:22,130
where we actually need to be able to

00:39:19,829 --> 00:39:22,130
sing

00:40:22,900 --> 00:40:27,340
so does that mean that you have a user

00:40:25,190 --> 00:40:27,340
base

00:40:46,580 --> 00:40:51,320
but for those components that sits

00:41:37,680 --> 00:41:43,980
but this there would there be a problem

00:41:40,349 --> 00:41:44,490
to model those as children of the output

00:41:43,980 --> 00:41:54,750
node

00:41:44,490 --> 00:42:04,890
oh they yeah no because like I said

00:41:54,750 --> 00:42:10,970
there are several the use cases I've

00:42:04,890 --> 00:42:10,970
seen today I have so it's either/or

00:42:12,410 --> 00:42:20,940
there are some classroom drivers that

00:42:14,970 --> 00:42:23,279
could follow that lifecycle so and then

00:42:20,940 --> 00:42:26,250
we have a couple of proposals for having

00:42:23,279 --> 00:42:29,279
this first and foremost for having a

00:42:26,250 --> 00:42:30,869
device three beyond the reference to a

00:42:29,279 --> 00:42:42,089
remote probe to be able to control it

00:42:30,869 --> 00:42:44,880
and Rob said why I haven't seen an

00:42:42,089 --> 00:42:51,440
example where it's needed except for the

00:42:44,880 --> 00:42:51,440
peer USS and I don't know how you would

00:42:54,049 --> 00:43:00,869
because it's not Hardware it's entirely

00:42:59,220 --> 00:43:07,680
a software construct for controlling

00:43:00,869 --> 00:43:11,960
over so the question is then is it valid

00:43:07,680 --> 00:43:11,960
to have this kind of control mechanism

00:43:14,569 --> 00:43:20,520
and another thing is in the cases when

00:43:18,089 --> 00:43:24,299
people want to start and stop the remote

00:43:20,520 --> 00:43:27,510
clock from user space there I think

00:43:24,299 --> 00:43:30,750
there was a Sisyphus interface for this

00:43:27,510 --> 00:43:36,539
or there is at least proposed Sisyphus

00:43:30,750 --> 00:43:43,680
interface for it but again it's a matter

00:43:36,539 --> 00:43:46,190
of what what are actual use cases we

00:43:43,680 --> 00:43:46,190
need to see some

00:43:47,730 --> 00:43:54,370
decide how we want to model that and we

00:43:51,730 --> 00:43:58,300
want to see what happens if i if i have

00:43:54,370 --> 00:43:59,740
my if i have an internal consumer if we

00:43:58,300 --> 00:44:04,030
come up with a use case for an internal

00:43:59,740 --> 00:44:06,280
consumer and that starts and the user

00:44:04,030 --> 00:44:14,110
space come in and say stop what does

00:44:06,280 --> 00:44:16,660
that mean and when is that valid there's

00:44:14,110 --> 00:44:21,160
definitely the problem of when do we

00:44:16,660 --> 00:44:22,990
actually start remote props and the way

00:44:21,160 --> 00:44:25,060
it works with autoboot thing is that

00:44:22,990 --> 00:44:27,130
when the firmware is available that we

00:44:25,060 --> 00:44:30,910
build it or when there is a third party

00:44:27,130 --> 00:44:38,850
components asking those cupboard and

00:44:30,910 --> 00:44:38,850
currents so I would really like to see

00:44:51,760 --> 00:44:58,730
yeah we we definitely need a mechanism

00:44:54,260 --> 00:45:04,300
to when the remote polka misbehaves to

00:44:58,730 --> 00:45:04,300
to extract a memory core gum from that

00:45:05,140 --> 00:45:12,500
so I'm gonna take another look at the TI

00:45:10,210 --> 00:45:14,570
there seems to be some TI code from

00:45:12,500 --> 00:45:25,480
three to four times that does this

00:45:14,570 --> 00:45:25,480
somewhere we we want to back up memory

00:45:33,280 --> 00:45:39,430
segments that driver or the resource

00:45:36,530 --> 00:45:39,430
table had

00:45:49,470 --> 00:45:56,230
yeah with all this ice introduced

00:45:52,990 --> 00:46:00,910
previously well drivers or the research

00:45:56,230 --> 00:46:03,550
table would use would register generic

00:46:00,910 --> 00:46:04,930
resources we should be able to turn that

00:46:03,550 --> 00:46:06,930
one around so there isn't so much

00:46:04,930 --> 00:46:09,730
coupling between the core and the

00:46:06,930 --> 00:46:16,540
research table parser but rather we have

00:46:09,730 --> 00:46:18,700
a resource in the parts which were

00:46:16,540 --> 00:46:22,780
default to the current behavior but be

00:46:18,700 --> 00:46:54,089
driven by that portion to register

00:46:22,780 --> 00:46:57,160
resources it's it becomes now I have

00:46:54,089 --> 00:47:10,470
most of these things I have implemented

00:46:57,160 --> 00:47:10,470
for two threads and some other things

00:47:14,670 --> 00:47:23,410
one outstanding issue in a lot of these

00:47:21,760 --> 00:47:38,440
systems we have firmware files that are

00:47:23,410 --> 00:47:41,170
huge in some cases even legal

00:47:38,440 --> 00:47:48,430
requirements that forces us to put it

00:47:41,170 --> 00:47:50,440
somewhere else so we will put them we'll

00:47:48,430 --> 00:47:53,970
have a system partition that once that

00:47:50,440 --> 00:47:53,970
is mounted we would have the

00:47:55,740 --> 00:48:06,330
signal Colonel and this becomes sort of

00:48:04,410 --> 00:48:10,010
equivalent to having a system and this

00:48:06,330 --> 00:48:10,010
is a percent way where we say start

00:48:13,250 --> 00:48:20,310
there are two working options for this

00:48:17,910 --> 00:48:23,730
today one is to use kernel modules if

00:48:20,310 --> 00:48:33,390
you load your driver once the firm is

00:48:23,730 --> 00:48:38,780
available it will be user space firmware

00:48:33,390 --> 00:48:38,780
loading there is a remnant in that code

00:48:39,110 --> 00:48:45,390
there is a remnant in the firmware class

00:48:42,119 --> 00:48:47,940
that if it fails to load a firmware file

00:48:45,390 --> 00:48:50,850
it will fall back to wait for some

00:48:47,940 --> 00:48:52,680
period of time for and it will send out

00:48:50,850 --> 00:48:55,770
the you event and we wait for some time

00:48:52,680 --> 00:49:00,330
for user space to feed the firmer in to

00:48:55,770 --> 00:49:02,070
this class firmware and no one supports

00:49:00,330 --> 00:49:04,080
this since like three years back when

00:49:02,070 --> 00:49:06,290
system D dropped it but it works

00:49:04,080 --> 00:49:06,290
perfectly

00:49:18,319 --> 00:49:45,240
and Dimitri suggests that we just have a

00:49:25,289 --> 00:49:47,430
done with the policies needed to a lot

00:49:45,240 --> 00:50:04,170
of these cases we have very similar

00:49:47,430 --> 00:50:08,220
former but different devices have this

00:50:04,170 --> 00:50:13,920
is the kernel modules and fallback works

00:50:08,220 --> 00:50:16,250
and I hate to force people to use kernel

00:50:13,920 --> 00:50:16,250
modules

00:50:41,640 --> 00:50:52,289
now it works the question is if they

00:50:43,769 --> 00:51:00,569
want but there was a patch posted that

00:50:52,289 --> 00:51:08,460
that introduced like a the file systems

00:51:00,569 --> 00:51:16,650
are available I try to discuss something

00:51:08,460 --> 00:51:29,279
like this he wants us to use kernel

00:51:16,650 --> 00:51:35,670
modules talks to him that report or P

00:51:29,279 --> 00:51:39,329
message it's it's a framework and wire

00:51:35,670 --> 00:51:42,960
format for exchanging packets of data

00:51:39,329 --> 00:51:45,660
and what differs it from a typical

00:51:42,960 --> 00:52:00,539
Network thing is that it's all over

00:51:45,660 --> 00:52:05,249
point-to-point channels so you write to

00:52:00,539 --> 00:52:08,759
an optimistic message driver and you tie

00:52:05,249 --> 00:52:11,069
it to you register it with the core when

00:52:08,759 --> 00:52:12,960
there is a channel related channel

00:52:11,069 --> 00:52:20,119
available your driver will be probed and

00:52:12,960 --> 00:52:23,130
when the channel goes away you have

00:52:20,119 --> 00:52:28,950
basically two functions three three

00:52:23,130 --> 00:52:40,710
functions you have you can send data on

00:52:28,950 --> 00:52:45,599
this channel that you're with and the

00:52:40,710 --> 00:52:49,009
core the Krait endpoint to destroy the

00:52:45,599 --> 00:52:51,720
endpoint if you want to

00:52:49,009 --> 00:52:58,319
try to associate with additional

00:52:51,720 --> 00:53:07,799
channels point-to-point channels you can

00:52:58,319 --> 00:53:09,599
use this API to to try to open it the

00:53:07,799 --> 00:53:11,099
secondary channels is or you have to

00:53:09,599 --> 00:53:19,999
sort of expect that they follow the

00:53:11,099 --> 00:53:33,809
primary Shannon's life cycle in the

00:53:19,999 --> 00:53:36,390
current implementation message when I

00:53:33,809 --> 00:53:39,450
moved the qualcomm shared memory

00:53:36,390 --> 00:53:44,309
computation method into mainline two

00:53:39,450 --> 00:53:48,289
years ago I think I modeled it so that

00:53:44,309 --> 00:53:48,289
it would be very similar Torpy message

00:53:53,029 --> 00:54:33,390
the structure of the devices in message

00:53:58,589 --> 00:54:37,099
device and then I introduced the

00:54:33,390 --> 00:54:37,099
implementation as one of the backends

00:54:46,009 --> 00:54:52,920
some of the services so we will have one

00:54:50,579 --> 00:54:55,460
API for talking to these point-to-point

00:54:52,920 --> 00:54:55,460
channels

00:55:12,810 --> 00:56:44,109
so to be able to access or it's mostly

00:56:42,520 --> 00:56:46,150
because we don't want the long list of

00:56:44,109 --> 00:56:47,740
hard-coded names in the kernel that for

00:56:46,150 --> 00:56:56,020
this platform these channels should be

00:56:47,740 --> 00:56:58,900
exposed to user space and we need some

00:56:56,020 --> 00:57:02,320
sort mechanism for some sort control

00:56:58,900 --> 00:57:04,900
interface for saying on this RP message

00:57:02,320 --> 00:57:08,100
instance create the character device or

00:57:04,900 --> 00:57:08,100
some sort of handle

00:57:09,950 --> 00:57:25,859
so this is ongoing discussion I think

00:57:19,290 --> 00:57:30,740
the last the more complex derivatives

00:57:25,859 --> 00:57:30,740
from the tear solution I think we can

00:57:42,930 --> 00:57:56,910
yes yes or something like that some way

00:57:51,069 --> 00:57:56,910
to to have a control interface to words

00:57:59,069 --> 00:58:04,390
to tell that thing or basically to be

00:58:02,440 --> 00:58:09,509
able to call crate endpoint and destroy

00:58:04,390 --> 00:58:11,559
endpoint from user space then just

00:58:09,509 --> 00:58:18,039
expose that is something that we can

00:58:11,559 --> 00:58:21,069
read and write on so most likely I would

00:58:18,039 --> 00:58:41,769
like that to be if we expose those two

00:58:21,069 --> 00:58:44,799
functions to user space and we have when

00:58:41,769 --> 00:58:47,680
user space want to have direct contact

00:58:44,799 --> 00:58:50,460
with other side so whenever you want to

00:58:47,680 --> 00:58:50,460
do processing

00:59:00,900 --> 00:59:06,040
yeah yeah if you have some special thing

00:59:03,730 --> 00:59:09,630
we need to do stuff in the kernel or you

00:59:06,040 --> 00:59:09,630
want to expose that channel

00:59:43,500 --> 00:59:50,730
one thing that we've seen several times

00:59:45,329 --> 00:59:55,400
being useful is to be able to dump down

00:59:50,730 --> 00:59:55,400
these channels we used quite extensively

00:59:56,030 --> 01:00:10,320
platforms I would like to see more or

01:00:01,470 --> 01:00:18,660
less happy version of that and if we can

01:00:10,320 --> 01:00:21,140
get this pcap this started writing much

01:00:18,660 --> 01:00:21,140
codons

01:00:34,289 --> 01:00:37,439
more questions

01:00:54,320 --> 01:01:01,040
yes it will turn out to be that because

01:00:57,120 --> 01:01:01,040
I think you can have custom

01:03:11,020 --> 01:03:21,579
there is there is

01:04:22,950 --> 01:04:31,770
yeah yeah but say that you were actually

01:04:28,650 --> 01:04:35,420
happy using mailbox for for not only

01:04:31,770 --> 01:04:35,420
transmitting one value at the time

01:05:15,920 --> 01:05:22,609
yes yes

01:05:20,119 --> 01:05:28,880
Lina have a patch that she wants me to

01:05:22,609 --> 01:05:32,809
merge so they I think they're only

01:05:28,880 --> 01:05:36,109
outstanding discussion we have is so

01:05:32,809 --> 01:05:45,500
today the harbor spinlock frameworks

01:05:36,109 --> 01:05:47,569
expected to spin locks are used but Lina

01:05:45,500 --> 01:05:58,760
has is a case where she wants to lock it

01:05:47,569 --> 01:06:01,099
and the question that needs to be

01:05:58,760 --> 01:06:03,829
answered is is that a property of that

01:06:01,099 --> 01:06:06,530
lock or is it a property of a parade of

01:06:03,829 --> 01:06:08,329
the lock operation because the way the

01:06:06,530 --> 01:06:15,109
framework is modeled today is that you

01:06:08,329 --> 01:06:26,990
have operations whether you want to to

01:06:15,109 --> 01:06:30,910
disable our queues and if you this could

01:06:26,990 --> 01:06:30,910
be both drawn as just another operation

01:06:41,680 --> 01:06:46,839
one could bolt on another function that

01:06:44,420 --> 01:06:46,839
skips

01:07:06,300 --> 01:07:11,850
because we the this particular use case

01:07:21,270 --> 01:07:43,780
but this specific use case is a

01:07:25,120 --> 01:07:45,670
synchronization between the two to make

01:07:43,780 --> 01:07:52,360
sure that when the kernel have decided

01:07:45,670 --> 01:07:56,110
that dangled idle another core waking

01:07:52,360 --> 01:07:58,920
and start executing the kernel and then

01:07:56,110 --> 01:07:58,920
the kernel

01:08:17,199 --> 01:08:19,920

YouTube URL: https://www.youtube.com/watch?v=QnnLvmvriVA


