Title: LAS16-300: Mini Conference 2 Cortex M Software Device Configuration
Publication date: 2016-09-30
Playlist: Linaro Connect Las Vegas 2016
Description: 
	LAS16-300: Mini Conference 2 RTOS-Zephyr - Device Configuration
Speakers: Andy Gross
Date: September 28, 2016

★ Session Description ★
SoC Vendors, board vendors, software middle layers, scripting languages, etc all need to have access to system configuration information (pin muxes, what sensors are on a system, what amount of memory, flash, etc, etc). We need a means to convey this in a vendor neutral mechanism but also one that is friendly for Cortex-M/constrained footprint devices. This session will be to discuss the topic, how its done today, what kinda tooling might exist from different vendors, what we could utilize (device tree) and what issues that creates.

★ Resources ★
Etherpad: pad.linaro.org/p/las16-300
Presentations & Videos: http://connect.linaro.org/resource/las16/las16-300/

★ Event Details ★
Linaro Connect Las Vegas 2016 – #LAS16
September 26-30, 2016
http://www.linaro.org
http://connect.linaro.org
Captions: 
	00:00:07,130 --> 00:00:15,599
okay I guess we'll go ahead and get

00:00:09,750 --> 00:00:19,590
started so this session is specifically

00:00:15,599 --> 00:00:21,090
focused on some of the configuration and

00:00:19,590 --> 00:00:24,510
initialization that's being done in this

00:00:21,090 --> 00:00:28,050
effort my name is Andy gross i'm part of

00:00:24,510 --> 00:00:29,820
the light team in linaro and this is

00:00:28,050 --> 00:00:36,420
what I've been focused on in the past

00:00:29,820 --> 00:00:38,100
probably month and a half so before i

00:00:36,420 --> 00:00:41,010
get into the introduction to device tree

00:00:38,100 --> 00:00:43,379
let me talk just a minute about zephyr

00:00:41,010 --> 00:00:44,730
and one of the first tasks i had going

00:00:43,379 --> 00:00:47,370
into this was to look at the different

00:00:44,730 --> 00:00:52,020
distributions out there like zephyr not

00:00:47,370 --> 00:00:54,199
x my new couple others just to get an

00:00:52,020 --> 00:00:56,399
idea of you know what what the state of

00:00:54,199 --> 00:00:59,190
you know these different distributions

00:00:56,399 --> 00:01:02,460
were how they did things how they

00:00:59,190 --> 00:01:04,049
utilize simpson and if you don't know

00:01:02,460 --> 00:01:05,670
what since this is i have a slide later

00:01:04,049 --> 00:01:07,500
that talks about some of the things that

00:01:05,670 --> 00:01:10,680
since this brings it's kind of a

00:01:07,500 --> 00:01:14,159
specification that that allows you to

00:01:10,680 --> 00:01:16,680
describe hardware configuration driver

00:01:14,159 --> 00:01:19,500
api's are tops api's things of that

00:01:16,680 --> 00:01:20,729
nature but initially when i got into

00:01:19,500 --> 00:01:21,930
this i was looking at those types of

00:01:20,729 --> 00:01:24,110
things and then it naturally progressed

00:01:21,930 --> 00:01:26,610
into okay now we're gonna use effort

00:01:24,110 --> 00:01:28,310
what can we do in Zephyr to make things

00:01:26,610 --> 00:01:31,619
a little bit easier with respect to

00:01:28,310 --> 00:01:34,409
configuration of boards because we all

00:01:31,619 --> 00:01:35,939
know you know a manufacturer a

00:01:34,409 --> 00:01:38,490
semiconductor company will put out on a

00:01:35,939 --> 00:01:40,200
chip and some number of words will be

00:01:38,490 --> 00:01:43,560
built off that chip and they'll be

00:01:40,200 --> 00:01:44,040
various configuration variations in

00:01:43,560 --> 00:01:45,930
those

00:01:44,040 --> 00:01:47,490
you know some have this type of setup

00:01:45,930 --> 00:01:51,240
some have a different type there's

00:01:47,490 --> 00:01:54,090
different peripherals pin mocks maybe

00:01:51,240 --> 00:01:55,650
different things that nature so so we

00:01:54,090 --> 00:01:59,130
tried to come up with a way to to deal

00:01:55,650 --> 00:02:01,470
with that so we're going to talk about

00:01:59,130 --> 00:02:05,340
how we could use device tree to solve

00:02:01,470 --> 00:02:06,720
some of these problems so let me do a

00:02:05,340 --> 00:02:09,330
little bit of an introduction to device

00:02:06,720 --> 00:02:10,800
tree and I'd like to note that if

00:02:09,330 --> 00:02:13,770
anybody has any questions or wants to

00:02:10,800 --> 00:02:17,100
have or discuss some of these topics so

00:02:13,770 --> 00:02:19,440
please jump in and we can give you a mic

00:02:17,100 --> 00:02:21,090
and we can talk through this this isn't

00:02:19,440 --> 00:02:23,130
meant to be a presentation where I talk

00:02:21,090 --> 00:02:24,600
at everyone and you know 50 minutes goes

00:02:23,130 --> 00:02:26,130
by and everybody gets up and leaves this

00:02:24,600 --> 00:02:27,390
is supposed to be a discussion we want

00:02:26,130 --> 00:02:29,910
to have some back and forth to talk

00:02:27,390 --> 00:02:32,310
about things and in fact I'll have some

00:02:29,910 --> 00:02:33,690
questions in here that are going to be

00:02:32,310 --> 00:02:36,510
really directed to some of the people

00:02:33,690 --> 00:02:39,510
that are here about how some of these

00:02:36,510 --> 00:02:42,450
other distributions views or do things

00:02:39,510 --> 00:02:44,940
so so first off let's talk a little bit

00:02:42,450 --> 00:02:46,770
about device truth if you're someone who

00:02:44,940 --> 00:02:48,420
has a Linux background you're probably

00:02:46,770 --> 00:02:51,810
already familiar with device tree and

00:02:48,420 --> 00:02:54,330
what it can bring to the system device

00:02:51,810 --> 00:02:57,150
tree I believe came into being in the

00:02:54,330 --> 00:03:01,070
PowerPC days it was a way of describing

00:02:57,150 --> 00:03:05,130
the system peripherals all that and

00:03:01,070 --> 00:03:06,660
lenox uses it not only to describe the

00:03:05,130 --> 00:03:09,750
system but it also uses it during the

00:03:06,660 --> 00:03:12,450
run time it actually keeps a flattened

00:03:09,750 --> 00:03:16,500
device tree blob any system and it uses

00:03:12,450 --> 00:03:18,600
that to create 50 of devices and that's

00:03:16,500 --> 00:03:23,010
that's used during probing of devices

00:03:18,600 --> 00:03:26,370
it's also used later one of the nice

00:03:23,010 --> 00:03:28,230
things about device tree is you can it's

00:03:26,370 --> 00:03:31,260
a text file initially so you can go in

00:03:28,230 --> 00:03:33,630
and you can modify it if you have a

00:03:31,260 --> 00:03:35,100
board that is a slight variation on an

00:03:33,630 --> 00:03:37,739
already existing board you can actually

00:03:35,100 --> 00:03:38,110
leverage a lot of the device tree and

00:03:37,739 --> 00:03:39,670
from

00:03:38,110 --> 00:03:43,570
that's already out there for that for

00:03:39,670 --> 00:03:47,170
that system it's pretty straightforward

00:03:43,570 --> 00:03:49,690
I did include a link to the device pre

00:03:47,170 --> 00:03:52,390
specification I actually thumbed through

00:03:49,690 --> 00:03:53,440
that this morning just to see how how

00:03:52,390 --> 00:03:56,080
straightforward it is it's actually

00:03:53,440 --> 00:04:00,520
pretty good read that they lay out all

00:03:56,080 --> 00:04:04,090
the okay that didn't come out right it's

00:04:00,520 --> 00:04:06,520
a good it's a good document it describes

00:04:04,090 --> 00:04:08,260
very simply how the Vice tree is laid

00:04:06,520 --> 00:04:11,230
out it talks about nodes it talks about

00:04:08,260 --> 00:04:16,380
how properties all that I didn't mean to

00:04:11,230 --> 00:04:19,260
actually talked about it but in any case

00:04:16,380 --> 00:04:23,680
when I talk about classical device tree

00:04:19,260 --> 00:04:25,900
firm or to how linux uses it zephyr i

00:04:23,680 --> 00:04:27,730
think we can leverage some of the

00:04:25,900 --> 00:04:29,500
strengths that device tree has and we

00:04:27,730 --> 00:04:31,300
can kind of leave some of the things

00:04:29,500 --> 00:04:32,650
that linux uses it for because that

00:04:31,300 --> 00:04:39,850
doesn't really apply to what we want to

00:04:32,650 --> 00:04:41,530
use it for so to get an idea of how the

00:04:39,850 --> 00:04:43,000
vice tree to help us we need to talk a

00:04:41,530 --> 00:04:46,470
little bit about how configuration is

00:04:43,000 --> 00:04:48,729
currently done in zephyr there's kind of

00:04:46,470 --> 00:04:50,830
there's a split in the directory

00:04:48,729 --> 00:04:54,280
structures if you if you look at zephyr

00:04:50,830 --> 00:04:55,390
there's an arch arm area where there's a

00:04:54,280 --> 00:04:57,280
lot of information on the different

00:04:55,390 --> 00:04:58,870
boards and there's also a boards

00:04:57,280 --> 00:05:02,890
directory where there's other

00:04:58,870 --> 00:05:06,220
information every board has a presence

00:05:02,890 --> 00:05:07,930
in both of these directories and if you

00:05:06,220 --> 00:05:09,220
go through and you just pick I don't

00:05:07,930 --> 00:05:11,350
know any one of the arm boards and you

00:05:09,220 --> 00:05:14,350
look at both of the directories you'll

00:05:11,350 --> 00:05:15,970
see make files you'll see k config files

00:05:14,350 --> 00:05:18,970
will see a def config file you'll see

00:05:15,970 --> 00:05:22,870
some C files and you'll see some include

00:05:18,970 --> 00:05:25,060
files if you look at each one of these

00:05:22,870 --> 00:05:27,580
files and you look at what the contents

00:05:25,060 --> 00:05:30,270
are you start to see a pattern you'll

00:05:27,580 --> 00:05:33,330
see a lot of configuration information

00:05:30,270 --> 00:05:36,139
hard-coded into these k config files

00:05:33,330 --> 00:05:39,259
you'll also notice that

00:05:36,139 --> 00:05:42,379
as each new board is defined you'll see

00:05:39,259 --> 00:05:43,669
a whole new directory in both places and

00:05:42,379 --> 00:05:45,620
in some cases you'll see a lot of

00:05:43,669 --> 00:05:47,150
copying of information from one place to

00:05:45,620 --> 00:05:49,490
another so there's not a lot of

00:05:47,150 --> 00:05:55,129
leveraging of the boards that are

00:05:49,490 --> 00:06:01,310
already very similar to that so let's

00:05:55,129 --> 00:06:03,590
see so when you build in in Zephyr you

00:06:01,310 --> 00:06:05,749
you specify a specific board it goes

00:06:03,590 --> 00:06:08,419
through ratchets through the the make

00:06:05,749 --> 00:06:10,189
files and does does what you want in the

00:06:08,419 --> 00:06:12,310
background what's happening actually is

00:06:10,189 --> 00:06:16,430
these Kate config files are used to

00:06:12,310 --> 00:06:19,370
select pieces that are compiled the font

00:06:16,430 --> 00:06:21,800
it defines information that's used in

00:06:19,370 --> 00:06:23,150
the system in the board file typically

00:06:21,800 --> 00:06:24,979
what you'll have is it'll you'll go

00:06:23,150 --> 00:06:28,310
through it in it and you'll do a clock

00:06:24,979 --> 00:06:31,520
in it you may do some pin configurations

00:06:28,310 --> 00:06:33,139
and then you'll start to do some of the

00:06:31,520 --> 00:06:35,180
device initializations and if you go and

00:06:33,139 --> 00:06:38,060
you look at the drivers like let's say

00:06:35,180 --> 00:06:39,499
you are driver there'll be structures

00:06:38,060 --> 00:06:42,800
that are actually defined inside the

00:06:39,499 --> 00:06:45,949
source code that are based off of what

00:06:42,800 --> 00:06:47,839
your k config options are specifying so

00:06:45,949 --> 00:06:51,409
for instance if let's say you have 5

00:06:47,839 --> 00:06:54,349
York ports you'll have ifdef gpio a

00:06:51,409 --> 00:06:56,389
you'll have a structured blob you may

00:06:54,349 --> 00:06:58,189
have a device API in the net call and

00:06:56,389 --> 00:07:00,589
then you'll have an end if and you'll

00:06:58,189 --> 00:07:02,629
have that cut and pasted down for each

00:07:00,589 --> 00:07:04,580
one of the you are port options that you

00:07:02,629 --> 00:07:06,379
have and if you go and you look at the

00:07:04,580 --> 00:07:09,710
cake and figs on some boards you may

00:07:06,379 --> 00:07:11,689
have ABCD on the gpios you may have a be

00:07:09,710 --> 00:07:16,930
on a different one and so that's how

00:07:11,689 --> 00:07:16,930
they manage having multiples of devices

00:07:25,790 --> 00:07:31,290
so one of the things that gets that gets

00:07:28,680 --> 00:07:34,250
utilized inside zephyr to some extent

00:07:31,290 --> 00:07:38,340
depending on which board it is is the

00:07:34,250 --> 00:07:41,900
symphysis information so sim sis is is

00:07:38,340 --> 00:07:44,910
designed to be a vendor agnostic

00:07:41,900 --> 00:07:49,170
hardware abstraction layer what it does

00:07:44,910 --> 00:07:50,640
is is a arm puts out Simpson a set of

00:07:49,170 --> 00:07:53,120
files and descriptions for synthesis

00:07:50,640 --> 00:07:56,100
this is okay this is a cortex m3 or m4

00:07:53,120 --> 00:07:58,680
this is the stuff that has to be there

00:07:56,100 --> 00:08:00,420
this will always be the same and then a

00:07:58,680 --> 00:08:02,070
vendor can come in and actually add some

00:08:00,420 --> 00:08:04,620
bomb the bomb informations or some

00:08:02,070 --> 00:08:06,450
slight modifications on the system like

00:08:04,620 --> 00:08:08,790
for instance one board may have 86

00:08:06,450 --> 00:08:10,920
interrupts one may have 90 well that's a

00:08:08,790 --> 00:08:15,000
difference that hat that may be encoded

00:08:10,920 --> 00:08:21,720
in there Simpson fragment that is added

00:08:15,000 --> 00:08:24,600
on top of the court Simpsons provides a

00:08:21,720 --> 00:08:27,120
number of facilities actually in Zephyr

00:08:24,600 --> 00:08:32,010
that you see references to the symphysis

00:08:27,120 --> 00:08:34,530
core that's kind of like the base

00:08:32,010 --> 00:08:36,210
information in the system there's some

00:08:34,530 --> 00:08:38,250
api's and definitions there's some

00:08:36,210 --> 00:08:40,200
things like some some assembly

00:08:38,250 --> 00:08:42,660
directives that gives you facilities

00:08:40,200 --> 00:08:45,870
like is B and DSP which is your your

00:08:42,660 --> 00:08:51,630
cash operations are not cash operations

00:08:45,870 --> 00:08:53,400
or instruction yeah barriers things like

00:08:51,630 --> 00:08:55,050
that so if you look at some other

00:08:53,400 --> 00:08:56,490
distributions you may see that those

00:08:55,050 --> 00:08:58,770
have been reimplemented they don't use

00:08:56,490 --> 00:09:00,450
the symphysis cord which i think is kind

00:08:58,770 --> 00:09:03,060
of a waste i mean the nice thing about

00:09:00,450 --> 00:09:04,560
some of these things is with the core

00:09:03,060 --> 00:09:07,290
you don't have to worry about

00:09:04,560 --> 00:09:08,910
implementing very specific types of

00:09:07,290 --> 00:09:12,150
functions like this you can just use

00:09:08,910 --> 00:09:14,510
them they're there it's nice it makes

00:09:12,150 --> 00:09:17,180
everybody act look the same

00:09:14,510 --> 00:09:18,800
and the other thing is is that you're

00:09:17,180 --> 00:09:20,240
not spending time reimplemented a lot of

00:09:18,800 --> 00:09:23,810
these things that are already done that

00:09:20,240 --> 00:09:25,670
just doesn't make sense why do it other

00:09:23,810 --> 00:09:27,830
parts of simchas there's a simpsons

00:09:25,670 --> 00:09:30,470
driver which provides some driver

00:09:27,830 --> 00:09:33,860
interfaces so so they kind of came up

00:09:30,470 --> 00:09:38,840
with their own set of api's for dealing

00:09:33,860 --> 00:09:41,930
with drivers there's this SVD component

00:09:38,840 --> 00:09:44,360
if you look at some of the ides out

00:09:41,930 --> 00:09:47,000
there like Kyle and maybe a few of the

00:09:44,360 --> 00:09:51,230
other ones they utilize some of the SPD

00:09:47,000 --> 00:09:53,090
things basically SPD is XML and it's

00:09:51,230 --> 00:09:56,390
used to describe all the components in

00:09:53,090 --> 00:09:57,740
the system to a very exact I mean

00:09:56,390 --> 00:10:00,620
there's a lot of information there for

00:09:57,740 --> 00:10:06,350
every piece of the system and you can go

00:10:00,620 --> 00:10:10,210
very broad and go very specific there's

00:10:06,350 --> 00:10:13,480
also a pack which it's it's a way of

00:10:10,210 --> 00:10:15,740
packaging or pulling all of us together

00:10:13,480 --> 00:10:19,010
zephyr in and of itself only really

00:10:15,740 --> 00:10:22,040
utilizes some the core other people

00:10:19,010 --> 00:10:24,020
utilize some of these other pieces so so

00:10:22,040 --> 00:10:26,120
i'm putting this in here just to kind of

00:10:24,020 --> 00:10:29,090
giving people an idea of what simpsons

00:10:26,120 --> 00:10:30,830
as a whole and give you I'm sure arm can

00:10:29,090 --> 00:10:33,920
probably chime in and give you a little

00:10:30,830 --> 00:10:36,440
bit better description to that and in

00:10:33,920 --> 00:10:38,780
fact it would be good if we had some

00:10:36,440 --> 00:10:41,930
people from arm talk about that or even

00:10:38,780 --> 00:10:44,390
talk about him bed because I know that

00:10:41,930 --> 00:10:46,670
embed uses a JSON for some of the

00:10:44,390 --> 00:10:48,740
configuration but I don't know how it

00:10:46,670 --> 00:10:51,030
all gets pulled together

00:10:48,740 --> 00:10:58,280
so I don't know if anybody wants to talk

00:10:51,030 --> 00:11:02,550
about this okay okay so nothing that

00:10:58,280 --> 00:11:19,050
okay as far as in bed do we have any of

00:11:02,550 --> 00:11:22,340
the embed developers here okay I can use

00:11:19,050 --> 00:11:27,090
the mic so the general concept is that

00:11:22,340 --> 00:11:32,280
there are a set of JSON files that

00:11:27,090 --> 00:11:34,950
define the architectures and they were

00:11:32,280 --> 00:11:37,290
mainly used by the old building system

00:11:34,950 --> 00:11:40,290
iota now with the new building system

00:11:37,290 --> 00:11:42,750
that is called an bad CLI the most of

00:11:40,290 --> 00:11:46,230
the configuration parameter parameter

00:11:42,750 --> 00:11:48,360
have been moved in a centralized JSON

00:11:46,230 --> 00:11:51,390
files that contains all the informations

00:11:48,360 --> 00:11:54,450
once this JSON file is setted up there

00:11:51,390 --> 00:11:57,480
are there is a python api that parses it

00:11:54,450 --> 00:11:59,220
endure produces a master include that

00:11:57,480 --> 00:12:01,950
contains all the configuration

00:11:59,220 --> 00:12:05,490
parameters included by your architecture

00:12:01,950 --> 00:12:09,660
and that help you to compile with the

00:12:05,490 --> 00:12:11,700
definitions for example of how big there

00:12:09,660 --> 00:12:14,820
are more where is the base address

00:12:11,700 --> 00:12:17,490
though these kind of parameters it's as

00:12:14,820 --> 00:12:21,270
simple as that basically it's quite

00:12:17,490 --> 00:12:24,030
similar to what device tree does for

00:12:21,270 --> 00:12:28,410
really looks with the difference device

00:12:24,030 --> 00:12:32,070
they can be can be escalated a bit more

00:12:28,410 --> 00:12:36,930
so they can be in a different set of

00:12:32,070 --> 00:12:38,910
includes and can be more your article in

00:12:36,930 --> 00:12:41,630
that case you have a master file that

00:12:38,910 --> 00:12:41,630
contains everything

00:12:44,660 --> 00:12:54,410
I think Simpsons is more towards the

00:12:52,370 --> 00:12:56,899
device is closer to device and

00:12:54,410 --> 00:12:59,089
description of device in maybe maybe

00:12:56,899 --> 00:13:00,829
even a bare metal systems it kind of

00:12:59,089 --> 00:13:04,610
looks more to us defining your device

00:13:00,829 --> 00:13:06,980
making it modular eyes and everything I

00:13:04,610 --> 00:13:08,990
think embed looks at more kind of our

00:13:06,980 --> 00:13:10,399
site requirements for the configuration

00:13:08,990 --> 00:13:12,730
of that device i think there's slightly

00:13:10,399 --> 00:13:18,949
kind of top top-down or bottom-up

00:13:12,730 --> 00:13:20,870
approach in the two yeah that's that's

00:13:18,949 --> 00:13:24,410
correct embed covers everything

00:13:20,870 --> 00:13:26,959
basically because in the same JSON file

00:13:24,410 --> 00:13:28,550
you have even the features that the

00:13:26,959 --> 00:13:31,670
operating system supports for your

00:13:28,550 --> 00:13:32,990
architecture for example so if Billy is

00:13:31,670 --> 00:13:34,519
one of the features that your

00:13:32,990 --> 00:13:39,100
architecture support you can define it

00:13:34,519 --> 00:13:42,980
in a billy in a JSON file and this

00:13:39,100 --> 00:13:46,730
through there python compliation system

00:13:42,980 --> 00:13:50,630
what it does it goes to bring into your

00:13:46,730 --> 00:13:54,310
final binary the feature really that is

00:13:50,630 --> 00:13:56,360
inside the features folder so it's like

00:13:54,310 --> 00:13:59,420
splitting the system in different

00:13:56,360 --> 00:14:01,610
components and using a master

00:13:59,420 --> 00:14:06,639
configuration file to put them in when

00:14:01,610 --> 00:14:06,639
they are required okay

00:14:12,160 --> 00:14:18,430
yeah and you know some of these ideas

00:14:14,860 --> 00:14:21,399
and I'll readily admit I'm not an IDE

00:14:18,430 --> 00:14:23,379
user so I just like using VI and I knew

00:14:21,399 --> 00:14:26,009
my will make well command-line stuff and

00:14:23,379 --> 00:14:28,389
when people when I see these IDs it

00:14:26,009 --> 00:14:30,399
encompass all this configuration stuff

00:14:28,389 --> 00:14:32,800
for your cooking and fills up the system

00:14:30,399 --> 00:14:34,839
for you it's like uh but but I mean

00:14:32,800 --> 00:14:37,779
these types of systems that allows you

00:14:34,839 --> 00:14:39,430
to have that because the system can be

00:14:37,779 --> 00:14:48,069
built up from all these configuration

00:14:39,430 --> 00:14:52,060
files this master file so the problem

00:14:48,069 --> 00:14:55,629
that you have is that since it allows

00:14:52,060 --> 00:14:57,550
you to manage even packages so ideally

00:14:55,629 --> 00:14:59,529
you could bring packages inside your

00:14:57,550 --> 00:15:03,279
project coming from different git

00:14:59,529 --> 00:15:08,529
repositories this is the advantage so

00:15:03,279 --> 00:15:10,389
you can develop pure and this is

00:15:08,529 --> 00:15:13,240
something that we should think even with

00:15:10,389 --> 00:15:16,509
defer to to do something similar because

00:15:13,240 --> 00:15:19,720
you can easily put your application in a

00:15:16,509 --> 00:15:22,060
git repository lock it against the

00:15:19,720 --> 00:15:25,540
definite version of embed that you

00:15:22,060 --> 00:15:29,620
tested that is working with your project

00:15:25,540 --> 00:15:31,060
and once this is done up to when the

00:15:29,620 --> 00:15:34,660
history of the gate will not be

00:15:31,060 --> 00:15:36,310
rewritten or for some reason the project

00:15:34,660 --> 00:15:37,959
will be fork then that branch not

00:15:36,310 --> 00:15:40,870
maintained anymore your project

00:15:37,959 --> 00:15:43,060
continues to work as it was meant to do

00:15:40,870 --> 00:15:48,069
so this is the main advantage that the

00:15:43,060 --> 00:15:51,189
solution like that does ok there's one

00:15:48,069 --> 00:15:54,160
more thing so like the SVD files from

00:15:51,189 --> 00:15:57,399
Kyle they can be utilized by many tool

00:15:54,160 --> 00:16:00,790
chains for example I ir and Kyle itself

00:15:57,399 --> 00:16:02,230
they can help you debug the system much

00:16:00,790 --> 00:16:04,630
easier because once you've defined the

00:16:02,230 --> 00:16:06,130
system and I believe and I haven't done

00:16:04,630 --> 00:16:08,439
a lot of experiment with that but i

00:16:06,130 --> 00:16:11,170
believe the ids recognize the system

00:16:08,439 --> 00:16:13,329
defined in a certain way and make it

00:16:11,170 --> 00:16:15,189
make easier to debug the system you can

00:16:13,329 --> 00:16:16,420
see the spare the registers are they

00:16:15,189 --> 00:16:18,100
will be defined there you can see

00:16:16,420 --> 00:16:22,209
instead of just an address you will have

00:16:18,100 --> 00:16:24,850
details and we have our discussions

00:16:22,209 --> 00:16:26,680
where people who are more GDB focused

00:16:24,850 --> 00:16:28,329
I'm not bothered about all that but

00:16:26,680 --> 00:16:30,790
there's a lot of people who use IDs

00:16:28,329 --> 00:16:34,630
would prefer to keep using ID for

00:16:30,790 --> 00:16:38,860
debugging buy a jtag connector I think

00:16:34,630 --> 00:16:40,750
Zephyr really needs to see how this a

00:16:38,860 --> 00:16:43,060
long term but I think we need to see how

00:16:40,750 --> 00:16:44,649
the device tree or whatever is defined

00:16:43,060 --> 00:16:47,620
is then recognized in a similar way

00:16:44,649 --> 00:16:50,170
somehow into the ID is so that your for

00:16:47,620 --> 00:16:51,880
example arm system control register when

00:16:50,170 --> 00:16:53,980
you go to the base address issue then

00:16:51,880 --> 00:16:58,920
they just recognize what are the

00:16:53,980 --> 00:16:58,920
registers you're looking at right thanks

00:16:59,880 --> 00:17:05,829
because it's been talked about that's

00:17:03,730 --> 00:17:09,280
linked to do I de use it but basically

00:17:05,829 --> 00:17:12,069
that's a description file for one of the

00:17:09,280 --> 00:17:14,559
main uses for peripheral registers so

00:17:12,069 --> 00:17:16,630
that's going to be used for debug could

00:17:14,559 --> 00:17:18,809
be used at runtime as well and it's a

00:17:16,630 --> 00:17:24,789
description of peripheral registers that

00:17:18,809 --> 00:17:28,209
the SOC s we Wed beyond the basic core

00:17:24,789 --> 00:17:31,630
registers so any user can actually make

00:17:28,209 --> 00:17:32,980
use of that information right and you

00:17:31,630 --> 00:17:34,390
actually see that ins effort to some

00:17:32,980 --> 00:17:36,909
extent some of the files that are in the

00:17:34,390 --> 00:17:39,760
XP XD howl directory that come from the

00:17:36,909 --> 00:17:42,669
vendor's a lot of them are generated

00:17:39,760 --> 00:17:48,520
from look I can see the SPD stuff in

00:17:42,669 --> 00:17:49,990
there so yeah one I guess hardest

00:17:48,520 --> 00:17:55,960
insists that I failed to mention was the

00:17:49,990 --> 00:17:59,100
DAP so there is a debug component

00:17:55,960 --> 00:18:02,770
I need to add that to the list I think

00:17:59,100 --> 00:18:04,780
so so the question is what can device

00:18:02,770 --> 00:18:06,520
tree do for Zephyr I mean what does it

00:18:04,780 --> 00:18:11,170
bring what would it bring to to Zephyr

00:18:06,520 --> 00:18:12,690
so in my description of how the system

00:18:11,170 --> 00:18:16,060
works and how boards are configured

00:18:12,690 --> 00:18:20,110
there's some problems that exist in the

00:18:16,060 --> 00:18:22,090
system today one is how how can you

00:18:20,110 --> 00:18:25,360
easily define any board or a variation

00:18:22,090 --> 00:18:28,510
of an existing board to how do you deal

00:18:25,360 --> 00:18:30,010
with multiple device declarations and

00:18:28,510 --> 00:18:33,730
there's there's a few other problems as

00:18:30,010 --> 00:18:38,020
well so the Vice Cree is very good at

00:18:33,730 --> 00:18:41,310
being able to specify our describe

00:18:38,020 --> 00:18:43,120
devices in and even deal with multiples

00:18:41,310 --> 00:18:45,760
the other thing is it's very

00:18:43,120 --> 00:18:49,480
architectural architectural II neutral I

00:18:45,760 --> 00:18:53,830
mean device trees used in PowerPC it's

00:18:49,480 --> 00:18:57,220
used in arm pretty much most people can

00:18:53,830 --> 00:18:59,020
use it because the description language

00:18:57,220 --> 00:19:04,450
is such that you can describe almost

00:18:59,020 --> 00:19:06,040
anything the other thing is is that with

00:19:04,450 --> 00:19:08,380
all these k config options if you look

00:19:06,040 --> 00:19:10,630
at the Linux kernel typically you have a

00:19:08,380 --> 00:19:12,820
def config file you do your make

00:19:10,630 --> 00:19:18,070
defconfig you may do a menu config to

00:19:12,820 --> 00:19:19,330
change sometimes but in general the

00:19:18,070 --> 00:19:21,910
build options are generated from the

00:19:19,330 --> 00:19:23,650
defconfig in our case I think because we

00:19:21,910 --> 00:19:26,800
have the cake picks stretched out on

00:19:23,650 --> 00:19:29,110
everywhere if we can leverage the device

00:19:26,800 --> 00:19:31,390
tree file to to use that to define what

00:19:29,110 --> 00:19:34,090
or to derive what our take config

00:19:31,390 --> 00:19:36,070
options are a lot of these files that

00:19:34,090 --> 00:19:38,190
are kind of strewn about the system can

00:19:36,070 --> 00:19:41,050
actually be removed or pared down some

00:19:38,190 --> 00:19:43,540
and it makes sense because if you have a

00:19:41,050 --> 00:19:45,250
board description that says hey I've got

00:19:43,540 --> 00:19:47,980
a UART I've got spy I've got I squirt

00:19:45,250 --> 00:19:50,320
see you naturally want to one enable

00:19:47,980 --> 00:19:51,760
those device drivers to be built but you

00:19:50,320 --> 00:19:53,900
don't want to include let's say a can

00:19:51,760 --> 00:19:55,910
bus driver is it's not actually being

00:19:53,900 --> 00:20:00,010
so you can actually pare down the system

00:19:55,910 --> 00:20:04,070
image and we can actually do that if we

00:20:00,010 --> 00:20:06,440
generate that from from the dt and in

00:20:04,070 --> 00:20:08,090
fact in the linux kernel they have a

00:20:06,440 --> 00:20:10,790
tool that they've added recently called

00:20:08,090 --> 00:20:13,430
a dt to config i think is the name of it

00:20:10,790 --> 00:20:14,870
but you can actually run it on device

00:20:13,430 --> 00:20:17,420
tree files and it goes through the

00:20:14,870 --> 00:20:19,940
system and figures out ok based off

00:20:17,420 --> 00:20:22,130
compatible what drivers are out there

00:20:19,940 --> 00:20:23,750
which ones need to be turned on and

00:20:22,130 --> 00:20:26,000
it'll actually look at the Deaf config

00:20:23,750 --> 00:20:28,640
file the party decided to use and it'll

00:20:26,000 --> 00:20:29,810
tell you ok yeah you have these on but

00:20:28,640 --> 00:20:32,030
you also need to turn these other ones

00:20:29,810 --> 00:20:34,190
are so Lennox has already kind of

00:20:32,030 --> 00:20:35,480
thought about this in our case it'd be

00:20:34,190 --> 00:20:36,620
very simplified it wouldn't be like

00:20:35,480 --> 00:20:39,080
Linux where we have to go through the

00:20:36,620 --> 00:20:41,440
whole system and do compatible matches I

00:20:39,080 --> 00:20:43,340
think we can do it in an easier fashion

00:20:41,440 --> 00:20:48,200
well we can get to that a little bit

00:20:43,340 --> 00:20:52,070
later as I mentioned earlier device tree

00:20:48,200 --> 00:20:54,590
is very flexible a lot of these arm

00:20:52,070 --> 00:20:57,260
boards are very similar if you if you

00:20:54,590 --> 00:21:00,650
look at the device manuals for these and

00:20:57,260 --> 00:21:02,870
go down I mean everybody has a you know

00:21:00,650 --> 00:21:05,510
clock controller of some sort they have

00:21:02,870 --> 00:21:08,210
a pin MUX controller of some sort they

00:21:05,510 --> 00:21:12,200
have gpio ports they may have some

00:21:08,210 --> 00:21:14,870
slightly different blocks where they're

00:21:12,200 --> 00:21:18,170
dealing with clock gating or things of

00:21:14,870 --> 00:21:19,700
that nature but but in general while

00:21:18,170 --> 00:21:22,580
they may have different names they all

00:21:19,700 --> 00:21:24,770
have the same function so in device tree

00:21:22,580 --> 00:21:25,910
I mean when you're dealing with certain

00:21:24,770 --> 00:21:27,080
types of things like a hierarchy

00:21:25,910 --> 00:21:30,530
controller which in our case would be

00:21:27,080 --> 00:21:33,140
the in vic or a UART I mean a you are

00:21:30,530 --> 00:21:36,370
too you are so it's very easy to kind of

00:21:33,140 --> 00:21:36,370
classify some of these devices

00:21:38,810 --> 00:21:47,010
so one question we have is whether or

00:21:45,000 --> 00:21:48,870
not we can kind of leverage the device

00:21:47,010 --> 00:21:55,440
tree information for the upper layers of

00:21:48,870 --> 00:21:58,650
software the easy thing is device

00:21:55,440 --> 00:22:00,300
drivers merging our mating the device

00:21:58,650 --> 00:22:02,370
drivers with device configuration

00:22:00,300 --> 00:22:03,450
information that's the easy part but one

00:22:02,370 --> 00:22:06,990
thing we need to think about a little

00:22:03,450 --> 00:22:10,680
bit is how does like a Jerry script or

00:22:06,990 --> 00:22:13,560
one of these applications figure out or

00:22:10,680 --> 00:22:16,800
you know what what facilities are in in

00:22:13,560 --> 00:22:18,540
the system but I think we can probably

00:22:16,800 --> 00:22:21,210
leverage device tree to do that to some

00:22:18,540 --> 00:22:22,680
extent but the only question is is if if

00:22:21,210 --> 00:22:25,740
we are not going to carry carry around

00:22:22,680 --> 00:22:27,780
the memory footprint of the device tree

00:22:25,740 --> 00:22:28,980
information will have to think about

00:22:27,780 --> 00:22:31,110
that i'm not sure if that's going to be

00:22:28,980 --> 00:22:33,180
an easy thing to do or not in the linux

00:22:31,110 --> 00:22:35,490
kernel they keep it around it's in

00:22:33,180 --> 00:22:38,250
memory its resident you can get at it

00:22:35,490 --> 00:22:40,740
you can display it in our case that

00:22:38,250 --> 00:22:43,940
might cost a little bit too much so we

00:22:40,740 --> 00:22:43,940
made should not choose to do that

00:23:26,400 --> 00:23:34,000
okay so yeah we should be able to do

00:23:30,570 --> 00:23:35,530
both basically for the extreme cases

00:23:34,000 --> 00:23:37,120
where you need to fit in a certain

00:23:35,530 --> 00:23:39,010
amount of memory you need to trim it

00:23:37,120 --> 00:23:40,930
down to two to the minimum and you need

00:23:39,010 --> 00:23:43,210
basically to turn off everything that

00:23:40,930 --> 00:23:45,820
you are not using if you are building a

00:23:43,210 --> 00:23:49,030
dedicated device for example that just

00:23:45,820 --> 00:23:50,620
you know drives one sensor and does

00:23:49,030 --> 00:23:52,210
certain things you really don't care

00:23:50,620 --> 00:23:55,620
about anything else that comes on the

00:23:52,210 --> 00:23:57,340
SOC or all the board in in development

00:23:55,620 --> 00:23:59,440
stage or when you are developing

00:23:57,340 --> 00:24:01,930
something or we win when you want to

00:23:59,440 --> 00:24:05,980
provide users something like our do we

00:24:01,930 --> 00:24:07,600
know for example and where people don't

00:24:05,980 --> 00:24:09,880
want to go through all of this process

00:24:07,600 --> 00:24:12,220
and know about the system probably and

00:24:09,880 --> 00:24:14,890
if you have enough memory you probably

00:24:12,220 --> 00:24:18,310
want to provide the whole tree we still

00:24:14,890 --> 00:24:20,830
need to see what is the penalty of like

00:24:18,310 --> 00:24:22,840
compiling everything n and what what

00:24:20,830 --> 00:24:24,910
what it means this is yet to be seen I

00:24:22,840 --> 00:24:27,250
don't if you have any numbers there but

00:24:24,910 --> 00:24:29,920
once once we take a look at that and I

00:24:27,250 --> 00:24:31,660
mean a lot of that development boards

00:24:29,920 --> 00:24:35,260
out there today they have enough from

00:24:31,660 --> 00:24:36,880
its to give you some flexibility but we

00:24:35,260 --> 00:24:40,000
really need to be able to turn it down

00:24:36,880 --> 00:24:42,130
to the lowest numbers possible because

00:24:40,000 --> 00:24:46,600
we still want to be able to run in 8k

00:24:42,130 --> 00:24:51,760
are armed and in very small systems okay

00:24:46,600 --> 00:24:54,640
right so we already kind of touched on

00:24:51,760 --> 00:24:56,800
some of these things but so my thoughts

00:24:54,640 --> 00:24:59,800
are we only really need to use some

00:24:56,800 --> 00:25:01,480
hearts in the device tree clearly we

00:24:59,800 --> 00:25:03,400
want to be able to describe the system

00:25:01,480 --> 00:25:05,650
configuration but I don't think

00:25:03,400 --> 00:25:08,680
necessarily we care about the flattened

00:25:05,650 --> 00:25:10,450
device tree blob so subtle for people

00:25:08,680 --> 00:25:14,440
who aren't familiar with the device tree

00:25:10,450 --> 00:25:16,900
you start with a textual description of

00:25:14,440 --> 00:25:19,650
system and then you run it through the

00:25:16,900 --> 00:25:23,020
compiler which is the dtc compiler and

00:25:19,650 --> 00:25:25,000
usually people process that and create a

00:25:23,020 --> 00:25:25,420
dtb file which is a flattened device

00:25:25,000 --> 00:25:29,530
tree

00:25:25,420 --> 00:25:31,600
it's basically a binary image with some

00:25:29,530 --> 00:25:34,810
header information and you can step you

00:25:31,600 --> 00:25:37,900
can actually step through the thing with

00:25:34,810 --> 00:25:39,040
with some utilities in our case because

00:25:37,900 --> 00:25:43,270
we're not going to really keep that

00:25:39,040 --> 00:25:45,280
information around in memory my thoughts

00:25:43,270 --> 00:25:47,920
was that we would just use DTS and a

00:25:45,280 --> 00:25:51,250
kind of a past three manner meaning that

00:25:47,920 --> 00:25:53,170
we have a text rule file we may we run

00:25:51,250 --> 00:25:54,990
it through the compiler to do some

00:25:53,170 --> 00:25:59,230
things like pre-processing and

00:25:54,990 --> 00:26:00,790
validation of the of the file and then

00:25:59,230 --> 00:26:03,580
we get an output that contains the

00:26:00,790 --> 00:26:05,440
information we want and we actually use

00:26:03,580 --> 00:26:07,690
the textual representation of the file

00:26:05,440 --> 00:26:11,050
to generate other things that we want to

00:26:07,690 --> 00:26:14,170
use and we'll get to that in a minute

00:26:11,050 --> 00:26:15,730
but the other thing is is we can also

00:26:14,170 --> 00:26:20,230
use that file to generate the cake and

00:26:15,730 --> 00:26:22,720
big options runtime access to to the

00:26:20,230 --> 00:26:24,010
blob is not something that I was

00:26:22,720 --> 00:26:27,420
thinking that we would be interested in

00:26:24,010 --> 00:26:30,730
basically because of the cost and memory

00:26:27,420 --> 00:26:31,960
these are small boards though so i would

00:26:30,730 --> 00:26:34,120
have to kind of take a look at what the

00:26:31,960 --> 00:26:36,130
image size would be and how we how we

00:26:34,120 --> 00:26:38,110
would keep it around and and with any

00:26:36,130 --> 00:26:39,910
would cost us actually flash because we

00:26:38,110 --> 00:26:41,620
wouldn't be booting or loading it into

00:26:39,910 --> 00:26:45,430
the RAM like like what's being done in

00:26:41,620 --> 00:26:48,130
lenox so I haven't done numbers on that

00:26:45,430 --> 00:26:49,690
and like I said these these descriptions

00:26:48,130 --> 00:26:51,250
for these boards are fairly small this

00:26:49,690 --> 00:26:54,820
isn't like a mobile processor where

00:26:51,250 --> 00:26:58,350
you've cut just a ton of devices these

00:26:54,820 --> 00:26:58,350
are relatively small

00:27:01,320 --> 00:27:07,419
what would you need it for on these

00:27:04,299 --> 00:27:09,429
small devices to keep it a memory it's

00:27:07,419 --> 00:27:11,529
part of these things where you know how

00:27:09,429 --> 00:27:14,169
does the application know what you have

00:27:11,529 --> 00:27:17,080
if there's a way of going through with

00:27:14,169 --> 00:27:18,490
you if I only use it for configuration I

00:27:17,080 --> 00:27:19,929
would pull out the pieces i need the

00:27:18,490 --> 00:27:22,029
board would give you configuring and we

00:27:19,929 --> 00:27:24,399
just run which right now is being done

00:27:22,029 --> 00:27:26,230
in a hard Club manner but if somebody

00:27:24,399 --> 00:27:28,419
wanted to figure out okay well what what

00:27:26,230 --> 00:27:30,549
kind of things can I do with this board

00:27:28,419 --> 00:27:32,230
what's turned on what kind of

00:27:30,549 --> 00:27:33,460
applications can I do it let's say they

00:27:32,230 --> 00:27:35,169
have an application that can do a bunch

00:27:33,460 --> 00:27:36,820
of different things but it looks at the

00:27:35,169 --> 00:27:38,649
board and says oh I can only do I

00:27:36,820 --> 00:27:41,950
squared C and I can only do you argh

00:27:38,649 --> 00:27:44,020
well okay how does it know that well it

00:27:41,950 --> 00:27:46,480
only knows it because you've compiled

00:27:44,020 --> 00:27:48,029
that specifically to run that way this

00:27:46,480 --> 00:27:50,620
would be used to kind of figure out

00:27:48,029 --> 00:27:52,779
dynamically what can I do it's a

00:27:50,620 --> 00:27:56,679
reconfigurable and a bit shy ? the

00:27:52,779 --> 00:27:58,299
application not aesthetically configure

00:27:56,679 --> 00:28:00,370
that itself example if you've got

00:27:58,299 --> 00:28:02,649
micropolitan there's no point in

00:28:00,370 --> 00:28:05,020
comparing ITC multi like you see right

00:28:02,649 --> 00:28:06,279
still wants to be standard right I mean

00:28:05,020 --> 00:28:07,630
you just gives you more freedom now

00:28:06,279 --> 00:28:10,419
whether or not you really want to pay

00:28:07,630 --> 00:28:14,940
that cost that's the question so I'll

00:28:10,419 --> 00:28:19,409
throw out a couple ideas first is

00:28:14,940 --> 00:28:21,340
looking at using function sections so

00:28:19,409 --> 00:28:24,640
because then you could compile

00:28:21,340 --> 00:28:29,140
everything and whatever gets used based

00:28:24,640 --> 00:28:33,309
on your device reconfiguration get store

00:28:29,140 --> 00:28:35,860
doesn't get use gets dropped and you

00:28:33,309 --> 00:28:37,750
probably have that would probably work

00:28:35,860 --> 00:28:44,140
better and Zephyr than the linux kernel

00:28:37,750 --> 00:28:46,529
because it's all 1 image just large

00:28:44,140 --> 00:28:46,529
extent

00:28:46,700 --> 00:28:54,740
second is I don't think I would make

00:28:49,289 --> 00:28:54,740
device tree generate the config I would

00:28:55,129 --> 00:29:03,330
generate some of the code itself from

00:28:58,440 --> 00:29:04,620
the device tree so so to use linux as an

00:29:03,330 --> 00:29:09,629
example because i know nothing about

00:29:04,620 --> 00:29:11,220
zephyr you know we dynamically we parse

00:29:09,629 --> 00:29:13,559
the device tree on boot and create

00:29:11,220 --> 00:29:16,769
platform devices you could just as

00:29:13,559 --> 00:29:19,980
easily parse the device tree calculate

00:29:16,769 --> 00:29:22,139
memory addresses interrupts and generate

00:29:19,980 --> 00:29:25,909
code that calls platform device create

00:29:22,139 --> 00:29:29,369
and you could do something like that

00:29:25,909 --> 00:29:32,549
then f is if zephyr is more like create

00:29:29,369 --> 00:29:34,320
I to see device if you have none of

00:29:32,549 --> 00:29:39,269
those than all the i2c code would drop

00:29:34,320 --> 00:29:40,830
out with friction sections right and the

00:29:39,269 --> 00:29:42,990
way jumper does that is they have a like

00:29:40,830 --> 00:29:45,480
a device API and in it call i think is

00:29:42,990 --> 00:29:47,940
what it is and they kind of overload

00:29:45,480 --> 00:29:50,909
some of the parameters being passed in

00:29:47,940 --> 00:29:53,159
to say okay well this is a you are this

00:29:50,909 --> 00:29:55,679
is I squared C this is five so they

00:29:53,159 --> 00:29:57,299
reinterpret that parameter coming in as

00:29:55,679 --> 00:30:01,200
give them their configuration

00:29:57,299 --> 00:30:03,210
information so i think the thinking

00:30:01,200 --> 00:30:06,779
would be that the k config would just be

00:30:03,210 --> 00:30:08,279
for picking drivers holy not at four so

00:30:06,779 --> 00:30:09,720
we'd still do i think what you're

00:30:08,279 --> 00:30:11,850
suggesting which is generate the code

00:30:09,720 --> 00:30:13,320
for the actual knowing i've got three

00:30:11,850 --> 00:30:14,759
you are it's there at this address they

00:30:13,320 --> 00:30:16,679
have this interrupt that would all be

00:30:14,759 --> 00:30:19,200
generated code like kind of in that same

00:30:16,679 --> 00:30:21,450
sense but maybe there's another tool

00:30:19,200 --> 00:30:24,869
that knows by scanning the tree i need

00:30:21,450 --> 00:30:28,019
the kinetis you our driver to be pulled

00:30:24,869 --> 00:30:30,210
in or I don't need it because I'm not

00:30:28,019 --> 00:30:31,830
using your tat all or whatever just for

00:30:30,210 --> 00:30:33,600
that at that level but definitely I

00:30:31,830 --> 00:30:36,360
think all of the other property

00:30:33,600 --> 00:30:39,269
information and creating whatever device

00:30:36,360 --> 00:30:41,700
nodes inside the systems for how its

00:30:39,269 --> 00:30:43,769
seen would be done kind of as a code

00:30:41,700 --> 00:30:45,990
generator as opposed to K config and

00:30:43,769 --> 00:30:48,240
stripping out I think the intent would

00:30:45,990 --> 00:30:51,179
be from I think our conversations is to

00:30:48,240 --> 00:30:54,059
kind of actually remove from Zephyr all

00:30:51,179 --> 00:30:55,649
of that k config information that's

00:30:54,059 --> 00:30:58,379
there that is describing device

00:30:55,649 --> 00:30:59,620
properties just because of its just not

00:30:58,379 --> 00:31:02,380
scalable as we

00:30:59,620 --> 00:31:03,850
about where you know yeah you go think

00:31:02,380 --> 00:31:05,260
maybe I have for you arts and now

00:31:03,850 --> 00:31:07,510
tomorrow someone comes out with that

00:31:05,260 --> 00:31:10,059
system that's got 20 right it's just it

00:31:07,510 --> 00:31:12,309
you know just doesn't really work well I

00:31:10,059 --> 00:31:16,450
think the other thing just to frame a

00:31:12,309 --> 00:31:17,770
bit of a conversation is not while what

00:31:16,450 --> 00:31:21,070
we're looking at is kind of using

00:31:17,770 --> 00:31:22,480
Zephyrs a platform to do this work and

00:31:21,070 --> 00:31:25,900
obviously address some of the issues in

00:31:22,480 --> 00:31:29,800
zephyr the DT and looking at this is

00:31:25,900 --> 00:31:32,170
meant to be I'll say agnostic both from

00:31:29,800 --> 00:31:36,910
an architecture point of view so much

00:31:32,170 --> 00:31:44,110
like Linux has DT on powerpc MIPS arm I

00:31:36,910 --> 00:31:46,059
guess I x86 yes ok but it clearly

00:31:44,110 --> 00:31:48,970
supports multiple architectures that

00:31:46,059 --> 00:31:51,160
that would also be true for the work

00:31:48,970 --> 00:31:52,600
we'd be doing that there's no reason

00:31:51,160 --> 00:31:54,580
this wouldn't be able to be supported on

00:31:52,600 --> 00:31:57,640
other architectures so that's one reason

00:31:54,580 --> 00:32:00,160
to kind of look at the dt as well as

00:31:57,640 --> 00:32:01,840
then having kind of the tooling and

00:32:00,160 --> 00:32:05,800
infrastructure there that could be used

00:32:01,840 --> 00:32:07,570
by other artists as well so it's not you

00:32:05,800 --> 00:32:10,240
know that the description and so forth

00:32:07,570 --> 00:32:12,880
is meant to be neutral in that respect

00:32:10,240 --> 00:32:14,470
to be able to be utilized by you know

00:32:12,880 --> 00:32:15,910
whether it's application frameworks and

00:32:14,470 --> 00:32:18,970
how we drive the information there that

00:32:15,910 --> 00:32:21,340
it needs it there or other artists is

00:32:18,970 --> 00:32:25,300
picking it up we're just using Zephyr as

00:32:21,340 --> 00:32:28,200
a way to prove out as well as improve

00:32:25,300 --> 00:32:28,200
Zephyr so

00:32:31,160 --> 00:32:37,070
so I'm just picking from the MCU side so

00:32:35,360 --> 00:32:38,870
from the MC you and I are you talking

00:32:37,070 --> 00:32:41,090
about just like you wanna include a

00:32:38,870 --> 00:32:45,260
certain driver into your configuration

00:32:41,090 --> 00:32:46,580
on that but usually I mean now the user

00:32:45,260 --> 00:32:48,770
knows you could zactly which ones i'm

00:32:46,580 --> 00:32:51,770
going to use and you mean you pour more

00:32:48,770 --> 00:32:54,020
sense into your source code and you know

00:32:51,770 --> 00:32:55,550
in the end your compiler or build

00:32:54,020 --> 00:32:58,130
process is going to strip out the code

00:32:55,550 --> 00:33:00,230
you never used so so so for that

00:32:58,130 --> 00:33:02,540
perspective I mean we're doing here you

00:33:00,230 --> 00:33:04,160
pull in more code or not but in the end

00:33:02,540 --> 00:33:06,680
and I here if you are not using it you

00:33:04,160 --> 00:33:08,390
are not going to get it I mean so just

00:33:06,680 --> 00:33:10,420
once in the other sins is like you know

00:33:08,390 --> 00:33:13,370
even from the device configuration side

00:33:10,420 --> 00:33:15,290
I think you know pretty much or just

00:33:13,370 --> 00:33:19,370
semi come same conduct companies are

00:33:15,290 --> 00:33:22,220
using the simplest kind of like the same

00:33:19,370 --> 00:33:24,980
score you know I mean it needs to have

00:33:22,220 --> 00:33:27,560
whatever device head files to describe

00:33:24,980 --> 00:33:29,390
the device so every single information

00:33:27,560 --> 00:33:32,210
regarding the device is already in the

00:33:29,390 --> 00:33:34,610
device head files is already in provided

00:33:32,210 --> 00:33:37,190
by semiconductor company so I do not

00:33:34,610 --> 00:33:39,950
know why we want to apply another layer

00:33:37,190 --> 00:33:44,870
on top of the sins that is already

00:33:39,950 --> 00:33:47,360
working very well and and to me is

00:33:44,870 --> 00:33:50,420
overhead right and the other sins nag

00:33:47,360 --> 00:33:53,120
you know MSU is very much human resource

00:33:50,420 --> 00:33:56,060
limited if we're talking about add you

00:33:53,120 --> 00:33:58,760
know one more bite into the system just

00:33:56,060 --> 00:34:01,280
not good at all I mean when we design of

00:33:58,760 --> 00:34:03,680
software to enable the MCO devices we

00:34:01,280 --> 00:34:06,410
talking to the by the network right I

00:34:03,680 --> 00:34:08,210
mean sometimes we even just don't want

00:34:06,410 --> 00:34:10,550
to add the point into the system because

00:34:08,210 --> 00:34:13,520
he's going to add for Barrett over it to

00:34:10,550 --> 00:34:16,480
the system so just something need to put

00:34:13,520 --> 00:34:16,480
into the consideration

00:34:22,500 --> 00:34:28,480
yeah and looking through the through the

00:34:25,960 --> 00:34:31,179
Zephyr the EXP hilarious I mean I see

00:34:28,480 --> 00:34:35,770
where that's true I mean for a lot of

00:34:31,179 --> 00:34:38,349
some systems The Simpsons that the

00:34:35,770 --> 00:34:40,450
vendors doing its describes a lot of the

00:34:38,349 --> 00:34:45,220
system but we still have some of the

00:34:40,450 --> 00:34:48,250
core problems of you know multiples of

00:34:45,220 --> 00:34:49,690
devices things of that nature I think

00:34:48,250 --> 00:34:50,919
with what we want to be able to generate

00:34:49,690 --> 00:34:54,280
out of this we don't want to necessarily

00:34:50,919 --> 00:34:56,230
add any any size of flash if we can get

00:34:54,280 --> 00:34:59,470
away with it what we really want to do

00:34:56,230 --> 00:35:02,530
is because i will give reductions from

00:34:59,470 --> 00:35:04,150
removing all of these blobs or blocks of

00:35:02,530 --> 00:35:06,309
code that are out there to deal with all

00:35:04,150 --> 00:35:10,329
these dealing with multiples and the

00:35:06,309 --> 00:35:12,369
drivers will have to add back maybe a

00:35:10,329 --> 00:35:14,440
very small portion and i completely

00:35:12,369 --> 00:35:17,050
agree with your statement about you know

00:35:14,440 --> 00:35:20,109
even you know a bite or four bites or

00:35:17,050 --> 00:35:21,250
eight bytes it matters because a little

00:35:20,109 --> 00:35:26,099
bit here and a little bit there it adds

00:35:21,250 --> 00:35:26,099
up yeah so no no we're sensitive to that

00:35:27,030 --> 00:35:32,140
device configuration you deserve his is

00:35:30,130 --> 00:35:34,270
kim from the device head files neck

00:35:32,140 --> 00:35:36,730
talking about the base address i talking

00:35:34,270 --> 00:35:38,559
about it you know the registering he's

00:35:36,730 --> 00:35:41,109
already been provided in that device

00:35:38,559 --> 00:35:43,240
head file so so for each device or for

00:35:41,109 --> 00:35:45,640
each device serious the vop ahead file

00:35:43,240 --> 00:35:48,690
came from the semiconductor company that

00:35:45,640 --> 00:35:51,970
is pretty much compound to jessence neck

00:35:48,690 --> 00:35:54,700
to the arms in to score a kind of

00:35:51,970 --> 00:35:57,099
specification so so why not just use

00:35:54,700 --> 00:36:02,109
that information there because everybody

00:35:57,099 --> 00:36:04,569
have a center standard unit well this

00:36:02,109 --> 00:36:07,210
this probably applies to systems that

00:36:04,569 --> 00:36:09,160
use census but they're far is not since

00:36:07,210 --> 00:36:12,069
it's only so we need I mean this is like

00:36:09,160 --> 00:36:14,829
different architectures doing things in

00:36:12,069 --> 00:36:16,750
a different way so we can't assume that

00:36:14,829 --> 00:36:19,809
everybody has the information in the

00:36:16,750 --> 00:36:21,220
same way and there has to be there has

00:36:19,809 --> 00:36:23,410
to be something in the middle likely to

00:36:21,220 --> 00:36:26,829
obstruct this type of thing but even

00:36:23,410 --> 00:36:28,180
even on the cortex side I mean you will

00:36:26,829 --> 00:36:31,040
have you will have different

00:36:28,180 --> 00:36:34,290
implementation of

00:36:31,040 --> 00:36:36,840
having since its core there that that's

00:36:34,290 --> 00:36:40,610
all great but when you go on that so sea

00:36:36,840 --> 00:36:40,610
level and and and the board level

00:36:40,700 --> 00:36:48,600
information usually is provided in

00:36:43,200 --> 00:36:50,040
different ways so and yeah I mean I

00:36:48,600 --> 00:36:53,160
think they kind of extend honor said

00:36:50,040 --> 00:36:55,020
it's not just because of things like

00:36:53,160 --> 00:36:57,870
Zephyr that have other architectures

00:36:55,020 --> 00:37:00,030
it's also other software environments

00:36:57,870 --> 00:37:02,610
that aren't can't be or shouldn't be

00:37:00,030 --> 00:37:05,310
only Simpsons aware so exactly we'll

00:37:02,610 --> 00:37:07,890
take the example again of a javascript

00:37:05,310 --> 00:37:10,440
jerry script engine right that engine is

00:37:07,890 --> 00:37:12,450
not armed specific there's nothing you

00:37:10,440 --> 00:37:14,550
know that should be supported on any

00:37:12,450 --> 00:37:18,030
architecture that wants it so having a

00:37:14,550 --> 00:37:20,310
solution that's only arm focused is

00:37:18,030 --> 00:37:22,740
really not portable across those

00:37:20,310 --> 00:37:24,540
environments additionally i think we can

00:37:22,740 --> 00:37:26,940
you know the thought is that we can take

00:37:24,540 --> 00:37:29,280
what is there in the symphysis type of

00:37:26,940 --> 00:37:34,620
definitions and have tools to convert

00:37:29,280 --> 00:37:36,600
from that to a dt mechanism or use those

00:37:34,620 --> 00:37:38,670
includes as part of the dt or other

00:37:36,600 --> 00:37:40,500
things so that the information that is

00:37:38,670 --> 00:37:43,770
provided by the semiconductor companies

00:37:40,500 --> 00:37:46,530
that way is not wasted or lost or not

00:37:43,770 --> 00:37:49,050
you know so it's not a whole new effort

00:37:46,530 --> 00:37:51,810
and on top of what they're doing today

00:37:49,050 --> 00:37:52,980
and presumably there's probably toolings

00:37:51,810 --> 00:37:54,720
and other things that are going on

00:37:52,980 --> 00:37:56,730
inside of those semiconductors for them

00:37:54,720 --> 00:37:59,330
to generate that code anyways from

00:37:56,730 --> 00:38:02,640
internal design databases and so forth

00:37:59,330 --> 00:38:04,950
and then kind of finally I think also

00:38:02,640 --> 00:38:06,990
there's a difference between I think

00:38:04,950 --> 00:38:09,450
what's in those descriptions because

00:38:06,990 --> 00:38:12,780
they describe what the chip is possible

00:38:09,450 --> 00:38:15,840
what capable of not how its configured

00:38:12,780 --> 00:38:18,990
as well so that's an additional piece on

00:38:15,840 --> 00:38:21,510
top that this provides is a means to

00:38:18,990 --> 00:38:23,910
provide that how the chip is being

00:38:21,510 --> 00:38:25,950
configured and utilized on a board

00:38:23,910 --> 00:38:27,900
specifically that those headers don't

00:38:25,950 --> 00:38:29,850
address because they don't know how your

00:38:27,900 --> 00:38:31,650
customer as good as you know what their

00:38:29,850 --> 00:38:34,470
boards doing what interfaces they've set

00:38:31,650 --> 00:38:36,150
up and then how you we propagate that to

00:38:34,470 --> 00:38:37,860
other pieces of software in the system

00:38:36,150 --> 00:38:40,260
as well and doing that in a consistent

00:38:37,860 --> 00:38:42,120
manner is kind of what we're trying to

00:38:40,260 --> 00:38:43,770
why we're looking at addressing this

00:38:42,120 --> 00:38:44,069
above and beyond what some of these

00:38:43,770 --> 00:38:50,489
other

00:38:44,069 --> 00:38:52,259
things have worked out yeah just first

00:38:50,489 --> 00:38:54,900
of all we are talking like it is this

00:38:52,259 --> 00:38:56,400
conference I saw this court exam based

00:38:54,900 --> 00:38:59,369
right we're talking about the solution

00:38:56,400 --> 00:39:01,049
on the toxin the Codex am so so simplest

00:38:59,369 --> 00:39:04,680
is going to be a big part of it and it's

00:39:01,049 --> 00:39:06,299
Addison's is I mean like I mean the

00:39:04,680 --> 00:39:08,839
customers you know who using the

00:39:06,299 --> 00:39:11,969
cortex-m devices are pretty much used to

00:39:08,839 --> 00:39:14,190
what the sims is standard right so so

00:39:11,969 --> 00:39:16,609
even with all we do this solution we pry

00:39:14,190 --> 00:39:20,309
some sins on top of that we cannot

00:39:16,609 --> 00:39:22,769
derive or change the user experience on

00:39:20,309 --> 00:39:24,869
the sensor already familiar ways so

00:39:22,769 --> 00:39:27,089
those just device head files the way how

00:39:24,869 --> 00:39:29,729
to access register substance has to be

00:39:27,089 --> 00:39:32,339
exactly the same we cannot change that

00:39:29,729 --> 00:39:35,400
user experience that is really been that

00:39:32,339 --> 00:39:36,690
is already working and I understand via

00:39:35,400 --> 00:39:38,130
support near knotts all other

00:39:36,690 --> 00:39:41,130
architectures since we will be different

00:39:38,130 --> 00:39:44,400
but the fundamental stuff on on how to

00:39:41,130 --> 00:39:46,109
represent in so the register for each IP

00:39:44,400 --> 00:39:48,509
block I mean those sins is going to be

00:39:46,109 --> 00:39:50,069
very similar I mean the sims of course

00:39:48,509 --> 00:39:53,640
standard is really I mean it's really

00:39:50,069 --> 00:39:55,529
not a standard it's just a way of define

00:39:53,640 --> 00:39:57,869
the way you know how register things

00:39:55,529 --> 00:39:59,190
being done you know how to access the

00:39:57,869 --> 00:40:05,489
registers and that's pretty much about

00:39:59,190 --> 00:40:08,039
it yeah I think I agree that you know

00:40:05,489 --> 00:40:09,809
that those headers are those are the

00:40:08,039 --> 00:40:12,749
bare metal descriptions of what we're

00:40:09,809 --> 00:40:14,849
talking about the same time now we're

00:40:12,749 --> 00:40:16,849
adding software drivers on top of those

00:40:14,849 --> 00:40:20,400
and how do we configure those to match

00:40:16,849 --> 00:40:22,380
to those those header files and so we're

00:40:20,400 --> 00:40:23,819
not out we're not duplicating or

00:40:22,380 --> 00:40:25,739
replacing the simpsons header files

00:40:23,819 --> 00:40:27,749
we're building software on top of those

00:40:25,739 --> 00:40:30,329
in a standard wait how do you configure

00:40:27,749 --> 00:40:33,029
those how do you attach instances of a

00:40:30,329 --> 00:40:34,709
base peripheral address to the driver

00:40:33,029 --> 00:40:36,509
make sure those are correct make sure

00:40:34,709 --> 00:40:39,569
the pins all that stuff's to work the

00:40:36,509 --> 00:40:41,279
the user I struck I'm from as another

00:40:39,569 --> 00:40:43,140
semi conductor company we always

00:40:41,279 --> 00:40:45,119
struggle with people going you're giving

00:40:43,140 --> 00:40:46,769
the software I can't touch the metal

00:40:45,119 --> 00:40:48,719
anymore that that's not true you could

00:40:46,769 --> 00:40:50,910
go pull in your Simpsons header file and

00:40:48,719 --> 00:40:55,079
go bang the bits directly if you want to

00:40:50,910 --> 00:40:56,220
so we're not doing away with that we're

00:40:55,079 --> 00:40:57,840
giving them

00:40:56,220 --> 00:41:00,930
much more functional software with

00:40:57,840 --> 00:41:02,310
drivers and and that has to map to the

00:41:00,930 --> 00:41:04,080
hardware in some way and that's what all

00:41:02,310 --> 00:41:10,530
this you know device tree stuff is

00:41:04,080 --> 00:41:12,480
trying to do in interest of time and

00:41:10,530 --> 00:41:13,560
he's got a few more examples we could if

00:41:12,480 --> 00:41:14,730
there's any more comments on this i

00:41:13,560 --> 00:41:16,830
would say hold and talk to andy

00:41:14,730 --> 00:41:19,320
afterwards and debate it the ways we can

00:41:16,830 --> 00:41:20,369
get to get to the next examples and then

00:41:19,320 --> 00:41:23,400
if there's time theme you can come back

00:41:20,369 --> 00:41:26,820
to that debate to thank you okay so the

00:41:23,400 --> 00:41:28,560
last piece of this is so device tree has

00:41:26,820 --> 00:41:30,240
some versioning information and i think

00:41:28,560 --> 00:41:32,490
maybe that it only really pertains to

00:41:30,240 --> 00:41:36,810
the divide street blobs is that true

00:41:32,490 --> 00:41:38,940
this means the versioning of the

00:41:36,810 --> 00:41:39,660
specification that you're using i see

00:41:38,940 --> 00:41:42,240
that there's some things that are

00:41:39,660 --> 00:41:44,790
deprecated but how would this would this

00:41:42,240 --> 00:41:47,310
affect us really are we have to keep

00:41:44,790 --> 00:41:48,780
this in our mind let versioning are you

00:41:47,310 --> 00:41:52,770
talking about i mean there is a version

00:41:48,780 --> 00:41:56,510
of the flattened the FTT but that

00:41:52,770 --> 00:41:56,510
changes like every 10 years

00:42:01,270 --> 00:42:10,150
the stability of binding and so forth

00:42:03,820 --> 00:42:12,460
we're not utilizing law really concern

00:42:10,150 --> 00:42:14,560
ourselves with that issue because of the

00:42:12,460 --> 00:42:16,450
environment we're building everything at

00:42:14,560 --> 00:42:18,610
once and just how it's utilized for it

00:42:16,450 --> 00:42:21,600
or not you know we don't miss Lee have

00:42:18,610 --> 00:42:21,600
that same stability

00:42:21,829 --> 00:42:27,769
what you do because you said this is for

00:42:24,329 --> 00:42:27,769
other OS environments as well

00:42:31,170 --> 00:42:37,710
I'll just plug here please don't go

00:42:33,660 --> 00:42:42,660
create Zephyr bindings use existing

00:42:37,710 --> 00:42:44,210
processes to define bindings and I

00:42:42,660 --> 00:42:46,619
wasn't looking at doing anything crazy

00:42:44,210 --> 00:42:49,500
we're talking about you know pretty

00:42:46,619 --> 00:42:51,510
generic nodes using all the standard

00:42:49,500 --> 00:42:53,520
required properties may be having some

00:42:51,510 --> 00:42:56,790
optional properties so it's not anything

00:42:53,520 --> 00:42:58,230
that's crazy right and you may not care

00:42:56,790 --> 00:43:01,380
about putting clocks in there

00:42:58,230 --> 00:43:03,690
immediately or power domains but right

00:43:01,380 --> 00:43:09,619
it could be a subset of what you care

00:43:03,690 --> 00:43:09,619
about right okay

00:43:11,660 --> 00:43:16,190
so when you're building up a device

00:43:14,390 --> 00:43:19,309
beeps specification there's a few things

00:43:16,190 --> 00:43:22,190
you have to look at or describe there's

00:43:19,309 --> 00:43:24,230
the CPU hierarchy devices and resources

00:43:22,190 --> 00:43:26,660
and resources can run anything from your

00:43:24,230 --> 00:43:31,549
registered address space interrupts jeje

00:43:26,660 --> 00:43:34,849
ayos pin MUX figuration clock clock

00:43:31,549 --> 00:43:36,289
gating control lots of different things

00:43:34,849 --> 00:43:37,720
and one of the things I noticed in

00:43:36,289 --> 00:43:40,339
Zephyr that was kind of interesting was

00:43:37,720 --> 00:43:43,940
the device labels were very important

00:43:40,339 --> 00:43:45,819
for some reason so so that's also

00:43:43,940 --> 00:43:50,299
something we need to be able to encode

00:43:45,819 --> 00:43:54,589
all of this is pretty easily manageable

00:43:50,299 --> 00:43:56,089
and device tree the the question that

00:43:54,589 --> 00:43:58,700
had here at the end of the slide was

00:43:56,089 --> 00:44:01,010
really so when you start talking about

00:43:58,700 --> 00:44:02,990
pin mops there's static pin boxes where

00:44:01,010 --> 00:44:05,119
you have a board that you have set ends

00:44:02,990 --> 00:44:07,099
in a certain way at the beginning and

00:44:05,119 --> 00:44:08,960
then they have device drivers which

00:44:07,099 --> 00:44:11,270
utilize other pins and they may have

00:44:08,960 --> 00:44:13,280
some pins if they set to use for spy and

00:44:11,270 --> 00:44:15,950
then they may have some low power modes

00:44:13,280 --> 00:44:17,569
where they want to turn those off the

00:44:15,950 --> 00:44:20,089
static pin muck settings question here

00:44:17,569 --> 00:44:22,279
was you know I see in some cases where

00:44:20,089 --> 00:44:24,829
there's some static configurations being

00:44:22,279 --> 00:44:27,109
done I didn't know exactly how important

00:44:24,829 --> 00:44:29,690
that was we can definitely easily deal

00:44:27,109 --> 00:44:30,890
with it but I would presume that this

00:44:29,690 --> 00:44:37,099
would be something that we would want to

00:44:30,890 --> 00:44:40,099
do or have support for so that's just a

00:44:37,099 --> 00:44:42,529
point I wanted to put in there so what I

00:44:40,099 --> 00:44:45,740
did initially was I chose the nxp

00:44:42,529 --> 00:44:49,160
freedom board and I just wrote a device

00:44:45,740 --> 00:44:51,710
tree file court and what I did here was

00:44:49,160 --> 00:44:53,529
I kind of cut and pasted it so this is

00:44:51,710 --> 00:44:55,880
kind of two column but as we go through

00:44:53,529 --> 00:44:59,599
through the different pages it'll

00:44:55,880 --> 00:45:02,150
progressively go forward at the very top

00:44:59,599 --> 00:45:05,740
of a device tree you typically have your

00:45:02,150 --> 00:45:09,170
board compatible and some idea of the

00:45:05,740 --> 00:45:10,869
address cells and size cells and really

00:45:09,170 --> 00:45:15,230
what those two fields are it tells you

00:45:10,869 --> 00:45:16,640
what are the number of contents of some

00:45:15,230 --> 00:45:20,390
of these fields are going to be

00:45:16,640 --> 00:45:25,579
so so in our case the the nxp has a

00:45:20,390 --> 00:45:27,619
single m4 f processor so when I added my

00:45:25,579 --> 00:45:33,740
cpu and i wish i had a laser pointer

00:45:27,619 --> 00:45:36,769
with anybody has very useful okay so we

00:45:33,740 --> 00:45:40,519
have a CPUs node and inside that we have

00:45:36,769 --> 00:45:42,380
one cpu and that cpu is defined as an

00:45:40,519 --> 00:45:45,589
arm cortex and for F because that's what

00:45:42,380 --> 00:45:48,519
goods we have some memory which is

00:45:45,589 --> 00:45:55,329
located at what is that 20 million

00:45:48,519 --> 00:45:55,329
address and that's where the the SRAM is

00:45:57,819 --> 00:46:02,329
you have it on so there's an interrupt

00:46:00,500 --> 00:46:04,130
controller which is just the invicta

00:46:02,329 --> 00:46:06,200
it's part of the m4 i went ahead and

00:46:04,130 --> 00:46:09,319
specified that and this these addresses

00:46:06,200 --> 00:46:11,809
are going to be the same across all the

00:46:09,319 --> 00:46:13,420
m four processors it's this is a very

00:46:11,809 --> 00:46:15,890
this is just the interrupt controller

00:46:13,420 --> 00:46:17,779
some of the boards very in the number of

00:46:15,890 --> 00:46:19,670
priority bits they have so this is a

00:46:17,779 --> 00:46:21,619
property that would actually matter and

00:46:19,670 --> 00:46:23,029
then the number of ir cues would

00:46:21,619 --> 00:46:25,490
actually change as well based off of

00:46:23,029 --> 00:46:28,130
what what the board is and what however

00:46:25,490 --> 00:46:30,500
many they define if you look in the

00:46:28,130 --> 00:46:33,200
Simpsons files the vendor defined ones

00:46:30,500 --> 00:46:37,960
this type of information will be located

00:46:33,200 --> 00:46:41,599
there you'll see that we have a timer

00:46:37,960 --> 00:46:43,640
which has some clock source I put a zero

00:46:41,599 --> 00:46:45,920
here typically what happens in device

00:46:43,640 --> 00:46:47,599
tree is you have include files and these

00:46:45,920 --> 00:46:50,390
include files would allow you to use

00:46:47,599 --> 00:46:53,299
some type of name here that would that

00:46:50,390 --> 00:46:54,500
would in turn actually be a zero we

00:46:53,299 --> 00:46:56,960
would probably want to have something

00:46:54,500 --> 00:46:59,509
that delves our minds some of these

00:46:56,960 --> 00:47:00,589
names out of the either dissembles or

00:46:59,509 --> 00:47:02,809
some of the other files that are

00:47:00,589 --> 00:47:04,789
included as part of the vendor just to

00:47:02,809 --> 00:47:05,960
be more descriptive of what it is so

00:47:04,789 --> 00:47:07,400
that when you actually look at this file

00:47:05,960 --> 00:47:09,849
you can actually read it and understand

00:47:07,400 --> 00:47:09,849
what's going on

00:47:11,320 --> 00:47:15,410
the clock sorts no this is this is the

00:47:14,030 --> 00:47:18,680
actual setting that you would want to

00:47:15,410 --> 00:47:20,450
set in the register usually there's two

00:47:18,680 --> 00:47:23,869
or three different choices you have for

00:47:20,450 --> 00:47:26,750
this type of thing some boards may have

00:47:23,869 --> 00:47:28,460
a Tempe you if they do have an mpu they

00:47:26,750 --> 00:47:29,900
may have some regions here that they

00:47:28,460 --> 00:47:32,329
want to actually do some protection on

00:47:29,900 --> 00:47:33,980
they would define this here as well and

00:47:32,329 --> 00:47:36,560
this would actually be used during the

00:47:33,980 --> 00:47:41,060
board initialization to configure the

00:47:36,560 --> 00:47:42,349
mpu properly I guess I had to stop for a

00:47:41,060 --> 00:47:44,359
second and talk about some of these

00:47:42,349 --> 00:47:46,670
these required fields that are part of

00:47:44,359 --> 00:47:47,869
these nodes for each one of the device

00:47:46,670 --> 00:47:50,869
nodes you're going to want to have a

00:47:47,869 --> 00:47:52,730
compatible that tells you one what the

00:47:50,869 --> 00:47:55,490
manufacturer board is but also what the

00:47:52,730 --> 00:47:57,770
component is this can be used to figure

00:47:55,490 --> 00:48:00,500
out what kind of device drivers you need

00:47:57,770 --> 00:48:02,210
this is how we would figure out in parts

00:48:00,500 --> 00:48:04,089
this to determine our cake config

00:48:02,210 --> 00:48:07,010
options if that's what we're going to do

00:48:04,089 --> 00:48:09,829
this reg entry here is actually the

00:48:07,010 --> 00:48:11,300
register space for this device because

00:48:09,829 --> 00:48:13,400
of the settings that we have we actually

00:48:11,300 --> 00:48:16,339
are able to say not only the start

00:48:13,400 --> 00:48:18,859
address but also the size i found that

00:48:16,339 --> 00:48:20,359
the size really doesn't matter it's more

00:48:18,859 --> 00:48:23,839
the base address that matters for a lot

00:48:20,359 --> 00:48:26,480
of these things you can talk you can

00:48:23,839 --> 00:48:28,310
actually define clock controllers define

00:48:26,480 --> 00:48:30,140
your system clock frequency here which I

00:48:28,310 --> 00:48:33,079
I called system clock frequency but it

00:48:30,140 --> 00:48:36,680
could just be clock frequency most

00:48:33,079 --> 00:48:38,119
boards have more than one clock in the

00:48:36,680 --> 00:48:41,200
case of the freedom board they have also

00:48:38,119 --> 00:48:43,660
have this oscillator that you can also

00:48:41,200 --> 00:48:50,260
define where the

00:48:43,660 --> 00:48:52,569
the reference comes from continuing on

00:48:50,260 --> 00:48:53,880
there's an RTC and pardon the tabbing

00:48:52,569 --> 00:48:56,260
here I don't know what the heck happened

00:48:53,880 --> 00:49:00,369
there's an RTC that has a clock

00:48:56,260 --> 00:49:02,109
frequency of 32 k we have so here's

00:49:00,369 --> 00:49:08,829
where some of these differences in the

00:49:02,109 --> 00:49:11,740
boards are so this sim the sim device on

00:49:08,829 --> 00:49:15,190
the nxp not only provides some

00:49:11,740 --> 00:49:18,369
configuration for the divisors for the

00:49:15,190 --> 00:49:20,260
different bus clocks it also provides

00:49:18,369 --> 00:49:23,650
the clock gating for the device

00:49:20,260 --> 00:49:27,220
peripherals so there are registers that

00:49:23,650 --> 00:49:29,980
exist in the node like three see I think

00:49:27,220 --> 00:49:31,900
that there's a bit assigned in that

00:49:29,980 --> 00:49:34,780
derivative in that register that

00:49:31,900 --> 00:49:38,349
actually will enable or disable clocks

00:49:34,780 --> 00:49:39,730
for spy i squared CEU arts so this would

00:49:38,349 --> 00:49:41,799
this would be a note that would actually

00:49:39,730 --> 00:49:44,940
be referenced later when we start

00:49:41,799 --> 00:49:47,230
talking about clock the gate enabling

00:49:44,940 --> 00:49:49,329
this board also has a flash controller

00:49:47,230 --> 00:49:50,890
and has some flash on it this flash note

00:49:49,329 --> 00:49:52,660
here would probably actually reside as a

00:49:50,890 --> 00:49:58,839
child underneath the flash controller I

00:49:52,660 --> 00:50:01,720
was to do this properly if a device has

00:49:58,839 --> 00:50:06,430
interrupts you can define or what the

00:50:01,720 --> 00:50:08,650
interrupt is as well one of the things I

00:50:06,430 --> 00:50:12,160
started doing was in zephyr they have

00:50:08,650 --> 00:50:14,710
the devices have names I threw in this

00:50:12,160 --> 00:50:16,410
dev name property but actually i think

00:50:14,710 --> 00:50:18,849
it probably should be a label that

00:50:16,410 --> 00:50:21,039
problem makes more sense i I don't know

00:50:18,849 --> 00:50:22,690
you can do it that way as well but

00:50:21,039 --> 00:50:24,579
here's where it gets interesting so so

00:50:22,690 --> 00:50:27,339
we have a you are or some number of you

00:50:24,579 --> 00:50:30,039
are it's actually in this case to the

00:50:27,339 --> 00:50:33,430
first you art has you know it's at you

00:50:30,039 --> 00:50:35,049
know 4,000 6000 des interrupt as baud

00:50:33,430 --> 00:50:37,299
rate but here's the interesting part so

00:50:35,049 --> 00:50:40,210
here's where you can actually define the

00:50:37,299 --> 00:50:41,859
pin muck settings for for the device it

00:50:40,210 --> 00:50:46,750
just so happens that this you are it is

00:50:41,859 --> 00:50:48,910
on port be 10 16 17 is using all

00:50:46,750 --> 00:50:51,160
function 3 so the way i decided to

00:50:48,910 --> 00:50:53,559
encode this and i can play around with

00:50:51,160 --> 00:50:57,609
this a little bit is is the first

00:50:53,559 --> 00:50:59,890
element defines which port it's going to

00:50:57,609 --> 00:51:01,539
sit on the second one defines what pin

00:50:59,890 --> 00:51:04,660
and the third one defines the function

00:51:01,539 --> 00:51:07,150
and you can actually have multiple sets

00:51:04,660 --> 00:51:09,069
of these pin mocks entries that we could

00:51:07,150 --> 00:51:12,760
use to say okay this is the active state

00:51:09,069 --> 00:51:14,170
and this is a sleep state and then we

00:51:12,760 --> 00:51:15,940
also have the dev name which is the you

00:51:14,170 --> 00:51:17,740
are which is used during the device API

00:51:15,940 --> 00:51:20,829
and Annette call to give a name for the

00:51:17,740 --> 00:51:22,869
device I didn't do the same thing for

00:51:20,829 --> 00:51:24,400
the UART the second view art because I

00:51:22,869 --> 00:51:27,670
was at that point I was kind of tired of

00:51:24,400 --> 00:51:30,970
looking through the pin mugs chart so i

00:51:27,670 --> 00:51:32,950
skipped that one but then we have the

00:51:30,970 --> 00:51:36,460
pin mux controller so this actually in

00:51:32,950 --> 00:51:38,020
the in the nxp freedom board at this

00:51:36,460 --> 00:51:40,270
address you actually have the

00:51:38,020 --> 00:51:42,579
configurations where you would configure

00:51:40,270 --> 00:51:46,960
the pin mux functions for the different

00:51:42,579 --> 00:51:49,359
pens so if you notice well and I decided

00:51:46,960 --> 00:51:50,200
in this case not to use a P handle but

00:51:49,359 --> 00:51:52,329
I'll probably need to go back and

00:51:50,200 --> 00:51:53,799
actually do that because we need to be

00:51:52,329 --> 00:51:59,799
able to figure out what address we need

00:51:53,799 --> 00:52:01,539
to modify and offset well we have a pin

00:51:59,799 --> 00:52:03,460
marks pardoning already so we should use

00:52:01,539 --> 00:52:05,460
that with that there's a pin mugs

00:52:03,460 --> 00:52:08,559
binding already so that should be used

00:52:05,460 --> 00:52:13,440
yeah I need to look at that again I mark

00:52:08,559 --> 00:52:16,359
has a comment also for the UART naming

00:52:13,440 --> 00:52:20,829
chosen or aliases would be a better

00:52:16,359 --> 00:52:26,710
option for that or just put that outside

00:52:20,829 --> 00:52:30,130
of the device tree that's part of your

00:52:26,710 --> 00:52:33,750
mapping of compatibles to drivers right

00:52:30,130 --> 00:52:33,750
yeah that could be done

00:52:36,369 --> 00:52:43,550
so on this board we have a number of

00:52:38,839 --> 00:52:45,890
gpio ports a b c d e and e for each one

00:52:43,550 --> 00:52:50,180
of these it encompasses some number of

00:52:45,890 --> 00:52:51,530
gpio pins i think it's like 32 / but for

00:52:50,180 --> 00:52:54,200
each one of these we have a different

00:52:51,530 --> 00:52:57,010
interrupt we have different set of base

00:52:54,200 --> 00:53:00,740
register offsets and a different labels

00:52:57,010 --> 00:53:02,150
and this gets utilized later so so the

00:53:00,740 --> 00:53:05,630
next device we have here is a spy and

00:53:02,150 --> 00:53:07,460
this is again is a good example you have

00:53:05,630 --> 00:53:09,619
your compatible your reg your reg

00:53:07,460 --> 00:53:12,710
register entry your interrupts your

00:53:09,619 --> 00:53:15,079
clocks this is your clock gating so I

00:53:12,710 --> 00:53:17,780
probably need to rework this and use a P

00:53:15,079 --> 00:53:19,640
handle to the to the sim and use an

00:53:17,780 --> 00:53:21,760
offset with the with a bit kind of like

00:53:19,640 --> 00:53:25,130
a siscon or something like that that's

00:53:21,760 --> 00:53:27,619
simulator we have clock bondings already

00:53:25,130 --> 00:53:30,589
precisely this the P handle plus cloak

00:53:27,619 --> 00:53:34,520
specific torque specified after i did it

00:53:30,589 --> 00:53:37,790
i look back at some of the arm DTS files

00:53:34,520 --> 00:53:39,650
and i was like i need to rework this but

00:53:37,790 --> 00:53:42,140
a one of the things that you see down

00:53:39,650 --> 00:53:44,569
here is a chip selects so this is one of

00:53:42,140 --> 00:53:45,980
the things that is very useful for users

00:53:44,569 --> 00:53:47,690
they're going to want to have some

00:53:45,980 --> 00:53:49,910
number of devices they need to be able

00:53:47,690 --> 00:53:52,369
to specify with the chip selects are and

00:53:49,910 --> 00:53:54,680
in this case what i decided to use was a

00:53:52,369 --> 00:53:58,819
p handle this actually is a reference to

00:53:54,680 --> 00:54:02,210
this node here and it tells you this

00:53:58,819 --> 00:54:04,970
port 10 10 and pin 9 are being used for

00:54:02,210 --> 00:54:06,619
chip select 0 and chip select one so

00:54:04,970 --> 00:54:08,690
when I actually go to program this I

00:54:06,619 --> 00:54:10,430
know which port it is based off of this

00:54:08,690 --> 00:54:13,069
handle right here which points to it and

00:54:10,430 --> 00:54:14,900
the other piece and this is why when I

00:54:13,069 --> 00:54:16,849
got to this point and saw my pin mux was

00:54:14,900 --> 00:54:19,190
very hey symmetric with respect to this

00:54:16,849 --> 00:54:20,569
I need to go back and fix this I need to

00:54:19,190 --> 00:54:25,640
use a P handle for the pin mux as well

00:54:20,569 --> 00:54:27,319
which points to the but again this pin

00:54:25,640 --> 00:54:30,890
marks here is for the other parts of the

00:54:27,319 --> 00:54:33,150
spy pins that are being used all

00:54:30,890 --> 00:54:35,549
function to is the spy

00:54:33,150 --> 00:54:38,849
set and I probably missed one or three

00:54:35,549 --> 00:54:42,930
tents cuz you know there's a clock me so

00:54:38,849 --> 00:54:44,309
mozi so I think I missed one pin yeah so

00:54:42,930 --> 00:54:45,839
I'm running out of time let me skip

00:54:44,309 --> 00:54:49,380
forward we're almost done actually the

00:54:45,839 --> 00:54:51,900
last piece is the watchdog the PWM s

00:54:49,380 --> 00:54:53,520
again we have some similar information

00:54:51,900 --> 00:54:56,640
from TW ms you're going to have other

00:54:53,520 --> 00:54:57,960
things like a period of prescaler some

00:54:56,640 --> 00:55:02,880
clock source and maybe some channel

00:54:57,960 --> 00:55:04,650
information that can be described lastly

00:55:02,880 --> 00:55:07,380
so this is the tooling that we've been

00:55:04,650 --> 00:55:10,920
talking about during this this thing the

00:55:07,380 --> 00:55:14,520
way I see this is we you have a DTS file

00:55:10,920 --> 00:55:16,049
that's defined we pull in some include

00:55:14,520 --> 00:55:18,900
information from some of the symphysis

00:55:16,049 --> 00:55:21,359
includes and also some of the other

00:55:18,900 --> 00:55:24,450
vendor include files to fill in some of

00:55:21,359 --> 00:55:27,420
these to make it more to take our more

00:55:24,450 --> 00:55:30,359
legible or readable information and

00:55:27,420 --> 00:55:32,460
actually turn it into the numbers and

00:55:30,359 --> 00:55:38,099
stuff that we need we run that through

00:55:32,460 --> 00:55:40,859
the pre process to generate that then we

00:55:38,099 --> 00:55:42,299
run it through some scripting to pull

00:55:40,859 --> 00:55:44,010
out the information we need to build up

00:55:42,299 --> 00:55:46,650
the structures we need for the in it and

00:55:44,010 --> 00:55:48,539
also for the devices and this this falls

00:55:46,650 --> 00:55:50,910
into what rob was referring to earlier

00:55:48,539 --> 00:55:53,609
where you're only going to want to call

00:55:50,910 --> 00:55:55,349
the device API and it on the you arts if

00:55:53,609 --> 00:55:56,819
you have some and you'll need to call it

00:55:55,349 --> 00:55:58,980
some number of times based off of the

00:55:56,819 --> 00:56:00,630
number of you arts that you have this is

00:55:58,980 --> 00:56:02,579
where we would go through this and

00:56:00,630 --> 00:56:06,990
figure out how we how we would do that

00:56:02,579 --> 00:56:08,880
and so the DTS allows us to build up all

00:56:06,990 --> 00:56:10,650
these different types of structures and

00:56:08,880 --> 00:56:13,980
also gives us the ability to figure out

00:56:10,650 --> 00:56:16,770
the cake and big options and that's kind

00:56:13,980 --> 00:56:19,020
of this this process is how I envisioned

00:56:16,770 --> 00:56:21,000
it working when you do make it ratchets

00:56:19,020 --> 00:56:22,810
through these different things all this

00:56:21,000 --> 00:56:24,630
happens in the background

00:56:22,810 --> 00:56:26,530
you know the configuration just works

00:56:24,630 --> 00:56:29,470
the user doesn't even know anything

00:56:26,530 --> 00:56:30,820
about it and that's pretty much all of

00:56:29,470 --> 00:56:32,260
it in a nutshell we've already touched

00:56:30,820 --> 00:56:34,420
on some of these other things earlier in

00:56:32,260 --> 00:56:37,950
the talk but you know do we have any

00:56:34,420 --> 00:56:37,950
questions or other points of discussion

00:56:41,820 --> 00:56:49,000
thank you so I had a question one of the

00:56:45,730 --> 00:56:51,310
one of the concerns I've heard of it is

00:56:49,000 --> 00:56:53,560
from a slightly different market

00:56:51,310 --> 00:56:55,150
segments potentially makers and and

00:56:53,560 --> 00:56:57,100
people who get these development boards

00:56:55,150 --> 00:56:59,110
one of the questions that comes up is

00:56:57,100 --> 00:57:01,930
how do I discover the capability of the

00:56:59,110 --> 00:57:03,520
board sometimes the default

00:57:01,930 --> 00:57:07,000
configuration may have many things

00:57:03,520 --> 00:57:09,010
disabled it will this aid in having

00:57:07,000 --> 00:57:11,650
people discover additional capabilities

00:57:09,010 --> 00:57:15,070
or if they wanted for example tie into a

00:57:11,650 --> 00:57:17,200
particular gpio how would this benefit

00:57:15,070 --> 00:57:22,230
them is that is that the intent or is

00:57:17,200 --> 00:57:24,760
that attentional cool well so you can

00:57:22,230 --> 00:57:26,020
define all of the devices whether or not

00:57:24,760 --> 00:57:28,300
they're going to be used so there's

00:57:26,020 --> 00:57:31,510
there's a property that I didn't show

00:57:28,300 --> 00:57:34,420
which is status so if the status is set

00:57:31,510 --> 00:57:35,680
to entertain it's an active node that

00:57:34,420 --> 00:57:38,200
you're expecting to be used in the

00:57:35,680 --> 00:57:39,790
system if not it's disabled so so the

00:57:38,200 --> 00:57:40,750
way I would see this is is that the

00:57:39,790 --> 00:57:42,990
vendors going to come in and actually

00:57:40,750 --> 00:57:45,280
define every device in the system

00:57:42,990 --> 00:57:48,190
whether or not they're labeled is a

00:57:45,280 --> 00:57:49,900
completely different thing for a

00:57:48,190 --> 00:57:52,210
development board they would have

00:57:49,900 --> 00:57:53,830
leverage the dts files that are the

00:57:52,210 --> 00:57:55,780
vendor comes up with that contain all

00:57:53,830 --> 00:57:57,550
this information they would go through

00:57:55,780 --> 00:57:59,770
and enable the pieces that they need and

00:57:57,550 --> 00:58:01,360
they would add the pin MUX and gpio

00:57:59,770 --> 00:58:04,720
information for the nodes of the need

00:58:01,360 --> 00:58:07,300
and that's how it work from from a maker

00:58:04,720 --> 00:58:09,820
perspective the end user

00:58:07,300 --> 00:58:11,410
I'm not quite sure how we would make

00:58:09,820 --> 00:58:13,780
this automated I think that would be

00:58:11,410 --> 00:58:14,890
something that I can I believe but one

00:58:13,780 --> 00:58:16,810
of those things would have to deal with

00:58:14,890 --> 00:58:18,460
if you have your options set in the IDE

00:58:16,810 --> 00:58:21,400
it would go through and generate the dts

00:58:18,460 --> 00:58:24,190
bits that are needed on top of the

00:58:21,400 --> 00:58:26,530
vendor specific DTS file then you use

00:58:24,190 --> 00:58:31,050
together Andy sorry to interrupt Willie

00:58:26,530 --> 00:58:31,050
over time absolutely dead me do that

00:58:37,970 --> 00:58:40,030

YouTube URL: https://www.youtube.com/watch?v=ehbeqDi7Jf4


