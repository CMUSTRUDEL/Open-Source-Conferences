Title: LAS16-108: Jerryscript and other scripting languages for IoT
Publication date: 2016-09-30
Playlist: Linaro Connect Las Vegas 2016
Description: 
	LAS16-108: JerryScript and other scripting languages for IoT
Speakers: Paul Sokolovsky
Date: September 26, 2016

★ Session Description ★
Overview of small-size/low-resource VHLL (very high-level languages)/scripting languages available for embedded/IoT usage (JavaScript, Python, Lua, etc.). Typical/possible usage scenarios and benefits. Challenges of running VHLLs in deeply embedded/very resource-constrained environments. Progress reports on porting JerryScript to Zephyr. (Possibly, architecture comparison of JerryScript and MicroPython).

★ Resources ★
Etherpad: pad.linaro.org/p/las16-108
Presentations & Videos: http://connect.linaro.org/resource/las16/las16-108/

★ Event Details ★
Linaro Connect Las Vegas 2016 – #LAS16
September 26-30, 2016
http://www.linaro.org
http://connect.linaro.org
Captions: 
	00:00:08,510 --> 00:00:14,150
hi I'm sterling everyone and I'm here to

00:00:12,240 --> 00:00:16,590
talk about a packing my new which is

00:00:14,150 --> 00:00:17,940
probably the smallest of the operating

00:00:16,590 --> 00:00:20,189
system efforts that have been presented

00:00:17,940 --> 00:00:22,800
today but I'll give you a little bit of

00:00:20,189 --> 00:00:25,410
an overview of our project very similar

00:00:22,800 --> 00:00:26,910
to both zephyr and embed we're an

00:00:25,410 --> 00:00:29,519
operating system that's targeting

00:00:26,910 --> 00:00:32,579
cortex-m and kind of that class of

00:00:29,519 --> 00:00:34,290
processors so we are agnostic of MCU

00:00:32,579 --> 00:00:36,180
architecture we want to work on Intel we

00:00:34,290 --> 00:00:38,730
want to work on mips but if you kind of

00:00:36,180 --> 00:00:40,920
think about the applicable space for our

00:00:38,730 --> 00:00:42,420
operating system it's really cortex ms

00:00:40,920 --> 00:00:45,690
and that's where we've spent a lot of

00:00:42,420 --> 00:00:47,940
our early time so anywhere from an m0 to

00:00:45,690 --> 00:00:51,000
an m7 is really our target architecture

00:00:47,940 --> 00:00:52,050
and kind of during the talk i'll just

00:00:51,000 --> 00:00:54,000
talk a little bit about what the

00:00:52,050 --> 00:00:55,920
motivations behind apache my new work

00:00:54,000 --> 00:00:59,250
why we decided to start yet another

00:00:55,920 --> 00:01:01,199
operating system effort and kind of what

00:00:59,250 --> 00:01:02,609
our philosophy behind it is right

00:01:01,199 --> 00:01:05,430
because I think we all of the operating

00:01:02,609 --> 00:01:08,070
systems up here today really do kind of

00:01:05,430 --> 00:01:09,780
have good end goals but maybe different

00:01:08,070 --> 00:01:11,549
things that they're optimizing for so

00:01:09,780 --> 00:01:13,140
I'll talk a little bit about what Apache

00:01:11,549 --> 00:01:17,159
my new is really focused on getting

00:01:13,140 --> 00:01:19,259
right first recognizing that we all have

00:01:17,159 --> 00:01:24,119
kind of expansive roadmaps towards the

00:01:19,259 --> 00:01:25,409
end of it all so my background is at

00:01:24,119 --> 00:01:26,970
what was from a company called silver

00:01:25,409 --> 00:01:29,009
spring networks at silver spring

00:01:26,970 --> 00:01:30,960
networks we did network power meters

00:01:29,009 --> 00:01:32,579
network streetlights and kind of some of

00:01:30,960 --> 00:01:36,810
the first smart city networks so we

00:01:32,579 --> 00:01:39,150
deployed 23 million ipv6 connected

00:01:36,810 --> 00:01:41,640
devices and it was my job to manage the

00:01:39,150 --> 00:01:43,590
firmware team that developed the

00:01:41,640 --> 00:01:45,509
software that ran on those devices but

00:01:43,590 --> 00:01:47,909
the NASA also read upgrades of those

00:01:45,509 --> 00:01:50,189
devices on customer Netflix so we had

00:01:47,909 --> 00:01:51,930
service level agreements where when we

00:01:50,189 --> 00:01:54,180
upgraded devices we couldn't brick them

00:01:51,930 --> 00:01:57,119
we had devices that lived in the field

00:01:54,180 --> 00:01:58,590
for 10 to 15 years where we would

00:01:57,119 --> 00:02:01,950
constantly have to provide software

00:01:58,590 --> 00:02:04,049
updates to those devices and we had you

00:02:01,950 --> 00:02:06,270
know 50 60 different revisions of

00:02:04,049 --> 00:02:08,360
hardware and manufacturing options and

00:02:06,270 --> 00:02:11,009
all of those things out in the field

00:02:08,360 --> 00:02:12,900
while we couldn't go and brick 23

00:02:11,009 --> 00:02:13,590
million devices yet we still had a

00:02:12,900 --> 00:02:15,870
release

00:02:13,590 --> 00:02:18,840
where to run on those devices and so

00:02:15,870 --> 00:02:21,060
Silver Spring was kind of this work was

00:02:18,840 --> 00:02:23,340
done in 2004 right and at that time

00:02:21,060 --> 00:02:25,410
there was a lot of there wasn't a lot of

00:02:23,340 --> 00:02:27,030
uniformity in this space both on the

00:02:25,410 --> 00:02:30,150
hardware side so if you looked at the

00:02:27,030 --> 00:02:32,489
chipsets we used it was an at mega 128

00:02:30,150 --> 00:02:35,390
that that we put a full light key stack

00:02:32,489 --> 00:02:37,830
on in a full mesh networking stack

00:02:35,390 --> 00:02:40,650
external radios we had two point four

00:02:37,830 --> 00:02:42,510
and nine hundred so we had two radios we

00:02:40,650 --> 00:02:44,970
had an external flash chip and external

00:02:42,510 --> 00:02:46,560
RAM chip eventually and so the board was

00:02:44,970 --> 00:02:49,650
a whole bunch of chips that weren't

00:02:46,560 --> 00:02:52,769
really know you know coordinated in any

00:02:49,650 --> 00:02:55,349
fashion and has as time went by silver

00:02:52,769 --> 00:02:56,610
springs hardware architecture evolved

00:02:55,349 --> 00:02:58,500
and things got more integrated and

00:02:56,610 --> 00:03:00,390
smaller and like you see today there's a

00:02:58,500 --> 00:03:03,900
whole bunch of system-on-chips the new

00:03:00,390 --> 00:03:08,000
TI chip as an example has a 80 to 15 for

00:03:03,900 --> 00:03:10,319
radio in sub gigahertz and a 2.4 and

00:03:08,000 --> 00:03:11,970
bluetooth all in a single chip design

00:03:10,319 --> 00:03:14,190
with a processor with rent memory and

00:03:11,970 --> 00:03:15,299
flash to run an operating system so we

00:03:14,190 --> 00:03:18,180
saw hardware getting a lot more

00:03:15,299 --> 00:03:20,459
integrated in these end points but we

00:03:18,180 --> 00:03:23,250
had kind of built our own operating

00:03:20,459 --> 00:03:25,230
system stack as a company right so when

00:03:23,250 --> 00:03:27,720
we started out we reuse you cost from

00:03:25,230 --> 00:03:29,430
mccrea and you know we modified it

00:03:27,720 --> 00:03:32,220
because you know the scheduler was a big

00:03:29,430 --> 00:03:35,310
array and we wanted to have a sleep list

00:03:32,220 --> 00:03:36,870
and a run list we built our own memories

00:03:35,310 --> 00:03:38,910
about the interfaces we build our own

00:03:36,870 --> 00:03:40,560
boot loaders our own flash file system

00:03:38,910 --> 00:03:42,030
we built everything that you would

00:03:40,560 --> 00:03:44,340
typically think of if you thought of

00:03:42,030 --> 00:03:46,230
Linux and an operating system that what

00:03:44,340 --> 00:03:49,139
didn't really exist in the space we were

00:03:46,230 --> 00:03:51,930
targeting and so of course we did that

00:03:49,139 --> 00:03:53,880
on a very tight time schedule and our

00:03:51,930 --> 00:03:55,380
boss didn't care about the you know

00:03:53,880 --> 00:03:57,870
beauty of it what was the first thing

00:03:55,380 --> 00:04:00,079
you get rid of its security right like

00:03:57,870 --> 00:04:02,579
and so we had this very rudimentary

00:04:00,079 --> 00:04:05,010
operating system that over time we

00:04:02,579 --> 00:04:06,690
evolved and we had to live with the

00:04:05,010 --> 00:04:08,319
mistakes we made in developing that

00:04:06,690 --> 00:04:09,939
operating system for a very long

00:04:08,319 --> 00:04:12,579
right once you've written the right

00:04:09,939 --> 00:04:14,409
protect area flash it's really hard to

00:04:12,579 --> 00:04:17,289
drop compatibility or something if

00:04:14,409 --> 00:04:19,359
you've messed the format ax and so there

00:04:17,289 --> 00:04:21,100
are all of these this kind of pain that

00:04:19,359 --> 00:04:22,300
we built and it's a little bit like you

00:04:21,100 --> 00:04:23,740
know you build this house of cards

00:04:22,300 --> 00:04:26,229
because you have to build a connected

00:04:23,740 --> 00:04:28,270
lock or connected wearable or some sort

00:04:26,229 --> 00:04:30,160
of connected product but you then have

00:04:28,270 --> 00:04:32,889
to build the entire stack up yourself

00:04:30,160 --> 00:04:35,289
and then you have to scale that and you

00:04:32,889 --> 00:04:37,419
have a massive amount of resources spent

00:04:35,289 --> 00:04:39,460
in scaling operating system

00:04:37,419 --> 00:04:41,860
functionality which isn't really your

00:04:39,460 --> 00:04:43,389
core expertise as a product company and

00:04:41,860 --> 00:04:44,740
we certainly found at Silver Spring I

00:04:43,389 --> 00:04:46,780
mean I think was a team and eventually

00:04:44,740 --> 00:04:49,599
if 1520 people just on the core

00:04:46,780 --> 00:04:51,370
infrastructure even with that resource

00:04:49,599 --> 00:04:54,550
spend our compilers were years out of

00:04:51,370 --> 00:04:56,979
date are you know we you know we found a

00:04:54,550 --> 00:04:59,139
bug in this one compiler and it worked

00:04:56,979 --> 00:05:00,580
and we forgot what the bug was that we

00:04:59,139 --> 00:05:02,500
found so we were deathly afraid of

00:05:00,580 --> 00:05:04,090
upgrading in case we ran into it and

00:05:02,500 --> 00:05:06,009
there were all these things where you

00:05:04,090 --> 00:05:07,900
just had a very old tool chain because

00:05:06,009 --> 00:05:09,820
it wasn't really our core expertise to

00:05:07,900 --> 00:05:11,650
maintain that tool chain and really

00:05:09,820 --> 00:05:13,210
that's what open source is really good

00:05:11,650 --> 00:05:15,400
at right having these platform

00:05:13,210 --> 00:05:17,620
technologies that cross a cut across

00:05:15,400 --> 00:05:19,000
things and actually outsource in the

00:05:17,620 --> 00:05:20,860
maintenance to a commute of broader

00:05:19,000 --> 00:05:23,500
community of people who share the same

00:05:20,860 --> 00:05:26,229
problems that you have so Apache minut

00:05:23,500 --> 00:05:29,409
is a pre-emptive real-time operating

00:05:26,229 --> 00:05:30,970
system for cortex-m environments but

00:05:29,409 --> 00:05:33,340
it's really about providing the whole

00:05:30,970 --> 00:05:36,789
stack for somebody to develop a product

00:05:33,340 --> 00:05:38,650
so this means at the base level it comes

00:05:36,789 --> 00:05:40,720
with a boot loader that boot loader

00:05:38,650 --> 00:05:42,270
works on all of the software on all of

00:05:40,720 --> 00:05:46,000
the hardware platforms that we support

00:05:42,270 --> 00:05:47,710
it has support for security so all

00:05:46,000 --> 00:05:50,949
images that are uploaded to the device

00:05:47,710 --> 00:05:54,789
are signed sha256 with an art either RSA

00:05:50,949 --> 00:05:57,400
or ECC DSA in the bootloader we've we've

00:05:54,789 --> 00:05:58,870
also gone to the point on the chips we

00:05:57,400 --> 00:06:00,969
support we support the various options

00:05:58,870 --> 00:06:05,620
for linking these images so on

00:06:00,969 --> 00:06:07,960
higher-end host processors we duel Bank

00:06:05,620 --> 00:06:10,360
images on the lower end processors like

00:06:07,960 --> 00:06:12,370
a Nordic will actually support in-place

00:06:10,360 --> 00:06:14,680
upgrade where we separate the operating

00:06:12,370 --> 00:06:18,310
system and kernel and we upgrade them in

00:06:14,680 --> 00:06:20,320
sequence a flash file system so multiple

00:06:18,310 --> 00:06:22,000
flash access mechanisms as you know on

00:06:20,320 --> 00:06:23,920
these kind of small platforms

00:06:22,000 --> 00:06:26,560
a file system sometimes takes up way too

00:06:23,920 --> 00:06:29,020
much memory so we have things like flash

00:06:26,560 --> 00:06:31,120
configuration variables circular buffers

00:06:29,020 --> 00:06:32,860
that allow you to write data to flash in

00:06:31,120 --> 00:06:34,750
a standard format but we handle things

00:06:32,860 --> 00:06:36,520
like see are seeing and encrypting that

00:06:34,750 --> 00:06:38,830
data and tying that into our

00:06:36,520 --> 00:06:40,360
configuration system so kind of a base

00:06:38,830 --> 00:06:42,850
level we've built that secure a

00:06:40,360 --> 00:06:44,560
bootloader flash file system on top of

00:06:42,850 --> 00:06:46,650
that we have the OS and the hardware

00:06:44,560 --> 00:06:49,090
abstraction layer so the OS is a

00:06:46,650 --> 00:06:51,670
standard pre-emptive multitasking our

00:06:49,090 --> 00:06:55,000
toss there is literally no magic in it

00:06:51,670 --> 00:06:57,310
um but when we looked at to build

00:06:55,000 --> 00:06:58,840
something what we saw was it's not that

00:06:57,310 --> 00:07:00,790
hard to build build a realtime kernel

00:06:58,840 --> 00:07:03,810
it's actually I think we spent two weeks

00:07:00,790 --> 00:07:06,640
on it maybe three in terms of testing

00:07:03,810 --> 00:07:09,310
but what what you miss in a lot of the

00:07:06,640 --> 00:07:10,240
kernels that are out there isn't is or

00:07:09,310 --> 00:07:13,570
at least a lot of the open-source

00:07:10,240 --> 00:07:15,370
kernels is support for debug ability and

00:07:13,570 --> 00:07:17,620
support for things like unified buffer

00:07:15,370 --> 00:07:20,560
schemes so a lot of what we did was tie

00:07:17,620 --> 00:07:22,720
together debugging interfaces into our

00:07:20,560 --> 00:07:25,300
own kernel so we have stack guard and

00:07:22,720 --> 00:07:27,820
stack checking we have all of our memory

00:07:25,300 --> 00:07:31,360
pools actually kept count freeze in the

00:07:27,820 --> 00:07:33,340
net and Alex we built a sanity task that

00:07:31,360 --> 00:07:35,169
ties into the watchdog and keeps the

00:07:33,340 --> 00:07:37,450
operating system up so it's really been

00:07:35,169 --> 00:07:39,310
about focusing on making the colonel

00:07:37,450 --> 00:07:41,919
very very easy to debug and tying into

00:07:39,310 --> 00:07:43,540
the rest of our system there's a

00:07:41,919 --> 00:07:46,120
hardware abstraction layer so we've done

00:07:43,540 --> 00:07:48,430
kind of a dual approach here where for

00:07:46,120 --> 00:07:51,190
every ms of you we support we support

00:07:48,430 --> 00:07:54,850
the how the how is based processor level

00:07:51,190 --> 00:07:56,770
features so spy i squared c you are all

00:07:54,850 --> 00:07:59,050
of those things the hal runs completely

00:07:56,770 --> 00:08:01,360
independent to the operating system

00:07:59,050 --> 00:08:02,800
itself so you can put the hell in the

00:08:01,360 --> 00:08:04,930
bootloader as an example and so if you

00:08:02,800 --> 00:08:06,760
add serial boot support you can still

00:08:04,930 --> 00:08:09,669
leverage the hell without requiring the

00:08:06,760 --> 00:08:11,320
operating system and its really targeted

00:08:09,669 --> 00:08:13,240
adjust the things are up that are common

00:08:11,320 --> 00:08:15,490
across MCU so we don't bother with for

00:08:13,240 --> 00:08:17,320
example adcs we don't yeah they're

00:08:15,490 --> 00:08:20,050
really really complicated and they're

00:08:17,320 --> 00:08:21,340
really specific to MCU vendor on top of

00:08:20,050 --> 00:08:23,710
the hell what we've done is layered or

00:08:21,340 --> 00:08:26,050
drivers infrastructure so for kind of

00:08:23,710 --> 00:08:28,000
standard things you can use the hell so

00:08:26,050 --> 00:08:30,910
if you're talking to flash chips for

00:08:28,000 --> 00:08:33,640
example that's a driver that then talks

00:08:30,910 --> 00:08:35,200
through the how spy interface or could

00:08:33,640 --> 00:08:35,760
talk natively to the processor or any

00:08:35,200 --> 00:08:37,320
other

00:08:35,760 --> 00:08:39,540
interfaces so we have a driver's

00:08:37,320 --> 00:08:41,640
interface on top of that that's where we

00:08:39,540 --> 00:08:44,160
tie in all of our power management so

00:08:41,640 --> 00:08:47,670
it's a ticklish our toss with sleep

00:08:44,160 --> 00:08:50,160
support on top of that stats and logging

00:08:47,670 --> 00:08:51,990
infrastructure is kind of one of the

00:08:50,160 --> 00:08:53,940
most unloved things we've seen in on the

00:08:51,990 --> 00:08:55,920
kernels out there and actually one of

00:08:53,940 --> 00:08:57,780
the most important things right so we've

00:08:55,920 --> 00:09:00,000
spent a lot of time really focusing on

00:08:57,780 --> 00:09:01,560
if you have a product out there how can

00:09:00,000 --> 00:09:04,260
you go and how can you debug that

00:09:01,560 --> 00:09:06,330
product right how can you add scale see

00:09:04,260 --> 00:09:08,550
issues that are in the field you know

00:09:06,330 --> 00:09:11,610
we've had issues in previous lifetimes

00:09:08,550 --> 00:09:13,650
of products that for example the radio

00:09:11,610 --> 00:09:15,960
performance was worse on a specific

00:09:13,650 --> 00:09:18,270
version of that product because traces

00:09:15,960 --> 00:09:21,030
were at bird low enough when talking to

00:09:18,270 --> 00:09:24,870
the flash and so radial performance was

00:09:21,030 --> 00:09:26,700
20 DB less just on the specifics Q of

00:09:24,870 --> 00:09:29,070
the specific manufacturing product and

00:09:26,700 --> 00:09:30,300
only when we read from flash and that

00:09:29,070 --> 00:09:32,100
had a large impact on network

00:09:30,300 --> 00:09:33,900
performance if you don't have those

00:09:32,100 --> 00:09:35,850
statistics and that logging throughout

00:09:33,900 --> 00:09:37,350
your code and that isn't done in a way

00:09:35,850 --> 00:09:40,080
that's code and memory efficient and

00:09:37,350 --> 00:09:42,810
configurable it allows you to not count

00:09:40,080 --> 00:09:45,150
certain statistics or to compile out

00:09:42,810 --> 00:09:47,340
statistic names even production images

00:09:45,150 --> 00:09:48,990
if you don't have that inherit then it's

00:09:47,340 --> 00:09:51,090
really hard to debug these products out

00:09:48,990 --> 00:09:54,810
in the field and then it's kind of

00:09:51,090 --> 00:09:57,420
console shell config an upgrade and then

00:09:54,810 --> 00:09:58,410
where we really kind of tie in again to

00:09:57,420 --> 00:10:00,690
providing something that's

00:09:58,410 --> 00:10:03,120
differentiated is in the networking

00:10:00,690 --> 00:10:05,100
stacks themselves and specifically our

00:10:03,120 --> 00:10:07,740
focus and our expertise is in the

00:10:05,100 --> 00:10:09,270
wireless networking stacks so we think

00:10:07,740 --> 00:10:11,430
you know there's a lot of work that

00:10:09,270 --> 00:10:13,920
needs to be done to improve embedded I

00:10:11,430 --> 00:10:15,990
pieced acts as an example and we're

00:10:13,920 --> 00:10:18,330
going to probably just glide on other

00:10:15,990 --> 00:10:21,840
people's work there we integrate el whip

00:10:18,330 --> 00:10:24,120
we like out lip it's kind of fully

00:10:21,840 --> 00:10:26,550
complete has ipv6 support has ipv4

00:10:24,120 --> 00:10:28,620
support but where we think there's a lot

00:10:26,550 --> 00:10:30,240
of opportunity for improvement is in how

00:10:28,620 --> 00:10:32,610
you manage the wireless side of these

00:10:30,240 --> 00:10:34,260
stacks and that also ties into a lot of

00:10:32,610 --> 00:10:36,210
the problems we see on these

00:10:34,260 --> 00:10:38,310
microcontrollers where the wireless

00:10:36,210 --> 00:10:40,650
portions of those stacks are pre

00:10:38,310 --> 00:10:43,020
compiled binaries that are completely

00:10:40,650 --> 00:10:44,880
opaque to the user and so it's our goal

00:10:43,020 --> 00:10:46,320
to make those Wireless stacks completely

00:10:44,880 --> 00:10:50,019
open

00:10:46,320 --> 00:10:52,390
so in terms of context and this is the

00:10:50,019 --> 00:10:54,760
community-driven pitch I'll jump over it

00:10:52,390 --> 00:10:58,420
home because I know people talk about it

00:10:54,760 --> 00:10:59,980
a little too much but just a quick note

00:10:58,420 --> 00:11:01,360
on where we chose to build this effort

00:10:59,980 --> 00:11:03,610
that we chose to build it in the apache

00:11:01,360 --> 00:11:04,959
software foundation so for those of you

00:11:03,610 --> 00:11:07,480
who don't know what the apache software

00:11:04,959 --> 00:11:09,370
foundation is it's the foundation behind

00:11:07,480 --> 00:11:13,930
a lot of the web infrastructure that

00:11:09,370 --> 00:11:16,390
came out so it started in 1994 Jeff can

00:11:13,930 --> 00:11:19,029
correct me there if I missed it but was

00:11:16,390 --> 00:11:21,310
officially incorporated in 1999 and the

00:11:19,029 --> 00:11:23,860
idea was at the time everybody was

00:11:21,310 --> 00:11:24,959
building their own web server and so

00:11:23,860 --> 00:11:26,920
wouldn't it be better for

00:11:24,959 --> 00:11:29,110
interoperability on the internet if

00:11:26,920 --> 00:11:31,060
there was a common open source web

00:11:29,110 --> 00:11:32,470
server and so that became the Apache web

00:11:31,060 --> 00:11:35,410
server which is the number one web

00:11:32,470 --> 00:11:37,660
server that everybody runs based upon

00:11:35,410 --> 00:11:39,610
the principles of the developers who did

00:11:37,660 --> 00:11:41,740
that they decided to create a non-profit

00:11:39,610 --> 00:11:44,050
foundation that help keep other people

00:11:41,740 --> 00:11:47,920
run community-driven open-source efforts

00:11:44,050 --> 00:11:50,380
so what community driven is that it's

00:11:47,920 --> 00:11:52,360
mara mara cratic and you don't have to

00:11:50,380 --> 00:11:53,980
pay anything to have control over the

00:11:52,360 --> 00:11:56,470
project so it's completely free to

00:11:53,980 --> 00:11:59,589
contribute you can come to our website

00:11:56,470 --> 00:12:01,120
download our code and submit patches but

00:11:59,589 --> 00:12:03,610
the other side of that is it's also

00:12:01,120 --> 00:12:06,399
self-governing by the contributors so no

00:12:03,610 --> 00:12:08,709
one no corporation owns the effort or

00:12:06,399 --> 00:12:10,089
has any control over the effort it's the

00:12:08,709 --> 00:12:12,100
individuals who contribute to the

00:12:10,089 --> 00:12:13,420
project so the way you become a

00:12:12,100 --> 00:12:15,550
contributor and the way you get a vote

00:12:13,420 --> 00:12:18,850
in the direction of our project is you

00:12:15,550 --> 00:12:20,860
submit patches if you submit patches you

00:12:18,850 --> 00:12:22,959
will become a committer and if you're a

00:12:20,860 --> 00:12:25,200
committer you vote on the strategic

00:12:22,959 --> 00:12:27,760
decisions in the project and your vote

00:12:25,200 --> 00:12:29,890
counts just as much as by my vote or any

00:12:27,760 --> 00:12:32,949
of the other committers votes and so

00:12:29,890 --> 00:12:35,920
it's really the idea is a project of

00:12:32,949 --> 00:12:37,029
individuals and contributors and you

00:12:35,920 --> 00:12:39,070
know you look at some of the largest

00:12:37,029 --> 00:12:40,899
pieces of infrastructure Hadoop most of

00:12:39,070 --> 00:12:43,839
the big data stuff the Apache web server

00:12:40,899 --> 00:12:45,940
they've all been built this way and the

00:12:43,839 --> 00:12:48,100
reason that this works is it is it's not

00:12:45,940 --> 00:12:49,570
a temporary alliance of people its

00:12:48,100 --> 00:12:51,100
individual contributors who are

00:12:49,570 --> 00:12:54,570
passionate about the project who carry

00:12:51,100 --> 00:12:57,120
it forward so

00:12:54,570 --> 00:12:58,290
so I'm gonna now just kind of talk a

00:12:57,120 --> 00:12:59,700
little bit by the way feel free to

00:12:58,290 --> 00:13:01,620
interrupt if you have questions with Sir

00:12:59,700 --> 00:13:03,930
comments but talk a little bit about

00:13:01,620 --> 00:13:07,470
some of the features of the Apache minut

00:13:03,930 --> 00:13:08,940
system this is by far not maybe our

00:13:07,470 --> 00:13:11,010
major feature but it is something that

00:13:08,940 --> 00:13:12,180
under underpins everything else we've

00:13:11,010 --> 00:13:14,730
developed so I'm going to go a little

00:13:12,180 --> 00:13:17,460
bit more into it so kind of the main

00:13:14,730 --> 00:13:19,230
part about new that ties everything

00:13:17,460 --> 00:13:21,540
together as we built our own build and

00:13:19,230 --> 00:13:23,760
package management system so very

00:13:21,540 --> 00:13:26,250
similar to yada that was in them bed for

00:13:23,760 --> 00:13:27,960
a while our thought is if you're going

00:13:26,250 --> 00:13:30,570
to go and develop and manage these large

00:13:27,960 --> 00:13:32,970
projects you want to have a stable core

00:13:30,570 --> 00:13:34,440
operating system and then you want to be

00:13:32,970 --> 00:13:36,090
able to redistribute third-party

00:13:34,440 --> 00:13:38,010
libraries and link them all together and

00:13:36,090 --> 00:13:41,040
you want to be able to manage that and

00:13:38,010 --> 00:13:42,780
that becomes very complex so a typical

00:13:41,040 --> 00:13:46,020
use case for this was that silver spring

00:13:42,780 --> 00:13:48,360
networks where we had meters

00:13:46,020 --> 00:13:50,820
streetlights about 20 30 different

00:13:48,360 --> 00:13:52,440
hardware skews but we had a unified

00:13:50,820 --> 00:13:54,150
operating system that we had built and

00:13:52,440 --> 00:13:55,860
you see this with a lot of people we

00:13:54,150 --> 00:13:58,350
wanted to maintain our code base in

00:13:55,860 --> 00:13:59,820
parallel for the that have

00:13:58,350 --> 00:14:01,380
customizations for each of the different

00:13:59,820 --> 00:14:02,580
products we develop so we wanted to have

00:14:01,380 --> 00:14:03,930
slightly different things for the

00:14:02,580 --> 00:14:06,180
streetlights than we did for the meters

00:14:03,930 --> 00:14:08,280
and so what we have is a core operating

00:14:06,180 --> 00:14:10,500
system component and then individual

00:14:08,280 --> 00:14:12,120
code base is based upon that and so nude

00:14:10,500 --> 00:14:14,280
allows you to do that and it allows you

00:14:12,120 --> 00:14:15,720
to compose your operating system picking

00:14:14,280 --> 00:14:17,940
only the pieces you want for a given

00:14:15,720 --> 00:14:21,150
project but still maintaining separate

00:14:17,940 --> 00:14:22,680
code bases and the other thing that Newt

00:14:21,150 --> 00:14:24,600
does for us is so that's the package

00:14:22,680 --> 00:14:26,370
management side we've then tied build

00:14:24,600 --> 00:14:27,750
into that so that when you take your

00:14:26,370 --> 00:14:30,120
development environment you go to

00:14:27,750 --> 00:14:33,570
production you can use the same tool to

00:14:30,120 --> 00:14:35,160
do both of those so as an example if you

00:14:33,570 --> 00:14:37,320
compile your operating system and

00:14:35,160 --> 00:14:39,510
compile your application with new you

00:14:37,320 --> 00:14:41,760
can then take that same code base that

00:14:39,510 --> 00:14:43,320
you could load it on a debugger and you

00:14:41,760 --> 00:14:45,630
can automatically create a flash image

00:14:43,320 --> 00:14:47,910
with for that and you can automatically

00:14:45,630 --> 00:14:49,380
create form or upload images so it's the

00:14:47,910 --> 00:14:52,530
same build tool that takes you from

00:14:49,380 --> 00:14:54,720
debug to production the bill to will

00:14:52,530 --> 00:14:56,850
automatically signs images for you it

00:14:54,720 --> 00:14:58,470
also maintains all of the symbol

00:14:56,850 --> 00:15:01,530
information and all of the get history

00:14:58,470 --> 00:15:04,980
for every build that you have so you

00:15:01,530 --> 00:15:07,950
have the entire history of that product

00:15:04,980 --> 00:15:08,310
through build artifacts as well as debug

00:15:07,950 --> 00:15:10,230
inferred

00:15:08,310 --> 00:15:11,850
action versions so when you go and you

00:15:10,230 --> 00:15:14,279
upgrade images in the field all of

00:15:11,850 --> 00:15:15,810
that's automatically saved for you so

00:15:14,279 --> 00:15:18,420
the idea is to help you maintain large

00:15:15,810 --> 00:15:23,120
code bases and to help you to move the

00:15:18,420 --> 00:15:27,839
bug to production in one seamless way a

00:15:23,120 --> 00:15:29,370
few other highlights so one of the core

00:15:27,839 --> 00:15:30,570
elements of the operating system that

00:15:29,370 --> 00:15:34,589
we've developed is cross-platform

00:15:30,570 --> 00:15:37,320
support we have spent an inordinate

00:15:34,589 --> 00:15:40,140
amount of time on this we really wish

00:15:37,320 --> 00:15:41,640
that it was not the job of the operating

00:15:40,140 --> 00:15:43,860
system and it was outsourced a little

00:15:41,640 --> 00:15:45,600
bit but you know how do you come up with

00:15:43,860 --> 00:15:48,570
a very good how that you can implement

00:15:45,600 --> 00:15:50,880
reliably across platforms and how do you

00:15:48,570 --> 00:15:52,950
do that in the way that's very efficient

00:15:50,880 --> 00:15:54,720
for product developers right so how do

00:15:52,950 --> 00:15:56,880
you abstract a spy interface you don't

00:15:54,720 --> 00:15:58,710
want it to be too high level you want to

00:15:56,880 --> 00:16:01,680
be able to run it how do you abstract a

00:15:58,710 --> 00:16:03,480
UART interface do you use dma how does

00:16:01,680 --> 00:16:05,820
DMA look different across all of these

00:16:03,480 --> 00:16:07,890
platforms so we've done a lot of work in

00:16:05,820 --> 00:16:10,260
really getting a how that's both

00:16:07,890 --> 00:16:13,050
efficient and portable across multiple

00:16:10,260 --> 00:16:14,670
platforms we've also focused on the

00:16:13,050 --> 00:16:17,550
build and package management system here

00:16:14,670 --> 00:16:20,250
which ties into how we layout code so as

00:16:17,550 --> 00:16:22,800
an example on every build that we create

00:16:20,250 --> 00:16:24,420
there's both an application that the two

00:16:22,800 --> 00:16:26,460
targets in the build are the application

00:16:24,420 --> 00:16:27,900
and the board support package the build

00:16:26,460 --> 00:16:31,020
and package management tool itself

00:16:27,900 --> 00:16:33,150
understands dependencies so the the

00:16:31,020 --> 00:16:35,490
board support package typically relies

00:16:33,150 --> 00:16:37,680
on an MCU support package which is a

00:16:35,490 --> 00:16:39,960
full implementation of the how for that

00:16:37,680 --> 00:16:41,880
board support package we've built in

00:16:39,960 --> 00:16:43,440
capabilities and all of that so that we

00:16:41,880 --> 00:16:47,100
can really develop a system that works

00:16:43,440 --> 00:16:48,570
across platforms and of then of course

00:16:47,100 --> 00:16:50,580
there's all the little details that we

00:16:48,570 --> 00:16:52,200
don't have no right like a dcs and other

00:16:50,580 --> 00:16:53,610
things where we just give direct access

00:16:52,200 --> 00:16:56,100
to the chip so we've kind of made a

00:16:53,610 --> 00:16:58,490
bunch of trade-offs their software

00:16:56,100 --> 00:16:58,490
upgrade

00:17:02,080 --> 00:17:06,589
so those are kind of some of the key

00:17:04,280 --> 00:17:07,970
areas for the operating system that

00:17:06,589 --> 00:17:10,250
we're we've really split put in a lot of

00:17:07,970 --> 00:17:12,949
thought to getting these api's tied down

00:17:10,250 --> 00:17:15,319
right to dig a little deeper into one of

00:17:12,949 --> 00:17:17,030
them so just to take security as an

00:17:15,319 --> 00:17:19,339
example of one of the areas where we

00:17:17,030 --> 00:17:21,380
thought so we've gone all the way

00:17:19,339 --> 00:17:24,140
through the product life cycle starting

00:17:21,380 --> 00:17:25,699
from provisioning so as an example most

00:17:24,140 --> 00:17:28,910
chips that you'll look in the arm-based

00:17:25,699 --> 00:17:30,980
world will have some probably Intel as

00:17:28,910 --> 00:17:33,470
well they have some unique identifiers

00:17:30,980 --> 00:17:35,030
that comes from silicon if not in order

00:17:33,470 --> 00:17:37,309
to do device provisioning within a

00:17:35,030 --> 00:17:38,990
manufacturing environment you need to

00:17:37,309 --> 00:17:41,390
have a unique identifier for that device

00:17:38,990 --> 00:17:43,130
so that when you develop a management

00:17:41,390 --> 00:17:45,080
system in the cloud you can actually

00:17:43,130 --> 00:17:47,720
come and understand what that device is

00:17:45,080 --> 00:17:49,340
doing so we have AP is in our board

00:17:47,720 --> 00:17:51,679
support packages and in our MC you

00:17:49,340 --> 00:17:53,240
support packages that actually providing

00:17:51,679 --> 00:17:55,550
that allow you to hook into the

00:17:53,240 --> 00:17:58,550
silicon's unique ability to provide you

00:17:55,550 --> 00:18:01,210
a unique ID we support generating a

00:17:58,550 --> 00:18:03,890
private key from that information and

00:18:01,210 --> 00:18:06,050
passing the public component out to a

00:18:03,890 --> 00:18:08,630
manufacturing station so that when a

00:18:06,050 --> 00:18:10,910
device comes and tries to get on the

00:18:08,630 --> 00:18:12,800
network all of that is tied together and

00:18:10,910 --> 00:18:14,660
that's built into the API as we've built

00:18:12,800 --> 00:18:16,820
because provisioning is key to pretty

00:18:14,660 --> 00:18:19,940
much anybody who's do with developing an

00:18:16,820 --> 00:18:22,429
IOT connected product in terms of

00:18:19,940 --> 00:18:25,670
upgrading the bootloader does not have

00:18:22,429 --> 00:18:28,970
an unsecure option so every image that

00:18:25,670 --> 00:18:31,910
you download to a device is secure it

00:18:28,970 --> 00:18:34,429
just uses a development key when you're

00:18:31,910 --> 00:18:36,920
generating the image so if you use Newt

00:18:34,429 --> 00:18:38,660
to manage your product you are already

00:18:36,920 --> 00:18:41,420
using a secure boot loader there's no

00:18:38,660 --> 00:18:43,820
secure boot loader option in terms of

00:18:41,420 --> 00:18:46,760
communication we support all of the

00:18:43,820 --> 00:18:49,010
communication security protocols so we

00:18:46,760 --> 00:18:50,750
have DTLS support but we also support

00:18:49,010 --> 00:18:53,059
all of Bluetooth security from

00:18:50,750 --> 00:18:57,950
accumulation perspective the are back

00:18:53,059 --> 00:18:59,360
there is absolute we definitely believe

00:18:57,950 --> 00:19:01,790
in having role based access control

00:18:59,360 --> 00:19:04,260
security for all of our management that

00:19:01,790 --> 00:19:06,460
has not been integrated

00:19:04,260 --> 00:19:09,220
you know one of the things that's always

00:19:06,460 --> 00:19:11,440
a pain early on nobody encrypts data on

00:19:09,220 --> 00:19:13,090
flash and then when you go and you

00:19:11,440 --> 00:19:14,380
actually deploy a product and you start

00:19:13,090 --> 00:19:16,540
to have to sell to government or you

00:19:14,380 --> 00:19:18,490
start to have privacy concerns almost

00:19:16,540 --> 00:19:22,210
everybody wants to encrypt data on flash

00:19:18,490 --> 00:19:24,340
and so we have options in our flash file

00:19:22,210 --> 00:19:26,140
system as well as our circular buffering

00:19:24,340 --> 00:19:28,330
mechanisms and config mechanisms to

00:19:26,140 --> 00:19:30,730
support encrypted storage of data and

00:19:28,330 --> 00:19:32,260
that's all built into the system for you

00:19:30,730 --> 00:19:34,150
so if you start out and you don't want

00:19:32,260 --> 00:19:37,600
to use it and then you want to switch to

00:19:34,150 --> 00:19:40,780
it it's a seamless transition and then

00:19:37,600 --> 00:19:42,340
we are ppm and smart card aware so if we

00:19:40,780 --> 00:19:44,170
want to come up and validates and data

00:19:42,340 --> 00:19:48,550
we want to sign that that's all abstract

00:19:44,170 --> 00:19:51,100
'add from a connectivity player apache

00:19:48,550 --> 00:19:53,410
my new has kind of we've made some we as

00:19:51,100 --> 00:19:56,170
runt I'll caveat this with runtimes view

00:19:53,410 --> 00:19:58,090
because road maps are really there about

00:19:56,170 --> 00:20:00,040
the community I can't speak for the

00:19:58,090 --> 00:20:01,900
Apache my new project but I can speak

00:20:00,040 --> 00:20:04,510
for what runtime is working on in Apache

00:20:01,900 --> 00:20:07,120
my new and the two transports we started

00:20:04,510 --> 00:20:08,170
with where Bluetooth and Wi-Fi we took

00:20:07,120 --> 00:20:10,360
we think there's going to be a lot of

00:20:08,170 --> 00:20:12,610
transports and wireless transports are

00:20:10,360 --> 00:20:13,720
going to dictate i/o two deployments but

00:20:12,610 --> 00:20:15,910
we started with Bluetooth and Wi-Fi

00:20:13,720 --> 00:20:17,890
because they were standards and they had

00:20:15,910 --> 00:20:19,990
interoperability processes around them

00:20:17,890 --> 00:20:21,850
that were way more robust than anything

00:20:19,990 --> 00:20:24,100
else we saw so when you look at

00:20:21,850 --> 00:20:25,780
bluetooth it truly is interoperable

00:20:24,100 --> 00:20:27,730
cross chip vendors and the same applies

00:20:25,780 --> 00:20:30,100
to Wi-Fi whereas if you look at some of

00:20:27,730 --> 00:20:31,720
the low-power wide area standards that

00:20:30,100 --> 00:20:33,340
are out there today you don't really

00:20:31,720 --> 00:20:35,140
have that interoperability framework

00:20:33,340 --> 00:20:37,180
there so well we think they're going to

00:20:35,140 --> 00:20:39,490
be really interesting and exciting we

00:20:37,180 --> 00:20:42,580
didn't focus on them first so I'm

00:20:39,490 --> 00:20:44,260
bluetooth we support both the host kind

00:20:42,580 --> 00:20:46,420
of controller so we go down and we

00:20:44,260 --> 00:20:49,090
completely so the first chip we support

00:20:46,420 --> 00:20:50,800
it was the Nordic NRF 52 we completely

00:20:49,090 --> 00:20:52,510
replaced the soft device on that ship

00:20:50,800 --> 00:20:53,980
and provide all of the functionality

00:20:52,510 --> 00:20:56,590
that you would get with the soft device

00:20:53,980 --> 00:20:59,080
but we do that in a portable fashion so

00:20:56,590 --> 00:21:02,740
you can easily move to from a Nordic

00:20:59,080 --> 00:21:04,900
chipset to a nxp chipset as an example

00:21:02,740 --> 00:21:06,670
and when you move none of your api's

00:21:04,900 --> 00:21:07,990
have to change and you don't have to

00:21:06,670 --> 00:21:08,820
re-implement your blue Bluetooth stack

00:21:07,990 --> 00:21:10,019
you don't have to

00:21:08,820 --> 00:21:11,990
implement your software upgrade

00:21:10,019 --> 00:21:14,700
mechanisms all of that comes in my new

00:21:11,990 --> 00:21:18,529
and so we support all the way up there

00:21:14,700 --> 00:21:21,720
on top of that we currently run oh I see

00:21:18,529 --> 00:21:25,019
so the idea is to run we run OIC

00:21:21,720 --> 00:21:27,330
natively on top of basically co-op on

00:21:25,019 --> 00:21:29,580
top of gap with OIC on top of that and

00:21:27,330 --> 00:21:31,950
we provide our management protocol using

00:21:29,580 --> 00:21:33,360
oh I see we chose OIC because it was a

00:21:31,950 --> 00:21:37,500
standard protocol and it was

00:21:33,360 --> 00:21:40,320
surprisingly saying JSON encoded data or

00:21:37,500 --> 00:21:42,360
C bore and it allows you to have the

00:21:40,320 --> 00:21:44,490
same framework for both management and

00:21:42,360 --> 00:21:46,860
application communication so we really

00:21:44,490 --> 00:21:49,769
like that about it we also support Wi-Fi

00:21:46,860 --> 00:21:52,230
support the first chips that we support

00:21:49,769 --> 00:21:54,450
is the wink 1500 but we're continuing to

00:21:52,230 --> 00:21:56,730
evolve our support beyond there and that

00:21:54,450 --> 00:21:59,909
really is where we're targeting on one

00:21:56,730 --> 00:22:03,929
are 10 f so right now the last release

00:21:59,909 --> 00:22:06,029
we had was 09 we are mid up to end of

00:22:03,929 --> 00:22:09,809
October we are launching with our 10

00:22:06,029 --> 00:22:11,700
release when you look at that kind of

00:22:09,809 --> 00:22:14,940
release what that means to us is full

00:22:11,700 --> 00:22:16,710
Wi-Fi support API stability and we've

00:22:14,940 --> 00:22:19,950
already been running minut in production

00:22:16,710 --> 00:22:22,139
with customers for about six months now

00:22:19,950 --> 00:22:23,879
so we've hacked it you no wonder that

00:22:22,139 --> 00:22:26,340
all of the operating systems are fairly

00:22:23,879 --> 00:22:28,169
nascent in this space but we feel pretty

00:22:26,340 --> 00:22:30,600
confident given that we've had six

00:22:28,169 --> 00:22:32,429
months of production on the operating

00:22:30,600 --> 00:22:35,220
system and a whole bunch of api testing

00:22:32,429 --> 00:22:36,960
that it will work pretty well beyond

00:22:35,220 --> 00:22:38,850
that we are committed to supporting

00:22:36,960 --> 00:22:40,889
bluetooth we think it's i think most

00:22:38,850 --> 00:22:43,950
people up here really like bluetooth we

00:22:40,889 --> 00:22:47,730
really like Bluetooth too we are going

00:22:43,950 --> 00:22:50,789
to support Bluetooth 50 50 really what's

00:22:47,730 --> 00:22:52,950
exciting to me about 50 is the fact that

00:22:50,789 --> 00:22:57,090
so the challenge with Bluetooth today is

00:22:52,950 --> 00:22:59,580
the small packet sizes specifically both

00:22:57,090 --> 00:23:00,690
in connections so it's 27 bytes in a

00:22:59,580 --> 00:23:02,759
connection but it specifically

00:23:00,690 --> 00:23:04,950
advertising packets which are essential

00:23:02,759 --> 00:23:06,840
to developing a mesh so when you have

00:23:04,950 --> 00:23:09,299
small advertising packets 23 5 packets

00:23:06,840 --> 00:23:11,549
you can actually broadcast out routing

00:23:09,299 --> 00:23:14,720
information or anything without having a

00:23:11,549 --> 00:23:16,800
connection to a device with Bluetooth 5

00:23:14,720 --> 00:23:20,550
advertising packets are moving from

00:23:16,800 --> 00:23:22,500
20-23 or 27 bites all the way up to 290

00:23:20,550 --> 00:23:25,560
bites which then allows you to really

00:23:22,500 --> 00:23:28,140
run mesh on top of Bluetooth 5 so we're

00:23:25,560 --> 00:23:29,460
really excited about blue 25 we plan on

00:23:28,140 --> 00:23:31,950
supporting a lot of the low-power white

00:23:29,460 --> 00:23:34,230
area standards so Laura is one of them

00:23:31,950 --> 00:23:35,790
but we're looking at also other look sub

00:23:34,230 --> 00:23:37,980
gigahertz mesh technologies and we think

00:23:35,790 --> 00:23:40,050
that's an area where good wireless stack

00:23:37,980 --> 00:23:42,510
support can really help unlock it and

00:23:40,050 --> 00:23:45,210
then there's of course all of the new

00:23:42,510 --> 00:23:47,760
3gpp stuff I think most notably there is

00:23:45,210 --> 00:23:50,100
envy IOT which a lot of the cell

00:23:47,760 --> 00:23:51,630
carriers are starting to deploy and then

00:23:50,100 --> 00:23:53,280
be a to use essentially for those who

00:23:51,630 --> 00:23:56,460
don't know it it's Laura and licensed

00:23:53,280 --> 00:23:59,310
spectrum and a lot of the problems with

00:23:56,460 --> 00:24:00,750
Laura in real deployments is that you

00:23:59,310 --> 00:24:01,920
know it's great to have a star

00:24:00,750 --> 00:24:05,220
architecture for our battery-powered

00:24:01,920 --> 00:24:06,780
devices because you can transmit really

00:24:05,220 --> 00:24:08,670
far and they know what channel to be on

00:24:06,780 --> 00:24:10,580
but if you do that in a non-licensed

00:24:08,670 --> 00:24:13,110
spectrum there's a very high noise floor

00:24:10,580 --> 00:24:15,600
so as you have other deployments around

00:24:13,110 --> 00:24:18,390
you sub gigahertz doesn't work as well

00:24:15,600 --> 00:24:20,700
for them whereas a mash architecture

00:24:18,390 --> 00:24:22,920
works a lot better and unlicensed so

00:24:20,700 --> 00:24:24,630
having envio IOT and license we think is

00:24:22,920 --> 00:24:26,250
a really interesting technology because

00:24:24,630 --> 00:24:28,380
it'll be great for things like that

00:24:26,250 --> 00:24:31,530
battery-powered devices that need long

00:24:28,380 --> 00:24:33,120
areas to go over so just a few

00:24:31,530 --> 00:24:34,620
highlights from the networking stack so

00:24:33,120 --> 00:24:35,910
I think the first tech if you're going

00:24:34,620 --> 00:24:37,290
to go and look at our effort and want to

00:24:35,910 --> 00:24:38,790
judge the code I think the first stack

00:24:37,290 --> 00:24:40,950
to look at is our Bluetooth networking

00:24:38,790 --> 00:24:43,800
stack we have pretty good performance

00:24:40,950 --> 00:24:45,840
results with it so we suppose central

00:24:43,800 --> 00:24:47,880
and peripheral modes for Bluetooth we

00:24:45,840 --> 00:24:50,100
also support up to 32 simultaneous

00:24:47,880 --> 00:24:52,440
connections and this is really an area

00:24:50,100 --> 00:24:54,060
where having good wireless stack support

00:24:52,440 --> 00:24:56,220
unlocks new applications so the first

00:24:54,060 --> 00:24:57,690
people to adopt our OS when it was you

00:24:56,220 --> 00:25:00,630
know barely working and constantly

00:24:57,690 --> 00:25:02,880
changing were locked people right so

00:25:00,630 --> 00:25:04,110
when you're developing smart locks what

00:25:02,880 --> 00:25:06,270
you want to do is you want to be able to

00:25:04,110 --> 00:25:08,190
scan for phones that are coming near a

00:25:06,270 --> 00:25:09,930
door right you want to be able to see

00:25:08,190 --> 00:25:11,610
those phones and see whether they're

00:25:09,930 --> 00:25:12,810
near enough to you that you should

00:25:11,610 --> 00:25:15,480
unlock the door and whether they're a

00:25:12,810 --> 00:25:16,950
phone you care about the Nordic stack

00:25:15,480 --> 00:25:19,020
that was shipped i think was three

00:25:16,950 --> 00:25:20,090
connections in central mode and one

00:25:19,020 --> 00:25:22,880
connection in peripheral

00:25:20,090 --> 00:25:24,830
which meant that you were severely

00:25:22,880 --> 00:25:27,860
limited and how many devices you could

00:25:24,830 --> 00:25:29,960
connect to but and this wasn't because

00:25:27,860 --> 00:25:31,580
Nordic was bad at writing drivers it was

00:25:29,960 --> 00:25:34,159
because they shipped a precompiled

00:25:31,580 --> 00:25:38,179
binary that had to work for all of their

00:25:34,159 --> 00:25:39,919
users right so you couldn't just if you

00:25:38,179 --> 00:25:41,960
made 32 connections you'd have to use

00:25:39,919 --> 00:25:44,330
all of that memory and somebody who's

00:25:41,960 --> 00:25:48,140
developing a small peripheral doesn't

00:25:44,330 --> 00:25:50,480
care about having to go and connect to

00:25:48,140 --> 00:25:53,029
30 devices but somebody who's connecting

00:25:50,480 --> 00:25:55,039
to a lock really does care and so having

00:25:53,029 --> 00:25:57,440
an open source option there allows

00:25:55,039 --> 00:25:59,630
people to then go and support more

00:25:57,440 --> 00:26:02,029
connections we also support combined

00:25:59,630 --> 00:26:04,010
hosts house and controller as well as

00:26:02,029 --> 00:26:05,690
host only in controller only mode so

00:26:04,010 --> 00:26:09,200
another very common place where uses in

00:26:05,690 --> 00:26:11,630
bluesy actually the Intel folks went and

00:26:09,200 --> 00:26:13,909
poured it my new to have support a

00:26:11,630 --> 00:26:19,190
controller only implementation and so

00:26:13,909 --> 00:26:20,600
we're run frequently and then just the

00:26:19,190 --> 00:26:22,850
kind of another thing there is because

00:26:20,600 --> 00:26:24,980
our stack is configurable it's about

00:26:22,850 --> 00:26:27,080
forty percent less code than the soft

00:26:24,980 --> 00:26:29,000
device when you run it in peripheral

00:26:27,080 --> 00:26:30,740
only mode because we don't need the

00:26:29,000 --> 00:26:32,390
central roles and we don't need to

00:26:30,740 --> 00:26:34,460
enable all of this functionality so it

00:26:32,390 --> 00:26:36,610
gives you fine gate grained control over

00:26:34,460 --> 00:26:39,919
what features you run on the device

00:26:36,610 --> 00:26:42,830
we've recently gone ahead and then added

00:26:39,919 --> 00:26:44,600
Wi-Fi support to my new so this is using

00:26:42,830 --> 00:26:47,510
el whip and then the underlying wireless

00:26:44,600 --> 00:26:49,940
support we have a abstract at interface

00:26:47,510 --> 00:26:51,740
to Wi-Fi supplicants currently it's with

00:26:49,940 --> 00:26:54,620
the link 1500 we're looking to add

00:26:51,740 --> 00:26:56,149
additional support I think runtime we're

00:26:54,620 --> 00:26:58,250
pretty excited about broadcom's chips

00:26:56,149 --> 00:27:01,070
and then some of the media tech stuff

00:26:58,250 --> 00:27:03,950
that is combo so both Bluetooth and

00:27:01,070 --> 00:27:06,620
Wi-Fi but the idea is to abstract all of

00:27:03,950 --> 00:27:08,299
the supplicant interfaces this is if

00:27:06,620 --> 00:27:10,520
people here are more familiar with linux

00:27:08,299 --> 00:27:12,860
linux there's a lot more mode so the

00:27:10,520 --> 00:27:15,260
supplicant can actually be soft in most

00:27:12,860 --> 00:27:16,850
of the MTU environments the supplicant

00:27:15,260 --> 00:27:19,159
comes in a vendor sdk that's on a

00:27:16,850 --> 00:27:19,680
separate chipset so you don't actually

00:27:19,159 --> 00:27:22,410
have

00:27:19,680 --> 00:27:24,090
to implement a full supplicant we've

00:27:22,410 --> 00:27:27,330
integrated I'll lip there and we're

00:27:24,090 --> 00:27:30,210
looking at others in in terms of

00:27:27,330 --> 00:27:31,980
hardware support the kind of these were

00:27:30,210 --> 00:27:33,720
the first three platforms that we really

00:27:31,980 --> 00:27:36,180
decided to develop our operating system

00:27:33,720 --> 00:27:38,490
so the first use case we looked at was

00:27:36,180 --> 00:27:41,040
really developing it for the Nordic NRF

00:27:38,490 --> 00:27:42,540
51 and 52 right and at least in my mind

00:27:41,040 --> 00:27:44,610
and I think other people's mind it was

00:27:42,540 --> 00:27:46,740
really how do we develop an open-source

00:27:44,610 --> 00:27:48,780
softest replacement right because the

00:27:46,740 --> 00:27:50,310
real business value of taking this

00:27:48,780 --> 00:27:51,750
operating system when you start to talk

00:27:50,310 --> 00:27:54,240
to people kind of outside of the

00:27:51,750 --> 00:27:58,320
engineering world is that you can now

00:27:54,240 --> 00:28:00,570
have a single operating system that can

00:27:58,320 --> 00:28:02,160
run on multiple chipsets and you can

00:28:00,570 --> 00:28:04,950
really then look at price performance

00:28:02,160 --> 00:28:08,520
between the various chip vendors in

00:28:04,950 --> 00:28:10,710
terms of the operating system and so our

00:28:08,520 --> 00:28:12,660
thought was let's develop a real kind of

00:28:10,710 --> 00:28:14,310
replacement for the soft device and so

00:28:12,660 --> 00:28:16,590
we targeted the Nordic platform to do

00:28:14,310 --> 00:28:17,970
that but at the same time when you're

00:28:16,590 --> 00:28:19,470
developing an operating system you

00:28:17,970 --> 00:28:21,090
really need to have support multiple

00:28:19,470 --> 00:28:23,370
platforms and able to in order to make

00:28:21,090 --> 00:28:25,650
things like your how work cleanly right

00:28:23,370 --> 00:28:27,390
because if we adjust supported Nordic we

00:28:25,650 --> 00:28:30,030
would never have seen all of the

00:28:27,390 --> 00:28:32,760
intricacies of the ADC on the STM and

00:28:30,030 --> 00:28:35,490
Arduino on the atmel platforms so we

00:28:32,760 --> 00:28:36,900
supported those three platforms we've

00:28:35,490 --> 00:28:39,060
seen a lot of usage on the SD micro

00:28:36,900 --> 00:28:42,720
platforms they're very popular for Wi-Fi

00:28:39,060 --> 00:28:45,420
they also are a very popular chip to go

00:28:42,720 --> 00:28:47,610
and do DSP offload on them so we see a

00:28:45,420 --> 00:28:49,500
lot of people who use the Nordic chip as

00:28:47,610 --> 00:28:52,230
a host processor and then when they have

00:28:49,500 --> 00:28:54,120
to do some sort of ESP or data

00:28:52,230 --> 00:28:56,700
processing they'll wake up an SD micro

00:28:54,120 --> 00:28:58,380
chip and then the at the metal Sam DCM

00:28:56,700 --> 00:29:01,290
l20 ones are very popular in maker

00:28:58,380 --> 00:29:04,350
platforms the sam'l 20 ones have

00:29:01,290 --> 00:29:05,850
fantastic low power support so these are

00:29:04,350 --> 00:29:09,210
the kind of the first three platforms we

00:29:05,850 --> 00:29:10,830
supported post 10 we're really going to

00:29:09,210 --> 00:29:13,200
spend a lot more effort broadening this

00:29:10,830 --> 00:29:15,480
out you know when you're Hal and your

00:29:13,200 --> 00:29:18,480
driver interfaces and your BSP our

00:29:15,480 --> 00:29:21,210
frequently changing supporting a lot of

00:29:18,480 --> 00:29:23,700
platforms is very difficult now that we

00:29:21,210 --> 00:29:27,360
with with our 10 release we're targeting

00:29:23,700 --> 00:29:29,340
API stability once we have API stability

00:29:27,360 --> 00:29:29,700
of the core that's when we're going to

00:29:29,340 --> 00:29:32,460
really

00:29:29,700 --> 00:29:34,950
kind of expand and spend a lot of effort

00:29:32,460 --> 00:29:37,500
expanding this support so kind of post

00:29:34,950 --> 00:29:40,409
one dot o a lot of our efforts are going

00:29:37,500 --> 00:29:42,149
to be focused on improving the IP

00:29:40,409 --> 00:29:44,490
support that's in there and improving

00:29:42,149 --> 00:29:47,039
the number of platforms we support so

00:29:44,490 --> 00:29:49,470
kind of that's the next six to 12 months

00:29:47,039 --> 00:29:51,570
is really rounding out platform support

00:29:49,470 --> 00:29:53,399
but at launch we support all of these we

00:29:51,570 --> 00:29:55,440
support the full set of how drivers IP

00:29:53,399 --> 00:29:57,409
stack Bluetooth stack on all of these

00:29:55,440 --> 00:30:02,100
platforms software upgrade boot loaders

00:29:57,409 --> 00:30:04,529
it's all available and I guess I'm

00:30:02,100 --> 00:30:07,980
running short on time but for more

00:30:04,529 --> 00:30:10,559
information minut apache org come talk

00:30:07,980 --> 00:30:12,389
to me and say hi you're welcome to join

00:30:10,559 --> 00:30:14,880
the development list we're looking for

00:30:12,389 --> 00:30:17,700
contributors everybody's welcome if the

00:30:14,880 --> 00:30:19,039
roadmap I presented here doesn't appeal

00:30:17,700 --> 00:30:21,299
to you and you want to add something

00:30:19,039 --> 00:30:24,269
just join the dev list and we're more

00:30:21,299 --> 00:30:26,399
than happy to take contributions and add

00:30:24,269 --> 00:30:29,130
people to the project so we're really

00:30:26,399 --> 00:30:31,250
kind of open that's it thank you very

00:30:29,130 --> 00:30:31,250
much

00:30:41,430 --> 00:30:43,490

YouTube URL: https://www.youtube.com/watch?v=khTwms9WpoI


