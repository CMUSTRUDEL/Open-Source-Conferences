Title: LAS16-207: Bus scaling QoS
Publication date: 2016-09-30
Playlist: Linaro Connect Las Vegas 2016
Description: 
	LAS16-207: Bus scaling QoS
Speakers: Georgi Djakov
Date: September 27, 2016

★ Session Description ★
System has a lot of interconnect bus that have to be set to provide throughputs to devices of the system. We are working on adding missing pieces to let device set the performance requirements to the performance provider that are interconnect bus.

★ Resources ★
Etherpad: pad.linaro.org/p/las16-207
Presentations & Videos: http://connect.linaro.org/resource/las16/las16-207/

★ Event Details ★
Linaro Connect Las Vegas 2016 – #LAS16
September 26-30, 2016
http://www.linaro.org
http://connect.linaro.org
Captions: 
	00:00:08,630 --> 00:00:17,609
hello everyone thanks for coming to my

00:00:14,759 --> 00:00:25,250
presentation and choosing it over the

00:00:17,609 --> 00:00:31,320
other interesting sessions so my name is

00:00:25,250 --> 00:00:38,010
jerky jackals and I'm doing some kernel

00:00:31,320 --> 00:00:44,460
development work for welcome and the

00:00:38,010 --> 00:00:46,680
title of this talk is scaling eos so

00:00:44,460 --> 00:00:53,480
i'll be speaking about on ship

00:00:46,680 --> 00:00:59,160
interconnects the purpose of this talk

00:00:53,480 --> 00:01:04,680
is to give an overview what onji paint

00:00:59,160 --> 00:01:09,590
connector and to highlight some of the

00:01:04,680 --> 00:01:14,180
current and upcoming work in this area

00:01:09,590 --> 00:01:17,450
which is mostly about providing

00:01:14,180 --> 00:01:22,049
mechanism for controlling this

00:01:17,450 --> 00:01:30,049
interconnect from the linux kernel and

00:01:22,049 --> 00:01:30,049
make use of the benefits they provide so

00:01:33,840 --> 00:01:44,649
here is the agenda so I'll say a few

00:01:39,579 --> 00:01:49,179
words about the challenges of the SOC

00:01:44,649 --> 00:01:52,079
architecture I will talk about the

00:01:49,179 --> 00:01:55,679
history and the evolution of the

00:01:52,079 --> 00:02:01,719
interconnects and explain a bit what

00:01:55,679 --> 00:02:10,450
network-on-chip is so then i'll give an

00:02:01,719 --> 00:02:15,310
overview of the problem we are trying to

00:02:10,450 --> 00:02:20,470
solve which is basically at the scaling

00:02:15,310 --> 00:02:24,790
supports to do next Colonel I'll speak

00:02:20,470 --> 00:02:27,870
about the requirements and I will point

00:02:24,790 --> 00:02:32,709
out some of the frameworks which are

00:02:27,870 --> 00:02:37,959
related to this problem and just do a

00:02:32,709 --> 00:02:42,280
brain dump and explain how I see this

00:02:37,959 --> 00:02:48,480
and what the frameworks are what can be

00:02:42,280 --> 00:02:48,480
expanded and how can we resolve this

00:02:54,940 --> 00:02:59,630
by the way there will be a separate

00:02:57,470 --> 00:03:02,690
cutting session in the afternoon right

00:02:59,630 --> 00:03:08,300
after lunch so if you are interested in

00:03:02,690 --> 00:03:12,950
this topic or your associate vendor and

00:03:08,300 --> 00:03:17,959
you use some custom implementation in

00:03:12,950 --> 00:03:20,180
the your kernels to do some dynamic

00:03:17,959 --> 00:03:23,300
blocking voltage scaling or interconnect

00:03:20,180 --> 00:03:26,660
scaling you are welcome to join the

00:03:23,300 --> 00:03:29,230
tracking session which will be in Rome

00:03:26,660 --> 00:03:29,230
Madrid

00:03:35,099 --> 00:03:43,900
so during last seven or eight years the

00:03:41,950 --> 00:03:47,650
on-chip interconnects and especially the

00:03:43,900 --> 00:03:50,920
network on chip concept is becoming

00:03:47,650 --> 00:03:54,610
increasingly popular it's used in

00:03:50,920 --> 00:03:58,150
various high-performance associes and it

00:03:54,610 --> 00:04:02,700
solves some problems and provide some

00:03:58,150 --> 00:04:06,250
benefits so these are mostly related to

00:04:02,700 --> 00:04:14,500
scalability power management performance

00:04:06,250 --> 00:04:18,639
management predictability gos so yeah

00:04:14,500 --> 00:04:22,290
there is hide amount of integrating more

00:04:18,639 --> 00:04:26,700
and more features each year there is a

00:04:22,290 --> 00:04:33,490
never-ending grace of adding new

00:04:26,700 --> 00:04:38,560
functionalities IP cores and as a

00:04:33,490 --> 00:04:46,060
consequence of that the design of the

00:04:38,560 --> 00:04:52,169
SOC is becoming more and more complex so

00:04:46,060 --> 00:04:56,380
now we have multiple cpus dedicated GPUs

00:04:52,169 --> 00:05:05,890
video and colors the colors graphic

00:04:56,380 --> 00:05:07,720
course modems many peripherals and many

00:05:05,890 --> 00:05:14,860
components that are talking to each

00:05:07,720 --> 00:05:20,460
other so the users want high speeds fast

00:05:14,860 --> 00:05:25,470
transfers great user experience and and

00:05:20,460 --> 00:05:32,639
the vendors are trying to solve this so

00:05:25,470 --> 00:05:35,710
when we have a complex SOC there are

00:05:32,639 --> 00:05:40,270
multiple sources of traffic multiple IP

00:05:35,710 --> 00:05:44,740
cores and multiple interrupts each

00:05:40,270 --> 00:05:48,000
second and we have shared components

00:05:44,740 --> 00:05:56,099
like deer on which is X

00:05:48,000 --> 00:05:58,660
from various components so we have

00:05:56,099 --> 00:06:04,180
utilization of the arraignment usually

00:05:58,660 --> 00:06:08,979
we can't predict how how do if the SOC

00:06:04,180 --> 00:06:14,470
will handle this so the predictability

00:06:08,979 --> 00:06:18,419
is difficult also the vendors are trying

00:06:14,470 --> 00:06:23,759
to the SOC manufacturers are trying to

00:06:18,419 --> 00:06:23,759
reduce the footprint of the SOC and

00:06:25,830 --> 00:06:33,639
enter facing various challenges related

00:06:30,250 --> 00:06:40,479
to this because of course all

00:06:33,639 --> 00:06:45,669
manufacturers want to use low power in

00:06:40,479 --> 00:06:55,930
their associés and this is a challenging

00:06:45,669 --> 00:07:00,479
task so the communication becomes a

00:06:55,930 --> 00:07:00,479
problem in in the complex SOC

00:07:06,780 --> 00:07:11,490
so the words are carrying the car

00:07:09,639 --> 00:07:16,210
carrying the information and the

00:07:11,490 --> 00:07:18,690
components connected to each other the

00:07:16,210 --> 00:07:23,199
data is exchanged increasingly

00:07:18,690 --> 00:07:25,840
increasingly high speeds so in the

00:07:23,199 --> 00:07:30,310
beginning designers chip designers has

00:07:25,840 --> 00:07:35,340
been relying on some legacy interconnect

00:07:30,310 --> 00:07:38,530
technologies like buses and cross bars

00:07:35,340 --> 00:07:44,169
so in the post technology the

00:07:38,530 --> 00:07:46,750
interconnect is just wires we have some

00:07:44,169 --> 00:07:48,880
IP cores which are connected on the bus

00:07:46,750 --> 00:07:51,699
and we have an arbiter which is

00:07:48,880 --> 00:07:55,240
arbitrating access on the bus we can

00:07:51,699 --> 00:07:59,979
have multiple devices communicating at

00:07:55,240 --> 00:08:06,449
the same time and also there are some

00:07:59,979 --> 00:08:09,820
latency constraints if the area is

00:08:06,449 --> 00:08:12,250
larger than it's difficult for the

00:08:09,820 --> 00:08:21,550
information to reach within a single

00:08:12,250 --> 00:08:29,289
clock cycle to the other component so to

00:08:21,550 --> 00:08:33,430
resolve this the manufacturers are using

00:08:29,289 --> 00:08:43,750
some hierarchical buses and also cross

00:08:33,430 --> 00:08:46,270
bars so the crossbar is a component

00:08:43,750 --> 00:08:51,370
which is connecting all the inputs to

00:08:46,270 --> 00:08:54,610
all the outputs so i'll just show you

00:08:51,370 --> 00:08:58,360
how it looks like yeah here is the bus

00:08:54,610 --> 00:09:03,070
we have devices on the bus here is the

00:08:58,360 --> 00:09:08,160
crossbar as you can see when we have a

00:09:03,070 --> 00:09:13,779
crossbar we have we have multiple wires

00:09:08,160 --> 00:09:16,480
so the area is much bigger when we use

00:09:13,779 --> 00:09:18,990
crossbar crossbar but from a performance

00:09:16,480 --> 00:09:18,990
point

00:09:20,250 --> 00:09:27,360
we can have parallel communication so

00:09:34,200 --> 00:09:42,940
so yeah and when we have a large number

00:09:37,630 --> 00:09:46,120
of wires this can be a problem with the

00:09:42,940 --> 00:09:52,440
area on the SOC when we have multiple

00:09:46,120 --> 00:10:01,540
wires this create routing congestion and

00:09:52,440 --> 00:10:06,490
also increases power consumption here is

00:10:01,540 --> 00:10:10,090
also an example of point-to-point buses

00:10:06,490 --> 00:10:12,160
when we increase the components the

00:10:10,090 --> 00:10:20,110
number of wires also increases

00:10:12,160 --> 00:10:25,620
quadratically so again this is ideal for

00:10:20,110 --> 00:10:29,070
performance but not for area and and

00:10:25,620 --> 00:10:29,070
power consumption

00:10:36,850 --> 00:10:53,930
so here is how the network on chip

00:10:42,080 --> 00:10:59,620
concept looks like so actually this

00:10:53,930 --> 00:11:05,089
concept comes from the carrier networks

00:10:59,620 --> 00:11:08,390
and we have this for a long time and the

00:11:05,089 --> 00:11:12,020
idea is here is to reuse the carrier

00:11:08,390 --> 00:11:17,210
networks concept into the SOC domain

00:11:12,020 --> 00:11:26,560
induct and buy the domain so here we

00:11:17,210 --> 00:11:28,730
have here are our components IP course

00:11:26,560 --> 00:11:35,570
they are connected to our network

00:11:28,730 --> 00:11:41,380
through sockets which give us a kind of

00:11:35,570 --> 00:11:46,820
uniform interface to connect into the

00:11:41,380 --> 00:11:50,120
network we have some routing or

00:11:46,820 --> 00:11:56,060
switching elements which are basically

00:11:50,120 --> 00:11:58,400
some micro routers that are switching

00:11:56,060 --> 00:12:04,220
packets so the communication here is

00:11:58,400 --> 00:12:08,209
packet-based we have a packet and each

00:12:04,220 --> 00:12:13,040
packet contains header and payload until

00:12:08,209 --> 00:12:17,089
the payload we have some information

00:12:13,040 --> 00:12:20,240
about source and destination ports on

00:12:17,089 --> 00:12:24,350
the network and some flags which can

00:12:20,240 --> 00:12:33,830
indicate priority so we can do quality

00:12:24,350 --> 00:12:42,500
of service so the links are very very

00:12:33,830 --> 00:12:46,970
short and we can have this network it

00:12:42,500 --> 00:12:48,660
can be multi tired and it can pass

00:12:46,970 --> 00:12:52,319
across multiple

00:12:48,660 --> 00:12:58,110
power domains so you know SOC we can

00:12:52,319 --> 00:13:06,089
turn some parts of in order to save

00:12:58,110 --> 00:13:10,379
power so there are various topologies

00:13:06,089 --> 00:13:15,689
for example this is just two dimensional

00:13:10,379 --> 00:13:19,800
illustration but so this is a mesh

00:13:15,689 --> 00:13:34,399
network but it can be also a torus when

00:13:19,800 --> 00:13:42,480
we have wrapping connections here so

00:13:34,399 --> 00:13:46,829
compared with the crossbar we have pure

00:13:42,480 --> 00:13:52,170
wires because we can reuse these links

00:13:46,829 --> 00:13:56,850
these links are shared between between

00:13:52,170 --> 00:14:00,810
the ports so we can have some traffic

00:13:56,850 --> 00:14:06,449
from here to there and there are also

00:14:00,810 --> 00:14:10,079
multiple paths which can be used the

00:14:06,449 --> 00:14:16,579
network on chip card can do some load

00:14:10,079 --> 00:14:16,579
balancing can provide quality of service

00:14:18,350 --> 00:14:24,889
handle different kinds of traffic

00:14:21,290 --> 00:14:24,889
different priority

00:14:30,200 --> 00:14:38,420
so these are see the summary of the

00:14:33,990 --> 00:14:45,720
benefits this concept is scalable

00:14:38,420 --> 00:14:47,870
because we can keep the the number of

00:14:45,720 --> 00:14:52,290
the links is not increasing

00:14:47,870 --> 00:14:55,530
quadratically like with the crossbar

00:14:52,290 --> 00:15:02,760
architecture we have a packet

00:14:55,530 --> 00:15:05,300
communication and we use shared

00:15:02,760 --> 00:15:05,300
resources

00:15:11,529 --> 00:15:18,620
so there are different algorithms used

00:15:15,290 --> 00:15:25,790
for quality of service and load

00:15:18,620 --> 00:15:30,230
balancing and there are actually many

00:15:25,790 --> 00:15:34,699
companies providing some interconnect IP

00:15:30,230 --> 00:15:40,310
solutions like our Terry Sonics let's

00:15:34,699 --> 00:15:42,459
beat systems most of most of the

00:15:40,310 --> 00:15:45,529
companies probably are using some arm

00:15:42,459 --> 00:15:50,089
reference designs and other companies

00:15:45,529 --> 00:15:53,980
have developed their own IP core

00:15:50,089 --> 00:15:53,980
solutions for the network on chip

00:16:03,740 --> 00:16:10,820
there is something else also that when

00:16:08,060 --> 00:16:20,870
you create the design of the network on

00:16:10,820 --> 00:16:23,270
chip you can know in advance what

00:16:20,870 --> 00:16:26,600
performance can you expect sexually this

00:16:23,270 --> 00:16:30,010
can be calculated and each of the links

00:16:26,600 --> 00:16:33,860
between the nodes can run up different

00:16:30,010 --> 00:16:38,420
frequency and provides different band

00:16:33,860 --> 00:16:47,510
right so this can be defined at design

00:16:38,420 --> 00:16:54,460
time so how about network on ships and

00:16:47,510 --> 00:17:02,030
Clinics so yeah we want to control this

00:16:54,460 --> 00:17:06,290
network on chip and scale it and control

00:17:02,030 --> 00:17:11,150
it and use the power management benefits

00:17:06,290 --> 00:17:17,750
and do precise calculation what when

00:17:11,150 --> 00:17:21,050
Dwight is traversing the network seems

00:17:17,750 --> 00:17:25,970
that currently there is no solution for

00:17:21,050 --> 00:17:32,020
this in the mainline kernel and probably

00:17:25,970 --> 00:17:39,290
the SOC manufacturers have their own

00:17:32,020 --> 00:17:43,180
solution for this so so if you know

00:17:39,290 --> 00:17:45,890
about any out of three implementations

00:17:43,180 --> 00:17:48,800
the hacking session after lunch you're

00:17:45,890 --> 00:17:52,340
welcome I will be curious to know more

00:17:48,800 --> 00:17:56,240
about this and in that linaro spirit we

00:17:52,340 --> 00:18:03,470
can collaborate and find the common

00:17:56,240 --> 00:18:07,300
solution for for all vendors which use

00:18:03,470 --> 00:18:07,300
this on the ARM architecture

00:18:07,530 --> 00:18:19,470
so how to solve this int how does this

00:18:14,190 --> 00:18:22,590
fit into the Linux kernel so I'll give

00:18:19,470 --> 00:18:25,170
just an overview of the Linux kernel

00:18:22,590 --> 00:18:31,880
frameworks that I think are related to

00:18:25,170 --> 00:18:31,880
this and talk a bit of how I see these

00:18:38,330 --> 00:18:50,250
so here is an example use case if we

00:18:44,880 --> 00:18:54,480
have device connected somewhere on the

00:18:50,250 --> 00:18:56,400
topology and it wants to bridge some

00:18:54,480 --> 00:19:01,700
other device connected to this topology

00:18:56,400 --> 00:19:05,880
and and the other device may be

00:19:01,700 --> 00:19:10,800
connected over a few interconnected

00:19:05,880 --> 00:19:17,550
knocks so how can we describe this and

00:19:10,800 --> 00:19:20,340
how can we solve this and this includes

00:19:17,550 --> 00:19:24,260
traversing called up networks finding

00:19:20,340 --> 00:19:28,800
all the ports where the traffic goes and

00:19:24,260 --> 00:19:30,890
um one of the parts we can have multiple

00:19:28,800 --> 00:19:36,000
streams of traffic so we need to

00:19:30,890 --> 00:19:39,110
aggregate all this traffic and set some

00:19:36,000 --> 00:19:39,110
eos values

00:19:43,010 --> 00:19:48,610
so we need some bandwidth analysis

00:19:53,530 --> 00:20:02,910
so here is an example of this topology

00:19:56,350 --> 00:20:02,910
we can have multiple network-on-chip

00:20:03,990 --> 00:20:11,620
buses for example we have here a memory

00:20:07,630 --> 00:20:15,010
front end we can have system log config

00:20:11,620 --> 00:20:19,680
knock multimedia NOC we can have many

00:20:15,010 --> 00:20:25,450
others depending on the architecture so

00:20:19,680 --> 00:20:27,550
on each bus we can have multiple slave

00:20:25,450 --> 00:20:36,930
and master devices from a cost

00:20:27,550 --> 00:20:39,130
perspective soul and between each

00:20:36,930 --> 00:20:45,880
network-on-chip we can have multiple

00:20:39,130 --> 00:20:50,410
connections so in one scenario you we

00:20:45,880 --> 00:20:52,570
would like to use one of these links for

00:20:50,410 --> 00:20:55,360
some other scenario we will like to use

00:20:52,570 --> 00:20:57,870
some other so it can get very

00:20:55,360 --> 00:20:57,870
complicated

00:21:07,660 --> 00:21:09,720
you

00:21:12,190 --> 00:21:21,710
so here is an example if you want to

00:21:17,299 --> 00:21:25,190
find the pad between one of the CPU to

00:21:21,710 --> 00:21:28,970
another cpu for exam in this example

00:21:25,190 --> 00:21:32,960
here we have two CPUs talking to each

00:21:28,970 --> 00:21:36,710
other via by using a message from so if

00:21:32,960 --> 00:21:40,340
one of the CPU has to write something

00:21:36,710 --> 00:21:43,330
into the message Ram it has to cross all

00:21:40,340 --> 00:21:43,330
these ports

00:21:53,230 --> 00:22:02,060
so in order to do this we should know

00:21:58,300 --> 00:22:05,630
the endpoints and we should know more

00:22:02,060 --> 00:22:13,220
about the architecture of this network

00:22:05,630 --> 00:22:24,320
on chip so we need to divide to define

00:22:13,220 --> 00:22:28,730
some kind of API for for this so here is

00:22:24,320 --> 00:22:31,310
a list of what we need to solve this we

00:22:28,730 --> 00:22:35,410
need a description of the topology how

00:22:31,310 --> 00:22:41,840
all these buses are interconnected and

00:22:35,410 --> 00:22:43,760
the topology description I see two

00:22:41,840 --> 00:22:47,120
possible solutions for this one is to

00:22:43,760 --> 00:22:51,590
define this into the device tree and the

00:22:47,120 --> 00:22:58,100
other is to embed this into some vendor

00:22:51,590 --> 00:23:02,780
specific driver and have this embedded

00:22:58,100 --> 00:23:08,240
into the source code and actually this

00:23:02,780 --> 00:23:12,800
is very similar to the common clock

00:23:08,240 --> 00:23:14,990
framework with difference that in the

00:23:12,800 --> 00:23:18,740
common clock framework we have tree

00:23:14,990 --> 00:23:23,720
topology with parent-child relationships

00:23:18,740 --> 00:23:28,460
and here we can have also multiple links

00:23:23,720 --> 00:23:31,310
between the network on ships so the

00:23:28,460 --> 00:23:37,600
topologies a little bit complex so it

00:23:31,310 --> 00:23:37,600
looks like graph and in the linux kernel

00:23:40,210 --> 00:23:48,040
there is no framework supporting this

00:23:44,990 --> 00:23:50,990
actually there is the media device

00:23:48,040 --> 00:23:54,680
framework which uses some graph

00:23:50,990 --> 00:23:56,990
traversals for configuring the video

00:23:54,680 --> 00:24:03,310
pipeline sold it was this was the

00:23:56,990 --> 00:24:03,310
closest think I found related to this

00:24:05,110 --> 00:24:13,669
so we need some also on API for setting

00:24:10,340 --> 00:24:21,590
the constraints on all the devices we

00:24:13,669 --> 00:24:26,320
need to have information about which is

00:24:21,590 --> 00:24:28,760
based on source and destination pair so

00:24:26,320 --> 00:24:32,889
then the framework can calculate what

00:24:28,760 --> 00:24:38,360
are the port what are the ports and

00:24:32,889 --> 00:24:42,260
configure them accordingly the framework

00:24:38,360 --> 00:24:48,769
should walk called the graphs and update

00:24:42,260 --> 00:24:53,419
the constraints on each port or note so

00:24:48,769 --> 00:24:56,330
the NOC hardware is also very specific

00:24:53,419 --> 00:25:00,320
there are multiple IP cores from

00:24:56,330 --> 00:25:08,600
multiple vendors and many associés have

00:25:00,320 --> 00:25:12,970
their own state their own Harbor so so

00:25:08,600 --> 00:25:12,970
this will be a hardware specific driver

00:25:14,200 --> 00:25:25,340
also we'll need a trigger for updating

00:25:20,750 --> 00:25:30,350
this network of nodes when there is a

00:25:25,340 --> 00:25:38,019
change of of the requirement or we want

00:25:30,350 --> 00:25:42,320
to to enter some high performance mode

00:25:38,019 --> 00:25:45,260
we need to traverse the tree and set

00:25:42,320 --> 00:25:48,559
nuke us values into the cargo registers

00:25:45,260 --> 00:25:51,559
and configure the Karma the harder for

00:25:48,559 --> 00:25:59,659
the performance note or we may want the

00:25:51,559 --> 00:26:03,100
low power mode and this is separate for

00:25:59,659 --> 00:26:08,450
each combination source and destination

00:26:03,100 --> 00:26:12,169
so we need to trigger to update this we

00:26:08,450 --> 00:26:16,909
can do this probably with specific API

00:26:12,169 --> 00:26:26,330
function or I'll talk with letter later

00:26:16,909 --> 00:26:29,659
about what else can be used so here is

00:26:26,330 --> 00:26:34,399
an overview of the existing frameworks

00:26:29,659 --> 00:26:41,139
in the Linux so we have the driver model

00:26:34,399 --> 00:26:45,619
the driver model contains some

00:26:41,139 --> 00:26:51,080
information about parent-child

00:26:45,619 --> 00:26:57,940
relationships between devices but to

00:26:51,080 --> 00:27:02,570
model this topology we need something

00:26:57,940 --> 00:27:04,669
something different which contains so we

00:27:02,570 --> 00:27:06,950
can have multiple dependency we can have

00:27:04,669 --> 00:27:11,509
multiple suppliers and multiple

00:27:06,950 --> 00:27:15,019
consumers of each device so currently

00:27:11,509 --> 00:27:18,019
there is so I patch a patch set on the

00:27:15,019 --> 00:27:23,659
Linux kernel mailing list by the PM core

00:27:18,019 --> 00:27:26,809
maintainer which is adding support for

00:27:23,659 --> 00:27:29,749
functional dependencies which is

00:27:26,809 --> 00:27:34,789
basically adding some link information

00:27:29,749 --> 00:27:37,549
into the struct device and then we can

00:27:34,789 --> 00:27:40,669
define there what are the relationships

00:27:37,549 --> 00:27:46,489
between devices and how they depend on

00:27:40,669 --> 00:27:51,529
each other so this is an interesting

00:27:46,489 --> 00:27:58,809
patch set that probably can be useful in

00:27:51,529 --> 00:27:58,809
resolving this also we have device tree

00:27:59,739 --> 00:28:08,659
so in the device tree we can describe

00:28:03,999 --> 00:28:14,210
the resources which device can claim so

00:28:08,659 --> 00:28:16,519
here I see the interconnects as resource

00:28:14,210 --> 00:28:21,379
you can model them as a resource and

00:28:16,519 --> 00:28:26,259
each device can claim the Pat or a link

00:28:21,379 --> 00:28:30,460
to some other device and set some

00:28:26,259 --> 00:28:40,600
properties on this link like band right

00:28:30,460 --> 00:28:42,880
latency qos so we have from multiple

00:28:40,600 --> 00:28:45,490
frameworks which are using the consumer

00:28:42,880 --> 00:28:51,180
provider based ap is like the regulator

00:28:45,490 --> 00:28:57,790
framework clock framework so we can

00:28:51,180 --> 00:29:00,640
expose this links in the device

00:28:57,790 --> 00:29:08,650
trilliant they can be claimed but by

00:29:00,640 --> 00:29:12,970
some consumer driver and we have a lot

00:29:08,650 --> 00:29:16,900
of power management frameworks which are

00:29:12,970 --> 00:29:21,390
mostly idle based so probably we can

00:29:16,900 --> 00:29:26,950
extend them and make them active based

00:29:21,390 --> 00:29:33,100
so explain a little bit more about this

00:29:26,950 --> 00:29:37,090
later so we have some depth 30 p p.s

00:29:33,100 --> 00:29:40,720
i've seen some some vendors use this

00:29:37,090 --> 00:29:44,490
into their downstream colonel so this is

00:29:40,720 --> 00:29:48,150
also an option when we have an

00:29:44,490 --> 00:29:52,440
interconnect device it can be modeled as

00:29:48,150 --> 00:29:56,340
depth Rick device which sets opds on

00:29:52,440 --> 00:29:56,340
themselves themselves

00:30:01,630 --> 00:30:11,530
some more existing frameworks so we have

00:30:08,530 --> 00:30:14,890
front I'm p.m. which is currently mostly

00:30:11,530 --> 00:30:17,020
idle based which does some reference

00:30:14,890 --> 00:30:23,910
counting and which one a device is not

00:30:17,020 --> 00:30:27,130
in use it just triggers some idle state

00:30:23,910 --> 00:30:29,490
we have generic p.m. domains which are

00:30:27,130 --> 00:30:34,330
used for grouping devices that share

00:30:29,490 --> 00:30:42,340
similar characteristics and we have p.m.

00:30:34,330 --> 00:30:49,800
qos which is very interesting so PM qos

00:30:42,340 --> 00:30:49,800
is actually a framework which there are

00:30:50,070 --> 00:30:58,710
two api's one is system-wide p.m. qos

00:30:54,430 --> 00:31:02,190
and the other is per device p.m. qos so

00:30:58,710 --> 00:31:06,360
the device p.m. gos is used to set

00:31:02,190 --> 00:31:09,760
constraints on some of the devices so

00:31:06,360 --> 00:31:20,500
this definitely is interesting in our

00:31:09,760 --> 00:31:23,650
case so yes I already gave them quick

00:31:20,500 --> 00:31:34,590
overview so this is used in many colonel

00:31:23,650 --> 00:31:39,090
subsystems so here I think we need this

00:31:34,590 --> 00:31:45,610
to kill callbacks as a minimum for

00:31:39,090 --> 00:31:49,120
setting some constraints we need an init

00:31:45,610 --> 00:31:53,770
callback for configuring the network ins

00:31:49,120 --> 00:31:57,280
on chip ports and we need an update API

00:31:53,770 --> 00:32:02,700
for updating and settings setting new

00:31:57,280 --> 00:32:06,930
constraints so the consumers can use

00:32:02,700 --> 00:32:06,930
getting functions

00:32:18,680 --> 00:32:26,720
so here is an example of how I see this

00:32:23,110 --> 00:32:30,110
in a device tree we can describe the

00:32:26,720 --> 00:32:32,930
interconnect between devices for example

00:32:30,110 --> 00:32:34,220
this is if we call this performance

00:32:32,930 --> 00:32:38,330
provider because actually the

00:32:34,220 --> 00:32:44,600
interconnects are providing connectivity

00:32:38,330 --> 00:32:46,850
and this connectivity can have developed

00:32:44,600 --> 00:32:49,580
different different performance

00:32:46,850 --> 00:32:52,250
characteristics and we can request dif

00:32:49,580 --> 00:32:56,810
different performance levels so if we

00:32:52,250 --> 00:32:58,900
have something like this and call this a

00:32:56,810 --> 00:33:01,610
performance provider it can has a

00:32:58,900 --> 00:33:08,540
compatible string which is some vendor

00:33:01,610 --> 00:33:10,640
specific driver it can it has a

00:33:08,540 --> 00:33:17,150
performance cells so this is also

00:33:10,640 --> 00:33:21,020
specific and we can have consumer

00:33:17,150 --> 00:33:25,190
devices the consumer device can be any

00:33:21,020 --> 00:33:31,360
peripheral for example USB device emmc

00:33:25,190 --> 00:33:37,190
controller even serial port whatever so

00:33:31,360 --> 00:33:43,520
this is just proposal how I see this we

00:33:37,190 --> 00:33:47,780
can describe here where this device is

00:33:43,520 --> 00:33:52,030
connected so the performance provider on

00:33:47,780 --> 00:33:55,070
the previous slide registers its ports

00:33:52,030 --> 00:33:57,440
into the framework and each device

00:33:55,070 --> 00:34:01,430
describes where exactly it is connected

00:33:57,440 --> 00:34:06,100
on the topology and here we define the

00:34:01,430 --> 00:34:10,190
links for example this device has

00:34:06,100 --> 00:34:12,440
connection to USB or to display and this

00:34:10,190 --> 00:34:15,710
here are the pic handles to other device

00:34:12,440 --> 00:34:19,430
notes so we parse this into the

00:34:15,710 --> 00:34:21,800
framework and look up and see what the

00:34:19,430 --> 00:34:28,220
other endpoint is and where it is

00:34:21,800 --> 00:34:31,640
connected so here we can add some vendor

00:34:28,220 --> 00:34:36,950
specific properties like

00:34:31,640 --> 00:34:43,950
matrix or directions or this is entirely

00:34:36,950 --> 00:34:48,330
dependent on the car dealer so the per

00:34:43,950 --> 00:34:52,890
device p.m. qos is very interesting so

00:34:48,330 --> 00:34:55,950
it exists already in the kernel and it's

00:34:52,890 --> 00:34:59,910
just up database for storing constraints

00:34:55,950 --> 00:35:02,850
per each device so here the missing

00:34:59,910 --> 00:35:06,000
pieces that we need to store the

00:35:02,850 --> 00:35:08,580
constraints based on the source and

00:35:06,000 --> 00:35:12,360
destination device pairs or currently it

00:35:08,580 --> 00:35:19,880
stores only constraints based on a

00:35:12,360 --> 00:35:19,880
single device so we can extend this and

00:35:23,420 --> 00:35:31,440
the developer device came to us all

00:35:26,370 --> 00:35:36,750
supports it can aggregate all the

00:35:31,440 --> 00:35:41,910
constraints which are defined / specific

00:35:36,750 --> 00:35:46,170
device and it can provide some value

00:35:41,910 --> 00:35:48,780
based on minimum or maximum constraints

00:35:46,170 --> 00:35:57,720
value so we can just do a look look up

00:35:48,780 --> 00:36:00,120
and see what the constraints are the

00:35:57,720 --> 00:36:03,570
runtime p.m. say so as I said earlier

00:36:00,120 --> 00:36:08,240
it's as idle based and currently the

00:36:03,570 --> 00:36:08,240
trigger is runtime be important when

00:36:10,280 --> 00:36:16,080
device is not in use it just enters idle

00:36:13,770 --> 00:36:20,910
and the device can have an idol function

00:36:16,080 --> 00:36:23,250
and it's cold and just that's what what

00:36:20,910 --> 00:36:27,180
it has to do for the specific hardware

00:36:23,250 --> 00:36:31,020
to enter idle oh I idle mode so I think

00:36:27,180 --> 00:36:38,570
that we may use runtime ppm get to

00:36:31,020 --> 00:36:42,740
trigger an update when we want to update

00:36:38,570 --> 00:36:42,740
the interconnect performance

00:36:43,570 --> 00:36:50,420
so this will be like mirror what we have

00:36:47,300 --> 00:37:00,800
for idle we can use the same concept and

00:36:50,420 --> 00:37:03,560
do this for performance States so that

00:37:00,800 --> 00:37:05,990
generic p.m. domains concept is also

00:37:03,560 --> 00:37:10,310
interesting so it allows grouping of

00:37:05,990 --> 00:37:13,550
multiple devices so currently it's used

00:37:10,310 --> 00:37:17,030
for hardware power domains so on SOC we

00:37:13,550 --> 00:37:18,920
can have multiple power domains we can

00:37:17,030 --> 00:37:22,730
switch some of them off when they are

00:37:18,920 --> 00:37:26,810
not in use in order to save power so

00:37:22,730 --> 00:37:30,410
when we have that work on ship and we

00:37:26,810 --> 00:37:34,099
have devices on this network on chip we

00:37:30,410 --> 00:37:38,390
have devices which share this similar

00:37:34,099 --> 00:37:49,540
characteristics so this is a candidate

00:37:38,390 --> 00:37:52,819
forum for for something that we can use

00:37:49,540 --> 00:37:56,270
the PM domains also support governor so

00:37:52,819 --> 00:38:02,000
we can use these governors when we have

00:37:56,270 --> 00:38:05,000
multiple devices the governor's can just

00:38:02,000 --> 00:38:06,859
look at what devices we have and check

00:38:05,000 --> 00:38:12,069
work or the constraints of these devices

00:38:06,859 --> 00:38:18,369
are and make a decision depending on the

00:38:12,069 --> 00:38:18,369
on the devices and set performance or

00:38:22,160 --> 00:38:35,100
so what's the solution so a solution so

00:38:32,370 --> 00:38:37,650
this I see this has some performance

00:38:35,100 --> 00:38:43,280
framework we can call it performance

00:38:37,650 --> 00:38:46,350
framework or interconnect framework its

00:38:43,280 --> 00:38:50,580
consumer provider based so we are

00:38:46,350 --> 00:38:53,520
describing the performance providers in

00:38:50,580 --> 00:38:57,090
the device tree and the consumers we use

00:38:53,520 --> 00:39:04,290
the the vendor drivers for describing

00:38:57,090 --> 00:39:14,060
the topology the consumers claim the

00:39:04,290 --> 00:39:17,900
links as resources and we extend BMG OS

00:39:14,060 --> 00:39:27,360
to store the constraints based on on

00:39:17,900 --> 00:39:31,620
links for triggers we can use runtime

00:39:27,360 --> 00:39:40,170
p.m. get or use the specific API

00:39:31,620 --> 00:39:43,410
function for triggering update so the

00:39:40,170 --> 00:39:47,460
idea here is to give an introduction of

00:39:43,410 --> 00:39:52,560
this topic and see if there are other

00:39:47,460 --> 00:39:58,310
people interested in decent work for

00:39:52,560 --> 00:40:02,360
some common solution actually this

00:39:58,310 --> 00:40:05,430
problem is standing for a long time and

00:40:02,360 --> 00:40:07,560
have not been resolved yet and the

00:40:05,430 --> 00:40:13,040
things were getting more and more

00:40:07,560 --> 00:40:16,730
complex so it's time to do something and

00:40:13,040 --> 00:40:16,730
to address these issues

00:40:25,780 --> 00:40:38,830
so there is a lot of work on going in

00:40:29,620 --> 00:40:40,360
this and a lot of upcoming work so we're

00:40:38,830 --> 00:40:42,370
investigating these functional

00:40:40,360 --> 00:40:46,270
dependencies between devices first but

00:40:42,370 --> 00:40:50,320
set by Rafael how this will work for

00:40:46,270 --> 00:40:53,970
buses because this is already proposal

00:40:50,320 --> 00:40:57,250
so we need to look into this and see how

00:40:53,970 --> 00:41:05,650
can we use this or do we need something

00:40:57,250 --> 00:41:08,320
else so I already mentioned that these

00:41:05,650 --> 00:41:14,680
frameworks need to be expanded for

00:41:08,320 --> 00:41:16,960
example for the PM domains currently

00:41:14,680 --> 00:41:19,030
they support only one device but

00:41:16,960 --> 00:41:22,600
actually do a device can be in more than

00:41:19,030 --> 00:41:26,320
one our domain and this is not yet

00:41:22,600 --> 00:41:29,220
supported actually I have noticed the

00:41:26,320 --> 00:41:32,080
last week some patches for adding

00:41:29,220 --> 00:41:43,510
support for multiple power domain so

00:41:32,080 --> 00:41:47,500
we're moving into this direction so at

00:41:43,510 --> 00:41:50,190
at ELC there will be a buff session

00:41:47,500 --> 00:41:54,070
about those device performance framework

00:41:50,190 --> 00:42:00,130
which is very similar to what we're

00:41:54,070 --> 00:42:04,390
trying to do so if you are at ELC you

00:42:00,130 --> 00:42:06,190
can attend this session microcat and

00:42:04,390 --> 00:42:11,250
kevin human from Bailey Bray will be

00:42:06,190 --> 00:42:11,250
there and we'll be discussing this soul

00:42:13,730 --> 00:42:25,250
and yeah there will be a session after

00:42:17,840 --> 00:42:29,750
lunch so please join so I would like to

00:42:25,250 --> 00:42:34,100
thank the guys from Qualcomm saravana

00:42:29,750 --> 00:42:37,810
column Sean Sweeney for providing some

00:42:34,100 --> 00:42:39,859
initial feedback and actively

00:42:37,810 --> 00:42:42,260
participating in to these discussions

00:42:39,859 --> 00:42:49,160
and also mike and kevin from bailey

00:42:42,260 --> 00:42:51,109
bread so yeah where we had some

00:42:49,160 --> 00:42:53,480
discussions about this architecture and

00:42:51,109 --> 00:42:55,400
I think we're it's time to involve more

00:42:53,480 --> 00:42:59,840
people from the community and other

00:42:55,400 --> 00:43:04,790
vendors so yeah we can work towards a

00:42:59,840 --> 00:43:19,490
common solution for this so do you have

00:43:04,790 --> 00:43:22,609
any questions or answers or comments so

00:43:19,490 --> 00:43:24,950
in in in the examples in the slides you

00:43:22,609 --> 00:43:27,800
showed some bindings of the performance

00:43:24,950 --> 00:43:30,560
providers and consumers are they public

00:43:27,800 --> 00:43:33,260
god they've been discussed or no they're

00:43:30,560 --> 00:43:36,350
not being this I Scalia I think the I

00:43:33,260 --> 00:43:39,680
think we should probably post the

00:43:36,350 --> 00:43:41,869
bindings and talk to more people yeah

00:43:39,680 --> 00:43:43,790
agree i think it's not just go home i

00:43:41,869 --> 00:43:48,040
think that a lot of people would be

00:43:43,790 --> 00:43:48,040
interested to give more inputs on that

00:43:48,880 --> 00:43:56,150
yeah for sure so this is actually the

00:43:52,070 --> 00:44:00,200
next step so currently i have some work

00:43:56,150 --> 00:44:05,080
in progress of which is using what i

00:44:00,200 --> 00:44:09,170
have described here and i would like to

00:44:05,080 --> 00:44:11,630
hear some feedback and some x nax and

00:44:09,170 --> 00:44:17,050
people saying no we're crazy don't do

00:44:11,630 --> 00:44:17,050
this or a okay sounds reasonable or

00:44:23,560 --> 00:44:29,420
first we I agree on bindings and the way

00:44:27,320 --> 00:44:32,510
things are supposed to work and then

00:44:29,420 --> 00:44:34,640
invest time on developing that rather

00:44:32,510 --> 00:44:42,170
than actually do you know the wrong yeah

00:44:34,640 --> 00:44:44,450
agree if you can pass the money I'm not

00:44:42,170 --> 00:44:46,970
sure I agree that we necessarily need to

00:44:44,450 --> 00:44:49,220
see airlines those two things binding is

00:44:46,970 --> 00:44:51,290
just to get a topology information it's

00:44:49,220 --> 00:44:52,520
just small part of the picture I think

00:44:51,290 --> 00:44:55,040
bigger part of the pictures trying to

00:44:52,520 --> 00:44:57,740
get the EPS agreed upon on the

00:44:55,040 --> 00:45:01,460
client-side AP is and how we want to

00:44:57,740 --> 00:45:03,470
have the topology traversed and the

00:45:01,460 --> 00:45:06,080
constraints applied I think all of these

00:45:03,470 --> 00:45:08,720
things can go on parallel and this is

00:45:06,080 --> 00:45:10,760
just one example he proposed in deity I

00:45:08,720 --> 00:45:12,200
don't think we should say hey let's all

00:45:10,760 --> 00:45:13,940
that first before you go to the coding

00:45:12,200 --> 00:45:23,210
part I think it's going to drag it on

00:45:13,940 --> 00:45:25,040
even further than it already has been by

00:45:23,210 --> 00:45:27,980
looking at the examples I can see their

00:45:25,040 --> 00:45:29,510
potential issues yeah I'm not at all

00:45:27,980 --> 00:45:31,220
questioning that the TT is far from

00:45:29,510 --> 00:45:35,990
being done it definitely in Jupiter yeah

00:45:31,220 --> 00:45:38,720
the basic use cases I think are not very

00:45:35,990 --> 00:45:40,970
tightly addressed in the binding so that

00:45:38,720 --> 00:45:45,850
that's the kind of discussion I want to

00:45:40,970 --> 00:45:45,850
bring up when we expose my knees people

00:45:46,090 --> 00:45:49,090
agree

00:45:50,570 --> 00:45:57,690
yeah yeah yeah so session if other

00:45:55,050 --> 00:45:59,790
wonders can attend the discussion after

00:45:57,690 --> 00:46:01,190
lunch that will be helpful I think for

00:45:59,790 --> 00:46:04,050
Georgie to at least get an idea of

00:46:01,190 --> 00:46:07,859
different use cases other one does might

00:46:04,050 --> 00:46:10,770
have for this so that he can design for

00:46:07,859 --> 00:46:13,080
ahead of time instead of being brought

00:46:10,770 --> 00:46:15,210
up when he submits the court saying hey

00:46:13,080 --> 00:46:25,859
this isn't work for me so that could

00:46:15,210 --> 00:46:29,700
kind of save us all some time so this is

00:46:25,859 --> 00:46:31,380
not my area but it's interesting I just

00:46:29,700 --> 00:46:34,170
have some fundamental questions right so

00:46:31,380 --> 00:46:37,859
I just have some fundamental questions

00:46:34,170 --> 00:46:41,430
which is um this sounds very complex

00:46:37,859 --> 00:46:42,990
clearly firstly is there some kind of a

00:46:41,430 --> 00:46:46,440
requirement to have a particular kind of

00:46:42,990 --> 00:46:49,650
platform as a proving ground for this or

00:46:46,440 --> 00:46:51,869
can existing problems on conventional

00:46:49,650 --> 00:46:58,080
mobile systems act as a proxy for a

00:46:51,869 --> 00:47:01,890
network on chip yes so currently I'm

00:46:58,080 --> 00:47:05,280
using her welcome platform to create

00:47:01,890 --> 00:47:11,609
some proof of concept and make this work

00:47:05,280 --> 00:47:15,450
and see how we can make all the

00:47:11,609 --> 00:47:17,790
frameworks work together and scale these

00:47:15,450 --> 00:47:19,800
interconnects i suppose what i was

00:47:17,790 --> 00:47:22,050
getting at was from our community

00:47:19,800 --> 00:47:24,690
adoption standpoint do you have the

00:47:22,050 --> 00:47:25,800
classic problem or don't you of there

00:47:24,690 --> 00:47:27,510
needs to be an openly accessible

00:47:25,800 --> 00:47:31,190
implementation of a platform on which

00:47:27,510 --> 00:47:35,700
this can be kind of aligned on right

00:47:31,190 --> 00:47:38,099
does such a thing exist what what kind

00:47:35,700 --> 00:47:40,550
of thing network-on-chip implementation

00:47:38,099 --> 00:47:40,550
actually

00:47:46,160 --> 00:47:54,420
okay fine this framework is equally a

00:47:50,010 --> 00:47:56,190
clip equally applicable for system will

00:47:54,420 --> 00:47:58,020
test across bar or doesn't even have a

00:47:56,190 --> 00:48:00,000
prospering to point right they're all

00:47:58,020 --> 00:48:01,710
perfectly valid hardware combinations

00:48:00,000 --> 00:48:04,500
where the should and could work okay

00:48:01,710 --> 00:48:07,200
yeah and networking simply started in

00:48:04,500 --> 00:48:11,070
your thing so you can take off the shelf

00:48:07,200 --> 00:48:12,359
exactly ne ne se SOC or rocket platform

00:48:11,070 --> 00:48:15,270
that has a bus which I'm sure all of

00:48:12,359 --> 00:48:18,180
them do cases the other thing I mean to

00:48:15,270 --> 00:48:19,680
ask was like I got the impression I have

00:48:18,180 --> 00:48:20,970
no knowledge of network on ships but I

00:48:19,680 --> 00:48:22,950
got the impression that there's a

00:48:20,970 --> 00:48:26,730
certain amount of repurposing of

00:48:22,950 --> 00:48:29,099
established techniques for network

00:48:26,730 --> 00:48:30,930
communication protocols and stuff like

00:48:29,099 --> 00:48:34,410
that right so is that something you guys

00:48:30,930 --> 00:48:36,420
I just need to use here or not at all ok

00:48:34,410 --> 00:48:46,280
so the packaging packetization of

00:48:36,420 --> 00:48:46,280
communication that's all happening so

00:48:47,540 --> 00:48:51,960
what I meant was like that's under the

00:48:50,190 --> 00:48:54,810
hood right that's an implementation

00:48:51,960 --> 00:48:56,369
specific yeah it is a story and you're

00:48:54,810 --> 00:48:58,920
just talking about high level API is to

00:48:56,369 --> 00:49:01,710
facilitate yes yeah there are many

00:48:58,920 --> 00:49:03,359
vendors and then many IP cores which are

00:49:01,710 --> 00:49:05,160
doing okay they're all have a

00:49:03,359 --> 00:49:07,230
requirement to have like a central

00:49:05,160 --> 00:49:08,550
arbiter that is you mentioned that there

00:49:07,230 --> 00:49:10,470
is some kind of a trigger that tells you

00:49:08,550 --> 00:49:13,020
that there's a situation will change

00:49:10,470 --> 00:49:15,980
which might impact qos right so who

00:49:13,020 --> 00:49:18,060
orchestrates that who's in charge of

00:49:15,980 --> 00:49:22,650
yeah but that framework is running on

00:49:18,060 --> 00:49:25,260
the AP what if there is a non AP entity

00:49:22,650 --> 00:49:30,080
that is also requiring a dynamic quass

00:49:25,260 --> 00:49:30,080
change okay

00:49:37,020 --> 00:49:53,470
okay are you fine so which it which

00:49:49,840 --> 00:49:56,800
ain't sure which hints at some other

00:49:53,470 --> 00:49:59,230
kind of orchestration API but that's

00:49:56,800 --> 00:50:10,090
that's an implementation detail it fine

00:49:59,230 --> 00:50:12,310
interesting best of luck have you

00:50:10,090 --> 00:50:15,010
thought about creating a new framework

00:50:12,310 --> 00:50:17,080
I'm all up for reusing the existing

00:50:15,010 --> 00:50:19,540
framework but from what I see you making

00:50:17,080 --> 00:50:21,760
core changes to a lot of frameworks p.m.

00:50:19,540 --> 00:50:23,140
domains runtime p.m. and all that I am

00:50:21,760 --> 00:50:28,600
afraid that you might end up with a

00:50:23,140 --> 00:50:31,090
Frankenstein solution in the end and it

00:50:28,600 --> 00:50:33,730
might be it might be better to even look

00:50:31,090 --> 00:50:37,900
at a new framework because it does touch

00:50:33,730 --> 00:50:39,460
a lot of existing stuff but not all the

00:50:37,900 --> 00:50:45,580
existing stuff provide the things that

00:50:39,460 --> 00:50:47,400
you need yeah exactly so yeah what I'd

00:50:45,580 --> 00:50:50,890
eat actually is creating a new framework

00:50:47,400 --> 00:50:53,050
but as there are some existing ones so

00:50:50,890 --> 00:50:55,330
actually the philosophy of the Linux

00:50:53,050 --> 00:50:58,030
kernel is if you have some existing

00:50:55,330 --> 00:51:01,900
framework you try to extend it as much

00:50:58,030 --> 00:51:03,400
as possible and every but the changes

00:51:01,900 --> 00:51:07,480
that you are suggesting to runtime p.m.

00:51:03,400 --> 00:51:09,640
and domains they are core changes like

00:51:07,480 --> 00:51:12,070
the assumption that a device exists in a

00:51:09,640 --> 00:51:13,630
domain is core it cannot exist in

00:51:12,070 --> 00:51:15,700
multiple domains or at least it's not

00:51:13,630 --> 00:51:18,130
been thought of that way so there are a

00:51:15,700 --> 00:51:21,520
whole lot of systems that believe that

00:51:18,130 --> 00:51:25,390
though is existed a single domain yeah

00:51:21,520 --> 00:51:27,790
and so you might end up conflicting a

00:51:25,390 --> 00:51:29,770
lot of existing ideas too yeah I agree

00:51:27,790 --> 00:51:31,480
this is why I would say keep your mind

00:51:29,770 --> 00:51:35,130
open about reinventing coming up to

00:51:31,480 --> 00:51:38,470
something neyo rather than just using up

00:51:35,130 --> 00:51:40,890
yeah that's that's what makes it so

00:51:38,470 --> 00:51:40,890
complex

00:51:46,440 --> 00:51:55,359
angry but I guess the benefits of a new

00:51:52,839 --> 00:51:57,940
framework needs to be put down to say

00:51:55,359 --> 00:51:59,470
yes if you make changes to all these

00:51:57,940 --> 00:52:04,750
frameworks and you end up with the

00:51:59,470 --> 00:52:07,869
solution the colonel might look yeah we

00:52:04,750 --> 00:52:13,210
can compare yeah we all continue with

00:52:07,869 --> 00:52:16,330
the hacking session yes so it's after

00:52:13,210 --> 00:52:20,280
lunch and Rome Madrid so yeah you're

00:52:16,330 --> 00:52:20,280
welcome thanks everyone

00:52:30,480 --> 00:52:32,540

YouTube URL: https://www.youtube.com/watch?v=uCTmfrzTbW4


