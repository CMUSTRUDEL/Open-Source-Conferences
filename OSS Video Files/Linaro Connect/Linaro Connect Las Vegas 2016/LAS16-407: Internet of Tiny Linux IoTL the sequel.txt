Title: LAS16-407: Internet of Tiny Linux IoTL the sequel
Publication date: 2016-09-30
Playlist: Linaro Connect Las Vegas 2016
Description: 
	LAS16-407: Internet of Tiny Linux (IoTL): the sequel.
Speakers: Nicolas Pitre
Date: September 29, 2016

★ Session Description ★
This is a discussion on various methods put forward to reduce the size of Linux kernel and user space binaries to make them suitable for small IoT applications, ranging from low hanging fruits to more daring approaches. Results from on-going work will also be presented.

★ Resources ★
Etherpad: pad.linaro.org/p/las16-407
Presentations & Videos: http://connect.linaro.org/resource/las16/las16-407/

★ Event Details ★
Linaro Connect Las Vegas 2016 – #LAS16
September 26-30, 2016
http://www.linaro.org
http://connect.linaro.org
Captions: 
	00:00:07,400 --> 00:00:18,150
do you hear me ok so my name is Nicholas

00:00:14,820 --> 00:00:20,520
betray i've been working at linaro for

00:00:18,150 --> 00:00:24,720
quite a while since the beginning I'm

00:00:20,520 --> 00:00:28,439
now part of the member of the CTO office

00:00:24,720 --> 00:00:32,340
and for the best part of the last year

00:00:28,439 --> 00:00:36,450
or so I've been working on looking at

00:00:32,340 --> 00:00:42,270
ways to reduce the linux kernel for IOT

00:00:36,450 --> 00:00:46,110
purposes so as many of you might know I

00:00:42,270 --> 00:00:48,629
I am blind so I don't see you if you

00:00:46,110 --> 00:00:50,579
have questions please interrupt me don't

00:00:48,629 --> 00:00:55,680
raise your hand it might not be

00:00:50,579 --> 00:00:57,629
efficient so this presentation is follow

00:00:55,680 --> 00:01:02,309
up a sequel of what I've presented

00:00:57,629 --> 00:01:06,950
before this is the result of my latest

00:01:02,309 --> 00:01:16,100
findings that i want to show you to you

00:01:06,950 --> 00:01:20,549
so slide the number three please IOT of

00:01:16,100 --> 00:01:25,799
course we want to have devices that are

00:01:20,549 --> 00:01:28,320
ubiquitous in cost effective they need

00:01:25,799 --> 00:01:31,439
to be reliable and usable and they need

00:01:28,320 --> 00:01:33,930
to be secure most of the time you cannot

00:01:31,439 --> 00:01:38,640
have all of those goals together you

00:01:33,930 --> 00:01:43,430
have to pick two even obviously we want

00:01:38,640 --> 00:01:47,490
to have all them so slide for the

00:01:43,430 --> 00:01:51,420
solution we need to reduce costs by

00:01:47,490 --> 00:01:53,450
avoiding custom softwares so if we can

00:01:51,420 --> 00:01:56,579
reuse based software that people are

00:01:53,450 --> 00:01:58,469
relying on that's why an hour is all

00:01:56,579 --> 00:02:02,369
about to reduce recommendation and have

00:01:58,469 --> 00:02:05,729
common base leveraging open source

00:02:02,369 --> 00:02:11,280
software of course and getting a

00:02:05,729 --> 00:02:15,120
critical mass around a solution and then

00:02:11,280 --> 00:02:20,790
the vendors can spend more time on what

00:02:15,120 --> 00:02:24,959
differentiate them between each other so

00:02:20,790 --> 00:02:25,980
slide number five I'm going quickly over

00:02:24,959 --> 00:02:30,120
those slides because I already

00:02:25,980 --> 00:02:32,580
presenting those before we know that

00:02:30,120 --> 00:02:36,000
linux is a good solution because it has

00:02:32,580 --> 00:02:40,860
a lot of developers there's a large no

00:02:36,000 --> 00:02:43,190
link bait knowledgebase around linux it

00:02:40,860 --> 00:02:45,090
probably has the bed networking stack

00:02:43,190 --> 00:02:53,340
available because there's a lot of

00:02:45,090 --> 00:02:56,790
people looking after it lots of storage

00:02:53,340 --> 00:02:58,800
options of course with IOT it's maybe

00:02:56,790 --> 00:03:01,560
it's not as relevant for servers but

00:02:58,800 --> 00:03:03,500
still if you want to have file system

00:03:01,560 --> 00:03:09,470
support for example it's already there

00:03:03,500 --> 00:03:13,860
and Linux is already widely used in to

00:03:09,470 --> 00:03:17,400
embedded systems for routers or devices

00:03:13,860 --> 00:03:24,780
which are not necessarily tiny but still

00:03:17,400 --> 00:03:29,040
small slide number six please Linux is

00:03:24,780 --> 00:03:31,920
cool but it has drawbacks as well it has

00:03:29,040 --> 00:03:34,500
a lot of features those features are

00:03:31,920 --> 00:03:39,870
mostly tunes for high-end servers in

00:03:34,500 --> 00:03:42,720
large machines usually it's been

00:03:39,870 --> 00:03:46,440
optimized to scale up instead of scaling

00:03:42,720 --> 00:03:49,940
down most of the time the configuration

00:03:46,440 --> 00:03:52,709
system is quite extensive but sometimes

00:03:49,940 --> 00:03:55,920
it might be hard to choose the right

00:03:52,709 --> 00:03:59,450
configuration to have the best optimized

00:03:55,920 --> 00:03:59,450
kernel for your application

00:04:04,420 --> 00:04:13,330
okay slide number seven please one of

00:04:11,090 --> 00:04:17,120
the thing I've been looking so far are

00:04:13,330 --> 00:04:19,280
automatic ways to reduce the kernel so

00:04:17,120 --> 00:04:23,990
we don't have to go left and right and

00:04:19,280 --> 00:04:27,170
trying to cut things manually so one of

00:04:23,990 --> 00:04:31,820
the technique is the linker garbage

00:04:27,170 --> 00:04:35,660
collection coupled with the GCC function

00:04:31,820 --> 00:04:42,260
section and there is also the lto which

00:04:35,660 --> 00:04:48,320
is a link time optimization slay slide 8

00:04:42,260 --> 00:04:51,080
please so what what is el tio el tio is

00:04:48,320 --> 00:04:53,360
a really really cool trick that has been

00:04:51,080 --> 00:04:56,990
implemented in GCC that allows the

00:04:53,360 --> 00:05:00,290
compiler to simply parse the C file and

00:04:56,990 --> 00:05:03,770
store its internal representation into

00:05:00,290 --> 00:05:08,120
the object file and that's all at the

00:05:03,770 --> 00:05:09,860
very final link that the compiler will

00:05:08,120 --> 00:05:14,180
gather all those objects file together

00:05:09,860 --> 00:05:17,140
and then go through all its optimization

00:05:14,180 --> 00:05:20,240
passes like if it was only one C file

00:05:17,140 --> 00:05:24,560
the advantage of this is if for example

00:05:20,240 --> 00:05:28,790
you have a global variable which is

00:05:24,560 --> 00:05:30,410
normally kept as a variable because the

00:05:28,790 --> 00:05:33,950
compiler has no visibility across

00:05:30,410 --> 00:05:36,860
different C files now if the variable is

00:05:33,950 --> 00:05:39,080
set only at one place then the compiler

00:05:36,860 --> 00:05:42,640
might may assume that it's a constant

00:05:39,080 --> 00:05:46,880
and optimize everything around that fact

00:05:42,640 --> 00:05:49,670
so if for example some functions are

00:05:46,880 --> 00:05:52,400
never called because the variable won't

00:05:49,670 --> 00:05:54,860
be set the right condition the compiler

00:05:52,400 --> 00:05:57,140
may just optimize all that code away

00:05:54,860 --> 00:05:59,780
even if it originally from a different

00:05:57,140 --> 00:06:06,050
see file so this is really really

00:05:59,780 --> 00:06:10,639
effective at removing unused code slide

00:06:06,050 --> 00:06:16,039
9 please LTA was cool but

00:06:10,639 --> 00:06:20,210
one of its drawback is the built time so

00:06:16,039 --> 00:06:28,099
here I have a table of some at a build

00:06:20,210 --> 00:06:30,819
test that I did so if we take one one

00:06:28,099 --> 00:06:34,819
particular configuration for the colonel

00:06:30,819 --> 00:06:36,909
on my test machine without lto it's

00:06:34,819 --> 00:06:39,650
about a little less than five minutes

00:06:36,909 --> 00:06:45,169
with LT oh it's the ball of the time

00:06:39,650 --> 00:06:47,539
it's more than 10 minutes and probably

00:06:45,169 --> 00:06:50,419
the worst drawback is that if you do a

00:06:47,539 --> 00:06:54,289
single change in the kernel for example

00:06:50,419 --> 00:06:58,340
you just want to add a new line in the

00:06:54,289 --> 00:07:01,310
print a string that single change will

00:06:58,340 --> 00:07:04,939
require a recompile of about eight

00:07:01,310 --> 00:07:07,009
minutes instead of 12 seconds so

00:07:04,939 --> 00:07:09,199
obviously 4 first first certain

00:07:07,009 --> 00:07:11,150
circumstances LT you might not be the

00:07:09,199 --> 00:07:14,270
right thing especially if you're doing

00:07:11,150 --> 00:07:16,490
your debugging you you test something it

00:07:14,270 --> 00:07:20,270
crashes your recompile all the time

00:07:16,490 --> 00:07:23,150
that's something I do move a print key

00:07:20,270 --> 00:07:30,129
around per likha lto will just get in

00:07:23,150 --> 00:07:33,849
the way in this case slide 10 please so

00:07:30,129 --> 00:07:37,669
the alternative to LT you would be the

00:07:33,849 --> 00:07:41,089
what a call I call the poor man a poor

00:07:37,669 --> 00:07:45,939
man's lto which is the GCC function

00:07:41,089 --> 00:07:50,899
section what does what it does is to

00:07:45,939 --> 00:07:55,719
assign a different health elf section to

00:07:50,899 --> 00:07:58,550
every function so in the example here

00:07:55,719 --> 00:08:01,370
function foo would get that text that

00:07:58,550 --> 00:08:07,689
foo function bar will get that text that

00:08:01,370 --> 00:08:07,689
bar and same thing for the main function

00:08:08,500 --> 00:08:16,639
slide 11 please now what the linker does

00:08:13,669 --> 00:08:20,300
is to garbage collect every section

00:08:16,639 --> 00:08:23,480
which is not referenced so in the

00:08:20,300 --> 00:08:27,300
example here if we build the

00:08:23,480 --> 00:08:30,390
the code that we had before we can see

00:08:27,300 --> 00:08:38,400
that text that bar section is gone

00:08:30,390 --> 00:08:41,550
because it has no reference to it now if

00:08:38,400 --> 00:08:47,460
we apply this to the colonel slide 12

00:08:41,550 --> 00:08:52,320
please so I I used a hacked version of

00:08:47,460 --> 00:08:58,500
the colonel to compare the effectiveness

00:08:52,320 --> 00:09:00,450
of those solutions so if we start with

00:08:58,500 --> 00:09:04,440
my base kernel which is the all no

00:09:00,450 --> 00:09:06,330
config the baseline would be one hundred

00:09:04,440 --> 00:09:10,860
percent because that that's more

00:09:06,330 --> 00:09:13,740
starting point if I stop out all the

00:09:10,860 --> 00:09:17,270
system calls in theory there's a bunch

00:09:13,740 --> 00:09:20,400
of code which are not reference anymore

00:09:17,270 --> 00:09:23,870
without any of those who have reduction

00:09:20,400 --> 00:09:26,690
techniques the colonel will shrink to

00:09:23,870 --> 00:09:31,200
ninety-four percent of its original size

00:09:26,690 --> 00:09:33,450
if we bring lto into the picture it's

00:09:31,200 --> 00:09:41,970
down to fifty six percent of the

00:09:33,450 --> 00:09:47,280
original size but if we see here with

00:09:41,970 --> 00:09:49,530
the garbage collecting the function

00:09:47,280 --> 00:09:52,740
section and so on it's a little less

00:09:49,530 --> 00:09:56,640
effective sixty-four percent but the

00:09:52,740 --> 00:09:59,250
advantage is the bill time so probably

00:09:56,640 --> 00:10:01,590
what we want is to support both in the

00:09:59,250 --> 00:10:05,880
kernel having both options if we can

00:10:01,590 --> 00:10:09,570
develop with GC section and then having

00:10:05,880 --> 00:10:11,910
the final build using lvo and having

00:10:09,570 --> 00:10:15,300
both might also help if there is a

00:10:11,910 --> 00:10:17,480
regression and lto support or things

00:10:15,300 --> 00:10:17,480
like that

00:10:24,240 --> 00:10:35,110
okay slide 13 please now the problem is

00:10:31,930 --> 00:10:37,300
we have this nice tool that is supposed

00:10:35,110 --> 00:10:41,670
to remove all the code which is not

00:10:37,300 --> 00:10:45,340
reference why the hell is there still

00:10:41,670 --> 00:10:51,280
480 case of kernel code when everything

00:10:45,340 --> 00:10:57,450
has been configured out it's something

00:10:51,280 --> 00:10:59,740
what I call anchors slide 14 please

00:10:57,450 --> 00:11:05,050
there are many anchors in the colonel

00:10:59,740 --> 00:11:10,210
those are points where we enforce a

00:11:05,050 --> 00:11:15,190
reference to some code for example all

00:11:10,210 --> 00:11:18,940
the init calls in the linker file even

00:11:15,190 --> 00:11:21,700
if we do lto or gz sections we have to

00:11:18,940 --> 00:11:24,550
tell the linker those entry points are

00:11:21,700 --> 00:11:26,890
being referenced somewhere even though

00:11:24,550 --> 00:11:29,890
they are not explicitly referenced we

00:11:26,890 --> 00:11:33,580
gathered them into a table the linker

00:11:29,890 --> 00:11:35,970
might might not see any direct reference

00:11:33,580 --> 00:11:39,670
to them so we have to explicitly tell

00:11:35,970 --> 00:11:43,680
the linker all the init calls don't give

00:11:39,670 --> 00:11:43,680
them away I want to execute them

00:11:50,410 --> 00:11:58,910
if we look at how many unique URLs we

00:11:53,630 --> 00:12:01,670
might have it's like 15 please so you

00:11:58,910 --> 00:12:05,540
see how it's easy to find how many Cisco

00:12:01,670 --> 00:12:08,209
any cars we can have error I'm still

00:12:05,540 --> 00:12:14,390
talking about my all no config colonel

00:12:08,209 --> 00:12:16,640
it has 49 in it calls I'm sure that for

00:12:14,390 --> 00:12:18,380
a kernel which is still supposed to do

00:12:16,640 --> 00:12:22,610
nothing since everything has been

00:12:18,380 --> 00:12:25,370
configured out having 949 in it calls is

00:12:22,610 --> 00:12:27,980
probably a bit high especially since

00:12:25,370 --> 00:12:30,890
most of them are there to probe things

00:12:27,980 --> 00:12:37,640
set of things that we're probably not

00:12:30,890 --> 00:12:45,019
going to use okay other examples slide

00:12:37,640 --> 00:12:47,329
16 all the early param parsers are using

00:12:45,019 --> 00:12:49,670
the same technique they're gathered into

00:12:47,329 --> 00:12:52,279
a table and we have to tell the linker

00:12:49,670 --> 00:12:54,500
don't get rid of them because we don't

00:12:52,279 --> 00:12:57,680
know we might be able to parse things

00:12:54,500 --> 00:13:02,180
from the command line or from module

00:12:57,680 --> 00:13:03,949
parents parameters so those are being

00:13:02,180 --> 00:13:08,029
gathered in the colonel even though we

00:13:03,949 --> 00:13:13,519
might not use them so again we have for

00:13:08,029 --> 00:13:17,540
example 47 entries of one kind and 12

00:13:13,519 --> 00:13:20,199
other entries here there's probably

00:13:17,540 --> 00:13:26,240
something we can do about those things

00:13:20,199 --> 00:13:29,810
if we are talking about iut I'm I would

00:13:26,240 --> 00:13:32,329
be surprised if users will be asked to

00:13:29,810 --> 00:13:37,459
and to change their colonel comment line

00:13:32,329 --> 00:13:40,339
right so probably we could during the

00:13:37,459 --> 00:13:41,420
build of the colonel parse the kind of

00:13:40,339 --> 00:13:45,079
end line that we want to pass the

00:13:41,420 --> 00:13:49,120
colonel and hard code those parameters

00:13:45,079 --> 00:13:49,120
in the colonel and some at some point

00:13:50,290 --> 00:14:02,920
okay slide this 17 another source of

00:13:55,690 --> 00:14:08,730
anchors export symbols last connect I

00:14:02,920 --> 00:14:11,769
did a presentation extensive I

00:14:08,730 --> 00:14:16,569
extensively about those exports symbols

00:14:11,769 --> 00:14:21,040
because there are all over the place if

00:14:16,569 --> 00:14:23,139
you do want support for a module in your

00:14:21,040 --> 00:14:28,889
Colonel you have export symbols

00:14:23,139 --> 00:14:33,430
everywhere so the idea is to be able to

00:14:28,889 --> 00:14:35,290
remove some or most of the export

00:14:33,430 --> 00:14:39,269
symbols that you're not going to use if

00:14:35,290 --> 00:14:42,420
you have only a handful set of modules I

00:14:39,269 --> 00:14:44,709
doubt that you will require the

00:14:42,420 --> 00:14:47,470
thousands of export symbols that you

00:14:44,709 --> 00:14:50,680
have in the kernel and yet those symbols

00:14:47,470 --> 00:14:53,230
are the export symbol statement is there

00:14:50,680 --> 00:14:56,560
to tell the linker don't get rid of that

00:14:53,230 --> 00:15:02,370
function because sometimes maybe a

00:14:56,560 --> 00:15:08,260
module will want to link against this so

00:15:02,370 --> 00:15:09,760
what I i sent upstream in for a linux

00:15:08,260 --> 00:15:14,230
for dot seven there's a new

00:15:09,760 --> 00:15:16,839
configuration that allows you to to tell

00:15:14,230 --> 00:15:20,560
the belt system i want only those

00:15:16,839 --> 00:15:26,199
exports symbol that my modules require

00:15:20,560 --> 00:15:28,839
and afterwards lto orgy c section can

00:15:26,199 --> 00:15:31,240
get rid of all the functions that are

00:15:28,839 --> 00:15:37,209
normally exported to symbols but are not

00:15:31,240 --> 00:15:43,740
required for your module set so slide 18

00:15:37,209 --> 00:15:47,019
please here's an example of a small

00:15:43,740 --> 00:15:54,430
configuration Colonel configuration got

00:15:47,019 --> 00:15:57,069
I used to illustrate this before the

00:15:54,430 --> 00:16:00,550
patch not the patch but that this

00:15:57,069 --> 00:16:02,740
function was enabled we have more than

00:16:00,550 --> 00:16:03,820
four five thousand symbols being

00:16:02,740 --> 00:16:06,220
exported

00:16:03,820 --> 00:16:12,150
with the set of modules being configured

00:16:06,220 --> 00:16:12,150
in only 52 symbols will were required

00:16:13,770 --> 00:16:23,500
and you can see the reduction of the

00:16:16,960 --> 00:16:26,740
colonel this made at thirteen point six

00:16:23,500 --> 00:16:31,870
percent reduction of the kernel which is

00:16:26,740 --> 00:16:34,150
nice here is if I disabled module

00:16:31,870 --> 00:16:39,070
support entirely then the colonel will

00:16:34,150 --> 00:16:44,440
shrink by 13.9 percent that means with

00:16:39,070 --> 00:16:47,940
this the overhead of module support went

00:16:44,440 --> 00:16:50,460
from thirteen percent of the colonel to

00:16:47,940 --> 00:16:54,220
zero-point-three percent of the colonel

00:16:50,460 --> 00:16:57,610
now one one might ask why would I use

00:16:54,220 --> 00:17:00,010
modules with IOT purposes let's say you

00:16:57,610 --> 00:17:04,360
have very very small amount of memory

00:17:00,010 --> 00:17:07,530
and you want to do firmware update maybe

00:17:04,360 --> 00:17:10,900
at that point you will require flash

00:17:07,530 --> 00:17:15,630
right support so that can be done into a

00:17:10,900 --> 00:17:18,459
module that you won't need otherwise and

00:17:15,630 --> 00:17:21,040
when you're no more normal operation you

00:17:18,459 --> 00:17:23,530
might have another modules to do other /

00:17:21,040 --> 00:17:29,310
other operation in your device so it's a

00:17:23,530 --> 00:17:32,590
bit like what we call overlays in

00:17:29,310 --> 00:17:35,050
ancient times when we used us and those

00:17:32,590 --> 00:17:40,960
those systems with very small amount of

00:17:35,050 --> 00:17:49,830
memory I'm giving it with my age I

00:17:40,960 --> 00:17:49,830
you're right thank ok slide 19

00:17:50,310 --> 00:18:00,880
at some point automatic reduction might

00:17:55,390 --> 00:18:05,170
not do the trick we need to have sub

00:18:00,880 --> 00:18:08,740
system specific trimming some example of

00:18:05,170 --> 00:18:10,810
things that have been done already we

00:18:08,740 --> 00:18:16,690
can already remove the blocks of system

00:18:10,810 --> 00:18:19,720
entirely we can remove and DP support we

00:18:16,690 --> 00:18:22,120
can remove capabilities from the colonel

00:18:19,720 --> 00:18:24,360
we can remove user support from the

00:18:22,120 --> 00:18:27,460
colonel so everything is run as root and

00:18:24,360 --> 00:18:29,320
that's probably typical of the small

00:18:27,460 --> 00:18:32,290
embedded systems everything is run as

00:18:29,320 --> 00:18:36,760
root so why carry the support for user

00:18:32,290 --> 00:18:40,620
permissions and group and so on we can

00:18:36,760 --> 00:18:40,620
remove prem ke from the colonel

00:18:40,680 --> 00:18:47,560
eventually if you want to fit your your

00:18:44,340 --> 00:18:49,900
application into a tiny device it

00:18:47,560 --> 00:18:54,340
probably won't have any way to output

00:18:49,900 --> 00:18:59,160
strings to the user so why just remove

00:18:54,340 --> 00:19:06,450
print k support so we need more more

00:18:59,160 --> 00:19:12,420
more options like this slide 20 please

00:19:06,450 --> 00:19:19,330
what to look for here is an example with

00:19:12,420 --> 00:19:23,680
my tiny config we can look at the size

00:19:19,330 --> 00:19:26,290
of the object files from subsystems so

00:19:23,680 --> 00:19:31,290
I've sorted them out here so you have a

00:19:26,290 --> 00:19:34,750
list of the size of some steps subsystem

00:19:31,290 --> 00:19:36,910
here keep in mind that we're still

00:19:34,750 --> 00:19:40,090
talking about it tiny configure know

00:19:36,910 --> 00:19:42,940
which is very close to all no country

00:19:40,090 --> 00:19:45,790
colonel so there is a lot of code here

00:19:42,940 --> 00:19:55,510
that no one ever bothered to can

00:19:45,790 --> 00:19:58,600
configure out slide 21 please so I

00:19:55,510 --> 00:20:02,859
picked one at random let's look at the

00:19:58,600 --> 00:20:06,320
time subsystem POSIX timers

00:20:02,859 --> 00:20:09,950
there's a huge amount of code to support

00:20:06,320 --> 00:20:15,369
po6 timers and especially one type of

00:20:09,950 --> 00:20:21,409
timer which is the POSIX cpu clock timer

00:20:15,369 --> 00:20:24,349
removing that we still can keep the

00:20:21,409 --> 00:20:29,269
basic function of the timers the most

00:20:24,349 --> 00:20:33,229
used one for example the real time and

00:20:29,269 --> 00:20:41,509
the monotonic clocks can be preserved

00:20:33,229 --> 00:20:44,539
very with very little code slide 22 that

00:20:41,509 --> 00:20:49,070
allowed me to save 12 kilobytes of

00:20:44,539 --> 00:20:50,809
Colonel curl memory and a nice thing

00:20:49,070 --> 00:20:55,009
about this is that standard distribution

00:20:50,809 --> 00:20:59,389
still build internal surprisingly not

00:20:55,009 --> 00:21:04,419
many things uses POSIX timers but no one

00:20:59,389 --> 00:21:04,419
until now butter to make them optional

00:21:07,389 --> 00:21:10,389
okay

00:21:12,440 --> 00:21:26,210
slide 23 so we can ask ourselves if the

00:21:21,120 --> 00:21:26,210
in the all new kernel pranky is removed

00:21:26,360 --> 00:21:32,970
why have we still two point five

00:21:29,520 --> 00:21:39,990
kilobytes of printing code that's

00:21:32,970 --> 00:21:42,740
probably an easy one slide 24 we still

00:21:39,990 --> 00:21:48,899
have four kilobytes of log locking code

00:21:42,740 --> 00:21:51,419
this is a single processor it's not SMP

00:21:48,899 --> 00:21:55,440
in theory a lot of the locking coaches

00:21:51,419 --> 00:22:06,539
just go away probably there are some SMP

00:21:55,440 --> 00:22:12,750
remnants in there slide 25 now 18

00:22:06,539 --> 00:22:14,610
kilobytes for interrupt support I don't

00:22:12,750 --> 00:22:17,159
think that we need that much code in

00:22:14,610 --> 00:22:20,220
some embedded systems most of the time

00:22:17,159 --> 00:22:26,309
we have four five six interrupt lines

00:22:20,220 --> 00:22:31,320
they are statically assigned we know how

00:22:26,309 --> 00:22:34,669
the he behaved most of the time it's

00:22:31,320 --> 00:22:38,730
really directly connected to the CPU I

00:22:34,669 --> 00:22:41,399
really doubt that we need 18 kilobytes

00:22:38,730 --> 00:22:52,980
of our cue infrastructure to support

00:22:41,399 --> 00:22:56,220
this right slide 26 now all the drivers

00:22:52,980 --> 00:23:02,090
I've been configured out why the hell is

00:22:56,220 --> 00:23:02,090
there still 75 kilobytes of driver code

00:23:04,890 --> 00:23:16,580
slide 27 80 kilobytes of memory

00:23:11,610 --> 00:23:20,970
management this is a new no mm ooh

00:23:16,580 --> 00:23:27,840
configuration so in theory memory

00:23:20,970 --> 00:23:33,380
management should be very trivial slide

00:23:27,840 --> 00:23:36,210
28 and we're in Vegas here's the jackpot

00:23:33,380 --> 00:23:41,820
all the file system have been configured

00:23:36,210 --> 00:23:48,900
out why do we still have 110 kilobytes

00:23:41,820 --> 00:23:52,890
of file system support code so all those

00:23:48,900 --> 00:23:55,830
things really add the add up for things

00:23:52,890 --> 00:24:01,590
in theory din if we think of a very very

00:23:55,830 --> 00:24:04,740
strictly control embedded system for IOT

00:24:01,590 --> 00:24:07,050
for example with very low memory all

00:24:04,740 --> 00:24:19,290
those things are most likely not going

00:24:07,050 --> 00:24:24,540
to be used so slide 29 trimming those

00:24:19,290 --> 00:24:28,070
things away won't cut it all the time we

00:24:24,540 --> 00:24:31,980
might have to look for substitutions for

00:24:28,070 --> 00:24:39,660
example we already have three memory

00:24:31,980 --> 00:24:43,020
allocators slabs slob and slob that's

00:24:39,660 --> 00:24:46,140
the slob SLO be a locator is there its

00:24:43,020 --> 00:24:49,470
purpose is to be very simple with very

00:24:46,140 --> 00:24:51,420
little code and to be small so this is

00:24:49,470 --> 00:24:54,000
most appropriate for embedded systems

00:24:51,420 --> 00:25:01,710
and I'm sure it's already used in those

00:24:54,000 --> 00:25:05,760
circumstances now it's probably the time

00:25:01,710 --> 00:25:16,600
that I must be the most daring

00:25:05,760 --> 00:25:22,140
slight 30 yeah right what about the

00:25:16,600 --> 00:25:22,140
scheduler should like we're way now this

00:25:24,030 --> 00:25:31,780
is a very controversial topic many

00:25:28,299 --> 00:25:34,179
people tried before to suggest that we

00:25:31,780 --> 00:25:40,840
have pluggable schedulers or Alton

00:25:34,179 --> 00:25:43,570
schedulers and so on so why not get in

00:25:40,840 --> 00:25:45,820
in that pool of people and get flame and

00:25:43,570 --> 00:25:53,320
so on so i tried italy let's have some

00:25:45,820 --> 00:25:59,400
fun slide 31 let's look at the sched

00:25:53,320 --> 00:26:05,860
existing scheduler it has close to

00:25:59,400 --> 00:26:13,480
30,000 lines it uses 140 kilobytes of

00:26:05,860 --> 00:26:17,470
memory that's a lot especially if we are

00:26:13,480 --> 00:26:20,049
talking about an embedded system so of

00:26:17,470 --> 00:26:22,600
course to be fair that amount of memory

00:26:20,049 --> 00:26:24,640
is with a standard configuration it's

00:26:22,600 --> 00:26:26,890
not the tiny configuration but it's just

00:26:24,640 --> 00:26:31,840
to illustrate that the current scheduler

00:26:26,890 --> 00:26:42,340
is quite complex so this is clearly not

00:26:31,840 --> 00:26:47,409
for small system so slight 32 let's try

00:26:42,340 --> 00:26:51,400
to make the slob of scheduler so my

00:26:47,409 --> 00:26:57,340
goals were to have the smallest codebase

00:26:51,400 --> 00:27:02,049
possible no frills I don't want to have

00:26:57,340 --> 00:27:05,340
any configuration in the scheduler let's

00:27:02,049 --> 00:27:09,940
keep in mind this is for an IOT device

00:27:05,340 --> 00:27:13,960
it probably have to schedule one task

00:27:09,940 --> 00:27:16,169
maybe two three four threads and that's

00:27:13,960 --> 00:27:16,169
all

00:27:16,539 --> 00:27:25,450
let's dispense with SMP support and have

00:27:22,029 --> 00:27:28,580
simplistic schedule scheduling policies

00:27:25,450 --> 00:27:35,059
no user interface I said minimal but I

00:27:28,580 --> 00:27:38,409
try to remove all of them and the idea

00:27:35,059 --> 00:27:43,129
is to still have a scheduler which is

00:27:38,409 --> 00:27:45,409
correct with regard to its behavior so I

00:27:43,129 --> 00:27:48,259
still wanted to have something that can

00:27:45,409 --> 00:27:50,600
run the standard kernel and standard

00:27:48,259 --> 00:27:53,419
distribution although a won't scale as

00:27:50,600 --> 00:27:56,570
as much but at least it can be validated

00:27:53,419 --> 00:27:58,639
with existing code did you keep

00:27:56,570 --> 00:28:01,100
priorities are did you remove them to

00:27:58,639 --> 00:28:06,940
burning did you keep priorities and the

00:28:01,100 --> 00:28:17,139
scheduler I did some kind of priority

00:28:06,940 --> 00:28:20,809
but it's not configurable and as

00:28:17,139 --> 00:28:23,360
probably the the most important criteria

00:28:20,809 --> 00:28:27,950
is to leave the existing scheduler alone

00:28:23,360 --> 00:28:32,119
I don't want to go play in there it's a

00:28:27,950 --> 00:28:37,129
lot of people rely on it it's highly

00:28:32,119 --> 00:28:40,460
complex it's somewhat fragile as soon as

00:28:37,129 --> 00:28:43,309
someone touches something there someone

00:28:40,460 --> 00:28:45,559
else somewhere will see regressions so

00:28:43,309 --> 00:28:53,440
obviously trying to shrink that current

00:28:45,559 --> 00:28:56,960
that scheduler is suicide so slide 33

00:28:53,440 --> 00:29:00,379
aiya did an experiment with an alternate

00:28:56,960 --> 00:29:04,249
schedule I started from BFS which is

00:29:00,379 --> 00:29:06,379
already more Sam sample is simpler than

00:29:04,249 --> 00:29:11,149
the existing scheduler at least I was

00:29:06,379 --> 00:29:14,299
able to wrap my brain around I stripped

00:29:11,149 --> 00:29:17,419
almost two third of the existing code

00:29:14,299 --> 00:29:21,350
base so i removed everything that I I

00:29:17,419 --> 00:29:25,119
thought it was it was not essential it

00:29:21,350 --> 00:29:25,119
has a single policy

00:29:27,799 --> 00:29:36,419
sleet 34 please so I ended up with a

00:29:33,839 --> 00:29:41,700
patch that will add only three thousand

00:29:36,419 --> 00:29:46,919
lines so it can be reviewed it can be

00:29:41,700 --> 00:29:51,690
understood and it at least compiles to

00:29:46,919 --> 00:29:54,589
for example my might my tiny config

00:29:51,690 --> 00:30:00,239
again I was able to reduce the old

00:29:54,589 --> 00:30:03,659
scheduler subsystem in half and it still

00:30:00,239 --> 00:30:05,759
boot standard distributions I was able

00:30:03,659 --> 00:30:09,059
to boot to Federer on top of that Duke

00:30:05,759 --> 00:30:16,200
colonel compilation and so on it works

00:30:09,059 --> 00:30:22,019
now we're in Vegas bets are open if this

00:30:16,200 --> 00:30:30,239
is going to ever get into mainline slide

00:30:22,019 --> 00:30:33,269
35 another thing we can have a look at

00:30:30,239 --> 00:30:38,389
is the networking stack that's another

00:30:33,269 --> 00:30:41,669
big part of the kernel of course

00:30:38,389 --> 00:30:44,489
internet of things there's the keyword

00:30:41,669 --> 00:30:49,259
internet there so we need network

00:30:44,489 --> 00:30:51,359
connectivity what can we do with the

00:30:49,259 --> 00:30:54,809
existing stack maybe we can have

00:30:51,359 --> 00:30:59,190
something that keeps only the socket API

00:30:54,809 --> 00:31:01,679
alive let's get rid of all the routing

00:30:59,190 --> 00:31:06,899
all the defensive features that are

00:31:01,679 --> 00:31:10,049
there to to route packets at 10 gigabits

00:31:06,899 --> 00:31:14,039
per second with traffic control and

00:31:10,049 --> 00:31:19,619
everything an IOT device probably

00:31:14,039 --> 00:31:23,190
doesn't need this of course Samba won't

00:31:19,619 --> 00:31:25,589
work if we remove many features of the

00:31:23,190 --> 00:31:29,539
stack but that's not the point the point

00:31:25,589 --> 00:31:33,179
is probably to gather some data from

00:31:29,539 --> 00:31:41,040
from sensors and just send them to the

00:31:33,179 --> 00:31:42,990
cloud and once again the idea is to

00:31:41,040 --> 00:31:48,000
compatible although we have a small

00:31:42,990 --> 00:31:51,060
subset of the current API we still want

00:31:48,000 --> 00:31:54,660
to remain compatible with the full stack

00:31:51,060 --> 00:31:59,970
in order to test our application on the

00:31:54,660 --> 00:32:02,010
full stack and compare things may be the

00:31:59,970 --> 00:32:04,800
ultimate solution will be to have only

00:32:02,010 --> 00:32:07,980
raw sockets and have a pass through 22

00:32:04,800 --> 00:32:11,670
hardware devices and having the IP stack

00:32:07,980 --> 00:32:24,240
in userspace highly optimized for the

00:32:11,670 --> 00:32:26,730
application using it slide 36 VFS that's

00:32:24,240 --> 00:32:30,840
another part where we probably can't

00:32:26,730 --> 00:32:33,810
save a lot of code once again let's put

00:32:30,840 --> 00:32:39,480
ourselves in the mind of a very tiny

00:32:33,810 --> 00:32:43,500
device there's only one task no no peril

00:32:39,480 --> 00:32:46,620
lookups no buffering no nothing let's go

00:32:43,500 --> 00:32:53,900
to the bare minimum write and read

00:32:46,620 --> 00:32:57,270
support so probably that we can have an

00:32:53,900 --> 00:32:59,550
alternate VFS layer that would bypass a

00:32:57,270 --> 00:33:04,320
lot of the fancy features that makes

00:32:59,550 --> 00:33:06,690
Linux so performance on servers may be

00:33:04,320 --> 00:33:09,720
the ultimate solution was again would be

00:33:06,690 --> 00:33:12,270
to have only raw access to block devices

00:33:09,720 --> 00:33:21,290
and having file system support and user

00:33:12,270 --> 00:33:28,320
space a bit like em tools does so slide

00:33:21,290 --> 00:33:32,550
37 this is the vision that I have for

00:33:28,320 --> 00:33:38,610
this probably you've heard of Zephyr

00:33:32,550 --> 00:33:41,460
this week I I really appreciate what is

00:33:38,610 --> 00:33:43,710
f er is trying to achieve of course we

00:33:41,460 --> 00:33:47,130
need to have something for very very

00:33:43,710 --> 00:33:49,230
very small systems let's say is effort

00:33:47,130 --> 00:33:52,410
they say that it runs into 8 kilobytes

00:33:49,230 --> 00:33:52,980
of RAM I don't pretend that Linux could

00:33:52,410 --> 00:33:55,860
ever do

00:33:52,980 --> 00:33:59,280
it is so there's a there's a space for

00:33:55,860 --> 00:34:04,200
Zephyr of course but if we go to let's

00:33:59,280 --> 00:34:07,470
say 128 kilobytes of RAM maybe maybe

00:34:04,200 --> 00:34:10,859
that if we have a very small user space

00:34:07,470 --> 00:34:14,399
application that uses 10 system calls or

00:34:10,859 --> 00:34:18,330
so and it does very simple memory

00:34:14,399 --> 00:34:22,919
allocation and has very small needs for

00:34:18,330 --> 00:34:27,109
networking maybe we can have a setup

00:34:22,919 --> 00:34:30,450
that reuses all the existing Linux

00:34:27,109 --> 00:34:34,889
interfaces all the API is for userspace

00:34:30,450 --> 00:34:38,960
and for drivers and have a kernel which

00:34:34,889 --> 00:34:41,399
is highly optimized for the very minimum

00:34:38,960 --> 00:34:46,169
level of support that such an

00:34:41,399 --> 00:34:50,760
application may require and the idea

00:34:46,169 --> 00:34:53,300
there is by doing so we can have such

00:34:50,760 --> 00:34:58,050
user space application that would run

00:34:53,300 --> 00:35:01,400
either in your 128 kilobytes system or

00:34:58,050 --> 00:35:05,100
on your full fledge workstation

00:35:01,400 --> 00:35:08,700
unchanged because we're using the same

00:35:05,100 --> 00:35:13,980
interfaces that so many people on this

00:35:08,700 --> 00:35:16,310
planet are used to work with and if you

00:35:13,980 --> 00:35:19,080
use the same application and most and

00:35:16,310 --> 00:35:23,210
probably yet you won't even have to

00:35:19,080 --> 00:35:25,380
recompile it it will run on your fold

00:35:23,210 --> 00:35:28,170
workstation with all the tools the

00:35:25,380 --> 00:35:34,500
debugging tools that we have the tracers

00:35:28,170 --> 00:35:37,470
and so on and the same can be applied

00:35:34,500 --> 00:35:38,510
for those different subsystem that we

00:35:37,470 --> 00:35:42,290
can

00:35:38,510 --> 00:35:47,120
work in the kernel for example if if i

00:35:42,290 --> 00:35:49,100
take my my my scheduler experiment i can

00:35:47,120 --> 00:35:52,280
swap between the regular scheduler and

00:35:49,100 --> 00:35:55,730
mice my tiny scheduler test that

00:35:52,280 --> 00:35:58,970
everything works i can debug it on any

00:35:55,730 --> 00:36:02,090
hardware i can run it on any hardware

00:35:58,970 --> 00:36:04,010
and it can be done by anyone because

00:36:02,090 --> 00:36:07,010
it's not dependent on the hardware that

00:36:04,010 --> 00:36:12,950
you have you might al well as well test

00:36:07,010 --> 00:36:15,470
your VFS replacement or bypass onto your

00:36:12,950 --> 00:36:22,930
workstation and of course it won't scale

00:36:15,470 --> 00:36:25,970
as as well but it should just work and

00:36:22,930 --> 00:36:29,150
by doing so we benefit from the

00:36:25,970 --> 00:36:35,840
extensive hardware coverage that linux

00:36:29,150 --> 00:36:38,420
already has now this might work only if

00:36:35,840 --> 00:36:41,870
all those things are done upstream I

00:36:38,420 --> 00:36:44,360
know that some people did did work on

00:36:41,870 --> 00:36:47,240
those things they were able to shrink

00:36:44,360 --> 00:36:50,870
the colonel very very small but those

00:36:47,240 --> 00:36:58,040
remained out of three hacks and they are

00:36:50,870 --> 00:37:01,150
just rutting there so that's it for me

00:36:58,040 --> 00:37:01,150
do you have questions

00:37:03,500 --> 00:37:10,980
Thanks quick one and I'm I'm old enough

00:37:06,150 --> 00:37:12,480
to remember overlays as well I think

00:37:10,980 --> 00:37:15,180
that's all great stuff as you know

00:37:12,480 --> 00:37:18,000
that's why I like you doing it I think

00:37:15,180 --> 00:37:20,160
we need some hardware as arms pointed

00:37:18,000 --> 00:37:22,830
out to to get this kind of getting

00:37:20,160 --> 00:37:25,200
during these changing the colonel will

00:37:22,830 --> 00:37:26,700
rot and people cannot see the reason for

00:37:25,200 --> 00:37:28,730
them all right so I think we need some

00:37:26,700 --> 00:37:31,950
hardware in my mind that's probably a

00:37:28,730 --> 00:37:35,340
hardened core with fpga around in pretty

00:37:31,950 --> 00:37:40,410
small amounts of SRAM what what sort of

00:37:35,340 --> 00:37:44,910
size memory system would you need well

00:37:40,410 --> 00:37:48,680
like I said my gut feeling is that we

00:37:44,910 --> 00:37:53,430
should aim for 128 kilobytes of

00:37:48,680 --> 00:37:56,280
available memory it of course we won't

00:37:53,430 --> 00:37:59,790
get there in the first try fortunately

00:37:56,280 --> 00:38:03,030
there are development platforms from

00:37:59,790 --> 00:38:09,560
some cortex-m implementation from st i

00:38:03,030 --> 00:38:13,109
think which have 512 kilobytes of SRAM

00:38:09,560 --> 00:38:15,900
so that would be probably the first goal

00:38:13,109 --> 00:38:19,920
and once we are there we just keep going

00:38:15,900 --> 00:38:23,220
down so I know that some people use

00:38:19,920 --> 00:38:26,760
upstream Linux in products with a couple

00:38:23,220 --> 00:38:29,220
of patches with two megabytes so those

00:38:26,760 --> 00:38:31,530
are basically the same trips that you

00:38:29,220 --> 00:38:33,990
mentioned with have half a megabyte but

00:38:31,530 --> 00:38:35,550
they're using external SRAM and that

00:38:33,990 --> 00:38:38,550
enables a couple of applications that

00:38:35,550 --> 00:38:40,290
you can't have with DRM already like

00:38:38,550 --> 00:38:44,910
because the power consumption is much

00:38:40,290 --> 00:38:48,600
lower having do you rem but the 512

00:38:44,910 --> 00:38:51,090
kilobytes target I think that's very

00:38:48,600 --> 00:38:55,859
interesting because it requires a number

00:38:51,090 --> 00:38:58,800
of changes that we don't have like some

00:38:55,859 --> 00:39:01,859
of the things you mentioned are easy

00:38:58,800 --> 00:39:04,710
enough to do that we can just try how

00:39:01,859 --> 00:39:06,380
much we can we have to do to get into

00:39:04,710 --> 00:39:10,080
the cavern artwork kilobyte space and

00:39:06,380 --> 00:39:13,130
try to do something useful with them the

00:39:10,080 --> 00:39:14,950
tiny config colonel right now is down to

00:39:13,130 --> 00:39:21,040
480 k

00:39:14,950 --> 00:39:26,560
and that is text + data all right that's

00:39:21,040 --> 00:39:29,380
not not just data because of you if you

00:39:26,560 --> 00:39:34,570
use execute in place a lot of the memory

00:39:29,380 --> 00:39:37,540
would be in nor flash and only the data

00:39:34,570 --> 00:39:41,740
data section and PSS would be required

00:39:37,540 --> 00:39:44,170
to live in an actual ram it's probably

00:39:41,740 --> 00:39:47,070
mostly it is the case in most of the

00:39:44,170 --> 00:39:51,250
time for for very small microcontrollers

00:39:47,070 --> 00:39:56,020
most of the text executable is always in

00:39:51,250 --> 00:39:58,480
rum or flash so that that's one thing

00:39:56,020 --> 00:40:01,060
we're probably we need to revive the xyp

00:39:58,480 --> 00:40:03,430
support but it's probably not that far

00:40:01,060 --> 00:40:07,750
yes it used to work it's just that

00:40:03,430 --> 00:40:09,400
nobody looked after it recently yes it

00:40:07,750 --> 00:40:12,550
doesn't work for any of the mb 7

00:40:09,400 --> 00:40:13,960
platforms because we lost the

00:40:12,550 --> 00:40:16,810
functionality with multi platform

00:40:13,960 --> 00:40:18,609
support because it basically the reason

00:40:16,810 --> 00:40:20,920
is if you if you have a current that

00:40:18,609 --> 00:40:23,980
runs on a lot of platforms you can't

00:40:20,920 --> 00:40:30,130
rely on the corner to run from a fixed

00:40:23,980 --> 00:40:32,829
physical address and yeah that that just

00:40:30,130 --> 00:40:36,310
doesn't work it I I think it basically

00:40:32,829 --> 00:40:40,060
works on the really small Norma miu

00:40:36,310 --> 00:40:44,079
targets that we will be using anyway so

00:40:40,060 --> 00:40:47,680
the stm32 and the some of the others are

00:40:44,079 --> 00:40:49,420
forget what they are and one thing I

00:40:47,680 --> 00:40:53,500
discussed with with Arnie yesterday

00:40:49,420 --> 00:40:57,940
yesterday or day before there is this

00:40:53,500 --> 00:41:02,109
trend in the Silicon instra story where

00:40:57,940 --> 00:41:06,790
you have sdram chips the minimum size

00:41:02,109 --> 00:41:09,490
you can have is 32 megabytes they're not

00:41:06,790 --> 00:41:13,030
producing smaller than that anymore so

00:41:09,490 --> 00:41:17,440
if you don't want to use as the RAM

00:41:13,030 --> 00:41:20,589
because of power consumptions issues you

00:41:17,440 --> 00:41:23,500
have to go with SRAM and then SRAM it's

00:41:20,589 --> 00:41:27,990
much more expensive so there's a huge

00:41:23,500 --> 00:41:30,180
gap between 32 megabytes

00:41:27,990 --> 00:41:33,390
and a typical system with a few

00:41:30,180 --> 00:41:36,780
kilobytes of SRAM or a few hundred of

00:41:33,390 --> 00:41:41,280
kilobytes of SRAM so if we want to

00:41:36,780 --> 00:41:46,320
target that space we really need to to

00:41:41,280 --> 00:41:48,960
address to address this with new

00:41:46,320 --> 00:41:53,550
techniques like alternative subsystem

00:41:48,960 --> 00:41:55,950
and so on because the 32 megabytes case

00:41:53,550 --> 00:41:57,600
is already well supported linux will run

00:41:55,950 --> 00:42:00,810
in and those amount of memory pretty

00:41:57,600 --> 00:42:04,380
comfortably so let's just gonna say the

00:42:00,810 --> 00:42:08,130
stm32 xop that was what you saw in the

00:42:04,380 --> 00:42:13,230
running in the previous demo just

00:42:08,130 --> 00:42:15,240
watching sorry I didn't hear at the demo

00:42:13,230 --> 00:42:19,740
in my presentation which was before this

00:42:15,240 --> 00:42:22,140
that was stm32 running xip executing

00:42:19,740 --> 00:42:25,290
place it does work on up shrinking but

00:42:22,140 --> 00:42:34,710
you have to have a specific stm32 comic

00:42:25,290 --> 00:42:37,020
book yeah hey Vaughn hi Nicholas so this

00:42:34,710 --> 00:42:40,500
is a big community around useless the

00:42:37,020 --> 00:42:42,119
microwaves Gunnar and I see that there's

00:42:40,500 --> 00:42:44,400
a lot of war lab between what you're

00:42:42,119 --> 00:42:47,160
trying to do and what usually is going

00:42:44,400 --> 00:42:49,470
to will be interested in because it's a

00:42:47,160 --> 00:42:52,020
basically started at the devices which

00:42:49,470 --> 00:42:54,359
are slightly more complex than I OT but

00:42:52,020 --> 00:42:56,940
less complicated than a mobile system

00:42:54,359 --> 00:42:59,900
let's not say come together but in terms

00:42:56,940 --> 00:43:02,670
of its ramp sizes and everything so

00:42:59,900 --> 00:43:06,810
should we not use the use of Linux

00:43:02,670 --> 00:43:10,020
community to you know make these changes

00:43:06,810 --> 00:43:12,570
and should you not publish these these

00:43:10,020 --> 00:43:15,990
proposals in that community so that we

00:43:12,570 --> 00:43:19,500
can leverage on a bigger developer

00:43:15,990 --> 00:43:21,570
codebase della per base and do these

00:43:19,500 --> 00:43:26,070
things faster and probably in more

00:43:21,570 --> 00:43:28,920
mature way well there's one thing I

00:43:26,070 --> 00:43:32,740
didn't mention in those slides

00:43:28,920 --> 00:43:37,540
recently I i sent upstream some patches

00:43:32,740 --> 00:43:41,350
to be able to have the flat binary

00:43:37,540 --> 00:43:44,800
executable format usable on an MMU

00:43:41,350 --> 00:43:48,310
equipped system so if you're yearning

00:43:44,800 --> 00:43:52,600
running your UC linux distribution on

00:43:48,310 --> 00:43:57,160
your full fledge arm server for example

00:43:52,600 --> 00:43:59,320
it'll just work so I maybe I didn't get

00:43:57,160 --> 00:44:00,520
the combat about you see linux to him

00:43:59,320 --> 00:44:03,280
mean the actual you see linux

00:44:00,520 --> 00:44:06,910
distribution or do you mean linux

00:44:03,280 --> 00:44:10,090
without mm you I mean the useless

00:44:06,910 --> 00:44:12,520
community as a whole there's a lot of

00:44:10,090 --> 00:44:14,800
community in the desert engineers

00:44:12,520 --> 00:44:16,690
working on using export on different

00:44:14,800 --> 00:44:18,970
architectures and to me it sounds like

00:44:16,690 --> 00:44:22,960
the work that Nicholas is doing has a

00:44:18,970 --> 00:44:24,850
lot of or lab in terms of the end goals

00:44:22,960 --> 00:44:26,530
may not be the methods but the end in

00:44:24,850 --> 00:44:29,230
terms of end goals or to use Linux

00:44:26,530 --> 00:44:30,730
community would want to achieve so so as

00:44:29,230 --> 00:44:33,100
far as I know you see linux is still on

00:44:30,730 --> 00:44:35,020
Linux 2.2 for most of the no I mean view

00:44:33,100 --> 00:44:37,630
targets and arm so they basically

00:44:35,020 --> 00:44:40,090
abandoned arm for going to your kernels

00:44:37,630 --> 00:44:42,580
and not sure and and I don't think that

00:44:40,090 --> 00:44:45,700
a lot of people are still actually using

00:44:42,580 --> 00:44:48,250
you see Linux it's what most people are

00:44:45,700 --> 00:44:51,610
doing is they use an upstream kernel or

00:44:48,250 --> 00:44:55,660
Colonel from some company that uses no

00:44:51,610 --> 00:44:58,780
mu and I but do you mean just the UC

00:44:55,660 --> 00:45:01,150
Linux like the user space tools with you

00:44:58,780 --> 00:45:06,280
see lipsy and I don't get what you mean

00:45:01,150 --> 00:45:08,920
with you see linens community basically

00:45:06,280 --> 00:45:12,250
the idea is that the publish this this

00:45:08,920 --> 00:45:15,190
this proposal to a bigger set of people

00:45:12,250 --> 00:45:16,780
larger set of people could be useful in

00:45:15,190 --> 00:45:19,510
security could be the main line

00:45:16,780 --> 00:45:22,260
community so that we can thrash out the

00:45:19,510 --> 00:45:24,280
details of the designs and Thresh of the

00:45:22,260 --> 00:45:26,740
different possibilities maybe we can

00:45:24,280 --> 00:45:31,030
come up with some newer things to

00:45:26,740 --> 00:45:33,760
optimizing the juices and so eventually

00:45:31,030 --> 00:45:35,560
when you reduce the RAM size ram usage

00:45:33,760 --> 00:45:37,450
you are also improving the performance

00:45:35,560 --> 00:45:40,610
in terms of cache of commercials and

00:45:37,450 --> 00:45:44,210
everything so I would believe that

00:45:40,610 --> 00:45:51,680
we'll have a lot more acceptance in

00:45:44,210 --> 00:45:53,450
bigger set of I think you running I'm so

00:45:51,680 --> 00:45:55,900
obviously in the mainline kernel there's

00:45:53,450 --> 00:46:00,230
been a lot of work over the years with

00:45:55,900 --> 00:46:02,270
titless work and make sure the CPU idol

00:46:00,230 --> 00:46:05,330
is really efficient so with your nano

00:46:02,270 --> 00:46:11,420
secular do we still get the ability to

00:46:05,330 --> 00:46:15,020
be really efficient with power I didn't

00:46:11,420 --> 00:46:18,380
have a close look at the power

00:46:15,020 --> 00:46:21,860
implication of those things probably

00:46:18,380 --> 00:46:24,500
that if your application is so simple if

00:46:21,860 --> 00:46:28,190
you have only one task and the task goes

00:46:24,500 --> 00:46:31,820
idle it should be pretty obvious what

00:46:28,190 --> 00:46:33,530
you need to do to save power then the

00:46:31,820 --> 00:46:37,750
tech last kernel and so on it's it's

00:46:33,530 --> 00:46:40,760
highly optimized for generic workloads

00:46:37,750 --> 00:46:43,790
so if you control the environment of

00:46:40,760 --> 00:46:48,890
what you're running maybe that the idle

00:46:43,790 --> 00:46:52,370
function in new kernel could be tied up

00:46:48,890 --> 00:46:54,920
to Mize for your purposes so I I don't

00:46:52,370 --> 00:46:58,760
think that in really really small system

00:46:54,920 --> 00:47:04,000
getting the best power possible best our

00:46:58,760 --> 00:47:06,350
saving possible is a huge issue the

00:47:04,000 --> 00:47:08,510
other thing that's happening right now

00:47:06,350 --> 00:47:11,750
that there's very active work going on

00:47:08,510 --> 00:47:13,340
is to get real-time the cramped RT

00:47:11,750 --> 00:47:17,420
patches upstream into the real-time

00:47:13,340 --> 00:47:19,970
linux kernel one of these domains for

00:47:17,420 --> 00:47:21,650
tiny kernels is obviously going to need

00:47:19,970 --> 00:47:25,160
real-time performance to what extent

00:47:21,650 --> 00:47:27,320
we've been thinking about making sure

00:47:25,160 --> 00:47:33,650
that we can keep the tiny kernel with

00:47:27,320 --> 00:47:37,100
real-time capabilities the smaller the

00:47:33,650 --> 00:47:40,670
colonel is the easiest is it will be to

00:47:37,100 --> 00:47:42,890
get it real time because then you don't

00:47:40,670 --> 00:47:44,510
have to cater for all the different

00:47:42,890 --> 00:47:47,480
subsystems and everything going in

00:47:44,510 --> 00:47:51,800
parallel and so on so in theory if you

00:47:47,480 --> 00:47:54,470
look at the existing small artists they

00:47:51,800 --> 00:47:58,460
are real time and their scheduler

00:47:54,470 --> 00:48:01,960
are very very simple so in theory if we

00:47:58,460 --> 00:48:05,960
go with this idea of having a very small

00:48:01,960 --> 00:48:09,290
scheduler and small amount of tasks it

00:48:05,960 --> 00:48:11,240
should be easier I think to have

00:48:09,290 --> 00:48:13,280
real-time performances from a tiny

00:48:11,240 --> 00:48:19,760
Colonel than it is from a regular

00:48:13,280 --> 00:48:22,640
colonel of course it might not have many

00:48:19,760 --> 00:48:28,250
relationship with the existing real-time

00:48:22,640 --> 00:48:32,359
pass yet though I have two comments to

00:48:28,250 --> 00:48:33,710
make number one have when you were you

00:48:32,359 --> 00:48:35,599
know first of all I appreciate your

00:48:33,710 --> 00:48:37,810
effort in trying to reduce memory and

00:48:35,599 --> 00:48:40,790
your hacked away and removed many things

00:48:37,810 --> 00:48:44,090
have you thought about or talked to any

00:48:40,790 --> 00:48:46,520
of the SRAM vendors to get an idea about

00:48:44,090 --> 00:48:49,400
two or three years from now what would

00:48:46,520 --> 00:48:52,400
be the minimal amount of SRAM that would

00:48:49,400 --> 00:48:55,820
be there so that you have a goal when

00:48:52,400 --> 00:48:57,680
you try to fit your Colonel into that

00:48:55,820 --> 00:49:02,869
that I think is worthwhile looking at

00:48:57,680 --> 00:49:04,970
that's a observation i'm making and and

00:49:02,869 --> 00:49:07,839
one of the thing that the second point

00:49:04,970 --> 00:49:11,270
was he knew your slides you said that

00:49:07,839 --> 00:49:13,820
there is no need for this IOT device to

00:49:11,270 --> 00:49:15,920
have a router on it I mean obviously I

00:49:13,820 --> 00:49:18,380
agree with that but I don't think you

00:49:15,920 --> 00:49:20,810
can assume that it will not doubt any of

00:49:18,380 --> 00:49:22,430
the packets to a neighboring IOT device

00:49:20,810 --> 00:49:28,490
i think that assumption might not be

00:49:22,430 --> 00:49:30,650
valid well you are i UT device my is

00:49:28,490 --> 00:49:32,560
likely to be a client in your network

00:49:30,650 --> 00:49:35,150
you're not going to use it as a router

00:49:32,560 --> 00:49:39,010
so it won't have to forward packets

00:49:35,150 --> 00:49:39,010
that's that's that's what I meant

00:49:39,310 --> 00:49:42,540
that is a valid assumption or not

00:49:41,080 --> 00:49:55,420
because in machine-to-machine

00:49:42,540 --> 00:49:58,360
communication has seen applications yeah

00:49:55,420 --> 00:50:00,100
well my if you do have a mesh network or

00:49:58,360 --> 00:50:04,210
things like that probably it will be

00:50:00,100 --> 00:50:06,820
implemented into your stack and if you

00:50:04,210 --> 00:50:10,900
have if you already have a stack that

00:50:06,820 --> 00:50:12,940
does this on another operating system

00:50:10,900 --> 00:50:17,830
probably you could just reuse the same

00:50:12,940 --> 00:50:20,290
code in in a linux based system and it

00:50:17,830 --> 00:50:23,320
would it wouldn't be any bigger for that

00:50:20,290 --> 00:50:25,180
the other ideas like this is not to make

00:50:23,320 --> 00:50:26,980
everything small to make everything

00:50:25,180 --> 00:50:28,870
configurable and if you need routing

00:50:26,980 --> 00:50:31,030
then you turn on the routing again and

00:50:28,870 --> 00:50:32,920
you have it it's still there you can

00:50:31,030 --> 00:50:34,890
turn off the routing and still have to

00:50:32,920 --> 00:50:39,940
turn off the scheduler and turn off the

00:50:34,890 --> 00:50:41,890
memory allocated another and for your

00:50:39,940 --> 00:50:44,200
other question for the for the SRAM this

00:50:41,890 --> 00:50:46,480
is the comments were about the

00:50:44,200 --> 00:50:48,840
integrated SRAM on chips and there will

00:50:46,480 --> 00:50:50,740
always be the whole range you will have

00:50:48,840 --> 00:50:53,980
microcontrollers with one kilobyte of

00:50:50,740 --> 00:50:56,080
SRAM and then 10 kilo 16 kilobytes or

00:50:53,980 --> 00:50:58,690
one megabyte we will always have the

00:50:56,080 --> 00:51:01,570
whole space the question is more which

00:50:58,690 --> 00:51:02,920
of these devices are we targeting I will

00:51:01,570 --> 00:51:04,930
only targeting the ones with two

00:51:02,920 --> 00:51:09,490
megabytes of SRAM on ship which have

00:51:04,930 --> 00:51:12,810
very few or do we go to 512 kilobytes or

00:51:09,490 --> 00:51:12,810
below five round 12 kilobytes

00:51:16,530 --> 00:51:26,040
I would like to make some general

00:51:23,520 --> 00:51:29,130
comments so i remember similar session a

00:51:26,040 --> 00:51:31,740
year or two ago and ending lion was

00:51:29,130 --> 00:51:34,200
maybe people should look for samsung

00:51:31,740 --> 00:51:37,290
else but linux if they want like lorem

00:51:34,200 --> 00:51:40,950
usage Oh Gemma sighs the message was

00:51:37,290 --> 00:51:44,130
huard linux foundation of her system

00:51:40,950 --> 00:51:48,090
google recently announced foxy a project

00:51:44,130 --> 00:51:51,750
and I'm happier except myself is changin

00:51:48,090 --> 00:51:54,900
and there is no thinkin maybe lyrics

00:51:51,750 --> 00:51:57,960
should go they actually the small size

00:51:54,900 --> 00:52:01,470
so I'm very happy to hear mediate the

00:51:57,960 --> 00:52:13,590
inertial 296 port project is small

00:52:01,470 --> 00:52:15,210
enough rare but to be able to so was it

00:52:13,590 --> 00:52:21,360
the question or comment I didn't get it

00:52:15,210 --> 00:52:24,140
all okay so i suppose that we're done so

00:52:21,360 --> 00:52:24,140
thank you very much

00:52:31,730 --> 00:52:33,790

YouTube URL: https://www.youtube.com/watch?v=vGH0K0CiUlI


