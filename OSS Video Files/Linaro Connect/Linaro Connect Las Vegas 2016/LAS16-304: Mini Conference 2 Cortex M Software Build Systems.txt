Title: LAS16-304: Mini Conference 2 Cortex M Software Build Systems
Publication date: 2016-09-30
Playlist: Linaro Connect Las Vegas 2016
Description: 
	LAS16-304: Mini Conference 2 RTOS-Zephyr - Build Systems
Speakers:
Date: September 28, 2016

★ Session Description ★
In composing RTOS-based images to run on embedded systems, there are number of different issues that come into play that are different from building a root fs for Linux. Issues such as how third-party libraries and code link with the OS, how we pull down the code, etc. Additionally, such systems may also need to support the creation of filesystem-based images. There are several options that exist today (“newt" - a tool from the Apache Mynewt project in the Apache Software Foundation; “yotta" - from ARM mbed; the Yocto Project; and more). This session will discuss required features, compare and contrast project approaches, and potential additions and changes that are needed in this space.

★ Resources ★
Etherpad: pad.linaro.org/p/las16-304
Presentations & Videos: http://connect.linaro.org/resource/las16/las16-304/

★ Event Details ★
Linaro Connect Las Vegas 2016 – #LAS16
September 26-30, 2016
http://www.linaro.org
http://connect.linaro.org
Captions: 
	00:00:06,770 --> 00:00:11,700
so I wanted to talk a bit about building

00:00:09,000 --> 00:00:13,610
package management which is something

00:00:11,700 --> 00:00:16,320
that we've spent a lot of time on my new

00:00:13,610 --> 00:00:17,609
so this is kind of our you know standard

00:00:16,320 --> 00:00:20,220
marketing slide and then I put up

00:00:17,609 --> 00:00:21,930
together a number of really two other

00:00:20,220 --> 00:00:25,800
slides that goes a little bit more in

00:00:21,930 --> 00:00:28,560
depth into the decisions up oh yeah sure

00:00:25,800 --> 00:00:30,599
so hey I'm sterling I'm CTO and

00:00:28,560 --> 00:00:32,219
co-founder of runtime runtime is one of

00:00:30,599 --> 00:00:35,969
the contributors to the Apache my new

00:00:32,219 --> 00:00:38,879
project my background is from a company

00:00:35,969 --> 00:00:41,370
called my background in started kind of

00:00:38,879 --> 00:00:42,719
self-taught worked on the PHP

00:00:41,370 --> 00:00:44,309
programming language worked on a lot of

00:00:42,719 --> 00:00:46,410
back-end and web server infrastructure

00:00:44,309 --> 00:00:48,360
and then spent ten years at a company

00:00:46,410 --> 00:00:51,649
called silver spring networks that did

00:00:48,360 --> 00:00:54,360
deeply embedded work over 23 million

00:00:51,649 --> 00:00:56,270
network-connected streetlights power

00:00:54,360 --> 00:00:59,579
meters distribution automation devices

00:00:56,270 --> 00:01:02,250
our first product we ran an IP stacks on

00:00:59,579 --> 00:01:05,339
80 to 15 for on 128 k a code on that

00:01:02,250 --> 00:01:09,210
mega we dealt with battery powered

00:01:05,339 --> 00:01:12,600
devices and moved all the way up from

00:01:09,210 --> 00:01:14,909
that to 70 DM eyes to court XM's and

00:01:12,600 --> 00:01:17,159
designing our Island system-on-chips we

00:01:14,909 --> 00:01:18,689
then founded a company of payson and I

00:01:17,159 --> 00:01:20,909
just founded a company called runtime

00:01:18,689 --> 00:01:23,100
and the goal was to develop an operating

00:01:20,909 --> 00:01:25,530
system that made it easy for people to

00:01:23,100 --> 00:01:29,040
develop these connected products because

00:01:25,530 --> 00:01:30,630
a lot of the issues we had at Silver

00:01:29,040 --> 00:01:33,210
Spring where we've created our own

00:01:30,630 --> 00:01:35,009
operating system and what we saw is most

00:01:33,210 --> 00:01:36,540
companies who do these deeply embedded

00:01:35,009 --> 00:01:38,909
connected products create their own

00:01:36,540 --> 00:01:40,500
operating system so you have your own

00:01:38,909 --> 00:01:42,720
flash file system that you've developed

00:01:40,500 --> 00:01:44,280
in-house or you have your own networking

00:01:42,720 --> 00:01:46,560
stack that you've developed in-house and

00:01:44,280 --> 00:01:48,899
over time you have to grow a platform

00:01:46,560 --> 00:01:50,759
team that becomes very specific to your

00:01:48,899 --> 00:01:53,520
company so when you need to do something

00:01:50,759 --> 00:01:55,229
new it's very expensive right I we have

00:01:53,520 --> 00:01:58,560
this IP stack that we've put all of this

00:01:55,229 --> 00:02:01,729
effort into and now we need to support

00:01:58,560 --> 00:02:04,710
ipv6 so we need to support 6lowpan and

00:02:01,729 --> 00:02:06,659
we can't use a new IP stack because we

00:02:04,710 --> 00:02:09,810
did all of the testing on our old IP

00:02:06,659 --> 00:02:11,129
stack and so challenges like that and so

00:02:09,810 --> 00:02:13,450
they got the idea behind the my new

00:02:11,129 --> 00:02:15,010
project was to create that open source

00:02:13,450 --> 00:02:18,190
operating system very similar to zephyr

00:02:15,010 --> 00:02:20,080
and embed efforts so one of the elements

00:02:18,190 --> 00:02:22,900
of that operating system that we spend a

00:02:20,080 --> 00:02:25,840
lot of time working on is the concept of

00:02:22,900 --> 00:02:28,209
build and package management so kind of

00:02:25,840 --> 00:02:31,660
taking in spirit what we saw from nodejs

00:02:28,209 --> 00:02:35,890
or from go I think go is a big influence

00:02:31,660 --> 00:02:38,830
on us how do you go and compose an

00:02:35,890 --> 00:02:41,680
embedded project and how do you make

00:02:38,830 --> 00:02:44,860
that reusable and this is especially

00:02:41,680 --> 00:02:47,110
important in areas like an operating

00:02:44,860 --> 00:02:50,230
system where you have very very

00:02:47,110 --> 00:02:52,390
constrained code and you have a broad

00:02:50,230 --> 00:02:53,860
set of use cases for our tosses right

00:02:52,390 --> 00:02:56,049
some people want to use on our toss on

00:02:53,860 --> 00:02:58,660
an Ethernet connected device and drive a

00:02:56,049 --> 00:03:01,720
display screen some people want to do a

00:02:58,660 --> 00:03:03,579
Bluetooth connected wearable and so

00:03:01,720 --> 00:03:06,549
there's all this diversity and so how do

00:03:03,579 --> 00:03:09,120
you help people met compose the right

00:03:06,549 --> 00:03:11,319
system allow them to reuse components

00:03:09,120 --> 00:03:14,230
but still have something that makes

00:03:11,319 --> 00:03:16,150
sense and isn't crazy uh-huh so I think

00:03:14,230 --> 00:03:18,489
some of the goals we had there were to

00:03:16,150 --> 00:03:20,650
maintain reuse in packages across

00:03:18,489 --> 00:03:23,109
multiple products so a big challenge

00:03:20,650 --> 00:03:24,519
that we had was we had meters and

00:03:23,109 --> 00:03:27,459
streetlights and distribution automation

00:03:24,519 --> 00:03:30,790
devices ninety-five percent of the code

00:03:27,459 --> 00:03:32,019
was the same between those but we but

00:03:30,790 --> 00:03:34,090
there were different and various

00:03:32,019 --> 00:03:35,889
configurations that we had and we had

00:03:34,090 --> 00:03:38,049
our own build system that we built which

00:03:35,889 --> 00:03:41,829
was just a bunch of make files that we

00:03:38,049 --> 00:03:43,870
had managed over time so how do you you

00:03:41,829 --> 00:03:45,519
know as a product company you're

00:03:43,870 --> 00:03:47,109
probably going to have the same code

00:03:45,519 --> 00:03:49,150
base and ten different products with

00:03:47,109 --> 00:03:50,230
slightly different requirements and you

00:03:49,150 --> 00:03:53,280
should have a tool that makes things

00:03:50,230 --> 00:03:56,530
easy for you to do that manage build and

00:03:53,280 --> 00:03:58,780
debug in production setups so you know

00:03:56,530 --> 00:04:00,940
pretty much every embedded developer and

00:03:58,780 --> 00:04:02,739
every embedded project you have to get

00:04:00,940 --> 00:04:05,139
your tool chain up and running right you

00:04:02,739 --> 00:04:07,959
have to go to open OCD and it turns out

00:04:05,139 --> 00:04:09,489
that open OCD you know has the wrong

00:04:07,959 --> 00:04:12,660
configuration for the board you have

00:04:09,489 --> 00:04:16,180
take a you know st boards as an example

00:04:12,660 --> 00:04:18,010
st link keeps getting upgraded and on

00:04:16,180 --> 00:04:19,959
these boards and there are different

00:04:18,010 --> 00:04:23,250
open OCD configurations for each of

00:04:19,959 --> 00:04:26,880
those most of which are out of date

00:04:23,250 --> 00:04:28,860
if you use you know there's there's five

00:04:26,880 --> 00:04:30,450
different debugging protocols from swd

00:04:28,860 --> 00:04:33,270
to dap link so the person who is

00:04:30,450 --> 00:04:35,160
creating the board support package in I

00:04:33,270 --> 00:04:37,200
guess our view should also be the person

00:04:35,160 --> 00:04:38,520
who's creating the debugger scripts for

00:04:37,200 --> 00:04:40,680
that board support package and

00:04:38,520 --> 00:04:42,870
supporting the various debuggers that

00:04:40,680 --> 00:04:44,310
you do so when you go and you download

00:04:42,870 --> 00:04:46,680
an operating system or you download a

00:04:44,310 --> 00:04:49,110
project you should have the person who

00:04:46,680 --> 00:04:51,300
made the board Support Package actually

00:04:49,110 --> 00:04:52,800
support your de bug setup but also you

00:04:51,300 --> 00:04:55,830
should have a tool that allows you to go

00:04:52,800 --> 00:04:57,750
from debugging to production right if

00:04:55,830 --> 00:04:59,520
your build system the first part of your

00:04:57,750 --> 00:05:01,380
build system is making something and

00:04:59,520 --> 00:05:02,850
loading it onto a device but then you

00:05:01,380 --> 00:05:04,620
want to take that same source code base

00:05:02,850 --> 00:05:07,140
and you actually want to create a

00:05:04,620 --> 00:05:08,550
downloadable image from it and you

00:05:07,140 --> 00:05:10,980
probably want different build settings

00:05:08,550 --> 00:05:13,500
for that image you probably want to use

00:05:10,980 --> 00:05:14,910
different security keys but you need a

00:05:13,500 --> 00:05:21,210
single system that takes you between

00:05:14,910 --> 00:05:23,850
those two and then yeah so so in talking

00:05:21,210 --> 00:05:25,620
those and I guess I'll leave it for

00:05:23,850 --> 00:05:29,430
questions and I want to keep this

00:05:25,620 --> 00:05:31,350
somewhat interactive so you know the

00:05:29,430 --> 00:05:33,690
first kind of decision you have to make

00:05:31,350 --> 00:05:37,169
is whether you make the system

00:05:33,690 --> 00:05:38,250
composable or not right so you know if

00:05:37,169 --> 00:05:40,470
you look at the build and package

00:05:38,250 --> 00:05:43,470
management tools that are out there in

00:05:40,470 --> 00:05:46,680
some some of them you have a just a file

00:05:43,470 --> 00:05:50,580
and you type install and that installs

00:05:46,680 --> 00:05:54,720
all of the packages for you but there is

00:05:50,580 --> 00:05:56,550
no enforcement of hierarchy in your in

00:05:54,720 --> 00:05:59,040
your directory tree and there's no

00:05:56,550 --> 00:06:02,310
enforcement of things like unified set

00:05:59,040 --> 00:06:03,840
up defines or where defines our put and

00:06:02,310 --> 00:06:07,650
so it makes it very hard to compose a

00:06:03,840 --> 00:06:09,570
system that puts those together so a lot

00:06:07,650 --> 00:06:11,970
of this is how do you create a new

00:06:09,570 --> 00:06:13,770
project how do you install dependencies

00:06:11,970 --> 00:06:15,810
for that project and how do you make

00:06:13,770 --> 00:06:18,210
sure that all of the different elements

00:06:15,810 --> 00:06:20,460
of those dependencies follow a unified

00:06:18,210 --> 00:06:22,640
system so in New what we've done is

00:06:20,460 --> 00:06:27,000
we've enforced directory hierarchy on

00:06:22,640 --> 00:06:28,890
the various different projects so I

00:06:27,000 --> 00:06:32,390
don't know is that similar to what's

00:06:28,890 --> 00:06:35,930
effort does or does effort not have a a

00:06:32,390 --> 00:06:35,930
enforced hierarchy

00:06:43,629 --> 00:06:50,680
it does yeah so I mean I can just jump

00:06:47,180 --> 00:06:50,680
to a turtle actually that might actually

00:06:53,259 --> 00:06:59,720
I was saying not necessarily I mean

00:06:57,139 --> 00:07:01,190
there is some structure but this is like

00:06:59,720 --> 00:07:05,389
in the house itself but when when you

00:07:01,190 --> 00:07:08,930
have an application writer there is no

00:07:05,389 --> 00:07:12,139
strict hierarchy there that you need to

00:07:08,930 --> 00:07:14,270
do and and right now we we don't really

00:07:12,139 --> 00:07:17,090
have the support for external modules

00:07:14,270 --> 00:07:19,639
where we can say where we have to say

00:07:17,090 --> 00:07:23,360
you have to build your module or your

00:07:19,639 --> 00:07:26,560
component in a certain way but that's

00:07:23,360 --> 00:07:26,560
probably will be coming soon

00:07:30,210 --> 00:07:36,690
so what we enforce here is the concept

00:07:34,620 --> 00:07:38,910
of a source directory and include

00:07:36,690 --> 00:07:41,310
directory the source directory gets

00:07:38,910 --> 00:07:43,530
recursively built so everything in

00:07:41,310 --> 00:07:45,599
source you that you put you can put

00:07:43,530 --> 00:07:48,060
whatever you want those devices will get

00:07:45,599 --> 00:07:49,560
built in there except for one directory

00:07:48,060 --> 00:07:54,000
that we put in source which is the arc

00:07:49,560 --> 00:07:56,280
directory so we have arc x86 which is

00:07:54,000 --> 00:07:58,380
our simulated environment we have arc

00:07:56,280 --> 00:08:02,759
arm oh and then you can do arc arm

00:07:58,380 --> 00:08:04,259
cortex-m 0 and so those directories are

00:08:02,759 --> 00:08:05,729
ignored in source but everything else is

00:08:04,259 --> 00:08:07,979
recursively compiled in the source

00:08:05,729 --> 00:08:13,940
directory and then in the include

00:08:07,979 --> 00:08:13,940
directory what we do

00:08:22,289 --> 00:08:29,199
essentially go and have include has OS

00:08:26,889 --> 00:08:30,880
as the first element in it so the name

00:08:29,199 --> 00:08:32,770
of the package that's being built is

00:08:30,880 --> 00:08:36,130
always the first element in the include

00:08:32,770 --> 00:08:38,800
directory GCC doesn't support include

00:08:36,130 --> 00:08:40,570
aliasing so there's no way of saying hey

00:08:38,800 --> 00:08:42,789
I want to have the following package

00:08:40,570 --> 00:08:44,980
directory Elias there so we have to

00:08:42,789 --> 00:08:46,990
enforce a hierarchy which means that

00:08:44,980 --> 00:08:50,230
everybody who develops a package will

00:08:46,990 --> 00:08:53,770
prefix that with their package name and

00:08:50,230 --> 00:08:56,560
the goal is to just avoid a a massive

00:08:53,770 --> 00:08:58,990
includes you can see here that there's

00:08:56,560 --> 00:09:02,140
also the architecture specific

00:08:58,990 --> 00:09:04,270
directories here so in include files

00:09:02,140 --> 00:09:07,180
that want to actually include something

00:09:04,270 --> 00:09:11,649
that's cortex-m 0 essentially what we do

00:09:07,180 --> 00:09:13,839
is we have on that arc directory we go

00:09:11,649 --> 00:09:15,880
into the specific directory like

00:09:13,839 --> 00:09:19,570
cortex-m 0 if you're compiling with that

00:09:15,880 --> 00:09:21,279
architecture and then Oh SRH is taken

00:09:19,570 --> 00:09:23,470
from that directory depending on which

00:09:21,279 --> 00:09:25,120
architecture you're compiling for so if

00:09:23,470 --> 00:09:27,190
you want to have architecture specific

00:09:25,120 --> 00:09:31,720
header files you just put them in there

00:09:27,190 --> 00:09:37,779
aliased so this is basically you call

00:09:31,720 --> 00:09:40,209
that extra structure yes ok and I mean

00:09:37,779 --> 00:09:42,450
our users expected to go and change that

00:09:40,209 --> 00:09:45,820
or the memos I'm not following exactly

00:09:42,450 --> 00:09:48,870
what structure I was trying to impose

00:09:45,820 --> 00:09:52,450
hear somebody lightly

00:09:48,870 --> 00:09:57,040
exactly so so everything in the in our

00:09:52,450 --> 00:10:00,160
build system is a package and so we have

00:09:57,040 --> 00:10:03,400
a concept of repository pop projects and

00:10:00,160 --> 00:10:06,400
packages and repositories so projects

00:10:03,400 --> 00:10:08,650
are a collection of packages and when

00:10:06,400 --> 00:10:10,360
you write when you create a new project

00:10:08,650 --> 00:10:13,330
with new you type Newton ooh your

00:10:10,360 --> 00:10:16,540
project at that point you can then add

00:10:13,330 --> 00:10:19,120
packages to that prepare a project in

00:10:16,540 --> 00:10:21,490
the case of the operating system it's a

00:10:19,120 --> 00:10:23,440
package and so all packages follow the

00:10:21,490 --> 00:10:25,720
same structure which is they have a

00:10:23,440 --> 00:10:28,980
package amo file that defines the

00:10:25,720 --> 00:10:28,980
package and their dependencies

00:10:36,840 --> 00:10:40,710
you have dependencies listed for this

00:10:39,120 --> 00:10:46,430
package so the operating system package

00:10:40,710 --> 00:10:48,720
requires the the system initialization

00:10:46,430 --> 00:10:51,180
package which defines system

00:10:48,720 --> 00:10:54,270
initialization order it also requires

00:10:51,180 --> 00:10:57,540
you libs util which has some memory

00:10:54,270 --> 00:11:01,560
management as elements to it there then

00:10:57,540 --> 00:11:04,080
depending on whether or not the ACL I

00:11:01,560 --> 00:11:05,940
has been provided or coordinate support

00:11:04,080 --> 00:11:09,540
has been enabled there are additional

00:11:05,940 --> 00:11:11,400
dependencies that are listed beyond that

00:11:09,540 --> 00:11:13,410
you have include source and test

00:11:11,400 --> 00:11:15,120
directories in the package so the build

00:11:13,410 --> 00:11:17,600
system has the concept of a unit test

00:11:15,120 --> 00:11:20,010
suite in it so if you want to go and run

00:11:17,600 --> 00:11:21,630
tests on the package all of your tests

00:11:20,010 --> 00:11:23,640
are located in that package directory

00:11:21,630 --> 00:11:26,790
and when you write new test it will

00:11:23,640 --> 00:11:29,370
compile the tests and run the tests for

00:11:26,790 --> 00:11:31,830
that package and the idea is that these

00:11:29,370 --> 00:11:34,080
packages are interchangeable and you can

00:11:31,830 --> 00:11:36,300
actually put something else other than

00:11:34,080 --> 00:11:38,490
what my note might actually provide

00:11:36,300 --> 00:11:40,260
absolutely and what how do you guarantee

00:11:38,490 --> 00:11:43,110
the interfaces are actually compatible

00:11:40,260 --> 00:11:46,440
is that defined for example between an

00:11:43,110 --> 00:11:48,210
OS and the boot package is there an

00:11:46,440 --> 00:11:50,040
interface which is defined that

00:11:48,210 --> 00:11:52,890
guarantees that whatever I put there

00:11:50,040 --> 00:11:54,780
actually walk exactly yeah so we what we

00:11:52,890 --> 00:11:57,630
do is the build system itself has a

00:11:54,780 --> 00:11:59,460
concept of api's and so what you you

00:11:57,630 --> 00:12:01,440
know within minut itself obviously we

00:11:59,460 --> 00:12:03,480
have our own ap is 40 s we haven't

00:12:01,440 --> 00:12:05,940
agreed with other projects on you know

00:12:03,480 --> 00:12:09,270
what what we call OS mutex acquire or

00:12:05,940 --> 00:12:10,920
mute x release but we do have the

00:12:09,270 --> 00:12:12,780
concept in the build system of AP is

00:12:10,920 --> 00:12:15,900
where a package can say I require the

00:12:12,780 --> 00:12:18,420
console API and the console API is what

00:12:15,900 --> 00:12:20,190
I define as console what will that

00:12:18,420 --> 00:12:22,470
happen is some other part of the build

00:12:20,190 --> 00:12:24,780
system can actually include the console

00:12:22,470 --> 00:12:26,880
package so you might for example in the

00:12:24,780 --> 00:12:29,040
board Support Package decide whether you

00:12:26,880 --> 00:12:31,290
want a console for the specific hardware

00:12:29,040 --> 00:12:32,550
platform you're using or you just want

00:12:31,290 --> 00:12:34,950
to stub it out because you're rumack

00:12:32,550 --> 00:12:38,400
running simulated what the OS does it

00:12:34,950 --> 00:12:41,670
says I require the console API I don't

00:12:38,400 --> 00:12:44,070
care what package it it has just so long

00:12:41,670 --> 00:12:46,329
as that dependency is satisfied and then

00:12:44,070 --> 00:12:49,089
it resolves that for you

00:12:46,329 --> 00:12:50,829
so this is also similar when you you

00:12:49,089 --> 00:12:52,720
want to do things like IP stacks right

00:12:50,829 --> 00:12:54,249
and you want to have a you might want to

00:12:52,720 --> 00:12:55,929
have multiple IP stacks that you have

00:12:54,249 --> 00:12:58,239
you don't really care which one is

00:12:55,929 --> 00:13:00,339
selected you just kick care that it

00:12:58,239 --> 00:13:02,110
conforms to a very specific API you've

00:13:00,339 --> 00:13:04,929
you've done and then all of the packages

00:13:02,110 --> 00:13:06,999
that are written expecting that API will

00:13:04,929 --> 00:13:10,749
automatically take the dependency once

00:13:06,999 --> 00:13:14,230
it's satisfied I don't know if that but

00:13:10,749 --> 00:13:16,749
I mean why would you want to do that at

00:13:14,230 --> 00:13:18,639
this low level of things yeah I mean

00:13:16,749 --> 00:13:22,899
don't you want actually be able to use

00:13:18,639 --> 00:13:24,579
one console or one IP stack and focus on

00:13:22,899 --> 00:13:27,100
that I mean the interchange your

00:13:24,579 --> 00:13:29,259
abilities is all fine yeah but then you

00:13:27,100 --> 00:13:31,660
are just basically giving too many

00:13:29,259 --> 00:13:34,170
options and there are too many ways to

00:13:31,660 --> 00:13:37,480
do one single thing and that basically

00:13:34,170 --> 00:13:39,399
drives users and developers crazy if

00:13:37,480 --> 00:13:41,999
actually because it works here doesn't

00:13:39,399 --> 00:13:45,160
work here this is better this is

00:13:41,999 --> 00:13:48,189
footprint is largely a footman is small

00:13:45,160 --> 00:13:51,610
here so why not focus on one one single

00:13:48,189 --> 00:13:53,439
thing that actually works and i think

00:13:51,610 --> 00:13:56,290
it's it's it's things like console as an

00:13:53,439 --> 00:13:59,769
example it is the one we use API is

00:13:56,290 --> 00:14:02,110
probably the most for and we have a

00:13:59,769 --> 00:14:04,239
console API that stubbed out you can

00:14:02,110 --> 00:14:07,119
either run a console on x86 or you can

00:14:04,239 --> 00:14:10,360
run a console on the specific hardware

00:14:07,119 --> 00:14:12,009
platform you're running on the those are

00:14:10,360 --> 00:14:15,730
different packages and have different

00:14:12,009 --> 00:14:18,699
code footprint sizes to them the various

00:14:15,730 --> 00:14:20,290
packages within the system don't want to

00:14:18,699 --> 00:14:22,839
specify whether you have but you bring

00:14:20,290 --> 00:14:24,669
in the full console itself or whether

00:14:22,839 --> 00:14:26,649
you bring or you just have it stubbed

00:14:24,669 --> 00:14:29,009
out but they want to kind of everywhere

00:14:26,649 --> 00:14:31,509
just you right things to the console

00:14:29,009 --> 00:14:33,549
it's basically different functionalities

00:14:31,509 --> 00:14:36,040
for example two different file systems

00:14:33,549 --> 00:14:37,709
that have completely different features

00:14:36,040 --> 00:14:41,499
that are supported by one single API

00:14:37,709 --> 00:14:44,079
exactly okay all that you care about is

00:14:41,499 --> 00:14:46,949
that there is a package that satisfies

00:14:44,079 --> 00:14:46,949
the file system API

00:15:03,540 --> 00:15:09,690
you're include folder is mainly just

00:15:06,779 --> 00:15:12,209
contain those public head files just

00:15:09,690 --> 00:15:14,250
public ones but inside your source you

00:15:12,209 --> 00:15:16,170
can still help I we'd head files that's

00:15:14,250 --> 00:15:18,149
right right and inside source do you

00:15:16,170 --> 00:15:21,149
have the hierarchy down inside this

00:15:18,149 --> 00:15:23,370
photo is always fret we just go and

00:15:21,149 --> 00:15:25,500
recursively compile source okay except

00:15:23,370 --> 00:15:27,420
for arc right okay so inside the force

00:15:25,500 --> 00:15:29,190
is actually more folders now for each

00:15:27,420 --> 00:15:35,120
component to it if you want to have them

00:15:29,190 --> 00:15:36,959
yeah okay I said yeah yeah yeah got it I

00:15:35,120 --> 00:15:41,310
don't know if we want to dive too deep

00:15:36,959 --> 00:15:43,620
on this but how our API is defined or is

00:15:41,310 --> 00:15:48,110
that from top down from the project and

00:15:43,620 --> 00:15:50,970
how are they versioned if at all so

00:15:48,110 --> 00:15:52,110
let's not go into versioning will go

00:15:50,970 --> 00:15:53,519
into versioning we use the same

00:15:52,110 --> 00:15:55,380
versioning system across api's

00:15:53,519 --> 00:15:58,529
dependencies and everything so let's

00:15:55,380 --> 00:16:00,720
save that one but API is essentially

00:15:58,529 --> 00:16:05,040
packages export the api's they implement

00:16:00,720 --> 00:16:08,970
so if you the lib console or sis console

00:16:05,040 --> 00:16:11,220
full exports the console API packages

00:16:08,970 --> 00:16:14,699
that then use console require the

00:16:11,220 --> 00:16:16,440
console API to be there and so then that

00:16:14,699 --> 00:16:18,029
that's automatically happened and of

00:16:16,440 --> 00:16:26,100
course those api's are then burgeoned

00:16:18,029 --> 00:16:29,120
but if you need a new API yeah you just

00:16:26,100 --> 00:16:29,120
export value tag

00:16:29,250 --> 00:16:41,880
yep and it was our version those are

00:16:32,460 --> 00:16:43,980
versions exactly and you just basically

00:16:41,880 --> 00:16:45,810
you know because we're going to have a

00:16:43,980 --> 00:16:47,910
set of AP is that we define in the

00:16:45,810 --> 00:16:50,420
operating system itself but then users

00:16:47,910 --> 00:16:52,830
can use this as for their build systems

00:16:50,420 --> 00:17:04,770
additionally to satisfy those

00:16:52,830 --> 00:17:07,860
dependencies but that's one it's really

00:17:04,770 --> 00:17:10,470
it's just a build system role for you in

00:17:07,860 --> 00:17:11,699
terms of a see interface yep and i say i

00:17:10,470 --> 00:17:13,530
want i'm supporting the console

00:17:11,699 --> 00:17:16,280
interface is it just that i implemented

00:17:13,530 --> 00:17:19,380
this header file or is there a more

00:17:16,280 --> 00:17:22,680
formal schema top of that it's just a

00:17:19,380 --> 00:17:24,630
header file ok so this so how do I

00:17:22,680 --> 00:17:27,689
assert that I've actually implemented

00:17:24,630 --> 00:17:29,220
that interface you provide the header

00:17:27,689 --> 00:17:35,010
file and say that you implemented it and

00:17:29,220 --> 00:17:38,520
we believe you I mean it yeah I mean the

00:17:35,010 --> 00:17:40,590
goal here really why we use the AP is it

00:17:38,520 --> 00:17:42,240
is for those cases where you don't want

00:17:40,590 --> 00:17:43,920
to have a specific dependency in the

00:17:42,240 --> 00:17:45,420
package so you don't want to dispense

00:17:43,920 --> 00:17:46,980
you don't want to depend on a specific

00:17:45,420 --> 00:17:50,220
package which you want to depend on an

00:17:46,980 --> 00:17:51,780
API being there and then you want the

00:17:50,220 --> 00:17:55,070
build that that to come from another

00:17:51,780 --> 00:17:55,070
place because for us

00:18:02,980 --> 00:18:05,640
so

00:18:07,270 --> 00:18:14,559
if you look here at new we do we manage

00:18:11,150 --> 00:18:16,400
targets for our device right so

00:18:14,559 --> 00:18:18,620
depending on what you want to build

00:18:16,400 --> 00:18:20,630
there's there's two routes to the target

00:18:18,620 --> 00:18:22,309
there's the application and the board

00:18:20,630 --> 00:18:24,890
support package and those two are

00:18:22,309 --> 00:18:27,470
combined to create an elf file or an

00:18:24,890 --> 00:18:29,390
image and the idea there is that you can

00:18:27,470 --> 00:18:30,950
write an app portably and you can switch

00:18:29,390 --> 00:18:33,350
the board Support Package underneath it

00:18:30,950 --> 00:18:36,500
those are also the two roots of the

00:18:33,350 --> 00:18:38,900
build tree right so there the

00:18:36,500 --> 00:18:40,490
application itself has a different route

00:18:38,900 --> 00:18:43,250
than the board support specific

00:18:40,490 --> 00:18:45,290
functionality and so you may want to in

00:18:43,250 --> 00:18:47,000
the applications buildroot tree or in

00:18:45,290 --> 00:18:49,550
the library for the packages subsequent

00:18:47,000 --> 00:18:51,650
to that you may not want to include a

00:18:49,550 --> 00:18:54,260
dependency you may want that to come

00:18:51,650 --> 00:18:55,880
through the hardware support tree and so

00:18:54,260 --> 00:19:02,690
the idea of the API is is to kind of

00:18:55,880 --> 00:19:06,070
mitigate between those two so I have

00:19:02,690 --> 00:19:06,070
titled there that's wonderful

00:19:10,590 --> 00:19:15,360
so the goal is to make the system

00:19:13,320 --> 00:19:17,549
composable what you want to be able to

00:19:15,360 --> 00:19:19,230
do is create a new project when you go

00:19:17,549 --> 00:19:33,179
into that project what we have is a

00:19:19,230 --> 00:19:34,980
package that defines that defines for

00:19:33,179 --> 00:19:37,080
your blog project here are your two

00:19:34,980 --> 00:19:39,690
dependencies you have a patchy minut

00:19:37,080 --> 00:19:42,960
core which is the core operating system

00:19:39,690 --> 00:19:45,659
repo the goal was kind of early on to

00:19:42,960 --> 00:19:46,860
make this very very slim but what we

00:19:45,659 --> 00:19:48,330
actually found was when we're

00:19:46,860 --> 00:19:51,000
distributing an operating system people

00:19:48,330 --> 00:19:52,710
like want the functionality as well so

00:19:51,000 --> 00:19:55,679
it's it's it's a fairly encompassing

00:19:52,710 --> 00:19:57,990
operating system but then also here you

00:19:55,679 --> 00:20:00,750
have a second repository which is my new

00:19:57,990 --> 00:20:03,570
to arduino 0 and the reason we break out

00:20:00,750 --> 00:20:05,789
that repository from our core is that at

00:20:03,570 --> 00:20:08,279
mels header files don't match our

00:20:05,789 --> 00:20:10,559
licensing restrictions but the goal of

00:20:08,279 --> 00:20:12,870
this project mo file is also to allow

00:20:10,559 --> 00:20:15,059
people to maintain their own private

00:20:12,870 --> 00:20:16,740
code bases as well so what we typically

00:20:15,059 --> 00:20:20,610
see happen is somebody creates a new

00:20:16,740 --> 00:20:24,000
project the default reference is Apache

00:20:20,610 --> 00:20:26,130
my new core and they install that but

00:20:24,000 --> 00:20:28,320
they'll also have their own platform

00:20:26,130 --> 00:20:29,850
code base that applies across all of

00:20:28,320 --> 00:20:32,929
their products and then they'll have

00:20:29,850 --> 00:20:34,740
individual projects for each of the

00:20:32,929 --> 00:20:38,690
products that they're actually

00:20:34,740 --> 00:20:38,690
developing and so what does

00:20:45,080 --> 00:20:53,430
rebo's you can see the full tree of the

00:20:49,770 --> 00:21:00,960
of those packages in there as well as a

00:20:53,430 --> 00:21:02,700
project at state which resolves it goes

00:21:00,960 --> 00:21:05,400
and it resolves the version 0 dash

00:21:02,700 --> 00:21:08,220
latest into a very specific version so

00:21:05,400 --> 00:21:11,780
in this case it's 0 dot 9 and it locks

00:21:08,220 --> 00:21:11,780
the repository to that version

00:21:19,929 --> 00:21:23,669
RT the rug versions

00:21:28,410 --> 00:21:32,520
it goes out of checks that you have the

00:21:30,540 --> 00:21:34,910
right versions if we wanted to create a

00:21:32,520 --> 00:21:34,910
new project

00:21:46,059 --> 00:21:50,540
and it would actually go in and it

00:21:49,070 --> 00:21:51,650
downloads the dependencies for that

00:21:50,540 --> 00:21:54,679
project which is going to take quite a

00:21:51,650 --> 00:21:56,840
while and then it locks the repository

00:21:54,679 --> 00:22:01,419
to that version so you can install and

00:21:56,840 --> 00:22:01,419
you can maintain these various versions

00:22:07,910 --> 00:22:12,980
and so one of the kind of big decisions

00:22:10,100 --> 00:22:14,750
we made here was that in an embedded

00:22:12,980 --> 00:22:17,150
project you probably don't want to have

00:22:14,750 --> 00:22:19,940
small little packages but instead you

00:22:17,150 --> 00:22:22,580
want to have fairly beefy packages that

00:22:19,940 --> 00:22:24,080
you actually go and install right so the

00:22:22,580 --> 00:22:26,390
kernel itself is a ton of source code

00:22:24,080 --> 00:22:27,980
you probably want to go and manage that

00:22:26,390 --> 00:22:30,370
and so that's why we broke out the

00:22:27,980 --> 00:22:33,140
concept of projects and repositories and

00:22:30,370 --> 00:22:35,090
packages so packages are individual

00:22:33,140 --> 00:22:37,220
build system elements that you can

00:22:35,090 --> 00:22:39,980
include in your bill drink and build

00:22:37,220 --> 00:22:42,290
things with a project is a collection of

00:22:39,980 --> 00:22:44,840
packages and then a repository is a

00:22:42,290 --> 00:22:46,400
versioned collection of packages so what

00:22:44,840 --> 00:22:48,850
we've done is we've essentially the

00:22:46,400 --> 00:22:53,050
remote repositories in the master branch

00:22:48,850 --> 00:22:57,140
they have a definition file that points

00:22:53,050 --> 00:22:59,420
to a git branch so when you have 090

00:22:57,140 --> 00:23:02,210
that points to a get branch which is

00:22:59,420 --> 00:23:04,460
branches your underscore 090 you then

00:23:02,210 --> 00:23:07,070
have a version tracking tag which is 0

00:23:04,460 --> 00:23:09,770
dash latest and 0 dash latest points to

00:23:07,070 --> 00:23:12,890
a specific version right so in 0 dot 90

00:23:09,770 --> 00:23:15,980
if we want to update that 20 10 we

00:23:12,890 --> 00:23:18,170
update that 20 10 and the idea there is

00:23:15,980 --> 00:23:20,360
we then tie that into our versioning

00:23:18,170 --> 00:23:23,660
scheme so our versioning scheme it says

00:23:20,360 --> 00:23:28,370
that if a minor version is upgraded

00:23:23,660 --> 00:23:30,620
it'll only be bug fixes if a revision is

00:23:28,370 --> 00:23:32,360
updated it's only bug fixes if a minor

00:23:30,620 --> 00:23:35,240
version is updated it's only new

00:23:32,360 --> 00:23:38,360
features and it if you change the major

00:23:35,240 --> 00:23:41,360
version we can do whatever we want and

00:23:38,360 --> 00:23:43,640
so that's kind of the the contract with

00:23:41,360 --> 00:23:45,830
our users and so then people can

00:23:43,640 --> 00:23:48,440
actually stay on tracking branches so

00:23:45,830 --> 00:23:50,510
they can say i want to be on 10 dash

00:23:48,440 --> 00:23:52,280
latest and they know they're only

00:23:50,510 --> 00:23:55,250
getting bug fixes between those versions

00:23:52,280 --> 00:23:57,230
we we then resolve those and provide

00:23:55,250 --> 00:24:00,480
upgrade functionality for these

00:23:57,230 --> 00:24:06,179
repositories that they track against

00:24:00,480 --> 00:24:08,250
I don't know if that sounds so so build

00:24:06,179 --> 00:24:10,590
you know in the build system there's a

00:24:08,250 --> 00:24:12,990
couple of different things to look at

00:24:10,590 --> 00:24:15,570
obviously one of the major things that

00:24:12,990 --> 00:24:18,210
we do is we bundle tool chains so we

00:24:15,570 --> 00:24:21,360
expect certain versions of GCC to be

00:24:18,210 --> 00:24:24,090
there most of our code is written to GCC

00:24:21,360 --> 00:24:28,260
but we also expect certain programs like

00:24:24,090 --> 00:24:30,780
open OCD or j-link we we we have those

00:24:28,260 --> 00:24:33,299
versions all compiled into a docker

00:24:30,780 --> 00:24:35,820
image so that people who want to go and

00:24:33,299 --> 00:24:37,980
download and install our source can just

00:24:35,820 --> 00:24:39,660
get the docker image of Newt which has

00:24:37,980 --> 00:24:41,630
all of the build and debug tool chain

00:24:39,660 --> 00:24:44,429
and all of that supported for them and

00:24:41,630 --> 00:24:46,410
the goal there really is so that people

00:24:44,429 --> 00:24:48,630
don't have to worry about their compiler

00:24:46,410 --> 00:24:50,130
versions we worry about their compiler

00:24:48,630 --> 00:24:52,049
versions for them we worry about the

00:24:50,130 --> 00:24:54,179
debugger versions we bundle all of that

00:24:52,049 --> 00:24:57,090
and distribute all of that as a part of

00:24:54,179 --> 00:24:58,860
Newt so that when you download new you

00:24:57,090 --> 00:25:03,960
don't have to worry about any of that

00:24:58,860 --> 00:25:05,520
stuff that does make obviously having

00:25:03,960 --> 00:25:08,850
multiple compilers kind of an issue

00:25:05,520 --> 00:25:12,600
uh-huh we kind of made the decision very

00:25:08,850 --> 00:25:15,240
early on that it was GCC or bust we'll

00:25:12,600 --> 00:25:16,890
probably go to llvm as well but

00:25:15,240 --> 00:25:22,290
traditionally in this space you've seen

00:25:16,890 --> 00:25:25,230
iir or arm CC there are benefits to

00:25:22,290 --> 00:25:27,570
those compilers but just we thought the

00:25:25,230 --> 00:25:29,730
benefit in general of just having

00:25:27,570 --> 00:25:31,980
everybody use the same set of open free

00:25:29,730 --> 00:25:37,049
compilers was probably a better trade

00:25:31,980 --> 00:25:39,059
off for us have you considered cases

00:25:37,049 --> 00:25:44,790
where you need two compilers for a

00:25:39,059 --> 00:25:47,340
specific target device yes so there's

00:25:44,790 --> 00:25:49,230
for instance on the AMD platform you've

00:25:47,340 --> 00:25:51,390
got a separate compiler for the GPU that

00:25:49,230 --> 00:25:55,440
is llvm based but you also have the

00:25:51,390 --> 00:25:58,380
primary cpu which is GCC so and there's

00:25:55,440 --> 00:26:02,370
other cases like that so we don't

00:25:58,380 --> 00:26:04,049
include those compilers but what we do

00:26:02,370 --> 00:26:06,120
is we have compilers are a package as

00:26:04,049 --> 00:26:10,160
well so the compiler definition is

00:26:06,120 --> 00:26:12,960
compiler / arm none EAB igc

00:26:10,160 --> 00:26:15,300
c4 cortex m4 and there's a package

00:26:12,960 --> 00:26:18,210
specifically for cortex m4 that we

00:26:15,300 --> 00:26:20,670
bundle the board support package lists

00:26:18,210 --> 00:26:22,380
that compiler as a dependency and then

00:26:20,670 --> 00:26:24,960
the build system is aware of a package

00:26:22,380 --> 00:26:26,480
type that is compiler and so the board

00:26:24,960 --> 00:26:29,130
support package is really what defines

00:26:26,480 --> 00:26:32,670
what compiler is used for the rest of

00:26:29,130 --> 00:26:35,040
the system and that actually so the

00:26:32,670 --> 00:26:36,660
hierarchy that we've done is you know so

00:26:35,040 --> 00:26:38,250
what we've done is a little bit I think

00:26:36,660 --> 00:26:39,840
different than than other people we just

00:26:38,250 --> 00:26:42,210
think that the BSP is going to define

00:26:39,840 --> 00:26:45,810
most of these things so for example for

00:26:42,210 --> 00:26:47,910
our driver interfaces or for our how any

00:26:45,810 --> 00:26:51,380
of the initialization elements that we

00:26:47,910 --> 00:26:53,790
use there are chip vendor specific

00:26:51,380 --> 00:26:56,340
structures and header files that we

00:26:53,790 --> 00:26:58,500
allow people to provide into an it when

00:26:56,340 --> 00:27:01,020
they create devices or a device tree or

00:26:58,500 --> 00:27:02,940
any of that stuff what they do is they

00:27:01,020 --> 00:27:05,340
register with the operating system and

00:27:02,940 --> 00:27:08,430
they say oh all right you know I want to

00:27:05,340 --> 00:27:10,290
initialize a device a DC 0 here's the

00:27:08,430 --> 00:27:13,710
chip vendor specific header files or

00:27:10,290 --> 00:27:15,060
structures for a DC 0 and call me back

00:27:13,710 --> 00:27:16,680
at the kernel set level of

00:27:15,060 --> 00:27:18,960
initialization or call me back as the

00:27:16,680 --> 00:27:20,640
primary level of initialization and then

00:27:18,960 --> 00:27:23,520
those header files are passed opaquely

00:27:20,640 --> 00:27:25,260
to an it in the kernel process so the

00:27:23,520 --> 00:27:26,610
board Support Package really defines all

00:27:25,260 --> 00:27:28,890
of that and it defines things like

00:27:26,610 --> 00:27:31,170
compilers and everything else so the

00:27:28,890 --> 00:27:32,820
it's this is not anywhere else in the

00:27:31,170 --> 00:27:34,770
make file system except in the board

00:27:32,820 --> 00:27:37,140
support package so if you wanted to do

00:27:34,770 --> 00:27:38,430
two different types of compilers you'd

00:27:37,140 --> 00:27:40,440
need two different board support

00:27:38,430 --> 00:27:42,080
packages that you need to compile for

00:27:40,440 --> 00:27:44,940
but you could use different compilers

00:27:42,080 --> 00:27:47,090
under there so for m0 in four cases as

00:27:44,940 --> 00:27:47,090
well

00:27:55,860 --> 00:28:01,240
you have your own set of system which is

00:27:59,530 --> 00:28:05,020
very similar to that did you see any

00:28:01,240 --> 00:28:07,780
disadvantages of not doing that you know

00:28:05,020 --> 00:28:09,600
we did we started with sub modules it

00:28:07,780 --> 00:28:13,380
was just a nightmare for us to maintain

00:28:09,600 --> 00:28:16,950
and we were just not very good at it and

00:28:13,380 --> 00:28:20,350
so was there some downside suit or just

00:28:16,950 --> 00:28:22,000
like some specifics like you know there

00:28:20,350 --> 00:28:26,440
is something wrong with that you fixed

00:28:22,000 --> 00:28:28,360
in what uh yeah i mean i don't think i

00:28:26,440 --> 00:28:30,850
think if we had known how to do it

00:28:28,360 --> 00:28:35,560
properly we probably would have probably

00:28:30,850 --> 00:28:38,320
would have been okay oh the so what we

00:28:35,560 --> 00:28:40,210
do is we just essentially when we

00:28:38,320 --> 00:28:43,540
download and install a remote repository

00:28:40,210 --> 00:28:46,960
we get clone it and then we check out

00:28:43,540 --> 00:28:49,960
the branch in that git clone and just

00:28:46,960 --> 00:28:52,060
leave it like that if there's no sub

00:28:49,960 --> 00:28:53,590
module definition that we have within

00:28:52,060 --> 00:28:55,420
the repository itself that then

00:28:53,590 --> 00:28:58,390
automatically downloads or manages as a

00:28:55,420 --> 00:29:02,710
sub-module what you can do is the

00:28:58,390 --> 00:29:04,870
project state file locks to a specific

00:29:02,710 --> 00:29:06,730
version so you have the project IM will

00:29:04,870 --> 00:29:09,910
file that says i want 0 latest right

00:29:06,730 --> 00:29:12,220
that then gets resolved 2090 that gets

00:29:09,910 --> 00:29:14,410
placed in a project state file and you

00:29:12,220 --> 00:29:16,870
can resynchronize your project from the

00:29:14,410 --> 00:29:18,700
project state file so you don't so you

00:29:16,870 --> 00:29:20,650
can have a consistent set of interfaces

00:29:18,700 --> 00:29:22,600
so if you don't want to check in those

00:29:20,650 --> 00:29:25,480
repositories which is kind of why you

00:29:22,600 --> 00:29:27,100
would use a get sub module you don't

00:29:25,480 --> 00:29:29,920
have to check in those repositories you

00:29:27,100 --> 00:29:33,820
can just recreate the exact setup from a

00:29:29,920 --> 00:29:35,320
project state file but we were just I

00:29:33,820 --> 00:29:37,450
mean it was a nightmare for us to use

00:29:35,320 --> 00:29:39,450
sub modules yeah I guess it's some

00:29:37,450 --> 00:29:42,220
modules can do the same things as well

00:29:39,450 --> 00:29:45,150
so the second question is when you

00:29:42,220 --> 00:29:47,680
consider external projects can you also

00:29:45,150 --> 00:29:49,180
does it have to interface with your

00:29:47,680 --> 00:29:51,910
build system or they can be any

00:29:49,180 --> 00:29:55,390
independent module we're still working

00:29:51,910 --> 00:29:57,760
on that we've taken some steps to make

00:29:55,390 --> 00:29:59,630
that a little bit easier so a lot of the

00:29:57,760 --> 00:30:02,990
major one being chip vendor SDK

00:29:59,630 --> 00:30:07,240
that we that we want to actually go and

00:30:02,990 --> 00:30:07,240
include so what we've done there

00:30:24,419 --> 00:30:28,289
I guess I'm curious from people because

00:30:26,429 --> 00:30:30,090
I think this is a little different view

00:30:28,289 --> 00:30:31,859
than I was thinking about coming from a

00:30:30,090 --> 00:30:35,629
lennox perspective into the

00:30:31,859 --> 00:30:38,909
microcontroller space around

00:30:35,629 --> 00:30:40,470
composability of software and so I think

00:30:38,909 --> 00:30:42,379
you know one of the things I've seen

00:30:40,470 --> 00:30:45,210
from working on the Zephyr project is

00:30:42,379 --> 00:30:48,299
I'm more concerned about how we deal

00:30:45,210 --> 00:30:52,710
with external packages pt's is a

00:30:48,299 --> 00:30:54,480
software embed TLS external SDKs you

00:30:52,710 --> 00:30:57,389
know tiny crypt there's just all these

00:30:54,480 --> 00:31:00,090
packages you know the protocol stacks

00:30:57,389 --> 00:31:02,519
right that are separate packages kind of

00:31:00,090 --> 00:31:04,919
our developments and so forth and you

00:31:02,519 --> 00:31:07,320
know there's obviously a difference so I

00:31:04,919 --> 00:31:08,970
think that's the class of problem I was

00:31:07,320 --> 00:31:10,739
having in my mind and I think there's a

00:31:08,970 --> 00:31:13,230
different class of problem that you guys

00:31:10,739 --> 00:31:19,249
are coming from which is it as valid

00:31:13,230 --> 00:31:21,690
about packages of software somewhat

00:31:19,249 --> 00:31:24,330
internally built but also towards how

00:31:21,690 --> 00:31:27,389
kind of you taking the OS view that my

00:31:24,330 --> 00:31:29,820
newts taking as well about the

00:31:27,389 --> 00:31:32,070
separation and distinction of breaking

00:31:29,820 --> 00:31:34,019
things up where things effort takes an

00:31:32,070 --> 00:31:38,009
approach of that's more everything's

00:31:34,019 --> 00:31:40,499
together filesystem IP stack console all

00:31:38,009 --> 00:31:45,269
that kind of stuff and so I'm kind of

00:31:40,499 --> 00:31:50,730
curious as far as from a application

00:31:45,269 --> 00:31:53,460
point of view do people see this value

00:31:50,730 --> 00:31:55,109
need problem is it you know that just

00:31:53,460 --> 00:31:56,789
from a because it's not what I didn't

00:31:55,109 --> 00:31:59,009
even thinking about is to kind of you

00:31:56,789 --> 00:32:02,369
know kind of drawing the line at the

00:31:59,009 --> 00:32:04,350
sand of kind of what the OS provides and

00:32:02,369 --> 00:32:07,470
maybe a BSP DK however you want to think

00:32:04,350 --> 00:32:11,850
about it and leaving how an application

00:32:07,470 --> 00:32:16,769
system product is managed to themselves

00:32:11,850 --> 00:32:19,109
so to speak so I think in zipper we are

00:32:16,769 --> 00:32:21,239
actually doing what my new does in a

00:32:19,109 --> 00:32:24,090
completely different way so we are doing

00:32:21,239 --> 00:32:26,220
that I mean you look at SOC SMBs piece

00:32:24,090 --> 00:32:27,809
on board these are basically modules

00:32:26,220 --> 00:32:28,570
because you can actually interchange

00:32:27,809 --> 00:32:31,240
them

00:32:28,570 --> 00:32:34,600
when you look at tiny clipped and mpls

00:32:31,240 --> 00:32:36,279
exactly the same thing by providing one

00:32:34,600 --> 00:32:39,970
single API actually to talk to the

00:32:36,279 --> 00:32:43,690
crypto the way we do it is it's probably

00:32:39,970 --> 00:32:47,049
different looking for example at my

00:32:43,690 --> 00:32:49,029
nausea and different file systems where

00:32:47,049 --> 00:32:52,600
do you implement the FBI is it part of

00:32:49,029 --> 00:32:55,929
their OS or is it part of the module

00:32:52,600 --> 00:32:59,350
itself so who does provide dot H file so

00:32:55,929 --> 00:33:02,799
so we have a FS / FS which is the file

00:32:59,350 --> 00:33:04,570
system API and then we have FS / n FF s

00:33:02,799 --> 00:33:09,220
which is our log structured flash file

00:33:04,570 --> 00:33:11,820
system and so n FF s provides an

00:33:09,220 --> 00:33:14,889
implementation of the file system API

00:33:11,820 --> 00:33:17,259
okay and this would be actually exactly

00:33:14,889 --> 00:33:18,850
the same API is basically a different

00:33:17,259 --> 00:33:23,259
implementation and they would be part of

00:33:18,850 --> 00:33:25,600
the package yep a not part of the OS so

00:33:23,259 --> 00:33:28,779
I have actually so basically it's not

00:33:25,600 --> 00:33:30,879
like I have an API which is part of the

00:33:28,779 --> 00:33:34,000
OS with different implementations that

00:33:30,879 --> 00:33:35,980
implement this API but no I mean there

00:33:34,000 --> 00:33:38,019
comes a package with with everything in

00:33:35,980 --> 00:33:42,039
it including the API itself yeah that I

00:33:38,019 --> 00:33:43,600
add to my application in this case well

00:33:42,039 --> 00:33:46,990
that's right so what essentially happens

00:33:43,600 --> 00:33:48,700
is you have apache my new core / FS / MS

00:33:46,990 --> 00:33:50,860
and if you're an application that's

00:33:48,700 --> 00:33:53,169
using a file system you're going to

00:33:50,860 --> 00:33:55,149
include that as a dependency and that

00:33:53,169 --> 00:33:57,820
contains a set of functions that point

00:33:55,149 --> 00:34:02,019
into the various file systems that then

00:33:57,820 --> 00:34:03,850
register into the system FF /n ffs is an

00:34:02,019 --> 00:34:08,109
example of one of those file system

00:34:03,850 --> 00:34:09,940
implementations there are others like FS

00:34:08,109 --> 00:34:12,669
/ fat which we're adding support for

00:34:09,940 --> 00:34:15,099
because of whatever so they just there's

00:34:12,669 --> 00:34:17,319
there's a defined interface in the FS /

00:34:15,099 --> 00:34:20,800
FS package which defines a set of

00:34:17,319 --> 00:34:23,770
handlers for seek open close all of

00:34:20,800 --> 00:34:27,310
those things and then the individual

00:34:23,770 --> 00:34:29,379
file system packages themselves register

00:34:27,310 --> 00:34:31,450
in and the board support package then

00:34:29,379 --> 00:34:34,450
creates the file systems that are on the

00:34:31,450 --> 00:34:36,460
system so the board right you you're

00:34:34,450 --> 00:34:40,270
writing an app and you say I want to

00:34:36,460 --> 00:34:44,200
open a file at / you know

00:34:40,270 --> 00:34:45,669
x / y you you include the FS package to

00:34:44,200 --> 00:34:47,860
do that and you open the file at that

00:34:45,669 --> 00:34:50,830
location you expect it to be there or

00:34:47,860 --> 00:34:52,630
you can use standard kind of unix e file

00:34:50,830 --> 00:34:55,540
system functions to discover the file

00:34:52,630 --> 00:34:58,180
system and then the board support

00:34:55,540 --> 00:35:00,610
package actually is what defines which

00:34:58,180 --> 00:35:06,280
file systems that are included and where

00:35:00,610 --> 00:35:08,680
they're mounted going so to go ahead so

00:35:06,280 --> 00:35:12,670
I'm still learning this but it seems to

00:35:08,680 --> 00:35:16,180
me as though you've defined at a very

00:35:12,670 --> 00:35:18,010
high level the general components that

00:35:16,180 --> 00:35:19,300
you want in your OS went along with a

00:35:18,010 --> 00:35:21,180
set of interfaces that can then be

00:35:19,300 --> 00:35:24,190
replaced by by any particular

00:35:21,180 --> 00:35:26,170
implementation and for to some extent

00:35:24,190 --> 00:35:27,340
this is kind of the Wild West in terms

00:35:26,170 --> 00:35:28,720
of you know you can put whatever

00:35:27,340 --> 00:35:31,720
implementation you wanna there that's

00:35:28,720 --> 00:35:35,470
driven by the BSP to Kumar's point

00:35:31,720 --> 00:35:37,840
that's a different focus than generally

00:35:35,470 --> 00:35:39,400
what you see I'm not as familiar with

00:35:37,840 --> 00:35:41,080
Zephyr but obviously in the octo project

00:35:39,400 --> 00:35:43,900
openembedded there's more of a

00:35:41,080 --> 00:35:45,520
monolithic idea of everything's going to

00:35:43,900 --> 00:35:47,070
kind of come together it goes to my

00:35:45,520 --> 00:35:49,000
question about the the tool chains

00:35:47,070 --> 00:35:51,370
everything is going to kind of play

00:35:49,000 --> 00:35:53,440
together into a single build that you're

00:35:51,370 --> 00:35:57,400
going to end up with a final image with

00:35:53,440 --> 00:35:59,380
so it seems like this is more as you

00:35:57,400 --> 00:36:00,640
said composable but from by does by

00:35:59,380 --> 00:36:04,690
design you really want everything to be

00:36:00,640 --> 00:36:06,820
replaceable with with something that the

00:36:04,690 --> 00:36:08,880
vendor wants to do or the application

00:36:06,820 --> 00:36:11,440
develop it wants to do is set son right

00:36:08,880 --> 00:36:14,080
it's more how we do we lay out our

00:36:11,440 --> 00:36:17,530
system so in the case of file systems

00:36:14,080 --> 00:36:19,510
right we we think that there should be

00:36:17,530 --> 00:36:21,100
an abstract API in the operating system

00:36:19,510 --> 00:36:23,800
in a min minut core that goes across

00:36:21,100 --> 00:36:26,470
multiple file systems so we have a file

00:36:23,800 --> 00:36:28,750
system API that's not enforced by the

00:36:26,470 --> 00:36:31,210
build system in any way but the build

00:36:28,750 --> 00:36:33,280
system allows us to go do that in other

00:36:31,210 --> 00:36:34,870
cases we just directly have

00:36:33,280 --> 00:36:37,270
implementations of things so like our

00:36:34,870 --> 00:36:39,220
Bluetooth stack is just a direct

00:36:37,270 --> 00:36:42,430
implementation of the Bluetooth host and

00:36:39,220 --> 00:36:44,620
a direct implementation of the Bluetooth

00:36:42,430 --> 00:36:48,190
controller the only case where we make

00:36:44,620 --> 00:36:50,530
things pluggable in that stack is at the

00:36:48,190 --> 00:36:51,260
driver level right so we have driver

00:36:50,530 --> 00:36:59,750
implementation

00:36:51,260 --> 00:37:02,120
are 51 52 and native so I think and kind

00:36:59,750 --> 00:37:04,760
of the Zephyrs kind of I think sort of

00:37:02,120 --> 00:37:06,890
like Linux in this respect and from an

00:37:04,760 --> 00:37:08,120
OS what we how we think of an OS and

00:37:06,890 --> 00:37:09,310
they kind of differs I think in the

00:37:08,120 --> 00:37:12,560
microcontroller space about the

00:37:09,310 --> 00:37:15,650
executive which is a very extremely too

00:37:12,560 --> 00:37:17,600
small just you know piece of kind of

00:37:15,650 --> 00:37:20,210
what we think of like Colonel core would

00:37:17,600 --> 00:37:22,460
be but but in zephyr much like Lennox

00:37:20,210 --> 00:37:24,820
where we have the drivers directory file

00:37:22,460 --> 00:37:28,130
system networking right all of that is

00:37:24,820 --> 00:37:30,410
revision under one git repo we use K

00:37:28,130 --> 00:37:34,310
config to do selection right so a lot of

00:37:30,410 --> 00:37:37,160
that stuff is being the equivalency is

00:37:34,310 --> 00:37:38,990
through the system here with the YAML

00:37:37,160 --> 00:37:40,910
files and dependencies and if we were to

00:37:38,990 --> 00:37:44,630
version everything independently and

00:37:40,910 --> 00:37:47,360
break it apart and so to speak it's part

00:37:44,630 --> 00:37:49,400
of what is going on on kind of what you

00:37:47,360 --> 00:37:51,430
know where one draws the OS line and

00:37:49,400 --> 00:37:53,840
thinks about it is kind of one aspect

00:37:51,430 --> 00:37:55,250
and then I think that was kind of where

00:37:53,840 --> 00:37:57,530
I was starting to ask the question of

00:37:55,250 --> 00:37:59,930
eight there's also the ability to deal

00:37:57,530 --> 00:38:02,600
with this for application code and then

00:37:59,930 --> 00:38:04,550
there's the third party which is the

00:38:02,600 --> 00:38:06,020
beep when I was coming from kind of

00:38:04,550 --> 00:38:08,510
peace where we come in from like Oh II

00:38:06,020 --> 00:38:10,190
or so forth where you're building you

00:38:08,510 --> 00:38:12,710
know the colonel is a package but then

00:38:10,190 --> 00:38:14,180
you've got you know just all of your

00:38:12,710 --> 00:38:15,850
users based stuff that we're building

00:38:14,180 --> 00:38:18,470
now obviously there's not this user

00:38:15,850 --> 00:38:21,170
kernels or you know not this user space

00:38:18,470 --> 00:38:25,040
split typically in these environments

00:38:21,170 --> 00:38:29,030
but there is that kind of you know

00:38:25,040 --> 00:38:32,660
protocol stack so co app or an HTTP

00:38:29,030 --> 00:38:33,980
library or you know embed TLS or there's

00:38:32,660 --> 00:38:36,980
all these other things that our

00:38:33,980 --> 00:38:39,410
application packages or pieces of

00:38:36,980 --> 00:38:41,450
software that I'm curious and obviously

00:38:39,410 --> 00:38:44,390
your sounds like you guys are starting

00:38:41,450 --> 00:38:47,660
down that path with obviously some of

00:38:44,390 --> 00:38:51,590
the V SOC SDKs but I'm kind of curious

00:38:47,660 --> 00:38:54,340
what else yeah so I mean I think you

00:38:51,590 --> 00:38:56,260
know we we are very similar to Zephyr in

00:38:54,340 --> 00:38:58,330
the way that you know Apache my new core

00:38:56,260 --> 00:39:01,120
which I've kind of is that repository

00:38:58,330 --> 00:39:04,060
does contain a version set of packages

00:39:01,120 --> 00:39:05,650
right and we distribute file systems

00:39:04,060 --> 00:39:08,170
with that and Bluetooth networking

00:39:05,650 --> 00:39:12,280
stacks and all of those things in Apache

00:39:08,170 --> 00:39:14,230
my new core the the package dependencies

00:39:12,280 --> 00:39:16,240
is more of a build system thing that

00:39:14,230 --> 00:39:19,630
allows you to you know we make it very

00:39:16,240 --> 00:39:21,940
configurable mainly so that people can

00:39:19,630 --> 00:39:23,380
reduce code size because you don't want

00:39:21,940 --> 00:39:25,120
to bring a whole bunch of stuff into the

00:39:23,380 --> 00:39:26,590
build system and so that you have a very

00:39:25,120 --> 00:39:29,050
clear picture of what's getting built

00:39:26,590 --> 00:39:31,300
and a lot of control over what is built

00:39:29,050 --> 00:39:33,280
in the system so that we can keep code

00:39:31,300 --> 00:39:34,840
size down the second point you were

00:39:33,280 --> 00:39:37,180
making I think is a good one I think

00:39:34,840 --> 00:39:39,610
scripting languages are a perfect place

00:39:37,180 --> 00:39:41,500
to kind of look at how you might do that

00:39:39,610 --> 00:39:43,300
right so we have I don't think we

00:39:41,500 --> 00:39:47,590
bundled allu into the core and I think

00:39:43,300 --> 00:39:49,960
that was a mistake that we made people

00:39:47,590 --> 00:39:51,370
Luanne to the core I don't think the

00:39:49,960 --> 00:39:56,850
operating system should contain a

00:39:51,370 --> 00:39:56,850
scripting that's my opinion um it's

00:39:59,550 --> 00:40:05,230
that's good but yeah kind of composing

00:40:03,040 --> 00:40:06,850
that so so so now you want to have

00:40:05,230 --> 00:40:08,350
apache mine of core and if you look at

00:40:06,850 --> 00:40:10,060
most of the scripting languages out

00:40:08,350 --> 00:40:12,610
there Jerry script i think is probably a

00:40:10,060 --> 00:40:14,650
outlier they actually contain their own

00:40:12,610 --> 00:40:16,840
operating systems and right so the

00:40:14,650 --> 00:40:19,570
scripting like jerry script the ones

00:40:16,840 --> 00:40:21,400
people use in this space are Esprit no &

00:40:19,570 --> 00:40:23,200
mike mike rowe python you go through

00:40:21,400 --> 00:40:24,600
they have their own house they have

00:40:23,200 --> 00:40:27,040
their own board support infrastructure

00:40:24,600 --> 00:40:29,970
they've basically built an operating

00:40:27,040 --> 00:40:33,100
system bare metal operating systems and

00:40:29,970 --> 00:40:34,840
it doesn't to me make sense that all of

00:40:33,100 --> 00:40:36,730
these different scripting engines are

00:40:34,840 --> 00:40:38,260
going to have their own operating

00:40:36,730 --> 00:40:40,720
systems eventually they'll adopt like

00:40:38,260 --> 00:40:43,990
Zefram writing or something else so so

00:40:40,720 --> 00:40:46,180
where you would use the composable

00:40:43,990 --> 00:40:48,190
aspect of this is you would want to have

00:40:46,180 --> 00:40:50,800
those scripting engines to have a

00:40:48,190 --> 00:40:52,510
dependency on apache minded core as a

00:40:50,800 --> 00:40:54,520
repository and you could specify that in

00:40:52,510 --> 00:40:56,380
a project Diane will file and they would

00:40:54,520 --> 00:40:58,150
want to depend on a specific version of

00:40:56,380 --> 00:40:59,510
my Apache my new core and that would be

00:40:58,150 --> 00:41:02,130
a source code dependent

00:40:59,510 --> 00:41:04,289
right along with a set of AP is that

00:41:02,130 --> 00:41:17,250
were exported and a virgin along with

00:41:04,289 --> 00:41:19,140
that so what you would do yeah well file

00:41:17,250 --> 00:41:21,119
and you would in the project you've

00:41:19,140 --> 00:41:23,369
created so you create your own custom

00:41:21,119 --> 00:41:26,160
project as a user right and you say

00:41:23,369 --> 00:41:27,930
newton ooh my project you would then in

00:41:26,160 --> 00:41:30,210
that project animals file say i want to

00:41:27,930 --> 00:41:32,490
have a patchy my new core and i want to

00:41:30,210 --> 00:41:34,890
have this remote repository which is

00:41:32,490 --> 00:41:36,900
jerry skipped hooked into Apache my new

00:41:34,890 --> 00:41:38,730
core this would install both of those

00:41:36,900 --> 00:41:41,039
and then you could go and create a

00:41:38,730 --> 00:41:43,680
compilation target to go build that

00:41:41,039 --> 00:41:45,569
system but I think you want the you know

00:41:43,680 --> 00:41:47,430
what we did for the package management

00:41:45,569 --> 00:41:49,740
system is we had all these little

00:41:47,430 --> 00:41:52,980
packages so libs OS was a separately

00:41:49,740 --> 00:41:54,420
installable package or pretty much every

00:41:52,980 --> 00:41:56,130
package in our system was separately

00:41:54,420 --> 00:41:59,339
installable and it just became a

00:41:56,130 --> 00:42:01,319
nightmare to maintain oh I see you might

00:41:59,339 --> 00:42:03,630
imagine and we actually tied in the

00:42:01,319 --> 00:42:05,789
concept of building and and package

00:42:03,630 --> 00:42:10,170
installation which was are completely

00:42:05,789 --> 00:42:11,730
separate but so what we what we came to

00:42:10,170 --> 00:42:14,670
is you want to be able to redistribute

00:42:11,730 --> 00:42:17,190
kind of big chunks of source and you

00:42:14,670 --> 00:42:18,930
want to allow people to to to manage big

00:42:17,190 --> 00:42:20,880
strong source but then once you go

00:42:18,930 --> 00:42:22,529
within those chunks you want to have a

00:42:20,880 --> 00:42:24,839
lot of flexibility and configurability

00:42:22,529 --> 00:42:27,720
so that you don't build the entire world

00:42:24,839 --> 00:42:29,640
right and a lot of what i don't like

00:42:27,720 --> 00:42:32,760
about the linux side of the build

00:42:29,640 --> 00:42:34,890
systems was the fact that pretty much

00:42:32,760 --> 00:42:36,329
everything gets built and then it's left

00:42:34,890 --> 00:42:38,490
to the linker to sort out a lot of this

00:42:36,329 --> 00:42:39,930
stuff and so you're constantly like

00:42:38,490 --> 00:42:42,960
going through and saying what's compiled

00:42:39,930 --> 00:42:46,260
in what isn't compiled in how do I know

00:42:42,960 --> 00:42:47,549
what's going on here and so a lot of the

00:42:46,260 --> 00:42:49,109
dependencies is also just to be very

00:42:47,549 --> 00:42:51,660
clear about what's getting built how

00:42:49,109 --> 00:42:56,299
it's getting built I'm letting users

00:42:51,660 --> 00:42:59,579
write that out so I think you need like

00:42:56,299 --> 00:43:01,140
same SDK across the whole ecosystem to

00:42:59,579 --> 00:43:03,839
support something like that otherwise

00:43:01,140 --> 00:43:05,600
what's the versioning control and all

00:43:03,839 --> 00:43:08,060
those issues that will come come

00:43:05,600 --> 00:43:09,980
long right oh yeah well you don't need

00:43:08,060 --> 00:43:12,140
the same SDK I mean you just need it all

00:43:09,980 --> 00:43:14,510
to be in your world okay you know kind

00:43:12,140 --> 00:43:17,270
of there is a tax for participating in

00:43:14,510 --> 00:43:21,170
this world yeah and you have to kind of

00:43:17,270 --> 00:43:23,570
take that tax otherwise it becomes hard

00:43:21,170 --> 00:43:25,490
to manage but there are benefits to it

00:43:23,570 --> 00:43:27,950
right like namespacing things I think

00:43:25,490 --> 00:43:29,600
every chip vendor header file that I've

00:43:27,950 --> 00:43:31,850
ever seen that's ever gotten delivered

00:43:29,600 --> 00:43:35,180
has a completely different name space in

00:43:31,850 --> 00:43:38,330
it and that's really really painful

00:43:35,180 --> 00:43:40,550
right we've added some build rules to

00:43:38,330 --> 00:43:42,830
handle that so what we do it for package

00:43:40,550 --> 00:43:45,680
types that are SD SDKs for chip vendor

00:43:42,830 --> 00:43:49,780
SDKs what we essentially do is we go in

00:43:45,680 --> 00:43:52,790
the directory and we recursively compile

00:43:49,780 --> 00:43:55,460
every element of the SDK directory we

00:43:52,790 --> 00:43:58,940
also recursively add into the include

00:43:55,460 --> 00:44:00,590
path all of those header files in order

00:43:58,940 --> 00:44:01,940
to build those and then have a set of

00:44:00,590 --> 00:44:09,920
rules that allow you to define what you

00:44:01,940 --> 00:44:11,870
compile as curious in sama if you don't

00:44:09,920 --> 00:44:13,460
mind just come from an embed point of

00:44:11,870 --> 00:44:17,300
view or if you can talk maybe a little

00:44:13,460 --> 00:44:20,590
bit just similarities differences from

00:44:17,300 --> 00:44:23,450
we've heard about composability

00:44:20,590 --> 00:44:25,880
dependencies and where it is today maybe

00:44:23,450 --> 00:44:31,040
you know are the things you know so

00:44:25,880 --> 00:44:34,640
forth okay so anybody who saw the

00:44:31,040 --> 00:44:36,860
presentation monday embed the current 5

00:44:34,640 --> 00:44:40,580
version we're working on ships without

00:44:36,860 --> 00:44:43,760
yata without this type of a detailed

00:44:40,580 --> 00:44:45,920
system included inside of it and this

00:44:43,760 --> 00:44:47,210
conversation brings back a lot of things

00:44:45,920 --> 00:44:50,060
that we'd gone through over the last 12

00:44:47,210 --> 00:44:52,280
to 18 months and it's it all just

00:44:50,060 --> 00:44:54,080
resonates right module fatigue module

00:44:52,280 --> 00:44:56,060
fragmentation is a very very hard thing

00:44:54,080 --> 00:44:58,280
to do you know are you compiling the OS

00:44:56,060 --> 00:45:00,380
oh I'm sorry are you composing the OS or

00:44:58,280 --> 00:45:04,070
are you composing applications these are

00:45:00,380 --> 00:45:05,990
very clear things that being on is we

00:45:04,070 --> 00:45:08,090
got completely wrong the first time

00:45:05,990 --> 00:45:10,430
around which made the adoption of our

00:45:08,090 --> 00:45:11,690
software very hard at the end of the day

00:45:10,430 --> 00:45:13,850
I think the most important thing to

00:45:11,690 --> 00:45:15,170
remember is it's not about the

00:45:13,850 --> 00:45:17,070
automation and what we're doing inside

00:45:15,170 --> 00:45:18,600
of here the tools are

00:45:17,070 --> 00:45:21,120
for that such that we deliver good

00:45:18,600 --> 00:45:22,860
software but it's also about how these

00:45:21,120 --> 00:45:24,630
fit into the environments of people who

00:45:22,860 --> 00:45:27,060
are going to adopt the code and go build

00:45:24,630 --> 00:45:30,000
products with it and you know part two

00:45:27,060 --> 00:45:32,640
what we got very wrong was the fact that

00:45:30,000 --> 00:45:36,660
a lot of the you know dynamic

00:45:32,640 --> 00:45:39,150
installation or injecting scripting with

00:45:36,660 --> 00:45:40,740
kind of see style development with the

00:45:39,150 --> 00:45:42,630
Ides and tools that exist that are

00:45:40,740 --> 00:45:43,920
commercially available when that big

00:45:42,630 --> 00:45:45,270
product companies who are shipping

00:45:43,920 --> 00:45:47,700
millions and millions of devices are

00:45:45,270 --> 00:45:49,170
using those two things are actually kind

00:45:47,700 --> 00:45:51,180
of opposing and when you go talk to

00:45:49,170 --> 00:45:52,860
those companies about their engineering

00:45:51,180 --> 00:45:54,990
practices and the requirements that they

00:45:52,860 --> 00:45:56,670
put on their teams to deliver quality

00:45:54,990 --> 00:45:58,370
products that they can measure against

00:45:56,670 --> 00:46:01,140
you know ISO standards and other things

00:45:58,370 --> 00:46:05,760
this world doesn't fit it's really cool

00:46:01,140 --> 00:46:07,920
for you know I don't know entry level

00:46:05,760 --> 00:46:09,750
and I think maybe in a couple years it's

00:46:07,920 --> 00:46:11,790
going to be something again that does

00:46:09,750 --> 00:46:15,390
fit you know symphysis is going down a

00:46:11,790 --> 00:46:16,980
path trying it with the packs not as in

00:46:15,390 --> 00:46:19,140
your face it's everything's there and

00:46:16,980 --> 00:46:22,380
you kind of clicky choosy pull it in and

00:46:19,140 --> 00:46:24,180
so we're embed is now at this point is

00:46:22,380 --> 00:46:25,860
much more of where we were three years

00:46:24,180 --> 00:46:28,290
ago which was yes we believe

00:46:25,860 --> 00:46:29,730
repositories are important not so much

00:46:28,290 --> 00:46:31,980
the type of the repositories whether

00:46:29,730 --> 00:46:34,650
it's get or svn or mercurial it doesn't

00:46:31,980 --> 00:46:37,110
matter and one of the pain points had

00:46:34,650 --> 00:46:38,760
been we were very tight in a trio before

00:46:37,110 --> 00:46:40,170
and so then the branching model of

00:46:38,760 --> 00:46:42,120
material and the branching model of get

00:46:40,170 --> 00:46:46,130
is very different with respect to how

00:46:42,120 --> 00:46:49,380
heads and masters and remotes work so I

00:46:46,130 --> 00:46:51,330
don't know current position is at least

00:46:49,380 --> 00:46:53,670
from but five as a major series of

00:46:51,330 --> 00:46:55,350
development that if the software is

00:46:53,670 --> 00:46:56,700
there it just built and we should all

00:46:55,350 --> 00:46:59,790
work out you know the name spacing

00:46:56,700 --> 00:47:01,170
issues the unique file names for it

00:46:59,790 --> 00:47:02,400
could you build these build systems you

00:47:01,170 --> 00:47:04,560
work around these things they're very

00:47:02,400 --> 00:47:06,150
flexible you can have multiple files and

00:47:04,560 --> 00:47:08,700
it links because you're passing the path

00:47:06,150 --> 00:47:10,950
to the linkers you go to an ir or even

00:47:08,700 --> 00:47:12,660
MDK environment and that fails well the

00:47:10,950 --> 00:47:14,610
moment that somebody is taking your code

00:47:12,660 --> 00:47:16,440
in who must use one of those tools in

00:47:14,610 --> 00:47:17,850
their environment there now modifying

00:47:16,440 --> 00:47:20,910
your code whether it's ensure you're out

00:47:17,850 --> 00:47:22,080
of tree in my opinion we just failed so

00:47:20,910 --> 00:47:24,720
those are all things very important and

00:47:22,080 --> 00:47:27,210
I think just generally good design

00:47:24,720 --> 00:47:28,980
practices for these OS is what's being

00:47:27,210 --> 00:47:29,570
delivered the packaging stuff is great

00:47:28,980 --> 00:47:31,130
in

00:47:29,570 --> 00:47:34,580
whether its branch models whether it's

00:47:31,130 --> 00:47:35,750
is it packages in other repositories you

00:47:34,580 --> 00:47:38,510
know we'll get there but right now our

00:47:35,750 --> 00:47:40,670
current position is pretty much you know

00:47:38,510 --> 00:47:43,070
if it's in a repo it comes in and we

00:47:40,670 --> 00:47:47,480
build it and it has a lot of limitations

00:47:43,070 --> 00:47:48,860
but given those positions it moves us

00:47:47,480 --> 00:47:50,180
forward to the point where we can

00:47:48,860 --> 00:47:53,660
continue to kind of study and try to

00:47:50,180 --> 00:47:56,870
solve these problems do you guys try to

00:47:53,660 --> 00:47:58,280
address at all at Adam trying to figure

00:47:56,870 --> 00:48:00,560
out how to terminal adji for us all to

00:47:58,280 --> 00:48:02,570
talk consistently because I think that's

00:48:00,560 --> 00:48:04,190
definitely something kind of coming out

00:48:02,570 --> 00:48:07,130
of this session and I know we'll have

00:48:04,190 --> 00:48:11,060
more conversations about but kind of the

00:48:07,130 --> 00:48:17,060
the layers above so I'm trying to think

00:48:11,060 --> 00:48:19,280
of a good example so a co-op stack maybe

00:48:17,060 --> 00:48:20,600
that's not something you guys you know

00:48:19,280 --> 00:48:22,100
it's not and maybe that's not the best

00:48:20,600 --> 00:48:24,280
one but just something like that like

00:48:22,100 --> 00:48:26,720
you know that is kind of an application

00:48:24,280 --> 00:48:28,790
potential thing maybe it's some

00:48:26,720 --> 00:48:30,770
third-party someone's developed the coop

00:48:28,790 --> 00:48:33,020
stack that's out there maybe there's

00:48:30,770 --> 00:48:36,830
still some integration so too that needs

00:48:33,020 --> 00:48:38,210
to be done for to work on em bed is that

00:48:36,830 --> 00:48:39,650
something you guys deal with yet or is

00:48:38,210 --> 00:48:42,590
that something you kind of let that sort

00:48:39,650 --> 00:48:46,510
of push to the application developer to

00:48:42,590 --> 00:48:48,650
kind of manage themselves so the

00:48:46,510 --> 00:48:50,360
object-oriented approach to development

00:48:48,650 --> 00:48:53,660
has helped us with that a little bit

00:48:50,360 --> 00:48:54,980
meaning we follow trends we watch what

00:48:53,660 --> 00:48:56,690
people do we watch what's hot we

00:48:54,980 --> 00:48:58,880
obviously have our own interest as far

00:48:56,690 --> 00:49:01,610
as what we think should be inside of an

00:48:58,880 --> 00:49:03,380
OS and things like web sockets and co-op

00:49:01,610 --> 00:49:04,970
and such there should be one there's not

00:49:03,380 --> 00:49:06,980
if it's written well and if it's written

00:49:04,970 --> 00:49:09,470
against the standard there shouldn't

00:49:06,980 --> 00:49:11,840
necessarily be a need to bring in

00:49:09,470 --> 00:49:13,190
different pieces like that in some cases

00:49:11,840 --> 00:49:16,160
okay so maybe that's not a good example

00:49:13,190 --> 00:49:19,340
but let's say let's say for some reason

00:49:16,160 --> 00:49:20,990
there's a file system that for this

00:49:19,340 --> 00:49:22,820
customer it's there's an open source

00:49:20,990 --> 00:49:24,710
project it's not one that you guys have

00:49:22,820 --> 00:49:27,470
seen really a vested interest in so it's

00:49:24,710 --> 00:49:29,000
not part of em bed standard you know you

00:49:27,470 --> 00:49:30,920
know what is the store you know is it

00:49:29,000 --> 00:49:32,030
yeah what's the story candle yeah so

00:49:30,920 --> 00:49:34,880
who's gonna know what that is the story

00:49:32,030 --> 00:49:36,590
is for common components there is that

00:49:34,880 --> 00:49:38,870
object oriented contract to the

00:49:36,590 --> 00:49:40,070
developers which we say in many cases

00:49:38,870 --> 00:49:42,030
you know sometimes it's in the OS and

00:49:40,070 --> 00:49:43,860
sometimes it's just a piece of code

00:49:42,030 --> 00:49:45,120
we float out there which is here's an

00:49:43,860 --> 00:49:47,220
interface and we think this is quite

00:49:45,120 --> 00:49:48,600
good and there's a contract for people

00:49:47,220 --> 00:49:50,160
developing on the top and then there's a

00:49:48,600 --> 00:49:52,470
contract on the bottom for people

00:49:50,160 --> 00:49:54,150
porting against it and as those things

00:49:52,470 --> 00:49:55,560
mature as we find out how people use

00:49:54,150 --> 00:49:57,750
things and what the requirements are

00:49:55,560 --> 00:49:59,820
sometimes those api's come into the code

00:49:57,750 --> 00:50:02,400
base such that you know one could be

00:49:59,820 --> 00:50:04,530
enabled as a feature or excluded and

00:50:02,400 --> 00:50:05,790
replaced by you know again an external

00:50:04,530 --> 00:50:08,250
piece of software whether that's the

00:50:05,790 --> 00:50:10,830
file system that then provided the lower

00:50:08,250 --> 00:50:13,650
level contract if the OS had the API the

00:50:10,830 --> 00:50:15,840
API still exposed and if it's still kind

00:50:13,650 --> 00:50:17,610
of under development maybe alpha or beta

00:50:15,840 --> 00:50:18,930
as to what it does and it's typically

00:50:17,610 --> 00:50:21,690
just floating around out of the

00:50:18,930 --> 00:50:23,870
repository elsewhere that these pieces

00:50:21,690 --> 00:50:27,240
can bring in and distribute themselves

00:50:23,870 --> 00:50:29,250
and it's really about learning you know

00:50:27,240 --> 00:50:32,040
what now people use these different

00:50:29,250 --> 00:50:33,810
things I think we have a couple minutes

00:50:32,040 --> 00:50:39,030
left so I just maybe open up anyone

00:50:33,810 --> 00:50:41,280
generally have any questions or yeah I I

00:50:39,030 --> 00:50:44,370
you know what one of the distinctions is

00:50:41,280 --> 00:50:46,980
that it was talking to Simon Ford about

00:50:44,370 --> 00:50:49,080
you know the iterations through ambad

00:50:46,980 --> 00:50:51,720
know and do you talk about tooling for

00:50:49,080 --> 00:50:55,320
consumers or producers and I think you

00:50:51,720 --> 00:50:57,840
know the much of the MCU space is is

00:50:55,320 --> 00:50:59,610
producer folk or consumer focus where

00:50:57,840 --> 00:51:01,770
they want a single ID in a single tool

00:50:59,610 --> 00:51:05,580
chain and it you know just point and

00:51:01,770 --> 00:51:06,920
click and build whereas many many of the

00:51:05,580 --> 00:51:10,410
people in the room I think are more

00:51:06,920 --> 00:51:12,810
producers and they're used to command

00:51:10,410 --> 00:51:14,580
line tooling and multiple is a is the

00:51:12,810 --> 00:51:15,840
multiple tool chains and have to deal

00:51:14,580 --> 00:51:18,930
with that and so do you do you

00:51:15,840 --> 00:51:21,870
differentiate between a tool set for

00:51:18,930 --> 00:51:24,630
producers versus tool sets for consumers

00:51:21,870 --> 00:51:29,100
and so we've been we tried to do

00:51:24,630 --> 00:51:33,960
packaging and build from TI and and

00:51:29,100 --> 00:51:35,940
miserably failed so i appreciate the the

00:51:33,960 --> 00:51:38,040
challenges and we have similar concepts

00:51:35,940 --> 00:51:41,310
and challenges but you know we move more

00:51:38,040 --> 00:51:44,280
towards a internal tooling thing that

00:51:41,310 --> 00:51:47,820
generates external artifacts that makes

00:51:44,280 --> 00:51:50,370
it easy to work in ir or GCC or that

00:51:47,820 --> 00:51:51,400
sort of thing and anyway i just throw

00:51:50,370 --> 00:51:53,230
that as a

00:51:51,400 --> 00:51:57,789
as a distinction but and to your point

00:51:53,230 --> 00:52:00,039
you know I think being able to compose a

00:51:57,789 --> 00:52:01,930
single executable which is different

00:52:00,039 --> 00:52:03,460
than the Linux case is really a

00:52:01,930 --> 00:52:05,859
challenge here so we're going to be able

00:52:03,460 --> 00:52:07,630
to bring in third-party algorithms and

00:52:05,859 --> 00:52:10,329
so forth it would sure be nice if you

00:52:07,630 --> 00:52:13,500
could build them the same way as when

00:52:10,329 --> 00:52:15,730
you link or build with your OS and so I

00:52:13,500 --> 00:52:17,920
appreciate the goal i'm not sure how to

00:52:15,730 --> 00:52:22,720
solve it but i think it's something we'd

00:52:17,920 --> 00:52:26,049
like to because there is a different

00:52:22,720 --> 00:52:27,700
challenge from a from an arm or a TI

00:52:26,049 --> 00:52:32,440
perspective than it would be from our

00:52:27,700 --> 00:52:33,789
perspective right you know we don't you

00:52:32,440 --> 00:52:36,180
know personally as runtime don't care

00:52:33,789 --> 00:52:39,910
about people who use iar right and

00:52:36,180 --> 00:52:42,520
there's a lot of people who do use irn

00:52:39,910 --> 00:52:44,170
STI you really have to care about the

00:52:42,520 --> 00:52:46,000
people who use iar right because they're

00:52:44,170 --> 00:52:47,829
probably fifty percent of your business

00:52:46,000 --> 00:52:49,210
or something anything it's a very very

00:52:47,829 --> 00:52:51,510
popular tool chain it's very very

00:52:49,210 --> 00:52:53,859
popular in industrial applications

00:52:51,510 --> 00:52:58,329
whereas for us it's a little bit less of

00:52:53,859 --> 00:53:00,700
a deal d and so I think you know what we

00:52:58,329 --> 00:53:02,410
would want from chip vendors and from

00:53:00,700 --> 00:53:04,059
from from providers is if we could all

00:53:02,410 --> 00:53:05,230
agree on a directory structure and it

00:53:04,059 --> 00:53:06,970
doesn't have to be our directory

00:53:05,230 --> 00:53:10,119
structure that these things get

00:53:06,970 --> 00:53:13,510
delivered in or there was a standard set

00:53:10,119 --> 00:53:16,359
of ways of delivering packages it make

00:53:13,510 --> 00:53:18,369
it a lot easier for systems like ours to

00:53:16,359 --> 00:53:20,440
then integrate those because today what

00:53:18,369 --> 00:53:24,450
we do is a lot of basically regex rules

00:53:20,440 --> 00:53:24,450
that we include into our build system

00:53:37,900 --> 00:53:46,460
I'll throw I'll throw the continued to

00:53:43,310 --> 00:53:50,750
be apart in many different ways to look

00:53:46,460 --> 00:53:55,260
at GCC everywhere toolchain should work

00:53:50,750 --> 00:53:57,980
like sea and separate

00:53:55,260 --> 00:53:57,980
which is hard

00:54:01,790 --> 00:54:06,720
no and certainly certainly that's our

00:54:04,710 --> 00:54:11,580
opinion as well I think that that is

00:54:06,720 --> 00:54:13,170
some way otherwise and at the end of the

00:54:11,580 --> 00:54:16,440
day it's you know there were the result

00:54:13,170 --> 00:54:19,140
of the system is really to make it

00:54:16,440 --> 00:54:20,850
compile like the user wants to get your

00:54:19,140 --> 00:54:22,290
operating system and they want to be

00:54:20,850 --> 00:54:24,720
able to compile it and load it on a

00:54:22,290 --> 00:54:27,360
board with the flash laid out with with

00:54:24,720 --> 00:54:29,280
all of the drivers set up and so build

00:54:27,360 --> 00:54:30,690
and package management if you if you

00:54:29,280 --> 00:54:33,540
make some trade-offs that are not going

00:54:30,690 --> 00:54:37,130
to be nice for everybody it's going to

00:54:33,540 --> 00:54:37,130
make it nice for the user who downloads

00:54:46,869 --> 00:55:02,160
yeah two minutes yep

00:54:58,270 --> 00:55:02,160
we'll start getting in about two minutes

00:55:08,490 --> 00:55:10,550

YouTube URL: https://www.youtube.com/watch?v=AbTRohVfZKM


