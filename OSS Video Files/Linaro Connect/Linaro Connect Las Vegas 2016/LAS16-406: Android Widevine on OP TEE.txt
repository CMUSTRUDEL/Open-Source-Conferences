Title: LAS16-406: Android Widevine on OP TEE
Publication date: 2016-09-30
Playlist: Linaro Connect Las Vegas 2016
Description: 
	LAS16-406: Android Widevine on OP-TEE
Speakers:
Date: September 29, 2016

★ Session Description ★
In this session we will learn about what has been done to get Android Widevine to run OP-TEE.

★ Resources ★
Etherpad: pad.linaro.org/p/las16-406
Presentations & Videos: http://connect.linaro.org/resource/las16/las16-406/

★ Event Details ★
Linaro Connect Las Vegas 2016 – #LAS16
September 26-30, 2016
http://www.linaro.org
http://connect.linaro.org
Captions: 
	00:00:07,910 --> 00:00:16,139
morning everybody hear me okay um

00:00:14,160 --> 00:00:19,890
welcome I'm gonna be giving a little

00:00:16,139 --> 00:00:26,699
presentation this morning about am I

00:00:19,890 --> 00:00:28,590
allowed to say Android Widevine okay so

00:00:26,699 --> 00:00:31,610
as the slide says this is about a droid

00:00:28,590 --> 00:00:34,500
Widevine on opti my name is David Brown

00:00:31,610 --> 00:00:36,870
Becker and I work on the software the

00:00:34,500 --> 00:00:39,059
security working group at Lennar oh and

00:00:36,870 --> 00:00:42,920
I've been working on this project for

00:00:39,059 --> 00:00:47,430
well since the last connect basically -

00:00:42,920 --> 00:00:50,100
well let's get into the presentation so

00:00:47,430 --> 00:00:54,239
what I want to cover today is some

00:00:50,100 --> 00:00:55,680
motivations for this gonna try to give a

00:00:54,239 --> 00:00:59,250
little bit of background as to why this

00:00:55,680 --> 00:01:01,850
is needed and why it's a lot harder of a

00:00:59,250 --> 00:01:04,140
problem than it may seem at first

00:01:01,850 --> 00:01:07,920
including some things on how not to do

00:01:04,140 --> 00:01:10,530
it with some pretty pictures what opti

00:01:07,920 --> 00:01:12,990
is vaguely and how that is involved in

00:01:10,530 --> 00:01:14,400
what we're doing here some general

00:01:12,990 --> 00:01:20,310
solutions and then an overview of

00:01:14,400 --> 00:01:21,750
Widevine itself so imagine you sit down

00:01:20,310 --> 00:01:26,310
at your Linux machine and you'd like to

00:01:21,750 --> 00:01:28,439
play a video so this diagram is kind of

00:01:26,310 --> 00:01:32,130
a typical view of what goes on when that

00:01:28,439 --> 00:01:33,900
happens if you think of this horizontal

00:01:32,130 --> 00:01:35,670
barrier between user space and kernel

00:01:33,900 --> 00:01:38,100
space with the kernel down at the bottom

00:01:35,670 --> 00:01:43,290
and some kind of media player up at the

00:01:38,100 --> 00:01:45,060
top we start out with protected content

00:01:43,290 --> 00:01:47,729
on some server on the internet that's

00:01:45,060 --> 00:01:50,970
encrypted with some key theoretically

00:01:47,729 --> 00:01:53,700
the user does not have access to there's

00:01:50,970 --> 00:01:56,460
a licensed manager that negotiates with

00:01:53,700 --> 00:01:59,490
this license server to convince it that

00:01:56,460 --> 00:02:02,219
this content playback is authorized the

00:01:59,490 --> 00:02:04,469
key should be downloaded we store this

00:02:02,219 --> 00:02:08,340
secret key and then as we stream the

00:02:04,469 --> 00:02:10,879
video we decrypt that data send it out

00:02:08,340 --> 00:02:13,560
to some kind of codec which decompresses

00:02:10,879 --> 00:02:15,870
usually h.264 and

00:02:13,560 --> 00:02:18,510
something like that sends it to a video

00:02:15,870 --> 00:02:23,099
driver and the video goes out the screen

00:02:18,510 --> 00:02:26,160
and you get to watch it so we call this

00:02:23,099 --> 00:02:28,200
affectionately software playback and

00:02:26,160 --> 00:02:30,000
there's kind of a problem here

00:02:28,200 --> 00:02:31,620
the I've color-coded the different

00:02:30,000 --> 00:02:35,430
things here the key information is that

00:02:31,620 --> 00:02:37,590
beautiful beige color the encrypted data

00:02:35,430 --> 00:02:41,220
is that dark blue but there's those red

00:02:37,590 --> 00:02:43,370
arrows and this is plain text version of

00:02:41,220 --> 00:02:47,370
the video content that you're watching

00:02:43,370 --> 00:02:50,370
and as you notice this lives in user

00:02:47,370 --> 00:02:54,269
space its decrypted by a users based

00:02:50,370 --> 00:02:57,060
program eventually it makes it out to

00:02:54,269 --> 00:03:00,269
the kernel out to the display but it's

00:02:57,060 --> 00:03:04,860
really easy for a malicious user an

00:03:00,269 --> 00:03:06,630
ordinary user to stash this content away

00:03:04,860 --> 00:03:08,940
to something else and the main

00:03:06,630 --> 00:03:12,090
consequence of this is as I said here

00:03:08,940 --> 00:03:14,430
the creators are sad the content

00:03:12,090 --> 00:03:16,319
creators studios whoever makes this

00:03:14,430 --> 00:03:20,670
content doesn't want people doing this

00:03:16,319 --> 00:03:24,090
and with this kind of playback it's easy

00:03:20,670 --> 00:03:25,980
to do and the kind of compromise that

00:03:24,090 --> 00:03:29,400
we've ended up with is you don't get HD

00:03:25,980 --> 00:03:31,980
you get a tiny little grainy fuzzy

00:03:29,400 --> 00:03:38,250
window of video when you have this kind

00:03:31,980 --> 00:03:40,170
of playback solution so let's talk a

00:03:38,250 --> 00:03:44,400
little bit more about how not to do this

00:03:40,170 --> 00:03:46,470
what's what's wrong here so the biggest

00:03:44,400 --> 00:03:49,500
problem is that the video is decrypted

00:03:46,470 --> 00:03:53,040
and the plain text passes through user

00:03:49,500 --> 00:03:54,660
space there's all kinds of things that

00:03:53,040 --> 00:03:57,420
can be exploited in this thing if you

00:03:54,660 --> 00:03:59,639
become route it's pretty trivial you

00:03:57,420 --> 00:04:03,569
could p trace another process you can

00:03:59,639 --> 00:04:06,269
get its memory you can find an exploit

00:04:03,569 --> 00:04:09,180
in the user space player there's just

00:04:06,269 --> 00:04:12,209
all kinds of things that make it really

00:04:09,180 --> 00:04:15,150
easy to get to the content and if you

00:04:12,209 --> 00:04:17,700
notice in this picture the secret key

00:04:15,150 --> 00:04:21,570
itself is stored in user space and this

00:04:17,700 --> 00:04:24,360
is actually also really bad with that

00:04:21,570 --> 00:04:26,970
key this gives me the ability to just I

00:04:24,360 --> 00:04:29,010
go ask the media server for the encrypt

00:04:26,970 --> 00:04:35,190
content and then do whatever I want to

00:04:29,010 --> 00:04:38,100
with it because I have the key so can we

00:04:35,190 --> 00:04:40,830
do better than that is the real question

00:04:38,100 --> 00:04:44,010
so there's diagram looks very similar to

00:04:40,830 --> 00:04:47,190
the last one the main difference here is

00:04:44,010 --> 00:04:51,180
that we've pushed the decryption of the

00:04:47,190 --> 00:04:54,420
video content to a hardware decoder so

00:04:51,180 --> 00:04:57,750
the sorry the decompression of the video

00:04:54,420 --> 00:05:01,410
into a hardware decoder so the video is

00:04:57,750 --> 00:05:03,870
still just secret key and user space

00:05:01,410 --> 00:05:06,660
it's decrypted sent to this piece of

00:05:03,870 --> 00:05:07,950
hardware which then decodes it plays it

00:05:06,660 --> 00:05:10,380
back now the reason this is better is

00:05:07,950 --> 00:05:16,170
there's a lot less of the plaintext

00:05:10,380 --> 00:05:19,380
video that's available to access it's

00:05:16,170 --> 00:05:21,870
not that much better though we mean less

00:05:19,380 --> 00:05:23,910
is still accessible but the plaintext is

00:05:21,870 --> 00:05:28,490
still in user space and the creators are

00:05:23,910 --> 00:05:30,930
still sad and we don't get our HD video

00:05:28,490 --> 00:05:34,919
okay let's push more of it down into the

00:05:30,930 --> 00:05:38,490
kernel then the put the key in the

00:05:34,919 --> 00:05:41,190
kernel have it stored there do the

00:05:38,490 --> 00:05:44,490
decryption in kernel space move it into

00:05:41,190 --> 00:05:47,729
the hardware codec play it out so we're

00:05:44,490 --> 00:05:52,650
a lot better now the video doesn't ever

00:05:47,729 --> 00:05:56,640
live in user space it's a lot harder to

00:05:52,650 --> 00:05:58,740
get to but the key still passes through

00:05:56,640 --> 00:06:01,650
user space if you see the the beige

00:05:58,740 --> 00:06:05,370
arrow is there in order to store this

00:06:01,650 --> 00:06:07,860
secret key in user space in the kernel

00:06:05,370 --> 00:06:10,530
it comes over the network it's decoded

00:06:07,860 --> 00:06:13,830
however and then it's sent to the kernel

00:06:10,530 --> 00:06:16,260
directly so but a deeper problem with

00:06:13,830 --> 00:06:19,169
that is that the kernel itself has a lot

00:06:16,260 --> 00:06:22,320
of vulnerabilities that you know keep

00:06:19,169 --> 00:06:25,470
being discovered and you find an exploit

00:06:22,320 --> 00:06:29,430
in the kernel and we can still get the

00:06:25,470 --> 00:06:35,970
video and as I said the creators are

00:06:29,430 --> 00:06:39,180
still sad so we do this better so what

00:06:35,970 --> 00:06:40,190
we do is we have this thing called key

00:06:39,180 --> 00:06:43,760
box

00:06:40,190 --> 00:06:46,850
which is a secret it's a secret that's

00:06:43,760 --> 00:06:49,820
only known between this system and the

00:06:46,850 --> 00:06:52,040
license server we use that to encrypt

00:06:49,820 --> 00:06:56,180
the secret key before it is sent over

00:06:52,040 --> 00:06:57,680
the network sent to users base so this

00:06:56,180 --> 00:07:02,090
gives us the advantage that we keep the

00:06:57,680 --> 00:07:04,160
key out of user space the will get in a

00:07:02,090 --> 00:07:07,070
minute as to how you deal with this key

00:07:04,160 --> 00:07:10,670
box we still have all the same problems

00:07:07,070 --> 00:07:13,580
with the kernel though that you know yes

00:07:10,670 --> 00:07:16,100
all the plaintext the keys everything

00:07:13,580 --> 00:07:19,610
secret is kept out of user space we're

00:07:16,100 --> 00:07:25,220
doing pretty good here kernel exploits

00:07:19,610 --> 00:07:27,380
are still possible and that means that

00:07:25,220 --> 00:07:35,510
the creator's are still sad we don't get

00:07:27,380 --> 00:07:38,150
HD so at this point on a typical Linux

00:07:35,510 --> 00:07:40,910
system this is kind of the best we can

00:07:38,150 --> 00:07:43,220
do we don't have anything better than

00:07:40,910 --> 00:07:46,880
the kernel to protect things so we need

00:07:43,220 --> 00:07:51,170
to look further into something in this

00:07:46,880 --> 00:07:52,760
particular case opti and specifically

00:07:51,170 --> 00:07:55,940
there's something called arm trust zone

00:07:52,760 --> 00:07:57,470
which is not just one thing it's a

00:07:55,940 --> 00:08:00,140
description of several things of this

00:07:57,470 --> 00:08:02,900
story of how you have a secure operating

00:08:00,140 --> 00:08:06,950
system that runs alongside the kernel

00:08:02,900 --> 00:08:09,950
and this is secure through boot into

00:08:06,950 --> 00:08:11,660
this operating system running that can

00:08:09,950 --> 00:08:13,700
then be called into from the kernel

00:08:11,660 --> 00:08:17,930
but the kernel doesn't have access to

00:08:13,700 --> 00:08:20,750
this secure operating system there's a

00:08:17,930 --> 00:08:23,270
global platform T specification so this

00:08:20,750 --> 00:08:27,970
is a standards body with a specification

00:08:23,270 --> 00:08:31,250
of how you have an API to a trusted

00:08:27,970 --> 00:08:34,310
execution environment and specifically

00:08:31,250 --> 00:08:39,320
opti is Linares implementation of this

00:08:34,310 --> 00:08:41,090
specification it allows you to write

00:08:39,320 --> 00:08:43,550
trusted applications they're kind of

00:08:41,090 --> 00:08:45,710
like applications in a regular Linux

00:08:43,550 --> 00:08:49,010
machine except they run in this trusted

00:08:45,710 --> 00:08:52,280
special environment it's inaccessible to

00:08:49,010 --> 00:08:54,730
kernel user space anything running

00:08:52,280 --> 00:08:57,800
outside of the trusted in

00:08:54,730 --> 00:09:00,380
so vaguely it looks something like this

00:08:57,800 --> 00:09:02,840
this is kind of simplified to give an

00:09:00,380 --> 00:09:04,250
idea of what's going on so whereas

00:09:02,840 --> 00:09:06,830
before we had the kernel at the bottom

00:09:04,250 --> 00:09:09,320
with a dotted line and then user space

00:09:06,830 --> 00:09:11,450
lives above the kernel for and there's a

00:09:09,320 --> 00:09:13,370
protection boundary between that we have

00:09:11,450 --> 00:09:14,330
another protection boundary between the

00:09:13,370 --> 00:09:16,730
reader rich

00:09:14,330 --> 00:09:19,700
execution environment and the T the

00:09:16,730 --> 00:09:21,440
trusted execution environment and things

00:09:19,700 --> 00:09:24,830
that happen inside of this trusted

00:09:21,440 --> 00:09:26,830
environment are protected the only way

00:09:24,830 --> 00:09:29,030
to access them is through a specific API

00:09:26,830 --> 00:09:32,210
it comes through the kernel so there's

00:09:29,030 --> 00:09:34,280
clients running in the rich execution

00:09:32,210 --> 00:09:36,230
environment that make requests calls

00:09:34,280 --> 00:09:40,070
into this trusted environment where code

00:09:36,230 --> 00:09:42,740
can then run and then there are various

00:09:40,070 --> 00:09:44,720
TAS that may do different purposes so

00:09:42,740 --> 00:09:49,520
what we're talking about now is a

00:09:44,720 --> 00:09:51,740
specific media trusted application which

00:09:49,520 --> 00:09:55,370
lives in this trusted operating system

00:09:51,740 --> 00:09:58,040
below the kernel and we take all those

00:09:55,370 --> 00:10:00,200
scary things and we start pushing them

00:09:58,040 --> 00:10:02,150
down into the the trusted execution

00:10:00,200 --> 00:10:04,520
environment in this particular case we

00:10:02,150 --> 00:10:08,120
see the key box the secret key and the

00:10:04,520 --> 00:10:11,030
decryption or pushed down however the

00:10:08,120 --> 00:10:13,940
video playback still kind of lives above

00:10:11,030 --> 00:10:15,620
that we have these we can ask the

00:10:13,940 --> 00:10:17,630
trusted execution environment in order

00:10:15,620 --> 00:10:20,630
to decrypt this video but now this

00:10:17,630 --> 00:10:23,240
buffer with the decrypted video is still

00:10:20,630 --> 00:10:28,000
accessible to users base so we're

00:10:23,240 --> 00:10:31,940
getting better but we're still not there

00:10:28,000 --> 00:10:36,080
so the advantage here is the key is

00:10:31,940 --> 00:10:39,110
actually protected but the plaintext

00:10:36,080 --> 00:10:42,110
video still is visible at one point to

00:10:39,110 --> 00:10:49,010
users face the creators are still sad

00:10:42,110 --> 00:10:52,760
and we don't get HD so we still need one

00:10:49,010 --> 00:10:54,680
more thing and this is a kind of still a

00:10:52,760 --> 00:10:57,530
discussion and something that we're

00:10:54,680 --> 00:11:00,020
working through actually learned about

00:10:57,530 --> 00:11:02,480
something last night of another possible

00:11:00,020 --> 00:11:05,000
way of doing this we need some kind of

00:11:02,480 --> 00:11:07,640
what I'm calling a weird buffer that's

00:11:05,000 --> 00:11:11,180
allocated it's accessible to the

00:11:07,640 --> 00:11:13,070
pure side but programs running in the

00:11:11,180 --> 00:11:16,160
kernel in the user space cannot read

00:11:13,070 --> 00:11:17,930
this data the only thing that can is the

00:11:16,160 --> 00:11:19,640
hardware video decoder and that's why

00:11:17,930 --> 00:11:21,110
the hardware decoder is so important

00:11:19,640 --> 00:11:25,160
because we can't have software that can

00:11:21,110 --> 00:11:26,240
read this only this hardware decoder how

00:11:25,160 --> 00:11:28,220
do we do this

00:11:26,240 --> 00:11:31,130
there are some patches going around

00:11:28,220 --> 00:11:32,510
called SM AF force math which is a

00:11:31,130 --> 00:11:35,960
secure memory allocator

00:11:32,510 --> 00:11:40,220
I just learned there's a some patches

00:11:35,960 --> 00:11:43,490
that we're going around in where were

00:11:40,220 --> 00:11:46,490
they add in another subsystem related to

00:11:43,490 --> 00:11:49,310
video playback in graphics that also

00:11:46,490 --> 00:11:53,120
have a secure memory allocator as part

00:11:49,310 --> 00:11:55,250
of their API ultimately the requirement

00:11:53,120 --> 00:11:58,970
here is that we need some kind of buffer

00:11:55,250 --> 00:12:00,800
that's allocated that a trusted

00:11:58,970 --> 00:12:03,050
application is able to write to but not

00:12:00,800 --> 00:12:06,830
the kernel and the hardware is able to

00:12:03,050 --> 00:12:08,900
play that back and this is tricky to get

00:12:06,830 --> 00:12:11,870
right I mean a lot of things with

00:12:08,900 --> 00:12:13,970
security are tricky to get right the the

00:12:11,870 --> 00:12:20,510
slightest little weakness and suddenly

00:12:13,970 --> 00:12:23,000
you have all of your data but once we

00:12:20,510 --> 00:12:26,930
get here this is actually enough to make

00:12:23,000 --> 00:12:30,080
the content creators happy so what I

00:12:26,930 --> 00:12:33,680
want to talk about right now is this

00:12:30,080 --> 00:12:35,600
general solution so not as much

00:12:33,680 --> 00:12:37,490
specifically Widevine but how does this

00:12:35,600 --> 00:12:41,300
problem get solved I'd mentioned the key

00:12:37,490 --> 00:12:43,070
box and the secret key so I just wanted

00:12:41,300 --> 00:12:46,370
to go through a little overview of how

00:12:43,070 --> 00:12:50,420
this happens some point generally during

00:12:46,370 --> 00:12:52,070
manufacture the original equipment

00:12:50,420 --> 00:12:54,980
manufacturer the people making the

00:12:52,070 --> 00:12:57,050
device will generate a key or they get

00:12:54,980 --> 00:12:59,960
the key from some kind of central

00:12:57,050 --> 00:13:02,690
authority in this instance I've shown it

00:12:59,960 --> 00:13:04,460
as a key pair it turns out you don't

00:13:02,690 --> 00:13:07,250
actually need a key pair it's fine to

00:13:04,460 --> 00:13:10,130
for that to just be a shared secret but

00:13:07,250 --> 00:13:13,900
this key has to be written into the

00:13:10,130 --> 00:13:16,640
device in this key box in the factory

00:13:13,900 --> 00:13:18,260
and you have to do this in such a way

00:13:16,640 --> 00:13:20,660
that it can't be read outside of the

00:13:18,260 --> 00:13:25,579
secure environment it's an import

00:13:20,660 --> 00:13:30,050
thing once it's written later the user

00:13:25,579 --> 00:13:31,550
goes to play back video the media server

00:13:30,050 --> 00:13:33,920
and licensed server will generate a

00:13:31,550 --> 00:13:37,579
Content qisas unrelated key usually just

00:13:33,920 --> 00:13:41,240
random numbers that is how the video

00:13:37,579 --> 00:13:44,930
will be encrypted with this key we then

00:13:41,240 --> 00:13:48,560
he was the key box key to rap this key

00:13:44,930 --> 00:13:52,339
so we encrypt the content key with the

00:13:48,560 --> 00:13:54,889
key box key so we now have a key that is

00:13:52,339 --> 00:13:58,519
only accessible to this code running in

00:13:54,889 --> 00:14:02,089
the secure side this gets sent over the

00:13:58,519 --> 00:14:04,310
network through user space through the

00:14:02,089 --> 00:14:06,790
kernel down into the trusted execution

00:14:04,310 --> 00:14:09,519
environment and by the way this is

00:14:06,790 --> 00:14:12,319
obviously somewhat oversimplified

00:14:09,519 --> 00:14:13,819
there's signatures there's all kinds of

00:14:12,319 --> 00:14:19,100
other things going on to make sure that

00:14:13,819 --> 00:14:22,370
the key is actually correct the trusted

00:14:19,100 --> 00:14:23,930
side then unwraps this key by reversing

00:14:22,370 --> 00:14:26,750
the encryption with the secret that it

00:14:23,930 --> 00:14:30,680
knows and is able to store this secret

00:14:26,750 --> 00:14:34,759
key inside the trusted environment so

00:14:30,680 --> 00:14:36,079
that when we come to play video oh when

00:14:34,759 --> 00:14:39,589
it's time to play video with all the

00:14:36,079 --> 00:14:42,529
other boxes up there we have the content

00:14:39,589 --> 00:14:44,000
key we can decrypt it we use our

00:14:42,529 --> 00:14:46,939
Hardware codec reading from these

00:14:44,000 --> 00:14:50,120
buffers we don't have access to this

00:14:46,939 --> 00:14:53,660
goes out the video driver do something

00:14:50,120 --> 00:14:57,100
like HDCP to protect the content on the

00:14:53,660 --> 00:15:00,889
cable ultimately we're now playing video

00:14:57,100 --> 00:15:07,959
everyone is happy and we can watch our

00:15:00,889 --> 00:15:10,389
movie so wide vine specifics

00:15:07,959 --> 00:15:17,230
unfortunately I can't tell you that much

00:15:10,389 --> 00:15:17,230
there there's NDA's and things like that

00:15:17,589 --> 00:15:25,610
the basic idea is that there's a plugin

00:15:21,110 --> 00:15:27,500
that you write it's a shared library and

00:15:25,610 --> 00:15:29,540
in this case with the arrangement and

00:15:27,500 --> 00:15:32,209
opti it is the user space part of the

00:15:29,540 --> 00:15:33,529
client that speaks through the kernel

00:15:32,209 --> 00:15:35,449
API into the

00:15:33,529 --> 00:15:37,790
the execution environment that

00:15:35,449 --> 00:15:40,639
implements the kind of calls you need in

00:15:37,790 --> 00:15:42,529
order to do these things manage the keys

00:15:40,639 --> 00:15:47,689
store them decrypt the video into

00:15:42,529 --> 00:15:50,180
buffers this kind of thing so what's

00:15:47,689 --> 00:15:55,910
working we're doing this work on a high

00:15:50,180 --> 00:15:57,860
keyboard it's a 96 board the I guess

00:15:55,910 --> 00:16:02,240
first thing is we have op T available

00:15:57,860 --> 00:16:03,980
for this there's I believe a version of

00:16:02,240 --> 00:16:07,519
this running in one of the lonardo

00:16:03,980 --> 00:16:08,809
releases we do also on the security

00:16:07,519 --> 00:16:12,589
working group we have our own local

00:16:08,809 --> 00:16:17,089
manifest to pull all of this into an

00:16:12,589 --> 00:16:19,999
AOSP build we also have developed this

00:16:17,089 --> 00:16:23,360
live OEM crypto and the necessary ta to

00:16:19,999 --> 00:16:28,519
go with that that implements this

00:16:23,360 --> 00:16:30,439
Widevine content decryption module so we

00:16:28,519 --> 00:16:33,230
have the flow we have the the

00:16:30,439 --> 00:16:36,680
implementation there but it's not

00:16:33,230 --> 00:16:39,649
actually secure so we find this a lot

00:16:36,680 --> 00:16:41,959
with with high key there's some things

00:16:39,649 --> 00:16:46,879
missing the secure boot chain is not

00:16:41,959 --> 00:16:50,120
present so yes there's a trusted

00:16:46,879 --> 00:16:53,029
application that decrypts your video but

00:16:50,120 --> 00:16:56,689
it could be modified so that doesn't

00:16:53,029 --> 00:16:58,730
really make it secure we don't have the

00:16:56,689 --> 00:17:01,449
secure buffer management implemented yet

00:16:58,730 --> 00:17:04,699
so the buffers actually just live in

00:17:01,449 --> 00:17:06,709
accessible data which is good because

00:17:04,699 --> 00:17:09,649
there's no hardware video playback yet

00:17:06,709 --> 00:17:13,100
on this target so they do need to be

00:17:09,649 --> 00:17:15,709
read by users face so in a sense this is

00:17:13,100 --> 00:17:17,209
not a product this is an example of how

00:17:15,709 --> 00:17:20,179
this works

00:17:17,209 --> 00:17:25,990
somebody making a real product would

00:17:20,179 --> 00:17:29,090
solve these problems I think that's it

00:17:25,990 --> 00:17:32,030
so that's kind of the overview that I

00:17:29,090 --> 00:17:36,320
had I guess at this point does anyone

00:17:32,030 --> 00:17:41,659
have any questions for me and we have a

00:17:36,320 --> 00:17:45,409
microphone denizens of the Internet can

00:17:41,659 --> 00:17:47,630
hear why do you need secure video memory

00:17:45,409 --> 00:17:50,780
on location because if you have a

00:17:47,630 --> 00:17:53,899
highway decoder the buffer can be

00:17:50,780 --> 00:17:55,909
located by the driver right right and

00:17:53,899 --> 00:17:58,580
application do not need to touch it

00:17:55,909 --> 00:18:01,460
right so the the thing is currently the

00:17:58,580 --> 00:18:03,649
the decryption of the video is being

00:18:01,460 --> 00:18:06,890
done by software running in the trusted

00:18:03,649 --> 00:18:10,760
execution environment so we need a place

00:18:06,890 --> 00:18:14,000
to store the decrypted video accessible

00:18:10,760 --> 00:18:16,059
by software it's secured software before

00:18:14,000 --> 00:18:18,740
the hard work and then play it back that

00:18:16,059 --> 00:18:21,530
so what you have works if your hard work

00:18:18,740 --> 00:18:23,059
and do the decryption as well if you

00:18:21,530 --> 00:18:26,330
have hardware such that you can load a

00:18:23,059 --> 00:18:28,250
key into it then that driver can manage

00:18:26,330 --> 00:18:31,250
all the buffers but in this particular

00:18:28,250 --> 00:18:34,039
configuration we need this buffer to

00:18:31,250 --> 00:18:37,600
store the the decrypted video to

00:18:34,039 --> 00:18:44,480
essentially hand the data between the

00:18:37,600 --> 00:18:46,850
trusted application and the video so

00:18:44,480 --> 00:18:50,570
actually even though you roni insecure

00:18:46,850 --> 00:18:52,909
OS insecure CPU MO but you still seeing

00:18:50,570 --> 00:18:55,190
this is not secure so therefore you need

00:18:52,909 --> 00:18:57,260
to allocate secure video memory unless

00:18:55,190 --> 00:18:59,870
your decoder can take the key from

00:18:57,260 --> 00:19:03,350
secure storage and decree and decode at

00:18:59,870 --> 00:19:05,679
the same time right yeah which we don't

00:19:03,350 --> 00:19:05,679
have here

00:19:11,520 --> 00:19:14,640
anything else

00:19:17,170 --> 00:19:22,360
I think the skill before allocation

00:19:20,080 --> 00:19:26,500
patches you're saying these what patches

00:19:22,360 --> 00:19:29,350
to what form do they say is this from

00:19:26,500 --> 00:19:33,730
some other place or just where that term

00:19:29,350 --> 00:19:36,700
was invented SMAS yeah there's one set

00:19:33,730 --> 00:19:38,980
of patches on SMA that I listed there I

00:19:36,700 --> 00:19:41,590
don't believe those contain any of the

00:19:38,980 --> 00:19:46,570
patches to opti itself for that site of

00:19:41,590 --> 00:19:48,460
the support it's basically not finished

00:19:46,570 --> 00:19:51,970
it's kind of an unsolved problem right

00:19:48,460 --> 00:19:54,280
now as to what will be acceptable to the

00:19:51,970 --> 00:20:10,150
upstream colonel that will also let us

00:19:54,280 --> 00:20:13,060
do these secure buffer management well

00:20:10,150 --> 00:20:14,740
currently we're not okay so I mean

00:20:13,060 --> 00:20:25,180
that's a that's still remaining work to

00:20:14,740 --> 00:20:26,320
be done it's one of the ideas that's

00:20:25,180 --> 00:20:30,130
being tossed around

00:20:26,320 --> 00:20:36,580
I own isn't exactly is only sort of

00:20:30,130 --> 00:20:39,280
upstream anyway just the common I hate

00:20:36,580 --> 00:20:41,290
to put you on a spot but we've been

00:20:39,280 --> 00:20:44,200
telling our customers that everything

00:20:41,290 --> 00:20:46,270
we're on insecure always is secure it's

00:20:44,200 --> 00:20:50,670
very unsecure sheep you know there

00:20:46,270 --> 00:20:54,190
nobody can compromise but seems like

00:20:50,670 --> 00:20:58,080
that's not a case right we we want to

00:20:54,190 --> 00:21:01,270
use secure memory for decrypt the key

00:20:58,080 --> 00:21:05,950
that seems like the conclusion we joined

00:21:01,270 --> 00:21:11,200
here yeah what's our good answer for

00:21:05,950 --> 00:21:15,100
that we're not providing a product as

00:21:11,200 --> 00:21:18,640
the thing here this is it's a reference

00:21:15,100 --> 00:21:21,520
implementation opti is used in in

00:21:18,640 --> 00:21:23,860
products now these problems are solved

00:21:21,520 --> 00:21:25,870
just not on the hardware that we're

00:21:23,860 --> 00:21:29,740
running right now that we have available

00:21:25,870 --> 00:21:30,790
to do this work on I think there's still

00:21:29,740 --> 00:21:32,200
a lot of to be

00:21:30,790 --> 00:21:35,110
learned by doing it on this kind of

00:21:32,200 --> 00:21:36,700
hardware even if the the end result of

00:21:35,110 --> 00:21:38,770
say the firewall that protects this

00:21:36,700 --> 00:21:41,350
secure memory doesn't actually work on

00:21:38,770 --> 00:21:49,660
the hardware we can still verify the the

00:21:41,350 --> 00:21:51,310
flow of the data and then yeah the point

00:21:49,660 --> 00:21:53,620
is that for the end user it shouldn't be

00:21:51,310 --> 00:21:54,970
too much work to take this up what we

00:21:53,620 --> 00:21:56,890
are done here and put it on their own

00:21:54,970 --> 00:21:59,020
devices and you have the missing pieces

00:21:56,890 --> 00:22:01,290
that you you always need to deal with

00:21:59,020 --> 00:22:12,240
that we can't do in a open reference

00:22:01,290 --> 00:22:12,240
implementation any other questions

00:22:15,640 --> 00:22:21,160
so both official and so the question was

00:22:19,300 --> 00:22:25,060
how does Apple solved this problem in

00:22:21,160 --> 00:22:30,520
iOS I would say both the official and

00:22:25,060 --> 00:22:32,230
correct answer is I have no idea I would

00:22:30,520 --> 00:22:33,910
imagine the solution is something

00:22:32,230 --> 00:22:37,090
similar to the general solution that I

00:22:33,910 --> 00:22:38,830
proposed just because that's those are

00:22:37,090 --> 00:22:42,820
the pieces you need in order to protect

00:22:38,830 --> 00:22:48,400
your content I don't know what actually

00:22:42,820 --> 00:22:54,180
happens inside iOS thank you Dave you're

00:22:48,400 --> 00:22:54,180
welcome any other questions

00:23:00,020 --> 00:23:13,640
when you did remote display something

00:23:05,790 --> 00:23:17,480
like feature yeah it's sweet we encode

00:23:13,640 --> 00:23:20,360
displaying yeah I don't actually know

00:23:17,480 --> 00:23:24,090
you know we've only done this with a

00:23:20,360 --> 00:23:27,600
directly connected display I would

00:23:24,090 --> 00:23:29,220
imagine that if there's really a that

00:23:27,600 --> 00:23:31,980
can see two ways of doing that one is to

00:23:29,220 --> 00:23:36,540
not read not decode the data at all and

00:23:31,980 --> 00:23:40,130
then send the encrypted the encrypted

00:23:36,540 --> 00:23:40,130
stream directly to the remote display

00:23:41,030 --> 00:23:46,470
yeah I mean rumors that I've heard of

00:23:44,060 --> 00:23:48,090
things that do that kind of thing

00:23:46,470 --> 00:23:50,130
typically do it that way I mean you

00:23:48,090 --> 00:23:52,110
could also decode Andrian code and then

00:23:50,130 --> 00:23:59,700
you have more key management to deal

00:23:52,110 --> 00:24:02,940
with the display typically what's done

00:23:59,700 --> 00:24:06,600
in an environment where there say a hub

00:24:02,940 --> 00:24:09,570
or home gateway that then encrypts the

00:24:06,600 --> 00:24:11,250
content to send to a attending client

00:24:09,570 --> 00:24:14,280
remote set-top they'll use something

00:24:11,250 --> 00:24:16,710
like D tcp/ip for a like a link layer

00:24:14,280 --> 00:24:18,420
encryption of that content so it'll be

00:24:16,710 --> 00:24:22,880
decrypted but they'll ring we encrypt

00:24:18,420 --> 00:24:26,420
with D TCP and then decrypt that at the

00:24:22,880 --> 00:24:26,420
remote set table

00:24:30,420 --> 00:24:40,020
any other questions all right well thank

00:24:38,040 --> 00:24:44,000
you for attending I hope this was

00:24:40,020 --> 00:24:44,000
informative thank you very much

00:24:52,960 --> 00:24:55,020

YouTube URL: https://www.youtube.com/watch?v=LEJqTXVs9N8


