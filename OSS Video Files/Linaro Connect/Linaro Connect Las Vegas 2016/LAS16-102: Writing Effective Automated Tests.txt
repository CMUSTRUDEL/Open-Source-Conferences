Title: LAS16-102: Writing Effective Automated Tests
Publication date: 2016-09-30
Playlist: Linaro Connect Las Vegas 2016
Description: 
	LAS16-102: Writing Effective Automated Tests
Speakers: Milosz Wasilewski, AntonioTerceiro
Date: September 26, 2016

★ Session Description ★
In this session we will discuss techniques and tools for writing automated tests that are robust, extensible and maintainable. The speakers will provide an initial presentation of their own point of view on the subject, but audience participation is expected, and encouraged. Some topics that will be covered: UIAutomator andAndroidViewClient for UI testing on Android; shunit2 and clitest for organizing test suites; best practices for shell scripts.

★ Resources ★
Etherpad: pad.linaro.org/p/las16-102
Presentations & Videos: http://connect.linaro.org/resource/las16/las16-102/

★ Event Details ★
Linaro Connect Las Vegas 2016 – #LAS16
September 26-30, 2016
http://www.linaro.org
http://connect.linaro.org
Captions: 
	00:00:00,190 --> 00:00:05,840
[Music]

00:00:07,429 --> 00:00:15,330
it's five us too I guess we can start

00:00:10,820 --> 00:00:18,180
someone can join later they wish hello

00:00:15,330 --> 00:00:23,100
and welcome or presentation sort of

00:00:18,180 --> 00:00:25,830
discussion myself and my team I would

00:00:23,100 --> 00:00:30,890
like to show you our what what we

00:00:25,830 --> 00:00:35,700
actually did in for our tools and what

00:00:30,890 --> 00:00:38,340
conclusions we we came to as well as ask

00:00:35,700 --> 00:00:42,809
your opinion about the good practices

00:00:38,340 --> 00:00:46,579
for writing tests that you might have so

00:00:42,809 --> 00:00:50,940
we'll go through general principles of

00:00:46,579 --> 00:00:53,989
writing tests automating tests then have

00:00:50,940 --> 00:00:59,719
some examples of implementing those in

00:00:53,989 --> 00:01:03,930
test four AOSP you I level testing the

00:00:59,719 --> 00:01:06,570
system operating system features and

00:01:03,930 --> 00:01:08,760
then we'll go through the to the example

00:01:06,570 --> 00:01:10,350
that led us here which is the

00:01:08,760 --> 00:01:13,110
refactoring of the De Niro test suite

00:01:10,350 --> 00:01:17,189
and how could there will be some time

00:01:13,110 --> 00:01:23,380
for discussions so for the first one

00:01:17,189 --> 00:01:26,000
I'll hand to Antonio right hello so

00:01:23,380 --> 00:01:28,909
these general principles are something

00:01:26,000 --> 00:01:33,320
that we think everyone has always

00:01:28,909 --> 00:01:35,479
driving my what when writing test out of

00:01:33,320 --> 00:01:39,200
the first the first place was a test

00:01:35,479 --> 00:01:46,750
called school so is sometimes you see

00:01:39,200 --> 00:01:49,190
the test code being treated with a lower

00:01:46,750 --> 00:01:51,320
being held to lower standard than the

00:01:49,190 --> 00:01:55,130
actual then the production code and

00:01:51,320 --> 00:01:57,170
that's usually will bring you the same

00:01:55,130 --> 00:01:59,660
problems that you have when you don't

00:01:57,170 --> 00:02:04,039
have high standards enough sounded high

00:01:59,660 --> 00:02:06,920
enough for your regular code so a test

00:02:04,039 --> 00:02:11,420
code it must be handled in the same way

00:02:06,920 --> 00:02:14,959
you handle your haggler code so it

00:02:11,420 --> 00:02:16,670
should be good right so you don't want

00:02:14,959 --> 00:02:19,850
Krabby production code you also don't

00:02:16,670 --> 00:02:21,620
want crappy Tesco and then you can you

00:02:19,850 --> 00:02:23,480
can and should do everything that you do

00:02:21,620 --> 00:02:27,200
with regular code so you can version

00:02:23,480 --> 00:02:31,130
Tesco you can make releases oltp is a

00:02:27,200 --> 00:02:33,890
good example of test codes that has a

00:02:31,130 --> 00:02:36,019
proper release processing and produces

00:02:33,890 --> 00:02:38,840
artifacts that can be consumed by users

00:02:36,019 --> 00:02:42,290
and also ee i did with this omission

00:02:38,840 --> 00:02:45,829
here but it can also be review so you

00:02:42,290 --> 00:02:47,570
can apply the same code review process

00:02:45,829 --> 00:02:50,090
you apply to your regular code to your

00:02:47,570 --> 00:02:52,970
test code and we do that all the time on

00:02:50,090 --> 00:02:56,660
our team and several other products do

00:02:52,970 --> 00:03:01,220
that as well another important principle

00:02:56,660 --> 00:03:03,320
we have should have in mind is having

00:03:01,220 --> 00:03:06,190
our test code organized in a way that

00:03:03,320 --> 00:03:10,700
you can easily extend to add new tests

00:03:06,190 --> 00:03:14,959
so this is why we are he fell into the

00:03:10,700 --> 00:03:17,000
open closet prints which is a pre so

00:03:14,959 --> 00:03:19,190
that was creating the contest of

00:03:17,000 --> 00:03:21,350
object-oriented programming but it can

00:03:19,190 --> 00:03:24,579
be applied to any kind of software so

00:03:21,350 --> 00:03:26,900
the idea that if you want to add new

00:03:24,579 --> 00:03:28,850
features should be able to do that

00:03:26,900 --> 00:03:32,210
without changing the

00:03:28,850 --> 00:03:35,170
features because we know that every time

00:03:32,210 --> 00:03:39,200
you change code you going also breaking

00:03:35,170 --> 00:03:41,210
that code somehow so if you can add new

00:03:39,200 --> 00:03:44,840
features without modifying the glitzy

00:03:41,210 --> 00:03:46,820
ones it's always good for you and you

00:03:44,840 --> 00:03:50,420
should also be able to do that on your

00:03:46,820 --> 00:03:52,640
test code so on most programming

00:03:50,420 --> 00:03:56,060
languages there are testing frameworks

00:03:52,640 --> 00:03:57,740
called anything unit so that's a good

00:03:56,060 --> 00:04:00,260
example because you add new test by

00:03:57,740 --> 00:04:03,320
writing new test methods or test

00:04:00,260 --> 00:04:07,370
function and that's probably what you

00:04:03,320 --> 00:04:14,240
should expect from any reasonably good

00:04:07,370 --> 00:04:16,489
testing framework and also the last

00:04:14,240 --> 00:04:20,360
point to not lock yourself up for your

00:04:16,489 --> 00:04:22,640
own test is usually today you have your

00:04:20,360 --> 00:04:25,580
test being run on the ipad room so

00:04:22,640 --> 00:04:28,310
Indian are we used lava you use

00:04:25,580 --> 00:04:30,410
drinking's so in free software products

00:04:28,310 --> 00:04:33,440
in January they can use Travis CI or

00:04:30,410 --> 00:04:35,780
anything else and you should avoid the

00:04:33,440 --> 00:04:38,300
trap of locking yourself with those

00:04:35,780 --> 00:04:41,720
systems so you should go out they should

00:04:38,300 --> 00:04:44,060
always be able to grab your test code

00:04:41,720 --> 00:04:45,650
and also the device while you want to

00:04:44,060 --> 00:04:47,000
test and run it there without the

00:04:45,650 --> 00:04:50,750
opinion or anything that comes from

00:04:47,000 --> 00:04:53,660
those automation systems so usually want

00:04:50,750 --> 00:04:57,950
to leave that integration with

00:04:53,660 --> 00:05:00,680
automation to a small part of the your

00:04:57,950 --> 00:05:03,380
test that runs as a second step after

00:05:00,680 --> 00:05:10,340
the actual tests so for instance if

00:05:03,380 --> 00:05:12,290
you're in our way we I think this is the

00:05:10,340 --> 00:05:15,440
point where we talk about yeah and then

00:05:12,290 --> 00:05:18,770
i guess i have an example as a very last

00:05:15,440 --> 00:05:20,510
or i can show well i'll show it for the

00:05:18,770 --> 00:05:22,070
last slide when we have the refractory

00:05:20,510 --> 00:05:25,250
so isn't the answer right yeah at the

00:05:22,070 --> 00:05:26,690
end there is an example exactly like the

00:05:25,250 --> 00:05:29,660
mistake that that was made in the

00:05:26,690 --> 00:05:32,390
beginning and then how to help to figure

00:05:29,660 --> 00:05:34,850
so we will come back to that story later

00:05:32,390 --> 00:05:37,910
so the idea is that you don't want your

00:05:34,850 --> 00:05:39,560
test to depend on any given automation

00:05:37,910 --> 00:05:42,230
infrastructure so you want them to be a

00:05:39,560 --> 00:05:44,930
standalone and then add the integration

00:05:42,230 --> 00:05:48,380
of your automation platform as a second

00:05:44,930 --> 00:05:50,900
step after the actual test or as a

00:05:48,380 --> 00:05:57,530
wrapper around the actual test depends

00:05:50,900 --> 00:06:02,180
on how exactly your tests work ok so as

00:05:57,530 --> 00:06:06,730
a second as the second topic is like

00:06:02,180 --> 00:06:13,160
second part I'd like to talk a bit about

00:06:06,730 --> 00:06:15,980
how to implement those in practice so UI

00:06:13,160 --> 00:06:17,720
testing UI testing and especially

00:06:15,980 --> 00:06:23,360
automated UI testing is not an easy

00:06:17,720 --> 00:06:26,510
thing to do with the UI and applications

00:06:23,360 --> 00:06:32,510
and front end for the user coming from

00:06:26,510 --> 00:06:36,680
all different origins but it's worth to

00:06:32,510 --> 00:06:39,400
mention that the good practices in

00:06:36,680 --> 00:06:43,280
writing those you I front that should be

00:06:39,400 --> 00:06:47,980
should have testing in mind so I think

00:06:43,280 --> 00:06:50,810
it if i remember correctly the selenium

00:06:47,980 --> 00:06:52,670
the selenium tutorial starts from more

00:06:50,810 --> 00:06:54,980
or less the same sentences so basically

00:06:52,670 --> 00:06:58,190
if there are some controls on the on the

00:06:54,980 --> 00:07:00,350
UI like buttons input boxes checkboxes

00:06:58,190 --> 00:07:05,240
and so on they should be named and those

00:07:00,350 --> 00:07:07,280
names should be unique in order for the

00:07:05,240 --> 00:07:13,400
album for the testing tools to access

00:07:07,280 --> 00:07:18,050
them I guess the good good good way of

00:07:13,400 --> 00:07:20,780
naming it is should also be possible for

00:07:18,050 --> 00:07:23,770
well that the good name should also be

00:07:20,780 --> 00:07:26,500
available for internationalized

00:07:23,770 --> 00:07:29,360
internationalization so

00:07:26,500 --> 00:07:31,580
translating the name for on the button

00:07:29,360 --> 00:07:34,240
that the shrink on the button two

00:07:31,580 --> 00:07:36,919
different languages may use the same ID

00:07:34,240 --> 00:07:41,780
that your automation script should you

00:07:36,919 --> 00:07:44,150
so it's it's worth to to check when

00:07:41,780 --> 00:07:46,699
actually writing your code that those

00:07:44,150 --> 00:07:49,879
names are there in place then when it

00:07:46,699 --> 00:07:55,129
comes to AOSP those name get those names

00:07:49,879 --> 00:07:57,819
get exposed to the tool that's that's

00:07:55,129 --> 00:08:02,629
available for all iOS platforms and it's

00:07:57,819 --> 00:08:04,460
called UI Automator so UI Automator is

00:08:02,629 --> 00:08:06,289
able to grab the screen the visible part

00:08:04,460 --> 00:08:09,889
of the screen and tell you like which

00:08:06,289 --> 00:08:13,400
IDs of the controls are there and if you

00:08:09,889 --> 00:08:15,860
do this exercise for a couple of three

00:08:13,400 --> 00:08:18,620
AP case then you realize that it's not

00:08:15,860 --> 00:08:20,419
the case so the ids are not there so

00:08:18,620 --> 00:08:23,150
it's a good idea to actually get them

00:08:20,419 --> 00:08:24,949
there is when you write your own apktor

00:08:23,150 --> 00:08:30,740
your own front ends in order to

00:08:24,949 --> 00:08:32,740
automatically test them later on as as

00:08:30,740 --> 00:08:37,519
Antonia mentioned the test should be

00:08:32,740 --> 00:08:40,399
easily extendable so here we come to the

00:08:37,519 --> 00:08:43,310
open close pursuit also basically the

00:08:40,399 --> 00:08:46,450
test that tests for example the login

00:08:43,310 --> 00:08:49,440
window should not depend on

00:08:46,450 --> 00:08:52,870
so that those unique IDs should come

00:08:49,440 --> 00:08:55,450
should appear in your testing test suite

00:08:52,870 --> 00:08:58,150
only once so if that test if for some

00:08:55,450 --> 00:09:03,850
reason the ID changes then you need to

00:08:58,150 --> 00:09:07,570
change it in only one place there are

00:09:03,850 --> 00:09:12,450
some some useful tools that that can be

00:09:07,570 --> 00:09:19,570
that can be used for writing tests for

00:09:12,450 --> 00:09:22,030
for AOSP so the where my experience

00:09:19,570 --> 00:09:24,490
comes from is is the UI Automator which

00:09:22,030 --> 00:09:27,010
is a tool that that delivered as a part

00:09:24,490 --> 00:09:29,920
of AOSP platform it's written in Java

00:09:27,010 --> 00:09:32,860
and it allows for creating tests for

00:09:29,920 --> 00:09:34,780
your front-end straightaway that test

00:09:32,860 --> 00:09:37,180
need to be written in Java and compiled

00:09:34,780 --> 00:09:41,110
and and run on the on the target device

00:09:37,180 --> 00:09:44,290
that might not always be the most

00:09:41,110 --> 00:09:48,430
convenient way but if the tests are

00:09:44,290 --> 00:09:54,310
maintained along the APK code then why

00:09:48,430 --> 00:09:58,510
not and then so what this is this is

00:09:54,310 --> 00:10:01,750
probably the example how it's supposed

00:09:58,510 --> 00:10:04,750
to be done when when the front end is

00:10:01,750 --> 00:10:07,990
our main goal like main focus so the

00:10:04,750 --> 00:10:11,020
test for for the front edge should come

00:10:07,990 --> 00:10:15,550
should be maintained along with the code

00:10:11,020 --> 00:10:17,680
from for the front end and then when

00:10:15,550 --> 00:10:21,250
something breaks then then we know

00:10:17,680 --> 00:10:24,070
exactly which version is in linaro we

00:10:21,250 --> 00:10:28,210
have a little bit different use case so

00:10:24,070 --> 00:10:30,040
we were taking the existing benchmarking

00:10:28,210 --> 00:10:33,070
applications which had a front end and

00:10:30,040 --> 00:10:34,570
we wanted to just automate the steps to

00:10:33,070 --> 00:10:37,630
run the benchmarks and then collect the

00:10:34,570 --> 00:10:42,820
benchmarks the benchmark scores in order

00:10:37,630 --> 00:10:45,580
to do it there and we wanted the script

00:10:42,820 --> 00:10:47,420
to that drives those those automated

00:10:45,580 --> 00:10:53,540
clicks to be

00:10:47,420 --> 00:10:56,090
easily changeable so there is a tool

00:10:53,540 --> 00:10:58,850
that's called Android new client that's

00:10:56,090 --> 00:11:01,880
basically a Titan wrapper around UI

00:10:58,850 --> 00:11:04,820
Automator it just forces UI Automator to

00:11:01,880 --> 00:11:06,970
dump the structure of the UI in the xml

00:11:04,820 --> 00:11:10,220
format and then allows you to navigate

00:11:06,970 --> 00:11:13,130
exposing the the methods for navigation

00:11:10,220 --> 00:11:14,630
and clicks and touches on the screen and

00:11:13,130 --> 00:11:17,960
everything that you are automator is

00:11:14,630 --> 00:11:21,110
actually able to do so this is how we

00:11:17,960 --> 00:11:22,940
wrote our tests and for it they are not

00:11:21,110 --> 00:11:25,370
really tests they are just a tool to

00:11:22,940 --> 00:11:28,220
drive the benchmarks the benchmarking I

00:11:25,370 --> 00:11:30,500
pk's to do what they are supposed to do

00:11:28,220 --> 00:11:33,290
which means produce the benchmarks so

00:11:30,500 --> 00:11:39,200
depending on the use case either native

00:11:33,290 --> 00:11:48,380
or the script approach is this is what

00:11:39,200 --> 00:11:50,620
can be done okay so chase chase to cover

00:11:48,380 --> 00:11:50,620
that

00:11:55,250 --> 00:12:03,300
for the low level system features or

00:11:59,580 --> 00:12:07,440
when we try to shell scripting we always

00:12:03,300 --> 00:12:11,220
try to do it in a pot buoy so basically

00:12:07,440 --> 00:12:15,750
you want to use part Michelle first to

00:12:11,220 --> 00:12:18,120
test a test case in debian a distributor

00:12:15,750 --> 00:12:22,709
you can use dash are you install it in

00:12:18,120 --> 00:12:25,170
your favorite tribution so if you are

00:12:22,709 --> 00:12:31,560
now using DVI Ubuntu you probably want

00:12:25,170 --> 00:12:37,410
to check if bindle SH point to pop out a

00:12:31,560 --> 00:12:39,899
shell we want to do this in it or want

00:12:37,410 --> 00:12:45,529
to do the test case in this way because

00:12:39,899 --> 00:12:50,750
we want to run everywhere there's party

00:12:45,529 --> 00:12:55,380
like politics compatible distributions

00:12:50,750 --> 00:13:00,680
so that's the initial point in doing

00:12:55,380 --> 00:13:03,870
this to make sure that your test code

00:13:00,680 --> 00:13:07,950
compile ball you can use them to like

00:13:03,870 --> 00:13:12,959
she'll check or check measures to expose

00:13:07,950 --> 00:13:16,920
the issues in the fix them normally does

00:13:12,959 --> 00:13:20,970
the tools were using in our daily

00:13:16,920 --> 00:13:25,110
development you can also found fancied

00:13:20,970 --> 00:13:29,540
the unit had to sell destitutes for this

00:13:25,110 --> 00:13:33,709
kind of unit tests are functional tests

00:13:29,540 --> 00:13:33,709
since i saw on this side

00:13:36,130 --> 00:13:41,420
so one other little part of this is that

00:13:39,080 --> 00:13:44,420
yes you've got a choice of bash and dash

00:13:41,420 --> 00:13:46,400
you pause gotta think about in a lot of

00:13:44,420 --> 00:13:48,650
cases you've actually dropped into a

00:13:46,400 --> 00:13:51,050
busy box shell and now you've got busy

00:13:48,650 --> 00:13:53,570
box ash which is very much more limited

00:13:51,050 --> 00:13:55,700
than any shell interpreter you end up

00:13:53,570 --> 00:13:57,860
using onion onion of your own laptops

00:13:55,700 --> 00:13:59,960
it's always worth if you're thinking of

00:13:57,860 --> 00:14:01,970
using such as I ends up in a busy box

00:13:59,960 --> 00:14:04,460
she'll get that test it on your own

00:14:01,970 --> 00:14:09,290
system using this box and see what the

00:14:04,460 --> 00:14:14,960
 she works and I guess we have a an

00:14:09,290 --> 00:14:21,200
example of the of the tote right the

00:14:14,960 --> 00:14:25,880
demo yep okay when I'll just switch

00:14:21,200 --> 00:14:28,910
right so i want to show two tools that

00:14:25,880 --> 00:14:33,760
are very useful to writing to write

00:14:28,910 --> 00:14:36,080
tests with that Sh unit 2 which is a

00:14:33,760 --> 00:14:45,490
implementation of the ex unit pattern

00:14:36,080 --> 00:14:45,490
for shell scripts in so

00:14:46,139 --> 00:14:52,779
is that ok chassis I think yeah so it

00:14:50,619 --> 00:14:56,019
implements the same thing as you have on

00:14:52,779 --> 00:14:58,809
X unit for any language in shell it's

00:14:56,019 --> 00:15:02,490
very useful to write this that's our

00:14:58,809 --> 00:15:05,350
nice V capsulated so if I one so it uses

00:15:02,490 --> 00:15:08,319
every shelf function that starts with

00:15:05,350 --> 00:15:10,029
death is a different test case and then

00:15:08,319 --> 00:15:13,269
you have the assertions as you as you

00:15:10,029 --> 00:15:15,670
have in other languages and if I want to

00:15:13,269 --> 00:15:18,339
rather add the new class I just add a

00:15:15,670 --> 00:15:21,879
new function here and it works it also

00:15:18,339 --> 00:15:24,369
support setup and teardown so code

00:15:21,879 --> 00:15:27,490
that's going to run before every test

00:15:24,369 --> 00:15:32,369
and then teardown school that we run

00:15:27,490 --> 00:15:32,369
after every test it also supports

00:15:33,029 --> 00:15:37,929
one-time setup and teardown so at the

00:15:35,980 --> 00:15:41,920
beginning of this script before of this

00:15:37,929 --> 00:15:44,050
then you can do something else and you

00:15:41,920 --> 00:15:47,199
can also run something when all the

00:15:44,050 --> 00:15:50,709
tests have exited so in this case here

00:15:47,199 --> 00:15:54,309
you you can for instance test the cut

00:15:50,709 --> 00:15:56,769
command and then you capture the output

00:15:54,309 --> 00:15:59,740
of any comment you want and then you can

00:15:56,769 --> 00:16:03,160
on park compared using an insertion with

00:15:59,740 --> 00:16:06,779
the expected result just like you do in

00:16:03,160 --> 00:16:10,870
any other language so it has a set of I

00:16:06,779 --> 00:16:17,550
think 10 or 12 as different types of

00:16:10,870 --> 00:16:20,499
assertions and then here you can also

00:16:17,550 --> 00:16:22,929
here's another example where you have a

00:16:20,499 --> 00:16:25,420
set true and then you pass an any

00:16:22,929 --> 00:16:28,540
arbitrary comment checking so if that

00:16:25,420 --> 00:16:30,339
common runs in and exit 0 then this

00:16:28,540 --> 00:16:35,279
assertion will pass otherwise it will

00:16:30,339 --> 00:16:39,189
fail so you in the documentation there's

00:16:35,279 --> 00:16:39,900
several examples of the supported

00:16:39,189 --> 00:16:43,050
assertion

00:16:39,900 --> 00:16:48,020
in here and that they only last bit is

00:16:43,050 --> 00:16:52,680
sourcing the SH unit to script here so

00:16:48,020 --> 00:16:55,740
so when running if your script does does

00:16:52,680 --> 00:16:59,340
not have that last line with the

00:16:55,740 --> 00:17:02,490
sourcing you can call it oh Sh you need

00:16:59,340 --> 00:17:04,560
to explicitly I have no idea what

00:17:02,490 --> 00:17:08,870
happens if you do this with the source

00:17:04,560 --> 00:17:13,830
there but if you just run with the show

00:17:08,870 --> 00:17:16,470
if we report the hazards so as new said

00:17:13,830 --> 00:17:20,130
you want to test that with as many

00:17:16,470 --> 00:17:22,770
shells as you want you can you can also

00:17:20,130 --> 00:17:27,839
run off bash you can also turn with

00:17:22,770 --> 00:17:30,060
busybox sh and it should work so if you

00:17:27,839 --> 00:17:34,770
have your test rating like these you

00:17:30,060 --> 00:17:37,530
cannot you can run your tests on the

00:17:34,770 --> 00:17:43,830
server Sheldon check that they work with

00:17:37,530 --> 00:17:47,820
everyone f with everything so

00:17:43,830 --> 00:17:50,159
this is a very useful tool and it's very

00:17:47,820 --> 00:17:54,659
convenient to organizing tests something

00:17:50,159 --> 00:18:02,100
that I came about more recently is a

00:17:54,659 --> 00:18:08,880
tool called CLI test which allows you to

00:18:02,100 --> 00:18:13,549
write plain text files with tests so one

00:18:08,880 --> 00:18:16,830
example is like this you can have a

00:18:13,549 --> 00:18:18,779
plain text file with every line that

00:18:16,830 --> 00:18:22,019
starts with a dollar is a comment that

00:18:18,779 --> 00:18:24,860
will be executed and then the following

00:18:22,019 --> 00:18:27,990
lines and you achoo before the next

00:18:24,860 --> 00:18:31,440
command is the output that you expect

00:18:27,990 --> 00:18:36,059
from this common so in this case it will

00:18:31,440 --> 00:18:38,519
be to run this command here and then it

00:18:36,059 --> 00:18:42,600
you pass if the output is like exactly

00:18:38,519 --> 00:18:45,769
this or fail you if it's not so it can

00:18:42,600 --> 00:18:45,769
hang here

00:18:48,390 --> 00:18:51,390
hmm

00:18:56,290 --> 00:19:05,590
when your undies we knows how to check

00:19:01,830 --> 00:19:08,410
another more advanced example it also

00:19:05,590 --> 00:19:11,980
supports embedding your tests each of

00:19:08,410 --> 00:19:15,220
documentation so you can have reducing

00:19:11,980 --> 00:19:19,090
early you Jesus for instance a markdown

00:19:15,220 --> 00:19:23,620
document with a betrayed text and then

00:19:19,090 --> 00:19:27,340
you you use here a markdown block with a

00:19:23,620 --> 00:19:30,280
tab so when you when you handle these

00:19:27,340 --> 00:19:33,700
using a microprocessor than these lines

00:19:30,280 --> 00:19:39,700
in the info tab will be in a code block

00:19:33,700 --> 00:19:42,280
so you have monospaced font and all that

00:19:39,700 --> 00:19:45,790
and then you can also process the same

00:19:42,280 --> 00:19:49,090
document with CLI test inhabit executor

00:19:45,790 --> 00:19:56,140
tests inch of the e in the index inbox

00:19:49,090 --> 00:19:59,070
so and then here you can say what prefix

00:19:56,140 --> 00:20:03,040
you want to use when running so you can

00:19:59,070 --> 00:20:05,200
have other if you have a different

00:20:03,040 --> 00:20:08,320
markup language then markdown work and

00:20:05,200 --> 00:20:12,970
also use other prefixes like four spaces

00:20:08,320 --> 00:20:16,920
or or greater than sign or something

00:20:12,970 --> 00:20:16,920
like that so it works the same way

00:20:19,890 --> 00:20:30,240
another example so obviously testing for

00:20:25,780 --> 00:20:32,950
the exact so if you want to omit the

00:20:30,240 --> 00:20:35,679
output lines for instance when you are

00:20:32,950 --> 00:20:38,320
using testing the documentation you can

00:20:35,679 --> 00:20:42,910
also use this special mark here which is

00:20:38,320 --> 00:20:46,390
a pound sign in the unicode right

00:20:42,910 --> 00:20:49,750
pointing arrow and then you can specify

00:20:46,390 --> 00:20:56,470
the expected output here instead of in a

00:20:49,750 --> 00:20:59,260
separate line is also the end result is

00:20:56,470 --> 00:21:05,500
the same but then the nicest feature is

00:20:59,260 --> 00:21:07,720
that you obvious did at specifying the

00:21:05,500 --> 00:21:10,150
exact up to that you expect for every

00:21:07,720 --> 00:21:15,429
test doesn't work for anything that's

00:21:10,150 --> 00:21:19,270
not review so you also have other types

00:21:15,429 --> 00:21:24,700
of tests that you that you can do so in

00:21:19,270 --> 00:21:26,740
this example here you have you use the

00:21:24,700 --> 00:21:29,230
magic marker here to say that you want

00:21:26,740 --> 00:21:33,910
in line checking and then you can pass

00:21:29,230 --> 00:21:35,650
several options that we specify what is

00:21:33,910 --> 00:21:39,610
that it needs to happen for this test to

00:21:35,650 --> 00:21:42,490
work so in this case the headline it

00:21:39,610 --> 00:21:45,250
must produce 10 lines of up I think it's

00:21:42,490 --> 00:21:47,590
at least hang lines of output so you you

00:21:45,250 --> 00:21:54,400
don't care exactly what is the output as

00:21:47,590 --> 00:21:57,580
long as it has 10 lines or more you can

00:21:54,400 --> 00:22:00,370
also specify the output must be the same

00:21:57,580 --> 00:22:03,160
as a given fire so for instance if you

00:22:00,370 --> 00:22:04,840
reverse the contents of a file twice you

00:22:03,160 --> 00:22:08,740
should end up with the same thing so

00:22:04,840 --> 00:22:11,320
this is what's being tested here you can

00:22:08,740 --> 00:22:13,929
also test for a given haggler expression

00:22:11,320 --> 00:22:17,860
in the output so in this case if the

00:22:13,929 --> 00:22:19,809
output matches root and the column in

00:22:17,860 --> 00:22:22,710
the beginning of a line then the test

00:22:19,809 --> 00:22:25,850
pass so if you have

00:22:22,710 --> 00:22:31,140
user on your season in these test passes

00:22:25,850 --> 00:22:37,350
you can also match for a regular

00:22:31,140 --> 00:22:39,750
expression yeah not sure what's the

00:22:37,350 --> 00:22:42,330
difference between the two but both take

00:22:39,750 --> 00:22:44,840
regular expressions so here you are

00:22:42,330 --> 00:22:49,350
testing that the result of shell

00:22:44,840 --> 00:22:52,110
arithmetic operation is a sequence of

00:22:49,350 --> 00:22:55,559
digits which should be always the case

00:22:52,110 --> 00:22:58,950
you can also test the as its exit status

00:22:55,559 --> 00:23:00,899
of common so if you don't care about the

00:22:58,950 --> 00:23:05,460
output you just care about the exit

00:23:00,899 --> 00:23:10,200
status or you can also pass an arbitrary

00:23:05,460 --> 00:23:12,240
comment and if the test comment in the

00:23:10,200 --> 00:23:14,700
one your say you are passing here

00:23:12,240 --> 00:23:20,010
produce the same output then the test

00:23:14,700 --> 00:23:23,460
passes then when you run these you you

00:23:20,010 --> 00:23:26,070
will see that it does the things it

00:23:23,460 --> 00:23:28,590
needs to do of course they make test

00:23:26,070 --> 00:23:33,059
here fails because there is no makefile

00:23:28,590 --> 00:23:36,299
but this is very powerful and lets you

00:23:33,059 --> 00:23:39,299
test several things that you can test in

00:23:36,299 --> 00:23:44,149
the comment line so you don't have to

00:23:39,299 --> 00:23:47,640
rely on the exact output of the common I

00:23:44,149 --> 00:23:50,419
think that's pretty much it and let

00:23:47,640 --> 00:23:50,419
people there instead

00:24:07,230 --> 00:24:15,750
okay thank you and I think the last the

00:24:13,410 --> 00:24:18,240
last bit we wanted to talk about is like

00:24:15,750 --> 00:24:26,010
what mistakes we made before we made in

00:24:18,240 --> 00:24:29,490
the past so in the previous iterations

00:24:26,010 --> 00:24:33,120
of the test suite that we call in our

00:24:29,490 --> 00:24:36,710
test Suites we assume that all the tests

00:24:33,120 --> 00:24:39,540
were run in lava that made our life

00:24:36,710 --> 00:24:42,870
pretty difficult when we wanted to add

00:24:39,540 --> 00:24:46,020
new tests they all had a prototype in

00:24:42,870 --> 00:24:51,900
the running environment of lava and

00:24:46,020 --> 00:24:53,669
that's not usually quick and create

00:24:51,900 --> 00:24:56,130
several other issues when for example

00:24:53,669 --> 00:25:03,080
lava deployment fails within a structure

00:24:56,130 --> 00:25:05,640
error so learned on those unpleasant

00:25:03,080 --> 00:25:09,210
experiences we wanted to change

00:25:05,640 --> 00:25:14,040
something and also based on the request

00:25:09,210 --> 00:25:18,000
from from people using our tests the

00:25:14,040 --> 00:25:20,700
changes the changes were designed so the

00:25:18,000 --> 00:25:22,860
first and I guess the most important one

00:25:20,700 --> 00:25:26,549
is that the tests are now possible to

00:25:22,860 --> 00:25:29,070
execute locally so we threw away all the

00:25:26,549 --> 00:25:32,220
costs lava test case from our tests and

00:25:29,070 --> 00:25:39,510
they are only used when you actually run

00:25:32,220 --> 00:25:41,750
the testing lava and then we also we

00:25:39,510 --> 00:25:46,530
also don't depend on lava feature that

00:25:41,750 --> 00:25:48,960
that is called the install section so so

00:25:46,530 --> 00:25:52,290
the installation part is also a part of

00:25:48,960 --> 00:25:55,110
the test at the moment it doesn't end on

00:25:52,290 --> 00:25:58,260
lava installing the proper stuff we have

00:25:55,110 --> 00:26:01,350
to do it ourselves this way we were able

00:25:58,260 --> 00:26:04,260
to support different distros so we have

00:26:01,350 --> 00:26:09,210
debian and ubuntu with

00:26:04,260 --> 00:26:11,490
with with the support for different

00:26:09,210 --> 00:26:14,940
package names in both these drawers we

00:26:11,490 --> 00:26:20,820
also have the RPM base fedora or Santos

00:26:14,940 --> 00:26:22,200
support then if if the tests are and all

00:26:20,820 --> 00:26:25,920
the dependencies for the tests are

00:26:22,200 --> 00:26:28,320
already built into the system that it's

00:26:25,920 --> 00:26:33,060
under test we can also skip the install

00:26:28,320 --> 00:26:34,980
part and and run the test directly the

00:26:33,060 --> 00:26:40,500
test results are saved to the temporary

00:26:34,980 --> 00:26:41,970
directory which might be not well that

00:26:40,500 --> 00:26:44,400
the assumption that there is some

00:26:41,970 --> 00:26:46,920
subdirectory we can write to is not

00:26:44,400 --> 00:26:53,670
always true but in for our use cases it

00:26:46,920 --> 00:26:55,770
is so we made this assumption and then

00:26:53,670 --> 00:26:58,680
parsing the test I'll show it on

00:26:55,770 --> 00:27:01,410
examples of parsing the test results for

00:26:58,680 --> 00:27:03,630
consumption in in lava for recording

00:27:01,410 --> 00:27:06,980
them in lava is done like as asked as

00:27:03,630 --> 00:27:10,320
the last step of the test execution and

00:27:06,980 --> 00:27:14,160
all the old tests that we run on AOSP

00:27:10,320 --> 00:27:17,010
are I executed now using adb link

00:27:14,160 --> 00:27:19,040
instead of running them directly on the

00:27:17,010 --> 00:27:21,900
target at least this is the assumption

00:27:19,040 --> 00:27:24,510
we didn't go yet through all the tests

00:27:21,900 --> 00:27:26,280
so it might not be always the case as I

00:27:24,510 --> 00:27:30,900
talk to young seen before just before

00:27:26,280 --> 00:27:32,820
the connect so we'll see but like at

00:27:30,900 --> 00:27:34,740
least we want to have all the tests

00:27:32,820 --> 00:27:38,580
executors from the house just like as

00:27:34,740 --> 00:27:43,380
any other user would do when testing the

00:27:38,580 --> 00:27:46,320
AOSP device on your bed and then about

00:27:43,380 --> 00:27:50,300
the integration to lava so there are two

00:27:46,320 --> 00:27:52,950
helper scripts that were introduced

00:27:50,300 --> 00:27:54,960
first is very simple sent to lava which

00:27:52,950 --> 00:27:58,950
parses the result file that we produce

00:27:54,960 --> 00:28:00,840
and the other one is test run our test

00:27:58,950 --> 00:28:03,960
runner allows you to run the tests

00:28:00,840 --> 00:28:06,120
locally in very similar way that would

00:28:03,960 --> 00:28:08,070
be done in lava that the test runner is

00:28:06,120 --> 00:28:10,530
much simpler than the lava dispatcher it

00:28:08,070 --> 00:28:13,170
just allows you to execute single or

00:28:10,530 --> 00:28:15,820
multiple tests from the from the yamu

00:28:13,170 --> 00:28:20,600
files and doesn't support any

00:28:15,820 --> 00:28:22,760
any multi nodes or I'm not sure what

00:28:20,600 --> 00:28:24,770
else but it's very simple you just run

00:28:22,760 --> 00:28:34,700
the test on the single device on your

00:28:24,770 --> 00:28:39,679
local bench if you mean inside the

00:28:34,700 --> 00:28:41,000
actual lava no it's not inside lava so

00:28:39,679 --> 00:28:43,690
the test runner is only meant for

00:28:41,000 --> 00:28:46,429
running the tests on the local bench and

00:28:43,690 --> 00:28:48,110
it sort of supposed to replace the

00:28:46,429 --> 00:28:50,059
dispatcher when we draw not running

00:28:48,110 --> 00:28:56,270
inside lava against like much less

00:28:50,059 --> 00:28:58,700
powerful than that so so as I guess

00:28:56,270 --> 00:29:00,350
chase can can add more but what would

00:28:58,700 --> 00:29:02,390
that test runner does it just converts

00:29:00,350 --> 00:29:04,730
the ammo filing to that shell script

00:29:02,390 --> 00:29:11,150
then runs at a shell script and collects

00:29:04,730 --> 00:29:14,809
the results as CSV or JSON or yeah we

00:29:11,150 --> 00:29:17,390
can say be safe booth yes csgn Jason and

00:29:14,809 --> 00:29:20,120
I guess we also produce a text file with

00:29:17,390 --> 00:29:23,770
the results txt files produced bad

00:29:20,120 --> 00:29:23,770
asking bye bye Felicia so

00:29:29,020 --> 00:29:34,520
does it also like I mean connect with

00:29:32,150 --> 00:29:43,610
the ADB and run the tests on the device

00:29:34,520 --> 00:29:47,090
are how it works so ok I can hear myself

00:29:43,610 --> 00:29:49,100
now well it assumes everything is done

00:29:47,090 --> 00:29:52,700
before that so it just execute the test

00:29:49,100 --> 00:29:54,650
nothing more ok so if you need to

00:29:52,700 --> 00:29:56,870
connect to a DB you have to make sure

00:29:54,650 --> 00:29:59,360
that the IDB connection is there before

00:29:56,870 --> 00:30:01,789
you start executing your test it doesn't

00:29:59,360 --> 00:30:03,770
do any work that dispatcher does like it

00:30:01,789 --> 00:30:07,880
doesn't flash the device it doesn't make

00:30:03,770 --> 00:30:09,799
you make this linaro like lava overlay

00:30:07,880 --> 00:30:21,679
or anything like that it just execute

00:30:09,799 --> 00:30:25,280
the test so so I have an example ok so i

00:30:21,679 --> 00:30:32,330
have an example here on what the test

00:30:25,280 --> 00:30:35,289
used to be and what they are now Dwight

00:30:32,330 --> 00:30:35,289
ok

00:30:36,180 --> 00:30:42,330
try Justin Queen the food Go Fish Plus

00:30:47,710 --> 00:30:51,029
it should be good enough

00:30:56,430 --> 00:31:02,800
so this is the version one or the

00:31:00,130 --> 00:31:06,250
previous state of the tests that we use

00:31:02,800 --> 00:31:08,200
for smoke testing the devices so the

00:31:06,250 --> 00:31:10,330
first part actually doesn't change its

00:31:08,200 --> 00:31:13,810
more or less to say it will be the same

00:31:10,330 --> 00:31:16,930
on on the version 2 but what changes is

00:31:13,810 --> 00:31:20,380
the the run step so as you can see all

00:31:16,930 --> 00:31:23,110
the tests are wrapped here around lava

00:31:20,380 --> 00:31:25,660
test case so when executing locally

00:31:23,110 --> 00:31:29,680
without the lava test case scrip well it

00:31:25,660 --> 00:31:31,570
won't work it won't do anything so it

00:31:29,680 --> 00:31:36,000
assumes that we are running inside lava

00:31:31,570 --> 00:31:36,000
now okay

00:31:51,160 --> 00:31:59,080
alright so this is exactly the same test

00:31:53,770 --> 00:32:02,740
after after we rewrite it does the same

00:31:59,080 --> 00:32:04,300
thing the the difference is that like on

00:32:02,740 --> 00:32:07,420
the on the right hand side there is the

00:32:04,300 --> 00:32:09,580
Yama file that egg that can be executed

00:32:07,420 --> 00:32:14,470
either in lava or in our local test

00:32:09,580 --> 00:32:17,740
runner so as you can see it like in the

00:32:14,470 --> 00:32:19,300
steps it only has like execute the shell

00:32:17,740 --> 00:32:23,290
script the shell script is on the left

00:32:19,300 --> 00:32:26,530
hand side so the shell script takes care

00:32:23,290 --> 00:32:32,410
of first installing all the dependencies

00:32:26,530 --> 00:32:34,750
and then running the tests so here are

00:32:32,410 --> 00:32:37,060
here are the steps so first you install

00:32:34,750 --> 00:32:39,580
and then you run all the same commands

00:32:37,060 --> 00:32:43,000
that will run previously but we can run

00:32:39,580 --> 00:32:46,060
it Dow or our local device without lava

00:32:43,000 --> 00:32:48,040
we can run either using the script

00:32:46,060 --> 00:32:51,220
itself it will produce the output of the

00:32:48,040 --> 00:32:55,690
text file or we can run using our test

00:32:51,220 --> 00:32:58,030
runner using the Yama file which will

00:32:55,690 --> 00:33:01,150
produce exactly the same output and then

00:32:58,030 --> 00:33:04,390
if the tests is going to be run inside

00:33:01,150 --> 00:33:07,210
lava will use the same the same Yama

00:33:04,390 --> 00:33:13,780
file which we run the same shell script

00:33:07,210 --> 00:33:16,000
and then the last step in the last step

00:33:13,780 --> 00:33:19,290
in the in the test says like center to

00:33:16,000 --> 00:33:23,710
lava which will record the test results

00:33:19,290 --> 00:33:29,830
as lava tests when running when running

00:33:23,710 --> 00:33:32,050
on a proper lava instance question I'm

00:33:29,830 --> 00:33:33,840
just just thinking just to reinforce

00:33:32,050 --> 00:33:35,800
here this is something that we are

00:33:33,840 --> 00:33:37,570
recommending

00:33:35,800 --> 00:33:39,130
from the lava software team as well as

00:33:37,570 --> 00:33:41,290
dust from the QA it's not as if kawai

00:33:39,130 --> 00:33:44,590
doing this on the road in case of there

00:33:41,290 --> 00:33:46,390
are good reasons why this is a these are

00:33:44,590 --> 00:33:48,610
best practices or everybody using lava

00:33:46,390 --> 00:33:51,220
that you should think about making these

00:33:48,610 --> 00:33:53,200
things portable and making them easier

00:33:51,220 --> 00:33:55,600
for you to debug that's what this is all

00:33:53,200 --> 00:33:57,520
about it's actually something that we're

00:33:55,600 --> 00:34:00,390
working on together to make sure that we

00:33:57,520 --> 00:34:00,390
actually get a better solution

00:34:09,080 --> 00:34:15,350
right so that brings us to the end of

00:34:11,660 --> 00:34:18,110
what we have to show so if there is

00:34:15,350 --> 00:34:22,220
anyone who would like to share their and

00:34:18,110 --> 00:34:25,070
their opinion or their experience on on

00:34:22,220 --> 00:34:28,060
good or bad practices writing test I

00:34:25,070 --> 00:34:28,060
welcome you

00:34:36,130 --> 00:34:40,200
I guess that concludes this session

00:34:43,079 --> 00:34:49,589
yeah okay thanks for watching one they

00:34:47,339 --> 00:34:51,799
were lashed mention is that we're doing

00:34:49,589 --> 00:34:53,729
something very similar in our own

00:34:51,799 --> 00:34:56,459
functional testing inside the lava

00:34:53,729 --> 00:35:00,059
software teams when we run our own unit

00:34:56,459 --> 00:35:02,009
tests of our packaged product inside

00:35:00,059 --> 00:35:03,569
lava so doing our own dog food testing

00:35:02,009 --> 00:35:06,059
we're doing exactly the same kind of

00:35:03,569 --> 00:35:07,829
thing oh we run the tests in a custom

00:35:06,059 --> 00:35:09,359
script that runs exactly the same way as

00:35:07,829 --> 00:35:12,959
it does on my on everybody else's

00:35:09,359 --> 00:35:15,450
machines and then we do handling of that

00:35:12,959 --> 00:35:18,269
after that is run to generate all the

00:35:15,450 --> 00:35:20,789
lava test case calls if Robert S quiz

00:35:18,269 --> 00:35:22,920
has been requested to it sustained model

00:35:20,789 --> 00:35:24,959
and they'll be doing it for the exactly

00:35:22,920 --> 00:35:27,930
the same reasons that you need to be

00:35:24,959 --> 00:35:30,239
able to debug these things outside lava

00:35:27,930 --> 00:35:32,249
as well as inside lava there as you

00:35:30,239 --> 00:35:34,200
start to build more more complex tests

00:35:32,249 --> 00:35:36,690
you bring in mantener to bring in other

00:35:34,200 --> 00:35:38,539
areas like that as well it becomes all

00:35:36,690 --> 00:35:42,499
the more important that you've got

00:35:38,539 --> 00:35:45,599
individual blocks that you can prove and

00:35:42,499 --> 00:35:47,969
deeper and improve independently and

00:35:45,599 --> 00:35:52,099
then you could test it box together to

00:35:47,969 --> 00:35:52,099
make a more complex test job in the end

00:36:00,750 --> 00:36:07,330
are there people using this outside of

00:36:03,370 --> 00:36:10,750
your team so we just introduced it like

00:36:07,330 --> 00:36:13,720
a month ago so no not yet there is a

00:36:10,750 --> 00:36:17,170
plan to actually deprecated the old

00:36:13,720 --> 00:36:18,640
approach and just switch to the new test

00:36:17,170 --> 00:36:25,210
so if there is someone using the old

00:36:18,640 --> 00:36:28,540
test they should stop doing that and you

00:36:25,210 --> 00:36:32,230
guys have a schema for the test that you

00:36:28,540 --> 00:36:34,450
will execute into that version like as

00:36:32,230 --> 00:36:39,630
you change the two or the parser the

00:36:34,450 --> 00:36:43,300
executor well yeah the test runner is

00:36:39,630 --> 00:36:46,810
compatible between v1 and v2 0 so it

00:36:43,300 --> 00:36:49,750
runs both the difference is that all the

00:36:46,810 --> 00:36:52,180
tests that we had so far were deeply

00:36:49,750 --> 00:36:54,400
depending on lava dispatcher features

00:36:52,180 --> 00:36:58,000
now we want to avoid that and another

00:36:54,400 --> 00:36:59,860
for local execution so that's that's

00:36:58,000 --> 00:37:02,190
probably the main reason for doing this

00:36:59,860 --> 00:37:02,190
work

00:37:08,380 --> 00:37:11,279
anyone else

00:37:12,460 --> 00:37:16,109
okay thanks

00:37:16,170 --> 00:37:21,059
[Applause]

00:37:24,700 --> 00:37:26,760

YouTube URL: https://www.youtube.com/watch?v=_O3biENV1gc


